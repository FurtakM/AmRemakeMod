// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 58 0 0
// InitMacro ;
   8: CALL 25957 0 0
// InitNature ;
  12: CALL 25781 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// PrepareAlliance ;
  29: CALL 8360 0 0
// PrepareRussian ;
  33: CALL 5575 0 0
// PrepareLegion ;
  37: CALL 3674 0 0
// PreparePowell ;
  41: CALL 2428 0 0
// PrepareAmerican ;
  45: CALL 1258 0 0
// Action ;
  49: CALL 9595 0 0
// MC_Start ( ) ;
  53: CALL 27104 0 0
// end ;
  57: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured ; export function InitVariables ; begin
  58: LD_INT 0
  60: PPUSH
// debug := 1 ;
  61: LD_ADDR_EXP 1
  65: PUSH
  66: LD_INT 1
  68: ST_TO_ADDR
// missionStart := false ;
  69: LD_ADDR_EXP 13
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// missionTime := 0 0$00 ;
  77: LD_ADDR_EXP 14
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// missionStage := 1 ;
  85: LD_ADDR_EXP 15
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// activeAttacks := false ;
  93: LD_ADDR_EXP 16
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// powellAnger := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// powellAllowRetreat := true ;
 109: LD_ADDR_EXP 19
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// powellCenterCameraMode := false ;
 117: LD_ADDR_EXP 20
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 125: LD_ADDR_EXP 18
 129: PUSH
 130: EMPTY
 131: PUSH
 132: EMPTY
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// russianDestroyed := false ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// legionDestroyed := false ;
 146: LD_ADDR_EXP 22
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// allianceDestroyed := false ;
 154: LD_ADDR_EXP 23
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 2
 166: PUSH
 167: LD_STRING 14_KappaStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 3
 182: PUSH
 183: LD_STRING 06_KurtStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 194: LD_ADDR_EXP 4
 198: PUSH
 199: LD_STRING 14_JMMVeh_1
 201: PPUSH
 202: LD_INT 0
 204: PPUSH
 205: CALL_OW 30
 209: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 210: LD_ADDR_EXP 5
 214: PUSH
 215: LD_STRING 14_JMMGirlVeh_1
 217: PPUSH
 218: LD_INT 0
 220: PPUSH
 221: CALL_OW 30
 225: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 226: LD_ADDR_EXP 7
 230: PUSH
 231: LD_STRING 14_JMMGirl_1
 233: PPUSH
 234: LD_INT 0
 236: PPUSH
 237: CALL_OW 30
 241: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 242: LD_ADDR_EXP 6
 246: PUSH
 247: LD_STRING 14_JMMGirlStatus_1
 249: PPUSH
 250: LD_INT 0
 252: PPUSH
 253: CALL_OW 30
 257: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 258: LD_ADDR_EXP 8
 262: PUSH
 263: LD_STRING 10_KhatamStatus_1
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 30
 273: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 274: LD_ADDR_EXP 9
 278: PUSH
 279: LD_STRING 13_BurlakStatus_1
 281: PPUSH
 282: LD_INT 0
 284: PPUSH
 285: CALL_OW 30
 289: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 290: LD_ADDR_EXP 10
 294: PUSH
 295: LD_STRING 13_StevensStatus_1
 297: PPUSH
 298: LD_INT 0
 300: PPUSH
 301: CALL_OW 30
 305: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 306: LD_ADDR_EXP 11
 310: PUSH
 311: LD_STRING 14_FastEnd_1
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: CALL_OW 30
 321: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 322: LD_ADDR_EXP 12
 326: PUSH
 327: LD_STRING 12_MainDepositFake_1
 329: PPUSH
 330: LD_INT 0
 332: PPUSH
 333: CALL_OW 30
 337: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 338: LD_ADDR_EXP 24
 342: PUSH
 343: LD_INT 1
 345: ST_TO_ADDR
// behemothUnderConstruct := false ;
 346: LD_ADDR_EXP 26
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 354: LD_ADDR_EXP 27
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// behemothDone := false ;
 362: LD_ADDR_EXP 28
 366: PUSH
 367: LD_INT 0
 369: ST_TO_ADDR
// allowBehemothConstruct := false ;
 370: LD_ADDR_EXP 25
 374: PUSH
 375: LD_INT 0
 377: ST_TO_ADDR
// seeBehemoth := false ;
 378: LD_ADDR_EXP 29
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// platonovHasBomb := false ;
 386: LD_ADDR_EXP 30
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// allianceActive := false ;
 394: LD_ADDR_EXP 31
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// rothCaptured := false ;
 402: LD_ADDR_EXP 33
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// lostCounter := 0 ;
 410: LD_ADDR_EXP 32
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 1
 422: RET
// export function CustomInitMacro ( ) ; begin
 423: LD_INT 0
 425: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 426: LD_ADDR_EXP 117
 430: PUSH
 431: LD_INT 2
 433: PUSH
 434: LD_INT 3
 436: PUSH
 437: LD_INT 6
 439: PUSH
 440: LD_INT 10
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 449: LD_ADDR_EXP 118
 453: PUSH
 454: LD_INT 1
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: LD_INT 5
 462: PUSH
 463: LD_INT 9
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 472: LD_INT 1
 474: PPUSH
 475: LD_INT 10
 477: PUSH
 478: LD_INT 11
 480: PUSH
 481: LD_INT 12
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: PPUSH
 489: CALL 48637 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 17
 498: PUSH
 499: EMPTY
 500: LIST
 501: PPUSH
 502: CALL 48730 0 2
// MC_SetTame ( 1 , allianceCratesArea ) ;
 506: LD_INT 1
 508: PPUSH
 509: LD_INT 17
 511: PPUSH
 512: CALL 48461 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 516: LD_INT 2
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: LD_INT 14
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 48637 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 541: LD_INT 2
 543: PPUSH
 544: LD_INT 16
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 48730 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 21
 559: PUSH
 560: LD_INT 3
 562: PUSH
 563: LD_INT 3
 565: PUSH
 566: LD_INT 51
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PUSH
 575: EMPTY
 576: LIST
 577: PPUSH
 578: CALL 47900 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 582: LD_INT 2
 584: PPUSH
 585: LD_INT 0
 587: PPUSH
 588: CALL 48510 0 2
// MC_SetMinesField ( 2 , [ 7 , 8 , 9 ] [ Difficulty ] , legionMinefield ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 7
 597: PUSH
 598: LD_INT 8
 600: PUSH
 601: LD_INT 9
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: PPUSH
 615: LD_INT 27
 617: PPUSH
 618: CALL 47582 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 622: LD_INT 3
 624: PPUSH
 625: LD_INT 10
 627: PUSH
 628: LD_INT 11
 630: PUSH
 631: LD_INT 13
 633: PUSH
 634: LD_INT 15
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PPUSH
 643: CALL 48637 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 647: LD_INT 3
 649: PPUSH
 650: LD_INT 15
 652: PUSH
 653: EMPTY
 654: LIST
 655: PPUSH
 656: CALL 48730 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 660: LD_ADDR_EXP 122
 664: PUSH
 665: LD_EXP 122
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 22
 675: PUSH
 676: LD_INT 8
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: PUSH
 683: LD_INT 25
 685: PUSH
 686: LD_INT 15
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL_OW 69
 701: PPUSH
 702: CALL_OW 1
 706: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 707: LD_INT 3
 709: PPUSH
 710: LD_INT 13
 712: PUSH
 713: LD_INT 2
 715: PUSH
 716: LD_INT 1
 718: PUSH
 719: LD_INT 31
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 2
 733: PUSH
 734: LD_INT 1
 736: PUSH
 737: LD_INT 31
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_INT 13
 748: PUSH
 749: LD_INT 3
 751: PUSH
 752: LD_INT 2
 754: PUSH
 755: LD_INT 32
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: PPUSH
 769: CALL 47900 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 773: LD_INT 4
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: PPUSH
 786: CALL 48637 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 790: LD_INT 4
 792: PPUSH
 793: LD_INT 9
 795: PUSH
 796: EMPTY
 797: LIST
 798: PPUSH
 799: CALL 48730 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
 803: LD_INT 4
 805: PPUSH
 806: LD_INT 26
 808: PUSH
 809: LD_INT 74
 811: PUSH
 812: LD_INT 107
 814: PUSH
 815: LD_INT 0
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 32
 826: PUSH
 827: LD_INT 77
 829: PUSH
 830: LD_INT 101
 832: PUSH
 833: LD_INT 4
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 32
 844: PUSH
 845: LD_INT 69
 847: PUSH
 848: LD_INT 86
 850: PUSH
 851: LD_INT 4
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PUSH
 860: LD_INT 27
 862: PUSH
 863: LD_INT 77
 865: PUSH
 866: LD_INT 110
 868: PUSH
 869: LD_INT 3
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: LIST
 877: PUSH
 878: LD_INT 27
 880: PUSH
 881: LD_INT 42
 883: PUSH
 884: LD_INT 79
 886: PUSH
 887: LD_INT 5
 889: PUSH
 890: EMPTY
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: PUSH
 896: LD_INT 29
 898: PUSH
 899: LD_INT 86
 901: PUSH
 902: LD_INT 105
 904: PUSH
 905: LD_INT 2
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: PUSH
 914: LD_INT 30
 916: PUSH
 917: LD_INT 40
 919: PUSH
 920: LD_INT 75
 922: PUSH
 923: LD_INT 1
 925: PUSH
 926: EMPTY
 927: LIST
 928: LIST
 929: LIST
 930: LIST
 931: PUSH
 932: LD_INT 32
 934: PUSH
 935: LD_INT 80
 937: PUSH
 938: LD_INT 106
 940: PUSH
 941: LD_INT 4
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PUSH
 950: LD_INT 32
 952: PUSH
 953: LD_INT 75
 955: PUSH
 956: LD_INT 114
 958: PUSH
 959: LD_INT 5
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: LIST
 966: LIST
 967: PUSH
 968: LD_INT 32
 970: PUSH
 971: LD_INT 82
 973: PUSH
 974: LD_INT 110
 976: PUSH
 977: LD_INT 5
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 32
 988: PUSH
 989: LD_INT 62
 991: PUSH
 992: LD_INT 78
 994: PUSH
 995: LD_INT 4
 997: PUSH
 998: EMPTY
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 4
1006: PUSH
1007: LD_INT 39
1009: PUSH
1010: LD_INT 61
1012: PUSH
1013: LD_INT 3
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: EMPTY
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL 47792 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1040: LD_INT 4
1042: PPUSH
1043: LD_INT 5
1045: PUSH
1046: LD_INT 6
1048: PUSH
1049: LD_INT 7
1051: PUSH
1052: LD_INT 9
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: PPUSH
1061: CALL 49048 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 40
1070: PUSH
1071: LD_INT 75
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 86
1084: PUSH
1085: LD_INT 105
1087: PUSH
1088: LD_INT 0
1090: PUSH
1091: EMPTY
1092: LIST
1093: LIST
1094: LIST
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: PPUSH
1100: CALL 48282 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1104: LD_INT 4
1106: PPUSH
1107: LD_INT 2
1109: PPUSH
1110: CALL 48510 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1114: LD_INT 4
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL 48510 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 19
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PPUSH
1154: CALL 48842 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1158: LD_INT 4
1160: PPUSH
1161: LD_INT 3
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 1
1169: PUSH
1170: LD_INT 5
1172: PUSH
1173: EMPTY
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: PUSH
1179: LD_INT 4
1181: PUSH
1182: LD_INT 1
1184: PUSH
1185: LD_INT 1
1187: PUSH
1188: LD_INT 6
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 4
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: LD_INT 1
1205: PUSH
1206: LD_INT 7
1208: PUSH
1209: EMPTY
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: LD_INT 4
1217: PUSH
1218: LD_INT 1
1220: PUSH
1221: LD_INT 1
1223: PUSH
1224: LD_INT 6
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: PPUSH
1239: CALL 47900 0 2
// MC_SetTame ( 4 , powellApe ) ;
1243: LD_INT 4
1245: PPUSH
1246: LD_INT 13
1248: PPUSH
1249: CALL 48461 0 2
// end ; end_of_file
1253: LD_VAR 0 1
1257: RET
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1258: LD_INT 0
1260: PPUSH
// uc_side := 1 ;
1261: LD_ADDR_OWVAR 20
1265: PUSH
1266: LD_INT 1
1268: ST_TO_ADDR
// uc_nation := 1 ;
1269: LD_ADDR_OWVAR 21
1273: PUSH
1274: LD_INT 1
1276: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1277: LD_ADDR_EXP 34
1281: PUSH
1282: LD_STRING JMM
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_STRING 14_
1293: PPUSH
1294: CALL 53843 0 3
1298: ST_TO_ADDR
// if not JMMVeh then
1299: LD_EXP 4
1303: NOT
1304: IFFALSE 1327
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1306: LD_INT 3
1308: PPUSH
1309: LD_INT 3
1311: PPUSH
1312: LD_INT 1
1314: PPUSH
1315: LD_INT 5
1317: PPUSH
1318: LD_INT 100
1320: PPUSH
1321: CALL 60476 0 5
1325: GO 1386
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1327: LD_EXP 4
1331: PUSH
1332: LD_INT 1
1334: ARRAY
1335: PUSH
1336: LD_INT 1
1338: ARRAY
1339: PPUSH
1340: LD_EXP 4
1344: PUSH
1345: LD_INT 2
1347: ARRAY
1348: PUSH
1349: LD_INT 1
1351: ARRAY
1352: PPUSH
1353: LD_EXP 4
1357: PUSH
1358: LD_INT 3
1360: ARRAY
1361: PUSH
1362: LD_INT 1
1364: ARRAY
1365: PPUSH
1366: LD_EXP 4
1370: PUSH
1371: LD_INT 4
1373: ARRAY
1374: PUSH
1375: LD_INT 1
1377: ARRAY
1378: PPUSH
1379: LD_INT 30
1381: PPUSH
1382: CALL 60476 0 5
// JMMNewVeh := CreateVehicle ;
1386: LD_ADDR_EXP 51
1390: PUSH
1391: CALL_OW 45
1395: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1396: LD_EXP 51
1400: PPUSH
1401: LD_INT 4
1403: PPUSH
1404: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1408: LD_EXP 51
1412: PPUSH
1413: LD_INT 75
1415: PPUSH
1416: LD_INT 92
1418: PPUSH
1419: LD_INT 0
1421: PPUSH
1422: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1426: LD_EXP 34
1430: PPUSH
1431: LD_EXP 51
1435: PPUSH
1436: CALL_OW 52
// if JMMGirl and not KappaStatus then
1440: LD_EXP 7
1444: PUSH
1445: LD_EXP 2
1449: NOT
1450: AND
1451: IFFALSE 1709
// begin if not JMMGirlVeh then
1453: LD_EXP 5
1457: NOT
1458: IFFALSE 1481
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1460: LD_INT 3
1462: PPUSH
1463: LD_INT 3
1465: PPUSH
1466: LD_INT 1
1468: PPUSH
1469: LD_INT 9
1471: PPUSH
1472: LD_INT 100
1474: PPUSH
1475: CALL 60476 0 5
1479: GO 1540
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1481: LD_EXP 5
1485: PUSH
1486: LD_INT 1
1488: ARRAY
1489: PUSH
1490: LD_INT 1
1492: ARRAY
1493: PPUSH
1494: LD_EXP 5
1498: PUSH
1499: LD_INT 2
1501: ARRAY
1502: PUSH
1503: LD_INT 1
1505: ARRAY
1506: PPUSH
1507: LD_EXP 5
1511: PUSH
1512: LD_INT 3
1514: ARRAY
1515: PUSH
1516: LD_INT 1
1518: ARRAY
1519: PPUSH
1520: LD_EXP 5
1524: PUSH
1525: LD_INT 4
1527: ARRAY
1528: PUSH
1529: LD_INT 1
1531: ARRAY
1532: PPUSH
1533: LD_INT 30
1535: PPUSH
1536: CALL 60476 0 5
// GirlNewVeh := CreateVehicle ;
1540: LD_ADDR_EXP 52
1544: PUSH
1545: CALL_OW 45
1549: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1550: LD_EXP 52
1554: PPUSH
1555: LD_INT 4
1557: PPUSH
1558: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1562: LD_EXP 52
1566: PPUSH
1567: LD_INT 82
1569: PPUSH
1570: LD_INT 96
1572: PPUSH
1573: LD_INT 0
1575: PPUSH
1576: CALL_OW 48
// if JMMGirl = 1 then
1580: LD_EXP 7
1584: PUSH
1585: LD_INT 1
1587: EQUAL
1588: IFFALSE 1623
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING Joan
1597: PPUSH
1598: LD_INT 1
1600: PPUSH
1601: LD_STRING 14_
1603: PPUSH
1604: CALL 53843 0 3
1608: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1609: LD_EXP 35
1613: PPUSH
1614: LD_EXP 52
1618: PPUSH
1619: CALL_OW 52
// end ; if JMMGirl = 2 then
1623: LD_EXP 7
1627: PUSH
1628: LD_INT 2
1630: EQUAL
1631: IFFALSE 1666
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1633: LD_ADDR_EXP 37
1637: PUSH
1638: LD_STRING Lisa
1640: PPUSH
1641: LD_INT 1
1643: PPUSH
1644: LD_STRING 14_
1646: PPUSH
1647: CALL 53843 0 3
1651: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1652: LD_EXP 37
1656: PPUSH
1657: LD_EXP 52
1661: PPUSH
1662: CALL_OW 52
// end ; if JMMGirl = 3 then
1666: LD_EXP 7
1670: PUSH
1671: LD_INT 3
1673: EQUAL
1674: IFFALSE 1709
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
1676: LD_ADDR_EXP 49
1680: PUSH
1681: LD_STRING Connie
1683: PPUSH
1684: LD_INT 1
1686: PPUSH
1687: LD_STRING 14_
1689: PPUSH
1690: CALL 53843 0 3
1694: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
1695: LD_EXP 49
1699: PPUSH
1700: LD_EXP 52
1704: PPUSH
1705: CALL_OW 52
// end ; end ; end ;
1709: LD_VAR 0 1
1713: RET
// export function PrepareStevensSquad ; var tmp ; begin
1714: LD_INT 0
1716: PPUSH
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
1734: LD_ADDR_EXP 36
1738: PUSH
1739: LD_STRING Stevens
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13f_
1750: PPUSH
1751: CALL 53843 0 3
1755: ST_TO_ADDR
// if not Stevens then
1756: LD_EXP 36
1760: NOT
1761: IFFALSE 1817
// begin hc_name = Baker Smith ;
1763: LD_ADDR_OWVAR 26
1767: PUSH
1768: LD_STRING Baker Smith
1770: ST_TO_ADDR
// hc_gallery =  ;
1771: LD_ADDR_OWVAR 33
1775: PUSH
1776: LD_STRING 
1778: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
1779: LD_INT 1
1781: PPUSH
1782: LD_INT 10
1784: PPUSH
1785: CALL_OW 384
// Baker = CreateHuman ;
1789: LD_ADDR_EXP 50
1793: PUSH
1794: CALL_OW 44
1798: ST_TO_ADDR
// tmp := tmp ^ Baker ;
1799: LD_ADDR_VAR 0 2
1803: PUSH
1804: LD_VAR 0 2
1808: PUSH
1809: LD_EXP 50
1813: ADD
1814: ST_TO_ADDR
// end else
1815: GO 1833
// tmp := tmp ^ Stevens ;
1817: LD_ADDR_VAR 0 2
1821: PUSH
1822: LD_VAR 0 2
1826: PUSH
1827: LD_EXP 36
1831: ADD
1832: ST_TO_ADDR
// if not Lisa then
1833: LD_EXP 37
1837: NOT
1838: IFFALSE 1884
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
1840: LD_ADDR_EXP 37
1844: PUSH
1845: LD_STRING Lisa
1847: PPUSH
1848: LD_EXP 1
1852: NOT
1853: PPUSH
1854: LD_STRING 13f_
1856: PPUSH
1857: CALL 53843 0 3
1861: ST_TO_ADDR
// if Lisa then
1862: LD_EXP 37
1866: IFFALSE 1884
// tmp := tmp ^ Lisa ;
1868: LD_ADDR_VAR 0 2
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: LD_EXP 37
1882: ADD
1883: ST_TO_ADDR
// end ; if not Donaldson then
1884: LD_EXP 38
1888: NOT
1889: IFFALSE 1935
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
1891: LD_ADDR_EXP 38
1895: PUSH
1896: LD_STRING Donaldson
1898: PPUSH
1899: LD_EXP 1
1903: NOT
1904: PPUSH
1905: LD_STRING 13f_
1907: PPUSH
1908: CALL 53843 0 3
1912: ST_TO_ADDR
// if Donaldson then
1913: LD_EXP 38
1917: IFFALSE 1935
// tmp := tmp ^ Donaldson ;
1919: LD_ADDR_VAR 0 2
1923: PUSH
1924: LD_VAR 0 2
1928: PUSH
1929: LD_EXP 38
1933: ADD
1934: ST_TO_ADDR
// end ; if not Bobby then
1935: LD_EXP 39
1939: NOT
1940: IFFALSE 1986
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
1942: LD_ADDR_EXP 39
1946: PUSH
1947: LD_STRING Bobby
1949: PPUSH
1950: LD_EXP 1
1954: NOT
1955: PPUSH
1956: LD_STRING 13f_
1958: PPUSH
1959: CALL 53843 0 3
1963: ST_TO_ADDR
// if Bobby then
1964: LD_EXP 39
1968: IFFALSE 1986
// tmp := tmp ^ Bobby ;
1970: LD_ADDR_VAR 0 2
1974: PUSH
1975: LD_VAR 0 2
1979: PUSH
1980: LD_EXP 39
1984: ADD
1985: ST_TO_ADDR
// end ; if not Cyrus then
1986: LD_EXP 40
1990: NOT
1991: IFFALSE 2037
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
1993: LD_ADDR_EXP 40
1997: PUSH
1998: LD_STRING Cyrus
2000: PPUSH
2001: LD_EXP 1
2005: NOT
2006: PPUSH
2007: LD_STRING 13f_
2009: PPUSH
2010: CALL 53843 0 3
2014: ST_TO_ADDR
// if Cyrus then
2015: LD_EXP 40
2019: IFFALSE 2037
// tmp := tmp ^ Cyrus ;
2021: LD_ADDR_VAR 0 2
2025: PUSH
2026: LD_VAR 0 2
2030: PUSH
2031: LD_EXP 40
2035: ADD
2036: ST_TO_ADDR
// end ; if not Brown then
2037: LD_EXP 42
2041: NOT
2042: IFFALSE 2088
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2044: LD_ADDR_EXP 42
2048: PUSH
2049: LD_STRING Brown
2051: PPUSH
2052: LD_EXP 1
2056: NOT
2057: PPUSH
2058: LD_STRING 13f_
2060: PPUSH
2061: CALL 53843 0 3
2065: ST_TO_ADDR
// if Brown then
2066: LD_EXP 42
2070: IFFALSE 2088
// tmp := tmp ^ Brown ;
2072: LD_ADDR_VAR 0 2
2076: PUSH
2077: LD_VAR 0 2
2081: PUSH
2082: LD_EXP 42
2086: ADD
2087: ST_TO_ADDR
// end ; if not Gladstone then
2088: LD_EXP 43
2092: NOT
2093: IFFALSE 2139
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2095: LD_ADDR_EXP 43
2099: PUSH
2100: LD_STRING Gladstone
2102: PPUSH
2103: LD_EXP 1
2107: NOT
2108: PPUSH
2109: LD_STRING 13f_
2111: PPUSH
2112: CALL 53843 0 3
2116: ST_TO_ADDR
// if Gladstone then
2117: LD_EXP 43
2121: IFFALSE 2139
// tmp := tmp ^ Gladstone ;
2123: LD_ADDR_VAR 0 2
2127: PUSH
2128: LD_VAR 0 2
2132: PUSH
2133: LD_EXP 43
2137: ADD
2138: ST_TO_ADDR
// end ; if not Houten then
2139: LD_EXP 44
2143: NOT
2144: IFFALSE 2190
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2146: LD_ADDR_EXP 44
2150: PUSH
2151: LD_STRING Houten
2153: PPUSH
2154: LD_EXP 1
2158: NOT
2159: PPUSH
2160: LD_STRING 13f_
2162: PPUSH
2163: CALL 53843 0 3
2167: ST_TO_ADDR
// if Houten then
2168: LD_EXP 44
2172: IFFALSE 2190
// tmp := tmp ^ Houten ;
2174: LD_ADDR_VAR 0 2
2178: PUSH
2179: LD_VAR 0 2
2183: PUSH
2184: LD_EXP 44
2188: ADD
2189: ST_TO_ADDR
// end ; if not Cornel then
2190: LD_EXP 45
2194: NOT
2195: IFFALSE 2241
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2197: LD_ADDR_EXP 45
2201: PUSH
2202: LD_STRING Cornel
2204: PPUSH
2205: LD_EXP 1
2209: NOT
2210: PPUSH
2211: LD_STRING 13f_
2213: PPUSH
2214: CALL 53843 0 3
2218: ST_TO_ADDR
// if Cornel then
2219: LD_EXP 45
2223: IFFALSE 2241
// tmp := tmp ^ Cornel ;
2225: LD_ADDR_VAR 0 2
2229: PUSH
2230: LD_VAR 0 2
2234: PUSH
2235: LD_EXP 45
2239: ADD
2240: ST_TO_ADDR
// end ; if not Gary then
2241: LD_EXP 46
2245: NOT
2246: IFFALSE 2292
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2248: LD_ADDR_EXP 46
2252: PUSH
2253: LD_STRING Gary
2255: PPUSH
2256: LD_EXP 1
2260: NOT
2261: PPUSH
2262: LD_STRING 13f_
2264: PPUSH
2265: CALL 53843 0 3
2269: ST_TO_ADDR
// if Gary then
2270: LD_EXP 46
2274: IFFALSE 2292
// tmp := tmp ^ Gary ;
2276: LD_ADDR_VAR 0 2
2280: PUSH
2281: LD_VAR 0 2
2285: PUSH
2286: LD_EXP 46
2290: ADD
2291: ST_TO_ADDR
// end ; if not Frank then
2292: LD_EXP 47
2296: NOT
2297: IFFALSE 2343
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2299: LD_ADDR_EXP 47
2303: PUSH
2304: LD_STRING Frank
2306: PPUSH
2307: LD_EXP 1
2311: NOT
2312: PPUSH
2313: LD_STRING 13f_
2315: PPUSH
2316: CALL 53843 0 3
2320: ST_TO_ADDR
// if Frank then
2321: LD_EXP 47
2325: IFFALSE 2343
// tmp := tmp ^ Frank ;
2327: LD_ADDR_VAR 0 2
2331: PUSH
2332: LD_VAR 0 2
2336: PUSH
2337: LD_EXP 47
2341: ADD
2342: ST_TO_ADDR
// end ; if not Kikuchi then
2343: LD_EXP 48
2347: NOT
2348: IFFALSE 2394
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 48
2354: PUSH
2355: LD_STRING Kikuchi
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 53843 0 3
2371: ST_TO_ADDR
// if Kikuchi then
2372: LD_EXP 48
2376: IFFALSE 2394
// tmp := tmp ^ Kikuchi ;
2378: LD_ADDR_VAR 0 2
2382: PUSH
2383: LD_VAR 0 2
2387: PUSH
2388: LD_EXP 48
2392: ADD
2393: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_VAR 0 2
2403: PUSH
2404: LD_STRING 13_other_survivors
2406: PPUSH
2407: CALL_OW 31
2411: UNION
2412: ST_TO_ADDR
// result := tmp ;
2413: LD_ADDR_VAR 0 1
2417: PUSH
2418: LD_VAR 0 2
2422: ST_TO_ADDR
// end ; end_of_file
2423: LD_VAR 0 1
2427: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2428: LD_INT 0
2430: PPUSH
2431: PPUSH
2432: PPUSH
2433: PPUSH
2434: PPUSH
2435: PPUSH
2436: PPUSH
2437: PPUSH
2438: PPUSH
2439: PPUSH
// uc_side := 4 ;
2440: LD_ADDR_OWVAR 20
2444: PUSH
2445: LD_INT 4
2447: ST_TO_ADDR
// uc_nation := 1 ;
2448: LD_ADDR_OWVAR 21
2452: PUSH
2453: LD_INT 1
2455: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2456: LD_INT 387
2458: PPUSH
2459: CALL_OW 274
2463: PPUSH
2464: LD_INT 1
2466: PPUSH
2467: LD_INT 2500
2469: PPUSH
2470: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2474: LD_INT 387
2476: PPUSH
2477: CALL_OW 274
2481: PPUSH
2482: LD_INT 2
2484: PPUSH
2485: LD_INT 400
2487: PPUSH
2488: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2492: LD_INT 387
2494: PPUSH
2495: CALL_OW 274
2499: PPUSH
2500: LD_INT 3
2502: PPUSH
2503: LD_INT 10
2505: PPUSH
2506: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2510: LD_ADDR_EXP 53
2514: PUSH
2515: LD_STRING Powell
2517: PPUSH
2518: CALL_OW 25
2522: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2523: LD_EXP 53
2527: PPUSH
2528: LD_INT 57
2530: PPUSH
2531: LD_INT 94
2533: PPUSH
2534: LD_INT 0
2536: PPUSH
2537: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2541: LD_EXP 53
2545: PPUSH
2546: LD_INT 58
2548: PPUSH
2549: LD_INT 94
2551: PPUSH
2552: CALL_OW 118
// vip := [ ] ;
2556: LD_ADDR_EXP 54
2560: PUSH
2561: EMPTY
2562: ST_TO_ADDR
// tmp := [ ] ;
2563: LD_ADDR_VAR 0 6
2567: PUSH
2568: EMPTY
2569: ST_TO_ADDR
// if JMMGirl <> 2 then
2570: LD_EXP 7
2574: PUSH
2575: LD_INT 2
2577: NONEQUAL
2578: IFFALSE 2602
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2580: LD_ADDR_EXP 37
2584: PUSH
2585: LD_STRING Lisa
2587: PPUSH
2588: LD_EXP 1
2592: NOT
2593: PPUSH
2594: LD_STRING 13s_
2596: PPUSH
2597: CALL 53843 0 3
2601: ST_TO_ADDR
// if Lisa then
2602: LD_EXP 37
2606: IFFALSE 2624
// tmp := tmp ^ Lisa ;
2608: LD_ADDR_VAR 0 6
2612: PUSH
2613: LD_VAR 0 6
2617: PUSH
2618: LD_EXP 37
2622: ADD
2623: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2624: LD_ADDR_EXP 38
2628: PUSH
2629: LD_STRING Donaldson
2631: PPUSH
2632: LD_EXP 1
2636: NOT
2637: PPUSH
2638: LD_STRING 13s_
2640: PPUSH
2641: CALL 53843 0 3
2645: ST_TO_ADDR
// if Donaldson then
2646: LD_EXP 38
2650: IFFALSE 2668
// tmp := tmp ^ Donaldson ;
2652: LD_ADDR_VAR 0 6
2656: PUSH
2657: LD_VAR 0 6
2661: PUSH
2662: LD_EXP 38
2666: ADD
2667: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
2668: LD_ADDR_EXP 39
2672: PUSH
2673: LD_STRING Bobby
2675: PPUSH
2676: LD_EXP 1
2680: NOT
2681: PPUSH
2682: LD_STRING 13s_
2684: PPUSH
2685: CALL 53843 0 3
2689: ST_TO_ADDR
// if Bobby then
2690: LD_EXP 39
2694: IFFALSE 2712
// tmp := tmp ^ Bobby ;
2696: LD_ADDR_VAR 0 6
2700: PUSH
2701: LD_VAR 0 6
2705: PUSH
2706: LD_EXP 39
2710: ADD
2711: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
2712: LD_ADDR_EXP 40
2716: PUSH
2717: LD_STRING Cyrus
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13s_
2728: PPUSH
2729: CALL 53843 0 3
2733: ST_TO_ADDR
// if Cyrus then
2734: LD_EXP 40
2738: IFFALSE 2756
// tmp := tmp ^ Cyrus ;
2740: LD_ADDR_VAR 0 6
2744: PUSH
2745: LD_VAR 0 6
2749: PUSH
2750: LD_EXP 40
2754: ADD
2755: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
2756: LD_ADDR_EXP 41
2760: PUSH
2761: LD_STRING Denis
2763: PPUSH
2764: LD_EXP 1
2768: NOT
2769: PPUSH
2770: LD_STRING 13s_
2772: PPUSH
2773: CALL 53843 0 3
2777: ST_TO_ADDR
// if not Denis then
2778: LD_EXP 41
2782: NOT
2783: IFFALSE 2807
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
2785: LD_ADDR_EXP 41
2789: PUSH
2790: LD_STRING Denis
2792: PPUSH
2793: LD_EXP 1
2797: NOT
2798: PPUSH
2799: LD_STRING 13f_
2801: PPUSH
2802: CALL 53843 0 3
2806: ST_TO_ADDR
// if Denis then
2807: LD_EXP 41
2811: IFFALSE 2829
// tmp := tmp ^ Denis ;
2813: LD_ADDR_VAR 0 6
2817: PUSH
2818: LD_VAR 0 6
2822: PUSH
2823: LD_EXP 41
2827: ADD
2828: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
2829: LD_ADDR_EXP 42
2833: PUSH
2834: LD_STRING Brown
2836: PPUSH
2837: LD_EXP 1
2841: NOT
2842: PPUSH
2843: LD_STRING 13s_
2845: PPUSH
2846: CALL 53843 0 3
2850: ST_TO_ADDR
// if Brown then
2851: LD_EXP 42
2855: IFFALSE 2873
// tmp := tmp ^ Brown ;
2857: LD_ADDR_VAR 0 6
2861: PUSH
2862: LD_VAR 0 6
2866: PUSH
2867: LD_EXP 42
2871: ADD
2872: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
2873: LD_ADDR_EXP 43
2877: PUSH
2878: LD_STRING Gladstone
2880: PPUSH
2881: LD_EXP 1
2885: NOT
2886: PPUSH
2887: LD_STRING 13s_
2889: PPUSH
2890: CALL 53843 0 3
2894: ST_TO_ADDR
// if Gladstone then
2895: LD_EXP 43
2899: IFFALSE 2917
// tmp := tmp ^ Gladstone ;
2901: LD_ADDR_VAR 0 6
2905: PUSH
2906: LD_VAR 0 6
2910: PUSH
2911: LD_EXP 43
2915: ADD
2916: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
2917: LD_ADDR_EXP 44
2921: PUSH
2922: LD_STRING Houten
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13s_
2933: PPUSH
2934: CALL 53843 0 3
2938: ST_TO_ADDR
// if Houten then
2939: LD_EXP 44
2943: IFFALSE 2961
// tmp := tmp ^ Houten ;
2945: LD_ADDR_VAR 0 6
2949: PUSH
2950: LD_VAR 0 6
2954: PUSH
2955: LD_EXP 44
2959: ADD
2960: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
2961: LD_ADDR_EXP 45
2965: PUSH
2966: LD_STRING Cornel
2968: PPUSH
2969: LD_EXP 1
2973: NOT
2974: PPUSH
2975: LD_STRING 13s_
2977: PPUSH
2978: CALL 53843 0 3
2982: ST_TO_ADDR
// if Cornel then
2983: LD_EXP 45
2987: IFFALSE 3005
// tmp := tmp ^ Cornel ;
2989: LD_ADDR_VAR 0 6
2993: PUSH
2994: LD_VAR 0 6
2998: PUSH
2999: LD_EXP 45
3003: ADD
3004: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3005: LD_ADDR_EXP 46
3009: PUSH
3010: LD_STRING Gary
3012: PPUSH
3013: LD_EXP 1
3017: NOT
3018: PPUSH
3019: LD_STRING 13s_
3021: PPUSH
3022: CALL 53843 0 3
3026: ST_TO_ADDR
// if Gary then
3027: LD_EXP 46
3031: IFFALSE 3049
// tmp := tmp ^ Gary ;
3033: LD_ADDR_VAR 0 6
3037: PUSH
3038: LD_VAR 0 6
3042: PUSH
3043: LD_EXP 46
3047: ADD
3048: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3049: LD_ADDR_EXP 47
3053: PUSH
3054: LD_STRING Frank
3056: PPUSH
3057: LD_EXP 1
3061: NOT
3062: PPUSH
3063: LD_STRING 13s_
3065: PPUSH
3066: CALL 53843 0 3
3070: ST_TO_ADDR
// if Frank then
3071: LD_EXP 47
3075: IFFALSE 3093
// tmp := tmp ^ Frank ;
3077: LD_ADDR_VAR 0 6
3081: PUSH
3082: LD_VAR 0 6
3086: PUSH
3087: LD_EXP 47
3091: ADD
3092: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3093: LD_ADDR_EXP 48
3097: PUSH
3098: LD_STRING Kikuchi
3100: PPUSH
3101: LD_EXP 1
3105: NOT
3106: PPUSH
3107: LD_STRING 13s_
3109: PPUSH
3110: CALL 53843 0 3
3114: ST_TO_ADDR
// if Kikuchi then
3115: LD_EXP 48
3119: IFFALSE 3137
// tmp := tmp ^ Kikuchi ;
3121: LD_ADDR_VAR 0 6
3125: PUSH
3126: LD_VAR 0 6
3130: PUSH
3131: LD_EXP 48
3135: ADD
3136: ST_TO_ADDR
// vip := tmp ;
3137: LD_ADDR_EXP 54
3141: PUSH
3142: LD_VAR 0 6
3146: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3147: LD_ADDR_VAR 0 6
3151: PUSH
3152: LD_VAR 0 6
3156: PUSH
3157: LD_STRING 13s_others
3159: PPUSH
3160: CALL_OW 31
3164: UNION
3165: ST_TO_ADDR
// if tmp < 20 then
3166: LD_VAR 0 6
3170: PUSH
3171: LD_INT 20
3173: LESS
3174: IFFALSE 3241
// for i = 1 to 20 - tmp do
3176: LD_ADDR_VAR 0 2
3180: PUSH
3181: DOUBLE
3182: LD_INT 1
3184: DEC
3185: ST_TO_ADDR
3186: LD_INT 20
3188: PUSH
3189: LD_VAR 0 6
3193: MINUS
3194: PUSH
3195: FOR_TO
3196: IFFALSE 3239
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3198: LD_INT 1
3200: PPUSH
3201: LD_VAR 0 2
3205: PUSH
3206: LD_INT 4
3208: MOD
3209: PUSH
3210: LD_INT 1
3212: PLUS
3213: PPUSH
3214: LD_INT 5
3216: PPUSH
3217: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3221: LD_ADDR_VAR 0 6
3225: PUSH
3226: LD_VAR 0 6
3230: PUSH
3231: CALL_OW 44
3235: ADD
3236: ST_TO_ADDR
// end ;
3237: GO 3195
3239: POP
3240: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3241: LD_ADDR_VAR 0 7
3245: PUSH
3246: LD_INT 22
3248: PUSH
3249: LD_INT 4
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 30
3258: PUSH
3259: LD_INT 0
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PPUSH
3270: CALL_OW 69
3274: PUSH
3275: LD_INT 1
3277: ARRAY
3278: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3279: LD_ADDR_VAR 0 8
3283: PUSH
3284: LD_INT 22
3286: PUSH
3287: LD_INT 4
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 30
3296: PUSH
3297: LD_INT 6
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PPUSH
3308: CALL_OW 69
3312: PUSH
3313: LD_INT 1
3315: ARRAY
3316: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3317: LD_ADDR_VAR 0 9
3321: PUSH
3322: LD_INT 22
3324: PUSH
3325: LD_INT 4
3327: PUSH
3328: EMPTY
3329: LIST
3330: LIST
3331: PUSH
3332: LD_INT 30
3334: PUSH
3335: LD_INT 4
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PPUSH
3346: CALL_OW 69
3350: PUSH
3351: LD_INT 1
3353: ARRAY
3354: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3355: LD_ADDR_VAR 0 10
3359: PUSH
3360: LD_INT 22
3362: PUSH
3363: LD_INT 4
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: PUSH
3370: LD_INT 30
3372: PUSH
3373: LD_INT 2
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PPUSH
3384: CALL_OW 69
3388: PUSH
3389: LD_INT 1
3391: ARRAY
3392: ST_TO_ADDR
// for i in tmp do
3393: LD_ADDR_VAR 0 2
3397: PUSH
3398: LD_VAR 0 6
3402: PUSH
3403: FOR_IN
3404: IFFALSE 3530
// begin cl := GetClass ( i ) ;
3406: LD_ADDR_VAR 0 5
3410: PUSH
3411: LD_VAR 0 2
3415: PPUSH
3416: CALL_OW 257
3420: ST_TO_ADDR
// if cl > 4 then
3421: LD_VAR 0 5
3425: PUSH
3426: LD_INT 4
3428: GREATER
3429: IFFALSE 3439
// cl := 1 ;
3431: LD_ADDR_VAR 0 5
3435: PUSH
3436: LD_INT 1
3438: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3439: LD_ADDR_VAR 0 3
3443: PUSH
3444: LD_VAR 0 9
3448: PUSH
3449: LD_VAR 0 7
3453: PUSH
3454: LD_VAR 0 10
3458: PUSH
3459: LD_VAR 0 8
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: LIST
3468: LIST
3469: PUSH
3470: LD_VAR 0 5
3474: ARRAY
3475: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3476: LD_VAR 0 3
3480: PPUSH
3481: CALL_OW 313
3485: PUSH
3486: LD_INT 5
3488: LESS
3489: IFFALSE 3507
// PlaceHumanInUnit ( i , b ) else
3491: LD_VAR 0 2
3495: PPUSH
3496: LD_VAR 0 3
3500: PPUSH
3501: CALL_OW 52
3505: GO 3528
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3507: LD_VAR 0 2
3511: PPUSH
3512: LD_INT 58
3514: PPUSH
3515: LD_INT 91
3517: PPUSH
3518: LD_INT 6
3520: PPUSH
3521: LD_INT 0
3523: PPUSH
3524: CALL_OW 50
// end ;
3528: GO 3403
3530: POP
3531: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3532: LD_INT 2
3534: PPUSH
3535: LD_INT 1
3537: PPUSH
3538: LD_INT 1
3540: PPUSH
3541: LD_INT 12
3543: PPUSH
3544: LD_INT 100
3546: PPUSH
3547: CALL 60476 0 5
// veh := CreateVehicle ;
3551: LD_ADDR_VAR 0 4
3555: PUSH
3556: CALL_OW 45
3560: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3561: LD_VAR 0 4
3565: PPUSH
3566: LD_INT 4
3568: PPUSH
3569: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3573: LD_VAR 0 4
3577: PPUSH
3578: LD_INT 49
3580: PPUSH
3581: LD_INT 88
3583: PPUSH
3584: LD_INT 0
3586: PPUSH
3587: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3591: LD_VAR 0 4
3595: PPUSH
3596: LD_INT 1
3598: PPUSH
3599: LD_INT 100
3601: PPUSH
3602: CALL_OW 290
// uc_side := 0 ;
3606: LD_ADDR_OWVAR 20
3610: PUSH
3611: LD_INT 0
3613: ST_TO_ADDR
// uc_nation := 0 ;
3614: LD_ADDR_OWVAR 21
3618: PUSH
3619: LD_INT 0
3621: ST_TO_ADDR
// for i = 1 to 4 do
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: DOUBLE
3628: LD_INT 1
3630: DEC
3631: ST_TO_ADDR
3632: LD_INT 4
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3667
// begin InitHc ;
3638: CALL_OW 19
// hc_class := class_apeman ;
3642: LD_ADDR_OWVAR 28
3646: PUSH
3647: LD_INT 12
3649: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
3650: CALL_OW 44
3654: PPUSH
3655: LD_INT 13
3657: PPUSH
3658: LD_INT 0
3660: PPUSH
3661: CALL_OW 49
// end ;
3665: GO 3635
3667: POP
3668: POP
// end ; end_of_file
3669: LD_VAR 0 1
3673: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
3674: LD_INT 0
3676: PPUSH
3677: PPUSH
3678: PPUSH
3679: PPUSH
3680: PPUSH
// side := 8 ;
3681: LD_ADDR_VAR 0 3
3685: PUSH
3686: LD_INT 8
3688: ST_TO_ADDR
// uc_side := side ;
3689: LD_ADDR_OWVAR 20
3693: PUSH
3694: LD_VAR 0 3
3698: ST_TO_ADDR
// uc_nation := 2 ;
3699: LD_ADDR_OWVAR 21
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3707: LD_ADDR_VAR 0 2
3711: PUSH
3712: LD_INT 22
3714: PUSH
3715: LD_VAR 0 3
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: LD_INT 21
3726: PUSH
3727: LD_INT 3
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PPUSH
3738: CALL_OW 69
3742: PUSH
3743: FOR_IN
3744: IFFALSE 3760
// SetBLevel ( i , 10 ) ;
3746: LD_VAR 0 2
3750: PPUSH
3751: LD_INT 10
3753: PPUSH
3754: CALL_OW 241
3758: GO 3743
3760: POP
3761: POP
// if KurtStatus then
3762: LD_EXP 3
3766: IFFALSE 3789
// Kurt := PrepareUnit ( Kurt , false ,  ) else
3768: LD_ADDR_EXP 55
3772: PUSH
3773: LD_STRING Kurt
3775: PPUSH
3776: LD_INT 0
3778: PPUSH
3779: LD_STRING 
3781: PPUSH
3782: CALL 53843 0 3
3786: ST_TO_ADDR
3787: GO 3811
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
3789: LD_ADDR_EXP 55
3793: PUSH
3794: LD_STRING AltKurt
3796: PPUSH
3797: LD_EXP 1
3801: NOT
3802: PPUSH
3803: LD_STRING 
3805: PPUSH
3806: CALL 53843 0 3
3810: ST_TO_ADDR
// if not Kurt then
3811: LD_EXP 55
3815: NOT
3816: IFFALSE 3842
// begin InitHc ;
3818: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
3822: LD_INT 1
3824: PPUSH
3825: LD_INT 10
3827: PPUSH
3828: CALL_OW 381
// Kurt := CreateHuman ;
3832: LD_ADDR_EXP 55
3836: PUSH
3837: CALL_OW 44
3841: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
3842: LD_EXP 55
3846: PPUSH
3847: LD_INT 324
3849: PPUSH
3850: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
3854: LD_ADDR_EXP 56
3858: PUSH
3859: LD_STRING Kozlov
3861: PPUSH
3862: LD_INT 0
3864: PPUSH
3865: LD_STRING 
3867: PPUSH
3868: CALL 53843 0 3
3872: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
3873: LD_EXP 56
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 8
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PUSH
3888: LD_INT 23
3890: PUSH
3891: LD_INT 3
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: PUSH
3898: LD_INT 30
3900: PUSH
3901: LD_INT 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: LIST
3912: PPUSH
3913: CALL_OW 69
3917: PUSH
3918: LD_INT 1
3920: ARRAY
3921: PPUSH
3922: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
3926: LD_ADDR_VAR 0 5
3930: PUSH
3931: LD_INT 22
3933: PUSH
3934: LD_VAR 0 3
3938: PUSH
3939: EMPTY
3940: LIST
3941: LIST
3942: PUSH
3943: LD_INT 30
3945: PUSH
3946: LD_INT 32
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: PUSH
3953: LD_INT 58
3955: PUSH
3956: EMPTY
3957: LIST
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: ST_TO_ADDR
// for i = 1 to 10 do
3969: LD_ADDR_VAR 0 2
3973: PUSH
3974: DOUBLE
3975: LD_INT 1
3977: DEC
3978: ST_TO_ADDR
3979: LD_INT 10
3981: PUSH
3982: FOR_TO
3983: IFFALSE 4055
// begin uc_nation := nation_nature ;
3985: LD_ADDR_OWVAR 21
3989: PUSH
3990: LD_INT 0
3992: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
3993: LD_ADDR_OWVAR 28
3997: PUSH
3998: LD_INT 15
4000: ST_TO_ADDR
// hc_gallery :=  ;
4001: LD_ADDR_OWVAR 33
4005: PUSH
4006: LD_STRING 
4008: ST_TO_ADDR
// hc_name :=  ;
4009: LD_ADDR_OWVAR 26
4013: PUSH
4014: LD_STRING 
4016: ST_TO_ADDR
// un := CreateHuman ;
4017: LD_ADDR_VAR 0 4
4021: PUSH
4022: CALL_OW 44
4026: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4027: LD_VAR 0 4
4031: PPUSH
4032: LD_VAR 0 5
4036: PUSH
4037: LD_VAR 0 5
4041: PUSH
4042: LD_VAR 0 2
4046: MINUS
4047: ARRAY
4048: PPUSH
4049: CALL_OW 52
// end ;
4053: GO 3982
4055: POP
4056: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4057: LD_ADDR_VAR 0 5
4061: PUSH
4062: LD_STRING 12_kurt_squad
4064: PPUSH
4065: CALL_OW 31
4069: ST_TO_ADDR
// if tmp then
4070: LD_VAR 0 5
4074: IFFALSE 4108
// for i in tmp do
4076: LD_ADDR_VAR 0 2
4080: PUSH
4081: LD_VAR 0 5
4085: PUSH
4086: FOR_IN
4087: IFFALSE 4106
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4089: LD_VAR 0 2
4093: PPUSH
4094: LD_INT 5
4096: PPUSH
4097: LD_INT 0
4099: PPUSH
4100: CALL_OW 49
4104: GO 4086
4106: POP
4107: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 12 , 6 , 6 , 8 ] ) ;
4108: LD_INT 324
4110: PPUSH
4111: LD_INT 5
4113: PPUSH
4114: LD_STRING 
4116: PPUSH
4117: LD_INT 8
4119: PUSH
4120: LD_INT 9
4122: PUSH
4123: LD_INT 10
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: LIST
4130: PUSH
4131: LD_OWVAR 67
4135: ARRAY
4136: PPUSH
4137: LD_INT 3000
4139: PUSH
4140: LD_INT 500
4142: PUSH
4143: LD_INT 150
4145: PUSH
4146: EMPTY
4147: LIST
4148: LIST
4149: LIST
4150: PPUSH
4151: LD_INT 12
4153: PUSH
4154: LD_INT 6
4156: PUSH
4157: LD_INT 6
4159: PUSH
4160: LD_INT 8
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: LIST
4167: LIST
4168: PPUSH
4169: CALL 63885 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4173: LD_ADDR_EXP 93
4177: PUSH
4178: LD_EXP 93
4182: PPUSH
4183: LD_INT 3
4185: PPUSH
4186: LD_INT 22
4188: PUSH
4189: LD_VAR 0 3
4193: PUSH
4194: EMPTY
4195: LIST
4196: LIST
4197: PUSH
4198: LD_INT 23
4200: PUSH
4201: LD_INT 2
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PUSH
4208: LD_INT 3
4210: PUSH
4211: LD_INT 21
4213: PUSH
4214: LD_INT 2
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: LIST
4229: PPUSH
4230: CALL_OW 69
4234: PUSH
4235: LD_EXP 55
4239: DIFF
4240: PPUSH
4241: CALL_OW 1
4245: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4246: LD_INT 1
4248: PPUSH
4249: LD_INT 7
4251: PPUSH
4252: CALL_OW 383
// Friend := CreateHuman ;
4256: LD_ADDR_EXP 57
4260: PUSH
4261: CALL_OW 44
4265: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4266: LD_INT 14
4268: PPUSH
4269: LD_INT 3
4271: PPUSH
4272: LD_INT 1
4274: PPUSH
4275: LD_INT 29
4277: PPUSH
4278: LD_INT 100
4280: PPUSH
4281: CALL 60476 0 5
// powellBomb := CreateVehicle ;
4285: LD_ADDR_EXP 58
4289: PUSH
4290: CALL_OW 45
4294: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4295: LD_EXP 58
4299: PPUSH
4300: LD_INT 90
4302: PPUSH
4303: LD_INT 51
4305: PPUSH
4306: LD_INT 0
4308: PPUSH
4309: CALL_OW 48
// end ;
4313: LD_VAR 0 1
4317: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4318: LD_INT 0
4320: PPUSH
4321: PPUSH
4322: PPUSH
// if IsLive ( kozlov_fac ) then
4323: LD_INT 332
4325: PPUSH
4326: CALL_OW 300
4330: IFFALSE 4334
// exit ;
4332: GO 4901
// ComExitBuilding ( Kozlov ) ;
4334: LD_EXP 56
4338: PPUSH
4339: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4343: LD_EXP 56
4347: PPUSH
4348: CALL_OW 257
4352: PUSH
4353: LD_INT 2
4355: NONEQUAL
4356: IFFALSE 4391
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4358: LD_EXP 56
4362: PPUSH
4363: LD_INT 324
4365: PPUSH
4366: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4370: LD_EXP 56
4374: PPUSH
4375: LD_INT 2
4377: PPUSH
4378: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4382: LD_EXP 56
4386: PPUSH
4387: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4391: LD_EXP 56
4395: PPUSH
4396: LD_INT 2
4398: PPUSH
4399: LD_INT 93
4401: PPUSH
4402: LD_INT 32
4404: PPUSH
4405: LD_INT 3
4407: PPUSH
4408: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4412: LD_INT 35
4414: PPUSH
4415: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4419: LD_INT 22
4421: PUSH
4422: LD_INT 8
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PUSH
4429: LD_INT 30
4431: PUSH
4432: LD_INT 3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: PUSH
4439: LD_INT 23
4441: PUSH
4442: LD_INT 3
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 57
4451: PUSH
4452: EMPTY
4453: LIST
4454: PUSH
4455: EMPTY
4456: LIST
4457: LIST
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 69
4465: IFFALSE 4412
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: LD_INT 22
4474: PUSH
4475: LD_INT 8
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 30
4484: PUSH
4485: LD_INT 3
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: LD_INT 23
4494: PUSH
4495: LD_INT 3
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 57
4504: PUSH
4505: EMPTY
4506: LIST
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PPUSH
4514: CALL_OW 69
4518: PUSH
4519: LD_INT 1
4521: ARRAY
4522: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4523: LD_INT 22
4525: PUSH
4526: LD_INT 8
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: LD_INT 23
4535: PUSH
4536: LD_INT 3
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 30
4545: PUSH
4546: LD_INT 21
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: PPUSH
4558: CALL_OW 69
4562: NOT
4563: IFFALSE 4641
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4565: LD_EXP 56
4569: PPUSH
4570: LD_INT 21
4572: PPUSH
4573: LD_INT 97
4575: PPUSH
4576: LD_INT 36
4578: PPUSH
4579: LD_INT 5
4581: PPUSH
4582: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4586: LD_INT 35
4588: PPUSH
4589: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4593: LD_INT 22
4595: PUSH
4596: LD_INT 8
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: LD_INT 23
4605: PUSH
4606: LD_INT 3
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: LD_INT 30
4615: PUSH
4616: LD_INT 21
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PUSH
4623: LD_INT 57
4625: PUSH
4626: EMPTY
4627: LIST
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: LIST
4633: LIST
4634: PPUSH
4635: CALL_OW 69
4639: IFFALSE 4586
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
4641: LD_INT 22
4643: PUSH
4644: LD_INT 8
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 23
4653: PUSH
4654: LD_INT 3
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: PUSH
4661: LD_INT 30
4663: PUSH
4664: LD_INT 18
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: EMPTY
4672: LIST
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: NOT
4681: IFFALSE 4759
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
4683: LD_EXP 56
4687: PPUSH
4688: LD_INT 18
4690: PPUSH
4691: LD_INT 89
4693: PPUSH
4694: LD_INT 32
4696: PPUSH
4697: LD_INT 1
4699: PPUSH
4700: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4704: LD_INT 35
4706: PPUSH
4707: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
4711: LD_INT 22
4713: PUSH
4714: LD_INT 8
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: PUSH
4721: LD_INT 23
4723: PUSH
4724: LD_INT 3
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: PUSH
4731: LD_INT 30
4733: PUSH
4734: LD_INT 18
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: PUSH
4741: LD_INT 57
4743: PUSH
4744: EMPTY
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: PPUSH
4753: CALL_OW 69
4757: IFFALSE 4704
// end ; lab := kozlov_lab ;
4759: LD_ADDR_VAR 0 3
4763: PUSH
4764: LD_INT 336
4766: ST_TO_ADDR
// if not lab then
4767: LD_VAR 0 3
4771: NOT
4772: IFFALSE 4776
// exit ;
4774: GO 4901
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
4776: LD_EXP 56
4780: PPUSH
4781: LD_VAR 0 3
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
4794: LD_EXP 56
4798: PPUSH
4799: LD_INT 4
4801: PPUSH
4802: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
4806: LD_VAR 0 3
4810: PUSH
4811: LD_INT 1
4813: ARRAY
4814: PPUSH
4815: LD_INT 25
4817: PPUSH
4818: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
4822: LD_INT 35
4824: PPUSH
4825: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
4829: LD_INT 25
4831: PPUSH
4832: LD_INT 8
4834: PPUSH
4835: CALL_OW 321
4839: PUSH
4840: LD_INT 2
4842: EQUAL
4843: IFFALSE 4822
// ComExitBuilding ( Kozlov ) ;
4845: LD_EXP 56
4849: PPUSH
4850: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
4854: LD_EXP 56
4858: PPUSH
4859: LD_VAR 0 2
4863: PPUSH
4864: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
4868: LD_EXP 56
4872: PPUSH
4873: LD_INT 3
4875: PPUSH
4876: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
4880: LD_VAR 0 2
4884: PPUSH
4885: LD_INT 23
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: LD_INT 1
4893: PPUSH
4894: LD_INT 48
4896: PPUSH
4897: CALL_OW 125
// end ;
4901: LD_VAR 0 1
4905: RET
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 do var i , tmp , target ;
4906: LD_EXP 22
4910: NOT
4911: PUSH
4912: LD_EXP 15
4916: PUSH
4917: LD_INT 6
4919: GREATEREQUAL
4920: AND
4921: IFFALSE 5572
4923: GO 4925
4925: DISABLE
4926: LD_INT 0
4928: PPUSH
4929: PPUSH
4930: PPUSH
// begin enable ;
4931: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
4932: LD_INT 22
4934: PUSH
4935: LD_INT 8
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: PUSH
4942: LD_INT 23
4944: PUSH
4945: LD_INT 2
4947: PUSH
4948: EMPTY
4949: LIST
4950: LIST
4951: PUSH
4952: LD_INT 30
4954: PUSH
4955: LD_INT 3
4957: PUSH
4958: EMPTY
4959: LIST
4960: LIST
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: LIST
4966: PPUSH
4967: CALL_OW 69
4971: NOT
4972: IFFALSE 4976
// exit ;
4974: GO 5572
// if Prob ( 40 ) then
4976: LD_INT 40
4978: PPUSH
4979: CALL_OW 13
4983: IFFALSE 5110
// begin MC_InsertProduceList ( 3 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
4985: LD_INT 3
4987: PPUSH
4988: LD_INT 13
4990: PUSH
4991: LD_INT 1
4993: PUSH
4994: LD_INT 2
4996: PUSH
4997: LD_INT 28
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: LD_INT 1
5011: PUSH
5012: LD_INT 2
5014: PUSH
5015: LD_INT 28
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 13
5026: PUSH
5027: LD_INT 1
5029: PUSH
5030: LD_INT 2
5032: PUSH
5033: LD_INT 28
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: PUSH
5042: LD_INT 13
5044: PUSH
5045: LD_INT 1
5047: PUSH
5048: LD_INT 2
5050: PUSH
5051: LD_INT 28
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: LIST
5058: LIST
5059: PUSH
5060: LD_INT 13
5062: PUSH
5063: LD_INT 1
5065: PUSH
5066: LD_INT 2
5068: PUSH
5069: LD_INT 28
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 13
5080: PUSH
5081: LD_INT 1
5083: PUSH
5084: LD_INT 2
5086: PUSH
5087: LD_INT 26
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: LIST
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PPUSH
5104: CALL 47948 0 2
// end else
5108: GO 5301
// begin MC_InsertProduceList ( 3 , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5110: LD_INT 3
5112: PPUSH
5113: LD_INT 13
5115: PUSH
5116: LD_INT 1
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 27
5124: PUSH
5125: LD_INT 26
5127: PUSH
5128: LD_INT 26
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: LIST
5135: PUSH
5136: LD_OWVAR 67
5140: ARRAY
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: PUSH
5148: LD_INT 13
5150: PUSH
5151: LD_INT 1
5153: PUSH
5154: LD_INT 2
5156: PUSH
5157: LD_INT 27
5159: PUSH
5160: LD_INT 26
5162: PUSH
5163: LD_INT 26
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: PUSH
5171: LD_OWVAR 67
5175: ARRAY
5176: PUSH
5177: EMPTY
5178: LIST
5179: LIST
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 13
5185: PUSH
5186: LD_INT 1
5188: PUSH
5189: LD_INT 2
5191: PUSH
5192: LD_INT 26
5194: PUSH
5195: LD_INT 26
5197: PUSH
5198: LD_INT 29
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: PUSH
5206: LD_OWVAR 67
5210: ARRAY
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 13
5220: PUSH
5221: LD_INT 1
5223: PUSH
5224: LD_INT 2
5226: PUSH
5227: LD_INT 26
5229: PUSH
5230: LD_INT 29
5232: PUSH
5233: LD_INT 29
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: LIST
5240: PUSH
5241: LD_OWVAR 67
5245: ARRAY
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 13
5255: PUSH
5256: LD_INT 1
5258: PUSH
5259: LD_INT 2
5261: PUSH
5262: LD_INT 29
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 13
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: LD_INT 2
5279: PUSH
5280: LD_INT 26
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: LIST
5287: LIST
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: PPUSH
5297: CALL 47948 0 2
// end ; repeat wait ( 0 0$1 ) ;
5301: LD_INT 35
5303: PPUSH
5304: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5308: LD_INT 3
5310: PPUSH
5311: LD_INT 1
5313: PPUSH
5314: CALL 49361 0 2
5318: PUSH
5319: LD_INT 6
5321: GREATEREQUAL
5322: IFFALSE 5301
// tmp := MC_GetVehicles ( 3 , true ) ;
5324: LD_ADDR_VAR 0 2
5328: PUSH
5329: LD_INT 3
5331: PPUSH
5332: LD_INT 1
5334: PPUSH
5335: CALL 49361 0 2
5339: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
5340: LD_ADDR_VAR 0 3
5344: PUSH
5345: LD_INT 0
5347: PPUSH
5348: LD_INT 1
5350: PPUSH
5351: CALL_OW 12
5355: ST_TO_ADDR
// if target then
5356: LD_VAR 0 3
5360: IFFALSE 5419
// begin repeat ComMoveXY ( tmp , 90 , 75 ) ;
5362: LD_VAR 0 2
5366: PPUSH
5367: LD_INT 90
5369: PPUSH
5370: LD_INT 75
5372: PPUSH
5373: CALL_OW 111
// wait ( 0 0$1 ) ;
5377: LD_INT 35
5379: PPUSH
5380: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 90 , 75 , 6 ] ) > 2 ;
5384: LD_VAR 0 2
5388: PPUSH
5389: LD_INT 92
5391: PUSH
5392: LD_INT 90
5394: PUSH
5395: LD_INT 75
5397: PUSH
5398: LD_INT 6
5400: PUSH
5401: EMPTY
5402: LIST
5403: LIST
5404: LIST
5405: LIST
5406: PPUSH
5407: CALL_OW 72
5411: PUSH
5412: LD_INT 2
5414: GREATER
5415: IFFALSE 5362
// end else
5417: GO 5474
// begin repeat ComMoveXY ( tmp , 128 , 11 ) ;
5419: LD_VAR 0 2
5423: PPUSH
5424: LD_INT 128
5426: PPUSH
5427: LD_INT 11
5429: PPUSH
5430: CALL_OW 111
// wait ( 0 0$1 ) ;
5434: LD_INT 35
5436: PPUSH
5437: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 128 , 11 , 6 ] ) > 2 ;
5441: LD_VAR 0 2
5445: PPUSH
5446: LD_INT 92
5448: PUSH
5449: LD_INT 128
5451: PUSH
5452: LD_INT 11
5454: PUSH
5455: LD_INT 6
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: LIST
5462: LIST
5463: PPUSH
5464: CALL_OW 72
5468: PUSH
5469: LD_INT 2
5471: GREATER
5472: IFFALSE 5419
// end ; repeat wait ( 0 0$1 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// for i in tmp do
5481: LD_ADDR_VAR 0 1
5485: PUSH
5486: LD_VAR 0 2
5490: PUSH
5491: FOR_IN
5492: IFFALSE 5563
// if GetLives ( i ) > 251 then
5494: LD_VAR 0 1
5498: PPUSH
5499: CALL_OW 256
5503: PUSH
5504: LD_INT 251
5506: GREATER
5507: IFFALSE 5545
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
5509: LD_VAR 0 1
5513: PPUSH
5514: LD_INT 81
5516: PUSH
5517: LD_INT 8
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 69
5528: PPUSH
5529: LD_VAR 0 1
5533: PPUSH
5534: CALL_OW 74
5538: PPUSH
5539: CALL_OW 115
5543: GO 5561
// tmp := tmp diff i ;
5545: LD_ADDR_VAR 0 2
5549: PUSH
5550: LD_VAR 0 2
5554: PUSH
5555: LD_VAR 0 1
5559: DIFF
5560: ST_TO_ADDR
5561: GO 5491
5563: POP
5564: POP
// until not tmp ;
5565: LD_VAR 0 2
5569: NOT
5570: IFFALSE 5474
// end ; end_of_file
5572: PPOPN 3
5574: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
5575: LD_INT 0
5577: PPUSH
5578: PPUSH
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
5585: PPUSH
// side := 3 ;
5586: LD_ADDR_VAR 0 6
5590: PUSH
5591: LD_INT 3
5593: ST_TO_ADDR
// uc_side := side ;
5594: LD_ADDR_OWVAR 20
5598: PUSH
5599: LD_VAR 0 6
5603: ST_TO_ADDR
// uc_nation := 3 ;
5604: LD_ADDR_OWVAR 21
5608: PUSH
5609: LD_INT 3
5611: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
5612: LD_ADDR_VAR 0 2
5616: PUSH
5617: LD_INT 22
5619: PUSH
5620: LD_VAR 0 6
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: PUSH
5629: LD_INT 21
5631: PUSH
5632: LD_INT 3
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PUSH
5639: EMPTY
5640: LIST
5641: LIST
5642: PPUSH
5643: CALL_OW 69
5647: PUSH
5648: FOR_IN
5649: IFFALSE 5665
// SetBLevel ( i , 10 ) ;
5651: LD_VAR 0 2
5655: PPUSH
5656: LD_INT 10
5658: PPUSH
5659: CALL_OW 241
5663: GO 5648
5665: POP
5666: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
5667: LD_ADDR_VAR 0 9
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PUSH
5684: LD_INT 30
5686: PUSH
5687: LD_INT 34
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PPUSH
5698: CALL_OW 69
5702: ST_TO_ADDR
// if teleport then
5703: LD_VAR 0 9
5707: IFFALSE 5728
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
5709: LD_VAR 0 9
5713: PUSH
5714: LD_INT 1
5716: ARRAY
5717: PPUSH
5718: LD_INT 123
5720: PPUSH
5721: LD_INT 122
5723: PPUSH
5724: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
5728: LD_ADDR_EXP 59
5732: PUSH
5733: LD_STRING Platonov
5735: PPUSH
5736: CALL_OW 25
5740: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
5741: LD_ADDR_EXP 60
5745: PUSH
5746: LD_STRING Kovalyuk
5748: PPUSH
5749: CALL_OW 25
5753: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
5754: LD_ADDR_EXP 62
5758: PUSH
5759: LD_STRING Yakotich
5761: PPUSH
5762: CALL_OW 25
5766: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
5767: LD_ADDR_EXP 61
5771: PUSH
5772: LD_STRING Bystrov
5774: PPUSH
5775: CALL_OW 25
5779: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
5780: LD_ADDR_EXP 63
5784: PUSH
5785: LD_STRING Gleb
5787: PPUSH
5788: CALL_OW 25
5792: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
5793: LD_STRING 03_Cornel
5795: PPUSH
5796: CALL_OW 28
5800: IFFALSE 5848
// begin Bierezov := NewCharacter ( Mikhail ) ;
5802: LD_ADDR_EXP 64
5806: PUSH
5807: LD_STRING Mikhail
5809: PPUSH
5810: CALL_OW 25
5814: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
5815: LD_EXP 64
5819: PPUSH
5820: LD_INT 197
5822: PPUSH
5823: LD_INT 111
5825: PPUSH
5826: LD_INT 9
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
5836: LD_EXP 64
5840: PPUSH
5841: LD_INT 3
5843: PPUSH
5844: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
5848: LD_EXP 59
5852: PPUSH
5853: LD_INT 126
5855: PPUSH
5856: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
5860: LD_EXP 60
5864: PPUSH
5865: LD_INT 134
5867: PPUSH
5868: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
5872: LD_EXP 62
5876: PPUSH
5877: LD_INT 197
5879: PPUSH
5880: LD_INT 111
5882: PPUSH
5883: LD_INT 9
5885: PPUSH
5886: LD_INT 0
5888: PPUSH
5889: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
5893: LD_EXP 61
5897: PPUSH
5898: LD_INT 197
5900: PPUSH
5901: LD_INT 111
5903: PPUSH
5904: LD_INT 9
5906: PPUSH
5907: LD_INT 0
5909: PPUSH
5910: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
5914: LD_EXP 63
5918: PPUSH
5919: LD_INT 197
5921: PPUSH
5922: LD_INT 111
5924: PPUSH
5925: LD_INT 9
5927: PPUSH
5928: LD_INT 0
5930: PPUSH
5931: CALL_OW 50
// PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 10000 , 1000 , 300 ] , [ - 1 , 8 , 13 , 8 ] ) ;
5935: LD_INT 126
5937: PPUSH
5938: LD_INT 4
5940: PPUSH
5941: LD_STRING zhukov
5943: PPUSH
5944: LD_INT 9
5946: PUSH
5947: LD_INT 10
5949: PUSH
5950: LD_INT 10
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: PUSH
5958: LD_OWVAR 67
5962: ARRAY
5963: PPUSH
5964: LD_INT 10000
5966: PUSH
5967: LD_INT 1000
5969: PUSH
5970: LD_INT 300
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: PPUSH
5978: LD_INT 1
5980: NEG
5981: PUSH
5982: LD_INT 8
5984: PUSH
5985: LD_INT 13
5987: PUSH
5988: LD_INT 8
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 63885 0 6
// base := GetBase ( ru_depot2 ) ;
6001: LD_ADDR_VAR 0 4
6005: PUSH
6006: LD_INT 267
6008: PPUSH
6009: CALL_OW 274
6013: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 2000 ) ;
6014: LD_VAR 0 4
6018: PPUSH
6019: LD_INT 1
6021: PPUSH
6022: LD_INT 2000
6024: PPUSH
6025: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
6029: LD_VAR 0 4
6033: PPUSH
6034: LD_INT 2
6036: PPUSH
6037: LD_INT 200
6039: PPUSH
6040: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
6044: LD_VAR 0 4
6048: PPUSH
6049: LD_INT 3
6051: PPUSH
6052: LD_INT 200
6054: PPUSH
6055: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
6059: LD_ADDR_EXP 93
6063: PUSH
6064: LD_EXP 93
6068: PPUSH
6069: LD_INT 2
6071: PPUSH
6072: LD_INT 22
6074: PUSH
6075: LD_VAR 0 6
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 3
6086: PUSH
6087: LD_INT 21
6089: PUSH
6090: LD_INT 2
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 69
6109: PUSH
6110: LD_EXP 59
6114: DIFF
6115: PPUSH
6116: CALL_OW 1
6120: ST_TO_ADDR
// behemoths := [ ] ;
6121: LD_ADDR_EXP 67
6125: PUSH
6126: EMPTY
6127: ST_TO_ADDR
// behemothBuilders := [ ] ;
6128: LD_ADDR_EXP 68
6132: PUSH
6133: EMPTY
6134: ST_TO_ADDR
// if Kovalyuk then
6135: LD_EXP 60
6139: IFFALSE 6161
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
6141: LD_ADDR_EXP 68
6145: PUSH
6146: LD_EXP 68
6150: PPUSH
6151: LD_EXP 60
6155: PPUSH
6156: CALL 96159 0 2
6160: ST_TO_ADDR
// j := 3 ;
6161: LD_ADDR_VAR 0 3
6165: PUSH
6166: LD_INT 3
6168: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
6169: LD_ADDR_VAR 0 2
6173: PUSH
6174: LD_INT 22
6176: PUSH
6177: LD_INT 3
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 25
6186: PUSH
6187: LD_INT 3
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PPUSH
6198: CALL_OW 69
6202: PUSH
6203: LD_EXP 60
6207: DIFF
6208: PUSH
6209: FOR_IN
6210: IFFALSE 6260
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
6212: LD_ADDR_EXP 68
6216: PUSH
6217: LD_EXP 68
6221: PPUSH
6222: LD_VAR 0 2
6226: PPUSH
6227: CALL 96159 0 2
6231: ST_TO_ADDR
// j := j - 1 ;
6232: LD_ADDR_VAR 0 3
6236: PUSH
6237: LD_VAR 0 3
6241: PUSH
6242: LD_INT 1
6244: MINUS
6245: ST_TO_ADDR
// if j = 0 then
6246: LD_VAR 0 3
6250: PUSH
6251: LD_INT 0
6253: EQUAL
6254: IFFALSE 6258
// break ;
6256: GO 6260
// end ;
6258: GO 6209
6260: POP
6261: POP
// end ;
6262: LD_VAR 0 1
6266: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
6267: LD_INT 0
6269: PPUSH
6270: PPUSH
6271: PPUSH
6272: PPUSH
6273: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
6274: LD_ADDR_VAR 0 4
6278: PUSH
6279: LD_INT 209
6281: PUSH
6282: LD_INT 149
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: PUSH
6289: LD_INT 219
6291: PUSH
6292: LD_INT 154
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: PUSH
6299: LD_INT 223
6301: PUSH
6302: LD_INT 149
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PUSH
6309: LD_INT 232
6311: PUSH
6312: LD_INT 155
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: ST_TO_ADDR
// if not behemothBuilders then
6325: LD_EXP 68
6329: NOT
6330: IFFALSE 6334
// exit ;
6332: GO 6438
// j := 1 ;
6334: LD_ADDR_VAR 0 3
6338: PUSH
6339: LD_INT 1
6341: ST_TO_ADDR
// for i in behemothBuilders do
6342: LD_ADDR_VAR 0 2
6346: PUSH
6347: LD_EXP 68
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6436
// begin if IsInUnit ( i ) then
6355: LD_VAR 0 2
6359: PPUSH
6360: CALL_OW 310
6364: IFFALSE 6375
// ComExitBuilding ( i ) ;
6366: LD_VAR 0 2
6370: PPUSH
6371: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
6375: LD_VAR 0 2
6379: PPUSH
6380: LD_INT 37
6382: PPUSH
6383: LD_VAR 0 4
6387: PUSH
6388: LD_VAR 0 3
6392: ARRAY
6393: PUSH
6394: LD_INT 1
6396: ARRAY
6397: PPUSH
6398: LD_VAR 0 4
6402: PUSH
6403: LD_VAR 0 3
6407: ARRAY
6408: PUSH
6409: LD_INT 2
6411: ARRAY
6412: PPUSH
6413: LD_INT 0
6415: PPUSH
6416: CALL_OW 230
// j := j + 1 ;
6420: LD_ADDR_VAR 0 3
6424: PUSH
6425: LD_VAR 0 3
6429: PUSH
6430: LD_INT 1
6432: PLUS
6433: ST_TO_ADDR
// end ;
6434: GO 6352
6436: POP
6437: POP
// end ;
6438: LD_VAR 0 1
6442: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
6443: LD_INT 24
6445: PPUSH
6446: LD_INT 30
6448: PUSH
6449: LD_INT 37
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: PPUSH
6456: CALL_OW 70
6460: IFFALSE 6473
6462: GO 6464
6464: DISABLE
// behemothUnderConstruct := true ;
6465: LD_ADDR_EXP 26
6469: PUSH
6470: LD_INT 1
6472: ST_TO_ADDR
6473: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
6474: LD_INT 3
6476: PPUSH
6477: CALL 96207 0 1
6481: PUSH
6482: LD_INT 22
6484: PUSH
6485: LD_INT 3
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: PUSH
6492: LD_INT 30
6494: PUSH
6495: LD_INT 37
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: PPUSH
6506: CALL_OW 69
6510: NOT
6511: AND
6512: IFFALSE 6698
6514: GO 6516
6516: DISABLE
6517: LD_INT 0
6519: PPUSH
6520: PPUSH
// begin enable ;
6521: ENABLE
// tmp := GetBehemoths ( 3 ) ;
6522: LD_ADDR_VAR 0 2
6526: PUSH
6527: LD_INT 3
6529: PPUSH
6530: CALL 96207 0 1
6534: ST_TO_ADDR
// for i in tmp do
6535: LD_ADDR_VAR 0 1
6539: PUSH
6540: LD_VAR 0 2
6544: PUSH
6545: FOR_IN
6546: IFFALSE 6696
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
6548: LD_VAR 0 1
6552: PPUSH
6553: LD_INT 9
6555: PPUSH
6556: CALL_OW 308
6560: PUSH
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 110
6570: PUSH
6571: LD_INT 2
6573: EQUAL
6574: NOT
6575: AND
6576: IFFALSE 6590
// SetTag ( i , 2 ) ;
6578: LD_VAR 0 1
6582: PPUSH
6583: LD_INT 2
6585: PPUSH
6586: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
6590: LD_INT 81
6592: PUSH
6593: LD_INT 3
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 91
6602: PUSH
6603: LD_VAR 0 1
6607: PUSH
6608: LD_INT 12
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: LIST
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PPUSH
6620: CALL_OW 69
6624: NOT
6625: PUSH
6626: LD_VAR 0 1
6630: PPUSH
6631: CALL_OW 110
6635: PUSH
6636: LD_INT 2
6638: EQUAL
6639: NOT
6640: AND
6641: IFFALSE 6660
// ComAgressiveMove ( i , 64 , 93 ) else
6643: LD_VAR 0 1
6647: PPUSH
6648: LD_INT 64
6650: PPUSH
6651: LD_INT 93
6653: PPUSH
6654: CALL_OW 114
6658: GO 6694
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
6660: LD_VAR 0 1
6664: PPUSH
6665: LD_INT 81
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL_OW 69
6679: PPUSH
6680: LD_VAR 0 1
6684: PPUSH
6685: CALL_OW 74
6689: PPUSH
6690: CALL_OW 115
// end ;
6694: GO 6545
6696: POP
6697: POP
// end ;
6698: PPOPN 2
6700: END
// export function PrepareRussianAttack ( strength ) ; var i ; begin
6701: LD_INT 0
6703: PPUSH
6704: PPUSH
// result := [ ] ;
6705: LD_ADDR_VAR 0 2
6709: PUSH
6710: EMPTY
6711: ST_TO_ADDR
// uc_side := 6 ;
6712: LD_ADDR_OWVAR 20
6716: PUSH
6717: LD_INT 6
6719: ST_TO_ADDR
// uc_nation := 3 ;
6720: LD_ADDR_OWVAR 21
6724: PUSH
6725: LD_INT 3
6727: ST_TO_ADDR
// case strength of 1 :
6728: LD_VAR 0 1
6732: PUSH
6733: LD_INT 1
6735: DOUBLE
6736: EQUAL
6737: IFTRUE 6741
6739: GO 6879
6741: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6742: LD_ADDR_VAR 0 3
6746: PUSH
6747: DOUBLE
6748: LD_INT 1
6750: DEC
6751: ST_TO_ADDR
6752: LD_INT 3
6754: PUSH
6755: LD_INT 4
6757: PUSH
6758: LD_INT 5
6760: PUSH
6761: EMPTY
6762: LIST
6763: LIST
6764: LIST
6765: PUSH
6766: LD_OWVAR 67
6770: ARRAY
6771: PUSH
6772: FOR_TO
6773: IFFALSE 6875
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
6775: LD_INT 22
6777: PUSH
6778: LD_INT 24
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: LD_VAR 0 3
6789: PUSH
6790: LD_INT 2
6792: MOD
6793: PUSH
6794: LD_INT 1
6796: PLUS
6797: ARRAY
6798: PPUSH
6799: LD_INT 1
6801: PUSH
6802: LD_INT 3
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: PUSH
6809: LD_INT 1
6811: PPUSH
6812: LD_INT 2
6814: PPUSH
6815: CALL_OW 12
6819: ARRAY
6820: PPUSH
6821: LD_INT 3
6823: PPUSH
6824: LD_INT 43
6826: PUSH
6827: LD_INT 44
6829: PUSH
6830: LD_INT 45
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: PUSH
6838: LD_INT 1
6840: PPUSH
6841: LD_INT 3
6843: PPUSH
6844: CALL_OW 12
6848: ARRAY
6849: PPUSH
6850: LD_INT 80
6852: PPUSH
6853: CALL 60476 0 5
// result := result union CreateVehicle ;
6857: LD_ADDR_VAR 0 2
6861: PUSH
6862: LD_VAR 0 2
6866: PUSH
6867: CALL_OW 45
6871: UNION
6872: ST_TO_ADDR
// end ;
6873: GO 6772
6875: POP
6876: POP
// end ; 2 :
6877: GO 7659
6879: LD_INT 2
6881: DOUBLE
6882: EQUAL
6883: IFTRUE 6887
6885: GO 7043
6887: POP
// begin for i = 1 to [ 5 , 5 , 6 ] [ Difficulty ] do
6888: LD_ADDR_VAR 0 3
6892: PUSH
6893: DOUBLE
6894: LD_INT 1
6896: DEC
6897: ST_TO_ADDR
6898: LD_INT 5
6900: PUSH
6901: LD_INT 5
6903: PUSH
6904: LD_INT 6
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: LIST
6911: PUSH
6912: LD_OWVAR 67
6916: ARRAY
6917: PUSH
6918: FOR_TO
6919: IFFALSE 7039
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
6921: LD_INT 22
6923: PUSH
6924: LD_INT 24
6926: PUSH
6927: LD_INT 24
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_VAR 0 3
6939: PUSH
6940: LD_INT 3
6942: MOD
6943: PUSH
6944: LD_INT 1
6946: PLUS
6947: ARRAY
6948: PPUSH
6949: LD_INT 1
6951: PUSH
6952: LD_INT 3
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PUSH
6959: LD_INT 1
6961: PPUSH
6962: LD_INT 2
6964: PPUSH
6965: CALL_OW 12
6969: ARRAY
6970: PPUSH
6971: LD_INT 3
6973: PPUSH
6974: LD_INT 43
6976: PUSH
6977: LD_INT 44
6979: PUSH
6980: LD_INT 45
6982: PUSH
6983: LD_INT 44
6985: PUSH
6986: LD_INT 46
6988: PUSH
6989: LD_INT 46
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: LIST
6996: LIST
6997: LIST
6998: LIST
6999: PUSH
7000: LD_VAR 0 3
7004: PUSH
7005: LD_INT 6
7007: MOD
7008: PUSH
7009: LD_INT 1
7011: PLUS
7012: ARRAY
7013: PPUSH
7014: LD_INT 80
7016: PPUSH
7017: CALL 60476 0 5
// result := result union CreateVehicle ;
7021: LD_ADDR_VAR 0 2
7025: PUSH
7026: LD_VAR 0 2
7030: PUSH
7031: CALL_OW 45
7035: UNION
7036: ST_TO_ADDR
// end ;
7037: GO 6918
7039: POP
7040: POP
// end ; 3 :
7041: GO 7659
7043: LD_INT 3
7045: DOUBLE
7046: EQUAL
7047: IFTRUE 7051
7049: GO 7207
7051: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
7052: LD_ADDR_VAR 0 3
7056: PUSH
7057: DOUBLE
7058: LD_INT 1
7060: DEC
7061: ST_TO_ADDR
7062: LD_INT 5
7064: PUSH
7065: LD_INT 6
7067: PUSH
7068: LD_INT 7
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_OWVAR 67
7080: ARRAY
7081: PUSH
7082: FOR_TO
7083: IFFALSE 7203
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
7085: LD_INT 22
7087: PUSH
7088: LD_INT 24
7090: PUSH
7091: LD_INT 24
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: LIST
7098: PUSH
7099: LD_VAR 0 3
7103: PUSH
7104: LD_INT 3
7106: MOD
7107: PUSH
7108: LD_INT 1
7110: PLUS
7111: ARRAY
7112: PPUSH
7113: LD_INT 1
7115: PUSH
7116: LD_INT 3
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 1
7125: PPUSH
7126: LD_INT 2
7128: PPUSH
7129: CALL_OW 12
7133: ARRAY
7134: PPUSH
7135: LD_INT 3
7137: PPUSH
7138: LD_INT 43
7140: PUSH
7141: LD_INT 47
7143: PUSH
7144: LD_INT 45
7146: PUSH
7147: LD_INT 45
7149: PUSH
7150: LD_INT 46
7152: PUSH
7153: LD_INT 46
7155: PUSH
7156: EMPTY
7157: LIST
7158: LIST
7159: LIST
7160: LIST
7161: LIST
7162: LIST
7163: PUSH
7164: LD_VAR 0 3
7168: PUSH
7169: LD_INT 6
7171: MOD
7172: PUSH
7173: LD_INT 1
7175: PLUS
7176: ARRAY
7177: PPUSH
7178: LD_INT 80
7180: PPUSH
7181: CALL 60476 0 5
// result := result union CreateVehicle ;
7185: LD_ADDR_VAR 0 2
7189: PUSH
7190: LD_VAR 0 2
7194: PUSH
7195: CALL_OW 45
7199: UNION
7200: ST_TO_ADDR
// end ;
7201: GO 7082
7203: POP
7204: POP
// end ; 4 :
7205: GO 7659
7207: LD_INT 4
7209: DOUBLE
7210: EQUAL
7211: IFTRUE 7215
7213: GO 7658
7215: POP
// begin uc_nation := 3 ;
7216: LD_ADDR_OWVAR 21
7220: PUSH
7221: LD_INT 3
7223: ST_TO_ADDR
// for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
7224: LD_ADDR_VAR 0 3
7228: PUSH
7229: DOUBLE
7230: LD_INT 1
7232: DEC
7233: ST_TO_ADDR
7234: LD_INT 6
7236: PUSH
7237: LD_INT 7
7239: PUSH
7240: LD_INT 8
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: LIST
7247: PUSH
7248: LD_OWVAR 67
7252: ARRAY
7253: PUSH
7254: FOR_TO
7255: IFFALSE 7375
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
7257: LD_INT 22
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 24
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: LIST
7270: PUSH
7271: LD_VAR 0 3
7275: PUSH
7276: LD_INT 3
7278: MOD
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: ARRAY
7284: PPUSH
7285: LD_INT 1
7287: PUSH
7288: LD_INT 3
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PUSH
7295: LD_INT 1
7297: PPUSH
7298: LD_INT 2
7300: PPUSH
7301: CALL_OW 12
7305: ARRAY
7306: PPUSH
7307: LD_INT 3
7309: PPUSH
7310: LD_INT 45
7312: PUSH
7313: LD_INT 47
7315: PUSH
7316: LD_INT 47
7318: PUSH
7319: LD_INT 45
7321: PUSH
7322: LD_INT 46
7324: PUSH
7325: LD_INT 46
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: LIST
7334: LIST
7335: PUSH
7336: LD_VAR 0 3
7340: PUSH
7341: LD_INT 6
7343: MOD
7344: PUSH
7345: LD_INT 1
7347: PLUS
7348: ARRAY
7349: PPUSH
7350: LD_INT 80
7352: PPUSH
7353: CALL 60476 0 5
// result := result union CreateVehicle ;
7357: LD_ADDR_VAR 0 2
7361: PUSH
7362: LD_VAR 0 2
7366: PUSH
7367: CALL_OW 45
7371: UNION
7372: ST_TO_ADDR
// end ;
7373: GO 7254
7375: POP
7376: POP
// if not KappaStatus then
7377: LD_EXP 2
7381: NOT
7382: IFFALSE 7577
// begin uc_nation := 1 ;
7384: LD_ADDR_OWVAR 21
7388: PUSH
7389: LD_INT 1
7391: ST_TO_ADDR
// for i = 1 to 3 do
7392: LD_ADDR_VAR 0 3
7396: PUSH
7397: DOUBLE
7398: LD_INT 1
7400: DEC
7401: ST_TO_ADDR
7402: LD_INT 3
7404: PUSH
7405: FOR_TO
7406: IFFALSE 7502
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 85 ) ;
7408: LD_INT 3
7410: PUSH
7411: LD_INT 5
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: PUSH
7418: LD_INT 1
7420: PPUSH
7421: LD_INT 2
7423: PPUSH
7424: CALL_OW 12
7428: ARRAY
7429: PPUSH
7430: LD_INT 1
7432: PUSH
7433: LD_INT 3
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 1
7442: PPUSH
7443: LD_INT 2
7445: PPUSH
7446: CALL_OW 12
7450: ARRAY
7451: PPUSH
7452: LD_INT 3
7454: PPUSH
7455: LD_INT 9
7457: PUSH
7458: LD_INT 7
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: LD_INT 1
7467: PPUSH
7468: LD_INT 2
7470: PPUSH
7471: CALL_OW 12
7475: ARRAY
7476: PPUSH
7477: LD_INT 85
7479: PPUSH
7480: CALL 60476 0 5
// result := result union CreateVehicle ;
7484: LD_ADDR_VAR 0 2
7488: PUSH
7489: LD_VAR 0 2
7493: PUSH
7494: CALL_OW 45
7498: UNION
7499: ST_TO_ADDR
// end ;
7500: GO 7405
7502: POP
7503: POP
// if vsevolodFirstAttack then
7504: LD_EXP 24
7508: IFFALSE 7575
// begin vsevolodFirstAttack := false ;
7510: LD_ADDR_EXP 24
7514: PUSH
7515: LD_INT 0
7517: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
7518: LD_INT 5
7520: PPUSH
7521: LD_INT 3
7523: PPUSH
7524: LD_INT 1
7526: PPUSH
7527: LD_INT 6
7529: PPUSH
7530: LD_INT 100
7532: PPUSH
7533: CALL 60476 0 5
// sewiVeh := CreateVehicle ;
7537: LD_ADDR_EXP 66
7541: PUSH
7542: CALL_OW 45
7546: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
7547: LD_EXP 66
7551: PPUSH
7552: LD_INT 1
7554: PPUSH
7555: CALL_OW 242
// result := result union sewiVeh ;
7559: LD_ADDR_VAR 0 2
7563: PUSH
7564: LD_VAR 0 2
7568: PUSH
7569: LD_EXP 66
7573: UNION
7574: ST_TO_ADDR
// end ; end else
7575: GO 7656
// if vsevolodFirstAttack then
7577: LD_EXP 24
7581: IFFALSE 7656
// begin vsevolodFirstAttack := false ;
7583: LD_ADDR_EXP 24
7587: PUSH
7588: LD_INT 0
7590: ST_TO_ADDR
// uc_nation := 3 ;
7591: LD_ADDR_OWVAR 21
7595: PUSH
7596: LD_INT 3
7598: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
7599: LD_INT 24
7601: PPUSH
7602: LD_INT 3
7604: PPUSH
7605: LD_INT 1
7607: PPUSH
7608: LD_INT 47
7610: PPUSH
7611: LD_INT 100
7613: PPUSH
7614: CALL 60476 0 5
// sewiVeh := CreateVehicle ;
7618: LD_ADDR_EXP 66
7622: PUSH
7623: CALL_OW 45
7627: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
7628: LD_EXP 66
7632: PPUSH
7633: LD_INT 1
7635: PPUSH
7636: CALL_OW 242
// result := result union sewiVeh ;
7640: LD_ADDR_VAR 0 2
7644: PUSH
7645: LD_VAR 0 2
7649: PUSH
7650: LD_EXP 66
7654: UNION
7655: ST_TO_ADDR
// end ; end ; end ;
7656: GO 7659
7658: POP
// end ;
7659: LD_VAR 0 2
7663: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy , x , y ;
7664: LD_EXP 16
7668: IFFALSE 8357
7670: GO 7672
7672: DISABLE
7673: LD_INT 0
7675: PPUSH
7676: PPUSH
7677: PPUSH
7678: PPUSH
7679: PPUSH
7680: PPUSH
7681: PPUSH
7682: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
7683: LD_ADDR_VAR 0 4
7687: PUSH
7688: LD_INT 11
7690: PUSH
7691: LD_INT 12
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
7698: LD_ADDR_VAR 0 3
7702: PUSH
7703: LD_INT 8400
7705: PUSH
7706: LD_INT 7350
7708: PUSH
7709: LD_INT 6650
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: ST_TO_ADDR
// xy := [ 60 , 96 ] ;
7723: LD_ADDR_VAR 0 6
7727: PUSH
7728: LD_INT 60
7730: PUSH
7731: LD_INT 96
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: ST_TO_ADDR
// repeat if missionStage = 2 then
7738: LD_EXP 15
7742: PUSH
7743: LD_INT 2
7745: EQUAL
7746: IFFALSE 7757
// wait ( 1 1$30 ) else
7748: LD_INT 3150
7750: PPUSH
7751: CALL_OW 67
7755: GO 7766
// wait ( time ) ;
7757: LD_VAR 0 3
7761: PPUSH
7762: CALL_OW 67
// if missionStage = 6 then
7766: LD_EXP 15
7770: PUSH
7771: LD_INT 6
7773: EQUAL
7774: IFFALSE 7802
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
7776: LD_INT 51
7778: PPUSH
7779: LD_INT 6
7781: PPUSH
7782: LD_INT 2
7784: PPUSH
7785: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
7789: LD_INT 57
7791: PPUSH
7792: LD_INT 6
7794: PPUSH
7795: LD_INT 2
7797: PPUSH
7798: CALL_OW 322
// end ; if missionStage = 8 then
7802: LD_EXP 15
7806: PUSH
7807: LD_INT 8
7809: EQUAL
7810: IFFALSE 7838
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
7812: LD_INT 52
7814: PPUSH
7815: LD_INT 6
7817: PPUSH
7818: LD_INT 2
7820: PPUSH
7821: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
7825: LD_INT 58
7827: PPUSH
7828: LD_INT 6
7830: PPUSH
7831: LD_INT 2
7833: PPUSH
7834: CALL_OW 322
// end ; if missionStage = 10 then
7838: LD_EXP 15
7842: PUSH
7843: LD_INT 10
7845: EQUAL
7846: IFFALSE 7874
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
7848: LD_INT 53
7850: PPUSH
7851: LD_INT 6
7853: PPUSH
7854: LD_INT 2
7856: PPUSH
7857: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
7861: LD_INT 59
7863: PPUSH
7864: LD_INT 6
7866: PPUSH
7867: LD_INT 2
7869: PPUSH
7870: CALL_OW 322
// end ; if activeAttacks then
7874: LD_EXP 16
7878: IFFALSE 8351
// begin if missionStage = 2 then
7880: LD_EXP 15
7884: PUSH
7885: LD_INT 2
7887: EQUAL
7888: IFFALSE 7898
// strength := 1 ;
7890: LD_ADDR_VAR 0 5
7894: PUSH
7895: LD_INT 1
7897: ST_TO_ADDR
// if missionStage > 2 then
7898: LD_EXP 15
7902: PUSH
7903: LD_INT 2
7905: GREATER
7906: IFFALSE 7916
// strength := 2 ;
7908: LD_ADDR_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ST_TO_ADDR
// if missionStage > 6 then
7916: LD_EXP 15
7920: PUSH
7921: LD_INT 6
7923: GREATER
7924: IFFALSE 7934
// strength := 3 ;
7926: LD_ADDR_VAR 0 5
7930: PUSH
7931: LD_INT 3
7933: ST_TO_ADDR
// if missionStage > 10 then
7934: LD_EXP 15
7938: PUSH
7939: LD_INT 10
7941: GREATER
7942: IFFALSE 7952
// strength := 4 ;
7944: LD_ADDR_VAR 0 5
7948: PUSH
7949: LD_INT 4
7951: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: LD_VAR 0 5
7961: PPUSH
7962: CALL 6701 0 1
7966: ST_TO_ADDR
// for i in tmp do
7967: LD_ADDR_VAR 0 1
7971: PUSH
7972: LD_VAR 0 2
7976: PUSH
7977: FOR_IN
7978: IFFALSE 8078
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
7980: LD_VAR 0 1
7984: PPUSH
7985: LD_VAR 0 4
7989: PUSH
7990: LD_INT 1
7992: PPUSH
7993: LD_INT 2
7995: PPUSH
7996: CALL_OW 12
8000: ARRAY
8001: PPUSH
8002: LD_INT 0
8004: PPUSH
8005: CALL_OW 49
// if i = sewiVeh then
8009: LD_VAR 0 1
8013: PUSH
8014: LD_EXP 66
8018: EQUAL
8019: IFFALSE 8054
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
8021: LD_ADDR_EXP 65
8025: PUSH
8026: LD_STRING Vsevolod
8028: PPUSH
8029: LD_INT 0
8031: PPUSH
8032: LD_STRING 
8034: PPUSH
8035: CALL 53843 0 3
8039: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
8040: LD_EXP 65
8044: PPUSH
8045: LD_VAR 0 1
8049: PPUSH
8050: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
8054: LD_VAR 0 1
8058: PPUSH
8059: LD_INT 111
8061: PPUSH
8062: LD_INT 197
8064: PPUSH
8065: CALL_OW 111
// wait ( 0 0$2 ) ;
8069: LD_INT 70
8071: PPUSH
8072: CALL_OW 67
// end ;
8076: GO 7977
8078: POP
8079: POP
// repeat wait ( 0 0$1 ) ;
8080: LD_INT 35
8082: PPUSH
8083: CALL_OW 67
// for i in tmp do
8087: LD_ADDR_VAR 0 1
8091: PUSH
8092: LD_VAR 0 2
8096: PUSH
8097: FOR_IN
8098: IFFALSE 8332
// begin x := GetX ( i ) ;
8100: LD_ADDR_VAR 0 7
8104: PUSH
8105: LD_VAR 0 1
8109: PPUSH
8110: CALL_OW 250
8114: ST_TO_ADDR
// y := GetY ( i ) ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: LD_VAR 0 1
8124: PPUSH
8125: CALL_OW 251
8129: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) then
8130: LD_INT 81
8132: PUSH
8133: LD_INT 6
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PUSH
8140: LD_INT 92
8142: PUSH
8143: LD_VAR 0 7
8147: PUSH
8148: LD_VAR 0 8
8152: PUSH
8153: LD_INT 12
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: PPUSH
8166: CALL_OW 69
8170: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) , i ) ) else
8172: LD_VAR 0 1
8176: PPUSH
8177: LD_INT 81
8179: PUSH
8180: LD_INT 6
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 92
8189: PUSH
8190: LD_VAR 0 7
8194: PUSH
8195: LD_VAR 0 8
8199: PUSH
8200: LD_INT 12
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8330
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 10 then
8234: LD_VAR 0 1
8238: PPUSH
8239: LD_VAR 0 6
8243: PUSH
8244: LD_INT 1
8246: ARRAY
8247: PPUSH
8248: LD_VAR 0 6
8252: PUSH
8253: LD_INT 2
8255: ARRAY
8256: PPUSH
8257: CALL_OW 297
8261: PUSH
8262: LD_INT 10
8264: GREATER
8265: IFFALSE 8296
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) else
8267: LD_VAR 0 1
8271: PPUSH
8272: LD_VAR 0 6
8276: PUSH
8277: LD_INT 1
8279: ARRAY
8280: PPUSH
8281: LD_VAR 0 6
8285: PUSH
8286: LD_INT 2
8288: ARRAY
8289: PPUSH
8290: CALL_OW 114
8294: GO 8330
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
8296: LD_VAR 0 1
8300: PPUSH
8301: LD_INT 81
8303: PUSH
8304: LD_INT 6
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PPUSH
8311: CALL_OW 69
8315: PPUSH
8316: LD_VAR 0 1
8320: PPUSH
8321: CALL_OW 74
8325: PPUSH
8326: CALL_OW 115
// end ;
8330: GO 8097
8332: POP
8333: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 6
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PPUSH
8344: CALL_OW 69
8348: NOT
8349: IFFALSE 8080
// end ; until russianDestroyed ;
8351: LD_EXP 21
8355: IFFALSE 7738
// end ; end_of_file
8357: PPOPN 8
8359: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
8360: LD_INT 0
8362: PPUSH
8363: PPUSH
8364: PPUSH
8365: PPUSH
8366: PPUSH
8367: PPUSH
// side := 7 ;
8368: LD_ADDR_VAR 0 5
8372: PUSH
8373: LD_INT 7
8375: ST_TO_ADDR
// uc_side := side ;
8376: LD_ADDR_OWVAR 20
8380: PUSH
8381: LD_VAR 0 5
8385: ST_TO_ADDR
// uc_nation := 1 ;
8386: LD_ADDR_OWVAR 21
8390: PUSH
8391: LD_INT 1
8393: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8394: LD_ADDR_VAR 0 2
8398: PUSH
8399: LD_INT 22
8401: PUSH
8402: LD_VAR 0 5
8406: PUSH
8407: EMPTY
8408: LIST
8409: LIST
8410: PUSH
8411: LD_INT 21
8413: PUSH
8414: LD_INT 3
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PUSH
8421: EMPTY
8422: LIST
8423: LIST
8424: PPUSH
8425: CALL_OW 69
8429: PUSH
8430: FOR_IN
8431: IFFALSE 8447
// SetBLevel ( i , 10 ) ;
8433: LD_VAR 0 2
8437: PPUSH
8438: LD_INT 10
8440: PPUSH
8441: CALL_OW 241
8445: GO 8430
8447: POP
8448: POP
// base := GetBase ( al_depot ) ;
8449: LD_ADDR_VAR 0 4
8453: PUSH
8454: LD_INT 2
8456: PPUSH
8457: CALL_OW 274
8461: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8462: LD_ADDR_VAR 0 6
8466: PUSH
8467: LD_INT 22
8469: PUSH
8470: LD_VAR 0 5
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PUSH
8479: LD_INT 30
8481: PUSH
8482: LD_INT 34
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: PPUSH
8493: CALL_OW 69
8497: ST_TO_ADDR
// if teleport then
8498: LD_VAR 0 6
8502: IFFALSE 8523
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
8504: LD_VAR 0 6
8508: PUSH
8509: LD_INT 1
8511: ARRAY
8512: PPUSH
8513: LD_INT 262
8515: PPUSH
8516: LD_INT 119
8518: PPUSH
8519: CALL_OW 243
// SetResourceType ( base , mat_cans , 3500 ) ;
8523: LD_VAR 0 4
8527: PPUSH
8528: LD_INT 1
8530: PPUSH
8531: LD_INT 3500
8533: PPUSH
8534: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8538: LD_VAR 0 4
8542: PPUSH
8543: LD_INT 2
8545: PPUSH
8546: LD_INT 200
8548: PPUSH
8549: CALL_OW 277
// SetResourceType ( base , mat_siberit , 50 ) ;
8553: LD_VAR 0 4
8557: PPUSH
8558: LD_INT 3
8560: PPUSH
8561: LD_INT 50
8563: PPUSH
8564: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
8568: LD_ADDR_EXP 69
8572: PUSH
8573: LD_STRING Roth
8575: PPUSH
8576: CALL_OW 25
8580: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
8581: LD_ADDR_EXP 70
8585: PUSH
8586: LD_STRING Simms
8588: PPUSH
8589: LD_EXP 1
8593: NOT
8594: PPUSH
8595: LD_STRING 10c_
8597: PPUSH
8598: CALL 53843 0 3
8602: ST_TO_ADDR
// uc_nation := 3 ;
8603: LD_ADDR_OWVAR 21
8607: PUSH
8608: LD_INT 3
8610: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
8611: LD_ADDR_EXP 71
8615: PUSH
8616: LD_STRING Kirilenkova
8618: PPUSH
8619: CALL_OW 25
8623: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
8624: LD_ADDR_EXP 85
8628: PUSH
8629: LD_STRING Oblukov
8631: PPUSH
8632: CALL_OW 25
8636: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
8637: LD_ADDR_EXP 72
8641: PUSH
8642: LD_STRING Dolgov
8644: PPUSH
8645: CALL_OW 25
8649: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
8650: LD_ADDR_EXP 73
8654: PUSH
8655: LD_STRING Petrosyan
8657: PPUSH
8658: CALL_OW 25
8662: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
8663: LD_ADDR_EXP 84
8667: PUSH
8668: LD_STRING Scholtze
8670: PPUSH
8671: CALL_OW 25
8675: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
8676: LD_ADDR_EXP 83
8680: PUSH
8681: LD_STRING Kapitsova
8683: PPUSH
8684: CALL_OW 25
8688: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
8689: LD_ADDR_EXP 74
8693: PUSH
8694: LD_STRING Petrovova
8696: PPUSH
8697: CALL_OW 25
8701: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
8702: LD_ADDR_EXP 75
8706: PUSH
8707: LD_STRING Kuzmov
8709: PPUSH
8710: CALL_OW 25
8714: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
8715: LD_ADDR_EXP 82
8719: PUSH
8720: LD_STRING Karamazov
8722: PPUSH
8723: CALL_OW 25
8727: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
8728: LD_STRING 13_Lipshchin_1
8730: PPUSH
8731: LD_INT 0
8733: PPUSH
8734: CALL_OW 30
8738: IFFALSE 8753
// Lipshchin := NewCharacter ( Lipshchin ) ;
8740: LD_ADDR_EXP 76
8744: PUSH
8745: LD_STRING Lipshchin
8747: PPUSH
8748: CALL_OW 25
8752: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
8753: LD_STRING 13_Titov_1
8755: PPUSH
8756: LD_INT 0
8758: PPUSH
8759: CALL_OW 30
8763: IFFALSE 8778
// Titov := NewCharacter ( Titov ) ;
8765: LD_ADDR_EXP 78
8769: PUSH
8770: LD_STRING Titov
8772: PPUSH
8773: CALL_OW 25
8777: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
8778: LD_STRING 13_Gnyevko_1
8780: PPUSH
8781: LD_INT 0
8783: PPUSH
8784: CALL_OW 30
8788: IFFALSE 8803
// Gnyevko := NewCharacter ( Gnyevko ) ;
8790: LD_ADDR_EXP 77
8794: PUSH
8795: LD_STRING Gnyevko
8797: PPUSH
8798: CALL_OW 25
8802: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
8803: LD_STRING 13_Xavier_1
8805: PPUSH
8806: LD_INT 0
8808: PPUSH
8809: CALL_OW 30
8813: IFFALSE 8828
// Xavier := NewCharacter ( Xavier2 ) ;
8815: LD_ADDR_EXP 79
8819: PUSH
8820: LD_STRING Xavier2
8822: PPUSH
8823: CALL_OW 25
8827: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
8828: LD_STRING 13_Belkov_1
8830: PPUSH
8831: LD_INT 0
8833: PPUSH
8834: CALL_OW 30
8838: IFFALSE 8853
// Belkov := NewCharacter ( Belkov ) ;
8840: LD_ADDR_EXP 80
8844: PUSH
8845: LD_STRING Belkov
8847: PPUSH
8848: CALL_OW 25
8852: ST_TO_ADDR
// if not BurlakStatus then
8853: LD_EXP 9
8857: NOT
8858: IFFALSE 8873
// Burlak = NewCharacter ( Burlak ) ;
8860: LD_ADDR_EXP 81
8864: PUSH
8865: LD_STRING Burlak
8867: PPUSH
8868: CALL_OW 25
8872: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
8873: LD_ADDR_VAR 0 3
8877: PUSH
8878: LD_EXP 69
8882: PUSH
8883: LD_EXP 71
8887: PUSH
8888: LD_EXP 85
8892: PUSH
8893: LD_EXP 72
8897: PUSH
8898: LD_EXP 73
8902: PUSH
8903: LD_EXP 84
8907: PUSH
8908: LD_EXP 83
8912: PUSH
8913: LD_EXP 74
8917: PUSH
8918: LD_EXP 75
8922: PUSH
8923: LD_EXP 82
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: ST_TO_ADDR
// if Simms then
8940: LD_EXP 70
8944: IFFALSE 8962
// tmp := tmp ^ Simms ;
8946: LD_ADDR_VAR 0 3
8950: PUSH
8951: LD_VAR 0 3
8955: PUSH
8956: LD_EXP 70
8960: ADD
8961: ST_TO_ADDR
// if Titov then
8962: LD_EXP 78
8966: IFFALSE 8984
// tmp := tmp ^ Titov ;
8968: LD_ADDR_VAR 0 3
8972: PUSH
8973: LD_VAR 0 3
8977: PUSH
8978: LD_EXP 78
8982: ADD
8983: ST_TO_ADDR
// if Lipshchin then
8984: LD_EXP 76
8988: IFFALSE 9006
// tmp := tmp ^ Lipshchin ;
8990: LD_ADDR_VAR 0 3
8994: PUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_EXP 76
9004: ADD
9005: ST_TO_ADDR
// if Gnyevko then
9006: LD_EXP 77
9010: IFFALSE 9028
// tmp := tmp ^ Gnyevko ;
9012: LD_ADDR_VAR 0 3
9016: PUSH
9017: LD_VAR 0 3
9021: PUSH
9022: LD_EXP 77
9026: ADD
9027: ST_TO_ADDR
// if Xavier then
9028: LD_EXP 79
9032: IFFALSE 9050
// tmp := tmp ^ Xavier ;
9034: LD_ADDR_VAR 0 3
9038: PUSH
9039: LD_VAR 0 3
9043: PUSH
9044: LD_EXP 79
9048: ADD
9049: ST_TO_ADDR
// if Belkov then
9050: LD_EXP 80
9054: IFFALSE 9072
// tmp := tmp ^ Belkov ;
9056: LD_ADDR_VAR 0 3
9060: PUSH
9061: LD_VAR 0 3
9065: PUSH
9066: LD_EXP 80
9070: ADD
9071: ST_TO_ADDR
// if Burlak then
9072: LD_EXP 81
9076: IFFALSE 9094
// tmp := tmp ^ Burlak ;
9078: LD_ADDR_VAR 0 3
9082: PUSH
9083: LD_VAR 0 3
9087: PUSH
9088: LD_EXP 81
9092: ADD
9093: ST_TO_ADDR
// for i = 1 to 8 do
9094: LD_ADDR_VAR 0 2
9098: PUSH
9099: DOUBLE
9100: LD_INT 1
9102: DEC
9103: ST_TO_ADDR
9104: LD_INT 8
9106: PUSH
9107: FOR_TO
9108: IFFALSE 9174
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
9110: LD_ADDR_OWVAR 21
9114: PUSH
9115: LD_INT 1
9117: PUSH
9118: LD_INT 3
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: LD_INT 1
9127: PPUSH
9128: LD_INT 2
9130: PPUSH
9131: CALL_OW 12
9135: ARRAY
9136: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
9137: LD_INT 0
9139: PPUSH
9140: LD_VAR 0 2
9144: PUSH
9145: LD_INT 2
9147: DIV
9148: PPUSH
9149: LD_INT 10
9151: PPUSH
9152: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
9156: LD_ADDR_VAR 0 3
9160: PUSH
9161: LD_VAR 0 3
9165: PUSH
9166: CALL_OW 44
9170: ADD
9171: ST_TO_ADDR
// end ;
9172: GO 9107
9174: POP
9175: POP
// for i in tmp do
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 3
9185: PUSH
9186: FOR_IN
9187: IFFALSE 9212
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_INT 260
9196: PPUSH
9197: LD_INT 235
9199: PPUSH
9200: LD_INT 8
9202: PPUSH
9203: LD_INT 0
9205: PPUSH
9206: CALL_OW 50
9210: GO 9186
9212: POP
9213: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
9214: LD_ADDR_EXP 93
9218: PUSH
9219: LD_EXP 93
9223: PPUSH
9224: LD_INT 1
9226: PPUSH
9227: LD_INT 22
9229: PUSH
9230: LD_VAR 0 5
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 3
9241: PUSH
9242: LD_INT 21
9244: PUSH
9245: LD_INT 2
9247: PUSH
9248: EMPTY
9249: LIST
9250: LIST
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: PPUSH
9260: CALL_OW 69
9264: PUSH
9265: LD_EXP 69
9269: PUSH
9270: LD_EXP 70
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: DIFF
9279: PPUSH
9280: CALL_OW 1
9284: ST_TO_ADDR
// uc_side := 0 ;
9285: LD_ADDR_OWVAR 20
9289: PUSH
9290: LD_INT 0
9292: ST_TO_ADDR
// uc_nation := 0 ;
9293: LD_ADDR_OWVAR 21
9297: PUSH
9298: LD_INT 0
9300: ST_TO_ADDR
// for i = 1 to 5 do
9301: LD_ADDR_VAR 0 2
9305: PUSH
9306: DOUBLE
9307: LD_INT 1
9309: DEC
9310: ST_TO_ADDR
9311: LD_INT 5
9313: PUSH
9314: FOR_TO
9315: IFFALSE 9352
// begin InitHc ;
9317: CALL_OW 19
// hc_class := class_apeman ;
9321: LD_ADDR_OWVAR 28
9325: PUSH
9326: LD_INT 12
9328: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
9329: CALL_OW 44
9333: PPUSH
9334: LD_INT 299
9336: PPUSH
9337: LD_INT 229
9339: PPUSH
9340: LD_INT 10
9342: PPUSH
9343: LD_INT 0
9345: PPUSH
9346: CALL_OW 50
// end ;
9350: GO 9314
9352: POP
9353: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
9354: LD_EXP 69
9358: PPUSH
9359: LD_INT 259
9361: PPUSH
9362: LD_INT 235
9364: PPUSH
9365: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
9369: LD_EXP 69
9373: PPUSH
9374: LD_INT 262
9376: PPUSH
9377: LD_INT 235
9379: PPUSH
9380: CALL_OW 178
// if Simms then
9384: LD_EXP 70
9388: IFFALSE 9419
// begin ComMoveXY ( Simms , 262 , 235 ) ;
9390: LD_EXP 70
9394: PPUSH
9395: LD_INT 262
9397: PPUSH
9398: LD_INT 235
9400: PPUSH
9401: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
9405: LD_EXP 70
9409: PPUSH
9410: LD_EXP 69
9414: PPUSH
9415: CALL_OW 179
// end ; end ;
9419: LD_VAR 0 1
9423: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp ;
9424: LD_EXP 31
9428: PUSH
9429: LD_EXP 23
9433: NOT
9434: AND
9435: IFFALSE 9576
9437: GO 9439
9439: DISABLE
9440: LD_INT 0
9442: PPUSH
9443: PPUSH
// begin enable ;
9444: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
9445: LD_ADDR_VAR 0 2
9449: PUSH
9450: LD_INT 81
9452: PUSH
9453: LD_INT 7
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 2
9462: PUSH
9463: LD_INT 32
9465: PUSH
9466: LD_INT 3
9468: PUSH
9469: EMPTY
9470: LIST
9471: LIST
9472: PUSH
9473: LD_INT 30
9475: PUSH
9476: LD_INT 30
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 28
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 34
9495: PUSH
9496: LD_INT 49
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PUSH
9503: LD_INT 34
9505: PUSH
9506: LD_INT 10
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: PUSH
9513: LD_INT 34
9515: PUSH
9516: LD_INT 8
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PUSH
9523: EMPTY
9524: LIST
9525: LIST
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PPUSH
9536: CALL_OW 69
9540: ST_TO_ADDR
// if not tmp then
9541: LD_VAR 0 2
9545: NOT
9546: IFFALSE 9550
// exit ;
9548: GO 9576
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 0 ) ;
9550: LD_VAR 0 2
9554: PUSH
9555: LD_INT 1
9557: PPUSH
9558: LD_VAR 0 2
9562: PPUSH
9563: CALL_OW 12
9567: ARRAY
9568: PPUSH
9569: LD_INT 0
9571: PPUSH
9572: CALL_OW 234
// end ; end_of_file
9576: PPOPN 2
9578: END
// export function PrepareOmarInvasion ; begin
9579: LD_INT 0
9581: PPUSH
// missionStage := 13 ;
9582: LD_ADDR_EXP 15
9586: PUSH
9587: LD_INT 13
9589: ST_TO_ADDR
// end ; end_of_file
9590: LD_VAR 0 1
9594: RET
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
9595: LD_INT 0
9597: PPUSH
9598: PPUSH
9599: PPUSH
9600: PPUSH
9601: PPUSH
9602: PPUSH
9603: PPUSH
9604: PPUSH
9605: PPUSH
// Video ( true ) ;
9606: LD_INT 1
9608: PPUSH
9609: CALL 96131 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
9613: LD_ADDR_VAR 0 5
9617: PUSH
9618: LD_INT 7
9620: PPUSH
9621: LD_INT 0
9623: PPUSH
9624: CALL_OW 517
9628: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
9629: LD_ADDR_VAR 0 2
9633: PUSH
9634: DOUBLE
9635: LD_INT 1
9637: DEC
9638: ST_TO_ADDR
9639: LD_VAR 0 5
9643: PUSH
9644: LD_INT 1
9646: ARRAY
9647: PUSH
9648: FOR_TO
9649: IFFALSE 9694
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
9651: LD_VAR 0 5
9655: PUSH
9656: LD_INT 1
9658: ARRAY
9659: PUSH
9660: LD_VAR 0 2
9664: ARRAY
9665: PPUSH
9666: LD_VAR 0 5
9670: PUSH
9671: LD_INT 2
9673: ARRAY
9674: PUSH
9675: LD_VAR 0 2
9679: ARRAY
9680: PPUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 15
9686: NEG
9687: PPUSH
9688: CALL 96045 0 4
9692: GO 9648
9694: POP
9695: POP
// CenterNowOnUnits ( Powell ) ;
9696: LD_EXP 53
9700: PPUSH
9701: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
9705: LD_ADDR_VAR 0 5
9709: PUSH
9710: LD_EXP 51
9714: PUSH
9715: EMPTY
9716: LIST
9717: ST_TO_ADDR
// if GirlNewVeh then
9718: LD_EXP 52
9722: IFFALSE 9740
// tmp := tmp ^ GirlNewVeh ;
9724: LD_ADDR_VAR 0 5
9728: PUSH
9729: LD_VAR 0 5
9733: PUSH
9734: LD_EXP 52
9738: ADD
9739: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
9740: LD_VAR 0 5
9744: PPUSH
9745: LD_INT 60
9747: PPUSH
9748: LD_INT 109
9750: PPUSH
9751: CALL_OW 111
// if KappaStatus then
9755: LD_EXP 2
9759: IFFALSE 9811
// begin Say ( JMM , D1T-JMM-1 ) ;
9761: LD_EXP 34
9765: PPUSH
9766: LD_STRING D1T-JMM-1
9768: PPUSH
9769: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
9773: LD_EXP 53
9777: PPUSH
9778: LD_STRING D1T-Pow-1
9780: PPUSH
9781: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
9785: LD_EXP 34
9789: PPUSH
9790: LD_STRING D1T-JMM-2
9792: PPUSH
9793: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
9797: LD_EXP 53
9801: PPUSH
9802: LD_STRING D1T-Pow-2
9804: PPUSH
9805: CALL_OW 88
// end else
9809: GO 10017
// if JMMGirlStatus then
9811: LD_EXP 6
9815: IFFALSE 9960
// begin Say ( JMM , D1T-JMM-1 ) ;
9817: LD_EXP 34
9821: PPUSH
9822: LD_STRING D1T-JMM-1
9824: PPUSH
9825: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
9829: LD_EXP 53
9833: PPUSH
9834: LD_STRING D1T-Pow-1
9836: PPUSH
9837: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
9841: LD_EXP 34
9845: PPUSH
9846: LD_STRING D1T-JMM-3
9848: PPUSH
9849: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
9853: LD_EXP 53
9857: PPUSH
9858: LD_STRING D1T-Pow-3
9860: PPUSH
9861: CALL_OW 88
// if JMMGirl then
9865: LD_EXP 7
9869: IFFALSE 9958
// begin case JMMGirl of 1 :
9871: LD_EXP 7
9875: PUSH
9876: LD_INT 1
9878: DOUBLE
9879: EQUAL
9880: IFTRUE 9884
9882: GO 9899
9884: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
9885: LD_EXP 35
9889: PPUSH
9890: LD_STRING D1T-Joan-3
9892: PPUSH
9893: CALL_OW 88
9897: GO 9946
9899: LD_INT 2
9901: DOUBLE
9902: EQUAL
9903: IFTRUE 9907
9905: GO 9922
9907: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
9908: LD_EXP 37
9912: PPUSH
9913: LD_STRING D1T-Lisa-3
9915: PPUSH
9916: CALL_OW 88
9920: GO 9946
9922: LD_INT 3
9924: DOUBLE
9925: EQUAL
9926: IFTRUE 9930
9928: GO 9945
9930: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
9931: LD_EXP 49
9935: PPUSH
9936: LD_STRING D1T-Con-3
9938: PPUSH
9939: CALL_OW 88
9943: GO 9946
9945: POP
// Say ( Powell , D1T-Pow-4 ) ;
9946: LD_EXP 53
9950: PPUSH
9951: LD_STRING D1T-Pow-4
9953: PPUSH
9954: CALL_OW 88
// end ; end else
9958: GO 10017
// if not FastEnd then
9960: LD_EXP 11
9964: NOT
9965: IFFALSE 9993
// begin Say ( JMM , D1T-JMM-4 ) ;
9967: LD_EXP 34
9971: PPUSH
9972: LD_STRING D1T-JMM-4
9974: PPUSH
9975: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
9979: LD_EXP 53
9983: PPUSH
9984: LD_STRING D1T-Pow-5
9986: PPUSH
9987: CALL_OW 88
// end else
9991: GO 10017
// begin Say ( JMM , D1nT-JMM-1 ) ;
9993: LD_EXP 34
9997: PPUSH
9998: LD_STRING D1nT-JMM-1
10000: PPUSH
10001: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
10005: LD_EXP 53
10009: PPUSH
10010: LD_STRING D1nT-Pow-1
10012: PPUSH
10013: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
10017: LD_INT 35
10019: PPUSH
10020: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
10024: LD_EXP 51
10028: PPUSH
10029: CALL_OW 314
10033: NOT
10034: IFFALSE 10017
// ComExitVehicle ( JMM ) ;
10036: LD_EXP 34
10040: PPUSH
10041: CALL_OW 121
// wait ( 3 ) ;
10045: LD_INT 3
10047: PPUSH
10048: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
10052: LD_EXP 34
10056: PPUSH
10057: LD_INT 60
10059: PPUSH
10060: LD_INT 94
10062: PPUSH
10063: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
10067: LD_EXP 34
10071: PPUSH
10072: LD_EXP 53
10076: PPUSH
10077: CALL_OW 179
// if Joan then
10081: LD_EXP 35
10085: IFFALSE 10139
// begin ComExitVehicle ( Joan ) ;
10087: LD_EXP 35
10091: PPUSH
10092: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
10096: LD_EXP 35
10100: PPUSH
10101: LD_INT 35
10103: PPUSH
10104: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
10108: LD_EXP 35
10112: PPUSH
10113: LD_INT 65
10115: PPUSH
10116: LD_INT 104
10118: PPUSH
10119: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
10123: LD_EXP 35
10127: PPUSH
10128: LD_EXP 34
10132: PPUSH
10133: CALL_OW 179
// end else
10137: GO 10273
// if Lisa and JMMGirl = 2 then
10139: LD_EXP 37
10143: PUSH
10144: LD_EXP 7
10148: PUSH
10149: LD_INT 2
10151: EQUAL
10152: AND
10153: IFFALSE 10207
// begin ComExitVehicle ( Lisa ) ;
10155: LD_EXP 37
10159: PPUSH
10160: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
10164: LD_EXP 37
10168: PPUSH
10169: LD_INT 35
10171: PPUSH
10172: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
10176: LD_EXP 37
10180: PPUSH
10181: LD_INT 65
10183: PPUSH
10184: LD_INT 104
10186: PPUSH
10187: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
10191: LD_EXP 37
10195: PPUSH
10196: LD_EXP 34
10200: PPUSH
10201: CALL_OW 179
// end else
10205: GO 10273
// if Connie and JMMGirl = 3 then
10207: LD_EXP 49
10211: PUSH
10212: LD_EXP 7
10216: PUSH
10217: LD_INT 3
10219: EQUAL
10220: AND
10221: IFFALSE 10273
// begin ComExitVehicle ( Connie ) ;
10223: LD_EXP 49
10227: PPUSH
10228: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
10232: LD_EXP 49
10236: PPUSH
10237: LD_INT 35
10239: PPUSH
10240: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
10244: LD_EXP 49
10248: PPUSH
10249: LD_INT 65
10251: PPUSH
10252: LD_INT 104
10254: PPUSH
10255: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
10259: LD_EXP 49
10263: PPUSH
10264: LD_EXP 34
10268: PPUSH
10269: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
10273: LD_INT 35
10275: PPUSH
10276: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
10280: LD_EXP 34
10284: PPUSH
10285: LD_EXP 53
10289: PPUSH
10290: CALL_OW 296
10294: PUSH
10295: LD_INT 6
10297: LESS
10298: IFFALSE 10273
// wait ( 0 0$0.5 ) ;
10300: LD_INT 18
10302: PPUSH
10303: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
10307: LD_EXP 34
10311: PPUSH
10312: LD_STRING D1-JMM-1
10314: PPUSH
10315: CALL_OW 88
// async ;
10319: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
10320: LD_EXP 53
10324: PPUSH
10325: LD_STRING D1-Pow-1
10327: PPUSH
10328: CALL_OW 88
// if not dialogue_skipped then
10332: LD_OWVAR 59
10336: NOT
10337: IFFALSE 10346
// wait ( 0 0$2 ) ;
10339: LD_INT 70
10341: PPUSH
10342: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
10346: LD_INT 170
10348: PPUSH
10349: LD_INT 99
10351: PPUSH
10352: LD_INT 1
10354: PPUSH
10355: LD_INT 6
10357: NEG
10358: PPUSH
10359: CALL 96045 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
10363: LD_INT 174
10365: PPUSH
10366: LD_INT 115
10368: PPUSH
10369: LD_INT 1
10371: PPUSH
10372: LD_INT 6
10374: NEG
10375: PPUSH
10376: CALL 96045 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
10380: LD_INT 169
10382: PPUSH
10383: LD_INT 71
10385: PPUSH
10386: LD_INT 1
10388: PPUSH
10389: LD_INT 6
10391: NEG
10392: PPUSH
10393: CALL 96045 0 4
// if not dialogue_skipped then
10397: LD_OWVAR 59
10401: NOT
10402: IFFALSE 10421
// begin CenterOnXY ( 170 , 99 ) ;
10404: LD_INT 170
10406: PPUSH
10407: LD_INT 99
10409: PPUSH
10410: CALL_OW 84
// wait ( 0 0$2.3 ) ;
10414: LD_INT 80
10416: PPUSH
10417: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
10421: LD_INT 75
10423: PPUSH
10424: LD_INT 53
10426: PPUSH
10427: LD_INT 1
10429: PPUSH
10430: LD_INT 9
10432: NEG
10433: PPUSH
10434: CALL 96045 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
10438: LD_INT 54
10440: PPUSH
10441: LD_INT 42
10443: PPUSH
10444: LD_INT 1
10446: PPUSH
10447: LD_INT 9
10449: NEG
10450: PPUSH
10451: CALL 96045 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
10455: LD_INT 62
10457: PPUSH
10458: LD_INT 51
10460: PPUSH
10461: LD_INT 1
10463: PPUSH
10464: LD_INT 9
10466: NEG
10467: PPUSH
10468: CALL 96045 0 4
// if not dialogue_skipped then
10472: LD_OWVAR 59
10476: NOT
10477: IFFALSE 10496
// begin CenterOnXY ( 75 , 53 ) ;
10479: LD_INT 75
10481: PPUSH
10482: LD_INT 53
10484: PPUSH
10485: CALL_OW 84
// wait ( 0 0$4 ) ;
10489: LD_INT 140
10491: PPUSH
10492: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
10496: LD_EXP 53
10500: PPUSH
10501: CALL_OW 87
// if not dialogue_skipped then
10505: LD_OWVAR 59
10509: NOT
10510: IFFALSE 10519
// wait ( 0 0$2 ) ;
10512: LD_INT 70
10514: PPUSH
10515: CALL_OW 67
// sync ;
10519: SYNC
// Say ( JMM , D1-JMM-2 ) ;
10520: LD_EXP 34
10524: PPUSH
10525: LD_STRING D1-JMM-2
10527: PPUSH
10528: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
10532: LD_EXP 53
10536: PPUSH
10537: LD_STRING D1-Pow-2
10539: PPUSH
10540: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
10544: LD_EXP 34
10548: PPUSH
10549: LD_STRING D1-JMM-3
10551: PPUSH
10552: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
10556: LD_EXP 53
10560: PPUSH
10561: LD_STRING D1-Pow-3
10563: PPUSH
10564: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
10568: LD_EXP 34
10572: PPUSH
10573: LD_STRING D1-JMM-4
10575: PPUSH
10576: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
10580: LD_EXP 53
10584: PPUSH
10585: LD_STRING D1-Pow-4
10587: PPUSH
10588: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
10592: LD_EXP 34
10596: PPUSH
10597: LD_STRING D1-JMM-5
10599: PPUSH
10600: CALL_OW 88
// async ;
10604: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
10605: LD_EXP 53
10609: PPUSH
10610: LD_STRING D1-Pow-5
10612: PPUSH
10613: CALL_OW 88
// if not dialogue_skipped then
10617: LD_OWVAR 59
10621: NOT
10622: IFFALSE 10631
// wait ( 0 0$3.6 ) ;
10624: LD_INT 126
10626: PPUSH
10627: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
10631: LD_INT 134
10633: PPUSH
10634: LD_INT 210
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: LD_INT 11
10642: NEG
10643: PPUSH
10644: CALL 96045 0 4
// if not dialogue_skipped then
10648: LD_OWVAR 59
10652: NOT
10653: IFFALSE 10672
// begin CenterOnXY ( 134 , 210 ) ;
10655: LD_INT 134
10657: PPUSH
10658: LD_INT 210
10660: PPUSH
10661: CALL_OW 84
// wait ( 0 0$2 ) ;
10665: LD_INT 70
10667: PPUSH
10668: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
10672: LD_INT 101
10674: PPUSH
10675: LD_INT 159
10677: PPUSH
10678: LD_INT 1
10680: PPUSH
10681: LD_INT 10
10683: NEG
10684: PPUSH
10685: CALL 96045 0 4
// if not dialogue_skipped then
10689: LD_OWVAR 59
10693: NOT
10694: IFFALSE 10713
// begin CenterOnXY ( 101 , 159 ) ;
10696: LD_INT 101
10698: PPUSH
10699: LD_INT 159
10701: PPUSH
10702: CALL_OW 84
// wait ( 0 0$2 ) ;
10706: LD_INT 70
10708: PPUSH
10709: CALL_OW 67
// end ; sync ;
10713: SYNC
// CenterNowOnUnits ( Powell ) ;
10714: LD_EXP 53
10718: PPUSH
10719: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
10723: LD_ADDR_VAR 0 6
10727: PUSH
10728: LD_INT 1
10730: PUSH
10731: LD_INT 2
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: LD_INT 4
10739: PUSH
10740: LD_INT 5
10742: PUSH
10743: LD_INT 6
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: ST_TO_ADDR
// if not dialogue_skipped then
10754: LD_OWVAR 59
10758: NOT
10759: IFFALSE 10920
// begin wait ( 0 0$6 ) ;
10761: LD_INT 210
10763: PPUSH
10764: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
10768: LD_ADDR_VAR 0 7
10772: PUSH
10773: LD_STRING Q1
10775: PPUSH
10776: LD_VAR 0 6
10780: PPUSH
10781: CALL_OW 98
10785: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
10786: LD_ADDR_VAR 0 7
10790: PUSH
10791: LD_STRING Q1
10793: PPUSH
10794: LD_VAR 0 6
10798: PPUSH
10799: CALL_OW 98
10803: ST_TO_ADDR
// options = options diff dec ;
10804: LD_ADDR_VAR 0 6
10808: PUSH
10809: LD_VAR 0 6
10813: PUSH
10814: LD_VAR 0 7
10818: DIFF
10819: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
10820: LD_VAR 0 7
10824: PPUSH
10825: LD_VAR 0 6
10829: PPUSH
10830: CALL 12203 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
10834: LD_VAR 0 7
10838: PUSH
10839: LD_INT 5
10841: PUSH
10842: LD_INT 6
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: IN
10849: PUSH
10850: LD_VAR 0 6
10854: PUSH
10855: LD_INT 2
10857: EQUAL
10858: OR
10859: IFFALSE 10786
// if not ( dec in [ 5 , 6 ] ) then
10861: LD_VAR 0 7
10865: PUSH
10866: LD_INT 5
10868: PUSH
10869: LD_INT 6
10871: PUSH
10872: EMPTY
10873: LIST
10874: LIST
10875: IN
10876: NOT
10877: IFFALSE 10920
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
10879: LD_ADDR_VAR 0 7
10883: PUSH
10884: LD_STRING Q1a
10886: PPUSH
10887: LD_INT 1
10889: PUSH
10890: LD_INT 2
10892: PUSH
10893: EMPTY
10894: LIST
10895: LIST
10896: PPUSH
10897: CALL_OW 98
10901: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
10902: LD_VAR 0 7
10906: PUSH
10907: LD_INT 4
10909: PLUS
10910: PPUSH
10911: LD_VAR 0 6
10915: PPUSH
10916: CALL 12203 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
10920: LD_INT 81
10922: PPUSH
10923: LD_INT 127
10925: PPUSH
10926: CALL_OW 84
// amount := 5 ;
10930: LD_ADDR_VAR 0 8
10934: PUSH
10935: LD_INT 5
10937: ST_TO_ADDR
// macmilan_squad := [ ] ;
10938: LD_ADDR_VAR 0 9
10942: PUSH
10943: EMPTY
10944: ST_TO_ADDR
// if vip < amount then
10945: LD_EXP 54
10949: PUSH
10950: LD_VAR 0 8
10954: LESS
10955: IFFALSE 10999
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
10957: LD_ADDR_VAR 0 5
10961: PUSH
10962: LD_EXP 54
10966: PUSH
10967: LD_INT 22
10969: PUSH
10970: LD_INT 4
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 21
10979: PUSH
10980: LD_INT 1
10982: PUSH
10983: EMPTY
10984: LIST
10985: LIST
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PPUSH
10991: CALL_OW 69
10995: UNION
10996: ST_TO_ADDR
10997: GO 11009
// tmp := vip ;
10999: LD_ADDR_VAR 0 5
11003: PUSH
11004: LD_EXP 54
11008: ST_TO_ADDR
// tmp := tmp diff Powell ;
11009: LD_ADDR_VAR 0 5
11013: PUSH
11014: LD_VAR 0 5
11018: PUSH
11019: LD_EXP 53
11023: DIFF
11024: ST_TO_ADDR
// if tmp < amount then
11025: LD_VAR 0 5
11029: PUSH
11030: LD_VAR 0 8
11034: LESS
11035: IFFALSE 11047
// amount := tmp ;
11037: LD_ADDR_VAR 0 8
11041: PUSH
11042: LD_VAR 0 5
11046: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
11047: LD_VAR 0 5
11051: PUSH
11052: LD_INT 1
11054: ARRAY
11055: PPUSH
11056: CALL_OW 257
11060: PUSH
11061: LD_INT 2
11063: NONEQUAL
11064: IFFALSE 11126
// begin if IsInUnit ( tmp [ 1 ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_INT 1
11073: ARRAY
11074: PPUSH
11075: CALL_OW 310
11079: IFFALSE 11094
// ComExitBuilding ( tmp [ 1 ] ) ;
11081: LD_VAR 0 5
11085: PUSH
11086: LD_INT 1
11088: ARRAY
11089: PPUSH
11090: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
11094: LD_VAR 0 5
11098: PUSH
11099: LD_INT 1
11101: ARRAY
11102: PPUSH
11103: LD_INT 387
11105: PPUSH
11106: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
11110: LD_VAR 0 5
11114: PUSH
11115: LD_INT 1
11117: ARRAY
11118: PPUSH
11119: LD_INT 2
11121: PPUSH
11122: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
11126: LD_EXP 34
11130: PPUSH
11131: LD_INT 82
11133: PPUSH
11134: LD_INT 129
11136: PPUSH
11137: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
11141: LD_EXP 34
11145: PPUSH
11146: LD_EXP 53
11150: PPUSH
11151: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
11155: LD_INT 22
11157: PUSH
11158: LD_INT 1
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_EXP 34
11174: DIFF
11175: PPUSH
11176: LD_INT 84
11178: PPUSH
11179: LD_INT 128
11181: PPUSH
11182: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
11186: LD_INT 22
11188: PUSH
11189: LD_INT 1
11191: PUSH
11192: EMPTY
11193: LIST
11194: LIST
11195: PPUSH
11196: CALL_OW 69
11200: PUSH
11201: LD_EXP 34
11205: DIFF
11206: PPUSH
11207: LD_EXP 34
11211: PPUSH
11212: CALL_OW 179
// for i = 1 to amount do
11216: LD_ADDR_VAR 0 2
11220: PUSH
11221: DOUBLE
11222: LD_INT 1
11224: DEC
11225: ST_TO_ADDR
11226: LD_VAR 0 8
11230: PUSH
11231: FOR_TO
11232: IFFALSE 11400
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
11234: LD_ADDR_VAR 0 9
11238: PUSH
11239: LD_VAR 0 9
11243: PUSH
11244: LD_VAR 0 5
11248: PUSH
11249: LD_VAR 0 2
11253: ARRAY
11254: ADD
11255: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
11256: LD_VAR 0 5
11260: PUSH
11261: LD_VAR 0 2
11265: ARRAY
11266: PPUSH
11267: CALL_OW 310
11271: IFFALSE 11288
// AddComExitBuilding ( tmp [ i ] ) ;
11273: LD_VAR 0 5
11277: PUSH
11278: LD_VAR 0 2
11282: ARRAY
11283: PPUSH
11284: CALL_OW 182
// if i = 2 and JMMNewVeh then
11288: LD_VAR 0 2
11292: PUSH
11293: LD_INT 2
11295: EQUAL
11296: PUSH
11297: LD_EXP 51
11301: AND
11302: IFFALSE 11360
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
11304: LD_VAR 0 5
11308: PUSH
11309: LD_VAR 0 2
11313: ARRAY
11314: PPUSH
11315: LD_EXP 51
11319: PPUSH
11320: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
11324: LD_VAR 0 5
11328: PUSH
11329: LD_VAR 0 2
11333: ARRAY
11334: PPUSH
11335: LD_INT 86
11337: PPUSH
11338: LD_INT 133
11340: PPUSH
11341: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
11345: LD_VAR 0 5
11349: PUSH
11350: LD_VAR 0 2
11354: ARRAY
11355: PPUSH
11356: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
11360: LD_VAR 0 5
11364: PUSH
11365: LD_VAR 0 2
11369: ARRAY
11370: PPUSH
11371: LD_INT 8
11373: PPUSH
11374: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
11378: LD_VAR 0 5
11382: PUSH
11383: LD_VAR 0 2
11387: ARRAY
11388: PPUSH
11389: LD_EXP 34
11393: PPUSH
11394: CALL_OW 179
// end ;
11398: GO 11231
11400: POP
11401: POP
// if GirlNewVeh then
11402: LD_EXP 52
11406: IFFALSE 11420
// SetSide ( GirlNewVeh , 4 ) ;
11408: LD_EXP 52
11412: PPUSH
11413: LD_INT 4
11415: PPUSH
11416: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
11427: LD_VAR 0 9
11431: PPUSH
11432: LD_INT 95
11434: PUSH
11435: LD_INT 9
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PPUSH
11442: CALL_OW 72
11446: PUSH
11447: LD_INT 0
11449: EQUAL
11450: PUSH
11451: LD_EXP 34
11455: PPUSH
11456: LD_INT 9
11458: PPUSH
11459: CALL_OW 308
11463: NOT
11464: AND
11465: IFFALSE 11420
// wait ( 0 0$2 ) ;
11467: LD_INT 70
11469: PPUSH
11470: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
11474: LD_VAR 0 9
11478: PPUSH
11479: LD_INT 1
11481: PPUSH
11482: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
11486: LD_INT 21
11488: PUSH
11489: LD_INT 2
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 92
11498: PUSH
11499: LD_INT 83
11501: PUSH
11502: LD_INT 130
11504: PUSH
11505: LD_INT 10
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: PPUSH
11518: CALL_OW 69
11522: PPUSH
11523: LD_INT 1
11525: PPUSH
11526: CALL_OW 235
// Video ( false ) ;
11530: LD_INT 0
11532: PPUSH
11533: CALL 96131 0 1
// ChangeMissionObjectives ( M1 ) ;
11537: LD_STRING M1
11539: PPUSH
11540: CALL_OW 337
// SaveForQuickRestart ;
11544: CALL_OW 22
// missionStart := true ;
11548: LD_ADDR_EXP 13
11552: PUSH
11553: LD_INT 1
11555: ST_TO_ADDR
// missionStage := 2 ;
11556: LD_ADDR_EXP 15
11560: PUSH
11561: LD_INT 2
11563: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11564: LD_INT 105
11566: PPUSH
11567: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
11571: LD_ADDR_VAR 0 5
11575: PUSH
11576: LD_VAR 0 5
11580: PUSH
11581: LD_INT 22
11583: PUSH
11584: LD_INT 1
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: LD_INT 21
11593: PUSH
11594: LD_INT 1
11596: PUSH
11597: EMPTY
11598: LIST
11599: LIST
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: PPUSH
11605: CALL_OW 69
11609: DIFF
11610: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
11611: LD_ADDR_EXP 93
11615: PUSH
11616: LD_EXP 93
11620: PPUSH
11621: LD_INT 4
11623: PPUSH
11624: LD_INT 22
11626: PUSH
11627: LD_INT 4
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: LD_INT 23
11636: PUSH
11637: LD_INT 1
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: LD_INT 3
11646: PUSH
11647: LD_INT 21
11649: PUSH
11650: LD_INT 2
11652: PUSH
11653: EMPTY
11654: LIST
11655: LIST
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: LIST
11665: PPUSH
11666: CALL_OW 69
11670: PUSH
11671: LD_EXP 53
11675: DIFF
11676: PPUSH
11677: CALL_OW 1
11681: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
11682: LD_ADDR_VAR 0 4
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 4
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: LD_INT 34
11699: PUSH
11700: LD_INT 12
11702: PUSH
11703: EMPTY
11704: LIST
11705: LIST
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: PPUSH
11711: CALL_OW 69
11715: PUSH
11716: LD_INT 1
11718: ARRAY
11719: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
11720: LD_VAR 0 5
11724: PUSH
11725: LD_INT 1
11727: ARRAY
11728: PPUSH
11729: CALL_OW 310
11733: IFFALSE 11748
// ComExitBuilding ( tmp [ 1 ] ) ;
11735: LD_VAR 0 5
11739: PUSH
11740: LD_INT 1
11742: ARRAY
11743: PPUSH
11744: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
11748: LD_VAR 0 5
11752: PUSH
11753: LD_INT 1
11755: ARRAY
11756: PPUSH
11757: LD_VAR 0 4
11761: PPUSH
11762: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
11766: LD_VAR 0 5
11770: PUSH
11771: LD_INT 1
11773: ARRAY
11774: PPUSH
11775: LD_INT 80
11777: PPUSH
11778: LD_INT 136
11780: PPUSH
11781: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
11785: LD_VAR 0 5
11789: PUSH
11790: LD_INT 1
11792: ARRAY
11793: PPUSH
11794: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
11798: LD_VAR 0 5
11802: PUSH
11803: LD_INT 1
11805: ARRAY
11806: PPUSH
11807: LD_INT 59
11809: PPUSH
11810: LD_INT 112
11812: PPUSH
11813: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
11817: LD_VAR 0 5
11821: PUSH
11822: LD_INT 1
11824: ARRAY
11825: PPUSH
11826: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
11830: LD_EXP 37
11834: PUSH
11835: LD_EXP 54
11839: IN
11840: PUSH
11841: LD_EXP 37
11845: PPUSH
11846: CALL_OW 255
11850: PUSH
11851: LD_INT 1
11853: EQUAL
11854: AND
11855: IFFALSE 11871
// Say ( Lisa , D3nW-Lisa-1 ) else
11857: LD_EXP 37
11861: PPUSH
11862: LD_STRING D3nW-Lisa-1
11864: PPUSH
11865: CALL_OW 88
11869: GO 12115
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
11871: LD_EXP 40
11875: PUSH
11876: LD_EXP 54
11880: IN
11881: PUSH
11882: LD_EXP 40
11886: PPUSH
11887: CALL_OW 255
11891: PUSH
11892: LD_INT 1
11894: EQUAL
11895: AND
11896: IFFALSE 11912
// Say ( Cyrus , D3nW-Cyrus-1 ) else
11898: LD_EXP 40
11902: PPUSH
11903: LD_STRING D3nW-Cyrus-1
11905: PPUSH
11906: CALL_OW 88
11910: GO 12115
// if Bobby in vip and GetSide ( Bobby ) = 1 then
11912: LD_EXP 39
11916: PUSH
11917: LD_EXP 54
11921: IN
11922: PUSH
11923: LD_EXP 39
11927: PPUSH
11928: CALL_OW 255
11932: PUSH
11933: LD_INT 1
11935: EQUAL
11936: AND
11937: IFFALSE 11953
// Say ( Bobby , D3nW-Bobby-1 ) else
11939: LD_EXP 39
11943: PPUSH
11944: LD_STRING D3nW-Bobby-1
11946: PPUSH
11947: CALL_OW 88
11951: GO 12115
// if Gary in vip and GetSide ( Gary ) = 1 then
11953: LD_EXP 46
11957: PUSH
11958: LD_EXP 54
11962: IN
11963: PUSH
11964: LD_EXP 46
11968: PPUSH
11969: CALL_OW 255
11973: PUSH
11974: LD_INT 1
11976: EQUAL
11977: AND
11978: IFFALSE 11994
// Say ( Gary , D3nW-Gary-1 ) else
11980: LD_EXP 46
11984: PPUSH
11985: LD_STRING D3nW-Gary-1
11987: PPUSH
11988: CALL_OW 88
11992: GO 12115
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
11994: LD_EXP 38
11998: PUSH
11999: LD_EXP 54
12003: IN
12004: PUSH
12005: LD_EXP 38
12009: PPUSH
12010: CALL_OW 255
12014: PUSH
12015: LD_INT 1
12017: EQUAL
12018: AND
12019: IFFALSE 12035
// Say ( Donaldson , D3nW-Don-1 ) else
12021: LD_EXP 38
12025: PPUSH
12026: LD_STRING D3nW-Don-1
12028: PPUSH
12029: CALL_OW 88
12033: GO 12115
// if Cornel in vip and GetSide ( Cornel ) = 1 then
12035: LD_EXP 45
12039: PUSH
12040: LD_EXP 54
12044: IN
12045: PUSH
12046: LD_EXP 45
12050: PPUSH
12051: CALL_OW 255
12055: PUSH
12056: LD_INT 1
12058: EQUAL
12059: AND
12060: IFFALSE 12076
// Say ( Cornel , D3nW-Corn-1 ) else
12062: LD_EXP 45
12066: PPUSH
12067: LD_STRING D3nW-Corn-1
12069: PPUSH
12070: CALL_OW 88
12074: GO 12115
// if Frank in vip and GetSide ( Frank ) = 1 then
12076: LD_EXP 47
12080: PUSH
12081: LD_EXP 54
12085: IN
12086: PUSH
12087: LD_EXP 47
12091: PPUSH
12092: CALL_OW 255
12096: PUSH
12097: LD_INT 1
12099: EQUAL
12100: AND
12101: IFFALSE 12115
// Say ( Frank , D3nW-Frank-1 ) ;
12103: LD_EXP 47
12107: PPUSH
12108: LD_STRING D3nW-Frank-1
12110: PPUSH
12111: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
12115: LD_EXP 34
12119: PPUSH
12120: LD_STRING D3nW-JMM-1
12122: PPUSH
12123: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
12127: LD_EXP 34
12131: PPUSH
12132: LD_STRING D3nW-JMM-1a
12134: PPUSH
12135: CALL_OW 88
// t := 0 0$00 ;
12139: LD_ADDR_VAR 0 3
12143: PUSH
12144: LD_INT 0
12146: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12147: LD_INT 35
12149: PPUSH
12150: CALL_OW 67
// t := t + 0 0$1 ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: LD_VAR 0 3
12163: PUSH
12164: LD_INT 35
12166: PLUS
12167: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
12168: LD_INT 59
12170: PPUSH
12171: LD_INT 112
12173: PPUSH
12174: CALL_OW 428
12178: PUSH
12179: LD_VAR 0 3
12183: PUSH
12184: LD_INT 2100
12186: GREATER
12187: OR
12188: IFFALSE 12147
// activeAttacks := true ;
12190: LD_ADDR_EXP 16
12194: PUSH
12195: LD_INT 1
12197: ST_TO_ADDR
// end ;
12198: LD_VAR 0 1
12202: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
12203: LD_INT 0
12205: PPUSH
// case question of 1 :
12206: LD_VAR 0 1
12210: PUSH
12211: LD_INT 1
12213: DOUBLE
12214: EQUAL
12215: IFTRUE 12219
12217: GO 12270
12219: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
12220: LD_EXP 34
12224: PPUSH
12225: LD_STRING D2Mot-JMM-1
12227: PPUSH
12228: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
12232: LD_EXP 53
12236: PPUSH
12237: LD_STRING D2Mot-Pow-1
12239: PPUSH
12240: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
12244: LD_EXP 34
12248: PPUSH
12249: LD_STRING D2Mot-JMM-2
12251: PPUSH
12252: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
12256: LD_EXP 53
12260: PPUSH
12261: LD_STRING D2Mot-Pow-2
12263: PPUSH
12264: CALL_OW 88
// end ; 2 :
12268: GO 12613
12270: LD_INT 2
12272: DOUBLE
12273: EQUAL
12274: IFTRUE 12278
12276: GO 12354
12278: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
12279: LD_EXP 34
12283: PPUSH
12284: LD_STRING D2Rus-JMM-1
12286: PPUSH
12287: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
12291: LD_EXP 53
12295: PPUSH
12296: LD_STRING D2Rus-Pow-1
12298: PPUSH
12299: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
12303: LD_EXP 34
12307: PPUSH
12308: LD_STRING D2Rus-JMM-2
12310: PPUSH
12311: CALL_OW 88
// if not ( 3 in list_of_q ) then
12315: LD_INT 3
12317: PUSH
12318: LD_VAR 0 2
12322: IN
12323: NOT
12324: IFFALSE 12340
// Say ( Powell , D2Rus-Pow-2 ) else
12326: LD_EXP 53
12330: PPUSH
12331: LD_STRING D2Rus-Pow-2
12333: PPUSH
12334: CALL_OW 88
12338: GO 12352
// Say ( Powell , D2Rus-Pow-2a ) ;
12340: LD_EXP 53
12344: PPUSH
12345: LD_STRING D2Rus-Pow-2a
12347: PPUSH
12348: CALL_OW 88
// end ; 3 :
12352: GO 12613
12354: LD_INT 3
12356: DOUBLE
12357: EQUAL
12358: IFTRUE 12362
12360: GO 12447
12362: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
12363: LD_EXP 34
12367: PPUSH
12368: LD_STRING D2Leg-JMM-1
12370: PPUSH
12371: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
12375: LD_EXP 53
12379: PPUSH
12380: LD_STRING D2Leg-Pow-1
12382: PPUSH
12383: CALL_OW 88
// if 2 in list_of_q then
12387: LD_INT 2
12389: PUSH
12390: LD_VAR 0 2
12394: IN
12395: IFFALSE 12421
// begin Say ( JMM , D2Leg-JMM-2 ) ;
12397: LD_EXP 34
12401: PPUSH
12402: LD_STRING D2Leg-JMM-2
12404: PPUSH
12405: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
12409: LD_EXP 53
12413: PPUSH
12414: LD_STRING D2Leg-Pow-2
12416: PPUSH
12417: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
12421: LD_EXP 34
12425: PPUSH
12426: LD_STRING D2Leg-JMM-3
12428: PPUSH
12429: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
12433: LD_EXP 53
12437: PPUSH
12438: LD_STRING D2Leg-Pow-3
12440: PPUSH
12441: CALL_OW 88
// end ; 4 :
12445: GO 12613
12447: LD_INT 4
12449: DOUBLE
12450: EQUAL
12451: IFTRUE 12455
12453: GO 12530
12455: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
12456: LD_EXP 34
12460: PPUSH
12461: LD_STRING D2Ar-JMM-1
12463: PPUSH
12464: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
12468: LD_EXP 53
12472: PPUSH
12473: LD_STRING D2Ar-Pow-1
12475: PPUSH
12476: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
12480: LD_EXP 34
12484: PPUSH
12485: LD_STRING D2Ar-JMM-2
12487: PPUSH
12488: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
12492: LD_EXP 53
12496: PPUSH
12497: LD_STRING D2Ar-Pow-2
12499: PPUSH
12500: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
12504: LD_EXP 34
12508: PPUSH
12509: LD_STRING D2Ar-JMM-3
12511: PPUSH
12512: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
12516: LD_EXP 53
12520: PPUSH
12521: LD_STRING D2Ar-Pow-3
12523: PPUSH
12524: CALL_OW 88
// end ; 5 :
12528: GO 12613
12530: LD_INT 5
12532: DOUBLE
12533: EQUAL
12534: IFTRUE 12538
12536: GO 12553
12538: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
12539: LD_EXP 34
12543: PPUSH
12544: LD_STRING D2Conf-JMM-1
12546: PPUSH
12547: CALL_OW 88
12551: GO 12613
12553: LD_INT 6
12555: DOUBLE
12556: EQUAL
12557: IFTRUE 12561
12559: GO 12612
12561: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
12562: LD_EXP 34
12566: PPUSH
12567: LD_STRING D2Com-JMM-1
12569: PPUSH
12570: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
12574: LD_EXP 53
12578: PPUSH
12579: LD_STRING D2Com-Pow-1
12581: PPUSH
12582: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
12586: LD_EXP 34
12590: PPUSH
12591: LD_STRING D2Com-JMM-2
12593: PPUSH
12594: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
12598: LD_EXP 53
12602: PPUSH
12603: LD_STRING D2Com-Pow-2
12605: PPUSH
12606: CALL_OW 88
// end ; end ;
12610: GO 12613
12612: POP
// end ;
12613: LD_VAR 0 3
12617: RET
// every 0 0$5 trigger missionStart do var tmp ;
12618: LD_EXP 13
12622: IFFALSE 12905
12624: GO 12626
12626: DISABLE
12627: LD_INT 0
12629: PPUSH
// begin repeat wait ( 0 0$1 ) ;
12630: LD_INT 35
12632: PPUSH
12633: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
12637: LD_INT 14
12639: PPUSH
12640: LD_INT 22
12642: PUSH
12643: LD_INT 1
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: PPUSH
12650: CALL_OW 70
12654: PUSH
12655: LD_EXP 15
12659: PUSH
12660: LD_INT 2
12662: PUSH
12663: LD_INT 3
12665: PUSH
12666: LD_INT 4
12668: PUSH
12669: LD_INT 5
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: IN
12678: AND
12679: IFFALSE 12895
// begin powellAnger := powellAnger + 1 ;
12681: LD_ADDR_EXP 17
12685: PUSH
12686: LD_EXP 17
12690: PUSH
12691: LD_INT 1
12693: PLUS
12694: ST_TO_ADDR
// Video ( true ) ;
12695: LD_INT 1
12697: PPUSH
12698: CALL 96131 0 1
// CenterNowOnUnits ( tmp ) ;
12702: LD_VAR 0 1
12706: PPUSH
12707: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
12711: LD_INT 14
12713: PPUSH
12714: LD_INT 22
12716: PUSH
12717: LD_INT 1
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PPUSH
12724: CALL_OW 70
12728: PPUSH
12729: LD_INT 86
12731: PPUSH
12732: LD_INT 133
12734: PPUSH
12735: CALL_OW 111
// async ;
12739: ASYNC
// case powellAnger of 1 :
12740: LD_EXP 17
12744: PUSH
12745: LD_INT 1
12747: DOUBLE
12748: EQUAL
12749: IFTRUE 12753
12751: GO 12768
12753: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
12754: LD_EXP 53
12758: PPUSH
12759: LD_STRING DBack1-Pow-1
12761: PPUSH
12762: CALL_OW 88
12766: GO 12815
12768: LD_INT 2
12770: DOUBLE
12771: EQUAL
12772: IFTRUE 12776
12774: GO 12791
12776: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
12777: LD_EXP 53
12781: PPUSH
12782: LD_STRING DBack2-Pow-1
12784: PPUSH
12785: CALL_OW 88
12789: GO 12815
12791: LD_INT 3
12793: DOUBLE
12794: EQUAL
12795: IFTRUE 12799
12797: GO 12814
12799: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
12800: LD_EXP 53
12804: PPUSH
12805: LD_STRING DBack3-Pow-1
12807: PPUSH
12808: CALL_OW 88
12812: GO 12815
12814: POP
// sync ;
12815: SYNC
// repeat wait ( 0 0$1 ) ;
12816: LD_INT 35
12818: PPUSH
12819: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
12823: LD_INT 14
12825: PPUSH
12826: LD_INT 22
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PPUSH
12836: CALL_OW 70
12840: PPUSH
12841: LD_INT 86
12843: PPUSH
12844: LD_INT 133
12846: PPUSH
12847: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
12851: LD_INT 14
12853: PPUSH
12854: LD_INT 22
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PPUSH
12864: CALL_OW 70
12868: NOT
12869: IFFALSE 12816
// if powellAnger >= 3 then
12871: LD_EXP 17
12875: PUSH
12876: LD_INT 3
12878: GREATEREQUAL
12879: IFFALSE 12888
// YouLost ( Dismissed ) ;
12881: LD_STRING Dismissed
12883: PPUSH
12884: CALL_OW 104
// Video ( false ) ;
12888: LD_INT 0
12890: PPUSH
12891: CALL 96131 0 1
// end ; until missionStage > 5 ;
12895: LD_EXP 15
12899: PUSH
12900: LD_INT 5
12902: GREATER
12903: IFFALSE 12630
// end ;
12905: PPOPN 1
12907: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , ru , un ;
12908: LD_EXP 13
12912: PUSH
12913: LD_INT 22
12915: PUSH
12916: LD_INT 4
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PUSH
12923: LD_INT 21
12925: PUSH
12926: LD_INT 2
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PPUSH
12937: CALL_OW 69
12941: PUSH
12942: LD_INT 4
12944: GREATEREQUAL
12945: AND
12946: PUSH
12947: LD_EXP 15
12951: PUSH
12952: LD_INT 2
12954: EQUAL
12955: AND
12956: IFFALSE 14503
12958: GO 12960
12960: DISABLE
12961: LD_INT 0
12963: PPUSH
12964: PPUSH
12965: PPUSH
12966: PPUSH
12967: PPUSH
12968: PPUSH
12969: PPUSH
// begin missionStage := 3 ;
12970: LD_ADDR_EXP 15
12974: PUSH
12975: LD_INT 3
12977: ST_TO_ADDR
// retreat := false ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 0
12985: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
12986: LD_ADDR_VAR 0 5
12990: PUSH
12991: LD_INT 22
12993: PUSH
12994: LD_INT 4
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: PUSH
13001: LD_INT 30
13003: PUSH
13004: LD_INT 4
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PPUSH
13015: CALL_OW 69
13019: PUSH
13020: LD_INT 1
13022: ARRAY
13023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13024: LD_INT 35
13026: PPUSH
13027: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
13031: LD_EXP 112
13035: PUSH
13036: LD_INT 4
13038: ARRAY
13039: PUSH
13040: LD_INT 4
13042: GREATEREQUAL
13043: IFFALSE 13024
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff ( Powell ^ vip ) ;
13045: LD_ADDR_VAR 0 2
13049: PUSH
13050: LD_INT 22
13052: PUSH
13053: LD_INT 4
13055: PUSH
13056: EMPTY
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 2
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 1
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 2
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 3
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 4
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: EMPTY
13104: LIST
13105: LIST
13106: LIST
13107: LIST
13108: LIST
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: PPUSH
13114: CALL_OW 69
13118: PUSH
13119: LD_EXP 53
13123: PUSH
13124: LD_EXP 54
13128: ADD
13129: DIFF
13130: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
13131: LD_ADDR_VAR 0 3
13135: PUSH
13136: LD_VAR 0 2
13140: PPUSH
13141: LD_INT 26
13143: PUSH
13144: LD_INT 1
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: PPUSH
13151: CALL_OW 72
13155: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
13156: LD_ADDR_VAR 0 2
13160: PUSH
13161: LD_VAR 0 2
13165: PUSH
13166: LD_VAR 0 3
13170: DIFF
13171: ST_TO_ADDR
// for i = 1 to 4 do
13172: LD_ADDR_VAR 0 1
13176: PUSH
13177: DOUBLE
13178: LD_INT 1
13180: DEC
13181: ST_TO_ADDR
13182: LD_INT 4
13184: PUSH
13185: FOR_TO
13186: IFFALSE 13352
// begin if tmp2 then
13188: LD_VAR 0 3
13192: IFFALSE 13273
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
13194: LD_ADDR_EXP 18
13198: PUSH
13199: LD_EXP 18
13203: PPUSH
13204: LD_INT 1
13206: PPUSH
13207: LD_EXP 18
13211: PUSH
13212: LD_INT 1
13214: ARRAY
13215: PUSH
13216: LD_VAR 0 3
13220: PUSH
13221: LD_VAR 0 3
13225: ARRAY
13226: ADD
13227: PPUSH
13228: CALL_OW 1
13232: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
13233: LD_VAR 0 3
13237: PUSH
13238: LD_VAR 0 3
13242: ARRAY
13243: PPUSH
13244: LD_INT 1
13246: PPUSH
13247: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
13251: LD_ADDR_VAR 0 3
13255: PUSH
13256: LD_VAR 0 3
13260: PPUSH
13261: LD_VAR 0 3
13265: PPUSH
13266: CALL_OW 3
13270: ST_TO_ADDR
// end else
13271: GO 13350
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
13273: LD_ADDR_EXP 18
13277: PUSH
13278: LD_EXP 18
13282: PPUSH
13283: LD_INT 1
13285: PPUSH
13286: LD_EXP 18
13290: PUSH
13291: LD_INT 1
13293: ARRAY
13294: PUSH
13295: LD_VAR 0 2
13299: PUSH
13300: LD_VAR 0 2
13304: ARRAY
13305: ADD
13306: PPUSH
13307: CALL_OW 1
13311: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
13312: LD_VAR 0 2
13316: PUSH
13317: LD_VAR 0 2
13321: ARRAY
13322: PPUSH
13323: LD_INT 1
13325: PPUSH
13326: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
13330: LD_ADDR_VAR 0 2
13334: PUSH
13335: LD_VAR 0 2
13339: PPUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: CALL_OW 3
13349: ST_TO_ADDR
// end ; end ;
13350: GO 13185
13352: POP
13353: POP
// if tmp2 then
13354: LD_VAR 0 3
13358: IFFALSE 13376
// tmp := tmp union tmp2 ;
13360: LD_ADDR_VAR 0 2
13364: PUSH
13365: LD_VAR 0 2
13369: PUSH
13370: LD_VAR 0 3
13374: UNION
13375: ST_TO_ADDR
// for i = 1 to 4 do
13376: LD_ADDR_VAR 0 1
13380: PUSH
13381: DOUBLE
13382: LD_INT 1
13384: DEC
13385: ST_TO_ADDR
13386: LD_INT 4
13388: PUSH
13389: FOR_TO
13390: IFFALSE 13439
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
13392: LD_ADDR_EXP 18
13396: PUSH
13397: LD_EXP 18
13401: PPUSH
13402: LD_INT 2
13404: PPUSH
13405: LD_EXP 18
13409: PUSH
13410: LD_INT 2
13412: ARRAY
13413: PUSH
13414: LD_VAR 0 2
13418: PUSH
13419: LD_VAR 0 2
13423: PUSH
13424: LD_VAR 0 1
13428: MINUS
13429: ARRAY
13430: ADD
13431: PPUSH
13432: CALL_OW 1
13436: ST_TO_ADDR
13437: GO 13389
13439: POP
13440: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
13441: LD_ADDR_EXP 93
13445: PUSH
13446: LD_EXP 93
13450: PPUSH
13451: LD_INT 4
13453: PPUSH
13454: LD_EXP 93
13458: PUSH
13459: LD_INT 4
13461: ARRAY
13462: PUSH
13463: LD_EXP 18
13467: PUSH
13468: LD_INT 1
13470: ARRAY
13471: DIFF
13472: PPUSH
13473: CALL_OW 1
13477: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
13478: LD_ADDR_VAR 0 1
13482: PUSH
13483: LD_EXP 18
13487: PUSH
13488: LD_INT 1
13490: ARRAY
13491: PUSH
13492: FOR_IN
13493: IFFALSE 13596
// begin if IsInUnit ( i ) then
13495: LD_VAR 0 1
13499: PPUSH
13500: CALL_OW 310
13504: IFFALSE 13515
// ComExitBuilding ( i ) ;
13506: LD_VAR 0 1
13510: PPUSH
13511: CALL_OW 122
// if GetClass ( i ) <> 1 then
13515: LD_VAR 0 1
13519: PPUSH
13520: CALL_OW 257
13524: PUSH
13525: LD_INT 1
13527: NONEQUAL
13528: IFFALSE 13565
// begin AddComEnterUnit ( i , arm ) ;
13530: LD_VAR 0 1
13534: PPUSH
13535: LD_VAR 0 5
13539: PPUSH
13540: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
13544: LD_VAR 0 1
13548: PPUSH
13549: LD_INT 1
13551: PPUSH
13552: CALL_OW 183
// AddComExitBuilding ( i ) ;
13556: LD_VAR 0 1
13560: PPUSH
13561: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
13565: LD_VAR 0 1
13569: PPUSH
13570: LD_INT 60
13572: PPUSH
13573: LD_INT 94
13575: PPUSH
13576: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
13580: LD_VAR 0 1
13584: PPUSH
13585: LD_EXP 53
13589: PPUSH
13590: CALL_OW 179
// end ;
13594: GO 13492
13596: POP
13597: POP
// wait ( 0 0$15 ) ;
13598: LD_INT 525
13600: PPUSH
13601: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
13605: LD_EXP 53
13609: PPUSH
13610: LD_STRING D4-Pow-1
13612: PPUSH
13613: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
13617: LD_ADDR_VAR 0 2
13621: PUSH
13622: LD_EXP 18
13626: PUSH
13627: LD_INT 1
13629: ARRAY
13630: PPUSH
13631: LD_INT 26
13633: PUSH
13634: LD_INT 1
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PPUSH
13641: CALL_OW 72
13645: ST_TO_ADDR
// if tmp then
13646: LD_VAR 0 2
13650: IFFALSE 13668
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
13652: LD_VAR 0 2
13656: PUSH
13657: LD_INT 1
13659: ARRAY
13660: PPUSH
13661: LD_STRING D4-Sol1-1
13663: PPUSH
13664: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
13668: LD_EXP 53
13672: PPUSH
13673: LD_STRING D4-Pow-2
13675: PPUSH
13676: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
13680: LD_ADDR_VAR 0 1
13684: PUSH
13685: DOUBLE
13686: LD_INT 1
13688: DEC
13689: ST_TO_ADDR
13690: LD_EXP 18
13694: PUSH
13695: LD_INT 1
13697: ARRAY
13698: PUSH
13699: FOR_TO
13700: IFFALSE 13793
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
13702: LD_EXP 18
13706: PUSH
13707: LD_INT 1
13709: ARRAY
13710: PUSH
13711: LD_VAR 0 1
13715: ARRAY
13716: PPUSH
13717: LD_EXP 112
13721: PUSH
13722: LD_INT 4
13724: ARRAY
13725: PUSH
13726: LD_INT 1
13728: ARRAY
13729: PPUSH
13730: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
13734: LD_ADDR_EXP 112
13738: PUSH
13739: LD_EXP 112
13743: PPUSH
13744: LD_INT 4
13746: PPUSH
13747: LD_EXP 112
13751: PUSH
13752: LD_INT 4
13754: ARRAY
13755: PPUSH
13756: LD_INT 1
13758: PPUSH
13759: CALL_OW 3
13763: PPUSH
13764: CALL_OW 1
13768: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
13769: LD_INT 8
13771: PPUSH
13772: LD_EXP 18
13776: PUSH
13777: LD_INT 1
13779: ARRAY
13780: PUSH
13781: LD_VAR 0 1
13785: ARRAY
13786: PPUSH
13787: CALL_OW 471
// end ;
13791: GO 13699
13793: POP
13794: POP
// repeat wait ( 0 0$1 ) ;
13795: LD_INT 35
13797: PPUSH
13798: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
13802: LD_EXP 18
13806: PUSH
13807: LD_INT 1
13809: ARRAY
13810: PPUSH
13811: LD_INT 55
13813: PUSH
13814: EMPTY
13815: LIST
13816: PPUSH
13817: CALL_OW 72
13821: PUSH
13822: LD_INT 4
13824: GREATEREQUAL
13825: IFFALSE 13795
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
13827: LD_EXP 18
13831: PUSH
13832: LD_INT 1
13834: ARRAY
13835: PPUSH
13836: LD_INT 69
13838: PPUSH
13839: LD_INT 94
13841: PPUSH
13842: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
13846: LD_EXP 18
13850: PUSH
13851: LD_INT 1
13853: ARRAY
13854: PPUSH
13855: LD_INT 82
13857: PPUSH
13858: LD_INT 83
13860: PPUSH
13861: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
13865: LD_EXP 18
13869: PUSH
13870: LD_INT 1
13872: ARRAY
13873: PPUSH
13874: LD_INT 77
13876: PPUSH
13877: LD_INT 69
13879: PPUSH
13880: CALL_OW 174
// repeat wait ( 3 ) ;
13884: LD_INT 3
13886: PPUSH
13887: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
13891: LD_ADDR_VAR 0 1
13895: PUSH
13896: LD_EXP 18
13900: PUSH
13901: LD_INT 1
13903: ARRAY
13904: PUSH
13905: FOR_IN
13906: IFFALSE 14015
// begin if GetLives ( i ) < 990 then
13908: LD_VAR 0 1
13912: PPUSH
13913: CALL_OW 256
13917: PUSH
13918: LD_INT 990
13920: LESS
13921: IFFALSE 13935
// SetLives ( i , 1000 ) ;
13923: LD_VAR 0 1
13927: PPUSH
13928: LD_INT 1000
13930: PPUSH
13931: CALL_OW 234
// if not IsInUnit ( i ) then
13935: LD_VAR 0 1
13939: PPUSH
13940: CALL_OW 310
13944: NOT
13945: IFFALSE 14013
// begin if not retreat and GetSex ( i ) = sex_male then
13947: LD_VAR 0 4
13951: NOT
13952: PUSH
13953: LD_VAR 0 1
13957: PPUSH
13958: CALL_OW 258
13962: PUSH
13963: LD_INT 1
13965: EQUAL
13966: AND
13967: IFFALSE 14013
// begin retreat := true ;
13969: LD_ADDR_VAR 0 4
13973: PUSH
13974: LD_INT 1
13976: ST_TO_ADDR
// SetTag ( i , 2 ) ;
13977: LD_VAR 0 1
13981: PPUSH
13982: LD_INT 2
13984: PPUSH
13985: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
13989: LD_VAR 0 1
13993: PPUSH
13994: LD_STRING D4a-Sol1-1
13996: PPUSH
13997: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
14001: LD_EXP 53
14005: PPUSH
14006: LD_STRING D4a-Pow-1
14008: PPUSH
14009: CALL_OW 88
// end ; end ; end ;
14013: GO 13905
14015: POP
14016: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
14017: LD_EXP 18
14021: PUSH
14022: LD_INT 1
14024: ARRAY
14025: PPUSH
14026: LD_INT 95
14028: PUSH
14029: LD_INT 9
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 3
14038: PUSH
14039: LD_INT 55
14041: PUSH
14042: EMPTY
14043: LIST
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PPUSH
14053: CALL_OW 72
14057: PUSH
14058: LD_INT 4
14060: GREATEREQUAL
14061: IFFALSE 13884
// for i in powellSquadAttack [ 1 ] do
14063: LD_ADDR_VAR 0 1
14067: PUSH
14068: LD_EXP 18
14072: PUSH
14073: LD_INT 1
14075: ARRAY
14076: PUSH
14077: FOR_IN
14078: IFFALSE 14214
// begin if GetTag ( i ) = 2 then
14080: LD_VAR 0 1
14084: PPUSH
14085: CALL_OW 110
14089: PUSH
14090: LD_INT 2
14092: EQUAL
14093: IFFALSE 14155
// begin ComMoveXY ( i , 60 , 94 ) ;
14095: LD_VAR 0 1
14099: PPUSH
14100: LD_INT 60
14102: PPUSH
14103: LD_INT 94
14105: PPUSH
14106: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
14110: LD_VAR 0 1
14114: PPUSH
14115: LD_EXP 53
14119: PPUSH
14120: CALL_OW 179
// wait ( 0 0$3 ) ;
14124: LD_INT 105
14126: PPUSH
14127: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
14131: LD_VAR 0 1
14135: PPUSH
14136: LD_STRING D4a-Sol1-2
14138: PPUSH
14139: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
14143: LD_EXP 53
14147: PPUSH
14148: LD_STRING D4a-Pow-2
14150: PPUSH
14151: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
14155: LD_VAR 0 1
14159: PPUSH
14160: LD_INT 0
14162: PPUSH
14163: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
14167: LD_ADDR_EXP 93
14171: PUSH
14172: LD_EXP 93
14176: PPUSH
14177: LD_INT 4
14179: PPUSH
14180: LD_EXP 93
14184: PUSH
14185: LD_INT 4
14187: ARRAY
14188: PUSH
14189: LD_VAR 0 1
14193: UNION
14194: PPUSH
14195: CALL_OW 1
14199: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
14200: LD_INT 8
14202: PPUSH
14203: LD_VAR 0 1
14207: PPUSH
14208: CALL_OW 472
// end ;
14212: GO 14077
14214: POP
14215: POP
// wait ( 4 4$00 ) ;
14216: LD_INT 8400
14218: PPUSH
14219: CALL_OW 67
// uc_side := 6 ;
14223: LD_ADDR_OWVAR 20
14227: PUSH
14228: LD_INT 6
14230: ST_TO_ADDR
// uc_nation := 3 ;
14231: LD_ADDR_OWVAR 21
14235: PUSH
14236: LD_INT 3
14238: ST_TO_ADDR
// ru := [ ] ;
14239: LD_ADDR_VAR 0 6
14243: PUSH
14244: EMPTY
14245: ST_TO_ADDR
// for i = 1 to 4 do
14246: LD_ADDR_VAR 0 1
14250: PUSH
14251: DOUBLE
14252: LD_INT 1
14254: DEC
14255: ST_TO_ADDR
14256: LD_INT 4
14258: PUSH
14259: FOR_TO
14260: IFFALSE 14361
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
14262: LD_INT 22
14264: PPUSH
14265: LD_INT 1
14267: PPUSH
14268: LD_INT 3
14270: PPUSH
14271: LD_INT 43
14273: PUSH
14274: LD_INT 44
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_INT 1
14283: PPUSH
14284: LD_INT 2
14286: PPUSH
14287: CALL_OW 12
14291: ARRAY
14292: PPUSH
14293: LD_INT 89
14295: PPUSH
14296: CALL 60476 0 5
// un := CreateVehicle ;
14300: LD_ADDR_VAR 0 7
14304: PUSH
14305: CALL_OW 45
14309: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14310: LD_VAR 0 7
14314: PPUSH
14315: LD_INT 4
14317: PPUSH
14318: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
14322: LD_VAR 0 7
14326: PPUSH
14327: LD_INT 136
14329: PPUSH
14330: LD_INT 90
14332: PPUSH
14333: LD_INT 8
14335: PPUSH
14336: LD_INT 0
14338: PPUSH
14339: CALL_OW 50
// ru := ru ^ un ;
14343: LD_ADDR_VAR 0 6
14347: PUSH
14348: LD_VAR 0 6
14352: PUSH
14353: LD_VAR 0 7
14357: ADD
14358: ST_TO_ADDR
// end ;
14359: GO 14259
14361: POP
14362: POP
// if ru then
14363: LD_VAR 0 6
14367: IFFALSE 14384
// ComAgressiveMove ( ru , 80 , 93 ) ;
14369: LD_VAR 0 6
14373: PPUSH
14374: LD_INT 80
14376: PPUSH
14377: LD_INT 93
14379: PPUSH
14380: CALL_OW 114
// wait ( 8 8$00 ) ;
14384: LD_INT 16800
14386: PPUSH
14387: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
14391: LD_INT 4
14393: PPUSH
14394: LD_INT 3
14396: PUSH
14397: LD_INT 1
14399: PUSH
14400: LD_INT 1
14402: PUSH
14403: LD_INT 5
14405: PUSH
14406: EMPTY
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: PUSH
14412: LD_INT 4
14414: PUSH
14415: LD_INT 1
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: LD_INT 6
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: PUSH
14430: LD_INT 4
14432: PUSH
14433: LD_INT 1
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: LD_INT 7
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 3
14450: PUSH
14451: LD_INT 1
14453: PUSH
14454: LD_INT 1
14456: PUSH
14457: LD_INT 7
14459: PUSH
14460: EMPTY
14461: LIST
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 3
14468: PUSH
14469: LD_INT 1
14471: PUSH
14472: LD_INT 1
14474: PUSH
14475: LD_INT 5
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: PPUSH
14491: CALL 47900 0 2
// missionStage := 4 ;
14495: LD_ADDR_EXP 15
14499: PUSH
14500: LD_INT 4
14502: ST_TO_ADDR
// end ;
14503: PPOPN 7
14505: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
14506: LD_EXP 15
14510: PUSH
14511: LD_INT 4
14513: EQUAL
14514: PUSH
14515: LD_INT 22
14517: PUSH
14518: LD_INT 4
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PUSH
14525: LD_INT 21
14527: PUSH
14528: LD_INT 2
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: PPUSH
14539: CALL_OW 69
14543: PUSH
14544: LD_INT 5
14546: GREATEREQUAL
14547: AND
14548: IFFALSE 18592
14550: GO 14552
14552: DISABLE
14553: LD_INT 0
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
// begin missionStage := 5 ;
14568: LD_ADDR_EXP 15
14572: PUSH
14573: LD_INT 5
14575: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
14576: LD_ADDR_VAR 0 10
14580: PUSH
14581: LD_INT 22
14583: PUSH
14584: LD_INT 4
14586: PUSH
14587: EMPTY
14588: LIST
14589: LIST
14590: PUSH
14591: LD_INT 2
14593: PUSH
14594: LD_INT 30
14596: PUSH
14597: LD_INT 4
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PUSH
14604: LD_INT 30
14606: PUSH
14607: LD_INT 5
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: LIST
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PPUSH
14623: CALL_OW 69
14627: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
14628: LD_ADDR_VAR 0 6
14632: PUSH
14633: LD_INT 22
14635: PUSH
14636: LD_INT 4
14638: PUSH
14639: EMPTY
14640: LIST
14641: LIST
14642: PUSH
14643: LD_INT 21
14645: PUSH
14646: LD_INT 1
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: PUSH
14653: LD_INT 3
14655: PUSH
14656: LD_INT 25
14658: PUSH
14659: LD_INT 16
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: PUSH
14670: LD_INT 3
14672: PUSH
14673: LD_INT 25
14675: PUSH
14676: LD_INT 12
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: PPUSH
14693: CALL_OW 69
14697: PUSH
14698: LD_EXP 53
14702: DIFF
14703: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14704: LD_ADDR_VAR 0 9
14708: PUSH
14709: LD_INT 22
14711: PUSH
14712: LD_INT 4
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: LD_INT 30
14721: PUSH
14722: LD_INT 3
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PPUSH
14733: CALL_OW 69
14737: PUSH
14738: LD_INT 1
14740: ARRAY
14741: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14742: LD_INT 35
14744: PPUSH
14745: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
14749: LD_EXP 112
14753: PUSH
14754: LD_INT 4
14756: ARRAY
14757: PUSH
14758: LD_INT 5
14760: GREATEREQUAL
14761: IFFALSE 14742
// powellAllowRetreat := false ;
14763: LD_ADDR_EXP 19
14767: PUSH
14768: LD_INT 0
14770: ST_TO_ADDR
// wait ( 0 0$20 ) ;
14771: LD_INT 700
14773: PPUSH
14774: CALL_OW 67
// activeAttacks := false ;
14778: LD_ADDR_EXP 16
14782: PUSH
14783: LD_INT 0
14785: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14786: LD_INT 35
14788: PPUSH
14789: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
14793: LD_INT 22
14795: PUSH
14796: LD_INT 6
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PPUSH
14803: CALL_OW 69
14807: PUSH
14808: LD_INT 0
14810: EQUAL
14811: IFFALSE 14786
// tmp := mc_vehicles [ 4 ] ;
14813: LD_ADDR_VAR 0 3
14817: PUSH
14818: LD_EXP 112
14822: PUSH
14823: LD_INT 4
14825: ARRAY
14826: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
14827: LD_ADDR_VAR 0 1
14831: PUSH
14832: DOUBLE
14833: LD_INT 1
14835: DEC
14836: ST_TO_ADDR
14837: LD_EXP 18
14841: PUSH
14842: FOR_TO
14843: IFFALSE 15104
// begin for j in powellSquadAttack [ i ] do
14845: LD_ADDR_VAR 0 2
14849: PUSH
14850: LD_EXP 18
14854: PUSH
14855: LD_VAR 0 1
14859: ARRAY
14860: PUSH
14861: FOR_IN
14862: IFFALSE 15100
// begin forces := forces diff j ;
14864: LD_ADDR_VAR 0 6
14868: PUSH
14869: LD_VAR 0 6
14873: PUSH
14874: LD_VAR 0 2
14878: DIFF
14879: ST_TO_ADDR
// SetTag ( j , 1 ) ;
14880: LD_VAR 0 2
14884: PPUSH
14885: LD_INT 1
14887: PPUSH
14888: CALL_OW 109
// wait ( 0 0$2 ) ;
14892: LD_INT 70
14894: PPUSH
14895: CALL_OW 67
// if IsInUnit ( j ) then
14899: LD_VAR 0 2
14903: PPUSH
14904: CALL_OW 310
14908: IFFALSE 14919
// ComExitBuilding ( j ) ;
14910: LD_VAR 0 2
14914: PPUSH
14915: CALL_OW 122
// if GetClass ( j ) <> 1 then
14919: LD_VAR 0 2
14923: PPUSH
14924: CALL_OW 257
14928: PUSH
14929: LD_INT 1
14931: NONEQUAL
14932: IFFALSE 15012
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
14934: LD_VAR 0 10
14938: PUSH
14939: LD_INT 1
14941: ARRAY
14942: PPUSH
14943: CALL_OW 313
14947: PUSH
14948: LD_INT 5
14950: GREATEREQUAL
14951: IFFALSE 14973
// AddComEnterUnit ( j , arm [ 2 ] ) else
14953: LD_VAR 0 2
14957: PPUSH
14958: LD_VAR 0 10
14962: PUSH
14963: LD_INT 2
14965: ARRAY
14966: PPUSH
14967: CALL_OW 180
14971: GO 14991
// AddComEnterUnit ( j , arm [ 1 ] ) ;
14973: LD_VAR 0 2
14977: PPUSH
14978: LD_VAR 0 10
14982: PUSH
14983: LD_INT 1
14985: ARRAY
14986: PPUSH
14987: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
14991: LD_VAR 0 2
14995: PPUSH
14996: LD_INT 1
14998: PPUSH
14999: CALL_OW 183
// AddComExitBuilding ( j ) ;
15003: LD_VAR 0 2
15007: PPUSH
15008: CALL_OW 182
// end ; if i = 2 then
15012: LD_VAR 0 1
15016: PUSH
15017: LD_INT 2
15019: EQUAL
15020: IFFALSE 15037
// AddComMoveXY ( j , 61 , 93 ) ;
15022: LD_VAR 0 2
15026: PPUSH
15027: LD_INT 61
15029: PPUSH
15030: LD_INT 93
15032: PPUSH
15033: CALL_OW 171
// if i = 1 then
15037: LD_VAR 0 1
15041: PUSH
15042: LD_INT 1
15044: EQUAL
15045: IFFALSE 15098
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
15047: LD_VAR 0 2
15051: PPUSH
15052: LD_VAR 0 3
15056: PUSH
15057: LD_INT 1
15059: ARRAY
15060: PPUSH
15061: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_VAR 0 3
15074: PPUSH
15075: LD_INT 1
15077: PPUSH
15078: CALL_OW 3
15082: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
15083: LD_VAR 0 2
15087: PPUSH
15088: LD_INT 69
15090: PPUSH
15091: LD_INT 94
15093: PPUSH
15094: CALL_OW 171
// end ; end ;
15098: GO 14861
15100: POP
15101: POP
// end ;
15102: GO 14842
15104: POP
15105: POP
// wait ( 0 0$45 ) ;
15106: LD_INT 1575
15108: PPUSH
15109: CALL_OW 67
// MC_Kill ( 4 ) ;
15113: LD_INT 4
15115: PPUSH
15116: CALL 26192 0 1
// tmp := UnitsInside ( fac ) ;
15120: LD_ADDR_VAR 0 3
15124: PUSH
15125: LD_VAR 0 9
15129: PPUSH
15130: CALL_OW 313
15134: ST_TO_ADDR
// if tmp then
15135: LD_VAR 0 3
15139: IFFALSE 15260
// for i in tmp do
15141: LD_ADDR_VAR 0 1
15145: PUSH
15146: LD_VAR 0 3
15150: PUSH
15151: FOR_IN
15152: IFFALSE 15258
// begin ComExitBuilding ( i ) ;
15154: LD_VAR 0 1
15158: PPUSH
15159: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
15163: LD_VAR 0 10
15167: PUSH
15168: LD_INT 2
15170: ARRAY
15171: PPUSH
15172: CALL_OW 313
15176: PUSH
15177: LD_INT 6
15179: LESS
15180: IFFALSE 15202
// AddComEnterUnit ( i , arm [ 2 ] ) else
15182: LD_VAR 0 1
15186: PPUSH
15187: LD_VAR 0 10
15191: PUSH
15192: LD_INT 2
15194: ARRAY
15195: PPUSH
15196: CALL_OW 180
15200: GO 15256
// if UnitsInside ( arm [ 1 ] ) < 6 then
15202: LD_VAR 0 10
15206: PUSH
15207: LD_INT 1
15209: ARRAY
15210: PPUSH
15211: CALL_OW 313
15215: PUSH
15216: LD_INT 6
15218: LESS
15219: IFFALSE 15241
// AddComEnterUnit ( i , arm [ 1 ] ) else
15221: LD_VAR 0 1
15225: PPUSH
15226: LD_VAR 0 10
15230: PUSH
15231: LD_INT 1
15233: ARRAY
15234: PPUSH
15235: CALL_OW 180
15239: GO 15256
// AddComMoveXY ( i , 37 , 68 ) ;
15241: LD_VAR 0 1
15245: PPUSH
15246: LD_INT 37
15248: PPUSH
15249: LD_INT 68
15251: PPUSH
15252: CALL_OW 171
// end ;
15256: GO 15151
15258: POP
15259: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
15260: LD_ADDR_VAR 0 11
15264: PUSH
15265: LD_VAR 0 6
15269: PPUSH
15270: LD_INT 26
15272: PUSH
15273: LD_INT 1
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: PPUSH
15280: CALL_OW 72
15284: PUSH
15285: LD_EXP 54
15289: DIFF
15290: ST_TO_ADDR
// if not speaker then
15291: LD_VAR 0 11
15295: NOT
15296: IFFALSE 15323
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
15298: LD_ADDR_VAR 0 11
15302: PUSH
15303: LD_VAR 0 6
15307: PPUSH
15308: LD_INT 26
15310: PUSH
15311: LD_INT 1
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PPUSH
15318: CALL_OW 72
15322: ST_TO_ADDR
// if speaker then
15323: LD_VAR 0 11
15327: IFFALSE 15343
// speaker := speaker [ 1 ] ;
15329: LD_ADDR_VAR 0 11
15333: PUSH
15334: LD_VAR 0 11
15338: PUSH
15339: LD_INT 1
15341: ARRAY
15342: ST_TO_ADDR
// Video ( true ) ;
15343: LD_INT 1
15345: PPUSH
15346: CALL 96131 0 1
// CenterNowOnUnits ( Powell ) ;
15350: LD_EXP 53
15354: PPUSH
15355: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
15359: LD_ADDR_VAR 0 3
15363: PUSH
15364: LD_VAR 0 6
15368: PPUSH
15369: LD_INT 3
15371: PUSH
15372: LD_INT 25
15374: PUSH
15375: LD_INT 1
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: PUSH
15382: EMPTY
15383: LIST
15384: LIST
15385: PPUSH
15386: CALL_OW 72
15390: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
15391: LD_ADDR_VAR 0 12
15395: PUSH
15396: LD_INT 22
15398: PUSH
15399: LD_INT 4
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PUSH
15406: LD_INT 30
15408: PUSH
15409: LD_INT 32
15411: PUSH
15412: EMPTY
15413: LIST
15414: LIST
15415: PUSH
15416: LD_INT 58
15418: PUSH
15419: EMPTY
15420: LIST
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: LIST
15426: PPUSH
15427: CALL_OW 69
15431: ST_TO_ADDR
// for i = 1 to 6 do
15432: LD_ADDR_VAR 0 1
15436: PUSH
15437: DOUBLE
15438: LD_INT 1
15440: DEC
15441: ST_TO_ADDR
15442: LD_INT 6
15444: PUSH
15445: FOR_TO
15446: IFFALSE 15587
// begin if IsInUnit ( tmp [ i ] ) then
15448: LD_VAR 0 3
15452: PUSH
15453: LD_VAR 0 1
15457: ARRAY
15458: PPUSH
15459: CALL_OW 310
15463: IFFALSE 15480
// ComExitBuilding ( tmp [ i ] ) ;
15465: LD_VAR 0 3
15469: PUSH
15470: LD_VAR 0 1
15474: ARRAY
15475: PPUSH
15476: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
15480: LD_VAR 0 3
15484: PUSH
15485: LD_VAR 0 1
15489: ARRAY
15490: PPUSH
15491: LD_VAR 0 10
15495: PUSH
15496: LD_INT 1
15498: ARRAY
15499: PPUSH
15500: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
15504: LD_VAR 0 3
15508: PUSH
15509: LD_VAR 0 1
15513: ARRAY
15514: PPUSH
15515: LD_INT 1
15517: PPUSH
15518: CALL_OW 183
// if emp_towers then
15522: LD_VAR 0 12
15526: IFFALSE 15585
// begin AddComExitBuilding ( tmp [ i ] ) ;
15528: LD_VAR 0 3
15532: PUSH
15533: LD_VAR 0 1
15537: ARRAY
15538: PPUSH
15539: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
15543: LD_VAR 0 3
15547: PUSH
15548: LD_VAR 0 1
15552: ARRAY
15553: PPUSH
15554: LD_VAR 0 12
15558: PUSH
15559: LD_INT 1
15561: ARRAY
15562: PPUSH
15563: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
15567: LD_ADDR_VAR 0 12
15571: PUSH
15572: LD_VAR 0 12
15576: PPUSH
15577: LD_INT 1
15579: PPUSH
15580: CALL_OW 3
15584: ST_TO_ADDR
// end ; end ;
15585: GO 15445
15587: POP
15588: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
15589: LD_ADDR_VAR 0 3
15593: PUSH
15594: LD_EXP 18
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PUSH
15603: LD_EXP 18
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: ADD
15612: PPUSH
15613: LD_INT 26
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PPUSH
15623: CALL_OW 72
15627: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
15628: LD_ADDR_VAR 0 1
15632: PUSH
15633: LD_EXP 18
15637: PUSH
15638: LD_INT 2
15640: ARRAY
15641: PUSH
15642: FOR_IN
15643: IFFALSE 15661
// ComTurnUnit ( i , Powell ) ;
15645: LD_VAR 0 1
15649: PPUSH
15650: LD_EXP 53
15654: PPUSH
15655: CALL_OW 119
15659: GO 15642
15661: POP
15662: POP
// Say ( Powell , D5-Pow-1 ) ;
15663: LD_EXP 53
15667: PPUSH
15668: LD_STRING D5-Pow-1
15670: PPUSH
15671: CALL_OW 88
// if tmp then
15675: LD_VAR 0 3
15679: IFFALSE 15697
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
15681: LD_VAR 0 3
15685: PUSH
15686: LD_INT 1
15688: ARRAY
15689: PPUSH
15690: LD_STRING D5-Sol2-1
15692: PPUSH
15693: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
15697: LD_EXP 53
15701: PPUSH
15702: LD_STRING D5-Pow-2
15704: PPUSH
15705: CALL_OW 88
// if tmp > 1 then
15709: LD_VAR 0 3
15713: PUSH
15714: LD_INT 1
15716: GREATER
15717: IFFALSE 15735
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
15719: LD_VAR 0 3
15723: PUSH
15724: LD_INT 2
15726: ARRAY
15727: PPUSH
15728: LD_STRING D5-Sol2-2
15730: PPUSH
15731: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
15735: LD_EXP 53
15739: PPUSH
15740: LD_STRING D5-Pow-3
15742: PPUSH
15743: CALL_OW 88
// wait ( 0 0$1 ) ;
15747: LD_INT 35
15749: PPUSH
15750: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
15754: LD_ADDR_VAR 0 3
15758: PUSH
15759: LD_EXP 18
15763: PUSH
15764: LD_INT 1
15766: ARRAY
15767: PUSH
15768: LD_EXP 18
15772: PUSH
15773: LD_INT 2
15775: ARRAY
15776: UNION
15777: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
15778: LD_VAR 0 3
15782: PPUSH
15783: LD_INT 80
15785: PPUSH
15786: LD_INT 67
15788: PPUSH
15789: CALL_OW 114
// wait ( 0 0$2 ) ;
15793: LD_INT 70
15795: PPUSH
15796: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
15800: LD_INT 79
15802: PPUSH
15803: LD_INT 72
15805: PPUSH
15806: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
15810: LD_INT 35
15812: PPUSH
15813: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
15817: LD_VAR 0 3
15821: PPUSH
15822: LD_INT 3
15824: PUSH
15825: LD_INT 24
15827: PUSH
15828: LD_INT 1000
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: PPUSH
15839: CALL_OW 72
15843: IFFALSE 15810
// Say ( Powell , D5a-Pow-1 ) ;
15845: LD_EXP 53
15849: PPUSH
15850: LD_STRING D5a-Pow-1
15852: PPUSH
15853: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
15857: LD_EXP 53
15861: PPUSH
15862: LD_STRING D5a-Pow-1a
15864: PPUSH
15865: CALL_OW 88
// wait ( 0 0$0.3 ) ;
15869: LD_INT 10
15871: PPUSH
15872: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
15876: LD_EXP 53
15880: PPUSH
15881: LD_STRING D5a-Pow-1b
15883: PPUSH
15884: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
15888: LD_EXP 53
15892: PPUSH
15893: LD_STRING D5a-Pow-1c
15895: PPUSH
15896: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
15900: LD_EXP 53
15904: PPUSH
15905: LD_STRING D5a-Pow-1d
15907: PPUSH
15908: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
15912: LD_INT 35
15914: PPUSH
15915: CALL_OW 67
// if not HasTask ( tmp ) then
15919: LD_VAR 0 3
15923: PPUSH
15924: CALL_OW 314
15928: NOT
15929: IFFALSE 15946
// ComAgressiveMove ( tmp , 80 , 67 ) ;
15931: LD_VAR 0 3
15935: PPUSH
15936: LD_INT 80
15938: PPUSH
15939: LD_INT 67
15941: PPUSH
15942: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
15946: LD_VAR 0 3
15950: PPUSH
15951: LD_INT 24
15953: PUSH
15954: LD_INT 1
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PPUSH
15961: CALL_OW 72
15965: NOT
15966: IFFALSE 15912
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
15968: LD_ADDR_VAR 0 3
15972: PUSH
15973: LD_INT 22
15975: PUSH
15976: LD_INT 4
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: PUSH
15983: LD_INT 92
15985: PUSH
15986: LD_INT 60
15988: PUSH
15989: LD_INT 93
15991: PUSH
15992: LD_INT 10
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: PUSH
16001: LD_INT 3
16003: PUSH
16004: LD_INT 54
16006: PUSH
16007: EMPTY
16008: LIST
16009: PUSH
16010: EMPTY
16011: LIST
16012: LIST
16013: PUSH
16014: EMPTY
16015: LIST
16016: LIST
16017: LIST
16018: PPUSH
16019: CALL_OW 69
16023: PUSH
16024: LD_EXP 53
16028: DIFF
16029: ST_TO_ADDR
// if tmp then
16030: LD_VAR 0 3
16034: IFFALSE 16068
// for i in tmp do
16036: LD_ADDR_VAR 0 1
16040: PUSH
16041: LD_VAR 0 3
16045: PUSH
16046: FOR_IN
16047: IFFALSE 16066
// ComMoveXY ( i , 36 , 67 ) ;
16049: LD_VAR 0 1
16053: PPUSH
16054: LD_INT 36
16056: PPUSH
16057: LD_INT 67
16059: PPUSH
16060: CALL_OW 111
16064: GO 16046
16066: POP
16067: POP
// wait ( 0 0$3 ) ;
16068: LD_INT 105
16070: PPUSH
16071: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
16075: LD_VAR 0 11
16079: PPUSH
16080: LD_STRING D6-Sol3-1
16082: PPUSH
16083: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
16087: LD_EXP 53
16091: PPUSH
16092: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
16096: LD_EXP 53
16100: PPUSH
16101: LD_STRING D6-Pow-1
16103: PPUSH
16104: CALL_OW 88
// tmp := [ ] ;
16108: LD_ADDR_VAR 0 3
16112: PUSH
16113: EMPTY
16114: ST_TO_ADDR
// for i = 1 to 2 do
16115: LD_ADDR_VAR 0 1
16119: PUSH
16120: DOUBLE
16121: LD_INT 1
16123: DEC
16124: ST_TO_ADDR
16125: LD_INT 2
16127: PUSH
16128: FOR_TO
16129: IFFALSE 16236
// begin uc_side := 8 ;
16131: LD_ADDR_OWVAR 20
16135: PUSH
16136: LD_INT 8
16138: ST_TO_ADDR
// uc_nation := 2 ;
16139: LD_ADDR_OWVAR 21
16143: PUSH
16144: LD_INT 2
16146: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
16147: LD_INT 14
16149: PPUSH
16150: LD_INT 3
16152: PPUSH
16153: LD_INT 2
16155: PPUSH
16156: LD_INT 29
16158: PPUSH
16159: LD_INT 100
16161: PPUSH
16162: CALL 60476 0 5
// veh := CreateVehicle ;
16166: LD_ADDR_VAR 0 13
16170: PUSH
16171: CALL_OW 45
16175: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16176: LD_VAR 0 13
16180: PPUSH
16181: LD_INT 4
16183: PPUSH
16184: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
16188: LD_VAR 0 13
16192: PPUSH
16193: LD_INT 99
16195: PPUSH
16196: LD_INT 83
16198: PPUSH
16199: LD_INT 5
16201: PPUSH
16202: LD_INT 0
16204: PPUSH
16205: CALL_OW 50
// Connect ( veh ) ;
16209: LD_VAR 0 13
16213: PPUSH
16214: CALL 63531 0 1
// tmp := tmp ^ veh ;
16218: LD_ADDR_VAR 0 3
16222: PUSH
16223: LD_VAR 0 3
16227: PUSH
16228: LD_VAR 0 13
16232: ADD
16233: ST_TO_ADDR
// end ;
16234: GO 16128
16236: POP
16237: POP
// wait ( 0 0$1 ) ;
16238: LD_INT 35
16240: PPUSH
16241: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
16245: LD_INT 99
16247: PPUSH
16248: LD_INT 83
16250: PPUSH
16251: LD_INT 1
16253: PPUSH
16254: LD_INT 10
16256: PPUSH
16257: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
16261: LD_INT 99
16263: PPUSH
16264: LD_INT 83
16266: PPUSH
16267: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
16271: LD_VAR 0 11
16275: PPUSH
16276: LD_STRING D6-Sol3-2
16278: PPUSH
16279: CALL_OW 88
// async ;
16283: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
16284: LD_EXP 53
16288: PPUSH
16289: LD_STRING D6-Pow-2
16291: PPUSH
16292: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
16296: LD_VAR 0 3
16300: PUSH
16301: LD_INT 1
16303: ARRAY
16304: PPUSH
16305: LD_VAR 0 9
16309: PPUSH
16310: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
16314: LD_VAR 0 3
16318: PUSH
16319: LD_INT 2
16321: ARRAY
16322: PPUSH
16323: LD_INT 22
16325: PUSH
16326: LD_INT 4
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: PUSH
16333: LD_INT 21
16335: PUSH
16336: LD_INT 3
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PPUSH
16347: CALL_OW 69
16351: PPUSH
16352: LD_VAR 0 3
16356: PUSH
16357: LD_INT 2
16359: ARRAY
16360: PPUSH
16361: CALL_OW 74
16365: PPUSH
16366: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
16370: LD_EXP 53
16374: PPUSH
16375: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
16379: LD_INT 99
16381: PPUSH
16382: LD_INT 83
16384: PPUSH
16385: LD_INT 1
16387: PPUSH
16388: CALL_OW 331
// repeat wait ( 4 ) ;
16392: LD_INT 4
16394: PPUSH
16395: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
16399: LD_VAR 0 3
16403: PUSH
16404: LD_INT 1
16406: ARRAY
16407: PPUSH
16408: CALL_OW 256
16412: PUSH
16413: LD_INT 1000
16415: LESS
16416: IFFALSE 16434
// SetLives ( tmp [ 1 ] , 1000 ) ;
16418: LD_VAR 0 3
16422: PUSH
16423: LD_INT 1
16425: ARRAY
16426: PPUSH
16427: LD_INT 1000
16429: PPUSH
16430: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
16434: LD_INT 22
16436: PUSH
16437: LD_INT 4
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PUSH
16444: LD_INT 30
16446: PUSH
16447: LD_INT 3
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: PUSH
16454: EMPTY
16455: LIST
16456: LIST
16457: PPUSH
16458: CALL_OW 69
16462: PUSH
16463: LD_INT 0
16465: EQUAL
16466: IFFALSE 16392
// sync ;
16468: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
16469: LD_EXP 53
16473: PPUSH
16474: LD_STRING D6a-Pow-1
16476: PPUSH
16477: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
16481: LD_VAR 0 11
16485: PPUSH
16486: LD_STRING D6a-Sol3-1
16488: PPUSH
16489: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
16493: LD_EXP 53
16497: PPUSH
16498: LD_STRING D6a-Pow-2
16500: PPUSH
16501: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
16505: LD_VAR 0 11
16509: PPUSH
16510: LD_STRING D6a-Sol3-2
16512: PPUSH
16513: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
16517: LD_EXP 53
16521: PPUSH
16522: LD_STRING D6a-Pow-3
16524: PPUSH
16525: CALL_OW 88
// powellCenterCameraMode := true ;
16529: LD_ADDR_EXP 20
16533: PUSH
16534: LD_INT 1
16536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
16537: LD_ADDR_VAR 0 1
16541: PUSH
16542: LD_INT 22
16544: PUSH
16545: LD_INT 8
16547: PUSH
16548: EMPTY
16549: LIST
16550: LIST
16551: PUSH
16552: LD_INT 25
16554: PUSH
16555: LD_INT 2
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: EMPTY
16563: LIST
16564: LIST
16565: PPUSH
16566: CALL_OW 69
16570: PUSH
16571: FOR_IN
16572: IFFALSE 16627
// begin SetTag ( i , 1 ) ;
16574: LD_VAR 0 1
16578: PPUSH
16579: LD_INT 1
16581: PPUSH
16582: CALL_OW 109
// ComExitBuilding ( i ) ;
16586: LD_VAR 0 1
16590: PPUSH
16591: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
16595: LD_VAR 0 1
16599: PPUSH
16600: LD_INT 35
16602: PPUSH
16603: LD_INT 6
16605: PPUSH
16606: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
16610: LD_VAR 0 1
16614: PPUSH
16615: LD_INT 53
16617: PPUSH
16618: LD_INT 4
16620: PPUSH
16621: CALL_OW 171
// end ;
16625: GO 16571
16627: POP
16628: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
16629: LD_ADDR_VAR 0 3
16633: PUSH
16634: LD_INT 22
16636: PUSH
16637: LD_INT 4
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: PUSH
16644: LD_INT 21
16646: PUSH
16647: LD_INT 2
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PUSH
16654: LD_INT 3
16656: PUSH
16657: LD_INT 34
16659: PUSH
16660: LD_INT 12
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: PUSH
16667: EMPTY
16668: LIST
16669: LIST
16670: PUSH
16671: EMPTY
16672: LIST
16673: LIST
16674: LIST
16675: PPUSH
16676: CALL_OW 69
16680: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
16681: LD_EXP 53
16685: PPUSH
16686: LD_VAR 0 3
16690: PPUSH
16691: LD_EXP 53
16695: PPUSH
16696: CALL_OW 74
16700: PPUSH
16701: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
16705: LD_EXP 53
16709: PPUSH
16710: LD_INT 100
16712: PPUSH
16713: LD_INT 88
16715: PPUSH
16716: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
16720: LD_EXP 53
16724: PPUSH
16725: LD_INT 100
16727: PPUSH
16728: LD_INT 75
16730: PPUSH
16731: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
16735: LD_EXP 53
16739: PPUSH
16740: LD_INT 88
16742: PPUSH
16743: LD_INT 53
16745: PPUSH
16746: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
16750: LD_INT 8
16752: PPUSH
16753: LD_EXP 53
16757: PPUSH
16758: CALL_OW 471
// repeat wait ( 3 ) ;
16762: LD_INT 3
16764: PPUSH
16765: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
16769: LD_INT 22
16771: PUSH
16772: LD_INT 4
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: PUSH
16779: LD_INT 92
16781: PUSH
16782: LD_INT 100
16784: PUSH
16785: LD_INT 75
16787: PUSH
16788: LD_INT 6
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: IFFALSE 16762
// async ;
16807: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
16808: LD_EXP 53
16812: PPUSH
16813: LD_STRING D6b-Pow-1
16815: PPUSH
16816: CALL_OW 88
// repeat wait ( 3 ) ;
16820: LD_INT 3
16822: PPUSH
16823: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
16827: LD_EXP 53
16831: PPUSH
16832: CALL_OW 310
16836: PPUSH
16837: CALL_OW 256
16841: PUSH
16842: LD_INT 1000
16844: LESS
16845: IFFALSE 16864
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
16847: LD_EXP 53
16851: PPUSH
16852: CALL_OW 310
16856: PPUSH
16857: LD_INT 1000
16859: PPUSH
16860: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
16864: LD_EXP 53
16868: PPUSH
16869: CALL_OW 256
16873: PUSH
16874: LD_INT 1000
16876: LESS
16877: IFFALSE 16891
// SetLives ( Powell , 1000 ) ;
16879: LD_EXP 53
16883: PPUSH
16884: LD_INT 1000
16886: PPUSH
16887: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
16891: LD_EXP 53
16895: PPUSH
16896: LD_EXP 58
16900: PPUSH
16901: CALL_OW 296
16905: PUSH
16906: LD_INT 5
16908: LESS
16909: PUSH
16910: LD_EXP 53
16914: PPUSH
16915: CALL_OW 310
16919: PPUSH
16920: LD_EXP 58
16924: PPUSH
16925: CALL_OW 296
16929: PUSH
16930: LD_INT 5
16932: LESS
16933: OR
16934: IFFALSE 16953
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
16936: LD_EXP 53
16940: PPUSH
16941: CALL_OW 310
16945: PPUSH
16946: LD_INT 100
16948: PPUSH
16949: CALL_OW 234
// until not IsInUnit ( Powell ) ;
16953: LD_EXP 53
16957: PPUSH
16958: CALL_OW 310
16962: NOT
16963: IFFALSE 16820
// game_speed := 4 ;
16965: LD_ADDR_OWVAR 65
16969: PUSH
16970: LD_INT 4
16972: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
16973: LD_EXP 53
16977: PPUSH
16978: LD_STRING D6b-Pow-1a
16980: PPUSH
16981: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
16985: LD_EXP 53
16989: PPUSH
16990: LD_EXP 58
16994: PPUSH
16995: CALL_OW 180
// sync ;
16999: SYNC
// repeat wait ( 0 0$1 ) ;
17000: LD_INT 35
17002: PPUSH
17003: CALL_OW 67
// until IsInUnit ( Powell ) ;
17007: LD_EXP 53
17011: PPUSH
17012: CALL_OW 310
17016: IFFALSE 17000
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
17018: LD_INT 8
17020: PPUSH
17021: LD_EXP 53
17025: PPUSH
17026: CALL_OW 310
17030: PPUSH
17031: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
17035: LD_EXP 53
17039: PPUSH
17040: LD_INT 91
17042: PPUSH
17043: LD_INT 44
17045: PPUSH
17046: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
17050: LD_EXP 53
17054: PPUSH
17055: LD_INT 96
17057: PPUSH
17058: LD_INT 44
17060: PPUSH
17061: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
17065: LD_EXP 53
17069: PPUSH
17070: LD_INT 96
17072: PPUSH
17073: LD_INT 41
17075: PPUSH
17076: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
17080: LD_EXP 53
17084: PPUSH
17085: LD_INT 92
17087: PPUSH
17088: LD_INT 39
17090: PPUSH
17091: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
17095: LD_EXP 53
17099: PPUSH
17100: LD_INT 88
17102: PPUSH
17103: LD_INT 41
17105: PPUSH
17106: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
17110: LD_EXP 53
17114: PPUSH
17115: LD_INT 91
17117: PPUSH
17118: LD_INT 44
17120: PPUSH
17121: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
17125: LD_EXP 53
17129: PPUSH
17130: LD_INT 96
17132: PPUSH
17133: LD_INT 44
17135: PPUSH
17136: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
17140: LD_EXP 53
17144: PPUSH
17145: LD_INT 96
17147: PPUSH
17148: LD_INT 41
17150: PPUSH
17151: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
17155: LD_EXP 53
17159: PPUSH
17160: LD_INT 92
17162: PPUSH
17163: LD_INT 39
17165: PPUSH
17166: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
17170: LD_EXP 53
17174: PPUSH
17175: LD_INT 88
17177: PPUSH
17178: LD_INT 41
17180: PPUSH
17181: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
17185: LD_EXP 53
17189: PPUSH
17190: LD_INT 91
17192: PPUSH
17193: LD_INT 44
17195: PPUSH
17196: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
17200: LD_EXP 53
17204: PPUSH
17205: LD_INT 93
17207: PPUSH
17208: LD_INT 39
17210: PPUSH
17211: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
17215: LD_EXP 53
17219: PPUSH
17220: LD_INT 93
17222: PPUSH
17223: LD_INT 36
17225: PPUSH
17226: CALL_OW 171
// wait ( 0 0$3.5 ) ;
17230: LD_INT 122
17232: PPUSH
17233: CALL_OW 67
// game_speed := 4 ;
17237: LD_ADDR_OWVAR 65
17241: PUSH
17242: LD_INT 4
17244: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
17245: LD_EXP 53
17249: PPUSH
17250: LD_STRING D6b-Pow-1b
17252: PPUSH
17253: CALL_OW 88
// tmp := [ ] ;
17257: LD_ADDR_VAR 0 3
17261: PUSH
17262: EMPTY
17263: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
17264: LD_ADDR_VAR 0 5
17268: PUSH
17269: LD_INT 78
17271: PUSH
17272: LD_INT 47
17274: PUSH
17275: EMPTY
17276: LIST
17277: LIST
17278: PUSH
17279: LD_INT 106
17281: PUSH
17282: LD_INT 53
17284: PUSH
17285: EMPTY
17286: LIST
17287: LIST
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
17293: LD_ADDR_VAR 0 1
17297: PUSH
17298: LD_INT 22
17300: PUSH
17301: LD_INT 8
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PUSH
17308: LD_INT 21
17310: PUSH
17311: LD_INT 3
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: PUSH
17318: LD_INT 92
17320: PUSH
17321: LD_INT 90
17323: PUSH
17324: LD_INT 52
17326: PUSH
17327: LD_INT 12
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: LIST
17334: LIST
17335: PUSH
17336: EMPTY
17337: LIST
17338: LIST
17339: LIST
17340: PPUSH
17341: CALL_OW 69
17345: PUSH
17346: FOR_IN
17347: IFFALSE 17372
// tmp := tmp ^ UnitsInside ( i ) ;
17349: LD_ADDR_VAR 0 3
17353: PUSH
17354: LD_VAR 0 3
17358: PUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: CALL_OW 313
17368: ADD
17369: ST_TO_ADDR
17370: GO 17346
17372: POP
17373: POP
// for i in tmp do
17374: LD_ADDR_VAR 0 1
17378: PUSH
17379: LD_VAR 0 3
17383: PUSH
17384: FOR_IN
17385: IFFALSE 17547
// begin dist := 9999 ;
17387: LD_ADDR_VAR 0 8
17391: PUSH
17392: LD_INT 9999
17394: ST_TO_ADDR
// _xy := [ ] ;
17395: LD_ADDR_VAR 0 7
17399: PUSH
17400: EMPTY
17401: ST_TO_ADDR
// SetTag ( i , 1 ) ;
17402: LD_VAR 0 1
17406: PPUSH
17407: LD_INT 1
17409: PPUSH
17410: CALL_OW 109
// ComExitBuilding ( i ) ;
17414: LD_VAR 0 1
17418: PPUSH
17419: CALL_OW 122
// for j in xy do
17423: LD_ADDR_VAR 0 2
17427: PUSH
17428: LD_VAR 0 5
17432: PUSH
17433: FOR_IN
17434: IFFALSE 17516
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
17436: LD_VAR 0 1
17440: PPUSH
17441: LD_VAR 0 2
17445: PUSH
17446: LD_INT 1
17448: ARRAY
17449: PPUSH
17450: LD_VAR 0 2
17454: PUSH
17455: LD_INT 2
17457: ARRAY
17458: PPUSH
17459: CALL_OW 297
17463: PUSH
17464: LD_VAR 0 8
17468: LESS
17469: IFFALSE 17514
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
17471: LD_ADDR_VAR 0 8
17475: PUSH
17476: LD_VAR 0 1
17480: PPUSH
17481: LD_VAR 0 2
17485: PUSH
17486: LD_INT 1
17488: ARRAY
17489: PPUSH
17490: LD_VAR 0 2
17494: PUSH
17495: LD_INT 2
17497: ARRAY
17498: PPUSH
17499: CALL_OW 297
17503: ST_TO_ADDR
// _xy := j ;
17504: LD_ADDR_VAR 0 7
17508: PUSH
17509: LD_VAR 0 2
17513: ST_TO_ADDR
// end ;
17514: GO 17433
17516: POP
17517: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
17518: LD_VAR 0 1
17522: PPUSH
17523: LD_VAR 0 7
17527: PUSH
17528: LD_INT 1
17530: ARRAY
17531: PPUSH
17532: LD_VAR 0 7
17536: PUSH
17537: LD_INT 2
17539: ARRAY
17540: PPUSH
17541: CALL_OW 171
// end ;
17545: GO 17384
17547: POP
17548: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
17549: LD_ADDR_VAR 0 4
17553: PUSH
17554: LD_VAR 0 3
17558: PPUSH
17559: LD_INT 26
17561: PUSH
17562: LD_INT 1
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: PUSH
17569: LD_INT 25
17571: PUSH
17572: LD_INT 1
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PPUSH
17583: CALL_OW 72
17587: ST_TO_ADDR
// if tmp2 < 2 then
17588: LD_VAR 0 4
17592: PUSH
17593: LD_INT 2
17595: LESS
17596: IFFALSE 17665
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
17598: LD_ADDR_VAR 0 4
17602: PUSH
17603: LD_INT 22
17605: PUSH
17606: LD_INT 8
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: PUSH
17613: LD_INT 26
17615: PUSH
17616: LD_INT 1
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: PUSH
17623: LD_INT 3
17625: PUSH
17626: LD_INT 25
17628: PUSH
17629: LD_INT 15
17631: PUSH
17632: EMPTY
17633: LIST
17634: LIST
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: PUSH
17650: LD_EXP 55
17654: PUSH
17655: LD_EXP 56
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: DIFF
17664: ST_TO_ADDR
// if tmp2 then
17665: LD_VAR 0 4
17669: IFFALSE 17687
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
17671: LD_VAR 0 4
17675: PUSH
17676: LD_INT 1
17678: ARRAY
17679: PPUSH
17680: LD_STRING D6b-ArSol1-1
17682: PPUSH
17683: CALL_OW 88
// async ;
17687: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
17688: LD_EXP 53
17692: PPUSH
17693: LD_STRING D6b-Pow-2
17695: PPUSH
17696: CALL_OW 88
// if tmp2 > 1 then
17700: LD_VAR 0 4
17704: PUSH
17705: LD_INT 1
17707: GREATER
17708: IFFALSE 17726
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
17710: LD_VAR 0 4
17714: PUSH
17715: LD_INT 2
17717: ARRAY
17718: PPUSH
17719: LD_STRING D6b-ArSol2-1
17721: PPUSH
17722: CALL_OW 88
// sync ;
17726: SYNC
// repeat wait ( 5 ) ;
17727: LD_INT 5
17729: PPUSH
17730: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
17734: LD_INT 93
17736: PPUSH
17737: LD_INT 36
17739: PPUSH
17740: CALL_OW 428
17744: PPUSH
17745: CALL_OW 255
17749: PUSH
17750: LD_INT 4
17752: EQUAL
17753: IFFALSE 17727
// DialogueOn ;
17755: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
17759: LD_INT 10
17761: PPUSH
17762: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
17766: LD_EXP 53
17770: PPUSH
17771: LD_STRING D6b-Pow-2a
17773: PPUSH
17774: CALL_OW 88
// DialogueOff ;
17778: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
17782: LD_EXP 53
17786: PPUSH
17787: CALL_OW 310
17791: PPUSH
17792: LD_INT 332
17794: PPUSH
17795: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
17799: LD_INT 93
17801: PPUSH
17802: LD_INT 35
17804: PPUSH
17805: LD_INT 1
17807: PPUSH
17808: LD_INT 6
17810: NEG
17811: PPUSH
17812: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
17816: LD_INT 35
17818: PPUSH
17819: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
17823: LD_INT 332
17825: PPUSH
17826: CALL_OW 256
17830: PUSH
17831: LD_INT 1000
17833: LESS
17834: PUSH
17835: LD_INT 332
17837: PPUSH
17838: CALL_OW 300
17842: AND
17843: IFFALSE 17855
// SetLives ( kozlov_fac , 0 ) ;
17845: LD_INT 332
17847: PPUSH
17848: LD_INT 0
17850: PPUSH
17851: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
17855: LD_INT 332
17857: PPUSH
17858: CALL_OW 301
17862: PUSH
17863: LD_EXP 53
17867: PPUSH
17868: CALL_OW 301
17872: OR
17873: IFFALSE 17816
// game_speed := 4 ;
17875: LD_ADDR_OWVAR 65
17879: PUSH
17880: LD_INT 4
17882: ST_TO_ADDR
// powellCenterCameraMode := false ;
17883: LD_ADDR_EXP 20
17887: PUSH
17888: LD_INT 0
17890: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
17891: LD_ADDR_VAR 0 1
17895: PUSH
17896: LD_VAR 0 3
17900: PUSH
17901: LD_INT 22
17903: PUSH
17904: LD_INT 8
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: PUSH
17911: LD_INT 25
17913: PUSH
17914: LD_INT 2
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PUSH
17921: EMPTY
17922: LIST
17923: LIST
17924: PPUSH
17925: CALL_OW 69
17929: UNION
17930: PUSH
17931: FOR_IN
17932: IFFALSE 17948
// SetTag ( i , 0 ) ;
17934: LD_VAR 0 1
17938: PPUSH
17939: LD_INT 0
17941: PPUSH
17942: CALL_OW 109
17946: GO 17931
17948: POP
17949: POP
// wait ( 0 0$3 ) ;
17950: LD_INT 105
17952: PPUSH
17953: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
17957: LD_INT 93
17959: PPUSH
17960: LD_INT 35
17962: PPUSH
17963: LD_INT 1
17965: PPUSH
17966: CALL_OW 331
// DialogueOn ;
17970: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
17974: LD_VAR 0 11
17978: PPUSH
17979: LD_STRING D6c-Sol3-1
17981: PPUSH
17982: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
17986: LD_INT 10
17988: PPUSH
17989: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
17993: LD_EXP 34
17997: PPUSH
17998: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
18002: LD_EXP 34
18006: PPUSH
18007: LD_STRING D6c-JMM-1
18009: PPUSH
18010: CALL_OW 88
// if Cyrus then
18014: LD_EXP 40
18018: IFFALSE 18032
// Say ( Cyrus , D6c-Cyrus-1 ) ;
18020: LD_EXP 40
18024: PPUSH
18025: LD_STRING D6c-Cyrus-1
18027: PPUSH
18028: CALL_OW 88
// if Bobby then
18032: LD_EXP 39
18036: IFFALSE 18050
// Say ( Bobby , D6c-Bobby-1 ) ;
18038: LD_EXP 39
18042: PPUSH
18043: LD_STRING D6c-Bobby-1
18045: PPUSH
18046: CALL_OW 88
// if Cornel then
18050: LD_EXP 45
18054: IFFALSE 18068
// Say ( Cornel , D6c-Corn-1 ) ;
18056: LD_EXP 45
18060: PPUSH
18061: LD_STRING D6c-Corn-1
18063: PPUSH
18064: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
18068: LD_ADDR_VAR 0 4
18072: PUSH
18073: LD_INT 2
18075: PUSH
18076: LD_INT 22
18078: PUSH
18079: LD_INT 1
18081: PUSH
18082: EMPTY
18083: LIST
18084: LIST
18085: PUSH
18086: LD_INT 22
18088: PUSH
18089: LD_INT 4
18091: PUSH
18092: EMPTY
18093: LIST
18094: LIST
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: PUSH
18101: LD_INT 26
18103: PUSH
18104: LD_INT 1
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 25
18116: PUSH
18117: LD_INT 16
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: PUSH
18124: LD_INT 25
18126: PUSH
18127: LD_INT 12
18129: PUSH
18130: EMPTY
18131: LIST
18132: LIST
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: PPUSH
18144: CALL_OW 69
18148: PUSH
18149: LD_VAR 0 11
18153: PUSH
18154: LD_EXP 34
18158: UNION
18159: PUSH
18160: LD_EXP 54
18164: UNION
18165: PUSH
18166: EMPTY
18167: LIST
18168: DIFF
18169: ST_TO_ADDR
// if tmp2 then
18170: LD_VAR 0 4
18174: IFFALSE 18192
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
18176: LD_VAR 0 4
18180: PUSH
18181: LD_INT 1
18183: ARRAY
18184: PPUSH
18185: LD_STRING D6c-Sol1-1
18187: PPUSH
18188: CALL_OW 88
// if Lisa then
18192: LD_EXP 37
18196: IFFALSE 18210
// Say ( Lisa , D6c-Lisa-1 ) ;
18198: LD_EXP 37
18202: PPUSH
18203: LD_STRING D6c-Lisa-1
18205: PPUSH
18206: CALL_OW 88
// if Gary then
18210: LD_EXP 46
18214: IFFALSE 18228
// Say ( Gary , D6c-Gary-1 ) ;
18216: LD_EXP 46
18220: PPUSH
18221: LD_STRING D6c-Gary-1
18223: PPUSH
18224: CALL_OW 88
// if Donaldson then
18228: LD_EXP 38
18232: IFFALSE 18246
// Say ( Donaldson , D6c-Don-1 ) ;
18234: LD_EXP 38
18238: PPUSH
18239: LD_STRING D6c-Don-1
18241: PPUSH
18242: CALL_OW 88
// if tmp2 > 1 then
18246: LD_VAR 0 4
18250: PUSH
18251: LD_INT 1
18253: GREATER
18254: IFFALSE 18272
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
18256: LD_VAR 0 4
18260: PUSH
18261: LD_INT 2
18263: ARRAY
18264: PPUSH
18265: LD_STRING D6c-Sol2-1
18267: PPUSH
18268: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
18272: LD_VAR 0 11
18276: PPUSH
18277: LD_STRING D6c-Sol3-2
18279: PPUSH
18280: CALL_OW 88
// dwait ( 0 0$1 ) ;
18284: LD_INT 35
18286: PPUSH
18287: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
18291: LD_EXP 34
18295: PPUSH
18296: LD_STRING D6c-JMM-2
18298: PPUSH
18299: CALL_OW 88
// DialogueOff ;
18303: CALL_OW 7
// Video ( false ) ;
18307: LD_INT 0
18309: PPUSH
18310: CALL 96131 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
18314: LD_INT 22
18316: PUSH
18317: LD_INT 4
18319: PUSH
18320: EMPTY
18321: LIST
18322: LIST
18323: PPUSH
18324: CALL_OW 69
18328: PPUSH
18329: LD_INT 1
18331: PPUSH
18332: CALL_OW 235
// for i in GetTechNation ( 4 , 1 , 2 ) do
18336: LD_ADDR_VAR 0 1
18340: PUSH
18341: LD_INT 4
18343: PPUSH
18344: LD_INT 1
18346: PPUSH
18347: LD_INT 2
18349: PPUSH
18350: CALL 53906 0 3
18354: PUSH
18355: FOR_IN
18356: IFFALSE 18393
// if GetTech ( i , 1 ) <> state_researched then
18358: LD_VAR 0 1
18362: PPUSH
18363: LD_INT 1
18365: PPUSH
18366: CALL_OW 321
18370: PUSH
18371: LD_INT 2
18373: NONEQUAL
18374: IFFALSE 18391
// SetTech ( i , 1 , state_researched ) ;
18376: LD_VAR 0 1
18380: PPUSH
18381: LD_INT 1
18383: PPUSH
18384: LD_INT 2
18386: PPUSH
18387: CALL_OW 322
18391: GO 18355
18393: POP
18394: POP
// missionStage := 6 ;
18395: LD_ADDR_EXP 15
18399: PUSH
18400: LD_INT 6
18402: ST_TO_ADDR
// activeAttacks := true ;
18403: LD_ADDR_EXP 16
18407: PUSH
18408: LD_INT 1
18410: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
18411: LD_STRING M2
18413: PPUSH
18414: CALL_OW 337
// SaveForQuickRestart ;
18418: CALL_OW 22
// wait ( 0 0$40 ) ;
18422: LD_INT 1400
18424: PPUSH
18425: CALL_OW 67
// DialogueOn ;
18429: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
18433: LD_EXP 57
18437: PPUSH
18438: LD_STRING D7-Friend-1
18440: PPUSH
18441: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
18445: LD_EXP 34
18449: PPUSH
18450: LD_STRING D7-JMM-1
18452: PPUSH
18453: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
18457: LD_EXP 57
18461: PPUSH
18462: LD_STRING D7-Friend-2
18464: PPUSH
18465: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
18469: LD_EXP 34
18473: PPUSH
18474: LD_STRING D7-JMM-2
18476: PPUSH
18477: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
18481: LD_EXP 57
18485: PPUSH
18486: LD_STRING D7-Friend-3
18488: PPUSH
18489: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
18493: LD_EXP 34
18497: PPUSH
18498: LD_STRING D7-JMM-3
18500: PPUSH
18501: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
18505: LD_EXP 57
18509: PPUSH
18510: LD_STRING D7-Friend-4
18512: PPUSH
18513: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
18517: LD_EXP 34
18521: PPUSH
18522: LD_STRING D7-JMM-4
18524: PPUSH
18525: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
18529: LD_EXP 57
18533: PPUSH
18534: LD_STRING D7-Friend-5
18536: PPUSH
18537: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
18541: LD_EXP 34
18545: PPUSH
18546: LD_STRING D7-JMM-5
18548: PPUSH
18549: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
18553: LD_EXP 57
18557: PPUSH
18558: LD_STRING D7-Friend-6
18560: PPUSH
18561: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
18565: LD_EXP 34
18569: PPUSH
18570: LD_STRING D7-JMM-6
18572: PPUSH
18573: CALL_OW 88
// DialogueOff ;
18577: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
18581: LD_STRING Mlegion
18583: PPUSH
18584: CALL_OW 337
// RebuildKozlovFactory ;
18588: CALL 4318 0 0
// end ;
18592: PPOPN 13
18594: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
18595: LD_EXP 20
18599: PUSH
18600: LD_EXP 53
18604: PPUSH
18605: CALL_OW 300
18609: AND
18610: IFFALSE 18652
18612: GO 18614
18614: DISABLE
// begin enable ;
18615: ENABLE
// if IsInUnit ( Powell ) then
18616: LD_EXP 53
18620: PPUSH
18621: CALL_OW 310
18625: IFFALSE 18643
// CenterOnUnits ( IsInUnit ( Powell ) ) else
18627: LD_EXP 53
18631: PPUSH
18632: CALL_OW 310
18636: PPUSH
18637: CALL_OW 85
18641: GO 18652
// CenterOnUnits ( Powell ) ;
18643: LD_EXP 53
18647: PPUSH
18648: CALL_OW 85
// end ;
18652: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
18653: LD_INT 22
18655: PUSH
18656: LD_INT 8
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: LD_INT 34
18665: PUSH
18666: LD_INT 48
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PPUSH
18677: CALL_OW 69
18681: IFFALSE 18944
18683: GO 18685
18685: DISABLE
18686: LD_INT 0
18688: PPUSH
18689: PPUSH
// begin if missionStage < 9 then
18690: LD_EXP 15
18694: PUSH
18695: LD_INT 9
18697: LESS
18698: IFFALSE 18708
// missionStage := 9 ;
18700: LD_ADDR_EXP 15
18704: PUSH
18705: LD_INT 9
18707: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
18708: LD_ADDR_VAR 0 1
18712: PUSH
18713: LD_INT 22
18715: PUSH
18716: LD_INT 8
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 34
18725: PUSH
18726: LD_INT 48
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: PPUSH
18737: CALL_OW 69
18741: PUSH
18742: LD_INT 1
18744: ARRAY
18745: ST_TO_ADDR
// wait ( 0 0$05 ) ;
18746: LD_INT 175
18748: PPUSH
18749: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
18753: LD_EXP 12
18757: PUSH
18758: LD_EXP 3
18762: PUSH
18763: LD_INT 0
18765: PUSH
18766: LD_INT 2
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: IN
18773: OR
18774: IFFALSE 18797
// target := [ 68 , 108 , 1 ] else
18776: LD_ADDR_VAR 0 2
18780: PUSH
18781: LD_INT 68
18783: PUSH
18784: LD_INT 108
18786: PUSH
18787: LD_INT 1
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: ST_TO_ADDR
18795: GO 18816
// target := [ 181 , 88 , 2 ] ;
18797: LD_ADDR_VAR 0 2
18801: PUSH
18802: LD_INT 181
18804: PUSH
18805: LD_INT 88
18807: PUSH
18808: LD_INT 2
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: LIST
18815: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
18816: LD_VAR 0 1
18820: PPUSH
18821: LD_VAR 0 2
18825: PUSH
18826: LD_INT 1
18828: ARRAY
18829: PPUSH
18830: LD_VAR 0 2
18834: PUSH
18835: LD_INT 2
18837: ARRAY
18838: PPUSH
18839: CALL_OW 176
// if target [ 3 ] = 1 then
18843: LD_VAR 0 2
18847: PUSH
18848: LD_INT 3
18850: ARRAY
18851: PUSH
18852: LD_INT 1
18854: EQUAL
18855: IFFALSE 18871
// SayRadio ( Kurt , D12-Kurt-1 ) else
18857: LD_EXP 55
18861: PPUSH
18862: LD_STRING D12-Kurt-1
18864: PPUSH
18865: CALL_OW 94
18869: GO 18895
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
18871: LD_EXP 55
18875: PPUSH
18876: LD_STRING D12a-Kurt-1
18878: PPUSH
18879: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
18883: LD_EXP 69
18887: PPUSH
18888: LD_STRING D12a-Roth-1
18890: PPUSH
18891: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
18895: LD_INT 350
18897: PPUSH
18898: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
18902: LD_VAR 0 1
18906: PPUSH
18907: LD_INT 22
18909: PUSH
18910: LD_INT 8
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 30
18919: PUSH
18920: LD_INT 3
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PPUSH
18931: CALL_OW 69
18935: PUSH
18936: LD_INT 1
18938: ARRAY
18939: PPUSH
18940: CALL_OW 228
// end ;
18944: PPOPN 2
18946: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
18947: LD_INT 22
18949: PUSH
18950: LD_INT 8
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: PUSH
18957: LD_INT 21
18959: PUSH
18960: LD_INT 1
18962: PUSH
18963: EMPTY
18964: LIST
18965: LIST
18966: PUSH
18967: LD_INT 23
18969: PUSH
18970: LD_INT 2
18972: PUSH
18973: EMPTY
18974: LIST
18975: LIST
18976: PUSH
18977: EMPTY
18978: LIST
18979: LIST
18980: LIST
18981: PPUSH
18982: CALL_OW 69
18986: PUSH
18987: LD_INT 8
18989: PUSH
18990: LD_INT 7
18992: PUSH
18993: LD_INT 6
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: LIST
19000: PUSH
19001: LD_OWVAR 67
19005: ARRAY
19006: LESSEQUAL
19007: PUSH
19008: LD_INT 22
19010: PUSH
19011: LD_INT 8
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: LD_INT 34
19020: PUSH
19021: LD_INT 48
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: EMPTY
19029: LIST
19030: LIST
19031: PPUSH
19032: CALL_OW 69
19036: NOT
19037: AND
19038: PUSH
19039: LD_EXP 55
19043: PPUSH
19044: CALL_OW 302
19048: AND
19049: IFFALSE 19366
19051: GO 19053
19053: DISABLE
// begin DialogueOn ;
19054: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
19058: LD_EXP 34
19062: PPUSH
19063: LD_STRING D13-JMM-1
19065: PPUSH
19066: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
19070: LD_EXP 55
19074: PPUSH
19075: LD_STRING D13-Kurt-1
19077: PPUSH
19078: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
19082: LD_EXP 34
19086: PPUSH
19087: LD_STRING D13-JMM-2
19089: PPUSH
19090: CALL_OW 88
// if FakeInfo then
19094: LD_EXP 12
19098: IFFALSE 19118
// begin Say ( Kurt , D13-Kurt-2 ) ;
19100: LD_EXP 55
19104: PPUSH
19105: LD_STRING D13-Kurt-2
19107: PPUSH
19108: CALL_OW 88
// DialogueOff ;
19112: CALL_OW 7
// exit ;
19116: GO 19366
// end ; if not KurtStatus then
19118: LD_EXP 3
19122: NOT
19123: IFFALSE 19139
// Say ( Kurt , D13-Kurt-2b ) else
19125: LD_EXP 55
19129: PPUSH
19130: LD_STRING D13-Kurt-2b
19132: PPUSH
19133: CALL_OW 88
19137: GO 19151
// Say ( Kurt , D13-Kurt-2a ) ;
19139: LD_EXP 55
19143: PPUSH
19144: LD_STRING D13-Kurt-2a
19146: PPUSH
19147: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
19151: LD_EXP 55
19155: PPUSH
19156: LD_STRING D13-Kurt-2a
19158: PPUSH
19159: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
19163: LD_EXP 34
19167: PPUSH
19168: LD_STRING D13-JMM-3
19170: PPUSH
19171: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
19175: LD_EXP 55
19179: PPUSH
19180: LD_STRING D13-Kurt-3
19182: PPUSH
19183: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
19187: LD_EXP 34
19191: PPUSH
19192: LD_STRING D13-JMM-4
19194: PPUSH
19195: CALL_OW 88
// DialogueOff ;
19199: CALL_OW 7
// MC_Kill ( 3 ) ;
19203: LD_INT 3
19205: PPUSH
19206: CALL 26192 0 1
// KillUnit ( Kozlov ) ;
19210: LD_EXP 56
19214: PPUSH
19215: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
19219: LD_INT 22
19221: PUSH
19222: LD_INT 8
19224: PUSH
19225: EMPTY
19226: LIST
19227: LIST
19228: PUSH
19229: LD_INT 21
19231: PUSH
19232: LD_INT 3
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: PUSH
19239: LD_INT 23
19241: PUSH
19242: LD_INT 3
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: PUSH
19249: LD_INT 30
19251: PUSH
19252: LD_INT 3
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: LIST
19263: LIST
19264: PPUSH
19265: CALL_OW 69
19269: PUSH
19270: LD_INT 1
19272: ARRAY
19273: PPUSH
19274: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
19278: LD_INT 8
19280: PPUSH
19281: LD_INT 1
19283: PPUSH
19284: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
19288: LD_INT 22
19290: PUSH
19291: LD_INT 8
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: PPUSH
19298: CALL_OW 69
19302: PPUSH
19303: LD_INT 1
19305: PPUSH
19306: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
19310: LD_INT 8
19312: PPUSH
19313: LD_INT 1
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: LD_INT 1
19321: PPUSH
19322: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
19326: LD_EXP 57
19330: PPUSH
19331: LD_INT 37
19333: PPUSH
19334: LD_INT 1
19336: PPUSH
19337: LD_INT 0
19339: PPUSH
19340: CALL_OW 48
// wait ( 0 0$1 ) ;
19344: LD_INT 35
19346: PPUSH
19347: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
19351: LD_EXP 57
19355: PPUSH
19356: LD_INT 60
19358: PPUSH
19359: LD_INT 95
19361: PPUSH
19362: CALL_OW 111
// end ;
19366: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
19367: LD_INT 22
19369: PUSH
19370: LD_INT 8
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: PUSH
19377: LD_INT 21
19379: PUSH
19380: LD_INT 1
19382: PUSH
19383: EMPTY
19384: LIST
19385: LIST
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: PPUSH
19391: CALL_OW 69
19395: PUSH
19396: LD_INT 0
19398: EQUAL
19399: IFFALSE 19419
19401: GO 19403
19403: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
19404: LD_STRING MlegionOut
19406: PPUSH
19407: CALL_OW 337
// legionDestroyed := true ;
19411: LD_ADDR_EXP 22
19415: PUSH
19416: LD_INT 1
19418: ST_TO_ADDR
// end ;
19419: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
19420: LD_INT 1
19422: PPUSH
19423: LD_EXP 57
19427: PPUSH
19428: CALL_OW 292
19432: IFFALSE 19732
19434: GO 19436
19436: DISABLE
19437: LD_INT 0
19439: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
19440: LD_EXP 57
19444: PPUSH
19445: CALL_OW 87
// DialogueOn ;
19449: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
19453: LD_EXP 34
19457: PPUSH
19458: LD_STRING D14-JMM-1
19460: PPUSH
19461: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
19465: LD_EXP 57
19469: PPUSH
19470: LD_STRING D14-Friend-1
19472: PPUSH
19473: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
19477: LD_EXP 34
19481: PPUSH
19482: LD_STRING D14-JMM-2
19484: PPUSH
19485: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
19489: LD_EXP 57
19493: PPUSH
19494: LD_STRING D14-Friend-2
19496: PPUSH
19497: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
19501: LD_EXP 34
19505: PPUSH
19506: LD_STRING D14-JMM-3
19508: PPUSH
19509: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
19513: LD_EXP 57
19517: PPUSH
19518: LD_STRING D14-Friend-3
19520: PPUSH
19521: CALL_OW 88
// DialogueOff ;
19525: CALL_OW 7
// dec = Query ( Q14 ) ;
19529: LD_ADDR_VAR 0 1
19533: PUSH
19534: LD_STRING Q14
19536: PPUSH
19537: CALL_OW 97
19541: ST_TO_ADDR
// if dec = 1 then
19542: LD_VAR 0 1
19546: PUSH
19547: LD_INT 1
19549: EQUAL
19550: IFFALSE 19584
// begin DialogueOn ;
19552: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
19556: LD_EXP 34
19560: PPUSH
19561: LD_STRING D14a-JMM-1
19563: PPUSH
19564: CALL_OW 88
// DialogueOff ;
19568: CALL_OW 7
// SetSide ( Friend , 1 ) ;
19572: LD_EXP 57
19576: PPUSH
19577: LD_INT 1
19579: PPUSH
19580: CALL_OW 235
// end ; if dec = 2 then
19584: LD_VAR 0 1
19588: PUSH
19589: LD_INT 2
19591: EQUAL
19592: IFFALSE 19638
// begin DialogueOn ;
19594: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
19598: LD_EXP 34
19602: PPUSH
19603: LD_STRING D14b-JMM-1
19605: PPUSH
19606: CALL_OW 88
// DialogueOff ;
19610: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
19614: LD_EXP 57
19618: PPUSH
19619: LD_INT 9
19621: PPUSH
19622: LD_INT 2
19624: PPUSH
19625: CALL_OW 111
// AddComHold ( Friend ) ;
19629: LD_EXP 57
19633: PPUSH
19634: CALL_OW 200
// end ; if dec = 3 then
19638: LD_VAR 0 1
19642: PUSH
19643: LD_INT 3
19645: EQUAL
19646: IFFALSE 19732
// begin DialogueOn ;
19648: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
19652: LD_EXP 34
19656: PPUSH
19657: LD_STRING D14c-JMM-1
19659: PPUSH
19660: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
19664: LD_EXP 57
19668: PPUSH
19669: LD_STRING D14c-Friend-1
19671: PPUSH
19672: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
19676: LD_EXP 34
19680: PPUSH
19681: LD_STRING D14c-JMM-2
19683: PPUSH
19684: CALL_OW 88
// DialogueOff ;
19688: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
19692: LD_INT 8
19694: PPUSH
19695: LD_INT 1
19697: PPUSH
19698: LD_INT 2
19700: PPUSH
19701: LD_INT 1
19703: PPUSH
19704: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
19708: LD_EXP 57
19712: PPUSH
19713: LD_INT 9
19715: PPUSH
19716: LD_INT 2
19718: PPUSH
19719: CALL_OW 111
// AddComHold ( Friend ) ;
19723: LD_EXP 57
19727: PPUSH
19728: CALL_OW 200
// end ; end ;
19732: PPOPN 1
19734: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
19735: LD_INT 9
19737: PPUSH
19738: LD_INT 2
19740: PPUSH
19741: CALL_OW 428
19745: PUSH
19746: LD_EXP 57
19750: EQUAL
19751: PUSH
19752: LD_EXP 57
19756: PPUSH
19757: CALL_OW 255
19761: PUSH
19762: LD_INT 8
19764: EQUAL
19765: AND
19766: IFFALSE 19780
19768: GO 19770
19770: DISABLE
// RemoveUnit ( Friend ) ;
19771: LD_EXP 57
19775: PPUSH
19776: CALL_OW 64
19780: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
19781: LD_EXP 14
19785: PUSH
19786: LD_INT 31500
19788: GREATEREQUAL
19789: PUSH
19790: LD_EXP 7
19794: AND
19795: PUSH
19796: LD_EXP 2
19800: AND
19801: IFFALSE 20231
19803: GO 19805
19805: DISABLE
19806: LD_INT 0
19808: PPUSH
19809: PPUSH
19810: PPUSH
// begin missionStage := 7 ;
19811: LD_ADDR_EXP 15
19815: PUSH
19816: LD_INT 7
19818: ST_TO_ADDR
// uc_side = 1 ;
19819: LD_ADDR_OWVAR 20
19823: PUSH
19824: LD_INT 1
19826: ST_TO_ADDR
// uc_nation = 1 ;
19827: LD_ADDR_OWVAR 21
19831: PUSH
19832: LD_INT 1
19834: ST_TO_ADDR
// for i = 1 to 5 do
19835: LD_ADDR_VAR 0 1
19839: PUSH
19840: DOUBLE
19841: LD_INT 1
19843: DEC
19844: ST_TO_ADDR
19845: LD_INT 5
19847: PUSH
19848: FOR_TO
19849: IFFALSE 19945
// begin vc_engine = 3 ;
19851: LD_ADDR_OWVAR 39
19855: PUSH
19856: LD_INT 3
19858: ST_TO_ADDR
// vc_control = 3 ;
19859: LD_ADDR_OWVAR 38
19863: PUSH
19864: LD_INT 3
19866: ST_TO_ADDR
// vc_chassis = 3 ;
19867: LD_ADDR_OWVAR 37
19871: PUSH
19872: LD_INT 3
19874: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
19875: LD_ADDR_OWVAR 40
19879: PUSH
19880: LD_INT 5
19882: PUSH
19883: LD_INT 9
19885: PUSH
19886: LD_INT 7
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: PUSH
19894: LD_INT 1
19896: PPUSH
19897: LD_INT 3
19899: PPUSH
19900: CALL_OW 12
19904: ARRAY
19905: ST_TO_ADDR
// veh = CreateVehicle ;
19906: LD_ADDR_VAR 0 2
19910: PUSH
19911: CALL_OW 45
19915: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
19916: LD_VAR 0 2
19920: PPUSH
19921: LD_INT 1
19923: PPUSH
19924: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
19928: LD_VAR 0 2
19932: PPUSH
19933: LD_INT 19
19935: PPUSH
19936: LD_INT 0
19938: PPUSH
19939: CALL_OW 49
// end ;
19943: GO 19848
19945: POP
19946: POP
// vc_engine = 3 ;
19947: LD_ADDR_OWVAR 39
19951: PUSH
19952: LD_INT 3
19954: ST_TO_ADDR
// vc_control = 1 ;
19955: LD_ADDR_OWVAR 38
19959: PUSH
19960: LD_INT 1
19962: ST_TO_ADDR
// vc_chassis = 3 ;
19963: LD_ADDR_OWVAR 37
19967: PUSH
19968: LD_INT 3
19970: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
19971: LD_ADDR_OWVAR 40
19975: PUSH
19976: LD_INT 5
19978: PUSH
19979: LD_INT 9
19981: PUSH
19982: LD_INT 7
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: PUSH
19990: LD_INT 1
19992: PPUSH
19993: LD_INT 3
19995: PPUSH
19996: CALL_OW 12
20000: ARRAY
20001: ST_TO_ADDR
// vehG = CreateVehicle ;
20002: LD_ADDR_VAR 0 3
20006: PUSH
20007: CALL_OW 45
20011: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
20012: LD_VAR 0 3
20016: PPUSH
20017: LD_INT 1
20019: PPUSH
20020: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
20024: LD_VAR 0 3
20028: PPUSH
20029: LD_INT 19
20031: PPUSH
20032: LD_INT 0
20034: PPUSH
20035: CALL_OW 49
// if JMMGirl = 1 then
20039: LD_EXP 7
20043: PUSH
20044: LD_INT 1
20046: EQUAL
20047: IFFALSE 20103
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
20049: LD_ADDR_EXP 35
20053: PUSH
20054: LD_STRING Joan
20056: PPUSH
20057: LD_INT 1
20059: PPUSH
20060: LD_STRING 14_
20062: PPUSH
20063: CALL 53843 0 3
20067: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
20068: LD_EXP 35
20072: PPUSH
20073: LD_VAR 0 3
20077: PPUSH
20078: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
20082: LD_VAR 0 3
20086: PPUSH
20087: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
20091: LD_EXP 35
20095: PPUSH
20096: LD_STRING D10BW-Joan-1
20098: PPUSH
20099: CALL_OW 94
// end ; if JMMGirl = 2 then
20103: LD_EXP 7
20107: PUSH
20108: LD_INT 2
20110: EQUAL
20111: IFFALSE 20167
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
20113: LD_ADDR_EXP 37
20117: PUSH
20118: LD_STRING Lisa
20120: PPUSH
20121: LD_INT 1
20123: PPUSH
20124: LD_STRING 14_
20126: PPUSH
20127: CALL 53843 0 3
20131: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
20132: LD_EXP 37
20136: PPUSH
20137: LD_VAR 0 3
20141: PPUSH
20142: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
20146: LD_VAR 0 3
20150: PPUSH
20151: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
20155: LD_EXP 37
20159: PPUSH
20160: LD_STRING D10BW-Lisa-1
20162: PPUSH
20163: CALL_OW 94
// end ; if JMMGirl = 3 then
20167: LD_EXP 7
20171: PUSH
20172: LD_INT 3
20174: EQUAL
20175: IFFALSE 20231
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
20177: LD_ADDR_EXP 49
20181: PUSH
20182: LD_STRING Connie
20184: PPUSH
20185: LD_INT 1
20187: PPUSH
20188: LD_STRING 14_
20190: PPUSH
20191: CALL 53843 0 3
20195: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
20196: LD_EXP 49
20200: PPUSH
20201: LD_VAR 0 3
20205: PPUSH
20206: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
20210: LD_VAR 0 3
20214: PPUSH
20215: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
20219: LD_EXP 37
20223: PPUSH
20224: LD_STRING D10BW-Con-1
20226: PPUSH
20227: CALL_OW 94
// end ; end ;
20231: PPOPN 3
20233: END
// every 0 0$1 trigger missionTime >= 30 30$00 do var i , veh , tmp ;
20234: LD_EXP 14
20238: PUSH
20239: LD_INT 63000
20241: GREATEREQUAL
20242: IFFALSE 20654
20244: GO 20246
20246: DISABLE
20247: LD_INT 0
20249: PPUSH
20250: PPUSH
20251: PPUSH
// begin tmp := PrepareStevensSquad ;
20252: LD_ADDR_VAR 0 3
20256: PUSH
20257: CALL 1714 0 0
20261: ST_TO_ADDR
// if not tmp then
20262: LD_VAR 0 3
20266: NOT
20267: IFFALSE 20271
// exit ;
20269: GO 20654
// uc_side := 1 ;
20271: LD_ADDR_OWVAR 20
20275: PUSH
20276: LD_INT 1
20278: ST_TO_ADDR
// uc_nation := 1 ;
20279: LD_ADDR_OWVAR 21
20283: PUSH
20284: LD_INT 1
20286: ST_TO_ADDR
// for i in tmp do
20287: LD_ADDR_VAR 0 1
20291: PUSH
20292: LD_VAR 0 3
20296: PUSH
20297: FOR_IN
20298: IFFALSE 20395
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
20300: LD_INT 3
20302: PPUSH
20303: LD_INT 3
20305: PPUSH
20306: LD_INT 1
20308: PPUSH
20309: LD_INT 5
20311: PUSH
20312: LD_INT 9
20314: PUSH
20315: LD_INT 7
20317: PUSH
20318: EMPTY
20319: LIST
20320: LIST
20321: LIST
20322: PUSH
20323: LD_INT 1
20325: PPUSH
20326: LD_INT 3
20328: PPUSH
20329: CALL_OW 12
20333: ARRAY
20334: PPUSH
20335: LD_INT 40
20337: PPUSH
20338: CALL 60476 0 5
// veh := CreateVehicle ;
20342: LD_ADDR_VAR 0 2
20346: PUSH
20347: CALL_OW 45
20351: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
20352: LD_VAR 0 2
20356: PPUSH
20357: LD_INT 1
20359: PPUSH
20360: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
20364: LD_VAR 0 2
20368: PPUSH
20369: LD_INT 19
20371: PPUSH
20372: LD_INT 0
20374: PPUSH
20375: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
20379: LD_VAR 0 1
20383: PPUSH
20384: LD_VAR 0 2
20388: PPUSH
20389: CALL_OW 52
// end ;
20393: GO 20297
20395: POP
20396: POP
// missionStage := 8 ;
20397: LD_ADDR_EXP 15
20401: PUSH
20402: LD_INT 8
20404: ST_TO_ADDR
// DialogueOn ;
20405: CALL_OW 6
// if Stevens then
20409: LD_EXP 36
20413: IFFALSE 20527
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
20415: LD_EXP 36
20419: PPUSH
20420: CALL_OW 310
20424: PPUSH
20425: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
20429: LD_EXP 36
20433: PPUSH
20434: LD_STRING D8-Huck-1
20436: PPUSH
20437: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
20441: LD_EXP 34
20445: PPUSH
20446: LD_STRING D8-JMM-1
20448: PPUSH
20449: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
20453: LD_EXP 36
20457: PPUSH
20458: LD_STRING D8-Huck-2
20460: PPUSH
20461: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
20465: LD_EXP 34
20469: PPUSH
20470: LD_STRING D8-JMM-2
20472: PPUSH
20473: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
20477: LD_EXP 36
20481: PPUSH
20482: LD_STRING D8-Huck-3
20484: PPUSH
20485: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
20489: LD_EXP 34
20493: PPUSH
20494: LD_STRING D8-JMM-3
20496: PPUSH
20497: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
20501: LD_EXP 36
20505: PPUSH
20506: LD_STRING D8-Huck-4
20508: PPUSH
20509: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
20513: LD_EXP 34
20517: PPUSH
20518: LD_STRING D8-JMM-4
20520: PPUSH
20521: CALL_OW 88
// end else
20525: GO 20637
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
20527: LD_EXP 50
20531: PPUSH
20532: CALL_OW 310
20536: PPUSH
20537: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
20541: LD_EXP 50
20545: PPUSH
20546: LD_STRING D8-Huck-1
20548: PPUSH
20549: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
20553: LD_EXP 34
20557: PPUSH
20558: LD_STRING D8-JMM-1a
20560: PPUSH
20561: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
20565: LD_EXP 50
20569: PPUSH
20570: LD_STRING D8-Huck-2
20572: PPUSH
20573: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
20577: LD_EXP 34
20581: PPUSH
20582: LD_STRING D8-JMM-2
20584: PPUSH
20585: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
20589: LD_EXP 50
20593: PPUSH
20594: LD_STRING D8-Huck-3
20596: PPUSH
20597: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
20601: LD_EXP 34
20605: PPUSH
20606: LD_STRING D8-JMM-3
20608: PPUSH
20609: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
20613: LD_EXP 50
20617: PPUSH
20618: LD_STRING D8-Huck-4
20620: PPUSH
20621: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
20625: LD_EXP 34
20629: PPUSH
20630: LD_STRING D8-JMM-4
20632: PPUSH
20633: CALL_OW 88
// end ; DialogueOff ;
20637: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
20641: LD_INT 25
20643: PPUSH
20644: LD_INT 1
20646: PPUSH
20647: LD_INT 1
20649: PPUSH
20650: CALL_OW 322
// end ;
20654: PPOPN 3
20656: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
20657: LD_INT 1
20659: PPUSH
20660: LD_EXP 66
20664: PPUSH
20665: CALL_OW 292
20669: IFFALSE 20920
20671: GO 20673
20673: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
20674: LD_EXP 66
20678: PPUSH
20679: CALL_OW 87
// DialogueOn ;
20683: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
20687: LD_EXP 34
20691: PPUSH
20692: LD_STRING D10nB-JMM-1
20694: PPUSH
20695: CALL_OW 88
// if BurlakStatus = 1 then
20699: LD_EXP 9
20703: PUSH
20704: LD_INT 1
20706: EQUAL
20707: IFFALSE 20721
// begin Say ( Vsevolod , D10nB-Vse-1a ) ;
20709: LD_EXP 65
20713: PPUSH
20714: LD_STRING D10nB-Vse-1a
20716: PPUSH
20717: CALL_OW 88
// end ; if BurlakStatus = 0 then
20721: LD_EXP 9
20725: PUSH
20726: LD_INT 0
20728: EQUAL
20729: IFFALSE 20743
// Say ( Vsevolod , D10nB-Vse-1 ) ;
20731: LD_EXP 65
20735: PPUSH
20736: LD_STRING D10nB-Vse-1
20738: PPUSH
20739: CALL_OW 88
// Say ( JMM , D10nB-JMM-2 ) ;
20743: LD_EXP 34
20747: PPUSH
20748: LD_STRING D10nB-JMM-2
20750: PPUSH
20751: CALL_OW 88
// if KappaStatus then
20755: LD_EXP 2
20759: IFFALSE 20773
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
20761: LD_EXP 65
20765: PPUSH
20766: LD_STRING D10nB-Vse-5a
20768: PPUSH
20769: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
20773: LD_EXP 2
20777: NOT
20778: PUSH
20779: LD_EXP 6
20783: PUSH
20784: LD_INT 0
20786: EQUAL
20787: AND
20788: IFFALSE 20916
// begin if JMMGirl = 1 then
20790: LD_EXP 7
20794: PUSH
20795: LD_INT 1
20797: EQUAL
20798: IFFALSE 20848
// begin Say ( Vsevolod , D10nB-Vse-2 ) ;
20800: LD_EXP 65
20804: PPUSH
20805: LD_STRING D10nB-Vse-2
20807: PPUSH
20808: CALL_OW 88
// Say ( JMM , D10nB-JMM-3 ) ;
20812: LD_EXP 34
20816: PPUSH
20817: LD_STRING D10nB-JMM-3
20819: PPUSH
20820: CALL_OW 88
// Say ( Vsevolod , D10nB-Vse-3 ) ;
20824: LD_EXP 65
20828: PPUSH
20829: LD_STRING D10nB-Vse-3
20831: PPUSH
20832: CALL_OW 88
// Say ( JMM , D10nB-JMM-4 ) ;
20836: LD_EXP 34
20840: PPUSH
20841: LD_STRING D10nB-JMM-4
20843: PPUSH
20844: CALL_OW 88
// end ; if JMMGirl = 2 then
20848: LD_EXP 7
20852: PUSH
20853: LD_INT 2
20855: EQUAL
20856: IFFALSE 20882
// begin Say ( Vsevolod , D10nB-Vse-4 ) ;
20858: LD_EXP 65
20862: PPUSH
20863: LD_STRING D10nB-Vse-4
20865: PPUSH
20866: CALL_OW 88
// Say ( JMM , D10nB-JMM-5 ) ;
20870: LD_EXP 34
20874: PPUSH
20875: LD_STRING D10nB-JMM-5
20877: PPUSH
20878: CALL_OW 88
// end ; if JMMGirl = 3 then
20882: LD_EXP 7
20886: PUSH
20887: LD_INT 3
20889: EQUAL
20890: IFFALSE 20916
// begin Say ( Vsevolod , D10nB-Vse-5 ) ;
20892: LD_EXP 65
20896: PPUSH
20897: LD_STRING D10nB-Vse-5
20899: PPUSH
20900: CALL_OW 88
// Say ( JMM , D10nB-JMM-6 ) ;
20904: LD_EXP 34
20908: PPUSH
20909: LD_STRING D10nB-JMM-6
20911: PPUSH
20912: CALL_OW 88
// end ; end ; DialogueOff ;
20916: CALL_OW 7
// end ;
20920: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
20921: LD_EXP 14
20925: PUSH
20926: LD_INT 115500
20928: GREATEREQUAL
20929: IFFALSE 21281
20931: GO 20933
20933: DISABLE
20934: LD_INT 0
20936: PPUSH
// begin missionStage := 10 ;
20937: LD_ADDR_EXP 15
20941: PUSH
20942: LD_INT 10
20944: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
20945: LD_ADDR_VAR 0 1
20949: PUSH
20950: LD_INT 22
20952: PUSH
20953: LD_INT 1
20955: PUSH
20956: EMPTY
20957: LIST
20958: LIST
20959: PUSH
20960: LD_INT 26
20962: PUSH
20963: LD_INT 1
20965: PUSH
20966: EMPTY
20967: LIST
20968: LIST
20969: PUSH
20970: LD_INT 3
20972: PUSH
20973: LD_INT 25
20975: PUSH
20976: LD_INT 12
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: PUSH
20983: LD_INT 25
20985: PUSH
20986: LD_INT 16
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: LIST
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: LIST
21002: PPUSH
21003: CALL_OW 69
21007: PUSH
21008: LD_EXP 34
21012: PUSH
21013: LD_EXP 36
21017: PUSH
21018: LD_EXP 50
21022: PUSH
21023: LD_EXP 37
21027: PUSH
21028: LD_EXP 38
21032: PUSH
21033: LD_EXP 39
21037: PUSH
21038: LD_EXP 40
21042: PUSH
21043: LD_EXP 41
21047: PUSH
21048: LD_EXP 42
21052: PUSH
21053: LD_EXP 43
21057: PUSH
21058: LD_EXP 44
21062: PUSH
21063: LD_EXP 45
21067: PUSH
21068: LD_EXP 46
21072: PUSH
21073: LD_EXP 47
21077: PUSH
21078: LD_EXP 48
21082: PUSH
21083: EMPTY
21084: LIST
21085: LIST
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: DIFF
21100: ST_TO_ADDR
// if not tmp and Brown then
21101: LD_VAR 0 1
21105: NOT
21106: PUSH
21107: LD_EXP 42
21111: AND
21112: IFFALSE 21127
// tmp := [ Brown ] ;
21114: LD_ADDR_VAR 0 1
21118: PUSH
21119: LD_EXP 42
21123: PUSH
21124: EMPTY
21125: LIST
21126: ST_TO_ADDR
// DialogueOn ;
21127: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
21131: LD_VAR 0 1
21135: PUSH
21136: LD_INT 1
21138: ARRAY
21139: PPUSH
21140: LD_STRING D11-Sol1-1
21142: PPUSH
21143: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
21147: LD_EXP 59
21151: PPUSH
21152: LD_STRING D11-Pla-1
21154: PPUSH
21155: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
21159: LD_EXP 60
21163: PPUSH
21164: LD_STRING D11-Kov-1
21166: PPUSH
21167: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
21171: LD_EXP 59
21175: PPUSH
21176: LD_STRING D11-Pla-2
21178: PPUSH
21179: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
21183: LD_VAR 0 1
21187: PUSH
21188: LD_INT 1
21190: ARRAY
21191: PPUSH
21192: LD_STRING D11-Sol1-2
21194: PPUSH
21195: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
21199: LD_EXP 34
21203: PPUSH
21204: LD_STRING D11-JMM-2
21206: PPUSH
21207: CALL_OW 88
// DialogueOff ;
21211: CALL_OW 7
// allowBehemothConstruct := true ;
21215: LD_ADDR_EXP 25
21219: PUSH
21220: LD_INT 1
21222: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
21223: LD_STRING M4
21225: PPUSH
21226: CALL_OW 337
// BuildBehemoths ;
21230: CALL 6267 0 0
// repeat wait ( 15 15$00 ) ;
21234: LD_INT 31500
21236: PPUSH
21237: CALL_OW 67
// if behemothDestroyedBeforeFinish then
21241: LD_EXP 27
21245: IFFALSE 21249
// break ;
21247: GO 21281
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
21249: LD_INT 267
21251: PPUSH
21252: CALL_OW 274
21256: PPUSH
21257: LD_INT 1
21259: PPUSH
21260: CALL_OW 275
21264: PUSH
21265: LD_INT 1000
21267: GREATEREQUAL
21268: IFFALSE 21274
// BuildBehemoths ;
21270: CALL 6267 0 0
// until not behemothBuilders ;
21274: LD_EXP 68
21278: NOT
21279: IFFALSE 21234
// end ;
21281: PPOPN 1
21283: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
21284: LD_EXP 68
21288: NOT
21289: PUSH
21290: LD_EXP 28
21294: NOT
21295: AND
21296: PUSH
21297: LD_EXP 25
21301: AND
21302: IFFALSE 21322
21304: GO 21306
21306: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
21307: LD_STRING M4a
21309: PPUSH
21310: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
21314: LD_ADDR_EXP 27
21318: PUSH
21319: LD_INT 1
21321: ST_TO_ADDR
// end ;
21322: END
// every 0 0$1 trigger behemothDone do
21323: LD_EXP 28
21327: IFFALSE 21339
21329: GO 21331
21331: DISABLE
// ChangeMissionObjectives ( M4b ) ;
21332: LD_STRING M4b
21334: PPUSH
21335: CALL_OW 337
21339: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
21340: LD_EXP 29
21344: NOT
21345: IFFALSE 21541
21347: GO 21349
21349: DISABLE
21350: LD_INT 0
21352: PPUSH
21353: PPUSH
// begin enable ;
21354: ENABLE
// tmp := GetBehemoths ( 3 ) ;
21355: LD_ADDR_VAR 0 1
21359: PUSH
21360: LD_INT 3
21362: PPUSH
21363: CALL 96207 0 1
21367: ST_TO_ADDR
// if not tmp and not behemothDone then
21368: LD_VAR 0 1
21372: NOT
21373: PUSH
21374: LD_EXP 28
21378: NOT
21379: AND
21380: IFFALSE 21416
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
21382: LD_ADDR_VAR 0 1
21386: PUSH
21387: LD_INT 22
21389: PUSH
21390: LD_INT 3
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: PUSH
21397: LD_INT 30
21399: PUSH
21400: LD_INT 37
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: PUSH
21407: EMPTY
21408: LIST
21409: LIST
21410: PPUSH
21411: CALL_OW 69
21415: ST_TO_ADDR
// if not tmp then
21416: LD_VAR 0 1
21420: NOT
21421: IFFALSE 21425
// exit ;
21423: GO 21541
// for i in tmp do
21425: LD_ADDR_VAR 0 2
21429: PUSH
21430: LD_VAR 0 1
21434: PUSH
21435: FOR_IN
21436: IFFALSE 21539
// if See ( 1 , i ) then
21438: LD_INT 1
21440: PPUSH
21441: LD_VAR 0 2
21445: PPUSH
21446: CALL_OW 292
21450: IFFALSE 21537
// begin if GetType ( i ) = unit_building then
21452: LD_VAR 0 2
21456: PPUSH
21457: CALL_OW 247
21461: PUSH
21462: LD_INT 3
21464: EQUAL
21465: IFFALSE 21503
// begin CenterNowOnUnits ( i ) ;
21467: LD_VAR 0 2
21471: PPUSH
21472: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
21476: LD_EXP 34
21480: PPUSH
21481: LD_STRING D17a-JMM-1
21483: PPUSH
21484: CALL_OW 88
// seeBehemoth := true ;
21488: LD_ADDR_EXP 29
21492: PUSH
21493: LD_INT 1
21495: ST_TO_ADDR
// disable ;
21496: DISABLE
// exit ;
21497: POP
21498: POP
21499: GO 21541
// end else
21501: GO 21537
// begin CenterNowOnUnits ( i ) ;
21503: LD_VAR 0 2
21507: PPUSH
21508: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
21512: LD_EXP 34
21516: PPUSH
21517: LD_STRING D17b-JMM-1
21519: PPUSH
21520: CALL_OW 88
// seeBehemoth := true ;
21524: LD_ADDR_EXP 29
21528: PUSH
21529: LD_INT 1
21531: ST_TO_ADDR
// disable ;
21532: DISABLE
// exit ;
21533: POP
21534: POP
21535: GO 21541
// end ; end ;
21537: GO 21435
21539: POP
21540: POP
// end ;
21541: PPOPN 2
21543: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var bomb , dec , tmp ;
21544: LD_EXP 14
21548: PUSH
21549: LD_INT 115500
21551: GREATEREQUAL
21552: IFFALSE 22725
21554: GO 21556
21556: DISABLE
21557: LD_INT 0
21559: PPUSH
21560: PPUSH
21561: PPUSH
// begin MC_InsertProduceList ( 2 , [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ) ;
21562: LD_INT 2
21564: PPUSH
21565: LD_INT 23
21567: PUSH
21568: LD_INT 3
21570: PUSH
21571: LD_INT 3
21573: PUSH
21574: LD_INT 48
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: PPUSH
21583: CALL 47948 0 2
// repeat wait ( 0 0$1 ) ;
21587: LD_INT 35
21589: PPUSH
21590: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
21594: LD_INT 22
21596: PUSH
21597: LD_INT 3
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 34
21606: PUSH
21607: LD_INT 48
21609: PUSH
21610: EMPTY
21611: LIST
21612: LIST
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: PPUSH
21618: CALL_OW 69
21622: IFFALSE 21587
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
21624: LD_ADDR_VAR 0 1
21628: PUSH
21629: LD_INT 22
21631: PUSH
21632: LD_INT 3
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 34
21641: PUSH
21642: LD_INT 48
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: PUSH
21649: EMPTY
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 69
21657: PUSH
21658: LD_INT 1
21660: ARRAY
21661: ST_TO_ADDR
// missionStage := 12 ;
21662: LD_ADDR_EXP 15
21666: PUSH
21667: LD_INT 12
21669: ST_TO_ADDR
// platonovHasBomb := true ;
21670: LD_ADDR_EXP 30
21674: PUSH
21675: LD_INT 1
21677: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
21678: LD_VAR 0 1
21682: PPUSH
21683: LD_INT 181
21685: PPUSH
21686: LD_INT 86
21688: PPUSH
21689: CALL_OW 171
// AddComHold ( bomb ) ;
21693: LD_VAR 0 1
21697: PPUSH
21698: CALL_OW 200
// wait ( 0 0$10 ) ;
21702: LD_INT 350
21704: PPUSH
21705: CALL_OW 67
// DialogueOn ;
21709: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
21713: LD_EXP 59
21717: PPUSH
21718: LD_STRING D15-Pla-1
21720: PPUSH
21721: CALL_OW 94
// dec = Query ( Q15a ) ;
21725: LD_ADDR_VAR 0 2
21729: PUSH
21730: LD_STRING Q15a
21732: PPUSH
21733: CALL_OW 97
21737: ST_TO_ADDR
// if dec = 1 then
21738: LD_VAR 0 2
21742: PUSH
21743: LD_INT 1
21745: EQUAL
21746: IFFALSE 21769
// begin Say ( JMM , D15a-JMM-1 ) ;
21748: LD_EXP 34
21752: PPUSH
21753: LD_STRING D15a-JMM-1
21755: PPUSH
21756: CALL_OW 88
// YouLost ( Surrender ) ;
21760: LD_STRING Surrender
21762: PPUSH
21763: CALL_OW 104
// exit ;
21767: GO 22725
// end ; if dec = 2 then
21769: LD_VAR 0 2
21773: PUSH
21774: LD_INT 2
21776: EQUAL
21777: IFFALSE 21846
// begin Say ( JMM , D15b-JMM-1 ) ;
21779: LD_EXP 34
21783: PPUSH
21784: LD_STRING D15b-JMM-1
21786: PPUSH
21787: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
21791: LD_EXP 59
21795: PPUSH
21796: LD_STRING D15b-Pla-1
21798: PPUSH
21799: CALL_OW 94
// DialogueOff ;
21803: CALL_OW 7
// wait ( 3 3$00 ) ;
21807: LD_INT 6300
21809: PPUSH
21810: CALL_OW 67
// DialogueOn ;
21814: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
21818: LD_EXP 34
21822: PPUSH
21823: LD_STRING D15d-JMM-1a
21825: PPUSH
21826: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
21830: LD_EXP 59
21834: PPUSH
21835: LD_STRING D15d-Pla-1
21837: PPUSH
21838: CALL_OW 94
// DialogueOff ;
21842: CALL_OW 7
// end ; if dec = 3 then
21846: LD_VAR 0 2
21850: PUSH
21851: LD_INT 3
21853: EQUAL
21854: IFFALSE 21908
// begin Say ( JMM , D15c-JMM-1 ) ;
21856: LD_EXP 34
21860: PPUSH
21861: LD_STRING D15c-JMM-1
21863: PPUSH
21864: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
21868: LD_EXP 59
21872: PPUSH
21873: LD_STRING D15c-Pla-1
21875: PPUSH
21876: CALL_OW 94
// DialogueOff ;
21880: CALL_OW 7
// wait ( 0 0$15 ) ;
21884: LD_INT 525
21886: PPUSH
21887: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
21891: LD_VAR 0 1
21895: PPUSH
21896: LD_INT 60
21898: PPUSH
21899: LD_INT 95
21901: PPUSH
21902: CALL_OW 116
// exit ;
21906: GO 22725
// end ; if dec = 4 then
21908: LD_VAR 0 2
21912: PUSH
21913: LD_INT 4
21915: EQUAL
21916: IFFALSE 21946
// begin Say ( JMM , D15d-JMM-1 ) ;
21918: LD_EXP 34
21922: PPUSH
21923: LD_STRING D15d-JMM-1
21925: PPUSH
21926: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
21930: LD_EXP 59
21934: PPUSH
21935: LD_STRING D15d-Pla-1
21937: PPUSH
21938: CALL_OW 94
// DialogueOff ;
21942: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
21946: LD_EXP 57
21950: PPUSH
21951: CALL_OW 302
21955: PUSH
21956: LD_EXP 57
21960: PPUSH
21961: CALL_OW 255
21965: PUSH
21966: LD_INT 1
21968: EQUAL
21969: AND
21970: PUSH
21971: LD_INT 22
21973: PUSH
21974: LD_INT 1
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PUSH
21981: LD_INT 34
21983: PUSH
21984: LD_INT 8
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: PUSH
21991: EMPTY
21992: LIST
21993: LIST
21994: PPUSH
21995: CALL_OW 69
21999: NOT
22000: AND
22001: IFFALSE 22626
// begin SetSide ( Friend , 8 ) ;
22003: LD_EXP 57
22007: PPUSH
22008: LD_INT 8
22010: PPUSH
22011: CALL_OW 235
// if IsInUnit ( Friend ) then
22015: LD_EXP 57
22019: PPUSH
22020: CALL_OW 310
22024: IFFALSE 22035
// ComExitBuilding ( Friend ) ;
22026: LD_EXP 57
22030: PPUSH
22031: CALL_OW 122
// if IsDriver ( Friend ) then
22035: LD_EXP 57
22039: PPUSH
22040: CALL 93883 0 1
22044: IFFALSE 22055
// ComExitVehicle ( Friend ) ;
22046: LD_EXP 57
22050: PPUSH
22051: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
22055: LD_EXP 57
22059: PPUSH
22060: LD_INT 9
22062: PPUSH
22063: LD_INT 2
22065: PPUSH
22066: CALL_OW 171
// wait ( 0 0$05 ) ;
22070: LD_INT 175
22072: PPUSH
22073: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
22077: LD_EXP 57
22081: PPUSH
22082: CALL_OW 87
// DialogueOn ;
22086: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
22090: LD_EXP 34
22094: PPUSH
22095: LD_STRING D16-JMM-1
22097: PPUSH
22098: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
22102: LD_EXP 57
22106: PPUSH
22107: LD_STRING D16-Friend-1
22109: PPUSH
22110: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
22114: LD_EXP 34
22118: PPUSH
22119: LD_STRING D16-JMM-2
22121: PPUSH
22122: CALL_OW 88
// DialogueOff ;
22126: CALL_OW 7
// SetSide ( Friend , 1 ) ;
22130: LD_EXP 57
22134: PPUSH
22135: LD_INT 1
22137: PPUSH
22138: CALL_OW 235
// ComHold ( Friend ) ;
22142: LD_EXP 57
22146: PPUSH
22147: CALL_OW 140
// wait ( 0 0$20 ) ;
22151: LD_INT 700
22153: PPUSH
22154: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
22158: LD_EXP 57
22162: PPUSH
22163: LD_INT 9
22165: PPUSH
22166: LD_INT 2
22168: PPUSH
22169: CALL_OW 297
22173: PUSH
22174: LD_INT 30
22176: LESS
22177: IFFALSE 22246
// begin SetSide ( Friend , 8 ) ;
22179: LD_EXP 57
22183: PPUSH
22184: LD_INT 8
22186: PPUSH
22187: CALL_OW 235
// if IsInUnit ( Friend ) then
22191: LD_EXP 57
22195: PPUSH
22196: CALL_OW 310
22200: IFFALSE 22211
// ComExitBuilding ( Friend ) ;
22202: LD_EXP 57
22206: PPUSH
22207: CALL_OW 122
// if IsDriver ( Friend ) then
22211: LD_EXP 57
22215: PPUSH
22216: CALL 93883 0 1
22220: IFFALSE 22231
// ComExitVehicle ( Friend ) ;
22222: LD_EXP 57
22226: PPUSH
22227: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
22231: LD_EXP 57
22235: PPUSH
22236: LD_INT 9
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
22246: LD_INT 1050
22248: PPUSH
22249: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
22253: LD_INT 22
22255: PUSH
22256: LD_INT 1
22258: PUSH
22259: EMPTY
22260: LIST
22261: LIST
22262: PUSH
22263: LD_INT 34
22265: PUSH
22266: LD_INT 8
22268: PUSH
22269: EMPTY
22270: LIST
22271: LIST
22272: PUSH
22273: EMPTY
22274: LIST
22275: LIST
22276: PPUSH
22277: CALL_OW 69
22281: NOT
22282: IFFALSE 22604
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
22284: LD_ADDR_VAR 0 3
22288: PUSH
22289: LD_INT 22
22291: PUSH
22292: LD_INT 1
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PUSH
22299: LD_INT 26
22301: PUSH
22302: LD_INT 1
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: PUSH
22309: LD_INT 3
22311: PUSH
22312: LD_INT 25
22314: PUSH
22315: LD_INT 12
22317: PUSH
22318: EMPTY
22319: LIST
22320: LIST
22321: PUSH
22322: LD_INT 25
22324: PUSH
22325: LD_INT 16
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PUSH
22332: EMPTY
22333: LIST
22334: LIST
22335: LIST
22336: PUSH
22337: EMPTY
22338: LIST
22339: LIST
22340: LIST
22341: PPUSH
22342: CALL_OW 69
22346: PUSH
22347: LD_EXP 34
22351: PUSH
22352: LD_EXP 36
22356: PUSH
22357: LD_EXP 50
22361: PUSH
22362: LD_EXP 37
22366: PUSH
22367: LD_EXP 38
22371: PUSH
22372: LD_EXP 39
22376: PUSH
22377: LD_EXP 40
22381: PUSH
22382: LD_EXP 41
22386: PUSH
22387: LD_EXP 42
22391: PUSH
22392: LD_EXP 43
22396: PUSH
22397: LD_EXP 44
22401: PUSH
22402: LD_EXP 45
22406: PUSH
22407: LD_EXP 46
22411: PUSH
22412: LD_EXP 47
22416: PUSH
22417: LD_EXP 48
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: LIST
22426: LIST
22427: LIST
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: DIFF
22439: ST_TO_ADDR
// DialogueOn ;
22440: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
22444: LD_EXP 59
22448: PPUSH
22449: LD_STRING D16a-Pla-1
22451: PPUSH
22452: CALL_OW 94
// if Stevens then
22456: LD_EXP 36
22460: IFFALSE 22476
// Say ( Stevens , D16a-Huck-1 ) else
22462: LD_EXP 36
22466: PPUSH
22467: LD_STRING D16a-Huck-1
22469: PPUSH
22470: CALL_OW 88
22474: GO 22518
// if Baker then
22476: LD_EXP 50
22480: IFFALSE 22496
// Say ( Baker , D16a-Huck-1 ) else
22482: LD_EXP 50
22486: PPUSH
22487: LD_STRING D16a-Huck-1
22489: PPUSH
22490: CALL_OW 88
22494: GO 22518
// if tmp then
22496: LD_VAR 0 3
22500: IFFALSE 22518
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
22502: LD_VAR 0 3
22506: PUSH
22507: LD_INT 1
22509: ARRAY
22510: PPUSH
22511: LD_STRING D16a-Sol1-1
22513: PPUSH
22514: CALL_OW 88
// if GetSide ( Friend ) = 8 then
22518: LD_EXP 57
22522: PPUSH
22523: CALL_OW 255
22527: PUSH
22528: LD_INT 8
22530: EQUAL
22531: IFFALSE 22547
// Say ( JMM , D16a-JMM-1 ) else
22533: LD_EXP 34
22537: PPUSH
22538: LD_STRING D16a-JMM-1
22540: PPUSH
22541: CALL_OW 88
22545: GO 22583
// begin Say ( JMM , D16a-JMM-1a ) ;
22547: LD_EXP 34
22551: PPUSH
22552: LD_STRING D16a-JMM-1a
22554: PPUSH
22555: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
22559: LD_EXP 57
22563: PPUSH
22564: LD_STRING D16a-Friend-1
22566: PPUSH
22567: CALL_OW 88
// SetSide ( Friend , 3 ) ;
22571: LD_EXP 57
22575: PPUSH
22576: LD_INT 3
22578: PPUSH
22579: CALL_OW 235
// end ; DialogueOff ;
22583: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
22587: LD_VAR 0 1
22591: PPUSH
22592: LD_INT 60
22594: PPUSH
22595: LD_INT 95
22597: PPUSH
22598: CALL_OW 116
// end else
22602: GO 22624
// begin DialogueOn ;
22604: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
22608: LD_EXP 59
22612: PPUSH
22613: LD_STRING D16c-Pla-
22615: PPUSH
22616: CALL_OW 94
// DialogueOff ;
22620: CALL_OW 7
// end ; end else
22624: GO 22725
// begin wait ( 3 3$00 ) ;
22626: LD_INT 6300
22628: PPUSH
22629: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
22633: LD_INT 22
22635: PUSH
22636: LD_INT 1
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: PUSH
22643: LD_INT 34
22645: PUSH
22646: LD_INT 8
22648: PUSH
22649: EMPTY
22650: LIST
22651: LIST
22652: PUSH
22653: EMPTY
22654: LIST
22655: LIST
22656: PPUSH
22657: CALL_OW 69
22661: NOT
22662: IFFALSE 22705
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
22664: LD_EXP 59
22668: PPUSH
22669: LD_STRING D16b-Pla-1
22671: PPUSH
22672: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
22676: LD_EXP 34
22680: PPUSH
22681: LD_STRING D16b-JMM-
22683: PPUSH
22684: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_INT 60
22695: PPUSH
22696: LD_INT 95
22698: PPUSH
22699: CALL_OW 116
// end else
22703: GO 22725
// begin DialogueOn ;
22705: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
22709: LD_EXP 59
22713: PPUSH
22714: LD_STRING D16c-Pla-
22716: PPUSH
22717: CALL_OW 94
// DialogueOff ;
22721: CALL_OW 7
// end ; end ; end ;
22725: PPOPN 3
22727: END
// every 0 0$1 trigger missionTime >= 60 60$00 do var dec ;
22728: LD_EXP 14
22732: PUSH
22733: LD_INT 126000
22735: GREATEREQUAL
22736: IFFALSE 23094
22738: GO 22740
22740: DISABLE
22741: LD_INT 0
22743: PPUSH
// begin missionStage = 11 ;
22744: LD_ADDR_EXP 15
22748: PUSH
22749: LD_INT 11
22751: ST_TO_ADDR
// DialogueOn ;
22752: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
22756: LD_EXP 69
22760: PPUSH
22761: LD_STRING D9-Roth-1
22763: PPUSH
22764: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
22768: LD_EXP 34
22772: PPUSH
22773: LD_STRING D9-JMM-1
22775: PPUSH
22776: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
22780: LD_EXP 69
22784: PPUSH
22785: LD_STRING D9-Roth-2
22787: PPUSH
22788: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
22792: LD_EXP 69
22796: PPUSH
22797: LD_STRING D9-Roth-2a
22799: PPUSH
22800: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
22804: LD_EXP 59
22808: PPUSH
22809: LD_STRING D9-Pla-2
22811: PPUSH
22812: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
22816: LD_EXP 69
22820: PPUSH
22821: LD_STRING D9-Roth-3
22823: PPUSH
22824: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
22828: LD_EXP 59
22832: PPUSH
22833: LD_STRING D9-Pla-3
22835: PPUSH
22836: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
22840: LD_EXP 69
22844: PPUSH
22845: LD_STRING D9-Roth-4
22847: PPUSH
22848: CALL_OW 94
// dec = Query ( Q9 ) ;
22852: LD_ADDR_VAR 0 1
22856: PUSH
22857: LD_STRING Q9
22859: PPUSH
22860: CALL_OW 97
22864: ST_TO_ADDR
// if dec = 1 then
22865: LD_VAR 0 1
22869: PUSH
22870: LD_INT 1
22872: EQUAL
22873: IFFALSE 22887
// SayRadio ( Roth , D9a-Roth-1 ) ;
22875: LD_EXP 69
22879: PPUSH
22880: LD_STRING D9a-Roth-1
22882: PPUSH
22883: CALL_OW 94
// if dec = 2 then
22887: LD_VAR 0 1
22891: PUSH
22892: LD_INT 2
22894: EQUAL
22895: IFFALSE 22921
// begin Say ( JMM , D9b-JMM-1 ) ;
22897: LD_EXP 34
22901: PPUSH
22902: LD_STRING D9b-JMM-1
22904: PPUSH
22905: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
22909: LD_EXP 69
22913: PPUSH
22914: LD_STRING D9b-Roth-1
22916: PPUSH
22917: CALL_OW 94
// end ; if dec = 3 then
22921: LD_VAR 0 1
22925: PUSH
22926: LD_INT 3
22928: EQUAL
22929: IFFALSE 22991
// begin Say ( JMM , D9c-JMM-1 ) ;
22931: LD_EXP 34
22935: PPUSH
22936: LD_STRING D9c-JMM-1
22938: PPUSH
22939: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
22943: LD_EXP 69
22947: PPUSH
22948: LD_STRING D9c-Roth-1
22950: PPUSH
22951: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
22955: LD_EXP 34
22959: PPUSH
22960: LD_STRING D9c-JMM-2
22962: PPUSH
22963: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
22967: LD_EXP 69
22971: PPUSH
22972: LD_STRING D9c-Roth-2
22974: PPUSH
22975: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
22979: LD_EXP 34
22983: PPUSH
22984: LD_STRING D9c-JMM-3
22986: PPUSH
22987: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
22991: LD_EXP 69
22995: PPUSH
22996: LD_STRING D9c-Roth-3
22998: PPUSH
22999: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
23003: LD_EXP 69
23007: PPUSH
23008: LD_STRING D9cont-Roth-1
23010: PPUSH
23011: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
23015: LD_EXP 34
23019: PPUSH
23020: LD_STRING D9cont-JMM-1
23022: PPUSH
23023: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
23027: LD_EXP 69
23031: PPUSH
23032: LD_STRING D9cont-Roth-2
23034: PPUSH
23035: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
23039: LD_EXP 34
23043: PPUSH
23044: LD_STRING D9cont-JMM-2
23046: PPUSH
23047: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
23051: LD_EXP 69
23055: PPUSH
23056: LD_STRING D9cont-Roth-3
23058: PPUSH
23059: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
23063: LD_EXP 34
23067: PPUSH
23068: LD_STRING D9cont-JMM-3
23070: PPUSH
23071: CALL_OW 88
// DialogueOff ;
23075: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
23079: LD_STRING M3
23081: PPUSH
23082: CALL_OW 337
// allianceActive := true ;
23086: LD_ADDR_EXP 31
23090: PUSH
23091: LD_INT 1
23093: ST_TO_ADDR
// end ;
23094: PPOPN 1
23096: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , arabianArmy ;
23097: LD_EXP 59
23101: PPUSH
23102: CALL_OW 301
23106: PUSH
23107: LD_EXP 62
23111: PPUSH
23112: CALL_OW 301
23116: AND
23117: PUSH
23118: LD_INT 22
23120: PUSH
23121: LD_INT 3
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: PUSH
23128: LD_INT 21
23130: PUSH
23131: LD_INT 1
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: PUSH
23138: LD_INT 50
23140: PUSH
23141: EMPTY
23142: LIST
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: LIST
23148: PPUSH
23149: CALL_OW 69
23153: PUSH
23154: LD_INT 7
23156: PUSH
23157: LD_INT 8
23159: PUSH
23160: LD_INT 9
23162: PUSH
23163: EMPTY
23164: LIST
23165: LIST
23166: LIST
23167: PUSH
23168: LD_OWVAR 67
23172: ARRAY
23173: LESS
23174: AND
23175: IFFALSE 23464
23177: GO 23179
23179: DISABLE
23180: LD_INT 0
23182: PPUSH
23183: PPUSH
23184: PPUSH
// begin MC_Kill ( 1 ) ;
23185: LD_INT 1
23187: PPUSH
23188: CALL 26192 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
23192: LD_INT 1
23194: PPUSH
23195: LD_INT 3
23197: PPUSH
23198: LD_INT 1
23200: PPUSH
23201: LD_INT 1
23203: PPUSH
23204: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
23208: LD_ADDR_VAR 0 1
23212: PUSH
23213: LD_INT 22
23215: PUSH
23216: LD_INT 3
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: PUSH
23223: LD_INT 21
23225: PUSH
23226: LD_INT 1
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: PUSH
23233: LD_INT 24
23235: PUSH
23236: LD_INT 900
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: PPUSH
23248: CALL_OW 69
23252: PUSH
23253: FOR_IN
23254: IFFALSE 23285
// if GetSex ( i ) = sex_male then
23256: LD_VAR 0 1
23260: PPUSH
23261: CALL_OW 258
23265: PUSH
23266: LD_INT 1
23268: EQUAL
23269: IFFALSE 23283
// begin tmp = i ;
23271: LD_ADDR_VAR 0 2
23275: PUSH
23276: LD_VAR 0 1
23280: ST_TO_ADDR
// break ;
23281: GO 23285
// end ;
23283: GO 23253
23285: POP
23286: POP
// if tmp = 0 then
23287: LD_VAR 0 2
23291: PUSH
23292: LD_INT 0
23294: EQUAL
23295: IFFALSE 23349
// begin uc_side = 3 ;
23297: LD_ADDR_OWVAR 20
23301: PUSH
23302: LD_INT 3
23304: ST_TO_ADDR
// uc_nation = 3 ;
23305: LD_ADDR_OWVAR 21
23309: PUSH
23310: LD_INT 3
23312: ST_TO_ADDR
// hc_name =  ;
23313: LD_ADDR_OWVAR 26
23317: PUSH
23318: LD_STRING 
23320: ST_TO_ADDR
// hc_gallery =  ;
23321: LD_ADDR_OWVAR 33
23325: PUSH
23326: LD_STRING 
23328: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
23329: LD_INT 1
23331: PPUSH
23332: LD_INT 10
23334: PPUSH
23335: CALL_OW 381
// tmp = CreateHuman ;
23339: LD_ADDR_VAR 0 2
23343: PUSH
23344: CALL_OW 44
23348: ST_TO_ADDR
// end ; DialogueOn ;
23349: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
23353: LD_VAR 0 2
23357: PPUSH
23358: LD_STRING DSurrenderRussians-RSol1-1a
23360: PPUSH
23361: CALL_OW 88
// DialogueOff ;
23365: CALL_OW 7
// russianDestroyed := true ;
23369: LD_ADDR_EXP 21
23373: PUSH
23374: LD_INT 1
23376: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
23377: LD_INT 22
23379: PUSH
23380: LD_INT 3
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: PUSH
23387: LD_INT 21
23389: PUSH
23390: LD_INT 1
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: PUSH
23397: EMPTY
23398: LIST
23399: LIST
23400: PPUSH
23401: CALL_OW 69
23405: PPUSH
23406: CALL_OW 122
// wait ( 0 0$1 ) ;
23410: LD_INT 35
23412: PPUSH
23413: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
23417: LD_INT 22
23419: PUSH
23420: LD_INT 3
23422: PUSH
23423: EMPTY
23424: LIST
23425: LIST
23426: PUSH
23427: LD_INT 21
23429: PUSH
23430: LD_INT 1
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_INT 25
23448: PPUSH
23449: CALL_OW 173
// wait ( 0 0$10 ) ;
23453: LD_INT 350
23455: PPUSH
23456: CALL_OW 67
// PrepareOmarInvasion ;
23460: CALL 9579 0 0
// end ;
23464: PPOPN 3
23466: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
23467: LD_INT 22
23469: PUSH
23470: LD_INT 3
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 21
23479: PUSH
23480: LD_INT 1
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: PPUSH
23491: CALL_OW 69
23495: PUSH
23496: LD_EXP 21
23500: AND
23501: IFFALSE 23569
23503: GO 23505
23505: DISABLE
23506: LD_INT 0
23508: PPUSH
23509: PPUSH
// begin enable ;
23510: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
23511: LD_ADDR_VAR 0 2
23515: PUSH
23516: LD_INT 25
23518: PPUSH
23519: LD_INT 22
23521: PUSH
23522: LD_INT 3
23524: PUSH
23525: EMPTY
23526: LIST
23527: LIST
23528: PPUSH
23529: CALL_OW 70
23533: ST_TO_ADDR
// if not tmp then
23534: LD_VAR 0 2
23538: NOT
23539: IFFALSE 23543
// exit ;
23541: GO 23569
// for i in tmp do
23543: LD_ADDR_VAR 0 1
23547: PUSH
23548: LD_VAR 0 2
23552: PUSH
23553: FOR_IN
23554: IFFALSE 23567
// RemoveUnit ( i ) ;
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 64
23565: GO 23553
23567: POP
23568: POP
// end ;
23569: PPOPN 2
23571: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 5 do var tmp , i ;
23572: LD_INT 22
23574: PUSH
23575: LD_INT 7
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: PUSH
23582: LD_INT 21
23584: PUSH
23585: LD_INT 1
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: PPUSH
23596: CALL_OW 69
23600: PUSH
23601: LD_INT 5
23603: LESS
23604: IFFALSE 23975
23606: GO 23608
23608: DISABLE
23609: LD_INT 0
23611: PPUSH
23612: PPUSH
// begin MC_Kill ( 1 ) ;
23613: LD_INT 1
23615: PPUSH
23616: CALL 26192 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
23620: LD_INT 7
23622: PPUSH
23623: LD_INT 1
23625: PPUSH
23626: LD_INT 1
23628: PPUSH
23629: LD_INT 1
23631: PPUSH
23632: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
23636: LD_ADDR_VAR 0 1
23640: PUSH
23641: LD_INT 22
23643: PUSH
23644: LD_INT 7
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: PUSH
23651: LD_INT 26
23653: PUSH
23654: LD_INT 1
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PPUSH
23665: CALL_OW 69
23669: PUSH
23670: LD_EXP 69
23674: DIFF
23675: ST_TO_ADDR
// if tmp then
23676: LD_VAR 0 1
23680: IFFALSE 23698
// tmp := tmp [ 1 ] else
23682: LD_ADDR_VAR 0 1
23686: PUSH
23687: LD_VAR 0 1
23691: PUSH
23692: LD_INT 1
23694: ARRAY
23695: ST_TO_ADDR
23696: GO 23734
// begin uc_side := 7 ;
23698: LD_ADDR_OWVAR 20
23702: PUSH
23703: LD_INT 7
23705: ST_TO_ADDR
// uc_nation := 1 ;
23706: LD_ADDR_OWVAR 21
23710: PUSH
23711: LD_INT 1
23713: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
23714: LD_INT 1
23716: PPUSH
23717: LD_INT 8
23719: PPUSH
23720: CALL_OW 384
// tmp := CreateHuman ;
23724: LD_ADDR_VAR 0 1
23728: PUSH
23729: CALL_OW 44
23733: ST_TO_ADDR
// end ; DialogueOn ;
23734: CALL_OW 6
// if IsOK ( Roth ) then
23738: LD_EXP 69
23742: PPUSH
23743: CALL_OW 302
23747: IFFALSE 23761
// Say ( JMM , DAb-JMM-1 ) ;
23749: LD_EXP 34
23753: PPUSH
23754: LD_STRING DAb-JMM-1
23756: PPUSH
23757: CALL_OW 88
// if IsOK ( Roth ) then
23761: LD_EXP 69
23765: PPUSH
23766: CALL_OW 302
23770: IFFALSE 23794
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
23772: LD_EXP 69
23776: PPUSH
23777: LD_STRING DSurrenderAlliance-Roth-1
23779: PPUSH
23780: CALL_OW 88
// RothCaptured := true ;
23784: LD_ADDR_EXP 33
23788: PUSH
23789: LD_INT 1
23791: ST_TO_ADDR
// end else
23792: GO 23806
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
23794: LD_VAR 0 1
23798: PPUSH
23799: LD_STRING DSurrenderAlliance-Sci1-1
23801: PPUSH
23802: CALL_OW 88
// DialogueOff ;
23806: CALL_OW 7
// allianceDestroyed := true ;
23810: LD_ADDR_EXP 23
23814: PUSH
23815: LD_INT 1
23817: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23818: LD_INT 35
23820: PPUSH
23821: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
23825: LD_ADDR_VAR 0 2
23829: PUSH
23830: LD_INT 22
23832: PUSH
23833: LD_INT 7
23835: PUSH
23836: EMPTY
23837: LIST
23838: LIST
23839: PUSH
23840: LD_INT 21
23842: PUSH
23843: LD_INT 1
23845: PUSH
23846: EMPTY
23847: LIST
23848: LIST
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: PPUSH
23854: CALL_OW 69
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23942
// begin if IsInUnit ( i ) then
23862: LD_VAR 0 2
23866: PPUSH
23867: CALL_OW 310
23871: IFFALSE 23882
// ComExitBuilding ( i ) ;
23873: LD_VAR 0 2
23877: PPUSH
23878: CALL_OW 122
// if IsDriver ( i ) then
23882: LD_VAR 0 2
23886: PPUSH
23887: CALL 93883 0 1
23891: IFFALSE 23902
// ComExitVehicle ( i ) ;
23893: LD_VAR 0 2
23897: PPUSH
23898: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
23902: LD_VAR 0 2
23906: PPUSH
23907: LD_INT 26
23909: PPUSH
23910: CALL_OW 308
23914: NOT
23915: IFFALSE 23931
// AddComMoveToArea ( i , allianceEscapeArea ) else
23917: LD_VAR 0 2
23921: PPUSH
23922: LD_INT 26
23924: PPUSH
23925: CALL_OW 173
23929: GO 23940
// RemoveUnit ( i ) ;
23931: LD_VAR 0 2
23935: PPUSH
23936: CALL_OW 64
// end ;
23940: GO 23859
23942: POP
23943: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
23944: LD_INT 22
23946: PUSH
23947: LD_INT 7
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: LD_INT 21
23956: PUSH
23957: LD_INT 1
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PPUSH
23968: CALL_OW 69
23972: NOT
23973: IFFALSE 23818
// end ;
23975: PPOPN 2
23977: END
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
23978: LD_EXP 15
23982: PUSH
23983: LD_INT 13
23985: GREATEREQUAL
23986: PUSH
23987: LD_INT 22
23989: PUSH
23990: LD_INT 2
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: PUSH
23997: LD_INT 21
23999: PUSH
24000: LD_INT 1
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PPUSH
24011: CALL_OW 69
24015: PUSH
24016: LD_INT 0
24018: EQUAL
24019: AND
24020: PUSH
24021: LD_INT 22
24023: PUSH
24024: LD_INT 2
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: PUSH
24031: LD_INT 21
24033: PUSH
24034: LD_INT 2
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: PUSH
24041: LD_INT 50
24043: PUSH
24044: EMPTY
24045: LIST
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: LIST
24051: PPUSH
24052: CALL_OW 69
24056: PUSH
24057: LD_INT 0
24059: EQUAL
24060: AND
24061: PUSH
24062: LD_EXP 21
24066: AND
24067: PUSH
24068: LD_EXP 22
24072: AND
24073: PUSH
24074: LD_EXP 23
24078: AND
24079: IFFALSE 24560
24081: GO 24083
24083: DISABLE
// begin DialogueOn ;
24084: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
24088: LD_EXP 34
24092: PPUSH
24093: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
24097: LD_EXP 34
24101: PPUSH
24102: LD_STRING D20-JMM-1
24104: PPUSH
24105: CALL_OW 88
// if IsOK ( Joan ) then
24109: LD_EXP 35
24113: PPUSH
24114: CALL_OW 302
24118: IFFALSE 24132
// Say ( Joan , D20-Joan-1 ) ;
24120: LD_EXP 35
24124: PPUSH
24125: LD_STRING D20-Joan-1
24127: PPUSH
24128: CALL_OW 88
// if IsOk ( Lisa ) then
24132: LD_EXP 37
24136: PPUSH
24137: CALL_OW 302
24141: IFFALSE 24155
// Say ( Lisa , D20-Lisa-1 ) ;
24143: LD_EXP 37
24147: PPUSH
24148: LD_STRING D20-Lisa-1
24150: PPUSH
24151: CALL_OW 88
// if IsOk ( Donaldson ) then
24155: LD_EXP 38
24159: PPUSH
24160: CALL_OW 302
24164: IFFALSE 24178
// Say ( Donaldson , D20-Don-1 ) ;
24166: LD_EXP 38
24170: PPUSH
24171: LD_STRING D20-Don-1
24173: PPUSH
24174: CALL_OW 88
// if IsOK ( Cornel ) then
24178: LD_EXP 45
24182: PPUSH
24183: CALL_OW 302
24187: IFFALSE 24201
// Say ( Cornel , D20-Corn-1 ) ;
24189: LD_EXP 45
24193: PPUSH
24194: LD_STRING D20-Corn-1
24196: PPUSH
24197: CALL_OW 88
// if IsOk ( Denis ) then
24201: LD_EXP 41
24205: PPUSH
24206: CALL_OW 302
24210: IFFALSE 24224
// Say ( Denis , D20-Den-1 ) ;
24212: LD_EXP 41
24216: PPUSH
24217: LD_STRING D20-Den-1
24219: PPUSH
24220: CALL_OW 88
// if IsOk ( Bobby ) then
24224: LD_EXP 39
24228: PPUSH
24229: CALL_OW 302
24233: IFFALSE 24247
// Say ( Bobby , D20-Bobby-1 ) ;
24235: LD_EXP 39
24239: PPUSH
24240: LD_STRING D20-Bobby-1
24242: PPUSH
24243: CALL_OW 88
// if IsOk ( Gladstone ) then
24247: LD_EXP 43
24251: PPUSH
24252: CALL_OW 302
24256: IFFALSE 24270
// Say ( Gladstone , D20-Glad-1 ) ;
24258: LD_EXP 43
24262: PPUSH
24263: LD_STRING D20-Glad-1
24265: PPUSH
24266: CALL_OW 88
// if IsOk ( Cyrus ) then
24270: LD_EXP 40
24274: PPUSH
24275: CALL_OW 302
24279: IFFALSE 24293
// Say ( Cyrus , D20-Cyrus-1 ) ;
24281: LD_EXP 40
24285: PPUSH
24286: LD_STRING D20-Cyrus-1
24288: PPUSH
24289: CALL_OW 88
// if IsOk ( Stevens ) then
24293: LD_EXP 36
24297: PPUSH
24298: CALL_OW 302
24302: IFFALSE 24316
// Say ( Stevens , D20-Huck-1 ) ;
24304: LD_EXP 36
24308: PPUSH
24309: LD_STRING D20-Huck-1
24311: PPUSH
24312: CALL_OW 88
// if IsOk ( Brown ) then
24316: LD_EXP 42
24320: PPUSH
24321: CALL_OW 302
24325: IFFALSE 24339
// Say ( Brown , D20-Brown-1 ) ;
24327: LD_EXP 42
24331: PPUSH
24332: LD_STRING D20-Brown-1
24334: PPUSH
24335: CALL_OW 88
// if IsOk ( Gary ) then
24339: LD_EXP 46
24343: PPUSH
24344: CALL_OW 302
24348: IFFALSE 24362
// Say ( Gary , D20-Gary-1 ) ;
24350: LD_EXP 46
24354: PPUSH
24355: LD_STRING D20-Gary-1
24357: PPUSH
24358: CALL_OW 88
// if IsOk ( Connie ) then
24362: LD_EXP 49
24366: PPUSH
24367: CALL_OW 302
24371: IFFALSE 24385
// Say ( Connie , D20-Con-1 ) ;
24373: LD_EXP 49
24377: PPUSH
24378: LD_STRING D20-Con-1
24380: PPUSH
24381: CALL_OW 88
// if IsOk ( Kurt ) then
24385: LD_EXP 55
24389: PPUSH
24390: CALL_OW 302
24394: IFFALSE 24408
// Say ( Kurt , D20-Kurt-1 ) ;
24396: LD_EXP 55
24400: PPUSH
24401: LD_STRING D20-Kurt-1
24403: PPUSH
24404: CALL_OW 88
// if IsOk ( Kikuchi ) then
24408: LD_EXP 48
24412: PPUSH
24413: CALL_OW 302
24417: IFFALSE 24431
// Say ( Kikuchi , D20-Yam-1 ) ;
24419: LD_EXP 48
24423: PPUSH
24424: LD_STRING D20-Yam-1
24426: PPUSH
24427: CALL_OW 88
// if IsOk ( Frank ) then
24431: LD_EXP 47
24435: PPUSH
24436: CALL_OW 302
24440: IFFALSE 24454
// Say ( Frank , D20-Frank-1 ) ;
24442: LD_EXP 47
24446: PPUSH
24447: LD_STRING D20-Frank-1
24449: PPUSH
24450: CALL_OW 88
// DialogueOff ;
24454: CALL_OW 7
// if RothCaptured then
24458: LD_EXP 33
24462: IFFALSE 24476
// AddMedal ( Roth , 1 ) else
24464: LD_STRING Roth
24466: PPUSH
24467: LD_INT 1
24469: PPUSH
24470: CALL_OW 101
24474: GO 24487
// AddMedal ( Roth , - 1 ) ;
24476: LD_STRING Roth
24478: PPUSH
24479: LD_INT 1
24481: NEG
24482: PPUSH
24483: CALL_OW 101
// if behemothDestroyedBeforeFinish then
24487: LD_EXP 27
24491: IFFALSE 24505
// AddMedal ( Project , 1 ) else
24493: LD_STRING Project
24495: PPUSH
24496: LD_INT 1
24498: PPUSH
24499: CALL_OW 101
24503: GO 24516
// AddMedal ( Project , - 1 ) ;
24505: LD_STRING Project
24507: PPUSH
24508: LD_INT 1
24510: NEG
24511: PPUSH
24512: CALL_OW 101
// if lostCounter = 0 then
24516: LD_EXP 32
24520: PUSH
24521: LD_INT 0
24523: EQUAL
24524: IFFALSE 24538
// AddMedal ( NoLosses , 1 ) else
24526: LD_STRING NoLosses
24528: PPUSH
24529: LD_INT 1
24531: PPUSH
24532: CALL_OW 101
24536: GO 24549
// AddMedal ( NoLosses , - 1 ) ;
24538: LD_STRING NoLosses
24540: PPUSH
24541: LD_INT 1
24543: NEG
24544: PPUSH
24545: CALL_OW 101
// GiveMedals ( MAIN ) ;
24549: LD_STRING MAIN
24551: PPUSH
24552: CALL_OW 102
// YouWin ;
24556: CALL_OW 103
// end ; end_of_file
24560: END
// export function CustomEvent ( event ) ; begin
24561: LD_INT 0
24563: PPUSH
// end ;
24564: LD_VAR 0 2
24568: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
24569: LD_VAR 0 1
24573: PUSH
24574: LD_INT 1
24576: EQUAL
24577: PUSH
24578: LD_VAR 0 2
24582: PUSH
24583: LD_INT 4
24585: EQUAL
24586: AND
24587: PUSH
24588: LD_EXP 53
24592: PPUSH
24593: CALL_OW 300
24597: AND
24598: IFFALSE 24614
// begin wait ( 0 0$2 ) ;
24600: LD_INT 70
24602: PPUSH
24603: CALL_OW 67
// YouLost ( Dismissed ) ;
24607: LD_STRING Dismissed
24609: PPUSH
24610: CALL_OW 104
// end ; end ;
24614: PPOPN 2
24616: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
24617: LD_EXP 27
24621: NOT
24622: IFFALSE 24632
// behemothDone := true ;
24624: LD_ADDR_EXP 28
24628: PUSH
24629: LD_INT 1
24631: ST_TO_ADDR
// end ;
24632: PPOPN 1
24634: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
24635: LD_VAR 0 2
24639: PPUSH
24640: LD_VAR 0 3
24644: PPUSH
24645: LD_INT 18
24647: PPUSH
24648: CALL_OW 309
24652: IFFALSE 24712
// begin if GetSide ( unit ) = 1 then
24654: LD_VAR 0 1
24658: PPUSH
24659: CALL_OW 255
24663: PUSH
24664: LD_INT 1
24666: EQUAL
24667: IFFALSE 24683
// begin wait ( 0 0$6 ) ;
24669: LD_INT 210
24671: PPUSH
24672: CALL_OW 67
// YouLost ( Motherlode2 ) ;
24676: LD_STRING Motherlode2
24678: PPUSH
24679: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
24683: LD_VAR 0 1
24687: PPUSH
24688: CALL_OW 255
24692: PUSH
24693: LD_INT 8
24695: EQUAL
24696: IFFALSE 24712
// begin wait ( 0 0$6 ) ;
24698: LD_INT 210
24700: PPUSH
24701: CALL_OW 67
// YouLost ( Motherlode1 ) ;
24705: LD_STRING Motherlode1
24707: PPUSH
24708: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
24712: LD_VAR 0 1
24716: PPUSH
24717: CALL_OW 255
24721: PUSH
24722: LD_INT 3
24724: EQUAL
24725: IFFALSE 24746
// begin wait ( 0 0$5 ) ;
24727: LD_INT 175
24729: PPUSH
24730: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
24734: LD_EXP 59
24738: PPUSH
24739: LD_STRING D18-Pla-1
24741: PPUSH
24742: CALL_OW 94
// end ; end ;
24746: PPOPN 3
24748: END
// on SibDepositContaminated ( unit , x , y ) do begin if GetSide ( unit ) = 2 then
24749: LD_VAR 0 1
24753: PPUSH
24754: CALL_OW 255
24758: PUSH
24759: LD_INT 2
24761: EQUAL
24762: IFFALSE 24771
// YouLost ( Motherlode3 ) ;
24764: LD_STRING Motherlode3
24766: PPUSH
24767: CALL_OW 104
// end ;
24771: PPOPN 3
24773: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
24774: LD_VAR 0 1
24778: PUSH
24779: LD_EXP 68
24783: IN
24784: IFFALSE 24804
// begin behemothBuilders := behemothBuilders diff un ;
24786: LD_ADDR_EXP 68
24790: PUSH
24791: LD_EXP 68
24795: PUSH
24796: LD_VAR 0 1
24800: DIFF
24801: ST_TO_ADDR
// exit ;
24802: GO 24902
// end ; if un = JMM then
24804: LD_VAR 0 1
24808: PUSH
24809: LD_EXP 34
24813: EQUAL
24814: IFFALSE 24825
// begin YouLost ( JMM ) ;
24816: LD_STRING JMM
24818: PPUSH
24819: CALL_OW 104
// exit ;
24823: GO 24902
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
24825: LD_VAR 0 1
24829: PUSH
24830: LD_INT 22
24832: PUSH
24833: LD_INT 1
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 3
24842: PUSH
24843: LD_INT 25
24845: PUSH
24846: LD_INT 16
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: LD_INT 25
24855: PUSH
24856: LD_INT 12
24858: PUSH
24859: EMPTY
24860: LIST
24861: LIST
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: LIST
24867: PUSH
24868: EMPTY
24869: LIST
24870: LIST
24871: PPUSH
24872: CALL_OW 69
24876: IN
24877: IFFALSE 24893
// lostCounter := lostCounter + 1 ;
24879: LD_ADDR_EXP 32
24883: PUSH
24884: LD_EXP 32
24888: PUSH
24889: LD_INT 1
24891: PLUS
24892: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
24893: LD_VAR 0 1
24897: PPUSH
24898: CALL 51319 0 1
// end ;
24902: PPOPN 1
24904: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
24905: LD_VAR 0 1
24909: PPUSH
24910: LD_VAR 0 2
24914: PPUSH
24915: CALL 53225 0 2
// end ;
24919: PPOPN 2
24921: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
24922: LD_VAR 0 1
24926: PPUSH
24927: CALL 52293 0 1
// end ;
24931: PPOPN 1
24933: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
24934: LD_VAR 0 1
24938: PUSH
24939: LD_INT 22
24941: PUSH
24942: LD_INT 8
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PUSH
24949: LD_INT 30
24951: PUSH
24952: LD_INT 2
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: PUSH
24959: LD_INT 23
24961: PUSH
24962: LD_INT 3
24964: PUSH
24965: EMPTY
24966: LIST
24967: LIST
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: LIST
24973: PPUSH
24974: CALL_OW 69
24978: IN
24979: IFFALSE 25006
// begin ComUpgrade ( building ) ;
24981: LD_VAR 0 1
24985: PPUSH
24986: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
24990: LD_EXP 56
24994: PPUSH
24995: LD_VAR 0 1
24999: PPUSH
25000: CALL 63449 0 2
// exit ;
25004: GO 25015
// end ; MCE_BuildingComplete ( building ) ;
25006: LD_VAR 0 1
25010: PPUSH
25011: CALL 52534 0 1
// end ;
25015: PPOPN 1
25017: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
25018: LD_VAR 0 1
25022: PPUSH
25023: LD_VAR 0 2
25027: PPUSH
25028: CALL 51015 0 2
// end ;
25032: PPOPN 2
25034: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
25035: LD_VAR 0 1
25039: PPUSH
25040: LD_VAR 0 2
25044: PPUSH
25045: LD_VAR 0 3
25049: PPUSH
25050: LD_VAR 0 4
25054: PPUSH
25055: LD_VAR 0 5
25059: PPUSH
25060: CALL 50635 0 5
// end ;
25064: PPOPN 5
25066: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
25067: LD_VAR 0 1
25071: PPUSH
25072: LD_VAR 0 2
25076: PPUSH
25077: CALL 50225 0 2
// end ;
25081: PPOPN 2
25083: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
25084: LD_VAR 0 1
25088: PPUSH
25089: LD_VAR 0 2
25093: PPUSH
25094: LD_VAR 0 3
25098: PPUSH
25099: LD_VAR 0 4
25103: PPUSH
25104: CALL 50063 0 4
// end ;
25108: PPOPN 4
25110: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
25111: LD_VAR 0 1
25115: PPUSH
25116: LD_VAR 0 2
25120: PPUSH
25121: LD_VAR 0 3
25125: PPUSH
25126: CALL 49838 0 3
// end ;
25130: PPOPN 3
25132: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
25133: LD_VAR 0 1
25137: PPUSH
25138: LD_VAR 0 2
25142: PPUSH
25143: CALL 49723 0 2
// end ;
25147: PPOPN 2
25149: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
25150: LD_VAR 0 1
25154: PPUSH
25155: LD_VAR 0 2
25159: PPUSH
25160: CALL 53486 0 2
// end ;
25164: PPOPN 2
25166: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
25167: LD_VAR 0 1
25171: PPUSH
25172: CALL_OW 255
25176: PUSH
25177: LD_INT 4
25179: EQUAL
25180: PUSH
25181: LD_VAR 0 1
25185: PUSH
25186: LD_EXP 18
25190: PUSH
25191: LD_INT 1
25193: ARRAY
25194: IN
25195: AND
25196: PUSH
25197: LD_EXP 19
25201: AND
25202: IFFALSE 25221
// begin ComMoveXY ( driver , 61 , 93 ) ;
25204: LD_VAR 0 1
25208: PPUSH
25209: LD_INT 61
25211: PPUSH
25212: LD_INT 93
25214: PPUSH
25215: CALL_OW 111
// exit ;
25219: GO 25245
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
25221: LD_VAR 0 1
25225: PPUSH
25226: LD_VAR 0 2
25230: PPUSH
25231: LD_VAR 0 3
25235: PPUSH
25236: LD_VAR 0 4
25240: PPUSH
25241: CALL 53702 0 4
// end ;
25245: PPOPN 4
25247: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
25248: LD_VAR 0 1
25252: PPUSH
25253: LD_VAR 0 2
25257: PPUSH
25258: CALL 49532 0 2
// end ; end_of_file
25262: PPOPN 2
25264: END
// every 0 0$30 trigger missionStage = 2 do var time ;
25265: LD_EXP 15
25269: PUSH
25270: LD_INT 2
25272: EQUAL
25273: IFFALSE 25726
25275: GO 25277
25277: DISABLE
25278: LD_INT 0
25280: PPUSH
// begin time := 0 0$30 ;
25281: LD_ADDR_VAR 0 1
25285: PUSH
25286: LD_INT 1050
25288: ST_TO_ADDR
// repeat wait ( time ) ;
25289: LD_VAR 0 1
25293: PPUSH
25294: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
25298: LD_INT 1
25300: PPUSH
25301: LD_INT 5
25303: PPUSH
25304: CALL_OW 12
25308: PPUSH
25309: LD_INT 106
25311: PPUSH
25312: LD_INT 150
25314: PPUSH
25315: LD_INT 19
25317: PPUSH
25318: LD_INT 1
25320: PPUSH
25321: CALL_OW 56
// time := time + 0 0$9 ;
25325: LD_ADDR_VAR 0 1
25329: PUSH
25330: LD_VAR 0 1
25334: PUSH
25335: LD_INT 315
25337: PLUS
25338: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$21 ) ) ;
25339: LD_INT 455
25341: PPUSH
25342: LD_INT 735
25344: PPUSH
25345: CALL_OW 12
25349: PPUSH
25350: CALL_OW 67
// if Prob ( 50 ) then
25354: LD_INT 50
25356: PPUSH
25357: CALL_OW 13
25361: IFFALSE 25390
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
25363: LD_INT 1
25365: PPUSH
25366: LD_INT 5
25368: PPUSH
25369: CALL_OW 12
25373: PPUSH
25374: LD_INT 62
25376: PPUSH
25377: LD_INT 108
25379: PPUSH
25380: LD_INT 10
25382: PPUSH
25383: LD_INT 1
25385: PPUSH
25386: CALL_OW 56
// until missionStage > 4 ;
25390: LD_EXP 15
25394: PUSH
25395: LD_INT 4
25397: GREATER
25398: IFFALSE 25289
// repeat wait ( 0 0$1 ) ;
25400: LD_INT 35
25402: PPUSH
25403: CALL_OW 67
// until missionStage = 6 ;
25407: LD_EXP 15
25411: PUSH
25412: LD_INT 6
25414: EQUAL
25415: IFFALSE 25400
// time := 0 0$40 ;
25417: LD_ADDR_VAR 0 1
25421: PUSH
25422: LD_INT 1400
25424: ST_TO_ADDR
// repeat wait ( time ) ;
25425: LD_VAR 0 1
25429: PPUSH
25430: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 35 , true ) ;
25434: LD_INT 1
25436: PPUSH
25437: LD_INT 5
25439: PPUSH
25440: CALL_OW 12
25444: PPUSH
25445: LD_INT 106
25447: PPUSH
25448: LD_INT 89
25450: PPUSH
25451: LD_INT 35
25453: PPUSH
25454: LD_INT 1
25456: PPUSH
25457: CALL_OW 56
// time := time + 0 0$3 ;
25461: LD_ADDR_VAR 0 1
25465: PUSH
25466: LD_VAR 0 1
25470: PUSH
25471: LD_INT 105
25473: PLUS
25474: ST_TO_ADDR
// if Prob ( 30 ) then
25475: LD_INT 30
25477: PPUSH
25478: CALL_OW 13
25482: IFFALSE 25528
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
25484: LD_INT 525
25486: PPUSH
25487: LD_INT 735
25489: PPUSH
25490: CALL_OW 12
25494: PPUSH
25495: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
25499: LD_INT 1
25501: PPUSH
25502: LD_INT 5
25504: PPUSH
25505: CALL_OW 12
25509: PPUSH
25510: LD_INT 21
25512: PPUSH
25513: LD_INT 26
25515: PPUSH
25516: LD_INT 12
25518: PPUSH
25519: LD_INT 1
25521: PPUSH
25522: CALL_OW 56
// end else
25526: GO 25564
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
25528: LD_INT 700
25530: PPUSH
25531: LD_INT 1225
25533: PPUSH
25534: CALL_OW 12
25538: PPUSH
25539: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
25543: LD_INT 1
25545: PPUSH
25546: LD_INT 5
25548: PPUSH
25549: CALL_OW 12
25553: PPUSH
25554: LD_INT 16
25556: PPUSH
25557: LD_INT 1
25559: PPUSH
25560: CALL_OW 55
// end ; if Prob ( 50 ) then
25564: LD_INT 50
25566: PPUSH
25567: CALL_OW 13
25571: IFFALSE 25617
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
25573: LD_INT 700
25575: PPUSH
25576: LD_INT 1050
25578: PPUSH
25579: CALL_OW 12
25583: PPUSH
25584: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
25588: LD_INT 1
25590: PPUSH
25591: LD_INT 5
25593: PPUSH
25594: CALL_OW 12
25598: PPUSH
25599: LD_INT 181
25601: PPUSH
25602: LD_INT 218
25604: PPUSH
25605: LD_INT 16
25607: PPUSH
25608: LD_INT 1
25610: PPUSH
25611: CALL_OW 56
// end else
25615: GO 25653
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
25617: LD_INT 350
25619: PPUSH
25620: LD_INT 525
25622: PPUSH
25623: CALL_OW 12
25627: PPUSH
25628: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
25632: LD_INT 1
25634: PPUSH
25635: LD_INT 5
25637: PPUSH
25638: CALL_OW 12
25642: PPUSH
25643: LD_INT 15
25645: PPUSH
25646: LD_INT 1
25648: PPUSH
25649: CALL_OW 55
// end ; if Prob ( 45 ) then
25653: LD_INT 45
25655: PPUSH
25656: CALL_OW 13
25660: IFFALSE 25704
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
25662: LD_INT 525
25664: PPUSH
25665: LD_INT 875
25667: PPUSH
25668: CALL_OW 12
25672: PPUSH
25673: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 5
25682: PPUSH
25683: CALL_OW 12
25687: PPUSH
25688: LD_INT 103
25690: PPUSH
25691: LD_INT 140
25693: PPUSH
25694: LD_INT 20
25696: PPUSH
25697: LD_INT 1
25699: PPUSH
25700: CALL_OW 56
// end ; if time > 2 2$20 then
25704: LD_VAR 0 1
25708: PUSH
25709: LD_INT 4900
25711: GREATER
25712: IFFALSE 25722
// time := 0 0$40 ;
25714: LD_ADDR_VAR 0 1
25718: PUSH
25719: LD_INT 1400
25721: ST_TO_ADDR
// until false ;
25722: LD_INT 0
25724: IFFALSE 25425
// end ; end_of_file
25726: PPOPN 1
25728: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
25729: LD_EXP 13
25733: PUSH
25734: LD_EXP 15
25738: PUSH
25739: LD_INT 6
25741: GREATEREQUAL
25742: AND
25743: IFFALSE 25780
25745: GO 25747
25747: DISABLE
// begin enable ;
25748: ENABLE
// missionTime := missionTime + 0 0$1 ;
25749: LD_ADDR_EXP 14
25753: PUSH
25754: LD_EXP 14
25758: PUSH
25759: LD_INT 35
25761: PLUS
25762: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
25763: LD_ADDR_OWVAR 47
25767: PUSH
25768: LD_STRING #Am15-1
25770: PUSH
25771: LD_EXP 14
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: ST_TO_ADDR
// end ; end_of_file
25780: END
// export function InitNature ; begin
25781: LD_INT 0
25783: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
25784: LD_INT 3
25786: PPUSH
25787: LD_INT 3
25789: PPUSH
25790: LD_INT 2
25792: PPUSH
25793: LD_INT 1
25795: PPUSH
25796: LD_INT 1
25798: PPUSH
25799: LD_INT 0
25801: PPUSH
25802: LD_INT 0
25804: PPUSH
25805: LD_INT 20
25807: PPUSH
25808: LD_INT 0
25810: PPUSH
25811: CALL 88266 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
25815: LD_INT 2
25817: PPUSH
25818: LD_INT 1
25820: PPUSH
25821: LD_INT 1
25823: PPUSH
25824: LD_INT 1
25826: PPUSH
25827: LD_INT 1
25829: PPUSH
25830: LD_INT 0
25832: PPUSH
25833: LD_INT 0
25835: PPUSH
25836: LD_INT 21
25838: PPUSH
25839: LD_INT 0
25841: PPUSH
25842: CALL 88266 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
25846: LD_INT 4
25848: PPUSH
25849: LD_INT 1
25851: PPUSH
25852: LD_INT 2
25854: PPUSH
25855: LD_INT 4
25857: PPUSH
25858: LD_INT 2
25860: PPUSH
25861: LD_INT 1
25863: PPUSH
25864: LD_INT 0
25866: PPUSH
25867: LD_INT 22
25869: PPUSH
25870: LD_INT 0
25872: PPUSH
25873: CALL 88266 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
25877: LD_INT 0
25879: PPUSH
25880: LD_INT 0
25882: PPUSH
25883: LD_INT 0
25885: PPUSH
25886: LD_INT 0
25888: PPUSH
25889: LD_INT 0
25891: PPUSH
25892: LD_INT 0
25894: PPUSH
25895: LD_INT 9
25897: PPUSH
25898: LD_INT 0
25900: PPUSH
25901: LD_INT 23
25903: PPUSH
25904: CALL 88266 0 9
// end ; end_of_file
25908: LD_VAR 0 1
25912: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
25913: GO 25915
25915: DISABLE
// begin ru_radar := 98 ;
25916: LD_ADDR_EXP 86
25920: PUSH
25921: LD_INT 98
25923: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
25924: LD_ADDR_EXP 87
25928: PUSH
25929: LD_INT 89
25931: ST_TO_ADDR
// us_hack := 99 ;
25932: LD_ADDR_EXP 88
25936: PUSH
25937: LD_INT 99
25939: ST_TO_ADDR
// us_artillery := 97 ;
25940: LD_ADDR_EXP 89
25944: PUSH
25945: LD_INT 97
25947: ST_TO_ADDR
// ar_bio_bomb := 91 ;
25948: LD_ADDR_EXP 90
25952: PUSH
25953: LD_INT 91
25955: ST_TO_ADDR
// end ; end_of_file
25956: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
25957: LD_INT 0
25959: PPUSH
25960: PPUSH
// skirmish := false ;
25961: LD_ADDR_EXP 91
25965: PUSH
25966: LD_INT 0
25968: ST_TO_ADDR
// debug_mc := false ;
25969: LD_ADDR_EXP 92
25973: PUSH
25974: LD_INT 0
25976: ST_TO_ADDR
// mc_bases := [ ] ;
25977: LD_ADDR_EXP 93
25981: PUSH
25982: EMPTY
25983: ST_TO_ADDR
// mc_sides := [ ] ;
25984: LD_ADDR_EXP 119
25988: PUSH
25989: EMPTY
25990: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
25991: LD_ADDR_EXP 94
25995: PUSH
25996: EMPTY
25997: ST_TO_ADDR
// mc_building_repairs := [ ] ;
25998: LD_ADDR_EXP 95
26002: PUSH
26003: EMPTY
26004: ST_TO_ADDR
// mc_need_heal := [ ] ;
26005: LD_ADDR_EXP 96
26009: PUSH
26010: EMPTY
26011: ST_TO_ADDR
// mc_healers := [ ] ;
26012: LD_ADDR_EXP 97
26016: PUSH
26017: EMPTY
26018: ST_TO_ADDR
// mc_build_list := [ ] ;
26019: LD_ADDR_EXP 98
26023: PUSH
26024: EMPTY
26025: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
26026: LD_ADDR_EXP 125
26030: PUSH
26031: EMPTY
26032: ST_TO_ADDR
// mc_builders := [ ] ;
26033: LD_ADDR_EXP 99
26037: PUSH
26038: EMPTY
26039: ST_TO_ADDR
// mc_construct_list := [ ] ;
26040: LD_ADDR_EXP 100
26044: PUSH
26045: EMPTY
26046: ST_TO_ADDR
// mc_turret_list := [ ] ;
26047: LD_ADDR_EXP 101
26051: PUSH
26052: EMPTY
26053: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
26054: LD_ADDR_EXP 102
26058: PUSH
26059: EMPTY
26060: ST_TO_ADDR
// mc_miners := [ ] ;
26061: LD_ADDR_EXP 107
26065: PUSH
26066: EMPTY
26067: ST_TO_ADDR
// mc_mines := [ ] ;
26068: LD_ADDR_EXP 106
26072: PUSH
26073: EMPTY
26074: ST_TO_ADDR
// mc_minefields := [ ] ;
26075: LD_ADDR_EXP 108
26079: PUSH
26080: EMPTY
26081: ST_TO_ADDR
// mc_crates := [ ] ;
26082: LD_ADDR_EXP 109
26086: PUSH
26087: EMPTY
26088: ST_TO_ADDR
// mc_crates_collector := [ ] ;
26089: LD_ADDR_EXP 110
26093: PUSH
26094: EMPTY
26095: ST_TO_ADDR
// mc_crates_area := [ ] ;
26096: LD_ADDR_EXP 111
26100: PUSH
26101: EMPTY
26102: ST_TO_ADDR
// mc_vehicles := [ ] ;
26103: LD_ADDR_EXP 112
26107: PUSH
26108: EMPTY
26109: ST_TO_ADDR
// mc_attack := [ ] ;
26110: LD_ADDR_EXP 113
26114: PUSH
26115: EMPTY
26116: ST_TO_ADDR
// mc_produce := [ ] ;
26117: LD_ADDR_EXP 114
26121: PUSH
26122: EMPTY
26123: ST_TO_ADDR
// mc_defender := [ ] ;
26124: LD_ADDR_EXP 115
26128: PUSH
26129: EMPTY
26130: ST_TO_ADDR
// mc_parking := [ ] ;
26131: LD_ADDR_EXP 117
26135: PUSH
26136: EMPTY
26137: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
26138: LD_ADDR_EXP 103
26142: PUSH
26143: EMPTY
26144: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
26145: LD_ADDR_EXP 105
26149: PUSH
26150: EMPTY
26151: ST_TO_ADDR
// mc_scan := [ ] ;
26152: LD_ADDR_EXP 116
26156: PUSH
26157: EMPTY
26158: ST_TO_ADDR
// mc_scan_area := [ ] ;
26159: LD_ADDR_EXP 118
26163: PUSH
26164: EMPTY
26165: ST_TO_ADDR
// mc_tech := [ ] ;
26166: LD_ADDR_EXP 120
26170: PUSH
26171: EMPTY
26172: ST_TO_ADDR
// mc_class := [ ] ;
26173: LD_ADDR_EXP 134
26177: PUSH
26178: EMPTY
26179: ST_TO_ADDR
// mc_class_case_use := [ ] ;
26180: LD_ADDR_EXP 135
26184: PUSH
26185: EMPTY
26186: ST_TO_ADDR
// end ;
26187: LD_VAR 0 1
26191: RET
// export function MC_Kill ( base ) ; begin
26192: LD_INT 0
26194: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
26195: LD_ADDR_EXP 93
26199: PUSH
26200: LD_EXP 93
26204: PPUSH
26205: LD_VAR 0 1
26209: PPUSH
26210: EMPTY
26211: PPUSH
26212: CALL_OW 1
26216: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
26217: LD_ADDR_EXP 94
26221: PUSH
26222: LD_EXP 94
26226: PPUSH
26227: LD_VAR 0 1
26231: PPUSH
26232: EMPTY
26233: PPUSH
26234: CALL_OW 1
26238: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
26239: LD_ADDR_EXP 95
26243: PUSH
26244: LD_EXP 95
26248: PPUSH
26249: LD_VAR 0 1
26253: PPUSH
26254: EMPTY
26255: PPUSH
26256: CALL_OW 1
26260: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
26261: LD_ADDR_EXP 96
26265: PUSH
26266: LD_EXP 96
26270: PPUSH
26271: LD_VAR 0 1
26275: PPUSH
26276: EMPTY
26277: PPUSH
26278: CALL_OW 1
26282: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
26283: LD_ADDR_EXP 97
26287: PUSH
26288: LD_EXP 97
26292: PPUSH
26293: LD_VAR 0 1
26297: PPUSH
26298: EMPTY
26299: PPUSH
26300: CALL_OW 1
26304: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
26305: LD_ADDR_EXP 98
26309: PUSH
26310: LD_EXP 98
26314: PPUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: EMPTY
26321: PPUSH
26322: CALL_OW 1
26326: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
26327: LD_ADDR_EXP 99
26331: PUSH
26332: LD_EXP 99
26336: PPUSH
26337: LD_VAR 0 1
26341: PPUSH
26342: EMPTY
26343: PPUSH
26344: CALL_OW 1
26348: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
26349: LD_ADDR_EXP 100
26353: PUSH
26354: LD_EXP 100
26358: PPUSH
26359: LD_VAR 0 1
26363: PPUSH
26364: EMPTY
26365: PPUSH
26366: CALL_OW 1
26370: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
26371: LD_ADDR_EXP 101
26375: PUSH
26376: LD_EXP 101
26380: PPUSH
26381: LD_VAR 0 1
26385: PPUSH
26386: EMPTY
26387: PPUSH
26388: CALL_OW 1
26392: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
26393: LD_ADDR_EXP 102
26397: PUSH
26398: LD_EXP 102
26402: PPUSH
26403: LD_VAR 0 1
26407: PPUSH
26408: EMPTY
26409: PPUSH
26410: CALL_OW 1
26414: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
26415: LD_ADDR_EXP 103
26419: PUSH
26420: LD_EXP 103
26424: PPUSH
26425: LD_VAR 0 1
26429: PPUSH
26430: EMPTY
26431: PPUSH
26432: CALL_OW 1
26436: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
26437: LD_ADDR_EXP 104
26441: PUSH
26442: LD_EXP 104
26446: PPUSH
26447: LD_VAR 0 1
26451: PPUSH
26452: LD_INT 0
26454: PPUSH
26455: CALL_OW 1
26459: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
26460: LD_ADDR_EXP 105
26464: PUSH
26465: LD_EXP 105
26469: PPUSH
26470: LD_VAR 0 1
26474: PPUSH
26475: EMPTY
26476: PPUSH
26477: CALL_OW 1
26481: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
26482: LD_ADDR_EXP 106
26486: PUSH
26487: LD_EXP 106
26491: PPUSH
26492: LD_VAR 0 1
26496: PPUSH
26497: EMPTY
26498: PPUSH
26499: CALL_OW 1
26503: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
26504: LD_ADDR_EXP 107
26508: PUSH
26509: LD_EXP 107
26513: PPUSH
26514: LD_VAR 0 1
26518: PPUSH
26519: EMPTY
26520: PPUSH
26521: CALL_OW 1
26525: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
26526: LD_ADDR_EXP 108
26530: PUSH
26531: LD_EXP 108
26535: PPUSH
26536: LD_VAR 0 1
26540: PPUSH
26541: EMPTY
26542: PPUSH
26543: CALL_OW 1
26547: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
26548: LD_ADDR_EXP 109
26552: PUSH
26553: LD_EXP 109
26557: PPUSH
26558: LD_VAR 0 1
26562: PPUSH
26563: EMPTY
26564: PPUSH
26565: CALL_OW 1
26569: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
26570: LD_ADDR_EXP 110
26574: PUSH
26575: LD_EXP 110
26579: PPUSH
26580: LD_VAR 0 1
26584: PPUSH
26585: EMPTY
26586: PPUSH
26587: CALL_OW 1
26591: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
26592: LD_ADDR_EXP 111
26596: PUSH
26597: LD_EXP 111
26601: PPUSH
26602: LD_VAR 0 1
26606: PPUSH
26607: EMPTY
26608: PPUSH
26609: CALL_OW 1
26613: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
26614: LD_ADDR_EXP 112
26618: PUSH
26619: LD_EXP 112
26623: PPUSH
26624: LD_VAR 0 1
26628: PPUSH
26629: EMPTY
26630: PPUSH
26631: CALL_OW 1
26635: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
26636: LD_ADDR_EXP 113
26640: PUSH
26641: LD_EXP 113
26645: PPUSH
26646: LD_VAR 0 1
26650: PPUSH
26651: EMPTY
26652: PPUSH
26653: CALL_OW 1
26657: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
26658: LD_ADDR_EXP 114
26662: PUSH
26663: LD_EXP 114
26667: PPUSH
26668: LD_VAR 0 1
26672: PPUSH
26673: EMPTY
26674: PPUSH
26675: CALL_OW 1
26679: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
26680: LD_ADDR_EXP 115
26684: PUSH
26685: LD_EXP 115
26689: PPUSH
26690: LD_VAR 0 1
26694: PPUSH
26695: EMPTY
26696: PPUSH
26697: CALL_OW 1
26701: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
26702: LD_ADDR_EXP 116
26706: PUSH
26707: LD_EXP 116
26711: PPUSH
26712: LD_VAR 0 1
26716: PPUSH
26717: EMPTY
26718: PPUSH
26719: CALL_OW 1
26723: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
26724: LD_ADDR_EXP 117
26728: PUSH
26729: LD_EXP 117
26733: PPUSH
26734: LD_VAR 0 1
26738: PPUSH
26739: EMPTY
26740: PPUSH
26741: CALL_OW 1
26745: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
26746: LD_ADDR_EXP 118
26750: PUSH
26751: LD_EXP 118
26755: PPUSH
26756: LD_VAR 0 1
26760: PPUSH
26761: EMPTY
26762: PPUSH
26763: CALL_OW 1
26767: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
26768: LD_ADDR_EXP 120
26772: PUSH
26773: LD_EXP 120
26777: PPUSH
26778: LD_VAR 0 1
26782: PPUSH
26783: EMPTY
26784: PPUSH
26785: CALL_OW 1
26789: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
26790: LD_ADDR_EXP 122
26794: PUSH
26795: LD_EXP 122
26799: PPUSH
26800: LD_VAR 0 1
26804: PPUSH
26805: EMPTY
26806: PPUSH
26807: CALL_OW 1
26811: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
26812: LD_ADDR_EXP 123
26816: PUSH
26817: LD_EXP 123
26821: PPUSH
26822: LD_VAR 0 1
26826: PPUSH
26827: EMPTY
26828: PPUSH
26829: CALL_OW 1
26833: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
26834: LD_ADDR_EXP 124
26838: PUSH
26839: LD_EXP 124
26843: PPUSH
26844: LD_VAR 0 1
26848: PPUSH
26849: EMPTY
26850: PPUSH
26851: CALL_OW 1
26855: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
26856: LD_ADDR_EXP 125
26860: PUSH
26861: LD_EXP 125
26865: PPUSH
26866: LD_VAR 0 1
26870: PPUSH
26871: EMPTY
26872: PPUSH
26873: CALL_OW 1
26877: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
26878: LD_ADDR_EXP 126
26882: PUSH
26883: LD_EXP 126
26887: PPUSH
26888: LD_VAR 0 1
26892: PPUSH
26893: EMPTY
26894: PPUSH
26895: CALL_OW 1
26899: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
26900: LD_ADDR_EXP 127
26904: PUSH
26905: LD_EXP 127
26909: PPUSH
26910: LD_VAR 0 1
26914: PPUSH
26915: EMPTY
26916: PPUSH
26917: CALL_OW 1
26921: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
26922: LD_ADDR_EXP 128
26926: PUSH
26927: LD_EXP 128
26931: PPUSH
26932: LD_VAR 0 1
26936: PPUSH
26937: EMPTY
26938: PPUSH
26939: CALL_OW 1
26943: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
26944: LD_ADDR_EXP 129
26948: PUSH
26949: LD_EXP 129
26953: PPUSH
26954: LD_VAR 0 1
26958: PPUSH
26959: EMPTY
26960: PPUSH
26961: CALL_OW 1
26965: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
26966: LD_ADDR_EXP 130
26970: PUSH
26971: LD_EXP 130
26975: PPUSH
26976: LD_VAR 0 1
26980: PPUSH
26981: EMPTY
26982: PPUSH
26983: CALL_OW 1
26987: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
26988: LD_ADDR_EXP 131
26992: PUSH
26993: LD_EXP 131
26997: PPUSH
26998: LD_VAR 0 1
27002: PPUSH
27003: EMPTY
27004: PPUSH
27005: CALL_OW 1
27009: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
27010: LD_ADDR_EXP 132
27014: PUSH
27015: LD_EXP 132
27019: PPUSH
27020: LD_VAR 0 1
27024: PPUSH
27025: EMPTY
27026: PPUSH
27027: CALL_OW 1
27031: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
27032: LD_ADDR_EXP 133
27036: PUSH
27037: LD_EXP 133
27041: PPUSH
27042: LD_VAR 0 1
27046: PPUSH
27047: EMPTY
27048: PPUSH
27049: CALL_OW 1
27053: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
27054: LD_ADDR_EXP 134
27058: PUSH
27059: LD_EXP 134
27063: PPUSH
27064: LD_VAR 0 1
27068: PPUSH
27069: EMPTY
27070: PPUSH
27071: CALL_OW 1
27075: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
27076: LD_ADDR_EXP 135
27080: PUSH
27081: LD_EXP 135
27085: PPUSH
27086: LD_VAR 0 1
27090: PPUSH
27091: LD_INT 0
27093: PPUSH
27094: CALL_OW 1
27098: ST_TO_ADDR
// end ;
27099: LD_VAR 0 2
27103: RET
// export function MC_Start ( ) ; var i ; begin
27104: LD_INT 0
27106: PPUSH
27107: PPUSH
// for i = 1 to mc_bases do
27108: LD_ADDR_VAR 0 2
27112: PUSH
27113: DOUBLE
27114: LD_INT 1
27116: DEC
27117: ST_TO_ADDR
27118: LD_EXP 93
27122: PUSH
27123: FOR_TO
27124: IFFALSE 28201
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
27126: LD_ADDR_EXP 93
27130: PUSH
27131: LD_EXP 93
27135: PPUSH
27136: LD_VAR 0 2
27140: PPUSH
27141: LD_EXP 93
27145: PUSH
27146: LD_VAR 0 2
27150: ARRAY
27151: PUSH
27152: LD_INT 0
27154: DIFF
27155: PPUSH
27156: CALL_OW 1
27160: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
27161: LD_ADDR_EXP 94
27165: PUSH
27166: LD_EXP 94
27170: PPUSH
27171: LD_VAR 0 2
27175: PPUSH
27176: EMPTY
27177: PPUSH
27178: CALL_OW 1
27182: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27183: LD_ADDR_EXP 95
27187: PUSH
27188: LD_EXP 95
27192: PPUSH
27193: LD_VAR 0 2
27197: PPUSH
27198: EMPTY
27199: PPUSH
27200: CALL_OW 1
27204: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
27205: LD_ADDR_EXP 96
27209: PUSH
27210: LD_EXP 96
27214: PPUSH
27215: LD_VAR 0 2
27219: PPUSH
27220: EMPTY
27221: PPUSH
27222: CALL_OW 1
27226: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
27227: LD_ADDR_EXP 97
27231: PUSH
27232: LD_EXP 97
27236: PPUSH
27237: LD_VAR 0 2
27241: PPUSH
27242: EMPTY
27243: PUSH
27244: EMPTY
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: PPUSH
27250: CALL_OW 1
27254: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
27255: LD_ADDR_EXP 98
27259: PUSH
27260: LD_EXP 98
27264: PPUSH
27265: LD_VAR 0 2
27269: PPUSH
27270: EMPTY
27271: PPUSH
27272: CALL_OW 1
27276: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
27277: LD_ADDR_EXP 125
27281: PUSH
27282: LD_EXP 125
27286: PPUSH
27287: LD_VAR 0 2
27291: PPUSH
27292: EMPTY
27293: PPUSH
27294: CALL_OW 1
27298: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
27299: LD_ADDR_EXP 99
27303: PUSH
27304: LD_EXP 99
27308: PPUSH
27309: LD_VAR 0 2
27313: PPUSH
27314: EMPTY
27315: PPUSH
27316: CALL_OW 1
27320: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
27321: LD_ADDR_EXP 100
27325: PUSH
27326: LD_EXP 100
27330: PPUSH
27331: LD_VAR 0 2
27335: PPUSH
27336: EMPTY
27337: PPUSH
27338: CALL_OW 1
27342: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
27343: LD_ADDR_EXP 101
27347: PUSH
27348: LD_EXP 101
27352: PPUSH
27353: LD_VAR 0 2
27357: PPUSH
27358: LD_EXP 93
27362: PUSH
27363: LD_VAR 0 2
27367: ARRAY
27368: PPUSH
27369: LD_INT 2
27371: PUSH
27372: LD_INT 30
27374: PUSH
27375: LD_INT 32
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 30
27384: PUSH
27385: LD_INT 33
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: LIST
27396: PPUSH
27397: CALL_OW 72
27401: PPUSH
27402: CALL_OW 1
27406: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
27407: LD_ADDR_EXP 102
27411: PUSH
27412: LD_EXP 102
27416: PPUSH
27417: LD_VAR 0 2
27421: PPUSH
27422: LD_EXP 93
27426: PUSH
27427: LD_VAR 0 2
27431: ARRAY
27432: PPUSH
27433: LD_INT 2
27435: PUSH
27436: LD_INT 30
27438: PUSH
27439: LD_INT 32
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PUSH
27446: LD_INT 30
27448: PUSH
27449: LD_INT 31
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: LIST
27460: PUSH
27461: LD_INT 58
27463: PUSH
27464: EMPTY
27465: LIST
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PPUSH
27471: CALL_OW 72
27475: PPUSH
27476: CALL_OW 1
27480: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
27481: LD_ADDR_EXP 103
27485: PUSH
27486: LD_EXP 103
27490: PPUSH
27491: LD_VAR 0 2
27495: PPUSH
27496: EMPTY
27497: PPUSH
27498: CALL_OW 1
27502: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
27503: LD_ADDR_EXP 107
27507: PUSH
27508: LD_EXP 107
27512: PPUSH
27513: LD_VAR 0 2
27517: PPUSH
27518: EMPTY
27519: PPUSH
27520: CALL_OW 1
27524: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
27525: LD_ADDR_EXP 106
27529: PUSH
27530: LD_EXP 106
27534: PPUSH
27535: LD_VAR 0 2
27539: PPUSH
27540: EMPTY
27541: PPUSH
27542: CALL_OW 1
27546: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
27547: LD_ADDR_EXP 108
27551: PUSH
27552: LD_EXP 108
27556: PPUSH
27557: LD_VAR 0 2
27561: PPUSH
27562: EMPTY
27563: PPUSH
27564: CALL_OW 1
27568: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
27569: LD_ADDR_EXP 109
27573: PUSH
27574: LD_EXP 109
27578: PPUSH
27579: LD_VAR 0 2
27583: PPUSH
27584: EMPTY
27585: PPUSH
27586: CALL_OW 1
27590: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
27591: LD_ADDR_EXP 110
27595: PUSH
27596: LD_EXP 110
27600: PPUSH
27601: LD_VAR 0 2
27605: PPUSH
27606: EMPTY
27607: PPUSH
27608: CALL_OW 1
27612: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
27613: LD_ADDR_EXP 111
27617: PUSH
27618: LD_EXP 111
27622: PPUSH
27623: LD_VAR 0 2
27627: PPUSH
27628: EMPTY
27629: PPUSH
27630: CALL_OW 1
27634: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
27635: LD_ADDR_EXP 112
27639: PUSH
27640: LD_EXP 112
27644: PPUSH
27645: LD_VAR 0 2
27649: PPUSH
27650: EMPTY
27651: PPUSH
27652: CALL_OW 1
27656: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
27657: LD_ADDR_EXP 113
27661: PUSH
27662: LD_EXP 113
27666: PPUSH
27667: LD_VAR 0 2
27671: PPUSH
27672: EMPTY
27673: PPUSH
27674: CALL_OW 1
27678: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
27679: LD_ADDR_EXP 114
27683: PUSH
27684: LD_EXP 114
27688: PPUSH
27689: LD_VAR 0 2
27693: PPUSH
27694: EMPTY
27695: PPUSH
27696: CALL_OW 1
27700: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
27701: LD_ADDR_EXP 115
27705: PUSH
27706: LD_EXP 115
27710: PPUSH
27711: LD_VAR 0 2
27715: PPUSH
27716: EMPTY
27717: PPUSH
27718: CALL_OW 1
27722: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
27723: LD_ADDR_EXP 104
27727: PUSH
27728: LD_EXP 104
27732: PPUSH
27733: LD_VAR 0 2
27737: PPUSH
27738: LD_INT 0
27740: PPUSH
27741: CALL_OW 1
27745: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
27746: LD_ADDR_EXP 117
27750: PUSH
27751: LD_EXP 117
27755: PPUSH
27756: LD_VAR 0 2
27760: PPUSH
27761: LD_INT 0
27763: PPUSH
27764: CALL_OW 1
27768: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
27769: LD_ADDR_EXP 105
27773: PUSH
27774: LD_EXP 105
27778: PPUSH
27779: LD_VAR 0 2
27783: PPUSH
27784: EMPTY
27785: PPUSH
27786: CALL_OW 1
27790: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
27791: LD_ADDR_EXP 116
27795: PUSH
27796: LD_EXP 116
27800: PPUSH
27801: LD_VAR 0 2
27805: PPUSH
27806: LD_INT 0
27808: PPUSH
27809: CALL_OW 1
27813: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
27814: LD_ADDR_EXP 118
27818: PUSH
27819: LD_EXP 118
27823: PPUSH
27824: LD_VAR 0 2
27828: PPUSH
27829: EMPTY
27830: PPUSH
27831: CALL_OW 1
27835: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
27836: LD_ADDR_EXP 121
27840: PUSH
27841: LD_EXP 121
27845: PPUSH
27846: LD_VAR 0 2
27850: PPUSH
27851: LD_INT 0
27853: PPUSH
27854: CALL_OW 1
27858: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
27859: LD_ADDR_EXP 122
27863: PUSH
27864: LD_EXP 122
27868: PPUSH
27869: LD_VAR 0 2
27873: PPUSH
27874: EMPTY
27875: PPUSH
27876: CALL_OW 1
27880: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
27881: LD_ADDR_EXP 123
27885: PUSH
27886: LD_EXP 123
27890: PPUSH
27891: LD_VAR 0 2
27895: PPUSH
27896: EMPTY
27897: PPUSH
27898: CALL_OW 1
27902: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27903: LD_ADDR_EXP 124
27907: PUSH
27908: LD_EXP 124
27912: PPUSH
27913: LD_VAR 0 2
27917: PPUSH
27918: EMPTY
27919: PPUSH
27920: CALL_OW 1
27924: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
27925: LD_ADDR_EXP 126
27929: PUSH
27930: LD_EXP 126
27934: PPUSH
27935: LD_VAR 0 2
27939: PPUSH
27940: LD_EXP 93
27944: PUSH
27945: LD_VAR 0 2
27949: ARRAY
27950: PPUSH
27951: LD_INT 2
27953: PUSH
27954: LD_INT 30
27956: PUSH
27957: LD_INT 6
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: PUSH
27964: LD_INT 30
27966: PUSH
27967: LD_INT 7
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PUSH
27974: LD_INT 30
27976: PUSH
27977: LD_INT 8
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: PPUSH
27990: CALL_OW 72
27994: PPUSH
27995: CALL_OW 1
27999: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
28000: LD_ADDR_EXP 127
28004: PUSH
28005: LD_EXP 127
28009: PPUSH
28010: LD_VAR 0 2
28014: PPUSH
28015: EMPTY
28016: PPUSH
28017: CALL_OW 1
28021: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
28022: LD_ADDR_EXP 128
28026: PUSH
28027: LD_EXP 128
28031: PPUSH
28032: LD_VAR 0 2
28036: PPUSH
28037: EMPTY
28038: PPUSH
28039: CALL_OW 1
28043: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
28044: LD_ADDR_EXP 129
28048: PUSH
28049: LD_EXP 129
28053: PPUSH
28054: LD_VAR 0 2
28058: PPUSH
28059: EMPTY
28060: PPUSH
28061: CALL_OW 1
28065: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
28066: LD_ADDR_EXP 130
28070: PUSH
28071: LD_EXP 130
28075: PPUSH
28076: LD_VAR 0 2
28080: PPUSH
28081: EMPTY
28082: PPUSH
28083: CALL_OW 1
28087: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
28088: LD_ADDR_EXP 131
28092: PUSH
28093: LD_EXP 131
28097: PPUSH
28098: LD_VAR 0 2
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL_OW 1
28109: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
28110: LD_ADDR_EXP 132
28114: PUSH
28115: LD_EXP 132
28119: PPUSH
28120: LD_VAR 0 2
28124: PPUSH
28125: EMPTY
28126: PPUSH
28127: CALL_OW 1
28131: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
28132: LD_ADDR_EXP 133
28136: PUSH
28137: LD_EXP 133
28141: PPUSH
28142: LD_VAR 0 2
28146: PPUSH
28147: EMPTY
28148: PPUSH
28149: CALL_OW 1
28153: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
28154: LD_ADDR_EXP 134
28158: PUSH
28159: LD_EXP 134
28163: PPUSH
28164: LD_VAR 0 2
28168: PPUSH
28169: EMPTY
28170: PPUSH
28171: CALL_OW 1
28175: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
28176: LD_ADDR_EXP 135
28180: PUSH
28181: LD_EXP 135
28185: PPUSH
28186: LD_VAR 0 2
28190: PPUSH
28191: LD_INT 0
28193: PPUSH
28194: CALL_OW 1
28198: ST_TO_ADDR
// end ;
28199: GO 27123
28201: POP
28202: POP
// MC_InitSides ( ) ;
28203: CALL 28489 0 0
// MC_InitResearch ( ) ;
28207: CALL 28228 0 0
// CustomInitMacro ( ) ;
28211: CALL 423 0 0
// skirmish := true ;
28215: LD_ADDR_EXP 91
28219: PUSH
28220: LD_INT 1
28222: ST_TO_ADDR
// end ;
28223: LD_VAR 0 1
28227: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
28228: LD_INT 0
28230: PPUSH
28231: PPUSH
28232: PPUSH
28233: PPUSH
28234: PPUSH
28235: PPUSH
// if not mc_bases then
28236: LD_EXP 93
28240: NOT
28241: IFFALSE 28245
// exit ;
28243: GO 28484
// for i = 1 to 8 do
28245: LD_ADDR_VAR 0 2
28249: PUSH
28250: DOUBLE
28251: LD_INT 1
28253: DEC
28254: ST_TO_ADDR
28255: LD_INT 8
28257: PUSH
28258: FOR_TO
28259: IFFALSE 28285
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
28261: LD_ADDR_EXP 120
28265: PUSH
28266: LD_EXP 120
28270: PPUSH
28271: LD_VAR 0 2
28275: PPUSH
28276: EMPTY
28277: PPUSH
28278: CALL_OW 1
28282: ST_TO_ADDR
28283: GO 28258
28285: POP
28286: POP
// tmp := [ ] ;
28287: LD_ADDR_VAR 0 5
28291: PUSH
28292: EMPTY
28293: ST_TO_ADDR
// for i = 1 to mc_sides do
28294: LD_ADDR_VAR 0 2
28298: PUSH
28299: DOUBLE
28300: LD_INT 1
28302: DEC
28303: ST_TO_ADDR
28304: LD_EXP 119
28308: PUSH
28309: FOR_TO
28310: IFFALSE 28368
// if not mc_sides [ i ] in tmp then
28312: LD_EXP 119
28316: PUSH
28317: LD_VAR 0 2
28321: ARRAY
28322: PUSH
28323: LD_VAR 0 5
28327: IN
28328: NOT
28329: IFFALSE 28366
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
28331: LD_ADDR_VAR 0 5
28335: PUSH
28336: LD_VAR 0 5
28340: PPUSH
28341: LD_VAR 0 5
28345: PUSH
28346: LD_INT 1
28348: PLUS
28349: PPUSH
28350: LD_EXP 119
28354: PUSH
28355: LD_VAR 0 2
28359: ARRAY
28360: PPUSH
28361: CALL_OW 2
28365: ST_TO_ADDR
28366: GO 28309
28368: POP
28369: POP
// if not tmp then
28370: LD_VAR 0 5
28374: NOT
28375: IFFALSE 28379
// exit ;
28377: GO 28484
// for j in tmp do
28379: LD_ADDR_VAR 0 3
28383: PUSH
28384: LD_VAR 0 5
28388: PUSH
28389: FOR_IN
28390: IFFALSE 28482
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
28392: LD_ADDR_VAR 0 6
28396: PUSH
28397: LD_INT 22
28399: PUSH
28400: LD_VAR 0 3
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: PPUSH
28409: CALL_OW 69
28413: ST_TO_ADDR
// if not un then
28414: LD_VAR 0 6
28418: NOT
28419: IFFALSE 28423
// continue ;
28421: GO 28389
// nation := GetNation ( un [ 1 ] ) ;
28423: LD_ADDR_VAR 0 4
28427: PUSH
28428: LD_VAR 0 6
28432: PUSH
28433: LD_INT 1
28435: ARRAY
28436: PPUSH
28437: CALL_OW 248
28441: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
28442: LD_ADDR_EXP 120
28446: PUSH
28447: LD_EXP 120
28451: PPUSH
28452: LD_VAR 0 3
28456: PPUSH
28457: LD_VAR 0 3
28461: PPUSH
28462: LD_VAR 0 4
28466: PPUSH
28467: LD_INT 1
28469: PPUSH
28470: CALL 53906 0 3
28474: PPUSH
28475: CALL_OW 1
28479: ST_TO_ADDR
// end ;
28480: GO 28389
28482: POP
28483: POP
// end ;
28484: LD_VAR 0 1
28488: RET
// export function MC_InitSides ( ) ; var i ; begin
28489: LD_INT 0
28491: PPUSH
28492: PPUSH
// if not mc_bases then
28493: LD_EXP 93
28497: NOT
28498: IFFALSE 28502
// exit ;
28500: GO 28576
// for i = 1 to mc_bases do
28502: LD_ADDR_VAR 0 2
28506: PUSH
28507: DOUBLE
28508: LD_INT 1
28510: DEC
28511: ST_TO_ADDR
28512: LD_EXP 93
28516: PUSH
28517: FOR_TO
28518: IFFALSE 28574
// if mc_bases [ i ] then
28520: LD_EXP 93
28524: PUSH
28525: LD_VAR 0 2
28529: ARRAY
28530: IFFALSE 28572
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
28532: LD_ADDR_EXP 119
28536: PUSH
28537: LD_EXP 119
28541: PPUSH
28542: LD_VAR 0 2
28546: PPUSH
28547: LD_EXP 93
28551: PUSH
28552: LD_VAR 0 2
28556: ARRAY
28557: PUSH
28558: LD_INT 1
28560: ARRAY
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: CALL_OW 1
28571: ST_TO_ADDR
28572: GO 28517
28574: POP
28575: POP
// end ;
28576: LD_VAR 0 1
28580: RET
// every 0 0$01 trigger skirmish do
28581: LD_EXP 91
28585: IFFALSE 28739
28587: GO 28589
28589: DISABLE
// begin enable ;
28590: ENABLE
// MC_CheckBuildings ( ) ;
28591: CALL 32905 0 0
// MC_CheckPeopleLife ( ) ;
28595: CALL 33030 0 0
// RaiseSailEvent ( 100 ) ;
28599: LD_INT 100
28601: PPUSH
28602: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
28606: LD_INT 103
28608: PPUSH
28609: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
28613: LD_INT 104
28615: PPUSH
28616: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
28620: LD_INT 105
28622: PPUSH
28623: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
28627: LD_INT 106
28629: PPUSH
28630: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
28634: LD_INT 107
28636: PPUSH
28637: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
28641: LD_INT 108
28643: PPUSH
28644: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
28648: LD_INT 109
28650: PPUSH
28651: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
28655: LD_INT 110
28657: PPUSH
28658: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
28662: LD_INT 111
28664: PPUSH
28665: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
28669: LD_INT 112
28671: PPUSH
28672: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
28676: LD_INT 113
28678: PPUSH
28679: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
28683: LD_INT 120
28685: PPUSH
28686: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
28690: LD_INT 121
28692: PPUSH
28693: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
28697: LD_INT 122
28699: PPUSH
28700: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
28704: LD_INT 123
28706: PPUSH
28707: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
28711: LD_INT 124
28713: PPUSH
28714: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
28718: LD_INT 125
28720: PPUSH
28721: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
28725: LD_INT 126
28727: PPUSH
28728: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
28732: LD_INT 200
28734: PPUSH
28735: CALL_OW 427
// end ;
28739: END
// on SailEvent ( event ) do begin if event < 100 then
28740: LD_VAR 0 1
28744: PUSH
28745: LD_INT 100
28747: LESS
28748: IFFALSE 28759
// CustomEvent ( event ) ;
28750: LD_VAR 0 1
28754: PPUSH
28755: CALL 24561 0 1
// if event = 100 then
28759: LD_VAR 0 1
28763: PUSH
28764: LD_INT 100
28766: EQUAL
28767: IFFALSE 28773
// MC_ClassManager ( ) ;
28769: CALL 29165 0 0
// if event = 101 then
28773: LD_VAR 0 1
28777: PUSH
28778: LD_INT 101
28780: EQUAL
28781: IFFALSE 28787
// MC_RepairBuildings ( ) ;
28783: CALL 33626 0 0
// if event = 102 then
28787: LD_VAR 0 1
28791: PUSH
28792: LD_INT 102
28794: EQUAL
28795: IFFALSE 28801
// MC_Heal ( ) ;
28797: CALL 34032 0 0
// if event = 103 then
28801: LD_VAR 0 1
28805: PUSH
28806: LD_INT 103
28808: EQUAL
28809: IFFALSE 28815
// MC_Build ( ) ;
28811: CALL 34454 0 0
// if event = 104 then
28815: LD_VAR 0 1
28819: PUSH
28820: LD_INT 104
28822: EQUAL
28823: IFFALSE 28829
// MC_TurretWeapon ( ) ;
28825: CALL 36067 0 0
// if event = 105 then
28829: LD_VAR 0 1
28833: PUSH
28834: LD_INT 105
28836: EQUAL
28837: IFFALSE 28843
// MC_BuildUpgrade ( ) ;
28839: CALL 35618 0 0
// if event = 106 then
28843: LD_VAR 0 1
28847: PUSH
28848: LD_INT 106
28850: EQUAL
28851: IFFALSE 28857
// MC_PlantMines ( ) ;
28853: CALL 36497 0 0
// if event = 107 then
28857: LD_VAR 0 1
28861: PUSH
28862: LD_INT 107
28864: EQUAL
28865: IFFALSE 28871
// MC_CollectCrates ( ) ;
28867: CALL 37531 0 0
// if event = 108 then
28871: LD_VAR 0 1
28875: PUSH
28876: LD_INT 108
28878: EQUAL
28879: IFFALSE 28885
// MC_LinkRemoteControl ( ) ;
28881: CALL 39288 0 0
// if event = 109 then
28885: LD_VAR 0 1
28889: PUSH
28890: LD_INT 109
28892: EQUAL
28893: IFFALSE 28899
// MC_ProduceVehicle ( ) ;
28895: CALL 39469 0 0
// if event = 110 then
28899: LD_VAR 0 1
28903: PUSH
28904: LD_INT 110
28906: EQUAL
28907: IFFALSE 28913
// MC_SendAttack ( ) ;
28909: CALL 39950 0 0
// if event = 111 then
28913: LD_VAR 0 1
28917: PUSH
28918: LD_INT 111
28920: EQUAL
28921: IFFALSE 28927
// MC_Defend ( ) ;
28923: CALL 40058 0 0
// if event = 112 then
28927: LD_VAR 0 1
28931: PUSH
28932: LD_INT 112
28934: EQUAL
28935: IFFALSE 28941
// MC_Research ( ) ;
28937: CALL 40685 0 0
// if event = 113 then
28941: LD_VAR 0 1
28945: PUSH
28946: LD_INT 113
28948: EQUAL
28949: IFFALSE 28955
// MC_MinesTrigger ( ) ;
28951: CALL 41799 0 0
// if event = 120 then
28955: LD_VAR 0 1
28959: PUSH
28960: LD_INT 120
28962: EQUAL
28963: IFFALSE 28969
// MC_RepairVehicle ( ) ;
28965: CALL 41898 0 0
// if event = 121 then
28969: LD_VAR 0 1
28973: PUSH
28974: LD_INT 121
28976: EQUAL
28977: IFFALSE 28983
// MC_TameApe ( ) ;
28979: CALL 42641 0 0
// if event = 122 then
28983: LD_VAR 0 1
28987: PUSH
28988: LD_INT 122
28990: EQUAL
28991: IFFALSE 28997
// MC_ChangeApeClass ( ) ;
28993: CALL 43470 0 0
// if event = 123 then
28997: LD_VAR 0 1
29001: PUSH
29002: LD_INT 123
29004: EQUAL
29005: IFFALSE 29011
// MC_Bazooka ( ) ;
29007: CALL 44120 0 0
// if event = 124 then
29011: LD_VAR 0 1
29015: PUSH
29016: LD_INT 124
29018: EQUAL
29019: IFFALSE 29025
// MC_TeleportExit ( ) ;
29021: CALL 44318 0 0
// if event = 125 then
29025: LD_VAR 0 1
29029: PUSH
29030: LD_INT 125
29032: EQUAL
29033: IFFALSE 29039
// MC_Deposits ( ) ;
29035: CALL 44965 0 0
// if event = 126 then
29039: LD_VAR 0 1
29043: PUSH
29044: LD_INT 126
29046: EQUAL
29047: IFFALSE 29053
// MC_RemoteDriver ( ) ;
29049: CALL 45590 0 0
// if event = 200 then
29053: LD_VAR 0 1
29057: PUSH
29058: LD_INT 200
29060: EQUAL
29061: IFFALSE 29067
// MC_Idle ( ) ;
29063: CALL 47323 0 0
// end ;
29067: PPOPN 1
29069: END
// export function MC_Reset ( base , tag ) ; var i ; begin
29070: LD_INT 0
29072: PPUSH
29073: PPUSH
// if not mc_bases [ base ] or not tag then
29074: LD_EXP 93
29078: PUSH
29079: LD_VAR 0 1
29083: ARRAY
29084: NOT
29085: PUSH
29086: LD_VAR 0 2
29090: NOT
29091: OR
29092: IFFALSE 29096
// exit ;
29094: GO 29160
// for i in mc_bases [ base ] union mc_ape [ base ] do
29096: LD_ADDR_VAR 0 4
29100: PUSH
29101: LD_EXP 93
29105: PUSH
29106: LD_VAR 0 1
29110: ARRAY
29111: PUSH
29112: LD_EXP 122
29116: PUSH
29117: LD_VAR 0 1
29121: ARRAY
29122: UNION
29123: PUSH
29124: FOR_IN
29125: IFFALSE 29158
// if GetTag ( i ) = tag then
29127: LD_VAR 0 4
29131: PPUSH
29132: CALL_OW 110
29136: PUSH
29137: LD_VAR 0 2
29141: EQUAL
29142: IFFALSE 29156
// SetTag ( i , 0 ) ;
29144: LD_VAR 0 4
29148: PPUSH
29149: LD_INT 0
29151: PPUSH
29152: CALL_OW 109
29156: GO 29124
29158: POP
29159: POP
// end ;
29160: LD_VAR 0 3
29164: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
29165: LD_INT 0
29167: PPUSH
29168: PPUSH
29169: PPUSH
29170: PPUSH
29171: PPUSH
29172: PPUSH
29173: PPUSH
29174: PPUSH
// if not mc_bases then
29175: LD_EXP 93
29179: NOT
29180: IFFALSE 29184
// exit ;
29182: GO 29642
// for i = 1 to mc_bases do
29184: LD_ADDR_VAR 0 2
29188: PUSH
29189: DOUBLE
29190: LD_INT 1
29192: DEC
29193: ST_TO_ADDR
29194: LD_EXP 93
29198: PUSH
29199: FOR_TO
29200: IFFALSE 29640
// begin tmp := MC_ClassCheckReq ( i ) ;
29202: LD_ADDR_VAR 0 4
29206: PUSH
29207: LD_VAR 0 2
29211: PPUSH
29212: CALL 29647 0 1
29216: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
29217: LD_ADDR_EXP 134
29221: PUSH
29222: LD_EXP 134
29226: PPUSH
29227: LD_VAR 0 2
29231: PPUSH
29232: LD_VAR 0 4
29236: PPUSH
29237: CALL_OW 1
29241: ST_TO_ADDR
// if not tmp then
29242: LD_VAR 0 4
29246: NOT
29247: IFFALSE 29251
// continue ;
29249: GO 29199
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
29251: LD_ADDR_VAR 0 6
29255: PUSH
29256: LD_EXP 93
29260: PUSH
29261: LD_VAR 0 2
29265: ARRAY
29266: PPUSH
29267: LD_INT 2
29269: PUSH
29270: LD_INT 30
29272: PUSH
29273: LD_INT 4
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 30
29282: PUSH
29283: LD_INT 5
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: LIST
29294: PPUSH
29295: CALL_OW 72
29299: PUSH
29300: LD_EXP 93
29304: PUSH
29305: LD_VAR 0 2
29309: ARRAY
29310: PPUSH
29311: LD_INT 2
29313: PUSH
29314: LD_INT 30
29316: PUSH
29317: LD_INT 0
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 30
29326: PUSH
29327: LD_INT 1
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: LIST
29338: PPUSH
29339: CALL_OW 72
29343: PUSH
29344: LD_EXP 93
29348: PUSH
29349: LD_VAR 0 2
29353: ARRAY
29354: PPUSH
29355: LD_INT 30
29357: PUSH
29358: LD_INT 3
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PPUSH
29365: CALL_OW 72
29369: PUSH
29370: LD_EXP 93
29374: PUSH
29375: LD_VAR 0 2
29379: ARRAY
29380: PPUSH
29381: LD_INT 2
29383: PUSH
29384: LD_INT 30
29386: PUSH
29387: LD_INT 6
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 30
29396: PUSH
29397: LD_INT 7
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 30
29406: PUSH
29407: LD_INT 8
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: PPUSH
29420: CALL_OW 72
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: ST_TO_ADDR
// for j = 1 to 4 do
29431: LD_ADDR_VAR 0 3
29435: PUSH
29436: DOUBLE
29437: LD_INT 1
29439: DEC
29440: ST_TO_ADDR
29441: LD_INT 4
29443: PUSH
29444: FOR_TO
29445: IFFALSE 29636
// begin if not tmp [ j ] then
29447: LD_VAR 0 4
29451: PUSH
29452: LD_VAR 0 3
29456: ARRAY
29457: NOT
29458: IFFALSE 29462
// continue ;
29460: GO 29444
// for p in tmp [ j ] do
29462: LD_ADDR_VAR 0 5
29466: PUSH
29467: LD_VAR 0 4
29471: PUSH
29472: LD_VAR 0 3
29476: ARRAY
29477: PUSH
29478: FOR_IN
29479: IFFALSE 29632
// begin if not b [ j ] then
29481: LD_VAR 0 6
29485: PUSH
29486: LD_VAR 0 3
29490: ARRAY
29491: NOT
29492: IFFALSE 29496
// break ;
29494: GO 29632
// e := 0 ;
29496: LD_ADDR_VAR 0 7
29500: PUSH
29501: LD_INT 0
29503: ST_TO_ADDR
// for k in b [ j ] do
29504: LD_ADDR_VAR 0 8
29508: PUSH
29509: LD_VAR 0 6
29513: PUSH
29514: LD_VAR 0 3
29518: ARRAY
29519: PUSH
29520: FOR_IN
29521: IFFALSE 29548
// if IsNotFull ( k ) then
29523: LD_VAR 0 8
29527: PPUSH
29528: CALL 57932 0 1
29532: IFFALSE 29546
// begin e := k ;
29534: LD_ADDR_VAR 0 7
29538: PUSH
29539: LD_VAR 0 8
29543: ST_TO_ADDR
// break ;
29544: GO 29548
// end ;
29546: GO 29520
29548: POP
29549: POP
// if e and not UnitGoingToBuilding ( p , e ) then
29550: LD_VAR 0 7
29554: PUSH
29555: LD_VAR 0 5
29559: PPUSH
29560: LD_VAR 0 7
29564: PPUSH
29565: CALL 94920 0 2
29569: NOT
29570: AND
29571: IFFALSE 29630
// begin if IsInUnit ( p ) then
29573: LD_VAR 0 5
29577: PPUSH
29578: CALL_OW 310
29582: IFFALSE 29593
// ComExitBuilding ( p ) ;
29584: LD_VAR 0 5
29588: PPUSH
29589: CALL_OW 122
// ComEnterUnit ( p , e ) ;
29593: LD_VAR 0 5
29597: PPUSH
29598: LD_VAR 0 7
29602: PPUSH
29603: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
29607: LD_VAR 0 5
29611: PPUSH
29612: LD_VAR 0 3
29616: PPUSH
29617: CALL_OW 183
// AddComExitBuilding ( p ) ;
29621: LD_VAR 0 5
29625: PPUSH
29626: CALL_OW 182
// end ; end ;
29630: GO 29478
29632: POP
29633: POP
// end ;
29634: GO 29444
29636: POP
29637: POP
// end ;
29638: GO 29199
29640: POP
29641: POP
// end ;
29642: LD_VAR 0 1
29646: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
29647: LD_INT 0
29649: PPUSH
29650: PPUSH
29651: PPUSH
29652: PPUSH
29653: PPUSH
29654: PPUSH
29655: PPUSH
29656: PPUSH
29657: PPUSH
29658: PPUSH
29659: PPUSH
29660: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
29661: LD_VAR 0 1
29665: NOT
29666: PUSH
29667: LD_EXP 93
29671: PUSH
29672: LD_VAR 0 1
29676: ARRAY
29677: NOT
29678: OR
29679: PUSH
29680: LD_EXP 93
29684: PUSH
29685: LD_VAR 0 1
29689: ARRAY
29690: PPUSH
29691: LD_INT 2
29693: PUSH
29694: LD_INT 30
29696: PUSH
29697: LD_INT 0
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_INT 1
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: LIST
29718: PPUSH
29719: CALL_OW 72
29723: NOT
29724: OR
29725: IFFALSE 29729
// exit ;
29727: GO 32900
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
29729: LD_ADDR_VAR 0 4
29733: PUSH
29734: LD_EXP 93
29738: PUSH
29739: LD_VAR 0 1
29743: ARRAY
29744: PPUSH
29745: LD_INT 2
29747: PUSH
29748: LD_INT 25
29750: PUSH
29751: LD_INT 1
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 25
29760: PUSH
29761: LD_INT 2
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 25
29770: PUSH
29771: LD_INT 3
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 25
29780: PUSH
29781: LD_INT 4
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 25
29790: PUSH
29791: LD_INT 5
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 25
29800: PUSH
29801: LD_INT 8
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 25
29810: PUSH
29811: LD_INT 9
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 72
29832: ST_TO_ADDR
// for i in tmp do
29833: LD_ADDR_VAR 0 3
29837: PUSH
29838: LD_VAR 0 4
29842: PUSH
29843: FOR_IN
29844: IFFALSE 29875
// if GetTag ( i ) then
29846: LD_VAR 0 3
29850: PPUSH
29851: CALL_OW 110
29855: IFFALSE 29873
// tmp := tmp diff i ;
29857: LD_ADDR_VAR 0 4
29861: PUSH
29862: LD_VAR 0 4
29866: PUSH
29867: LD_VAR 0 3
29871: DIFF
29872: ST_TO_ADDR
29873: GO 29843
29875: POP
29876: POP
// if not tmp then
29877: LD_VAR 0 4
29881: NOT
29882: IFFALSE 29886
// exit ;
29884: GO 32900
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
29886: LD_ADDR_VAR 0 5
29890: PUSH
29891: LD_EXP 93
29895: PUSH
29896: LD_VAR 0 1
29900: ARRAY
29901: PPUSH
29902: LD_INT 2
29904: PUSH
29905: LD_INT 25
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 25
29917: PUSH
29918: LD_INT 5
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 25
29927: PUSH
29928: LD_INT 8
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 25
29937: PUSH
29938: LD_INT 9
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: PPUSH
29952: CALL_OW 72
29956: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
29957: LD_ADDR_VAR 0 6
29961: PUSH
29962: LD_EXP 93
29966: PUSH
29967: LD_VAR 0 1
29971: ARRAY
29972: PPUSH
29973: LD_INT 25
29975: PUSH
29976: LD_INT 2
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PPUSH
29983: CALL_OW 72
29987: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
29988: LD_ADDR_VAR 0 7
29992: PUSH
29993: LD_EXP 93
29997: PUSH
29998: LD_VAR 0 1
30002: ARRAY
30003: PPUSH
30004: LD_INT 25
30006: PUSH
30007: LD_INT 3
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PPUSH
30014: CALL_OW 72
30018: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
30019: LD_ADDR_VAR 0 8
30023: PUSH
30024: LD_EXP 93
30028: PUSH
30029: LD_VAR 0 1
30033: ARRAY
30034: PPUSH
30035: LD_INT 25
30037: PUSH
30038: LD_INT 4
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 24
30047: PUSH
30048: LD_INT 251
30050: PUSH
30051: EMPTY
30052: LIST
30053: LIST
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PPUSH
30059: CALL_OW 72
30063: ST_TO_ADDR
// if mc_scan [ base ] then
30064: LD_EXP 116
30068: PUSH
30069: LD_VAR 0 1
30073: ARRAY
30074: IFFALSE 30535
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
30076: LD_ADDR_EXP 135
30080: PUSH
30081: LD_EXP 135
30085: PPUSH
30086: LD_VAR 0 1
30090: PPUSH
30091: LD_INT 4
30093: PPUSH
30094: CALL_OW 1
30098: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
30099: LD_ADDR_VAR 0 12
30103: PUSH
30104: LD_EXP 93
30108: PUSH
30109: LD_VAR 0 1
30113: ARRAY
30114: PPUSH
30115: LD_INT 2
30117: PUSH
30118: LD_INT 30
30120: PUSH
30121: LD_INT 4
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 30
30130: PUSH
30131: LD_INT 5
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: LIST
30142: PPUSH
30143: CALL_OW 72
30147: ST_TO_ADDR
// if not b then
30148: LD_VAR 0 12
30152: NOT
30153: IFFALSE 30157
// exit ;
30155: GO 32900
// p := [ ] ;
30157: LD_ADDR_VAR 0 11
30161: PUSH
30162: EMPTY
30163: ST_TO_ADDR
// if sci >= 2 then
30164: LD_VAR 0 8
30168: PUSH
30169: LD_INT 2
30171: GREATEREQUAL
30172: IFFALSE 30203
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
30174: LD_ADDR_VAR 0 8
30178: PUSH
30179: LD_VAR 0 8
30183: PUSH
30184: LD_INT 1
30186: ARRAY
30187: PUSH
30188: LD_VAR 0 8
30192: PUSH
30193: LD_INT 2
30195: ARRAY
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: ST_TO_ADDR
30201: GO 30264
// if sci = 1 then
30203: LD_VAR 0 8
30207: PUSH
30208: LD_INT 1
30210: EQUAL
30211: IFFALSE 30232
// sci := [ sci [ 1 ] ] else
30213: LD_ADDR_VAR 0 8
30217: PUSH
30218: LD_VAR 0 8
30222: PUSH
30223: LD_INT 1
30225: ARRAY
30226: PUSH
30227: EMPTY
30228: LIST
30229: ST_TO_ADDR
30230: GO 30264
// if sci = 0 then
30232: LD_VAR 0 8
30236: PUSH
30237: LD_INT 0
30239: EQUAL
30240: IFFALSE 30264
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
30242: LD_ADDR_VAR 0 11
30246: PUSH
30247: LD_VAR 0 4
30251: PPUSH
30252: LD_INT 4
30254: PPUSH
30255: CALL 94783 0 2
30259: PUSH
30260: LD_INT 1
30262: ARRAY
30263: ST_TO_ADDR
// if eng > 4 then
30264: LD_VAR 0 6
30268: PUSH
30269: LD_INT 4
30271: GREATER
30272: IFFALSE 30318
// for i = eng downto 4 do
30274: LD_ADDR_VAR 0 3
30278: PUSH
30279: DOUBLE
30280: LD_VAR 0 6
30284: INC
30285: ST_TO_ADDR
30286: LD_INT 4
30288: PUSH
30289: FOR_DOWNTO
30290: IFFALSE 30316
// eng := eng diff eng [ i ] ;
30292: LD_ADDR_VAR 0 6
30296: PUSH
30297: LD_VAR 0 6
30301: PUSH
30302: LD_VAR 0 6
30306: PUSH
30307: LD_VAR 0 3
30311: ARRAY
30312: DIFF
30313: ST_TO_ADDR
30314: GO 30289
30316: POP
30317: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
30318: LD_ADDR_VAR 0 4
30322: PUSH
30323: LD_VAR 0 4
30327: PUSH
30328: LD_VAR 0 5
30332: PUSH
30333: LD_VAR 0 6
30337: UNION
30338: PUSH
30339: LD_VAR 0 7
30343: UNION
30344: PUSH
30345: LD_VAR 0 8
30349: UNION
30350: DIFF
30351: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
30352: LD_ADDR_VAR 0 13
30356: PUSH
30357: LD_EXP 93
30361: PUSH
30362: LD_VAR 0 1
30366: ARRAY
30367: PPUSH
30368: LD_INT 2
30370: PUSH
30371: LD_INT 30
30373: PUSH
30374: LD_INT 32
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 30
30383: PUSH
30384: LD_INT 31
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: LIST
30395: PPUSH
30396: CALL_OW 72
30400: PUSH
30401: LD_EXP 93
30405: PUSH
30406: LD_VAR 0 1
30410: ARRAY
30411: PPUSH
30412: LD_INT 2
30414: PUSH
30415: LD_INT 30
30417: PUSH
30418: LD_INT 4
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: LD_INT 30
30427: PUSH
30428: LD_INT 5
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: LIST
30439: PPUSH
30440: CALL_OW 72
30444: PUSH
30445: LD_INT 6
30447: MUL
30448: PLUS
30449: ST_TO_ADDR
// if bcount < tmp then
30450: LD_VAR 0 13
30454: PUSH
30455: LD_VAR 0 4
30459: LESS
30460: IFFALSE 30506
// for i = tmp downto bcount do
30462: LD_ADDR_VAR 0 3
30466: PUSH
30467: DOUBLE
30468: LD_VAR 0 4
30472: INC
30473: ST_TO_ADDR
30474: LD_VAR 0 13
30478: PUSH
30479: FOR_DOWNTO
30480: IFFALSE 30504
// tmp := Delete ( tmp , tmp ) ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_VAR 0 4
30491: PPUSH
30492: LD_VAR 0 4
30496: PPUSH
30497: CALL_OW 3
30501: ST_TO_ADDR
30502: GO 30479
30504: POP
30505: POP
// result := [ tmp , 0 , 0 , p ] ;
30506: LD_ADDR_VAR 0 2
30510: PUSH
30511: LD_VAR 0 4
30515: PUSH
30516: LD_INT 0
30518: PUSH
30519: LD_INT 0
30521: PUSH
30522: LD_VAR 0 11
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: ST_TO_ADDR
// exit ;
30533: GO 32900
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
30535: LD_EXP 93
30539: PUSH
30540: LD_VAR 0 1
30544: ARRAY
30545: PPUSH
30546: LD_INT 2
30548: PUSH
30549: LD_INT 30
30551: PUSH
30552: LD_INT 6
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 30
30561: PUSH
30562: LD_INT 7
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 30
30571: PUSH
30572: LD_INT 8
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: PPUSH
30585: CALL_OW 72
30589: NOT
30590: PUSH
30591: LD_EXP 93
30595: PUSH
30596: LD_VAR 0 1
30600: ARRAY
30601: PPUSH
30602: LD_INT 30
30604: PUSH
30605: LD_INT 3
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PPUSH
30612: CALL_OW 72
30616: NOT
30617: AND
30618: IFFALSE 30690
// begin if eng = tmp then
30620: LD_VAR 0 6
30624: PUSH
30625: LD_VAR 0 4
30629: EQUAL
30630: IFFALSE 30634
// exit ;
30632: GO 32900
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
30634: LD_ADDR_EXP 135
30638: PUSH
30639: LD_EXP 135
30643: PPUSH
30644: LD_VAR 0 1
30648: PPUSH
30649: LD_INT 1
30651: PPUSH
30652: CALL_OW 1
30656: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
30657: LD_ADDR_VAR 0 2
30661: PUSH
30662: LD_INT 0
30664: PUSH
30665: LD_VAR 0 4
30669: PUSH
30670: LD_VAR 0 6
30674: DIFF
30675: PUSH
30676: LD_INT 0
30678: PUSH
30679: LD_INT 0
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: ST_TO_ADDR
// exit ;
30688: GO 32900
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
30690: LD_EXP 120
30694: PUSH
30695: LD_EXP 119
30699: PUSH
30700: LD_VAR 0 1
30704: ARRAY
30705: ARRAY
30706: PUSH
30707: LD_EXP 93
30711: PUSH
30712: LD_VAR 0 1
30716: ARRAY
30717: PPUSH
30718: LD_INT 2
30720: PUSH
30721: LD_INT 30
30723: PUSH
30724: LD_INT 6
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PUSH
30731: LD_INT 30
30733: PUSH
30734: LD_INT 7
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 30
30743: PUSH
30744: LD_INT 8
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: PPUSH
30757: CALL_OW 72
30761: AND
30762: PUSH
30763: LD_EXP 93
30767: PUSH
30768: LD_VAR 0 1
30772: ARRAY
30773: PPUSH
30774: LD_INT 30
30776: PUSH
30777: LD_INT 3
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PPUSH
30784: CALL_OW 72
30788: NOT
30789: AND
30790: IFFALSE 31004
// begin if sci >= 6 then
30792: LD_VAR 0 8
30796: PUSH
30797: LD_INT 6
30799: GREATEREQUAL
30800: IFFALSE 30804
// exit ;
30802: GO 32900
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
30804: LD_ADDR_EXP 135
30808: PUSH
30809: LD_EXP 135
30813: PPUSH
30814: LD_VAR 0 1
30818: PPUSH
30819: LD_INT 2
30821: PPUSH
30822: CALL_OW 1
30826: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
30827: LD_ADDR_VAR 0 9
30831: PUSH
30832: LD_VAR 0 4
30836: PUSH
30837: LD_VAR 0 8
30841: DIFF
30842: PPUSH
30843: LD_INT 4
30845: PPUSH
30846: CALL 94783 0 2
30850: ST_TO_ADDR
// p := [ ] ;
30851: LD_ADDR_VAR 0 11
30855: PUSH
30856: EMPTY
30857: ST_TO_ADDR
// if sci < 6 and sort > 6 then
30858: LD_VAR 0 8
30862: PUSH
30863: LD_INT 6
30865: LESS
30866: PUSH
30867: LD_VAR 0 9
30871: PUSH
30872: LD_INT 6
30874: GREATER
30875: AND
30876: IFFALSE 30957
// begin for i = 1 to 6 - sci do
30878: LD_ADDR_VAR 0 3
30882: PUSH
30883: DOUBLE
30884: LD_INT 1
30886: DEC
30887: ST_TO_ADDR
30888: LD_INT 6
30890: PUSH
30891: LD_VAR 0 8
30895: MINUS
30896: PUSH
30897: FOR_TO
30898: IFFALSE 30953
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
30900: LD_ADDR_VAR 0 11
30904: PUSH
30905: LD_VAR 0 11
30909: PPUSH
30910: LD_VAR 0 11
30914: PUSH
30915: LD_INT 1
30917: PLUS
30918: PPUSH
30919: LD_VAR 0 9
30923: PUSH
30924: LD_INT 1
30926: ARRAY
30927: PPUSH
30928: CALL_OW 2
30932: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
30933: LD_ADDR_VAR 0 9
30937: PUSH
30938: LD_VAR 0 9
30942: PPUSH
30943: LD_INT 1
30945: PPUSH
30946: CALL_OW 3
30950: ST_TO_ADDR
// end ;
30951: GO 30897
30953: POP
30954: POP
// end else
30955: GO 30977
// if sort then
30957: LD_VAR 0 9
30961: IFFALSE 30977
// p := sort [ 1 ] ;
30963: LD_ADDR_VAR 0 11
30967: PUSH
30968: LD_VAR 0 9
30972: PUSH
30973: LD_INT 1
30975: ARRAY
30976: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: LD_INT 0
30990: PUSH
30991: LD_VAR 0 11
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: ST_TO_ADDR
// exit ;
31002: GO 32900
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
31004: LD_EXP 120
31008: PUSH
31009: LD_EXP 119
31013: PUSH
31014: LD_VAR 0 1
31018: ARRAY
31019: ARRAY
31020: PUSH
31021: LD_EXP 93
31025: PUSH
31026: LD_VAR 0 1
31030: ARRAY
31031: PPUSH
31032: LD_INT 2
31034: PUSH
31035: LD_INT 30
31037: PUSH
31038: LD_INT 6
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 30
31047: PUSH
31048: LD_INT 7
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 30
31057: PUSH
31058: LD_INT 8
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: LIST
31069: LIST
31070: PPUSH
31071: CALL_OW 72
31075: AND
31076: PUSH
31077: LD_EXP 93
31081: PUSH
31082: LD_VAR 0 1
31086: ARRAY
31087: PPUSH
31088: LD_INT 30
31090: PUSH
31091: LD_INT 3
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PPUSH
31098: CALL_OW 72
31102: AND
31103: IFFALSE 31630
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
31105: LD_ADDR_EXP 135
31109: PUSH
31110: LD_EXP 135
31114: PPUSH
31115: LD_VAR 0 1
31119: PPUSH
31120: LD_INT 3
31122: PPUSH
31123: CALL_OW 1
31127: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
31128: LD_ADDR_VAR 0 2
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 0
31138: PUSH
31139: LD_INT 0
31141: PUSH
31142: LD_INT 0
31144: PUSH
31145: EMPTY
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: ST_TO_ADDR
// if not eng then
31151: LD_VAR 0 6
31155: NOT
31156: IFFALSE 31219
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
31158: LD_ADDR_VAR 0 11
31162: PUSH
31163: LD_VAR 0 4
31167: PPUSH
31168: LD_INT 2
31170: PPUSH
31171: CALL 94783 0 2
31175: PUSH
31176: LD_INT 1
31178: ARRAY
31179: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
31180: LD_ADDR_VAR 0 2
31184: PUSH
31185: LD_VAR 0 2
31189: PPUSH
31190: LD_INT 2
31192: PPUSH
31193: LD_VAR 0 11
31197: PPUSH
31198: CALL_OW 1
31202: ST_TO_ADDR
// tmp := tmp diff p ;
31203: LD_ADDR_VAR 0 4
31207: PUSH
31208: LD_VAR 0 4
31212: PUSH
31213: LD_VAR 0 11
31217: DIFF
31218: ST_TO_ADDR
// end ; if not eng then
31219: LD_VAR 0 6
31223: NOT
31224: IFFALSE 31250
// tmp := tmp diff ( mech union sci ) else
31226: LD_ADDR_VAR 0 4
31230: PUSH
31231: LD_VAR 0 4
31235: PUSH
31236: LD_VAR 0 7
31240: PUSH
31241: LD_VAR 0 8
31245: UNION
31246: DIFF
31247: ST_TO_ADDR
31248: GO 31282
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
31250: LD_ADDR_VAR 0 4
31254: PUSH
31255: LD_VAR 0 4
31259: PUSH
31260: LD_VAR 0 6
31264: PUSH
31265: LD_INT 1
31267: ARRAY
31268: PUSH
31269: LD_VAR 0 7
31273: UNION
31274: PUSH
31275: LD_VAR 0 8
31279: UNION
31280: DIFF
31281: ST_TO_ADDR
// if tmp and sci < 6 then
31282: LD_VAR 0 4
31286: PUSH
31287: LD_VAR 0 8
31291: PUSH
31292: LD_INT 6
31294: LESS
31295: AND
31296: IFFALSE 31455
// begin sort := SortBySkill ( tmp , 4 ) ;
31298: LD_ADDR_VAR 0 9
31302: PUSH
31303: LD_VAR 0 4
31307: PPUSH
31308: LD_INT 4
31310: PPUSH
31311: CALL 94783 0 2
31315: ST_TO_ADDR
// p := [ ] ;
31316: LD_ADDR_VAR 0 11
31320: PUSH
31321: EMPTY
31322: ST_TO_ADDR
// if sort then
31323: LD_VAR 0 9
31327: IFFALSE 31426
// for i = 1 to 6 - sci do
31329: LD_ADDR_VAR 0 3
31333: PUSH
31334: DOUBLE
31335: LD_INT 1
31337: DEC
31338: ST_TO_ADDR
31339: LD_INT 6
31341: PUSH
31342: LD_VAR 0 8
31346: MINUS
31347: PUSH
31348: FOR_TO
31349: IFFALSE 31424
// begin if i = sort then
31351: LD_VAR 0 3
31355: PUSH
31356: LD_VAR 0 9
31360: EQUAL
31361: IFFALSE 31365
// break ;
31363: GO 31424
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31365: LD_ADDR_VAR 0 11
31369: PUSH
31370: LD_VAR 0 11
31374: PPUSH
31375: LD_VAR 0 11
31379: PUSH
31380: LD_INT 1
31382: PLUS
31383: PPUSH
31384: LD_VAR 0 9
31388: PUSH
31389: LD_VAR 0 3
31393: ARRAY
31394: PPUSH
31395: CALL_OW 2
31399: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31400: LD_ADDR_VAR 0 4
31404: PUSH
31405: LD_VAR 0 4
31409: PUSH
31410: LD_VAR 0 9
31414: PUSH
31415: LD_VAR 0 3
31419: ARRAY
31420: DIFF
31421: ST_TO_ADDR
// end ;
31422: GO 31348
31424: POP
31425: POP
// if p then
31426: LD_VAR 0 11
31430: IFFALSE 31455
// result := Replace ( result , 4 , p ) ;
31432: LD_ADDR_VAR 0 2
31436: PUSH
31437: LD_VAR 0 2
31441: PPUSH
31442: LD_INT 4
31444: PPUSH
31445: LD_VAR 0 11
31449: PPUSH
31450: CALL_OW 1
31454: ST_TO_ADDR
// end ; if tmp and mech < 6 then
31455: LD_VAR 0 4
31459: PUSH
31460: LD_VAR 0 7
31464: PUSH
31465: LD_INT 6
31467: LESS
31468: AND
31469: IFFALSE 31628
// begin sort := SortBySkill ( tmp , 3 ) ;
31471: LD_ADDR_VAR 0 9
31475: PUSH
31476: LD_VAR 0 4
31480: PPUSH
31481: LD_INT 3
31483: PPUSH
31484: CALL 94783 0 2
31488: ST_TO_ADDR
// p := [ ] ;
31489: LD_ADDR_VAR 0 11
31493: PUSH
31494: EMPTY
31495: ST_TO_ADDR
// if sort then
31496: LD_VAR 0 9
31500: IFFALSE 31599
// for i = 1 to 6 - mech do
31502: LD_ADDR_VAR 0 3
31506: PUSH
31507: DOUBLE
31508: LD_INT 1
31510: DEC
31511: ST_TO_ADDR
31512: LD_INT 6
31514: PUSH
31515: LD_VAR 0 7
31519: MINUS
31520: PUSH
31521: FOR_TO
31522: IFFALSE 31597
// begin if i = sort then
31524: LD_VAR 0 3
31528: PUSH
31529: LD_VAR 0 9
31533: EQUAL
31534: IFFALSE 31538
// break ;
31536: GO 31597
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31538: LD_ADDR_VAR 0 11
31542: PUSH
31543: LD_VAR 0 11
31547: PPUSH
31548: LD_VAR 0 11
31552: PUSH
31553: LD_INT 1
31555: PLUS
31556: PPUSH
31557: LD_VAR 0 9
31561: PUSH
31562: LD_VAR 0 3
31566: ARRAY
31567: PPUSH
31568: CALL_OW 2
31572: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31573: LD_ADDR_VAR 0 4
31577: PUSH
31578: LD_VAR 0 4
31582: PUSH
31583: LD_VAR 0 9
31587: PUSH
31588: LD_VAR 0 3
31592: ARRAY
31593: DIFF
31594: ST_TO_ADDR
// end ;
31595: GO 31521
31597: POP
31598: POP
// if p then
31599: LD_VAR 0 11
31603: IFFALSE 31628
// result := Replace ( result , 3 , p ) ;
31605: LD_ADDR_VAR 0 2
31609: PUSH
31610: LD_VAR 0 2
31614: PPUSH
31615: LD_INT 3
31617: PPUSH
31618: LD_VAR 0 11
31622: PPUSH
31623: CALL_OW 1
31627: ST_TO_ADDR
// end ; exit ;
31628: GO 32900
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
31630: LD_EXP 120
31634: PUSH
31635: LD_EXP 119
31639: PUSH
31640: LD_VAR 0 1
31644: ARRAY
31645: ARRAY
31646: NOT
31647: PUSH
31648: LD_EXP 93
31652: PUSH
31653: LD_VAR 0 1
31657: ARRAY
31658: PPUSH
31659: LD_INT 30
31661: PUSH
31662: LD_INT 3
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PPUSH
31669: CALL_OW 72
31673: AND
31674: PUSH
31675: LD_EXP 98
31679: PUSH
31680: LD_VAR 0 1
31684: ARRAY
31685: AND
31686: IFFALSE 32230
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
31688: LD_ADDR_EXP 135
31692: PUSH
31693: LD_EXP 135
31697: PPUSH
31698: LD_VAR 0 1
31702: PPUSH
31703: LD_INT 5
31705: PPUSH
31706: CALL_OW 1
31710: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
31711: LD_ADDR_VAR 0 2
31715: PUSH
31716: LD_INT 0
31718: PUSH
31719: LD_INT 0
31721: PUSH
31722: LD_INT 0
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: ST_TO_ADDR
// if sci > 1 then
31734: LD_VAR 0 8
31738: PUSH
31739: LD_INT 1
31741: GREATER
31742: IFFALSE 31770
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
31744: LD_ADDR_VAR 0 4
31748: PUSH
31749: LD_VAR 0 4
31753: PUSH
31754: LD_VAR 0 8
31758: PUSH
31759: LD_VAR 0 8
31763: PUSH
31764: LD_INT 1
31766: ARRAY
31767: DIFF
31768: DIFF
31769: ST_TO_ADDR
// if tmp and not sci then
31770: LD_VAR 0 4
31774: PUSH
31775: LD_VAR 0 8
31779: NOT
31780: AND
31781: IFFALSE 31850
// begin sort := SortBySkill ( tmp , 4 ) ;
31783: LD_ADDR_VAR 0 9
31787: PUSH
31788: LD_VAR 0 4
31792: PPUSH
31793: LD_INT 4
31795: PPUSH
31796: CALL 94783 0 2
31800: ST_TO_ADDR
// if sort then
31801: LD_VAR 0 9
31805: IFFALSE 31821
// p := sort [ 1 ] ;
31807: LD_ADDR_VAR 0 11
31811: PUSH
31812: LD_VAR 0 9
31816: PUSH
31817: LD_INT 1
31819: ARRAY
31820: ST_TO_ADDR
// if p then
31821: LD_VAR 0 11
31825: IFFALSE 31850
// result := Replace ( result , 4 , p ) ;
31827: LD_ADDR_VAR 0 2
31831: PUSH
31832: LD_VAR 0 2
31836: PPUSH
31837: LD_INT 4
31839: PPUSH
31840: LD_VAR 0 11
31844: PPUSH
31845: CALL_OW 1
31849: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
31850: LD_ADDR_VAR 0 4
31854: PUSH
31855: LD_VAR 0 4
31859: PUSH
31860: LD_VAR 0 7
31864: DIFF
31865: ST_TO_ADDR
// if tmp and mech < 6 then
31866: LD_VAR 0 4
31870: PUSH
31871: LD_VAR 0 7
31875: PUSH
31876: LD_INT 6
31878: LESS
31879: AND
31880: IFFALSE 32039
// begin sort := SortBySkill ( tmp , 3 ) ;
31882: LD_ADDR_VAR 0 9
31886: PUSH
31887: LD_VAR 0 4
31891: PPUSH
31892: LD_INT 3
31894: PPUSH
31895: CALL 94783 0 2
31899: ST_TO_ADDR
// p := [ ] ;
31900: LD_ADDR_VAR 0 11
31904: PUSH
31905: EMPTY
31906: ST_TO_ADDR
// if sort then
31907: LD_VAR 0 9
31911: IFFALSE 32010
// for i = 1 to 6 - mech do
31913: LD_ADDR_VAR 0 3
31917: PUSH
31918: DOUBLE
31919: LD_INT 1
31921: DEC
31922: ST_TO_ADDR
31923: LD_INT 6
31925: PUSH
31926: LD_VAR 0 7
31930: MINUS
31931: PUSH
31932: FOR_TO
31933: IFFALSE 32008
// begin if i = sort then
31935: LD_VAR 0 3
31939: PUSH
31940: LD_VAR 0 9
31944: EQUAL
31945: IFFALSE 31949
// break ;
31947: GO 32008
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31949: LD_ADDR_VAR 0 11
31953: PUSH
31954: LD_VAR 0 11
31958: PPUSH
31959: LD_VAR 0 11
31963: PUSH
31964: LD_INT 1
31966: PLUS
31967: PPUSH
31968: LD_VAR 0 9
31972: PUSH
31973: LD_VAR 0 3
31977: ARRAY
31978: PPUSH
31979: CALL_OW 2
31983: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31984: LD_ADDR_VAR 0 4
31988: PUSH
31989: LD_VAR 0 4
31993: PUSH
31994: LD_VAR 0 9
31998: PUSH
31999: LD_VAR 0 3
32003: ARRAY
32004: DIFF
32005: ST_TO_ADDR
// end ;
32006: GO 31932
32008: POP
32009: POP
// if p then
32010: LD_VAR 0 11
32014: IFFALSE 32039
// result := Replace ( result , 3 , p ) ;
32016: LD_ADDR_VAR 0 2
32020: PUSH
32021: LD_VAR 0 2
32025: PPUSH
32026: LD_INT 3
32028: PPUSH
32029: LD_VAR 0 11
32033: PPUSH
32034: CALL_OW 1
32038: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
32039: LD_ADDR_VAR 0 4
32043: PUSH
32044: LD_VAR 0 4
32048: PUSH
32049: LD_VAR 0 6
32053: DIFF
32054: ST_TO_ADDR
// if tmp and eng < 6 then
32055: LD_VAR 0 4
32059: PUSH
32060: LD_VAR 0 6
32064: PUSH
32065: LD_INT 6
32067: LESS
32068: AND
32069: IFFALSE 32228
// begin sort := SortBySkill ( tmp , 2 ) ;
32071: LD_ADDR_VAR 0 9
32075: PUSH
32076: LD_VAR 0 4
32080: PPUSH
32081: LD_INT 2
32083: PPUSH
32084: CALL 94783 0 2
32088: ST_TO_ADDR
// p := [ ] ;
32089: LD_ADDR_VAR 0 11
32093: PUSH
32094: EMPTY
32095: ST_TO_ADDR
// if sort then
32096: LD_VAR 0 9
32100: IFFALSE 32199
// for i = 1 to 6 - eng do
32102: LD_ADDR_VAR 0 3
32106: PUSH
32107: DOUBLE
32108: LD_INT 1
32110: DEC
32111: ST_TO_ADDR
32112: LD_INT 6
32114: PUSH
32115: LD_VAR 0 6
32119: MINUS
32120: PUSH
32121: FOR_TO
32122: IFFALSE 32197
// begin if i = sort then
32124: LD_VAR 0 3
32128: PUSH
32129: LD_VAR 0 9
32133: EQUAL
32134: IFFALSE 32138
// break ;
32136: GO 32197
// p := Insert ( p , p + 1 , sort [ i ] ) ;
32138: LD_ADDR_VAR 0 11
32142: PUSH
32143: LD_VAR 0 11
32147: PPUSH
32148: LD_VAR 0 11
32152: PUSH
32153: LD_INT 1
32155: PLUS
32156: PPUSH
32157: LD_VAR 0 9
32161: PUSH
32162: LD_VAR 0 3
32166: ARRAY
32167: PPUSH
32168: CALL_OW 2
32172: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
32173: LD_ADDR_VAR 0 4
32177: PUSH
32178: LD_VAR 0 4
32182: PUSH
32183: LD_VAR 0 9
32187: PUSH
32188: LD_VAR 0 3
32192: ARRAY
32193: DIFF
32194: ST_TO_ADDR
// end ;
32195: GO 32121
32197: POP
32198: POP
// if p then
32199: LD_VAR 0 11
32203: IFFALSE 32228
// result := Replace ( result , 2 , p ) ;
32205: LD_ADDR_VAR 0 2
32209: PUSH
32210: LD_VAR 0 2
32214: PPUSH
32215: LD_INT 2
32217: PPUSH
32218: LD_VAR 0 11
32222: PPUSH
32223: CALL_OW 1
32227: ST_TO_ADDR
// end ; exit ;
32228: GO 32900
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
32230: LD_EXP 120
32234: PUSH
32235: LD_EXP 119
32239: PUSH
32240: LD_VAR 0 1
32244: ARRAY
32245: ARRAY
32246: NOT
32247: PUSH
32248: LD_EXP 93
32252: PUSH
32253: LD_VAR 0 1
32257: ARRAY
32258: PPUSH
32259: LD_INT 30
32261: PUSH
32262: LD_INT 3
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PPUSH
32269: CALL_OW 72
32273: AND
32274: PUSH
32275: LD_EXP 98
32279: PUSH
32280: LD_VAR 0 1
32284: ARRAY
32285: NOT
32286: AND
32287: IFFALSE 32900
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
32289: LD_ADDR_EXP 135
32293: PUSH
32294: LD_EXP 135
32298: PPUSH
32299: LD_VAR 0 1
32303: PPUSH
32304: LD_INT 6
32306: PPUSH
32307: CALL_OW 1
32311: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
32312: LD_ADDR_VAR 0 2
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: LD_INT 0
32325: PUSH
32326: LD_INT 0
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: ST_TO_ADDR
// if sci >= 1 then
32335: LD_VAR 0 8
32339: PUSH
32340: LD_INT 1
32342: GREATEREQUAL
32343: IFFALSE 32365
// tmp := tmp diff sci [ 1 ] ;
32345: LD_ADDR_VAR 0 4
32349: PUSH
32350: LD_VAR 0 4
32354: PUSH
32355: LD_VAR 0 8
32359: PUSH
32360: LD_INT 1
32362: ARRAY
32363: DIFF
32364: ST_TO_ADDR
// if tmp and not sci then
32365: LD_VAR 0 4
32369: PUSH
32370: LD_VAR 0 8
32374: NOT
32375: AND
32376: IFFALSE 32445
// begin sort := SortBySkill ( tmp , 4 ) ;
32378: LD_ADDR_VAR 0 9
32382: PUSH
32383: LD_VAR 0 4
32387: PPUSH
32388: LD_INT 4
32390: PPUSH
32391: CALL 94783 0 2
32395: ST_TO_ADDR
// if sort then
32396: LD_VAR 0 9
32400: IFFALSE 32416
// p := sort [ 1 ] ;
32402: LD_ADDR_VAR 0 11
32406: PUSH
32407: LD_VAR 0 9
32411: PUSH
32412: LD_INT 1
32414: ARRAY
32415: ST_TO_ADDR
// if p then
32416: LD_VAR 0 11
32420: IFFALSE 32445
// result := Replace ( result , 4 , p ) ;
32422: LD_ADDR_VAR 0 2
32426: PUSH
32427: LD_VAR 0 2
32431: PPUSH
32432: LD_INT 4
32434: PPUSH
32435: LD_VAR 0 11
32439: PPUSH
32440: CALL_OW 1
32444: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
32445: LD_ADDR_VAR 0 4
32449: PUSH
32450: LD_VAR 0 4
32454: PUSH
32455: LD_VAR 0 7
32459: DIFF
32460: ST_TO_ADDR
// if tmp and mech < 6 then
32461: LD_VAR 0 4
32465: PUSH
32466: LD_VAR 0 7
32470: PUSH
32471: LD_INT 6
32473: LESS
32474: AND
32475: IFFALSE 32634
// begin sort := SortBySkill ( tmp , 3 ) ;
32477: LD_ADDR_VAR 0 9
32481: PUSH
32482: LD_VAR 0 4
32486: PPUSH
32487: LD_INT 3
32489: PPUSH
32490: CALL 94783 0 2
32494: ST_TO_ADDR
// p := [ ] ;
32495: LD_ADDR_VAR 0 11
32499: PUSH
32500: EMPTY
32501: ST_TO_ADDR
// if sort then
32502: LD_VAR 0 9
32506: IFFALSE 32605
// for i = 1 to 6 - mech do
32508: LD_ADDR_VAR 0 3
32512: PUSH
32513: DOUBLE
32514: LD_INT 1
32516: DEC
32517: ST_TO_ADDR
32518: LD_INT 6
32520: PUSH
32521: LD_VAR 0 7
32525: MINUS
32526: PUSH
32527: FOR_TO
32528: IFFALSE 32603
// begin if i = sort then
32530: LD_VAR 0 3
32534: PUSH
32535: LD_VAR 0 9
32539: EQUAL
32540: IFFALSE 32544
// break ;
32542: GO 32603
// p := Insert ( p , p + 1 , sort [ i ] ) ;
32544: LD_ADDR_VAR 0 11
32548: PUSH
32549: LD_VAR 0 11
32553: PPUSH
32554: LD_VAR 0 11
32558: PUSH
32559: LD_INT 1
32561: PLUS
32562: PPUSH
32563: LD_VAR 0 9
32567: PUSH
32568: LD_VAR 0 3
32572: ARRAY
32573: PPUSH
32574: CALL_OW 2
32578: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
32579: LD_ADDR_VAR 0 4
32583: PUSH
32584: LD_VAR 0 4
32588: PUSH
32589: LD_VAR 0 9
32593: PUSH
32594: LD_VAR 0 3
32598: ARRAY
32599: DIFF
32600: ST_TO_ADDR
// end ;
32601: GO 32527
32603: POP
32604: POP
// if p then
32605: LD_VAR 0 11
32609: IFFALSE 32634
// result := Replace ( result , 3 , p ) ;
32611: LD_ADDR_VAR 0 2
32615: PUSH
32616: LD_VAR 0 2
32620: PPUSH
32621: LD_INT 3
32623: PPUSH
32624: LD_VAR 0 11
32628: PPUSH
32629: CALL_OW 1
32633: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
32634: LD_ADDR_VAR 0 4
32638: PUSH
32639: LD_VAR 0 4
32643: PUSH
32644: LD_VAR 0 6
32648: DIFF
32649: ST_TO_ADDR
// if tmp and eng < 4 then
32650: LD_VAR 0 4
32654: PUSH
32655: LD_VAR 0 6
32659: PUSH
32660: LD_INT 4
32662: LESS
32663: AND
32664: IFFALSE 32825
// begin sort := SortBySkill ( tmp , 2 ) ;
32666: LD_ADDR_VAR 0 9
32670: PUSH
32671: LD_VAR 0 4
32675: PPUSH
32676: LD_INT 2
32678: PPUSH
32679: CALL 94783 0 2
32683: ST_TO_ADDR
// p := [ ] ;
32684: LD_ADDR_VAR 0 11
32688: PUSH
32689: EMPTY
32690: ST_TO_ADDR
// if sort then
32691: LD_VAR 0 9
32695: IFFALSE 32794
// for i = 1 to 4 - eng do
32697: LD_ADDR_VAR 0 3
32701: PUSH
32702: DOUBLE
32703: LD_INT 1
32705: DEC
32706: ST_TO_ADDR
32707: LD_INT 4
32709: PUSH
32710: LD_VAR 0 6
32714: MINUS
32715: PUSH
32716: FOR_TO
32717: IFFALSE 32792
// begin if i = sort then
32719: LD_VAR 0 3
32723: PUSH
32724: LD_VAR 0 9
32728: EQUAL
32729: IFFALSE 32733
// break ;
32731: GO 32792
// p := Insert ( p , p + 1 , sort [ i ] ) ;
32733: LD_ADDR_VAR 0 11
32737: PUSH
32738: LD_VAR 0 11
32742: PPUSH
32743: LD_VAR 0 11
32747: PUSH
32748: LD_INT 1
32750: PLUS
32751: PPUSH
32752: LD_VAR 0 9
32756: PUSH
32757: LD_VAR 0 3
32761: ARRAY
32762: PPUSH
32763: CALL_OW 2
32767: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
32768: LD_ADDR_VAR 0 4
32772: PUSH
32773: LD_VAR 0 4
32777: PUSH
32778: LD_VAR 0 9
32782: PUSH
32783: LD_VAR 0 3
32787: ARRAY
32788: DIFF
32789: ST_TO_ADDR
// end ;
32790: GO 32716
32792: POP
32793: POP
// if p then
32794: LD_VAR 0 11
32798: IFFALSE 32823
// result := Replace ( result , 2 , p ) ;
32800: LD_ADDR_VAR 0 2
32804: PUSH
32805: LD_VAR 0 2
32809: PPUSH
32810: LD_INT 2
32812: PPUSH
32813: LD_VAR 0 11
32817: PPUSH
32818: CALL_OW 1
32822: ST_TO_ADDR
// end else
32823: GO 32869
// for i = eng downto 5 do
32825: LD_ADDR_VAR 0 3
32829: PUSH
32830: DOUBLE
32831: LD_VAR 0 6
32835: INC
32836: ST_TO_ADDR
32837: LD_INT 5
32839: PUSH
32840: FOR_DOWNTO
32841: IFFALSE 32867
// tmp := tmp union eng [ i ] ;
32843: LD_ADDR_VAR 0 4
32847: PUSH
32848: LD_VAR 0 4
32852: PUSH
32853: LD_VAR 0 6
32857: PUSH
32858: LD_VAR 0 3
32862: ARRAY
32863: UNION
32864: ST_TO_ADDR
32865: GO 32840
32867: POP
32868: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
32869: LD_ADDR_VAR 0 2
32873: PUSH
32874: LD_VAR 0 2
32878: PPUSH
32879: LD_INT 1
32881: PPUSH
32882: LD_VAR 0 4
32886: PUSH
32887: LD_VAR 0 5
32891: DIFF
32892: PPUSH
32893: CALL_OW 1
32897: ST_TO_ADDR
// exit ;
32898: GO 32900
// end ; end ;
32900: LD_VAR 0 2
32904: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
32905: LD_INT 0
32907: PPUSH
32908: PPUSH
32909: PPUSH
// if not mc_bases then
32910: LD_EXP 93
32914: NOT
32915: IFFALSE 32919
// exit ;
32917: GO 33025
// for i = 1 to mc_bases do
32919: LD_ADDR_VAR 0 2
32923: PUSH
32924: DOUBLE
32925: LD_INT 1
32927: DEC
32928: ST_TO_ADDR
32929: LD_EXP 93
32933: PUSH
32934: FOR_TO
32935: IFFALSE 33016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
32937: LD_ADDR_VAR 0 3
32941: PUSH
32942: LD_EXP 93
32946: PUSH
32947: LD_VAR 0 2
32951: ARRAY
32952: PPUSH
32953: LD_INT 21
32955: PUSH
32956: LD_INT 3
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 3
32965: PUSH
32966: LD_INT 24
32968: PUSH
32969: LD_INT 1000
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PPUSH
32984: CALL_OW 72
32988: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
32989: LD_ADDR_EXP 94
32993: PUSH
32994: LD_EXP 94
32998: PPUSH
32999: LD_VAR 0 2
33003: PPUSH
33004: LD_VAR 0 3
33008: PPUSH
33009: CALL_OW 1
33013: ST_TO_ADDR
// end ;
33014: GO 32934
33016: POP
33017: POP
// RaiseSailEvent ( 101 ) ;
33018: LD_INT 101
33020: PPUSH
33021: CALL_OW 427
// end ;
33025: LD_VAR 0 1
33029: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
33030: LD_INT 0
33032: PPUSH
33033: PPUSH
33034: PPUSH
33035: PPUSH
33036: PPUSH
33037: PPUSH
33038: PPUSH
// if not mc_bases then
33039: LD_EXP 93
33043: NOT
33044: IFFALSE 33048
// exit ;
33046: GO 33621
// for i = 1 to mc_bases do
33048: LD_ADDR_VAR 0 2
33052: PUSH
33053: DOUBLE
33054: LD_INT 1
33056: DEC
33057: ST_TO_ADDR
33058: LD_EXP 93
33062: PUSH
33063: FOR_TO
33064: IFFALSE 33612
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
33066: LD_ADDR_VAR 0 5
33070: PUSH
33071: LD_EXP 93
33075: PUSH
33076: LD_VAR 0 2
33080: ARRAY
33081: PUSH
33082: LD_EXP 122
33086: PUSH
33087: LD_VAR 0 2
33091: ARRAY
33092: UNION
33093: PPUSH
33094: LD_INT 21
33096: PUSH
33097: LD_INT 1
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: PUSH
33107: LD_INT 3
33109: PUSH
33110: LD_INT 54
33112: PUSH
33113: EMPTY
33114: LIST
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 3
33122: PUSH
33123: LD_INT 24
33125: PUSH
33126: LD_INT 750
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: LIST
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PPUSH
33146: CALL_OW 72
33150: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
33151: LD_ADDR_VAR 0 6
33155: PUSH
33156: LD_EXP 93
33160: PUSH
33161: LD_VAR 0 2
33165: ARRAY
33166: PPUSH
33167: LD_INT 21
33169: PUSH
33170: LD_INT 1
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 1
33179: PUSH
33180: LD_INT 3
33182: PUSH
33183: LD_INT 54
33185: PUSH
33186: EMPTY
33187: LIST
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 3
33195: PUSH
33196: LD_INT 24
33198: PUSH
33199: LD_INT 250
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: LIST
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PPUSH
33219: CALL_OW 72
33223: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
33224: LD_ADDR_VAR 0 7
33228: PUSH
33229: LD_VAR 0 5
33233: PUSH
33234: LD_VAR 0 6
33238: DIFF
33239: ST_TO_ADDR
// if not need_heal_1 then
33240: LD_VAR 0 6
33244: NOT
33245: IFFALSE 33278
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
33247: LD_ADDR_EXP 96
33251: PUSH
33252: LD_EXP 96
33256: PPUSH
33257: LD_VAR 0 2
33261: PUSH
33262: LD_INT 1
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PPUSH
33269: EMPTY
33270: PPUSH
33271: CALL 60598 0 3
33275: ST_TO_ADDR
33276: GO 33348
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
33278: LD_ADDR_EXP 96
33282: PUSH
33283: LD_EXP 96
33287: PPUSH
33288: LD_VAR 0 2
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PPUSH
33300: LD_EXP 96
33304: PUSH
33305: LD_VAR 0 2
33309: ARRAY
33310: PUSH
33311: LD_INT 1
33313: ARRAY
33314: PPUSH
33315: LD_INT 3
33317: PUSH
33318: LD_INT 24
33320: PUSH
33321: LD_INT 1000
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PPUSH
33332: CALL_OW 72
33336: PUSH
33337: LD_VAR 0 6
33341: UNION
33342: PPUSH
33343: CALL 60598 0 3
33347: ST_TO_ADDR
// if not need_heal_2 then
33348: LD_VAR 0 7
33352: NOT
33353: IFFALSE 33386
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
33355: LD_ADDR_EXP 96
33359: PUSH
33360: LD_EXP 96
33364: PPUSH
33365: LD_VAR 0 2
33369: PUSH
33370: LD_INT 2
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PPUSH
33377: EMPTY
33378: PPUSH
33379: CALL 60598 0 3
33383: ST_TO_ADDR
33384: GO 33418
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
33386: LD_ADDR_EXP 96
33390: PUSH
33391: LD_EXP 96
33395: PPUSH
33396: LD_VAR 0 2
33400: PUSH
33401: LD_INT 2
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PPUSH
33408: LD_VAR 0 7
33412: PPUSH
33413: CALL 60598 0 3
33417: ST_TO_ADDR
// if need_heal_2 then
33418: LD_VAR 0 7
33422: IFFALSE 33594
// for j in need_heal_2 do
33424: LD_ADDR_VAR 0 3
33428: PUSH
33429: LD_VAR 0 7
33433: PUSH
33434: FOR_IN
33435: IFFALSE 33592
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
33437: LD_ADDR_VAR 0 5
33441: PUSH
33442: LD_EXP 93
33446: PUSH
33447: LD_VAR 0 2
33451: ARRAY
33452: PPUSH
33453: LD_INT 2
33455: PUSH
33456: LD_INT 30
33458: PUSH
33459: LD_INT 6
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 30
33468: PUSH
33469: LD_INT 7
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 30
33478: PUSH
33479: LD_INT 8
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 30
33488: PUSH
33489: LD_INT 0
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 30
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 25
33508: PUSH
33509: LD_INT 4
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: LIST
33522: LIST
33523: LIST
33524: PPUSH
33525: CALL_OW 72
33529: ST_TO_ADDR
// if tmp then
33530: LD_VAR 0 5
33534: IFFALSE 33590
// begin k := NearestUnitToUnit ( tmp , j ) ;
33536: LD_ADDR_VAR 0 4
33540: PUSH
33541: LD_VAR 0 5
33545: PPUSH
33546: LD_VAR 0 3
33550: PPUSH
33551: CALL_OW 74
33555: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
33556: LD_VAR 0 3
33560: PPUSH
33561: LD_VAR 0 4
33565: PPUSH
33566: CALL_OW 296
33570: PUSH
33571: LD_INT 7
33573: GREATER
33574: IFFALSE 33590
// ComMoveUnit ( j , k ) ;
33576: LD_VAR 0 3
33580: PPUSH
33581: LD_VAR 0 4
33585: PPUSH
33586: CALL_OW 112
// end ; end ;
33590: GO 33434
33592: POP
33593: POP
// if not need_heal_1 and not need_heal_2 then
33594: LD_VAR 0 6
33598: NOT
33599: PUSH
33600: LD_VAR 0 7
33604: NOT
33605: AND
33606: IFFALSE 33610
// continue ;
33608: GO 33063
// end ;
33610: GO 33063
33612: POP
33613: POP
// RaiseSailEvent ( 102 ) ;
33614: LD_INT 102
33616: PPUSH
33617: CALL_OW 427
// end ;
33621: LD_VAR 0 1
33625: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
33626: LD_INT 0
33628: PPUSH
33629: PPUSH
33630: PPUSH
33631: PPUSH
33632: PPUSH
// if not mc_bases then
33633: LD_EXP 93
33637: NOT
33638: IFFALSE 33642
// exit ;
33640: GO 34027
// for i = 1 to mc_bases do
33642: LD_ADDR_VAR 0 2
33646: PUSH
33647: DOUBLE
33648: LD_INT 1
33650: DEC
33651: ST_TO_ADDR
33652: LD_EXP 93
33656: PUSH
33657: FOR_TO
33658: IFFALSE 34025
// begin if not mc_building_need_repair [ i ] then
33660: LD_EXP 94
33664: PUSH
33665: LD_VAR 0 2
33669: ARRAY
33670: NOT
33671: IFFALSE 33709
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
33673: LD_ADDR_EXP 95
33677: PUSH
33678: LD_EXP 95
33682: PPUSH
33683: LD_VAR 0 2
33687: PPUSH
33688: EMPTY
33689: PPUSH
33690: CALL_OW 1
33694: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
33695: LD_VAR 0 2
33699: PPUSH
33700: LD_INT 101
33702: PPUSH
33703: CALL 29070 0 2
// continue ;
33707: GO 33657
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
33709: LD_ADDR_EXP 99
33713: PUSH
33714: LD_EXP 99
33718: PPUSH
33719: LD_VAR 0 2
33723: PPUSH
33724: EMPTY
33725: PPUSH
33726: CALL_OW 1
33730: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33731: LD_VAR 0 2
33735: PPUSH
33736: LD_INT 103
33738: PPUSH
33739: CALL 29070 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
33743: LD_ADDR_VAR 0 5
33747: PUSH
33748: LD_EXP 93
33752: PUSH
33753: LD_VAR 0 2
33757: ARRAY
33758: PUSH
33759: LD_EXP 122
33763: PUSH
33764: LD_VAR 0 2
33768: ARRAY
33769: UNION
33770: PPUSH
33771: LD_INT 2
33773: PUSH
33774: LD_INT 25
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 25
33786: PUSH
33787: LD_INT 16
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: LIST
33798: PUSH
33799: EMPTY
33800: LIST
33801: PPUSH
33802: CALL_OW 72
33806: ST_TO_ADDR
// if not tmp then
33807: LD_VAR 0 5
33811: NOT
33812: IFFALSE 33816
// continue ;
33814: GO 33657
// for j in tmp do
33816: LD_ADDR_VAR 0 3
33820: PUSH
33821: LD_VAR 0 5
33825: PUSH
33826: FOR_IN
33827: IFFALSE 34021
// begin if mc_need_heal [ i ] then
33829: LD_EXP 96
33833: PUSH
33834: LD_VAR 0 2
33838: ARRAY
33839: IFFALSE 33887
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
33841: LD_VAR 0 3
33845: PUSH
33846: LD_EXP 96
33850: PUSH
33851: LD_VAR 0 2
33855: ARRAY
33856: PUSH
33857: LD_INT 1
33859: ARRAY
33860: IN
33861: PUSH
33862: LD_VAR 0 3
33866: PUSH
33867: LD_EXP 96
33871: PUSH
33872: LD_VAR 0 2
33876: ARRAY
33877: PUSH
33878: LD_INT 2
33880: ARRAY
33881: IN
33882: OR
33883: IFFALSE 33887
// continue ;
33885: GO 33826
// if IsInUnit ( j ) then
33887: LD_VAR 0 3
33891: PPUSH
33892: CALL_OW 310
33896: IFFALSE 33907
// ComExitBuilding ( j ) ;
33898: LD_VAR 0 3
33902: PPUSH
33903: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
33907: LD_VAR 0 3
33911: PUSH
33912: LD_EXP 95
33916: PUSH
33917: LD_VAR 0 2
33921: ARRAY
33922: IN
33923: NOT
33924: IFFALSE 33982
// begin SetTag ( j , 101 ) ;
33926: LD_VAR 0 3
33930: PPUSH
33931: LD_INT 101
33933: PPUSH
33934: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
33938: LD_ADDR_EXP 95
33942: PUSH
33943: LD_EXP 95
33947: PPUSH
33948: LD_VAR 0 2
33952: PUSH
33953: LD_EXP 95
33957: PUSH
33958: LD_VAR 0 2
33962: ARRAY
33963: PUSH
33964: LD_INT 1
33966: PLUS
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PPUSH
33972: LD_VAR 0 3
33976: PPUSH
33977: CALL 60598 0 3
33981: ST_TO_ADDR
// end ; wait ( 1 ) ;
33982: LD_INT 1
33984: PPUSH
33985: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
33989: LD_VAR 0 3
33993: PPUSH
33994: LD_EXP 94
33998: PUSH
33999: LD_VAR 0 2
34003: ARRAY
34004: PPUSH
34005: LD_VAR 0 3
34009: PPUSH
34010: CALL_OW 74
34014: PPUSH
34015: CALL_OW 130
// end ;
34019: GO 33826
34021: POP
34022: POP
// end ;
34023: GO 33657
34025: POP
34026: POP
// end ;
34027: LD_VAR 0 1
34031: RET
// export function MC_Heal ; var i , j , tmp ; begin
34032: LD_INT 0
34034: PPUSH
34035: PPUSH
34036: PPUSH
34037: PPUSH
// if not mc_bases then
34038: LD_EXP 93
34042: NOT
34043: IFFALSE 34047
// exit ;
34045: GO 34449
// for i = 1 to mc_bases do
34047: LD_ADDR_VAR 0 2
34051: PUSH
34052: DOUBLE
34053: LD_INT 1
34055: DEC
34056: ST_TO_ADDR
34057: LD_EXP 93
34061: PUSH
34062: FOR_TO
34063: IFFALSE 34447
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
34065: LD_EXP 96
34069: PUSH
34070: LD_VAR 0 2
34074: ARRAY
34075: PUSH
34076: LD_INT 1
34078: ARRAY
34079: NOT
34080: PUSH
34081: LD_EXP 96
34085: PUSH
34086: LD_VAR 0 2
34090: ARRAY
34091: PUSH
34092: LD_INT 2
34094: ARRAY
34095: NOT
34096: AND
34097: IFFALSE 34135
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
34099: LD_ADDR_EXP 97
34103: PUSH
34104: LD_EXP 97
34108: PPUSH
34109: LD_VAR 0 2
34113: PPUSH
34114: EMPTY
34115: PPUSH
34116: CALL_OW 1
34120: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
34121: LD_VAR 0 2
34125: PPUSH
34126: LD_INT 102
34128: PPUSH
34129: CALL 29070 0 2
// continue ;
34133: GO 34062
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
34135: LD_ADDR_VAR 0 4
34139: PUSH
34140: LD_EXP 93
34144: PUSH
34145: LD_VAR 0 2
34149: ARRAY
34150: PPUSH
34151: LD_INT 25
34153: PUSH
34154: LD_INT 4
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PPUSH
34161: CALL_OW 72
34165: ST_TO_ADDR
// if not tmp then
34166: LD_VAR 0 4
34170: NOT
34171: IFFALSE 34175
// continue ;
34173: GO 34062
// if mc_taming [ i ] then
34175: LD_EXP 124
34179: PUSH
34180: LD_VAR 0 2
34184: ARRAY
34185: IFFALSE 34209
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
34187: LD_ADDR_EXP 124
34191: PUSH
34192: LD_EXP 124
34196: PPUSH
34197: LD_VAR 0 2
34201: PPUSH
34202: EMPTY
34203: PPUSH
34204: CALL_OW 1
34208: ST_TO_ADDR
// for j in tmp do
34209: LD_ADDR_VAR 0 3
34213: PUSH
34214: LD_VAR 0 4
34218: PUSH
34219: FOR_IN
34220: IFFALSE 34443
// begin if IsInUnit ( j ) then
34222: LD_VAR 0 3
34226: PPUSH
34227: CALL_OW 310
34231: IFFALSE 34242
// ComExitBuilding ( j ) ;
34233: LD_VAR 0 3
34237: PPUSH
34238: CALL_OW 122
// if not j in mc_healers [ i ] then
34242: LD_VAR 0 3
34246: PUSH
34247: LD_EXP 97
34251: PUSH
34252: LD_VAR 0 2
34256: ARRAY
34257: IN
34258: NOT
34259: IFFALSE 34305
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
34261: LD_ADDR_EXP 97
34265: PUSH
34266: LD_EXP 97
34270: PPUSH
34271: LD_VAR 0 2
34275: PUSH
34276: LD_EXP 97
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: PUSH
34287: LD_INT 1
34289: PLUS
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PPUSH
34295: LD_VAR 0 3
34299: PPUSH
34300: CALL 60598 0 3
34304: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
34305: LD_VAR 0 3
34309: PPUSH
34310: CALL_OW 110
34314: PUSH
34315: LD_INT 102
34317: NONEQUAL
34318: IFFALSE 34332
// SetTag ( j , 102 ) ;
34320: LD_VAR 0 3
34324: PPUSH
34325: LD_INT 102
34327: PPUSH
34328: CALL_OW 109
// Wait ( 3 ) ;
34332: LD_INT 3
34334: PPUSH
34335: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
34339: LD_EXP 96
34343: PUSH
34344: LD_VAR 0 2
34348: ARRAY
34349: PUSH
34350: LD_INT 1
34352: ARRAY
34353: IFFALSE 34385
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
34355: LD_VAR 0 3
34359: PPUSH
34360: LD_EXP 96
34364: PUSH
34365: LD_VAR 0 2
34369: ARRAY
34370: PUSH
34371: LD_INT 1
34373: ARRAY
34374: PUSH
34375: LD_INT 1
34377: ARRAY
34378: PPUSH
34379: CALL_OW 128
34383: GO 34441
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
34385: LD_VAR 0 3
34389: PPUSH
34390: CALL_OW 314
34394: NOT
34395: PUSH
34396: LD_EXP 96
34400: PUSH
34401: LD_VAR 0 2
34405: ARRAY
34406: PUSH
34407: LD_INT 2
34409: ARRAY
34410: AND
34411: IFFALSE 34441
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
34413: LD_VAR 0 3
34417: PPUSH
34418: LD_EXP 96
34422: PUSH
34423: LD_VAR 0 2
34427: ARRAY
34428: PUSH
34429: LD_INT 2
34431: ARRAY
34432: PUSH
34433: LD_INT 1
34435: ARRAY
34436: PPUSH
34437: CALL_OW 128
// end ;
34441: GO 34219
34443: POP
34444: POP
// end ;
34445: GO 34062
34447: POP
34448: POP
// end ;
34449: LD_VAR 0 1
34453: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
34454: LD_INT 0
34456: PPUSH
34457: PPUSH
34458: PPUSH
34459: PPUSH
34460: PPUSH
// if not mc_bases then
34461: LD_EXP 93
34465: NOT
34466: IFFALSE 34470
// exit ;
34468: GO 35613
// for i = 1 to mc_bases do
34470: LD_ADDR_VAR 0 2
34474: PUSH
34475: DOUBLE
34476: LD_INT 1
34478: DEC
34479: ST_TO_ADDR
34480: LD_EXP 93
34484: PUSH
34485: FOR_TO
34486: IFFALSE 35611
// begin if mc_scan [ i ] then
34488: LD_EXP 116
34492: PUSH
34493: LD_VAR 0 2
34497: ARRAY
34498: IFFALSE 34502
// continue ;
34500: GO 34485
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
34502: LD_EXP 98
34506: PUSH
34507: LD_VAR 0 2
34511: ARRAY
34512: NOT
34513: PUSH
34514: LD_EXP 100
34518: PUSH
34519: LD_VAR 0 2
34523: ARRAY
34524: NOT
34525: AND
34526: PUSH
34527: LD_EXP 99
34531: PUSH
34532: LD_VAR 0 2
34536: ARRAY
34537: AND
34538: IFFALSE 34576
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
34540: LD_ADDR_EXP 99
34544: PUSH
34545: LD_EXP 99
34549: PPUSH
34550: LD_VAR 0 2
34554: PPUSH
34555: EMPTY
34556: PPUSH
34557: CALL_OW 1
34561: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
34562: LD_VAR 0 2
34566: PPUSH
34567: LD_INT 103
34569: PPUSH
34570: CALL 29070 0 2
// continue ;
34574: GO 34485
// end ; if mc_construct_list [ i ] then
34576: LD_EXP 100
34580: PUSH
34581: LD_VAR 0 2
34585: ARRAY
34586: IFFALSE 34806
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34588: LD_ADDR_VAR 0 4
34592: PUSH
34593: LD_EXP 93
34597: PUSH
34598: LD_VAR 0 2
34602: ARRAY
34603: PPUSH
34604: LD_INT 25
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PPUSH
34614: CALL_OW 72
34618: PUSH
34619: LD_EXP 95
34623: PUSH
34624: LD_VAR 0 2
34628: ARRAY
34629: DIFF
34630: ST_TO_ADDR
// if not tmp then
34631: LD_VAR 0 4
34635: NOT
34636: IFFALSE 34640
// continue ;
34638: GO 34485
// for j in tmp do
34640: LD_ADDR_VAR 0 3
34644: PUSH
34645: LD_VAR 0 4
34649: PUSH
34650: FOR_IN
34651: IFFALSE 34802
// begin if not mc_builders [ i ] then
34653: LD_EXP 99
34657: PUSH
34658: LD_VAR 0 2
34662: ARRAY
34663: NOT
34664: IFFALSE 34722
// begin SetTag ( j , 103 ) ;
34666: LD_VAR 0 3
34670: PPUSH
34671: LD_INT 103
34673: PPUSH
34674: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34678: LD_ADDR_EXP 99
34682: PUSH
34683: LD_EXP 99
34687: PPUSH
34688: LD_VAR 0 2
34692: PUSH
34693: LD_EXP 99
34697: PUSH
34698: LD_VAR 0 2
34702: ARRAY
34703: PUSH
34704: LD_INT 1
34706: PLUS
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PPUSH
34712: LD_VAR 0 3
34716: PPUSH
34717: CALL 60598 0 3
34721: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34722: LD_VAR 0 3
34726: PPUSH
34727: CALL_OW 310
34731: IFFALSE 34742
// ComExitBuilding ( j ) ;
34733: LD_VAR 0 3
34737: PPUSH
34738: CALL_OW 122
// wait ( 3 ) ;
34742: LD_INT 3
34744: PPUSH
34745: CALL_OW 67
// if not mc_construct_list [ i ] then
34749: LD_EXP 100
34753: PUSH
34754: LD_VAR 0 2
34758: ARRAY
34759: NOT
34760: IFFALSE 34764
// break ;
34762: GO 34802
// if not HasTask ( j ) then
34764: LD_VAR 0 3
34768: PPUSH
34769: CALL_OW 314
34773: NOT
34774: IFFALSE 34800
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
34776: LD_VAR 0 3
34780: PPUSH
34781: LD_EXP 100
34785: PUSH
34786: LD_VAR 0 2
34790: ARRAY
34791: PUSH
34792: LD_INT 1
34794: ARRAY
34795: PPUSH
34796: CALL 63449 0 2
// end ;
34800: GO 34650
34802: POP
34803: POP
// end else
34804: GO 35609
// if mc_build_list [ i ] then
34806: LD_EXP 98
34810: PUSH
34811: LD_VAR 0 2
34815: ARRAY
34816: IFFALSE 35609
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34818: LD_ADDR_VAR 0 5
34822: PUSH
34823: LD_EXP 93
34827: PUSH
34828: LD_VAR 0 2
34832: ARRAY
34833: PPUSH
34834: LD_INT 2
34836: PUSH
34837: LD_INT 30
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 30
34849: PUSH
34850: LD_INT 1
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: LIST
34861: PPUSH
34862: CALL_OW 72
34866: ST_TO_ADDR
// if depot then
34867: LD_VAR 0 5
34871: IFFALSE 34889
// depot := depot [ 1 ] else
34873: LD_ADDR_VAR 0 5
34877: PUSH
34878: LD_VAR 0 5
34882: PUSH
34883: LD_INT 1
34885: ARRAY
34886: ST_TO_ADDR
34887: GO 34897
// depot := 0 ;
34889: LD_ADDR_VAR 0 5
34893: PUSH
34894: LD_INT 0
34896: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
34897: LD_EXP 98
34901: PUSH
34902: LD_VAR 0 2
34906: ARRAY
34907: PUSH
34908: LD_INT 1
34910: ARRAY
34911: PUSH
34912: LD_INT 1
34914: ARRAY
34915: PPUSH
34916: CALL 63279 0 1
34920: PUSH
34921: LD_EXP 93
34925: PUSH
34926: LD_VAR 0 2
34930: ARRAY
34931: PPUSH
34932: LD_INT 2
34934: PUSH
34935: LD_INT 30
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 30
34947: PUSH
34948: LD_INT 3
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: LIST
34959: PPUSH
34960: CALL_OW 72
34964: NOT
34965: AND
34966: IFFALSE 35071
// begin for j = 1 to mc_build_list [ i ] do
34968: LD_ADDR_VAR 0 3
34972: PUSH
34973: DOUBLE
34974: LD_INT 1
34976: DEC
34977: ST_TO_ADDR
34978: LD_EXP 98
34982: PUSH
34983: LD_VAR 0 2
34987: ARRAY
34988: PUSH
34989: FOR_TO
34990: IFFALSE 35069
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
34992: LD_EXP 98
34996: PUSH
34997: LD_VAR 0 2
35001: ARRAY
35002: PUSH
35003: LD_VAR 0 3
35007: ARRAY
35008: PUSH
35009: LD_INT 1
35011: ARRAY
35012: PUSH
35013: LD_INT 2
35015: EQUAL
35016: IFFALSE 35067
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
35018: LD_ADDR_EXP 98
35022: PUSH
35023: LD_EXP 98
35027: PPUSH
35028: LD_VAR 0 2
35032: PPUSH
35033: LD_EXP 98
35037: PUSH
35038: LD_VAR 0 2
35042: ARRAY
35043: PPUSH
35044: LD_VAR 0 3
35048: PPUSH
35049: LD_INT 1
35051: PPUSH
35052: LD_INT 0
35054: PPUSH
35055: CALL 60016 0 4
35059: PPUSH
35060: CALL_OW 1
35064: ST_TO_ADDR
// break ;
35065: GO 35069
// end ;
35067: GO 34989
35069: POP
35070: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
35071: LD_EXP 98
35075: PUSH
35076: LD_VAR 0 2
35080: ARRAY
35081: PUSH
35082: LD_INT 1
35084: ARRAY
35085: PUSH
35086: LD_INT 1
35088: ARRAY
35089: PUSH
35090: LD_INT 0
35092: EQUAL
35093: PUSH
35094: LD_VAR 0 5
35098: PUSH
35099: LD_VAR 0 5
35103: PPUSH
35104: LD_EXP 98
35108: PUSH
35109: LD_VAR 0 2
35113: ARRAY
35114: PUSH
35115: LD_INT 1
35117: ARRAY
35118: PUSH
35119: LD_INT 1
35121: ARRAY
35122: PPUSH
35123: LD_EXP 98
35127: PUSH
35128: LD_VAR 0 2
35132: ARRAY
35133: PUSH
35134: LD_INT 1
35136: ARRAY
35137: PUSH
35138: LD_INT 2
35140: ARRAY
35141: PPUSH
35142: LD_EXP 98
35146: PUSH
35147: LD_VAR 0 2
35151: ARRAY
35152: PUSH
35153: LD_INT 1
35155: ARRAY
35156: PUSH
35157: LD_INT 3
35159: ARRAY
35160: PPUSH
35161: LD_EXP 98
35165: PUSH
35166: LD_VAR 0 2
35170: ARRAY
35171: PUSH
35172: LD_INT 1
35174: ARRAY
35175: PUSH
35176: LD_INT 4
35178: ARRAY
35179: PPUSH
35180: CALL 67995 0 5
35184: AND
35185: OR
35186: IFFALSE 35467
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
35188: LD_ADDR_VAR 0 4
35192: PUSH
35193: LD_EXP 93
35197: PUSH
35198: LD_VAR 0 2
35202: ARRAY
35203: PPUSH
35204: LD_INT 25
35206: PUSH
35207: LD_INT 2
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PPUSH
35214: CALL_OW 72
35218: PUSH
35219: LD_EXP 95
35223: PUSH
35224: LD_VAR 0 2
35228: ARRAY
35229: DIFF
35230: ST_TO_ADDR
// if not tmp then
35231: LD_VAR 0 4
35235: NOT
35236: IFFALSE 35240
// continue ;
35238: GO 34485
// for j in tmp do
35240: LD_ADDR_VAR 0 3
35244: PUSH
35245: LD_VAR 0 4
35249: PUSH
35250: FOR_IN
35251: IFFALSE 35463
// begin if not mc_builders [ i ] then
35253: LD_EXP 99
35257: PUSH
35258: LD_VAR 0 2
35262: ARRAY
35263: NOT
35264: IFFALSE 35322
// begin SetTag ( j , 103 ) ;
35266: LD_VAR 0 3
35270: PPUSH
35271: LD_INT 103
35273: PPUSH
35274: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
35278: LD_ADDR_EXP 99
35282: PUSH
35283: LD_EXP 99
35287: PPUSH
35288: LD_VAR 0 2
35292: PUSH
35293: LD_EXP 99
35297: PUSH
35298: LD_VAR 0 2
35302: ARRAY
35303: PUSH
35304: LD_INT 1
35306: PLUS
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PPUSH
35312: LD_VAR 0 3
35316: PPUSH
35317: CALL 60598 0 3
35321: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
35322: LD_VAR 0 3
35326: PPUSH
35327: CALL_OW 310
35331: IFFALSE 35342
// ComExitBuilding ( j ) ;
35333: LD_VAR 0 3
35337: PPUSH
35338: CALL_OW 122
// wait ( 3 ) ;
35342: LD_INT 3
35344: PPUSH
35345: CALL_OW 67
// if not mc_build_list [ i ] then
35349: LD_EXP 98
35353: PUSH
35354: LD_VAR 0 2
35358: ARRAY
35359: NOT
35360: IFFALSE 35364
// break ;
35362: GO 35463
// if not HasTask ( j ) then
35364: LD_VAR 0 3
35368: PPUSH
35369: CALL_OW 314
35373: NOT
35374: IFFALSE 35461
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
35376: LD_VAR 0 3
35380: PPUSH
35381: LD_EXP 98
35385: PUSH
35386: LD_VAR 0 2
35390: ARRAY
35391: PUSH
35392: LD_INT 1
35394: ARRAY
35395: PUSH
35396: LD_INT 1
35398: ARRAY
35399: PPUSH
35400: LD_EXP 98
35404: PUSH
35405: LD_VAR 0 2
35409: ARRAY
35410: PUSH
35411: LD_INT 1
35413: ARRAY
35414: PUSH
35415: LD_INT 2
35417: ARRAY
35418: PPUSH
35419: LD_EXP 98
35423: PUSH
35424: LD_VAR 0 2
35428: ARRAY
35429: PUSH
35430: LD_INT 1
35432: ARRAY
35433: PUSH
35434: LD_INT 3
35436: ARRAY
35437: PPUSH
35438: LD_EXP 98
35442: PUSH
35443: LD_VAR 0 2
35447: ARRAY
35448: PUSH
35449: LD_INT 1
35451: ARRAY
35452: PUSH
35453: LD_INT 4
35455: ARRAY
35456: PPUSH
35457: CALL_OW 145
// end ;
35461: GO 35250
35463: POP
35464: POP
// end else
35465: GO 35609
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
35467: LD_EXP 93
35471: PUSH
35472: LD_VAR 0 2
35476: ARRAY
35477: PPUSH
35478: LD_EXP 98
35482: PUSH
35483: LD_VAR 0 2
35487: ARRAY
35488: PUSH
35489: LD_INT 1
35491: ARRAY
35492: PUSH
35493: LD_INT 1
35495: ARRAY
35496: PPUSH
35497: LD_EXP 98
35501: PUSH
35502: LD_VAR 0 2
35506: ARRAY
35507: PUSH
35508: LD_INT 1
35510: ARRAY
35511: PUSH
35512: LD_INT 2
35514: ARRAY
35515: PPUSH
35516: LD_EXP 98
35520: PUSH
35521: LD_VAR 0 2
35525: ARRAY
35526: PUSH
35527: LD_INT 1
35529: ARRAY
35530: PUSH
35531: LD_INT 3
35533: ARRAY
35534: PPUSH
35535: LD_EXP 98
35539: PUSH
35540: LD_VAR 0 2
35544: ARRAY
35545: PUSH
35546: LD_INT 1
35548: ARRAY
35549: PUSH
35550: LD_INT 4
35552: ARRAY
35553: PPUSH
35554: CALL 67349 0 5
35558: NOT
35559: IFFALSE 35609
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
35561: LD_ADDR_EXP 98
35565: PUSH
35566: LD_EXP 98
35570: PPUSH
35571: LD_VAR 0 2
35575: PPUSH
35576: LD_EXP 98
35580: PUSH
35581: LD_VAR 0 2
35585: ARRAY
35586: PPUSH
35587: LD_INT 1
35589: PPUSH
35590: LD_INT 1
35592: NEG
35593: PPUSH
35594: LD_INT 0
35596: PPUSH
35597: CALL 60016 0 4
35601: PPUSH
35602: CALL_OW 1
35606: ST_TO_ADDR
// continue ;
35607: GO 34485
// end ; end ; end ;
35609: GO 34485
35611: POP
35612: POP
// end ;
35613: LD_VAR 0 1
35617: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
35618: LD_INT 0
35620: PPUSH
35621: PPUSH
35622: PPUSH
35623: PPUSH
35624: PPUSH
35625: PPUSH
// if not mc_bases then
35626: LD_EXP 93
35630: NOT
35631: IFFALSE 35635
// exit ;
35633: GO 36062
// for i = 1 to mc_bases do
35635: LD_ADDR_VAR 0 2
35639: PUSH
35640: DOUBLE
35641: LD_INT 1
35643: DEC
35644: ST_TO_ADDR
35645: LD_EXP 93
35649: PUSH
35650: FOR_TO
35651: IFFALSE 36060
// begin tmp := mc_build_upgrade [ i ] ;
35653: LD_ADDR_VAR 0 4
35657: PUSH
35658: LD_EXP 125
35662: PUSH
35663: LD_VAR 0 2
35667: ARRAY
35668: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
35669: LD_ADDR_VAR 0 6
35673: PUSH
35674: LD_EXP 126
35678: PUSH
35679: LD_VAR 0 2
35683: ARRAY
35684: PPUSH
35685: LD_INT 2
35687: PUSH
35688: LD_INT 30
35690: PUSH
35691: LD_INT 6
35693: PUSH
35694: EMPTY
35695: LIST
35696: LIST
35697: PUSH
35698: LD_INT 30
35700: PUSH
35701: LD_INT 7
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: LIST
35712: PPUSH
35713: CALL_OW 72
35717: ST_TO_ADDR
// if not tmp and not lab then
35718: LD_VAR 0 4
35722: NOT
35723: PUSH
35724: LD_VAR 0 6
35728: NOT
35729: AND
35730: IFFALSE 35734
// continue ;
35732: GO 35650
// if tmp then
35734: LD_VAR 0 4
35738: IFFALSE 35858
// for j in tmp do
35740: LD_ADDR_VAR 0 3
35744: PUSH
35745: LD_VAR 0 4
35749: PUSH
35750: FOR_IN
35751: IFFALSE 35856
// begin if UpgradeCost ( j ) then
35753: LD_VAR 0 3
35757: PPUSH
35758: CALL 67009 0 1
35762: IFFALSE 35854
// begin ComUpgrade ( j ) ;
35764: LD_VAR 0 3
35768: PPUSH
35769: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
35773: LD_ADDR_EXP 125
35777: PUSH
35778: LD_EXP 125
35782: PPUSH
35783: LD_VAR 0 2
35787: PPUSH
35788: LD_EXP 125
35792: PUSH
35793: LD_VAR 0 2
35797: ARRAY
35798: PUSH
35799: LD_VAR 0 3
35803: DIFF
35804: PPUSH
35805: CALL_OW 1
35809: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
35810: LD_ADDR_EXP 100
35814: PUSH
35815: LD_EXP 100
35819: PPUSH
35820: LD_VAR 0 2
35824: PUSH
35825: LD_EXP 100
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 1
35838: PLUS
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PPUSH
35844: LD_VAR 0 3
35848: PPUSH
35849: CALL 60598 0 3
35853: ST_TO_ADDR
// end ; end ;
35854: GO 35750
35856: POP
35857: POP
// if not lab or not mc_lab_upgrade [ i ] then
35858: LD_VAR 0 6
35862: NOT
35863: PUSH
35864: LD_EXP 127
35868: PUSH
35869: LD_VAR 0 2
35873: ARRAY
35874: NOT
35875: OR
35876: IFFALSE 35880
// continue ;
35878: GO 35650
// for j in lab do
35880: LD_ADDR_VAR 0 3
35884: PUSH
35885: LD_VAR 0 6
35889: PUSH
35890: FOR_IN
35891: IFFALSE 36056
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
35893: LD_VAR 0 3
35897: PPUSH
35898: CALL_OW 266
35902: PUSH
35903: LD_INT 6
35905: PUSH
35906: LD_INT 7
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: IN
35913: PUSH
35914: LD_VAR 0 3
35918: PPUSH
35919: CALL_OW 461
35923: PUSH
35924: LD_INT 1
35926: NONEQUAL
35927: AND
35928: IFFALSE 36054
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
35930: LD_VAR 0 3
35934: PPUSH
35935: LD_EXP 127
35939: PUSH
35940: LD_VAR 0 2
35944: ARRAY
35945: PUSH
35946: LD_INT 1
35948: ARRAY
35949: PPUSH
35950: CALL 67214 0 2
35954: IFFALSE 36054
// begin ComCancel ( j ) ;
35956: LD_VAR 0 3
35960: PPUSH
35961: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
35965: LD_VAR 0 3
35969: PPUSH
35970: LD_EXP 127
35974: PUSH
35975: LD_VAR 0 2
35979: ARRAY
35980: PUSH
35981: LD_INT 1
35983: ARRAY
35984: PPUSH
35985: CALL_OW 207
// if not j in mc_construct_list [ i ] then
35989: LD_VAR 0 3
35993: PUSH
35994: LD_EXP 100
35998: PUSH
35999: LD_VAR 0 2
36003: ARRAY
36004: IN
36005: NOT
36006: IFFALSE 36052
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
36008: LD_ADDR_EXP 100
36012: PUSH
36013: LD_EXP 100
36017: PPUSH
36018: LD_VAR 0 2
36022: PUSH
36023: LD_EXP 100
36027: PUSH
36028: LD_VAR 0 2
36032: ARRAY
36033: PUSH
36034: LD_INT 1
36036: PLUS
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PPUSH
36042: LD_VAR 0 3
36046: PPUSH
36047: CALL 60598 0 3
36051: ST_TO_ADDR
// break ;
36052: GO 36056
// end ; end ; end ;
36054: GO 35890
36056: POP
36057: POP
// end ;
36058: GO 35650
36060: POP
36061: POP
// end ;
36062: LD_VAR 0 1
36066: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
36067: LD_INT 0
36069: PPUSH
36070: PPUSH
36071: PPUSH
36072: PPUSH
36073: PPUSH
36074: PPUSH
36075: PPUSH
36076: PPUSH
36077: PPUSH
// if not mc_bases then
36078: LD_EXP 93
36082: NOT
36083: IFFALSE 36087
// exit ;
36085: GO 36492
// for i = 1 to mc_bases do
36087: LD_ADDR_VAR 0 2
36091: PUSH
36092: DOUBLE
36093: LD_INT 1
36095: DEC
36096: ST_TO_ADDR
36097: LD_EXP 93
36101: PUSH
36102: FOR_TO
36103: IFFALSE 36490
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
36105: LD_EXP 101
36109: PUSH
36110: LD_VAR 0 2
36114: ARRAY
36115: NOT
36116: PUSH
36117: LD_EXP 93
36121: PUSH
36122: LD_VAR 0 2
36126: ARRAY
36127: PPUSH
36128: LD_INT 30
36130: PUSH
36131: LD_INT 3
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PPUSH
36138: CALL_OW 72
36142: NOT
36143: OR
36144: IFFALSE 36148
// continue ;
36146: GO 36102
// busy := false ;
36148: LD_ADDR_VAR 0 8
36152: PUSH
36153: LD_INT 0
36155: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36156: LD_ADDR_VAR 0 4
36160: PUSH
36161: LD_EXP 93
36165: PUSH
36166: LD_VAR 0 2
36170: ARRAY
36171: PPUSH
36172: LD_INT 30
36174: PUSH
36175: LD_INT 3
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PPUSH
36182: CALL_OW 72
36186: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
36187: LD_ADDR_VAR 0 6
36191: PUSH
36192: LD_EXP 101
36196: PUSH
36197: LD_VAR 0 2
36201: ARRAY
36202: PPUSH
36203: LD_INT 2
36205: PUSH
36206: LD_INT 30
36208: PUSH
36209: LD_INT 32
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 30
36218: PUSH
36219: LD_INT 33
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: LIST
36230: PPUSH
36231: CALL_OW 72
36235: ST_TO_ADDR
// if not t then
36236: LD_VAR 0 6
36240: NOT
36241: IFFALSE 36245
// continue ;
36243: GO 36102
// for j in tmp do
36245: LD_ADDR_VAR 0 3
36249: PUSH
36250: LD_VAR 0 4
36254: PUSH
36255: FOR_IN
36256: IFFALSE 36286
// if not BuildingStatus ( j ) = bs_idle then
36258: LD_VAR 0 3
36262: PPUSH
36263: CALL_OW 461
36267: PUSH
36268: LD_INT 2
36270: EQUAL
36271: NOT
36272: IFFALSE 36284
// begin busy := true ;
36274: LD_ADDR_VAR 0 8
36278: PUSH
36279: LD_INT 1
36281: ST_TO_ADDR
// break ;
36282: GO 36286
// end ;
36284: GO 36255
36286: POP
36287: POP
// if busy then
36288: LD_VAR 0 8
36292: IFFALSE 36296
// continue ;
36294: GO 36102
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
36296: LD_ADDR_VAR 0 7
36300: PUSH
36301: LD_VAR 0 6
36305: PPUSH
36306: LD_INT 35
36308: PUSH
36309: LD_INT 0
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PPUSH
36316: CALL_OW 72
36320: ST_TO_ADDR
// if tw then
36321: LD_VAR 0 7
36325: IFFALSE 36402
// begin tw := tw [ 1 ] ;
36327: LD_ADDR_VAR 0 7
36331: PUSH
36332: LD_VAR 0 7
36336: PUSH
36337: LD_INT 1
36339: ARRAY
36340: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
36341: LD_ADDR_VAR 0 9
36345: PUSH
36346: LD_VAR 0 7
36350: PPUSH
36351: LD_EXP 118
36355: PUSH
36356: LD_VAR 0 2
36360: ARRAY
36361: PPUSH
36362: CALL 65568 0 2
36366: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
36367: LD_EXP 132
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: IFFALSE 36400
// if not weapon in mc_allowed_tower_weapons [ i ] then
36379: LD_VAR 0 9
36383: PUSH
36384: LD_EXP 132
36388: PUSH
36389: LD_VAR 0 2
36393: ARRAY
36394: IN
36395: NOT
36396: IFFALSE 36400
// continue ;
36398: GO 36102
// end else
36400: GO 36465
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
36402: LD_ADDR_VAR 0 5
36406: PUSH
36407: LD_EXP 101
36411: PUSH
36412: LD_VAR 0 2
36416: ARRAY
36417: PPUSH
36418: LD_VAR 0 4
36422: PPUSH
36423: CALL 95707 0 2
36427: ST_TO_ADDR
// if not tmp2 then
36428: LD_VAR 0 5
36432: NOT
36433: IFFALSE 36437
// continue ;
36435: GO 36102
// tw := tmp2 [ 1 ] ;
36437: LD_ADDR_VAR 0 7
36441: PUSH
36442: LD_VAR 0 5
36446: PUSH
36447: LD_INT 1
36449: ARRAY
36450: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
36451: LD_ADDR_VAR 0 9
36455: PUSH
36456: LD_VAR 0 5
36460: PUSH
36461: LD_INT 2
36463: ARRAY
36464: ST_TO_ADDR
// end ; if not weapon then
36465: LD_VAR 0 9
36469: NOT
36470: IFFALSE 36474
// continue ;
36472: GO 36102
// ComPlaceWeapon ( tw , weapon ) ;
36474: LD_VAR 0 7
36478: PPUSH
36479: LD_VAR 0 9
36483: PPUSH
36484: CALL_OW 148
// end ;
36488: GO 36102
36490: POP
36491: POP
// end ;
36492: LD_VAR 0 1
36496: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
36497: LD_INT 0
36499: PPUSH
36500: PPUSH
36501: PPUSH
36502: PPUSH
36503: PPUSH
36504: PPUSH
// if not mc_bases then
36505: LD_EXP 93
36509: NOT
36510: IFFALSE 36514
// exit ;
36512: GO 37526
// for i = 1 to mc_bases do
36514: LD_ADDR_VAR 0 2
36518: PUSH
36519: DOUBLE
36520: LD_INT 1
36522: DEC
36523: ST_TO_ADDR
36524: LD_EXP 93
36528: PUSH
36529: FOR_TO
36530: IFFALSE 37524
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
36532: LD_EXP 106
36536: PUSH
36537: LD_VAR 0 2
36541: ARRAY
36542: NOT
36543: PUSH
36544: LD_EXP 106
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: PUSH
36555: LD_EXP 107
36559: PUSH
36560: LD_VAR 0 2
36564: ARRAY
36565: EQUAL
36566: OR
36567: IFFALSE 36571
// continue ;
36569: GO 36529
// if mc_miners [ i ] then
36571: LD_EXP 107
36575: PUSH
36576: LD_VAR 0 2
36580: ARRAY
36581: IFFALSE 37211
// begin k := 1 ;
36583: LD_ADDR_VAR 0 4
36587: PUSH
36588: LD_INT 1
36590: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
36591: LD_ADDR_VAR 0 3
36595: PUSH
36596: DOUBLE
36597: LD_EXP 107
36601: PUSH
36602: LD_VAR 0 2
36606: ARRAY
36607: INC
36608: ST_TO_ADDR
36609: LD_INT 1
36611: PUSH
36612: FOR_DOWNTO
36613: IFFALSE 37209
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
36615: LD_EXP 107
36619: PUSH
36620: LD_VAR 0 2
36624: ARRAY
36625: PUSH
36626: LD_VAR 0 3
36630: ARRAY
36631: PPUSH
36632: CALL_OW 301
36636: PUSH
36637: LD_EXP 107
36641: PUSH
36642: LD_VAR 0 2
36646: ARRAY
36647: PUSH
36648: LD_VAR 0 3
36652: ARRAY
36653: PPUSH
36654: CALL_OW 257
36658: PUSH
36659: LD_INT 1
36661: NONEQUAL
36662: OR
36663: IFFALSE 36726
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
36665: LD_ADDR_VAR 0 5
36669: PUSH
36670: LD_EXP 107
36674: PUSH
36675: LD_VAR 0 2
36679: ARRAY
36680: PUSH
36681: LD_EXP 107
36685: PUSH
36686: LD_VAR 0 2
36690: ARRAY
36691: PUSH
36692: LD_VAR 0 3
36696: ARRAY
36697: DIFF
36698: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
36699: LD_ADDR_EXP 107
36703: PUSH
36704: LD_EXP 107
36708: PPUSH
36709: LD_VAR 0 2
36713: PPUSH
36714: LD_VAR 0 5
36718: PPUSH
36719: CALL_OW 1
36723: ST_TO_ADDR
// continue ;
36724: GO 36612
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
36726: LD_EXP 107
36730: PUSH
36731: LD_VAR 0 2
36735: ARRAY
36736: PUSH
36737: LD_VAR 0 3
36741: ARRAY
36742: PPUSH
36743: CALL 60534 0 1
36747: PUSH
36748: LD_EXP 107
36752: PUSH
36753: LD_VAR 0 2
36757: ARRAY
36758: PUSH
36759: LD_VAR 0 3
36763: ARRAY
36764: PPUSH
36765: CALL_OW 255
36769: PPUSH
36770: LD_EXP 106
36774: PUSH
36775: LD_VAR 0 2
36779: ARRAY
36780: PUSH
36781: LD_VAR 0 4
36785: ARRAY
36786: PUSH
36787: LD_INT 1
36789: ARRAY
36790: PPUSH
36791: LD_EXP 106
36795: PUSH
36796: LD_VAR 0 2
36800: ARRAY
36801: PUSH
36802: LD_VAR 0 4
36806: ARRAY
36807: PUSH
36808: LD_INT 2
36810: ARRAY
36811: PPUSH
36812: LD_INT 15
36814: PPUSH
36815: CALL 61494 0 4
36819: PUSH
36820: LD_INT 4
36822: ARRAY
36823: PUSH
36824: LD_EXP 107
36828: PUSH
36829: LD_VAR 0 2
36833: ARRAY
36834: PUSH
36835: LD_VAR 0 3
36839: ARRAY
36840: PPUSH
36841: LD_INT 10
36843: PPUSH
36844: CALL 63191 0 2
36848: PUSH
36849: LD_INT 4
36851: ARRAY
36852: OR
36853: AND
36854: IFFALSE 36877
// ComStop ( mc_miners [ i ] [ j ] ) ;
36856: LD_EXP 107
36860: PUSH
36861: LD_VAR 0 2
36865: ARRAY
36866: PUSH
36867: LD_VAR 0 3
36871: ARRAY
36872: PPUSH
36873: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
36877: LD_EXP 107
36881: PUSH
36882: LD_VAR 0 2
36886: ARRAY
36887: PUSH
36888: LD_VAR 0 3
36892: ARRAY
36893: PPUSH
36894: CALL_OW 257
36898: PUSH
36899: LD_INT 1
36901: EQUAL
36902: PUSH
36903: LD_EXP 107
36907: PUSH
36908: LD_VAR 0 2
36912: ARRAY
36913: PUSH
36914: LD_VAR 0 3
36918: ARRAY
36919: PPUSH
36920: CALL_OW 459
36924: NOT
36925: AND
36926: PUSH
36927: LD_EXP 107
36931: PUSH
36932: LD_VAR 0 2
36936: ARRAY
36937: PUSH
36938: LD_VAR 0 3
36942: ARRAY
36943: PPUSH
36944: CALL_OW 255
36948: PPUSH
36949: LD_EXP 106
36953: PUSH
36954: LD_VAR 0 2
36958: ARRAY
36959: PUSH
36960: LD_VAR 0 4
36964: ARRAY
36965: PUSH
36966: LD_INT 1
36968: ARRAY
36969: PPUSH
36970: LD_EXP 106
36974: PUSH
36975: LD_VAR 0 2
36979: ARRAY
36980: PUSH
36981: LD_VAR 0 4
36985: ARRAY
36986: PUSH
36987: LD_INT 2
36989: ARRAY
36990: PPUSH
36991: LD_INT 15
36993: PPUSH
36994: CALL 61494 0 4
36998: PUSH
36999: LD_INT 4
37001: ARRAY
37002: PUSH
37003: LD_INT 0
37005: EQUAL
37006: AND
37007: PUSH
37008: LD_EXP 107
37012: PUSH
37013: LD_VAR 0 2
37017: ARRAY
37018: PUSH
37019: LD_VAR 0 3
37023: ARRAY
37024: PPUSH
37025: CALL_OW 314
37029: NOT
37030: AND
37031: IFFALSE 37207
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
37033: LD_EXP 107
37037: PUSH
37038: LD_VAR 0 2
37042: ARRAY
37043: PUSH
37044: LD_VAR 0 3
37048: ARRAY
37049: PPUSH
37050: CALL_OW 310
37054: IFFALSE 37077
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
37056: LD_EXP 107
37060: PUSH
37061: LD_VAR 0 2
37065: ARRAY
37066: PUSH
37067: LD_VAR 0 3
37071: ARRAY
37072: PPUSH
37073: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
37077: LD_EXP 107
37081: PUSH
37082: LD_VAR 0 2
37086: ARRAY
37087: PUSH
37088: LD_VAR 0 3
37092: ARRAY
37093: PPUSH
37094: CALL_OW 314
37098: NOT
37099: IFFALSE 37167
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
37101: LD_EXP 107
37105: PUSH
37106: LD_VAR 0 2
37110: ARRAY
37111: PUSH
37112: LD_VAR 0 3
37116: ARRAY
37117: PPUSH
37118: LD_EXP 106
37122: PUSH
37123: LD_VAR 0 2
37127: ARRAY
37128: PUSH
37129: LD_VAR 0 4
37133: ARRAY
37134: PUSH
37135: LD_INT 1
37137: ARRAY
37138: PPUSH
37139: LD_EXP 106
37143: PUSH
37144: LD_VAR 0 2
37148: ARRAY
37149: PUSH
37150: LD_VAR 0 4
37154: ARRAY
37155: PUSH
37156: LD_INT 2
37158: ARRAY
37159: PPUSH
37160: LD_INT 0
37162: PPUSH
37163: CALL_OW 193
// k := k + 1 ;
37167: LD_ADDR_VAR 0 4
37171: PUSH
37172: LD_VAR 0 4
37176: PUSH
37177: LD_INT 1
37179: PLUS
37180: ST_TO_ADDR
// if k > mc_mines [ i ] then
37181: LD_VAR 0 4
37185: PUSH
37186: LD_EXP 106
37190: PUSH
37191: LD_VAR 0 2
37195: ARRAY
37196: GREATER
37197: IFFALSE 37207
// k := 1 ;
37199: LD_ADDR_VAR 0 4
37203: PUSH
37204: LD_INT 1
37206: ST_TO_ADDR
// end ; end ;
37207: GO 36612
37209: POP
37210: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
37211: LD_ADDR_VAR 0 5
37215: PUSH
37216: LD_EXP 93
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: PPUSH
37227: LD_INT 2
37229: PUSH
37230: LD_INT 30
37232: PUSH
37233: LD_INT 4
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 30
37242: PUSH
37243: LD_INT 5
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 30
37252: PUSH
37253: LD_INT 32
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: PPUSH
37266: CALL_OW 72
37270: ST_TO_ADDR
// if not tmp then
37271: LD_VAR 0 5
37275: NOT
37276: IFFALSE 37280
// continue ;
37278: GO 36529
// list := [ ] ;
37280: LD_ADDR_VAR 0 6
37284: PUSH
37285: EMPTY
37286: ST_TO_ADDR
// for j in tmp do
37287: LD_ADDR_VAR 0 3
37291: PUSH
37292: LD_VAR 0 5
37296: PUSH
37297: FOR_IN
37298: IFFALSE 37367
// begin for k in UnitsInside ( j ) do
37300: LD_ADDR_VAR 0 4
37304: PUSH
37305: LD_VAR 0 3
37309: PPUSH
37310: CALL_OW 313
37314: PUSH
37315: FOR_IN
37316: IFFALSE 37363
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
37318: LD_VAR 0 4
37322: PPUSH
37323: CALL_OW 257
37327: PUSH
37328: LD_INT 1
37330: EQUAL
37331: PUSH
37332: LD_VAR 0 4
37336: PPUSH
37337: CALL_OW 459
37341: NOT
37342: AND
37343: IFFALSE 37361
// list := list ^ k ;
37345: LD_ADDR_VAR 0 6
37349: PUSH
37350: LD_VAR 0 6
37354: PUSH
37355: LD_VAR 0 4
37359: ADD
37360: ST_TO_ADDR
37361: GO 37315
37363: POP
37364: POP
// end ;
37365: GO 37297
37367: POP
37368: POP
// list := list diff mc_miners [ i ] ;
37369: LD_ADDR_VAR 0 6
37373: PUSH
37374: LD_VAR 0 6
37378: PUSH
37379: LD_EXP 107
37383: PUSH
37384: LD_VAR 0 2
37388: ARRAY
37389: DIFF
37390: ST_TO_ADDR
// if not list then
37391: LD_VAR 0 6
37395: NOT
37396: IFFALSE 37400
// continue ;
37398: GO 36529
// k := mc_mines [ i ] - mc_miners [ i ] ;
37400: LD_ADDR_VAR 0 4
37404: PUSH
37405: LD_EXP 106
37409: PUSH
37410: LD_VAR 0 2
37414: ARRAY
37415: PUSH
37416: LD_EXP 107
37420: PUSH
37421: LD_VAR 0 2
37425: ARRAY
37426: MINUS
37427: ST_TO_ADDR
// if k > list then
37428: LD_VAR 0 4
37432: PUSH
37433: LD_VAR 0 6
37437: GREATER
37438: IFFALSE 37450
// k := list ;
37440: LD_ADDR_VAR 0 4
37444: PUSH
37445: LD_VAR 0 6
37449: ST_TO_ADDR
// for j = 1 to k do
37450: LD_ADDR_VAR 0 3
37454: PUSH
37455: DOUBLE
37456: LD_INT 1
37458: DEC
37459: ST_TO_ADDR
37460: LD_VAR 0 4
37464: PUSH
37465: FOR_TO
37466: IFFALSE 37520
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
37468: LD_ADDR_EXP 107
37472: PUSH
37473: LD_EXP 107
37477: PPUSH
37478: LD_VAR 0 2
37482: PUSH
37483: LD_EXP 107
37487: PUSH
37488: LD_VAR 0 2
37492: ARRAY
37493: PUSH
37494: LD_INT 1
37496: PLUS
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PPUSH
37502: LD_VAR 0 6
37506: PUSH
37507: LD_VAR 0 3
37511: ARRAY
37512: PPUSH
37513: CALL 60598 0 3
37517: ST_TO_ADDR
37518: GO 37465
37520: POP
37521: POP
// end ;
37522: GO 36529
37524: POP
37525: POP
// end ;
37526: LD_VAR 0 1
37530: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
37531: LD_INT 0
37533: PPUSH
37534: PPUSH
37535: PPUSH
37536: PPUSH
37537: PPUSH
37538: PPUSH
37539: PPUSH
37540: PPUSH
37541: PPUSH
37542: PPUSH
// if not mc_bases then
37543: LD_EXP 93
37547: NOT
37548: IFFALSE 37552
// exit ;
37550: GO 39283
// for i = 1 to mc_bases do
37552: LD_ADDR_VAR 0 2
37556: PUSH
37557: DOUBLE
37558: LD_INT 1
37560: DEC
37561: ST_TO_ADDR
37562: LD_EXP 93
37566: PUSH
37567: FOR_TO
37568: IFFALSE 39281
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
37570: LD_EXP 93
37574: PUSH
37575: LD_VAR 0 2
37579: ARRAY
37580: NOT
37581: PUSH
37582: LD_EXP 100
37586: PUSH
37587: LD_VAR 0 2
37591: ARRAY
37592: OR
37593: IFFALSE 37597
// continue ;
37595: GO 37567
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
37597: LD_EXP 109
37601: PUSH
37602: LD_VAR 0 2
37606: ARRAY
37607: NOT
37608: PUSH
37609: LD_EXP 110
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: AND
37620: IFFALSE 37658
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37622: LD_ADDR_EXP 110
37626: PUSH
37627: LD_EXP 110
37631: PPUSH
37632: LD_VAR 0 2
37636: PPUSH
37637: EMPTY
37638: PPUSH
37639: CALL_OW 1
37643: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
37644: LD_VAR 0 2
37648: PPUSH
37649: LD_INT 107
37651: PPUSH
37652: CALL 29070 0 2
// continue ;
37656: GO 37567
// end ; target := [ ] ;
37658: LD_ADDR_VAR 0 6
37662: PUSH
37663: EMPTY
37664: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
37665: LD_ADDR_VAR 0 3
37669: PUSH
37670: DOUBLE
37671: LD_EXP 109
37675: PUSH
37676: LD_VAR 0 2
37680: ARRAY
37681: INC
37682: ST_TO_ADDR
37683: LD_INT 1
37685: PUSH
37686: FOR_DOWNTO
37687: IFFALSE 37947
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
37689: LD_EXP 109
37693: PUSH
37694: LD_VAR 0 2
37698: ARRAY
37699: PUSH
37700: LD_VAR 0 3
37704: ARRAY
37705: PUSH
37706: LD_INT 2
37708: ARRAY
37709: PPUSH
37710: LD_EXP 109
37714: PUSH
37715: LD_VAR 0 2
37719: ARRAY
37720: PUSH
37721: LD_VAR 0 3
37725: ARRAY
37726: PUSH
37727: LD_INT 3
37729: ARRAY
37730: PPUSH
37731: CALL_OW 488
37735: PUSH
37736: LD_EXP 109
37740: PUSH
37741: LD_VAR 0 2
37745: ARRAY
37746: PUSH
37747: LD_VAR 0 3
37751: ARRAY
37752: PUSH
37753: LD_INT 2
37755: ARRAY
37756: PPUSH
37757: LD_EXP 109
37761: PUSH
37762: LD_VAR 0 2
37766: ARRAY
37767: PUSH
37768: LD_VAR 0 3
37772: ARRAY
37773: PUSH
37774: LD_INT 3
37776: ARRAY
37777: PPUSH
37778: CALL_OW 284
37782: PUSH
37783: LD_INT 0
37785: EQUAL
37786: AND
37787: IFFALSE 37842
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
37789: LD_ADDR_VAR 0 5
37793: PUSH
37794: LD_EXP 109
37798: PUSH
37799: LD_VAR 0 2
37803: ARRAY
37804: PPUSH
37805: LD_VAR 0 3
37809: PPUSH
37810: CALL_OW 3
37814: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
37815: LD_ADDR_EXP 109
37819: PUSH
37820: LD_EXP 109
37824: PPUSH
37825: LD_VAR 0 2
37829: PPUSH
37830: LD_VAR 0 5
37834: PPUSH
37835: CALL_OW 1
37839: ST_TO_ADDR
// continue ;
37840: GO 37686
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
37842: LD_EXP 93
37846: PUSH
37847: LD_VAR 0 2
37851: ARRAY
37852: PUSH
37853: LD_INT 1
37855: ARRAY
37856: PPUSH
37857: CALL_OW 255
37861: PPUSH
37862: LD_EXP 109
37866: PUSH
37867: LD_VAR 0 2
37871: ARRAY
37872: PUSH
37873: LD_VAR 0 3
37877: ARRAY
37878: PUSH
37879: LD_INT 2
37881: ARRAY
37882: PPUSH
37883: LD_EXP 109
37887: PUSH
37888: LD_VAR 0 2
37892: ARRAY
37893: PUSH
37894: LD_VAR 0 3
37898: ARRAY
37899: PUSH
37900: LD_INT 3
37902: ARRAY
37903: PPUSH
37904: LD_INT 30
37906: PPUSH
37907: CALL 61494 0 4
37911: PUSH
37912: LD_INT 4
37914: ARRAY
37915: PUSH
37916: LD_INT 0
37918: EQUAL
37919: IFFALSE 37945
// begin target := mc_crates [ i ] [ j ] ;
37921: LD_ADDR_VAR 0 6
37925: PUSH
37926: LD_EXP 109
37930: PUSH
37931: LD_VAR 0 2
37935: ARRAY
37936: PUSH
37937: LD_VAR 0 3
37941: ARRAY
37942: ST_TO_ADDR
// break ;
37943: GO 37947
// end ; end ;
37945: GO 37686
37947: POP
37948: POP
// if not target then
37949: LD_VAR 0 6
37953: NOT
37954: IFFALSE 37958
// continue ;
37956: GO 37567
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
37958: LD_ADDR_VAR 0 7
37962: PUSH
37963: LD_EXP 112
37967: PUSH
37968: LD_VAR 0 2
37972: ARRAY
37973: PPUSH
37974: LD_INT 2
37976: PUSH
37977: LD_INT 3
37979: PUSH
37980: LD_INT 58
37982: PUSH
37983: EMPTY
37984: LIST
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 61
37992: PUSH
37993: EMPTY
37994: LIST
37995: PUSH
37996: LD_INT 33
37998: PUSH
37999: LD_INT 5
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 33
38008: PUSH
38009: LD_INT 3
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 2
38025: PUSH
38026: LD_INT 34
38028: PUSH
38029: LD_INT 32
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 34
38038: PUSH
38039: LD_INT 51
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 34
38048: PUSH
38049: LD_INT 12
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PPUSH
38066: CALL_OW 72
38070: ST_TO_ADDR
// if not cargo then
38071: LD_VAR 0 7
38075: NOT
38076: IFFALSE 38719
// begin if mc_crates_collector [ i ] < 5 then
38078: LD_EXP 110
38082: PUSH
38083: LD_VAR 0 2
38087: ARRAY
38088: PUSH
38089: LD_INT 5
38091: LESS
38092: IFFALSE 38458
// begin if mc_ape [ i ] then
38094: LD_EXP 122
38098: PUSH
38099: LD_VAR 0 2
38103: ARRAY
38104: IFFALSE 38151
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
38106: LD_ADDR_VAR 0 5
38110: PUSH
38111: LD_EXP 122
38115: PUSH
38116: LD_VAR 0 2
38120: ARRAY
38121: PPUSH
38122: LD_INT 25
38124: PUSH
38125: LD_INT 16
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 24
38134: PUSH
38135: LD_INT 750
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PPUSH
38146: CALL_OW 72
38150: ST_TO_ADDR
// if not tmp then
38151: LD_VAR 0 5
38155: NOT
38156: IFFALSE 38203
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
38158: LD_ADDR_VAR 0 5
38162: PUSH
38163: LD_EXP 93
38167: PUSH
38168: LD_VAR 0 2
38172: ARRAY
38173: PPUSH
38174: LD_INT 25
38176: PUSH
38177: LD_INT 2
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 24
38186: PUSH
38187: LD_INT 750
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PPUSH
38198: CALL_OW 72
38202: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
38203: LD_EXP 122
38207: PUSH
38208: LD_VAR 0 2
38212: ARRAY
38213: PUSH
38214: LD_EXP 93
38218: PUSH
38219: LD_VAR 0 2
38223: ARRAY
38224: PPUSH
38225: LD_INT 25
38227: PUSH
38228: LD_INT 2
38230: PUSH
38231: EMPTY
38232: LIST
38233: LIST
38234: PUSH
38235: LD_INT 24
38237: PUSH
38238: LD_INT 750
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PPUSH
38249: CALL_OW 72
38253: AND
38254: PUSH
38255: LD_VAR 0 5
38259: PUSH
38260: LD_INT 5
38262: LESS
38263: AND
38264: IFFALSE 38346
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
38266: LD_ADDR_VAR 0 3
38270: PUSH
38271: LD_EXP 93
38275: PUSH
38276: LD_VAR 0 2
38280: ARRAY
38281: PPUSH
38282: LD_INT 25
38284: PUSH
38285: LD_INT 2
38287: PUSH
38288: EMPTY
38289: LIST
38290: LIST
38291: PUSH
38292: LD_INT 24
38294: PUSH
38295: LD_INT 750
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PPUSH
38306: CALL_OW 72
38310: PUSH
38311: FOR_IN
38312: IFFALSE 38344
// begin tmp := tmp union j ;
38314: LD_ADDR_VAR 0 5
38318: PUSH
38319: LD_VAR 0 5
38323: PUSH
38324: LD_VAR 0 3
38328: UNION
38329: ST_TO_ADDR
// if tmp >= 5 then
38330: LD_VAR 0 5
38334: PUSH
38335: LD_INT 5
38337: GREATEREQUAL
38338: IFFALSE 38342
// break ;
38340: GO 38344
// end ;
38342: GO 38311
38344: POP
38345: POP
// end ; if not tmp then
38346: LD_VAR 0 5
38350: NOT
38351: IFFALSE 38355
// continue ;
38353: GO 37567
// for j in tmp do
38355: LD_ADDR_VAR 0 3
38359: PUSH
38360: LD_VAR 0 5
38364: PUSH
38365: FOR_IN
38366: IFFALSE 38456
// if not GetTag ( j ) then
38368: LD_VAR 0 3
38372: PPUSH
38373: CALL_OW 110
38377: NOT
38378: IFFALSE 38454
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
38380: LD_ADDR_EXP 110
38384: PUSH
38385: LD_EXP 110
38389: PPUSH
38390: LD_VAR 0 2
38394: PUSH
38395: LD_EXP 110
38399: PUSH
38400: LD_VAR 0 2
38404: ARRAY
38405: PUSH
38406: LD_INT 1
38408: PLUS
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PPUSH
38414: LD_VAR 0 3
38418: PPUSH
38419: CALL 60598 0 3
38423: ST_TO_ADDR
// SetTag ( j , 107 ) ;
38424: LD_VAR 0 3
38428: PPUSH
38429: LD_INT 107
38431: PPUSH
38432: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
38436: LD_EXP 110
38440: PUSH
38441: LD_VAR 0 2
38445: ARRAY
38446: PUSH
38447: LD_INT 5
38449: GREATEREQUAL
38450: IFFALSE 38454
// break ;
38452: GO 38456
// end ;
38454: GO 38365
38456: POP
38457: POP
// end ; if mc_crates_collector [ i ] and target then
38458: LD_EXP 110
38462: PUSH
38463: LD_VAR 0 2
38467: ARRAY
38468: PUSH
38469: LD_VAR 0 6
38473: AND
38474: IFFALSE 38717
// begin if mc_crates_collector [ i ] < target [ 1 ] then
38476: LD_EXP 110
38480: PUSH
38481: LD_VAR 0 2
38485: ARRAY
38486: PUSH
38487: LD_VAR 0 6
38491: PUSH
38492: LD_INT 1
38494: ARRAY
38495: LESS
38496: IFFALSE 38516
// tmp := mc_crates_collector [ i ] else
38498: LD_ADDR_VAR 0 5
38502: PUSH
38503: LD_EXP 110
38507: PUSH
38508: LD_VAR 0 2
38512: ARRAY
38513: ST_TO_ADDR
38514: GO 38530
// tmp := target [ 1 ] ;
38516: LD_ADDR_VAR 0 5
38520: PUSH
38521: LD_VAR 0 6
38525: PUSH
38526: LD_INT 1
38528: ARRAY
38529: ST_TO_ADDR
// k := 0 ;
38530: LD_ADDR_VAR 0 4
38534: PUSH
38535: LD_INT 0
38537: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
38538: LD_ADDR_VAR 0 3
38542: PUSH
38543: LD_EXP 110
38547: PUSH
38548: LD_VAR 0 2
38552: ARRAY
38553: PUSH
38554: FOR_IN
38555: IFFALSE 38715
// begin k := k + 1 ;
38557: LD_ADDR_VAR 0 4
38561: PUSH
38562: LD_VAR 0 4
38566: PUSH
38567: LD_INT 1
38569: PLUS
38570: ST_TO_ADDR
// if k > tmp then
38571: LD_VAR 0 4
38575: PUSH
38576: LD_VAR 0 5
38580: GREATER
38581: IFFALSE 38585
// break ;
38583: GO 38715
// if not GetClass ( j ) in [ 2 , 16 ] then
38585: LD_VAR 0 3
38589: PPUSH
38590: CALL_OW 257
38594: PUSH
38595: LD_INT 2
38597: PUSH
38598: LD_INT 16
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: IN
38605: NOT
38606: IFFALSE 38659
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
38608: LD_ADDR_EXP 110
38612: PUSH
38613: LD_EXP 110
38617: PPUSH
38618: LD_VAR 0 2
38622: PPUSH
38623: LD_EXP 110
38627: PUSH
38628: LD_VAR 0 2
38632: ARRAY
38633: PUSH
38634: LD_VAR 0 3
38638: DIFF
38639: PPUSH
38640: CALL_OW 1
38644: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38645: LD_VAR 0 3
38649: PPUSH
38650: LD_INT 0
38652: PPUSH
38653: CALL_OW 109
// continue ;
38657: GO 38554
// end ; if IsInUnit ( j ) then
38659: LD_VAR 0 3
38663: PPUSH
38664: CALL_OW 310
38668: IFFALSE 38679
// ComExitBuilding ( j ) ;
38670: LD_VAR 0 3
38674: PPUSH
38675: CALL_OW 122
// wait ( 3 ) ;
38679: LD_INT 3
38681: PPUSH
38682: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
38686: LD_VAR 0 3
38690: PPUSH
38691: LD_VAR 0 6
38695: PUSH
38696: LD_INT 2
38698: ARRAY
38699: PPUSH
38700: LD_VAR 0 6
38704: PUSH
38705: LD_INT 3
38707: ARRAY
38708: PPUSH
38709: CALL_OW 117
// end ;
38713: GO 38554
38715: POP
38716: POP
// end ; end else
38717: GO 39279
// begin for j in cargo do
38719: LD_ADDR_VAR 0 3
38723: PUSH
38724: LD_VAR 0 7
38728: PUSH
38729: FOR_IN
38730: IFFALSE 39277
// begin if GetTag ( j ) <> 0 then
38732: LD_VAR 0 3
38736: PPUSH
38737: CALL_OW 110
38741: PUSH
38742: LD_INT 0
38744: NONEQUAL
38745: IFFALSE 38749
// continue ;
38747: GO 38729
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
38749: LD_VAR 0 3
38753: PPUSH
38754: CALL_OW 256
38758: PUSH
38759: LD_INT 1000
38761: LESS
38762: PUSH
38763: LD_VAR 0 3
38767: PPUSH
38768: LD_EXP 117
38772: PUSH
38773: LD_VAR 0 2
38777: ARRAY
38778: PPUSH
38779: CALL_OW 308
38783: NOT
38784: AND
38785: IFFALSE 38807
// ComMoveToArea ( j , mc_parking [ i ] ) ;
38787: LD_VAR 0 3
38791: PPUSH
38792: LD_EXP 117
38796: PUSH
38797: LD_VAR 0 2
38801: ARRAY
38802: PPUSH
38803: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
38807: LD_VAR 0 3
38811: PPUSH
38812: CALL_OW 256
38816: PUSH
38817: LD_INT 1000
38819: LESS
38820: PUSH
38821: LD_VAR 0 3
38825: PPUSH
38826: LD_EXP 117
38830: PUSH
38831: LD_VAR 0 2
38835: ARRAY
38836: PPUSH
38837: CALL_OW 308
38841: AND
38842: IFFALSE 38846
// continue ;
38844: GO 38729
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
38846: LD_VAR 0 3
38850: PPUSH
38851: CALL_OW 262
38855: PUSH
38856: LD_INT 2
38858: EQUAL
38859: PUSH
38860: LD_VAR 0 3
38864: PPUSH
38865: CALL_OW 261
38869: PUSH
38870: LD_INT 15
38872: LESS
38873: AND
38874: IFFALSE 38878
// continue ;
38876: GO 38729
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
38878: LD_VAR 0 3
38882: PPUSH
38883: CALL_OW 262
38887: PUSH
38888: LD_INT 1
38890: EQUAL
38891: PUSH
38892: LD_VAR 0 3
38896: PPUSH
38897: CALL_OW 261
38901: PUSH
38902: LD_INT 10
38904: LESS
38905: AND
38906: IFFALSE 39216
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38908: LD_ADDR_VAR 0 8
38912: PUSH
38913: LD_EXP 93
38917: PUSH
38918: LD_VAR 0 2
38922: ARRAY
38923: PPUSH
38924: LD_INT 2
38926: PUSH
38927: LD_INT 30
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 30
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: LIST
38951: PPUSH
38952: CALL_OW 72
38956: ST_TO_ADDR
// if not depot then
38957: LD_VAR 0 8
38961: NOT
38962: IFFALSE 38966
// continue ;
38964: GO 38729
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
38966: LD_VAR 0 3
38970: PPUSH
38971: LD_VAR 0 8
38975: PPUSH
38976: LD_VAR 0 3
38980: PPUSH
38981: CALL_OW 74
38985: PPUSH
38986: CALL_OW 296
38990: PUSH
38991: LD_INT 6
38993: LESS
38994: IFFALSE 39010
// SetFuel ( j , 100 ) else
38996: LD_VAR 0 3
39000: PPUSH
39001: LD_INT 100
39003: PPUSH
39004: CALL_OW 240
39008: GO 39216
// if GetFuel ( j ) = 0 then
39010: LD_VAR 0 3
39014: PPUSH
39015: CALL_OW 261
39019: PUSH
39020: LD_INT 0
39022: EQUAL
39023: IFFALSE 39216
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
39025: LD_ADDR_EXP 112
39029: PUSH
39030: LD_EXP 112
39034: PPUSH
39035: LD_VAR 0 2
39039: PPUSH
39040: LD_EXP 112
39044: PUSH
39045: LD_VAR 0 2
39049: ARRAY
39050: PUSH
39051: LD_VAR 0 3
39055: DIFF
39056: PPUSH
39057: CALL_OW 1
39061: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
39062: LD_VAR 0 3
39066: PPUSH
39067: CALL_OW 263
39071: PUSH
39072: LD_INT 1
39074: EQUAL
39075: IFFALSE 39091
// ComExitVehicle ( IsInUnit ( j ) ) ;
39077: LD_VAR 0 3
39081: PPUSH
39082: CALL_OW 310
39086: PPUSH
39087: CALL_OW 121
// if GetControl ( j ) = control_remote then
39091: LD_VAR 0 3
39095: PPUSH
39096: CALL_OW 263
39100: PUSH
39101: LD_INT 2
39103: EQUAL
39104: IFFALSE 39115
// ComUnlink ( j ) ;
39106: LD_VAR 0 3
39110: PPUSH
39111: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
39115: LD_ADDR_VAR 0 9
39119: PUSH
39120: LD_VAR 0 2
39124: PPUSH
39125: LD_INT 3
39127: PPUSH
39128: CALL 48378 0 2
39132: ST_TO_ADDR
// if fac then
39133: LD_VAR 0 9
39137: IFFALSE 39214
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
39139: LD_ADDR_VAR 0 10
39143: PUSH
39144: LD_VAR 0 9
39148: PPUSH
39149: LD_VAR 0 3
39153: PPUSH
39154: CALL_OW 265
39158: PPUSH
39159: LD_VAR 0 3
39163: PPUSH
39164: CALL_OW 262
39168: PPUSH
39169: LD_VAR 0 3
39173: PPUSH
39174: CALL_OW 263
39178: PPUSH
39179: LD_VAR 0 3
39183: PPUSH
39184: CALL_OW 264
39188: PPUSH
39189: CALL 58198 0 5
39193: ST_TO_ADDR
// if components then
39194: LD_VAR 0 10
39198: IFFALSE 39214
// MC_InsertProduceList ( i , components ) ;
39200: LD_VAR 0 2
39204: PPUSH
39205: LD_VAR 0 10
39209: PPUSH
39210: CALL 47948 0 2
// end ; continue ;
39214: GO 38729
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
39216: LD_VAR 0 3
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 289
39228: PUSH
39229: LD_INT 100
39231: LESS
39232: PUSH
39233: LD_VAR 0 3
39237: PPUSH
39238: CALL_OW 314
39242: NOT
39243: AND
39244: IFFALSE 39273
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
39246: LD_VAR 0 3
39250: PPUSH
39251: LD_VAR 0 6
39255: PUSH
39256: LD_INT 2
39258: ARRAY
39259: PPUSH
39260: LD_VAR 0 6
39264: PUSH
39265: LD_INT 3
39267: ARRAY
39268: PPUSH
39269: CALL_OW 117
// break ;
39273: GO 39277
// end ;
39275: GO 38729
39277: POP
39278: POP
// end ; end ;
39279: GO 37567
39281: POP
39282: POP
// end ;
39283: LD_VAR 0 1
39287: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
39288: LD_INT 0
39290: PPUSH
39291: PPUSH
39292: PPUSH
39293: PPUSH
// if not mc_bases then
39294: LD_EXP 93
39298: NOT
39299: IFFALSE 39303
// exit ;
39301: GO 39464
// for i = 1 to mc_bases do
39303: LD_ADDR_VAR 0 2
39307: PUSH
39308: DOUBLE
39309: LD_INT 1
39311: DEC
39312: ST_TO_ADDR
39313: LD_EXP 93
39317: PUSH
39318: FOR_TO
39319: IFFALSE 39462
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
39321: LD_ADDR_VAR 0 4
39325: PUSH
39326: LD_EXP 112
39330: PUSH
39331: LD_VAR 0 2
39335: ARRAY
39336: PUSH
39337: LD_EXP 115
39341: PUSH
39342: LD_VAR 0 2
39346: ARRAY
39347: UNION
39348: PPUSH
39349: LD_INT 33
39351: PUSH
39352: LD_INT 2
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PPUSH
39359: CALL_OW 72
39363: ST_TO_ADDR
// if tmp then
39364: LD_VAR 0 4
39368: IFFALSE 39460
// for j in tmp do
39370: LD_ADDR_VAR 0 3
39374: PUSH
39375: LD_VAR 0 4
39379: PUSH
39380: FOR_IN
39381: IFFALSE 39458
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
39383: LD_VAR 0 3
39387: PPUSH
39388: CALL_OW 312
39392: NOT
39393: PUSH
39394: LD_VAR 0 3
39398: PPUSH
39399: CALL_OW 256
39403: PUSH
39404: LD_INT 250
39406: GREATEREQUAL
39407: AND
39408: IFFALSE 39421
// Connect ( j ) else
39410: LD_VAR 0 3
39414: PPUSH
39415: CALL 63531 0 1
39419: GO 39456
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
39421: LD_VAR 0 3
39425: PPUSH
39426: CALL_OW 256
39430: PUSH
39431: LD_INT 250
39433: LESS
39434: PUSH
39435: LD_VAR 0 3
39439: PPUSH
39440: CALL_OW 312
39444: AND
39445: IFFALSE 39456
// ComUnlink ( j ) ;
39447: LD_VAR 0 3
39451: PPUSH
39452: CALL_OW 136
39456: GO 39380
39458: POP
39459: POP
// end ;
39460: GO 39318
39462: POP
39463: POP
// end ;
39464: LD_VAR 0 1
39468: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
39469: LD_INT 0
39471: PPUSH
39472: PPUSH
39473: PPUSH
39474: PPUSH
39475: PPUSH
// if not mc_bases then
39476: LD_EXP 93
39480: NOT
39481: IFFALSE 39485
// exit ;
39483: GO 39945
// for i = 1 to mc_bases do
39485: LD_ADDR_VAR 0 2
39489: PUSH
39490: DOUBLE
39491: LD_INT 1
39493: DEC
39494: ST_TO_ADDR
39495: LD_EXP 93
39499: PUSH
39500: FOR_TO
39501: IFFALSE 39943
// begin if not mc_produce [ i ] then
39503: LD_EXP 114
39507: PUSH
39508: LD_VAR 0 2
39512: ARRAY
39513: NOT
39514: IFFALSE 39518
// continue ;
39516: GO 39500
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39518: LD_ADDR_VAR 0 5
39522: PUSH
39523: LD_EXP 93
39527: PUSH
39528: LD_VAR 0 2
39532: ARRAY
39533: PPUSH
39534: LD_INT 30
39536: PUSH
39537: LD_INT 3
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PPUSH
39544: CALL_OW 72
39548: ST_TO_ADDR
// if not fac then
39549: LD_VAR 0 5
39553: NOT
39554: IFFALSE 39558
// continue ;
39556: GO 39500
// for j in fac do
39558: LD_ADDR_VAR 0 3
39562: PUSH
39563: LD_VAR 0 5
39567: PUSH
39568: FOR_IN
39569: IFFALSE 39939
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
39571: LD_VAR 0 3
39575: PPUSH
39576: CALL_OW 461
39580: PUSH
39581: LD_INT 2
39583: NONEQUAL
39584: PUSH
39585: LD_VAR 0 3
39589: PPUSH
39590: LD_INT 15
39592: PPUSH
39593: CALL 63191 0 2
39597: PUSH
39598: LD_INT 4
39600: ARRAY
39601: OR
39602: PUSH
39603: LD_VAR 0 3
39607: PPUSH
39608: CALL_OW 313
39612: PUSH
39613: LD_INT 0
39615: EQUAL
39616: OR
39617: IFFALSE 39621
// continue ;
39619: GO 39568
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
39621: LD_VAR 0 3
39625: PPUSH
39626: LD_EXP 114
39630: PUSH
39631: LD_VAR 0 2
39635: ARRAY
39636: PUSH
39637: LD_INT 1
39639: ARRAY
39640: PUSH
39641: LD_INT 1
39643: ARRAY
39644: PPUSH
39645: LD_EXP 114
39649: PUSH
39650: LD_VAR 0 2
39654: ARRAY
39655: PUSH
39656: LD_INT 1
39658: ARRAY
39659: PUSH
39660: LD_INT 2
39662: ARRAY
39663: PPUSH
39664: LD_EXP 114
39668: PUSH
39669: LD_VAR 0 2
39673: ARRAY
39674: PUSH
39675: LD_INT 1
39677: ARRAY
39678: PUSH
39679: LD_INT 3
39681: ARRAY
39682: PPUSH
39683: LD_EXP 114
39687: PUSH
39688: LD_VAR 0 2
39692: ARRAY
39693: PUSH
39694: LD_INT 1
39696: ARRAY
39697: PUSH
39698: LD_INT 4
39700: ARRAY
39701: PPUSH
39702: CALL_OW 448
39706: PUSH
39707: LD_VAR 0 3
39711: PPUSH
39712: LD_EXP 114
39716: PUSH
39717: LD_VAR 0 2
39721: ARRAY
39722: PUSH
39723: LD_INT 1
39725: ARRAY
39726: PUSH
39727: LD_INT 1
39729: ARRAY
39730: PUSH
39731: LD_EXP 114
39735: PUSH
39736: LD_VAR 0 2
39740: ARRAY
39741: PUSH
39742: LD_INT 1
39744: ARRAY
39745: PUSH
39746: LD_INT 2
39748: ARRAY
39749: PUSH
39750: LD_EXP 114
39754: PUSH
39755: LD_VAR 0 2
39759: ARRAY
39760: PUSH
39761: LD_INT 1
39763: ARRAY
39764: PUSH
39765: LD_INT 3
39767: ARRAY
39768: PUSH
39769: LD_EXP 114
39773: PUSH
39774: LD_VAR 0 2
39778: ARRAY
39779: PUSH
39780: LD_INT 1
39782: ARRAY
39783: PUSH
39784: LD_INT 4
39786: ARRAY
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: PPUSH
39794: CALL 66862 0 2
39798: AND
39799: IFFALSE 39937
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
39801: LD_VAR 0 3
39805: PPUSH
39806: LD_EXP 114
39810: PUSH
39811: LD_VAR 0 2
39815: ARRAY
39816: PUSH
39817: LD_INT 1
39819: ARRAY
39820: PUSH
39821: LD_INT 1
39823: ARRAY
39824: PPUSH
39825: LD_EXP 114
39829: PUSH
39830: LD_VAR 0 2
39834: ARRAY
39835: PUSH
39836: LD_INT 1
39838: ARRAY
39839: PUSH
39840: LD_INT 2
39842: ARRAY
39843: PPUSH
39844: LD_EXP 114
39848: PUSH
39849: LD_VAR 0 2
39853: ARRAY
39854: PUSH
39855: LD_INT 1
39857: ARRAY
39858: PUSH
39859: LD_INT 3
39861: ARRAY
39862: PPUSH
39863: LD_EXP 114
39867: PUSH
39868: LD_VAR 0 2
39872: ARRAY
39873: PUSH
39874: LD_INT 1
39876: ARRAY
39877: PUSH
39878: LD_INT 4
39880: ARRAY
39881: PPUSH
39882: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
39886: LD_ADDR_VAR 0 4
39890: PUSH
39891: LD_EXP 114
39895: PUSH
39896: LD_VAR 0 2
39900: ARRAY
39901: PPUSH
39902: LD_INT 1
39904: PPUSH
39905: CALL_OW 3
39909: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
39910: LD_ADDR_EXP 114
39914: PUSH
39915: LD_EXP 114
39919: PPUSH
39920: LD_VAR 0 2
39924: PPUSH
39925: LD_VAR 0 4
39929: PPUSH
39930: CALL_OW 1
39934: ST_TO_ADDR
// break ;
39935: GO 39939
// end ; end ;
39937: GO 39568
39939: POP
39940: POP
// end ;
39941: GO 39500
39943: POP
39944: POP
// end ;
39945: LD_VAR 0 1
39949: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
39950: LD_INT 0
39952: PPUSH
39953: PPUSH
39954: PPUSH
// if not mc_bases then
39955: LD_EXP 93
39959: NOT
39960: IFFALSE 39964
// exit ;
39962: GO 40053
// for i = 1 to mc_bases do
39964: LD_ADDR_VAR 0 2
39968: PUSH
39969: DOUBLE
39970: LD_INT 1
39972: DEC
39973: ST_TO_ADDR
39974: LD_EXP 93
39978: PUSH
39979: FOR_TO
39980: IFFALSE 40051
// begin if mc_attack [ i ] then
39982: LD_EXP 113
39986: PUSH
39987: LD_VAR 0 2
39991: ARRAY
39992: IFFALSE 40049
// begin tmp := mc_attack [ i ] [ 1 ] ;
39994: LD_ADDR_VAR 0 3
39998: PUSH
39999: LD_EXP 113
40003: PUSH
40004: LD_VAR 0 2
40008: ARRAY
40009: PUSH
40010: LD_INT 1
40012: ARRAY
40013: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
40014: LD_ADDR_EXP 113
40018: PUSH
40019: LD_EXP 113
40023: PPUSH
40024: LD_VAR 0 2
40028: PPUSH
40029: EMPTY
40030: PPUSH
40031: CALL_OW 1
40035: ST_TO_ADDR
// Attack ( tmp ) ;
40036: LD_VAR 0 3
40040: PPUSH
40041: CALL 89051 0 1
// exit ;
40045: POP
40046: POP
40047: GO 40053
// end ; end ;
40049: GO 39979
40051: POP
40052: POP
// end ;
40053: LD_VAR 0 1
40057: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
40058: LD_INT 0
40060: PPUSH
40061: PPUSH
40062: PPUSH
40063: PPUSH
40064: PPUSH
40065: PPUSH
40066: PPUSH
// if not mc_bases then
40067: LD_EXP 93
40071: NOT
40072: IFFALSE 40076
// exit ;
40074: GO 40680
// for i = 1 to mc_bases do
40076: LD_ADDR_VAR 0 2
40080: PUSH
40081: DOUBLE
40082: LD_INT 1
40084: DEC
40085: ST_TO_ADDR
40086: LD_EXP 93
40090: PUSH
40091: FOR_TO
40092: IFFALSE 40678
// begin if not mc_bases [ i ] then
40094: LD_EXP 93
40098: PUSH
40099: LD_VAR 0 2
40103: ARRAY
40104: NOT
40105: IFFALSE 40109
// continue ;
40107: GO 40091
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
40109: LD_ADDR_VAR 0 7
40113: PUSH
40114: LD_EXP 93
40118: PUSH
40119: LD_VAR 0 2
40123: ARRAY
40124: PUSH
40125: LD_INT 1
40127: ARRAY
40128: PPUSH
40129: CALL 57502 0 1
40133: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
40134: LD_ADDR_EXP 116
40138: PUSH
40139: LD_EXP 116
40143: PPUSH
40144: LD_VAR 0 2
40148: PPUSH
40149: LD_EXP 93
40153: PUSH
40154: LD_VAR 0 2
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: PPUSH
40164: CALL_OW 255
40168: PPUSH
40169: LD_EXP 118
40173: PUSH
40174: LD_VAR 0 2
40178: ARRAY
40179: PPUSH
40180: CALL 55462 0 2
40184: PPUSH
40185: CALL_OW 1
40189: ST_TO_ADDR
// if not mc_scan [ i ] then
40190: LD_EXP 116
40194: PUSH
40195: LD_VAR 0 2
40199: ARRAY
40200: NOT
40201: IFFALSE 40356
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40203: LD_ADDR_VAR 0 4
40207: PUSH
40208: LD_EXP 93
40212: PUSH
40213: LD_VAR 0 2
40217: ARRAY
40218: PPUSH
40219: LD_INT 2
40221: PUSH
40222: LD_INT 25
40224: PUSH
40225: LD_INT 5
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 25
40234: PUSH
40235: LD_INT 8
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PUSH
40242: LD_INT 25
40244: PUSH
40245: LD_INT 9
40247: PUSH
40248: EMPTY
40249: LIST
40250: LIST
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: PPUSH
40258: CALL_OW 72
40262: ST_TO_ADDR
// if not tmp then
40263: LD_VAR 0 4
40267: NOT
40268: IFFALSE 40272
// continue ;
40270: GO 40091
// for j in tmp do
40272: LD_ADDR_VAR 0 3
40276: PUSH
40277: LD_VAR 0 4
40281: PUSH
40282: FOR_IN
40283: IFFALSE 40354
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
40285: LD_VAR 0 3
40289: PPUSH
40290: CALL_OW 310
40294: PPUSH
40295: CALL_OW 266
40299: PUSH
40300: LD_INT 5
40302: EQUAL
40303: PUSH
40304: LD_VAR 0 3
40308: PPUSH
40309: CALL_OW 257
40313: PUSH
40314: LD_INT 1
40316: EQUAL
40317: AND
40318: PUSH
40319: LD_VAR 0 3
40323: PPUSH
40324: CALL_OW 459
40328: NOT
40329: AND
40330: PUSH
40331: LD_VAR 0 7
40335: AND
40336: IFFALSE 40352
// ComChangeProfession ( j , class ) ;
40338: LD_VAR 0 3
40342: PPUSH
40343: LD_VAR 0 7
40347: PPUSH
40348: CALL_OW 123
40352: GO 40282
40354: POP
40355: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
40356: LD_EXP 116
40360: PUSH
40361: LD_VAR 0 2
40365: ARRAY
40366: PUSH
40367: LD_EXP 115
40371: PUSH
40372: LD_VAR 0 2
40376: ARRAY
40377: NOT
40378: AND
40379: PUSH
40380: LD_EXP 93
40384: PUSH
40385: LD_VAR 0 2
40389: ARRAY
40390: PPUSH
40391: LD_INT 30
40393: PUSH
40394: LD_INT 32
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PPUSH
40401: CALL_OW 72
40405: NOT
40406: AND
40407: PUSH
40408: LD_EXP 93
40412: PUSH
40413: LD_VAR 0 2
40417: ARRAY
40418: PPUSH
40419: LD_INT 2
40421: PUSH
40422: LD_INT 30
40424: PUSH
40425: LD_INT 4
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 30
40434: PUSH
40435: LD_INT 5
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: LIST
40446: PPUSH
40447: CALL_OW 72
40451: NOT
40452: AND
40453: IFFALSE 40585
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40455: LD_ADDR_VAR 0 4
40459: PUSH
40460: LD_EXP 93
40464: PUSH
40465: LD_VAR 0 2
40469: ARRAY
40470: PPUSH
40471: LD_INT 2
40473: PUSH
40474: LD_INT 25
40476: PUSH
40477: LD_INT 1
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 25
40486: PUSH
40487: LD_INT 5
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 25
40496: PUSH
40497: LD_INT 8
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 25
40506: PUSH
40507: LD_INT 9
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: PPUSH
40521: CALL_OW 72
40525: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
40526: LD_ADDR_VAR 0 4
40530: PUSH
40531: LD_VAR 0 4
40535: PUSH
40536: LD_VAR 0 4
40540: PPUSH
40541: LD_INT 18
40543: PPUSH
40544: CALL 93795 0 2
40548: DIFF
40549: ST_TO_ADDR
// if tmp then
40550: LD_VAR 0 4
40554: IFFALSE 40585
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
40556: LD_VAR 0 2
40560: PPUSH
40561: LD_VAR 0 4
40565: PPUSH
40566: LD_EXP 118
40570: PUSH
40571: LD_VAR 0 2
40575: ARRAY
40576: PPUSH
40577: CALL 55497 0 3
// exit ;
40581: POP
40582: POP
40583: GO 40680
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
40585: LD_EXP 116
40589: PUSH
40590: LD_VAR 0 2
40594: ARRAY
40595: PUSH
40596: LD_EXP 115
40600: PUSH
40601: LD_VAR 0 2
40605: ARRAY
40606: AND
40607: IFFALSE 40676
// begin tmp := mc_defender [ i ] ;
40609: LD_ADDR_VAR 0 4
40613: PUSH
40614: LD_EXP 115
40618: PUSH
40619: LD_VAR 0 2
40623: ARRAY
40624: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40625: LD_ADDR_EXP 115
40629: PUSH
40630: LD_EXP 115
40634: PPUSH
40635: LD_VAR 0 2
40639: PPUSH
40640: EMPTY
40641: PPUSH
40642: CALL_OW 1
40646: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
40647: LD_VAR 0 2
40651: PPUSH
40652: LD_VAR 0 4
40656: PPUSH
40657: LD_EXP 116
40661: PUSH
40662: LD_VAR 0 2
40666: ARRAY
40667: PPUSH
40668: CALL 55995 0 3
// exit ;
40672: POP
40673: POP
40674: GO 40680
// end ; end ;
40676: GO 40091
40678: POP
40679: POP
// end ;
40680: LD_VAR 0 1
40684: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
40685: LD_INT 0
40687: PPUSH
40688: PPUSH
40689: PPUSH
40690: PPUSH
40691: PPUSH
40692: PPUSH
40693: PPUSH
40694: PPUSH
40695: PPUSH
40696: PPUSH
40697: PPUSH
// if not mc_bases then
40698: LD_EXP 93
40702: NOT
40703: IFFALSE 40707
// exit ;
40705: GO 41794
// for i = 1 to mc_bases do
40707: LD_ADDR_VAR 0 2
40711: PUSH
40712: DOUBLE
40713: LD_INT 1
40715: DEC
40716: ST_TO_ADDR
40717: LD_EXP 93
40721: PUSH
40722: FOR_TO
40723: IFFALSE 41792
// begin tmp := mc_lab [ i ] ;
40725: LD_ADDR_VAR 0 6
40729: PUSH
40730: LD_EXP 126
40734: PUSH
40735: LD_VAR 0 2
40739: ARRAY
40740: ST_TO_ADDR
// if not tmp then
40741: LD_VAR 0 6
40745: NOT
40746: IFFALSE 40750
// continue ;
40748: GO 40722
// idle_lab := 0 ;
40750: LD_ADDR_VAR 0 11
40754: PUSH
40755: LD_INT 0
40757: ST_TO_ADDR
// for j in tmp do
40758: LD_ADDR_VAR 0 3
40762: PUSH
40763: LD_VAR 0 6
40767: PUSH
40768: FOR_IN
40769: IFFALSE 41788
// begin researching := false ;
40771: LD_ADDR_VAR 0 10
40775: PUSH
40776: LD_INT 0
40778: ST_TO_ADDR
// side := GetSide ( j ) ;
40779: LD_ADDR_VAR 0 4
40783: PUSH
40784: LD_VAR 0 3
40788: PPUSH
40789: CALL_OW 255
40793: ST_TO_ADDR
// if not mc_tech [ side ] then
40794: LD_EXP 120
40798: PUSH
40799: LD_VAR 0 4
40803: ARRAY
40804: NOT
40805: IFFALSE 40809
// continue ;
40807: GO 40768
// if BuildingStatus ( j ) = bs_idle then
40809: LD_VAR 0 3
40813: PPUSH
40814: CALL_OW 461
40818: PUSH
40819: LD_INT 2
40821: EQUAL
40822: IFFALSE 41010
// begin if idle_lab and UnitsInside ( j ) < 6 then
40824: LD_VAR 0 11
40828: PUSH
40829: LD_VAR 0 3
40833: PPUSH
40834: CALL_OW 313
40838: PUSH
40839: LD_INT 6
40841: LESS
40842: AND
40843: IFFALSE 40914
// begin tmp2 := UnitsInside ( idle_lab ) ;
40845: LD_ADDR_VAR 0 9
40849: PUSH
40850: LD_VAR 0 11
40854: PPUSH
40855: CALL_OW 313
40859: ST_TO_ADDR
// if tmp2 then
40860: LD_VAR 0 9
40864: IFFALSE 40906
// for x in tmp2 do
40866: LD_ADDR_VAR 0 7
40870: PUSH
40871: LD_VAR 0 9
40875: PUSH
40876: FOR_IN
40877: IFFALSE 40904
// begin ComExitBuilding ( x ) ;
40879: LD_VAR 0 7
40883: PPUSH
40884: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40888: LD_VAR 0 7
40892: PPUSH
40893: LD_VAR 0 3
40897: PPUSH
40898: CALL_OW 180
// end ;
40902: GO 40876
40904: POP
40905: POP
// idle_lab := 0 ;
40906: LD_ADDR_VAR 0 11
40910: PUSH
40911: LD_INT 0
40913: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
40914: LD_ADDR_VAR 0 5
40918: PUSH
40919: LD_EXP 120
40923: PUSH
40924: LD_VAR 0 4
40928: ARRAY
40929: PUSH
40930: FOR_IN
40931: IFFALSE 40991
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
40933: LD_VAR 0 3
40937: PPUSH
40938: LD_VAR 0 5
40942: PPUSH
40943: CALL_OW 430
40947: PUSH
40948: LD_VAR 0 4
40952: PPUSH
40953: LD_VAR 0 5
40957: PPUSH
40958: CALL 54567 0 2
40962: AND
40963: IFFALSE 40989
// begin researching := true ;
40965: LD_ADDR_VAR 0 10
40969: PUSH
40970: LD_INT 1
40972: ST_TO_ADDR
// ComResearch ( j , t ) ;
40973: LD_VAR 0 3
40977: PPUSH
40978: LD_VAR 0 5
40982: PPUSH
40983: CALL_OW 124
// break ;
40987: GO 40991
// end ;
40989: GO 40930
40991: POP
40992: POP
// if not researching then
40993: LD_VAR 0 10
40997: NOT
40998: IFFALSE 41010
// idle_lab := j ;
41000: LD_ADDR_VAR 0 11
41004: PUSH
41005: LD_VAR 0 3
41009: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
41010: LD_VAR 0 3
41014: PPUSH
41015: CALL_OW 461
41019: PUSH
41020: LD_INT 10
41022: EQUAL
41023: IFFALSE 41611
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
41025: LD_EXP 122
41029: PUSH
41030: LD_VAR 0 2
41034: ARRAY
41035: NOT
41036: PUSH
41037: LD_EXP 123
41041: PUSH
41042: LD_VAR 0 2
41046: ARRAY
41047: NOT
41048: AND
41049: PUSH
41050: LD_EXP 120
41054: PUSH
41055: LD_VAR 0 4
41059: ARRAY
41060: PUSH
41061: LD_INT 1
41063: GREATER
41064: AND
41065: IFFALSE 41196
// begin ComCancel ( j ) ;
41067: LD_VAR 0 3
41071: PPUSH
41072: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
41076: LD_ADDR_EXP 120
41080: PUSH
41081: LD_EXP 120
41085: PPUSH
41086: LD_VAR 0 4
41090: PPUSH
41091: LD_EXP 120
41095: PUSH
41096: LD_VAR 0 4
41100: ARRAY
41101: PPUSH
41102: LD_EXP 120
41106: PUSH
41107: LD_VAR 0 4
41111: ARRAY
41112: PUSH
41113: LD_INT 1
41115: MINUS
41116: PPUSH
41117: LD_EXP 120
41121: PUSH
41122: LD_VAR 0 4
41126: ARRAY
41127: PPUSH
41128: LD_INT 0
41130: PPUSH
41131: CALL 60016 0 4
41135: PPUSH
41136: CALL_OW 1
41140: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
41141: LD_ADDR_EXP 120
41145: PUSH
41146: LD_EXP 120
41150: PPUSH
41151: LD_VAR 0 4
41155: PPUSH
41156: LD_EXP 120
41160: PUSH
41161: LD_VAR 0 4
41165: ARRAY
41166: PPUSH
41167: LD_EXP 120
41171: PUSH
41172: LD_VAR 0 4
41176: ARRAY
41177: PPUSH
41178: LD_INT 1
41180: PPUSH
41181: LD_INT 0
41183: PPUSH
41184: CALL 60016 0 4
41188: PPUSH
41189: CALL_OW 1
41193: ST_TO_ADDR
// continue ;
41194: GO 40768
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
41196: LD_EXP 122
41200: PUSH
41201: LD_VAR 0 2
41205: ARRAY
41206: PUSH
41207: LD_EXP 123
41211: PUSH
41212: LD_VAR 0 2
41216: ARRAY
41217: NOT
41218: AND
41219: IFFALSE 41346
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
41221: LD_ADDR_EXP 123
41225: PUSH
41226: LD_EXP 123
41230: PPUSH
41231: LD_VAR 0 2
41235: PUSH
41236: LD_EXP 123
41240: PUSH
41241: LD_VAR 0 2
41245: ARRAY
41246: PUSH
41247: LD_INT 1
41249: PLUS
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PPUSH
41255: LD_EXP 122
41259: PUSH
41260: LD_VAR 0 2
41264: ARRAY
41265: PUSH
41266: LD_INT 1
41268: ARRAY
41269: PPUSH
41270: CALL 60598 0 3
41274: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
41275: LD_EXP 122
41279: PUSH
41280: LD_VAR 0 2
41284: ARRAY
41285: PUSH
41286: LD_INT 1
41288: ARRAY
41289: PPUSH
41290: LD_INT 112
41292: PPUSH
41293: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
41297: LD_ADDR_VAR 0 9
41301: PUSH
41302: LD_EXP 122
41306: PUSH
41307: LD_VAR 0 2
41311: ARRAY
41312: PPUSH
41313: LD_INT 1
41315: PPUSH
41316: CALL_OW 3
41320: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
41321: LD_ADDR_EXP 122
41325: PUSH
41326: LD_EXP 122
41330: PPUSH
41331: LD_VAR 0 2
41335: PPUSH
41336: LD_VAR 0 9
41340: PPUSH
41341: CALL_OW 1
41345: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
41346: LD_EXP 122
41350: PUSH
41351: LD_VAR 0 2
41355: ARRAY
41356: PUSH
41357: LD_EXP 123
41361: PUSH
41362: LD_VAR 0 2
41366: ARRAY
41367: AND
41368: PUSH
41369: LD_EXP 123
41373: PUSH
41374: LD_VAR 0 2
41378: ARRAY
41379: PUSH
41380: LD_INT 1
41382: ARRAY
41383: PPUSH
41384: CALL_OW 310
41388: NOT
41389: AND
41390: PUSH
41391: LD_VAR 0 3
41395: PPUSH
41396: CALL_OW 313
41400: PUSH
41401: LD_INT 6
41403: EQUAL
41404: AND
41405: IFFALSE 41461
// begin tmp2 := UnitsInside ( j ) ;
41407: LD_ADDR_VAR 0 9
41411: PUSH
41412: LD_VAR 0 3
41416: PPUSH
41417: CALL_OW 313
41421: ST_TO_ADDR
// if tmp2 = 6 then
41422: LD_VAR 0 9
41426: PUSH
41427: LD_INT 6
41429: EQUAL
41430: IFFALSE 41461
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
41432: LD_VAR 0 9
41436: PUSH
41437: LD_INT 1
41439: ARRAY
41440: PPUSH
41441: LD_INT 112
41443: PPUSH
41444: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
41448: LD_VAR 0 9
41452: PUSH
41453: LD_INT 1
41455: ARRAY
41456: PPUSH
41457: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
41461: LD_EXP 123
41465: PUSH
41466: LD_VAR 0 2
41470: ARRAY
41471: PUSH
41472: LD_EXP 123
41476: PUSH
41477: LD_VAR 0 2
41481: ARRAY
41482: PUSH
41483: LD_INT 1
41485: ARRAY
41486: PPUSH
41487: CALL_OW 314
41491: NOT
41492: AND
41493: PUSH
41494: LD_EXP 123
41498: PUSH
41499: LD_VAR 0 2
41503: ARRAY
41504: PUSH
41505: LD_INT 1
41507: ARRAY
41508: PPUSH
41509: CALL_OW 310
41513: NOT
41514: AND
41515: IFFALSE 41541
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
41517: LD_EXP 123
41521: PUSH
41522: LD_VAR 0 2
41526: ARRAY
41527: PUSH
41528: LD_INT 1
41530: ARRAY
41531: PPUSH
41532: LD_VAR 0 3
41536: PPUSH
41537: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
41541: LD_EXP 123
41545: PUSH
41546: LD_VAR 0 2
41550: ARRAY
41551: PUSH
41552: LD_INT 1
41554: ARRAY
41555: PPUSH
41556: CALL_OW 310
41560: PUSH
41561: LD_EXP 123
41565: PUSH
41566: LD_VAR 0 2
41570: ARRAY
41571: PUSH
41572: LD_INT 1
41574: ARRAY
41575: PPUSH
41576: CALL_OW 310
41580: PPUSH
41581: CALL_OW 461
41585: PUSH
41586: LD_INT 3
41588: NONEQUAL
41589: AND
41590: IFFALSE 41611
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
41592: LD_EXP 123
41596: PUSH
41597: LD_VAR 0 2
41601: ARRAY
41602: PUSH
41603: LD_INT 1
41605: ARRAY
41606: PPUSH
41607: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
41611: LD_VAR 0 3
41615: PPUSH
41616: CALL_OW 461
41620: PUSH
41621: LD_INT 6
41623: EQUAL
41624: PUSH
41625: LD_VAR 0 6
41629: PUSH
41630: LD_INT 1
41632: GREATER
41633: AND
41634: IFFALSE 41786
// begin sci := [ ] ;
41636: LD_ADDR_VAR 0 8
41640: PUSH
41641: EMPTY
41642: ST_TO_ADDR
// for x in ( tmp diff j ) do
41643: LD_ADDR_VAR 0 7
41647: PUSH
41648: LD_VAR 0 6
41652: PUSH
41653: LD_VAR 0 3
41657: DIFF
41658: PUSH
41659: FOR_IN
41660: IFFALSE 41712
// begin if sci = 6 then
41662: LD_VAR 0 8
41666: PUSH
41667: LD_INT 6
41669: EQUAL
41670: IFFALSE 41674
// break ;
41672: GO 41712
// if BuildingStatus ( x ) = bs_idle then
41674: LD_VAR 0 7
41678: PPUSH
41679: CALL_OW 461
41683: PUSH
41684: LD_INT 2
41686: EQUAL
41687: IFFALSE 41710
// sci := sci ^ UnitsInside ( x ) ;
41689: LD_ADDR_VAR 0 8
41693: PUSH
41694: LD_VAR 0 8
41698: PUSH
41699: LD_VAR 0 7
41703: PPUSH
41704: CALL_OW 313
41708: ADD
41709: ST_TO_ADDR
// end ;
41710: GO 41659
41712: POP
41713: POP
// if not sci then
41714: LD_VAR 0 8
41718: NOT
41719: IFFALSE 41723
// continue ;
41721: GO 40768
// for x in sci do
41723: LD_ADDR_VAR 0 7
41727: PUSH
41728: LD_VAR 0 8
41732: PUSH
41733: FOR_IN
41734: IFFALSE 41784
// if IsInUnit ( x ) and not HasTask ( x ) then
41736: LD_VAR 0 7
41740: PPUSH
41741: CALL_OW 310
41745: PUSH
41746: LD_VAR 0 7
41750: PPUSH
41751: CALL_OW 314
41755: NOT
41756: AND
41757: IFFALSE 41782
// begin ComExitBuilding ( x ) ;
41759: LD_VAR 0 7
41763: PPUSH
41764: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
41768: LD_VAR 0 7
41772: PPUSH
41773: LD_VAR 0 3
41777: PPUSH
41778: CALL_OW 180
// end ;
41782: GO 41733
41784: POP
41785: POP
// end ; end ;
41786: GO 40768
41788: POP
41789: POP
// end ;
41790: GO 40722
41792: POP
41793: POP
// end ;
41794: LD_VAR 0 1
41798: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
41799: LD_INT 0
41801: PPUSH
41802: PPUSH
// if not mc_bases then
41803: LD_EXP 93
41807: NOT
41808: IFFALSE 41812
// exit ;
41810: GO 41893
// for i = 1 to mc_bases do
41812: LD_ADDR_VAR 0 2
41816: PUSH
41817: DOUBLE
41818: LD_INT 1
41820: DEC
41821: ST_TO_ADDR
41822: LD_EXP 93
41826: PUSH
41827: FOR_TO
41828: IFFALSE 41891
// if mc_mines [ i ] and mc_miners [ i ] then
41830: LD_EXP 106
41834: PUSH
41835: LD_VAR 0 2
41839: ARRAY
41840: PUSH
41841: LD_EXP 107
41845: PUSH
41846: LD_VAR 0 2
41850: ARRAY
41851: AND
41852: IFFALSE 41889
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
41854: LD_EXP 107
41858: PUSH
41859: LD_VAR 0 2
41863: ARRAY
41864: PUSH
41865: LD_INT 1
41867: ARRAY
41868: PPUSH
41869: CALL_OW 255
41873: PPUSH
41874: LD_EXP 106
41878: PUSH
41879: LD_VAR 0 2
41883: ARRAY
41884: PPUSH
41885: CALL 57655 0 2
41889: GO 41827
41891: POP
41892: POP
// end ;
41893: LD_VAR 0 1
41897: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
41898: LD_INT 0
41900: PPUSH
41901: PPUSH
41902: PPUSH
41903: PPUSH
41904: PPUSH
41905: PPUSH
41906: PPUSH
41907: PPUSH
// if not mc_bases or not mc_parking then
41908: LD_EXP 93
41912: NOT
41913: PUSH
41914: LD_EXP 117
41918: NOT
41919: OR
41920: IFFALSE 41924
// exit ;
41922: GO 42636
// for i = 1 to mc_bases do
41924: LD_ADDR_VAR 0 2
41928: PUSH
41929: DOUBLE
41930: LD_INT 1
41932: DEC
41933: ST_TO_ADDR
41934: LD_EXP 93
41938: PUSH
41939: FOR_TO
41940: IFFALSE 42634
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
41942: LD_EXP 93
41946: PUSH
41947: LD_VAR 0 2
41951: ARRAY
41952: NOT
41953: PUSH
41954: LD_EXP 117
41958: PUSH
41959: LD_VAR 0 2
41963: ARRAY
41964: NOT
41965: OR
41966: IFFALSE 41970
// continue ;
41968: GO 41939
// if mc_scan [ i ] then
41970: LD_EXP 116
41974: PUSH
41975: LD_VAR 0 2
41979: ARRAY
41980: IFFALSE 42006
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41982: LD_ADDR_EXP 105
41986: PUSH
41987: LD_EXP 105
41991: PPUSH
41992: LD_VAR 0 2
41996: PPUSH
41997: EMPTY
41998: PPUSH
41999: CALL_OW 1
42003: ST_TO_ADDR
// continue ;
42004: GO 41939
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
42006: LD_ADDR_VAR 0 5
42010: PUSH
42011: LD_EXP 93
42015: PUSH
42016: LD_VAR 0 2
42020: ARRAY
42021: PUSH
42022: LD_INT 1
42024: ARRAY
42025: PPUSH
42026: CALL_OW 255
42030: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
42031: LD_ADDR_VAR 0 6
42035: PUSH
42036: LD_EXP 93
42040: PUSH
42041: LD_VAR 0 2
42045: ARRAY
42046: PPUSH
42047: LD_INT 30
42049: PUSH
42050: LD_INT 3
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PPUSH
42057: CALL_OW 72
42061: ST_TO_ADDR
// if not fac then
42062: LD_VAR 0 6
42066: NOT
42067: IFFALSE 42118
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42069: LD_ADDR_VAR 0 6
42073: PUSH
42074: LD_EXP 93
42078: PUSH
42079: LD_VAR 0 2
42083: ARRAY
42084: PPUSH
42085: LD_INT 2
42087: PUSH
42088: LD_INT 30
42090: PUSH
42091: LD_INT 0
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 30
42100: PUSH
42101: LD_INT 1
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: LIST
42112: PPUSH
42113: CALL_OW 72
42117: ST_TO_ADDR
// if not fac then
42118: LD_VAR 0 6
42122: NOT
42123: IFFALSE 42127
// continue ;
42125: GO 41939
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42127: LD_ADDR_VAR 0 7
42131: PUSH
42132: LD_EXP 117
42136: PUSH
42137: LD_VAR 0 2
42141: ARRAY
42142: PPUSH
42143: LD_INT 22
42145: PUSH
42146: LD_VAR 0 5
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 21
42157: PUSH
42158: LD_INT 2
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 3
42167: PUSH
42168: LD_INT 24
42170: PUSH
42171: LD_INT 1000
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: PPUSH
42187: CALL_OW 70
42191: PUSH
42192: LD_INT 22
42194: PUSH
42195: LD_VAR 0 5
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: LD_INT 91
42206: PUSH
42207: LD_VAR 0 6
42211: PUSH
42212: LD_INT 1
42214: ARRAY
42215: PUSH
42216: LD_INT 25
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: LIST
42223: PUSH
42224: LD_INT 21
42226: PUSH
42227: LD_INT 2
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 3
42236: PUSH
42237: LD_INT 24
42239: PUSH
42240: LD_INT 1000
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PPUSH
42257: CALL_OW 69
42261: UNION
42262: ST_TO_ADDR
// if not vehs then
42263: LD_VAR 0 7
42267: NOT
42268: IFFALSE 42294
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42270: LD_ADDR_EXP 105
42274: PUSH
42275: LD_EXP 105
42279: PPUSH
42280: LD_VAR 0 2
42284: PPUSH
42285: EMPTY
42286: PPUSH
42287: CALL_OW 1
42291: ST_TO_ADDR
// continue ;
42292: GO 41939
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
42294: LD_ADDR_VAR 0 8
42298: PUSH
42299: LD_EXP 93
42303: PUSH
42304: LD_VAR 0 2
42308: ARRAY
42309: PPUSH
42310: LD_INT 30
42312: PUSH
42313: LD_INT 3
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: CALL_OW 72
42324: ST_TO_ADDR
// if tmp then
42325: LD_VAR 0 8
42329: IFFALSE 42432
// begin for j in tmp do
42331: LD_ADDR_VAR 0 3
42335: PUSH
42336: LD_VAR 0 8
42340: PUSH
42341: FOR_IN
42342: IFFALSE 42430
// for k in UnitsInside ( j ) do
42344: LD_ADDR_VAR 0 4
42348: PUSH
42349: LD_VAR 0 3
42353: PPUSH
42354: CALL_OW 313
42358: PUSH
42359: FOR_IN
42360: IFFALSE 42426
// if k then
42362: LD_VAR 0 4
42366: IFFALSE 42424
// if not k in mc_repair_vehicle [ i ] then
42368: LD_VAR 0 4
42372: PUSH
42373: LD_EXP 105
42377: PUSH
42378: LD_VAR 0 2
42382: ARRAY
42383: IN
42384: NOT
42385: IFFALSE 42424
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
42387: LD_ADDR_EXP 105
42391: PUSH
42392: LD_EXP 105
42396: PPUSH
42397: LD_VAR 0 2
42401: PPUSH
42402: LD_EXP 105
42406: PUSH
42407: LD_VAR 0 2
42411: ARRAY
42412: PUSH
42413: LD_VAR 0 4
42417: UNION
42418: PPUSH
42419: CALL_OW 1
42423: ST_TO_ADDR
42424: GO 42359
42426: POP
42427: POP
42428: GO 42341
42430: POP
42431: POP
// end ; if not mc_repair_vehicle [ i ] then
42432: LD_EXP 105
42436: PUSH
42437: LD_VAR 0 2
42441: ARRAY
42442: NOT
42443: IFFALSE 42447
// continue ;
42445: GO 41939
// for j in mc_repair_vehicle [ i ] do
42447: LD_ADDR_VAR 0 3
42451: PUSH
42452: LD_EXP 105
42456: PUSH
42457: LD_VAR 0 2
42461: ARRAY
42462: PUSH
42463: FOR_IN
42464: IFFALSE 42630
// begin if GetClass ( j ) <> 3 then
42466: LD_VAR 0 3
42470: PPUSH
42471: CALL_OW 257
42475: PUSH
42476: LD_INT 3
42478: NONEQUAL
42479: IFFALSE 42520
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
42481: LD_ADDR_EXP 105
42485: PUSH
42486: LD_EXP 105
42490: PPUSH
42491: LD_VAR 0 2
42495: PPUSH
42496: LD_EXP 105
42500: PUSH
42501: LD_VAR 0 2
42505: ARRAY
42506: PUSH
42507: LD_VAR 0 3
42511: DIFF
42512: PPUSH
42513: CALL_OW 1
42517: ST_TO_ADDR
// continue ;
42518: GO 42463
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42520: LD_VAR 0 3
42524: PPUSH
42525: CALL_OW 311
42529: NOT
42530: PUSH
42531: LD_VAR 0 3
42535: PUSH
42536: LD_EXP 96
42540: PUSH
42541: LD_VAR 0 2
42545: ARRAY
42546: PUSH
42547: LD_INT 1
42549: ARRAY
42550: IN
42551: NOT
42552: AND
42553: PUSH
42554: LD_VAR 0 3
42558: PUSH
42559: LD_EXP 96
42563: PUSH
42564: LD_VAR 0 2
42568: ARRAY
42569: PUSH
42570: LD_INT 2
42572: ARRAY
42573: IN
42574: NOT
42575: AND
42576: IFFALSE 42628
// begin if IsInUnit ( j ) then
42578: LD_VAR 0 3
42582: PPUSH
42583: CALL_OW 310
42587: IFFALSE 42598
// ComExitBuilding ( j ) ;
42589: LD_VAR 0 3
42593: PPUSH
42594: CALL_OW 122
// if not HasTask ( j ) then
42598: LD_VAR 0 3
42602: PPUSH
42603: CALL_OW 314
42607: NOT
42608: IFFALSE 42628
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
42610: LD_VAR 0 3
42614: PPUSH
42615: LD_VAR 0 7
42619: PUSH
42620: LD_INT 1
42622: ARRAY
42623: PPUSH
42624: CALL_OW 189
// end ; end ;
42628: GO 42463
42630: POP
42631: POP
// end ;
42632: GO 41939
42634: POP
42635: POP
// end ;
42636: LD_VAR 0 1
42640: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
42641: LD_INT 0
42643: PPUSH
42644: PPUSH
42645: PPUSH
42646: PPUSH
42647: PPUSH
42648: PPUSH
42649: PPUSH
42650: PPUSH
42651: PPUSH
42652: PPUSH
42653: PPUSH
// if not mc_bases then
42654: LD_EXP 93
42658: NOT
42659: IFFALSE 42663
// exit ;
42661: GO 43465
// for i = 1 to mc_bases do
42663: LD_ADDR_VAR 0 2
42667: PUSH
42668: DOUBLE
42669: LD_INT 1
42671: DEC
42672: ST_TO_ADDR
42673: LD_EXP 93
42677: PUSH
42678: FOR_TO
42679: IFFALSE 43463
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
42681: LD_EXP 121
42685: PUSH
42686: LD_VAR 0 2
42690: ARRAY
42691: NOT
42692: PUSH
42693: LD_EXP 96
42697: PUSH
42698: LD_VAR 0 2
42702: ARRAY
42703: PUSH
42704: LD_INT 1
42706: ARRAY
42707: OR
42708: PUSH
42709: LD_EXP 96
42713: PUSH
42714: LD_VAR 0 2
42718: ARRAY
42719: PUSH
42720: LD_INT 2
42722: ARRAY
42723: OR
42724: PUSH
42725: LD_EXP 119
42729: PUSH
42730: LD_VAR 0 2
42734: ARRAY
42735: PPUSH
42736: LD_INT 1
42738: PPUSH
42739: CALL_OW 325
42743: NOT
42744: OR
42745: PUSH
42746: LD_EXP 116
42750: PUSH
42751: LD_VAR 0 2
42755: ARRAY
42756: OR
42757: IFFALSE 42761
// continue ;
42759: GO 42678
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
42761: LD_ADDR_VAR 0 8
42765: PUSH
42766: LD_EXP 93
42770: PUSH
42771: LD_VAR 0 2
42775: ARRAY
42776: PPUSH
42777: LD_INT 25
42779: PUSH
42780: LD_INT 4
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 50
42789: PUSH
42790: EMPTY
42791: LIST
42792: PUSH
42793: LD_INT 3
42795: PUSH
42796: LD_INT 60
42798: PUSH
42799: EMPTY
42800: LIST
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: LIST
42810: PPUSH
42811: CALL_OW 72
42815: PUSH
42816: LD_EXP 97
42820: PUSH
42821: LD_VAR 0 2
42825: ARRAY
42826: DIFF
42827: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42828: LD_ADDR_VAR 0 9
42832: PUSH
42833: LD_EXP 93
42837: PUSH
42838: LD_VAR 0 2
42842: ARRAY
42843: PPUSH
42844: LD_INT 2
42846: PUSH
42847: LD_INT 30
42849: PUSH
42850: LD_INT 0
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 30
42859: PUSH
42860: LD_INT 1
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: LIST
42871: PPUSH
42872: CALL_OW 72
42876: ST_TO_ADDR
// if not tmp or not dep then
42877: LD_VAR 0 8
42881: NOT
42882: PUSH
42883: LD_VAR 0 9
42887: NOT
42888: OR
42889: IFFALSE 42893
// continue ;
42891: GO 42678
// side := GetSide ( tmp [ 1 ] ) ;
42893: LD_ADDR_VAR 0 11
42897: PUSH
42898: LD_VAR 0 8
42902: PUSH
42903: LD_INT 1
42905: ARRAY
42906: PPUSH
42907: CALL_OW 255
42911: ST_TO_ADDR
// dep := dep [ 1 ] ;
42912: LD_ADDR_VAR 0 9
42916: PUSH
42917: LD_VAR 0 9
42921: PUSH
42922: LD_INT 1
42924: ARRAY
42925: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
42926: LD_ADDR_VAR 0 7
42930: PUSH
42931: LD_EXP 121
42935: PUSH
42936: LD_VAR 0 2
42940: ARRAY
42941: PPUSH
42942: LD_INT 22
42944: PUSH
42945: LD_INT 0
42947: PUSH
42948: EMPTY
42949: LIST
42950: LIST
42951: PUSH
42952: LD_INT 25
42954: PUSH
42955: LD_INT 12
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: PPUSH
42966: CALL_OW 70
42970: PUSH
42971: LD_INT 22
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 25
42983: PUSH
42984: LD_INT 12
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 91
42993: PUSH
42994: LD_VAR 0 9
42998: PUSH
42999: LD_INT 20
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: LIST
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: LIST
43011: PPUSH
43012: CALL_OW 69
43016: UNION
43017: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
43018: LD_ADDR_VAR 0 10
43022: PUSH
43023: LD_EXP 121
43027: PUSH
43028: LD_VAR 0 2
43032: ARRAY
43033: PPUSH
43034: LD_INT 81
43036: PUSH
43037: LD_VAR 0 11
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PPUSH
43046: CALL_OW 70
43050: ST_TO_ADDR
// if not apes or danger_at_area then
43051: LD_VAR 0 7
43055: NOT
43056: PUSH
43057: LD_VAR 0 10
43061: OR
43062: IFFALSE 43112
// begin if mc_taming [ i ] then
43064: LD_EXP 124
43068: PUSH
43069: LD_VAR 0 2
43073: ARRAY
43074: IFFALSE 43110
// begin MC_Reset ( i , 121 ) ;
43076: LD_VAR 0 2
43080: PPUSH
43081: LD_INT 121
43083: PPUSH
43084: CALL 29070 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43088: LD_ADDR_EXP 124
43092: PUSH
43093: LD_EXP 124
43097: PPUSH
43098: LD_VAR 0 2
43102: PPUSH
43103: EMPTY
43104: PPUSH
43105: CALL_OW 1
43109: ST_TO_ADDR
// end ; continue ;
43110: GO 42678
// end ; for j in tmp do
43112: LD_ADDR_VAR 0 3
43116: PUSH
43117: LD_VAR 0 8
43121: PUSH
43122: FOR_IN
43123: IFFALSE 43459
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
43125: LD_VAR 0 3
43129: PUSH
43130: LD_EXP 124
43134: PUSH
43135: LD_VAR 0 2
43139: ARRAY
43140: IN
43141: NOT
43142: PUSH
43143: LD_EXP 124
43147: PUSH
43148: LD_VAR 0 2
43152: ARRAY
43153: PUSH
43154: LD_INT 3
43156: LESS
43157: AND
43158: IFFALSE 43216
// begin SetTag ( j , 121 ) ;
43160: LD_VAR 0 3
43164: PPUSH
43165: LD_INT 121
43167: PPUSH
43168: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
43172: LD_ADDR_EXP 124
43176: PUSH
43177: LD_EXP 124
43181: PPUSH
43182: LD_VAR 0 2
43186: PUSH
43187: LD_EXP 124
43191: PUSH
43192: LD_VAR 0 2
43196: ARRAY
43197: PUSH
43198: LD_INT 1
43200: PLUS
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PPUSH
43206: LD_VAR 0 3
43210: PPUSH
43211: CALL 60598 0 3
43215: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
43216: LD_VAR 0 3
43220: PUSH
43221: LD_EXP 124
43225: PUSH
43226: LD_VAR 0 2
43230: ARRAY
43231: IN
43232: IFFALSE 43457
// begin if GetClass ( j ) <> 4 then
43234: LD_VAR 0 3
43238: PPUSH
43239: CALL_OW 257
43243: PUSH
43244: LD_INT 4
43246: NONEQUAL
43247: IFFALSE 43300
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
43249: LD_ADDR_EXP 124
43253: PUSH
43254: LD_EXP 124
43258: PPUSH
43259: LD_VAR 0 2
43263: PPUSH
43264: LD_EXP 124
43268: PUSH
43269: LD_VAR 0 2
43273: ARRAY
43274: PUSH
43275: LD_VAR 0 3
43279: DIFF
43280: PPUSH
43281: CALL_OW 1
43285: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43286: LD_VAR 0 3
43290: PPUSH
43291: LD_INT 0
43293: PPUSH
43294: CALL_OW 109
// continue ;
43298: GO 43122
// end ; if IsInUnit ( j ) then
43300: LD_VAR 0 3
43304: PPUSH
43305: CALL_OW 310
43309: IFFALSE 43320
// ComExitBuilding ( j ) ;
43311: LD_VAR 0 3
43315: PPUSH
43316: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
43320: LD_ADDR_VAR 0 6
43324: PUSH
43325: LD_VAR 0 7
43329: PPUSH
43330: LD_VAR 0 3
43334: PPUSH
43335: CALL_OW 74
43339: ST_TO_ADDR
// if not ape then
43340: LD_VAR 0 6
43344: NOT
43345: IFFALSE 43349
// break ;
43347: GO 43459
// x := GetX ( ape ) ;
43349: LD_ADDR_VAR 0 4
43353: PUSH
43354: LD_VAR 0 6
43358: PPUSH
43359: CALL_OW 250
43363: ST_TO_ADDR
// y := GetY ( ape ) ;
43364: LD_ADDR_VAR 0 5
43368: PUSH
43369: LD_VAR 0 6
43373: PPUSH
43374: CALL_OW 251
43378: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
43379: LD_VAR 0 4
43383: PPUSH
43384: LD_VAR 0 5
43388: PPUSH
43389: CALL_OW 488
43393: NOT
43394: PUSH
43395: LD_VAR 0 11
43399: PPUSH
43400: LD_VAR 0 4
43404: PPUSH
43405: LD_VAR 0 5
43409: PPUSH
43410: LD_INT 20
43412: PPUSH
43413: CALL 61494 0 4
43417: PUSH
43418: LD_INT 4
43420: ARRAY
43421: OR
43422: IFFALSE 43426
// break ;
43424: GO 43459
// if not HasTask ( j ) then
43426: LD_VAR 0 3
43430: PPUSH
43431: CALL_OW 314
43435: NOT
43436: IFFALSE 43457
// ComTameXY ( j , x , y ) ;
43438: LD_VAR 0 3
43442: PPUSH
43443: LD_VAR 0 4
43447: PPUSH
43448: LD_VAR 0 5
43452: PPUSH
43453: CALL_OW 131
// end ; end ;
43457: GO 43122
43459: POP
43460: POP
// end ;
43461: GO 42678
43463: POP
43464: POP
// end ;
43465: LD_VAR 0 1
43469: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
43470: LD_INT 0
43472: PPUSH
43473: PPUSH
43474: PPUSH
43475: PPUSH
43476: PPUSH
43477: PPUSH
43478: PPUSH
43479: PPUSH
// if not mc_bases then
43480: LD_EXP 93
43484: NOT
43485: IFFALSE 43489
// exit ;
43487: GO 44115
// for i = 1 to mc_bases do
43489: LD_ADDR_VAR 0 2
43493: PUSH
43494: DOUBLE
43495: LD_INT 1
43497: DEC
43498: ST_TO_ADDR
43499: LD_EXP 93
43503: PUSH
43504: FOR_TO
43505: IFFALSE 44113
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
43507: LD_EXP 122
43511: PUSH
43512: LD_VAR 0 2
43516: ARRAY
43517: NOT
43518: PUSH
43519: LD_EXP 122
43523: PUSH
43524: LD_VAR 0 2
43528: ARRAY
43529: PPUSH
43530: LD_INT 25
43532: PUSH
43533: LD_INT 12
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PPUSH
43540: CALL_OW 72
43544: NOT
43545: OR
43546: IFFALSE 43550
// continue ;
43548: GO 43504
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
43550: LD_ADDR_VAR 0 5
43554: PUSH
43555: LD_EXP 122
43559: PUSH
43560: LD_VAR 0 2
43564: ARRAY
43565: PUSH
43566: LD_INT 1
43568: ARRAY
43569: PPUSH
43570: CALL_OW 255
43574: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
43575: LD_VAR 0 5
43579: PPUSH
43580: LD_INT 2
43582: PPUSH
43583: CALL_OW 325
43587: IFFALSE 43840
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43589: LD_ADDR_VAR 0 4
43593: PUSH
43594: LD_EXP 122
43598: PUSH
43599: LD_VAR 0 2
43603: ARRAY
43604: PPUSH
43605: LD_INT 25
43607: PUSH
43608: LD_INT 16
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PPUSH
43615: CALL_OW 72
43619: ST_TO_ADDR
// if tmp < 6 then
43620: LD_VAR 0 4
43624: PUSH
43625: LD_INT 6
43627: LESS
43628: IFFALSE 43840
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43630: LD_ADDR_VAR 0 6
43634: PUSH
43635: LD_EXP 93
43639: PUSH
43640: LD_VAR 0 2
43644: ARRAY
43645: PPUSH
43646: LD_INT 2
43648: PUSH
43649: LD_INT 30
43651: PUSH
43652: LD_INT 0
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: LD_INT 30
43661: PUSH
43662: LD_INT 1
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: LIST
43673: PPUSH
43674: CALL_OW 72
43678: ST_TO_ADDR
// if depot then
43679: LD_VAR 0 6
43683: IFFALSE 43840
// begin selected := 0 ;
43685: LD_ADDR_VAR 0 7
43689: PUSH
43690: LD_INT 0
43692: ST_TO_ADDR
// for j in depot do
43693: LD_ADDR_VAR 0 3
43697: PUSH
43698: LD_VAR 0 6
43702: PUSH
43703: FOR_IN
43704: IFFALSE 43735
// begin if UnitsInside ( j ) < 6 then
43706: LD_VAR 0 3
43710: PPUSH
43711: CALL_OW 313
43715: PUSH
43716: LD_INT 6
43718: LESS
43719: IFFALSE 43733
// begin selected := j ;
43721: LD_ADDR_VAR 0 7
43725: PUSH
43726: LD_VAR 0 3
43730: ST_TO_ADDR
// break ;
43731: GO 43735
// end ; end ;
43733: GO 43703
43735: POP
43736: POP
// if selected then
43737: LD_VAR 0 7
43741: IFFALSE 43840
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43743: LD_ADDR_VAR 0 3
43747: PUSH
43748: LD_EXP 122
43752: PUSH
43753: LD_VAR 0 2
43757: ARRAY
43758: PPUSH
43759: LD_INT 25
43761: PUSH
43762: LD_INT 12
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PPUSH
43769: CALL_OW 72
43773: PUSH
43774: FOR_IN
43775: IFFALSE 43838
// if not HasTask ( j ) then
43777: LD_VAR 0 3
43781: PPUSH
43782: CALL_OW 314
43786: NOT
43787: IFFALSE 43836
// begin if not IsInUnit ( j ) then
43789: LD_VAR 0 3
43793: PPUSH
43794: CALL_OW 310
43798: NOT
43799: IFFALSE 43815
// ComEnterUnit ( j , selected ) ;
43801: LD_VAR 0 3
43805: PPUSH
43806: LD_VAR 0 7
43810: PPUSH
43811: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
43815: LD_VAR 0 3
43819: PPUSH
43820: LD_INT 16
43822: PPUSH
43823: CALL_OW 183
// AddComExitBuilding ( j ) ;
43827: LD_VAR 0 3
43831: PPUSH
43832: CALL_OW 182
// end ;
43836: GO 43774
43838: POP
43839: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
43840: LD_VAR 0 5
43844: PPUSH
43845: LD_INT 11
43847: PPUSH
43848: CALL_OW 325
43852: IFFALSE 44111
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43854: LD_ADDR_VAR 0 4
43858: PUSH
43859: LD_EXP 122
43863: PUSH
43864: LD_VAR 0 2
43868: ARRAY
43869: PPUSH
43870: LD_INT 25
43872: PUSH
43873: LD_INT 16
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PPUSH
43880: CALL_OW 72
43884: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
43885: LD_VAR 0 4
43889: PUSH
43890: LD_INT 6
43892: GREATEREQUAL
43893: PUSH
43894: LD_VAR 0 5
43898: PPUSH
43899: LD_INT 2
43901: PPUSH
43902: CALL_OW 325
43906: NOT
43907: OR
43908: IFFALSE 44111
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43910: LD_ADDR_VAR 0 8
43914: PUSH
43915: LD_EXP 93
43919: PUSH
43920: LD_VAR 0 2
43924: ARRAY
43925: PPUSH
43926: LD_INT 2
43928: PUSH
43929: LD_INT 30
43931: PUSH
43932: LD_INT 4
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 30
43941: PUSH
43942: LD_INT 5
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: LIST
43953: PPUSH
43954: CALL_OW 72
43958: ST_TO_ADDR
// if barracks then
43959: LD_VAR 0 8
43963: IFFALSE 44111
// begin selected := 0 ;
43965: LD_ADDR_VAR 0 7
43969: PUSH
43970: LD_INT 0
43972: ST_TO_ADDR
// for j in barracks do
43973: LD_ADDR_VAR 0 3
43977: PUSH
43978: LD_VAR 0 8
43982: PUSH
43983: FOR_IN
43984: IFFALSE 44015
// begin if UnitsInside ( j ) < 6 then
43986: LD_VAR 0 3
43990: PPUSH
43991: CALL_OW 313
43995: PUSH
43996: LD_INT 6
43998: LESS
43999: IFFALSE 44013
// begin selected := j ;
44001: LD_ADDR_VAR 0 7
44005: PUSH
44006: LD_VAR 0 3
44010: ST_TO_ADDR
// break ;
44011: GO 44015
// end ; end ;
44013: GO 43983
44015: POP
44016: POP
// if selected then
44017: LD_VAR 0 7
44021: IFFALSE 44111
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
44023: LD_ADDR_VAR 0 3
44027: PUSH
44028: LD_EXP 122
44032: PUSH
44033: LD_VAR 0 2
44037: ARRAY
44038: PPUSH
44039: LD_INT 25
44041: PUSH
44042: LD_INT 12
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PPUSH
44049: CALL_OW 72
44053: PUSH
44054: FOR_IN
44055: IFFALSE 44109
// if not IsInUnit ( j ) and not HasTask ( j ) then
44057: LD_VAR 0 3
44061: PPUSH
44062: CALL_OW 310
44066: NOT
44067: PUSH
44068: LD_VAR 0 3
44072: PPUSH
44073: CALL_OW 314
44077: NOT
44078: AND
44079: IFFALSE 44107
// begin ComEnterUnit ( j , selected ) ;
44081: LD_VAR 0 3
44085: PPUSH
44086: LD_VAR 0 7
44090: PPUSH
44091: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
44095: LD_VAR 0 3
44099: PPUSH
44100: LD_INT 15
44102: PPUSH
44103: CALL_OW 183
// end ;
44107: GO 44054
44109: POP
44110: POP
// end ; end ; end ; end ; end ;
44111: GO 43504
44113: POP
44114: POP
// end ;
44115: LD_VAR 0 1
44119: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
44120: LD_INT 0
44122: PPUSH
44123: PPUSH
44124: PPUSH
44125: PPUSH
// if not mc_bases then
44126: LD_EXP 93
44130: NOT
44131: IFFALSE 44135
// exit ;
44133: GO 44313
// for i = 1 to mc_bases do
44135: LD_ADDR_VAR 0 2
44139: PUSH
44140: DOUBLE
44141: LD_INT 1
44143: DEC
44144: ST_TO_ADDR
44145: LD_EXP 93
44149: PUSH
44150: FOR_TO
44151: IFFALSE 44311
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
44153: LD_ADDR_VAR 0 4
44157: PUSH
44158: LD_EXP 93
44162: PUSH
44163: LD_VAR 0 2
44167: ARRAY
44168: PPUSH
44169: LD_INT 25
44171: PUSH
44172: LD_INT 9
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PPUSH
44179: CALL_OW 72
44183: ST_TO_ADDR
// if not tmp then
44184: LD_VAR 0 4
44188: NOT
44189: IFFALSE 44193
// continue ;
44191: GO 44150
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
44193: LD_EXP 119
44197: PUSH
44198: LD_VAR 0 2
44202: ARRAY
44203: PPUSH
44204: LD_INT 29
44206: PPUSH
44207: CALL_OW 325
44211: NOT
44212: PUSH
44213: LD_EXP 119
44217: PUSH
44218: LD_VAR 0 2
44222: ARRAY
44223: PPUSH
44224: LD_INT 28
44226: PPUSH
44227: CALL_OW 325
44231: NOT
44232: AND
44233: IFFALSE 44237
// continue ;
44235: GO 44150
// for j in tmp do
44237: LD_ADDR_VAR 0 3
44241: PUSH
44242: LD_VAR 0 4
44246: PUSH
44247: FOR_IN
44248: IFFALSE 44307
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
44250: LD_VAR 0 3
44254: PUSH
44255: LD_EXP 96
44259: PUSH
44260: LD_VAR 0 2
44264: ARRAY
44265: PUSH
44266: LD_INT 1
44268: ARRAY
44269: IN
44270: NOT
44271: PUSH
44272: LD_VAR 0 3
44276: PUSH
44277: LD_EXP 96
44281: PUSH
44282: LD_VAR 0 2
44286: ARRAY
44287: PUSH
44288: LD_INT 2
44290: ARRAY
44291: IN
44292: NOT
44293: AND
44294: IFFALSE 44305
// ComSpaceTimeShoot ( j ) ;
44296: LD_VAR 0 3
44300: PPUSH
44301: CALL 54658 0 1
44305: GO 44247
44307: POP
44308: POP
// end ;
44309: GO 44150
44311: POP
44312: POP
// end ;
44313: LD_VAR 0 1
44317: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
44318: LD_INT 0
44320: PPUSH
44321: PPUSH
44322: PPUSH
44323: PPUSH
44324: PPUSH
44325: PPUSH
44326: PPUSH
44327: PPUSH
44328: PPUSH
// if not mc_bases then
44329: LD_EXP 93
44333: NOT
44334: IFFALSE 44338
// exit ;
44336: GO 44960
// for i = 1 to mc_bases do
44338: LD_ADDR_VAR 0 2
44342: PUSH
44343: DOUBLE
44344: LD_INT 1
44346: DEC
44347: ST_TO_ADDR
44348: LD_EXP 93
44352: PUSH
44353: FOR_TO
44354: IFFALSE 44958
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
44356: LD_EXP 128
44360: PUSH
44361: LD_VAR 0 2
44365: ARRAY
44366: NOT
44367: PUSH
44368: LD_INT 38
44370: PPUSH
44371: LD_EXP 119
44375: PUSH
44376: LD_VAR 0 2
44380: ARRAY
44381: PPUSH
44382: CALL_OW 321
44386: PUSH
44387: LD_INT 2
44389: NONEQUAL
44390: OR
44391: IFFALSE 44395
// continue ;
44393: GO 44353
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
44395: LD_ADDR_VAR 0 8
44399: PUSH
44400: LD_EXP 93
44404: PUSH
44405: LD_VAR 0 2
44409: ARRAY
44410: PPUSH
44411: LD_INT 30
44413: PUSH
44414: LD_INT 34
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PPUSH
44421: CALL_OW 72
44425: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
44426: LD_ADDR_VAR 0 9
44430: PUSH
44431: LD_EXP 93
44435: PUSH
44436: LD_VAR 0 2
44440: ARRAY
44441: PPUSH
44442: LD_INT 25
44444: PUSH
44445: LD_INT 4
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PPUSH
44452: CALL_OW 72
44456: PPUSH
44457: LD_INT 0
44459: PPUSH
44460: CALL 93795 0 2
44464: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
44465: LD_VAR 0 9
44469: NOT
44470: PUSH
44471: LD_VAR 0 8
44475: NOT
44476: OR
44477: PUSH
44478: LD_EXP 93
44482: PUSH
44483: LD_VAR 0 2
44487: ARRAY
44488: PPUSH
44489: LD_INT 124
44491: PPUSH
44492: CALL 93795 0 2
44496: OR
44497: IFFALSE 44501
// continue ;
44499: GO 44353
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
44501: LD_EXP 129
44505: PUSH
44506: LD_VAR 0 2
44510: ARRAY
44511: PUSH
44512: LD_EXP 128
44516: PUSH
44517: LD_VAR 0 2
44521: ARRAY
44522: LESS
44523: PUSH
44524: LD_EXP 129
44528: PUSH
44529: LD_VAR 0 2
44533: ARRAY
44534: PUSH
44535: LD_VAR 0 8
44539: LESS
44540: AND
44541: IFFALSE 44956
// begin tmp := sci [ 1 ] ;
44543: LD_ADDR_VAR 0 7
44547: PUSH
44548: LD_VAR 0 9
44552: PUSH
44553: LD_INT 1
44555: ARRAY
44556: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
44557: LD_VAR 0 7
44561: PPUSH
44562: LD_INT 124
44564: PPUSH
44565: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
44569: LD_ADDR_VAR 0 3
44573: PUSH
44574: DOUBLE
44575: LD_EXP 128
44579: PUSH
44580: LD_VAR 0 2
44584: ARRAY
44585: INC
44586: ST_TO_ADDR
44587: LD_EXP 128
44591: PUSH
44592: LD_VAR 0 2
44596: ARRAY
44597: PUSH
44598: FOR_DOWNTO
44599: IFFALSE 44942
// begin if IsInUnit ( tmp ) then
44601: LD_VAR 0 7
44605: PPUSH
44606: CALL_OW 310
44610: IFFALSE 44621
// ComExitBuilding ( tmp ) ;
44612: LD_VAR 0 7
44616: PPUSH
44617: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
44621: LD_INT 35
44623: PPUSH
44624: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
44628: LD_VAR 0 7
44632: PPUSH
44633: CALL_OW 310
44637: NOT
44638: PUSH
44639: LD_VAR 0 7
44643: PPUSH
44644: CALL_OW 314
44648: NOT
44649: AND
44650: IFFALSE 44621
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
44652: LD_ADDR_VAR 0 6
44656: PUSH
44657: LD_VAR 0 7
44661: PPUSH
44662: CALL_OW 250
44666: PUSH
44667: LD_VAR 0 7
44671: PPUSH
44672: CALL_OW 251
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
44681: LD_INT 35
44683: PPUSH
44684: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
44688: LD_ADDR_VAR 0 4
44692: PUSH
44693: LD_EXP 128
44697: PUSH
44698: LD_VAR 0 2
44702: ARRAY
44703: PUSH
44704: LD_VAR 0 3
44708: ARRAY
44709: PUSH
44710: LD_INT 1
44712: ARRAY
44713: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
44714: LD_ADDR_VAR 0 5
44718: PUSH
44719: LD_EXP 128
44723: PUSH
44724: LD_VAR 0 2
44728: ARRAY
44729: PUSH
44730: LD_VAR 0 3
44734: ARRAY
44735: PUSH
44736: LD_INT 2
44738: ARRAY
44739: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
44740: LD_VAR 0 7
44744: PPUSH
44745: LD_INT 10
44747: PPUSH
44748: CALL 63191 0 2
44752: PUSH
44753: LD_INT 4
44755: ARRAY
44756: IFFALSE 44794
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
44758: LD_VAR 0 7
44762: PPUSH
44763: LD_VAR 0 6
44767: PUSH
44768: LD_INT 1
44770: ARRAY
44771: PPUSH
44772: LD_VAR 0 6
44776: PUSH
44777: LD_INT 2
44779: ARRAY
44780: PPUSH
44781: CALL_OW 111
// wait ( 0 0$10 ) ;
44785: LD_INT 350
44787: PPUSH
44788: CALL_OW 67
// end else
44792: GO 44820
// begin ComMoveXY ( tmp , x , y ) ;
44794: LD_VAR 0 7
44798: PPUSH
44799: LD_VAR 0 4
44803: PPUSH
44804: LD_VAR 0 5
44808: PPUSH
44809: CALL_OW 111
// wait ( 0 0$3 ) ;
44813: LD_INT 105
44815: PPUSH
44816: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
44820: LD_VAR 0 7
44824: PPUSH
44825: LD_VAR 0 4
44829: PPUSH
44830: LD_VAR 0 5
44834: PPUSH
44835: CALL_OW 307
44839: IFFALSE 44681
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
44841: LD_VAR 0 7
44845: PPUSH
44846: LD_VAR 0 4
44850: PPUSH
44851: LD_VAR 0 5
44855: PPUSH
44856: LD_VAR 0 8
44860: PUSH
44861: LD_VAR 0 3
44865: ARRAY
44866: PPUSH
44867: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
44871: LD_INT 35
44873: PPUSH
44874: CALL_OW 67
// until not HasTask ( tmp ) ;
44878: LD_VAR 0 7
44882: PPUSH
44883: CALL_OW 314
44887: NOT
44888: IFFALSE 44871
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
44890: LD_ADDR_EXP 129
44894: PUSH
44895: LD_EXP 129
44899: PPUSH
44900: LD_VAR 0 2
44904: PUSH
44905: LD_EXP 129
44909: PUSH
44910: LD_VAR 0 2
44914: ARRAY
44915: PUSH
44916: LD_INT 1
44918: PLUS
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PPUSH
44924: LD_VAR 0 8
44928: PUSH
44929: LD_VAR 0 3
44933: ARRAY
44934: PPUSH
44935: CALL 60598 0 3
44939: ST_TO_ADDR
// end ;
44940: GO 44598
44942: POP
44943: POP
// MC_Reset ( i , 124 ) ;
44944: LD_VAR 0 2
44948: PPUSH
44949: LD_INT 124
44951: PPUSH
44952: CALL 29070 0 2
// end ; end ;
44956: GO 44353
44958: POP
44959: POP
// end ;
44960: LD_VAR 0 1
44964: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
44965: LD_INT 0
44967: PPUSH
44968: PPUSH
44969: PPUSH
// if not mc_bases then
44970: LD_EXP 93
44974: NOT
44975: IFFALSE 44979
// exit ;
44977: GO 45585
// for i = 1 to mc_bases do
44979: LD_ADDR_VAR 0 2
44983: PUSH
44984: DOUBLE
44985: LD_INT 1
44987: DEC
44988: ST_TO_ADDR
44989: LD_EXP 93
44993: PUSH
44994: FOR_TO
44995: IFFALSE 45583
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44997: LD_ADDR_VAR 0 3
45001: PUSH
45002: LD_EXP 93
45006: PUSH
45007: LD_VAR 0 2
45011: ARRAY
45012: PPUSH
45013: LD_INT 25
45015: PUSH
45016: LD_INT 4
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PPUSH
45023: CALL_OW 72
45027: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45028: LD_VAR 0 3
45032: NOT
45033: PUSH
45034: LD_EXP 130
45038: PUSH
45039: LD_VAR 0 2
45043: ARRAY
45044: NOT
45045: OR
45046: PUSH
45047: LD_EXP 93
45051: PUSH
45052: LD_VAR 0 2
45056: ARRAY
45057: PPUSH
45058: LD_INT 2
45060: PUSH
45061: LD_INT 30
45063: PUSH
45064: LD_INT 0
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: PUSH
45071: LD_INT 30
45073: PUSH
45074: LD_INT 1
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: LIST
45085: PPUSH
45086: CALL_OW 72
45090: NOT
45091: OR
45092: IFFALSE 45142
// begin if mc_deposits_finder [ i ] then
45094: LD_EXP 131
45098: PUSH
45099: LD_VAR 0 2
45103: ARRAY
45104: IFFALSE 45140
// begin MC_Reset ( i , 125 ) ;
45106: LD_VAR 0 2
45110: PPUSH
45111: LD_INT 125
45113: PPUSH
45114: CALL 29070 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
45118: LD_ADDR_EXP 131
45122: PUSH
45123: LD_EXP 131
45127: PPUSH
45128: LD_VAR 0 2
45132: PPUSH
45133: EMPTY
45134: PPUSH
45135: CALL_OW 1
45139: ST_TO_ADDR
// end ; continue ;
45140: GO 44994
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
45142: LD_EXP 130
45146: PUSH
45147: LD_VAR 0 2
45151: ARRAY
45152: PUSH
45153: LD_INT 1
45155: ARRAY
45156: PUSH
45157: LD_INT 3
45159: ARRAY
45160: PUSH
45161: LD_INT 1
45163: EQUAL
45164: PUSH
45165: LD_INT 20
45167: PPUSH
45168: LD_EXP 119
45172: PUSH
45173: LD_VAR 0 2
45177: ARRAY
45178: PPUSH
45179: CALL_OW 321
45183: PUSH
45184: LD_INT 2
45186: NONEQUAL
45187: AND
45188: IFFALSE 45238
// begin if mc_deposits_finder [ i ] then
45190: LD_EXP 131
45194: PUSH
45195: LD_VAR 0 2
45199: ARRAY
45200: IFFALSE 45236
// begin MC_Reset ( i , 125 ) ;
45202: LD_VAR 0 2
45206: PPUSH
45207: LD_INT 125
45209: PPUSH
45210: CALL 29070 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
45214: LD_ADDR_EXP 131
45218: PUSH
45219: LD_EXP 131
45223: PPUSH
45224: LD_VAR 0 2
45228: PPUSH
45229: EMPTY
45230: PPUSH
45231: CALL_OW 1
45235: ST_TO_ADDR
// end ; continue ;
45236: GO 44994
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
45238: LD_EXP 130
45242: PUSH
45243: LD_VAR 0 2
45247: ARRAY
45248: PUSH
45249: LD_INT 1
45251: ARRAY
45252: PUSH
45253: LD_INT 1
45255: ARRAY
45256: PPUSH
45257: LD_EXP 130
45261: PUSH
45262: LD_VAR 0 2
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: ARRAY
45271: PUSH
45272: LD_INT 2
45274: ARRAY
45275: PPUSH
45276: LD_EXP 119
45280: PUSH
45281: LD_VAR 0 2
45285: ARRAY
45286: PPUSH
45287: CALL_OW 440
45291: IFFALSE 45334
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
45293: LD_ADDR_EXP 130
45297: PUSH
45298: LD_EXP 130
45302: PPUSH
45303: LD_VAR 0 2
45307: PPUSH
45308: LD_EXP 130
45312: PUSH
45313: LD_VAR 0 2
45317: ARRAY
45318: PPUSH
45319: LD_INT 1
45321: PPUSH
45322: CALL_OW 3
45326: PPUSH
45327: CALL_OW 1
45331: ST_TO_ADDR
45332: GO 45581
// begin if not mc_deposits_finder [ i ] then
45334: LD_EXP 131
45338: PUSH
45339: LD_VAR 0 2
45343: ARRAY
45344: NOT
45345: IFFALSE 45397
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
45347: LD_ADDR_EXP 131
45351: PUSH
45352: LD_EXP 131
45356: PPUSH
45357: LD_VAR 0 2
45361: PPUSH
45362: LD_VAR 0 3
45366: PUSH
45367: LD_INT 1
45369: ARRAY
45370: PUSH
45371: EMPTY
45372: LIST
45373: PPUSH
45374: CALL_OW 1
45378: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
45379: LD_VAR 0 3
45383: PUSH
45384: LD_INT 1
45386: ARRAY
45387: PPUSH
45388: LD_INT 125
45390: PPUSH
45391: CALL_OW 109
// end else
45395: GO 45581
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
45397: LD_EXP 131
45401: PUSH
45402: LD_VAR 0 2
45406: ARRAY
45407: PUSH
45408: LD_INT 1
45410: ARRAY
45411: PPUSH
45412: CALL_OW 310
45416: IFFALSE 45439
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
45418: LD_EXP 131
45422: PUSH
45423: LD_VAR 0 2
45427: ARRAY
45428: PUSH
45429: LD_INT 1
45431: ARRAY
45432: PPUSH
45433: CALL_OW 122
45437: GO 45581
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
45439: LD_EXP 131
45443: PUSH
45444: LD_VAR 0 2
45448: ARRAY
45449: PUSH
45450: LD_INT 1
45452: ARRAY
45453: PPUSH
45454: CALL_OW 314
45458: NOT
45459: PUSH
45460: LD_EXP 131
45464: PUSH
45465: LD_VAR 0 2
45469: ARRAY
45470: PUSH
45471: LD_INT 1
45473: ARRAY
45474: PPUSH
45475: LD_EXP 130
45479: PUSH
45480: LD_VAR 0 2
45484: ARRAY
45485: PUSH
45486: LD_INT 1
45488: ARRAY
45489: PUSH
45490: LD_INT 1
45492: ARRAY
45493: PPUSH
45494: LD_EXP 130
45498: PUSH
45499: LD_VAR 0 2
45503: ARRAY
45504: PUSH
45505: LD_INT 1
45507: ARRAY
45508: PUSH
45509: LD_INT 2
45511: ARRAY
45512: PPUSH
45513: CALL_OW 297
45517: PUSH
45518: LD_INT 6
45520: GREATER
45521: AND
45522: IFFALSE 45581
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
45524: LD_EXP 131
45528: PUSH
45529: LD_VAR 0 2
45533: ARRAY
45534: PUSH
45535: LD_INT 1
45537: ARRAY
45538: PPUSH
45539: LD_EXP 130
45543: PUSH
45544: LD_VAR 0 2
45548: ARRAY
45549: PUSH
45550: LD_INT 1
45552: ARRAY
45553: PUSH
45554: LD_INT 1
45556: ARRAY
45557: PPUSH
45558: LD_EXP 130
45562: PUSH
45563: LD_VAR 0 2
45567: ARRAY
45568: PUSH
45569: LD_INT 1
45571: ARRAY
45572: PUSH
45573: LD_INT 2
45575: ARRAY
45576: PPUSH
45577: CALL_OW 111
// end ; end ; end ;
45581: GO 44994
45583: POP
45584: POP
// end ;
45585: LD_VAR 0 1
45589: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
45590: LD_INT 0
45592: PPUSH
45593: PPUSH
45594: PPUSH
45595: PPUSH
45596: PPUSH
45597: PPUSH
45598: PPUSH
45599: PPUSH
45600: PPUSH
45601: PPUSH
45602: PPUSH
// if not mc_bases then
45603: LD_EXP 93
45607: NOT
45608: IFFALSE 45612
// exit ;
45610: GO 46336
// for i = 1 to mc_bases do
45612: LD_ADDR_VAR 0 2
45616: PUSH
45617: DOUBLE
45618: LD_INT 1
45620: DEC
45621: ST_TO_ADDR
45622: LD_EXP 93
45626: PUSH
45627: FOR_TO
45628: IFFALSE 46334
// begin if not mc_bases [ i ] then
45630: LD_EXP 93
45634: PUSH
45635: LD_VAR 0 2
45639: ARRAY
45640: NOT
45641: IFFALSE 45645
// continue ;
45643: GO 45627
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
45645: LD_ADDR_VAR 0 7
45649: PUSH
45650: LD_EXP 93
45654: PUSH
45655: LD_VAR 0 2
45659: ARRAY
45660: PUSH
45661: LD_INT 1
45663: ARRAY
45664: PPUSH
45665: CALL_OW 248
45669: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
45670: LD_VAR 0 7
45674: PUSH
45675: LD_INT 3
45677: EQUAL
45678: PUSH
45679: LD_EXP 112
45683: PUSH
45684: LD_VAR 0 2
45688: ARRAY
45689: PUSH
45690: LD_EXP 115
45694: PUSH
45695: LD_VAR 0 2
45699: ARRAY
45700: UNION
45701: PPUSH
45702: LD_INT 33
45704: PUSH
45705: LD_INT 2
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PPUSH
45712: CALL_OW 72
45716: NOT
45717: OR
45718: IFFALSE 45722
// continue ;
45720: GO 45627
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
45722: LD_ADDR_VAR 0 9
45726: PUSH
45727: LD_EXP 93
45731: PUSH
45732: LD_VAR 0 2
45736: ARRAY
45737: PPUSH
45738: LD_INT 30
45740: PUSH
45741: LD_INT 36
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PPUSH
45748: CALL_OW 72
45752: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
45753: LD_ADDR_VAR 0 10
45757: PUSH
45758: LD_EXP 112
45762: PUSH
45763: LD_VAR 0 2
45767: ARRAY
45768: PPUSH
45769: LD_INT 34
45771: PUSH
45772: LD_INT 31
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PPUSH
45779: CALL_OW 72
45783: ST_TO_ADDR
// if not cts and not mcts then
45784: LD_VAR 0 9
45788: NOT
45789: PUSH
45790: LD_VAR 0 10
45794: NOT
45795: AND
45796: IFFALSE 45800
// continue ;
45798: GO 45627
// x := cts ;
45800: LD_ADDR_VAR 0 11
45804: PUSH
45805: LD_VAR 0 9
45809: ST_TO_ADDR
// if not x then
45810: LD_VAR 0 11
45814: NOT
45815: IFFALSE 45827
// x := mcts ;
45817: LD_ADDR_VAR 0 11
45821: PUSH
45822: LD_VAR 0 10
45826: ST_TO_ADDR
// if mc_remote_driver [ i ] then
45827: LD_EXP 133
45831: PUSH
45832: LD_VAR 0 2
45836: ARRAY
45837: IFFALSE 46106
// for j in mc_remote_driver [ i ] do
45839: LD_ADDR_VAR 0 3
45843: PUSH
45844: LD_EXP 133
45848: PUSH
45849: LD_VAR 0 2
45853: ARRAY
45854: PUSH
45855: FOR_IN
45856: IFFALSE 46104
// begin if GetClass ( j ) <> 3 then
45858: LD_VAR 0 3
45862: PPUSH
45863: CALL_OW 257
45867: PUSH
45868: LD_INT 3
45870: NONEQUAL
45871: IFFALSE 45924
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
45873: LD_ADDR_EXP 133
45877: PUSH
45878: LD_EXP 133
45882: PPUSH
45883: LD_VAR 0 2
45887: PPUSH
45888: LD_EXP 133
45892: PUSH
45893: LD_VAR 0 2
45897: ARRAY
45898: PUSH
45899: LD_VAR 0 3
45903: DIFF
45904: PPUSH
45905: CALL_OW 1
45909: ST_TO_ADDR
// SetTag ( j , 0 ) ;
45910: LD_VAR 0 3
45914: PPUSH
45915: LD_INT 0
45917: PPUSH
45918: CALL_OW 109
// continue ;
45922: GO 45855
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
45924: LD_VAR 0 3
45928: PPUSH
45929: CALL_OW 310
45933: NOT
45934: PUSH
45935: LD_VAR 0 3
45939: PPUSH
45940: CALL_OW 310
45944: PPUSH
45945: CALL_OW 266
45949: PUSH
45950: LD_INT 36
45952: NONEQUAL
45953: PUSH
45954: LD_VAR 0 3
45958: PPUSH
45959: CALL 93883 0 1
45963: NOT
45964: AND
45965: OR
45966: IFFALSE 46102
// begin if IsInUnit ( j ) then
45968: LD_VAR 0 3
45972: PPUSH
45973: CALL_OW 310
45977: IFFALSE 45988
// ComExitBuilding ( j ) ;
45979: LD_VAR 0 3
45983: PPUSH
45984: CALL_OW 122
// ct := 0 ;
45988: LD_ADDR_VAR 0 8
45992: PUSH
45993: LD_INT 0
45995: ST_TO_ADDR
// for k in x do
45996: LD_ADDR_VAR 0 4
46000: PUSH
46001: LD_VAR 0 11
46005: PUSH
46006: FOR_IN
46007: IFFALSE 46080
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
46009: LD_VAR 0 4
46013: PPUSH
46014: CALL_OW 264
46018: PUSH
46019: LD_INT 31
46021: EQUAL
46022: PUSH
46023: LD_VAR 0 4
46027: PPUSH
46028: CALL_OW 311
46032: NOT
46033: AND
46034: PUSH
46035: LD_VAR 0 4
46039: PPUSH
46040: CALL_OW 266
46044: PUSH
46045: LD_INT 36
46047: EQUAL
46048: PUSH
46049: LD_VAR 0 4
46053: PPUSH
46054: CALL_OW 313
46058: PUSH
46059: LD_INT 3
46061: LESS
46062: AND
46063: OR
46064: IFFALSE 46078
// begin ct := k ;
46066: LD_ADDR_VAR 0 8
46070: PUSH
46071: LD_VAR 0 4
46075: ST_TO_ADDR
// break ;
46076: GO 46080
// end ;
46078: GO 46006
46080: POP
46081: POP
// if ct then
46082: LD_VAR 0 8
46086: IFFALSE 46102
// ComEnterUnit ( j , ct ) ;
46088: LD_VAR 0 3
46092: PPUSH
46093: LD_VAR 0 8
46097: PPUSH
46098: CALL_OW 120
// end ; end ;
46102: GO 45855
46104: POP
46105: POP
// places := 0 ;
46106: LD_ADDR_VAR 0 5
46110: PUSH
46111: LD_INT 0
46113: ST_TO_ADDR
// for j = 1 to x do
46114: LD_ADDR_VAR 0 3
46118: PUSH
46119: DOUBLE
46120: LD_INT 1
46122: DEC
46123: ST_TO_ADDR
46124: LD_VAR 0 11
46128: PUSH
46129: FOR_TO
46130: IFFALSE 46185
// if GetWeapon ( x [ j ] ) = ar_control_tower then
46132: LD_VAR 0 11
46136: PUSH
46137: LD_VAR 0 3
46141: ARRAY
46142: PPUSH
46143: CALL_OW 264
46147: PUSH
46148: LD_INT 31
46150: EQUAL
46151: IFFALSE 46169
// places := places + 1 else
46153: LD_ADDR_VAR 0 5
46157: PUSH
46158: LD_VAR 0 5
46162: PUSH
46163: LD_INT 1
46165: PLUS
46166: ST_TO_ADDR
46167: GO 46183
// places := places + 3 ;
46169: LD_ADDR_VAR 0 5
46173: PUSH
46174: LD_VAR 0 5
46178: PUSH
46179: LD_INT 3
46181: PLUS
46182: ST_TO_ADDR
46183: GO 46129
46185: POP
46186: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
46187: LD_ADDR_VAR 0 6
46191: PUSH
46192: LD_EXP 93
46196: PUSH
46197: LD_VAR 0 2
46201: ARRAY
46202: PPUSH
46203: LD_INT 25
46205: PUSH
46206: LD_INT 3
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PPUSH
46213: CALL_OW 72
46217: PUSH
46218: LD_EXP 133
46222: PUSH
46223: LD_VAR 0 2
46227: ARRAY
46228: DIFF
46229: PPUSH
46230: LD_INT 3
46232: PPUSH
46233: CALL 94783 0 2
46237: ST_TO_ADDR
// if not tmp then
46238: LD_VAR 0 6
46242: NOT
46243: IFFALSE 46247
// continue ;
46245: GO 45627
// places := places - mc_remote_driver [ i ] ;
46247: LD_ADDR_VAR 0 5
46251: PUSH
46252: LD_VAR 0 5
46256: PUSH
46257: LD_EXP 133
46261: PUSH
46262: LD_VAR 0 2
46266: ARRAY
46267: MINUS
46268: ST_TO_ADDR
// if places then
46269: LD_VAR 0 5
46273: IFFALSE 46332
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
46275: LD_ADDR_EXP 133
46279: PUSH
46280: LD_EXP 133
46284: PPUSH
46285: LD_VAR 0 2
46289: PPUSH
46290: LD_EXP 133
46294: PUSH
46295: LD_VAR 0 2
46299: ARRAY
46300: PUSH
46301: LD_VAR 0 6
46305: PUSH
46306: LD_INT 1
46308: ARRAY
46309: UNION
46310: PPUSH
46311: CALL_OW 1
46315: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
46316: LD_VAR 0 6
46320: PUSH
46321: LD_INT 1
46323: ARRAY
46324: PPUSH
46325: LD_INT 126
46327: PPUSH
46328: CALL_OW 109
// end ; end ;
46332: GO 45627
46334: POP
46335: POP
// end ;
46336: LD_VAR 0 1
46340: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
46341: LD_INT 0
46343: PPUSH
46344: PPUSH
46345: PPUSH
46346: PPUSH
46347: PPUSH
46348: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
46349: LD_VAR 0 1
46353: NOT
46354: PUSH
46355: LD_VAR 0 2
46359: NOT
46360: OR
46361: PUSH
46362: LD_VAR 0 3
46366: NOT
46367: OR
46368: PUSH
46369: LD_VAR 0 4
46373: PUSH
46374: LD_INT 1
46376: PUSH
46377: LD_INT 2
46379: PUSH
46380: LD_INT 3
46382: PUSH
46383: LD_INT 4
46385: PUSH
46386: LD_INT 5
46388: PUSH
46389: LD_INT 8
46391: PUSH
46392: LD_INT 9
46394: PUSH
46395: LD_INT 15
46397: PUSH
46398: LD_INT 16
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: IN
46412: NOT
46413: OR
46414: IFFALSE 46418
// exit ;
46416: GO 47318
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
46418: LD_ADDR_VAR 0 2
46422: PUSH
46423: LD_VAR 0 2
46427: PPUSH
46428: LD_INT 21
46430: PUSH
46431: LD_INT 3
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 24
46440: PUSH
46441: LD_INT 250
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PPUSH
46452: CALL_OW 72
46456: ST_TO_ADDR
// case class of 1 , 15 :
46457: LD_VAR 0 4
46461: PUSH
46462: LD_INT 1
46464: DOUBLE
46465: EQUAL
46466: IFTRUE 46476
46468: LD_INT 15
46470: DOUBLE
46471: EQUAL
46472: IFTRUE 46476
46474: GO 46561
46476: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
46477: LD_ADDR_VAR 0 8
46481: PUSH
46482: LD_VAR 0 2
46486: PPUSH
46487: LD_INT 2
46489: PUSH
46490: LD_INT 30
46492: PUSH
46493: LD_INT 32
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: PUSH
46500: LD_INT 30
46502: PUSH
46503: LD_INT 31
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: LIST
46514: PPUSH
46515: CALL_OW 72
46519: PUSH
46520: LD_VAR 0 2
46524: PPUSH
46525: LD_INT 2
46527: PUSH
46528: LD_INT 30
46530: PUSH
46531: LD_INT 4
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: LD_INT 30
46540: PUSH
46541: LD_INT 5
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: LIST
46552: PPUSH
46553: CALL_OW 72
46557: ADD
46558: ST_TO_ADDR
46559: GO 46807
46561: LD_INT 2
46563: DOUBLE
46564: EQUAL
46565: IFTRUE 46575
46567: LD_INT 16
46569: DOUBLE
46570: EQUAL
46571: IFTRUE 46575
46573: GO 46621
46575: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
46576: LD_ADDR_VAR 0 8
46580: PUSH
46581: LD_VAR 0 2
46585: PPUSH
46586: LD_INT 2
46588: PUSH
46589: LD_INT 30
46591: PUSH
46592: LD_INT 0
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 30
46601: PUSH
46602: LD_INT 1
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: LIST
46613: PPUSH
46614: CALL_OW 72
46618: ST_TO_ADDR
46619: GO 46807
46621: LD_INT 3
46623: DOUBLE
46624: EQUAL
46625: IFTRUE 46629
46627: GO 46675
46629: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
46630: LD_ADDR_VAR 0 8
46634: PUSH
46635: LD_VAR 0 2
46639: PPUSH
46640: LD_INT 2
46642: PUSH
46643: LD_INT 30
46645: PUSH
46646: LD_INT 2
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 30
46655: PUSH
46656: LD_INT 3
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: LIST
46667: PPUSH
46668: CALL_OW 72
46672: ST_TO_ADDR
46673: GO 46807
46675: LD_INT 4
46677: DOUBLE
46678: EQUAL
46679: IFTRUE 46683
46681: GO 46740
46683: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
46684: LD_ADDR_VAR 0 8
46688: PUSH
46689: LD_VAR 0 2
46693: PPUSH
46694: LD_INT 2
46696: PUSH
46697: LD_INT 30
46699: PUSH
46700: LD_INT 6
46702: PUSH
46703: EMPTY
46704: LIST
46705: LIST
46706: PUSH
46707: LD_INT 30
46709: PUSH
46710: LD_INT 7
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PUSH
46717: LD_INT 30
46719: PUSH
46720: LD_INT 8
46722: PUSH
46723: EMPTY
46724: LIST
46725: LIST
46726: PUSH
46727: EMPTY
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: PPUSH
46733: CALL_OW 72
46737: ST_TO_ADDR
46738: GO 46807
46740: LD_INT 5
46742: DOUBLE
46743: EQUAL
46744: IFTRUE 46760
46746: LD_INT 8
46748: DOUBLE
46749: EQUAL
46750: IFTRUE 46760
46752: LD_INT 9
46754: DOUBLE
46755: EQUAL
46756: IFTRUE 46760
46758: GO 46806
46760: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
46761: LD_ADDR_VAR 0 8
46765: PUSH
46766: LD_VAR 0 2
46770: PPUSH
46771: LD_INT 2
46773: PUSH
46774: LD_INT 30
46776: PUSH
46777: LD_INT 4
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PUSH
46784: LD_INT 30
46786: PUSH
46787: LD_INT 5
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: PUSH
46794: EMPTY
46795: LIST
46796: LIST
46797: LIST
46798: PPUSH
46799: CALL_OW 72
46803: ST_TO_ADDR
46804: GO 46807
46806: POP
// if not tmp then
46807: LD_VAR 0 8
46811: NOT
46812: IFFALSE 46816
// exit ;
46814: GO 47318
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
46816: LD_VAR 0 4
46820: PUSH
46821: LD_INT 1
46823: PUSH
46824: LD_INT 15
46826: PUSH
46827: EMPTY
46828: LIST
46829: LIST
46830: IN
46831: PUSH
46832: LD_EXP 102
46836: PUSH
46837: LD_VAR 0 1
46841: ARRAY
46842: AND
46843: IFFALSE 46999
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
46845: LD_ADDR_VAR 0 9
46849: PUSH
46850: LD_EXP 102
46854: PUSH
46855: LD_VAR 0 1
46859: ARRAY
46860: PUSH
46861: LD_INT 1
46863: ARRAY
46864: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
46865: LD_VAR 0 9
46869: PUSH
46870: LD_EXP 103
46874: PUSH
46875: LD_VAR 0 1
46879: ARRAY
46880: IN
46881: NOT
46882: IFFALSE 46997
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46884: LD_ADDR_EXP 103
46888: PUSH
46889: LD_EXP 103
46893: PPUSH
46894: LD_VAR 0 1
46898: PUSH
46899: LD_EXP 103
46903: PUSH
46904: LD_VAR 0 1
46908: ARRAY
46909: PUSH
46910: LD_INT 1
46912: PLUS
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PPUSH
46918: LD_VAR 0 9
46922: PPUSH
46923: CALL 60598 0 3
46927: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46928: LD_ADDR_EXP 102
46932: PUSH
46933: LD_EXP 102
46937: PPUSH
46938: LD_VAR 0 1
46942: PPUSH
46943: LD_EXP 102
46947: PUSH
46948: LD_VAR 0 1
46952: ARRAY
46953: PUSH
46954: LD_VAR 0 9
46958: DIFF
46959: PPUSH
46960: CALL_OW 1
46964: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46965: LD_VAR 0 3
46969: PPUSH
46970: LD_EXP 103
46974: PUSH
46975: LD_VAR 0 1
46979: ARRAY
46980: PUSH
46981: LD_EXP 103
46985: PUSH
46986: LD_VAR 0 1
46990: ARRAY
46991: ARRAY
46992: PPUSH
46993: CALL_OW 120
// end ; exit ;
46997: GO 47318
// end ; if tmp > 1 then
46999: LD_VAR 0 8
47003: PUSH
47004: LD_INT 1
47006: GREATER
47007: IFFALSE 47111
// for i = 2 to tmp do
47009: LD_ADDR_VAR 0 6
47013: PUSH
47014: DOUBLE
47015: LD_INT 2
47017: DEC
47018: ST_TO_ADDR
47019: LD_VAR 0 8
47023: PUSH
47024: FOR_TO
47025: IFFALSE 47109
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
47027: LD_VAR 0 8
47031: PUSH
47032: LD_VAR 0 6
47036: ARRAY
47037: PPUSH
47038: CALL_OW 461
47042: PUSH
47043: LD_INT 6
47045: EQUAL
47046: IFFALSE 47107
// begin x := tmp [ i ] ;
47048: LD_ADDR_VAR 0 9
47052: PUSH
47053: LD_VAR 0 8
47057: PUSH
47058: LD_VAR 0 6
47062: ARRAY
47063: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
47064: LD_ADDR_VAR 0 8
47068: PUSH
47069: LD_VAR 0 8
47073: PPUSH
47074: LD_VAR 0 6
47078: PPUSH
47079: CALL_OW 3
47083: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
47084: LD_ADDR_VAR 0 8
47088: PUSH
47089: LD_VAR 0 8
47093: PPUSH
47094: LD_INT 1
47096: PPUSH
47097: LD_VAR 0 9
47101: PPUSH
47102: CALL_OW 2
47106: ST_TO_ADDR
// end ;
47107: GO 47024
47109: POP
47110: POP
// for i in tmp do
47111: LD_ADDR_VAR 0 6
47115: PUSH
47116: LD_VAR 0 8
47120: PUSH
47121: FOR_IN
47122: IFFALSE 47191
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
47124: LD_VAR 0 6
47128: PPUSH
47129: CALL_OW 313
47133: PUSH
47134: LD_INT 6
47136: LESS
47137: PUSH
47138: LD_VAR 0 6
47142: PPUSH
47143: CALL_OW 266
47147: PUSH
47148: LD_INT 31
47150: PUSH
47151: LD_INT 32
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: IN
47158: NOT
47159: AND
47160: PUSH
47161: LD_VAR 0 6
47165: PPUSH
47166: CALL_OW 313
47170: PUSH
47171: LD_INT 0
47173: EQUAL
47174: OR
47175: IFFALSE 47189
// begin j := i ;
47177: LD_ADDR_VAR 0 7
47181: PUSH
47182: LD_VAR 0 6
47186: ST_TO_ADDR
// break ;
47187: GO 47191
// end ; end ;
47189: GO 47121
47191: POP
47192: POP
// if j then
47193: LD_VAR 0 7
47197: IFFALSE 47215
// ComEnterUnit ( unit , j ) else
47199: LD_VAR 0 3
47203: PPUSH
47204: LD_VAR 0 7
47208: PPUSH
47209: CALL_OW 120
47213: GO 47318
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47215: LD_ADDR_VAR 0 10
47219: PUSH
47220: LD_VAR 0 2
47224: PPUSH
47225: LD_INT 2
47227: PUSH
47228: LD_INT 30
47230: PUSH
47231: LD_INT 0
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 30
47240: PUSH
47241: LD_INT 1
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: LIST
47252: PPUSH
47253: CALL_OW 72
47257: ST_TO_ADDR
// if depot then
47258: LD_VAR 0 10
47262: IFFALSE 47318
// begin depot := NearestUnitToUnit ( depot , unit ) ;
47264: LD_ADDR_VAR 0 10
47268: PUSH
47269: LD_VAR 0 10
47273: PPUSH
47274: LD_VAR 0 3
47278: PPUSH
47279: CALL_OW 74
47283: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
47284: LD_VAR 0 3
47288: PPUSH
47289: LD_VAR 0 10
47293: PPUSH
47294: CALL_OW 296
47298: PUSH
47299: LD_INT 10
47301: GREATER
47302: IFFALSE 47318
// ComStandNearbyBuilding ( unit , depot ) ;
47304: LD_VAR 0 3
47308: PPUSH
47309: LD_VAR 0 10
47313: PPUSH
47314: CALL 55275 0 2
// end ; end ; end ;
47318: LD_VAR 0 5
47322: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
47323: LD_INT 0
47325: PPUSH
47326: PPUSH
47327: PPUSH
47328: PPUSH
// if not mc_bases then
47329: LD_EXP 93
47333: NOT
47334: IFFALSE 47338
// exit ;
47336: GO 47577
// for i = 1 to mc_bases do
47338: LD_ADDR_VAR 0 2
47342: PUSH
47343: DOUBLE
47344: LD_INT 1
47346: DEC
47347: ST_TO_ADDR
47348: LD_EXP 93
47352: PUSH
47353: FOR_TO
47354: IFFALSE 47575
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
47356: LD_ADDR_VAR 0 4
47360: PUSH
47361: LD_EXP 93
47365: PUSH
47366: LD_VAR 0 2
47370: ARRAY
47371: PPUSH
47372: LD_INT 21
47374: PUSH
47375: LD_INT 1
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: PPUSH
47382: CALL_OW 72
47386: PUSH
47387: LD_EXP 122
47391: PUSH
47392: LD_VAR 0 2
47396: ARRAY
47397: UNION
47398: ST_TO_ADDR
// if not tmp then
47399: LD_VAR 0 4
47403: NOT
47404: IFFALSE 47408
// continue ;
47406: GO 47353
// for j in tmp do
47408: LD_ADDR_VAR 0 3
47412: PUSH
47413: LD_VAR 0 4
47417: PUSH
47418: FOR_IN
47419: IFFALSE 47571
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
47421: LD_VAR 0 3
47425: PPUSH
47426: CALL_OW 110
47430: NOT
47431: PUSH
47432: LD_VAR 0 3
47436: PPUSH
47437: CALL_OW 314
47441: NOT
47442: AND
47443: PUSH
47444: LD_VAR 0 3
47448: PPUSH
47449: CALL_OW 311
47453: NOT
47454: AND
47455: PUSH
47456: LD_VAR 0 3
47460: PPUSH
47461: CALL_OW 310
47465: NOT
47466: AND
47467: PUSH
47468: LD_VAR 0 3
47472: PUSH
47473: LD_EXP 96
47477: PUSH
47478: LD_VAR 0 2
47482: ARRAY
47483: PUSH
47484: LD_INT 1
47486: ARRAY
47487: IN
47488: NOT
47489: AND
47490: PUSH
47491: LD_VAR 0 3
47495: PUSH
47496: LD_EXP 96
47500: PUSH
47501: LD_VAR 0 2
47505: ARRAY
47506: PUSH
47507: LD_INT 2
47509: ARRAY
47510: IN
47511: NOT
47512: AND
47513: PUSH
47514: LD_VAR 0 3
47518: PUSH
47519: LD_EXP 105
47523: PUSH
47524: LD_VAR 0 2
47528: ARRAY
47529: IN
47530: NOT
47531: AND
47532: IFFALSE 47569
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
47534: LD_VAR 0 2
47538: PPUSH
47539: LD_EXP 93
47543: PUSH
47544: LD_VAR 0 2
47548: ARRAY
47549: PPUSH
47550: LD_VAR 0 3
47554: PPUSH
47555: LD_VAR 0 3
47559: PPUSH
47560: CALL_OW 257
47564: PPUSH
47565: CALL 46341 0 4
// end ;
47569: GO 47418
47571: POP
47572: POP
// end ;
47573: GO 47353
47575: POP
47576: POP
// end ;
47577: LD_VAR 0 1
47581: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
47582: LD_INT 0
47584: PPUSH
47585: PPUSH
47586: PPUSH
47587: PPUSH
47588: PPUSH
47589: PPUSH
// if not mc_bases [ base ] then
47590: LD_EXP 93
47594: PUSH
47595: LD_VAR 0 1
47599: ARRAY
47600: NOT
47601: IFFALSE 47605
// exit ;
47603: GO 47787
// tmp := [ ] ;
47605: LD_ADDR_VAR 0 6
47609: PUSH
47610: EMPTY
47611: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
47612: LD_ADDR_VAR 0 7
47616: PUSH
47617: LD_VAR 0 3
47621: PPUSH
47622: LD_INT 0
47624: PPUSH
47625: CALL_OW 517
47629: ST_TO_ADDR
// if not list then
47630: LD_VAR 0 7
47634: NOT
47635: IFFALSE 47639
// exit ;
47637: GO 47787
// for i = 1 to amount do
47639: LD_ADDR_VAR 0 5
47643: PUSH
47644: DOUBLE
47645: LD_INT 1
47647: DEC
47648: ST_TO_ADDR
47649: LD_VAR 0 2
47653: PUSH
47654: FOR_TO
47655: IFFALSE 47735
// begin x := rand ( 1 , list [ 1 ] ) ;
47657: LD_ADDR_VAR 0 8
47661: PUSH
47662: LD_INT 1
47664: PPUSH
47665: LD_VAR 0 7
47669: PUSH
47670: LD_INT 1
47672: ARRAY
47673: PPUSH
47674: CALL_OW 12
47678: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
47679: LD_ADDR_VAR 0 6
47683: PUSH
47684: LD_VAR 0 6
47688: PPUSH
47689: LD_VAR 0 5
47693: PPUSH
47694: LD_VAR 0 7
47698: PUSH
47699: LD_INT 1
47701: ARRAY
47702: PUSH
47703: LD_VAR 0 8
47707: ARRAY
47708: PUSH
47709: LD_VAR 0 7
47713: PUSH
47714: LD_INT 2
47716: ARRAY
47717: PUSH
47718: LD_VAR 0 8
47722: ARRAY
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PPUSH
47728: CALL_OW 1
47732: ST_TO_ADDR
// end ;
47733: GO 47654
47735: POP
47736: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
47737: LD_ADDR_EXP 106
47741: PUSH
47742: LD_EXP 106
47746: PPUSH
47747: LD_VAR 0 1
47751: PPUSH
47752: LD_VAR 0 6
47756: PPUSH
47757: CALL_OW 1
47761: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
47762: LD_ADDR_EXP 108
47766: PUSH
47767: LD_EXP 108
47771: PPUSH
47772: LD_VAR 0 1
47776: PPUSH
47777: LD_VAR 0 3
47781: PPUSH
47782: CALL_OW 1
47786: ST_TO_ADDR
// end ;
47787: LD_VAR 0 4
47791: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
47792: LD_INT 0
47794: PPUSH
// if not mc_bases [ base ] then
47795: LD_EXP 93
47799: PUSH
47800: LD_VAR 0 1
47804: ARRAY
47805: NOT
47806: IFFALSE 47810
// exit ;
47808: GO 47835
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
47810: LD_ADDR_EXP 98
47814: PUSH
47815: LD_EXP 98
47819: PPUSH
47820: LD_VAR 0 1
47824: PPUSH
47825: LD_VAR 0 2
47829: PPUSH
47830: CALL_OW 1
47834: ST_TO_ADDR
// end ;
47835: LD_VAR 0 3
47839: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
47840: LD_INT 0
47842: PPUSH
// if not mc_bases [ base ] then
47843: LD_EXP 93
47847: PUSH
47848: LD_VAR 0 1
47852: ARRAY
47853: NOT
47854: IFFALSE 47858
// exit ;
47856: GO 47895
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
47858: LD_ADDR_EXP 98
47862: PUSH
47863: LD_EXP 98
47867: PPUSH
47868: LD_VAR 0 1
47872: PPUSH
47873: LD_EXP 98
47877: PUSH
47878: LD_VAR 0 1
47882: ARRAY
47883: PUSH
47884: LD_VAR 0 2
47888: UNION
47889: PPUSH
47890: CALL_OW 1
47894: ST_TO_ADDR
// end ;
47895: LD_VAR 0 3
47899: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47900: LD_INT 0
47902: PPUSH
// if not mc_bases [ base ] then
47903: LD_EXP 93
47907: PUSH
47908: LD_VAR 0 1
47912: ARRAY
47913: NOT
47914: IFFALSE 47918
// exit ;
47916: GO 47943
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47918: LD_ADDR_EXP 114
47922: PUSH
47923: LD_EXP 114
47927: PPUSH
47928: LD_VAR 0 1
47932: PPUSH
47933: LD_VAR 0 2
47937: PPUSH
47938: CALL_OW 1
47942: ST_TO_ADDR
// end ;
47943: LD_VAR 0 3
47947: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
47948: LD_INT 0
47950: PPUSH
// if not mc_bases [ base ] then
47951: LD_EXP 93
47955: PUSH
47956: LD_VAR 0 1
47960: ARRAY
47961: NOT
47962: IFFALSE 47966
// exit ;
47964: GO 48003
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
47966: LD_ADDR_EXP 114
47970: PUSH
47971: LD_EXP 114
47975: PPUSH
47976: LD_VAR 0 1
47980: PPUSH
47981: LD_EXP 114
47985: PUSH
47986: LD_VAR 0 1
47990: ARRAY
47991: PUSH
47992: LD_VAR 0 2
47996: UNION
47997: PPUSH
47998: CALL_OW 1
48002: ST_TO_ADDR
// end ;
48003: LD_VAR 0 3
48007: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
48008: LD_INT 0
48010: PPUSH
// if not mc_bases [ base ] then
48011: LD_EXP 93
48015: PUSH
48016: LD_VAR 0 1
48020: ARRAY
48021: NOT
48022: IFFALSE 48026
// exit ;
48024: GO 48138
// mc_defender := Replace ( mc_defender , base , deflist ) ;
48026: LD_ADDR_EXP 115
48030: PUSH
48031: LD_EXP 115
48035: PPUSH
48036: LD_VAR 0 1
48040: PPUSH
48041: LD_VAR 0 2
48045: PPUSH
48046: CALL_OW 1
48050: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
48051: LD_ADDR_EXP 104
48055: PUSH
48056: LD_EXP 104
48060: PPUSH
48061: LD_VAR 0 1
48065: PPUSH
48066: LD_VAR 0 2
48070: PUSH
48071: LD_INT 0
48073: PLUS
48074: PPUSH
48075: CALL_OW 1
48079: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
48080: LD_ADDR_EXP 112
48084: PUSH
48085: LD_EXP 112
48089: PPUSH
48090: LD_VAR 0 1
48094: PPUSH
48095: LD_EXP 112
48099: PUSH
48100: LD_VAR 0 1
48104: ARRAY
48105: PUSH
48106: LD_EXP 115
48110: PUSH
48111: LD_VAR 0 1
48115: ARRAY
48116: PPUSH
48117: LD_INT 21
48119: PUSH
48120: LD_INT 2
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: PPUSH
48127: CALL_OW 72
48131: UNION
48132: PPUSH
48133: CALL_OW 1
48137: ST_TO_ADDR
// end ;
48138: LD_VAR 0 3
48142: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
48143: LD_INT 0
48145: PPUSH
// if not mc_bases [ base ] then
48146: LD_EXP 93
48150: PUSH
48151: LD_VAR 0 1
48155: ARRAY
48156: NOT
48157: IFFALSE 48161
// exit ;
48159: GO 48186
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
48161: LD_ADDR_EXP 104
48165: PUSH
48166: LD_EXP 104
48170: PPUSH
48171: LD_VAR 0 1
48175: PPUSH
48176: LD_VAR 0 2
48180: PPUSH
48181: CALL_OW 1
48185: ST_TO_ADDR
// end ;
48186: LD_VAR 0 3
48190: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
48191: LD_INT 0
48193: PPUSH
48194: PPUSH
48195: PPUSH
48196: PPUSH
// if not mc_bases [ base ] then
48197: LD_EXP 93
48201: PUSH
48202: LD_VAR 0 1
48206: ARRAY
48207: NOT
48208: IFFALSE 48212
// exit ;
48210: GO 48277
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
48212: LD_ADDR_EXP 113
48216: PUSH
48217: LD_EXP 113
48221: PPUSH
48222: LD_VAR 0 1
48226: PUSH
48227: LD_EXP 113
48231: PUSH
48232: LD_VAR 0 1
48236: ARRAY
48237: PUSH
48238: LD_INT 1
48240: PLUS
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PPUSH
48246: LD_VAR 0 1
48250: PUSH
48251: LD_VAR 0 2
48255: PUSH
48256: LD_VAR 0 3
48260: PUSH
48261: LD_VAR 0 4
48265: PUSH
48266: EMPTY
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: PPUSH
48272: CALL 60598 0 3
48276: ST_TO_ADDR
// end ;
48277: LD_VAR 0 5
48281: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
48282: LD_INT 0
48284: PPUSH
// if not mc_bases [ base ] then
48285: LD_EXP 93
48289: PUSH
48290: LD_VAR 0 1
48294: ARRAY
48295: NOT
48296: IFFALSE 48300
// exit ;
48298: GO 48325
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
48300: LD_ADDR_EXP 130
48304: PUSH
48305: LD_EXP 130
48309: PPUSH
48310: LD_VAR 0 1
48314: PPUSH
48315: LD_VAR 0 2
48319: PPUSH
48320: CALL_OW 1
48324: ST_TO_ADDR
// end ;
48325: LD_VAR 0 3
48329: RET
// export function MC_GetMinesField ( base ) ; begin
48330: LD_INT 0
48332: PPUSH
// result := mc_mines [ base ] ;
48333: LD_ADDR_VAR 0 2
48337: PUSH
48338: LD_EXP 106
48342: PUSH
48343: LD_VAR 0 1
48347: ARRAY
48348: ST_TO_ADDR
// end ;
48349: LD_VAR 0 2
48353: RET
// export function MC_GetProduceList ( base ) ; begin
48354: LD_INT 0
48356: PPUSH
// result := mc_produce [ base ] ;
48357: LD_ADDR_VAR 0 2
48361: PUSH
48362: LD_EXP 114
48366: PUSH
48367: LD_VAR 0 1
48371: ARRAY
48372: ST_TO_ADDR
// end ;
48373: LD_VAR 0 2
48377: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
48378: LD_INT 0
48380: PPUSH
48381: PPUSH
// if not mc_bases then
48382: LD_EXP 93
48386: NOT
48387: IFFALSE 48391
// exit ;
48389: GO 48456
// if mc_bases [ base ] then
48391: LD_EXP 93
48395: PUSH
48396: LD_VAR 0 1
48400: ARRAY
48401: IFFALSE 48456
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48403: LD_ADDR_VAR 0 3
48407: PUSH
48408: LD_EXP 93
48412: PUSH
48413: LD_VAR 0 1
48417: ARRAY
48418: PPUSH
48419: LD_INT 30
48421: PUSH
48422: LD_VAR 0 2
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: PPUSH
48431: CALL_OW 72
48435: ST_TO_ADDR
// if result then
48436: LD_VAR 0 3
48440: IFFALSE 48456
// result := result [ 1 ] ;
48442: LD_ADDR_VAR 0 3
48446: PUSH
48447: LD_VAR 0 3
48451: PUSH
48452: LD_INT 1
48454: ARRAY
48455: ST_TO_ADDR
// end ; end ;
48456: LD_VAR 0 3
48460: RET
// export function MC_SetTame ( base , area ) ; begin
48461: LD_INT 0
48463: PPUSH
// if not mc_bases or not base then
48464: LD_EXP 93
48468: NOT
48469: PUSH
48470: LD_VAR 0 1
48474: NOT
48475: OR
48476: IFFALSE 48480
// exit ;
48478: GO 48505
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
48480: LD_ADDR_EXP 121
48484: PUSH
48485: LD_EXP 121
48489: PPUSH
48490: LD_VAR 0 1
48494: PPUSH
48495: LD_VAR 0 2
48499: PPUSH
48500: CALL_OW 1
48504: ST_TO_ADDR
// end ;
48505: LD_VAR 0 3
48509: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
48510: LD_INT 0
48512: PPUSH
48513: PPUSH
// if not mc_bases or not base then
48514: LD_EXP 93
48518: NOT
48519: PUSH
48520: LD_VAR 0 1
48524: NOT
48525: OR
48526: IFFALSE 48530
// exit ;
48528: GO 48632
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48530: LD_ADDR_VAR 0 4
48534: PUSH
48535: LD_EXP 93
48539: PUSH
48540: LD_VAR 0 1
48544: ARRAY
48545: PPUSH
48546: LD_INT 30
48548: PUSH
48549: LD_VAR 0 2
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PPUSH
48558: CALL_OW 72
48562: ST_TO_ADDR
// if not tmp then
48563: LD_VAR 0 4
48567: NOT
48568: IFFALSE 48572
// exit ;
48570: GO 48632
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
48572: LD_ADDR_EXP 125
48576: PUSH
48577: LD_EXP 125
48581: PPUSH
48582: LD_VAR 0 1
48586: PPUSH
48587: LD_EXP 125
48591: PUSH
48592: LD_VAR 0 1
48596: ARRAY
48597: PPUSH
48598: LD_EXP 125
48602: PUSH
48603: LD_VAR 0 1
48607: ARRAY
48608: PUSH
48609: LD_INT 1
48611: PLUS
48612: PPUSH
48613: LD_VAR 0 4
48617: PUSH
48618: LD_INT 1
48620: ARRAY
48621: PPUSH
48622: CALL_OW 2
48626: PPUSH
48627: CALL_OW 1
48631: ST_TO_ADDR
// end ;
48632: LD_VAR 0 3
48636: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
48637: LD_INT 0
48639: PPUSH
48640: PPUSH
// if not mc_bases or not base or not kinds then
48641: LD_EXP 93
48645: NOT
48646: PUSH
48647: LD_VAR 0 1
48651: NOT
48652: OR
48653: PUSH
48654: LD_VAR 0 2
48658: NOT
48659: OR
48660: IFFALSE 48664
// exit ;
48662: GO 48725
// for i in kinds do
48664: LD_ADDR_VAR 0 4
48668: PUSH
48669: LD_VAR 0 2
48673: PUSH
48674: FOR_IN
48675: IFFALSE 48723
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
48677: LD_ADDR_EXP 127
48681: PUSH
48682: LD_EXP 127
48686: PPUSH
48687: LD_VAR 0 1
48691: PUSH
48692: LD_EXP 127
48696: PUSH
48697: LD_VAR 0 1
48701: ARRAY
48702: PUSH
48703: LD_INT 1
48705: PLUS
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PPUSH
48711: LD_VAR 0 4
48715: PPUSH
48716: CALL 60598 0 3
48720: ST_TO_ADDR
48721: GO 48674
48723: POP
48724: POP
// end ;
48725: LD_VAR 0 3
48729: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
48730: LD_INT 0
48732: PPUSH
// if not mc_bases or not base or not areas then
48733: LD_EXP 93
48737: NOT
48738: PUSH
48739: LD_VAR 0 1
48743: NOT
48744: OR
48745: PUSH
48746: LD_VAR 0 2
48750: NOT
48751: OR
48752: IFFALSE 48756
// exit ;
48754: GO 48781
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
48756: LD_ADDR_EXP 111
48760: PUSH
48761: LD_EXP 111
48765: PPUSH
48766: LD_VAR 0 1
48770: PPUSH
48771: LD_VAR 0 2
48775: PPUSH
48776: CALL_OW 1
48780: ST_TO_ADDR
// end ;
48781: LD_VAR 0 3
48785: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
48786: LD_INT 0
48788: PPUSH
// if not mc_bases or not base or not teleports_exit then
48789: LD_EXP 93
48793: NOT
48794: PUSH
48795: LD_VAR 0 1
48799: NOT
48800: OR
48801: PUSH
48802: LD_VAR 0 2
48806: NOT
48807: OR
48808: IFFALSE 48812
// exit ;
48810: GO 48837
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
48812: LD_ADDR_EXP 128
48816: PUSH
48817: LD_EXP 128
48821: PPUSH
48822: LD_VAR 0 1
48826: PPUSH
48827: LD_VAR 0 2
48831: PPUSH
48832: CALL_OW 1
48836: ST_TO_ADDR
// end ;
48837: LD_VAR 0 3
48841: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
48842: LD_INT 0
48844: PPUSH
48845: PPUSH
48846: PPUSH
// if not mc_bases or not base or not ext_list then
48847: LD_EXP 93
48851: NOT
48852: PUSH
48853: LD_VAR 0 1
48857: NOT
48858: OR
48859: PUSH
48860: LD_VAR 0 5
48864: NOT
48865: OR
48866: IFFALSE 48870
// exit ;
48868: GO 49043
// tmp := GetFacExtXYD ( x , y , d ) ;
48870: LD_ADDR_VAR 0 8
48874: PUSH
48875: LD_VAR 0 2
48879: PPUSH
48880: LD_VAR 0 3
48884: PPUSH
48885: LD_VAR 0 4
48889: PPUSH
48890: CALL 93913 0 3
48894: ST_TO_ADDR
// if not tmp then
48895: LD_VAR 0 8
48899: NOT
48900: IFFALSE 48904
// exit ;
48902: GO 49043
// for i in tmp do
48904: LD_ADDR_VAR 0 7
48908: PUSH
48909: LD_VAR 0 8
48913: PUSH
48914: FOR_IN
48915: IFFALSE 49041
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48917: LD_ADDR_EXP 98
48921: PUSH
48922: LD_EXP 98
48926: PPUSH
48927: LD_VAR 0 1
48931: PPUSH
48932: LD_EXP 98
48936: PUSH
48937: LD_VAR 0 1
48941: ARRAY
48942: PPUSH
48943: LD_EXP 98
48947: PUSH
48948: LD_VAR 0 1
48952: ARRAY
48953: PUSH
48954: LD_INT 1
48956: PLUS
48957: PPUSH
48958: LD_VAR 0 5
48962: PUSH
48963: LD_INT 1
48965: ARRAY
48966: PUSH
48967: LD_VAR 0 7
48971: PUSH
48972: LD_INT 1
48974: ARRAY
48975: PUSH
48976: LD_VAR 0 7
48980: PUSH
48981: LD_INT 2
48983: ARRAY
48984: PUSH
48985: LD_VAR 0 7
48989: PUSH
48990: LD_INT 3
48992: ARRAY
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: PPUSH
49000: CALL_OW 2
49004: PPUSH
49005: CALL_OW 1
49009: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
49010: LD_ADDR_VAR 0 5
49014: PUSH
49015: LD_VAR 0 5
49019: PPUSH
49020: LD_INT 1
49022: PPUSH
49023: CALL_OW 3
49027: ST_TO_ADDR
// if not ext_list then
49028: LD_VAR 0 5
49032: NOT
49033: IFFALSE 49039
// exit ;
49035: POP
49036: POP
49037: GO 49043
// end ;
49039: GO 48914
49041: POP
49042: POP
// end ;
49043: LD_VAR 0 6
49047: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
49048: LD_INT 0
49050: PPUSH
// if not mc_bases or not base or not weapon_list then
49051: LD_EXP 93
49055: NOT
49056: PUSH
49057: LD_VAR 0 1
49061: NOT
49062: OR
49063: PUSH
49064: LD_VAR 0 2
49068: NOT
49069: OR
49070: IFFALSE 49074
// exit ;
49072: GO 49099
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
49074: LD_ADDR_EXP 132
49078: PUSH
49079: LD_EXP 132
49083: PPUSH
49084: LD_VAR 0 1
49088: PPUSH
49089: LD_VAR 0 2
49093: PPUSH
49094: CALL_OW 1
49098: ST_TO_ADDR
// end ;
49099: LD_VAR 0 3
49103: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
49104: LD_INT 0
49106: PPUSH
// if not mc_bases or not base or not tech_list then
49107: LD_EXP 93
49111: NOT
49112: PUSH
49113: LD_VAR 0 1
49117: NOT
49118: OR
49119: PUSH
49120: LD_VAR 0 2
49124: NOT
49125: OR
49126: IFFALSE 49130
// exit ;
49128: GO 49155
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
49130: LD_ADDR_EXP 120
49134: PUSH
49135: LD_EXP 120
49139: PPUSH
49140: LD_VAR 0 1
49144: PPUSH
49145: LD_VAR 0 2
49149: PPUSH
49150: CALL_OW 1
49154: ST_TO_ADDR
// end ;
49155: LD_VAR 0 3
49159: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
49160: LD_INT 0
49162: PPUSH
// if not mc_bases or not parking_area or not base then
49163: LD_EXP 93
49167: NOT
49168: PUSH
49169: LD_VAR 0 2
49173: NOT
49174: OR
49175: PUSH
49176: LD_VAR 0 1
49180: NOT
49181: OR
49182: IFFALSE 49186
// exit ;
49184: GO 49211
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
49186: LD_ADDR_EXP 117
49190: PUSH
49191: LD_EXP 117
49195: PPUSH
49196: LD_VAR 0 1
49200: PPUSH
49201: LD_VAR 0 2
49205: PPUSH
49206: CALL_OW 1
49210: ST_TO_ADDR
// end ;
49211: LD_VAR 0 3
49215: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
49216: LD_INT 0
49218: PPUSH
// if not mc_bases or not base or not scan_area then
49219: LD_EXP 93
49223: NOT
49224: PUSH
49225: LD_VAR 0 1
49229: NOT
49230: OR
49231: PUSH
49232: LD_VAR 0 2
49236: NOT
49237: OR
49238: IFFALSE 49242
// exit ;
49240: GO 49267
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
49242: LD_ADDR_EXP 118
49246: PUSH
49247: LD_EXP 118
49251: PPUSH
49252: LD_VAR 0 1
49256: PPUSH
49257: LD_VAR 0 2
49261: PPUSH
49262: CALL_OW 1
49266: ST_TO_ADDR
// end ;
49267: LD_VAR 0 3
49271: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
49272: LD_INT 0
49274: PPUSH
49275: PPUSH
// if not mc_bases or not base then
49276: LD_EXP 93
49280: NOT
49281: PUSH
49282: LD_VAR 0 1
49286: NOT
49287: OR
49288: IFFALSE 49292
// exit ;
49290: GO 49356
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
49292: LD_ADDR_VAR 0 3
49296: PUSH
49297: LD_INT 1
49299: PUSH
49300: LD_INT 2
49302: PUSH
49303: LD_INT 3
49305: PUSH
49306: LD_INT 4
49308: PUSH
49309: LD_INT 11
49311: PUSH
49312: EMPTY
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
49319: LD_ADDR_EXP 120
49323: PUSH
49324: LD_EXP 120
49328: PPUSH
49329: LD_VAR 0 1
49333: PPUSH
49334: LD_EXP 120
49338: PUSH
49339: LD_VAR 0 1
49343: ARRAY
49344: PUSH
49345: LD_VAR 0 3
49349: DIFF
49350: PPUSH
49351: CALL_OW 1
49355: ST_TO_ADDR
// end ;
49356: LD_VAR 0 2
49360: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
49361: LD_INT 0
49363: PPUSH
// result := mc_vehicles [ base ] ;
49364: LD_ADDR_VAR 0 3
49368: PUSH
49369: LD_EXP 112
49373: PUSH
49374: LD_VAR 0 1
49378: ARRAY
49379: ST_TO_ADDR
// if onlyCombat then
49380: LD_VAR 0 2
49384: IFFALSE 49527
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] ] ) ;
49386: LD_ADDR_VAR 0 3
49390: PUSH
49391: LD_VAR 0 3
49395: PUSH
49396: LD_VAR 0 3
49400: PPUSH
49401: LD_INT 2
49403: PUSH
49404: LD_INT 34
49406: PUSH
49407: LD_INT 12
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: PUSH
49414: LD_INT 34
49416: PUSH
49417: LD_INT 51
49419: PUSH
49420: EMPTY
49421: LIST
49422: LIST
49423: PUSH
49424: LD_INT 34
49426: PUSH
49427: LD_EXP 87
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PUSH
49436: LD_INT 34
49438: PUSH
49439: LD_INT 32
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: PUSH
49446: LD_INT 34
49448: PUSH
49449: LD_INT 13
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 34
49458: PUSH
49459: LD_INT 52
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: PUSH
49466: LD_INT 34
49468: PUSH
49469: LD_INT 14
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: PUSH
49476: LD_INT 34
49478: PUSH
49479: LD_INT 53
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 34
49488: PUSH
49489: LD_EXP 86
49493: PUSH
49494: EMPTY
49495: LIST
49496: LIST
49497: PUSH
49498: LD_INT 34
49500: PUSH
49501: LD_INT 31
49503: PUSH
49504: EMPTY
49505: LIST
49506: LIST
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: LIST
49512: LIST
49513: LIST
49514: LIST
49515: LIST
49516: LIST
49517: LIST
49518: LIST
49519: LIST
49520: PPUSH
49521: CALL_OW 72
49525: DIFF
49526: ST_TO_ADDR
// end ; end_of_file
49527: LD_VAR 0 3
49531: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
49532: LD_INT 0
49534: PPUSH
49535: PPUSH
49536: PPUSH
// if not mc_bases or not skirmish then
49537: LD_EXP 93
49541: NOT
49542: PUSH
49543: LD_EXP 91
49547: NOT
49548: OR
49549: IFFALSE 49553
// exit ;
49551: GO 49718
// for i = 1 to mc_bases do
49553: LD_ADDR_VAR 0 4
49557: PUSH
49558: DOUBLE
49559: LD_INT 1
49561: DEC
49562: ST_TO_ADDR
49563: LD_EXP 93
49567: PUSH
49568: FOR_TO
49569: IFFALSE 49716
// begin if sci in mc_bases [ i ] then
49571: LD_VAR 0 2
49575: PUSH
49576: LD_EXP 93
49580: PUSH
49581: LD_VAR 0 4
49585: ARRAY
49586: IN
49587: IFFALSE 49714
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
49589: LD_ADDR_EXP 122
49593: PUSH
49594: LD_EXP 122
49598: PPUSH
49599: LD_VAR 0 4
49603: PUSH
49604: LD_EXP 122
49608: PUSH
49609: LD_VAR 0 4
49613: ARRAY
49614: PUSH
49615: LD_INT 1
49617: PLUS
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PPUSH
49623: LD_VAR 0 1
49627: PPUSH
49628: CALL 60598 0 3
49632: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
49633: LD_ADDR_VAR 0 5
49637: PUSH
49638: LD_EXP 93
49642: PUSH
49643: LD_VAR 0 4
49647: ARRAY
49648: PPUSH
49649: LD_INT 2
49651: PUSH
49652: LD_INT 30
49654: PUSH
49655: LD_INT 0
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 30
49664: PUSH
49665: LD_INT 1
49667: PUSH
49668: EMPTY
49669: LIST
49670: LIST
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: LIST
49676: PPUSH
49677: CALL_OW 72
49681: PPUSH
49682: LD_VAR 0 1
49686: PPUSH
49687: CALL_OW 74
49691: ST_TO_ADDR
// if tmp then
49692: LD_VAR 0 5
49696: IFFALSE 49712
// ComStandNearbyBuilding ( ape , tmp ) ;
49698: LD_VAR 0 1
49702: PPUSH
49703: LD_VAR 0 5
49707: PPUSH
49708: CALL 55275 0 2
// break ;
49712: GO 49716
// end ; end ;
49714: GO 49568
49716: POP
49717: POP
// end ;
49718: LD_VAR 0 3
49722: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
49723: LD_INT 0
49725: PPUSH
49726: PPUSH
49727: PPUSH
// if not mc_bases or not skirmish then
49728: LD_EXP 93
49732: NOT
49733: PUSH
49734: LD_EXP 91
49738: NOT
49739: OR
49740: IFFALSE 49744
// exit ;
49742: GO 49833
// for i = 1 to mc_bases do
49744: LD_ADDR_VAR 0 4
49748: PUSH
49749: DOUBLE
49750: LD_INT 1
49752: DEC
49753: ST_TO_ADDR
49754: LD_EXP 93
49758: PUSH
49759: FOR_TO
49760: IFFALSE 49831
// begin if building in mc_busy_turret_list [ i ] then
49762: LD_VAR 0 1
49766: PUSH
49767: LD_EXP 103
49771: PUSH
49772: LD_VAR 0 4
49776: ARRAY
49777: IN
49778: IFFALSE 49829
// begin tmp := mc_busy_turret_list [ i ] diff building ;
49780: LD_ADDR_VAR 0 5
49784: PUSH
49785: LD_EXP 103
49789: PUSH
49790: LD_VAR 0 4
49794: ARRAY
49795: PUSH
49796: LD_VAR 0 1
49800: DIFF
49801: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
49802: LD_ADDR_EXP 103
49806: PUSH
49807: LD_EXP 103
49811: PPUSH
49812: LD_VAR 0 4
49816: PPUSH
49817: LD_VAR 0 5
49821: PPUSH
49822: CALL_OW 1
49826: ST_TO_ADDR
// break ;
49827: GO 49831
// end ; end ;
49829: GO 49759
49831: POP
49832: POP
// end ;
49833: LD_VAR 0 3
49837: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
49838: LD_INT 0
49840: PPUSH
49841: PPUSH
49842: PPUSH
// if not mc_bases or not skirmish then
49843: LD_EXP 93
49847: NOT
49848: PUSH
49849: LD_EXP 91
49853: NOT
49854: OR
49855: IFFALSE 49859
// exit ;
49857: GO 50058
// for i = 1 to mc_bases do
49859: LD_ADDR_VAR 0 5
49863: PUSH
49864: DOUBLE
49865: LD_INT 1
49867: DEC
49868: ST_TO_ADDR
49869: LD_EXP 93
49873: PUSH
49874: FOR_TO
49875: IFFALSE 50056
// if building in mc_bases [ i ] then
49877: LD_VAR 0 1
49881: PUSH
49882: LD_EXP 93
49886: PUSH
49887: LD_VAR 0 5
49891: ARRAY
49892: IN
49893: IFFALSE 50054
// begin tmp := mc_bases [ i ] diff building ;
49895: LD_ADDR_VAR 0 6
49899: PUSH
49900: LD_EXP 93
49904: PUSH
49905: LD_VAR 0 5
49909: ARRAY
49910: PUSH
49911: LD_VAR 0 1
49915: DIFF
49916: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49917: LD_ADDR_EXP 93
49921: PUSH
49922: LD_EXP 93
49926: PPUSH
49927: LD_VAR 0 5
49931: PPUSH
49932: LD_VAR 0 6
49936: PPUSH
49937: CALL_OW 1
49941: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
49942: LD_VAR 0 1
49946: PUSH
49947: LD_EXP 101
49951: PUSH
49952: LD_VAR 0 5
49956: ARRAY
49957: IN
49958: IFFALSE 49997
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
49960: LD_ADDR_EXP 101
49964: PUSH
49965: LD_EXP 101
49969: PPUSH
49970: LD_VAR 0 5
49974: PPUSH
49975: LD_EXP 101
49979: PUSH
49980: LD_VAR 0 5
49984: ARRAY
49985: PUSH
49986: LD_VAR 0 1
49990: DIFF
49991: PPUSH
49992: CALL_OW 1
49996: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
49997: LD_VAR 0 1
50001: PUSH
50002: LD_EXP 102
50006: PUSH
50007: LD_VAR 0 5
50011: ARRAY
50012: IN
50013: IFFALSE 50052
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
50015: LD_ADDR_EXP 102
50019: PUSH
50020: LD_EXP 102
50024: PPUSH
50025: LD_VAR 0 5
50029: PPUSH
50030: LD_EXP 102
50034: PUSH
50035: LD_VAR 0 5
50039: ARRAY
50040: PUSH
50041: LD_VAR 0 1
50045: DIFF
50046: PPUSH
50047: CALL_OW 1
50051: ST_TO_ADDR
// break ;
50052: GO 50056
// end ;
50054: GO 49874
50056: POP
50057: POP
// end ;
50058: LD_VAR 0 4
50062: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
50063: LD_INT 0
50065: PPUSH
50066: PPUSH
50067: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
50068: LD_EXP 93
50072: NOT
50073: PUSH
50074: LD_EXP 91
50078: NOT
50079: OR
50080: PUSH
50081: LD_VAR 0 3
50085: PUSH
50086: LD_EXP 119
50090: IN
50091: NOT
50092: OR
50093: IFFALSE 50097
// exit ;
50095: GO 50220
// for i = 1 to mc_vehicles do
50097: LD_ADDR_VAR 0 6
50101: PUSH
50102: DOUBLE
50103: LD_INT 1
50105: DEC
50106: ST_TO_ADDR
50107: LD_EXP 112
50111: PUSH
50112: FOR_TO
50113: IFFALSE 50218
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
50115: LD_VAR 0 2
50119: PUSH
50120: LD_EXP 112
50124: PUSH
50125: LD_VAR 0 6
50129: ARRAY
50130: IN
50131: PUSH
50132: LD_VAR 0 1
50136: PUSH
50137: LD_EXP 112
50141: PUSH
50142: LD_VAR 0 6
50146: ARRAY
50147: IN
50148: OR
50149: IFFALSE 50216
// begin tmp := mc_vehicles [ i ] diff old ;
50151: LD_ADDR_VAR 0 7
50155: PUSH
50156: LD_EXP 112
50160: PUSH
50161: LD_VAR 0 6
50165: ARRAY
50166: PUSH
50167: LD_VAR 0 2
50171: DIFF
50172: ST_TO_ADDR
// tmp := tmp diff new ;
50173: LD_ADDR_VAR 0 7
50177: PUSH
50178: LD_VAR 0 7
50182: PUSH
50183: LD_VAR 0 1
50187: DIFF
50188: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
50189: LD_ADDR_EXP 112
50193: PUSH
50194: LD_EXP 112
50198: PPUSH
50199: LD_VAR 0 6
50203: PPUSH
50204: LD_VAR 0 7
50208: PPUSH
50209: CALL_OW 1
50213: ST_TO_ADDR
// break ;
50214: GO 50218
// end ;
50216: GO 50112
50218: POP
50219: POP
// end ;
50220: LD_VAR 0 5
50224: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
50225: LD_INT 0
50227: PPUSH
50228: PPUSH
50229: PPUSH
50230: PPUSH
// if not mc_bases or not skirmish then
50231: LD_EXP 93
50235: NOT
50236: PUSH
50237: LD_EXP 91
50241: NOT
50242: OR
50243: IFFALSE 50247
// exit ;
50245: GO 50630
// side := GetSide ( vehicle ) ;
50247: LD_ADDR_VAR 0 5
50251: PUSH
50252: LD_VAR 0 1
50256: PPUSH
50257: CALL_OW 255
50261: ST_TO_ADDR
// for i = 1 to mc_bases do
50262: LD_ADDR_VAR 0 4
50266: PUSH
50267: DOUBLE
50268: LD_INT 1
50270: DEC
50271: ST_TO_ADDR
50272: LD_EXP 93
50276: PUSH
50277: FOR_TO
50278: IFFALSE 50628
// begin if factory in mc_bases [ i ] then
50280: LD_VAR 0 2
50284: PUSH
50285: LD_EXP 93
50289: PUSH
50290: LD_VAR 0 4
50294: ARRAY
50295: IN
50296: IFFALSE 50626
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
50298: LD_EXP 115
50302: PUSH
50303: LD_VAR 0 4
50307: ARRAY
50308: PUSH
50309: LD_EXP 104
50313: PUSH
50314: LD_VAR 0 4
50318: ARRAY
50319: LESS
50320: PUSH
50321: LD_VAR 0 1
50325: PPUSH
50326: CALL_OW 264
50330: PUSH
50331: LD_INT 31
50333: PUSH
50334: LD_INT 32
50336: PUSH
50337: LD_INT 51
50339: PUSH
50340: LD_EXP 87
50344: PUSH
50345: LD_INT 12
50347: PUSH
50348: LD_INT 30
50350: PUSH
50351: LD_EXP 86
50355: PUSH
50356: LD_INT 11
50358: PUSH
50359: LD_INT 53
50361: PUSH
50362: LD_INT 14
50364: PUSH
50365: LD_EXP 90
50369: PUSH
50370: LD_INT 29
50372: PUSH
50373: LD_EXP 88
50377: PUSH
50378: LD_INT 13
50380: PUSH
50381: LD_INT 52
50383: PUSH
50384: LD_INT 48
50386: PUSH
50387: LD_INT 8
50389: PUSH
50390: EMPTY
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: LIST
50405: LIST
50406: LIST
50407: LIST
50408: IN
50409: NOT
50410: AND
50411: IFFALSE 50452
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
50413: LD_ADDR_EXP 115
50417: PUSH
50418: LD_EXP 115
50422: PPUSH
50423: LD_VAR 0 4
50427: PPUSH
50428: LD_EXP 115
50432: PUSH
50433: LD_VAR 0 4
50437: ARRAY
50438: PUSH
50439: LD_VAR 0 1
50443: ADD
50444: PPUSH
50445: CALL_OW 1
50449: ST_TO_ADDR
50450: GO 50496
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
50452: LD_ADDR_EXP 112
50456: PUSH
50457: LD_EXP 112
50461: PPUSH
50462: LD_VAR 0 4
50466: PUSH
50467: LD_EXP 112
50471: PUSH
50472: LD_VAR 0 4
50476: ARRAY
50477: PUSH
50478: LD_INT 1
50480: PLUS
50481: PUSH
50482: EMPTY
50483: LIST
50484: LIST
50485: PPUSH
50486: LD_VAR 0 1
50490: PPUSH
50491: CALL 60598 0 3
50495: ST_TO_ADDR
// if not mc_scan [ i ] then
50496: LD_EXP 116
50500: PUSH
50501: LD_VAR 0 4
50505: ARRAY
50506: NOT
50507: IFFALSE 50626
// begin if GetControl ( vehicle ) = control_remote then
50509: LD_VAR 0 1
50513: PPUSH
50514: CALL_OW 263
50518: PUSH
50519: LD_INT 2
50521: EQUAL
50522: IFFALSE 50542
// repeat wait ( 0 0$1 ) ;
50524: LD_INT 35
50526: PPUSH
50527: CALL_OW 67
// until IsControledBy ( vehicle ) ;
50531: LD_VAR 0 1
50535: PPUSH
50536: CALL_OW 312
50540: IFFALSE 50524
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
50542: LD_VAR 0 1
50546: PPUSH
50547: LD_EXP 117
50551: PUSH
50552: LD_VAR 0 4
50556: ARRAY
50557: PPUSH
50558: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
50562: LD_VAR 0 1
50566: PPUSH
50567: CALL_OW 263
50571: PUSH
50572: LD_INT 1
50574: NONEQUAL
50575: IFFALSE 50579
// break ;
50577: GO 50628
// repeat wait ( 0 0$1 ) ;
50579: LD_INT 35
50581: PPUSH
50582: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
50586: LD_VAR 0 1
50590: PPUSH
50591: LD_EXP 117
50595: PUSH
50596: LD_VAR 0 4
50600: ARRAY
50601: PPUSH
50602: CALL_OW 308
50606: IFFALSE 50579
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
50608: LD_VAR 0 1
50612: PPUSH
50613: CALL_OW 311
50617: PPUSH
50618: CALL_OW 121
// exit ;
50622: POP
50623: POP
50624: GO 50630
// end ; end ; end ;
50626: GO 50277
50628: POP
50629: POP
// end ;
50630: LD_VAR 0 3
50634: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
50635: LD_INT 0
50637: PPUSH
50638: PPUSH
50639: PPUSH
50640: PPUSH
// if not mc_bases or not skirmish then
50641: LD_EXP 93
50645: NOT
50646: PUSH
50647: LD_EXP 91
50651: NOT
50652: OR
50653: IFFALSE 50657
// exit ;
50655: GO 51010
// repeat wait ( 0 0$1 ) ;
50657: LD_INT 35
50659: PPUSH
50660: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
50664: LD_VAR 0 2
50668: PPUSH
50669: LD_VAR 0 3
50673: PPUSH
50674: CALL_OW 284
50678: IFFALSE 50657
// if GetResourceTypeXY ( x , y ) = mat_artefact then
50680: LD_VAR 0 2
50684: PPUSH
50685: LD_VAR 0 3
50689: PPUSH
50690: CALL_OW 283
50694: PUSH
50695: LD_INT 4
50697: EQUAL
50698: IFFALSE 50702
// exit ;
50700: GO 51010
// for i = 1 to mc_bases do
50702: LD_ADDR_VAR 0 7
50706: PUSH
50707: DOUBLE
50708: LD_INT 1
50710: DEC
50711: ST_TO_ADDR
50712: LD_EXP 93
50716: PUSH
50717: FOR_TO
50718: IFFALSE 51008
// begin if mc_crates_area [ i ] then
50720: LD_EXP 111
50724: PUSH
50725: LD_VAR 0 7
50729: ARRAY
50730: IFFALSE 50841
// for j in mc_crates_area [ i ] do
50732: LD_ADDR_VAR 0 8
50736: PUSH
50737: LD_EXP 111
50741: PUSH
50742: LD_VAR 0 7
50746: ARRAY
50747: PUSH
50748: FOR_IN
50749: IFFALSE 50839
// if InArea ( x , y , j ) then
50751: LD_VAR 0 2
50755: PPUSH
50756: LD_VAR 0 3
50760: PPUSH
50761: LD_VAR 0 8
50765: PPUSH
50766: CALL_OW 309
50770: IFFALSE 50837
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50772: LD_ADDR_EXP 109
50776: PUSH
50777: LD_EXP 109
50781: PPUSH
50782: LD_VAR 0 7
50786: PUSH
50787: LD_EXP 109
50791: PUSH
50792: LD_VAR 0 7
50796: ARRAY
50797: PUSH
50798: LD_INT 1
50800: PLUS
50801: PUSH
50802: EMPTY
50803: LIST
50804: LIST
50805: PPUSH
50806: LD_VAR 0 4
50810: PUSH
50811: LD_VAR 0 2
50815: PUSH
50816: LD_VAR 0 3
50820: PUSH
50821: EMPTY
50822: LIST
50823: LIST
50824: LIST
50825: PPUSH
50826: CALL 60598 0 3
50830: ST_TO_ADDR
// exit ;
50831: POP
50832: POP
50833: POP
50834: POP
50835: GO 51010
// end ;
50837: GO 50748
50839: POP
50840: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50841: LD_ADDR_VAR 0 9
50845: PUSH
50846: LD_EXP 93
50850: PUSH
50851: LD_VAR 0 7
50855: ARRAY
50856: PPUSH
50857: LD_INT 2
50859: PUSH
50860: LD_INT 30
50862: PUSH
50863: LD_INT 0
50865: PUSH
50866: EMPTY
50867: LIST
50868: LIST
50869: PUSH
50870: LD_INT 30
50872: PUSH
50873: LD_INT 1
50875: PUSH
50876: EMPTY
50877: LIST
50878: LIST
50879: PUSH
50880: EMPTY
50881: LIST
50882: LIST
50883: LIST
50884: PPUSH
50885: CALL_OW 72
50889: ST_TO_ADDR
// if not depot then
50890: LD_VAR 0 9
50894: NOT
50895: IFFALSE 50899
// continue ;
50897: GO 50717
// for j in depot do
50899: LD_ADDR_VAR 0 8
50903: PUSH
50904: LD_VAR 0 9
50908: PUSH
50909: FOR_IN
50910: IFFALSE 51004
// if GetDistUnitXY ( j , x , y ) < 30 then
50912: LD_VAR 0 8
50916: PPUSH
50917: LD_VAR 0 2
50921: PPUSH
50922: LD_VAR 0 3
50926: PPUSH
50927: CALL_OW 297
50931: PUSH
50932: LD_INT 30
50934: LESS
50935: IFFALSE 51002
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50937: LD_ADDR_EXP 109
50941: PUSH
50942: LD_EXP 109
50946: PPUSH
50947: LD_VAR 0 7
50951: PUSH
50952: LD_EXP 109
50956: PUSH
50957: LD_VAR 0 7
50961: ARRAY
50962: PUSH
50963: LD_INT 1
50965: PLUS
50966: PUSH
50967: EMPTY
50968: LIST
50969: LIST
50970: PPUSH
50971: LD_VAR 0 4
50975: PUSH
50976: LD_VAR 0 2
50980: PUSH
50981: LD_VAR 0 3
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: LIST
50990: PPUSH
50991: CALL 60598 0 3
50995: ST_TO_ADDR
// exit ;
50996: POP
50997: POP
50998: POP
50999: POP
51000: GO 51010
// end ;
51002: GO 50909
51004: POP
51005: POP
// end ;
51006: GO 50717
51008: POP
51009: POP
// end ;
51010: LD_VAR 0 6
51014: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
51015: LD_INT 0
51017: PPUSH
51018: PPUSH
51019: PPUSH
51020: PPUSH
// if not mc_bases or not skirmish then
51021: LD_EXP 93
51025: NOT
51026: PUSH
51027: LD_EXP 91
51031: NOT
51032: OR
51033: IFFALSE 51037
// exit ;
51035: GO 51314
// side := GetSide ( lab ) ;
51037: LD_ADDR_VAR 0 4
51041: PUSH
51042: LD_VAR 0 2
51046: PPUSH
51047: CALL_OW 255
51051: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
51052: LD_VAR 0 4
51056: PUSH
51057: LD_EXP 119
51061: IN
51062: NOT
51063: PUSH
51064: LD_EXP 120
51068: NOT
51069: OR
51070: PUSH
51071: LD_EXP 93
51075: NOT
51076: OR
51077: IFFALSE 51081
// exit ;
51079: GO 51314
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
51081: LD_ADDR_EXP 120
51085: PUSH
51086: LD_EXP 120
51090: PPUSH
51091: LD_VAR 0 4
51095: PPUSH
51096: LD_EXP 120
51100: PUSH
51101: LD_VAR 0 4
51105: ARRAY
51106: PUSH
51107: LD_VAR 0 1
51111: DIFF
51112: PPUSH
51113: CALL_OW 1
51117: ST_TO_ADDR
// for i = 1 to mc_bases do
51118: LD_ADDR_VAR 0 5
51122: PUSH
51123: DOUBLE
51124: LD_INT 1
51126: DEC
51127: ST_TO_ADDR
51128: LD_EXP 93
51132: PUSH
51133: FOR_TO
51134: IFFALSE 51312
// begin if lab in mc_bases [ i ] then
51136: LD_VAR 0 2
51140: PUSH
51141: LD_EXP 93
51145: PUSH
51146: LD_VAR 0 5
51150: ARRAY
51151: IN
51152: IFFALSE 51310
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
51154: LD_VAR 0 1
51158: PUSH
51159: LD_INT 11
51161: PUSH
51162: LD_INT 4
51164: PUSH
51165: LD_INT 3
51167: PUSH
51168: LD_INT 2
51170: PUSH
51171: EMPTY
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: IN
51177: PUSH
51178: LD_EXP 123
51182: PUSH
51183: LD_VAR 0 5
51187: ARRAY
51188: AND
51189: IFFALSE 51310
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
51191: LD_ADDR_VAR 0 6
51195: PUSH
51196: LD_EXP 123
51200: PUSH
51201: LD_VAR 0 5
51205: ARRAY
51206: PUSH
51207: LD_INT 1
51209: ARRAY
51210: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51211: LD_ADDR_EXP 123
51215: PUSH
51216: LD_EXP 123
51220: PPUSH
51221: LD_VAR 0 5
51225: PPUSH
51226: EMPTY
51227: PPUSH
51228: CALL_OW 1
51232: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
51233: LD_VAR 0 6
51237: PPUSH
51238: LD_INT 0
51240: PPUSH
51241: CALL_OW 109
// ComExitBuilding ( tmp ) ;
51245: LD_VAR 0 6
51249: PPUSH
51250: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
51254: LD_ADDR_EXP 122
51258: PUSH
51259: LD_EXP 122
51263: PPUSH
51264: LD_VAR 0 5
51268: PPUSH
51269: LD_EXP 122
51273: PUSH
51274: LD_VAR 0 5
51278: ARRAY
51279: PPUSH
51280: LD_INT 1
51282: PPUSH
51283: LD_VAR 0 6
51287: PPUSH
51288: CALL_OW 2
51292: PPUSH
51293: CALL_OW 1
51297: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
51298: LD_VAR 0 5
51302: PPUSH
51303: LD_INT 112
51305: PPUSH
51306: CALL 29070 0 2
// end ; end ; end ;
51310: GO 51133
51312: POP
51313: POP
// end ;
51314: LD_VAR 0 3
51318: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
51319: LD_INT 0
51321: PPUSH
51322: PPUSH
51323: PPUSH
51324: PPUSH
51325: PPUSH
51326: PPUSH
51327: PPUSH
51328: PPUSH
// if not mc_bases or not skirmish then
51329: LD_EXP 93
51333: NOT
51334: PUSH
51335: LD_EXP 91
51339: NOT
51340: OR
51341: IFFALSE 51345
// exit ;
51343: GO 52288
// for i = 1 to mc_bases do
51345: LD_ADDR_VAR 0 3
51349: PUSH
51350: DOUBLE
51351: LD_INT 1
51353: DEC
51354: ST_TO_ADDR
51355: LD_EXP 93
51359: PUSH
51360: FOR_TO
51361: IFFALSE 52286
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
51363: LD_VAR 0 1
51367: PUSH
51368: LD_EXP 93
51372: PUSH
51373: LD_VAR 0 3
51377: ARRAY
51378: IN
51379: PUSH
51380: LD_VAR 0 1
51384: PUSH
51385: LD_EXP 100
51389: PUSH
51390: LD_VAR 0 3
51394: ARRAY
51395: IN
51396: OR
51397: PUSH
51398: LD_VAR 0 1
51402: PUSH
51403: LD_EXP 112
51407: PUSH
51408: LD_VAR 0 3
51412: ARRAY
51413: IN
51414: OR
51415: PUSH
51416: LD_VAR 0 1
51420: PUSH
51421: LD_EXP 122
51425: PUSH
51426: LD_VAR 0 3
51430: ARRAY
51431: IN
51432: OR
51433: PUSH
51434: LD_VAR 0 1
51438: PUSH
51439: LD_EXP 123
51443: PUSH
51444: LD_VAR 0 3
51448: ARRAY
51449: IN
51450: OR
51451: IFFALSE 52284
// begin if un in mc_ape [ i ] then
51453: LD_VAR 0 1
51457: PUSH
51458: LD_EXP 122
51462: PUSH
51463: LD_VAR 0 3
51467: ARRAY
51468: IN
51469: IFFALSE 51508
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
51471: LD_ADDR_EXP 122
51475: PUSH
51476: LD_EXP 122
51480: PPUSH
51481: LD_VAR 0 3
51485: PPUSH
51486: LD_EXP 122
51490: PUSH
51491: LD_VAR 0 3
51495: ARRAY
51496: PUSH
51497: LD_VAR 0 1
51501: DIFF
51502: PPUSH
51503: CALL_OW 1
51507: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
51508: LD_VAR 0 1
51512: PUSH
51513: LD_EXP 123
51517: PUSH
51518: LD_VAR 0 3
51522: ARRAY
51523: IN
51524: IFFALSE 51548
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51526: LD_ADDR_EXP 123
51530: PUSH
51531: LD_EXP 123
51535: PPUSH
51536: LD_VAR 0 3
51540: PPUSH
51541: EMPTY
51542: PPUSH
51543: CALL_OW 1
51547: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
51548: LD_VAR 0 1
51552: PPUSH
51553: CALL_OW 247
51557: PUSH
51558: LD_INT 2
51560: EQUAL
51561: PUSH
51562: LD_VAR 0 1
51566: PPUSH
51567: CALL_OW 110
51571: PUSH
51572: LD_INT 20
51574: EQUAL
51575: AND
51576: IFFALSE 51679
// begin fac := MC_GetBuilding ( i , b_factory ) ;
51578: LD_ADDR_VAR 0 8
51582: PUSH
51583: LD_VAR 0 3
51587: PPUSH
51588: LD_INT 3
51590: PPUSH
51591: CALL 48378 0 2
51595: ST_TO_ADDR
// if fac then
51596: LD_VAR 0 8
51600: IFFALSE 51679
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
51602: LD_ADDR_VAR 0 9
51606: PUSH
51607: LD_VAR 0 8
51611: PPUSH
51612: LD_VAR 0 1
51616: PPUSH
51617: CALL_OW 265
51621: PPUSH
51622: LD_VAR 0 1
51626: PPUSH
51627: CALL_OW 262
51631: PPUSH
51632: LD_VAR 0 1
51636: PPUSH
51637: CALL_OW 263
51641: PPUSH
51642: LD_VAR 0 1
51646: PPUSH
51647: CALL_OW 264
51651: PPUSH
51652: CALL 58198 0 5
51656: ST_TO_ADDR
// if components then
51657: LD_VAR 0 9
51661: IFFALSE 51677
// MC_InsertProduceList ( i , components ) ;
51663: LD_VAR 0 3
51667: PPUSH
51668: LD_VAR 0 9
51672: PPUSH
51673: CALL 47948 0 2
// break ;
51677: GO 52286
// end ; end ; if GetType ( un ) = unit_building then
51679: LD_VAR 0 1
51683: PPUSH
51684: CALL_OW 247
51688: PUSH
51689: LD_INT 3
51691: EQUAL
51692: IFFALSE 52007
// begin btype := GetBType ( un ) ;
51694: LD_ADDR_VAR 0 5
51698: PUSH
51699: LD_VAR 0 1
51703: PPUSH
51704: CALL_OW 266
51708: ST_TO_ADDR
// if btype = b_warehouse then
51709: LD_VAR 0 5
51713: PUSH
51714: LD_INT 1
51716: EQUAL
51717: IFFALSE 51735
// begin btype := b_depot ;
51719: LD_ADDR_VAR 0 5
51723: PUSH
51724: LD_INT 0
51726: ST_TO_ADDR
// pos := 1 ;
51727: LD_ADDR_VAR 0 6
51731: PUSH
51732: LD_INT 1
51734: ST_TO_ADDR
// end ; if btype = b_factory then
51735: LD_VAR 0 5
51739: PUSH
51740: LD_INT 3
51742: EQUAL
51743: IFFALSE 51761
// begin btype := b_workshop ;
51745: LD_ADDR_VAR 0 5
51749: PUSH
51750: LD_INT 2
51752: ST_TO_ADDR
// pos := 1 ;
51753: LD_ADDR_VAR 0 6
51757: PUSH
51758: LD_INT 1
51760: ST_TO_ADDR
// end ; if btype = b_barracks then
51761: LD_VAR 0 5
51765: PUSH
51766: LD_INT 5
51768: EQUAL
51769: IFFALSE 51779
// btype := b_armoury ;
51771: LD_ADDR_VAR 0 5
51775: PUSH
51776: LD_INT 4
51778: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51779: LD_VAR 0 5
51783: PUSH
51784: LD_INT 7
51786: PUSH
51787: LD_INT 8
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: IN
51794: IFFALSE 51804
// btype := b_lab ;
51796: LD_ADDR_VAR 0 5
51800: PUSH
51801: LD_INT 6
51803: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51804: LD_ADDR_EXP 98
51808: PUSH
51809: LD_EXP 98
51813: PPUSH
51814: LD_VAR 0 3
51818: PUSH
51819: LD_EXP 98
51823: PUSH
51824: LD_VAR 0 3
51828: ARRAY
51829: PUSH
51830: LD_INT 1
51832: PLUS
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: PPUSH
51838: LD_VAR 0 5
51842: PUSH
51843: LD_VAR 0 1
51847: PPUSH
51848: CALL_OW 250
51852: PUSH
51853: LD_VAR 0 1
51857: PPUSH
51858: CALL_OW 251
51862: PUSH
51863: LD_VAR 0 1
51867: PPUSH
51868: CALL_OW 254
51872: PUSH
51873: EMPTY
51874: LIST
51875: LIST
51876: LIST
51877: LIST
51878: PPUSH
51879: CALL 60598 0 3
51883: ST_TO_ADDR
// if pos = 1 then
51884: LD_VAR 0 6
51888: PUSH
51889: LD_INT 1
51891: EQUAL
51892: IFFALSE 52007
// begin tmp := mc_build_list [ i ] ;
51894: LD_ADDR_VAR 0 7
51898: PUSH
51899: LD_EXP 98
51903: PUSH
51904: LD_VAR 0 3
51908: ARRAY
51909: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51910: LD_VAR 0 7
51914: PPUSH
51915: LD_INT 2
51917: PUSH
51918: LD_INT 30
51920: PUSH
51921: LD_INT 0
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: PUSH
51928: LD_INT 30
51930: PUSH
51931: LD_INT 1
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: LIST
51942: PPUSH
51943: CALL_OW 72
51947: IFFALSE 51957
// pos := 2 ;
51949: LD_ADDR_VAR 0 6
51953: PUSH
51954: LD_INT 2
51956: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51957: LD_ADDR_VAR 0 7
51961: PUSH
51962: LD_VAR 0 7
51966: PPUSH
51967: LD_VAR 0 6
51971: PPUSH
51972: LD_VAR 0 7
51976: PPUSH
51977: CALL 60924 0 3
51981: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51982: LD_ADDR_EXP 98
51986: PUSH
51987: LD_EXP 98
51991: PPUSH
51992: LD_VAR 0 3
51996: PPUSH
51997: LD_VAR 0 7
52001: PPUSH
52002: CALL_OW 1
52006: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
52007: LD_VAR 0 1
52011: PUSH
52012: LD_EXP 93
52016: PUSH
52017: LD_VAR 0 3
52021: ARRAY
52022: IN
52023: IFFALSE 52062
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
52025: LD_ADDR_EXP 93
52029: PUSH
52030: LD_EXP 93
52034: PPUSH
52035: LD_VAR 0 3
52039: PPUSH
52040: LD_EXP 93
52044: PUSH
52045: LD_VAR 0 3
52049: ARRAY
52050: PUSH
52051: LD_VAR 0 1
52055: DIFF
52056: PPUSH
52057: CALL_OW 1
52061: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
52062: LD_VAR 0 1
52066: PUSH
52067: LD_EXP 100
52071: PUSH
52072: LD_VAR 0 3
52076: ARRAY
52077: IN
52078: IFFALSE 52117
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
52080: LD_ADDR_EXP 100
52084: PUSH
52085: LD_EXP 100
52089: PPUSH
52090: LD_VAR 0 3
52094: PPUSH
52095: LD_EXP 100
52099: PUSH
52100: LD_VAR 0 3
52104: ARRAY
52105: PUSH
52106: LD_VAR 0 1
52110: DIFF
52111: PPUSH
52112: CALL_OW 1
52116: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
52117: LD_VAR 0 1
52121: PUSH
52122: LD_EXP 112
52126: PUSH
52127: LD_VAR 0 3
52131: ARRAY
52132: IN
52133: IFFALSE 52172
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
52135: LD_ADDR_EXP 112
52139: PUSH
52140: LD_EXP 112
52144: PPUSH
52145: LD_VAR 0 3
52149: PPUSH
52150: LD_EXP 112
52154: PUSH
52155: LD_VAR 0 3
52159: ARRAY
52160: PUSH
52161: LD_VAR 0 1
52165: DIFF
52166: PPUSH
52167: CALL_OW 1
52171: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
52172: LD_VAR 0 1
52176: PUSH
52177: LD_EXP 102
52181: PUSH
52182: LD_VAR 0 3
52186: ARRAY
52187: IN
52188: IFFALSE 52227
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
52190: LD_ADDR_EXP 102
52194: PUSH
52195: LD_EXP 102
52199: PPUSH
52200: LD_VAR 0 3
52204: PPUSH
52205: LD_EXP 102
52209: PUSH
52210: LD_VAR 0 3
52214: ARRAY
52215: PUSH
52216: LD_VAR 0 1
52220: DIFF
52221: PPUSH
52222: CALL_OW 1
52226: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
52227: LD_VAR 0 1
52231: PUSH
52232: LD_EXP 101
52236: PUSH
52237: LD_VAR 0 3
52241: ARRAY
52242: IN
52243: IFFALSE 52282
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
52245: LD_ADDR_EXP 101
52249: PUSH
52250: LD_EXP 101
52254: PPUSH
52255: LD_VAR 0 3
52259: PPUSH
52260: LD_EXP 101
52264: PUSH
52265: LD_VAR 0 3
52269: ARRAY
52270: PUSH
52271: LD_VAR 0 1
52275: DIFF
52276: PPUSH
52277: CALL_OW 1
52281: ST_TO_ADDR
// end ; break ;
52282: GO 52286
// end ;
52284: GO 51360
52286: POP
52287: POP
// end ;
52288: LD_VAR 0 2
52292: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
52293: LD_INT 0
52295: PPUSH
52296: PPUSH
52297: PPUSH
// if not mc_bases or not skirmish then
52298: LD_EXP 93
52302: NOT
52303: PUSH
52304: LD_EXP 91
52308: NOT
52309: OR
52310: IFFALSE 52314
// exit ;
52312: GO 52529
// for i = 1 to mc_bases do
52314: LD_ADDR_VAR 0 3
52318: PUSH
52319: DOUBLE
52320: LD_INT 1
52322: DEC
52323: ST_TO_ADDR
52324: LD_EXP 93
52328: PUSH
52329: FOR_TO
52330: IFFALSE 52527
// begin if building in mc_construct_list [ i ] then
52332: LD_VAR 0 1
52336: PUSH
52337: LD_EXP 100
52341: PUSH
52342: LD_VAR 0 3
52346: ARRAY
52347: IN
52348: IFFALSE 52525
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52350: LD_ADDR_EXP 100
52354: PUSH
52355: LD_EXP 100
52359: PPUSH
52360: LD_VAR 0 3
52364: PPUSH
52365: LD_EXP 100
52369: PUSH
52370: LD_VAR 0 3
52374: ARRAY
52375: PUSH
52376: LD_VAR 0 1
52380: DIFF
52381: PPUSH
52382: CALL_OW 1
52386: ST_TO_ADDR
// if building in mc_lab [ i ] then
52387: LD_VAR 0 1
52391: PUSH
52392: LD_EXP 126
52396: PUSH
52397: LD_VAR 0 3
52401: ARRAY
52402: IN
52403: IFFALSE 52458
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52405: LD_ADDR_EXP 127
52409: PUSH
52410: LD_EXP 127
52414: PPUSH
52415: LD_VAR 0 3
52419: PPUSH
52420: LD_EXP 127
52424: PUSH
52425: LD_VAR 0 3
52429: ARRAY
52430: PPUSH
52431: LD_INT 1
52433: PPUSH
52434: LD_EXP 127
52438: PUSH
52439: LD_VAR 0 3
52443: ARRAY
52444: PPUSH
52445: LD_INT 0
52447: PPUSH
52448: CALL 60016 0 4
52452: PPUSH
52453: CALL_OW 1
52457: ST_TO_ADDR
// if not building in mc_bases [ i ] then
52458: LD_VAR 0 1
52462: PUSH
52463: LD_EXP 93
52467: PUSH
52468: LD_VAR 0 3
52472: ARRAY
52473: IN
52474: NOT
52475: IFFALSE 52521
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52477: LD_ADDR_EXP 93
52481: PUSH
52482: LD_EXP 93
52486: PPUSH
52487: LD_VAR 0 3
52491: PUSH
52492: LD_EXP 93
52496: PUSH
52497: LD_VAR 0 3
52501: ARRAY
52502: PUSH
52503: LD_INT 1
52505: PLUS
52506: PUSH
52507: EMPTY
52508: LIST
52509: LIST
52510: PPUSH
52511: LD_VAR 0 1
52515: PPUSH
52516: CALL 60598 0 3
52520: ST_TO_ADDR
// exit ;
52521: POP
52522: POP
52523: GO 52529
// end ; end ;
52525: GO 52329
52527: POP
52528: POP
// end ;
52529: LD_VAR 0 2
52533: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
52534: LD_INT 0
52536: PPUSH
52537: PPUSH
52538: PPUSH
52539: PPUSH
52540: PPUSH
52541: PPUSH
52542: PPUSH
// if not mc_bases or not skirmish then
52543: LD_EXP 93
52547: NOT
52548: PUSH
52549: LD_EXP 91
52553: NOT
52554: OR
52555: IFFALSE 52559
// exit ;
52557: GO 53220
// for i = 1 to mc_bases do
52559: LD_ADDR_VAR 0 3
52563: PUSH
52564: DOUBLE
52565: LD_INT 1
52567: DEC
52568: ST_TO_ADDR
52569: LD_EXP 93
52573: PUSH
52574: FOR_TO
52575: IFFALSE 53218
// begin if building in mc_construct_list [ i ] then
52577: LD_VAR 0 1
52581: PUSH
52582: LD_EXP 100
52586: PUSH
52587: LD_VAR 0 3
52591: ARRAY
52592: IN
52593: IFFALSE 53216
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52595: LD_ADDR_EXP 100
52599: PUSH
52600: LD_EXP 100
52604: PPUSH
52605: LD_VAR 0 3
52609: PPUSH
52610: LD_EXP 100
52614: PUSH
52615: LD_VAR 0 3
52619: ARRAY
52620: PUSH
52621: LD_VAR 0 1
52625: DIFF
52626: PPUSH
52627: CALL_OW 1
52631: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52632: LD_ADDR_EXP 93
52636: PUSH
52637: LD_EXP 93
52641: PPUSH
52642: LD_VAR 0 3
52646: PUSH
52647: LD_EXP 93
52651: PUSH
52652: LD_VAR 0 3
52656: ARRAY
52657: PUSH
52658: LD_INT 1
52660: PLUS
52661: PUSH
52662: EMPTY
52663: LIST
52664: LIST
52665: PPUSH
52666: LD_VAR 0 1
52670: PPUSH
52671: CALL 60598 0 3
52675: ST_TO_ADDR
// btype := GetBType ( building ) ;
52676: LD_ADDR_VAR 0 5
52680: PUSH
52681: LD_VAR 0 1
52685: PPUSH
52686: CALL_OW 266
52690: ST_TO_ADDR
// side := GetSide ( building ) ;
52691: LD_ADDR_VAR 0 8
52695: PUSH
52696: LD_VAR 0 1
52700: PPUSH
52701: CALL_OW 255
52705: ST_TO_ADDR
// if btype = b_lab then
52706: LD_VAR 0 5
52710: PUSH
52711: LD_INT 6
52713: EQUAL
52714: IFFALSE 52764
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52716: LD_ADDR_EXP 126
52720: PUSH
52721: LD_EXP 126
52725: PPUSH
52726: LD_VAR 0 3
52730: PUSH
52731: LD_EXP 126
52735: PUSH
52736: LD_VAR 0 3
52740: ARRAY
52741: PUSH
52742: LD_INT 1
52744: PLUS
52745: PUSH
52746: EMPTY
52747: LIST
52748: LIST
52749: PPUSH
52750: LD_VAR 0 1
52754: PPUSH
52755: CALL 60598 0 3
52759: ST_TO_ADDR
// exit ;
52760: POP
52761: POP
52762: GO 53220
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52764: LD_VAR 0 5
52768: PUSH
52769: LD_INT 0
52771: PUSH
52772: LD_INT 2
52774: PUSH
52775: LD_INT 4
52777: PUSH
52778: EMPTY
52779: LIST
52780: LIST
52781: LIST
52782: IN
52783: IFFALSE 52907
// begin if btype = b_armoury then
52785: LD_VAR 0 5
52789: PUSH
52790: LD_INT 4
52792: EQUAL
52793: IFFALSE 52803
// btype := b_barracks ;
52795: LD_ADDR_VAR 0 5
52799: PUSH
52800: LD_INT 5
52802: ST_TO_ADDR
// if btype = b_depot then
52803: LD_VAR 0 5
52807: PUSH
52808: LD_INT 0
52810: EQUAL
52811: IFFALSE 52821
// btype := b_warehouse ;
52813: LD_ADDR_VAR 0 5
52817: PUSH
52818: LD_INT 1
52820: ST_TO_ADDR
// if btype = b_workshop then
52821: LD_VAR 0 5
52825: PUSH
52826: LD_INT 2
52828: EQUAL
52829: IFFALSE 52839
// btype := b_factory ;
52831: LD_ADDR_VAR 0 5
52835: PUSH
52836: LD_INT 3
52838: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52839: LD_VAR 0 5
52843: PPUSH
52844: LD_VAR 0 8
52848: PPUSH
52849: CALL_OW 323
52853: PUSH
52854: LD_INT 1
52856: EQUAL
52857: IFFALSE 52903
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52859: LD_ADDR_EXP 125
52863: PUSH
52864: LD_EXP 125
52868: PPUSH
52869: LD_VAR 0 3
52873: PUSH
52874: LD_EXP 125
52878: PUSH
52879: LD_VAR 0 3
52883: ARRAY
52884: PUSH
52885: LD_INT 1
52887: PLUS
52888: PUSH
52889: EMPTY
52890: LIST
52891: LIST
52892: PPUSH
52893: LD_VAR 0 1
52897: PPUSH
52898: CALL 60598 0 3
52902: ST_TO_ADDR
// exit ;
52903: POP
52904: POP
52905: GO 53220
// end ; if btype in [ b_bunker , b_turret ] then
52907: LD_VAR 0 5
52911: PUSH
52912: LD_INT 32
52914: PUSH
52915: LD_INT 33
52917: PUSH
52918: EMPTY
52919: LIST
52920: LIST
52921: IN
52922: IFFALSE 53212
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52924: LD_ADDR_EXP 101
52928: PUSH
52929: LD_EXP 101
52933: PPUSH
52934: LD_VAR 0 3
52938: PUSH
52939: LD_EXP 101
52943: PUSH
52944: LD_VAR 0 3
52948: ARRAY
52949: PUSH
52950: LD_INT 1
52952: PLUS
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: PPUSH
52958: LD_VAR 0 1
52962: PPUSH
52963: CALL 60598 0 3
52967: ST_TO_ADDR
// if btype = b_bunker then
52968: LD_VAR 0 5
52972: PUSH
52973: LD_INT 32
52975: EQUAL
52976: IFFALSE 53212
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52978: LD_ADDR_EXP 102
52982: PUSH
52983: LD_EXP 102
52987: PPUSH
52988: LD_VAR 0 3
52992: PUSH
52993: LD_EXP 102
52997: PUSH
52998: LD_VAR 0 3
53002: ARRAY
53003: PUSH
53004: LD_INT 1
53006: PLUS
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PPUSH
53012: LD_VAR 0 1
53016: PPUSH
53017: CALL 60598 0 3
53021: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
53022: LD_ADDR_VAR 0 6
53026: PUSH
53027: LD_EXP 93
53031: PUSH
53032: LD_VAR 0 3
53036: ARRAY
53037: PPUSH
53038: LD_INT 25
53040: PUSH
53041: LD_INT 1
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: PUSH
53048: LD_INT 3
53050: PUSH
53051: LD_INT 54
53053: PUSH
53054: EMPTY
53055: LIST
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: PPUSH
53065: CALL_OW 72
53069: ST_TO_ADDR
// if tmp then
53070: LD_VAR 0 6
53074: IFFALSE 53080
// exit ;
53076: POP
53077: POP
53078: GO 53220
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53080: LD_ADDR_VAR 0 6
53084: PUSH
53085: LD_EXP 93
53089: PUSH
53090: LD_VAR 0 3
53094: ARRAY
53095: PPUSH
53096: LD_INT 2
53098: PUSH
53099: LD_INT 30
53101: PUSH
53102: LD_INT 4
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: LD_INT 30
53111: PUSH
53112: LD_INT 5
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: PUSH
53119: EMPTY
53120: LIST
53121: LIST
53122: LIST
53123: PPUSH
53124: CALL_OW 72
53128: ST_TO_ADDR
// if not tmp then
53129: LD_VAR 0 6
53133: NOT
53134: IFFALSE 53140
// exit ;
53136: POP
53137: POP
53138: GO 53220
// for j in tmp do
53140: LD_ADDR_VAR 0 4
53144: PUSH
53145: LD_VAR 0 6
53149: PUSH
53150: FOR_IN
53151: IFFALSE 53210
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
53153: LD_ADDR_VAR 0 7
53157: PUSH
53158: LD_VAR 0 4
53162: PPUSH
53163: CALL_OW 313
53167: PPUSH
53168: LD_INT 25
53170: PUSH
53171: LD_INT 1
53173: PUSH
53174: EMPTY
53175: LIST
53176: LIST
53177: PPUSH
53178: CALL_OW 72
53182: ST_TO_ADDR
// if units then
53183: LD_VAR 0 7
53187: IFFALSE 53208
// begin ComExitBuilding ( units [ 1 ] ) ;
53189: LD_VAR 0 7
53193: PUSH
53194: LD_INT 1
53196: ARRAY
53197: PPUSH
53198: CALL_OW 122
// exit ;
53202: POP
53203: POP
53204: POP
53205: POP
53206: GO 53220
// end ; end ;
53208: GO 53150
53210: POP
53211: POP
// end ; end ; exit ;
53212: POP
53213: POP
53214: GO 53220
// end ; end ;
53216: GO 52574
53218: POP
53219: POP
// end ;
53220: LD_VAR 0 2
53224: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
53225: LD_INT 0
53227: PPUSH
53228: PPUSH
53229: PPUSH
53230: PPUSH
53231: PPUSH
53232: PPUSH
53233: PPUSH
// if not mc_bases or not skirmish then
53234: LD_EXP 93
53238: NOT
53239: PUSH
53240: LD_EXP 91
53244: NOT
53245: OR
53246: IFFALSE 53250
// exit ;
53248: GO 53481
// btype := GetBType ( building ) ;
53250: LD_ADDR_VAR 0 6
53254: PUSH
53255: LD_VAR 0 1
53259: PPUSH
53260: CALL_OW 266
53264: ST_TO_ADDR
// x := GetX ( building ) ;
53265: LD_ADDR_VAR 0 7
53269: PUSH
53270: LD_VAR 0 1
53274: PPUSH
53275: CALL_OW 250
53279: ST_TO_ADDR
// y := GetY ( building ) ;
53280: LD_ADDR_VAR 0 8
53284: PUSH
53285: LD_VAR 0 1
53289: PPUSH
53290: CALL_OW 251
53294: ST_TO_ADDR
// d := GetDir ( building ) ;
53295: LD_ADDR_VAR 0 9
53299: PUSH
53300: LD_VAR 0 1
53304: PPUSH
53305: CALL_OW 254
53309: ST_TO_ADDR
// for i = 1 to mc_bases do
53310: LD_ADDR_VAR 0 4
53314: PUSH
53315: DOUBLE
53316: LD_INT 1
53318: DEC
53319: ST_TO_ADDR
53320: LD_EXP 93
53324: PUSH
53325: FOR_TO
53326: IFFALSE 53479
// begin if not mc_build_list [ i ] then
53328: LD_EXP 98
53332: PUSH
53333: LD_VAR 0 4
53337: ARRAY
53338: NOT
53339: IFFALSE 53343
// continue ;
53341: GO 53325
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
53343: LD_VAR 0 6
53347: PUSH
53348: LD_VAR 0 7
53352: PUSH
53353: LD_VAR 0 8
53357: PUSH
53358: LD_VAR 0 9
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: LIST
53367: LIST
53368: PPUSH
53369: LD_EXP 98
53373: PUSH
53374: LD_VAR 0 4
53378: ARRAY
53379: PUSH
53380: LD_INT 1
53382: ARRAY
53383: PPUSH
53384: CALL 66767 0 2
53388: IFFALSE 53477
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
53390: LD_ADDR_EXP 98
53394: PUSH
53395: LD_EXP 98
53399: PPUSH
53400: LD_VAR 0 4
53404: PPUSH
53405: LD_EXP 98
53409: PUSH
53410: LD_VAR 0 4
53414: ARRAY
53415: PPUSH
53416: LD_INT 1
53418: PPUSH
53419: CALL_OW 3
53423: PPUSH
53424: CALL_OW 1
53428: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
53429: LD_ADDR_EXP 100
53433: PUSH
53434: LD_EXP 100
53438: PPUSH
53439: LD_VAR 0 4
53443: PUSH
53444: LD_EXP 100
53448: PUSH
53449: LD_VAR 0 4
53453: ARRAY
53454: PUSH
53455: LD_INT 1
53457: PLUS
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PPUSH
53463: LD_VAR 0 1
53467: PPUSH
53468: CALL 60598 0 3
53472: ST_TO_ADDR
// exit ;
53473: POP
53474: POP
53475: GO 53481
// end ; end ;
53477: GO 53325
53479: POP
53480: POP
// end ;
53481: LD_VAR 0 3
53485: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
53486: LD_INT 0
53488: PPUSH
53489: PPUSH
53490: PPUSH
// if not mc_bases or not skirmish then
53491: LD_EXP 93
53495: NOT
53496: PUSH
53497: LD_EXP 91
53501: NOT
53502: OR
53503: IFFALSE 53507
// exit ;
53505: GO 53697
// for i = 1 to mc_bases do
53507: LD_ADDR_VAR 0 4
53511: PUSH
53512: DOUBLE
53513: LD_INT 1
53515: DEC
53516: ST_TO_ADDR
53517: LD_EXP 93
53521: PUSH
53522: FOR_TO
53523: IFFALSE 53610
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
53525: LD_VAR 0 1
53529: PUSH
53530: LD_EXP 101
53534: PUSH
53535: LD_VAR 0 4
53539: ARRAY
53540: IN
53541: PUSH
53542: LD_VAR 0 1
53546: PUSH
53547: LD_EXP 102
53551: PUSH
53552: LD_VAR 0 4
53556: ARRAY
53557: IN
53558: NOT
53559: AND
53560: IFFALSE 53608
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53562: LD_ADDR_EXP 102
53566: PUSH
53567: LD_EXP 102
53571: PPUSH
53572: LD_VAR 0 4
53576: PUSH
53577: LD_EXP 102
53581: PUSH
53582: LD_VAR 0 4
53586: ARRAY
53587: PUSH
53588: LD_INT 1
53590: PLUS
53591: PUSH
53592: EMPTY
53593: LIST
53594: LIST
53595: PPUSH
53596: LD_VAR 0 1
53600: PPUSH
53601: CALL 60598 0 3
53605: ST_TO_ADDR
// break ;
53606: GO 53610
// end ; end ;
53608: GO 53522
53610: POP
53611: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53612: LD_VAR 0 1
53616: PPUSH
53617: CALL_OW 257
53621: PUSH
53622: LD_EXP 119
53626: IN
53627: PUSH
53628: LD_VAR 0 1
53632: PPUSH
53633: CALL_OW 266
53637: PUSH
53638: LD_INT 5
53640: EQUAL
53641: AND
53642: PUSH
53643: LD_VAR 0 2
53647: PPUSH
53648: CALL_OW 110
53652: PUSH
53653: LD_INT 18
53655: NONEQUAL
53656: AND
53657: IFFALSE 53697
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53659: LD_VAR 0 2
53663: PPUSH
53664: CALL_OW 257
53668: PUSH
53669: LD_INT 5
53671: PUSH
53672: LD_INT 8
53674: PUSH
53675: LD_INT 9
53677: PUSH
53678: EMPTY
53679: LIST
53680: LIST
53681: LIST
53682: IN
53683: IFFALSE 53697
// SetClass ( unit , 1 ) ;
53685: LD_VAR 0 2
53689: PPUSH
53690: LD_INT 1
53692: PPUSH
53693: CALL_OW 336
// end ;
53697: LD_VAR 0 3
53701: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53702: LD_INT 0
53704: PPUSH
53705: PPUSH
// if not mc_bases or not skirmish then
53706: LD_EXP 93
53710: NOT
53711: PUSH
53712: LD_EXP 91
53716: NOT
53717: OR
53718: IFFALSE 53722
// exit ;
53720: GO 53838
// if GetLives ( abandoned_vehicle ) > 250 then
53722: LD_VAR 0 2
53726: PPUSH
53727: CALL_OW 256
53731: PUSH
53732: LD_INT 250
53734: GREATER
53735: IFFALSE 53739
// exit ;
53737: GO 53838
// for i = 1 to mc_bases do
53739: LD_ADDR_VAR 0 6
53743: PUSH
53744: DOUBLE
53745: LD_INT 1
53747: DEC
53748: ST_TO_ADDR
53749: LD_EXP 93
53753: PUSH
53754: FOR_TO
53755: IFFALSE 53836
// begin if driver in mc_bases [ i ] then
53757: LD_VAR 0 1
53761: PUSH
53762: LD_EXP 93
53766: PUSH
53767: LD_VAR 0 6
53771: ARRAY
53772: IN
53773: IFFALSE 53834
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53775: LD_VAR 0 1
53779: PPUSH
53780: LD_EXP 93
53784: PUSH
53785: LD_VAR 0 6
53789: ARRAY
53790: PPUSH
53791: LD_INT 2
53793: PUSH
53794: LD_INT 30
53796: PUSH
53797: LD_INT 0
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: PUSH
53804: LD_INT 30
53806: PUSH
53807: LD_INT 1
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: LIST
53818: PPUSH
53819: CALL_OW 72
53823: PUSH
53824: LD_INT 1
53826: ARRAY
53827: PPUSH
53828: CALL_OW 112
// break ;
53832: GO 53836
// end ; end ;
53834: GO 53754
53836: POP
53837: POP
// end ; end_of_file
53838: LD_VAR 0 5
53842: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53843: LD_INT 0
53845: PPUSH
53846: PPUSH
// if exist_mode then
53847: LD_VAR 0 2
53851: IFFALSE 53876
// unit := CreateCharacter ( prefix & ident ) else
53853: LD_ADDR_VAR 0 5
53857: PUSH
53858: LD_VAR 0 3
53862: PUSH
53863: LD_VAR 0 1
53867: STR
53868: PPUSH
53869: CALL_OW 34
53873: ST_TO_ADDR
53874: GO 53891
// unit := NewCharacter ( ident ) ;
53876: LD_ADDR_VAR 0 5
53880: PUSH
53881: LD_VAR 0 1
53885: PPUSH
53886: CALL_OW 25
53890: ST_TO_ADDR
// result := unit ;
53891: LD_ADDR_VAR 0 4
53895: PUSH
53896: LD_VAR 0 5
53900: ST_TO_ADDR
// end ;
53901: LD_VAR 0 4
53905: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53906: LD_INT 0
53908: PPUSH
53909: PPUSH
// if not side or not nation then
53910: LD_VAR 0 1
53914: NOT
53915: PUSH
53916: LD_VAR 0 2
53920: NOT
53921: OR
53922: IFFALSE 53926
// exit ;
53924: GO 54562
// case nation of nation_american :
53926: LD_VAR 0 2
53930: PUSH
53931: LD_INT 1
53933: DOUBLE
53934: EQUAL
53935: IFTRUE 53939
53937: GO 54109
53939: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
53940: LD_ADDR_VAR 0 4
53944: PUSH
53945: LD_INT 35
53947: PUSH
53948: LD_INT 45
53950: PUSH
53951: LD_INT 46
53953: PUSH
53954: LD_INT 47
53956: PUSH
53957: LD_INT 1
53959: PUSH
53960: LD_INT 2
53962: PUSH
53963: LD_INT 6
53965: PUSH
53966: LD_INT 15
53968: PUSH
53969: LD_INT 16
53971: PUSH
53972: LD_INT 7
53974: PUSH
53975: LD_INT 12
53977: PUSH
53978: LD_INT 13
53980: PUSH
53981: LD_INT 10
53983: PUSH
53984: LD_INT 14
53986: PUSH
53987: LD_INT 20
53989: PUSH
53990: LD_INT 21
53992: PUSH
53993: LD_INT 22
53995: PUSH
53996: LD_INT 25
53998: PUSH
53999: LD_INT 32
54001: PUSH
54002: LD_INT 27
54004: PUSH
54005: LD_INT 36
54007: PUSH
54008: LD_INT 69
54010: PUSH
54011: LD_INT 39
54013: PUSH
54014: LD_INT 34
54016: PUSH
54017: LD_INT 40
54019: PUSH
54020: LD_INT 48
54022: PUSH
54023: LD_INT 49
54025: PUSH
54026: LD_INT 50
54028: PUSH
54029: LD_INT 51
54031: PUSH
54032: LD_INT 52
54034: PUSH
54035: LD_INT 53
54037: PUSH
54038: LD_INT 54
54040: PUSH
54041: LD_INT 55
54043: PUSH
54044: LD_INT 56
54046: PUSH
54047: LD_INT 57
54049: PUSH
54050: LD_INT 58
54052: PUSH
54053: LD_INT 59
54055: PUSH
54056: LD_INT 60
54058: PUSH
54059: LD_INT 61
54061: PUSH
54062: LD_INT 62
54064: PUSH
54065: EMPTY
54066: LIST
54067: LIST
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: LIST
54074: LIST
54075: LIST
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: LIST
54081: LIST
54082: LIST
54083: LIST
54084: LIST
54085: LIST
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: LIST
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: ST_TO_ADDR
54107: GO 54486
54109: LD_INT 2
54111: DOUBLE
54112: EQUAL
54113: IFTRUE 54117
54115: GO 54295
54117: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
54118: LD_ADDR_VAR 0 4
54122: PUSH
54123: LD_INT 35
54125: PUSH
54126: LD_INT 45
54128: PUSH
54129: LD_INT 46
54131: PUSH
54132: LD_INT 47
54134: PUSH
54135: LD_INT 70
54137: PUSH
54138: LD_INT 1
54140: PUSH
54141: LD_INT 11
54143: PUSH
54144: LD_INT 3
54146: PUSH
54147: LD_INT 4
54149: PUSH
54150: LD_INT 5
54152: PUSH
54153: LD_INT 6
54155: PUSH
54156: LD_INT 15
54158: PUSH
54159: LD_INT 18
54161: PUSH
54162: LD_INT 7
54164: PUSH
54165: LD_INT 17
54167: PUSH
54168: LD_INT 8
54170: PUSH
54171: LD_INT 20
54173: PUSH
54174: LD_INT 21
54176: PUSH
54177: LD_INT 22
54179: PUSH
54180: LD_INT 72
54182: PUSH
54183: LD_INT 26
54185: PUSH
54186: LD_INT 69
54188: PUSH
54189: LD_INT 39
54191: PUSH
54192: LD_INT 40
54194: PUSH
54195: LD_INT 41
54197: PUSH
54198: LD_INT 42
54200: PUSH
54201: LD_INT 43
54203: PUSH
54204: LD_INT 48
54206: PUSH
54207: LD_INT 49
54209: PUSH
54210: LD_INT 50
54212: PUSH
54213: LD_INT 51
54215: PUSH
54216: LD_INT 52
54218: PUSH
54219: LD_INT 53
54221: PUSH
54222: LD_INT 54
54224: PUSH
54225: LD_INT 55
54227: PUSH
54228: LD_INT 56
54230: PUSH
54231: LD_INT 60
54233: PUSH
54234: LD_INT 61
54236: PUSH
54237: LD_INT 62
54239: PUSH
54240: LD_INT 66
54242: PUSH
54243: LD_INT 67
54245: PUSH
54246: LD_INT 68
54248: PUSH
54249: EMPTY
54250: LIST
54251: LIST
54252: LIST
54253: LIST
54254: LIST
54255: LIST
54256: LIST
54257: LIST
54258: LIST
54259: LIST
54260: LIST
54261: LIST
54262: LIST
54263: LIST
54264: LIST
54265: LIST
54266: LIST
54267: LIST
54268: LIST
54269: LIST
54270: LIST
54271: LIST
54272: LIST
54273: LIST
54274: LIST
54275: LIST
54276: LIST
54277: LIST
54278: LIST
54279: LIST
54280: LIST
54281: LIST
54282: LIST
54283: LIST
54284: LIST
54285: LIST
54286: LIST
54287: LIST
54288: LIST
54289: LIST
54290: LIST
54291: LIST
54292: ST_TO_ADDR
54293: GO 54486
54295: LD_INT 3
54297: DOUBLE
54298: EQUAL
54299: IFTRUE 54303
54301: GO 54485
54303: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
54304: LD_ADDR_VAR 0 4
54308: PUSH
54309: LD_INT 46
54311: PUSH
54312: LD_INT 47
54314: PUSH
54315: LD_INT 1
54317: PUSH
54318: LD_INT 2
54320: PUSH
54321: LD_INT 11
54323: PUSH
54324: LD_INT 9
54326: PUSH
54327: LD_INT 20
54329: PUSH
54330: LD_INT 19
54332: PUSH
54333: LD_INT 21
54335: PUSH
54336: LD_INT 24
54338: PUSH
54339: LD_INT 22
54341: PUSH
54342: LD_INT 25
54344: PUSH
54345: LD_INT 28
54347: PUSH
54348: LD_INT 29
54350: PUSH
54351: LD_INT 30
54353: PUSH
54354: LD_INT 31
54356: PUSH
54357: LD_INT 37
54359: PUSH
54360: LD_INT 38
54362: PUSH
54363: LD_INT 32
54365: PUSH
54366: LD_INT 27
54368: PUSH
54369: LD_INT 33
54371: PUSH
54372: LD_INT 69
54374: PUSH
54375: LD_INT 39
54377: PUSH
54378: LD_INT 34
54380: PUSH
54381: LD_INT 40
54383: PUSH
54384: LD_INT 71
54386: PUSH
54387: LD_INT 23
54389: PUSH
54390: LD_INT 44
54392: PUSH
54393: LD_INT 48
54395: PUSH
54396: LD_INT 49
54398: PUSH
54399: LD_INT 50
54401: PUSH
54402: LD_INT 51
54404: PUSH
54405: LD_INT 52
54407: PUSH
54408: LD_INT 53
54410: PUSH
54411: LD_INT 54
54413: PUSH
54414: LD_INT 55
54416: PUSH
54417: LD_INT 56
54419: PUSH
54420: LD_INT 57
54422: PUSH
54423: LD_INT 58
54425: PUSH
54426: LD_INT 59
54428: PUSH
54429: LD_INT 63
54431: PUSH
54432: LD_INT 64
54434: PUSH
54435: LD_INT 65
54437: PUSH
54438: EMPTY
54439: LIST
54440: LIST
54441: LIST
54442: LIST
54443: LIST
54444: LIST
54445: LIST
54446: LIST
54447: LIST
54448: LIST
54449: LIST
54450: LIST
54451: LIST
54452: LIST
54453: LIST
54454: LIST
54455: LIST
54456: LIST
54457: LIST
54458: LIST
54459: LIST
54460: LIST
54461: LIST
54462: LIST
54463: LIST
54464: LIST
54465: LIST
54466: LIST
54467: LIST
54468: LIST
54469: LIST
54470: LIST
54471: LIST
54472: LIST
54473: LIST
54474: LIST
54475: LIST
54476: LIST
54477: LIST
54478: LIST
54479: LIST
54480: LIST
54481: LIST
54482: ST_TO_ADDR
54483: GO 54486
54485: POP
// if state > - 1 and state < 3 then
54486: LD_VAR 0 3
54490: PUSH
54491: LD_INT 1
54493: NEG
54494: GREATER
54495: PUSH
54496: LD_VAR 0 3
54500: PUSH
54501: LD_INT 3
54503: LESS
54504: AND
54505: IFFALSE 54562
// for i in result do
54507: LD_ADDR_VAR 0 5
54511: PUSH
54512: LD_VAR 0 4
54516: PUSH
54517: FOR_IN
54518: IFFALSE 54560
// if GetTech ( i , side ) <> state then
54520: LD_VAR 0 5
54524: PPUSH
54525: LD_VAR 0 1
54529: PPUSH
54530: CALL_OW 321
54534: PUSH
54535: LD_VAR 0 3
54539: NONEQUAL
54540: IFFALSE 54558
// result := result diff i ;
54542: LD_ADDR_VAR 0 4
54546: PUSH
54547: LD_VAR 0 4
54551: PUSH
54552: LD_VAR 0 5
54556: DIFF
54557: ST_TO_ADDR
54558: GO 54517
54560: POP
54561: POP
// end ;
54562: LD_VAR 0 4
54566: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54567: LD_INT 0
54569: PPUSH
54570: PPUSH
54571: PPUSH
// result := true ;
54572: LD_ADDR_VAR 0 3
54576: PUSH
54577: LD_INT 1
54579: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54580: LD_ADDR_VAR 0 5
54584: PUSH
54585: LD_VAR 0 2
54589: PPUSH
54590: CALL_OW 480
54594: ST_TO_ADDR
// if not tmp then
54595: LD_VAR 0 5
54599: NOT
54600: IFFALSE 54604
// exit ;
54602: GO 54653
// for i in tmp do
54604: LD_ADDR_VAR 0 4
54608: PUSH
54609: LD_VAR 0 5
54613: PUSH
54614: FOR_IN
54615: IFFALSE 54651
// if GetTech ( i , side ) <> state_researched then
54617: LD_VAR 0 4
54621: PPUSH
54622: LD_VAR 0 1
54626: PPUSH
54627: CALL_OW 321
54631: PUSH
54632: LD_INT 2
54634: NONEQUAL
54635: IFFALSE 54649
// begin result := false ;
54637: LD_ADDR_VAR 0 3
54641: PUSH
54642: LD_INT 0
54644: ST_TO_ADDR
// exit ;
54645: POP
54646: POP
54647: GO 54653
// end ;
54649: GO 54614
54651: POP
54652: POP
// end ;
54653: LD_VAR 0 3
54657: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54658: LD_INT 0
54660: PPUSH
54661: PPUSH
54662: PPUSH
54663: PPUSH
54664: PPUSH
54665: PPUSH
54666: PPUSH
54667: PPUSH
54668: PPUSH
54669: PPUSH
54670: PPUSH
54671: PPUSH
54672: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54673: LD_VAR 0 1
54677: NOT
54678: PUSH
54679: LD_VAR 0 1
54683: PPUSH
54684: CALL_OW 257
54688: PUSH
54689: LD_INT 9
54691: NONEQUAL
54692: OR
54693: IFFALSE 54697
// exit ;
54695: GO 55270
// side := GetSide ( unit ) ;
54697: LD_ADDR_VAR 0 9
54701: PUSH
54702: LD_VAR 0 1
54706: PPUSH
54707: CALL_OW 255
54711: ST_TO_ADDR
// tech_space := tech_spacanom ;
54712: LD_ADDR_VAR 0 12
54716: PUSH
54717: LD_INT 29
54719: ST_TO_ADDR
// tech_time := tech_taurad ;
54720: LD_ADDR_VAR 0 13
54724: PUSH
54725: LD_INT 28
54727: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54728: LD_ADDR_VAR 0 11
54732: PUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: CALL_OW 310
54742: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54743: LD_VAR 0 11
54747: PPUSH
54748: CALL_OW 247
54752: PUSH
54753: LD_INT 2
54755: EQUAL
54756: IFFALSE 54760
// exit ;
54758: GO 55270
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54760: LD_ADDR_VAR 0 8
54764: PUSH
54765: LD_INT 81
54767: PUSH
54768: LD_VAR 0 9
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PUSH
54777: LD_INT 3
54779: PUSH
54780: LD_INT 21
54782: PUSH
54783: LD_INT 3
54785: PUSH
54786: EMPTY
54787: LIST
54788: LIST
54789: PUSH
54790: EMPTY
54791: LIST
54792: LIST
54793: PUSH
54794: EMPTY
54795: LIST
54796: LIST
54797: PPUSH
54798: CALL_OW 69
54802: ST_TO_ADDR
// if not tmp then
54803: LD_VAR 0 8
54807: NOT
54808: IFFALSE 54812
// exit ;
54810: GO 55270
// if in_unit then
54812: LD_VAR 0 11
54816: IFFALSE 54840
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54818: LD_ADDR_VAR 0 10
54822: PUSH
54823: LD_VAR 0 8
54827: PPUSH
54828: LD_VAR 0 11
54832: PPUSH
54833: CALL_OW 74
54837: ST_TO_ADDR
54838: GO 54860
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54840: LD_ADDR_VAR 0 10
54844: PUSH
54845: LD_VAR 0 8
54849: PPUSH
54850: LD_VAR 0 1
54854: PPUSH
54855: CALL_OW 74
54859: ST_TO_ADDR
// if not enemy then
54860: LD_VAR 0 10
54864: NOT
54865: IFFALSE 54869
// exit ;
54867: GO 55270
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54869: LD_VAR 0 11
54873: PUSH
54874: LD_VAR 0 11
54878: PPUSH
54879: LD_VAR 0 10
54883: PPUSH
54884: CALL_OW 296
54888: PUSH
54889: LD_INT 13
54891: GREATER
54892: AND
54893: PUSH
54894: LD_VAR 0 1
54898: PPUSH
54899: LD_VAR 0 10
54903: PPUSH
54904: CALL_OW 296
54908: PUSH
54909: LD_INT 12
54911: GREATER
54912: OR
54913: IFFALSE 54917
// exit ;
54915: GO 55270
// missile := [ 1 ] ;
54917: LD_ADDR_VAR 0 14
54921: PUSH
54922: LD_INT 1
54924: PUSH
54925: EMPTY
54926: LIST
54927: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54928: LD_VAR 0 9
54932: PPUSH
54933: LD_VAR 0 12
54937: PPUSH
54938: CALL_OW 325
54942: IFFALSE 54971
// missile := Insert ( missile , missile + 1 , 2 ) ;
54944: LD_ADDR_VAR 0 14
54948: PUSH
54949: LD_VAR 0 14
54953: PPUSH
54954: LD_VAR 0 14
54958: PUSH
54959: LD_INT 1
54961: PLUS
54962: PPUSH
54963: LD_INT 2
54965: PPUSH
54966: CALL_OW 2
54970: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54971: LD_VAR 0 9
54975: PPUSH
54976: LD_VAR 0 13
54980: PPUSH
54981: CALL_OW 325
54985: PUSH
54986: LD_VAR 0 10
54990: PPUSH
54991: CALL_OW 255
54995: PPUSH
54996: LD_VAR 0 13
55000: PPUSH
55001: CALL_OW 325
55005: NOT
55006: AND
55007: IFFALSE 55036
// missile := Insert ( missile , missile + 1 , 3 ) ;
55009: LD_ADDR_VAR 0 14
55013: PUSH
55014: LD_VAR 0 14
55018: PPUSH
55019: LD_VAR 0 14
55023: PUSH
55024: LD_INT 1
55026: PLUS
55027: PPUSH
55028: LD_INT 3
55030: PPUSH
55031: CALL_OW 2
55035: ST_TO_ADDR
// if missile < 2 then
55036: LD_VAR 0 14
55040: PUSH
55041: LD_INT 2
55043: LESS
55044: IFFALSE 55048
// exit ;
55046: GO 55270
// x := GetX ( enemy ) ;
55048: LD_ADDR_VAR 0 4
55052: PUSH
55053: LD_VAR 0 10
55057: PPUSH
55058: CALL_OW 250
55062: ST_TO_ADDR
// y := GetY ( enemy ) ;
55063: LD_ADDR_VAR 0 5
55067: PUSH
55068: LD_VAR 0 10
55072: PPUSH
55073: CALL_OW 251
55077: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
55078: LD_ADDR_VAR 0 6
55082: PUSH
55083: LD_VAR 0 4
55087: PUSH
55088: LD_INT 1
55090: NEG
55091: PPUSH
55092: LD_INT 1
55094: PPUSH
55095: CALL_OW 12
55099: PLUS
55100: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
55101: LD_ADDR_VAR 0 7
55105: PUSH
55106: LD_VAR 0 5
55110: PUSH
55111: LD_INT 1
55113: NEG
55114: PPUSH
55115: LD_INT 1
55117: PPUSH
55118: CALL_OW 12
55122: PLUS
55123: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55124: LD_VAR 0 6
55128: PPUSH
55129: LD_VAR 0 7
55133: PPUSH
55134: CALL_OW 488
55138: NOT
55139: IFFALSE 55161
// begin _x := x ;
55141: LD_ADDR_VAR 0 6
55145: PUSH
55146: LD_VAR 0 4
55150: ST_TO_ADDR
// _y := y ;
55151: LD_ADDR_VAR 0 7
55155: PUSH
55156: LD_VAR 0 5
55160: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
55161: LD_ADDR_VAR 0 3
55165: PUSH
55166: LD_INT 1
55168: PPUSH
55169: LD_VAR 0 14
55173: PPUSH
55174: CALL_OW 12
55178: ST_TO_ADDR
// case i of 1 :
55179: LD_VAR 0 3
55183: PUSH
55184: LD_INT 1
55186: DOUBLE
55187: EQUAL
55188: IFTRUE 55192
55190: GO 55209
55192: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
55193: LD_VAR 0 1
55197: PPUSH
55198: LD_VAR 0 10
55202: PPUSH
55203: CALL_OW 115
55207: GO 55270
55209: LD_INT 2
55211: DOUBLE
55212: EQUAL
55213: IFTRUE 55217
55215: GO 55239
55217: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
55218: LD_VAR 0 1
55222: PPUSH
55223: LD_VAR 0 6
55227: PPUSH
55228: LD_VAR 0 7
55232: PPUSH
55233: CALL_OW 153
55237: GO 55270
55239: LD_INT 3
55241: DOUBLE
55242: EQUAL
55243: IFTRUE 55247
55245: GO 55269
55247: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
55248: LD_VAR 0 1
55252: PPUSH
55253: LD_VAR 0 6
55257: PPUSH
55258: LD_VAR 0 7
55262: PPUSH
55263: CALL_OW 154
55267: GO 55270
55269: POP
// end ;
55270: LD_VAR 0 2
55274: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
55275: LD_INT 0
55277: PPUSH
55278: PPUSH
55279: PPUSH
55280: PPUSH
55281: PPUSH
55282: PPUSH
// if not unit or not building then
55283: LD_VAR 0 1
55287: NOT
55288: PUSH
55289: LD_VAR 0 2
55293: NOT
55294: OR
55295: IFFALSE 55299
// exit ;
55297: GO 55457
// x := GetX ( building ) ;
55299: LD_ADDR_VAR 0 5
55303: PUSH
55304: LD_VAR 0 2
55308: PPUSH
55309: CALL_OW 250
55313: ST_TO_ADDR
// y := GetY ( building ) ;
55314: LD_ADDR_VAR 0 6
55318: PUSH
55319: LD_VAR 0 2
55323: PPUSH
55324: CALL_OW 251
55328: ST_TO_ADDR
// for i = 0 to 5 do
55329: LD_ADDR_VAR 0 4
55333: PUSH
55334: DOUBLE
55335: LD_INT 0
55337: DEC
55338: ST_TO_ADDR
55339: LD_INT 5
55341: PUSH
55342: FOR_TO
55343: IFFALSE 55455
// begin _x := ShiftX ( x , i , 3 ) ;
55345: LD_ADDR_VAR 0 7
55349: PUSH
55350: LD_VAR 0 5
55354: PPUSH
55355: LD_VAR 0 4
55359: PPUSH
55360: LD_INT 3
55362: PPUSH
55363: CALL_OW 272
55367: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
55368: LD_ADDR_VAR 0 8
55372: PUSH
55373: LD_VAR 0 6
55377: PPUSH
55378: LD_VAR 0 4
55382: PPUSH
55383: LD_INT 3
55385: PPUSH
55386: CALL_OW 273
55390: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55391: LD_VAR 0 7
55395: PPUSH
55396: LD_VAR 0 8
55400: PPUSH
55401: CALL_OW 488
55405: NOT
55406: IFFALSE 55410
// continue ;
55408: GO 55342
// if HexInfo ( _x , _y ) = 0 then
55410: LD_VAR 0 7
55414: PPUSH
55415: LD_VAR 0 8
55419: PPUSH
55420: CALL_OW 428
55424: PUSH
55425: LD_INT 0
55427: EQUAL
55428: IFFALSE 55453
// begin ComMoveXY ( unit , _x , _y ) ;
55430: LD_VAR 0 1
55434: PPUSH
55435: LD_VAR 0 7
55439: PPUSH
55440: LD_VAR 0 8
55444: PPUSH
55445: CALL_OW 111
// exit ;
55449: POP
55450: POP
55451: GO 55457
// end ; end ;
55453: GO 55342
55455: POP
55456: POP
// end ;
55457: LD_VAR 0 3
55461: RET
// export function ScanBase ( side , base_area ) ; begin
55462: LD_INT 0
55464: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55465: LD_ADDR_VAR 0 3
55469: PUSH
55470: LD_VAR 0 2
55474: PPUSH
55475: LD_INT 81
55477: PUSH
55478: LD_VAR 0 1
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: PPUSH
55487: CALL_OW 70
55491: ST_TO_ADDR
// end ;
55492: LD_VAR 0 3
55496: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
55497: LD_INT 0
55499: PPUSH
55500: PPUSH
55501: PPUSH
55502: PPUSH
55503: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
55504: LD_VAR 0 1
55508: NOT
55509: PUSH
55510: LD_EXP 93
55514: PUSH
55515: LD_VAR 0 1
55519: ARRAY
55520: NOT
55521: OR
55522: PUSH
55523: LD_VAR 0 2
55527: NOT
55528: OR
55529: PUSH
55530: LD_VAR 0 3
55534: NOT
55535: OR
55536: IFFALSE 55540
// exit ;
55538: GO 55990
// side := mc_sides [ base ] ;
55540: LD_ADDR_VAR 0 6
55544: PUSH
55545: LD_EXP 119
55549: PUSH
55550: LD_VAR 0 1
55554: ARRAY
55555: ST_TO_ADDR
// if not side then
55556: LD_VAR 0 6
55560: NOT
55561: IFFALSE 55565
// exit ;
55563: GO 55990
// for i in solds do
55565: LD_ADDR_VAR 0 7
55569: PUSH
55570: LD_VAR 0 2
55574: PUSH
55575: FOR_IN
55576: IFFALSE 55637
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
55578: LD_VAR 0 7
55582: PPUSH
55583: CALL_OW 310
55587: PPUSH
55588: CALL_OW 266
55592: PUSH
55593: LD_INT 32
55595: PUSH
55596: LD_INT 31
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: IN
55603: IFFALSE 55623
// solds := solds diff i else
55605: LD_ADDR_VAR 0 2
55609: PUSH
55610: LD_VAR 0 2
55614: PUSH
55615: LD_VAR 0 7
55619: DIFF
55620: ST_TO_ADDR
55621: GO 55635
// SetTag ( i , 18 ) ;
55623: LD_VAR 0 7
55627: PPUSH
55628: LD_INT 18
55630: PPUSH
55631: CALL_OW 109
55635: GO 55575
55637: POP
55638: POP
// if not solds then
55639: LD_VAR 0 2
55643: NOT
55644: IFFALSE 55648
// exit ;
55646: GO 55990
// repeat wait ( 0 0$1 ) ;
55648: LD_INT 35
55650: PPUSH
55651: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
55655: LD_ADDR_VAR 0 5
55659: PUSH
55660: LD_VAR 0 6
55664: PPUSH
55665: LD_VAR 0 3
55669: PPUSH
55670: CALL 55462 0 2
55674: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
55675: LD_VAR 0 5
55679: NOT
55680: PUSH
55681: LD_VAR 0 5
55685: PUSH
55686: LD_INT 3
55688: GREATER
55689: OR
55690: PUSH
55691: LD_EXP 115
55695: PUSH
55696: LD_VAR 0 1
55700: ARRAY
55701: OR
55702: IFFALSE 55743
// begin for i in solds do
55704: LD_ADDR_VAR 0 7
55708: PUSH
55709: LD_VAR 0 2
55713: PUSH
55714: FOR_IN
55715: IFFALSE 55739
// if HasTask ( i ) then
55717: LD_VAR 0 7
55721: PPUSH
55722: CALL_OW 314
55726: IFFALSE 55737
// ComStop ( i ) ;
55728: LD_VAR 0 7
55732: PPUSH
55733: CALL_OW 141
55737: GO 55714
55739: POP
55740: POP
// break ;
55741: GO 55978
// end ; for i in solds do
55743: LD_ADDR_VAR 0 7
55747: PUSH
55748: LD_VAR 0 2
55752: PUSH
55753: FOR_IN
55754: IFFALSE 55970
// begin if IsInUnit ( i ) then
55756: LD_VAR 0 7
55760: PPUSH
55761: CALL_OW 310
55765: IFFALSE 55776
// ComExitBuilding ( i ) ;
55767: LD_VAR 0 7
55771: PPUSH
55772: CALL_OW 122
// if GetLives ( i ) > 333 then
55776: LD_VAR 0 7
55780: PPUSH
55781: CALL_OW 256
55785: PUSH
55786: LD_INT 333
55788: GREATER
55789: IFFALSE 55817
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55791: LD_VAR 0 7
55795: PPUSH
55796: LD_VAR 0 5
55800: PPUSH
55801: LD_VAR 0 7
55805: PPUSH
55806: CALL_OW 74
55810: PPUSH
55811: CALL_OW 115
55815: GO 55968
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
55817: LD_ADDR_VAR 0 8
55821: PUSH
55822: LD_EXP 93
55826: PUSH
55827: LD_VAR 0 1
55831: ARRAY
55832: PPUSH
55833: LD_INT 2
55835: PUSH
55836: LD_INT 30
55838: PUSH
55839: LD_INT 0
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: PUSH
55846: LD_INT 30
55848: PUSH
55849: LD_INT 1
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: PUSH
55856: LD_INT 30
55858: PUSH
55859: LD_INT 6
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: PUSH
55866: EMPTY
55867: LIST
55868: LIST
55869: LIST
55870: LIST
55871: PPUSH
55872: CALL_OW 72
55876: PPUSH
55877: LD_VAR 0 7
55881: PPUSH
55882: CALL_OW 74
55886: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
55887: LD_VAR 0 7
55891: PPUSH
55892: LD_VAR 0 8
55896: PPUSH
55897: CALL_OW 250
55901: PPUSH
55902: LD_INT 3
55904: PPUSH
55905: LD_INT 5
55907: PPUSH
55908: CALL_OW 272
55912: PPUSH
55913: LD_VAR 0 8
55917: PPUSH
55918: CALL_OW 251
55922: PPUSH
55923: LD_INT 3
55925: PPUSH
55926: LD_INT 5
55928: PPUSH
55929: CALL_OW 273
55933: PPUSH
55934: CALL_OW 111
// SetTag ( i , 0 ) ;
55938: LD_VAR 0 7
55942: PPUSH
55943: LD_INT 0
55945: PPUSH
55946: CALL_OW 109
// solds := solds diff i ;
55950: LD_ADDR_VAR 0 2
55954: PUSH
55955: LD_VAR 0 2
55959: PUSH
55960: LD_VAR 0 7
55964: DIFF
55965: ST_TO_ADDR
// continue ;
55966: GO 55753
// end ; end ;
55968: GO 55753
55970: POP
55971: POP
// until solds ;
55972: LD_VAR 0 2
55976: IFFALSE 55648
// MC_Reset ( base , 18 ) ;
55978: LD_VAR 0 1
55982: PPUSH
55983: LD_INT 18
55985: PPUSH
55986: CALL 29070 0 2
// end ;
55990: LD_VAR 0 4
55994: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
55995: LD_INT 0
55997: PPUSH
55998: PPUSH
55999: PPUSH
56000: PPUSH
56001: PPUSH
56002: PPUSH
56003: PPUSH
56004: PPUSH
56005: PPUSH
56006: PPUSH
56007: PPUSH
56008: PPUSH
56009: PPUSH
56010: PPUSH
56011: PPUSH
56012: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56013: LD_ADDR_VAR 0 12
56017: PUSH
56018: LD_EXP 93
56022: PUSH
56023: LD_VAR 0 1
56027: ARRAY
56028: PPUSH
56029: LD_INT 25
56031: PUSH
56032: LD_INT 3
56034: PUSH
56035: EMPTY
56036: LIST
56037: LIST
56038: PPUSH
56039: CALL_OW 72
56043: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56044: LD_ADDR_VAR 0 8
56048: PUSH
56049: LD_EXP 93
56053: PUSH
56054: LD_VAR 0 1
56058: ARRAY
56059: PPUSH
56060: LD_INT 2
56062: PUSH
56063: LD_INT 25
56065: PUSH
56066: LD_INT 1
56068: PUSH
56069: EMPTY
56070: LIST
56071: LIST
56072: PUSH
56073: LD_INT 25
56075: PUSH
56076: LD_INT 5
56078: PUSH
56079: EMPTY
56080: LIST
56081: LIST
56082: PUSH
56083: LD_INT 25
56085: PUSH
56086: LD_INT 8
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: PUSH
56093: LD_INT 25
56095: PUSH
56096: LD_INT 9
56098: PUSH
56099: EMPTY
56100: LIST
56101: LIST
56102: PUSH
56103: EMPTY
56104: LIST
56105: LIST
56106: LIST
56107: LIST
56108: LIST
56109: PPUSH
56110: CALL_OW 72
56114: ST_TO_ADDR
// if not defenders and not solds then
56115: LD_VAR 0 2
56119: NOT
56120: PUSH
56121: LD_VAR 0 8
56125: NOT
56126: AND
56127: IFFALSE 56131
// exit ;
56129: GO 57497
// depot_under_attack := false ;
56131: LD_ADDR_VAR 0 16
56135: PUSH
56136: LD_INT 0
56138: ST_TO_ADDR
// sold_defenders := [ ] ;
56139: LD_ADDR_VAR 0 17
56143: PUSH
56144: EMPTY
56145: ST_TO_ADDR
// if mechs then
56146: LD_VAR 0 12
56150: IFFALSE 56279
// for i in defenders do
56152: LD_ADDR_VAR 0 5
56156: PUSH
56157: LD_VAR 0 2
56161: PUSH
56162: FOR_IN
56163: IFFALSE 56277
// begin SetTag ( i , 20 ) ;
56165: LD_VAR 0 5
56169: PPUSH
56170: LD_INT 20
56172: PPUSH
56173: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
56177: LD_VAR 0 5
56181: PPUSH
56182: CALL_OW 263
56186: PUSH
56187: LD_INT 1
56189: EQUAL
56190: PUSH
56191: LD_VAR 0 5
56195: PPUSH
56196: CALL_OW 311
56200: NOT
56201: AND
56202: PUSH
56203: LD_VAR 0 12
56207: AND
56208: IFFALSE 56275
// begin un := mechs [ 1 ] ;
56210: LD_ADDR_VAR 0 10
56214: PUSH
56215: LD_VAR 0 12
56219: PUSH
56220: LD_INT 1
56222: ARRAY
56223: ST_TO_ADDR
// ComExitBuilding ( un ) ;
56224: LD_VAR 0 10
56228: PPUSH
56229: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
56233: LD_VAR 0 10
56237: PPUSH
56238: LD_VAR 0 5
56242: PPUSH
56243: CALL_OW 180
// SetTag ( un , 19 ) ;
56247: LD_VAR 0 10
56251: PPUSH
56252: LD_INT 19
56254: PPUSH
56255: CALL_OW 109
// mechs := mechs diff un ;
56259: LD_ADDR_VAR 0 12
56263: PUSH
56264: LD_VAR 0 12
56268: PUSH
56269: LD_VAR 0 10
56273: DIFF
56274: ST_TO_ADDR
// end ; end ;
56275: GO 56162
56277: POP
56278: POP
// if solds then
56279: LD_VAR 0 8
56283: IFFALSE 56342
// for i in solds do
56285: LD_ADDR_VAR 0 5
56289: PUSH
56290: LD_VAR 0 8
56294: PUSH
56295: FOR_IN
56296: IFFALSE 56340
// if not GetTag ( i ) then
56298: LD_VAR 0 5
56302: PPUSH
56303: CALL_OW 110
56307: NOT
56308: IFFALSE 56338
// begin defenders := defenders union i ;
56310: LD_ADDR_VAR 0 2
56314: PUSH
56315: LD_VAR 0 2
56319: PUSH
56320: LD_VAR 0 5
56324: UNION
56325: ST_TO_ADDR
// SetTag ( i , 18 ) ;
56326: LD_VAR 0 5
56330: PPUSH
56331: LD_INT 18
56333: PPUSH
56334: CALL_OW 109
// end ;
56338: GO 56295
56340: POP
56341: POP
// repeat wait ( 0 0$1 ) ;
56342: LD_INT 35
56344: PPUSH
56345: CALL_OW 67
// enemy := mc_scan [ base ] ;
56349: LD_ADDR_VAR 0 3
56353: PUSH
56354: LD_EXP 116
56358: PUSH
56359: LD_VAR 0 1
56363: ARRAY
56364: ST_TO_ADDR
// for i in defenders do
56365: LD_ADDR_VAR 0 5
56369: PUSH
56370: LD_VAR 0 2
56374: PUSH
56375: FOR_IN
56376: IFFALSE 57061
// begin e := NearestUnitToUnit ( enemy , i ) ;
56378: LD_ADDR_VAR 0 13
56382: PUSH
56383: LD_VAR 0 3
56387: PPUSH
56388: LD_VAR 0 5
56392: PPUSH
56393: CALL_OW 74
56397: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
56398: LD_ADDR_VAR 0 16
56402: PUSH
56403: LD_EXP 93
56407: PUSH
56408: LD_VAR 0 1
56412: ARRAY
56413: PPUSH
56414: LD_INT 2
56416: PUSH
56417: LD_INT 30
56419: PUSH
56420: LD_INT 0
56422: PUSH
56423: EMPTY
56424: LIST
56425: LIST
56426: PUSH
56427: LD_INT 30
56429: PUSH
56430: LD_INT 1
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: PUSH
56437: EMPTY
56438: LIST
56439: LIST
56440: LIST
56441: PPUSH
56442: CALL_OW 72
56446: NOT
56447: PUSH
56448: LD_EXP 93
56452: PUSH
56453: LD_VAR 0 1
56457: ARRAY
56458: PPUSH
56459: LD_INT 2
56461: PUSH
56462: LD_INT 30
56464: PUSH
56465: LD_INT 0
56467: PUSH
56468: EMPTY
56469: LIST
56470: LIST
56471: PUSH
56472: LD_INT 30
56474: PUSH
56475: LD_INT 1
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: PUSH
56482: EMPTY
56483: LIST
56484: LIST
56485: LIST
56486: PPUSH
56487: CALL_OW 72
56491: PPUSH
56492: CALL_OW 256
56496: PUSH
56497: LD_INT 600
56499: LESS
56500: OR
56501: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
56502: LD_VAR 0 5
56506: PPUSH
56507: CALL_OW 247
56511: PUSH
56512: LD_INT 2
56514: DOUBLE
56515: EQUAL
56516: IFTRUE 56520
56518: GO 56767
56520: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
56521: LD_VAR 0 5
56525: PPUSH
56526: CALL_OW 256
56530: PUSH
56531: LD_INT 650
56533: GREATER
56534: PUSH
56535: LD_VAR 0 5
56539: PPUSH
56540: LD_VAR 0 13
56544: PPUSH
56545: CALL_OW 296
56549: PUSH
56550: LD_INT 40
56552: LESS
56553: AND
56554: IFFALSE 56572
// ComAttackUnit ( i , e ) else
56556: LD_VAR 0 5
56560: PPUSH
56561: LD_VAR 0 13
56565: PPUSH
56566: CALL_OW 115
56570: GO 56650
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
56572: LD_VAR 0 5
56576: PPUSH
56577: LD_VAR 0 13
56581: PPUSH
56582: CALL_OW 296
56586: PUSH
56587: LD_INT 30
56589: GREATEREQUAL
56590: PUSH
56591: LD_VAR 0 5
56595: PPUSH
56596: CALL_OW 256
56600: PUSH
56601: LD_INT 650
56603: LESSEQUAL
56604: OR
56605: PUSH
56606: LD_VAR 0 5
56610: PPUSH
56611: LD_EXP 117
56615: PUSH
56616: LD_VAR 0 1
56620: ARRAY
56621: PPUSH
56622: CALL_OW 308
56626: NOT
56627: AND
56628: IFFALSE 56650
// ComMoveToArea ( i , mc_parking [ base ] ) ;
56630: LD_VAR 0 5
56634: PPUSH
56635: LD_EXP 117
56639: PUSH
56640: LD_VAR 0 1
56644: ARRAY
56645: PPUSH
56646: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
56650: LD_VAR 0 5
56654: PPUSH
56655: CALL_OW 256
56659: PUSH
56660: LD_INT 998
56662: LESS
56663: PUSH
56664: LD_VAR 0 5
56668: PPUSH
56669: CALL_OW 263
56673: PUSH
56674: LD_INT 1
56676: EQUAL
56677: AND
56678: PUSH
56679: LD_VAR 0 5
56683: PPUSH
56684: CALL_OW 311
56688: AND
56689: PUSH
56690: LD_VAR 0 5
56694: PPUSH
56695: LD_EXP 117
56699: PUSH
56700: LD_VAR 0 1
56704: ARRAY
56705: PPUSH
56706: CALL_OW 308
56710: AND
56711: IFFALSE 56765
// begin mech := IsDrivenBy ( i ) ;
56713: LD_ADDR_VAR 0 9
56717: PUSH
56718: LD_VAR 0 5
56722: PPUSH
56723: CALL_OW 311
56727: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
56728: LD_VAR 0 9
56732: PPUSH
56733: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
56737: LD_VAR 0 9
56741: PPUSH
56742: LD_VAR 0 5
56746: PPUSH
56747: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
56751: LD_VAR 0 9
56755: PPUSH
56756: LD_VAR 0 5
56760: PPUSH
56761: CALL_OW 180
// end ; end ; unit_human :
56765: GO 57032
56767: LD_INT 1
56769: DOUBLE
56770: EQUAL
56771: IFTRUE 56775
56773: GO 57031
56775: POP
// begin b := IsInUnit ( i ) ;
56776: LD_ADDR_VAR 0 18
56780: PUSH
56781: LD_VAR 0 5
56785: PPUSH
56786: CALL_OW 310
56790: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
56791: LD_ADDR_VAR 0 19
56795: PUSH
56796: LD_VAR 0 18
56800: NOT
56801: PUSH
56802: LD_VAR 0 18
56806: PPUSH
56807: CALL_OW 266
56811: PUSH
56812: LD_INT 32
56814: PUSH
56815: LD_INT 31
56817: PUSH
56818: EMPTY
56819: LIST
56820: LIST
56821: IN
56822: OR
56823: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
56824: LD_VAR 0 16
56828: PUSH
56829: LD_VAR 0 2
56833: PPUSH
56834: LD_INT 21
56836: PUSH
56837: LD_INT 2
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PPUSH
56844: CALL_OW 72
56848: PUSH
56849: LD_INT 1
56851: LESSEQUAL
56852: OR
56853: PUSH
56854: LD_VAR 0 19
56858: AND
56859: PUSH
56860: LD_VAR 0 5
56864: PUSH
56865: LD_VAR 0 17
56869: IN
56870: NOT
56871: AND
56872: IFFALSE 56965
// begin if b then
56874: LD_VAR 0 18
56878: IFFALSE 56927
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
56880: LD_VAR 0 18
56884: PPUSH
56885: LD_VAR 0 3
56889: PPUSH
56890: LD_VAR 0 18
56894: PPUSH
56895: CALL_OW 74
56899: PPUSH
56900: CALL_OW 296
56904: PUSH
56905: LD_INT 10
56907: LESS
56908: PUSH
56909: LD_VAR 0 18
56913: PPUSH
56914: CALL_OW 461
56918: PUSH
56919: LD_INT 7
56921: NONEQUAL
56922: AND
56923: IFFALSE 56927
// continue ;
56925: GO 56375
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
56927: LD_ADDR_VAR 0 17
56931: PUSH
56932: LD_VAR 0 17
56936: PPUSH
56937: LD_VAR 0 17
56941: PUSH
56942: LD_INT 1
56944: PLUS
56945: PPUSH
56946: LD_VAR 0 5
56950: PPUSH
56951: CALL_OW 1
56955: ST_TO_ADDR
// ComExitBuilding ( i ) ;
56956: LD_VAR 0 5
56960: PPUSH
56961: CALL_OW 122
// end ; if sold_defenders then
56965: LD_VAR 0 17
56969: IFFALSE 57029
// if i in sold_defenders then
56971: LD_VAR 0 5
56975: PUSH
56976: LD_VAR 0 17
56980: IN
56981: IFFALSE 57029
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
56983: LD_VAR 0 5
56987: PPUSH
56988: CALL_OW 314
56992: NOT
56993: PUSH
56994: LD_VAR 0 5
56998: PPUSH
56999: LD_VAR 0 13
57003: PPUSH
57004: CALL_OW 296
57008: PUSH
57009: LD_INT 30
57011: LESS
57012: AND
57013: IFFALSE 57029
// ComAttackUnit ( i , e ) ;
57015: LD_VAR 0 5
57019: PPUSH
57020: LD_VAR 0 13
57024: PPUSH
57025: CALL_OW 115
// end ; end ; end ;
57029: GO 57032
57031: POP
// if IsDead ( i ) then
57032: LD_VAR 0 5
57036: PPUSH
57037: CALL_OW 301
57041: IFFALSE 57059
// defenders := defenders diff i ;
57043: LD_ADDR_VAR 0 2
57047: PUSH
57048: LD_VAR 0 2
57052: PUSH
57053: LD_VAR 0 5
57057: DIFF
57058: ST_TO_ADDR
// end ;
57059: GO 56375
57061: POP
57062: POP
// until not enemy or not defenders ;
57063: LD_VAR 0 3
57067: NOT
57068: PUSH
57069: LD_VAR 0 2
57073: NOT
57074: OR
57075: IFFALSE 56342
// MC_Reset ( base , 18 ) ;
57077: LD_VAR 0 1
57081: PPUSH
57082: LD_INT 18
57084: PPUSH
57085: CALL 29070 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57089: LD_ADDR_VAR 0 2
57093: PUSH
57094: LD_VAR 0 2
57098: PUSH
57099: LD_VAR 0 2
57103: PPUSH
57104: LD_INT 2
57106: PUSH
57107: LD_INT 25
57109: PUSH
57110: LD_INT 1
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: PUSH
57117: LD_INT 25
57119: PUSH
57120: LD_INT 5
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: PUSH
57127: LD_INT 25
57129: PUSH
57130: LD_INT 8
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: PUSH
57137: LD_INT 25
57139: PUSH
57140: LD_INT 9
57142: PUSH
57143: EMPTY
57144: LIST
57145: LIST
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: LIST
57151: LIST
57152: LIST
57153: PPUSH
57154: CALL_OW 72
57158: DIFF
57159: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
57160: LD_VAR 0 3
57164: NOT
57165: PUSH
57166: LD_VAR 0 2
57170: PPUSH
57171: LD_INT 21
57173: PUSH
57174: LD_INT 2
57176: PUSH
57177: EMPTY
57178: LIST
57179: LIST
57180: PPUSH
57181: CALL_OW 72
57185: AND
57186: IFFALSE 57448
// begin tmp := FilterByTag ( defenders , 19 ) ;
57188: LD_ADDR_VAR 0 11
57192: PUSH
57193: LD_VAR 0 2
57197: PPUSH
57198: LD_INT 19
57200: PPUSH
57201: CALL 93795 0 2
57205: ST_TO_ADDR
// if tmp then
57206: LD_VAR 0 11
57210: IFFALSE 57280
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
57212: LD_ADDR_VAR 0 11
57216: PUSH
57217: LD_VAR 0 11
57221: PPUSH
57222: LD_INT 25
57224: PUSH
57225: LD_INT 3
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PPUSH
57232: CALL_OW 72
57236: ST_TO_ADDR
// if tmp then
57237: LD_VAR 0 11
57241: IFFALSE 57280
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
57243: LD_ADDR_EXP 105
57247: PUSH
57248: LD_EXP 105
57252: PPUSH
57253: LD_VAR 0 1
57257: PPUSH
57258: LD_EXP 105
57262: PUSH
57263: LD_VAR 0 1
57267: ARRAY
57268: PUSH
57269: LD_VAR 0 11
57273: UNION
57274: PPUSH
57275: CALL_OW 1
57279: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
57280: LD_VAR 0 1
57284: PPUSH
57285: LD_INT 19
57287: PPUSH
57288: CALL 29070 0 2
// repeat wait ( 0 0$1 ) ;
57292: LD_INT 35
57294: PPUSH
57295: CALL_OW 67
// for i in defenders do
57299: LD_ADDR_VAR 0 5
57303: PUSH
57304: LD_VAR 0 2
57308: PUSH
57309: FOR_IN
57310: IFFALSE 57399
// begin if not IsInArea ( i , mc_parking [ base ] ) then
57312: LD_VAR 0 5
57316: PPUSH
57317: LD_EXP 117
57321: PUSH
57322: LD_VAR 0 1
57326: ARRAY
57327: PPUSH
57328: CALL_OW 308
57332: NOT
57333: IFFALSE 57357
// ComMoveToArea ( i , mc_parking [ base ] ) else
57335: LD_VAR 0 5
57339: PPUSH
57340: LD_EXP 117
57344: PUSH
57345: LD_VAR 0 1
57349: ARRAY
57350: PPUSH
57351: CALL_OW 113
57355: GO 57397
// if GetControl ( i ) = control_manual then
57357: LD_VAR 0 5
57361: PPUSH
57362: CALL_OW 263
57366: PUSH
57367: LD_INT 1
57369: EQUAL
57370: IFFALSE 57397
// if IsDrivenBy ( i ) then
57372: LD_VAR 0 5
57376: PPUSH
57377: CALL_OW 311
57381: IFFALSE 57397
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
57383: LD_VAR 0 5
57387: PPUSH
57388: CALL_OW 311
57392: PPUSH
57393: CALL_OW 121
// end ;
57397: GO 57309
57399: POP
57400: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
57401: LD_VAR 0 2
57405: PPUSH
57406: LD_INT 95
57408: PUSH
57409: LD_EXP 117
57413: PUSH
57414: LD_VAR 0 1
57418: ARRAY
57419: PUSH
57420: EMPTY
57421: LIST
57422: LIST
57423: PPUSH
57424: CALL_OW 72
57428: PUSH
57429: LD_VAR 0 2
57433: EQUAL
57434: PUSH
57435: LD_EXP 116
57439: PUSH
57440: LD_VAR 0 1
57444: ARRAY
57445: OR
57446: IFFALSE 57292
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
57448: LD_ADDR_EXP 115
57452: PUSH
57453: LD_EXP 115
57457: PPUSH
57458: LD_VAR 0 1
57462: PPUSH
57463: LD_EXP 115
57467: PUSH
57468: LD_VAR 0 1
57472: ARRAY
57473: PUSH
57474: LD_VAR 0 2
57478: UNION
57479: PPUSH
57480: CALL_OW 1
57484: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
57485: LD_VAR 0 1
57489: PPUSH
57490: LD_INT 20
57492: PPUSH
57493: CALL 29070 0 2
// end ;
57497: LD_VAR 0 4
57501: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
57502: LD_INT 0
57504: PPUSH
57505: PPUSH
57506: PPUSH
57507: PPUSH
// result := false ;
57508: LD_ADDR_VAR 0 2
57512: PUSH
57513: LD_INT 0
57515: ST_TO_ADDR
// side := GetSide ( unit ) ;
57516: LD_ADDR_VAR 0 3
57520: PUSH
57521: LD_VAR 0 1
57525: PPUSH
57526: CALL_OW 255
57530: ST_TO_ADDR
// nat := GetNation ( unit ) ;
57531: LD_ADDR_VAR 0 4
57535: PUSH
57536: LD_VAR 0 1
57540: PPUSH
57541: CALL_OW 248
57545: ST_TO_ADDR
// case nat of 1 :
57546: LD_VAR 0 4
57550: PUSH
57551: LD_INT 1
57553: DOUBLE
57554: EQUAL
57555: IFTRUE 57559
57557: GO 57570
57559: POP
// tech := tech_lassight ; 2 :
57560: LD_ADDR_VAR 0 5
57564: PUSH
57565: LD_INT 12
57567: ST_TO_ADDR
57568: GO 57609
57570: LD_INT 2
57572: DOUBLE
57573: EQUAL
57574: IFTRUE 57578
57576: GO 57589
57578: POP
// tech := tech_mortar ; 3 :
57579: LD_ADDR_VAR 0 5
57583: PUSH
57584: LD_INT 41
57586: ST_TO_ADDR
57587: GO 57609
57589: LD_INT 3
57591: DOUBLE
57592: EQUAL
57593: IFTRUE 57597
57595: GO 57608
57597: POP
// tech := tech_bazooka ; end ;
57598: LD_ADDR_VAR 0 5
57602: PUSH
57603: LD_INT 44
57605: ST_TO_ADDR
57606: GO 57609
57608: POP
// if Researched ( side , tech ) then
57609: LD_VAR 0 3
57613: PPUSH
57614: LD_VAR 0 5
57618: PPUSH
57619: CALL_OW 325
57623: IFFALSE 57650
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
57625: LD_ADDR_VAR 0 2
57629: PUSH
57630: LD_INT 5
57632: PUSH
57633: LD_INT 8
57635: PUSH
57636: LD_INT 9
57638: PUSH
57639: EMPTY
57640: LIST
57641: LIST
57642: LIST
57643: PUSH
57644: LD_VAR 0 4
57648: ARRAY
57649: ST_TO_ADDR
// end ;
57650: LD_VAR 0 2
57654: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
57655: LD_INT 0
57657: PPUSH
57658: PPUSH
57659: PPUSH
// if not mines then
57660: LD_VAR 0 2
57664: NOT
57665: IFFALSE 57669
// exit ;
57667: GO 57813
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57669: LD_ADDR_VAR 0 5
57673: PUSH
57674: LD_INT 81
57676: PUSH
57677: LD_VAR 0 1
57681: PUSH
57682: EMPTY
57683: LIST
57684: LIST
57685: PUSH
57686: LD_INT 3
57688: PUSH
57689: LD_INT 21
57691: PUSH
57692: LD_INT 3
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: PUSH
57699: EMPTY
57700: LIST
57701: LIST
57702: PUSH
57703: EMPTY
57704: LIST
57705: LIST
57706: PPUSH
57707: CALL_OW 69
57711: ST_TO_ADDR
// for i in mines do
57712: LD_ADDR_VAR 0 4
57716: PUSH
57717: LD_VAR 0 2
57721: PUSH
57722: FOR_IN
57723: IFFALSE 57811
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
57725: LD_VAR 0 4
57729: PUSH
57730: LD_INT 1
57732: ARRAY
57733: PPUSH
57734: LD_VAR 0 4
57738: PUSH
57739: LD_INT 2
57741: ARRAY
57742: PPUSH
57743: CALL_OW 458
57747: NOT
57748: IFFALSE 57752
// continue ;
57750: GO 57722
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
57752: LD_VAR 0 4
57756: PUSH
57757: LD_INT 1
57759: ARRAY
57760: PPUSH
57761: LD_VAR 0 4
57765: PUSH
57766: LD_INT 2
57768: ARRAY
57769: PPUSH
57770: CALL_OW 428
57774: PUSH
57775: LD_VAR 0 5
57779: IN
57780: IFFALSE 57809
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
57782: LD_VAR 0 4
57786: PUSH
57787: LD_INT 1
57789: ARRAY
57790: PPUSH
57791: LD_VAR 0 4
57795: PUSH
57796: LD_INT 2
57798: ARRAY
57799: PPUSH
57800: LD_VAR 0 1
57804: PPUSH
57805: CALL_OW 456
// end ;
57809: GO 57722
57811: POP
57812: POP
// end ;
57813: LD_VAR 0 3
57817: RET
// export function Count ( array ) ; var i ; begin
57818: LD_INT 0
57820: PPUSH
57821: PPUSH
// result := 0 ;
57822: LD_ADDR_VAR 0 2
57826: PUSH
57827: LD_INT 0
57829: ST_TO_ADDR
// for i in array do
57830: LD_ADDR_VAR 0 3
57834: PUSH
57835: LD_VAR 0 1
57839: PUSH
57840: FOR_IN
57841: IFFALSE 57865
// if i then
57843: LD_VAR 0 3
57847: IFFALSE 57863
// result := result + 1 ;
57849: LD_ADDR_VAR 0 2
57853: PUSH
57854: LD_VAR 0 2
57858: PUSH
57859: LD_INT 1
57861: PLUS
57862: ST_TO_ADDR
57863: GO 57840
57865: POP
57866: POP
// end ;
57867: LD_VAR 0 2
57871: RET
// export function IsEmpty ( building ) ; begin
57872: LD_INT 0
57874: PPUSH
// if not building then
57875: LD_VAR 0 1
57879: NOT
57880: IFFALSE 57884
// exit ;
57882: GO 57927
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
57884: LD_ADDR_VAR 0 2
57888: PUSH
57889: LD_VAR 0 1
57893: PUSH
57894: LD_INT 22
57896: PUSH
57897: LD_VAR 0 1
57901: PPUSH
57902: CALL_OW 255
57906: PUSH
57907: EMPTY
57908: LIST
57909: LIST
57910: PUSH
57911: LD_INT 58
57913: PUSH
57914: EMPTY
57915: LIST
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PPUSH
57921: CALL_OW 69
57925: IN
57926: ST_TO_ADDR
// end ;
57927: LD_VAR 0 2
57931: RET
// export function IsNotFull ( building ) ; begin
57932: LD_INT 0
57934: PPUSH
// if not building then
57935: LD_VAR 0 1
57939: NOT
57940: IFFALSE 57944
// exit ;
57942: GO 57963
// result := UnitsInside ( building ) < 6 ;
57944: LD_ADDR_VAR 0 2
57948: PUSH
57949: LD_VAR 0 1
57953: PPUSH
57954: CALL_OW 313
57958: PUSH
57959: LD_INT 6
57961: LESS
57962: ST_TO_ADDR
// end ;
57963: LD_VAR 0 2
57967: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
57968: LD_INT 0
57970: PPUSH
57971: PPUSH
57972: PPUSH
57973: PPUSH
// tmp := [ ] ;
57974: LD_ADDR_VAR 0 3
57978: PUSH
57979: EMPTY
57980: ST_TO_ADDR
// list := [ ] ;
57981: LD_ADDR_VAR 0 5
57985: PUSH
57986: EMPTY
57987: ST_TO_ADDR
// for i = 16 to 25 do
57988: LD_ADDR_VAR 0 4
57992: PUSH
57993: DOUBLE
57994: LD_INT 16
57996: DEC
57997: ST_TO_ADDR
57998: LD_INT 25
58000: PUSH
58001: FOR_TO
58002: IFFALSE 58075
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
58004: LD_ADDR_VAR 0 3
58008: PUSH
58009: LD_VAR 0 3
58013: PUSH
58014: LD_INT 22
58016: PUSH
58017: LD_VAR 0 1
58021: PPUSH
58022: CALL_OW 255
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PUSH
58031: LD_INT 91
58033: PUSH
58034: LD_VAR 0 1
58038: PUSH
58039: LD_INT 6
58041: PUSH
58042: EMPTY
58043: LIST
58044: LIST
58045: LIST
58046: PUSH
58047: LD_INT 30
58049: PUSH
58050: LD_VAR 0 4
58054: PUSH
58055: EMPTY
58056: LIST
58057: LIST
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: LIST
58063: PUSH
58064: EMPTY
58065: LIST
58066: PPUSH
58067: CALL_OW 69
58071: ADD
58072: ST_TO_ADDR
58073: GO 58001
58075: POP
58076: POP
// for i = 1 to tmp do
58077: LD_ADDR_VAR 0 4
58081: PUSH
58082: DOUBLE
58083: LD_INT 1
58085: DEC
58086: ST_TO_ADDR
58087: LD_VAR 0 3
58091: PUSH
58092: FOR_TO
58093: IFFALSE 58181
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
58095: LD_ADDR_VAR 0 5
58099: PUSH
58100: LD_VAR 0 5
58104: PUSH
58105: LD_VAR 0 3
58109: PUSH
58110: LD_VAR 0 4
58114: ARRAY
58115: PPUSH
58116: CALL_OW 266
58120: PUSH
58121: LD_VAR 0 3
58125: PUSH
58126: LD_VAR 0 4
58130: ARRAY
58131: PPUSH
58132: CALL_OW 250
58136: PUSH
58137: LD_VAR 0 3
58141: PUSH
58142: LD_VAR 0 4
58146: ARRAY
58147: PPUSH
58148: CALL_OW 251
58152: PUSH
58153: LD_VAR 0 3
58157: PUSH
58158: LD_VAR 0 4
58162: ARRAY
58163: PPUSH
58164: CALL_OW 254
58168: PUSH
58169: EMPTY
58170: LIST
58171: LIST
58172: LIST
58173: LIST
58174: PUSH
58175: EMPTY
58176: LIST
58177: ADD
58178: ST_TO_ADDR
58179: GO 58092
58181: POP
58182: POP
// result := list ;
58183: LD_ADDR_VAR 0 2
58187: PUSH
58188: LD_VAR 0 5
58192: ST_TO_ADDR
// end ;
58193: LD_VAR 0 2
58197: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
58198: LD_INT 0
58200: PPUSH
58201: PPUSH
58202: PPUSH
58203: PPUSH
58204: PPUSH
58205: PPUSH
58206: PPUSH
// if not factory then
58207: LD_VAR 0 1
58211: NOT
58212: IFFALSE 58216
// exit ;
58214: GO 58741
// if control = control_apeman then
58216: LD_VAR 0 4
58220: PUSH
58221: LD_INT 5
58223: EQUAL
58224: IFFALSE 58333
// begin tmp := UnitsInside ( factory ) ;
58226: LD_ADDR_VAR 0 8
58230: PUSH
58231: LD_VAR 0 1
58235: PPUSH
58236: CALL_OW 313
58240: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
58241: LD_VAR 0 8
58245: PPUSH
58246: LD_INT 25
58248: PUSH
58249: LD_INT 12
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: PPUSH
58256: CALL_OW 72
58260: NOT
58261: IFFALSE 58271
// control := control_manual ;
58263: LD_ADDR_VAR 0 4
58267: PUSH
58268: LD_INT 1
58270: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
58271: LD_ADDR_VAR 0 8
58275: PUSH
58276: LD_VAR 0 1
58280: PPUSH
58281: CALL 57968 0 1
58285: ST_TO_ADDR
// if tmp then
58286: LD_VAR 0 8
58290: IFFALSE 58333
// begin for i in tmp do
58292: LD_ADDR_VAR 0 7
58296: PUSH
58297: LD_VAR 0 8
58301: PUSH
58302: FOR_IN
58303: IFFALSE 58331
// if i [ 1 ] = b_ext_radar then
58305: LD_VAR 0 7
58309: PUSH
58310: LD_INT 1
58312: ARRAY
58313: PUSH
58314: LD_INT 20
58316: EQUAL
58317: IFFALSE 58329
// begin control := control_remote ;
58319: LD_ADDR_VAR 0 4
58323: PUSH
58324: LD_INT 2
58326: ST_TO_ADDR
// break ;
58327: GO 58331
// end ;
58329: GO 58302
58331: POP
58332: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
58333: LD_VAR 0 1
58337: PPUSH
58338: LD_VAR 0 2
58342: PPUSH
58343: LD_VAR 0 3
58347: PPUSH
58348: LD_VAR 0 4
58352: PPUSH
58353: LD_VAR 0 5
58357: PPUSH
58358: CALL_OW 448
58362: IFFALSE 58397
// begin result := [ chassis , engine , control , weapon ] ;
58364: LD_ADDR_VAR 0 6
58368: PUSH
58369: LD_VAR 0 2
58373: PUSH
58374: LD_VAR 0 3
58378: PUSH
58379: LD_VAR 0 4
58383: PUSH
58384: LD_VAR 0 5
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: LIST
58393: LIST
58394: ST_TO_ADDR
// exit ;
58395: GO 58741
// end ; _chassis := AvailableChassisList ( factory ) ;
58397: LD_ADDR_VAR 0 9
58401: PUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: CALL_OW 475
58411: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
58412: LD_ADDR_VAR 0 11
58416: PUSH
58417: LD_VAR 0 1
58421: PPUSH
58422: CALL_OW 476
58426: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
58427: LD_ADDR_VAR 0 12
58431: PUSH
58432: LD_VAR 0 1
58436: PPUSH
58437: CALL_OW 477
58441: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
58442: LD_ADDR_VAR 0 10
58446: PUSH
58447: LD_VAR 0 1
58451: PPUSH
58452: CALL_OW 478
58456: ST_TO_ADDR
// if not chassis in _chassis then
58457: LD_VAR 0 2
58461: PUSH
58462: LD_VAR 0 9
58466: IN
58467: NOT
58468: IFFALSE 58494
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
58470: LD_ADDR_VAR 0 2
58474: PUSH
58475: LD_VAR 0 9
58479: PUSH
58480: LD_INT 1
58482: PPUSH
58483: LD_VAR 0 9
58487: PPUSH
58488: CALL_OW 12
58492: ARRAY
58493: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
58494: LD_VAR 0 2
58498: PPUSH
58499: LD_VAR 0 3
58503: PPUSH
58504: CALL 58746 0 2
58508: NOT
58509: IFFALSE 58568
// repeat engine := _engine [ 1 ] ;
58511: LD_ADDR_VAR 0 3
58515: PUSH
58516: LD_VAR 0 11
58520: PUSH
58521: LD_INT 1
58523: ARRAY
58524: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
58525: LD_ADDR_VAR 0 11
58529: PUSH
58530: LD_VAR 0 11
58534: PPUSH
58535: LD_INT 1
58537: PPUSH
58538: CALL_OW 3
58542: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
58543: LD_VAR 0 2
58547: PPUSH
58548: LD_VAR 0 3
58552: PPUSH
58553: CALL 58746 0 2
58557: PUSH
58558: LD_VAR 0 11
58562: PUSH
58563: EMPTY
58564: EQUAL
58565: OR
58566: IFFALSE 58511
// if not control in _control then
58568: LD_VAR 0 4
58572: PUSH
58573: LD_VAR 0 12
58577: IN
58578: NOT
58579: IFFALSE 58605
// control := _control [ rand ( 1 , _control ) ] ;
58581: LD_ADDR_VAR 0 4
58585: PUSH
58586: LD_VAR 0 12
58590: PUSH
58591: LD_INT 1
58593: PPUSH
58594: LD_VAR 0 12
58598: PPUSH
58599: CALL_OW 12
58603: ARRAY
58604: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
58605: LD_VAR 0 2
58609: PPUSH
58610: LD_VAR 0 5
58614: PPUSH
58615: CALL 58966 0 2
58619: NOT
58620: IFFALSE 58679
// repeat weapon := _weapon [ 1 ] ;
58622: LD_ADDR_VAR 0 5
58626: PUSH
58627: LD_VAR 0 10
58631: PUSH
58632: LD_INT 1
58634: ARRAY
58635: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
58636: LD_ADDR_VAR 0 10
58640: PUSH
58641: LD_VAR 0 10
58645: PPUSH
58646: LD_INT 1
58648: PPUSH
58649: CALL_OW 3
58653: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
58654: LD_VAR 0 2
58658: PPUSH
58659: LD_VAR 0 5
58663: PPUSH
58664: CALL 58966 0 2
58668: PUSH
58669: LD_VAR 0 10
58673: PUSH
58674: EMPTY
58675: EQUAL
58676: OR
58677: IFFALSE 58622
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
58679: LD_VAR 0 1
58683: PPUSH
58684: LD_VAR 0 2
58688: PPUSH
58689: LD_VAR 0 3
58693: PPUSH
58694: LD_VAR 0 4
58698: PPUSH
58699: LD_VAR 0 5
58703: PPUSH
58704: CALL_OW 448
58708: IFFALSE 58741
// result := [ chassis , engine , control , weapon ] ;
58710: LD_ADDR_VAR 0 6
58714: PUSH
58715: LD_VAR 0 2
58719: PUSH
58720: LD_VAR 0 3
58724: PUSH
58725: LD_VAR 0 4
58729: PUSH
58730: LD_VAR 0 5
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: LIST
58739: LIST
58740: ST_TO_ADDR
// end ;
58741: LD_VAR 0 6
58745: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
58746: LD_INT 0
58748: PPUSH
// if not chassis or not engine then
58749: LD_VAR 0 1
58753: NOT
58754: PUSH
58755: LD_VAR 0 2
58759: NOT
58760: OR
58761: IFFALSE 58765
// exit ;
58763: GO 58961
// case engine of engine_solar :
58765: LD_VAR 0 2
58769: PUSH
58770: LD_INT 2
58772: DOUBLE
58773: EQUAL
58774: IFTRUE 58778
58776: GO 58816
58778: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
58779: LD_ADDR_VAR 0 3
58783: PUSH
58784: LD_INT 11
58786: PUSH
58787: LD_INT 12
58789: PUSH
58790: LD_INT 13
58792: PUSH
58793: LD_INT 14
58795: PUSH
58796: LD_INT 1
58798: PUSH
58799: LD_INT 2
58801: PUSH
58802: LD_INT 3
58804: PUSH
58805: EMPTY
58806: LIST
58807: LIST
58808: LIST
58809: LIST
58810: LIST
58811: LIST
58812: LIST
58813: ST_TO_ADDR
58814: GO 58945
58816: LD_INT 1
58818: DOUBLE
58819: EQUAL
58820: IFTRUE 58824
58822: GO 58886
58824: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
58825: LD_ADDR_VAR 0 3
58829: PUSH
58830: LD_INT 11
58832: PUSH
58833: LD_INT 12
58835: PUSH
58836: LD_INT 13
58838: PUSH
58839: LD_INT 14
58841: PUSH
58842: LD_INT 1
58844: PUSH
58845: LD_INT 2
58847: PUSH
58848: LD_INT 3
58850: PUSH
58851: LD_INT 4
58853: PUSH
58854: LD_INT 5
58856: PUSH
58857: LD_INT 21
58859: PUSH
58860: LD_INT 23
58862: PUSH
58863: LD_INT 22
58865: PUSH
58866: LD_INT 24
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: LIST
58876: LIST
58877: LIST
58878: LIST
58879: LIST
58880: LIST
58881: LIST
58882: LIST
58883: ST_TO_ADDR
58884: GO 58945
58886: LD_INT 3
58888: DOUBLE
58889: EQUAL
58890: IFTRUE 58894
58892: GO 58944
58894: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
58895: LD_ADDR_VAR 0 3
58899: PUSH
58900: LD_INT 13
58902: PUSH
58903: LD_INT 14
58905: PUSH
58906: LD_INT 2
58908: PUSH
58909: LD_INT 3
58911: PUSH
58912: LD_INT 4
58914: PUSH
58915: LD_INT 5
58917: PUSH
58918: LD_INT 21
58920: PUSH
58921: LD_INT 22
58923: PUSH
58924: LD_INT 23
58926: PUSH
58927: LD_INT 24
58929: PUSH
58930: EMPTY
58931: LIST
58932: LIST
58933: LIST
58934: LIST
58935: LIST
58936: LIST
58937: LIST
58938: LIST
58939: LIST
58940: LIST
58941: ST_TO_ADDR
58942: GO 58945
58944: POP
// result := ( chassis in result ) ;
58945: LD_ADDR_VAR 0 3
58949: PUSH
58950: LD_VAR 0 1
58954: PUSH
58955: LD_VAR 0 3
58959: IN
58960: ST_TO_ADDR
// end ;
58961: LD_VAR 0 3
58965: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
58966: LD_INT 0
58968: PPUSH
// if not chassis or not weapon then
58969: LD_VAR 0 1
58973: NOT
58974: PUSH
58975: LD_VAR 0 2
58979: NOT
58980: OR
58981: IFFALSE 58985
// exit ;
58983: GO 60011
// case weapon of us_machine_gun :
58985: LD_VAR 0 2
58989: PUSH
58990: LD_INT 2
58992: DOUBLE
58993: EQUAL
58994: IFTRUE 58998
58996: GO 59028
58998: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
58999: LD_ADDR_VAR 0 3
59003: PUSH
59004: LD_INT 1
59006: PUSH
59007: LD_INT 2
59009: PUSH
59010: LD_INT 3
59012: PUSH
59013: LD_INT 4
59015: PUSH
59016: LD_INT 5
59018: PUSH
59019: EMPTY
59020: LIST
59021: LIST
59022: LIST
59023: LIST
59024: LIST
59025: ST_TO_ADDR
59026: GO 59995
59028: LD_INT 3
59030: DOUBLE
59031: EQUAL
59032: IFTRUE 59036
59034: GO 59066
59036: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
59037: LD_ADDR_VAR 0 3
59041: PUSH
59042: LD_INT 1
59044: PUSH
59045: LD_INT 2
59047: PUSH
59048: LD_INT 3
59050: PUSH
59051: LD_INT 4
59053: PUSH
59054: LD_INT 5
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: LIST
59061: LIST
59062: LIST
59063: ST_TO_ADDR
59064: GO 59995
59066: LD_INT 11
59068: DOUBLE
59069: EQUAL
59070: IFTRUE 59074
59072: GO 59104
59074: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
59075: LD_ADDR_VAR 0 3
59079: PUSH
59080: LD_INT 1
59082: PUSH
59083: LD_INT 2
59085: PUSH
59086: LD_INT 3
59088: PUSH
59089: LD_INT 4
59091: PUSH
59092: LD_INT 5
59094: PUSH
59095: EMPTY
59096: LIST
59097: LIST
59098: LIST
59099: LIST
59100: LIST
59101: ST_TO_ADDR
59102: GO 59995
59104: LD_INT 4
59106: DOUBLE
59107: EQUAL
59108: IFTRUE 59112
59110: GO 59138
59112: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
59113: LD_ADDR_VAR 0 3
59117: PUSH
59118: LD_INT 2
59120: PUSH
59121: LD_INT 3
59123: PUSH
59124: LD_INT 4
59126: PUSH
59127: LD_INT 5
59129: PUSH
59130: EMPTY
59131: LIST
59132: LIST
59133: LIST
59134: LIST
59135: ST_TO_ADDR
59136: GO 59995
59138: LD_INT 5
59140: DOUBLE
59141: EQUAL
59142: IFTRUE 59146
59144: GO 59172
59146: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
59147: LD_ADDR_VAR 0 3
59151: PUSH
59152: LD_INT 2
59154: PUSH
59155: LD_INT 3
59157: PUSH
59158: LD_INT 4
59160: PUSH
59161: LD_INT 5
59163: PUSH
59164: EMPTY
59165: LIST
59166: LIST
59167: LIST
59168: LIST
59169: ST_TO_ADDR
59170: GO 59995
59172: LD_INT 9
59174: DOUBLE
59175: EQUAL
59176: IFTRUE 59180
59178: GO 59206
59180: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
59181: LD_ADDR_VAR 0 3
59185: PUSH
59186: LD_INT 2
59188: PUSH
59189: LD_INT 3
59191: PUSH
59192: LD_INT 4
59194: PUSH
59195: LD_INT 5
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: LIST
59202: LIST
59203: ST_TO_ADDR
59204: GO 59995
59206: LD_INT 7
59208: DOUBLE
59209: EQUAL
59210: IFTRUE 59214
59212: GO 59240
59214: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
59215: LD_ADDR_VAR 0 3
59219: PUSH
59220: LD_INT 2
59222: PUSH
59223: LD_INT 3
59225: PUSH
59226: LD_INT 4
59228: PUSH
59229: LD_INT 5
59231: PUSH
59232: EMPTY
59233: LIST
59234: LIST
59235: LIST
59236: LIST
59237: ST_TO_ADDR
59238: GO 59995
59240: LD_INT 12
59242: DOUBLE
59243: EQUAL
59244: IFTRUE 59248
59246: GO 59274
59248: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
59249: LD_ADDR_VAR 0 3
59253: PUSH
59254: LD_INT 2
59256: PUSH
59257: LD_INT 3
59259: PUSH
59260: LD_INT 4
59262: PUSH
59263: LD_INT 5
59265: PUSH
59266: EMPTY
59267: LIST
59268: LIST
59269: LIST
59270: LIST
59271: ST_TO_ADDR
59272: GO 59995
59274: LD_INT 13
59276: DOUBLE
59277: EQUAL
59278: IFTRUE 59282
59280: GO 59308
59282: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
59283: LD_ADDR_VAR 0 3
59287: PUSH
59288: LD_INT 2
59290: PUSH
59291: LD_INT 3
59293: PUSH
59294: LD_INT 4
59296: PUSH
59297: LD_INT 5
59299: PUSH
59300: EMPTY
59301: LIST
59302: LIST
59303: LIST
59304: LIST
59305: ST_TO_ADDR
59306: GO 59995
59308: LD_INT 14
59310: DOUBLE
59311: EQUAL
59312: IFTRUE 59316
59314: GO 59334
59316: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
59317: LD_ADDR_VAR 0 3
59321: PUSH
59322: LD_INT 4
59324: PUSH
59325: LD_INT 5
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: ST_TO_ADDR
59332: GO 59995
59334: LD_INT 6
59336: DOUBLE
59337: EQUAL
59338: IFTRUE 59342
59340: GO 59360
59342: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
59343: LD_ADDR_VAR 0 3
59347: PUSH
59348: LD_INT 4
59350: PUSH
59351: LD_INT 5
59353: PUSH
59354: EMPTY
59355: LIST
59356: LIST
59357: ST_TO_ADDR
59358: GO 59995
59360: LD_INT 10
59362: DOUBLE
59363: EQUAL
59364: IFTRUE 59368
59366: GO 59386
59368: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
59369: LD_ADDR_VAR 0 3
59373: PUSH
59374: LD_INT 4
59376: PUSH
59377: LD_INT 5
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: ST_TO_ADDR
59384: GO 59995
59386: LD_INT 22
59388: DOUBLE
59389: EQUAL
59390: IFTRUE 59394
59392: GO 59420
59394: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
59395: LD_ADDR_VAR 0 3
59399: PUSH
59400: LD_INT 11
59402: PUSH
59403: LD_INT 12
59405: PUSH
59406: LD_INT 13
59408: PUSH
59409: LD_INT 14
59411: PUSH
59412: EMPTY
59413: LIST
59414: LIST
59415: LIST
59416: LIST
59417: ST_TO_ADDR
59418: GO 59995
59420: LD_INT 23
59422: DOUBLE
59423: EQUAL
59424: IFTRUE 59428
59426: GO 59454
59428: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
59429: LD_ADDR_VAR 0 3
59433: PUSH
59434: LD_INT 11
59436: PUSH
59437: LD_INT 12
59439: PUSH
59440: LD_INT 13
59442: PUSH
59443: LD_INT 14
59445: PUSH
59446: EMPTY
59447: LIST
59448: LIST
59449: LIST
59450: LIST
59451: ST_TO_ADDR
59452: GO 59995
59454: LD_INT 24
59456: DOUBLE
59457: EQUAL
59458: IFTRUE 59462
59460: GO 59488
59462: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
59463: LD_ADDR_VAR 0 3
59467: PUSH
59468: LD_INT 11
59470: PUSH
59471: LD_INT 12
59473: PUSH
59474: LD_INT 13
59476: PUSH
59477: LD_INT 14
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: LIST
59484: LIST
59485: ST_TO_ADDR
59486: GO 59995
59488: LD_INT 30
59490: DOUBLE
59491: EQUAL
59492: IFTRUE 59496
59494: GO 59522
59496: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
59497: LD_ADDR_VAR 0 3
59501: PUSH
59502: LD_INT 11
59504: PUSH
59505: LD_INT 12
59507: PUSH
59508: LD_INT 13
59510: PUSH
59511: LD_INT 14
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: LIST
59518: LIST
59519: ST_TO_ADDR
59520: GO 59995
59522: LD_INT 25
59524: DOUBLE
59525: EQUAL
59526: IFTRUE 59530
59528: GO 59548
59530: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
59531: LD_ADDR_VAR 0 3
59535: PUSH
59536: LD_INT 13
59538: PUSH
59539: LD_INT 14
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: ST_TO_ADDR
59546: GO 59995
59548: LD_INT 27
59550: DOUBLE
59551: EQUAL
59552: IFTRUE 59556
59554: GO 59574
59556: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
59557: LD_ADDR_VAR 0 3
59561: PUSH
59562: LD_INT 13
59564: PUSH
59565: LD_INT 14
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: ST_TO_ADDR
59572: GO 59995
59574: LD_INT 28
59576: DOUBLE
59577: EQUAL
59578: IFTRUE 59582
59580: GO 59600
59582: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
59583: LD_ADDR_VAR 0 3
59587: PUSH
59588: LD_INT 13
59590: PUSH
59591: LD_INT 14
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: ST_TO_ADDR
59598: GO 59995
59600: LD_INT 29
59602: DOUBLE
59603: EQUAL
59604: IFTRUE 59608
59606: GO 59626
59608: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
59609: LD_ADDR_VAR 0 3
59613: PUSH
59614: LD_INT 13
59616: PUSH
59617: LD_INT 14
59619: PUSH
59620: EMPTY
59621: LIST
59622: LIST
59623: ST_TO_ADDR
59624: GO 59995
59626: LD_INT 31
59628: DOUBLE
59629: EQUAL
59630: IFTRUE 59634
59632: GO 59652
59634: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
59635: LD_ADDR_VAR 0 3
59639: PUSH
59640: LD_INT 13
59642: PUSH
59643: LD_INT 14
59645: PUSH
59646: EMPTY
59647: LIST
59648: LIST
59649: ST_TO_ADDR
59650: GO 59995
59652: LD_INT 26
59654: DOUBLE
59655: EQUAL
59656: IFTRUE 59660
59658: GO 59678
59660: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
59661: LD_ADDR_VAR 0 3
59665: PUSH
59666: LD_INT 13
59668: PUSH
59669: LD_INT 14
59671: PUSH
59672: EMPTY
59673: LIST
59674: LIST
59675: ST_TO_ADDR
59676: GO 59995
59678: LD_INT 42
59680: DOUBLE
59681: EQUAL
59682: IFTRUE 59686
59684: GO 59712
59686: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
59687: LD_ADDR_VAR 0 3
59691: PUSH
59692: LD_INT 21
59694: PUSH
59695: LD_INT 22
59697: PUSH
59698: LD_INT 23
59700: PUSH
59701: LD_INT 24
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: LIST
59708: LIST
59709: ST_TO_ADDR
59710: GO 59995
59712: LD_INT 43
59714: DOUBLE
59715: EQUAL
59716: IFTRUE 59720
59718: GO 59746
59720: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
59721: LD_ADDR_VAR 0 3
59725: PUSH
59726: LD_INT 21
59728: PUSH
59729: LD_INT 22
59731: PUSH
59732: LD_INT 23
59734: PUSH
59735: LD_INT 24
59737: PUSH
59738: EMPTY
59739: LIST
59740: LIST
59741: LIST
59742: LIST
59743: ST_TO_ADDR
59744: GO 59995
59746: LD_INT 44
59748: DOUBLE
59749: EQUAL
59750: IFTRUE 59754
59752: GO 59780
59754: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
59755: LD_ADDR_VAR 0 3
59759: PUSH
59760: LD_INT 21
59762: PUSH
59763: LD_INT 22
59765: PUSH
59766: LD_INT 23
59768: PUSH
59769: LD_INT 24
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: ST_TO_ADDR
59778: GO 59995
59780: LD_INT 45
59782: DOUBLE
59783: EQUAL
59784: IFTRUE 59788
59786: GO 59814
59788: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
59789: LD_ADDR_VAR 0 3
59793: PUSH
59794: LD_INT 21
59796: PUSH
59797: LD_INT 22
59799: PUSH
59800: LD_INT 23
59802: PUSH
59803: LD_INT 24
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: LIST
59810: LIST
59811: ST_TO_ADDR
59812: GO 59995
59814: LD_INT 49
59816: DOUBLE
59817: EQUAL
59818: IFTRUE 59822
59820: GO 59848
59822: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
59823: LD_ADDR_VAR 0 3
59827: PUSH
59828: LD_INT 21
59830: PUSH
59831: LD_INT 22
59833: PUSH
59834: LD_INT 23
59836: PUSH
59837: LD_INT 24
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: LIST
59844: LIST
59845: ST_TO_ADDR
59846: GO 59995
59848: LD_INT 51
59850: DOUBLE
59851: EQUAL
59852: IFTRUE 59856
59854: GO 59882
59856: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
59857: LD_ADDR_VAR 0 3
59861: PUSH
59862: LD_INT 21
59864: PUSH
59865: LD_INT 22
59867: PUSH
59868: LD_INT 23
59870: PUSH
59871: LD_INT 24
59873: PUSH
59874: EMPTY
59875: LIST
59876: LIST
59877: LIST
59878: LIST
59879: ST_TO_ADDR
59880: GO 59995
59882: LD_INT 52
59884: DOUBLE
59885: EQUAL
59886: IFTRUE 59890
59888: GO 59916
59890: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
59891: LD_ADDR_VAR 0 3
59895: PUSH
59896: LD_INT 21
59898: PUSH
59899: LD_INT 22
59901: PUSH
59902: LD_INT 23
59904: PUSH
59905: LD_INT 24
59907: PUSH
59908: EMPTY
59909: LIST
59910: LIST
59911: LIST
59912: LIST
59913: ST_TO_ADDR
59914: GO 59995
59916: LD_INT 53
59918: DOUBLE
59919: EQUAL
59920: IFTRUE 59924
59922: GO 59942
59924: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
59925: LD_ADDR_VAR 0 3
59929: PUSH
59930: LD_INT 23
59932: PUSH
59933: LD_INT 24
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: ST_TO_ADDR
59940: GO 59995
59942: LD_INT 46
59944: DOUBLE
59945: EQUAL
59946: IFTRUE 59950
59948: GO 59968
59950: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
59951: LD_ADDR_VAR 0 3
59955: PUSH
59956: LD_INT 23
59958: PUSH
59959: LD_INT 24
59961: PUSH
59962: EMPTY
59963: LIST
59964: LIST
59965: ST_TO_ADDR
59966: GO 59995
59968: LD_INT 47
59970: DOUBLE
59971: EQUAL
59972: IFTRUE 59976
59974: GO 59994
59976: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
59977: LD_ADDR_VAR 0 3
59981: PUSH
59982: LD_INT 23
59984: PUSH
59985: LD_INT 24
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: ST_TO_ADDR
59992: GO 59995
59994: POP
// result := ( chassis in result ) ;
59995: LD_ADDR_VAR 0 3
59999: PUSH
60000: LD_VAR 0 1
60004: PUSH
60005: LD_VAR 0 3
60009: IN
60010: ST_TO_ADDR
// end ;
60011: LD_VAR 0 3
60015: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
60016: LD_INT 0
60018: PPUSH
60019: PPUSH
60020: PPUSH
60021: PPUSH
60022: PPUSH
60023: PPUSH
60024: PPUSH
// result := array ;
60025: LD_ADDR_VAR 0 5
60029: PUSH
60030: LD_VAR 0 1
60034: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
60035: LD_VAR 0 1
60039: NOT
60040: PUSH
60041: LD_VAR 0 2
60045: NOT
60046: OR
60047: PUSH
60048: LD_VAR 0 3
60052: NOT
60053: OR
60054: PUSH
60055: LD_VAR 0 2
60059: PUSH
60060: LD_VAR 0 1
60064: GREATER
60065: OR
60066: PUSH
60067: LD_VAR 0 3
60071: PUSH
60072: LD_VAR 0 1
60076: GREATER
60077: OR
60078: IFFALSE 60082
// exit ;
60080: GO 60378
// if direction then
60082: LD_VAR 0 4
60086: IFFALSE 60150
// begin d := 1 ;
60088: LD_ADDR_VAR 0 9
60092: PUSH
60093: LD_INT 1
60095: ST_TO_ADDR
// if i_from > i_to then
60096: LD_VAR 0 2
60100: PUSH
60101: LD_VAR 0 3
60105: GREATER
60106: IFFALSE 60132
// length := ( array - i_from ) + i_to else
60108: LD_ADDR_VAR 0 11
60112: PUSH
60113: LD_VAR 0 1
60117: PUSH
60118: LD_VAR 0 2
60122: MINUS
60123: PUSH
60124: LD_VAR 0 3
60128: PLUS
60129: ST_TO_ADDR
60130: GO 60148
// length := i_to - i_from ;
60132: LD_ADDR_VAR 0 11
60136: PUSH
60137: LD_VAR 0 3
60141: PUSH
60142: LD_VAR 0 2
60146: MINUS
60147: ST_TO_ADDR
// end else
60148: GO 60211
// begin d := - 1 ;
60150: LD_ADDR_VAR 0 9
60154: PUSH
60155: LD_INT 1
60157: NEG
60158: ST_TO_ADDR
// if i_from > i_to then
60159: LD_VAR 0 2
60163: PUSH
60164: LD_VAR 0 3
60168: GREATER
60169: IFFALSE 60189
// length := i_from - i_to else
60171: LD_ADDR_VAR 0 11
60175: PUSH
60176: LD_VAR 0 2
60180: PUSH
60181: LD_VAR 0 3
60185: MINUS
60186: ST_TO_ADDR
60187: GO 60211
// length := ( array - i_to ) + i_from ;
60189: LD_ADDR_VAR 0 11
60193: PUSH
60194: LD_VAR 0 1
60198: PUSH
60199: LD_VAR 0 3
60203: MINUS
60204: PUSH
60205: LD_VAR 0 2
60209: PLUS
60210: ST_TO_ADDR
// end ; if not length then
60211: LD_VAR 0 11
60215: NOT
60216: IFFALSE 60220
// exit ;
60218: GO 60378
// tmp := array ;
60220: LD_ADDR_VAR 0 10
60224: PUSH
60225: LD_VAR 0 1
60229: ST_TO_ADDR
// for i = 1 to length do
60230: LD_ADDR_VAR 0 6
60234: PUSH
60235: DOUBLE
60236: LD_INT 1
60238: DEC
60239: ST_TO_ADDR
60240: LD_VAR 0 11
60244: PUSH
60245: FOR_TO
60246: IFFALSE 60366
// begin for j = 1 to array do
60248: LD_ADDR_VAR 0 7
60252: PUSH
60253: DOUBLE
60254: LD_INT 1
60256: DEC
60257: ST_TO_ADDR
60258: LD_VAR 0 1
60262: PUSH
60263: FOR_TO
60264: IFFALSE 60352
// begin k := j + d ;
60266: LD_ADDR_VAR 0 8
60270: PUSH
60271: LD_VAR 0 7
60275: PUSH
60276: LD_VAR 0 9
60280: PLUS
60281: ST_TO_ADDR
// if k > array then
60282: LD_VAR 0 8
60286: PUSH
60287: LD_VAR 0 1
60291: GREATER
60292: IFFALSE 60302
// k := 1 ;
60294: LD_ADDR_VAR 0 8
60298: PUSH
60299: LD_INT 1
60301: ST_TO_ADDR
// if not k then
60302: LD_VAR 0 8
60306: NOT
60307: IFFALSE 60319
// k := array ;
60309: LD_ADDR_VAR 0 8
60313: PUSH
60314: LD_VAR 0 1
60318: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
60319: LD_ADDR_VAR 0 10
60323: PUSH
60324: LD_VAR 0 10
60328: PPUSH
60329: LD_VAR 0 8
60333: PPUSH
60334: LD_VAR 0 1
60338: PUSH
60339: LD_VAR 0 7
60343: ARRAY
60344: PPUSH
60345: CALL_OW 1
60349: ST_TO_ADDR
// end ;
60350: GO 60263
60352: POP
60353: POP
// array := tmp ;
60354: LD_ADDR_VAR 0 1
60358: PUSH
60359: LD_VAR 0 10
60363: ST_TO_ADDR
// end ;
60364: GO 60245
60366: POP
60367: POP
// result := array ;
60368: LD_ADDR_VAR 0 5
60372: PUSH
60373: LD_VAR 0 1
60377: ST_TO_ADDR
// end ;
60378: LD_VAR 0 5
60382: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
60383: LD_INT 0
60385: PPUSH
60386: PPUSH
// result := 0 ;
60387: LD_ADDR_VAR 0 3
60391: PUSH
60392: LD_INT 0
60394: ST_TO_ADDR
// if not array or not value in array then
60395: LD_VAR 0 1
60399: NOT
60400: PUSH
60401: LD_VAR 0 2
60405: PUSH
60406: LD_VAR 0 1
60410: IN
60411: NOT
60412: OR
60413: IFFALSE 60417
// exit ;
60415: GO 60471
// for i = 1 to array do
60417: LD_ADDR_VAR 0 4
60421: PUSH
60422: DOUBLE
60423: LD_INT 1
60425: DEC
60426: ST_TO_ADDR
60427: LD_VAR 0 1
60431: PUSH
60432: FOR_TO
60433: IFFALSE 60469
// if value = array [ i ] then
60435: LD_VAR 0 2
60439: PUSH
60440: LD_VAR 0 1
60444: PUSH
60445: LD_VAR 0 4
60449: ARRAY
60450: EQUAL
60451: IFFALSE 60467
// begin result := i ;
60453: LD_ADDR_VAR 0 3
60457: PUSH
60458: LD_VAR 0 4
60462: ST_TO_ADDR
// exit ;
60463: POP
60464: POP
60465: GO 60471
// end ;
60467: GO 60432
60469: POP
60470: POP
// end ;
60471: LD_VAR 0 3
60475: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
60476: LD_INT 0
60478: PPUSH
// vc_chassis := chassis ;
60479: LD_ADDR_OWVAR 37
60483: PUSH
60484: LD_VAR 0 1
60488: ST_TO_ADDR
// vc_engine := engine ;
60489: LD_ADDR_OWVAR 39
60493: PUSH
60494: LD_VAR 0 2
60498: ST_TO_ADDR
// vc_control := control ;
60499: LD_ADDR_OWVAR 38
60503: PUSH
60504: LD_VAR 0 3
60508: ST_TO_ADDR
// vc_weapon := weapon ;
60509: LD_ADDR_OWVAR 40
60513: PUSH
60514: LD_VAR 0 4
60518: ST_TO_ADDR
// vc_fuel_battery := fuel ;
60519: LD_ADDR_OWVAR 41
60523: PUSH
60524: LD_VAR 0 5
60528: ST_TO_ADDR
// end ;
60529: LD_VAR 0 6
60533: RET
// export function WantPlant ( unit ) ; var task ; begin
60534: LD_INT 0
60536: PPUSH
60537: PPUSH
// result := false ;
60538: LD_ADDR_VAR 0 2
60542: PUSH
60543: LD_INT 0
60545: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
60546: LD_ADDR_VAR 0 3
60550: PUSH
60551: LD_VAR 0 1
60555: PPUSH
60556: CALL_OW 437
60560: ST_TO_ADDR
// if task then
60561: LD_VAR 0 3
60565: IFFALSE 60593
// if task [ 1 ] [ 1 ] = p then
60567: LD_VAR 0 3
60571: PUSH
60572: LD_INT 1
60574: ARRAY
60575: PUSH
60576: LD_INT 1
60578: ARRAY
60579: PUSH
60580: LD_STRING p
60582: EQUAL
60583: IFFALSE 60593
// result := true ;
60585: LD_ADDR_VAR 0 2
60589: PUSH
60590: LD_INT 1
60592: ST_TO_ADDR
// end ;
60593: LD_VAR 0 2
60597: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
60598: LD_INT 0
60600: PPUSH
60601: PPUSH
60602: PPUSH
60603: PPUSH
// if pos < 1 then
60604: LD_VAR 0 2
60608: PUSH
60609: LD_INT 1
60611: LESS
60612: IFFALSE 60616
// exit ;
60614: GO 60919
// if pos = 1 then
60616: LD_VAR 0 2
60620: PUSH
60621: LD_INT 1
60623: EQUAL
60624: IFFALSE 60657
// result := Replace ( arr , pos [ 1 ] , value ) else
60626: LD_ADDR_VAR 0 4
60630: PUSH
60631: LD_VAR 0 1
60635: PPUSH
60636: LD_VAR 0 2
60640: PUSH
60641: LD_INT 1
60643: ARRAY
60644: PPUSH
60645: LD_VAR 0 3
60649: PPUSH
60650: CALL_OW 1
60654: ST_TO_ADDR
60655: GO 60919
// begin tmp := arr ;
60657: LD_ADDR_VAR 0 6
60661: PUSH
60662: LD_VAR 0 1
60666: ST_TO_ADDR
// s_arr := [ tmp ] ;
60667: LD_ADDR_VAR 0 7
60671: PUSH
60672: LD_VAR 0 6
60676: PUSH
60677: EMPTY
60678: LIST
60679: ST_TO_ADDR
// for i = 1 to pos - 1 do
60680: LD_ADDR_VAR 0 5
60684: PUSH
60685: DOUBLE
60686: LD_INT 1
60688: DEC
60689: ST_TO_ADDR
60690: LD_VAR 0 2
60694: PUSH
60695: LD_INT 1
60697: MINUS
60698: PUSH
60699: FOR_TO
60700: IFFALSE 60745
// begin tmp := tmp [ pos [ i ] ] ;
60702: LD_ADDR_VAR 0 6
60706: PUSH
60707: LD_VAR 0 6
60711: PUSH
60712: LD_VAR 0 2
60716: PUSH
60717: LD_VAR 0 5
60721: ARRAY
60722: ARRAY
60723: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
60724: LD_ADDR_VAR 0 7
60728: PUSH
60729: LD_VAR 0 7
60733: PUSH
60734: LD_VAR 0 6
60738: PUSH
60739: EMPTY
60740: LIST
60741: ADD
60742: ST_TO_ADDR
// end ;
60743: GO 60699
60745: POP
60746: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
60747: LD_ADDR_VAR 0 6
60751: PUSH
60752: LD_VAR 0 6
60756: PPUSH
60757: LD_VAR 0 2
60761: PUSH
60762: LD_VAR 0 2
60766: ARRAY
60767: PPUSH
60768: LD_VAR 0 3
60772: PPUSH
60773: CALL_OW 1
60777: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
60778: LD_ADDR_VAR 0 7
60782: PUSH
60783: LD_VAR 0 7
60787: PPUSH
60788: LD_VAR 0 7
60792: PPUSH
60793: LD_VAR 0 6
60797: PPUSH
60798: CALL_OW 1
60802: ST_TO_ADDR
// for i = s_arr downto 2 do
60803: LD_ADDR_VAR 0 5
60807: PUSH
60808: DOUBLE
60809: LD_VAR 0 7
60813: INC
60814: ST_TO_ADDR
60815: LD_INT 2
60817: PUSH
60818: FOR_DOWNTO
60819: IFFALSE 60903
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
60821: LD_ADDR_VAR 0 6
60825: PUSH
60826: LD_VAR 0 7
60830: PUSH
60831: LD_VAR 0 5
60835: PUSH
60836: LD_INT 1
60838: MINUS
60839: ARRAY
60840: PPUSH
60841: LD_VAR 0 2
60845: PUSH
60846: LD_VAR 0 5
60850: PUSH
60851: LD_INT 1
60853: MINUS
60854: ARRAY
60855: PPUSH
60856: LD_VAR 0 7
60860: PUSH
60861: LD_VAR 0 5
60865: ARRAY
60866: PPUSH
60867: CALL_OW 1
60871: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
60872: LD_ADDR_VAR 0 7
60876: PUSH
60877: LD_VAR 0 7
60881: PPUSH
60882: LD_VAR 0 5
60886: PUSH
60887: LD_INT 1
60889: MINUS
60890: PPUSH
60891: LD_VAR 0 6
60895: PPUSH
60896: CALL_OW 1
60900: ST_TO_ADDR
// end ;
60901: GO 60818
60903: POP
60904: POP
// result := s_arr [ 1 ] ;
60905: LD_ADDR_VAR 0 4
60909: PUSH
60910: LD_VAR 0 7
60914: PUSH
60915: LD_INT 1
60917: ARRAY
60918: ST_TO_ADDR
// end ; end ;
60919: LD_VAR 0 4
60923: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
60924: LD_INT 0
60926: PPUSH
60927: PPUSH
// if not list then
60928: LD_VAR 0 1
60932: NOT
60933: IFFALSE 60937
// exit ;
60935: GO 61028
// i := list [ pos1 ] ;
60937: LD_ADDR_VAR 0 5
60941: PUSH
60942: LD_VAR 0 1
60946: PUSH
60947: LD_VAR 0 2
60951: ARRAY
60952: ST_TO_ADDR
// if not i then
60953: LD_VAR 0 5
60957: NOT
60958: IFFALSE 60962
// exit ;
60960: GO 61028
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
60962: LD_ADDR_VAR 0 1
60966: PUSH
60967: LD_VAR 0 1
60971: PPUSH
60972: LD_VAR 0 2
60976: PPUSH
60977: LD_VAR 0 1
60981: PUSH
60982: LD_VAR 0 3
60986: ARRAY
60987: PPUSH
60988: CALL_OW 1
60992: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
60993: LD_ADDR_VAR 0 1
60997: PUSH
60998: LD_VAR 0 1
61002: PPUSH
61003: LD_VAR 0 3
61007: PPUSH
61008: LD_VAR 0 5
61012: PPUSH
61013: CALL_OW 1
61017: ST_TO_ADDR
// result := list ;
61018: LD_ADDR_VAR 0 4
61022: PUSH
61023: LD_VAR 0 1
61027: ST_TO_ADDR
// end ;
61028: LD_VAR 0 4
61032: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
61033: LD_INT 0
61035: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
61036: LD_ADDR_VAR 0 5
61040: PUSH
61041: LD_VAR 0 1
61045: PPUSH
61046: CALL_OW 250
61050: PPUSH
61051: LD_VAR 0 1
61055: PPUSH
61056: CALL_OW 251
61060: PPUSH
61061: LD_VAR 0 2
61065: PPUSH
61066: LD_VAR 0 3
61070: PPUSH
61071: LD_VAR 0 4
61075: PPUSH
61076: CALL 61086 0 5
61080: ST_TO_ADDR
// end ;
61081: LD_VAR 0 5
61085: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
61086: LD_INT 0
61088: PPUSH
61089: PPUSH
61090: PPUSH
61091: PPUSH
// if not list then
61092: LD_VAR 0 3
61096: NOT
61097: IFFALSE 61101
// exit ;
61099: GO 61489
// result := [ ] ;
61101: LD_ADDR_VAR 0 6
61105: PUSH
61106: EMPTY
61107: ST_TO_ADDR
// for i in list do
61108: LD_ADDR_VAR 0 7
61112: PUSH
61113: LD_VAR 0 3
61117: PUSH
61118: FOR_IN
61119: IFFALSE 61321
// begin tmp := GetDistUnitXY ( i , x , y ) ;
61121: LD_ADDR_VAR 0 9
61125: PUSH
61126: LD_VAR 0 7
61130: PPUSH
61131: LD_VAR 0 1
61135: PPUSH
61136: LD_VAR 0 2
61140: PPUSH
61141: CALL_OW 297
61145: ST_TO_ADDR
// if not result then
61146: LD_VAR 0 6
61150: NOT
61151: IFFALSE 61177
// result := [ [ i , tmp ] ] else
61153: LD_ADDR_VAR 0 6
61157: PUSH
61158: LD_VAR 0 7
61162: PUSH
61163: LD_VAR 0 9
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: PUSH
61172: EMPTY
61173: LIST
61174: ST_TO_ADDR
61175: GO 61319
// begin if result [ result ] [ 2 ] < tmp then
61177: LD_VAR 0 6
61181: PUSH
61182: LD_VAR 0 6
61186: ARRAY
61187: PUSH
61188: LD_INT 2
61190: ARRAY
61191: PUSH
61192: LD_VAR 0 9
61196: LESS
61197: IFFALSE 61239
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
61199: LD_ADDR_VAR 0 6
61203: PUSH
61204: LD_VAR 0 6
61208: PPUSH
61209: LD_VAR 0 6
61213: PUSH
61214: LD_INT 1
61216: PLUS
61217: PPUSH
61218: LD_VAR 0 7
61222: PUSH
61223: LD_VAR 0 9
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PPUSH
61232: CALL_OW 2
61236: ST_TO_ADDR
61237: GO 61319
// for j = 1 to result do
61239: LD_ADDR_VAR 0 8
61243: PUSH
61244: DOUBLE
61245: LD_INT 1
61247: DEC
61248: ST_TO_ADDR
61249: LD_VAR 0 6
61253: PUSH
61254: FOR_TO
61255: IFFALSE 61317
// begin if tmp < result [ j ] [ 2 ] then
61257: LD_VAR 0 9
61261: PUSH
61262: LD_VAR 0 6
61266: PUSH
61267: LD_VAR 0 8
61271: ARRAY
61272: PUSH
61273: LD_INT 2
61275: ARRAY
61276: LESS
61277: IFFALSE 61315
// begin result := Insert ( result , j , [ i , tmp ] ) ;
61279: LD_ADDR_VAR 0 6
61283: PUSH
61284: LD_VAR 0 6
61288: PPUSH
61289: LD_VAR 0 8
61293: PPUSH
61294: LD_VAR 0 7
61298: PUSH
61299: LD_VAR 0 9
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PPUSH
61308: CALL_OW 2
61312: ST_TO_ADDR
// break ;
61313: GO 61317
// end ; end ;
61315: GO 61254
61317: POP
61318: POP
// end ; end ;
61319: GO 61118
61321: POP
61322: POP
// if result and not asc then
61323: LD_VAR 0 6
61327: PUSH
61328: LD_VAR 0 4
61332: NOT
61333: AND
61334: IFFALSE 61409
// begin tmp := result ;
61336: LD_ADDR_VAR 0 9
61340: PUSH
61341: LD_VAR 0 6
61345: ST_TO_ADDR
// for i = tmp downto 1 do
61346: LD_ADDR_VAR 0 7
61350: PUSH
61351: DOUBLE
61352: LD_VAR 0 9
61356: INC
61357: ST_TO_ADDR
61358: LD_INT 1
61360: PUSH
61361: FOR_DOWNTO
61362: IFFALSE 61407
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
61364: LD_ADDR_VAR 0 6
61368: PUSH
61369: LD_VAR 0 6
61373: PPUSH
61374: LD_VAR 0 9
61378: PUSH
61379: LD_VAR 0 7
61383: MINUS
61384: PUSH
61385: LD_INT 1
61387: PLUS
61388: PPUSH
61389: LD_VAR 0 9
61393: PUSH
61394: LD_VAR 0 7
61398: ARRAY
61399: PPUSH
61400: CALL_OW 1
61404: ST_TO_ADDR
61405: GO 61361
61407: POP
61408: POP
// end ; tmp := [ ] ;
61409: LD_ADDR_VAR 0 9
61413: PUSH
61414: EMPTY
61415: ST_TO_ADDR
// if mode then
61416: LD_VAR 0 5
61420: IFFALSE 61489
// begin for i = 1 to result do
61422: LD_ADDR_VAR 0 7
61426: PUSH
61427: DOUBLE
61428: LD_INT 1
61430: DEC
61431: ST_TO_ADDR
61432: LD_VAR 0 6
61436: PUSH
61437: FOR_TO
61438: IFFALSE 61477
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
61440: LD_ADDR_VAR 0 9
61444: PUSH
61445: LD_VAR 0 9
61449: PPUSH
61450: LD_VAR 0 7
61454: PPUSH
61455: LD_VAR 0 6
61459: PUSH
61460: LD_VAR 0 7
61464: ARRAY
61465: PUSH
61466: LD_INT 1
61468: ARRAY
61469: PPUSH
61470: CALL_OW 1
61474: ST_TO_ADDR
61475: GO 61437
61477: POP
61478: POP
// result := tmp ;
61479: LD_ADDR_VAR 0 6
61483: PUSH
61484: LD_VAR 0 9
61488: ST_TO_ADDR
// end ; end ;
61489: LD_VAR 0 6
61493: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
61494: LD_INT 0
61496: PPUSH
61497: PPUSH
61498: PPUSH
61499: PPUSH
61500: PPUSH
61501: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
61502: LD_ADDR_VAR 0 5
61506: PUSH
61507: LD_INT 0
61509: PUSH
61510: LD_INT 0
61512: PUSH
61513: LD_INT 0
61515: PUSH
61516: EMPTY
61517: PUSH
61518: EMPTY
61519: LIST
61520: LIST
61521: LIST
61522: LIST
61523: ST_TO_ADDR
// if not x or not y then
61524: LD_VAR 0 2
61528: NOT
61529: PUSH
61530: LD_VAR 0 3
61534: NOT
61535: OR
61536: IFFALSE 61540
// exit ;
61538: GO 63186
// if not range then
61540: LD_VAR 0 4
61544: NOT
61545: IFFALSE 61555
// range := 10 ;
61547: LD_ADDR_VAR 0 4
61551: PUSH
61552: LD_INT 10
61554: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61555: LD_ADDR_VAR 0 8
61559: PUSH
61560: LD_INT 81
61562: PUSH
61563: LD_VAR 0 1
61567: PUSH
61568: EMPTY
61569: LIST
61570: LIST
61571: PUSH
61572: LD_INT 92
61574: PUSH
61575: LD_VAR 0 2
61579: PUSH
61580: LD_VAR 0 3
61584: PUSH
61585: LD_VAR 0 4
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: LIST
61594: LIST
61595: PUSH
61596: LD_INT 3
61598: PUSH
61599: LD_INT 21
61601: PUSH
61602: LD_INT 3
61604: PUSH
61605: EMPTY
61606: LIST
61607: LIST
61608: PUSH
61609: EMPTY
61610: LIST
61611: LIST
61612: PUSH
61613: EMPTY
61614: LIST
61615: LIST
61616: LIST
61617: PPUSH
61618: CALL_OW 69
61622: ST_TO_ADDR
// if not tmp then
61623: LD_VAR 0 8
61627: NOT
61628: IFFALSE 61632
// exit ;
61630: GO 63186
// for i in tmp do
61632: LD_ADDR_VAR 0 6
61636: PUSH
61637: LD_VAR 0 8
61641: PUSH
61642: FOR_IN
61643: IFFALSE 63161
// begin points := [ 0 , 0 , 0 ] ;
61645: LD_ADDR_VAR 0 9
61649: PUSH
61650: LD_INT 0
61652: PUSH
61653: LD_INT 0
61655: PUSH
61656: LD_INT 0
61658: PUSH
61659: EMPTY
61660: LIST
61661: LIST
61662: LIST
61663: ST_TO_ADDR
// bpoints := 1 ;
61664: LD_ADDR_VAR 0 10
61668: PUSH
61669: LD_INT 1
61671: ST_TO_ADDR
// case GetType ( i ) of unit_human :
61672: LD_VAR 0 6
61676: PPUSH
61677: CALL_OW 247
61681: PUSH
61682: LD_INT 1
61684: DOUBLE
61685: EQUAL
61686: IFTRUE 61690
61688: GO 62268
61690: POP
// begin if GetClass ( i ) = 1 then
61691: LD_VAR 0 6
61695: PPUSH
61696: CALL_OW 257
61700: PUSH
61701: LD_INT 1
61703: EQUAL
61704: IFFALSE 61725
// points := [ 10 , 5 , 3 ] ;
61706: LD_ADDR_VAR 0 9
61710: PUSH
61711: LD_INT 10
61713: PUSH
61714: LD_INT 5
61716: PUSH
61717: LD_INT 3
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: LIST
61724: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
61725: LD_VAR 0 6
61729: PPUSH
61730: CALL_OW 257
61734: PUSH
61735: LD_INT 2
61737: PUSH
61738: LD_INT 3
61740: PUSH
61741: LD_INT 4
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: LIST
61748: IN
61749: IFFALSE 61770
// points := [ 3 , 2 , 1 ] ;
61751: LD_ADDR_VAR 0 9
61755: PUSH
61756: LD_INT 3
61758: PUSH
61759: LD_INT 2
61761: PUSH
61762: LD_INT 1
61764: PUSH
61765: EMPTY
61766: LIST
61767: LIST
61768: LIST
61769: ST_TO_ADDR
// if GetClass ( i ) = 5 then
61770: LD_VAR 0 6
61774: PPUSH
61775: CALL_OW 257
61779: PUSH
61780: LD_INT 5
61782: EQUAL
61783: IFFALSE 61804
// points := [ 130 , 5 , 2 ] ;
61785: LD_ADDR_VAR 0 9
61789: PUSH
61790: LD_INT 130
61792: PUSH
61793: LD_INT 5
61795: PUSH
61796: LD_INT 2
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: LIST
61803: ST_TO_ADDR
// if GetClass ( i ) = 8 then
61804: LD_VAR 0 6
61808: PPUSH
61809: CALL_OW 257
61813: PUSH
61814: LD_INT 8
61816: EQUAL
61817: IFFALSE 61838
// points := [ 35 , 35 , 30 ] ;
61819: LD_ADDR_VAR 0 9
61823: PUSH
61824: LD_INT 35
61826: PUSH
61827: LD_INT 35
61829: PUSH
61830: LD_INT 30
61832: PUSH
61833: EMPTY
61834: LIST
61835: LIST
61836: LIST
61837: ST_TO_ADDR
// if GetClass ( i ) = 9 then
61838: LD_VAR 0 6
61842: PPUSH
61843: CALL_OW 257
61847: PUSH
61848: LD_INT 9
61850: EQUAL
61851: IFFALSE 61872
// points := [ 20 , 55 , 40 ] ;
61853: LD_ADDR_VAR 0 9
61857: PUSH
61858: LD_INT 20
61860: PUSH
61861: LD_INT 55
61863: PUSH
61864: LD_INT 40
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: LIST
61871: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
61872: LD_VAR 0 6
61876: PPUSH
61877: CALL_OW 257
61881: PUSH
61882: LD_INT 12
61884: PUSH
61885: LD_INT 16
61887: PUSH
61888: EMPTY
61889: LIST
61890: LIST
61891: IN
61892: IFFALSE 61913
// points := [ 5 , 3 , 2 ] ;
61894: LD_ADDR_VAR 0 9
61898: PUSH
61899: LD_INT 5
61901: PUSH
61902: LD_INT 3
61904: PUSH
61905: LD_INT 2
61907: PUSH
61908: EMPTY
61909: LIST
61910: LIST
61911: LIST
61912: ST_TO_ADDR
// if GetClass ( i ) = 17 then
61913: LD_VAR 0 6
61917: PPUSH
61918: CALL_OW 257
61922: PUSH
61923: LD_INT 17
61925: EQUAL
61926: IFFALSE 61947
// points := [ 100 , 50 , 75 ] ;
61928: LD_ADDR_VAR 0 9
61932: PUSH
61933: LD_INT 100
61935: PUSH
61936: LD_INT 50
61938: PUSH
61939: LD_INT 75
61941: PUSH
61942: EMPTY
61943: LIST
61944: LIST
61945: LIST
61946: ST_TO_ADDR
// if GetClass ( i ) = 15 then
61947: LD_VAR 0 6
61951: PPUSH
61952: CALL_OW 257
61956: PUSH
61957: LD_INT 15
61959: EQUAL
61960: IFFALSE 61981
// points := [ 10 , 5 , 3 ] ;
61962: LD_ADDR_VAR 0 9
61966: PUSH
61967: LD_INT 10
61969: PUSH
61970: LD_INT 5
61972: PUSH
61973: LD_INT 3
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: LIST
61980: ST_TO_ADDR
// if GetClass ( i ) = 14 then
61981: LD_VAR 0 6
61985: PPUSH
61986: CALL_OW 257
61990: PUSH
61991: LD_INT 14
61993: EQUAL
61994: IFFALSE 62015
// points := [ 10 , 0 , 0 ] ;
61996: LD_ADDR_VAR 0 9
62000: PUSH
62001: LD_INT 10
62003: PUSH
62004: LD_INT 0
62006: PUSH
62007: LD_INT 0
62009: PUSH
62010: EMPTY
62011: LIST
62012: LIST
62013: LIST
62014: ST_TO_ADDR
// if GetClass ( i ) = 11 then
62015: LD_VAR 0 6
62019: PPUSH
62020: CALL_OW 257
62024: PUSH
62025: LD_INT 11
62027: EQUAL
62028: IFFALSE 62049
// points := [ 30 , 10 , 5 ] ;
62030: LD_ADDR_VAR 0 9
62034: PUSH
62035: LD_INT 30
62037: PUSH
62038: LD_INT 10
62040: PUSH
62041: LD_INT 5
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: LIST
62048: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
62049: LD_VAR 0 1
62053: PPUSH
62054: LD_INT 5
62056: PPUSH
62057: CALL_OW 321
62061: PUSH
62062: LD_INT 2
62064: EQUAL
62065: IFFALSE 62082
// bpoints := bpoints * 1.8 ;
62067: LD_ADDR_VAR 0 10
62071: PUSH
62072: LD_VAR 0 10
62076: PUSH
62077: LD_REAL  1.80000000000000E+0000
62080: MUL
62081: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
62082: LD_VAR 0 6
62086: PPUSH
62087: CALL_OW 257
62091: PUSH
62092: LD_INT 1
62094: PUSH
62095: LD_INT 2
62097: PUSH
62098: LD_INT 3
62100: PUSH
62101: LD_INT 4
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: IN
62110: PUSH
62111: LD_VAR 0 1
62115: PPUSH
62116: LD_INT 51
62118: PPUSH
62119: CALL_OW 321
62123: PUSH
62124: LD_INT 2
62126: EQUAL
62127: AND
62128: IFFALSE 62145
// bpoints := bpoints * 1.2 ;
62130: LD_ADDR_VAR 0 10
62134: PUSH
62135: LD_VAR 0 10
62139: PUSH
62140: LD_REAL  1.20000000000000E+0000
62143: MUL
62144: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
62145: LD_VAR 0 6
62149: PPUSH
62150: CALL_OW 257
62154: PUSH
62155: LD_INT 5
62157: PUSH
62158: LD_INT 7
62160: PUSH
62161: LD_INT 9
62163: PUSH
62164: EMPTY
62165: LIST
62166: LIST
62167: LIST
62168: IN
62169: PUSH
62170: LD_VAR 0 1
62174: PPUSH
62175: LD_INT 52
62177: PPUSH
62178: CALL_OW 321
62182: PUSH
62183: LD_INT 2
62185: EQUAL
62186: AND
62187: IFFALSE 62204
// bpoints := bpoints * 1.5 ;
62189: LD_ADDR_VAR 0 10
62193: PUSH
62194: LD_VAR 0 10
62198: PUSH
62199: LD_REAL  1.50000000000000E+0000
62202: MUL
62203: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
62204: LD_VAR 0 1
62208: PPUSH
62209: LD_INT 66
62211: PPUSH
62212: CALL_OW 321
62216: PUSH
62217: LD_INT 2
62219: EQUAL
62220: IFFALSE 62237
// bpoints := bpoints * 1.1 ;
62222: LD_ADDR_VAR 0 10
62226: PUSH
62227: LD_VAR 0 10
62231: PUSH
62232: LD_REAL  1.10000000000000E+0000
62235: MUL
62236: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
62237: LD_ADDR_VAR 0 10
62241: PUSH
62242: LD_VAR 0 10
62246: PUSH
62247: LD_VAR 0 6
62251: PPUSH
62252: LD_INT 1
62254: PPUSH
62255: CALL_OW 259
62259: PUSH
62260: LD_REAL  1.15000000000000E+0000
62263: MUL
62264: MUL
62265: ST_TO_ADDR
// end ; unit_vehicle :
62266: GO 63090
62268: LD_INT 2
62270: DOUBLE
62271: EQUAL
62272: IFTRUE 62276
62274: GO 63078
62276: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
62277: LD_VAR 0 6
62281: PPUSH
62282: CALL_OW 264
62286: PUSH
62287: LD_INT 2
62289: PUSH
62290: LD_INT 42
62292: PUSH
62293: LD_INT 24
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: LIST
62300: IN
62301: IFFALSE 62322
// points := [ 25 , 5 , 3 ] ;
62303: LD_ADDR_VAR 0 9
62307: PUSH
62308: LD_INT 25
62310: PUSH
62311: LD_INT 5
62313: PUSH
62314: LD_INT 3
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: LIST
62321: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
62322: LD_VAR 0 6
62326: PPUSH
62327: CALL_OW 264
62331: PUSH
62332: LD_INT 4
62334: PUSH
62335: LD_INT 43
62337: PUSH
62338: LD_INT 25
62340: PUSH
62341: EMPTY
62342: LIST
62343: LIST
62344: LIST
62345: IN
62346: IFFALSE 62367
// points := [ 40 , 15 , 5 ] ;
62348: LD_ADDR_VAR 0 9
62352: PUSH
62353: LD_INT 40
62355: PUSH
62356: LD_INT 15
62358: PUSH
62359: LD_INT 5
62361: PUSH
62362: EMPTY
62363: LIST
62364: LIST
62365: LIST
62366: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
62367: LD_VAR 0 6
62371: PPUSH
62372: CALL_OW 264
62376: PUSH
62377: LD_INT 3
62379: PUSH
62380: LD_INT 23
62382: PUSH
62383: EMPTY
62384: LIST
62385: LIST
62386: IN
62387: IFFALSE 62408
// points := [ 7 , 25 , 8 ] ;
62389: LD_ADDR_VAR 0 9
62393: PUSH
62394: LD_INT 7
62396: PUSH
62397: LD_INT 25
62399: PUSH
62400: LD_INT 8
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: LIST
62407: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
62408: LD_VAR 0 6
62412: PPUSH
62413: CALL_OW 264
62417: PUSH
62418: LD_INT 5
62420: PUSH
62421: LD_INT 27
62423: PUSH
62424: LD_INT 44
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: LIST
62431: IN
62432: IFFALSE 62453
// points := [ 14 , 50 , 16 ] ;
62434: LD_ADDR_VAR 0 9
62438: PUSH
62439: LD_INT 14
62441: PUSH
62442: LD_INT 50
62444: PUSH
62445: LD_INT 16
62447: PUSH
62448: EMPTY
62449: LIST
62450: LIST
62451: LIST
62452: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
62453: LD_VAR 0 6
62457: PPUSH
62458: CALL_OW 264
62462: PUSH
62463: LD_INT 6
62465: PUSH
62466: LD_INT 46
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: IN
62473: IFFALSE 62494
// points := [ 32 , 120 , 70 ] ;
62475: LD_ADDR_VAR 0 9
62479: PUSH
62480: LD_INT 32
62482: PUSH
62483: LD_INT 120
62485: PUSH
62486: LD_INT 70
62488: PUSH
62489: EMPTY
62490: LIST
62491: LIST
62492: LIST
62493: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
62494: LD_VAR 0 6
62498: PPUSH
62499: CALL_OW 264
62503: PUSH
62504: LD_INT 7
62506: PUSH
62507: LD_INT 28
62509: PUSH
62510: LD_INT 45
62512: PUSH
62513: EMPTY
62514: LIST
62515: LIST
62516: LIST
62517: IN
62518: IFFALSE 62539
// points := [ 35 , 20 , 45 ] ;
62520: LD_ADDR_VAR 0 9
62524: PUSH
62525: LD_INT 35
62527: PUSH
62528: LD_INT 20
62530: PUSH
62531: LD_INT 45
62533: PUSH
62534: EMPTY
62535: LIST
62536: LIST
62537: LIST
62538: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
62539: LD_VAR 0 6
62543: PPUSH
62544: CALL_OW 264
62548: PUSH
62549: LD_INT 47
62551: PUSH
62552: EMPTY
62553: LIST
62554: IN
62555: IFFALSE 62576
// points := [ 67 , 45 , 75 ] ;
62557: LD_ADDR_VAR 0 9
62561: PUSH
62562: LD_INT 67
62564: PUSH
62565: LD_INT 45
62567: PUSH
62568: LD_INT 75
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: LIST
62575: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
62576: LD_VAR 0 6
62580: PPUSH
62581: CALL_OW 264
62585: PUSH
62586: LD_INT 26
62588: PUSH
62589: EMPTY
62590: LIST
62591: IN
62592: IFFALSE 62613
// points := [ 120 , 30 , 80 ] ;
62594: LD_ADDR_VAR 0 9
62598: PUSH
62599: LD_INT 120
62601: PUSH
62602: LD_INT 30
62604: PUSH
62605: LD_INT 80
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: LIST
62612: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
62613: LD_VAR 0 6
62617: PPUSH
62618: CALL_OW 264
62622: PUSH
62623: LD_INT 22
62625: PUSH
62626: EMPTY
62627: LIST
62628: IN
62629: IFFALSE 62650
// points := [ 40 , 1 , 1 ] ;
62631: LD_ADDR_VAR 0 9
62635: PUSH
62636: LD_INT 40
62638: PUSH
62639: LD_INT 1
62641: PUSH
62642: LD_INT 1
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: LIST
62649: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
62650: LD_VAR 0 6
62654: PPUSH
62655: CALL_OW 264
62659: PUSH
62660: LD_INT 29
62662: PUSH
62663: EMPTY
62664: LIST
62665: IN
62666: IFFALSE 62687
// points := [ 70 , 200 , 400 ] ;
62668: LD_ADDR_VAR 0 9
62672: PUSH
62673: LD_INT 70
62675: PUSH
62676: LD_INT 200
62678: PUSH
62679: LD_INT 400
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: LIST
62686: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
62687: LD_VAR 0 6
62691: PPUSH
62692: CALL_OW 264
62696: PUSH
62697: LD_INT 14
62699: PUSH
62700: LD_INT 53
62702: PUSH
62703: EMPTY
62704: LIST
62705: LIST
62706: IN
62707: IFFALSE 62728
// points := [ 40 , 10 , 20 ] ;
62709: LD_ADDR_VAR 0 9
62713: PUSH
62714: LD_INT 40
62716: PUSH
62717: LD_INT 10
62719: PUSH
62720: LD_INT 20
62722: PUSH
62723: EMPTY
62724: LIST
62725: LIST
62726: LIST
62727: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
62728: LD_VAR 0 6
62732: PPUSH
62733: CALL_OW 264
62737: PUSH
62738: LD_INT 9
62740: PUSH
62741: EMPTY
62742: LIST
62743: IN
62744: IFFALSE 62765
// points := [ 5 , 70 , 20 ] ;
62746: LD_ADDR_VAR 0 9
62750: PUSH
62751: LD_INT 5
62753: PUSH
62754: LD_INT 70
62756: PUSH
62757: LD_INT 20
62759: PUSH
62760: EMPTY
62761: LIST
62762: LIST
62763: LIST
62764: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
62765: LD_VAR 0 6
62769: PPUSH
62770: CALL_OW 264
62774: PUSH
62775: LD_INT 10
62777: PUSH
62778: EMPTY
62779: LIST
62780: IN
62781: IFFALSE 62802
// points := [ 35 , 110 , 70 ] ;
62783: LD_ADDR_VAR 0 9
62787: PUSH
62788: LD_INT 35
62790: PUSH
62791: LD_INT 110
62793: PUSH
62794: LD_INT 70
62796: PUSH
62797: EMPTY
62798: LIST
62799: LIST
62800: LIST
62801: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
62802: LD_VAR 0 6
62806: PPUSH
62807: CALL_OW 265
62811: PUSH
62812: LD_INT 25
62814: EQUAL
62815: IFFALSE 62836
// points := [ 80 , 65 , 100 ] ;
62817: LD_ADDR_VAR 0 9
62821: PUSH
62822: LD_INT 80
62824: PUSH
62825: LD_INT 65
62827: PUSH
62828: LD_INT 100
62830: PUSH
62831: EMPTY
62832: LIST
62833: LIST
62834: LIST
62835: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
62836: LD_VAR 0 6
62840: PPUSH
62841: CALL_OW 263
62845: PUSH
62846: LD_INT 1
62848: EQUAL
62849: IFFALSE 62884
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
62851: LD_ADDR_VAR 0 10
62855: PUSH
62856: LD_VAR 0 10
62860: PUSH
62861: LD_VAR 0 6
62865: PPUSH
62866: CALL_OW 311
62870: PPUSH
62871: LD_INT 3
62873: PPUSH
62874: CALL_OW 259
62878: PUSH
62879: LD_INT 4
62881: MUL
62882: MUL
62883: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
62884: LD_VAR 0 6
62888: PPUSH
62889: CALL_OW 263
62893: PUSH
62894: LD_INT 2
62896: EQUAL
62897: IFFALSE 62948
// begin j := IsControledBy ( i ) ;
62899: LD_ADDR_VAR 0 7
62903: PUSH
62904: LD_VAR 0 6
62908: PPUSH
62909: CALL_OW 312
62913: ST_TO_ADDR
// if j then
62914: LD_VAR 0 7
62918: IFFALSE 62948
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
62920: LD_ADDR_VAR 0 10
62924: PUSH
62925: LD_VAR 0 10
62929: PUSH
62930: LD_VAR 0 7
62934: PPUSH
62935: LD_INT 3
62937: PPUSH
62938: CALL_OW 259
62942: PUSH
62943: LD_INT 3
62945: MUL
62946: MUL
62947: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
62948: LD_VAR 0 6
62952: PPUSH
62953: CALL_OW 264
62957: PUSH
62958: LD_INT 5
62960: PUSH
62961: LD_INT 6
62963: PUSH
62964: LD_INT 46
62966: PUSH
62967: LD_INT 44
62969: PUSH
62970: LD_INT 47
62972: PUSH
62973: LD_INT 45
62975: PUSH
62976: LD_INT 28
62978: PUSH
62979: LD_INT 7
62981: PUSH
62982: LD_INT 27
62984: PUSH
62985: LD_INT 29
62987: PUSH
62988: EMPTY
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: LIST
62994: LIST
62995: LIST
62996: LIST
62997: LIST
62998: LIST
62999: IN
63000: PUSH
63001: LD_VAR 0 1
63005: PPUSH
63006: LD_INT 52
63008: PPUSH
63009: CALL_OW 321
63013: PUSH
63014: LD_INT 2
63016: EQUAL
63017: AND
63018: IFFALSE 63035
// bpoints := bpoints * 1.2 ;
63020: LD_ADDR_VAR 0 10
63024: PUSH
63025: LD_VAR 0 10
63029: PUSH
63030: LD_REAL  1.20000000000000E+0000
63033: MUL
63034: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
63035: LD_VAR 0 6
63039: PPUSH
63040: CALL_OW 264
63044: PUSH
63045: LD_INT 6
63047: PUSH
63048: LD_INT 46
63050: PUSH
63051: LD_INT 47
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: LIST
63058: IN
63059: IFFALSE 63076
// bpoints := bpoints * 1.2 ;
63061: LD_ADDR_VAR 0 10
63065: PUSH
63066: LD_VAR 0 10
63070: PUSH
63071: LD_REAL  1.20000000000000E+0000
63074: MUL
63075: ST_TO_ADDR
// end ; unit_building :
63076: GO 63090
63078: LD_INT 3
63080: DOUBLE
63081: EQUAL
63082: IFTRUE 63086
63084: GO 63089
63086: POP
// ; end ;
63087: GO 63090
63089: POP
// for j = 1 to 3 do
63090: LD_ADDR_VAR 0 7
63094: PUSH
63095: DOUBLE
63096: LD_INT 1
63098: DEC
63099: ST_TO_ADDR
63100: LD_INT 3
63102: PUSH
63103: FOR_TO
63104: IFFALSE 63157
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
63106: LD_ADDR_VAR 0 5
63110: PUSH
63111: LD_VAR 0 5
63115: PPUSH
63116: LD_VAR 0 7
63120: PPUSH
63121: LD_VAR 0 5
63125: PUSH
63126: LD_VAR 0 7
63130: ARRAY
63131: PUSH
63132: LD_VAR 0 9
63136: PUSH
63137: LD_VAR 0 7
63141: ARRAY
63142: PUSH
63143: LD_VAR 0 10
63147: MUL
63148: PLUS
63149: PPUSH
63150: CALL_OW 1
63154: ST_TO_ADDR
63155: GO 63103
63157: POP
63158: POP
// end ;
63159: GO 61642
63161: POP
63162: POP
// result := Replace ( result , 4 , tmp ) ;
63163: LD_ADDR_VAR 0 5
63167: PUSH
63168: LD_VAR 0 5
63172: PPUSH
63173: LD_INT 4
63175: PPUSH
63176: LD_VAR 0 8
63180: PPUSH
63181: CALL_OW 1
63185: ST_TO_ADDR
// end ;
63186: LD_VAR 0 5
63190: RET
// export function DangerAtRange ( unit , range ) ; begin
63191: LD_INT 0
63193: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
63194: LD_ADDR_VAR 0 3
63198: PUSH
63199: LD_VAR 0 1
63203: PPUSH
63204: CALL_OW 255
63208: PPUSH
63209: LD_VAR 0 1
63213: PPUSH
63214: CALL_OW 250
63218: PPUSH
63219: LD_VAR 0 1
63223: PPUSH
63224: CALL_OW 251
63228: PPUSH
63229: LD_VAR 0 2
63233: PPUSH
63234: CALL 61494 0 4
63238: ST_TO_ADDR
// end ;
63239: LD_VAR 0 3
63243: RET
// export function DangerInArea ( side , area ) ; begin
63244: LD_INT 0
63246: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
63247: LD_ADDR_VAR 0 3
63251: PUSH
63252: LD_VAR 0 2
63256: PPUSH
63257: LD_INT 81
63259: PUSH
63260: LD_VAR 0 1
63264: PUSH
63265: EMPTY
63266: LIST
63267: LIST
63268: PPUSH
63269: CALL_OW 70
63273: ST_TO_ADDR
// end ;
63274: LD_VAR 0 3
63278: RET
// export function IsExtension ( b ) ; begin
63279: LD_INT 0
63281: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
63282: LD_ADDR_VAR 0 2
63286: PUSH
63287: LD_VAR 0 1
63291: PUSH
63292: LD_INT 23
63294: PUSH
63295: LD_INT 20
63297: PUSH
63298: LD_INT 22
63300: PUSH
63301: LD_INT 17
63303: PUSH
63304: LD_INT 24
63306: PUSH
63307: LD_INT 21
63309: PUSH
63310: LD_INT 19
63312: PUSH
63313: LD_INT 16
63315: PUSH
63316: LD_INT 25
63318: PUSH
63319: LD_INT 18
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: LIST
63331: LIST
63332: LIST
63333: IN
63334: ST_TO_ADDR
// end ;
63335: LD_VAR 0 2
63339: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
63340: LD_INT 0
63342: PPUSH
63343: PPUSH
63344: PPUSH
// result := [ ] ;
63345: LD_ADDR_VAR 0 3
63349: PUSH
63350: EMPTY
63351: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
63352: LD_ADDR_VAR 0 4
63356: PUSH
63357: LD_VAR 0 2
63361: PPUSH
63362: LD_INT 21
63364: PUSH
63365: LD_INT 3
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: PPUSH
63372: CALL_OW 70
63376: ST_TO_ADDR
// if not tmp then
63377: LD_VAR 0 4
63381: NOT
63382: IFFALSE 63386
// exit ;
63384: GO 63444
// for i in tmp do
63386: LD_ADDR_VAR 0 5
63390: PUSH
63391: LD_VAR 0 4
63395: PUSH
63396: FOR_IN
63397: IFFALSE 63432
// if GetBase ( i ) <> base then
63399: LD_VAR 0 5
63403: PPUSH
63404: CALL_OW 274
63408: PUSH
63409: LD_VAR 0 1
63413: NONEQUAL
63414: IFFALSE 63430
// ComLinkToBase ( base , i ) ;
63416: LD_VAR 0 1
63420: PPUSH
63421: LD_VAR 0 5
63425: PPUSH
63426: CALL_OW 169
63430: GO 63396
63432: POP
63433: POP
// result := tmp ;
63434: LD_ADDR_VAR 0 3
63438: PUSH
63439: LD_VAR 0 4
63443: ST_TO_ADDR
// end ;
63444: LD_VAR 0 3
63448: RET
// export function ComComplete ( unit , b ) ; var i ; begin
63449: LD_INT 0
63451: PPUSH
63452: PPUSH
// if BuildingStatus ( b ) = bs_build then
63453: LD_VAR 0 2
63457: PPUSH
63458: CALL_OW 461
63462: PUSH
63463: LD_INT 1
63465: EQUAL
63466: IFFALSE 63526
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
63468: LD_VAR 0 1
63472: PPUSH
63473: LD_STRING h
63475: PUSH
63476: LD_VAR 0 2
63480: PPUSH
63481: CALL_OW 250
63485: PUSH
63486: LD_VAR 0 2
63490: PPUSH
63491: CALL_OW 251
63495: PUSH
63496: LD_VAR 0 2
63500: PUSH
63501: LD_INT 0
63503: PUSH
63504: LD_INT 0
63506: PUSH
63507: LD_INT 0
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: LIST
63518: PUSH
63519: EMPTY
63520: LIST
63521: PPUSH
63522: CALL_OW 446
// end ;
63526: LD_VAR 0 3
63530: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
63531: LD_INT 0
63533: PPUSH
63534: PPUSH
63535: PPUSH
63536: PPUSH
63537: PPUSH
63538: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
63539: LD_VAR 0 1
63543: NOT
63544: PUSH
63545: LD_VAR 0 1
63549: PPUSH
63550: CALL_OW 263
63554: PUSH
63555: LD_INT 2
63557: EQUAL
63558: NOT
63559: OR
63560: IFFALSE 63564
// exit ;
63562: GO 63880
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
63564: LD_ADDR_VAR 0 6
63568: PUSH
63569: LD_INT 22
63571: PUSH
63572: LD_VAR 0 1
63576: PPUSH
63577: CALL_OW 255
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 2
63588: PUSH
63589: LD_INT 30
63591: PUSH
63592: LD_INT 36
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: PUSH
63599: LD_INT 34
63601: PUSH
63602: LD_INT 31
63604: PUSH
63605: EMPTY
63606: LIST
63607: LIST
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: LIST
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PPUSH
63618: CALL_OW 69
63622: ST_TO_ADDR
// if not tmp then
63623: LD_VAR 0 6
63627: NOT
63628: IFFALSE 63632
// exit ;
63630: GO 63880
// result := [ ] ;
63632: LD_ADDR_VAR 0 2
63636: PUSH
63637: EMPTY
63638: ST_TO_ADDR
// for i in tmp do
63639: LD_ADDR_VAR 0 3
63643: PUSH
63644: LD_VAR 0 6
63648: PUSH
63649: FOR_IN
63650: IFFALSE 63721
// begin t := UnitsInside ( i ) ;
63652: LD_ADDR_VAR 0 4
63656: PUSH
63657: LD_VAR 0 3
63661: PPUSH
63662: CALL_OW 313
63666: ST_TO_ADDR
// if t then
63667: LD_VAR 0 4
63671: IFFALSE 63719
// for j in t do
63673: LD_ADDR_VAR 0 7
63677: PUSH
63678: LD_VAR 0 4
63682: PUSH
63683: FOR_IN
63684: IFFALSE 63717
// result := Insert ( result , result + 1 , j ) ;
63686: LD_ADDR_VAR 0 2
63690: PUSH
63691: LD_VAR 0 2
63695: PPUSH
63696: LD_VAR 0 2
63700: PUSH
63701: LD_INT 1
63703: PLUS
63704: PPUSH
63705: LD_VAR 0 7
63709: PPUSH
63710: CALL_OW 2
63714: ST_TO_ADDR
63715: GO 63683
63717: POP
63718: POP
// end ;
63719: GO 63649
63721: POP
63722: POP
// if not result then
63723: LD_VAR 0 2
63727: NOT
63728: IFFALSE 63732
// exit ;
63730: GO 63880
// mech := result [ 1 ] ;
63732: LD_ADDR_VAR 0 5
63736: PUSH
63737: LD_VAR 0 2
63741: PUSH
63742: LD_INT 1
63744: ARRAY
63745: ST_TO_ADDR
// if result > 1 then
63746: LD_VAR 0 2
63750: PUSH
63751: LD_INT 1
63753: GREATER
63754: IFFALSE 63866
// for i = 2 to result do
63756: LD_ADDR_VAR 0 3
63760: PUSH
63761: DOUBLE
63762: LD_INT 2
63764: DEC
63765: ST_TO_ADDR
63766: LD_VAR 0 2
63770: PUSH
63771: FOR_TO
63772: IFFALSE 63864
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
63774: LD_ADDR_VAR 0 4
63778: PUSH
63779: LD_VAR 0 2
63783: PUSH
63784: LD_VAR 0 3
63788: ARRAY
63789: PPUSH
63790: LD_INT 3
63792: PPUSH
63793: CALL_OW 259
63797: PUSH
63798: LD_VAR 0 2
63802: PUSH
63803: LD_VAR 0 3
63807: ARRAY
63808: PPUSH
63809: CALL_OW 432
63813: MINUS
63814: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
63815: LD_VAR 0 4
63819: PUSH
63820: LD_VAR 0 5
63824: PPUSH
63825: LD_INT 3
63827: PPUSH
63828: CALL_OW 259
63832: PUSH
63833: LD_VAR 0 5
63837: PPUSH
63838: CALL_OW 432
63842: MINUS
63843: GREATEREQUAL
63844: IFFALSE 63862
// mech := result [ i ] ;
63846: LD_ADDR_VAR 0 5
63850: PUSH
63851: LD_VAR 0 2
63855: PUSH
63856: LD_VAR 0 3
63860: ARRAY
63861: ST_TO_ADDR
// end ;
63862: GO 63771
63864: POP
63865: POP
// ComLinkTo ( vehicle , mech ) ;
63866: LD_VAR 0 1
63870: PPUSH
63871: LD_VAR 0 5
63875: PPUSH
63876: CALL_OW 135
// end ;
63880: LD_VAR 0 2
63884: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
63885: LD_INT 0
63887: PPUSH
63888: PPUSH
63889: PPUSH
63890: PPUSH
63891: PPUSH
63892: PPUSH
63893: PPUSH
63894: PPUSH
63895: PPUSH
63896: PPUSH
63897: PPUSH
63898: PPUSH
63899: PPUSH
// result := [ ] ;
63900: LD_ADDR_VAR 0 7
63904: PUSH
63905: EMPTY
63906: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
63907: LD_VAR 0 1
63911: PPUSH
63912: CALL_OW 266
63916: PUSH
63917: LD_INT 0
63919: PUSH
63920: LD_INT 1
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: IN
63927: NOT
63928: IFFALSE 63932
// exit ;
63930: GO 65563
// if name then
63932: LD_VAR 0 3
63936: IFFALSE 63952
// SetBName ( base_dep , name ) ;
63938: LD_VAR 0 1
63942: PPUSH
63943: LD_VAR 0 3
63947: PPUSH
63948: CALL_OW 500
// base := GetBase ( base_dep ) ;
63952: LD_ADDR_VAR 0 15
63956: PUSH
63957: LD_VAR 0 1
63961: PPUSH
63962: CALL_OW 274
63966: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
63967: LD_ADDR_VAR 0 16
63971: PUSH
63972: LD_VAR 0 1
63976: PPUSH
63977: CALL_OW 255
63981: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
63982: LD_ADDR_VAR 0 17
63986: PUSH
63987: LD_VAR 0 1
63991: PPUSH
63992: CALL_OW 248
63996: ST_TO_ADDR
// if sources then
63997: LD_VAR 0 5
64001: IFFALSE 64048
// for i = 1 to 3 do
64003: LD_ADDR_VAR 0 8
64007: PUSH
64008: DOUBLE
64009: LD_INT 1
64011: DEC
64012: ST_TO_ADDR
64013: LD_INT 3
64015: PUSH
64016: FOR_TO
64017: IFFALSE 64046
// AddResourceType ( base , i , sources [ i ] ) ;
64019: LD_VAR 0 15
64023: PPUSH
64024: LD_VAR 0 8
64028: PPUSH
64029: LD_VAR 0 5
64033: PUSH
64034: LD_VAR 0 8
64038: ARRAY
64039: PPUSH
64040: CALL_OW 276
64044: GO 64016
64046: POP
64047: POP
// buildings := GetBaseBuildings ( base , area ) ;
64048: LD_ADDR_VAR 0 18
64052: PUSH
64053: LD_VAR 0 15
64057: PPUSH
64058: LD_VAR 0 2
64062: PPUSH
64063: CALL 63340 0 2
64067: ST_TO_ADDR
// InitHc ;
64068: CALL_OW 19
// InitUc ;
64072: CALL_OW 18
// uc_side := side ;
64076: LD_ADDR_OWVAR 20
64080: PUSH
64081: LD_VAR 0 16
64085: ST_TO_ADDR
// uc_nation := nation ;
64086: LD_ADDR_OWVAR 21
64090: PUSH
64091: LD_VAR 0 17
64095: ST_TO_ADDR
// if buildings then
64096: LD_VAR 0 18
64100: IFFALSE 65422
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
64102: LD_ADDR_VAR 0 19
64106: PUSH
64107: LD_VAR 0 18
64111: PPUSH
64112: LD_INT 2
64114: PUSH
64115: LD_INT 30
64117: PUSH
64118: LD_INT 29
64120: PUSH
64121: EMPTY
64122: LIST
64123: LIST
64124: PUSH
64125: LD_INT 30
64127: PUSH
64128: LD_INT 30
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: LIST
64139: PPUSH
64140: CALL_OW 72
64144: ST_TO_ADDR
// if tmp then
64145: LD_VAR 0 19
64149: IFFALSE 64197
// for i in tmp do
64151: LD_ADDR_VAR 0 8
64155: PUSH
64156: LD_VAR 0 19
64160: PUSH
64161: FOR_IN
64162: IFFALSE 64195
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
64164: LD_VAR 0 8
64168: PPUSH
64169: CALL_OW 250
64173: PPUSH
64174: LD_VAR 0 8
64178: PPUSH
64179: CALL_OW 251
64183: PPUSH
64184: LD_VAR 0 16
64188: PPUSH
64189: CALL_OW 441
64193: GO 64161
64195: POP
64196: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
64197: LD_VAR 0 18
64201: PPUSH
64202: LD_INT 2
64204: PUSH
64205: LD_INT 30
64207: PUSH
64208: LD_INT 32
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: LD_INT 30
64217: PUSH
64218: LD_INT 33
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PUSH
64225: EMPTY
64226: LIST
64227: LIST
64228: LIST
64229: PPUSH
64230: CALL_OW 72
64234: IFFALSE 64322
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
64236: LD_ADDR_VAR 0 8
64240: PUSH
64241: LD_VAR 0 18
64245: PPUSH
64246: LD_INT 2
64248: PUSH
64249: LD_INT 30
64251: PUSH
64252: LD_INT 32
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: PUSH
64259: LD_INT 30
64261: PUSH
64262: LD_INT 33
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: LIST
64273: PPUSH
64274: CALL_OW 72
64278: PUSH
64279: FOR_IN
64280: IFFALSE 64320
// begin if not GetBWeapon ( i ) then
64282: LD_VAR 0 8
64286: PPUSH
64287: CALL_OW 269
64291: NOT
64292: IFFALSE 64318
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
64294: LD_VAR 0 8
64298: PPUSH
64299: LD_VAR 0 8
64303: PPUSH
64304: LD_VAR 0 2
64308: PPUSH
64309: CALL 65568 0 2
64313: PPUSH
64314: CALL_OW 431
// end ;
64318: GO 64279
64320: POP
64321: POP
// end ; for i = 1 to personel do
64322: LD_ADDR_VAR 0 8
64326: PUSH
64327: DOUBLE
64328: LD_INT 1
64330: DEC
64331: ST_TO_ADDR
64332: LD_VAR 0 6
64336: PUSH
64337: FOR_TO
64338: IFFALSE 65402
// begin if i > 4 then
64340: LD_VAR 0 8
64344: PUSH
64345: LD_INT 4
64347: GREATER
64348: IFFALSE 64352
// break ;
64350: GO 65402
// case i of 1 :
64352: LD_VAR 0 8
64356: PUSH
64357: LD_INT 1
64359: DOUBLE
64360: EQUAL
64361: IFTRUE 64365
64363: GO 64445
64365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
64366: LD_ADDR_VAR 0 12
64370: PUSH
64371: LD_VAR 0 18
64375: PPUSH
64376: LD_INT 22
64378: PUSH
64379: LD_VAR 0 16
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 58
64390: PUSH
64391: EMPTY
64392: LIST
64393: PUSH
64394: LD_INT 2
64396: PUSH
64397: LD_INT 30
64399: PUSH
64400: LD_INT 32
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: PUSH
64407: LD_INT 30
64409: PUSH
64410: LD_INT 4
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: PUSH
64417: LD_INT 30
64419: PUSH
64420: LD_INT 5
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: LIST
64431: LIST
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: LIST
64437: PPUSH
64438: CALL_OW 72
64442: ST_TO_ADDR
64443: GO 64667
64445: LD_INT 2
64447: DOUBLE
64448: EQUAL
64449: IFTRUE 64453
64451: GO 64515
64453: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
64454: LD_ADDR_VAR 0 12
64458: PUSH
64459: LD_VAR 0 18
64463: PPUSH
64464: LD_INT 22
64466: PUSH
64467: LD_VAR 0 16
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 2
64478: PUSH
64479: LD_INT 30
64481: PUSH
64482: LD_INT 0
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: PUSH
64489: LD_INT 30
64491: PUSH
64492: LD_INT 1
64494: PUSH
64495: EMPTY
64496: LIST
64497: LIST
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: LIST
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PPUSH
64508: CALL_OW 72
64512: ST_TO_ADDR
64513: GO 64667
64515: LD_INT 3
64517: DOUBLE
64518: EQUAL
64519: IFTRUE 64523
64521: GO 64585
64523: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
64524: LD_ADDR_VAR 0 12
64528: PUSH
64529: LD_VAR 0 18
64533: PPUSH
64534: LD_INT 22
64536: PUSH
64537: LD_VAR 0 16
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: LD_INT 2
64548: PUSH
64549: LD_INT 30
64551: PUSH
64552: LD_INT 2
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: PUSH
64559: LD_INT 30
64561: PUSH
64562: LD_INT 3
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: LIST
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: PPUSH
64578: CALL_OW 72
64582: ST_TO_ADDR
64583: GO 64667
64585: LD_INT 4
64587: DOUBLE
64588: EQUAL
64589: IFTRUE 64593
64591: GO 64666
64593: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
64594: LD_ADDR_VAR 0 12
64598: PUSH
64599: LD_VAR 0 18
64603: PPUSH
64604: LD_INT 22
64606: PUSH
64607: LD_VAR 0 16
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_INT 2
64618: PUSH
64619: LD_INT 30
64621: PUSH
64622: LD_INT 6
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 30
64631: PUSH
64632: LD_INT 7
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 30
64641: PUSH
64642: LD_INT 8
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: EMPTY
64650: LIST
64651: LIST
64652: LIST
64653: LIST
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PPUSH
64659: CALL_OW 72
64663: ST_TO_ADDR
64664: GO 64667
64666: POP
// if i = 1 then
64667: LD_VAR 0 8
64671: PUSH
64672: LD_INT 1
64674: EQUAL
64675: IFFALSE 64786
// begin tmp := [ ] ;
64677: LD_ADDR_VAR 0 19
64681: PUSH
64682: EMPTY
64683: ST_TO_ADDR
// for j in f do
64684: LD_ADDR_VAR 0 9
64688: PUSH
64689: LD_VAR 0 12
64693: PUSH
64694: FOR_IN
64695: IFFALSE 64768
// if GetBType ( j ) = b_bunker then
64697: LD_VAR 0 9
64701: PPUSH
64702: CALL_OW 266
64706: PUSH
64707: LD_INT 32
64709: EQUAL
64710: IFFALSE 64737
// tmp := Insert ( tmp , 1 , j ) else
64712: LD_ADDR_VAR 0 19
64716: PUSH
64717: LD_VAR 0 19
64721: PPUSH
64722: LD_INT 1
64724: PPUSH
64725: LD_VAR 0 9
64729: PPUSH
64730: CALL_OW 2
64734: ST_TO_ADDR
64735: GO 64766
// tmp := Insert ( tmp , tmp + 1 , j ) ;
64737: LD_ADDR_VAR 0 19
64741: PUSH
64742: LD_VAR 0 19
64746: PPUSH
64747: LD_VAR 0 19
64751: PUSH
64752: LD_INT 1
64754: PLUS
64755: PPUSH
64756: LD_VAR 0 9
64760: PPUSH
64761: CALL_OW 2
64765: ST_TO_ADDR
64766: GO 64694
64768: POP
64769: POP
// if tmp then
64770: LD_VAR 0 19
64774: IFFALSE 64786
// f := tmp ;
64776: LD_ADDR_VAR 0 12
64780: PUSH
64781: LD_VAR 0 19
64785: ST_TO_ADDR
// end ; x := personel [ i ] ;
64786: LD_ADDR_VAR 0 13
64790: PUSH
64791: LD_VAR 0 6
64795: PUSH
64796: LD_VAR 0 8
64800: ARRAY
64801: ST_TO_ADDR
// if x = - 1 then
64802: LD_VAR 0 13
64806: PUSH
64807: LD_INT 1
64809: NEG
64810: EQUAL
64811: IFFALSE 65020
// begin for j in f do
64813: LD_ADDR_VAR 0 9
64817: PUSH
64818: LD_VAR 0 12
64822: PUSH
64823: FOR_IN
64824: IFFALSE 65016
// repeat InitHc ;
64826: CALL_OW 19
// if GetBType ( j ) = b_barracks then
64830: LD_VAR 0 9
64834: PPUSH
64835: CALL_OW 266
64839: PUSH
64840: LD_INT 5
64842: EQUAL
64843: IFFALSE 64913
// begin if UnitsInside ( j ) < 3 then
64845: LD_VAR 0 9
64849: PPUSH
64850: CALL_OW 313
64854: PUSH
64855: LD_INT 3
64857: LESS
64858: IFFALSE 64894
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
64860: LD_INT 0
64862: PPUSH
64863: LD_INT 5
64865: PUSH
64866: LD_INT 8
64868: PUSH
64869: LD_INT 9
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: LIST
64876: PUSH
64877: LD_VAR 0 17
64881: ARRAY
64882: PPUSH
64883: LD_VAR 0 4
64887: PPUSH
64888: CALL_OW 380
64892: GO 64911
// PrepareHuman ( false , i , skill ) ;
64894: LD_INT 0
64896: PPUSH
64897: LD_VAR 0 8
64901: PPUSH
64902: LD_VAR 0 4
64906: PPUSH
64907: CALL_OW 380
// end else
64911: GO 64930
// PrepareHuman ( false , i , skill ) ;
64913: LD_INT 0
64915: PPUSH
64916: LD_VAR 0 8
64920: PPUSH
64921: LD_VAR 0 4
64925: PPUSH
64926: CALL_OW 380
// un := CreateHuman ;
64930: LD_ADDR_VAR 0 14
64934: PUSH
64935: CALL_OW 44
64939: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64940: LD_ADDR_VAR 0 7
64944: PUSH
64945: LD_VAR 0 7
64949: PPUSH
64950: LD_INT 1
64952: PPUSH
64953: LD_VAR 0 14
64957: PPUSH
64958: CALL_OW 2
64962: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
64963: LD_VAR 0 14
64967: PPUSH
64968: LD_VAR 0 9
64972: PPUSH
64973: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
64977: LD_VAR 0 9
64981: PPUSH
64982: CALL_OW 313
64986: PUSH
64987: LD_INT 6
64989: EQUAL
64990: PUSH
64991: LD_VAR 0 9
64995: PPUSH
64996: CALL_OW 266
65000: PUSH
65001: LD_INT 32
65003: PUSH
65004: LD_INT 31
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: IN
65011: OR
65012: IFFALSE 64826
65014: GO 64823
65016: POP
65017: POP
// end else
65018: GO 65400
// for j = 1 to x do
65020: LD_ADDR_VAR 0 9
65024: PUSH
65025: DOUBLE
65026: LD_INT 1
65028: DEC
65029: ST_TO_ADDR
65030: LD_VAR 0 13
65034: PUSH
65035: FOR_TO
65036: IFFALSE 65398
// begin InitHc ;
65038: CALL_OW 19
// if not f then
65042: LD_VAR 0 12
65046: NOT
65047: IFFALSE 65136
// begin PrepareHuman ( false , i , skill ) ;
65049: LD_INT 0
65051: PPUSH
65052: LD_VAR 0 8
65056: PPUSH
65057: LD_VAR 0 4
65061: PPUSH
65062: CALL_OW 380
// un := CreateHuman ;
65066: LD_ADDR_VAR 0 14
65070: PUSH
65071: CALL_OW 44
65075: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
65076: LD_ADDR_VAR 0 7
65080: PUSH
65081: LD_VAR 0 7
65085: PPUSH
65086: LD_INT 1
65088: PPUSH
65089: LD_VAR 0 14
65093: PPUSH
65094: CALL_OW 2
65098: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
65099: LD_VAR 0 14
65103: PPUSH
65104: LD_VAR 0 1
65108: PPUSH
65109: CALL_OW 250
65113: PPUSH
65114: LD_VAR 0 1
65118: PPUSH
65119: CALL_OW 251
65123: PPUSH
65124: LD_INT 10
65126: PPUSH
65127: LD_INT 0
65129: PPUSH
65130: CALL_OW 50
// continue ;
65134: GO 65035
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
65136: LD_VAR 0 12
65140: PUSH
65141: LD_INT 1
65143: ARRAY
65144: PPUSH
65145: CALL_OW 313
65149: PUSH
65150: LD_VAR 0 12
65154: PUSH
65155: LD_INT 1
65157: ARRAY
65158: PPUSH
65159: CALL_OW 266
65163: PUSH
65164: LD_INT 32
65166: PUSH
65167: LD_INT 31
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: IN
65174: AND
65175: PUSH
65176: LD_VAR 0 12
65180: PUSH
65181: LD_INT 1
65183: ARRAY
65184: PPUSH
65185: CALL_OW 313
65189: PUSH
65190: LD_INT 6
65192: EQUAL
65193: OR
65194: IFFALSE 65214
// f := Delete ( f , 1 ) ;
65196: LD_ADDR_VAR 0 12
65200: PUSH
65201: LD_VAR 0 12
65205: PPUSH
65206: LD_INT 1
65208: PPUSH
65209: CALL_OW 3
65213: ST_TO_ADDR
// if not f then
65214: LD_VAR 0 12
65218: NOT
65219: IFFALSE 65237
// begin x := x + 2 ;
65221: LD_ADDR_VAR 0 13
65225: PUSH
65226: LD_VAR 0 13
65230: PUSH
65231: LD_INT 2
65233: PLUS
65234: ST_TO_ADDR
// continue ;
65235: GO 65035
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
65237: LD_VAR 0 12
65241: PUSH
65242: LD_INT 1
65244: ARRAY
65245: PPUSH
65246: CALL_OW 266
65250: PUSH
65251: LD_INT 5
65253: EQUAL
65254: IFFALSE 65328
// begin if UnitsInside ( f [ 1 ] ) < 3 then
65256: LD_VAR 0 12
65260: PUSH
65261: LD_INT 1
65263: ARRAY
65264: PPUSH
65265: CALL_OW 313
65269: PUSH
65270: LD_INT 3
65272: LESS
65273: IFFALSE 65309
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
65275: LD_INT 0
65277: PPUSH
65278: LD_INT 5
65280: PUSH
65281: LD_INT 8
65283: PUSH
65284: LD_INT 9
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: LIST
65291: PUSH
65292: LD_VAR 0 17
65296: ARRAY
65297: PPUSH
65298: LD_VAR 0 4
65302: PPUSH
65303: CALL_OW 380
65307: GO 65326
// PrepareHuman ( false , i , skill ) ;
65309: LD_INT 0
65311: PPUSH
65312: LD_VAR 0 8
65316: PPUSH
65317: LD_VAR 0 4
65321: PPUSH
65322: CALL_OW 380
// end else
65326: GO 65345
// PrepareHuman ( false , i , skill ) ;
65328: LD_INT 0
65330: PPUSH
65331: LD_VAR 0 8
65335: PPUSH
65336: LD_VAR 0 4
65340: PPUSH
65341: CALL_OW 380
// un := CreateHuman ;
65345: LD_ADDR_VAR 0 14
65349: PUSH
65350: CALL_OW 44
65354: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
65355: LD_ADDR_VAR 0 7
65359: PUSH
65360: LD_VAR 0 7
65364: PPUSH
65365: LD_INT 1
65367: PPUSH
65368: LD_VAR 0 14
65372: PPUSH
65373: CALL_OW 2
65377: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
65378: LD_VAR 0 14
65382: PPUSH
65383: LD_VAR 0 12
65387: PUSH
65388: LD_INT 1
65390: ARRAY
65391: PPUSH
65392: CALL_OW 52
// end ;
65396: GO 65035
65398: POP
65399: POP
// end ;
65400: GO 64337
65402: POP
65403: POP
// result := result ^ buildings ;
65404: LD_ADDR_VAR 0 7
65408: PUSH
65409: LD_VAR 0 7
65413: PUSH
65414: LD_VAR 0 18
65418: ADD
65419: ST_TO_ADDR
// end else
65420: GO 65563
// begin for i = 1 to personel do
65422: LD_ADDR_VAR 0 8
65426: PUSH
65427: DOUBLE
65428: LD_INT 1
65430: DEC
65431: ST_TO_ADDR
65432: LD_VAR 0 6
65436: PUSH
65437: FOR_TO
65438: IFFALSE 65561
// begin if i > 4 then
65440: LD_VAR 0 8
65444: PUSH
65445: LD_INT 4
65447: GREATER
65448: IFFALSE 65452
// break ;
65450: GO 65561
// x := personel [ i ] ;
65452: LD_ADDR_VAR 0 13
65456: PUSH
65457: LD_VAR 0 6
65461: PUSH
65462: LD_VAR 0 8
65466: ARRAY
65467: ST_TO_ADDR
// if x = - 1 then
65468: LD_VAR 0 13
65472: PUSH
65473: LD_INT 1
65475: NEG
65476: EQUAL
65477: IFFALSE 65481
// continue ;
65479: GO 65437
// PrepareHuman ( false , i , skill ) ;
65481: LD_INT 0
65483: PPUSH
65484: LD_VAR 0 8
65488: PPUSH
65489: LD_VAR 0 4
65493: PPUSH
65494: CALL_OW 380
// un := CreateHuman ;
65498: LD_ADDR_VAR 0 14
65502: PUSH
65503: CALL_OW 44
65507: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
65508: LD_VAR 0 14
65512: PPUSH
65513: LD_VAR 0 1
65517: PPUSH
65518: CALL_OW 250
65522: PPUSH
65523: LD_VAR 0 1
65527: PPUSH
65528: CALL_OW 251
65532: PPUSH
65533: LD_INT 10
65535: PPUSH
65536: LD_INT 0
65538: PPUSH
65539: CALL_OW 50
// result := result ^ un ;
65543: LD_ADDR_VAR 0 7
65547: PUSH
65548: LD_VAR 0 7
65552: PUSH
65553: LD_VAR 0 14
65557: ADD
65558: ST_TO_ADDR
// end ;
65559: GO 65437
65561: POP
65562: POP
// end ; end ;
65563: LD_VAR 0 7
65567: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
65568: LD_INT 0
65570: PPUSH
65571: PPUSH
65572: PPUSH
65573: PPUSH
65574: PPUSH
65575: PPUSH
65576: PPUSH
65577: PPUSH
65578: PPUSH
65579: PPUSH
65580: PPUSH
65581: PPUSH
65582: PPUSH
65583: PPUSH
65584: PPUSH
65585: PPUSH
// result := false ;
65586: LD_ADDR_VAR 0 3
65590: PUSH
65591: LD_INT 0
65593: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
65594: LD_VAR 0 1
65598: NOT
65599: PUSH
65600: LD_VAR 0 1
65604: PPUSH
65605: CALL_OW 266
65609: PUSH
65610: LD_INT 32
65612: PUSH
65613: LD_INT 33
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: IN
65620: NOT
65621: OR
65622: IFFALSE 65626
// exit ;
65624: GO 66762
// nat := GetNation ( tower ) ;
65626: LD_ADDR_VAR 0 12
65630: PUSH
65631: LD_VAR 0 1
65635: PPUSH
65636: CALL_OW 248
65640: ST_TO_ADDR
// side := GetSide ( tower ) ;
65641: LD_ADDR_VAR 0 16
65645: PUSH
65646: LD_VAR 0 1
65650: PPUSH
65651: CALL_OW 255
65655: ST_TO_ADDR
// x := GetX ( tower ) ;
65656: LD_ADDR_VAR 0 10
65660: PUSH
65661: LD_VAR 0 1
65665: PPUSH
65666: CALL_OW 250
65670: ST_TO_ADDR
// y := GetY ( tower ) ;
65671: LD_ADDR_VAR 0 11
65675: PUSH
65676: LD_VAR 0 1
65680: PPUSH
65681: CALL_OW 251
65685: ST_TO_ADDR
// if not x or not y then
65686: LD_VAR 0 10
65690: NOT
65691: PUSH
65692: LD_VAR 0 11
65696: NOT
65697: OR
65698: IFFALSE 65702
// exit ;
65700: GO 66762
// weapon := 0 ;
65702: LD_ADDR_VAR 0 18
65706: PUSH
65707: LD_INT 0
65709: ST_TO_ADDR
// fac_list := [ ] ;
65710: LD_ADDR_VAR 0 17
65714: PUSH
65715: EMPTY
65716: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
65717: LD_ADDR_VAR 0 6
65721: PUSH
65722: LD_VAR 0 1
65726: PPUSH
65727: CALL_OW 274
65731: PPUSH
65732: LD_VAR 0 2
65736: PPUSH
65737: CALL 63340 0 2
65741: PPUSH
65742: LD_INT 30
65744: PUSH
65745: LD_INT 3
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PPUSH
65752: CALL_OW 72
65756: ST_TO_ADDR
// if not factories then
65757: LD_VAR 0 6
65761: NOT
65762: IFFALSE 65766
// exit ;
65764: GO 66762
// for i in factories do
65766: LD_ADDR_VAR 0 8
65770: PUSH
65771: LD_VAR 0 6
65775: PUSH
65776: FOR_IN
65777: IFFALSE 65802
// fac_list := fac_list union AvailableWeaponList ( i ) ;
65779: LD_ADDR_VAR 0 17
65783: PUSH
65784: LD_VAR 0 17
65788: PUSH
65789: LD_VAR 0 8
65793: PPUSH
65794: CALL_OW 478
65798: UNION
65799: ST_TO_ADDR
65800: GO 65776
65802: POP
65803: POP
// if not fac_list then
65804: LD_VAR 0 17
65808: NOT
65809: IFFALSE 65813
// exit ;
65811: GO 66762
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
65813: LD_ADDR_VAR 0 5
65817: PUSH
65818: LD_INT 4
65820: PUSH
65821: LD_INT 5
65823: PUSH
65824: LD_INT 9
65826: PUSH
65827: LD_INT 10
65829: PUSH
65830: LD_INT 6
65832: PUSH
65833: LD_INT 7
65835: PUSH
65836: LD_INT 11
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: PUSH
65848: LD_INT 27
65850: PUSH
65851: LD_INT 28
65853: PUSH
65854: LD_INT 26
65856: PUSH
65857: LD_INT 30
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 43
65868: PUSH
65869: LD_INT 44
65871: PUSH
65872: LD_INT 46
65874: PUSH
65875: LD_INT 45
65877: PUSH
65878: LD_INT 47
65880: PUSH
65881: LD_INT 49
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: PUSH
65892: EMPTY
65893: LIST
65894: LIST
65895: LIST
65896: PUSH
65897: LD_VAR 0 12
65901: ARRAY
65902: ST_TO_ADDR
// for i in list do
65903: LD_ADDR_VAR 0 8
65907: PUSH
65908: LD_VAR 0 5
65912: PUSH
65913: FOR_IN
65914: IFFALSE 65947
// if not i in fac_list then
65916: LD_VAR 0 8
65920: PUSH
65921: LD_VAR 0 17
65925: IN
65926: NOT
65927: IFFALSE 65945
// list := list diff i ;
65929: LD_ADDR_VAR 0 5
65933: PUSH
65934: LD_VAR 0 5
65938: PUSH
65939: LD_VAR 0 8
65943: DIFF
65944: ST_TO_ADDR
65945: GO 65913
65947: POP
65948: POP
// if not list then
65949: LD_VAR 0 5
65953: NOT
65954: IFFALSE 65958
// exit ;
65956: GO 66762
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
65958: LD_VAR 0 12
65962: PUSH
65963: LD_INT 3
65965: EQUAL
65966: PUSH
65967: LD_INT 49
65969: PUSH
65970: LD_VAR 0 5
65974: IN
65975: AND
65976: PUSH
65977: LD_INT 31
65979: PPUSH
65980: LD_VAR 0 16
65984: PPUSH
65985: CALL_OW 321
65989: PUSH
65990: LD_INT 2
65992: EQUAL
65993: AND
65994: IFFALSE 66054
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
65996: LD_INT 22
65998: PUSH
65999: LD_VAR 0 16
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 35
66010: PUSH
66011: LD_INT 49
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 91
66020: PUSH
66021: LD_VAR 0 1
66025: PUSH
66026: LD_INT 10
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: LIST
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: LIST
66038: PPUSH
66039: CALL_OW 69
66043: NOT
66044: IFFALSE 66054
// weapon := ru_time_lapser ;
66046: LD_ADDR_VAR 0 18
66050: PUSH
66051: LD_INT 49
66053: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
66054: LD_VAR 0 12
66058: PUSH
66059: LD_INT 1
66061: PUSH
66062: LD_INT 2
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: IN
66069: PUSH
66070: LD_INT 11
66072: PUSH
66073: LD_VAR 0 5
66077: IN
66078: PUSH
66079: LD_INT 30
66081: PUSH
66082: LD_VAR 0 5
66086: IN
66087: OR
66088: AND
66089: PUSH
66090: LD_INT 6
66092: PPUSH
66093: LD_VAR 0 16
66097: PPUSH
66098: CALL_OW 321
66102: PUSH
66103: LD_INT 2
66105: EQUAL
66106: AND
66107: IFFALSE 66272
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
66109: LD_INT 22
66111: PUSH
66112: LD_VAR 0 16
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PUSH
66121: LD_INT 2
66123: PUSH
66124: LD_INT 35
66126: PUSH
66127: LD_INT 11
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 35
66136: PUSH
66137: LD_INT 30
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 91
66151: PUSH
66152: LD_VAR 0 1
66156: PUSH
66157: LD_INT 18
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: LIST
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: LIST
66169: PPUSH
66170: CALL_OW 69
66174: NOT
66175: PUSH
66176: LD_INT 22
66178: PUSH
66179: LD_VAR 0 16
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: LD_INT 2
66190: PUSH
66191: LD_INT 30
66193: PUSH
66194: LD_INT 32
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: LD_INT 30
66203: PUSH
66204: LD_INT 33
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 91
66218: PUSH
66219: LD_VAR 0 1
66223: PUSH
66224: LD_INT 12
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: LIST
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: LIST
66236: PUSH
66237: EMPTY
66238: LIST
66239: PPUSH
66240: CALL_OW 69
66244: PUSH
66245: LD_INT 2
66247: GREATER
66248: AND
66249: IFFALSE 66272
// weapon := [ us_radar , ar_radar ] [ nat ] ;
66251: LD_ADDR_VAR 0 18
66255: PUSH
66256: LD_INT 11
66258: PUSH
66259: LD_INT 30
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_VAR 0 12
66270: ARRAY
66271: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
66272: LD_VAR 0 18
66276: NOT
66277: PUSH
66278: LD_INT 40
66280: PPUSH
66281: LD_VAR 0 16
66285: PPUSH
66286: CALL_OW 321
66290: PUSH
66291: LD_INT 2
66293: EQUAL
66294: AND
66295: PUSH
66296: LD_INT 7
66298: PUSH
66299: LD_VAR 0 5
66303: IN
66304: PUSH
66305: LD_INT 28
66307: PUSH
66308: LD_VAR 0 5
66312: IN
66313: OR
66314: PUSH
66315: LD_INT 45
66317: PUSH
66318: LD_VAR 0 5
66322: IN
66323: OR
66324: AND
66325: IFFALSE 66579
// begin hex := GetHexInfo ( x , y ) ;
66327: LD_ADDR_VAR 0 4
66331: PUSH
66332: LD_VAR 0 10
66336: PPUSH
66337: LD_VAR 0 11
66341: PPUSH
66342: CALL_OW 546
66346: ST_TO_ADDR
// if hex [ 1 ] then
66347: LD_VAR 0 4
66351: PUSH
66352: LD_INT 1
66354: ARRAY
66355: IFFALSE 66359
// exit ;
66357: GO 66762
// height := hex [ 2 ] ;
66359: LD_ADDR_VAR 0 15
66363: PUSH
66364: LD_VAR 0 4
66368: PUSH
66369: LD_INT 2
66371: ARRAY
66372: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
66373: LD_ADDR_VAR 0 14
66377: PUSH
66378: LD_INT 0
66380: PUSH
66381: LD_INT 2
66383: PUSH
66384: LD_INT 3
66386: PUSH
66387: LD_INT 5
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: ST_TO_ADDR
// for i in tmp do
66396: LD_ADDR_VAR 0 8
66400: PUSH
66401: LD_VAR 0 14
66405: PUSH
66406: FOR_IN
66407: IFFALSE 66577
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
66409: LD_ADDR_VAR 0 9
66413: PUSH
66414: LD_VAR 0 10
66418: PPUSH
66419: LD_VAR 0 8
66423: PPUSH
66424: LD_INT 5
66426: PPUSH
66427: CALL_OW 272
66431: PUSH
66432: LD_VAR 0 11
66436: PPUSH
66437: LD_VAR 0 8
66441: PPUSH
66442: LD_INT 5
66444: PPUSH
66445: CALL_OW 273
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
66454: LD_VAR 0 9
66458: PUSH
66459: LD_INT 1
66461: ARRAY
66462: PPUSH
66463: LD_VAR 0 9
66467: PUSH
66468: LD_INT 2
66470: ARRAY
66471: PPUSH
66472: CALL_OW 488
66476: IFFALSE 66575
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
66478: LD_ADDR_VAR 0 4
66482: PUSH
66483: LD_VAR 0 9
66487: PUSH
66488: LD_INT 1
66490: ARRAY
66491: PPUSH
66492: LD_VAR 0 9
66496: PUSH
66497: LD_INT 2
66499: ARRAY
66500: PPUSH
66501: CALL_OW 546
66505: ST_TO_ADDR
// if hex [ 1 ] then
66506: LD_VAR 0 4
66510: PUSH
66511: LD_INT 1
66513: ARRAY
66514: IFFALSE 66518
// continue ;
66516: GO 66406
// h := hex [ 2 ] ;
66518: LD_ADDR_VAR 0 13
66522: PUSH
66523: LD_VAR 0 4
66527: PUSH
66528: LD_INT 2
66530: ARRAY
66531: ST_TO_ADDR
// if h + 7 < height then
66532: LD_VAR 0 13
66536: PUSH
66537: LD_INT 7
66539: PLUS
66540: PUSH
66541: LD_VAR 0 15
66545: LESS
66546: IFFALSE 66575
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
66548: LD_ADDR_VAR 0 18
66552: PUSH
66553: LD_INT 7
66555: PUSH
66556: LD_INT 28
66558: PUSH
66559: LD_INT 45
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: LIST
66566: PUSH
66567: LD_VAR 0 12
66571: ARRAY
66572: ST_TO_ADDR
// break ;
66573: GO 66577
// end ; end ; end ;
66575: GO 66406
66577: POP
66578: POP
// end ; if not weapon then
66579: LD_VAR 0 18
66583: NOT
66584: IFFALSE 66644
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
66586: LD_ADDR_VAR 0 5
66590: PUSH
66591: LD_VAR 0 5
66595: PUSH
66596: LD_INT 11
66598: PUSH
66599: LD_INT 30
66601: PUSH
66602: LD_INT 49
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: LIST
66609: DIFF
66610: ST_TO_ADDR
// if not list then
66611: LD_VAR 0 5
66615: NOT
66616: IFFALSE 66620
// exit ;
66618: GO 66762
// weapon := list [ rand ( 1 , list ) ] ;
66620: LD_ADDR_VAR 0 18
66624: PUSH
66625: LD_VAR 0 5
66629: PUSH
66630: LD_INT 1
66632: PPUSH
66633: LD_VAR 0 5
66637: PPUSH
66638: CALL_OW 12
66642: ARRAY
66643: ST_TO_ADDR
// end ; if weapon then
66644: LD_VAR 0 18
66648: IFFALSE 66762
// begin tmp := CostOfWeapon ( weapon ) ;
66650: LD_ADDR_VAR 0 14
66654: PUSH
66655: LD_VAR 0 18
66659: PPUSH
66660: CALL_OW 451
66664: ST_TO_ADDR
// j := GetBase ( tower ) ;
66665: LD_ADDR_VAR 0 9
66669: PUSH
66670: LD_VAR 0 1
66674: PPUSH
66675: CALL_OW 274
66679: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
66680: LD_VAR 0 9
66684: PPUSH
66685: LD_INT 1
66687: PPUSH
66688: CALL_OW 275
66692: PUSH
66693: LD_VAR 0 14
66697: PUSH
66698: LD_INT 1
66700: ARRAY
66701: GREATEREQUAL
66702: PUSH
66703: LD_VAR 0 9
66707: PPUSH
66708: LD_INT 2
66710: PPUSH
66711: CALL_OW 275
66715: PUSH
66716: LD_VAR 0 14
66720: PUSH
66721: LD_INT 2
66723: ARRAY
66724: GREATEREQUAL
66725: AND
66726: PUSH
66727: LD_VAR 0 9
66731: PPUSH
66732: LD_INT 3
66734: PPUSH
66735: CALL_OW 275
66739: PUSH
66740: LD_VAR 0 14
66744: PUSH
66745: LD_INT 3
66747: ARRAY
66748: GREATEREQUAL
66749: AND
66750: IFFALSE 66762
// result := weapon ;
66752: LD_ADDR_VAR 0 3
66756: PUSH
66757: LD_VAR 0 18
66761: ST_TO_ADDR
// end ; end ;
66762: LD_VAR 0 3
66766: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
66767: LD_INT 0
66769: PPUSH
66770: PPUSH
// result := true ;
66771: LD_ADDR_VAR 0 3
66775: PUSH
66776: LD_INT 1
66778: ST_TO_ADDR
// if array1 = array2 then
66779: LD_VAR 0 1
66783: PUSH
66784: LD_VAR 0 2
66788: EQUAL
66789: IFFALSE 66849
// begin for i = 1 to array1 do
66791: LD_ADDR_VAR 0 4
66795: PUSH
66796: DOUBLE
66797: LD_INT 1
66799: DEC
66800: ST_TO_ADDR
66801: LD_VAR 0 1
66805: PUSH
66806: FOR_TO
66807: IFFALSE 66845
// if array1 [ i ] <> array2 [ i ] then
66809: LD_VAR 0 1
66813: PUSH
66814: LD_VAR 0 4
66818: ARRAY
66819: PUSH
66820: LD_VAR 0 2
66824: PUSH
66825: LD_VAR 0 4
66829: ARRAY
66830: NONEQUAL
66831: IFFALSE 66843
// begin result := false ;
66833: LD_ADDR_VAR 0 3
66837: PUSH
66838: LD_INT 0
66840: ST_TO_ADDR
// break ;
66841: GO 66845
// end ;
66843: GO 66806
66845: POP
66846: POP
// end else
66847: GO 66857
// result := false ;
66849: LD_ADDR_VAR 0 3
66853: PUSH
66854: LD_INT 0
66856: ST_TO_ADDR
// end ;
66857: LD_VAR 0 3
66861: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
66862: LD_INT 0
66864: PPUSH
66865: PPUSH
66866: PPUSH
// pom := GetBase ( fac ) ;
66867: LD_ADDR_VAR 0 5
66871: PUSH
66872: LD_VAR 0 1
66876: PPUSH
66877: CALL_OW 274
66881: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
66882: LD_ADDR_VAR 0 4
66886: PUSH
66887: LD_VAR 0 2
66891: PUSH
66892: LD_INT 1
66894: ARRAY
66895: PPUSH
66896: LD_VAR 0 2
66900: PUSH
66901: LD_INT 2
66903: ARRAY
66904: PPUSH
66905: LD_VAR 0 2
66909: PUSH
66910: LD_INT 3
66912: ARRAY
66913: PPUSH
66914: LD_VAR 0 2
66918: PUSH
66919: LD_INT 4
66921: ARRAY
66922: PPUSH
66923: CALL_OW 449
66927: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66928: LD_ADDR_VAR 0 3
66932: PUSH
66933: LD_VAR 0 5
66937: PPUSH
66938: LD_INT 1
66940: PPUSH
66941: CALL_OW 275
66945: PUSH
66946: LD_VAR 0 4
66950: PUSH
66951: LD_INT 1
66953: ARRAY
66954: GREATEREQUAL
66955: PUSH
66956: LD_VAR 0 5
66960: PPUSH
66961: LD_INT 2
66963: PPUSH
66964: CALL_OW 275
66968: PUSH
66969: LD_VAR 0 4
66973: PUSH
66974: LD_INT 2
66976: ARRAY
66977: GREATEREQUAL
66978: AND
66979: PUSH
66980: LD_VAR 0 5
66984: PPUSH
66985: LD_INT 3
66987: PPUSH
66988: CALL_OW 275
66992: PUSH
66993: LD_VAR 0 4
66997: PUSH
66998: LD_INT 3
67000: ARRAY
67001: GREATEREQUAL
67002: AND
67003: ST_TO_ADDR
// end ;
67004: LD_VAR 0 3
67008: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
67009: LD_INT 0
67011: PPUSH
67012: PPUSH
67013: PPUSH
67014: PPUSH
// pom := GetBase ( building ) ;
67015: LD_ADDR_VAR 0 3
67019: PUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL_OW 274
67029: ST_TO_ADDR
// if not pom then
67030: LD_VAR 0 3
67034: NOT
67035: IFFALSE 67039
// exit ;
67037: GO 67209
// btype := GetBType ( building ) ;
67039: LD_ADDR_VAR 0 5
67043: PUSH
67044: LD_VAR 0 1
67048: PPUSH
67049: CALL_OW 266
67053: ST_TO_ADDR
// if btype = b_armoury then
67054: LD_VAR 0 5
67058: PUSH
67059: LD_INT 4
67061: EQUAL
67062: IFFALSE 67072
// btype := b_barracks ;
67064: LD_ADDR_VAR 0 5
67068: PUSH
67069: LD_INT 5
67071: ST_TO_ADDR
// if btype = b_depot then
67072: LD_VAR 0 5
67076: PUSH
67077: LD_INT 0
67079: EQUAL
67080: IFFALSE 67090
// btype := b_warehouse ;
67082: LD_ADDR_VAR 0 5
67086: PUSH
67087: LD_INT 1
67089: ST_TO_ADDR
// if btype = b_workshop then
67090: LD_VAR 0 5
67094: PUSH
67095: LD_INT 2
67097: EQUAL
67098: IFFALSE 67108
// btype := b_factory ;
67100: LD_ADDR_VAR 0 5
67104: PUSH
67105: LD_INT 3
67107: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
67108: LD_ADDR_VAR 0 4
67112: PUSH
67113: LD_VAR 0 5
67117: PPUSH
67118: LD_VAR 0 1
67122: PPUSH
67123: CALL_OW 248
67127: PPUSH
67128: CALL_OW 450
67132: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
67133: LD_ADDR_VAR 0 2
67137: PUSH
67138: LD_VAR 0 3
67142: PPUSH
67143: LD_INT 1
67145: PPUSH
67146: CALL_OW 275
67150: PUSH
67151: LD_VAR 0 4
67155: PUSH
67156: LD_INT 1
67158: ARRAY
67159: GREATEREQUAL
67160: PUSH
67161: LD_VAR 0 3
67165: PPUSH
67166: LD_INT 2
67168: PPUSH
67169: CALL_OW 275
67173: PUSH
67174: LD_VAR 0 4
67178: PUSH
67179: LD_INT 2
67181: ARRAY
67182: GREATEREQUAL
67183: AND
67184: PUSH
67185: LD_VAR 0 3
67189: PPUSH
67190: LD_INT 3
67192: PPUSH
67193: CALL_OW 275
67197: PUSH
67198: LD_VAR 0 4
67202: PUSH
67203: LD_INT 3
67205: ARRAY
67206: GREATEREQUAL
67207: AND
67208: ST_TO_ADDR
// end ;
67209: LD_VAR 0 2
67213: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
67214: LD_INT 0
67216: PPUSH
67217: PPUSH
67218: PPUSH
// pom := GetBase ( building ) ;
67219: LD_ADDR_VAR 0 4
67223: PUSH
67224: LD_VAR 0 1
67228: PPUSH
67229: CALL_OW 274
67233: ST_TO_ADDR
// if not pom then
67234: LD_VAR 0 4
67238: NOT
67239: IFFALSE 67243
// exit ;
67241: GO 67344
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
67243: LD_ADDR_VAR 0 5
67247: PUSH
67248: LD_VAR 0 2
67252: PPUSH
67253: LD_VAR 0 1
67257: PPUSH
67258: CALL_OW 248
67262: PPUSH
67263: CALL_OW 450
67267: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
67268: LD_ADDR_VAR 0 3
67272: PUSH
67273: LD_VAR 0 4
67277: PPUSH
67278: LD_INT 1
67280: PPUSH
67281: CALL_OW 275
67285: PUSH
67286: LD_VAR 0 5
67290: PUSH
67291: LD_INT 1
67293: ARRAY
67294: GREATEREQUAL
67295: PUSH
67296: LD_VAR 0 4
67300: PPUSH
67301: LD_INT 2
67303: PPUSH
67304: CALL_OW 275
67308: PUSH
67309: LD_VAR 0 5
67313: PUSH
67314: LD_INT 2
67316: ARRAY
67317: GREATEREQUAL
67318: AND
67319: PUSH
67320: LD_VAR 0 4
67324: PPUSH
67325: LD_INT 3
67327: PPUSH
67328: CALL_OW 275
67332: PUSH
67333: LD_VAR 0 5
67337: PUSH
67338: LD_INT 3
67340: ARRAY
67341: GREATEREQUAL
67342: AND
67343: ST_TO_ADDR
// end ;
67344: LD_VAR 0 3
67348: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
67349: LD_INT 0
67351: PPUSH
67352: PPUSH
67353: PPUSH
67354: PPUSH
67355: PPUSH
67356: PPUSH
67357: PPUSH
67358: PPUSH
67359: PPUSH
67360: PPUSH
// result := false ;
67361: LD_ADDR_VAR 0 6
67365: PUSH
67366: LD_INT 0
67368: ST_TO_ADDR
// if not base or not btype or not x or not y then
67369: LD_VAR 0 1
67373: NOT
67374: PUSH
67375: LD_VAR 0 2
67379: NOT
67380: OR
67381: PUSH
67382: LD_VAR 0 3
67386: NOT
67387: OR
67388: PUSH
67389: LD_VAR 0 4
67393: NOT
67394: OR
67395: IFFALSE 67399
// exit ;
67397: GO 67990
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
67399: LD_ADDR_VAR 0 12
67403: PUSH
67404: LD_VAR 0 2
67408: PPUSH
67409: LD_VAR 0 3
67413: PPUSH
67414: LD_VAR 0 4
67418: PPUSH
67419: LD_VAR 0 5
67423: PPUSH
67424: LD_VAR 0 1
67428: PUSH
67429: LD_INT 1
67431: ARRAY
67432: PPUSH
67433: CALL_OW 248
67437: PPUSH
67438: LD_INT 0
67440: PPUSH
67441: CALL 68827 0 6
67445: ST_TO_ADDR
// if not hexes then
67446: LD_VAR 0 12
67450: NOT
67451: IFFALSE 67455
// exit ;
67453: GO 67990
// for i = 1 to hexes do
67455: LD_ADDR_VAR 0 7
67459: PUSH
67460: DOUBLE
67461: LD_INT 1
67463: DEC
67464: ST_TO_ADDR
67465: LD_VAR 0 12
67469: PUSH
67470: FOR_TO
67471: IFFALSE 67988
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67473: LD_ADDR_VAR 0 11
67477: PUSH
67478: LD_VAR 0 12
67482: PUSH
67483: LD_VAR 0 7
67487: ARRAY
67488: PUSH
67489: LD_INT 1
67491: ARRAY
67492: PPUSH
67493: LD_VAR 0 12
67497: PUSH
67498: LD_VAR 0 7
67502: ARRAY
67503: PUSH
67504: LD_INT 2
67506: ARRAY
67507: PPUSH
67508: CALL_OW 428
67512: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
67513: LD_VAR 0 12
67517: PUSH
67518: LD_VAR 0 7
67522: ARRAY
67523: PUSH
67524: LD_INT 1
67526: ARRAY
67527: PPUSH
67528: LD_VAR 0 12
67532: PUSH
67533: LD_VAR 0 7
67537: ARRAY
67538: PUSH
67539: LD_INT 2
67541: ARRAY
67542: PPUSH
67543: CALL_OW 351
67547: PUSH
67548: LD_VAR 0 12
67552: PUSH
67553: LD_VAR 0 7
67557: ARRAY
67558: PUSH
67559: LD_INT 1
67561: ARRAY
67562: PPUSH
67563: LD_VAR 0 12
67567: PUSH
67568: LD_VAR 0 7
67572: ARRAY
67573: PUSH
67574: LD_INT 2
67576: ARRAY
67577: PPUSH
67578: CALL_OW 488
67582: NOT
67583: OR
67584: PUSH
67585: LD_VAR 0 11
67589: PPUSH
67590: CALL_OW 247
67594: PUSH
67595: LD_INT 3
67597: EQUAL
67598: OR
67599: IFFALSE 67605
// exit ;
67601: POP
67602: POP
67603: GO 67990
// if not tmp then
67605: LD_VAR 0 11
67609: NOT
67610: IFFALSE 67614
// continue ;
67612: GO 67470
// result := true ;
67614: LD_ADDR_VAR 0 6
67618: PUSH
67619: LD_INT 1
67621: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
67622: LD_ADDR_VAR 0 15
67626: PUSH
67627: LD_INT 22
67629: PUSH
67630: LD_VAR 0 11
67634: PPUSH
67635: CALL_OW 255
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: PUSH
67644: LD_INT 2
67646: PUSH
67647: LD_INT 30
67649: PUSH
67650: LD_INT 0
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 30
67659: PUSH
67660: LD_INT 1
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: LIST
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PPUSH
67676: CALL_OW 69
67680: ST_TO_ADDR
// if dep then
67681: LD_VAR 0 15
67685: IFFALSE 67821
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
67687: LD_ADDR_VAR 0 14
67691: PUSH
67692: LD_VAR 0 15
67696: PUSH
67697: LD_INT 1
67699: ARRAY
67700: PPUSH
67701: CALL_OW 250
67705: PPUSH
67706: LD_VAR 0 15
67710: PUSH
67711: LD_INT 1
67713: ARRAY
67714: PPUSH
67715: CALL_OW 254
67719: PPUSH
67720: LD_INT 5
67722: PPUSH
67723: CALL_OW 272
67727: PUSH
67728: LD_VAR 0 15
67732: PUSH
67733: LD_INT 1
67735: ARRAY
67736: PPUSH
67737: CALL_OW 251
67741: PPUSH
67742: LD_VAR 0 15
67746: PUSH
67747: LD_INT 1
67749: ARRAY
67750: PPUSH
67751: CALL_OW 254
67755: PPUSH
67756: LD_INT 5
67758: PPUSH
67759: CALL_OW 273
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
67768: LD_VAR 0 14
67772: PUSH
67773: LD_INT 1
67775: ARRAY
67776: PPUSH
67777: LD_VAR 0 14
67781: PUSH
67782: LD_INT 2
67784: ARRAY
67785: PPUSH
67786: CALL_OW 488
67790: IFFALSE 67821
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
67792: LD_VAR 0 11
67796: PPUSH
67797: LD_VAR 0 14
67801: PUSH
67802: LD_INT 1
67804: ARRAY
67805: PPUSH
67806: LD_VAR 0 14
67810: PUSH
67811: LD_INT 2
67813: ARRAY
67814: PPUSH
67815: CALL_OW 111
// continue ;
67819: GO 67470
// end ; end ; r := GetDir ( tmp ) ;
67821: LD_ADDR_VAR 0 13
67825: PUSH
67826: LD_VAR 0 11
67830: PPUSH
67831: CALL_OW 254
67835: ST_TO_ADDR
// if r = 5 then
67836: LD_VAR 0 13
67840: PUSH
67841: LD_INT 5
67843: EQUAL
67844: IFFALSE 67854
// r := 0 ;
67846: LD_ADDR_VAR 0 13
67850: PUSH
67851: LD_INT 0
67853: ST_TO_ADDR
// for j = r to 5 do
67854: LD_ADDR_VAR 0 8
67858: PUSH
67859: DOUBLE
67860: LD_VAR 0 13
67864: DEC
67865: ST_TO_ADDR
67866: LD_INT 5
67868: PUSH
67869: FOR_TO
67870: IFFALSE 67984
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
67872: LD_ADDR_VAR 0 9
67876: PUSH
67877: LD_VAR 0 11
67881: PPUSH
67882: CALL_OW 250
67886: PPUSH
67887: LD_VAR 0 8
67891: PPUSH
67892: LD_INT 2
67894: PPUSH
67895: CALL_OW 272
67899: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
67900: LD_ADDR_VAR 0 10
67904: PUSH
67905: LD_VAR 0 11
67909: PPUSH
67910: CALL_OW 251
67914: PPUSH
67915: LD_VAR 0 8
67919: PPUSH
67920: LD_INT 2
67922: PPUSH
67923: CALL_OW 273
67927: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
67928: LD_VAR 0 9
67932: PPUSH
67933: LD_VAR 0 10
67937: PPUSH
67938: CALL_OW 488
67942: PUSH
67943: LD_VAR 0 9
67947: PPUSH
67948: LD_VAR 0 10
67952: PPUSH
67953: CALL_OW 428
67957: NOT
67958: AND
67959: IFFALSE 67982
// begin ComMoveXY ( tmp , _x , _y ) ;
67961: LD_VAR 0 11
67965: PPUSH
67966: LD_VAR 0 9
67970: PPUSH
67971: LD_VAR 0 10
67975: PPUSH
67976: CALL_OW 111
// break ;
67980: GO 67984
// end ; end ;
67982: GO 67869
67984: POP
67985: POP
// end ;
67986: GO 67470
67988: POP
67989: POP
// end ;
67990: LD_VAR 0 6
67994: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
67995: LD_INT 0
67997: PPUSH
67998: PPUSH
67999: PPUSH
68000: PPUSH
68001: PPUSH
68002: PPUSH
68003: PPUSH
68004: PPUSH
68005: PPUSH
68006: PPUSH
// result := false ;
68007: LD_ADDR_VAR 0 6
68011: PUSH
68012: LD_INT 0
68014: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
68015: LD_VAR 0 1
68019: NOT
68020: PUSH
68021: LD_VAR 0 1
68025: PPUSH
68026: CALL_OW 266
68030: PUSH
68031: LD_INT 0
68033: PUSH
68034: LD_INT 1
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: IN
68041: NOT
68042: OR
68043: PUSH
68044: LD_VAR 0 2
68048: NOT
68049: OR
68050: PUSH
68051: LD_VAR 0 5
68055: PUSH
68056: LD_INT 0
68058: PUSH
68059: LD_INT 1
68061: PUSH
68062: LD_INT 2
68064: PUSH
68065: LD_INT 3
68067: PUSH
68068: LD_INT 4
68070: PUSH
68071: LD_INT 5
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: IN
68082: NOT
68083: OR
68084: PUSH
68085: LD_VAR 0 3
68089: PPUSH
68090: LD_VAR 0 4
68094: PPUSH
68095: CALL_OW 488
68099: NOT
68100: OR
68101: IFFALSE 68105
// exit ;
68103: GO 68822
// pom := GetBase ( bdepot ) ;
68105: LD_ADDR_VAR 0 10
68109: PUSH
68110: LD_VAR 0 1
68114: PPUSH
68115: CALL_OW 274
68119: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
68120: LD_ADDR_VAR 0 11
68124: PUSH
68125: LD_VAR 0 2
68129: PPUSH
68130: LD_VAR 0 1
68134: PPUSH
68135: CALL_OW 248
68139: PPUSH
68140: CALL_OW 450
68144: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
68145: LD_VAR 0 10
68149: PPUSH
68150: LD_INT 1
68152: PPUSH
68153: CALL_OW 275
68157: PUSH
68158: LD_VAR 0 11
68162: PUSH
68163: LD_INT 1
68165: ARRAY
68166: GREATEREQUAL
68167: PUSH
68168: LD_VAR 0 10
68172: PPUSH
68173: LD_INT 2
68175: PPUSH
68176: CALL_OW 275
68180: PUSH
68181: LD_VAR 0 11
68185: PUSH
68186: LD_INT 2
68188: ARRAY
68189: GREATEREQUAL
68190: AND
68191: PUSH
68192: LD_VAR 0 10
68196: PPUSH
68197: LD_INT 3
68199: PPUSH
68200: CALL_OW 275
68204: PUSH
68205: LD_VAR 0 11
68209: PUSH
68210: LD_INT 3
68212: ARRAY
68213: GREATEREQUAL
68214: AND
68215: NOT
68216: IFFALSE 68220
// exit ;
68218: GO 68822
// if GetBType ( bdepot ) = b_depot then
68220: LD_VAR 0 1
68224: PPUSH
68225: CALL_OW 266
68229: PUSH
68230: LD_INT 0
68232: EQUAL
68233: IFFALSE 68245
// dist := 28 else
68235: LD_ADDR_VAR 0 14
68239: PUSH
68240: LD_INT 28
68242: ST_TO_ADDR
68243: GO 68253
// dist := 36 ;
68245: LD_ADDR_VAR 0 14
68249: PUSH
68250: LD_INT 36
68252: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
68253: LD_VAR 0 1
68257: PPUSH
68258: LD_VAR 0 3
68262: PPUSH
68263: LD_VAR 0 4
68267: PPUSH
68268: CALL_OW 297
68272: PUSH
68273: LD_VAR 0 14
68277: GREATER
68278: IFFALSE 68282
// exit ;
68280: GO 68822
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
68282: LD_ADDR_VAR 0 12
68286: PUSH
68287: LD_VAR 0 2
68291: PPUSH
68292: LD_VAR 0 3
68296: PPUSH
68297: LD_VAR 0 4
68301: PPUSH
68302: LD_VAR 0 5
68306: PPUSH
68307: LD_VAR 0 1
68311: PPUSH
68312: CALL_OW 248
68316: PPUSH
68317: LD_INT 0
68319: PPUSH
68320: CALL 68827 0 6
68324: ST_TO_ADDR
// if not hexes then
68325: LD_VAR 0 12
68329: NOT
68330: IFFALSE 68334
// exit ;
68332: GO 68822
// hex := GetHexInfo ( x , y ) ;
68334: LD_ADDR_VAR 0 15
68338: PUSH
68339: LD_VAR 0 3
68343: PPUSH
68344: LD_VAR 0 4
68348: PPUSH
68349: CALL_OW 546
68353: ST_TO_ADDR
// if hex [ 1 ] then
68354: LD_VAR 0 15
68358: PUSH
68359: LD_INT 1
68361: ARRAY
68362: IFFALSE 68366
// exit ;
68364: GO 68822
// height := hex [ 2 ] ;
68366: LD_ADDR_VAR 0 13
68370: PUSH
68371: LD_VAR 0 15
68375: PUSH
68376: LD_INT 2
68378: ARRAY
68379: ST_TO_ADDR
// for i = 1 to hexes do
68380: LD_ADDR_VAR 0 7
68384: PUSH
68385: DOUBLE
68386: LD_INT 1
68388: DEC
68389: ST_TO_ADDR
68390: LD_VAR 0 12
68394: PUSH
68395: FOR_TO
68396: IFFALSE 68726
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
68398: LD_VAR 0 12
68402: PUSH
68403: LD_VAR 0 7
68407: ARRAY
68408: PUSH
68409: LD_INT 1
68411: ARRAY
68412: PPUSH
68413: LD_VAR 0 12
68417: PUSH
68418: LD_VAR 0 7
68422: ARRAY
68423: PUSH
68424: LD_INT 2
68426: ARRAY
68427: PPUSH
68428: CALL_OW 488
68432: NOT
68433: PUSH
68434: LD_VAR 0 12
68438: PUSH
68439: LD_VAR 0 7
68443: ARRAY
68444: PUSH
68445: LD_INT 1
68447: ARRAY
68448: PPUSH
68449: LD_VAR 0 12
68453: PUSH
68454: LD_VAR 0 7
68458: ARRAY
68459: PUSH
68460: LD_INT 2
68462: ARRAY
68463: PPUSH
68464: CALL_OW 428
68468: PUSH
68469: LD_INT 0
68471: GREATER
68472: OR
68473: PUSH
68474: LD_VAR 0 12
68478: PUSH
68479: LD_VAR 0 7
68483: ARRAY
68484: PUSH
68485: LD_INT 1
68487: ARRAY
68488: PPUSH
68489: LD_VAR 0 12
68493: PUSH
68494: LD_VAR 0 7
68498: ARRAY
68499: PUSH
68500: LD_INT 2
68502: ARRAY
68503: PPUSH
68504: CALL_OW 351
68508: OR
68509: IFFALSE 68515
// exit ;
68511: POP
68512: POP
68513: GO 68822
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
68515: LD_ADDR_VAR 0 8
68519: PUSH
68520: LD_VAR 0 12
68524: PUSH
68525: LD_VAR 0 7
68529: ARRAY
68530: PUSH
68531: LD_INT 1
68533: ARRAY
68534: PPUSH
68535: LD_VAR 0 12
68539: PUSH
68540: LD_VAR 0 7
68544: ARRAY
68545: PUSH
68546: LD_INT 2
68548: ARRAY
68549: PPUSH
68550: CALL_OW 546
68554: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
68555: LD_VAR 0 8
68559: PUSH
68560: LD_INT 1
68562: ARRAY
68563: PUSH
68564: LD_VAR 0 8
68568: PUSH
68569: LD_INT 2
68571: ARRAY
68572: PUSH
68573: LD_VAR 0 13
68577: PUSH
68578: LD_INT 2
68580: PLUS
68581: GREATER
68582: OR
68583: PUSH
68584: LD_VAR 0 8
68588: PUSH
68589: LD_INT 2
68591: ARRAY
68592: PUSH
68593: LD_VAR 0 13
68597: PUSH
68598: LD_INT 2
68600: MINUS
68601: LESS
68602: OR
68603: PUSH
68604: LD_VAR 0 8
68608: PUSH
68609: LD_INT 3
68611: ARRAY
68612: PUSH
68613: LD_INT 0
68615: PUSH
68616: LD_INT 8
68618: PUSH
68619: LD_INT 9
68621: PUSH
68622: LD_INT 10
68624: PUSH
68625: LD_INT 11
68627: PUSH
68628: LD_INT 12
68630: PUSH
68631: LD_INT 13
68633: PUSH
68634: LD_INT 16
68636: PUSH
68637: LD_INT 17
68639: PUSH
68640: LD_INT 18
68642: PUSH
68643: LD_INT 19
68645: PUSH
68646: LD_INT 20
68648: PUSH
68649: LD_INT 21
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: LIST
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: IN
68667: NOT
68668: OR
68669: PUSH
68670: LD_VAR 0 8
68674: PUSH
68675: LD_INT 5
68677: ARRAY
68678: NOT
68679: OR
68680: PUSH
68681: LD_VAR 0 8
68685: PUSH
68686: LD_INT 6
68688: ARRAY
68689: PUSH
68690: LD_INT 1
68692: PUSH
68693: LD_INT 2
68695: PUSH
68696: LD_INT 7
68698: PUSH
68699: LD_INT 9
68701: PUSH
68702: LD_INT 10
68704: PUSH
68705: LD_INT 11
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: IN
68716: NOT
68717: OR
68718: IFFALSE 68724
// exit ;
68720: POP
68721: POP
68722: GO 68822
// end ;
68724: GO 68395
68726: POP
68727: POP
// side := GetSide ( bdepot ) ;
68728: LD_ADDR_VAR 0 9
68732: PUSH
68733: LD_VAR 0 1
68737: PPUSH
68738: CALL_OW 255
68742: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68743: LD_VAR 0 9
68747: PPUSH
68748: LD_VAR 0 3
68752: PPUSH
68753: LD_VAR 0 4
68757: PPUSH
68758: LD_INT 20
68760: PPUSH
68761: CALL 61494 0 4
68765: PUSH
68766: LD_INT 4
68768: ARRAY
68769: IFFALSE 68773
// exit ;
68771: GO 68822
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
68773: LD_VAR 0 2
68777: PUSH
68778: LD_INT 29
68780: PUSH
68781: LD_INT 30
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: IN
68788: PUSH
68789: LD_VAR 0 3
68793: PPUSH
68794: LD_VAR 0 4
68798: PPUSH
68799: LD_VAR 0 9
68803: PPUSH
68804: CALL_OW 440
68808: NOT
68809: AND
68810: IFFALSE 68814
// exit ;
68812: GO 68822
// result := true ;
68814: LD_ADDR_VAR 0 6
68818: PUSH
68819: LD_INT 1
68821: ST_TO_ADDR
// end ;
68822: LD_VAR 0 6
68826: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
68827: LD_INT 0
68829: PPUSH
68830: PPUSH
68831: PPUSH
68832: PPUSH
68833: PPUSH
68834: PPUSH
68835: PPUSH
68836: PPUSH
68837: PPUSH
68838: PPUSH
68839: PPUSH
68840: PPUSH
68841: PPUSH
68842: PPUSH
68843: PPUSH
68844: PPUSH
68845: PPUSH
68846: PPUSH
68847: PPUSH
68848: PPUSH
68849: PPUSH
68850: PPUSH
68851: PPUSH
68852: PPUSH
68853: PPUSH
68854: PPUSH
68855: PPUSH
68856: PPUSH
68857: PPUSH
68858: PPUSH
68859: PPUSH
68860: PPUSH
68861: PPUSH
68862: PPUSH
68863: PPUSH
68864: PPUSH
68865: PPUSH
68866: PPUSH
68867: PPUSH
68868: PPUSH
68869: PPUSH
68870: PPUSH
68871: PPUSH
68872: PPUSH
68873: PPUSH
68874: PPUSH
68875: PPUSH
68876: PPUSH
68877: PPUSH
68878: PPUSH
68879: PPUSH
68880: PPUSH
68881: PPUSH
68882: PPUSH
68883: PPUSH
68884: PPUSH
68885: PPUSH
68886: PPUSH
// result = [ ] ;
68887: LD_ADDR_VAR 0 7
68891: PUSH
68892: EMPTY
68893: ST_TO_ADDR
// temp_list = [ ] ;
68894: LD_ADDR_VAR 0 9
68898: PUSH
68899: EMPTY
68900: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
68901: LD_VAR 0 4
68905: PUSH
68906: LD_INT 0
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: LD_INT 2
68914: PUSH
68915: LD_INT 3
68917: PUSH
68918: LD_INT 4
68920: PUSH
68921: LD_INT 5
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: LIST
68931: IN
68932: NOT
68933: PUSH
68934: LD_VAR 0 1
68938: PUSH
68939: LD_INT 0
68941: PUSH
68942: LD_INT 1
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: IN
68949: PUSH
68950: LD_VAR 0 5
68954: PUSH
68955: LD_INT 1
68957: PUSH
68958: LD_INT 2
68960: PUSH
68961: LD_INT 3
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: LIST
68968: IN
68969: NOT
68970: AND
68971: OR
68972: IFFALSE 68976
// exit ;
68974: GO 87361
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
68976: LD_VAR 0 1
68980: PUSH
68981: LD_INT 6
68983: PUSH
68984: LD_INT 7
68986: PUSH
68987: LD_INT 8
68989: PUSH
68990: LD_INT 13
68992: PUSH
68993: LD_INT 12
68995: PUSH
68996: LD_INT 15
68998: PUSH
68999: LD_INT 11
69001: PUSH
69002: LD_INT 14
69004: PUSH
69005: LD_INT 10
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: IN
69019: IFFALSE 69029
// btype = b_lab ;
69021: LD_ADDR_VAR 0 1
69025: PUSH
69026: LD_INT 6
69028: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
69029: LD_VAR 0 6
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: LD_INT 1
69039: PUSH
69040: LD_INT 2
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: LIST
69047: IN
69048: NOT
69049: PUSH
69050: LD_VAR 0 1
69054: PUSH
69055: LD_INT 0
69057: PUSH
69058: LD_INT 1
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: LD_INT 3
69066: PUSH
69067: LD_INT 6
69069: PUSH
69070: LD_INT 36
69072: PUSH
69073: LD_INT 4
69075: PUSH
69076: LD_INT 5
69078: PUSH
69079: LD_INT 31
69081: PUSH
69082: LD_INT 32
69084: PUSH
69085: LD_INT 33
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: IN
69101: NOT
69102: PUSH
69103: LD_VAR 0 6
69107: PUSH
69108: LD_INT 1
69110: EQUAL
69111: AND
69112: OR
69113: PUSH
69114: LD_VAR 0 1
69118: PUSH
69119: LD_INT 2
69121: PUSH
69122: LD_INT 3
69124: PUSH
69125: EMPTY
69126: LIST
69127: LIST
69128: IN
69129: NOT
69130: PUSH
69131: LD_VAR 0 6
69135: PUSH
69136: LD_INT 2
69138: EQUAL
69139: AND
69140: OR
69141: IFFALSE 69151
// mode = 0 ;
69143: LD_ADDR_VAR 0 6
69147: PUSH
69148: LD_INT 0
69150: ST_TO_ADDR
// case mode of 0 :
69151: LD_VAR 0 6
69155: PUSH
69156: LD_INT 0
69158: DOUBLE
69159: EQUAL
69160: IFTRUE 69164
69162: GO 80617
69164: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69165: LD_ADDR_VAR 0 11
69169: PUSH
69170: LD_INT 0
69172: PUSH
69173: LD_INT 0
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: LD_INT 1
69185: NEG
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: LD_INT 0
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 0
69213: PUSH
69214: LD_INT 1
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: NEG
69224: PUSH
69225: LD_INT 0
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 1
69234: NEG
69235: PUSH
69236: LD_INT 1
69238: NEG
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 1
69246: NEG
69247: PUSH
69248: LD_INT 2
69250: NEG
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PUSH
69256: LD_INT 0
69258: PUSH
69259: LD_INT 2
69261: NEG
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: LD_INT 1
69269: PUSH
69270: LD_INT 1
69272: NEG
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 1
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 1
69300: NEG
69301: PUSH
69302: LD_INT 1
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 1
69311: PUSH
69312: LD_INT 3
69314: PUSH
69315: EMPTY
69316: LIST
69317: LIST
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: LD_INT 3
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: LD_INT 2
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69358: LD_ADDR_VAR 0 12
69362: PUSH
69363: LD_INT 0
69365: PUSH
69366: LD_INT 0
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 0
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 1
69386: PUSH
69387: LD_INT 0
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 1
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 1
69416: NEG
69417: PUSH
69418: LD_INT 0
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 1
69427: NEG
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 2
69450: PUSH
69451: LD_INT 0
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 2
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 1
69470: NEG
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 2
69481: NEG
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 2
69492: NEG
69493: PUSH
69494: LD_INT 1
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 2
69504: NEG
69505: PUSH
69506: LD_INT 1
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 3
69515: NEG
69516: PUSH
69517: LD_INT 0
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 3
69526: NEG
69527: PUSH
69528: LD_INT 1
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69554: LD_ADDR_VAR 0 13
69558: PUSH
69559: LD_INT 0
69561: PUSH
69562: LD_INT 0
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 0
69571: PUSH
69572: LD_INT 1
69574: NEG
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 1
69582: PUSH
69583: LD_INT 0
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 1
69592: PUSH
69593: LD_INT 1
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 0
69602: PUSH
69603: LD_INT 1
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 1
69612: NEG
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: LD_INT 1
69623: NEG
69624: PUSH
69625: LD_INT 1
69627: NEG
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: PUSH
69633: LD_INT 1
69635: NEG
69636: PUSH
69637: LD_INT 2
69639: NEG
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 2
69657: PUSH
69658: LD_INT 2
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: PUSH
69668: LD_INT 2
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 2
69677: NEG
69678: PUSH
69679: LD_INT 1
69681: NEG
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 2
69689: NEG
69690: PUSH
69691: LD_INT 2
69693: NEG
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 2
69701: NEG
69702: PUSH
69703: LD_INT 3
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 3
69713: NEG
69714: PUSH
69715: LD_INT 2
69717: NEG
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 3
69725: NEG
69726: PUSH
69727: LD_INT 3
69729: NEG
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69753: LD_ADDR_VAR 0 14
69757: PUSH
69758: LD_INT 0
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 0
69770: PUSH
69771: LD_INT 1
69773: NEG
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: LD_INT 0
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 1
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: LD_INT 1
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: NEG
69823: PUSH
69824: LD_INT 1
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 1
69834: NEG
69835: PUSH
69836: LD_INT 2
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 0
69846: PUSH
69847: LD_INT 2
69849: NEG
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 1
69857: PUSH
69858: LD_INT 1
69860: NEG
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: PUSH
69869: LD_INT 2
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: PUSH
69876: LD_INT 0
69878: PUSH
69879: LD_INT 2
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 1
69888: NEG
69889: PUSH
69890: LD_INT 1
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 1
69899: NEG
69900: PUSH
69901: LD_INT 3
69903: NEG
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 0
69911: PUSH
69912: LD_INT 3
69914: NEG
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 1
69922: PUSH
69923: LD_INT 2
69925: NEG
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: EMPTY
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69949: LD_ADDR_VAR 0 15
69953: PUSH
69954: LD_INT 0
69956: PUSH
69957: LD_INT 0
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 0
69966: PUSH
69967: LD_INT 1
69969: NEG
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 1
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 1
69987: PUSH
69988: LD_INT 1
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 0
69997: PUSH
69998: LD_INT 1
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 1
70007: NEG
70008: PUSH
70009: LD_INT 0
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: LD_INT 1
70022: NEG
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: PUSH
70031: LD_INT 1
70033: NEG
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: LD_INT 2
70041: PUSH
70042: LD_INT 0
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 2
70051: PUSH
70052: LD_INT 1
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 1
70061: NEG
70062: PUSH
70063: LD_INT 1
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 2
70072: NEG
70073: PUSH
70074: LD_INT 0
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 2
70083: NEG
70084: PUSH
70085: LD_INT 1
70087: NEG
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 2
70095: PUSH
70096: LD_INT 1
70098: NEG
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 3
70106: PUSH
70107: LD_INT 0
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 3
70116: PUSH
70117: LD_INT 1
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
70142: LD_ADDR_VAR 0 16
70146: PUSH
70147: LD_INT 0
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 0
70159: PUSH
70160: LD_INT 1
70162: NEG
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 1
70170: PUSH
70171: LD_INT 0
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: LD_INT 1
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 0
70190: PUSH
70191: LD_INT 1
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 1
70211: NEG
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 2
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 2
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 2
70245: PUSH
70246: LD_INT 2
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: LD_INT 2
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 2
70265: NEG
70266: PUSH
70267: LD_INT 1
70269: NEG
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 2
70277: NEG
70278: PUSH
70279: LD_INT 2
70281: NEG
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 3
70289: PUSH
70290: LD_INT 2
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: LD_INT 3
70299: PUSH
70300: LD_INT 3
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: LD_INT 2
70309: PUSH
70310: LD_INT 3
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70335: LD_ADDR_VAR 0 17
70339: PUSH
70340: LD_INT 0
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: LD_INT 1
70355: NEG
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 1
70363: PUSH
70364: LD_INT 0
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 1
70393: NEG
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: LD_INT 2
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: LD_INT 2
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 2
70460: PUSH
70461: LD_INT 1
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 2
70470: PUSH
70471: LD_INT 2
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 1
70480: PUSH
70481: LD_INT 2
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 0
70490: PUSH
70491: LD_INT 2
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 1
70500: NEG
70501: PUSH
70502: LD_INT 1
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 2
70511: NEG
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: LD_INT 2
70522: NEG
70523: PUSH
70524: LD_INT 1
70526: NEG
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: LD_INT 2
70534: NEG
70535: PUSH
70536: LD_INT 2
70538: NEG
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70565: LD_ADDR_VAR 0 18
70569: PUSH
70570: LD_INT 0
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 0
70582: PUSH
70583: LD_INT 1
70585: NEG
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 1
70593: PUSH
70594: LD_INT 0
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 1
70603: PUSH
70604: LD_INT 1
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: LD_INT 1
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: LD_INT 0
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 1
70634: NEG
70635: PUSH
70636: LD_INT 1
70638: NEG
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 1
70646: NEG
70647: PUSH
70648: LD_INT 2
70650: NEG
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 0
70658: PUSH
70659: LD_INT 2
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 1
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 2
70680: PUSH
70681: LD_INT 0
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 2
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 2
70700: PUSH
70701: LD_INT 2
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: PUSH
70708: LD_INT 1
70710: PUSH
70711: LD_INT 2
70713: PUSH
70714: EMPTY
70715: LIST
70716: LIST
70717: PUSH
70718: LD_INT 0
70720: PUSH
70721: LD_INT 2
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 1
70730: NEG
70731: PUSH
70732: LD_INT 1
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 2
70741: NEG
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 2
70752: NEG
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 2
70764: NEG
70765: PUSH
70766: LD_INT 2
70768: NEG
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70795: LD_ADDR_VAR 0 19
70799: PUSH
70800: LD_INT 0
70802: PUSH
70803: LD_INT 0
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: LD_INT 1
70815: NEG
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 1
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: PUSH
70834: LD_INT 1
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 0
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: NEG
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 1
70864: NEG
70865: PUSH
70866: LD_INT 1
70868: NEG
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: NEG
70877: PUSH
70878: LD_INT 2
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: LD_INT 2
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: PUSH
70900: LD_INT 1
70902: NEG
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 2
70910: PUSH
70911: LD_INT 0
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: PUSH
70918: LD_INT 2
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: PUSH
70931: LD_INT 2
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 1
70940: PUSH
70941: LD_INT 2
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 0
70950: PUSH
70951: LD_INT 2
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 1
70960: NEG
70961: PUSH
70962: LD_INT 1
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 2
70971: NEG
70972: PUSH
70973: LD_INT 0
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 2
70982: NEG
70983: PUSH
70984: LD_INT 1
70986: NEG
70987: PUSH
70988: EMPTY
70989: LIST
70990: LIST
70991: PUSH
70992: LD_INT 2
70994: NEG
70995: PUSH
70996: LD_INT 2
70998: NEG
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71025: LD_ADDR_VAR 0 20
71029: PUSH
71030: LD_INT 0
71032: PUSH
71033: LD_INT 0
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: LD_INT 1
71045: NEG
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 1
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 1
71063: PUSH
71064: LD_INT 1
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 0
71073: PUSH
71074: LD_INT 1
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 1
71083: NEG
71084: PUSH
71085: LD_INT 0
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 1
71098: NEG
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 1
71106: NEG
71107: PUSH
71108: LD_INT 2
71110: NEG
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 0
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 1
71129: PUSH
71130: LD_INT 1
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 2
71140: PUSH
71141: LD_INT 0
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 2
71150: PUSH
71151: LD_INT 1
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 2
71160: PUSH
71161: LD_INT 2
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_INT 1
71170: PUSH
71171: LD_INT 2
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 0
71180: PUSH
71181: LD_INT 2
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: PUSH
71188: LD_INT 1
71190: NEG
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 2
71201: NEG
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 2
71212: NEG
71213: PUSH
71214: LD_INT 1
71216: NEG
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 2
71224: NEG
71225: PUSH
71226: LD_INT 2
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: LIST
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: LIST
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71255: LD_ADDR_VAR 0 21
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: LD_INT 0
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: LD_INT 1
71275: NEG
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 1
71283: PUSH
71284: LD_INT 0
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: PUSH
71294: LD_INT 1
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 0
71303: PUSH
71304: LD_INT 1
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 1
71313: NEG
71314: PUSH
71315: LD_INT 0
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: LD_INT 1
71324: NEG
71325: PUSH
71326: LD_INT 1
71328: NEG
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 1
71336: NEG
71337: PUSH
71338: LD_INT 2
71340: NEG
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PUSH
71346: LD_INT 0
71348: PUSH
71349: LD_INT 2
71351: NEG
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 1
71359: PUSH
71360: LD_INT 1
71362: NEG
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 2
71370: PUSH
71371: LD_INT 0
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 2
71380: PUSH
71381: LD_INT 1
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 2
71390: PUSH
71391: LD_INT 2
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 1
71400: PUSH
71401: LD_INT 2
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 0
71410: PUSH
71411: LD_INT 2
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 1
71420: NEG
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 2
71431: NEG
71432: PUSH
71433: LD_INT 0
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 2
71442: NEG
71443: PUSH
71444: LD_INT 1
71446: NEG
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 2
71454: NEG
71455: PUSH
71456: LD_INT 2
71458: NEG
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: LIST
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: LIST
71479: LIST
71480: LIST
71481: LIST
71482: LIST
71483: LIST
71484: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71485: LD_ADDR_VAR 0 22
71489: PUSH
71490: LD_INT 0
71492: PUSH
71493: LD_INT 0
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 0
71502: PUSH
71503: LD_INT 1
71505: NEG
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: PUSH
71514: LD_INT 0
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 1
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: LD_INT 1
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 1
71543: NEG
71544: PUSH
71545: LD_INT 0
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: NEG
71555: PUSH
71556: LD_INT 1
71558: NEG
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 1
71566: NEG
71567: PUSH
71568: LD_INT 2
71570: NEG
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 0
71578: PUSH
71579: LD_INT 2
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 1
71589: PUSH
71590: LD_INT 1
71592: NEG
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 2
71600: PUSH
71601: LD_INT 0
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 2
71610: PUSH
71611: LD_INT 1
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 2
71620: PUSH
71621: LD_INT 2
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: PUSH
71628: LD_INT 1
71630: PUSH
71631: LD_INT 2
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 0
71640: PUSH
71641: LD_INT 2
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 1
71650: NEG
71651: PUSH
71652: LD_INT 1
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 2
71661: NEG
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 2
71672: NEG
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 2
71684: NEG
71685: PUSH
71686: LD_INT 2
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
71715: LD_ADDR_VAR 0 23
71719: PUSH
71720: LD_INT 0
71722: PUSH
71723: LD_INT 0
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 0
71732: PUSH
71733: LD_INT 1
71735: NEG
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: PUSH
71744: LD_INT 0
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: LD_INT 1
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 0
71763: PUSH
71764: LD_INT 1
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 1
71773: NEG
71774: PUSH
71775: LD_INT 0
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: LD_INT 1
71788: NEG
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 1
71796: NEG
71797: PUSH
71798: LD_INT 2
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: LD_INT 2
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 1
71819: PUSH
71820: LD_INT 1
71822: NEG
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 2
71830: PUSH
71831: LD_INT 0
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 2
71840: PUSH
71841: LD_INT 1
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 2
71850: PUSH
71851: LD_INT 2
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 1
71860: PUSH
71861: LD_INT 2
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 0
71870: PUSH
71871: LD_INT 2
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 1
71880: NEG
71881: PUSH
71882: LD_INT 1
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 2
71891: NEG
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 2
71902: NEG
71903: PUSH
71904: LD_INT 1
71906: NEG
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 2
71914: NEG
71915: PUSH
71916: LD_INT 2
71918: NEG
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 2
71926: NEG
71927: PUSH
71928: LD_INT 3
71930: NEG
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 1
71938: NEG
71939: PUSH
71940: LD_INT 3
71942: NEG
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 1
71950: PUSH
71951: LD_INT 2
71953: NEG
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: LD_INT 2
71961: PUSH
71962: LD_INT 1
71964: NEG
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
71995: LD_ADDR_VAR 0 24
71999: PUSH
72000: LD_INT 0
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 0
72012: PUSH
72013: LD_INT 1
72015: NEG
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 1
72023: PUSH
72024: LD_INT 0
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: LD_INT 1
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 0
72043: PUSH
72044: LD_INT 1
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 1
72053: NEG
72054: PUSH
72055: LD_INT 0
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 1
72064: NEG
72065: PUSH
72066: LD_INT 1
72068: NEG
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 1
72076: NEG
72077: PUSH
72078: LD_INT 2
72080: NEG
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: LD_INT 2
72091: NEG
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 1
72099: PUSH
72100: LD_INT 1
72102: NEG
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 2
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 2
72120: PUSH
72121: LD_INT 1
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 2
72130: PUSH
72131: LD_INT 2
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: LD_INT 2
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 2
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 1
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 2
72171: NEG
72172: PUSH
72173: LD_INT 0
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 2
72182: NEG
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: EMPTY
72189: LIST
72190: LIST
72191: PUSH
72192: LD_INT 2
72194: NEG
72195: PUSH
72196: LD_INT 2
72198: NEG
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 1
72206: PUSH
72207: LD_INT 2
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 2
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 3
72228: PUSH
72229: LD_INT 1
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 3
72238: PUSH
72239: LD_INT 2
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: LIST
72255: LIST
72256: LIST
72257: LIST
72258: LIST
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
72271: LD_ADDR_VAR 0 25
72275: PUSH
72276: LD_INT 0
72278: PUSH
72279: LD_INT 0
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 0
72288: PUSH
72289: LD_INT 1
72291: NEG
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: LD_INT 0
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: LD_INT 1
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 0
72319: PUSH
72320: LD_INT 1
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 1
72329: NEG
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 1
72340: NEG
72341: PUSH
72342: LD_INT 1
72344: NEG
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 1
72352: NEG
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 0
72364: PUSH
72365: LD_INT 2
72367: NEG
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: LD_INT 1
72375: PUSH
72376: LD_INT 1
72378: NEG
72379: PUSH
72380: EMPTY
72381: LIST
72382: LIST
72383: PUSH
72384: LD_INT 2
72386: PUSH
72387: LD_INT 0
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 2
72396: PUSH
72397: LD_INT 1
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 2
72406: PUSH
72407: LD_INT 2
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 1
72416: PUSH
72417: LD_INT 2
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 0
72426: PUSH
72427: LD_INT 2
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 1
72436: NEG
72437: PUSH
72438: LD_INT 1
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 2
72447: NEG
72448: PUSH
72449: LD_INT 0
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 2
72458: NEG
72459: PUSH
72460: LD_INT 1
72462: NEG
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 2
72470: NEG
72471: PUSH
72472: LD_INT 2
72474: NEG
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 3
72482: PUSH
72483: LD_INT 1
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 3
72492: PUSH
72493: LD_INT 2
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 2
72502: PUSH
72503: LD_INT 3
72505: PUSH
72506: EMPTY
72507: LIST
72508: LIST
72509: PUSH
72510: LD_INT 1
72512: PUSH
72513: LD_INT 3
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: LIST
72531: LIST
72532: LIST
72533: LIST
72534: LIST
72535: LIST
72536: LIST
72537: LIST
72538: LIST
72539: LIST
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
72545: LD_ADDR_VAR 0 26
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 1
72573: PUSH
72574: LD_INT 0
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 1
72583: PUSH
72584: LD_INT 1
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 0
72593: PUSH
72594: LD_INT 1
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 1
72603: NEG
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 1
72614: NEG
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 0
72638: PUSH
72639: LD_INT 2
72641: NEG
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 1
72649: PUSH
72650: LD_INT 1
72652: NEG
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 2
72660: PUSH
72661: LD_INT 0
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 2
72670: PUSH
72671: LD_INT 1
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: LD_INT 2
72680: PUSH
72681: LD_INT 2
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: PUSH
72691: LD_INT 2
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: LD_INT 0
72700: PUSH
72701: LD_INT 2
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 1
72710: NEG
72711: PUSH
72712: LD_INT 1
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 2
72721: NEG
72722: PUSH
72723: LD_INT 0
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: PUSH
72730: LD_INT 2
72732: NEG
72733: PUSH
72734: LD_INT 1
72736: NEG
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 2
72744: NEG
72745: PUSH
72746: LD_INT 2
72748: NEG
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 2
72756: PUSH
72757: LD_INT 3
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 1
72766: PUSH
72767: LD_INT 3
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 2
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 2
72787: NEG
72788: PUSH
72789: LD_INT 1
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: LIST
72800: LIST
72801: LIST
72802: LIST
72803: LIST
72804: LIST
72805: LIST
72806: LIST
72807: LIST
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72821: LD_ADDR_VAR 0 27
72825: PUSH
72826: LD_INT 0
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 1
72849: PUSH
72850: LD_INT 0
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 1
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 0
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 1
72879: NEG
72880: PUSH
72881: LD_INT 0
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: LD_INT 1
72890: NEG
72891: PUSH
72892: LD_INT 1
72894: NEG
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: LD_INT 2
72906: NEG
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: PUSH
72912: LD_INT 0
72914: PUSH
72915: LD_INT 2
72917: NEG
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 1
72925: PUSH
72926: LD_INT 1
72928: NEG
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 2
72936: PUSH
72937: LD_INT 0
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 2
72946: PUSH
72947: LD_INT 1
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: LD_INT 2
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 1
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 0
72976: PUSH
72977: LD_INT 2
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PUSH
72984: LD_INT 1
72986: NEG
72987: PUSH
72988: LD_INT 1
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 2
72997: NEG
72998: PUSH
72999: LD_INT 0
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 2
73008: NEG
73009: PUSH
73010: LD_INT 1
73012: NEG
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 2
73020: NEG
73021: PUSH
73022: LD_INT 2
73024: NEG
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: LD_INT 2
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 2
73043: NEG
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 3
73054: NEG
73055: PUSH
73056: LD_INT 1
73058: NEG
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 3
73066: NEG
73067: PUSH
73068: LD_INT 2
73070: NEG
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: LIST
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73101: LD_ADDR_VAR 0 28
73105: PUSH
73106: LD_INT 0
73108: PUSH
73109: LD_INT 0
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 0
73118: PUSH
73119: LD_INT 1
73121: NEG
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 1
73129: PUSH
73130: LD_INT 0
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: PUSH
73140: LD_INT 1
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: LD_INT 1
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: LD_INT 0
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: NEG
73171: PUSH
73172: LD_INT 1
73174: NEG
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 1
73182: NEG
73183: PUSH
73184: LD_INT 2
73186: NEG
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 0
73194: PUSH
73195: LD_INT 2
73197: NEG
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 1
73205: PUSH
73206: LD_INT 1
73208: NEG
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 2
73216: PUSH
73217: LD_INT 0
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 2
73226: PUSH
73227: LD_INT 1
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 2
73236: PUSH
73237: LD_INT 2
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: LD_INT 2
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 0
73256: PUSH
73257: LD_INT 2
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 1
73266: NEG
73267: PUSH
73268: LD_INT 1
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: NEG
73278: PUSH
73279: LD_INT 0
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 2
73288: NEG
73289: PUSH
73290: LD_INT 1
73292: NEG
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 2
73300: NEG
73301: PUSH
73302: LD_INT 2
73304: NEG
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 2
73312: NEG
73313: PUSH
73314: LD_INT 3
73316: NEG
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: LD_INT 3
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 3
73336: NEG
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 3
73348: NEG
73349: PUSH
73350: LD_INT 2
73352: NEG
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73383: LD_ADDR_VAR 0 29
73387: PUSH
73388: LD_INT 0
73390: PUSH
73391: LD_INT 0
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 0
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 1
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 1
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 0
73431: PUSH
73432: LD_INT 1
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 1
73441: NEG
73442: PUSH
73443: LD_INT 0
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 1
73452: NEG
73453: PUSH
73454: LD_INT 1
73456: NEG
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 1
73464: NEG
73465: PUSH
73466: LD_INT 2
73468: NEG
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 0
73476: PUSH
73477: LD_INT 2
73479: NEG
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 1
73487: PUSH
73488: LD_INT 1
73490: NEG
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 2
73498: PUSH
73499: LD_INT 0
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 2
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: LD_INT 1
73518: PUSH
73519: LD_INT 2
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 0
73528: PUSH
73529: LD_INT 2
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 1
73538: NEG
73539: PUSH
73540: LD_INT 1
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 2
73549: NEG
73550: PUSH
73551: LD_INT 1
73553: NEG
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 2
73561: NEG
73562: PUSH
73563: LD_INT 2
73565: NEG
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: PUSH
73571: LD_INT 2
73573: NEG
73574: PUSH
73575: LD_INT 3
73577: NEG
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 2
73585: PUSH
73586: LD_INT 1
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 3
73596: PUSH
73597: LD_INT 1
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 1
73606: PUSH
73607: LD_INT 3
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 1
73616: NEG
73617: PUSH
73618: LD_INT 2
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 3
73627: NEG
73628: PUSH
73629: LD_INT 2
73631: NEG
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: LIST
73645: LIST
73646: LIST
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73662: LD_ADDR_VAR 0 30
73666: PUSH
73667: LD_INT 0
73669: PUSH
73670: LD_INT 0
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 0
73679: PUSH
73680: LD_INT 1
73682: NEG
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 1
73690: PUSH
73691: LD_INT 0
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 1
73700: PUSH
73701: LD_INT 1
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 0
73710: PUSH
73711: LD_INT 1
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 1
73720: NEG
73721: PUSH
73722: LD_INT 0
73724: PUSH
73725: EMPTY
73726: LIST
73727: LIST
73728: PUSH
73729: LD_INT 1
73731: NEG
73732: PUSH
73733: LD_INT 1
73735: NEG
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 1
73743: NEG
73744: PUSH
73745: LD_INT 2
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: LD_INT 2
73758: NEG
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 1
73766: PUSH
73767: LD_INT 1
73769: NEG
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 2
73777: PUSH
73778: LD_INT 0
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: PUSH
73785: LD_INT 2
73787: PUSH
73788: LD_INT 1
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: PUSH
73795: LD_INT 2
73797: PUSH
73798: LD_INT 2
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: LD_INT 2
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: NEG
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 2
73828: NEG
73829: PUSH
73830: LD_INT 0
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: PUSH
73837: LD_INT 2
73839: NEG
73840: PUSH
73841: LD_INT 1
73843: NEG
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 1
73851: NEG
73852: PUSH
73853: LD_INT 3
73855: NEG
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 1
73863: PUSH
73864: LD_INT 2
73866: NEG
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 3
73874: PUSH
73875: LD_INT 2
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 2
73884: PUSH
73885: LD_INT 3
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 2
73894: NEG
73895: PUSH
73896: LD_INT 1
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 3
73905: NEG
73906: PUSH
73907: LD_INT 1
73909: NEG
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73940: LD_ADDR_VAR 0 31
73944: PUSH
73945: LD_INT 0
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 0
73957: PUSH
73958: LD_INT 1
73960: NEG
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 1
73968: PUSH
73969: LD_INT 0
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 1
73978: PUSH
73979: LD_INT 1
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: LD_INT 0
73988: PUSH
73989: LD_INT 1
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: PUSH
73996: LD_INT 1
73998: NEG
73999: PUSH
74000: LD_INT 0
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 1
74009: NEG
74010: PUSH
74011: LD_INT 1
74013: NEG
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 1
74021: NEG
74022: PUSH
74023: LD_INT 2
74025: NEG
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 1
74033: PUSH
74034: LD_INT 1
74036: NEG
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 2
74044: PUSH
74045: LD_INT 0
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 2
74054: PUSH
74055: LD_INT 1
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 2
74064: PUSH
74065: LD_INT 2
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: LD_INT 1
74074: PUSH
74075: LD_INT 2
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: LD_INT 2
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 1
74094: NEG
74095: PUSH
74096: LD_INT 1
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 2
74105: NEG
74106: PUSH
74107: LD_INT 1
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 2
74117: NEG
74118: PUSH
74119: LD_INT 2
74121: NEG
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 2
74129: NEG
74130: PUSH
74131: LD_INT 3
74133: NEG
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: PUSH
74139: LD_INT 2
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 3
74152: PUSH
74153: LD_INT 1
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: LD_INT 3
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 1
74172: NEG
74173: PUSH
74174: LD_INT 2
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 3
74183: NEG
74184: PUSH
74185: LD_INT 2
74187: NEG
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74218: LD_ADDR_VAR 0 32
74222: PUSH
74223: LD_INT 0
74225: PUSH
74226: LD_INT 0
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 0
74235: PUSH
74236: LD_INT 1
74238: NEG
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 1
74246: PUSH
74247: LD_INT 0
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 1
74256: PUSH
74257: LD_INT 1
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 0
74266: PUSH
74267: LD_INT 1
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: NEG
74277: PUSH
74278: LD_INT 0
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 1
74287: NEG
74288: PUSH
74289: LD_INT 1
74291: NEG
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 1
74299: NEG
74300: PUSH
74301: LD_INT 2
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 0
74311: PUSH
74312: LD_INT 2
74314: NEG
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 1
74322: PUSH
74323: LD_INT 1
74325: NEG
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 2
74343: PUSH
74344: LD_INT 2
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_INT 1
74353: PUSH
74354: LD_INT 2
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: LD_INT 2
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 1
74373: NEG
74374: PUSH
74375: LD_INT 1
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 2
74384: NEG
74385: PUSH
74386: LD_INT 0
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 2
74395: NEG
74396: PUSH
74397: LD_INT 1
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 1
74407: NEG
74408: PUSH
74409: LD_INT 3
74411: NEG
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 1
74419: PUSH
74420: LD_INT 2
74422: NEG
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 3
74430: PUSH
74431: LD_INT 2
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 2
74440: PUSH
74441: LD_INT 3
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 2
74450: NEG
74451: PUSH
74452: LD_INT 1
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: PUSH
74459: LD_INT 3
74461: NEG
74462: PUSH
74463: LD_INT 1
74465: NEG
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: LIST
74475: LIST
74476: LIST
74477: LIST
74478: LIST
74479: LIST
74480: LIST
74481: LIST
74482: LIST
74483: LIST
74484: LIST
74485: LIST
74486: LIST
74487: LIST
74488: LIST
74489: LIST
74490: LIST
74491: LIST
74492: LIST
74493: LIST
74494: LIST
74495: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
74496: LD_ADDR_VAR 0 33
74500: PUSH
74501: LD_INT 0
74503: PUSH
74504: LD_INT 0
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 0
74513: PUSH
74514: LD_INT 1
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 1
74524: PUSH
74525: LD_INT 0
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: LD_INT 1
74534: PUSH
74535: LD_INT 1
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 0
74544: PUSH
74545: LD_INT 1
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 1
74554: NEG
74555: PUSH
74556: LD_INT 0
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 1
74565: NEG
74566: PUSH
74567: LD_INT 1
74569: NEG
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: LD_INT 1
74577: NEG
74578: PUSH
74579: LD_INT 2
74581: NEG
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 1
74589: PUSH
74590: LD_INT 1
74592: NEG
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 2
74600: PUSH
74601: LD_INT 0
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 2
74610: PUSH
74611: LD_INT 1
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: LD_INT 2
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 0
74630: PUSH
74631: LD_INT 2
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 1
74640: NEG
74641: PUSH
74642: LD_INT 1
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 2
74651: NEG
74652: PUSH
74653: LD_INT 0
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: LD_INT 2
74662: NEG
74663: PUSH
74664: LD_INT 1
74666: NEG
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 2
74674: NEG
74675: PUSH
74676: LD_INT 2
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 2
74686: NEG
74687: PUSH
74688: LD_INT 3
74690: NEG
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 2
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 3
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: LD_INT 3
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 1
74729: NEG
74730: PUSH
74731: LD_INT 2
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 3
74740: NEG
74741: PUSH
74742: LD_INT 2
74744: NEG
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74775: LD_ADDR_VAR 0 34
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: LD_INT 1
74795: NEG
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: PUSH
74814: LD_INT 1
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 1
74833: NEG
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: NEG
74845: PUSH
74846: LD_INT 1
74848: NEG
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 1
74856: NEG
74857: PUSH
74858: LD_INT 2
74860: NEG
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 0
74868: PUSH
74869: LD_INT 2
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 1
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 2
74890: PUSH
74891: LD_INT 1
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 2
74900: PUSH
74901: LD_INT 2
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 1
74910: PUSH
74911: LD_INT 2
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: LD_INT 1
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 2
74931: NEG
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 2
74942: NEG
74943: PUSH
74944: LD_INT 1
74946: NEG
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 2
74954: NEG
74955: PUSH
74956: LD_INT 2
74958: NEG
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 1
74966: NEG
74967: PUSH
74968: LD_INT 3
74970: NEG
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: LD_INT 2
74981: NEG
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 3
74989: PUSH
74990: LD_INT 2
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 2
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 2
75009: NEG
75010: PUSH
75011: LD_INT 1
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 3
75020: NEG
75021: PUSH
75022: LD_INT 1
75024: NEG
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: LIST
75054: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
75055: LD_ADDR_VAR 0 35
75059: PUSH
75060: LD_INT 0
75062: PUSH
75063: LD_INT 0
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 0
75072: PUSH
75073: LD_INT 1
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 1
75083: PUSH
75084: LD_INT 0
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 1
75093: PUSH
75094: LD_INT 1
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 0
75103: PUSH
75104: LD_INT 1
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 1
75113: NEG
75114: PUSH
75115: LD_INT 0
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 1
75124: NEG
75125: PUSH
75126: LD_INT 1
75128: NEG
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 2
75136: PUSH
75137: LD_INT 1
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 2
75146: NEG
75147: PUSH
75148: LD_INT 1
75150: NEG
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: LIST
75164: LIST
75165: LIST
75166: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
75167: LD_ADDR_VAR 0 36
75171: PUSH
75172: LD_INT 0
75174: PUSH
75175: LD_INT 0
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 1
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 1
75205: PUSH
75206: LD_INT 1
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 0
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: NEG
75226: PUSH
75227: LD_INT 0
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 1
75236: NEG
75237: PUSH
75238: LD_INT 1
75240: NEG
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 1
75248: NEG
75249: PUSH
75250: LD_INT 2
75252: NEG
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 1
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
75279: LD_ADDR_VAR 0 37
75283: PUSH
75284: LD_INT 0
75286: PUSH
75287: LD_INT 0
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 0
75296: PUSH
75297: LD_INT 1
75299: NEG
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: LD_INT 0
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: LD_INT 1
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 1
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: NEG
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 1
75348: NEG
75349: PUSH
75350: LD_INT 1
75352: NEG
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: LD_INT 1
75363: NEG
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: LD_INT 1
75371: NEG
75372: PUSH
75373: LD_INT 1
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
75391: LD_ADDR_VAR 0 38
75395: PUSH
75396: LD_INT 0
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 0
75408: PUSH
75409: LD_INT 1
75411: NEG
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 1
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 1
75429: PUSH
75430: LD_INT 1
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: PUSH
75437: LD_INT 0
75439: PUSH
75440: LD_INT 1
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 1
75449: NEG
75450: PUSH
75451: LD_INT 0
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 1
75460: NEG
75461: PUSH
75462: LD_INT 1
75464: NEG
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 2
75472: PUSH
75473: LD_INT 1
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: PUSH
75480: LD_INT 2
75482: NEG
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
75503: LD_ADDR_VAR 0 39
75507: PUSH
75508: LD_INT 0
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 0
75520: PUSH
75521: LD_INT 1
75523: NEG
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: PUSH
75532: LD_INT 0
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 1
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 0
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: LD_INT 1
75561: NEG
75562: PUSH
75563: LD_INT 0
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 1
75572: NEG
75573: PUSH
75574: LD_INT 1
75576: NEG
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 1
75584: NEG
75585: PUSH
75586: LD_INT 2
75588: NEG
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 1
75596: PUSH
75597: LD_INT 2
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
75615: LD_ADDR_VAR 0 40
75619: PUSH
75620: LD_INT 0
75622: PUSH
75623: LD_INT 0
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: LD_INT 1
75635: NEG
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: PUSH
75644: LD_INT 0
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: LD_INT 1
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 0
75663: PUSH
75664: LD_INT 1
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 1
75673: NEG
75674: PUSH
75675: LD_INT 0
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 1
75684: NEG
75685: PUSH
75686: LD_INT 1
75688: NEG
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 1
75696: PUSH
75697: LD_INT 1
75699: NEG
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 1
75707: NEG
75708: PUSH
75709: LD_INT 1
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75727: LD_ADDR_VAR 0 41
75731: PUSH
75732: LD_INT 0
75734: PUSH
75735: LD_INT 0
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: LD_INT 1
75747: NEG
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 1
75755: PUSH
75756: LD_INT 0
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 1
75765: PUSH
75766: LD_INT 1
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 0
75775: PUSH
75776: LD_INT 1
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 1
75785: NEG
75786: PUSH
75787: LD_INT 0
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 1
75796: NEG
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: LD_INT 2
75812: NEG
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: LD_INT 1
75823: NEG
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 2
75831: PUSH
75832: LD_INT 0
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 2
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 2
75851: PUSH
75852: LD_INT 2
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 1
75861: PUSH
75862: LD_INT 2
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 1
75871: NEG
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 2
75882: NEG
75883: PUSH
75884: LD_INT 0
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: PUSH
75891: LD_INT 2
75893: NEG
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 2
75905: NEG
75906: PUSH
75907: LD_INT 2
75909: NEG
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 2
75917: NEG
75918: PUSH
75919: LD_INT 3
75921: NEG
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 2
75929: PUSH
75930: LD_INT 1
75932: NEG
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 3
75940: PUSH
75941: LD_INT 0
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 3
75950: PUSH
75951: LD_INT 1
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 3
75960: PUSH
75961: LD_INT 2
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 3
75970: PUSH
75971: LD_INT 3
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: LD_INT 2
75980: PUSH
75981: LD_INT 3
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 2
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 3
76001: NEG
76002: PUSH
76003: LD_INT 0
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 3
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 3
76024: NEG
76025: PUSH
76026: LD_INT 2
76028: NEG
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 3
76036: NEG
76037: PUSH
76038: LD_INT 3
76040: NEG
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: LIST
76050: LIST
76051: LIST
76052: LIST
76053: LIST
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76077: LD_ADDR_VAR 0 42
76081: PUSH
76082: LD_INT 0
76084: PUSH
76085: LD_INT 0
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: LD_INT 0
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 1
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: LD_INT 1
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: LD_INT 0
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 1
76146: NEG
76147: PUSH
76148: LD_INT 1
76150: NEG
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 1
76158: NEG
76159: PUSH
76160: LD_INT 2
76162: NEG
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 0
76170: PUSH
76171: LD_INT 2
76173: NEG
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 1
76181: PUSH
76182: LD_INT 1
76184: NEG
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 2
76192: PUSH
76193: LD_INT 1
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 2
76202: PUSH
76203: LD_INT 2
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 1
76212: PUSH
76213: LD_INT 2
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: LD_INT 0
76222: PUSH
76223: LD_INT 2
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 1
76232: NEG
76233: PUSH
76234: LD_INT 1
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 2
76243: NEG
76244: PUSH
76245: LD_INT 1
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 2
76255: NEG
76256: PUSH
76257: LD_INT 2
76259: NEG
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 2
76267: NEG
76268: PUSH
76269: LD_INT 3
76271: NEG
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 1
76279: NEG
76280: PUSH
76281: LD_INT 3
76283: NEG
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_INT 0
76291: PUSH
76292: LD_INT 3
76294: NEG
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 1
76302: PUSH
76303: LD_INT 2
76305: NEG
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: PUSH
76311: LD_INT 3
76313: PUSH
76314: LD_INT 2
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 3
76323: PUSH
76324: LD_INT 3
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 2
76333: PUSH
76334: LD_INT 3
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: PUSH
76341: LD_INT 1
76343: PUSH
76344: LD_INT 3
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: PUSH
76351: LD_INT 0
76353: PUSH
76354: LD_INT 3
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 1
76363: NEG
76364: PUSH
76365: LD_INT 2
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 3
76374: NEG
76375: PUSH
76376: LD_INT 2
76378: NEG
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 3
76386: NEG
76387: PUSH
76388: LD_INT 3
76390: NEG
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: LIST
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: LIST
76417: LIST
76418: LIST
76419: LIST
76420: LIST
76421: LIST
76422: LIST
76423: LIST
76424: LIST
76425: LIST
76426: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76427: LD_ADDR_VAR 0 43
76431: PUSH
76432: LD_INT 0
76434: PUSH
76435: LD_INT 0
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 0
76444: PUSH
76445: LD_INT 1
76447: NEG
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: LD_INT 0
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 1
76465: PUSH
76466: LD_INT 1
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 0
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 1
76485: NEG
76486: PUSH
76487: LD_INT 0
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 1
76496: NEG
76497: PUSH
76498: LD_INT 1
76500: NEG
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 1
76508: NEG
76509: PUSH
76510: LD_INT 2
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 0
76520: PUSH
76521: LD_INT 2
76523: NEG
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 1
76531: PUSH
76532: LD_INT 1
76534: NEG
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 2
76542: PUSH
76543: LD_INT 0
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 2
76552: PUSH
76553: LD_INT 1
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 1
76562: PUSH
76563: LD_INT 2
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 0
76572: PUSH
76573: LD_INT 2
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 1
76582: NEG
76583: PUSH
76584: LD_INT 1
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 2
76593: NEG
76594: PUSH
76595: LD_INT 0
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 2
76604: NEG
76605: PUSH
76606: LD_INT 1
76608: NEG
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 1
76616: NEG
76617: PUSH
76618: LD_INT 3
76620: NEG
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 0
76628: PUSH
76629: LD_INT 3
76631: NEG
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 1
76639: PUSH
76640: LD_INT 2
76642: NEG
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: LD_INT 2
76650: PUSH
76651: LD_INT 1
76653: NEG
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 3
76661: PUSH
76662: LD_INT 0
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: LD_INT 3
76671: PUSH
76672: LD_INT 1
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 1
76681: PUSH
76682: LD_INT 3
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PUSH
76689: LD_INT 0
76691: PUSH
76692: LD_INT 3
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: LD_INT 1
76701: NEG
76702: PUSH
76703: LD_INT 2
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 2
76712: NEG
76713: PUSH
76714: LD_INT 1
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: LD_INT 3
76723: NEG
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 3
76734: NEG
76735: PUSH
76736: LD_INT 1
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76775: LD_ADDR_VAR 0 44
76779: PUSH
76780: LD_INT 0
76782: PUSH
76783: LD_INT 0
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 0
76792: PUSH
76793: LD_INT 1
76795: NEG
76796: PUSH
76797: EMPTY
76798: LIST
76799: LIST
76800: PUSH
76801: LD_INT 1
76803: PUSH
76804: LD_INT 0
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 1
76813: PUSH
76814: LD_INT 1
76816: PUSH
76817: EMPTY
76818: LIST
76819: LIST
76820: PUSH
76821: LD_INT 0
76823: PUSH
76824: LD_INT 1
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: LD_INT 0
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 1
76844: NEG
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 1
76856: NEG
76857: PUSH
76858: LD_INT 2
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 1
76868: PUSH
76869: LD_INT 1
76871: NEG
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 2
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 2
76889: PUSH
76890: LD_INT 1
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: LD_INT 2
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: LD_INT 2
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 1
76919: NEG
76920: PUSH
76921: LD_INT 1
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 2
76930: NEG
76931: PUSH
76932: LD_INT 0
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 2
76941: NEG
76942: PUSH
76943: LD_INT 1
76945: NEG
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: LD_INT 2
76953: NEG
76954: PUSH
76955: LD_INT 2
76957: NEG
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: NEG
76966: PUSH
76967: LD_INT 3
76969: NEG
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: LD_INT 2
76977: PUSH
76978: LD_INT 1
76980: NEG
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 3
76988: PUSH
76989: LD_INT 0
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 3
76998: PUSH
76999: LD_INT 1
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 3
77008: PUSH
77009: LD_INT 2
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 3
77018: PUSH
77019: LD_INT 3
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 2
77028: PUSH
77029: LD_INT 3
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 2
77038: NEG
77039: PUSH
77040: LD_INT 1
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 3
77049: NEG
77050: PUSH
77051: LD_INT 0
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 3
77060: NEG
77061: PUSH
77062: LD_INT 1
77064: NEG
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 3
77072: NEG
77073: PUSH
77074: LD_INT 2
77076: NEG
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: LD_INT 3
77084: NEG
77085: PUSH
77086: LD_INT 3
77088: NEG
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: LIST
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: LIST
77124: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77125: LD_ADDR_VAR 0 45
77129: PUSH
77130: LD_INT 0
77132: PUSH
77133: LD_INT 0
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 0
77142: PUSH
77143: LD_INT 1
77145: NEG
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 1
77153: PUSH
77154: LD_INT 0
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 1
77163: PUSH
77164: LD_INT 1
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 0
77173: PUSH
77174: LD_INT 1
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 1
77183: NEG
77184: PUSH
77185: LD_INT 0
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 1
77194: NEG
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 1
77206: NEG
77207: PUSH
77208: LD_INT 2
77210: NEG
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 0
77218: PUSH
77219: LD_INT 2
77221: NEG
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: LD_INT 1
77232: NEG
77233: PUSH
77234: EMPTY
77235: LIST
77236: LIST
77237: PUSH
77238: LD_INT 2
77240: PUSH
77241: LD_INT 1
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: LD_INT 2
77250: PUSH
77251: LD_INT 2
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 1
77260: PUSH
77261: LD_INT 2
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 0
77270: PUSH
77271: LD_INT 2
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 1
77280: NEG
77281: PUSH
77282: LD_INT 1
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: PUSH
77289: LD_INT 2
77291: NEG
77292: PUSH
77293: LD_INT 1
77295: NEG
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: LD_INT 2
77303: NEG
77304: PUSH
77305: LD_INT 2
77307: NEG
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 2
77315: NEG
77316: PUSH
77317: LD_INT 3
77319: NEG
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 1
77327: NEG
77328: PUSH
77329: LD_INT 3
77331: NEG
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: LD_INT 3
77342: NEG
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 1
77350: PUSH
77351: LD_INT 2
77353: NEG
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 3
77361: PUSH
77362: LD_INT 2
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 3
77371: PUSH
77372: LD_INT 3
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: LD_INT 2
77381: PUSH
77382: LD_INT 3
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: LD_INT 1
77391: PUSH
77392: LD_INT 3
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 0
77401: PUSH
77402: LD_INT 3
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: LD_INT 2
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 3
77422: NEG
77423: PUSH
77424: LD_INT 2
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 3
77434: NEG
77435: PUSH
77436: LD_INT 3
77438: NEG
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77475: LD_ADDR_VAR 0 46
77479: PUSH
77480: LD_INT 0
77482: PUSH
77483: LD_INT 0
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 0
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 1
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 1
77513: PUSH
77514: LD_INT 1
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 0
77523: PUSH
77524: LD_INT 1
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 1
77533: NEG
77534: PUSH
77535: LD_INT 0
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 1
77544: NEG
77545: PUSH
77546: LD_INT 1
77548: NEG
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 1
77556: NEG
77557: PUSH
77558: LD_INT 2
77560: NEG
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 0
77568: PUSH
77569: LD_INT 2
77571: NEG
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 1
77579: PUSH
77580: LD_INT 1
77582: NEG
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 2
77590: PUSH
77591: LD_INT 0
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 2
77600: PUSH
77601: LD_INT 1
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 1
77610: PUSH
77611: LD_INT 2
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 0
77620: PUSH
77621: LD_INT 2
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 1
77630: NEG
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 2
77641: NEG
77642: PUSH
77643: LD_INT 0
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 2
77652: NEG
77653: PUSH
77654: LD_INT 1
77656: NEG
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 1
77664: NEG
77665: PUSH
77666: LD_INT 3
77668: NEG
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PUSH
77674: LD_INT 0
77676: PUSH
77677: LD_INT 3
77679: NEG
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: PUSH
77688: LD_INT 2
77690: NEG
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 2
77698: PUSH
77699: LD_INT 1
77701: NEG
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 3
77709: PUSH
77710: LD_INT 0
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 3
77719: PUSH
77720: LD_INT 1
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: LD_INT 3
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 0
77739: PUSH
77740: LD_INT 3
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: LD_INT 2
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 2
77760: NEG
77761: PUSH
77762: LD_INT 1
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 3
77771: NEG
77772: PUSH
77773: LD_INT 0
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 3
77782: NEG
77783: PUSH
77784: LD_INT 1
77786: NEG
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: LIST
77796: LIST
77797: LIST
77798: LIST
77799: LIST
77800: LIST
77801: LIST
77802: LIST
77803: LIST
77804: LIST
77805: LIST
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77823: LD_ADDR_VAR 0 47
77827: PUSH
77828: LD_INT 0
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 0
77840: PUSH
77841: LD_INT 1
77843: NEG
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 1
77851: PUSH
77852: LD_INT 0
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 1
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 0
77871: PUSH
77872: LD_INT 1
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 1
77881: NEG
77882: PUSH
77883: LD_INT 0
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 1
77904: NEG
77905: PUSH
77906: LD_INT 2
77908: NEG
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 0
77916: PUSH
77917: LD_INT 2
77919: NEG
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 1
77927: PUSH
77928: LD_INT 1
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 2
77938: NEG
77939: PUSH
77940: LD_INT 1
77942: NEG
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 2
77950: NEG
77951: PUSH
77952: LD_INT 2
77954: NEG
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: LIST
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77974: LD_ADDR_VAR 0 48
77978: PUSH
77979: LD_INT 0
77981: PUSH
77982: LD_INT 0
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 0
77991: PUSH
77992: LD_INT 1
77994: NEG
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: LD_INT 0
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 1
78012: PUSH
78013: LD_INT 1
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 0
78022: PUSH
78023: LD_INT 1
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 1
78032: NEG
78033: PUSH
78034: LD_INT 0
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 1
78043: NEG
78044: PUSH
78045: LD_INT 1
78047: NEG
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 1
78055: NEG
78056: PUSH
78057: LD_INT 2
78059: NEG
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: PUSH
78065: LD_INT 0
78067: PUSH
78068: LD_INT 2
78070: NEG
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: LD_INT 1
78081: NEG
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 2
78089: PUSH
78090: LD_INT 0
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 2
78099: PUSH
78100: LD_INT 1
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: LIST
78116: LIST
78117: LIST
78118: LIST
78119: LIST
78120: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78121: LD_ADDR_VAR 0 49
78125: PUSH
78126: LD_INT 0
78128: PUSH
78129: LD_INT 0
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: LD_INT 1
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 1
78149: PUSH
78150: LD_INT 0
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 1
78159: PUSH
78160: LD_INT 1
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 0
78169: PUSH
78170: LD_INT 1
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: NEG
78180: PUSH
78181: LD_INT 0
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 1
78190: NEG
78191: PUSH
78192: LD_INT 1
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 1
78202: PUSH
78203: LD_INT 1
78205: NEG
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 2
78213: PUSH
78214: LD_INT 0
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: PUSH
78221: LD_INT 2
78223: PUSH
78224: LD_INT 1
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: LD_INT 2
78233: PUSH
78234: LD_INT 2
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 1
78243: PUSH
78244: LD_INT 2
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78265: LD_ADDR_VAR 0 50
78269: PUSH
78270: LD_INT 0
78272: PUSH
78273: LD_INT 0
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 0
78282: PUSH
78283: LD_INT 1
78285: NEG
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 1
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 1
78303: PUSH
78304: LD_INT 1
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 0
78313: PUSH
78314: LD_INT 1
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 1
78323: NEG
78324: PUSH
78325: LD_INT 0
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 1
78334: NEG
78335: PUSH
78336: LD_INT 1
78338: NEG
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 2
78346: PUSH
78347: LD_INT 1
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 2
78356: PUSH
78357: LD_INT 2
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 1
78366: PUSH
78367: LD_INT 2
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 0
78376: PUSH
78377: LD_INT 2
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 1
78386: NEG
78387: PUSH
78388: LD_INT 1
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78409: LD_ADDR_VAR 0 51
78413: PUSH
78414: LD_INT 0
78416: PUSH
78417: LD_INT 0
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: LD_INT 1
78429: NEG
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 1
78437: PUSH
78438: LD_INT 0
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 1
78447: PUSH
78448: LD_INT 1
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: LD_INT 1
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 1
78467: NEG
78468: PUSH
78469: LD_INT 0
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 1
78478: NEG
78479: PUSH
78480: LD_INT 1
78482: NEG
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: LD_INT 1
78490: PUSH
78491: LD_INT 2
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 0
78500: PUSH
78501: LD_INT 2
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: LD_INT 1
78510: NEG
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 2
78521: NEG
78522: PUSH
78523: LD_INT 0
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 2
78532: NEG
78533: PUSH
78534: LD_INT 1
78536: NEG
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78556: LD_ADDR_VAR 0 52
78560: PUSH
78561: LD_INT 0
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: PUSH
78571: LD_INT 0
78573: PUSH
78574: LD_INT 1
78576: NEG
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: PUSH
78582: LD_INT 1
78584: PUSH
78585: LD_INT 0
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 1
78594: PUSH
78595: LD_INT 1
78597: PUSH
78598: EMPTY
78599: LIST
78600: LIST
78601: PUSH
78602: LD_INT 0
78604: PUSH
78605: LD_INT 1
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 1
78614: NEG
78615: PUSH
78616: LD_INT 0
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 1
78625: NEG
78626: PUSH
78627: LD_INT 1
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 1
78637: NEG
78638: PUSH
78639: LD_INT 2
78641: NEG
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 1
78649: NEG
78650: PUSH
78651: LD_INT 1
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 2
78660: NEG
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 2
78671: NEG
78672: PUSH
78673: LD_INT 1
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 2
78683: NEG
78684: PUSH
78685: LD_INT 2
78687: NEG
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78707: LD_ADDR_VAR 0 53
78711: PUSH
78712: LD_INT 0
78714: PUSH
78715: LD_INT 0
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 0
78724: PUSH
78725: LD_INT 1
78727: NEG
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: LD_INT 1
78735: PUSH
78736: LD_INT 0
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: LD_INT 1
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 0
78755: PUSH
78756: LD_INT 1
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 1
78765: NEG
78766: PUSH
78767: LD_INT 0
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 1
78776: NEG
78777: PUSH
78778: LD_INT 1
78780: NEG
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PUSH
78786: LD_INT 1
78788: NEG
78789: PUSH
78790: LD_INT 2
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 0
78800: PUSH
78801: LD_INT 2
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 1
78811: PUSH
78812: LD_INT 1
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 2
78822: PUSH
78823: LD_INT 0
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PUSH
78830: LD_INT 2
78832: PUSH
78833: LD_INT 1
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: LD_INT 2
78842: PUSH
78843: LD_INT 2
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 1
78852: PUSH
78853: LD_INT 2
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 0
78862: PUSH
78863: LD_INT 2
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 1
78872: NEG
78873: PUSH
78874: LD_INT 1
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 2
78883: NEG
78884: PUSH
78885: LD_INT 0
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 2
78894: NEG
78895: PUSH
78896: LD_INT 1
78898: NEG
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 2
78906: NEG
78907: PUSH
78908: LD_INT 2
78910: NEG
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78937: LD_ADDR_VAR 0 54
78941: PUSH
78942: LD_INT 0
78944: PUSH
78945: LD_INT 0
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 0
78954: PUSH
78955: LD_INT 1
78957: NEG
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 1
78975: PUSH
78976: LD_INT 1
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 0
78985: PUSH
78986: LD_INT 1
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 1
78995: NEG
78996: PUSH
78997: LD_INT 0
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 1
79006: NEG
79007: PUSH
79008: LD_INT 1
79010: NEG
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 1
79018: NEG
79019: PUSH
79020: LD_INT 2
79022: NEG
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 0
79030: PUSH
79031: LD_INT 2
79033: NEG
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: LD_INT 1
79041: PUSH
79042: LD_INT 1
79044: NEG
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 2
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 2
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 2
79072: PUSH
79073: LD_INT 2
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 1
79082: PUSH
79083: LD_INT 2
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 0
79092: PUSH
79093: LD_INT 2
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 1
79102: NEG
79103: PUSH
79104: LD_INT 1
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 2
79113: NEG
79114: PUSH
79115: LD_INT 0
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 2
79124: NEG
79125: PUSH
79126: LD_INT 1
79128: NEG
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 2
79136: NEG
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79167: LD_ADDR_VAR 0 55
79171: PUSH
79172: LD_INT 0
79174: PUSH
79175: LD_INT 0
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 0
79184: PUSH
79185: LD_INT 1
79187: NEG
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 1
79195: PUSH
79196: LD_INT 0
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 1
79205: PUSH
79206: LD_INT 1
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 0
79215: PUSH
79216: LD_INT 1
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 1
79225: NEG
79226: PUSH
79227: LD_INT 0
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 1
79236: NEG
79237: PUSH
79238: LD_INT 1
79240: NEG
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 1
79248: NEG
79249: PUSH
79250: LD_INT 2
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 0
79260: PUSH
79261: LD_INT 2
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 1
79271: PUSH
79272: LD_INT 1
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 2
79282: PUSH
79283: LD_INT 0
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 2
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 2
79302: PUSH
79303: LD_INT 2
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 1
79312: PUSH
79313: LD_INT 2
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 0
79322: PUSH
79323: LD_INT 2
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 1
79332: NEG
79333: PUSH
79334: LD_INT 1
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: LD_INT 2
79343: NEG
79344: PUSH
79345: LD_INT 0
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 2
79354: NEG
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 2
79366: NEG
79367: PUSH
79368: LD_INT 2
79370: NEG
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79397: LD_ADDR_VAR 0 56
79401: PUSH
79402: LD_INT 0
79404: PUSH
79405: LD_INT 0
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: PUSH
79412: LD_INT 0
79414: PUSH
79415: LD_INT 1
79417: NEG
79418: PUSH
79419: EMPTY
79420: LIST
79421: LIST
79422: PUSH
79423: LD_INT 1
79425: PUSH
79426: LD_INT 0
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 1
79435: PUSH
79436: LD_INT 1
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 0
79445: PUSH
79446: LD_INT 1
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: NEG
79456: PUSH
79457: LD_INT 0
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 1
79466: NEG
79467: PUSH
79468: LD_INT 1
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 1
79478: NEG
79479: PUSH
79480: LD_INT 2
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 0
79490: PUSH
79491: LD_INT 2
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 1
79501: PUSH
79502: LD_INT 1
79504: NEG
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 2
79512: PUSH
79513: LD_INT 0
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 2
79522: PUSH
79523: LD_INT 1
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 2
79532: PUSH
79533: LD_INT 2
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 1
79542: PUSH
79543: LD_INT 2
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 0
79552: PUSH
79553: LD_INT 2
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: NEG
79563: PUSH
79564: LD_INT 1
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 2
79573: NEG
79574: PUSH
79575: LD_INT 0
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 2
79584: NEG
79585: PUSH
79586: LD_INT 1
79588: NEG
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 2
79596: NEG
79597: PUSH
79598: LD_INT 2
79600: NEG
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79627: LD_ADDR_VAR 0 57
79631: PUSH
79632: LD_INT 0
79634: PUSH
79635: LD_INT 0
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 1
79647: NEG
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 1
79655: PUSH
79656: LD_INT 0
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 1
79665: PUSH
79666: LD_INT 1
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 0
79675: PUSH
79676: LD_INT 1
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 1
79685: NEG
79686: PUSH
79687: LD_INT 0
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 1
79696: NEG
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 1
79708: NEG
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 0
79720: PUSH
79721: LD_INT 2
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: LD_INT 1
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 2
79742: PUSH
79743: LD_INT 0
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 2
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 2
79762: PUSH
79763: LD_INT 2
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 1
79772: PUSH
79773: LD_INT 2
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 0
79782: PUSH
79783: LD_INT 2
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 1
79792: NEG
79793: PUSH
79794: LD_INT 1
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 2
79803: NEG
79804: PUSH
79805: LD_INT 0
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 2
79814: NEG
79815: PUSH
79816: LD_INT 1
79818: NEG
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 2
79826: NEG
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79857: LD_ADDR_VAR 0 58
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: LD_INT 0
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 0
79874: PUSH
79875: LD_INT 1
79877: NEG
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 1
79885: PUSH
79886: LD_INT 0
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 1
79895: PUSH
79896: LD_INT 1
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 0
79905: PUSH
79906: LD_INT 1
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 1
79915: NEG
79916: PUSH
79917: LD_INT 0
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 1
79926: NEG
79927: PUSH
79928: LD_INT 1
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 1
79938: NEG
79939: PUSH
79940: LD_INT 2
79942: NEG
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 0
79950: PUSH
79951: LD_INT 2
79953: NEG
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 1
79961: PUSH
79962: LD_INT 1
79964: NEG
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 2
79972: PUSH
79973: LD_INT 0
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 2
79982: PUSH
79983: LD_INT 1
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 2
79992: PUSH
79993: LD_INT 2
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 1
80002: PUSH
80003: LD_INT 2
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 0
80012: PUSH
80013: LD_INT 2
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PUSH
80020: LD_INT 1
80022: NEG
80023: PUSH
80024: LD_INT 1
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 2
80033: NEG
80034: PUSH
80035: LD_INT 0
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 2
80044: NEG
80045: PUSH
80046: LD_INT 1
80048: NEG
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 2
80056: NEG
80057: PUSH
80058: LD_INT 2
80060: NEG
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80087: LD_ADDR_VAR 0 59
80091: PUSH
80092: LD_INT 0
80094: PUSH
80095: LD_INT 0
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: LD_INT 1
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 1
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 1
80125: PUSH
80126: LD_INT 1
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: LD_INT 0
80135: PUSH
80136: LD_INT 1
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 1
80145: NEG
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 1
80156: NEG
80157: PUSH
80158: LD_INT 1
80160: NEG
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80175: LD_ADDR_VAR 0 60
80179: PUSH
80180: LD_INT 0
80182: PUSH
80183: LD_INT 0
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 0
80192: PUSH
80193: LD_INT 1
80195: NEG
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: LD_INT 1
80203: PUSH
80204: LD_INT 0
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 1
80213: PUSH
80214: LD_INT 1
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 0
80223: PUSH
80224: LD_INT 1
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: LD_INT 0
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 1
80244: NEG
80245: PUSH
80246: LD_INT 1
80248: NEG
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80263: LD_ADDR_VAR 0 61
80267: PUSH
80268: LD_INT 0
80270: PUSH
80271: LD_INT 0
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: LD_INT 1
80283: NEG
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 1
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 0
80311: PUSH
80312: LD_INT 1
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 1
80321: NEG
80322: PUSH
80323: LD_INT 0
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 1
80332: NEG
80333: PUSH
80334: LD_INT 1
80336: NEG
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80351: LD_ADDR_VAR 0 62
80355: PUSH
80356: LD_INT 0
80358: PUSH
80359: LD_INT 0
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 0
80368: PUSH
80369: LD_INT 1
80371: NEG
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 1
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 1
80389: PUSH
80390: LD_INT 1
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 0
80399: PUSH
80400: LD_INT 1
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 1
80409: NEG
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 1
80420: NEG
80421: PUSH
80422: LD_INT 1
80424: NEG
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80439: LD_ADDR_VAR 0 63
80443: PUSH
80444: LD_INT 0
80446: PUSH
80447: LD_INT 0
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: LD_INT 0
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 1
80467: PUSH
80468: LD_INT 0
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 1
80477: PUSH
80478: LD_INT 1
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: LD_INT 1
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 1
80497: NEG
80498: PUSH
80499: LD_INT 0
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 1
80508: NEG
80509: PUSH
80510: LD_INT 1
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80527: LD_ADDR_VAR 0 64
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: LD_INT 0
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 0
80544: PUSH
80545: LD_INT 1
80547: NEG
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: PUSH
80556: LD_INT 0
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: LD_INT 1
80565: PUSH
80566: LD_INT 1
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 0
80575: PUSH
80576: LD_INT 1
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 1
80585: NEG
80586: PUSH
80587: LD_INT 0
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 1
80596: NEG
80597: PUSH
80598: LD_INT 1
80600: NEG
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: ST_TO_ADDR
// end ; 1 :
80615: GO 86512
80617: LD_INT 1
80619: DOUBLE
80620: EQUAL
80621: IFTRUE 80625
80623: GO 83248
80625: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80626: LD_ADDR_VAR 0 11
80630: PUSH
80631: LD_INT 1
80633: NEG
80634: PUSH
80635: LD_INT 3
80637: NEG
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 0
80645: PUSH
80646: LD_INT 3
80648: NEG
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 1
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: LIST
80669: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80670: LD_ADDR_VAR 0 12
80674: PUSH
80675: LD_INT 2
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 3
80688: PUSH
80689: LD_INT 0
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 3
80698: PUSH
80699: LD_INT 1
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: LIST
80710: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80711: LD_ADDR_VAR 0 13
80715: PUSH
80716: LD_INT 3
80718: PUSH
80719: LD_INT 2
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 3
80728: PUSH
80729: LD_INT 3
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 2
80738: PUSH
80739: LD_INT 3
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: LIST
80750: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80751: LD_ADDR_VAR 0 14
80755: PUSH
80756: LD_INT 1
80758: PUSH
80759: LD_INT 3
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: LD_INT 3
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: LD_INT 2
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: LIST
80791: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80792: LD_ADDR_VAR 0 15
80796: PUSH
80797: LD_INT 2
80799: NEG
80800: PUSH
80801: LD_INT 1
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 3
80810: NEG
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 3
80821: NEG
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: LIST
80835: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80836: LD_ADDR_VAR 0 16
80840: PUSH
80841: LD_INT 2
80843: NEG
80844: PUSH
80845: LD_INT 3
80847: NEG
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 3
80855: NEG
80856: PUSH
80857: LD_INT 2
80859: NEG
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 3
80867: NEG
80868: PUSH
80869: LD_INT 3
80871: NEG
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: LIST
80881: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80882: LD_ADDR_VAR 0 17
80886: PUSH
80887: LD_INT 1
80889: NEG
80890: PUSH
80891: LD_INT 3
80893: NEG
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 0
80901: PUSH
80902: LD_INT 3
80904: NEG
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 1
80912: PUSH
80913: LD_INT 2
80915: NEG
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: LIST
80925: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80926: LD_ADDR_VAR 0 18
80930: PUSH
80931: LD_INT 2
80933: PUSH
80934: LD_INT 1
80936: NEG
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 3
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 3
80954: PUSH
80955: LD_INT 1
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: LIST
80966: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80967: LD_ADDR_VAR 0 19
80971: PUSH
80972: LD_INT 3
80974: PUSH
80975: LD_INT 2
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 3
80984: PUSH
80985: LD_INT 3
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: LD_INT 3
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: LIST
81006: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81007: LD_ADDR_VAR 0 20
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: LD_INT 3
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: LD_INT 3
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: LD_INT 2
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: LIST
81047: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81048: LD_ADDR_VAR 0 21
81052: PUSH
81053: LD_INT 2
81055: NEG
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 3
81066: NEG
81067: PUSH
81068: LD_INT 0
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 3
81077: NEG
81078: PUSH
81079: LD_INT 1
81081: NEG
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: LIST
81091: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81092: LD_ADDR_VAR 0 22
81096: PUSH
81097: LD_INT 2
81099: NEG
81100: PUSH
81101: LD_INT 3
81103: NEG
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 3
81111: NEG
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 3
81123: NEG
81124: PUSH
81125: LD_INT 3
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: LIST
81137: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
81138: LD_ADDR_VAR 0 23
81142: PUSH
81143: LD_INT 0
81145: PUSH
81146: LD_INT 3
81148: NEG
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 1
81156: NEG
81157: PUSH
81158: LD_INT 4
81160: NEG
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 1
81168: PUSH
81169: LD_INT 3
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: LIST
81181: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
81182: LD_ADDR_VAR 0 24
81186: PUSH
81187: LD_INT 3
81189: PUSH
81190: LD_INT 0
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 3
81199: PUSH
81200: LD_INT 1
81202: NEG
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 4
81210: PUSH
81211: LD_INT 1
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: LIST
81222: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
81223: LD_ADDR_VAR 0 25
81227: PUSH
81228: LD_INT 3
81230: PUSH
81231: LD_INT 3
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 4
81240: PUSH
81241: LD_INT 3
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 3
81250: PUSH
81251: LD_INT 4
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: LIST
81262: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
81263: LD_ADDR_VAR 0 26
81267: PUSH
81268: LD_INT 0
81270: PUSH
81271: LD_INT 3
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 1
81280: PUSH
81281: LD_INT 4
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 1
81290: NEG
81291: PUSH
81292: LD_INT 3
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: LIST
81303: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
81304: LD_ADDR_VAR 0 27
81308: PUSH
81309: LD_INT 3
81311: NEG
81312: PUSH
81313: LD_INT 0
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 3
81322: NEG
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 4
81333: NEG
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: LIST
81347: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
81348: LD_ADDR_VAR 0 28
81352: PUSH
81353: LD_INT 3
81355: NEG
81356: PUSH
81357: LD_INT 3
81359: NEG
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 3
81367: NEG
81368: PUSH
81369: LD_INT 4
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 4
81379: NEG
81380: PUSH
81381: LD_INT 3
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: LIST
81393: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
81394: LD_ADDR_VAR 0 29
81398: PUSH
81399: LD_INT 1
81401: NEG
81402: PUSH
81403: LD_INT 3
81405: NEG
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 0
81413: PUSH
81414: LD_INT 3
81416: NEG
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: LD_INT 2
81427: NEG
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: LD_INT 4
81439: NEG
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: LD_INT 4
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 1
81458: PUSH
81459: LD_INT 3
81461: NEG
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 1
81469: NEG
81470: PUSH
81471: LD_INT 5
81473: NEG
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: LD_INT 5
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 1
81492: PUSH
81493: LD_INT 4
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: NEG
81504: PUSH
81505: LD_INT 6
81507: NEG
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: LD_INT 6
81518: NEG
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: PUSH
81527: LD_INT 5
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
81549: LD_ADDR_VAR 0 30
81553: PUSH
81554: LD_INT 2
81556: PUSH
81557: LD_INT 1
81559: NEG
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 3
81567: PUSH
81568: LD_INT 0
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 3
81577: PUSH
81578: LD_INT 1
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 3
81587: PUSH
81588: LD_INT 1
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 4
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 4
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 4
81618: PUSH
81619: LD_INT 1
81621: NEG
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 5
81629: PUSH
81630: LD_INT 0
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 5
81639: PUSH
81640: LD_INT 1
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 5
81649: PUSH
81650: LD_INT 1
81652: NEG
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 6
81660: PUSH
81661: LD_INT 0
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 6
81670: PUSH
81671: LD_INT 1
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
81692: LD_ADDR_VAR 0 31
81696: PUSH
81697: LD_INT 3
81699: PUSH
81700: LD_INT 2
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 3
81709: PUSH
81710: LD_INT 3
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 2
81719: PUSH
81720: LD_INT 3
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 4
81729: PUSH
81730: LD_INT 3
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 4
81739: PUSH
81740: LD_INT 4
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 3
81749: PUSH
81750: LD_INT 4
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 5
81759: PUSH
81760: LD_INT 4
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 5
81769: PUSH
81770: LD_INT 5
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 4
81779: PUSH
81780: LD_INT 5
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 6
81789: PUSH
81790: LD_INT 5
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 6
81799: PUSH
81800: LD_INT 6
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 5
81809: PUSH
81810: LD_INT 6
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
81831: LD_ADDR_VAR 0 32
81835: PUSH
81836: LD_INT 1
81838: PUSH
81839: LD_INT 3
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: LD_INT 3
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: NEG
81859: PUSH
81860: LD_INT 2
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 1
81869: PUSH
81870: LD_INT 4
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: LD_INT 4
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 1
81889: NEG
81890: PUSH
81891: LD_INT 3
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 1
81900: PUSH
81901: LD_INT 5
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 0
81910: PUSH
81911: LD_INT 5
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: LD_INT 4
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 1
81931: PUSH
81932: LD_INT 6
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 6
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: LD_INT 5
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
81974: LD_ADDR_VAR 0 33
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: LD_INT 1
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 3
81992: NEG
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 3
82003: NEG
82004: PUSH
82005: LD_INT 1
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 3
82015: NEG
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 4
82026: NEG
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 4
82037: NEG
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 4
82049: NEG
82050: PUSH
82051: LD_INT 1
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 5
82060: NEG
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 5
82071: NEG
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 5
82083: NEG
82084: PUSH
82085: LD_INT 1
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 6
82094: NEG
82095: PUSH
82096: LD_INT 0
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 6
82105: NEG
82106: PUSH
82107: LD_INT 1
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
82129: LD_ADDR_VAR 0 34
82133: PUSH
82134: LD_INT 2
82136: NEG
82137: PUSH
82138: LD_INT 3
82140: NEG
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 3
82148: NEG
82149: PUSH
82150: LD_INT 2
82152: NEG
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 3
82160: NEG
82161: PUSH
82162: LD_INT 3
82164: NEG
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 3
82172: NEG
82173: PUSH
82174: LD_INT 4
82176: NEG
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 4
82184: NEG
82185: PUSH
82186: LD_INT 3
82188: NEG
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 4
82196: NEG
82197: PUSH
82198: LD_INT 4
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 4
82208: NEG
82209: PUSH
82210: LD_INT 5
82212: NEG
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 5
82220: NEG
82221: PUSH
82222: LD_INT 4
82224: NEG
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 5
82232: NEG
82233: PUSH
82234: LD_INT 5
82236: NEG
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 5
82244: NEG
82245: PUSH
82246: LD_INT 6
82248: NEG
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 6
82256: NEG
82257: PUSH
82258: LD_INT 5
82260: NEG
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 6
82268: NEG
82269: PUSH
82270: LD_INT 6
82272: NEG
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
82292: LD_ADDR_VAR 0 41
82296: PUSH
82297: LD_INT 0
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 1
82310: NEG
82311: PUSH
82312: LD_INT 3
82314: NEG
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: LD_INT 2
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: LIST
82335: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
82336: LD_ADDR_VAR 0 42
82340: PUSH
82341: LD_INT 2
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 2
82353: PUSH
82354: LD_INT 1
82356: NEG
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 3
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: LIST
82376: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
82377: LD_ADDR_VAR 0 43
82381: PUSH
82382: LD_INT 2
82384: PUSH
82385: LD_INT 2
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 3
82394: PUSH
82395: LD_INT 2
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 2
82404: PUSH
82405: LD_INT 3
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: LIST
82416: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
82417: LD_ADDR_VAR 0 44
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: LD_INT 2
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 1
82434: PUSH
82435: LD_INT 3
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 1
82444: NEG
82445: PUSH
82446: LD_INT 2
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: LIST
82457: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82458: LD_ADDR_VAR 0 45
82462: PUSH
82463: LD_INT 2
82465: NEG
82466: PUSH
82467: LD_INT 0
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 2
82476: NEG
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 3
82487: NEG
82488: PUSH
82489: LD_INT 1
82491: NEG
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: EMPTY
82498: LIST
82499: LIST
82500: LIST
82501: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
82502: LD_ADDR_VAR 0 46
82506: PUSH
82507: LD_INT 2
82509: NEG
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: NEG
82522: PUSH
82523: LD_INT 3
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 3
82533: NEG
82534: PUSH
82535: LD_INT 2
82537: NEG
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: LIST
82547: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
82548: LD_ADDR_VAR 0 47
82552: PUSH
82553: LD_INT 2
82555: NEG
82556: PUSH
82557: LD_INT 3
82559: NEG
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 1
82567: NEG
82568: PUSH
82569: LD_INT 3
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82581: LD_ADDR_VAR 0 48
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: LD_INT 2
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 2
82599: PUSH
82600: LD_INT 1
82602: NEG
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
82612: LD_ADDR_VAR 0 49
82616: PUSH
82617: LD_INT 3
82619: PUSH
82620: LD_INT 1
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 3
82629: PUSH
82630: LD_INT 2
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
82641: LD_ADDR_VAR 0 50
82645: PUSH
82646: LD_INT 2
82648: PUSH
82649: LD_INT 3
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 1
82658: PUSH
82659: LD_INT 3
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82670: LD_ADDR_VAR 0 51
82674: PUSH
82675: LD_INT 1
82677: NEG
82678: PUSH
82679: LD_INT 2
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 2
82688: NEG
82689: PUSH
82690: LD_INT 1
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82701: LD_ADDR_VAR 0 52
82705: PUSH
82706: LD_INT 3
82708: NEG
82709: PUSH
82710: LD_INT 1
82712: NEG
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 3
82720: NEG
82721: PUSH
82722: LD_INT 2
82724: NEG
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82734: LD_ADDR_VAR 0 53
82738: PUSH
82739: LD_INT 1
82741: NEG
82742: PUSH
82743: LD_INT 3
82745: NEG
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 0
82753: PUSH
82754: LD_INT 3
82756: NEG
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: LD_INT 2
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: LIST
82777: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82778: LD_ADDR_VAR 0 54
82782: PUSH
82783: LD_INT 2
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 3
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 3
82806: PUSH
82807: LD_INT 1
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: LIST
82818: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82819: LD_ADDR_VAR 0 55
82823: PUSH
82824: LD_INT 3
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 3
82836: PUSH
82837: LD_INT 3
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 3
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: LIST
82858: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
82859: LD_ADDR_VAR 0 56
82863: PUSH
82864: LD_INT 1
82866: PUSH
82867: LD_INT 3
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 0
82876: PUSH
82877: LD_INT 3
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 1
82886: NEG
82887: PUSH
82888: LD_INT 2
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: LIST
82899: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82900: LD_ADDR_VAR 0 57
82904: PUSH
82905: LD_INT 2
82907: NEG
82908: PUSH
82909: LD_INT 1
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 3
82918: NEG
82919: PUSH
82920: LD_INT 0
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 3
82929: NEG
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: LIST
82943: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82944: LD_ADDR_VAR 0 58
82948: PUSH
82949: LD_INT 2
82951: NEG
82952: PUSH
82953: LD_INT 3
82955: NEG
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: LD_INT 3
82963: NEG
82964: PUSH
82965: LD_INT 2
82967: NEG
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 3
82975: NEG
82976: PUSH
82977: LD_INT 3
82979: NEG
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: LIST
82989: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
82990: LD_ADDR_VAR 0 59
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: LD_INT 2
83001: NEG
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 0
83009: PUSH
83010: LD_INT 2
83012: NEG
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 1
83020: PUSH
83021: LD_INT 1
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: LIST
83033: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83034: LD_ADDR_VAR 0 60
83038: PUSH
83039: LD_INT 1
83041: PUSH
83042: LD_INT 1
83044: NEG
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 2
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 2
83062: PUSH
83063: LD_INT 1
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: LIST
83074: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83075: LD_ADDR_VAR 0 61
83079: PUSH
83080: LD_INT 2
83082: PUSH
83083: LD_INT 1
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 2
83092: PUSH
83093: LD_INT 2
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 1
83102: PUSH
83103: LD_INT 2
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: LIST
83114: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83115: LD_ADDR_VAR 0 62
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: LD_INT 2
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 0
83132: PUSH
83133: LD_INT 2
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: NEG
83143: PUSH
83144: LD_INT 1
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: LIST
83155: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83156: LD_ADDR_VAR 0 63
83160: PUSH
83161: LD_INT 1
83163: NEG
83164: PUSH
83165: LD_INT 1
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 0
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 2
83185: NEG
83186: PUSH
83187: LD_INT 1
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: LIST
83199: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83200: LD_ADDR_VAR 0 64
83204: PUSH
83205: LD_INT 1
83207: NEG
83208: PUSH
83209: LD_INT 2
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 2
83219: NEG
83220: PUSH
83221: LD_INT 1
83223: NEG
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 2
83231: NEG
83232: PUSH
83233: LD_INT 2
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: LIST
83245: ST_TO_ADDR
// end ; 2 :
83246: GO 86512
83248: LD_INT 2
83250: DOUBLE
83251: EQUAL
83252: IFTRUE 83256
83254: GO 86511
83256: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
83257: LD_ADDR_VAR 0 29
83261: PUSH
83262: LD_INT 4
83264: PUSH
83265: LD_INT 0
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: PUSH
83272: LD_INT 4
83274: PUSH
83275: LD_INT 1
83277: NEG
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 5
83285: PUSH
83286: LD_INT 0
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 5
83295: PUSH
83296: LD_INT 1
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 4
83305: PUSH
83306: LD_INT 1
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 3
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 3
83325: PUSH
83326: LD_INT 1
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 3
83336: PUSH
83337: LD_INT 2
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 5
83347: PUSH
83348: LD_INT 2
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 3
83357: PUSH
83358: LD_INT 3
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 3
83367: PUSH
83368: LD_INT 2
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 4
83377: PUSH
83378: LD_INT 3
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 4
83387: PUSH
83388: LD_INT 4
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 3
83397: PUSH
83398: LD_INT 4
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 2
83407: PUSH
83408: LD_INT 3
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 2
83417: PUSH
83418: LD_INT 2
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 4
83427: PUSH
83428: LD_INT 2
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 2
83437: PUSH
83438: LD_INT 4
83440: PUSH
83441: EMPTY
83442: LIST
83443: LIST
83444: PUSH
83445: LD_INT 0
83447: PUSH
83448: LD_INT 4
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 0
83457: PUSH
83458: LD_INT 3
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 1
83467: PUSH
83468: LD_INT 4
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 1
83477: PUSH
83478: LD_INT 5
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 0
83487: PUSH
83488: LD_INT 5
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 1
83497: NEG
83498: PUSH
83499: LD_INT 4
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 1
83508: NEG
83509: PUSH
83510: LD_INT 3
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 2
83519: PUSH
83520: LD_INT 5
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 2
83529: NEG
83530: PUSH
83531: LD_INT 3
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 3
83540: NEG
83541: PUSH
83542: LD_INT 0
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 3
83551: NEG
83552: PUSH
83553: LD_INT 1
83555: NEG
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 2
83563: NEG
83564: PUSH
83565: LD_INT 0
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 2
83574: NEG
83575: PUSH
83576: LD_INT 1
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 3
83585: NEG
83586: PUSH
83587: LD_INT 1
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: PUSH
83594: LD_INT 4
83596: NEG
83597: PUSH
83598: LD_INT 0
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 4
83607: NEG
83608: PUSH
83609: LD_INT 1
83611: NEG
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: PUSH
83617: LD_INT 4
83619: NEG
83620: PUSH
83621: LD_INT 2
83623: NEG
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 2
83631: NEG
83632: PUSH
83633: LD_INT 2
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 4
83642: NEG
83643: PUSH
83644: LD_INT 4
83646: NEG
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: PUSH
83652: LD_INT 4
83654: NEG
83655: PUSH
83656: LD_INT 5
83658: NEG
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 3
83666: NEG
83667: PUSH
83668: LD_INT 4
83670: NEG
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 3
83678: NEG
83679: PUSH
83680: LD_INT 3
83682: NEG
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 4
83690: NEG
83691: PUSH
83692: LD_INT 3
83694: NEG
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 5
83702: NEG
83703: PUSH
83704: LD_INT 4
83706: NEG
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 5
83714: NEG
83715: PUSH
83716: LD_INT 5
83718: NEG
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PUSH
83724: LD_INT 3
83726: NEG
83727: PUSH
83728: LD_INT 5
83730: NEG
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 5
83738: NEG
83739: PUSH
83740: LD_INT 3
83742: NEG
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
83795: LD_ADDR_VAR 0 30
83799: PUSH
83800: LD_INT 4
83802: PUSH
83803: LD_INT 4
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 4
83812: PUSH
83813: LD_INT 3
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 5
83822: PUSH
83823: LD_INT 4
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 5
83832: PUSH
83833: LD_INT 5
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 4
83842: PUSH
83843: LD_INT 5
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 3
83852: PUSH
83853: LD_INT 4
83855: PUSH
83856: EMPTY
83857: LIST
83858: LIST
83859: PUSH
83860: LD_INT 3
83862: PUSH
83863: LD_INT 3
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: PUSH
83870: LD_INT 5
83872: PUSH
83873: LD_INT 3
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 3
83882: PUSH
83883: LD_INT 5
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 0
83892: PUSH
83893: LD_INT 3
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 0
83902: PUSH
83903: LD_INT 2
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: PUSH
83910: LD_INT 1
83912: PUSH
83913: LD_INT 3
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: PUSH
83920: LD_INT 1
83922: PUSH
83923: LD_INT 4
83925: PUSH
83926: EMPTY
83927: LIST
83928: LIST
83929: PUSH
83930: LD_INT 0
83932: PUSH
83933: LD_INT 4
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: PUSH
83940: LD_INT 1
83942: NEG
83943: PUSH
83944: LD_INT 3
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 1
83953: NEG
83954: PUSH
83955: LD_INT 2
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: PUSH
83962: LD_INT 2
83964: PUSH
83965: LD_INT 4
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 2
83974: NEG
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 4
83985: NEG
83986: PUSH
83987: LD_INT 0
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 4
83996: NEG
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 3
84008: NEG
84009: PUSH
84010: LD_INT 0
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 3
84019: NEG
84020: PUSH
84021: LD_INT 1
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 4
84030: NEG
84031: PUSH
84032: LD_INT 1
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 5
84041: NEG
84042: PUSH
84043: LD_INT 0
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 5
84052: NEG
84053: PUSH
84054: LD_INT 1
84056: NEG
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: LD_INT 5
84064: NEG
84065: PUSH
84066: LD_INT 2
84068: NEG
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 3
84076: NEG
84077: PUSH
84078: LD_INT 2
84080: PUSH
84081: EMPTY
84082: LIST
84083: LIST
84084: PUSH
84085: LD_INT 3
84087: NEG
84088: PUSH
84089: LD_INT 3
84091: NEG
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 3
84099: NEG
84100: PUSH
84101: LD_INT 4
84103: NEG
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 2
84111: NEG
84112: PUSH
84113: LD_INT 3
84115: NEG
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 2
84123: NEG
84124: PUSH
84125: LD_INT 2
84127: NEG
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 3
84135: NEG
84136: PUSH
84137: LD_INT 2
84139: NEG
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 4
84147: NEG
84148: PUSH
84149: LD_INT 3
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 4
84159: NEG
84160: PUSH
84161: LD_INT 4
84163: NEG
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 2
84171: NEG
84172: PUSH
84173: LD_INT 4
84175: NEG
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 4
84183: NEG
84184: PUSH
84185: LD_INT 2
84187: NEG
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 0
84195: PUSH
84196: LD_INT 4
84198: NEG
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 0
84206: PUSH
84207: LD_INT 5
84209: NEG
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 1
84217: PUSH
84218: LD_INT 4
84220: NEG
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: LD_INT 3
84231: NEG
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: PUSH
84237: LD_INT 0
84239: PUSH
84240: LD_INT 3
84242: NEG
84243: PUSH
84244: EMPTY
84245: LIST
84246: LIST
84247: PUSH
84248: LD_INT 1
84250: NEG
84251: PUSH
84252: LD_INT 4
84254: NEG
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: NEG
84263: PUSH
84264: LD_INT 5
84266: NEG
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 2
84274: PUSH
84275: LD_INT 3
84277: NEG
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 2
84285: NEG
84286: PUSH
84287: LD_INT 5
84289: NEG
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
84342: LD_ADDR_VAR 0 31
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: LD_INT 4
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 0
84359: PUSH
84360: LD_INT 3
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 1
84369: PUSH
84370: LD_INT 4
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 1
84379: PUSH
84380: LD_INT 5
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 0
84389: PUSH
84390: LD_INT 5
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: LD_INT 4
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 1
84410: NEG
84411: PUSH
84412: LD_INT 3
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 2
84421: PUSH
84422: LD_INT 5
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 2
84431: NEG
84432: PUSH
84433: LD_INT 3
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: PUSH
84440: LD_INT 3
84442: NEG
84443: PUSH
84444: LD_INT 0
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 3
84453: NEG
84454: PUSH
84455: LD_INT 1
84457: NEG
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 2
84465: NEG
84466: PUSH
84467: LD_INT 0
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 2
84476: NEG
84477: PUSH
84478: LD_INT 1
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 3
84487: NEG
84488: PUSH
84489: LD_INT 1
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 4
84498: NEG
84499: PUSH
84500: LD_INT 0
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 4
84509: NEG
84510: PUSH
84511: LD_INT 1
84513: NEG
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 4
84521: NEG
84522: PUSH
84523: LD_INT 2
84525: NEG
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: LD_INT 2
84533: NEG
84534: PUSH
84535: LD_INT 2
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 4
84544: NEG
84545: PUSH
84546: LD_INT 4
84548: NEG
84549: PUSH
84550: EMPTY
84551: LIST
84552: LIST
84553: PUSH
84554: LD_INT 4
84556: NEG
84557: PUSH
84558: LD_INT 5
84560: NEG
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 3
84568: NEG
84569: PUSH
84570: LD_INT 4
84572: NEG
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 3
84580: NEG
84581: PUSH
84582: LD_INT 3
84584: NEG
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 4
84592: NEG
84593: PUSH
84594: LD_INT 3
84596: NEG
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 5
84604: NEG
84605: PUSH
84606: LD_INT 4
84608: NEG
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: LD_INT 5
84616: NEG
84617: PUSH
84618: LD_INT 5
84620: NEG
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 3
84628: NEG
84629: PUSH
84630: LD_INT 5
84632: NEG
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 5
84640: NEG
84641: PUSH
84642: LD_INT 3
84644: NEG
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: PUSH
84650: LD_INT 0
84652: PUSH
84653: LD_INT 3
84655: NEG
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: LD_INT 4
84666: NEG
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: LD_INT 3
84677: NEG
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 1
84685: PUSH
84686: LD_INT 2
84688: NEG
84689: PUSH
84690: EMPTY
84691: LIST
84692: LIST
84693: PUSH
84694: LD_INT 0
84696: PUSH
84697: LD_INT 2
84699: NEG
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 1
84707: NEG
84708: PUSH
84709: LD_INT 3
84711: NEG
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: NEG
84720: PUSH
84721: LD_INT 4
84723: NEG
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 2
84731: PUSH
84732: LD_INT 2
84734: NEG
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 2
84742: NEG
84743: PUSH
84744: LD_INT 4
84746: NEG
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 4
84754: PUSH
84755: LD_INT 0
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 4
84764: PUSH
84765: LD_INT 1
84767: NEG
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 5
84775: PUSH
84776: LD_INT 0
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 5
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 4
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 3
84805: PUSH
84806: LD_INT 0
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 3
84815: PUSH
84816: LD_INT 1
84818: NEG
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 3
84826: PUSH
84827: LD_INT 2
84829: NEG
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 5
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
84892: LD_ADDR_VAR 0 32
84896: PUSH
84897: LD_INT 4
84899: NEG
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 4
84910: NEG
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 3
84922: NEG
84923: PUSH
84924: LD_INT 0
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PUSH
84931: LD_INT 3
84933: NEG
84934: PUSH
84935: LD_INT 1
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: LD_INT 4
84944: NEG
84945: PUSH
84946: LD_INT 1
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 5
84955: NEG
84956: PUSH
84957: LD_INT 0
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 5
84966: NEG
84967: PUSH
84968: LD_INT 1
84970: NEG
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 5
84978: NEG
84979: PUSH
84980: LD_INT 2
84982: NEG
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 3
84990: NEG
84991: PUSH
84992: LD_INT 2
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 3
85001: NEG
85002: PUSH
85003: LD_INT 3
85005: NEG
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: PUSH
85011: LD_INT 3
85013: NEG
85014: PUSH
85015: LD_INT 4
85017: NEG
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: PUSH
85023: LD_INT 2
85025: NEG
85026: PUSH
85027: LD_INT 3
85029: NEG
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 2
85037: NEG
85038: PUSH
85039: LD_INT 2
85041: NEG
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 3
85049: NEG
85050: PUSH
85051: LD_INT 2
85053: NEG
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 4
85061: NEG
85062: PUSH
85063: LD_INT 3
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 4
85073: NEG
85074: PUSH
85075: LD_INT 4
85077: NEG
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 2
85085: NEG
85086: PUSH
85087: LD_INT 4
85089: NEG
85090: PUSH
85091: EMPTY
85092: LIST
85093: LIST
85094: PUSH
85095: LD_INT 4
85097: NEG
85098: PUSH
85099: LD_INT 2
85101: NEG
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 0
85109: PUSH
85110: LD_INT 4
85112: NEG
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 0
85120: PUSH
85121: LD_INT 5
85123: NEG
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: PUSH
85132: LD_INT 4
85134: NEG
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: LD_INT 3
85145: NEG
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 0
85153: PUSH
85154: LD_INT 3
85156: NEG
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 1
85164: NEG
85165: PUSH
85166: LD_INT 4
85168: NEG
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_INT 1
85176: NEG
85177: PUSH
85178: LD_INT 5
85180: NEG
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 2
85188: PUSH
85189: LD_INT 3
85191: NEG
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_INT 2
85199: NEG
85200: PUSH
85201: LD_INT 5
85203: NEG
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 3
85211: PUSH
85212: LD_INT 0
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 3
85221: PUSH
85222: LD_INT 1
85224: NEG
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 4
85232: PUSH
85233: LD_INT 0
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 4
85242: PUSH
85243: LD_INT 1
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 3
85252: PUSH
85253: LD_INT 1
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: LD_INT 2
85272: PUSH
85273: LD_INT 1
85275: NEG
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: PUSH
85281: LD_INT 2
85283: PUSH
85284: LD_INT 2
85286: NEG
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PUSH
85292: LD_INT 4
85294: PUSH
85295: LD_INT 2
85297: PUSH
85298: EMPTY
85299: LIST
85300: LIST
85301: PUSH
85302: LD_INT 4
85304: PUSH
85305: LD_INT 4
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 4
85314: PUSH
85315: LD_INT 3
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 5
85324: PUSH
85325: LD_INT 4
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 5
85334: PUSH
85335: LD_INT 5
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 4
85344: PUSH
85345: LD_INT 5
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 3
85354: PUSH
85355: LD_INT 4
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 3
85364: PUSH
85365: LD_INT 3
85367: PUSH
85368: EMPTY
85369: LIST
85370: LIST
85371: PUSH
85372: LD_INT 5
85374: PUSH
85375: LD_INT 3
85377: PUSH
85378: EMPTY
85379: LIST
85380: LIST
85381: PUSH
85382: LD_INT 3
85384: PUSH
85385: LD_INT 5
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
85439: LD_ADDR_VAR 0 33
85443: PUSH
85444: LD_INT 4
85446: NEG
85447: PUSH
85448: LD_INT 4
85450: NEG
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: PUSH
85456: LD_INT 4
85458: NEG
85459: PUSH
85460: LD_INT 5
85462: NEG
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: LD_INT 3
85470: NEG
85471: PUSH
85472: LD_INT 4
85474: NEG
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 3
85482: NEG
85483: PUSH
85484: LD_INT 3
85486: NEG
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 4
85494: NEG
85495: PUSH
85496: LD_INT 3
85498: NEG
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: LD_INT 5
85506: NEG
85507: PUSH
85508: LD_INT 4
85510: NEG
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 5
85518: NEG
85519: PUSH
85520: LD_INT 5
85522: NEG
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 3
85530: NEG
85531: PUSH
85532: LD_INT 5
85534: NEG
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 5
85542: NEG
85543: PUSH
85544: LD_INT 3
85546: NEG
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 0
85554: PUSH
85555: LD_INT 3
85557: NEG
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: LD_INT 4
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 1
85576: PUSH
85577: LD_INT 3
85579: NEG
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: LD_INT 1
85587: PUSH
85588: LD_INT 2
85590: NEG
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PUSH
85596: LD_INT 0
85598: PUSH
85599: LD_INT 2
85601: NEG
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 1
85609: NEG
85610: PUSH
85611: LD_INT 3
85613: NEG
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 1
85621: NEG
85622: PUSH
85623: LD_INT 4
85625: NEG
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 2
85633: PUSH
85634: LD_INT 2
85636: NEG
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 2
85644: NEG
85645: PUSH
85646: LD_INT 4
85648: NEG
85649: PUSH
85650: EMPTY
85651: LIST
85652: LIST
85653: PUSH
85654: LD_INT 4
85656: PUSH
85657: LD_INT 0
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 4
85666: PUSH
85667: LD_INT 1
85669: NEG
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 5
85677: PUSH
85678: LD_INT 0
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 5
85687: PUSH
85688: LD_INT 1
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 4
85697: PUSH
85698: LD_INT 1
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 3
85707: PUSH
85708: LD_INT 0
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 3
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 3
85728: PUSH
85729: LD_INT 2
85731: NEG
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 5
85739: PUSH
85740: LD_INT 2
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 3
85749: PUSH
85750: LD_INT 3
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 3
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 4
85769: PUSH
85770: LD_INT 3
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PUSH
85777: LD_INT 4
85779: PUSH
85780: LD_INT 4
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 3
85789: PUSH
85790: LD_INT 4
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 2
85799: PUSH
85800: LD_INT 3
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 2
85809: PUSH
85810: LD_INT 2
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: PUSH
85817: LD_INT 4
85819: PUSH
85820: LD_INT 2
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 2
85829: PUSH
85830: LD_INT 4
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: LD_INT 4
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 0
85849: PUSH
85850: LD_INT 3
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 1
85859: PUSH
85860: LD_INT 4
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 1
85869: PUSH
85870: LD_INT 5
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 0
85879: PUSH
85880: LD_INT 5
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 1
85889: NEG
85890: PUSH
85891: LD_INT 4
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 1
85900: NEG
85901: PUSH
85902: LD_INT 3
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 2
85911: PUSH
85912: LD_INT 5
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: LD_INT 2
85921: NEG
85922: PUSH
85923: LD_INT 3
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
85977: LD_ADDR_VAR 0 34
85981: PUSH
85982: LD_INT 0
85984: PUSH
85985: LD_INT 4
85987: NEG
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 0
85995: PUSH
85996: LD_INT 5
85998: NEG
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 1
86006: PUSH
86007: LD_INT 4
86009: NEG
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 1
86017: PUSH
86018: LD_INT 3
86020: NEG
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 0
86028: PUSH
86029: LD_INT 3
86031: NEG
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 1
86039: NEG
86040: PUSH
86041: LD_INT 4
86043: NEG
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 1
86051: NEG
86052: PUSH
86053: LD_INT 5
86055: NEG
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 2
86063: PUSH
86064: LD_INT 3
86066: NEG
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 2
86074: NEG
86075: PUSH
86076: LD_INT 5
86078: NEG
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 3
86086: PUSH
86087: LD_INT 0
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 3
86096: PUSH
86097: LD_INT 1
86099: NEG
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 4
86107: PUSH
86108: LD_INT 0
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 4
86117: PUSH
86118: LD_INT 1
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: LD_INT 3
86127: PUSH
86128: LD_INT 1
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 2
86137: PUSH
86138: LD_INT 0
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: PUSH
86145: LD_INT 2
86147: PUSH
86148: LD_INT 1
86150: NEG
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 2
86158: PUSH
86159: LD_INT 2
86161: NEG
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 4
86169: PUSH
86170: LD_INT 2
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 4
86179: PUSH
86180: LD_INT 4
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PUSH
86187: LD_INT 4
86189: PUSH
86190: LD_INT 3
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 5
86199: PUSH
86200: LD_INT 4
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 5
86209: PUSH
86210: LD_INT 5
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 4
86219: PUSH
86220: LD_INT 5
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: LD_INT 3
86229: PUSH
86230: LD_INT 4
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 3
86239: PUSH
86240: LD_INT 3
86242: PUSH
86243: EMPTY
86244: LIST
86245: LIST
86246: PUSH
86247: LD_INT 5
86249: PUSH
86250: LD_INT 3
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 3
86259: PUSH
86260: LD_INT 5
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: LD_INT 0
86269: PUSH
86270: LD_INT 3
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 0
86279: PUSH
86280: LD_INT 2
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 1
86289: PUSH
86290: LD_INT 3
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 1
86299: PUSH
86300: LD_INT 4
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 0
86309: PUSH
86310: LD_INT 4
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 1
86319: NEG
86320: PUSH
86321: LD_INT 3
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 1
86330: NEG
86331: PUSH
86332: LD_INT 2
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 2
86341: PUSH
86342: LD_INT 4
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 2
86351: NEG
86352: PUSH
86353: LD_INT 2
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 4
86362: NEG
86363: PUSH
86364: LD_INT 0
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 4
86373: NEG
86374: PUSH
86375: LD_INT 1
86377: NEG
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 3
86385: NEG
86386: PUSH
86387: LD_INT 0
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 3
86396: NEG
86397: PUSH
86398: LD_INT 1
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 4
86407: NEG
86408: PUSH
86409: LD_INT 1
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 5
86418: NEG
86419: PUSH
86420: LD_INT 0
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PUSH
86427: LD_INT 5
86429: NEG
86430: PUSH
86431: LD_INT 1
86433: NEG
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 5
86441: NEG
86442: PUSH
86443: LD_INT 2
86445: NEG
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 3
86453: NEG
86454: PUSH
86455: LD_INT 2
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: ST_TO_ADDR
// end ; end ;
86509: GO 86512
86511: POP
// case btype of b_depot , b_warehouse :
86512: LD_VAR 0 1
86516: PUSH
86517: LD_INT 0
86519: DOUBLE
86520: EQUAL
86521: IFTRUE 86531
86523: LD_INT 1
86525: DOUBLE
86526: EQUAL
86527: IFTRUE 86531
86529: GO 86732
86531: POP
// case nation of nation_american :
86532: LD_VAR 0 5
86536: PUSH
86537: LD_INT 1
86539: DOUBLE
86540: EQUAL
86541: IFTRUE 86545
86543: GO 86601
86545: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
86546: LD_ADDR_VAR 0 9
86550: PUSH
86551: LD_VAR 0 11
86555: PUSH
86556: LD_VAR 0 12
86560: PUSH
86561: LD_VAR 0 13
86565: PUSH
86566: LD_VAR 0 14
86570: PUSH
86571: LD_VAR 0 15
86575: PUSH
86576: LD_VAR 0 16
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: PUSH
86589: LD_VAR 0 4
86593: PUSH
86594: LD_INT 1
86596: PLUS
86597: ARRAY
86598: ST_TO_ADDR
86599: GO 86730
86601: LD_INT 2
86603: DOUBLE
86604: EQUAL
86605: IFTRUE 86609
86607: GO 86665
86609: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
86610: LD_ADDR_VAR 0 9
86614: PUSH
86615: LD_VAR 0 17
86619: PUSH
86620: LD_VAR 0 18
86624: PUSH
86625: LD_VAR 0 19
86629: PUSH
86630: LD_VAR 0 20
86634: PUSH
86635: LD_VAR 0 21
86639: PUSH
86640: LD_VAR 0 22
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: PUSH
86653: LD_VAR 0 4
86657: PUSH
86658: LD_INT 1
86660: PLUS
86661: ARRAY
86662: ST_TO_ADDR
86663: GO 86730
86665: LD_INT 3
86667: DOUBLE
86668: EQUAL
86669: IFTRUE 86673
86671: GO 86729
86673: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
86674: LD_ADDR_VAR 0 9
86678: PUSH
86679: LD_VAR 0 23
86683: PUSH
86684: LD_VAR 0 24
86688: PUSH
86689: LD_VAR 0 25
86693: PUSH
86694: LD_VAR 0 26
86698: PUSH
86699: LD_VAR 0 27
86703: PUSH
86704: LD_VAR 0 28
86708: PUSH
86709: EMPTY
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: PUSH
86717: LD_VAR 0 4
86721: PUSH
86722: LD_INT 1
86724: PLUS
86725: ARRAY
86726: ST_TO_ADDR
86727: GO 86730
86729: POP
86730: GO 87279
86732: LD_INT 2
86734: DOUBLE
86735: EQUAL
86736: IFTRUE 86746
86738: LD_INT 3
86740: DOUBLE
86741: EQUAL
86742: IFTRUE 86746
86744: GO 86802
86746: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
86747: LD_ADDR_VAR 0 9
86751: PUSH
86752: LD_VAR 0 29
86756: PUSH
86757: LD_VAR 0 30
86761: PUSH
86762: LD_VAR 0 31
86766: PUSH
86767: LD_VAR 0 32
86771: PUSH
86772: LD_VAR 0 33
86776: PUSH
86777: LD_VAR 0 34
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: PUSH
86790: LD_VAR 0 4
86794: PUSH
86795: LD_INT 1
86797: PLUS
86798: ARRAY
86799: ST_TO_ADDR
86800: GO 87279
86802: LD_INT 16
86804: DOUBLE
86805: EQUAL
86806: IFTRUE 86858
86808: LD_INT 17
86810: DOUBLE
86811: EQUAL
86812: IFTRUE 86858
86814: LD_INT 18
86816: DOUBLE
86817: EQUAL
86818: IFTRUE 86858
86820: LD_INT 19
86822: DOUBLE
86823: EQUAL
86824: IFTRUE 86858
86826: LD_INT 20
86828: DOUBLE
86829: EQUAL
86830: IFTRUE 86858
86832: LD_INT 21
86834: DOUBLE
86835: EQUAL
86836: IFTRUE 86858
86838: LD_INT 23
86840: DOUBLE
86841: EQUAL
86842: IFTRUE 86858
86844: LD_INT 24
86846: DOUBLE
86847: EQUAL
86848: IFTRUE 86858
86850: LD_INT 25
86852: DOUBLE
86853: EQUAL
86854: IFTRUE 86858
86856: GO 86914
86858: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
86859: LD_ADDR_VAR 0 9
86863: PUSH
86864: LD_VAR 0 35
86868: PUSH
86869: LD_VAR 0 36
86873: PUSH
86874: LD_VAR 0 37
86878: PUSH
86879: LD_VAR 0 38
86883: PUSH
86884: LD_VAR 0 39
86888: PUSH
86889: LD_VAR 0 40
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: PUSH
86902: LD_VAR 0 4
86906: PUSH
86907: LD_INT 1
86909: PLUS
86910: ARRAY
86911: ST_TO_ADDR
86912: GO 87279
86914: LD_INT 6
86916: DOUBLE
86917: EQUAL
86918: IFTRUE 86970
86920: LD_INT 7
86922: DOUBLE
86923: EQUAL
86924: IFTRUE 86970
86926: LD_INT 8
86928: DOUBLE
86929: EQUAL
86930: IFTRUE 86970
86932: LD_INT 13
86934: DOUBLE
86935: EQUAL
86936: IFTRUE 86970
86938: LD_INT 12
86940: DOUBLE
86941: EQUAL
86942: IFTRUE 86970
86944: LD_INT 15
86946: DOUBLE
86947: EQUAL
86948: IFTRUE 86970
86950: LD_INT 11
86952: DOUBLE
86953: EQUAL
86954: IFTRUE 86970
86956: LD_INT 14
86958: DOUBLE
86959: EQUAL
86960: IFTRUE 86970
86962: LD_INT 10
86964: DOUBLE
86965: EQUAL
86966: IFTRUE 86970
86968: GO 87026
86970: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
86971: LD_ADDR_VAR 0 9
86975: PUSH
86976: LD_VAR 0 41
86980: PUSH
86981: LD_VAR 0 42
86985: PUSH
86986: LD_VAR 0 43
86990: PUSH
86991: LD_VAR 0 44
86995: PUSH
86996: LD_VAR 0 45
87000: PUSH
87001: LD_VAR 0 46
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: PUSH
87014: LD_VAR 0 4
87018: PUSH
87019: LD_INT 1
87021: PLUS
87022: ARRAY
87023: ST_TO_ADDR
87024: GO 87279
87026: LD_INT 36
87028: DOUBLE
87029: EQUAL
87030: IFTRUE 87034
87032: GO 87090
87034: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
87035: LD_ADDR_VAR 0 9
87039: PUSH
87040: LD_VAR 0 47
87044: PUSH
87045: LD_VAR 0 48
87049: PUSH
87050: LD_VAR 0 49
87054: PUSH
87055: LD_VAR 0 50
87059: PUSH
87060: LD_VAR 0 51
87064: PUSH
87065: LD_VAR 0 52
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: PUSH
87078: LD_VAR 0 4
87082: PUSH
87083: LD_INT 1
87085: PLUS
87086: ARRAY
87087: ST_TO_ADDR
87088: GO 87279
87090: LD_INT 4
87092: DOUBLE
87093: EQUAL
87094: IFTRUE 87116
87096: LD_INT 5
87098: DOUBLE
87099: EQUAL
87100: IFTRUE 87116
87102: LD_INT 34
87104: DOUBLE
87105: EQUAL
87106: IFTRUE 87116
87108: LD_INT 37
87110: DOUBLE
87111: EQUAL
87112: IFTRUE 87116
87114: GO 87172
87116: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
87117: LD_ADDR_VAR 0 9
87121: PUSH
87122: LD_VAR 0 53
87126: PUSH
87127: LD_VAR 0 54
87131: PUSH
87132: LD_VAR 0 55
87136: PUSH
87137: LD_VAR 0 56
87141: PUSH
87142: LD_VAR 0 57
87146: PUSH
87147: LD_VAR 0 58
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: PUSH
87160: LD_VAR 0 4
87164: PUSH
87165: LD_INT 1
87167: PLUS
87168: ARRAY
87169: ST_TO_ADDR
87170: GO 87279
87172: LD_INT 31
87174: DOUBLE
87175: EQUAL
87176: IFTRUE 87222
87178: LD_INT 32
87180: DOUBLE
87181: EQUAL
87182: IFTRUE 87222
87184: LD_INT 33
87186: DOUBLE
87187: EQUAL
87188: IFTRUE 87222
87190: LD_INT 27
87192: DOUBLE
87193: EQUAL
87194: IFTRUE 87222
87196: LD_INT 26
87198: DOUBLE
87199: EQUAL
87200: IFTRUE 87222
87202: LD_INT 28
87204: DOUBLE
87205: EQUAL
87206: IFTRUE 87222
87208: LD_INT 29
87210: DOUBLE
87211: EQUAL
87212: IFTRUE 87222
87214: LD_INT 30
87216: DOUBLE
87217: EQUAL
87218: IFTRUE 87222
87220: GO 87278
87222: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
87223: LD_ADDR_VAR 0 9
87227: PUSH
87228: LD_VAR 0 59
87232: PUSH
87233: LD_VAR 0 60
87237: PUSH
87238: LD_VAR 0 61
87242: PUSH
87243: LD_VAR 0 62
87247: PUSH
87248: LD_VAR 0 63
87252: PUSH
87253: LD_VAR 0 64
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: PUSH
87266: LD_VAR 0 4
87270: PUSH
87271: LD_INT 1
87273: PLUS
87274: ARRAY
87275: ST_TO_ADDR
87276: GO 87279
87278: POP
// temp_list2 = [ ] ;
87279: LD_ADDR_VAR 0 10
87283: PUSH
87284: EMPTY
87285: ST_TO_ADDR
// for i in temp_list do
87286: LD_ADDR_VAR 0 8
87290: PUSH
87291: LD_VAR 0 9
87295: PUSH
87296: FOR_IN
87297: IFFALSE 87349
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
87299: LD_ADDR_VAR 0 10
87303: PUSH
87304: LD_VAR 0 10
87308: PUSH
87309: LD_VAR 0 8
87313: PUSH
87314: LD_INT 1
87316: ARRAY
87317: PUSH
87318: LD_VAR 0 2
87322: PLUS
87323: PUSH
87324: LD_VAR 0 8
87328: PUSH
87329: LD_INT 2
87331: ARRAY
87332: PUSH
87333: LD_VAR 0 3
87337: PLUS
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: EMPTY
87344: LIST
87345: ADD
87346: ST_TO_ADDR
87347: GO 87296
87349: POP
87350: POP
// result = temp_list2 ;
87351: LD_ADDR_VAR 0 7
87355: PUSH
87356: LD_VAR 0 10
87360: ST_TO_ADDR
// end ;
87361: LD_VAR 0 7
87365: RET
// export function EnemyInRange ( unit , dist ) ; begin
87366: LD_INT 0
87368: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
87369: LD_ADDR_VAR 0 3
87373: PUSH
87374: LD_VAR 0 1
87378: PPUSH
87379: CALL_OW 255
87383: PPUSH
87384: LD_VAR 0 1
87388: PPUSH
87389: CALL_OW 250
87393: PPUSH
87394: LD_VAR 0 1
87398: PPUSH
87399: CALL_OW 251
87403: PPUSH
87404: LD_VAR 0 2
87408: PPUSH
87409: CALL 61494 0 4
87413: PUSH
87414: LD_INT 4
87416: ARRAY
87417: ST_TO_ADDR
// end ;
87418: LD_VAR 0 3
87422: RET
// export function PlayerSeeMe ( unit ) ; begin
87423: LD_INT 0
87425: PPUSH
// result := See ( your_side , unit ) ;
87426: LD_ADDR_VAR 0 2
87430: PUSH
87431: LD_OWVAR 2
87435: PPUSH
87436: LD_VAR 0 1
87440: PPUSH
87441: CALL_OW 292
87445: ST_TO_ADDR
// end ;
87446: LD_VAR 0 2
87450: RET
// export function ReverseDir ( unit ) ; begin
87451: LD_INT 0
87453: PPUSH
// if not unit then
87454: LD_VAR 0 1
87458: NOT
87459: IFFALSE 87463
// exit ;
87461: GO 87509
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
87463: LD_ADDR_VAR 0 2
87467: PUSH
87468: LD_INT 3
87470: PUSH
87471: LD_INT 4
87473: PUSH
87474: LD_INT 5
87476: PUSH
87477: LD_INT 0
87479: PUSH
87480: LD_INT 1
87482: PUSH
87483: LD_INT 2
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: PUSH
87494: LD_VAR 0 1
87498: PPUSH
87499: CALL_OW 254
87503: PUSH
87504: LD_INT 1
87506: PLUS
87507: ARRAY
87508: ST_TO_ADDR
// end ;
87509: LD_VAR 0 2
87513: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
87514: LD_INT 0
87516: PPUSH
87517: PPUSH
87518: PPUSH
87519: PPUSH
87520: PPUSH
// if not hexes then
87521: LD_VAR 0 2
87525: NOT
87526: IFFALSE 87530
// exit ;
87528: GO 87678
// dist := 9999 ;
87530: LD_ADDR_VAR 0 5
87534: PUSH
87535: LD_INT 9999
87537: ST_TO_ADDR
// for i = 1 to hexes do
87538: LD_ADDR_VAR 0 4
87542: PUSH
87543: DOUBLE
87544: LD_INT 1
87546: DEC
87547: ST_TO_ADDR
87548: LD_VAR 0 2
87552: PUSH
87553: FOR_TO
87554: IFFALSE 87666
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
87556: LD_VAR 0 1
87560: PPUSH
87561: LD_VAR 0 2
87565: PUSH
87566: LD_VAR 0 4
87570: ARRAY
87571: PUSH
87572: LD_INT 1
87574: ARRAY
87575: PPUSH
87576: LD_VAR 0 2
87580: PUSH
87581: LD_VAR 0 4
87585: ARRAY
87586: PUSH
87587: LD_INT 2
87589: ARRAY
87590: PPUSH
87591: CALL_OW 297
87595: PUSH
87596: LD_VAR 0 5
87600: LESS
87601: IFFALSE 87664
// begin hex := hexes [ i ] ;
87603: LD_ADDR_VAR 0 7
87607: PUSH
87608: LD_VAR 0 2
87612: PUSH
87613: LD_VAR 0 4
87617: ARRAY
87618: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
87619: LD_ADDR_VAR 0 5
87623: PUSH
87624: LD_VAR 0 1
87628: PPUSH
87629: LD_VAR 0 2
87633: PUSH
87634: LD_VAR 0 4
87638: ARRAY
87639: PUSH
87640: LD_INT 1
87642: ARRAY
87643: PPUSH
87644: LD_VAR 0 2
87648: PUSH
87649: LD_VAR 0 4
87653: ARRAY
87654: PUSH
87655: LD_INT 2
87657: ARRAY
87658: PPUSH
87659: CALL_OW 297
87663: ST_TO_ADDR
// end ; end ;
87664: GO 87553
87666: POP
87667: POP
// result := hex ;
87668: LD_ADDR_VAR 0 3
87672: PUSH
87673: LD_VAR 0 7
87677: ST_TO_ADDR
// end ;
87678: LD_VAR 0 3
87682: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
87683: LD_INT 0
87685: PPUSH
87686: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87687: LD_VAR 0 1
87691: NOT
87692: PUSH
87693: LD_VAR 0 1
87697: PUSH
87698: LD_INT 21
87700: PUSH
87701: LD_INT 2
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: LD_INT 23
87710: PUSH
87711: LD_INT 2
87713: PUSH
87714: EMPTY
87715: LIST
87716: LIST
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PPUSH
87722: CALL_OW 69
87726: IN
87727: NOT
87728: OR
87729: IFFALSE 87733
// exit ;
87731: GO 87780
// for i = 1 to 3 do
87733: LD_ADDR_VAR 0 3
87737: PUSH
87738: DOUBLE
87739: LD_INT 1
87741: DEC
87742: ST_TO_ADDR
87743: LD_INT 3
87745: PUSH
87746: FOR_TO
87747: IFFALSE 87778
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
87749: LD_VAR 0 1
87753: PPUSH
87754: CALL_OW 250
87758: PPUSH
87759: LD_VAR 0 1
87763: PPUSH
87764: CALL_OW 251
87768: PPUSH
87769: LD_INT 1
87771: PPUSH
87772: CALL_OW 453
87776: GO 87746
87778: POP
87779: POP
// end ;
87780: LD_VAR 0 2
87784: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
87785: LD_INT 0
87787: PPUSH
87788: PPUSH
87789: PPUSH
87790: PPUSH
87791: PPUSH
87792: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
87793: LD_VAR 0 1
87797: NOT
87798: PUSH
87799: LD_VAR 0 2
87803: NOT
87804: OR
87805: PUSH
87806: LD_VAR 0 1
87810: PPUSH
87811: CALL_OW 314
87815: OR
87816: IFFALSE 87820
// exit ;
87818: GO 88261
// x := GetX ( enemy_unit ) ;
87820: LD_ADDR_VAR 0 7
87824: PUSH
87825: LD_VAR 0 2
87829: PPUSH
87830: CALL_OW 250
87834: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
87835: LD_ADDR_VAR 0 8
87839: PUSH
87840: LD_VAR 0 2
87844: PPUSH
87845: CALL_OW 251
87849: ST_TO_ADDR
// if not x or not y then
87850: LD_VAR 0 7
87854: NOT
87855: PUSH
87856: LD_VAR 0 8
87860: NOT
87861: OR
87862: IFFALSE 87866
// exit ;
87864: GO 88261
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
87866: LD_ADDR_VAR 0 6
87870: PUSH
87871: LD_VAR 0 7
87875: PPUSH
87876: LD_INT 0
87878: PPUSH
87879: LD_INT 4
87881: PPUSH
87882: CALL_OW 272
87886: PUSH
87887: LD_VAR 0 8
87891: PPUSH
87892: LD_INT 0
87894: PPUSH
87895: LD_INT 4
87897: PPUSH
87898: CALL_OW 273
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_VAR 0 7
87911: PPUSH
87912: LD_INT 1
87914: PPUSH
87915: LD_INT 4
87917: PPUSH
87918: CALL_OW 272
87922: PUSH
87923: LD_VAR 0 8
87927: PPUSH
87928: LD_INT 1
87930: PPUSH
87931: LD_INT 4
87933: PPUSH
87934: CALL_OW 273
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_VAR 0 7
87947: PPUSH
87948: LD_INT 2
87950: PPUSH
87951: LD_INT 4
87953: PPUSH
87954: CALL_OW 272
87958: PUSH
87959: LD_VAR 0 8
87963: PPUSH
87964: LD_INT 2
87966: PPUSH
87967: LD_INT 4
87969: PPUSH
87970: CALL_OW 273
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_VAR 0 7
87983: PPUSH
87984: LD_INT 3
87986: PPUSH
87987: LD_INT 4
87989: PPUSH
87990: CALL_OW 272
87994: PUSH
87995: LD_VAR 0 8
87999: PPUSH
88000: LD_INT 3
88002: PPUSH
88003: LD_INT 4
88005: PPUSH
88006: CALL_OW 273
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_VAR 0 7
88019: PPUSH
88020: LD_INT 4
88022: PPUSH
88023: LD_INT 4
88025: PPUSH
88026: CALL_OW 272
88030: PUSH
88031: LD_VAR 0 8
88035: PPUSH
88036: LD_INT 4
88038: PPUSH
88039: LD_INT 4
88041: PPUSH
88042: CALL_OW 273
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: LD_VAR 0 7
88055: PPUSH
88056: LD_INT 5
88058: PPUSH
88059: LD_INT 4
88061: PPUSH
88062: CALL_OW 272
88066: PUSH
88067: LD_VAR 0 8
88071: PPUSH
88072: LD_INT 5
88074: PPUSH
88075: LD_INT 4
88077: PPUSH
88078: CALL_OW 273
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: ST_TO_ADDR
// for i = tmp downto 1 do
88095: LD_ADDR_VAR 0 4
88099: PUSH
88100: DOUBLE
88101: LD_VAR 0 6
88105: INC
88106: ST_TO_ADDR
88107: LD_INT 1
88109: PUSH
88110: FOR_DOWNTO
88111: IFFALSE 88212
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
88113: LD_VAR 0 6
88117: PUSH
88118: LD_VAR 0 4
88122: ARRAY
88123: PUSH
88124: LD_INT 1
88126: ARRAY
88127: PPUSH
88128: LD_VAR 0 6
88132: PUSH
88133: LD_VAR 0 4
88137: ARRAY
88138: PUSH
88139: LD_INT 2
88141: ARRAY
88142: PPUSH
88143: CALL_OW 488
88147: NOT
88148: PUSH
88149: LD_VAR 0 6
88153: PUSH
88154: LD_VAR 0 4
88158: ARRAY
88159: PUSH
88160: LD_INT 1
88162: ARRAY
88163: PPUSH
88164: LD_VAR 0 6
88168: PUSH
88169: LD_VAR 0 4
88173: ARRAY
88174: PUSH
88175: LD_INT 2
88177: ARRAY
88178: PPUSH
88179: CALL_OW 428
88183: PUSH
88184: LD_INT 0
88186: NONEQUAL
88187: OR
88188: IFFALSE 88210
// tmp := Delete ( tmp , i ) ;
88190: LD_ADDR_VAR 0 6
88194: PUSH
88195: LD_VAR 0 6
88199: PPUSH
88200: LD_VAR 0 4
88204: PPUSH
88205: CALL_OW 3
88209: ST_TO_ADDR
88210: GO 88110
88212: POP
88213: POP
// j := GetClosestHex ( unit , tmp ) ;
88214: LD_ADDR_VAR 0 5
88218: PUSH
88219: LD_VAR 0 1
88223: PPUSH
88224: LD_VAR 0 6
88228: PPUSH
88229: CALL 87514 0 2
88233: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
88234: LD_VAR 0 1
88238: PPUSH
88239: LD_VAR 0 5
88243: PUSH
88244: LD_INT 1
88246: ARRAY
88247: PPUSH
88248: LD_VAR 0 5
88252: PUSH
88253: LD_INT 2
88255: ARRAY
88256: PPUSH
88257: CALL_OW 111
// end ;
88261: LD_VAR 0 3
88265: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
88266: LD_INT 0
88268: PPUSH
88269: PPUSH
88270: PPUSH
// uc_side = 0 ;
88271: LD_ADDR_OWVAR 20
88275: PUSH
88276: LD_INT 0
88278: ST_TO_ADDR
// uc_nation = 0 ;
88279: LD_ADDR_OWVAR 21
88283: PUSH
88284: LD_INT 0
88286: ST_TO_ADDR
// InitHc ;
88287: CALL_OW 19
// InitVc ;
88291: CALL_OW 20
// if mastodonts then
88295: LD_VAR 0 6
88299: IFFALSE 88366
// for i = 1 to mastodonts do
88301: LD_ADDR_VAR 0 11
88305: PUSH
88306: DOUBLE
88307: LD_INT 1
88309: DEC
88310: ST_TO_ADDR
88311: LD_VAR 0 6
88315: PUSH
88316: FOR_TO
88317: IFFALSE 88364
// begin vc_chassis := 31 ;
88319: LD_ADDR_OWVAR 37
88323: PUSH
88324: LD_INT 31
88326: ST_TO_ADDR
// vc_control := control_rider ;
88327: LD_ADDR_OWVAR 38
88331: PUSH
88332: LD_INT 4
88334: ST_TO_ADDR
// animal := CreateVehicle ;
88335: LD_ADDR_VAR 0 12
88339: PUSH
88340: CALL_OW 45
88344: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88345: LD_VAR 0 12
88349: PPUSH
88350: LD_VAR 0 8
88354: PPUSH
88355: LD_INT 0
88357: PPUSH
88358: CALL 95072 0 3
// end ;
88362: GO 88316
88364: POP
88365: POP
// if horses then
88366: LD_VAR 0 5
88370: IFFALSE 88437
// for i = 1 to horses do
88372: LD_ADDR_VAR 0 11
88376: PUSH
88377: DOUBLE
88378: LD_INT 1
88380: DEC
88381: ST_TO_ADDR
88382: LD_VAR 0 5
88386: PUSH
88387: FOR_TO
88388: IFFALSE 88435
// begin hc_class := 21 ;
88390: LD_ADDR_OWVAR 28
88394: PUSH
88395: LD_INT 21
88397: ST_TO_ADDR
// hc_gallery :=  ;
88398: LD_ADDR_OWVAR 33
88402: PUSH
88403: LD_STRING 
88405: ST_TO_ADDR
// animal := CreateHuman ;
88406: LD_ADDR_VAR 0 12
88410: PUSH
88411: CALL_OW 44
88415: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88416: LD_VAR 0 12
88420: PPUSH
88421: LD_VAR 0 8
88425: PPUSH
88426: LD_INT 0
88428: PPUSH
88429: CALL 95072 0 3
// end ;
88433: GO 88387
88435: POP
88436: POP
// if birds then
88437: LD_VAR 0 1
88441: IFFALSE 88508
// for i = 1 to birds do
88443: LD_ADDR_VAR 0 11
88447: PUSH
88448: DOUBLE
88449: LD_INT 1
88451: DEC
88452: ST_TO_ADDR
88453: LD_VAR 0 1
88457: PUSH
88458: FOR_TO
88459: IFFALSE 88506
// begin hc_class = 18 ;
88461: LD_ADDR_OWVAR 28
88465: PUSH
88466: LD_INT 18
88468: ST_TO_ADDR
// hc_gallery =  ;
88469: LD_ADDR_OWVAR 33
88473: PUSH
88474: LD_STRING 
88476: ST_TO_ADDR
// animal := CreateHuman ;
88477: LD_ADDR_VAR 0 12
88481: PUSH
88482: CALL_OW 44
88486: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88487: LD_VAR 0 12
88491: PPUSH
88492: LD_VAR 0 8
88496: PPUSH
88497: LD_INT 0
88499: PPUSH
88500: CALL 95072 0 3
// end ;
88504: GO 88458
88506: POP
88507: POP
// if tigers then
88508: LD_VAR 0 2
88512: IFFALSE 88596
// for i = 1 to tigers do
88514: LD_ADDR_VAR 0 11
88518: PUSH
88519: DOUBLE
88520: LD_INT 1
88522: DEC
88523: ST_TO_ADDR
88524: LD_VAR 0 2
88528: PUSH
88529: FOR_TO
88530: IFFALSE 88594
// begin hc_class = class_tiger ;
88532: LD_ADDR_OWVAR 28
88536: PUSH
88537: LD_INT 14
88539: ST_TO_ADDR
// hc_gallery =  ;
88540: LD_ADDR_OWVAR 33
88544: PUSH
88545: LD_STRING 
88547: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
88548: LD_ADDR_OWVAR 35
88552: PUSH
88553: LD_INT 7
88555: NEG
88556: PPUSH
88557: LD_INT 7
88559: PPUSH
88560: CALL_OW 12
88564: ST_TO_ADDR
// animal := CreateHuman ;
88565: LD_ADDR_VAR 0 12
88569: PUSH
88570: CALL_OW 44
88574: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88575: LD_VAR 0 12
88579: PPUSH
88580: LD_VAR 0 8
88584: PPUSH
88585: LD_INT 0
88587: PPUSH
88588: CALL 95072 0 3
// end ;
88592: GO 88529
88594: POP
88595: POP
// if apemans then
88596: LD_VAR 0 3
88600: IFFALSE 88723
// for i = 1 to apemans do
88602: LD_ADDR_VAR 0 11
88606: PUSH
88607: DOUBLE
88608: LD_INT 1
88610: DEC
88611: ST_TO_ADDR
88612: LD_VAR 0 3
88616: PUSH
88617: FOR_TO
88618: IFFALSE 88721
// begin hc_class = class_apeman ;
88620: LD_ADDR_OWVAR 28
88624: PUSH
88625: LD_INT 12
88627: ST_TO_ADDR
// hc_gallery =  ;
88628: LD_ADDR_OWVAR 33
88632: PUSH
88633: LD_STRING 
88635: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
88636: LD_ADDR_OWVAR 35
88640: PUSH
88641: LD_INT 5
88643: NEG
88644: PPUSH
88645: LD_INT 5
88647: PPUSH
88648: CALL_OW 12
88652: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88653: LD_ADDR_OWVAR 31
88657: PUSH
88658: LD_INT 1
88660: PPUSH
88661: LD_INT 3
88663: PPUSH
88664: CALL_OW 12
88668: PUSH
88669: LD_INT 1
88671: PPUSH
88672: LD_INT 3
88674: PPUSH
88675: CALL_OW 12
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: LD_INT 0
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: ST_TO_ADDR
// animal := CreateHuman ;
88692: LD_ADDR_VAR 0 12
88696: PUSH
88697: CALL_OW 44
88701: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88702: LD_VAR 0 12
88706: PPUSH
88707: LD_VAR 0 8
88711: PPUSH
88712: LD_INT 0
88714: PPUSH
88715: CALL 95072 0 3
// end ;
88719: GO 88617
88721: POP
88722: POP
// if enchidnas then
88723: LD_VAR 0 4
88727: IFFALSE 88794
// for i = 1 to enchidnas do
88729: LD_ADDR_VAR 0 11
88733: PUSH
88734: DOUBLE
88735: LD_INT 1
88737: DEC
88738: ST_TO_ADDR
88739: LD_VAR 0 4
88743: PUSH
88744: FOR_TO
88745: IFFALSE 88792
// begin hc_class = 13 ;
88747: LD_ADDR_OWVAR 28
88751: PUSH
88752: LD_INT 13
88754: ST_TO_ADDR
// hc_gallery =  ;
88755: LD_ADDR_OWVAR 33
88759: PUSH
88760: LD_STRING 
88762: ST_TO_ADDR
// animal := CreateHuman ;
88763: LD_ADDR_VAR 0 12
88767: PUSH
88768: CALL_OW 44
88772: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88773: LD_VAR 0 12
88777: PPUSH
88778: LD_VAR 0 8
88782: PPUSH
88783: LD_INT 0
88785: PPUSH
88786: CALL 95072 0 3
// end ;
88790: GO 88744
88792: POP
88793: POP
// if fishes then
88794: LD_VAR 0 7
88798: IFFALSE 88865
// for i = 1 to fishes do
88800: LD_ADDR_VAR 0 11
88804: PUSH
88805: DOUBLE
88806: LD_INT 1
88808: DEC
88809: ST_TO_ADDR
88810: LD_VAR 0 7
88814: PUSH
88815: FOR_TO
88816: IFFALSE 88863
// begin hc_class = 20 ;
88818: LD_ADDR_OWVAR 28
88822: PUSH
88823: LD_INT 20
88825: ST_TO_ADDR
// hc_gallery =  ;
88826: LD_ADDR_OWVAR 33
88830: PUSH
88831: LD_STRING 
88833: ST_TO_ADDR
// animal := CreateHuman ;
88834: LD_ADDR_VAR 0 12
88838: PUSH
88839: CALL_OW 44
88843: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88844: LD_VAR 0 12
88848: PPUSH
88849: LD_VAR 0 9
88853: PPUSH
88854: LD_INT 0
88856: PPUSH
88857: CALL 95072 0 3
// end ;
88861: GO 88815
88863: POP
88864: POP
// end ;
88865: LD_VAR 0 10
88869: RET
// export function WantHeal ( sci , unit ) ; begin
88870: LD_INT 0
88872: PPUSH
// if GetTaskList ( sci ) > 0 then
88873: LD_VAR 0 1
88877: PPUSH
88878: CALL_OW 437
88882: PUSH
88883: LD_INT 0
88885: GREATER
88886: IFFALSE 88956
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88888: LD_VAR 0 1
88892: PPUSH
88893: CALL_OW 437
88897: PUSH
88898: LD_INT 1
88900: ARRAY
88901: PUSH
88902: LD_INT 1
88904: ARRAY
88905: PUSH
88906: LD_STRING l
88908: EQUAL
88909: PUSH
88910: LD_VAR 0 1
88914: PPUSH
88915: CALL_OW 437
88919: PUSH
88920: LD_INT 1
88922: ARRAY
88923: PUSH
88924: LD_INT 4
88926: ARRAY
88927: PUSH
88928: LD_VAR 0 2
88932: EQUAL
88933: AND
88934: IFFALSE 88946
// result := true else
88936: LD_ADDR_VAR 0 3
88940: PUSH
88941: LD_INT 1
88943: ST_TO_ADDR
88944: GO 88954
// result := false ;
88946: LD_ADDR_VAR 0 3
88950: PUSH
88951: LD_INT 0
88953: ST_TO_ADDR
// end else
88954: GO 88964
// result := false ;
88956: LD_ADDR_VAR 0 3
88960: PUSH
88961: LD_INT 0
88963: ST_TO_ADDR
// end ;
88964: LD_VAR 0 3
88968: RET
// export function HealTarget ( sci ) ; begin
88969: LD_INT 0
88971: PPUSH
// if not sci then
88972: LD_VAR 0 1
88976: NOT
88977: IFFALSE 88981
// exit ;
88979: GO 89046
// result := 0 ;
88981: LD_ADDR_VAR 0 2
88985: PUSH
88986: LD_INT 0
88988: ST_TO_ADDR
// if GetTaskList ( sci ) then
88989: LD_VAR 0 1
88993: PPUSH
88994: CALL_OW 437
88998: IFFALSE 89046
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
89000: LD_VAR 0 1
89004: PPUSH
89005: CALL_OW 437
89009: PUSH
89010: LD_INT 1
89012: ARRAY
89013: PUSH
89014: LD_INT 1
89016: ARRAY
89017: PUSH
89018: LD_STRING l
89020: EQUAL
89021: IFFALSE 89046
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
89023: LD_ADDR_VAR 0 2
89027: PUSH
89028: LD_VAR 0 1
89032: PPUSH
89033: CALL_OW 437
89037: PUSH
89038: LD_INT 1
89040: ARRAY
89041: PUSH
89042: LD_INT 4
89044: ARRAY
89045: ST_TO_ADDR
// end ;
89046: LD_VAR 0 2
89050: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
89051: LD_INT 0
89053: PPUSH
89054: PPUSH
89055: PPUSH
89056: PPUSH
89057: PPUSH
89058: PPUSH
89059: PPUSH
89060: PPUSH
89061: PPUSH
89062: PPUSH
89063: PPUSH
89064: PPUSH
89065: PPUSH
89066: PPUSH
89067: PPUSH
89068: PPUSH
89069: PPUSH
89070: PPUSH
89071: PPUSH
89072: PPUSH
89073: PPUSH
89074: PPUSH
89075: PPUSH
89076: PPUSH
89077: PPUSH
89078: PPUSH
89079: PPUSH
89080: PPUSH
89081: PPUSH
89082: PPUSH
89083: PPUSH
89084: PPUSH
89085: PPUSH
// if not list then
89086: LD_VAR 0 1
89090: NOT
89091: IFFALSE 89095
// exit ;
89093: GO 93683
// base := list [ 1 ] ;
89095: LD_ADDR_VAR 0 3
89099: PUSH
89100: LD_VAR 0 1
89104: PUSH
89105: LD_INT 1
89107: ARRAY
89108: ST_TO_ADDR
// group := list [ 2 ] ;
89109: LD_ADDR_VAR 0 4
89113: PUSH
89114: LD_VAR 0 1
89118: PUSH
89119: LD_INT 2
89121: ARRAY
89122: ST_TO_ADDR
// path := list [ 3 ] ;
89123: LD_ADDR_VAR 0 5
89127: PUSH
89128: LD_VAR 0 1
89132: PUSH
89133: LD_INT 3
89135: ARRAY
89136: ST_TO_ADDR
// flags := list [ 4 ] ;
89137: LD_ADDR_VAR 0 6
89141: PUSH
89142: LD_VAR 0 1
89146: PUSH
89147: LD_INT 4
89149: ARRAY
89150: ST_TO_ADDR
// mined := [ ] ;
89151: LD_ADDR_VAR 0 27
89155: PUSH
89156: EMPTY
89157: ST_TO_ADDR
// bombed := [ ] ;
89158: LD_ADDR_VAR 0 28
89162: PUSH
89163: EMPTY
89164: ST_TO_ADDR
// healers := [ ] ;
89165: LD_ADDR_VAR 0 31
89169: PUSH
89170: EMPTY
89171: ST_TO_ADDR
// to_heal := [ ] ;
89172: LD_ADDR_VAR 0 30
89176: PUSH
89177: EMPTY
89178: ST_TO_ADDR
// repairs := [ ] ;
89179: LD_ADDR_VAR 0 33
89183: PUSH
89184: EMPTY
89185: ST_TO_ADDR
// to_repair := [ ] ;
89186: LD_ADDR_VAR 0 32
89190: PUSH
89191: EMPTY
89192: ST_TO_ADDR
// if not group or not path then
89193: LD_VAR 0 4
89197: NOT
89198: PUSH
89199: LD_VAR 0 5
89203: NOT
89204: OR
89205: IFFALSE 89209
// exit ;
89207: GO 93683
// if flags then
89209: LD_VAR 0 6
89213: IFFALSE 89357
// begin f_ignore_area := flags [ 1 ] ;
89215: LD_ADDR_VAR 0 17
89219: PUSH
89220: LD_VAR 0 6
89224: PUSH
89225: LD_INT 1
89227: ARRAY
89228: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
89229: LD_ADDR_VAR 0 18
89233: PUSH
89234: LD_VAR 0 6
89238: PUSH
89239: LD_INT 2
89241: ARRAY
89242: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
89243: LD_ADDR_VAR 0 19
89247: PUSH
89248: LD_VAR 0 6
89252: PUSH
89253: LD_INT 3
89255: ARRAY
89256: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
89257: LD_ADDR_VAR 0 20
89261: PUSH
89262: LD_VAR 0 6
89266: PUSH
89267: LD_INT 4
89269: ARRAY
89270: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
89271: LD_ADDR_VAR 0 21
89275: PUSH
89276: LD_VAR 0 6
89280: PUSH
89281: LD_INT 5
89283: ARRAY
89284: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
89285: LD_ADDR_VAR 0 22
89289: PUSH
89290: LD_VAR 0 6
89294: PUSH
89295: LD_INT 6
89297: ARRAY
89298: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
89299: LD_ADDR_VAR 0 23
89303: PUSH
89304: LD_VAR 0 6
89308: PUSH
89309: LD_INT 7
89311: ARRAY
89312: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
89313: LD_ADDR_VAR 0 24
89317: PUSH
89318: LD_VAR 0 6
89322: PUSH
89323: LD_INT 8
89325: ARRAY
89326: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
89327: LD_ADDR_VAR 0 25
89331: PUSH
89332: LD_VAR 0 6
89336: PUSH
89337: LD_INT 9
89339: ARRAY
89340: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
89341: LD_ADDR_VAR 0 26
89345: PUSH
89346: LD_VAR 0 6
89350: PUSH
89351: LD_INT 10
89353: ARRAY
89354: ST_TO_ADDR
// end else
89355: GO 89437
// begin f_ignore_area := false ;
89357: LD_ADDR_VAR 0 17
89361: PUSH
89362: LD_INT 0
89364: ST_TO_ADDR
// f_capture := false ;
89365: LD_ADDR_VAR 0 18
89369: PUSH
89370: LD_INT 0
89372: ST_TO_ADDR
// f_ignore_civ := false ;
89373: LD_ADDR_VAR 0 19
89377: PUSH
89378: LD_INT 0
89380: ST_TO_ADDR
// f_murder := false ;
89381: LD_ADDR_VAR 0 20
89385: PUSH
89386: LD_INT 0
89388: ST_TO_ADDR
// f_mines := false ;
89389: LD_ADDR_VAR 0 21
89393: PUSH
89394: LD_INT 0
89396: ST_TO_ADDR
// f_repair := false ;
89397: LD_ADDR_VAR 0 22
89401: PUSH
89402: LD_INT 0
89404: ST_TO_ADDR
// f_heal := false ;
89405: LD_ADDR_VAR 0 23
89409: PUSH
89410: LD_INT 0
89412: ST_TO_ADDR
// f_spacetime := false ;
89413: LD_ADDR_VAR 0 24
89417: PUSH
89418: LD_INT 0
89420: ST_TO_ADDR
// f_attack_depot := false ;
89421: LD_ADDR_VAR 0 25
89425: PUSH
89426: LD_INT 0
89428: ST_TO_ADDR
// f_crawl := false ;
89429: LD_ADDR_VAR 0 26
89433: PUSH
89434: LD_INT 0
89436: ST_TO_ADDR
// end ; if f_heal then
89437: LD_VAR 0 23
89441: IFFALSE 89468
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
89443: LD_ADDR_VAR 0 31
89447: PUSH
89448: LD_VAR 0 4
89452: PPUSH
89453: LD_INT 25
89455: PUSH
89456: LD_INT 4
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PPUSH
89463: CALL_OW 72
89467: ST_TO_ADDR
// if f_repair then
89468: LD_VAR 0 22
89472: IFFALSE 89499
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
89474: LD_ADDR_VAR 0 33
89478: PUSH
89479: LD_VAR 0 4
89483: PPUSH
89484: LD_INT 25
89486: PUSH
89487: LD_INT 3
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PPUSH
89494: CALL_OW 72
89498: ST_TO_ADDR
// units_path := [ ] ;
89499: LD_ADDR_VAR 0 16
89503: PUSH
89504: EMPTY
89505: ST_TO_ADDR
// for i = 1 to group do
89506: LD_ADDR_VAR 0 7
89510: PUSH
89511: DOUBLE
89512: LD_INT 1
89514: DEC
89515: ST_TO_ADDR
89516: LD_VAR 0 4
89520: PUSH
89521: FOR_TO
89522: IFFALSE 89551
// units_path := Replace ( units_path , i , path ) ;
89524: LD_ADDR_VAR 0 16
89528: PUSH
89529: LD_VAR 0 16
89533: PPUSH
89534: LD_VAR 0 7
89538: PPUSH
89539: LD_VAR 0 5
89543: PPUSH
89544: CALL_OW 1
89548: ST_TO_ADDR
89549: GO 89521
89551: POP
89552: POP
// repeat for i = group downto 1 do
89553: LD_ADDR_VAR 0 7
89557: PUSH
89558: DOUBLE
89559: LD_VAR 0 4
89563: INC
89564: ST_TO_ADDR
89565: LD_INT 1
89567: PUSH
89568: FOR_DOWNTO
89569: IFFALSE 93665
// begin wait ( 5 ) ;
89571: LD_INT 5
89573: PPUSH
89574: CALL_OW 67
// tmp := [ ] ;
89578: LD_ADDR_VAR 0 14
89582: PUSH
89583: EMPTY
89584: ST_TO_ADDR
// attacking := false ;
89585: LD_ADDR_VAR 0 29
89589: PUSH
89590: LD_INT 0
89592: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
89593: LD_VAR 0 4
89597: PUSH
89598: LD_VAR 0 7
89602: ARRAY
89603: PPUSH
89604: CALL_OW 301
89608: PUSH
89609: LD_VAR 0 4
89613: PUSH
89614: LD_VAR 0 7
89618: ARRAY
89619: NOT
89620: OR
89621: IFFALSE 89730
// begin if GetType ( group [ i ] ) = unit_human then
89623: LD_VAR 0 4
89627: PUSH
89628: LD_VAR 0 7
89632: ARRAY
89633: PPUSH
89634: CALL_OW 247
89638: PUSH
89639: LD_INT 1
89641: EQUAL
89642: IFFALSE 89688
// begin to_heal := to_heal diff group [ i ] ;
89644: LD_ADDR_VAR 0 30
89648: PUSH
89649: LD_VAR 0 30
89653: PUSH
89654: LD_VAR 0 4
89658: PUSH
89659: LD_VAR 0 7
89663: ARRAY
89664: DIFF
89665: ST_TO_ADDR
// healers := healers diff group [ i ] ;
89666: LD_ADDR_VAR 0 31
89670: PUSH
89671: LD_VAR 0 31
89675: PUSH
89676: LD_VAR 0 4
89680: PUSH
89681: LD_VAR 0 7
89685: ARRAY
89686: DIFF
89687: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
89688: LD_ADDR_VAR 0 4
89692: PUSH
89693: LD_VAR 0 4
89697: PPUSH
89698: LD_VAR 0 7
89702: PPUSH
89703: CALL_OW 3
89707: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
89708: LD_ADDR_VAR 0 16
89712: PUSH
89713: LD_VAR 0 16
89717: PPUSH
89718: LD_VAR 0 7
89722: PPUSH
89723: CALL_OW 3
89727: ST_TO_ADDR
// continue ;
89728: GO 89568
// end ; if f_repair then
89730: LD_VAR 0 22
89734: IFFALSE 90223
// begin if GetType ( group [ i ] ) = unit_vehicle then
89736: LD_VAR 0 4
89740: PUSH
89741: LD_VAR 0 7
89745: ARRAY
89746: PPUSH
89747: CALL_OW 247
89751: PUSH
89752: LD_INT 2
89754: EQUAL
89755: IFFALSE 89945
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
89757: LD_VAR 0 4
89761: PUSH
89762: LD_VAR 0 7
89766: ARRAY
89767: PPUSH
89768: CALL_OW 256
89772: PUSH
89773: LD_INT 700
89775: LESS
89776: PUSH
89777: LD_VAR 0 4
89781: PUSH
89782: LD_VAR 0 7
89786: ARRAY
89787: PUSH
89788: LD_VAR 0 32
89792: IN
89793: NOT
89794: AND
89795: IFFALSE 89819
// to_repair := to_repair union group [ i ] ;
89797: LD_ADDR_VAR 0 32
89801: PUSH
89802: LD_VAR 0 32
89806: PUSH
89807: LD_VAR 0 4
89811: PUSH
89812: LD_VAR 0 7
89816: ARRAY
89817: UNION
89818: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
89819: LD_VAR 0 4
89823: PUSH
89824: LD_VAR 0 7
89828: ARRAY
89829: PPUSH
89830: CALL_OW 256
89834: PUSH
89835: LD_INT 1000
89837: EQUAL
89838: PUSH
89839: LD_VAR 0 4
89843: PUSH
89844: LD_VAR 0 7
89848: ARRAY
89849: PUSH
89850: LD_VAR 0 32
89854: IN
89855: AND
89856: IFFALSE 89880
// to_repair := to_repair diff group [ i ] ;
89858: LD_ADDR_VAR 0 32
89862: PUSH
89863: LD_VAR 0 32
89867: PUSH
89868: LD_VAR 0 4
89872: PUSH
89873: LD_VAR 0 7
89877: ARRAY
89878: DIFF
89879: ST_TO_ADDR
// if group [ i ] in to_repair then
89880: LD_VAR 0 4
89884: PUSH
89885: LD_VAR 0 7
89889: ARRAY
89890: PUSH
89891: LD_VAR 0 32
89895: IN
89896: IFFALSE 89943
// begin if not IsInArea ( group [ i ] , f_repair ) then
89898: LD_VAR 0 4
89902: PUSH
89903: LD_VAR 0 7
89907: ARRAY
89908: PPUSH
89909: LD_VAR 0 22
89913: PPUSH
89914: CALL_OW 308
89918: NOT
89919: IFFALSE 89941
// ComMoveToArea ( group [ i ] , f_repair ) ;
89921: LD_VAR 0 4
89925: PUSH
89926: LD_VAR 0 7
89930: ARRAY
89931: PPUSH
89932: LD_VAR 0 22
89936: PPUSH
89937: CALL_OW 113
// continue ;
89941: GO 89568
// end ; end else
89943: GO 90223
// if group [ i ] in repairs then
89945: LD_VAR 0 4
89949: PUSH
89950: LD_VAR 0 7
89954: ARRAY
89955: PUSH
89956: LD_VAR 0 33
89960: IN
89961: IFFALSE 90223
// begin if IsInUnit ( group [ i ] ) then
89963: LD_VAR 0 4
89967: PUSH
89968: LD_VAR 0 7
89972: ARRAY
89973: PPUSH
89974: CALL_OW 310
89978: IFFALSE 90046
// begin z := IsInUnit ( group [ i ] ) ;
89980: LD_ADDR_VAR 0 13
89984: PUSH
89985: LD_VAR 0 4
89989: PUSH
89990: LD_VAR 0 7
89994: ARRAY
89995: PPUSH
89996: CALL_OW 310
90000: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
90001: LD_VAR 0 13
90005: PUSH
90006: LD_VAR 0 32
90010: IN
90011: PUSH
90012: LD_VAR 0 13
90016: PPUSH
90017: LD_VAR 0 22
90021: PPUSH
90022: CALL_OW 308
90026: AND
90027: IFFALSE 90044
// ComExitVehicle ( group [ i ] ) ;
90029: LD_VAR 0 4
90033: PUSH
90034: LD_VAR 0 7
90038: ARRAY
90039: PPUSH
90040: CALL_OW 121
// end else
90044: GO 90223
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
90046: LD_ADDR_VAR 0 13
90050: PUSH
90051: LD_VAR 0 4
90055: PPUSH
90056: LD_INT 95
90058: PUSH
90059: LD_VAR 0 22
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 58
90070: PUSH
90071: EMPTY
90072: LIST
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PPUSH
90078: CALL_OW 72
90082: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
90083: LD_VAR 0 4
90087: PUSH
90088: LD_VAR 0 7
90092: ARRAY
90093: PPUSH
90094: CALL_OW 314
90098: NOT
90099: IFFALSE 90221
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
90101: LD_ADDR_VAR 0 10
90105: PUSH
90106: LD_VAR 0 13
90110: PPUSH
90111: LD_VAR 0 4
90115: PUSH
90116: LD_VAR 0 7
90120: ARRAY
90121: PPUSH
90122: CALL_OW 74
90126: ST_TO_ADDR
// if not x then
90127: LD_VAR 0 10
90131: NOT
90132: IFFALSE 90136
// continue ;
90134: GO 89568
// if GetLives ( x ) < 1000 then
90136: LD_VAR 0 10
90140: PPUSH
90141: CALL_OW 256
90145: PUSH
90146: LD_INT 1000
90148: LESS
90149: IFFALSE 90173
// ComRepairVehicle ( group [ i ] , x ) else
90151: LD_VAR 0 4
90155: PUSH
90156: LD_VAR 0 7
90160: ARRAY
90161: PPUSH
90162: LD_VAR 0 10
90166: PPUSH
90167: CALL_OW 129
90171: GO 90221
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
90173: LD_VAR 0 23
90177: PUSH
90178: LD_VAR 0 4
90182: PUSH
90183: LD_VAR 0 7
90187: ARRAY
90188: PPUSH
90189: CALL_OW 256
90193: PUSH
90194: LD_INT 1000
90196: LESS
90197: AND
90198: NOT
90199: IFFALSE 90221
// ComEnterUnit ( group [ i ] , x ) ;
90201: LD_VAR 0 4
90205: PUSH
90206: LD_VAR 0 7
90210: ARRAY
90211: PPUSH
90212: LD_VAR 0 10
90216: PPUSH
90217: CALL_OW 120
// end ; continue ;
90221: GO 89568
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
90223: LD_VAR 0 23
90227: PUSH
90228: LD_VAR 0 4
90232: PUSH
90233: LD_VAR 0 7
90237: ARRAY
90238: PPUSH
90239: CALL_OW 247
90243: PUSH
90244: LD_INT 1
90246: EQUAL
90247: AND
90248: IFFALSE 90726
// begin if group [ i ] in healers then
90250: LD_VAR 0 4
90254: PUSH
90255: LD_VAR 0 7
90259: ARRAY
90260: PUSH
90261: LD_VAR 0 31
90265: IN
90266: IFFALSE 90539
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
90268: LD_VAR 0 4
90272: PUSH
90273: LD_VAR 0 7
90277: ARRAY
90278: PPUSH
90279: LD_VAR 0 23
90283: PPUSH
90284: CALL_OW 308
90288: NOT
90289: PUSH
90290: LD_VAR 0 4
90294: PUSH
90295: LD_VAR 0 7
90299: ARRAY
90300: PPUSH
90301: CALL_OW 314
90305: NOT
90306: AND
90307: IFFALSE 90331
// ComMoveToArea ( group [ i ] , f_heal ) else
90309: LD_VAR 0 4
90313: PUSH
90314: LD_VAR 0 7
90318: ARRAY
90319: PPUSH
90320: LD_VAR 0 23
90324: PPUSH
90325: CALL_OW 113
90329: GO 90537
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
90331: LD_VAR 0 4
90335: PUSH
90336: LD_VAR 0 7
90340: ARRAY
90341: PPUSH
90342: CALL 88969 0 1
90346: PPUSH
90347: CALL_OW 256
90351: PUSH
90352: LD_INT 1000
90354: EQUAL
90355: IFFALSE 90374
// ComStop ( group [ i ] ) else
90357: LD_VAR 0 4
90361: PUSH
90362: LD_VAR 0 7
90366: ARRAY
90367: PPUSH
90368: CALL_OW 141
90372: GO 90537
// if not HasTask ( group [ i ] ) and to_heal then
90374: LD_VAR 0 4
90378: PUSH
90379: LD_VAR 0 7
90383: ARRAY
90384: PPUSH
90385: CALL_OW 314
90389: NOT
90390: PUSH
90391: LD_VAR 0 30
90395: AND
90396: IFFALSE 90537
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
90398: LD_ADDR_VAR 0 13
90402: PUSH
90403: LD_VAR 0 30
90407: PPUSH
90408: LD_INT 3
90410: PUSH
90411: LD_INT 54
90413: PUSH
90414: EMPTY
90415: LIST
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PPUSH
90421: CALL_OW 72
90425: PPUSH
90426: LD_VAR 0 4
90430: PUSH
90431: LD_VAR 0 7
90435: ARRAY
90436: PPUSH
90437: CALL_OW 74
90441: ST_TO_ADDR
// if z then
90442: LD_VAR 0 13
90446: IFFALSE 90537
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
90448: LD_INT 91
90450: PUSH
90451: LD_VAR 0 13
90455: PUSH
90456: LD_INT 10
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: LIST
90463: PUSH
90464: LD_INT 81
90466: PUSH
90467: LD_VAR 0 13
90471: PPUSH
90472: CALL_OW 255
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PPUSH
90485: CALL_OW 69
90489: PUSH
90490: LD_INT 0
90492: EQUAL
90493: IFFALSE 90517
// ComHeal ( group [ i ] , z ) else
90495: LD_VAR 0 4
90499: PUSH
90500: LD_VAR 0 7
90504: ARRAY
90505: PPUSH
90506: LD_VAR 0 13
90510: PPUSH
90511: CALL_OW 128
90515: GO 90537
// ComMoveToArea ( group [ i ] , f_heal ) ;
90517: LD_VAR 0 4
90521: PUSH
90522: LD_VAR 0 7
90526: ARRAY
90527: PPUSH
90528: LD_VAR 0 23
90532: PPUSH
90533: CALL_OW 113
// end ; continue ;
90537: GO 89568
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
90539: LD_VAR 0 4
90543: PUSH
90544: LD_VAR 0 7
90548: ARRAY
90549: PPUSH
90550: CALL_OW 256
90554: PUSH
90555: LD_INT 700
90557: LESS
90558: PUSH
90559: LD_VAR 0 4
90563: PUSH
90564: LD_VAR 0 7
90568: ARRAY
90569: PUSH
90570: LD_VAR 0 30
90574: IN
90575: NOT
90576: AND
90577: IFFALSE 90601
// to_heal := to_heal union group [ i ] ;
90579: LD_ADDR_VAR 0 30
90583: PUSH
90584: LD_VAR 0 30
90588: PUSH
90589: LD_VAR 0 4
90593: PUSH
90594: LD_VAR 0 7
90598: ARRAY
90599: UNION
90600: ST_TO_ADDR
// if group [ i ] in to_heal then
90601: LD_VAR 0 4
90605: PUSH
90606: LD_VAR 0 7
90610: ARRAY
90611: PUSH
90612: LD_VAR 0 30
90616: IN
90617: IFFALSE 90726
// begin if GetLives ( group [ i ] ) = 1000 then
90619: LD_VAR 0 4
90623: PUSH
90624: LD_VAR 0 7
90628: ARRAY
90629: PPUSH
90630: CALL_OW 256
90634: PUSH
90635: LD_INT 1000
90637: EQUAL
90638: IFFALSE 90664
// to_heal := to_heal diff group [ i ] else
90640: LD_ADDR_VAR 0 30
90644: PUSH
90645: LD_VAR 0 30
90649: PUSH
90650: LD_VAR 0 4
90654: PUSH
90655: LD_VAR 0 7
90659: ARRAY
90660: DIFF
90661: ST_TO_ADDR
90662: GO 90726
// begin if not IsInArea ( group [ i ] , to_heal ) then
90664: LD_VAR 0 4
90668: PUSH
90669: LD_VAR 0 7
90673: ARRAY
90674: PPUSH
90675: LD_VAR 0 30
90679: PPUSH
90680: CALL_OW 308
90684: NOT
90685: IFFALSE 90709
// ComMoveToArea ( group [ i ] , f_heal ) else
90687: LD_VAR 0 4
90691: PUSH
90692: LD_VAR 0 7
90696: ARRAY
90697: PPUSH
90698: LD_VAR 0 23
90702: PPUSH
90703: CALL_OW 113
90707: GO 90724
// ComHold ( group [ i ] ) ;
90709: LD_VAR 0 4
90713: PUSH
90714: LD_VAR 0 7
90718: ARRAY
90719: PPUSH
90720: CALL_OW 140
// continue ;
90724: GO 89568
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
90726: LD_VAR 0 4
90730: PUSH
90731: LD_VAR 0 7
90735: ARRAY
90736: PPUSH
90737: LD_INT 10
90739: PPUSH
90740: CALL 87366 0 2
90744: NOT
90745: PUSH
90746: LD_VAR 0 16
90750: PUSH
90751: LD_VAR 0 7
90755: ARRAY
90756: PUSH
90757: EMPTY
90758: EQUAL
90759: NOT
90760: AND
90761: IFFALSE 91027
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
90763: LD_VAR 0 4
90767: PUSH
90768: LD_VAR 0 7
90772: ARRAY
90773: PPUSH
90774: CALL_OW 262
90778: PUSH
90779: LD_INT 1
90781: PUSH
90782: LD_INT 2
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: IN
90789: IFFALSE 90830
// if GetFuel ( group [ i ] ) < 10 then
90791: LD_VAR 0 4
90795: PUSH
90796: LD_VAR 0 7
90800: ARRAY
90801: PPUSH
90802: CALL_OW 261
90806: PUSH
90807: LD_INT 10
90809: LESS
90810: IFFALSE 90830
// SetFuel ( group [ i ] , 12 ) ;
90812: LD_VAR 0 4
90816: PUSH
90817: LD_VAR 0 7
90821: ARRAY
90822: PPUSH
90823: LD_INT 12
90825: PPUSH
90826: CALL_OW 240
// if units_path [ i ] then
90830: LD_VAR 0 16
90834: PUSH
90835: LD_VAR 0 7
90839: ARRAY
90840: IFFALSE 91025
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
90842: LD_VAR 0 4
90846: PUSH
90847: LD_VAR 0 7
90851: ARRAY
90852: PPUSH
90853: LD_VAR 0 16
90857: PUSH
90858: LD_VAR 0 7
90862: ARRAY
90863: PUSH
90864: LD_INT 1
90866: ARRAY
90867: PUSH
90868: LD_INT 1
90870: ARRAY
90871: PPUSH
90872: LD_VAR 0 16
90876: PUSH
90877: LD_VAR 0 7
90881: ARRAY
90882: PUSH
90883: LD_INT 1
90885: ARRAY
90886: PUSH
90887: LD_INT 2
90889: ARRAY
90890: PPUSH
90891: CALL_OW 297
90895: PUSH
90896: LD_INT 6
90898: GREATER
90899: IFFALSE 90974
// begin if not HasTask ( group [ i ] ) then
90901: LD_VAR 0 4
90905: PUSH
90906: LD_VAR 0 7
90910: ARRAY
90911: PPUSH
90912: CALL_OW 314
90916: NOT
90917: IFFALSE 90972
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
90919: LD_VAR 0 4
90923: PUSH
90924: LD_VAR 0 7
90928: ARRAY
90929: PPUSH
90930: LD_VAR 0 16
90934: PUSH
90935: LD_VAR 0 7
90939: ARRAY
90940: PUSH
90941: LD_INT 1
90943: ARRAY
90944: PUSH
90945: LD_INT 1
90947: ARRAY
90948: PPUSH
90949: LD_VAR 0 16
90953: PUSH
90954: LD_VAR 0 7
90958: ARRAY
90959: PUSH
90960: LD_INT 1
90962: ARRAY
90963: PUSH
90964: LD_INT 2
90966: ARRAY
90967: PPUSH
90968: CALL_OW 114
// end else
90972: GO 91025
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
90974: LD_ADDR_VAR 0 15
90978: PUSH
90979: LD_VAR 0 16
90983: PUSH
90984: LD_VAR 0 7
90988: ARRAY
90989: PPUSH
90990: LD_INT 1
90992: PPUSH
90993: CALL_OW 3
90997: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
90998: LD_ADDR_VAR 0 16
91002: PUSH
91003: LD_VAR 0 16
91007: PPUSH
91008: LD_VAR 0 7
91012: PPUSH
91013: LD_VAR 0 15
91017: PPUSH
91018: CALL_OW 1
91022: ST_TO_ADDR
// continue ;
91023: GO 89568
// end ; end ; end else
91025: GO 93663
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
91027: LD_ADDR_VAR 0 14
91031: PUSH
91032: LD_INT 81
91034: PUSH
91035: LD_VAR 0 4
91039: PUSH
91040: LD_VAR 0 7
91044: ARRAY
91045: PPUSH
91046: CALL_OW 255
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PPUSH
91055: CALL_OW 69
91059: ST_TO_ADDR
// if not tmp then
91060: LD_VAR 0 14
91064: NOT
91065: IFFALSE 91069
// continue ;
91067: GO 89568
// if f_ignore_area then
91069: LD_VAR 0 17
91073: IFFALSE 91161
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
91075: LD_ADDR_VAR 0 15
91079: PUSH
91080: LD_VAR 0 14
91084: PPUSH
91085: LD_INT 3
91087: PUSH
91088: LD_INT 92
91090: PUSH
91091: LD_VAR 0 17
91095: PUSH
91096: LD_INT 1
91098: ARRAY
91099: PUSH
91100: LD_VAR 0 17
91104: PUSH
91105: LD_INT 2
91107: ARRAY
91108: PUSH
91109: LD_VAR 0 17
91113: PUSH
91114: LD_INT 3
91116: ARRAY
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: PPUSH
91128: CALL_OW 72
91132: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
91133: LD_VAR 0 14
91137: PUSH
91138: LD_VAR 0 15
91142: DIFF
91143: IFFALSE 91161
// tmp := tmp diff tmp2 ;
91145: LD_ADDR_VAR 0 14
91149: PUSH
91150: LD_VAR 0 14
91154: PUSH
91155: LD_VAR 0 15
91159: DIFF
91160: ST_TO_ADDR
// end ; if not f_murder then
91161: LD_VAR 0 20
91165: NOT
91166: IFFALSE 91224
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
91168: LD_ADDR_VAR 0 15
91172: PUSH
91173: LD_VAR 0 14
91177: PPUSH
91178: LD_INT 3
91180: PUSH
91181: LD_INT 50
91183: PUSH
91184: EMPTY
91185: LIST
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: PPUSH
91191: CALL_OW 72
91195: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
91196: LD_VAR 0 14
91200: PUSH
91201: LD_VAR 0 15
91205: DIFF
91206: IFFALSE 91224
// tmp := tmp diff tmp2 ;
91208: LD_ADDR_VAR 0 14
91212: PUSH
91213: LD_VAR 0 14
91217: PUSH
91218: LD_VAR 0 15
91222: DIFF
91223: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
91224: LD_ADDR_VAR 0 14
91228: PUSH
91229: LD_VAR 0 4
91233: PUSH
91234: LD_VAR 0 7
91238: ARRAY
91239: PPUSH
91240: LD_VAR 0 14
91244: PPUSH
91245: LD_INT 1
91247: PPUSH
91248: LD_INT 1
91250: PPUSH
91251: CALL 61033 0 4
91255: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
91256: LD_VAR 0 4
91260: PUSH
91261: LD_VAR 0 7
91265: ARRAY
91266: PPUSH
91267: CALL_OW 257
91271: PUSH
91272: LD_INT 1
91274: EQUAL
91275: IFFALSE 91723
// begin if WantPlant ( group [ i ] ) then
91277: LD_VAR 0 4
91281: PUSH
91282: LD_VAR 0 7
91286: ARRAY
91287: PPUSH
91288: CALL 60534 0 1
91292: IFFALSE 91296
// continue ;
91294: GO 89568
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
91296: LD_VAR 0 18
91300: PUSH
91301: LD_VAR 0 4
91305: PUSH
91306: LD_VAR 0 7
91310: ARRAY
91311: PPUSH
91312: CALL_OW 310
91316: NOT
91317: AND
91318: PUSH
91319: LD_VAR 0 14
91323: PUSH
91324: LD_INT 1
91326: ARRAY
91327: PUSH
91328: LD_VAR 0 14
91332: PPUSH
91333: LD_INT 21
91335: PUSH
91336: LD_INT 2
91338: PUSH
91339: EMPTY
91340: LIST
91341: LIST
91342: PUSH
91343: LD_INT 58
91345: PUSH
91346: EMPTY
91347: LIST
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: PPUSH
91353: CALL_OW 72
91357: IN
91358: AND
91359: IFFALSE 91395
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
91361: LD_VAR 0 4
91365: PUSH
91366: LD_VAR 0 7
91370: ARRAY
91371: PPUSH
91372: LD_VAR 0 14
91376: PUSH
91377: LD_INT 1
91379: ARRAY
91380: PPUSH
91381: CALL_OW 120
// attacking := true ;
91385: LD_ADDR_VAR 0 29
91389: PUSH
91390: LD_INT 1
91392: ST_TO_ADDR
// continue ;
91393: GO 89568
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
91395: LD_VAR 0 26
91399: PUSH
91400: LD_VAR 0 4
91404: PUSH
91405: LD_VAR 0 7
91409: ARRAY
91410: PPUSH
91411: CALL_OW 257
91415: PUSH
91416: LD_INT 1
91418: EQUAL
91419: AND
91420: PUSH
91421: LD_VAR 0 4
91425: PUSH
91426: LD_VAR 0 7
91430: ARRAY
91431: PPUSH
91432: CALL_OW 256
91436: PUSH
91437: LD_INT 800
91439: LESS
91440: AND
91441: PUSH
91442: LD_VAR 0 4
91446: PUSH
91447: LD_VAR 0 7
91451: ARRAY
91452: PPUSH
91453: CALL_OW 318
91457: NOT
91458: AND
91459: IFFALSE 91476
// ComCrawl ( group [ i ] ) ;
91461: LD_VAR 0 4
91465: PUSH
91466: LD_VAR 0 7
91470: ARRAY
91471: PPUSH
91472: CALL_OW 137
// if f_mines then
91476: LD_VAR 0 21
91480: IFFALSE 91723
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
91482: LD_VAR 0 14
91486: PUSH
91487: LD_INT 1
91489: ARRAY
91490: PPUSH
91491: CALL_OW 247
91495: PUSH
91496: LD_INT 3
91498: EQUAL
91499: PUSH
91500: LD_VAR 0 14
91504: PUSH
91505: LD_INT 1
91507: ARRAY
91508: PUSH
91509: LD_VAR 0 27
91513: IN
91514: NOT
91515: AND
91516: IFFALSE 91723
// begin x := GetX ( tmp [ 1 ] ) ;
91518: LD_ADDR_VAR 0 10
91522: PUSH
91523: LD_VAR 0 14
91527: PUSH
91528: LD_INT 1
91530: ARRAY
91531: PPUSH
91532: CALL_OW 250
91536: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
91537: LD_ADDR_VAR 0 11
91541: PUSH
91542: LD_VAR 0 14
91546: PUSH
91547: LD_INT 1
91549: ARRAY
91550: PPUSH
91551: CALL_OW 251
91555: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
91556: LD_ADDR_VAR 0 12
91560: PUSH
91561: LD_VAR 0 4
91565: PUSH
91566: LD_VAR 0 7
91570: ARRAY
91571: PPUSH
91572: CALL 87451 0 1
91576: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
91577: LD_VAR 0 4
91581: PUSH
91582: LD_VAR 0 7
91586: ARRAY
91587: PPUSH
91588: LD_VAR 0 10
91592: PPUSH
91593: LD_VAR 0 11
91597: PPUSH
91598: LD_VAR 0 14
91602: PUSH
91603: LD_INT 1
91605: ARRAY
91606: PPUSH
91607: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
91611: LD_VAR 0 4
91615: PUSH
91616: LD_VAR 0 7
91620: ARRAY
91621: PPUSH
91622: LD_VAR 0 10
91626: PPUSH
91627: LD_VAR 0 12
91631: PPUSH
91632: LD_INT 7
91634: PPUSH
91635: CALL_OW 272
91639: PPUSH
91640: LD_VAR 0 11
91644: PPUSH
91645: LD_VAR 0 12
91649: PPUSH
91650: LD_INT 7
91652: PPUSH
91653: CALL_OW 273
91657: PPUSH
91658: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
91662: LD_VAR 0 4
91666: PUSH
91667: LD_VAR 0 7
91671: ARRAY
91672: PPUSH
91673: LD_INT 71
91675: PPUSH
91676: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
91680: LD_ADDR_VAR 0 27
91684: PUSH
91685: LD_VAR 0 27
91689: PPUSH
91690: LD_VAR 0 27
91694: PUSH
91695: LD_INT 1
91697: PLUS
91698: PPUSH
91699: LD_VAR 0 14
91703: PUSH
91704: LD_INT 1
91706: ARRAY
91707: PPUSH
91708: CALL_OW 1
91712: ST_TO_ADDR
// attacking := true ;
91713: LD_ADDR_VAR 0 29
91717: PUSH
91718: LD_INT 1
91720: ST_TO_ADDR
// continue ;
91721: GO 89568
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
91723: LD_VAR 0 4
91727: PUSH
91728: LD_VAR 0 7
91732: ARRAY
91733: PPUSH
91734: CALL_OW 257
91738: PUSH
91739: LD_INT 17
91741: EQUAL
91742: PUSH
91743: LD_VAR 0 4
91747: PUSH
91748: LD_VAR 0 7
91752: ARRAY
91753: PPUSH
91754: CALL_OW 110
91758: PUSH
91759: LD_INT 71
91761: EQUAL
91762: NOT
91763: AND
91764: IFFALSE 91910
// begin attacking := false ;
91766: LD_ADDR_VAR 0 29
91770: PUSH
91771: LD_INT 0
91773: ST_TO_ADDR
// k := 5 ;
91774: LD_ADDR_VAR 0 9
91778: PUSH
91779: LD_INT 5
91781: ST_TO_ADDR
// if tmp < k then
91782: LD_VAR 0 14
91786: PUSH
91787: LD_VAR 0 9
91791: LESS
91792: IFFALSE 91804
// k := tmp ;
91794: LD_ADDR_VAR 0 9
91798: PUSH
91799: LD_VAR 0 14
91803: ST_TO_ADDR
// for j = 1 to k do
91804: LD_ADDR_VAR 0 8
91808: PUSH
91809: DOUBLE
91810: LD_INT 1
91812: DEC
91813: ST_TO_ADDR
91814: LD_VAR 0 9
91818: PUSH
91819: FOR_TO
91820: IFFALSE 91908
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
91822: LD_VAR 0 14
91826: PUSH
91827: LD_VAR 0 8
91831: ARRAY
91832: PUSH
91833: LD_VAR 0 14
91837: PPUSH
91838: LD_INT 58
91840: PUSH
91841: EMPTY
91842: LIST
91843: PPUSH
91844: CALL_OW 72
91848: IN
91849: NOT
91850: IFFALSE 91906
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
91852: LD_VAR 0 4
91856: PUSH
91857: LD_VAR 0 7
91861: ARRAY
91862: PPUSH
91863: LD_VAR 0 14
91867: PUSH
91868: LD_VAR 0 8
91872: ARRAY
91873: PPUSH
91874: CALL_OW 115
// attacking := true ;
91878: LD_ADDR_VAR 0 29
91882: PUSH
91883: LD_INT 1
91885: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
91886: LD_VAR 0 4
91890: PUSH
91891: LD_VAR 0 7
91895: ARRAY
91896: PPUSH
91897: LD_INT 71
91899: PPUSH
91900: CALL_OW 109
// continue ;
91904: GO 91819
// end ; end ;
91906: GO 91819
91908: POP
91909: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
91910: LD_VAR 0 4
91914: PUSH
91915: LD_VAR 0 7
91919: ARRAY
91920: PPUSH
91921: CALL_OW 257
91925: PUSH
91926: LD_INT 8
91928: EQUAL
91929: PUSH
91930: LD_VAR 0 4
91934: PUSH
91935: LD_VAR 0 7
91939: ARRAY
91940: PPUSH
91941: CALL_OW 264
91945: PUSH
91946: LD_INT 28
91948: PUSH
91949: LD_INT 45
91951: PUSH
91952: LD_INT 7
91954: PUSH
91955: LD_INT 47
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: IN
91964: OR
91965: IFFALSE 92195
// begin attacking := false ;
91967: LD_ADDR_VAR 0 29
91971: PUSH
91972: LD_INT 0
91974: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
91975: LD_VAR 0 14
91979: PUSH
91980: LD_INT 1
91982: ARRAY
91983: PPUSH
91984: CALL_OW 266
91988: PUSH
91989: LD_INT 32
91991: PUSH
91992: LD_INT 31
91994: PUSH
91995: LD_INT 33
91997: PUSH
91998: LD_INT 4
92000: PUSH
92001: LD_INT 5
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: IN
92011: IFFALSE 92195
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
92013: LD_ADDR_VAR 0 9
92017: PUSH
92018: LD_VAR 0 14
92022: PUSH
92023: LD_INT 1
92025: ARRAY
92026: PPUSH
92027: CALL_OW 266
92031: PPUSH
92032: LD_VAR 0 14
92036: PUSH
92037: LD_INT 1
92039: ARRAY
92040: PPUSH
92041: CALL_OW 250
92045: PPUSH
92046: LD_VAR 0 14
92050: PUSH
92051: LD_INT 1
92053: ARRAY
92054: PPUSH
92055: CALL_OW 251
92059: PPUSH
92060: LD_VAR 0 14
92064: PUSH
92065: LD_INT 1
92067: ARRAY
92068: PPUSH
92069: CALL_OW 254
92073: PPUSH
92074: LD_VAR 0 14
92078: PUSH
92079: LD_INT 1
92081: ARRAY
92082: PPUSH
92083: CALL_OW 248
92087: PPUSH
92088: LD_INT 0
92090: PPUSH
92091: CALL 68827 0 6
92095: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
92096: LD_ADDR_VAR 0 8
92100: PUSH
92101: LD_VAR 0 4
92105: PUSH
92106: LD_VAR 0 7
92110: ARRAY
92111: PPUSH
92112: LD_VAR 0 9
92116: PPUSH
92117: CALL 87514 0 2
92121: ST_TO_ADDR
// if j then
92122: LD_VAR 0 8
92126: IFFALSE 92195
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
92128: LD_VAR 0 8
92132: PUSH
92133: LD_INT 1
92135: ARRAY
92136: PPUSH
92137: LD_VAR 0 8
92141: PUSH
92142: LD_INT 2
92144: ARRAY
92145: PPUSH
92146: CALL_OW 488
92150: IFFALSE 92195
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
92152: LD_VAR 0 4
92156: PUSH
92157: LD_VAR 0 7
92161: ARRAY
92162: PPUSH
92163: LD_VAR 0 8
92167: PUSH
92168: LD_INT 1
92170: ARRAY
92171: PPUSH
92172: LD_VAR 0 8
92176: PUSH
92177: LD_INT 2
92179: ARRAY
92180: PPUSH
92181: CALL_OW 116
// attacking := true ;
92185: LD_ADDR_VAR 0 29
92189: PUSH
92190: LD_INT 1
92192: ST_TO_ADDR
// continue ;
92193: GO 89568
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
92195: LD_VAR 0 4
92199: PUSH
92200: LD_VAR 0 7
92204: ARRAY
92205: PPUSH
92206: CALL_OW 265
92210: PUSH
92211: LD_INT 11
92213: EQUAL
92214: IFFALSE 92492
// begin k := 10 ;
92216: LD_ADDR_VAR 0 9
92220: PUSH
92221: LD_INT 10
92223: ST_TO_ADDR
// x := 0 ;
92224: LD_ADDR_VAR 0 10
92228: PUSH
92229: LD_INT 0
92231: ST_TO_ADDR
// if tmp < k then
92232: LD_VAR 0 14
92236: PUSH
92237: LD_VAR 0 9
92241: LESS
92242: IFFALSE 92254
// k := tmp ;
92244: LD_ADDR_VAR 0 9
92248: PUSH
92249: LD_VAR 0 14
92253: ST_TO_ADDR
// for j = k downto 1 do
92254: LD_ADDR_VAR 0 8
92258: PUSH
92259: DOUBLE
92260: LD_VAR 0 9
92264: INC
92265: ST_TO_ADDR
92266: LD_INT 1
92268: PUSH
92269: FOR_DOWNTO
92270: IFFALSE 92345
// begin if GetType ( tmp [ j ] ) = unit_human then
92272: LD_VAR 0 14
92276: PUSH
92277: LD_VAR 0 8
92281: ARRAY
92282: PPUSH
92283: CALL_OW 247
92287: PUSH
92288: LD_INT 1
92290: EQUAL
92291: IFFALSE 92343
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
92293: LD_VAR 0 4
92297: PUSH
92298: LD_VAR 0 7
92302: ARRAY
92303: PPUSH
92304: LD_VAR 0 14
92308: PUSH
92309: LD_VAR 0 8
92313: ARRAY
92314: PPUSH
92315: CALL 87785 0 2
// x := tmp [ j ] ;
92319: LD_ADDR_VAR 0 10
92323: PUSH
92324: LD_VAR 0 14
92328: PUSH
92329: LD_VAR 0 8
92333: ARRAY
92334: ST_TO_ADDR
// attacking := true ;
92335: LD_ADDR_VAR 0 29
92339: PUSH
92340: LD_INT 1
92342: ST_TO_ADDR
// end ; end ;
92343: GO 92269
92345: POP
92346: POP
// if not x then
92347: LD_VAR 0 10
92351: NOT
92352: IFFALSE 92492
// begin attacking := true ;
92354: LD_ADDR_VAR 0 29
92358: PUSH
92359: LD_INT 1
92361: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
92362: LD_VAR 0 4
92366: PUSH
92367: LD_VAR 0 7
92371: ARRAY
92372: PPUSH
92373: CALL_OW 250
92377: PPUSH
92378: LD_VAR 0 4
92382: PUSH
92383: LD_VAR 0 7
92387: ARRAY
92388: PPUSH
92389: CALL_OW 251
92393: PPUSH
92394: CALL_OW 546
92398: PUSH
92399: LD_INT 2
92401: ARRAY
92402: PUSH
92403: LD_VAR 0 14
92407: PUSH
92408: LD_INT 1
92410: ARRAY
92411: PPUSH
92412: CALL_OW 250
92416: PPUSH
92417: LD_VAR 0 14
92421: PUSH
92422: LD_INT 1
92424: ARRAY
92425: PPUSH
92426: CALL_OW 251
92430: PPUSH
92431: CALL_OW 546
92435: PUSH
92436: LD_INT 2
92438: ARRAY
92439: EQUAL
92440: IFFALSE 92468
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
92442: LD_VAR 0 4
92446: PUSH
92447: LD_VAR 0 7
92451: ARRAY
92452: PPUSH
92453: LD_VAR 0 14
92457: PUSH
92458: LD_INT 1
92460: ARRAY
92461: PPUSH
92462: CALL 87785 0 2
92466: GO 92492
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
92468: LD_VAR 0 4
92472: PUSH
92473: LD_VAR 0 7
92477: ARRAY
92478: PPUSH
92479: LD_VAR 0 14
92483: PUSH
92484: LD_INT 1
92486: ARRAY
92487: PPUSH
92488: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
92492: LD_VAR 0 4
92496: PUSH
92497: LD_VAR 0 7
92501: ARRAY
92502: PPUSH
92503: CALL_OW 264
92507: PUSH
92508: LD_INT 29
92510: EQUAL
92511: IFFALSE 92877
// begin if WantsToAttack ( group [ i ] ) in bombed then
92513: LD_VAR 0 4
92517: PUSH
92518: LD_VAR 0 7
92522: ARRAY
92523: PPUSH
92524: CALL_OW 319
92528: PUSH
92529: LD_VAR 0 28
92533: IN
92534: IFFALSE 92538
// continue ;
92536: GO 89568
// k := 8 ;
92538: LD_ADDR_VAR 0 9
92542: PUSH
92543: LD_INT 8
92545: ST_TO_ADDR
// x := 0 ;
92546: LD_ADDR_VAR 0 10
92550: PUSH
92551: LD_INT 0
92553: ST_TO_ADDR
// if tmp < k then
92554: LD_VAR 0 14
92558: PUSH
92559: LD_VAR 0 9
92563: LESS
92564: IFFALSE 92576
// k := tmp ;
92566: LD_ADDR_VAR 0 9
92570: PUSH
92571: LD_VAR 0 14
92575: ST_TO_ADDR
// for j = 1 to k do
92576: LD_ADDR_VAR 0 8
92580: PUSH
92581: DOUBLE
92582: LD_INT 1
92584: DEC
92585: ST_TO_ADDR
92586: LD_VAR 0 9
92590: PUSH
92591: FOR_TO
92592: IFFALSE 92724
// begin if GetType ( tmp [ j ] ) = unit_building then
92594: LD_VAR 0 14
92598: PUSH
92599: LD_VAR 0 8
92603: ARRAY
92604: PPUSH
92605: CALL_OW 247
92609: PUSH
92610: LD_INT 3
92612: EQUAL
92613: IFFALSE 92722
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
92615: LD_VAR 0 14
92619: PUSH
92620: LD_VAR 0 8
92624: ARRAY
92625: PUSH
92626: LD_VAR 0 28
92630: IN
92631: NOT
92632: PUSH
92633: LD_VAR 0 14
92637: PUSH
92638: LD_VAR 0 8
92642: ARRAY
92643: PPUSH
92644: CALL_OW 313
92648: AND
92649: IFFALSE 92722
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
92651: LD_VAR 0 4
92655: PUSH
92656: LD_VAR 0 7
92660: ARRAY
92661: PPUSH
92662: LD_VAR 0 14
92666: PUSH
92667: LD_VAR 0 8
92671: ARRAY
92672: PPUSH
92673: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
92677: LD_ADDR_VAR 0 28
92681: PUSH
92682: LD_VAR 0 28
92686: PPUSH
92687: LD_VAR 0 28
92691: PUSH
92692: LD_INT 1
92694: PLUS
92695: PPUSH
92696: LD_VAR 0 14
92700: PUSH
92701: LD_VAR 0 8
92705: ARRAY
92706: PPUSH
92707: CALL_OW 1
92711: ST_TO_ADDR
// attacking := true ;
92712: LD_ADDR_VAR 0 29
92716: PUSH
92717: LD_INT 1
92719: ST_TO_ADDR
// break ;
92720: GO 92724
// end ; end ;
92722: GO 92591
92724: POP
92725: POP
// if not attacking and f_attack_depot then
92726: LD_VAR 0 29
92730: NOT
92731: PUSH
92732: LD_VAR 0 25
92736: AND
92737: IFFALSE 92832
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
92739: LD_ADDR_VAR 0 13
92743: PUSH
92744: LD_VAR 0 14
92748: PPUSH
92749: LD_INT 2
92751: PUSH
92752: LD_INT 30
92754: PUSH
92755: LD_INT 0
92757: PUSH
92758: EMPTY
92759: LIST
92760: LIST
92761: PUSH
92762: LD_INT 30
92764: PUSH
92765: LD_INT 1
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: LIST
92776: PPUSH
92777: CALL_OW 72
92781: ST_TO_ADDR
// if z then
92782: LD_VAR 0 13
92786: IFFALSE 92832
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
92788: LD_VAR 0 4
92792: PUSH
92793: LD_VAR 0 7
92797: ARRAY
92798: PPUSH
92799: LD_VAR 0 13
92803: PPUSH
92804: LD_VAR 0 4
92808: PUSH
92809: LD_VAR 0 7
92813: ARRAY
92814: PPUSH
92815: CALL_OW 74
92819: PPUSH
92820: CALL_OW 115
// attacking := true ;
92824: LD_ADDR_VAR 0 29
92828: PUSH
92829: LD_INT 1
92831: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
92832: LD_VAR 0 4
92836: PUSH
92837: LD_VAR 0 7
92841: ARRAY
92842: PPUSH
92843: CALL_OW 256
92847: PUSH
92848: LD_INT 500
92850: LESS
92851: IFFALSE 92877
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
92853: LD_VAR 0 4
92857: PUSH
92858: LD_VAR 0 7
92862: ARRAY
92863: PPUSH
92864: LD_VAR 0 14
92868: PUSH
92869: LD_INT 1
92871: ARRAY
92872: PPUSH
92873: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
92877: LD_VAR 0 4
92881: PUSH
92882: LD_VAR 0 7
92886: ARRAY
92887: PPUSH
92888: CALL_OW 264
92892: PUSH
92893: LD_INT 49
92895: EQUAL
92896: IFFALSE 93017
// begin if not HasTask ( group [ i ] ) then
92898: LD_VAR 0 4
92902: PUSH
92903: LD_VAR 0 7
92907: ARRAY
92908: PPUSH
92909: CALL_OW 314
92913: NOT
92914: IFFALSE 93017
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
92916: LD_ADDR_VAR 0 9
92920: PUSH
92921: LD_INT 81
92923: PUSH
92924: LD_VAR 0 4
92928: PUSH
92929: LD_VAR 0 7
92933: ARRAY
92934: PPUSH
92935: CALL_OW 255
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: PPUSH
92944: CALL_OW 69
92948: PPUSH
92949: LD_VAR 0 4
92953: PUSH
92954: LD_VAR 0 7
92958: ARRAY
92959: PPUSH
92960: CALL_OW 74
92964: ST_TO_ADDR
// if k then
92965: LD_VAR 0 9
92969: IFFALSE 93017
// if GetDistUnits ( group [ i ] , k ) > 10 then
92971: LD_VAR 0 4
92975: PUSH
92976: LD_VAR 0 7
92980: ARRAY
92981: PPUSH
92982: LD_VAR 0 9
92986: PPUSH
92987: CALL_OW 296
92991: PUSH
92992: LD_INT 10
92994: GREATER
92995: IFFALSE 93017
// ComMoveUnit ( group [ i ] , k ) ;
92997: LD_VAR 0 4
93001: PUSH
93002: LD_VAR 0 7
93006: ARRAY
93007: PPUSH
93008: LD_VAR 0 9
93012: PPUSH
93013: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
93017: LD_VAR 0 4
93021: PUSH
93022: LD_VAR 0 7
93026: ARRAY
93027: PPUSH
93028: CALL_OW 256
93032: PUSH
93033: LD_INT 250
93035: LESS
93036: PUSH
93037: LD_VAR 0 4
93041: PUSH
93042: LD_VAR 0 7
93046: ARRAY
93047: PUSH
93048: LD_INT 21
93050: PUSH
93051: LD_INT 2
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 23
93060: PUSH
93061: LD_INT 2
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PPUSH
93072: CALL_OW 69
93076: IN
93077: AND
93078: IFFALSE 93203
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
93080: LD_ADDR_VAR 0 9
93084: PUSH
93085: LD_OWVAR 3
93089: PUSH
93090: LD_VAR 0 4
93094: PUSH
93095: LD_VAR 0 7
93099: ARRAY
93100: DIFF
93101: PPUSH
93102: LD_VAR 0 4
93106: PUSH
93107: LD_VAR 0 7
93111: ARRAY
93112: PPUSH
93113: CALL_OW 74
93117: ST_TO_ADDR
// if not k then
93118: LD_VAR 0 9
93122: NOT
93123: IFFALSE 93127
// continue ;
93125: GO 89568
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
93127: LD_VAR 0 9
93131: PUSH
93132: LD_INT 81
93134: PUSH
93135: LD_VAR 0 4
93139: PUSH
93140: LD_VAR 0 7
93144: ARRAY
93145: PPUSH
93146: CALL_OW 255
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PPUSH
93155: CALL_OW 69
93159: IN
93160: PUSH
93161: LD_VAR 0 9
93165: PPUSH
93166: LD_VAR 0 4
93170: PUSH
93171: LD_VAR 0 7
93175: ARRAY
93176: PPUSH
93177: CALL_OW 296
93181: PUSH
93182: LD_INT 5
93184: LESS
93185: AND
93186: IFFALSE 93203
// ComAutodestruct ( group [ i ] ) ;
93188: LD_VAR 0 4
93192: PUSH
93193: LD_VAR 0 7
93197: ARRAY
93198: PPUSH
93199: CALL 87683 0 1
// end ; if f_attack_depot then
93203: LD_VAR 0 25
93207: IFFALSE 93319
// begin k := 6 ;
93209: LD_ADDR_VAR 0 9
93213: PUSH
93214: LD_INT 6
93216: ST_TO_ADDR
// if tmp < k then
93217: LD_VAR 0 14
93221: PUSH
93222: LD_VAR 0 9
93226: LESS
93227: IFFALSE 93239
// k := tmp ;
93229: LD_ADDR_VAR 0 9
93233: PUSH
93234: LD_VAR 0 14
93238: ST_TO_ADDR
// for j = 1 to k do
93239: LD_ADDR_VAR 0 8
93243: PUSH
93244: DOUBLE
93245: LD_INT 1
93247: DEC
93248: ST_TO_ADDR
93249: LD_VAR 0 9
93253: PUSH
93254: FOR_TO
93255: IFFALSE 93317
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
93257: LD_VAR 0 8
93261: PPUSH
93262: CALL_OW 266
93266: PUSH
93267: LD_INT 0
93269: PUSH
93270: LD_INT 1
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: IN
93277: IFFALSE 93315
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
93279: LD_VAR 0 4
93283: PUSH
93284: LD_VAR 0 7
93288: ARRAY
93289: PPUSH
93290: LD_VAR 0 14
93294: PUSH
93295: LD_VAR 0 8
93299: ARRAY
93300: PPUSH
93301: CALL_OW 115
// attacking := true ;
93305: LD_ADDR_VAR 0 29
93309: PUSH
93310: LD_INT 1
93312: ST_TO_ADDR
// break ;
93313: GO 93317
// end ;
93315: GO 93254
93317: POP
93318: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
93319: LD_VAR 0 4
93323: PUSH
93324: LD_VAR 0 7
93328: ARRAY
93329: PPUSH
93330: CALL_OW 302
93334: PUSH
93335: LD_VAR 0 29
93339: NOT
93340: AND
93341: IFFALSE 93663
// begin if GetTag ( group [ i ] ) = 71 then
93343: LD_VAR 0 4
93347: PUSH
93348: LD_VAR 0 7
93352: ARRAY
93353: PPUSH
93354: CALL_OW 110
93358: PUSH
93359: LD_INT 71
93361: EQUAL
93362: IFFALSE 93403
// begin if HasTask ( group [ i ] ) then
93364: LD_VAR 0 4
93368: PUSH
93369: LD_VAR 0 7
93373: ARRAY
93374: PPUSH
93375: CALL_OW 314
93379: IFFALSE 93385
// continue else
93381: GO 89568
93383: GO 93403
// SetTag ( group [ i ] , 0 ) ;
93385: LD_VAR 0 4
93389: PUSH
93390: LD_VAR 0 7
93394: ARRAY
93395: PPUSH
93396: LD_INT 0
93398: PPUSH
93399: CALL_OW 109
// end ; k := 8 ;
93403: LD_ADDR_VAR 0 9
93407: PUSH
93408: LD_INT 8
93410: ST_TO_ADDR
// x := 0 ;
93411: LD_ADDR_VAR 0 10
93415: PUSH
93416: LD_INT 0
93418: ST_TO_ADDR
// if tmp < k then
93419: LD_VAR 0 14
93423: PUSH
93424: LD_VAR 0 9
93428: LESS
93429: IFFALSE 93441
// k := tmp ;
93431: LD_ADDR_VAR 0 9
93435: PUSH
93436: LD_VAR 0 14
93440: ST_TO_ADDR
// for j = 1 to k do
93441: LD_ADDR_VAR 0 8
93445: PUSH
93446: DOUBLE
93447: LD_INT 1
93449: DEC
93450: ST_TO_ADDR
93451: LD_VAR 0 9
93455: PUSH
93456: FOR_TO
93457: IFFALSE 93555
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
93459: LD_VAR 0 14
93463: PUSH
93464: LD_VAR 0 8
93468: ARRAY
93469: PPUSH
93470: CALL_OW 247
93474: PUSH
93475: LD_INT 1
93477: EQUAL
93478: PUSH
93479: LD_VAR 0 14
93483: PUSH
93484: LD_VAR 0 8
93488: ARRAY
93489: PPUSH
93490: CALL_OW 256
93494: PUSH
93495: LD_INT 250
93497: LESS
93498: PUSH
93499: LD_VAR 0 20
93503: AND
93504: PUSH
93505: LD_VAR 0 20
93509: NOT
93510: PUSH
93511: LD_VAR 0 14
93515: PUSH
93516: LD_VAR 0 8
93520: ARRAY
93521: PPUSH
93522: CALL_OW 256
93526: PUSH
93527: LD_INT 250
93529: GREATEREQUAL
93530: AND
93531: OR
93532: AND
93533: IFFALSE 93553
// begin x := tmp [ j ] ;
93535: LD_ADDR_VAR 0 10
93539: PUSH
93540: LD_VAR 0 14
93544: PUSH
93545: LD_VAR 0 8
93549: ARRAY
93550: ST_TO_ADDR
// break ;
93551: GO 93555
// end ;
93553: GO 93456
93555: POP
93556: POP
// if x then
93557: LD_VAR 0 10
93561: IFFALSE 93585
// ComAttackUnit ( group [ i ] , x ) else
93563: LD_VAR 0 4
93567: PUSH
93568: LD_VAR 0 7
93572: ARRAY
93573: PPUSH
93574: LD_VAR 0 10
93578: PPUSH
93579: CALL_OW 115
93583: GO 93609
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
93585: LD_VAR 0 4
93589: PUSH
93590: LD_VAR 0 7
93594: ARRAY
93595: PPUSH
93596: LD_VAR 0 14
93600: PUSH
93601: LD_INT 1
93603: ARRAY
93604: PPUSH
93605: CALL_OW 115
// if not HasTask ( group [ i ] ) then
93609: LD_VAR 0 4
93613: PUSH
93614: LD_VAR 0 7
93618: ARRAY
93619: PPUSH
93620: CALL_OW 314
93624: NOT
93625: IFFALSE 93663
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
93627: LD_VAR 0 4
93631: PUSH
93632: LD_VAR 0 7
93636: ARRAY
93637: PPUSH
93638: LD_VAR 0 14
93642: PPUSH
93643: LD_VAR 0 4
93647: PUSH
93648: LD_VAR 0 7
93652: ARRAY
93653: PPUSH
93654: CALL_OW 74
93658: PPUSH
93659: CALL_OW 115
// end ; end ; end ;
93663: GO 89568
93665: POP
93666: POP
// wait ( 0 0$1 ) ;
93667: LD_INT 35
93669: PPUSH
93670: CALL_OW 67
// until group = [ ] ;
93674: LD_VAR 0 4
93678: PUSH
93679: EMPTY
93680: EQUAL
93681: IFFALSE 89553
// end ;
93683: LD_VAR 0 2
93687: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
93688: LD_INT 0
93690: PPUSH
93691: PPUSH
93692: PPUSH
93693: PPUSH
// if not base_units then
93694: LD_VAR 0 1
93698: NOT
93699: IFFALSE 93703
// exit ;
93701: GO 93790
// result := false ;
93703: LD_ADDR_VAR 0 2
93707: PUSH
93708: LD_INT 0
93710: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
93711: LD_ADDR_VAR 0 5
93715: PUSH
93716: LD_VAR 0 1
93720: PPUSH
93721: LD_INT 21
93723: PUSH
93724: LD_INT 3
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PPUSH
93731: CALL_OW 72
93735: ST_TO_ADDR
// if not tmp then
93736: LD_VAR 0 5
93740: NOT
93741: IFFALSE 93745
// exit ;
93743: GO 93790
// for i in tmp do
93745: LD_ADDR_VAR 0 3
93749: PUSH
93750: LD_VAR 0 5
93754: PUSH
93755: FOR_IN
93756: IFFALSE 93788
// begin result := EnemyInRange ( i , 22 ) ;
93758: LD_ADDR_VAR 0 2
93762: PUSH
93763: LD_VAR 0 3
93767: PPUSH
93768: LD_INT 22
93770: PPUSH
93771: CALL 87366 0 2
93775: ST_TO_ADDR
// if result then
93776: LD_VAR 0 2
93780: IFFALSE 93786
// exit ;
93782: POP
93783: POP
93784: GO 93790
// end ;
93786: GO 93755
93788: POP
93789: POP
// end ;
93790: LD_VAR 0 2
93794: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
93795: LD_INT 0
93797: PPUSH
93798: PPUSH
// if not units then
93799: LD_VAR 0 1
93803: NOT
93804: IFFALSE 93808
// exit ;
93806: GO 93878
// result := [ ] ;
93808: LD_ADDR_VAR 0 3
93812: PUSH
93813: EMPTY
93814: ST_TO_ADDR
// for i in units do
93815: LD_ADDR_VAR 0 4
93819: PUSH
93820: LD_VAR 0 1
93824: PUSH
93825: FOR_IN
93826: IFFALSE 93876
// if GetTag ( i ) = tag then
93828: LD_VAR 0 4
93832: PPUSH
93833: CALL_OW 110
93837: PUSH
93838: LD_VAR 0 2
93842: EQUAL
93843: IFFALSE 93874
// result := Insert ( result , result + 1 , i ) ;
93845: LD_ADDR_VAR 0 3
93849: PUSH
93850: LD_VAR 0 3
93854: PPUSH
93855: LD_VAR 0 3
93859: PUSH
93860: LD_INT 1
93862: PLUS
93863: PPUSH
93864: LD_VAR 0 4
93868: PPUSH
93869: CALL_OW 2
93873: ST_TO_ADDR
93874: GO 93825
93876: POP
93877: POP
// end ;
93878: LD_VAR 0 3
93882: RET
// export function IsDriver ( un ) ; begin
93883: LD_INT 0
93885: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
93886: LD_ADDR_VAR 0 2
93890: PUSH
93891: LD_VAR 0 1
93895: PUSH
93896: LD_INT 55
93898: PUSH
93899: EMPTY
93900: LIST
93901: PPUSH
93902: CALL_OW 69
93906: IN
93907: ST_TO_ADDR
// end ;
93908: LD_VAR 0 2
93912: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
93913: LD_INT 0
93915: PPUSH
93916: PPUSH
// list := [ ] ;
93917: LD_ADDR_VAR 0 5
93921: PUSH
93922: EMPTY
93923: ST_TO_ADDR
// case d of 0 :
93924: LD_VAR 0 3
93928: PUSH
93929: LD_INT 0
93931: DOUBLE
93932: EQUAL
93933: IFTRUE 93937
93935: GO 94070
93937: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
93938: LD_ADDR_VAR 0 5
93942: PUSH
93943: LD_VAR 0 1
93947: PUSH
93948: LD_INT 4
93950: MINUS
93951: PUSH
93952: LD_VAR 0 2
93956: PUSH
93957: LD_INT 4
93959: MINUS
93960: PUSH
93961: LD_INT 2
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: LIST
93968: PUSH
93969: LD_VAR 0 1
93973: PUSH
93974: LD_INT 3
93976: MINUS
93977: PUSH
93978: LD_VAR 0 2
93982: PUSH
93983: LD_INT 1
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: LIST
93990: PUSH
93991: LD_VAR 0 1
93995: PUSH
93996: LD_INT 4
93998: PLUS
93999: PUSH
94000: LD_VAR 0 2
94004: PUSH
94005: LD_INT 4
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: LIST
94012: PUSH
94013: LD_VAR 0 1
94017: PUSH
94018: LD_INT 3
94020: PLUS
94021: PUSH
94022: LD_VAR 0 2
94026: PUSH
94027: LD_INT 3
94029: PLUS
94030: PUSH
94031: LD_INT 5
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: LIST
94038: PUSH
94039: LD_VAR 0 1
94043: PUSH
94044: LD_VAR 0 2
94048: PUSH
94049: LD_INT 4
94051: PLUS
94052: PUSH
94053: LD_INT 0
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: LIST
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: ST_TO_ADDR
// end ; 1 :
94068: GO 94768
94070: LD_INT 1
94072: DOUBLE
94073: EQUAL
94074: IFTRUE 94078
94076: GO 94211
94078: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
94079: LD_ADDR_VAR 0 5
94083: PUSH
94084: LD_VAR 0 1
94088: PUSH
94089: LD_VAR 0 2
94093: PUSH
94094: LD_INT 4
94096: MINUS
94097: PUSH
94098: LD_INT 3
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: PUSH
94106: LD_VAR 0 1
94110: PUSH
94111: LD_INT 3
94113: MINUS
94114: PUSH
94115: LD_VAR 0 2
94119: PUSH
94120: LD_INT 3
94122: MINUS
94123: PUSH
94124: LD_INT 2
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: LIST
94131: PUSH
94132: LD_VAR 0 1
94136: PUSH
94137: LD_INT 4
94139: MINUS
94140: PUSH
94141: LD_VAR 0 2
94145: PUSH
94146: LD_INT 1
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: LIST
94153: PUSH
94154: LD_VAR 0 1
94158: PUSH
94159: LD_VAR 0 2
94163: PUSH
94164: LD_INT 3
94166: PLUS
94167: PUSH
94168: LD_INT 0
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: LIST
94175: PUSH
94176: LD_VAR 0 1
94180: PUSH
94181: LD_INT 4
94183: PLUS
94184: PUSH
94185: LD_VAR 0 2
94189: PUSH
94190: LD_INT 4
94192: PLUS
94193: PUSH
94194: LD_INT 5
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: LIST
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: ST_TO_ADDR
// end ; 2 :
94209: GO 94768
94211: LD_INT 2
94213: DOUBLE
94214: EQUAL
94215: IFTRUE 94219
94217: GO 94348
94219: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
94220: LD_ADDR_VAR 0 5
94224: PUSH
94225: LD_VAR 0 1
94229: PUSH
94230: LD_VAR 0 2
94234: PUSH
94235: LD_INT 3
94237: MINUS
94238: PUSH
94239: LD_INT 3
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: LIST
94246: PUSH
94247: LD_VAR 0 1
94251: PUSH
94252: LD_INT 4
94254: PLUS
94255: PUSH
94256: LD_VAR 0 2
94260: PUSH
94261: LD_INT 4
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: LIST
94268: PUSH
94269: LD_VAR 0 1
94273: PUSH
94274: LD_VAR 0 2
94278: PUSH
94279: LD_INT 4
94281: PLUS
94282: PUSH
94283: LD_INT 0
94285: PUSH
94286: EMPTY
94287: LIST
94288: LIST
94289: LIST
94290: PUSH
94291: LD_VAR 0 1
94295: PUSH
94296: LD_INT 3
94298: MINUS
94299: PUSH
94300: LD_VAR 0 2
94304: PUSH
94305: LD_INT 1
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: LIST
94312: PUSH
94313: LD_VAR 0 1
94317: PUSH
94318: LD_INT 4
94320: MINUS
94321: PUSH
94322: LD_VAR 0 2
94326: PUSH
94327: LD_INT 4
94329: MINUS
94330: PUSH
94331: LD_INT 2
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: LIST
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: ST_TO_ADDR
// end ; 3 :
94346: GO 94768
94348: LD_INT 3
94350: DOUBLE
94351: EQUAL
94352: IFTRUE 94356
94354: GO 94489
94356: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
94357: LD_ADDR_VAR 0 5
94361: PUSH
94362: LD_VAR 0 1
94366: PUSH
94367: LD_INT 3
94369: PLUS
94370: PUSH
94371: LD_VAR 0 2
94375: PUSH
94376: LD_INT 4
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: LIST
94383: PUSH
94384: LD_VAR 0 1
94388: PUSH
94389: LD_INT 4
94391: PLUS
94392: PUSH
94393: LD_VAR 0 2
94397: PUSH
94398: LD_INT 4
94400: PLUS
94401: PUSH
94402: LD_INT 5
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: LIST
94409: PUSH
94410: LD_VAR 0 1
94414: PUSH
94415: LD_INT 4
94417: MINUS
94418: PUSH
94419: LD_VAR 0 2
94423: PUSH
94424: LD_INT 1
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: LIST
94431: PUSH
94432: LD_VAR 0 1
94436: PUSH
94437: LD_VAR 0 2
94441: PUSH
94442: LD_INT 4
94444: MINUS
94445: PUSH
94446: LD_INT 3
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: LIST
94453: PUSH
94454: LD_VAR 0 1
94458: PUSH
94459: LD_INT 3
94461: MINUS
94462: PUSH
94463: LD_VAR 0 2
94467: PUSH
94468: LD_INT 3
94470: MINUS
94471: PUSH
94472: LD_INT 2
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: LIST
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: ST_TO_ADDR
// end ; 4 :
94487: GO 94768
94489: LD_INT 4
94491: DOUBLE
94492: EQUAL
94493: IFTRUE 94497
94495: GO 94630
94497: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
94498: LD_ADDR_VAR 0 5
94502: PUSH
94503: LD_VAR 0 1
94507: PUSH
94508: LD_VAR 0 2
94512: PUSH
94513: LD_INT 4
94515: PLUS
94516: PUSH
94517: LD_INT 0
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: LIST
94524: PUSH
94525: LD_VAR 0 1
94529: PUSH
94530: LD_INT 3
94532: PLUS
94533: PUSH
94534: LD_VAR 0 2
94538: PUSH
94539: LD_INT 3
94541: PLUS
94542: PUSH
94543: LD_INT 5
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: LIST
94550: PUSH
94551: LD_VAR 0 1
94555: PUSH
94556: LD_INT 4
94558: PLUS
94559: PUSH
94560: LD_VAR 0 2
94564: PUSH
94565: LD_INT 4
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: LIST
94572: PUSH
94573: LD_VAR 0 1
94577: PUSH
94578: LD_VAR 0 2
94582: PUSH
94583: LD_INT 3
94585: MINUS
94586: PUSH
94587: LD_INT 3
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: LIST
94594: PUSH
94595: LD_VAR 0 1
94599: PUSH
94600: LD_INT 4
94602: MINUS
94603: PUSH
94604: LD_VAR 0 2
94608: PUSH
94609: LD_INT 4
94611: MINUS
94612: PUSH
94613: LD_INT 2
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: LIST
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: ST_TO_ADDR
// end ; 5 :
94628: GO 94768
94630: LD_INT 5
94632: DOUBLE
94633: EQUAL
94634: IFTRUE 94638
94636: GO 94767
94638: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
94639: LD_ADDR_VAR 0 5
94643: PUSH
94644: LD_VAR 0 1
94648: PUSH
94649: LD_INT 4
94651: MINUS
94652: PUSH
94653: LD_VAR 0 2
94657: PUSH
94658: LD_INT 1
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: LIST
94665: PUSH
94666: LD_VAR 0 1
94670: PUSH
94671: LD_VAR 0 2
94675: PUSH
94676: LD_INT 4
94678: MINUS
94679: PUSH
94680: LD_INT 3
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: LIST
94687: PUSH
94688: LD_VAR 0 1
94692: PUSH
94693: LD_INT 4
94695: PLUS
94696: PUSH
94697: LD_VAR 0 2
94701: PUSH
94702: LD_INT 4
94704: PLUS
94705: PUSH
94706: LD_INT 5
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: LIST
94713: PUSH
94714: LD_VAR 0 1
94718: PUSH
94719: LD_INT 3
94721: PLUS
94722: PUSH
94723: LD_VAR 0 2
94727: PUSH
94728: LD_INT 4
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: LIST
94735: PUSH
94736: LD_VAR 0 1
94740: PUSH
94741: LD_VAR 0 2
94745: PUSH
94746: LD_INT 3
94748: PLUS
94749: PUSH
94750: LD_INT 0
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: LIST
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: ST_TO_ADDR
// end ; end ;
94765: GO 94768
94767: POP
// result := list ;
94768: LD_ADDR_VAR 0 4
94772: PUSH
94773: LD_VAR 0 5
94777: ST_TO_ADDR
// end ;
94778: LD_VAR 0 4
94782: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
94783: LD_INT 0
94785: PPUSH
94786: PPUSH
94787: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
94788: LD_VAR 0 1
94792: NOT
94793: PUSH
94794: LD_VAR 0 2
94798: PUSH
94799: LD_INT 1
94801: PUSH
94802: LD_INT 2
94804: PUSH
94805: LD_INT 3
94807: PUSH
94808: LD_INT 4
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: IN
94817: NOT
94818: OR
94819: IFFALSE 94823
// exit ;
94821: GO 94915
// tmp := [ ] ;
94823: LD_ADDR_VAR 0 5
94827: PUSH
94828: EMPTY
94829: ST_TO_ADDR
// for i in units do
94830: LD_ADDR_VAR 0 4
94834: PUSH
94835: LD_VAR 0 1
94839: PUSH
94840: FOR_IN
94841: IFFALSE 94884
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
94843: LD_ADDR_VAR 0 5
94847: PUSH
94848: LD_VAR 0 5
94852: PPUSH
94853: LD_VAR 0 5
94857: PUSH
94858: LD_INT 1
94860: PLUS
94861: PPUSH
94862: LD_VAR 0 4
94866: PPUSH
94867: LD_VAR 0 2
94871: PPUSH
94872: CALL_OW 259
94876: PPUSH
94877: CALL_OW 2
94881: ST_TO_ADDR
94882: GO 94840
94884: POP
94885: POP
// if not tmp then
94886: LD_VAR 0 5
94890: NOT
94891: IFFALSE 94895
// exit ;
94893: GO 94915
// result := SortListByListDesc ( units , tmp ) ;
94895: LD_ADDR_VAR 0 3
94899: PUSH
94900: LD_VAR 0 1
94904: PPUSH
94905: LD_VAR 0 5
94909: PPUSH
94910: CALL_OW 77
94914: ST_TO_ADDR
// end ;
94915: LD_VAR 0 3
94919: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
94920: LD_INT 0
94922: PPUSH
94923: PPUSH
94924: PPUSH
// x := GetX ( building ) ;
94925: LD_ADDR_VAR 0 4
94929: PUSH
94930: LD_VAR 0 2
94934: PPUSH
94935: CALL_OW 250
94939: ST_TO_ADDR
// y := GetY ( building ) ;
94940: LD_ADDR_VAR 0 5
94944: PUSH
94945: LD_VAR 0 2
94949: PPUSH
94950: CALL_OW 251
94954: ST_TO_ADDR
// if GetTaskList ( unit ) then
94955: LD_VAR 0 1
94959: PPUSH
94960: CALL_OW 437
94964: IFFALSE 95059
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
94966: LD_STRING e
94968: PUSH
94969: LD_VAR 0 1
94973: PPUSH
94974: CALL_OW 437
94978: PUSH
94979: LD_INT 1
94981: ARRAY
94982: PUSH
94983: LD_INT 1
94985: ARRAY
94986: EQUAL
94987: PUSH
94988: LD_VAR 0 4
94992: PUSH
94993: LD_VAR 0 1
94997: PPUSH
94998: CALL_OW 437
95002: PUSH
95003: LD_INT 1
95005: ARRAY
95006: PUSH
95007: LD_INT 2
95009: ARRAY
95010: EQUAL
95011: AND
95012: PUSH
95013: LD_VAR 0 5
95017: PUSH
95018: LD_VAR 0 1
95022: PPUSH
95023: CALL_OW 437
95027: PUSH
95028: LD_INT 1
95030: ARRAY
95031: PUSH
95032: LD_INT 3
95034: ARRAY
95035: EQUAL
95036: AND
95037: IFFALSE 95049
// result := true else
95039: LD_ADDR_VAR 0 3
95043: PUSH
95044: LD_INT 1
95046: ST_TO_ADDR
95047: GO 95057
// result := false ;
95049: LD_ADDR_VAR 0 3
95053: PUSH
95054: LD_INT 0
95056: ST_TO_ADDR
// end else
95057: GO 95067
// result := false ;
95059: LD_ADDR_VAR 0 3
95063: PUSH
95064: LD_INT 0
95066: ST_TO_ADDR
// end ;
95067: LD_VAR 0 3
95071: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
95072: LD_INT 0
95074: PPUSH
95075: PPUSH
95076: PPUSH
95077: PPUSH
// if not unit or not area then
95078: LD_VAR 0 1
95082: NOT
95083: PUSH
95084: LD_VAR 0 2
95088: NOT
95089: OR
95090: IFFALSE 95094
// exit ;
95092: GO 95259
// tmp := AreaToList ( area , i ) ;
95094: LD_ADDR_VAR 0 6
95098: PUSH
95099: LD_VAR 0 2
95103: PPUSH
95104: LD_VAR 0 5
95108: PPUSH
95109: CALL_OW 517
95113: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
95114: LD_ADDR_VAR 0 5
95118: PUSH
95119: DOUBLE
95120: LD_INT 1
95122: DEC
95123: ST_TO_ADDR
95124: LD_VAR 0 6
95128: PUSH
95129: LD_INT 1
95131: ARRAY
95132: PUSH
95133: FOR_TO
95134: IFFALSE 95249
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
95136: LD_ADDR_VAR 0 7
95140: PUSH
95141: LD_VAR 0 6
95145: PUSH
95146: LD_INT 1
95148: ARRAY
95149: PUSH
95150: LD_VAR 0 5
95154: ARRAY
95155: PUSH
95156: LD_VAR 0 6
95160: PUSH
95161: LD_INT 2
95163: ARRAY
95164: PUSH
95165: LD_VAR 0 5
95169: ARRAY
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
95175: LD_VAR 0 7
95179: PUSH
95180: LD_INT 1
95182: ARRAY
95183: PPUSH
95184: LD_VAR 0 7
95188: PUSH
95189: LD_INT 2
95191: ARRAY
95192: PPUSH
95193: CALL_OW 428
95197: PUSH
95198: LD_INT 0
95200: EQUAL
95201: IFFALSE 95247
// begin result := true ;
95203: LD_ADDR_VAR 0 4
95207: PUSH
95208: LD_INT 1
95210: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
95211: LD_VAR 0 1
95215: PPUSH
95216: LD_VAR 0 7
95220: PUSH
95221: LD_INT 1
95223: ARRAY
95224: PPUSH
95225: LD_VAR 0 7
95229: PUSH
95230: LD_INT 2
95232: ARRAY
95233: PPUSH
95234: LD_VAR 0 3
95238: PPUSH
95239: CALL_OW 48
// exit ;
95243: POP
95244: POP
95245: GO 95259
// end ; end ;
95247: GO 95133
95249: POP
95250: POP
// result := false ;
95251: LD_ADDR_VAR 0 4
95255: PUSH
95256: LD_INT 0
95258: ST_TO_ADDR
// end ;
95259: LD_VAR 0 4
95263: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
95264: LD_INT 0
95266: PPUSH
95267: PPUSH
95268: PPUSH
// if not side or side > 8 then
95269: LD_VAR 0 1
95273: NOT
95274: PUSH
95275: LD_VAR 0 1
95279: PUSH
95280: LD_INT 8
95282: GREATER
95283: OR
95284: IFFALSE 95288
// exit ;
95286: GO 95475
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
95288: LD_ADDR_VAR 0 4
95292: PUSH
95293: LD_INT 22
95295: PUSH
95296: LD_VAR 0 1
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 21
95307: PUSH
95308: LD_INT 3
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: PPUSH
95319: CALL_OW 69
95323: ST_TO_ADDR
// if not tmp then
95324: LD_VAR 0 4
95328: NOT
95329: IFFALSE 95333
// exit ;
95331: GO 95475
// enable_addtolog := true ;
95333: LD_ADDR_OWVAR 81
95337: PUSH
95338: LD_INT 1
95340: ST_TO_ADDR
// AddToLog ( [ ) ;
95341: LD_STRING [
95343: PPUSH
95344: CALL_OW 561
// for i in tmp do
95348: LD_ADDR_VAR 0 3
95352: PUSH
95353: LD_VAR 0 4
95357: PUSH
95358: FOR_IN
95359: IFFALSE 95466
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
95361: LD_STRING [
95363: PUSH
95364: LD_VAR 0 3
95368: PPUSH
95369: CALL_OW 266
95373: STR
95374: PUSH
95375: LD_STRING , 
95377: STR
95378: PUSH
95379: LD_VAR 0 3
95383: PPUSH
95384: CALL_OW 250
95388: STR
95389: PUSH
95390: LD_STRING , 
95392: STR
95393: PUSH
95394: LD_VAR 0 3
95398: PPUSH
95399: CALL_OW 251
95403: STR
95404: PUSH
95405: LD_STRING , 
95407: STR
95408: PUSH
95409: LD_VAR 0 3
95413: PPUSH
95414: CALL_OW 254
95418: STR
95419: PUSH
95420: LD_STRING , 
95422: STR
95423: PUSH
95424: LD_VAR 0 3
95428: PPUSH
95429: LD_INT 1
95431: PPUSH
95432: CALL_OW 268
95436: STR
95437: PUSH
95438: LD_STRING , 
95440: STR
95441: PUSH
95442: LD_VAR 0 3
95446: PPUSH
95447: LD_INT 2
95449: PPUSH
95450: CALL_OW 268
95454: STR
95455: PUSH
95456: LD_STRING ],
95458: STR
95459: PPUSH
95460: CALL_OW 561
// end ;
95464: GO 95358
95466: POP
95467: POP
// AddToLog ( ]; ) ;
95468: LD_STRING ];
95470: PPUSH
95471: CALL_OW 561
// end ;
95475: LD_VAR 0 2
95479: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
95480: LD_INT 0
95482: PPUSH
95483: PPUSH
95484: PPUSH
95485: PPUSH
95486: PPUSH
// if not area or not rate or not max then
95487: LD_VAR 0 1
95491: NOT
95492: PUSH
95493: LD_VAR 0 2
95497: NOT
95498: OR
95499: PUSH
95500: LD_VAR 0 4
95504: NOT
95505: OR
95506: IFFALSE 95510
// exit ;
95508: GO 95702
// while 1 do
95510: LD_INT 1
95512: IFFALSE 95702
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
95514: LD_ADDR_VAR 0 9
95518: PUSH
95519: LD_VAR 0 1
95523: PPUSH
95524: LD_INT 1
95526: PPUSH
95527: CALL_OW 287
95531: PUSH
95532: LD_INT 10
95534: MUL
95535: ST_TO_ADDR
// r := rate / 10 ;
95536: LD_ADDR_VAR 0 7
95540: PUSH
95541: LD_VAR 0 2
95545: PUSH
95546: LD_INT 10
95548: DIVREAL
95549: ST_TO_ADDR
// time := 1 1$00 ;
95550: LD_ADDR_VAR 0 8
95554: PUSH
95555: LD_INT 2100
95557: ST_TO_ADDR
// if amount < min then
95558: LD_VAR 0 9
95562: PUSH
95563: LD_VAR 0 3
95567: LESS
95568: IFFALSE 95586
// r := r * 2 else
95570: LD_ADDR_VAR 0 7
95574: PUSH
95575: LD_VAR 0 7
95579: PUSH
95580: LD_INT 2
95582: MUL
95583: ST_TO_ADDR
95584: GO 95612
// if amount > max then
95586: LD_VAR 0 9
95590: PUSH
95591: LD_VAR 0 4
95595: GREATER
95596: IFFALSE 95612
// r := r / 2 ;
95598: LD_ADDR_VAR 0 7
95602: PUSH
95603: LD_VAR 0 7
95607: PUSH
95608: LD_INT 2
95610: DIVREAL
95611: ST_TO_ADDR
// time := time / r ;
95612: LD_ADDR_VAR 0 8
95616: PUSH
95617: LD_VAR 0 8
95621: PUSH
95622: LD_VAR 0 7
95626: DIVREAL
95627: ST_TO_ADDR
// if time < 0 then
95628: LD_VAR 0 8
95632: PUSH
95633: LD_INT 0
95635: LESS
95636: IFFALSE 95653
// time := time * - 1 ;
95638: LD_ADDR_VAR 0 8
95642: PUSH
95643: LD_VAR 0 8
95647: PUSH
95648: LD_INT 1
95650: NEG
95651: MUL
95652: ST_TO_ADDR
// wait ( time ) ;
95653: LD_VAR 0 8
95657: PPUSH
95658: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
95662: LD_INT 35
95664: PPUSH
95665: LD_INT 875
95667: PPUSH
95668: CALL_OW 12
95672: PPUSH
95673: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
95677: LD_INT 1
95679: PPUSH
95680: LD_INT 5
95682: PPUSH
95683: CALL_OW 12
95687: PPUSH
95688: LD_VAR 0 1
95692: PPUSH
95693: LD_INT 1
95695: PPUSH
95696: CALL_OW 55
// end ;
95700: GO 95510
// end ;
95702: LD_VAR 0 5
95706: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
95707: LD_INT 0
95709: PPUSH
95710: PPUSH
95711: PPUSH
95712: PPUSH
95713: PPUSH
95714: PPUSH
95715: PPUSH
95716: PPUSH
// if not turrets or not factories then
95717: LD_VAR 0 1
95721: NOT
95722: PUSH
95723: LD_VAR 0 2
95727: NOT
95728: OR
95729: IFFALSE 95733
// exit ;
95731: GO 96040
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
95733: LD_ADDR_VAR 0 10
95737: PUSH
95738: LD_INT 5
95740: PUSH
95741: LD_INT 6
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 2
95750: PUSH
95751: LD_INT 4
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: LD_INT 3
95760: PUSH
95761: LD_INT 5
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: LIST
95772: PUSH
95773: LD_INT 24
95775: PUSH
95776: LD_INT 25
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PUSH
95783: LD_INT 23
95785: PUSH
95786: LD_INT 27
95788: PUSH
95789: EMPTY
95790: LIST
95791: LIST
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 42
95799: PUSH
95800: LD_INT 43
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 44
95809: PUSH
95810: LD_INT 46
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 45
95819: PUSH
95820: LD_INT 47
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: LIST
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: LIST
95836: ST_TO_ADDR
// result := [ ] ;
95837: LD_ADDR_VAR 0 3
95841: PUSH
95842: EMPTY
95843: ST_TO_ADDR
// for i in turrets do
95844: LD_ADDR_VAR 0 4
95848: PUSH
95849: LD_VAR 0 1
95853: PUSH
95854: FOR_IN
95855: IFFALSE 96038
// begin nat := GetNation ( i ) ;
95857: LD_ADDR_VAR 0 7
95861: PUSH
95862: LD_VAR 0 4
95866: PPUSH
95867: CALL_OW 248
95871: ST_TO_ADDR
// weapon := 0 ;
95872: LD_ADDR_VAR 0 8
95876: PUSH
95877: LD_INT 0
95879: ST_TO_ADDR
// if not nat then
95880: LD_VAR 0 7
95884: NOT
95885: IFFALSE 95889
// continue ;
95887: GO 95854
// for j in list [ nat ] do
95889: LD_ADDR_VAR 0 5
95893: PUSH
95894: LD_VAR 0 10
95898: PUSH
95899: LD_VAR 0 7
95903: ARRAY
95904: PUSH
95905: FOR_IN
95906: IFFALSE 95947
// if GetBWeapon ( i ) = j [ 1 ] then
95908: LD_VAR 0 4
95912: PPUSH
95913: CALL_OW 269
95917: PUSH
95918: LD_VAR 0 5
95922: PUSH
95923: LD_INT 1
95925: ARRAY
95926: EQUAL
95927: IFFALSE 95945
// begin weapon := j [ 2 ] ;
95929: LD_ADDR_VAR 0 8
95933: PUSH
95934: LD_VAR 0 5
95938: PUSH
95939: LD_INT 2
95941: ARRAY
95942: ST_TO_ADDR
// break ;
95943: GO 95947
// end ;
95945: GO 95905
95947: POP
95948: POP
// if not weapon then
95949: LD_VAR 0 8
95953: NOT
95954: IFFALSE 95958
// continue ;
95956: GO 95854
// for k in factories do
95958: LD_ADDR_VAR 0 6
95962: PUSH
95963: LD_VAR 0 2
95967: PUSH
95968: FOR_IN
95969: IFFALSE 96034
// begin weapons := AvailableWeaponList ( k ) ;
95971: LD_ADDR_VAR 0 9
95975: PUSH
95976: LD_VAR 0 6
95980: PPUSH
95981: CALL_OW 478
95985: ST_TO_ADDR
// if not weapons then
95986: LD_VAR 0 9
95990: NOT
95991: IFFALSE 95995
// continue ;
95993: GO 95968
// if weapon in weapons then
95995: LD_VAR 0 8
95999: PUSH
96000: LD_VAR 0 9
96004: IN
96005: IFFALSE 96032
// begin result := [ i , weapon ] ;
96007: LD_ADDR_VAR 0 3
96011: PUSH
96012: LD_VAR 0 4
96016: PUSH
96017: LD_VAR 0 8
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: ST_TO_ADDR
// exit ;
96026: POP
96027: POP
96028: POP
96029: POP
96030: GO 96040
// end ; end ;
96032: GO 95968
96034: POP
96035: POP
// end ;
96036: GO 95854
96038: POP
96039: POP
// end ;
96040: LD_VAR 0 3
96044: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
96045: LD_INT 0
96047: PPUSH
// if not side or side > 8 then
96048: LD_VAR 0 3
96052: NOT
96053: PUSH
96054: LD_VAR 0 3
96058: PUSH
96059: LD_INT 8
96061: GREATER
96062: OR
96063: IFFALSE 96067
// exit ;
96065: GO 96126
// if not range then
96067: LD_VAR 0 4
96071: NOT
96072: IFFALSE 96083
// range := - 12 ;
96074: LD_ADDR_VAR 0 4
96078: PUSH
96079: LD_INT 12
96081: NEG
96082: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
96083: LD_VAR 0 1
96087: PPUSH
96088: LD_VAR 0 2
96092: PPUSH
96093: LD_VAR 0 3
96097: PPUSH
96098: LD_VAR 0 4
96102: PPUSH
96103: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
96107: LD_VAR 0 1
96111: PPUSH
96112: LD_VAR 0 2
96116: PPUSH
96117: LD_VAR 0 3
96121: PPUSH
96122: CALL_OW 331
// end ;
96126: LD_VAR 0 5
96130: RET
// export function Video ( mode ) ; begin
96131: LD_INT 0
96133: PPUSH
// ingame_video = mode ;
96134: LD_ADDR_OWVAR 52
96138: PUSH
96139: LD_VAR 0 1
96143: ST_TO_ADDR
// interface_hidden = mode ;
96144: LD_ADDR_OWVAR 54
96148: PUSH
96149: LD_VAR 0 1
96153: ST_TO_ADDR
// end ;
96154: LD_VAR 0 2
96158: RET
// export function Join ( array , element ) ; begin
96159: LD_INT 0
96161: PPUSH
// result := array ^ element ;
96162: LD_ADDR_VAR 0 3
96166: PUSH
96167: LD_VAR 0 1
96171: PUSH
96172: LD_VAR 0 2
96176: ADD
96177: ST_TO_ADDR
// end ;
96178: LD_VAR 0 3
96182: RET
// export function JoinUnion ( array , element ) ; begin
96183: LD_INT 0
96185: PPUSH
// result := array union element ;
96186: LD_ADDR_VAR 0 3
96190: PUSH
96191: LD_VAR 0 1
96195: PUSH
96196: LD_VAR 0 2
96200: UNION
96201: ST_TO_ADDR
// end ;
96202: LD_VAR 0 3
96206: RET
// export function GetBehemoths ( side ) ; begin
96207: LD_INT 0
96209: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
96210: LD_ADDR_VAR 0 2
96214: PUSH
96215: LD_INT 22
96217: PUSH
96218: LD_VAR 0 1
96222: PUSH
96223: EMPTY
96224: LIST
96225: LIST
96226: PUSH
96227: LD_INT 31
96229: PUSH
96230: LD_INT 25
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PPUSH
96241: CALL_OW 69
96245: ST_TO_ADDR
// end ;
96246: LD_VAR 0 2
96250: RET
