// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 54 0 0
// InitMacro ;
   8: CALL 14734 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 25
// FogOff ( 1 ) ;
  18: LD_INT 1
  20: PPUSH
  21: CALL_OW 344
// PrepareAlliance ;
  25: CALL 4262 0 0
// PrepareRussian ;
  29: CALL 3900 0 0
// PrepareLegion ;
  33: CALL 2668 0 0
// PreparePowell ;
  37: CALL 1451 0 0
// PrepareAmerican ;
  41: CALL 995 0 0
// Action ;
  45: CALL 5177 0 0
// MC_Start ( ) ;
  49: CALL 15881 0 0
// end ;
  53: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode ; export function InitVariables ; begin
  54: LD_INT 0
  56: PPUSH
// debug := true ;
  57: LD_ADDR_EXP 1
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// missionStart := false ;
  65: LD_ADDR_EXP 13
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// missionTime := 0 0$00 ;
  73: LD_ADDR_EXP 14
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// missionStage := 1 ;
  81: LD_ADDR_EXP 15
  85: PUSH
  86: LD_INT 1
  88: ST_TO_ADDR
// activeAttacks := false ;
  89: LD_ADDR_EXP 16
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// powellAnger := 0 ;
  97: LD_ADDR_EXP 17
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// powellAllowRetreat := true ;
 105: LD_ADDR_EXP 19
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// powellCenterCameraMode := false ;
 113: LD_ADDR_EXP 20
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 121: LD_ADDR_EXP 18
 125: PUSH
 126: EMPTY
 127: PUSH
 128: EMPTY
 129: PUSH
 130: EMPTY
 131: LIST
 132: LIST
 133: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 134: LD_ADDR_EXP 2
 138: PUSH
 139: LD_STRING 14_KappaStatus_1
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: CALL_OW 30
 149: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 150: LD_ADDR_EXP 3
 154: PUSH
 155: LD_STRING 06_KurtStatus_1
 157: PPUSH
 158: LD_INT 0
 160: PPUSH
 161: CALL_OW 30
 165: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 166: LD_ADDR_EXP 4
 170: PUSH
 171: LD_STRING 14_JMMVeh_1
 173: PPUSH
 174: LD_INT 0
 176: PPUSH
 177: CALL_OW 30
 181: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 182: LD_ADDR_EXP 5
 186: PUSH
 187: LD_STRING 14_JMMGirlVeh_1
 189: PPUSH
 190: LD_INT 0
 192: PPUSH
 193: CALL_OW 30
 197: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 198: LD_ADDR_EXP 7
 202: PUSH
 203: LD_STRING 14_JMMGirl_1
 205: PPUSH
 206: LD_INT 0
 208: PPUSH
 209: CALL_OW 30
 213: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 214: LD_ADDR_EXP 6
 218: PUSH
 219: LD_STRING 14_JMMGirlStatus_1
 221: PPUSH
 222: LD_INT 0
 224: PPUSH
 225: CALL_OW 30
 229: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 230: LD_ADDR_EXP 8
 234: PUSH
 235: LD_STRING 10_KhatamStatus_1
 237: PPUSH
 238: LD_INT 0
 240: PPUSH
 241: CALL_OW 30
 245: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 246: LD_ADDR_EXP 9
 250: PUSH
 251: LD_STRING 13_BurlakStatus_1
 253: PPUSH
 254: LD_INT 0
 256: PPUSH
 257: CALL_OW 30
 261: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 262: LD_ADDR_EXP 10
 266: PUSH
 267: LD_STRING 13_StevensStatus_1
 269: PPUSH
 270: LD_INT 0
 272: PPUSH
 273: CALL_OW 30
 277: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 278: LD_ADDR_EXP 11
 282: PUSH
 283: LD_STRING 14_FastEnd_1
 285: PPUSH
 286: LD_INT 0
 288: PPUSH
 289: CALL_OW 30
 293: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 294: LD_ADDR_EXP 12
 298: PUSH
 299: LD_STRING 12_MainDepositFake_1
 301: PPUSH
 302: LD_INT 0
 304: PPUSH
 305: CALL_OW 30
 309: ST_TO_ADDR
// end ;
 310: LD_VAR 0 1
 314: RET
// export function CustomInitMacro ( ) ; begin
 315: LD_INT 0
 317: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 318: LD_ADDR_EXP 95
 322: PUSH
 323: LD_INT 2
 325: PUSH
 326: LD_INT 3
 328: PUSH
 329: LD_INT 6
 331: PUSH
 332: LD_INT 11
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 341: LD_ADDR_EXP 96
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 5
 354: PUSH
 355: LD_INT 10
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: LIST
 363: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: LD_INT 12
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: PPUSH
 381: CALL 37414 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 385: LD_INT 2
 387: PPUSH
 388: LD_INT 10
 390: PUSH
 391: LD_INT 11
 393: PUSH
 394: LD_INT 12
 396: PUSH
 397: LD_INT 14
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: PPUSH
 406: CALL 37414 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 410: LD_INT 3
 412: PPUSH
 413: LD_INT 10
 415: PUSH
 416: LD_INT 11
 418: PUSH
 419: LD_INT 13
 421: PUSH
 422: LD_INT 15
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PPUSH
 431: CALL 37414 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 435: LD_ADDR_EXP 100
 439: PUSH
 440: LD_EXP 100
 444: PPUSH
 445: LD_INT 3
 447: PPUSH
 448: LD_INT 22
 450: PUSH
 451: LD_INT 8
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: PUSH
 458: LD_INT 25
 460: PUSH
 461: LD_INT 15
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: PPUSH
 472: CALL_OW 69
 476: PPUSH
 477: CALL_OW 1
 481: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_remote , ar_gun ] , [ ar_medium_trike , engine_solar , control_remote , ar_rocket_launcher ] ] ) ;
 482: LD_INT 3
 484: PPUSH
 485: LD_INT 13
 487: PUSH
 488: LD_INT 2
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 31
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 13
 505: PUSH
 506: LD_INT 2
 508: PUSH
 509: LD_INT 1
 511: PUSH
 512: LD_INT 31
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: LD_INT 13
 523: PUSH
 524: LD_INT 2
 526: PUSH
 527: LD_INT 2
 529: PUSH
 530: LD_INT 27
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: PUSH
 539: LD_INT 13
 541: PUSH
 542: LD_INT 2
 544: PUSH
 545: LD_INT 2
 547: PUSH
 548: LD_INT 28
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 36677 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 567: LD_INT 4
 569: PPUSH
 570: LD_INT 10
 572: PUSH
 573: LD_INT 12
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: PPUSH
 580: CALL 37414 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 584: LD_INT 4
 586: PPUSH
 587: LD_INT 10
 589: PUSH
 590: EMPTY
 591: LIST
 592: PPUSH
 593: CALL 37507 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 62 , 78 , 4 ] ] ) ;
 597: LD_INT 4
 599: PPUSH
 600: LD_INT 26
 602: PUSH
 603: LD_INT 74
 605: PUSH
 606: LD_INT 107
 608: PUSH
 609: LD_INT 0
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: PUSH
 618: LD_INT 32
 620: PUSH
 621: LD_INT 77
 623: PUSH
 624: LD_INT 101
 626: PUSH
 627: LD_INT 4
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: PUSH
 636: LD_INT 32
 638: PUSH
 639: LD_INT 69
 641: PUSH
 642: LD_INT 86
 644: PUSH
 645: LD_INT 4
 647: PUSH
 648: EMPTY
 649: LIST
 650: LIST
 651: LIST
 652: LIST
 653: PUSH
 654: LD_INT 27
 656: PUSH
 657: LD_INT 77
 659: PUSH
 660: LD_INT 110
 662: PUSH
 663: LD_INT 3
 665: PUSH
 666: EMPTY
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 42
 677: PUSH
 678: LD_INT 79
 680: PUSH
 681: LD_INT 5
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: LIST
 688: LIST
 689: PUSH
 690: LD_INT 29
 692: PUSH
 693: LD_INT 86
 695: PUSH
 696: LD_INT 105
 698: PUSH
 699: LD_INT 2
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: LIST
 706: LIST
 707: PUSH
 708: LD_INT 30
 710: PUSH
 711: LD_INT 40
 713: PUSH
 714: LD_INT 75
 716: PUSH
 717: LD_INT 1
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_INT 32
 728: PUSH
 729: LD_INT 80
 731: PUSH
 732: LD_INT 106
 734: PUSH
 735: LD_INT 4
 737: PUSH
 738: EMPTY
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 32
 746: PUSH
 747: LD_INT 62
 749: PUSH
 750: LD_INT 78
 752: PUSH
 753: LD_INT 4
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: LIST
 761: PUSH
 762: EMPTY
 763: LIST
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: PPUSH
 773: CALL 36569 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
 777: LD_INT 4
 779: PPUSH
 780: LD_INT 5
 782: PUSH
 783: LD_INT 6
 785: PUSH
 786: LD_INT 7
 788: PUSH
 789: LD_INT 9
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL 37825 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
 802: LD_INT 4
 804: PPUSH
 805: LD_INT 40
 807: PUSH
 808: LD_INT 75
 810: PUSH
 811: LD_INT 1
 813: PUSH
 814: EMPTY
 815: LIST
 816: LIST
 817: LIST
 818: PUSH
 819: LD_INT 86
 821: PUSH
 822: LD_INT 105
 824: PUSH
 825: LD_INT 0
 827: PUSH
 828: EMPTY
 829: LIST
 830: LIST
 831: LIST
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: PPUSH
 837: CALL 37059 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
 841: LD_INT 4
 843: PPUSH
 844: LD_INT 2
 846: PPUSH
 847: CALL 37287 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
 851: LD_INT 4
 853: PPUSH
 854: LD_INT 0
 856: PPUSH
 857: CALL 37287 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
 861: LD_INT 4
 863: PPUSH
 864: LD_INT 54
 866: PPUSH
 867: LD_INT 85
 869: PPUSH
 870: LD_INT 2
 872: PPUSH
 873: LD_INT 19
 875: PUSH
 876: LD_INT 16
 878: PUSH
 879: LD_INT 17
 881: PUSH
 882: LD_INT 18
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: LIST
 889: LIST
 890: PPUSH
 891: CALL 37619 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
 895: LD_INT 4
 897: PPUSH
 898: LD_INT 3
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 5
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 4
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 6
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 4
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 7
 945: PUSH
 946: EMPTY
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 4
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 6
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: LIST
 968: LIST
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PPUSH
 976: CALL 36677 0 2
// MC_SetTame ( 4 , powellApe ) ;
 980: LD_INT 4
 982: PPUSH
 983: LD_INT 14
 985: PPUSH
 986: CALL 37238 0 2
// end ; end_of_file
 990: LD_VAR 0 1
 994: RET
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
 995: LD_INT 0
 997: PPUSH
// uc_side := 1 ;
 998: LD_ADDR_OWVAR 20
1002: PUSH
1003: LD_INT 1
1005: ST_TO_ADDR
// uc_nation := 1 ;
1006: LD_ADDR_OWVAR 21
1010: PUSH
1011: LD_INT 1
1013: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1014: LD_ADDR_EXP 21
1018: PUSH
1019: LD_STRING JMM
1021: PPUSH
1022: LD_EXP 1
1026: NOT
1027: PPUSH
1028: LD_STRING 14_
1030: PPUSH
1031: CALL 42449 0 3
1035: ST_TO_ADDR
// if not JMMVeh then
1036: LD_EXP 4
1040: NOT
1041: IFFALSE 1064
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1043: LD_INT 3
1045: PPUSH
1046: LD_INT 3
1048: PPUSH
1049: LD_INT 1
1051: PPUSH
1052: LD_INT 5
1054: PPUSH
1055: LD_INT 100
1057: PPUSH
1058: CALL 49082 0 5
1062: GO 1123
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1064: LD_EXP 4
1068: PUSH
1069: LD_INT 1
1071: ARRAY
1072: PUSH
1073: LD_INT 1
1075: ARRAY
1076: PPUSH
1077: LD_EXP 4
1081: PUSH
1082: LD_INT 2
1084: ARRAY
1085: PUSH
1086: LD_INT 1
1088: ARRAY
1089: PPUSH
1090: LD_EXP 4
1094: PUSH
1095: LD_INT 3
1097: ARRAY
1098: PUSH
1099: LD_INT 1
1101: ARRAY
1102: PPUSH
1103: LD_EXP 4
1107: PUSH
1108: LD_INT 4
1110: ARRAY
1111: PUSH
1112: LD_INT 1
1114: ARRAY
1115: PPUSH
1116: LD_INT 30
1118: PPUSH
1119: CALL 49082 0 5
// JMMNewVeh := CreateVehicle ;
1123: LD_ADDR_EXP 37
1127: PUSH
1128: CALL_OW 45
1132: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1133: LD_EXP 37
1137: PPUSH
1138: LD_INT 4
1140: PPUSH
1141: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1145: LD_EXP 37
1149: PPUSH
1150: LD_INT 75
1152: PPUSH
1153: LD_INT 92
1155: PPUSH
1156: LD_INT 0
1158: PPUSH
1159: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1163: LD_EXP 21
1167: PPUSH
1168: LD_EXP 37
1172: PPUSH
1173: CALL_OW 52
// if JMMGirl and not KappaStatus then
1177: LD_EXP 7
1181: PUSH
1182: LD_EXP 2
1186: NOT
1187: AND
1188: IFFALSE 1446
// begin if not JMMGirlVeh then
1190: LD_EXP 5
1194: NOT
1195: IFFALSE 1218
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1197: LD_INT 3
1199: PPUSH
1200: LD_INT 3
1202: PPUSH
1203: LD_INT 1
1205: PPUSH
1206: LD_INT 9
1208: PPUSH
1209: LD_INT 100
1211: PPUSH
1212: CALL 49082 0 5
1216: GO 1277
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1218: LD_EXP 5
1222: PUSH
1223: LD_INT 1
1225: ARRAY
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: PPUSH
1231: LD_EXP 5
1235: PUSH
1236: LD_INT 2
1238: ARRAY
1239: PUSH
1240: LD_INT 1
1242: ARRAY
1243: PPUSH
1244: LD_EXP 5
1248: PUSH
1249: LD_INT 3
1251: ARRAY
1252: PUSH
1253: LD_INT 1
1255: ARRAY
1256: PPUSH
1257: LD_EXP 5
1261: PUSH
1262: LD_INT 4
1264: ARRAY
1265: PUSH
1266: LD_INT 1
1268: ARRAY
1269: PPUSH
1270: LD_INT 30
1272: PPUSH
1273: CALL 49082 0 5
// GirlNewVeh := CreateVehicle ;
1277: LD_ADDR_EXP 38
1281: PUSH
1282: CALL_OW 45
1286: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1287: LD_EXP 38
1291: PPUSH
1292: LD_INT 4
1294: PPUSH
1295: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1299: LD_EXP 38
1303: PPUSH
1304: LD_INT 82
1306: PPUSH
1307: LD_INT 96
1309: PPUSH
1310: LD_INT 0
1312: PPUSH
1313: CALL_OW 48
// if JMMGirl = 1 then
1317: LD_EXP 7
1321: PUSH
1322: LD_INT 1
1324: EQUAL
1325: IFFALSE 1360
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1327: LD_ADDR_EXP 22
1331: PUSH
1332: LD_STRING Joan
1334: PPUSH
1335: LD_INT 1
1337: PPUSH
1338: LD_STRING 14_
1340: PPUSH
1341: CALL 42449 0 3
1345: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1346: LD_EXP 22
1350: PPUSH
1351: LD_EXP 38
1355: PPUSH
1356: CALL_OW 52
// end ; if JMMGirl = 2 then
1360: LD_EXP 7
1364: PUSH
1365: LD_INT 2
1367: EQUAL
1368: IFFALSE 1403
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1370: LD_ADDR_EXP 24
1374: PUSH
1375: LD_STRING Lisa
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_STRING 14_
1383: PPUSH
1384: CALL 42449 0 3
1388: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1389: LD_EXP 24
1393: PPUSH
1394: LD_EXP 38
1398: PPUSH
1399: CALL_OW 52
// end ; if JMMGirl = 3 then
1403: LD_EXP 7
1407: PUSH
1408: LD_INT 3
1410: EQUAL
1411: IFFALSE 1446
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
1413: LD_ADDR_EXP 36
1417: PUSH
1418: LD_STRING Connie
1420: PPUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_STRING 14_
1426: PPUSH
1427: CALL 42449 0 3
1431: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
1432: LD_EXP 36
1436: PPUSH
1437: LD_EXP 38
1441: PPUSH
1442: CALL_OW 52
// end ; end ; end ; end_of_file
1446: LD_VAR 0 1
1450: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
1451: LD_INT 0
1453: PPUSH
1454: PPUSH
1455: PPUSH
1456: PPUSH
1457: PPUSH
1458: PPUSH
1459: PPUSH
1460: PPUSH
1461: PPUSH
1462: PPUSH
// uc_side := 4 ;
1463: LD_ADDR_OWVAR 20
1467: PUSH
1468: LD_INT 4
1470: ST_TO_ADDR
// uc_nation := 1 ;
1471: LD_ADDR_OWVAR 21
1475: PUSH
1476: LD_INT 1
1478: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
1479: LD_INT 387
1481: PPUSH
1482: CALL_OW 274
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 2500
1492: PPUSH
1493: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
1497: LD_INT 387
1499: PPUSH
1500: CALL_OW 274
1504: PPUSH
1505: LD_INT 2
1507: PPUSH
1508: LD_INT 400
1510: PPUSH
1511: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
1515: LD_INT 387
1517: PPUSH
1518: CALL_OW 274
1522: PPUSH
1523: LD_INT 3
1525: PPUSH
1526: LD_INT 10
1528: PPUSH
1529: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
1533: LD_ADDR_EXP 39
1537: PUSH
1538: LD_STRING Powell
1540: PPUSH
1541: CALL_OW 25
1545: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
1546: LD_EXP 39
1550: PPUSH
1551: LD_INT 57
1553: PPUSH
1554: LD_INT 94
1556: PPUSH
1557: LD_INT 0
1559: PPUSH
1560: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
1564: LD_EXP 39
1568: PPUSH
1569: LD_INT 58
1571: PPUSH
1572: LD_INT 94
1574: PPUSH
1575: CALL_OW 118
// vip := [ ] ;
1579: LD_ADDR_EXP 40
1583: PUSH
1584: EMPTY
1585: ST_TO_ADDR
// tmp := [ ] ;
1586: LD_ADDR_VAR 0 6
1590: PUSH
1591: EMPTY
1592: ST_TO_ADDR
// if JMMGirl <> 2 then
1593: LD_EXP 7
1597: PUSH
1598: LD_INT 2
1600: NONEQUAL
1601: IFFALSE 1625
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
1603: LD_ADDR_EXP 24
1607: PUSH
1608: LD_STRING Lisa
1610: PPUSH
1611: LD_EXP 1
1615: NOT
1616: PPUSH
1617: LD_STRING 13s_
1619: PPUSH
1620: CALL 42449 0 3
1624: ST_TO_ADDR
// if Lisa then
1625: LD_EXP 24
1629: IFFALSE 1647
// tmp := tmp ^ Lisa ;
1631: LD_ADDR_VAR 0 6
1635: PUSH
1636: LD_VAR 0 6
1640: PUSH
1641: LD_EXP 24
1645: ADD
1646: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
1647: LD_ADDR_EXP 25
1651: PUSH
1652: LD_STRING Donaldson
1654: PPUSH
1655: LD_EXP 1
1659: NOT
1660: PPUSH
1661: LD_STRING 13s_
1663: PPUSH
1664: CALL 42449 0 3
1668: ST_TO_ADDR
// if Donaldson then
1669: LD_EXP 25
1673: IFFALSE 1691
// tmp := tmp ^ Donaldson ;
1675: LD_ADDR_VAR 0 6
1679: PUSH
1680: LD_VAR 0 6
1684: PUSH
1685: LD_EXP 25
1689: ADD
1690: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
1691: LD_ADDR_EXP 26
1695: PUSH
1696: LD_STRING Bobby
1698: PPUSH
1699: LD_EXP 1
1703: NOT
1704: PPUSH
1705: LD_STRING 13s_
1707: PPUSH
1708: CALL 42449 0 3
1712: ST_TO_ADDR
// if Bobby then
1713: LD_EXP 26
1717: IFFALSE 1735
// tmp := tmp ^ Bobby ;
1719: LD_ADDR_VAR 0 6
1723: PUSH
1724: LD_VAR 0 6
1728: PUSH
1729: LD_EXP 26
1733: ADD
1734: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
1735: LD_ADDR_EXP 27
1739: PUSH
1740: LD_STRING Cyrus
1742: PPUSH
1743: LD_EXP 1
1747: NOT
1748: PPUSH
1749: LD_STRING 13s_
1751: PPUSH
1752: CALL 42449 0 3
1756: ST_TO_ADDR
// if Cyrus then
1757: LD_EXP 27
1761: IFFALSE 1779
// tmp := tmp ^ Cyrus ;
1763: LD_ADDR_VAR 0 6
1767: PUSH
1768: LD_VAR 0 6
1772: PUSH
1773: LD_EXP 27
1777: ADD
1778: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
1779: LD_ADDR_EXP 28
1783: PUSH
1784: LD_STRING Denis
1786: PPUSH
1787: LD_EXP 1
1791: NOT
1792: PPUSH
1793: LD_STRING 13s_
1795: PPUSH
1796: CALL 42449 0 3
1800: ST_TO_ADDR
// if Denis then
1801: LD_EXP 28
1805: IFFALSE 1823
// tmp := tmp ^ Denis ;
1807: LD_ADDR_VAR 0 6
1811: PUSH
1812: LD_VAR 0 6
1816: PUSH
1817: LD_EXP 28
1821: ADD
1822: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
1823: LD_ADDR_EXP 29
1827: PUSH
1828: LD_STRING Brown
1830: PPUSH
1831: LD_EXP 1
1835: NOT
1836: PPUSH
1837: LD_STRING 13s_
1839: PPUSH
1840: CALL 42449 0 3
1844: ST_TO_ADDR
// if Brown then
1845: LD_EXP 29
1849: IFFALSE 1867
// tmp := tmp ^ Brown ;
1851: LD_ADDR_VAR 0 6
1855: PUSH
1856: LD_VAR 0 6
1860: PUSH
1861: LD_EXP 29
1865: ADD
1866: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
1867: LD_ADDR_EXP 30
1871: PUSH
1872: LD_STRING Gladstone
1874: PPUSH
1875: LD_EXP 1
1879: NOT
1880: PPUSH
1881: LD_STRING 13s_
1883: PPUSH
1884: CALL 42449 0 3
1888: ST_TO_ADDR
// if Gladstone then
1889: LD_EXP 30
1893: IFFALSE 1911
// tmp := tmp ^ Gladstone ;
1895: LD_ADDR_VAR 0 6
1899: PUSH
1900: LD_VAR 0 6
1904: PUSH
1905: LD_EXP 30
1909: ADD
1910: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
1911: LD_ADDR_EXP 31
1915: PUSH
1916: LD_STRING Houten
1918: PPUSH
1919: LD_EXP 1
1923: NOT
1924: PPUSH
1925: LD_STRING 13s_
1927: PPUSH
1928: CALL 42449 0 3
1932: ST_TO_ADDR
// if Houten then
1933: LD_EXP 31
1937: IFFALSE 1955
// tmp := tmp ^ Houten ;
1939: LD_ADDR_VAR 0 6
1943: PUSH
1944: LD_VAR 0 6
1948: PUSH
1949: LD_EXP 31
1953: ADD
1954: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
1955: LD_ADDR_EXP 32
1959: PUSH
1960: LD_STRING Cornel
1962: PPUSH
1963: LD_EXP 1
1967: NOT
1968: PPUSH
1969: LD_STRING 13s_
1971: PPUSH
1972: CALL 42449 0 3
1976: ST_TO_ADDR
// if Cornel then
1977: LD_EXP 32
1981: IFFALSE 1999
// tmp := tmp ^ Cornel ;
1983: LD_ADDR_VAR 0 6
1987: PUSH
1988: LD_VAR 0 6
1992: PUSH
1993: LD_EXP 32
1997: ADD
1998: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
1999: LD_ADDR_EXP 33
2003: PUSH
2004: LD_STRING Gary
2006: PPUSH
2007: LD_EXP 1
2011: NOT
2012: PPUSH
2013: LD_STRING 13s_
2015: PPUSH
2016: CALL 42449 0 3
2020: ST_TO_ADDR
// if Gary then
2021: LD_EXP 33
2025: IFFALSE 2043
// tmp := tmp ^ Gary ;
2027: LD_ADDR_VAR 0 6
2031: PUSH
2032: LD_VAR 0 6
2036: PUSH
2037: LD_EXP 33
2041: ADD
2042: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
2043: LD_ADDR_EXP 34
2047: PUSH
2048: LD_STRING Frank
2050: PPUSH
2051: LD_EXP 1
2055: NOT
2056: PPUSH
2057: LD_STRING 13s_
2059: PPUSH
2060: CALL 42449 0 3
2064: ST_TO_ADDR
// if Frank then
2065: LD_EXP 34
2069: IFFALSE 2087
// tmp := tmp ^ Frank ;
2071: LD_ADDR_VAR 0 6
2075: PUSH
2076: LD_VAR 0 6
2080: PUSH
2081: LD_EXP 34
2085: ADD
2086: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
2087: LD_ADDR_EXP 35
2091: PUSH
2092: LD_STRING Kikuchi
2094: PPUSH
2095: LD_EXP 1
2099: NOT
2100: PPUSH
2101: LD_STRING 13s_
2103: PPUSH
2104: CALL 42449 0 3
2108: ST_TO_ADDR
// if Kikuchi then
2109: LD_EXP 35
2113: IFFALSE 2131
// tmp := tmp ^ Kikuchi ;
2115: LD_ADDR_VAR 0 6
2119: PUSH
2120: LD_VAR 0 6
2124: PUSH
2125: LD_EXP 35
2129: ADD
2130: ST_TO_ADDR
// vip := tmp ;
2131: LD_ADDR_EXP 40
2135: PUSH
2136: LD_VAR 0 6
2140: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
2141: LD_ADDR_VAR 0 6
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_STRING 13s_others
2153: PPUSH
2154: CALL_OW 31
2158: UNION
2159: ST_TO_ADDR
// if tmp < 20 then
2160: LD_VAR 0 6
2164: PUSH
2165: LD_INT 20
2167: LESS
2168: IFFALSE 2235
// for i = 1 to 20 - tmp do
2170: LD_ADDR_VAR 0 2
2174: PUSH
2175: DOUBLE
2176: LD_INT 1
2178: DEC
2179: ST_TO_ADDR
2180: LD_INT 20
2182: PUSH
2183: LD_VAR 0 6
2187: MINUS
2188: PUSH
2189: FOR_TO
2190: IFFALSE 2233
// begin PrepareHuman ( false , i mod 4 + 1 , 8 ) ;
2192: LD_INT 0
2194: PPUSH
2195: LD_VAR 0 2
2199: PUSH
2200: LD_INT 4
2202: MOD
2203: PUSH
2204: LD_INT 1
2206: PLUS
2207: PPUSH
2208: LD_INT 8
2210: PPUSH
2211: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2215: LD_ADDR_VAR 0 6
2219: PUSH
2220: LD_VAR 0 6
2224: PUSH
2225: CALL_OW 44
2229: ADD
2230: ST_TO_ADDR
// end ;
2231: GO 2189
2233: POP
2234: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
2235: LD_ADDR_VAR 0 7
2239: PUSH
2240: LD_INT 22
2242: PUSH
2243: LD_INT 4
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 30
2252: PUSH
2253: LD_INT 0
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: PUSH
2260: EMPTY
2261: LIST
2262: LIST
2263: PPUSH
2264: CALL_OW 69
2268: PUSH
2269: LD_INT 1
2271: ARRAY
2272: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
2273: LD_ADDR_VAR 0 8
2277: PUSH
2278: LD_INT 22
2280: PUSH
2281: LD_INT 4
2283: PUSH
2284: EMPTY
2285: LIST
2286: LIST
2287: PUSH
2288: LD_INT 30
2290: PUSH
2291: LD_INT 6
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PPUSH
2302: CALL_OW 69
2306: PUSH
2307: LD_INT 1
2309: ARRAY
2310: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
2311: LD_ADDR_VAR 0 9
2315: PUSH
2316: LD_INT 22
2318: PUSH
2319: LD_INT 4
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: PUSH
2326: LD_INT 30
2328: PUSH
2329: LD_INT 4
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: PUSH
2336: EMPTY
2337: LIST
2338: LIST
2339: PPUSH
2340: CALL_OW 69
2344: PUSH
2345: LD_INT 1
2347: ARRAY
2348: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
2349: LD_ADDR_VAR 0 10
2353: PUSH
2354: LD_INT 22
2356: PUSH
2357: LD_INT 4
2359: PUSH
2360: EMPTY
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 30
2366: PUSH
2367: LD_INT 2
2369: PUSH
2370: EMPTY
2371: LIST
2372: LIST
2373: PUSH
2374: EMPTY
2375: LIST
2376: LIST
2377: PPUSH
2378: CALL_OW 69
2382: PUSH
2383: LD_INT 1
2385: ARRAY
2386: ST_TO_ADDR
// for i in tmp do
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 6
2396: PUSH
2397: FOR_IN
2398: IFFALSE 2524
// begin cl := GetClass ( i ) ;
2400: LD_ADDR_VAR 0 5
2404: PUSH
2405: LD_VAR 0 2
2409: PPUSH
2410: CALL_OW 257
2414: ST_TO_ADDR
// if cl > 4 then
2415: LD_VAR 0 5
2419: PUSH
2420: LD_INT 4
2422: GREATER
2423: IFFALSE 2433
// cl := 1 ;
2425: LD_ADDR_VAR 0 5
2429: PUSH
2430: LD_INT 1
2432: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
2433: LD_ADDR_VAR 0 3
2437: PUSH
2438: LD_VAR 0 9
2442: PUSH
2443: LD_VAR 0 7
2447: PUSH
2448: LD_VAR 0 10
2452: PUSH
2453: LD_VAR 0 8
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: LIST
2462: LIST
2463: PUSH
2464: LD_VAR 0 5
2468: ARRAY
2469: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
2470: LD_VAR 0 3
2474: PPUSH
2475: CALL_OW 313
2479: PUSH
2480: LD_INT 5
2482: LESS
2483: IFFALSE 2501
// PlaceHumanInUnit ( i , b ) else
2485: LD_VAR 0 2
2489: PPUSH
2490: LD_VAR 0 3
2494: PPUSH
2495: CALL_OW 52
2499: GO 2522
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
2501: LD_VAR 0 2
2505: PPUSH
2506: LD_INT 58
2508: PPUSH
2509: LD_INT 91
2511: PPUSH
2512: LD_INT 6
2514: PPUSH
2515: LD_INT 0
2517: PPUSH
2518: CALL_OW 50
// end ;
2522: GO 2397
2524: POP
2525: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
2526: LD_INT 2
2528: PPUSH
2529: LD_INT 1
2531: PPUSH
2532: LD_INT 1
2534: PPUSH
2535: LD_INT 12
2537: PPUSH
2538: LD_INT 100
2540: PPUSH
2541: CALL 49082 0 5
// veh := CreateVehicle ;
2545: LD_ADDR_VAR 0 4
2549: PUSH
2550: CALL_OW 45
2554: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2555: LD_VAR 0 4
2559: PPUSH
2560: LD_INT 4
2562: PPUSH
2563: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
2567: LD_VAR 0 4
2571: PPUSH
2572: LD_INT 49
2574: PPUSH
2575: LD_INT 88
2577: PPUSH
2578: LD_INT 0
2580: PPUSH
2581: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
2585: LD_VAR 0 4
2589: PPUSH
2590: LD_INT 1
2592: PPUSH
2593: LD_INT 100
2595: PPUSH
2596: CALL_OW 290
// uc_side := 0 ;
2600: LD_ADDR_OWVAR 20
2604: PUSH
2605: LD_INT 0
2607: ST_TO_ADDR
// uc_nation := 0 ;
2608: LD_ADDR_OWVAR 21
2612: PUSH
2613: LD_INT 0
2615: ST_TO_ADDR
// for i = 1 to 4 do
2616: LD_ADDR_VAR 0 2
2620: PUSH
2621: DOUBLE
2622: LD_INT 1
2624: DEC
2625: ST_TO_ADDR
2626: LD_INT 4
2628: PUSH
2629: FOR_TO
2630: IFFALSE 2661
// begin InitHc ;
2632: CALL_OW 19
// hc_class := class_apeman ;
2636: LD_ADDR_OWVAR 28
2640: PUSH
2641: LD_INT 12
2643: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
2644: CALL_OW 44
2648: PPUSH
2649: LD_INT 14
2651: PPUSH
2652: LD_INT 0
2654: PPUSH
2655: CALL_OW 49
// end ;
2659: GO 2629
2661: POP
2662: POP
// end ; end_of_file
2663: LD_VAR 0 1
2667: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
2668: LD_INT 0
2670: PPUSH
2671: PPUSH
2672: PPUSH
2673: PPUSH
2674: PPUSH
// side := 8 ;
2675: LD_ADDR_VAR 0 3
2679: PUSH
2680: LD_INT 8
2682: ST_TO_ADDR
// uc_side := side ;
2683: LD_ADDR_OWVAR 20
2687: PUSH
2688: LD_VAR 0 3
2692: ST_TO_ADDR
// uc_nation := 2 ;
2693: LD_ADDR_OWVAR 21
2697: PUSH
2698: LD_INT 2
2700: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
2701: LD_ADDR_VAR 0 2
2705: PUSH
2706: LD_INT 22
2708: PUSH
2709: LD_VAR 0 3
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: LD_INT 21
2720: PUSH
2721: LD_INT 3
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PPUSH
2732: CALL_OW 69
2736: PUSH
2737: FOR_IN
2738: IFFALSE 2754
// SetBLevel ( i , 10 ) ;
2740: LD_VAR 0 2
2744: PPUSH
2745: LD_INT 10
2747: PPUSH
2748: CALL_OW 241
2752: GO 2737
2754: POP
2755: POP
// if KurtStatus then
2756: LD_EXP 3
2760: IFFALSE 2783
// Kurt := PrepareUnit ( Kurt , false ,  ) else
2762: LD_ADDR_EXP 41
2766: PUSH
2767: LD_STRING Kurt
2769: PPUSH
2770: LD_INT 0
2772: PPUSH
2773: LD_STRING 
2775: PPUSH
2776: CALL 42449 0 3
2780: ST_TO_ADDR
2781: GO 2805
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
2783: LD_ADDR_EXP 41
2787: PUSH
2788: LD_STRING AltKurt
2790: PPUSH
2791: LD_EXP 1
2795: NOT
2796: PPUSH
2797: LD_STRING 
2799: PPUSH
2800: CALL 42449 0 3
2804: ST_TO_ADDR
// if not Kurt then
2805: LD_EXP 41
2809: NOT
2810: IFFALSE 2836
// begin InitHc ;
2812: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
2816: LD_INT 1
2818: PPUSH
2819: LD_INT 10
2821: PPUSH
2822: CALL_OW 381
// Kurt := CreateHuman ;
2826: LD_ADDR_EXP 41
2830: PUSH
2831: CALL_OW 44
2835: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
2836: LD_EXP 41
2840: PPUSH
2841: LD_INT 324
2843: PPUSH
2844: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
2848: LD_ADDR_EXP 42
2852: PUSH
2853: LD_STRING Kozlov
2855: PPUSH
2856: LD_INT 0
2858: PPUSH
2859: LD_STRING 
2861: PPUSH
2862: CALL 42449 0 3
2866: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
2867: LD_EXP 42
2871: PPUSH
2872: LD_INT 22
2874: PUSH
2875: LD_INT 8
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PUSH
2882: LD_INT 23
2884: PUSH
2885: LD_INT 3
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 30
2894: PUSH
2895: LD_INT 8
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: LIST
2906: PPUSH
2907: CALL_OW 69
2911: PUSH
2912: LD_INT 1
2914: ARRAY
2915: PPUSH
2916: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
2920: LD_ADDR_VAR 0 5
2924: PUSH
2925: LD_INT 22
2927: PUSH
2928: LD_VAR 0 3
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: LD_INT 30
2939: PUSH
2940: LD_INT 32
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 58
2949: PUSH
2950: EMPTY
2951: LIST
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: LIST
2957: PPUSH
2958: CALL_OW 69
2962: ST_TO_ADDR
// for i = 1 to 10 do
2963: LD_ADDR_VAR 0 2
2967: PUSH
2968: DOUBLE
2969: LD_INT 1
2971: DEC
2972: ST_TO_ADDR
2973: LD_INT 10
2975: PUSH
2976: FOR_TO
2977: IFFALSE 3049
// begin uc_nation := nation_nature ;
2979: LD_ADDR_OWVAR 21
2983: PUSH
2984: LD_INT 0
2986: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
2987: LD_ADDR_OWVAR 28
2991: PUSH
2992: LD_INT 15
2994: ST_TO_ADDR
// hc_gallery :=  ;
2995: LD_ADDR_OWVAR 33
2999: PUSH
3000: LD_STRING 
3002: ST_TO_ADDR
// hc_name :=  ;
3003: LD_ADDR_OWVAR 26
3007: PUSH
3008: LD_STRING 
3010: ST_TO_ADDR
// un := CreateHuman ;
3011: LD_ADDR_VAR 0 4
3015: PUSH
3016: CALL_OW 44
3020: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
3021: LD_VAR 0 4
3025: PPUSH
3026: LD_VAR 0 5
3030: PUSH
3031: LD_VAR 0 5
3035: PUSH
3036: LD_VAR 0 2
3040: MINUS
3041: ARRAY
3042: PPUSH
3043: CALL_OW 52
// end ;
3047: GO 2976
3049: POP
3050: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
3051: LD_ADDR_VAR 0 5
3055: PUSH
3056: LD_STRING 12_kurt_squad
3058: PPUSH
3059: CALL_OW 31
3063: ST_TO_ADDR
// if tmp then
3064: LD_VAR 0 5
3068: IFFALSE 3102
// for i in tmp do
3070: LD_ADDR_VAR 0 2
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: FOR_IN
3081: IFFALSE 3100
// PlaceUnitArea ( i , legionBaseArea , false ) ;
3083: LD_VAR 0 2
3087: PPUSH
3088: LD_INT 5
3090: PPUSH
3091: LD_INT 0
3093: PPUSH
3094: CALL_OW 49
3098: GO 3080
3100: POP
3101: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
3102: LD_INT 324
3104: PPUSH
3105: LD_INT 5
3107: PPUSH
3108: LD_STRING 
3110: PPUSH
3111: LD_INT 8
3113: PUSH
3114: LD_INT 9
3116: PUSH
3117: LD_INT 10
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_OWVAR 67
3129: ARRAY
3130: PPUSH
3131: LD_INT 3000
3133: PUSH
3134: LD_INT 500
3136: PUSH
3137: LD_INT 150
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: LIST
3144: PPUSH
3145: LD_INT 16
3147: PUSH
3148: LD_INT 6
3150: PUSH
3151: LD_INT 6
3153: PUSH
3154: LD_INT 8
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: PPUSH
3163: CALL 52491 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
3167: LD_ADDR_EXP 71
3171: PUSH
3172: LD_EXP 71
3176: PPUSH
3177: LD_INT 3
3179: PPUSH
3180: LD_INT 22
3182: PUSH
3183: LD_VAR 0 3
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 23
3194: PUSH
3195: LD_INT 2
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 3
3204: PUSH
3205: LD_INT 21
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: CALL_OW 69
3228: PUSH
3229: LD_EXP 41
3233: DIFF
3234: PPUSH
3235: CALL_OW 1
3239: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
3240: LD_INT 1
3242: PPUSH
3243: LD_INT 7
3245: PPUSH
3246: CALL_OW 383
// Friend := CreateHuman ;
3250: LD_ADDR_EXP 43
3254: PUSH
3255: CALL_OW 44
3259: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
3260: LD_INT 14
3262: PPUSH
3263: LD_INT 3
3265: PPUSH
3266: LD_INT 1
3268: PPUSH
3269: LD_INT 29
3271: PPUSH
3272: LD_INT 100
3274: PPUSH
3275: CALL 49082 0 5
// powellBomb := CreateVehicle ;
3279: LD_ADDR_EXP 44
3283: PUSH
3284: CALL_OW 45
3288: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
3289: LD_EXP 44
3293: PPUSH
3294: LD_INT 90
3296: PPUSH
3297: LD_INT 51
3299: PPUSH
3300: LD_INT 0
3302: PPUSH
3303: CALL_OW 48
// end ;
3307: LD_VAR 0 1
3311: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
3312: LD_INT 0
3314: PPUSH
3315: PPUSH
3316: PPUSH
// if IsLive ( kozlov_fac ) then
3317: LD_INT 332
3319: PPUSH
3320: CALL_OW 300
3324: IFFALSE 3328
// exit ;
3326: GO 3895
// ComExitBuilding ( Kozlov ) ;
3328: LD_EXP 42
3332: PPUSH
3333: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
3337: LD_EXP 42
3341: PPUSH
3342: CALL_OW 257
3346: PUSH
3347: LD_INT 2
3349: NONEQUAL
3350: IFFALSE 3385
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
3352: LD_EXP 42
3356: PPUSH
3357: LD_INT 324
3359: PPUSH
3360: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
3364: LD_EXP 42
3368: PPUSH
3369: LD_INT 2
3371: PPUSH
3372: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
3376: LD_EXP 42
3380: PPUSH
3381: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
3385: LD_EXP 42
3389: PPUSH
3390: LD_INT 2
3392: PPUSH
3393: LD_INT 93
3395: PPUSH
3396: LD_INT 32
3398: PPUSH
3399: LD_INT 3
3401: PPUSH
3402: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3406: LD_INT 35
3408: PPUSH
3409: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
3413: LD_INT 22
3415: PUSH
3416: LD_INT 8
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PUSH
3423: LD_INT 30
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: PUSH
3433: LD_INT 23
3435: PUSH
3436: LD_INT 3
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: LD_INT 57
3445: PUSH
3446: EMPTY
3447: LIST
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: LIST
3453: LIST
3454: PPUSH
3455: CALL_OW 69
3459: IFFALSE 3406
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
3461: LD_ADDR_VAR 0 2
3465: PUSH
3466: LD_INT 22
3468: PUSH
3469: LD_INT 8
3471: PUSH
3472: EMPTY
3473: LIST
3474: LIST
3475: PUSH
3476: LD_INT 30
3478: PUSH
3479: LD_INT 3
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: PUSH
3486: LD_INT 23
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: EMPTY
3493: LIST
3494: LIST
3495: PUSH
3496: LD_INT 57
3498: PUSH
3499: EMPTY
3500: LIST
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: PPUSH
3508: CALL_OW 69
3512: PUSH
3513: LD_INT 1
3515: ARRAY
3516: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
3517: LD_INT 22
3519: PUSH
3520: LD_INT 8
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 23
3529: PUSH
3530: LD_INT 3
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: PUSH
3537: LD_INT 30
3539: PUSH
3540: LD_INT 21
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: LIST
3551: PPUSH
3552: CALL_OW 69
3556: NOT
3557: IFFALSE 3635
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
3559: LD_EXP 42
3563: PPUSH
3564: LD_INT 21
3566: PPUSH
3567: LD_INT 97
3569: PPUSH
3570: LD_INT 36
3572: PPUSH
3573: LD_INT 5
3575: PPUSH
3576: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3580: LD_INT 35
3582: PPUSH
3583: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
3587: LD_INT 22
3589: PUSH
3590: LD_INT 8
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: PUSH
3597: LD_INT 23
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 21
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 57
3619: PUSH
3620: EMPTY
3621: LIST
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: LIST
3627: LIST
3628: PPUSH
3629: CALL_OW 69
3633: IFFALSE 3580
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
3635: LD_INT 22
3637: PUSH
3638: LD_INT 8
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 23
3647: PUSH
3648: LD_INT 3
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PUSH
3655: LD_INT 30
3657: PUSH
3658: LD_INT 18
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: LIST
3669: PPUSH
3670: CALL_OW 69
3674: NOT
3675: IFFALSE 3753
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
3677: LD_EXP 42
3681: PPUSH
3682: LD_INT 18
3684: PPUSH
3685: LD_INT 89
3687: PPUSH
3688: LD_INT 32
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3698: LD_INT 35
3700: PPUSH
3701: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
3705: LD_INT 22
3707: PUSH
3708: LD_INT 8
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 23
3717: PUSH
3718: LD_INT 3
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 30
3727: PUSH
3728: LD_INT 18
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: LD_INT 57
3737: PUSH
3738: EMPTY
3739: LIST
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PPUSH
3747: CALL_OW 69
3751: IFFALSE 3698
// end ; lab := kozlov_lab ;
3753: LD_ADDR_VAR 0 3
3757: PUSH
3758: LD_INT 336
3760: ST_TO_ADDR
// if not lab then
3761: LD_VAR 0 3
3765: NOT
3766: IFFALSE 3770
// exit ;
3768: GO 3895
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
3770: LD_EXP 42
3774: PPUSH
3775: LD_VAR 0 3
3779: PUSH
3780: LD_INT 1
3782: ARRAY
3783: PPUSH
3784: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
3788: LD_EXP 42
3792: PPUSH
3793: LD_INT 4
3795: PPUSH
3796: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
3800: LD_VAR 0 3
3804: PUSH
3805: LD_INT 1
3807: ARRAY
3808: PPUSH
3809: LD_INT 25
3811: PPUSH
3812: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
3816: LD_INT 35
3818: PPUSH
3819: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
3823: LD_INT 25
3825: PPUSH
3826: LD_INT 8
3828: PPUSH
3829: CALL_OW 321
3833: PUSH
3834: LD_INT 2
3836: EQUAL
3837: IFFALSE 3816
// ComExitBuilding ( Kozlov ) ;
3839: LD_EXP 42
3843: PPUSH
3844: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
3848: LD_EXP 42
3852: PPUSH
3853: LD_VAR 0 2
3857: PPUSH
3858: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
3862: LD_EXP 42
3866: PPUSH
3867: LD_INT 3
3869: PPUSH
3870: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
3874: LD_VAR 0 2
3878: PPUSH
3879: LD_INT 23
3881: PPUSH
3882: LD_INT 3
3884: PPUSH
3885: LD_INT 1
3887: PPUSH
3888: LD_INT 48
3890: PPUSH
3891: CALL_OW 125
// end ; end_of_file
3895: LD_VAR 0 1
3899: RET
// export Platonov , Kovalyuk ; export function PrepareRussian ; var i , base , tmp , side ; begin
3900: LD_INT 0
3902: PPUSH
3903: PPUSH
3904: PPUSH
3905: PPUSH
3906: PPUSH
// side := 3 ;
3907: LD_ADDR_VAR 0 5
3911: PUSH
3912: LD_INT 3
3914: ST_TO_ADDR
// uc_side := side ;
3915: LD_ADDR_OWVAR 20
3919: PUSH
3920: LD_VAR 0 5
3924: ST_TO_ADDR
// uc_nation := 3 ;
3925: LD_ADDR_OWVAR 21
3929: PUSH
3930: LD_INT 3
3932: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_INT 22
3940: PUSH
3941: LD_VAR 0 5
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 21
3952: PUSH
3953: LD_INT 3
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: PUSH
3969: FOR_IN
3970: IFFALSE 3986
// SetBLevel ( i , 10 ) ;
3972: LD_VAR 0 2
3976: PPUSH
3977: LD_INT 10
3979: PPUSH
3980: CALL_OW 241
3984: GO 3969
3986: POP
3987: POP
// Platonov := NewCharacter ( Platonov ) ;
3988: LD_ADDR_EXP 45
3992: PUSH
3993: LD_STRING Platonov
3995: PPUSH
3996: CALL_OW 25
4000: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4001: LD_ADDR_EXP 46
4005: PUSH
4006: LD_STRING Kovalyuk
4008: PPUSH
4009: CALL_OW 25
4013: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , ru_depot ) ;
4014: LD_EXP 45
4018: PPUSH
4019: LD_INT 126
4021: PPUSH
4022: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
4026: LD_EXP 46
4030: PPUSH
4031: LD_INT 134
4033: PPUSH
4034: CALL_OW 52
// PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 1000 , 300 ] , [ - 1 , 8 , 13 , 8 ] ) ;
4038: LD_INT 126
4040: PPUSH
4041: LD_INT 4
4043: PPUSH
4044: LD_STRING zhukov
4046: PPUSH
4047: LD_INT 9
4049: PUSH
4050: LD_INT 10
4052: PUSH
4053: LD_INT 10
4055: PUSH
4056: EMPTY
4057: LIST
4058: LIST
4059: LIST
4060: PUSH
4061: LD_OWVAR 67
4065: ARRAY
4066: PPUSH
4067: LD_INT 3000
4069: PUSH
4070: LD_INT 1000
4072: PUSH
4073: LD_INT 300
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: LIST
4080: PPUSH
4081: LD_INT 1
4083: NEG
4084: PUSH
4085: LD_INT 8
4087: PUSH
4088: LD_INT 13
4090: PUSH
4091: LD_INT 8
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: PPUSH
4100: CALL 52491 0 6
// base := GetBase ( ru_depot2 ) ;
4104: LD_ADDR_VAR 0 3
4108: PUSH
4109: LD_INT 267
4111: PPUSH
4112: CALL_OW 274
4116: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 600 ) ;
4117: LD_VAR 0 3
4121: PPUSH
4122: LD_INT 1
4124: PPUSH
4125: LD_INT 600
4127: PPUSH
4128: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
4132: LD_VAR 0 3
4136: PPUSH
4137: LD_INT 2
4139: PPUSH
4140: LD_INT 200
4142: PPUSH
4143: CALL_OW 277
// SetResourceType ( base , mat_siberit , 20 ) ;
4147: LD_VAR 0 3
4151: PPUSH
4152: LD_INT 3
4154: PPUSH
4155: LD_INT 20
4157: PPUSH
4158: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Platonov , Kovalyuk ] ) ;
4162: LD_ADDR_EXP 71
4166: PUSH
4167: LD_EXP 71
4171: PPUSH
4172: LD_INT 2
4174: PPUSH
4175: LD_INT 22
4177: PUSH
4178: LD_VAR 0 5
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: PUSH
4187: LD_INT 3
4189: PUSH
4190: LD_INT 21
4192: PUSH
4193: LD_INT 2
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PPUSH
4208: CALL_OW 69
4212: PUSH
4213: LD_EXP 45
4217: PUSH
4218: LD_EXP 46
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: DIFF
4227: PPUSH
4228: CALL_OW 1
4232: ST_TO_ADDR
// end ;
4233: LD_VAR 0 1
4237: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , areas ;
4238: LD_EXP 16
4242: IFFALSE 4259
4244: GO 4246
4246: DISABLE
4247: LD_INT 0
4249: PPUSH
4250: PPUSH
4251: PPUSH
// begin areas := [ ] ;
4252: LD_ADDR_VAR 0 3
4256: PUSH
4257: EMPTY
4258: ST_TO_ADDR
// end ; end_of_file
4259: PPOPN 3
4261: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
4262: LD_INT 0
4264: PPUSH
4265: PPUSH
4266: PPUSH
4267: PPUSH
4268: PPUSH
4269: PPUSH
// side := 7 ;
4270: LD_ADDR_VAR 0 5
4274: PUSH
4275: LD_INT 7
4277: ST_TO_ADDR
// uc_side := side ;
4278: LD_ADDR_OWVAR 20
4282: PUSH
4283: LD_VAR 0 5
4287: ST_TO_ADDR
// uc_nation := 1 ;
4288: LD_ADDR_OWVAR 21
4292: PUSH
4293: LD_INT 1
4295: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4296: LD_ADDR_VAR 0 2
4300: PUSH
4301: LD_INT 22
4303: PUSH
4304: LD_VAR 0 5
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PUSH
4313: LD_INT 21
4315: PUSH
4316: LD_INT 3
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PPUSH
4327: CALL_OW 69
4331: PUSH
4332: FOR_IN
4333: IFFALSE 4349
// SetBLevel ( i , 10 ) ;
4335: LD_VAR 0 2
4339: PPUSH
4340: LD_INT 10
4342: PPUSH
4343: CALL_OW 241
4347: GO 4332
4349: POP
4350: POP
// base := GetBase ( al_depot ) ;
4351: LD_ADDR_VAR 0 4
4355: PUSH
4356: LD_INT 2
4358: PPUSH
4359: CALL_OW 274
4363: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
4364: LD_ADDR_VAR 0 6
4368: PUSH
4369: LD_INT 22
4371: PUSH
4372: LD_VAR 0 5
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 30
4383: PUSH
4384: LD_INT 34
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PPUSH
4395: CALL_OW 69
4399: ST_TO_ADDR
// if teleport then
4400: LD_VAR 0 6
4404: IFFALSE 4425
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
4406: LD_VAR 0 6
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PPUSH
4415: LD_INT 262
4417: PPUSH
4418: LD_INT 119
4420: PPUSH
4421: CALL_OW 243
// SetResourceType ( base , mat_cans , 2500 ) ;
4425: LD_VAR 0 4
4429: PPUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2500
4435: PPUSH
4436: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
4440: LD_VAR 0 4
4444: PPUSH
4445: LD_INT 2
4447: PPUSH
4448: LD_INT 200
4450: PPUSH
4451: CALL_OW 277
// SetResourceType ( base , mat_siberit , 50 ) ;
4455: LD_VAR 0 4
4459: PPUSH
4460: LD_INT 3
4462: PPUSH
4463: LD_INT 50
4465: PPUSH
4466: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
4470: LD_ADDR_EXP 47
4474: PUSH
4475: LD_STRING Roth
4477: PPUSH
4478: CALL_OW 25
4482: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
4483: LD_ADDR_EXP 48
4487: PUSH
4488: LD_STRING Simms
4490: PPUSH
4491: LD_EXP 1
4495: NOT
4496: PPUSH
4497: LD_STRING 10c_
4499: PPUSH
4500: CALL 42449 0 3
4504: ST_TO_ADDR
// uc_nation := 3 ;
4505: LD_ADDR_OWVAR 21
4509: PUSH
4510: LD_INT 3
4512: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
4513: LD_ADDR_EXP 49
4517: PUSH
4518: LD_STRING Kirilenkova
4520: PPUSH
4521: CALL_OW 25
4525: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4526: LD_ADDR_EXP 63
4530: PUSH
4531: LD_STRING Oblukov
4533: PPUSH
4534: CALL_OW 25
4538: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4539: LD_ADDR_EXP 50
4543: PUSH
4544: LD_STRING Dolgov
4546: PPUSH
4547: CALL_OW 25
4551: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
4552: LD_ADDR_EXP 51
4556: PUSH
4557: LD_STRING Petrosyan
4559: PPUSH
4560: CALL_OW 25
4564: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4565: LD_ADDR_EXP 62
4569: PUSH
4570: LD_STRING Scholtze
4572: PPUSH
4573: CALL_OW 25
4577: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4578: LD_ADDR_EXP 61
4582: PUSH
4583: LD_STRING Kapitsova
4585: PPUSH
4586: CALL_OW 25
4590: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
4591: LD_ADDR_EXP 52
4595: PUSH
4596: LD_STRING Petrovova
4598: PPUSH
4599: CALL_OW 25
4603: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4604: LD_ADDR_EXP 53
4608: PUSH
4609: LD_STRING Kuzmov
4611: PPUSH
4612: CALL_OW 25
4616: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4617: LD_ADDR_EXP 60
4621: PUSH
4622: LD_STRING Karamazov
4624: PPUSH
4625: CALL_OW 25
4629: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
4630: LD_STRING 13_Lipshchin_1
4632: PPUSH
4633: LD_INT 0
4635: PPUSH
4636: CALL_OW 30
4640: IFFALSE 4655
// Lipshchin := NewCharacter ( Lipshchin ) ;
4642: LD_ADDR_EXP 54
4646: PUSH
4647: LD_STRING Lipshchin
4649: PPUSH
4650: CALL_OW 25
4654: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
4655: LD_STRING 13_Titov_1
4657: PPUSH
4658: LD_INT 0
4660: PPUSH
4661: CALL_OW 30
4665: IFFALSE 4680
// Titov := NewCharacter ( Titov ) ;
4667: LD_ADDR_EXP 56
4671: PUSH
4672: LD_STRING Titov
4674: PPUSH
4675: CALL_OW 25
4679: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
4680: LD_STRING 13_Gnyevko_1
4682: PPUSH
4683: LD_INT 0
4685: PPUSH
4686: CALL_OW 30
4690: IFFALSE 4705
// Gnyevko := NewCharacter ( Gnyevko ) ;
4692: LD_ADDR_EXP 55
4696: PUSH
4697: LD_STRING Gnyevko
4699: PPUSH
4700: CALL_OW 25
4704: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
4705: LD_STRING 13_Xavier_1
4707: PPUSH
4708: LD_INT 0
4710: PPUSH
4711: CALL_OW 30
4715: IFFALSE 4730
// Xavier := NewCharacter ( Xavier2 ) ;
4717: LD_ADDR_EXP 57
4721: PUSH
4722: LD_STRING Xavier2
4724: PPUSH
4725: CALL_OW 25
4729: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
4730: LD_STRING 13_Belkov_1
4732: PPUSH
4733: LD_INT 0
4735: PPUSH
4736: CALL_OW 30
4740: IFFALSE 4755
// Belkov := NewCharacter ( Belkov ) ;
4742: LD_ADDR_EXP 58
4746: PUSH
4747: LD_STRING Belkov
4749: PPUSH
4750: CALL_OW 25
4754: ST_TO_ADDR
// if not BurlakStatus then
4755: LD_EXP 9
4759: NOT
4760: IFFALSE 4775
// Burlak = NewCharacter ( Burlak ) ;
4762: LD_ADDR_EXP 59
4766: PUSH
4767: LD_STRING Burlak
4769: PPUSH
4770: CALL_OW 25
4774: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
4775: LD_ADDR_VAR 0 3
4779: PUSH
4780: LD_EXP 47
4784: PUSH
4785: LD_EXP 49
4789: PUSH
4790: LD_EXP 63
4794: PUSH
4795: LD_EXP 50
4799: PUSH
4800: LD_EXP 51
4804: PUSH
4805: LD_EXP 62
4809: PUSH
4810: LD_EXP 61
4814: PUSH
4815: LD_EXP 52
4819: PUSH
4820: LD_EXP 53
4824: PUSH
4825: LD_EXP 60
4829: PUSH
4830: EMPTY
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: ST_TO_ADDR
// if Simms then
4842: LD_EXP 48
4846: IFFALSE 4864
// tmp := tmp ^ Simms ;
4848: LD_ADDR_VAR 0 3
4852: PUSH
4853: LD_VAR 0 3
4857: PUSH
4858: LD_EXP 48
4862: ADD
4863: ST_TO_ADDR
// if Titov then
4864: LD_EXP 56
4868: IFFALSE 4886
// tmp := tmp ^ Titov ;
4870: LD_ADDR_VAR 0 3
4874: PUSH
4875: LD_VAR 0 3
4879: PUSH
4880: LD_EXP 56
4884: ADD
4885: ST_TO_ADDR
// if Lipshchin then
4886: LD_EXP 54
4890: IFFALSE 4908
// tmp := tmp ^ Lipshchin ;
4892: LD_ADDR_VAR 0 3
4896: PUSH
4897: LD_VAR 0 3
4901: PUSH
4902: LD_EXP 54
4906: ADD
4907: ST_TO_ADDR
// if Gnyevko then
4908: LD_EXP 55
4912: IFFALSE 4930
// tmp := tmp ^ Gnyevko ;
4914: LD_ADDR_VAR 0 3
4918: PUSH
4919: LD_VAR 0 3
4923: PUSH
4924: LD_EXP 55
4928: ADD
4929: ST_TO_ADDR
// if Xavier then
4930: LD_EXP 57
4934: IFFALSE 4952
// tmp := tmp ^ Xavier ;
4936: LD_ADDR_VAR 0 3
4940: PUSH
4941: LD_VAR 0 3
4945: PUSH
4946: LD_EXP 57
4950: ADD
4951: ST_TO_ADDR
// if Belkov then
4952: LD_EXP 58
4956: IFFALSE 4974
// tmp := tmp ^ Belkov ;
4958: LD_ADDR_VAR 0 3
4962: PUSH
4963: LD_VAR 0 3
4967: PUSH
4968: LD_EXP 58
4972: ADD
4973: ST_TO_ADDR
// if Burlak then
4974: LD_EXP 59
4978: IFFALSE 4996
// tmp := tmp ^ Burlak ;
4980: LD_ADDR_VAR 0 3
4984: PUSH
4985: LD_VAR 0 3
4989: PUSH
4990: LD_EXP 59
4994: ADD
4995: ST_TO_ADDR
// for i = 1 to 8 do
4996: LD_ADDR_VAR 0 2
5000: PUSH
5001: DOUBLE
5002: LD_INT 1
5004: DEC
5005: ST_TO_ADDR
5006: LD_INT 8
5008: PUSH
5009: FOR_TO
5010: IFFALSE 5076
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
5012: LD_ADDR_OWVAR 21
5016: PUSH
5017: LD_INT 1
5019: PUSH
5020: LD_INT 3
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 1
5029: PPUSH
5030: LD_INT 2
5032: PPUSH
5033: CALL_OW 12
5037: ARRAY
5038: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
5039: LD_INT 0
5041: PPUSH
5042: LD_VAR 0 2
5046: PUSH
5047: LD_INT 2
5049: DIV
5050: PPUSH
5051: LD_INT 10
5053: PPUSH
5054: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5058: LD_ADDR_VAR 0 3
5062: PUSH
5063: LD_VAR 0 3
5067: PUSH
5068: CALL_OW 44
5072: ADD
5073: ST_TO_ADDR
// end ;
5074: GO 5009
5076: POP
5077: POP
// for i in tmp do
5078: LD_ADDR_VAR 0 2
5082: PUSH
5083: LD_VAR 0 3
5087: PUSH
5088: FOR_IN
5089: IFFALSE 5114
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
5091: LD_VAR 0 2
5095: PPUSH
5096: LD_INT 260
5098: PPUSH
5099: LD_INT 235
5101: PPUSH
5102: LD_INT 8
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 50
5112: GO 5088
5114: POP
5115: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
5116: LD_ADDR_EXP 71
5120: PUSH
5121: LD_EXP 71
5125: PPUSH
5126: LD_INT 1
5128: PPUSH
5129: LD_INT 22
5131: PUSH
5132: LD_VAR 0 5
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PUSH
5141: LD_INT 3
5143: PUSH
5144: LD_INT 21
5146: PUSH
5147: LD_INT 2
5149: PUSH
5150: EMPTY
5151: LIST
5152: LIST
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: PPUSH
5162: CALL_OW 69
5166: PPUSH
5167: CALL_OW 1
5171: ST_TO_ADDR
// end ; end_of_file end_of_file
5172: LD_VAR 0 1
5176: RET
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
5177: LD_INT 0
5179: PPUSH
5180: PPUSH
5181: PPUSH
5182: PPUSH
5183: PPUSH
5184: PPUSH
5185: PPUSH
5186: PPUSH
5187: PPUSH
// Video ( true ) ;
5188: LD_INT 1
5190: PPUSH
5191: CALL 84737 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
5195: LD_ADDR_VAR 0 5
5199: PUSH
5200: LD_INT 8
5202: PPUSH
5203: LD_INT 0
5205: PPUSH
5206: CALL_OW 517
5210: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
5211: LD_ADDR_VAR 0 2
5215: PUSH
5216: DOUBLE
5217: LD_INT 1
5219: DEC
5220: ST_TO_ADDR
5221: LD_VAR 0 5
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: PUSH
5230: FOR_TO
5231: IFFALSE 5276
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
5233: LD_VAR 0 5
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PUSH
5242: LD_VAR 0 2
5246: ARRAY
5247: PPUSH
5248: LD_VAR 0 5
5252: PUSH
5253: LD_INT 2
5255: ARRAY
5256: PUSH
5257: LD_VAR 0 2
5261: ARRAY
5262: PPUSH
5263: LD_INT 1
5265: PPUSH
5266: LD_INT 15
5268: NEG
5269: PPUSH
5270: CALL 84651 0 4
5274: GO 5230
5276: POP
5277: POP
// CenterNowOnUnits ( Powell ) ;
5278: LD_EXP 39
5282: PPUSH
5283: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
5287: LD_ADDR_VAR 0 5
5291: PUSH
5292: LD_EXP 37
5296: PUSH
5297: EMPTY
5298: LIST
5299: ST_TO_ADDR
// if GirlNewVeh then
5300: LD_EXP 38
5304: IFFALSE 5322
// tmp := tmp ^ GirlNewVeh ;
5306: LD_ADDR_VAR 0 5
5310: PUSH
5311: LD_VAR 0 5
5315: PUSH
5316: LD_EXP 38
5320: ADD
5321: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
5322: LD_VAR 0 5
5326: PPUSH
5327: LD_INT 60
5329: PPUSH
5330: LD_INT 109
5332: PPUSH
5333: CALL_OW 111
// if KappaStatus then
5337: LD_EXP 2
5341: IFFALSE 5393
// begin Say ( JMM , D1T-JMM-1 ) ;
5343: LD_EXP 21
5347: PPUSH
5348: LD_STRING D1T-JMM-1
5350: PPUSH
5351: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
5355: LD_EXP 39
5359: PPUSH
5360: LD_STRING D1T-Pow-1
5362: PPUSH
5363: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
5367: LD_EXP 21
5371: PPUSH
5372: LD_STRING D1T-JMM-2
5374: PPUSH
5375: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
5379: LD_EXP 39
5383: PPUSH
5384: LD_STRING D1T-Pow-2
5386: PPUSH
5387: CALL_OW 88
// end else
5391: GO 5599
// if JMMGirlStatus then
5393: LD_EXP 6
5397: IFFALSE 5542
// begin Say ( JMM , D1T-JMM-1 ) ;
5399: LD_EXP 21
5403: PPUSH
5404: LD_STRING D1T-JMM-1
5406: PPUSH
5407: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
5411: LD_EXP 39
5415: PPUSH
5416: LD_STRING D1T-Pow-1
5418: PPUSH
5419: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
5423: LD_EXP 21
5427: PPUSH
5428: LD_STRING D1T-JMM-3
5430: PPUSH
5431: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
5435: LD_EXP 39
5439: PPUSH
5440: LD_STRING D1T-Pow-3
5442: PPUSH
5443: CALL_OW 88
// if JMMGirl then
5447: LD_EXP 7
5451: IFFALSE 5540
// begin case JMMGirl of 1 :
5453: LD_EXP 7
5457: PUSH
5458: LD_INT 1
5460: DOUBLE
5461: EQUAL
5462: IFTRUE 5466
5464: GO 5481
5466: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
5467: LD_EXP 22
5471: PPUSH
5472: LD_STRING D1T-Joan-3
5474: PPUSH
5475: CALL_OW 88
5479: GO 5528
5481: LD_INT 2
5483: DOUBLE
5484: EQUAL
5485: IFTRUE 5489
5487: GO 5504
5489: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
5490: LD_EXP 24
5494: PPUSH
5495: LD_STRING D1T-Lisa-3
5497: PPUSH
5498: CALL_OW 88
5502: GO 5528
5504: LD_INT 3
5506: DOUBLE
5507: EQUAL
5508: IFTRUE 5512
5510: GO 5527
5512: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
5513: LD_EXP 36
5517: PPUSH
5518: LD_STRING D1T-Con-3
5520: PPUSH
5521: CALL_OW 88
5525: GO 5528
5527: POP
// Say ( Powell , D1T-Pow-4 ) ;
5528: LD_EXP 39
5532: PPUSH
5533: LD_STRING D1T-Pow-4
5535: PPUSH
5536: CALL_OW 88
// end ; end else
5540: GO 5599
// if not FastEnd then
5542: LD_EXP 11
5546: NOT
5547: IFFALSE 5575
// begin Say ( JMM , D1T-JMM-4 ) ;
5549: LD_EXP 21
5553: PPUSH
5554: LD_STRING D1T-JMM-4
5556: PPUSH
5557: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
5561: LD_EXP 39
5565: PPUSH
5566: LD_STRING D1T-Pow-5
5568: PPUSH
5569: CALL_OW 88
// end else
5573: GO 5599
// begin Say ( JMM , D1nT-JMM-1 ) ;
5575: LD_EXP 21
5579: PPUSH
5580: LD_STRING D1nT-JMM-1
5582: PPUSH
5583: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
5587: LD_EXP 39
5591: PPUSH
5592: LD_STRING D1nT-Pow-1
5594: PPUSH
5595: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
5599: LD_INT 35
5601: PPUSH
5602: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
5606: LD_EXP 37
5610: PPUSH
5611: CALL_OW 314
5615: NOT
5616: IFFALSE 5599
// ComExitVehicle ( JMM ) ;
5618: LD_EXP 21
5622: PPUSH
5623: CALL_OW 121
// wait ( 3 ) ;
5627: LD_INT 3
5629: PPUSH
5630: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
5634: LD_EXP 21
5638: PPUSH
5639: LD_INT 60
5641: PPUSH
5642: LD_INT 94
5644: PPUSH
5645: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
5649: LD_EXP 21
5653: PPUSH
5654: LD_EXP 39
5658: PPUSH
5659: CALL_OW 179
// if JMMGirl and JMMGirlStatus and not KappaStatus then
5663: LD_EXP 7
5667: PUSH
5668: LD_EXP 6
5672: AND
5673: PUSH
5674: LD_EXP 2
5678: NOT
5679: AND
5680: IFFALSE 5783
// begin AddComExitVehicle ( [ Joan , Lisa , Connie ] [ JMMGirl ] ) ;
5682: LD_EXP 22
5686: PUSH
5687: LD_EXP 24
5691: PUSH
5692: LD_EXP 36
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: PUSH
5702: LD_EXP 7
5706: ARRAY
5707: PPUSH
5708: CALL_OW 181
// AddComMoveXY ( [ Joan , Lisa , Connie ] [ JMMGirl ] , 64 , 102 ) ;
5712: LD_EXP 22
5716: PUSH
5717: LD_EXP 24
5721: PUSH
5722: LD_EXP 36
5726: PUSH
5727: EMPTY
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_EXP 7
5736: ARRAY
5737: PPUSH
5738: LD_INT 64
5740: PPUSH
5741: LD_INT 102
5743: PPUSH
5744: CALL_OW 171
// AddComTurnUnit ( [ Joan , Lisa , Connie ] [ JMMGirl ] , JMM ) ;
5748: LD_EXP 22
5752: PUSH
5753: LD_EXP 24
5757: PUSH
5758: LD_EXP 36
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_EXP 7
5772: ARRAY
5773: PPUSH
5774: LD_EXP 21
5778: PPUSH
5779: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
5783: LD_INT 35
5785: PPUSH
5786: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
5790: LD_EXP 21
5794: PPUSH
5795: LD_EXP 39
5799: PPUSH
5800: CALL_OW 296
5804: PUSH
5805: LD_INT 6
5807: LESS
5808: IFFALSE 5783
// wait ( 0 0$0.5 ) ;
5810: LD_INT 18
5812: PPUSH
5813: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
5817: LD_EXP 21
5821: PPUSH
5822: LD_STRING D1-JMM-1
5824: PPUSH
5825: CALL_OW 88
// async ;
5829: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
5830: LD_EXP 39
5834: PPUSH
5835: LD_STRING D1-Pow-1
5837: PPUSH
5838: CALL_OW 88
// if not dialogue_skipped then
5842: LD_OWVAR 59
5846: NOT
5847: IFFALSE 5856
// wait ( 0 0$2 ) ;
5849: LD_INT 70
5851: PPUSH
5852: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
5856: LD_INT 170
5858: PPUSH
5859: LD_INT 99
5861: PPUSH
5862: LD_INT 1
5864: PPUSH
5865: LD_INT 6
5867: NEG
5868: PPUSH
5869: CALL 84651 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
5873: LD_INT 174
5875: PPUSH
5876: LD_INT 115
5878: PPUSH
5879: LD_INT 1
5881: PPUSH
5882: LD_INT 6
5884: NEG
5885: PPUSH
5886: CALL 84651 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
5890: LD_INT 169
5892: PPUSH
5893: LD_INT 71
5895: PPUSH
5896: LD_INT 1
5898: PPUSH
5899: LD_INT 6
5901: NEG
5902: PPUSH
5903: CALL 84651 0 4
// if not dialogue_skipped then
5907: LD_OWVAR 59
5911: NOT
5912: IFFALSE 5931
// begin CenterOnXY ( 170 , 99 ) ;
5914: LD_INT 170
5916: PPUSH
5917: LD_INT 99
5919: PPUSH
5920: CALL_OW 84
// wait ( 0 0$2.3 ) ;
5924: LD_INT 80
5926: PPUSH
5927: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
5931: LD_INT 75
5933: PPUSH
5934: LD_INT 53
5936: PPUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_INT 9
5942: NEG
5943: PPUSH
5944: CALL 84651 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
5948: LD_INT 54
5950: PPUSH
5951: LD_INT 42
5953: PPUSH
5954: LD_INT 1
5956: PPUSH
5957: LD_INT 9
5959: NEG
5960: PPUSH
5961: CALL 84651 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
5965: LD_INT 62
5967: PPUSH
5968: LD_INT 51
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: LD_INT 9
5976: NEG
5977: PPUSH
5978: CALL 84651 0 4
// if not dialogue_skipped then
5982: LD_OWVAR 59
5986: NOT
5987: IFFALSE 6006
// begin CenterOnXY ( 75 , 53 ) ;
5989: LD_INT 75
5991: PPUSH
5992: LD_INT 53
5994: PPUSH
5995: CALL_OW 84
// wait ( 0 0$4 ) ;
5999: LD_INT 140
6001: PPUSH
6002: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
6006: LD_EXP 39
6010: PPUSH
6011: CALL_OW 87
// if not dialogue_skipped then
6015: LD_OWVAR 59
6019: NOT
6020: IFFALSE 6029
// wait ( 0 0$2 ) ;
6022: LD_INT 70
6024: PPUSH
6025: CALL_OW 67
// sync ;
6029: SYNC
// Say ( JMM , D1-JMM-2 ) ;
6030: LD_EXP 21
6034: PPUSH
6035: LD_STRING D1-JMM-2
6037: PPUSH
6038: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
6042: LD_EXP 39
6046: PPUSH
6047: LD_STRING D1-Pow-2
6049: PPUSH
6050: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
6054: LD_EXP 21
6058: PPUSH
6059: LD_STRING D1-JMM-3
6061: PPUSH
6062: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
6066: LD_EXP 39
6070: PPUSH
6071: LD_STRING D1-Pow-3
6073: PPUSH
6074: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
6078: LD_EXP 21
6082: PPUSH
6083: LD_STRING D1-JMM-4
6085: PPUSH
6086: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
6090: LD_EXP 39
6094: PPUSH
6095: LD_STRING D1-Pow-4
6097: PPUSH
6098: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
6102: LD_EXP 21
6106: PPUSH
6107: LD_STRING D1-JMM-5
6109: PPUSH
6110: CALL_OW 88
// async ;
6114: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
6115: LD_EXP 39
6119: PPUSH
6120: LD_STRING D1-Pow-5
6122: PPUSH
6123: CALL_OW 88
// if not dialogue_skipped then
6127: LD_OWVAR 59
6131: NOT
6132: IFFALSE 6141
// wait ( 0 0$3.6 ) ;
6134: LD_INT 126
6136: PPUSH
6137: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
6141: LD_INT 134
6143: PPUSH
6144: LD_INT 210
6146: PPUSH
6147: LD_INT 1
6149: PPUSH
6150: LD_INT 11
6152: NEG
6153: PPUSH
6154: CALL 84651 0 4
// if not dialogue_skipped then
6158: LD_OWVAR 59
6162: NOT
6163: IFFALSE 6182
// begin CenterOnXY ( 134 , 210 ) ;
6165: LD_INT 134
6167: PPUSH
6168: LD_INT 210
6170: PPUSH
6171: CALL_OW 84
// wait ( 0 0$2 ) ;
6175: LD_INT 70
6177: PPUSH
6178: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
6182: LD_INT 101
6184: PPUSH
6185: LD_INT 159
6187: PPUSH
6188: LD_INT 1
6190: PPUSH
6191: LD_INT 10
6193: NEG
6194: PPUSH
6195: CALL 84651 0 4
// if not dialogue_skipped then
6199: LD_OWVAR 59
6203: NOT
6204: IFFALSE 6223
// begin CenterOnXY ( 101 , 159 ) ;
6206: LD_INT 101
6208: PPUSH
6209: LD_INT 159
6211: PPUSH
6212: CALL_OW 84
// wait ( 0 0$2 ) ;
6216: LD_INT 70
6218: PPUSH
6219: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
6223: LD_EXP 39
6227: PPUSH
6228: CALL_OW 87
// if not dialogue_skipped then
6232: LD_OWVAR 59
6236: NOT
6237: IFFALSE 6246
// wait ( 0 0$6 ) ;
6239: LD_INT 210
6241: PPUSH
6242: CALL_OW 67
// sync ;
6246: SYNC
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
6247: LD_ADDR_VAR 0 6
6251: PUSH
6252: LD_INT 1
6254: PUSH
6255: LD_INT 2
6257: PUSH
6258: LD_INT 3
6260: PUSH
6261: LD_INT 4
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 6
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: ST_TO_ADDR
// if not dialogue_skipped then
6278: LD_OWVAR 59
6282: NOT
6283: IFFALSE 6437
// begin dec = SelectiveQuery ( Q1 , options ) ;
6285: LD_ADDR_VAR 0 7
6289: PUSH
6290: LD_STRING Q1
6292: PPUSH
6293: LD_VAR 0 6
6297: PPUSH
6298: CALL_OW 98
6302: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
6303: LD_ADDR_VAR 0 7
6307: PUSH
6308: LD_STRING Q1
6310: PPUSH
6311: LD_VAR 0 6
6315: PPUSH
6316: CALL_OW 98
6320: ST_TO_ADDR
// options = options diff dec ;
6321: LD_ADDR_VAR 0 6
6325: PUSH
6326: LD_VAR 0 6
6330: PUSH
6331: LD_VAR 0 7
6335: DIFF
6336: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
6337: LD_VAR 0 7
6341: PPUSH
6342: LD_VAR 0 6
6346: PPUSH
6347: CALL 7733 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
6351: LD_VAR 0 7
6355: PUSH
6356: LD_INT 5
6358: PUSH
6359: LD_INT 6
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: IN
6366: PUSH
6367: LD_VAR 0 6
6371: PUSH
6372: LD_INT 2
6374: EQUAL
6375: OR
6376: IFFALSE 6303
// if not ( dec in [ 5 , 6 ] ) then
6378: LD_VAR 0 7
6382: PUSH
6383: LD_INT 5
6385: PUSH
6386: LD_INT 6
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: IN
6393: NOT
6394: IFFALSE 6437
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
6396: LD_ADDR_VAR 0 7
6400: PUSH
6401: LD_STRING Q1a
6403: PPUSH
6404: LD_INT 1
6406: PUSH
6407: LD_INT 2
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PPUSH
6414: CALL_OW 98
6418: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
6419: LD_VAR 0 7
6423: PUSH
6424: LD_INT 4
6426: PLUS
6427: PPUSH
6428: LD_VAR 0 6
6432: PPUSH
6433: CALL 7733 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
6437: LD_INT 81
6439: PPUSH
6440: LD_INT 127
6442: PPUSH
6443: CALL_OW 84
// amount := 5 ;
6447: LD_ADDR_VAR 0 8
6451: PUSH
6452: LD_INT 5
6454: ST_TO_ADDR
// macmilan_squad := [ ] ;
6455: LD_ADDR_VAR 0 9
6459: PUSH
6460: EMPTY
6461: ST_TO_ADDR
// if vip < amount then
6462: LD_EXP 40
6466: PUSH
6467: LD_VAR 0 8
6471: LESS
6472: IFFALSE 6516
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
6474: LD_ADDR_VAR 0 5
6478: PUSH
6479: LD_EXP 40
6483: PUSH
6484: LD_INT 22
6486: PUSH
6487: LD_INT 4
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 21
6496: PUSH
6497: LD_INT 1
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: PPUSH
6508: CALL_OW 69
6512: UNION
6513: ST_TO_ADDR
6514: GO 6526
// tmp := vip ;
6516: LD_ADDR_VAR 0 5
6520: PUSH
6521: LD_EXP 40
6525: ST_TO_ADDR
// tmp := tmp diff Powell ;
6526: LD_ADDR_VAR 0 5
6530: PUSH
6531: LD_VAR 0 5
6535: PUSH
6536: LD_EXP 39
6540: DIFF
6541: ST_TO_ADDR
// if tmp < amount then
6542: LD_VAR 0 5
6546: PUSH
6547: LD_VAR 0 8
6551: LESS
6552: IFFALSE 6564
// amount := tmp ;
6554: LD_ADDR_VAR 0 8
6558: PUSH
6559: LD_VAR 0 5
6563: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
6564: LD_VAR 0 5
6568: PUSH
6569: LD_INT 1
6571: ARRAY
6572: PPUSH
6573: CALL_OW 257
6577: PUSH
6578: LD_INT 2
6580: NONEQUAL
6581: IFFALSE 6643
// begin if IsInUnit ( tmp [ 1 ] ) then
6583: LD_VAR 0 5
6587: PUSH
6588: LD_INT 1
6590: ARRAY
6591: PPUSH
6592: CALL_OW 310
6596: IFFALSE 6611
// ComExitBuilding ( tmp [ 1 ] ) ;
6598: LD_VAR 0 5
6602: PUSH
6603: LD_INT 1
6605: ARRAY
6606: PPUSH
6607: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
6611: LD_VAR 0 5
6615: PUSH
6616: LD_INT 1
6618: ARRAY
6619: PPUSH
6620: LD_INT 387
6622: PPUSH
6623: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
6627: LD_VAR 0 5
6631: PUSH
6632: LD_INT 1
6634: ARRAY
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
6643: LD_EXP 21
6647: PPUSH
6648: LD_INT 82
6650: PPUSH
6651: LD_INT 129
6653: PPUSH
6654: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
6658: LD_EXP 21
6662: PPUSH
6663: LD_EXP 39
6667: PPUSH
6668: CALL_OW 179
// if KappaStatus and JMMGirlStatus and JMMGirl then
6672: LD_EXP 2
6676: PUSH
6677: LD_EXP 6
6681: AND
6682: PUSH
6683: LD_EXP 7
6687: AND
6688: IFFALSE 6761
// begin ComMoveXY ( [ Joan , Lisa , Connie ] [ JMMGirl ] , 84 , 128 ) ;
6690: LD_EXP 22
6694: PUSH
6695: LD_EXP 24
6699: PUSH
6700: LD_EXP 36
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: PUSH
6710: LD_EXP 7
6714: ARRAY
6715: PPUSH
6716: LD_INT 84
6718: PPUSH
6719: LD_INT 128
6721: PPUSH
6722: CALL_OW 111
// AddComTurnUnit ( [ Joan , Lisa , Connie ] [ JMMGirl ] , JMM ) ;
6726: LD_EXP 22
6730: PUSH
6731: LD_EXP 24
6735: PUSH
6736: LD_EXP 36
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: LD_EXP 7
6750: ARRAY
6751: PPUSH
6752: LD_EXP 21
6756: PPUSH
6757: CALL_OW 179
// end ; for i = 1 to amount do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: DOUBLE
6767: LD_INT 1
6769: DEC
6770: ST_TO_ADDR
6771: LD_VAR 0 8
6775: PUSH
6776: FOR_TO
6777: IFFALSE 6945
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
6779: LD_ADDR_VAR 0 9
6783: PUSH
6784: LD_VAR 0 9
6788: PUSH
6789: LD_VAR 0 5
6793: PUSH
6794: LD_VAR 0 2
6798: ARRAY
6799: ADD
6800: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
6801: LD_VAR 0 5
6805: PUSH
6806: LD_VAR 0 2
6810: ARRAY
6811: PPUSH
6812: CALL_OW 310
6816: IFFALSE 6833
// AddComExitBuilding ( tmp [ i ] ) ;
6818: LD_VAR 0 5
6822: PUSH
6823: LD_VAR 0 2
6827: ARRAY
6828: PPUSH
6829: CALL_OW 182
// if i = 2 and JMMNewVeh then
6833: LD_VAR 0 2
6837: PUSH
6838: LD_INT 2
6840: EQUAL
6841: PUSH
6842: LD_EXP 37
6846: AND
6847: IFFALSE 6905
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
6849: LD_VAR 0 5
6853: PUSH
6854: LD_VAR 0 2
6858: ARRAY
6859: PPUSH
6860: LD_EXP 37
6864: PPUSH
6865: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
6869: LD_VAR 0 5
6873: PUSH
6874: LD_VAR 0 2
6878: ARRAY
6879: PPUSH
6880: LD_INT 86
6882: PPUSH
6883: LD_INT 133
6885: PPUSH
6886: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
6890: LD_VAR 0 5
6894: PUSH
6895: LD_VAR 0 2
6899: ARRAY
6900: PPUSH
6901: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
6905: LD_VAR 0 5
6909: PUSH
6910: LD_VAR 0 2
6914: ARRAY
6915: PPUSH
6916: LD_INT 9
6918: PPUSH
6919: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
6923: LD_VAR 0 5
6927: PUSH
6928: LD_VAR 0 2
6932: ARRAY
6933: PPUSH
6934: LD_EXP 21
6938: PPUSH
6939: CALL_OW 179
// end ;
6943: GO 6776
6945: POP
6946: POP
// if GirlNewVeh then
6947: LD_EXP 38
6951: IFFALSE 6965
// SetSide ( GirlNewVeh , 4 ) ;
6953: LD_EXP 38
6957: PPUSH
6958: LD_INT 4
6960: PPUSH
6961: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
6965: LD_INT 35
6967: PPUSH
6968: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
6972: LD_VAR 0 9
6976: PPUSH
6977: LD_INT 95
6979: PUSH
6980: LD_INT 10
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: PPUSH
6987: CALL_OW 72
6991: PUSH
6992: LD_INT 0
6994: EQUAL
6995: PUSH
6996: LD_EXP 21
7000: PPUSH
7001: LD_INT 10
7003: PPUSH
7004: CALL_OW 308
7008: NOT
7009: AND
7010: IFFALSE 6965
// wait ( 0 0$2 ) ;
7012: LD_INT 70
7014: PPUSH
7015: CALL_OW 67
// for i in macmilan_squad do
7019: LD_ADDR_VAR 0 2
7023: PUSH
7024: LD_VAR 0 9
7028: PUSH
7029: FOR_IN
7030: IFFALSE 7046
// SetSide ( i , 1 ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: LD_INT 1
7039: PPUSH
7040: CALL_OW 235
7044: GO 7029
7046: POP
7047: POP
// SetSide ( JMMNewVeh , 1 ) ;
7048: LD_EXP 37
7052: PPUSH
7053: LD_INT 1
7055: PPUSH
7056: CALL_OW 235
// Video ( false ) ;
7060: LD_INT 0
7062: PPUSH
7063: CALL 84737 0 1
// ChangeMissionObjectives ( M1 ) ;
7067: LD_STRING M1
7069: PPUSH
7070: CALL_OW 337
// SaveForQuickRestart ;
7074: CALL_OW 22
// missionStart := true ;
7078: LD_ADDR_EXP 13
7082: PUSH
7083: LD_INT 1
7085: ST_TO_ADDR
// missionStage := 2 ;
7086: LD_ADDR_EXP 15
7090: PUSH
7091: LD_INT 2
7093: ST_TO_ADDR
// wait ( 0 0$3 ) ;
7094: LD_INT 105
7096: PPUSH
7097: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
7101: LD_ADDR_VAR 0 5
7105: PUSH
7106: LD_VAR 0 5
7110: PUSH
7111: LD_INT 22
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PUSH
7121: LD_INT 21
7123: PUSH
7124: LD_INT 1
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PPUSH
7135: CALL_OW 69
7139: DIFF
7140: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
7141: LD_ADDR_EXP 71
7145: PUSH
7146: LD_EXP 71
7150: PPUSH
7151: LD_INT 4
7153: PPUSH
7154: LD_INT 22
7156: PUSH
7157: LD_INT 4
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 23
7166: PUSH
7167: LD_INT 1
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 3
7176: PUSH
7177: LD_INT 21
7179: PUSH
7180: LD_INT 2
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: EMPTY
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: PPUSH
7196: CALL_OW 69
7200: PUSH
7201: LD_EXP 39
7205: DIFF
7206: PPUSH
7207: CALL_OW 1
7211: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
7212: LD_ADDR_VAR 0 4
7216: PUSH
7217: LD_INT 22
7219: PUSH
7220: LD_INT 4
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PUSH
7227: LD_INT 34
7229: PUSH
7230: LD_INT 12
7232: PUSH
7233: EMPTY
7234: LIST
7235: LIST
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: PUSH
7246: LD_INT 1
7248: ARRAY
7249: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
7250: LD_VAR 0 5
7254: PUSH
7255: LD_INT 1
7257: ARRAY
7258: PPUSH
7259: CALL_OW 310
7263: IFFALSE 7278
// ComExitBuilding ( tmp [ 1 ] ) ;
7265: LD_VAR 0 5
7269: PUSH
7270: LD_INT 1
7272: ARRAY
7273: PPUSH
7274: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
7278: LD_VAR 0 5
7282: PUSH
7283: LD_INT 1
7285: ARRAY
7286: PPUSH
7287: LD_VAR 0 4
7291: PPUSH
7292: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
7296: LD_VAR 0 5
7300: PUSH
7301: LD_INT 1
7303: ARRAY
7304: PPUSH
7305: LD_INT 80
7307: PPUSH
7308: LD_INT 136
7310: PPUSH
7311: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
7315: LD_VAR 0 5
7319: PUSH
7320: LD_INT 1
7322: ARRAY
7323: PPUSH
7324: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
7328: LD_VAR 0 5
7332: PUSH
7333: LD_INT 1
7335: ARRAY
7336: PPUSH
7337: LD_INT 59
7339: PPUSH
7340: LD_INT 112
7342: PPUSH
7343: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
7347: LD_VAR 0 5
7351: PUSH
7352: LD_INT 1
7354: ARRAY
7355: PPUSH
7356: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
7360: LD_EXP 24
7364: PUSH
7365: LD_EXP 40
7369: IN
7370: PUSH
7371: LD_EXP 24
7375: PPUSH
7376: CALL_OW 255
7380: PUSH
7381: LD_INT 1
7383: EQUAL
7384: AND
7385: IFFALSE 7401
// Say ( Lisa , D3nW-Lisa-1 ) else
7387: LD_EXP 24
7391: PPUSH
7392: LD_STRING D3nW-Lisa-1
7394: PPUSH
7395: CALL_OW 88
7399: GO 7645
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
7401: LD_EXP 27
7405: PUSH
7406: LD_EXP 40
7410: IN
7411: PUSH
7412: LD_EXP 27
7416: PPUSH
7417: CALL_OW 255
7421: PUSH
7422: LD_INT 1
7424: EQUAL
7425: AND
7426: IFFALSE 7442
// Say ( Cyrus , D3nW-Cyrus-1 ) else
7428: LD_EXP 27
7432: PPUSH
7433: LD_STRING D3nW-Cyrus-1
7435: PPUSH
7436: CALL_OW 88
7440: GO 7645
// if Bobby in vip and GetSide ( Bobby ) = 1 then
7442: LD_EXP 26
7446: PUSH
7447: LD_EXP 40
7451: IN
7452: PUSH
7453: LD_EXP 26
7457: PPUSH
7458: CALL_OW 255
7462: PUSH
7463: LD_INT 1
7465: EQUAL
7466: AND
7467: IFFALSE 7483
// Say ( Bobby , D3nW-Bobby-1 ) else
7469: LD_EXP 26
7473: PPUSH
7474: LD_STRING D3nW-Bobby-1
7476: PPUSH
7477: CALL_OW 88
7481: GO 7645
// if Gary in vip and GetSide ( Gary ) = 1 then
7483: LD_EXP 33
7487: PUSH
7488: LD_EXP 40
7492: IN
7493: PUSH
7494: LD_EXP 33
7498: PPUSH
7499: CALL_OW 255
7503: PUSH
7504: LD_INT 1
7506: EQUAL
7507: AND
7508: IFFALSE 7524
// Say ( Gary , D3nW-Gary-1 ) else
7510: LD_EXP 33
7514: PPUSH
7515: LD_STRING D3nW-Gary-1
7517: PPUSH
7518: CALL_OW 88
7522: GO 7645
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
7524: LD_EXP 25
7528: PUSH
7529: LD_EXP 40
7533: IN
7534: PUSH
7535: LD_EXP 25
7539: PPUSH
7540: CALL_OW 255
7544: PUSH
7545: LD_INT 1
7547: EQUAL
7548: AND
7549: IFFALSE 7565
// Say ( Donaldson , D3nW-Don-1 ) else
7551: LD_EXP 25
7555: PPUSH
7556: LD_STRING D3nW-Don-1
7558: PPUSH
7559: CALL_OW 88
7563: GO 7645
// if Cornel in vip and GetSide ( Cornel ) = 1 then
7565: LD_EXP 32
7569: PUSH
7570: LD_EXP 40
7574: IN
7575: PUSH
7576: LD_EXP 32
7580: PPUSH
7581: CALL_OW 255
7585: PUSH
7586: LD_INT 1
7588: EQUAL
7589: AND
7590: IFFALSE 7606
// Say ( Cornel , D3nW-Corn-1 ) else
7592: LD_EXP 32
7596: PPUSH
7597: LD_STRING D3nW-Corn-1
7599: PPUSH
7600: CALL_OW 88
7604: GO 7645
// if Frank in vip and GetSide ( Frank ) = 1 then
7606: LD_EXP 34
7610: PUSH
7611: LD_EXP 40
7615: IN
7616: PUSH
7617: LD_EXP 34
7621: PPUSH
7622: CALL_OW 255
7626: PUSH
7627: LD_INT 1
7629: EQUAL
7630: AND
7631: IFFALSE 7645
// Say ( Frank , D3nW-Frank-1 ) ;
7633: LD_EXP 34
7637: PPUSH
7638: LD_STRING D3nW-Frank-1
7640: PPUSH
7641: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
7645: LD_EXP 21
7649: PPUSH
7650: LD_STRING D3nW-JMM-1
7652: PPUSH
7653: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
7657: LD_EXP 21
7661: PPUSH
7662: LD_STRING D3nW-JMM-1a
7664: PPUSH
7665: CALL_OW 88
// t := 0 0$00 ;
7669: LD_ADDR_VAR 0 3
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7677: LD_INT 35
7679: PPUSH
7680: CALL_OW 67
// t := t + 0 0$1 ;
7684: LD_ADDR_VAR 0 3
7688: PUSH
7689: LD_VAR 0 3
7693: PUSH
7694: LD_INT 35
7696: PLUS
7697: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
7698: LD_INT 59
7700: PPUSH
7701: LD_INT 112
7703: PPUSH
7704: CALL_OW 428
7708: PUSH
7709: LD_VAR 0 3
7713: PUSH
7714: LD_INT 2100
7716: GREATER
7717: OR
7718: IFFALSE 7677
// activeAttacks := true ;
7720: LD_ADDR_EXP 16
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// end ;
7728: LD_VAR 0 1
7732: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
7733: LD_INT 0
7735: PPUSH
// case question of 1 :
7736: LD_VAR 0 1
7740: PUSH
7741: LD_INT 1
7743: DOUBLE
7744: EQUAL
7745: IFTRUE 7749
7747: GO 7800
7749: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
7750: LD_EXP 21
7754: PPUSH
7755: LD_STRING D2Mot-JMM-1
7757: PPUSH
7758: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
7762: LD_EXP 39
7766: PPUSH
7767: LD_STRING D2Mot-Pow-1
7769: PPUSH
7770: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
7774: LD_EXP 21
7778: PPUSH
7779: LD_STRING D2Mot-JMM-2
7781: PPUSH
7782: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
7786: LD_EXP 39
7790: PPUSH
7791: LD_STRING D2Mot-Pow-2
7793: PPUSH
7794: CALL_OW 88
// end ; 2 :
7798: GO 8143
7800: LD_INT 2
7802: DOUBLE
7803: EQUAL
7804: IFTRUE 7808
7806: GO 7884
7808: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
7809: LD_EXP 21
7813: PPUSH
7814: LD_STRING D2Rus-JMM-1
7816: PPUSH
7817: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
7821: LD_EXP 39
7825: PPUSH
7826: LD_STRING D2Rus-Pow-1
7828: PPUSH
7829: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
7833: LD_EXP 21
7837: PPUSH
7838: LD_STRING D2Rus-JMM-2
7840: PPUSH
7841: CALL_OW 88
// if not ( 3 in list_of_q ) then
7845: LD_INT 3
7847: PUSH
7848: LD_VAR 0 2
7852: IN
7853: NOT
7854: IFFALSE 7870
// Say ( Powell , D2Rus-Pow-2 ) else
7856: LD_EXP 39
7860: PPUSH
7861: LD_STRING D2Rus-Pow-2
7863: PPUSH
7864: CALL_OW 88
7868: GO 7882
// Say ( Powell , D2Rus-Pow-2a ) ;
7870: LD_EXP 39
7874: PPUSH
7875: LD_STRING D2Rus-Pow-2a
7877: PPUSH
7878: CALL_OW 88
// end ; 3 :
7882: GO 8143
7884: LD_INT 3
7886: DOUBLE
7887: EQUAL
7888: IFTRUE 7892
7890: GO 7977
7892: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
7893: LD_EXP 21
7897: PPUSH
7898: LD_STRING D2Leg-JMM-1
7900: PPUSH
7901: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
7905: LD_EXP 39
7909: PPUSH
7910: LD_STRING D2Leg-Pow-1
7912: PPUSH
7913: CALL_OW 88
// if 2 in list_of_q then
7917: LD_INT 2
7919: PUSH
7920: LD_VAR 0 2
7924: IN
7925: IFFALSE 7951
// begin Say ( JMM , D2Leg-JMM-2 ) ;
7927: LD_EXP 21
7931: PPUSH
7932: LD_STRING D2Leg-JMM-2
7934: PPUSH
7935: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
7939: LD_EXP 39
7943: PPUSH
7944: LD_STRING D2Leg-Pow-2
7946: PPUSH
7947: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
7951: LD_EXP 21
7955: PPUSH
7956: LD_STRING D2Leg-JMM-3
7958: PPUSH
7959: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
7963: LD_EXP 39
7967: PPUSH
7968: LD_STRING D2Leg-Pow-3
7970: PPUSH
7971: CALL_OW 88
// end ; 4 :
7975: GO 8143
7977: LD_INT 4
7979: DOUBLE
7980: EQUAL
7981: IFTRUE 7985
7983: GO 8060
7985: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
7986: LD_EXP 21
7990: PPUSH
7991: LD_STRING D2Ar-JMM-1
7993: PPUSH
7994: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
7998: LD_EXP 39
8002: PPUSH
8003: LD_STRING D2Ar-Pow-1
8005: PPUSH
8006: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
8010: LD_EXP 21
8014: PPUSH
8015: LD_STRING D2Ar-JMM-2
8017: PPUSH
8018: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
8022: LD_EXP 39
8026: PPUSH
8027: LD_STRING D2Ar-Pow-2
8029: PPUSH
8030: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
8034: LD_EXP 21
8038: PPUSH
8039: LD_STRING D2Ar-JMM-3
8041: PPUSH
8042: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
8046: LD_EXP 39
8050: PPUSH
8051: LD_STRING D2Ar-Pow-3
8053: PPUSH
8054: CALL_OW 88
// end ; 5 :
8058: GO 8143
8060: LD_INT 5
8062: DOUBLE
8063: EQUAL
8064: IFTRUE 8068
8066: GO 8083
8068: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
8069: LD_EXP 21
8073: PPUSH
8074: LD_STRING D2Conf-JMM-1
8076: PPUSH
8077: CALL_OW 88
8081: GO 8143
8083: LD_INT 6
8085: DOUBLE
8086: EQUAL
8087: IFTRUE 8091
8089: GO 8142
8091: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
8092: LD_EXP 21
8096: PPUSH
8097: LD_STRING D2Com-JMM-1
8099: PPUSH
8100: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
8104: LD_EXP 39
8108: PPUSH
8109: LD_STRING D2Com-Pow-1
8111: PPUSH
8112: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
8116: LD_EXP 21
8120: PPUSH
8121: LD_STRING D2Com-JMM-2
8123: PPUSH
8124: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
8128: LD_EXP 39
8132: PPUSH
8133: LD_STRING D2Com-Pow-2
8135: PPUSH
8136: CALL_OW 88
// end ; end ;
8140: GO 8143
8142: POP
// end ;
8143: LD_VAR 0 3
8147: RET
// every 0 0$5 trigger missionStart do var tmp ;
8148: LD_EXP 13
8152: IFFALSE 8435
8154: GO 8156
8156: DISABLE
8157: LD_INT 0
8159: PPUSH
// begin repeat wait ( 0 0$1 ) ;
8160: LD_INT 35
8162: PPUSH
8163: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
8167: LD_INT 15
8169: PPUSH
8170: LD_INT 22
8172: PUSH
8173: LD_INT 1
8175: PUSH
8176: EMPTY
8177: LIST
8178: LIST
8179: PPUSH
8180: CALL_OW 70
8184: PUSH
8185: LD_EXP 15
8189: PUSH
8190: LD_INT 2
8192: PUSH
8193: LD_INT 3
8195: PUSH
8196: LD_INT 4
8198: PUSH
8199: LD_INT 5
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: LIST
8206: LIST
8207: IN
8208: AND
8209: IFFALSE 8425
// begin powellAnger := powellAnger + 1 ;
8211: LD_ADDR_EXP 17
8215: PUSH
8216: LD_EXP 17
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ST_TO_ADDR
// Video ( true ) ;
8225: LD_INT 1
8227: PPUSH
8228: CALL 84737 0 1
// CenterNowOnUnits ( tmp ) ;
8232: LD_VAR 0 1
8236: PPUSH
8237: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
8241: LD_INT 15
8243: PPUSH
8244: LD_INT 22
8246: PUSH
8247: LD_INT 1
8249: PUSH
8250: EMPTY
8251: LIST
8252: LIST
8253: PPUSH
8254: CALL_OW 70
8258: PPUSH
8259: LD_INT 86
8261: PPUSH
8262: LD_INT 133
8264: PPUSH
8265: CALL_OW 111
// async ;
8269: ASYNC
// case powellAnger of 1 :
8270: LD_EXP 17
8274: PUSH
8275: LD_INT 1
8277: DOUBLE
8278: EQUAL
8279: IFTRUE 8283
8281: GO 8298
8283: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
8284: LD_EXP 39
8288: PPUSH
8289: LD_STRING DBack1-Pow-1
8291: PPUSH
8292: CALL_OW 88
8296: GO 8345
8298: LD_INT 2
8300: DOUBLE
8301: EQUAL
8302: IFTRUE 8306
8304: GO 8321
8306: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
8307: LD_EXP 39
8311: PPUSH
8312: LD_STRING DBack2-Pow-1
8314: PPUSH
8315: CALL_OW 88
8319: GO 8345
8321: LD_INT 3
8323: DOUBLE
8324: EQUAL
8325: IFTRUE 8329
8327: GO 8344
8329: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
8330: LD_EXP 39
8334: PPUSH
8335: LD_STRING DBack3-Pow-1
8337: PPUSH
8338: CALL_OW 88
8342: GO 8345
8344: POP
// sync ;
8345: SYNC
// repeat wait ( 0 0$1 ) ;
8346: LD_INT 35
8348: PPUSH
8349: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
8353: LD_INT 15
8355: PPUSH
8356: LD_INT 22
8358: PUSH
8359: LD_INT 1
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PPUSH
8366: CALL_OW 70
8370: PPUSH
8371: LD_INT 86
8373: PPUSH
8374: LD_INT 133
8376: PPUSH
8377: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
8381: LD_INT 15
8383: PPUSH
8384: LD_INT 22
8386: PUSH
8387: LD_INT 1
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: PPUSH
8394: CALL_OW 70
8398: NOT
8399: IFFALSE 8346
// if powellAnger >= 3 then
8401: LD_EXP 17
8405: PUSH
8406: LD_INT 3
8408: GREATEREQUAL
8409: IFFALSE 8418
// YouLost ( Dismissed ) ;
8411: LD_STRING Dismissed
8413: PPUSH
8414: CALL_OW 104
// Video ( false ) ;
8418: LD_INT 0
8420: PPUSH
8421: CALL 84737 0 1
// end ; until missionStage > 5 ;
8425: LD_EXP 15
8429: PUSH
8430: LD_INT 5
8432: GREATER
8433: IFFALSE 8160
// end ;
8435: PPOPN 1
8437: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm ;
8438: LD_EXP 13
8442: PUSH
8443: LD_INT 22
8445: PUSH
8446: LD_INT 4
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 21
8455: PUSH
8456: LD_INT 2
8458: PUSH
8459: EMPTY
8460: LIST
8461: LIST
8462: PUSH
8463: EMPTY
8464: LIST
8465: LIST
8466: PPUSH
8467: CALL_OW 69
8471: PUSH
8472: LD_INT 4
8474: GREATEREQUAL
8475: AND
8476: PUSH
8477: LD_EXP 15
8481: PUSH
8482: LD_INT 2
8484: EQUAL
8485: AND
8486: IFFALSE 9845
8488: GO 8490
8490: DISABLE
8491: LD_INT 0
8493: PPUSH
8494: PPUSH
8495: PPUSH
8496: PPUSH
8497: PPUSH
// begin missionStage := 3 ;
8498: LD_ADDR_EXP 15
8502: PUSH
8503: LD_INT 3
8505: ST_TO_ADDR
// retreat := false ;
8506: LD_ADDR_VAR 0 4
8510: PUSH
8511: LD_INT 0
8513: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
8514: LD_ADDR_VAR 0 5
8518: PUSH
8519: LD_INT 22
8521: PUSH
8522: LD_INT 4
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 30
8531: PUSH
8532: LD_INT 4
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: PUSH
8548: LD_INT 1
8550: ARRAY
8551: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8552: LD_INT 35
8554: PPUSH
8555: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
8559: LD_EXP 90
8563: PUSH
8564: LD_INT 4
8566: ARRAY
8567: PUSH
8568: LD_INT 4
8570: GREATEREQUAL
8571: IFFALSE 8552
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff ( Powell ^ vip ) ;
8573: LD_ADDR_VAR 0 2
8577: PUSH
8578: LD_INT 22
8580: PUSH
8581: LD_INT 4
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: PUSH
8588: LD_INT 2
8590: PUSH
8591: LD_INT 25
8593: PUSH
8594: LD_INT 1
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: PUSH
8601: LD_INT 25
8603: PUSH
8604: LD_INT 2
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 3
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: LD_INT 25
8623: PUSH
8624: LD_INT 4
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: LIST
8635: LIST
8636: LIST
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PPUSH
8642: CALL_OW 69
8646: PUSH
8647: LD_EXP 39
8651: PUSH
8652: LD_EXP 40
8656: ADD
8657: DIFF
8658: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
8659: LD_ADDR_VAR 0 3
8663: PUSH
8664: LD_VAR 0 2
8668: PPUSH
8669: LD_INT 26
8671: PUSH
8672: LD_INT 1
8674: PUSH
8675: EMPTY
8676: LIST
8677: LIST
8678: PPUSH
8679: CALL_OW 72
8683: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
8684: LD_ADDR_VAR 0 2
8688: PUSH
8689: LD_VAR 0 2
8693: PUSH
8694: LD_VAR 0 3
8698: DIFF
8699: ST_TO_ADDR
// for i = 1 to 4 do
8700: LD_ADDR_VAR 0 1
8704: PUSH
8705: DOUBLE
8706: LD_INT 1
8708: DEC
8709: ST_TO_ADDR
8710: LD_INT 4
8712: PUSH
8713: FOR_TO
8714: IFFALSE 8868
// begin if tmp2 then
8716: LD_VAR 0 3
8720: IFFALSE 8795
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ 1 ] ) ;
8722: LD_ADDR_EXP 18
8726: PUSH
8727: LD_EXP 18
8731: PPUSH
8732: LD_INT 1
8734: PPUSH
8735: LD_EXP 18
8739: PUSH
8740: LD_INT 1
8742: ARRAY
8743: PUSH
8744: LD_VAR 0 3
8748: PUSH
8749: LD_INT 1
8751: ARRAY
8752: ADD
8753: PPUSH
8754: CALL_OW 1
8758: ST_TO_ADDR
// SetTag ( tmp2 [ 1 ] , 1 ) ;
8759: LD_VAR 0 3
8763: PUSH
8764: LD_INT 1
8766: ARRAY
8767: PPUSH
8768: LD_INT 1
8770: PPUSH
8771: CALL_OW 109
// tmp2 := Delete ( tmp2 , 1 ) ;
8775: LD_ADDR_VAR 0 3
8779: PUSH
8780: LD_VAR 0 3
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: CALL_OW 3
8792: ST_TO_ADDR
// end else
8793: GO 8866
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ 1 ] ) ;
8795: LD_ADDR_EXP 18
8799: PUSH
8800: LD_EXP 18
8804: PPUSH
8805: LD_INT 1
8807: PPUSH
8808: LD_EXP 18
8812: PUSH
8813: LD_INT 1
8815: ARRAY
8816: PUSH
8817: LD_VAR 0 2
8821: PUSH
8822: LD_INT 1
8824: ARRAY
8825: ADD
8826: PPUSH
8827: CALL_OW 1
8831: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 1 ) ;
8832: LD_VAR 0 2
8836: PUSH
8837: LD_INT 1
8839: ARRAY
8840: PPUSH
8841: LD_INT 1
8843: PPUSH
8844: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
8848: LD_ADDR_VAR 0 2
8852: PUSH
8853: LD_VAR 0 2
8857: PPUSH
8858: LD_INT 1
8860: PPUSH
8861: CALL_OW 3
8865: ST_TO_ADDR
// end ; end ;
8866: GO 8713
8868: POP
8869: POP
// if tmp2 then
8870: LD_VAR 0 3
8874: IFFALSE 8892
// tmp := tmp union tmp2 ;
8876: LD_ADDR_VAR 0 2
8880: PUSH
8881: LD_VAR 0 2
8885: PUSH
8886: LD_VAR 0 3
8890: UNION
8891: ST_TO_ADDR
// for i = 1 to 4 do
8892: LD_ADDR_VAR 0 1
8896: PUSH
8897: DOUBLE
8898: LD_INT 1
8900: DEC
8901: ST_TO_ADDR
8902: LD_INT 4
8904: PUSH
8905: FOR_TO
8906: IFFALSE 8949
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ i ] ) ;
8908: LD_ADDR_EXP 18
8912: PUSH
8913: LD_EXP 18
8917: PPUSH
8918: LD_INT 2
8920: PPUSH
8921: LD_EXP 18
8925: PUSH
8926: LD_INT 2
8928: ARRAY
8929: PUSH
8930: LD_VAR 0 2
8934: PUSH
8935: LD_VAR 0 1
8939: ARRAY
8940: ADD
8941: PPUSH
8942: CALL_OW 1
8946: ST_TO_ADDR
8947: GO 8905
8949: POP
8950: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
8951: LD_ADDR_EXP 71
8955: PUSH
8956: LD_EXP 71
8960: PPUSH
8961: LD_INT 4
8963: PPUSH
8964: LD_EXP 71
8968: PUSH
8969: LD_INT 4
8971: ARRAY
8972: PUSH
8973: LD_EXP 18
8977: PUSH
8978: LD_INT 1
8980: ARRAY
8981: DIFF
8982: PPUSH
8983: CALL_OW 1
8987: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
8988: LD_ADDR_VAR 0 1
8992: PUSH
8993: LD_EXP 18
8997: PUSH
8998: LD_INT 1
9000: ARRAY
9001: PUSH
9002: FOR_IN
9003: IFFALSE 9106
// begin if IsInUnit ( i ) then
9005: LD_VAR 0 1
9009: PPUSH
9010: CALL_OW 310
9014: IFFALSE 9025
// ComExitBuilding ( i ) ;
9016: LD_VAR 0 1
9020: PPUSH
9021: CALL_OW 122
// if GetClass ( i ) <> 1 then
9025: LD_VAR 0 1
9029: PPUSH
9030: CALL_OW 257
9034: PUSH
9035: LD_INT 1
9037: NONEQUAL
9038: IFFALSE 9075
// begin AddComEnterUnit ( i , arm ) ;
9040: LD_VAR 0 1
9044: PPUSH
9045: LD_VAR 0 5
9049: PPUSH
9050: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
9054: LD_VAR 0 1
9058: PPUSH
9059: LD_INT 1
9061: PPUSH
9062: CALL_OW 183
// AddComExitBuilding ( i ) ;
9066: LD_VAR 0 1
9070: PPUSH
9071: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
9075: LD_VAR 0 1
9079: PPUSH
9080: LD_INT 60
9082: PPUSH
9083: LD_INT 94
9085: PPUSH
9086: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
9090: LD_VAR 0 1
9094: PPUSH
9095: LD_EXP 39
9099: PPUSH
9100: CALL_OW 179
// end ;
9104: GO 9002
9106: POP
9107: POP
// wait ( 0 0$15 ) ;
9108: LD_INT 525
9110: PPUSH
9111: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
9115: LD_EXP 39
9119: PPUSH
9120: LD_STRING D4-Pow-1
9122: PPUSH
9123: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
9127: LD_ADDR_VAR 0 2
9131: PUSH
9132: LD_EXP 18
9136: PUSH
9137: LD_INT 1
9139: ARRAY
9140: PPUSH
9141: LD_INT 26
9143: PUSH
9144: LD_INT 1
9146: PUSH
9147: EMPTY
9148: LIST
9149: LIST
9150: PPUSH
9151: CALL_OW 72
9155: ST_TO_ADDR
// if tmp then
9156: LD_VAR 0 2
9160: IFFALSE 9178
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
9162: LD_VAR 0 2
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_STRING D4-Sol1-1
9173: PPUSH
9174: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
9178: LD_EXP 39
9182: PPUSH
9183: LD_STRING D4-Pow-2
9185: PPUSH
9186: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
9190: LD_ADDR_VAR 0 1
9194: PUSH
9195: DOUBLE
9196: LD_INT 1
9198: DEC
9199: ST_TO_ADDR
9200: LD_EXP 18
9204: PUSH
9205: LD_INT 1
9207: ARRAY
9208: PUSH
9209: FOR_TO
9210: IFFALSE 9303
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
9212: LD_EXP 18
9216: PUSH
9217: LD_INT 1
9219: ARRAY
9220: PUSH
9221: LD_VAR 0 1
9225: ARRAY
9226: PPUSH
9227: LD_EXP 90
9231: PUSH
9232: LD_INT 4
9234: ARRAY
9235: PUSH
9236: LD_INT 1
9238: ARRAY
9239: PPUSH
9240: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
9244: LD_ADDR_EXP 90
9248: PUSH
9249: LD_EXP 90
9253: PPUSH
9254: LD_INT 4
9256: PPUSH
9257: LD_EXP 90
9261: PUSH
9262: LD_INT 4
9264: ARRAY
9265: PPUSH
9266: LD_INT 1
9268: PPUSH
9269: CALL_OW 3
9273: PPUSH
9274: CALL_OW 1
9278: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
9279: LD_INT 8
9281: PPUSH
9282: LD_EXP 18
9286: PUSH
9287: LD_INT 1
9289: ARRAY
9290: PUSH
9291: LD_VAR 0 1
9295: ARRAY
9296: PPUSH
9297: CALL_OW 471
// end ;
9301: GO 9209
9303: POP
9304: POP
// repeat wait ( 0 0$1 ) ;
9305: LD_INT 35
9307: PPUSH
9308: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
9312: LD_EXP 18
9316: PUSH
9317: LD_INT 1
9319: ARRAY
9320: PPUSH
9321: LD_INT 55
9323: PUSH
9324: EMPTY
9325: LIST
9326: PPUSH
9327: CALL_OW 72
9331: PUSH
9332: LD_INT 4
9334: GREATEREQUAL
9335: IFFALSE 9305
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
9337: LD_EXP 18
9341: PUSH
9342: LD_INT 1
9344: ARRAY
9345: PPUSH
9346: LD_INT 69
9348: PPUSH
9349: LD_INT 94
9351: PPUSH
9352: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
9356: LD_EXP 18
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: LD_INT 82
9367: PPUSH
9368: LD_INT 83
9370: PPUSH
9371: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
9375: LD_EXP 18
9379: PUSH
9380: LD_INT 1
9382: ARRAY
9383: PPUSH
9384: LD_INT 77
9386: PPUSH
9387: LD_INT 69
9389: PPUSH
9390: CALL_OW 174
// repeat wait ( 3 ) ;
9394: LD_INT 3
9396: PPUSH
9397: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
9401: LD_ADDR_VAR 0 1
9405: PUSH
9406: LD_EXP 18
9410: PUSH
9411: LD_INT 1
9413: ARRAY
9414: PUSH
9415: FOR_IN
9416: IFFALSE 9525
// begin if GetLives ( i ) < 990 then
9418: LD_VAR 0 1
9422: PPUSH
9423: CALL_OW 256
9427: PUSH
9428: LD_INT 990
9430: LESS
9431: IFFALSE 9445
// SetLives ( i , 1000 ) ;
9433: LD_VAR 0 1
9437: PPUSH
9438: LD_INT 1000
9440: PPUSH
9441: CALL_OW 234
// if not IsInUnit ( i ) then
9445: LD_VAR 0 1
9449: PPUSH
9450: CALL_OW 310
9454: NOT
9455: IFFALSE 9523
// begin if not retreat and GetSex ( i ) = sex_male then
9457: LD_VAR 0 4
9461: NOT
9462: PUSH
9463: LD_VAR 0 1
9467: PPUSH
9468: CALL_OW 258
9472: PUSH
9473: LD_INT 1
9475: EQUAL
9476: AND
9477: IFFALSE 9523
// begin retreat := true ;
9479: LD_ADDR_VAR 0 4
9483: PUSH
9484: LD_INT 1
9486: ST_TO_ADDR
// SetTag ( i , 2 ) ;
9487: LD_VAR 0 1
9491: PPUSH
9492: LD_INT 2
9494: PPUSH
9495: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
9499: LD_VAR 0 1
9503: PPUSH
9504: LD_STRING D4a-Sol1-1
9506: PPUSH
9507: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
9511: LD_EXP 39
9515: PPUSH
9516: LD_STRING D4a-Pow-1
9518: PPUSH
9519: CALL_OW 88
// end ; end ; end ;
9523: GO 9415
9525: POP
9526: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
9527: LD_EXP 18
9531: PUSH
9532: LD_INT 1
9534: ARRAY
9535: PPUSH
9536: LD_INT 95
9538: PUSH
9539: LD_INT 10
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 55
9551: PUSH
9552: EMPTY
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PPUSH
9563: CALL_OW 72
9567: PUSH
9568: LD_INT 4
9570: GREATEREQUAL
9571: IFFALSE 9394
// for i in powellSquadAttack [ 1 ] do
9573: LD_ADDR_VAR 0 1
9577: PUSH
9578: LD_EXP 18
9582: PUSH
9583: LD_INT 1
9585: ARRAY
9586: PUSH
9587: FOR_IN
9588: IFFALSE 9724
// begin if GetTag ( i ) = 2 then
9590: LD_VAR 0 1
9594: PPUSH
9595: CALL_OW 110
9599: PUSH
9600: LD_INT 2
9602: EQUAL
9603: IFFALSE 9665
// begin ComMoveXY ( i , 60 , 94 ) ;
9605: LD_VAR 0 1
9609: PPUSH
9610: LD_INT 60
9612: PPUSH
9613: LD_INT 94
9615: PPUSH
9616: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
9620: LD_VAR 0 1
9624: PPUSH
9625: LD_EXP 39
9629: PPUSH
9630: CALL_OW 179
// wait ( 0 0$3 ) ;
9634: LD_INT 105
9636: PPUSH
9637: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
9641: LD_VAR 0 1
9645: PPUSH
9646: LD_STRING D4a-Sol1-2
9648: PPUSH
9649: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
9653: LD_EXP 39
9657: PPUSH
9658: LD_STRING D4a-Pow-2
9660: PPUSH
9661: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
9665: LD_VAR 0 1
9669: PPUSH
9670: LD_INT 0
9672: PPUSH
9673: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
9677: LD_ADDR_EXP 71
9681: PUSH
9682: LD_EXP 71
9686: PPUSH
9687: LD_INT 4
9689: PPUSH
9690: LD_EXP 71
9694: PUSH
9695: LD_INT 4
9697: ARRAY
9698: PUSH
9699: LD_VAR 0 1
9703: UNION
9704: PPUSH
9705: CALL_OW 1
9709: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
9710: LD_INT 8
9712: PPUSH
9713: LD_VAR 0 1
9717: PPUSH
9718: CALL_OW 472
// end ;
9722: GO 9587
9724: POP
9725: POP
// wait ( 1 1$00 ) ;
9726: LD_INT 2100
9728: PPUSH
9729: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
9733: LD_INT 4
9735: PPUSH
9736: LD_INT 3
9738: PUSH
9739: LD_INT 1
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: LD_INT 5
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: PUSH
9754: LD_INT 4
9756: PUSH
9757: LD_INT 1
9759: PUSH
9760: LD_INT 1
9762: PUSH
9763: LD_INT 6
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 4
9774: PUSH
9775: LD_INT 1
9777: PUSH
9778: LD_INT 1
9780: PUSH
9781: LD_INT 7
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: LD_INT 3
9792: PUSH
9793: LD_INT 1
9795: PUSH
9796: LD_INT 1
9798: PUSH
9799: LD_INT 7
9801: PUSH
9802: EMPTY
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: PUSH
9808: LD_INT 3
9810: PUSH
9811: LD_INT 1
9813: PUSH
9814: LD_INT 1
9816: PUSH
9817: LD_INT 5
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: PUSH
9826: EMPTY
9827: LIST
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL 36677 0 2
// missionStage := 4 ;
9837: LD_ADDR_EXP 15
9841: PUSH
9842: LD_INT 4
9844: ST_TO_ADDR
// end ;
9845: PPOPN 5
9847: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
9848: LD_EXP 15
9852: PUSH
9853: LD_INT 4
9855: EQUAL
9856: PUSH
9857: LD_INT 22
9859: PUSH
9860: LD_INT 4
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PUSH
9867: LD_INT 21
9869: PUSH
9870: LD_INT 2
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PPUSH
9881: CALL_OW 69
9885: PUSH
9886: LD_INT 5
9888: GREATEREQUAL
9889: AND
9890: IFFALSE 13575
9892: GO 9894
9894: DISABLE
9895: LD_INT 0
9897: PPUSH
9898: PPUSH
9899: PPUSH
9900: PPUSH
9901: PPUSH
9902: PPUSH
9903: PPUSH
9904: PPUSH
9905: PPUSH
9906: PPUSH
9907: PPUSH
9908: PPUSH
9909: PPUSH
// begin missionStage := 5 ;
9910: LD_ADDR_EXP 15
9914: PUSH
9915: LD_INT 5
9917: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
9918: LD_ADDR_VAR 0 10
9922: PUSH
9923: LD_INT 22
9925: PUSH
9926: LD_INT 4
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: LD_INT 30
9935: PUSH
9936: LD_INT 4
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PPUSH
9947: CALL_OW 69
9951: PUSH
9952: LD_INT 1
9954: ARRAY
9955: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
9956: LD_ADDR_VAR 0 6
9960: PUSH
9961: LD_INT 22
9963: PUSH
9964: LD_INT 4
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PUSH
9971: LD_INT 21
9973: PUSH
9974: LD_INT 1
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 25
9986: PUSH
9987: LD_INT 16
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: PUSH
9998: LD_INT 3
10000: PUSH
10001: LD_INT 25
10003: PUSH
10004: LD_INT 12
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: PUSH
10026: LD_EXP 39
10030: DIFF
10031: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
10032: LD_ADDR_VAR 0 9
10036: PUSH
10037: LD_INT 22
10039: PUSH
10040: LD_INT 4
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 30
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PUSH
10066: LD_INT 1
10068: ARRAY
10069: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10070: LD_INT 35
10072: PPUSH
10073: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
10077: LD_EXP 90
10081: PUSH
10082: LD_INT 4
10084: ARRAY
10085: PUSH
10086: LD_INT 5
10088: GREATEREQUAL
10089: IFFALSE 10070
// powellAllowRetreat := false ;
10091: LD_ADDR_EXP 19
10095: PUSH
10096: LD_INT 0
10098: ST_TO_ADDR
// wait ( 0 0$20 ) ;
10099: LD_INT 700
10101: PPUSH
10102: CALL_OW 67
// activeAttacks := false ;
10106: LD_ADDR_EXP 16
10110: PUSH
10111: LD_INT 0
10113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10114: LD_INT 35
10116: PPUSH
10117: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
10121: LD_INT 22
10123: PUSH
10124: LD_INT 6
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: PPUSH
10131: CALL_OW 69
10135: PUSH
10136: LD_INT 0
10138: EQUAL
10139: IFFALSE 10114
// tmp := mc_vehicles [ 4 ] ;
10141: LD_ADDR_VAR 0 3
10145: PUSH
10146: LD_EXP 90
10150: PUSH
10151: LD_INT 4
10153: ARRAY
10154: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
10155: LD_ADDR_VAR 0 1
10159: PUSH
10160: DOUBLE
10161: LD_INT 1
10163: DEC
10164: ST_TO_ADDR
10165: LD_EXP 18
10169: PUSH
10170: FOR_TO
10171: IFFALSE 10389
// begin for j in powellSquadAttack [ i ] do
10173: LD_ADDR_VAR 0 2
10177: PUSH
10178: LD_EXP 18
10182: PUSH
10183: LD_VAR 0 1
10187: ARRAY
10188: PUSH
10189: FOR_IN
10190: IFFALSE 10385
// begin forces := forces diff j ;
10192: LD_ADDR_VAR 0 6
10196: PUSH
10197: LD_VAR 0 6
10201: PUSH
10202: LD_VAR 0 2
10206: DIFF
10207: ST_TO_ADDR
// SetTag ( j , 1 ) ;
10208: LD_VAR 0 2
10212: PPUSH
10213: LD_INT 1
10215: PPUSH
10216: CALL_OW 109
// wait ( 0 0$2 ) ;
10220: LD_INT 70
10222: PPUSH
10223: CALL_OW 67
// if IsInUnit ( j ) then
10227: LD_VAR 0 2
10231: PPUSH
10232: CALL_OW 310
10236: IFFALSE 10247
// ComExitBuilding ( j ) ;
10238: LD_VAR 0 2
10242: PPUSH
10243: CALL_OW 122
// if GetClass ( j ) <> 1 then
10247: LD_VAR 0 2
10251: PPUSH
10252: CALL_OW 257
10256: PUSH
10257: LD_INT 1
10259: NONEQUAL
10260: IFFALSE 10297
// begin AddComEnterUnit ( j , arm ) ;
10262: LD_VAR 0 2
10266: PPUSH
10267: LD_VAR 0 10
10271: PPUSH
10272: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
10276: LD_VAR 0 2
10280: PPUSH
10281: LD_INT 1
10283: PPUSH
10284: CALL_OW 183
// AddComExitBuilding ( j ) ;
10288: LD_VAR 0 2
10292: PPUSH
10293: CALL_OW 182
// end ; if i = 2 then
10297: LD_VAR 0 1
10301: PUSH
10302: LD_INT 2
10304: EQUAL
10305: IFFALSE 10322
// AddComMoveXY ( j , 61 , 93 ) ;
10307: LD_VAR 0 2
10311: PPUSH
10312: LD_INT 61
10314: PPUSH
10315: LD_INT 93
10317: PPUSH
10318: CALL_OW 171
// if i = 1 then
10322: LD_VAR 0 1
10326: PUSH
10327: LD_INT 1
10329: EQUAL
10330: IFFALSE 10383
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
10332: LD_VAR 0 2
10336: PPUSH
10337: LD_VAR 0 3
10341: PUSH
10342: LD_INT 1
10344: ARRAY
10345: PPUSH
10346: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
10350: LD_ADDR_VAR 0 3
10354: PUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_INT 1
10362: PPUSH
10363: CALL_OW 3
10367: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
10368: LD_VAR 0 2
10372: PPUSH
10373: LD_INT 69
10375: PPUSH
10376: LD_INT 94
10378: PPUSH
10379: CALL_OW 171
// end ; end ;
10383: GO 10189
10385: POP
10386: POP
// end ;
10387: GO 10170
10389: POP
10390: POP
// wait ( 0 0$30 ) ;
10391: LD_INT 1050
10393: PPUSH
10394: CALL_OW 67
// MC_Kill ( 4 ) ;
10398: LD_INT 4
10400: PPUSH
10401: CALL 14969 0 1
// tmp := UnitsInside ( fac ) ;
10405: LD_ADDR_VAR 0 3
10409: PUSH
10410: LD_VAR 0 9
10414: PPUSH
10415: CALL_OW 313
10419: ST_TO_ADDR
// if tmp then
10420: LD_VAR 0 3
10424: IFFALSE 10498
// for i in tmp do
10426: LD_ADDR_VAR 0 1
10430: PUSH
10431: LD_VAR 0 3
10435: PUSH
10436: FOR_IN
10437: IFFALSE 10496
// begin ComExitBuilding ( i ) ;
10439: LD_VAR 0 1
10443: PPUSH
10444: CALL_OW 122
// if UnitsInside ( arm ) < 6 then
10448: LD_VAR 0 10
10452: PPUSH
10453: CALL_OW 313
10457: PUSH
10458: LD_INT 6
10460: LESS
10461: IFFALSE 10479
// AddComEnterUnit ( i , arm ) else
10463: LD_VAR 0 1
10467: PPUSH
10468: LD_VAR 0 10
10472: PPUSH
10473: CALL_OW 180
10477: GO 10494
// AddComMoveXY ( i , 61 , 101 ) ;
10479: LD_VAR 0 1
10483: PPUSH
10484: LD_INT 61
10486: PPUSH
10487: LD_INT 101
10489: PPUSH
10490: CALL_OW 171
// end ;
10494: GO 10436
10496: POP
10497: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
10498: LD_ADDR_VAR 0 11
10502: PUSH
10503: LD_VAR 0 6
10507: PPUSH
10508: LD_INT 26
10510: PUSH
10511: LD_INT 1
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: PPUSH
10518: CALL_OW 72
10522: PUSH
10523: LD_EXP 40
10527: DIFF
10528: ST_TO_ADDR
// if not speaker then
10529: LD_VAR 0 11
10533: NOT
10534: IFFALSE 10561
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
10536: LD_ADDR_VAR 0 11
10540: PUSH
10541: LD_VAR 0 6
10545: PPUSH
10546: LD_INT 26
10548: PUSH
10549: LD_INT 1
10551: PUSH
10552: EMPTY
10553: LIST
10554: LIST
10555: PPUSH
10556: CALL_OW 72
10560: ST_TO_ADDR
// if speaker then
10561: LD_VAR 0 11
10565: IFFALSE 10581
// speaker := speaker [ 1 ] ;
10567: LD_ADDR_VAR 0 11
10571: PUSH
10572: LD_VAR 0 11
10576: PUSH
10577: LD_INT 1
10579: ARRAY
10580: ST_TO_ADDR
// Video ( true ) ;
10581: LD_INT 1
10583: PPUSH
10584: CALL 84737 0 1
// CenterNowOnUnits ( Powell ) ;
10588: LD_EXP 39
10592: PPUSH
10593: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
10597: LD_ADDR_VAR 0 3
10601: PUSH
10602: LD_VAR 0 6
10606: PPUSH
10607: LD_INT 3
10609: PUSH
10610: LD_INT 25
10612: PUSH
10613: LD_INT 1
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PPUSH
10624: CALL_OW 72
10628: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
10629: LD_ADDR_VAR 0 12
10633: PUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 4
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PUSH
10644: LD_INT 30
10646: PUSH
10647: LD_INT 32
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: LD_INT 58
10656: PUSH
10657: EMPTY
10658: LIST
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: PPUSH
10665: CALL_OW 69
10669: ST_TO_ADDR
// for i = 1 to 6 do
10670: LD_ADDR_VAR 0 1
10674: PUSH
10675: DOUBLE
10676: LD_INT 1
10678: DEC
10679: ST_TO_ADDR
10680: LD_INT 6
10682: PUSH
10683: FOR_TO
10684: IFFALSE 10821
// begin if IsInUnit ( tmp [ i ] ) then
10686: LD_VAR 0 3
10690: PUSH
10691: LD_VAR 0 1
10695: ARRAY
10696: PPUSH
10697: CALL_OW 310
10701: IFFALSE 10718
// ComExitBuilding ( tmp [ i ] ) ;
10703: LD_VAR 0 3
10707: PUSH
10708: LD_VAR 0 1
10712: ARRAY
10713: PPUSH
10714: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm ) ;
10718: LD_VAR 0 3
10722: PUSH
10723: LD_VAR 0 1
10727: ARRAY
10728: PPUSH
10729: LD_VAR 0 10
10733: PPUSH
10734: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
10738: LD_VAR 0 3
10742: PUSH
10743: LD_VAR 0 1
10747: ARRAY
10748: PPUSH
10749: LD_INT 1
10751: PPUSH
10752: CALL_OW 183
// if emp_towers then
10756: LD_VAR 0 12
10760: IFFALSE 10819
// begin AddComExitBuilding ( tmp [ i ] ) ;
10762: LD_VAR 0 3
10766: PUSH
10767: LD_VAR 0 1
10771: ARRAY
10772: PPUSH
10773: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
10777: LD_VAR 0 3
10781: PUSH
10782: LD_VAR 0 1
10786: ARRAY
10787: PPUSH
10788: LD_VAR 0 12
10792: PUSH
10793: LD_INT 1
10795: ARRAY
10796: PPUSH
10797: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
10801: LD_ADDR_VAR 0 12
10805: PUSH
10806: LD_VAR 0 12
10810: PPUSH
10811: LD_INT 1
10813: PPUSH
10814: CALL_OW 3
10818: ST_TO_ADDR
// end ; end ;
10819: GO 10683
10821: POP
10822: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
10823: LD_ADDR_VAR 0 3
10827: PUSH
10828: LD_EXP 18
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: PUSH
10837: LD_EXP 18
10841: PUSH
10842: LD_INT 2
10844: ARRAY
10845: ADD
10846: PPUSH
10847: LD_INT 26
10849: PUSH
10850: LD_INT 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 72
10861: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
10862: LD_ADDR_VAR 0 1
10866: PUSH
10867: LD_EXP 18
10871: PUSH
10872: LD_INT 2
10874: ARRAY
10875: PUSH
10876: FOR_IN
10877: IFFALSE 10895
// ComTurnUnit ( i , Powell ) ;
10879: LD_VAR 0 1
10883: PPUSH
10884: LD_EXP 39
10888: PPUSH
10889: CALL_OW 119
10893: GO 10876
10895: POP
10896: POP
// Say ( Powell , D5-Pow-1 ) ;
10897: LD_EXP 39
10901: PPUSH
10902: LD_STRING D5-Pow-1
10904: PPUSH
10905: CALL_OW 88
// if tmp then
10909: LD_VAR 0 3
10913: IFFALSE 10931
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
10915: LD_VAR 0 3
10919: PUSH
10920: LD_INT 1
10922: ARRAY
10923: PPUSH
10924: LD_STRING D5-Sol2-1
10926: PPUSH
10927: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
10931: LD_EXP 39
10935: PPUSH
10936: LD_STRING D5-Pow-2
10938: PPUSH
10939: CALL_OW 88
// if tmp > 1 then
10943: LD_VAR 0 3
10947: PUSH
10948: LD_INT 1
10950: GREATER
10951: IFFALSE 10969
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
10953: LD_VAR 0 3
10957: PUSH
10958: LD_INT 2
10960: ARRAY
10961: PPUSH
10962: LD_STRING D5-Sol2-2
10964: PPUSH
10965: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
10969: LD_EXP 39
10973: PPUSH
10974: LD_STRING D5-Pow-3
10976: PPUSH
10977: CALL_OW 88
// wait ( 0 0$1 ) ;
10981: LD_INT 35
10983: PPUSH
10984: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
10988: LD_ADDR_VAR 0 3
10992: PUSH
10993: LD_EXP 18
10997: PUSH
10998: LD_INT 1
11000: ARRAY
11001: PUSH
11002: LD_EXP 18
11006: PUSH
11007: LD_INT 2
11009: ARRAY
11010: UNION
11011: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
11012: LD_VAR 0 3
11016: PPUSH
11017: LD_INT 80
11019: PPUSH
11020: LD_INT 67
11022: PPUSH
11023: CALL_OW 114
// wait ( 0 0$2 ) ;
11027: LD_INT 70
11029: PPUSH
11030: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
11034: LD_INT 79
11036: PPUSH
11037: LD_INT 72
11039: PPUSH
11040: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
11044: LD_INT 35
11046: PPUSH
11047: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
11051: LD_VAR 0 3
11055: PPUSH
11056: LD_INT 3
11058: PUSH
11059: LD_INT 24
11061: PUSH
11062: LD_INT 1000
11064: PUSH
11065: EMPTY
11066: LIST
11067: LIST
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PPUSH
11073: CALL_OW 72
11077: IFFALSE 11044
// Say ( Powell , D5a-Pow-1 ) ;
11079: LD_EXP 39
11083: PPUSH
11084: LD_STRING D5a-Pow-1
11086: PPUSH
11087: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
11091: LD_EXP 39
11095: PPUSH
11096: LD_STRING D5a-Pow-1a
11098: PPUSH
11099: CALL_OW 88
// wait ( 0 0$0.3 ) ;
11103: LD_INT 10
11105: PPUSH
11106: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
11110: LD_EXP 39
11114: PPUSH
11115: LD_STRING D5a-Pow-1b
11117: PPUSH
11118: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
11122: LD_EXP 39
11126: PPUSH
11127: LD_STRING D5a-Pow-1c
11129: PPUSH
11130: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
11134: LD_EXP 39
11138: PPUSH
11139: LD_STRING D5a-Pow-1d
11141: PPUSH
11142: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11146: LD_INT 35
11148: PPUSH
11149: CALL_OW 67
// if not HasTask ( tmp ) then
11153: LD_VAR 0 3
11157: PPUSH
11158: CALL_OW 314
11162: NOT
11163: IFFALSE 11180
// ComAgressiveMove ( tmp , 80 , 67 ) ;
11165: LD_VAR 0 3
11169: PPUSH
11170: LD_INT 80
11172: PPUSH
11173: LD_INT 67
11175: PPUSH
11176: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
11180: LD_VAR 0 3
11184: PPUSH
11185: LD_INT 24
11187: PUSH
11188: LD_INT 1
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PPUSH
11195: CALL_OW 72
11199: NOT
11200: IFFALSE 11146
// wait ( 0 0$3 ) ;
11202: LD_INT 105
11204: PPUSH
11205: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
11209: LD_VAR 0 11
11213: PPUSH
11214: LD_STRING D6-Sol3-1
11216: PPUSH
11217: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
11221: LD_EXP 39
11225: PPUSH
11226: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
11230: LD_EXP 39
11234: PPUSH
11235: LD_STRING D6-Pow-1
11237: PPUSH
11238: CALL_OW 88
// tmp := [ ] ;
11242: LD_ADDR_VAR 0 3
11246: PUSH
11247: EMPTY
11248: ST_TO_ADDR
// for i = 1 to 2 do
11249: LD_ADDR_VAR 0 1
11253: PUSH
11254: DOUBLE
11255: LD_INT 1
11257: DEC
11258: ST_TO_ADDR
11259: LD_INT 2
11261: PUSH
11262: FOR_TO
11263: IFFALSE 11370
// begin uc_side := 8 ;
11265: LD_ADDR_OWVAR 20
11269: PUSH
11270: LD_INT 8
11272: ST_TO_ADDR
// uc_nation := 2 ;
11273: LD_ADDR_OWVAR 21
11277: PUSH
11278: LD_INT 2
11280: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
11281: LD_INT 14
11283: PPUSH
11284: LD_INT 3
11286: PPUSH
11287: LD_INT 2
11289: PPUSH
11290: LD_INT 29
11292: PPUSH
11293: LD_INT 100
11295: PPUSH
11296: CALL 49082 0 5
// veh := CreateVehicle ;
11300: LD_ADDR_VAR 0 13
11304: PUSH
11305: CALL_OW 45
11309: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
11310: LD_VAR 0 13
11314: PPUSH
11315: LD_INT 4
11317: PPUSH
11318: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
11322: LD_VAR 0 13
11326: PPUSH
11327: LD_INT 99
11329: PPUSH
11330: LD_INT 83
11332: PPUSH
11333: LD_INT 5
11335: PPUSH
11336: LD_INT 0
11338: PPUSH
11339: CALL_OW 50
// Connect ( veh ) ;
11343: LD_VAR 0 13
11347: PPUSH
11348: CALL 52137 0 1
// tmp := tmp ^ veh ;
11352: LD_ADDR_VAR 0 3
11356: PUSH
11357: LD_VAR 0 3
11361: PUSH
11362: LD_VAR 0 13
11366: ADD
11367: ST_TO_ADDR
// end ;
11368: GO 11262
11370: POP
11371: POP
// wait ( 0 0$1 ) ;
11372: LD_INT 35
11374: PPUSH
11375: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
11379: LD_INT 99
11381: PPUSH
11382: LD_INT 83
11384: PPUSH
11385: LD_INT 1
11387: PPUSH
11388: LD_INT 10
11390: PPUSH
11391: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
11395: LD_INT 99
11397: PPUSH
11398: LD_INT 83
11400: PPUSH
11401: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
11405: LD_VAR 0 11
11409: PPUSH
11410: LD_STRING D6-Sol3-2
11412: PPUSH
11413: CALL_OW 88
// async ;
11417: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
11418: LD_EXP 39
11422: PPUSH
11423: LD_STRING D6-Pow-2
11425: PPUSH
11426: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
11430: LD_VAR 0 3
11434: PUSH
11435: LD_INT 1
11437: ARRAY
11438: PPUSH
11439: LD_VAR 0 9
11443: PPUSH
11444: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
11448: LD_VAR 0 3
11452: PUSH
11453: LD_INT 2
11455: ARRAY
11456: PPUSH
11457: LD_INT 22
11459: PUSH
11460: LD_INT 4
11462: PUSH
11463: EMPTY
11464: LIST
11465: LIST
11466: PUSH
11467: LD_INT 21
11469: PUSH
11470: LD_INT 3
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: PUSH
11477: EMPTY
11478: LIST
11479: LIST
11480: PPUSH
11481: CALL_OW 69
11485: PPUSH
11486: LD_VAR 0 3
11490: PUSH
11491: LD_INT 2
11493: ARRAY
11494: PPUSH
11495: CALL_OW 74
11499: PPUSH
11500: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
11504: LD_EXP 39
11508: PPUSH
11509: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
11513: LD_INT 99
11515: PPUSH
11516: LD_INT 83
11518: PPUSH
11519: LD_INT 1
11521: PPUSH
11522: CALL_OW 331
// repeat wait ( 4 ) ;
11526: LD_INT 4
11528: PPUSH
11529: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
11533: LD_VAR 0 3
11537: PUSH
11538: LD_INT 1
11540: ARRAY
11541: PPUSH
11542: CALL_OW 256
11546: PUSH
11547: LD_INT 1000
11549: LESS
11550: IFFALSE 11568
// SetLives ( tmp [ 1 ] , 1000 ) ;
11552: LD_VAR 0 3
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PPUSH
11561: LD_INT 1000
11563: PPUSH
11564: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
11568: LD_INT 22
11570: PUSH
11571: LD_INT 4
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PUSH
11578: LD_INT 30
11580: PUSH
11581: LD_INT 3
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PPUSH
11592: CALL_OW 69
11596: PUSH
11597: LD_INT 0
11599: EQUAL
11600: IFFALSE 11526
// sync ;
11602: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
11603: LD_EXP 39
11607: PPUSH
11608: LD_STRING D6a-Pow-1
11610: PPUSH
11611: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
11615: LD_VAR 0 11
11619: PPUSH
11620: LD_STRING D6a-Sol3-1
11622: PPUSH
11623: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
11627: LD_EXP 39
11631: PPUSH
11632: LD_STRING D6a-Pow-2
11634: PPUSH
11635: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
11639: LD_VAR 0 11
11643: PPUSH
11644: LD_STRING D6a-Sol3-2
11646: PPUSH
11647: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
11651: LD_EXP 39
11655: PPUSH
11656: LD_STRING D6a-Pow-3
11658: PPUSH
11659: CALL_OW 88
// powellCenterCameraMode := true ;
11663: LD_ADDR_EXP 20
11667: PUSH
11668: LD_INT 1
11670: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
11671: LD_ADDR_VAR 0 3
11675: PUSH
11676: LD_INT 22
11678: PUSH
11679: LD_INT 4
11681: PUSH
11682: EMPTY
11683: LIST
11684: LIST
11685: PUSH
11686: LD_INT 21
11688: PUSH
11689: LD_INT 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PUSH
11696: LD_INT 3
11698: PUSH
11699: LD_INT 34
11701: PUSH
11702: LD_INT 12
11704: PUSH
11705: EMPTY
11706: LIST
11707: LIST
11708: PUSH
11709: EMPTY
11710: LIST
11711: LIST
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: LIST
11717: PPUSH
11718: CALL_OW 69
11722: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
11723: LD_EXP 39
11727: PPUSH
11728: LD_VAR 0 3
11732: PPUSH
11733: LD_EXP 39
11737: PPUSH
11738: CALL_OW 74
11742: PPUSH
11743: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
11747: LD_EXP 39
11751: PPUSH
11752: LD_INT 100
11754: PPUSH
11755: LD_INT 88
11757: PPUSH
11758: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
11762: LD_EXP 39
11766: PPUSH
11767: LD_INT 100
11769: PPUSH
11770: LD_INT 75
11772: PPUSH
11773: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
11777: LD_EXP 39
11781: PPUSH
11782: LD_INT 88
11784: PPUSH
11785: LD_INT 53
11787: PPUSH
11788: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
11792: LD_INT 8
11794: PPUSH
11795: LD_EXP 39
11799: PPUSH
11800: CALL_OW 471
// SetAttitude ( 4 , 8 , att_neutral , false ) ;
11804: LD_INT 4
11806: PPUSH
11807: LD_INT 8
11809: PPUSH
11810: LD_INT 0
11812: PPUSH
11813: LD_INT 0
11815: PPUSH
11816: CALL_OW 80
// repeat wait ( 3 ) ;
11820: LD_INT 3
11822: PPUSH
11823: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
11827: LD_INT 22
11829: PUSH
11830: LD_INT 4
11832: PUSH
11833: EMPTY
11834: LIST
11835: LIST
11836: PUSH
11837: LD_INT 92
11839: PUSH
11840: LD_INT 100
11842: PUSH
11843: LD_INT 75
11845: PUSH
11846: LD_INT 6
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PPUSH
11859: CALL_OW 69
11863: IFFALSE 11820
// async ;
11865: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
11866: LD_EXP 39
11870: PPUSH
11871: LD_STRING D6b-Pow-1
11873: PPUSH
11874: CALL_OW 88
// repeat wait ( 3 ) ;
11878: LD_INT 3
11880: PPUSH
11881: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
11885: LD_EXP 39
11889: PPUSH
11890: CALL_OW 310
11894: PPUSH
11895: CALL_OW 256
11899: PUSH
11900: LD_INT 1000
11902: LESS
11903: IFFALSE 11922
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
11905: LD_EXP 39
11909: PPUSH
11910: CALL_OW 310
11914: PPUSH
11915: LD_INT 1000
11917: PPUSH
11918: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
11922: LD_EXP 39
11926: PPUSH
11927: CALL_OW 256
11931: PUSH
11932: LD_INT 1000
11934: LESS
11935: IFFALSE 11949
// SetLives ( Powell , 1000 ) ;
11937: LD_EXP 39
11941: PPUSH
11942: LD_INT 1000
11944: PPUSH
11945: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
11949: LD_EXP 39
11953: PPUSH
11954: LD_EXP 44
11958: PPUSH
11959: CALL_OW 296
11963: PUSH
11964: LD_INT 5
11966: LESS
11967: PUSH
11968: LD_EXP 39
11972: PPUSH
11973: CALL_OW 310
11977: PPUSH
11978: LD_EXP 44
11982: PPUSH
11983: CALL_OW 296
11987: PUSH
11988: LD_INT 5
11990: LESS
11991: OR
11992: IFFALSE 12011
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
11994: LD_EXP 39
11998: PPUSH
11999: CALL_OW 310
12003: PPUSH
12004: LD_INT 100
12006: PPUSH
12007: CALL_OW 234
// until not IsInUnit ( Powell ) ;
12011: LD_EXP 39
12015: PPUSH
12016: CALL_OW 310
12020: NOT
12021: IFFALSE 11878
// game_speed := 4 ;
12023: LD_ADDR_OWVAR 65
12027: PUSH
12028: LD_INT 4
12030: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
12031: LD_EXP 39
12035: PPUSH
12036: LD_STRING D6b-Pow-1a
12038: PPUSH
12039: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
12043: LD_EXP 39
12047: PPUSH
12048: LD_EXP 44
12052: PPUSH
12053: CALL_OW 180
// sync ;
12057: SYNC
// repeat wait ( 0 0$1 ) ;
12058: LD_INT 35
12060: PPUSH
12061: CALL_OW 67
// until IsInUnit ( Powell ) ;
12065: LD_EXP 39
12069: PPUSH
12070: CALL_OW 310
12074: IFFALSE 12058
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
12076: LD_INT 8
12078: PPUSH
12079: LD_EXP 39
12083: PPUSH
12084: CALL_OW 310
12088: PPUSH
12089: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
12093: LD_EXP 39
12097: PPUSH
12098: LD_INT 91
12100: PPUSH
12101: LD_INT 44
12103: PPUSH
12104: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
12108: LD_EXP 39
12112: PPUSH
12113: LD_INT 96
12115: PPUSH
12116: LD_INT 44
12118: PPUSH
12119: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
12123: LD_EXP 39
12127: PPUSH
12128: LD_INT 96
12130: PPUSH
12131: LD_INT 41
12133: PPUSH
12134: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
12138: LD_EXP 39
12142: PPUSH
12143: LD_INT 92
12145: PPUSH
12146: LD_INT 39
12148: PPUSH
12149: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
12153: LD_EXP 39
12157: PPUSH
12158: LD_INT 88
12160: PPUSH
12161: LD_INT 41
12163: PPUSH
12164: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
12168: LD_EXP 39
12172: PPUSH
12173: LD_INT 91
12175: PPUSH
12176: LD_INT 44
12178: PPUSH
12179: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
12183: LD_EXP 39
12187: PPUSH
12188: LD_INT 96
12190: PPUSH
12191: LD_INT 44
12193: PPUSH
12194: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
12198: LD_EXP 39
12202: PPUSH
12203: LD_INT 96
12205: PPUSH
12206: LD_INT 41
12208: PPUSH
12209: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
12213: LD_EXP 39
12217: PPUSH
12218: LD_INT 92
12220: PPUSH
12221: LD_INT 39
12223: PPUSH
12224: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
12228: LD_EXP 39
12232: PPUSH
12233: LD_INT 88
12235: PPUSH
12236: LD_INT 41
12238: PPUSH
12239: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
12243: LD_EXP 39
12247: PPUSH
12248: LD_INT 91
12250: PPUSH
12251: LD_INT 44
12253: PPUSH
12254: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
12258: LD_EXP 39
12262: PPUSH
12263: LD_INT 93
12265: PPUSH
12266: LD_INT 39
12268: PPUSH
12269: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
12273: LD_EXP 39
12277: PPUSH
12278: LD_INT 93
12280: PPUSH
12281: LD_INT 36
12283: PPUSH
12284: CALL_OW 171
// wait ( 0 0$3.5 ) ;
12288: LD_INT 122
12290: PPUSH
12291: CALL_OW 67
// game_speed := 4 ;
12295: LD_ADDR_OWVAR 65
12299: PUSH
12300: LD_INT 4
12302: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
12303: LD_EXP 39
12307: PPUSH
12308: LD_STRING D6b-Pow-1b
12310: PPUSH
12311: CALL_OW 88
// tmp := [ ] ;
12315: LD_ADDR_VAR 0 3
12319: PUSH
12320: EMPTY
12321: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
12322: LD_ADDR_VAR 0 5
12326: PUSH
12327: LD_INT 78
12329: PUSH
12330: LD_INT 47
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 106
12339: PUSH
12340: LD_INT 53
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
12351: LD_ADDR_VAR 0 1
12355: PUSH
12356: LD_INT 22
12358: PUSH
12359: LD_INT 8
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: PUSH
12366: LD_INT 21
12368: PUSH
12369: LD_INT 3
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PUSH
12376: LD_INT 92
12378: PUSH
12379: LD_INT 90
12381: PUSH
12382: LD_INT 52
12384: PUSH
12385: LD_INT 12
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: LIST
12398: PPUSH
12399: CALL_OW 69
12403: PUSH
12404: FOR_IN
12405: IFFALSE 12430
// tmp := tmp ^ UnitsInside ( i ) ;
12407: LD_ADDR_VAR 0 3
12411: PUSH
12412: LD_VAR 0 3
12416: PUSH
12417: LD_VAR 0 1
12421: PPUSH
12422: CALL_OW 313
12426: ADD
12427: ST_TO_ADDR
12428: GO 12404
12430: POP
12431: POP
// for i in tmp do
12432: LD_ADDR_VAR 0 1
12436: PUSH
12437: LD_VAR 0 3
12441: PUSH
12442: FOR_IN
12443: IFFALSE 12605
// begin dist := 9999 ;
12445: LD_ADDR_VAR 0 8
12449: PUSH
12450: LD_INT 9999
12452: ST_TO_ADDR
// _xy := [ ] ;
12453: LD_ADDR_VAR 0 7
12457: PUSH
12458: EMPTY
12459: ST_TO_ADDR
// SetTag ( i , 1 ) ;
12460: LD_VAR 0 1
12464: PPUSH
12465: LD_INT 1
12467: PPUSH
12468: CALL_OW 109
// ComExitBuilding ( i ) ;
12472: LD_VAR 0 1
12476: PPUSH
12477: CALL_OW 122
// for j in xy do
12481: LD_ADDR_VAR 0 2
12485: PUSH
12486: LD_VAR 0 5
12490: PUSH
12491: FOR_IN
12492: IFFALSE 12574
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
12494: LD_VAR 0 1
12498: PPUSH
12499: LD_VAR 0 2
12503: PUSH
12504: LD_INT 1
12506: ARRAY
12507: PPUSH
12508: LD_VAR 0 2
12512: PUSH
12513: LD_INT 2
12515: ARRAY
12516: PPUSH
12517: CALL_OW 297
12521: PUSH
12522: LD_VAR 0 8
12526: LESS
12527: IFFALSE 12572
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
12529: LD_ADDR_VAR 0 8
12533: PUSH
12534: LD_VAR 0 1
12538: PPUSH
12539: LD_VAR 0 2
12543: PUSH
12544: LD_INT 1
12546: ARRAY
12547: PPUSH
12548: LD_VAR 0 2
12552: PUSH
12553: LD_INT 2
12555: ARRAY
12556: PPUSH
12557: CALL_OW 297
12561: ST_TO_ADDR
// _xy := j ;
12562: LD_ADDR_VAR 0 7
12566: PUSH
12567: LD_VAR 0 2
12571: ST_TO_ADDR
// end ;
12572: GO 12491
12574: POP
12575: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
12576: LD_VAR 0 1
12580: PPUSH
12581: LD_VAR 0 7
12585: PUSH
12586: LD_INT 1
12588: ARRAY
12589: PPUSH
12590: LD_VAR 0 7
12594: PUSH
12595: LD_INT 2
12597: ARRAY
12598: PPUSH
12599: CALL_OW 171
// end ;
12603: GO 12442
12605: POP
12606: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
12607: LD_ADDR_VAR 0 4
12611: PUSH
12612: LD_VAR 0 3
12616: PPUSH
12617: LD_INT 26
12619: PUSH
12620: LD_INT 1
12622: PUSH
12623: EMPTY
12624: LIST
12625: LIST
12626: PPUSH
12627: CALL_OW 72
12631: ST_TO_ADDR
// if tmp2 < 2 then
12632: LD_VAR 0 4
12636: PUSH
12637: LD_INT 2
12639: LESS
12640: IFFALSE 12702
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_class , 1 ] ] ) diff [ Kurt , Kozlov ] ;
12642: LD_ADDR_VAR 0 4
12646: PUSH
12647: LD_INT 22
12649: PUSH
12650: LD_INT 8
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 26
12659: PUSH
12660: LD_INT 1
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: PUSH
12667: LD_INT 25
12669: PUSH
12670: LD_INT 1
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: PPUSH
12682: CALL_OW 69
12686: PUSH
12687: LD_EXP 41
12691: PUSH
12692: LD_EXP 42
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: DIFF
12701: ST_TO_ADDR
// if tmp2 then
12702: LD_VAR 0 4
12706: IFFALSE 12724
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
12708: LD_VAR 0 4
12712: PUSH
12713: LD_INT 1
12715: ARRAY
12716: PPUSH
12717: LD_STRING D6b-ArSol1-1
12719: PPUSH
12720: CALL_OW 88
// async ;
12724: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
12725: LD_EXP 39
12729: PPUSH
12730: LD_STRING D6b-Pow-2
12732: PPUSH
12733: CALL_OW 88
// if tmp2 > 1 then
12737: LD_VAR 0 4
12741: PUSH
12742: LD_INT 1
12744: GREATER
12745: IFFALSE 12763
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
12747: LD_VAR 0 4
12751: PUSH
12752: LD_INT 2
12754: ARRAY
12755: PPUSH
12756: LD_STRING D6b-ArSol2-1
12758: PPUSH
12759: CALL_OW 88
// sync ;
12763: SYNC
// repeat wait ( 5 ) ;
12764: LD_INT 5
12766: PPUSH
12767: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
12771: LD_INT 93
12773: PPUSH
12774: LD_INT 36
12776: PPUSH
12777: CALL_OW 428
12781: PPUSH
12782: CALL_OW 255
12786: PUSH
12787: LD_INT 4
12789: EQUAL
12790: IFFALSE 12764
// DialogueOn ;
12792: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
12796: LD_INT 10
12798: PPUSH
12799: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
12803: LD_EXP 39
12807: PPUSH
12808: LD_STRING D6b-Pow-2a
12810: PPUSH
12811: CALL_OW 88
// DialogueOff ;
12815: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
12819: LD_EXP 39
12823: PPUSH
12824: CALL_OW 310
12828: PPUSH
12829: LD_INT 332
12831: PPUSH
12832: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
12836: LD_INT 93
12838: PPUSH
12839: LD_INT 35
12841: PPUSH
12842: LD_INT 1
12844: PPUSH
12845: LD_INT 6
12847: NEG
12848: PPUSH
12849: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
12853: LD_INT 35
12855: PPUSH
12856: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
12860: LD_INT 332
12862: PPUSH
12863: CALL_OW 256
12867: PUSH
12868: LD_INT 1000
12870: LESS
12871: PUSH
12872: LD_INT 332
12874: PPUSH
12875: CALL_OW 300
12879: AND
12880: IFFALSE 12892
// SetLives ( kozlov_fac , 1 ) ;
12882: LD_INT 332
12884: PPUSH
12885: LD_INT 1
12887: PPUSH
12888: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
12892: LD_INT 332
12894: PPUSH
12895: CALL_OW 301
12899: PUSH
12900: LD_EXP 39
12904: PPUSH
12905: CALL_OW 301
12909: OR
12910: IFFALSE 12853
// game_speed := 4 ;
12912: LD_ADDR_OWVAR 65
12916: PUSH
12917: LD_INT 4
12919: ST_TO_ADDR
// powellCenterCameraMode := false ;
12920: LD_ADDR_EXP 20
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// for i in tmp do
12928: LD_ADDR_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: PUSH
12938: FOR_IN
12939: IFFALSE 12955
// SetTag ( i , 0 ) ;
12941: LD_VAR 0 1
12945: PPUSH
12946: LD_INT 0
12948: PPUSH
12949: CALL_OW 109
12953: GO 12938
12955: POP
12956: POP
// wait ( 0 0$3 ) ;
12957: LD_INT 105
12959: PPUSH
12960: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
12964: LD_INT 93
12966: PPUSH
12967: LD_INT 35
12969: PPUSH
12970: LD_INT 1
12972: PPUSH
12973: CALL_OW 331
// DialogueOn ;
12977: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
12981: LD_VAR 0 11
12985: PPUSH
12986: LD_STRING D6c-Sol3-1
12988: PPUSH
12989: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12993: LD_INT 10
12995: PPUSH
12996: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
13000: LD_EXP 21
13004: PPUSH
13005: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
13009: LD_EXP 21
13013: PPUSH
13014: LD_STRING D6c-JMM-1
13016: PPUSH
13017: CALL_OW 88
// if Cyrus then
13021: LD_EXP 27
13025: IFFALSE 13039
// Say ( Cyrus , D6c-Cyrus-1 ) ;
13027: LD_EXP 27
13031: PPUSH
13032: LD_STRING D6c-Cyrus-1
13034: PPUSH
13035: CALL_OW 88
// if Bobby then
13039: LD_EXP 26
13043: IFFALSE 13057
// Say ( Bobby , D6c-Bobby-1 ) ;
13045: LD_EXP 26
13049: PPUSH
13050: LD_STRING D6c-Bobby-1
13052: PPUSH
13053: CALL_OW 88
// if Cornel then
13057: LD_EXP 32
13061: IFFALSE 13075
// Say ( Cornel , D6c-Corn-1 ) ;
13063: LD_EXP 32
13067: PPUSH
13068: LD_STRING D6c-Corn-1
13070: PPUSH
13071: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] ] ) diff ( speaker union JMM union vip ) ;
13075: LD_ADDR_VAR 0 4
13079: PUSH
13080: LD_INT 2
13082: PUSH
13083: LD_INT 22
13085: PUSH
13086: LD_INT 1
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 22
13095: PUSH
13096: LD_INT 4
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: EMPTY
13104: LIST
13105: LIST
13106: LIST
13107: PUSH
13108: LD_INT 26
13110: PUSH
13111: LD_INT 1
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: PPUSH
13122: CALL_OW 69
13126: PUSH
13127: LD_VAR 0 11
13131: PUSH
13132: LD_EXP 21
13136: UNION
13137: PUSH
13138: LD_EXP 40
13142: UNION
13143: DIFF
13144: ST_TO_ADDR
// if tmp2 then
13145: LD_VAR 0 4
13149: IFFALSE 13167
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
13151: LD_VAR 0 4
13155: PUSH
13156: LD_INT 1
13158: ARRAY
13159: PPUSH
13160: LD_STRING D6c-Sol1-1
13162: PPUSH
13163: CALL_OW 88
// if Lisa then
13167: LD_EXP 24
13171: IFFALSE 13185
// Say ( Lisa , D6c-Lisa-1 ) ;
13173: LD_EXP 24
13177: PPUSH
13178: LD_STRING D6c-Lisa-1
13180: PPUSH
13181: CALL_OW 88
// if Gary then
13185: LD_EXP 33
13189: IFFALSE 13203
// Say ( Gary , D6c-Gary-1 ) ;
13191: LD_EXP 33
13195: PPUSH
13196: LD_STRING D6c-Gary-1
13198: PPUSH
13199: CALL_OW 88
// if Donaldson then
13203: LD_EXP 25
13207: IFFALSE 13221
// Say ( Donaldson , D6c-Don-1 ) ;
13209: LD_EXP 25
13213: PPUSH
13214: LD_STRING D6c-Don-1
13216: PPUSH
13217: CALL_OW 88
// if tmp2 > 1 then
13221: LD_VAR 0 4
13225: PUSH
13226: LD_INT 1
13228: GREATER
13229: IFFALSE 13247
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
13231: LD_VAR 0 4
13235: PUSH
13236: LD_INT 2
13238: ARRAY
13239: PPUSH
13240: LD_STRING D6c-Sol2-1
13242: PPUSH
13243: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
13247: LD_VAR 0 11
13251: PPUSH
13252: LD_STRING D6c-Sol3-2
13254: PPUSH
13255: CALL_OW 88
// dwait ( 0 0$1 ) ;
13259: LD_INT 35
13261: PPUSH
13262: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
13266: LD_EXP 21
13270: PPUSH
13271: LD_STRING D6c-JMM-2
13273: PPUSH
13274: CALL_OW 88
// DialogueOff ;
13278: CALL_OW 7
// Video ( false ) ;
13282: LD_INT 0
13284: PPUSH
13285: CALL 84737 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
13289: LD_INT 22
13291: PUSH
13292: LD_INT 4
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PPUSH
13299: CALL_OW 69
13303: PPUSH
13304: LD_INT 1
13306: PPUSH
13307: CALL_OW 235
// for i in GetTechNation ( 4 , 1 , 2 ) do
13311: LD_ADDR_VAR 0 1
13315: PUSH
13316: LD_INT 4
13318: PPUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 2
13324: PPUSH
13325: CALL 42512 0 3
13329: PUSH
13330: FOR_IN
13331: IFFALSE 13368
// if GetTech ( i , 1 ) <> state_researched then
13333: LD_VAR 0 1
13337: PPUSH
13338: LD_INT 1
13340: PPUSH
13341: CALL_OW 321
13345: PUSH
13346: LD_INT 2
13348: NONEQUAL
13349: IFFALSE 13366
// SetTech ( i , 1 , state_researched ) ;
13351: LD_VAR 0 1
13355: PPUSH
13356: LD_INT 1
13358: PPUSH
13359: LD_INT 2
13361: PPUSH
13362: CALL_OW 322
13366: GO 13330
13368: POP
13369: POP
// missionStart := 0 0$00 ;
13370: LD_ADDR_EXP 13
13374: PUSH
13375: LD_INT 0
13377: ST_TO_ADDR
// missionStage := 6 ;
13378: LD_ADDR_EXP 15
13382: PUSH
13383: LD_INT 6
13385: ST_TO_ADDR
// activeAttacks := true ;
13386: LD_ADDR_EXP 16
13390: PUSH
13391: LD_INT 1
13393: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
13394: LD_STRING M2
13396: PPUSH
13397: CALL_OW 337
// SaveForQuickRestart ;
13401: CALL_OW 22
// wait ( 0 0$40 ) ;
13405: LD_INT 1400
13407: PPUSH
13408: CALL_OW 67
// DialogueOn ;
13412: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
13416: LD_EXP 43
13420: PPUSH
13421: LD_STRING D7-Friend-1
13423: PPUSH
13424: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
13428: LD_EXP 21
13432: PPUSH
13433: LD_STRING D7-JMM-1
13435: PPUSH
13436: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
13440: LD_EXP 43
13444: PPUSH
13445: LD_STRING D7-Friend-2
13447: PPUSH
13448: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13452: LD_EXP 21
13456: PPUSH
13457: LD_STRING D7-JMM-2
13459: PPUSH
13460: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
13464: LD_EXP 43
13468: PPUSH
13469: LD_STRING D7-Friend-3
13471: PPUSH
13472: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13476: LD_EXP 21
13480: PPUSH
13481: LD_STRING D7-JMM-3
13483: PPUSH
13484: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
13488: LD_EXP 43
13492: PPUSH
13493: LD_STRING D7-Friend-4
13495: PPUSH
13496: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13500: LD_EXP 21
13504: PPUSH
13505: LD_STRING D7-JMM-4
13507: PPUSH
13508: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
13512: LD_EXP 43
13516: PPUSH
13517: LD_STRING D7-Friend-5
13519: PPUSH
13520: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
13524: LD_EXP 21
13528: PPUSH
13529: LD_STRING D7-JMM-5
13531: PPUSH
13532: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
13536: LD_EXP 43
13540: PPUSH
13541: LD_STRING D7-Friend-6
13543: PPUSH
13544: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
13548: LD_EXP 21
13552: PPUSH
13553: LD_STRING D7-JMM-6
13555: PPUSH
13556: CALL_OW 88
// DialogueOff ;
13560: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
13564: LD_STRING Mlegion
13566: PPUSH
13567: CALL_OW 337
// RebuildKozlovFactory ;
13571: CALL 3312 0 0
// end ;
13575: PPOPN 13
13577: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
13578: LD_EXP 20
13582: PUSH
13583: LD_EXP 39
13587: PPUSH
13588: CALL_OW 300
13592: AND
13593: IFFALSE 13635
13595: GO 13597
13597: DISABLE
// begin enable ;
13598: ENABLE
// if IsInUnit ( Powell ) then
13599: LD_EXP 39
13603: PPUSH
13604: CALL_OW 310
13608: IFFALSE 13626
// CenterOnUnits ( IsInUnit ( Powell ) ) else
13610: LD_EXP 39
13614: PPUSH
13615: CALL_OW 310
13619: PPUSH
13620: CALL_OW 85
13624: GO 13635
// CenterOnUnits ( Powell ) ;
13626: LD_EXP 39
13630: PPUSH
13631: CALL_OW 85
// end ;
13635: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
13636: LD_INT 22
13638: PUSH
13639: LD_INT 8
13641: PUSH
13642: EMPTY
13643: LIST
13644: LIST
13645: PUSH
13646: LD_INT 34
13648: PUSH
13649: LD_INT 48
13651: PUSH
13652: EMPTY
13653: LIST
13654: LIST
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PPUSH
13660: CALL_OW 69
13664: IFFALSE 13867
13666: GO 13668
13668: DISABLE
13669: LD_INT 0
13671: PPUSH
13672: PPUSH
// begin bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
13673: LD_ADDR_VAR 0 1
13677: PUSH
13678: LD_INT 22
13680: PUSH
13681: LD_INT 8
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: PUSH
13688: LD_INT 34
13690: PUSH
13691: LD_INT 48
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PPUSH
13702: CALL_OW 69
13706: PUSH
13707: LD_INT 1
13709: ARRAY
13710: ST_TO_ADDR
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
13711: LD_EXP 12
13715: PUSH
13716: LD_EXP 3
13720: PUSH
13721: LD_INT 0
13723: PUSH
13724: LD_INT 2
13726: PUSH
13727: EMPTY
13728: LIST
13729: LIST
13730: IN
13731: OR
13732: IFFALSE 13755
// target := [ 68 , 108 , 1 ] else
13734: LD_ADDR_VAR 0 2
13738: PUSH
13739: LD_INT 68
13741: PUSH
13742: LD_INT 108
13744: PUSH
13745: LD_INT 1
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: LIST
13752: ST_TO_ADDR
13753: GO 13774
// target := [ 181 , 88 , 2 ] ;
13755: LD_ADDR_VAR 0 2
13759: PUSH
13760: LD_INT 181
13762: PUSH
13763: LD_INT 88
13765: PUSH
13766: LD_INT 2
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: LIST
13773: ST_TO_ADDR
// if not target then
13774: LD_VAR 0 2
13778: NOT
13779: IFFALSE 13783
// exit ;
13781: GO 13867
// ComAttackPlace ( IsInUnit ( bomb ) , target [ 1 ] , target [ 2 ] ) ;
13783: LD_VAR 0 1
13787: PPUSH
13788: CALL_OW 310
13792: PPUSH
13793: LD_VAR 0 2
13797: PUSH
13798: LD_INT 1
13800: ARRAY
13801: PPUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 2
13809: ARRAY
13810: PPUSH
13811: CALL_OW 116
// if target [ 3 ] = 1 then
13815: LD_VAR 0 2
13819: PUSH
13820: LD_INT 3
13822: ARRAY
13823: PUSH
13824: LD_INT 1
13826: EQUAL
13827: IFFALSE 13843
// SayRadio ( Kurt , D12-Kurt-1 ) else
13829: LD_EXP 41
13833: PPUSH
13834: LD_STRING D12-Kurt-1
13836: PPUSH
13837: CALL_OW 94
13841: GO 13867
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
13843: LD_EXP 41
13847: PPUSH
13848: LD_STRING D12a-Kurt-1
13850: PPUSH
13851: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
13855: LD_EXP 47
13859: PPUSH
13860: LD_STRING D12a-Roth-1
13862: PPUSH
13863: CALL_OW 94
// end ; end ; end_of_file
13867: PPOPN 2
13869: END
// export function CustomEvent ( event ) ; begin
13870: LD_INT 0
13872: PPUSH
// end ;
13873: LD_VAR 0 2
13877: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
13878: LD_VAR 0 1
13882: PPUSH
13883: CALL 39925 0 1
// end ;
13887: PPOPN 1
13889: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13890: LD_VAR 0 1
13894: PPUSH
13895: LD_VAR 0 2
13899: PPUSH
13900: CALL 41831 0 2
// end ;
13904: PPOPN 2
13906: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13907: LD_VAR 0 1
13911: PPUSH
13912: CALL 40899 0 1
// end ;
13916: PPOPN 1
13918: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
13919: LD_VAR 0 1
13923: PUSH
13924: LD_INT 22
13926: PUSH
13927: LD_INT 8
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: LD_INT 30
13936: PUSH
13937: LD_INT 2
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PUSH
13944: LD_INT 23
13946: PUSH
13947: LD_INT 3
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: IN
13964: IFFALSE 13991
// begin ComUpgrade ( building ) ;
13966: LD_VAR 0 1
13970: PPUSH
13971: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
13975: LD_EXP 42
13979: PPUSH
13980: LD_VAR 0 1
13984: PPUSH
13985: CALL 52055 0 2
// exit ;
13989: GO 14000
// end ; MCE_BuildingComplete ( building ) ;
13991: LD_VAR 0 1
13995: PPUSH
13996: CALL 41140 0 1
// end ;
14000: PPOPN 1
14002: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14003: LD_VAR 0 1
14007: PPUSH
14008: LD_VAR 0 2
14012: PPUSH
14013: CALL 39621 0 2
// end ;
14017: PPOPN 2
14019: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14020: LD_VAR 0 1
14024: PPUSH
14025: LD_VAR 0 2
14029: PPUSH
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_VAR 0 4
14039: PPUSH
14040: LD_VAR 0 5
14044: PPUSH
14045: CALL 39241 0 5
// end ;
14049: PPOPN 5
14051: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14052: LD_VAR 0 1
14056: PPUSH
14057: LD_VAR 0 2
14061: PPUSH
14062: CALL 38831 0 2
// end ;
14066: PPOPN 2
14068: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14069: LD_VAR 0 1
14073: PPUSH
14074: LD_VAR 0 2
14078: PPUSH
14079: LD_VAR 0 3
14083: PPUSH
14084: LD_VAR 0 4
14088: PPUSH
14089: CALL 38669 0 4
// end ;
14093: PPOPN 4
14095: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14096: LD_VAR 0 1
14100: PPUSH
14101: LD_VAR 0 2
14105: PPUSH
14106: LD_VAR 0 3
14110: PPUSH
14111: CALL 38444 0 3
// end ;
14115: PPOPN 3
14117: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_VAR 0 2
14127: PPUSH
14128: CALL 38329 0 2
// end ;
14132: PPOPN 2
14134: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14135: LD_VAR 0 1
14139: PPUSH
14140: LD_VAR 0 2
14144: PPUSH
14145: CALL 42092 0 2
// end ;
14149: PPOPN 2
14151: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 255
14161: PUSH
14162: LD_INT 4
14164: EQUAL
14165: PUSH
14166: LD_VAR 0 1
14170: PUSH
14171: LD_EXP 18
14175: PUSH
14176: LD_INT 1
14178: ARRAY
14179: IN
14180: AND
14181: PUSH
14182: LD_EXP 19
14186: AND
14187: IFFALSE 14206
// begin ComMoveXY ( driver , 61 , 93 ) ;
14189: LD_VAR 0 1
14193: PPUSH
14194: LD_INT 61
14196: PPUSH
14197: LD_INT 93
14199: PPUSH
14200: CALL_OW 111
// exit ;
14204: GO 14230
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14206: LD_VAR 0 1
14210: PPUSH
14211: LD_VAR 0 2
14215: PPUSH
14216: LD_VAR 0 3
14220: PPUSH
14221: LD_VAR 0 4
14225: PPUSH
14226: CALL 42308 0 4
// end ;
14230: PPOPN 4
14232: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14233: LD_VAR 0 1
14237: PPUSH
14238: LD_VAR 0 2
14242: PPUSH
14243: CALL 38138 0 2
// end ; end_of_file
14247: PPOPN 2
14249: END
// every 0 0$30 trigger missionStage = 2 do var time ;
14250: LD_EXP 15
14254: PUSH
14255: LD_INT 2
14257: EQUAL
14258: IFFALSE 14635
14260: GO 14262
14262: DISABLE
14263: LD_INT 0
14265: PPUSH
// begin time := 0 0$10 ;
14266: LD_ADDR_VAR 0 1
14270: PUSH
14271: LD_INT 350
14273: ST_TO_ADDR
// repeat wait ( time ) ;
14274: LD_VAR 0 1
14278: PPUSH
14279: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
14283: LD_INT 1
14285: PPUSH
14286: LD_INT 5
14288: PPUSH
14289: CALL_OW 12
14293: PPUSH
14294: LD_INT 106
14296: PPUSH
14297: LD_INT 150
14299: PPUSH
14300: LD_INT 19
14302: PPUSH
14303: LD_INT 1
14305: PPUSH
14306: CALL_OW 56
// time := time + 0 0$9 ;
14310: LD_ADDR_VAR 0 1
14314: PUSH
14315: LD_VAR 0 1
14319: PUSH
14320: LD_INT 315
14322: PLUS
14323: ST_TO_ADDR
// wait ( rand ( 0 0$3 , 0 0$11 ) ) ;
14324: LD_INT 105
14326: PPUSH
14327: LD_INT 385
14329: PPUSH
14330: CALL_OW 12
14334: PPUSH
14335: CALL_OW 67
// if Prob ( 50 ) then
14339: LD_INT 50
14341: PPUSH
14342: CALL_OW 13
14346: IFFALSE 14375
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
14348: LD_INT 1
14350: PPUSH
14351: LD_INT 5
14353: PPUSH
14354: CALL_OW 12
14358: PPUSH
14359: LD_INT 62
14361: PPUSH
14362: LD_INT 108
14364: PPUSH
14365: LD_INT 10
14367: PPUSH
14368: LD_INT 1
14370: PPUSH
14371: CALL_OW 56
// until missionStage > 2 ;
14375: LD_EXP 15
14379: PUSH
14380: LD_INT 2
14382: GREATER
14383: IFFALSE 14274
// repeat wait ( 0 0$1 ) ;
14385: LD_INT 35
14387: PPUSH
14388: CALL_OW 67
// until missionStage = 6 ;
14392: LD_EXP 15
14396: PUSH
14397: LD_INT 6
14399: EQUAL
14400: IFFALSE 14385
// time := 0 0$20 ;
14402: LD_ADDR_VAR 0 1
14406: PUSH
14407: LD_INT 700
14409: ST_TO_ADDR
// repeat wait ( time ) ;
14410: LD_VAR 0 1
14414: PPUSH
14415: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 40 , true ) ;
14419: LD_INT 1
14421: PPUSH
14422: LD_INT 5
14424: PPUSH
14425: CALL_OW 12
14429: PPUSH
14430: LD_INT 106
14432: PPUSH
14433: LD_INT 89
14435: PPUSH
14436: LD_INT 40
14438: PPUSH
14439: LD_INT 1
14441: PPUSH
14442: CALL_OW 56
// time := time + 0 0$3 ;
14446: LD_ADDR_VAR 0 1
14450: PUSH
14451: LD_VAR 0 1
14455: PUSH
14456: LD_INT 105
14458: PLUS
14459: ST_TO_ADDR
// if Prob ( 30 ) then
14460: LD_INT 30
14462: PPUSH
14463: CALL_OW 13
14467: IFFALSE 14511
// begin wait ( rand ( 0 0$5 , 0 0$11 ) ) ;
14469: LD_INT 175
14471: PPUSH
14472: LD_INT 385
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
14484: LD_INT 1
14486: PPUSH
14487: LD_INT 5
14489: PPUSH
14490: CALL_OW 12
14494: PPUSH
14495: LD_INT 21
14497: PPUSH
14498: LD_INT 26
14500: PPUSH
14501: LD_INT 12
14503: PPUSH
14504: LD_INT 1
14506: PPUSH
14507: CALL_OW 56
// end ; if Prob ( 50 ) then
14511: LD_INT 50
14513: PPUSH
14514: CALL_OW 13
14518: IFFALSE 14562
// begin wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
14520: LD_INT 350
14522: PPUSH
14523: LD_INT 700
14525: PPUSH
14526: CALL_OW 12
14530: PPUSH
14531: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
14535: LD_INT 1
14537: PPUSH
14538: LD_INT 5
14540: PPUSH
14541: CALL_OW 12
14545: PPUSH
14546: LD_INT 181
14548: PPUSH
14549: LD_INT 218
14551: PPUSH
14552: LD_INT 16
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL_OW 56
// end ; if Prob ( 45 ) then
14562: LD_INT 45
14564: PPUSH
14565: CALL_OW 13
14569: IFFALSE 14613
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
14571: LD_INT 525
14573: PPUSH
14574: LD_INT 875
14576: PPUSH
14577: CALL_OW 12
14581: PPUSH
14582: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
14586: LD_INT 1
14588: PPUSH
14589: LD_INT 5
14591: PPUSH
14592: CALL_OW 12
14596: PPUSH
14597: LD_INT 103
14599: PPUSH
14600: LD_INT 140
14602: PPUSH
14603: LD_INT 20
14605: PPUSH
14606: LD_INT 1
14608: PPUSH
14609: CALL_OW 56
// end ; if time > 3 3$20 then
14613: LD_VAR 0 1
14617: PUSH
14618: LD_INT 7000
14620: GREATER
14621: IFFALSE 14631
// time := 0 0$40 ;
14623: LD_ADDR_VAR 0 1
14627: PUSH
14628: LD_INT 1400
14630: ST_TO_ADDR
// until false ;
14631: LD_INT 0
14633: IFFALSE 14410
// end ; end_of_file
14635: PPOPN 1
14637: END
// every 0 0$1 trigger missionStart do
14638: LD_EXP 13
14642: IFFALSE 14689
14644: GO 14646
14646: DISABLE
// begin enable ;
14647: ENABLE
// missionTime := missionTime + 0 0$1 ;
14648: LD_ADDR_EXP 14
14652: PUSH
14653: LD_EXP 14
14657: PUSH
14658: LD_INT 35
14660: PLUS
14661: ST_TO_ADDR
// if missionStage >= 6 then
14662: LD_EXP 15
14666: PUSH
14667: LD_INT 6
14669: GREATEREQUAL
14670: IFFALSE 14689
// display_strings = [ #Am15-1 , missionTime ] ;
14672: LD_ADDR_OWVAR 47
14676: PUSH
14677: LD_STRING #Am15-1
14679: PUSH
14680: LD_EXP 14
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: ST_TO_ADDR
// end ; end_of_file
14689: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
14690: GO 14692
14692: DISABLE
// begin ru_radar := 98 ;
14693: LD_ADDR_EXP 64
14697: PUSH
14698: LD_INT 98
14700: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
14701: LD_ADDR_EXP 65
14705: PUSH
14706: LD_INT 89
14708: ST_TO_ADDR
// us_hack := 99 ;
14709: LD_ADDR_EXP 66
14713: PUSH
14714: LD_INT 99
14716: ST_TO_ADDR
// us_artillery := 97 ;
14717: LD_ADDR_EXP 67
14721: PUSH
14722: LD_INT 97
14724: ST_TO_ADDR
// ar_bio_bomb := 91 ;
14725: LD_ADDR_EXP 68
14729: PUSH
14730: LD_INT 91
14732: ST_TO_ADDR
// end ; end_of_file
14733: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
14734: LD_INT 0
14736: PPUSH
14737: PPUSH
// skirmish := false ;
14738: LD_ADDR_EXP 69
14742: PUSH
14743: LD_INT 0
14745: ST_TO_ADDR
// debug_mc := false ;
14746: LD_ADDR_EXP 70
14750: PUSH
14751: LD_INT 0
14753: ST_TO_ADDR
// mc_bases := [ ] ;
14754: LD_ADDR_EXP 71
14758: PUSH
14759: EMPTY
14760: ST_TO_ADDR
// mc_sides := [ ] ;
14761: LD_ADDR_EXP 97
14765: PUSH
14766: EMPTY
14767: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
14768: LD_ADDR_EXP 72
14772: PUSH
14773: EMPTY
14774: ST_TO_ADDR
// mc_building_repairs := [ ] ;
14775: LD_ADDR_EXP 73
14779: PUSH
14780: EMPTY
14781: ST_TO_ADDR
// mc_need_heal := [ ] ;
14782: LD_ADDR_EXP 74
14786: PUSH
14787: EMPTY
14788: ST_TO_ADDR
// mc_healers := [ ] ;
14789: LD_ADDR_EXP 75
14793: PUSH
14794: EMPTY
14795: ST_TO_ADDR
// mc_build_list := [ ] ;
14796: LD_ADDR_EXP 76
14800: PUSH
14801: EMPTY
14802: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
14803: LD_ADDR_EXP 103
14807: PUSH
14808: EMPTY
14809: ST_TO_ADDR
// mc_builders := [ ] ;
14810: LD_ADDR_EXP 77
14814: PUSH
14815: EMPTY
14816: ST_TO_ADDR
// mc_construct_list := [ ] ;
14817: LD_ADDR_EXP 78
14821: PUSH
14822: EMPTY
14823: ST_TO_ADDR
// mc_turret_list := [ ] ;
14824: LD_ADDR_EXP 79
14828: PUSH
14829: EMPTY
14830: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
14831: LD_ADDR_EXP 80
14835: PUSH
14836: EMPTY
14837: ST_TO_ADDR
// mc_miners := [ ] ;
14838: LD_ADDR_EXP 85
14842: PUSH
14843: EMPTY
14844: ST_TO_ADDR
// mc_mines := [ ] ;
14845: LD_ADDR_EXP 84
14849: PUSH
14850: EMPTY
14851: ST_TO_ADDR
// mc_minefields := [ ] ;
14852: LD_ADDR_EXP 86
14856: PUSH
14857: EMPTY
14858: ST_TO_ADDR
// mc_crates := [ ] ;
14859: LD_ADDR_EXP 87
14863: PUSH
14864: EMPTY
14865: ST_TO_ADDR
// mc_crates_collector := [ ] ;
14866: LD_ADDR_EXP 88
14870: PUSH
14871: EMPTY
14872: ST_TO_ADDR
// mc_crates_area := [ ] ;
14873: LD_ADDR_EXP 89
14877: PUSH
14878: EMPTY
14879: ST_TO_ADDR
// mc_vehicles := [ ] ;
14880: LD_ADDR_EXP 90
14884: PUSH
14885: EMPTY
14886: ST_TO_ADDR
// mc_attack := [ ] ;
14887: LD_ADDR_EXP 91
14891: PUSH
14892: EMPTY
14893: ST_TO_ADDR
// mc_produce := [ ] ;
14894: LD_ADDR_EXP 92
14898: PUSH
14899: EMPTY
14900: ST_TO_ADDR
// mc_defender := [ ] ;
14901: LD_ADDR_EXP 93
14905: PUSH
14906: EMPTY
14907: ST_TO_ADDR
// mc_parking := [ ] ;
14908: LD_ADDR_EXP 95
14912: PUSH
14913: EMPTY
14914: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
14915: LD_ADDR_EXP 81
14919: PUSH
14920: EMPTY
14921: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
14922: LD_ADDR_EXP 83
14926: PUSH
14927: EMPTY
14928: ST_TO_ADDR
// mc_scan := [ ] ;
14929: LD_ADDR_EXP 94
14933: PUSH
14934: EMPTY
14935: ST_TO_ADDR
// mc_scan_area := [ ] ;
14936: LD_ADDR_EXP 96
14940: PUSH
14941: EMPTY
14942: ST_TO_ADDR
// mc_tech := [ ] ;
14943: LD_ADDR_EXP 98
14947: PUSH
14948: EMPTY
14949: ST_TO_ADDR
// mc_class := [ ] ;
14950: LD_ADDR_EXP 112
14954: PUSH
14955: EMPTY
14956: ST_TO_ADDR
// mc_class_case_use := [ ] ;
14957: LD_ADDR_EXP 113
14961: PUSH
14962: EMPTY
14963: ST_TO_ADDR
// end ;
14964: LD_VAR 0 1
14968: RET
// export function MC_Kill ( base ) ; begin
14969: LD_INT 0
14971: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
14972: LD_ADDR_EXP 71
14976: PUSH
14977: LD_EXP 71
14981: PPUSH
14982: LD_VAR 0 1
14986: PPUSH
14987: EMPTY
14988: PPUSH
14989: CALL_OW 1
14993: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
14994: LD_ADDR_EXP 72
14998: PUSH
14999: LD_EXP 72
15003: PPUSH
15004: LD_VAR 0 1
15008: PPUSH
15009: EMPTY
15010: PPUSH
15011: CALL_OW 1
15015: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
15016: LD_ADDR_EXP 73
15020: PUSH
15021: LD_EXP 73
15025: PPUSH
15026: LD_VAR 0 1
15030: PPUSH
15031: EMPTY
15032: PPUSH
15033: CALL_OW 1
15037: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
15038: LD_ADDR_EXP 74
15042: PUSH
15043: LD_EXP 74
15047: PPUSH
15048: LD_VAR 0 1
15052: PPUSH
15053: EMPTY
15054: PPUSH
15055: CALL_OW 1
15059: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
15060: LD_ADDR_EXP 75
15064: PUSH
15065: LD_EXP 75
15069: PPUSH
15070: LD_VAR 0 1
15074: PPUSH
15075: EMPTY
15076: PPUSH
15077: CALL_OW 1
15081: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
15082: LD_ADDR_EXP 76
15086: PUSH
15087: LD_EXP 76
15091: PPUSH
15092: LD_VAR 0 1
15096: PPUSH
15097: EMPTY
15098: PPUSH
15099: CALL_OW 1
15103: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
15104: LD_ADDR_EXP 77
15108: PUSH
15109: LD_EXP 77
15113: PPUSH
15114: LD_VAR 0 1
15118: PPUSH
15119: EMPTY
15120: PPUSH
15121: CALL_OW 1
15125: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
15126: LD_ADDR_EXP 78
15130: PUSH
15131: LD_EXP 78
15135: PPUSH
15136: LD_VAR 0 1
15140: PPUSH
15141: EMPTY
15142: PPUSH
15143: CALL_OW 1
15147: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
15148: LD_ADDR_EXP 79
15152: PUSH
15153: LD_EXP 79
15157: PPUSH
15158: LD_VAR 0 1
15162: PPUSH
15163: EMPTY
15164: PPUSH
15165: CALL_OW 1
15169: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
15170: LD_ADDR_EXP 80
15174: PUSH
15175: LD_EXP 80
15179: PPUSH
15180: LD_VAR 0 1
15184: PPUSH
15185: EMPTY
15186: PPUSH
15187: CALL_OW 1
15191: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
15192: LD_ADDR_EXP 81
15196: PUSH
15197: LD_EXP 81
15201: PPUSH
15202: LD_VAR 0 1
15206: PPUSH
15207: EMPTY
15208: PPUSH
15209: CALL_OW 1
15213: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
15214: LD_ADDR_EXP 82
15218: PUSH
15219: LD_EXP 82
15223: PPUSH
15224: LD_VAR 0 1
15228: PPUSH
15229: LD_INT 0
15231: PPUSH
15232: CALL_OW 1
15236: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
15237: LD_ADDR_EXP 83
15241: PUSH
15242: LD_EXP 83
15246: PPUSH
15247: LD_VAR 0 1
15251: PPUSH
15252: EMPTY
15253: PPUSH
15254: CALL_OW 1
15258: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
15259: LD_ADDR_EXP 84
15263: PUSH
15264: LD_EXP 84
15268: PPUSH
15269: LD_VAR 0 1
15273: PPUSH
15274: EMPTY
15275: PPUSH
15276: CALL_OW 1
15280: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
15281: LD_ADDR_EXP 85
15285: PUSH
15286: LD_EXP 85
15290: PPUSH
15291: LD_VAR 0 1
15295: PPUSH
15296: EMPTY
15297: PPUSH
15298: CALL_OW 1
15302: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
15303: LD_ADDR_EXP 86
15307: PUSH
15308: LD_EXP 86
15312: PPUSH
15313: LD_VAR 0 1
15317: PPUSH
15318: EMPTY
15319: PPUSH
15320: CALL_OW 1
15324: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
15325: LD_ADDR_EXP 87
15329: PUSH
15330: LD_EXP 87
15334: PPUSH
15335: LD_VAR 0 1
15339: PPUSH
15340: EMPTY
15341: PPUSH
15342: CALL_OW 1
15346: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
15347: LD_ADDR_EXP 88
15351: PUSH
15352: LD_EXP 88
15356: PPUSH
15357: LD_VAR 0 1
15361: PPUSH
15362: EMPTY
15363: PPUSH
15364: CALL_OW 1
15368: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
15369: LD_ADDR_EXP 89
15373: PUSH
15374: LD_EXP 89
15378: PPUSH
15379: LD_VAR 0 1
15383: PPUSH
15384: EMPTY
15385: PPUSH
15386: CALL_OW 1
15390: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
15391: LD_ADDR_EXP 90
15395: PUSH
15396: LD_EXP 90
15400: PPUSH
15401: LD_VAR 0 1
15405: PPUSH
15406: EMPTY
15407: PPUSH
15408: CALL_OW 1
15412: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
15413: LD_ADDR_EXP 91
15417: PUSH
15418: LD_EXP 91
15422: PPUSH
15423: LD_VAR 0 1
15427: PPUSH
15428: EMPTY
15429: PPUSH
15430: CALL_OW 1
15434: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
15435: LD_ADDR_EXP 92
15439: PUSH
15440: LD_EXP 92
15444: PPUSH
15445: LD_VAR 0 1
15449: PPUSH
15450: EMPTY
15451: PPUSH
15452: CALL_OW 1
15456: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
15457: LD_ADDR_EXP 93
15461: PUSH
15462: LD_EXP 93
15466: PPUSH
15467: LD_VAR 0 1
15471: PPUSH
15472: EMPTY
15473: PPUSH
15474: CALL_OW 1
15478: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
15479: LD_ADDR_EXP 94
15483: PUSH
15484: LD_EXP 94
15488: PPUSH
15489: LD_VAR 0 1
15493: PPUSH
15494: EMPTY
15495: PPUSH
15496: CALL_OW 1
15500: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
15501: LD_ADDR_EXP 95
15505: PUSH
15506: LD_EXP 95
15510: PPUSH
15511: LD_VAR 0 1
15515: PPUSH
15516: EMPTY
15517: PPUSH
15518: CALL_OW 1
15522: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
15523: LD_ADDR_EXP 96
15527: PUSH
15528: LD_EXP 96
15532: PPUSH
15533: LD_VAR 0 1
15537: PPUSH
15538: EMPTY
15539: PPUSH
15540: CALL_OW 1
15544: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
15545: LD_ADDR_EXP 98
15549: PUSH
15550: LD_EXP 98
15554: PPUSH
15555: LD_VAR 0 1
15559: PPUSH
15560: EMPTY
15561: PPUSH
15562: CALL_OW 1
15566: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
15567: LD_ADDR_EXP 100
15571: PUSH
15572: LD_EXP 100
15576: PPUSH
15577: LD_VAR 0 1
15581: PPUSH
15582: EMPTY
15583: PPUSH
15584: CALL_OW 1
15588: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
15589: LD_ADDR_EXP 101
15593: PUSH
15594: LD_EXP 101
15598: PPUSH
15599: LD_VAR 0 1
15603: PPUSH
15604: EMPTY
15605: PPUSH
15606: CALL_OW 1
15610: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
15611: LD_ADDR_EXP 102
15615: PUSH
15616: LD_EXP 102
15620: PPUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: EMPTY
15627: PPUSH
15628: CALL_OW 1
15632: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
15633: LD_ADDR_EXP 103
15637: PUSH
15638: LD_EXP 103
15642: PPUSH
15643: LD_VAR 0 1
15647: PPUSH
15648: EMPTY
15649: PPUSH
15650: CALL_OW 1
15654: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
15655: LD_ADDR_EXP 104
15659: PUSH
15660: LD_EXP 104
15664: PPUSH
15665: LD_VAR 0 1
15669: PPUSH
15670: EMPTY
15671: PPUSH
15672: CALL_OW 1
15676: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
15677: LD_ADDR_EXP 105
15681: PUSH
15682: LD_EXP 105
15686: PPUSH
15687: LD_VAR 0 1
15691: PPUSH
15692: EMPTY
15693: PPUSH
15694: CALL_OW 1
15698: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
15699: LD_ADDR_EXP 106
15703: PUSH
15704: LD_EXP 106
15708: PPUSH
15709: LD_VAR 0 1
15713: PPUSH
15714: EMPTY
15715: PPUSH
15716: CALL_OW 1
15720: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
15721: LD_ADDR_EXP 107
15725: PUSH
15726: LD_EXP 107
15730: PPUSH
15731: LD_VAR 0 1
15735: PPUSH
15736: EMPTY
15737: PPUSH
15738: CALL_OW 1
15742: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
15743: LD_ADDR_EXP 108
15747: PUSH
15748: LD_EXP 108
15752: PPUSH
15753: LD_VAR 0 1
15757: PPUSH
15758: EMPTY
15759: PPUSH
15760: CALL_OW 1
15764: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
15765: LD_ADDR_EXP 109
15769: PUSH
15770: LD_EXP 109
15774: PPUSH
15775: LD_VAR 0 1
15779: PPUSH
15780: EMPTY
15781: PPUSH
15782: CALL_OW 1
15786: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
15787: LD_ADDR_EXP 110
15791: PUSH
15792: LD_EXP 110
15796: PPUSH
15797: LD_VAR 0 1
15801: PPUSH
15802: EMPTY
15803: PPUSH
15804: CALL_OW 1
15808: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
15809: LD_ADDR_EXP 111
15813: PUSH
15814: LD_EXP 111
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: EMPTY
15825: PPUSH
15826: CALL_OW 1
15830: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
15831: LD_ADDR_EXP 112
15835: PUSH
15836: LD_EXP 112
15840: PPUSH
15841: LD_VAR 0 1
15845: PPUSH
15846: EMPTY
15847: PPUSH
15848: CALL_OW 1
15852: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
15853: LD_ADDR_EXP 113
15857: PUSH
15858: LD_EXP 113
15862: PPUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 0
15870: PPUSH
15871: CALL_OW 1
15875: ST_TO_ADDR
// end ;
15876: LD_VAR 0 2
15880: RET
// export function MC_Start ( ) ; var i ; begin
15881: LD_INT 0
15883: PPUSH
15884: PPUSH
// for i = 1 to mc_bases do
15885: LD_ADDR_VAR 0 2
15889: PUSH
15890: DOUBLE
15891: LD_INT 1
15893: DEC
15894: ST_TO_ADDR
15895: LD_EXP 71
15899: PUSH
15900: FOR_TO
15901: IFFALSE 16978
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
15903: LD_ADDR_EXP 71
15907: PUSH
15908: LD_EXP 71
15912: PPUSH
15913: LD_VAR 0 2
15917: PPUSH
15918: LD_EXP 71
15922: PUSH
15923: LD_VAR 0 2
15927: ARRAY
15928: PUSH
15929: LD_INT 0
15931: DIFF
15932: PPUSH
15933: CALL_OW 1
15937: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
15938: LD_ADDR_EXP 72
15942: PUSH
15943: LD_EXP 72
15947: PPUSH
15948: LD_VAR 0 2
15952: PPUSH
15953: EMPTY
15954: PPUSH
15955: CALL_OW 1
15959: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
15960: LD_ADDR_EXP 73
15964: PUSH
15965: LD_EXP 73
15969: PPUSH
15970: LD_VAR 0 2
15974: PPUSH
15975: EMPTY
15976: PPUSH
15977: CALL_OW 1
15981: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
15982: LD_ADDR_EXP 74
15986: PUSH
15987: LD_EXP 74
15991: PPUSH
15992: LD_VAR 0 2
15996: PPUSH
15997: EMPTY
15998: PPUSH
15999: CALL_OW 1
16003: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
16004: LD_ADDR_EXP 75
16008: PUSH
16009: LD_EXP 75
16013: PPUSH
16014: LD_VAR 0 2
16018: PPUSH
16019: EMPTY
16020: PUSH
16021: EMPTY
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PPUSH
16027: CALL_OW 1
16031: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
16032: LD_ADDR_EXP 76
16036: PUSH
16037: LD_EXP 76
16041: PPUSH
16042: LD_VAR 0 2
16046: PPUSH
16047: EMPTY
16048: PPUSH
16049: CALL_OW 1
16053: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
16054: LD_ADDR_EXP 103
16058: PUSH
16059: LD_EXP 103
16063: PPUSH
16064: LD_VAR 0 2
16068: PPUSH
16069: EMPTY
16070: PPUSH
16071: CALL_OW 1
16075: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
16076: LD_ADDR_EXP 77
16080: PUSH
16081: LD_EXP 77
16085: PPUSH
16086: LD_VAR 0 2
16090: PPUSH
16091: EMPTY
16092: PPUSH
16093: CALL_OW 1
16097: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
16098: LD_ADDR_EXP 78
16102: PUSH
16103: LD_EXP 78
16107: PPUSH
16108: LD_VAR 0 2
16112: PPUSH
16113: EMPTY
16114: PPUSH
16115: CALL_OW 1
16119: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
16120: LD_ADDR_EXP 79
16124: PUSH
16125: LD_EXP 79
16129: PPUSH
16130: LD_VAR 0 2
16134: PPUSH
16135: LD_EXP 71
16139: PUSH
16140: LD_VAR 0 2
16144: ARRAY
16145: PPUSH
16146: LD_INT 2
16148: PUSH
16149: LD_INT 30
16151: PUSH
16152: LD_INT 32
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: PUSH
16159: LD_INT 30
16161: PUSH
16162: LD_INT 33
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: LIST
16173: PPUSH
16174: CALL_OW 72
16178: PPUSH
16179: CALL_OW 1
16183: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
16184: LD_ADDR_EXP 80
16188: PUSH
16189: LD_EXP 80
16193: PPUSH
16194: LD_VAR 0 2
16198: PPUSH
16199: LD_EXP 71
16203: PUSH
16204: LD_VAR 0 2
16208: ARRAY
16209: PPUSH
16210: LD_INT 2
16212: PUSH
16213: LD_INT 30
16215: PUSH
16216: LD_INT 32
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: LD_INT 30
16225: PUSH
16226: LD_INT 31
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: LIST
16237: PUSH
16238: LD_INT 58
16240: PUSH
16241: EMPTY
16242: LIST
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: PPUSH
16248: CALL_OW 72
16252: PPUSH
16253: CALL_OW 1
16257: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
16258: LD_ADDR_EXP 81
16262: PUSH
16263: LD_EXP 81
16267: PPUSH
16268: LD_VAR 0 2
16272: PPUSH
16273: EMPTY
16274: PPUSH
16275: CALL_OW 1
16279: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
16280: LD_ADDR_EXP 85
16284: PUSH
16285: LD_EXP 85
16289: PPUSH
16290: LD_VAR 0 2
16294: PPUSH
16295: EMPTY
16296: PPUSH
16297: CALL_OW 1
16301: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
16302: LD_ADDR_EXP 84
16306: PUSH
16307: LD_EXP 84
16311: PPUSH
16312: LD_VAR 0 2
16316: PPUSH
16317: EMPTY
16318: PPUSH
16319: CALL_OW 1
16323: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
16324: LD_ADDR_EXP 86
16328: PUSH
16329: LD_EXP 86
16333: PPUSH
16334: LD_VAR 0 2
16338: PPUSH
16339: EMPTY
16340: PPUSH
16341: CALL_OW 1
16345: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
16346: LD_ADDR_EXP 87
16350: PUSH
16351: LD_EXP 87
16355: PPUSH
16356: LD_VAR 0 2
16360: PPUSH
16361: EMPTY
16362: PPUSH
16363: CALL_OW 1
16367: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
16368: LD_ADDR_EXP 88
16372: PUSH
16373: LD_EXP 88
16377: PPUSH
16378: LD_VAR 0 2
16382: PPUSH
16383: EMPTY
16384: PPUSH
16385: CALL_OW 1
16389: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
16390: LD_ADDR_EXP 89
16394: PUSH
16395: LD_EXP 89
16399: PPUSH
16400: LD_VAR 0 2
16404: PPUSH
16405: EMPTY
16406: PPUSH
16407: CALL_OW 1
16411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
16412: LD_ADDR_EXP 90
16416: PUSH
16417: LD_EXP 90
16421: PPUSH
16422: LD_VAR 0 2
16426: PPUSH
16427: EMPTY
16428: PPUSH
16429: CALL_OW 1
16433: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
16434: LD_ADDR_EXP 91
16438: PUSH
16439: LD_EXP 91
16443: PPUSH
16444: LD_VAR 0 2
16448: PPUSH
16449: EMPTY
16450: PPUSH
16451: CALL_OW 1
16455: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
16456: LD_ADDR_EXP 92
16460: PUSH
16461: LD_EXP 92
16465: PPUSH
16466: LD_VAR 0 2
16470: PPUSH
16471: EMPTY
16472: PPUSH
16473: CALL_OW 1
16477: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
16478: LD_ADDR_EXP 93
16482: PUSH
16483: LD_EXP 93
16487: PPUSH
16488: LD_VAR 0 2
16492: PPUSH
16493: EMPTY
16494: PPUSH
16495: CALL_OW 1
16499: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
16500: LD_ADDR_EXP 82
16504: PUSH
16505: LD_EXP 82
16509: PPUSH
16510: LD_VAR 0 2
16514: PPUSH
16515: LD_INT 0
16517: PPUSH
16518: CALL_OW 1
16522: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
16523: LD_ADDR_EXP 95
16527: PUSH
16528: LD_EXP 95
16532: PPUSH
16533: LD_VAR 0 2
16537: PPUSH
16538: LD_INT 0
16540: PPUSH
16541: CALL_OW 1
16545: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
16546: LD_ADDR_EXP 83
16550: PUSH
16551: LD_EXP 83
16555: PPUSH
16556: LD_VAR 0 2
16560: PPUSH
16561: EMPTY
16562: PPUSH
16563: CALL_OW 1
16567: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
16568: LD_ADDR_EXP 94
16572: PUSH
16573: LD_EXP 94
16577: PPUSH
16578: LD_VAR 0 2
16582: PPUSH
16583: LD_INT 0
16585: PPUSH
16586: CALL_OW 1
16590: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
16591: LD_ADDR_EXP 96
16595: PUSH
16596: LD_EXP 96
16600: PPUSH
16601: LD_VAR 0 2
16605: PPUSH
16606: EMPTY
16607: PPUSH
16608: CALL_OW 1
16612: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
16613: LD_ADDR_EXP 99
16617: PUSH
16618: LD_EXP 99
16622: PPUSH
16623: LD_VAR 0 2
16627: PPUSH
16628: LD_INT 0
16630: PPUSH
16631: CALL_OW 1
16635: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
16636: LD_ADDR_EXP 100
16640: PUSH
16641: LD_EXP 100
16645: PPUSH
16646: LD_VAR 0 2
16650: PPUSH
16651: EMPTY
16652: PPUSH
16653: CALL_OW 1
16657: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
16658: LD_ADDR_EXP 101
16662: PUSH
16663: LD_EXP 101
16667: PPUSH
16668: LD_VAR 0 2
16672: PPUSH
16673: EMPTY
16674: PPUSH
16675: CALL_OW 1
16679: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
16680: LD_ADDR_EXP 102
16684: PUSH
16685: LD_EXP 102
16689: PPUSH
16690: LD_VAR 0 2
16694: PPUSH
16695: EMPTY
16696: PPUSH
16697: CALL_OW 1
16701: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
16702: LD_ADDR_EXP 104
16706: PUSH
16707: LD_EXP 104
16711: PPUSH
16712: LD_VAR 0 2
16716: PPUSH
16717: LD_EXP 71
16721: PUSH
16722: LD_VAR 0 2
16726: ARRAY
16727: PPUSH
16728: LD_INT 2
16730: PUSH
16731: LD_INT 30
16733: PUSH
16734: LD_INT 6
16736: PUSH
16737: EMPTY
16738: LIST
16739: LIST
16740: PUSH
16741: LD_INT 30
16743: PUSH
16744: LD_INT 7
16746: PUSH
16747: EMPTY
16748: LIST
16749: LIST
16750: PUSH
16751: LD_INT 30
16753: PUSH
16754: LD_INT 8
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: PUSH
16761: EMPTY
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: PPUSH
16767: CALL_OW 72
16771: PPUSH
16772: CALL_OW 1
16776: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
16777: LD_ADDR_EXP 105
16781: PUSH
16782: LD_EXP 105
16786: PPUSH
16787: LD_VAR 0 2
16791: PPUSH
16792: EMPTY
16793: PPUSH
16794: CALL_OW 1
16798: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
16799: LD_ADDR_EXP 106
16803: PUSH
16804: LD_EXP 106
16808: PPUSH
16809: LD_VAR 0 2
16813: PPUSH
16814: EMPTY
16815: PPUSH
16816: CALL_OW 1
16820: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
16821: LD_ADDR_EXP 107
16825: PUSH
16826: LD_EXP 107
16830: PPUSH
16831: LD_VAR 0 2
16835: PPUSH
16836: EMPTY
16837: PPUSH
16838: CALL_OW 1
16842: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
16843: LD_ADDR_EXP 108
16847: PUSH
16848: LD_EXP 108
16852: PPUSH
16853: LD_VAR 0 2
16857: PPUSH
16858: EMPTY
16859: PPUSH
16860: CALL_OW 1
16864: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
16865: LD_ADDR_EXP 109
16869: PUSH
16870: LD_EXP 109
16874: PPUSH
16875: LD_VAR 0 2
16879: PPUSH
16880: EMPTY
16881: PPUSH
16882: CALL_OW 1
16886: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
16887: LD_ADDR_EXP 110
16891: PUSH
16892: LD_EXP 110
16896: PPUSH
16897: LD_VAR 0 2
16901: PPUSH
16902: EMPTY
16903: PPUSH
16904: CALL_OW 1
16908: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
16909: LD_ADDR_EXP 111
16913: PUSH
16914: LD_EXP 111
16918: PPUSH
16919: LD_VAR 0 2
16923: PPUSH
16924: EMPTY
16925: PPUSH
16926: CALL_OW 1
16930: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
16931: LD_ADDR_EXP 112
16935: PUSH
16936: LD_EXP 112
16940: PPUSH
16941: LD_VAR 0 2
16945: PPUSH
16946: EMPTY
16947: PPUSH
16948: CALL_OW 1
16952: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
16953: LD_ADDR_EXP 113
16957: PUSH
16958: LD_EXP 113
16962: PPUSH
16963: LD_VAR 0 2
16967: PPUSH
16968: LD_INT 0
16970: PPUSH
16971: CALL_OW 1
16975: ST_TO_ADDR
// end ;
16976: GO 15900
16978: POP
16979: POP
// MC_InitSides ( ) ;
16980: CALL 17266 0 0
// MC_InitResearch ( ) ;
16984: CALL 17005 0 0
// CustomInitMacro ( ) ;
16988: CALL 315 0 0
// skirmish := true ;
16992: LD_ADDR_EXP 69
16996: PUSH
16997: LD_INT 1
16999: ST_TO_ADDR
// end ;
17000: LD_VAR 0 1
17004: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
17005: LD_INT 0
17007: PPUSH
17008: PPUSH
17009: PPUSH
17010: PPUSH
17011: PPUSH
17012: PPUSH
// if not mc_bases then
17013: LD_EXP 71
17017: NOT
17018: IFFALSE 17022
// exit ;
17020: GO 17261
// for i = 1 to 8 do
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: DOUBLE
17028: LD_INT 1
17030: DEC
17031: ST_TO_ADDR
17032: LD_INT 8
17034: PUSH
17035: FOR_TO
17036: IFFALSE 17062
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
17038: LD_ADDR_EXP 98
17042: PUSH
17043: LD_EXP 98
17047: PPUSH
17048: LD_VAR 0 2
17052: PPUSH
17053: EMPTY
17054: PPUSH
17055: CALL_OW 1
17059: ST_TO_ADDR
17060: GO 17035
17062: POP
17063: POP
// tmp := [ ] ;
17064: LD_ADDR_VAR 0 5
17068: PUSH
17069: EMPTY
17070: ST_TO_ADDR
// for i = 1 to mc_sides do
17071: LD_ADDR_VAR 0 2
17075: PUSH
17076: DOUBLE
17077: LD_INT 1
17079: DEC
17080: ST_TO_ADDR
17081: LD_EXP 97
17085: PUSH
17086: FOR_TO
17087: IFFALSE 17145
// if not mc_sides [ i ] in tmp then
17089: LD_EXP 97
17093: PUSH
17094: LD_VAR 0 2
17098: ARRAY
17099: PUSH
17100: LD_VAR 0 5
17104: IN
17105: NOT
17106: IFFALSE 17143
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
17108: LD_ADDR_VAR 0 5
17112: PUSH
17113: LD_VAR 0 5
17117: PPUSH
17118: LD_VAR 0 5
17122: PUSH
17123: LD_INT 1
17125: PLUS
17126: PPUSH
17127: LD_EXP 97
17131: PUSH
17132: LD_VAR 0 2
17136: ARRAY
17137: PPUSH
17138: CALL_OW 2
17142: ST_TO_ADDR
17143: GO 17086
17145: POP
17146: POP
// if not tmp then
17147: LD_VAR 0 5
17151: NOT
17152: IFFALSE 17156
// exit ;
17154: GO 17261
// for j in tmp do
17156: LD_ADDR_VAR 0 3
17160: PUSH
17161: LD_VAR 0 5
17165: PUSH
17166: FOR_IN
17167: IFFALSE 17259
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
17169: LD_ADDR_VAR 0 6
17173: PUSH
17174: LD_INT 22
17176: PUSH
17177: LD_VAR 0 3
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: PPUSH
17186: CALL_OW 69
17190: ST_TO_ADDR
// if not un then
17191: LD_VAR 0 6
17195: NOT
17196: IFFALSE 17200
// continue ;
17198: GO 17166
// nation := GetNation ( un [ 1 ] ) ;
17200: LD_ADDR_VAR 0 4
17204: PUSH
17205: LD_VAR 0 6
17209: PUSH
17210: LD_INT 1
17212: ARRAY
17213: PPUSH
17214: CALL_OW 248
17218: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
17219: LD_ADDR_EXP 98
17223: PUSH
17224: LD_EXP 98
17228: PPUSH
17229: LD_VAR 0 3
17233: PPUSH
17234: LD_VAR 0 3
17238: PPUSH
17239: LD_VAR 0 4
17243: PPUSH
17244: LD_INT 1
17246: PPUSH
17247: CALL 42512 0 3
17251: PPUSH
17252: CALL_OW 1
17256: ST_TO_ADDR
// end ;
17257: GO 17166
17259: POP
17260: POP
// end ;
17261: LD_VAR 0 1
17265: RET
// export function MC_InitSides ( ) ; var i ; begin
17266: LD_INT 0
17268: PPUSH
17269: PPUSH
// if not mc_bases then
17270: LD_EXP 71
17274: NOT
17275: IFFALSE 17279
// exit ;
17277: GO 17353
// for i = 1 to mc_bases do
17279: LD_ADDR_VAR 0 2
17283: PUSH
17284: DOUBLE
17285: LD_INT 1
17287: DEC
17288: ST_TO_ADDR
17289: LD_EXP 71
17293: PUSH
17294: FOR_TO
17295: IFFALSE 17351
// if mc_bases [ i ] then
17297: LD_EXP 71
17301: PUSH
17302: LD_VAR 0 2
17306: ARRAY
17307: IFFALSE 17349
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
17309: LD_ADDR_EXP 97
17313: PUSH
17314: LD_EXP 97
17318: PPUSH
17319: LD_VAR 0 2
17323: PPUSH
17324: LD_EXP 71
17328: PUSH
17329: LD_VAR 0 2
17333: ARRAY
17334: PUSH
17335: LD_INT 1
17337: ARRAY
17338: PPUSH
17339: CALL_OW 255
17343: PPUSH
17344: CALL_OW 1
17348: ST_TO_ADDR
17349: GO 17294
17351: POP
17352: POP
// end ;
17353: LD_VAR 0 1
17357: RET
// every 0 0$01 trigger skirmish do
17358: LD_EXP 69
17362: IFFALSE 17516
17364: GO 17366
17366: DISABLE
// begin enable ;
17367: ENABLE
// MC_CheckBuildings ( ) ;
17368: CALL 21682 0 0
// MC_CheckPeopleLife ( ) ;
17372: CALL 21807 0 0
// RaiseSailEvent ( 100 ) ;
17376: LD_INT 100
17378: PPUSH
17379: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
17383: LD_INT 103
17385: PPUSH
17386: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
17390: LD_INT 104
17392: PPUSH
17393: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
17397: LD_INT 105
17399: PPUSH
17400: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
17404: LD_INT 106
17406: PPUSH
17407: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
17411: LD_INT 107
17413: PPUSH
17414: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
17418: LD_INT 108
17420: PPUSH
17421: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
17425: LD_INT 109
17427: PPUSH
17428: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
17432: LD_INT 110
17434: PPUSH
17435: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
17439: LD_INT 111
17441: PPUSH
17442: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
17446: LD_INT 112
17448: PPUSH
17449: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
17453: LD_INT 113
17455: PPUSH
17456: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
17460: LD_INT 120
17462: PPUSH
17463: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
17467: LD_INT 121
17469: PPUSH
17470: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
17474: LD_INT 122
17476: PPUSH
17477: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
17481: LD_INT 123
17483: PPUSH
17484: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
17488: LD_INT 124
17490: PPUSH
17491: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
17495: LD_INT 125
17497: PPUSH
17498: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
17502: LD_INT 126
17504: PPUSH
17505: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
17509: LD_INT 200
17511: PPUSH
17512: CALL_OW 427
// end ;
17516: END
// on SailEvent ( event ) do begin if event < 100 then
17517: LD_VAR 0 1
17521: PUSH
17522: LD_INT 100
17524: LESS
17525: IFFALSE 17536
// CustomEvent ( event ) ;
17527: LD_VAR 0 1
17531: PPUSH
17532: CALL 13870 0 1
// if event = 100 then
17536: LD_VAR 0 1
17540: PUSH
17541: LD_INT 100
17543: EQUAL
17544: IFFALSE 17550
// MC_ClassManager ( ) ;
17546: CALL 17942 0 0
// if event = 101 then
17550: LD_VAR 0 1
17554: PUSH
17555: LD_INT 101
17557: EQUAL
17558: IFFALSE 17564
// MC_RepairBuildings ( ) ;
17560: CALL 22403 0 0
// if event = 102 then
17564: LD_VAR 0 1
17568: PUSH
17569: LD_INT 102
17571: EQUAL
17572: IFFALSE 17578
// MC_Heal ( ) ;
17574: CALL 22809 0 0
// if event = 103 then
17578: LD_VAR 0 1
17582: PUSH
17583: LD_INT 103
17585: EQUAL
17586: IFFALSE 17592
// MC_Build ( ) ;
17588: CALL 23231 0 0
// if event = 104 then
17592: LD_VAR 0 1
17596: PUSH
17597: LD_INT 104
17599: EQUAL
17600: IFFALSE 17606
// MC_TurretWeapon ( ) ;
17602: CALL 24844 0 0
// if event = 105 then
17606: LD_VAR 0 1
17610: PUSH
17611: LD_INT 105
17613: EQUAL
17614: IFFALSE 17620
// MC_BuildUpgrade ( ) ;
17616: CALL 24395 0 0
// if event = 106 then
17620: LD_VAR 0 1
17624: PUSH
17625: LD_INT 106
17627: EQUAL
17628: IFFALSE 17634
// MC_PlantMines ( ) ;
17630: CALL 25274 0 0
// if event = 107 then
17634: LD_VAR 0 1
17638: PUSH
17639: LD_INT 107
17641: EQUAL
17642: IFFALSE 17648
// MC_CollectCrates ( ) ;
17644: CALL 26308 0 0
// if event = 108 then
17648: LD_VAR 0 1
17652: PUSH
17653: LD_INT 108
17655: EQUAL
17656: IFFALSE 17662
// MC_LinkRemoteControl ( ) ;
17658: CALL 28065 0 0
// if event = 109 then
17662: LD_VAR 0 1
17666: PUSH
17667: LD_INT 109
17669: EQUAL
17670: IFFALSE 17676
// MC_ProduceVehicle ( ) ;
17672: CALL 28246 0 0
// if event = 110 then
17676: LD_VAR 0 1
17680: PUSH
17681: LD_INT 110
17683: EQUAL
17684: IFFALSE 17690
// MC_SendAttack ( ) ;
17686: CALL 28727 0 0
// if event = 111 then
17690: LD_VAR 0 1
17694: PUSH
17695: LD_INT 111
17697: EQUAL
17698: IFFALSE 17704
// MC_Defend ( ) ;
17700: CALL 28835 0 0
// if event = 112 then
17704: LD_VAR 0 1
17708: PUSH
17709: LD_INT 112
17711: EQUAL
17712: IFFALSE 17718
// MC_Research ( ) ;
17714: CALL 29462 0 0
// if event = 113 then
17718: LD_VAR 0 1
17722: PUSH
17723: LD_INT 113
17725: EQUAL
17726: IFFALSE 17732
// MC_MinesTrigger ( ) ;
17728: CALL 30576 0 0
// if event = 120 then
17732: LD_VAR 0 1
17736: PUSH
17737: LD_INT 120
17739: EQUAL
17740: IFFALSE 17746
// MC_RepairVehicle ( ) ;
17742: CALL 30675 0 0
// if event = 121 then
17746: LD_VAR 0 1
17750: PUSH
17751: LD_INT 121
17753: EQUAL
17754: IFFALSE 17760
// MC_TameApe ( ) ;
17756: CALL 31418 0 0
// if event = 122 then
17760: LD_VAR 0 1
17764: PUSH
17765: LD_INT 122
17767: EQUAL
17768: IFFALSE 17774
// MC_ChangeApeClass ( ) ;
17770: CALL 32247 0 0
// if event = 123 then
17774: LD_VAR 0 1
17778: PUSH
17779: LD_INT 123
17781: EQUAL
17782: IFFALSE 17788
// MC_Bazooka ( ) ;
17784: CALL 32897 0 0
// if event = 124 then
17788: LD_VAR 0 1
17792: PUSH
17793: LD_INT 124
17795: EQUAL
17796: IFFALSE 17802
// MC_TeleportExit ( ) ;
17798: CALL 33095 0 0
// if event = 125 then
17802: LD_VAR 0 1
17806: PUSH
17807: LD_INT 125
17809: EQUAL
17810: IFFALSE 17816
// MC_Deposits ( ) ;
17812: CALL 33742 0 0
// if event = 126 then
17816: LD_VAR 0 1
17820: PUSH
17821: LD_INT 126
17823: EQUAL
17824: IFFALSE 17830
// MC_RemoteDriver ( ) ;
17826: CALL 34367 0 0
// if event = 200 then
17830: LD_VAR 0 1
17834: PUSH
17835: LD_INT 200
17837: EQUAL
17838: IFFALSE 17844
// MC_Idle ( ) ;
17840: CALL 36100 0 0
// end ;
17844: PPOPN 1
17846: END
// export function MC_Reset ( base , tag ) ; var i ; begin
17847: LD_INT 0
17849: PPUSH
17850: PPUSH
// if not mc_bases [ base ] or not tag then
17851: LD_EXP 71
17855: PUSH
17856: LD_VAR 0 1
17860: ARRAY
17861: NOT
17862: PUSH
17863: LD_VAR 0 2
17867: NOT
17868: OR
17869: IFFALSE 17873
// exit ;
17871: GO 17937
// for i in mc_bases [ base ] union mc_ape [ base ] do
17873: LD_ADDR_VAR 0 4
17877: PUSH
17878: LD_EXP 71
17882: PUSH
17883: LD_VAR 0 1
17887: ARRAY
17888: PUSH
17889: LD_EXP 100
17893: PUSH
17894: LD_VAR 0 1
17898: ARRAY
17899: UNION
17900: PUSH
17901: FOR_IN
17902: IFFALSE 17935
// if GetTag ( i ) = tag then
17904: LD_VAR 0 4
17908: PPUSH
17909: CALL_OW 110
17913: PUSH
17914: LD_VAR 0 2
17918: EQUAL
17919: IFFALSE 17933
// SetTag ( i , 0 ) ;
17921: LD_VAR 0 4
17925: PPUSH
17926: LD_INT 0
17928: PPUSH
17929: CALL_OW 109
17933: GO 17901
17935: POP
17936: POP
// end ;
17937: LD_VAR 0 3
17941: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
17942: LD_INT 0
17944: PPUSH
17945: PPUSH
17946: PPUSH
17947: PPUSH
17948: PPUSH
17949: PPUSH
17950: PPUSH
17951: PPUSH
// if not mc_bases then
17952: LD_EXP 71
17956: NOT
17957: IFFALSE 17961
// exit ;
17959: GO 18419
// for i = 1 to mc_bases do
17961: LD_ADDR_VAR 0 2
17965: PUSH
17966: DOUBLE
17967: LD_INT 1
17969: DEC
17970: ST_TO_ADDR
17971: LD_EXP 71
17975: PUSH
17976: FOR_TO
17977: IFFALSE 18417
// begin tmp := MC_ClassCheckReq ( i ) ;
17979: LD_ADDR_VAR 0 4
17983: PUSH
17984: LD_VAR 0 2
17988: PPUSH
17989: CALL 18424 0 1
17993: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
17994: LD_ADDR_EXP 112
17998: PUSH
17999: LD_EXP 112
18003: PPUSH
18004: LD_VAR 0 2
18008: PPUSH
18009: LD_VAR 0 4
18013: PPUSH
18014: CALL_OW 1
18018: ST_TO_ADDR
// if not tmp then
18019: LD_VAR 0 4
18023: NOT
18024: IFFALSE 18028
// continue ;
18026: GO 17976
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
18028: LD_ADDR_VAR 0 6
18032: PUSH
18033: LD_EXP 71
18037: PUSH
18038: LD_VAR 0 2
18042: ARRAY
18043: PPUSH
18044: LD_INT 2
18046: PUSH
18047: LD_INT 30
18049: PUSH
18050: LD_INT 4
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: PUSH
18057: LD_INT 30
18059: PUSH
18060: LD_INT 5
18062: PUSH
18063: EMPTY
18064: LIST
18065: LIST
18066: PUSH
18067: EMPTY
18068: LIST
18069: LIST
18070: LIST
18071: PPUSH
18072: CALL_OW 72
18076: PUSH
18077: LD_EXP 71
18081: PUSH
18082: LD_VAR 0 2
18086: ARRAY
18087: PPUSH
18088: LD_INT 2
18090: PUSH
18091: LD_INT 30
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PUSH
18101: LD_INT 30
18103: PUSH
18104: LD_INT 1
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: PPUSH
18116: CALL_OW 72
18120: PUSH
18121: LD_EXP 71
18125: PUSH
18126: LD_VAR 0 2
18130: ARRAY
18131: PPUSH
18132: LD_INT 30
18134: PUSH
18135: LD_INT 3
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: PPUSH
18142: CALL_OW 72
18146: PUSH
18147: LD_EXP 71
18151: PUSH
18152: LD_VAR 0 2
18156: ARRAY
18157: PPUSH
18158: LD_INT 2
18160: PUSH
18161: LD_INT 30
18163: PUSH
18164: LD_INT 6
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 30
18173: PUSH
18174: LD_INT 7
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: PUSH
18181: LD_INT 30
18183: PUSH
18184: LD_INT 8
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: PUSH
18191: EMPTY
18192: LIST
18193: LIST
18194: LIST
18195: LIST
18196: PPUSH
18197: CALL_OW 72
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: ST_TO_ADDR
// for j = 1 to 4 do
18208: LD_ADDR_VAR 0 3
18212: PUSH
18213: DOUBLE
18214: LD_INT 1
18216: DEC
18217: ST_TO_ADDR
18218: LD_INT 4
18220: PUSH
18221: FOR_TO
18222: IFFALSE 18413
// begin if not tmp [ j ] then
18224: LD_VAR 0 4
18228: PUSH
18229: LD_VAR 0 3
18233: ARRAY
18234: NOT
18235: IFFALSE 18239
// continue ;
18237: GO 18221
// for p in tmp [ j ] do
18239: LD_ADDR_VAR 0 5
18243: PUSH
18244: LD_VAR 0 4
18248: PUSH
18249: LD_VAR 0 3
18253: ARRAY
18254: PUSH
18255: FOR_IN
18256: IFFALSE 18409
// begin if not b [ j ] then
18258: LD_VAR 0 6
18262: PUSH
18263: LD_VAR 0 3
18267: ARRAY
18268: NOT
18269: IFFALSE 18273
// break ;
18271: GO 18409
// e := 0 ;
18273: LD_ADDR_VAR 0 7
18277: PUSH
18278: LD_INT 0
18280: ST_TO_ADDR
// for k in b [ j ] do
18281: LD_ADDR_VAR 0 8
18285: PUSH
18286: LD_VAR 0 6
18290: PUSH
18291: LD_VAR 0 3
18295: ARRAY
18296: PUSH
18297: FOR_IN
18298: IFFALSE 18325
// if IsNotFull ( k ) then
18300: LD_VAR 0 8
18304: PPUSH
18305: CALL 46538 0 1
18309: IFFALSE 18323
// begin e := k ;
18311: LD_ADDR_VAR 0 7
18315: PUSH
18316: LD_VAR 0 8
18320: ST_TO_ADDR
// break ;
18321: GO 18325
// end ;
18323: GO 18297
18325: POP
18326: POP
// if e and not UnitGoingToBuilding ( p , e ) then
18327: LD_VAR 0 7
18331: PUSH
18332: LD_VAR 0 5
18336: PPUSH
18337: LD_VAR 0 7
18341: PPUSH
18342: CALL 83526 0 2
18346: NOT
18347: AND
18348: IFFALSE 18407
// begin if IsInUnit ( p ) then
18350: LD_VAR 0 5
18354: PPUSH
18355: CALL_OW 310
18359: IFFALSE 18370
// ComExitBuilding ( p ) ;
18361: LD_VAR 0 5
18365: PPUSH
18366: CALL_OW 122
// ComEnterUnit ( p , e ) ;
18370: LD_VAR 0 5
18374: PPUSH
18375: LD_VAR 0 7
18379: PPUSH
18380: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
18384: LD_VAR 0 5
18388: PPUSH
18389: LD_VAR 0 3
18393: PPUSH
18394: CALL_OW 183
// AddComExitBuilding ( p ) ;
18398: LD_VAR 0 5
18402: PPUSH
18403: CALL_OW 182
// end ; end ;
18407: GO 18255
18409: POP
18410: POP
// end ;
18411: GO 18221
18413: POP
18414: POP
// end ;
18415: GO 17976
18417: POP
18418: POP
// end ;
18419: LD_VAR 0 1
18423: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
18424: LD_INT 0
18426: PPUSH
18427: PPUSH
18428: PPUSH
18429: PPUSH
18430: PPUSH
18431: PPUSH
18432: PPUSH
18433: PPUSH
18434: PPUSH
18435: PPUSH
18436: PPUSH
18437: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
18438: LD_VAR 0 1
18442: NOT
18443: PUSH
18444: LD_EXP 71
18448: PUSH
18449: LD_VAR 0 1
18453: ARRAY
18454: NOT
18455: OR
18456: PUSH
18457: LD_EXP 71
18461: PUSH
18462: LD_VAR 0 1
18466: ARRAY
18467: PPUSH
18468: LD_INT 2
18470: PUSH
18471: LD_INT 30
18473: PUSH
18474: LD_INT 0
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 30
18483: PUSH
18484: LD_INT 1
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: LIST
18495: PPUSH
18496: CALL_OW 72
18500: NOT
18501: OR
18502: IFFALSE 18506
// exit ;
18504: GO 21677
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
18506: LD_ADDR_VAR 0 4
18510: PUSH
18511: LD_EXP 71
18515: PUSH
18516: LD_VAR 0 1
18520: ARRAY
18521: PPUSH
18522: LD_INT 2
18524: PUSH
18525: LD_INT 25
18527: PUSH
18528: LD_INT 1
18530: PUSH
18531: EMPTY
18532: LIST
18533: LIST
18534: PUSH
18535: LD_INT 25
18537: PUSH
18538: LD_INT 2
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: PUSH
18545: LD_INT 25
18547: PUSH
18548: LD_INT 3
18550: PUSH
18551: EMPTY
18552: LIST
18553: LIST
18554: PUSH
18555: LD_INT 25
18557: PUSH
18558: LD_INT 4
18560: PUSH
18561: EMPTY
18562: LIST
18563: LIST
18564: PUSH
18565: LD_INT 25
18567: PUSH
18568: LD_INT 5
18570: PUSH
18571: EMPTY
18572: LIST
18573: LIST
18574: PUSH
18575: LD_INT 25
18577: PUSH
18578: LD_INT 8
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: PUSH
18585: LD_INT 25
18587: PUSH
18588: LD_INT 9
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: PUSH
18595: EMPTY
18596: LIST
18597: LIST
18598: LIST
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: LIST
18604: PPUSH
18605: CALL_OW 72
18609: ST_TO_ADDR
// for i in tmp do
18610: LD_ADDR_VAR 0 3
18614: PUSH
18615: LD_VAR 0 4
18619: PUSH
18620: FOR_IN
18621: IFFALSE 18652
// if GetTag ( i ) then
18623: LD_VAR 0 3
18627: PPUSH
18628: CALL_OW 110
18632: IFFALSE 18650
// tmp := tmp diff i ;
18634: LD_ADDR_VAR 0 4
18638: PUSH
18639: LD_VAR 0 4
18643: PUSH
18644: LD_VAR 0 3
18648: DIFF
18649: ST_TO_ADDR
18650: GO 18620
18652: POP
18653: POP
// if not tmp then
18654: LD_VAR 0 4
18658: NOT
18659: IFFALSE 18663
// exit ;
18661: GO 21677
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
18663: LD_ADDR_VAR 0 5
18667: PUSH
18668: LD_EXP 71
18672: PUSH
18673: LD_VAR 0 1
18677: ARRAY
18678: PPUSH
18679: LD_INT 2
18681: PUSH
18682: LD_INT 25
18684: PUSH
18685: LD_INT 1
18687: PUSH
18688: EMPTY
18689: LIST
18690: LIST
18691: PUSH
18692: LD_INT 25
18694: PUSH
18695: LD_INT 5
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PUSH
18702: LD_INT 25
18704: PUSH
18705: LD_INT 8
18707: PUSH
18708: EMPTY
18709: LIST
18710: LIST
18711: PUSH
18712: LD_INT 25
18714: PUSH
18715: LD_INT 9
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: PPUSH
18729: CALL_OW 72
18733: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
18734: LD_ADDR_VAR 0 6
18738: PUSH
18739: LD_EXP 71
18743: PUSH
18744: LD_VAR 0 1
18748: ARRAY
18749: PPUSH
18750: LD_INT 25
18752: PUSH
18753: LD_INT 2
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PPUSH
18760: CALL_OW 72
18764: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
18765: LD_ADDR_VAR 0 7
18769: PUSH
18770: LD_EXP 71
18774: PUSH
18775: LD_VAR 0 1
18779: ARRAY
18780: PPUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 3
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PPUSH
18791: CALL_OW 72
18795: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
18796: LD_ADDR_VAR 0 8
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: PPUSH
18812: LD_INT 25
18814: PUSH
18815: LD_INT 4
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PUSH
18822: LD_INT 24
18824: PUSH
18825: LD_INT 251
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: PPUSH
18836: CALL_OW 72
18840: ST_TO_ADDR
// if mc_scan [ base ] then
18841: LD_EXP 94
18845: PUSH
18846: LD_VAR 0 1
18850: ARRAY
18851: IFFALSE 19312
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
18853: LD_ADDR_EXP 113
18857: PUSH
18858: LD_EXP 113
18862: PPUSH
18863: LD_VAR 0 1
18867: PPUSH
18868: LD_INT 4
18870: PPUSH
18871: CALL_OW 1
18875: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
18876: LD_ADDR_VAR 0 12
18880: PUSH
18881: LD_EXP 71
18885: PUSH
18886: LD_VAR 0 1
18890: ARRAY
18891: PPUSH
18892: LD_INT 2
18894: PUSH
18895: LD_INT 30
18897: PUSH
18898: LD_INT 4
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: PUSH
18905: LD_INT 30
18907: PUSH
18908: LD_INT 5
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: LIST
18919: PPUSH
18920: CALL_OW 72
18924: ST_TO_ADDR
// if not b then
18925: LD_VAR 0 12
18929: NOT
18930: IFFALSE 18934
// exit ;
18932: GO 21677
// p := [ ] ;
18934: LD_ADDR_VAR 0 11
18938: PUSH
18939: EMPTY
18940: ST_TO_ADDR
// if sci >= 2 then
18941: LD_VAR 0 8
18945: PUSH
18946: LD_INT 2
18948: GREATEREQUAL
18949: IFFALSE 18980
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
18951: LD_ADDR_VAR 0 8
18955: PUSH
18956: LD_VAR 0 8
18960: PUSH
18961: LD_INT 1
18963: ARRAY
18964: PUSH
18965: LD_VAR 0 8
18969: PUSH
18970: LD_INT 2
18972: ARRAY
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: ST_TO_ADDR
18978: GO 19041
// if sci = 1 then
18980: LD_VAR 0 8
18984: PUSH
18985: LD_INT 1
18987: EQUAL
18988: IFFALSE 19009
// sci := [ sci [ 1 ] ] else
18990: LD_ADDR_VAR 0 8
18994: PUSH
18995: LD_VAR 0 8
18999: PUSH
19000: LD_INT 1
19002: ARRAY
19003: PUSH
19004: EMPTY
19005: LIST
19006: ST_TO_ADDR
19007: GO 19041
// if sci = 0 then
19009: LD_VAR 0 8
19013: PUSH
19014: LD_INT 0
19016: EQUAL
19017: IFFALSE 19041
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
19019: LD_ADDR_VAR 0 11
19023: PUSH
19024: LD_VAR 0 4
19028: PPUSH
19029: LD_INT 4
19031: PPUSH
19032: CALL 83389 0 2
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: ST_TO_ADDR
// if eng > 4 then
19041: LD_VAR 0 6
19045: PUSH
19046: LD_INT 4
19048: GREATER
19049: IFFALSE 19095
// for i = eng downto 4 do
19051: LD_ADDR_VAR 0 3
19055: PUSH
19056: DOUBLE
19057: LD_VAR 0 6
19061: INC
19062: ST_TO_ADDR
19063: LD_INT 4
19065: PUSH
19066: FOR_DOWNTO
19067: IFFALSE 19093
// eng := eng diff eng [ i ] ;
19069: LD_ADDR_VAR 0 6
19073: PUSH
19074: LD_VAR 0 6
19078: PUSH
19079: LD_VAR 0 6
19083: PUSH
19084: LD_VAR 0 3
19088: ARRAY
19089: DIFF
19090: ST_TO_ADDR
19091: GO 19066
19093: POP
19094: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
19095: LD_ADDR_VAR 0 4
19099: PUSH
19100: LD_VAR 0 4
19104: PUSH
19105: LD_VAR 0 5
19109: PUSH
19110: LD_VAR 0 6
19114: UNION
19115: PUSH
19116: LD_VAR 0 7
19120: UNION
19121: PUSH
19122: LD_VAR 0 8
19126: UNION
19127: DIFF
19128: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
19129: LD_ADDR_VAR 0 13
19133: PUSH
19134: LD_EXP 71
19138: PUSH
19139: LD_VAR 0 1
19143: ARRAY
19144: PPUSH
19145: LD_INT 2
19147: PUSH
19148: LD_INT 30
19150: PUSH
19151: LD_INT 32
19153: PUSH
19154: EMPTY
19155: LIST
19156: LIST
19157: PUSH
19158: LD_INT 30
19160: PUSH
19161: LD_INT 31
19163: PUSH
19164: EMPTY
19165: LIST
19166: LIST
19167: PUSH
19168: EMPTY
19169: LIST
19170: LIST
19171: LIST
19172: PPUSH
19173: CALL_OW 72
19177: PUSH
19178: LD_EXP 71
19182: PUSH
19183: LD_VAR 0 1
19187: ARRAY
19188: PPUSH
19189: LD_INT 2
19191: PUSH
19192: LD_INT 30
19194: PUSH
19195: LD_INT 4
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: PUSH
19202: LD_INT 30
19204: PUSH
19205: LD_INT 5
19207: PUSH
19208: EMPTY
19209: LIST
19210: LIST
19211: PUSH
19212: EMPTY
19213: LIST
19214: LIST
19215: LIST
19216: PPUSH
19217: CALL_OW 72
19221: PUSH
19222: LD_INT 6
19224: MUL
19225: PLUS
19226: ST_TO_ADDR
// if bcount < tmp then
19227: LD_VAR 0 13
19231: PUSH
19232: LD_VAR 0 4
19236: LESS
19237: IFFALSE 19283
// for i = tmp downto bcount do
19239: LD_ADDR_VAR 0 3
19243: PUSH
19244: DOUBLE
19245: LD_VAR 0 4
19249: INC
19250: ST_TO_ADDR
19251: LD_VAR 0 13
19255: PUSH
19256: FOR_DOWNTO
19257: IFFALSE 19281
// tmp := Delete ( tmp , tmp ) ;
19259: LD_ADDR_VAR 0 4
19263: PUSH
19264: LD_VAR 0 4
19268: PPUSH
19269: LD_VAR 0 4
19273: PPUSH
19274: CALL_OW 3
19278: ST_TO_ADDR
19279: GO 19256
19281: POP
19282: POP
// result := [ tmp , 0 , 0 , p ] ;
19283: LD_ADDR_VAR 0 2
19287: PUSH
19288: LD_VAR 0 4
19292: PUSH
19293: LD_INT 0
19295: PUSH
19296: LD_INT 0
19298: PUSH
19299: LD_VAR 0 11
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: LIST
19308: LIST
19309: ST_TO_ADDR
// exit ;
19310: GO 21677
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
19312: LD_EXP 71
19316: PUSH
19317: LD_VAR 0 1
19321: ARRAY
19322: PPUSH
19323: LD_INT 2
19325: PUSH
19326: LD_INT 30
19328: PUSH
19329: LD_INT 6
19331: PUSH
19332: EMPTY
19333: LIST
19334: LIST
19335: PUSH
19336: LD_INT 30
19338: PUSH
19339: LD_INT 7
19341: PUSH
19342: EMPTY
19343: LIST
19344: LIST
19345: PUSH
19346: LD_INT 30
19348: PUSH
19349: LD_INT 8
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: EMPTY
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: PPUSH
19362: CALL_OW 72
19366: NOT
19367: PUSH
19368: LD_EXP 71
19372: PUSH
19373: LD_VAR 0 1
19377: ARRAY
19378: PPUSH
19379: LD_INT 30
19381: PUSH
19382: LD_INT 3
19384: PUSH
19385: EMPTY
19386: LIST
19387: LIST
19388: PPUSH
19389: CALL_OW 72
19393: NOT
19394: AND
19395: IFFALSE 19467
// begin if eng = tmp then
19397: LD_VAR 0 6
19401: PUSH
19402: LD_VAR 0 4
19406: EQUAL
19407: IFFALSE 19411
// exit ;
19409: GO 21677
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
19411: LD_ADDR_EXP 113
19415: PUSH
19416: LD_EXP 113
19420: PPUSH
19421: LD_VAR 0 1
19425: PPUSH
19426: LD_INT 1
19428: PPUSH
19429: CALL_OW 1
19433: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
19434: LD_ADDR_VAR 0 2
19438: PUSH
19439: LD_INT 0
19441: PUSH
19442: LD_VAR 0 4
19446: PUSH
19447: LD_VAR 0 6
19451: DIFF
19452: PUSH
19453: LD_INT 0
19455: PUSH
19456: LD_INT 0
19458: PUSH
19459: EMPTY
19460: LIST
19461: LIST
19462: LIST
19463: LIST
19464: ST_TO_ADDR
// exit ;
19465: GO 21677
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
19467: LD_EXP 98
19471: PUSH
19472: LD_EXP 97
19476: PUSH
19477: LD_VAR 0 1
19481: ARRAY
19482: ARRAY
19483: PUSH
19484: LD_EXP 71
19488: PUSH
19489: LD_VAR 0 1
19493: ARRAY
19494: PPUSH
19495: LD_INT 2
19497: PUSH
19498: LD_INT 30
19500: PUSH
19501: LD_INT 6
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: PUSH
19508: LD_INT 30
19510: PUSH
19511: LD_INT 7
19513: PUSH
19514: EMPTY
19515: LIST
19516: LIST
19517: PUSH
19518: LD_INT 30
19520: PUSH
19521: LD_INT 8
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: LIST
19532: LIST
19533: PPUSH
19534: CALL_OW 72
19538: AND
19539: PUSH
19540: LD_EXP 71
19544: PUSH
19545: LD_VAR 0 1
19549: ARRAY
19550: PPUSH
19551: LD_INT 30
19553: PUSH
19554: LD_INT 3
19556: PUSH
19557: EMPTY
19558: LIST
19559: LIST
19560: PPUSH
19561: CALL_OW 72
19565: NOT
19566: AND
19567: IFFALSE 19781
// begin if sci >= 6 then
19569: LD_VAR 0 8
19573: PUSH
19574: LD_INT 6
19576: GREATEREQUAL
19577: IFFALSE 19581
// exit ;
19579: GO 21677
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
19581: LD_ADDR_EXP 113
19585: PUSH
19586: LD_EXP 113
19590: PPUSH
19591: LD_VAR 0 1
19595: PPUSH
19596: LD_INT 2
19598: PPUSH
19599: CALL_OW 1
19603: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
19604: LD_ADDR_VAR 0 9
19608: PUSH
19609: LD_VAR 0 4
19613: PUSH
19614: LD_VAR 0 8
19618: DIFF
19619: PPUSH
19620: LD_INT 4
19622: PPUSH
19623: CALL 83389 0 2
19627: ST_TO_ADDR
// p := [ ] ;
19628: LD_ADDR_VAR 0 11
19632: PUSH
19633: EMPTY
19634: ST_TO_ADDR
// if sci < 6 and sort > 6 then
19635: LD_VAR 0 8
19639: PUSH
19640: LD_INT 6
19642: LESS
19643: PUSH
19644: LD_VAR 0 9
19648: PUSH
19649: LD_INT 6
19651: GREATER
19652: AND
19653: IFFALSE 19734
// begin for i = 1 to 6 - sci do
19655: LD_ADDR_VAR 0 3
19659: PUSH
19660: DOUBLE
19661: LD_INT 1
19663: DEC
19664: ST_TO_ADDR
19665: LD_INT 6
19667: PUSH
19668: LD_VAR 0 8
19672: MINUS
19673: PUSH
19674: FOR_TO
19675: IFFALSE 19730
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
19677: LD_ADDR_VAR 0 11
19681: PUSH
19682: LD_VAR 0 11
19686: PPUSH
19687: LD_VAR 0 11
19691: PUSH
19692: LD_INT 1
19694: PLUS
19695: PPUSH
19696: LD_VAR 0 9
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: CALL_OW 2
19709: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
19710: LD_ADDR_VAR 0 9
19714: PUSH
19715: LD_VAR 0 9
19719: PPUSH
19720: LD_INT 1
19722: PPUSH
19723: CALL_OW 3
19727: ST_TO_ADDR
// end ;
19728: GO 19674
19730: POP
19731: POP
// end else
19732: GO 19754
// if sort then
19734: LD_VAR 0 9
19738: IFFALSE 19754
// p := sort [ 1 ] ;
19740: LD_ADDR_VAR 0 11
19744: PUSH
19745: LD_VAR 0 9
19749: PUSH
19750: LD_INT 1
19752: ARRAY
19753: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
19754: LD_ADDR_VAR 0 2
19758: PUSH
19759: LD_INT 0
19761: PUSH
19762: LD_INT 0
19764: PUSH
19765: LD_INT 0
19767: PUSH
19768: LD_VAR 0 11
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: ST_TO_ADDR
// exit ;
19779: GO 21677
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
19781: LD_EXP 98
19785: PUSH
19786: LD_EXP 97
19790: PUSH
19791: LD_VAR 0 1
19795: ARRAY
19796: ARRAY
19797: PUSH
19798: LD_EXP 71
19802: PUSH
19803: LD_VAR 0 1
19807: ARRAY
19808: PPUSH
19809: LD_INT 2
19811: PUSH
19812: LD_INT 30
19814: PUSH
19815: LD_INT 6
19817: PUSH
19818: EMPTY
19819: LIST
19820: LIST
19821: PUSH
19822: LD_INT 30
19824: PUSH
19825: LD_INT 7
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: PUSH
19832: LD_INT 30
19834: PUSH
19835: LD_INT 8
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PUSH
19842: EMPTY
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: PPUSH
19848: CALL_OW 72
19852: AND
19853: PUSH
19854: LD_EXP 71
19858: PUSH
19859: LD_VAR 0 1
19863: ARRAY
19864: PPUSH
19865: LD_INT 30
19867: PUSH
19868: LD_INT 3
19870: PUSH
19871: EMPTY
19872: LIST
19873: LIST
19874: PPUSH
19875: CALL_OW 72
19879: AND
19880: IFFALSE 20407
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
19882: LD_ADDR_EXP 113
19886: PUSH
19887: LD_EXP 113
19891: PPUSH
19892: LD_VAR 0 1
19896: PPUSH
19897: LD_INT 3
19899: PPUSH
19900: CALL_OW 1
19904: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
19905: LD_ADDR_VAR 0 2
19909: PUSH
19910: LD_INT 0
19912: PUSH
19913: LD_INT 0
19915: PUSH
19916: LD_INT 0
19918: PUSH
19919: LD_INT 0
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: LIST
19926: LIST
19927: ST_TO_ADDR
// if not eng then
19928: LD_VAR 0 6
19932: NOT
19933: IFFALSE 19996
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
19935: LD_ADDR_VAR 0 11
19939: PUSH
19940: LD_VAR 0 4
19944: PPUSH
19945: LD_INT 2
19947: PPUSH
19948: CALL 83389 0 2
19952: PUSH
19953: LD_INT 1
19955: ARRAY
19956: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
19957: LD_ADDR_VAR 0 2
19961: PUSH
19962: LD_VAR 0 2
19966: PPUSH
19967: LD_INT 2
19969: PPUSH
19970: LD_VAR 0 11
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// tmp := tmp diff p ;
19980: LD_ADDR_VAR 0 4
19984: PUSH
19985: LD_VAR 0 4
19989: PUSH
19990: LD_VAR 0 11
19994: DIFF
19995: ST_TO_ADDR
// end ; if not eng then
19996: LD_VAR 0 6
20000: NOT
20001: IFFALSE 20027
// tmp := tmp diff ( mech union sci ) else
20003: LD_ADDR_VAR 0 4
20007: PUSH
20008: LD_VAR 0 4
20012: PUSH
20013: LD_VAR 0 7
20017: PUSH
20018: LD_VAR 0 8
20022: UNION
20023: DIFF
20024: ST_TO_ADDR
20025: GO 20059
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
20027: LD_ADDR_VAR 0 4
20031: PUSH
20032: LD_VAR 0 4
20036: PUSH
20037: LD_VAR 0 6
20041: PUSH
20042: LD_INT 1
20044: ARRAY
20045: PUSH
20046: LD_VAR 0 7
20050: UNION
20051: PUSH
20052: LD_VAR 0 8
20056: UNION
20057: DIFF
20058: ST_TO_ADDR
// if tmp and sci < 6 then
20059: LD_VAR 0 4
20063: PUSH
20064: LD_VAR 0 8
20068: PUSH
20069: LD_INT 6
20071: LESS
20072: AND
20073: IFFALSE 20232
// begin sort := SortBySkill ( tmp , 4 ) ;
20075: LD_ADDR_VAR 0 9
20079: PUSH
20080: LD_VAR 0 4
20084: PPUSH
20085: LD_INT 4
20087: PPUSH
20088: CALL 83389 0 2
20092: ST_TO_ADDR
// p := [ ] ;
20093: LD_ADDR_VAR 0 11
20097: PUSH
20098: EMPTY
20099: ST_TO_ADDR
// if sort then
20100: LD_VAR 0 9
20104: IFFALSE 20203
// for i = 1 to 6 - sci do
20106: LD_ADDR_VAR 0 3
20110: PUSH
20111: DOUBLE
20112: LD_INT 1
20114: DEC
20115: ST_TO_ADDR
20116: LD_INT 6
20118: PUSH
20119: LD_VAR 0 8
20123: MINUS
20124: PUSH
20125: FOR_TO
20126: IFFALSE 20201
// begin if i = sort then
20128: LD_VAR 0 3
20132: PUSH
20133: LD_VAR 0 9
20137: EQUAL
20138: IFFALSE 20142
// break ;
20140: GO 20201
// p := Insert ( p , p + 1 , sort [ i ] ) ;
20142: LD_ADDR_VAR 0 11
20146: PUSH
20147: LD_VAR 0 11
20151: PPUSH
20152: LD_VAR 0 11
20156: PUSH
20157: LD_INT 1
20159: PLUS
20160: PPUSH
20161: LD_VAR 0 9
20165: PUSH
20166: LD_VAR 0 3
20170: ARRAY
20171: PPUSH
20172: CALL_OW 2
20176: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
20177: LD_ADDR_VAR 0 4
20181: PUSH
20182: LD_VAR 0 4
20186: PUSH
20187: LD_VAR 0 9
20191: PUSH
20192: LD_VAR 0 3
20196: ARRAY
20197: DIFF
20198: ST_TO_ADDR
// end ;
20199: GO 20125
20201: POP
20202: POP
// if p then
20203: LD_VAR 0 11
20207: IFFALSE 20232
// result := Replace ( result , 4 , p ) ;
20209: LD_ADDR_VAR 0 2
20213: PUSH
20214: LD_VAR 0 2
20218: PPUSH
20219: LD_INT 4
20221: PPUSH
20222: LD_VAR 0 11
20226: PPUSH
20227: CALL_OW 1
20231: ST_TO_ADDR
// end ; if tmp and mech < 6 then
20232: LD_VAR 0 4
20236: PUSH
20237: LD_VAR 0 7
20241: PUSH
20242: LD_INT 6
20244: LESS
20245: AND
20246: IFFALSE 20405
// begin sort := SortBySkill ( tmp , 3 ) ;
20248: LD_ADDR_VAR 0 9
20252: PUSH
20253: LD_VAR 0 4
20257: PPUSH
20258: LD_INT 3
20260: PPUSH
20261: CALL 83389 0 2
20265: ST_TO_ADDR
// p := [ ] ;
20266: LD_ADDR_VAR 0 11
20270: PUSH
20271: EMPTY
20272: ST_TO_ADDR
// if sort then
20273: LD_VAR 0 9
20277: IFFALSE 20376
// for i = 1 to 6 - mech do
20279: LD_ADDR_VAR 0 3
20283: PUSH
20284: DOUBLE
20285: LD_INT 1
20287: DEC
20288: ST_TO_ADDR
20289: LD_INT 6
20291: PUSH
20292: LD_VAR 0 7
20296: MINUS
20297: PUSH
20298: FOR_TO
20299: IFFALSE 20374
// begin if i = sort then
20301: LD_VAR 0 3
20305: PUSH
20306: LD_VAR 0 9
20310: EQUAL
20311: IFFALSE 20315
// break ;
20313: GO 20374
// p := Insert ( p , p + 1 , sort [ i ] ) ;
20315: LD_ADDR_VAR 0 11
20319: PUSH
20320: LD_VAR 0 11
20324: PPUSH
20325: LD_VAR 0 11
20329: PUSH
20330: LD_INT 1
20332: PLUS
20333: PPUSH
20334: LD_VAR 0 9
20338: PUSH
20339: LD_VAR 0 3
20343: ARRAY
20344: PPUSH
20345: CALL_OW 2
20349: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
20350: LD_ADDR_VAR 0 4
20354: PUSH
20355: LD_VAR 0 4
20359: PUSH
20360: LD_VAR 0 9
20364: PUSH
20365: LD_VAR 0 3
20369: ARRAY
20370: DIFF
20371: ST_TO_ADDR
// end ;
20372: GO 20298
20374: POP
20375: POP
// if p then
20376: LD_VAR 0 11
20380: IFFALSE 20405
// result := Replace ( result , 3 , p ) ;
20382: LD_ADDR_VAR 0 2
20386: PUSH
20387: LD_VAR 0 2
20391: PPUSH
20392: LD_INT 3
20394: PPUSH
20395: LD_VAR 0 11
20399: PPUSH
20400: CALL_OW 1
20404: ST_TO_ADDR
// end ; exit ;
20405: GO 21677
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
20407: LD_EXP 98
20411: PUSH
20412: LD_EXP 97
20416: PUSH
20417: LD_VAR 0 1
20421: ARRAY
20422: ARRAY
20423: NOT
20424: PUSH
20425: LD_EXP 71
20429: PUSH
20430: LD_VAR 0 1
20434: ARRAY
20435: PPUSH
20436: LD_INT 30
20438: PUSH
20439: LD_INT 3
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PPUSH
20446: CALL_OW 72
20450: AND
20451: PUSH
20452: LD_EXP 76
20456: PUSH
20457: LD_VAR 0 1
20461: ARRAY
20462: AND
20463: IFFALSE 21007
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
20465: LD_ADDR_EXP 113
20469: PUSH
20470: LD_EXP 113
20474: PPUSH
20475: LD_VAR 0 1
20479: PPUSH
20480: LD_INT 5
20482: PPUSH
20483: CALL_OW 1
20487: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
20488: LD_ADDR_VAR 0 2
20492: PUSH
20493: LD_INT 0
20495: PUSH
20496: LD_INT 0
20498: PUSH
20499: LD_INT 0
20501: PUSH
20502: LD_INT 0
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: LIST
20509: LIST
20510: ST_TO_ADDR
// if sci > 1 then
20511: LD_VAR 0 8
20515: PUSH
20516: LD_INT 1
20518: GREATER
20519: IFFALSE 20547
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
20521: LD_ADDR_VAR 0 4
20525: PUSH
20526: LD_VAR 0 4
20530: PUSH
20531: LD_VAR 0 8
20535: PUSH
20536: LD_VAR 0 8
20540: PUSH
20541: LD_INT 1
20543: ARRAY
20544: DIFF
20545: DIFF
20546: ST_TO_ADDR
// if tmp and not sci then
20547: LD_VAR 0 4
20551: PUSH
20552: LD_VAR 0 8
20556: NOT
20557: AND
20558: IFFALSE 20627
// begin sort := SortBySkill ( tmp , 4 ) ;
20560: LD_ADDR_VAR 0 9
20564: PUSH
20565: LD_VAR 0 4
20569: PPUSH
20570: LD_INT 4
20572: PPUSH
20573: CALL 83389 0 2
20577: ST_TO_ADDR
// if sort then
20578: LD_VAR 0 9
20582: IFFALSE 20598
// p := sort [ 1 ] ;
20584: LD_ADDR_VAR 0 11
20588: PUSH
20589: LD_VAR 0 9
20593: PUSH
20594: LD_INT 1
20596: ARRAY
20597: ST_TO_ADDR
// if p then
20598: LD_VAR 0 11
20602: IFFALSE 20627
// result := Replace ( result , 4 , p ) ;
20604: LD_ADDR_VAR 0 2
20608: PUSH
20609: LD_VAR 0 2
20613: PPUSH
20614: LD_INT 4
20616: PPUSH
20617: LD_VAR 0 11
20621: PPUSH
20622: CALL_OW 1
20626: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
20627: LD_ADDR_VAR 0 4
20631: PUSH
20632: LD_VAR 0 4
20636: PUSH
20637: LD_VAR 0 7
20641: DIFF
20642: ST_TO_ADDR
// if tmp and mech < 6 then
20643: LD_VAR 0 4
20647: PUSH
20648: LD_VAR 0 7
20652: PUSH
20653: LD_INT 6
20655: LESS
20656: AND
20657: IFFALSE 20816
// begin sort := SortBySkill ( tmp , 3 ) ;
20659: LD_ADDR_VAR 0 9
20663: PUSH
20664: LD_VAR 0 4
20668: PPUSH
20669: LD_INT 3
20671: PPUSH
20672: CALL 83389 0 2
20676: ST_TO_ADDR
// p := [ ] ;
20677: LD_ADDR_VAR 0 11
20681: PUSH
20682: EMPTY
20683: ST_TO_ADDR
// if sort then
20684: LD_VAR 0 9
20688: IFFALSE 20787
// for i = 1 to 6 - mech do
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: DOUBLE
20696: LD_INT 1
20698: DEC
20699: ST_TO_ADDR
20700: LD_INT 6
20702: PUSH
20703: LD_VAR 0 7
20707: MINUS
20708: PUSH
20709: FOR_TO
20710: IFFALSE 20785
// begin if i = sort then
20712: LD_VAR 0 3
20716: PUSH
20717: LD_VAR 0 9
20721: EQUAL
20722: IFFALSE 20726
// break ;
20724: GO 20785
// p := Insert ( p , p + 1 , sort [ i ] ) ;
20726: LD_ADDR_VAR 0 11
20730: PUSH
20731: LD_VAR 0 11
20735: PPUSH
20736: LD_VAR 0 11
20740: PUSH
20741: LD_INT 1
20743: PLUS
20744: PPUSH
20745: LD_VAR 0 9
20749: PUSH
20750: LD_VAR 0 3
20754: ARRAY
20755: PPUSH
20756: CALL_OW 2
20760: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
20761: LD_ADDR_VAR 0 4
20765: PUSH
20766: LD_VAR 0 4
20770: PUSH
20771: LD_VAR 0 9
20775: PUSH
20776: LD_VAR 0 3
20780: ARRAY
20781: DIFF
20782: ST_TO_ADDR
// end ;
20783: GO 20709
20785: POP
20786: POP
// if p then
20787: LD_VAR 0 11
20791: IFFALSE 20816
// result := Replace ( result , 3 , p ) ;
20793: LD_ADDR_VAR 0 2
20797: PUSH
20798: LD_VAR 0 2
20802: PPUSH
20803: LD_INT 3
20805: PPUSH
20806: LD_VAR 0 11
20810: PPUSH
20811: CALL_OW 1
20815: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
20816: LD_ADDR_VAR 0 4
20820: PUSH
20821: LD_VAR 0 4
20825: PUSH
20826: LD_VAR 0 6
20830: DIFF
20831: ST_TO_ADDR
// if tmp and eng < 6 then
20832: LD_VAR 0 4
20836: PUSH
20837: LD_VAR 0 6
20841: PUSH
20842: LD_INT 6
20844: LESS
20845: AND
20846: IFFALSE 21005
// begin sort := SortBySkill ( tmp , 2 ) ;
20848: LD_ADDR_VAR 0 9
20852: PUSH
20853: LD_VAR 0 4
20857: PPUSH
20858: LD_INT 2
20860: PPUSH
20861: CALL 83389 0 2
20865: ST_TO_ADDR
// p := [ ] ;
20866: LD_ADDR_VAR 0 11
20870: PUSH
20871: EMPTY
20872: ST_TO_ADDR
// if sort then
20873: LD_VAR 0 9
20877: IFFALSE 20976
// for i = 1 to 6 - eng do
20879: LD_ADDR_VAR 0 3
20883: PUSH
20884: DOUBLE
20885: LD_INT 1
20887: DEC
20888: ST_TO_ADDR
20889: LD_INT 6
20891: PUSH
20892: LD_VAR 0 6
20896: MINUS
20897: PUSH
20898: FOR_TO
20899: IFFALSE 20974
// begin if i = sort then
20901: LD_VAR 0 3
20905: PUSH
20906: LD_VAR 0 9
20910: EQUAL
20911: IFFALSE 20915
// break ;
20913: GO 20974
// p := Insert ( p , p + 1 , sort [ i ] ) ;
20915: LD_ADDR_VAR 0 11
20919: PUSH
20920: LD_VAR 0 11
20924: PPUSH
20925: LD_VAR 0 11
20929: PUSH
20930: LD_INT 1
20932: PLUS
20933: PPUSH
20934: LD_VAR 0 9
20938: PUSH
20939: LD_VAR 0 3
20943: ARRAY
20944: PPUSH
20945: CALL_OW 2
20949: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
20950: LD_ADDR_VAR 0 4
20954: PUSH
20955: LD_VAR 0 4
20959: PUSH
20960: LD_VAR 0 9
20964: PUSH
20965: LD_VAR 0 3
20969: ARRAY
20970: DIFF
20971: ST_TO_ADDR
// end ;
20972: GO 20898
20974: POP
20975: POP
// if p then
20976: LD_VAR 0 11
20980: IFFALSE 21005
// result := Replace ( result , 2 , p ) ;
20982: LD_ADDR_VAR 0 2
20986: PUSH
20987: LD_VAR 0 2
20991: PPUSH
20992: LD_INT 2
20994: PPUSH
20995: LD_VAR 0 11
20999: PPUSH
21000: CALL_OW 1
21004: ST_TO_ADDR
// end ; exit ;
21005: GO 21677
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
21007: LD_EXP 98
21011: PUSH
21012: LD_EXP 97
21016: PUSH
21017: LD_VAR 0 1
21021: ARRAY
21022: ARRAY
21023: NOT
21024: PUSH
21025: LD_EXP 71
21029: PUSH
21030: LD_VAR 0 1
21034: ARRAY
21035: PPUSH
21036: LD_INT 30
21038: PUSH
21039: LD_INT 3
21041: PUSH
21042: EMPTY
21043: LIST
21044: LIST
21045: PPUSH
21046: CALL_OW 72
21050: AND
21051: PUSH
21052: LD_EXP 76
21056: PUSH
21057: LD_VAR 0 1
21061: ARRAY
21062: NOT
21063: AND
21064: IFFALSE 21677
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
21066: LD_ADDR_EXP 113
21070: PUSH
21071: LD_EXP 113
21075: PPUSH
21076: LD_VAR 0 1
21080: PPUSH
21081: LD_INT 6
21083: PPUSH
21084: CALL_OW 1
21088: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
21089: LD_ADDR_VAR 0 2
21093: PUSH
21094: LD_INT 0
21096: PUSH
21097: LD_INT 0
21099: PUSH
21100: LD_INT 0
21102: PUSH
21103: LD_INT 0
21105: PUSH
21106: EMPTY
21107: LIST
21108: LIST
21109: LIST
21110: LIST
21111: ST_TO_ADDR
// if sci >= 1 then
21112: LD_VAR 0 8
21116: PUSH
21117: LD_INT 1
21119: GREATEREQUAL
21120: IFFALSE 21142
// tmp := tmp diff sci [ 1 ] ;
21122: LD_ADDR_VAR 0 4
21126: PUSH
21127: LD_VAR 0 4
21131: PUSH
21132: LD_VAR 0 8
21136: PUSH
21137: LD_INT 1
21139: ARRAY
21140: DIFF
21141: ST_TO_ADDR
// if tmp and not sci then
21142: LD_VAR 0 4
21146: PUSH
21147: LD_VAR 0 8
21151: NOT
21152: AND
21153: IFFALSE 21222
// begin sort := SortBySkill ( tmp , 4 ) ;
21155: LD_ADDR_VAR 0 9
21159: PUSH
21160: LD_VAR 0 4
21164: PPUSH
21165: LD_INT 4
21167: PPUSH
21168: CALL 83389 0 2
21172: ST_TO_ADDR
// if sort then
21173: LD_VAR 0 9
21177: IFFALSE 21193
// p := sort [ 1 ] ;
21179: LD_ADDR_VAR 0 11
21183: PUSH
21184: LD_VAR 0 9
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: ST_TO_ADDR
// if p then
21193: LD_VAR 0 11
21197: IFFALSE 21222
// result := Replace ( result , 4 , p ) ;
21199: LD_ADDR_VAR 0 2
21203: PUSH
21204: LD_VAR 0 2
21208: PPUSH
21209: LD_INT 4
21211: PPUSH
21212: LD_VAR 0 11
21216: PPUSH
21217: CALL_OW 1
21221: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
21222: LD_ADDR_VAR 0 4
21226: PUSH
21227: LD_VAR 0 4
21231: PUSH
21232: LD_VAR 0 7
21236: DIFF
21237: ST_TO_ADDR
// if tmp and mech < 6 then
21238: LD_VAR 0 4
21242: PUSH
21243: LD_VAR 0 7
21247: PUSH
21248: LD_INT 6
21250: LESS
21251: AND
21252: IFFALSE 21411
// begin sort := SortBySkill ( tmp , 3 ) ;
21254: LD_ADDR_VAR 0 9
21258: PUSH
21259: LD_VAR 0 4
21263: PPUSH
21264: LD_INT 3
21266: PPUSH
21267: CALL 83389 0 2
21271: ST_TO_ADDR
// p := [ ] ;
21272: LD_ADDR_VAR 0 11
21276: PUSH
21277: EMPTY
21278: ST_TO_ADDR
// if sort then
21279: LD_VAR 0 9
21283: IFFALSE 21382
// for i = 1 to 6 - mech do
21285: LD_ADDR_VAR 0 3
21289: PUSH
21290: DOUBLE
21291: LD_INT 1
21293: DEC
21294: ST_TO_ADDR
21295: LD_INT 6
21297: PUSH
21298: LD_VAR 0 7
21302: MINUS
21303: PUSH
21304: FOR_TO
21305: IFFALSE 21380
// begin if i = sort then
21307: LD_VAR 0 3
21311: PUSH
21312: LD_VAR 0 9
21316: EQUAL
21317: IFFALSE 21321
// break ;
21319: GO 21380
// p := Insert ( p , p + 1 , sort [ i ] ) ;
21321: LD_ADDR_VAR 0 11
21325: PUSH
21326: LD_VAR 0 11
21330: PPUSH
21331: LD_VAR 0 11
21335: PUSH
21336: LD_INT 1
21338: PLUS
21339: PPUSH
21340: LD_VAR 0 9
21344: PUSH
21345: LD_VAR 0 3
21349: ARRAY
21350: PPUSH
21351: CALL_OW 2
21355: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
21356: LD_ADDR_VAR 0 4
21360: PUSH
21361: LD_VAR 0 4
21365: PUSH
21366: LD_VAR 0 9
21370: PUSH
21371: LD_VAR 0 3
21375: ARRAY
21376: DIFF
21377: ST_TO_ADDR
// end ;
21378: GO 21304
21380: POP
21381: POP
// if p then
21382: LD_VAR 0 11
21386: IFFALSE 21411
// result := Replace ( result , 3 , p ) ;
21388: LD_ADDR_VAR 0 2
21392: PUSH
21393: LD_VAR 0 2
21397: PPUSH
21398: LD_INT 3
21400: PPUSH
21401: LD_VAR 0 11
21405: PPUSH
21406: CALL_OW 1
21410: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
21411: LD_ADDR_VAR 0 4
21415: PUSH
21416: LD_VAR 0 4
21420: PUSH
21421: LD_VAR 0 6
21425: DIFF
21426: ST_TO_ADDR
// if tmp and eng < 4 then
21427: LD_VAR 0 4
21431: PUSH
21432: LD_VAR 0 6
21436: PUSH
21437: LD_INT 4
21439: LESS
21440: AND
21441: IFFALSE 21602
// begin sort := SortBySkill ( tmp , 2 ) ;
21443: LD_ADDR_VAR 0 9
21447: PUSH
21448: LD_VAR 0 4
21452: PPUSH
21453: LD_INT 2
21455: PPUSH
21456: CALL 83389 0 2
21460: ST_TO_ADDR
// p := [ ] ;
21461: LD_ADDR_VAR 0 11
21465: PUSH
21466: EMPTY
21467: ST_TO_ADDR
// if sort then
21468: LD_VAR 0 9
21472: IFFALSE 21571
// for i = 1 to 4 - eng do
21474: LD_ADDR_VAR 0 3
21478: PUSH
21479: DOUBLE
21480: LD_INT 1
21482: DEC
21483: ST_TO_ADDR
21484: LD_INT 4
21486: PUSH
21487: LD_VAR 0 6
21491: MINUS
21492: PUSH
21493: FOR_TO
21494: IFFALSE 21569
// begin if i = sort then
21496: LD_VAR 0 3
21500: PUSH
21501: LD_VAR 0 9
21505: EQUAL
21506: IFFALSE 21510
// break ;
21508: GO 21569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
21510: LD_ADDR_VAR 0 11
21514: PUSH
21515: LD_VAR 0 11
21519: PPUSH
21520: LD_VAR 0 11
21524: PUSH
21525: LD_INT 1
21527: PLUS
21528: PPUSH
21529: LD_VAR 0 9
21533: PUSH
21534: LD_VAR 0 3
21538: ARRAY
21539: PPUSH
21540: CALL_OW 2
21544: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
21545: LD_ADDR_VAR 0 4
21549: PUSH
21550: LD_VAR 0 4
21554: PUSH
21555: LD_VAR 0 9
21559: PUSH
21560: LD_VAR 0 3
21564: ARRAY
21565: DIFF
21566: ST_TO_ADDR
// end ;
21567: GO 21493
21569: POP
21570: POP
// if p then
21571: LD_VAR 0 11
21575: IFFALSE 21600
// result := Replace ( result , 2 , p ) ;
21577: LD_ADDR_VAR 0 2
21581: PUSH
21582: LD_VAR 0 2
21586: PPUSH
21587: LD_INT 2
21589: PPUSH
21590: LD_VAR 0 11
21594: PPUSH
21595: CALL_OW 1
21599: ST_TO_ADDR
// end else
21600: GO 21646
// for i = eng downto 5 do
21602: LD_ADDR_VAR 0 3
21606: PUSH
21607: DOUBLE
21608: LD_VAR 0 6
21612: INC
21613: ST_TO_ADDR
21614: LD_INT 5
21616: PUSH
21617: FOR_DOWNTO
21618: IFFALSE 21644
// tmp := tmp union eng [ i ] ;
21620: LD_ADDR_VAR 0 4
21624: PUSH
21625: LD_VAR 0 4
21629: PUSH
21630: LD_VAR 0 6
21634: PUSH
21635: LD_VAR 0 3
21639: ARRAY
21640: UNION
21641: ST_TO_ADDR
21642: GO 21617
21644: POP
21645: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
21646: LD_ADDR_VAR 0 2
21650: PUSH
21651: LD_VAR 0 2
21655: PPUSH
21656: LD_INT 1
21658: PPUSH
21659: LD_VAR 0 4
21663: PUSH
21664: LD_VAR 0 5
21668: DIFF
21669: PPUSH
21670: CALL_OW 1
21674: ST_TO_ADDR
// exit ;
21675: GO 21677
// end ; end ;
21677: LD_VAR 0 2
21681: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
21682: LD_INT 0
21684: PPUSH
21685: PPUSH
21686: PPUSH
// if not mc_bases then
21687: LD_EXP 71
21691: NOT
21692: IFFALSE 21696
// exit ;
21694: GO 21802
// for i = 1 to mc_bases do
21696: LD_ADDR_VAR 0 2
21700: PUSH
21701: DOUBLE
21702: LD_INT 1
21704: DEC
21705: ST_TO_ADDR
21706: LD_EXP 71
21710: PUSH
21711: FOR_TO
21712: IFFALSE 21793
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
21714: LD_ADDR_VAR 0 3
21718: PUSH
21719: LD_EXP 71
21723: PUSH
21724: LD_VAR 0 2
21728: ARRAY
21729: PPUSH
21730: LD_INT 21
21732: PUSH
21733: LD_INT 3
21735: PUSH
21736: EMPTY
21737: LIST
21738: LIST
21739: PUSH
21740: LD_INT 3
21742: PUSH
21743: LD_INT 24
21745: PUSH
21746: LD_INT 1000
21748: PUSH
21749: EMPTY
21750: LIST
21751: LIST
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: PPUSH
21761: CALL_OW 72
21765: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
21766: LD_ADDR_EXP 72
21770: PUSH
21771: LD_EXP 72
21775: PPUSH
21776: LD_VAR 0 2
21780: PPUSH
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL_OW 1
21790: ST_TO_ADDR
// end ;
21791: GO 21711
21793: POP
21794: POP
// RaiseSailEvent ( 101 ) ;
21795: LD_INT 101
21797: PPUSH
21798: CALL_OW 427
// end ;
21802: LD_VAR 0 1
21806: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
21807: LD_INT 0
21809: PPUSH
21810: PPUSH
21811: PPUSH
21812: PPUSH
21813: PPUSH
21814: PPUSH
21815: PPUSH
// if not mc_bases then
21816: LD_EXP 71
21820: NOT
21821: IFFALSE 21825
// exit ;
21823: GO 22398
// for i = 1 to mc_bases do
21825: LD_ADDR_VAR 0 2
21829: PUSH
21830: DOUBLE
21831: LD_INT 1
21833: DEC
21834: ST_TO_ADDR
21835: LD_EXP 71
21839: PUSH
21840: FOR_TO
21841: IFFALSE 22389
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
21843: LD_ADDR_VAR 0 5
21847: PUSH
21848: LD_EXP 71
21852: PUSH
21853: LD_VAR 0 2
21857: ARRAY
21858: PUSH
21859: LD_EXP 100
21863: PUSH
21864: LD_VAR 0 2
21868: ARRAY
21869: UNION
21870: PPUSH
21871: LD_INT 21
21873: PUSH
21874: LD_INT 1
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PUSH
21881: LD_INT 1
21883: PUSH
21884: LD_INT 3
21886: PUSH
21887: LD_INT 54
21889: PUSH
21890: EMPTY
21891: LIST
21892: PUSH
21893: EMPTY
21894: LIST
21895: LIST
21896: PUSH
21897: LD_INT 3
21899: PUSH
21900: LD_INT 24
21902: PUSH
21903: LD_INT 750
21905: PUSH
21906: EMPTY
21907: LIST
21908: LIST
21909: PUSH
21910: EMPTY
21911: LIST
21912: LIST
21913: PUSH
21914: EMPTY
21915: LIST
21916: LIST
21917: LIST
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PPUSH
21923: CALL_OW 72
21927: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
21928: LD_ADDR_VAR 0 6
21932: PUSH
21933: LD_EXP 71
21937: PUSH
21938: LD_VAR 0 2
21942: ARRAY
21943: PPUSH
21944: LD_INT 21
21946: PUSH
21947: LD_INT 1
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PUSH
21954: LD_INT 1
21956: PUSH
21957: LD_INT 3
21959: PUSH
21960: LD_INT 54
21962: PUSH
21963: EMPTY
21964: LIST
21965: PUSH
21966: EMPTY
21967: LIST
21968: LIST
21969: PUSH
21970: LD_INT 3
21972: PUSH
21973: LD_INT 24
21975: PUSH
21976: LD_INT 250
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: EMPTY
21984: LIST
21985: LIST
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: LIST
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PPUSH
21996: CALL_OW 72
22000: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
22001: LD_ADDR_VAR 0 7
22005: PUSH
22006: LD_VAR 0 5
22010: PUSH
22011: LD_VAR 0 6
22015: DIFF
22016: ST_TO_ADDR
// if not need_heal_1 then
22017: LD_VAR 0 6
22021: NOT
22022: IFFALSE 22055
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
22024: LD_ADDR_EXP 74
22028: PUSH
22029: LD_EXP 74
22033: PPUSH
22034: LD_VAR 0 2
22038: PUSH
22039: LD_INT 1
22041: PUSH
22042: EMPTY
22043: LIST
22044: LIST
22045: PPUSH
22046: EMPTY
22047: PPUSH
22048: CALL 49204 0 3
22052: ST_TO_ADDR
22053: GO 22125
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
22055: LD_ADDR_EXP 74
22059: PUSH
22060: LD_EXP 74
22064: PPUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 1
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PPUSH
22077: LD_EXP 74
22081: PUSH
22082: LD_VAR 0 2
22086: ARRAY
22087: PUSH
22088: LD_INT 1
22090: ARRAY
22091: PPUSH
22092: LD_INT 3
22094: PUSH
22095: LD_INT 24
22097: PUSH
22098: LD_INT 1000
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PUSH
22105: EMPTY
22106: LIST
22107: LIST
22108: PPUSH
22109: CALL_OW 72
22113: PUSH
22114: LD_VAR 0 6
22118: UNION
22119: PPUSH
22120: CALL 49204 0 3
22124: ST_TO_ADDR
// if not need_heal_2 then
22125: LD_VAR 0 7
22129: NOT
22130: IFFALSE 22163
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
22132: LD_ADDR_EXP 74
22136: PUSH
22137: LD_EXP 74
22141: PPUSH
22142: LD_VAR 0 2
22146: PUSH
22147: LD_INT 2
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PPUSH
22154: EMPTY
22155: PPUSH
22156: CALL 49204 0 3
22160: ST_TO_ADDR
22161: GO 22195
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
22163: LD_ADDR_EXP 74
22167: PUSH
22168: LD_EXP 74
22172: PPUSH
22173: LD_VAR 0 2
22177: PUSH
22178: LD_INT 2
22180: PUSH
22181: EMPTY
22182: LIST
22183: LIST
22184: PPUSH
22185: LD_VAR 0 7
22189: PPUSH
22190: CALL 49204 0 3
22194: ST_TO_ADDR
// if need_heal_2 then
22195: LD_VAR 0 7
22199: IFFALSE 22371
// for j in need_heal_2 do
22201: LD_ADDR_VAR 0 3
22205: PUSH
22206: LD_VAR 0 7
22210: PUSH
22211: FOR_IN
22212: IFFALSE 22369
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
22214: LD_ADDR_VAR 0 5
22218: PUSH
22219: LD_EXP 71
22223: PUSH
22224: LD_VAR 0 2
22228: ARRAY
22229: PPUSH
22230: LD_INT 2
22232: PUSH
22233: LD_INT 30
22235: PUSH
22236: LD_INT 6
22238: PUSH
22239: EMPTY
22240: LIST
22241: LIST
22242: PUSH
22243: LD_INT 30
22245: PUSH
22246: LD_INT 7
22248: PUSH
22249: EMPTY
22250: LIST
22251: LIST
22252: PUSH
22253: LD_INT 30
22255: PUSH
22256: LD_INT 8
22258: PUSH
22259: EMPTY
22260: LIST
22261: LIST
22262: PUSH
22263: LD_INT 30
22265: PUSH
22266: LD_INT 0
22268: PUSH
22269: EMPTY
22270: LIST
22271: LIST
22272: PUSH
22273: LD_INT 30
22275: PUSH
22276: LD_INT 1
22278: PUSH
22279: EMPTY
22280: LIST
22281: LIST
22282: PUSH
22283: LD_INT 25
22285: PUSH
22286: LD_INT 4
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: LIST
22301: PPUSH
22302: CALL_OW 72
22306: ST_TO_ADDR
// if tmp then
22307: LD_VAR 0 5
22311: IFFALSE 22367
// begin k := NearestUnitToUnit ( tmp , j ) ;
22313: LD_ADDR_VAR 0 4
22317: PUSH
22318: LD_VAR 0 5
22322: PPUSH
22323: LD_VAR 0 3
22327: PPUSH
22328: CALL_OW 74
22332: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
22333: LD_VAR 0 3
22337: PPUSH
22338: LD_VAR 0 4
22342: PPUSH
22343: CALL_OW 296
22347: PUSH
22348: LD_INT 7
22350: GREATER
22351: IFFALSE 22367
// ComMoveUnit ( j , k ) ;
22353: LD_VAR 0 3
22357: PPUSH
22358: LD_VAR 0 4
22362: PPUSH
22363: CALL_OW 112
// end ; end ;
22367: GO 22211
22369: POP
22370: POP
// if not need_heal_1 and not need_heal_2 then
22371: LD_VAR 0 6
22375: NOT
22376: PUSH
22377: LD_VAR 0 7
22381: NOT
22382: AND
22383: IFFALSE 22387
// continue ;
22385: GO 21840
// end ;
22387: GO 21840
22389: POP
22390: POP
// RaiseSailEvent ( 102 ) ;
22391: LD_INT 102
22393: PPUSH
22394: CALL_OW 427
// end ;
22398: LD_VAR 0 1
22402: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
22403: LD_INT 0
22405: PPUSH
22406: PPUSH
22407: PPUSH
22408: PPUSH
22409: PPUSH
// if not mc_bases then
22410: LD_EXP 71
22414: NOT
22415: IFFALSE 22419
// exit ;
22417: GO 22804
// for i = 1 to mc_bases do
22419: LD_ADDR_VAR 0 2
22423: PUSH
22424: DOUBLE
22425: LD_INT 1
22427: DEC
22428: ST_TO_ADDR
22429: LD_EXP 71
22433: PUSH
22434: FOR_TO
22435: IFFALSE 22802
// begin if not mc_building_need_repair [ i ] then
22437: LD_EXP 72
22441: PUSH
22442: LD_VAR 0 2
22446: ARRAY
22447: NOT
22448: IFFALSE 22486
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22450: LD_ADDR_EXP 73
22454: PUSH
22455: LD_EXP 73
22459: PPUSH
22460: LD_VAR 0 2
22464: PPUSH
22465: EMPTY
22466: PPUSH
22467: CALL_OW 1
22471: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
22472: LD_VAR 0 2
22476: PPUSH
22477: LD_INT 101
22479: PPUSH
22480: CALL 17847 0 2
// continue ;
22484: GO 22434
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
22486: LD_ADDR_EXP 77
22490: PUSH
22491: LD_EXP 77
22495: PPUSH
22496: LD_VAR 0 2
22500: PPUSH
22501: EMPTY
22502: PPUSH
22503: CALL_OW 1
22507: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
22508: LD_VAR 0 2
22512: PPUSH
22513: LD_INT 103
22515: PPUSH
22516: CALL 17847 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
22520: LD_ADDR_VAR 0 5
22524: PUSH
22525: LD_EXP 71
22529: PUSH
22530: LD_VAR 0 2
22534: ARRAY
22535: PUSH
22536: LD_EXP 100
22540: PUSH
22541: LD_VAR 0 2
22545: ARRAY
22546: UNION
22547: PPUSH
22548: LD_INT 2
22550: PUSH
22551: LD_INT 25
22553: PUSH
22554: LD_INT 2
22556: PUSH
22557: EMPTY
22558: LIST
22559: LIST
22560: PUSH
22561: LD_INT 25
22563: PUSH
22564: LD_INT 16
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: PPUSH
22579: CALL_OW 72
22583: ST_TO_ADDR
// if not tmp then
22584: LD_VAR 0 5
22588: NOT
22589: IFFALSE 22593
// continue ;
22591: GO 22434
// for j in tmp do
22593: LD_ADDR_VAR 0 3
22597: PUSH
22598: LD_VAR 0 5
22602: PUSH
22603: FOR_IN
22604: IFFALSE 22798
// begin if mc_need_heal [ i ] then
22606: LD_EXP 74
22610: PUSH
22611: LD_VAR 0 2
22615: ARRAY
22616: IFFALSE 22664
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
22618: LD_VAR 0 3
22622: PUSH
22623: LD_EXP 74
22627: PUSH
22628: LD_VAR 0 2
22632: ARRAY
22633: PUSH
22634: LD_INT 1
22636: ARRAY
22637: IN
22638: PUSH
22639: LD_VAR 0 3
22643: PUSH
22644: LD_EXP 74
22648: PUSH
22649: LD_VAR 0 2
22653: ARRAY
22654: PUSH
22655: LD_INT 2
22657: ARRAY
22658: IN
22659: OR
22660: IFFALSE 22664
// continue ;
22662: GO 22603
// if IsInUnit ( j ) then
22664: LD_VAR 0 3
22668: PPUSH
22669: CALL_OW 310
22673: IFFALSE 22684
// ComExitBuilding ( j ) ;
22675: LD_VAR 0 3
22679: PPUSH
22680: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
22684: LD_VAR 0 3
22688: PUSH
22689: LD_EXP 73
22693: PUSH
22694: LD_VAR 0 2
22698: ARRAY
22699: IN
22700: NOT
22701: IFFALSE 22759
// begin SetTag ( j , 101 ) ;
22703: LD_VAR 0 3
22707: PPUSH
22708: LD_INT 101
22710: PPUSH
22711: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
22715: LD_ADDR_EXP 73
22719: PUSH
22720: LD_EXP 73
22724: PPUSH
22725: LD_VAR 0 2
22729: PUSH
22730: LD_EXP 73
22734: PUSH
22735: LD_VAR 0 2
22739: ARRAY
22740: PUSH
22741: LD_INT 1
22743: PLUS
22744: PUSH
22745: EMPTY
22746: LIST
22747: LIST
22748: PPUSH
22749: LD_VAR 0 3
22753: PPUSH
22754: CALL 49204 0 3
22758: ST_TO_ADDR
// end ; wait ( 1 ) ;
22759: LD_INT 1
22761: PPUSH
22762: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
22766: LD_VAR 0 3
22770: PPUSH
22771: LD_EXP 72
22775: PUSH
22776: LD_VAR 0 2
22780: ARRAY
22781: PPUSH
22782: LD_VAR 0 3
22786: PPUSH
22787: CALL_OW 74
22791: PPUSH
22792: CALL_OW 130
// end ;
22796: GO 22603
22798: POP
22799: POP
// end ;
22800: GO 22434
22802: POP
22803: POP
// end ;
22804: LD_VAR 0 1
22808: RET
// export function MC_Heal ; var i , j , tmp ; begin
22809: LD_INT 0
22811: PPUSH
22812: PPUSH
22813: PPUSH
22814: PPUSH
// if not mc_bases then
22815: LD_EXP 71
22819: NOT
22820: IFFALSE 22824
// exit ;
22822: GO 23226
// for i = 1 to mc_bases do
22824: LD_ADDR_VAR 0 2
22828: PUSH
22829: DOUBLE
22830: LD_INT 1
22832: DEC
22833: ST_TO_ADDR
22834: LD_EXP 71
22838: PUSH
22839: FOR_TO
22840: IFFALSE 23224
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
22842: LD_EXP 74
22846: PUSH
22847: LD_VAR 0 2
22851: ARRAY
22852: PUSH
22853: LD_INT 1
22855: ARRAY
22856: NOT
22857: PUSH
22858: LD_EXP 74
22862: PUSH
22863: LD_VAR 0 2
22867: ARRAY
22868: PUSH
22869: LD_INT 2
22871: ARRAY
22872: NOT
22873: AND
22874: IFFALSE 22912
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
22876: LD_ADDR_EXP 75
22880: PUSH
22881: LD_EXP 75
22885: PPUSH
22886: LD_VAR 0 2
22890: PPUSH
22891: EMPTY
22892: PPUSH
22893: CALL_OW 1
22897: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
22898: LD_VAR 0 2
22902: PPUSH
22903: LD_INT 102
22905: PPUSH
22906: CALL 17847 0 2
// continue ;
22910: GO 22839
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
22912: LD_ADDR_VAR 0 4
22916: PUSH
22917: LD_EXP 71
22921: PUSH
22922: LD_VAR 0 2
22926: ARRAY
22927: PPUSH
22928: LD_INT 25
22930: PUSH
22931: LD_INT 4
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: PPUSH
22938: CALL_OW 72
22942: ST_TO_ADDR
// if not tmp then
22943: LD_VAR 0 4
22947: NOT
22948: IFFALSE 22952
// continue ;
22950: GO 22839
// if mc_taming [ i ] then
22952: LD_EXP 102
22956: PUSH
22957: LD_VAR 0 2
22961: ARRAY
22962: IFFALSE 22986
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
22964: LD_ADDR_EXP 102
22968: PUSH
22969: LD_EXP 102
22973: PPUSH
22974: LD_VAR 0 2
22978: PPUSH
22979: EMPTY
22980: PPUSH
22981: CALL_OW 1
22985: ST_TO_ADDR
// for j in tmp do
22986: LD_ADDR_VAR 0 3
22990: PUSH
22991: LD_VAR 0 4
22995: PUSH
22996: FOR_IN
22997: IFFALSE 23220
// begin if IsInUnit ( j ) then
22999: LD_VAR 0 3
23003: PPUSH
23004: CALL_OW 310
23008: IFFALSE 23019
// ComExitBuilding ( j ) ;
23010: LD_VAR 0 3
23014: PPUSH
23015: CALL_OW 122
// if not j in mc_healers [ i ] then
23019: LD_VAR 0 3
23023: PUSH
23024: LD_EXP 75
23028: PUSH
23029: LD_VAR 0 2
23033: ARRAY
23034: IN
23035: NOT
23036: IFFALSE 23082
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
23038: LD_ADDR_EXP 75
23042: PUSH
23043: LD_EXP 75
23047: PPUSH
23048: LD_VAR 0 2
23052: PUSH
23053: LD_EXP 75
23057: PUSH
23058: LD_VAR 0 2
23062: ARRAY
23063: PUSH
23064: LD_INT 1
23066: PLUS
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PPUSH
23072: LD_VAR 0 3
23076: PPUSH
23077: CALL 49204 0 3
23081: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
23082: LD_VAR 0 3
23086: PPUSH
23087: CALL_OW 110
23091: PUSH
23092: LD_INT 102
23094: NONEQUAL
23095: IFFALSE 23109
// SetTag ( j , 102 ) ;
23097: LD_VAR 0 3
23101: PPUSH
23102: LD_INT 102
23104: PPUSH
23105: CALL_OW 109
// Wait ( 3 ) ;
23109: LD_INT 3
23111: PPUSH
23112: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
23116: LD_EXP 74
23120: PUSH
23121: LD_VAR 0 2
23125: ARRAY
23126: PUSH
23127: LD_INT 1
23129: ARRAY
23130: IFFALSE 23162
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
23132: LD_VAR 0 3
23136: PPUSH
23137: LD_EXP 74
23141: PUSH
23142: LD_VAR 0 2
23146: ARRAY
23147: PUSH
23148: LD_INT 1
23150: ARRAY
23151: PUSH
23152: LD_INT 1
23154: ARRAY
23155: PPUSH
23156: CALL_OW 128
23160: GO 23218
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
23162: LD_VAR 0 3
23166: PPUSH
23167: CALL_OW 314
23171: NOT
23172: PUSH
23173: LD_EXP 74
23177: PUSH
23178: LD_VAR 0 2
23182: ARRAY
23183: PUSH
23184: LD_INT 2
23186: ARRAY
23187: AND
23188: IFFALSE 23218
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
23190: LD_VAR 0 3
23194: PPUSH
23195: LD_EXP 74
23199: PUSH
23200: LD_VAR 0 2
23204: ARRAY
23205: PUSH
23206: LD_INT 2
23208: ARRAY
23209: PUSH
23210: LD_INT 1
23212: ARRAY
23213: PPUSH
23214: CALL_OW 128
// end ;
23218: GO 22996
23220: POP
23221: POP
// end ;
23222: GO 22839
23224: POP
23225: POP
// end ;
23226: LD_VAR 0 1
23230: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
23231: LD_INT 0
23233: PPUSH
23234: PPUSH
23235: PPUSH
23236: PPUSH
23237: PPUSH
// if not mc_bases then
23238: LD_EXP 71
23242: NOT
23243: IFFALSE 23247
// exit ;
23245: GO 24390
// for i = 1 to mc_bases do
23247: LD_ADDR_VAR 0 2
23251: PUSH
23252: DOUBLE
23253: LD_INT 1
23255: DEC
23256: ST_TO_ADDR
23257: LD_EXP 71
23261: PUSH
23262: FOR_TO
23263: IFFALSE 24388
// begin if mc_scan [ i ] then
23265: LD_EXP 94
23269: PUSH
23270: LD_VAR 0 2
23274: ARRAY
23275: IFFALSE 23279
// continue ;
23277: GO 23262
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
23279: LD_EXP 76
23283: PUSH
23284: LD_VAR 0 2
23288: ARRAY
23289: NOT
23290: PUSH
23291: LD_EXP 78
23295: PUSH
23296: LD_VAR 0 2
23300: ARRAY
23301: NOT
23302: AND
23303: PUSH
23304: LD_EXP 77
23308: PUSH
23309: LD_VAR 0 2
23313: ARRAY
23314: AND
23315: IFFALSE 23353
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
23317: LD_ADDR_EXP 77
23321: PUSH
23322: LD_EXP 77
23326: PPUSH
23327: LD_VAR 0 2
23331: PPUSH
23332: EMPTY
23333: PPUSH
23334: CALL_OW 1
23338: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
23339: LD_VAR 0 2
23343: PPUSH
23344: LD_INT 103
23346: PPUSH
23347: CALL 17847 0 2
// continue ;
23351: GO 23262
// end ; if mc_construct_list [ i ] then
23353: LD_EXP 78
23357: PUSH
23358: LD_VAR 0 2
23362: ARRAY
23363: IFFALSE 23583
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
23365: LD_ADDR_VAR 0 4
23369: PUSH
23370: LD_EXP 71
23374: PUSH
23375: LD_VAR 0 2
23379: ARRAY
23380: PPUSH
23381: LD_INT 25
23383: PUSH
23384: LD_INT 2
23386: PUSH
23387: EMPTY
23388: LIST
23389: LIST
23390: PPUSH
23391: CALL_OW 72
23395: PUSH
23396: LD_EXP 73
23400: PUSH
23401: LD_VAR 0 2
23405: ARRAY
23406: DIFF
23407: ST_TO_ADDR
// if not tmp then
23408: LD_VAR 0 4
23412: NOT
23413: IFFALSE 23417
// continue ;
23415: GO 23262
// for j in tmp do
23417: LD_ADDR_VAR 0 3
23421: PUSH
23422: LD_VAR 0 4
23426: PUSH
23427: FOR_IN
23428: IFFALSE 23579
// begin if not mc_builders [ i ] then
23430: LD_EXP 77
23434: PUSH
23435: LD_VAR 0 2
23439: ARRAY
23440: NOT
23441: IFFALSE 23499
// begin SetTag ( j , 103 ) ;
23443: LD_VAR 0 3
23447: PPUSH
23448: LD_INT 103
23450: PPUSH
23451: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
23455: LD_ADDR_EXP 77
23459: PUSH
23460: LD_EXP 77
23464: PPUSH
23465: LD_VAR 0 2
23469: PUSH
23470: LD_EXP 77
23474: PUSH
23475: LD_VAR 0 2
23479: ARRAY
23480: PUSH
23481: LD_INT 1
23483: PLUS
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PPUSH
23489: LD_VAR 0 3
23493: PPUSH
23494: CALL 49204 0 3
23498: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
23499: LD_VAR 0 3
23503: PPUSH
23504: CALL_OW 310
23508: IFFALSE 23519
// ComExitBuilding ( j ) ;
23510: LD_VAR 0 3
23514: PPUSH
23515: CALL_OW 122
// wait ( 3 ) ;
23519: LD_INT 3
23521: PPUSH
23522: CALL_OW 67
// if not mc_construct_list [ i ] then
23526: LD_EXP 78
23530: PUSH
23531: LD_VAR 0 2
23535: ARRAY
23536: NOT
23537: IFFALSE 23541
// break ;
23539: GO 23579
// if not HasTask ( j ) then
23541: LD_VAR 0 3
23545: PPUSH
23546: CALL_OW 314
23550: NOT
23551: IFFALSE 23577
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
23553: LD_VAR 0 3
23557: PPUSH
23558: LD_EXP 78
23562: PUSH
23563: LD_VAR 0 2
23567: ARRAY
23568: PUSH
23569: LD_INT 1
23571: ARRAY
23572: PPUSH
23573: CALL 52055 0 2
// end ;
23577: GO 23427
23579: POP
23580: POP
// end else
23581: GO 24386
// if mc_build_list [ i ] then
23583: LD_EXP 76
23587: PUSH
23588: LD_VAR 0 2
23592: ARRAY
23593: IFFALSE 24386
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
23595: LD_ADDR_VAR 0 5
23599: PUSH
23600: LD_EXP 71
23604: PUSH
23605: LD_VAR 0 2
23609: ARRAY
23610: PPUSH
23611: LD_INT 2
23613: PUSH
23614: LD_INT 30
23616: PUSH
23617: LD_INT 0
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: PUSH
23624: LD_INT 30
23626: PUSH
23627: LD_INT 1
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: LIST
23638: PPUSH
23639: CALL_OW 72
23643: ST_TO_ADDR
// if depot then
23644: LD_VAR 0 5
23648: IFFALSE 23666
// depot := depot [ 1 ] else
23650: LD_ADDR_VAR 0 5
23654: PUSH
23655: LD_VAR 0 5
23659: PUSH
23660: LD_INT 1
23662: ARRAY
23663: ST_TO_ADDR
23664: GO 23674
// depot := 0 ;
23666: LD_ADDR_VAR 0 5
23670: PUSH
23671: LD_INT 0
23673: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
23674: LD_EXP 76
23678: PUSH
23679: LD_VAR 0 2
23683: ARRAY
23684: PUSH
23685: LD_INT 1
23687: ARRAY
23688: PUSH
23689: LD_INT 1
23691: ARRAY
23692: PPUSH
23693: CALL 51885 0 1
23697: PUSH
23698: LD_EXP 71
23702: PUSH
23703: LD_VAR 0 2
23707: ARRAY
23708: PPUSH
23709: LD_INT 2
23711: PUSH
23712: LD_INT 30
23714: PUSH
23715: LD_INT 2
23717: PUSH
23718: EMPTY
23719: LIST
23720: LIST
23721: PUSH
23722: LD_INT 30
23724: PUSH
23725: LD_INT 3
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PUSH
23732: EMPTY
23733: LIST
23734: LIST
23735: LIST
23736: PPUSH
23737: CALL_OW 72
23741: NOT
23742: AND
23743: IFFALSE 23848
// begin for j = 1 to mc_build_list [ i ] do
23745: LD_ADDR_VAR 0 3
23749: PUSH
23750: DOUBLE
23751: LD_INT 1
23753: DEC
23754: ST_TO_ADDR
23755: LD_EXP 76
23759: PUSH
23760: LD_VAR 0 2
23764: ARRAY
23765: PUSH
23766: FOR_TO
23767: IFFALSE 23846
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
23769: LD_EXP 76
23773: PUSH
23774: LD_VAR 0 2
23778: ARRAY
23779: PUSH
23780: LD_VAR 0 3
23784: ARRAY
23785: PUSH
23786: LD_INT 1
23788: ARRAY
23789: PUSH
23790: LD_INT 2
23792: EQUAL
23793: IFFALSE 23844
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
23795: LD_ADDR_EXP 76
23799: PUSH
23800: LD_EXP 76
23804: PPUSH
23805: LD_VAR 0 2
23809: PPUSH
23810: LD_EXP 76
23814: PUSH
23815: LD_VAR 0 2
23819: ARRAY
23820: PPUSH
23821: LD_VAR 0 3
23825: PPUSH
23826: LD_INT 1
23828: PPUSH
23829: LD_INT 0
23831: PPUSH
23832: CALL 48622 0 4
23836: PPUSH
23837: CALL_OW 1
23841: ST_TO_ADDR
// break ;
23842: GO 23846
// end ;
23844: GO 23766
23846: POP
23847: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
23848: LD_EXP 76
23852: PUSH
23853: LD_VAR 0 2
23857: ARRAY
23858: PUSH
23859: LD_INT 1
23861: ARRAY
23862: PUSH
23863: LD_INT 1
23865: ARRAY
23866: PUSH
23867: LD_INT 0
23869: EQUAL
23870: PUSH
23871: LD_VAR 0 5
23875: PUSH
23876: LD_VAR 0 5
23880: PPUSH
23881: LD_EXP 76
23885: PUSH
23886: LD_VAR 0 2
23890: ARRAY
23891: PUSH
23892: LD_INT 1
23894: ARRAY
23895: PUSH
23896: LD_INT 1
23898: ARRAY
23899: PPUSH
23900: LD_EXP 76
23904: PUSH
23905: LD_VAR 0 2
23909: ARRAY
23910: PUSH
23911: LD_INT 1
23913: ARRAY
23914: PUSH
23915: LD_INT 2
23917: ARRAY
23918: PPUSH
23919: LD_EXP 76
23923: PUSH
23924: LD_VAR 0 2
23928: ARRAY
23929: PUSH
23930: LD_INT 1
23932: ARRAY
23933: PUSH
23934: LD_INT 3
23936: ARRAY
23937: PPUSH
23938: LD_EXP 76
23942: PUSH
23943: LD_VAR 0 2
23947: ARRAY
23948: PUSH
23949: LD_INT 1
23951: ARRAY
23952: PUSH
23953: LD_INT 4
23955: ARRAY
23956: PPUSH
23957: CALL 56601 0 5
23961: AND
23962: OR
23963: IFFALSE 24244
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
23965: LD_ADDR_VAR 0 4
23969: PUSH
23970: LD_EXP 71
23974: PUSH
23975: LD_VAR 0 2
23979: ARRAY
23980: PPUSH
23981: LD_INT 25
23983: PUSH
23984: LD_INT 2
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PPUSH
23991: CALL_OW 72
23995: PUSH
23996: LD_EXP 73
24000: PUSH
24001: LD_VAR 0 2
24005: ARRAY
24006: DIFF
24007: ST_TO_ADDR
// if not tmp then
24008: LD_VAR 0 4
24012: NOT
24013: IFFALSE 24017
// continue ;
24015: GO 23262
// for j in tmp do
24017: LD_ADDR_VAR 0 3
24021: PUSH
24022: LD_VAR 0 4
24026: PUSH
24027: FOR_IN
24028: IFFALSE 24240
// begin if not mc_builders [ i ] then
24030: LD_EXP 77
24034: PUSH
24035: LD_VAR 0 2
24039: ARRAY
24040: NOT
24041: IFFALSE 24099
// begin SetTag ( j , 103 ) ;
24043: LD_VAR 0 3
24047: PPUSH
24048: LD_INT 103
24050: PPUSH
24051: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
24055: LD_ADDR_EXP 77
24059: PUSH
24060: LD_EXP 77
24064: PPUSH
24065: LD_VAR 0 2
24069: PUSH
24070: LD_EXP 77
24074: PUSH
24075: LD_VAR 0 2
24079: ARRAY
24080: PUSH
24081: LD_INT 1
24083: PLUS
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PPUSH
24089: LD_VAR 0 3
24093: PPUSH
24094: CALL 49204 0 3
24098: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
24099: LD_VAR 0 3
24103: PPUSH
24104: CALL_OW 310
24108: IFFALSE 24119
// ComExitBuilding ( j ) ;
24110: LD_VAR 0 3
24114: PPUSH
24115: CALL_OW 122
// wait ( 3 ) ;
24119: LD_INT 3
24121: PPUSH
24122: CALL_OW 67
// if not mc_build_list [ i ] then
24126: LD_EXP 76
24130: PUSH
24131: LD_VAR 0 2
24135: ARRAY
24136: NOT
24137: IFFALSE 24141
// break ;
24139: GO 24240
// if not HasTask ( j ) then
24141: LD_VAR 0 3
24145: PPUSH
24146: CALL_OW 314
24150: NOT
24151: IFFALSE 24238
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
24153: LD_VAR 0 3
24157: PPUSH
24158: LD_EXP 76
24162: PUSH
24163: LD_VAR 0 2
24167: ARRAY
24168: PUSH
24169: LD_INT 1
24171: ARRAY
24172: PUSH
24173: LD_INT 1
24175: ARRAY
24176: PPUSH
24177: LD_EXP 76
24181: PUSH
24182: LD_VAR 0 2
24186: ARRAY
24187: PUSH
24188: LD_INT 1
24190: ARRAY
24191: PUSH
24192: LD_INT 2
24194: ARRAY
24195: PPUSH
24196: LD_EXP 76
24200: PUSH
24201: LD_VAR 0 2
24205: ARRAY
24206: PUSH
24207: LD_INT 1
24209: ARRAY
24210: PUSH
24211: LD_INT 3
24213: ARRAY
24214: PPUSH
24215: LD_EXP 76
24219: PUSH
24220: LD_VAR 0 2
24224: ARRAY
24225: PUSH
24226: LD_INT 1
24228: ARRAY
24229: PUSH
24230: LD_INT 4
24232: ARRAY
24233: PPUSH
24234: CALL_OW 145
// end ;
24238: GO 24027
24240: POP
24241: POP
// end else
24242: GO 24386
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
24244: LD_EXP 71
24248: PUSH
24249: LD_VAR 0 2
24253: ARRAY
24254: PPUSH
24255: LD_EXP 76
24259: PUSH
24260: LD_VAR 0 2
24264: ARRAY
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: PUSH
24270: LD_INT 1
24272: ARRAY
24273: PPUSH
24274: LD_EXP 76
24278: PUSH
24279: LD_VAR 0 2
24283: ARRAY
24284: PUSH
24285: LD_INT 1
24287: ARRAY
24288: PUSH
24289: LD_INT 2
24291: ARRAY
24292: PPUSH
24293: LD_EXP 76
24297: PUSH
24298: LD_VAR 0 2
24302: ARRAY
24303: PUSH
24304: LD_INT 1
24306: ARRAY
24307: PUSH
24308: LD_INT 3
24310: ARRAY
24311: PPUSH
24312: LD_EXP 76
24316: PUSH
24317: LD_VAR 0 2
24321: ARRAY
24322: PUSH
24323: LD_INT 1
24325: ARRAY
24326: PUSH
24327: LD_INT 4
24329: ARRAY
24330: PPUSH
24331: CALL 55955 0 5
24335: NOT
24336: IFFALSE 24386
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
24338: LD_ADDR_EXP 76
24342: PUSH
24343: LD_EXP 76
24347: PPUSH
24348: LD_VAR 0 2
24352: PPUSH
24353: LD_EXP 76
24357: PUSH
24358: LD_VAR 0 2
24362: ARRAY
24363: PPUSH
24364: LD_INT 1
24366: PPUSH
24367: LD_INT 1
24369: NEG
24370: PPUSH
24371: LD_INT 0
24373: PPUSH
24374: CALL 48622 0 4
24378: PPUSH
24379: CALL_OW 1
24383: ST_TO_ADDR
// continue ;
24384: GO 23262
// end ; end ; end ;
24386: GO 23262
24388: POP
24389: POP
// end ;
24390: LD_VAR 0 1
24394: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
24395: LD_INT 0
24397: PPUSH
24398: PPUSH
24399: PPUSH
24400: PPUSH
24401: PPUSH
24402: PPUSH
// if not mc_bases then
24403: LD_EXP 71
24407: NOT
24408: IFFALSE 24412
// exit ;
24410: GO 24839
// for i = 1 to mc_bases do
24412: LD_ADDR_VAR 0 2
24416: PUSH
24417: DOUBLE
24418: LD_INT 1
24420: DEC
24421: ST_TO_ADDR
24422: LD_EXP 71
24426: PUSH
24427: FOR_TO
24428: IFFALSE 24837
// begin tmp := mc_build_upgrade [ i ] ;
24430: LD_ADDR_VAR 0 4
24434: PUSH
24435: LD_EXP 103
24439: PUSH
24440: LD_VAR 0 2
24444: ARRAY
24445: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
24446: LD_ADDR_VAR 0 6
24450: PUSH
24451: LD_EXP 104
24455: PUSH
24456: LD_VAR 0 2
24460: ARRAY
24461: PPUSH
24462: LD_INT 2
24464: PUSH
24465: LD_INT 30
24467: PUSH
24468: LD_INT 6
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: LD_INT 30
24477: PUSH
24478: LD_INT 7
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: LIST
24489: PPUSH
24490: CALL_OW 72
24494: ST_TO_ADDR
// if not tmp and not lab then
24495: LD_VAR 0 4
24499: NOT
24500: PUSH
24501: LD_VAR 0 6
24505: NOT
24506: AND
24507: IFFALSE 24511
// continue ;
24509: GO 24427
// if tmp then
24511: LD_VAR 0 4
24515: IFFALSE 24635
// for j in tmp do
24517: LD_ADDR_VAR 0 3
24521: PUSH
24522: LD_VAR 0 4
24526: PUSH
24527: FOR_IN
24528: IFFALSE 24633
// begin if UpgradeCost ( j ) then
24530: LD_VAR 0 3
24534: PPUSH
24535: CALL 55615 0 1
24539: IFFALSE 24631
// begin ComUpgrade ( j ) ;
24541: LD_VAR 0 3
24545: PPUSH
24546: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
24550: LD_ADDR_EXP 103
24554: PUSH
24555: LD_EXP 103
24559: PPUSH
24560: LD_VAR 0 2
24564: PPUSH
24565: LD_EXP 103
24569: PUSH
24570: LD_VAR 0 2
24574: ARRAY
24575: PUSH
24576: LD_VAR 0 3
24580: DIFF
24581: PPUSH
24582: CALL_OW 1
24586: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
24587: LD_ADDR_EXP 78
24591: PUSH
24592: LD_EXP 78
24596: PPUSH
24597: LD_VAR 0 2
24601: PUSH
24602: LD_EXP 78
24606: PUSH
24607: LD_VAR 0 2
24611: ARRAY
24612: PUSH
24613: LD_INT 1
24615: PLUS
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PPUSH
24621: LD_VAR 0 3
24625: PPUSH
24626: CALL 49204 0 3
24630: ST_TO_ADDR
// end ; end ;
24631: GO 24527
24633: POP
24634: POP
// if not lab or not mc_lab_upgrade [ i ] then
24635: LD_VAR 0 6
24639: NOT
24640: PUSH
24641: LD_EXP 105
24645: PUSH
24646: LD_VAR 0 2
24650: ARRAY
24651: NOT
24652: OR
24653: IFFALSE 24657
// continue ;
24655: GO 24427
// for j in lab do
24657: LD_ADDR_VAR 0 3
24661: PUSH
24662: LD_VAR 0 6
24666: PUSH
24667: FOR_IN
24668: IFFALSE 24833
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
24670: LD_VAR 0 3
24674: PPUSH
24675: CALL_OW 266
24679: PUSH
24680: LD_INT 6
24682: PUSH
24683: LD_INT 7
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: IN
24690: PUSH
24691: LD_VAR 0 3
24695: PPUSH
24696: CALL_OW 461
24700: PUSH
24701: LD_INT 1
24703: NONEQUAL
24704: AND
24705: IFFALSE 24831
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
24707: LD_VAR 0 3
24711: PPUSH
24712: LD_EXP 105
24716: PUSH
24717: LD_VAR 0 2
24721: ARRAY
24722: PUSH
24723: LD_INT 1
24725: ARRAY
24726: PPUSH
24727: CALL 55820 0 2
24731: IFFALSE 24831
// begin ComCancel ( j ) ;
24733: LD_VAR 0 3
24737: PPUSH
24738: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
24742: LD_VAR 0 3
24746: PPUSH
24747: LD_EXP 105
24751: PUSH
24752: LD_VAR 0 2
24756: ARRAY
24757: PUSH
24758: LD_INT 1
24760: ARRAY
24761: PPUSH
24762: CALL_OW 207
// if not j in mc_construct_list [ i ] then
24766: LD_VAR 0 3
24770: PUSH
24771: LD_EXP 78
24775: PUSH
24776: LD_VAR 0 2
24780: ARRAY
24781: IN
24782: NOT
24783: IFFALSE 24829
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
24785: LD_ADDR_EXP 78
24789: PUSH
24790: LD_EXP 78
24794: PPUSH
24795: LD_VAR 0 2
24799: PUSH
24800: LD_EXP 78
24804: PUSH
24805: LD_VAR 0 2
24809: ARRAY
24810: PUSH
24811: LD_INT 1
24813: PLUS
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: PPUSH
24819: LD_VAR 0 3
24823: PPUSH
24824: CALL 49204 0 3
24828: ST_TO_ADDR
// break ;
24829: GO 24833
// end ; end ; end ;
24831: GO 24667
24833: POP
24834: POP
// end ;
24835: GO 24427
24837: POP
24838: POP
// end ;
24839: LD_VAR 0 1
24843: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
24844: LD_INT 0
24846: PPUSH
24847: PPUSH
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
24852: PPUSH
24853: PPUSH
24854: PPUSH
// if not mc_bases then
24855: LD_EXP 71
24859: NOT
24860: IFFALSE 24864
// exit ;
24862: GO 25269
// for i = 1 to mc_bases do
24864: LD_ADDR_VAR 0 2
24868: PUSH
24869: DOUBLE
24870: LD_INT 1
24872: DEC
24873: ST_TO_ADDR
24874: LD_EXP 71
24878: PUSH
24879: FOR_TO
24880: IFFALSE 25267
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
24882: LD_EXP 79
24886: PUSH
24887: LD_VAR 0 2
24891: ARRAY
24892: NOT
24893: PUSH
24894: LD_EXP 71
24898: PUSH
24899: LD_VAR 0 2
24903: ARRAY
24904: PPUSH
24905: LD_INT 30
24907: PUSH
24908: LD_INT 3
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PPUSH
24915: CALL_OW 72
24919: NOT
24920: OR
24921: IFFALSE 24925
// continue ;
24923: GO 24879
// busy := false ;
24925: LD_ADDR_VAR 0 8
24929: PUSH
24930: LD_INT 0
24932: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
24933: LD_ADDR_VAR 0 4
24937: PUSH
24938: LD_EXP 71
24942: PUSH
24943: LD_VAR 0 2
24947: ARRAY
24948: PPUSH
24949: LD_INT 30
24951: PUSH
24952: LD_INT 3
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: PPUSH
24959: CALL_OW 72
24963: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
24964: LD_ADDR_VAR 0 6
24968: PUSH
24969: LD_EXP 79
24973: PUSH
24974: LD_VAR 0 2
24978: ARRAY
24979: PPUSH
24980: LD_INT 2
24982: PUSH
24983: LD_INT 30
24985: PUSH
24986: LD_INT 32
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: LD_INT 30
24995: PUSH
24996: LD_INT 33
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: EMPTY
25004: LIST
25005: LIST
25006: LIST
25007: PPUSH
25008: CALL_OW 72
25012: ST_TO_ADDR
// if not t then
25013: LD_VAR 0 6
25017: NOT
25018: IFFALSE 25022
// continue ;
25020: GO 24879
// for j in tmp do
25022: LD_ADDR_VAR 0 3
25026: PUSH
25027: LD_VAR 0 4
25031: PUSH
25032: FOR_IN
25033: IFFALSE 25063
// if not BuildingStatus ( j ) = bs_idle then
25035: LD_VAR 0 3
25039: PPUSH
25040: CALL_OW 461
25044: PUSH
25045: LD_INT 2
25047: EQUAL
25048: NOT
25049: IFFALSE 25061
// begin busy := true ;
25051: LD_ADDR_VAR 0 8
25055: PUSH
25056: LD_INT 1
25058: ST_TO_ADDR
// break ;
25059: GO 25063
// end ;
25061: GO 25032
25063: POP
25064: POP
// if busy then
25065: LD_VAR 0 8
25069: IFFALSE 25073
// continue ;
25071: GO 24879
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
25073: LD_ADDR_VAR 0 7
25077: PUSH
25078: LD_VAR 0 6
25082: PPUSH
25083: LD_INT 35
25085: PUSH
25086: LD_INT 0
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PPUSH
25093: CALL_OW 72
25097: ST_TO_ADDR
// if tw then
25098: LD_VAR 0 7
25102: IFFALSE 25179
// begin tw := tw [ 1 ] ;
25104: LD_ADDR_VAR 0 7
25108: PUSH
25109: LD_VAR 0 7
25113: PUSH
25114: LD_INT 1
25116: ARRAY
25117: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
25118: LD_ADDR_VAR 0 9
25122: PUSH
25123: LD_VAR 0 7
25127: PPUSH
25128: LD_EXP 96
25132: PUSH
25133: LD_VAR 0 2
25137: ARRAY
25138: PPUSH
25139: CALL 54174 0 2
25143: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
25144: LD_EXP 110
25148: PUSH
25149: LD_VAR 0 2
25153: ARRAY
25154: IFFALSE 25177
// if not weapon in mc_allowed_tower_weapons [ i ] then
25156: LD_VAR 0 9
25160: PUSH
25161: LD_EXP 110
25165: PUSH
25166: LD_VAR 0 2
25170: ARRAY
25171: IN
25172: NOT
25173: IFFALSE 25177
// continue ;
25175: GO 24879
// end else
25177: GO 25242
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
25179: LD_ADDR_VAR 0 5
25183: PUSH
25184: LD_EXP 79
25188: PUSH
25189: LD_VAR 0 2
25193: ARRAY
25194: PPUSH
25195: LD_VAR 0 4
25199: PPUSH
25200: CALL 84313 0 2
25204: ST_TO_ADDR
// if not tmp2 then
25205: LD_VAR 0 5
25209: NOT
25210: IFFALSE 25214
// continue ;
25212: GO 24879
// tw := tmp2 [ 1 ] ;
25214: LD_ADDR_VAR 0 7
25218: PUSH
25219: LD_VAR 0 5
25223: PUSH
25224: LD_INT 1
25226: ARRAY
25227: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
25228: LD_ADDR_VAR 0 9
25232: PUSH
25233: LD_VAR 0 5
25237: PUSH
25238: LD_INT 2
25240: ARRAY
25241: ST_TO_ADDR
// end ; if not weapon then
25242: LD_VAR 0 9
25246: NOT
25247: IFFALSE 25251
// continue ;
25249: GO 24879
// ComPlaceWeapon ( tw , weapon ) ;
25251: LD_VAR 0 7
25255: PPUSH
25256: LD_VAR 0 9
25260: PPUSH
25261: CALL_OW 148
// end ;
25265: GO 24879
25267: POP
25268: POP
// end ;
25269: LD_VAR 0 1
25273: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
25274: LD_INT 0
25276: PPUSH
25277: PPUSH
25278: PPUSH
25279: PPUSH
25280: PPUSH
25281: PPUSH
// if not mc_bases then
25282: LD_EXP 71
25286: NOT
25287: IFFALSE 25291
// exit ;
25289: GO 26303
// for i = 1 to mc_bases do
25291: LD_ADDR_VAR 0 2
25295: PUSH
25296: DOUBLE
25297: LD_INT 1
25299: DEC
25300: ST_TO_ADDR
25301: LD_EXP 71
25305: PUSH
25306: FOR_TO
25307: IFFALSE 26301
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
25309: LD_EXP 84
25313: PUSH
25314: LD_VAR 0 2
25318: ARRAY
25319: NOT
25320: PUSH
25321: LD_EXP 84
25325: PUSH
25326: LD_VAR 0 2
25330: ARRAY
25331: PUSH
25332: LD_EXP 85
25336: PUSH
25337: LD_VAR 0 2
25341: ARRAY
25342: EQUAL
25343: OR
25344: IFFALSE 25348
// continue ;
25346: GO 25306
// if mc_miners [ i ] then
25348: LD_EXP 85
25352: PUSH
25353: LD_VAR 0 2
25357: ARRAY
25358: IFFALSE 25988
// begin k := 1 ;
25360: LD_ADDR_VAR 0 4
25364: PUSH
25365: LD_INT 1
25367: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
25368: LD_ADDR_VAR 0 3
25372: PUSH
25373: DOUBLE
25374: LD_EXP 85
25378: PUSH
25379: LD_VAR 0 2
25383: ARRAY
25384: INC
25385: ST_TO_ADDR
25386: LD_INT 1
25388: PUSH
25389: FOR_DOWNTO
25390: IFFALSE 25986
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
25392: LD_EXP 85
25396: PUSH
25397: LD_VAR 0 2
25401: ARRAY
25402: PUSH
25403: LD_VAR 0 3
25407: ARRAY
25408: PPUSH
25409: CALL_OW 301
25413: PUSH
25414: LD_EXP 85
25418: PUSH
25419: LD_VAR 0 2
25423: ARRAY
25424: PUSH
25425: LD_VAR 0 3
25429: ARRAY
25430: PPUSH
25431: CALL_OW 257
25435: PUSH
25436: LD_INT 1
25438: NONEQUAL
25439: OR
25440: IFFALSE 25503
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
25442: LD_ADDR_VAR 0 5
25446: PUSH
25447: LD_EXP 85
25451: PUSH
25452: LD_VAR 0 2
25456: ARRAY
25457: PUSH
25458: LD_EXP 85
25462: PUSH
25463: LD_VAR 0 2
25467: ARRAY
25468: PUSH
25469: LD_VAR 0 3
25473: ARRAY
25474: DIFF
25475: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
25476: LD_ADDR_EXP 85
25480: PUSH
25481: LD_EXP 85
25485: PPUSH
25486: LD_VAR 0 2
25490: PPUSH
25491: LD_VAR 0 5
25495: PPUSH
25496: CALL_OW 1
25500: ST_TO_ADDR
// continue ;
25501: GO 25389
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
25503: LD_EXP 85
25507: PUSH
25508: LD_VAR 0 2
25512: ARRAY
25513: PUSH
25514: LD_VAR 0 3
25518: ARRAY
25519: PPUSH
25520: CALL 49140 0 1
25524: PUSH
25525: LD_EXP 85
25529: PUSH
25530: LD_VAR 0 2
25534: ARRAY
25535: PUSH
25536: LD_VAR 0 3
25540: ARRAY
25541: PPUSH
25542: CALL_OW 255
25546: PPUSH
25547: LD_EXP 84
25551: PUSH
25552: LD_VAR 0 2
25556: ARRAY
25557: PUSH
25558: LD_VAR 0 4
25562: ARRAY
25563: PUSH
25564: LD_INT 1
25566: ARRAY
25567: PPUSH
25568: LD_EXP 84
25572: PUSH
25573: LD_VAR 0 2
25577: ARRAY
25578: PUSH
25579: LD_VAR 0 4
25583: ARRAY
25584: PUSH
25585: LD_INT 2
25587: ARRAY
25588: PPUSH
25589: LD_INT 15
25591: PPUSH
25592: CALL 50100 0 4
25596: PUSH
25597: LD_INT 4
25599: ARRAY
25600: PUSH
25601: LD_EXP 85
25605: PUSH
25606: LD_VAR 0 2
25610: ARRAY
25611: PUSH
25612: LD_VAR 0 3
25616: ARRAY
25617: PPUSH
25618: LD_INT 10
25620: PPUSH
25621: CALL 51797 0 2
25625: PUSH
25626: LD_INT 4
25628: ARRAY
25629: OR
25630: AND
25631: IFFALSE 25654
// ComStop ( mc_miners [ i ] [ j ] ) ;
25633: LD_EXP 85
25637: PUSH
25638: LD_VAR 0 2
25642: ARRAY
25643: PUSH
25644: LD_VAR 0 3
25648: ARRAY
25649: PPUSH
25650: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
25654: LD_EXP 85
25658: PUSH
25659: LD_VAR 0 2
25663: ARRAY
25664: PUSH
25665: LD_VAR 0 3
25669: ARRAY
25670: PPUSH
25671: CALL_OW 257
25675: PUSH
25676: LD_INT 1
25678: EQUAL
25679: PUSH
25680: LD_EXP 85
25684: PUSH
25685: LD_VAR 0 2
25689: ARRAY
25690: PUSH
25691: LD_VAR 0 3
25695: ARRAY
25696: PPUSH
25697: CALL_OW 459
25701: NOT
25702: AND
25703: PUSH
25704: LD_EXP 85
25708: PUSH
25709: LD_VAR 0 2
25713: ARRAY
25714: PUSH
25715: LD_VAR 0 3
25719: ARRAY
25720: PPUSH
25721: CALL_OW 255
25725: PPUSH
25726: LD_EXP 84
25730: PUSH
25731: LD_VAR 0 2
25735: ARRAY
25736: PUSH
25737: LD_VAR 0 4
25741: ARRAY
25742: PUSH
25743: LD_INT 1
25745: ARRAY
25746: PPUSH
25747: LD_EXP 84
25751: PUSH
25752: LD_VAR 0 2
25756: ARRAY
25757: PUSH
25758: LD_VAR 0 4
25762: ARRAY
25763: PUSH
25764: LD_INT 2
25766: ARRAY
25767: PPUSH
25768: LD_INT 15
25770: PPUSH
25771: CALL 50100 0 4
25775: PUSH
25776: LD_INT 4
25778: ARRAY
25779: PUSH
25780: LD_INT 0
25782: EQUAL
25783: AND
25784: PUSH
25785: LD_EXP 85
25789: PUSH
25790: LD_VAR 0 2
25794: ARRAY
25795: PUSH
25796: LD_VAR 0 3
25800: ARRAY
25801: PPUSH
25802: CALL_OW 314
25806: NOT
25807: AND
25808: IFFALSE 25984
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
25810: LD_EXP 85
25814: PUSH
25815: LD_VAR 0 2
25819: ARRAY
25820: PUSH
25821: LD_VAR 0 3
25825: ARRAY
25826: PPUSH
25827: CALL_OW 310
25831: IFFALSE 25854
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
25833: LD_EXP 85
25837: PUSH
25838: LD_VAR 0 2
25842: ARRAY
25843: PUSH
25844: LD_VAR 0 3
25848: ARRAY
25849: PPUSH
25850: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
25854: LD_EXP 85
25858: PUSH
25859: LD_VAR 0 2
25863: ARRAY
25864: PUSH
25865: LD_VAR 0 3
25869: ARRAY
25870: PPUSH
25871: CALL_OW 314
25875: NOT
25876: IFFALSE 25944
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
25878: LD_EXP 85
25882: PUSH
25883: LD_VAR 0 2
25887: ARRAY
25888: PUSH
25889: LD_VAR 0 3
25893: ARRAY
25894: PPUSH
25895: LD_EXP 84
25899: PUSH
25900: LD_VAR 0 2
25904: ARRAY
25905: PUSH
25906: LD_VAR 0 4
25910: ARRAY
25911: PUSH
25912: LD_INT 1
25914: ARRAY
25915: PPUSH
25916: LD_EXP 84
25920: PUSH
25921: LD_VAR 0 2
25925: ARRAY
25926: PUSH
25927: LD_VAR 0 4
25931: ARRAY
25932: PUSH
25933: LD_INT 2
25935: ARRAY
25936: PPUSH
25937: LD_INT 0
25939: PPUSH
25940: CALL_OW 193
// k := k + 1 ;
25944: LD_ADDR_VAR 0 4
25948: PUSH
25949: LD_VAR 0 4
25953: PUSH
25954: LD_INT 1
25956: PLUS
25957: ST_TO_ADDR
// if k > mc_mines [ i ] then
25958: LD_VAR 0 4
25962: PUSH
25963: LD_EXP 84
25967: PUSH
25968: LD_VAR 0 2
25972: ARRAY
25973: GREATER
25974: IFFALSE 25984
// k := 1 ;
25976: LD_ADDR_VAR 0 4
25980: PUSH
25981: LD_INT 1
25983: ST_TO_ADDR
// end ; end ;
25984: GO 25389
25986: POP
25987: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
25988: LD_ADDR_VAR 0 5
25992: PUSH
25993: LD_EXP 71
25997: PUSH
25998: LD_VAR 0 2
26002: ARRAY
26003: PPUSH
26004: LD_INT 2
26006: PUSH
26007: LD_INT 30
26009: PUSH
26010: LD_INT 4
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 30
26019: PUSH
26020: LD_INT 5
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 30
26029: PUSH
26030: LD_INT 32
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: LIST
26041: LIST
26042: PPUSH
26043: CALL_OW 72
26047: ST_TO_ADDR
// if not tmp then
26048: LD_VAR 0 5
26052: NOT
26053: IFFALSE 26057
// continue ;
26055: GO 25306
// list := [ ] ;
26057: LD_ADDR_VAR 0 6
26061: PUSH
26062: EMPTY
26063: ST_TO_ADDR
// for j in tmp do
26064: LD_ADDR_VAR 0 3
26068: PUSH
26069: LD_VAR 0 5
26073: PUSH
26074: FOR_IN
26075: IFFALSE 26144
// begin for k in UnitsInside ( j ) do
26077: LD_ADDR_VAR 0 4
26081: PUSH
26082: LD_VAR 0 3
26086: PPUSH
26087: CALL_OW 313
26091: PUSH
26092: FOR_IN
26093: IFFALSE 26140
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
26095: LD_VAR 0 4
26099: PPUSH
26100: CALL_OW 257
26104: PUSH
26105: LD_INT 1
26107: EQUAL
26108: PUSH
26109: LD_VAR 0 4
26113: PPUSH
26114: CALL_OW 459
26118: NOT
26119: AND
26120: IFFALSE 26138
// list := list ^ k ;
26122: LD_ADDR_VAR 0 6
26126: PUSH
26127: LD_VAR 0 6
26131: PUSH
26132: LD_VAR 0 4
26136: ADD
26137: ST_TO_ADDR
26138: GO 26092
26140: POP
26141: POP
// end ;
26142: GO 26074
26144: POP
26145: POP
// list := list diff mc_miners [ i ] ;
26146: LD_ADDR_VAR 0 6
26150: PUSH
26151: LD_VAR 0 6
26155: PUSH
26156: LD_EXP 85
26160: PUSH
26161: LD_VAR 0 2
26165: ARRAY
26166: DIFF
26167: ST_TO_ADDR
// if not list then
26168: LD_VAR 0 6
26172: NOT
26173: IFFALSE 26177
// continue ;
26175: GO 25306
// k := mc_mines [ i ] - mc_miners [ i ] ;
26177: LD_ADDR_VAR 0 4
26181: PUSH
26182: LD_EXP 84
26186: PUSH
26187: LD_VAR 0 2
26191: ARRAY
26192: PUSH
26193: LD_EXP 85
26197: PUSH
26198: LD_VAR 0 2
26202: ARRAY
26203: MINUS
26204: ST_TO_ADDR
// if k > list then
26205: LD_VAR 0 4
26209: PUSH
26210: LD_VAR 0 6
26214: GREATER
26215: IFFALSE 26227
// k := list ;
26217: LD_ADDR_VAR 0 4
26221: PUSH
26222: LD_VAR 0 6
26226: ST_TO_ADDR
// for j = 1 to k do
26227: LD_ADDR_VAR 0 3
26231: PUSH
26232: DOUBLE
26233: LD_INT 1
26235: DEC
26236: ST_TO_ADDR
26237: LD_VAR 0 4
26241: PUSH
26242: FOR_TO
26243: IFFALSE 26297
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
26245: LD_ADDR_EXP 85
26249: PUSH
26250: LD_EXP 85
26254: PPUSH
26255: LD_VAR 0 2
26259: PUSH
26260: LD_EXP 85
26264: PUSH
26265: LD_VAR 0 2
26269: ARRAY
26270: PUSH
26271: LD_INT 1
26273: PLUS
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PPUSH
26279: LD_VAR 0 6
26283: PUSH
26284: LD_VAR 0 3
26288: ARRAY
26289: PPUSH
26290: CALL 49204 0 3
26294: ST_TO_ADDR
26295: GO 26242
26297: POP
26298: POP
// end ;
26299: GO 25306
26301: POP
26302: POP
// end ;
26303: LD_VAR 0 1
26307: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
26308: LD_INT 0
26310: PPUSH
26311: PPUSH
26312: PPUSH
26313: PPUSH
26314: PPUSH
26315: PPUSH
26316: PPUSH
26317: PPUSH
26318: PPUSH
26319: PPUSH
// if not mc_bases then
26320: LD_EXP 71
26324: NOT
26325: IFFALSE 26329
// exit ;
26327: GO 28060
// for i = 1 to mc_bases do
26329: LD_ADDR_VAR 0 2
26333: PUSH
26334: DOUBLE
26335: LD_INT 1
26337: DEC
26338: ST_TO_ADDR
26339: LD_EXP 71
26343: PUSH
26344: FOR_TO
26345: IFFALSE 28058
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
26347: LD_EXP 71
26351: PUSH
26352: LD_VAR 0 2
26356: ARRAY
26357: NOT
26358: PUSH
26359: LD_EXP 78
26363: PUSH
26364: LD_VAR 0 2
26368: ARRAY
26369: OR
26370: IFFALSE 26374
// continue ;
26372: GO 26344
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
26374: LD_EXP 87
26378: PUSH
26379: LD_VAR 0 2
26383: ARRAY
26384: NOT
26385: PUSH
26386: LD_EXP 88
26390: PUSH
26391: LD_VAR 0 2
26395: ARRAY
26396: AND
26397: IFFALSE 26435
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
26399: LD_ADDR_EXP 88
26403: PUSH
26404: LD_EXP 88
26408: PPUSH
26409: LD_VAR 0 2
26413: PPUSH
26414: EMPTY
26415: PPUSH
26416: CALL_OW 1
26420: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
26421: LD_VAR 0 2
26425: PPUSH
26426: LD_INT 107
26428: PPUSH
26429: CALL 17847 0 2
// continue ;
26433: GO 26344
// end ; target := [ ] ;
26435: LD_ADDR_VAR 0 6
26439: PUSH
26440: EMPTY
26441: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
26442: LD_ADDR_VAR 0 3
26446: PUSH
26447: DOUBLE
26448: LD_EXP 87
26452: PUSH
26453: LD_VAR 0 2
26457: ARRAY
26458: INC
26459: ST_TO_ADDR
26460: LD_INT 1
26462: PUSH
26463: FOR_DOWNTO
26464: IFFALSE 26724
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
26466: LD_EXP 87
26470: PUSH
26471: LD_VAR 0 2
26475: ARRAY
26476: PUSH
26477: LD_VAR 0 3
26481: ARRAY
26482: PUSH
26483: LD_INT 2
26485: ARRAY
26486: PPUSH
26487: LD_EXP 87
26491: PUSH
26492: LD_VAR 0 2
26496: ARRAY
26497: PUSH
26498: LD_VAR 0 3
26502: ARRAY
26503: PUSH
26504: LD_INT 3
26506: ARRAY
26507: PPUSH
26508: CALL_OW 488
26512: PUSH
26513: LD_EXP 87
26517: PUSH
26518: LD_VAR 0 2
26522: ARRAY
26523: PUSH
26524: LD_VAR 0 3
26528: ARRAY
26529: PUSH
26530: LD_INT 2
26532: ARRAY
26533: PPUSH
26534: LD_EXP 87
26538: PUSH
26539: LD_VAR 0 2
26543: ARRAY
26544: PUSH
26545: LD_VAR 0 3
26549: ARRAY
26550: PUSH
26551: LD_INT 3
26553: ARRAY
26554: PPUSH
26555: CALL_OW 284
26559: PUSH
26560: LD_INT 0
26562: EQUAL
26563: AND
26564: IFFALSE 26619
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
26566: LD_ADDR_VAR 0 5
26570: PUSH
26571: LD_EXP 87
26575: PUSH
26576: LD_VAR 0 2
26580: ARRAY
26581: PPUSH
26582: LD_VAR 0 3
26586: PPUSH
26587: CALL_OW 3
26591: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
26592: LD_ADDR_EXP 87
26596: PUSH
26597: LD_EXP 87
26601: PPUSH
26602: LD_VAR 0 2
26606: PPUSH
26607: LD_VAR 0 5
26611: PPUSH
26612: CALL_OW 1
26616: ST_TO_ADDR
// continue ;
26617: GO 26463
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
26619: LD_EXP 71
26623: PUSH
26624: LD_VAR 0 2
26628: ARRAY
26629: PUSH
26630: LD_INT 1
26632: ARRAY
26633: PPUSH
26634: CALL_OW 255
26638: PPUSH
26639: LD_EXP 87
26643: PUSH
26644: LD_VAR 0 2
26648: ARRAY
26649: PUSH
26650: LD_VAR 0 3
26654: ARRAY
26655: PUSH
26656: LD_INT 2
26658: ARRAY
26659: PPUSH
26660: LD_EXP 87
26664: PUSH
26665: LD_VAR 0 2
26669: ARRAY
26670: PUSH
26671: LD_VAR 0 3
26675: ARRAY
26676: PUSH
26677: LD_INT 3
26679: ARRAY
26680: PPUSH
26681: LD_INT 30
26683: PPUSH
26684: CALL 50100 0 4
26688: PUSH
26689: LD_INT 4
26691: ARRAY
26692: PUSH
26693: LD_INT 0
26695: EQUAL
26696: IFFALSE 26722
// begin target := mc_crates [ i ] [ j ] ;
26698: LD_ADDR_VAR 0 6
26702: PUSH
26703: LD_EXP 87
26707: PUSH
26708: LD_VAR 0 2
26712: ARRAY
26713: PUSH
26714: LD_VAR 0 3
26718: ARRAY
26719: ST_TO_ADDR
// break ;
26720: GO 26724
// end ; end ;
26722: GO 26463
26724: POP
26725: POP
// if not target then
26726: LD_VAR 0 6
26730: NOT
26731: IFFALSE 26735
// continue ;
26733: GO 26344
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
26735: LD_ADDR_VAR 0 7
26739: PUSH
26740: LD_EXP 90
26744: PUSH
26745: LD_VAR 0 2
26749: ARRAY
26750: PPUSH
26751: LD_INT 2
26753: PUSH
26754: LD_INT 3
26756: PUSH
26757: LD_INT 58
26759: PUSH
26760: EMPTY
26761: LIST
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: PUSH
26767: LD_INT 61
26769: PUSH
26770: EMPTY
26771: LIST
26772: PUSH
26773: LD_INT 33
26775: PUSH
26776: LD_INT 5
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 33
26785: PUSH
26786: LD_INT 3
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: EMPTY
26794: LIST
26795: LIST
26796: LIST
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 2
26802: PUSH
26803: LD_INT 34
26805: PUSH
26806: LD_INT 32
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 34
26815: PUSH
26816: LD_INT 51
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: LD_INT 34
26825: PUSH
26826: LD_INT 12
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: EMPTY
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PPUSH
26843: CALL_OW 72
26847: ST_TO_ADDR
// if not cargo then
26848: LD_VAR 0 7
26852: NOT
26853: IFFALSE 27496
// begin if mc_crates_collector [ i ] < 5 then
26855: LD_EXP 88
26859: PUSH
26860: LD_VAR 0 2
26864: ARRAY
26865: PUSH
26866: LD_INT 5
26868: LESS
26869: IFFALSE 27235
// begin if mc_ape [ i ] then
26871: LD_EXP 100
26875: PUSH
26876: LD_VAR 0 2
26880: ARRAY
26881: IFFALSE 26928
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
26883: LD_ADDR_VAR 0 5
26887: PUSH
26888: LD_EXP 100
26892: PUSH
26893: LD_VAR 0 2
26897: ARRAY
26898: PPUSH
26899: LD_INT 25
26901: PUSH
26902: LD_INT 16
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: PUSH
26909: LD_INT 24
26911: PUSH
26912: LD_INT 750
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PPUSH
26923: CALL_OW 72
26927: ST_TO_ADDR
// if not tmp then
26928: LD_VAR 0 5
26932: NOT
26933: IFFALSE 26980
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
26935: LD_ADDR_VAR 0 5
26939: PUSH
26940: LD_EXP 71
26944: PUSH
26945: LD_VAR 0 2
26949: ARRAY
26950: PPUSH
26951: LD_INT 25
26953: PUSH
26954: LD_INT 2
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: PUSH
26961: LD_INT 24
26963: PUSH
26964: LD_INT 750
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PPUSH
26975: CALL_OW 72
26979: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
26980: LD_EXP 100
26984: PUSH
26985: LD_VAR 0 2
26989: ARRAY
26990: PUSH
26991: LD_EXP 71
26995: PUSH
26996: LD_VAR 0 2
27000: ARRAY
27001: PPUSH
27002: LD_INT 25
27004: PUSH
27005: LD_INT 2
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 24
27014: PUSH
27015: LD_INT 750
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PPUSH
27026: CALL_OW 72
27030: AND
27031: PUSH
27032: LD_VAR 0 5
27036: PUSH
27037: LD_INT 5
27039: LESS
27040: AND
27041: IFFALSE 27123
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
27043: LD_ADDR_VAR 0 3
27047: PUSH
27048: LD_EXP 71
27052: PUSH
27053: LD_VAR 0 2
27057: ARRAY
27058: PPUSH
27059: LD_INT 25
27061: PUSH
27062: LD_INT 2
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 24
27071: PUSH
27072: LD_INT 750
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PPUSH
27083: CALL_OW 72
27087: PUSH
27088: FOR_IN
27089: IFFALSE 27121
// begin tmp := tmp union j ;
27091: LD_ADDR_VAR 0 5
27095: PUSH
27096: LD_VAR 0 5
27100: PUSH
27101: LD_VAR 0 3
27105: UNION
27106: ST_TO_ADDR
// if tmp >= 5 then
27107: LD_VAR 0 5
27111: PUSH
27112: LD_INT 5
27114: GREATEREQUAL
27115: IFFALSE 27119
// break ;
27117: GO 27121
// end ;
27119: GO 27088
27121: POP
27122: POP
// end ; if not tmp then
27123: LD_VAR 0 5
27127: NOT
27128: IFFALSE 27132
// continue ;
27130: GO 26344
// for j in tmp do
27132: LD_ADDR_VAR 0 3
27136: PUSH
27137: LD_VAR 0 5
27141: PUSH
27142: FOR_IN
27143: IFFALSE 27233
// if not GetTag ( j ) then
27145: LD_VAR 0 3
27149: PPUSH
27150: CALL_OW 110
27154: NOT
27155: IFFALSE 27231
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
27157: LD_ADDR_EXP 88
27161: PUSH
27162: LD_EXP 88
27166: PPUSH
27167: LD_VAR 0 2
27171: PUSH
27172: LD_EXP 88
27176: PUSH
27177: LD_VAR 0 2
27181: ARRAY
27182: PUSH
27183: LD_INT 1
27185: PLUS
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PPUSH
27191: LD_VAR 0 3
27195: PPUSH
27196: CALL 49204 0 3
27200: ST_TO_ADDR
// SetTag ( j , 107 ) ;
27201: LD_VAR 0 3
27205: PPUSH
27206: LD_INT 107
27208: PPUSH
27209: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
27213: LD_EXP 88
27217: PUSH
27218: LD_VAR 0 2
27222: ARRAY
27223: PUSH
27224: LD_INT 5
27226: GREATEREQUAL
27227: IFFALSE 27231
// break ;
27229: GO 27233
// end ;
27231: GO 27142
27233: POP
27234: POP
// end ; if mc_crates_collector [ i ] and target then
27235: LD_EXP 88
27239: PUSH
27240: LD_VAR 0 2
27244: ARRAY
27245: PUSH
27246: LD_VAR 0 6
27250: AND
27251: IFFALSE 27494
// begin if mc_crates_collector [ i ] < target [ 1 ] then
27253: LD_EXP 88
27257: PUSH
27258: LD_VAR 0 2
27262: ARRAY
27263: PUSH
27264: LD_VAR 0 6
27268: PUSH
27269: LD_INT 1
27271: ARRAY
27272: LESS
27273: IFFALSE 27293
// tmp := mc_crates_collector [ i ] else
27275: LD_ADDR_VAR 0 5
27279: PUSH
27280: LD_EXP 88
27284: PUSH
27285: LD_VAR 0 2
27289: ARRAY
27290: ST_TO_ADDR
27291: GO 27307
// tmp := target [ 1 ] ;
27293: LD_ADDR_VAR 0 5
27297: PUSH
27298: LD_VAR 0 6
27302: PUSH
27303: LD_INT 1
27305: ARRAY
27306: ST_TO_ADDR
// k := 0 ;
27307: LD_ADDR_VAR 0 4
27311: PUSH
27312: LD_INT 0
27314: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: LD_EXP 88
27324: PUSH
27325: LD_VAR 0 2
27329: ARRAY
27330: PUSH
27331: FOR_IN
27332: IFFALSE 27492
// begin k := k + 1 ;
27334: LD_ADDR_VAR 0 4
27338: PUSH
27339: LD_VAR 0 4
27343: PUSH
27344: LD_INT 1
27346: PLUS
27347: ST_TO_ADDR
// if k > tmp then
27348: LD_VAR 0 4
27352: PUSH
27353: LD_VAR 0 5
27357: GREATER
27358: IFFALSE 27362
// break ;
27360: GO 27492
// if not GetClass ( j ) in [ 2 , 16 ] then
27362: LD_VAR 0 3
27366: PPUSH
27367: CALL_OW 257
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: LD_INT 16
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: IN
27382: NOT
27383: IFFALSE 27436
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
27385: LD_ADDR_EXP 88
27389: PUSH
27390: LD_EXP 88
27394: PPUSH
27395: LD_VAR 0 2
27399: PPUSH
27400: LD_EXP 88
27404: PUSH
27405: LD_VAR 0 2
27409: ARRAY
27410: PUSH
27411: LD_VAR 0 3
27415: DIFF
27416: PPUSH
27417: CALL_OW 1
27421: ST_TO_ADDR
// SetTag ( j , 0 ) ;
27422: LD_VAR 0 3
27426: PPUSH
27427: LD_INT 0
27429: PPUSH
27430: CALL_OW 109
// continue ;
27434: GO 27331
// end ; if IsInUnit ( j ) then
27436: LD_VAR 0 3
27440: PPUSH
27441: CALL_OW 310
27445: IFFALSE 27456
// ComExitBuilding ( j ) ;
27447: LD_VAR 0 3
27451: PPUSH
27452: CALL_OW 122
// wait ( 3 ) ;
27456: LD_INT 3
27458: PPUSH
27459: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
27463: LD_VAR 0 3
27467: PPUSH
27468: LD_VAR 0 6
27472: PUSH
27473: LD_INT 2
27475: ARRAY
27476: PPUSH
27477: LD_VAR 0 6
27481: PUSH
27482: LD_INT 3
27484: ARRAY
27485: PPUSH
27486: CALL_OW 117
// end ;
27490: GO 27331
27492: POP
27493: POP
// end ; end else
27494: GO 28056
// begin for j in cargo do
27496: LD_ADDR_VAR 0 3
27500: PUSH
27501: LD_VAR 0 7
27505: PUSH
27506: FOR_IN
27507: IFFALSE 28054
// begin if GetTag ( j ) <> 0 then
27509: LD_VAR 0 3
27513: PPUSH
27514: CALL_OW 110
27518: PUSH
27519: LD_INT 0
27521: NONEQUAL
27522: IFFALSE 27526
// continue ;
27524: GO 27506
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
27526: LD_VAR 0 3
27530: PPUSH
27531: CALL_OW 256
27535: PUSH
27536: LD_INT 1000
27538: LESS
27539: PUSH
27540: LD_VAR 0 3
27544: PPUSH
27545: LD_EXP 95
27549: PUSH
27550: LD_VAR 0 2
27554: ARRAY
27555: PPUSH
27556: CALL_OW 308
27560: NOT
27561: AND
27562: IFFALSE 27584
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27564: LD_VAR 0 3
27568: PPUSH
27569: LD_EXP 95
27573: PUSH
27574: LD_VAR 0 2
27578: ARRAY
27579: PPUSH
27580: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
27584: LD_VAR 0 3
27588: PPUSH
27589: CALL_OW 256
27593: PUSH
27594: LD_INT 1000
27596: LESS
27597: PUSH
27598: LD_VAR 0 3
27602: PPUSH
27603: LD_EXP 95
27607: PUSH
27608: LD_VAR 0 2
27612: ARRAY
27613: PPUSH
27614: CALL_OW 308
27618: AND
27619: IFFALSE 27623
// continue ;
27621: GO 27506
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
27623: LD_VAR 0 3
27627: PPUSH
27628: CALL_OW 262
27632: PUSH
27633: LD_INT 2
27635: EQUAL
27636: PUSH
27637: LD_VAR 0 3
27641: PPUSH
27642: CALL_OW 261
27646: PUSH
27647: LD_INT 15
27649: LESS
27650: AND
27651: IFFALSE 27655
// continue ;
27653: GO 27506
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
27655: LD_VAR 0 3
27659: PPUSH
27660: CALL_OW 262
27664: PUSH
27665: LD_INT 1
27667: EQUAL
27668: PUSH
27669: LD_VAR 0 3
27673: PPUSH
27674: CALL_OW 261
27678: PUSH
27679: LD_INT 10
27681: LESS
27682: AND
27683: IFFALSE 27993
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27685: LD_ADDR_VAR 0 8
27689: PUSH
27690: LD_EXP 71
27694: PUSH
27695: LD_VAR 0 2
27699: ARRAY
27700: PPUSH
27701: LD_INT 2
27703: PUSH
27704: LD_INT 30
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 30
27716: PUSH
27717: LD_INT 1
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: LIST
27728: PPUSH
27729: CALL_OW 72
27733: ST_TO_ADDR
// if not depot then
27734: LD_VAR 0 8
27738: NOT
27739: IFFALSE 27743
// continue ;
27741: GO 27506
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
27743: LD_VAR 0 3
27747: PPUSH
27748: LD_VAR 0 8
27752: PPUSH
27753: LD_VAR 0 3
27757: PPUSH
27758: CALL_OW 74
27762: PPUSH
27763: CALL_OW 296
27767: PUSH
27768: LD_INT 6
27770: LESS
27771: IFFALSE 27787
// SetFuel ( j , 100 ) else
27773: LD_VAR 0 3
27777: PPUSH
27778: LD_INT 100
27780: PPUSH
27781: CALL_OW 240
27785: GO 27993
// if GetFuel ( j ) = 0 then
27787: LD_VAR 0 3
27791: PPUSH
27792: CALL_OW 261
27796: PUSH
27797: LD_INT 0
27799: EQUAL
27800: IFFALSE 27993
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
27802: LD_ADDR_EXP 90
27806: PUSH
27807: LD_EXP 90
27811: PPUSH
27812: LD_VAR 0 2
27816: PPUSH
27817: LD_EXP 90
27821: PUSH
27822: LD_VAR 0 2
27826: ARRAY
27827: PUSH
27828: LD_VAR 0 3
27832: DIFF
27833: PPUSH
27834: CALL_OW 1
27838: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
27839: LD_VAR 0 3
27843: PPUSH
27844: CALL_OW 263
27848: PUSH
27849: LD_INT 1
27851: EQUAL
27852: IFFALSE 27868
// ComExitVehicle ( IsInUnit ( j ) ) ;
27854: LD_VAR 0 3
27858: PPUSH
27859: CALL_OW 310
27863: PPUSH
27864: CALL_OW 121
// if GetControl ( j ) = control_remote then
27868: LD_VAR 0 3
27872: PPUSH
27873: CALL_OW 263
27877: PUSH
27878: LD_INT 2
27880: EQUAL
27881: IFFALSE 27892
// ComUnlink ( j ) ;
27883: LD_VAR 0 3
27887: PPUSH
27888: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
27892: LD_ADDR_VAR 0 9
27896: PUSH
27897: LD_VAR 0 2
27901: PPUSH
27902: LD_INT 3
27904: PPUSH
27905: CALL 37155 0 2
27909: ST_TO_ADDR
// if fac then
27910: LD_VAR 0 9
27914: IFFALSE 27991
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
27916: LD_ADDR_VAR 0 10
27920: PUSH
27921: LD_VAR 0 9
27925: PPUSH
27926: LD_VAR 0 3
27930: PPUSH
27931: CALL_OW 265
27935: PPUSH
27936: LD_VAR 0 3
27940: PPUSH
27941: CALL_OW 262
27945: PPUSH
27946: LD_VAR 0 3
27950: PPUSH
27951: CALL_OW 263
27955: PPUSH
27956: LD_VAR 0 3
27960: PPUSH
27961: CALL_OW 264
27965: PPUSH
27966: CALL 46804 0 5
27970: ST_TO_ADDR
// if components then
27971: LD_VAR 0 10
27975: IFFALSE 27991
// MC_InsertProduceList ( i , components ) ;
27977: LD_VAR 0 2
27981: PPUSH
27982: LD_VAR 0 10
27986: PPUSH
27987: CALL 36725 0 2
// end ; continue ;
27991: GO 27506
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
27993: LD_VAR 0 3
27997: PPUSH
27998: LD_INT 1
28000: PPUSH
28001: CALL_OW 289
28005: PUSH
28006: LD_INT 100
28008: LESS
28009: PUSH
28010: LD_VAR 0 3
28014: PPUSH
28015: CALL_OW 314
28019: NOT
28020: AND
28021: IFFALSE 28050
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
28023: LD_VAR 0 3
28027: PPUSH
28028: LD_VAR 0 6
28032: PUSH
28033: LD_INT 2
28035: ARRAY
28036: PPUSH
28037: LD_VAR 0 6
28041: PUSH
28042: LD_INT 3
28044: ARRAY
28045: PPUSH
28046: CALL_OW 117
// break ;
28050: GO 28054
// end ;
28052: GO 27506
28054: POP
28055: POP
// end ; end ;
28056: GO 26344
28058: POP
28059: POP
// end ;
28060: LD_VAR 0 1
28064: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
28065: LD_INT 0
28067: PPUSH
28068: PPUSH
28069: PPUSH
28070: PPUSH
// if not mc_bases then
28071: LD_EXP 71
28075: NOT
28076: IFFALSE 28080
// exit ;
28078: GO 28241
// for i = 1 to mc_bases do
28080: LD_ADDR_VAR 0 2
28084: PUSH
28085: DOUBLE
28086: LD_INT 1
28088: DEC
28089: ST_TO_ADDR
28090: LD_EXP 71
28094: PUSH
28095: FOR_TO
28096: IFFALSE 28239
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
28098: LD_ADDR_VAR 0 4
28102: PUSH
28103: LD_EXP 90
28107: PUSH
28108: LD_VAR 0 2
28112: ARRAY
28113: PUSH
28114: LD_EXP 93
28118: PUSH
28119: LD_VAR 0 2
28123: ARRAY
28124: UNION
28125: PPUSH
28126: LD_INT 33
28128: PUSH
28129: LD_INT 2
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PPUSH
28136: CALL_OW 72
28140: ST_TO_ADDR
// if tmp then
28141: LD_VAR 0 4
28145: IFFALSE 28237
// for j in tmp do
28147: LD_ADDR_VAR 0 3
28151: PUSH
28152: LD_VAR 0 4
28156: PUSH
28157: FOR_IN
28158: IFFALSE 28235
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
28160: LD_VAR 0 3
28164: PPUSH
28165: CALL_OW 312
28169: NOT
28170: PUSH
28171: LD_VAR 0 3
28175: PPUSH
28176: CALL_OW 256
28180: PUSH
28181: LD_INT 250
28183: GREATEREQUAL
28184: AND
28185: IFFALSE 28198
// Connect ( j ) else
28187: LD_VAR 0 3
28191: PPUSH
28192: CALL 52137 0 1
28196: GO 28233
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
28198: LD_VAR 0 3
28202: PPUSH
28203: CALL_OW 256
28207: PUSH
28208: LD_INT 250
28210: LESS
28211: PUSH
28212: LD_VAR 0 3
28216: PPUSH
28217: CALL_OW 312
28221: AND
28222: IFFALSE 28233
// ComUnlink ( j ) ;
28224: LD_VAR 0 3
28228: PPUSH
28229: CALL_OW 136
28233: GO 28157
28235: POP
28236: POP
// end ;
28237: GO 28095
28239: POP
28240: POP
// end ;
28241: LD_VAR 0 1
28245: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
28246: LD_INT 0
28248: PPUSH
28249: PPUSH
28250: PPUSH
28251: PPUSH
28252: PPUSH
// if not mc_bases then
28253: LD_EXP 71
28257: NOT
28258: IFFALSE 28262
// exit ;
28260: GO 28722
// for i = 1 to mc_bases do
28262: LD_ADDR_VAR 0 2
28266: PUSH
28267: DOUBLE
28268: LD_INT 1
28270: DEC
28271: ST_TO_ADDR
28272: LD_EXP 71
28276: PUSH
28277: FOR_TO
28278: IFFALSE 28720
// begin if not mc_produce [ i ] then
28280: LD_EXP 92
28284: PUSH
28285: LD_VAR 0 2
28289: ARRAY
28290: NOT
28291: IFFALSE 28295
// continue ;
28293: GO 28277
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28295: LD_ADDR_VAR 0 5
28299: PUSH
28300: LD_EXP 71
28304: PUSH
28305: LD_VAR 0 2
28309: ARRAY
28310: PPUSH
28311: LD_INT 30
28313: PUSH
28314: LD_INT 3
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PPUSH
28321: CALL_OW 72
28325: ST_TO_ADDR
// if not fac then
28326: LD_VAR 0 5
28330: NOT
28331: IFFALSE 28335
// continue ;
28333: GO 28277
// for j in fac do
28335: LD_ADDR_VAR 0 3
28339: PUSH
28340: LD_VAR 0 5
28344: PUSH
28345: FOR_IN
28346: IFFALSE 28716
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
28348: LD_VAR 0 3
28352: PPUSH
28353: CALL_OW 461
28357: PUSH
28358: LD_INT 2
28360: NONEQUAL
28361: PUSH
28362: LD_VAR 0 3
28366: PPUSH
28367: LD_INT 15
28369: PPUSH
28370: CALL 51797 0 2
28374: PUSH
28375: LD_INT 4
28377: ARRAY
28378: OR
28379: PUSH
28380: LD_VAR 0 3
28384: PPUSH
28385: CALL_OW 313
28389: PUSH
28390: LD_INT 0
28392: EQUAL
28393: OR
28394: IFFALSE 28398
// continue ;
28396: GO 28345
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
28398: LD_VAR 0 3
28402: PPUSH
28403: LD_EXP 92
28407: PUSH
28408: LD_VAR 0 2
28412: ARRAY
28413: PUSH
28414: LD_INT 1
28416: ARRAY
28417: PUSH
28418: LD_INT 1
28420: ARRAY
28421: PPUSH
28422: LD_EXP 92
28426: PUSH
28427: LD_VAR 0 2
28431: ARRAY
28432: PUSH
28433: LD_INT 1
28435: ARRAY
28436: PUSH
28437: LD_INT 2
28439: ARRAY
28440: PPUSH
28441: LD_EXP 92
28445: PUSH
28446: LD_VAR 0 2
28450: ARRAY
28451: PUSH
28452: LD_INT 1
28454: ARRAY
28455: PUSH
28456: LD_INT 3
28458: ARRAY
28459: PPUSH
28460: LD_EXP 92
28464: PUSH
28465: LD_VAR 0 2
28469: ARRAY
28470: PUSH
28471: LD_INT 1
28473: ARRAY
28474: PUSH
28475: LD_INT 4
28477: ARRAY
28478: PPUSH
28479: CALL_OW 448
28483: PUSH
28484: LD_VAR 0 3
28488: PPUSH
28489: LD_EXP 92
28493: PUSH
28494: LD_VAR 0 2
28498: ARRAY
28499: PUSH
28500: LD_INT 1
28502: ARRAY
28503: PUSH
28504: LD_INT 1
28506: ARRAY
28507: PUSH
28508: LD_EXP 92
28512: PUSH
28513: LD_VAR 0 2
28517: ARRAY
28518: PUSH
28519: LD_INT 1
28521: ARRAY
28522: PUSH
28523: LD_INT 2
28525: ARRAY
28526: PUSH
28527: LD_EXP 92
28531: PUSH
28532: LD_VAR 0 2
28536: ARRAY
28537: PUSH
28538: LD_INT 1
28540: ARRAY
28541: PUSH
28542: LD_INT 3
28544: ARRAY
28545: PUSH
28546: LD_EXP 92
28550: PUSH
28551: LD_VAR 0 2
28555: ARRAY
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PUSH
28561: LD_INT 4
28563: ARRAY
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: LIST
28569: LIST
28570: PPUSH
28571: CALL 55468 0 2
28575: AND
28576: IFFALSE 28714
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
28578: LD_VAR 0 3
28582: PPUSH
28583: LD_EXP 92
28587: PUSH
28588: LD_VAR 0 2
28592: ARRAY
28593: PUSH
28594: LD_INT 1
28596: ARRAY
28597: PUSH
28598: LD_INT 1
28600: ARRAY
28601: PPUSH
28602: LD_EXP 92
28606: PUSH
28607: LD_VAR 0 2
28611: ARRAY
28612: PUSH
28613: LD_INT 1
28615: ARRAY
28616: PUSH
28617: LD_INT 2
28619: ARRAY
28620: PPUSH
28621: LD_EXP 92
28625: PUSH
28626: LD_VAR 0 2
28630: ARRAY
28631: PUSH
28632: LD_INT 1
28634: ARRAY
28635: PUSH
28636: LD_INT 3
28638: ARRAY
28639: PPUSH
28640: LD_EXP 92
28644: PUSH
28645: LD_VAR 0 2
28649: ARRAY
28650: PUSH
28651: LD_INT 1
28653: ARRAY
28654: PUSH
28655: LD_INT 4
28657: ARRAY
28658: PPUSH
28659: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
28663: LD_ADDR_VAR 0 4
28667: PUSH
28668: LD_EXP 92
28672: PUSH
28673: LD_VAR 0 2
28677: ARRAY
28678: PPUSH
28679: LD_INT 1
28681: PPUSH
28682: CALL_OW 3
28686: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
28687: LD_ADDR_EXP 92
28691: PUSH
28692: LD_EXP 92
28696: PPUSH
28697: LD_VAR 0 2
28701: PPUSH
28702: LD_VAR 0 4
28706: PPUSH
28707: CALL_OW 1
28711: ST_TO_ADDR
// break ;
28712: GO 28716
// end ; end ;
28714: GO 28345
28716: POP
28717: POP
// end ;
28718: GO 28277
28720: POP
28721: POP
// end ;
28722: LD_VAR 0 1
28726: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
28727: LD_INT 0
28729: PPUSH
28730: PPUSH
28731: PPUSH
// if not mc_bases then
28732: LD_EXP 71
28736: NOT
28737: IFFALSE 28741
// exit ;
28739: GO 28830
// for i = 1 to mc_bases do
28741: LD_ADDR_VAR 0 2
28745: PUSH
28746: DOUBLE
28747: LD_INT 1
28749: DEC
28750: ST_TO_ADDR
28751: LD_EXP 71
28755: PUSH
28756: FOR_TO
28757: IFFALSE 28828
// begin if mc_attack [ i ] then
28759: LD_EXP 91
28763: PUSH
28764: LD_VAR 0 2
28768: ARRAY
28769: IFFALSE 28826
// begin tmp := mc_attack [ i ] [ 1 ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_EXP 91
28780: PUSH
28781: LD_VAR 0 2
28785: ARRAY
28786: PUSH
28787: LD_INT 1
28789: ARRAY
28790: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
28791: LD_ADDR_EXP 91
28795: PUSH
28796: LD_EXP 91
28800: PPUSH
28801: LD_VAR 0 2
28805: PPUSH
28806: EMPTY
28807: PPUSH
28808: CALL_OW 1
28812: ST_TO_ADDR
// Attack ( tmp ) ;
28813: LD_VAR 0 3
28817: PPUSH
28818: CALL 77657 0 1
// exit ;
28822: POP
28823: POP
28824: GO 28830
// end ; end ;
28826: GO 28756
28828: POP
28829: POP
// end ;
28830: LD_VAR 0 1
28834: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
28835: LD_INT 0
28837: PPUSH
28838: PPUSH
28839: PPUSH
28840: PPUSH
28841: PPUSH
28842: PPUSH
28843: PPUSH
// if not mc_bases then
28844: LD_EXP 71
28848: NOT
28849: IFFALSE 28853
// exit ;
28851: GO 29457
// for i = 1 to mc_bases do
28853: LD_ADDR_VAR 0 2
28857: PUSH
28858: DOUBLE
28859: LD_INT 1
28861: DEC
28862: ST_TO_ADDR
28863: LD_EXP 71
28867: PUSH
28868: FOR_TO
28869: IFFALSE 29455
// begin if not mc_bases [ i ] then
28871: LD_EXP 71
28875: PUSH
28876: LD_VAR 0 2
28880: ARRAY
28881: NOT
28882: IFFALSE 28886
// continue ;
28884: GO 28868
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
28886: LD_ADDR_VAR 0 7
28890: PUSH
28891: LD_EXP 71
28895: PUSH
28896: LD_VAR 0 2
28900: ARRAY
28901: PUSH
28902: LD_INT 1
28904: ARRAY
28905: PPUSH
28906: CALL 46108 0 1
28910: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
28911: LD_ADDR_EXP 94
28915: PUSH
28916: LD_EXP 94
28920: PPUSH
28921: LD_VAR 0 2
28925: PPUSH
28926: LD_EXP 71
28930: PUSH
28931: LD_VAR 0 2
28935: ARRAY
28936: PUSH
28937: LD_INT 1
28939: ARRAY
28940: PPUSH
28941: CALL_OW 255
28945: PPUSH
28946: LD_EXP 96
28950: PUSH
28951: LD_VAR 0 2
28955: ARRAY
28956: PPUSH
28957: CALL 44068 0 2
28961: PPUSH
28962: CALL_OW 1
28966: ST_TO_ADDR
// if not mc_scan [ i ] then
28967: LD_EXP 94
28971: PUSH
28972: LD_VAR 0 2
28976: ARRAY
28977: NOT
28978: IFFALSE 29133
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
28980: LD_ADDR_VAR 0 4
28984: PUSH
28985: LD_EXP 71
28989: PUSH
28990: LD_VAR 0 2
28994: ARRAY
28995: PPUSH
28996: LD_INT 2
28998: PUSH
28999: LD_INT 25
29001: PUSH
29002: LD_INT 5
29004: PUSH
29005: EMPTY
29006: LIST
29007: LIST
29008: PUSH
29009: LD_INT 25
29011: PUSH
29012: LD_INT 8
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 25
29021: PUSH
29022: LD_INT 9
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: PPUSH
29035: CALL_OW 72
29039: ST_TO_ADDR
// if not tmp then
29040: LD_VAR 0 4
29044: NOT
29045: IFFALSE 29049
// continue ;
29047: GO 28868
// for j in tmp do
29049: LD_ADDR_VAR 0 3
29053: PUSH
29054: LD_VAR 0 4
29058: PUSH
29059: FOR_IN
29060: IFFALSE 29131
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
29062: LD_VAR 0 3
29066: PPUSH
29067: CALL_OW 310
29071: PPUSH
29072: CALL_OW 266
29076: PUSH
29077: LD_INT 5
29079: EQUAL
29080: PUSH
29081: LD_VAR 0 3
29085: PPUSH
29086: CALL_OW 257
29090: PUSH
29091: LD_INT 1
29093: EQUAL
29094: AND
29095: PUSH
29096: LD_VAR 0 3
29100: PPUSH
29101: CALL_OW 459
29105: NOT
29106: AND
29107: PUSH
29108: LD_VAR 0 7
29112: AND
29113: IFFALSE 29129
// ComChangeProfession ( j , class ) ;
29115: LD_VAR 0 3
29119: PPUSH
29120: LD_VAR 0 7
29124: PPUSH
29125: CALL_OW 123
29129: GO 29059
29131: POP
29132: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
29133: LD_EXP 94
29137: PUSH
29138: LD_VAR 0 2
29142: ARRAY
29143: PUSH
29144: LD_EXP 93
29148: PUSH
29149: LD_VAR 0 2
29153: ARRAY
29154: NOT
29155: AND
29156: PUSH
29157: LD_EXP 71
29161: PUSH
29162: LD_VAR 0 2
29166: ARRAY
29167: PPUSH
29168: LD_INT 30
29170: PUSH
29171: LD_INT 32
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PPUSH
29178: CALL_OW 72
29182: NOT
29183: AND
29184: PUSH
29185: LD_EXP 71
29189: PUSH
29190: LD_VAR 0 2
29194: ARRAY
29195: PPUSH
29196: LD_INT 2
29198: PUSH
29199: LD_INT 30
29201: PUSH
29202: LD_INT 4
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 30
29211: PUSH
29212: LD_INT 5
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: PPUSH
29224: CALL_OW 72
29228: NOT
29229: AND
29230: IFFALSE 29362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
29232: LD_ADDR_VAR 0 4
29236: PUSH
29237: LD_EXP 71
29241: PUSH
29242: LD_VAR 0 2
29246: ARRAY
29247: PPUSH
29248: LD_INT 2
29250: PUSH
29251: LD_INT 25
29253: PUSH
29254: LD_INT 1
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 25
29263: PUSH
29264: LD_INT 5
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 25
29273: PUSH
29274: LD_INT 8
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 25
29283: PUSH
29284: LD_INT 9
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: LIST
29295: LIST
29296: LIST
29297: PPUSH
29298: CALL_OW 72
29302: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
29303: LD_ADDR_VAR 0 4
29307: PUSH
29308: LD_VAR 0 4
29312: PUSH
29313: LD_VAR 0 4
29317: PPUSH
29318: LD_INT 18
29320: PPUSH
29321: CALL 82401 0 2
29325: DIFF
29326: ST_TO_ADDR
// if tmp then
29327: LD_VAR 0 4
29331: IFFALSE 29362
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
29333: LD_VAR 0 2
29337: PPUSH
29338: LD_VAR 0 4
29342: PPUSH
29343: LD_EXP 96
29347: PUSH
29348: LD_VAR 0 2
29352: ARRAY
29353: PPUSH
29354: CALL 44103 0 3
// exit ;
29358: POP
29359: POP
29360: GO 29457
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
29362: LD_EXP 94
29366: PUSH
29367: LD_VAR 0 2
29371: ARRAY
29372: PUSH
29373: LD_EXP 93
29377: PUSH
29378: LD_VAR 0 2
29382: ARRAY
29383: AND
29384: IFFALSE 29453
// begin tmp := mc_defender [ i ] ;
29386: LD_ADDR_VAR 0 4
29390: PUSH
29391: LD_EXP 93
29395: PUSH
29396: LD_VAR 0 2
29400: ARRAY
29401: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
29402: LD_ADDR_EXP 93
29406: PUSH
29407: LD_EXP 93
29411: PPUSH
29412: LD_VAR 0 2
29416: PPUSH
29417: EMPTY
29418: PPUSH
29419: CALL_OW 1
29423: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
29424: LD_VAR 0 2
29428: PPUSH
29429: LD_VAR 0 4
29433: PPUSH
29434: LD_EXP 94
29438: PUSH
29439: LD_VAR 0 2
29443: ARRAY
29444: PPUSH
29445: CALL 44601 0 3
// exit ;
29449: POP
29450: POP
29451: GO 29457
// end ; end ;
29453: GO 28868
29455: POP
29456: POP
// end ;
29457: LD_VAR 0 1
29461: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
29462: LD_INT 0
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
29468: PPUSH
29469: PPUSH
29470: PPUSH
29471: PPUSH
29472: PPUSH
29473: PPUSH
29474: PPUSH
// if not mc_bases then
29475: LD_EXP 71
29479: NOT
29480: IFFALSE 29484
// exit ;
29482: GO 30571
// for i = 1 to mc_bases do
29484: LD_ADDR_VAR 0 2
29488: PUSH
29489: DOUBLE
29490: LD_INT 1
29492: DEC
29493: ST_TO_ADDR
29494: LD_EXP 71
29498: PUSH
29499: FOR_TO
29500: IFFALSE 30569
// begin tmp := mc_lab [ i ] ;
29502: LD_ADDR_VAR 0 6
29506: PUSH
29507: LD_EXP 104
29511: PUSH
29512: LD_VAR 0 2
29516: ARRAY
29517: ST_TO_ADDR
// if not tmp then
29518: LD_VAR 0 6
29522: NOT
29523: IFFALSE 29527
// continue ;
29525: GO 29499
// idle_lab := 0 ;
29527: LD_ADDR_VAR 0 11
29531: PUSH
29532: LD_INT 0
29534: ST_TO_ADDR
// for j in tmp do
29535: LD_ADDR_VAR 0 3
29539: PUSH
29540: LD_VAR 0 6
29544: PUSH
29545: FOR_IN
29546: IFFALSE 30565
// begin researching := false ;
29548: LD_ADDR_VAR 0 10
29552: PUSH
29553: LD_INT 0
29555: ST_TO_ADDR
// side := GetSide ( j ) ;
29556: LD_ADDR_VAR 0 4
29560: PUSH
29561: LD_VAR 0 3
29565: PPUSH
29566: CALL_OW 255
29570: ST_TO_ADDR
// if not mc_tech [ side ] then
29571: LD_EXP 98
29575: PUSH
29576: LD_VAR 0 4
29580: ARRAY
29581: NOT
29582: IFFALSE 29586
// continue ;
29584: GO 29545
// if BuildingStatus ( j ) = bs_idle then
29586: LD_VAR 0 3
29590: PPUSH
29591: CALL_OW 461
29595: PUSH
29596: LD_INT 2
29598: EQUAL
29599: IFFALSE 29787
// begin if idle_lab and UnitsInside ( j ) < 6 then
29601: LD_VAR 0 11
29605: PUSH
29606: LD_VAR 0 3
29610: PPUSH
29611: CALL_OW 313
29615: PUSH
29616: LD_INT 6
29618: LESS
29619: AND
29620: IFFALSE 29691
// begin tmp2 := UnitsInside ( idle_lab ) ;
29622: LD_ADDR_VAR 0 9
29626: PUSH
29627: LD_VAR 0 11
29631: PPUSH
29632: CALL_OW 313
29636: ST_TO_ADDR
// if tmp2 then
29637: LD_VAR 0 9
29641: IFFALSE 29683
// for x in tmp2 do
29643: LD_ADDR_VAR 0 7
29647: PUSH
29648: LD_VAR 0 9
29652: PUSH
29653: FOR_IN
29654: IFFALSE 29681
// begin ComExitBuilding ( x ) ;
29656: LD_VAR 0 7
29660: PPUSH
29661: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
29665: LD_VAR 0 7
29669: PPUSH
29670: LD_VAR 0 3
29674: PPUSH
29675: CALL_OW 180
// end ;
29679: GO 29653
29681: POP
29682: POP
// idle_lab := 0 ;
29683: LD_ADDR_VAR 0 11
29687: PUSH
29688: LD_INT 0
29690: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
29691: LD_ADDR_VAR 0 5
29695: PUSH
29696: LD_EXP 98
29700: PUSH
29701: LD_VAR 0 4
29705: ARRAY
29706: PUSH
29707: FOR_IN
29708: IFFALSE 29768
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
29710: LD_VAR 0 3
29714: PPUSH
29715: LD_VAR 0 5
29719: PPUSH
29720: CALL_OW 430
29724: PUSH
29725: LD_VAR 0 4
29729: PPUSH
29730: LD_VAR 0 5
29734: PPUSH
29735: CALL 43173 0 2
29739: AND
29740: IFFALSE 29766
// begin researching := true ;
29742: LD_ADDR_VAR 0 10
29746: PUSH
29747: LD_INT 1
29749: ST_TO_ADDR
// ComResearch ( j , t ) ;
29750: LD_VAR 0 3
29754: PPUSH
29755: LD_VAR 0 5
29759: PPUSH
29760: CALL_OW 124
// break ;
29764: GO 29768
// end ;
29766: GO 29707
29768: POP
29769: POP
// if not researching then
29770: LD_VAR 0 10
29774: NOT
29775: IFFALSE 29787
// idle_lab := j ;
29777: LD_ADDR_VAR 0 11
29781: PUSH
29782: LD_VAR 0 3
29786: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
29787: LD_VAR 0 3
29791: PPUSH
29792: CALL_OW 461
29796: PUSH
29797: LD_INT 10
29799: EQUAL
29800: IFFALSE 30388
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
29802: LD_EXP 100
29806: PUSH
29807: LD_VAR 0 2
29811: ARRAY
29812: NOT
29813: PUSH
29814: LD_EXP 101
29818: PUSH
29819: LD_VAR 0 2
29823: ARRAY
29824: NOT
29825: AND
29826: PUSH
29827: LD_EXP 98
29831: PUSH
29832: LD_VAR 0 4
29836: ARRAY
29837: PUSH
29838: LD_INT 1
29840: GREATER
29841: AND
29842: IFFALSE 29973
// begin ComCancel ( j ) ;
29844: LD_VAR 0 3
29848: PPUSH
29849: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
29853: LD_ADDR_EXP 98
29857: PUSH
29858: LD_EXP 98
29862: PPUSH
29863: LD_VAR 0 4
29867: PPUSH
29868: LD_EXP 98
29872: PUSH
29873: LD_VAR 0 4
29877: ARRAY
29878: PPUSH
29879: LD_EXP 98
29883: PUSH
29884: LD_VAR 0 4
29888: ARRAY
29889: PUSH
29890: LD_INT 1
29892: MINUS
29893: PPUSH
29894: LD_EXP 98
29898: PUSH
29899: LD_VAR 0 4
29903: ARRAY
29904: PPUSH
29905: LD_INT 0
29907: PPUSH
29908: CALL 48622 0 4
29912: PPUSH
29913: CALL_OW 1
29917: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
29918: LD_ADDR_EXP 98
29922: PUSH
29923: LD_EXP 98
29927: PPUSH
29928: LD_VAR 0 4
29932: PPUSH
29933: LD_EXP 98
29937: PUSH
29938: LD_VAR 0 4
29942: ARRAY
29943: PPUSH
29944: LD_EXP 98
29948: PUSH
29949: LD_VAR 0 4
29953: ARRAY
29954: PPUSH
29955: LD_INT 1
29957: PPUSH
29958: LD_INT 0
29960: PPUSH
29961: CALL 48622 0 4
29965: PPUSH
29966: CALL_OW 1
29970: ST_TO_ADDR
// continue ;
29971: GO 29545
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
29973: LD_EXP 100
29977: PUSH
29978: LD_VAR 0 2
29982: ARRAY
29983: PUSH
29984: LD_EXP 101
29988: PUSH
29989: LD_VAR 0 2
29993: ARRAY
29994: NOT
29995: AND
29996: IFFALSE 30123
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
29998: LD_ADDR_EXP 101
30002: PUSH
30003: LD_EXP 101
30007: PPUSH
30008: LD_VAR 0 2
30012: PUSH
30013: LD_EXP 101
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PUSH
30024: LD_INT 1
30026: PLUS
30027: PUSH
30028: EMPTY
30029: LIST
30030: LIST
30031: PPUSH
30032: LD_EXP 100
30036: PUSH
30037: LD_VAR 0 2
30041: ARRAY
30042: PUSH
30043: LD_INT 1
30045: ARRAY
30046: PPUSH
30047: CALL 49204 0 3
30051: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
30052: LD_EXP 100
30056: PUSH
30057: LD_VAR 0 2
30061: ARRAY
30062: PUSH
30063: LD_INT 1
30065: ARRAY
30066: PPUSH
30067: LD_INT 112
30069: PPUSH
30070: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
30074: LD_ADDR_VAR 0 9
30078: PUSH
30079: LD_EXP 100
30083: PUSH
30084: LD_VAR 0 2
30088: ARRAY
30089: PPUSH
30090: LD_INT 1
30092: PPUSH
30093: CALL_OW 3
30097: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
30098: LD_ADDR_EXP 100
30102: PUSH
30103: LD_EXP 100
30107: PPUSH
30108: LD_VAR 0 2
30112: PPUSH
30113: LD_VAR 0 9
30117: PPUSH
30118: CALL_OW 1
30122: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
30123: LD_EXP 100
30127: PUSH
30128: LD_VAR 0 2
30132: ARRAY
30133: PUSH
30134: LD_EXP 101
30138: PUSH
30139: LD_VAR 0 2
30143: ARRAY
30144: AND
30145: PUSH
30146: LD_EXP 101
30150: PUSH
30151: LD_VAR 0 2
30155: ARRAY
30156: PUSH
30157: LD_INT 1
30159: ARRAY
30160: PPUSH
30161: CALL_OW 310
30165: NOT
30166: AND
30167: PUSH
30168: LD_VAR 0 3
30172: PPUSH
30173: CALL_OW 313
30177: PUSH
30178: LD_INT 6
30180: EQUAL
30181: AND
30182: IFFALSE 30238
// begin tmp2 := UnitsInside ( j ) ;
30184: LD_ADDR_VAR 0 9
30188: PUSH
30189: LD_VAR 0 3
30193: PPUSH
30194: CALL_OW 313
30198: ST_TO_ADDR
// if tmp2 = 6 then
30199: LD_VAR 0 9
30203: PUSH
30204: LD_INT 6
30206: EQUAL
30207: IFFALSE 30238
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
30209: LD_VAR 0 9
30213: PUSH
30214: LD_INT 1
30216: ARRAY
30217: PPUSH
30218: LD_INT 112
30220: PPUSH
30221: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
30225: LD_VAR 0 9
30229: PUSH
30230: LD_INT 1
30232: ARRAY
30233: PPUSH
30234: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
30238: LD_EXP 101
30242: PUSH
30243: LD_VAR 0 2
30247: ARRAY
30248: PUSH
30249: LD_EXP 101
30253: PUSH
30254: LD_VAR 0 2
30258: ARRAY
30259: PUSH
30260: LD_INT 1
30262: ARRAY
30263: PPUSH
30264: CALL_OW 314
30268: NOT
30269: AND
30270: PUSH
30271: LD_EXP 101
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: PUSH
30282: LD_INT 1
30284: ARRAY
30285: PPUSH
30286: CALL_OW 310
30290: NOT
30291: AND
30292: IFFALSE 30318
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
30294: LD_EXP 101
30298: PUSH
30299: LD_VAR 0 2
30303: ARRAY
30304: PUSH
30305: LD_INT 1
30307: ARRAY
30308: PPUSH
30309: LD_VAR 0 3
30313: PPUSH
30314: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
30318: LD_EXP 101
30322: PUSH
30323: LD_VAR 0 2
30327: ARRAY
30328: PUSH
30329: LD_INT 1
30331: ARRAY
30332: PPUSH
30333: CALL_OW 310
30337: PUSH
30338: LD_EXP 101
30342: PUSH
30343: LD_VAR 0 2
30347: ARRAY
30348: PUSH
30349: LD_INT 1
30351: ARRAY
30352: PPUSH
30353: CALL_OW 310
30357: PPUSH
30358: CALL_OW 461
30362: PUSH
30363: LD_INT 3
30365: NONEQUAL
30366: AND
30367: IFFALSE 30388
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
30369: LD_EXP 101
30373: PUSH
30374: LD_VAR 0 2
30378: ARRAY
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
30388: LD_VAR 0 3
30392: PPUSH
30393: CALL_OW 461
30397: PUSH
30398: LD_INT 6
30400: EQUAL
30401: PUSH
30402: LD_VAR 0 6
30406: PUSH
30407: LD_INT 1
30409: GREATER
30410: AND
30411: IFFALSE 30563
// begin sci := [ ] ;
30413: LD_ADDR_VAR 0 8
30417: PUSH
30418: EMPTY
30419: ST_TO_ADDR
// for x in ( tmp diff j ) do
30420: LD_ADDR_VAR 0 7
30424: PUSH
30425: LD_VAR 0 6
30429: PUSH
30430: LD_VAR 0 3
30434: DIFF
30435: PUSH
30436: FOR_IN
30437: IFFALSE 30489
// begin if sci = 6 then
30439: LD_VAR 0 8
30443: PUSH
30444: LD_INT 6
30446: EQUAL
30447: IFFALSE 30451
// break ;
30449: GO 30489
// if BuildingStatus ( x ) = bs_idle then
30451: LD_VAR 0 7
30455: PPUSH
30456: CALL_OW 461
30460: PUSH
30461: LD_INT 2
30463: EQUAL
30464: IFFALSE 30487
// sci := sci ^ UnitsInside ( x ) ;
30466: LD_ADDR_VAR 0 8
30470: PUSH
30471: LD_VAR 0 8
30475: PUSH
30476: LD_VAR 0 7
30480: PPUSH
30481: CALL_OW 313
30485: ADD
30486: ST_TO_ADDR
// end ;
30487: GO 30436
30489: POP
30490: POP
// if not sci then
30491: LD_VAR 0 8
30495: NOT
30496: IFFALSE 30500
// continue ;
30498: GO 29545
// for x in sci do
30500: LD_ADDR_VAR 0 7
30504: PUSH
30505: LD_VAR 0 8
30509: PUSH
30510: FOR_IN
30511: IFFALSE 30561
// if IsInUnit ( x ) and not HasTask ( x ) then
30513: LD_VAR 0 7
30517: PPUSH
30518: CALL_OW 310
30522: PUSH
30523: LD_VAR 0 7
30527: PPUSH
30528: CALL_OW 314
30532: NOT
30533: AND
30534: IFFALSE 30559
// begin ComExitBuilding ( x ) ;
30536: LD_VAR 0 7
30540: PPUSH
30541: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
30545: LD_VAR 0 7
30549: PPUSH
30550: LD_VAR 0 3
30554: PPUSH
30555: CALL_OW 180
// end ;
30559: GO 30510
30561: POP
30562: POP
// end ; end ;
30563: GO 29545
30565: POP
30566: POP
// end ;
30567: GO 29499
30569: POP
30570: POP
// end ;
30571: LD_VAR 0 1
30575: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
30576: LD_INT 0
30578: PPUSH
30579: PPUSH
// if not mc_bases then
30580: LD_EXP 71
30584: NOT
30585: IFFALSE 30589
// exit ;
30587: GO 30670
// for i = 1 to mc_bases do
30589: LD_ADDR_VAR 0 2
30593: PUSH
30594: DOUBLE
30595: LD_INT 1
30597: DEC
30598: ST_TO_ADDR
30599: LD_EXP 71
30603: PUSH
30604: FOR_TO
30605: IFFALSE 30668
// if mc_mines [ i ] and mc_miners [ i ] then
30607: LD_EXP 84
30611: PUSH
30612: LD_VAR 0 2
30616: ARRAY
30617: PUSH
30618: LD_EXP 85
30622: PUSH
30623: LD_VAR 0 2
30627: ARRAY
30628: AND
30629: IFFALSE 30666
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
30631: LD_EXP 85
30635: PUSH
30636: LD_VAR 0 2
30640: ARRAY
30641: PUSH
30642: LD_INT 1
30644: ARRAY
30645: PPUSH
30646: CALL_OW 255
30650: PPUSH
30651: LD_EXP 84
30655: PUSH
30656: LD_VAR 0 2
30660: ARRAY
30661: PPUSH
30662: CALL 46261 0 2
30666: GO 30604
30668: POP
30669: POP
// end ;
30670: LD_VAR 0 1
30674: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
30675: LD_INT 0
30677: PPUSH
30678: PPUSH
30679: PPUSH
30680: PPUSH
30681: PPUSH
30682: PPUSH
30683: PPUSH
30684: PPUSH
// if not mc_bases or not mc_parking then
30685: LD_EXP 71
30689: NOT
30690: PUSH
30691: LD_EXP 95
30695: NOT
30696: OR
30697: IFFALSE 30701
// exit ;
30699: GO 31413
// for i = 1 to mc_bases do
30701: LD_ADDR_VAR 0 2
30705: PUSH
30706: DOUBLE
30707: LD_INT 1
30709: DEC
30710: ST_TO_ADDR
30711: LD_EXP 71
30715: PUSH
30716: FOR_TO
30717: IFFALSE 31411
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
30719: LD_EXP 71
30723: PUSH
30724: LD_VAR 0 2
30728: ARRAY
30729: NOT
30730: PUSH
30731: LD_EXP 95
30735: PUSH
30736: LD_VAR 0 2
30740: ARRAY
30741: NOT
30742: OR
30743: IFFALSE 30747
// continue ;
30745: GO 30716
// if mc_scan [ i ] then
30747: LD_EXP 94
30751: PUSH
30752: LD_VAR 0 2
30756: ARRAY
30757: IFFALSE 30783
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
30759: LD_ADDR_EXP 83
30763: PUSH
30764: LD_EXP 83
30768: PPUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: EMPTY
30775: PPUSH
30776: CALL_OW 1
30780: ST_TO_ADDR
// continue ;
30781: GO 30716
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
30783: LD_ADDR_VAR 0 5
30787: PUSH
30788: LD_EXP 71
30792: PUSH
30793: LD_VAR 0 2
30797: ARRAY
30798: PUSH
30799: LD_INT 1
30801: ARRAY
30802: PPUSH
30803: CALL_OW 255
30807: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30808: LD_ADDR_VAR 0 6
30812: PUSH
30813: LD_EXP 71
30817: PUSH
30818: LD_VAR 0 2
30822: ARRAY
30823: PPUSH
30824: LD_INT 30
30826: PUSH
30827: LD_INT 3
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PPUSH
30834: CALL_OW 72
30838: ST_TO_ADDR
// if not fac then
30839: LD_VAR 0 6
30843: NOT
30844: IFFALSE 30895
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30846: LD_ADDR_VAR 0 6
30850: PUSH
30851: LD_EXP 71
30855: PUSH
30856: LD_VAR 0 2
30860: ARRAY
30861: PPUSH
30862: LD_INT 2
30864: PUSH
30865: LD_INT 30
30867: PUSH
30868: LD_INT 0
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 30
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: LIST
30889: PPUSH
30890: CALL_OW 72
30894: ST_TO_ADDR
// if not fac then
30895: LD_VAR 0 6
30899: NOT
30900: IFFALSE 30904
// continue ;
30902: GO 30716
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30904: LD_ADDR_VAR 0 7
30908: PUSH
30909: LD_EXP 95
30913: PUSH
30914: LD_VAR 0 2
30918: ARRAY
30919: PPUSH
30920: LD_INT 22
30922: PUSH
30923: LD_VAR 0 5
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 21
30934: PUSH
30935: LD_INT 2
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 3
30944: PUSH
30945: LD_INT 24
30947: PUSH
30948: LD_INT 1000
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: LIST
30963: PPUSH
30964: CALL_OW 70
30968: PUSH
30969: LD_INT 22
30971: PUSH
30972: LD_VAR 0 5
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 91
30983: PUSH
30984: LD_VAR 0 6
30988: PUSH
30989: LD_INT 1
30991: ARRAY
30992: PUSH
30993: LD_INT 25
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 21
31003: PUSH
31004: LD_INT 2
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 3
31013: PUSH
31014: LD_INT 24
31016: PUSH
31017: LD_INT 1000
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: PPUSH
31034: CALL_OW 69
31038: UNION
31039: ST_TO_ADDR
// if not vehs then
31040: LD_VAR 0 7
31044: NOT
31045: IFFALSE 31071
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
31047: LD_ADDR_EXP 83
31051: PUSH
31052: LD_EXP 83
31056: PPUSH
31057: LD_VAR 0 2
31061: PPUSH
31062: EMPTY
31063: PPUSH
31064: CALL_OW 1
31068: ST_TO_ADDR
// continue ;
31069: GO 30716
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31071: LD_ADDR_VAR 0 8
31075: PUSH
31076: LD_EXP 71
31080: PUSH
31081: LD_VAR 0 2
31085: ARRAY
31086: PPUSH
31087: LD_INT 30
31089: PUSH
31090: LD_INT 3
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PPUSH
31097: CALL_OW 72
31101: ST_TO_ADDR
// if tmp then
31102: LD_VAR 0 8
31106: IFFALSE 31209
// begin for j in tmp do
31108: LD_ADDR_VAR 0 3
31112: PUSH
31113: LD_VAR 0 8
31117: PUSH
31118: FOR_IN
31119: IFFALSE 31207
// for k in UnitsInside ( j ) do
31121: LD_ADDR_VAR 0 4
31125: PUSH
31126: LD_VAR 0 3
31130: PPUSH
31131: CALL_OW 313
31135: PUSH
31136: FOR_IN
31137: IFFALSE 31203
// if k then
31139: LD_VAR 0 4
31143: IFFALSE 31201
// if not k in mc_repair_vehicle [ i ] then
31145: LD_VAR 0 4
31149: PUSH
31150: LD_EXP 83
31154: PUSH
31155: LD_VAR 0 2
31159: ARRAY
31160: IN
31161: NOT
31162: IFFALSE 31201
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
31164: LD_ADDR_EXP 83
31168: PUSH
31169: LD_EXP 83
31173: PPUSH
31174: LD_VAR 0 2
31178: PPUSH
31179: LD_EXP 83
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: PUSH
31190: LD_VAR 0 4
31194: UNION
31195: PPUSH
31196: CALL_OW 1
31200: ST_TO_ADDR
31201: GO 31136
31203: POP
31204: POP
31205: GO 31118
31207: POP
31208: POP
// end ; if not mc_repair_vehicle [ i ] then
31209: LD_EXP 83
31213: PUSH
31214: LD_VAR 0 2
31218: ARRAY
31219: NOT
31220: IFFALSE 31224
// continue ;
31222: GO 30716
// for j in mc_repair_vehicle [ i ] do
31224: LD_ADDR_VAR 0 3
31228: PUSH
31229: LD_EXP 83
31233: PUSH
31234: LD_VAR 0 2
31238: ARRAY
31239: PUSH
31240: FOR_IN
31241: IFFALSE 31407
// begin if GetClass ( j ) <> 3 then
31243: LD_VAR 0 3
31247: PPUSH
31248: CALL_OW 257
31252: PUSH
31253: LD_INT 3
31255: NONEQUAL
31256: IFFALSE 31297
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
31258: LD_ADDR_EXP 83
31262: PUSH
31263: LD_EXP 83
31267: PPUSH
31268: LD_VAR 0 2
31272: PPUSH
31273: LD_EXP 83
31277: PUSH
31278: LD_VAR 0 2
31282: ARRAY
31283: PUSH
31284: LD_VAR 0 3
31288: DIFF
31289: PPUSH
31290: CALL_OW 1
31294: ST_TO_ADDR
// continue ;
31295: GO 31240
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
31297: LD_VAR 0 3
31301: PPUSH
31302: CALL_OW 311
31306: NOT
31307: PUSH
31308: LD_VAR 0 3
31312: PUSH
31313: LD_EXP 74
31317: PUSH
31318: LD_VAR 0 2
31322: ARRAY
31323: PUSH
31324: LD_INT 1
31326: ARRAY
31327: IN
31328: NOT
31329: AND
31330: PUSH
31331: LD_VAR 0 3
31335: PUSH
31336: LD_EXP 74
31340: PUSH
31341: LD_VAR 0 2
31345: ARRAY
31346: PUSH
31347: LD_INT 2
31349: ARRAY
31350: IN
31351: NOT
31352: AND
31353: IFFALSE 31405
// begin if IsInUnit ( j ) then
31355: LD_VAR 0 3
31359: PPUSH
31360: CALL_OW 310
31364: IFFALSE 31375
// ComExitBuilding ( j ) ;
31366: LD_VAR 0 3
31370: PPUSH
31371: CALL_OW 122
// if not HasTask ( j ) then
31375: LD_VAR 0 3
31379: PPUSH
31380: CALL_OW 314
31384: NOT
31385: IFFALSE 31405
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
31387: LD_VAR 0 3
31391: PPUSH
31392: LD_VAR 0 7
31396: PUSH
31397: LD_INT 1
31399: ARRAY
31400: PPUSH
31401: CALL_OW 189
// end ; end ;
31405: GO 31240
31407: POP
31408: POP
// end ;
31409: GO 30716
31411: POP
31412: POP
// end ;
31413: LD_VAR 0 1
31417: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
31418: LD_INT 0
31420: PPUSH
31421: PPUSH
31422: PPUSH
31423: PPUSH
31424: PPUSH
31425: PPUSH
31426: PPUSH
31427: PPUSH
31428: PPUSH
31429: PPUSH
31430: PPUSH
// if not mc_bases then
31431: LD_EXP 71
31435: NOT
31436: IFFALSE 31440
// exit ;
31438: GO 32242
// for i = 1 to mc_bases do
31440: LD_ADDR_VAR 0 2
31444: PUSH
31445: DOUBLE
31446: LD_INT 1
31448: DEC
31449: ST_TO_ADDR
31450: LD_EXP 71
31454: PUSH
31455: FOR_TO
31456: IFFALSE 32240
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
31458: LD_EXP 99
31462: PUSH
31463: LD_VAR 0 2
31467: ARRAY
31468: NOT
31469: PUSH
31470: LD_EXP 74
31474: PUSH
31475: LD_VAR 0 2
31479: ARRAY
31480: PUSH
31481: LD_INT 1
31483: ARRAY
31484: OR
31485: PUSH
31486: LD_EXP 74
31490: PUSH
31491: LD_VAR 0 2
31495: ARRAY
31496: PUSH
31497: LD_INT 2
31499: ARRAY
31500: OR
31501: PUSH
31502: LD_EXP 97
31506: PUSH
31507: LD_VAR 0 2
31511: ARRAY
31512: PPUSH
31513: LD_INT 1
31515: PPUSH
31516: CALL_OW 325
31520: NOT
31521: OR
31522: PUSH
31523: LD_EXP 94
31527: PUSH
31528: LD_VAR 0 2
31532: ARRAY
31533: OR
31534: IFFALSE 31538
// continue ;
31536: GO 31455
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
31538: LD_ADDR_VAR 0 8
31542: PUSH
31543: LD_EXP 71
31547: PUSH
31548: LD_VAR 0 2
31552: ARRAY
31553: PPUSH
31554: LD_INT 25
31556: PUSH
31557: LD_INT 4
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: PUSH
31564: LD_INT 50
31566: PUSH
31567: EMPTY
31568: LIST
31569: PUSH
31570: LD_INT 3
31572: PUSH
31573: LD_INT 60
31575: PUSH
31576: EMPTY
31577: LIST
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: LIST
31587: PPUSH
31588: CALL_OW 72
31592: PUSH
31593: LD_EXP 75
31597: PUSH
31598: LD_VAR 0 2
31602: ARRAY
31603: DIFF
31604: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31605: LD_ADDR_VAR 0 9
31609: PUSH
31610: LD_EXP 71
31614: PUSH
31615: LD_VAR 0 2
31619: ARRAY
31620: PPUSH
31621: LD_INT 2
31623: PUSH
31624: LD_INT 30
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 30
31636: PUSH
31637: LD_INT 1
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: LIST
31648: PPUSH
31649: CALL_OW 72
31653: ST_TO_ADDR
// if not tmp or not dep then
31654: LD_VAR 0 8
31658: NOT
31659: PUSH
31660: LD_VAR 0 9
31664: NOT
31665: OR
31666: IFFALSE 31670
// continue ;
31668: GO 31455
// side := GetSide ( tmp [ 1 ] ) ;
31670: LD_ADDR_VAR 0 11
31674: PUSH
31675: LD_VAR 0 8
31679: PUSH
31680: LD_INT 1
31682: ARRAY
31683: PPUSH
31684: CALL_OW 255
31688: ST_TO_ADDR
// dep := dep [ 1 ] ;
31689: LD_ADDR_VAR 0 9
31693: PUSH
31694: LD_VAR 0 9
31698: PUSH
31699: LD_INT 1
31701: ARRAY
31702: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
31703: LD_ADDR_VAR 0 7
31707: PUSH
31708: LD_EXP 99
31712: PUSH
31713: LD_VAR 0 2
31717: ARRAY
31718: PPUSH
31719: LD_INT 22
31721: PUSH
31722: LD_INT 0
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 25
31731: PUSH
31732: LD_INT 12
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PPUSH
31743: CALL_OW 70
31747: PUSH
31748: LD_INT 22
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 25
31760: PUSH
31761: LD_INT 12
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 91
31770: PUSH
31771: LD_VAR 0 9
31775: PUSH
31776: LD_INT 20
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: LIST
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: LIST
31788: PPUSH
31789: CALL_OW 69
31793: UNION
31794: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
31795: LD_ADDR_VAR 0 10
31799: PUSH
31800: LD_EXP 99
31804: PUSH
31805: LD_VAR 0 2
31809: ARRAY
31810: PPUSH
31811: LD_INT 81
31813: PUSH
31814: LD_VAR 0 11
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PPUSH
31823: CALL_OW 70
31827: ST_TO_ADDR
// if not apes or danger_at_area then
31828: LD_VAR 0 7
31832: NOT
31833: PUSH
31834: LD_VAR 0 10
31838: OR
31839: IFFALSE 31889
// begin if mc_taming [ i ] then
31841: LD_EXP 102
31845: PUSH
31846: LD_VAR 0 2
31850: ARRAY
31851: IFFALSE 31887
// begin MC_Reset ( i , 121 ) ;
31853: LD_VAR 0 2
31857: PPUSH
31858: LD_INT 121
31860: PPUSH
31861: CALL 17847 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31865: LD_ADDR_EXP 102
31869: PUSH
31870: LD_EXP 102
31874: PPUSH
31875: LD_VAR 0 2
31879: PPUSH
31880: EMPTY
31881: PPUSH
31882: CALL_OW 1
31886: ST_TO_ADDR
// end ; continue ;
31887: GO 31455
// end ; for j in tmp do
31889: LD_ADDR_VAR 0 3
31893: PUSH
31894: LD_VAR 0 8
31898: PUSH
31899: FOR_IN
31900: IFFALSE 32236
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
31902: LD_VAR 0 3
31906: PUSH
31907: LD_EXP 102
31911: PUSH
31912: LD_VAR 0 2
31916: ARRAY
31917: IN
31918: NOT
31919: PUSH
31920: LD_EXP 102
31924: PUSH
31925: LD_VAR 0 2
31929: ARRAY
31930: PUSH
31931: LD_INT 3
31933: LESS
31934: AND
31935: IFFALSE 31993
// begin SetTag ( j , 121 ) ;
31937: LD_VAR 0 3
31941: PPUSH
31942: LD_INT 121
31944: PPUSH
31945: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
31949: LD_ADDR_EXP 102
31953: PUSH
31954: LD_EXP 102
31958: PPUSH
31959: LD_VAR 0 2
31963: PUSH
31964: LD_EXP 102
31968: PUSH
31969: LD_VAR 0 2
31973: ARRAY
31974: PUSH
31975: LD_INT 1
31977: PLUS
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PPUSH
31983: LD_VAR 0 3
31987: PPUSH
31988: CALL 49204 0 3
31992: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
31993: LD_VAR 0 3
31997: PUSH
31998: LD_EXP 102
32002: PUSH
32003: LD_VAR 0 2
32007: ARRAY
32008: IN
32009: IFFALSE 32234
// begin if GetClass ( j ) <> 4 then
32011: LD_VAR 0 3
32015: PPUSH
32016: CALL_OW 257
32020: PUSH
32021: LD_INT 4
32023: NONEQUAL
32024: IFFALSE 32077
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
32026: LD_ADDR_EXP 102
32030: PUSH
32031: LD_EXP 102
32035: PPUSH
32036: LD_VAR 0 2
32040: PPUSH
32041: LD_EXP 102
32045: PUSH
32046: LD_VAR 0 2
32050: ARRAY
32051: PUSH
32052: LD_VAR 0 3
32056: DIFF
32057: PPUSH
32058: CALL_OW 1
32062: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32063: LD_VAR 0 3
32067: PPUSH
32068: LD_INT 0
32070: PPUSH
32071: CALL_OW 109
// continue ;
32075: GO 31899
// end ; if IsInUnit ( j ) then
32077: LD_VAR 0 3
32081: PPUSH
32082: CALL_OW 310
32086: IFFALSE 32097
// ComExitBuilding ( j ) ;
32088: LD_VAR 0 3
32092: PPUSH
32093: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
32097: LD_ADDR_VAR 0 6
32101: PUSH
32102: LD_VAR 0 7
32106: PPUSH
32107: LD_VAR 0 3
32111: PPUSH
32112: CALL_OW 74
32116: ST_TO_ADDR
// if not ape then
32117: LD_VAR 0 6
32121: NOT
32122: IFFALSE 32126
// break ;
32124: GO 32236
// x := GetX ( ape ) ;
32126: LD_ADDR_VAR 0 4
32130: PUSH
32131: LD_VAR 0 6
32135: PPUSH
32136: CALL_OW 250
32140: ST_TO_ADDR
// y := GetY ( ape ) ;
32141: LD_ADDR_VAR 0 5
32145: PUSH
32146: LD_VAR 0 6
32150: PPUSH
32151: CALL_OW 251
32155: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
32156: LD_VAR 0 4
32160: PPUSH
32161: LD_VAR 0 5
32165: PPUSH
32166: CALL_OW 488
32170: NOT
32171: PUSH
32172: LD_VAR 0 11
32176: PPUSH
32177: LD_VAR 0 4
32181: PPUSH
32182: LD_VAR 0 5
32186: PPUSH
32187: LD_INT 20
32189: PPUSH
32190: CALL 50100 0 4
32194: PUSH
32195: LD_INT 4
32197: ARRAY
32198: OR
32199: IFFALSE 32203
// break ;
32201: GO 32236
// if not HasTask ( j ) then
32203: LD_VAR 0 3
32207: PPUSH
32208: CALL_OW 314
32212: NOT
32213: IFFALSE 32234
// ComTameXY ( j , x , y ) ;
32215: LD_VAR 0 3
32219: PPUSH
32220: LD_VAR 0 4
32224: PPUSH
32225: LD_VAR 0 5
32229: PPUSH
32230: CALL_OW 131
// end ; end ;
32234: GO 31899
32236: POP
32237: POP
// end ;
32238: GO 31455
32240: POP
32241: POP
// end ;
32242: LD_VAR 0 1
32246: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
32247: LD_INT 0
32249: PPUSH
32250: PPUSH
32251: PPUSH
32252: PPUSH
32253: PPUSH
32254: PPUSH
32255: PPUSH
32256: PPUSH
// if not mc_bases then
32257: LD_EXP 71
32261: NOT
32262: IFFALSE 32266
// exit ;
32264: GO 32892
// for i = 1 to mc_bases do
32266: LD_ADDR_VAR 0 2
32270: PUSH
32271: DOUBLE
32272: LD_INT 1
32274: DEC
32275: ST_TO_ADDR
32276: LD_EXP 71
32280: PUSH
32281: FOR_TO
32282: IFFALSE 32890
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
32284: LD_EXP 100
32288: PUSH
32289: LD_VAR 0 2
32293: ARRAY
32294: NOT
32295: PUSH
32296: LD_EXP 100
32300: PUSH
32301: LD_VAR 0 2
32305: ARRAY
32306: PPUSH
32307: LD_INT 25
32309: PUSH
32310: LD_INT 12
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PPUSH
32317: CALL_OW 72
32321: NOT
32322: OR
32323: IFFALSE 32327
// continue ;
32325: GO 32281
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
32327: LD_ADDR_VAR 0 5
32331: PUSH
32332: LD_EXP 100
32336: PUSH
32337: LD_VAR 0 2
32341: ARRAY
32342: PUSH
32343: LD_INT 1
32345: ARRAY
32346: PPUSH
32347: CALL_OW 255
32351: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
32352: LD_VAR 0 5
32356: PPUSH
32357: LD_INT 2
32359: PPUSH
32360: CALL_OW 325
32364: IFFALSE 32617
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
32366: LD_ADDR_VAR 0 4
32370: PUSH
32371: LD_EXP 100
32375: PUSH
32376: LD_VAR 0 2
32380: ARRAY
32381: PPUSH
32382: LD_INT 25
32384: PUSH
32385: LD_INT 16
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PPUSH
32392: CALL_OW 72
32396: ST_TO_ADDR
// if tmp < 6 then
32397: LD_VAR 0 4
32401: PUSH
32402: LD_INT 6
32404: LESS
32405: IFFALSE 32617
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32407: LD_ADDR_VAR 0 6
32411: PUSH
32412: LD_EXP 71
32416: PUSH
32417: LD_VAR 0 2
32421: ARRAY
32422: PPUSH
32423: LD_INT 2
32425: PUSH
32426: LD_INT 30
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 30
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: LIST
32450: PPUSH
32451: CALL_OW 72
32455: ST_TO_ADDR
// if depot then
32456: LD_VAR 0 6
32460: IFFALSE 32617
// begin selected := 0 ;
32462: LD_ADDR_VAR 0 7
32466: PUSH
32467: LD_INT 0
32469: ST_TO_ADDR
// for j in depot do
32470: LD_ADDR_VAR 0 3
32474: PUSH
32475: LD_VAR 0 6
32479: PUSH
32480: FOR_IN
32481: IFFALSE 32512
// begin if UnitsInside ( j ) < 6 then
32483: LD_VAR 0 3
32487: PPUSH
32488: CALL_OW 313
32492: PUSH
32493: LD_INT 6
32495: LESS
32496: IFFALSE 32510
// begin selected := j ;
32498: LD_ADDR_VAR 0 7
32502: PUSH
32503: LD_VAR 0 3
32507: ST_TO_ADDR
// break ;
32508: GO 32512
// end ; end ;
32510: GO 32480
32512: POP
32513: POP
// if selected then
32514: LD_VAR 0 7
32518: IFFALSE 32617
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
32520: LD_ADDR_VAR 0 3
32524: PUSH
32525: LD_EXP 100
32529: PUSH
32530: LD_VAR 0 2
32534: ARRAY
32535: PPUSH
32536: LD_INT 25
32538: PUSH
32539: LD_INT 12
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PPUSH
32546: CALL_OW 72
32550: PUSH
32551: FOR_IN
32552: IFFALSE 32615
// if not HasTask ( j ) then
32554: LD_VAR 0 3
32558: PPUSH
32559: CALL_OW 314
32563: NOT
32564: IFFALSE 32613
// begin if not IsInUnit ( j ) then
32566: LD_VAR 0 3
32570: PPUSH
32571: CALL_OW 310
32575: NOT
32576: IFFALSE 32592
// ComEnterUnit ( j , selected ) ;
32578: LD_VAR 0 3
32582: PPUSH
32583: LD_VAR 0 7
32587: PPUSH
32588: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
32592: LD_VAR 0 3
32596: PPUSH
32597: LD_INT 16
32599: PPUSH
32600: CALL_OW 183
// AddComExitBuilding ( j ) ;
32604: LD_VAR 0 3
32608: PPUSH
32609: CALL_OW 182
// end ;
32613: GO 32551
32615: POP
32616: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
32617: LD_VAR 0 5
32621: PPUSH
32622: LD_INT 11
32624: PPUSH
32625: CALL_OW 325
32629: IFFALSE 32888
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
32631: LD_ADDR_VAR 0 4
32635: PUSH
32636: LD_EXP 100
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PPUSH
32647: LD_INT 25
32649: PUSH
32650: LD_INT 16
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PPUSH
32657: CALL_OW 72
32661: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
32662: LD_VAR 0 4
32666: PUSH
32667: LD_INT 6
32669: GREATEREQUAL
32670: PUSH
32671: LD_VAR 0 5
32675: PPUSH
32676: LD_INT 2
32678: PPUSH
32679: CALL_OW 325
32683: NOT
32684: OR
32685: IFFALSE 32888
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
32687: LD_ADDR_VAR 0 8
32691: PUSH
32692: LD_EXP 71
32696: PUSH
32697: LD_VAR 0 2
32701: ARRAY
32702: PPUSH
32703: LD_INT 2
32705: PUSH
32706: LD_INT 30
32708: PUSH
32709: LD_INT 4
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 30
32718: PUSH
32719: LD_INT 5
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 72
32735: ST_TO_ADDR
// if barracks then
32736: LD_VAR 0 8
32740: IFFALSE 32888
// begin selected := 0 ;
32742: LD_ADDR_VAR 0 7
32746: PUSH
32747: LD_INT 0
32749: ST_TO_ADDR
// for j in barracks do
32750: LD_ADDR_VAR 0 3
32754: PUSH
32755: LD_VAR 0 8
32759: PUSH
32760: FOR_IN
32761: IFFALSE 32792
// begin if UnitsInside ( j ) < 6 then
32763: LD_VAR 0 3
32767: PPUSH
32768: CALL_OW 313
32772: PUSH
32773: LD_INT 6
32775: LESS
32776: IFFALSE 32790
// begin selected := j ;
32778: LD_ADDR_VAR 0 7
32782: PUSH
32783: LD_VAR 0 3
32787: ST_TO_ADDR
// break ;
32788: GO 32792
// end ; end ;
32790: GO 32760
32792: POP
32793: POP
// if selected then
32794: LD_VAR 0 7
32798: IFFALSE 32888
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
32800: LD_ADDR_VAR 0 3
32804: PUSH
32805: LD_EXP 100
32809: PUSH
32810: LD_VAR 0 2
32814: ARRAY
32815: PPUSH
32816: LD_INT 25
32818: PUSH
32819: LD_INT 12
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PPUSH
32826: CALL_OW 72
32830: PUSH
32831: FOR_IN
32832: IFFALSE 32886
// if not IsInUnit ( j ) and not HasTask ( j ) then
32834: LD_VAR 0 3
32838: PPUSH
32839: CALL_OW 310
32843: NOT
32844: PUSH
32845: LD_VAR 0 3
32849: PPUSH
32850: CALL_OW 314
32854: NOT
32855: AND
32856: IFFALSE 32884
// begin ComEnterUnit ( j , selected ) ;
32858: LD_VAR 0 3
32862: PPUSH
32863: LD_VAR 0 7
32867: PPUSH
32868: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
32872: LD_VAR 0 3
32876: PPUSH
32877: LD_INT 15
32879: PPUSH
32880: CALL_OW 183
// end ;
32884: GO 32831
32886: POP
32887: POP
// end ; end ; end ; end ; end ;
32888: GO 32281
32890: POP
32891: POP
// end ;
32892: LD_VAR 0 1
32896: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
32897: LD_INT 0
32899: PPUSH
32900: PPUSH
32901: PPUSH
32902: PPUSH
// if not mc_bases then
32903: LD_EXP 71
32907: NOT
32908: IFFALSE 32912
// exit ;
32910: GO 33090
// for i = 1 to mc_bases do
32912: LD_ADDR_VAR 0 2
32916: PUSH
32917: DOUBLE
32918: LD_INT 1
32920: DEC
32921: ST_TO_ADDR
32922: LD_EXP 71
32926: PUSH
32927: FOR_TO
32928: IFFALSE 33088
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
32930: LD_ADDR_VAR 0 4
32934: PUSH
32935: LD_EXP 71
32939: PUSH
32940: LD_VAR 0 2
32944: ARRAY
32945: PPUSH
32946: LD_INT 25
32948: PUSH
32949: LD_INT 9
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PPUSH
32956: CALL_OW 72
32960: ST_TO_ADDR
// if not tmp then
32961: LD_VAR 0 4
32965: NOT
32966: IFFALSE 32970
// continue ;
32968: GO 32927
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
32970: LD_EXP 97
32974: PUSH
32975: LD_VAR 0 2
32979: ARRAY
32980: PPUSH
32981: LD_INT 29
32983: PPUSH
32984: CALL_OW 325
32988: NOT
32989: PUSH
32990: LD_EXP 97
32994: PUSH
32995: LD_VAR 0 2
32999: ARRAY
33000: PPUSH
33001: LD_INT 28
33003: PPUSH
33004: CALL_OW 325
33008: NOT
33009: AND
33010: IFFALSE 33014
// continue ;
33012: GO 32927
// for j in tmp do
33014: LD_ADDR_VAR 0 3
33018: PUSH
33019: LD_VAR 0 4
33023: PUSH
33024: FOR_IN
33025: IFFALSE 33084
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
33027: LD_VAR 0 3
33031: PUSH
33032: LD_EXP 74
33036: PUSH
33037: LD_VAR 0 2
33041: ARRAY
33042: PUSH
33043: LD_INT 1
33045: ARRAY
33046: IN
33047: NOT
33048: PUSH
33049: LD_VAR 0 3
33053: PUSH
33054: LD_EXP 74
33058: PUSH
33059: LD_VAR 0 2
33063: ARRAY
33064: PUSH
33065: LD_INT 2
33067: ARRAY
33068: IN
33069: NOT
33070: AND
33071: IFFALSE 33082
// ComSpaceTimeShoot ( j ) ;
33073: LD_VAR 0 3
33077: PPUSH
33078: CALL 43264 0 1
33082: GO 33024
33084: POP
33085: POP
// end ;
33086: GO 32927
33088: POP
33089: POP
// end ;
33090: LD_VAR 0 1
33094: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
33095: LD_INT 0
33097: PPUSH
33098: PPUSH
33099: PPUSH
33100: PPUSH
33101: PPUSH
33102: PPUSH
33103: PPUSH
33104: PPUSH
33105: PPUSH
// if not mc_bases then
33106: LD_EXP 71
33110: NOT
33111: IFFALSE 33115
// exit ;
33113: GO 33737
// for i = 1 to mc_bases do
33115: LD_ADDR_VAR 0 2
33119: PUSH
33120: DOUBLE
33121: LD_INT 1
33123: DEC
33124: ST_TO_ADDR
33125: LD_EXP 71
33129: PUSH
33130: FOR_TO
33131: IFFALSE 33735
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
33133: LD_EXP 106
33137: PUSH
33138: LD_VAR 0 2
33142: ARRAY
33143: NOT
33144: PUSH
33145: LD_INT 38
33147: PPUSH
33148: LD_EXP 97
33152: PUSH
33153: LD_VAR 0 2
33157: ARRAY
33158: PPUSH
33159: CALL_OW 321
33163: PUSH
33164: LD_INT 2
33166: NONEQUAL
33167: OR
33168: IFFALSE 33172
// continue ;
33170: GO 33130
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
33172: LD_ADDR_VAR 0 8
33176: PUSH
33177: LD_EXP 71
33181: PUSH
33182: LD_VAR 0 2
33186: ARRAY
33187: PPUSH
33188: LD_INT 30
33190: PUSH
33191: LD_INT 34
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PPUSH
33198: CALL_OW 72
33202: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
33203: LD_ADDR_VAR 0 9
33207: PUSH
33208: LD_EXP 71
33212: PUSH
33213: LD_VAR 0 2
33217: ARRAY
33218: PPUSH
33219: LD_INT 25
33221: PUSH
33222: LD_INT 4
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PPUSH
33229: CALL_OW 72
33233: PPUSH
33234: LD_INT 0
33236: PPUSH
33237: CALL 82401 0 2
33241: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
33242: LD_VAR 0 9
33246: NOT
33247: PUSH
33248: LD_VAR 0 8
33252: NOT
33253: OR
33254: PUSH
33255: LD_EXP 71
33259: PUSH
33260: LD_VAR 0 2
33264: ARRAY
33265: PPUSH
33266: LD_INT 124
33268: PPUSH
33269: CALL 82401 0 2
33273: OR
33274: IFFALSE 33278
// continue ;
33276: GO 33130
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
33278: LD_EXP 107
33282: PUSH
33283: LD_VAR 0 2
33287: ARRAY
33288: PUSH
33289: LD_EXP 106
33293: PUSH
33294: LD_VAR 0 2
33298: ARRAY
33299: LESS
33300: PUSH
33301: LD_EXP 107
33305: PUSH
33306: LD_VAR 0 2
33310: ARRAY
33311: PUSH
33312: LD_VAR 0 8
33316: LESS
33317: AND
33318: IFFALSE 33733
// begin tmp := sci [ 1 ] ;
33320: LD_ADDR_VAR 0 7
33324: PUSH
33325: LD_VAR 0 9
33329: PUSH
33330: LD_INT 1
33332: ARRAY
33333: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
33334: LD_VAR 0 7
33338: PPUSH
33339: LD_INT 124
33341: PPUSH
33342: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
33346: LD_ADDR_VAR 0 3
33350: PUSH
33351: DOUBLE
33352: LD_EXP 106
33356: PUSH
33357: LD_VAR 0 2
33361: ARRAY
33362: INC
33363: ST_TO_ADDR
33364: LD_EXP 106
33368: PUSH
33369: LD_VAR 0 2
33373: ARRAY
33374: PUSH
33375: FOR_DOWNTO
33376: IFFALSE 33719
// begin if IsInUnit ( tmp ) then
33378: LD_VAR 0 7
33382: PPUSH
33383: CALL_OW 310
33387: IFFALSE 33398
// ComExitBuilding ( tmp ) ;
33389: LD_VAR 0 7
33393: PPUSH
33394: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
33398: LD_INT 35
33400: PPUSH
33401: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
33405: LD_VAR 0 7
33409: PPUSH
33410: CALL_OW 310
33414: NOT
33415: PUSH
33416: LD_VAR 0 7
33420: PPUSH
33421: CALL_OW 314
33425: NOT
33426: AND
33427: IFFALSE 33398
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
33429: LD_ADDR_VAR 0 6
33433: PUSH
33434: LD_VAR 0 7
33438: PPUSH
33439: CALL_OW 250
33443: PUSH
33444: LD_VAR 0 7
33448: PPUSH
33449: CALL_OW 251
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33458: LD_INT 35
33460: PPUSH
33461: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
33465: LD_ADDR_VAR 0 4
33469: PUSH
33470: LD_EXP 106
33474: PUSH
33475: LD_VAR 0 2
33479: ARRAY
33480: PUSH
33481: LD_VAR 0 3
33485: ARRAY
33486: PUSH
33487: LD_INT 1
33489: ARRAY
33490: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
33491: LD_ADDR_VAR 0 5
33495: PUSH
33496: LD_EXP 106
33500: PUSH
33501: LD_VAR 0 2
33505: ARRAY
33506: PUSH
33507: LD_VAR 0 3
33511: ARRAY
33512: PUSH
33513: LD_INT 2
33515: ARRAY
33516: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
33517: LD_VAR 0 7
33521: PPUSH
33522: LD_INT 10
33524: PPUSH
33525: CALL 51797 0 2
33529: PUSH
33530: LD_INT 4
33532: ARRAY
33533: IFFALSE 33571
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
33535: LD_VAR 0 7
33539: PPUSH
33540: LD_VAR 0 6
33544: PUSH
33545: LD_INT 1
33547: ARRAY
33548: PPUSH
33549: LD_VAR 0 6
33553: PUSH
33554: LD_INT 2
33556: ARRAY
33557: PPUSH
33558: CALL_OW 111
// wait ( 0 0$10 ) ;
33562: LD_INT 350
33564: PPUSH
33565: CALL_OW 67
// end else
33569: GO 33597
// begin ComMoveXY ( tmp , x , y ) ;
33571: LD_VAR 0 7
33575: PPUSH
33576: LD_VAR 0 4
33580: PPUSH
33581: LD_VAR 0 5
33585: PPUSH
33586: CALL_OW 111
// wait ( 0 0$3 ) ;
33590: LD_INT 105
33592: PPUSH
33593: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
33597: LD_VAR 0 7
33601: PPUSH
33602: LD_VAR 0 4
33606: PPUSH
33607: LD_VAR 0 5
33611: PPUSH
33612: CALL_OW 307
33616: IFFALSE 33458
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
33618: LD_VAR 0 7
33622: PPUSH
33623: LD_VAR 0 4
33627: PPUSH
33628: LD_VAR 0 5
33632: PPUSH
33633: LD_VAR 0 8
33637: PUSH
33638: LD_VAR 0 3
33642: ARRAY
33643: PPUSH
33644: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
33648: LD_INT 35
33650: PPUSH
33651: CALL_OW 67
// until not HasTask ( tmp ) ;
33655: LD_VAR 0 7
33659: PPUSH
33660: CALL_OW 314
33664: NOT
33665: IFFALSE 33648
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
33667: LD_ADDR_EXP 107
33671: PUSH
33672: LD_EXP 107
33676: PPUSH
33677: LD_VAR 0 2
33681: PUSH
33682: LD_EXP 107
33686: PUSH
33687: LD_VAR 0 2
33691: ARRAY
33692: PUSH
33693: LD_INT 1
33695: PLUS
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PPUSH
33701: LD_VAR 0 8
33705: PUSH
33706: LD_VAR 0 3
33710: ARRAY
33711: PPUSH
33712: CALL 49204 0 3
33716: ST_TO_ADDR
// end ;
33717: GO 33375
33719: POP
33720: POP
// MC_Reset ( i , 124 ) ;
33721: LD_VAR 0 2
33725: PPUSH
33726: LD_INT 124
33728: PPUSH
33729: CALL 17847 0 2
// end ; end ;
33733: GO 33130
33735: POP
33736: POP
// end ;
33737: LD_VAR 0 1
33741: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
33742: LD_INT 0
33744: PPUSH
33745: PPUSH
33746: PPUSH
// if not mc_bases then
33747: LD_EXP 71
33751: NOT
33752: IFFALSE 33756
// exit ;
33754: GO 34362
// for i = 1 to mc_bases do
33756: LD_ADDR_VAR 0 2
33760: PUSH
33761: DOUBLE
33762: LD_INT 1
33764: DEC
33765: ST_TO_ADDR
33766: LD_EXP 71
33770: PUSH
33771: FOR_TO
33772: IFFALSE 34360
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
33774: LD_ADDR_VAR 0 3
33778: PUSH
33779: LD_EXP 71
33783: PUSH
33784: LD_VAR 0 2
33788: ARRAY
33789: PPUSH
33790: LD_INT 25
33792: PUSH
33793: LD_INT 4
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PPUSH
33800: CALL_OW 72
33804: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
33805: LD_VAR 0 3
33809: NOT
33810: PUSH
33811: LD_EXP 108
33815: PUSH
33816: LD_VAR 0 2
33820: ARRAY
33821: NOT
33822: OR
33823: PUSH
33824: LD_EXP 71
33828: PUSH
33829: LD_VAR 0 2
33833: ARRAY
33834: PPUSH
33835: LD_INT 2
33837: PUSH
33838: LD_INT 30
33840: PUSH
33841: LD_INT 0
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 30
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: LIST
33862: PPUSH
33863: CALL_OW 72
33867: NOT
33868: OR
33869: IFFALSE 33919
// begin if mc_deposits_finder [ i ] then
33871: LD_EXP 109
33875: PUSH
33876: LD_VAR 0 2
33880: ARRAY
33881: IFFALSE 33917
// begin MC_Reset ( i , 125 ) ;
33883: LD_VAR 0 2
33887: PPUSH
33888: LD_INT 125
33890: PPUSH
33891: CALL 17847 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
33895: LD_ADDR_EXP 109
33899: PUSH
33900: LD_EXP 109
33904: PPUSH
33905: LD_VAR 0 2
33909: PPUSH
33910: EMPTY
33911: PPUSH
33912: CALL_OW 1
33916: ST_TO_ADDR
// end ; continue ;
33917: GO 33771
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
33919: LD_EXP 108
33923: PUSH
33924: LD_VAR 0 2
33928: ARRAY
33929: PUSH
33930: LD_INT 1
33932: ARRAY
33933: PUSH
33934: LD_INT 3
33936: ARRAY
33937: PUSH
33938: LD_INT 1
33940: EQUAL
33941: PUSH
33942: LD_INT 20
33944: PPUSH
33945: LD_EXP 97
33949: PUSH
33950: LD_VAR 0 2
33954: ARRAY
33955: PPUSH
33956: CALL_OW 321
33960: PUSH
33961: LD_INT 2
33963: NONEQUAL
33964: AND
33965: IFFALSE 34015
// begin if mc_deposits_finder [ i ] then
33967: LD_EXP 109
33971: PUSH
33972: LD_VAR 0 2
33976: ARRAY
33977: IFFALSE 34013
// begin MC_Reset ( i , 125 ) ;
33979: LD_VAR 0 2
33983: PPUSH
33984: LD_INT 125
33986: PPUSH
33987: CALL 17847 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
33991: LD_ADDR_EXP 109
33995: PUSH
33996: LD_EXP 109
34000: PPUSH
34001: LD_VAR 0 2
34005: PPUSH
34006: EMPTY
34007: PPUSH
34008: CALL_OW 1
34012: ST_TO_ADDR
// end ; continue ;
34013: GO 33771
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
34015: LD_EXP 108
34019: PUSH
34020: LD_VAR 0 2
34024: ARRAY
34025: PUSH
34026: LD_INT 1
34028: ARRAY
34029: PUSH
34030: LD_INT 1
34032: ARRAY
34033: PPUSH
34034: LD_EXP 108
34038: PUSH
34039: LD_VAR 0 2
34043: ARRAY
34044: PUSH
34045: LD_INT 1
34047: ARRAY
34048: PUSH
34049: LD_INT 2
34051: ARRAY
34052: PPUSH
34053: LD_EXP 97
34057: PUSH
34058: LD_VAR 0 2
34062: ARRAY
34063: PPUSH
34064: CALL_OW 440
34068: IFFALSE 34111
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
34070: LD_ADDR_EXP 108
34074: PUSH
34075: LD_EXP 108
34079: PPUSH
34080: LD_VAR 0 2
34084: PPUSH
34085: LD_EXP 108
34089: PUSH
34090: LD_VAR 0 2
34094: ARRAY
34095: PPUSH
34096: LD_INT 1
34098: PPUSH
34099: CALL_OW 3
34103: PPUSH
34104: CALL_OW 1
34108: ST_TO_ADDR
34109: GO 34358
// begin if not mc_deposits_finder [ i ] then
34111: LD_EXP 109
34115: PUSH
34116: LD_VAR 0 2
34120: ARRAY
34121: NOT
34122: IFFALSE 34174
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
34124: LD_ADDR_EXP 109
34128: PUSH
34129: LD_EXP 109
34133: PPUSH
34134: LD_VAR 0 2
34138: PPUSH
34139: LD_VAR 0 3
34143: PUSH
34144: LD_INT 1
34146: ARRAY
34147: PUSH
34148: EMPTY
34149: LIST
34150: PPUSH
34151: CALL_OW 1
34155: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
34156: LD_VAR 0 3
34160: PUSH
34161: LD_INT 1
34163: ARRAY
34164: PPUSH
34165: LD_INT 125
34167: PPUSH
34168: CALL_OW 109
// end else
34172: GO 34358
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
34174: LD_EXP 109
34178: PUSH
34179: LD_VAR 0 2
34183: ARRAY
34184: PUSH
34185: LD_INT 1
34187: ARRAY
34188: PPUSH
34189: CALL_OW 310
34193: IFFALSE 34216
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
34195: LD_EXP 109
34199: PUSH
34200: LD_VAR 0 2
34204: ARRAY
34205: PUSH
34206: LD_INT 1
34208: ARRAY
34209: PPUSH
34210: CALL_OW 122
34214: GO 34358
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
34216: LD_EXP 109
34220: PUSH
34221: LD_VAR 0 2
34225: ARRAY
34226: PUSH
34227: LD_INT 1
34229: ARRAY
34230: PPUSH
34231: CALL_OW 314
34235: NOT
34236: PUSH
34237: LD_EXP 109
34241: PUSH
34242: LD_VAR 0 2
34246: ARRAY
34247: PUSH
34248: LD_INT 1
34250: ARRAY
34251: PPUSH
34252: LD_EXP 108
34256: PUSH
34257: LD_VAR 0 2
34261: ARRAY
34262: PUSH
34263: LD_INT 1
34265: ARRAY
34266: PUSH
34267: LD_INT 1
34269: ARRAY
34270: PPUSH
34271: LD_EXP 108
34275: PUSH
34276: LD_VAR 0 2
34280: ARRAY
34281: PUSH
34282: LD_INT 1
34284: ARRAY
34285: PUSH
34286: LD_INT 2
34288: ARRAY
34289: PPUSH
34290: CALL_OW 297
34294: PUSH
34295: LD_INT 6
34297: GREATER
34298: AND
34299: IFFALSE 34358
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
34301: LD_EXP 109
34305: PUSH
34306: LD_VAR 0 2
34310: ARRAY
34311: PUSH
34312: LD_INT 1
34314: ARRAY
34315: PPUSH
34316: LD_EXP 108
34320: PUSH
34321: LD_VAR 0 2
34325: ARRAY
34326: PUSH
34327: LD_INT 1
34329: ARRAY
34330: PUSH
34331: LD_INT 1
34333: ARRAY
34334: PPUSH
34335: LD_EXP 108
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: PUSH
34346: LD_INT 1
34348: ARRAY
34349: PUSH
34350: LD_INT 2
34352: ARRAY
34353: PPUSH
34354: CALL_OW 111
// end ; end ; end ;
34358: GO 33771
34360: POP
34361: POP
// end ;
34362: LD_VAR 0 1
34366: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
34367: LD_INT 0
34369: PPUSH
34370: PPUSH
34371: PPUSH
34372: PPUSH
34373: PPUSH
34374: PPUSH
34375: PPUSH
34376: PPUSH
34377: PPUSH
34378: PPUSH
34379: PPUSH
// if not mc_bases then
34380: LD_EXP 71
34384: NOT
34385: IFFALSE 34389
// exit ;
34387: GO 35113
// for i = 1 to mc_bases do
34389: LD_ADDR_VAR 0 2
34393: PUSH
34394: DOUBLE
34395: LD_INT 1
34397: DEC
34398: ST_TO_ADDR
34399: LD_EXP 71
34403: PUSH
34404: FOR_TO
34405: IFFALSE 35111
// begin if not mc_bases [ i ] then
34407: LD_EXP 71
34411: PUSH
34412: LD_VAR 0 2
34416: ARRAY
34417: NOT
34418: IFFALSE 34422
// continue ;
34420: GO 34404
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
34422: LD_ADDR_VAR 0 7
34426: PUSH
34427: LD_EXP 71
34431: PUSH
34432: LD_VAR 0 2
34436: ARRAY
34437: PUSH
34438: LD_INT 1
34440: ARRAY
34441: PPUSH
34442: CALL_OW 248
34446: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
34447: LD_VAR 0 7
34451: PUSH
34452: LD_INT 3
34454: EQUAL
34455: PUSH
34456: LD_EXP 90
34460: PUSH
34461: LD_VAR 0 2
34465: ARRAY
34466: PUSH
34467: LD_EXP 93
34471: PUSH
34472: LD_VAR 0 2
34476: ARRAY
34477: UNION
34478: PPUSH
34479: LD_INT 33
34481: PUSH
34482: LD_INT 2
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PPUSH
34489: CALL_OW 72
34493: NOT
34494: OR
34495: IFFALSE 34499
// continue ;
34497: GO 34404
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
34499: LD_ADDR_VAR 0 9
34503: PUSH
34504: LD_EXP 71
34508: PUSH
34509: LD_VAR 0 2
34513: ARRAY
34514: PPUSH
34515: LD_INT 30
34517: PUSH
34518: LD_INT 36
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PPUSH
34525: CALL_OW 72
34529: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
34530: LD_ADDR_VAR 0 10
34534: PUSH
34535: LD_EXP 90
34539: PUSH
34540: LD_VAR 0 2
34544: ARRAY
34545: PPUSH
34546: LD_INT 34
34548: PUSH
34549: LD_INT 31
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PPUSH
34556: CALL_OW 72
34560: ST_TO_ADDR
// if not cts and not mcts then
34561: LD_VAR 0 9
34565: NOT
34566: PUSH
34567: LD_VAR 0 10
34571: NOT
34572: AND
34573: IFFALSE 34577
// continue ;
34575: GO 34404
// x := cts ;
34577: LD_ADDR_VAR 0 11
34581: PUSH
34582: LD_VAR 0 9
34586: ST_TO_ADDR
// if not x then
34587: LD_VAR 0 11
34591: NOT
34592: IFFALSE 34604
// x := mcts ;
34594: LD_ADDR_VAR 0 11
34598: PUSH
34599: LD_VAR 0 10
34603: ST_TO_ADDR
// if mc_remote_driver [ i ] then
34604: LD_EXP 111
34608: PUSH
34609: LD_VAR 0 2
34613: ARRAY
34614: IFFALSE 34883
// for j in mc_remote_driver [ i ] do
34616: LD_ADDR_VAR 0 3
34620: PUSH
34621: LD_EXP 111
34625: PUSH
34626: LD_VAR 0 2
34630: ARRAY
34631: PUSH
34632: FOR_IN
34633: IFFALSE 34881
// begin if GetClass ( j ) <> 3 then
34635: LD_VAR 0 3
34639: PPUSH
34640: CALL_OW 257
34644: PUSH
34645: LD_INT 3
34647: NONEQUAL
34648: IFFALSE 34701
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
34650: LD_ADDR_EXP 111
34654: PUSH
34655: LD_EXP 111
34659: PPUSH
34660: LD_VAR 0 2
34664: PPUSH
34665: LD_EXP 111
34669: PUSH
34670: LD_VAR 0 2
34674: ARRAY
34675: PUSH
34676: LD_VAR 0 3
34680: DIFF
34681: PPUSH
34682: CALL_OW 1
34686: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34687: LD_VAR 0 3
34691: PPUSH
34692: LD_INT 0
34694: PPUSH
34695: CALL_OW 109
// continue ;
34699: GO 34632
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
34701: LD_VAR 0 3
34705: PPUSH
34706: CALL_OW 310
34710: NOT
34711: PUSH
34712: LD_VAR 0 3
34716: PPUSH
34717: CALL_OW 310
34721: PPUSH
34722: CALL_OW 266
34726: PUSH
34727: LD_INT 36
34729: NONEQUAL
34730: PUSH
34731: LD_VAR 0 3
34735: PPUSH
34736: CALL 82489 0 1
34740: NOT
34741: AND
34742: OR
34743: IFFALSE 34879
// begin if IsInUnit ( j ) then
34745: LD_VAR 0 3
34749: PPUSH
34750: CALL_OW 310
34754: IFFALSE 34765
// ComExitBuilding ( j ) ;
34756: LD_VAR 0 3
34760: PPUSH
34761: CALL_OW 122
// ct := 0 ;
34765: LD_ADDR_VAR 0 8
34769: PUSH
34770: LD_INT 0
34772: ST_TO_ADDR
// for k in x do
34773: LD_ADDR_VAR 0 4
34777: PUSH
34778: LD_VAR 0 11
34782: PUSH
34783: FOR_IN
34784: IFFALSE 34857
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
34786: LD_VAR 0 4
34790: PPUSH
34791: CALL_OW 264
34795: PUSH
34796: LD_INT 31
34798: EQUAL
34799: PUSH
34800: LD_VAR 0 4
34804: PPUSH
34805: CALL_OW 311
34809: NOT
34810: AND
34811: PUSH
34812: LD_VAR 0 4
34816: PPUSH
34817: CALL_OW 266
34821: PUSH
34822: LD_INT 36
34824: EQUAL
34825: PUSH
34826: LD_VAR 0 4
34830: PPUSH
34831: CALL_OW 313
34835: PUSH
34836: LD_INT 3
34838: LESS
34839: AND
34840: OR
34841: IFFALSE 34855
// begin ct := k ;
34843: LD_ADDR_VAR 0 8
34847: PUSH
34848: LD_VAR 0 4
34852: ST_TO_ADDR
// break ;
34853: GO 34857
// end ;
34855: GO 34783
34857: POP
34858: POP
// if ct then
34859: LD_VAR 0 8
34863: IFFALSE 34879
// ComEnterUnit ( j , ct ) ;
34865: LD_VAR 0 3
34869: PPUSH
34870: LD_VAR 0 8
34874: PPUSH
34875: CALL_OW 120
// end ; end ;
34879: GO 34632
34881: POP
34882: POP
// places := 0 ;
34883: LD_ADDR_VAR 0 5
34887: PUSH
34888: LD_INT 0
34890: ST_TO_ADDR
// for j = 1 to x do
34891: LD_ADDR_VAR 0 3
34895: PUSH
34896: DOUBLE
34897: LD_INT 1
34899: DEC
34900: ST_TO_ADDR
34901: LD_VAR 0 11
34905: PUSH
34906: FOR_TO
34907: IFFALSE 34962
// if GetWeapon ( x [ j ] ) = ar_control_tower then
34909: LD_VAR 0 11
34913: PUSH
34914: LD_VAR 0 3
34918: ARRAY
34919: PPUSH
34920: CALL_OW 264
34924: PUSH
34925: LD_INT 31
34927: EQUAL
34928: IFFALSE 34946
// places := places + 1 else
34930: LD_ADDR_VAR 0 5
34934: PUSH
34935: LD_VAR 0 5
34939: PUSH
34940: LD_INT 1
34942: PLUS
34943: ST_TO_ADDR
34944: GO 34960
// places := places + 3 ;
34946: LD_ADDR_VAR 0 5
34950: PUSH
34951: LD_VAR 0 5
34955: PUSH
34956: LD_INT 3
34958: PLUS
34959: ST_TO_ADDR
34960: GO 34906
34962: POP
34963: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
34964: LD_ADDR_VAR 0 6
34968: PUSH
34969: LD_EXP 71
34973: PUSH
34974: LD_VAR 0 2
34978: ARRAY
34979: PPUSH
34980: LD_INT 25
34982: PUSH
34983: LD_INT 3
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PPUSH
34990: CALL_OW 72
34994: PUSH
34995: LD_EXP 111
34999: PUSH
35000: LD_VAR 0 2
35004: ARRAY
35005: DIFF
35006: PPUSH
35007: LD_INT 3
35009: PPUSH
35010: CALL 83389 0 2
35014: ST_TO_ADDR
// if not tmp then
35015: LD_VAR 0 6
35019: NOT
35020: IFFALSE 35024
// continue ;
35022: GO 34404
// places := places - mc_remote_driver [ i ] ;
35024: LD_ADDR_VAR 0 5
35028: PUSH
35029: LD_VAR 0 5
35033: PUSH
35034: LD_EXP 111
35038: PUSH
35039: LD_VAR 0 2
35043: ARRAY
35044: MINUS
35045: ST_TO_ADDR
// if places then
35046: LD_VAR 0 5
35050: IFFALSE 35109
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
35052: LD_ADDR_EXP 111
35056: PUSH
35057: LD_EXP 111
35061: PPUSH
35062: LD_VAR 0 2
35066: PPUSH
35067: LD_EXP 111
35071: PUSH
35072: LD_VAR 0 2
35076: ARRAY
35077: PUSH
35078: LD_VAR 0 6
35082: PUSH
35083: LD_INT 1
35085: ARRAY
35086: UNION
35087: PPUSH
35088: CALL_OW 1
35092: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
35093: LD_VAR 0 6
35097: PUSH
35098: LD_INT 1
35100: ARRAY
35101: PPUSH
35102: LD_INT 126
35104: PPUSH
35105: CALL_OW 109
// end ; end ;
35109: GO 34404
35111: POP
35112: POP
// end ;
35113: LD_VAR 0 1
35117: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
35118: LD_INT 0
35120: PPUSH
35121: PPUSH
35122: PPUSH
35123: PPUSH
35124: PPUSH
35125: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
35126: LD_VAR 0 1
35130: NOT
35131: PUSH
35132: LD_VAR 0 2
35136: NOT
35137: OR
35138: PUSH
35139: LD_VAR 0 3
35143: NOT
35144: OR
35145: PUSH
35146: LD_VAR 0 4
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: LD_INT 2
35156: PUSH
35157: LD_INT 3
35159: PUSH
35160: LD_INT 4
35162: PUSH
35163: LD_INT 5
35165: PUSH
35166: LD_INT 8
35168: PUSH
35169: LD_INT 9
35171: PUSH
35172: LD_INT 15
35174: PUSH
35175: LD_INT 16
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: IN
35189: NOT
35190: OR
35191: IFFALSE 35195
// exit ;
35193: GO 36095
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
35195: LD_ADDR_VAR 0 2
35199: PUSH
35200: LD_VAR 0 2
35204: PPUSH
35205: LD_INT 21
35207: PUSH
35208: LD_INT 3
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 24
35217: PUSH
35218: LD_INT 250
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PPUSH
35229: CALL_OW 72
35233: ST_TO_ADDR
// case class of 1 , 15 :
35234: LD_VAR 0 4
35238: PUSH
35239: LD_INT 1
35241: DOUBLE
35242: EQUAL
35243: IFTRUE 35253
35245: LD_INT 15
35247: DOUBLE
35248: EQUAL
35249: IFTRUE 35253
35251: GO 35338
35253: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
35254: LD_ADDR_VAR 0 8
35258: PUSH
35259: LD_VAR 0 2
35263: PPUSH
35264: LD_INT 2
35266: PUSH
35267: LD_INT 30
35269: PUSH
35270: LD_INT 32
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 30
35279: PUSH
35280: LD_INT 31
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: LIST
35291: PPUSH
35292: CALL_OW 72
35296: PUSH
35297: LD_VAR 0 2
35301: PPUSH
35302: LD_INT 2
35304: PUSH
35305: LD_INT 30
35307: PUSH
35308: LD_INT 4
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 30
35317: PUSH
35318: LD_INT 5
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: LIST
35329: PPUSH
35330: CALL_OW 72
35334: ADD
35335: ST_TO_ADDR
35336: GO 35584
35338: LD_INT 2
35340: DOUBLE
35341: EQUAL
35342: IFTRUE 35352
35344: LD_INT 16
35346: DOUBLE
35347: EQUAL
35348: IFTRUE 35352
35350: GO 35398
35352: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
35353: LD_ADDR_VAR 0 8
35357: PUSH
35358: LD_VAR 0 2
35362: PPUSH
35363: LD_INT 2
35365: PUSH
35366: LD_INT 30
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 30
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: LIST
35390: PPUSH
35391: CALL_OW 72
35395: ST_TO_ADDR
35396: GO 35584
35398: LD_INT 3
35400: DOUBLE
35401: EQUAL
35402: IFTRUE 35406
35404: GO 35452
35406: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
35407: LD_ADDR_VAR 0 8
35411: PUSH
35412: LD_VAR 0 2
35416: PPUSH
35417: LD_INT 2
35419: PUSH
35420: LD_INT 30
35422: PUSH
35423: LD_INT 2
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 30
35432: PUSH
35433: LD_INT 3
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: LIST
35444: PPUSH
35445: CALL_OW 72
35449: ST_TO_ADDR
35450: GO 35584
35452: LD_INT 4
35454: DOUBLE
35455: EQUAL
35456: IFTRUE 35460
35458: GO 35517
35460: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
35461: LD_ADDR_VAR 0 8
35465: PUSH
35466: LD_VAR 0 2
35470: PPUSH
35471: LD_INT 2
35473: PUSH
35474: LD_INT 30
35476: PUSH
35477: LD_INT 6
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 30
35486: PUSH
35487: LD_INT 7
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 30
35496: PUSH
35497: LD_INT 8
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: PPUSH
35510: CALL_OW 72
35514: ST_TO_ADDR
35515: GO 35584
35517: LD_INT 5
35519: DOUBLE
35520: EQUAL
35521: IFTRUE 35537
35523: LD_INT 8
35525: DOUBLE
35526: EQUAL
35527: IFTRUE 35537
35529: LD_INT 9
35531: DOUBLE
35532: EQUAL
35533: IFTRUE 35537
35535: GO 35583
35537: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
35538: LD_ADDR_VAR 0 8
35542: PUSH
35543: LD_VAR 0 2
35547: PPUSH
35548: LD_INT 2
35550: PUSH
35551: LD_INT 30
35553: PUSH
35554: LD_INT 4
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 30
35563: PUSH
35564: LD_INT 5
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: LIST
35575: PPUSH
35576: CALL_OW 72
35580: ST_TO_ADDR
35581: GO 35584
35583: POP
// if not tmp then
35584: LD_VAR 0 8
35588: NOT
35589: IFFALSE 35593
// exit ;
35591: GO 36095
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
35593: LD_VAR 0 4
35597: PUSH
35598: LD_INT 1
35600: PUSH
35601: LD_INT 15
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: IN
35608: PUSH
35609: LD_EXP 80
35613: PUSH
35614: LD_VAR 0 1
35618: ARRAY
35619: AND
35620: IFFALSE 35776
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
35622: LD_ADDR_VAR 0 9
35626: PUSH
35627: LD_EXP 80
35631: PUSH
35632: LD_VAR 0 1
35636: ARRAY
35637: PUSH
35638: LD_INT 1
35640: ARRAY
35641: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
35642: LD_VAR 0 9
35646: PUSH
35647: LD_EXP 81
35651: PUSH
35652: LD_VAR 0 1
35656: ARRAY
35657: IN
35658: NOT
35659: IFFALSE 35774
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
35661: LD_ADDR_EXP 81
35665: PUSH
35666: LD_EXP 81
35670: PPUSH
35671: LD_VAR 0 1
35675: PUSH
35676: LD_EXP 81
35680: PUSH
35681: LD_VAR 0 1
35685: ARRAY
35686: PUSH
35687: LD_INT 1
35689: PLUS
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PPUSH
35695: LD_VAR 0 9
35699: PPUSH
35700: CALL 49204 0 3
35704: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
35705: LD_ADDR_EXP 80
35709: PUSH
35710: LD_EXP 80
35714: PPUSH
35715: LD_VAR 0 1
35719: PPUSH
35720: LD_EXP 80
35724: PUSH
35725: LD_VAR 0 1
35729: ARRAY
35730: PUSH
35731: LD_VAR 0 9
35735: DIFF
35736: PPUSH
35737: CALL_OW 1
35741: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
35742: LD_VAR 0 3
35746: PPUSH
35747: LD_EXP 81
35751: PUSH
35752: LD_VAR 0 1
35756: ARRAY
35757: PUSH
35758: LD_EXP 81
35762: PUSH
35763: LD_VAR 0 1
35767: ARRAY
35768: ARRAY
35769: PPUSH
35770: CALL_OW 120
// end ; exit ;
35774: GO 36095
// end ; if tmp > 1 then
35776: LD_VAR 0 8
35780: PUSH
35781: LD_INT 1
35783: GREATER
35784: IFFALSE 35888
// for i = 2 to tmp do
35786: LD_ADDR_VAR 0 6
35790: PUSH
35791: DOUBLE
35792: LD_INT 2
35794: DEC
35795: ST_TO_ADDR
35796: LD_VAR 0 8
35800: PUSH
35801: FOR_TO
35802: IFFALSE 35886
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
35804: LD_VAR 0 8
35808: PUSH
35809: LD_VAR 0 6
35813: ARRAY
35814: PPUSH
35815: CALL_OW 461
35819: PUSH
35820: LD_INT 6
35822: EQUAL
35823: IFFALSE 35884
// begin x := tmp [ i ] ;
35825: LD_ADDR_VAR 0 9
35829: PUSH
35830: LD_VAR 0 8
35834: PUSH
35835: LD_VAR 0 6
35839: ARRAY
35840: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
35841: LD_ADDR_VAR 0 8
35845: PUSH
35846: LD_VAR 0 8
35850: PPUSH
35851: LD_VAR 0 6
35855: PPUSH
35856: CALL_OW 3
35860: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
35861: LD_ADDR_VAR 0 8
35865: PUSH
35866: LD_VAR 0 8
35870: PPUSH
35871: LD_INT 1
35873: PPUSH
35874: LD_VAR 0 9
35878: PPUSH
35879: CALL_OW 2
35883: ST_TO_ADDR
// end ;
35884: GO 35801
35886: POP
35887: POP
// for i in tmp do
35888: LD_ADDR_VAR 0 6
35892: PUSH
35893: LD_VAR 0 8
35897: PUSH
35898: FOR_IN
35899: IFFALSE 35968
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
35901: LD_VAR 0 6
35905: PPUSH
35906: CALL_OW 313
35910: PUSH
35911: LD_INT 6
35913: LESS
35914: PUSH
35915: LD_VAR 0 6
35919: PPUSH
35920: CALL_OW 266
35924: PUSH
35925: LD_INT 31
35927: PUSH
35928: LD_INT 32
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: IN
35935: NOT
35936: AND
35937: PUSH
35938: LD_VAR 0 6
35942: PPUSH
35943: CALL_OW 313
35947: PUSH
35948: LD_INT 0
35950: EQUAL
35951: OR
35952: IFFALSE 35966
// begin j := i ;
35954: LD_ADDR_VAR 0 7
35958: PUSH
35959: LD_VAR 0 6
35963: ST_TO_ADDR
// break ;
35964: GO 35968
// end ; end ;
35966: GO 35898
35968: POP
35969: POP
// if j then
35970: LD_VAR 0 7
35974: IFFALSE 35992
// ComEnterUnit ( unit , j ) else
35976: LD_VAR 0 3
35980: PPUSH
35981: LD_VAR 0 7
35985: PPUSH
35986: CALL_OW 120
35990: GO 36095
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35992: LD_ADDR_VAR 0 10
35996: PUSH
35997: LD_VAR 0 2
36001: PPUSH
36002: LD_INT 2
36004: PUSH
36005: LD_INT 30
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 30
36017: PUSH
36018: LD_INT 1
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: LIST
36029: PPUSH
36030: CALL_OW 72
36034: ST_TO_ADDR
// if depot then
36035: LD_VAR 0 10
36039: IFFALSE 36095
// begin depot := NearestUnitToUnit ( depot , unit ) ;
36041: LD_ADDR_VAR 0 10
36045: PUSH
36046: LD_VAR 0 10
36050: PPUSH
36051: LD_VAR 0 3
36055: PPUSH
36056: CALL_OW 74
36060: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
36061: LD_VAR 0 3
36065: PPUSH
36066: LD_VAR 0 10
36070: PPUSH
36071: CALL_OW 296
36075: PUSH
36076: LD_INT 10
36078: GREATER
36079: IFFALSE 36095
// ComStandNearbyBuilding ( unit , depot ) ;
36081: LD_VAR 0 3
36085: PPUSH
36086: LD_VAR 0 10
36090: PPUSH
36091: CALL 43881 0 2
// end ; end ; end ;
36095: LD_VAR 0 5
36099: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
36100: LD_INT 0
36102: PPUSH
36103: PPUSH
36104: PPUSH
36105: PPUSH
// if not mc_bases then
36106: LD_EXP 71
36110: NOT
36111: IFFALSE 36115
// exit ;
36113: GO 36354
// for i = 1 to mc_bases do
36115: LD_ADDR_VAR 0 2
36119: PUSH
36120: DOUBLE
36121: LD_INT 1
36123: DEC
36124: ST_TO_ADDR
36125: LD_EXP 71
36129: PUSH
36130: FOR_TO
36131: IFFALSE 36352
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
36133: LD_ADDR_VAR 0 4
36137: PUSH
36138: LD_EXP 71
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PPUSH
36149: LD_INT 21
36151: PUSH
36152: LD_INT 1
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PPUSH
36159: CALL_OW 72
36163: PUSH
36164: LD_EXP 100
36168: PUSH
36169: LD_VAR 0 2
36173: ARRAY
36174: UNION
36175: ST_TO_ADDR
// if not tmp then
36176: LD_VAR 0 4
36180: NOT
36181: IFFALSE 36185
// continue ;
36183: GO 36130
// for j in tmp do
36185: LD_ADDR_VAR 0 3
36189: PUSH
36190: LD_VAR 0 4
36194: PUSH
36195: FOR_IN
36196: IFFALSE 36348
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
36198: LD_VAR 0 3
36202: PPUSH
36203: CALL_OW 110
36207: NOT
36208: PUSH
36209: LD_VAR 0 3
36213: PPUSH
36214: CALL_OW 314
36218: NOT
36219: AND
36220: PUSH
36221: LD_VAR 0 3
36225: PPUSH
36226: CALL_OW 311
36230: NOT
36231: AND
36232: PUSH
36233: LD_VAR 0 3
36237: PPUSH
36238: CALL_OW 310
36242: NOT
36243: AND
36244: PUSH
36245: LD_VAR 0 3
36249: PUSH
36250: LD_EXP 74
36254: PUSH
36255: LD_VAR 0 2
36259: ARRAY
36260: PUSH
36261: LD_INT 1
36263: ARRAY
36264: IN
36265: NOT
36266: AND
36267: PUSH
36268: LD_VAR 0 3
36272: PUSH
36273: LD_EXP 74
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: PUSH
36284: LD_INT 2
36286: ARRAY
36287: IN
36288: NOT
36289: AND
36290: PUSH
36291: LD_VAR 0 3
36295: PUSH
36296: LD_EXP 83
36300: PUSH
36301: LD_VAR 0 2
36305: ARRAY
36306: IN
36307: NOT
36308: AND
36309: IFFALSE 36346
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
36311: LD_VAR 0 2
36315: PPUSH
36316: LD_EXP 71
36320: PUSH
36321: LD_VAR 0 2
36325: ARRAY
36326: PPUSH
36327: LD_VAR 0 3
36331: PPUSH
36332: LD_VAR 0 3
36336: PPUSH
36337: CALL_OW 257
36341: PPUSH
36342: CALL 35118 0 4
// end ;
36346: GO 36195
36348: POP
36349: POP
// end ;
36350: GO 36130
36352: POP
36353: POP
// end ;
36354: LD_VAR 0 1
36358: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
36359: LD_INT 0
36361: PPUSH
36362: PPUSH
36363: PPUSH
36364: PPUSH
36365: PPUSH
36366: PPUSH
// if not mc_bases [ base ] then
36367: LD_EXP 71
36371: PUSH
36372: LD_VAR 0 1
36376: ARRAY
36377: NOT
36378: IFFALSE 36382
// exit ;
36380: GO 36564
// tmp := [ ] ;
36382: LD_ADDR_VAR 0 6
36386: PUSH
36387: EMPTY
36388: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
36389: LD_ADDR_VAR 0 7
36393: PUSH
36394: LD_VAR 0 3
36398: PPUSH
36399: LD_INT 0
36401: PPUSH
36402: CALL_OW 517
36406: ST_TO_ADDR
// if not list then
36407: LD_VAR 0 7
36411: NOT
36412: IFFALSE 36416
// exit ;
36414: GO 36564
// for i = 1 to amount do
36416: LD_ADDR_VAR 0 5
36420: PUSH
36421: DOUBLE
36422: LD_INT 1
36424: DEC
36425: ST_TO_ADDR
36426: LD_VAR 0 2
36430: PUSH
36431: FOR_TO
36432: IFFALSE 36512
// begin x := rand ( 1 , list [ 1 ] ) ;
36434: LD_ADDR_VAR 0 8
36438: PUSH
36439: LD_INT 1
36441: PPUSH
36442: LD_VAR 0 7
36446: PUSH
36447: LD_INT 1
36449: ARRAY
36450: PPUSH
36451: CALL_OW 12
36455: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
36456: LD_ADDR_VAR 0 6
36460: PUSH
36461: LD_VAR 0 6
36465: PPUSH
36466: LD_VAR 0 5
36470: PPUSH
36471: LD_VAR 0 7
36475: PUSH
36476: LD_INT 1
36478: ARRAY
36479: PUSH
36480: LD_VAR 0 8
36484: ARRAY
36485: PUSH
36486: LD_VAR 0 7
36490: PUSH
36491: LD_INT 2
36493: ARRAY
36494: PUSH
36495: LD_VAR 0 8
36499: ARRAY
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PPUSH
36505: CALL_OW 1
36509: ST_TO_ADDR
// end ;
36510: GO 36431
36512: POP
36513: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
36514: LD_ADDR_EXP 84
36518: PUSH
36519: LD_EXP 84
36523: PPUSH
36524: LD_VAR 0 1
36528: PPUSH
36529: LD_VAR 0 6
36533: PPUSH
36534: CALL_OW 1
36538: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
36539: LD_ADDR_EXP 86
36543: PUSH
36544: LD_EXP 86
36548: PPUSH
36549: LD_VAR 0 1
36553: PPUSH
36554: LD_VAR 0 3
36558: PPUSH
36559: CALL_OW 1
36563: ST_TO_ADDR
// end ;
36564: LD_VAR 0 4
36568: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
36569: LD_INT 0
36571: PPUSH
// if not mc_bases [ base ] then
36572: LD_EXP 71
36576: PUSH
36577: LD_VAR 0 1
36581: ARRAY
36582: NOT
36583: IFFALSE 36587
// exit ;
36585: GO 36612
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
36587: LD_ADDR_EXP 76
36591: PUSH
36592: LD_EXP 76
36596: PPUSH
36597: LD_VAR 0 1
36601: PPUSH
36602: LD_VAR 0 2
36606: PPUSH
36607: CALL_OW 1
36611: ST_TO_ADDR
// end ;
36612: LD_VAR 0 3
36616: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
36617: LD_INT 0
36619: PPUSH
// if not mc_bases [ base ] then
36620: LD_EXP 71
36624: PUSH
36625: LD_VAR 0 1
36629: ARRAY
36630: NOT
36631: IFFALSE 36635
// exit ;
36633: GO 36672
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
36635: LD_ADDR_EXP 76
36639: PUSH
36640: LD_EXP 76
36644: PPUSH
36645: LD_VAR 0 1
36649: PPUSH
36650: LD_EXP 76
36654: PUSH
36655: LD_VAR 0 1
36659: ARRAY
36660: PUSH
36661: LD_VAR 0 2
36665: UNION
36666: PPUSH
36667: CALL_OW 1
36671: ST_TO_ADDR
// end ;
36672: LD_VAR 0 3
36676: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
36677: LD_INT 0
36679: PPUSH
// if not mc_bases [ base ] then
36680: LD_EXP 71
36684: PUSH
36685: LD_VAR 0 1
36689: ARRAY
36690: NOT
36691: IFFALSE 36695
// exit ;
36693: GO 36720
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
36695: LD_ADDR_EXP 92
36699: PUSH
36700: LD_EXP 92
36704: PPUSH
36705: LD_VAR 0 1
36709: PPUSH
36710: LD_VAR 0 2
36714: PPUSH
36715: CALL_OW 1
36719: ST_TO_ADDR
// end ;
36720: LD_VAR 0 3
36724: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
36725: LD_INT 0
36727: PPUSH
// if not mc_bases [ base ] then
36728: LD_EXP 71
36732: PUSH
36733: LD_VAR 0 1
36737: ARRAY
36738: NOT
36739: IFFALSE 36743
// exit ;
36741: GO 36780
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
36743: LD_ADDR_EXP 92
36747: PUSH
36748: LD_EXP 92
36752: PPUSH
36753: LD_VAR 0 1
36757: PPUSH
36758: LD_EXP 92
36762: PUSH
36763: LD_VAR 0 1
36767: ARRAY
36768: PUSH
36769: LD_VAR 0 2
36773: UNION
36774: PPUSH
36775: CALL_OW 1
36779: ST_TO_ADDR
// end ;
36780: LD_VAR 0 3
36784: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
36785: LD_INT 0
36787: PPUSH
// if not mc_bases [ base ] then
36788: LD_EXP 71
36792: PUSH
36793: LD_VAR 0 1
36797: ARRAY
36798: NOT
36799: IFFALSE 36803
// exit ;
36801: GO 36915
// mc_defender := Replace ( mc_defender , base , deflist ) ;
36803: LD_ADDR_EXP 93
36807: PUSH
36808: LD_EXP 93
36812: PPUSH
36813: LD_VAR 0 1
36817: PPUSH
36818: LD_VAR 0 2
36822: PPUSH
36823: CALL_OW 1
36827: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
36828: LD_ADDR_EXP 82
36832: PUSH
36833: LD_EXP 82
36837: PPUSH
36838: LD_VAR 0 1
36842: PPUSH
36843: LD_VAR 0 2
36847: PUSH
36848: LD_INT 0
36850: PLUS
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
36857: LD_ADDR_EXP 90
36861: PUSH
36862: LD_EXP 90
36866: PPUSH
36867: LD_VAR 0 1
36871: PPUSH
36872: LD_EXP 90
36876: PUSH
36877: LD_VAR 0 1
36881: ARRAY
36882: PUSH
36883: LD_EXP 93
36887: PUSH
36888: LD_VAR 0 1
36892: ARRAY
36893: PPUSH
36894: LD_INT 21
36896: PUSH
36897: LD_INT 2
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PPUSH
36904: CALL_OW 72
36908: UNION
36909: PPUSH
36910: CALL_OW 1
36914: ST_TO_ADDR
// end ;
36915: LD_VAR 0 3
36919: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
36920: LD_INT 0
36922: PPUSH
// if not mc_bases [ base ] then
36923: LD_EXP 71
36927: PUSH
36928: LD_VAR 0 1
36932: ARRAY
36933: NOT
36934: IFFALSE 36938
// exit ;
36936: GO 36963
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
36938: LD_ADDR_EXP 82
36942: PUSH
36943: LD_EXP 82
36947: PPUSH
36948: LD_VAR 0 1
36952: PPUSH
36953: LD_VAR 0 2
36957: PPUSH
36958: CALL_OW 1
36962: ST_TO_ADDR
// end ;
36963: LD_VAR 0 3
36967: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
36968: LD_INT 0
36970: PPUSH
36971: PPUSH
36972: PPUSH
36973: PPUSH
// if not mc_bases [ base ] then
36974: LD_EXP 71
36978: PUSH
36979: LD_VAR 0 1
36983: ARRAY
36984: NOT
36985: IFFALSE 36989
// exit ;
36987: GO 37054
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
36989: LD_ADDR_EXP 91
36993: PUSH
36994: LD_EXP 91
36998: PPUSH
36999: LD_VAR 0 1
37003: PUSH
37004: LD_EXP 91
37008: PUSH
37009: LD_VAR 0 1
37013: ARRAY
37014: PUSH
37015: LD_INT 1
37017: PLUS
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PPUSH
37023: LD_VAR 0 1
37027: PUSH
37028: LD_VAR 0 2
37032: PUSH
37033: LD_VAR 0 3
37037: PUSH
37038: LD_VAR 0 4
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: PPUSH
37049: CALL 49204 0 3
37053: ST_TO_ADDR
// end ;
37054: LD_VAR 0 5
37058: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
37059: LD_INT 0
37061: PPUSH
// if not mc_bases [ base ] then
37062: LD_EXP 71
37066: PUSH
37067: LD_VAR 0 1
37071: ARRAY
37072: NOT
37073: IFFALSE 37077
// exit ;
37075: GO 37102
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
37077: LD_ADDR_EXP 108
37081: PUSH
37082: LD_EXP 108
37086: PPUSH
37087: LD_VAR 0 1
37091: PPUSH
37092: LD_VAR 0 2
37096: PPUSH
37097: CALL_OW 1
37101: ST_TO_ADDR
// end ;
37102: LD_VAR 0 3
37106: RET
// export function MC_GetMinesField ( base ) ; begin
37107: LD_INT 0
37109: PPUSH
// result := mc_mines [ base ] ;
37110: LD_ADDR_VAR 0 2
37114: PUSH
37115: LD_EXP 84
37119: PUSH
37120: LD_VAR 0 1
37124: ARRAY
37125: ST_TO_ADDR
// end ;
37126: LD_VAR 0 2
37130: RET
// export function MC_GetProduceList ( base ) ; begin
37131: LD_INT 0
37133: PPUSH
// result := mc_produce [ base ] ;
37134: LD_ADDR_VAR 0 2
37138: PUSH
37139: LD_EXP 92
37143: PUSH
37144: LD_VAR 0 1
37148: ARRAY
37149: ST_TO_ADDR
// end ;
37150: LD_VAR 0 2
37154: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
37155: LD_INT 0
37157: PPUSH
37158: PPUSH
// if not mc_bases then
37159: LD_EXP 71
37163: NOT
37164: IFFALSE 37168
// exit ;
37166: GO 37233
// if mc_bases [ base ] then
37168: LD_EXP 71
37172: PUSH
37173: LD_VAR 0 1
37177: ARRAY
37178: IFFALSE 37233
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
37180: LD_ADDR_VAR 0 3
37184: PUSH
37185: LD_EXP 71
37189: PUSH
37190: LD_VAR 0 1
37194: ARRAY
37195: PPUSH
37196: LD_INT 30
37198: PUSH
37199: LD_VAR 0 2
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PPUSH
37208: CALL_OW 72
37212: ST_TO_ADDR
// if result then
37213: LD_VAR 0 3
37217: IFFALSE 37233
// result := result [ 1 ] ;
37219: LD_ADDR_VAR 0 3
37223: PUSH
37224: LD_VAR 0 3
37228: PUSH
37229: LD_INT 1
37231: ARRAY
37232: ST_TO_ADDR
// end ; end ;
37233: LD_VAR 0 3
37237: RET
// export function MC_SetTame ( base , area ) ; begin
37238: LD_INT 0
37240: PPUSH
// if not mc_bases or not base then
37241: LD_EXP 71
37245: NOT
37246: PUSH
37247: LD_VAR 0 1
37251: NOT
37252: OR
37253: IFFALSE 37257
// exit ;
37255: GO 37282
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
37257: LD_ADDR_EXP 99
37261: PUSH
37262: LD_EXP 99
37266: PPUSH
37267: LD_VAR 0 1
37271: PPUSH
37272: LD_VAR 0 2
37276: PPUSH
37277: CALL_OW 1
37281: ST_TO_ADDR
// end ;
37282: LD_VAR 0 3
37286: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
37287: LD_INT 0
37289: PPUSH
37290: PPUSH
// if not mc_bases or not base then
37291: LD_EXP 71
37295: NOT
37296: PUSH
37297: LD_VAR 0 1
37301: NOT
37302: OR
37303: IFFALSE 37307
// exit ;
37305: GO 37409
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
37307: LD_ADDR_VAR 0 4
37311: PUSH
37312: LD_EXP 71
37316: PUSH
37317: LD_VAR 0 1
37321: ARRAY
37322: PPUSH
37323: LD_INT 30
37325: PUSH
37326: LD_VAR 0 2
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PPUSH
37335: CALL_OW 72
37339: ST_TO_ADDR
// if not tmp then
37340: LD_VAR 0 4
37344: NOT
37345: IFFALSE 37349
// exit ;
37347: GO 37409
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
37349: LD_ADDR_EXP 103
37353: PUSH
37354: LD_EXP 103
37358: PPUSH
37359: LD_VAR 0 1
37363: PPUSH
37364: LD_EXP 103
37368: PUSH
37369: LD_VAR 0 1
37373: ARRAY
37374: PPUSH
37375: LD_EXP 103
37379: PUSH
37380: LD_VAR 0 1
37384: ARRAY
37385: PUSH
37386: LD_INT 1
37388: PLUS
37389: PPUSH
37390: LD_VAR 0 4
37394: PUSH
37395: LD_INT 1
37397: ARRAY
37398: PPUSH
37399: CALL_OW 2
37403: PPUSH
37404: CALL_OW 1
37408: ST_TO_ADDR
// end ;
37409: LD_VAR 0 3
37413: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
37414: LD_INT 0
37416: PPUSH
37417: PPUSH
// if not mc_bases or not base or not kinds then
37418: LD_EXP 71
37422: NOT
37423: PUSH
37424: LD_VAR 0 1
37428: NOT
37429: OR
37430: PUSH
37431: LD_VAR 0 2
37435: NOT
37436: OR
37437: IFFALSE 37441
// exit ;
37439: GO 37502
// for i in kinds do
37441: LD_ADDR_VAR 0 4
37445: PUSH
37446: LD_VAR 0 2
37450: PUSH
37451: FOR_IN
37452: IFFALSE 37500
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
37454: LD_ADDR_EXP 105
37458: PUSH
37459: LD_EXP 105
37463: PPUSH
37464: LD_VAR 0 1
37468: PUSH
37469: LD_EXP 105
37473: PUSH
37474: LD_VAR 0 1
37478: ARRAY
37479: PUSH
37480: LD_INT 1
37482: PLUS
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PPUSH
37488: LD_VAR 0 4
37492: PPUSH
37493: CALL 49204 0 3
37497: ST_TO_ADDR
37498: GO 37451
37500: POP
37501: POP
// end ;
37502: LD_VAR 0 3
37506: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
37507: LD_INT 0
37509: PPUSH
// if not mc_bases or not base or not areas then
37510: LD_EXP 71
37514: NOT
37515: PUSH
37516: LD_VAR 0 1
37520: NOT
37521: OR
37522: PUSH
37523: LD_VAR 0 2
37527: NOT
37528: OR
37529: IFFALSE 37533
// exit ;
37531: GO 37558
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
37533: LD_ADDR_EXP 89
37537: PUSH
37538: LD_EXP 89
37542: PPUSH
37543: LD_VAR 0 1
37547: PPUSH
37548: LD_VAR 0 2
37552: PPUSH
37553: CALL_OW 1
37557: ST_TO_ADDR
// end ;
37558: LD_VAR 0 3
37562: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
37563: LD_INT 0
37565: PPUSH
// if not mc_bases or not base or not teleports_exit then
37566: LD_EXP 71
37570: NOT
37571: PUSH
37572: LD_VAR 0 1
37576: NOT
37577: OR
37578: PUSH
37579: LD_VAR 0 2
37583: NOT
37584: OR
37585: IFFALSE 37589
// exit ;
37587: GO 37614
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
37589: LD_ADDR_EXP 106
37593: PUSH
37594: LD_EXP 106
37598: PPUSH
37599: LD_VAR 0 1
37603: PPUSH
37604: LD_VAR 0 2
37608: PPUSH
37609: CALL_OW 1
37613: ST_TO_ADDR
// end ;
37614: LD_VAR 0 3
37618: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
37619: LD_INT 0
37621: PPUSH
37622: PPUSH
37623: PPUSH
// if not mc_bases or not base or not ext_list then
37624: LD_EXP 71
37628: NOT
37629: PUSH
37630: LD_VAR 0 1
37634: NOT
37635: OR
37636: PUSH
37637: LD_VAR 0 5
37641: NOT
37642: OR
37643: IFFALSE 37647
// exit ;
37645: GO 37820
// tmp := GetFacExtXYD ( x , y , d ) ;
37647: LD_ADDR_VAR 0 8
37651: PUSH
37652: LD_VAR 0 2
37656: PPUSH
37657: LD_VAR 0 3
37661: PPUSH
37662: LD_VAR 0 4
37666: PPUSH
37667: CALL 82519 0 3
37671: ST_TO_ADDR
// if not tmp then
37672: LD_VAR 0 8
37676: NOT
37677: IFFALSE 37681
// exit ;
37679: GO 37820
// for i in tmp do
37681: LD_ADDR_VAR 0 7
37685: PUSH
37686: LD_VAR 0 8
37690: PUSH
37691: FOR_IN
37692: IFFALSE 37818
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
37694: LD_ADDR_EXP 76
37698: PUSH
37699: LD_EXP 76
37703: PPUSH
37704: LD_VAR 0 1
37708: PPUSH
37709: LD_EXP 76
37713: PUSH
37714: LD_VAR 0 1
37718: ARRAY
37719: PPUSH
37720: LD_EXP 76
37724: PUSH
37725: LD_VAR 0 1
37729: ARRAY
37730: PUSH
37731: LD_INT 1
37733: PLUS
37734: PPUSH
37735: LD_VAR 0 5
37739: PUSH
37740: LD_INT 1
37742: ARRAY
37743: PUSH
37744: LD_VAR 0 7
37748: PUSH
37749: LD_INT 1
37751: ARRAY
37752: PUSH
37753: LD_VAR 0 7
37757: PUSH
37758: LD_INT 2
37760: ARRAY
37761: PUSH
37762: LD_VAR 0 7
37766: PUSH
37767: LD_INT 3
37769: ARRAY
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: PPUSH
37777: CALL_OW 2
37781: PPUSH
37782: CALL_OW 1
37786: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
37787: LD_ADDR_VAR 0 5
37791: PUSH
37792: LD_VAR 0 5
37796: PPUSH
37797: LD_INT 1
37799: PPUSH
37800: CALL_OW 3
37804: ST_TO_ADDR
// if not ext_list then
37805: LD_VAR 0 5
37809: NOT
37810: IFFALSE 37816
// exit ;
37812: POP
37813: POP
37814: GO 37820
// end ;
37816: GO 37691
37818: POP
37819: POP
// end ;
37820: LD_VAR 0 6
37824: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
37825: LD_INT 0
37827: PPUSH
// if not mc_bases or not base or not weapon_list then
37828: LD_EXP 71
37832: NOT
37833: PUSH
37834: LD_VAR 0 1
37838: NOT
37839: OR
37840: PUSH
37841: LD_VAR 0 2
37845: NOT
37846: OR
37847: IFFALSE 37851
// exit ;
37849: GO 37876
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
37851: LD_ADDR_EXP 110
37855: PUSH
37856: LD_EXP 110
37860: PPUSH
37861: LD_VAR 0 1
37865: PPUSH
37866: LD_VAR 0 2
37870: PPUSH
37871: CALL_OW 1
37875: ST_TO_ADDR
// end ;
37876: LD_VAR 0 3
37880: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
37881: LD_INT 0
37883: PPUSH
// if not mc_bases or not base or not tech_list then
37884: LD_EXP 71
37888: NOT
37889: PUSH
37890: LD_VAR 0 1
37894: NOT
37895: OR
37896: PUSH
37897: LD_VAR 0 2
37901: NOT
37902: OR
37903: IFFALSE 37907
// exit ;
37905: GO 37932
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
37907: LD_ADDR_EXP 98
37911: PUSH
37912: LD_EXP 98
37916: PPUSH
37917: LD_VAR 0 1
37921: PPUSH
37922: LD_VAR 0 2
37926: PPUSH
37927: CALL_OW 1
37931: ST_TO_ADDR
// end ;
37932: LD_VAR 0 3
37936: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
37937: LD_INT 0
37939: PPUSH
// if not mc_bases or not parking_area or not base then
37940: LD_EXP 71
37944: NOT
37945: PUSH
37946: LD_VAR 0 2
37950: NOT
37951: OR
37952: PUSH
37953: LD_VAR 0 1
37957: NOT
37958: OR
37959: IFFALSE 37963
// exit ;
37961: GO 37988
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
37963: LD_ADDR_EXP 95
37967: PUSH
37968: LD_EXP 95
37972: PPUSH
37973: LD_VAR 0 1
37977: PPUSH
37978: LD_VAR 0 2
37982: PPUSH
37983: CALL_OW 1
37987: ST_TO_ADDR
// end ;
37988: LD_VAR 0 3
37992: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
37993: LD_INT 0
37995: PPUSH
// if not mc_bases or not base or not scan_area then
37996: LD_EXP 71
38000: NOT
38001: PUSH
38002: LD_VAR 0 1
38006: NOT
38007: OR
38008: PUSH
38009: LD_VAR 0 2
38013: NOT
38014: OR
38015: IFFALSE 38019
// exit ;
38017: GO 38044
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
38019: LD_ADDR_EXP 96
38023: PUSH
38024: LD_EXP 96
38028: PPUSH
38029: LD_VAR 0 1
38033: PPUSH
38034: LD_VAR 0 2
38038: PPUSH
38039: CALL_OW 1
38043: ST_TO_ADDR
// end ;
38044: LD_VAR 0 3
38048: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
38049: LD_INT 0
38051: PPUSH
38052: PPUSH
// if not mc_bases or not base then
38053: LD_EXP 71
38057: NOT
38058: PUSH
38059: LD_VAR 0 1
38063: NOT
38064: OR
38065: IFFALSE 38069
// exit ;
38067: GO 38133
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
38069: LD_ADDR_VAR 0 3
38073: PUSH
38074: LD_INT 1
38076: PUSH
38077: LD_INT 2
38079: PUSH
38080: LD_INT 3
38082: PUSH
38083: LD_INT 4
38085: PUSH
38086: LD_INT 11
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: LIST
38093: LIST
38094: LIST
38095: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
38096: LD_ADDR_EXP 98
38100: PUSH
38101: LD_EXP 98
38105: PPUSH
38106: LD_VAR 0 1
38110: PPUSH
38111: LD_EXP 98
38115: PUSH
38116: LD_VAR 0 1
38120: ARRAY
38121: PUSH
38122: LD_VAR 0 3
38126: DIFF
38127: PPUSH
38128: CALL_OW 1
38132: ST_TO_ADDR
// end ; end_of_file
38133: LD_VAR 0 2
38137: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
38138: LD_INT 0
38140: PPUSH
38141: PPUSH
38142: PPUSH
// if not mc_bases or not skirmish then
38143: LD_EXP 71
38147: NOT
38148: PUSH
38149: LD_EXP 69
38153: NOT
38154: OR
38155: IFFALSE 38159
// exit ;
38157: GO 38324
// for i = 1 to mc_bases do
38159: LD_ADDR_VAR 0 4
38163: PUSH
38164: DOUBLE
38165: LD_INT 1
38167: DEC
38168: ST_TO_ADDR
38169: LD_EXP 71
38173: PUSH
38174: FOR_TO
38175: IFFALSE 38322
// begin if sci in mc_bases [ i ] then
38177: LD_VAR 0 2
38181: PUSH
38182: LD_EXP 71
38186: PUSH
38187: LD_VAR 0 4
38191: ARRAY
38192: IN
38193: IFFALSE 38320
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
38195: LD_ADDR_EXP 100
38199: PUSH
38200: LD_EXP 100
38204: PPUSH
38205: LD_VAR 0 4
38209: PUSH
38210: LD_EXP 100
38214: PUSH
38215: LD_VAR 0 4
38219: ARRAY
38220: PUSH
38221: LD_INT 1
38223: PLUS
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PPUSH
38229: LD_VAR 0 1
38233: PPUSH
38234: CALL 49204 0 3
38238: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
38239: LD_ADDR_VAR 0 5
38243: PUSH
38244: LD_EXP 71
38248: PUSH
38249: LD_VAR 0 4
38253: ARRAY
38254: PPUSH
38255: LD_INT 2
38257: PUSH
38258: LD_INT 30
38260: PUSH
38261: LD_INT 0
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 30
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: LIST
38282: PPUSH
38283: CALL_OW 72
38287: PPUSH
38288: LD_VAR 0 1
38292: PPUSH
38293: CALL_OW 74
38297: ST_TO_ADDR
// if tmp then
38298: LD_VAR 0 5
38302: IFFALSE 38318
// ComStandNearbyBuilding ( ape , tmp ) ;
38304: LD_VAR 0 1
38308: PPUSH
38309: LD_VAR 0 5
38313: PPUSH
38314: CALL 43881 0 2
// break ;
38318: GO 38322
// end ; end ;
38320: GO 38174
38322: POP
38323: POP
// end ;
38324: LD_VAR 0 3
38328: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
38329: LD_INT 0
38331: PPUSH
38332: PPUSH
38333: PPUSH
// if not mc_bases or not skirmish then
38334: LD_EXP 71
38338: NOT
38339: PUSH
38340: LD_EXP 69
38344: NOT
38345: OR
38346: IFFALSE 38350
// exit ;
38348: GO 38439
// for i = 1 to mc_bases do
38350: LD_ADDR_VAR 0 4
38354: PUSH
38355: DOUBLE
38356: LD_INT 1
38358: DEC
38359: ST_TO_ADDR
38360: LD_EXP 71
38364: PUSH
38365: FOR_TO
38366: IFFALSE 38437
// begin if building in mc_busy_turret_list [ i ] then
38368: LD_VAR 0 1
38372: PUSH
38373: LD_EXP 81
38377: PUSH
38378: LD_VAR 0 4
38382: ARRAY
38383: IN
38384: IFFALSE 38435
// begin tmp := mc_busy_turret_list [ i ] diff building ;
38386: LD_ADDR_VAR 0 5
38390: PUSH
38391: LD_EXP 81
38395: PUSH
38396: LD_VAR 0 4
38400: ARRAY
38401: PUSH
38402: LD_VAR 0 1
38406: DIFF
38407: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
38408: LD_ADDR_EXP 81
38412: PUSH
38413: LD_EXP 81
38417: PPUSH
38418: LD_VAR 0 4
38422: PPUSH
38423: LD_VAR 0 5
38427: PPUSH
38428: CALL_OW 1
38432: ST_TO_ADDR
// break ;
38433: GO 38437
// end ; end ;
38435: GO 38365
38437: POP
38438: POP
// end ;
38439: LD_VAR 0 3
38443: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
38444: LD_INT 0
38446: PPUSH
38447: PPUSH
38448: PPUSH
// if not mc_bases or not skirmish then
38449: LD_EXP 71
38453: NOT
38454: PUSH
38455: LD_EXP 69
38459: NOT
38460: OR
38461: IFFALSE 38465
// exit ;
38463: GO 38664
// for i = 1 to mc_bases do
38465: LD_ADDR_VAR 0 5
38469: PUSH
38470: DOUBLE
38471: LD_INT 1
38473: DEC
38474: ST_TO_ADDR
38475: LD_EXP 71
38479: PUSH
38480: FOR_TO
38481: IFFALSE 38662
// if building in mc_bases [ i ] then
38483: LD_VAR 0 1
38487: PUSH
38488: LD_EXP 71
38492: PUSH
38493: LD_VAR 0 5
38497: ARRAY
38498: IN
38499: IFFALSE 38660
// begin tmp := mc_bases [ i ] diff building ;
38501: LD_ADDR_VAR 0 6
38505: PUSH
38506: LD_EXP 71
38510: PUSH
38511: LD_VAR 0 5
38515: ARRAY
38516: PUSH
38517: LD_VAR 0 1
38521: DIFF
38522: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
38523: LD_ADDR_EXP 71
38527: PUSH
38528: LD_EXP 71
38532: PPUSH
38533: LD_VAR 0 5
38537: PPUSH
38538: LD_VAR 0 6
38542: PPUSH
38543: CALL_OW 1
38547: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
38548: LD_VAR 0 1
38552: PUSH
38553: LD_EXP 79
38557: PUSH
38558: LD_VAR 0 5
38562: ARRAY
38563: IN
38564: IFFALSE 38603
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
38566: LD_ADDR_EXP 79
38570: PUSH
38571: LD_EXP 79
38575: PPUSH
38576: LD_VAR 0 5
38580: PPUSH
38581: LD_EXP 79
38585: PUSH
38586: LD_VAR 0 5
38590: ARRAY
38591: PUSH
38592: LD_VAR 0 1
38596: DIFF
38597: PPUSH
38598: CALL_OW 1
38602: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
38603: LD_VAR 0 1
38607: PUSH
38608: LD_EXP 80
38612: PUSH
38613: LD_VAR 0 5
38617: ARRAY
38618: IN
38619: IFFALSE 38658
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
38621: LD_ADDR_EXP 80
38625: PUSH
38626: LD_EXP 80
38630: PPUSH
38631: LD_VAR 0 5
38635: PPUSH
38636: LD_EXP 80
38640: PUSH
38641: LD_VAR 0 5
38645: ARRAY
38646: PUSH
38647: LD_VAR 0 1
38651: DIFF
38652: PPUSH
38653: CALL_OW 1
38657: ST_TO_ADDR
// break ;
38658: GO 38662
// end ;
38660: GO 38480
38662: POP
38663: POP
// end ;
38664: LD_VAR 0 4
38668: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
38669: LD_INT 0
38671: PPUSH
38672: PPUSH
38673: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
38674: LD_EXP 71
38678: NOT
38679: PUSH
38680: LD_EXP 69
38684: NOT
38685: OR
38686: PUSH
38687: LD_VAR 0 3
38691: PUSH
38692: LD_EXP 97
38696: IN
38697: NOT
38698: OR
38699: IFFALSE 38703
// exit ;
38701: GO 38826
// for i = 1 to mc_vehicles do
38703: LD_ADDR_VAR 0 6
38707: PUSH
38708: DOUBLE
38709: LD_INT 1
38711: DEC
38712: ST_TO_ADDR
38713: LD_EXP 90
38717: PUSH
38718: FOR_TO
38719: IFFALSE 38824
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
38721: LD_VAR 0 2
38725: PUSH
38726: LD_EXP 90
38730: PUSH
38731: LD_VAR 0 6
38735: ARRAY
38736: IN
38737: PUSH
38738: LD_VAR 0 1
38742: PUSH
38743: LD_EXP 90
38747: PUSH
38748: LD_VAR 0 6
38752: ARRAY
38753: IN
38754: OR
38755: IFFALSE 38822
// begin tmp := mc_vehicles [ i ] diff old ;
38757: LD_ADDR_VAR 0 7
38761: PUSH
38762: LD_EXP 90
38766: PUSH
38767: LD_VAR 0 6
38771: ARRAY
38772: PUSH
38773: LD_VAR 0 2
38777: DIFF
38778: ST_TO_ADDR
// tmp := tmp diff new ;
38779: LD_ADDR_VAR 0 7
38783: PUSH
38784: LD_VAR 0 7
38788: PUSH
38789: LD_VAR 0 1
38793: DIFF
38794: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
38795: LD_ADDR_EXP 90
38799: PUSH
38800: LD_EXP 90
38804: PPUSH
38805: LD_VAR 0 6
38809: PPUSH
38810: LD_VAR 0 7
38814: PPUSH
38815: CALL_OW 1
38819: ST_TO_ADDR
// break ;
38820: GO 38824
// end ;
38822: GO 38718
38824: POP
38825: POP
// end ;
38826: LD_VAR 0 5
38830: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
38831: LD_INT 0
38833: PPUSH
38834: PPUSH
38835: PPUSH
38836: PPUSH
// if not mc_bases or not skirmish then
38837: LD_EXP 71
38841: NOT
38842: PUSH
38843: LD_EXP 69
38847: NOT
38848: OR
38849: IFFALSE 38853
// exit ;
38851: GO 39236
// side := GetSide ( vehicle ) ;
38853: LD_ADDR_VAR 0 5
38857: PUSH
38858: LD_VAR 0 1
38862: PPUSH
38863: CALL_OW 255
38867: ST_TO_ADDR
// for i = 1 to mc_bases do
38868: LD_ADDR_VAR 0 4
38872: PUSH
38873: DOUBLE
38874: LD_INT 1
38876: DEC
38877: ST_TO_ADDR
38878: LD_EXP 71
38882: PUSH
38883: FOR_TO
38884: IFFALSE 39234
// begin if factory in mc_bases [ i ] then
38886: LD_VAR 0 2
38890: PUSH
38891: LD_EXP 71
38895: PUSH
38896: LD_VAR 0 4
38900: ARRAY
38901: IN
38902: IFFALSE 39232
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
38904: LD_EXP 93
38908: PUSH
38909: LD_VAR 0 4
38913: ARRAY
38914: PUSH
38915: LD_EXP 82
38919: PUSH
38920: LD_VAR 0 4
38924: ARRAY
38925: LESS
38926: PUSH
38927: LD_VAR 0 1
38931: PPUSH
38932: CALL_OW 264
38936: PUSH
38937: LD_INT 31
38939: PUSH
38940: LD_INT 32
38942: PUSH
38943: LD_INT 51
38945: PUSH
38946: LD_EXP 65
38950: PUSH
38951: LD_INT 12
38953: PUSH
38954: LD_INT 30
38956: PUSH
38957: LD_EXP 64
38961: PUSH
38962: LD_INT 11
38964: PUSH
38965: LD_INT 53
38967: PUSH
38968: LD_INT 14
38970: PUSH
38971: LD_EXP 68
38975: PUSH
38976: LD_INT 29
38978: PUSH
38979: LD_EXP 66
38983: PUSH
38984: LD_INT 13
38986: PUSH
38987: LD_INT 52
38989: PUSH
38990: LD_INT 48
38992: PUSH
38993: LD_INT 8
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: IN
39015: NOT
39016: AND
39017: IFFALSE 39058
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
39019: LD_ADDR_EXP 93
39023: PUSH
39024: LD_EXP 93
39028: PPUSH
39029: LD_VAR 0 4
39033: PPUSH
39034: LD_EXP 93
39038: PUSH
39039: LD_VAR 0 4
39043: ARRAY
39044: PUSH
39045: LD_VAR 0 1
39049: ADD
39050: PPUSH
39051: CALL_OW 1
39055: ST_TO_ADDR
39056: GO 39102
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
39058: LD_ADDR_EXP 90
39062: PUSH
39063: LD_EXP 90
39067: PPUSH
39068: LD_VAR 0 4
39072: PUSH
39073: LD_EXP 90
39077: PUSH
39078: LD_VAR 0 4
39082: ARRAY
39083: PUSH
39084: LD_INT 1
39086: PLUS
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PPUSH
39092: LD_VAR 0 1
39096: PPUSH
39097: CALL 49204 0 3
39101: ST_TO_ADDR
// if not mc_scan [ i ] then
39102: LD_EXP 94
39106: PUSH
39107: LD_VAR 0 4
39111: ARRAY
39112: NOT
39113: IFFALSE 39232
// begin if GetControl ( vehicle ) = control_remote then
39115: LD_VAR 0 1
39119: PPUSH
39120: CALL_OW 263
39124: PUSH
39125: LD_INT 2
39127: EQUAL
39128: IFFALSE 39148
// repeat wait ( 0 0$1 ) ;
39130: LD_INT 35
39132: PPUSH
39133: CALL_OW 67
// until IsControledBy ( vehicle ) ;
39137: LD_VAR 0 1
39141: PPUSH
39142: CALL_OW 312
39146: IFFALSE 39130
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
39148: LD_VAR 0 1
39152: PPUSH
39153: LD_EXP 95
39157: PUSH
39158: LD_VAR 0 4
39162: ARRAY
39163: PPUSH
39164: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
39168: LD_VAR 0 1
39172: PPUSH
39173: CALL_OW 263
39177: PUSH
39178: LD_INT 1
39180: NONEQUAL
39181: IFFALSE 39185
// break ;
39183: GO 39234
// repeat wait ( 0 0$1 ) ;
39185: LD_INT 35
39187: PPUSH
39188: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
39192: LD_VAR 0 1
39196: PPUSH
39197: LD_EXP 95
39201: PUSH
39202: LD_VAR 0 4
39206: ARRAY
39207: PPUSH
39208: CALL_OW 308
39212: IFFALSE 39185
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
39214: LD_VAR 0 1
39218: PPUSH
39219: CALL_OW 311
39223: PPUSH
39224: CALL_OW 121
// exit ;
39228: POP
39229: POP
39230: GO 39236
// end ; end ; end ;
39232: GO 38883
39234: POP
39235: POP
// end ;
39236: LD_VAR 0 3
39240: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
39241: LD_INT 0
39243: PPUSH
39244: PPUSH
39245: PPUSH
39246: PPUSH
// if not mc_bases or not skirmish then
39247: LD_EXP 71
39251: NOT
39252: PUSH
39253: LD_EXP 69
39257: NOT
39258: OR
39259: IFFALSE 39263
// exit ;
39261: GO 39616
// repeat wait ( 0 0$1 ) ;
39263: LD_INT 35
39265: PPUSH
39266: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
39270: LD_VAR 0 2
39274: PPUSH
39275: LD_VAR 0 3
39279: PPUSH
39280: CALL_OW 284
39284: IFFALSE 39263
// if GetResourceTypeXY ( x , y ) = mat_artefact then
39286: LD_VAR 0 2
39290: PPUSH
39291: LD_VAR 0 3
39295: PPUSH
39296: CALL_OW 283
39300: PUSH
39301: LD_INT 4
39303: EQUAL
39304: IFFALSE 39308
// exit ;
39306: GO 39616
// for i = 1 to mc_bases do
39308: LD_ADDR_VAR 0 7
39312: PUSH
39313: DOUBLE
39314: LD_INT 1
39316: DEC
39317: ST_TO_ADDR
39318: LD_EXP 71
39322: PUSH
39323: FOR_TO
39324: IFFALSE 39614
// begin if mc_crates_area [ i ] then
39326: LD_EXP 89
39330: PUSH
39331: LD_VAR 0 7
39335: ARRAY
39336: IFFALSE 39447
// for j in mc_crates_area [ i ] do
39338: LD_ADDR_VAR 0 8
39342: PUSH
39343: LD_EXP 89
39347: PUSH
39348: LD_VAR 0 7
39352: ARRAY
39353: PUSH
39354: FOR_IN
39355: IFFALSE 39445
// if InArea ( x , y , j ) then
39357: LD_VAR 0 2
39361: PPUSH
39362: LD_VAR 0 3
39366: PPUSH
39367: LD_VAR 0 8
39371: PPUSH
39372: CALL_OW 309
39376: IFFALSE 39443
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
39378: LD_ADDR_EXP 87
39382: PUSH
39383: LD_EXP 87
39387: PPUSH
39388: LD_VAR 0 7
39392: PUSH
39393: LD_EXP 87
39397: PUSH
39398: LD_VAR 0 7
39402: ARRAY
39403: PUSH
39404: LD_INT 1
39406: PLUS
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PPUSH
39412: LD_VAR 0 4
39416: PUSH
39417: LD_VAR 0 2
39421: PUSH
39422: LD_VAR 0 3
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: LIST
39431: PPUSH
39432: CALL 49204 0 3
39436: ST_TO_ADDR
// exit ;
39437: POP
39438: POP
39439: POP
39440: POP
39441: GO 39616
// end ;
39443: GO 39354
39445: POP
39446: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39447: LD_ADDR_VAR 0 9
39451: PUSH
39452: LD_EXP 71
39456: PUSH
39457: LD_VAR 0 7
39461: ARRAY
39462: PPUSH
39463: LD_INT 2
39465: PUSH
39466: LD_INT 30
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: EMPTY
39473: LIST
39474: LIST
39475: PUSH
39476: LD_INT 30
39478: PUSH
39479: LD_INT 1
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: LIST
39490: PPUSH
39491: CALL_OW 72
39495: ST_TO_ADDR
// if not depot then
39496: LD_VAR 0 9
39500: NOT
39501: IFFALSE 39505
// continue ;
39503: GO 39323
// for j in depot do
39505: LD_ADDR_VAR 0 8
39509: PUSH
39510: LD_VAR 0 9
39514: PUSH
39515: FOR_IN
39516: IFFALSE 39610
// if GetDistUnitXY ( j , x , y ) < 30 then
39518: LD_VAR 0 8
39522: PPUSH
39523: LD_VAR 0 2
39527: PPUSH
39528: LD_VAR 0 3
39532: PPUSH
39533: CALL_OW 297
39537: PUSH
39538: LD_INT 30
39540: LESS
39541: IFFALSE 39608
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
39543: LD_ADDR_EXP 87
39547: PUSH
39548: LD_EXP 87
39552: PPUSH
39553: LD_VAR 0 7
39557: PUSH
39558: LD_EXP 87
39562: PUSH
39563: LD_VAR 0 7
39567: ARRAY
39568: PUSH
39569: LD_INT 1
39571: PLUS
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PPUSH
39577: LD_VAR 0 4
39581: PUSH
39582: LD_VAR 0 2
39586: PUSH
39587: LD_VAR 0 3
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: LIST
39596: PPUSH
39597: CALL 49204 0 3
39601: ST_TO_ADDR
// exit ;
39602: POP
39603: POP
39604: POP
39605: POP
39606: GO 39616
// end ;
39608: GO 39515
39610: POP
39611: POP
// end ;
39612: GO 39323
39614: POP
39615: POP
// end ;
39616: LD_VAR 0 6
39620: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
39621: LD_INT 0
39623: PPUSH
39624: PPUSH
39625: PPUSH
39626: PPUSH
// if not mc_bases or not skirmish then
39627: LD_EXP 71
39631: NOT
39632: PUSH
39633: LD_EXP 69
39637: NOT
39638: OR
39639: IFFALSE 39643
// exit ;
39641: GO 39920
// side := GetSide ( lab ) ;
39643: LD_ADDR_VAR 0 4
39647: PUSH
39648: LD_VAR 0 2
39652: PPUSH
39653: CALL_OW 255
39657: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
39658: LD_VAR 0 4
39662: PUSH
39663: LD_EXP 97
39667: IN
39668: NOT
39669: PUSH
39670: LD_EXP 98
39674: NOT
39675: OR
39676: PUSH
39677: LD_EXP 71
39681: NOT
39682: OR
39683: IFFALSE 39687
// exit ;
39685: GO 39920
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
39687: LD_ADDR_EXP 98
39691: PUSH
39692: LD_EXP 98
39696: PPUSH
39697: LD_VAR 0 4
39701: PPUSH
39702: LD_EXP 98
39706: PUSH
39707: LD_VAR 0 4
39711: ARRAY
39712: PUSH
39713: LD_VAR 0 1
39717: DIFF
39718: PPUSH
39719: CALL_OW 1
39723: ST_TO_ADDR
// for i = 1 to mc_bases do
39724: LD_ADDR_VAR 0 5
39728: PUSH
39729: DOUBLE
39730: LD_INT 1
39732: DEC
39733: ST_TO_ADDR
39734: LD_EXP 71
39738: PUSH
39739: FOR_TO
39740: IFFALSE 39918
// begin if lab in mc_bases [ i ] then
39742: LD_VAR 0 2
39746: PUSH
39747: LD_EXP 71
39751: PUSH
39752: LD_VAR 0 5
39756: ARRAY
39757: IN
39758: IFFALSE 39916
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
39760: LD_VAR 0 1
39764: PUSH
39765: LD_INT 11
39767: PUSH
39768: LD_INT 4
39770: PUSH
39771: LD_INT 3
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: LIST
39781: LIST
39782: IN
39783: PUSH
39784: LD_EXP 101
39788: PUSH
39789: LD_VAR 0 5
39793: ARRAY
39794: AND
39795: IFFALSE 39916
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
39797: LD_ADDR_VAR 0 6
39801: PUSH
39802: LD_EXP 101
39806: PUSH
39807: LD_VAR 0 5
39811: ARRAY
39812: PUSH
39813: LD_INT 1
39815: ARRAY
39816: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39817: LD_ADDR_EXP 101
39821: PUSH
39822: LD_EXP 101
39826: PPUSH
39827: LD_VAR 0 5
39831: PPUSH
39832: EMPTY
39833: PPUSH
39834: CALL_OW 1
39838: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
39839: LD_VAR 0 6
39843: PPUSH
39844: LD_INT 0
39846: PPUSH
39847: CALL_OW 109
// ComExitBuilding ( tmp ) ;
39851: LD_VAR 0 6
39855: PPUSH
39856: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
39860: LD_ADDR_EXP 100
39864: PUSH
39865: LD_EXP 100
39869: PPUSH
39870: LD_VAR 0 5
39874: PPUSH
39875: LD_EXP 100
39879: PUSH
39880: LD_VAR 0 5
39884: ARRAY
39885: PPUSH
39886: LD_INT 1
39888: PPUSH
39889: LD_VAR 0 6
39893: PPUSH
39894: CALL_OW 2
39898: PPUSH
39899: CALL_OW 1
39903: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
39904: LD_VAR 0 5
39908: PPUSH
39909: LD_INT 112
39911: PPUSH
39912: CALL 17847 0 2
// end ; end ; end ;
39916: GO 39739
39918: POP
39919: POP
// end ;
39920: LD_VAR 0 3
39924: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
39925: LD_INT 0
39927: PPUSH
39928: PPUSH
39929: PPUSH
39930: PPUSH
39931: PPUSH
39932: PPUSH
39933: PPUSH
39934: PPUSH
// if not mc_bases or not skirmish then
39935: LD_EXP 71
39939: NOT
39940: PUSH
39941: LD_EXP 69
39945: NOT
39946: OR
39947: IFFALSE 39951
// exit ;
39949: GO 40894
// for i = 1 to mc_bases do
39951: LD_ADDR_VAR 0 3
39955: PUSH
39956: DOUBLE
39957: LD_INT 1
39959: DEC
39960: ST_TO_ADDR
39961: LD_EXP 71
39965: PUSH
39966: FOR_TO
39967: IFFALSE 40892
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
39969: LD_VAR 0 1
39973: PUSH
39974: LD_EXP 71
39978: PUSH
39979: LD_VAR 0 3
39983: ARRAY
39984: IN
39985: PUSH
39986: LD_VAR 0 1
39990: PUSH
39991: LD_EXP 78
39995: PUSH
39996: LD_VAR 0 3
40000: ARRAY
40001: IN
40002: OR
40003: PUSH
40004: LD_VAR 0 1
40008: PUSH
40009: LD_EXP 90
40013: PUSH
40014: LD_VAR 0 3
40018: ARRAY
40019: IN
40020: OR
40021: PUSH
40022: LD_VAR 0 1
40026: PUSH
40027: LD_EXP 100
40031: PUSH
40032: LD_VAR 0 3
40036: ARRAY
40037: IN
40038: OR
40039: PUSH
40040: LD_VAR 0 1
40044: PUSH
40045: LD_EXP 101
40049: PUSH
40050: LD_VAR 0 3
40054: ARRAY
40055: IN
40056: OR
40057: IFFALSE 40890
// begin if un in mc_ape [ i ] then
40059: LD_VAR 0 1
40063: PUSH
40064: LD_EXP 100
40068: PUSH
40069: LD_VAR 0 3
40073: ARRAY
40074: IN
40075: IFFALSE 40114
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
40077: LD_ADDR_EXP 100
40081: PUSH
40082: LD_EXP 100
40086: PPUSH
40087: LD_VAR 0 3
40091: PPUSH
40092: LD_EXP 100
40096: PUSH
40097: LD_VAR 0 3
40101: ARRAY
40102: PUSH
40103: LD_VAR 0 1
40107: DIFF
40108: PPUSH
40109: CALL_OW 1
40113: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
40114: LD_VAR 0 1
40118: PUSH
40119: LD_EXP 101
40123: PUSH
40124: LD_VAR 0 3
40128: ARRAY
40129: IN
40130: IFFALSE 40154
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
40132: LD_ADDR_EXP 101
40136: PUSH
40137: LD_EXP 101
40141: PPUSH
40142: LD_VAR 0 3
40146: PPUSH
40147: EMPTY
40148: PPUSH
40149: CALL_OW 1
40153: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
40154: LD_VAR 0 1
40158: PPUSH
40159: CALL_OW 247
40163: PUSH
40164: LD_INT 2
40166: EQUAL
40167: PUSH
40168: LD_VAR 0 1
40172: PPUSH
40173: CALL_OW 110
40177: PUSH
40178: LD_INT 20
40180: EQUAL
40181: AND
40182: IFFALSE 40285
// begin fac := MC_GetBuilding ( i , b_factory ) ;
40184: LD_ADDR_VAR 0 8
40188: PUSH
40189: LD_VAR 0 3
40193: PPUSH
40194: LD_INT 3
40196: PPUSH
40197: CALL 37155 0 2
40201: ST_TO_ADDR
// if fac then
40202: LD_VAR 0 8
40206: IFFALSE 40285
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
40208: LD_ADDR_VAR 0 9
40212: PUSH
40213: LD_VAR 0 8
40217: PPUSH
40218: LD_VAR 0 1
40222: PPUSH
40223: CALL_OW 265
40227: PPUSH
40228: LD_VAR 0 1
40232: PPUSH
40233: CALL_OW 262
40237: PPUSH
40238: LD_VAR 0 1
40242: PPUSH
40243: CALL_OW 263
40247: PPUSH
40248: LD_VAR 0 1
40252: PPUSH
40253: CALL_OW 264
40257: PPUSH
40258: CALL 46804 0 5
40262: ST_TO_ADDR
// if components then
40263: LD_VAR 0 9
40267: IFFALSE 40283
// MC_InsertProduceList ( i , components ) ;
40269: LD_VAR 0 3
40273: PPUSH
40274: LD_VAR 0 9
40278: PPUSH
40279: CALL 36725 0 2
// break ;
40283: GO 40892
// end ; end ; if GetType ( un ) = unit_building then
40285: LD_VAR 0 1
40289: PPUSH
40290: CALL_OW 247
40294: PUSH
40295: LD_INT 3
40297: EQUAL
40298: IFFALSE 40613
// begin btype := GetBType ( un ) ;
40300: LD_ADDR_VAR 0 5
40304: PUSH
40305: LD_VAR 0 1
40309: PPUSH
40310: CALL_OW 266
40314: ST_TO_ADDR
// if btype = b_warehouse then
40315: LD_VAR 0 5
40319: PUSH
40320: LD_INT 1
40322: EQUAL
40323: IFFALSE 40341
// begin btype := b_depot ;
40325: LD_ADDR_VAR 0 5
40329: PUSH
40330: LD_INT 0
40332: ST_TO_ADDR
// pos := 1 ;
40333: LD_ADDR_VAR 0 6
40337: PUSH
40338: LD_INT 1
40340: ST_TO_ADDR
// end ; if btype = b_factory then
40341: LD_VAR 0 5
40345: PUSH
40346: LD_INT 3
40348: EQUAL
40349: IFFALSE 40367
// begin btype := b_workshop ;
40351: LD_ADDR_VAR 0 5
40355: PUSH
40356: LD_INT 2
40358: ST_TO_ADDR
// pos := 1 ;
40359: LD_ADDR_VAR 0 6
40363: PUSH
40364: LD_INT 1
40366: ST_TO_ADDR
// end ; if btype = b_barracks then
40367: LD_VAR 0 5
40371: PUSH
40372: LD_INT 5
40374: EQUAL
40375: IFFALSE 40385
// btype := b_armoury ;
40377: LD_ADDR_VAR 0 5
40381: PUSH
40382: LD_INT 4
40384: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
40385: LD_VAR 0 5
40389: PUSH
40390: LD_INT 7
40392: PUSH
40393: LD_INT 8
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: IN
40400: IFFALSE 40410
// btype := b_lab ;
40402: LD_ADDR_VAR 0 5
40406: PUSH
40407: LD_INT 6
40409: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
40410: LD_ADDR_EXP 76
40414: PUSH
40415: LD_EXP 76
40419: PPUSH
40420: LD_VAR 0 3
40424: PUSH
40425: LD_EXP 76
40429: PUSH
40430: LD_VAR 0 3
40434: ARRAY
40435: PUSH
40436: LD_INT 1
40438: PLUS
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PPUSH
40444: LD_VAR 0 5
40448: PUSH
40449: LD_VAR 0 1
40453: PPUSH
40454: CALL_OW 250
40458: PUSH
40459: LD_VAR 0 1
40463: PPUSH
40464: CALL_OW 251
40468: PUSH
40469: LD_VAR 0 1
40473: PPUSH
40474: CALL_OW 254
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: PPUSH
40485: CALL 49204 0 3
40489: ST_TO_ADDR
// if pos = 1 then
40490: LD_VAR 0 6
40494: PUSH
40495: LD_INT 1
40497: EQUAL
40498: IFFALSE 40613
// begin tmp := mc_build_list [ i ] ;
40500: LD_ADDR_VAR 0 7
40504: PUSH
40505: LD_EXP 76
40509: PUSH
40510: LD_VAR 0 3
40514: ARRAY
40515: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40516: LD_VAR 0 7
40520: PPUSH
40521: LD_INT 2
40523: PUSH
40524: LD_INT 30
40526: PUSH
40527: LD_INT 0
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 30
40536: PUSH
40537: LD_INT 1
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: LIST
40548: PPUSH
40549: CALL_OW 72
40553: IFFALSE 40563
// pos := 2 ;
40555: LD_ADDR_VAR 0 6
40559: PUSH
40560: LD_INT 2
40562: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
40563: LD_ADDR_VAR 0 7
40567: PUSH
40568: LD_VAR 0 7
40572: PPUSH
40573: LD_VAR 0 6
40577: PPUSH
40578: LD_VAR 0 7
40582: PPUSH
40583: CALL 49530 0 3
40587: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
40588: LD_ADDR_EXP 76
40592: PUSH
40593: LD_EXP 76
40597: PPUSH
40598: LD_VAR 0 3
40602: PPUSH
40603: LD_VAR 0 7
40607: PPUSH
40608: CALL_OW 1
40612: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
40613: LD_VAR 0 1
40617: PUSH
40618: LD_EXP 71
40622: PUSH
40623: LD_VAR 0 3
40627: ARRAY
40628: IN
40629: IFFALSE 40668
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
40631: LD_ADDR_EXP 71
40635: PUSH
40636: LD_EXP 71
40640: PPUSH
40641: LD_VAR 0 3
40645: PPUSH
40646: LD_EXP 71
40650: PUSH
40651: LD_VAR 0 3
40655: ARRAY
40656: PUSH
40657: LD_VAR 0 1
40661: DIFF
40662: PPUSH
40663: CALL_OW 1
40667: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
40668: LD_VAR 0 1
40672: PUSH
40673: LD_EXP 78
40677: PUSH
40678: LD_VAR 0 3
40682: ARRAY
40683: IN
40684: IFFALSE 40723
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
40686: LD_ADDR_EXP 78
40690: PUSH
40691: LD_EXP 78
40695: PPUSH
40696: LD_VAR 0 3
40700: PPUSH
40701: LD_EXP 78
40705: PUSH
40706: LD_VAR 0 3
40710: ARRAY
40711: PUSH
40712: LD_VAR 0 1
40716: DIFF
40717: PPUSH
40718: CALL_OW 1
40722: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
40723: LD_VAR 0 1
40727: PUSH
40728: LD_EXP 90
40732: PUSH
40733: LD_VAR 0 3
40737: ARRAY
40738: IN
40739: IFFALSE 40778
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
40741: LD_ADDR_EXP 90
40745: PUSH
40746: LD_EXP 90
40750: PPUSH
40751: LD_VAR 0 3
40755: PPUSH
40756: LD_EXP 90
40760: PUSH
40761: LD_VAR 0 3
40765: ARRAY
40766: PUSH
40767: LD_VAR 0 1
40771: DIFF
40772: PPUSH
40773: CALL_OW 1
40777: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
40778: LD_VAR 0 1
40782: PUSH
40783: LD_EXP 80
40787: PUSH
40788: LD_VAR 0 3
40792: ARRAY
40793: IN
40794: IFFALSE 40833
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
40796: LD_ADDR_EXP 80
40800: PUSH
40801: LD_EXP 80
40805: PPUSH
40806: LD_VAR 0 3
40810: PPUSH
40811: LD_EXP 80
40815: PUSH
40816: LD_VAR 0 3
40820: ARRAY
40821: PUSH
40822: LD_VAR 0 1
40826: DIFF
40827: PPUSH
40828: CALL_OW 1
40832: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
40833: LD_VAR 0 1
40837: PUSH
40838: LD_EXP 79
40842: PUSH
40843: LD_VAR 0 3
40847: ARRAY
40848: IN
40849: IFFALSE 40888
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
40851: LD_ADDR_EXP 79
40855: PUSH
40856: LD_EXP 79
40860: PPUSH
40861: LD_VAR 0 3
40865: PPUSH
40866: LD_EXP 79
40870: PUSH
40871: LD_VAR 0 3
40875: ARRAY
40876: PUSH
40877: LD_VAR 0 1
40881: DIFF
40882: PPUSH
40883: CALL_OW 1
40887: ST_TO_ADDR
// end ; break ;
40888: GO 40892
// end ;
40890: GO 39966
40892: POP
40893: POP
// end ;
40894: LD_VAR 0 2
40898: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
40899: LD_INT 0
40901: PPUSH
40902: PPUSH
40903: PPUSH
// if not mc_bases or not skirmish then
40904: LD_EXP 71
40908: NOT
40909: PUSH
40910: LD_EXP 69
40914: NOT
40915: OR
40916: IFFALSE 40920
// exit ;
40918: GO 41135
// for i = 1 to mc_bases do
40920: LD_ADDR_VAR 0 3
40924: PUSH
40925: DOUBLE
40926: LD_INT 1
40928: DEC
40929: ST_TO_ADDR
40930: LD_EXP 71
40934: PUSH
40935: FOR_TO
40936: IFFALSE 41133
// begin if building in mc_construct_list [ i ] then
40938: LD_VAR 0 1
40942: PUSH
40943: LD_EXP 78
40947: PUSH
40948: LD_VAR 0 3
40952: ARRAY
40953: IN
40954: IFFALSE 41131
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
40956: LD_ADDR_EXP 78
40960: PUSH
40961: LD_EXP 78
40965: PPUSH
40966: LD_VAR 0 3
40970: PPUSH
40971: LD_EXP 78
40975: PUSH
40976: LD_VAR 0 3
40980: ARRAY
40981: PUSH
40982: LD_VAR 0 1
40986: DIFF
40987: PPUSH
40988: CALL_OW 1
40992: ST_TO_ADDR
// if building in mc_lab [ i ] then
40993: LD_VAR 0 1
40997: PUSH
40998: LD_EXP 104
41002: PUSH
41003: LD_VAR 0 3
41007: ARRAY
41008: IN
41009: IFFALSE 41064
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
41011: LD_ADDR_EXP 105
41015: PUSH
41016: LD_EXP 105
41020: PPUSH
41021: LD_VAR 0 3
41025: PPUSH
41026: LD_EXP 105
41030: PUSH
41031: LD_VAR 0 3
41035: ARRAY
41036: PPUSH
41037: LD_INT 1
41039: PPUSH
41040: LD_EXP 105
41044: PUSH
41045: LD_VAR 0 3
41049: ARRAY
41050: PPUSH
41051: LD_INT 0
41053: PPUSH
41054: CALL 48622 0 4
41058: PPUSH
41059: CALL_OW 1
41063: ST_TO_ADDR
// if not building in mc_bases [ i ] then
41064: LD_VAR 0 1
41068: PUSH
41069: LD_EXP 71
41073: PUSH
41074: LD_VAR 0 3
41078: ARRAY
41079: IN
41080: NOT
41081: IFFALSE 41127
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
41083: LD_ADDR_EXP 71
41087: PUSH
41088: LD_EXP 71
41092: PPUSH
41093: LD_VAR 0 3
41097: PUSH
41098: LD_EXP 71
41102: PUSH
41103: LD_VAR 0 3
41107: ARRAY
41108: PUSH
41109: LD_INT 1
41111: PLUS
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PPUSH
41117: LD_VAR 0 1
41121: PPUSH
41122: CALL 49204 0 3
41126: ST_TO_ADDR
// exit ;
41127: POP
41128: POP
41129: GO 41135
// end ; end ;
41131: GO 40935
41133: POP
41134: POP
// end ;
41135: LD_VAR 0 2
41139: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
41140: LD_INT 0
41142: PPUSH
41143: PPUSH
41144: PPUSH
41145: PPUSH
41146: PPUSH
41147: PPUSH
41148: PPUSH
// if not mc_bases or not skirmish then
41149: LD_EXP 71
41153: NOT
41154: PUSH
41155: LD_EXP 69
41159: NOT
41160: OR
41161: IFFALSE 41165
// exit ;
41163: GO 41826
// for i = 1 to mc_bases do
41165: LD_ADDR_VAR 0 3
41169: PUSH
41170: DOUBLE
41171: LD_INT 1
41173: DEC
41174: ST_TO_ADDR
41175: LD_EXP 71
41179: PUSH
41180: FOR_TO
41181: IFFALSE 41824
// begin if building in mc_construct_list [ i ] then
41183: LD_VAR 0 1
41187: PUSH
41188: LD_EXP 78
41192: PUSH
41193: LD_VAR 0 3
41197: ARRAY
41198: IN
41199: IFFALSE 41822
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
41201: LD_ADDR_EXP 78
41205: PUSH
41206: LD_EXP 78
41210: PPUSH
41211: LD_VAR 0 3
41215: PPUSH
41216: LD_EXP 78
41220: PUSH
41221: LD_VAR 0 3
41225: ARRAY
41226: PUSH
41227: LD_VAR 0 1
41231: DIFF
41232: PPUSH
41233: CALL_OW 1
41237: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
41238: LD_ADDR_EXP 71
41242: PUSH
41243: LD_EXP 71
41247: PPUSH
41248: LD_VAR 0 3
41252: PUSH
41253: LD_EXP 71
41257: PUSH
41258: LD_VAR 0 3
41262: ARRAY
41263: PUSH
41264: LD_INT 1
41266: PLUS
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PPUSH
41272: LD_VAR 0 1
41276: PPUSH
41277: CALL 49204 0 3
41281: ST_TO_ADDR
// btype := GetBType ( building ) ;
41282: LD_ADDR_VAR 0 5
41286: PUSH
41287: LD_VAR 0 1
41291: PPUSH
41292: CALL_OW 266
41296: ST_TO_ADDR
// side := GetSide ( building ) ;
41297: LD_ADDR_VAR 0 8
41301: PUSH
41302: LD_VAR 0 1
41306: PPUSH
41307: CALL_OW 255
41311: ST_TO_ADDR
// if btype = b_lab then
41312: LD_VAR 0 5
41316: PUSH
41317: LD_INT 6
41319: EQUAL
41320: IFFALSE 41370
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
41322: LD_ADDR_EXP 104
41326: PUSH
41327: LD_EXP 104
41331: PPUSH
41332: LD_VAR 0 3
41336: PUSH
41337: LD_EXP 104
41341: PUSH
41342: LD_VAR 0 3
41346: ARRAY
41347: PUSH
41348: LD_INT 1
41350: PLUS
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PPUSH
41356: LD_VAR 0 1
41360: PPUSH
41361: CALL 49204 0 3
41365: ST_TO_ADDR
// exit ;
41366: POP
41367: POP
41368: GO 41826
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
41370: LD_VAR 0 5
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 4
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: LIST
41388: IN
41389: IFFALSE 41513
// begin if btype = b_armoury then
41391: LD_VAR 0 5
41395: PUSH
41396: LD_INT 4
41398: EQUAL
41399: IFFALSE 41409
// btype := b_barracks ;
41401: LD_ADDR_VAR 0 5
41405: PUSH
41406: LD_INT 5
41408: ST_TO_ADDR
// if btype = b_depot then
41409: LD_VAR 0 5
41413: PUSH
41414: LD_INT 0
41416: EQUAL
41417: IFFALSE 41427
// btype := b_warehouse ;
41419: LD_ADDR_VAR 0 5
41423: PUSH
41424: LD_INT 1
41426: ST_TO_ADDR
// if btype = b_workshop then
41427: LD_VAR 0 5
41431: PUSH
41432: LD_INT 2
41434: EQUAL
41435: IFFALSE 41445
// btype := b_factory ;
41437: LD_ADDR_VAR 0 5
41441: PUSH
41442: LD_INT 3
41444: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
41445: LD_VAR 0 5
41449: PPUSH
41450: LD_VAR 0 8
41454: PPUSH
41455: CALL_OW 323
41459: PUSH
41460: LD_INT 1
41462: EQUAL
41463: IFFALSE 41509
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
41465: LD_ADDR_EXP 103
41469: PUSH
41470: LD_EXP 103
41474: PPUSH
41475: LD_VAR 0 3
41479: PUSH
41480: LD_EXP 103
41484: PUSH
41485: LD_VAR 0 3
41489: ARRAY
41490: PUSH
41491: LD_INT 1
41493: PLUS
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PPUSH
41499: LD_VAR 0 1
41503: PPUSH
41504: CALL 49204 0 3
41508: ST_TO_ADDR
// exit ;
41509: POP
41510: POP
41511: GO 41826
// end ; if btype in [ b_bunker , b_turret ] then
41513: LD_VAR 0 5
41517: PUSH
41518: LD_INT 32
41520: PUSH
41521: LD_INT 33
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: IN
41528: IFFALSE 41818
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
41530: LD_ADDR_EXP 79
41534: PUSH
41535: LD_EXP 79
41539: PPUSH
41540: LD_VAR 0 3
41544: PUSH
41545: LD_EXP 79
41549: PUSH
41550: LD_VAR 0 3
41554: ARRAY
41555: PUSH
41556: LD_INT 1
41558: PLUS
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PPUSH
41564: LD_VAR 0 1
41568: PPUSH
41569: CALL 49204 0 3
41573: ST_TO_ADDR
// if btype = b_bunker then
41574: LD_VAR 0 5
41578: PUSH
41579: LD_INT 32
41581: EQUAL
41582: IFFALSE 41818
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
41584: LD_ADDR_EXP 80
41588: PUSH
41589: LD_EXP 80
41593: PPUSH
41594: LD_VAR 0 3
41598: PUSH
41599: LD_EXP 80
41603: PUSH
41604: LD_VAR 0 3
41608: ARRAY
41609: PUSH
41610: LD_INT 1
41612: PLUS
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PPUSH
41618: LD_VAR 0 1
41622: PPUSH
41623: CALL 49204 0 3
41627: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
41628: LD_ADDR_VAR 0 6
41632: PUSH
41633: LD_EXP 71
41637: PUSH
41638: LD_VAR 0 3
41642: ARRAY
41643: PPUSH
41644: LD_INT 25
41646: PUSH
41647: LD_INT 1
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 3
41656: PUSH
41657: LD_INT 54
41659: PUSH
41660: EMPTY
41661: LIST
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PPUSH
41671: CALL_OW 72
41675: ST_TO_ADDR
// if tmp then
41676: LD_VAR 0 6
41680: IFFALSE 41686
// exit ;
41682: POP
41683: POP
41684: GO 41826
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41686: LD_ADDR_VAR 0 6
41690: PUSH
41691: LD_EXP 71
41695: PUSH
41696: LD_VAR 0 3
41700: ARRAY
41701: PPUSH
41702: LD_INT 2
41704: PUSH
41705: LD_INT 30
41707: PUSH
41708: LD_INT 4
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 30
41717: PUSH
41718: LD_INT 5
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: LIST
41729: PPUSH
41730: CALL_OW 72
41734: ST_TO_ADDR
// if not tmp then
41735: LD_VAR 0 6
41739: NOT
41740: IFFALSE 41746
// exit ;
41742: POP
41743: POP
41744: GO 41826
// for j in tmp do
41746: LD_ADDR_VAR 0 4
41750: PUSH
41751: LD_VAR 0 6
41755: PUSH
41756: FOR_IN
41757: IFFALSE 41816
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
41759: LD_ADDR_VAR 0 7
41763: PUSH
41764: LD_VAR 0 4
41768: PPUSH
41769: CALL_OW 313
41773: PPUSH
41774: LD_INT 25
41776: PUSH
41777: LD_INT 1
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PPUSH
41784: CALL_OW 72
41788: ST_TO_ADDR
// if units then
41789: LD_VAR 0 7
41793: IFFALSE 41814
// begin ComExitBuilding ( units [ 1 ] ) ;
41795: LD_VAR 0 7
41799: PUSH
41800: LD_INT 1
41802: ARRAY
41803: PPUSH
41804: CALL_OW 122
// exit ;
41808: POP
41809: POP
41810: POP
41811: POP
41812: GO 41826
// end ; end ;
41814: GO 41756
41816: POP
41817: POP
// end ; end ; exit ;
41818: POP
41819: POP
41820: GO 41826
// end ; end ;
41822: GO 41180
41824: POP
41825: POP
// end ;
41826: LD_VAR 0 2
41830: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
41831: LD_INT 0
41833: PPUSH
41834: PPUSH
41835: PPUSH
41836: PPUSH
41837: PPUSH
41838: PPUSH
41839: PPUSH
// if not mc_bases or not skirmish then
41840: LD_EXP 71
41844: NOT
41845: PUSH
41846: LD_EXP 69
41850: NOT
41851: OR
41852: IFFALSE 41856
// exit ;
41854: GO 42087
// btype := GetBType ( building ) ;
41856: LD_ADDR_VAR 0 6
41860: PUSH
41861: LD_VAR 0 1
41865: PPUSH
41866: CALL_OW 266
41870: ST_TO_ADDR
// x := GetX ( building ) ;
41871: LD_ADDR_VAR 0 7
41875: PUSH
41876: LD_VAR 0 1
41880: PPUSH
41881: CALL_OW 250
41885: ST_TO_ADDR
// y := GetY ( building ) ;
41886: LD_ADDR_VAR 0 8
41890: PUSH
41891: LD_VAR 0 1
41895: PPUSH
41896: CALL_OW 251
41900: ST_TO_ADDR
// d := GetDir ( building ) ;
41901: LD_ADDR_VAR 0 9
41905: PUSH
41906: LD_VAR 0 1
41910: PPUSH
41911: CALL_OW 254
41915: ST_TO_ADDR
// for i = 1 to mc_bases do
41916: LD_ADDR_VAR 0 4
41920: PUSH
41921: DOUBLE
41922: LD_INT 1
41924: DEC
41925: ST_TO_ADDR
41926: LD_EXP 71
41930: PUSH
41931: FOR_TO
41932: IFFALSE 42085
// begin if not mc_build_list [ i ] then
41934: LD_EXP 76
41938: PUSH
41939: LD_VAR 0 4
41943: ARRAY
41944: NOT
41945: IFFALSE 41949
// continue ;
41947: GO 41931
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
41949: LD_VAR 0 6
41953: PUSH
41954: LD_VAR 0 7
41958: PUSH
41959: LD_VAR 0 8
41963: PUSH
41964: LD_VAR 0 9
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: LIST
41973: LIST
41974: PPUSH
41975: LD_EXP 76
41979: PUSH
41980: LD_VAR 0 4
41984: ARRAY
41985: PUSH
41986: LD_INT 1
41988: ARRAY
41989: PPUSH
41990: CALL 55373 0 2
41994: IFFALSE 42083
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
41996: LD_ADDR_EXP 76
42000: PUSH
42001: LD_EXP 76
42005: PPUSH
42006: LD_VAR 0 4
42010: PPUSH
42011: LD_EXP 76
42015: PUSH
42016: LD_VAR 0 4
42020: ARRAY
42021: PPUSH
42022: LD_INT 1
42024: PPUSH
42025: CALL_OW 3
42029: PPUSH
42030: CALL_OW 1
42034: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
42035: LD_ADDR_EXP 78
42039: PUSH
42040: LD_EXP 78
42044: PPUSH
42045: LD_VAR 0 4
42049: PUSH
42050: LD_EXP 78
42054: PUSH
42055: LD_VAR 0 4
42059: ARRAY
42060: PUSH
42061: LD_INT 1
42063: PLUS
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PPUSH
42069: LD_VAR 0 1
42073: PPUSH
42074: CALL 49204 0 3
42078: ST_TO_ADDR
// exit ;
42079: POP
42080: POP
42081: GO 42087
// end ; end ;
42083: GO 41931
42085: POP
42086: POP
// end ;
42087: LD_VAR 0 3
42091: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
42092: LD_INT 0
42094: PPUSH
42095: PPUSH
42096: PPUSH
// if not mc_bases or not skirmish then
42097: LD_EXP 71
42101: NOT
42102: PUSH
42103: LD_EXP 69
42107: NOT
42108: OR
42109: IFFALSE 42113
// exit ;
42111: GO 42303
// for i = 1 to mc_bases do
42113: LD_ADDR_VAR 0 4
42117: PUSH
42118: DOUBLE
42119: LD_INT 1
42121: DEC
42122: ST_TO_ADDR
42123: LD_EXP 71
42127: PUSH
42128: FOR_TO
42129: IFFALSE 42216
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
42131: LD_VAR 0 1
42135: PUSH
42136: LD_EXP 79
42140: PUSH
42141: LD_VAR 0 4
42145: ARRAY
42146: IN
42147: PUSH
42148: LD_VAR 0 1
42152: PUSH
42153: LD_EXP 80
42157: PUSH
42158: LD_VAR 0 4
42162: ARRAY
42163: IN
42164: NOT
42165: AND
42166: IFFALSE 42214
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
42168: LD_ADDR_EXP 80
42172: PUSH
42173: LD_EXP 80
42177: PPUSH
42178: LD_VAR 0 4
42182: PUSH
42183: LD_EXP 80
42187: PUSH
42188: LD_VAR 0 4
42192: ARRAY
42193: PUSH
42194: LD_INT 1
42196: PLUS
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PPUSH
42202: LD_VAR 0 1
42206: PPUSH
42207: CALL 49204 0 3
42211: ST_TO_ADDR
// break ;
42212: GO 42216
// end ; end ;
42214: GO 42128
42216: POP
42217: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
42218: LD_VAR 0 1
42222: PPUSH
42223: CALL_OW 257
42227: PUSH
42228: LD_EXP 97
42232: IN
42233: PUSH
42234: LD_VAR 0 1
42238: PPUSH
42239: CALL_OW 266
42243: PUSH
42244: LD_INT 5
42246: EQUAL
42247: AND
42248: PUSH
42249: LD_VAR 0 2
42253: PPUSH
42254: CALL_OW 110
42258: PUSH
42259: LD_INT 18
42261: NONEQUAL
42262: AND
42263: IFFALSE 42303
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
42265: LD_VAR 0 2
42269: PPUSH
42270: CALL_OW 257
42274: PUSH
42275: LD_INT 5
42277: PUSH
42278: LD_INT 8
42280: PUSH
42281: LD_INT 9
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: LIST
42288: IN
42289: IFFALSE 42303
// SetClass ( unit , 1 ) ;
42291: LD_VAR 0 2
42295: PPUSH
42296: LD_INT 1
42298: PPUSH
42299: CALL_OW 336
// end ;
42303: LD_VAR 0 3
42307: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
42308: LD_INT 0
42310: PPUSH
42311: PPUSH
// if not mc_bases or not skirmish then
42312: LD_EXP 71
42316: NOT
42317: PUSH
42318: LD_EXP 69
42322: NOT
42323: OR
42324: IFFALSE 42328
// exit ;
42326: GO 42444
// if GetLives ( abandoned_vehicle ) > 250 then
42328: LD_VAR 0 2
42332: PPUSH
42333: CALL_OW 256
42337: PUSH
42338: LD_INT 250
42340: GREATER
42341: IFFALSE 42345
// exit ;
42343: GO 42444
// for i = 1 to mc_bases do
42345: LD_ADDR_VAR 0 6
42349: PUSH
42350: DOUBLE
42351: LD_INT 1
42353: DEC
42354: ST_TO_ADDR
42355: LD_EXP 71
42359: PUSH
42360: FOR_TO
42361: IFFALSE 42442
// begin if driver in mc_bases [ i ] then
42363: LD_VAR 0 1
42367: PUSH
42368: LD_EXP 71
42372: PUSH
42373: LD_VAR 0 6
42377: ARRAY
42378: IN
42379: IFFALSE 42440
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
42381: LD_VAR 0 1
42385: PPUSH
42386: LD_EXP 71
42390: PUSH
42391: LD_VAR 0 6
42395: ARRAY
42396: PPUSH
42397: LD_INT 2
42399: PUSH
42400: LD_INT 30
42402: PUSH
42403: LD_INT 0
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 30
42412: PUSH
42413: LD_INT 1
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: LIST
42424: PPUSH
42425: CALL_OW 72
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PPUSH
42434: CALL_OW 112
// break ;
42438: GO 42442
// end ; end ;
42440: GO 42360
42442: POP
42443: POP
// end ; end_of_file
42444: LD_VAR 0 5
42448: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
42449: LD_INT 0
42451: PPUSH
42452: PPUSH
// if exist_mode then
42453: LD_VAR 0 2
42457: IFFALSE 42482
// unit := CreateCharacter ( prefix & ident ) else
42459: LD_ADDR_VAR 0 5
42463: PUSH
42464: LD_VAR 0 3
42468: PUSH
42469: LD_VAR 0 1
42473: STR
42474: PPUSH
42475: CALL_OW 34
42479: ST_TO_ADDR
42480: GO 42497
// unit := NewCharacter ( ident ) ;
42482: LD_ADDR_VAR 0 5
42486: PUSH
42487: LD_VAR 0 1
42491: PPUSH
42492: CALL_OW 25
42496: ST_TO_ADDR
// result := unit ;
42497: LD_ADDR_VAR 0 4
42501: PUSH
42502: LD_VAR 0 5
42506: ST_TO_ADDR
// end ;
42507: LD_VAR 0 4
42511: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
42512: LD_INT 0
42514: PPUSH
42515: PPUSH
// if not side or not nation then
42516: LD_VAR 0 1
42520: NOT
42521: PUSH
42522: LD_VAR 0 2
42526: NOT
42527: OR
42528: IFFALSE 42532
// exit ;
42530: GO 43168
// case nation of nation_american :
42532: LD_VAR 0 2
42536: PUSH
42537: LD_INT 1
42539: DOUBLE
42540: EQUAL
42541: IFTRUE 42545
42543: GO 42715
42545: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
42546: LD_ADDR_VAR 0 4
42550: PUSH
42551: LD_INT 35
42553: PUSH
42554: LD_INT 45
42556: PUSH
42557: LD_INT 46
42559: PUSH
42560: LD_INT 47
42562: PUSH
42563: LD_INT 1
42565: PUSH
42566: LD_INT 2
42568: PUSH
42569: LD_INT 6
42571: PUSH
42572: LD_INT 15
42574: PUSH
42575: LD_INT 16
42577: PUSH
42578: LD_INT 7
42580: PUSH
42581: LD_INT 12
42583: PUSH
42584: LD_INT 13
42586: PUSH
42587: LD_INT 10
42589: PUSH
42590: LD_INT 14
42592: PUSH
42593: LD_INT 20
42595: PUSH
42596: LD_INT 21
42598: PUSH
42599: LD_INT 22
42601: PUSH
42602: LD_INT 25
42604: PUSH
42605: LD_INT 32
42607: PUSH
42608: LD_INT 27
42610: PUSH
42611: LD_INT 36
42613: PUSH
42614: LD_INT 69
42616: PUSH
42617: LD_INT 39
42619: PUSH
42620: LD_INT 34
42622: PUSH
42623: LD_INT 40
42625: PUSH
42626: LD_INT 48
42628: PUSH
42629: LD_INT 49
42631: PUSH
42632: LD_INT 50
42634: PUSH
42635: LD_INT 51
42637: PUSH
42638: LD_INT 52
42640: PUSH
42641: LD_INT 53
42643: PUSH
42644: LD_INT 54
42646: PUSH
42647: LD_INT 55
42649: PUSH
42650: LD_INT 56
42652: PUSH
42653: LD_INT 57
42655: PUSH
42656: LD_INT 58
42658: PUSH
42659: LD_INT 59
42661: PUSH
42662: LD_INT 60
42664: PUSH
42665: LD_INT 61
42667: PUSH
42668: LD_INT 62
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: LIST
42675: LIST
42676: LIST
42677: LIST
42678: LIST
42679: LIST
42680: LIST
42681: LIST
42682: LIST
42683: LIST
42684: LIST
42685: LIST
42686: LIST
42687: LIST
42688: LIST
42689: LIST
42690: LIST
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: LIST
42707: LIST
42708: LIST
42709: LIST
42710: LIST
42711: LIST
42712: ST_TO_ADDR
42713: GO 43092
42715: LD_INT 2
42717: DOUBLE
42718: EQUAL
42719: IFTRUE 42723
42721: GO 42901
42723: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
42724: LD_ADDR_VAR 0 4
42728: PUSH
42729: LD_INT 35
42731: PUSH
42732: LD_INT 45
42734: PUSH
42735: LD_INT 46
42737: PUSH
42738: LD_INT 47
42740: PUSH
42741: LD_INT 70
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: LD_INT 11
42749: PUSH
42750: LD_INT 3
42752: PUSH
42753: LD_INT 4
42755: PUSH
42756: LD_INT 5
42758: PUSH
42759: LD_INT 6
42761: PUSH
42762: LD_INT 15
42764: PUSH
42765: LD_INT 18
42767: PUSH
42768: LD_INT 7
42770: PUSH
42771: LD_INT 17
42773: PUSH
42774: LD_INT 8
42776: PUSH
42777: LD_INT 20
42779: PUSH
42780: LD_INT 21
42782: PUSH
42783: LD_INT 22
42785: PUSH
42786: LD_INT 72
42788: PUSH
42789: LD_INT 26
42791: PUSH
42792: LD_INT 69
42794: PUSH
42795: LD_INT 39
42797: PUSH
42798: LD_INT 40
42800: PUSH
42801: LD_INT 41
42803: PUSH
42804: LD_INT 42
42806: PUSH
42807: LD_INT 43
42809: PUSH
42810: LD_INT 48
42812: PUSH
42813: LD_INT 49
42815: PUSH
42816: LD_INT 50
42818: PUSH
42819: LD_INT 51
42821: PUSH
42822: LD_INT 52
42824: PUSH
42825: LD_INT 53
42827: PUSH
42828: LD_INT 54
42830: PUSH
42831: LD_INT 55
42833: PUSH
42834: LD_INT 56
42836: PUSH
42837: LD_INT 60
42839: PUSH
42840: LD_INT 61
42842: PUSH
42843: LD_INT 62
42845: PUSH
42846: LD_INT 66
42848: PUSH
42849: LD_INT 67
42851: PUSH
42852: LD_INT 68
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: LIST
42871: LIST
42872: LIST
42873: LIST
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: ST_TO_ADDR
42899: GO 43092
42901: LD_INT 3
42903: DOUBLE
42904: EQUAL
42905: IFTRUE 42909
42907: GO 43091
42909: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
42910: LD_ADDR_VAR 0 4
42914: PUSH
42915: LD_INT 46
42917: PUSH
42918: LD_INT 47
42920: PUSH
42921: LD_INT 1
42923: PUSH
42924: LD_INT 2
42926: PUSH
42927: LD_INT 11
42929: PUSH
42930: LD_INT 9
42932: PUSH
42933: LD_INT 20
42935: PUSH
42936: LD_INT 19
42938: PUSH
42939: LD_INT 21
42941: PUSH
42942: LD_INT 24
42944: PUSH
42945: LD_INT 22
42947: PUSH
42948: LD_INT 25
42950: PUSH
42951: LD_INT 28
42953: PUSH
42954: LD_INT 29
42956: PUSH
42957: LD_INT 30
42959: PUSH
42960: LD_INT 31
42962: PUSH
42963: LD_INT 37
42965: PUSH
42966: LD_INT 38
42968: PUSH
42969: LD_INT 32
42971: PUSH
42972: LD_INT 27
42974: PUSH
42975: LD_INT 33
42977: PUSH
42978: LD_INT 69
42980: PUSH
42981: LD_INT 39
42983: PUSH
42984: LD_INT 34
42986: PUSH
42987: LD_INT 40
42989: PUSH
42990: LD_INT 71
42992: PUSH
42993: LD_INT 23
42995: PUSH
42996: LD_INT 44
42998: PUSH
42999: LD_INT 48
43001: PUSH
43002: LD_INT 49
43004: PUSH
43005: LD_INT 50
43007: PUSH
43008: LD_INT 51
43010: PUSH
43011: LD_INT 52
43013: PUSH
43014: LD_INT 53
43016: PUSH
43017: LD_INT 54
43019: PUSH
43020: LD_INT 55
43022: PUSH
43023: LD_INT 56
43025: PUSH
43026: LD_INT 57
43028: PUSH
43029: LD_INT 58
43031: PUSH
43032: LD_INT 59
43034: PUSH
43035: LD_INT 63
43037: PUSH
43038: LD_INT 64
43040: PUSH
43041: LD_INT 65
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: LIST
43052: LIST
43053: LIST
43054: LIST
43055: LIST
43056: LIST
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: LIST
43076: LIST
43077: LIST
43078: LIST
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: LIST
43085: LIST
43086: LIST
43087: LIST
43088: ST_TO_ADDR
43089: GO 43092
43091: POP
// if state > - 1 and state < 3 then
43092: LD_VAR 0 3
43096: PUSH
43097: LD_INT 1
43099: NEG
43100: GREATER
43101: PUSH
43102: LD_VAR 0 3
43106: PUSH
43107: LD_INT 3
43109: LESS
43110: AND
43111: IFFALSE 43168
// for i in result do
43113: LD_ADDR_VAR 0 5
43117: PUSH
43118: LD_VAR 0 4
43122: PUSH
43123: FOR_IN
43124: IFFALSE 43166
// if GetTech ( i , side ) <> state then
43126: LD_VAR 0 5
43130: PPUSH
43131: LD_VAR 0 1
43135: PPUSH
43136: CALL_OW 321
43140: PUSH
43141: LD_VAR 0 3
43145: NONEQUAL
43146: IFFALSE 43164
// result := result diff i ;
43148: LD_ADDR_VAR 0 4
43152: PUSH
43153: LD_VAR 0 4
43157: PUSH
43158: LD_VAR 0 5
43162: DIFF
43163: ST_TO_ADDR
43164: GO 43123
43166: POP
43167: POP
// end ;
43168: LD_VAR 0 4
43172: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
43173: LD_INT 0
43175: PPUSH
43176: PPUSH
43177: PPUSH
// result := true ;
43178: LD_ADDR_VAR 0 3
43182: PUSH
43183: LD_INT 1
43185: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
43186: LD_ADDR_VAR 0 5
43190: PUSH
43191: LD_VAR 0 2
43195: PPUSH
43196: CALL_OW 480
43200: ST_TO_ADDR
// if not tmp then
43201: LD_VAR 0 5
43205: NOT
43206: IFFALSE 43210
// exit ;
43208: GO 43259
// for i in tmp do
43210: LD_ADDR_VAR 0 4
43214: PUSH
43215: LD_VAR 0 5
43219: PUSH
43220: FOR_IN
43221: IFFALSE 43257
// if GetTech ( i , side ) <> state_researched then
43223: LD_VAR 0 4
43227: PPUSH
43228: LD_VAR 0 1
43232: PPUSH
43233: CALL_OW 321
43237: PUSH
43238: LD_INT 2
43240: NONEQUAL
43241: IFFALSE 43255
// begin result := false ;
43243: LD_ADDR_VAR 0 3
43247: PUSH
43248: LD_INT 0
43250: ST_TO_ADDR
// exit ;
43251: POP
43252: POP
43253: GO 43259
// end ;
43255: GO 43220
43257: POP
43258: POP
// end ;
43259: LD_VAR 0 3
43263: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
43264: LD_INT 0
43266: PPUSH
43267: PPUSH
43268: PPUSH
43269: PPUSH
43270: PPUSH
43271: PPUSH
43272: PPUSH
43273: PPUSH
43274: PPUSH
43275: PPUSH
43276: PPUSH
43277: PPUSH
43278: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
43279: LD_VAR 0 1
43283: NOT
43284: PUSH
43285: LD_VAR 0 1
43289: PPUSH
43290: CALL_OW 257
43294: PUSH
43295: LD_INT 9
43297: NONEQUAL
43298: OR
43299: IFFALSE 43303
// exit ;
43301: GO 43876
// side := GetSide ( unit ) ;
43303: LD_ADDR_VAR 0 9
43307: PUSH
43308: LD_VAR 0 1
43312: PPUSH
43313: CALL_OW 255
43317: ST_TO_ADDR
// tech_space := tech_spacanom ;
43318: LD_ADDR_VAR 0 12
43322: PUSH
43323: LD_INT 29
43325: ST_TO_ADDR
// tech_time := tech_taurad ;
43326: LD_ADDR_VAR 0 13
43330: PUSH
43331: LD_INT 28
43333: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
43334: LD_ADDR_VAR 0 11
43338: PUSH
43339: LD_VAR 0 1
43343: PPUSH
43344: CALL_OW 310
43348: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
43349: LD_VAR 0 11
43353: PPUSH
43354: CALL_OW 247
43358: PUSH
43359: LD_INT 2
43361: EQUAL
43362: IFFALSE 43366
// exit ;
43364: GO 43876
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
43366: LD_ADDR_VAR 0 8
43370: PUSH
43371: LD_INT 81
43373: PUSH
43374: LD_VAR 0 9
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 3
43385: PUSH
43386: LD_INT 21
43388: PUSH
43389: LD_INT 3
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PPUSH
43404: CALL_OW 69
43408: ST_TO_ADDR
// if not tmp then
43409: LD_VAR 0 8
43413: NOT
43414: IFFALSE 43418
// exit ;
43416: GO 43876
// if in_unit then
43418: LD_VAR 0 11
43422: IFFALSE 43446
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
43424: LD_ADDR_VAR 0 10
43428: PUSH
43429: LD_VAR 0 8
43433: PPUSH
43434: LD_VAR 0 11
43438: PPUSH
43439: CALL_OW 74
43443: ST_TO_ADDR
43444: GO 43466
// enemy := NearestUnitToUnit ( tmp , unit ) ;
43446: LD_ADDR_VAR 0 10
43450: PUSH
43451: LD_VAR 0 8
43455: PPUSH
43456: LD_VAR 0 1
43460: PPUSH
43461: CALL_OW 74
43465: ST_TO_ADDR
// if not enemy then
43466: LD_VAR 0 10
43470: NOT
43471: IFFALSE 43475
// exit ;
43473: GO 43876
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
43475: LD_VAR 0 11
43479: PUSH
43480: LD_VAR 0 11
43484: PPUSH
43485: LD_VAR 0 10
43489: PPUSH
43490: CALL_OW 296
43494: PUSH
43495: LD_INT 13
43497: GREATER
43498: AND
43499: PUSH
43500: LD_VAR 0 1
43504: PPUSH
43505: LD_VAR 0 10
43509: PPUSH
43510: CALL_OW 296
43514: PUSH
43515: LD_INT 12
43517: GREATER
43518: OR
43519: IFFALSE 43523
// exit ;
43521: GO 43876
// missile := [ 1 ] ;
43523: LD_ADDR_VAR 0 14
43527: PUSH
43528: LD_INT 1
43530: PUSH
43531: EMPTY
43532: LIST
43533: ST_TO_ADDR
// if Researched ( side , tech_space ) then
43534: LD_VAR 0 9
43538: PPUSH
43539: LD_VAR 0 12
43543: PPUSH
43544: CALL_OW 325
43548: IFFALSE 43577
// missile := Insert ( missile , missile + 1 , 2 ) ;
43550: LD_ADDR_VAR 0 14
43554: PUSH
43555: LD_VAR 0 14
43559: PPUSH
43560: LD_VAR 0 14
43564: PUSH
43565: LD_INT 1
43567: PLUS
43568: PPUSH
43569: LD_INT 2
43571: PPUSH
43572: CALL_OW 2
43576: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
43577: LD_VAR 0 9
43581: PPUSH
43582: LD_VAR 0 13
43586: PPUSH
43587: CALL_OW 325
43591: PUSH
43592: LD_VAR 0 10
43596: PPUSH
43597: CALL_OW 255
43601: PPUSH
43602: LD_VAR 0 13
43606: PPUSH
43607: CALL_OW 325
43611: NOT
43612: AND
43613: IFFALSE 43642
// missile := Insert ( missile , missile + 1 , 3 ) ;
43615: LD_ADDR_VAR 0 14
43619: PUSH
43620: LD_VAR 0 14
43624: PPUSH
43625: LD_VAR 0 14
43629: PUSH
43630: LD_INT 1
43632: PLUS
43633: PPUSH
43634: LD_INT 3
43636: PPUSH
43637: CALL_OW 2
43641: ST_TO_ADDR
// if missile < 2 then
43642: LD_VAR 0 14
43646: PUSH
43647: LD_INT 2
43649: LESS
43650: IFFALSE 43654
// exit ;
43652: GO 43876
// x := GetX ( enemy ) ;
43654: LD_ADDR_VAR 0 4
43658: PUSH
43659: LD_VAR 0 10
43663: PPUSH
43664: CALL_OW 250
43668: ST_TO_ADDR
// y := GetY ( enemy ) ;
43669: LD_ADDR_VAR 0 5
43673: PUSH
43674: LD_VAR 0 10
43678: PPUSH
43679: CALL_OW 251
43683: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
43684: LD_ADDR_VAR 0 6
43688: PUSH
43689: LD_VAR 0 4
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PPUSH
43698: LD_INT 1
43700: PPUSH
43701: CALL_OW 12
43705: PLUS
43706: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
43707: LD_ADDR_VAR 0 7
43711: PUSH
43712: LD_VAR 0 5
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PPUSH
43721: LD_INT 1
43723: PPUSH
43724: CALL_OW 12
43728: PLUS
43729: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
43730: LD_VAR 0 6
43734: PPUSH
43735: LD_VAR 0 7
43739: PPUSH
43740: CALL_OW 488
43744: NOT
43745: IFFALSE 43767
// begin _x := x ;
43747: LD_ADDR_VAR 0 6
43751: PUSH
43752: LD_VAR 0 4
43756: ST_TO_ADDR
// _y := y ;
43757: LD_ADDR_VAR 0 7
43761: PUSH
43762: LD_VAR 0 5
43766: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
43767: LD_ADDR_VAR 0 3
43771: PUSH
43772: LD_INT 1
43774: PPUSH
43775: LD_VAR 0 14
43779: PPUSH
43780: CALL_OW 12
43784: ST_TO_ADDR
// case i of 1 :
43785: LD_VAR 0 3
43789: PUSH
43790: LD_INT 1
43792: DOUBLE
43793: EQUAL
43794: IFTRUE 43798
43796: GO 43815
43798: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
43799: LD_VAR 0 1
43803: PPUSH
43804: LD_VAR 0 10
43808: PPUSH
43809: CALL_OW 115
43813: GO 43876
43815: LD_INT 2
43817: DOUBLE
43818: EQUAL
43819: IFTRUE 43823
43821: GO 43845
43823: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
43824: LD_VAR 0 1
43828: PPUSH
43829: LD_VAR 0 6
43833: PPUSH
43834: LD_VAR 0 7
43838: PPUSH
43839: CALL_OW 153
43843: GO 43876
43845: LD_INT 3
43847: DOUBLE
43848: EQUAL
43849: IFTRUE 43853
43851: GO 43875
43853: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
43854: LD_VAR 0 1
43858: PPUSH
43859: LD_VAR 0 6
43863: PPUSH
43864: LD_VAR 0 7
43868: PPUSH
43869: CALL_OW 154
43873: GO 43876
43875: POP
// end ;
43876: LD_VAR 0 2
43880: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
43881: LD_INT 0
43883: PPUSH
43884: PPUSH
43885: PPUSH
43886: PPUSH
43887: PPUSH
43888: PPUSH
// if not unit or not building then
43889: LD_VAR 0 1
43893: NOT
43894: PUSH
43895: LD_VAR 0 2
43899: NOT
43900: OR
43901: IFFALSE 43905
// exit ;
43903: GO 44063
// x := GetX ( building ) ;
43905: LD_ADDR_VAR 0 5
43909: PUSH
43910: LD_VAR 0 2
43914: PPUSH
43915: CALL_OW 250
43919: ST_TO_ADDR
// y := GetY ( building ) ;
43920: LD_ADDR_VAR 0 6
43924: PUSH
43925: LD_VAR 0 2
43929: PPUSH
43930: CALL_OW 251
43934: ST_TO_ADDR
// for i = 0 to 5 do
43935: LD_ADDR_VAR 0 4
43939: PUSH
43940: DOUBLE
43941: LD_INT 0
43943: DEC
43944: ST_TO_ADDR
43945: LD_INT 5
43947: PUSH
43948: FOR_TO
43949: IFFALSE 44061
// begin _x := ShiftX ( x , i , 3 ) ;
43951: LD_ADDR_VAR 0 7
43955: PUSH
43956: LD_VAR 0 5
43960: PPUSH
43961: LD_VAR 0 4
43965: PPUSH
43966: LD_INT 3
43968: PPUSH
43969: CALL_OW 272
43973: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
43974: LD_ADDR_VAR 0 8
43978: PUSH
43979: LD_VAR 0 6
43983: PPUSH
43984: LD_VAR 0 4
43988: PPUSH
43989: LD_INT 3
43991: PPUSH
43992: CALL_OW 273
43996: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
43997: LD_VAR 0 7
44001: PPUSH
44002: LD_VAR 0 8
44006: PPUSH
44007: CALL_OW 488
44011: NOT
44012: IFFALSE 44016
// continue ;
44014: GO 43948
// if HexInfo ( _x , _y ) = 0 then
44016: LD_VAR 0 7
44020: PPUSH
44021: LD_VAR 0 8
44025: PPUSH
44026: CALL_OW 428
44030: PUSH
44031: LD_INT 0
44033: EQUAL
44034: IFFALSE 44059
// begin ComMoveXY ( unit , _x , _y ) ;
44036: LD_VAR 0 1
44040: PPUSH
44041: LD_VAR 0 7
44045: PPUSH
44046: LD_VAR 0 8
44050: PPUSH
44051: CALL_OW 111
// exit ;
44055: POP
44056: POP
44057: GO 44063
// end ; end ;
44059: GO 43948
44061: POP
44062: POP
// end ;
44063: LD_VAR 0 3
44067: RET
// export function ScanBase ( side , base_area ) ; begin
44068: LD_INT 0
44070: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
44071: LD_ADDR_VAR 0 3
44075: PUSH
44076: LD_VAR 0 2
44080: PPUSH
44081: LD_INT 81
44083: PUSH
44084: LD_VAR 0 1
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PPUSH
44093: CALL_OW 70
44097: ST_TO_ADDR
// end ;
44098: LD_VAR 0 3
44102: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
44103: LD_INT 0
44105: PPUSH
44106: PPUSH
44107: PPUSH
44108: PPUSH
44109: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
44110: LD_VAR 0 1
44114: NOT
44115: PUSH
44116: LD_EXP 71
44120: PUSH
44121: LD_VAR 0 1
44125: ARRAY
44126: NOT
44127: OR
44128: PUSH
44129: LD_VAR 0 2
44133: NOT
44134: OR
44135: PUSH
44136: LD_VAR 0 3
44140: NOT
44141: OR
44142: IFFALSE 44146
// exit ;
44144: GO 44596
// side := mc_sides [ base ] ;
44146: LD_ADDR_VAR 0 6
44150: PUSH
44151: LD_EXP 97
44155: PUSH
44156: LD_VAR 0 1
44160: ARRAY
44161: ST_TO_ADDR
// if not side then
44162: LD_VAR 0 6
44166: NOT
44167: IFFALSE 44171
// exit ;
44169: GO 44596
// for i in solds do
44171: LD_ADDR_VAR 0 7
44175: PUSH
44176: LD_VAR 0 2
44180: PUSH
44181: FOR_IN
44182: IFFALSE 44243
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
44184: LD_VAR 0 7
44188: PPUSH
44189: CALL_OW 310
44193: PPUSH
44194: CALL_OW 266
44198: PUSH
44199: LD_INT 32
44201: PUSH
44202: LD_INT 31
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: IN
44209: IFFALSE 44229
// solds := solds diff i else
44211: LD_ADDR_VAR 0 2
44215: PUSH
44216: LD_VAR 0 2
44220: PUSH
44221: LD_VAR 0 7
44225: DIFF
44226: ST_TO_ADDR
44227: GO 44241
// SetTag ( i , 18 ) ;
44229: LD_VAR 0 7
44233: PPUSH
44234: LD_INT 18
44236: PPUSH
44237: CALL_OW 109
44241: GO 44181
44243: POP
44244: POP
// if not solds then
44245: LD_VAR 0 2
44249: NOT
44250: IFFALSE 44254
// exit ;
44252: GO 44596
// repeat wait ( 0 0$1 ) ;
44254: LD_INT 35
44256: PPUSH
44257: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
44261: LD_ADDR_VAR 0 5
44265: PUSH
44266: LD_VAR 0 6
44270: PPUSH
44271: LD_VAR 0 3
44275: PPUSH
44276: CALL 44068 0 2
44280: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
44281: LD_VAR 0 5
44285: NOT
44286: PUSH
44287: LD_VAR 0 5
44291: PUSH
44292: LD_INT 3
44294: GREATER
44295: OR
44296: PUSH
44297: LD_EXP 93
44301: PUSH
44302: LD_VAR 0 1
44306: ARRAY
44307: OR
44308: IFFALSE 44349
// begin for i in solds do
44310: LD_ADDR_VAR 0 7
44314: PUSH
44315: LD_VAR 0 2
44319: PUSH
44320: FOR_IN
44321: IFFALSE 44345
// if HasTask ( i ) then
44323: LD_VAR 0 7
44327: PPUSH
44328: CALL_OW 314
44332: IFFALSE 44343
// ComStop ( i ) ;
44334: LD_VAR 0 7
44338: PPUSH
44339: CALL_OW 141
44343: GO 44320
44345: POP
44346: POP
// break ;
44347: GO 44584
// end ; for i in solds do
44349: LD_ADDR_VAR 0 7
44353: PUSH
44354: LD_VAR 0 2
44358: PUSH
44359: FOR_IN
44360: IFFALSE 44576
// begin if IsInUnit ( i ) then
44362: LD_VAR 0 7
44366: PPUSH
44367: CALL_OW 310
44371: IFFALSE 44382
// ComExitBuilding ( i ) ;
44373: LD_VAR 0 7
44377: PPUSH
44378: CALL_OW 122
// if GetLives ( i ) > 333 then
44382: LD_VAR 0 7
44386: PPUSH
44387: CALL_OW 256
44391: PUSH
44392: LD_INT 333
44394: GREATER
44395: IFFALSE 44423
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
44397: LD_VAR 0 7
44401: PPUSH
44402: LD_VAR 0 5
44406: PPUSH
44407: LD_VAR 0 7
44411: PPUSH
44412: CALL_OW 74
44416: PPUSH
44417: CALL_OW 115
44421: GO 44574
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
44423: LD_ADDR_VAR 0 8
44427: PUSH
44428: LD_EXP 71
44432: PUSH
44433: LD_VAR 0 1
44437: ARRAY
44438: PPUSH
44439: LD_INT 2
44441: PUSH
44442: LD_INT 30
44444: PUSH
44445: LD_INT 0
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 30
44454: PUSH
44455: LD_INT 1
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 30
44464: PUSH
44465: LD_INT 6
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: PPUSH
44478: CALL_OW 72
44482: PPUSH
44483: LD_VAR 0 7
44487: PPUSH
44488: CALL_OW 74
44492: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
44493: LD_VAR 0 7
44497: PPUSH
44498: LD_VAR 0 8
44502: PPUSH
44503: CALL_OW 250
44507: PPUSH
44508: LD_INT 3
44510: PPUSH
44511: LD_INT 5
44513: PPUSH
44514: CALL_OW 272
44518: PPUSH
44519: LD_VAR 0 8
44523: PPUSH
44524: CALL_OW 251
44528: PPUSH
44529: LD_INT 3
44531: PPUSH
44532: LD_INT 5
44534: PPUSH
44535: CALL_OW 273
44539: PPUSH
44540: CALL_OW 111
// SetTag ( i , 0 ) ;
44544: LD_VAR 0 7
44548: PPUSH
44549: LD_INT 0
44551: PPUSH
44552: CALL_OW 109
// solds := solds diff i ;
44556: LD_ADDR_VAR 0 2
44560: PUSH
44561: LD_VAR 0 2
44565: PUSH
44566: LD_VAR 0 7
44570: DIFF
44571: ST_TO_ADDR
// continue ;
44572: GO 44359
// end ; end ;
44574: GO 44359
44576: POP
44577: POP
// until solds ;
44578: LD_VAR 0 2
44582: IFFALSE 44254
// MC_Reset ( base , 18 ) ;
44584: LD_VAR 0 1
44588: PPUSH
44589: LD_INT 18
44591: PPUSH
44592: CALL 17847 0 2
// end ;
44596: LD_VAR 0 4
44600: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
44601: LD_INT 0
44603: PPUSH
44604: PPUSH
44605: PPUSH
44606: PPUSH
44607: PPUSH
44608: PPUSH
44609: PPUSH
44610: PPUSH
44611: PPUSH
44612: PPUSH
44613: PPUSH
44614: PPUSH
44615: PPUSH
44616: PPUSH
44617: PPUSH
44618: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44619: LD_ADDR_VAR 0 12
44623: PUSH
44624: LD_EXP 71
44628: PUSH
44629: LD_VAR 0 1
44633: ARRAY
44634: PPUSH
44635: LD_INT 25
44637: PUSH
44638: LD_INT 3
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PPUSH
44645: CALL_OW 72
44649: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44650: LD_ADDR_VAR 0 8
44654: PUSH
44655: LD_EXP 71
44659: PUSH
44660: LD_VAR 0 1
44664: ARRAY
44665: PPUSH
44666: LD_INT 2
44668: PUSH
44669: LD_INT 25
44671: PUSH
44672: LD_INT 1
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 25
44681: PUSH
44682: LD_INT 5
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: LD_INT 25
44691: PUSH
44692: LD_INT 8
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 25
44701: PUSH
44702: LD_INT 9
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: EMPTY
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: PPUSH
44716: CALL_OW 72
44720: ST_TO_ADDR
// if not defenders and not solds then
44721: LD_VAR 0 2
44725: NOT
44726: PUSH
44727: LD_VAR 0 8
44731: NOT
44732: AND
44733: IFFALSE 44737
// exit ;
44735: GO 46103
// depot_under_attack := false ;
44737: LD_ADDR_VAR 0 16
44741: PUSH
44742: LD_INT 0
44744: ST_TO_ADDR
// sold_defenders := [ ] ;
44745: LD_ADDR_VAR 0 17
44749: PUSH
44750: EMPTY
44751: ST_TO_ADDR
// if mechs then
44752: LD_VAR 0 12
44756: IFFALSE 44885
// for i in defenders do
44758: LD_ADDR_VAR 0 5
44762: PUSH
44763: LD_VAR 0 2
44767: PUSH
44768: FOR_IN
44769: IFFALSE 44883
// begin SetTag ( i , 20 ) ;
44771: LD_VAR 0 5
44775: PPUSH
44776: LD_INT 20
44778: PPUSH
44779: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
44783: LD_VAR 0 5
44787: PPUSH
44788: CALL_OW 263
44792: PUSH
44793: LD_INT 1
44795: EQUAL
44796: PUSH
44797: LD_VAR 0 5
44801: PPUSH
44802: CALL_OW 311
44806: NOT
44807: AND
44808: PUSH
44809: LD_VAR 0 12
44813: AND
44814: IFFALSE 44881
// begin un := mechs [ 1 ] ;
44816: LD_ADDR_VAR 0 10
44820: PUSH
44821: LD_VAR 0 12
44825: PUSH
44826: LD_INT 1
44828: ARRAY
44829: ST_TO_ADDR
// ComExitBuilding ( un ) ;
44830: LD_VAR 0 10
44834: PPUSH
44835: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
44839: LD_VAR 0 10
44843: PPUSH
44844: LD_VAR 0 5
44848: PPUSH
44849: CALL_OW 180
// SetTag ( un , 19 ) ;
44853: LD_VAR 0 10
44857: PPUSH
44858: LD_INT 19
44860: PPUSH
44861: CALL_OW 109
// mechs := mechs diff un ;
44865: LD_ADDR_VAR 0 12
44869: PUSH
44870: LD_VAR 0 12
44874: PUSH
44875: LD_VAR 0 10
44879: DIFF
44880: ST_TO_ADDR
// end ; end ;
44881: GO 44768
44883: POP
44884: POP
// if solds then
44885: LD_VAR 0 8
44889: IFFALSE 44948
// for i in solds do
44891: LD_ADDR_VAR 0 5
44895: PUSH
44896: LD_VAR 0 8
44900: PUSH
44901: FOR_IN
44902: IFFALSE 44946
// if not GetTag ( i ) then
44904: LD_VAR 0 5
44908: PPUSH
44909: CALL_OW 110
44913: NOT
44914: IFFALSE 44944
// begin defenders := defenders union i ;
44916: LD_ADDR_VAR 0 2
44920: PUSH
44921: LD_VAR 0 2
44925: PUSH
44926: LD_VAR 0 5
44930: UNION
44931: ST_TO_ADDR
// SetTag ( i , 18 ) ;
44932: LD_VAR 0 5
44936: PPUSH
44937: LD_INT 18
44939: PPUSH
44940: CALL_OW 109
// end ;
44944: GO 44901
44946: POP
44947: POP
// repeat wait ( 0 0$1 ) ;
44948: LD_INT 35
44950: PPUSH
44951: CALL_OW 67
// enemy := mc_scan [ base ] ;
44955: LD_ADDR_VAR 0 3
44959: PUSH
44960: LD_EXP 94
44964: PUSH
44965: LD_VAR 0 1
44969: ARRAY
44970: ST_TO_ADDR
// for i in defenders do
44971: LD_ADDR_VAR 0 5
44975: PUSH
44976: LD_VAR 0 2
44980: PUSH
44981: FOR_IN
44982: IFFALSE 45667
// begin e := NearestUnitToUnit ( enemy , i ) ;
44984: LD_ADDR_VAR 0 13
44988: PUSH
44989: LD_VAR 0 3
44993: PPUSH
44994: LD_VAR 0 5
44998: PPUSH
44999: CALL_OW 74
45003: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
45004: LD_ADDR_VAR 0 16
45008: PUSH
45009: LD_EXP 71
45013: PUSH
45014: LD_VAR 0 1
45018: ARRAY
45019: PPUSH
45020: LD_INT 2
45022: PUSH
45023: LD_INT 30
45025: PUSH
45026: LD_INT 0
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 30
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: LIST
45047: PPUSH
45048: CALL_OW 72
45052: NOT
45053: PUSH
45054: LD_EXP 71
45058: PUSH
45059: LD_VAR 0 1
45063: ARRAY
45064: PPUSH
45065: LD_INT 2
45067: PUSH
45068: LD_INT 30
45070: PUSH
45071: LD_INT 0
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 30
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: LIST
45092: PPUSH
45093: CALL_OW 72
45097: PPUSH
45098: CALL_OW 256
45102: PUSH
45103: LD_INT 600
45105: LESS
45106: OR
45107: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
45108: LD_VAR 0 5
45112: PPUSH
45113: CALL_OW 247
45117: PUSH
45118: LD_INT 2
45120: DOUBLE
45121: EQUAL
45122: IFTRUE 45126
45124: GO 45373
45126: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
45127: LD_VAR 0 5
45131: PPUSH
45132: CALL_OW 256
45136: PUSH
45137: LD_INT 650
45139: GREATER
45140: PUSH
45141: LD_VAR 0 5
45145: PPUSH
45146: LD_VAR 0 13
45150: PPUSH
45151: CALL_OW 296
45155: PUSH
45156: LD_INT 40
45158: LESS
45159: AND
45160: IFFALSE 45178
// ComAttackUnit ( i , e ) else
45162: LD_VAR 0 5
45166: PPUSH
45167: LD_VAR 0 13
45171: PPUSH
45172: CALL_OW 115
45176: GO 45256
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
45178: LD_VAR 0 5
45182: PPUSH
45183: LD_VAR 0 13
45187: PPUSH
45188: CALL_OW 296
45192: PUSH
45193: LD_INT 30
45195: GREATEREQUAL
45196: PUSH
45197: LD_VAR 0 5
45201: PPUSH
45202: CALL_OW 256
45206: PUSH
45207: LD_INT 650
45209: LESSEQUAL
45210: OR
45211: PUSH
45212: LD_VAR 0 5
45216: PPUSH
45217: LD_EXP 95
45221: PUSH
45222: LD_VAR 0 1
45226: ARRAY
45227: PPUSH
45228: CALL_OW 308
45232: NOT
45233: AND
45234: IFFALSE 45256
// ComMoveToArea ( i , mc_parking [ base ] ) ;
45236: LD_VAR 0 5
45240: PPUSH
45241: LD_EXP 95
45245: PUSH
45246: LD_VAR 0 1
45250: ARRAY
45251: PPUSH
45252: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
45256: LD_VAR 0 5
45260: PPUSH
45261: CALL_OW 256
45265: PUSH
45266: LD_INT 998
45268: LESS
45269: PUSH
45270: LD_VAR 0 5
45274: PPUSH
45275: CALL_OW 263
45279: PUSH
45280: LD_INT 1
45282: EQUAL
45283: AND
45284: PUSH
45285: LD_VAR 0 5
45289: PPUSH
45290: CALL_OW 311
45294: AND
45295: PUSH
45296: LD_VAR 0 5
45300: PPUSH
45301: LD_EXP 95
45305: PUSH
45306: LD_VAR 0 1
45310: ARRAY
45311: PPUSH
45312: CALL_OW 308
45316: AND
45317: IFFALSE 45371
// begin mech := IsDrivenBy ( i ) ;
45319: LD_ADDR_VAR 0 9
45323: PUSH
45324: LD_VAR 0 5
45328: PPUSH
45329: CALL_OW 311
45333: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
45334: LD_VAR 0 9
45338: PPUSH
45339: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
45343: LD_VAR 0 9
45347: PPUSH
45348: LD_VAR 0 5
45352: PPUSH
45353: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
45357: LD_VAR 0 9
45361: PPUSH
45362: LD_VAR 0 5
45366: PPUSH
45367: CALL_OW 180
// end ; end ; unit_human :
45371: GO 45638
45373: LD_INT 1
45375: DOUBLE
45376: EQUAL
45377: IFTRUE 45381
45379: GO 45637
45381: POP
// begin b := IsInUnit ( i ) ;
45382: LD_ADDR_VAR 0 18
45386: PUSH
45387: LD_VAR 0 5
45391: PPUSH
45392: CALL_OW 310
45396: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
45397: LD_ADDR_VAR 0 19
45401: PUSH
45402: LD_VAR 0 18
45406: NOT
45407: PUSH
45408: LD_VAR 0 18
45412: PPUSH
45413: CALL_OW 266
45417: PUSH
45418: LD_INT 32
45420: PUSH
45421: LD_INT 31
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: IN
45428: OR
45429: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
45430: LD_VAR 0 16
45434: PUSH
45435: LD_VAR 0 2
45439: PPUSH
45440: LD_INT 21
45442: PUSH
45443: LD_INT 2
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PPUSH
45450: CALL_OW 72
45454: PUSH
45455: LD_INT 1
45457: LESSEQUAL
45458: OR
45459: PUSH
45460: LD_VAR 0 19
45464: AND
45465: PUSH
45466: LD_VAR 0 5
45470: PUSH
45471: LD_VAR 0 17
45475: IN
45476: NOT
45477: AND
45478: IFFALSE 45571
// begin if b then
45480: LD_VAR 0 18
45484: IFFALSE 45533
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
45486: LD_VAR 0 18
45490: PPUSH
45491: LD_VAR 0 3
45495: PPUSH
45496: LD_VAR 0 18
45500: PPUSH
45501: CALL_OW 74
45505: PPUSH
45506: CALL_OW 296
45510: PUSH
45511: LD_INT 10
45513: LESS
45514: PUSH
45515: LD_VAR 0 18
45519: PPUSH
45520: CALL_OW 461
45524: PUSH
45525: LD_INT 7
45527: NONEQUAL
45528: AND
45529: IFFALSE 45533
// continue ;
45531: GO 44981
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
45533: LD_ADDR_VAR 0 17
45537: PUSH
45538: LD_VAR 0 17
45542: PPUSH
45543: LD_VAR 0 17
45547: PUSH
45548: LD_INT 1
45550: PLUS
45551: PPUSH
45552: LD_VAR 0 5
45556: PPUSH
45557: CALL_OW 1
45561: ST_TO_ADDR
// ComExitBuilding ( i ) ;
45562: LD_VAR 0 5
45566: PPUSH
45567: CALL_OW 122
// end ; if sold_defenders then
45571: LD_VAR 0 17
45575: IFFALSE 45635
// if i in sold_defenders then
45577: LD_VAR 0 5
45581: PUSH
45582: LD_VAR 0 17
45586: IN
45587: IFFALSE 45635
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
45589: LD_VAR 0 5
45593: PPUSH
45594: CALL_OW 314
45598: NOT
45599: PUSH
45600: LD_VAR 0 5
45604: PPUSH
45605: LD_VAR 0 13
45609: PPUSH
45610: CALL_OW 296
45614: PUSH
45615: LD_INT 30
45617: LESS
45618: AND
45619: IFFALSE 45635
// ComAttackUnit ( i , e ) ;
45621: LD_VAR 0 5
45625: PPUSH
45626: LD_VAR 0 13
45630: PPUSH
45631: CALL_OW 115
// end ; end ; end ;
45635: GO 45638
45637: POP
// if IsDead ( i ) then
45638: LD_VAR 0 5
45642: PPUSH
45643: CALL_OW 301
45647: IFFALSE 45665
// defenders := defenders diff i ;
45649: LD_ADDR_VAR 0 2
45653: PUSH
45654: LD_VAR 0 2
45658: PUSH
45659: LD_VAR 0 5
45663: DIFF
45664: ST_TO_ADDR
// end ;
45665: GO 44981
45667: POP
45668: POP
// until not enemy or not defenders ;
45669: LD_VAR 0 3
45673: NOT
45674: PUSH
45675: LD_VAR 0 2
45679: NOT
45680: OR
45681: IFFALSE 44948
// MC_Reset ( base , 18 ) ;
45683: LD_VAR 0 1
45687: PPUSH
45688: LD_INT 18
45690: PPUSH
45691: CALL 17847 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
45695: LD_ADDR_VAR 0 2
45699: PUSH
45700: LD_VAR 0 2
45704: PUSH
45705: LD_VAR 0 2
45709: PPUSH
45710: LD_INT 2
45712: PUSH
45713: LD_INT 25
45715: PUSH
45716: LD_INT 1
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: PUSH
45723: LD_INT 25
45725: PUSH
45726: LD_INT 5
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 25
45735: PUSH
45736: LD_INT 8
45738: PUSH
45739: EMPTY
45740: LIST
45741: LIST
45742: PUSH
45743: LD_INT 25
45745: PUSH
45746: LD_INT 9
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: PPUSH
45760: CALL_OW 72
45764: DIFF
45765: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
45766: LD_VAR 0 3
45770: NOT
45771: PUSH
45772: LD_VAR 0 2
45776: PPUSH
45777: LD_INT 21
45779: PUSH
45780: LD_INT 2
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PPUSH
45787: CALL_OW 72
45791: AND
45792: IFFALSE 46054
// begin tmp := FilterByTag ( defenders , 19 ) ;
45794: LD_ADDR_VAR 0 11
45798: PUSH
45799: LD_VAR 0 2
45803: PPUSH
45804: LD_INT 19
45806: PPUSH
45807: CALL 82401 0 2
45811: ST_TO_ADDR
// if tmp then
45812: LD_VAR 0 11
45816: IFFALSE 45886
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
45818: LD_ADDR_VAR 0 11
45822: PUSH
45823: LD_VAR 0 11
45827: PPUSH
45828: LD_INT 25
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PPUSH
45838: CALL_OW 72
45842: ST_TO_ADDR
// if tmp then
45843: LD_VAR 0 11
45847: IFFALSE 45886
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
45849: LD_ADDR_EXP 83
45853: PUSH
45854: LD_EXP 83
45858: PPUSH
45859: LD_VAR 0 1
45863: PPUSH
45864: LD_EXP 83
45868: PUSH
45869: LD_VAR 0 1
45873: ARRAY
45874: PUSH
45875: LD_VAR 0 11
45879: UNION
45880: PPUSH
45881: CALL_OW 1
45885: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
45886: LD_VAR 0 1
45890: PPUSH
45891: LD_INT 19
45893: PPUSH
45894: CALL 17847 0 2
// repeat wait ( 0 0$1 ) ;
45898: LD_INT 35
45900: PPUSH
45901: CALL_OW 67
// for i in defenders do
45905: LD_ADDR_VAR 0 5
45909: PUSH
45910: LD_VAR 0 2
45914: PUSH
45915: FOR_IN
45916: IFFALSE 46005
// begin if not IsInArea ( i , mc_parking [ base ] ) then
45918: LD_VAR 0 5
45922: PPUSH
45923: LD_EXP 95
45927: PUSH
45928: LD_VAR 0 1
45932: ARRAY
45933: PPUSH
45934: CALL_OW 308
45938: NOT
45939: IFFALSE 45963
// ComMoveToArea ( i , mc_parking [ base ] ) else
45941: LD_VAR 0 5
45945: PPUSH
45946: LD_EXP 95
45950: PUSH
45951: LD_VAR 0 1
45955: ARRAY
45956: PPUSH
45957: CALL_OW 113
45961: GO 46003
// if GetControl ( i ) = control_manual then
45963: LD_VAR 0 5
45967: PPUSH
45968: CALL_OW 263
45972: PUSH
45973: LD_INT 1
45975: EQUAL
45976: IFFALSE 46003
// if IsDrivenBy ( i ) then
45978: LD_VAR 0 5
45982: PPUSH
45983: CALL_OW 311
45987: IFFALSE 46003
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
45989: LD_VAR 0 5
45993: PPUSH
45994: CALL_OW 311
45998: PPUSH
45999: CALL_OW 121
// end ;
46003: GO 45915
46005: POP
46006: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
46007: LD_VAR 0 2
46011: PPUSH
46012: LD_INT 95
46014: PUSH
46015: LD_EXP 95
46019: PUSH
46020: LD_VAR 0 1
46024: ARRAY
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PPUSH
46030: CALL_OW 72
46034: PUSH
46035: LD_VAR 0 2
46039: EQUAL
46040: PUSH
46041: LD_EXP 94
46045: PUSH
46046: LD_VAR 0 1
46050: ARRAY
46051: OR
46052: IFFALSE 45898
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
46054: LD_ADDR_EXP 93
46058: PUSH
46059: LD_EXP 93
46063: PPUSH
46064: LD_VAR 0 1
46068: PPUSH
46069: LD_EXP 93
46073: PUSH
46074: LD_VAR 0 1
46078: ARRAY
46079: PUSH
46080: LD_VAR 0 2
46084: UNION
46085: PPUSH
46086: CALL_OW 1
46090: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
46091: LD_VAR 0 1
46095: PPUSH
46096: LD_INT 20
46098: PPUSH
46099: CALL 17847 0 2
// end ;
46103: LD_VAR 0 4
46107: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
46108: LD_INT 0
46110: PPUSH
46111: PPUSH
46112: PPUSH
46113: PPUSH
// result := false ;
46114: LD_ADDR_VAR 0 2
46118: PUSH
46119: LD_INT 0
46121: ST_TO_ADDR
// side := GetSide ( unit ) ;
46122: LD_ADDR_VAR 0 3
46126: PUSH
46127: LD_VAR 0 1
46131: PPUSH
46132: CALL_OW 255
46136: ST_TO_ADDR
// nat := GetNation ( unit ) ;
46137: LD_ADDR_VAR 0 4
46141: PUSH
46142: LD_VAR 0 1
46146: PPUSH
46147: CALL_OW 248
46151: ST_TO_ADDR
// case nat of 1 :
46152: LD_VAR 0 4
46156: PUSH
46157: LD_INT 1
46159: DOUBLE
46160: EQUAL
46161: IFTRUE 46165
46163: GO 46176
46165: POP
// tech := tech_lassight ; 2 :
46166: LD_ADDR_VAR 0 5
46170: PUSH
46171: LD_INT 12
46173: ST_TO_ADDR
46174: GO 46215
46176: LD_INT 2
46178: DOUBLE
46179: EQUAL
46180: IFTRUE 46184
46182: GO 46195
46184: POP
// tech := tech_mortar ; 3 :
46185: LD_ADDR_VAR 0 5
46189: PUSH
46190: LD_INT 41
46192: ST_TO_ADDR
46193: GO 46215
46195: LD_INT 3
46197: DOUBLE
46198: EQUAL
46199: IFTRUE 46203
46201: GO 46214
46203: POP
// tech := tech_bazooka ; end ;
46204: LD_ADDR_VAR 0 5
46208: PUSH
46209: LD_INT 44
46211: ST_TO_ADDR
46212: GO 46215
46214: POP
// if Researched ( side , tech ) then
46215: LD_VAR 0 3
46219: PPUSH
46220: LD_VAR 0 5
46224: PPUSH
46225: CALL_OW 325
46229: IFFALSE 46256
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
46231: LD_ADDR_VAR 0 2
46235: PUSH
46236: LD_INT 5
46238: PUSH
46239: LD_INT 8
46241: PUSH
46242: LD_INT 9
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: LIST
46249: PUSH
46250: LD_VAR 0 4
46254: ARRAY
46255: ST_TO_ADDR
// end ;
46256: LD_VAR 0 2
46260: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
46261: LD_INT 0
46263: PPUSH
46264: PPUSH
46265: PPUSH
// if not mines then
46266: LD_VAR 0 2
46270: NOT
46271: IFFALSE 46275
// exit ;
46273: GO 46419
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
46275: LD_ADDR_VAR 0 5
46279: PUSH
46280: LD_INT 81
46282: PUSH
46283: LD_VAR 0 1
46287: PUSH
46288: EMPTY
46289: LIST
46290: LIST
46291: PUSH
46292: LD_INT 3
46294: PUSH
46295: LD_INT 21
46297: PUSH
46298: LD_INT 3
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PPUSH
46313: CALL_OW 69
46317: ST_TO_ADDR
// for i in mines do
46318: LD_ADDR_VAR 0 4
46322: PUSH
46323: LD_VAR 0 2
46327: PUSH
46328: FOR_IN
46329: IFFALSE 46417
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
46331: LD_VAR 0 4
46335: PUSH
46336: LD_INT 1
46338: ARRAY
46339: PPUSH
46340: LD_VAR 0 4
46344: PUSH
46345: LD_INT 2
46347: ARRAY
46348: PPUSH
46349: CALL_OW 458
46353: NOT
46354: IFFALSE 46358
// continue ;
46356: GO 46328
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
46358: LD_VAR 0 4
46362: PUSH
46363: LD_INT 1
46365: ARRAY
46366: PPUSH
46367: LD_VAR 0 4
46371: PUSH
46372: LD_INT 2
46374: ARRAY
46375: PPUSH
46376: CALL_OW 428
46380: PUSH
46381: LD_VAR 0 5
46385: IN
46386: IFFALSE 46415
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
46388: LD_VAR 0 4
46392: PUSH
46393: LD_INT 1
46395: ARRAY
46396: PPUSH
46397: LD_VAR 0 4
46401: PUSH
46402: LD_INT 2
46404: ARRAY
46405: PPUSH
46406: LD_VAR 0 1
46410: PPUSH
46411: CALL_OW 456
// end ;
46415: GO 46328
46417: POP
46418: POP
// end ;
46419: LD_VAR 0 3
46423: RET
// export function Count ( array ) ; var i ; begin
46424: LD_INT 0
46426: PPUSH
46427: PPUSH
// result := 0 ;
46428: LD_ADDR_VAR 0 2
46432: PUSH
46433: LD_INT 0
46435: ST_TO_ADDR
// for i in array do
46436: LD_ADDR_VAR 0 3
46440: PUSH
46441: LD_VAR 0 1
46445: PUSH
46446: FOR_IN
46447: IFFALSE 46471
// if i then
46449: LD_VAR 0 3
46453: IFFALSE 46469
// result := result + 1 ;
46455: LD_ADDR_VAR 0 2
46459: PUSH
46460: LD_VAR 0 2
46464: PUSH
46465: LD_INT 1
46467: PLUS
46468: ST_TO_ADDR
46469: GO 46446
46471: POP
46472: POP
// end ;
46473: LD_VAR 0 2
46477: RET
// export function IsEmpty ( building ) ; begin
46478: LD_INT 0
46480: PPUSH
// if not building then
46481: LD_VAR 0 1
46485: NOT
46486: IFFALSE 46490
// exit ;
46488: GO 46533
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
46490: LD_ADDR_VAR 0 2
46494: PUSH
46495: LD_VAR 0 1
46499: PUSH
46500: LD_INT 22
46502: PUSH
46503: LD_VAR 0 1
46507: PPUSH
46508: CALL_OW 255
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: PUSH
46517: LD_INT 58
46519: PUSH
46520: EMPTY
46521: LIST
46522: PUSH
46523: EMPTY
46524: LIST
46525: LIST
46526: PPUSH
46527: CALL_OW 69
46531: IN
46532: ST_TO_ADDR
// end ;
46533: LD_VAR 0 2
46537: RET
// export function IsNotFull ( building ) ; begin
46538: LD_INT 0
46540: PPUSH
// if not building then
46541: LD_VAR 0 1
46545: NOT
46546: IFFALSE 46550
// exit ;
46548: GO 46569
// result := UnitsInside ( building ) < 6 ;
46550: LD_ADDR_VAR 0 2
46554: PUSH
46555: LD_VAR 0 1
46559: PPUSH
46560: CALL_OW 313
46564: PUSH
46565: LD_INT 6
46567: LESS
46568: ST_TO_ADDR
// end ;
46569: LD_VAR 0 2
46573: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
46574: LD_INT 0
46576: PPUSH
46577: PPUSH
46578: PPUSH
46579: PPUSH
// tmp := [ ] ;
46580: LD_ADDR_VAR 0 3
46584: PUSH
46585: EMPTY
46586: ST_TO_ADDR
// list := [ ] ;
46587: LD_ADDR_VAR 0 5
46591: PUSH
46592: EMPTY
46593: ST_TO_ADDR
// for i = 16 to 25 do
46594: LD_ADDR_VAR 0 4
46598: PUSH
46599: DOUBLE
46600: LD_INT 16
46602: DEC
46603: ST_TO_ADDR
46604: LD_INT 25
46606: PUSH
46607: FOR_TO
46608: IFFALSE 46681
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
46610: LD_ADDR_VAR 0 3
46614: PUSH
46615: LD_VAR 0 3
46619: PUSH
46620: LD_INT 22
46622: PUSH
46623: LD_VAR 0 1
46627: PPUSH
46628: CALL_OW 255
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 91
46639: PUSH
46640: LD_VAR 0 1
46644: PUSH
46645: LD_INT 6
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 30
46655: PUSH
46656: LD_VAR 0 4
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: LIST
46669: PUSH
46670: EMPTY
46671: LIST
46672: PPUSH
46673: CALL_OW 69
46677: ADD
46678: ST_TO_ADDR
46679: GO 46607
46681: POP
46682: POP
// for i = 1 to tmp do
46683: LD_ADDR_VAR 0 4
46687: PUSH
46688: DOUBLE
46689: LD_INT 1
46691: DEC
46692: ST_TO_ADDR
46693: LD_VAR 0 3
46697: PUSH
46698: FOR_TO
46699: IFFALSE 46787
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
46701: LD_ADDR_VAR 0 5
46705: PUSH
46706: LD_VAR 0 5
46710: PUSH
46711: LD_VAR 0 3
46715: PUSH
46716: LD_VAR 0 4
46720: ARRAY
46721: PPUSH
46722: CALL_OW 266
46726: PUSH
46727: LD_VAR 0 3
46731: PUSH
46732: LD_VAR 0 4
46736: ARRAY
46737: PPUSH
46738: CALL_OW 250
46742: PUSH
46743: LD_VAR 0 3
46747: PUSH
46748: LD_VAR 0 4
46752: ARRAY
46753: PPUSH
46754: CALL_OW 251
46758: PUSH
46759: LD_VAR 0 3
46763: PUSH
46764: LD_VAR 0 4
46768: ARRAY
46769: PPUSH
46770: CALL_OW 254
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: PUSH
46781: EMPTY
46782: LIST
46783: ADD
46784: ST_TO_ADDR
46785: GO 46698
46787: POP
46788: POP
// result := list ;
46789: LD_ADDR_VAR 0 2
46793: PUSH
46794: LD_VAR 0 5
46798: ST_TO_ADDR
// end ;
46799: LD_VAR 0 2
46803: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
46804: LD_INT 0
46806: PPUSH
46807: PPUSH
46808: PPUSH
46809: PPUSH
46810: PPUSH
46811: PPUSH
46812: PPUSH
// if not factory then
46813: LD_VAR 0 1
46817: NOT
46818: IFFALSE 46822
// exit ;
46820: GO 47347
// if control = control_apeman then
46822: LD_VAR 0 4
46826: PUSH
46827: LD_INT 5
46829: EQUAL
46830: IFFALSE 46939
// begin tmp := UnitsInside ( factory ) ;
46832: LD_ADDR_VAR 0 8
46836: PUSH
46837: LD_VAR 0 1
46841: PPUSH
46842: CALL_OW 313
46846: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
46847: LD_VAR 0 8
46851: PPUSH
46852: LD_INT 25
46854: PUSH
46855: LD_INT 12
46857: PUSH
46858: EMPTY
46859: LIST
46860: LIST
46861: PPUSH
46862: CALL_OW 72
46866: NOT
46867: IFFALSE 46877
// control := control_manual ;
46869: LD_ADDR_VAR 0 4
46873: PUSH
46874: LD_INT 1
46876: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
46877: LD_ADDR_VAR 0 8
46881: PUSH
46882: LD_VAR 0 1
46886: PPUSH
46887: CALL 46574 0 1
46891: ST_TO_ADDR
// if tmp then
46892: LD_VAR 0 8
46896: IFFALSE 46939
// begin for i in tmp do
46898: LD_ADDR_VAR 0 7
46902: PUSH
46903: LD_VAR 0 8
46907: PUSH
46908: FOR_IN
46909: IFFALSE 46937
// if i [ 1 ] = b_ext_radar then
46911: LD_VAR 0 7
46915: PUSH
46916: LD_INT 1
46918: ARRAY
46919: PUSH
46920: LD_INT 20
46922: EQUAL
46923: IFFALSE 46935
// begin control := control_remote ;
46925: LD_ADDR_VAR 0 4
46929: PUSH
46930: LD_INT 2
46932: ST_TO_ADDR
// break ;
46933: GO 46937
// end ;
46935: GO 46908
46937: POP
46938: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
46939: LD_VAR 0 1
46943: PPUSH
46944: LD_VAR 0 2
46948: PPUSH
46949: LD_VAR 0 3
46953: PPUSH
46954: LD_VAR 0 4
46958: PPUSH
46959: LD_VAR 0 5
46963: PPUSH
46964: CALL_OW 448
46968: IFFALSE 47003
// begin result := [ chassis , engine , control , weapon ] ;
46970: LD_ADDR_VAR 0 6
46974: PUSH
46975: LD_VAR 0 2
46979: PUSH
46980: LD_VAR 0 3
46984: PUSH
46985: LD_VAR 0 4
46989: PUSH
46990: LD_VAR 0 5
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: ST_TO_ADDR
// exit ;
47001: GO 47347
// end ; _chassis := AvailableChassisList ( factory ) ;
47003: LD_ADDR_VAR 0 9
47007: PUSH
47008: LD_VAR 0 1
47012: PPUSH
47013: CALL_OW 475
47017: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
47018: LD_ADDR_VAR 0 11
47022: PUSH
47023: LD_VAR 0 1
47027: PPUSH
47028: CALL_OW 476
47032: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
47033: LD_ADDR_VAR 0 12
47037: PUSH
47038: LD_VAR 0 1
47042: PPUSH
47043: CALL_OW 477
47047: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
47048: LD_ADDR_VAR 0 10
47052: PUSH
47053: LD_VAR 0 1
47057: PPUSH
47058: CALL_OW 478
47062: ST_TO_ADDR
// if not chassis in _chassis then
47063: LD_VAR 0 2
47067: PUSH
47068: LD_VAR 0 9
47072: IN
47073: NOT
47074: IFFALSE 47100
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
47076: LD_ADDR_VAR 0 2
47080: PUSH
47081: LD_VAR 0 9
47085: PUSH
47086: LD_INT 1
47088: PPUSH
47089: LD_VAR 0 9
47093: PPUSH
47094: CALL_OW 12
47098: ARRAY
47099: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
47100: LD_VAR 0 2
47104: PPUSH
47105: LD_VAR 0 3
47109: PPUSH
47110: CALL 47352 0 2
47114: NOT
47115: IFFALSE 47174
// repeat engine := _engine [ 1 ] ;
47117: LD_ADDR_VAR 0 3
47121: PUSH
47122: LD_VAR 0 11
47126: PUSH
47127: LD_INT 1
47129: ARRAY
47130: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
47131: LD_ADDR_VAR 0 11
47135: PUSH
47136: LD_VAR 0 11
47140: PPUSH
47141: LD_INT 1
47143: PPUSH
47144: CALL_OW 3
47148: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
47149: LD_VAR 0 2
47153: PPUSH
47154: LD_VAR 0 3
47158: PPUSH
47159: CALL 47352 0 2
47163: PUSH
47164: LD_VAR 0 11
47168: PUSH
47169: EMPTY
47170: EQUAL
47171: OR
47172: IFFALSE 47117
// if not control in _control then
47174: LD_VAR 0 4
47178: PUSH
47179: LD_VAR 0 12
47183: IN
47184: NOT
47185: IFFALSE 47211
// control := _control [ rand ( 1 , _control ) ] ;
47187: LD_ADDR_VAR 0 4
47191: PUSH
47192: LD_VAR 0 12
47196: PUSH
47197: LD_INT 1
47199: PPUSH
47200: LD_VAR 0 12
47204: PPUSH
47205: CALL_OW 12
47209: ARRAY
47210: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
47211: LD_VAR 0 2
47215: PPUSH
47216: LD_VAR 0 5
47220: PPUSH
47221: CALL 47572 0 2
47225: NOT
47226: IFFALSE 47285
// repeat weapon := _weapon [ 1 ] ;
47228: LD_ADDR_VAR 0 5
47232: PUSH
47233: LD_VAR 0 10
47237: PUSH
47238: LD_INT 1
47240: ARRAY
47241: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
47242: LD_ADDR_VAR 0 10
47246: PUSH
47247: LD_VAR 0 10
47251: PPUSH
47252: LD_INT 1
47254: PPUSH
47255: CALL_OW 3
47259: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
47260: LD_VAR 0 2
47264: PPUSH
47265: LD_VAR 0 5
47269: PPUSH
47270: CALL 47572 0 2
47274: PUSH
47275: LD_VAR 0 10
47279: PUSH
47280: EMPTY
47281: EQUAL
47282: OR
47283: IFFALSE 47228
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
47285: LD_VAR 0 1
47289: PPUSH
47290: LD_VAR 0 2
47294: PPUSH
47295: LD_VAR 0 3
47299: PPUSH
47300: LD_VAR 0 4
47304: PPUSH
47305: LD_VAR 0 5
47309: PPUSH
47310: CALL_OW 448
47314: IFFALSE 47347
// result := [ chassis , engine , control , weapon ] ;
47316: LD_ADDR_VAR 0 6
47320: PUSH
47321: LD_VAR 0 2
47325: PUSH
47326: LD_VAR 0 3
47330: PUSH
47331: LD_VAR 0 4
47335: PUSH
47336: LD_VAR 0 5
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: ST_TO_ADDR
// end ;
47347: LD_VAR 0 6
47351: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
47352: LD_INT 0
47354: PPUSH
// if not chassis or not engine then
47355: LD_VAR 0 1
47359: NOT
47360: PUSH
47361: LD_VAR 0 2
47365: NOT
47366: OR
47367: IFFALSE 47371
// exit ;
47369: GO 47567
// case engine of engine_solar :
47371: LD_VAR 0 2
47375: PUSH
47376: LD_INT 2
47378: DOUBLE
47379: EQUAL
47380: IFTRUE 47384
47382: GO 47422
47384: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
47385: LD_ADDR_VAR 0 3
47389: PUSH
47390: LD_INT 11
47392: PUSH
47393: LD_INT 12
47395: PUSH
47396: LD_INT 13
47398: PUSH
47399: LD_INT 14
47401: PUSH
47402: LD_INT 1
47404: PUSH
47405: LD_INT 2
47407: PUSH
47408: LD_INT 3
47410: PUSH
47411: EMPTY
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: ST_TO_ADDR
47420: GO 47551
47422: LD_INT 1
47424: DOUBLE
47425: EQUAL
47426: IFTRUE 47430
47428: GO 47492
47430: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
47431: LD_ADDR_VAR 0 3
47435: PUSH
47436: LD_INT 11
47438: PUSH
47439: LD_INT 12
47441: PUSH
47442: LD_INT 13
47444: PUSH
47445: LD_INT 14
47447: PUSH
47448: LD_INT 1
47450: PUSH
47451: LD_INT 2
47453: PUSH
47454: LD_INT 3
47456: PUSH
47457: LD_INT 4
47459: PUSH
47460: LD_INT 5
47462: PUSH
47463: LD_INT 21
47465: PUSH
47466: LD_INT 23
47468: PUSH
47469: LD_INT 22
47471: PUSH
47472: LD_INT 24
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: ST_TO_ADDR
47490: GO 47551
47492: LD_INT 3
47494: DOUBLE
47495: EQUAL
47496: IFTRUE 47500
47498: GO 47550
47500: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
47501: LD_ADDR_VAR 0 3
47505: PUSH
47506: LD_INT 13
47508: PUSH
47509: LD_INT 14
47511: PUSH
47512: LD_INT 2
47514: PUSH
47515: LD_INT 3
47517: PUSH
47518: LD_INT 4
47520: PUSH
47521: LD_INT 5
47523: PUSH
47524: LD_INT 21
47526: PUSH
47527: LD_INT 22
47529: PUSH
47530: LD_INT 23
47532: PUSH
47533: LD_INT 24
47535: PUSH
47536: EMPTY
47537: LIST
47538: LIST
47539: LIST
47540: LIST
47541: LIST
47542: LIST
47543: LIST
47544: LIST
47545: LIST
47546: LIST
47547: ST_TO_ADDR
47548: GO 47551
47550: POP
// result := ( chassis in result ) ;
47551: LD_ADDR_VAR 0 3
47555: PUSH
47556: LD_VAR 0 1
47560: PUSH
47561: LD_VAR 0 3
47565: IN
47566: ST_TO_ADDR
// end ;
47567: LD_VAR 0 3
47571: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
47572: LD_INT 0
47574: PPUSH
// if not chassis or not weapon then
47575: LD_VAR 0 1
47579: NOT
47580: PUSH
47581: LD_VAR 0 2
47585: NOT
47586: OR
47587: IFFALSE 47591
// exit ;
47589: GO 48617
// case weapon of us_machine_gun :
47591: LD_VAR 0 2
47595: PUSH
47596: LD_INT 2
47598: DOUBLE
47599: EQUAL
47600: IFTRUE 47604
47602: GO 47634
47604: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
47605: LD_ADDR_VAR 0 3
47609: PUSH
47610: LD_INT 1
47612: PUSH
47613: LD_INT 2
47615: PUSH
47616: LD_INT 3
47618: PUSH
47619: LD_INT 4
47621: PUSH
47622: LD_INT 5
47624: PUSH
47625: EMPTY
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: ST_TO_ADDR
47632: GO 48601
47634: LD_INT 3
47636: DOUBLE
47637: EQUAL
47638: IFTRUE 47642
47640: GO 47672
47642: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
47643: LD_ADDR_VAR 0 3
47647: PUSH
47648: LD_INT 1
47650: PUSH
47651: LD_INT 2
47653: PUSH
47654: LD_INT 3
47656: PUSH
47657: LD_INT 4
47659: PUSH
47660: LD_INT 5
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: ST_TO_ADDR
47670: GO 48601
47672: LD_INT 11
47674: DOUBLE
47675: EQUAL
47676: IFTRUE 47680
47678: GO 47710
47680: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
47681: LD_ADDR_VAR 0 3
47685: PUSH
47686: LD_INT 1
47688: PUSH
47689: LD_INT 2
47691: PUSH
47692: LD_INT 3
47694: PUSH
47695: LD_INT 4
47697: PUSH
47698: LD_INT 5
47700: PUSH
47701: EMPTY
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: ST_TO_ADDR
47708: GO 48601
47710: LD_INT 4
47712: DOUBLE
47713: EQUAL
47714: IFTRUE 47718
47716: GO 47744
47718: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
47719: LD_ADDR_VAR 0 3
47723: PUSH
47724: LD_INT 2
47726: PUSH
47727: LD_INT 3
47729: PUSH
47730: LD_INT 4
47732: PUSH
47733: LD_INT 5
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: ST_TO_ADDR
47742: GO 48601
47744: LD_INT 5
47746: DOUBLE
47747: EQUAL
47748: IFTRUE 47752
47750: GO 47778
47752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
47753: LD_ADDR_VAR 0 3
47757: PUSH
47758: LD_INT 2
47760: PUSH
47761: LD_INT 3
47763: PUSH
47764: LD_INT 4
47766: PUSH
47767: LD_INT 5
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: ST_TO_ADDR
47776: GO 48601
47778: LD_INT 9
47780: DOUBLE
47781: EQUAL
47782: IFTRUE 47786
47784: GO 47812
47786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
47787: LD_ADDR_VAR 0 3
47791: PUSH
47792: LD_INT 2
47794: PUSH
47795: LD_INT 3
47797: PUSH
47798: LD_INT 4
47800: PUSH
47801: LD_INT 5
47803: PUSH
47804: EMPTY
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: ST_TO_ADDR
47810: GO 48601
47812: LD_INT 7
47814: DOUBLE
47815: EQUAL
47816: IFTRUE 47820
47818: GO 47846
47820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
47821: LD_ADDR_VAR 0 3
47825: PUSH
47826: LD_INT 2
47828: PUSH
47829: LD_INT 3
47831: PUSH
47832: LD_INT 4
47834: PUSH
47835: LD_INT 5
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: ST_TO_ADDR
47844: GO 48601
47846: LD_INT 12
47848: DOUBLE
47849: EQUAL
47850: IFTRUE 47854
47852: GO 47880
47854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
47855: LD_ADDR_VAR 0 3
47859: PUSH
47860: LD_INT 2
47862: PUSH
47863: LD_INT 3
47865: PUSH
47866: LD_INT 4
47868: PUSH
47869: LD_INT 5
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: ST_TO_ADDR
47878: GO 48601
47880: LD_INT 13
47882: DOUBLE
47883: EQUAL
47884: IFTRUE 47888
47886: GO 47914
47888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
47889: LD_ADDR_VAR 0 3
47893: PUSH
47894: LD_INT 2
47896: PUSH
47897: LD_INT 3
47899: PUSH
47900: LD_INT 4
47902: PUSH
47903: LD_INT 5
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: ST_TO_ADDR
47912: GO 48601
47914: LD_INT 14
47916: DOUBLE
47917: EQUAL
47918: IFTRUE 47922
47920: GO 47940
47922: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
47923: LD_ADDR_VAR 0 3
47927: PUSH
47928: LD_INT 4
47930: PUSH
47931: LD_INT 5
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: ST_TO_ADDR
47938: GO 48601
47940: LD_INT 6
47942: DOUBLE
47943: EQUAL
47944: IFTRUE 47948
47946: GO 47966
47948: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
47949: LD_ADDR_VAR 0 3
47953: PUSH
47954: LD_INT 4
47956: PUSH
47957: LD_INT 5
47959: PUSH
47960: EMPTY
47961: LIST
47962: LIST
47963: ST_TO_ADDR
47964: GO 48601
47966: LD_INT 10
47968: DOUBLE
47969: EQUAL
47970: IFTRUE 47974
47972: GO 47992
47974: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
47975: LD_ADDR_VAR 0 3
47979: PUSH
47980: LD_INT 4
47982: PUSH
47983: LD_INT 5
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: ST_TO_ADDR
47990: GO 48601
47992: LD_INT 22
47994: DOUBLE
47995: EQUAL
47996: IFTRUE 48000
47998: GO 48026
48000: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
48001: LD_ADDR_VAR 0 3
48005: PUSH
48006: LD_INT 11
48008: PUSH
48009: LD_INT 12
48011: PUSH
48012: LD_INT 13
48014: PUSH
48015: LD_INT 14
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: ST_TO_ADDR
48024: GO 48601
48026: LD_INT 23
48028: DOUBLE
48029: EQUAL
48030: IFTRUE 48034
48032: GO 48060
48034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
48035: LD_ADDR_VAR 0 3
48039: PUSH
48040: LD_INT 11
48042: PUSH
48043: LD_INT 12
48045: PUSH
48046: LD_INT 13
48048: PUSH
48049: LD_INT 14
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: ST_TO_ADDR
48058: GO 48601
48060: LD_INT 24
48062: DOUBLE
48063: EQUAL
48064: IFTRUE 48068
48066: GO 48094
48068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
48069: LD_ADDR_VAR 0 3
48073: PUSH
48074: LD_INT 11
48076: PUSH
48077: LD_INT 12
48079: PUSH
48080: LD_INT 13
48082: PUSH
48083: LD_INT 14
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: ST_TO_ADDR
48092: GO 48601
48094: LD_INT 30
48096: DOUBLE
48097: EQUAL
48098: IFTRUE 48102
48100: GO 48128
48102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
48103: LD_ADDR_VAR 0 3
48107: PUSH
48108: LD_INT 11
48110: PUSH
48111: LD_INT 12
48113: PUSH
48114: LD_INT 13
48116: PUSH
48117: LD_INT 14
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: ST_TO_ADDR
48126: GO 48601
48128: LD_INT 25
48130: DOUBLE
48131: EQUAL
48132: IFTRUE 48136
48134: GO 48154
48136: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
48137: LD_ADDR_VAR 0 3
48141: PUSH
48142: LD_INT 13
48144: PUSH
48145: LD_INT 14
48147: PUSH
48148: EMPTY
48149: LIST
48150: LIST
48151: ST_TO_ADDR
48152: GO 48601
48154: LD_INT 27
48156: DOUBLE
48157: EQUAL
48158: IFTRUE 48162
48160: GO 48180
48162: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
48163: LD_ADDR_VAR 0 3
48167: PUSH
48168: LD_INT 13
48170: PUSH
48171: LD_INT 14
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: ST_TO_ADDR
48178: GO 48601
48180: LD_INT 28
48182: DOUBLE
48183: EQUAL
48184: IFTRUE 48188
48186: GO 48206
48188: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
48189: LD_ADDR_VAR 0 3
48193: PUSH
48194: LD_INT 13
48196: PUSH
48197: LD_INT 14
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: ST_TO_ADDR
48204: GO 48601
48206: LD_INT 29
48208: DOUBLE
48209: EQUAL
48210: IFTRUE 48214
48212: GO 48232
48214: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
48215: LD_ADDR_VAR 0 3
48219: PUSH
48220: LD_INT 13
48222: PUSH
48223: LD_INT 14
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: ST_TO_ADDR
48230: GO 48601
48232: LD_INT 31
48234: DOUBLE
48235: EQUAL
48236: IFTRUE 48240
48238: GO 48258
48240: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
48241: LD_ADDR_VAR 0 3
48245: PUSH
48246: LD_INT 13
48248: PUSH
48249: LD_INT 14
48251: PUSH
48252: EMPTY
48253: LIST
48254: LIST
48255: ST_TO_ADDR
48256: GO 48601
48258: LD_INT 26
48260: DOUBLE
48261: EQUAL
48262: IFTRUE 48266
48264: GO 48284
48266: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
48267: LD_ADDR_VAR 0 3
48271: PUSH
48272: LD_INT 13
48274: PUSH
48275: LD_INT 14
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: ST_TO_ADDR
48282: GO 48601
48284: LD_INT 42
48286: DOUBLE
48287: EQUAL
48288: IFTRUE 48292
48290: GO 48318
48292: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
48293: LD_ADDR_VAR 0 3
48297: PUSH
48298: LD_INT 21
48300: PUSH
48301: LD_INT 22
48303: PUSH
48304: LD_INT 23
48306: PUSH
48307: LD_INT 24
48309: PUSH
48310: EMPTY
48311: LIST
48312: LIST
48313: LIST
48314: LIST
48315: ST_TO_ADDR
48316: GO 48601
48318: LD_INT 43
48320: DOUBLE
48321: EQUAL
48322: IFTRUE 48326
48324: GO 48352
48326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
48327: LD_ADDR_VAR 0 3
48331: PUSH
48332: LD_INT 21
48334: PUSH
48335: LD_INT 22
48337: PUSH
48338: LD_INT 23
48340: PUSH
48341: LD_INT 24
48343: PUSH
48344: EMPTY
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: ST_TO_ADDR
48350: GO 48601
48352: LD_INT 44
48354: DOUBLE
48355: EQUAL
48356: IFTRUE 48360
48358: GO 48386
48360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
48361: LD_ADDR_VAR 0 3
48365: PUSH
48366: LD_INT 21
48368: PUSH
48369: LD_INT 22
48371: PUSH
48372: LD_INT 23
48374: PUSH
48375: LD_INT 24
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: ST_TO_ADDR
48384: GO 48601
48386: LD_INT 45
48388: DOUBLE
48389: EQUAL
48390: IFTRUE 48394
48392: GO 48420
48394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
48395: LD_ADDR_VAR 0 3
48399: PUSH
48400: LD_INT 21
48402: PUSH
48403: LD_INT 22
48405: PUSH
48406: LD_INT 23
48408: PUSH
48409: LD_INT 24
48411: PUSH
48412: EMPTY
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: ST_TO_ADDR
48418: GO 48601
48420: LD_INT 49
48422: DOUBLE
48423: EQUAL
48424: IFTRUE 48428
48426: GO 48454
48428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
48429: LD_ADDR_VAR 0 3
48433: PUSH
48434: LD_INT 21
48436: PUSH
48437: LD_INT 22
48439: PUSH
48440: LD_INT 23
48442: PUSH
48443: LD_INT 24
48445: PUSH
48446: EMPTY
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: ST_TO_ADDR
48452: GO 48601
48454: LD_INT 51
48456: DOUBLE
48457: EQUAL
48458: IFTRUE 48462
48460: GO 48488
48462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
48463: LD_ADDR_VAR 0 3
48467: PUSH
48468: LD_INT 21
48470: PUSH
48471: LD_INT 22
48473: PUSH
48474: LD_INT 23
48476: PUSH
48477: LD_INT 24
48479: PUSH
48480: EMPTY
48481: LIST
48482: LIST
48483: LIST
48484: LIST
48485: ST_TO_ADDR
48486: GO 48601
48488: LD_INT 52
48490: DOUBLE
48491: EQUAL
48492: IFTRUE 48496
48494: GO 48522
48496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
48497: LD_ADDR_VAR 0 3
48501: PUSH
48502: LD_INT 21
48504: PUSH
48505: LD_INT 22
48507: PUSH
48508: LD_INT 23
48510: PUSH
48511: LD_INT 24
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: LIST
48518: LIST
48519: ST_TO_ADDR
48520: GO 48601
48522: LD_INT 53
48524: DOUBLE
48525: EQUAL
48526: IFTRUE 48530
48528: GO 48548
48530: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
48531: LD_ADDR_VAR 0 3
48535: PUSH
48536: LD_INT 23
48538: PUSH
48539: LD_INT 24
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: ST_TO_ADDR
48546: GO 48601
48548: LD_INT 46
48550: DOUBLE
48551: EQUAL
48552: IFTRUE 48556
48554: GO 48574
48556: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
48557: LD_ADDR_VAR 0 3
48561: PUSH
48562: LD_INT 23
48564: PUSH
48565: LD_INT 24
48567: PUSH
48568: EMPTY
48569: LIST
48570: LIST
48571: ST_TO_ADDR
48572: GO 48601
48574: LD_INT 47
48576: DOUBLE
48577: EQUAL
48578: IFTRUE 48582
48580: GO 48600
48582: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
48583: LD_ADDR_VAR 0 3
48587: PUSH
48588: LD_INT 23
48590: PUSH
48591: LD_INT 24
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: ST_TO_ADDR
48598: GO 48601
48600: POP
// result := ( chassis in result ) ;
48601: LD_ADDR_VAR 0 3
48605: PUSH
48606: LD_VAR 0 1
48610: PUSH
48611: LD_VAR 0 3
48615: IN
48616: ST_TO_ADDR
// end ;
48617: LD_VAR 0 3
48621: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
48622: LD_INT 0
48624: PPUSH
48625: PPUSH
48626: PPUSH
48627: PPUSH
48628: PPUSH
48629: PPUSH
48630: PPUSH
// result := array ;
48631: LD_ADDR_VAR 0 5
48635: PUSH
48636: LD_VAR 0 1
48640: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
48641: LD_VAR 0 1
48645: NOT
48646: PUSH
48647: LD_VAR 0 2
48651: NOT
48652: OR
48653: PUSH
48654: LD_VAR 0 3
48658: NOT
48659: OR
48660: PUSH
48661: LD_VAR 0 2
48665: PUSH
48666: LD_VAR 0 1
48670: GREATER
48671: OR
48672: PUSH
48673: LD_VAR 0 3
48677: PUSH
48678: LD_VAR 0 1
48682: GREATER
48683: OR
48684: IFFALSE 48688
// exit ;
48686: GO 48984
// if direction then
48688: LD_VAR 0 4
48692: IFFALSE 48756
// begin d := 1 ;
48694: LD_ADDR_VAR 0 9
48698: PUSH
48699: LD_INT 1
48701: ST_TO_ADDR
// if i_from > i_to then
48702: LD_VAR 0 2
48706: PUSH
48707: LD_VAR 0 3
48711: GREATER
48712: IFFALSE 48738
// length := ( array - i_from ) + i_to else
48714: LD_ADDR_VAR 0 11
48718: PUSH
48719: LD_VAR 0 1
48723: PUSH
48724: LD_VAR 0 2
48728: MINUS
48729: PUSH
48730: LD_VAR 0 3
48734: PLUS
48735: ST_TO_ADDR
48736: GO 48754
// length := i_to - i_from ;
48738: LD_ADDR_VAR 0 11
48742: PUSH
48743: LD_VAR 0 3
48747: PUSH
48748: LD_VAR 0 2
48752: MINUS
48753: ST_TO_ADDR
// end else
48754: GO 48817
// begin d := - 1 ;
48756: LD_ADDR_VAR 0 9
48760: PUSH
48761: LD_INT 1
48763: NEG
48764: ST_TO_ADDR
// if i_from > i_to then
48765: LD_VAR 0 2
48769: PUSH
48770: LD_VAR 0 3
48774: GREATER
48775: IFFALSE 48795
// length := i_from - i_to else
48777: LD_ADDR_VAR 0 11
48781: PUSH
48782: LD_VAR 0 2
48786: PUSH
48787: LD_VAR 0 3
48791: MINUS
48792: ST_TO_ADDR
48793: GO 48817
// length := ( array - i_to ) + i_from ;
48795: LD_ADDR_VAR 0 11
48799: PUSH
48800: LD_VAR 0 1
48804: PUSH
48805: LD_VAR 0 3
48809: MINUS
48810: PUSH
48811: LD_VAR 0 2
48815: PLUS
48816: ST_TO_ADDR
// end ; if not length then
48817: LD_VAR 0 11
48821: NOT
48822: IFFALSE 48826
// exit ;
48824: GO 48984
// tmp := array ;
48826: LD_ADDR_VAR 0 10
48830: PUSH
48831: LD_VAR 0 1
48835: ST_TO_ADDR
// for i = 1 to length do
48836: LD_ADDR_VAR 0 6
48840: PUSH
48841: DOUBLE
48842: LD_INT 1
48844: DEC
48845: ST_TO_ADDR
48846: LD_VAR 0 11
48850: PUSH
48851: FOR_TO
48852: IFFALSE 48972
// begin for j = 1 to array do
48854: LD_ADDR_VAR 0 7
48858: PUSH
48859: DOUBLE
48860: LD_INT 1
48862: DEC
48863: ST_TO_ADDR
48864: LD_VAR 0 1
48868: PUSH
48869: FOR_TO
48870: IFFALSE 48958
// begin k := j + d ;
48872: LD_ADDR_VAR 0 8
48876: PUSH
48877: LD_VAR 0 7
48881: PUSH
48882: LD_VAR 0 9
48886: PLUS
48887: ST_TO_ADDR
// if k > array then
48888: LD_VAR 0 8
48892: PUSH
48893: LD_VAR 0 1
48897: GREATER
48898: IFFALSE 48908
// k := 1 ;
48900: LD_ADDR_VAR 0 8
48904: PUSH
48905: LD_INT 1
48907: ST_TO_ADDR
// if not k then
48908: LD_VAR 0 8
48912: NOT
48913: IFFALSE 48925
// k := array ;
48915: LD_ADDR_VAR 0 8
48919: PUSH
48920: LD_VAR 0 1
48924: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
48925: LD_ADDR_VAR 0 10
48929: PUSH
48930: LD_VAR 0 10
48934: PPUSH
48935: LD_VAR 0 8
48939: PPUSH
48940: LD_VAR 0 1
48944: PUSH
48945: LD_VAR 0 7
48949: ARRAY
48950: PPUSH
48951: CALL_OW 1
48955: ST_TO_ADDR
// end ;
48956: GO 48869
48958: POP
48959: POP
// array := tmp ;
48960: LD_ADDR_VAR 0 1
48964: PUSH
48965: LD_VAR 0 10
48969: ST_TO_ADDR
// end ;
48970: GO 48851
48972: POP
48973: POP
// result := array ;
48974: LD_ADDR_VAR 0 5
48978: PUSH
48979: LD_VAR 0 1
48983: ST_TO_ADDR
// end ;
48984: LD_VAR 0 5
48988: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
48989: LD_INT 0
48991: PPUSH
48992: PPUSH
// result := 0 ;
48993: LD_ADDR_VAR 0 3
48997: PUSH
48998: LD_INT 0
49000: ST_TO_ADDR
// if not array or not value in array then
49001: LD_VAR 0 1
49005: NOT
49006: PUSH
49007: LD_VAR 0 2
49011: PUSH
49012: LD_VAR 0 1
49016: IN
49017: NOT
49018: OR
49019: IFFALSE 49023
// exit ;
49021: GO 49077
// for i = 1 to array do
49023: LD_ADDR_VAR 0 4
49027: PUSH
49028: DOUBLE
49029: LD_INT 1
49031: DEC
49032: ST_TO_ADDR
49033: LD_VAR 0 1
49037: PUSH
49038: FOR_TO
49039: IFFALSE 49075
// if value = array [ i ] then
49041: LD_VAR 0 2
49045: PUSH
49046: LD_VAR 0 1
49050: PUSH
49051: LD_VAR 0 4
49055: ARRAY
49056: EQUAL
49057: IFFALSE 49073
// begin result := i ;
49059: LD_ADDR_VAR 0 3
49063: PUSH
49064: LD_VAR 0 4
49068: ST_TO_ADDR
// exit ;
49069: POP
49070: POP
49071: GO 49077
// end ;
49073: GO 49038
49075: POP
49076: POP
// end ;
49077: LD_VAR 0 3
49081: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
49082: LD_INT 0
49084: PPUSH
// vc_chassis := chassis ;
49085: LD_ADDR_OWVAR 37
49089: PUSH
49090: LD_VAR 0 1
49094: ST_TO_ADDR
// vc_engine := engine ;
49095: LD_ADDR_OWVAR 39
49099: PUSH
49100: LD_VAR 0 2
49104: ST_TO_ADDR
// vc_control := control ;
49105: LD_ADDR_OWVAR 38
49109: PUSH
49110: LD_VAR 0 3
49114: ST_TO_ADDR
// vc_weapon := weapon ;
49115: LD_ADDR_OWVAR 40
49119: PUSH
49120: LD_VAR 0 4
49124: ST_TO_ADDR
// vc_fuel_battery := fuel ;
49125: LD_ADDR_OWVAR 41
49129: PUSH
49130: LD_VAR 0 5
49134: ST_TO_ADDR
// end ;
49135: LD_VAR 0 6
49139: RET
// export function WantPlant ( unit ) ; var task ; begin
49140: LD_INT 0
49142: PPUSH
49143: PPUSH
// result := false ;
49144: LD_ADDR_VAR 0 2
49148: PUSH
49149: LD_INT 0
49151: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
49152: LD_ADDR_VAR 0 3
49156: PUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL_OW 437
49166: ST_TO_ADDR
// if task then
49167: LD_VAR 0 3
49171: IFFALSE 49199
// if task [ 1 ] [ 1 ] = p then
49173: LD_VAR 0 3
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: PUSH
49182: LD_INT 1
49184: ARRAY
49185: PUSH
49186: LD_STRING p
49188: EQUAL
49189: IFFALSE 49199
// result := true ;
49191: LD_ADDR_VAR 0 2
49195: PUSH
49196: LD_INT 1
49198: ST_TO_ADDR
// end ;
49199: LD_VAR 0 2
49203: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
49204: LD_INT 0
49206: PPUSH
49207: PPUSH
49208: PPUSH
49209: PPUSH
// if pos < 1 then
49210: LD_VAR 0 2
49214: PUSH
49215: LD_INT 1
49217: LESS
49218: IFFALSE 49222
// exit ;
49220: GO 49525
// if pos = 1 then
49222: LD_VAR 0 2
49226: PUSH
49227: LD_INT 1
49229: EQUAL
49230: IFFALSE 49263
// result := Replace ( arr , pos [ 1 ] , value ) else
49232: LD_ADDR_VAR 0 4
49236: PUSH
49237: LD_VAR 0 1
49241: PPUSH
49242: LD_VAR 0 2
49246: PUSH
49247: LD_INT 1
49249: ARRAY
49250: PPUSH
49251: LD_VAR 0 3
49255: PPUSH
49256: CALL_OW 1
49260: ST_TO_ADDR
49261: GO 49525
// begin tmp := arr ;
49263: LD_ADDR_VAR 0 6
49267: PUSH
49268: LD_VAR 0 1
49272: ST_TO_ADDR
// s_arr := [ tmp ] ;
49273: LD_ADDR_VAR 0 7
49277: PUSH
49278: LD_VAR 0 6
49282: PUSH
49283: EMPTY
49284: LIST
49285: ST_TO_ADDR
// for i = 1 to pos - 1 do
49286: LD_ADDR_VAR 0 5
49290: PUSH
49291: DOUBLE
49292: LD_INT 1
49294: DEC
49295: ST_TO_ADDR
49296: LD_VAR 0 2
49300: PUSH
49301: LD_INT 1
49303: MINUS
49304: PUSH
49305: FOR_TO
49306: IFFALSE 49351
// begin tmp := tmp [ pos [ i ] ] ;
49308: LD_ADDR_VAR 0 6
49312: PUSH
49313: LD_VAR 0 6
49317: PUSH
49318: LD_VAR 0 2
49322: PUSH
49323: LD_VAR 0 5
49327: ARRAY
49328: ARRAY
49329: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
49330: LD_ADDR_VAR 0 7
49334: PUSH
49335: LD_VAR 0 7
49339: PUSH
49340: LD_VAR 0 6
49344: PUSH
49345: EMPTY
49346: LIST
49347: ADD
49348: ST_TO_ADDR
// end ;
49349: GO 49305
49351: POP
49352: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
49353: LD_ADDR_VAR 0 6
49357: PUSH
49358: LD_VAR 0 6
49362: PPUSH
49363: LD_VAR 0 2
49367: PUSH
49368: LD_VAR 0 2
49372: ARRAY
49373: PPUSH
49374: LD_VAR 0 3
49378: PPUSH
49379: CALL_OW 1
49383: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
49384: LD_ADDR_VAR 0 7
49388: PUSH
49389: LD_VAR 0 7
49393: PPUSH
49394: LD_VAR 0 7
49398: PPUSH
49399: LD_VAR 0 6
49403: PPUSH
49404: CALL_OW 1
49408: ST_TO_ADDR
// for i = s_arr downto 2 do
49409: LD_ADDR_VAR 0 5
49413: PUSH
49414: DOUBLE
49415: LD_VAR 0 7
49419: INC
49420: ST_TO_ADDR
49421: LD_INT 2
49423: PUSH
49424: FOR_DOWNTO
49425: IFFALSE 49509
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
49427: LD_ADDR_VAR 0 6
49431: PUSH
49432: LD_VAR 0 7
49436: PUSH
49437: LD_VAR 0 5
49441: PUSH
49442: LD_INT 1
49444: MINUS
49445: ARRAY
49446: PPUSH
49447: LD_VAR 0 2
49451: PUSH
49452: LD_VAR 0 5
49456: PUSH
49457: LD_INT 1
49459: MINUS
49460: ARRAY
49461: PPUSH
49462: LD_VAR 0 7
49466: PUSH
49467: LD_VAR 0 5
49471: ARRAY
49472: PPUSH
49473: CALL_OW 1
49477: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
49478: LD_ADDR_VAR 0 7
49482: PUSH
49483: LD_VAR 0 7
49487: PPUSH
49488: LD_VAR 0 5
49492: PUSH
49493: LD_INT 1
49495: MINUS
49496: PPUSH
49497: LD_VAR 0 6
49501: PPUSH
49502: CALL_OW 1
49506: ST_TO_ADDR
// end ;
49507: GO 49424
49509: POP
49510: POP
// result := s_arr [ 1 ] ;
49511: LD_ADDR_VAR 0 4
49515: PUSH
49516: LD_VAR 0 7
49520: PUSH
49521: LD_INT 1
49523: ARRAY
49524: ST_TO_ADDR
// end ; end ;
49525: LD_VAR 0 4
49529: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
49530: LD_INT 0
49532: PPUSH
49533: PPUSH
// if not list then
49534: LD_VAR 0 1
49538: NOT
49539: IFFALSE 49543
// exit ;
49541: GO 49634
// i := list [ pos1 ] ;
49543: LD_ADDR_VAR 0 5
49547: PUSH
49548: LD_VAR 0 1
49552: PUSH
49553: LD_VAR 0 2
49557: ARRAY
49558: ST_TO_ADDR
// if not i then
49559: LD_VAR 0 5
49563: NOT
49564: IFFALSE 49568
// exit ;
49566: GO 49634
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
49568: LD_ADDR_VAR 0 1
49572: PUSH
49573: LD_VAR 0 1
49577: PPUSH
49578: LD_VAR 0 2
49582: PPUSH
49583: LD_VAR 0 1
49587: PUSH
49588: LD_VAR 0 3
49592: ARRAY
49593: PPUSH
49594: CALL_OW 1
49598: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
49599: LD_ADDR_VAR 0 1
49603: PUSH
49604: LD_VAR 0 1
49608: PPUSH
49609: LD_VAR 0 3
49613: PPUSH
49614: LD_VAR 0 5
49618: PPUSH
49619: CALL_OW 1
49623: ST_TO_ADDR
// result := list ;
49624: LD_ADDR_VAR 0 4
49628: PUSH
49629: LD_VAR 0 1
49633: ST_TO_ADDR
// end ;
49634: LD_VAR 0 4
49638: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
49639: LD_INT 0
49641: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
49642: LD_ADDR_VAR 0 5
49646: PUSH
49647: LD_VAR 0 1
49651: PPUSH
49652: CALL_OW 250
49656: PPUSH
49657: LD_VAR 0 1
49661: PPUSH
49662: CALL_OW 251
49666: PPUSH
49667: LD_VAR 0 2
49671: PPUSH
49672: LD_VAR 0 3
49676: PPUSH
49677: LD_VAR 0 4
49681: PPUSH
49682: CALL 49692 0 5
49686: ST_TO_ADDR
// end ;
49687: LD_VAR 0 5
49691: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
49692: LD_INT 0
49694: PPUSH
49695: PPUSH
49696: PPUSH
49697: PPUSH
// if not list then
49698: LD_VAR 0 3
49702: NOT
49703: IFFALSE 49707
// exit ;
49705: GO 50095
// result := [ ] ;
49707: LD_ADDR_VAR 0 6
49711: PUSH
49712: EMPTY
49713: ST_TO_ADDR
// for i in list do
49714: LD_ADDR_VAR 0 7
49718: PUSH
49719: LD_VAR 0 3
49723: PUSH
49724: FOR_IN
49725: IFFALSE 49927
// begin tmp := GetDistUnitXY ( i , x , y ) ;
49727: LD_ADDR_VAR 0 9
49731: PUSH
49732: LD_VAR 0 7
49736: PPUSH
49737: LD_VAR 0 1
49741: PPUSH
49742: LD_VAR 0 2
49746: PPUSH
49747: CALL_OW 297
49751: ST_TO_ADDR
// if not result then
49752: LD_VAR 0 6
49756: NOT
49757: IFFALSE 49783
// result := [ [ i , tmp ] ] else
49759: LD_ADDR_VAR 0 6
49763: PUSH
49764: LD_VAR 0 7
49768: PUSH
49769: LD_VAR 0 9
49773: PUSH
49774: EMPTY
49775: LIST
49776: LIST
49777: PUSH
49778: EMPTY
49779: LIST
49780: ST_TO_ADDR
49781: GO 49925
// begin if result [ result ] [ 2 ] < tmp then
49783: LD_VAR 0 6
49787: PUSH
49788: LD_VAR 0 6
49792: ARRAY
49793: PUSH
49794: LD_INT 2
49796: ARRAY
49797: PUSH
49798: LD_VAR 0 9
49802: LESS
49803: IFFALSE 49845
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
49805: LD_ADDR_VAR 0 6
49809: PUSH
49810: LD_VAR 0 6
49814: PPUSH
49815: LD_VAR 0 6
49819: PUSH
49820: LD_INT 1
49822: PLUS
49823: PPUSH
49824: LD_VAR 0 7
49828: PUSH
49829: LD_VAR 0 9
49833: PUSH
49834: EMPTY
49835: LIST
49836: LIST
49837: PPUSH
49838: CALL_OW 2
49842: ST_TO_ADDR
49843: GO 49925
// for j = 1 to result do
49845: LD_ADDR_VAR 0 8
49849: PUSH
49850: DOUBLE
49851: LD_INT 1
49853: DEC
49854: ST_TO_ADDR
49855: LD_VAR 0 6
49859: PUSH
49860: FOR_TO
49861: IFFALSE 49923
// begin if tmp < result [ j ] [ 2 ] then
49863: LD_VAR 0 9
49867: PUSH
49868: LD_VAR 0 6
49872: PUSH
49873: LD_VAR 0 8
49877: ARRAY
49878: PUSH
49879: LD_INT 2
49881: ARRAY
49882: LESS
49883: IFFALSE 49921
// begin result := Insert ( result , j , [ i , tmp ] ) ;
49885: LD_ADDR_VAR 0 6
49889: PUSH
49890: LD_VAR 0 6
49894: PPUSH
49895: LD_VAR 0 8
49899: PPUSH
49900: LD_VAR 0 7
49904: PUSH
49905: LD_VAR 0 9
49909: PUSH
49910: EMPTY
49911: LIST
49912: LIST
49913: PPUSH
49914: CALL_OW 2
49918: ST_TO_ADDR
// break ;
49919: GO 49923
// end ; end ;
49921: GO 49860
49923: POP
49924: POP
// end ; end ;
49925: GO 49724
49927: POP
49928: POP
// if result and not asc then
49929: LD_VAR 0 6
49933: PUSH
49934: LD_VAR 0 4
49938: NOT
49939: AND
49940: IFFALSE 50015
// begin tmp := result ;
49942: LD_ADDR_VAR 0 9
49946: PUSH
49947: LD_VAR 0 6
49951: ST_TO_ADDR
// for i = tmp downto 1 do
49952: LD_ADDR_VAR 0 7
49956: PUSH
49957: DOUBLE
49958: LD_VAR 0 9
49962: INC
49963: ST_TO_ADDR
49964: LD_INT 1
49966: PUSH
49967: FOR_DOWNTO
49968: IFFALSE 50013
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
49970: LD_ADDR_VAR 0 6
49974: PUSH
49975: LD_VAR 0 6
49979: PPUSH
49980: LD_VAR 0 9
49984: PUSH
49985: LD_VAR 0 7
49989: MINUS
49990: PUSH
49991: LD_INT 1
49993: PLUS
49994: PPUSH
49995: LD_VAR 0 9
49999: PUSH
50000: LD_VAR 0 7
50004: ARRAY
50005: PPUSH
50006: CALL_OW 1
50010: ST_TO_ADDR
50011: GO 49967
50013: POP
50014: POP
// end ; tmp := [ ] ;
50015: LD_ADDR_VAR 0 9
50019: PUSH
50020: EMPTY
50021: ST_TO_ADDR
// if mode then
50022: LD_VAR 0 5
50026: IFFALSE 50095
// begin for i = 1 to result do
50028: LD_ADDR_VAR 0 7
50032: PUSH
50033: DOUBLE
50034: LD_INT 1
50036: DEC
50037: ST_TO_ADDR
50038: LD_VAR 0 6
50042: PUSH
50043: FOR_TO
50044: IFFALSE 50083
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
50046: LD_ADDR_VAR 0 9
50050: PUSH
50051: LD_VAR 0 9
50055: PPUSH
50056: LD_VAR 0 7
50060: PPUSH
50061: LD_VAR 0 6
50065: PUSH
50066: LD_VAR 0 7
50070: ARRAY
50071: PUSH
50072: LD_INT 1
50074: ARRAY
50075: PPUSH
50076: CALL_OW 1
50080: ST_TO_ADDR
50081: GO 50043
50083: POP
50084: POP
// result := tmp ;
50085: LD_ADDR_VAR 0 6
50089: PUSH
50090: LD_VAR 0 9
50094: ST_TO_ADDR
// end ; end ;
50095: LD_VAR 0 6
50099: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
50100: LD_INT 0
50102: PPUSH
50103: PPUSH
50104: PPUSH
50105: PPUSH
50106: PPUSH
50107: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
50108: LD_ADDR_VAR 0 5
50112: PUSH
50113: LD_INT 0
50115: PUSH
50116: LD_INT 0
50118: PUSH
50119: LD_INT 0
50121: PUSH
50122: EMPTY
50123: PUSH
50124: EMPTY
50125: LIST
50126: LIST
50127: LIST
50128: LIST
50129: ST_TO_ADDR
// if not x or not y then
50130: LD_VAR 0 2
50134: NOT
50135: PUSH
50136: LD_VAR 0 3
50140: NOT
50141: OR
50142: IFFALSE 50146
// exit ;
50144: GO 51792
// if not range then
50146: LD_VAR 0 4
50150: NOT
50151: IFFALSE 50161
// range := 10 ;
50153: LD_ADDR_VAR 0 4
50157: PUSH
50158: LD_INT 10
50160: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50161: LD_ADDR_VAR 0 8
50165: PUSH
50166: LD_INT 81
50168: PUSH
50169: LD_VAR 0 1
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 92
50180: PUSH
50181: LD_VAR 0 2
50185: PUSH
50186: LD_VAR 0 3
50190: PUSH
50191: LD_VAR 0 4
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: PUSH
50202: LD_INT 3
50204: PUSH
50205: LD_INT 21
50207: PUSH
50208: LD_INT 3
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: PUSH
50215: EMPTY
50216: LIST
50217: LIST
50218: PUSH
50219: EMPTY
50220: LIST
50221: LIST
50222: LIST
50223: PPUSH
50224: CALL_OW 69
50228: ST_TO_ADDR
// if not tmp then
50229: LD_VAR 0 8
50233: NOT
50234: IFFALSE 50238
// exit ;
50236: GO 51792
// for i in tmp do
50238: LD_ADDR_VAR 0 6
50242: PUSH
50243: LD_VAR 0 8
50247: PUSH
50248: FOR_IN
50249: IFFALSE 51767
// begin points := [ 0 , 0 , 0 ] ;
50251: LD_ADDR_VAR 0 9
50255: PUSH
50256: LD_INT 0
50258: PUSH
50259: LD_INT 0
50261: PUSH
50262: LD_INT 0
50264: PUSH
50265: EMPTY
50266: LIST
50267: LIST
50268: LIST
50269: ST_TO_ADDR
// bpoints := 1 ;
50270: LD_ADDR_VAR 0 10
50274: PUSH
50275: LD_INT 1
50277: ST_TO_ADDR
// case GetType ( i ) of unit_human :
50278: LD_VAR 0 6
50282: PPUSH
50283: CALL_OW 247
50287: PUSH
50288: LD_INT 1
50290: DOUBLE
50291: EQUAL
50292: IFTRUE 50296
50294: GO 50874
50296: POP
// begin if GetClass ( i ) = 1 then
50297: LD_VAR 0 6
50301: PPUSH
50302: CALL_OW 257
50306: PUSH
50307: LD_INT 1
50309: EQUAL
50310: IFFALSE 50331
// points := [ 10 , 5 , 3 ] ;
50312: LD_ADDR_VAR 0 9
50316: PUSH
50317: LD_INT 10
50319: PUSH
50320: LD_INT 5
50322: PUSH
50323: LD_INT 3
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: LIST
50330: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
50331: LD_VAR 0 6
50335: PPUSH
50336: CALL_OW 257
50340: PUSH
50341: LD_INT 2
50343: PUSH
50344: LD_INT 3
50346: PUSH
50347: LD_INT 4
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: LIST
50354: IN
50355: IFFALSE 50376
// points := [ 3 , 2 , 1 ] ;
50357: LD_ADDR_VAR 0 9
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 2
50367: PUSH
50368: LD_INT 1
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: LIST
50375: ST_TO_ADDR
// if GetClass ( i ) = 5 then
50376: LD_VAR 0 6
50380: PPUSH
50381: CALL_OW 257
50385: PUSH
50386: LD_INT 5
50388: EQUAL
50389: IFFALSE 50410
// points := [ 130 , 5 , 2 ] ;
50391: LD_ADDR_VAR 0 9
50395: PUSH
50396: LD_INT 130
50398: PUSH
50399: LD_INT 5
50401: PUSH
50402: LD_INT 2
50404: PUSH
50405: EMPTY
50406: LIST
50407: LIST
50408: LIST
50409: ST_TO_ADDR
// if GetClass ( i ) = 8 then
50410: LD_VAR 0 6
50414: PPUSH
50415: CALL_OW 257
50419: PUSH
50420: LD_INT 8
50422: EQUAL
50423: IFFALSE 50444
// points := [ 35 , 35 , 30 ] ;
50425: LD_ADDR_VAR 0 9
50429: PUSH
50430: LD_INT 35
50432: PUSH
50433: LD_INT 35
50435: PUSH
50436: LD_INT 30
50438: PUSH
50439: EMPTY
50440: LIST
50441: LIST
50442: LIST
50443: ST_TO_ADDR
// if GetClass ( i ) = 9 then
50444: LD_VAR 0 6
50448: PPUSH
50449: CALL_OW 257
50453: PUSH
50454: LD_INT 9
50456: EQUAL
50457: IFFALSE 50478
// points := [ 20 , 55 , 40 ] ;
50459: LD_ADDR_VAR 0 9
50463: PUSH
50464: LD_INT 20
50466: PUSH
50467: LD_INT 55
50469: PUSH
50470: LD_INT 40
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: LIST
50477: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
50478: LD_VAR 0 6
50482: PPUSH
50483: CALL_OW 257
50487: PUSH
50488: LD_INT 12
50490: PUSH
50491: LD_INT 16
50493: PUSH
50494: EMPTY
50495: LIST
50496: LIST
50497: IN
50498: IFFALSE 50519
// points := [ 5 , 3 , 2 ] ;
50500: LD_ADDR_VAR 0 9
50504: PUSH
50505: LD_INT 5
50507: PUSH
50508: LD_INT 3
50510: PUSH
50511: LD_INT 2
50513: PUSH
50514: EMPTY
50515: LIST
50516: LIST
50517: LIST
50518: ST_TO_ADDR
// if GetClass ( i ) = 17 then
50519: LD_VAR 0 6
50523: PPUSH
50524: CALL_OW 257
50528: PUSH
50529: LD_INT 17
50531: EQUAL
50532: IFFALSE 50553
// points := [ 100 , 50 , 75 ] ;
50534: LD_ADDR_VAR 0 9
50538: PUSH
50539: LD_INT 100
50541: PUSH
50542: LD_INT 50
50544: PUSH
50545: LD_INT 75
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: LIST
50552: ST_TO_ADDR
// if GetClass ( i ) = 15 then
50553: LD_VAR 0 6
50557: PPUSH
50558: CALL_OW 257
50562: PUSH
50563: LD_INT 15
50565: EQUAL
50566: IFFALSE 50587
// points := [ 10 , 5 , 3 ] ;
50568: LD_ADDR_VAR 0 9
50572: PUSH
50573: LD_INT 10
50575: PUSH
50576: LD_INT 5
50578: PUSH
50579: LD_INT 3
50581: PUSH
50582: EMPTY
50583: LIST
50584: LIST
50585: LIST
50586: ST_TO_ADDR
// if GetClass ( i ) = 14 then
50587: LD_VAR 0 6
50591: PPUSH
50592: CALL_OW 257
50596: PUSH
50597: LD_INT 14
50599: EQUAL
50600: IFFALSE 50621
// points := [ 10 , 0 , 0 ] ;
50602: LD_ADDR_VAR 0 9
50606: PUSH
50607: LD_INT 10
50609: PUSH
50610: LD_INT 0
50612: PUSH
50613: LD_INT 0
50615: PUSH
50616: EMPTY
50617: LIST
50618: LIST
50619: LIST
50620: ST_TO_ADDR
// if GetClass ( i ) = 11 then
50621: LD_VAR 0 6
50625: PPUSH
50626: CALL_OW 257
50630: PUSH
50631: LD_INT 11
50633: EQUAL
50634: IFFALSE 50655
// points := [ 30 , 10 , 5 ] ;
50636: LD_ADDR_VAR 0 9
50640: PUSH
50641: LD_INT 30
50643: PUSH
50644: LD_INT 10
50646: PUSH
50647: LD_INT 5
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: LIST
50654: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
50655: LD_VAR 0 1
50659: PPUSH
50660: LD_INT 5
50662: PPUSH
50663: CALL_OW 321
50667: PUSH
50668: LD_INT 2
50670: EQUAL
50671: IFFALSE 50688
// bpoints := bpoints * 1.8 ;
50673: LD_ADDR_VAR 0 10
50677: PUSH
50678: LD_VAR 0 10
50682: PUSH
50683: LD_REAL  1.80000000000000E+0000
50686: MUL
50687: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
50688: LD_VAR 0 6
50692: PPUSH
50693: CALL_OW 257
50697: PUSH
50698: LD_INT 1
50700: PUSH
50701: LD_INT 2
50703: PUSH
50704: LD_INT 3
50706: PUSH
50707: LD_INT 4
50709: PUSH
50710: EMPTY
50711: LIST
50712: LIST
50713: LIST
50714: LIST
50715: IN
50716: PUSH
50717: LD_VAR 0 1
50721: PPUSH
50722: LD_INT 51
50724: PPUSH
50725: CALL_OW 321
50729: PUSH
50730: LD_INT 2
50732: EQUAL
50733: AND
50734: IFFALSE 50751
// bpoints := bpoints * 1.2 ;
50736: LD_ADDR_VAR 0 10
50740: PUSH
50741: LD_VAR 0 10
50745: PUSH
50746: LD_REAL  1.20000000000000E+0000
50749: MUL
50750: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
50751: LD_VAR 0 6
50755: PPUSH
50756: CALL_OW 257
50760: PUSH
50761: LD_INT 5
50763: PUSH
50764: LD_INT 7
50766: PUSH
50767: LD_INT 9
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: LIST
50774: IN
50775: PUSH
50776: LD_VAR 0 1
50780: PPUSH
50781: LD_INT 52
50783: PPUSH
50784: CALL_OW 321
50788: PUSH
50789: LD_INT 2
50791: EQUAL
50792: AND
50793: IFFALSE 50810
// bpoints := bpoints * 1.5 ;
50795: LD_ADDR_VAR 0 10
50799: PUSH
50800: LD_VAR 0 10
50804: PUSH
50805: LD_REAL  1.50000000000000E+0000
50808: MUL
50809: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
50810: LD_VAR 0 1
50814: PPUSH
50815: LD_INT 66
50817: PPUSH
50818: CALL_OW 321
50822: PUSH
50823: LD_INT 2
50825: EQUAL
50826: IFFALSE 50843
// bpoints := bpoints * 1.1 ;
50828: LD_ADDR_VAR 0 10
50832: PUSH
50833: LD_VAR 0 10
50837: PUSH
50838: LD_REAL  1.10000000000000E+0000
50841: MUL
50842: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
50843: LD_ADDR_VAR 0 10
50847: PUSH
50848: LD_VAR 0 10
50852: PUSH
50853: LD_VAR 0 6
50857: PPUSH
50858: LD_INT 1
50860: PPUSH
50861: CALL_OW 259
50865: PUSH
50866: LD_REAL  1.15000000000000E+0000
50869: MUL
50870: MUL
50871: ST_TO_ADDR
// end ; unit_vehicle :
50872: GO 51696
50874: LD_INT 2
50876: DOUBLE
50877: EQUAL
50878: IFTRUE 50882
50880: GO 51684
50882: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
50883: LD_VAR 0 6
50887: PPUSH
50888: CALL_OW 264
50892: PUSH
50893: LD_INT 2
50895: PUSH
50896: LD_INT 42
50898: PUSH
50899: LD_INT 24
50901: PUSH
50902: EMPTY
50903: LIST
50904: LIST
50905: LIST
50906: IN
50907: IFFALSE 50928
// points := [ 25 , 5 , 3 ] ;
50909: LD_ADDR_VAR 0 9
50913: PUSH
50914: LD_INT 25
50916: PUSH
50917: LD_INT 5
50919: PUSH
50920: LD_INT 3
50922: PUSH
50923: EMPTY
50924: LIST
50925: LIST
50926: LIST
50927: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
50928: LD_VAR 0 6
50932: PPUSH
50933: CALL_OW 264
50937: PUSH
50938: LD_INT 4
50940: PUSH
50941: LD_INT 43
50943: PUSH
50944: LD_INT 25
50946: PUSH
50947: EMPTY
50948: LIST
50949: LIST
50950: LIST
50951: IN
50952: IFFALSE 50973
// points := [ 40 , 15 , 5 ] ;
50954: LD_ADDR_VAR 0 9
50958: PUSH
50959: LD_INT 40
50961: PUSH
50962: LD_INT 15
50964: PUSH
50965: LD_INT 5
50967: PUSH
50968: EMPTY
50969: LIST
50970: LIST
50971: LIST
50972: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
50973: LD_VAR 0 6
50977: PPUSH
50978: CALL_OW 264
50982: PUSH
50983: LD_INT 3
50985: PUSH
50986: LD_INT 23
50988: PUSH
50989: EMPTY
50990: LIST
50991: LIST
50992: IN
50993: IFFALSE 51014
// points := [ 7 , 25 , 8 ] ;
50995: LD_ADDR_VAR 0 9
50999: PUSH
51000: LD_INT 7
51002: PUSH
51003: LD_INT 25
51005: PUSH
51006: LD_INT 8
51008: PUSH
51009: EMPTY
51010: LIST
51011: LIST
51012: LIST
51013: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
51014: LD_VAR 0 6
51018: PPUSH
51019: CALL_OW 264
51023: PUSH
51024: LD_INT 5
51026: PUSH
51027: LD_INT 27
51029: PUSH
51030: LD_INT 44
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: LIST
51037: IN
51038: IFFALSE 51059
// points := [ 14 , 50 , 16 ] ;
51040: LD_ADDR_VAR 0 9
51044: PUSH
51045: LD_INT 14
51047: PUSH
51048: LD_INT 50
51050: PUSH
51051: LD_INT 16
51053: PUSH
51054: EMPTY
51055: LIST
51056: LIST
51057: LIST
51058: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
51059: LD_VAR 0 6
51063: PPUSH
51064: CALL_OW 264
51068: PUSH
51069: LD_INT 6
51071: PUSH
51072: LD_INT 46
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: IN
51079: IFFALSE 51100
// points := [ 32 , 120 , 70 ] ;
51081: LD_ADDR_VAR 0 9
51085: PUSH
51086: LD_INT 32
51088: PUSH
51089: LD_INT 120
51091: PUSH
51092: LD_INT 70
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: LIST
51099: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
51100: LD_VAR 0 6
51104: PPUSH
51105: CALL_OW 264
51109: PUSH
51110: LD_INT 7
51112: PUSH
51113: LD_INT 28
51115: PUSH
51116: LD_INT 45
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: LIST
51123: IN
51124: IFFALSE 51145
// points := [ 35 , 20 , 45 ] ;
51126: LD_ADDR_VAR 0 9
51130: PUSH
51131: LD_INT 35
51133: PUSH
51134: LD_INT 20
51136: PUSH
51137: LD_INT 45
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: LIST
51144: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
51145: LD_VAR 0 6
51149: PPUSH
51150: CALL_OW 264
51154: PUSH
51155: LD_INT 47
51157: PUSH
51158: EMPTY
51159: LIST
51160: IN
51161: IFFALSE 51182
// points := [ 67 , 45 , 75 ] ;
51163: LD_ADDR_VAR 0 9
51167: PUSH
51168: LD_INT 67
51170: PUSH
51171: LD_INT 45
51173: PUSH
51174: LD_INT 75
51176: PUSH
51177: EMPTY
51178: LIST
51179: LIST
51180: LIST
51181: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
51182: LD_VAR 0 6
51186: PPUSH
51187: CALL_OW 264
51191: PUSH
51192: LD_INT 26
51194: PUSH
51195: EMPTY
51196: LIST
51197: IN
51198: IFFALSE 51219
// points := [ 120 , 30 , 80 ] ;
51200: LD_ADDR_VAR 0 9
51204: PUSH
51205: LD_INT 120
51207: PUSH
51208: LD_INT 30
51210: PUSH
51211: LD_INT 80
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: LIST
51218: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
51219: LD_VAR 0 6
51223: PPUSH
51224: CALL_OW 264
51228: PUSH
51229: LD_INT 22
51231: PUSH
51232: EMPTY
51233: LIST
51234: IN
51235: IFFALSE 51256
// points := [ 40 , 1 , 1 ] ;
51237: LD_ADDR_VAR 0 9
51241: PUSH
51242: LD_INT 40
51244: PUSH
51245: LD_INT 1
51247: PUSH
51248: LD_INT 1
51250: PUSH
51251: EMPTY
51252: LIST
51253: LIST
51254: LIST
51255: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
51256: LD_VAR 0 6
51260: PPUSH
51261: CALL_OW 264
51265: PUSH
51266: LD_INT 29
51268: PUSH
51269: EMPTY
51270: LIST
51271: IN
51272: IFFALSE 51293
// points := [ 70 , 200 , 400 ] ;
51274: LD_ADDR_VAR 0 9
51278: PUSH
51279: LD_INT 70
51281: PUSH
51282: LD_INT 200
51284: PUSH
51285: LD_INT 400
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: LIST
51292: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
51293: LD_VAR 0 6
51297: PPUSH
51298: CALL_OW 264
51302: PUSH
51303: LD_INT 14
51305: PUSH
51306: LD_INT 53
51308: PUSH
51309: EMPTY
51310: LIST
51311: LIST
51312: IN
51313: IFFALSE 51334
// points := [ 40 , 10 , 20 ] ;
51315: LD_ADDR_VAR 0 9
51319: PUSH
51320: LD_INT 40
51322: PUSH
51323: LD_INT 10
51325: PUSH
51326: LD_INT 20
51328: PUSH
51329: EMPTY
51330: LIST
51331: LIST
51332: LIST
51333: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
51334: LD_VAR 0 6
51338: PPUSH
51339: CALL_OW 264
51343: PUSH
51344: LD_INT 9
51346: PUSH
51347: EMPTY
51348: LIST
51349: IN
51350: IFFALSE 51371
// points := [ 5 , 70 , 20 ] ;
51352: LD_ADDR_VAR 0 9
51356: PUSH
51357: LD_INT 5
51359: PUSH
51360: LD_INT 70
51362: PUSH
51363: LD_INT 20
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: LIST
51370: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
51371: LD_VAR 0 6
51375: PPUSH
51376: CALL_OW 264
51380: PUSH
51381: LD_INT 10
51383: PUSH
51384: EMPTY
51385: LIST
51386: IN
51387: IFFALSE 51408
// points := [ 35 , 110 , 70 ] ;
51389: LD_ADDR_VAR 0 9
51393: PUSH
51394: LD_INT 35
51396: PUSH
51397: LD_INT 110
51399: PUSH
51400: LD_INT 70
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: LIST
51407: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
51408: LD_VAR 0 6
51412: PPUSH
51413: CALL_OW 265
51417: PUSH
51418: LD_INT 25
51420: EQUAL
51421: IFFALSE 51442
// points := [ 80 , 65 , 100 ] ;
51423: LD_ADDR_VAR 0 9
51427: PUSH
51428: LD_INT 80
51430: PUSH
51431: LD_INT 65
51433: PUSH
51434: LD_INT 100
51436: PUSH
51437: EMPTY
51438: LIST
51439: LIST
51440: LIST
51441: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
51442: LD_VAR 0 6
51446: PPUSH
51447: CALL_OW 263
51451: PUSH
51452: LD_INT 1
51454: EQUAL
51455: IFFALSE 51490
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
51457: LD_ADDR_VAR 0 10
51461: PUSH
51462: LD_VAR 0 10
51466: PUSH
51467: LD_VAR 0 6
51471: PPUSH
51472: CALL_OW 311
51476: PPUSH
51477: LD_INT 3
51479: PPUSH
51480: CALL_OW 259
51484: PUSH
51485: LD_INT 4
51487: MUL
51488: MUL
51489: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
51490: LD_VAR 0 6
51494: PPUSH
51495: CALL_OW 263
51499: PUSH
51500: LD_INT 2
51502: EQUAL
51503: IFFALSE 51554
// begin j := IsControledBy ( i ) ;
51505: LD_ADDR_VAR 0 7
51509: PUSH
51510: LD_VAR 0 6
51514: PPUSH
51515: CALL_OW 312
51519: ST_TO_ADDR
// if j then
51520: LD_VAR 0 7
51524: IFFALSE 51554
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
51526: LD_ADDR_VAR 0 10
51530: PUSH
51531: LD_VAR 0 10
51535: PUSH
51536: LD_VAR 0 7
51540: PPUSH
51541: LD_INT 3
51543: PPUSH
51544: CALL_OW 259
51548: PUSH
51549: LD_INT 3
51551: MUL
51552: MUL
51553: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
51554: LD_VAR 0 6
51558: PPUSH
51559: CALL_OW 264
51563: PUSH
51564: LD_INT 5
51566: PUSH
51567: LD_INT 6
51569: PUSH
51570: LD_INT 46
51572: PUSH
51573: LD_INT 44
51575: PUSH
51576: LD_INT 47
51578: PUSH
51579: LD_INT 45
51581: PUSH
51582: LD_INT 28
51584: PUSH
51585: LD_INT 7
51587: PUSH
51588: LD_INT 27
51590: PUSH
51591: LD_INT 29
51593: PUSH
51594: EMPTY
51595: LIST
51596: LIST
51597: LIST
51598: LIST
51599: LIST
51600: LIST
51601: LIST
51602: LIST
51603: LIST
51604: LIST
51605: IN
51606: PUSH
51607: LD_VAR 0 1
51611: PPUSH
51612: LD_INT 52
51614: PPUSH
51615: CALL_OW 321
51619: PUSH
51620: LD_INT 2
51622: EQUAL
51623: AND
51624: IFFALSE 51641
// bpoints := bpoints * 1.2 ;
51626: LD_ADDR_VAR 0 10
51630: PUSH
51631: LD_VAR 0 10
51635: PUSH
51636: LD_REAL  1.20000000000000E+0000
51639: MUL
51640: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
51641: LD_VAR 0 6
51645: PPUSH
51646: CALL_OW 264
51650: PUSH
51651: LD_INT 6
51653: PUSH
51654: LD_INT 46
51656: PUSH
51657: LD_INT 47
51659: PUSH
51660: EMPTY
51661: LIST
51662: LIST
51663: LIST
51664: IN
51665: IFFALSE 51682
// bpoints := bpoints * 1.2 ;
51667: LD_ADDR_VAR 0 10
51671: PUSH
51672: LD_VAR 0 10
51676: PUSH
51677: LD_REAL  1.20000000000000E+0000
51680: MUL
51681: ST_TO_ADDR
// end ; unit_building :
51682: GO 51696
51684: LD_INT 3
51686: DOUBLE
51687: EQUAL
51688: IFTRUE 51692
51690: GO 51695
51692: POP
// ; end ;
51693: GO 51696
51695: POP
// for j = 1 to 3 do
51696: LD_ADDR_VAR 0 7
51700: PUSH
51701: DOUBLE
51702: LD_INT 1
51704: DEC
51705: ST_TO_ADDR
51706: LD_INT 3
51708: PUSH
51709: FOR_TO
51710: IFFALSE 51763
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
51712: LD_ADDR_VAR 0 5
51716: PUSH
51717: LD_VAR 0 5
51721: PPUSH
51722: LD_VAR 0 7
51726: PPUSH
51727: LD_VAR 0 5
51731: PUSH
51732: LD_VAR 0 7
51736: ARRAY
51737: PUSH
51738: LD_VAR 0 9
51742: PUSH
51743: LD_VAR 0 7
51747: ARRAY
51748: PUSH
51749: LD_VAR 0 10
51753: MUL
51754: PLUS
51755: PPUSH
51756: CALL_OW 1
51760: ST_TO_ADDR
51761: GO 51709
51763: POP
51764: POP
// end ;
51765: GO 50248
51767: POP
51768: POP
// result := Replace ( result , 4 , tmp ) ;
51769: LD_ADDR_VAR 0 5
51773: PUSH
51774: LD_VAR 0 5
51778: PPUSH
51779: LD_INT 4
51781: PPUSH
51782: LD_VAR 0 8
51786: PPUSH
51787: CALL_OW 1
51791: ST_TO_ADDR
// end ;
51792: LD_VAR 0 5
51796: RET
// export function DangerAtRange ( unit , range ) ; begin
51797: LD_INT 0
51799: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
51800: LD_ADDR_VAR 0 3
51804: PUSH
51805: LD_VAR 0 1
51809: PPUSH
51810: CALL_OW 255
51814: PPUSH
51815: LD_VAR 0 1
51819: PPUSH
51820: CALL_OW 250
51824: PPUSH
51825: LD_VAR 0 1
51829: PPUSH
51830: CALL_OW 251
51834: PPUSH
51835: LD_VAR 0 2
51839: PPUSH
51840: CALL 50100 0 4
51844: ST_TO_ADDR
// end ;
51845: LD_VAR 0 3
51849: RET
// export function DangerInArea ( side , area ) ; begin
51850: LD_INT 0
51852: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
51853: LD_ADDR_VAR 0 3
51857: PUSH
51858: LD_VAR 0 2
51862: PPUSH
51863: LD_INT 81
51865: PUSH
51866: LD_VAR 0 1
51870: PUSH
51871: EMPTY
51872: LIST
51873: LIST
51874: PPUSH
51875: CALL_OW 70
51879: ST_TO_ADDR
// end ;
51880: LD_VAR 0 3
51884: RET
// export function IsExtension ( b ) ; begin
51885: LD_INT 0
51887: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
51888: LD_ADDR_VAR 0 2
51892: PUSH
51893: LD_VAR 0 1
51897: PUSH
51898: LD_INT 23
51900: PUSH
51901: LD_INT 20
51903: PUSH
51904: LD_INT 22
51906: PUSH
51907: LD_INT 17
51909: PUSH
51910: LD_INT 24
51912: PUSH
51913: LD_INT 21
51915: PUSH
51916: LD_INT 19
51918: PUSH
51919: LD_INT 16
51921: PUSH
51922: LD_INT 25
51924: PUSH
51925: LD_INT 18
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: LIST
51932: LIST
51933: LIST
51934: LIST
51935: LIST
51936: LIST
51937: LIST
51938: LIST
51939: IN
51940: ST_TO_ADDR
// end ;
51941: LD_VAR 0 2
51945: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
51946: LD_INT 0
51948: PPUSH
51949: PPUSH
51950: PPUSH
// result := [ ] ;
51951: LD_ADDR_VAR 0 3
51955: PUSH
51956: EMPTY
51957: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
51958: LD_ADDR_VAR 0 4
51962: PUSH
51963: LD_VAR 0 2
51967: PPUSH
51968: LD_INT 21
51970: PUSH
51971: LD_INT 3
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: PPUSH
51978: CALL_OW 70
51982: ST_TO_ADDR
// if not tmp then
51983: LD_VAR 0 4
51987: NOT
51988: IFFALSE 51992
// exit ;
51990: GO 52050
// for i in tmp do
51992: LD_ADDR_VAR 0 5
51996: PUSH
51997: LD_VAR 0 4
52001: PUSH
52002: FOR_IN
52003: IFFALSE 52038
// if GetBase ( i ) <> base then
52005: LD_VAR 0 5
52009: PPUSH
52010: CALL_OW 274
52014: PUSH
52015: LD_VAR 0 1
52019: NONEQUAL
52020: IFFALSE 52036
// ComLinkToBase ( base , i ) ;
52022: LD_VAR 0 1
52026: PPUSH
52027: LD_VAR 0 5
52031: PPUSH
52032: CALL_OW 169
52036: GO 52002
52038: POP
52039: POP
// result := tmp ;
52040: LD_ADDR_VAR 0 3
52044: PUSH
52045: LD_VAR 0 4
52049: ST_TO_ADDR
// end ;
52050: LD_VAR 0 3
52054: RET
// export function ComComplete ( unit , b ) ; var i ; begin
52055: LD_INT 0
52057: PPUSH
52058: PPUSH
// if BuildingStatus ( b ) = bs_build then
52059: LD_VAR 0 2
52063: PPUSH
52064: CALL_OW 461
52068: PUSH
52069: LD_INT 1
52071: EQUAL
52072: IFFALSE 52132
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
52074: LD_VAR 0 1
52078: PPUSH
52079: LD_STRING h
52081: PUSH
52082: LD_VAR 0 2
52086: PPUSH
52087: CALL_OW 250
52091: PUSH
52092: LD_VAR 0 2
52096: PPUSH
52097: CALL_OW 251
52101: PUSH
52102: LD_VAR 0 2
52106: PUSH
52107: LD_INT 0
52109: PUSH
52110: LD_INT 0
52112: PUSH
52113: LD_INT 0
52115: PUSH
52116: EMPTY
52117: LIST
52118: LIST
52119: LIST
52120: LIST
52121: LIST
52122: LIST
52123: LIST
52124: PUSH
52125: EMPTY
52126: LIST
52127: PPUSH
52128: CALL_OW 446
// end ;
52132: LD_VAR 0 3
52136: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
52137: LD_INT 0
52139: PPUSH
52140: PPUSH
52141: PPUSH
52142: PPUSH
52143: PPUSH
52144: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
52145: LD_VAR 0 1
52149: NOT
52150: PUSH
52151: LD_VAR 0 1
52155: PPUSH
52156: CALL_OW 263
52160: PUSH
52161: LD_INT 2
52163: EQUAL
52164: NOT
52165: OR
52166: IFFALSE 52170
// exit ;
52168: GO 52486
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
52170: LD_ADDR_VAR 0 6
52174: PUSH
52175: LD_INT 22
52177: PUSH
52178: LD_VAR 0 1
52182: PPUSH
52183: CALL_OW 255
52187: PUSH
52188: EMPTY
52189: LIST
52190: LIST
52191: PUSH
52192: LD_INT 2
52194: PUSH
52195: LD_INT 30
52197: PUSH
52198: LD_INT 36
52200: PUSH
52201: EMPTY
52202: LIST
52203: LIST
52204: PUSH
52205: LD_INT 34
52207: PUSH
52208: LD_INT 31
52210: PUSH
52211: EMPTY
52212: LIST
52213: LIST
52214: PUSH
52215: EMPTY
52216: LIST
52217: LIST
52218: LIST
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: PPUSH
52224: CALL_OW 69
52228: ST_TO_ADDR
// if not tmp then
52229: LD_VAR 0 6
52233: NOT
52234: IFFALSE 52238
// exit ;
52236: GO 52486
// result := [ ] ;
52238: LD_ADDR_VAR 0 2
52242: PUSH
52243: EMPTY
52244: ST_TO_ADDR
// for i in tmp do
52245: LD_ADDR_VAR 0 3
52249: PUSH
52250: LD_VAR 0 6
52254: PUSH
52255: FOR_IN
52256: IFFALSE 52327
// begin t := UnitsInside ( i ) ;
52258: LD_ADDR_VAR 0 4
52262: PUSH
52263: LD_VAR 0 3
52267: PPUSH
52268: CALL_OW 313
52272: ST_TO_ADDR
// if t then
52273: LD_VAR 0 4
52277: IFFALSE 52325
// for j in t do
52279: LD_ADDR_VAR 0 7
52283: PUSH
52284: LD_VAR 0 4
52288: PUSH
52289: FOR_IN
52290: IFFALSE 52323
// result := Insert ( result , result + 1 , j ) ;
52292: LD_ADDR_VAR 0 2
52296: PUSH
52297: LD_VAR 0 2
52301: PPUSH
52302: LD_VAR 0 2
52306: PUSH
52307: LD_INT 1
52309: PLUS
52310: PPUSH
52311: LD_VAR 0 7
52315: PPUSH
52316: CALL_OW 2
52320: ST_TO_ADDR
52321: GO 52289
52323: POP
52324: POP
// end ;
52325: GO 52255
52327: POP
52328: POP
// if not result then
52329: LD_VAR 0 2
52333: NOT
52334: IFFALSE 52338
// exit ;
52336: GO 52486
// mech := result [ 1 ] ;
52338: LD_ADDR_VAR 0 5
52342: PUSH
52343: LD_VAR 0 2
52347: PUSH
52348: LD_INT 1
52350: ARRAY
52351: ST_TO_ADDR
// if result > 1 then
52352: LD_VAR 0 2
52356: PUSH
52357: LD_INT 1
52359: GREATER
52360: IFFALSE 52472
// for i = 2 to result do
52362: LD_ADDR_VAR 0 3
52366: PUSH
52367: DOUBLE
52368: LD_INT 2
52370: DEC
52371: ST_TO_ADDR
52372: LD_VAR 0 2
52376: PUSH
52377: FOR_TO
52378: IFFALSE 52470
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
52380: LD_ADDR_VAR 0 4
52384: PUSH
52385: LD_VAR 0 2
52389: PUSH
52390: LD_VAR 0 3
52394: ARRAY
52395: PPUSH
52396: LD_INT 3
52398: PPUSH
52399: CALL_OW 259
52403: PUSH
52404: LD_VAR 0 2
52408: PUSH
52409: LD_VAR 0 3
52413: ARRAY
52414: PPUSH
52415: CALL_OW 432
52419: MINUS
52420: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
52421: LD_VAR 0 4
52425: PUSH
52426: LD_VAR 0 5
52430: PPUSH
52431: LD_INT 3
52433: PPUSH
52434: CALL_OW 259
52438: PUSH
52439: LD_VAR 0 5
52443: PPUSH
52444: CALL_OW 432
52448: MINUS
52449: GREATEREQUAL
52450: IFFALSE 52468
// mech := result [ i ] ;
52452: LD_ADDR_VAR 0 5
52456: PUSH
52457: LD_VAR 0 2
52461: PUSH
52462: LD_VAR 0 3
52466: ARRAY
52467: ST_TO_ADDR
// end ;
52468: GO 52377
52470: POP
52471: POP
// ComLinkTo ( vehicle , mech ) ;
52472: LD_VAR 0 1
52476: PPUSH
52477: LD_VAR 0 5
52481: PPUSH
52482: CALL_OW 135
// end ;
52486: LD_VAR 0 2
52490: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
52491: LD_INT 0
52493: PPUSH
52494: PPUSH
52495: PPUSH
52496: PPUSH
52497: PPUSH
52498: PPUSH
52499: PPUSH
52500: PPUSH
52501: PPUSH
52502: PPUSH
52503: PPUSH
52504: PPUSH
52505: PPUSH
// result := [ ] ;
52506: LD_ADDR_VAR 0 7
52510: PUSH
52511: EMPTY
52512: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
52513: LD_VAR 0 1
52517: PPUSH
52518: CALL_OW 266
52522: PUSH
52523: LD_INT 0
52525: PUSH
52526: LD_INT 1
52528: PUSH
52529: EMPTY
52530: LIST
52531: LIST
52532: IN
52533: NOT
52534: IFFALSE 52538
// exit ;
52536: GO 54169
// if name then
52538: LD_VAR 0 3
52542: IFFALSE 52558
// SetBName ( base_dep , name ) ;
52544: LD_VAR 0 1
52548: PPUSH
52549: LD_VAR 0 3
52553: PPUSH
52554: CALL_OW 500
// base := GetBase ( base_dep ) ;
52558: LD_ADDR_VAR 0 15
52562: PUSH
52563: LD_VAR 0 1
52567: PPUSH
52568: CALL_OW 274
52572: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
52573: LD_ADDR_VAR 0 16
52577: PUSH
52578: LD_VAR 0 1
52582: PPUSH
52583: CALL_OW 255
52587: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
52588: LD_ADDR_VAR 0 17
52592: PUSH
52593: LD_VAR 0 1
52597: PPUSH
52598: CALL_OW 248
52602: ST_TO_ADDR
// if sources then
52603: LD_VAR 0 5
52607: IFFALSE 52654
// for i = 1 to 3 do
52609: LD_ADDR_VAR 0 8
52613: PUSH
52614: DOUBLE
52615: LD_INT 1
52617: DEC
52618: ST_TO_ADDR
52619: LD_INT 3
52621: PUSH
52622: FOR_TO
52623: IFFALSE 52652
// AddResourceType ( base , i , sources [ i ] ) ;
52625: LD_VAR 0 15
52629: PPUSH
52630: LD_VAR 0 8
52634: PPUSH
52635: LD_VAR 0 5
52639: PUSH
52640: LD_VAR 0 8
52644: ARRAY
52645: PPUSH
52646: CALL_OW 276
52650: GO 52622
52652: POP
52653: POP
// buildings := GetBaseBuildings ( base , area ) ;
52654: LD_ADDR_VAR 0 18
52658: PUSH
52659: LD_VAR 0 15
52663: PPUSH
52664: LD_VAR 0 2
52668: PPUSH
52669: CALL 51946 0 2
52673: ST_TO_ADDR
// InitHc ;
52674: CALL_OW 19
// InitUc ;
52678: CALL_OW 18
// uc_side := side ;
52682: LD_ADDR_OWVAR 20
52686: PUSH
52687: LD_VAR 0 16
52691: ST_TO_ADDR
// uc_nation := nation ;
52692: LD_ADDR_OWVAR 21
52696: PUSH
52697: LD_VAR 0 17
52701: ST_TO_ADDR
// if buildings then
52702: LD_VAR 0 18
52706: IFFALSE 54028
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
52708: LD_ADDR_VAR 0 19
52712: PUSH
52713: LD_VAR 0 18
52717: PPUSH
52718: LD_INT 2
52720: PUSH
52721: LD_INT 30
52723: PUSH
52724: LD_INT 29
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PUSH
52731: LD_INT 30
52733: PUSH
52734: LD_INT 30
52736: PUSH
52737: EMPTY
52738: LIST
52739: LIST
52740: PUSH
52741: EMPTY
52742: LIST
52743: LIST
52744: LIST
52745: PPUSH
52746: CALL_OW 72
52750: ST_TO_ADDR
// if tmp then
52751: LD_VAR 0 19
52755: IFFALSE 52803
// for i in tmp do
52757: LD_ADDR_VAR 0 8
52761: PUSH
52762: LD_VAR 0 19
52766: PUSH
52767: FOR_IN
52768: IFFALSE 52801
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
52770: LD_VAR 0 8
52774: PPUSH
52775: CALL_OW 250
52779: PPUSH
52780: LD_VAR 0 8
52784: PPUSH
52785: CALL_OW 251
52789: PPUSH
52790: LD_VAR 0 16
52794: PPUSH
52795: CALL_OW 441
52799: GO 52767
52801: POP
52802: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
52803: LD_VAR 0 18
52807: PPUSH
52808: LD_INT 2
52810: PUSH
52811: LD_INT 30
52813: PUSH
52814: LD_INT 32
52816: PUSH
52817: EMPTY
52818: LIST
52819: LIST
52820: PUSH
52821: LD_INT 30
52823: PUSH
52824: LD_INT 33
52826: PUSH
52827: EMPTY
52828: LIST
52829: LIST
52830: PUSH
52831: EMPTY
52832: LIST
52833: LIST
52834: LIST
52835: PPUSH
52836: CALL_OW 72
52840: IFFALSE 52928
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
52842: LD_ADDR_VAR 0 8
52846: PUSH
52847: LD_VAR 0 18
52851: PPUSH
52852: LD_INT 2
52854: PUSH
52855: LD_INT 30
52857: PUSH
52858: LD_INT 32
52860: PUSH
52861: EMPTY
52862: LIST
52863: LIST
52864: PUSH
52865: LD_INT 30
52867: PUSH
52868: LD_INT 33
52870: PUSH
52871: EMPTY
52872: LIST
52873: LIST
52874: PUSH
52875: EMPTY
52876: LIST
52877: LIST
52878: LIST
52879: PPUSH
52880: CALL_OW 72
52884: PUSH
52885: FOR_IN
52886: IFFALSE 52926
// begin if not GetBWeapon ( i ) then
52888: LD_VAR 0 8
52892: PPUSH
52893: CALL_OW 269
52897: NOT
52898: IFFALSE 52924
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
52900: LD_VAR 0 8
52904: PPUSH
52905: LD_VAR 0 8
52909: PPUSH
52910: LD_VAR 0 2
52914: PPUSH
52915: CALL 54174 0 2
52919: PPUSH
52920: CALL_OW 431
// end ;
52924: GO 52885
52926: POP
52927: POP
// end ; for i = 1 to personel do
52928: LD_ADDR_VAR 0 8
52932: PUSH
52933: DOUBLE
52934: LD_INT 1
52936: DEC
52937: ST_TO_ADDR
52938: LD_VAR 0 6
52942: PUSH
52943: FOR_TO
52944: IFFALSE 54008
// begin if i > 4 then
52946: LD_VAR 0 8
52950: PUSH
52951: LD_INT 4
52953: GREATER
52954: IFFALSE 52958
// break ;
52956: GO 54008
// case i of 1 :
52958: LD_VAR 0 8
52962: PUSH
52963: LD_INT 1
52965: DOUBLE
52966: EQUAL
52967: IFTRUE 52971
52969: GO 53051
52971: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
52972: LD_ADDR_VAR 0 12
52976: PUSH
52977: LD_VAR 0 18
52981: PPUSH
52982: LD_INT 22
52984: PUSH
52985: LD_VAR 0 16
52989: PUSH
52990: EMPTY
52991: LIST
52992: LIST
52993: PUSH
52994: LD_INT 58
52996: PUSH
52997: EMPTY
52998: LIST
52999: PUSH
53000: LD_INT 2
53002: PUSH
53003: LD_INT 30
53005: PUSH
53006: LD_INT 32
53008: PUSH
53009: EMPTY
53010: LIST
53011: LIST
53012: PUSH
53013: LD_INT 30
53015: PUSH
53016: LD_INT 4
53018: PUSH
53019: EMPTY
53020: LIST
53021: LIST
53022: PUSH
53023: LD_INT 30
53025: PUSH
53026: LD_INT 5
53028: PUSH
53029: EMPTY
53030: LIST
53031: LIST
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: LIST
53037: LIST
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: LIST
53043: PPUSH
53044: CALL_OW 72
53048: ST_TO_ADDR
53049: GO 53273
53051: LD_INT 2
53053: DOUBLE
53054: EQUAL
53055: IFTRUE 53059
53057: GO 53121
53059: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
53060: LD_ADDR_VAR 0 12
53064: PUSH
53065: LD_VAR 0 18
53069: PPUSH
53070: LD_INT 22
53072: PUSH
53073: LD_VAR 0 16
53077: PUSH
53078: EMPTY
53079: LIST
53080: LIST
53081: PUSH
53082: LD_INT 2
53084: PUSH
53085: LD_INT 30
53087: PUSH
53088: LD_INT 0
53090: PUSH
53091: EMPTY
53092: LIST
53093: LIST
53094: PUSH
53095: LD_INT 30
53097: PUSH
53098: LD_INT 1
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: LIST
53109: PUSH
53110: EMPTY
53111: LIST
53112: LIST
53113: PPUSH
53114: CALL_OW 72
53118: ST_TO_ADDR
53119: GO 53273
53121: LD_INT 3
53123: DOUBLE
53124: EQUAL
53125: IFTRUE 53129
53127: GO 53191
53129: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
53130: LD_ADDR_VAR 0 12
53134: PUSH
53135: LD_VAR 0 18
53139: PPUSH
53140: LD_INT 22
53142: PUSH
53143: LD_VAR 0 16
53147: PUSH
53148: EMPTY
53149: LIST
53150: LIST
53151: PUSH
53152: LD_INT 2
53154: PUSH
53155: LD_INT 30
53157: PUSH
53158: LD_INT 2
53160: PUSH
53161: EMPTY
53162: LIST
53163: LIST
53164: PUSH
53165: LD_INT 30
53167: PUSH
53168: LD_INT 3
53170: PUSH
53171: EMPTY
53172: LIST
53173: LIST
53174: PUSH
53175: EMPTY
53176: LIST
53177: LIST
53178: LIST
53179: PUSH
53180: EMPTY
53181: LIST
53182: LIST
53183: PPUSH
53184: CALL_OW 72
53188: ST_TO_ADDR
53189: GO 53273
53191: LD_INT 4
53193: DOUBLE
53194: EQUAL
53195: IFTRUE 53199
53197: GO 53272
53199: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
53200: LD_ADDR_VAR 0 12
53204: PUSH
53205: LD_VAR 0 18
53209: PPUSH
53210: LD_INT 22
53212: PUSH
53213: LD_VAR 0 16
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PUSH
53222: LD_INT 2
53224: PUSH
53225: LD_INT 30
53227: PUSH
53228: LD_INT 6
53230: PUSH
53231: EMPTY
53232: LIST
53233: LIST
53234: PUSH
53235: LD_INT 30
53237: PUSH
53238: LD_INT 7
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: PUSH
53245: LD_INT 30
53247: PUSH
53248: LD_INT 8
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: LIST
53259: LIST
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: PPUSH
53265: CALL_OW 72
53269: ST_TO_ADDR
53270: GO 53273
53272: POP
// if i = 1 then
53273: LD_VAR 0 8
53277: PUSH
53278: LD_INT 1
53280: EQUAL
53281: IFFALSE 53392
// begin tmp := [ ] ;
53283: LD_ADDR_VAR 0 19
53287: PUSH
53288: EMPTY
53289: ST_TO_ADDR
// for j in f do
53290: LD_ADDR_VAR 0 9
53294: PUSH
53295: LD_VAR 0 12
53299: PUSH
53300: FOR_IN
53301: IFFALSE 53374
// if GetBType ( j ) = b_bunker then
53303: LD_VAR 0 9
53307: PPUSH
53308: CALL_OW 266
53312: PUSH
53313: LD_INT 32
53315: EQUAL
53316: IFFALSE 53343
// tmp := Insert ( tmp , 1 , j ) else
53318: LD_ADDR_VAR 0 19
53322: PUSH
53323: LD_VAR 0 19
53327: PPUSH
53328: LD_INT 1
53330: PPUSH
53331: LD_VAR 0 9
53335: PPUSH
53336: CALL_OW 2
53340: ST_TO_ADDR
53341: GO 53372
// tmp := Insert ( tmp , tmp + 1 , j ) ;
53343: LD_ADDR_VAR 0 19
53347: PUSH
53348: LD_VAR 0 19
53352: PPUSH
53353: LD_VAR 0 19
53357: PUSH
53358: LD_INT 1
53360: PLUS
53361: PPUSH
53362: LD_VAR 0 9
53366: PPUSH
53367: CALL_OW 2
53371: ST_TO_ADDR
53372: GO 53300
53374: POP
53375: POP
// if tmp then
53376: LD_VAR 0 19
53380: IFFALSE 53392
// f := tmp ;
53382: LD_ADDR_VAR 0 12
53386: PUSH
53387: LD_VAR 0 19
53391: ST_TO_ADDR
// end ; x := personel [ i ] ;
53392: LD_ADDR_VAR 0 13
53396: PUSH
53397: LD_VAR 0 6
53401: PUSH
53402: LD_VAR 0 8
53406: ARRAY
53407: ST_TO_ADDR
// if x = - 1 then
53408: LD_VAR 0 13
53412: PUSH
53413: LD_INT 1
53415: NEG
53416: EQUAL
53417: IFFALSE 53626
// begin for j in f do
53419: LD_ADDR_VAR 0 9
53423: PUSH
53424: LD_VAR 0 12
53428: PUSH
53429: FOR_IN
53430: IFFALSE 53622
// repeat InitHc ;
53432: CALL_OW 19
// if GetBType ( j ) = b_barracks then
53436: LD_VAR 0 9
53440: PPUSH
53441: CALL_OW 266
53445: PUSH
53446: LD_INT 5
53448: EQUAL
53449: IFFALSE 53519
// begin if UnitsInside ( j ) < 3 then
53451: LD_VAR 0 9
53455: PPUSH
53456: CALL_OW 313
53460: PUSH
53461: LD_INT 3
53463: LESS
53464: IFFALSE 53500
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
53466: LD_INT 0
53468: PPUSH
53469: LD_INT 5
53471: PUSH
53472: LD_INT 8
53474: PUSH
53475: LD_INT 9
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: LIST
53482: PUSH
53483: LD_VAR 0 17
53487: ARRAY
53488: PPUSH
53489: LD_VAR 0 4
53493: PPUSH
53494: CALL_OW 380
53498: GO 53517
// PrepareHuman ( false , i , skill ) ;
53500: LD_INT 0
53502: PPUSH
53503: LD_VAR 0 8
53507: PPUSH
53508: LD_VAR 0 4
53512: PPUSH
53513: CALL_OW 380
// end else
53517: GO 53536
// PrepareHuman ( false , i , skill ) ;
53519: LD_INT 0
53521: PPUSH
53522: LD_VAR 0 8
53526: PPUSH
53527: LD_VAR 0 4
53531: PPUSH
53532: CALL_OW 380
// un := CreateHuman ;
53536: LD_ADDR_VAR 0 14
53540: PUSH
53541: CALL_OW 44
53545: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
53546: LD_ADDR_VAR 0 7
53550: PUSH
53551: LD_VAR 0 7
53555: PPUSH
53556: LD_INT 1
53558: PPUSH
53559: LD_VAR 0 14
53563: PPUSH
53564: CALL_OW 2
53568: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
53569: LD_VAR 0 14
53573: PPUSH
53574: LD_VAR 0 9
53578: PPUSH
53579: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
53583: LD_VAR 0 9
53587: PPUSH
53588: CALL_OW 313
53592: PUSH
53593: LD_INT 6
53595: EQUAL
53596: PUSH
53597: LD_VAR 0 9
53601: PPUSH
53602: CALL_OW 266
53606: PUSH
53607: LD_INT 32
53609: PUSH
53610: LD_INT 31
53612: PUSH
53613: EMPTY
53614: LIST
53615: LIST
53616: IN
53617: OR
53618: IFFALSE 53432
53620: GO 53429
53622: POP
53623: POP
// end else
53624: GO 54006
// for j = 1 to x do
53626: LD_ADDR_VAR 0 9
53630: PUSH
53631: DOUBLE
53632: LD_INT 1
53634: DEC
53635: ST_TO_ADDR
53636: LD_VAR 0 13
53640: PUSH
53641: FOR_TO
53642: IFFALSE 54004
// begin InitHc ;
53644: CALL_OW 19
// if not f then
53648: LD_VAR 0 12
53652: NOT
53653: IFFALSE 53742
// begin PrepareHuman ( false , i , skill ) ;
53655: LD_INT 0
53657: PPUSH
53658: LD_VAR 0 8
53662: PPUSH
53663: LD_VAR 0 4
53667: PPUSH
53668: CALL_OW 380
// un := CreateHuman ;
53672: LD_ADDR_VAR 0 14
53676: PUSH
53677: CALL_OW 44
53681: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
53682: LD_ADDR_VAR 0 7
53686: PUSH
53687: LD_VAR 0 7
53691: PPUSH
53692: LD_INT 1
53694: PPUSH
53695: LD_VAR 0 14
53699: PPUSH
53700: CALL_OW 2
53704: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
53705: LD_VAR 0 14
53709: PPUSH
53710: LD_VAR 0 1
53714: PPUSH
53715: CALL_OW 250
53719: PPUSH
53720: LD_VAR 0 1
53724: PPUSH
53725: CALL_OW 251
53729: PPUSH
53730: LD_INT 10
53732: PPUSH
53733: LD_INT 0
53735: PPUSH
53736: CALL_OW 50
// continue ;
53740: GO 53641
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
53742: LD_VAR 0 12
53746: PUSH
53747: LD_INT 1
53749: ARRAY
53750: PPUSH
53751: CALL_OW 313
53755: PUSH
53756: LD_VAR 0 12
53760: PUSH
53761: LD_INT 1
53763: ARRAY
53764: PPUSH
53765: CALL_OW 266
53769: PUSH
53770: LD_INT 32
53772: PUSH
53773: LD_INT 31
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: IN
53780: AND
53781: PUSH
53782: LD_VAR 0 12
53786: PUSH
53787: LD_INT 1
53789: ARRAY
53790: PPUSH
53791: CALL_OW 313
53795: PUSH
53796: LD_INT 6
53798: EQUAL
53799: OR
53800: IFFALSE 53820
// f := Delete ( f , 1 ) ;
53802: LD_ADDR_VAR 0 12
53806: PUSH
53807: LD_VAR 0 12
53811: PPUSH
53812: LD_INT 1
53814: PPUSH
53815: CALL_OW 3
53819: ST_TO_ADDR
// if not f then
53820: LD_VAR 0 12
53824: NOT
53825: IFFALSE 53843
// begin x := x + 2 ;
53827: LD_ADDR_VAR 0 13
53831: PUSH
53832: LD_VAR 0 13
53836: PUSH
53837: LD_INT 2
53839: PLUS
53840: ST_TO_ADDR
// continue ;
53841: GO 53641
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
53843: LD_VAR 0 12
53847: PUSH
53848: LD_INT 1
53850: ARRAY
53851: PPUSH
53852: CALL_OW 266
53856: PUSH
53857: LD_INT 5
53859: EQUAL
53860: IFFALSE 53934
// begin if UnitsInside ( f [ 1 ] ) < 3 then
53862: LD_VAR 0 12
53866: PUSH
53867: LD_INT 1
53869: ARRAY
53870: PPUSH
53871: CALL_OW 313
53875: PUSH
53876: LD_INT 3
53878: LESS
53879: IFFALSE 53915
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
53881: LD_INT 0
53883: PPUSH
53884: LD_INT 5
53886: PUSH
53887: LD_INT 8
53889: PUSH
53890: LD_INT 9
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: LIST
53897: PUSH
53898: LD_VAR 0 17
53902: ARRAY
53903: PPUSH
53904: LD_VAR 0 4
53908: PPUSH
53909: CALL_OW 380
53913: GO 53932
// PrepareHuman ( false , i , skill ) ;
53915: LD_INT 0
53917: PPUSH
53918: LD_VAR 0 8
53922: PPUSH
53923: LD_VAR 0 4
53927: PPUSH
53928: CALL_OW 380
// end else
53932: GO 53951
// PrepareHuman ( false , i , skill ) ;
53934: LD_INT 0
53936: PPUSH
53937: LD_VAR 0 8
53941: PPUSH
53942: LD_VAR 0 4
53946: PPUSH
53947: CALL_OW 380
// un := CreateHuman ;
53951: LD_ADDR_VAR 0 14
53955: PUSH
53956: CALL_OW 44
53960: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
53961: LD_ADDR_VAR 0 7
53965: PUSH
53966: LD_VAR 0 7
53970: PPUSH
53971: LD_INT 1
53973: PPUSH
53974: LD_VAR 0 14
53978: PPUSH
53979: CALL_OW 2
53983: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
53984: LD_VAR 0 14
53988: PPUSH
53989: LD_VAR 0 12
53993: PUSH
53994: LD_INT 1
53996: ARRAY
53997: PPUSH
53998: CALL_OW 52
// end ;
54002: GO 53641
54004: POP
54005: POP
// end ;
54006: GO 52943
54008: POP
54009: POP
// result := result ^ buildings ;
54010: LD_ADDR_VAR 0 7
54014: PUSH
54015: LD_VAR 0 7
54019: PUSH
54020: LD_VAR 0 18
54024: ADD
54025: ST_TO_ADDR
// end else
54026: GO 54169
// begin for i = 1 to personel do
54028: LD_ADDR_VAR 0 8
54032: PUSH
54033: DOUBLE
54034: LD_INT 1
54036: DEC
54037: ST_TO_ADDR
54038: LD_VAR 0 6
54042: PUSH
54043: FOR_TO
54044: IFFALSE 54167
// begin if i > 4 then
54046: LD_VAR 0 8
54050: PUSH
54051: LD_INT 4
54053: GREATER
54054: IFFALSE 54058
// break ;
54056: GO 54167
// x := personel [ i ] ;
54058: LD_ADDR_VAR 0 13
54062: PUSH
54063: LD_VAR 0 6
54067: PUSH
54068: LD_VAR 0 8
54072: ARRAY
54073: ST_TO_ADDR
// if x = - 1 then
54074: LD_VAR 0 13
54078: PUSH
54079: LD_INT 1
54081: NEG
54082: EQUAL
54083: IFFALSE 54087
// continue ;
54085: GO 54043
// PrepareHuman ( false , i , skill ) ;
54087: LD_INT 0
54089: PPUSH
54090: LD_VAR 0 8
54094: PPUSH
54095: LD_VAR 0 4
54099: PPUSH
54100: CALL_OW 380
// un := CreateHuman ;
54104: LD_ADDR_VAR 0 14
54108: PUSH
54109: CALL_OW 44
54113: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
54114: LD_VAR 0 14
54118: PPUSH
54119: LD_VAR 0 1
54123: PPUSH
54124: CALL_OW 250
54128: PPUSH
54129: LD_VAR 0 1
54133: PPUSH
54134: CALL_OW 251
54138: PPUSH
54139: LD_INT 10
54141: PPUSH
54142: LD_INT 0
54144: PPUSH
54145: CALL_OW 50
// result := result ^ un ;
54149: LD_ADDR_VAR 0 7
54153: PUSH
54154: LD_VAR 0 7
54158: PUSH
54159: LD_VAR 0 14
54163: ADD
54164: ST_TO_ADDR
// end ;
54165: GO 54043
54167: POP
54168: POP
// end ; end ;
54169: LD_VAR 0 7
54173: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
54174: LD_INT 0
54176: PPUSH
54177: PPUSH
54178: PPUSH
54179: PPUSH
54180: PPUSH
54181: PPUSH
54182: PPUSH
54183: PPUSH
54184: PPUSH
54185: PPUSH
54186: PPUSH
54187: PPUSH
54188: PPUSH
54189: PPUSH
54190: PPUSH
54191: PPUSH
// result := false ;
54192: LD_ADDR_VAR 0 3
54196: PUSH
54197: LD_INT 0
54199: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
54200: LD_VAR 0 1
54204: NOT
54205: PUSH
54206: LD_VAR 0 1
54210: PPUSH
54211: CALL_OW 266
54215: PUSH
54216: LD_INT 32
54218: PUSH
54219: LD_INT 33
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: IN
54226: NOT
54227: OR
54228: IFFALSE 54232
// exit ;
54230: GO 55368
// nat := GetNation ( tower ) ;
54232: LD_ADDR_VAR 0 12
54236: PUSH
54237: LD_VAR 0 1
54241: PPUSH
54242: CALL_OW 248
54246: ST_TO_ADDR
// side := GetSide ( tower ) ;
54247: LD_ADDR_VAR 0 16
54251: PUSH
54252: LD_VAR 0 1
54256: PPUSH
54257: CALL_OW 255
54261: ST_TO_ADDR
// x := GetX ( tower ) ;
54262: LD_ADDR_VAR 0 10
54266: PUSH
54267: LD_VAR 0 1
54271: PPUSH
54272: CALL_OW 250
54276: ST_TO_ADDR
// y := GetY ( tower ) ;
54277: LD_ADDR_VAR 0 11
54281: PUSH
54282: LD_VAR 0 1
54286: PPUSH
54287: CALL_OW 251
54291: ST_TO_ADDR
// if not x or not y then
54292: LD_VAR 0 10
54296: NOT
54297: PUSH
54298: LD_VAR 0 11
54302: NOT
54303: OR
54304: IFFALSE 54308
// exit ;
54306: GO 55368
// weapon := 0 ;
54308: LD_ADDR_VAR 0 18
54312: PUSH
54313: LD_INT 0
54315: ST_TO_ADDR
// fac_list := [ ] ;
54316: LD_ADDR_VAR 0 17
54320: PUSH
54321: EMPTY
54322: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
54323: LD_ADDR_VAR 0 6
54327: PUSH
54328: LD_VAR 0 1
54332: PPUSH
54333: CALL_OW 274
54337: PPUSH
54338: LD_VAR 0 2
54342: PPUSH
54343: CALL 51946 0 2
54347: PPUSH
54348: LD_INT 30
54350: PUSH
54351: LD_INT 3
54353: PUSH
54354: EMPTY
54355: LIST
54356: LIST
54357: PPUSH
54358: CALL_OW 72
54362: ST_TO_ADDR
// if not factories then
54363: LD_VAR 0 6
54367: NOT
54368: IFFALSE 54372
// exit ;
54370: GO 55368
// for i in factories do
54372: LD_ADDR_VAR 0 8
54376: PUSH
54377: LD_VAR 0 6
54381: PUSH
54382: FOR_IN
54383: IFFALSE 54408
// fac_list := fac_list union AvailableWeaponList ( i ) ;
54385: LD_ADDR_VAR 0 17
54389: PUSH
54390: LD_VAR 0 17
54394: PUSH
54395: LD_VAR 0 8
54399: PPUSH
54400: CALL_OW 478
54404: UNION
54405: ST_TO_ADDR
54406: GO 54382
54408: POP
54409: POP
// if not fac_list then
54410: LD_VAR 0 17
54414: NOT
54415: IFFALSE 54419
// exit ;
54417: GO 55368
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
54419: LD_ADDR_VAR 0 5
54423: PUSH
54424: LD_INT 4
54426: PUSH
54427: LD_INT 5
54429: PUSH
54430: LD_INT 9
54432: PUSH
54433: LD_INT 10
54435: PUSH
54436: LD_INT 6
54438: PUSH
54439: LD_INT 7
54441: PUSH
54442: LD_INT 11
54444: PUSH
54445: EMPTY
54446: LIST
54447: LIST
54448: LIST
54449: LIST
54450: LIST
54451: LIST
54452: LIST
54453: PUSH
54454: LD_INT 27
54456: PUSH
54457: LD_INT 28
54459: PUSH
54460: LD_INT 26
54462: PUSH
54463: LD_INT 30
54465: PUSH
54466: EMPTY
54467: LIST
54468: LIST
54469: LIST
54470: LIST
54471: PUSH
54472: LD_INT 43
54474: PUSH
54475: LD_INT 44
54477: PUSH
54478: LD_INT 46
54480: PUSH
54481: LD_INT 45
54483: PUSH
54484: LD_INT 47
54486: PUSH
54487: LD_INT 49
54489: PUSH
54490: EMPTY
54491: LIST
54492: LIST
54493: LIST
54494: LIST
54495: LIST
54496: LIST
54497: PUSH
54498: EMPTY
54499: LIST
54500: LIST
54501: LIST
54502: PUSH
54503: LD_VAR 0 12
54507: ARRAY
54508: ST_TO_ADDR
// for i in list do
54509: LD_ADDR_VAR 0 8
54513: PUSH
54514: LD_VAR 0 5
54518: PUSH
54519: FOR_IN
54520: IFFALSE 54553
// if not i in fac_list then
54522: LD_VAR 0 8
54526: PUSH
54527: LD_VAR 0 17
54531: IN
54532: NOT
54533: IFFALSE 54551
// list := list diff i ;
54535: LD_ADDR_VAR 0 5
54539: PUSH
54540: LD_VAR 0 5
54544: PUSH
54545: LD_VAR 0 8
54549: DIFF
54550: ST_TO_ADDR
54551: GO 54519
54553: POP
54554: POP
// if not list then
54555: LD_VAR 0 5
54559: NOT
54560: IFFALSE 54564
// exit ;
54562: GO 55368
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
54564: LD_VAR 0 12
54568: PUSH
54569: LD_INT 3
54571: EQUAL
54572: PUSH
54573: LD_INT 49
54575: PUSH
54576: LD_VAR 0 5
54580: IN
54581: AND
54582: PUSH
54583: LD_INT 31
54585: PPUSH
54586: LD_VAR 0 16
54590: PPUSH
54591: CALL_OW 321
54595: PUSH
54596: LD_INT 2
54598: EQUAL
54599: AND
54600: IFFALSE 54660
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
54602: LD_INT 22
54604: PUSH
54605: LD_VAR 0 16
54609: PUSH
54610: EMPTY
54611: LIST
54612: LIST
54613: PUSH
54614: LD_INT 35
54616: PUSH
54617: LD_INT 49
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PUSH
54624: LD_INT 91
54626: PUSH
54627: LD_VAR 0 1
54631: PUSH
54632: LD_INT 10
54634: PUSH
54635: EMPTY
54636: LIST
54637: LIST
54638: LIST
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: LIST
54644: PPUSH
54645: CALL_OW 69
54649: NOT
54650: IFFALSE 54660
// weapon := ru_time_lapser ;
54652: LD_ADDR_VAR 0 18
54656: PUSH
54657: LD_INT 49
54659: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
54660: LD_VAR 0 12
54664: PUSH
54665: LD_INT 1
54667: PUSH
54668: LD_INT 2
54670: PUSH
54671: EMPTY
54672: LIST
54673: LIST
54674: IN
54675: PUSH
54676: LD_INT 11
54678: PUSH
54679: LD_VAR 0 5
54683: IN
54684: PUSH
54685: LD_INT 30
54687: PUSH
54688: LD_VAR 0 5
54692: IN
54693: OR
54694: AND
54695: PUSH
54696: LD_INT 6
54698: PPUSH
54699: LD_VAR 0 16
54703: PPUSH
54704: CALL_OW 321
54708: PUSH
54709: LD_INT 2
54711: EQUAL
54712: AND
54713: IFFALSE 54878
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
54715: LD_INT 22
54717: PUSH
54718: LD_VAR 0 16
54722: PUSH
54723: EMPTY
54724: LIST
54725: LIST
54726: PUSH
54727: LD_INT 2
54729: PUSH
54730: LD_INT 35
54732: PUSH
54733: LD_INT 11
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: PUSH
54740: LD_INT 35
54742: PUSH
54743: LD_INT 30
54745: PUSH
54746: EMPTY
54747: LIST
54748: LIST
54749: PUSH
54750: EMPTY
54751: LIST
54752: LIST
54753: LIST
54754: PUSH
54755: LD_INT 91
54757: PUSH
54758: LD_VAR 0 1
54762: PUSH
54763: LD_INT 18
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: LIST
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: LIST
54775: PPUSH
54776: CALL_OW 69
54780: NOT
54781: PUSH
54782: LD_INT 22
54784: PUSH
54785: LD_VAR 0 16
54789: PUSH
54790: EMPTY
54791: LIST
54792: LIST
54793: PUSH
54794: LD_INT 2
54796: PUSH
54797: LD_INT 30
54799: PUSH
54800: LD_INT 32
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: PUSH
54807: LD_INT 30
54809: PUSH
54810: LD_INT 33
54812: PUSH
54813: EMPTY
54814: LIST
54815: LIST
54816: PUSH
54817: EMPTY
54818: LIST
54819: LIST
54820: LIST
54821: PUSH
54822: LD_INT 91
54824: PUSH
54825: LD_VAR 0 1
54829: PUSH
54830: LD_INT 12
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: LIST
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: LIST
54842: PUSH
54843: EMPTY
54844: LIST
54845: PPUSH
54846: CALL_OW 69
54850: PUSH
54851: LD_INT 2
54853: GREATER
54854: AND
54855: IFFALSE 54878
// weapon := [ us_radar , ar_radar ] [ nat ] ;
54857: LD_ADDR_VAR 0 18
54861: PUSH
54862: LD_INT 11
54864: PUSH
54865: LD_INT 30
54867: PUSH
54868: EMPTY
54869: LIST
54870: LIST
54871: PUSH
54872: LD_VAR 0 12
54876: ARRAY
54877: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
54878: LD_VAR 0 18
54882: NOT
54883: PUSH
54884: LD_INT 40
54886: PPUSH
54887: LD_VAR 0 16
54891: PPUSH
54892: CALL_OW 321
54896: PUSH
54897: LD_INT 2
54899: EQUAL
54900: AND
54901: PUSH
54902: LD_INT 7
54904: PUSH
54905: LD_VAR 0 5
54909: IN
54910: PUSH
54911: LD_INT 28
54913: PUSH
54914: LD_VAR 0 5
54918: IN
54919: OR
54920: PUSH
54921: LD_INT 45
54923: PUSH
54924: LD_VAR 0 5
54928: IN
54929: OR
54930: AND
54931: IFFALSE 55185
// begin hex := GetHexInfo ( x , y ) ;
54933: LD_ADDR_VAR 0 4
54937: PUSH
54938: LD_VAR 0 10
54942: PPUSH
54943: LD_VAR 0 11
54947: PPUSH
54948: CALL_OW 546
54952: ST_TO_ADDR
// if hex [ 1 ] then
54953: LD_VAR 0 4
54957: PUSH
54958: LD_INT 1
54960: ARRAY
54961: IFFALSE 54965
// exit ;
54963: GO 55368
// height := hex [ 2 ] ;
54965: LD_ADDR_VAR 0 15
54969: PUSH
54970: LD_VAR 0 4
54974: PUSH
54975: LD_INT 2
54977: ARRAY
54978: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
54979: LD_ADDR_VAR 0 14
54983: PUSH
54984: LD_INT 0
54986: PUSH
54987: LD_INT 2
54989: PUSH
54990: LD_INT 3
54992: PUSH
54993: LD_INT 5
54995: PUSH
54996: EMPTY
54997: LIST
54998: LIST
54999: LIST
55000: LIST
55001: ST_TO_ADDR
// for i in tmp do
55002: LD_ADDR_VAR 0 8
55006: PUSH
55007: LD_VAR 0 14
55011: PUSH
55012: FOR_IN
55013: IFFALSE 55183
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
55015: LD_ADDR_VAR 0 9
55019: PUSH
55020: LD_VAR 0 10
55024: PPUSH
55025: LD_VAR 0 8
55029: PPUSH
55030: LD_INT 5
55032: PPUSH
55033: CALL_OW 272
55037: PUSH
55038: LD_VAR 0 11
55042: PPUSH
55043: LD_VAR 0 8
55047: PPUSH
55048: LD_INT 5
55050: PPUSH
55051: CALL_OW 273
55055: PUSH
55056: EMPTY
55057: LIST
55058: LIST
55059: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
55060: LD_VAR 0 9
55064: PUSH
55065: LD_INT 1
55067: ARRAY
55068: PPUSH
55069: LD_VAR 0 9
55073: PUSH
55074: LD_INT 2
55076: ARRAY
55077: PPUSH
55078: CALL_OW 488
55082: IFFALSE 55181
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
55084: LD_ADDR_VAR 0 4
55088: PUSH
55089: LD_VAR 0 9
55093: PUSH
55094: LD_INT 1
55096: ARRAY
55097: PPUSH
55098: LD_VAR 0 9
55102: PUSH
55103: LD_INT 2
55105: ARRAY
55106: PPUSH
55107: CALL_OW 546
55111: ST_TO_ADDR
// if hex [ 1 ] then
55112: LD_VAR 0 4
55116: PUSH
55117: LD_INT 1
55119: ARRAY
55120: IFFALSE 55124
// continue ;
55122: GO 55012
// h := hex [ 2 ] ;
55124: LD_ADDR_VAR 0 13
55128: PUSH
55129: LD_VAR 0 4
55133: PUSH
55134: LD_INT 2
55136: ARRAY
55137: ST_TO_ADDR
// if h + 7 < height then
55138: LD_VAR 0 13
55142: PUSH
55143: LD_INT 7
55145: PLUS
55146: PUSH
55147: LD_VAR 0 15
55151: LESS
55152: IFFALSE 55181
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
55154: LD_ADDR_VAR 0 18
55158: PUSH
55159: LD_INT 7
55161: PUSH
55162: LD_INT 28
55164: PUSH
55165: LD_INT 45
55167: PUSH
55168: EMPTY
55169: LIST
55170: LIST
55171: LIST
55172: PUSH
55173: LD_VAR 0 12
55177: ARRAY
55178: ST_TO_ADDR
// break ;
55179: GO 55183
// end ; end ; end ;
55181: GO 55012
55183: POP
55184: POP
// end ; if not weapon then
55185: LD_VAR 0 18
55189: NOT
55190: IFFALSE 55250
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
55192: LD_ADDR_VAR 0 5
55196: PUSH
55197: LD_VAR 0 5
55201: PUSH
55202: LD_INT 11
55204: PUSH
55205: LD_INT 30
55207: PUSH
55208: LD_INT 49
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: LIST
55215: DIFF
55216: ST_TO_ADDR
// if not list then
55217: LD_VAR 0 5
55221: NOT
55222: IFFALSE 55226
// exit ;
55224: GO 55368
// weapon := list [ rand ( 1 , list ) ] ;
55226: LD_ADDR_VAR 0 18
55230: PUSH
55231: LD_VAR 0 5
55235: PUSH
55236: LD_INT 1
55238: PPUSH
55239: LD_VAR 0 5
55243: PPUSH
55244: CALL_OW 12
55248: ARRAY
55249: ST_TO_ADDR
// end ; if weapon then
55250: LD_VAR 0 18
55254: IFFALSE 55368
// begin tmp := CostOfWeapon ( weapon ) ;
55256: LD_ADDR_VAR 0 14
55260: PUSH
55261: LD_VAR 0 18
55265: PPUSH
55266: CALL_OW 451
55270: ST_TO_ADDR
// j := GetBase ( tower ) ;
55271: LD_ADDR_VAR 0 9
55275: PUSH
55276: LD_VAR 0 1
55280: PPUSH
55281: CALL_OW 274
55285: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
55286: LD_VAR 0 9
55290: PPUSH
55291: LD_INT 1
55293: PPUSH
55294: CALL_OW 275
55298: PUSH
55299: LD_VAR 0 14
55303: PUSH
55304: LD_INT 1
55306: ARRAY
55307: GREATEREQUAL
55308: PUSH
55309: LD_VAR 0 9
55313: PPUSH
55314: LD_INT 2
55316: PPUSH
55317: CALL_OW 275
55321: PUSH
55322: LD_VAR 0 14
55326: PUSH
55327: LD_INT 2
55329: ARRAY
55330: GREATEREQUAL
55331: AND
55332: PUSH
55333: LD_VAR 0 9
55337: PPUSH
55338: LD_INT 3
55340: PPUSH
55341: CALL_OW 275
55345: PUSH
55346: LD_VAR 0 14
55350: PUSH
55351: LD_INT 3
55353: ARRAY
55354: GREATEREQUAL
55355: AND
55356: IFFALSE 55368
// result := weapon ;
55358: LD_ADDR_VAR 0 3
55362: PUSH
55363: LD_VAR 0 18
55367: ST_TO_ADDR
// end ; end ;
55368: LD_VAR 0 3
55372: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
55373: LD_INT 0
55375: PPUSH
55376: PPUSH
// result := true ;
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_INT 1
55384: ST_TO_ADDR
// if array1 = array2 then
55385: LD_VAR 0 1
55389: PUSH
55390: LD_VAR 0 2
55394: EQUAL
55395: IFFALSE 55455
// begin for i = 1 to array1 do
55397: LD_ADDR_VAR 0 4
55401: PUSH
55402: DOUBLE
55403: LD_INT 1
55405: DEC
55406: ST_TO_ADDR
55407: LD_VAR 0 1
55411: PUSH
55412: FOR_TO
55413: IFFALSE 55451
// if array1 [ i ] <> array2 [ i ] then
55415: LD_VAR 0 1
55419: PUSH
55420: LD_VAR 0 4
55424: ARRAY
55425: PUSH
55426: LD_VAR 0 2
55430: PUSH
55431: LD_VAR 0 4
55435: ARRAY
55436: NONEQUAL
55437: IFFALSE 55449
// begin result := false ;
55439: LD_ADDR_VAR 0 3
55443: PUSH
55444: LD_INT 0
55446: ST_TO_ADDR
// break ;
55447: GO 55451
// end ;
55449: GO 55412
55451: POP
55452: POP
// end else
55453: GO 55463
// result := false ;
55455: LD_ADDR_VAR 0 3
55459: PUSH
55460: LD_INT 0
55462: ST_TO_ADDR
// end ;
55463: LD_VAR 0 3
55467: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
55468: LD_INT 0
55470: PPUSH
55471: PPUSH
55472: PPUSH
// pom := GetBase ( fac ) ;
55473: LD_ADDR_VAR 0 5
55477: PUSH
55478: LD_VAR 0 1
55482: PPUSH
55483: CALL_OW 274
55487: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
55488: LD_ADDR_VAR 0 4
55492: PUSH
55493: LD_VAR 0 2
55497: PUSH
55498: LD_INT 1
55500: ARRAY
55501: PPUSH
55502: LD_VAR 0 2
55506: PUSH
55507: LD_INT 2
55509: ARRAY
55510: PPUSH
55511: LD_VAR 0 2
55515: PUSH
55516: LD_INT 3
55518: ARRAY
55519: PPUSH
55520: LD_VAR 0 2
55524: PUSH
55525: LD_INT 4
55527: ARRAY
55528: PPUSH
55529: CALL_OW 449
55533: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
55534: LD_ADDR_VAR 0 3
55538: PUSH
55539: LD_VAR 0 5
55543: PPUSH
55544: LD_INT 1
55546: PPUSH
55547: CALL_OW 275
55551: PUSH
55552: LD_VAR 0 4
55556: PUSH
55557: LD_INT 1
55559: ARRAY
55560: GREATEREQUAL
55561: PUSH
55562: LD_VAR 0 5
55566: PPUSH
55567: LD_INT 2
55569: PPUSH
55570: CALL_OW 275
55574: PUSH
55575: LD_VAR 0 4
55579: PUSH
55580: LD_INT 2
55582: ARRAY
55583: GREATEREQUAL
55584: AND
55585: PUSH
55586: LD_VAR 0 5
55590: PPUSH
55591: LD_INT 3
55593: PPUSH
55594: CALL_OW 275
55598: PUSH
55599: LD_VAR 0 4
55603: PUSH
55604: LD_INT 3
55606: ARRAY
55607: GREATEREQUAL
55608: AND
55609: ST_TO_ADDR
// end ;
55610: LD_VAR 0 3
55614: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
55615: LD_INT 0
55617: PPUSH
55618: PPUSH
55619: PPUSH
55620: PPUSH
// pom := GetBase ( building ) ;
55621: LD_ADDR_VAR 0 3
55625: PUSH
55626: LD_VAR 0 1
55630: PPUSH
55631: CALL_OW 274
55635: ST_TO_ADDR
// if not pom then
55636: LD_VAR 0 3
55640: NOT
55641: IFFALSE 55645
// exit ;
55643: GO 55815
// btype := GetBType ( building ) ;
55645: LD_ADDR_VAR 0 5
55649: PUSH
55650: LD_VAR 0 1
55654: PPUSH
55655: CALL_OW 266
55659: ST_TO_ADDR
// if btype = b_armoury then
55660: LD_VAR 0 5
55664: PUSH
55665: LD_INT 4
55667: EQUAL
55668: IFFALSE 55678
// btype := b_barracks ;
55670: LD_ADDR_VAR 0 5
55674: PUSH
55675: LD_INT 5
55677: ST_TO_ADDR
// if btype = b_depot then
55678: LD_VAR 0 5
55682: PUSH
55683: LD_INT 0
55685: EQUAL
55686: IFFALSE 55696
// btype := b_warehouse ;
55688: LD_ADDR_VAR 0 5
55692: PUSH
55693: LD_INT 1
55695: ST_TO_ADDR
// if btype = b_workshop then
55696: LD_VAR 0 5
55700: PUSH
55701: LD_INT 2
55703: EQUAL
55704: IFFALSE 55714
// btype := b_factory ;
55706: LD_ADDR_VAR 0 5
55710: PUSH
55711: LD_INT 3
55713: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
55714: LD_ADDR_VAR 0 4
55718: PUSH
55719: LD_VAR 0 5
55723: PPUSH
55724: LD_VAR 0 1
55728: PPUSH
55729: CALL_OW 248
55733: PPUSH
55734: CALL_OW 450
55738: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
55739: LD_ADDR_VAR 0 2
55743: PUSH
55744: LD_VAR 0 3
55748: PPUSH
55749: LD_INT 1
55751: PPUSH
55752: CALL_OW 275
55756: PUSH
55757: LD_VAR 0 4
55761: PUSH
55762: LD_INT 1
55764: ARRAY
55765: GREATEREQUAL
55766: PUSH
55767: LD_VAR 0 3
55771: PPUSH
55772: LD_INT 2
55774: PPUSH
55775: CALL_OW 275
55779: PUSH
55780: LD_VAR 0 4
55784: PUSH
55785: LD_INT 2
55787: ARRAY
55788: GREATEREQUAL
55789: AND
55790: PUSH
55791: LD_VAR 0 3
55795: PPUSH
55796: LD_INT 3
55798: PPUSH
55799: CALL_OW 275
55803: PUSH
55804: LD_VAR 0 4
55808: PUSH
55809: LD_INT 3
55811: ARRAY
55812: GREATEREQUAL
55813: AND
55814: ST_TO_ADDR
// end ;
55815: LD_VAR 0 2
55819: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
55820: LD_INT 0
55822: PPUSH
55823: PPUSH
55824: PPUSH
// pom := GetBase ( building ) ;
55825: LD_ADDR_VAR 0 4
55829: PUSH
55830: LD_VAR 0 1
55834: PPUSH
55835: CALL_OW 274
55839: ST_TO_ADDR
// if not pom then
55840: LD_VAR 0 4
55844: NOT
55845: IFFALSE 55849
// exit ;
55847: GO 55950
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
55849: LD_ADDR_VAR 0 5
55853: PUSH
55854: LD_VAR 0 2
55858: PPUSH
55859: LD_VAR 0 1
55863: PPUSH
55864: CALL_OW 248
55868: PPUSH
55869: CALL_OW 450
55873: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
55874: LD_ADDR_VAR 0 3
55878: PUSH
55879: LD_VAR 0 4
55883: PPUSH
55884: LD_INT 1
55886: PPUSH
55887: CALL_OW 275
55891: PUSH
55892: LD_VAR 0 5
55896: PUSH
55897: LD_INT 1
55899: ARRAY
55900: GREATEREQUAL
55901: PUSH
55902: LD_VAR 0 4
55906: PPUSH
55907: LD_INT 2
55909: PPUSH
55910: CALL_OW 275
55914: PUSH
55915: LD_VAR 0 5
55919: PUSH
55920: LD_INT 2
55922: ARRAY
55923: GREATEREQUAL
55924: AND
55925: PUSH
55926: LD_VAR 0 4
55930: PPUSH
55931: LD_INT 3
55933: PPUSH
55934: CALL_OW 275
55938: PUSH
55939: LD_VAR 0 5
55943: PUSH
55944: LD_INT 3
55946: ARRAY
55947: GREATEREQUAL
55948: AND
55949: ST_TO_ADDR
// end ;
55950: LD_VAR 0 3
55954: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
55955: LD_INT 0
55957: PPUSH
55958: PPUSH
55959: PPUSH
55960: PPUSH
55961: PPUSH
55962: PPUSH
55963: PPUSH
55964: PPUSH
55965: PPUSH
55966: PPUSH
// result := false ;
55967: LD_ADDR_VAR 0 6
55971: PUSH
55972: LD_INT 0
55974: ST_TO_ADDR
// if not base or not btype or not x or not y then
55975: LD_VAR 0 1
55979: NOT
55980: PUSH
55981: LD_VAR 0 2
55985: NOT
55986: OR
55987: PUSH
55988: LD_VAR 0 3
55992: NOT
55993: OR
55994: PUSH
55995: LD_VAR 0 4
55999: NOT
56000: OR
56001: IFFALSE 56005
// exit ;
56003: GO 56596
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
56005: LD_ADDR_VAR 0 12
56009: PUSH
56010: LD_VAR 0 2
56014: PPUSH
56015: LD_VAR 0 3
56019: PPUSH
56020: LD_VAR 0 4
56024: PPUSH
56025: LD_VAR 0 5
56029: PPUSH
56030: LD_VAR 0 1
56034: PUSH
56035: LD_INT 1
56037: ARRAY
56038: PPUSH
56039: CALL_OW 248
56043: PPUSH
56044: LD_INT 0
56046: PPUSH
56047: CALL 57433 0 6
56051: ST_TO_ADDR
// if not hexes then
56052: LD_VAR 0 12
56056: NOT
56057: IFFALSE 56061
// exit ;
56059: GO 56596
// for i = 1 to hexes do
56061: LD_ADDR_VAR 0 7
56065: PUSH
56066: DOUBLE
56067: LD_INT 1
56069: DEC
56070: ST_TO_ADDR
56071: LD_VAR 0 12
56075: PUSH
56076: FOR_TO
56077: IFFALSE 56594
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
56079: LD_ADDR_VAR 0 11
56083: PUSH
56084: LD_VAR 0 12
56088: PUSH
56089: LD_VAR 0 7
56093: ARRAY
56094: PUSH
56095: LD_INT 1
56097: ARRAY
56098: PPUSH
56099: LD_VAR 0 12
56103: PUSH
56104: LD_VAR 0 7
56108: ARRAY
56109: PUSH
56110: LD_INT 2
56112: ARRAY
56113: PPUSH
56114: CALL_OW 428
56118: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
56119: LD_VAR 0 12
56123: PUSH
56124: LD_VAR 0 7
56128: ARRAY
56129: PUSH
56130: LD_INT 1
56132: ARRAY
56133: PPUSH
56134: LD_VAR 0 12
56138: PUSH
56139: LD_VAR 0 7
56143: ARRAY
56144: PUSH
56145: LD_INT 2
56147: ARRAY
56148: PPUSH
56149: CALL_OW 351
56153: PUSH
56154: LD_VAR 0 12
56158: PUSH
56159: LD_VAR 0 7
56163: ARRAY
56164: PUSH
56165: LD_INT 1
56167: ARRAY
56168: PPUSH
56169: LD_VAR 0 12
56173: PUSH
56174: LD_VAR 0 7
56178: ARRAY
56179: PUSH
56180: LD_INT 2
56182: ARRAY
56183: PPUSH
56184: CALL_OW 488
56188: NOT
56189: OR
56190: PUSH
56191: LD_VAR 0 11
56195: PPUSH
56196: CALL_OW 247
56200: PUSH
56201: LD_INT 3
56203: EQUAL
56204: OR
56205: IFFALSE 56211
// exit ;
56207: POP
56208: POP
56209: GO 56596
// if not tmp then
56211: LD_VAR 0 11
56215: NOT
56216: IFFALSE 56220
// continue ;
56218: GO 56076
// result := true ;
56220: LD_ADDR_VAR 0 6
56224: PUSH
56225: LD_INT 1
56227: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56228: LD_ADDR_VAR 0 15
56232: PUSH
56233: LD_INT 22
56235: PUSH
56236: LD_VAR 0 11
56240: PPUSH
56241: CALL_OW 255
56245: PUSH
56246: EMPTY
56247: LIST
56248: LIST
56249: PUSH
56250: LD_INT 2
56252: PUSH
56253: LD_INT 30
56255: PUSH
56256: LD_INT 0
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PUSH
56263: LD_INT 30
56265: PUSH
56266: LD_INT 1
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: LIST
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: PPUSH
56282: CALL_OW 69
56286: ST_TO_ADDR
// if dep then
56287: LD_VAR 0 15
56291: IFFALSE 56427
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
56293: LD_ADDR_VAR 0 14
56297: PUSH
56298: LD_VAR 0 15
56302: PUSH
56303: LD_INT 1
56305: ARRAY
56306: PPUSH
56307: CALL_OW 250
56311: PPUSH
56312: LD_VAR 0 15
56316: PUSH
56317: LD_INT 1
56319: ARRAY
56320: PPUSH
56321: CALL_OW 254
56325: PPUSH
56326: LD_INT 5
56328: PPUSH
56329: CALL_OW 272
56333: PUSH
56334: LD_VAR 0 15
56338: PUSH
56339: LD_INT 1
56341: ARRAY
56342: PPUSH
56343: CALL_OW 251
56347: PPUSH
56348: LD_VAR 0 15
56352: PUSH
56353: LD_INT 1
56355: ARRAY
56356: PPUSH
56357: CALL_OW 254
56361: PPUSH
56362: LD_INT 5
56364: PPUSH
56365: CALL_OW 273
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
56374: LD_VAR 0 14
56378: PUSH
56379: LD_INT 1
56381: ARRAY
56382: PPUSH
56383: LD_VAR 0 14
56387: PUSH
56388: LD_INT 2
56390: ARRAY
56391: PPUSH
56392: CALL_OW 488
56396: IFFALSE 56427
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
56398: LD_VAR 0 11
56402: PPUSH
56403: LD_VAR 0 14
56407: PUSH
56408: LD_INT 1
56410: ARRAY
56411: PPUSH
56412: LD_VAR 0 14
56416: PUSH
56417: LD_INT 2
56419: ARRAY
56420: PPUSH
56421: CALL_OW 111
// continue ;
56425: GO 56076
// end ; end ; r := GetDir ( tmp ) ;
56427: LD_ADDR_VAR 0 13
56431: PUSH
56432: LD_VAR 0 11
56436: PPUSH
56437: CALL_OW 254
56441: ST_TO_ADDR
// if r = 5 then
56442: LD_VAR 0 13
56446: PUSH
56447: LD_INT 5
56449: EQUAL
56450: IFFALSE 56460
// r := 0 ;
56452: LD_ADDR_VAR 0 13
56456: PUSH
56457: LD_INT 0
56459: ST_TO_ADDR
// for j = r to 5 do
56460: LD_ADDR_VAR 0 8
56464: PUSH
56465: DOUBLE
56466: LD_VAR 0 13
56470: DEC
56471: ST_TO_ADDR
56472: LD_INT 5
56474: PUSH
56475: FOR_TO
56476: IFFALSE 56590
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
56478: LD_ADDR_VAR 0 9
56482: PUSH
56483: LD_VAR 0 11
56487: PPUSH
56488: CALL_OW 250
56492: PPUSH
56493: LD_VAR 0 8
56497: PPUSH
56498: LD_INT 2
56500: PPUSH
56501: CALL_OW 272
56505: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
56506: LD_ADDR_VAR 0 10
56510: PUSH
56511: LD_VAR 0 11
56515: PPUSH
56516: CALL_OW 251
56520: PPUSH
56521: LD_VAR 0 8
56525: PPUSH
56526: LD_INT 2
56528: PPUSH
56529: CALL_OW 273
56533: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
56534: LD_VAR 0 9
56538: PPUSH
56539: LD_VAR 0 10
56543: PPUSH
56544: CALL_OW 488
56548: PUSH
56549: LD_VAR 0 9
56553: PPUSH
56554: LD_VAR 0 10
56558: PPUSH
56559: CALL_OW 428
56563: NOT
56564: AND
56565: IFFALSE 56588
// begin ComMoveXY ( tmp , _x , _y ) ;
56567: LD_VAR 0 11
56571: PPUSH
56572: LD_VAR 0 9
56576: PPUSH
56577: LD_VAR 0 10
56581: PPUSH
56582: CALL_OW 111
// break ;
56586: GO 56590
// end ; end ;
56588: GO 56475
56590: POP
56591: POP
// end ;
56592: GO 56076
56594: POP
56595: POP
// end ;
56596: LD_VAR 0 6
56600: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
56601: LD_INT 0
56603: PPUSH
56604: PPUSH
56605: PPUSH
56606: PPUSH
56607: PPUSH
56608: PPUSH
56609: PPUSH
56610: PPUSH
56611: PPUSH
56612: PPUSH
// result := false ;
56613: LD_ADDR_VAR 0 6
56617: PUSH
56618: LD_INT 0
56620: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
56621: LD_VAR 0 1
56625: NOT
56626: PUSH
56627: LD_VAR 0 1
56631: PPUSH
56632: CALL_OW 266
56636: PUSH
56637: LD_INT 0
56639: PUSH
56640: LD_INT 1
56642: PUSH
56643: EMPTY
56644: LIST
56645: LIST
56646: IN
56647: NOT
56648: OR
56649: PUSH
56650: LD_VAR 0 2
56654: NOT
56655: OR
56656: PUSH
56657: LD_VAR 0 5
56661: PUSH
56662: LD_INT 0
56664: PUSH
56665: LD_INT 1
56667: PUSH
56668: LD_INT 2
56670: PUSH
56671: LD_INT 3
56673: PUSH
56674: LD_INT 4
56676: PUSH
56677: LD_INT 5
56679: PUSH
56680: EMPTY
56681: LIST
56682: LIST
56683: LIST
56684: LIST
56685: LIST
56686: LIST
56687: IN
56688: NOT
56689: OR
56690: PUSH
56691: LD_VAR 0 3
56695: PPUSH
56696: LD_VAR 0 4
56700: PPUSH
56701: CALL_OW 488
56705: NOT
56706: OR
56707: IFFALSE 56711
// exit ;
56709: GO 57428
// pom := GetBase ( bdepot ) ;
56711: LD_ADDR_VAR 0 10
56715: PUSH
56716: LD_VAR 0 1
56720: PPUSH
56721: CALL_OW 274
56725: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
56726: LD_ADDR_VAR 0 11
56730: PUSH
56731: LD_VAR 0 2
56735: PPUSH
56736: LD_VAR 0 1
56740: PPUSH
56741: CALL_OW 248
56745: PPUSH
56746: CALL_OW 450
56750: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
56751: LD_VAR 0 10
56755: PPUSH
56756: LD_INT 1
56758: PPUSH
56759: CALL_OW 275
56763: PUSH
56764: LD_VAR 0 11
56768: PUSH
56769: LD_INT 1
56771: ARRAY
56772: GREATEREQUAL
56773: PUSH
56774: LD_VAR 0 10
56778: PPUSH
56779: LD_INT 2
56781: PPUSH
56782: CALL_OW 275
56786: PUSH
56787: LD_VAR 0 11
56791: PUSH
56792: LD_INT 2
56794: ARRAY
56795: GREATEREQUAL
56796: AND
56797: PUSH
56798: LD_VAR 0 10
56802: PPUSH
56803: LD_INT 3
56805: PPUSH
56806: CALL_OW 275
56810: PUSH
56811: LD_VAR 0 11
56815: PUSH
56816: LD_INT 3
56818: ARRAY
56819: GREATEREQUAL
56820: AND
56821: NOT
56822: IFFALSE 56826
// exit ;
56824: GO 57428
// if GetBType ( bdepot ) = b_depot then
56826: LD_VAR 0 1
56830: PPUSH
56831: CALL_OW 266
56835: PUSH
56836: LD_INT 0
56838: EQUAL
56839: IFFALSE 56851
// dist := 28 else
56841: LD_ADDR_VAR 0 14
56845: PUSH
56846: LD_INT 28
56848: ST_TO_ADDR
56849: GO 56859
// dist := 36 ;
56851: LD_ADDR_VAR 0 14
56855: PUSH
56856: LD_INT 36
56858: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
56859: LD_VAR 0 1
56863: PPUSH
56864: LD_VAR 0 3
56868: PPUSH
56869: LD_VAR 0 4
56873: PPUSH
56874: CALL_OW 297
56878: PUSH
56879: LD_VAR 0 14
56883: GREATER
56884: IFFALSE 56888
// exit ;
56886: GO 57428
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
56888: LD_ADDR_VAR 0 12
56892: PUSH
56893: LD_VAR 0 2
56897: PPUSH
56898: LD_VAR 0 3
56902: PPUSH
56903: LD_VAR 0 4
56907: PPUSH
56908: LD_VAR 0 5
56912: PPUSH
56913: LD_VAR 0 1
56917: PPUSH
56918: CALL_OW 248
56922: PPUSH
56923: LD_INT 0
56925: PPUSH
56926: CALL 57433 0 6
56930: ST_TO_ADDR
// if not hexes then
56931: LD_VAR 0 12
56935: NOT
56936: IFFALSE 56940
// exit ;
56938: GO 57428
// hex := GetHexInfo ( x , y ) ;
56940: LD_ADDR_VAR 0 15
56944: PUSH
56945: LD_VAR 0 3
56949: PPUSH
56950: LD_VAR 0 4
56954: PPUSH
56955: CALL_OW 546
56959: ST_TO_ADDR
// if hex [ 1 ] then
56960: LD_VAR 0 15
56964: PUSH
56965: LD_INT 1
56967: ARRAY
56968: IFFALSE 56972
// exit ;
56970: GO 57428
// height := hex [ 2 ] ;
56972: LD_ADDR_VAR 0 13
56976: PUSH
56977: LD_VAR 0 15
56981: PUSH
56982: LD_INT 2
56984: ARRAY
56985: ST_TO_ADDR
// for i = 1 to hexes do
56986: LD_ADDR_VAR 0 7
56990: PUSH
56991: DOUBLE
56992: LD_INT 1
56994: DEC
56995: ST_TO_ADDR
56996: LD_VAR 0 12
57000: PUSH
57001: FOR_TO
57002: IFFALSE 57332
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
57004: LD_VAR 0 12
57008: PUSH
57009: LD_VAR 0 7
57013: ARRAY
57014: PUSH
57015: LD_INT 1
57017: ARRAY
57018: PPUSH
57019: LD_VAR 0 12
57023: PUSH
57024: LD_VAR 0 7
57028: ARRAY
57029: PUSH
57030: LD_INT 2
57032: ARRAY
57033: PPUSH
57034: CALL_OW 488
57038: NOT
57039: PUSH
57040: LD_VAR 0 12
57044: PUSH
57045: LD_VAR 0 7
57049: ARRAY
57050: PUSH
57051: LD_INT 1
57053: ARRAY
57054: PPUSH
57055: LD_VAR 0 12
57059: PUSH
57060: LD_VAR 0 7
57064: ARRAY
57065: PUSH
57066: LD_INT 2
57068: ARRAY
57069: PPUSH
57070: CALL_OW 428
57074: PUSH
57075: LD_INT 0
57077: GREATER
57078: OR
57079: PUSH
57080: LD_VAR 0 12
57084: PUSH
57085: LD_VAR 0 7
57089: ARRAY
57090: PUSH
57091: LD_INT 1
57093: ARRAY
57094: PPUSH
57095: LD_VAR 0 12
57099: PUSH
57100: LD_VAR 0 7
57104: ARRAY
57105: PUSH
57106: LD_INT 2
57108: ARRAY
57109: PPUSH
57110: CALL_OW 351
57114: OR
57115: IFFALSE 57121
// exit ;
57117: POP
57118: POP
57119: GO 57428
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
57121: LD_ADDR_VAR 0 8
57125: PUSH
57126: LD_VAR 0 12
57130: PUSH
57131: LD_VAR 0 7
57135: ARRAY
57136: PUSH
57137: LD_INT 1
57139: ARRAY
57140: PPUSH
57141: LD_VAR 0 12
57145: PUSH
57146: LD_VAR 0 7
57150: ARRAY
57151: PUSH
57152: LD_INT 2
57154: ARRAY
57155: PPUSH
57156: CALL_OW 546
57160: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
57161: LD_VAR 0 8
57165: PUSH
57166: LD_INT 1
57168: ARRAY
57169: PUSH
57170: LD_VAR 0 8
57174: PUSH
57175: LD_INT 2
57177: ARRAY
57178: PUSH
57179: LD_VAR 0 13
57183: PUSH
57184: LD_INT 2
57186: PLUS
57187: GREATER
57188: OR
57189: PUSH
57190: LD_VAR 0 8
57194: PUSH
57195: LD_INT 2
57197: ARRAY
57198: PUSH
57199: LD_VAR 0 13
57203: PUSH
57204: LD_INT 2
57206: MINUS
57207: LESS
57208: OR
57209: PUSH
57210: LD_VAR 0 8
57214: PUSH
57215: LD_INT 3
57217: ARRAY
57218: PUSH
57219: LD_INT 0
57221: PUSH
57222: LD_INT 8
57224: PUSH
57225: LD_INT 9
57227: PUSH
57228: LD_INT 10
57230: PUSH
57231: LD_INT 11
57233: PUSH
57234: LD_INT 12
57236: PUSH
57237: LD_INT 13
57239: PUSH
57240: LD_INT 16
57242: PUSH
57243: LD_INT 17
57245: PUSH
57246: LD_INT 18
57248: PUSH
57249: LD_INT 19
57251: PUSH
57252: LD_INT 20
57254: PUSH
57255: LD_INT 21
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: LIST
57262: LIST
57263: LIST
57264: LIST
57265: LIST
57266: LIST
57267: LIST
57268: LIST
57269: LIST
57270: LIST
57271: LIST
57272: IN
57273: NOT
57274: OR
57275: PUSH
57276: LD_VAR 0 8
57280: PUSH
57281: LD_INT 5
57283: ARRAY
57284: NOT
57285: OR
57286: PUSH
57287: LD_VAR 0 8
57291: PUSH
57292: LD_INT 6
57294: ARRAY
57295: PUSH
57296: LD_INT 1
57298: PUSH
57299: LD_INT 2
57301: PUSH
57302: LD_INT 7
57304: PUSH
57305: LD_INT 9
57307: PUSH
57308: LD_INT 10
57310: PUSH
57311: LD_INT 11
57313: PUSH
57314: EMPTY
57315: LIST
57316: LIST
57317: LIST
57318: LIST
57319: LIST
57320: LIST
57321: IN
57322: NOT
57323: OR
57324: IFFALSE 57330
// exit ;
57326: POP
57327: POP
57328: GO 57428
// end ;
57330: GO 57001
57332: POP
57333: POP
// side := GetSide ( bdepot ) ;
57334: LD_ADDR_VAR 0 9
57338: PUSH
57339: LD_VAR 0 1
57343: PPUSH
57344: CALL_OW 255
57348: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
57349: LD_VAR 0 9
57353: PPUSH
57354: LD_VAR 0 3
57358: PPUSH
57359: LD_VAR 0 4
57363: PPUSH
57364: LD_INT 20
57366: PPUSH
57367: CALL 50100 0 4
57371: PUSH
57372: LD_INT 4
57374: ARRAY
57375: IFFALSE 57379
// exit ;
57377: GO 57428
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
57379: LD_VAR 0 2
57383: PUSH
57384: LD_INT 29
57386: PUSH
57387: LD_INT 30
57389: PUSH
57390: EMPTY
57391: LIST
57392: LIST
57393: IN
57394: PUSH
57395: LD_VAR 0 3
57399: PPUSH
57400: LD_VAR 0 4
57404: PPUSH
57405: LD_VAR 0 9
57409: PPUSH
57410: CALL_OW 440
57414: NOT
57415: AND
57416: IFFALSE 57420
// exit ;
57418: GO 57428
// result := true ;
57420: LD_ADDR_VAR 0 6
57424: PUSH
57425: LD_INT 1
57427: ST_TO_ADDR
// end ;
57428: LD_VAR 0 6
57432: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
57433: LD_INT 0
57435: PPUSH
57436: PPUSH
57437: PPUSH
57438: PPUSH
57439: PPUSH
57440: PPUSH
57441: PPUSH
57442: PPUSH
57443: PPUSH
57444: PPUSH
57445: PPUSH
57446: PPUSH
57447: PPUSH
57448: PPUSH
57449: PPUSH
57450: PPUSH
57451: PPUSH
57452: PPUSH
57453: PPUSH
57454: PPUSH
57455: PPUSH
57456: PPUSH
57457: PPUSH
57458: PPUSH
57459: PPUSH
57460: PPUSH
57461: PPUSH
57462: PPUSH
57463: PPUSH
57464: PPUSH
57465: PPUSH
57466: PPUSH
57467: PPUSH
57468: PPUSH
57469: PPUSH
57470: PPUSH
57471: PPUSH
57472: PPUSH
57473: PPUSH
57474: PPUSH
57475: PPUSH
57476: PPUSH
57477: PPUSH
57478: PPUSH
57479: PPUSH
57480: PPUSH
57481: PPUSH
57482: PPUSH
57483: PPUSH
57484: PPUSH
57485: PPUSH
57486: PPUSH
57487: PPUSH
57488: PPUSH
57489: PPUSH
57490: PPUSH
57491: PPUSH
57492: PPUSH
// result = [ ] ;
57493: LD_ADDR_VAR 0 7
57497: PUSH
57498: EMPTY
57499: ST_TO_ADDR
// temp_list = [ ] ;
57500: LD_ADDR_VAR 0 9
57504: PUSH
57505: EMPTY
57506: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
57507: LD_VAR 0 4
57511: PUSH
57512: LD_INT 0
57514: PUSH
57515: LD_INT 1
57517: PUSH
57518: LD_INT 2
57520: PUSH
57521: LD_INT 3
57523: PUSH
57524: LD_INT 4
57526: PUSH
57527: LD_INT 5
57529: PUSH
57530: EMPTY
57531: LIST
57532: LIST
57533: LIST
57534: LIST
57535: LIST
57536: LIST
57537: IN
57538: NOT
57539: PUSH
57540: LD_VAR 0 1
57544: PUSH
57545: LD_INT 0
57547: PUSH
57548: LD_INT 1
57550: PUSH
57551: EMPTY
57552: LIST
57553: LIST
57554: IN
57555: PUSH
57556: LD_VAR 0 5
57560: PUSH
57561: LD_INT 1
57563: PUSH
57564: LD_INT 2
57566: PUSH
57567: LD_INT 3
57569: PUSH
57570: EMPTY
57571: LIST
57572: LIST
57573: LIST
57574: IN
57575: NOT
57576: AND
57577: OR
57578: IFFALSE 57582
// exit ;
57580: GO 75967
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
57582: LD_VAR 0 1
57586: PUSH
57587: LD_INT 6
57589: PUSH
57590: LD_INT 7
57592: PUSH
57593: LD_INT 8
57595: PUSH
57596: LD_INT 13
57598: PUSH
57599: LD_INT 12
57601: PUSH
57602: LD_INT 15
57604: PUSH
57605: LD_INT 11
57607: PUSH
57608: LD_INT 14
57610: PUSH
57611: LD_INT 10
57613: PUSH
57614: EMPTY
57615: LIST
57616: LIST
57617: LIST
57618: LIST
57619: LIST
57620: LIST
57621: LIST
57622: LIST
57623: LIST
57624: IN
57625: IFFALSE 57635
// btype = b_lab ;
57627: LD_ADDR_VAR 0 1
57631: PUSH
57632: LD_INT 6
57634: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
57635: LD_VAR 0 6
57639: PUSH
57640: LD_INT 0
57642: PUSH
57643: LD_INT 1
57645: PUSH
57646: LD_INT 2
57648: PUSH
57649: EMPTY
57650: LIST
57651: LIST
57652: LIST
57653: IN
57654: NOT
57655: PUSH
57656: LD_VAR 0 1
57660: PUSH
57661: LD_INT 0
57663: PUSH
57664: LD_INT 1
57666: PUSH
57667: LD_INT 2
57669: PUSH
57670: LD_INT 3
57672: PUSH
57673: LD_INT 6
57675: PUSH
57676: LD_INT 36
57678: PUSH
57679: LD_INT 4
57681: PUSH
57682: LD_INT 5
57684: PUSH
57685: LD_INT 31
57687: PUSH
57688: LD_INT 32
57690: PUSH
57691: LD_INT 33
57693: PUSH
57694: EMPTY
57695: LIST
57696: LIST
57697: LIST
57698: LIST
57699: LIST
57700: LIST
57701: LIST
57702: LIST
57703: LIST
57704: LIST
57705: LIST
57706: IN
57707: NOT
57708: PUSH
57709: LD_VAR 0 6
57713: PUSH
57714: LD_INT 1
57716: EQUAL
57717: AND
57718: OR
57719: PUSH
57720: LD_VAR 0 1
57724: PUSH
57725: LD_INT 2
57727: PUSH
57728: LD_INT 3
57730: PUSH
57731: EMPTY
57732: LIST
57733: LIST
57734: IN
57735: NOT
57736: PUSH
57737: LD_VAR 0 6
57741: PUSH
57742: LD_INT 2
57744: EQUAL
57745: AND
57746: OR
57747: IFFALSE 57757
// mode = 0 ;
57749: LD_ADDR_VAR 0 6
57753: PUSH
57754: LD_INT 0
57756: ST_TO_ADDR
// case mode of 0 :
57757: LD_VAR 0 6
57761: PUSH
57762: LD_INT 0
57764: DOUBLE
57765: EQUAL
57766: IFTRUE 57770
57768: GO 69223
57770: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
57771: LD_ADDR_VAR 0 11
57775: PUSH
57776: LD_INT 0
57778: PUSH
57779: LD_INT 0
57781: PUSH
57782: EMPTY
57783: LIST
57784: LIST
57785: PUSH
57786: LD_INT 0
57788: PUSH
57789: LD_INT 1
57791: NEG
57792: PUSH
57793: EMPTY
57794: LIST
57795: LIST
57796: PUSH
57797: LD_INT 1
57799: PUSH
57800: LD_INT 0
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: PUSH
57807: LD_INT 1
57809: PUSH
57810: LD_INT 1
57812: PUSH
57813: EMPTY
57814: LIST
57815: LIST
57816: PUSH
57817: LD_INT 0
57819: PUSH
57820: LD_INT 1
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PUSH
57827: LD_INT 1
57829: NEG
57830: PUSH
57831: LD_INT 0
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: PUSH
57838: LD_INT 1
57840: NEG
57841: PUSH
57842: LD_INT 1
57844: NEG
57845: PUSH
57846: EMPTY
57847: LIST
57848: LIST
57849: PUSH
57850: LD_INT 1
57852: NEG
57853: PUSH
57854: LD_INT 2
57856: NEG
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: LD_INT 0
57864: PUSH
57865: LD_INT 2
57867: NEG
57868: PUSH
57869: EMPTY
57870: LIST
57871: LIST
57872: PUSH
57873: LD_INT 1
57875: PUSH
57876: LD_INT 1
57878: NEG
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PUSH
57884: LD_INT 1
57886: PUSH
57887: LD_INT 2
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: PUSH
57894: LD_INT 0
57896: PUSH
57897: LD_INT 2
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: PUSH
57904: LD_INT 1
57906: NEG
57907: PUSH
57908: LD_INT 1
57910: PUSH
57911: EMPTY
57912: LIST
57913: LIST
57914: PUSH
57915: LD_INT 1
57917: PUSH
57918: LD_INT 3
57920: PUSH
57921: EMPTY
57922: LIST
57923: LIST
57924: PUSH
57925: LD_INT 0
57927: PUSH
57928: LD_INT 3
57930: PUSH
57931: EMPTY
57932: LIST
57933: LIST
57934: PUSH
57935: LD_INT 1
57937: NEG
57938: PUSH
57939: LD_INT 2
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: LIST
57950: LIST
57951: LIST
57952: LIST
57953: LIST
57954: LIST
57955: LIST
57956: LIST
57957: LIST
57958: LIST
57959: LIST
57960: LIST
57961: LIST
57962: LIST
57963: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
57964: LD_ADDR_VAR 0 12
57968: PUSH
57969: LD_INT 0
57971: PUSH
57972: LD_INT 0
57974: PUSH
57975: EMPTY
57976: LIST
57977: LIST
57978: PUSH
57979: LD_INT 0
57981: PUSH
57982: LD_INT 1
57984: NEG
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: PUSH
57990: LD_INT 1
57992: PUSH
57993: LD_INT 0
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: PUSH
58000: LD_INT 1
58002: PUSH
58003: LD_INT 1
58005: PUSH
58006: EMPTY
58007: LIST
58008: LIST
58009: PUSH
58010: LD_INT 0
58012: PUSH
58013: LD_INT 1
58015: PUSH
58016: EMPTY
58017: LIST
58018: LIST
58019: PUSH
58020: LD_INT 1
58022: NEG
58023: PUSH
58024: LD_INT 0
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PUSH
58031: LD_INT 1
58033: NEG
58034: PUSH
58035: LD_INT 1
58037: NEG
58038: PUSH
58039: EMPTY
58040: LIST
58041: LIST
58042: PUSH
58043: LD_INT 1
58045: PUSH
58046: LD_INT 1
58048: NEG
58049: PUSH
58050: EMPTY
58051: LIST
58052: LIST
58053: PUSH
58054: LD_INT 2
58056: PUSH
58057: LD_INT 0
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: PUSH
58064: LD_INT 2
58066: PUSH
58067: LD_INT 1
58069: PUSH
58070: EMPTY
58071: LIST
58072: LIST
58073: PUSH
58074: LD_INT 1
58076: NEG
58077: PUSH
58078: LD_INT 1
58080: PUSH
58081: EMPTY
58082: LIST
58083: LIST
58084: PUSH
58085: LD_INT 2
58087: NEG
58088: PUSH
58089: LD_INT 0
58091: PUSH
58092: EMPTY
58093: LIST
58094: LIST
58095: PUSH
58096: LD_INT 2
58098: NEG
58099: PUSH
58100: LD_INT 1
58102: NEG
58103: PUSH
58104: EMPTY
58105: LIST
58106: LIST
58107: PUSH
58108: LD_INT 2
58110: NEG
58111: PUSH
58112: LD_INT 1
58114: PUSH
58115: EMPTY
58116: LIST
58117: LIST
58118: PUSH
58119: LD_INT 3
58121: NEG
58122: PUSH
58123: LD_INT 0
58125: PUSH
58126: EMPTY
58127: LIST
58128: LIST
58129: PUSH
58130: LD_INT 3
58132: NEG
58133: PUSH
58134: LD_INT 1
58136: NEG
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: PUSH
58142: EMPTY
58143: LIST
58144: LIST
58145: LIST
58146: LIST
58147: LIST
58148: LIST
58149: LIST
58150: LIST
58151: LIST
58152: LIST
58153: LIST
58154: LIST
58155: LIST
58156: LIST
58157: LIST
58158: LIST
58159: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
58160: LD_ADDR_VAR 0 13
58164: PUSH
58165: LD_INT 0
58167: PUSH
58168: LD_INT 0
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: PUSH
58175: LD_INT 0
58177: PUSH
58178: LD_INT 1
58180: NEG
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: PUSH
58186: LD_INT 1
58188: PUSH
58189: LD_INT 0
58191: PUSH
58192: EMPTY
58193: LIST
58194: LIST
58195: PUSH
58196: LD_INT 1
58198: PUSH
58199: LD_INT 1
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: PUSH
58206: LD_INT 0
58208: PUSH
58209: LD_INT 1
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: PUSH
58216: LD_INT 1
58218: NEG
58219: PUSH
58220: LD_INT 0
58222: PUSH
58223: EMPTY
58224: LIST
58225: LIST
58226: PUSH
58227: LD_INT 1
58229: NEG
58230: PUSH
58231: LD_INT 1
58233: NEG
58234: PUSH
58235: EMPTY
58236: LIST
58237: LIST
58238: PUSH
58239: LD_INT 1
58241: NEG
58242: PUSH
58243: LD_INT 2
58245: NEG
58246: PUSH
58247: EMPTY
58248: LIST
58249: LIST
58250: PUSH
58251: LD_INT 2
58253: PUSH
58254: LD_INT 1
58256: PUSH
58257: EMPTY
58258: LIST
58259: LIST
58260: PUSH
58261: LD_INT 2
58263: PUSH
58264: LD_INT 2
58266: PUSH
58267: EMPTY
58268: LIST
58269: LIST
58270: PUSH
58271: LD_INT 1
58273: PUSH
58274: LD_INT 2
58276: PUSH
58277: EMPTY
58278: LIST
58279: LIST
58280: PUSH
58281: LD_INT 2
58283: NEG
58284: PUSH
58285: LD_INT 1
58287: NEG
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: PUSH
58293: LD_INT 2
58295: NEG
58296: PUSH
58297: LD_INT 2
58299: NEG
58300: PUSH
58301: EMPTY
58302: LIST
58303: LIST
58304: PUSH
58305: LD_INT 2
58307: NEG
58308: PUSH
58309: LD_INT 3
58311: NEG
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: PUSH
58317: LD_INT 3
58319: NEG
58320: PUSH
58321: LD_INT 2
58323: NEG
58324: PUSH
58325: EMPTY
58326: LIST
58327: LIST
58328: PUSH
58329: LD_INT 3
58331: NEG
58332: PUSH
58333: LD_INT 3
58335: NEG
58336: PUSH
58337: EMPTY
58338: LIST
58339: LIST
58340: PUSH
58341: EMPTY
58342: LIST
58343: LIST
58344: LIST
58345: LIST
58346: LIST
58347: LIST
58348: LIST
58349: LIST
58350: LIST
58351: LIST
58352: LIST
58353: LIST
58354: LIST
58355: LIST
58356: LIST
58357: LIST
58358: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
58359: LD_ADDR_VAR 0 14
58363: PUSH
58364: LD_INT 0
58366: PUSH
58367: LD_INT 0
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: LD_INT 0
58376: PUSH
58377: LD_INT 1
58379: NEG
58380: PUSH
58381: EMPTY
58382: LIST
58383: LIST
58384: PUSH
58385: LD_INT 1
58387: PUSH
58388: LD_INT 0
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: PUSH
58395: LD_INT 1
58397: PUSH
58398: LD_INT 1
58400: PUSH
58401: EMPTY
58402: LIST
58403: LIST
58404: PUSH
58405: LD_INT 0
58407: PUSH
58408: LD_INT 1
58410: PUSH
58411: EMPTY
58412: LIST
58413: LIST
58414: PUSH
58415: LD_INT 1
58417: NEG
58418: PUSH
58419: LD_INT 0
58421: PUSH
58422: EMPTY
58423: LIST
58424: LIST
58425: PUSH
58426: LD_INT 1
58428: NEG
58429: PUSH
58430: LD_INT 1
58432: NEG
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: LD_INT 1
58440: NEG
58441: PUSH
58442: LD_INT 2
58444: NEG
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: PUSH
58450: LD_INT 0
58452: PUSH
58453: LD_INT 2
58455: NEG
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PUSH
58461: LD_INT 1
58463: PUSH
58464: LD_INT 1
58466: NEG
58467: PUSH
58468: EMPTY
58469: LIST
58470: LIST
58471: PUSH
58472: LD_INT 1
58474: PUSH
58475: LD_INT 2
58477: PUSH
58478: EMPTY
58479: LIST
58480: LIST
58481: PUSH
58482: LD_INT 0
58484: PUSH
58485: LD_INT 2
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: PUSH
58492: LD_INT 1
58494: NEG
58495: PUSH
58496: LD_INT 1
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: PUSH
58503: LD_INT 1
58505: NEG
58506: PUSH
58507: LD_INT 3
58509: NEG
58510: PUSH
58511: EMPTY
58512: LIST
58513: LIST
58514: PUSH
58515: LD_INT 0
58517: PUSH
58518: LD_INT 3
58520: NEG
58521: PUSH
58522: EMPTY
58523: LIST
58524: LIST
58525: PUSH
58526: LD_INT 1
58528: PUSH
58529: LD_INT 2
58531: NEG
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: PUSH
58537: EMPTY
58538: LIST
58539: LIST
58540: LIST
58541: LIST
58542: LIST
58543: LIST
58544: LIST
58545: LIST
58546: LIST
58547: LIST
58548: LIST
58549: LIST
58550: LIST
58551: LIST
58552: LIST
58553: LIST
58554: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
58555: LD_ADDR_VAR 0 15
58559: PUSH
58560: LD_INT 0
58562: PUSH
58563: LD_INT 0
58565: PUSH
58566: EMPTY
58567: LIST
58568: LIST
58569: PUSH
58570: LD_INT 0
58572: PUSH
58573: LD_INT 1
58575: NEG
58576: PUSH
58577: EMPTY
58578: LIST
58579: LIST
58580: PUSH
58581: LD_INT 1
58583: PUSH
58584: LD_INT 0
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: PUSH
58591: LD_INT 1
58593: PUSH
58594: LD_INT 1
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PUSH
58601: LD_INT 0
58603: PUSH
58604: LD_INT 1
58606: PUSH
58607: EMPTY
58608: LIST
58609: LIST
58610: PUSH
58611: LD_INT 1
58613: NEG
58614: PUSH
58615: LD_INT 0
58617: PUSH
58618: EMPTY
58619: LIST
58620: LIST
58621: PUSH
58622: LD_INT 1
58624: NEG
58625: PUSH
58626: LD_INT 1
58628: NEG
58629: PUSH
58630: EMPTY
58631: LIST
58632: LIST
58633: PUSH
58634: LD_INT 1
58636: PUSH
58637: LD_INT 1
58639: NEG
58640: PUSH
58641: EMPTY
58642: LIST
58643: LIST
58644: PUSH
58645: LD_INT 2
58647: PUSH
58648: LD_INT 0
58650: PUSH
58651: EMPTY
58652: LIST
58653: LIST
58654: PUSH
58655: LD_INT 2
58657: PUSH
58658: LD_INT 1
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: PUSH
58665: LD_INT 1
58667: NEG
58668: PUSH
58669: LD_INT 1
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: PUSH
58676: LD_INT 2
58678: NEG
58679: PUSH
58680: LD_INT 0
58682: PUSH
58683: EMPTY
58684: LIST
58685: LIST
58686: PUSH
58687: LD_INT 2
58689: NEG
58690: PUSH
58691: LD_INT 1
58693: NEG
58694: PUSH
58695: EMPTY
58696: LIST
58697: LIST
58698: PUSH
58699: LD_INT 2
58701: PUSH
58702: LD_INT 1
58704: NEG
58705: PUSH
58706: EMPTY
58707: LIST
58708: LIST
58709: PUSH
58710: LD_INT 3
58712: PUSH
58713: LD_INT 0
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: PUSH
58720: LD_INT 3
58722: PUSH
58723: LD_INT 1
58725: PUSH
58726: EMPTY
58727: LIST
58728: LIST
58729: PUSH
58730: EMPTY
58731: LIST
58732: LIST
58733: LIST
58734: LIST
58735: LIST
58736: LIST
58737: LIST
58738: LIST
58739: LIST
58740: LIST
58741: LIST
58742: LIST
58743: LIST
58744: LIST
58745: LIST
58746: LIST
58747: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
58748: LD_ADDR_VAR 0 16
58752: PUSH
58753: LD_INT 0
58755: PUSH
58756: LD_INT 0
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PUSH
58763: LD_INT 0
58765: PUSH
58766: LD_INT 1
58768: NEG
58769: PUSH
58770: EMPTY
58771: LIST
58772: LIST
58773: PUSH
58774: LD_INT 1
58776: PUSH
58777: LD_INT 0
58779: PUSH
58780: EMPTY
58781: LIST
58782: LIST
58783: PUSH
58784: LD_INT 1
58786: PUSH
58787: LD_INT 1
58789: PUSH
58790: EMPTY
58791: LIST
58792: LIST
58793: PUSH
58794: LD_INT 0
58796: PUSH
58797: LD_INT 1
58799: PUSH
58800: EMPTY
58801: LIST
58802: LIST
58803: PUSH
58804: LD_INT 1
58806: NEG
58807: PUSH
58808: LD_INT 0
58810: PUSH
58811: EMPTY
58812: LIST
58813: LIST
58814: PUSH
58815: LD_INT 1
58817: NEG
58818: PUSH
58819: LD_INT 1
58821: NEG
58822: PUSH
58823: EMPTY
58824: LIST
58825: LIST
58826: PUSH
58827: LD_INT 1
58829: NEG
58830: PUSH
58831: LD_INT 2
58833: NEG
58834: PUSH
58835: EMPTY
58836: LIST
58837: LIST
58838: PUSH
58839: LD_INT 2
58841: PUSH
58842: LD_INT 1
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: PUSH
58849: LD_INT 2
58851: PUSH
58852: LD_INT 2
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: PUSH
58859: LD_INT 1
58861: PUSH
58862: LD_INT 2
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 2
58871: NEG
58872: PUSH
58873: LD_INT 1
58875: NEG
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: PUSH
58881: LD_INT 2
58883: NEG
58884: PUSH
58885: LD_INT 2
58887: NEG
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: PUSH
58893: LD_INT 3
58895: PUSH
58896: LD_INT 2
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: PUSH
58903: LD_INT 3
58905: PUSH
58906: LD_INT 3
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: PUSH
58913: LD_INT 2
58915: PUSH
58916: LD_INT 3
58918: PUSH
58919: EMPTY
58920: LIST
58921: LIST
58922: PUSH
58923: EMPTY
58924: LIST
58925: LIST
58926: LIST
58927: LIST
58928: LIST
58929: LIST
58930: LIST
58931: LIST
58932: LIST
58933: LIST
58934: LIST
58935: LIST
58936: LIST
58937: LIST
58938: LIST
58939: LIST
58940: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
58941: LD_ADDR_VAR 0 17
58945: PUSH
58946: LD_INT 0
58948: PUSH
58949: LD_INT 0
58951: PUSH
58952: EMPTY
58953: LIST
58954: LIST
58955: PUSH
58956: LD_INT 0
58958: PUSH
58959: LD_INT 1
58961: NEG
58962: PUSH
58963: EMPTY
58964: LIST
58965: LIST
58966: PUSH
58967: LD_INT 1
58969: PUSH
58970: LD_INT 0
58972: PUSH
58973: EMPTY
58974: LIST
58975: LIST
58976: PUSH
58977: LD_INT 1
58979: PUSH
58980: LD_INT 1
58982: PUSH
58983: EMPTY
58984: LIST
58985: LIST
58986: PUSH
58987: LD_INT 0
58989: PUSH
58990: LD_INT 1
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: LD_INT 1
58999: NEG
59000: PUSH
59001: LD_INT 0
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: PUSH
59008: LD_INT 1
59010: NEG
59011: PUSH
59012: LD_INT 1
59014: NEG
59015: PUSH
59016: EMPTY
59017: LIST
59018: LIST
59019: PUSH
59020: LD_INT 1
59022: NEG
59023: PUSH
59024: LD_INT 2
59026: NEG
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: PUSH
59032: LD_INT 0
59034: PUSH
59035: LD_INT 2
59037: NEG
59038: PUSH
59039: EMPTY
59040: LIST
59041: LIST
59042: PUSH
59043: LD_INT 1
59045: PUSH
59046: LD_INT 1
59048: NEG
59049: PUSH
59050: EMPTY
59051: LIST
59052: LIST
59053: PUSH
59054: LD_INT 2
59056: PUSH
59057: LD_INT 0
59059: PUSH
59060: EMPTY
59061: LIST
59062: LIST
59063: PUSH
59064: LD_INT 2
59066: PUSH
59067: LD_INT 1
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: PUSH
59074: LD_INT 2
59076: PUSH
59077: LD_INT 2
59079: PUSH
59080: EMPTY
59081: LIST
59082: LIST
59083: PUSH
59084: LD_INT 1
59086: PUSH
59087: LD_INT 2
59089: PUSH
59090: EMPTY
59091: LIST
59092: LIST
59093: PUSH
59094: LD_INT 0
59096: PUSH
59097: LD_INT 2
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: PUSH
59104: LD_INT 1
59106: NEG
59107: PUSH
59108: LD_INT 1
59110: PUSH
59111: EMPTY
59112: LIST
59113: LIST
59114: PUSH
59115: LD_INT 2
59117: NEG
59118: PUSH
59119: LD_INT 0
59121: PUSH
59122: EMPTY
59123: LIST
59124: LIST
59125: PUSH
59126: LD_INT 2
59128: NEG
59129: PUSH
59130: LD_INT 1
59132: NEG
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: PUSH
59138: LD_INT 2
59140: NEG
59141: PUSH
59142: LD_INT 2
59144: NEG
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: LIST
59154: LIST
59155: LIST
59156: LIST
59157: LIST
59158: LIST
59159: LIST
59160: LIST
59161: LIST
59162: LIST
59163: LIST
59164: LIST
59165: LIST
59166: LIST
59167: LIST
59168: LIST
59169: LIST
59170: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
59171: LD_ADDR_VAR 0 18
59175: PUSH
59176: LD_INT 0
59178: PUSH
59179: LD_INT 0
59181: PUSH
59182: EMPTY
59183: LIST
59184: LIST
59185: PUSH
59186: LD_INT 0
59188: PUSH
59189: LD_INT 1
59191: NEG
59192: PUSH
59193: EMPTY
59194: LIST
59195: LIST
59196: PUSH
59197: LD_INT 1
59199: PUSH
59200: LD_INT 0
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: PUSH
59207: LD_INT 1
59209: PUSH
59210: LD_INT 1
59212: PUSH
59213: EMPTY
59214: LIST
59215: LIST
59216: PUSH
59217: LD_INT 0
59219: PUSH
59220: LD_INT 1
59222: PUSH
59223: EMPTY
59224: LIST
59225: LIST
59226: PUSH
59227: LD_INT 1
59229: NEG
59230: PUSH
59231: LD_INT 0
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: PUSH
59238: LD_INT 1
59240: NEG
59241: PUSH
59242: LD_INT 1
59244: NEG
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: PUSH
59250: LD_INT 1
59252: NEG
59253: PUSH
59254: LD_INT 2
59256: NEG
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PUSH
59262: LD_INT 0
59264: PUSH
59265: LD_INT 2
59267: NEG
59268: PUSH
59269: EMPTY
59270: LIST
59271: LIST
59272: PUSH
59273: LD_INT 1
59275: PUSH
59276: LD_INT 1
59278: NEG
59279: PUSH
59280: EMPTY
59281: LIST
59282: LIST
59283: PUSH
59284: LD_INT 2
59286: PUSH
59287: LD_INT 0
59289: PUSH
59290: EMPTY
59291: LIST
59292: LIST
59293: PUSH
59294: LD_INT 2
59296: PUSH
59297: LD_INT 1
59299: PUSH
59300: EMPTY
59301: LIST
59302: LIST
59303: PUSH
59304: LD_INT 2
59306: PUSH
59307: LD_INT 2
59309: PUSH
59310: EMPTY
59311: LIST
59312: LIST
59313: PUSH
59314: LD_INT 1
59316: PUSH
59317: LD_INT 2
59319: PUSH
59320: EMPTY
59321: LIST
59322: LIST
59323: PUSH
59324: LD_INT 0
59326: PUSH
59327: LD_INT 2
59329: PUSH
59330: EMPTY
59331: LIST
59332: LIST
59333: PUSH
59334: LD_INT 1
59336: NEG
59337: PUSH
59338: LD_INT 1
59340: PUSH
59341: EMPTY
59342: LIST
59343: LIST
59344: PUSH
59345: LD_INT 2
59347: NEG
59348: PUSH
59349: LD_INT 0
59351: PUSH
59352: EMPTY
59353: LIST
59354: LIST
59355: PUSH
59356: LD_INT 2
59358: NEG
59359: PUSH
59360: LD_INT 1
59362: NEG
59363: PUSH
59364: EMPTY
59365: LIST
59366: LIST
59367: PUSH
59368: LD_INT 2
59370: NEG
59371: PUSH
59372: LD_INT 2
59374: NEG
59375: PUSH
59376: EMPTY
59377: LIST
59378: LIST
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: LIST
59393: LIST
59394: LIST
59395: LIST
59396: LIST
59397: LIST
59398: LIST
59399: LIST
59400: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
59401: LD_ADDR_VAR 0 19
59405: PUSH
59406: LD_INT 0
59408: PUSH
59409: LD_INT 0
59411: PUSH
59412: EMPTY
59413: LIST
59414: LIST
59415: PUSH
59416: LD_INT 0
59418: PUSH
59419: LD_INT 1
59421: NEG
59422: PUSH
59423: EMPTY
59424: LIST
59425: LIST
59426: PUSH
59427: LD_INT 1
59429: PUSH
59430: LD_INT 0
59432: PUSH
59433: EMPTY
59434: LIST
59435: LIST
59436: PUSH
59437: LD_INT 1
59439: PUSH
59440: LD_INT 1
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PUSH
59447: LD_INT 0
59449: PUSH
59450: LD_INT 1
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: LD_INT 1
59459: NEG
59460: PUSH
59461: LD_INT 0
59463: PUSH
59464: EMPTY
59465: LIST
59466: LIST
59467: PUSH
59468: LD_INT 1
59470: NEG
59471: PUSH
59472: LD_INT 1
59474: NEG
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: PUSH
59480: LD_INT 1
59482: NEG
59483: PUSH
59484: LD_INT 2
59486: NEG
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PUSH
59492: LD_INT 0
59494: PUSH
59495: LD_INT 2
59497: NEG
59498: PUSH
59499: EMPTY
59500: LIST
59501: LIST
59502: PUSH
59503: LD_INT 1
59505: PUSH
59506: LD_INT 1
59508: NEG
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PUSH
59514: LD_INT 2
59516: PUSH
59517: LD_INT 0
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: LD_INT 2
59526: PUSH
59527: LD_INT 1
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: PUSH
59534: LD_INT 2
59536: PUSH
59537: LD_INT 2
59539: PUSH
59540: EMPTY
59541: LIST
59542: LIST
59543: PUSH
59544: LD_INT 1
59546: PUSH
59547: LD_INT 2
59549: PUSH
59550: EMPTY
59551: LIST
59552: LIST
59553: PUSH
59554: LD_INT 0
59556: PUSH
59557: LD_INT 2
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: PUSH
59564: LD_INT 1
59566: NEG
59567: PUSH
59568: LD_INT 1
59570: PUSH
59571: EMPTY
59572: LIST
59573: LIST
59574: PUSH
59575: LD_INT 2
59577: NEG
59578: PUSH
59579: LD_INT 0
59581: PUSH
59582: EMPTY
59583: LIST
59584: LIST
59585: PUSH
59586: LD_INT 2
59588: NEG
59589: PUSH
59590: LD_INT 1
59592: NEG
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: PUSH
59598: LD_INT 2
59600: NEG
59601: PUSH
59602: LD_INT 2
59604: NEG
59605: PUSH
59606: EMPTY
59607: LIST
59608: LIST
59609: PUSH
59610: EMPTY
59611: LIST
59612: LIST
59613: LIST
59614: LIST
59615: LIST
59616: LIST
59617: LIST
59618: LIST
59619: LIST
59620: LIST
59621: LIST
59622: LIST
59623: LIST
59624: LIST
59625: LIST
59626: LIST
59627: LIST
59628: LIST
59629: LIST
59630: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
59631: LD_ADDR_VAR 0 20
59635: PUSH
59636: LD_INT 0
59638: PUSH
59639: LD_INT 0
59641: PUSH
59642: EMPTY
59643: LIST
59644: LIST
59645: PUSH
59646: LD_INT 0
59648: PUSH
59649: LD_INT 1
59651: NEG
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: PUSH
59657: LD_INT 1
59659: PUSH
59660: LD_INT 0
59662: PUSH
59663: EMPTY
59664: LIST
59665: LIST
59666: PUSH
59667: LD_INT 1
59669: PUSH
59670: LD_INT 1
59672: PUSH
59673: EMPTY
59674: LIST
59675: LIST
59676: PUSH
59677: LD_INT 0
59679: PUSH
59680: LD_INT 1
59682: PUSH
59683: EMPTY
59684: LIST
59685: LIST
59686: PUSH
59687: LD_INT 1
59689: NEG
59690: PUSH
59691: LD_INT 0
59693: PUSH
59694: EMPTY
59695: LIST
59696: LIST
59697: PUSH
59698: LD_INT 1
59700: NEG
59701: PUSH
59702: LD_INT 1
59704: NEG
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PUSH
59710: LD_INT 1
59712: NEG
59713: PUSH
59714: LD_INT 2
59716: NEG
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PUSH
59722: LD_INT 0
59724: PUSH
59725: LD_INT 2
59727: NEG
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: PUSH
59733: LD_INT 1
59735: PUSH
59736: LD_INT 1
59738: NEG
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: PUSH
59744: LD_INT 2
59746: PUSH
59747: LD_INT 0
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PUSH
59754: LD_INT 2
59756: PUSH
59757: LD_INT 1
59759: PUSH
59760: EMPTY
59761: LIST
59762: LIST
59763: PUSH
59764: LD_INT 2
59766: PUSH
59767: LD_INT 2
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: PUSH
59774: LD_INT 1
59776: PUSH
59777: LD_INT 2
59779: PUSH
59780: EMPTY
59781: LIST
59782: LIST
59783: PUSH
59784: LD_INT 0
59786: PUSH
59787: LD_INT 2
59789: PUSH
59790: EMPTY
59791: LIST
59792: LIST
59793: PUSH
59794: LD_INT 1
59796: NEG
59797: PUSH
59798: LD_INT 1
59800: PUSH
59801: EMPTY
59802: LIST
59803: LIST
59804: PUSH
59805: LD_INT 2
59807: NEG
59808: PUSH
59809: LD_INT 0
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: PUSH
59816: LD_INT 2
59818: NEG
59819: PUSH
59820: LD_INT 1
59822: NEG
59823: PUSH
59824: EMPTY
59825: LIST
59826: LIST
59827: PUSH
59828: LD_INT 2
59830: NEG
59831: PUSH
59832: LD_INT 2
59834: NEG
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: LIST
59844: LIST
59845: LIST
59846: LIST
59847: LIST
59848: LIST
59849: LIST
59850: LIST
59851: LIST
59852: LIST
59853: LIST
59854: LIST
59855: LIST
59856: LIST
59857: LIST
59858: LIST
59859: LIST
59860: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
59861: LD_ADDR_VAR 0 21
59865: PUSH
59866: LD_INT 0
59868: PUSH
59869: LD_INT 0
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: PUSH
59876: LD_INT 0
59878: PUSH
59879: LD_INT 1
59881: NEG
59882: PUSH
59883: EMPTY
59884: LIST
59885: LIST
59886: PUSH
59887: LD_INT 1
59889: PUSH
59890: LD_INT 0
59892: PUSH
59893: EMPTY
59894: LIST
59895: LIST
59896: PUSH
59897: LD_INT 1
59899: PUSH
59900: LD_INT 1
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: PUSH
59907: LD_INT 0
59909: PUSH
59910: LD_INT 1
59912: PUSH
59913: EMPTY
59914: LIST
59915: LIST
59916: PUSH
59917: LD_INT 1
59919: NEG
59920: PUSH
59921: LD_INT 0
59923: PUSH
59924: EMPTY
59925: LIST
59926: LIST
59927: PUSH
59928: LD_INT 1
59930: NEG
59931: PUSH
59932: LD_INT 1
59934: NEG
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 1
59942: NEG
59943: PUSH
59944: LD_INT 2
59946: NEG
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PUSH
59952: LD_INT 0
59954: PUSH
59955: LD_INT 2
59957: NEG
59958: PUSH
59959: EMPTY
59960: LIST
59961: LIST
59962: PUSH
59963: LD_INT 1
59965: PUSH
59966: LD_INT 1
59968: NEG
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: PUSH
59974: LD_INT 2
59976: PUSH
59977: LD_INT 0
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: LD_INT 2
59986: PUSH
59987: LD_INT 1
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: PUSH
59994: LD_INT 2
59996: PUSH
59997: LD_INT 2
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: PUSH
60004: LD_INT 1
60006: PUSH
60007: LD_INT 2
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PUSH
60014: LD_INT 0
60016: PUSH
60017: LD_INT 2
60019: PUSH
60020: EMPTY
60021: LIST
60022: LIST
60023: PUSH
60024: LD_INT 1
60026: NEG
60027: PUSH
60028: LD_INT 1
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: PUSH
60035: LD_INT 2
60037: NEG
60038: PUSH
60039: LD_INT 0
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: PUSH
60046: LD_INT 2
60048: NEG
60049: PUSH
60050: LD_INT 1
60052: NEG
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 2
60060: NEG
60061: PUSH
60062: LD_INT 2
60064: NEG
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: LIST
60074: LIST
60075: LIST
60076: LIST
60077: LIST
60078: LIST
60079: LIST
60080: LIST
60081: LIST
60082: LIST
60083: LIST
60084: LIST
60085: LIST
60086: LIST
60087: LIST
60088: LIST
60089: LIST
60090: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60091: LD_ADDR_VAR 0 22
60095: PUSH
60096: LD_INT 0
60098: PUSH
60099: LD_INT 0
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 0
60108: PUSH
60109: LD_INT 1
60111: NEG
60112: PUSH
60113: EMPTY
60114: LIST
60115: LIST
60116: PUSH
60117: LD_INT 1
60119: PUSH
60120: LD_INT 0
60122: PUSH
60123: EMPTY
60124: LIST
60125: LIST
60126: PUSH
60127: LD_INT 1
60129: PUSH
60130: LD_INT 1
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PUSH
60137: LD_INT 0
60139: PUSH
60140: LD_INT 1
60142: PUSH
60143: EMPTY
60144: LIST
60145: LIST
60146: PUSH
60147: LD_INT 1
60149: NEG
60150: PUSH
60151: LD_INT 0
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PUSH
60158: LD_INT 1
60160: NEG
60161: PUSH
60162: LD_INT 1
60164: NEG
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: PUSH
60170: LD_INT 1
60172: NEG
60173: PUSH
60174: LD_INT 2
60176: NEG
60177: PUSH
60178: EMPTY
60179: LIST
60180: LIST
60181: PUSH
60182: LD_INT 0
60184: PUSH
60185: LD_INT 2
60187: NEG
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: PUSH
60193: LD_INT 1
60195: PUSH
60196: LD_INT 1
60198: NEG
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: PUSH
60204: LD_INT 2
60206: PUSH
60207: LD_INT 0
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: PUSH
60214: LD_INT 2
60216: PUSH
60217: LD_INT 1
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: PUSH
60224: LD_INT 2
60226: PUSH
60227: LD_INT 2
60229: PUSH
60230: EMPTY
60231: LIST
60232: LIST
60233: PUSH
60234: LD_INT 1
60236: PUSH
60237: LD_INT 2
60239: PUSH
60240: EMPTY
60241: LIST
60242: LIST
60243: PUSH
60244: LD_INT 0
60246: PUSH
60247: LD_INT 2
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: PUSH
60254: LD_INT 1
60256: NEG
60257: PUSH
60258: LD_INT 1
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: PUSH
60265: LD_INT 2
60267: NEG
60268: PUSH
60269: LD_INT 0
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: PUSH
60276: LD_INT 2
60278: NEG
60279: PUSH
60280: LD_INT 1
60282: NEG
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: PUSH
60288: LD_INT 2
60290: NEG
60291: PUSH
60292: LD_INT 2
60294: NEG
60295: PUSH
60296: EMPTY
60297: LIST
60298: LIST
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: LIST
60304: LIST
60305: LIST
60306: LIST
60307: LIST
60308: LIST
60309: LIST
60310: LIST
60311: LIST
60312: LIST
60313: LIST
60314: LIST
60315: LIST
60316: LIST
60317: LIST
60318: LIST
60319: LIST
60320: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
60321: LD_ADDR_VAR 0 23
60325: PUSH
60326: LD_INT 0
60328: PUSH
60329: LD_INT 0
60331: PUSH
60332: EMPTY
60333: LIST
60334: LIST
60335: PUSH
60336: LD_INT 0
60338: PUSH
60339: LD_INT 1
60341: NEG
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: PUSH
60347: LD_INT 1
60349: PUSH
60350: LD_INT 0
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: PUSH
60357: LD_INT 1
60359: PUSH
60360: LD_INT 1
60362: PUSH
60363: EMPTY
60364: LIST
60365: LIST
60366: PUSH
60367: LD_INT 0
60369: PUSH
60370: LD_INT 1
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: PUSH
60377: LD_INT 1
60379: NEG
60380: PUSH
60381: LD_INT 0
60383: PUSH
60384: EMPTY
60385: LIST
60386: LIST
60387: PUSH
60388: LD_INT 1
60390: NEG
60391: PUSH
60392: LD_INT 1
60394: NEG
60395: PUSH
60396: EMPTY
60397: LIST
60398: LIST
60399: PUSH
60400: LD_INT 1
60402: NEG
60403: PUSH
60404: LD_INT 2
60406: NEG
60407: PUSH
60408: EMPTY
60409: LIST
60410: LIST
60411: PUSH
60412: LD_INT 0
60414: PUSH
60415: LD_INT 2
60417: NEG
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PUSH
60423: LD_INT 1
60425: PUSH
60426: LD_INT 1
60428: NEG
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: PUSH
60434: LD_INT 2
60436: PUSH
60437: LD_INT 0
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: LD_INT 2
60446: PUSH
60447: LD_INT 1
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: LD_INT 2
60456: PUSH
60457: LD_INT 2
60459: PUSH
60460: EMPTY
60461: LIST
60462: LIST
60463: PUSH
60464: LD_INT 1
60466: PUSH
60467: LD_INT 2
60469: PUSH
60470: EMPTY
60471: LIST
60472: LIST
60473: PUSH
60474: LD_INT 0
60476: PUSH
60477: LD_INT 2
60479: PUSH
60480: EMPTY
60481: LIST
60482: LIST
60483: PUSH
60484: LD_INT 1
60486: NEG
60487: PUSH
60488: LD_INT 1
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: PUSH
60495: LD_INT 2
60497: NEG
60498: PUSH
60499: LD_INT 0
60501: PUSH
60502: EMPTY
60503: LIST
60504: LIST
60505: PUSH
60506: LD_INT 2
60508: NEG
60509: PUSH
60510: LD_INT 1
60512: NEG
60513: PUSH
60514: EMPTY
60515: LIST
60516: LIST
60517: PUSH
60518: LD_INT 2
60520: NEG
60521: PUSH
60522: LD_INT 2
60524: NEG
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: PUSH
60530: LD_INT 2
60532: NEG
60533: PUSH
60534: LD_INT 3
60536: NEG
60537: PUSH
60538: EMPTY
60539: LIST
60540: LIST
60541: PUSH
60542: LD_INT 1
60544: NEG
60545: PUSH
60546: LD_INT 3
60548: NEG
60549: PUSH
60550: EMPTY
60551: LIST
60552: LIST
60553: PUSH
60554: LD_INT 1
60556: PUSH
60557: LD_INT 2
60559: NEG
60560: PUSH
60561: EMPTY
60562: LIST
60563: LIST
60564: PUSH
60565: LD_INT 2
60567: PUSH
60568: LD_INT 1
60570: NEG
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: PUSH
60576: EMPTY
60577: LIST
60578: LIST
60579: LIST
60580: LIST
60581: LIST
60582: LIST
60583: LIST
60584: LIST
60585: LIST
60586: LIST
60587: LIST
60588: LIST
60589: LIST
60590: LIST
60591: LIST
60592: LIST
60593: LIST
60594: LIST
60595: LIST
60596: LIST
60597: LIST
60598: LIST
60599: LIST
60600: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
60601: LD_ADDR_VAR 0 24
60605: PUSH
60606: LD_INT 0
60608: PUSH
60609: LD_INT 0
60611: PUSH
60612: EMPTY
60613: LIST
60614: LIST
60615: PUSH
60616: LD_INT 0
60618: PUSH
60619: LD_INT 1
60621: NEG
60622: PUSH
60623: EMPTY
60624: LIST
60625: LIST
60626: PUSH
60627: LD_INT 1
60629: PUSH
60630: LD_INT 0
60632: PUSH
60633: EMPTY
60634: LIST
60635: LIST
60636: PUSH
60637: LD_INT 1
60639: PUSH
60640: LD_INT 1
60642: PUSH
60643: EMPTY
60644: LIST
60645: LIST
60646: PUSH
60647: LD_INT 0
60649: PUSH
60650: LD_INT 1
60652: PUSH
60653: EMPTY
60654: LIST
60655: LIST
60656: PUSH
60657: LD_INT 1
60659: NEG
60660: PUSH
60661: LD_INT 0
60663: PUSH
60664: EMPTY
60665: LIST
60666: LIST
60667: PUSH
60668: LD_INT 1
60670: NEG
60671: PUSH
60672: LD_INT 1
60674: NEG
60675: PUSH
60676: EMPTY
60677: LIST
60678: LIST
60679: PUSH
60680: LD_INT 1
60682: NEG
60683: PUSH
60684: LD_INT 2
60686: NEG
60687: PUSH
60688: EMPTY
60689: LIST
60690: LIST
60691: PUSH
60692: LD_INT 0
60694: PUSH
60695: LD_INT 2
60697: NEG
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PUSH
60703: LD_INT 1
60705: PUSH
60706: LD_INT 1
60708: NEG
60709: PUSH
60710: EMPTY
60711: LIST
60712: LIST
60713: PUSH
60714: LD_INT 2
60716: PUSH
60717: LD_INT 0
60719: PUSH
60720: EMPTY
60721: LIST
60722: LIST
60723: PUSH
60724: LD_INT 2
60726: PUSH
60727: LD_INT 1
60729: PUSH
60730: EMPTY
60731: LIST
60732: LIST
60733: PUSH
60734: LD_INT 2
60736: PUSH
60737: LD_INT 2
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: LD_INT 1
60746: PUSH
60747: LD_INT 2
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: LD_INT 0
60756: PUSH
60757: LD_INT 2
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: PUSH
60764: LD_INT 1
60766: NEG
60767: PUSH
60768: LD_INT 1
60770: PUSH
60771: EMPTY
60772: LIST
60773: LIST
60774: PUSH
60775: LD_INT 2
60777: NEG
60778: PUSH
60779: LD_INT 0
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PUSH
60786: LD_INT 2
60788: NEG
60789: PUSH
60790: LD_INT 1
60792: NEG
60793: PUSH
60794: EMPTY
60795: LIST
60796: LIST
60797: PUSH
60798: LD_INT 2
60800: NEG
60801: PUSH
60802: LD_INT 2
60804: NEG
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PUSH
60810: LD_INT 1
60812: PUSH
60813: LD_INT 2
60815: NEG
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PUSH
60821: LD_INT 2
60823: PUSH
60824: LD_INT 1
60826: NEG
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: LD_INT 3
60834: PUSH
60835: LD_INT 1
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: LD_INT 3
60844: PUSH
60845: LD_INT 2
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: PUSH
60852: EMPTY
60853: LIST
60854: LIST
60855: LIST
60856: LIST
60857: LIST
60858: LIST
60859: LIST
60860: LIST
60861: LIST
60862: LIST
60863: LIST
60864: LIST
60865: LIST
60866: LIST
60867: LIST
60868: LIST
60869: LIST
60870: LIST
60871: LIST
60872: LIST
60873: LIST
60874: LIST
60875: LIST
60876: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
60877: LD_ADDR_VAR 0 25
60881: PUSH
60882: LD_INT 0
60884: PUSH
60885: LD_INT 0
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: PUSH
60892: LD_INT 0
60894: PUSH
60895: LD_INT 1
60897: NEG
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PUSH
60903: LD_INT 1
60905: PUSH
60906: LD_INT 0
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: PUSH
60913: LD_INT 1
60915: PUSH
60916: LD_INT 1
60918: PUSH
60919: EMPTY
60920: LIST
60921: LIST
60922: PUSH
60923: LD_INT 0
60925: PUSH
60926: LD_INT 1
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PUSH
60933: LD_INT 1
60935: NEG
60936: PUSH
60937: LD_INT 0
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: PUSH
60944: LD_INT 1
60946: NEG
60947: PUSH
60948: LD_INT 1
60950: NEG
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: PUSH
60956: LD_INT 1
60958: NEG
60959: PUSH
60960: LD_INT 2
60962: NEG
60963: PUSH
60964: EMPTY
60965: LIST
60966: LIST
60967: PUSH
60968: LD_INT 0
60970: PUSH
60971: LD_INT 2
60973: NEG
60974: PUSH
60975: EMPTY
60976: LIST
60977: LIST
60978: PUSH
60979: LD_INT 1
60981: PUSH
60982: LD_INT 1
60984: NEG
60985: PUSH
60986: EMPTY
60987: LIST
60988: LIST
60989: PUSH
60990: LD_INT 2
60992: PUSH
60993: LD_INT 0
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: PUSH
61000: LD_INT 2
61002: PUSH
61003: LD_INT 1
61005: PUSH
61006: EMPTY
61007: LIST
61008: LIST
61009: PUSH
61010: LD_INT 2
61012: PUSH
61013: LD_INT 2
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: PUSH
61020: LD_INT 1
61022: PUSH
61023: LD_INT 2
61025: PUSH
61026: EMPTY
61027: LIST
61028: LIST
61029: PUSH
61030: LD_INT 0
61032: PUSH
61033: LD_INT 2
61035: PUSH
61036: EMPTY
61037: LIST
61038: LIST
61039: PUSH
61040: LD_INT 1
61042: NEG
61043: PUSH
61044: LD_INT 1
61046: PUSH
61047: EMPTY
61048: LIST
61049: LIST
61050: PUSH
61051: LD_INT 2
61053: NEG
61054: PUSH
61055: LD_INT 0
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: LD_INT 2
61064: NEG
61065: PUSH
61066: LD_INT 1
61068: NEG
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: LD_INT 2
61076: NEG
61077: PUSH
61078: LD_INT 2
61080: NEG
61081: PUSH
61082: EMPTY
61083: LIST
61084: LIST
61085: PUSH
61086: LD_INT 3
61088: PUSH
61089: LD_INT 1
61091: PUSH
61092: EMPTY
61093: LIST
61094: LIST
61095: PUSH
61096: LD_INT 3
61098: PUSH
61099: LD_INT 2
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: LD_INT 2
61108: PUSH
61109: LD_INT 3
61111: PUSH
61112: EMPTY
61113: LIST
61114: LIST
61115: PUSH
61116: LD_INT 1
61118: PUSH
61119: LD_INT 3
61121: PUSH
61122: EMPTY
61123: LIST
61124: LIST
61125: PUSH
61126: EMPTY
61127: LIST
61128: LIST
61129: LIST
61130: LIST
61131: LIST
61132: LIST
61133: LIST
61134: LIST
61135: LIST
61136: LIST
61137: LIST
61138: LIST
61139: LIST
61140: LIST
61141: LIST
61142: LIST
61143: LIST
61144: LIST
61145: LIST
61146: LIST
61147: LIST
61148: LIST
61149: LIST
61150: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
61151: LD_ADDR_VAR 0 26
61155: PUSH
61156: LD_INT 0
61158: PUSH
61159: LD_INT 0
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: PUSH
61166: LD_INT 0
61168: PUSH
61169: LD_INT 1
61171: NEG
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PUSH
61177: LD_INT 1
61179: PUSH
61180: LD_INT 0
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PUSH
61187: LD_INT 1
61189: PUSH
61190: LD_INT 1
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: PUSH
61197: LD_INT 0
61199: PUSH
61200: LD_INT 1
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: PUSH
61207: LD_INT 1
61209: NEG
61210: PUSH
61211: LD_INT 0
61213: PUSH
61214: EMPTY
61215: LIST
61216: LIST
61217: PUSH
61218: LD_INT 1
61220: NEG
61221: PUSH
61222: LD_INT 1
61224: NEG
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: PUSH
61230: LD_INT 1
61232: NEG
61233: PUSH
61234: LD_INT 2
61236: NEG
61237: PUSH
61238: EMPTY
61239: LIST
61240: LIST
61241: PUSH
61242: LD_INT 0
61244: PUSH
61245: LD_INT 2
61247: NEG
61248: PUSH
61249: EMPTY
61250: LIST
61251: LIST
61252: PUSH
61253: LD_INT 1
61255: PUSH
61256: LD_INT 1
61258: NEG
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 2
61266: PUSH
61267: LD_INT 0
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: LD_INT 2
61276: PUSH
61277: LD_INT 1
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PUSH
61284: LD_INT 2
61286: PUSH
61287: LD_INT 2
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PUSH
61294: LD_INT 1
61296: PUSH
61297: LD_INT 2
61299: PUSH
61300: EMPTY
61301: LIST
61302: LIST
61303: PUSH
61304: LD_INT 0
61306: PUSH
61307: LD_INT 2
61309: PUSH
61310: EMPTY
61311: LIST
61312: LIST
61313: PUSH
61314: LD_INT 1
61316: NEG
61317: PUSH
61318: LD_INT 1
61320: PUSH
61321: EMPTY
61322: LIST
61323: LIST
61324: PUSH
61325: LD_INT 2
61327: NEG
61328: PUSH
61329: LD_INT 0
61331: PUSH
61332: EMPTY
61333: LIST
61334: LIST
61335: PUSH
61336: LD_INT 2
61338: NEG
61339: PUSH
61340: LD_INT 1
61342: NEG
61343: PUSH
61344: EMPTY
61345: LIST
61346: LIST
61347: PUSH
61348: LD_INT 2
61350: NEG
61351: PUSH
61352: LD_INT 2
61354: NEG
61355: PUSH
61356: EMPTY
61357: LIST
61358: LIST
61359: PUSH
61360: LD_INT 2
61362: PUSH
61363: LD_INT 3
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PUSH
61370: LD_INT 1
61372: PUSH
61373: LD_INT 3
61375: PUSH
61376: EMPTY
61377: LIST
61378: LIST
61379: PUSH
61380: LD_INT 1
61382: NEG
61383: PUSH
61384: LD_INT 2
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: LD_INT 2
61393: NEG
61394: PUSH
61395: LD_INT 1
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: LIST
61406: LIST
61407: LIST
61408: LIST
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: LIST
61414: LIST
61415: LIST
61416: LIST
61417: LIST
61418: LIST
61419: LIST
61420: LIST
61421: LIST
61422: LIST
61423: LIST
61424: LIST
61425: LIST
61426: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
61427: LD_ADDR_VAR 0 27
61431: PUSH
61432: LD_INT 0
61434: PUSH
61435: LD_INT 0
61437: PUSH
61438: EMPTY
61439: LIST
61440: LIST
61441: PUSH
61442: LD_INT 0
61444: PUSH
61445: LD_INT 1
61447: NEG
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: LD_INT 1
61455: PUSH
61456: LD_INT 0
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: PUSH
61463: LD_INT 1
61465: PUSH
61466: LD_INT 1
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: PUSH
61473: LD_INT 0
61475: PUSH
61476: LD_INT 1
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: PUSH
61483: LD_INT 1
61485: NEG
61486: PUSH
61487: LD_INT 0
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PUSH
61494: LD_INT 1
61496: NEG
61497: PUSH
61498: LD_INT 1
61500: NEG
61501: PUSH
61502: EMPTY
61503: LIST
61504: LIST
61505: PUSH
61506: LD_INT 1
61508: NEG
61509: PUSH
61510: LD_INT 2
61512: NEG
61513: PUSH
61514: EMPTY
61515: LIST
61516: LIST
61517: PUSH
61518: LD_INT 0
61520: PUSH
61521: LD_INT 2
61523: NEG
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: PUSH
61529: LD_INT 1
61531: PUSH
61532: LD_INT 1
61534: NEG
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 2
61542: PUSH
61543: LD_INT 0
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 2
61552: PUSH
61553: LD_INT 1
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: PUSH
61560: LD_INT 2
61562: PUSH
61563: LD_INT 2
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: PUSH
61570: LD_INT 1
61572: PUSH
61573: LD_INT 2
61575: PUSH
61576: EMPTY
61577: LIST
61578: LIST
61579: PUSH
61580: LD_INT 0
61582: PUSH
61583: LD_INT 2
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: PUSH
61590: LD_INT 1
61592: NEG
61593: PUSH
61594: LD_INT 1
61596: PUSH
61597: EMPTY
61598: LIST
61599: LIST
61600: PUSH
61601: LD_INT 2
61603: NEG
61604: PUSH
61605: LD_INT 0
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: PUSH
61612: LD_INT 2
61614: NEG
61615: PUSH
61616: LD_INT 1
61618: NEG
61619: PUSH
61620: EMPTY
61621: LIST
61622: LIST
61623: PUSH
61624: LD_INT 2
61626: NEG
61627: PUSH
61628: LD_INT 2
61630: NEG
61631: PUSH
61632: EMPTY
61633: LIST
61634: LIST
61635: PUSH
61636: LD_INT 1
61638: NEG
61639: PUSH
61640: LD_INT 2
61642: PUSH
61643: EMPTY
61644: LIST
61645: LIST
61646: PUSH
61647: LD_INT 2
61649: NEG
61650: PUSH
61651: LD_INT 1
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: PUSH
61658: LD_INT 3
61660: NEG
61661: PUSH
61662: LD_INT 1
61664: NEG
61665: PUSH
61666: EMPTY
61667: LIST
61668: LIST
61669: PUSH
61670: LD_INT 3
61672: NEG
61673: PUSH
61674: LD_INT 2
61676: NEG
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: LIST
61686: LIST
61687: LIST
61688: LIST
61689: LIST
61690: LIST
61691: LIST
61692: LIST
61693: LIST
61694: LIST
61695: LIST
61696: LIST
61697: LIST
61698: LIST
61699: LIST
61700: LIST
61701: LIST
61702: LIST
61703: LIST
61704: LIST
61705: LIST
61706: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
61707: LD_ADDR_VAR 0 28
61711: PUSH
61712: LD_INT 0
61714: PUSH
61715: LD_INT 0
61717: PUSH
61718: EMPTY
61719: LIST
61720: LIST
61721: PUSH
61722: LD_INT 0
61724: PUSH
61725: LD_INT 1
61727: NEG
61728: PUSH
61729: EMPTY
61730: LIST
61731: LIST
61732: PUSH
61733: LD_INT 1
61735: PUSH
61736: LD_INT 0
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: LD_INT 1
61745: PUSH
61746: LD_INT 1
61748: PUSH
61749: EMPTY
61750: LIST
61751: LIST
61752: PUSH
61753: LD_INT 0
61755: PUSH
61756: LD_INT 1
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PUSH
61763: LD_INT 1
61765: NEG
61766: PUSH
61767: LD_INT 0
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: PUSH
61774: LD_INT 1
61776: NEG
61777: PUSH
61778: LD_INT 1
61780: NEG
61781: PUSH
61782: EMPTY
61783: LIST
61784: LIST
61785: PUSH
61786: LD_INT 1
61788: NEG
61789: PUSH
61790: LD_INT 2
61792: NEG
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: PUSH
61798: LD_INT 0
61800: PUSH
61801: LD_INT 2
61803: NEG
61804: PUSH
61805: EMPTY
61806: LIST
61807: LIST
61808: PUSH
61809: LD_INT 1
61811: PUSH
61812: LD_INT 1
61814: NEG
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: PUSH
61820: LD_INT 2
61822: PUSH
61823: LD_INT 0
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: PUSH
61830: LD_INT 2
61832: PUSH
61833: LD_INT 1
61835: PUSH
61836: EMPTY
61837: LIST
61838: LIST
61839: PUSH
61840: LD_INT 2
61842: PUSH
61843: LD_INT 2
61845: PUSH
61846: EMPTY
61847: LIST
61848: LIST
61849: PUSH
61850: LD_INT 1
61852: PUSH
61853: LD_INT 2
61855: PUSH
61856: EMPTY
61857: LIST
61858: LIST
61859: PUSH
61860: LD_INT 0
61862: PUSH
61863: LD_INT 2
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: LD_INT 1
61872: NEG
61873: PUSH
61874: LD_INT 1
61876: PUSH
61877: EMPTY
61878: LIST
61879: LIST
61880: PUSH
61881: LD_INT 2
61883: NEG
61884: PUSH
61885: LD_INT 0
61887: PUSH
61888: EMPTY
61889: LIST
61890: LIST
61891: PUSH
61892: LD_INT 2
61894: NEG
61895: PUSH
61896: LD_INT 1
61898: NEG
61899: PUSH
61900: EMPTY
61901: LIST
61902: LIST
61903: PUSH
61904: LD_INT 2
61906: NEG
61907: PUSH
61908: LD_INT 2
61910: NEG
61911: PUSH
61912: EMPTY
61913: LIST
61914: LIST
61915: PUSH
61916: LD_INT 2
61918: NEG
61919: PUSH
61920: LD_INT 3
61922: NEG
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 1
61930: NEG
61931: PUSH
61932: LD_INT 3
61934: NEG
61935: PUSH
61936: EMPTY
61937: LIST
61938: LIST
61939: PUSH
61940: LD_INT 3
61942: NEG
61943: PUSH
61944: LD_INT 1
61946: NEG
61947: PUSH
61948: EMPTY
61949: LIST
61950: LIST
61951: PUSH
61952: LD_INT 3
61954: NEG
61955: PUSH
61956: LD_INT 2
61958: NEG
61959: PUSH
61960: EMPTY
61961: LIST
61962: LIST
61963: PUSH
61964: EMPTY
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: LIST
61986: LIST
61987: LIST
61988: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
61989: LD_ADDR_VAR 0 29
61993: PUSH
61994: LD_INT 0
61996: PUSH
61997: LD_INT 0
61999: PUSH
62000: EMPTY
62001: LIST
62002: LIST
62003: PUSH
62004: LD_INT 0
62006: PUSH
62007: LD_INT 1
62009: NEG
62010: PUSH
62011: EMPTY
62012: LIST
62013: LIST
62014: PUSH
62015: LD_INT 1
62017: PUSH
62018: LD_INT 0
62020: PUSH
62021: EMPTY
62022: LIST
62023: LIST
62024: PUSH
62025: LD_INT 1
62027: PUSH
62028: LD_INT 1
62030: PUSH
62031: EMPTY
62032: LIST
62033: LIST
62034: PUSH
62035: LD_INT 0
62037: PUSH
62038: LD_INT 1
62040: PUSH
62041: EMPTY
62042: LIST
62043: LIST
62044: PUSH
62045: LD_INT 1
62047: NEG
62048: PUSH
62049: LD_INT 0
62051: PUSH
62052: EMPTY
62053: LIST
62054: LIST
62055: PUSH
62056: LD_INT 1
62058: NEG
62059: PUSH
62060: LD_INT 1
62062: NEG
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: LD_INT 1
62070: NEG
62071: PUSH
62072: LD_INT 2
62074: NEG
62075: PUSH
62076: EMPTY
62077: LIST
62078: LIST
62079: PUSH
62080: LD_INT 0
62082: PUSH
62083: LD_INT 2
62085: NEG
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PUSH
62091: LD_INT 1
62093: PUSH
62094: LD_INT 1
62096: NEG
62097: PUSH
62098: EMPTY
62099: LIST
62100: LIST
62101: PUSH
62102: LD_INT 2
62104: PUSH
62105: LD_INT 0
62107: PUSH
62108: EMPTY
62109: LIST
62110: LIST
62111: PUSH
62112: LD_INT 2
62114: PUSH
62115: LD_INT 1
62117: PUSH
62118: EMPTY
62119: LIST
62120: LIST
62121: PUSH
62122: LD_INT 1
62124: PUSH
62125: LD_INT 2
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PUSH
62132: LD_INT 0
62134: PUSH
62135: LD_INT 2
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 1
62144: NEG
62145: PUSH
62146: LD_INT 1
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PUSH
62153: LD_INT 2
62155: NEG
62156: PUSH
62157: LD_INT 1
62159: NEG
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: PUSH
62165: LD_INT 2
62167: NEG
62168: PUSH
62169: LD_INT 2
62171: NEG
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: PUSH
62177: LD_INT 2
62179: NEG
62180: PUSH
62181: LD_INT 3
62183: NEG
62184: PUSH
62185: EMPTY
62186: LIST
62187: LIST
62188: PUSH
62189: LD_INT 2
62191: PUSH
62192: LD_INT 1
62194: NEG
62195: PUSH
62196: EMPTY
62197: LIST
62198: LIST
62199: PUSH
62200: LD_INT 3
62202: PUSH
62203: LD_INT 1
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: PUSH
62210: LD_INT 1
62212: PUSH
62213: LD_INT 3
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: PUSH
62220: LD_INT 1
62222: NEG
62223: PUSH
62224: LD_INT 2
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: LD_INT 3
62233: NEG
62234: PUSH
62235: LD_INT 2
62237: NEG
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: LIST
62247: LIST
62248: LIST
62249: LIST
62250: LIST
62251: LIST
62252: LIST
62253: LIST
62254: LIST
62255: LIST
62256: LIST
62257: LIST
62258: LIST
62259: LIST
62260: LIST
62261: LIST
62262: LIST
62263: LIST
62264: LIST
62265: LIST
62266: LIST
62267: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
62268: LD_ADDR_VAR 0 30
62272: PUSH
62273: LD_INT 0
62275: PUSH
62276: LD_INT 0
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: LD_INT 0
62285: PUSH
62286: LD_INT 1
62288: NEG
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 1
62296: PUSH
62297: LD_INT 0
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PUSH
62304: LD_INT 1
62306: PUSH
62307: LD_INT 1
62309: PUSH
62310: EMPTY
62311: LIST
62312: LIST
62313: PUSH
62314: LD_INT 0
62316: PUSH
62317: LD_INT 1
62319: PUSH
62320: EMPTY
62321: LIST
62322: LIST
62323: PUSH
62324: LD_INT 1
62326: NEG
62327: PUSH
62328: LD_INT 0
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: PUSH
62335: LD_INT 1
62337: NEG
62338: PUSH
62339: LD_INT 1
62341: NEG
62342: PUSH
62343: EMPTY
62344: LIST
62345: LIST
62346: PUSH
62347: LD_INT 1
62349: NEG
62350: PUSH
62351: LD_INT 2
62353: NEG
62354: PUSH
62355: EMPTY
62356: LIST
62357: LIST
62358: PUSH
62359: LD_INT 0
62361: PUSH
62362: LD_INT 2
62364: NEG
62365: PUSH
62366: EMPTY
62367: LIST
62368: LIST
62369: PUSH
62370: LD_INT 1
62372: PUSH
62373: LD_INT 1
62375: NEG
62376: PUSH
62377: EMPTY
62378: LIST
62379: LIST
62380: PUSH
62381: LD_INT 2
62383: PUSH
62384: LD_INT 0
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: PUSH
62391: LD_INT 2
62393: PUSH
62394: LD_INT 1
62396: PUSH
62397: EMPTY
62398: LIST
62399: LIST
62400: PUSH
62401: LD_INT 2
62403: PUSH
62404: LD_INT 2
62406: PUSH
62407: EMPTY
62408: LIST
62409: LIST
62410: PUSH
62411: LD_INT 1
62413: PUSH
62414: LD_INT 2
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PUSH
62421: LD_INT 1
62423: NEG
62424: PUSH
62425: LD_INT 1
62427: PUSH
62428: EMPTY
62429: LIST
62430: LIST
62431: PUSH
62432: LD_INT 2
62434: NEG
62435: PUSH
62436: LD_INT 0
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PUSH
62443: LD_INT 2
62445: NEG
62446: PUSH
62447: LD_INT 1
62449: NEG
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: PUSH
62455: LD_INT 1
62457: NEG
62458: PUSH
62459: LD_INT 3
62461: NEG
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: PUSH
62467: LD_INT 1
62469: PUSH
62470: LD_INT 2
62472: NEG
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 3
62480: PUSH
62481: LD_INT 2
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 2
62490: PUSH
62491: LD_INT 3
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 2
62500: NEG
62501: PUSH
62502: LD_INT 1
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 3
62511: NEG
62512: PUSH
62513: LD_INT 1
62515: NEG
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: PUSH
62521: EMPTY
62522: LIST
62523: LIST
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: LIST
62529: LIST
62530: LIST
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: LIST
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
62546: LD_ADDR_VAR 0 31
62550: PUSH
62551: LD_INT 0
62553: PUSH
62554: LD_INT 0
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: LD_INT 0
62563: PUSH
62564: LD_INT 1
62566: NEG
62567: PUSH
62568: EMPTY
62569: LIST
62570: LIST
62571: PUSH
62572: LD_INT 1
62574: PUSH
62575: LD_INT 0
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: PUSH
62582: LD_INT 1
62584: PUSH
62585: LD_INT 1
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 0
62594: PUSH
62595: LD_INT 1
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: LD_INT 1
62604: NEG
62605: PUSH
62606: LD_INT 0
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: PUSH
62613: LD_INT 1
62615: NEG
62616: PUSH
62617: LD_INT 1
62619: NEG
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: PUSH
62625: LD_INT 1
62627: NEG
62628: PUSH
62629: LD_INT 2
62631: NEG
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: PUSH
62637: LD_INT 1
62639: PUSH
62640: LD_INT 1
62642: NEG
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 2
62650: PUSH
62651: LD_INT 0
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PUSH
62658: LD_INT 2
62660: PUSH
62661: LD_INT 1
62663: PUSH
62664: EMPTY
62665: LIST
62666: LIST
62667: PUSH
62668: LD_INT 2
62670: PUSH
62671: LD_INT 2
62673: PUSH
62674: EMPTY
62675: LIST
62676: LIST
62677: PUSH
62678: LD_INT 1
62680: PUSH
62681: LD_INT 2
62683: PUSH
62684: EMPTY
62685: LIST
62686: LIST
62687: PUSH
62688: LD_INT 0
62690: PUSH
62691: LD_INT 2
62693: PUSH
62694: EMPTY
62695: LIST
62696: LIST
62697: PUSH
62698: LD_INT 1
62700: NEG
62701: PUSH
62702: LD_INT 1
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 2
62711: NEG
62712: PUSH
62713: LD_INT 1
62715: NEG
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PUSH
62721: LD_INT 2
62723: NEG
62724: PUSH
62725: LD_INT 2
62727: NEG
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 2
62735: NEG
62736: PUSH
62737: LD_INT 3
62739: NEG
62740: PUSH
62741: EMPTY
62742: LIST
62743: LIST
62744: PUSH
62745: LD_INT 2
62747: PUSH
62748: LD_INT 1
62750: NEG
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PUSH
62756: LD_INT 3
62758: PUSH
62759: LD_INT 1
62761: PUSH
62762: EMPTY
62763: LIST
62764: LIST
62765: PUSH
62766: LD_INT 1
62768: PUSH
62769: LD_INT 3
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: PUSH
62776: LD_INT 1
62778: NEG
62779: PUSH
62780: LD_INT 2
62782: PUSH
62783: EMPTY
62784: LIST
62785: LIST
62786: PUSH
62787: LD_INT 3
62789: NEG
62790: PUSH
62791: LD_INT 2
62793: NEG
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: LIST
62803: LIST
62804: LIST
62805: LIST
62806: LIST
62807: LIST
62808: LIST
62809: LIST
62810: LIST
62811: LIST
62812: LIST
62813: LIST
62814: LIST
62815: LIST
62816: LIST
62817: LIST
62818: LIST
62819: LIST
62820: LIST
62821: LIST
62822: LIST
62823: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
62824: LD_ADDR_VAR 0 32
62828: PUSH
62829: LD_INT 0
62831: PUSH
62832: LD_INT 0
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: PUSH
62839: LD_INT 0
62841: PUSH
62842: LD_INT 1
62844: NEG
62845: PUSH
62846: EMPTY
62847: LIST
62848: LIST
62849: PUSH
62850: LD_INT 1
62852: PUSH
62853: LD_INT 0
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 1
62862: PUSH
62863: LD_INT 1
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 0
62872: PUSH
62873: LD_INT 1
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 1
62882: NEG
62883: PUSH
62884: LD_INT 0
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 1
62893: NEG
62894: PUSH
62895: LD_INT 1
62897: NEG
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: PUSH
62903: LD_INT 1
62905: NEG
62906: PUSH
62907: LD_INT 2
62909: NEG
62910: PUSH
62911: EMPTY
62912: LIST
62913: LIST
62914: PUSH
62915: LD_INT 0
62917: PUSH
62918: LD_INT 2
62920: NEG
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: PUSH
62926: LD_INT 1
62928: PUSH
62929: LD_INT 1
62931: NEG
62932: PUSH
62933: EMPTY
62934: LIST
62935: LIST
62936: PUSH
62937: LD_INT 2
62939: PUSH
62940: LD_INT 1
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PUSH
62947: LD_INT 2
62949: PUSH
62950: LD_INT 2
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 1
62959: PUSH
62960: LD_INT 2
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 0
62969: PUSH
62970: LD_INT 2
62972: PUSH
62973: EMPTY
62974: LIST
62975: LIST
62976: PUSH
62977: LD_INT 1
62979: NEG
62980: PUSH
62981: LD_INT 1
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 2
62990: NEG
62991: PUSH
62992: LD_INT 0
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: LD_INT 2
63001: NEG
63002: PUSH
63003: LD_INT 1
63005: NEG
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 1
63013: NEG
63014: PUSH
63015: LD_INT 3
63017: NEG
63018: PUSH
63019: EMPTY
63020: LIST
63021: LIST
63022: PUSH
63023: LD_INT 1
63025: PUSH
63026: LD_INT 2
63028: NEG
63029: PUSH
63030: EMPTY
63031: LIST
63032: LIST
63033: PUSH
63034: LD_INT 3
63036: PUSH
63037: LD_INT 2
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: PUSH
63044: LD_INT 2
63046: PUSH
63047: LD_INT 3
63049: PUSH
63050: EMPTY
63051: LIST
63052: LIST
63053: PUSH
63054: LD_INT 2
63056: NEG
63057: PUSH
63058: LD_INT 1
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 3
63067: NEG
63068: PUSH
63069: LD_INT 1
63071: NEG
63072: PUSH
63073: EMPTY
63074: LIST
63075: LIST
63076: PUSH
63077: EMPTY
63078: LIST
63079: LIST
63080: LIST
63081: LIST
63082: LIST
63083: LIST
63084: LIST
63085: LIST
63086: LIST
63087: LIST
63088: LIST
63089: LIST
63090: LIST
63091: LIST
63092: LIST
63093: LIST
63094: LIST
63095: LIST
63096: LIST
63097: LIST
63098: LIST
63099: LIST
63100: LIST
63101: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
63102: LD_ADDR_VAR 0 33
63106: PUSH
63107: LD_INT 0
63109: PUSH
63110: LD_INT 0
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 0
63119: PUSH
63120: LD_INT 1
63122: NEG
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 1
63130: PUSH
63131: LD_INT 0
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: LD_INT 1
63140: PUSH
63141: LD_INT 1
63143: PUSH
63144: EMPTY
63145: LIST
63146: LIST
63147: PUSH
63148: LD_INT 0
63150: PUSH
63151: LD_INT 1
63153: PUSH
63154: EMPTY
63155: LIST
63156: LIST
63157: PUSH
63158: LD_INT 1
63160: NEG
63161: PUSH
63162: LD_INT 0
63164: PUSH
63165: EMPTY
63166: LIST
63167: LIST
63168: PUSH
63169: LD_INT 1
63171: NEG
63172: PUSH
63173: LD_INT 1
63175: NEG
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PUSH
63181: LD_INT 1
63183: NEG
63184: PUSH
63185: LD_INT 2
63187: NEG
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 1
63195: PUSH
63196: LD_INT 1
63198: NEG
63199: PUSH
63200: EMPTY
63201: LIST
63202: LIST
63203: PUSH
63204: LD_INT 2
63206: PUSH
63207: LD_INT 0
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PUSH
63214: LD_INT 2
63216: PUSH
63217: LD_INT 1
63219: PUSH
63220: EMPTY
63221: LIST
63222: LIST
63223: PUSH
63224: LD_INT 1
63226: PUSH
63227: LD_INT 2
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PUSH
63234: LD_INT 0
63236: PUSH
63237: LD_INT 2
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: LD_INT 1
63246: NEG
63247: PUSH
63248: LD_INT 1
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: PUSH
63255: LD_INT 2
63257: NEG
63258: PUSH
63259: LD_INT 0
63261: PUSH
63262: EMPTY
63263: LIST
63264: LIST
63265: PUSH
63266: LD_INT 2
63268: NEG
63269: PUSH
63270: LD_INT 1
63272: NEG
63273: PUSH
63274: EMPTY
63275: LIST
63276: LIST
63277: PUSH
63278: LD_INT 2
63280: NEG
63281: PUSH
63282: LD_INT 2
63284: NEG
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: PUSH
63290: LD_INT 2
63292: NEG
63293: PUSH
63294: LD_INT 3
63296: NEG
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 2
63304: PUSH
63305: LD_INT 1
63307: NEG
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 3
63315: PUSH
63316: LD_INT 1
63318: PUSH
63319: EMPTY
63320: LIST
63321: LIST
63322: PUSH
63323: LD_INT 1
63325: PUSH
63326: LD_INT 3
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: LD_INT 1
63335: NEG
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 3
63346: NEG
63347: PUSH
63348: LD_INT 2
63350: NEG
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: LIST
63362: LIST
63363: LIST
63364: LIST
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: LIST
63372: LIST
63373: LIST
63374: LIST
63375: LIST
63376: LIST
63377: LIST
63378: LIST
63379: LIST
63380: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
63381: LD_ADDR_VAR 0 34
63385: PUSH
63386: LD_INT 0
63388: PUSH
63389: LD_INT 0
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PUSH
63396: LD_INT 0
63398: PUSH
63399: LD_INT 1
63401: NEG
63402: PUSH
63403: EMPTY
63404: LIST
63405: LIST
63406: PUSH
63407: LD_INT 1
63409: PUSH
63410: LD_INT 0
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_INT 1
63419: PUSH
63420: LD_INT 1
63422: PUSH
63423: EMPTY
63424: LIST
63425: LIST
63426: PUSH
63427: LD_INT 0
63429: PUSH
63430: LD_INT 1
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 1
63439: NEG
63440: PUSH
63441: LD_INT 0
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: PUSH
63448: LD_INT 1
63450: NEG
63451: PUSH
63452: LD_INT 1
63454: NEG
63455: PUSH
63456: EMPTY
63457: LIST
63458: LIST
63459: PUSH
63460: LD_INT 1
63462: NEG
63463: PUSH
63464: LD_INT 2
63466: NEG
63467: PUSH
63468: EMPTY
63469: LIST
63470: LIST
63471: PUSH
63472: LD_INT 0
63474: PUSH
63475: LD_INT 2
63477: NEG
63478: PUSH
63479: EMPTY
63480: LIST
63481: LIST
63482: PUSH
63483: LD_INT 1
63485: PUSH
63486: LD_INT 1
63488: NEG
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PUSH
63494: LD_INT 2
63496: PUSH
63497: LD_INT 1
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: PUSH
63504: LD_INT 2
63506: PUSH
63507: LD_INT 2
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: PUSH
63514: LD_INT 1
63516: PUSH
63517: LD_INT 2
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 1
63526: NEG
63527: PUSH
63528: LD_INT 1
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 2
63537: NEG
63538: PUSH
63539: LD_INT 0
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: LD_INT 2
63548: NEG
63549: PUSH
63550: LD_INT 1
63552: NEG
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: PUSH
63558: LD_INT 2
63560: NEG
63561: PUSH
63562: LD_INT 2
63564: NEG
63565: PUSH
63566: EMPTY
63567: LIST
63568: LIST
63569: PUSH
63570: LD_INT 1
63572: NEG
63573: PUSH
63574: LD_INT 3
63576: NEG
63577: PUSH
63578: EMPTY
63579: LIST
63580: LIST
63581: PUSH
63582: LD_INT 1
63584: PUSH
63585: LD_INT 2
63587: NEG
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: PUSH
63593: LD_INT 3
63595: PUSH
63596: LD_INT 2
63598: PUSH
63599: EMPTY
63600: LIST
63601: LIST
63602: PUSH
63603: LD_INT 2
63605: PUSH
63606: LD_INT 3
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: PUSH
63613: LD_INT 2
63615: NEG
63616: PUSH
63617: LD_INT 1
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: LD_INT 3
63626: NEG
63627: PUSH
63628: LD_INT 1
63630: NEG
63631: PUSH
63632: EMPTY
63633: LIST
63634: LIST
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
63661: LD_ADDR_VAR 0 35
63665: PUSH
63666: LD_INT 0
63668: PUSH
63669: LD_INT 0
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: PUSH
63676: LD_INT 0
63678: PUSH
63679: LD_INT 1
63681: NEG
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 1
63689: PUSH
63690: LD_INT 0
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: LD_INT 1
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PUSH
63707: LD_INT 0
63709: PUSH
63710: LD_INT 1
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PUSH
63717: LD_INT 1
63719: NEG
63720: PUSH
63721: LD_INT 0
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 1
63730: NEG
63731: PUSH
63732: LD_INT 1
63734: NEG
63735: PUSH
63736: EMPTY
63737: LIST
63738: LIST
63739: PUSH
63740: LD_INT 2
63742: PUSH
63743: LD_INT 1
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PUSH
63750: LD_INT 2
63752: NEG
63753: PUSH
63754: LD_INT 1
63756: NEG
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
63773: LD_ADDR_VAR 0 36
63777: PUSH
63778: LD_INT 0
63780: PUSH
63781: LD_INT 0
63783: PUSH
63784: EMPTY
63785: LIST
63786: LIST
63787: PUSH
63788: LD_INT 0
63790: PUSH
63791: LD_INT 1
63793: NEG
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PUSH
63799: LD_INT 1
63801: PUSH
63802: LD_INT 0
63804: PUSH
63805: EMPTY
63806: LIST
63807: LIST
63808: PUSH
63809: LD_INT 1
63811: PUSH
63812: LD_INT 1
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 0
63821: PUSH
63822: LD_INT 1
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 1
63831: NEG
63832: PUSH
63833: LD_INT 0
63835: PUSH
63836: EMPTY
63837: LIST
63838: LIST
63839: PUSH
63840: LD_INT 1
63842: NEG
63843: PUSH
63844: LD_INT 1
63846: NEG
63847: PUSH
63848: EMPTY
63849: LIST
63850: LIST
63851: PUSH
63852: LD_INT 1
63854: NEG
63855: PUSH
63856: LD_INT 2
63858: NEG
63859: PUSH
63860: EMPTY
63861: LIST
63862: LIST
63863: PUSH
63864: LD_INT 1
63866: PUSH
63867: LD_INT 2
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
63885: LD_ADDR_VAR 0 37
63889: PUSH
63890: LD_INT 0
63892: PUSH
63893: LD_INT 0
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 0
63902: PUSH
63903: LD_INT 1
63905: NEG
63906: PUSH
63907: EMPTY
63908: LIST
63909: LIST
63910: PUSH
63911: LD_INT 1
63913: PUSH
63914: LD_INT 0
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: PUSH
63921: LD_INT 1
63923: PUSH
63924: LD_INT 1
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: LD_INT 0
63933: PUSH
63934: LD_INT 1
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 1
63943: NEG
63944: PUSH
63945: LD_INT 0
63947: PUSH
63948: EMPTY
63949: LIST
63950: LIST
63951: PUSH
63952: LD_INT 1
63954: NEG
63955: PUSH
63956: LD_INT 1
63958: NEG
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 1
63966: PUSH
63967: LD_INT 1
63969: NEG
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 1
63977: NEG
63978: PUSH
63979: LD_INT 1
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: LIST
63990: LIST
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: LIST
63996: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
63997: LD_ADDR_VAR 0 38
64001: PUSH
64002: LD_INT 0
64004: PUSH
64005: LD_INT 0
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 0
64014: PUSH
64015: LD_INT 1
64017: NEG
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 1
64025: PUSH
64026: LD_INT 0
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: LD_INT 1
64035: PUSH
64036: LD_INT 1
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 0
64045: PUSH
64046: LD_INT 1
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: LD_INT 1
64055: NEG
64056: PUSH
64057: LD_INT 0
64059: PUSH
64060: EMPTY
64061: LIST
64062: LIST
64063: PUSH
64064: LD_INT 1
64066: NEG
64067: PUSH
64068: LD_INT 1
64070: NEG
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 2
64078: PUSH
64079: LD_INT 1
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: PUSH
64086: LD_INT 2
64088: NEG
64089: PUSH
64090: LD_INT 1
64092: NEG
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PUSH
64098: EMPTY
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
64109: LD_ADDR_VAR 0 39
64113: PUSH
64114: LD_INT 0
64116: PUSH
64117: LD_INT 0
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: LD_INT 0
64126: PUSH
64127: LD_INT 1
64129: NEG
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: LD_INT 1
64137: PUSH
64138: LD_INT 0
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PUSH
64145: LD_INT 1
64147: PUSH
64148: LD_INT 1
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 0
64157: PUSH
64158: LD_INT 1
64160: PUSH
64161: EMPTY
64162: LIST
64163: LIST
64164: PUSH
64165: LD_INT 1
64167: NEG
64168: PUSH
64169: LD_INT 0
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 1
64178: NEG
64179: PUSH
64180: LD_INT 1
64182: NEG
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: PUSH
64188: LD_INT 1
64190: NEG
64191: PUSH
64192: LD_INT 2
64194: NEG
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: LD_INT 1
64202: PUSH
64203: LD_INT 2
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: LIST
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
64221: LD_ADDR_VAR 0 40
64225: PUSH
64226: LD_INT 0
64228: PUSH
64229: LD_INT 0
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 0
64238: PUSH
64239: LD_INT 1
64241: NEG
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: PUSH
64247: LD_INT 1
64249: PUSH
64250: LD_INT 0
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 1
64259: PUSH
64260: LD_INT 1
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 0
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 1
64279: NEG
64280: PUSH
64281: LD_INT 0
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 1
64290: NEG
64291: PUSH
64292: LD_INT 1
64294: NEG
64295: PUSH
64296: EMPTY
64297: LIST
64298: LIST
64299: PUSH
64300: LD_INT 1
64302: PUSH
64303: LD_INT 1
64305: NEG
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 1
64313: NEG
64314: PUSH
64315: LD_INT 1
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: EMPTY
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64333: LD_ADDR_VAR 0 41
64337: PUSH
64338: LD_INT 0
64340: PUSH
64341: LD_INT 0
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 0
64350: PUSH
64351: LD_INT 1
64353: NEG
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 1
64361: PUSH
64362: LD_INT 0
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 1
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 0
64381: PUSH
64382: LD_INT 1
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: NEG
64392: PUSH
64393: LD_INT 0
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: LD_INT 1
64402: NEG
64403: PUSH
64404: LD_INT 1
64406: NEG
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: PUSH
64412: LD_INT 1
64414: NEG
64415: PUSH
64416: LD_INT 2
64418: NEG
64419: PUSH
64420: EMPTY
64421: LIST
64422: LIST
64423: PUSH
64424: LD_INT 1
64426: PUSH
64427: LD_INT 1
64429: NEG
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: LD_INT 2
64437: PUSH
64438: LD_INT 0
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: PUSH
64445: LD_INT 2
64447: PUSH
64448: LD_INT 1
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 2
64457: PUSH
64458: LD_INT 2
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 1
64467: PUSH
64468: LD_INT 2
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 1
64477: NEG
64478: PUSH
64479: LD_INT 1
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 2
64488: NEG
64489: PUSH
64490: LD_INT 0
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 2
64499: NEG
64500: PUSH
64501: LD_INT 1
64503: NEG
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 2
64511: NEG
64512: PUSH
64513: LD_INT 2
64515: NEG
64516: PUSH
64517: EMPTY
64518: LIST
64519: LIST
64520: PUSH
64521: LD_INT 2
64523: NEG
64524: PUSH
64525: LD_INT 3
64527: NEG
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: PUSH
64533: LD_INT 2
64535: PUSH
64536: LD_INT 1
64538: NEG
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PUSH
64544: LD_INT 3
64546: PUSH
64547: LD_INT 0
64549: PUSH
64550: EMPTY
64551: LIST
64552: LIST
64553: PUSH
64554: LD_INT 3
64556: PUSH
64557: LD_INT 1
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: PUSH
64564: LD_INT 3
64566: PUSH
64567: LD_INT 2
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: LD_INT 3
64576: PUSH
64577: LD_INT 3
64579: PUSH
64580: EMPTY
64581: LIST
64582: LIST
64583: PUSH
64584: LD_INT 2
64586: PUSH
64587: LD_INT 3
64589: PUSH
64590: EMPTY
64591: LIST
64592: LIST
64593: PUSH
64594: LD_INT 2
64596: NEG
64597: PUSH
64598: LD_INT 1
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: PUSH
64605: LD_INT 3
64607: NEG
64608: PUSH
64609: LD_INT 0
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_INT 3
64618: NEG
64619: PUSH
64620: LD_INT 1
64622: NEG
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 3
64630: NEG
64631: PUSH
64632: LD_INT 2
64634: NEG
64635: PUSH
64636: EMPTY
64637: LIST
64638: LIST
64639: PUSH
64640: LD_INT 3
64642: NEG
64643: PUSH
64644: LD_INT 3
64646: NEG
64647: PUSH
64648: EMPTY
64649: LIST
64650: LIST
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: LIST
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64683: LD_ADDR_VAR 0 42
64687: PUSH
64688: LD_INT 0
64690: PUSH
64691: LD_INT 0
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: PUSH
64698: LD_INT 0
64700: PUSH
64701: LD_INT 1
64703: NEG
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PUSH
64709: LD_INT 1
64711: PUSH
64712: LD_INT 0
64714: PUSH
64715: EMPTY
64716: LIST
64717: LIST
64718: PUSH
64719: LD_INT 1
64721: PUSH
64722: LD_INT 1
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: PUSH
64729: LD_INT 0
64731: PUSH
64732: LD_INT 1
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: LD_INT 1
64741: NEG
64742: PUSH
64743: LD_INT 0
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 1
64752: NEG
64753: PUSH
64754: LD_INT 1
64756: NEG
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: LD_INT 1
64764: NEG
64765: PUSH
64766: LD_INT 2
64768: NEG
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: LD_INT 2
64779: NEG
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 1
64787: PUSH
64788: LD_INT 1
64790: NEG
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 2
64798: PUSH
64799: LD_INT 1
64801: PUSH
64802: EMPTY
64803: LIST
64804: LIST
64805: PUSH
64806: LD_INT 2
64808: PUSH
64809: LD_INT 2
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: LD_INT 2
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 0
64828: PUSH
64829: LD_INT 2
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 1
64838: NEG
64839: PUSH
64840: LD_INT 1
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 2
64849: NEG
64850: PUSH
64851: LD_INT 1
64853: NEG
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 2
64861: NEG
64862: PUSH
64863: LD_INT 2
64865: NEG
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: LD_INT 2
64873: NEG
64874: PUSH
64875: LD_INT 3
64877: NEG
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 1
64885: NEG
64886: PUSH
64887: LD_INT 3
64889: NEG
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 0
64897: PUSH
64898: LD_INT 3
64900: NEG
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: LD_INT 1
64908: PUSH
64909: LD_INT 2
64911: NEG
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: LD_INT 3
64919: PUSH
64920: LD_INT 2
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 3
64929: PUSH
64930: LD_INT 3
64932: PUSH
64933: EMPTY
64934: LIST
64935: LIST
64936: PUSH
64937: LD_INT 2
64939: PUSH
64940: LD_INT 3
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 1
64949: PUSH
64950: LD_INT 3
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 0
64959: PUSH
64960: LD_INT 3
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 1
64969: NEG
64970: PUSH
64971: LD_INT 2
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 3
64980: NEG
64981: PUSH
64982: LD_INT 2
64984: NEG
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: PUSH
64990: LD_INT 3
64992: NEG
64993: PUSH
64994: LD_INT 3
64996: NEG
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: LIST
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65033: LD_ADDR_VAR 0 43
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 0
65050: PUSH
65051: LD_INT 1
65053: NEG
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 1
65061: PUSH
65062: LD_INT 0
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 1
65071: PUSH
65072: LD_INT 1
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 0
65081: PUSH
65082: LD_INT 1
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 1
65091: NEG
65092: PUSH
65093: LD_INT 0
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: LD_INT 1
65102: NEG
65103: PUSH
65104: LD_INT 1
65106: NEG
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 1
65114: NEG
65115: PUSH
65116: LD_INT 2
65118: NEG
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 0
65126: PUSH
65127: LD_INT 2
65129: NEG
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: PUSH
65135: LD_INT 1
65137: PUSH
65138: LD_INT 1
65140: NEG
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 2
65148: PUSH
65149: LD_INT 0
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: LD_INT 2
65158: PUSH
65159: LD_INT 1
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 1
65168: PUSH
65169: LD_INT 2
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: LD_INT 0
65178: PUSH
65179: LD_INT 2
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PUSH
65186: LD_INT 1
65188: NEG
65189: PUSH
65190: LD_INT 1
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 2
65199: NEG
65200: PUSH
65201: LD_INT 0
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: LD_INT 2
65210: NEG
65211: PUSH
65212: LD_INT 1
65214: NEG
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PUSH
65220: LD_INT 1
65222: NEG
65223: PUSH
65224: LD_INT 3
65226: NEG
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PUSH
65232: LD_INT 0
65234: PUSH
65235: LD_INT 3
65237: NEG
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: PUSH
65243: LD_INT 1
65245: PUSH
65246: LD_INT 2
65248: NEG
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: PUSH
65254: LD_INT 2
65256: PUSH
65257: LD_INT 1
65259: NEG
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 3
65267: PUSH
65268: LD_INT 0
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 3
65277: PUSH
65278: LD_INT 1
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PUSH
65285: LD_INT 1
65287: PUSH
65288: LD_INT 3
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: PUSH
65295: LD_INT 0
65297: PUSH
65298: LD_INT 3
65300: PUSH
65301: EMPTY
65302: LIST
65303: LIST
65304: PUSH
65305: LD_INT 1
65307: NEG
65308: PUSH
65309: LD_INT 2
65311: PUSH
65312: EMPTY
65313: LIST
65314: LIST
65315: PUSH
65316: LD_INT 2
65318: NEG
65319: PUSH
65320: LD_INT 1
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 3
65329: NEG
65330: PUSH
65331: LD_INT 0
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: LD_INT 3
65340: NEG
65341: PUSH
65342: LD_INT 1
65344: NEG
65345: PUSH
65346: EMPTY
65347: LIST
65348: LIST
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65381: LD_ADDR_VAR 0 44
65385: PUSH
65386: LD_INT 0
65388: PUSH
65389: LD_INT 0
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 1
65401: NEG
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 1
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 1
65419: PUSH
65420: LD_INT 1
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 0
65429: PUSH
65430: LD_INT 1
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 1
65439: NEG
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: NEG
65451: PUSH
65452: LD_INT 1
65454: NEG
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 1
65462: NEG
65463: PUSH
65464: LD_INT 2
65466: NEG
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: LD_INT 1
65474: PUSH
65475: LD_INT 1
65477: NEG
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 2
65485: PUSH
65486: LD_INT 0
65488: PUSH
65489: EMPTY
65490: LIST
65491: LIST
65492: PUSH
65493: LD_INT 2
65495: PUSH
65496: LD_INT 1
65498: PUSH
65499: EMPTY
65500: LIST
65501: LIST
65502: PUSH
65503: LD_INT 2
65505: PUSH
65506: LD_INT 2
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 2
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: PUSH
65523: LD_INT 1
65525: NEG
65526: PUSH
65527: LD_INT 1
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: LD_INT 2
65536: NEG
65537: PUSH
65538: LD_INT 0
65540: PUSH
65541: EMPTY
65542: LIST
65543: LIST
65544: PUSH
65545: LD_INT 2
65547: NEG
65548: PUSH
65549: LD_INT 1
65551: NEG
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 2
65559: NEG
65560: PUSH
65561: LD_INT 2
65563: NEG
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: NEG
65572: PUSH
65573: LD_INT 3
65575: NEG
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: PUSH
65584: LD_INT 1
65586: NEG
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 3
65594: PUSH
65595: LD_INT 0
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: LD_INT 3
65604: PUSH
65605: LD_INT 1
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: PUSH
65612: LD_INT 3
65614: PUSH
65615: LD_INT 2
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 3
65624: PUSH
65625: LD_INT 3
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: PUSH
65632: LD_INT 2
65634: PUSH
65635: LD_INT 3
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: LD_INT 2
65644: NEG
65645: PUSH
65646: LD_INT 1
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 3
65655: NEG
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 3
65666: NEG
65667: PUSH
65668: LD_INT 1
65670: NEG
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: LD_INT 3
65678: NEG
65679: PUSH
65680: LD_INT 2
65682: NEG
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PUSH
65688: LD_INT 3
65690: NEG
65691: PUSH
65692: LD_INT 3
65694: NEG
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65731: LD_ADDR_VAR 0 45
65735: PUSH
65736: LD_INT 0
65738: PUSH
65739: LD_INT 0
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: LD_INT 0
65748: PUSH
65749: LD_INT 1
65751: NEG
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: PUSH
65760: LD_INT 0
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: LD_INT 1
65769: PUSH
65770: LD_INT 1
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 0
65779: PUSH
65780: LD_INT 1
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 1
65789: NEG
65790: PUSH
65791: LD_INT 0
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 1
65800: NEG
65801: PUSH
65802: LD_INT 1
65804: NEG
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 1
65812: NEG
65813: PUSH
65814: LD_INT 2
65816: NEG
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: PUSH
65822: LD_INT 0
65824: PUSH
65825: LD_INT 2
65827: NEG
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: LD_INT 1
65838: NEG
65839: PUSH
65840: EMPTY
65841: LIST
65842: LIST
65843: PUSH
65844: LD_INT 2
65846: PUSH
65847: LD_INT 1
65849: PUSH
65850: EMPTY
65851: LIST
65852: LIST
65853: PUSH
65854: LD_INT 2
65856: PUSH
65857: LD_INT 2
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: PUSH
65864: LD_INT 1
65866: PUSH
65867: LD_INT 2
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 0
65876: PUSH
65877: LD_INT 2
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 1
65886: NEG
65887: PUSH
65888: LD_INT 1
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 2
65897: NEG
65898: PUSH
65899: LD_INT 1
65901: NEG
65902: PUSH
65903: EMPTY
65904: LIST
65905: LIST
65906: PUSH
65907: LD_INT 2
65909: NEG
65910: PUSH
65911: LD_INT 2
65913: NEG
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PUSH
65919: LD_INT 2
65921: NEG
65922: PUSH
65923: LD_INT 3
65925: NEG
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 1
65933: NEG
65934: PUSH
65935: LD_INT 3
65937: NEG
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PUSH
65943: LD_INT 0
65945: PUSH
65946: LD_INT 3
65948: NEG
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 1
65956: PUSH
65957: LD_INT 2
65959: NEG
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 3
65967: PUSH
65968: LD_INT 2
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 3
65977: PUSH
65978: LD_INT 3
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 2
65987: PUSH
65988: LD_INT 3
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 1
65997: PUSH
65998: LD_INT 3
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 0
66007: PUSH
66008: LD_INT 3
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 1
66017: NEG
66018: PUSH
66019: LD_INT 2
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 3
66028: NEG
66029: PUSH
66030: LD_INT 2
66032: NEG
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 3
66040: NEG
66041: PUSH
66042: LD_INT 3
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66081: LD_ADDR_VAR 0 46
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: LD_INT 0
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 0
66098: PUSH
66099: LD_INT 1
66101: NEG
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: LD_INT 0
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 1
66119: PUSH
66120: LD_INT 1
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 0
66129: PUSH
66130: LD_INT 1
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 1
66139: NEG
66140: PUSH
66141: LD_INT 0
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 1
66150: NEG
66151: PUSH
66152: LD_INT 1
66154: NEG
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PUSH
66160: LD_INT 1
66162: NEG
66163: PUSH
66164: LD_INT 2
66166: NEG
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 0
66174: PUSH
66175: LD_INT 2
66177: NEG
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: PUSH
66183: LD_INT 1
66185: PUSH
66186: LD_INT 1
66188: NEG
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 2
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 2
66206: PUSH
66207: LD_INT 1
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: LD_INT 2
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 0
66226: PUSH
66227: LD_INT 2
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: LD_INT 1
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 2
66247: NEG
66248: PUSH
66249: LD_INT 0
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 2
66258: NEG
66259: PUSH
66260: LD_INT 1
66262: NEG
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 1
66270: NEG
66271: PUSH
66272: LD_INT 3
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 0
66282: PUSH
66283: LD_INT 3
66285: NEG
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 1
66293: PUSH
66294: LD_INT 2
66296: NEG
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 2
66304: PUSH
66305: LD_INT 1
66307: NEG
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 3
66315: PUSH
66316: LD_INT 0
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 3
66325: PUSH
66326: LD_INT 1
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: LD_INT 1
66335: PUSH
66336: LD_INT 3
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 0
66345: PUSH
66346: LD_INT 3
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: PUSH
66353: LD_INT 1
66355: NEG
66356: PUSH
66357: LD_INT 2
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: PUSH
66364: LD_INT 2
66366: NEG
66367: PUSH
66368: LD_INT 1
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 3
66377: NEG
66378: PUSH
66379: LD_INT 0
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 3
66388: NEG
66389: PUSH
66390: LD_INT 1
66392: NEG
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: LIST
66427: LIST
66428: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66429: LD_ADDR_VAR 0 47
66433: PUSH
66434: LD_INT 0
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 0
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 1
66457: PUSH
66458: LD_INT 0
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 1
66467: PUSH
66468: LD_INT 1
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 0
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 1
66487: NEG
66488: PUSH
66489: LD_INT 0
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: LD_INT 1
66502: NEG
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 2
66514: NEG
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 0
66522: PUSH
66523: LD_INT 2
66525: NEG
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: LD_INT 1
66533: PUSH
66534: LD_INT 1
66536: NEG
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 2
66544: NEG
66545: PUSH
66546: LD_INT 1
66548: NEG
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 2
66556: NEG
66557: PUSH
66558: LD_INT 2
66560: NEG
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
66580: LD_ADDR_VAR 0 48
66584: PUSH
66585: LD_INT 0
66587: PUSH
66588: LD_INT 0
66590: PUSH
66591: EMPTY
66592: LIST
66593: LIST
66594: PUSH
66595: LD_INT 0
66597: PUSH
66598: LD_INT 1
66600: NEG
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PUSH
66606: LD_INT 1
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: PUSH
66619: LD_INT 1
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 0
66628: PUSH
66629: LD_INT 1
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 1
66638: NEG
66639: PUSH
66640: LD_INT 0
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 1
66649: NEG
66650: PUSH
66651: LD_INT 1
66653: NEG
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 1
66661: NEG
66662: PUSH
66663: LD_INT 2
66665: NEG
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 0
66673: PUSH
66674: LD_INT 2
66676: NEG
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: LD_INT 1
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: LD_INT 2
66695: PUSH
66696: LD_INT 0
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: LD_INT 2
66705: PUSH
66706: LD_INT 1
66708: PUSH
66709: EMPTY
66710: LIST
66711: LIST
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
66727: LD_ADDR_VAR 0 49
66731: PUSH
66732: LD_INT 0
66734: PUSH
66735: LD_INT 0
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 0
66744: PUSH
66745: LD_INT 1
66747: NEG
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 1
66755: PUSH
66756: LD_INT 0
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 1
66765: PUSH
66766: LD_INT 1
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: LD_INT 1
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 1
66785: NEG
66786: PUSH
66787: LD_INT 0
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 1
66796: NEG
66797: PUSH
66798: LD_INT 1
66800: NEG
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: LD_INT 1
66811: NEG
66812: PUSH
66813: EMPTY
66814: LIST
66815: LIST
66816: PUSH
66817: LD_INT 2
66819: PUSH
66820: LD_INT 0
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 2
66829: PUSH
66830: LD_INT 1
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 2
66839: PUSH
66840: LD_INT 2
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: PUSH
66847: LD_INT 1
66849: PUSH
66850: LD_INT 2
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
66871: LD_ADDR_VAR 0 50
66875: PUSH
66876: LD_INT 0
66878: PUSH
66879: LD_INT 0
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: LD_INT 1
66891: NEG
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 1
66899: PUSH
66900: LD_INT 0
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 1
66909: PUSH
66910: LD_INT 1
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 0
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: NEG
66930: PUSH
66931: LD_INT 0
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 1
66940: NEG
66941: PUSH
66942: LD_INT 1
66944: NEG
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 2
66952: PUSH
66953: LD_INT 1
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 2
66962: PUSH
66963: LD_INT 2
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: LD_INT 1
66972: PUSH
66973: LD_INT 2
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 0
66982: PUSH
66983: LD_INT 2
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 1
66992: NEG
66993: PUSH
66994: LD_INT 1
66996: PUSH
66997: EMPTY
66998: LIST
66999: LIST
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
67015: LD_ADDR_VAR 0 51
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: LD_INT 0
67025: PUSH
67026: EMPTY
67027: LIST
67028: LIST
67029: PUSH
67030: LD_INT 0
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 1
67043: PUSH
67044: LD_INT 0
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: LD_INT 1
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 0
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 1
67073: NEG
67074: PUSH
67075: LD_INT 0
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 1
67084: NEG
67085: PUSH
67086: LD_INT 1
67088: NEG
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: LD_INT 1
67096: PUSH
67097: LD_INT 2
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: LD_INT 2
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 1
67116: NEG
67117: PUSH
67118: LD_INT 1
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 2
67127: NEG
67128: PUSH
67129: LD_INT 0
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 2
67138: NEG
67139: PUSH
67140: LD_INT 1
67142: NEG
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67162: LD_ADDR_VAR 0 52
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 0
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 1
67182: NEG
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 1
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 0
67210: PUSH
67211: LD_INT 1
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: NEG
67221: PUSH
67222: LD_INT 0
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: LD_INT 1
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: NEG
67244: PUSH
67245: LD_INT 2
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 1
67255: NEG
67256: PUSH
67257: LD_INT 1
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 2
67266: NEG
67267: PUSH
67268: LD_INT 0
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 2
67277: NEG
67278: PUSH
67279: LD_INT 1
67281: NEG
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 2
67289: NEG
67290: PUSH
67291: LD_INT 2
67293: NEG
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67313: LD_ADDR_VAR 0 53
67317: PUSH
67318: LD_INT 0
67320: PUSH
67321: LD_INT 0
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 0
67330: PUSH
67331: LD_INT 1
67333: NEG
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: LD_INT 0
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 0
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: LD_INT 0
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 1
67382: NEG
67383: PUSH
67384: LD_INT 1
67386: NEG
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: LD_INT 2
67398: NEG
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 0
67406: PUSH
67407: LD_INT 2
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 1
67417: PUSH
67418: LD_INT 1
67420: NEG
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: PUSH
67426: LD_INT 2
67428: PUSH
67429: LD_INT 0
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 2
67448: PUSH
67449: LD_INT 2
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 1
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 0
67468: PUSH
67469: LD_INT 2
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: LD_INT 1
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: LD_INT 2
67489: NEG
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 2
67500: NEG
67501: PUSH
67502: LD_INT 1
67504: NEG
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 2
67512: NEG
67513: PUSH
67514: LD_INT 2
67516: NEG
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: LIST
67539: LIST
67540: LIST
67541: LIST
67542: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67543: LD_ADDR_VAR 0 54
67547: PUSH
67548: LD_INT 0
67550: PUSH
67551: LD_INT 0
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: LD_INT 1
67563: NEG
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 1
67571: PUSH
67572: LD_INT 0
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 1
67581: PUSH
67582: LD_INT 1
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: LD_INT 1
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 1
67601: NEG
67602: PUSH
67603: LD_INT 0
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: NEG
67613: PUSH
67614: LD_INT 1
67616: NEG
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 1
67624: NEG
67625: PUSH
67626: LD_INT 2
67628: NEG
67629: PUSH
67630: EMPTY
67631: LIST
67632: LIST
67633: PUSH
67634: LD_INT 0
67636: PUSH
67637: LD_INT 2
67639: NEG
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: LD_INT 1
67650: NEG
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PUSH
67656: LD_INT 2
67658: PUSH
67659: LD_INT 0
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 2
67668: PUSH
67669: LD_INT 1
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 2
67678: PUSH
67679: LD_INT 2
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 1
67688: PUSH
67689: LD_INT 2
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 0
67698: PUSH
67699: LD_INT 2
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: LD_INT 1
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 2
67719: NEG
67720: PUSH
67721: LD_INT 0
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 2
67730: NEG
67731: PUSH
67732: LD_INT 1
67734: NEG
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: LD_INT 2
67742: NEG
67743: PUSH
67744: LD_INT 2
67746: NEG
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67773: LD_ADDR_VAR 0 55
67777: PUSH
67778: LD_INT 0
67780: PUSH
67781: LD_INT 0
67783: PUSH
67784: EMPTY
67785: LIST
67786: LIST
67787: PUSH
67788: LD_INT 0
67790: PUSH
67791: LD_INT 1
67793: NEG
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 1
67801: PUSH
67802: LD_INT 0
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 1
67811: PUSH
67812: LD_INT 1
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 0
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: LD_INT 1
67831: NEG
67832: PUSH
67833: LD_INT 0
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 1
67842: NEG
67843: PUSH
67844: LD_INT 1
67846: NEG
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 1
67854: NEG
67855: PUSH
67856: LD_INT 2
67858: NEG
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 0
67866: PUSH
67867: LD_INT 2
67869: NEG
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 1
67877: PUSH
67878: LD_INT 1
67880: NEG
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 2
67888: PUSH
67889: LD_INT 0
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 2
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 2
67908: PUSH
67909: LD_INT 2
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 1
67918: PUSH
67919: LD_INT 2
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: LD_INT 2
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: LD_INT 1
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 2
67949: NEG
67950: PUSH
67951: LD_INT 0
67953: PUSH
67954: EMPTY
67955: LIST
67956: LIST
67957: PUSH
67958: LD_INT 2
67960: NEG
67961: PUSH
67962: LD_INT 1
67964: NEG
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 2
67972: NEG
67973: PUSH
67974: LD_INT 2
67976: NEG
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68003: LD_ADDR_VAR 0 56
68007: PUSH
68008: LD_INT 0
68010: PUSH
68011: LD_INT 0
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 0
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 1
68031: PUSH
68032: LD_INT 0
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 1
68041: PUSH
68042: LD_INT 1
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 0
68051: PUSH
68052: LD_INT 1
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 1
68061: NEG
68062: PUSH
68063: LD_INT 0
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 1
68072: NEG
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 1
68084: NEG
68085: PUSH
68086: LD_INT 2
68088: NEG
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 0
68096: PUSH
68097: LD_INT 2
68099: NEG
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 1
68107: PUSH
68108: LD_INT 1
68110: NEG
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 2
68118: PUSH
68119: LD_INT 0
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 2
68128: PUSH
68129: LD_INT 1
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 2
68138: PUSH
68139: LD_INT 2
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 1
68148: PUSH
68149: LD_INT 2
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: LD_INT 2
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: LD_INT 1
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 2
68179: NEG
68180: PUSH
68181: LD_INT 0
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 2
68190: NEG
68191: PUSH
68192: LD_INT 1
68194: NEG
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 2
68202: NEG
68203: PUSH
68204: LD_INT 2
68206: NEG
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: LIST
68232: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68233: LD_ADDR_VAR 0 57
68237: PUSH
68238: LD_INT 0
68240: PUSH
68241: LD_INT 0
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 0
68250: PUSH
68251: LD_INT 1
68253: NEG
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: PUSH
68262: LD_INT 0
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: LD_INT 1
68271: PUSH
68272: LD_INT 1
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 0
68281: PUSH
68282: LD_INT 1
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 1
68291: NEG
68292: PUSH
68293: LD_INT 0
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 1
68302: NEG
68303: PUSH
68304: LD_INT 1
68306: NEG
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 1
68314: NEG
68315: PUSH
68316: LD_INT 2
68318: NEG
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 0
68326: PUSH
68327: LD_INT 2
68329: NEG
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 1
68337: PUSH
68338: LD_INT 1
68340: NEG
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 2
68348: PUSH
68349: LD_INT 0
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 2
68358: PUSH
68359: LD_INT 1
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 2
68368: PUSH
68369: LD_INT 2
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 1
68378: PUSH
68379: LD_INT 2
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 0
68388: PUSH
68389: LD_INT 2
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: LD_INT 1
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 2
68409: NEG
68410: PUSH
68411: LD_INT 0
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 2
68420: NEG
68421: PUSH
68422: LD_INT 1
68424: NEG
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 2
68432: NEG
68433: PUSH
68434: LD_INT 2
68436: NEG
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68463: LD_ADDR_VAR 0 58
68467: PUSH
68468: LD_INT 0
68470: PUSH
68471: LD_INT 0
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: LD_INT 1
68483: NEG
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: PUSH
68492: LD_INT 0
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 1
68501: PUSH
68502: LD_INT 1
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 0
68511: PUSH
68512: LD_INT 1
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 1
68521: NEG
68522: PUSH
68523: LD_INT 0
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 1
68532: NEG
68533: PUSH
68534: LD_INT 1
68536: NEG
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 1
68544: NEG
68545: PUSH
68546: LD_INT 2
68548: NEG
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: LD_INT 0
68556: PUSH
68557: LD_INT 2
68559: NEG
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: LD_INT 1
68570: NEG
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 2
68578: PUSH
68579: LD_INT 0
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 2
68588: PUSH
68589: LD_INT 1
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 2
68598: PUSH
68599: LD_INT 2
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 1
68608: PUSH
68609: LD_INT 2
68611: PUSH
68612: EMPTY
68613: LIST
68614: LIST
68615: PUSH
68616: LD_INT 0
68618: PUSH
68619: LD_INT 2
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: PUSH
68626: LD_INT 1
68628: NEG
68629: PUSH
68630: LD_INT 1
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 2
68639: NEG
68640: PUSH
68641: LD_INT 0
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 2
68650: NEG
68651: PUSH
68652: LD_INT 1
68654: NEG
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: LD_INT 2
68662: NEG
68663: PUSH
68664: LD_INT 2
68666: NEG
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
68693: LD_ADDR_VAR 0 59
68697: PUSH
68698: LD_INT 0
68700: PUSH
68701: LD_INT 0
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 0
68710: PUSH
68711: LD_INT 1
68713: NEG
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: LD_INT 1
68721: PUSH
68722: LD_INT 0
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 1
68731: PUSH
68732: LD_INT 1
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 0
68741: PUSH
68742: LD_INT 1
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: LD_INT 0
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: NEG
68763: PUSH
68764: LD_INT 1
68766: NEG
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
68781: LD_ADDR_VAR 0 60
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: LD_INT 0
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 0
68798: PUSH
68799: LD_INT 1
68801: NEG
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 1
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 1
68819: PUSH
68820: LD_INT 1
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 0
68829: PUSH
68830: LD_INT 1
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: NEG
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 1
68850: NEG
68851: PUSH
68852: LD_INT 1
68854: NEG
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
68869: LD_ADDR_VAR 0 61
68873: PUSH
68874: LD_INT 0
68876: PUSH
68877: LD_INT 0
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: LD_INT 1
68889: NEG
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 1
68897: PUSH
68898: LD_INT 0
68900: PUSH
68901: EMPTY
68902: LIST
68903: LIST
68904: PUSH
68905: LD_INT 1
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 0
68917: PUSH
68918: LD_INT 1
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: PUSH
68925: LD_INT 1
68927: NEG
68928: PUSH
68929: LD_INT 0
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: LD_INT 1
68942: NEG
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
68957: LD_ADDR_VAR 0 62
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: LD_INT 0
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 1
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 1
68995: PUSH
68996: LD_INT 1
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 0
69005: PUSH
69006: LD_INT 1
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 1
69015: NEG
69016: PUSH
69017: LD_INT 0
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 1
69026: NEG
69027: PUSH
69028: LD_INT 1
69030: NEG
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
69045: LD_ADDR_VAR 0 63
69049: PUSH
69050: LD_INT 0
69052: PUSH
69053: LD_INT 0
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 0
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 1
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 1
69083: PUSH
69084: LD_INT 1
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: LD_INT 1
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: LD_INT 0
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: NEG
69115: PUSH
69116: LD_INT 1
69118: NEG
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
69133: LD_ADDR_VAR 0 64
69137: PUSH
69138: LD_INT 0
69140: PUSH
69141: LD_INT 0
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: LD_INT 1
69153: NEG
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 1
69161: PUSH
69162: LD_INT 0
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: PUSH
69172: LD_INT 1
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 0
69181: PUSH
69182: LD_INT 1
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 1
69191: NEG
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: PUSH
69200: LD_INT 1
69202: NEG
69203: PUSH
69204: LD_INT 1
69206: NEG
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: ST_TO_ADDR
// end ; 1 :
69221: GO 75118
69223: LD_INT 1
69225: DOUBLE
69226: EQUAL
69227: IFTRUE 69231
69229: GO 71854
69231: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69232: LD_ADDR_VAR 0 11
69236: PUSH
69237: LD_INT 1
69239: NEG
69240: PUSH
69241: LD_INT 3
69243: NEG
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 0
69251: PUSH
69252: LD_INT 3
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 2
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: LIST
69275: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69276: LD_ADDR_VAR 0 12
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: LD_INT 1
69286: NEG
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 3
69294: PUSH
69295: LD_INT 0
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 3
69304: PUSH
69305: LD_INT 1
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: LIST
69316: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69317: LD_ADDR_VAR 0 13
69321: PUSH
69322: LD_INT 3
69324: PUSH
69325: LD_INT 2
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 3
69334: PUSH
69335: LD_INT 3
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 2
69344: PUSH
69345: LD_INT 3
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: LIST
69356: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69357: LD_ADDR_VAR 0 14
69361: PUSH
69362: LD_INT 1
69364: PUSH
69365: LD_INT 3
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 0
69374: PUSH
69375: LD_INT 3
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 1
69384: NEG
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: LIST
69397: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69398: LD_ADDR_VAR 0 15
69402: PUSH
69403: LD_INT 2
69405: NEG
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 3
69416: NEG
69417: PUSH
69418: LD_INT 0
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 3
69427: NEG
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: LIST
69441: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69442: LD_ADDR_VAR 0 16
69446: PUSH
69447: LD_INT 2
69449: NEG
69450: PUSH
69451: LD_INT 3
69453: NEG
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 3
69461: NEG
69462: PUSH
69463: LD_INT 2
69465: NEG
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 3
69473: NEG
69474: PUSH
69475: LD_INT 3
69477: NEG
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: LIST
69487: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69488: LD_ADDR_VAR 0 17
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 3
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: LD_INT 3
69510: NEG
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 1
69518: PUSH
69519: LD_INT 2
69521: NEG
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: LIST
69531: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69532: LD_ADDR_VAR 0 18
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: LD_INT 1
69542: NEG
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 3
69550: PUSH
69551: LD_INT 0
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 3
69560: PUSH
69561: LD_INT 1
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: LIST
69572: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69573: LD_ADDR_VAR 0 19
69577: PUSH
69578: LD_INT 3
69580: PUSH
69581: LD_INT 2
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: LD_INT 3
69590: PUSH
69591: LD_INT 3
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: LD_INT 2
69600: PUSH
69601: LD_INT 3
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: LIST
69612: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69613: LD_ADDR_VAR 0 20
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: LD_INT 3
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 0
69630: PUSH
69631: LD_INT 3
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 1
69640: NEG
69641: PUSH
69642: LD_INT 2
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: LIST
69653: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69654: LD_ADDR_VAR 0 21
69658: PUSH
69659: LD_INT 2
69661: NEG
69662: PUSH
69663: LD_INT 1
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 3
69672: NEG
69673: PUSH
69674: LD_INT 0
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 3
69683: NEG
69684: PUSH
69685: LD_INT 1
69687: NEG
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: LIST
69697: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69698: LD_ADDR_VAR 0 22
69702: PUSH
69703: LD_INT 2
69705: NEG
69706: PUSH
69707: LD_INT 3
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 3
69717: NEG
69718: PUSH
69719: LD_INT 2
69721: NEG
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: LD_INT 3
69729: NEG
69730: PUSH
69731: LD_INT 3
69733: NEG
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: LIST
69743: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
69744: LD_ADDR_VAR 0 23
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: LD_INT 3
69754: NEG
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 1
69762: NEG
69763: PUSH
69764: LD_INT 4
69766: NEG
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 1
69774: PUSH
69775: LD_INT 3
69777: NEG
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: LIST
69787: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
69788: LD_ADDR_VAR 0 24
69792: PUSH
69793: LD_INT 3
69795: PUSH
69796: LD_INT 0
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 3
69805: PUSH
69806: LD_INT 1
69808: NEG
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 4
69816: PUSH
69817: LD_INT 1
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: LIST
69828: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
69829: LD_ADDR_VAR 0 25
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: LD_INT 3
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 4
69846: PUSH
69847: LD_INT 3
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: LD_INT 3
69856: PUSH
69857: LD_INT 4
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: LIST
69868: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
69869: LD_ADDR_VAR 0 26
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: LD_INT 3
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 1
69886: PUSH
69887: LD_INT 4
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 1
69896: NEG
69897: PUSH
69898: LD_INT 3
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: LIST
69909: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
69910: LD_ADDR_VAR 0 27
69914: PUSH
69915: LD_INT 3
69917: NEG
69918: PUSH
69919: LD_INT 0
69921: PUSH
69922: EMPTY
69923: LIST
69924: LIST
69925: PUSH
69926: LD_INT 3
69928: NEG
69929: PUSH
69930: LD_INT 1
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 4
69939: NEG
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: LIST
69953: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
69954: LD_ADDR_VAR 0 28
69958: PUSH
69959: LD_INT 3
69961: NEG
69962: PUSH
69963: LD_INT 3
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 3
69973: NEG
69974: PUSH
69975: LD_INT 4
69977: NEG
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: LD_INT 4
69985: NEG
69986: PUSH
69987: LD_INT 3
69989: NEG
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: LIST
69999: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
70000: LD_ADDR_VAR 0 29
70004: PUSH
70005: LD_INT 1
70007: NEG
70008: PUSH
70009: LD_INT 3
70011: NEG
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: LD_INT 3
70022: NEG
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: PUSH
70031: LD_INT 2
70033: NEG
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: LD_INT 1
70041: NEG
70042: PUSH
70043: LD_INT 4
70045: NEG
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: LD_INT 4
70056: NEG
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 1
70064: PUSH
70065: LD_INT 3
70067: NEG
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: PUSH
70073: LD_INT 1
70075: NEG
70076: PUSH
70077: LD_INT 5
70079: NEG
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 0
70087: PUSH
70088: LD_INT 5
70090: NEG
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 1
70098: PUSH
70099: LD_INT 4
70101: NEG
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 1
70109: NEG
70110: PUSH
70111: LD_INT 6
70113: NEG
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 0
70121: PUSH
70122: LD_INT 6
70124: NEG
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 1
70132: PUSH
70133: LD_INT 5
70135: NEG
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
70155: LD_ADDR_VAR 0 30
70159: PUSH
70160: LD_INT 2
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 3
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 3
70183: PUSH
70184: LD_INT 1
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 3
70193: PUSH
70194: LD_INT 1
70196: NEG
70197: PUSH
70198: EMPTY
70199: LIST
70200: LIST
70201: PUSH
70202: LD_INT 4
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 4
70214: PUSH
70215: LD_INT 1
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 4
70224: PUSH
70225: LD_INT 1
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 5
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 5
70245: PUSH
70246: LD_INT 1
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 5
70255: PUSH
70256: LD_INT 1
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 6
70266: PUSH
70267: LD_INT 0
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 6
70276: PUSH
70277: LD_INT 1
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
70298: LD_ADDR_VAR 0 31
70302: PUSH
70303: LD_INT 3
70305: PUSH
70306: LD_INT 2
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 3
70315: PUSH
70316: LD_INT 3
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 2
70325: PUSH
70326: LD_INT 3
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 4
70335: PUSH
70336: LD_INT 3
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 4
70345: PUSH
70346: LD_INT 4
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 3
70355: PUSH
70356: LD_INT 4
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 5
70365: PUSH
70366: LD_INT 4
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 5
70375: PUSH
70376: LD_INT 5
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 4
70385: PUSH
70386: LD_INT 5
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 6
70395: PUSH
70396: LD_INT 5
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 6
70405: PUSH
70406: LD_INT 6
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 5
70415: PUSH
70416: LD_INT 6
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
70437: LD_ADDR_VAR 0 32
70441: PUSH
70442: LD_INT 1
70444: PUSH
70445: LD_INT 3
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: LD_INT 3
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: LD_INT 2
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 1
70475: PUSH
70476: LD_INT 4
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 0
70485: PUSH
70486: LD_INT 4
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: LD_INT 3
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 1
70506: PUSH
70507: LD_INT 5
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: LD_INT 5
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 1
70526: NEG
70527: PUSH
70528: LD_INT 4
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 6
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: LD_INT 6
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: LD_INT 5
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
70580: LD_ADDR_VAR 0 33
70584: PUSH
70585: LD_INT 2
70587: NEG
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 3
70598: NEG
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 3
70609: NEG
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 3
70621: NEG
70622: PUSH
70623: LD_INT 1
70625: PUSH
70626: EMPTY
70627: LIST
70628: LIST
70629: PUSH
70630: LD_INT 4
70632: NEG
70633: PUSH
70634: LD_INT 0
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 4
70643: NEG
70644: PUSH
70645: LD_INT 1
70647: NEG
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 4
70655: NEG
70656: PUSH
70657: LD_INT 1
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 5
70666: NEG
70667: PUSH
70668: LD_INT 0
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 5
70677: NEG
70678: PUSH
70679: LD_INT 1
70681: NEG
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 5
70689: NEG
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 6
70700: NEG
70701: PUSH
70702: LD_INT 0
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 6
70711: NEG
70712: PUSH
70713: LD_INT 1
70715: NEG
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
70735: LD_ADDR_VAR 0 34
70739: PUSH
70740: LD_INT 2
70742: NEG
70743: PUSH
70744: LD_INT 3
70746: NEG
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: LD_INT 3
70754: NEG
70755: PUSH
70756: LD_INT 2
70758: NEG
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 3
70766: NEG
70767: PUSH
70768: LD_INT 3
70770: NEG
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 3
70778: NEG
70779: PUSH
70780: LD_INT 4
70782: NEG
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 4
70790: NEG
70791: PUSH
70792: LD_INT 3
70794: NEG
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 4
70802: NEG
70803: PUSH
70804: LD_INT 4
70806: NEG
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: PUSH
70812: LD_INT 4
70814: NEG
70815: PUSH
70816: LD_INT 5
70818: NEG
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: PUSH
70824: LD_INT 5
70826: NEG
70827: PUSH
70828: LD_INT 4
70830: NEG
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 5
70838: NEG
70839: PUSH
70840: LD_INT 5
70842: NEG
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 5
70850: NEG
70851: PUSH
70852: LD_INT 6
70854: NEG
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 6
70862: NEG
70863: PUSH
70864: LD_INT 5
70866: NEG
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 6
70874: NEG
70875: PUSH
70876: LD_INT 6
70878: NEG
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
70898: LD_ADDR_VAR 0 41
70902: PUSH
70903: LD_INT 0
70905: PUSH
70906: LD_INT 2
70908: NEG
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 1
70916: NEG
70917: PUSH
70918: LD_INT 3
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 1
70928: PUSH
70929: LD_INT 2
70931: NEG
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: LIST
70941: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
70942: LD_ADDR_VAR 0 42
70946: PUSH
70947: LD_INT 2
70949: PUSH
70950: LD_INT 0
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: LD_INT 2
70959: PUSH
70960: LD_INT 1
70962: NEG
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 3
70970: PUSH
70971: LD_INT 1
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: LIST
70982: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
70983: LD_ADDR_VAR 0 43
70987: PUSH
70988: LD_INT 2
70990: PUSH
70991: LD_INT 2
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 3
71000: PUSH
71001: LD_INT 2
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 2
71010: PUSH
71011: LD_INT 3
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: LIST
71022: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
71023: LD_ADDR_VAR 0 44
71027: PUSH
71028: LD_INT 0
71030: PUSH
71031: LD_INT 2
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 1
71040: PUSH
71041: LD_INT 3
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 1
71050: NEG
71051: PUSH
71052: LD_INT 2
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: LIST
71063: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71064: LD_ADDR_VAR 0 45
71068: PUSH
71069: LD_INT 2
71071: NEG
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 2
71082: NEG
71083: PUSH
71084: LD_INT 1
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 3
71093: NEG
71094: PUSH
71095: LD_INT 1
71097: NEG
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: LIST
71107: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
71108: LD_ADDR_VAR 0 46
71112: PUSH
71113: LD_INT 2
71115: NEG
71116: PUSH
71117: LD_INT 2
71119: NEG
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 2
71127: NEG
71128: PUSH
71129: LD_INT 3
71131: NEG
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 3
71139: NEG
71140: PUSH
71141: LD_INT 2
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: LIST
71153: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
71154: LD_ADDR_VAR 0 47
71158: PUSH
71159: LD_INT 2
71161: NEG
71162: PUSH
71163: LD_INT 3
71165: NEG
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: LD_INT 3
71177: NEG
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
71187: LD_ADDR_VAR 0 48
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: LD_INT 2
71197: NEG
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: LD_INT 1
71208: NEG
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
71218: LD_ADDR_VAR 0 49
71222: PUSH
71223: LD_INT 3
71225: PUSH
71226: LD_INT 1
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: LD_INT 3
71235: PUSH
71236: LD_INT 2
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
71247: LD_ADDR_VAR 0 50
71251: PUSH
71252: LD_INT 2
71254: PUSH
71255: LD_INT 3
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 1
71264: PUSH
71265: LD_INT 3
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71276: LD_ADDR_VAR 0 51
71280: PUSH
71281: LD_INT 1
71283: NEG
71284: PUSH
71285: LD_INT 2
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 2
71294: NEG
71295: PUSH
71296: LD_INT 1
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71307: LD_ADDR_VAR 0 52
71311: PUSH
71312: LD_INT 3
71314: NEG
71315: PUSH
71316: LD_INT 1
71318: NEG
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 3
71326: NEG
71327: PUSH
71328: LD_INT 2
71330: NEG
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
71340: LD_ADDR_VAR 0 53
71344: PUSH
71345: LD_INT 1
71347: NEG
71348: PUSH
71349: LD_INT 3
71351: NEG
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 0
71359: PUSH
71360: LD_INT 3
71362: NEG
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 1
71370: PUSH
71371: LD_INT 2
71373: NEG
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: LIST
71383: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
71384: LD_ADDR_VAR 0 54
71388: PUSH
71389: LD_INT 2
71391: PUSH
71392: LD_INT 1
71394: NEG
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 3
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 3
71412: PUSH
71413: LD_INT 1
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: LIST
71424: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
71425: LD_ADDR_VAR 0 55
71429: PUSH
71430: LD_INT 3
71432: PUSH
71433: LD_INT 2
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 3
71442: PUSH
71443: LD_INT 3
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 2
71452: PUSH
71453: LD_INT 3
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: LIST
71464: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71465: LD_ADDR_VAR 0 56
71469: PUSH
71470: LD_INT 1
71472: PUSH
71473: LD_INT 3
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PUSH
71480: LD_INT 0
71482: PUSH
71483: LD_INT 3
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 1
71492: NEG
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: LIST
71505: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71506: LD_ADDR_VAR 0 57
71510: PUSH
71511: LD_INT 2
71513: NEG
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 3
71524: NEG
71525: PUSH
71526: LD_INT 0
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 3
71535: NEG
71536: PUSH
71537: LD_INT 1
71539: NEG
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: LIST
71549: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71550: LD_ADDR_VAR 0 58
71554: PUSH
71555: LD_INT 2
71557: NEG
71558: PUSH
71559: LD_INT 3
71561: NEG
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 3
71569: NEG
71570: PUSH
71571: LD_INT 2
71573: NEG
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 3
71581: NEG
71582: PUSH
71583: LD_INT 3
71585: NEG
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: LIST
71595: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
71596: LD_ADDR_VAR 0 59
71600: PUSH
71601: LD_INT 1
71603: NEG
71604: PUSH
71605: LD_INT 2
71607: NEG
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: LD_INT 0
71615: PUSH
71616: LD_INT 2
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 1
71626: PUSH
71627: LD_INT 1
71629: NEG
71630: PUSH
71631: EMPTY
71632: LIST
71633: LIST
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: LIST
71639: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71640: LD_ADDR_VAR 0 60
71644: PUSH
71645: LD_INT 1
71647: PUSH
71648: LD_INT 1
71650: NEG
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 2
71658: PUSH
71659: LD_INT 0
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 2
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: LIST
71680: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71681: LD_ADDR_VAR 0 61
71685: PUSH
71686: LD_INT 2
71688: PUSH
71689: LD_INT 1
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 2
71698: PUSH
71699: LD_INT 2
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: LD_INT 2
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: LIST
71720: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71721: LD_ADDR_VAR 0 62
71725: PUSH
71726: LD_INT 1
71728: PUSH
71729: LD_INT 2
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 0
71738: PUSH
71739: LD_INT 2
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 1
71748: NEG
71749: PUSH
71750: LD_INT 1
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: LIST
71761: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71762: LD_ADDR_VAR 0 63
71766: PUSH
71767: LD_INT 1
71769: NEG
71770: PUSH
71771: LD_INT 1
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 2
71780: NEG
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 2
71791: NEG
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: LIST
71805: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71806: LD_ADDR_VAR 0 64
71810: PUSH
71811: LD_INT 1
71813: NEG
71814: PUSH
71815: LD_INT 2
71817: NEG
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 2
71825: NEG
71826: PUSH
71827: LD_INT 1
71829: NEG
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 2
71837: NEG
71838: PUSH
71839: LD_INT 2
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: LIST
71851: ST_TO_ADDR
// end ; 2 :
71852: GO 75118
71854: LD_INT 2
71856: DOUBLE
71857: EQUAL
71858: IFTRUE 71862
71860: GO 75117
71862: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
71863: LD_ADDR_VAR 0 29
71867: PUSH
71868: LD_INT 4
71870: PUSH
71871: LD_INT 0
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 4
71880: PUSH
71881: LD_INT 1
71883: NEG
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 5
71891: PUSH
71892: LD_INT 0
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 5
71901: PUSH
71902: LD_INT 1
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 4
71911: PUSH
71912: LD_INT 1
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 3
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 3
71931: PUSH
71932: LD_INT 1
71934: NEG
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PUSH
71940: LD_INT 3
71942: PUSH
71943: LD_INT 2
71945: NEG
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 5
71953: PUSH
71954: LD_INT 2
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 3
71963: PUSH
71964: LD_INT 3
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 3
71973: PUSH
71974: LD_INT 2
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 4
71983: PUSH
71984: LD_INT 3
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 4
71993: PUSH
71994: LD_INT 4
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 3
72003: PUSH
72004: LD_INT 4
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 2
72013: PUSH
72014: LD_INT 3
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 2
72023: PUSH
72024: LD_INT 2
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 4
72033: PUSH
72034: LD_INT 2
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: LD_INT 4
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 0
72053: PUSH
72054: LD_INT 4
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 0
72063: PUSH
72064: LD_INT 3
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: LD_INT 4
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: LD_INT 5
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 0
72093: PUSH
72094: LD_INT 5
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 1
72103: NEG
72104: PUSH
72105: LD_INT 4
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: PUSH
72112: LD_INT 1
72114: NEG
72115: PUSH
72116: LD_INT 3
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PUSH
72123: LD_INT 2
72125: PUSH
72126: LD_INT 5
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: PUSH
72133: LD_INT 2
72135: NEG
72136: PUSH
72137: LD_INT 3
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PUSH
72144: LD_INT 3
72146: NEG
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 3
72157: NEG
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 2
72169: NEG
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 2
72180: NEG
72181: PUSH
72182: LD_INT 1
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 3
72191: NEG
72192: PUSH
72193: LD_INT 1
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 4
72202: NEG
72203: PUSH
72204: LD_INT 0
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PUSH
72211: LD_INT 4
72213: NEG
72214: PUSH
72215: LD_INT 1
72217: NEG
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 4
72225: NEG
72226: PUSH
72227: LD_INT 2
72229: NEG
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 2
72237: NEG
72238: PUSH
72239: LD_INT 2
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 4
72248: NEG
72249: PUSH
72250: LD_INT 4
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 4
72260: NEG
72261: PUSH
72262: LD_INT 5
72264: NEG
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 3
72272: NEG
72273: PUSH
72274: LD_INT 4
72276: NEG
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 3
72284: NEG
72285: PUSH
72286: LD_INT 3
72288: NEG
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 4
72296: NEG
72297: PUSH
72298: LD_INT 3
72300: NEG
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 5
72308: NEG
72309: PUSH
72310: LD_INT 4
72312: NEG
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 5
72320: NEG
72321: PUSH
72322: LD_INT 5
72324: NEG
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 3
72332: NEG
72333: PUSH
72334: LD_INT 5
72336: NEG
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 5
72344: NEG
72345: PUSH
72346: LD_INT 3
72348: NEG
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
72401: LD_ADDR_VAR 0 30
72405: PUSH
72406: LD_INT 4
72408: PUSH
72409: LD_INT 4
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 4
72418: PUSH
72419: LD_INT 3
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 5
72428: PUSH
72429: LD_INT 4
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 5
72438: PUSH
72439: LD_INT 5
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 4
72448: PUSH
72449: LD_INT 5
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 3
72458: PUSH
72459: LD_INT 4
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 3
72468: PUSH
72469: LD_INT 3
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 5
72478: PUSH
72479: LD_INT 3
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 3
72488: PUSH
72489: LD_INT 5
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: LD_INT 3
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: PUSH
72506: LD_INT 0
72508: PUSH
72509: LD_INT 2
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: PUSH
72516: LD_INT 1
72518: PUSH
72519: LD_INT 3
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 1
72528: PUSH
72529: LD_INT 4
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: LD_INT 4
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: LD_INT 3
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: NEG
72560: PUSH
72561: LD_INT 2
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 2
72570: PUSH
72571: LD_INT 4
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: LD_INT 2
72580: NEG
72581: PUSH
72582: LD_INT 2
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 4
72591: NEG
72592: PUSH
72593: LD_INT 0
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 4
72602: NEG
72603: PUSH
72604: LD_INT 1
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 3
72614: NEG
72615: PUSH
72616: LD_INT 0
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 3
72625: NEG
72626: PUSH
72627: LD_INT 1
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 4
72636: NEG
72637: PUSH
72638: LD_INT 1
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 5
72647: NEG
72648: PUSH
72649: LD_INT 0
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 5
72658: NEG
72659: PUSH
72660: LD_INT 1
72662: NEG
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 5
72670: NEG
72671: PUSH
72672: LD_INT 2
72674: NEG
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 3
72682: NEG
72683: PUSH
72684: LD_INT 2
72686: PUSH
72687: EMPTY
72688: LIST
72689: LIST
72690: PUSH
72691: LD_INT 3
72693: NEG
72694: PUSH
72695: LD_INT 3
72697: NEG
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 3
72705: NEG
72706: PUSH
72707: LD_INT 4
72709: NEG
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 2
72717: NEG
72718: PUSH
72719: LD_INT 3
72721: NEG
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 2
72729: NEG
72730: PUSH
72731: LD_INT 2
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 3
72741: NEG
72742: PUSH
72743: LD_INT 2
72745: NEG
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 4
72753: NEG
72754: PUSH
72755: LD_INT 3
72757: NEG
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 4
72765: NEG
72766: PUSH
72767: LD_INT 4
72769: NEG
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 2
72777: NEG
72778: PUSH
72779: LD_INT 4
72781: NEG
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 4
72789: NEG
72790: PUSH
72791: LD_INT 2
72793: NEG
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: LD_INT 0
72801: PUSH
72802: LD_INT 4
72804: NEG
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 0
72812: PUSH
72813: LD_INT 5
72815: NEG
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: LD_INT 4
72826: NEG
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: LD_INT 3
72837: NEG
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 0
72845: PUSH
72846: LD_INT 3
72848: NEG
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: LD_INT 4
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: LD_INT 5
72872: NEG
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 2
72880: PUSH
72881: LD_INT 3
72883: NEG
72884: PUSH
72885: EMPTY
72886: LIST
72887: LIST
72888: PUSH
72889: LD_INT 2
72891: NEG
72892: PUSH
72893: LD_INT 5
72895: NEG
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
72948: LD_ADDR_VAR 0 31
72952: PUSH
72953: LD_INT 0
72955: PUSH
72956: LD_INT 4
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 0
72965: PUSH
72966: LD_INT 3
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 1
72975: PUSH
72976: LD_INT 4
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 1
72985: PUSH
72986: LD_INT 5
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 0
72995: PUSH
72996: LD_INT 5
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: NEG
73006: PUSH
73007: LD_INT 4
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 1
73016: NEG
73017: PUSH
73018: LD_INT 3
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: LD_INT 5
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 2
73037: NEG
73038: PUSH
73039: LD_INT 3
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 3
73048: NEG
73049: PUSH
73050: LD_INT 0
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 3
73059: NEG
73060: PUSH
73061: LD_INT 1
73063: NEG
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 2
73071: NEG
73072: PUSH
73073: LD_INT 0
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 2
73082: NEG
73083: PUSH
73084: LD_INT 1
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: LD_INT 3
73093: NEG
73094: PUSH
73095: LD_INT 1
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 4
73104: NEG
73105: PUSH
73106: LD_INT 0
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 4
73115: NEG
73116: PUSH
73117: LD_INT 1
73119: NEG
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 4
73127: NEG
73128: PUSH
73129: LD_INT 2
73131: NEG
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 2
73139: NEG
73140: PUSH
73141: LD_INT 2
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 4
73150: NEG
73151: PUSH
73152: LD_INT 4
73154: NEG
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 4
73162: NEG
73163: PUSH
73164: LD_INT 5
73166: NEG
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 3
73174: NEG
73175: PUSH
73176: LD_INT 4
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 3
73186: NEG
73187: PUSH
73188: LD_INT 3
73190: NEG
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 4
73198: NEG
73199: PUSH
73200: LD_INT 3
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 5
73210: NEG
73211: PUSH
73212: LD_INT 4
73214: NEG
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 5
73222: NEG
73223: PUSH
73224: LD_INT 5
73226: NEG
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 3
73234: NEG
73235: PUSH
73236: LD_INT 5
73238: NEG
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 5
73246: NEG
73247: PUSH
73248: LD_INT 3
73250: NEG
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 0
73258: PUSH
73259: LD_INT 3
73261: NEG
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: LD_INT 4
73272: NEG
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 1
73280: PUSH
73281: LD_INT 3
73283: NEG
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 1
73291: PUSH
73292: LD_INT 2
73294: NEG
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 0
73302: PUSH
73303: LD_INT 2
73305: NEG
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: LD_INT 3
73317: NEG
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 1
73325: NEG
73326: PUSH
73327: LD_INT 4
73329: NEG
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 2
73337: PUSH
73338: LD_INT 2
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 2
73348: NEG
73349: PUSH
73350: LD_INT 4
73352: NEG
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: LD_INT 4
73360: PUSH
73361: LD_INT 0
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PUSH
73368: LD_INT 4
73370: PUSH
73371: LD_INT 1
73373: NEG
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 5
73381: PUSH
73382: LD_INT 0
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 5
73391: PUSH
73392: LD_INT 1
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 4
73401: PUSH
73402: LD_INT 1
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 3
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 3
73421: PUSH
73422: LD_INT 1
73424: NEG
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 3
73432: PUSH
73433: LD_INT 2
73435: NEG
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 5
73443: PUSH
73444: LD_INT 2
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: LIST
73481: LIST
73482: LIST
73483: LIST
73484: LIST
73485: LIST
73486: LIST
73487: LIST
73488: LIST
73489: LIST
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
73498: LD_ADDR_VAR 0 32
73502: PUSH
73503: LD_INT 4
73505: NEG
73506: PUSH
73507: LD_INT 0
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 4
73516: NEG
73517: PUSH
73518: LD_INT 1
73520: NEG
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 3
73528: NEG
73529: PUSH
73530: LD_INT 0
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 3
73539: NEG
73540: PUSH
73541: LD_INT 1
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 4
73550: NEG
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 5
73561: NEG
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 5
73572: NEG
73573: PUSH
73574: LD_INT 1
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 5
73584: NEG
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 3
73596: NEG
73597: PUSH
73598: LD_INT 2
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 3
73607: NEG
73608: PUSH
73609: LD_INT 3
73611: NEG
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 3
73619: NEG
73620: PUSH
73621: LD_INT 4
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 2
73631: NEG
73632: PUSH
73633: LD_INT 3
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 2
73643: NEG
73644: PUSH
73645: LD_INT 2
73647: NEG
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: LD_INT 3
73655: NEG
73656: PUSH
73657: LD_INT 2
73659: NEG
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 4
73667: NEG
73668: PUSH
73669: LD_INT 3
73671: NEG
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 4
73679: NEG
73680: PUSH
73681: LD_INT 4
73683: NEG
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 2
73691: NEG
73692: PUSH
73693: LD_INT 4
73695: NEG
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 4
73703: NEG
73704: PUSH
73705: LD_INT 2
73707: NEG
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 0
73715: PUSH
73716: LD_INT 4
73718: NEG
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 0
73726: PUSH
73727: LD_INT 5
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 1
73737: PUSH
73738: LD_INT 4
73740: NEG
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 1
73748: PUSH
73749: LD_INT 3
73751: NEG
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 0
73759: PUSH
73760: LD_INT 3
73762: NEG
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 1
73770: NEG
73771: PUSH
73772: LD_INT 4
73774: NEG
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 1
73782: NEG
73783: PUSH
73784: LD_INT 5
73786: NEG
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 2
73794: PUSH
73795: LD_INT 3
73797: NEG
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: PUSH
73803: LD_INT 2
73805: NEG
73806: PUSH
73807: LD_INT 5
73809: NEG
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 3
73817: PUSH
73818: LD_INT 0
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 3
73827: PUSH
73828: LD_INT 1
73830: NEG
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 4
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 4
73848: PUSH
73849: LD_INT 1
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 3
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 2
73868: PUSH
73869: LD_INT 0
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: LD_INT 2
73878: PUSH
73879: LD_INT 1
73881: NEG
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 2
73889: PUSH
73890: LD_INT 2
73892: NEG
73893: PUSH
73894: EMPTY
73895: LIST
73896: LIST
73897: PUSH
73898: LD_INT 4
73900: PUSH
73901: LD_INT 2
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: PUSH
73908: LD_INT 4
73910: PUSH
73911: LD_INT 4
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 4
73920: PUSH
73921: LD_INT 3
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PUSH
73928: LD_INT 5
73930: PUSH
73931: LD_INT 4
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 5
73940: PUSH
73941: LD_INT 5
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PUSH
73948: LD_INT 4
73950: PUSH
73951: LD_INT 5
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 3
73960: PUSH
73961: LD_INT 4
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 3
73970: PUSH
73971: LD_INT 3
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 5
73980: PUSH
73981: LD_INT 3
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 3
73990: PUSH
73991: LD_INT 5
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: LIST
74020: LIST
74021: LIST
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: LIST
74028: LIST
74029: LIST
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: LIST
74044: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
74045: LD_ADDR_VAR 0 33
74049: PUSH
74050: LD_INT 4
74052: NEG
74053: PUSH
74054: LD_INT 4
74056: NEG
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 4
74064: NEG
74065: PUSH
74066: LD_INT 5
74068: NEG
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 3
74076: NEG
74077: PUSH
74078: LD_INT 4
74080: NEG
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 3
74088: NEG
74089: PUSH
74090: LD_INT 3
74092: NEG
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 4
74100: NEG
74101: PUSH
74102: LD_INT 3
74104: NEG
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 5
74112: NEG
74113: PUSH
74114: LD_INT 4
74116: NEG
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 5
74124: NEG
74125: PUSH
74126: LD_INT 5
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 3
74136: NEG
74137: PUSH
74138: LD_INT 5
74140: NEG
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 5
74148: NEG
74149: PUSH
74150: LD_INT 3
74152: NEG
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: LD_INT 3
74163: NEG
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PUSH
74169: LD_INT 0
74171: PUSH
74172: LD_INT 4
74174: NEG
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: LD_INT 3
74185: NEG
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: LD_INT 1
74193: PUSH
74194: LD_INT 2
74196: NEG
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 0
74204: PUSH
74205: LD_INT 2
74207: NEG
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 3
74219: NEG
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 1
74227: NEG
74228: PUSH
74229: LD_INT 4
74231: NEG
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 2
74239: PUSH
74240: LD_INT 2
74242: NEG
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: LD_INT 2
74250: NEG
74251: PUSH
74252: LD_INT 4
74254: NEG
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 4
74262: PUSH
74263: LD_INT 0
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 4
74272: PUSH
74273: LD_INT 1
74275: NEG
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 5
74283: PUSH
74284: LD_INT 0
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 5
74293: PUSH
74294: LD_INT 1
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 4
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 3
74313: PUSH
74314: LD_INT 0
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 3
74323: PUSH
74324: LD_INT 1
74326: NEG
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 3
74334: PUSH
74335: LD_INT 2
74337: NEG
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: LD_INT 5
74345: PUSH
74346: LD_INT 2
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: LD_INT 3
74355: PUSH
74356: LD_INT 3
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: LD_INT 3
74365: PUSH
74366: LD_INT 2
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 4
74375: PUSH
74376: LD_INT 3
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 4
74385: PUSH
74386: LD_INT 4
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 3
74395: PUSH
74396: LD_INT 4
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 2
74405: PUSH
74406: LD_INT 3
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 2
74415: PUSH
74416: LD_INT 2
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 4
74425: PUSH
74426: LD_INT 2
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 2
74435: PUSH
74436: LD_INT 4
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: LD_INT 4
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: LD_INT 3
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: PUSH
74463: LD_INT 1
74465: PUSH
74466: LD_INT 4
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 1
74475: PUSH
74476: LD_INT 5
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: LD_INT 0
74485: PUSH
74486: LD_INT 5
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 1
74495: NEG
74496: PUSH
74497: LD_INT 4
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 1
74506: NEG
74507: PUSH
74508: LD_INT 3
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 2
74517: PUSH
74518: LD_INT 5
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 2
74527: NEG
74528: PUSH
74529: LD_INT 3
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: LIST
74540: LIST
74541: LIST
74542: LIST
74543: LIST
74544: LIST
74545: LIST
74546: LIST
74547: LIST
74548: LIST
74549: LIST
74550: LIST
74551: LIST
74552: LIST
74553: LIST
74554: LIST
74555: LIST
74556: LIST
74557: LIST
74558: LIST
74559: LIST
74560: LIST
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: LIST
74582: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
74583: LD_ADDR_VAR 0 34
74587: PUSH
74588: LD_INT 0
74590: PUSH
74591: LD_INT 4
74593: NEG
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 0
74601: PUSH
74602: LD_INT 5
74604: NEG
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: LD_INT 4
74615: NEG
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: LD_INT 3
74626: NEG
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 0
74634: PUSH
74635: LD_INT 3
74637: NEG
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 1
74645: NEG
74646: PUSH
74647: LD_INT 4
74649: NEG
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 1
74657: NEG
74658: PUSH
74659: LD_INT 5
74661: NEG
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: LD_INT 3
74672: NEG
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 2
74680: NEG
74681: PUSH
74682: LD_INT 5
74684: NEG
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 3
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 3
74702: PUSH
74703: LD_INT 1
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 4
74713: PUSH
74714: LD_INT 0
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: LD_INT 4
74723: PUSH
74724: LD_INT 1
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 3
74733: PUSH
74734: LD_INT 1
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 2
74743: PUSH
74744: LD_INT 0
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 2
74753: PUSH
74754: LD_INT 1
74756: NEG
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 2
74764: PUSH
74765: LD_INT 2
74767: NEG
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 4
74775: PUSH
74776: LD_INT 2
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 4
74785: PUSH
74786: LD_INT 4
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 4
74795: PUSH
74796: LD_INT 3
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 5
74805: PUSH
74806: LD_INT 4
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 5
74815: PUSH
74816: LD_INT 5
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 4
74825: PUSH
74826: LD_INT 5
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 3
74835: PUSH
74836: LD_INT 4
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 3
74845: PUSH
74846: LD_INT 3
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 5
74855: PUSH
74856: LD_INT 3
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 3
74865: PUSH
74866: LD_INT 5
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: LD_INT 0
74875: PUSH
74876: LD_INT 3
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 0
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 1
74895: PUSH
74896: LD_INT 3
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: LD_INT 4
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: LD_INT 4
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 1
74925: NEG
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 1
74936: NEG
74937: PUSH
74938: LD_INT 2
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 2
74947: PUSH
74948: LD_INT 4
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 2
74957: NEG
74958: PUSH
74959: LD_INT 2
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 4
74968: NEG
74969: PUSH
74970: LD_INT 0
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 4
74979: NEG
74980: PUSH
74981: LD_INT 1
74983: NEG
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 3
74991: NEG
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 3
75002: NEG
75003: PUSH
75004: LD_INT 1
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: LD_INT 4
75013: NEG
75014: PUSH
75015: LD_INT 1
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PUSH
75022: LD_INT 5
75024: NEG
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PUSH
75033: LD_INT 5
75035: NEG
75036: PUSH
75037: LD_INT 1
75039: NEG
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 5
75047: NEG
75048: PUSH
75049: LD_INT 2
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 3
75059: NEG
75060: PUSH
75061: LD_INT 2
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: LIST
75081: LIST
75082: LIST
75083: LIST
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: LIST
75094: LIST
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: ST_TO_ADDR
// end ; end ;
75115: GO 75118
75117: POP
// case btype of b_depot , b_warehouse :
75118: LD_VAR 0 1
75122: PUSH
75123: LD_INT 0
75125: DOUBLE
75126: EQUAL
75127: IFTRUE 75137
75129: LD_INT 1
75131: DOUBLE
75132: EQUAL
75133: IFTRUE 75137
75135: GO 75338
75137: POP
// case nation of nation_american :
75138: LD_VAR 0 5
75142: PUSH
75143: LD_INT 1
75145: DOUBLE
75146: EQUAL
75147: IFTRUE 75151
75149: GO 75207
75151: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
75152: LD_ADDR_VAR 0 9
75156: PUSH
75157: LD_VAR 0 11
75161: PUSH
75162: LD_VAR 0 12
75166: PUSH
75167: LD_VAR 0 13
75171: PUSH
75172: LD_VAR 0 14
75176: PUSH
75177: LD_VAR 0 15
75181: PUSH
75182: LD_VAR 0 16
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: LIST
75193: LIST
75194: PUSH
75195: LD_VAR 0 4
75199: PUSH
75200: LD_INT 1
75202: PLUS
75203: ARRAY
75204: ST_TO_ADDR
75205: GO 75336
75207: LD_INT 2
75209: DOUBLE
75210: EQUAL
75211: IFTRUE 75215
75213: GO 75271
75215: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
75216: LD_ADDR_VAR 0 9
75220: PUSH
75221: LD_VAR 0 17
75225: PUSH
75226: LD_VAR 0 18
75230: PUSH
75231: LD_VAR 0 19
75235: PUSH
75236: LD_VAR 0 20
75240: PUSH
75241: LD_VAR 0 21
75245: PUSH
75246: LD_VAR 0 22
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: LIST
75258: PUSH
75259: LD_VAR 0 4
75263: PUSH
75264: LD_INT 1
75266: PLUS
75267: ARRAY
75268: ST_TO_ADDR
75269: GO 75336
75271: LD_INT 3
75273: DOUBLE
75274: EQUAL
75275: IFTRUE 75279
75277: GO 75335
75279: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
75280: LD_ADDR_VAR 0 9
75284: PUSH
75285: LD_VAR 0 23
75289: PUSH
75290: LD_VAR 0 24
75294: PUSH
75295: LD_VAR 0 25
75299: PUSH
75300: LD_VAR 0 26
75304: PUSH
75305: LD_VAR 0 27
75309: PUSH
75310: LD_VAR 0 28
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: PUSH
75323: LD_VAR 0 4
75327: PUSH
75328: LD_INT 1
75330: PLUS
75331: ARRAY
75332: ST_TO_ADDR
75333: GO 75336
75335: POP
75336: GO 75885
75338: LD_INT 2
75340: DOUBLE
75341: EQUAL
75342: IFTRUE 75352
75344: LD_INT 3
75346: DOUBLE
75347: EQUAL
75348: IFTRUE 75352
75350: GO 75408
75352: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
75353: LD_ADDR_VAR 0 9
75357: PUSH
75358: LD_VAR 0 29
75362: PUSH
75363: LD_VAR 0 30
75367: PUSH
75368: LD_VAR 0 31
75372: PUSH
75373: LD_VAR 0 32
75377: PUSH
75378: LD_VAR 0 33
75382: PUSH
75383: LD_VAR 0 34
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: LIST
75392: LIST
75393: LIST
75394: LIST
75395: PUSH
75396: LD_VAR 0 4
75400: PUSH
75401: LD_INT 1
75403: PLUS
75404: ARRAY
75405: ST_TO_ADDR
75406: GO 75885
75408: LD_INT 16
75410: DOUBLE
75411: EQUAL
75412: IFTRUE 75464
75414: LD_INT 17
75416: DOUBLE
75417: EQUAL
75418: IFTRUE 75464
75420: LD_INT 18
75422: DOUBLE
75423: EQUAL
75424: IFTRUE 75464
75426: LD_INT 19
75428: DOUBLE
75429: EQUAL
75430: IFTRUE 75464
75432: LD_INT 20
75434: DOUBLE
75435: EQUAL
75436: IFTRUE 75464
75438: LD_INT 21
75440: DOUBLE
75441: EQUAL
75442: IFTRUE 75464
75444: LD_INT 23
75446: DOUBLE
75447: EQUAL
75448: IFTRUE 75464
75450: LD_INT 24
75452: DOUBLE
75453: EQUAL
75454: IFTRUE 75464
75456: LD_INT 25
75458: DOUBLE
75459: EQUAL
75460: IFTRUE 75464
75462: GO 75520
75464: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
75465: LD_ADDR_VAR 0 9
75469: PUSH
75470: LD_VAR 0 35
75474: PUSH
75475: LD_VAR 0 36
75479: PUSH
75480: LD_VAR 0 37
75484: PUSH
75485: LD_VAR 0 38
75489: PUSH
75490: LD_VAR 0 39
75494: PUSH
75495: LD_VAR 0 40
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: PUSH
75508: LD_VAR 0 4
75512: PUSH
75513: LD_INT 1
75515: PLUS
75516: ARRAY
75517: ST_TO_ADDR
75518: GO 75885
75520: LD_INT 6
75522: DOUBLE
75523: EQUAL
75524: IFTRUE 75576
75526: LD_INT 7
75528: DOUBLE
75529: EQUAL
75530: IFTRUE 75576
75532: LD_INT 8
75534: DOUBLE
75535: EQUAL
75536: IFTRUE 75576
75538: LD_INT 13
75540: DOUBLE
75541: EQUAL
75542: IFTRUE 75576
75544: LD_INT 12
75546: DOUBLE
75547: EQUAL
75548: IFTRUE 75576
75550: LD_INT 15
75552: DOUBLE
75553: EQUAL
75554: IFTRUE 75576
75556: LD_INT 11
75558: DOUBLE
75559: EQUAL
75560: IFTRUE 75576
75562: LD_INT 14
75564: DOUBLE
75565: EQUAL
75566: IFTRUE 75576
75568: LD_INT 10
75570: DOUBLE
75571: EQUAL
75572: IFTRUE 75576
75574: GO 75632
75576: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
75577: LD_ADDR_VAR 0 9
75581: PUSH
75582: LD_VAR 0 41
75586: PUSH
75587: LD_VAR 0 42
75591: PUSH
75592: LD_VAR 0 43
75596: PUSH
75597: LD_VAR 0 44
75601: PUSH
75602: LD_VAR 0 45
75606: PUSH
75607: LD_VAR 0 46
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: PUSH
75620: LD_VAR 0 4
75624: PUSH
75625: LD_INT 1
75627: PLUS
75628: ARRAY
75629: ST_TO_ADDR
75630: GO 75885
75632: LD_INT 36
75634: DOUBLE
75635: EQUAL
75636: IFTRUE 75640
75638: GO 75696
75640: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
75641: LD_ADDR_VAR 0 9
75645: PUSH
75646: LD_VAR 0 47
75650: PUSH
75651: LD_VAR 0 48
75655: PUSH
75656: LD_VAR 0 49
75660: PUSH
75661: LD_VAR 0 50
75665: PUSH
75666: LD_VAR 0 51
75670: PUSH
75671: LD_VAR 0 52
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: LIST
75680: LIST
75681: LIST
75682: LIST
75683: PUSH
75684: LD_VAR 0 4
75688: PUSH
75689: LD_INT 1
75691: PLUS
75692: ARRAY
75693: ST_TO_ADDR
75694: GO 75885
75696: LD_INT 4
75698: DOUBLE
75699: EQUAL
75700: IFTRUE 75722
75702: LD_INT 5
75704: DOUBLE
75705: EQUAL
75706: IFTRUE 75722
75708: LD_INT 34
75710: DOUBLE
75711: EQUAL
75712: IFTRUE 75722
75714: LD_INT 37
75716: DOUBLE
75717: EQUAL
75718: IFTRUE 75722
75720: GO 75778
75722: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
75723: LD_ADDR_VAR 0 9
75727: PUSH
75728: LD_VAR 0 53
75732: PUSH
75733: LD_VAR 0 54
75737: PUSH
75738: LD_VAR 0 55
75742: PUSH
75743: LD_VAR 0 56
75747: PUSH
75748: LD_VAR 0 57
75752: PUSH
75753: LD_VAR 0 58
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: PUSH
75766: LD_VAR 0 4
75770: PUSH
75771: LD_INT 1
75773: PLUS
75774: ARRAY
75775: ST_TO_ADDR
75776: GO 75885
75778: LD_INT 31
75780: DOUBLE
75781: EQUAL
75782: IFTRUE 75828
75784: LD_INT 32
75786: DOUBLE
75787: EQUAL
75788: IFTRUE 75828
75790: LD_INT 33
75792: DOUBLE
75793: EQUAL
75794: IFTRUE 75828
75796: LD_INT 27
75798: DOUBLE
75799: EQUAL
75800: IFTRUE 75828
75802: LD_INT 26
75804: DOUBLE
75805: EQUAL
75806: IFTRUE 75828
75808: LD_INT 28
75810: DOUBLE
75811: EQUAL
75812: IFTRUE 75828
75814: LD_INT 29
75816: DOUBLE
75817: EQUAL
75818: IFTRUE 75828
75820: LD_INT 30
75822: DOUBLE
75823: EQUAL
75824: IFTRUE 75828
75826: GO 75884
75828: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
75829: LD_ADDR_VAR 0 9
75833: PUSH
75834: LD_VAR 0 59
75838: PUSH
75839: LD_VAR 0 60
75843: PUSH
75844: LD_VAR 0 61
75848: PUSH
75849: LD_VAR 0 62
75853: PUSH
75854: LD_VAR 0 63
75858: PUSH
75859: LD_VAR 0 64
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: PUSH
75872: LD_VAR 0 4
75876: PUSH
75877: LD_INT 1
75879: PLUS
75880: ARRAY
75881: ST_TO_ADDR
75882: GO 75885
75884: POP
// temp_list2 = [ ] ;
75885: LD_ADDR_VAR 0 10
75889: PUSH
75890: EMPTY
75891: ST_TO_ADDR
// for i in temp_list do
75892: LD_ADDR_VAR 0 8
75896: PUSH
75897: LD_VAR 0 9
75901: PUSH
75902: FOR_IN
75903: IFFALSE 75955
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
75905: LD_ADDR_VAR 0 10
75909: PUSH
75910: LD_VAR 0 10
75914: PUSH
75915: LD_VAR 0 8
75919: PUSH
75920: LD_INT 1
75922: ARRAY
75923: PUSH
75924: LD_VAR 0 2
75928: PLUS
75929: PUSH
75930: LD_VAR 0 8
75934: PUSH
75935: LD_INT 2
75937: ARRAY
75938: PUSH
75939: LD_VAR 0 3
75943: PLUS
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: EMPTY
75950: LIST
75951: ADD
75952: ST_TO_ADDR
75953: GO 75902
75955: POP
75956: POP
// result = temp_list2 ;
75957: LD_ADDR_VAR 0 7
75961: PUSH
75962: LD_VAR 0 10
75966: ST_TO_ADDR
// end ;
75967: LD_VAR 0 7
75971: RET
// export function EnemyInRange ( unit , dist ) ; begin
75972: LD_INT 0
75974: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
75975: LD_ADDR_VAR 0 3
75979: PUSH
75980: LD_VAR 0 1
75984: PPUSH
75985: CALL_OW 255
75989: PPUSH
75990: LD_VAR 0 1
75994: PPUSH
75995: CALL_OW 250
75999: PPUSH
76000: LD_VAR 0 1
76004: PPUSH
76005: CALL_OW 251
76009: PPUSH
76010: LD_VAR 0 2
76014: PPUSH
76015: CALL 50100 0 4
76019: PUSH
76020: LD_INT 4
76022: ARRAY
76023: ST_TO_ADDR
// end ;
76024: LD_VAR 0 3
76028: RET
// export function PlayerSeeMe ( unit ) ; begin
76029: LD_INT 0
76031: PPUSH
// result := See ( your_side , unit ) ;
76032: LD_ADDR_VAR 0 2
76036: PUSH
76037: LD_OWVAR 2
76041: PPUSH
76042: LD_VAR 0 1
76046: PPUSH
76047: CALL_OW 292
76051: ST_TO_ADDR
// end ;
76052: LD_VAR 0 2
76056: RET
// export function ReverseDir ( unit ) ; begin
76057: LD_INT 0
76059: PPUSH
// if not unit then
76060: LD_VAR 0 1
76064: NOT
76065: IFFALSE 76069
// exit ;
76067: GO 76115
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
76069: LD_ADDR_VAR 0 2
76073: PUSH
76074: LD_INT 3
76076: PUSH
76077: LD_INT 4
76079: PUSH
76080: LD_INT 5
76082: PUSH
76083: LD_INT 0
76085: PUSH
76086: LD_INT 1
76088: PUSH
76089: LD_INT 2
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: PUSH
76100: LD_VAR 0 1
76104: PPUSH
76105: CALL_OW 254
76109: PUSH
76110: LD_INT 1
76112: PLUS
76113: ARRAY
76114: ST_TO_ADDR
// end ;
76115: LD_VAR 0 2
76119: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
76120: LD_INT 0
76122: PPUSH
76123: PPUSH
76124: PPUSH
76125: PPUSH
76126: PPUSH
// if not hexes then
76127: LD_VAR 0 2
76131: NOT
76132: IFFALSE 76136
// exit ;
76134: GO 76284
// dist := 9999 ;
76136: LD_ADDR_VAR 0 5
76140: PUSH
76141: LD_INT 9999
76143: ST_TO_ADDR
// for i = 1 to hexes do
76144: LD_ADDR_VAR 0 4
76148: PUSH
76149: DOUBLE
76150: LD_INT 1
76152: DEC
76153: ST_TO_ADDR
76154: LD_VAR 0 2
76158: PUSH
76159: FOR_TO
76160: IFFALSE 76272
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
76162: LD_VAR 0 1
76166: PPUSH
76167: LD_VAR 0 2
76171: PUSH
76172: LD_VAR 0 4
76176: ARRAY
76177: PUSH
76178: LD_INT 1
76180: ARRAY
76181: PPUSH
76182: LD_VAR 0 2
76186: PUSH
76187: LD_VAR 0 4
76191: ARRAY
76192: PUSH
76193: LD_INT 2
76195: ARRAY
76196: PPUSH
76197: CALL_OW 297
76201: PUSH
76202: LD_VAR 0 5
76206: LESS
76207: IFFALSE 76270
// begin hex := hexes [ i ] ;
76209: LD_ADDR_VAR 0 7
76213: PUSH
76214: LD_VAR 0 2
76218: PUSH
76219: LD_VAR 0 4
76223: ARRAY
76224: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76225: LD_ADDR_VAR 0 5
76229: PUSH
76230: LD_VAR 0 1
76234: PPUSH
76235: LD_VAR 0 2
76239: PUSH
76240: LD_VAR 0 4
76244: ARRAY
76245: PUSH
76246: LD_INT 1
76248: ARRAY
76249: PPUSH
76250: LD_VAR 0 2
76254: PUSH
76255: LD_VAR 0 4
76259: ARRAY
76260: PUSH
76261: LD_INT 2
76263: ARRAY
76264: PPUSH
76265: CALL_OW 297
76269: ST_TO_ADDR
// end ; end ;
76270: GO 76159
76272: POP
76273: POP
// result := hex ;
76274: LD_ADDR_VAR 0 3
76278: PUSH
76279: LD_VAR 0 7
76283: ST_TO_ADDR
// end ;
76284: LD_VAR 0 3
76288: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
76289: LD_INT 0
76291: PPUSH
76292: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
76293: LD_VAR 0 1
76297: NOT
76298: PUSH
76299: LD_VAR 0 1
76303: PUSH
76304: LD_INT 21
76306: PUSH
76307: LD_INT 2
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 23
76316: PUSH
76317: LD_INT 2
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PPUSH
76328: CALL_OW 69
76332: IN
76333: NOT
76334: OR
76335: IFFALSE 76339
// exit ;
76337: GO 76386
// for i = 1 to 3 do
76339: LD_ADDR_VAR 0 3
76343: PUSH
76344: DOUBLE
76345: LD_INT 1
76347: DEC
76348: ST_TO_ADDR
76349: LD_INT 3
76351: PUSH
76352: FOR_TO
76353: IFFALSE 76384
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
76355: LD_VAR 0 1
76359: PPUSH
76360: CALL_OW 250
76364: PPUSH
76365: LD_VAR 0 1
76369: PPUSH
76370: CALL_OW 251
76374: PPUSH
76375: LD_INT 1
76377: PPUSH
76378: CALL_OW 453
76382: GO 76352
76384: POP
76385: POP
// end ;
76386: LD_VAR 0 2
76390: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
76391: LD_INT 0
76393: PPUSH
76394: PPUSH
76395: PPUSH
76396: PPUSH
76397: PPUSH
76398: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
76399: LD_VAR 0 1
76403: NOT
76404: PUSH
76405: LD_VAR 0 2
76409: NOT
76410: OR
76411: PUSH
76412: LD_VAR 0 1
76416: PPUSH
76417: CALL_OW 314
76421: OR
76422: IFFALSE 76426
// exit ;
76424: GO 76867
// x := GetX ( enemy_unit ) ;
76426: LD_ADDR_VAR 0 7
76430: PUSH
76431: LD_VAR 0 2
76435: PPUSH
76436: CALL_OW 250
76440: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
76441: LD_ADDR_VAR 0 8
76445: PUSH
76446: LD_VAR 0 2
76450: PPUSH
76451: CALL_OW 251
76455: ST_TO_ADDR
// if not x or not y then
76456: LD_VAR 0 7
76460: NOT
76461: PUSH
76462: LD_VAR 0 8
76466: NOT
76467: OR
76468: IFFALSE 76472
// exit ;
76470: GO 76867
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
76472: LD_ADDR_VAR 0 6
76476: PUSH
76477: LD_VAR 0 7
76481: PPUSH
76482: LD_INT 0
76484: PPUSH
76485: LD_INT 4
76487: PPUSH
76488: CALL_OW 272
76492: PUSH
76493: LD_VAR 0 8
76497: PPUSH
76498: LD_INT 0
76500: PPUSH
76501: LD_INT 4
76503: PPUSH
76504: CALL_OW 273
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_VAR 0 7
76517: PPUSH
76518: LD_INT 1
76520: PPUSH
76521: LD_INT 4
76523: PPUSH
76524: CALL_OW 272
76528: PUSH
76529: LD_VAR 0 8
76533: PPUSH
76534: LD_INT 1
76536: PPUSH
76537: LD_INT 4
76539: PPUSH
76540: CALL_OW 273
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_VAR 0 7
76553: PPUSH
76554: LD_INT 2
76556: PPUSH
76557: LD_INT 4
76559: PPUSH
76560: CALL_OW 272
76564: PUSH
76565: LD_VAR 0 8
76569: PPUSH
76570: LD_INT 2
76572: PPUSH
76573: LD_INT 4
76575: PPUSH
76576: CALL_OW 273
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_VAR 0 7
76589: PPUSH
76590: LD_INT 3
76592: PPUSH
76593: LD_INT 4
76595: PPUSH
76596: CALL_OW 272
76600: PUSH
76601: LD_VAR 0 8
76605: PPUSH
76606: LD_INT 3
76608: PPUSH
76609: LD_INT 4
76611: PPUSH
76612: CALL_OW 273
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_VAR 0 7
76625: PPUSH
76626: LD_INT 4
76628: PPUSH
76629: LD_INT 4
76631: PPUSH
76632: CALL_OW 272
76636: PUSH
76637: LD_VAR 0 8
76641: PPUSH
76642: LD_INT 4
76644: PPUSH
76645: LD_INT 4
76647: PPUSH
76648: CALL_OW 273
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_VAR 0 7
76661: PPUSH
76662: LD_INT 5
76664: PPUSH
76665: LD_INT 4
76667: PPUSH
76668: CALL_OW 272
76672: PUSH
76673: LD_VAR 0 8
76677: PPUSH
76678: LD_INT 5
76680: PPUSH
76681: LD_INT 4
76683: PPUSH
76684: CALL_OW 273
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: LIST
76697: LIST
76698: LIST
76699: LIST
76700: ST_TO_ADDR
// for i = tmp downto 1 do
76701: LD_ADDR_VAR 0 4
76705: PUSH
76706: DOUBLE
76707: LD_VAR 0 6
76711: INC
76712: ST_TO_ADDR
76713: LD_INT 1
76715: PUSH
76716: FOR_DOWNTO
76717: IFFALSE 76818
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
76719: LD_VAR 0 6
76723: PUSH
76724: LD_VAR 0 4
76728: ARRAY
76729: PUSH
76730: LD_INT 1
76732: ARRAY
76733: PPUSH
76734: LD_VAR 0 6
76738: PUSH
76739: LD_VAR 0 4
76743: ARRAY
76744: PUSH
76745: LD_INT 2
76747: ARRAY
76748: PPUSH
76749: CALL_OW 488
76753: NOT
76754: PUSH
76755: LD_VAR 0 6
76759: PUSH
76760: LD_VAR 0 4
76764: ARRAY
76765: PUSH
76766: LD_INT 1
76768: ARRAY
76769: PPUSH
76770: LD_VAR 0 6
76774: PUSH
76775: LD_VAR 0 4
76779: ARRAY
76780: PUSH
76781: LD_INT 2
76783: ARRAY
76784: PPUSH
76785: CALL_OW 428
76789: PUSH
76790: LD_INT 0
76792: NONEQUAL
76793: OR
76794: IFFALSE 76816
// tmp := Delete ( tmp , i ) ;
76796: LD_ADDR_VAR 0 6
76800: PUSH
76801: LD_VAR 0 6
76805: PPUSH
76806: LD_VAR 0 4
76810: PPUSH
76811: CALL_OW 3
76815: ST_TO_ADDR
76816: GO 76716
76818: POP
76819: POP
// j := GetClosestHex ( unit , tmp ) ;
76820: LD_ADDR_VAR 0 5
76824: PUSH
76825: LD_VAR 0 1
76829: PPUSH
76830: LD_VAR 0 6
76834: PPUSH
76835: CALL 76120 0 2
76839: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
76840: LD_VAR 0 1
76844: PPUSH
76845: LD_VAR 0 5
76849: PUSH
76850: LD_INT 1
76852: ARRAY
76853: PPUSH
76854: LD_VAR 0 5
76858: PUSH
76859: LD_INT 2
76861: ARRAY
76862: PPUSH
76863: CALL_OW 111
// end ;
76867: LD_VAR 0 3
76871: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
76872: LD_INT 0
76874: PPUSH
76875: PPUSH
76876: PPUSH
// uc_side = 0 ;
76877: LD_ADDR_OWVAR 20
76881: PUSH
76882: LD_INT 0
76884: ST_TO_ADDR
// uc_nation = 0 ;
76885: LD_ADDR_OWVAR 21
76889: PUSH
76890: LD_INT 0
76892: ST_TO_ADDR
// InitHc ;
76893: CALL_OW 19
// InitVc ;
76897: CALL_OW 20
// if mastodonts then
76901: LD_VAR 0 6
76905: IFFALSE 76972
// for i = 1 to mastodonts do
76907: LD_ADDR_VAR 0 11
76911: PUSH
76912: DOUBLE
76913: LD_INT 1
76915: DEC
76916: ST_TO_ADDR
76917: LD_VAR 0 6
76921: PUSH
76922: FOR_TO
76923: IFFALSE 76970
// begin vc_chassis := 31 ;
76925: LD_ADDR_OWVAR 37
76929: PUSH
76930: LD_INT 31
76932: ST_TO_ADDR
// vc_control := control_rider ;
76933: LD_ADDR_OWVAR 38
76937: PUSH
76938: LD_INT 4
76940: ST_TO_ADDR
// animal := CreateVehicle ;
76941: LD_ADDR_VAR 0 12
76945: PUSH
76946: CALL_OW 45
76950: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
76951: LD_VAR 0 12
76955: PPUSH
76956: LD_VAR 0 8
76960: PPUSH
76961: LD_INT 0
76963: PPUSH
76964: CALL 83678 0 3
// end ;
76968: GO 76922
76970: POP
76971: POP
// if horses then
76972: LD_VAR 0 5
76976: IFFALSE 77043
// for i = 1 to horses do
76978: LD_ADDR_VAR 0 11
76982: PUSH
76983: DOUBLE
76984: LD_INT 1
76986: DEC
76987: ST_TO_ADDR
76988: LD_VAR 0 5
76992: PUSH
76993: FOR_TO
76994: IFFALSE 77041
// begin hc_class := 21 ;
76996: LD_ADDR_OWVAR 28
77000: PUSH
77001: LD_INT 21
77003: ST_TO_ADDR
// hc_gallery :=  ;
77004: LD_ADDR_OWVAR 33
77008: PUSH
77009: LD_STRING 
77011: ST_TO_ADDR
// animal := CreateHuman ;
77012: LD_ADDR_VAR 0 12
77016: PUSH
77017: CALL_OW 44
77021: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
77022: LD_VAR 0 12
77026: PPUSH
77027: LD_VAR 0 8
77031: PPUSH
77032: LD_INT 0
77034: PPUSH
77035: CALL 83678 0 3
// end ;
77039: GO 76993
77041: POP
77042: POP
// if birds then
77043: LD_VAR 0 1
77047: IFFALSE 77114
// for i = 1 to birds do
77049: LD_ADDR_VAR 0 11
77053: PUSH
77054: DOUBLE
77055: LD_INT 1
77057: DEC
77058: ST_TO_ADDR
77059: LD_VAR 0 1
77063: PUSH
77064: FOR_TO
77065: IFFALSE 77112
// begin hc_class = 18 ;
77067: LD_ADDR_OWVAR 28
77071: PUSH
77072: LD_INT 18
77074: ST_TO_ADDR
// hc_gallery =  ;
77075: LD_ADDR_OWVAR 33
77079: PUSH
77080: LD_STRING 
77082: ST_TO_ADDR
// animal := CreateHuman ;
77083: LD_ADDR_VAR 0 12
77087: PUSH
77088: CALL_OW 44
77092: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
77093: LD_VAR 0 12
77097: PPUSH
77098: LD_VAR 0 8
77102: PPUSH
77103: LD_INT 0
77105: PPUSH
77106: CALL 83678 0 3
// end ;
77110: GO 77064
77112: POP
77113: POP
// if tigers then
77114: LD_VAR 0 2
77118: IFFALSE 77202
// for i = 1 to tigers do
77120: LD_ADDR_VAR 0 11
77124: PUSH
77125: DOUBLE
77126: LD_INT 1
77128: DEC
77129: ST_TO_ADDR
77130: LD_VAR 0 2
77134: PUSH
77135: FOR_TO
77136: IFFALSE 77200
// begin hc_class = class_tiger ;
77138: LD_ADDR_OWVAR 28
77142: PUSH
77143: LD_INT 14
77145: ST_TO_ADDR
// hc_gallery =  ;
77146: LD_ADDR_OWVAR 33
77150: PUSH
77151: LD_STRING 
77153: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
77154: LD_ADDR_OWVAR 35
77158: PUSH
77159: LD_INT 7
77161: NEG
77162: PPUSH
77163: LD_INT 7
77165: PPUSH
77166: CALL_OW 12
77170: ST_TO_ADDR
// animal := CreateHuman ;
77171: LD_ADDR_VAR 0 12
77175: PUSH
77176: CALL_OW 44
77180: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
77181: LD_VAR 0 12
77185: PPUSH
77186: LD_VAR 0 8
77190: PPUSH
77191: LD_INT 0
77193: PPUSH
77194: CALL 83678 0 3
// end ;
77198: GO 77135
77200: POP
77201: POP
// if apemans then
77202: LD_VAR 0 3
77206: IFFALSE 77329
// for i = 1 to apemans do
77208: LD_ADDR_VAR 0 11
77212: PUSH
77213: DOUBLE
77214: LD_INT 1
77216: DEC
77217: ST_TO_ADDR
77218: LD_VAR 0 3
77222: PUSH
77223: FOR_TO
77224: IFFALSE 77327
// begin hc_class = class_apeman ;
77226: LD_ADDR_OWVAR 28
77230: PUSH
77231: LD_INT 12
77233: ST_TO_ADDR
// hc_gallery =  ;
77234: LD_ADDR_OWVAR 33
77238: PUSH
77239: LD_STRING 
77241: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
77242: LD_ADDR_OWVAR 35
77246: PUSH
77247: LD_INT 5
77249: NEG
77250: PPUSH
77251: LD_INT 5
77253: PPUSH
77254: CALL_OW 12
77258: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
77259: LD_ADDR_OWVAR 31
77263: PUSH
77264: LD_INT 1
77266: PPUSH
77267: LD_INT 3
77269: PPUSH
77270: CALL_OW 12
77274: PUSH
77275: LD_INT 1
77277: PPUSH
77278: LD_INT 3
77280: PPUSH
77281: CALL_OW 12
77285: PUSH
77286: LD_INT 0
77288: PUSH
77289: LD_INT 0
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: ST_TO_ADDR
// animal := CreateHuman ;
77298: LD_ADDR_VAR 0 12
77302: PUSH
77303: CALL_OW 44
77307: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
77308: LD_VAR 0 12
77312: PPUSH
77313: LD_VAR 0 8
77317: PPUSH
77318: LD_INT 0
77320: PPUSH
77321: CALL 83678 0 3
// end ;
77325: GO 77223
77327: POP
77328: POP
// if enchidnas then
77329: LD_VAR 0 4
77333: IFFALSE 77400
// for i = 1 to enchidnas do
77335: LD_ADDR_VAR 0 11
77339: PUSH
77340: DOUBLE
77341: LD_INT 1
77343: DEC
77344: ST_TO_ADDR
77345: LD_VAR 0 4
77349: PUSH
77350: FOR_TO
77351: IFFALSE 77398
// begin hc_class = 13 ;
77353: LD_ADDR_OWVAR 28
77357: PUSH
77358: LD_INT 13
77360: ST_TO_ADDR
// hc_gallery =  ;
77361: LD_ADDR_OWVAR 33
77365: PUSH
77366: LD_STRING 
77368: ST_TO_ADDR
// animal := CreateHuman ;
77369: LD_ADDR_VAR 0 12
77373: PUSH
77374: CALL_OW 44
77378: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
77379: LD_VAR 0 12
77383: PPUSH
77384: LD_VAR 0 8
77388: PPUSH
77389: LD_INT 0
77391: PPUSH
77392: CALL 83678 0 3
// end ;
77396: GO 77350
77398: POP
77399: POP
// if fishes then
77400: LD_VAR 0 7
77404: IFFALSE 77471
// for i = 1 to fishes do
77406: LD_ADDR_VAR 0 11
77410: PUSH
77411: DOUBLE
77412: LD_INT 1
77414: DEC
77415: ST_TO_ADDR
77416: LD_VAR 0 7
77420: PUSH
77421: FOR_TO
77422: IFFALSE 77469
// begin hc_class = 20 ;
77424: LD_ADDR_OWVAR 28
77428: PUSH
77429: LD_INT 20
77431: ST_TO_ADDR
// hc_gallery =  ;
77432: LD_ADDR_OWVAR 33
77436: PUSH
77437: LD_STRING 
77439: ST_TO_ADDR
// animal := CreateHuman ;
77440: LD_ADDR_VAR 0 12
77444: PUSH
77445: CALL_OW 44
77449: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
77450: LD_VAR 0 12
77454: PPUSH
77455: LD_VAR 0 9
77459: PPUSH
77460: LD_INT 0
77462: PPUSH
77463: CALL 83678 0 3
// end ;
77467: GO 77421
77469: POP
77470: POP
// end ;
77471: LD_VAR 0 10
77475: RET
// export function WantHeal ( sci , unit ) ; begin
77476: LD_INT 0
77478: PPUSH
// if GetTaskList ( sci ) > 0 then
77479: LD_VAR 0 1
77483: PPUSH
77484: CALL_OW 437
77488: PUSH
77489: LD_INT 0
77491: GREATER
77492: IFFALSE 77562
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
77494: LD_VAR 0 1
77498: PPUSH
77499: CALL_OW 437
77503: PUSH
77504: LD_INT 1
77506: ARRAY
77507: PUSH
77508: LD_INT 1
77510: ARRAY
77511: PUSH
77512: LD_STRING l
77514: EQUAL
77515: PUSH
77516: LD_VAR 0 1
77520: PPUSH
77521: CALL_OW 437
77525: PUSH
77526: LD_INT 1
77528: ARRAY
77529: PUSH
77530: LD_INT 4
77532: ARRAY
77533: PUSH
77534: LD_VAR 0 2
77538: EQUAL
77539: AND
77540: IFFALSE 77552
// result := true else
77542: LD_ADDR_VAR 0 3
77546: PUSH
77547: LD_INT 1
77549: ST_TO_ADDR
77550: GO 77560
// result := false ;
77552: LD_ADDR_VAR 0 3
77556: PUSH
77557: LD_INT 0
77559: ST_TO_ADDR
// end else
77560: GO 77570
// result := false ;
77562: LD_ADDR_VAR 0 3
77566: PUSH
77567: LD_INT 0
77569: ST_TO_ADDR
// end ;
77570: LD_VAR 0 3
77574: RET
// export function HealTarget ( sci ) ; begin
77575: LD_INT 0
77577: PPUSH
// if not sci then
77578: LD_VAR 0 1
77582: NOT
77583: IFFALSE 77587
// exit ;
77585: GO 77652
// result := 0 ;
77587: LD_ADDR_VAR 0 2
77591: PUSH
77592: LD_INT 0
77594: ST_TO_ADDR
// if GetTaskList ( sci ) then
77595: LD_VAR 0 1
77599: PPUSH
77600: CALL_OW 437
77604: IFFALSE 77652
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
77606: LD_VAR 0 1
77610: PPUSH
77611: CALL_OW 437
77615: PUSH
77616: LD_INT 1
77618: ARRAY
77619: PUSH
77620: LD_INT 1
77622: ARRAY
77623: PUSH
77624: LD_STRING l
77626: EQUAL
77627: IFFALSE 77652
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
77629: LD_ADDR_VAR 0 2
77633: PUSH
77634: LD_VAR 0 1
77638: PPUSH
77639: CALL_OW 437
77643: PUSH
77644: LD_INT 1
77646: ARRAY
77647: PUSH
77648: LD_INT 4
77650: ARRAY
77651: ST_TO_ADDR
// end ;
77652: LD_VAR 0 2
77656: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
77657: LD_INT 0
77659: PPUSH
77660: PPUSH
77661: PPUSH
77662: PPUSH
77663: PPUSH
77664: PPUSH
77665: PPUSH
77666: PPUSH
77667: PPUSH
77668: PPUSH
77669: PPUSH
77670: PPUSH
77671: PPUSH
77672: PPUSH
77673: PPUSH
77674: PPUSH
77675: PPUSH
77676: PPUSH
77677: PPUSH
77678: PPUSH
77679: PPUSH
77680: PPUSH
77681: PPUSH
77682: PPUSH
77683: PPUSH
77684: PPUSH
77685: PPUSH
77686: PPUSH
77687: PPUSH
77688: PPUSH
77689: PPUSH
77690: PPUSH
77691: PPUSH
// if not list then
77692: LD_VAR 0 1
77696: NOT
77697: IFFALSE 77701
// exit ;
77699: GO 82289
// base := list [ 1 ] ;
77701: LD_ADDR_VAR 0 3
77705: PUSH
77706: LD_VAR 0 1
77710: PUSH
77711: LD_INT 1
77713: ARRAY
77714: ST_TO_ADDR
// group := list [ 2 ] ;
77715: LD_ADDR_VAR 0 4
77719: PUSH
77720: LD_VAR 0 1
77724: PUSH
77725: LD_INT 2
77727: ARRAY
77728: ST_TO_ADDR
// path := list [ 3 ] ;
77729: LD_ADDR_VAR 0 5
77733: PUSH
77734: LD_VAR 0 1
77738: PUSH
77739: LD_INT 3
77741: ARRAY
77742: ST_TO_ADDR
// flags := list [ 4 ] ;
77743: LD_ADDR_VAR 0 6
77747: PUSH
77748: LD_VAR 0 1
77752: PUSH
77753: LD_INT 4
77755: ARRAY
77756: ST_TO_ADDR
// mined := [ ] ;
77757: LD_ADDR_VAR 0 27
77761: PUSH
77762: EMPTY
77763: ST_TO_ADDR
// bombed := [ ] ;
77764: LD_ADDR_VAR 0 28
77768: PUSH
77769: EMPTY
77770: ST_TO_ADDR
// healers := [ ] ;
77771: LD_ADDR_VAR 0 31
77775: PUSH
77776: EMPTY
77777: ST_TO_ADDR
// to_heal := [ ] ;
77778: LD_ADDR_VAR 0 30
77782: PUSH
77783: EMPTY
77784: ST_TO_ADDR
// repairs := [ ] ;
77785: LD_ADDR_VAR 0 33
77789: PUSH
77790: EMPTY
77791: ST_TO_ADDR
// to_repair := [ ] ;
77792: LD_ADDR_VAR 0 32
77796: PUSH
77797: EMPTY
77798: ST_TO_ADDR
// if not group or not path then
77799: LD_VAR 0 4
77803: NOT
77804: PUSH
77805: LD_VAR 0 5
77809: NOT
77810: OR
77811: IFFALSE 77815
// exit ;
77813: GO 82289
// if flags then
77815: LD_VAR 0 6
77819: IFFALSE 77963
// begin f_ignore_area := flags [ 1 ] ;
77821: LD_ADDR_VAR 0 17
77825: PUSH
77826: LD_VAR 0 6
77830: PUSH
77831: LD_INT 1
77833: ARRAY
77834: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77835: LD_ADDR_VAR 0 18
77839: PUSH
77840: LD_VAR 0 6
77844: PUSH
77845: LD_INT 2
77847: ARRAY
77848: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77849: LD_ADDR_VAR 0 19
77853: PUSH
77854: LD_VAR 0 6
77858: PUSH
77859: LD_INT 3
77861: ARRAY
77862: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77863: LD_ADDR_VAR 0 20
77867: PUSH
77868: LD_VAR 0 6
77872: PUSH
77873: LD_INT 4
77875: ARRAY
77876: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77877: LD_ADDR_VAR 0 21
77881: PUSH
77882: LD_VAR 0 6
77886: PUSH
77887: LD_INT 5
77889: ARRAY
77890: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77891: LD_ADDR_VAR 0 22
77895: PUSH
77896: LD_VAR 0 6
77900: PUSH
77901: LD_INT 6
77903: ARRAY
77904: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77905: LD_ADDR_VAR 0 23
77909: PUSH
77910: LD_VAR 0 6
77914: PUSH
77915: LD_INT 7
77917: ARRAY
77918: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77919: LD_ADDR_VAR 0 24
77923: PUSH
77924: LD_VAR 0 6
77928: PUSH
77929: LD_INT 8
77931: ARRAY
77932: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77933: LD_ADDR_VAR 0 25
77937: PUSH
77938: LD_VAR 0 6
77942: PUSH
77943: LD_INT 9
77945: ARRAY
77946: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77947: LD_ADDR_VAR 0 26
77951: PUSH
77952: LD_VAR 0 6
77956: PUSH
77957: LD_INT 10
77959: ARRAY
77960: ST_TO_ADDR
// end else
77961: GO 78043
// begin f_ignore_area := false ;
77963: LD_ADDR_VAR 0 17
77967: PUSH
77968: LD_INT 0
77970: ST_TO_ADDR
// f_capture := false ;
77971: LD_ADDR_VAR 0 18
77975: PUSH
77976: LD_INT 0
77978: ST_TO_ADDR
// f_ignore_civ := false ;
77979: LD_ADDR_VAR 0 19
77983: PUSH
77984: LD_INT 0
77986: ST_TO_ADDR
// f_murder := false ;
77987: LD_ADDR_VAR 0 20
77991: PUSH
77992: LD_INT 0
77994: ST_TO_ADDR
// f_mines := false ;
77995: LD_ADDR_VAR 0 21
77999: PUSH
78000: LD_INT 0
78002: ST_TO_ADDR
// f_repair := false ;
78003: LD_ADDR_VAR 0 22
78007: PUSH
78008: LD_INT 0
78010: ST_TO_ADDR
// f_heal := false ;
78011: LD_ADDR_VAR 0 23
78015: PUSH
78016: LD_INT 0
78018: ST_TO_ADDR
// f_spacetime := false ;
78019: LD_ADDR_VAR 0 24
78023: PUSH
78024: LD_INT 0
78026: ST_TO_ADDR
// f_attack_depot := false ;
78027: LD_ADDR_VAR 0 25
78031: PUSH
78032: LD_INT 0
78034: ST_TO_ADDR
// f_crawl := false ;
78035: LD_ADDR_VAR 0 26
78039: PUSH
78040: LD_INT 0
78042: ST_TO_ADDR
// end ; if f_heal then
78043: LD_VAR 0 23
78047: IFFALSE 78074
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
78049: LD_ADDR_VAR 0 31
78053: PUSH
78054: LD_VAR 0 4
78058: PPUSH
78059: LD_INT 25
78061: PUSH
78062: LD_INT 4
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PPUSH
78069: CALL_OW 72
78073: ST_TO_ADDR
// if f_repair then
78074: LD_VAR 0 22
78078: IFFALSE 78105
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
78080: LD_ADDR_VAR 0 33
78084: PUSH
78085: LD_VAR 0 4
78089: PPUSH
78090: LD_INT 25
78092: PUSH
78093: LD_INT 3
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PPUSH
78100: CALL_OW 72
78104: ST_TO_ADDR
// units_path := [ ] ;
78105: LD_ADDR_VAR 0 16
78109: PUSH
78110: EMPTY
78111: ST_TO_ADDR
// for i = 1 to group do
78112: LD_ADDR_VAR 0 7
78116: PUSH
78117: DOUBLE
78118: LD_INT 1
78120: DEC
78121: ST_TO_ADDR
78122: LD_VAR 0 4
78126: PUSH
78127: FOR_TO
78128: IFFALSE 78157
// units_path := Replace ( units_path , i , path ) ;
78130: LD_ADDR_VAR 0 16
78134: PUSH
78135: LD_VAR 0 16
78139: PPUSH
78140: LD_VAR 0 7
78144: PPUSH
78145: LD_VAR 0 5
78149: PPUSH
78150: CALL_OW 1
78154: ST_TO_ADDR
78155: GO 78127
78157: POP
78158: POP
// repeat for i = group downto 1 do
78159: LD_ADDR_VAR 0 7
78163: PUSH
78164: DOUBLE
78165: LD_VAR 0 4
78169: INC
78170: ST_TO_ADDR
78171: LD_INT 1
78173: PUSH
78174: FOR_DOWNTO
78175: IFFALSE 82271
// begin wait ( 5 ) ;
78177: LD_INT 5
78179: PPUSH
78180: CALL_OW 67
// tmp := [ ] ;
78184: LD_ADDR_VAR 0 14
78188: PUSH
78189: EMPTY
78190: ST_TO_ADDR
// attacking := false ;
78191: LD_ADDR_VAR 0 29
78195: PUSH
78196: LD_INT 0
78198: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
78199: LD_VAR 0 4
78203: PUSH
78204: LD_VAR 0 7
78208: ARRAY
78209: PPUSH
78210: CALL_OW 301
78214: PUSH
78215: LD_VAR 0 4
78219: PUSH
78220: LD_VAR 0 7
78224: ARRAY
78225: NOT
78226: OR
78227: IFFALSE 78336
// begin if GetType ( group [ i ] ) = unit_human then
78229: LD_VAR 0 4
78233: PUSH
78234: LD_VAR 0 7
78238: ARRAY
78239: PPUSH
78240: CALL_OW 247
78244: PUSH
78245: LD_INT 1
78247: EQUAL
78248: IFFALSE 78294
// begin to_heal := to_heal diff group [ i ] ;
78250: LD_ADDR_VAR 0 30
78254: PUSH
78255: LD_VAR 0 30
78259: PUSH
78260: LD_VAR 0 4
78264: PUSH
78265: LD_VAR 0 7
78269: ARRAY
78270: DIFF
78271: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78272: LD_ADDR_VAR 0 31
78276: PUSH
78277: LD_VAR 0 31
78281: PUSH
78282: LD_VAR 0 4
78286: PUSH
78287: LD_VAR 0 7
78291: ARRAY
78292: DIFF
78293: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78294: LD_ADDR_VAR 0 4
78298: PUSH
78299: LD_VAR 0 4
78303: PPUSH
78304: LD_VAR 0 7
78308: PPUSH
78309: CALL_OW 3
78313: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78314: LD_ADDR_VAR 0 16
78318: PUSH
78319: LD_VAR 0 16
78323: PPUSH
78324: LD_VAR 0 7
78328: PPUSH
78329: CALL_OW 3
78333: ST_TO_ADDR
// continue ;
78334: GO 78174
// end ; if f_repair then
78336: LD_VAR 0 22
78340: IFFALSE 78829
// begin if GetType ( group [ i ] ) = unit_vehicle then
78342: LD_VAR 0 4
78346: PUSH
78347: LD_VAR 0 7
78351: ARRAY
78352: PPUSH
78353: CALL_OW 247
78357: PUSH
78358: LD_INT 2
78360: EQUAL
78361: IFFALSE 78551
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78363: LD_VAR 0 4
78367: PUSH
78368: LD_VAR 0 7
78372: ARRAY
78373: PPUSH
78374: CALL_OW 256
78378: PUSH
78379: LD_INT 700
78381: LESS
78382: PUSH
78383: LD_VAR 0 4
78387: PUSH
78388: LD_VAR 0 7
78392: ARRAY
78393: PUSH
78394: LD_VAR 0 32
78398: IN
78399: NOT
78400: AND
78401: IFFALSE 78425
// to_repair := to_repair union group [ i ] ;
78403: LD_ADDR_VAR 0 32
78407: PUSH
78408: LD_VAR 0 32
78412: PUSH
78413: LD_VAR 0 4
78417: PUSH
78418: LD_VAR 0 7
78422: ARRAY
78423: UNION
78424: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78425: LD_VAR 0 4
78429: PUSH
78430: LD_VAR 0 7
78434: ARRAY
78435: PPUSH
78436: CALL_OW 256
78440: PUSH
78441: LD_INT 1000
78443: EQUAL
78444: PUSH
78445: LD_VAR 0 4
78449: PUSH
78450: LD_VAR 0 7
78454: ARRAY
78455: PUSH
78456: LD_VAR 0 32
78460: IN
78461: AND
78462: IFFALSE 78486
// to_repair := to_repair diff group [ i ] ;
78464: LD_ADDR_VAR 0 32
78468: PUSH
78469: LD_VAR 0 32
78473: PUSH
78474: LD_VAR 0 4
78478: PUSH
78479: LD_VAR 0 7
78483: ARRAY
78484: DIFF
78485: ST_TO_ADDR
// if group [ i ] in to_repair then
78486: LD_VAR 0 4
78490: PUSH
78491: LD_VAR 0 7
78495: ARRAY
78496: PUSH
78497: LD_VAR 0 32
78501: IN
78502: IFFALSE 78549
// begin if not IsInArea ( group [ i ] , f_repair ) then
78504: LD_VAR 0 4
78508: PUSH
78509: LD_VAR 0 7
78513: ARRAY
78514: PPUSH
78515: LD_VAR 0 22
78519: PPUSH
78520: CALL_OW 308
78524: NOT
78525: IFFALSE 78547
// ComMoveToArea ( group [ i ] , f_repair ) ;
78527: LD_VAR 0 4
78531: PUSH
78532: LD_VAR 0 7
78536: ARRAY
78537: PPUSH
78538: LD_VAR 0 22
78542: PPUSH
78543: CALL_OW 113
// continue ;
78547: GO 78174
// end ; end else
78549: GO 78829
// if group [ i ] in repairs then
78551: LD_VAR 0 4
78555: PUSH
78556: LD_VAR 0 7
78560: ARRAY
78561: PUSH
78562: LD_VAR 0 33
78566: IN
78567: IFFALSE 78829
// begin if IsInUnit ( group [ i ] ) then
78569: LD_VAR 0 4
78573: PUSH
78574: LD_VAR 0 7
78578: ARRAY
78579: PPUSH
78580: CALL_OW 310
78584: IFFALSE 78652
// begin z := IsInUnit ( group [ i ] ) ;
78586: LD_ADDR_VAR 0 13
78590: PUSH
78591: LD_VAR 0 4
78595: PUSH
78596: LD_VAR 0 7
78600: ARRAY
78601: PPUSH
78602: CALL_OW 310
78606: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78607: LD_VAR 0 13
78611: PUSH
78612: LD_VAR 0 32
78616: IN
78617: PUSH
78618: LD_VAR 0 13
78622: PPUSH
78623: LD_VAR 0 22
78627: PPUSH
78628: CALL_OW 308
78632: AND
78633: IFFALSE 78650
// ComExitVehicle ( group [ i ] ) ;
78635: LD_VAR 0 4
78639: PUSH
78640: LD_VAR 0 7
78644: ARRAY
78645: PPUSH
78646: CALL_OW 121
// end else
78650: GO 78829
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78652: LD_ADDR_VAR 0 13
78656: PUSH
78657: LD_VAR 0 4
78661: PPUSH
78662: LD_INT 95
78664: PUSH
78665: LD_VAR 0 22
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 58
78676: PUSH
78677: EMPTY
78678: LIST
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PPUSH
78684: CALL_OW 72
78688: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78689: LD_VAR 0 4
78693: PUSH
78694: LD_VAR 0 7
78698: ARRAY
78699: PPUSH
78700: CALL_OW 314
78704: NOT
78705: IFFALSE 78827
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78707: LD_ADDR_VAR 0 10
78711: PUSH
78712: LD_VAR 0 13
78716: PPUSH
78717: LD_VAR 0 4
78721: PUSH
78722: LD_VAR 0 7
78726: ARRAY
78727: PPUSH
78728: CALL_OW 74
78732: ST_TO_ADDR
// if not x then
78733: LD_VAR 0 10
78737: NOT
78738: IFFALSE 78742
// continue ;
78740: GO 78174
// if GetLives ( x ) < 1000 then
78742: LD_VAR 0 10
78746: PPUSH
78747: CALL_OW 256
78751: PUSH
78752: LD_INT 1000
78754: LESS
78755: IFFALSE 78779
// ComRepairVehicle ( group [ i ] , x ) else
78757: LD_VAR 0 4
78761: PUSH
78762: LD_VAR 0 7
78766: ARRAY
78767: PPUSH
78768: LD_VAR 0 10
78772: PPUSH
78773: CALL_OW 129
78777: GO 78827
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78779: LD_VAR 0 23
78783: PUSH
78784: LD_VAR 0 4
78788: PUSH
78789: LD_VAR 0 7
78793: ARRAY
78794: PPUSH
78795: CALL_OW 256
78799: PUSH
78800: LD_INT 1000
78802: LESS
78803: AND
78804: NOT
78805: IFFALSE 78827
// ComEnterUnit ( group [ i ] , x ) ;
78807: LD_VAR 0 4
78811: PUSH
78812: LD_VAR 0 7
78816: ARRAY
78817: PPUSH
78818: LD_VAR 0 10
78822: PPUSH
78823: CALL_OW 120
// end ; continue ;
78827: GO 78174
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78829: LD_VAR 0 23
78833: PUSH
78834: LD_VAR 0 4
78838: PUSH
78839: LD_VAR 0 7
78843: ARRAY
78844: PPUSH
78845: CALL_OW 247
78849: PUSH
78850: LD_INT 1
78852: EQUAL
78853: AND
78854: IFFALSE 79332
// begin if group [ i ] in healers then
78856: LD_VAR 0 4
78860: PUSH
78861: LD_VAR 0 7
78865: ARRAY
78866: PUSH
78867: LD_VAR 0 31
78871: IN
78872: IFFALSE 79145
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78874: LD_VAR 0 4
78878: PUSH
78879: LD_VAR 0 7
78883: ARRAY
78884: PPUSH
78885: LD_VAR 0 23
78889: PPUSH
78890: CALL_OW 308
78894: NOT
78895: PUSH
78896: LD_VAR 0 4
78900: PUSH
78901: LD_VAR 0 7
78905: ARRAY
78906: PPUSH
78907: CALL_OW 314
78911: NOT
78912: AND
78913: IFFALSE 78937
// ComMoveToArea ( group [ i ] , f_heal ) else
78915: LD_VAR 0 4
78919: PUSH
78920: LD_VAR 0 7
78924: ARRAY
78925: PPUSH
78926: LD_VAR 0 23
78930: PPUSH
78931: CALL_OW 113
78935: GO 79143
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78937: LD_VAR 0 4
78941: PUSH
78942: LD_VAR 0 7
78946: ARRAY
78947: PPUSH
78948: CALL 77575 0 1
78952: PPUSH
78953: CALL_OW 256
78957: PUSH
78958: LD_INT 1000
78960: EQUAL
78961: IFFALSE 78980
// ComStop ( group [ i ] ) else
78963: LD_VAR 0 4
78967: PUSH
78968: LD_VAR 0 7
78972: ARRAY
78973: PPUSH
78974: CALL_OW 141
78978: GO 79143
// if not HasTask ( group [ i ] ) and to_heal then
78980: LD_VAR 0 4
78984: PUSH
78985: LD_VAR 0 7
78989: ARRAY
78990: PPUSH
78991: CALL_OW 314
78995: NOT
78996: PUSH
78997: LD_VAR 0 30
79001: AND
79002: IFFALSE 79143
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
79004: LD_ADDR_VAR 0 13
79008: PUSH
79009: LD_VAR 0 30
79013: PPUSH
79014: LD_INT 3
79016: PUSH
79017: LD_INT 54
79019: PUSH
79020: EMPTY
79021: LIST
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PPUSH
79027: CALL_OW 72
79031: PPUSH
79032: LD_VAR 0 4
79036: PUSH
79037: LD_VAR 0 7
79041: ARRAY
79042: PPUSH
79043: CALL_OW 74
79047: ST_TO_ADDR
// if z then
79048: LD_VAR 0 13
79052: IFFALSE 79143
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
79054: LD_INT 91
79056: PUSH
79057: LD_VAR 0 13
79061: PUSH
79062: LD_INT 10
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 81
79072: PUSH
79073: LD_VAR 0 13
79077: PPUSH
79078: CALL_OW 255
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PPUSH
79091: CALL_OW 69
79095: PUSH
79096: LD_INT 0
79098: EQUAL
79099: IFFALSE 79123
// ComHeal ( group [ i ] , z ) else
79101: LD_VAR 0 4
79105: PUSH
79106: LD_VAR 0 7
79110: ARRAY
79111: PPUSH
79112: LD_VAR 0 13
79116: PPUSH
79117: CALL_OW 128
79121: GO 79143
// ComMoveToArea ( group [ i ] , f_heal ) ;
79123: LD_VAR 0 4
79127: PUSH
79128: LD_VAR 0 7
79132: ARRAY
79133: PPUSH
79134: LD_VAR 0 23
79138: PPUSH
79139: CALL_OW 113
// end ; continue ;
79143: GO 78174
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
79145: LD_VAR 0 4
79149: PUSH
79150: LD_VAR 0 7
79154: ARRAY
79155: PPUSH
79156: CALL_OW 256
79160: PUSH
79161: LD_INT 700
79163: LESS
79164: PUSH
79165: LD_VAR 0 4
79169: PUSH
79170: LD_VAR 0 7
79174: ARRAY
79175: PUSH
79176: LD_VAR 0 30
79180: IN
79181: NOT
79182: AND
79183: IFFALSE 79207
// to_heal := to_heal union group [ i ] ;
79185: LD_ADDR_VAR 0 30
79189: PUSH
79190: LD_VAR 0 30
79194: PUSH
79195: LD_VAR 0 4
79199: PUSH
79200: LD_VAR 0 7
79204: ARRAY
79205: UNION
79206: ST_TO_ADDR
// if group [ i ] in to_heal then
79207: LD_VAR 0 4
79211: PUSH
79212: LD_VAR 0 7
79216: ARRAY
79217: PUSH
79218: LD_VAR 0 30
79222: IN
79223: IFFALSE 79332
// begin if GetLives ( group [ i ] ) = 1000 then
79225: LD_VAR 0 4
79229: PUSH
79230: LD_VAR 0 7
79234: ARRAY
79235: PPUSH
79236: CALL_OW 256
79240: PUSH
79241: LD_INT 1000
79243: EQUAL
79244: IFFALSE 79270
// to_heal := to_heal diff group [ i ] else
79246: LD_ADDR_VAR 0 30
79250: PUSH
79251: LD_VAR 0 30
79255: PUSH
79256: LD_VAR 0 4
79260: PUSH
79261: LD_VAR 0 7
79265: ARRAY
79266: DIFF
79267: ST_TO_ADDR
79268: GO 79332
// begin if not IsInArea ( group [ i ] , to_heal ) then
79270: LD_VAR 0 4
79274: PUSH
79275: LD_VAR 0 7
79279: ARRAY
79280: PPUSH
79281: LD_VAR 0 30
79285: PPUSH
79286: CALL_OW 308
79290: NOT
79291: IFFALSE 79315
// ComMoveToArea ( group [ i ] , f_heal ) else
79293: LD_VAR 0 4
79297: PUSH
79298: LD_VAR 0 7
79302: ARRAY
79303: PPUSH
79304: LD_VAR 0 23
79308: PPUSH
79309: CALL_OW 113
79313: GO 79330
// ComHold ( group [ i ] ) ;
79315: LD_VAR 0 4
79319: PUSH
79320: LD_VAR 0 7
79324: ARRAY
79325: PPUSH
79326: CALL_OW 140
// continue ;
79330: GO 78174
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79332: LD_VAR 0 4
79336: PUSH
79337: LD_VAR 0 7
79341: ARRAY
79342: PPUSH
79343: LD_INT 10
79345: PPUSH
79346: CALL 75972 0 2
79350: NOT
79351: PUSH
79352: LD_VAR 0 16
79356: PUSH
79357: LD_VAR 0 7
79361: ARRAY
79362: PUSH
79363: EMPTY
79364: EQUAL
79365: NOT
79366: AND
79367: IFFALSE 79633
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79369: LD_VAR 0 4
79373: PUSH
79374: LD_VAR 0 7
79378: ARRAY
79379: PPUSH
79380: CALL_OW 262
79384: PUSH
79385: LD_INT 1
79387: PUSH
79388: LD_INT 2
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: IN
79395: IFFALSE 79436
// if GetFuel ( group [ i ] ) < 10 then
79397: LD_VAR 0 4
79401: PUSH
79402: LD_VAR 0 7
79406: ARRAY
79407: PPUSH
79408: CALL_OW 261
79412: PUSH
79413: LD_INT 10
79415: LESS
79416: IFFALSE 79436
// SetFuel ( group [ i ] , 12 ) ;
79418: LD_VAR 0 4
79422: PUSH
79423: LD_VAR 0 7
79427: ARRAY
79428: PPUSH
79429: LD_INT 12
79431: PPUSH
79432: CALL_OW 240
// if units_path [ i ] then
79436: LD_VAR 0 16
79440: PUSH
79441: LD_VAR 0 7
79445: ARRAY
79446: IFFALSE 79631
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79448: LD_VAR 0 4
79452: PUSH
79453: LD_VAR 0 7
79457: ARRAY
79458: PPUSH
79459: LD_VAR 0 16
79463: PUSH
79464: LD_VAR 0 7
79468: ARRAY
79469: PUSH
79470: LD_INT 1
79472: ARRAY
79473: PUSH
79474: LD_INT 1
79476: ARRAY
79477: PPUSH
79478: LD_VAR 0 16
79482: PUSH
79483: LD_VAR 0 7
79487: ARRAY
79488: PUSH
79489: LD_INT 1
79491: ARRAY
79492: PUSH
79493: LD_INT 2
79495: ARRAY
79496: PPUSH
79497: CALL_OW 297
79501: PUSH
79502: LD_INT 6
79504: GREATER
79505: IFFALSE 79580
// begin if not HasTask ( group [ i ] ) then
79507: LD_VAR 0 4
79511: PUSH
79512: LD_VAR 0 7
79516: ARRAY
79517: PPUSH
79518: CALL_OW 314
79522: NOT
79523: IFFALSE 79578
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79525: LD_VAR 0 4
79529: PUSH
79530: LD_VAR 0 7
79534: ARRAY
79535: PPUSH
79536: LD_VAR 0 16
79540: PUSH
79541: LD_VAR 0 7
79545: ARRAY
79546: PUSH
79547: LD_INT 1
79549: ARRAY
79550: PUSH
79551: LD_INT 1
79553: ARRAY
79554: PPUSH
79555: LD_VAR 0 16
79559: PUSH
79560: LD_VAR 0 7
79564: ARRAY
79565: PUSH
79566: LD_INT 1
79568: ARRAY
79569: PUSH
79570: LD_INT 2
79572: ARRAY
79573: PPUSH
79574: CALL_OW 114
// end else
79578: GO 79631
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79580: LD_ADDR_VAR 0 15
79584: PUSH
79585: LD_VAR 0 16
79589: PUSH
79590: LD_VAR 0 7
79594: ARRAY
79595: PPUSH
79596: LD_INT 1
79598: PPUSH
79599: CALL_OW 3
79603: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79604: LD_ADDR_VAR 0 16
79608: PUSH
79609: LD_VAR 0 16
79613: PPUSH
79614: LD_VAR 0 7
79618: PPUSH
79619: LD_VAR 0 15
79623: PPUSH
79624: CALL_OW 1
79628: ST_TO_ADDR
// continue ;
79629: GO 78174
// end ; end ; end else
79631: GO 82269
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79633: LD_ADDR_VAR 0 14
79637: PUSH
79638: LD_INT 81
79640: PUSH
79641: LD_VAR 0 4
79645: PUSH
79646: LD_VAR 0 7
79650: ARRAY
79651: PPUSH
79652: CALL_OW 255
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PPUSH
79661: CALL_OW 69
79665: ST_TO_ADDR
// if not tmp then
79666: LD_VAR 0 14
79670: NOT
79671: IFFALSE 79675
// continue ;
79673: GO 78174
// if f_ignore_area then
79675: LD_VAR 0 17
79679: IFFALSE 79767
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79681: LD_ADDR_VAR 0 15
79685: PUSH
79686: LD_VAR 0 14
79690: PPUSH
79691: LD_INT 3
79693: PUSH
79694: LD_INT 92
79696: PUSH
79697: LD_VAR 0 17
79701: PUSH
79702: LD_INT 1
79704: ARRAY
79705: PUSH
79706: LD_VAR 0 17
79710: PUSH
79711: LD_INT 2
79713: ARRAY
79714: PUSH
79715: LD_VAR 0 17
79719: PUSH
79720: LD_INT 3
79722: ARRAY
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PPUSH
79734: CALL_OW 72
79738: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79739: LD_VAR 0 14
79743: PUSH
79744: LD_VAR 0 15
79748: DIFF
79749: IFFALSE 79767
// tmp := tmp diff tmp2 ;
79751: LD_ADDR_VAR 0 14
79755: PUSH
79756: LD_VAR 0 14
79760: PUSH
79761: LD_VAR 0 15
79765: DIFF
79766: ST_TO_ADDR
// end ; if not f_murder then
79767: LD_VAR 0 20
79771: NOT
79772: IFFALSE 79830
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79774: LD_ADDR_VAR 0 15
79778: PUSH
79779: LD_VAR 0 14
79783: PPUSH
79784: LD_INT 3
79786: PUSH
79787: LD_INT 50
79789: PUSH
79790: EMPTY
79791: LIST
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PPUSH
79797: CALL_OW 72
79801: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79802: LD_VAR 0 14
79806: PUSH
79807: LD_VAR 0 15
79811: DIFF
79812: IFFALSE 79830
// tmp := tmp diff tmp2 ;
79814: LD_ADDR_VAR 0 14
79818: PUSH
79819: LD_VAR 0 14
79823: PUSH
79824: LD_VAR 0 15
79828: DIFF
79829: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79830: LD_ADDR_VAR 0 14
79834: PUSH
79835: LD_VAR 0 4
79839: PUSH
79840: LD_VAR 0 7
79844: ARRAY
79845: PPUSH
79846: LD_VAR 0 14
79850: PPUSH
79851: LD_INT 1
79853: PPUSH
79854: LD_INT 1
79856: PPUSH
79857: CALL 49639 0 4
79861: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79862: LD_VAR 0 4
79866: PUSH
79867: LD_VAR 0 7
79871: ARRAY
79872: PPUSH
79873: CALL_OW 257
79877: PUSH
79878: LD_INT 1
79880: EQUAL
79881: IFFALSE 80329
// begin if WantPlant ( group [ i ] ) then
79883: LD_VAR 0 4
79887: PUSH
79888: LD_VAR 0 7
79892: ARRAY
79893: PPUSH
79894: CALL 49140 0 1
79898: IFFALSE 79902
// continue ;
79900: GO 78174
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79902: LD_VAR 0 18
79906: PUSH
79907: LD_VAR 0 4
79911: PUSH
79912: LD_VAR 0 7
79916: ARRAY
79917: PPUSH
79918: CALL_OW 310
79922: NOT
79923: AND
79924: PUSH
79925: LD_VAR 0 14
79929: PUSH
79930: LD_INT 1
79932: ARRAY
79933: PUSH
79934: LD_VAR 0 14
79938: PPUSH
79939: LD_INT 21
79941: PUSH
79942: LD_INT 2
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 58
79951: PUSH
79952: EMPTY
79953: LIST
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PPUSH
79959: CALL_OW 72
79963: IN
79964: AND
79965: IFFALSE 80001
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79967: LD_VAR 0 4
79971: PUSH
79972: LD_VAR 0 7
79976: ARRAY
79977: PPUSH
79978: LD_VAR 0 14
79982: PUSH
79983: LD_INT 1
79985: ARRAY
79986: PPUSH
79987: CALL_OW 120
// attacking := true ;
79991: LD_ADDR_VAR 0 29
79995: PUSH
79996: LD_INT 1
79998: ST_TO_ADDR
// continue ;
79999: GO 78174
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
80001: LD_VAR 0 26
80005: PUSH
80006: LD_VAR 0 4
80010: PUSH
80011: LD_VAR 0 7
80015: ARRAY
80016: PPUSH
80017: CALL_OW 257
80021: PUSH
80022: LD_INT 1
80024: EQUAL
80025: AND
80026: PUSH
80027: LD_VAR 0 4
80031: PUSH
80032: LD_VAR 0 7
80036: ARRAY
80037: PPUSH
80038: CALL_OW 256
80042: PUSH
80043: LD_INT 800
80045: LESS
80046: AND
80047: PUSH
80048: LD_VAR 0 4
80052: PUSH
80053: LD_VAR 0 7
80057: ARRAY
80058: PPUSH
80059: CALL_OW 318
80063: NOT
80064: AND
80065: IFFALSE 80082
// ComCrawl ( group [ i ] ) ;
80067: LD_VAR 0 4
80071: PUSH
80072: LD_VAR 0 7
80076: ARRAY
80077: PPUSH
80078: CALL_OW 137
// if f_mines then
80082: LD_VAR 0 21
80086: IFFALSE 80329
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
80088: LD_VAR 0 14
80092: PUSH
80093: LD_INT 1
80095: ARRAY
80096: PPUSH
80097: CALL_OW 247
80101: PUSH
80102: LD_INT 3
80104: EQUAL
80105: PUSH
80106: LD_VAR 0 14
80110: PUSH
80111: LD_INT 1
80113: ARRAY
80114: PUSH
80115: LD_VAR 0 27
80119: IN
80120: NOT
80121: AND
80122: IFFALSE 80329
// begin x := GetX ( tmp [ 1 ] ) ;
80124: LD_ADDR_VAR 0 10
80128: PUSH
80129: LD_VAR 0 14
80133: PUSH
80134: LD_INT 1
80136: ARRAY
80137: PPUSH
80138: CALL_OW 250
80142: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
80143: LD_ADDR_VAR 0 11
80147: PUSH
80148: LD_VAR 0 14
80152: PUSH
80153: LD_INT 1
80155: ARRAY
80156: PPUSH
80157: CALL_OW 251
80161: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
80162: LD_ADDR_VAR 0 12
80166: PUSH
80167: LD_VAR 0 4
80171: PUSH
80172: LD_VAR 0 7
80176: ARRAY
80177: PPUSH
80178: CALL 76057 0 1
80182: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
80183: LD_VAR 0 4
80187: PUSH
80188: LD_VAR 0 7
80192: ARRAY
80193: PPUSH
80194: LD_VAR 0 10
80198: PPUSH
80199: LD_VAR 0 11
80203: PPUSH
80204: LD_VAR 0 14
80208: PUSH
80209: LD_INT 1
80211: ARRAY
80212: PPUSH
80213: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
80217: LD_VAR 0 4
80221: PUSH
80222: LD_VAR 0 7
80226: ARRAY
80227: PPUSH
80228: LD_VAR 0 10
80232: PPUSH
80233: LD_VAR 0 12
80237: PPUSH
80238: LD_INT 7
80240: PPUSH
80241: CALL_OW 272
80245: PPUSH
80246: LD_VAR 0 11
80250: PPUSH
80251: LD_VAR 0 12
80255: PPUSH
80256: LD_INT 7
80258: PPUSH
80259: CALL_OW 273
80263: PPUSH
80264: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
80268: LD_VAR 0 4
80272: PUSH
80273: LD_VAR 0 7
80277: ARRAY
80278: PPUSH
80279: LD_INT 71
80281: PPUSH
80282: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80286: LD_ADDR_VAR 0 27
80290: PUSH
80291: LD_VAR 0 27
80295: PPUSH
80296: LD_VAR 0 27
80300: PUSH
80301: LD_INT 1
80303: PLUS
80304: PPUSH
80305: LD_VAR 0 14
80309: PUSH
80310: LD_INT 1
80312: ARRAY
80313: PPUSH
80314: CALL_OW 1
80318: ST_TO_ADDR
// attacking := true ;
80319: LD_ADDR_VAR 0 29
80323: PUSH
80324: LD_INT 1
80326: ST_TO_ADDR
// continue ;
80327: GO 78174
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80329: LD_VAR 0 4
80333: PUSH
80334: LD_VAR 0 7
80338: ARRAY
80339: PPUSH
80340: CALL_OW 257
80344: PUSH
80345: LD_INT 17
80347: EQUAL
80348: PUSH
80349: LD_VAR 0 4
80353: PUSH
80354: LD_VAR 0 7
80358: ARRAY
80359: PPUSH
80360: CALL_OW 110
80364: PUSH
80365: LD_INT 71
80367: EQUAL
80368: NOT
80369: AND
80370: IFFALSE 80516
// begin attacking := false ;
80372: LD_ADDR_VAR 0 29
80376: PUSH
80377: LD_INT 0
80379: ST_TO_ADDR
// k := 5 ;
80380: LD_ADDR_VAR 0 9
80384: PUSH
80385: LD_INT 5
80387: ST_TO_ADDR
// if tmp < k then
80388: LD_VAR 0 14
80392: PUSH
80393: LD_VAR 0 9
80397: LESS
80398: IFFALSE 80410
// k := tmp ;
80400: LD_ADDR_VAR 0 9
80404: PUSH
80405: LD_VAR 0 14
80409: ST_TO_ADDR
// for j = 1 to k do
80410: LD_ADDR_VAR 0 8
80414: PUSH
80415: DOUBLE
80416: LD_INT 1
80418: DEC
80419: ST_TO_ADDR
80420: LD_VAR 0 9
80424: PUSH
80425: FOR_TO
80426: IFFALSE 80514
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80428: LD_VAR 0 14
80432: PUSH
80433: LD_VAR 0 8
80437: ARRAY
80438: PUSH
80439: LD_VAR 0 14
80443: PPUSH
80444: LD_INT 58
80446: PUSH
80447: EMPTY
80448: LIST
80449: PPUSH
80450: CALL_OW 72
80454: IN
80455: NOT
80456: IFFALSE 80512
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80458: LD_VAR 0 4
80462: PUSH
80463: LD_VAR 0 7
80467: ARRAY
80468: PPUSH
80469: LD_VAR 0 14
80473: PUSH
80474: LD_VAR 0 8
80478: ARRAY
80479: PPUSH
80480: CALL_OW 115
// attacking := true ;
80484: LD_ADDR_VAR 0 29
80488: PUSH
80489: LD_INT 1
80491: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80492: LD_VAR 0 4
80496: PUSH
80497: LD_VAR 0 7
80501: ARRAY
80502: PPUSH
80503: LD_INT 71
80505: PPUSH
80506: CALL_OW 109
// continue ;
80510: GO 80425
// end ; end ;
80512: GO 80425
80514: POP
80515: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80516: LD_VAR 0 4
80520: PUSH
80521: LD_VAR 0 7
80525: ARRAY
80526: PPUSH
80527: CALL_OW 257
80531: PUSH
80532: LD_INT 8
80534: EQUAL
80535: PUSH
80536: LD_VAR 0 4
80540: PUSH
80541: LD_VAR 0 7
80545: ARRAY
80546: PPUSH
80547: CALL_OW 264
80551: PUSH
80552: LD_INT 28
80554: PUSH
80555: LD_INT 45
80557: PUSH
80558: LD_INT 7
80560: PUSH
80561: LD_INT 47
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: IN
80570: OR
80571: IFFALSE 80801
// begin attacking := false ;
80573: LD_ADDR_VAR 0 29
80577: PUSH
80578: LD_INT 0
80580: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80581: LD_VAR 0 14
80585: PUSH
80586: LD_INT 1
80588: ARRAY
80589: PPUSH
80590: CALL_OW 266
80594: PUSH
80595: LD_INT 32
80597: PUSH
80598: LD_INT 31
80600: PUSH
80601: LD_INT 33
80603: PUSH
80604: LD_INT 4
80606: PUSH
80607: LD_INT 5
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: IN
80617: IFFALSE 80801
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80619: LD_ADDR_VAR 0 9
80623: PUSH
80624: LD_VAR 0 14
80628: PUSH
80629: LD_INT 1
80631: ARRAY
80632: PPUSH
80633: CALL_OW 266
80637: PPUSH
80638: LD_VAR 0 14
80642: PUSH
80643: LD_INT 1
80645: ARRAY
80646: PPUSH
80647: CALL_OW 250
80651: PPUSH
80652: LD_VAR 0 14
80656: PUSH
80657: LD_INT 1
80659: ARRAY
80660: PPUSH
80661: CALL_OW 251
80665: PPUSH
80666: LD_VAR 0 14
80670: PUSH
80671: LD_INT 1
80673: ARRAY
80674: PPUSH
80675: CALL_OW 254
80679: PPUSH
80680: LD_VAR 0 14
80684: PUSH
80685: LD_INT 1
80687: ARRAY
80688: PPUSH
80689: CALL_OW 248
80693: PPUSH
80694: LD_INT 0
80696: PPUSH
80697: CALL 57433 0 6
80701: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80702: LD_ADDR_VAR 0 8
80706: PUSH
80707: LD_VAR 0 4
80711: PUSH
80712: LD_VAR 0 7
80716: ARRAY
80717: PPUSH
80718: LD_VAR 0 9
80722: PPUSH
80723: CALL 76120 0 2
80727: ST_TO_ADDR
// if j then
80728: LD_VAR 0 8
80732: IFFALSE 80801
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80734: LD_VAR 0 8
80738: PUSH
80739: LD_INT 1
80741: ARRAY
80742: PPUSH
80743: LD_VAR 0 8
80747: PUSH
80748: LD_INT 2
80750: ARRAY
80751: PPUSH
80752: CALL_OW 488
80756: IFFALSE 80801
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80758: LD_VAR 0 4
80762: PUSH
80763: LD_VAR 0 7
80767: ARRAY
80768: PPUSH
80769: LD_VAR 0 8
80773: PUSH
80774: LD_INT 1
80776: ARRAY
80777: PPUSH
80778: LD_VAR 0 8
80782: PUSH
80783: LD_INT 2
80785: ARRAY
80786: PPUSH
80787: CALL_OW 116
// attacking := true ;
80791: LD_ADDR_VAR 0 29
80795: PUSH
80796: LD_INT 1
80798: ST_TO_ADDR
// continue ;
80799: GO 78174
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80801: LD_VAR 0 4
80805: PUSH
80806: LD_VAR 0 7
80810: ARRAY
80811: PPUSH
80812: CALL_OW 265
80816: PUSH
80817: LD_INT 11
80819: EQUAL
80820: IFFALSE 81098
// begin k := 10 ;
80822: LD_ADDR_VAR 0 9
80826: PUSH
80827: LD_INT 10
80829: ST_TO_ADDR
// x := 0 ;
80830: LD_ADDR_VAR 0 10
80834: PUSH
80835: LD_INT 0
80837: ST_TO_ADDR
// if tmp < k then
80838: LD_VAR 0 14
80842: PUSH
80843: LD_VAR 0 9
80847: LESS
80848: IFFALSE 80860
// k := tmp ;
80850: LD_ADDR_VAR 0 9
80854: PUSH
80855: LD_VAR 0 14
80859: ST_TO_ADDR
// for j = k downto 1 do
80860: LD_ADDR_VAR 0 8
80864: PUSH
80865: DOUBLE
80866: LD_VAR 0 9
80870: INC
80871: ST_TO_ADDR
80872: LD_INT 1
80874: PUSH
80875: FOR_DOWNTO
80876: IFFALSE 80951
// begin if GetType ( tmp [ j ] ) = unit_human then
80878: LD_VAR 0 14
80882: PUSH
80883: LD_VAR 0 8
80887: ARRAY
80888: PPUSH
80889: CALL_OW 247
80893: PUSH
80894: LD_INT 1
80896: EQUAL
80897: IFFALSE 80949
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80899: LD_VAR 0 4
80903: PUSH
80904: LD_VAR 0 7
80908: ARRAY
80909: PPUSH
80910: LD_VAR 0 14
80914: PUSH
80915: LD_VAR 0 8
80919: ARRAY
80920: PPUSH
80921: CALL 76391 0 2
// x := tmp [ j ] ;
80925: LD_ADDR_VAR 0 10
80929: PUSH
80930: LD_VAR 0 14
80934: PUSH
80935: LD_VAR 0 8
80939: ARRAY
80940: ST_TO_ADDR
// attacking := true ;
80941: LD_ADDR_VAR 0 29
80945: PUSH
80946: LD_INT 1
80948: ST_TO_ADDR
// end ; end ;
80949: GO 80875
80951: POP
80952: POP
// if not x then
80953: LD_VAR 0 10
80957: NOT
80958: IFFALSE 81098
// begin attacking := true ;
80960: LD_ADDR_VAR 0 29
80964: PUSH
80965: LD_INT 1
80967: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80968: LD_VAR 0 4
80972: PUSH
80973: LD_VAR 0 7
80977: ARRAY
80978: PPUSH
80979: CALL_OW 250
80983: PPUSH
80984: LD_VAR 0 4
80988: PUSH
80989: LD_VAR 0 7
80993: ARRAY
80994: PPUSH
80995: CALL_OW 251
80999: PPUSH
81000: CALL_OW 546
81004: PUSH
81005: LD_INT 2
81007: ARRAY
81008: PUSH
81009: LD_VAR 0 14
81013: PUSH
81014: LD_INT 1
81016: ARRAY
81017: PPUSH
81018: CALL_OW 250
81022: PPUSH
81023: LD_VAR 0 14
81027: PUSH
81028: LD_INT 1
81030: ARRAY
81031: PPUSH
81032: CALL_OW 251
81036: PPUSH
81037: CALL_OW 546
81041: PUSH
81042: LD_INT 2
81044: ARRAY
81045: EQUAL
81046: IFFALSE 81074
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
81048: LD_VAR 0 4
81052: PUSH
81053: LD_VAR 0 7
81057: ARRAY
81058: PPUSH
81059: LD_VAR 0 14
81063: PUSH
81064: LD_INT 1
81066: ARRAY
81067: PPUSH
81068: CALL 76391 0 2
81072: GO 81098
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81074: LD_VAR 0 4
81078: PUSH
81079: LD_VAR 0 7
81083: ARRAY
81084: PPUSH
81085: LD_VAR 0 14
81089: PUSH
81090: LD_INT 1
81092: ARRAY
81093: PPUSH
81094: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
81098: LD_VAR 0 4
81102: PUSH
81103: LD_VAR 0 7
81107: ARRAY
81108: PPUSH
81109: CALL_OW 264
81113: PUSH
81114: LD_INT 29
81116: EQUAL
81117: IFFALSE 81483
// begin if WantsToAttack ( group [ i ] ) in bombed then
81119: LD_VAR 0 4
81123: PUSH
81124: LD_VAR 0 7
81128: ARRAY
81129: PPUSH
81130: CALL_OW 319
81134: PUSH
81135: LD_VAR 0 28
81139: IN
81140: IFFALSE 81144
// continue ;
81142: GO 78174
// k := 8 ;
81144: LD_ADDR_VAR 0 9
81148: PUSH
81149: LD_INT 8
81151: ST_TO_ADDR
// x := 0 ;
81152: LD_ADDR_VAR 0 10
81156: PUSH
81157: LD_INT 0
81159: ST_TO_ADDR
// if tmp < k then
81160: LD_VAR 0 14
81164: PUSH
81165: LD_VAR 0 9
81169: LESS
81170: IFFALSE 81182
// k := tmp ;
81172: LD_ADDR_VAR 0 9
81176: PUSH
81177: LD_VAR 0 14
81181: ST_TO_ADDR
// for j = 1 to k do
81182: LD_ADDR_VAR 0 8
81186: PUSH
81187: DOUBLE
81188: LD_INT 1
81190: DEC
81191: ST_TO_ADDR
81192: LD_VAR 0 9
81196: PUSH
81197: FOR_TO
81198: IFFALSE 81330
// begin if GetType ( tmp [ j ] ) = unit_building then
81200: LD_VAR 0 14
81204: PUSH
81205: LD_VAR 0 8
81209: ARRAY
81210: PPUSH
81211: CALL_OW 247
81215: PUSH
81216: LD_INT 3
81218: EQUAL
81219: IFFALSE 81328
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
81221: LD_VAR 0 14
81225: PUSH
81226: LD_VAR 0 8
81230: ARRAY
81231: PUSH
81232: LD_VAR 0 28
81236: IN
81237: NOT
81238: PUSH
81239: LD_VAR 0 14
81243: PUSH
81244: LD_VAR 0 8
81248: ARRAY
81249: PPUSH
81250: CALL_OW 313
81254: AND
81255: IFFALSE 81328
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81257: LD_VAR 0 4
81261: PUSH
81262: LD_VAR 0 7
81266: ARRAY
81267: PPUSH
81268: LD_VAR 0 14
81272: PUSH
81273: LD_VAR 0 8
81277: ARRAY
81278: PPUSH
81279: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81283: LD_ADDR_VAR 0 28
81287: PUSH
81288: LD_VAR 0 28
81292: PPUSH
81293: LD_VAR 0 28
81297: PUSH
81298: LD_INT 1
81300: PLUS
81301: PPUSH
81302: LD_VAR 0 14
81306: PUSH
81307: LD_VAR 0 8
81311: ARRAY
81312: PPUSH
81313: CALL_OW 1
81317: ST_TO_ADDR
// attacking := true ;
81318: LD_ADDR_VAR 0 29
81322: PUSH
81323: LD_INT 1
81325: ST_TO_ADDR
// break ;
81326: GO 81330
// end ; end ;
81328: GO 81197
81330: POP
81331: POP
// if not attacking and f_attack_depot then
81332: LD_VAR 0 29
81336: NOT
81337: PUSH
81338: LD_VAR 0 25
81342: AND
81343: IFFALSE 81438
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81345: LD_ADDR_VAR 0 13
81349: PUSH
81350: LD_VAR 0 14
81354: PPUSH
81355: LD_INT 2
81357: PUSH
81358: LD_INT 30
81360: PUSH
81361: LD_INT 0
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 30
81370: PUSH
81371: LD_INT 1
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: LIST
81382: PPUSH
81383: CALL_OW 72
81387: ST_TO_ADDR
// if z then
81388: LD_VAR 0 13
81392: IFFALSE 81438
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81394: LD_VAR 0 4
81398: PUSH
81399: LD_VAR 0 7
81403: ARRAY
81404: PPUSH
81405: LD_VAR 0 13
81409: PPUSH
81410: LD_VAR 0 4
81414: PUSH
81415: LD_VAR 0 7
81419: ARRAY
81420: PPUSH
81421: CALL_OW 74
81425: PPUSH
81426: CALL_OW 115
// attacking := true ;
81430: LD_ADDR_VAR 0 29
81434: PUSH
81435: LD_INT 1
81437: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81438: LD_VAR 0 4
81442: PUSH
81443: LD_VAR 0 7
81447: ARRAY
81448: PPUSH
81449: CALL_OW 256
81453: PUSH
81454: LD_INT 500
81456: LESS
81457: IFFALSE 81483
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81459: LD_VAR 0 4
81463: PUSH
81464: LD_VAR 0 7
81468: ARRAY
81469: PPUSH
81470: LD_VAR 0 14
81474: PUSH
81475: LD_INT 1
81477: ARRAY
81478: PPUSH
81479: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81483: LD_VAR 0 4
81487: PUSH
81488: LD_VAR 0 7
81492: ARRAY
81493: PPUSH
81494: CALL_OW 264
81498: PUSH
81499: LD_INT 49
81501: EQUAL
81502: IFFALSE 81623
// begin if not HasTask ( group [ i ] ) then
81504: LD_VAR 0 4
81508: PUSH
81509: LD_VAR 0 7
81513: ARRAY
81514: PPUSH
81515: CALL_OW 314
81519: NOT
81520: IFFALSE 81623
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81522: LD_ADDR_VAR 0 9
81526: PUSH
81527: LD_INT 81
81529: PUSH
81530: LD_VAR 0 4
81534: PUSH
81535: LD_VAR 0 7
81539: ARRAY
81540: PPUSH
81541: CALL_OW 255
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PPUSH
81550: CALL_OW 69
81554: PPUSH
81555: LD_VAR 0 4
81559: PUSH
81560: LD_VAR 0 7
81564: ARRAY
81565: PPUSH
81566: CALL_OW 74
81570: ST_TO_ADDR
// if k then
81571: LD_VAR 0 9
81575: IFFALSE 81623
// if GetDistUnits ( group [ i ] , k ) > 10 then
81577: LD_VAR 0 4
81581: PUSH
81582: LD_VAR 0 7
81586: ARRAY
81587: PPUSH
81588: LD_VAR 0 9
81592: PPUSH
81593: CALL_OW 296
81597: PUSH
81598: LD_INT 10
81600: GREATER
81601: IFFALSE 81623
// ComMoveUnit ( group [ i ] , k ) ;
81603: LD_VAR 0 4
81607: PUSH
81608: LD_VAR 0 7
81612: ARRAY
81613: PPUSH
81614: LD_VAR 0 9
81618: PPUSH
81619: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81623: LD_VAR 0 4
81627: PUSH
81628: LD_VAR 0 7
81632: ARRAY
81633: PPUSH
81634: CALL_OW 256
81638: PUSH
81639: LD_INT 250
81641: LESS
81642: PUSH
81643: LD_VAR 0 4
81647: PUSH
81648: LD_VAR 0 7
81652: ARRAY
81653: PUSH
81654: LD_INT 21
81656: PUSH
81657: LD_INT 2
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 23
81666: PUSH
81667: LD_INT 2
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PPUSH
81678: CALL_OW 69
81682: IN
81683: AND
81684: IFFALSE 81809
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81686: LD_ADDR_VAR 0 9
81690: PUSH
81691: LD_OWVAR 3
81695: PUSH
81696: LD_VAR 0 4
81700: PUSH
81701: LD_VAR 0 7
81705: ARRAY
81706: DIFF
81707: PPUSH
81708: LD_VAR 0 4
81712: PUSH
81713: LD_VAR 0 7
81717: ARRAY
81718: PPUSH
81719: CALL_OW 74
81723: ST_TO_ADDR
// if not k then
81724: LD_VAR 0 9
81728: NOT
81729: IFFALSE 81733
// continue ;
81731: GO 78174
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81733: LD_VAR 0 9
81737: PUSH
81738: LD_INT 81
81740: PUSH
81741: LD_VAR 0 4
81745: PUSH
81746: LD_VAR 0 7
81750: ARRAY
81751: PPUSH
81752: CALL_OW 255
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PPUSH
81761: CALL_OW 69
81765: IN
81766: PUSH
81767: LD_VAR 0 9
81771: PPUSH
81772: LD_VAR 0 4
81776: PUSH
81777: LD_VAR 0 7
81781: ARRAY
81782: PPUSH
81783: CALL_OW 296
81787: PUSH
81788: LD_INT 5
81790: LESS
81791: AND
81792: IFFALSE 81809
// ComAutodestruct ( group [ i ] ) ;
81794: LD_VAR 0 4
81798: PUSH
81799: LD_VAR 0 7
81803: ARRAY
81804: PPUSH
81805: CALL 76289 0 1
// end ; if f_attack_depot then
81809: LD_VAR 0 25
81813: IFFALSE 81925
// begin k := 6 ;
81815: LD_ADDR_VAR 0 9
81819: PUSH
81820: LD_INT 6
81822: ST_TO_ADDR
// if tmp < k then
81823: LD_VAR 0 14
81827: PUSH
81828: LD_VAR 0 9
81832: LESS
81833: IFFALSE 81845
// k := tmp ;
81835: LD_ADDR_VAR 0 9
81839: PUSH
81840: LD_VAR 0 14
81844: ST_TO_ADDR
// for j = 1 to k do
81845: LD_ADDR_VAR 0 8
81849: PUSH
81850: DOUBLE
81851: LD_INT 1
81853: DEC
81854: ST_TO_ADDR
81855: LD_VAR 0 9
81859: PUSH
81860: FOR_TO
81861: IFFALSE 81923
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81863: LD_VAR 0 8
81867: PPUSH
81868: CALL_OW 266
81872: PUSH
81873: LD_INT 0
81875: PUSH
81876: LD_INT 1
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: IN
81883: IFFALSE 81921
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81885: LD_VAR 0 4
81889: PUSH
81890: LD_VAR 0 7
81894: ARRAY
81895: PPUSH
81896: LD_VAR 0 14
81900: PUSH
81901: LD_VAR 0 8
81905: ARRAY
81906: PPUSH
81907: CALL_OW 115
// attacking := true ;
81911: LD_ADDR_VAR 0 29
81915: PUSH
81916: LD_INT 1
81918: ST_TO_ADDR
// break ;
81919: GO 81923
// end ;
81921: GO 81860
81923: POP
81924: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81925: LD_VAR 0 4
81929: PUSH
81930: LD_VAR 0 7
81934: ARRAY
81935: PPUSH
81936: CALL_OW 302
81940: PUSH
81941: LD_VAR 0 29
81945: NOT
81946: AND
81947: IFFALSE 82269
// begin if GetTag ( group [ i ] ) = 71 then
81949: LD_VAR 0 4
81953: PUSH
81954: LD_VAR 0 7
81958: ARRAY
81959: PPUSH
81960: CALL_OW 110
81964: PUSH
81965: LD_INT 71
81967: EQUAL
81968: IFFALSE 82009
// begin if HasTask ( group [ i ] ) then
81970: LD_VAR 0 4
81974: PUSH
81975: LD_VAR 0 7
81979: ARRAY
81980: PPUSH
81981: CALL_OW 314
81985: IFFALSE 81991
// continue else
81987: GO 78174
81989: GO 82009
// SetTag ( group [ i ] , 0 ) ;
81991: LD_VAR 0 4
81995: PUSH
81996: LD_VAR 0 7
82000: ARRAY
82001: PPUSH
82002: LD_INT 0
82004: PPUSH
82005: CALL_OW 109
// end ; k := 8 ;
82009: LD_ADDR_VAR 0 9
82013: PUSH
82014: LD_INT 8
82016: ST_TO_ADDR
// x := 0 ;
82017: LD_ADDR_VAR 0 10
82021: PUSH
82022: LD_INT 0
82024: ST_TO_ADDR
// if tmp < k then
82025: LD_VAR 0 14
82029: PUSH
82030: LD_VAR 0 9
82034: LESS
82035: IFFALSE 82047
// k := tmp ;
82037: LD_ADDR_VAR 0 9
82041: PUSH
82042: LD_VAR 0 14
82046: ST_TO_ADDR
// for j = 1 to k do
82047: LD_ADDR_VAR 0 8
82051: PUSH
82052: DOUBLE
82053: LD_INT 1
82055: DEC
82056: ST_TO_ADDR
82057: LD_VAR 0 9
82061: PUSH
82062: FOR_TO
82063: IFFALSE 82161
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
82065: LD_VAR 0 14
82069: PUSH
82070: LD_VAR 0 8
82074: ARRAY
82075: PPUSH
82076: CALL_OW 247
82080: PUSH
82081: LD_INT 1
82083: EQUAL
82084: PUSH
82085: LD_VAR 0 14
82089: PUSH
82090: LD_VAR 0 8
82094: ARRAY
82095: PPUSH
82096: CALL_OW 256
82100: PUSH
82101: LD_INT 250
82103: LESS
82104: PUSH
82105: LD_VAR 0 20
82109: AND
82110: PUSH
82111: LD_VAR 0 20
82115: NOT
82116: PUSH
82117: LD_VAR 0 14
82121: PUSH
82122: LD_VAR 0 8
82126: ARRAY
82127: PPUSH
82128: CALL_OW 256
82132: PUSH
82133: LD_INT 250
82135: GREATEREQUAL
82136: AND
82137: OR
82138: AND
82139: IFFALSE 82159
// begin x := tmp [ j ] ;
82141: LD_ADDR_VAR 0 10
82145: PUSH
82146: LD_VAR 0 14
82150: PUSH
82151: LD_VAR 0 8
82155: ARRAY
82156: ST_TO_ADDR
// break ;
82157: GO 82161
// end ;
82159: GO 82062
82161: POP
82162: POP
// if x then
82163: LD_VAR 0 10
82167: IFFALSE 82191
// ComAttackUnit ( group [ i ] , x ) else
82169: LD_VAR 0 4
82173: PUSH
82174: LD_VAR 0 7
82178: ARRAY
82179: PPUSH
82180: LD_VAR 0 10
82184: PPUSH
82185: CALL_OW 115
82189: GO 82215
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82191: LD_VAR 0 4
82195: PUSH
82196: LD_VAR 0 7
82200: ARRAY
82201: PPUSH
82202: LD_VAR 0 14
82206: PUSH
82207: LD_INT 1
82209: ARRAY
82210: PPUSH
82211: CALL_OW 115
// if not HasTask ( group [ i ] ) then
82215: LD_VAR 0 4
82219: PUSH
82220: LD_VAR 0 7
82224: ARRAY
82225: PPUSH
82226: CALL_OW 314
82230: NOT
82231: IFFALSE 82269
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
82233: LD_VAR 0 4
82237: PUSH
82238: LD_VAR 0 7
82242: ARRAY
82243: PPUSH
82244: LD_VAR 0 14
82248: PPUSH
82249: LD_VAR 0 4
82253: PUSH
82254: LD_VAR 0 7
82258: ARRAY
82259: PPUSH
82260: CALL_OW 74
82264: PPUSH
82265: CALL_OW 115
// end ; end ; end ;
82269: GO 78174
82271: POP
82272: POP
// wait ( 0 0$1 ) ;
82273: LD_INT 35
82275: PPUSH
82276: CALL_OW 67
// until group = [ ] ;
82280: LD_VAR 0 4
82284: PUSH
82285: EMPTY
82286: EQUAL
82287: IFFALSE 78159
// end ;
82289: LD_VAR 0 2
82293: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82294: LD_INT 0
82296: PPUSH
82297: PPUSH
82298: PPUSH
82299: PPUSH
// if not base_units then
82300: LD_VAR 0 1
82304: NOT
82305: IFFALSE 82309
// exit ;
82307: GO 82396
// result := false ;
82309: LD_ADDR_VAR 0 2
82313: PUSH
82314: LD_INT 0
82316: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82317: LD_ADDR_VAR 0 5
82321: PUSH
82322: LD_VAR 0 1
82326: PPUSH
82327: LD_INT 21
82329: PUSH
82330: LD_INT 3
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PPUSH
82337: CALL_OW 72
82341: ST_TO_ADDR
// if not tmp then
82342: LD_VAR 0 5
82346: NOT
82347: IFFALSE 82351
// exit ;
82349: GO 82396
// for i in tmp do
82351: LD_ADDR_VAR 0 3
82355: PUSH
82356: LD_VAR 0 5
82360: PUSH
82361: FOR_IN
82362: IFFALSE 82394
// begin result := EnemyInRange ( i , 22 ) ;
82364: LD_ADDR_VAR 0 2
82368: PUSH
82369: LD_VAR 0 3
82373: PPUSH
82374: LD_INT 22
82376: PPUSH
82377: CALL 75972 0 2
82381: ST_TO_ADDR
// if result then
82382: LD_VAR 0 2
82386: IFFALSE 82392
// exit ;
82388: POP
82389: POP
82390: GO 82396
// end ;
82392: GO 82361
82394: POP
82395: POP
// end ;
82396: LD_VAR 0 2
82400: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
82401: LD_INT 0
82403: PPUSH
82404: PPUSH
// if not units then
82405: LD_VAR 0 1
82409: NOT
82410: IFFALSE 82414
// exit ;
82412: GO 82484
// result := [ ] ;
82414: LD_ADDR_VAR 0 3
82418: PUSH
82419: EMPTY
82420: ST_TO_ADDR
// for i in units do
82421: LD_ADDR_VAR 0 4
82425: PUSH
82426: LD_VAR 0 1
82430: PUSH
82431: FOR_IN
82432: IFFALSE 82482
// if GetTag ( i ) = tag then
82434: LD_VAR 0 4
82438: PPUSH
82439: CALL_OW 110
82443: PUSH
82444: LD_VAR 0 2
82448: EQUAL
82449: IFFALSE 82480
// result := Insert ( result , result + 1 , i ) ;
82451: LD_ADDR_VAR 0 3
82455: PUSH
82456: LD_VAR 0 3
82460: PPUSH
82461: LD_VAR 0 3
82465: PUSH
82466: LD_INT 1
82468: PLUS
82469: PPUSH
82470: LD_VAR 0 4
82474: PPUSH
82475: CALL_OW 2
82479: ST_TO_ADDR
82480: GO 82431
82482: POP
82483: POP
// end ;
82484: LD_VAR 0 3
82488: RET
// export function IsDriver ( un ) ; begin
82489: LD_INT 0
82491: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82492: LD_ADDR_VAR 0 2
82496: PUSH
82497: LD_VAR 0 1
82501: PUSH
82502: LD_INT 55
82504: PUSH
82505: EMPTY
82506: LIST
82507: PPUSH
82508: CALL_OW 69
82512: IN
82513: ST_TO_ADDR
// end ;
82514: LD_VAR 0 2
82518: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82519: LD_INT 0
82521: PPUSH
82522: PPUSH
// list := [ ] ;
82523: LD_ADDR_VAR 0 5
82527: PUSH
82528: EMPTY
82529: ST_TO_ADDR
// case d of 0 :
82530: LD_VAR 0 3
82534: PUSH
82535: LD_INT 0
82537: DOUBLE
82538: EQUAL
82539: IFTRUE 82543
82541: GO 82676
82543: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82544: LD_ADDR_VAR 0 5
82548: PUSH
82549: LD_VAR 0 1
82553: PUSH
82554: LD_INT 4
82556: MINUS
82557: PUSH
82558: LD_VAR 0 2
82562: PUSH
82563: LD_INT 4
82565: MINUS
82566: PUSH
82567: LD_INT 2
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: LIST
82574: PUSH
82575: LD_VAR 0 1
82579: PUSH
82580: LD_INT 3
82582: MINUS
82583: PUSH
82584: LD_VAR 0 2
82588: PUSH
82589: LD_INT 1
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: LIST
82596: PUSH
82597: LD_VAR 0 1
82601: PUSH
82602: LD_INT 4
82604: PLUS
82605: PUSH
82606: LD_VAR 0 2
82610: PUSH
82611: LD_INT 4
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: LIST
82618: PUSH
82619: LD_VAR 0 1
82623: PUSH
82624: LD_INT 3
82626: PLUS
82627: PUSH
82628: LD_VAR 0 2
82632: PUSH
82633: LD_INT 3
82635: PLUS
82636: PUSH
82637: LD_INT 5
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: LIST
82644: PUSH
82645: LD_VAR 0 1
82649: PUSH
82650: LD_VAR 0 2
82654: PUSH
82655: LD_INT 4
82657: PLUS
82658: PUSH
82659: LD_INT 0
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: LIST
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: ST_TO_ADDR
// end ; 1 :
82674: GO 83374
82676: LD_INT 1
82678: DOUBLE
82679: EQUAL
82680: IFTRUE 82684
82682: GO 82817
82684: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
82685: LD_ADDR_VAR 0 5
82689: PUSH
82690: LD_VAR 0 1
82694: PUSH
82695: LD_VAR 0 2
82699: PUSH
82700: LD_INT 4
82702: MINUS
82703: PUSH
82704: LD_INT 3
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: LIST
82711: PUSH
82712: LD_VAR 0 1
82716: PUSH
82717: LD_INT 3
82719: MINUS
82720: PUSH
82721: LD_VAR 0 2
82725: PUSH
82726: LD_INT 3
82728: MINUS
82729: PUSH
82730: LD_INT 2
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: LIST
82737: PUSH
82738: LD_VAR 0 1
82742: PUSH
82743: LD_INT 4
82745: MINUS
82746: PUSH
82747: LD_VAR 0 2
82751: PUSH
82752: LD_INT 1
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: LIST
82759: PUSH
82760: LD_VAR 0 1
82764: PUSH
82765: LD_VAR 0 2
82769: PUSH
82770: LD_INT 3
82772: PLUS
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: LIST
82781: PUSH
82782: LD_VAR 0 1
82786: PUSH
82787: LD_INT 4
82789: PLUS
82790: PUSH
82791: LD_VAR 0 2
82795: PUSH
82796: LD_INT 4
82798: PLUS
82799: PUSH
82800: LD_INT 5
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: LIST
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: ST_TO_ADDR
// end ; 2 :
82815: GO 83374
82817: LD_INT 2
82819: DOUBLE
82820: EQUAL
82821: IFTRUE 82825
82823: GO 82954
82825: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
82826: LD_ADDR_VAR 0 5
82830: PUSH
82831: LD_VAR 0 1
82835: PUSH
82836: LD_VAR 0 2
82840: PUSH
82841: LD_INT 3
82843: MINUS
82844: PUSH
82845: LD_INT 3
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: LIST
82852: PUSH
82853: LD_VAR 0 1
82857: PUSH
82858: LD_INT 4
82860: PLUS
82861: PUSH
82862: LD_VAR 0 2
82866: PUSH
82867: LD_INT 4
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: LIST
82874: PUSH
82875: LD_VAR 0 1
82879: PUSH
82880: LD_VAR 0 2
82884: PUSH
82885: LD_INT 4
82887: PLUS
82888: PUSH
82889: LD_INT 0
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: LIST
82896: PUSH
82897: LD_VAR 0 1
82901: PUSH
82902: LD_INT 3
82904: MINUS
82905: PUSH
82906: LD_VAR 0 2
82910: PUSH
82911: LD_INT 1
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: LIST
82918: PUSH
82919: LD_VAR 0 1
82923: PUSH
82924: LD_INT 4
82926: MINUS
82927: PUSH
82928: LD_VAR 0 2
82932: PUSH
82933: LD_INT 4
82935: MINUS
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: LIST
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: ST_TO_ADDR
// end ; 3 :
82952: GO 83374
82954: LD_INT 3
82956: DOUBLE
82957: EQUAL
82958: IFTRUE 82962
82960: GO 83095
82962: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
82963: LD_ADDR_VAR 0 5
82967: PUSH
82968: LD_VAR 0 1
82972: PUSH
82973: LD_INT 3
82975: PLUS
82976: PUSH
82977: LD_VAR 0 2
82981: PUSH
82982: LD_INT 4
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: LIST
82989: PUSH
82990: LD_VAR 0 1
82994: PUSH
82995: LD_INT 4
82997: PLUS
82998: PUSH
82999: LD_VAR 0 2
83003: PUSH
83004: LD_INT 4
83006: PLUS
83007: PUSH
83008: LD_INT 5
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: LIST
83015: PUSH
83016: LD_VAR 0 1
83020: PUSH
83021: LD_INT 4
83023: MINUS
83024: PUSH
83025: LD_VAR 0 2
83029: PUSH
83030: LD_INT 1
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: LIST
83037: PUSH
83038: LD_VAR 0 1
83042: PUSH
83043: LD_VAR 0 2
83047: PUSH
83048: LD_INT 4
83050: MINUS
83051: PUSH
83052: LD_INT 3
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: LIST
83059: PUSH
83060: LD_VAR 0 1
83064: PUSH
83065: LD_INT 3
83067: MINUS
83068: PUSH
83069: LD_VAR 0 2
83073: PUSH
83074: LD_INT 3
83076: MINUS
83077: PUSH
83078: LD_INT 2
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: LIST
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: ST_TO_ADDR
// end ; 4 :
83093: GO 83374
83095: LD_INT 4
83097: DOUBLE
83098: EQUAL
83099: IFTRUE 83103
83101: GO 83236
83103: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83104: LD_ADDR_VAR 0 5
83108: PUSH
83109: LD_VAR 0 1
83113: PUSH
83114: LD_VAR 0 2
83118: PUSH
83119: LD_INT 4
83121: PLUS
83122: PUSH
83123: LD_INT 0
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: LIST
83130: PUSH
83131: LD_VAR 0 1
83135: PUSH
83136: LD_INT 3
83138: PLUS
83139: PUSH
83140: LD_VAR 0 2
83144: PUSH
83145: LD_INT 3
83147: PLUS
83148: PUSH
83149: LD_INT 5
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: LIST
83156: PUSH
83157: LD_VAR 0 1
83161: PUSH
83162: LD_INT 4
83164: PLUS
83165: PUSH
83166: LD_VAR 0 2
83170: PUSH
83171: LD_INT 4
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: LIST
83178: PUSH
83179: LD_VAR 0 1
83183: PUSH
83184: LD_VAR 0 2
83188: PUSH
83189: LD_INT 3
83191: MINUS
83192: PUSH
83193: LD_INT 3
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: LIST
83200: PUSH
83201: LD_VAR 0 1
83205: PUSH
83206: LD_INT 4
83208: MINUS
83209: PUSH
83210: LD_VAR 0 2
83214: PUSH
83215: LD_INT 4
83217: MINUS
83218: PUSH
83219: LD_INT 2
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: LIST
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: ST_TO_ADDR
// end ; 5 :
83234: GO 83374
83236: LD_INT 5
83238: DOUBLE
83239: EQUAL
83240: IFTRUE 83244
83242: GO 83373
83244: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83245: LD_ADDR_VAR 0 5
83249: PUSH
83250: LD_VAR 0 1
83254: PUSH
83255: LD_INT 4
83257: MINUS
83258: PUSH
83259: LD_VAR 0 2
83263: PUSH
83264: LD_INT 1
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: LIST
83271: PUSH
83272: LD_VAR 0 1
83276: PUSH
83277: LD_VAR 0 2
83281: PUSH
83282: LD_INT 4
83284: MINUS
83285: PUSH
83286: LD_INT 3
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: LIST
83293: PUSH
83294: LD_VAR 0 1
83298: PUSH
83299: LD_INT 4
83301: PLUS
83302: PUSH
83303: LD_VAR 0 2
83307: PUSH
83308: LD_INT 4
83310: PLUS
83311: PUSH
83312: LD_INT 5
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: LIST
83319: PUSH
83320: LD_VAR 0 1
83324: PUSH
83325: LD_INT 3
83327: PLUS
83328: PUSH
83329: LD_VAR 0 2
83333: PUSH
83334: LD_INT 4
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: LIST
83341: PUSH
83342: LD_VAR 0 1
83346: PUSH
83347: LD_VAR 0 2
83351: PUSH
83352: LD_INT 3
83354: PLUS
83355: PUSH
83356: LD_INT 0
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: LIST
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: ST_TO_ADDR
// end ; end ;
83371: GO 83374
83373: POP
// result := list ;
83374: LD_ADDR_VAR 0 4
83378: PUSH
83379: LD_VAR 0 5
83383: ST_TO_ADDR
// end ;
83384: LD_VAR 0 4
83388: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83389: LD_INT 0
83391: PPUSH
83392: PPUSH
83393: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83394: LD_VAR 0 1
83398: NOT
83399: PUSH
83400: LD_VAR 0 2
83404: PUSH
83405: LD_INT 1
83407: PUSH
83408: LD_INT 2
83410: PUSH
83411: LD_INT 3
83413: PUSH
83414: LD_INT 4
83416: PUSH
83417: EMPTY
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: IN
83423: NOT
83424: OR
83425: IFFALSE 83429
// exit ;
83427: GO 83521
// tmp := [ ] ;
83429: LD_ADDR_VAR 0 5
83433: PUSH
83434: EMPTY
83435: ST_TO_ADDR
// for i in units do
83436: LD_ADDR_VAR 0 4
83440: PUSH
83441: LD_VAR 0 1
83445: PUSH
83446: FOR_IN
83447: IFFALSE 83490
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83449: LD_ADDR_VAR 0 5
83453: PUSH
83454: LD_VAR 0 5
83458: PPUSH
83459: LD_VAR 0 5
83463: PUSH
83464: LD_INT 1
83466: PLUS
83467: PPUSH
83468: LD_VAR 0 4
83472: PPUSH
83473: LD_VAR 0 2
83477: PPUSH
83478: CALL_OW 259
83482: PPUSH
83483: CALL_OW 2
83487: ST_TO_ADDR
83488: GO 83446
83490: POP
83491: POP
// if not tmp then
83492: LD_VAR 0 5
83496: NOT
83497: IFFALSE 83501
// exit ;
83499: GO 83521
// result := SortListByListDesc ( units , tmp ) ;
83501: LD_ADDR_VAR 0 3
83505: PUSH
83506: LD_VAR 0 1
83510: PPUSH
83511: LD_VAR 0 5
83515: PPUSH
83516: CALL_OW 77
83520: ST_TO_ADDR
// end ;
83521: LD_VAR 0 3
83525: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83526: LD_INT 0
83528: PPUSH
83529: PPUSH
83530: PPUSH
// x := GetX ( building ) ;
83531: LD_ADDR_VAR 0 4
83535: PUSH
83536: LD_VAR 0 2
83540: PPUSH
83541: CALL_OW 250
83545: ST_TO_ADDR
// y := GetY ( building ) ;
83546: LD_ADDR_VAR 0 5
83550: PUSH
83551: LD_VAR 0 2
83555: PPUSH
83556: CALL_OW 251
83560: ST_TO_ADDR
// if GetTaskList ( unit ) then
83561: LD_VAR 0 1
83565: PPUSH
83566: CALL_OW 437
83570: IFFALSE 83665
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83572: LD_STRING e
83574: PUSH
83575: LD_VAR 0 1
83579: PPUSH
83580: CALL_OW 437
83584: PUSH
83585: LD_INT 1
83587: ARRAY
83588: PUSH
83589: LD_INT 1
83591: ARRAY
83592: EQUAL
83593: PUSH
83594: LD_VAR 0 4
83598: PUSH
83599: LD_VAR 0 1
83603: PPUSH
83604: CALL_OW 437
83608: PUSH
83609: LD_INT 1
83611: ARRAY
83612: PUSH
83613: LD_INT 2
83615: ARRAY
83616: EQUAL
83617: AND
83618: PUSH
83619: LD_VAR 0 5
83623: PUSH
83624: LD_VAR 0 1
83628: PPUSH
83629: CALL_OW 437
83633: PUSH
83634: LD_INT 1
83636: ARRAY
83637: PUSH
83638: LD_INT 3
83640: ARRAY
83641: EQUAL
83642: AND
83643: IFFALSE 83655
// result := true else
83645: LD_ADDR_VAR 0 3
83649: PUSH
83650: LD_INT 1
83652: ST_TO_ADDR
83653: GO 83663
// result := false ;
83655: LD_ADDR_VAR 0 3
83659: PUSH
83660: LD_INT 0
83662: ST_TO_ADDR
// end else
83663: GO 83673
// result := false ;
83665: LD_ADDR_VAR 0 3
83669: PUSH
83670: LD_INT 0
83672: ST_TO_ADDR
// end ;
83673: LD_VAR 0 3
83677: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
83678: LD_INT 0
83680: PPUSH
83681: PPUSH
83682: PPUSH
83683: PPUSH
// if not unit or not area then
83684: LD_VAR 0 1
83688: NOT
83689: PUSH
83690: LD_VAR 0 2
83694: NOT
83695: OR
83696: IFFALSE 83700
// exit ;
83698: GO 83865
// tmp := AreaToList ( area , i ) ;
83700: LD_ADDR_VAR 0 6
83704: PUSH
83705: LD_VAR 0 2
83709: PPUSH
83710: LD_VAR 0 5
83714: PPUSH
83715: CALL_OW 517
83719: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
83720: LD_ADDR_VAR 0 5
83724: PUSH
83725: DOUBLE
83726: LD_INT 1
83728: DEC
83729: ST_TO_ADDR
83730: LD_VAR 0 6
83734: PUSH
83735: LD_INT 1
83737: ARRAY
83738: PUSH
83739: FOR_TO
83740: IFFALSE 83855
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
83742: LD_ADDR_VAR 0 7
83746: PUSH
83747: LD_VAR 0 6
83751: PUSH
83752: LD_INT 1
83754: ARRAY
83755: PUSH
83756: LD_VAR 0 5
83760: ARRAY
83761: PUSH
83762: LD_VAR 0 6
83766: PUSH
83767: LD_INT 2
83769: ARRAY
83770: PUSH
83771: LD_VAR 0 5
83775: ARRAY
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
83781: LD_VAR 0 7
83785: PUSH
83786: LD_INT 1
83788: ARRAY
83789: PPUSH
83790: LD_VAR 0 7
83794: PUSH
83795: LD_INT 2
83797: ARRAY
83798: PPUSH
83799: CALL_OW 428
83803: PUSH
83804: LD_INT 0
83806: EQUAL
83807: IFFALSE 83853
// begin result := true ;
83809: LD_ADDR_VAR 0 4
83813: PUSH
83814: LD_INT 1
83816: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
83817: LD_VAR 0 1
83821: PPUSH
83822: LD_VAR 0 7
83826: PUSH
83827: LD_INT 1
83829: ARRAY
83830: PPUSH
83831: LD_VAR 0 7
83835: PUSH
83836: LD_INT 2
83838: ARRAY
83839: PPUSH
83840: LD_VAR 0 3
83844: PPUSH
83845: CALL_OW 48
// exit ;
83849: POP
83850: POP
83851: GO 83865
// end ; end ;
83853: GO 83739
83855: POP
83856: POP
// result := false ;
83857: LD_ADDR_VAR 0 4
83861: PUSH
83862: LD_INT 0
83864: ST_TO_ADDR
// end ;
83865: LD_VAR 0 4
83869: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
83870: LD_INT 0
83872: PPUSH
83873: PPUSH
83874: PPUSH
// if not side or side > 8 then
83875: LD_VAR 0 1
83879: NOT
83880: PUSH
83881: LD_VAR 0 1
83885: PUSH
83886: LD_INT 8
83888: GREATER
83889: OR
83890: IFFALSE 83894
// exit ;
83892: GO 84081
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
83894: LD_ADDR_VAR 0 4
83898: PUSH
83899: LD_INT 22
83901: PUSH
83902: LD_VAR 0 1
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 21
83913: PUSH
83914: LD_INT 3
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PPUSH
83925: CALL_OW 69
83929: ST_TO_ADDR
// if not tmp then
83930: LD_VAR 0 4
83934: NOT
83935: IFFALSE 83939
// exit ;
83937: GO 84081
// enable_addtolog := true ;
83939: LD_ADDR_OWVAR 81
83943: PUSH
83944: LD_INT 1
83946: ST_TO_ADDR
// AddToLog ( [ ) ;
83947: LD_STRING [
83949: PPUSH
83950: CALL_OW 561
// for i in tmp do
83954: LD_ADDR_VAR 0 3
83958: PUSH
83959: LD_VAR 0 4
83963: PUSH
83964: FOR_IN
83965: IFFALSE 84072
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
83967: LD_STRING [
83969: PUSH
83970: LD_VAR 0 3
83974: PPUSH
83975: CALL_OW 266
83979: STR
83980: PUSH
83981: LD_STRING , 
83983: STR
83984: PUSH
83985: LD_VAR 0 3
83989: PPUSH
83990: CALL_OW 250
83994: STR
83995: PUSH
83996: LD_STRING , 
83998: STR
83999: PUSH
84000: LD_VAR 0 3
84004: PPUSH
84005: CALL_OW 251
84009: STR
84010: PUSH
84011: LD_STRING , 
84013: STR
84014: PUSH
84015: LD_VAR 0 3
84019: PPUSH
84020: CALL_OW 254
84024: STR
84025: PUSH
84026: LD_STRING , 
84028: STR
84029: PUSH
84030: LD_VAR 0 3
84034: PPUSH
84035: LD_INT 1
84037: PPUSH
84038: CALL_OW 268
84042: STR
84043: PUSH
84044: LD_STRING , 
84046: STR
84047: PUSH
84048: LD_VAR 0 3
84052: PPUSH
84053: LD_INT 2
84055: PPUSH
84056: CALL_OW 268
84060: STR
84061: PUSH
84062: LD_STRING ],
84064: STR
84065: PPUSH
84066: CALL_OW 561
// end ;
84070: GO 83964
84072: POP
84073: POP
// AddToLog ( ]; ) ;
84074: LD_STRING ];
84076: PPUSH
84077: CALL_OW 561
// end ;
84081: LD_VAR 0 2
84085: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84086: LD_INT 0
84088: PPUSH
84089: PPUSH
84090: PPUSH
84091: PPUSH
84092: PPUSH
// if not area or not rate or not max then
84093: LD_VAR 0 1
84097: NOT
84098: PUSH
84099: LD_VAR 0 2
84103: NOT
84104: OR
84105: PUSH
84106: LD_VAR 0 4
84110: NOT
84111: OR
84112: IFFALSE 84116
// exit ;
84114: GO 84308
// while 1 do
84116: LD_INT 1
84118: IFFALSE 84308
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84120: LD_ADDR_VAR 0 9
84124: PUSH
84125: LD_VAR 0 1
84129: PPUSH
84130: LD_INT 1
84132: PPUSH
84133: CALL_OW 287
84137: PUSH
84138: LD_INT 10
84140: MUL
84141: ST_TO_ADDR
// r := rate / 10 ;
84142: LD_ADDR_VAR 0 7
84146: PUSH
84147: LD_VAR 0 2
84151: PUSH
84152: LD_INT 10
84154: DIVREAL
84155: ST_TO_ADDR
// time := 1 1$00 ;
84156: LD_ADDR_VAR 0 8
84160: PUSH
84161: LD_INT 2100
84163: ST_TO_ADDR
// if amount < min then
84164: LD_VAR 0 9
84168: PUSH
84169: LD_VAR 0 3
84173: LESS
84174: IFFALSE 84192
// r := r * 2 else
84176: LD_ADDR_VAR 0 7
84180: PUSH
84181: LD_VAR 0 7
84185: PUSH
84186: LD_INT 2
84188: MUL
84189: ST_TO_ADDR
84190: GO 84218
// if amount > max then
84192: LD_VAR 0 9
84196: PUSH
84197: LD_VAR 0 4
84201: GREATER
84202: IFFALSE 84218
// r := r / 2 ;
84204: LD_ADDR_VAR 0 7
84208: PUSH
84209: LD_VAR 0 7
84213: PUSH
84214: LD_INT 2
84216: DIVREAL
84217: ST_TO_ADDR
// time := time / r ;
84218: LD_ADDR_VAR 0 8
84222: PUSH
84223: LD_VAR 0 8
84227: PUSH
84228: LD_VAR 0 7
84232: DIVREAL
84233: ST_TO_ADDR
// if time < 0 then
84234: LD_VAR 0 8
84238: PUSH
84239: LD_INT 0
84241: LESS
84242: IFFALSE 84259
// time := time * - 1 ;
84244: LD_ADDR_VAR 0 8
84248: PUSH
84249: LD_VAR 0 8
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: MUL
84258: ST_TO_ADDR
// wait ( time ) ;
84259: LD_VAR 0 8
84263: PPUSH
84264: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
84268: LD_INT 35
84270: PPUSH
84271: LD_INT 875
84273: PPUSH
84274: CALL_OW 12
84278: PPUSH
84279: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84283: LD_INT 1
84285: PPUSH
84286: LD_INT 5
84288: PPUSH
84289: CALL_OW 12
84293: PPUSH
84294: LD_VAR 0 1
84298: PPUSH
84299: LD_INT 1
84301: PPUSH
84302: CALL_OW 55
// end ;
84306: GO 84116
// end ;
84308: LD_VAR 0 5
84312: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84313: LD_INT 0
84315: PPUSH
84316: PPUSH
84317: PPUSH
84318: PPUSH
84319: PPUSH
84320: PPUSH
84321: PPUSH
84322: PPUSH
// if not turrets or not factories then
84323: LD_VAR 0 1
84327: NOT
84328: PUSH
84329: LD_VAR 0 2
84333: NOT
84334: OR
84335: IFFALSE 84339
// exit ;
84337: GO 84646
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84339: LD_ADDR_VAR 0 10
84343: PUSH
84344: LD_INT 5
84346: PUSH
84347: LD_INT 6
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: PUSH
84354: LD_INT 2
84356: PUSH
84357: LD_INT 4
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 3
84366: PUSH
84367: LD_INT 5
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 24
84381: PUSH
84382: LD_INT 25
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 23
84391: PUSH
84392: LD_INT 27
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 42
84405: PUSH
84406: LD_INT 43
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 44
84415: PUSH
84416: LD_INT 46
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: LD_INT 45
84425: PUSH
84426: LD_INT 47
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: LIST
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: LIST
84442: ST_TO_ADDR
// result := [ ] ;
84443: LD_ADDR_VAR 0 3
84447: PUSH
84448: EMPTY
84449: ST_TO_ADDR
// for i in turrets do
84450: LD_ADDR_VAR 0 4
84454: PUSH
84455: LD_VAR 0 1
84459: PUSH
84460: FOR_IN
84461: IFFALSE 84644
// begin nat := GetNation ( i ) ;
84463: LD_ADDR_VAR 0 7
84467: PUSH
84468: LD_VAR 0 4
84472: PPUSH
84473: CALL_OW 248
84477: ST_TO_ADDR
// weapon := 0 ;
84478: LD_ADDR_VAR 0 8
84482: PUSH
84483: LD_INT 0
84485: ST_TO_ADDR
// if not nat then
84486: LD_VAR 0 7
84490: NOT
84491: IFFALSE 84495
// continue ;
84493: GO 84460
// for j in list [ nat ] do
84495: LD_ADDR_VAR 0 5
84499: PUSH
84500: LD_VAR 0 10
84504: PUSH
84505: LD_VAR 0 7
84509: ARRAY
84510: PUSH
84511: FOR_IN
84512: IFFALSE 84553
// if GetBWeapon ( i ) = j [ 1 ] then
84514: LD_VAR 0 4
84518: PPUSH
84519: CALL_OW 269
84523: PUSH
84524: LD_VAR 0 5
84528: PUSH
84529: LD_INT 1
84531: ARRAY
84532: EQUAL
84533: IFFALSE 84551
// begin weapon := j [ 2 ] ;
84535: LD_ADDR_VAR 0 8
84539: PUSH
84540: LD_VAR 0 5
84544: PUSH
84545: LD_INT 2
84547: ARRAY
84548: ST_TO_ADDR
// break ;
84549: GO 84553
// end ;
84551: GO 84511
84553: POP
84554: POP
// if not weapon then
84555: LD_VAR 0 8
84559: NOT
84560: IFFALSE 84564
// continue ;
84562: GO 84460
// for k in factories do
84564: LD_ADDR_VAR 0 6
84568: PUSH
84569: LD_VAR 0 2
84573: PUSH
84574: FOR_IN
84575: IFFALSE 84640
// begin weapons := AvailableWeaponList ( k ) ;
84577: LD_ADDR_VAR 0 9
84581: PUSH
84582: LD_VAR 0 6
84586: PPUSH
84587: CALL_OW 478
84591: ST_TO_ADDR
// if not weapons then
84592: LD_VAR 0 9
84596: NOT
84597: IFFALSE 84601
// continue ;
84599: GO 84574
// if weapon in weapons then
84601: LD_VAR 0 8
84605: PUSH
84606: LD_VAR 0 9
84610: IN
84611: IFFALSE 84638
// begin result := [ i , weapon ] ;
84613: LD_ADDR_VAR 0 3
84617: PUSH
84618: LD_VAR 0 4
84622: PUSH
84623: LD_VAR 0 8
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: ST_TO_ADDR
// exit ;
84632: POP
84633: POP
84634: POP
84635: POP
84636: GO 84646
// end ; end ;
84638: GO 84574
84640: POP
84641: POP
// end ;
84642: GO 84460
84644: POP
84645: POP
// end ;
84646: LD_VAR 0 3
84650: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
84651: LD_INT 0
84653: PPUSH
// if not side or side > 8 then
84654: LD_VAR 0 3
84658: NOT
84659: PUSH
84660: LD_VAR 0 3
84664: PUSH
84665: LD_INT 8
84667: GREATER
84668: OR
84669: IFFALSE 84673
// exit ;
84671: GO 84732
// if not range then
84673: LD_VAR 0 4
84677: NOT
84678: IFFALSE 84689
// range := - 12 ;
84680: LD_ADDR_VAR 0 4
84684: PUSH
84685: LD_INT 12
84687: NEG
84688: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
84689: LD_VAR 0 1
84693: PPUSH
84694: LD_VAR 0 2
84698: PPUSH
84699: LD_VAR 0 3
84703: PPUSH
84704: LD_VAR 0 4
84708: PPUSH
84709: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
84713: LD_VAR 0 1
84717: PPUSH
84718: LD_VAR 0 2
84722: PPUSH
84723: LD_VAR 0 3
84727: PPUSH
84728: CALL_OW 331
// end ;
84732: LD_VAR 0 5
84736: RET
// export function Video ( mode ) ; begin
84737: LD_INT 0
84739: PPUSH
// ingame_video = mode ;
84740: LD_ADDR_OWVAR 52
84744: PUSH
84745: LD_VAR 0 1
84749: ST_TO_ADDR
// interface_hidden = mode ;
84750: LD_ADDR_OWVAR 54
84754: PUSH
84755: LD_VAR 0 1
84759: ST_TO_ADDR
// end ;
84760: LD_VAR 0 2
84764: RET
