// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 41 0 0
// InitMacro ;
   8: CALL 13268 0 0
// PrepareAlliance ;
  12: CALL 3530 0 0
// PrepareRussian ;
  16: CALL 3192 0 0
// PrepareLegion ;
  20: CALL 2568 0 0
// PreparePowell ;
  24: CALL 1351 0 0
// PrepareAmerican ;
  28: CALL 895 0 0
// Action ;
  32: CALL 4445 0 0
// MC_Start ( ) ;
  36: CALL 14415 0 0
// end ;
  40: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode ; export function InitVariables ; begin
  41: LD_INT 0
  43: PPUSH
// debug := true ;
  44: LD_ADDR_EXP 1
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// missionStart := false ;
  52: LD_ADDR_EXP 12
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// missionTime := 0 0$00 ;
  60: LD_ADDR_EXP 13
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// missionStage := 1 ;
  68: LD_ADDR_EXP 14
  72: PUSH
  73: LD_INT 1
  75: ST_TO_ADDR
// activeAttacks := false ;
  76: LD_ADDR_EXP 15
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// powellAnger := 0 ;
  84: LD_ADDR_EXP 16
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// powellAllowRetreat := true ;
  92: LD_ADDR_EXP 18
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// powellCenterCameraMode := false ;
 100: LD_ADDR_EXP 19
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: EMPTY
 114: PUSH
 115: EMPTY
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 121: LD_ADDR_EXP 2
 125: PUSH
 126: LD_STRING 14_KappaStatus_1
 128: PPUSH
 129: LD_INT 0
 131: PPUSH
 132: CALL_OW 30
 136: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 137: LD_ADDR_EXP 3
 141: PUSH
 142: LD_STRING 06_KurtStatus_1
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: CALL_OW 30
 152: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 153: LD_ADDR_EXP 4
 157: PUSH
 158: LD_STRING 14_JMMVeh_1
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL_OW 30
 168: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 169: LD_ADDR_EXP 5
 173: PUSH
 174: LD_STRING 14_JMMGirlVeh_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 185: LD_ADDR_EXP 7
 189: PUSH
 190: LD_STRING 14_JMMGirl_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 201: LD_ADDR_EXP 6
 205: PUSH
 206: LD_STRING 14_JMMGirlStatus_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 217: LD_ADDR_EXP 8
 221: PUSH
 222: LD_STRING 10_KhatamStatus_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 233: LD_ADDR_EXP 9
 237: PUSH
 238: LD_STRING 13_BurlakStatus_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 10
 253: PUSH
 254: LD_STRING 13_StevensStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 265: LD_ADDR_EXP 11
 269: PUSH
 270: LD_STRING 14_FastEnd_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// end ;
 281: LD_VAR 0 1
 285: RET
// export function CustomInitMacro ( ) ; begin
 286: LD_INT 0
 288: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 289: LD_ADDR_EXP 93
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 3
 299: PUSH
 300: LD_INT 6
 302: PUSH
 303: LD_INT 11
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 312: LD_ADDR_EXP 94
 316: PUSH
 317: LD_INT 1
 319: PUSH
 320: LD_INT 4
 322: PUSH
 323: LD_INT 5
 325: PUSH
 326: LD_INT 10
 328: PUSH
 329: EMPTY
 330: LIST
 331: LIST
 332: LIST
 333: LIST
 334: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 335: LD_ADDR_EXP 98
 339: PUSH
 340: LD_EXP 98
 344: PPUSH
 345: LD_INT 3
 347: PPUSH
 348: LD_INT 22
 350: PUSH
 351: LD_INT 8
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 25
 360: PUSH
 361: LD_INT 15
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PPUSH
 372: CALL_OW 69
 376: PPUSH
 377: CALL_OW 1
 381: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_remote , ar_gun ] , [ ar_medium_trike , engine_solar , control_remote , ar_rocket_launcher ] ] ) ;
 382: LD_INT 3
 384: PPUSH
 385: LD_INT 13
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: LD_INT 1
 393: PUSH
 394: LD_INT 31
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: PUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 2
 429: PUSH
 430: LD_INT 27
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 2
 444: PUSH
 445: LD_INT 2
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: PPUSH
 463: CALL 35211 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 467: LD_INT 4
 469: PPUSH
 470: LD_INT 10
 472: PUSH
 473: LD_INT 12
 475: PUSH
 476: EMPTY
 477: LIST
 478: LIST
 479: PPUSH
 480: CALL 35948 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 484: LD_INT 4
 486: PPUSH
 487: LD_INT 10
 489: PUSH
 490: EMPTY
 491: LIST
 492: PPUSH
 493: CALL 36041 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 62 , 78 , 4 ] ] ) ;
 497: LD_INT 4
 499: PPUSH
 500: LD_INT 26
 502: PUSH
 503: LD_INT 74
 505: PUSH
 506: LD_INT 107
 508: PUSH
 509: LD_INT 0
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: PUSH
 518: LD_INT 32
 520: PUSH
 521: LD_INT 77
 523: PUSH
 524: LD_INT 101
 526: PUSH
 527: LD_INT 4
 529: PUSH
 530: EMPTY
 531: LIST
 532: LIST
 533: LIST
 534: LIST
 535: PUSH
 536: LD_INT 32
 538: PUSH
 539: LD_INT 69
 541: PUSH
 542: LD_INT 86
 544: PUSH
 545: LD_INT 4
 547: PUSH
 548: EMPTY
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_INT 27
 556: PUSH
 557: LD_INT 77
 559: PUSH
 560: LD_INT 110
 562: PUSH
 563: LD_INT 3
 565: PUSH
 566: EMPTY
 567: LIST
 568: LIST
 569: LIST
 570: LIST
 571: PUSH
 572: LD_INT 27
 574: PUSH
 575: LD_INT 42
 577: PUSH
 578: LD_INT 79
 580: PUSH
 581: LD_INT 5
 583: PUSH
 584: EMPTY
 585: LIST
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_INT 29
 592: PUSH
 593: LD_INT 86
 595: PUSH
 596: LD_INT 105
 598: PUSH
 599: LD_INT 2
 601: PUSH
 602: EMPTY
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: PUSH
 608: LD_INT 30
 610: PUSH
 611: LD_INT 40
 613: PUSH
 614: LD_INT 75
 616: PUSH
 617: LD_INT 1
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: LIST
 624: LIST
 625: PUSH
 626: LD_INT 32
 628: PUSH
 629: LD_INT 80
 631: PUSH
 632: LD_INT 106
 634: PUSH
 635: LD_INT 4
 637: PUSH
 638: EMPTY
 639: LIST
 640: LIST
 641: LIST
 642: LIST
 643: PUSH
 644: LD_INT 32
 646: PUSH
 647: LD_INT 62
 649: PUSH
 650: LD_INT 78
 652: PUSH
 653: LD_INT 4
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PUSH
 662: EMPTY
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: LIST
 672: PPUSH
 673: CALL 35103 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
 677: LD_INT 4
 679: PPUSH
 680: LD_INT 5
 682: PUSH
 683: LD_INT 6
 685: PUSH
 686: LD_INT 7
 688: PUSH
 689: LD_INT 9
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: LIST
 697: PPUSH
 698: CALL 36359 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
 702: LD_INT 4
 704: PPUSH
 705: LD_INT 40
 707: PUSH
 708: LD_INT 75
 710: PUSH
 711: LD_INT 1
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: PUSH
 719: LD_INT 86
 721: PUSH
 722: LD_INT 105
 724: PUSH
 725: LD_INT 0
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: PPUSH
 737: CALL 35593 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
 741: LD_INT 4
 743: PPUSH
 744: LD_INT 2
 746: PPUSH
 747: CALL 35821 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
 751: LD_INT 4
 753: PPUSH
 754: LD_INT 0
 756: PPUSH
 757: CALL 35821 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
 761: LD_INT 4
 763: PPUSH
 764: LD_INT 54
 766: PPUSH
 767: LD_INT 85
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: LD_INT 19
 775: PUSH
 776: LD_INT 16
 778: PUSH
 779: LD_INT 17
 781: PUSH
 782: LD_INT 18
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL 36153 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
 795: LD_INT 4
 797: PPUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 1
 803: PUSH
 804: LD_INT 1
 806: PUSH
 807: LD_INT 5
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: LIST
 814: LIST
 815: PUSH
 816: LD_INT 4
 818: PUSH
 819: LD_INT 1
 821: PUSH
 822: LD_INT 1
 824: PUSH
 825: LD_INT 6
 827: PUSH
 828: EMPTY
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: PUSH
 834: LD_INT 4
 836: PUSH
 837: LD_INT 1
 839: PUSH
 840: LD_INT 1
 842: PUSH
 843: LD_INT 7
 845: PUSH
 846: EMPTY
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PUSH
 852: LD_INT 4
 854: PUSH
 855: LD_INT 1
 857: PUSH
 858: LD_INT 1
 860: PUSH
 861: LD_INT 6
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: PUSH
 870: EMPTY
 871: LIST
 872: LIST
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL 35211 0 2
// MC_SetTame ( 4 , powellApe ) ;
 880: LD_INT 4
 882: PPUSH
 883: LD_INT 14
 885: PPUSH
 886: CALL 35772 0 2
// end ; end_of_file
 890: LD_VAR 0 1
 894: RET
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
 895: LD_INT 0
 897: PPUSH
// uc_side := 1 ;
 898: LD_ADDR_OWVAR 20
 902: PUSH
 903: LD_INT 1
 905: ST_TO_ADDR
// uc_nation := 1 ;
 906: LD_ADDR_OWVAR 21
 910: PUSH
 911: LD_INT 1
 913: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
 914: LD_ADDR_EXP 20
 918: PUSH
 919: LD_STRING JMM
 921: PPUSH
 922: LD_EXP 1
 926: NOT
 927: PPUSH
 928: LD_STRING 14_
 930: PPUSH
 931: CALL 40983 0 3
 935: ST_TO_ADDR
// if not JMMVeh then
 936: LD_EXP 4
 940: NOT
 941: IFFALSE 964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
 943: LD_INT 3
 945: PPUSH
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 1
 951: PPUSH
 952: LD_INT 5
 954: PPUSH
 955: LD_INT 100
 957: PPUSH
 958: CALL 47616 0 5
 962: GO 1023
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
 964: LD_EXP 4
 968: PUSH
 969: LD_INT 1
 971: ARRAY
 972: PUSH
 973: LD_INT 1
 975: ARRAY
 976: PPUSH
 977: LD_EXP 4
 981: PUSH
 982: LD_INT 2
 984: ARRAY
 985: PUSH
 986: LD_INT 1
 988: ARRAY
 989: PPUSH
 990: LD_EXP 4
 994: PUSH
 995: LD_INT 3
 997: ARRAY
 998: PUSH
 999: LD_INT 1
1001: ARRAY
1002: PPUSH
1003: LD_EXP 4
1007: PUSH
1008: LD_INT 4
1010: ARRAY
1011: PUSH
1012: LD_INT 1
1014: ARRAY
1015: PPUSH
1016: LD_INT 30
1018: PPUSH
1019: CALL 47616 0 5
// JMMNewVeh := CreateVehicle ;
1023: LD_ADDR_EXP 36
1027: PUSH
1028: CALL_OW 45
1032: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1033: LD_EXP 36
1037: PPUSH
1038: LD_INT 4
1040: PPUSH
1041: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1045: LD_EXP 36
1049: PPUSH
1050: LD_INT 75
1052: PPUSH
1053: LD_INT 92
1055: PPUSH
1056: LD_INT 0
1058: PPUSH
1059: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1063: LD_EXP 20
1067: PPUSH
1068: LD_EXP 36
1072: PPUSH
1073: CALL_OW 52
// if JMMGirl and not KappaStatus then
1077: LD_EXP 7
1081: PUSH
1082: LD_EXP 2
1086: NOT
1087: AND
1088: IFFALSE 1346
// begin if not JMMGirlVeh then
1090: LD_EXP 5
1094: NOT
1095: IFFALSE 1118
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1097: LD_INT 3
1099: PPUSH
1100: LD_INT 3
1102: PPUSH
1103: LD_INT 1
1105: PPUSH
1106: LD_INT 9
1108: PPUSH
1109: LD_INT 100
1111: PPUSH
1112: CALL 47616 0 5
1116: GO 1177
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1118: LD_EXP 5
1122: PUSH
1123: LD_INT 1
1125: ARRAY
1126: PUSH
1127: LD_INT 1
1129: ARRAY
1130: PPUSH
1131: LD_EXP 5
1135: PUSH
1136: LD_INT 2
1138: ARRAY
1139: PUSH
1140: LD_INT 1
1142: ARRAY
1143: PPUSH
1144: LD_EXP 5
1148: PUSH
1149: LD_INT 3
1151: ARRAY
1152: PUSH
1153: LD_INT 1
1155: ARRAY
1156: PPUSH
1157: LD_EXP 5
1161: PUSH
1162: LD_INT 4
1164: ARRAY
1165: PUSH
1166: LD_INT 1
1168: ARRAY
1169: PPUSH
1170: LD_INT 30
1172: PPUSH
1173: CALL 47616 0 5
// GirlNewVeh := CreateVehicle ;
1177: LD_ADDR_EXP 37
1181: PUSH
1182: CALL_OW 45
1186: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1187: LD_EXP 37
1191: PPUSH
1192: LD_INT 4
1194: PPUSH
1195: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1199: LD_EXP 37
1203: PPUSH
1204: LD_INT 82
1206: PPUSH
1207: LD_INT 96
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 48
// if JMMGirl = 1 then
1217: LD_EXP 7
1221: PUSH
1222: LD_INT 1
1224: EQUAL
1225: IFFALSE 1260
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1227: LD_ADDR_EXP 21
1231: PUSH
1232: LD_STRING Joan
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_STRING 14_
1240: PPUSH
1241: CALL 40983 0 3
1245: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1246: LD_EXP 21
1250: PPUSH
1251: LD_EXP 37
1255: PPUSH
1256: CALL_OW 52
// end ; if JMMGirl = 2 then
1260: LD_EXP 7
1264: PUSH
1265: LD_INT 2
1267: EQUAL
1268: IFFALSE 1303
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1270: LD_ADDR_EXP 23
1274: PUSH
1275: LD_STRING Lisa
1277: PPUSH
1278: LD_INT 1
1280: PPUSH
1281: LD_STRING 14_
1283: PPUSH
1284: CALL 40983 0 3
1288: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1289: LD_EXP 23
1293: PPUSH
1294: LD_EXP 37
1298: PPUSH
1299: CALL_OW 52
// end ; if JMMGirl = 3 then
1303: LD_EXP 7
1307: PUSH
1308: LD_INT 3
1310: EQUAL
1311: IFFALSE 1346
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
1313: LD_ADDR_EXP 35
1317: PUSH
1318: LD_STRING Connie
1320: PPUSH
1321: LD_INT 1
1323: PPUSH
1324: LD_STRING 14_
1326: PPUSH
1327: CALL 40983 0 3
1331: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
1332: LD_EXP 35
1336: PPUSH
1337: LD_EXP 37
1341: PPUSH
1342: CALL_OW 52
// end ; end ; end ; end_of_file
1346: LD_VAR 0 1
1350: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
1351: LD_INT 0
1353: PPUSH
1354: PPUSH
1355: PPUSH
1356: PPUSH
1357: PPUSH
1358: PPUSH
1359: PPUSH
1360: PPUSH
1361: PPUSH
1362: PPUSH
// uc_side := 4 ;
1363: LD_ADDR_OWVAR 20
1367: PUSH
1368: LD_INT 4
1370: ST_TO_ADDR
// uc_nation := 1 ;
1371: LD_ADDR_OWVAR 21
1375: PUSH
1376: LD_INT 1
1378: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
1379: LD_INT 387
1381: PPUSH
1382: CALL_OW 274
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_INT 2500
1392: PPUSH
1393: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
1397: LD_INT 387
1399: PPUSH
1400: CALL_OW 274
1404: PPUSH
1405: LD_INT 2
1407: PPUSH
1408: LD_INT 400
1410: PPUSH
1411: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
1415: LD_INT 387
1417: PPUSH
1418: CALL_OW 274
1422: PPUSH
1423: LD_INT 3
1425: PPUSH
1426: LD_INT 10
1428: PPUSH
1429: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
1433: LD_ADDR_EXP 38
1437: PUSH
1438: LD_STRING Powell
1440: PPUSH
1441: CALL_OW 25
1445: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
1446: LD_EXP 38
1450: PPUSH
1451: LD_INT 57
1453: PPUSH
1454: LD_INT 94
1456: PPUSH
1457: LD_INT 0
1459: PPUSH
1460: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
1464: LD_EXP 38
1468: PPUSH
1469: LD_INT 58
1471: PPUSH
1472: LD_INT 94
1474: PPUSH
1475: CALL_OW 118
// vip := [ ] ;
1479: LD_ADDR_EXP 39
1483: PUSH
1484: EMPTY
1485: ST_TO_ADDR
// tmp := [ ] ;
1486: LD_ADDR_VAR 0 6
1490: PUSH
1491: EMPTY
1492: ST_TO_ADDR
// if JMMGirl <> 2 then
1493: LD_EXP 7
1497: PUSH
1498: LD_INT 2
1500: NONEQUAL
1501: IFFALSE 1525
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
1503: LD_ADDR_EXP 23
1507: PUSH
1508: LD_STRING Lisa
1510: PPUSH
1511: LD_EXP 1
1515: NOT
1516: PPUSH
1517: LD_STRING 13s_
1519: PPUSH
1520: CALL 40983 0 3
1524: ST_TO_ADDR
// if Lisa then
1525: LD_EXP 23
1529: IFFALSE 1547
// tmp := tmp ^ Lisa ;
1531: LD_ADDR_VAR 0 6
1535: PUSH
1536: LD_VAR 0 6
1540: PUSH
1541: LD_EXP 23
1545: ADD
1546: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
1547: LD_ADDR_EXP 24
1551: PUSH
1552: LD_STRING Donaldson
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 13s_
1563: PPUSH
1564: CALL 40983 0 3
1568: ST_TO_ADDR
// if Donaldson then
1569: LD_EXP 24
1573: IFFALSE 1591
// tmp := tmp ^ Donaldson ;
1575: LD_ADDR_VAR 0 6
1579: PUSH
1580: LD_VAR 0 6
1584: PUSH
1585: LD_EXP 24
1589: ADD
1590: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
1591: LD_ADDR_EXP 25
1595: PUSH
1596: LD_STRING Bobby
1598: PPUSH
1599: LD_EXP 1
1603: NOT
1604: PPUSH
1605: LD_STRING 13s_
1607: PPUSH
1608: CALL 40983 0 3
1612: ST_TO_ADDR
// if Bobby then
1613: LD_EXP 25
1617: IFFALSE 1635
// tmp := tmp ^ Bobby ;
1619: LD_ADDR_VAR 0 6
1623: PUSH
1624: LD_VAR 0 6
1628: PUSH
1629: LD_EXP 25
1633: ADD
1634: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
1635: LD_ADDR_EXP 26
1639: PUSH
1640: LD_STRING Cyrus
1642: PPUSH
1643: LD_EXP 1
1647: NOT
1648: PPUSH
1649: LD_STRING 13s_
1651: PPUSH
1652: CALL 40983 0 3
1656: ST_TO_ADDR
// if Cyrus then
1657: LD_EXP 26
1661: IFFALSE 1679
// tmp := tmp ^ Cyrus ;
1663: LD_ADDR_VAR 0 6
1667: PUSH
1668: LD_VAR 0 6
1672: PUSH
1673: LD_EXP 26
1677: ADD
1678: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
1679: LD_ADDR_EXP 27
1683: PUSH
1684: LD_STRING Denis
1686: PPUSH
1687: LD_EXP 1
1691: NOT
1692: PPUSH
1693: LD_STRING 13s_
1695: PPUSH
1696: CALL 40983 0 3
1700: ST_TO_ADDR
// if Denis then
1701: LD_EXP 27
1705: IFFALSE 1723
// tmp := tmp ^ Denis ;
1707: LD_ADDR_VAR 0 6
1711: PUSH
1712: LD_VAR 0 6
1716: PUSH
1717: LD_EXP 27
1721: ADD
1722: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
1723: LD_ADDR_EXP 28
1727: PUSH
1728: LD_STRING Brown
1730: PPUSH
1731: LD_EXP 1
1735: NOT
1736: PPUSH
1737: LD_STRING 13s_
1739: PPUSH
1740: CALL 40983 0 3
1744: ST_TO_ADDR
// if Brown then
1745: LD_EXP 28
1749: IFFALSE 1767
// tmp := tmp ^ Brown ;
1751: LD_ADDR_VAR 0 6
1755: PUSH
1756: LD_VAR 0 6
1760: PUSH
1761: LD_EXP 28
1765: ADD
1766: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
1767: LD_ADDR_EXP 29
1771: PUSH
1772: LD_STRING Gladstone
1774: PPUSH
1775: LD_EXP 1
1779: NOT
1780: PPUSH
1781: LD_STRING 13s_
1783: PPUSH
1784: CALL 40983 0 3
1788: ST_TO_ADDR
// if Gladstone then
1789: LD_EXP 29
1793: IFFALSE 1811
// tmp := tmp ^ Gladstone ;
1795: LD_ADDR_VAR 0 6
1799: PUSH
1800: LD_VAR 0 6
1804: PUSH
1805: LD_EXP 29
1809: ADD
1810: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
1811: LD_ADDR_EXP 30
1815: PUSH
1816: LD_STRING Houten
1818: PPUSH
1819: LD_EXP 1
1823: NOT
1824: PPUSH
1825: LD_STRING 13s_
1827: PPUSH
1828: CALL 40983 0 3
1832: ST_TO_ADDR
// if Houten then
1833: LD_EXP 30
1837: IFFALSE 1855
// tmp := tmp ^ Houten ;
1839: LD_ADDR_VAR 0 6
1843: PUSH
1844: LD_VAR 0 6
1848: PUSH
1849: LD_EXP 30
1853: ADD
1854: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
1855: LD_ADDR_EXP 31
1859: PUSH
1860: LD_STRING Cornel
1862: PPUSH
1863: LD_EXP 1
1867: NOT
1868: PPUSH
1869: LD_STRING 13s_
1871: PPUSH
1872: CALL 40983 0 3
1876: ST_TO_ADDR
// if Cornel then
1877: LD_EXP 31
1881: IFFALSE 1899
// tmp := tmp ^ Cornel ;
1883: LD_ADDR_VAR 0 6
1887: PUSH
1888: LD_VAR 0 6
1892: PUSH
1893: LD_EXP 31
1897: ADD
1898: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
1899: LD_ADDR_EXP 32
1903: PUSH
1904: LD_STRING Gary
1906: PPUSH
1907: LD_EXP 1
1911: NOT
1912: PPUSH
1913: LD_STRING 13s_
1915: PPUSH
1916: CALL 40983 0 3
1920: ST_TO_ADDR
// if Gary then
1921: LD_EXP 32
1925: IFFALSE 1943
// tmp := tmp ^ Gary ;
1927: LD_ADDR_VAR 0 6
1931: PUSH
1932: LD_VAR 0 6
1936: PUSH
1937: LD_EXP 32
1941: ADD
1942: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
1943: LD_ADDR_EXP 33
1947: PUSH
1948: LD_STRING Frank
1950: PPUSH
1951: LD_EXP 1
1955: NOT
1956: PPUSH
1957: LD_STRING 13s_
1959: PPUSH
1960: CALL 40983 0 3
1964: ST_TO_ADDR
// if Frank then
1965: LD_EXP 33
1969: IFFALSE 1987
// tmp := tmp ^ Frank ;
1971: LD_ADDR_VAR 0 6
1975: PUSH
1976: LD_VAR 0 6
1980: PUSH
1981: LD_EXP 33
1985: ADD
1986: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
1987: LD_ADDR_EXP 34
1991: PUSH
1992: LD_STRING Kikuchi
1994: PPUSH
1995: LD_EXP 1
1999: NOT
2000: PPUSH
2001: LD_STRING 13s_
2003: PPUSH
2004: CALL 40983 0 3
2008: ST_TO_ADDR
// if Kikuchi then
2009: LD_EXP 34
2013: IFFALSE 2031
// tmp := tmp ^ Kikuchi ;
2015: LD_ADDR_VAR 0 6
2019: PUSH
2020: LD_VAR 0 6
2024: PUSH
2025: LD_EXP 34
2029: ADD
2030: ST_TO_ADDR
// vip := tmp ;
2031: LD_ADDR_EXP 39
2035: PUSH
2036: LD_VAR 0 6
2040: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
2041: LD_ADDR_VAR 0 6
2045: PUSH
2046: LD_VAR 0 6
2050: PUSH
2051: LD_STRING 13s_others
2053: PPUSH
2054: CALL_OW 31
2058: UNION
2059: ST_TO_ADDR
// if tmp < 20 then
2060: LD_VAR 0 6
2064: PUSH
2065: LD_INT 20
2067: LESS
2068: IFFALSE 2135
// for i = 1 to 20 - tmp do
2070: LD_ADDR_VAR 0 2
2074: PUSH
2075: DOUBLE
2076: LD_INT 1
2078: DEC
2079: ST_TO_ADDR
2080: LD_INT 20
2082: PUSH
2083: LD_VAR 0 6
2087: MINUS
2088: PUSH
2089: FOR_TO
2090: IFFALSE 2133
// begin PrepareHuman ( false , i mod 4 + 1 , 8 ) ;
2092: LD_INT 0
2094: PPUSH
2095: LD_VAR 0 2
2099: PUSH
2100: LD_INT 4
2102: MOD
2103: PUSH
2104: LD_INT 1
2106: PLUS
2107: PPUSH
2108: LD_INT 8
2110: PPUSH
2111: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2115: LD_ADDR_VAR 0 6
2119: PUSH
2120: LD_VAR 0 6
2124: PUSH
2125: CALL_OW 44
2129: ADD
2130: ST_TO_ADDR
// end ;
2131: GO 2089
2133: POP
2134: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
2135: LD_ADDR_VAR 0 7
2139: PUSH
2140: LD_INT 22
2142: PUSH
2143: LD_INT 4
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: PUSH
2150: LD_INT 30
2152: PUSH
2153: LD_INT 0
2155: PUSH
2156: EMPTY
2157: LIST
2158: LIST
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: PPUSH
2164: CALL_OW 69
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
2173: LD_ADDR_VAR 0 8
2177: PUSH
2178: LD_INT 22
2180: PUSH
2181: LD_INT 4
2183: PUSH
2184: EMPTY
2185: LIST
2186: LIST
2187: PUSH
2188: LD_INT 30
2190: PUSH
2191: LD_INT 6
2193: PUSH
2194: EMPTY
2195: LIST
2196: LIST
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL_OW 69
2206: PUSH
2207: LD_INT 1
2209: ARRAY
2210: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
2211: LD_ADDR_VAR 0 9
2215: PUSH
2216: LD_INT 22
2218: PUSH
2219: LD_INT 4
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PUSH
2226: LD_INT 30
2228: PUSH
2229: LD_INT 4
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 69
2244: PUSH
2245: LD_INT 1
2247: ARRAY
2248: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
2249: LD_ADDR_VAR 0 10
2253: PUSH
2254: LD_INT 22
2256: PUSH
2257: LD_INT 4
2259: PUSH
2260: EMPTY
2261: LIST
2262: LIST
2263: PUSH
2264: LD_INT 30
2266: PUSH
2267: LD_INT 2
2269: PUSH
2270: EMPTY
2271: LIST
2272: LIST
2273: PUSH
2274: EMPTY
2275: LIST
2276: LIST
2277: PPUSH
2278: CALL_OW 69
2282: PUSH
2283: LD_INT 1
2285: ARRAY
2286: ST_TO_ADDR
// for i in tmp do
2287: LD_ADDR_VAR 0 2
2291: PUSH
2292: LD_VAR 0 6
2296: PUSH
2297: FOR_IN
2298: IFFALSE 2424
// begin cl := GetClass ( i ) ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 2
2309: PPUSH
2310: CALL_OW 257
2314: ST_TO_ADDR
// if cl > 4 then
2315: LD_VAR 0 5
2319: PUSH
2320: LD_INT 4
2322: GREATER
2323: IFFALSE 2333
// cl := 1 ;
2325: LD_ADDR_VAR 0 5
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
2333: LD_ADDR_VAR 0 3
2337: PUSH
2338: LD_VAR 0 9
2342: PUSH
2343: LD_VAR 0 7
2347: PUSH
2348: LD_VAR 0 10
2352: PUSH
2353: LD_VAR 0 8
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_VAR 0 5
2368: ARRAY
2369: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
2370: LD_VAR 0 3
2374: PPUSH
2375: CALL_OW 313
2379: PUSH
2380: LD_INT 5
2382: LESS
2383: IFFALSE 2401
// PlaceHumanInUnit ( i , b ) else
2385: LD_VAR 0 2
2389: PPUSH
2390: LD_VAR 0 3
2394: PPUSH
2395: CALL_OW 52
2399: GO 2422
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 58
2408: PPUSH
2409: LD_INT 91
2411: PPUSH
2412: LD_INT 6
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 50
// end ;
2422: GO 2297
2424: POP
2425: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
2426: LD_INT 2
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: LD_INT 1
2434: PPUSH
2435: LD_INT 12
2437: PPUSH
2438: LD_INT 100
2440: PPUSH
2441: CALL 47616 0 5
// veh := CreateVehicle ;
2445: LD_ADDR_VAR 0 4
2449: PUSH
2450: CALL_OW 45
2454: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2455: LD_VAR 0 4
2459: PPUSH
2460: LD_INT 4
2462: PPUSH
2463: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
2467: LD_VAR 0 4
2471: PPUSH
2472: LD_INT 49
2474: PPUSH
2475: LD_INT 88
2477: PPUSH
2478: LD_INT 0
2480: PPUSH
2481: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
2485: LD_VAR 0 4
2489: PPUSH
2490: LD_INT 1
2492: PPUSH
2493: LD_INT 100
2495: PPUSH
2496: CALL_OW 290
// uc_side := 0 ;
2500: LD_ADDR_OWVAR 20
2504: PUSH
2505: LD_INT 0
2507: ST_TO_ADDR
// uc_nation := 0 ;
2508: LD_ADDR_OWVAR 21
2512: PUSH
2513: LD_INT 0
2515: ST_TO_ADDR
// for i = 1 to 4 do
2516: LD_ADDR_VAR 0 2
2520: PUSH
2521: DOUBLE
2522: LD_INT 1
2524: DEC
2525: ST_TO_ADDR
2526: LD_INT 4
2528: PUSH
2529: FOR_TO
2530: IFFALSE 2561
// begin InitHc ;
2532: CALL_OW 19
// hc_class := class_apeman ;
2536: LD_ADDR_OWVAR 28
2540: PUSH
2541: LD_INT 12
2543: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
2544: CALL_OW 44
2548: PPUSH
2549: LD_INT 14
2551: PPUSH
2552: LD_INT 0
2554: PPUSH
2555: CALL_OW 49
// end ;
2559: GO 2529
2561: POP
2562: POP
// end ; end_of_file
2563: LD_VAR 0 1
2567: RET
// export Kurt , Kozlov ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
2568: LD_INT 0
2570: PPUSH
2571: PPUSH
2572: PPUSH
2573: PPUSH
2574: PPUSH
// side := 8 ;
2575: LD_ADDR_VAR 0 3
2579: PUSH
2580: LD_INT 8
2582: ST_TO_ADDR
// uc_side := side ;
2583: LD_ADDR_OWVAR 20
2587: PUSH
2588: LD_VAR 0 3
2592: ST_TO_ADDR
// uc_nation := 2 ;
2593: LD_ADDR_OWVAR 21
2597: PUSH
2598: LD_INT 2
2600: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
2601: LD_ADDR_VAR 0 2
2605: PUSH
2606: LD_INT 22
2608: PUSH
2609: LD_VAR 0 3
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: LD_INT 21
2620: PUSH
2621: LD_INT 3
2623: PUSH
2624: EMPTY
2625: LIST
2626: LIST
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: PPUSH
2632: CALL_OW 69
2636: PUSH
2637: FOR_IN
2638: IFFALSE 2654
// SetBLevel ( i , 10 ) ;
2640: LD_VAR 0 2
2644: PPUSH
2645: LD_INT 10
2647: PPUSH
2648: CALL_OW 241
2652: GO 2637
2654: POP
2655: POP
// if KurtStatus then
2656: LD_EXP 3
2660: IFFALSE 2683
// Kurt := PrepareUnit ( Kurt , false ,  ) else
2662: LD_ADDR_EXP 40
2666: PUSH
2667: LD_STRING Kurt
2669: PPUSH
2670: LD_INT 0
2672: PPUSH
2673: LD_STRING 
2675: PPUSH
2676: CALL 40983 0 3
2680: ST_TO_ADDR
2681: GO 2705
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
2683: LD_ADDR_EXP 40
2687: PUSH
2688: LD_STRING AltKurt
2690: PPUSH
2691: LD_EXP 1
2695: NOT
2696: PPUSH
2697: LD_STRING 
2699: PPUSH
2700: CALL 40983 0 3
2704: ST_TO_ADDR
// if not Kurt then
2705: LD_EXP 40
2709: NOT
2710: IFFALSE 2736
// begin InitHc ;
2712: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
2716: LD_INT 1
2718: PPUSH
2719: LD_INT 10
2721: PPUSH
2722: CALL_OW 381
// Kurt := CreateHuman ;
2726: LD_ADDR_EXP 40
2730: PUSH
2731: CALL_OW 44
2735: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
2736: LD_EXP 40
2740: PPUSH
2741: LD_INT 324
2743: PPUSH
2744: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
2748: LD_ADDR_EXP 41
2752: PUSH
2753: LD_STRING Kozlov
2755: PPUSH
2756: LD_INT 0
2758: PPUSH
2759: LD_STRING 
2761: PPUSH
2762: CALL 40983 0 3
2766: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
2767: LD_EXP 41
2771: PPUSH
2772: LD_INT 22
2774: PUSH
2775: LD_INT 8
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PUSH
2782: LD_INT 23
2784: PUSH
2785: LD_INT 3
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: PUSH
2792: LD_INT 30
2794: PUSH
2795: LD_INT 8
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: PPUSH
2807: CALL_OW 69
2811: PUSH
2812: LD_INT 1
2814: ARRAY
2815: PPUSH
2816: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
2820: LD_ADDR_VAR 0 5
2824: PUSH
2825: LD_INT 22
2827: PUSH
2828: LD_VAR 0 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 30
2839: PUSH
2840: LD_INT 32
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 58
2849: PUSH
2850: EMPTY
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: PPUSH
2858: CALL_OW 69
2862: ST_TO_ADDR
// for i = 1 to 10 do
2863: LD_ADDR_VAR 0 2
2867: PUSH
2868: DOUBLE
2869: LD_INT 1
2871: DEC
2872: ST_TO_ADDR
2873: LD_INT 10
2875: PUSH
2876: FOR_TO
2877: IFFALSE 2949
// begin uc_nation := nation_nature ;
2879: LD_ADDR_OWVAR 21
2883: PUSH
2884: LD_INT 0
2886: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
2887: LD_ADDR_OWVAR 28
2891: PUSH
2892: LD_INT 15
2894: ST_TO_ADDR
// hc_gallery :=  ;
2895: LD_ADDR_OWVAR 33
2899: PUSH
2900: LD_STRING 
2902: ST_TO_ADDR
// hc_name :=  ;
2903: LD_ADDR_OWVAR 26
2907: PUSH
2908: LD_STRING 
2910: ST_TO_ADDR
// un := CreateHuman ;
2911: LD_ADDR_VAR 0 4
2915: PUSH
2916: CALL_OW 44
2920: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
2921: LD_VAR 0 4
2925: PPUSH
2926: LD_VAR 0 5
2930: PUSH
2931: LD_VAR 0 5
2935: PUSH
2936: LD_VAR 0 2
2940: MINUS
2941: ARRAY
2942: PPUSH
2943: CALL_OW 52
// end ;
2947: GO 2876
2949: POP
2950: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
2951: LD_ADDR_VAR 0 5
2955: PUSH
2956: LD_STRING 12_kurt_squad
2958: PPUSH
2959: CALL_OW 31
2963: ST_TO_ADDR
// if tmp then
2964: LD_VAR 0 5
2968: IFFALSE 3002
// for i in tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: LD_VAR 0 5
2979: PUSH
2980: FOR_IN
2981: IFFALSE 3000
// PlaceUnitArea ( i , legionBaseArea , false ) ;
2983: LD_VAR 0 2
2987: PPUSH
2988: LD_INT 5
2990: PPUSH
2991: LD_INT 0
2993: PPUSH
2994: CALL_OW 49
2998: GO 2980
3000: POP
3001: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
3002: LD_INT 324
3004: PPUSH
3005: LD_INT 5
3007: PPUSH
3008: LD_STRING 
3010: PPUSH
3011: LD_INT 8
3013: PUSH
3014: LD_INT 9
3016: PUSH
3017: LD_INT 10
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: LIST
3024: PUSH
3025: LD_OWVAR 67
3029: ARRAY
3030: PPUSH
3031: LD_INT 3000
3033: PUSH
3034: LD_INT 500
3036: PUSH
3037: LD_INT 150
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: LIST
3044: PPUSH
3045: LD_INT 16
3047: PUSH
3048: LD_INT 6
3050: PUSH
3051: LD_INT 6
3053: PUSH
3054: LD_INT 8
3056: PUSH
3057: EMPTY
3058: LIST
3059: LIST
3060: LIST
3061: LIST
3062: PPUSH
3063: CALL 51025 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
3067: LD_ADDR_EXP 69
3071: PUSH
3072: LD_EXP 69
3076: PPUSH
3077: LD_INT 3
3079: PPUSH
3080: LD_INT 22
3082: PUSH
3083: LD_VAR 0 3
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PUSH
3092: LD_INT 23
3094: PUSH
3095: LD_INT 2
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 21
3107: PUSH
3108: LD_INT 2
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: PPUSH
3124: CALL_OW 69
3128: PUSH
3129: LD_EXP 40
3133: DIFF
3134: PPUSH
3135: CALL_OW 1
3139: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
3140: LD_INT 14
3142: PPUSH
3143: LD_INT 3
3145: PPUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 29
3151: PPUSH
3152: LD_INT 100
3154: PPUSH
3155: CALL 47616 0 5
// powellBomb := CreateVehicle ;
3159: LD_ADDR_EXP 42
3163: PUSH
3164: CALL_OW 45
3168: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
3169: LD_EXP 42
3173: PPUSH
3174: LD_INT 90
3176: PPUSH
3177: LD_INT 51
3179: PPUSH
3180: LD_INT 0
3182: PPUSH
3183: CALL_OW 48
// end ; end_of_file
3187: LD_VAR 0 1
3191: RET
// export Platonov , Kovalyuk ; export function PrepareRussian ; var i , base , tmp , side ; begin
3192: LD_INT 0
3194: PPUSH
3195: PPUSH
3196: PPUSH
3197: PPUSH
3198: PPUSH
// side := 3 ;
3199: LD_ADDR_VAR 0 5
3203: PUSH
3204: LD_INT 3
3206: ST_TO_ADDR
// uc_side := side ;
3207: LD_ADDR_OWVAR 20
3211: PUSH
3212: LD_VAR 0 5
3216: ST_TO_ADDR
// uc_nation := 3 ;
3217: LD_ADDR_OWVAR 21
3221: PUSH
3222: LD_INT 3
3224: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3225: LD_ADDR_VAR 0 2
3229: PUSH
3230: LD_INT 22
3232: PUSH
3233: LD_VAR 0 5
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PUSH
3242: LD_INT 21
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL_OW 69
3260: PUSH
3261: FOR_IN
3262: IFFALSE 3278
// SetBLevel ( i , 10 ) ;
3264: LD_VAR 0 2
3268: PPUSH
3269: LD_INT 10
3271: PPUSH
3272: CALL_OW 241
3276: GO 3261
3278: POP
3279: POP
// Platonov := NewCharacter ( Platonov ) ;
3280: LD_ADDR_EXP 43
3284: PUSH
3285: LD_STRING Platonov
3287: PPUSH
3288: CALL_OW 25
3292: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
3293: LD_ADDR_EXP 44
3297: PUSH
3298: LD_STRING Kovalyuk
3300: PPUSH
3301: CALL_OW 25
3305: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , ru_depot ) ;
3306: LD_EXP 43
3310: PPUSH
3311: LD_INT 126
3313: PPUSH
3314: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
3318: LD_EXP 44
3322: PPUSH
3323: LD_INT 134
3325: PPUSH
3326: CALL_OW 52
// PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 1000 , 300 ] , [ - 1 , 8 , 13 , 8 ] ) ;
3330: LD_INT 126
3332: PPUSH
3333: LD_INT 4
3335: PPUSH
3336: LD_STRING zhukov
3338: PPUSH
3339: LD_INT 9
3341: PUSH
3342: LD_INT 10
3344: PUSH
3345: LD_INT 10
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: LIST
3352: PUSH
3353: LD_OWVAR 67
3357: ARRAY
3358: PPUSH
3359: LD_INT 3000
3361: PUSH
3362: LD_INT 1000
3364: PUSH
3365: LD_INT 300
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: LIST
3372: PPUSH
3373: LD_INT 1
3375: NEG
3376: PUSH
3377: LD_INT 8
3379: PUSH
3380: LD_INT 13
3382: PUSH
3383: LD_INT 8
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: PPUSH
3392: CALL 51025 0 6
// base := GetBase ( ru_depot2 ) ;
3396: LD_ADDR_VAR 0 3
3400: PUSH
3401: LD_INT 267
3403: PPUSH
3404: CALL_OW 274
3408: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 600 ) ;
3409: LD_VAR 0 3
3413: PPUSH
3414: LD_INT 1
3416: PPUSH
3417: LD_INT 600
3419: PPUSH
3420: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
3424: LD_VAR 0 3
3428: PPUSH
3429: LD_INT 2
3431: PPUSH
3432: LD_INT 200
3434: PPUSH
3435: CALL_OW 277
// SetResourceType ( base , mat_siberit , 20 ) ;
3439: LD_VAR 0 3
3443: PPUSH
3444: LD_INT 3
3446: PPUSH
3447: LD_INT 20
3449: PPUSH
3450: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Platonov , Kovalyuk ] ) ;
3454: LD_ADDR_EXP 69
3458: PUSH
3459: LD_EXP 69
3463: PPUSH
3464: LD_INT 2
3466: PPUSH
3467: LD_INT 22
3469: PUSH
3470: LD_VAR 0 5
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: PUSH
3479: LD_INT 3
3481: PUSH
3482: LD_INT 21
3484: PUSH
3485: LD_INT 2
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: PUSH
3492: EMPTY
3493: LIST
3494: LIST
3495: PUSH
3496: EMPTY
3497: LIST
3498: LIST
3499: PPUSH
3500: CALL_OW 69
3504: PUSH
3505: LD_EXP 43
3509: PUSH
3510: LD_EXP 44
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: DIFF
3519: PPUSH
3520: CALL_OW 1
3524: ST_TO_ADDR
// end ; end_of_file
3525: LD_VAR 0 1
3529: RET
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
3530: LD_INT 0
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
// side := 7 ;
3538: LD_ADDR_VAR 0 5
3542: PUSH
3543: LD_INT 7
3545: ST_TO_ADDR
// uc_side := side ;
3546: LD_ADDR_OWVAR 20
3550: PUSH
3551: LD_VAR 0 5
3555: ST_TO_ADDR
// uc_nation := 1 ;
3556: LD_ADDR_OWVAR 21
3560: PUSH
3561: LD_INT 1
3563: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3564: LD_ADDR_VAR 0 2
3568: PUSH
3569: LD_INT 22
3571: PUSH
3572: LD_VAR 0 5
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PUSH
3581: LD_INT 21
3583: PUSH
3584: LD_INT 3
3586: PUSH
3587: EMPTY
3588: LIST
3589: LIST
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PPUSH
3595: CALL_OW 69
3599: PUSH
3600: FOR_IN
3601: IFFALSE 3617
// SetBLevel ( i , 10 ) ;
3603: LD_VAR 0 2
3607: PPUSH
3608: LD_INT 10
3610: PPUSH
3611: CALL_OW 241
3615: GO 3600
3617: POP
3618: POP
// base := GetBase ( al_depot ) ;
3619: LD_ADDR_VAR 0 4
3623: PUSH
3624: LD_INT 2
3626: PPUSH
3627: CALL_OW 274
3631: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
3632: LD_ADDR_VAR 0 6
3636: PUSH
3637: LD_INT 22
3639: PUSH
3640: LD_VAR 0 5
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 30
3651: PUSH
3652: LD_INT 34
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PPUSH
3663: CALL_OW 69
3667: ST_TO_ADDR
// if teleport then
3668: LD_VAR 0 6
3672: IFFALSE 3693
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
3674: LD_VAR 0 6
3678: PUSH
3679: LD_INT 1
3681: ARRAY
3682: PPUSH
3683: LD_INT 262
3685: PPUSH
3686: LD_INT 119
3688: PPUSH
3689: CALL_OW 243
// SetResourceType ( base , mat_cans , 2500 ) ;
3693: LD_VAR 0 4
3697: PPUSH
3698: LD_INT 1
3700: PPUSH
3701: LD_INT 2500
3703: PPUSH
3704: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
3708: LD_VAR 0 4
3712: PPUSH
3713: LD_INT 2
3715: PPUSH
3716: LD_INT 200
3718: PPUSH
3719: CALL_OW 277
// SetResourceType ( base , mat_siberit , 50 ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 3
3730: PPUSH
3731: LD_INT 50
3733: PPUSH
3734: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
3738: LD_ADDR_EXP 45
3742: PUSH
3743: LD_STRING Roth
3745: PPUSH
3746: CALL_OW 25
3750: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
3751: LD_ADDR_EXP 46
3755: PUSH
3756: LD_STRING Simms
3758: PPUSH
3759: LD_EXP 1
3763: NOT
3764: PPUSH
3765: LD_STRING 10c_
3767: PPUSH
3768: CALL 40983 0 3
3772: ST_TO_ADDR
// uc_nation := 3 ;
3773: LD_ADDR_OWVAR 21
3777: PUSH
3778: LD_INT 3
3780: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
3781: LD_ADDR_EXP 47
3785: PUSH
3786: LD_STRING Kirilenkova
3788: PPUSH
3789: CALL_OW 25
3793: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
3794: LD_ADDR_EXP 61
3798: PUSH
3799: LD_STRING Oblukov
3801: PPUSH
3802: CALL_OW 25
3806: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
3807: LD_ADDR_EXP 48
3811: PUSH
3812: LD_STRING Dolgov
3814: PPUSH
3815: CALL_OW 25
3819: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
3820: LD_ADDR_EXP 49
3824: PUSH
3825: LD_STRING Petrosyan
3827: PPUSH
3828: CALL_OW 25
3832: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
3833: LD_ADDR_EXP 60
3837: PUSH
3838: LD_STRING Scholtze
3840: PPUSH
3841: CALL_OW 25
3845: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
3846: LD_ADDR_EXP 59
3850: PUSH
3851: LD_STRING Kapitsova
3853: PPUSH
3854: CALL_OW 25
3858: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
3859: LD_ADDR_EXP 50
3863: PUSH
3864: LD_STRING Petrovova
3866: PPUSH
3867: CALL_OW 25
3871: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
3872: LD_ADDR_EXP 51
3876: PUSH
3877: LD_STRING Kuzmov
3879: PPUSH
3880: CALL_OW 25
3884: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
3885: LD_ADDR_EXP 58
3889: PUSH
3890: LD_STRING Karamazov
3892: PPUSH
3893: CALL_OW 25
3897: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
3898: LD_STRING 13_Lipshchin_1
3900: PPUSH
3901: LD_INT 0
3903: PPUSH
3904: CALL_OW 30
3908: IFFALSE 3923
// Lipshchin := NewCharacter ( Lipshchin ) ;
3910: LD_ADDR_EXP 52
3914: PUSH
3915: LD_STRING Lipshchin
3917: PPUSH
3918: CALL_OW 25
3922: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
3923: LD_STRING 13_Titov_1
3925: PPUSH
3926: LD_INT 0
3928: PPUSH
3929: CALL_OW 30
3933: IFFALSE 3948
// Titov := NewCharacter ( Titov ) ;
3935: LD_ADDR_EXP 54
3939: PUSH
3940: LD_STRING Titov
3942: PPUSH
3943: CALL_OW 25
3947: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
3948: LD_STRING 13_Gnyevko_1
3950: PPUSH
3951: LD_INT 0
3953: PPUSH
3954: CALL_OW 30
3958: IFFALSE 3973
// Gnyevko := NewCharacter ( Gnyevko ) ;
3960: LD_ADDR_EXP 53
3964: PUSH
3965: LD_STRING Gnyevko
3967: PPUSH
3968: CALL_OW 25
3972: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
3973: LD_STRING 13_Xavier_1
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 30
3983: IFFALSE 3998
// Xavier := NewCharacter ( Xavier2 ) ;
3985: LD_ADDR_EXP 55
3989: PUSH
3990: LD_STRING Xavier2
3992: PPUSH
3993: CALL_OW 25
3997: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
3998: LD_STRING 13_Belkov_1
4000: PPUSH
4001: LD_INT 0
4003: PPUSH
4004: CALL_OW 30
4008: IFFALSE 4023
// Belkov := NewCharacter ( Belkov ) ;
4010: LD_ADDR_EXP 56
4014: PUSH
4015: LD_STRING Belkov
4017: PPUSH
4018: CALL_OW 25
4022: ST_TO_ADDR
// if not BurlakStatus then
4023: LD_EXP 9
4027: NOT
4028: IFFALSE 4043
// Burlak = NewCharacter ( Burlak ) ;
4030: LD_ADDR_EXP 57
4034: PUSH
4035: LD_STRING Burlak
4037: PPUSH
4038: CALL_OW 25
4042: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
4043: LD_ADDR_VAR 0 3
4047: PUSH
4048: LD_EXP 45
4052: PUSH
4053: LD_EXP 47
4057: PUSH
4058: LD_EXP 61
4062: PUSH
4063: LD_EXP 48
4067: PUSH
4068: LD_EXP 49
4072: PUSH
4073: LD_EXP 60
4077: PUSH
4078: LD_EXP 59
4082: PUSH
4083: LD_EXP 50
4087: PUSH
4088: LD_EXP 51
4092: PUSH
4093: LD_EXP 58
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: ST_TO_ADDR
// if Simms then
4110: LD_EXP 46
4114: IFFALSE 4132
// tmp := tmp ^ Simms ;
4116: LD_ADDR_VAR 0 3
4120: PUSH
4121: LD_VAR 0 3
4125: PUSH
4126: LD_EXP 46
4130: ADD
4131: ST_TO_ADDR
// if Titov then
4132: LD_EXP 54
4136: IFFALSE 4154
// tmp := tmp ^ Titov ;
4138: LD_ADDR_VAR 0 3
4142: PUSH
4143: LD_VAR 0 3
4147: PUSH
4148: LD_EXP 54
4152: ADD
4153: ST_TO_ADDR
// if Lipshchin then
4154: LD_EXP 52
4158: IFFALSE 4176
// tmp := tmp ^ Lipshchin ;
4160: LD_ADDR_VAR 0 3
4164: PUSH
4165: LD_VAR 0 3
4169: PUSH
4170: LD_EXP 52
4174: ADD
4175: ST_TO_ADDR
// if Gnyevko then
4176: LD_EXP 53
4180: IFFALSE 4198
// tmp := tmp ^ Gnyevko ;
4182: LD_ADDR_VAR 0 3
4186: PUSH
4187: LD_VAR 0 3
4191: PUSH
4192: LD_EXP 53
4196: ADD
4197: ST_TO_ADDR
// if Xavier then
4198: LD_EXP 55
4202: IFFALSE 4220
// tmp := tmp ^ Xavier ;
4204: LD_ADDR_VAR 0 3
4208: PUSH
4209: LD_VAR 0 3
4213: PUSH
4214: LD_EXP 55
4218: ADD
4219: ST_TO_ADDR
// if Belkov then
4220: LD_EXP 56
4224: IFFALSE 4242
// tmp := tmp ^ Belkov ;
4226: LD_ADDR_VAR 0 3
4230: PUSH
4231: LD_VAR 0 3
4235: PUSH
4236: LD_EXP 56
4240: ADD
4241: ST_TO_ADDR
// if Burlak then
4242: LD_EXP 57
4246: IFFALSE 4264
// tmp := tmp ^ Burlak ;
4248: LD_ADDR_VAR 0 3
4252: PUSH
4253: LD_VAR 0 3
4257: PUSH
4258: LD_EXP 57
4262: ADD
4263: ST_TO_ADDR
// for i = 1 to 8 do
4264: LD_ADDR_VAR 0 2
4268: PUSH
4269: DOUBLE
4270: LD_INT 1
4272: DEC
4273: ST_TO_ADDR
4274: LD_INT 8
4276: PUSH
4277: FOR_TO
4278: IFFALSE 4344
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
4280: LD_ADDR_OWVAR 21
4284: PUSH
4285: LD_INT 1
4287: PUSH
4288: LD_INT 3
4290: PUSH
4291: EMPTY
4292: LIST
4293: LIST
4294: PUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_INT 2
4300: PPUSH
4301: CALL_OW 12
4305: ARRAY
4306: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
4307: LD_INT 0
4309: PPUSH
4310: LD_VAR 0 2
4314: PUSH
4315: LD_INT 2
4317: DIV
4318: PPUSH
4319: LD_INT 10
4321: PPUSH
4322: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
4326: LD_ADDR_VAR 0 3
4330: PUSH
4331: LD_VAR 0 3
4335: PUSH
4336: CALL_OW 44
4340: ADD
4341: ST_TO_ADDR
// end ;
4342: GO 4277
4344: POP
4345: POP
// for i in tmp do
4346: LD_ADDR_VAR 0 2
4350: PUSH
4351: LD_VAR 0 3
4355: PUSH
4356: FOR_IN
4357: IFFALSE 4382
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
4359: LD_VAR 0 2
4363: PPUSH
4364: LD_INT 260
4366: PPUSH
4367: LD_INT 235
4369: PPUSH
4370: LD_INT 8
4372: PPUSH
4373: LD_INT 0
4375: PPUSH
4376: CALL_OW 50
4380: GO 4356
4382: POP
4383: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
4384: LD_ADDR_EXP 69
4388: PUSH
4389: LD_EXP 69
4393: PPUSH
4394: LD_INT 1
4396: PPUSH
4397: LD_INT 22
4399: PUSH
4400: LD_VAR 0 5
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 3
4411: PUSH
4412: LD_INT 21
4414: PUSH
4415: LD_INT 2
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PPUSH
4430: CALL_OW 69
4434: PPUSH
4435: CALL_OW 1
4439: ST_TO_ADDR
// end ; end_of_file end_of_file
4440: LD_VAR 0 1
4444: RET
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
4445: LD_INT 0
4447: PPUSH
4448: PPUSH
4449: PPUSH
4450: PPUSH
4451: PPUSH
4452: PPUSH
4453: PPUSH
4454: PPUSH
4455: PPUSH
// Video ( true ) ;
4456: LD_INT 1
4458: PPUSH
4459: CALL 83271 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_INT 8
4470: PPUSH
4471: LD_INT 0
4473: PPUSH
4474: CALL_OW 517
4478: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4479: LD_ADDR_VAR 0 2
4483: PUSH
4484: DOUBLE
4485: LD_INT 1
4487: DEC
4488: ST_TO_ADDR
4489: LD_VAR 0 5
4493: PUSH
4494: LD_INT 1
4496: ARRAY
4497: PUSH
4498: FOR_TO
4499: IFFALSE 4544
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
4501: LD_VAR 0 5
4505: PUSH
4506: LD_INT 1
4508: ARRAY
4509: PUSH
4510: LD_VAR 0 2
4514: ARRAY
4515: PPUSH
4516: LD_VAR 0 5
4520: PUSH
4521: LD_INT 2
4523: ARRAY
4524: PUSH
4525: LD_VAR 0 2
4529: ARRAY
4530: PPUSH
4531: LD_INT 1
4533: PPUSH
4534: LD_INT 15
4536: NEG
4537: PPUSH
4538: CALL 83185 0 4
4542: GO 4498
4544: POP
4545: POP
// CenterNowOnUnits ( Powell ) ;
4546: LD_EXP 38
4550: PPUSH
4551: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
4555: LD_ADDR_VAR 0 5
4559: PUSH
4560: LD_EXP 36
4564: PUSH
4565: EMPTY
4566: LIST
4567: ST_TO_ADDR
// if GirlNewVeh then
4568: LD_EXP 37
4572: IFFALSE 4590
// tmp := tmp ^ GirlNewVeh ;
4574: LD_ADDR_VAR 0 5
4578: PUSH
4579: LD_VAR 0 5
4583: PUSH
4584: LD_EXP 37
4588: ADD
4589: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
4590: LD_VAR 0 5
4594: PPUSH
4595: LD_INT 60
4597: PPUSH
4598: LD_INT 109
4600: PPUSH
4601: CALL_OW 111
// if KappaStatus then
4605: LD_EXP 2
4609: IFFALSE 4661
// begin Say ( JMM , D1T-JMM-1 ) ;
4611: LD_EXP 20
4615: PPUSH
4616: LD_STRING D1T-JMM-1
4618: PPUSH
4619: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
4623: LD_EXP 38
4627: PPUSH
4628: LD_STRING D1T-Pow-1
4630: PPUSH
4631: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
4635: LD_EXP 20
4639: PPUSH
4640: LD_STRING D1T-JMM-2
4642: PPUSH
4643: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
4647: LD_EXP 38
4651: PPUSH
4652: LD_STRING D1T-Pow-2
4654: PPUSH
4655: CALL_OW 88
// end else
4659: GO 4867
// if JMMGirlStatus then
4661: LD_EXP 6
4665: IFFALSE 4810
// begin Say ( JMM , D1T-JMM-1 ) ;
4667: LD_EXP 20
4671: PPUSH
4672: LD_STRING D1T-JMM-1
4674: PPUSH
4675: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
4679: LD_EXP 38
4683: PPUSH
4684: LD_STRING D1T-Pow-1
4686: PPUSH
4687: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
4691: LD_EXP 20
4695: PPUSH
4696: LD_STRING D1T-JMM-3
4698: PPUSH
4699: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
4703: LD_EXP 38
4707: PPUSH
4708: LD_STRING D1T-Pow-3
4710: PPUSH
4711: CALL_OW 88
// if JMMGirl then
4715: LD_EXP 7
4719: IFFALSE 4808
// begin case JMMGirl of 1 :
4721: LD_EXP 7
4725: PUSH
4726: LD_INT 1
4728: DOUBLE
4729: EQUAL
4730: IFTRUE 4734
4732: GO 4749
4734: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
4735: LD_EXP 21
4739: PPUSH
4740: LD_STRING D1T-Joan-3
4742: PPUSH
4743: CALL_OW 88
4747: GO 4796
4749: LD_INT 2
4751: DOUBLE
4752: EQUAL
4753: IFTRUE 4757
4755: GO 4772
4757: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
4758: LD_EXP 23
4762: PPUSH
4763: LD_STRING D1T-Lisa-3
4765: PPUSH
4766: CALL_OW 88
4770: GO 4796
4772: LD_INT 3
4774: DOUBLE
4775: EQUAL
4776: IFTRUE 4780
4778: GO 4795
4780: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
4781: LD_EXP 35
4785: PPUSH
4786: LD_STRING D1T-Con-3
4788: PPUSH
4789: CALL_OW 88
4793: GO 4796
4795: POP
// Say ( Powell , D1T-Pow-4 ) ;
4796: LD_EXP 38
4800: PPUSH
4801: LD_STRING D1T-Pow-4
4803: PPUSH
4804: CALL_OW 88
// end ; end else
4808: GO 4867
// if not FastEnd then
4810: LD_EXP 11
4814: NOT
4815: IFFALSE 4843
// begin Say ( JMM , D1T-JMM-4 ) ;
4817: LD_EXP 20
4821: PPUSH
4822: LD_STRING D1T-JMM-4
4824: PPUSH
4825: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
4829: LD_EXP 38
4833: PPUSH
4834: LD_STRING D1T-Pow-5
4836: PPUSH
4837: CALL_OW 88
// end else
4841: GO 4867
// begin Say ( JMM , D1nT-JMM-1 ) ;
4843: LD_EXP 20
4847: PPUSH
4848: LD_STRING D1nT-JMM-1
4850: PPUSH
4851: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
4855: LD_EXP 38
4859: PPUSH
4860: LD_STRING D1nT-Pow-1
4862: PPUSH
4863: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
4874: LD_EXP 36
4878: PPUSH
4879: CALL_OW 314
4883: NOT
4884: IFFALSE 4867
// ComExitVehicle ( JMM ) ;
4886: LD_EXP 20
4890: PPUSH
4891: CALL_OW 121
// wait ( 3 ) ;
4895: LD_INT 3
4897: PPUSH
4898: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
4902: LD_EXP 20
4906: PPUSH
4907: LD_INT 60
4909: PPUSH
4910: LD_INT 94
4912: PPUSH
4913: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
4917: LD_EXP 20
4921: PPUSH
4922: LD_EXP 38
4926: PPUSH
4927: CALL_OW 179
// if JMMGirl and JMMGirlStatus and not KappaStatus then
4931: LD_EXP 7
4935: PUSH
4936: LD_EXP 6
4940: AND
4941: PUSH
4942: LD_EXP 2
4946: NOT
4947: AND
4948: IFFALSE 5051
// begin AddComExitVehicle ( [ Joan , Lisa , Connie ] [ JMMGirl ] ) ;
4950: LD_EXP 21
4954: PUSH
4955: LD_EXP 23
4959: PUSH
4960: LD_EXP 35
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_EXP 7
4974: ARRAY
4975: PPUSH
4976: CALL_OW 181
// AddComMoveXY ( [ Joan , Lisa , Connie ] [ JMMGirl ] , 64 , 102 ) ;
4980: LD_EXP 21
4984: PUSH
4985: LD_EXP 23
4989: PUSH
4990: LD_EXP 35
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: LIST
4999: PUSH
5000: LD_EXP 7
5004: ARRAY
5005: PPUSH
5006: LD_INT 64
5008: PPUSH
5009: LD_INT 102
5011: PPUSH
5012: CALL_OW 171
// AddComTurnUnit ( [ Joan , Lisa , Connie ] [ JMMGirl ] , JMM ) ;
5016: LD_EXP 21
5020: PUSH
5021: LD_EXP 23
5025: PUSH
5026: LD_EXP 35
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: LD_EXP 7
5040: ARRAY
5041: PPUSH
5042: LD_EXP 20
5046: PPUSH
5047: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
5051: LD_INT 35
5053: PPUSH
5054: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
5058: LD_EXP 20
5062: PPUSH
5063: LD_EXP 38
5067: PPUSH
5068: CALL_OW 296
5072: PUSH
5073: LD_INT 6
5075: LESS
5076: IFFALSE 5051
// wait ( 0 0$0.5 ) ;
5078: LD_INT 18
5080: PPUSH
5081: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
5085: LD_EXP 20
5089: PPUSH
5090: LD_STRING D1-JMM-1
5092: PPUSH
5093: CALL_OW 88
// async ;
5097: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
5098: LD_EXP 38
5102: PPUSH
5103: LD_STRING D1-Pow-1
5105: PPUSH
5106: CALL_OW 88
// if not dialogue_skipped then
5110: LD_OWVAR 59
5114: NOT
5115: IFFALSE 5124
// wait ( 0 0$2 ) ;
5117: LD_INT 70
5119: PPUSH
5120: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
5124: LD_INT 170
5126: PPUSH
5127: LD_INT 99
5129: PPUSH
5130: LD_INT 1
5132: PPUSH
5133: LD_INT 6
5135: NEG
5136: PPUSH
5137: CALL 83185 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
5141: LD_INT 174
5143: PPUSH
5144: LD_INT 115
5146: PPUSH
5147: LD_INT 1
5149: PPUSH
5150: LD_INT 6
5152: NEG
5153: PPUSH
5154: CALL 83185 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
5158: LD_INT 169
5160: PPUSH
5161: LD_INT 71
5163: PPUSH
5164: LD_INT 1
5166: PPUSH
5167: LD_INT 6
5169: NEG
5170: PPUSH
5171: CALL 83185 0 4
// if not dialogue_skipped then
5175: LD_OWVAR 59
5179: NOT
5180: IFFALSE 5199
// begin CenterOnXY ( 170 , 99 ) ;
5182: LD_INT 170
5184: PPUSH
5185: LD_INT 99
5187: PPUSH
5188: CALL_OW 84
// wait ( 0 0$2.3 ) ;
5192: LD_INT 80
5194: PPUSH
5195: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
5199: LD_INT 75
5201: PPUSH
5202: LD_INT 53
5204: PPUSH
5205: LD_INT 1
5207: PPUSH
5208: LD_INT 9
5210: NEG
5211: PPUSH
5212: CALL 83185 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
5216: LD_INT 54
5218: PPUSH
5219: LD_INT 42
5221: PPUSH
5222: LD_INT 1
5224: PPUSH
5225: LD_INT 9
5227: NEG
5228: PPUSH
5229: CALL 83185 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
5233: LD_INT 62
5235: PPUSH
5236: LD_INT 51
5238: PPUSH
5239: LD_INT 1
5241: PPUSH
5242: LD_INT 9
5244: NEG
5245: PPUSH
5246: CALL 83185 0 4
// if not dialogue_skipped then
5250: LD_OWVAR 59
5254: NOT
5255: IFFALSE 5274
// begin CenterOnXY ( 75 , 53 ) ;
5257: LD_INT 75
5259: PPUSH
5260: LD_INT 53
5262: PPUSH
5263: CALL_OW 84
// wait ( 0 0$4 ) ;
5267: LD_INT 140
5269: PPUSH
5270: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
5274: LD_EXP 38
5278: PPUSH
5279: CALL_OW 87
// if not dialogue_skipped then
5283: LD_OWVAR 59
5287: NOT
5288: IFFALSE 5297
// wait ( 0 0$2 ) ;
5290: LD_INT 70
5292: PPUSH
5293: CALL_OW 67
// sync ;
5297: SYNC
// Say ( JMM , D1-JMM-2 ) ;
5298: LD_EXP 20
5302: PPUSH
5303: LD_STRING D1-JMM-2
5305: PPUSH
5306: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
5310: LD_EXP 38
5314: PPUSH
5315: LD_STRING D1-Pow-2
5317: PPUSH
5318: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
5322: LD_EXP 20
5326: PPUSH
5327: LD_STRING D1-JMM-3
5329: PPUSH
5330: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
5334: LD_EXP 38
5338: PPUSH
5339: LD_STRING D1-Pow-3
5341: PPUSH
5342: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
5346: LD_EXP 20
5350: PPUSH
5351: LD_STRING D1-JMM-4
5353: PPUSH
5354: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
5358: LD_EXP 38
5362: PPUSH
5363: LD_STRING D1-Pow-4
5365: PPUSH
5366: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
5370: LD_EXP 20
5374: PPUSH
5375: LD_STRING D1-JMM-5
5377: PPUSH
5378: CALL_OW 88
// async ;
5382: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
5383: LD_EXP 38
5387: PPUSH
5388: LD_STRING D1-Pow-5
5390: PPUSH
5391: CALL_OW 88
// if not dialogue_skipped then
5395: LD_OWVAR 59
5399: NOT
5400: IFFALSE 5409
// wait ( 0 0$3.6 ) ;
5402: LD_INT 126
5404: PPUSH
5405: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
5409: LD_INT 134
5411: PPUSH
5412: LD_INT 210
5414: PPUSH
5415: LD_INT 1
5417: PPUSH
5418: LD_INT 11
5420: NEG
5421: PPUSH
5422: CALL 83185 0 4
// if not dialogue_skipped then
5426: LD_OWVAR 59
5430: NOT
5431: IFFALSE 5450
// begin CenterOnXY ( 134 , 210 ) ;
5433: LD_INT 134
5435: PPUSH
5436: LD_INT 210
5438: PPUSH
5439: CALL_OW 84
// wait ( 0 0$2 ) ;
5443: LD_INT 70
5445: PPUSH
5446: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
5450: LD_INT 101
5452: PPUSH
5453: LD_INT 159
5455: PPUSH
5456: LD_INT 1
5458: PPUSH
5459: LD_INT 10
5461: NEG
5462: PPUSH
5463: CALL 83185 0 4
// if not dialogue_skipped then
5467: LD_OWVAR 59
5471: NOT
5472: IFFALSE 5491
// begin CenterOnXY ( 101 , 159 ) ;
5474: LD_INT 101
5476: PPUSH
5477: LD_INT 159
5479: PPUSH
5480: CALL_OW 84
// wait ( 0 0$2 ) ;
5484: LD_INT 70
5486: PPUSH
5487: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
5491: LD_EXP 38
5495: PPUSH
5496: CALL_OW 87
// if not dialogue_skipped then
5500: LD_OWVAR 59
5504: NOT
5505: IFFALSE 5514
// wait ( 0 0$6 ) ;
5507: LD_INT 210
5509: PPUSH
5510: CALL_OW 67
// sync ;
5514: SYNC
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
5515: LD_ADDR_VAR 0 6
5519: PUSH
5520: LD_INT 1
5522: PUSH
5523: LD_INT 2
5525: PUSH
5526: LD_INT 3
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 6
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: LIST
5544: LIST
5545: ST_TO_ADDR
// if not dialogue_skipped then
5546: LD_OWVAR 59
5550: NOT
5551: IFFALSE 5705
// begin dec = SelectiveQuery ( Q1 , options ) ;
5553: LD_ADDR_VAR 0 7
5557: PUSH
5558: LD_STRING Q1
5560: PPUSH
5561: LD_VAR 0 6
5565: PPUSH
5566: CALL_OW 98
5570: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
5571: LD_ADDR_VAR 0 7
5575: PUSH
5576: LD_STRING Q1
5578: PPUSH
5579: LD_VAR 0 6
5583: PPUSH
5584: CALL_OW 98
5588: ST_TO_ADDR
// options = options diff dec ;
5589: LD_ADDR_VAR 0 6
5593: PUSH
5594: LD_VAR 0 6
5598: PUSH
5599: LD_VAR 0 7
5603: DIFF
5604: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
5605: LD_VAR 0 7
5609: PPUSH
5610: LD_VAR 0 6
5614: PPUSH
5615: CALL 7001 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
5619: LD_VAR 0 7
5623: PUSH
5624: LD_INT 5
5626: PUSH
5627: LD_INT 6
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: IN
5634: PUSH
5635: LD_VAR 0 6
5639: PUSH
5640: LD_INT 2
5642: EQUAL
5643: OR
5644: IFFALSE 5571
// if not ( dec in [ 5 , 6 ] ) then
5646: LD_VAR 0 7
5650: PUSH
5651: LD_INT 5
5653: PUSH
5654: LD_INT 6
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: IN
5661: NOT
5662: IFFALSE 5705
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
5664: LD_ADDR_VAR 0 7
5668: PUSH
5669: LD_STRING Q1a
5671: PPUSH
5672: LD_INT 1
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PPUSH
5682: CALL_OW 98
5686: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
5687: LD_VAR 0 7
5691: PUSH
5692: LD_INT 4
5694: PLUS
5695: PPUSH
5696: LD_VAR 0 6
5700: PPUSH
5701: CALL 7001 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
5705: LD_INT 81
5707: PPUSH
5708: LD_INT 127
5710: PPUSH
5711: CALL_OW 84
// amount := 5 ;
5715: LD_ADDR_VAR 0 8
5719: PUSH
5720: LD_INT 5
5722: ST_TO_ADDR
// macmilan_squad := [ ] ;
5723: LD_ADDR_VAR 0 9
5727: PUSH
5728: EMPTY
5729: ST_TO_ADDR
// if vip < amount then
5730: LD_EXP 39
5734: PUSH
5735: LD_VAR 0 8
5739: LESS
5740: IFFALSE 5784
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
5742: LD_ADDR_VAR 0 5
5746: PUSH
5747: LD_EXP 39
5751: PUSH
5752: LD_INT 22
5754: PUSH
5755: LD_INT 4
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 21
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL_OW 69
5780: UNION
5781: ST_TO_ADDR
5782: GO 5794
// tmp := vip ;
5784: LD_ADDR_VAR 0 5
5788: PUSH
5789: LD_EXP 39
5793: ST_TO_ADDR
// tmp := tmp diff Powell ;
5794: LD_ADDR_VAR 0 5
5798: PUSH
5799: LD_VAR 0 5
5803: PUSH
5804: LD_EXP 38
5808: DIFF
5809: ST_TO_ADDR
// if tmp < amount then
5810: LD_VAR 0 5
5814: PUSH
5815: LD_VAR 0 8
5819: LESS
5820: IFFALSE 5832
// amount := tmp ;
5822: LD_ADDR_VAR 0 8
5826: PUSH
5827: LD_VAR 0 5
5831: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
5832: LD_VAR 0 5
5836: PUSH
5837: LD_INT 1
5839: ARRAY
5840: PPUSH
5841: CALL_OW 257
5845: PUSH
5846: LD_INT 2
5848: NONEQUAL
5849: IFFALSE 5911
// begin if IsInUnit ( tmp [ 1 ] ) then
5851: LD_VAR 0 5
5855: PUSH
5856: LD_INT 1
5858: ARRAY
5859: PPUSH
5860: CALL_OW 310
5864: IFFALSE 5879
// ComExitBuilding ( tmp [ 1 ] ) ;
5866: LD_VAR 0 5
5870: PUSH
5871: LD_INT 1
5873: ARRAY
5874: PPUSH
5875: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
5879: LD_VAR 0 5
5883: PUSH
5884: LD_INT 1
5886: ARRAY
5887: PPUSH
5888: LD_INT 387
5890: PPUSH
5891: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
5895: LD_VAR 0 5
5899: PUSH
5900: LD_INT 1
5902: ARRAY
5903: PPUSH
5904: LD_INT 2
5906: PPUSH
5907: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
5911: LD_EXP 20
5915: PPUSH
5916: LD_INT 82
5918: PPUSH
5919: LD_INT 129
5921: PPUSH
5922: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
5926: LD_EXP 20
5930: PPUSH
5931: LD_EXP 38
5935: PPUSH
5936: CALL_OW 179
// if KappaStatus and JMMGirlStatus and JMMGirl then
5940: LD_EXP 2
5944: PUSH
5945: LD_EXP 6
5949: AND
5950: PUSH
5951: LD_EXP 7
5955: AND
5956: IFFALSE 6029
// begin ComMoveXY ( [ Joan , Lisa , Connie ] [ JMMGirl ] , 84 , 128 ) ;
5958: LD_EXP 21
5962: PUSH
5963: LD_EXP 23
5967: PUSH
5968: LD_EXP 35
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_EXP 7
5982: ARRAY
5983: PPUSH
5984: LD_INT 84
5986: PPUSH
5987: LD_INT 128
5989: PPUSH
5990: CALL_OW 111
// AddComTurnUnit ( [ Joan , Lisa , Connie ] [ JMMGirl ] , JMM ) ;
5994: LD_EXP 21
5998: PUSH
5999: LD_EXP 23
6003: PUSH
6004: LD_EXP 35
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: PUSH
6014: LD_EXP 7
6018: ARRAY
6019: PPUSH
6020: LD_EXP 20
6024: PPUSH
6025: CALL_OW 179
// end ; for i = 1 to amount do
6029: LD_ADDR_VAR 0 2
6033: PUSH
6034: DOUBLE
6035: LD_INT 1
6037: DEC
6038: ST_TO_ADDR
6039: LD_VAR 0 8
6043: PUSH
6044: FOR_TO
6045: IFFALSE 6213
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
6047: LD_ADDR_VAR 0 9
6051: PUSH
6052: LD_VAR 0 9
6056: PUSH
6057: LD_VAR 0 5
6061: PUSH
6062: LD_VAR 0 2
6066: ARRAY
6067: ADD
6068: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
6069: LD_VAR 0 5
6073: PUSH
6074: LD_VAR 0 2
6078: ARRAY
6079: PPUSH
6080: CALL_OW 310
6084: IFFALSE 6101
// AddComExitBuilding ( tmp [ i ] ) ;
6086: LD_VAR 0 5
6090: PUSH
6091: LD_VAR 0 2
6095: ARRAY
6096: PPUSH
6097: CALL_OW 182
// if i = 2 and JMMNewVeh then
6101: LD_VAR 0 2
6105: PUSH
6106: LD_INT 2
6108: EQUAL
6109: PUSH
6110: LD_EXP 36
6114: AND
6115: IFFALSE 6173
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
6117: LD_VAR 0 5
6121: PUSH
6122: LD_VAR 0 2
6126: ARRAY
6127: PPUSH
6128: LD_EXP 36
6132: PPUSH
6133: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
6137: LD_VAR 0 5
6141: PUSH
6142: LD_VAR 0 2
6146: ARRAY
6147: PPUSH
6148: LD_INT 86
6150: PPUSH
6151: LD_INT 133
6153: PPUSH
6154: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
6158: LD_VAR 0 5
6162: PUSH
6163: LD_VAR 0 2
6167: ARRAY
6168: PPUSH
6169: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
6173: LD_VAR 0 5
6177: PUSH
6178: LD_VAR 0 2
6182: ARRAY
6183: PPUSH
6184: LD_INT 9
6186: PPUSH
6187: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
6191: LD_VAR 0 5
6195: PUSH
6196: LD_VAR 0 2
6200: ARRAY
6201: PPUSH
6202: LD_EXP 20
6206: PPUSH
6207: CALL_OW 179
// end ;
6211: GO 6044
6213: POP
6214: POP
// if GirlNewVeh then
6215: LD_EXP 37
6219: IFFALSE 6233
// SetSide ( GirlNewVeh , 4 ) ;
6221: LD_EXP 37
6225: PPUSH
6226: LD_INT 4
6228: PPUSH
6229: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
6233: LD_INT 35
6235: PPUSH
6236: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
6240: LD_VAR 0 9
6244: PPUSH
6245: LD_INT 95
6247: PUSH
6248: LD_INT 10
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PPUSH
6255: CALL_OW 72
6259: PUSH
6260: LD_INT 0
6262: EQUAL
6263: PUSH
6264: LD_EXP 20
6268: PPUSH
6269: LD_INT 10
6271: PPUSH
6272: CALL_OW 308
6276: NOT
6277: AND
6278: IFFALSE 6233
// wait ( 0 0$2 ) ;
6280: LD_INT 70
6282: PPUSH
6283: CALL_OW 67
// for i in macmilan_squad do
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_VAR 0 9
6296: PUSH
6297: FOR_IN
6298: IFFALSE 6314
// SetSide ( i , 1 ) ;
6300: LD_VAR 0 2
6304: PPUSH
6305: LD_INT 1
6307: PPUSH
6308: CALL_OW 235
6312: GO 6297
6314: POP
6315: POP
// SetSide ( JMMNewVeh , 1 ) ;
6316: LD_EXP 36
6320: PPUSH
6321: LD_INT 1
6323: PPUSH
6324: CALL_OW 235
// Video ( false ) ;
6328: LD_INT 0
6330: PPUSH
6331: CALL 83271 0 1
// ChangeMissionObjectives ( M1 ) ;
6335: LD_STRING M1
6337: PPUSH
6338: CALL_OW 337
// SaveForQuickRestart ;
6342: CALL_OW 22
// missionStart := true ;
6346: LD_ADDR_EXP 12
6350: PUSH
6351: LD_INT 1
6353: ST_TO_ADDR
// missionStage := 2 ;
6354: LD_ADDR_EXP 14
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// wait ( 0 0$3 ) ;
6362: LD_INT 105
6364: PPUSH
6365: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
6369: LD_ADDR_VAR 0 5
6373: PUSH
6374: LD_VAR 0 5
6378: PUSH
6379: LD_INT 22
6381: PUSH
6382: LD_INT 1
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PUSH
6389: LD_INT 21
6391: PUSH
6392: LD_INT 1
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: PPUSH
6403: CALL_OW 69
6407: DIFF
6408: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
6409: LD_ADDR_EXP 69
6413: PUSH
6414: LD_EXP 69
6418: PPUSH
6419: LD_INT 4
6421: PPUSH
6422: LD_INT 22
6424: PUSH
6425: LD_INT 4
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: LD_INT 23
6434: PUSH
6435: LD_INT 1
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: LIST
6463: PPUSH
6464: CALL_OW 69
6468: PUSH
6469: LD_EXP 38
6473: DIFF
6474: PPUSH
6475: CALL_OW 1
6479: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
6480: LD_ADDR_VAR 0 4
6484: PUSH
6485: LD_INT 22
6487: PUSH
6488: LD_INT 4
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: PUSH
6495: LD_INT 34
6497: PUSH
6498: LD_INT 12
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PPUSH
6509: CALL_OW 69
6513: PUSH
6514: LD_INT 1
6516: ARRAY
6517: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
6518: LD_VAR 0 5
6522: PUSH
6523: LD_INT 1
6525: ARRAY
6526: PPUSH
6527: CALL_OW 310
6531: IFFALSE 6546
// ComExitBuilding ( tmp [ 1 ] ) ;
6533: LD_VAR 0 5
6537: PUSH
6538: LD_INT 1
6540: ARRAY
6541: PPUSH
6542: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
6546: LD_VAR 0 5
6550: PUSH
6551: LD_INT 1
6553: ARRAY
6554: PPUSH
6555: LD_VAR 0 4
6559: PPUSH
6560: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
6564: LD_VAR 0 5
6568: PUSH
6569: LD_INT 1
6571: ARRAY
6572: PPUSH
6573: LD_INT 80
6575: PPUSH
6576: LD_INT 136
6578: PPUSH
6579: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
6583: LD_VAR 0 5
6587: PUSH
6588: LD_INT 1
6590: ARRAY
6591: PPUSH
6592: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
6596: LD_VAR 0 5
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: LD_INT 59
6607: PPUSH
6608: LD_INT 112
6610: PPUSH
6611: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
6615: LD_VAR 0 5
6619: PUSH
6620: LD_INT 1
6622: ARRAY
6623: PPUSH
6624: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
6628: LD_EXP 23
6632: PUSH
6633: LD_EXP 39
6637: IN
6638: PUSH
6639: LD_EXP 23
6643: PPUSH
6644: CALL_OW 255
6648: PUSH
6649: LD_INT 1
6651: EQUAL
6652: AND
6653: IFFALSE 6669
// Say ( Lisa , D3nW-Lisa-1 ) else
6655: LD_EXP 23
6659: PPUSH
6660: LD_STRING D3nW-Lisa-1
6662: PPUSH
6663: CALL_OW 88
6667: GO 6913
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
6669: LD_EXP 26
6673: PUSH
6674: LD_EXP 39
6678: IN
6679: PUSH
6680: LD_EXP 26
6684: PPUSH
6685: CALL_OW 255
6689: PUSH
6690: LD_INT 1
6692: EQUAL
6693: AND
6694: IFFALSE 6710
// Say ( Cyrus , D3nW-Cyrus-1 ) else
6696: LD_EXP 26
6700: PPUSH
6701: LD_STRING D3nW-Cyrus-1
6703: PPUSH
6704: CALL_OW 88
6708: GO 6913
// if Bobby in vip and GetSide ( Bobby ) = 1 then
6710: LD_EXP 25
6714: PUSH
6715: LD_EXP 39
6719: IN
6720: PUSH
6721: LD_EXP 25
6725: PPUSH
6726: CALL_OW 255
6730: PUSH
6731: LD_INT 1
6733: EQUAL
6734: AND
6735: IFFALSE 6751
// Say ( Bobby , D3nW-Bobby-1 ) else
6737: LD_EXP 25
6741: PPUSH
6742: LD_STRING D3nW-Bobby-1
6744: PPUSH
6745: CALL_OW 88
6749: GO 6913
// if Gary in vip and GetSide ( Gary ) = 1 then
6751: LD_EXP 32
6755: PUSH
6756: LD_EXP 39
6760: IN
6761: PUSH
6762: LD_EXP 32
6766: PPUSH
6767: CALL_OW 255
6771: PUSH
6772: LD_INT 1
6774: EQUAL
6775: AND
6776: IFFALSE 6792
// Say ( Gary , D3nW-Gary-1 ) else
6778: LD_EXP 32
6782: PPUSH
6783: LD_STRING D3nW-Gary-1
6785: PPUSH
6786: CALL_OW 88
6790: GO 6913
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
6792: LD_EXP 24
6796: PUSH
6797: LD_EXP 39
6801: IN
6802: PUSH
6803: LD_EXP 24
6807: PPUSH
6808: CALL_OW 255
6812: PUSH
6813: LD_INT 1
6815: EQUAL
6816: AND
6817: IFFALSE 6833
// Say ( Donaldson , D3nW-Don-1 ) else
6819: LD_EXP 24
6823: PPUSH
6824: LD_STRING D3nW-Don-1
6826: PPUSH
6827: CALL_OW 88
6831: GO 6913
// if Cornel in vip and GetSide ( Cornel ) = 1 then
6833: LD_EXP 31
6837: PUSH
6838: LD_EXP 39
6842: IN
6843: PUSH
6844: LD_EXP 31
6848: PPUSH
6849: CALL_OW 255
6853: PUSH
6854: LD_INT 1
6856: EQUAL
6857: AND
6858: IFFALSE 6874
// Say ( Cornel , D3nW-Corn-1 ) else
6860: LD_EXP 31
6864: PPUSH
6865: LD_STRING D3nW-Corn-1
6867: PPUSH
6868: CALL_OW 88
6872: GO 6913
// if Frank in vip and GetSide ( Frank ) = 1 then
6874: LD_EXP 33
6878: PUSH
6879: LD_EXP 39
6883: IN
6884: PUSH
6885: LD_EXP 33
6889: PPUSH
6890: CALL_OW 255
6894: PUSH
6895: LD_INT 1
6897: EQUAL
6898: AND
6899: IFFALSE 6913
// Say ( Frank , D3nW-Frank-1 ) ;
6901: LD_EXP 33
6905: PPUSH
6906: LD_STRING D3nW-Frank-1
6908: PPUSH
6909: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
6913: LD_EXP 20
6917: PPUSH
6918: LD_STRING D3nW-JMM-1
6920: PPUSH
6921: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
6925: LD_EXP 20
6929: PPUSH
6930: LD_STRING D3nW-JMM-1a
6932: PPUSH
6933: CALL_OW 88
// t := 0 0$00 ;
6937: LD_ADDR_VAR 0 3
6941: PUSH
6942: LD_INT 0
6944: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6945: LD_INT 35
6947: PPUSH
6948: CALL_OW 67
// t := t + 0 0$1 ;
6952: LD_ADDR_VAR 0 3
6956: PUSH
6957: LD_VAR 0 3
6961: PUSH
6962: LD_INT 35
6964: PLUS
6965: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
6966: LD_INT 59
6968: PPUSH
6969: LD_INT 112
6971: PPUSH
6972: CALL_OW 428
6976: PUSH
6977: LD_VAR 0 3
6981: PUSH
6982: LD_INT 2100
6984: GREATER
6985: OR
6986: IFFALSE 6945
// activeAttacks := true ;
6988: LD_ADDR_EXP 15
6992: PUSH
6993: LD_INT 1
6995: ST_TO_ADDR
// end ;
6996: LD_VAR 0 1
7000: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
7001: LD_INT 0
7003: PPUSH
// case question of 1 :
7004: LD_VAR 0 1
7008: PUSH
7009: LD_INT 1
7011: DOUBLE
7012: EQUAL
7013: IFTRUE 7017
7015: GO 7068
7017: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
7018: LD_EXP 20
7022: PPUSH
7023: LD_STRING D2Mot-JMM-1
7025: PPUSH
7026: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
7030: LD_EXP 38
7034: PPUSH
7035: LD_STRING D2Mot-Pow-1
7037: PPUSH
7038: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
7042: LD_EXP 20
7046: PPUSH
7047: LD_STRING D2Mot-JMM-2
7049: PPUSH
7050: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
7054: LD_EXP 38
7058: PPUSH
7059: LD_STRING D2Mot-Pow-2
7061: PPUSH
7062: CALL_OW 88
// end ; 2 :
7066: GO 7411
7068: LD_INT 2
7070: DOUBLE
7071: EQUAL
7072: IFTRUE 7076
7074: GO 7152
7076: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
7077: LD_EXP 20
7081: PPUSH
7082: LD_STRING D2Rus-JMM-1
7084: PPUSH
7085: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
7089: LD_EXP 38
7093: PPUSH
7094: LD_STRING D2Rus-Pow-1
7096: PPUSH
7097: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
7101: LD_EXP 20
7105: PPUSH
7106: LD_STRING D2Rus-JMM-2
7108: PPUSH
7109: CALL_OW 88
// if not ( 3 in list_of_q ) then
7113: LD_INT 3
7115: PUSH
7116: LD_VAR 0 2
7120: IN
7121: NOT
7122: IFFALSE 7138
// Say ( Powell , D2Rus-Pow-2 ) else
7124: LD_EXP 38
7128: PPUSH
7129: LD_STRING D2Rus-Pow-2
7131: PPUSH
7132: CALL_OW 88
7136: GO 7150
// Say ( Powell , D2Rus-Pow-2a ) ;
7138: LD_EXP 38
7142: PPUSH
7143: LD_STRING D2Rus-Pow-2a
7145: PPUSH
7146: CALL_OW 88
// end ; 3 :
7150: GO 7411
7152: LD_INT 3
7154: DOUBLE
7155: EQUAL
7156: IFTRUE 7160
7158: GO 7245
7160: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
7161: LD_EXP 20
7165: PPUSH
7166: LD_STRING D2Leg-JMM-1
7168: PPUSH
7169: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
7173: LD_EXP 38
7177: PPUSH
7178: LD_STRING D2Leg-Pow-1
7180: PPUSH
7181: CALL_OW 88
// if 2 in list_of_q then
7185: LD_INT 2
7187: PUSH
7188: LD_VAR 0 2
7192: IN
7193: IFFALSE 7219
// begin Say ( JMM , D2Leg-JMM-2 ) ;
7195: LD_EXP 20
7199: PPUSH
7200: LD_STRING D2Leg-JMM-2
7202: PPUSH
7203: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
7207: LD_EXP 38
7211: PPUSH
7212: LD_STRING D2Leg-Pow-2
7214: PPUSH
7215: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
7219: LD_EXP 20
7223: PPUSH
7224: LD_STRING D2Leg-JMM-3
7226: PPUSH
7227: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
7231: LD_EXP 38
7235: PPUSH
7236: LD_STRING D2Leg-Pow-3
7238: PPUSH
7239: CALL_OW 88
// end ; 4 :
7243: GO 7411
7245: LD_INT 4
7247: DOUBLE
7248: EQUAL
7249: IFTRUE 7253
7251: GO 7328
7253: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
7254: LD_EXP 20
7258: PPUSH
7259: LD_STRING D2Ar-JMM-1
7261: PPUSH
7262: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
7266: LD_EXP 38
7270: PPUSH
7271: LD_STRING D2Ar-Pow-1
7273: PPUSH
7274: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
7278: LD_EXP 20
7282: PPUSH
7283: LD_STRING D2Ar-JMM-2
7285: PPUSH
7286: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
7290: LD_EXP 38
7294: PPUSH
7295: LD_STRING D2Ar-Pow-2
7297: PPUSH
7298: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
7302: LD_EXP 20
7306: PPUSH
7307: LD_STRING D2Ar-JMM-3
7309: PPUSH
7310: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
7314: LD_EXP 38
7318: PPUSH
7319: LD_STRING D2Ar-Pow-3
7321: PPUSH
7322: CALL_OW 88
// end ; 5 :
7326: GO 7411
7328: LD_INT 5
7330: DOUBLE
7331: EQUAL
7332: IFTRUE 7336
7334: GO 7351
7336: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
7337: LD_EXP 20
7341: PPUSH
7342: LD_STRING D2Conf-JMM-1
7344: PPUSH
7345: CALL_OW 88
7349: GO 7411
7351: LD_INT 6
7353: DOUBLE
7354: EQUAL
7355: IFTRUE 7359
7357: GO 7410
7359: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
7360: LD_EXP 20
7364: PPUSH
7365: LD_STRING D2Com-JMM-1
7367: PPUSH
7368: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
7372: LD_EXP 38
7376: PPUSH
7377: LD_STRING D2Com-Pow-1
7379: PPUSH
7380: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
7384: LD_EXP 20
7388: PPUSH
7389: LD_STRING D2Com-JMM-2
7391: PPUSH
7392: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
7396: LD_EXP 38
7400: PPUSH
7401: LD_STRING D2Com-Pow-2
7403: PPUSH
7404: CALL_OW 88
// end ; end ;
7408: GO 7411
7410: POP
// end ;
7411: LD_VAR 0 3
7415: RET
// every 0 0$5 trigger missionStart do var tmp ;
7416: LD_EXP 12
7420: IFFALSE 7703
7422: GO 7424
7424: DISABLE
7425: LD_INT 0
7427: PPUSH
// begin repeat wait ( 0 0$1 ) ;
7428: LD_INT 35
7430: PPUSH
7431: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
7435: LD_INT 15
7437: PPUSH
7438: LD_INT 22
7440: PUSH
7441: LD_INT 1
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PPUSH
7448: CALL_OW 70
7452: PUSH
7453: LD_EXP 14
7457: PUSH
7458: LD_INT 2
7460: PUSH
7461: LD_INT 3
7463: PUSH
7464: LD_INT 4
7466: PUSH
7467: LD_INT 5
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: LIST
7475: IN
7476: AND
7477: IFFALSE 7693
// begin powellAnger := powellAnger + 1 ;
7479: LD_ADDR_EXP 16
7483: PUSH
7484: LD_EXP 16
7488: PUSH
7489: LD_INT 1
7491: PLUS
7492: ST_TO_ADDR
// Video ( true ) ;
7493: LD_INT 1
7495: PPUSH
7496: CALL 83271 0 1
// CenterNowOnUnits ( tmp ) ;
7500: LD_VAR 0 1
7504: PPUSH
7505: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
7509: LD_INT 15
7511: PPUSH
7512: LD_INT 22
7514: PUSH
7515: LD_INT 1
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PPUSH
7522: CALL_OW 70
7526: PPUSH
7527: LD_INT 86
7529: PPUSH
7530: LD_INT 133
7532: PPUSH
7533: CALL_OW 111
// async ;
7537: ASYNC
// case powellAnger of 1 :
7538: LD_EXP 16
7542: PUSH
7543: LD_INT 1
7545: DOUBLE
7546: EQUAL
7547: IFTRUE 7551
7549: GO 7566
7551: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
7552: LD_EXP 38
7556: PPUSH
7557: LD_STRING DBack1-Pow-1
7559: PPUSH
7560: CALL_OW 88
7564: GO 7613
7566: LD_INT 2
7568: DOUBLE
7569: EQUAL
7570: IFTRUE 7574
7572: GO 7589
7574: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
7575: LD_EXP 38
7579: PPUSH
7580: LD_STRING DBack2-Pow-1
7582: PPUSH
7583: CALL_OW 88
7587: GO 7613
7589: LD_INT 3
7591: DOUBLE
7592: EQUAL
7593: IFTRUE 7597
7595: GO 7612
7597: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
7598: LD_EXP 38
7602: PPUSH
7603: LD_STRING DBack3-Pow-1
7605: PPUSH
7606: CALL_OW 88
7610: GO 7613
7612: POP
// sync ;
7613: SYNC
// repeat wait ( 0 0$1 ) ;
7614: LD_INT 35
7616: PPUSH
7617: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
7621: LD_INT 15
7623: PPUSH
7624: LD_INT 22
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PPUSH
7634: CALL_OW 70
7638: PPUSH
7639: LD_INT 86
7641: PPUSH
7642: LD_INT 133
7644: PPUSH
7645: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
7649: LD_INT 15
7651: PPUSH
7652: LD_INT 22
7654: PUSH
7655: LD_INT 1
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PPUSH
7662: CALL_OW 70
7666: NOT
7667: IFFALSE 7614
// if powellAnger >= 3 then
7669: LD_EXP 16
7673: PUSH
7674: LD_INT 3
7676: GREATEREQUAL
7677: IFFALSE 7686
// YouLost ( Dismissed ) ;
7679: LD_STRING Dismissed
7681: PPUSH
7682: CALL_OW 104
// Video ( false ) ;
7686: LD_INT 0
7688: PPUSH
7689: CALL 83271 0 1
// end ; until missionStage > 5 ;
7693: LD_EXP 14
7697: PUSH
7698: LD_INT 5
7700: GREATER
7701: IFFALSE 7428
// end ;
7703: PPOPN 1
7705: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm ;
7706: LD_EXP 12
7710: PUSH
7711: LD_INT 22
7713: PUSH
7714: LD_INT 4
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PUSH
7721: LD_INT 21
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PPUSH
7735: CALL_OW 69
7739: PUSH
7740: LD_INT 4
7742: GREATEREQUAL
7743: AND
7744: PUSH
7745: LD_EXP 14
7749: PUSH
7750: LD_INT 2
7752: EQUAL
7753: AND
7754: IFFALSE 9113
7756: GO 7758
7758: DISABLE
7759: LD_INT 0
7761: PPUSH
7762: PPUSH
7763: PPUSH
7764: PPUSH
7765: PPUSH
// begin missionStage := 3 ;
7766: LD_ADDR_EXP 14
7770: PUSH
7771: LD_INT 3
7773: ST_TO_ADDR
// retreat := false ;
7774: LD_ADDR_VAR 0 4
7778: PUSH
7779: LD_INT 0
7781: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
7782: LD_ADDR_VAR 0 5
7786: PUSH
7787: LD_INT 22
7789: PUSH
7790: LD_INT 4
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PUSH
7797: LD_INT 30
7799: PUSH
7800: LD_INT 4
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PPUSH
7811: CALL_OW 69
7815: PUSH
7816: LD_INT 1
7818: ARRAY
7819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7820: LD_INT 35
7822: PPUSH
7823: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
7827: LD_EXP 88
7831: PUSH
7832: LD_INT 4
7834: ARRAY
7835: PUSH
7836: LD_INT 4
7838: GREATEREQUAL
7839: IFFALSE 7820
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff ( Powell ^ vip ) ;
7841: LD_ADDR_VAR 0 2
7845: PUSH
7846: LD_INT 22
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: LD_INT 2
7858: PUSH
7859: LD_INT 25
7861: PUSH
7862: LD_INT 1
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PUSH
7869: LD_INT 25
7871: PUSH
7872: LD_INT 2
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PUSH
7879: LD_INT 25
7881: PUSH
7882: LD_INT 3
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 25
7891: PUSH
7892: LD_INT 4
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: LIST
7903: LIST
7904: LIST
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PPUSH
7910: CALL_OW 69
7914: PUSH
7915: LD_EXP 38
7919: PUSH
7920: LD_EXP 39
7924: ADD
7925: DIFF
7926: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
7927: LD_ADDR_VAR 0 3
7931: PUSH
7932: LD_VAR 0 2
7936: PPUSH
7937: LD_INT 26
7939: PUSH
7940: LD_INT 1
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PPUSH
7947: CALL_OW 72
7951: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: LD_VAR 0 2
7961: PUSH
7962: LD_VAR 0 3
7966: DIFF
7967: ST_TO_ADDR
// for i = 1 to 4 do
7968: LD_ADDR_VAR 0 1
7972: PUSH
7973: DOUBLE
7974: LD_INT 1
7976: DEC
7977: ST_TO_ADDR
7978: LD_INT 4
7980: PUSH
7981: FOR_TO
7982: IFFALSE 8136
// begin if tmp2 then
7984: LD_VAR 0 3
7988: IFFALSE 8063
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ 1 ] ) ;
7990: LD_ADDR_EXP 17
7994: PUSH
7995: LD_EXP 17
7999: PPUSH
8000: LD_INT 1
8002: PPUSH
8003: LD_EXP 17
8007: PUSH
8008: LD_INT 1
8010: ARRAY
8011: PUSH
8012: LD_VAR 0 3
8016: PUSH
8017: LD_INT 1
8019: ARRAY
8020: ADD
8021: PPUSH
8022: CALL_OW 1
8026: ST_TO_ADDR
// SetTag ( tmp2 [ 1 ] , 1 ) ;
8027: LD_VAR 0 3
8031: PUSH
8032: LD_INT 1
8034: ARRAY
8035: PPUSH
8036: LD_INT 1
8038: PPUSH
8039: CALL_OW 109
// tmp2 := Delete ( tmp2 , 1 ) ;
8043: LD_ADDR_VAR 0 3
8047: PUSH
8048: LD_VAR 0 3
8052: PPUSH
8053: LD_INT 1
8055: PPUSH
8056: CALL_OW 3
8060: ST_TO_ADDR
// end else
8061: GO 8134
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ 1 ] ) ;
8063: LD_ADDR_EXP 17
8067: PUSH
8068: LD_EXP 17
8072: PPUSH
8073: LD_INT 1
8075: PPUSH
8076: LD_EXP 17
8080: PUSH
8081: LD_INT 1
8083: ARRAY
8084: PUSH
8085: LD_VAR 0 2
8089: PUSH
8090: LD_INT 1
8092: ARRAY
8093: ADD
8094: PPUSH
8095: CALL_OW 1
8099: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 1 ) ;
8100: LD_VAR 0 2
8104: PUSH
8105: LD_INT 1
8107: ARRAY
8108: PPUSH
8109: LD_INT 1
8111: PPUSH
8112: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
8116: LD_ADDR_VAR 0 2
8120: PUSH
8121: LD_VAR 0 2
8125: PPUSH
8126: LD_INT 1
8128: PPUSH
8129: CALL_OW 3
8133: ST_TO_ADDR
// end ; end ;
8134: GO 7981
8136: POP
8137: POP
// if tmp2 then
8138: LD_VAR 0 3
8142: IFFALSE 8160
// tmp := tmp union tmp2 ;
8144: LD_ADDR_VAR 0 2
8148: PUSH
8149: LD_VAR 0 2
8153: PUSH
8154: LD_VAR 0 3
8158: UNION
8159: ST_TO_ADDR
// for i = 1 to 4 do
8160: LD_ADDR_VAR 0 1
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_INT 4
8172: PUSH
8173: FOR_TO
8174: IFFALSE 8217
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ i ] ) ;
8176: LD_ADDR_EXP 17
8180: PUSH
8181: LD_EXP 17
8185: PPUSH
8186: LD_INT 2
8188: PPUSH
8189: LD_EXP 17
8193: PUSH
8194: LD_INT 2
8196: ARRAY
8197: PUSH
8198: LD_VAR 0 2
8202: PUSH
8203: LD_VAR 0 1
8207: ARRAY
8208: ADD
8209: PPUSH
8210: CALL_OW 1
8214: ST_TO_ADDR
8215: GO 8173
8217: POP
8218: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
8219: LD_ADDR_EXP 69
8223: PUSH
8224: LD_EXP 69
8228: PPUSH
8229: LD_INT 4
8231: PPUSH
8232: LD_EXP 69
8236: PUSH
8237: LD_INT 4
8239: ARRAY
8240: PUSH
8241: LD_EXP 17
8245: PUSH
8246: LD_INT 1
8248: ARRAY
8249: DIFF
8250: PPUSH
8251: CALL_OW 1
8255: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
8256: LD_ADDR_VAR 0 1
8260: PUSH
8261: LD_EXP 17
8265: PUSH
8266: LD_INT 1
8268: ARRAY
8269: PUSH
8270: FOR_IN
8271: IFFALSE 8374
// begin if IsInUnit ( i ) then
8273: LD_VAR 0 1
8277: PPUSH
8278: CALL_OW 310
8282: IFFALSE 8293
// ComExitBuilding ( i ) ;
8284: LD_VAR 0 1
8288: PPUSH
8289: CALL_OW 122
// if GetClass ( i ) <> 1 then
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 257
8302: PUSH
8303: LD_INT 1
8305: NONEQUAL
8306: IFFALSE 8343
// begin AddComEnterUnit ( i , arm ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: LD_VAR 0 5
8317: PPUSH
8318: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
8322: LD_VAR 0 1
8326: PPUSH
8327: LD_INT 1
8329: PPUSH
8330: CALL_OW 183
// AddComExitBuilding ( i ) ;
8334: LD_VAR 0 1
8338: PPUSH
8339: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
8343: LD_VAR 0 1
8347: PPUSH
8348: LD_INT 60
8350: PPUSH
8351: LD_INT 94
8353: PPUSH
8354: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_EXP 38
8367: PPUSH
8368: CALL_OW 179
// end ;
8372: GO 8270
8374: POP
8375: POP
// wait ( 0 0$15 ) ;
8376: LD_INT 525
8378: PPUSH
8379: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
8383: LD_EXP 38
8387: PPUSH
8388: LD_STRING D4-Pow-1
8390: PPUSH
8391: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_EXP 17
8404: PUSH
8405: LD_INT 1
8407: ARRAY
8408: PPUSH
8409: LD_INT 26
8411: PUSH
8412: LD_INT 1
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PPUSH
8419: CALL_OW 72
8423: ST_TO_ADDR
// if tmp then
8424: LD_VAR 0 2
8428: IFFALSE 8446
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 1
8437: ARRAY
8438: PPUSH
8439: LD_STRING D4-Sol1-1
8441: PPUSH
8442: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
8446: LD_EXP 38
8450: PPUSH
8451: LD_STRING D4-Pow-2
8453: PPUSH
8454: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
8458: LD_ADDR_VAR 0 1
8462: PUSH
8463: DOUBLE
8464: LD_INT 1
8466: DEC
8467: ST_TO_ADDR
8468: LD_EXP 17
8472: PUSH
8473: LD_INT 1
8475: ARRAY
8476: PUSH
8477: FOR_TO
8478: IFFALSE 8571
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
8480: LD_EXP 17
8484: PUSH
8485: LD_INT 1
8487: ARRAY
8488: PUSH
8489: LD_VAR 0 1
8493: ARRAY
8494: PPUSH
8495: LD_EXP 88
8499: PUSH
8500: LD_INT 4
8502: ARRAY
8503: PUSH
8504: LD_INT 1
8506: ARRAY
8507: PPUSH
8508: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
8512: LD_ADDR_EXP 88
8516: PUSH
8517: LD_EXP 88
8521: PPUSH
8522: LD_INT 4
8524: PPUSH
8525: LD_EXP 88
8529: PUSH
8530: LD_INT 4
8532: ARRAY
8533: PPUSH
8534: LD_INT 1
8536: PPUSH
8537: CALL_OW 3
8541: PPUSH
8542: CALL_OW 1
8546: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
8547: LD_INT 8
8549: PPUSH
8550: LD_EXP 17
8554: PUSH
8555: LD_INT 1
8557: ARRAY
8558: PUSH
8559: LD_VAR 0 1
8563: ARRAY
8564: PPUSH
8565: CALL_OW 471
// end ;
8569: GO 8477
8571: POP
8572: POP
// repeat wait ( 0 0$1 ) ;
8573: LD_INT 35
8575: PPUSH
8576: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
8580: LD_EXP 17
8584: PUSH
8585: LD_INT 1
8587: ARRAY
8588: PPUSH
8589: LD_INT 55
8591: PUSH
8592: EMPTY
8593: LIST
8594: PPUSH
8595: CALL_OW 72
8599: PUSH
8600: LD_INT 4
8602: GREATEREQUAL
8603: IFFALSE 8573
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
8605: LD_EXP 17
8609: PUSH
8610: LD_INT 1
8612: ARRAY
8613: PPUSH
8614: LD_INT 69
8616: PPUSH
8617: LD_INT 94
8619: PPUSH
8620: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
8624: LD_EXP 17
8628: PUSH
8629: LD_INT 1
8631: ARRAY
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: LD_INT 83
8638: PPUSH
8639: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
8643: LD_EXP 17
8647: PUSH
8648: LD_INT 1
8650: ARRAY
8651: PPUSH
8652: LD_INT 77
8654: PPUSH
8655: LD_INT 69
8657: PPUSH
8658: CALL_OW 174
// repeat wait ( 3 ) ;
8662: LD_INT 3
8664: PPUSH
8665: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
8669: LD_ADDR_VAR 0 1
8673: PUSH
8674: LD_EXP 17
8678: PUSH
8679: LD_INT 1
8681: ARRAY
8682: PUSH
8683: FOR_IN
8684: IFFALSE 8793
// begin if GetLives ( i ) < 990 then
8686: LD_VAR 0 1
8690: PPUSH
8691: CALL_OW 256
8695: PUSH
8696: LD_INT 990
8698: LESS
8699: IFFALSE 8713
// SetLives ( i , 1000 ) ;
8701: LD_VAR 0 1
8705: PPUSH
8706: LD_INT 1000
8708: PPUSH
8709: CALL_OW 234
// if not IsInUnit ( i ) then
8713: LD_VAR 0 1
8717: PPUSH
8718: CALL_OW 310
8722: NOT
8723: IFFALSE 8791
// begin if not retreat and GetSex ( i ) = sex_male then
8725: LD_VAR 0 4
8729: NOT
8730: PUSH
8731: LD_VAR 0 1
8735: PPUSH
8736: CALL_OW 258
8740: PUSH
8741: LD_INT 1
8743: EQUAL
8744: AND
8745: IFFALSE 8791
// begin retreat := true ;
8747: LD_ADDR_VAR 0 4
8751: PUSH
8752: LD_INT 1
8754: ST_TO_ADDR
// SetTag ( i , 2 ) ;
8755: LD_VAR 0 1
8759: PPUSH
8760: LD_INT 2
8762: PPUSH
8763: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
8767: LD_VAR 0 1
8771: PPUSH
8772: LD_STRING D4a-Sol1-1
8774: PPUSH
8775: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
8779: LD_EXP 38
8783: PPUSH
8784: LD_STRING D4a-Pow-1
8786: PPUSH
8787: CALL_OW 88
// end ; end ; end ;
8791: GO 8683
8793: POP
8794: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
8795: LD_EXP 17
8799: PUSH
8800: LD_INT 1
8802: ARRAY
8803: PPUSH
8804: LD_INT 95
8806: PUSH
8807: LD_INT 10
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 3
8816: PUSH
8817: LD_INT 55
8819: PUSH
8820: EMPTY
8821: LIST
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: PUSH
8827: EMPTY
8828: LIST
8829: LIST
8830: PPUSH
8831: CALL_OW 72
8835: PUSH
8836: LD_INT 4
8838: GREATEREQUAL
8839: IFFALSE 8662
// for i in powellSquadAttack [ 1 ] do
8841: LD_ADDR_VAR 0 1
8845: PUSH
8846: LD_EXP 17
8850: PUSH
8851: LD_INT 1
8853: ARRAY
8854: PUSH
8855: FOR_IN
8856: IFFALSE 8992
// begin if GetTag ( i ) = 2 then
8858: LD_VAR 0 1
8862: PPUSH
8863: CALL_OW 110
8867: PUSH
8868: LD_INT 2
8870: EQUAL
8871: IFFALSE 8933
// begin ComMoveXY ( i , 60 , 94 ) ;
8873: LD_VAR 0 1
8877: PPUSH
8878: LD_INT 60
8880: PPUSH
8881: LD_INT 94
8883: PPUSH
8884: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
8888: LD_VAR 0 1
8892: PPUSH
8893: LD_EXP 38
8897: PPUSH
8898: CALL_OW 179
// wait ( 0 0$3 ) ;
8902: LD_INT 105
8904: PPUSH
8905: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_STRING D4a-Sol1-2
8916: PPUSH
8917: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
8921: LD_EXP 38
8925: PPUSH
8926: LD_STRING D4a-Pow-2
8928: PPUSH
8929: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
8933: LD_VAR 0 1
8937: PPUSH
8938: LD_INT 0
8940: PPUSH
8941: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
8945: LD_ADDR_EXP 69
8949: PUSH
8950: LD_EXP 69
8954: PPUSH
8955: LD_INT 4
8957: PPUSH
8958: LD_EXP 69
8962: PUSH
8963: LD_INT 4
8965: ARRAY
8966: PUSH
8967: LD_VAR 0 1
8971: UNION
8972: PPUSH
8973: CALL_OW 1
8977: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
8978: LD_INT 8
8980: PPUSH
8981: LD_VAR 0 1
8985: PPUSH
8986: CALL_OW 472
// end ;
8990: GO 8855
8992: POP
8993: POP
// wait ( 1 1$00 ) ;
8994: LD_INT 2100
8996: PPUSH
8997: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
9001: LD_INT 4
9003: PPUSH
9004: LD_INT 3
9006: PUSH
9007: LD_INT 1
9009: PUSH
9010: LD_INT 1
9012: PUSH
9013: LD_INT 5
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: LIST
9020: LIST
9021: PUSH
9022: LD_INT 4
9024: PUSH
9025: LD_INT 1
9027: PUSH
9028: LD_INT 1
9030: PUSH
9031: LD_INT 6
9033: PUSH
9034: EMPTY
9035: LIST
9036: LIST
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 4
9042: PUSH
9043: LD_INT 1
9045: PUSH
9046: LD_INT 1
9048: PUSH
9049: LD_INT 7
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: LD_INT 3
9060: PUSH
9061: LD_INT 1
9063: PUSH
9064: LD_INT 1
9066: PUSH
9067: LD_INT 7
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_INT 3
9078: PUSH
9079: LD_INT 1
9081: PUSH
9082: LD_INT 1
9084: PUSH
9085: LD_INT 5
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: LIST
9092: LIST
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: PPUSH
9101: CALL 35211 0 2
// missionStage := 4 ;
9105: LD_ADDR_EXP 14
9109: PUSH
9110: LD_INT 4
9112: ST_TO_ADDR
// end ;
9113: PPOPN 5
9115: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
9116: LD_EXP 14
9120: PUSH
9121: LD_INT 4
9123: EQUAL
9124: PUSH
9125: LD_INT 22
9127: PUSH
9128: LD_INT 4
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: LD_INT 21
9137: PUSH
9138: LD_INT 2
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: PPUSH
9149: CALL_OW 69
9153: PUSH
9154: LD_INT 5
9156: GREATEREQUAL
9157: AND
9158: IFFALSE 12665
9160: GO 9162
9162: DISABLE
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
9168: PPUSH
9169: PPUSH
9170: PPUSH
9171: PPUSH
9172: PPUSH
9173: PPUSH
9174: PPUSH
9175: PPUSH
9176: PPUSH
9177: PPUSH
// begin missionStage := 5 ;
9178: LD_ADDR_EXP 14
9182: PUSH
9183: LD_INT 5
9185: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
9186: LD_ADDR_VAR 0 10
9190: PUSH
9191: LD_INT 22
9193: PUSH
9194: LD_INT 4
9196: PUSH
9197: EMPTY
9198: LIST
9199: LIST
9200: PUSH
9201: LD_INT 30
9203: PUSH
9204: LD_INT 4
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: PPUSH
9215: CALL_OW 69
9219: PUSH
9220: LD_INT 1
9222: ARRAY
9223: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
9224: LD_ADDR_VAR 0 6
9228: PUSH
9229: LD_INT 22
9231: PUSH
9232: LD_INT 4
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 21
9241: PUSH
9242: LD_INT 1
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: PUSH
9249: LD_INT 3
9251: PUSH
9252: LD_INT 25
9254: PUSH
9255: LD_INT 16
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: PUSH
9266: LD_INT 3
9268: PUSH
9269: LD_INT 25
9271: PUSH
9272: LD_INT 12
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: LIST
9288: PPUSH
9289: CALL_OW 69
9293: PUSH
9294: LD_EXP 38
9298: DIFF
9299: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
9300: LD_ADDR_VAR 0 9
9304: PUSH
9305: LD_INT 22
9307: PUSH
9308: LD_INT 4
9310: PUSH
9311: EMPTY
9312: LIST
9313: LIST
9314: PUSH
9315: LD_INT 30
9317: PUSH
9318: LD_INT 3
9320: PUSH
9321: EMPTY
9322: LIST
9323: LIST
9324: PUSH
9325: EMPTY
9326: LIST
9327: LIST
9328: PPUSH
9329: CALL_OW 69
9333: PUSH
9334: LD_INT 1
9336: ARRAY
9337: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9338: LD_INT 35
9340: PPUSH
9341: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
9345: LD_EXP 88
9349: PUSH
9350: LD_INT 4
9352: ARRAY
9353: PUSH
9354: LD_INT 5
9356: GREATEREQUAL
9357: IFFALSE 9338
// powellAllowRetreat := false ;
9359: LD_ADDR_EXP 18
9363: PUSH
9364: LD_INT 0
9366: ST_TO_ADDR
// wait ( 0 0$20 ) ;
9367: LD_INT 700
9369: PPUSH
9370: CALL_OW 67
// activeAttacks := false ;
9374: LD_ADDR_EXP 15
9378: PUSH
9379: LD_INT 0
9381: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9382: LD_INT 35
9384: PPUSH
9385: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
9389: LD_INT 22
9391: PUSH
9392: LD_INT 6
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PPUSH
9399: CALL_OW 69
9403: PUSH
9404: LD_INT 0
9406: EQUAL
9407: IFFALSE 9382
// tmp := mc_vehicles [ 4 ] ;
9409: LD_ADDR_VAR 0 3
9413: PUSH
9414: LD_EXP 88
9418: PUSH
9419: LD_INT 4
9421: ARRAY
9422: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: DOUBLE
9429: LD_INT 1
9431: DEC
9432: ST_TO_ADDR
9433: LD_EXP 17
9437: PUSH
9438: FOR_TO
9439: IFFALSE 9657
// begin for j in powellSquadAttack [ i ] do
9441: LD_ADDR_VAR 0 2
9445: PUSH
9446: LD_EXP 17
9450: PUSH
9451: LD_VAR 0 1
9455: ARRAY
9456: PUSH
9457: FOR_IN
9458: IFFALSE 9653
// begin forces := forces diff j ;
9460: LD_ADDR_VAR 0 6
9464: PUSH
9465: LD_VAR 0 6
9469: PUSH
9470: LD_VAR 0 2
9474: DIFF
9475: ST_TO_ADDR
// SetTag ( j , 1 ) ;
9476: LD_VAR 0 2
9480: PPUSH
9481: LD_INT 1
9483: PPUSH
9484: CALL_OW 109
// wait ( 0 0$2 ) ;
9488: LD_INT 70
9490: PPUSH
9491: CALL_OW 67
// if IsInUnit ( j ) then
9495: LD_VAR 0 2
9499: PPUSH
9500: CALL_OW 310
9504: IFFALSE 9515
// ComExitBuilding ( j ) ;
9506: LD_VAR 0 2
9510: PPUSH
9511: CALL_OW 122
// if GetClass ( j ) <> 1 then
9515: LD_VAR 0 2
9519: PPUSH
9520: CALL_OW 257
9524: PUSH
9525: LD_INT 1
9527: NONEQUAL
9528: IFFALSE 9565
// begin AddComEnterUnit ( j , arm ) ;
9530: LD_VAR 0 2
9534: PPUSH
9535: LD_VAR 0 10
9539: PPUSH
9540: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
9544: LD_VAR 0 2
9548: PPUSH
9549: LD_INT 1
9551: PPUSH
9552: CALL_OW 183
// AddComExitBuilding ( j ) ;
9556: LD_VAR 0 2
9560: PPUSH
9561: CALL_OW 182
// end ; if i = 2 then
9565: LD_VAR 0 1
9569: PUSH
9570: LD_INT 2
9572: EQUAL
9573: IFFALSE 9590
// AddComMoveXY ( j , 61 , 93 ) ;
9575: LD_VAR 0 2
9579: PPUSH
9580: LD_INT 61
9582: PPUSH
9583: LD_INT 93
9585: PPUSH
9586: CALL_OW 171
// if i = 1 then
9590: LD_VAR 0 1
9594: PUSH
9595: LD_INT 1
9597: EQUAL
9598: IFFALSE 9651
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
9600: LD_VAR 0 2
9604: PPUSH
9605: LD_VAR 0 3
9609: PUSH
9610: LD_INT 1
9612: ARRAY
9613: PPUSH
9614: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
9618: LD_ADDR_VAR 0 3
9622: PUSH
9623: LD_VAR 0 3
9627: PPUSH
9628: LD_INT 1
9630: PPUSH
9631: CALL_OW 3
9635: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
9636: LD_VAR 0 2
9640: PPUSH
9641: LD_INT 69
9643: PPUSH
9644: LD_INT 94
9646: PPUSH
9647: CALL_OW 171
// end ; end ;
9651: GO 9457
9653: POP
9654: POP
// end ;
9655: GO 9438
9657: POP
9658: POP
// wait ( 0 0$30 ) ;
9659: LD_INT 1050
9661: PPUSH
9662: CALL_OW 67
// MC_Kill ( 4 ) ;
9666: LD_INT 4
9668: PPUSH
9669: CALL 13503 0 1
// tmp := UnitsInside ( fac ) ;
9673: LD_ADDR_VAR 0 3
9677: PUSH
9678: LD_VAR 0 9
9682: PPUSH
9683: CALL_OW 313
9687: ST_TO_ADDR
// if tmp then
9688: LD_VAR 0 3
9692: IFFALSE 9766
// for i in tmp do
9694: LD_ADDR_VAR 0 1
9698: PUSH
9699: LD_VAR 0 3
9703: PUSH
9704: FOR_IN
9705: IFFALSE 9764
// begin ComExitBuilding ( i ) ;
9707: LD_VAR 0 1
9711: PPUSH
9712: CALL_OW 122
// if UnitsInside ( arm ) < 6 then
9716: LD_VAR 0 10
9720: PPUSH
9721: CALL_OW 313
9725: PUSH
9726: LD_INT 6
9728: LESS
9729: IFFALSE 9747
// AddComEnterUnit ( i , arm ) else
9731: LD_VAR 0 1
9735: PPUSH
9736: LD_VAR 0 10
9740: PPUSH
9741: CALL_OW 180
9745: GO 9762
// AddComMoveXY ( i , 61 , 101 ) ;
9747: LD_VAR 0 1
9751: PPUSH
9752: LD_INT 61
9754: PPUSH
9755: LD_INT 101
9757: PPUSH
9758: CALL_OW 171
// end ;
9762: GO 9704
9764: POP
9765: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
9766: LD_ADDR_VAR 0 11
9770: PUSH
9771: LD_VAR 0 6
9775: PPUSH
9776: LD_INT 26
9778: PUSH
9779: LD_INT 1
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 72
9790: PUSH
9791: LD_EXP 39
9795: DIFF
9796: ST_TO_ADDR
// if not speaker then
9797: LD_VAR 0 11
9801: NOT
9802: IFFALSE 9829
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
9804: LD_ADDR_VAR 0 11
9808: PUSH
9809: LD_VAR 0 6
9813: PPUSH
9814: LD_INT 26
9816: PUSH
9817: LD_INT 1
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PPUSH
9824: CALL_OW 72
9828: ST_TO_ADDR
// if speaker then
9829: LD_VAR 0 11
9833: IFFALSE 9849
// speaker := speaker [ 1 ] ;
9835: LD_ADDR_VAR 0 11
9839: PUSH
9840: LD_VAR 0 11
9844: PUSH
9845: LD_INT 1
9847: ARRAY
9848: ST_TO_ADDR
// Video ( true ) ;
9849: LD_INT 1
9851: PPUSH
9852: CALL 83271 0 1
// CenterNowOnUnits ( Powell ) ;
9856: LD_EXP 38
9860: PPUSH
9861: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
9865: LD_ADDR_VAR 0 3
9869: PUSH
9870: LD_VAR 0 6
9874: PPUSH
9875: LD_INT 3
9877: PUSH
9878: LD_INT 25
9880: PUSH
9881: LD_INT 1
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: PPUSH
9892: CALL_OW 72
9896: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
9897: LD_ADDR_VAR 0 12
9901: PUSH
9902: LD_INT 22
9904: PUSH
9905: LD_INT 4
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: PUSH
9912: LD_INT 30
9914: PUSH
9915: LD_INT 32
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PUSH
9922: LD_INT 58
9924: PUSH
9925: EMPTY
9926: LIST
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL_OW 69
9937: ST_TO_ADDR
// for i = 1 to 6 do
9938: LD_ADDR_VAR 0 1
9942: PUSH
9943: DOUBLE
9944: LD_INT 1
9946: DEC
9947: ST_TO_ADDR
9948: LD_INT 6
9950: PUSH
9951: FOR_TO
9952: IFFALSE 10089
// begin if IsInUnit ( tmp [ i ] ) then
9954: LD_VAR 0 3
9958: PUSH
9959: LD_VAR 0 1
9963: ARRAY
9964: PPUSH
9965: CALL_OW 310
9969: IFFALSE 9986
// ComExitBuilding ( tmp [ i ] ) ;
9971: LD_VAR 0 3
9975: PUSH
9976: LD_VAR 0 1
9980: ARRAY
9981: PPUSH
9982: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm ) ;
9986: LD_VAR 0 3
9990: PUSH
9991: LD_VAR 0 1
9995: ARRAY
9996: PPUSH
9997: LD_VAR 0 10
10001: PPUSH
10002: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
10006: LD_VAR 0 3
10010: PUSH
10011: LD_VAR 0 1
10015: ARRAY
10016: PPUSH
10017: LD_INT 1
10019: PPUSH
10020: CALL_OW 183
// if emp_towers then
10024: LD_VAR 0 12
10028: IFFALSE 10087
// begin AddComExitBuilding ( tmp [ i ] ) ;
10030: LD_VAR 0 3
10034: PUSH
10035: LD_VAR 0 1
10039: ARRAY
10040: PPUSH
10041: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
10045: LD_VAR 0 3
10049: PUSH
10050: LD_VAR 0 1
10054: ARRAY
10055: PPUSH
10056: LD_VAR 0 12
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PPUSH
10065: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
10069: LD_ADDR_VAR 0 12
10073: PUSH
10074: LD_VAR 0 12
10078: PPUSH
10079: LD_INT 1
10081: PPUSH
10082: CALL_OW 3
10086: ST_TO_ADDR
// end ; end ;
10087: GO 9951
10089: POP
10090: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
10091: LD_ADDR_VAR 0 3
10095: PUSH
10096: LD_EXP 17
10100: PUSH
10101: LD_INT 1
10103: ARRAY
10104: PUSH
10105: LD_EXP 17
10109: PUSH
10110: LD_INT 2
10112: ARRAY
10113: ADD
10114: PPUSH
10115: LD_INT 26
10117: PUSH
10118: LD_INT 1
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: PPUSH
10125: CALL_OW 72
10129: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
10130: LD_ADDR_VAR 0 1
10134: PUSH
10135: LD_EXP 17
10139: PUSH
10140: LD_INT 2
10142: ARRAY
10143: PUSH
10144: FOR_IN
10145: IFFALSE 10163
// ComTurnUnit ( i , Powell ) ;
10147: LD_VAR 0 1
10151: PPUSH
10152: LD_EXP 38
10156: PPUSH
10157: CALL_OW 119
10161: GO 10144
10163: POP
10164: POP
// Say ( Powell , D5-Pow-1 ) ;
10165: LD_EXP 38
10169: PPUSH
10170: LD_STRING D5-Pow-1
10172: PPUSH
10173: CALL_OW 88
// if tmp then
10177: LD_VAR 0 3
10181: IFFALSE 10199
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
10183: LD_VAR 0 3
10187: PUSH
10188: LD_INT 1
10190: ARRAY
10191: PPUSH
10192: LD_STRING D5-Sol2-1
10194: PPUSH
10195: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
10199: LD_EXP 38
10203: PPUSH
10204: LD_STRING D5-Pow-2
10206: PPUSH
10207: CALL_OW 88
// if tmp > 1 then
10211: LD_VAR 0 3
10215: PUSH
10216: LD_INT 1
10218: GREATER
10219: IFFALSE 10237
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
10221: LD_VAR 0 3
10225: PUSH
10226: LD_INT 2
10228: ARRAY
10229: PPUSH
10230: LD_STRING D5-Sol2-2
10232: PPUSH
10233: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
10237: LD_EXP 38
10241: PPUSH
10242: LD_STRING D5-Pow-3
10244: PPUSH
10245: CALL_OW 88
// wait ( 0 0$1 ) ;
10249: LD_INT 35
10251: PPUSH
10252: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
10256: LD_ADDR_VAR 0 3
10260: PUSH
10261: LD_EXP 17
10265: PUSH
10266: LD_INT 1
10268: ARRAY
10269: PUSH
10270: LD_EXP 17
10274: PUSH
10275: LD_INT 2
10277: ARRAY
10278: UNION
10279: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
10280: LD_VAR 0 3
10284: PPUSH
10285: LD_INT 80
10287: PPUSH
10288: LD_INT 67
10290: PPUSH
10291: CALL_OW 114
// wait ( 0 0$2 ) ;
10295: LD_INT 70
10297: PPUSH
10298: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
10302: LD_INT 79
10304: PPUSH
10305: LD_INT 72
10307: PPUSH
10308: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
10312: LD_INT 35
10314: PPUSH
10315: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
10319: LD_VAR 0 3
10323: PPUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 24
10329: PUSH
10330: LD_INT 1000
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PPUSH
10341: CALL_OW 72
10345: IFFALSE 10312
// Say ( Powell , D5a-Pow-1 ) ;
10347: LD_EXP 38
10351: PPUSH
10352: LD_STRING D5a-Pow-1
10354: PPUSH
10355: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
10359: LD_EXP 38
10363: PPUSH
10364: LD_STRING D5a-Pow-1a
10366: PPUSH
10367: CALL_OW 88
// wait ( 0 0$0.3 ) ;
10371: LD_INT 10
10373: PPUSH
10374: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
10378: LD_EXP 38
10382: PPUSH
10383: LD_STRING D5a-Pow-1b
10385: PPUSH
10386: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
10390: LD_EXP 38
10394: PPUSH
10395: LD_STRING D5a-Pow-1c
10397: PPUSH
10398: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
10402: LD_EXP 38
10406: PPUSH
10407: LD_STRING D5a-Pow-1d
10409: PPUSH
10410: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10414: LD_INT 35
10416: PPUSH
10417: CALL_OW 67
// if not HasTask ( tmp ) then
10421: LD_VAR 0 3
10425: PPUSH
10426: CALL_OW 314
10430: NOT
10431: IFFALSE 10448
// ComAgressiveMove ( tmp , 80 , 67 ) ;
10433: LD_VAR 0 3
10437: PPUSH
10438: LD_INT 80
10440: PPUSH
10441: LD_INT 67
10443: PPUSH
10444: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
10448: LD_VAR 0 3
10452: PPUSH
10453: LD_INT 24
10455: PUSH
10456: LD_INT 1
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PPUSH
10463: CALL_OW 72
10467: NOT
10468: IFFALSE 10414
// wait ( 0 0$3 ) ;
10470: LD_INT 105
10472: PPUSH
10473: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
10477: LD_VAR 0 11
10481: PPUSH
10482: LD_STRING D6-Sol3-1
10484: PPUSH
10485: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
10489: LD_EXP 38
10493: PPUSH
10494: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
10498: LD_EXP 38
10502: PPUSH
10503: LD_STRING D6-Pow-1
10505: PPUSH
10506: CALL_OW 88
// tmp := [ ] ;
10510: LD_ADDR_VAR 0 3
10514: PUSH
10515: EMPTY
10516: ST_TO_ADDR
// for i = 1 to 2 do
10517: LD_ADDR_VAR 0 1
10521: PUSH
10522: DOUBLE
10523: LD_INT 1
10525: DEC
10526: ST_TO_ADDR
10527: LD_INT 2
10529: PUSH
10530: FOR_TO
10531: IFFALSE 10638
// begin uc_side := 8 ;
10533: LD_ADDR_OWVAR 20
10537: PUSH
10538: LD_INT 8
10540: ST_TO_ADDR
// uc_nation := 2 ;
10541: LD_ADDR_OWVAR 21
10545: PUSH
10546: LD_INT 2
10548: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
10549: LD_INT 14
10551: PPUSH
10552: LD_INT 3
10554: PPUSH
10555: LD_INT 2
10557: PPUSH
10558: LD_INT 29
10560: PPUSH
10561: LD_INT 100
10563: PPUSH
10564: CALL 47616 0 5
// veh := CreateVehicle ;
10568: LD_ADDR_VAR 0 13
10572: PUSH
10573: CALL_OW 45
10577: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10578: LD_VAR 0 13
10582: PPUSH
10583: LD_INT 4
10585: PPUSH
10586: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
10590: LD_VAR 0 13
10594: PPUSH
10595: LD_INT 99
10597: PPUSH
10598: LD_INT 83
10600: PPUSH
10601: LD_INT 5
10603: PPUSH
10604: LD_INT 0
10606: PPUSH
10607: CALL_OW 50
// Connect ( veh ) ;
10611: LD_VAR 0 13
10615: PPUSH
10616: CALL 50671 0 1
// tmp := tmp ^ veh ;
10620: LD_ADDR_VAR 0 3
10624: PUSH
10625: LD_VAR 0 3
10629: PUSH
10630: LD_VAR 0 13
10634: ADD
10635: ST_TO_ADDR
// end ;
10636: GO 10530
10638: POP
10639: POP
// wait ( 0 0$1 ) ;
10640: LD_INT 35
10642: PPUSH
10643: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
10647: LD_INT 99
10649: PPUSH
10650: LD_INT 83
10652: PPUSH
10653: LD_INT 1
10655: PPUSH
10656: LD_INT 10
10658: PPUSH
10659: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
10663: LD_INT 99
10665: PPUSH
10666: LD_INT 83
10668: PPUSH
10669: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
10673: LD_VAR 0 11
10677: PPUSH
10678: LD_STRING D6-Sol3-2
10680: PPUSH
10681: CALL_OW 88
// async ;
10685: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
10686: LD_EXP 38
10690: PPUSH
10691: LD_STRING D6-Pow-2
10693: PPUSH
10694: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
10698: LD_VAR 0 3
10702: PUSH
10703: LD_INT 1
10705: ARRAY
10706: PPUSH
10707: LD_VAR 0 9
10711: PPUSH
10712: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
10716: LD_VAR 0 3
10720: PUSH
10721: LD_INT 2
10723: ARRAY
10724: PPUSH
10725: LD_INT 22
10727: PUSH
10728: LD_INT 4
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 21
10737: PUSH
10738: LD_INT 3
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 69
10753: PPUSH
10754: LD_VAR 0 3
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PPUSH
10763: CALL_OW 74
10767: PPUSH
10768: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
10772: LD_EXP 38
10776: PPUSH
10777: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
10781: LD_INT 99
10783: PPUSH
10784: LD_INT 83
10786: PPUSH
10787: LD_INT 1
10789: PPUSH
10790: CALL_OW 331
// repeat wait ( 4 ) ;
10794: LD_INT 4
10796: PPUSH
10797: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
10801: LD_VAR 0 3
10805: PUSH
10806: LD_INT 1
10808: ARRAY
10809: PPUSH
10810: CALL_OW 256
10814: PUSH
10815: LD_INT 1000
10817: LESS
10818: IFFALSE 10836
// SetLives ( tmp [ 1 ] , 1000 ) ;
10820: LD_VAR 0 3
10824: PUSH
10825: LD_INT 1
10827: ARRAY
10828: PPUSH
10829: LD_INT 1000
10831: PPUSH
10832: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
10836: LD_INT 22
10838: PUSH
10839: LD_INT 4
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PUSH
10846: LD_INT 30
10848: PUSH
10849: LD_INT 3
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: PPUSH
10860: CALL_OW 69
10864: PUSH
10865: LD_INT 0
10867: EQUAL
10868: IFFALSE 10794
// sync ;
10870: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
10871: LD_EXP 38
10875: PPUSH
10876: LD_STRING D6a-Pow-1
10878: PPUSH
10879: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
10883: LD_VAR 0 11
10887: PPUSH
10888: LD_STRING D6a-Sol3-1
10890: PPUSH
10891: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
10895: LD_EXP 38
10899: PPUSH
10900: LD_STRING D6a-Pow-2
10902: PPUSH
10903: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
10907: LD_VAR 0 11
10911: PPUSH
10912: LD_STRING D6a-Sol3-2
10914: PPUSH
10915: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
10919: LD_EXP 38
10923: PPUSH
10924: LD_STRING D6a-Pow-3
10926: PPUSH
10927: CALL_OW 88
// powellCenterCameraMode := true ;
10931: LD_ADDR_EXP 19
10935: PUSH
10936: LD_INT 1
10938: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
10939: LD_ADDR_VAR 0 3
10943: PUSH
10944: LD_INT 22
10946: PUSH
10947: LD_INT 4
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: PUSH
10954: LD_INT 21
10956: PUSH
10957: LD_INT 2
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PUSH
10964: LD_INT 3
10966: PUSH
10967: LD_INT 34
10969: PUSH
10970: LD_INT 12
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: PUSH
10977: EMPTY
10978: LIST
10979: LIST
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: LIST
10985: PPUSH
10986: CALL_OW 69
10990: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
10991: LD_EXP 38
10995: PPUSH
10996: LD_VAR 0 3
11000: PPUSH
11001: LD_EXP 38
11005: PPUSH
11006: CALL_OW 74
11010: PPUSH
11011: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
11015: LD_EXP 38
11019: PPUSH
11020: LD_INT 100
11022: PPUSH
11023: LD_INT 88
11025: PPUSH
11026: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
11030: LD_EXP 38
11034: PPUSH
11035: LD_INT 100
11037: PPUSH
11038: LD_INT 75
11040: PPUSH
11041: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
11045: LD_EXP 38
11049: PPUSH
11050: LD_INT 88
11052: PPUSH
11053: LD_INT 53
11055: PPUSH
11056: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
11060: LD_INT 8
11062: PPUSH
11063: LD_EXP 38
11067: PPUSH
11068: CALL_OW 471
// SetAttitude ( 4 , 8 , att_neutral , false ) ;
11072: LD_INT 4
11074: PPUSH
11075: LD_INT 8
11077: PPUSH
11078: LD_INT 0
11080: PPUSH
11081: LD_INT 0
11083: PPUSH
11084: CALL_OW 80
// repeat wait ( 3 ) ;
11088: LD_INT 3
11090: PPUSH
11091: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
11095: LD_INT 22
11097: PUSH
11098: LD_INT 4
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: LD_INT 92
11107: PUSH
11108: LD_INT 100
11110: PUSH
11111: LD_INT 75
11113: PUSH
11114: LD_INT 6
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: LIST
11121: LIST
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: PPUSH
11127: CALL_OW 69
11131: IFFALSE 11088
// async ;
11133: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
11134: LD_EXP 38
11138: PPUSH
11139: LD_STRING D6b-Pow-1
11141: PPUSH
11142: CALL_OW 88
// repeat wait ( 3 ) ;
11146: LD_INT 3
11148: PPUSH
11149: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
11153: LD_EXP 38
11157: PPUSH
11158: CALL_OW 310
11162: PPUSH
11163: CALL_OW 256
11167: PUSH
11168: LD_INT 1000
11170: LESS
11171: IFFALSE 11190
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
11173: LD_EXP 38
11177: PPUSH
11178: CALL_OW 310
11182: PPUSH
11183: LD_INT 1000
11185: PPUSH
11186: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
11190: LD_EXP 38
11194: PPUSH
11195: CALL_OW 256
11199: PUSH
11200: LD_INT 1000
11202: LESS
11203: IFFALSE 11217
// SetLives ( Powell , 1000 ) ;
11205: LD_EXP 38
11209: PPUSH
11210: LD_INT 1000
11212: PPUSH
11213: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
11217: LD_EXP 38
11221: PPUSH
11222: LD_EXP 42
11226: PPUSH
11227: CALL_OW 296
11231: PUSH
11232: LD_INT 5
11234: LESS
11235: PUSH
11236: LD_EXP 38
11240: PPUSH
11241: CALL_OW 310
11245: PPUSH
11246: LD_EXP 42
11250: PPUSH
11251: CALL_OW 296
11255: PUSH
11256: LD_INT 5
11258: LESS
11259: OR
11260: IFFALSE 11279
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
11262: LD_EXP 38
11266: PPUSH
11267: CALL_OW 310
11271: PPUSH
11272: LD_INT 100
11274: PPUSH
11275: CALL_OW 234
// until not IsInUnit ( Powell ) ;
11279: LD_EXP 38
11283: PPUSH
11284: CALL_OW 310
11288: NOT
11289: IFFALSE 11146
// game_speed := 4 ;
11291: LD_ADDR_OWVAR 65
11295: PUSH
11296: LD_INT 4
11298: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
11299: LD_EXP 38
11303: PPUSH
11304: LD_STRING D6b-Pow-1a
11306: PPUSH
11307: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
11311: LD_EXP 38
11315: PPUSH
11316: LD_EXP 42
11320: PPUSH
11321: CALL_OW 180
// sync ;
11325: SYNC
// repeat wait ( 0 0$1 ) ;
11326: LD_INT 35
11328: PPUSH
11329: CALL_OW 67
// until IsInUnit ( Powell ) ;
11333: LD_EXP 38
11337: PPUSH
11338: CALL_OW 310
11342: IFFALSE 11326
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
11344: LD_INT 8
11346: PPUSH
11347: LD_EXP 38
11351: PPUSH
11352: CALL_OW 310
11356: PPUSH
11357: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
11361: LD_EXP 38
11365: PPUSH
11366: LD_INT 91
11368: PPUSH
11369: LD_INT 44
11371: PPUSH
11372: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
11376: LD_EXP 38
11380: PPUSH
11381: LD_INT 96
11383: PPUSH
11384: LD_INT 44
11386: PPUSH
11387: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
11391: LD_EXP 38
11395: PPUSH
11396: LD_INT 96
11398: PPUSH
11399: LD_INT 41
11401: PPUSH
11402: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
11406: LD_EXP 38
11410: PPUSH
11411: LD_INT 92
11413: PPUSH
11414: LD_INT 39
11416: PPUSH
11417: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
11421: LD_EXP 38
11425: PPUSH
11426: LD_INT 88
11428: PPUSH
11429: LD_INT 41
11431: PPUSH
11432: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
11436: LD_EXP 38
11440: PPUSH
11441: LD_INT 91
11443: PPUSH
11444: LD_INT 44
11446: PPUSH
11447: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
11451: LD_EXP 38
11455: PPUSH
11456: LD_INT 96
11458: PPUSH
11459: LD_INT 44
11461: PPUSH
11462: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
11466: LD_EXP 38
11470: PPUSH
11471: LD_INT 96
11473: PPUSH
11474: LD_INT 41
11476: PPUSH
11477: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
11481: LD_EXP 38
11485: PPUSH
11486: LD_INT 92
11488: PPUSH
11489: LD_INT 39
11491: PPUSH
11492: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
11496: LD_EXP 38
11500: PPUSH
11501: LD_INT 88
11503: PPUSH
11504: LD_INT 41
11506: PPUSH
11507: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
11511: LD_EXP 38
11515: PPUSH
11516: LD_INT 91
11518: PPUSH
11519: LD_INT 44
11521: PPUSH
11522: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
11526: LD_EXP 38
11530: PPUSH
11531: LD_INT 93
11533: PPUSH
11534: LD_INT 39
11536: PPUSH
11537: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
11541: LD_EXP 38
11545: PPUSH
11546: LD_INT 93
11548: PPUSH
11549: LD_INT 36
11551: PPUSH
11552: CALL_OW 171
// wait ( 0 0$3.5 ) ;
11556: LD_INT 122
11558: PPUSH
11559: CALL_OW 67
// game_speed := 4 ;
11563: LD_ADDR_OWVAR 65
11567: PUSH
11568: LD_INT 4
11570: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
11571: LD_EXP 38
11575: PPUSH
11576: LD_STRING D6b-Pow-1b
11578: PPUSH
11579: CALL_OW 88
// tmp := [ ] ;
11583: LD_ADDR_VAR 0 3
11587: PUSH
11588: EMPTY
11589: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
11590: LD_ADDR_VAR 0 5
11594: PUSH
11595: LD_INT 78
11597: PUSH
11598: LD_INT 47
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: PUSH
11605: LD_INT 106
11607: PUSH
11608: LD_INT 53
11610: PUSH
11611: EMPTY
11612: LIST
11613: LIST
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
11619: LD_ADDR_VAR 0 1
11623: PUSH
11624: LD_INT 22
11626: PUSH
11627: LD_INT 8
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: LD_INT 21
11636: PUSH
11637: LD_INT 3
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: LD_INT 92
11646: PUSH
11647: LD_INT 90
11649: PUSH
11650: LD_INT 52
11652: PUSH
11653: LD_INT 12
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: LIST
11660: LIST
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: LIST
11666: PPUSH
11667: CALL_OW 69
11671: PUSH
11672: FOR_IN
11673: IFFALSE 11698
// tmp := tmp ^ UnitsInside ( i ) ;
11675: LD_ADDR_VAR 0 3
11679: PUSH
11680: LD_VAR 0 3
11684: PUSH
11685: LD_VAR 0 1
11689: PPUSH
11690: CALL_OW 313
11694: ADD
11695: ST_TO_ADDR
11696: GO 11672
11698: POP
11699: POP
// for i in tmp do
11700: LD_ADDR_VAR 0 1
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: FOR_IN
11711: IFFALSE 11873
// begin dist := 9999 ;
11713: LD_ADDR_VAR 0 8
11717: PUSH
11718: LD_INT 9999
11720: ST_TO_ADDR
// _xy := [ ] ;
11721: LD_ADDR_VAR 0 7
11725: PUSH
11726: EMPTY
11727: ST_TO_ADDR
// SetTag ( i , 1 ) ;
11728: LD_VAR 0 1
11732: PPUSH
11733: LD_INT 1
11735: PPUSH
11736: CALL_OW 109
// ComExitBuilding ( i ) ;
11740: LD_VAR 0 1
11744: PPUSH
11745: CALL_OW 122
// for j in xy do
11749: LD_ADDR_VAR 0 2
11753: PUSH
11754: LD_VAR 0 5
11758: PUSH
11759: FOR_IN
11760: IFFALSE 11842
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
11762: LD_VAR 0 1
11766: PPUSH
11767: LD_VAR 0 2
11771: PUSH
11772: LD_INT 1
11774: ARRAY
11775: PPUSH
11776: LD_VAR 0 2
11780: PUSH
11781: LD_INT 2
11783: ARRAY
11784: PPUSH
11785: CALL_OW 297
11789: PUSH
11790: LD_VAR 0 8
11794: LESS
11795: IFFALSE 11840
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
11797: LD_ADDR_VAR 0 8
11801: PUSH
11802: LD_VAR 0 1
11806: PPUSH
11807: LD_VAR 0 2
11811: PUSH
11812: LD_INT 1
11814: ARRAY
11815: PPUSH
11816: LD_VAR 0 2
11820: PUSH
11821: LD_INT 2
11823: ARRAY
11824: PPUSH
11825: CALL_OW 297
11829: ST_TO_ADDR
// _xy := j ;
11830: LD_ADDR_VAR 0 7
11834: PUSH
11835: LD_VAR 0 2
11839: ST_TO_ADDR
// end ;
11840: GO 11759
11842: POP
11843: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
11844: LD_VAR 0 1
11848: PPUSH
11849: LD_VAR 0 7
11853: PUSH
11854: LD_INT 1
11856: ARRAY
11857: PPUSH
11858: LD_VAR 0 7
11862: PUSH
11863: LD_INT 2
11865: ARRAY
11866: PPUSH
11867: CALL_OW 171
// end ;
11871: GO 11710
11873: POP
11874: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
11875: LD_ADDR_VAR 0 4
11879: PUSH
11880: LD_VAR 0 3
11884: PPUSH
11885: LD_INT 26
11887: PUSH
11888: LD_INT 1
11890: PUSH
11891: EMPTY
11892: LIST
11893: LIST
11894: PPUSH
11895: CALL_OW 72
11899: ST_TO_ADDR
// if tmp2 < 2 then
11900: LD_VAR 0 4
11904: PUSH
11905: LD_INT 2
11907: LESS
11908: IFFALSE 11970
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_class , 1 ] ] ) diff [ Kurt , Kozlov ] ;
11910: LD_ADDR_VAR 0 4
11914: PUSH
11915: LD_INT 22
11917: PUSH
11918: LD_INT 8
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: LD_INT 26
11927: PUSH
11928: LD_INT 1
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: PUSH
11935: LD_INT 25
11937: PUSH
11938: LD_INT 1
11940: PUSH
11941: EMPTY
11942: LIST
11943: LIST
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: LIST
11949: PPUSH
11950: CALL_OW 69
11954: PUSH
11955: LD_EXP 40
11959: PUSH
11960: LD_EXP 41
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: DIFF
11969: ST_TO_ADDR
// if tmp2 then
11970: LD_VAR 0 4
11974: IFFALSE 11992
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
11976: LD_VAR 0 4
11980: PUSH
11981: LD_INT 1
11983: ARRAY
11984: PPUSH
11985: LD_STRING D6b-ArSol1-1
11987: PPUSH
11988: CALL_OW 88
// async ;
11992: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
11993: LD_EXP 38
11997: PPUSH
11998: LD_STRING D6b-Pow-2
12000: PPUSH
12001: CALL_OW 88
// if tmp2 > 1 then
12005: LD_VAR 0 4
12009: PUSH
12010: LD_INT 1
12012: GREATER
12013: IFFALSE 12031
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
12015: LD_VAR 0 4
12019: PUSH
12020: LD_INT 2
12022: ARRAY
12023: PPUSH
12024: LD_STRING D6b-ArSol2-1
12026: PPUSH
12027: CALL_OW 88
// sync ;
12031: SYNC
// repeat wait ( 5 ) ;
12032: LD_INT 5
12034: PPUSH
12035: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
12039: LD_INT 93
12041: PPUSH
12042: LD_INT 36
12044: PPUSH
12045: CALL_OW 428
12049: PPUSH
12050: CALL_OW 255
12054: PUSH
12055: LD_INT 4
12057: EQUAL
12058: IFFALSE 12032
// DialogueOn ;
12060: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
12064: LD_INT 10
12066: PPUSH
12067: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
12071: LD_EXP 38
12075: PPUSH
12076: LD_STRING D6b-Pow-2a
12078: PPUSH
12079: CALL_OW 88
// DialogueOff ;
12083: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
12087: LD_EXP 38
12091: PPUSH
12092: CALL_OW 310
12096: PPUSH
12097: LD_INT 332
12099: PPUSH
12100: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
12104: LD_INT 93
12106: PPUSH
12107: LD_INT 35
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: LD_INT 6
12115: NEG
12116: PPUSH
12117: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
12121: LD_INT 35
12123: PPUSH
12124: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
12128: LD_INT 332
12130: PPUSH
12131: CALL_OW 256
12135: PUSH
12136: LD_INT 1000
12138: LESS
12139: PUSH
12140: LD_INT 332
12142: PPUSH
12143: CALL_OW 300
12147: AND
12148: IFFALSE 12160
// SetLives ( kozlov_fac , 1 ) ;
12150: LD_INT 332
12152: PPUSH
12153: LD_INT 1
12155: PPUSH
12156: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
12160: LD_INT 332
12162: PPUSH
12163: CALL_OW 301
12167: PUSH
12168: LD_EXP 38
12172: PPUSH
12173: CALL_OW 301
12177: OR
12178: IFFALSE 12121
// game_speed := 4 ;
12180: LD_ADDR_OWVAR 65
12184: PUSH
12185: LD_INT 4
12187: ST_TO_ADDR
// powellCenterCameraMode := false ;
12188: LD_ADDR_EXP 19
12192: PUSH
12193: LD_INT 0
12195: ST_TO_ADDR
// for i in tmp do
12196: LD_ADDR_VAR 0 1
12200: PUSH
12201: LD_VAR 0 3
12205: PUSH
12206: FOR_IN
12207: IFFALSE 12223
// SetTag ( i , 0 ) ;
12209: LD_VAR 0 1
12213: PPUSH
12214: LD_INT 0
12216: PPUSH
12217: CALL_OW 109
12221: GO 12206
12223: POP
12224: POP
// wait ( 0 0$3 ) ;
12225: LD_INT 105
12227: PPUSH
12228: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
12232: LD_INT 93
12234: PPUSH
12235: LD_INT 35
12237: PPUSH
12238: LD_INT 1
12240: PPUSH
12241: CALL_OW 331
// DialogueOn ;
12245: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
12249: LD_VAR 0 11
12253: PPUSH
12254: LD_STRING D6c-Sol3-1
12256: PPUSH
12257: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12261: LD_INT 10
12263: PPUSH
12264: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
12268: LD_EXP 20
12272: PPUSH
12273: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
12277: LD_EXP 20
12281: PPUSH
12282: LD_STRING D6c-JMM-1
12284: PPUSH
12285: CALL_OW 88
// if Cyrus then
12289: LD_EXP 26
12293: IFFALSE 12307
// Say ( Cyrus , D6c-Cyrus-1 ) ;
12295: LD_EXP 26
12299: PPUSH
12300: LD_STRING D6c-Cyrus-1
12302: PPUSH
12303: CALL_OW 88
// if Bobby then
12307: LD_EXP 25
12311: IFFALSE 12325
// Say ( Bobby , D6c-Bobby-1 ) ;
12313: LD_EXP 25
12317: PPUSH
12318: LD_STRING D6c-Bobby-1
12320: PPUSH
12321: CALL_OW 88
// if Cornel then
12325: LD_EXP 31
12329: IFFALSE 12343
// Say ( Cornel , D6c-Corn-1 ) ;
12331: LD_EXP 31
12335: PPUSH
12336: LD_STRING D6c-Corn-1
12338: PPUSH
12339: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] ] ) diff ( speaker union JMM union vip ) ;
12343: LD_ADDR_VAR 0 4
12347: PUSH
12348: LD_INT 2
12350: PUSH
12351: LD_INT 22
12353: PUSH
12354: LD_INT 1
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: PUSH
12361: LD_INT 22
12363: PUSH
12364: LD_INT 4
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: LIST
12375: PUSH
12376: LD_INT 26
12378: PUSH
12379: LD_INT 1
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: PPUSH
12390: CALL_OW 69
12394: PUSH
12395: LD_VAR 0 11
12399: PUSH
12400: LD_EXP 20
12404: UNION
12405: PUSH
12406: LD_EXP 39
12410: UNION
12411: DIFF
12412: ST_TO_ADDR
// if tmp2 then
12413: LD_VAR 0 4
12417: IFFALSE 12435
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
12419: LD_VAR 0 4
12423: PUSH
12424: LD_INT 1
12426: ARRAY
12427: PPUSH
12428: LD_STRING D6c-Sol1-1
12430: PPUSH
12431: CALL_OW 88
// if Lisa then
12435: LD_EXP 23
12439: IFFALSE 12453
// Say ( Lisa , D6c-Lisa-1 ) ;
12441: LD_EXP 23
12445: PPUSH
12446: LD_STRING D6c-Lisa-1
12448: PPUSH
12449: CALL_OW 88
// if Gary then
12453: LD_EXP 32
12457: IFFALSE 12471
// Say ( Gary , D6c-Gary-1 ) ;
12459: LD_EXP 32
12463: PPUSH
12464: LD_STRING D6c-Gary-1
12466: PPUSH
12467: CALL_OW 88
// if Donaldson then
12471: LD_EXP 24
12475: IFFALSE 12489
// Say ( Donaldson , D6c-Don-1 ) ;
12477: LD_EXP 24
12481: PPUSH
12482: LD_STRING D6c-Don-1
12484: PPUSH
12485: CALL_OW 88
// if tmp2 > 1 then
12489: LD_VAR 0 4
12493: PUSH
12494: LD_INT 1
12496: GREATER
12497: IFFALSE 12515
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
12499: LD_VAR 0 4
12503: PUSH
12504: LD_INT 2
12506: ARRAY
12507: PPUSH
12508: LD_STRING D6c-Sol2-1
12510: PPUSH
12511: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
12515: LD_VAR 0 11
12519: PPUSH
12520: LD_STRING D6c-Sol3-2
12522: PPUSH
12523: CALL_OW 88
// dwait ( 0 0$1 ) ;
12527: LD_INT 35
12529: PPUSH
12530: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
12534: LD_EXP 20
12538: PPUSH
12539: LD_STRING D6c-JMM-2
12541: PPUSH
12542: CALL_OW 88
// DialogueOff ;
12546: CALL_OW 7
// Video ( false ) ;
12550: LD_INT 0
12552: PPUSH
12553: CALL 83271 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
12557: LD_INT 22
12559: PUSH
12560: LD_INT 4
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: PPUSH
12567: CALL_OW 69
12571: PPUSH
12572: LD_INT 1
12574: PPUSH
12575: CALL_OW 235
// for i in GetTechNation ( 4 , 1 , 2 ) do
12579: LD_ADDR_VAR 0 1
12583: PUSH
12584: LD_INT 4
12586: PPUSH
12587: LD_INT 1
12589: PPUSH
12590: LD_INT 2
12592: PPUSH
12593: CALL 41046 0 3
12597: PUSH
12598: FOR_IN
12599: IFFALSE 12636
// if GetTech ( i , 1 ) <> state_researched then
12601: LD_VAR 0 1
12605: PPUSH
12606: LD_INT 1
12608: PPUSH
12609: CALL_OW 321
12613: PUSH
12614: LD_INT 2
12616: NONEQUAL
12617: IFFALSE 12634
// SetTech ( i , 1 , state_researched ) ;
12619: LD_VAR 0 1
12623: PPUSH
12624: LD_INT 1
12626: PPUSH
12627: LD_INT 2
12629: PPUSH
12630: CALL_OW 322
12634: GO 12598
12636: POP
12637: POP
// missionStart := 0 0$00 ;
12638: LD_ADDR_EXP 12
12642: PUSH
12643: LD_INT 0
12645: ST_TO_ADDR
// missionStage := 6 ;
12646: LD_ADDR_EXP 14
12650: PUSH
12651: LD_INT 6
12653: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
12654: LD_STRING M2
12656: PPUSH
12657: CALL_OW 337
// SaveForQuickRestart ;
12661: CALL_OW 22
// end ;
12665: PPOPN 13
12667: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
12668: LD_EXP 19
12672: PUSH
12673: LD_EXP 38
12677: PPUSH
12678: CALL_OW 300
12682: AND
12683: IFFALSE 12725
12685: GO 12687
12687: DISABLE
// begin enable ;
12688: ENABLE
// if IsInUnit ( Powell ) then
12689: LD_EXP 38
12693: PPUSH
12694: CALL_OW 310
12698: IFFALSE 12716
// CenterOnUnits ( IsInUnit ( Powell ) ) else
12700: LD_EXP 38
12704: PPUSH
12705: CALL_OW 310
12709: PPUSH
12710: CALL_OW 85
12714: GO 12725
// CenterOnUnits ( Powell ) ;
12716: LD_EXP 38
12720: PPUSH
12721: CALL_OW 85
// end ; end_of_file
12725: END
// export function CustomEvent ( event ) ; begin
12726: LD_INT 0
12728: PPUSH
// end ;
12729: LD_VAR 0 2
12733: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
12734: LD_VAR 0 1
12738: PPUSH
12739: CALL 38459 0 1
// end ;
12743: PPOPN 1
12745: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12746: LD_VAR 0 1
12750: PPUSH
12751: LD_VAR 0 2
12755: PPUSH
12756: CALL 40365 0 2
// end ;
12760: PPOPN 2
12762: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12763: LD_VAR 0 1
12767: PPUSH
12768: CALL 39433 0 1
// end ;
12772: PPOPN 1
12774: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: CALL 39674 0 1
// end ;
12784: PPOPN 1
12786: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12787: LD_VAR 0 1
12791: PPUSH
12792: LD_VAR 0 2
12796: PPUSH
12797: CALL 38155 0 2
// end ;
12801: PPOPN 2
12803: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: LD_VAR 0 4
12823: PPUSH
12824: LD_VAR 0 5
12828: PPUSH
12829: CALL 37775 0 5
// end ;
12833: PPOPN 5
12835: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12836: LD_VAR 0 1
12840: PPUSH
12841: LD_VAR 0 2
12845: PPUSH
12846: CALL 37365 0 2
// end ;
12850: PPOPN 2
12852: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12853: LD_VAR 0 1
12857: PPUSH
12858: LD_VAR 0 2
12862: PPUSH
12863: LD_VAR 0 3
12867: PPUSH
12868: LD_VAR 0 4
12872: PPUSH
12873: CALL 37203 0 4
// end ;
12877: PPOPN 4
12879: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12880: LD_VAR 0 1
12884: PPUSH
12885: LD_VAR 0 2
12889: PPUSH
12890: LD_VAR 0 3
12894: PPUSH
12895: CALL 36978 0 3
// end ;
12899: PPOPN 3
12901: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12902: LD_VAR 0 1
12906: PPUSH
12907: LD_VAR 0 2
12911: PPUSH
12912: CALL 36863 0 2
// end ;
12916: PPOPN 2
12918: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12919: LD_VAR 0 1
12923: PPUSH
12924: LD_VAR 0 2
12928: PPUSH
12929: CALL 40626 0 2
// end ;
12933: PPOPN 2
12935: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
12936: LD_VAR 0 1
12940: PPUSH
12941: CALL_OW 255
12945: PUSH
12946: LD_INT 4
12948: EQUAL
12949: PUSH
12950: LD_VAR 0 1
12954: PUSH
12955: LD_EXP 17
12959: PUSH
12960: LD_INT 1
12962: ARRAY
12963: IN
12964: AND
12965: PUSH
12966: LD_EXP 18
12970: AND
12971: IFFALSE 12990
// begin ComMoveXY ( driver , 61 , 93 ) ;
12973: LD_VAR 0 1
12977: PPUSH
12978: LD_INT 61
12980: PPUSH
12981: LD_INT 93
12983: PPUSH
12984: CALL_OW 111
// exit ;
12988: GO 13014
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12990: LD_VAR 0 1
12994: PPUSH
12995: LD_VAR 0 2
12999: PPUSH
13000: LD_VAR 0 3
13004: PPUSH
13005: LD_VAR 0 4
13009: PPUSH
13010: CALL 40842 0 4
// end ;
13014: PPOPN 4
13016: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13017: LD_VAR 0 1
13021: PPUSH
13022: LD_VAR 0 2
13026: PPUSH
13027: CALL 36672 0 2
// end ; end_of_file
13031: PPOPN 2
13033: END
// every 0 0$30 trigger missionStage = 2 do var time ;
13034: LD_EXP 14
13038: PUSH
13039: LD_INT 2
13041: EQUAL
13042: IFFALSE 13169
13044: GO 13046
13046: DISABLE
13047: LD_INT 0
13049: PPUSH
// begin time := 0 0$10 ;
13050: LD_ADDR_VAR 0 1
13054: PUSH
13055: LD_INT 350
13057: ST_TO_ADDR
// repeat wait ( time ) ;
13058: LD_VAR 0 1
13062: PPUSH
13063: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
13067: LD_INT 1
13069: PPUSH
13070: LD_INT 5
13072: PPUSH
13073: CALL_OW 12
13077: PPUSH
13078: LD_INT 106
13080: PPUSH
13081: LD_INT 150
13083: PPUSH
13084: LD_INT 19
13086: PPUSH
13087: LD_INT 1
13089: PPUSH
13090: CALL_OW 56
// time := time + 0 0$9 ;
13094: LD_ADDR_VAR 0 1
13098: PUSH
13099: LD_VAR 0 1
13103: PUSH
13104: LD_INT 315
13106: PLUS
13107: ST_TO_ADDR
// wait ( rand ( 0 0$3 , 0 0$11 ) ) ;
13108: LD_INT 105
13110: PPUSH
13111: LD_INT 385
13113: PPUSH
13114: CALL_OW 12
13118: PPUSH
13119: CALL_OW 67
// if Prob ( 50 ) then
13123: LD_INT 50
13125: PPUSH
13126: CALL_OW 13
13130: IFFALSE 13159
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
13132: LD_INT 1
13134: PPUSH
13135: LD_INT 5
13137: PPUSH
13138: CALL_OW 12
13142: PPUSH
13143: LD_INT 62
13145: PPUSH
13146: LD_INT 108
13148: PPUSH
13149: LD_INT 10
13151: PPUSH
13152: LD_INT 1
13154: PPUSH
13155: CALL_OW 56
// until missionStage > 2 ;
13159: LD_EXP 14
13163: PUSH
13164: LD_INT 2
13166: GREATER
13167: IFFALSE 13058
// end ; end_of_file
13169: PPOPN 1
13171: END
// every 0 0$1 trigger missionStart do
13172: LD_EXP 12
13176: IFFALSE 13223
13178: GO 13180
13180: DISABLE
// begin enable ;
13181: ENABLE
// missionTime := missionTime + 0 0$1 ;
13182: LD_ADDR_EXP 13
13186: PUSH
13187: LD_EXP 13
13191: PUSH
13192: LD_INT 35
13194: PLUS
13195: ST_TO_ADDR
// if missionStage >= 6 then
13196: LD_EXP 14
13200: PUSH
13201: LD_INT 6
13203: GREATEREQUAL
13204: IFFALSE 13223
// display_strings = [ #Am15-1 , missionTime ] ;
13206: LD_ADDR_OWVAR 47
13210: PUSH
13211: LD_STRING #Am15-1
13213: PUSH
13214: LD_EXP 13
13218: PUSH
13219: EMPTY
13220: LIST
13221: LIST
13222: ST_TO_ADDR
// end ; end_of_file
13223: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
13224: GO 13226
13226: DISABLE
// begin ru_radar := 98 ;
13227: LD_ADDR_EXP 62
13231: PUSH
13232: LD_INT 98
13234: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
13235: LD_ADDR_EXP 63
13239: PUSH
13240: LD_INT 89
13242: ST_TO_ADDR
// us_hack := 99 ;
13243: LD_ADDR_EXP 64
13247: PUSH
13248: LD_INT 99
13250: ST_TO_ADDR
// us_artillery := 97 ;
13251: LD_ADDR_EXP 65
13255: PUSH
13256: LD_INT 97
13258: ST_TO_ADDR
// ar_bio_bomb := 91 ;
13259: LD_ADDR_EXP 66
13263: PUSH
13264: LD_INT 91
13266: ST_TO_ADDR
// end ; end_of_file
13267: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
13268: LD_INT 0
13270: PPUSH
13271: PPUSH
// skirmish := false ;
13272: LD_ADDR_EXP 67
13276: PUSH
13277: LD_INT 0
13279: ST_TO_ADDR
// debug_mc := false ;
13280: LD_ADDR_EXP 68
13284: PUSH
13285: LD_INT 0
13287: ST_TO_ADDR
// mc_bases := [ ] ;
13288: LD_ADDR_EXP 69
13292: PUSH
13293: EMPTY
13294: ST_TO_ADDR
// mc_sides := [ ] ;
13295: LD_ADDR_EXP 95
13299: PUSH
13300: EMPTY
13301: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
13302: LD_ADDR_EXP 70
13306: PUSH
13307: EMPTY
13308: ST_TO_ADDR
// mc_building_repairs := [ ] ;
13309: LD_ADDR_EXP 71
13313: PUSH
13314: EMPTY
13315: ST_TO_ADDR
// mc_need_heal := [ ] ;
13316: LD_ADDR_EXP 72
13320: PUSH
13321: EMPTY
13322: ST_TO_ADDR
// mc_healers := [ ] ;
13323: LD_ADDR_EXP 73
13327: PUSH
13328: EMPTY
13329: ST_TO_ADDR
// mc_build_list := [ ] ;
13330: LD_ADDR_EXP 74
13334: PUSH
13335: EMPTY
13336: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
13337: LD_ADDR_EXP 101
13341: PUSH
13342: EMPTY
13343: ST_TO_ADDR
// mc_builders := [ ] ;
13344: LD_ADDR_EXP 75
13348: PUSH
13349: EMPTY
13350: ST_TO_ADDR
// mc_construct_list := [ ] ;
13351: LD_ADDR_EXP 76
13355: PUSH
13356: EMPTY
13357: ST_TO_ADDR
// mc_turret_list := [ ] ;
13358: LD_ADDR_EXP 77
13362: PUSH
13363: EMPTY
13364: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
13365: LD_ADDR_EXP 78
13369: PUSH
13370: EMPTY
13371: ST_TO_ADDR
// mc_miners := [ ] ;
13372: LD_ADDR_EXP 83
13376: PUSH
13377: EMPTY
13378: ST_TO_ADDR
// mc_mines := [ ] ;
13379: LD_ADDR_EXP 82
13383: PUSH
13384: EMPTY
13385: ST_TO_ADDR
// mc_minefields := [ ] ;
13386: LD_ADDR_EXP 84
13390: PUSH
13391: EMPTY
13392: ST_TO_ADDR
// mc_crates := [ ] ;
13393: LD_ADDR_EXP 85
13397: PUSH
13398: EMPTY
13399: ST_TO_ADDR
// mc_crates_collector := [ ] ;
13400: LD_ADDR_EXP 86
13404: PUSH
13405: EMPTY
13406: ST_TO_ADDR
// mc_crates_area := [ ] ;
13407: LD_ADDR_EXP 87
13411: PUSH
13412: EMPTY
13413: ST_TO_ADDR
// mc_vehicles := [ ] ;
13414: LD_ADDR_EXP 88
13418: PUSH
13419: EMPTY
13420: ST_TO_ADDR
// mc_attack := [ ] ;
13421: LD_ADDR_EXP 89
13425: PUSH
13426: EMPTY
13427: ST_TO_ADDR
// mc_produce := [ ] ;
13428: LD_ADDR_EXP 90
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// mc_defender := [ ] ;
13435: LD_ADDR_EXP 91
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// mc_parking := [ ] ;
13442: LD_ADDR_EXP 93
13446: PUSH
13447: EMPTY
13448: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
13449: LD_ADDR_EXP 79
13453: PUSH
13454: EMPTY
13455: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
13456: LD_ADDR_EXP 81
13460: PUSH
13461: EMPTY
13462: ST_TO_ADDR
// mc_scan := [ ] ;
13463: LD_ADDR_EXP 92
13467: PUSH
13468: EMPTY
13469: ST_TO_ADDR
// mc_scan_area := [ ] ;
13470: LD_ADDR_EXP 94
13474: PUSH
13475: EMPTY
13476: ST_TO_ADDR
// mc_tech := [ ] ;
13477: LD_ADDR_EXP 96
13481: PUSH
13482: EMPTY
13483: ST_TO_ADDR
// mc_class := [ ] ;
13484: LD_ADDR_EXP 110
13488: PUSH
13489: EMPTY
13490: ST_TO_ADDR
// mc_class_case_use := [ ] ;
13491: LD_ADDR_EXP 111
13495: PUSH
13496: EMPTY
13497: ST_TO_ADDR
// end ;
13498: LD_VAR 0 1
13502: RET
// export function MC_Kill ( base ) ; begin
13503: LD_INT 0
13505: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
13506: LD_ADDR_EXP 69
13510: PUSH
13511: LD_EXP 69
13515: PPUSH
13516: LD_VAR 0 1
13520: PPUSH
13521: EMPTY
13522: PPUSH
13523: CALL_OW 1
13527: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
13528: LD_ADDR_EXP 70
13532: PUSH
13533: LD_EXP 70
13537: PPUSH
13538: LD_VAR 0 1
13542: PPUSH
13543: EMPTY
13544: PPUSH
13545: CALL_OW 1
13549: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
13550: LD_ADDR_EXP 71
13554: PUSH
13555: LD_EXP 71
13559: PPUSH
13560: LD_VAR 0 1
13564: PPUSH
13565: EMPTY
13566: PPUSH
13567: CALL_OW 1
13571: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
13572: LD_ADDR_EXP 72
13576: PUSH
13577: LD_EXP 72
13581: PPUSH
13582: LD_VAR 0 1
13586: PPUSH
13587: EMPTY
13588: PPUSH
13589: CALL_OW 1
13593: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
13594: LD_ADDR_EXP 73
13598: PUSH
13599: LD_EXP 73
13603: PPUSH
13604: LD_VAR 0 1
13608: PPUSH
13609: EMPTY
13610: PPUSH
13611: CALL_OW 1
13615: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
13616: LD_ADDR_EXP 74
13620: PUSH
13621: LD_EXP 74
13625: PPUSH
13626: LD_VAR 0 1
13630: PPUSH
13631: EMPTY
13632: PPUSH
13633: CALL_OW 1
13637: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
13638: LD_ADDR_EXP 75
13642: PUSH
13643: LD_EXP 75
13647: PPUSH
13648: LD_VAR 0 1
13652: PPUSH
13653: EMPTY
13654: PPUSH
13655: CALL_OW 1
13659: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
13660: LD_ADDR_EXP 76
13664: PUSH
13665: LD_EXP 76
13669: PPUSH
13670: LD_VAR 0 1
13674: PPUSH
13675: EMPTY
13676: PPUSH
13677: CALL_OW 1
13681: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
13682: LD_ADDR_EXP 77
13686: PUSH
13687: LD_EXP 77
13691: PPUSH
13692: LD_VAR 0 1
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL_OW 1
13703: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
13704: LD_ADDR_EXP 78
13708: PUSH
13709: LD_EXP 78
13713: PPUSH
13714: LD_VAR 0 1
13718: PPUSH
13719: EMPTY
13720: PPUSH
13721: CALL_OW 1
13725: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
13726: LD_ADDR_EXP 79
13730: PUSH
13731: LD_EXP 79
13735: PPUSH
13736: LD_VAR 0 1
13740: PPUSH
13741: EMPTY
13742: PPUSH
13743: CALL_OW 1
13747: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
13748: LD_ADDR_EXP 80
13752: PUSH
13753: LD_EXP 80
13757: PPUSH
13758: LD_VAR 0 1
13762: PPUSH
13763: LD_INT 0
13765: PPUSH
13766: CALL_OW 1
13770: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
13771: LD_ADDR_EXP 81
13775: PUSH
13776: LD_EXP 81
13780: PPUSH
13781: LD_VAR 0 1
13785: PPUSH
13786: EMPTY
13787: PPUSH
13788: CALL_OW 1
13792: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
13793: LD_ADDR_EXP 82
13797: PUSH
13798: LD_EXP 82
13802: PPUSH
13803: LD_VAR 0 1
13807: PPUSH
13808: EMPTY
13809: PPUSH
13810: CALL_OW 1
13814: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
13815: LD_ADDR_EXP 83
13819: PUSH
13820: LD_EXP 83
13824: PPUSH
13825: LD_VAR 0 1
13829: PPUSH
13830: EMPTY
13831: PPUSH
13832: CALL_OW 1
13836: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
13837: LD_ADDR_EXP 84
13841: PUSH
13842: LD_EXP 84
13846: PPUSH
13847: LD_VAR 0 1
13851: PPUSH
13852: EMPTY
13853: PPUSH
13854: CALL_OW 1
13858: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
13859: LD_ADDR_EXP 85
13863: PUSH
13864: LD_EXP 85
13868: PPUSH
13869: LD_VAR 0 1
13873: PPUSH
13874: EMPTY
13875: PPUSH
13876: CALL_OW 1
13880: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
13881: LD_ADDR_EXP 86
13885: PUSH
13886: LD_EXP 86
13890: PPUSH
13891: LD_VAR 0 1
13895: PPUSH
13896: EMPTY
13897: PPUSH
13898: CALL_OW 1
13902: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
13903: LD_ADDR_EXP 87
13907: PUSH
13908: LD_EXP 87
13912: PPUSH
13913: LD_VAR 0 1
13917: PPUSH
13918: EMPTY
13919: PPUSH
13920: CALL_OW 1
13924: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
13925: LD_ADDR_EXP 88
13929: PUSH
13930: LD_EXP 88
13934: PPUSH
13935: LD_VAR 0 1
13939: PPUSH
13940: EMPTY
13941: PPUSH
13942: CALL_OW 1
13946: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
13947: LD_ADDR_EXP 89
13951: PUSH
13952: LD_EXP 89
13956: PPUSH
13957: LD_VAR 0 1
13961: PPUSH
13962: EMPTY
13963: PPUSH
13964: CALL_OW 1
13968: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
13969: LD_ADDR_EXP 90
13973: PUSH
13974: LD_EXP 90
13978: PPUSH
13979: LD_VAR 0 1
13983: PPUSH
13984: EMPTY
13985: PPUSH
13986: CALL_OW 1
13990: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
13991: LD_ADDR_EXP 91
13995: PUSH
13996: LD_EXP 91
14000: PPUSH
14001: LD_VAR 0 1
14005: PPUSH
14006: EMPTY
14007: PPUSH
14008: CALL_OW 1
14012: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
14013: LD_ADDR_EXP 92
14017: PUSH
14018: LD_EXP 92
14022: PPUSH
14023: LD_VAR 0 1
14027: PPUSH
14028: EMPTY
14029: PPUSH
14030: CALL_OW 1
14034: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
14035: LD_ADDR_EXP 93
14039: PUSH
14040: LD_EXP 93
14044: PPUSH
14045: LD_VAR 0 1
14049: PPUSH
14050: EMPTY
14051: PPUSH
14052: CALL_OW 1
14056: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
14057: LD_ADDR_EXP 94
14061: PUSH
14062: LD_EXP 94
14066: PPUSH
14067: LD_VAR 0 1
14071: PPUSH
14072: EMPTY
14073: PPUSH
14074: CALL_OW 1
14078: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
14079: LD_ADDR_EXP 96
14083: PUSH
14084: LD_EXP 96
14088: PPUSH
14089: LD_VAR 0 1
14093: PPUSH
14094: EMPTY
14095: PPUSH
14096: CALL_OW 1
14100: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
14101: LD_ADDR_EXP 98
14105: PUSH
14106: LD_EXP 98
14110: PPUSH
14111: LD_VAR 0 1
14115: PPUSH
14116: EMPTY
14117: PPUSH
14118: CALL_OW 1
14122: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
14123: LD_ADDR_EXP 99
14127: PUSH
14128: LD_EXP 99
14132: PPUSH
14133: LD_VAR 0 1
14137: PPUSH
14138: EMPTY
14139: PPUSH
14140: CALL_OW 1
14144: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
14145: LD_ADDR_EXP 100
14149: PUSH
14150: LD_EXP 100
14154: PPUSH
14155: LD_VAR 0 1
14159: PPUSH
14160: EMPTY
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
14167: LD_ADDR_EXP 101
14171: PUSH
14172: LD_EXP 101
14176: PPUSH
14177: LD_VAR 0 1
14181: PPUSH
14182: EMPTY
14183: PPUSH
14184: CALL_OW 1
14188: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
14189: LD_ADDR_EXP 102
14193: PUSH
14194: LD_EXP 102
14198: PPUSH
14199: LD_VAR 0 1
14203: PPUSH
14204: EMPTY
14205: PPUSH
14206: CALL_OW 1
14210: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
14211: LD_ADDR_EXP 103
14215: PUSH
14216: LD_EXP 103
14220: PPUSH
14221: LD_VAR 0 1
14225: PPUSH
14226: EMPTY
14227: PPUSH
14228: CALL_OW 1
14232: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
14233: LD_ADDR_EXP 104
14237: PUSH
14238: LD_EXP 104
14242: PPUSH
14243: LD_VAR 0 1
14247: PPUSH
14248: EMPTY
14249: PPUSH
14250: CALL_OW 1
14254: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
14255: LD_ADDR_EXP 105
14259: PUSH
14260: LD_EXP 105
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: EMPTY
14271: PPUSH
14272: CALL_OW 1
14276: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
14277: LD_ADDR_EXP 106
14281: PUSH
14282: LD_EXP 106
14286: PPUSH
14287: LD_VAR 0 1
14291: PPUSH
14292: EMPTY
14293: PPUSH
14294: CALL_OW 1
14298: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
14299: LD_ADDR_EXP 107
14303: PUSH
14304: LD_EXP 107
14308: PPUSH
14309: LD_VAR 0 1
14313: PPUSH
14314: EMPTY
14315: PPUSH
14316: CALL_OW 1
14320: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
14321: LD_ADDR_EXP 108
14325: PUSH
14326: LD_EXP 108
14330: PPUSH
14331: LD_VAR 0 1
14335: PPUSH
14336: EMPTY
14337: PPUSH
14338: CALL_OW 1
14342: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
14343: LD_ADDR_EXP 109
14347: PUSH
14348: LD_EXP 109
14352: PPUSH
14353: LD_VAR 0 1
14357: PPUSH
14358: EMPTY
14359: PPUSH
14360: CALL_OW 1
14364: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
14365: LD_ADDR_EXP 110
14369: PUSH
14370: LD_EXP 110
14374: PPUSH
14375: LD_VAR 0 1
14379: PPUSH
14380: EMPTY
14381: PPUSH
14382: CALL_OW 1
14386: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
14387: LD_ADDR_EXP 111
14391: PUSH
14392: LD_EXP 111
14396: PPUSH
14397: LD_VAR 0 1
14401: PPUSH
14402: LD_INT 0
14404: PPUSH
14405: CALL_OW 1
14409: ST_TO_ADDR
// end ;
14410: LD_VAR 0 2
14414: RET
// export function MC_Start ( ) ; var i ; begin
14415: LD_INT 0
14417: PPUSH
14418: PPUSH
// for i = 1 to mc_bases do
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: DOUBLE
14425: LD_INT 1
14427: DEC
14428: ST_TO_ADDR
14429: LD_EXP 69
14433: PUSH
14434: FOR_TO
14435: IFFALSE 15512
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
14437: LD_ADDR_EXP 69
14441: PUSH
14442: LD_EXP 69
14446: PPUSH
14447: LD_VAR 0 2
14451: PPUSH
14452: LD_EXP 69
14456: PUSH
14457: LD_VAR 0 2
14461: ARRAY
14462: PUSH
14463: LD_INT 0
14465: DIFF
14466: PPUSH
14467: CALL_OW 1
14471: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
14472: LD_ADDR_EXP 70
14476: PUSH
14477: LD_EXP 70
14481: PPUSH
14482: LD_VAR 0 2
14486: PPUSH
14487: EMPTY
14488: PPUSH
14489: CALL_OW 1
14493: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
14494: LD_ADDR_EXP 71
14498: PUSH
14499: LD_EXP 71
14503: PPUSH
14504: LD_VAR 0 2
14508: PPUSH
14509: EMPTY
14510: PPUSH
14511: CALL_OW 1
14515: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
14516: LD_ADDR_EXP 72
14520: PUSH
14521: LD_EXP 72
14525: PPUSH
14526: LD_VAR 0 2
14530: PPUSH
14531: EMPTY
14532: PPUSH
14533: CALL_OW 1
14537: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
14538: LD_ADDR_EXP 73
14542: PUSH
14543: LD_EXP 73
14547: PPUSH
14548: LD_VAR 0 2
14552: PPUSH
14553: EMPTY
14554: PUSH
14555: EMPTY
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PPUSH
14561: CALL_OW 1
14565: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
14566: LD_ADDR_EXP 74
14570: PUSH
14571: LD_EXP 74
14575: PPUSH
14576: LD_VAR 0 2
14580: PPUSH
14581: EMPTY
14582: PPUSH
14583: CALL_OW 1
14587: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
14588: LD_ADDR_EXP 101
14592: PUSH
14593: LD_EXP 101
14597: PPUSH
14598: LD_VAR 0 2
14602: PPUSH
14603: EMPTY
14604: PPUSH
14605: CALL_OW 1
14609: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
14610: LD_ADDR_EXP 75
14614: PUSH
14615: LD_EXP 75
14619: PPUSH
14620: LD_VAR 0 2
14624: PPUSH
14625: EMPTY
14626: PPUSH
14627: CALL_OW 1
14631: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
14632: LD_ADDR_EXP 76
14636: PUSH
14637: LD_EXP 76
14641: PPUSH
14642: LD_VAR 0 2
14646: PPUSH
14647: EMPTY
14648: PPUSH
14649: CALL_OW 1
14653: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
14654: LD_ADDR_EXP 77
14658: PUSH
14659: LD_EXP 77
14663: PPUSH
14664: LD_VAR 0 2
14668: PPUSH
14669: LD_EXP 69
14673: PUSH
14674: LD_VAR 0 2
14678: ARRAY
14679: PPUSH
14680: LD_INT 2
14682: PUSH
14683: LD_INT 30
14685: PUSH
14686: LD_INT 32
14688: PUSH
14689: EMPTY
14690: LIST
14691: LIST
14692: PUSH
14693: LD_INT 30
14695: PUSH
14696: LD_INT 33
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 72
14712: PPUSH
14713: CALL_OW 1
14717: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
14718: LD_ADDR_EXP 78
14722: PUSH
14723: LD_EXP 78
14727: PPUSH
14728: LD_VAR 0 2
14732: PPUSH
14733: LD_EXP 69
14737: PUSH
14738: LD_VAR 0 2
14742: ARRAY
14743: PPUSH
14744: LD_INT 2
14746: PUSH
14747: LD_INT 30
14749: PUSH
14750: LD_INT 32
14752: PUSH
14753: EMPTY
14754: LIST
14755: LIST
14756: PUSH
14757: LD_INT 30
14759: PUSH
14760: LD_INT 31
14762: PUSH
14763: EMPTY
14764: LIST
14765: LIST
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: LIST
14771: PUSH
14772: LD_INT 58
14774: PUSH
14775: EMPTY
14776: LIST
14777: PUSH
14778: EMPTY
14779: LIST
14780: LIST
14781: PPUSH
14782: CALL_OW 72
14786: PPUSH
14787: CALL_OW 1
14791: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
14792: LD_ADDR_EXP 79
14796: PUSH
14797: LD_EXP 79
14801: PPUSH
14802: LD_VAR 0 2
14806: PPUSH
14807: EMPTY
14808: PPUSH
14809: CALL_OW 1
14813: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
14814: LD_ADDR_EXP 83
14818: PUSH
14819: LD_EXP 83
14823: PPUSH
14824: LD_VAR 0 2
14828: PPUSH
14829: EMPTY
14830: PPUSH
14831: CALL_OW 1
14835: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
14836: LD_ADDR_EXP 82
14840: PUSH
14841: LD_EXP 82
14845: PPUSH
14846: LD_VAR 0 2
14850: PPUSH
14851: EMPTY
14852: PPUSH
14853: CALL_OW 1
14857: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
14858: LD_ADDR_EXP 84
14862: PUSH
14863: LD_EXP 84
14867: PPUSH
14868: LD_VAR 0 2
14872: PPUSH
14873: EMPTY
14874: PPUSH
14875: CALL_OW 1
14879: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
14880: LD_ADDR_EXP 85
14884: PUSH
14885: LD_EXP 85
14889: PPUSH
14890: LD_VAR 0 2
14894: PPUSH
14895: EMPTY
14896: PPUSH
14897: CALL_OW 1
14901: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
14902: LD_ADDR_EXP 86
14906: PUSH
14907: LD_EXP 86
14911: PPUSH
14912: LD_VAR 0 2
14916: PPUSH
14917: EMPTY
14918: PPUSH
14919: CALL_OW 1
14923: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
14924: LD_ADDR_EXP 87
14928: PUSH
14929: LD_EXP 87
14933: PPUSH
14934: LD_VAR 0 2
14938: PPUSH
14939: EMPTY
14940: PPUSH
14941: CALL_OW 1
14945: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
14946: LD_ADDR_EXP 88
14950: PUSH
14951: LD_EXP 88
14955: PPUSH
14956: LD_VAR 0 2
14960: PPUSH
14961: EMPTY
14962: PPUSH
14963: CALL_OW 1
14967: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
14968: LD_ADDR_EXP 89
14972: PUSH
14973: LD_EXP 89
14977: PPUSH
14978: LD_VAR 0 2
14982: PPUSH
14983: EMPTY
14984: PPUSH
14985: CALL_OW 1
14989: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
14990: LD_ADDR_EXP 90
14994: PUSH
14995: LD_EXP 90
14999: PPUSH
15000: LD_VAR 0 2
15004: PPUSH
15005: EMPTY
15006: PPUSH
15007: CALL_OW 1
15011: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
15012: LD_ADDR_EXP 91
15016: PUSH
15017: LD_EXP 91
15021: PPUSH
15022: LD_VAR 0 2
15026: PPUSH
15027: EMPTY
15028: PPUSH
15029: CALL_OW 1
15033: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
15034: LD_ADDR_EXP 80
15038: PUSH
15039: LD_EXP 80
15043: PPUSH
15044: LD_VAR 0 2
15048: PPUSH
15049: LD_INT 0
15051: PPUSH
15052: CALL_OW 1
15056: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
15057: LD_ADDR_EXP 93
15061: PUSH
15062: LD_EXP 93
15066: PPUSH
15067: LD_VAR 0 2
15071: PPUSH
15072: LD_INT 0
15074: PPUSH
15075: CALL_OW 1
15079: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
15080: LD_ADDR_EXP 81
15084: PUSH
15085: LD_EXP 81
15089: PPUSH
15090: LD_VAR 0 2
15094: PPUSH
15095: EMPTY
15096: PPUSH
15097: CALL_OW 1
15101: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
15102: LD_ADDR_EXP 92
15106: PUSH
15107: LD_EXP 92
15111: PPUSH
15112: LD_VAR 0 2
15116: PPUSH
15117: LD_INT 0
15119: PPUSH
15120: CALL_OW 1
15124: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
15125: LD_ADDR_EXP 94
15129: PUSH
15130: LD_EXP 94
15134: PPUSH
15135: LD_VAR 0 2
15139: PPUSH
15140: EMPTY
15141: PPUSH
15142: CALL_OW 1
15146: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
15147: LD_ADDR_EXP 97
15151: PUSH
15152: LD_EXP 97
15156: PPUSH
15157: LD_VAR 0 2
15161: PPUSH
15162: LD_INT 0
15164: PPUSH
15165: CALL_OW 1
15169: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
15170: LD_ADDR_EXP 98
15174: PUSH
15175: LD_EXP 98
15179: PPUSH
15180: LD_VAR 0 2
15184: PPUSH
15185: EMPTY
15186: PPUSH
15187: CALL_OW 1
15191: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
15192: LD_ADDR_EXP 99
15196: PUSH
15197: LD_EXP 99
15201: PPUSH
15202: LD_VAR 0 2
15206: PPUSH
15207: EMPTY
15208: PPUSH
15209: CALL_OW 1
15213: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
15214: LD_ADDR_EXP 100
15218: PUSH
15219: LD_EXP 100
15223: PPUSH
15224: LD_VAR 0 2
15228: PPUSH
15229: EMPTY
15230: PPUSH
15231: CALL_OW 1
15235: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
15236: LD_ADDR_EXP 102
15240: PUSH
15241: LD_EXP 102
15245: PPUSH
15246: LD_VAR 0 2
15250: PPUSH
15251: LD_EXP 69
15255: PUSH
15256: LD_VAR 0 2
15260: ARRAY
15261: PPUSH
15262: LD_INT 2
15264: PUSH
15265: LD_INT 30
15267: PUSH
15268: LD_INT 6
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 30
15277: PUSH
15278: LD_INT 7
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: PUSH
15285: LD_INT 30
15287: PUSH
15288: LD_INT 8
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: LIST
15299: LIST
15300: PPUSH
15301: CALL_OW 72
15305: PPUSH
15306: CALL_OW 1
15310: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
15311: LD_ADDR_EXP 103
15315: PUSH
15316: LD_EXP 103
15320: PPUSH
15321: LD_VAR 0 2
15325: PPUSH
15326: EMPTY
15327: PPUSH
15328: CALL_OW 1
15332: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
15333: LD_ADDR_EXP 104
15337: PUSH
15338: LD_EXP 104
15342: PPUSH
15343: LD_VAR 0 2
15347: PPUSH
15348: EMPTY
15349: PPUSH
15350: CALL_OW 1
15354: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
15355: LD_ADDR_EXP 105
15359: PUSH
15360: LD_EXP 105
15364: PPUSH
15365: LD_VAR 0 2
15369: PPUSH
15370: EMPTY
15371: PPUSH
15372: CALL_OW 1
15376: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
15377: LD_ADDR_EXP 106
15381: PUSH
15382: LD_EXP 106
15386: PPUSH
15387: LD_VAR 0 2
15391: PPUSH
15392: EMPTY
15393: PPUSH
15394: CALL_OW 1
15398: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
15399: LD_ADDR_EXP 107
15403: PUSH
15404: LD_EXP 107
15408: PPUSH
15409: LD_VAR 0 2
15413: PPUSH
15414: EMPTY
15415: PPUSH
15416: CALL_OW 1
15420: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
15421: LD_ADDR_EXP 108
15425: PUSH
15426: LD_EXP 108
15430: PPUSH
15431: LD_VAR 0 2
15435: PPUSH
15436: EMPTY
15437: PPUSH
15438: CALL_OW 1
15442: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
15443: LD_ADDR_EXP 109
15447: PUSH
15448: LD_EXP 109
15452: PPUSH
15453: LD_VAR 0 2
15457: PPUSH
15458: EMPTY
15459: PPUSH
15460: CALL_OW 1
15464: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
15465: LD_ADDR_EXP 110
15469: PUSH
15470: LD_EXP 110
15474: PPUSH
15475: LD_VAR 0 2
15479: PPUSH
15480: EMPTY
15481: PPUSH
15482: CALL_OW 1
15486: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
15487: LD_ADDR_EXP 111
15491: PUSH
15492: LD_EXP 111
15496: PPUSH
15497: LD_VAR 0 2
15501: PPUSH
15502: LD_INT 0
15504: PPUSH
15505: CALL_OW 1
15509: ST_TO_ADDR
// end ;
15510: GO 14434
15512: POP
15513: POP
// MC_InitSides ( ) ;
15514: CALL 15800 0 0
// MC_InitResearch ( ) ;
15518: CALL 15539 0 0
// CustomInitMacro ( ) ;
15522: CALL 286 0 0
// skirmish := true ;
15526: LD_ADDR_EXP 67
15530: PUSH
15531: LD_INT 1
15533: ST_TO_ADDR
// end ;
15534: LD_VAR 0 1
15538: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
15539: LD_INT 0
15541: PPUSH
15542: PPUSH
15543: PPUSH
15544: PPUSH
15545: PPUSH
15546: PPUSH
// if not mc_bases then
15547: LD_EXP 69
15551: NOT
15552: IFFALSE 15556
// exit ;
15554: GO 15795
// for i = 1 to 8 do
15556: LD_ADDR_VAR 0 2
15560: PUSH
15561: DOUBLE
15562: LD_INT 1
15564: DEC
15565: ST_TO_ADDR
15566: LD_INT 8
15568: PUSH
15569: FOR_TO
15570: IFFALSE 15596
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
15572: LD_ADDR_EXP 96
15576: PUSH
15577: LD_EXP 96
15581: PPUSH
15582: LD_VAR 0 2
15586: PPUSH
15587: EMPTY
15588: PPUSH
15589: CALL_OW 1
15593: ST_TO_ADDR
15594: GO 15569
15596: POP
15597: POP
// tmp := [ ] ;
15598: LD_ADDR_VAR 0 5
15602: PUSH
15603: EMPTY
15604: ST_TO_ADDR
// for i = 1 to mc_sides do
15605: LD_ADDR_VAR 0 2
15609: PUSH
15610: DOUBLE
15611: LD_INT 1
15613: DEC
15614: ST_TO_ADDR
15615: LD_EXP 95
15619: PUSH
15620: FOR_TO
15621: IFFALSE 15679
// if not mc_sides [ i ] in tmp then
15623: LD_EXP 95
15627: PUSH
15628: LD_VAR 0 2
15632: ARRAY
15633: PUSH
15634: LD_VAR 0 5
15638: IN
15639: NOT
15640: IFFALSE 15677
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
15642: LD_ADDR_VAR 0 5
15646: PUSH
15647: LD_VAR 0 5
15651: PPUSH
15652: LD_VAR 0 5
15656: PUSH
15657: LD_INT 1
15659: PLUS
15660: PPUSH
15661: LD_EXP 95
15665: PUSH
15666: LD_VAR 0 2
15670: ARRAY
15671: PPUSH
15672: CALL_OW 2
15676: ST_TO_ADDR
15677: GO 15620
15679: POP
15680: POP
// if not tmp then
15681: LD_VAR 0 5
15685: NOT
15686: IFFALSE 15690
// exit ;
15688: GO 15795
// for j in tmp do
15690: LD_ADDR_VAR 0 3
15694: PUSH
15695: LD_VAR 0 5
15699: PUSH
15700: FOR_IN
15701: IFFALSE 15793
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
15703: LD_ADDR_VAR 0 6
15707: PUSH
15708: LD_INT 22
15710: PUSH
15711: LD_VAR 0 3
15715: PUSH
15716: EMPTY
15717: LIST
15718: LIST
15719: PPUSH
15720: CALL_OW 69
15724: ST_TO_ADDR
// if not un then
15725: LD_VAR 0 6
15729: NOT
15730: IFFALSE 15734
// continue ;
15732: GO 15700
// nation := GetNation ( un [ 1 ] ) ;
15734: LD_ADDR_VAR 0 4
15738: PUSH
15739: LD_VAR 0 6
15743: PUSH
15744: LD_INT 1
15746: ARRAY
15747: PPUSH
15748: CALL_OW 248
15752: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
15753: LD_ADDR_EXP 96
15757: PUSH
15758: LD_EXP 96
15762: PPUSH
15763: LD_VAR 0 3
15767: PPUSH
15768: LD_VAR 0 3
15772: PPUSH
15773: LD_VAR 0 4
15777: PPUSH
15778: LD_INT 1
15780: PPUSH
15781: CALL 41046 0 3
15785: PPUSH
15786: CALL_OW 1
15790: ST_TO_ADDR
// end ;
15791: GO 15700
15793: POP
15794: POP
// end ;
15795: LD_VAR 0 1
15799: RET
// export function MC_InitSides ( ) ; var i ; begin
15800: LD_INT 0
15802: PPUSH
15803: PPUSH
// if not mc_bases then
15804: LD_EXP 69
15808: NOT
15809: IFFALSE 15813
// exit ;
15811: GO 15887
// for i = 1 to mc_bases do
15813: LD_ADDR_VAR 0 2
15817: PUSH
15818: DOUBLE
15819: LD_INT 1
15821: DEC
15822: ST_TO_ADDR
15823: LD_EXP 69
15827: PUSH
15828: FOR_TO
15829: IFFALSE 15885
// if mc_bases [ i ] then
15831: LD_EXP 69
15835: PUSH
15836: LD_VAR 0 2
15840: ARRAY
15841: IFFALSE 15883
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
15843: LD_ADDR_EXP 95
15847: PUSH
15848: LD_EXP 95
15852: PPUSH
15853: LD_VAR 0 2
15857: PPUSH
15858: LD_EXP 69
15862: PUSH
15863: LD_VAR 0 2
15867: ARRAY
15868: PUSH
15869: LD_INT 1
15871: ARRAY
15872: PPUSH
15873: CALL_OW 255
15877: PPUSH
15878: CALL_OW 1
15882: ST_TO_ADDR
15883: GO 15828
15885: POP
15886: POP
// end ;
15887: LD_VAR 0 1
15891: RET
// every 0 0$01 trigger skirmish do
15892: LD_EXP 67
15896: IFFALSE 16050
15898: GO 15900
15900: DISABLE
// begin enable ;
15901: ENABLE
// MC_CheckBuildings ( ) ;
15902: CALL 20216 0 0
// MC_CheckPeopleLife ( ) ;
15906: CALL 20341 0 0
// RaiseSailEvent ( 100 ) ;
15910: LD_INT 100
15912: PPUSH
15913: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
15917: LD_INT 103
15919: PPUSH
15920: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
15924: LD_INT 104
15926: PPUSH
15927: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
15931: LD_INT 105
15933: PPUSH
15934: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
15938: LD_INT 106
15940: PPUSH
15941: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
15945: LD_INT 107
15947: PPUSH
15948: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
15952: LD_INT 108
15954: PPUSH
15955: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
15959: LD_INT 109
15961: PPUSH
15962: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
15966: LD_INT 110
15968: PPUSH
15969: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
15973: LD_INT 111
15975: PPUSH
15976: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
15980: LD_INT 112
15982: PPUSH
15983: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
15987: LD_INT 113
15989: PPUSH
15990: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
15994: LD_INT 120
15996: PPUSH
15997: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
16001: LD_INT 121
16003: PPUSH
16004: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
16008: LD_INT 122
16010: PPUSH
16011: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
16015: LD_INT 123
16017: PPUSH
16018: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
16022: LD_INT 124
16024: PPUSH
16025: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
16029: LD_INT 125
16031: PPUSH
16032: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
16036: LD_INT 126
16038: PPUSH
16039: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
16043: LD_INT 200
16045: PPUSH
16046: CALL_OW 427
// end ;
16050: END
// on SailEvent ( event ) do begin if event < 100 then
16051: LD_VAR 0 1
16055: PUSH
16056: LD_INT 100
16058: LESS
16059: IFFALSE 16070
// CustomEvent ( event ) ;
16061: LD_VAR 0 1
16065: PPUSH
16066: CALL 12726 0 1
// if event = 100 then
16070: LD_VAR 0 1
16074: PUSH
16075: LD_INT 100
16077: EQUAL
16078: IFFALSE 16084
// MC_ClassManager ( ) ;
16080: CALL 16476 0 0
// if event = 101 then
16084: LD_VAR 0 1
16088: PUSH
16089: LD_INT 101
16091: EQUAL
16092: IFFALSE 16098
// MC_RepairBuildings ( ) ;
16094: CALL 20937 0 0
// if event = 102 then
16098: LD_VAR 0 1
16102: PUSH
16103: LD_INT 102
16105: EQUAL
16106: IFFALSE 16112
// MC_Heal ( ) ;
16108: CALL 21343 0 0
// if event = 103 then
16112: LD_VAR 0 1
16116: PUSH
16117: LD_INT 103
16119: EQUAL
16120: IFFALSE 16126
// MC_Build ( ) ;
16122: CALL 21765 0 0
// if event = 104 then
16126: LD_VAR 0 1
16130: PUSH
16131: LD_INT 104
16133: EQUAL
16134: IFFALSE 16140
// MC_TurretWeapon ( ) ;
16136: CALL 23378 0 0
// if event = 105 then
16140: LD_VAR 0 1
16144: PUSH
16145: LD_INT 105
16147: EQUAL
16148: IFFALSE 16154
// MC_BuildUpgrade ( ) ;
16150: CALL 22929 0 0
// if event = 106 then
16154: LD_VAR 0 1
16158: PUSH
16159: LD_INT 106
16161: EQUAL
16162: IFFALSE 16168
// MC_PlantMines ( ) ;
16164: CALL 23808 0 0
// if event = 107 then
16168: LD_VAR 0 1
16172: PUSH
16173: LD_INT 107
16175: EQUAL
16176: IFFALSE 16182
// MC_CollectCrates ( ) ;
16178: CALL 24842 0 0
// if event = 108 then
16182: LD_VAR 0 1
16186: PUSH
16187: LD_INT 108
16189: EQUAL
16190: IFFALSE 16196
// MC_LinkRemoteControl ( ) ;
16192: CALL 26599 0 0
// if event = 109 then
16196: LD_VAR 0 1
16200: PUSH
16201: LD_INT 109
16203: EQUAL
16204: IFFALSE 16210
// MC_ProduceVehicle ( ) ;
16206: CALL 26780 0 0
// if event = 110 then
16210: LD_VAR 0 1
16214: PUSH
16215: LD_INT 110
16217: EQUAL
16218: IFFALSE 16224
// MC_SendAttack ( ) ;
16220: CALL 27261 0 0
// if event = 111 then
16224: LD_VAR 0 1
16228: PUSH
16229: LD_INT 111
16231: EQUAL
16232: IFFALSE 16238
// MC_Defend ( ) ;
16234: CALL 27369 0 0
// if event = 112 then
16238: LD_VAR 0 1
16242: PUSH
16243: LD_INT 112
16245: EQUAL
16246: IFFALSE 16252
// MC_Research ( ) ;
16248: CALL 27996 0 0
// if event = 113 then
16252: LD_VAR 0 1
16256: PUSH
16257: LD_INT 113
16259: EQUAL
16260: IFFALSE 16266
// MC_MinesTrigger ( ) ;
16262: CALL 29110 0 0
// if event = 120 then
16266: LD_VAR 0 1
16270: PUSH
16271: LD_INT 120
16273: EQUAL
16274: IFFALSE 16280
// MC_RepairVehicle ( ) ;
16276: CALL 29209 0 0
// if event = 121 then
16280: LD_VAR 0 1
16284: PUSH
16285: LD_INT 121
16287: EQUAL
16288: IFFALSE 16294
// MC_TameApe ( ) ;
16290: CALL 29952 0 0
// if event = 122 then
16294: LD_VAR 0 1
16298: PUSH
16299: LD_INT 122
16301: EQUAL
16302: IFFALSE 16308
// MC_ChangeApeClass ( ) ;
16304: CALL 30781 0 0
// if event = 123 then
16308: LD_VAR 0 1
16312: PUSH
16313: LD_INT 123
16315: EQUAL
16316: IFFALSE 16322
// MC_Bazooka ( ) ;
16318: CALL 31431 0 0
// if event = 124 then
16322: LD_VAR 0 1
16326: PUSH
16327: LD_INT 124
16329: EQUAL
16330: IFFALSE 16336
// MC_TeleportExit ( ) ;
16332: CALL 31629 0 0
// if event = 125 then
16336: LD_VAR 0 1
16340: PUSH
16341: LD_INT 125
16343: EQUAL
16344: IFFALSE 16350
// MC_Deposits ( ) ;
16346: CALL 32276 0 0
// if event = 126 then
16350: LD_VAR 0 1
16354: PUSH
16355: LD_INT 126
16357: EQUAL
16358: IFFALSE 16364
// MC_RemoteDriver ( ) ;
16360: CALL 32901 0 0
// if event = 200 then
16364: LD_VAR 0 1
16368: PUSH
16369: LD_INT 200
16371: EQUAL
16372: IFFALSE 16378
// MC_Idle ( ) ;
16374: CALL 34634 0 0
// end ;
16378: PPOPN 1
16380: END
// export function MC_Reset ( base , tag ) ; var i ; begin
16381: LD_INT 0
16383: PPUSH
16384: PPUSH
// if not mc_bases [ base ] or not tag then
16385: LD_EXP 69
16389: PUSH
16390: LD_VAR 0 1
16394: ARRAY
16395: NOT
16396: PUSH
16397: LD_VAR 0 2
16401: NOT
16402: OR
16403: IFFALSE 16407
// exit ;
16405: GO 16471
// for i in mc_bases [ base ] union mc_ape [ base ] do
16407: LD_ADDR_VAR 0 4
16411: PUSH
16412: LD_EXP 69
16416: PUSH
16417: LD_VAR 0 1
16421: ARRAY
16422: PUSH
16423: LD_EXP 98
16427: PUSH
16428: LD_VAR 0 1
16432: ARRAY
16433: UNION
16434: PUSH
16435: FOR_IN
16436: IFFALSE 16469
// if GetTag ( i ) = tag then
16438: LD_VAR 0 4
16442: PPUSH
16443: CALL_OW 110
16447: PUSH
16448: LD_VAR 0 2
16452: EQUAL
16453: IFFALSE 16467
// SetTag ( i , 0 ) ;
16455: LD_VAR 0 4
16459: PPUSH
16460: LD_INT 0
16462: PPUSH
16463: CALL_OW 109
16467: GO 16435
16469: POP
16470: POP
// end ;
16471: LD_VAR 0 3
16475: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
16476: LD_INT 0
16478: PPUSH
16479: PPUSH
16480: PPUSH
16481: PPUSH
16482: PPUSH
16483: PPUSH
16484: PPUSH
16485: PPUSH
// if not mc_bases then
16486: LD_EXP 69
16490: NOT
16491: IFFALSE 16495
// exit ;
16493: GO 16953
// for i = 1 to mc_bases do
16495: LD_ADDR_VAR 0 2
16499: PUSH
16500: DOUBLE
16501: LD_INT 1
16503: DEC
16504: ST_TO_ADDR
16505: LD_EXP 69
16509: PUSH
16510: FOR_TO
16511: IFFALSE 16951
// begin tmp := MC_ClassCheckReq ( i ) ;
16513: LD_ADDR_VAR 0 4
16517: PUSH
16518: LD_VAR 0 2
16522: PPUSH
16523: CALL 16958 0 1
16527: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
16528: LD_ADDR_EXP 110
16532: PUSH
16533: LD_EXP 110
16537: PPUSH
16538: LD_VAR 0 2
16542: PPUSH
16543: LD_VAR 0 4
16547: PPUSH
16548: CALL_OW 1
16552: ST_TO_ADDR
// if not tmp then
16553: LD_VAR 0 4
16557: NOT
16558: IFFALSE 16562
// continue ;
16560: GO 16510
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
16562: LD_ADDR_VAR 0 6
16566: PUSH
16567: LD_EXP 69
16571: PUSH
16572: LD_VAR 0 2
16576: ARRAY
16577: PPUSH
16578: LD_INT 2
16580: PUSH
16581: LD_INT 30
16583: PUSH
16584: LD_INT 4
16586: PUSH
16587: EMPTY
16588: LIST
16589: LIST
16590: PUSH
16591: LD_INT 30
16593: PUSH
16594: LD_INT 5
16596: PUSH
16597: EMPTY
16598: LIST
16599: LIST
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: LIST
16605: PPUSH
16606: CALL_OW 72
16610: PUSH
16611: LD_EXP 69
16615: PUSH
16616: LD_VAR 0 2
16620: ARRAY
16621: PPUSH
16622: LD_INT 2
16624: PUSH
16625: LD_INT 30
16627: PUSH
16628: LD_INT 0
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: PUSH
16635: LD_INT 30
16637: PUSH
16638: LD_INT 1
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: LIST
16649: PPUSH
16650: CALL_OW 72
16654: PUSH
16655: LD_EXP 69
16659: PUSH
16660: LD_VAR 0 2
16664: ARRAY
16665: PPUSH
16666: LD_INT 30
16668: PUSH
16669: LD_INT 3
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PPUSH
16676: CALL_OW 72
16680: PUSH
16681: LD_EXP 69
16685: PUSH
16686: LD_VAR 0 2
16690: ARRAY
16691: PPUSH
16692: LD_INT 2
16694: PUSH
16695: LD_INT 30
16697: PUSH
16698: LD_INT 6
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: PUSH
16705: LD_INT 30
16707: PUSH
16708: LD_INT 7
16710: PUSH
16711: EMPTY
16712: LIST
16713: LIST
16714: PUSH
16715: LD_INT 30
16717: PUSH
16718: LD_INT 8
16720: PUSH
16721: EMPTY
16722: LIST
16723: LIST
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: PPUSH
16731: CALL_OW 72
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: LIST
16741: ST_TO_ADDR
// for j = 1 to 4 do
16742: LD_ADDR_VAR 0 3
16746: PUSH
16747: DOUBLE
16748: LD_INT 1
16750: DEC
16751: ST_TO_ADDR
16752: LD_INT 4
16754: PUSH
16755: FOR_TO
16756: IFFALSE 16947
// begin if not tmp [ j ] then
16758: LD_VAR 0 4
16762: PUSH
16763: LD_VAR 0 3
16767: ARRAY
16768: NOT
16769: IFFALSE 16773
// continue ;
16771: GO 16755
// for p in tmp [ j ] do
16773: LD_ADDR_VAR 0 5
16777: PUSH
16778: LD_VAR 0 4
16782: PUSH
16783: LD_VAR 0 3
16787: ARRAY
16788: PUSH
16789: FOR_IN
16790: IFFALSE 16943
// begin if not b [ j ] then
16792: LD_VAR 0 6
16796: PUSH
16797: LD_VAR 0 3
16801: ARRAY
16802: NOT
16803: IFFALSE 16807
// break ;
16805: GO 16943
// e := 0 ;
16807: LD_ADDR_VAR 0 7
16811: PUSH
16812: LD_INT 0
16814: ST_TO_ADDR
// for k in b [ j ] do
16815: LD_ADDR_VAR 0 8
16819: PUSH
16820: LD_VAR 0 6
16824: PUSH
16825: LD_VAR 0 3
16829: ARRAY
16830: PUSH
16831: FOR_IN
16832: IFFALSE 16859
// if IsNotFull ( k ) then
16834: LD_VAR 0 8
16838: PPUSH
16839: CALL 45072 0 1
16843: IFFALSE 16857
// begin e := k ;
16845: LD_ADDR_VAR 0 7
16849: PUSH
16850: LD_VAR 0 8
16854: ST_TO_ADDR
// break ;
16855: GO 16859
// end ;
16857: GO 16831
16859: POP
16860: POP
// if e and not UnitGoingToBuilding ( p , e ) then
16861: LD_VAR 0 7
16865: PUSH
16866: LD_VAR 0 5
16870: PPUSH
16871: LD_VAR 0 7
16875: PPUSH
16876: CALL 82060 0 2
16880: NOT
16881: AND
16882: IFFALSE 16941
// begin if IsInUnit ( p ) then
16884: LD_VAR 0 5
16888: PPUSH
16889: CALL_OW 310
16893: IFFALSE 16904
// ComExitBuilding ( p ) ;
16895: LD_VAR 0 5
16899: PPUSH
16900: CALL_OW 122
// ComEnterUnit ( p , e ) ;
16904: LD_VAR 0 5
16908: PPUSH
16909: LD_VAR 0 7
16913: PPUSH
16914: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
16918: LD_VAR 0 5
16922: PPUSH
16923: LD_VAR 0 3
16927: PPUSH
16928: CALL_OW 183
// AddComExitBuilding ( p ) ;
16932: LD_VAR 0 5
16936: PPUSH
16937: CALL_OW 182
// end ; end ;
16941: GO 16789
16943: POP
16944: POP
// end ;
16945: GO 16755
16947: POP
16948: POP
// end ;
16949: GO 16510
16951: POP
16952: POP
// end ;
16953: LD_VAR 0 1
16957: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
16958: LD_INT 0
16960: PPUSH
16961: PPUSH
16962: PPUSH
16963: PPUSH
16964: PPUSH
16965: PPUSH
16966: PPUSH
16967: PPUSH
16968: PPUSH
16969: PPUSH
16970: PPUSH
16971: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16972: LD_VAR 0 1
16976: NOT
16977: PUSH
16978: LD_EXP 69
16982: PUSH
16983: LD_VAR 0 1
16987: ARRAY
16988: NOT
16989: OR
16990: PUSH
16991: LD_EXP 69
16995: PUSH
16996: LD_VAR 0 1
17000: ARRAY
17001: PPUSH
17002: LD_INT 2
17004: PUSH
17005: LD_INT 30
17007: PUSH
17008: LD_INT 0
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PUSH
17015: LD_INT 30
17017: PUSH
17018: LD_INT 1
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: EMPTY
17026: LIST
17027: LIST
17028: LIST
17029: PPUSH
17030: CALL_OW 72
17034: NOT
17035: OR
17036: IFFALSE 17040
// exit ;
17038: GO 20211
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17040: LD_ADDR_VAR 0 4
17044: PUSH
17045: LD_EXP 69
17049: PUSH
17050: LD_VAR 0 1
17054: ARRAY
17055: PPUSH
17056: LD_INT 2
17058: PUSH
17059: LD_INT 25
17061: PUSH
17062: LD_INT 1
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: PUSH
17069: LD_INT 25
17071: PUSH
17072: LD_INT 2
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 25
17081: PUSH
17082: LD_INT 3
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PUSH
17089: LD_INT 25
17091: PUSH
17092: LD_INT 4
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: LD_INT 25
17101: PUSH
17102: LD_INT 5
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: PUSH
17109: LD_INT 25
17111: PUSH
17112: LD_INT 8
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: PUSH
17119: LD_INT 25
17121: PUSH
17122: LD_INT 9
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: PPUSH
17139: CALL_OW 72
17143: ST_TO_ADDR
// for i in tmp do
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_VAR 0 4
17153: PUSH
17154: FOR_IN
17155: IFFALSE 17186
// if GetTag ( i ) then
17157: LD_VAR 0 3
17161: PPUSH
17162: CALL_OW 110
17166: IFFALSE 17184
// tmp := tmp diff i ;
17168: LD_ADDR_VAR 0 4
17172: PUSH
17173: LD_VAR 0 4
17177: PUSH
17178: LD_VAR 0 3
17182: DIFF
17183: ST_TO_ADDR
17184: GO 17154
17186: POP
17187: POP
// if not tmp then
17188: LD_VAR 0 4
17192: NOT
17193: IFFALSE 17197
// exit ;
17195: GO 20211
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17197: LD_ADDR_VAR 0 5
17201: PUSH
17202: LD_EXP 69
17206: PUSH
17207: LD_VAR 0 1
17211: ARRAY
17212: PPUSH
17213: LD_INT 2
17215: PUSH
17216: LD_INT 25
17218: PUSH
17219: LD_INT 1
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 25
17228: PUSH
17229: LD_INT 5
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: LD_INT 25
17238: PUSH
17239: LD_INT 8
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: PUSH
17246: LD_INT 25
17248: PUSH
17249: LD_INT 9
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: PPUSH
17263: CALL_OW 72
17267: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
17268: LD_ADDR_VAR 0 6
17272: PUSH
17273: LD_EXP 69
17277: PUSH
17278: LD_VAR 0 1
17282: ARRAY
17283: PPUSH
17284: LD_INT 25
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PPUSH
17294: CALL_OW 72
17298: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
17299: LD_ADDR_VAR 0 7
17303: PUSH
17304: LD_EXP 69
17308: PUSH
17309: LD_VAR 0 1
17313: ARRAY
17314: PPUSH
17315: LD_INT 25
17317: PUSH
17318: LD_INT 3
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: PPUSH
17325: CALL_OW 72
17329: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
17330: LD_ADDR_VAR 0 8
17334: PUSH
17335: LD_EXP 69
17339: PUSH
17340: LD_VAR 0 1
17344: ARRAY
17345: PPUSH
17346: LD_INT 25
17348: PUSH
17349: LD_INT 4
17351: PUSH
17352: EMPTY
17353: LIST
17354: LIST
17355: PUSH
17356: LD_INT 24
17358: PUSH
17359: LD_INT 251
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: PUSH
17366: EMPTY
17367: LIST
17368: LIST
17369: PPUSH
17370: CALL_OW 72
17374: ST_TO_ADDR
// if mc_scan [ base ] then
17375: LD_EXP 92
17379: PUSH
17380: LD_VAR 0 1
17384: ARRAY
17385: IFFALSE 17846
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
17387: LD_ADDR_EXP 111
17391: PUSH
17392: LD_EXP 111
17396: PPUSH
17397: LD_VAR 0 1
17401: PPUSH
17402: LD_INT 4
17404: PPUSH
17405: CALL_OW 1
17409: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
17410: LD_ADDR_VAR 0 12
17414: PUSH
17415: LD_EXP 69
17419: PUSH
17420: LD_VAR 0 1
17424: ARRAY
17425: PPUSH
17426: LD_INT 2
17428: PUSH
17429: LD_INT 30
17431: PUSH
17432: LD_INT 4
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: PUSH
17439: LD_INT 30
17441: PUSH
17442: LD_INT 5
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: PUSH
17449: EMPTY
17450: LIST
17451: LIST
17452: LIST
17453: PPUSH
17454: CALL_OW 72
17458: ST_TO_ADDR
// if not b then
17459: LD_VAR 0 12
17463: NOT
17464: IFFALSE 17468
// exit ;
17466: GO 20211
// p := [ ] ;
17468: LD_ADDR_VAR 0 11
17472: PUSH
17473: EMPTY
17474: ST_TO_ADDR
// if sci >= 2 then
17475: LD_VAR 0 8
17479: PUSH
17480: LD_INT 2
17482: GREATEREQUAL
17483: IFFALSE 17514
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
17485: LD_ADDR_VAR 0 8
17489: PUSH
17490: LD_VAR 0 8
17494: PUSH
17495: LD_INT 1
17497: ARRAY
17498: PUSH
17499: LD_VAR 0 8
17503: PUSH
17504: LD_INT 2
17506: ARRAY
17507: PUSH
17508: EMPTY
17509: LIST
17510: LIST
17511: ST_TO_ADDR
17512: GO 17575
// if sci = 1 then
17514: LD_VAR 0 8
17518: PUSH
17519: LD_INT 1
17521: EQUAL
17522: IFFALSE 17543
// sci := [ sci [ 1 ] ] else
17524: LD_ADDR_VAR 0 8
17528: PUSH
17529: LD_VAR 0 8
17533: PUSH
17534: LD_INT 1
17536: ARRAY
17537: PUSH
17538: EMPTY
17539: LIST
17540: ST_TO_ADDR
17541: GO 17575
// if sci = 0 then
17543: LD_VAR 0 8
17547: PUSH
17548: LD_INT 0
17550: EQUAL
17551: IFFALSE 17575
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
17553: LD_ADDR_VAR 0 11
17557: PUSH
17558: LD_VAR 0 4
17562: PPUSH
17563: LD_INT 4
17565: PPUSH
17566: CALL 81923 0 2
17570: PUSH
17571: LD_INT 1
17573: ARRAY
17574: ST_TO_ADDR
// if eng > 4 then
17575: LD_VAR 0 6
17579: PUSH
17580: LD_INT 4
17582: GREATER
17583: IFFALSE 17629
// for i = eng downto 4 do
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: DOUBLE
17591: LD_VAR 0 6
17595: INC
17596: ST_TO_ADDR
17597: LD_INT 4
17599: PUSH
17600: FOR_DOWNTO
17601: IFFALSE 17627
// eng := eng diff eng [ i ] ;
17603: LD_ADDR_VAR 0 6
17607: PUSH
17608: LD_VAR 0 6
17612: PUSH
17613: LD_VAR 0 6
17617: PUSH
17618: LD_VAR 0 3
17622: ARRAY
17623: DIFF
17624: ST_TO_ADDR
17625: GO 17600
17627: POP
17628: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
17629: LD_ADDR_VAR 0 4
17633: PUSH
17634: LD_VAR 0 4
17638: PUSH
17639: LD_VAR 0 5
17643: PUSH
17644: LD_VAR 0 6
17648: UNION
17649: PUSH
17650: LD_VAR 0 7
17654: UNION
17655: PUSH
17656: LD_VAR 0 8
17660: UNION
17661: DIFF
17662: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
17663: LD_ADDR_VAR 0 13
17667: PUSH
17668: LD_EXP 69
17672: PUSH
17673: LD_VAR 0 1
17677: ARRAY
17678: PPUSH
17679: LD_INT 2
17681: PUSH
17682: LD_INT 30
17684: PUSH
17685: LD_INT 32
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: PUSH
17692: LD_INT 30
17694: PUSH
17695: LD_INT 31
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: LIST
17706: PPUSH
17707: CALL_OW 72
17711: PUSH
17712: LD_EXP 69
17716: PUSH
17717: LD_VAR 0 1
17721: ARRAY
17722: PPUSH
17723: LD_INT 2
17725: PUSH
17726: LD_INT 30
17728: PUSH
17729: LD_INT 4
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: PUSH
17736: LD_INT 30
17738: PUSH
17739: LD_INT 5
17741: PUSH
17742: EMPTY
17743: LIST
17744: LIST
17745: PUSH
17746: EMPTY
17747: LIST
17748: LIST
17749: LIST
17750: PPUSH
17751: CALL_OW 72
17755: PUSH
17756: LD_INT 6
17758: MUL
17759: PLUS
17760: ST_TO_ADDR
// if bcount < tmp then
17761: LD_VAR 0 13
17765: PUSH
17766: LD_VAR 0 4
17770: LESS
17771: IFFALSE 17817
// for i = tmp downto bcount do
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: DOUBLE
17779: LD_VAR 0 4
17783: INC
17784: ST_TO_ADDR
17785: LD_VAR 0 13
17789: PUSH
17790: FOR_DOWNTO
17791: IFFALSE 17815
// tmp := Delete ( tmp , tmp ) ;
17793: LD_ADDR_VAR 0 4
17797: PUSH
17798: LD_VAR 0 4
17802: PPUSH
17803: LD_VAR 0 4
17807: PPUSH
17808: CALL_OW 3
17812: ST_TO_ADDR
17813: GO 17790
17815: POP
17816: POP
// result := [ tmp , 0 , 0 , p ] ;
17817: LD_ADDR_VAR 0 2
17821: PUSH
17822: LD_VAR 0 4
17826: PUSH
17827: LD_INT 0
17829: PUSH
17830: LD_INT 0
17832: PUSH
17833: LD_VAR 0 11
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: ST_TO_ADDR
// exit ;
17844: GO 20211
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
17846: LD_EXP 69
17850: PUSH
17851: LD_VAR 0 1
17855: ARRAY
17856: PPUSH
17857: LD_INT 2
17859: PUSH
17860: LD_INT 30
17862: PUSH
17863: LD_INT 6
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PUSH
17870: LD_INT 30
17872: PUSH
17873: LD_INT 7
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: PUSH
17880: LD_INT 30
17882: PUSH
17883: LD_INT 8
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: PPUSH
17896: CALL_OW 72
17900: NOT
17901: PUSH
17902: LD_EXP 69
17906: PUSH
17907: LD_VAR 0 1
17911: ARRAY
17912: PPUSH
17913: LD_INT 30
17915: PUSH
17916: LD_INT 3
17918: PUSH
17919: EMPTY
17920: LIST
17921: LIST
17922: PPUSH
17923: CALL_OW 72
17927: NOT
17928: AND
17929: IFFALSE 18001
// begin if eng = tmp then
17931: LD_VAR 0 6
17935: PUSH
17936: LD_VAR 0 4
17940: EQUAL
17941: IFFALSE 17945
// exit ;
17943: GO 20211
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
17945: LD_ADDR_EXP 111
17949: PUSH
17950: LD_EXP 111
17954: PPUSH
17955: LD_VAR 0 1
17959: PPUSH
17960: LD_INT 1
17962: PPUSH
17963: CALL_OW 1
17967: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 0
17975: PUSH
17976: LD_VAR 0 4
17980: PUSH
17981: LD_VAR 0 6
17985: DIFF
17986: PUSH
17987: LD_INT 0
17989: PUSH
17990: LD_INT 0
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: ST_TO_ADDR
// exit ;
17999: GO 20211
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
18001: LD_EXP 96
18005: PUSH
18006: LD_EXP 95
18010: PUSH
18011: LD_VAR 0 1
18015: ARRAY
18016: ARRAY
18017: PUSH
18018: LD_EXP 69
18022: PUSH
18023: LD_VAR 0 1
18027: ARRAY
18028: PPUSH
18029: LD_INT 2
18031: PUSH
18032: LD_INT 30
18034: PUSH
18035: LD_INT 6
18037: PUSH
18038: EMPTY
18039: LIST
18040: LIST
18041: PUSH
18042: LD_INT 30
18044: PUSH
18045: LD_INT 7
18047: PUSH
18048: EMPTY
18049: LIST
18050: LIST
18051: PUSH
18052: LD_INT 30
18054: PUSH
18055: LD_INT 8
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: PUSH
18062: EMPTY
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: PPUSH
18068: CALL_OW 72
18072: AND
18073: PUSH
18074: LD_EXP 69
18078: PUSH
18079: LD_VAR 0 1
18083: ARRAY
18084: PPUSH
18085: LD_INT 30
18087: PUSH
18088: LD_INT 3
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 72
18099: NOT
18100: AND
18101: IFFALSE 18315
// begin if sci >= 6 then
18103: LD_VAR 0 8
18107: PUSH
18108: LD_INT 6
18110: GREATEREQUAL
18111: IFFALSE 18115
// exit ;
18113: GO 20211
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
18115: LD_ADDR_EXP 111
18119: PUSH
18120: LD_EXP 111
18124: PPUSH
18125: LD_VAR 0 1
18129: PPUSH
18130: LD_INT 2
18132: PPUSH
18133: CALL_OW 1
18137: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
18138: LD_ADDR_VAR 0 9
18142: PUSH
18143: LD_VAR 0 4
18147: PUSH
18148: LD_VAR 0 8
18152: DIFF
18153: PPUSH
18154: LD_INT 4
18156: PPUSH
18157: CALL 81923 0 2
18161: ST_TO_ADDR
// p := [ ] ;
18162: LD_ADDR_VAR 0 11
18166: PUSH
18167: EMPTY
18168: ST_TO_ADDR
// if sci < 6 and sort > 6 then
18169: LD_VAR 0 8
18173: PUSH
18174: LD_INT 6
18176: LESS
18177: PUSH
18178: LD_VAR 0 9
18182: PUSH
18183: LD_INT 6
18185: GREATER
18186: AND
18187: IFFALSE 18268
// begin for i = 1 to 6 - sci do
18189: LD_ADDR_VAR 0 3
18193: PUSH
18194: DOUBLE
18195: LD_INT 1
18197: DEC
18198: ST_TO_ADDR
18199: LD_INT 6
18201: PUSH
18202: LD_VAR 0 8
18206: MINUS
18207: PUSH
18208: FOR_TO
18209: IFFALSE 18264
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
18211: LD_ADDR_VAR 0 11
18215: PUSH
18216: LD_VAR 0 11
18220: PPUSH
18221: LD_VAR 0 11
18225: PUSH
18226: LD_INT 1
18228: PLUS
18229: PPUSH
18230: LD_VAR 0 9
18234: PUSH
18235: LD_INT 1
18237: ARRAY
18238: PPUSH
18239: CALL_OW 2
18243: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
18244: LD_ADDR_VAR 0 9
18248: PUSH
18249: LD_VAR 0 9
18253: PPUSH
18254: LD_INT 1
18256: PPUSH
18257: CALL_OW 3
18261: ST_TO_ADDR
// end ;
18262: GO 18208
18264: POP
18265: POP
// end else
18266: GO 18288
// if sort then
18268: LD_VAR 0 9
18272: IFFALSE 18288
// p := sort [ 1 ] ;
18274: LD_ADDR_VAR 0 11
18278: PUSH
18279: LD_VAR 0 9
18283: PUSH
18284: LD_INT 1
18286: ARRAY
18287: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
18288: LD_ADDR_VAR 0 2
18292: PUSH
18293: LD_INT 0
18295: PUSH
18296: LD_INT 0
18298: PUSH
18299: LD_INT 0
18301: PUSH
18302: LD_VAR 0 11
18306: PUSH
18307: EMPTY
18308: LIST
18309: LIST
18310: LIST
18311: LIST
18312: ST_TO_ADDR
// exit ;
18313: GO 20211
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
18315: LD_EXP 96
18319: PUSH
18320: LD_EXP 95
18324: PUSH
18325: LD_VAR 0 1
18329: ARRAY
18330: ARRAY
18331: PUSH
18332: LD_EXP 69
18336: PUSH
18337: LD_VAR 0 1
18341: ARRAY
18342: PPUSH
18343: LD_INT 2
18345: PUSH
18346: LD_INT 30
18348: PUSH
18349: LD_INT 6
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: PUSH
18356: LD_INT 30
18358: PUSH
18359: LD_INT 7
18361: PUSH
18362: EMPTY
18363: LIST
18364: LIST
18365: PUSH
18366: LD_INT 30
18368: PUSH
18369: LD_INT 8
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: PUSH
18376: EMPTY
18377: LIST
18378: LIST
18379: LIST
18380: LIST
18381: PPUSH
18382: CALL_OW 72
18386: AND
18387: PUSH
18388: LD_EXP 69
18392: PUSH
18393: LD_VAR 0 1
18397: ARRAY
18398: PPUSH
18399: LD_INT 30
18401: PUSH
18402: LD_INT 3
18404: PUSH
18405: EMPTY
18406: LIST
18407: LIST
18408: PPUSH
18409: CALL_OW 72
18413: AND
18414: IFFALSE 18941
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
18416: LD_ADDR_EXP 111
18420: PUSH
18421: LD_EXP 111
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: LD_INT 3
18433: PPUSH
18434: CALL_OW 1
18438: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
18439: LD_ADDR_VAR 0 2
18443: PUSH
18444: LD_INT 0
18446: PUSH
18447: LD_INT 0
18449: PUSH
18450: LD_INT 0
18452: PUSH
18453: LD_INT 0
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: ST_TO_ADDR
// if not eng then
18462: LD_VAR 0 6
18466: NOT
18467: IFFALSE 18530
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
18469: LD_ADDR_VAR 0 11
18473: PUSH
18474: LD_VAR 0 4
18478: PPUSH
18479: LD_INT 2
18481: PPUSH
18482: CALL 81923 0 2
18486: PUSH
18487: LD_INT 1
18489: ARRAY
18490: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
18491: LD_ADDR_VAR 0 2
18495: PUSH
18496: LD_VAR 0 2
18500: PPUSH
18501: LD_INT 2
18503: PPUSH
18504: LD_VAR 0 11
18508: PPUSH
18509: CALL_OW 1
18513: ST_TO_ADDR
// tmp := tmp diff p ;
18514: LD_ADDR_VAR 0 4
18518: PUSH
18519: LD_VAR 0 4
18523: PUSH
18524: LD_VAR 0 11
18528: DIFF
18529: ST_TO_ADDR
// end ; if not eng then
18530: LD_VAR 0 6
18534: NOT
18535: IFFALSE 18561
// tmp := tmp diff ( mech union sci ) else
18537: LD_ADDR_VAR 0 4
18541: PUSH
18542: LD_VAR 0 4
18546: PUSH
18547: LD_VAR 0 7
18551: PUSH
18552: LD_VAR 0 8
18556: UNION
18557: DIFF
18558: ST_TO_ADDR
18559: GO 18593
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
18561: LD_ADDR_VAR 0 4
18565: PUSH
18566: LD_VAR 0 4
18570: PUSH
18571: LD_VAR 0 6
18575: PUSH
18576: LD_INT 1
18578: ARRAY
18579: PUSH
18580: LD_VAR 0 7
18584: UNION
18585: PUSH
18586: LD_VAR 0 8
18590: UNION
18591: DIFF
18592: ST_TO_ADDR
// if tmp and sci < 6 then
18593: LD_VAR 0 4
18597: PUSH
18598: LD_VAR 0 8
18602: PUSH
18603: LD_INT 6
18605: LESS
18606: AND
18607: IFFALSE 18766
// begin sort := SortBySkill ( tmp , 4 ) ;
18609: LD_ADDR_VAR 0 9
18613: PUSH
18614: LD_VAR 0 4
18618: PPUSH
18619: LD_INT 4
18621: PPUSH
18622: CALL 81923 0 2
18626: ST_TO_ADDR
// p := [ ] ;
18627: LD_ADDR_VAR 0 11
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// if sort then
18634: LD_VAR 0 9
18638: IFFALSE 18737
// for i = 1 to 6 - sci do
18640: LD_ADDR_VAR 0 3
18644: PUSH
18645: DOUBLE
18646: LD_INT 1
18648: DEC
18649: ST_TO_ADDR
18650: LD_INT 6
18652: PUSH
18653: LD_VAR 0 8
18657: MINUS
18658: PUSH
18659: FOR_TO
18660: IFFALSE 18735
// begin if i = sort then
18662: LD_VAR 0 3
18666: PUSH
18667: LD_VAR 0 9
18671: EQUAL
18672: IFFALSE 18676
// break ;
18674: GO 18735
// p := Insert ( p , p + 1 , sort [ i ] ) ;
18676: LD_ADDR_VAR 0 11
18680: PUSH
18681: LD_VAR 0 11
18685: PPUSH
18686: LD_VAR 0 11
18690: PUSH
18691: LD_INT 1
18693: PLUS
18694: PPUSH
18695: LD_VAR 0 9
18699: PUSH
18700: LD_VAR 0 3
18704: ARRAY
18705: PPUSH
18706: CALL_OW 2
18710: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18711: LD_ADDR_VAR 0 4
18715: PUSH
18716: LD_VAR 0 4
18720: PUSH
18721: LD_VAR 0 9
18725: PUSH
18726: LD_VAR 0 3
18730: ARRAY
18731: DIFF
18732: ST_TO_ADDR
// end ;
18733: GO 18659
18735: POP
18736: POP
// if p then
18737: LD_VAR 0 11
18741: IFFALSE 18766
// result := Replace ( result , 4 , p ) ;
18743: LD_ADDR_VAR 0 2
18747: PUSH
18748: LD_VAR 0 2
18752: PPUSH
18753: LD_INT 4
18755: PPUSH
18756: LD_VAR 0 11
18760: PPUSH
18761: CALL_OW 1
18765: ST_TO_ADDR
// end ; if tmp and mech < 6 then
18766: LD_VAR 0 4
18770: PUSH
18771: LD_VAR 0 7
18775: PUSH
18776: LD_INT 6
18778: LESS
18779: AND
18780: IFFALSE 18939
// begin sort := SortBySkill ( tmp , 3 ) ;
18782: LD_ADDR_VAR 0 9
18786: PUSH
18787: LD_VAR 0 4
18791: PPUSH
18792: LD_INT 3
18794: PPUSH
18795: CALL 81923 0 2
18799: ST_TO_ADDR
// p := [ ] ;
18800: LD_ADDR_VAR 0 11
18804: PUSH
18805: EMPTY
18806: ST_TO_ADDR
// if sort then
18807: LD_VAR 0 9
18811: IFFALSE 18910
// for i = 1 to 6 - mech do
18813: LD_ADDR_VAR 0 3
18817: PUSH
18818: DOUBLE
18819: LD_INT 1
18821: DEC
18822: ST_TO_ADDR
18823: LD_INT 6
18825: PUSH
18826: LD_VAR 0 7
18830: MINUS
18831: PUSH
18832: FOR_TO
18833: IFFALSE 18908
// begin if i = sort then
18835: LD_VAR 0 3
18839: PUSH
18840: LD_VAR 0 9
18844: EQUAL
18845: IFFALSE 18849
// break ;
18847: GO 18908
// p := Insert ( p , p + 1 , sort [ i ] ) ;
18849: LD_ADDR_VAR 0 11
18853: PUSH
18854: LD_VAR 0 11
18858: PPUSH
18859: LD_VAR 0 11
18863: PUSH
18864: LD_INT 1
18866: PLUS
18867: PPUSH
18868: LD_VAR 0 9
18872: PUSH
18873: LD_VAR 0 3
18877: ARRAY
18878: PPUSH
18879: CALL_OW 2
18883: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18884: LD_ADDR_VAR 0 4
18888: PUSH
18889: LD_VAR 0 4
18893: PUSH
18894: LD_VAR 0 9
18898: PUSH
18899: LD_VAR 0 3
18903: ARRAY
18904: DIFF
18905: ST_TO_ADDR
// end ;
18906: GO 18832
18908: POP
18909: POP
// if p then
18910: LD_VAR 0 11
18914: IFFALSE 18939
// result := Replace ( result , 3 , p ) ;
18916: LD_ADDR_VAR 0 2
18920: PUSH
18921: LD_VAR 0 2
18925: PPUSH
18926: LD_INT 3
18928: PPUSH
18929: LD_VAR 0 11
18933: PPUSH
18934: CALL_OW 1
18938: ST_TO_ADDR
// end ; exit ;
18939: GO 20211
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
18941: LD_EXP 96
18945: PUSH
18946: LD_EXP 95
18950: PUSH
18951: LD_VAR 0 1
18955: ARRAY
18956: ARRAY
18957: NOT
18958: PUSH
18959: LD_EXP 69
18963: PUSH
18964: LD_VAR 0 1
18968: ARRAY
18969: PPUSH
18970: LD_INT 30
18972: PUSH
18973: LD_INT 3
18975: PUSH
18976: EMPTY
18977: LIST
18978: LIST
18979: PPUSH
18980: CALL_OW 72
18984: AND
18985: PUSH
18986: LD_EXP 74
18990: PUSH
18991: LD_VAR 0 1
18995: ARRAY
18996: AND
18997: IFFALSE 19541
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
18999: LD_ADDR_EXP 111
19003: PUSH
19004: LD_EXP 111
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: LD_INT 5
19016: PPUSH
19017: CALL_OW 1
19021: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
19022: LD_ADDR_VAR 0 2
19026: PUSH
19027: LD_INT 0
19029: PUSH
19030: LD_INT 0
19032: PUSH
19033: LD_INT 0
19035: PUSH
19036: LD_INT 0
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: ST_TO_ADDR
// if sci > 1 then
19045: LD_VAR 0 8
19049: PUSH
19050: LD_INT 1
19052: GREATER
19053: IFFALSE 19081
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
19055: LD_ADDR_VAR 0 4
19059: PUSH
19060: LD_VAR 0 4
19064: PUSH
19065: LD_VAR 0 8
19069: PUSH
19070: LD_VAR 0 8
19074: PUSH
19075: LD_INT 1
19077: ARRAY
19078: DIFF
19079: DIFF
19080: ST_TO_ADDR
// if tmp and not sci then
19081: LD_VAR 0 4
19085: PUSH
19086: LD_VAR 0 8
19090: NOT
19091: AND
19092: IFFALSE 19161
// begin sort := SortBySkill ( tmp , 4 ) ;
19094: LD_ADDR_VAR 0 9
19098: PUSH
19099: LD_VAR 0 4
19103: PPUSH
19104: LD_INT 4
19106: PPUSH
19107: CALL 81923 0 2
19111: ST_TO_ADDR
// if sort then
19112: LD_VAR 0 9
19116: IFFALSE 19132
// p := sort [ 1 ] ;
19118: LD_ADDR_VAR 0 11
19122: PUSH
19123: LD_VAR 0 9
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: ST_TO_ADDR
// if p then
19132: LD_VAR 0 11
19136: IFFALSE 19161
// result := Replace ( result , 4 , p ) ;
19138: LD_ADDR_VAR 0 2
19142: PUSH
19143: LD_VAR 0 2
19147: PPUSH
19148: LD_INT 4
19150: PPUSH
19151: LD_VAR 0 11
19155: PPUSH
19156: CALL_OW 1
19160: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
19161: LD_ADDR_VAR 0 4
19165: PUSH
19166: LD_VAR 0 4
19170: PUSH
19171: LD_VAR 0 7
19175: DIFF
19176: ST_TO_ADDR
// if tmp and mech < 6 then
19177: LD_VAR 0 4
19181: PUSH
19182: LD_VAR 0 7
19186: PUSH
19187: LD_INT 6
19189: LESS
19190: AND
19191: IFFALSE 19350
// begin sort := SortBySkill ( tmp , 3 ) ;
19193: LD_ADDR_VAR 0 9
19197: PUSH
19198: LD_VAR 0 4
19202: PPUSH
19203: LD_INT 3
19205: PPUSH
19206: CALL 81923 0 2
19210: ST_TO_ADDR
// p := [ ] ;
19211: LD_ADDR_VAR 0 11
19215: PUSH
19216: EMPTY
19217: ST_TO_ADDR
// if sort then
19218: LD_VAR 0 9
19222: IFFALSE 19321
// for i = 1 to 6 - mech do
19224: LD_ADDR_VAR 0 3
19228: PUSH
19229: DOUBLE
19230: LD_INT 1
19232: DEC
19233: ST_TO_ADDR
19234: LD_INT 6
19236: PUSH
19237: LD_VAR 0 7
19241: MINUS
19242: PUSH
19243: FOR_TO
19244: IFFALSE 19319
// begin if i = sort then
19246: LD_VAR 0 3
19250: PUSH
19251: LD_VAR 0 9
19255: EQUAL
19256: IFFALSE 19260
// break ;
19258: GO 19319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
19260: LD_ADDR_VAR 0 11
19264: PUSH
19265: LD_VAR 0 11
19269: PPUSH
19270: LD_VAR 0 11
19274: PUSH
19275: LD_INT 1
19277: PLUS
19278: PPUSH
19279: LD_VAR 0 9
19283: PUSH
19284: LD_VAR 0 3
19288: ARRAY
19289: PPUSH
19290: CALL_OW 2
19294: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
19295: LD_ADDR_VAR 0 4
19299: PUSH
19300: LD_VAR 0 4
19304: PUSH
19305: LD_VAR 0 9
19309: PUSH
19310: LD_VAR 0 3
19314: ARRAY
19315: DIFF
19316: ST_TO_ADDR
// end ;
19317: GO 19243
19319: POP
19320: POP
// if p then
19321: LD_VAR 0 11
19325: IFFALSE 19350
// result := Replace ( result , 3 , p ) ;
19327: LD_ADDR_VAR 0 2
19331: PUSH
19332: LD_VAR 0 2
19336: PPUSH
19337: LD_INT 3
19339: PPUSH
19340: LD_VAR 0 11
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
19350: LD_ADDR_VAR 0 4
19354: PUSH
19355: LD_VAR 0 4
19359: PUSH
19360: LD_VAR 0 6
19364: DIFF
19365: ST_TO_ADDR
// if tmp and eng < 6 then
19366: LD_VAR 0 4
19370: PUSH
19371: LD_VAR 0 6
19375: PUSH
19376: LD_INT 6
19378: LESS
19379: AND
19380: IFFALSE 19539
// begin sort := SortBySkill ( tmp , 2 ) ;
19382: LD_ADDR_VAR 0 9
19386: PUSH
19387: LD_VAR 0 4
19391: PPUSH
19392: LD_INT 2
19394: PPUSH
19395: CALL 81923 0 2
19399: ST_TO_ADDR
// p := [ ] ;
19400: LD_ADDR_VAR 0 11
19404: PUSH
19405: EMPTY
19406: ST_TO_ADDR
// if sort then
19407: LD_VAR 0 9
19411: IFFALSE 19510
// for i = 1 to 6 - eng do
19413: LD_ADDR_VAR 0 3
19417: PUSH
19418: DOUBLE
19419: LD_INT 1
19421: DEC
19422: ST_TO_ADDR
19423: LD_INT 6
19425: PUSH
19426: LD_VAR 0 6
19430: MINUS
19431: PUSH
19432: FOR_TO
19433: IFFALSE 19508
// begin if i = sort then
19435: LD_VAR 0 3
19439: PUSH
19440: LD_VAR 0 9
19444: EQUAL
19445: IFFALSE 19449
// break ;
19447: GO 19508
// p := Insert ( p , p + 1 , sort [ i ] ) ;
19449: LD_ADDR_VAR 0 11
19453: PUSH
19454: LD_VAR 0 11
19458: PPUSH
19459: LD_VAR 0 11
19463: PUSH
19464: LD_INT 1
19466: PLUS
19467: PPUSH
19468: LD_VAR 0 9
19472: PUSH
19473: LD_VAR 0 3
19477: ARRAY
19478: PPUSH
19479: CALL_OW 2
19483: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
19484: LD_ADDR_VAR 0 4
19488: PUSH
19489: LD_VAR 0 4
19493: PUSH
19494: LD_VAR 0 9
19498: PUSH
19499: LD_VAR 0 3
19503: ARRAY
19504: DIFF
19505: ST_TO_ADDR
// end ;
19506: GO 19432
19508: POP
19509: POP
// if p then
19510: LD_VAR 0 11
19514: IFFALSE 19539
// result := Replace ( result , 2 , p ) ;
19516: LD_ADDR_VAR 0 2
19520: PUSH
19521: LD_VAR 0 2
19525: PPUSH
19526: LD_INT 2
19528: PPUSH
19529: LD_VAR 0 11
19533: PPUSH
19534: CALL_OW 1
19538: ST_TO_ADDR
// end ; exit ;
19539: GO 20211
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
19541: LD_EXP 96
19545: PUSH
19546: LD_EXP 95
19550: PUSH
19551: LD_VAR 0 1
19555: ARRAY
19556: ARRAY
19557: NOT
19558: PUSH
19559: LD_EXP 69
19563: PUSH
19564: LD_VAR 0 1
19568: ARRAY
19569: PPUSH
19570: LD_INT 30
19572: PUSH
19573: LD_INT 3
19575: PUSH
19576: EMPTY
19577: LIST
19578: LIST
19579: PPUSH
19580: CALL_OW 72
19584: AND
19585: PUSH
19586: LD_EXP 74
19590: PUSH
19591: LD_VAR 0 1
19595: ARRAY
19596: NOT
19597: AND
19598: IFFALSE 20211
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
19600: LD_ADDR_EXP 111
19604: PUSH
19605: LD_EXP 111
19609: PPUSH
19610: LD_VAR 0 1
19614: PPUSH
19615: LD_INT 6
19617: PPUSH
19618: CALL_OW 1
19622: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
19623: LD_ADDR_VAR 0 2
19627: PUSH
19628: LD_INT 0
19630: PUSH
19631: LD_INT 0
19633: PUSH
19634: LD_INT 0
19636: PUSH
19637: LD_INT 0
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: ST_TO_ADDR
// if sci >= 1 then
19646: LD_VAR 0 8
19650: PUSH
19651: LD_INT 1
19653: GREATEREQUAL
19654: IFFALSE 19676
// tmp := tmp diff sci [ 1 ] ;
19656: LD_ADDR_VAR 0 4
19660: PUSH
19661: LD_VAR 0 4
19665: PUSH
19666: LD_VAR 0 8
19670: PUSH
19671: LD_INT 1
19673: ARRAY
19674: DIFF
19675: ST_TO_ADDR
// if tmp and not sci then
19676: LD_VAR 0 4
19680: PUSH
19681: LD_VAR 0 8
19685: NOT
19686: AND
19687: IFFALSE 19756
// begin sort := SortBySkill ( tmp , 4 ) ;
19689: LD_ADDR_VAR 0 9
19693: PUSH
19694: LD_VAR 0 4
19698: PPUSH
19699: LD_INT 4
19701: PPUSH
19702: CALL 81923 0 2
19706: ST_TO_ADDR
// if sort then
19707: LD_VAR 0 9
19711: IFFALSE 19727
// p := sort [ 1 ] ;
19713: LD_ADDR_VAR 0 11
19717: PUSH
19718: LD_VAR 0 9
19722: PUSH
19723: LD_INT 1
19725: ARRAY
19726: ST_TO_ADDR
// if p then
19727: LD_VAR 0 11
19731: IFFALSE 19756
// result := Replace ( result , 4 , p ) ;
19733: LD_ADDR_VAR 0 2
19737: PUSH
19738: LD_VAR 0 2
19742: PPUSH
19743: LD_INT 4
19745: PPUSH
19746: LD_VAR 0 11
19750: PPUSH
19751: CALL_OW 1
19755: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
19756: LD_ADDR_VAR 0 4
19760: PUSH
19761: LD_VAR 0 4
19765: PUSH
19766: LD_VAR 0 7
19770: DIFF
19771: ST_TO_ADDR
// if tmp and mech < 6 then
19772: LD_VAR 0 4
19776: PUSH
19777: LD_VAR 0 7
19781: PUSH
19782: LD_INT 6
19784: LESS
19785: AND
19786: IFFALSE 19945
// begin sort := SortBySkill ( tmp , 3 ) ;
19788: LD_ADDR_VAR 0 9
19792: PUSH
19793: LD_VAR 0 4
19797: PPUSH
19798: LD_INT 3
19800: PPUSH
19801: CALL 81923 0 2
19805: ST_TO_ADDR
// p := [ ] ;
19806: LD_ADDR_VAR 0 11
19810: PUSH
19811: EMPTY
19812: ST_TO_ADDR
// if sort then
19813: LD_VAR 0 9
19817: IFFALSE 19916
// for i = 1 to 6 - mech do
19819: LD_ADDR_VAR 0 3
19823: PUSH
19824: DOUBLE
19825: LD_INT 1
19827: DEC
19828: ST_TO_ADDR
19829: LD_INT 6
19831: PUSH
19832: LD_VAR 0 7
19836: MINUS
19837: PUSH
19838: FOR_TO
19839: IFFALSE 19914
// begin if i = sort then
19841: LD_VAR 0 3
19845: PUSH
19846: LD_VAR 0 9
19850: EQUAL
19851: IFFALSE 19855
// break ;
19853: GO 19914
// p := Insert ( p , p + 1 , sort [ i ] ) ;
19855: LD_ADDR_VAR 0 11
19859: PUSH
19860: LD_VAR 0 11
19864: PPUSH
19865: LD_VAR 0 11
19869: PUSH
19870: LD_INT 1
19872: PLUS
19873: PPUSH
19874: LD_VAR 0 9
19878: PUSH
19879: LD_VAR 0 3
19883: ARRAY
19884: PPUSH
19885: CALL_OW 2
19889: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
19890: LD_ADDR_VAR 0 4
19894: PUSH
19895: LD_VAR 0 4
19899: PUSH
19900: LD_VAR 0 9
19904: PUSH
19905: LD_VAR 0 3
19909: ARRAY
19910: DIFF
19911: ST_TO_ADDR
// end ;
19912: GO 19838
19914: POP
19915: POP
// if p then
19916: LD_VAR 0 11
19920: IFFALSE 19945
// result := Replace ( result , 3 , p ) ;
19922: LD_ADDR_VAR 0 2
19926: PUSH
19927: LD_VAR 0 2
19931: PPUSH
19932: LD_INT 3
19934: PPUSH
19935: LD_VAR 0 11
19939: PPUSH
19940: CALL_OW 1
19944: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
19945: LD_ADDR_VAR 0 4
19949: PUSH
19950: LD_VAR 0 4
19954: PUSH
19955: LD_VAR 0 6
19959: DIFF
19960: ST_TO_ADDR
// if tmp and eng < 4 then
19961: LD_VAR 0 4
19965: PUSH
19966: LD_VAR 0 6
19970: PUSH
19971: LD_INT 4
19973: LESS
19974: AND
19975: IFFALSE 20136
// begin sort := SortBySkill ( tmp , 2 ) ;
19977: LD_ADDR_VAR 0 9
19981: PUSH
19982: LD_VAR 0 4
19986: PPUSH
19987: LD_INT 2
19989: PPUSH
19990: CALL 81923 0 2
19994: ST_TO_ADDR
// p := [ ] ;
19995: LD_ADDR_VAR 0 11
19999: PUSH
20000: EMPTY
20001: ST_TO_ADDR
// if sort then
20002: LD_VAR 0 9
20006: IFFALSE 20105
// for i = 1 to 4 - eng do
20008: LD_ADDR_VAR 0 3
20012: PUSH
20013: DOUBLE
20014: LD_INT 1
20016: DEC
20017: ST_TO_ADDR
20018: LD_INT 4
20020: PUSH
20021: LD_VAR 0 6
20025: MINUS
20026: PUSH
20027: FOR_TO
20028: IFFALSE 20103
// begin if i = sort then
20030: LD_VAR 0 3
20034: PUSH
20035: LD_VAR 0 9
20039: EQUAL
20040: IFFALSE 20044
// break ;
20042: GO 20103
// p := Insert ( p , p + 1 , sort [ i ] ) ;
20044: LD_ADDR_VAR 0 11
20048: PUSH
20049: LD_VAR 0 11
20053: PPUSH
20054: LD_VAR 0 11
20058: PUSH
20059: LD_INT 1
20061: PLUS
20062: PPUSH
20063: LD_VAR 0 9
20067: PUSH
20068: LD_VAR 0 3
20072: ARRAY
20073: PPUSH
20074: CALL_OW 2
20078: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
20079: LD_ADDR_VAR 0 4
20083: PUSH
20084: LD_VAR 0 4
20088: PUSH
20089: LD_VAR 0 9
20093: PUSH
20094: LD_VAR 0 3
20098: ARRAY
20099: DIFF
20100: ST_TO_ADDR
// end ;
20101: GO 20027
20103: POP
20104: POP
// if p then
20105: LD_VAR 0 11
20109: IFFALSE 20134
// result := Replace ( result , 2 , p ) ;
20111: LD_ADDR_VAR 0 2
20115: PUSH
20116: LD_VAR 0 2
20120: PPUSH
20121: LD_INT 2
20123: PPUSH
20124: LD_VAR 0 11
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// end else
20134: GO 20180
// for i = eng downto 5 do
20136: LD_ADDR_VAR 0 3
20140: PUSH
20141: DOUBLE
20142: LD_VAR 0 6
20146: INC
20147: ST_TO_ADDR
20148: LD_INT 5
20150: PUSH
20151: FOR_DOWNTO
20152: IFFALSE 20178
// tmp := tmp union eng [ i ] ;
20154: LD_ADDR_VAR 0 4
20158: PUSH
20159: LD_VAR 0 4
20163: PUSH
20164: LD_VAR 0 6
20168: PUSH
20169: LD_VAR 0 3
20173: ARRAY
20174: UNION
20175: ST_TO_ADDR
20176: GO 20151
20178: POP
20179: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
20180: LD_ADDR_VAR 0 2
20184: PUSH
20185: LD_VAR 0 2
20189: PPUSH
20190: LD_INT 1
20192: PPUSH
20193: LD_VAR 0 4
20197: PUSH
20198: LD_VAR 0 5
20202: DIFF
20203: PPUSH
20204: CALL_OW 1
20208: ST_TO_ADDR
// exit ;
20209: GO 20211
// end ; end ;
20211: LD_VAR 0 2
20215: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
20216: LD_INT 0
20218: PPUSH
20219: PPUSH
20220: PPUSH
// if not mc_bases then
20221: LD_EXP 69
20225: NOT
20226: IFFALSE 20230
// exit ;
20228: GO 20336
// for i = 1 to mc_bases do
20230: LD_ADDR_VAR 0 2
20234: PUSH
20235: DOUBLE
20236: LD_INT 1
20238: DEC
20239: ST_TO_ADDR
20240: LD_EXP 69
20244: PUSH
20245: FOR_TO
20246: IFFALSE 20327
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
20248: LD_ADDR_VAR 0 3
20252: PUSH
20253: LD_EXP 69
20257: PUSH
20258: LD_VAR 0 2
20262: ARRAY
20263: PPUSH
20264: LD_INT 21
20266: PUSH
20267: LD_INT 3
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: PUSH
20274: LD_INT 3
20276: PUSH
20277: LD_INT 24
20279: PUSH
20280: LD_INT 1000
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: PUSH
20287: EMPTY
20288: LIST
20289: LIST
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: PPUSH
20295: CALL_OW 72
20299: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
20300: LD_ADDR_EXP 70
20304: PUSH
20305: LD_EXP 70
20309: PPUSH
20310: LD_VAR 0 2
20314: PPUSH
20315: LD_VAR 0 3
20319: PPUSH
20320: CALL_OW 1
20324: ST_TO_ADDR
// end ;
20325: GO 20245
20327: POP
20328: POP
// RaiseSailEvent ( 101 ) ;
20329: LD_INT 101
20331: PPUSH
20332: CALL_OW 427
// end ;
20336: LD_VAR 0 1
20340: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
20341: LD_INT 0
20343: PPUSH
20344: PPUSH
20345: PPUSH
20346: PPUSH
20347: PPUSH
20348: PPUSH
20349: PPUSH
// if not mc_bases then
20350: LD_EXP 69
20354: NOT
20355: IFFALSE 20359
// exit ;
20357: GO 20932
// for i = 1 to mc_bases do
20359: LD_ADDR_VAR 0 2
20363: PUSH
20364: DOUBLE
20365: LD_INT 1
20367: DEC
20368: ST_TO_ADDR
20369: LD_EXP 69
20373: PUSH
20374: FOR_TO
20375: IFFALSE 20923
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
20377: LD_ADDR_VAR 0 5
20381: PUSH
20382: LD_EXP 69
20386: PUSH
20387: LD_VAR 0 2
20391: ARRAY
20392: PUSH
20393: LD_EXP 98
20397: PUSH
20398: LD_VAR 0 2
20402: ARRAY
20403: UNION
20404: PPUSH
20405: LD_INT 21
20407: PUSH
20408: LD_INT 1
20410: PUSH
20411: EMPTY
20412: LIST
20413: LIST
20414: PUSH
20415: LD_INT 1
20417: PUSH
20418: LD_INT 3
20420: PUSH
20421: LD_INT 54
20423: PUSH
20424: EMPTY
20425: LIST
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: PUSH
20431: LD_INT 3
20433: PUSH
20434: LD_INT 24
20436: PUSH
20437: LD_INT 750
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: PPUSH
20457: CALL_OW 72
20461: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
20462: LD_ADDR_VAR 0 6
20466: PUSH
20467: LD_EXP 69
20471: PUSH
20472: LD_VAR 0 2
20476: ARRAY
20477: PPUSH
20478: LD_INT 21
20480: PUSH
20481: LD_INT 1
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: PUSH
20488: LD_INT 1
20490: PUSH
20491: LD_INT 3
20493: PUSH
20494: LD_INT 54
20496: PUSH
20497: EMPTY
20498: LIST
20499: PUSH
20500: EMPTY
20501: LIST
20502: LIST
20503: PUSH
20504: LD_INT 3
20506: PUSH
20507: LD_INT 24
20509: PUSH
20510: LD_INT 250
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 72
20534: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
20535: LD_ADDR_VAR 0 7
20539: PUSH
20540: LD_VAR 0 5
20544: PUSH
20545: LD_VAR 0 6
20549: DIFF
20550: ST_TO_ADDR
// if not need_heal_1 then
20551: LD_VAR 0 6
20555: NOT
20556: IFFALSE 20589
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
20558: LD_ADDR_EXP 72
20562: PUSH
20563: LD_EXP 72
20567: PPUSH
20568: LD_VAR 0 2
20572: PUSH
20573: LD_INT 1
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: PPUSH
20580: EMPTY
20581: PPUSH
20582: CALL 47738 0 3
20586: ST_TO_ADDR
20587: GO 20659
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
20589: LD_ADDR_EXP 72
20593: PUSH
20594: LD_EXP 72
20598: PPUSH
20599: LD_VAR 0 2
20603: PUSH
20604: LD_INT 1
20606: PUSH
20607: EMPTY
20608: LIST
20609: LIST
20610: PPUSH
20611: LD_EXP 72
20615: PUSH
20616: LD_VAR 0 2
20620: ARRAY
20621: PUSH
20622: LD_INT 1
20624: ARRAY
20625: PPUSH
20626: LD_INT 3
20628: PUSH
20629: LD_INT 24
20631: PUSH
20632: LD_INT 1000
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PPUSH
20643: CALL_OW 72
20647: PUSH
20648: LD_VAR 0 6
20652: UNION
20653: PPUSH
20654: CALL 47738 0 3
20658: ST_TO_ADDR
// if not need_heal_2 then
20659: LD_VAR 0 7
20663: NOT
20664: IFFALSE 20697
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
20666: LD_ADDR_EXP 72
20670: PUSH
20671: LD_EXP 72
20675: PPUSH
20676: LD_VAR 0 2
20680: PUSH
20681: LD_INT 2
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: PPUSH
20688: EMPTY
20689: PPUSH
20690: CALL 47738 0 3
20694: ST_TO_ADDR
20695: GO 20729
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
20697: LD_ADDR_EXP 72
20701: PUSH
20702: LD_EXP 72
20706: PPUSH
20707: LD_VAR 0 2
20711: PUSH
20712: LD_INT 2
20714: PUSH
20715: EMPTY
20716: LIST
20717: LIST
20718: PPUSH
20719: LD_VAR 0 7
20723: PPUSH
20724: CALL 47738 0 3
20728: ST_TO_ADDR
// if need_heal_2 then
20729: LD_VAR 0 7
20733: IFFALSE 20905
// for j in need_heal_2 do
20735: LD_ADDR_VAR 0 3
20739: PUSH
20740: LD_VAR 0 7
20744: PUSH
20745: FOR_IN
20746: IFFALSE 20903
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
20748: LD_ADDR_VAR 0 5
20752: PUSH
20753: LD_EXP 69
20757: PUSH
20758: LD_VAR 0 2
20762: ARRAY
20763: PPUSH
20764: LD_INT 2
20766: PUSH
20767: LD_INT 30
20769: PUSH
20770: LD_INT 6
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: PUSH
20777: LD_INT 30
20779: PUSH
20780: LD_INT 7
20782: PUSH
20783: EMPTY
20784: LIST
20785: LIST
20786: PUSH
20787: LD_INT 30
20789: PUSH
20790: LD_INT 8
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: PUSH
20797: LD_INT 30
20799: PUSH
20800: LD_INT 0
20802: PUSH
20803: EMPTY
20804: LIST
20805: LIST
20806: PUSH
20807: LD_INT 30
20809: PUSH
20810: LD_INT 1
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: PUSH
20817: LD_INT 25
20819: PUSH
20820: LD_INT 4
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: LIST
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: PPUSH
20836: CALL_OW 72
20840: ST_TO_ADDR
// if tmp then
20841: LD_VAR 0 5
20845: IFFALSE 20901
// begin k := NearestUnitToUnit ( tmp , j ) ;
20847: LD_ADDR_VAR 0 4
20851: PUSH
20852: LD_VAR 0 5
20856: PPUSH
20857: LD_VAR 0 3
20861: PPUSH
20862: CALL_OW 74
20866: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
20867: LD_VAR 0 3
20871: PPUSH
20872: LD_VAR 0 4
20876: PPUSH
20877: CALL_OW 296
20881: PUSH
20882: LD_INT 7
20884: GREATER
20885: IFFALSE 20901
// ComMoveUnit ( j , k ) ;
20887: LD_VAR 0 3
20891: PPUSH
20892: LD_VAR 0 4
20896: PPUSH
20897: CALL_OW 112
// end ; end ;
20901: GO 20745
20903: POP
20904: POP
// if not need_heal_1 and not need_heal_2 then
20905: LD_VAR 0 6
20909: NOT
20910: PUSH
20911: LD_VAR 0 7
20915: NOT
20916: AND
20917: IFFALSE 20921
// continue ;
20919: GO 20374
// end ;
20921: GO 20374
20923: POP
20924: POP
// RaiseSailEvent ( 102 ) ;
20925: LD_INT 102
20927: PPUSH
20928: CALL_OW 427
// end ;
20932: LD_VAR 0 1
20936: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
20937: LD_INT 0
20939: PPUSH
20940: PPUSH
20941: PPUSH
20942: PPUSH
20943: PPUSH
// if not mc_bases then
20944: LD_EXP 69
20948: NOT
20949: IFFALSE 20953
// exit ;
20951: GO 21338
// for i = 1 to mc_bases do
20953: LD_ADDR_VAR 0 2
20957: PUSH
20958: DOUBLE
20959: LD_INT 1
20961: DEC
20962: ST_TO_ADDR
20963: LD_EXP 69
20967: PUSH
20968: FOR_TO
20969: IFFALSE 21336
// begin if not mc_building_need_repair [ i ] then
20971: LD_EXP 70
20975: PUSH
20976: LD_VAR 0 2
20980: ARRAY
20981: NOT
20982: IFFALSE 21020
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20984: LD_ADDR_EXP 71
20988: PUSH
20989: LD_EXP 71
20993: PPUSH
20994: LD_VAR 0 2
20998: PPUSH
20999: EMPTY
21000: PPUSH
21001: CALL_OW 1
21005: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
21006: LD_VAR 0 2
21010: PPUSH
21011: LD_INT 101
21013: PPUSH
21014: CALL 16381 0 2
// continue ;
21018: GO 20968
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
21020: LD_ADDR_EXP 75
21024: PUSH
21025: LD_EXP 75
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
21042: LD_VAR 0 2
21046: PPUSH
21047: LD_INT 103
21049: PPUSH
21050: CALL 16381 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
21054: LD_ADDR_VAR 0 5
21058: PUSH
21059: LD_EXP 69
21063: PUSH
21064: LD_VAR 0 2
21068: ARRAY
21069: PUSH
21070: LD_EXP 98
21074: PUSH
21075: LD_VAR 0 2
21079: ARRAY
21080: UNION
21081: PPUSH
21082: LD_INT 2
21084: PUSH
21085: LD_INT 25
21087: PUSH
21088: LD_INT 2
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: PUSH
21095: LD_INT 25
21097: PUSH
21098: LD_INT 16
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: EMPTY
21106: LIST
21107: LIST
21108: LIST
21109: PUSH
21110: EMPTY
21111: LIST
21112: PPUSH
21113: CALL_OW 72
21117: ST_TO_ADDR
// if not tmp then
21118: LD_VAR 0 5
21122: NOT
21123: IFFALSE 21127
// continue ;
21125: GO 20968
// for j in tmp do
21127: LD_ADDR_VAR 0 3
21131: PUSH
21132: LD_VAR 0 5
21136: PUSH
21137: FOR_IN
21138: IFFALSE 21332
// begin if mc_need_heal [ i ] then
21140: LD_EXP 72
21144: PUSH
21145: LD_VAR 0 2
21149: ARRAY
21150: IFFALSE 21198
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
21152: LD_VAR 0 3
21156: PUSH
21157: LD_EXP 72
21161: PUSH
21162: LD_VAR 0 2
21166: ARRAY
21167: PUSH
21168: LD_INT 1
21170: ARRAY
21171: IN
21172: PUSH
21173: LD_VAR 0 3
21177: PUSH
21178: LD_EXP 72
21182: PUSH
21183: LD_VAR 0 2
21187: ARRAY
21188: PUSH
21189: LD_INT 2
21191: ARRAY
21192: IN
21193: OR
21194: IFFALSE 21198
// continue ;
21196: GO 21137
// if IsInUnit ( j ) then
21198: LD_VAR 0 3
21202: PPUSH
21203: CALL_OW 310
21207: IFFALSE 21218
// ComExitBuilding ( j ) ;
21209: LD_VAR 0 3
21213: PPUSH
21214: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
21218: LD_VAR 0 3
21222: PUSH
21223: LD_EXP 71
21227: PUSH
21228: LD_VAR 0 2
21232: ARRAY
21233: IN
21234: NOT
21235: IFFALSE 21293
// begin SetTag ( j , 101 ) ;
21237: LD_VAR 0 3
21241: PPUSH
21242: LD_INT 101
21244: PPUSH
21245: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
21249: LD_ADDR_EXP 71
21253: PUSH
21254: LD_EXP 71
21258: PPUSH
21259: LD_VAR 0 2
21263: PUSH
21264: LD_EXP 71
21268: PUSH
21269: LD_VAR 0 2
21273: ARRAY
21274: PUSH
21275: LD_INT 1
21277: PLUS
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PPUSH
21283: LD_VAR 0 3
21287: PPUSH
21288: CALL 47738 0 3
21292: ST_TO_ADDR
// end ; wait ( 1 ) ;
21293: LD_INT 1
21295: PPUSH
21296: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
21300: LD_VAR 0 3
21304: PPUSH
21305: LD_EXP 70
21309: PUSH
21310: LD_VAR 0 2
21314: ARRAY
21315: PPUSH
21316: LD_VAR 0 3
21320: PPUSH
21321: CALL_OW 74
21325: PPUSH
21326: CALL_OW 130
// end ;
21330: GO 21137
21332: POP
21333: POP
// end ;
21334: GO 20968
21336: POP
21337: POP
// end ;
21338: LD_VAR 0 1
21342: RET
// export function MC_Heal ; var i , j , tmp ; begin
21343: LD_INT 0
21345: PPUSH
21346: PPUSH
21347: PPUSH
21348: PPUSH
// if not mc_bases then
21349: LD_EXP 69
21353: NOT
21354: IFFALSE 21358
// exit ;
21356: GO 21760
// for i = 1 to mc_bases do
21358: LD_ADDR_VAR 0 2
21362: PUSH
21363: DOUBLE
21364: LD_INT 1
21366: DEC
21367: ST_TO_ADDR
21368: LD_EXP 69
21372: PUSH
21373: FOR_TO
21374: IFFALSE 21758
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
21376: LD_EXP 72
21380: PUSH
21381: LD_VAR 0 2
21385: ARRAY
21386: PUSH
21387: LD_INT 1
21389: ARRAY
21390: NOT
21391: PUSH
21392: LD_EXP 72
21396: PUSH
21397: LD_VAR 0 2
21401: ARRAY
21402: PUSH
21403: LD_INT 2
21405: ARRAY
21406: NOT
21407: AND
21408: IFFALSE 21446
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
21410: LD_ADDR_EXP 73
21414: PUSH
21415: LD_EXP 73
21419: PPUSH
21420: LD_VAR 0 2
21424: PPUSH
21425: EMPTY
21426: PPUSH
21427: CALL_OW 1
21431: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
21432: LD_VAR 0 2
21436: PPUSH
21437: LD_INT 102
21439: PPUSH
21440: CALL 16381 0 2
// continue ;
21444: GO 21373
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
21446: LD_ADDR_VAR 0 4
21450: PUSH
21451: LD_EXP 69
21455: PUSH
21456: LD_VAR 0 2
21460: ARRAY
21461: PPUSH
21462: LD_INT 25
21464: PUSH
21465: LD_INT 4
21467: PUSH
21468: EMPTY
21469: LIST
21470: LIST
21471: PPUSH
21472: CALL_OW 72
21476: ST_TO_ADDR
// if not tmp then
21477: LD_VAR 0 4
21481: NOT
21482: IFFALSE 21486
// continue ;
21484: GO 21373
// if mc_taming [ i ] then
21486: LD_EXP 100
21490: PUSH
21491: LD_VAR 0 2
21495: ARRAY
21496: IFFALSE 21520
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21498: LD_ADDR_EXP 100
21502: PUSH
21503: LD_EXP 100
21507: PPUSH
21508: LD_VAR 0 2
21512: PPUSH
21513: EMPTY
21514: PPUSH
21515: CALL_OW 1
21519: ST_TO_ADDR
// for j in tmp do
21520: LD_ADDR_VAR 0 3
21524: PUSH
21525: LD_VAR 0 4
21529: PUSH
21530: FOR_IN
21531: IFFALSE 21754
// begin if IsInUnit ( j ) then
21533: LD_VAR 0 3
21537: PPUSH
21538: CALL_OW 310
21542: IFFALSE 21553
// ComExitBuilding ( j ) ;
21544: LD_VAR 0 3
21548: PPUSH
21549: CALL_OW 122
// if not j in mc_healers [ i ] then
21553: LD_VAR 0 3
21557: PUSH
21558: LD_EXP 73
21562: PUSH
21563: LD_VAR 0 2
21567: ARRAY
21568: IN
21569: NOT
21570: IFFALSE 21616
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
21572: LD_ADDR_EXP 73
21576: PUSH
21577: LD_EXP 73
21581: PPUSH
21582: LD_VAR 0 2
21586: PUSH
21587: LD_EXP 73
21591: PUSH
21592: LD_VAR 0 2
21596: ARRAY
21597: PUSH
21598: LD_INT 1
21600: PLUS
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PPUSH
21606: LD_VAR 0 3
21610: PPUSH
21611: CALL 47738 0 3
21615: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
21616: LD_VAR 0 3
21620: PPUSH
21621: CALL_OW 110
21625: PUSH
21626: LD_INT 102
21628: NONEQUAL
21629: IFFALSE 21643
// SetTag ( j , 102 ) ;
21631: LD_VAR 0 3
21635: PPUSH
21636: LD_INT 102
21638: PPUSH
21639: CALL_OW 109
// Wait ( 3 ) ;
21643: LD_INT 3
21645: PPUSH
21646: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
21650: LD_EXP 72
21654: PUSH
21655: LD_VAR 0 2
21659: ARRAY
21660: PUSH
21661: LD_INT 1
21663: ARRAY
21664: IFFALSE 21696
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
21666: LD_VAR 0 3
21670: PPUSH
21671: LD_EXP 72
21675: PUSH
21676: LD_VAR 0 2
21680: ARRAY
21681: PUSH
21682: LD_INT 1
21684: ARRAY
21685: PUSH
21686: LD_INT 1
21688: ARRAY
21689: PPUSH
21690: CALL_OW 128
21694: GO 21752
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
21696: LD_VAR 0 3
21700: PPUSH
21701: CALL_OW 314
21705: NOT
21706: PUSH
21707: LD_EXP 72
21711: PUSH
21712: LD_VAR 0 2
21716: ARRAY
21717: PUSH
21718: LD_INT 2
21720: ARRAY
21721: AND
21722: IFFALSE 21752
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
21724: LD_VAR 0 3
21728: PPUSH
21729: LD_EXP 72
21733: PUSH
21734: LD_VAR 0 2
21738: ARRAY
21739: PUSH
21740: LD_INT 2
21742: ARRAY
21743: PUSH
21744: LD_INT 1
21746: ARRAY
21747: PPUSH
21748: CALL_OW 128
// end ;
21752: GO 21530
21754: POP
21755: POP
// end ;
21756: GO 21373
21758: POP
21759: POP
// end ;
21760: LD_VAR 0 1
21764: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
21765: LD_INT 0
21767: PPUSH
21768: PPUSH
21769: PPUSH
21770: PPUSH
21771: PPUSH
// if not mc_bases then
21772: LD_EXP 69
21776: NOT
21777: IFFALSE 21781
// exit ;
21779: GO 22924
// for i = 1 to mc_bases do
21781: LD_ADDR_VAR 0 2
21785: PUSH
21786: DOUBLE
21787: LD_INT 1
21789: DEC
21790: ST_TO_ADDR
21791: LD_EXP 69
21795: PUSH
21796: FOR_TO
21797: IFFALSE 22922
// begin if mc_scan [ i ] then
21799: LD_EXP 92
21803: PUSH
21804: LD_VAR 0 2
21808: ARRAY
21809: IFFALSE 21813
// continue ;
21811: GO 21796
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
21813: LD_EXP 74
21817: PUSH
21818: LD_VAR 0 2
21822: ARRAY
21823: NOT
21824: PUSH
21825: LD_EXP 76
21829: PUSH
21830: LD_VAR 0 2
21834: ARRAY
21835: NOT
21836: AND
21837: PUSH
21838: LD_EXP 75
21842: PUSH
21843: LD_VAR 0 2
21847: ARRAY
21848: AND
21849: IFFALSE 21887
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
21851: LD_ADDR_EXP 75
21855: PUSH
21856: LD_EXP 75
21860: PPUSH
21861: LD_VAR 0 2
21865: PPUSH
21866: EMPTY
21867: PPUSH
21868: CALL_OW 1
21872: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
21873: LD_VAR 0 2
21877: PPUSH
21878: LD_INT 103
21880: PPUSH
21881: CALL 16381 0 2
// continue ;
21885: GO 21796
// end ; if mc_construct_list [ i ] then
21887: LD_EXP 76
21891: PUSH
21892: LD_VAR 0 2
21896: ARRAY
21897: IFFALSE 22117
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
21899: LD_ADDR_VAR 0 4
21903: PUSH
21904: LD_EXP 69
21908: PUSH
21909: LD_VAR 0 2
21913: ARRAY
21914: PPUSH
21915: LD_INT 25
21917: PUSH
21918: LD_INT 2
21920: PUSH
21921: EMPTY
21922: LIST
21923: LIST
21924: PPUSH
21925: CALL_OW 72
21929: PUSH
21930: LD_EXP 71
21934: PUSH
21935: LD_VAR 0 2
21939: ARRAY
21940: DIFF
21941: ST_TO_ADDR
// if not tmp then
21942: LD_VAR 0 4
21946: NOT
21947: IFFALSE 21951
// continue ;
21949: GO 21796
// for j in tmp do
21951: LD_ADDR_VAR 0 3
21955: PUSH
21956: LD_VAR 0 4
21960: PUSH
21961: FOR_IN
21962: IFFALSE 22113
// begin if not mc_builders [ i ] then
21964: LD_EXP 75
21968: PUSH
21969: LD_VAR 0 2
21973: ARRAY
21974: NOT
21975: IFFALSE 22033
// begin SetTag ( j , 103 ) ;
21977: LD_VAR 0 3
21981: PPUSH
21982: LD_INT 103
21984: PPUSH
21985: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
21989: LD_ADDR_EXP 75
21993: PUSH
21994: LD_EXP 75
21998: PPUSH
21999: LD_VAR 0 2
22003: PUSH
22004: LD_EXP 75
22008: PUSH
22009: LD_VAR 0 2
22013: ARRAY
22014: PUSH
22015: LD_INT 1
22017: PLUS
22018: PUSH
22019: EMPTY
22020: LIST
22021: LIST
22022: PPUSH
22023: LD_VAR 0 3
22027: PPUSH
22028: CALL 47738 0 3
22032: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
22033: LD_VAR 0 3
22037: PPUSH
22038: CALL_OW 310
22042: IFFALSE 22053
// ComExitBuilding ( j ) ;
22044: LD_VAR 0 3
22048: PPUSH
22049: CALL_OW 122
// wait ( 3 ) ;
22053: LD_INT 3
22055: PPUSH
22056: CALL_OW 67
// if not mc_construct_list [ i ] then
22060: LD_EXP 76
22064: PUSH
22065: LD_VAR 0 2
22069: ARRAY
22070: NOT
22071: IFFALSE 22075
// break ;
22073: GO 22113
// if not HasTask ( j ) then
22075: LD_VAR 0 3
22079: PPUSH
22080: CALL_OW 314
22084: NOT
22085: IFFALSE 22111
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
22087: LD_VAR 0 3
22091: PPUSH
22092: LD_EXP 76
22096: PUSH
22097: LD_VAR 0 2
22101: ARRAY
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: PPUSH
22107: CALL 50589 0 2
// end ;
22111: GO 21961
22113: POP
22114: POP
// end else
22115: GO 22920
// if mc_build_list [ i ] then
22117: LD_EXP 74
22121: PUSH
22122: LD_VAR 0 2
22126: ARRAY
22127: IFFALSE 22920
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
22129: LD_ADDR_VAR 0 5
22133: PUSH
22134: LD_EXP 69
22138: PUSH
22139: LD_VAR 0 2
22143: ARRAY
22144: PPUSH
22145: LD_INT 2
22147: PUSH
22148: LD_INT 30
22150: PUSH
22151: LD_INT 0
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: LD_INT 30
22160: PUSH
22161: LD_INT 1
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PUSH
22168: EMPTY
22169: LIST
22170: LIST
22171: LIST
22172: PPUSH
22173: CALL_OW 72
22177: ST_TO_ADDR
// if depot then
22178: LD_VAR 0 5
22182: IFFALSE 22200
// depot := depot [ 1 ] else
22184: LD_ADDR_VAR 0 5
22188: PUSH
22189: LD_VAR 0 5
22193: PUSH
22194: LD_INT 1
22196: ARRAY
22197: ST_TO_ADDR
22198: GO 22208
// depot := 0 ;
22200: LD_ADDR_VAR 0 5
22204: PUSH
22205: LD_INT 0
22207: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
22208: LD_EXP 74
22212: PUSH
22213: LD_VAR 0 2
22217: ARRAY
22218: PUSH
22219: LD_INT 1
22221: ARRAY
22222: PUSH
22223: LD_INT 1
22225: ARRAY
22226: PPUSH
22227: CALL 50419 0 1
22231: PUSH
22232: LD_EXP 69
22236: PUSH
22237: LD_VAR 0 2
22241: ARRAY
22242: PPUSH
22243: LD_INT 2
22245: PUSH
22246: LD_INT 30
22248: PUSH
22249: LD_INT 2
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PUSH
22256: LD_INT 30
22258: PUSH
22259: LD_INT 3
22261: PUSH
22262: EMPTY
22263: LIST
22264: LIST
22265: PUSH
22266: EMPTY
22267: LIST
22268: LIST
22269: LIST
22270: PPUSH
22271: CALL_OW 72
22275: NOT
22276: AND
22277: IFFALSE 22382
// begin for j = 1 to mc_build_list [ i ] do
22279: LD_ADDR_VAR 0 3
22283: PUSH
22284: DOUBLE
22285: LD_INT 1
22287: DEC
22288: ST_TO_ADDR
22289: LD_EXP 74
22293: PUSH
22294: LD_VAR 0 2
22298: ARRAY
22299: PUSH
22300: FOR_TO
22301: IFFALSE 22380
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
22303: LD_EXP 74
22307: PUSH
22308: LD_VAR 0 2
22312: ARRAY
22313: PUSH
22314: LD_VAR 0 3
22318: ARRAY
22319: PUSH
22320: LD_INT 1
22322: ARRAY
22323: PUSH
22324: LD_INT 2
22326: EQUAL
22327: IFFALSE 22378
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
22329: LD_ADDR_EXP 74
22333: PUSH
22334: LD_EXP 74
22338: PPUSH
22339: LD_VAR 0 2
22343: PPUSH
22344: LD_EXP 74
22348: PUSH
22349: LD_VAR 0 2
22353: ARRAY
22354: PPUSH
22355: LD_VAR 0 3
22359: PPUSH
22360: LD_INT 1
22362: PPUSH
22363: LD_INT 0
22365: PPUSH
22366: CALL 47156 0 4
22370: PPUSH
22371: CALL_OW 1
22375: ST_TO_ADDR
// break ;
22376: GO 22380
// end ;
22378: GO 22300
22380: POP
22381: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
22382: LD_EXP 74
22386: PUSH
22387: LD_VAR 0 2
22391: ARRAY
22392: PUSH
22393: LD_INT 1
22395: ARRAY
22396: PUSH
22397: LD_INT 1
22399: ARRAY
22400: PUSH
22401: LD_INT 0
22403: EQUAL
22404: PUSH
22405: LD_VAR 0 5
22409: PUSH
22410: LD_VAR 0 5
22414: PPUSH
22415: LD_EXP 74
22419: PUSH
22420: LD_VAR 0 2
22424: ARRAY
22425: PUSH
22426: LD_INT 1
22428: ARRAY
22429: PUSH
22430: LD_INT 1
22432: ARRAY
22433: PPUSH
22434: LD_EXP 74
22438: PUSH
22439: LD_VAR 0 2
22443: ARRAY
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: PUSH
22449: LD_INT 2
22451: ARRAY
22452: PPUSH
22453: LD_EXP 74
22457: PUSH
22458: LD_VAR 0 2
22462: ARRAY
22463: PUSH
22464: LD_INT 1
22466: ARRAY
22467: PUSH
22468: LD_INT 3
22470: ARRAY
22471: PPUSH
22472: LD_EXP 74
22476: PUSH
22477: LD_VAR 0 2
22481: ARRAY
22482: PUSH
22483: LD_INT 1
22485: ARRAY
22486: PUSH
22487: LD_INT 4
22489: ARRAY
22490: PPUSH
22491: CALL 55135 0 5
22495: AND
22496: OR
22497: IFFALSE 22778
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
22499: LD_ADDR_VAR 0 4
22503: PUSH
22504: LD_EXP 69
22508: PUSH
22509: LD_VAR 0 2
22513: ARRAY
22514: PPUSH
22515: LD_INT 25
22517: PUSH
22518: LD_INT 2
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: PPUSH
22525: CALL_OW 72
22529: PUSH
22530: LD_EXP 71
22534: PUSH
22535: LD_VAR 0 2
22539: ARRAY
22540: DIFF
22541: ST_TO_ADDR
// if not tmp then
22542: LD_VAR 0 4
22546: NOT
22547: IFFALSE 22551
// continue ;
22549: GO 21796
// for j in tmp do
22551: LD_ADDR_VAR 0 3
22555: PUSH
22556: LD_VAR 0 4
22560: PUSH
22561: FOR_IN
22562: IFFALSE 22774
// begin if not mc_builders [ i ] then
22564: LD_EXP 75
22568: PUSH
22569: LD_VAR 0 2
22573: ARRAY
22574: NOT
22575: IFFALSE 22633
// begin SetTag ( j , 103 ) ;
22577: LD_VAR 0 3
22581: PPUSH
22582: LD_INT 103
22584: PPUSH
22585: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
22589: LD_ADDR_EXP 75
22593: PUSH
22594: LD_EXP 75
22598: PPUSH
22599: LD_VAR 0 2
22603: PUSH
22604: LD_EXP 75
22608: PUSH
22609: LD_VAR 0 2
22613: ARRAY
22614: PUSH
22615: LD_INT 1
22617: PLUS
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: PPUSH
22623: LD_VAR 0 3
22627: PPUSH
22628: CALL 47738 0 3
22632: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
22633: LD_VAR 0 3
22637: PPUSH
22638: CALL_OW 310
22642: IFFALSE 22653
// ComExitBuilding ( j ) ;
22644: LD_VAR 0 3
22648: PPUSH
22649: CALL_OW 122
// wait ( 3 ) ;
22653: LD_INT 3
22655: PPUSH
22656: CALL_OW 67
// if not mc_build_list [ i ] then
22660: LD_EXP 74
22664: PUSH
22665: LD_VAR 0 2
22669: ARRAY
22670: NOT
22671: IFFALSE 22675
// break ;
22673: GO 22774
// if not HasTask ( j ) then
22675: LD_VAR 0 3
22679: PPUSH
22680: CALL_OW 314
22684: NOT
22685: IFFALSE 22772
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
22687: LD_VAR 0 3
22691: PPUSH
22692: LD_EXP 74
22696: PUSH
22697: LD_VAR 0 2
22701: ARRAY
22702: PUSH
22703: LD_INT 1
22705: ARRAY
22706: PUSH
22707: LD_INT 1
22709: ARRAY
22710: PPUSH
22711: LD_EXP 74
22715: PUSH
22716: LD_VAR 0 2
22720: ARRAY
22721: PUSH
22722: LD_INT 1
22724: ARRAY
22725: PUSH
22726: LD_INT 2
22728: ARRAY
22729: PPUSH
22730: LD_EXP 74
22734: PUSH
22735: LD_VAR 0 2
22739: ARRAY
22740: PUSH
22741: LD_INT 1
22743: ARRAY
22744: PUSH
22745: LD_INT 3
22747: ARRAY
22748: PPUSH
22749: LD_EXP 74
22753: PUSH
22754: LD_VAR 0 2
22758: ARRAY
22759: PUSH
22760: LD_INT 1
22762: ARRAY
22763: PUSH
22764: LD_INT 4
22766: ARRAY
22767: PPUSH
22768: CALL_OW 145
// end ;
22772: GO 22561
22774: POP
22775: POP
// end else
22776: GO 22920
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
22778: LD_EXP 69
22782: PUSH
22783: LD_VAR 0 2
22787: ARRAY
22788: PPUSH
22789: LD_EXP 74
22793: PUSH
22794: LD_VAR 0 2
22798: ARRAY
22799: PUSH
22800: LD_INT 1
22802: ARRAY
22803: PUSH
22804: LD_INT 1
22806: ARRAY
22807: PPUSH
22808: LD_EXP 74
22812: PUSH
22813: LD_VAR 0 2
22817: ARRAY
22818: PUSH
22819: LD_INT 1
22821: ARRAY
22822: PUSH
22823: LD_INT 2
22825: ARRAY
22826: PPUSH
22827: LD_EXP 74
22831: PUSH
22832: LD_VAR 0 2
22836: ARRAY
22837: PUSH
22838: LD_INT 1
22840: ARRAY
22841: PUSH
22842: LD_INT 3
22844: ARRAY
22845: PPUSH
22846: LD_EXP 74
22850: PUSH
22851: LD_VAR 0 2
22855: ARRAY
22856: PUSH
22857: LD_INT 1
22859: ARRAY
22860: PUSH
22861: LD_INT 4
22863: ARRAY
22864: PPUSH
22865: CALL 54489 0 5
22869: NOT
22870: IFFALSE 22920
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
22872: LD_ADDR_EXP 74
22876: PUSH
22877: LD_EXP 74
22881: PPUSH
22882: LD_VAR 0 2
22886: PPUSH
22887: LD_EXP 74
22891: PUSH
22892: LD_VAR 0 2
22896: ARRAY
22897: PPUSH
22898: LD_INT 1
22900: PPUSH
22901: LD_INT 1
22903: NEG
22904: PPUSH
22905: LD_INT 0
22907: PPUSH
22908: CALL 47156 0 4
22912: PPUSH
22913: CALL_OW 1
22917: ST_TO_ADDR
// continue ;
22918: GO 21796
// end ; end ; end ;
22920: GO 21796
22922: POP
22923: POP
// end ;
22924: LD_VAR 0 1
22928: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
22929: LD_INT 0
22931: PPUSH
22932: PPUSH
22933: PPUSH
22934: PPUSH
22935: PPUSH
22936: PPUSH
// if not mc_bases then
22937: LD_EXP 69
22941: NOT
22942: IFFALSE 22946
// exit ;
22944: GO 23373
// for i = 1 to mc_bases do
22946: LD_ADDR_VAR 0 2
22950: PUSH
22951: DOUBLE
22952: LD_INT 1
22954: DEC
22955: ST_TO_ADDR
22956: LD_EXP 69
22960: PUSH
22961: FOR_TO
22962: IFFALSE 23371
// begin tmp := mc_build_upgrade [ i ] ;
22964: LD_ADDR_VAR 0 4
22968: PUSH
22969: LD_EXP 101
22973: PUSH
22974: LD_VAR 0 2
22978: ARRAY
22979: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
22980: LD_ADDR_VAR 0 6
22984: PUSH
22985: LD_EXP 102
22989: PUSH
22990: LD_VAR 0 2
22994: ARRAY
22995: PPUSH
22996: LD_INT 2
22998: PUSH
22999: LD_INT 30
23001: PUSH
23002: LD_INT 6
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PUSH
23009: LD_INT 30
23011: PUSH
23012: LD_INT 7
23014: PUSH
23015: EMPTY
23016: LIST
23017: LIST
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: LIST
23023: PPUSH
23024: CALL_OW 72
23028: ST_TO_ADDR
// if not tmp and not lab then
23029: LD_VAR 0 4
23033: NOT
23034: PUSH
23035: LD_VAR 0 6
23039: NOT
23040: AND
23041: IFFALSE 23045
// continue ;
23043: GO 22961
// if tmp then
23045: LD_VAR 0 4
23049: IFFALSE 23169
// for j in tmp do
23051: LD_ADDR_VAR 0 3
23055: PUSH
23056: LD_VAR 0 4
23060: PUSH
23061: FOR_IN
23062: IFFALSE 23167
// begin if UpgradeCost ( j ) then
23064: LD_VAR 0 3
23068: PPUSH
23069: CALL 54149 0 1
23073: IFFALSE 23165
// begin ComUpgrade ( j ) ;
23075: LD_VAR 0 3
23079: PPUSH
23080: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
23084: LD_ADDR_EXP 101
23088: PUSH
23089: LD_EXP 101
23093: PPUSH
23094: LD_VAR 0 2
23098: PPUSH
23099: LD_EXP 101
23103: PUSH
23104: LD_VAR 0 2
23108: ARRAY
23109: PUSH
23110: LD_VAR 0 3
23114: DIFF
23115: PPUSH
23116: CALL_OW 1
23120: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
23121: LD_ADDR_EXP 76
23125: PUSH
23126: LD_EXP 76
23130: PPUSH
23131: LD_VAR 0 2
23135: PUSH
23136: LD_EXP 76
23140: PUSH
23141: LD_VAR 0 2
23145: ARRAY
23146: PUSH
23147: LD_INT 1
23149: PLUS
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: PPUSH
23155: LD_VAR 0 3
23159: PPUSH
23160: CALL 47738 0 3
23164: ST_TO_ADDR
// end ; end ;
23165: GO 23061
23167: POP
23168: POP
// if not lab or not mc_lab_upgrade [ i ] then
23169: LD_VAR 0 6
23173: NOT
23174: PUSH
23175: LD_EXP 103
23179: PUSH
23180: LD_VAR 0 2
23184: ARRAY
23185: NOT
23186: OR
23187: IFFALSE 23191
// continue ;
23189: GO 22961
// for j in lab do
23191: LD_ADDR_VAR 0 3
23195: PUSH
23196: LD_VAR 0 6
23200: PUSH
23201: FOR_IN
23202: IFFALSE 23367
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
23204: LD_VAR 0 3
23208: PPUSH
23209: CALL_OW 266
23213: PUSH
23214: LD_INT 6
23216: PUSH
23217: LD_INT 7
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: IN
23224: PUSH
23225: LD_VAR 0 3
23229: PPUSH
23230: CALL_OW 461
23234: PUSH
23235: LD_INT 1
23237: NONEQUAL
23238: AND
23239: IFFALSE 23365
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
23241: LD_VAR 0 3
23245: PPUSH
23246: LD_EXP 103
23250: PUSH
23251: LD_VAR 0 2
23255: ARRAY
23256: PUSH
23257: LD_INT 1
23259: ARRAY
23260: PPUSH
23261: CALL 54354 0 2
23265: IFFALSE 23365
// begin ComCancel ( j ) ;
23267: LD_VAR 0 3
23271: PPUSH
23272: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
23276: LD_VAR 0 3
23280: PPUSH
23281: LD_EXP 103
23285: PUSH
23286: LD_VAR 0 2
23290: ARRAY
23291: PUSH
23292: LD_INT 1
23294: ARRAY
23295: PPUSH
23296: CALL_OW 207
// if not j in mc_construct_list [ i ] then
23300: LD_VAR 0 3
23304: PUSH
23305: LD_EXP 76
23309: PUSH
23310: LD_VAR 0 2
23314: ARRAY
23315: IN
23316: NOT
23317: IFFALSE 23363
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
23319: LD_ADDR_EXP 76
23323: PUSH
23324: LD_EXP 76
23328: PPUSH
23329: LD_VAR 0 2
23333: PUSH
23334: LD_EXP 76
23338: PUSH
23339: LD_VAR 0 2
23343: ARRAY
23344: PUSH
23345: LD_INT 1
23347: PLUS
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: PPUSH
23353: LD_VAR 0 3
23357: PPUSH
23358: CALL 47738 0 3
23362: ST_TO_ADDR
// break ;
23363: GO 23367
// end ; end ; end ;
23365: GO 23201
23367: POP
23368: POP
// end ;
23369: GO 22961
23371: POP
23372: POP
// end ;
23373: LD_VAR 0 1
23377: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
23378: LD_INT 0
23380: PPUSH
23381: PPUSH
23382: PPUSH
23383: PPUSH
23384: PPUSH
23385: PPUSH
23386: PPUSH
23387: PPUSH
23388: PPUSH
// if not mc_bases then
23389: LD_EXP 69
23393: NOT
23394: IFFALSE 23398
// exit ;
23396: GO 23803
// for i = 1 to mc_bases do
23398: LD_ADDR_VAR 0 2
23402: PUSH
23403: DOUBLE
23404: LD_INT 1
23406: DEC
23407: ST_TO_ADDR
23408: LD_EXP 69
23412: PUSH
23413: FOR_TO
23414: IFFALSE 23801
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
23416: LD_EXP 77
23420: PUSH
23421: LD_VAR 0 2
23425: ARRAY
23426: NOT
23427: PUSH
23428: LD_EXP 69
23432: PUSH
23433: LD_VAR 0 2
23437: ARRAY
23438: PPUSH
23439: LD_INT 30
23441: PUSH
23442: LD_INT 3
23444: PUSH
23445: EMPTY
23446: LIST
23447: LIST
23448: PPUSH
23449: CALL_OW 72
23453: NOT
23454: OR
23455: IFFALSE 23459
// continue ;
23457: GO 23413
// busy := false ;
23459: LD_ADDR_VAR 0 8
23463: PUSH
23464: LD_INT 0
23466: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
23467: LD_ADDR_VAR 0 4
23471: PUSH
23472: LD_EXP 69
23476: PUSH
23477: LD_VAR 0 2
23481: ARRAY
23482: PPUSH
23483: LD_INT 30
23485: PUSH
23486: LD_INT 3
23488: PUSH
23489: EMPTY
23490: LIST
23491: LIST
23492: PPUSH
23493: CALL_OW 72
23497: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
23498: LD_ADDR_VAR 0 6
23502: PUSH
23503: LD_EXP 77
23507: PUSH
23508: LD_VAR 0 2
23512: ARRAY
23513: PPUSH
23514: LD_INT 2
23516: PUSH
23517: LD_INT 30
23519: PUSH
23520: LD_INT 32
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: PUSH
23527: LD_INT 30
23529: PUSH
23530: LD_INT 33
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: LIST
23541: PPUSH
23542: CALL_OW 72
23546: ST_TO_ADDR
// if not t then
23547: LD_VAR 0 6
23551: NOT
23552: IFFALSE 23556
// continue ;
23554: GO 23413
// for j in tmp do
23556: LD_ADDR_VAR 0 3
23560: PUSH
23561: LD_VAR 0 4
23565: PUSH
23566: FOR_IN
23567: IFFALSE 23597
// if not BuildingStatus ( j ) = bs_idle then
23569: LD_VAR 0 3
23573: PPUSH
23574: CALL_OW 461
23578: PUSH
23579: LD_INT 2
23581: EQUAL
23582: NOT
23583: IFFALSE 23595
// begin busy := true ;
23585: LD_ADDR_VAR 0 8
23589: PUSH
23590: LD_INT 1
23592: ST_TO_ADDR
// break ;
23593: GO 23597
// end ;
23595: GO 23566
23597: POP
23598: POP
// if busy then
23599: LD_VAR 0 8
23603: IFFALSE 23607
// continue ;
23605: GO 23413
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
23607: LD_ADDR_VAR 0 7
23611: PUSH
23612: LD_VAR 0 6
23616: PPUSH
23617: LD_INT 35
23619: PUSH
23620: LD_INT 0
23622: PUSH
23623: EMPTY
23624: LIST
23625: LIST
23626: PPUSH
23627: CALL_OW 72
23631: ST_TO_ADDR
// if tw then
23632: LD_VAR 0 7
23636: IFFALSE 23713
// begin tw := tw [ 1 ] ;
23638: LD_ADDR_VAR 0 7
23642: PUSH
23643: LD_VAR 0 7
23647: PUSH
23648: LD_INT 1
23650: ARRAY
23651: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
23652: LD_ADDR_VAR 0 9
23656: PUSH
23657: LD_VAR 0 7
23661: PPUSH
23662: LD_EXP 94
23666: PUSH
23667: LD_VAR 0 2
23671: ARRAY
23672: PPUSH
23673: CALL 52708 0 2
23677: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
23678: LD_EXP 108
23682: PUSH
23683: LD_VAR 0 2
23687: ARRAY
23688: IFFALSE 23711
// if not weapon in mc_allowed_tower_weapons [ i ] then
23690: LD_VAR 0 9
23694: PUSH
23695: LD_EXP 108
23699: PUSH
23700: LD_VAR 0 2
23704: ARRAY
23705: IN
23706: NOT
23707: IFFALSE 23711
// continue ;
23709: GO 23413
// end else
23711: GO 23776
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
23713: LD_ADDR_VAR 0 5
23717: PUSH
23718: LD_EXP 77
23722: PUSH
23723: LD_VAR 0 2
23727: ARRAY
23728: PPUSH
23729: LD_VAR 0 4
23733: PPUSH
23734: CALL 82847 0 2
23738: ST_TO_ADDR
// if not tmp2 then
23739: LD_VAR 0 5
23743: NOT
23744: IFFALSE 23748
// continue ;
23746: GO 23413
// tw := tmp2 [ 1 ] ;
23748: LD_ADDR_VAR 0 7
23752: PUSH
23753: LD_VAR 0 5
23757: PUSH
23758: LD_INT 1
23760: ARRAY
23761: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
23762: LD_ADDR_VAR 0 9
23766: PUSH
23767: LD_VAR 0 5
23771: PUSH
23772: LD_INT 2
23774: ARRAY
23775: ST_TO_ADDR
// end ; if not weapon then
23776: LD_VAR 0 9
23780: NOT
23781: IFFALSE 23785
// continue ;
23783: GO 23413
// ComPlaceWeapon ( tw , weapon ) ;
23785: LD_VAR 0 7
23789: PPUSH
23790: LD_VAR 0 9
23794: PPUSH
23795: CALL_OW 148
// end ;
23799: GO 23413
23801: POP
23802: POP
// end ;
23803: LD_VAR 0 1
23807: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
23808: LD_INT 0
23810: PPUSH
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
23815: PPUSH
// if not mc_bases then
23816: LD_EXP 69
23820: NOT
23821: IFFALSE 23825
// exit ;
23823: GO 24837
// for i = 1 to mc_bases do
23825: LD_ADDR_VAR 0 2
23829: PUSH
23830: DOUBLE
23831: LD_INT 1
23833: DEC
23834: ST_TO_ADDR
23835: LD_EXP 69
23839: PUSH
23840: FOR_TO
23841: IFFALSE 24835
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
23843: LD_EXP 82
23847: PUSH
23848: LD_VAR 0 2
23852: ARRAY
23853: NOT
23854: PUSH
23855: LD_EXP 82
23859: PUSH
23860: LD_VAR 0 2
23864: ARRAY
23865: PUSH
23866: LD_EXP 83
23870: PUSH
23871: LD_VAR 0 2
23875: ARRAY
23876: EQUAL
23877: OR
23878: IFFALSE 23882
// continue ;
23880: GO 23840
// if mc_miners [ i ] then
23882: LD_EXP 83
23886: PUSH
23887: LD_VAR 0 2
23891: ARRAY
23892: IFFALSE 24522
// begin k := 1 ;
23894: LD_ADDR_VAR 0 4
23898: PUSH
23899: LD_INT 1
23901: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
23902: LD_ADDR_VAR 0 3
23906: PUSH
23907: DOUBLE
23908: LD_EXP 83
23912: PUSH
23913: LD_VAR 0 2
23917: ARRAY
23918: INC
23919: ST_TO_ADDR
23920: LD_INT 1
23922: PUSH
23923: FOR_DOWNTO
23924: IFFALSE 24520
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
23926: LD_EXP 83
23930: PUSH
23931: LD_VAR 0 2
23935: ARRAY
23936: PUSH
23937: LD_VAR 0 3
23941: ARRAY
23942: PPUSH
23943: CALL_OW 301
23947: PUSH
23948: LD_EXP 83
23952: PUSH
23953: LD_VAR 0 2
23957: ARRAY
23958: PUSH
23959: LD_VAR 0 3
23963: ARRAY
23964: PPUSH
23965: CALL_OW 257
23969: PUSH
23970: LD_INT 1
23972: NONEQUAL
23973: OR
23974: IFFALSE 24037
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
23976: LD_ADDR_VAR 0 5
23980: PUSH
23981: LD_EXP 83
23985: PUSH
23986: LD_VAR 0 2
23990: ARRAY
23991: PUSH
23992: LD_EXP 83
23996: PUSH
23997: LD_VAR 0 2
24001: ARRAY
24002: PUSH
24003: LD_VAR 0 3
24007: ARRAY
24008: DIFF
24009: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
24010: LD_ADDR_EXP 83
24014: PUSH
24015: LD_EXP 83
24019: PPUSH
24020: LD_VAR 0 2
24024: PPUSH
24025: LD_VAR 0 5
24029: PPUSH
24030: CALL_OW 1
24034: ST_TO_ADDR
// continue ;
24035: GO 23923
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
24037: LD_EXP 83
24041: PUSH
24042: LD_VAR 0 2
24046: ARRAY
24047: PUSH
24048: LD_VAR 0 3
24052: ARRAY
24053: PPUSH
24054: CALL 47674 0 1
24058: PUSH
24059: LD_EXP 83
24063: PUSH
24064: LD_VAR 0 2
24068: ARRAY
24069: PUSH
24070: LD_VAR 0 3
24074: ARRAY
24075: PPUSH
24076: CALL_OW 255
24080: PPUSH
24081: LD_EXP 82
24085: PUSH
24086: LD_VAR 0 2
24090: ARRAY
24091: PUSH
24092: LD_VAR 0 4
24096: ARRAY
24097: PUSH
24098: LD_INT 1
24100: ARRAY
24101: PPUSH
24102: LD_EXP 82
24106: PUSH
24107: LD_VAR 0 2
24111: ARRAY
24112: PUSH
24113: LD_VAR 0 4
24117: ARRAY
24118: PUSH
24119: LD_INT 2
24121: ARRAY
24122: PPUSH
24123: LD_INT 15
24125: PPUSH
24126: CALL 48634 0 4
24130: PUSH
24131: LD_INT 4
24133: ARRAY
24134: PUSH
24135: LD_EXP 83
24139: PUSH
24140: LD_VAR 0 2
24144: ARRAY
24145: PUSH
24146: LD_VAR 0 3
24150: ARRAY
24151: PPUSH
24152: LD_INT 10
24154: PPUSH
24155: CALL 50331 0 2
24159: PUSH
24160: LD_INT 4
24162: ARRAY
24163: OR
24164: AND
24165: IFFALSE 24188
// ComStop ( mc_miners [ i ] [ j ] ) ;
24167: LD_EXP 83
24171: PUSH
24172: LD_VAR 0 2
24176: ARRAY
24177: PUSH
24178: LD_VAR 0 3
24182: ARRAY
24183: PPUSH
24184: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
24188: LD_EXP 83
24192: PUSH
24193: LD_VAR 0 2
24197: ARRAY
24198: PUSH
24199: LD_VAR 0 3
24203: ARRAY
24204: PPUSH
24205: CALL_OW 257
24209: PUSH
24210: LD_INT 1
24212: EQUAL
24213: PUSH
24214: LD_EXP 83
24218: PUSH
24219: LD_VAR 0 2
24223: ARRAY
24224: PUSH
24225: LD_VAR 0 3
24229: ARRAY
24230: PPUSH
24231: CALL_OW 459
24235: NOT
24236: AND
24237: PUSH
24238: LD_EXP 83
24242: PUSH
24243: LD_VAR 0 2
24247: ARRAY
24248: PUSH
24249: LD_VAR 0 3
24253: ARRAY
24254: PPUSH
24255: CALL_OW 255
24259: PPUSH
24260: LD_EXP 82
24264: PUSH
24265: LD_VAR 0 2
24269: ARRAY
24270: PUSH
24271: LD_VAR 0 4
24275: ARRAY
24276: PUSH
24277: LD_INT 1
24279: ARRAY
24280: PPUSH
24281: LD_EXP 82
24285: PUSH
24286: LD_VAR 0 2
24290: ARRAY
24291: PUSH
24292: LD_VAR 0 4
24296: ARRAY
24297: PUSH
24298: LD_INT 2
24300: ARRAY
24301: PPUSH
24302: LD_INT 15
24304: PPUSH
24305: CALL 48634 0 4
24309: PUSH
24310: LD_INT 4
24312: ARRAY
24313: PUSH
24314: LD_INT 0
24316: EQUAL
24317: AND
24318: PUSH
24319: LD_EXP 83
24323: PUSH
24324: LD_VAR 0 2
24328: ARRAY
24329: PUSH
24330: LD_VAR 0 3
24334: ARRAY
24335: PPUSH
24336: CALL_OW 314
24340: NOT
24341: AND
24342: IFFALSE 24518
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
24344: LD_EXP 83
24348: PUSH
24349: LD_VAR 0 2
24353: ARRAY
24354: PUSH
24355: LD_VAR 0 3
24359: ARRAY
24360: PPUSH
24361: CALL_OW 310
24365: IFFALSE 24388
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
24367: LD_EXP 83
24371: PUSH
24372: LD_VAR 0 2
24376: ARRAY
24377: PUSH
24378: LD_VAR 0 3
24382: ARRAY
24383: PPUSH
24384: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
24388: LD_EXP 83
24392: PUSH
24393: LD_VAR 0 2
24397: ARRAY
24398: PUSH
24399: LD_VAR 0 3
24403: ARRAY
24404: PPUSH
24405: CALL_OW 314
24409: NOT
24410: IFFALSE 24478
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
24412: LD_EXP 83
24416: PUSH
24417: LD_VAR 0 2
24421: ARRAY
24422: PUSH
24423: LD_VAR 0 3
24427: ARRAY
24428: PPUSH
24429: LD_EXP 82
24433: PUSH
24434: LD_VAR 0 2
24438: ARRAY
24439: PUSH
24440: LD_VAR 0 4
24444: ARRAY
24445: PUSH
24446: LD_INT 1
24448: ARRAY
24449: PPUSH
24450: LD_EXP 82
24454: PUSH
24455: LD_VAR 0 2
24459: ARRAY
24460: PUSH
24461: LD_VAR 0 4
24465: ARRAY
24466: PUSH
24467: LD_INT 2
24469: ARRAY
24470: PPUSH
24471: LD_INT 0
24473: PPUSH
24474: CALL_OW 193
// k := k + 1 ;
24478: LD_ADDR_VAR 0 4
24482: PUSH
24483: LD_VAR 0 4
24487: PUSH
24488: LD_INT 1
24490: PLUS
24491: ST_TO_ADDR
// if k > mc_mines [ i ] then
24492: LD_VAR 0 4
24496: PUSH
24497: LD_EXP 82
24501: PUSH
24502: LD_VAR 0 2
24506: ARRAY
24507: GREATER
24508: IFFALSE 24518
// k := 1 ;
24510: LD_ADDR_VAR 0 4
24514: PUSH
24515: LD_INT 1
24517: ST_TO_ADDR
// end ; end ;
24518: GO 23923
24520: POP
24521: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
24522: LD_ADDR_VAR 0 5
24526: PUSH
24527: LD_EXP 69
24531: PUSH
24532: LD_VAR 0 2
24536: ARRAY
24537: PPUSH
24538: LD_INT 2
24540: PUSH
24541: LD_INT 30
24543: PUSH
24544: LD_INT 4
24546: PUSH
24547: EMPTY
24548: LIST
24549: LIST
24550: PUSH
24551: LD_INT 30
24553: PUSH
24554: LD_INT 5
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 30
24563: PUSH
24564: LD_INT 32
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: LIST
24575: LIST
24576: PPUSH
24577: CALL_OW 72
24581: ST_TO_ADDR
// if not tmp then
24582: LD_VAR 0 5
24586: NOT
24587: IFFALSE 24591
// continue ;
24589: GO 23840
// list := [ ] ;
24591: LD_ADDR_VAR 0 6
24595: PUSH
24596: EMPTY
24597: ST_TO_ADDR
// for j in tmp do
24598: LD_ADDR_VAR 0 3
24602: PUSH
24603: LD_VAR 0 5
24607: PUSH
24608: FOR_IN
24609: IFFALSE 24678
// begin for k in UnitsInside ( j ) do
24611: LD_ADDR_VAR 0 4
24615: PUSH
24616: LD_VAR 0 3
24620: PPUSH
24621: CALL_OW 313
24625: PUSH
24626: FOR_IN
24627: IFFALSE 24674
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
24629: LD_VAR 0 4
24633: PPUSH
24634: CALL_OW 257
24638: PUSH
24639: LD_INT 1
24641: EQUAL
24642: PUSH
24643: LD_VAR 0 4
24647: PPUSH
24648: CALL_OW 459
24652: NOT
24653: AND
24654: IFFALSE 24672
// list := list ^ k ;
24656: LD_ADDR_VAR 0 6
24660: PUSH
24661: LD_VAR 0 6
24665: PUSH
24666: LD_VAR 0 4
24670: ADD
24671: ST_TO_ADDR
24672: GO 24626
24674: POP
24675: POP
// end ;
24676: GO 24608
24678: POP
24679: POP
// list := list diff mc_miners [ i ] ;
24680: LD_ADDR_VAR 0 6
24684: PUSH
24685: LD_VAR 0 6
24689: PUSH
24690: LD_EXP 83
24694: PUSH
24695: LD_VAR 0 2
24699: ARRAY
24700: DIFF
24701: ST_TO_ADDR
// if not list then
24702: LD_VAR 0 6
24706: NOT
24707: IFFALSE 24711
// continue ;
24709: GO 23840
// k := mc_mines [ i ] - mc_miners [ i ] ;
24711: LD_ADDR_VAR 0 4
24715: PUSH
24716: LD_EXP 82
24720: PUSH
24721: LD_VAR 0 2
24725: ARRAY
24726: PUSH
24727: LD_EXP 83
24731: PUSH
24732: LD_VAR 0 2
24736: ARRAY
24737: MINUS
24738: ST_TO_ADDR
// if k > list then
24739: LD_VAR 0 4
24743: PUSH
24744: LD_VAR 0 6
24748: GREATER
24749: IFFALSE 24761
// k := list ;
24751: LD_ADDR_VAR 0 4
24755: PUSH
24756: LD_VAR 0 6
24760: ST_TO_ADDR
// for j = 1 to k do
24761: LD_ADDR_VAR 0 3
24765: PUSH
24766: DOUBLE
24767: LD_INT 1
24769: DEC
24770: ST_TO_ADDR
24771: LD_VAR 0 4
24775: PUSH
24776: FOR_TO
24777: IFFALSE 24831
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
24779: LD_ADDR_EXP 83
24783: PUSH
24784: LD_EXP 83
24788: PPUSH
24789: LD_VAR 0 2
24793: PUSH
24794: LD_EXP 83
24798: PUSH
24799: LD_VAR 0 2
24803: ARRAY
24804: PUSH
24805: LD_INT 1
24807: PLUS
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PPUSH
24813: LD_VAR 0 6
24817: PUSH
24818: LD_VAR 0 3
24822: ARRAY
24823: PPUSH
24824: CALL 47738 0 3
24828: ST_TO_ADDR
24829: GO 24776
24831: POP
24832: POP
// end ;
24833: GO 23840
24835: POP
24836: POP
// end ;
24837: LD_VAR 0 1
24841: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
24842: LD_INT 0
24844: PPUSH
24845: PPUSH
24846: PPUSH
24847: PPUSH
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
24852: PPUSH
24853: PPUSH
// if not mc_bases then
24854: LD_EXP 69
24858: NOT
24859: IFFALSE 24863
// exit ;
24861: GO 26594
// for i = 1 to mc_bases do
24863: LD_ADDR_VAR 0 2
24867: PUSH
24868: DOUBLE
24869: LD_INT 1
24871: DEC
24872: ST_TO_ADDR
24873: LD_EXP 69
24877: PUSH
24878: FOR_TO
24879: IFFALSE 26592
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
24881: LD_EXP 69
24885: PUSH
24886: LD_VAR 0 2
24890: ARRAY
24891: NOT
24892: PUSH
24893: LD_EXP 76
24897: PUSH
24898: LD_VAR 0 2
24902: ARRAY
24903: OR
24904: IFFALSE 24908
// continue ;
24906: GO 24878
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
24908: LD_EXP 85
24912: PUSH
24913: LD_VAR 0 2
24917: ARRAY
24918: NOT
24919: PUSH
24920: LD_EXP 86
24924: PUSH
24925: LD_VAR 0 2
24929: ARRAY
24930: AND
24931: IFFALSE 24969
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24933: LD_ADDR_EXP 86
24937: PUSH
24938: LD_EXP 86
24942: PPUSH
24943: LD_VAR 0 2
24947: PPUSH
24948: EMPTY
24949: PPUSH
24950: CALL_OW 1
24954: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
24955: LD_VAR 0 2
24959: PPUSH
24960: LD_INT 107
24962: PPUSH
24963: CALL 16381 0 2
// continue ;
24967: GO 24878
// end ; target := [ ] ;
24969: LD_ADDR_VAR 0 6
24973: PUSH
24974: EMPTY
24975: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
24976: LD_ADDR_VAR 0 3
24980: PUSH
24981: DOUBLE
24982: LD_EXP 85
24986: PUSH
24987: LD_VAR 0 2
24991: ARRAY
24992: INC
24993: ST_TO_ADDR
24994: LD_INT 1
24996: PUSH
24997: FOR_DOWNTO
24998: IFFALSE 25258
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
25000: LD_EXP 85
25004: PUSH
25005: LD_VAR 0 2
25009: ARRAY
25010: PUSH
25011: LD_VAR 0 3
25015: ARRAY
25016: PUSH
25017: LD_INT 2
25019: ARRAY
25020: PPUSH
25021: LD_EXP 85
25025: PUSH
25026: LD_VAR 0 2
25030: ARRAY
25031: PUSH
25032: LD_VAR 0 3
25036: ARRAY
25037: PUSH
25038: LD_INT 3
25040: ARRAY
25041: PPUSH
25042: CALL_OW 488
25046: PUSH
25047: LD_EXP 85
25051: PUSH
25052: LD_VAR 0 2
25056: ARRAY
25057: PUSH
25058: LD_VAR 0 3
25062: ARRAY
25063: PUSH
25064: LD_INT 2
25066: ARRAY
25067: PPUSH
25068: LD_EXP 85
25072: PUSH
25073: LD_VAR 0 2
25077: ARRAY
25078: PUSH
25079: LD_VAR 0 3
25083: ARRAY
25084: PUSH
25085: LD_INT 3
25087: ARRAY
25088: PPUSH
25089: CALL_OW 284
25093: PUSH
25094: LD_INT 0
25096: EQUAL
25097: AND
25098: IFFALSE 25153
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
25100: LD_ADDR_VAR 0 5
25104: PUSH
25105: LD_EXP 85
25109: PUSH
25110: LD_VAR 0 2
25114: ARRAY
25115: PPUSH
25116: LD_VAR 0 3
25120: PPUSH
25121: CALL_OW 3
25125: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
25126: LD_ADDR_EXP 85
25130: PUSH
25131: LD_EXP 85
25135: PPUSH
25136: LD_VAR 0 2
25140: PPUSH
25141: LD_VAR 0 5
25145: PPUSH
25146: CALL_OW 1
25150: ST_TO_ADDR
// continue ;
25151: GO 24997
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
25153: LD_EXP 69
25157: PUSH
25158: LD_VAR 0 2
25162: ARRAY
25163: PUSH
25164: LD_INT 1
25166: ARRAY
25167: PPUSH
25168: CALL_OW 255
25172: PPUSH
25173: LD_EXP 85
25177: PUSH
25178: LD_VAR 0 2
25182: ARRAY
25183: PUSH
25184: LD_VAR 0 3
25188: ARRAY
25189: PUSH
25190: LD_INT 2
25192: ARRAY
25193: PPUSH
25194: LD_EXP 85
25198: PUSH
25199: LD_VAR 0 2
25203: ARRAY
25204: PUSH
25205: LD_VAR 0 3
25209: ARRAY
25210: PUSH
25211: LD_INT 3
25213: ARRAY
25214: PPUSH
25215: LD_INT 30
25217: PPUSH
25218: CALL 48634 0 4
25222: PUSH
25223: LD_INT 4
25225: ARRAY
25226: PUSH
25227: LD_INT 0
25229: EQUAL
25230: IFFALSE 25256
// begin target := mc_crates [ i ] [ j ] ;
25232: LD_ADDR_VAR 0 6
25236: PUSH
25237: LD_EXP 85
25241: PUSH
25242: LD_VAR 0 2
25246: ARRAY
25247: PUSH
25248: LD_VAR 0 3
25252: ARRAY
25253: ST_TO_ADDR
// break ;
25254: GO 25258
// end ; end ;
25256: GO 24997
25258: POP
25259: POP
// if not target then
25260: LD_VAR 0 6
25264: NOT
25265: IFFALSE 25269
// continue ;
25267: GO 24878
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
25269: LD_ADDR_VAR 0 7
25273: PUSH
25274: LD_EXP 88
25278: PUSH
25279: LD_VAR 0 2
25283: ARRAY
25284: PPUSH
25285: LD_INT 2
25287: PUSH
25288: LD_INT 3
25290: PUSH
25291: LD_INT 58
25293: PUSH
25294: EMPTY
25295: LIST
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: PUSH
25301: LD_INT 61
25303: PUSH
25304: EMPTY
25305: LIST
25306: PUSH
25307: LD_INT 33
25309: PUSH
25310: LD_INT 5
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PUSH
25317: LD_INT 33
25319: PUSH
25320: LD_INT 3
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: EMPTY
25328: LIST
25329: LIST
25330: LIST
25331: LIST
25332: LIST
25333: PUSH
25334: LD_INT 2
25336: PUSH
25337: LD_INT 34
25339: PUSH
25340: LD_INT 32
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: PUSH
25347: LD_INT 34
25349: PUSH
25350: LD_INT 51
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: PUSH
25357: LD_INT 34
25359: PUSH
25360: LD_INT 12
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: PPUSH
25377: CALL_OW 72
25381: ST_TO_ADDR
// if not cargo then
25382: LD_VAR 0 7
25386: NOT
25387: IFFALSE 26030
// begin if mc_crates_collector [ i ] < 5 then
25389: LD_EXP 86
25393: PUSH
25394: LD_VAR 0 2
25398: ARRAY
25399: PUSH
25400: LD_INT 5
25402: LESS
25403: IFFALSE 25769
// begin if mc_ape [ i ] then
25405: LD_EXP 98
25409: PUSH
25410: LD_VAR 0 2
25414: ARRAY
25415: IFFALSE 25462
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
25417: LD_ADDR_VAR 0 5
25421: PUSH
25422: LD_EXP 98
25426: PUSH
25427: LD_VAR 0 2
25431: ARRAY
25432: PPUSH
25433: LD_INT 25
25435: PUSH
25436: LD_INT 16
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 24
25445: PUSH
25446: LD_INT 750
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PPUSH
25457: CALL_OW 72
25461: ST_TO_ADDR
// if not tmp then
25462: LD_VAR 0 5
25466: NOT
25467: IFFALSE 25514
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
25469: LD_ADDR_VAR 0 5
25473: PUSH
25474: LD_EXP 69
25478: PUSH
25479: LD_VAR 0 2
25483: ARRAY
25484: PPUSH
25485: LD_INT 25
25487: PUSH
25488: LD_INT 2
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 24
25497: PUSH
25498: LD_INT 750
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PPUSH
25509: CALL_OW 72
25513: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
25514: LD_EXP 98
25518: PUSH
25519: LD_VAR 0 2
25523: ARRAY
25524: PUSH
25525: LD_EXP 69
25529: PUSH
25530: LD_VAR 0 2
25534: ARRAY
25535: PPUSH
25536: LD_INT 25
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 24
25548: PUSH
25549: LD_INT 750
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PPUSH
25560: CALL_OW 72
25564: AND
25565: PUSH
25566: LD_VAR 0 5
25570: PUSH
25571: LD_INT 5
25573: LESS
25574: AND
25575: IFFALSE 25657
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
25577: LD_ADDR_VAR 0 3
25581: PUSH
25582: LD_EXP 69
25586: PUSH
25587: LD_VAR 0 2
25591: ARRAY
25592: PPUSH
25593: LD_INT 25
25595: PUSH
25596: LD_INT 2
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 24
25605: PUSH
25606: LD_INT 750
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: EMPTY
25614: LIST
25615: LIST
25616: PPUSH
25617: CALL_OW 72
25621: PUSH
25622: FOR_IN
25623: IFFALSE 25655
// begin tmp := tmp union j ;
25625: LD_ADDR_VAR 0 5
25629: PUSH
25630: LD_VAR 0 5
25634: PUSH
25635: LD_VAR 0 3
25639: UNION
25640: ST_TO_ADDR
// if tmp >= 5 then
25641: LD_VAR 0 5
25645: PUSH
25646: LD_INT 5
25648: GREATEREQUAL
25649: IFFALSE 25653
// break ;
25651: GO 25655
// end ;
25653: GO 25622
25655: POP
25656: POP
// end ; if not tmp then
25657: LD_VAR 0 5
25661: NOT
25662: IFFALSE 25666
// continue ;
25664: GO 24878
// for j in tmp do
25666: LD_ADDR_VAR 0 3
25670: PUSH
25671: LD_VAR 0 5
25675: PUSH
25676: FOR_IN
25677: IFFALSE 25767
// if not GetTag ( j ) then
25679: LD_VAR 0 3
25683: PPUSH
25684: CALL_OW 110
25688: NOT
25689: IFFALSE 25765
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
25691: LD_ADDR_EXP 86
25695: PUSH
25696: LD_EXP 86
25700: PPUSH
25701: LD_VAR 0 2
25705: PUSH
25706: LD_EXP 86
25710: PUSH
25711: LD_VAR 0 2
25715: ARRAY
25716: PUSH
25717: LD_INT 1
25719: PLUS
25720: PUSH
25721: EMPTY
25722: LIST
25723: LIST
25724: PPUSH
25725: LD_VAR 0 3
25729: PPUSH
25730: CALL 47738 0 3
25734: ST_TO_ADDR
// SetTag ( j , 107 ) ;
25735: LD_VAR 0 3
25739: PPUSH
25740: LD_INT 107
25742: PPUSH
25743: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
25747: LD_EXP 86
25751: PUSH
25752: LD_VAR 0 2
25756: ARRAY
25757: PUSH
25758: LD_INT 5
25760: GREATEREQUAL
25761: IFFALSE 25765
// break ;
25763: GO 25767
// end ;
25765: GO 25676
25767: POP
25768: POP
// end ; if mc_crates_collector [ i ] and target then
25769: LD_EXP 86
25773: PUSH
25774: LD_VAR 0 2
25778: ARRAY
25779: PUSH
25780: LD_VAR 0 6
25784: AND
25785: IFFALSE 26028
// begin if mc_crates_collector [ i ] < target [ 1 ] then
25787: LD_EXP 86
25791: PUSH
25792: LD_VAR 0 2
25796: ARRAY
25797: PUSH
25798: LD_VAR 0 6
25802: PUSH
25803: LD_INT 1
25805: ARRAY
25806: LESS
25807: IFFALSE 25827
// tmp := mc_crates_collector [ i ] else
25809: LD_ADDR_VAR 0 5
25813: PUSH
25814: LD_EXP 86
25818: PUSH
25819: LD_VAR 0 2
25823: ARRAY
25824: ST_TO_ADDR
25825: GO 25841
// tmp := target [ 1 ] ;
25827: LD_ADDR_VAR 0 5
25831: PUSH
25832: LD_VAR 0 6
25836: PUSH
25837: LD_INT 1
25839: ARRAY
25840: ST_TO_ADDR
// k := 0 ;
25841: LD_ADDR_VAR 0 4
25845: PUSH
25846: LD_INT 0
25848: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
25849: LD_ADDR_VAR 0 3
25853: PUSH
25854: LD_EXP 86
25858: PUSH
25859: LD_VAR 0 2
25863: ARRAY
25864: PUSH
25865: FOR_IN
25866: IFFALSE 26026
// begin k := k + 1 ;
25868: LD_ADDR_VAR 0 4
25872: PUSH
25873: LD_VAR 0 4
25877: PUSH
25878: LD_INT 1
25880: PLUS
25881: ST_TO_ADDR
// if k > tmp then
25882: LD_VAR 0 4
25886: PUSH
25887: LD_VAR 0 5
25891: GREATER
25892: IFFALSE 25896
// break ;
25894: GO 26026
// if not GetClass ( j ) in [ 2 , 16 ] then
25896: LD_VAR 0 3
25900: PPUSH
25901: CALL_OW 257
25905: PUSH
25906: LD_INT 2
25908: PUSH
25909: LD_INT 16
25911: PUSH
25912: EMPTY
25913: LIST
25914: LIST
25915: IN
25916: NOT
25917: IFFALSE 25970
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
25919: LD_ADDR_EXP 86
25923: PUSH
25924: LD_EXP 86
25928: PPUSH
25929: LD_VAR 0 2
25933: PPUSH
25934: LD_EXP 86
25938: PUSH
25939: LD_VAR 0 2
25943: ARRAY
25944: PUSH
25945: LD_VAR 0 3
25949: DIFF
25950: PPUSH
25951: CALL_OW 1
25955: ST_TO_ADDR
// SetTag ( j , 0 ) ;
25956: LD_VAR 0 3
25960: PPUSH
25961: LD_INT 0
25963: PPUSH
25964: CALL_OW 109
// continue ;
25968: GO 25865
// end ; if IsInUnit ( j ) then
25970: LD_VAR 0 3
25974: PPUSH
25975: CALL_OW 310
25979: IFFALSE 25990
// ComExitBuilding ( j ) ;
25981: LD_VAR 0 3
25985: PPUSH
25986: CALL_OW 122
// wait ( 3 ) ;
25990: LD_INT 3
25992: PPUSH
25993: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
25997: LD_VAR 0 3
26001: PPUSH
26002: LD_VAR 0 6
26006: PUSH
26007: LD_INT 2
26009: ARRAY
26010: PPUSH
26011: LD_VAR 0 6
26015: PUSH
26016: LD_INT 3
26018: ARRAY
26019: PPUSH
26020: CALL_OW 117
// end ;
26024: GO 25865
26026: POP
26027: POP
// end ; end else
26028: GO 26590
// begin for j in cargo do
26030: LD_ADDR_VAR 0 3
26034: PUSH
26035: LD_VAR 0 7
26039: PUSH
26040: FOR_IN
26041: IFFALSE 26588
// begin if GetTag ( j ) <> 0 then
26043: LD_VAR 0 3
26047: PPUSH
26048: CALL_OW 110
26052: PUSH
26053: LD_INT 0
26055: NONEQUAL
26056: IFFALSE 26060
// continue ;
26058: GO 26040
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
26060: LD_VAR 0 3
26064: PPUSH
26065: CALL_OW 256
26069: PUSH
26070: LD_INT 1000
26072: LESS
26073: PUSH
26074: LD_VAR 0 3
26078: PPUSH
26079: LD_EXP 93
26083: PUSH
26084: LD_VAR 0 2
26088: ARRAY
26089: PPUSH
26090: CALL_OW 308
26094: NOT
26095: AND
26096: IFFALSE 26118
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26098: LD_VAR 0 3
26102: PPUSH
26103: LD_EXP 93
26107: PUSH
26108: LD_VAR 0 2
26112: ARRAY
26113: PPUSH
26114: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
26118: LD_VAR 0 3
26122: PPUSH
26123: CALL_OW 256
26127: PUSH
26128: LD_INT 1000
26130: LESS
26131: PUSH
26132: LD_VAR 0 3
26136: PPUSH
26137: LD_EXP 93
26141: PUSH
26142: LD_VAR 0 2
26146: ARRAY
26147: PPUSH
26148: CALL_OW 308
26152: AND
26153: IFFALSE 26157
// continue ;
26155: GO 26040
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
26157: LD_VAR 0 3
26161: PPUSH
26162: CALL_OW 262
26166: PUSH
26167: LD_INT 2
26169: EQUAL
26170: PUSH
26171: LD_VAR 0 3
26175: PPUSH
26176: CALL_OW 261
26180: PUSH
26181: LD_INT 15
26183: LESS
26184: AND
26185: IFFALSE 26189
// continue ;
26187: GO 26040
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
26189: LD_VAR 0 3
26193: PPUSH
26194: CALL_OW 262
26198: PUSH
26199: LD_INT 1
26201: EQUAL
26202: PUSH
26203: LD_VAR 0 3
26207: PPUSH
26208: CALL_OW 261
26212: PUSH
26213: LD_INT 10
26215: LESS
26216: AND
26217: IFFALSE 26527
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26219: LD_ADDR_VAR 0 8
26223: PUSH
26224: LD_EXP 69
26228: PUSH
26229: LD_VAR 0 2
26233: ARRAY
26234: PPUSH
26235: LD_INT 2
26237: PUSH
26238: LD_INT 30
26240: PUSH
26241: LD_INT 0
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 30
26250: PUSH
26251: LD_INT 1
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: LIST
26262: PPUSH
26263: CALL_OW 72
26267: ST_TO_ADDR
// if not depot then
26268: LD_VAR 0 8
26272: NOT
26273: IFFALSE 26277
// continue ;
26275: GO 26040
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
26277: LD_VAR 0 3
26281: PPUSH
26282: LD_VAR 0 8
26286: PPUSH
26287: LD_VAR 0 3
26291: PPUSH
26292: CALL_OW 74
26296: PPUSH
26297: CALL_OW 296
26301: PUSH
26302: LD_INT 6
26304: LESS
26305: IFFALSE 26321
// SetFuel ( j , 100 ) else
26307: LD_VAR 0 3
26311: PPUSH
26312: LD_INT 100
26314: PPUSH
26315: CALL_OW 240
26319: GO 26527
// if GetFuel ( j ) = 0 then
26321: LD_VAR 0 3
26325: PPUSH
26326: CALL_OW 261
26330: PUSH
26331: LD_INT 0
26333: EQUAL
26334: IFFALSE 26527
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
26336: LD_ADDR_EXP 88
26340: PUSH
26341: LD_EXP 88
26345: PPUSH
26346: LD_VAR 0 2
26350: PPUSH
26351: LD_EXP 88
26355: PUSH
26356: LD_VAR 0 2
26360: ARRAY
26361: PUSH
26362: LD_VAR 0 3
26366: DIFF
26367: PPUSH
26368: CALL_OW 1
26372: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
26373: LD_VAR 0 3
26377: PPUSH
26378: CALL_OW 263
26382: PUSH
26383: LD_INT 1
26385: EQUAL
26386: IFFALSE 26402
// ComExitVehicle ( IsInUnit ( j ) ) ;
26388: LD_VAR 0 3
26392: PPUSH
26393: CALL_OW 310
26397: PPUSH
26398: CALL_OW 121
// if GetControl ( j ) = control_remote then
26402: LD_VAR 0 3
26406: PPUSH
26407: CALL_OW 263
26411: PUSH
26412: LD_INT 2
26414: EQUAL
26415: IFFALSE 26426
// ComUnlink ( j ) ;
26417: LD_VAR 0 3
26421: PPUSH
26422: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
26426: LD_ADDR_VAR 0 9
26430: PUSH
26431: LD_VAR 0 2
26435: PPUSH
26436: LD_INT 3
26438: PPUSH
26439: CALL 35689 0 2
26443: ST_TO_ADDR
// if fac then
26444: LD_VAR 0 9
26448: IFFALSE 26525
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
26450: LD_ADDR_VAR 0 10
26454: PUSH
26455: LD_VAR 0 9
26459: PPUSH
26460: LD_VAR 0 3
26464: PPUSH
26465: CALL_OW 265
26469: PPUSH
26470: LD_VAR 0 3
26474: PPUSH
26475: CALL_OW 262
26479: PPUSH
26480: LD_VAR 0 3
26484: PPUSH
26485: CALL_OW 263
26489: PPUSH
26490: LD_VAR 0 3
26494: PPUSH
26495: CALL_OW 264
26499: PPUSH
26500: CALL 45338 0 5
26504: ST_TO_ADDR
// if components then
26505: LD_VAR 0 10
26509: IFFALSE 26525
// MC_InsertProduceList ( i , components ) ;
26511: LD_VAR 0 2
26515: PPUSH
26516: LD_VAR 0 10
26520: PPUSH
26521: CALL 35259 0 2
// end ; continue ;
26525: GO 26040
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
26527: LD_VAR 0 3
26531: PPUSH
26532: LD_INT 1
26534: PPUSH
26535: CALL_OW 289
26539: PUSH
26540: LD_INT 100
26542: LESS
26543: PUSH
26544: LD_VAR 0 3
26548: PPUSH
26549: CALL_OW 314
26553: NOT
26554: AND
26555: IFFALSE 26584
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
26557: LD_VAR 0 3
26561: PPUSH
26562: LD_VAR 0 6
26566: PUSH
26567: LD_INT 2
26569: ARRAY
26570: PPUSH
26571: LD_VAR 0 6
26575: PUSH
26576: LD_INT 3
26578: ARRAY
26579: PPUSH
26580: CALL_OW 117
// break ;
26584: GO 26588
// end ;
26586: GO 26040
26588: POP
26589: POP
// end ; end ;
26590: GO 24878
26592: POP
26593: POP
// end ;
26594: LD_VAR 0 1
26598: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
26599: LD_INT 0
26601: PPUSH
26602: PPUSH
26603: PPUSH
26604: PPUSH
// if not mc_bases then
26605: LD_EXP 69
26609: NOT
26610: IFFALSE 26614
// exit ;
26612: GO 26775
// for i = 1 to mc_bases do
26614: LD_ADDR_VAR 0 2
26618: PUSH
26619: DOUBLE
26620: LD_INT 1
26622: DEC
26623: ST_TO_ADDR
26624: LD_EXP 69
26628: PUSH
26629: FOR_TO
26630: IFFALSE 26773
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
26632: LD_ADDR_VAR 0 4
26636: PUSH
26637: LD_EXP 88
26641: PUSH
26642: LD_VAR 0 2
26646: ARRAY
26647: PUSH
26648: LD_EXP 91
26652: PUSH
26653: LD_VAR 0 2
26657: ARRAY
26658: UNION
26659: PPUSH
26660: LD_INT 33
26662: PUSH
26663: LD_INT 2
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PPUSH
26670: CALL_OW 72
26674: ST_TO_ADDR
// if tmp then
26675: LD_VAR 0 4
26679: IFFALSE 26771
// for j in tmp do
26681: LD_ADDR_VAR 0 3
26685: PUSH
26686: LD_VAR 0 4
26690: PUSH
26691: FOR_IN
26692: IFFALSE 26769
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
26694: LD_VAR 0 3
26698: PPUSH
26699: CALL_OW 312
26703: NOT
26704: PUSH
26705: LD_VAR 0 3
26709: PPUSH
26710: CALL_OW 256
26714: PUSH
26715: LD_INT 250
26717: GREATEREQUAL
26718: AND
26719: IFFALSE 26732
// Connect ( j ) else
26721: LD_VAR 0 3
26725: PPUSH
26726: CALL 50671 0 1
26730: GO 26767
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
26732: LD_VAR 0 3
26736: PPUSH
26737: CALL_OW 256
26741: PUSH
26742: LD_INT 250
26744: LESS
26745: PUSH
26746: LD_VAR 0 3
26750: PPUSH
26751: CALL_OW 312
26755: AND
26756: IFFALSE 26767
// ComUnlink ( j ) ;
26758: LD_VAR 0 3
26762: PPUSH
26763: CALL_OW 136
26767: GO 26691
26769: POP
26770: POP
// end ;
26771: GO 26629
26773: POP
26774: POP
// end ;
26775: LD_VAR 0 1
26779: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
26780: LD_INT 0
26782: PPUSH
26783: PPUSH
26784: PPUSH
26785: PPUSH
26786: PPUSH
// if not mc_bases then
26787: LD_EXP 69
26791: NOT
26792: IFFALSE 26796
// exit ;
26794: GO 27256
// for i = 1 to mc_bases do
26796: LD_ADDR_VAR 0 2
26800: PUSH
26801: DOUBLE
26802: LD_INT 1
26804: DEC
26805: ST_TO_ADDR
26806: LD_EXP 69
26810: PUSH
26811: FOR_TO
26812: IFFALSE 27254
// begin if not mc_produce [ i ] then
26814: LD_EXP 90
26818: PUSH
26819: LD_VAR 0 2
26823: ARRAY
26824: NOT
26825: IFFALSE 26829
// continue ;
26827: GO 26811
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
26829: LD_ADDR_VAR 0 5
26833: PUSH
26834: LD_EXP 69
26838: PUSH
26839: LD_VAR 0 2
26843: ARRAY
26844: PPUSH
26845: LD_INT 30
26847: PUSH
26848: LD_INT 3
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: PPUSH
26855: CALL_OW 72
26859: ST_TO_ADDR
// if not fac then
26860: LD_VAR 0 5
26864: NOT
26865: IFFALSE 26869
// continue ;
26867: GO 26811
// for j in fac do
26869: LD_ADDR_VAR 0 3
26873: PUSH
26874: LD_VAR 0 5
26878: PUSH
26879: FOR_IN
26880: IFFALSE 27250
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
26882: LD_VAR 0 3
26886: PPUSH
26887: CALL_OW 461
26891: PUSH
26892: LD_INT 2
26894: NONEQUAL
26895: PUSH
26896: LD_VAR 0 3
26900: PPUSH
26901: LD_INT 15
26903: PPUSH
26904: CALL 50331 0 2
26908: PUSH
26909: LD_INT 4
26911: ARRAY
26912: OR
26913: PUSH
26914: LD_VAR 0 3
26918: PPUSH
26919: CALL_OW 313
26923: PUSH
26924: LD_INT 0
26926: EQUAL
26927: OR
26928: IFFALSE 26932
// continue ;
26930: GO 26879
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
26932: LD_VAR 0 3
26936: PPUSH
26937: LD_EXP 90
26941: PUSH
26942: LD_VAR 0 2
26946: ARRAY
26947: PUSH
26948: LD_INT 1
26950: ARRAY
26951: PUSH
26952: LD_INT 1
26954: ARRAY
26955: PPUSH
26956: LD_EXP 90
26960: PUSH
26961: LD_VAR 0 2
26965: ARRAY
26966: PUSH
26967: LD_INT 1
26969: ARRAY
26970: PUSH
26971: LD_INT 2
26973: ARRAY
26974: PPUSH
26975: LD_EXP 90
26979: PUSH
26980: LD_VAR 0 2
26984: ARRAY
26985: PUSH
26986: LD_INT 1
26988: ARRAY
26989: PUSH
26990: LD_INT 3
26992: ARRAY
26993: PPUSH
26994: LD_EXP 90
26998: PUSH
26999: LD_VAR 0 2
27003: ARRAY
27004: PUSH
27005: LD_INT 1
27007: ARRAY
27008: PUSH
27009: LD_INT 4
27011: ARRAY
27012: PPUSH
27013: CALL_OW 448
27017: PUSH
27018: LD_VAR 0 3
27022: PPUSH
27023: LD_EXP 90
27027: PUSH
27028: LD_VAR 0 2
27032: ARRAY
27033: PUSH
27034: LD_INT 1
27036: ARRAY
27037: PUSH
27038: LD_INT 1
27040: ARRAY
27041: PUSH
27042: LD_EXP 90
27046: PUSH
27047: LD_VAR 0 2
27051: ARRAY
27052: PUSH
27053: LD_INT 1
27055: ARRAY
27056: PUSH
27057: LD_INT 2
27059: ARRAY
27060: PUSH
27061: LD_EXP 90
27065: PUSH
27066: LD_VAR 0 2
27070: ARRAY
27071: PUSH
27072: LD_INT 1
27074: ARRAY
27075: PUSH
27076: LD_INT 3
27078: ARRAY
27079: PUSH
27080: LD_EXP 90
27084: PUSH
27085: LD_VAR 0 2
27089: ARRAY
27090: PUSH
27091: LD_INT 1
27093: ARRAY
27094: PUSH
27095: LD_INT 4
27097: ARRAY
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: PPUSH
27105: CALL 54002 0 2
27109: AND
27110: IFFALSE 27248
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
27112: LD_VAR 0 3
27116: PPUSH
27117: LD_EXP 90
27121: PUSH
27122: LD_VAR 0 2
27126: ARRAY
27127: PUSH
27128: LD_INT 1
27130: ARRAY
27131: PUSH
27132: LD_INT 1
27134: ARRAY
27135: PPUSH
27136: LD_EXP 90
27140: PUSH
27141: LD_VAR 0 2
27145: ARRAY
27146: PUSH
27147: LD_INT 1
27149: ARRAY
27150: PUSH
27151: LD_INT 2
27153: ARRAY
27154: PPUSH
27155: LD_EXP 90
27159: PUSH
27160: LD_VAR 0 2
27164: ARRAY
27165: PUSH
27166: LD_INT 1
27168: ARRAY
27169: PUSH
27170: LD_INT 3
27172: ARRAY
27173: PPUSH
27174: LD_EXP 90
27178: PUSH
27179: LD_VAR 0 2
27183: ARRAY
27184: PUSH
27185: LD_INT 1
27187: ARRAY
27188: PUSH
27189: LD_INT 4
27191: ARRAY
27192: PPUSH
27193: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
27197: LD_ADDR_VAR 0 4
27201: PUSH
27202: LD_EXP 90
27206: PUSH
27207: LD_VAR 0 2
27211: ARRAY
27212: PPUSH
27213: LD_INT 1
27215: PPUSH
27216: CALL_OW 3
27220: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
27221: LD_ADDR_EXP 90
27225: PUSH
27226: LD_EXP 90
27230: PPUSH
27231: LD_VAR 0 2
27235: PPUSH
27236: LD_VAR 0 4
27240: PPUSH
27241: CALL_OW 1
27245: ST_TO_ADDR
// break ;
27246: GO 27250
// end ; end ;
27248: GO 26879
27250: POP
27251: POP
// end ;
27252: GO 26811
27254: POP
27255: POP
// end ;
27256: LD_VAR 0 1
27260: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
27261: LD_INT 0
27263: PPUSH
27264: PPUSH
27265: PPUSH
// if not mc_bases then
27266: LD_EXP 69
27270: NOT
27271: IFFALSE 27275
// exit ;
27273: GO 27364
// for i = 1 to mc_bases do
27275: LD_ADDR_VAR 0 2
27279: PUSH
27280: DOUBLE
27281: LD_INT 1
27283: DEC
27284: ST_TO_ADDR
27285: LD_EXP 69
27289: PUSH
27290: FOR_TO
27291: IFFALSE 27362
// begin if mc_attack [ i ] then
27293: LD_EXP 89
27297: PUSH
27298: LD_VAR 0 2
27302: ARRAY
27303: IFFALSE 27360
// begin tmp := mc_attack [ i ] [ 1 ] ;
27305: LD_ADDR_VAR 0 3
27309: PUSH
27310: LD_EXP 89
27314: PUSH
27315: LD_VAR 0 2
27319: ARRAY
27320: PUSH
27321: LD_INT 1
27323: ARRAY
27324: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
27325: LD_ADDR_EXP 89
27329: PUSH
27330: LD_EXP 89
27334: PPUSH
27335: LD_VAR 0 2
27339: PPUSH
27340: EMPTY
27341: PPUSH
27342: CALL_OW 1
27346: ST_TO_ADDR
// Attack ( tmp ) ;
27347: LD_VAR 0 3
27351: PPUSH
27352: CALL 76191 0 1
// exit ;
27356: POP
27357: POP
27358: GO 27364
// end ; end ;
27360: GO 27290
27362: POP
27363: POP
// end ;
27364: LD_VAR 0 1
27368: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
27369: LD_INT 0
27371: PPUSH
27372: PPUSH
27373: PPUSH
27374: PPUSH
27375: PPUSH
27376: PPUSH
27377: PPUSH
// if not mc_bases then
27378: LD_EXP 69
27382: NOT
27383: IFFALSE 27387
// exit ;
27385: GO 27991
// for i = 1 to mc_bases do
27387: LD_ADDR_VAR 0 2
27391: PUSH
27392: DOUBLE
27393: LD_INT 1
27395: DEC
27396: ST_TO_ADDR
27397: LD_EXP 69
27401: PUSH
27402: FOR_TO
27403: IFFALSE 27989
// begin if not mc_bases [ i ] then
27405: LD_EXP 69
27409: PUSH
27410: LD_VAR 0 2
27414: ARRAY
27415: NOT
27416: IFFALSE 27420
// continue ;
27418: GO 27402
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
27420: LD_ADDR_VAR 0 7
27424: PUSH
27425: LD_EXP 69
27429: PUSH
27430: LD_VAR 0 2
27434: ARRAY
27435: PUSH
27436: LD_INT 1
27438: ARRAY
27439: PPUSH
27440: CALL 44642 0 1
27444: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
27445: LD_ADDR_EXP 92
27449: PUSH
27450: LD_EXP 92
27454: PPUSH
27455: LD_VAR 0 2
27459: PPUSH
27460: LD_EXP 69
27464: PUSH
27465: LD_VAR 0 2
27469: ARRAY
27470: PUSH
27471: LD_INT 1
27473: ARRAY
27474: PPUSH
27475: CALL_OW 255
27479: PPUSH
27480: LD_EXP 94
27484: PUSH
27485: LD_VAR 0 2
27489: ARRAY
27490: PPUSH
27491: CALL 42602 0 2
27495: PPUSH
27496: CALL_OW 1
27500: ST_TO_ADDR
// if not mc_scan [ i ] then
27501: LD_EXP 92
27505: PUSH
27506: LD_VAR 0 2
27510: ARRAY
27511: NOT
27512: IFFALSE 27667
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27514: LD_ADDR_VAR 0 4
27518: PUSH
27519: LD_EXP 69
27523: PUSH
27524: LD_VAR 0 2
27528: ARRAY
27529: PPUSH
27530: LD_INT 2
27532: PUSH
27533: LD_INT 25
27535: PUSH
27536: LD_INT 5
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 25
27545: PUSH
27546: LD_INT 8
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: LD_INT 25
27555: PUSH
27556: LD_INT 9
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: PPUSH
27569: CALL_OW 72
27573: ST_TO_ADDR
// if not tmp then
27574: LD_VAR 0 4
27578: NOT
27579: IFFALSE 27583
// continue ;
27581: GO 27402
// for j in tmp do
27583: LD_ADDR_VAR 0 3
27587: PUSH
27588: LD_VAR 0 4
27592: PUSH
27593: FOR_IN
27594: IFFALSE 27665
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
27596: LD_VAR 0 3
27600: PPUSH
27601: CALL_OW 310
27605: PPUSH
27606: CALL_OW 266
27610: PUSH
27611: LD_INT 5
27613: EQUAL
27614: PUSH
27615: LD_VAR 0 3
27619: PPUSH
27620: CALL_OW 257
27624: PUSH
27625: LD_INT 1
27627: EQUAL
27628: AND
27629: PUSH
27630: LD_VAR 0 3
27634: PPUSH
27635: CALL_OW 459
27639: NOT
27640: AND
27641: PUSH
27642: LD_VAR 0 7
27646: AND
27647: IFFALSE 27663
// ComChangeProfession ( j , class ) ;
27649: LD_VAR 0 3
27653: PPUSH
27654: LD_VAR 0 7
27658: PPUSH
27659: CALL_OW 123
27663: GO 27593
27665: POP
27666: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
27667: LD_EXP 92
27671: PUSH
27672: LD_VAR 0 2
27676: ARRAY
27677: PUSH
27678: LD_EXP 91
27682: PUSH
27683: LD_VAR 0 2
27687: ARRAY
27688: NOT
27689: AND
27690: PUSH
27691: LD_EXP 69
27695: PUSH
27696: LD_VAR 0 2
27700: ARRAY
27701: PPUSH
27702: LD_INT 30
27704: PUSH
27705: LD_INT 32
27707: PUSH
27708: EMPTY
27709: LIST
27710: LIST
27711: PPUSH
27712: CALL_OW 72
27716: NOT
27717: AND
27718: PUSH
27719: LD_EXP 69
27723: PUSH
27724: LD_VAR 0 2
27728: ARRAY
27729: PPUSH
27730: LD_INT 2
27732: PUSH
27733: LD_INT 30
27735: PUSH
27736: LD_INT 4
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PUSH
27743: LD_INT 30
27745: PUSH
27746: LD_INT 5
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: LIST
27757: PPUSH
27758: CALL_OW 72
27762: NOT
27763: AND
27764: IFFALSE 27896
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27766: LD_ADDR_VAR 0 4
27770: PUSH
27771: LD_EXP 69
27775: PUSH
27776: LD_VAR 0 2
27780: ARRAY
27781: PPUSH
27782: LD_INT 2
27784: PUSH
27785: LD_INT 25
27787: PUSH
27788: LD_INT 1
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 25
27797: PUSH
27798: LD_INT 5
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PUSH
27805: LD_INT 25
27807: PUSH
27808: LD_INT 8
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 25
27817: PUSH
27818: LD_INT 9
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: PPUSH
27832: CALL_OW 72
27836: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
27837: LD_ADDR_VAR 0 4
27841: PUSH
27842: LD_VAR 0 4
27846: PUSH
27847: LD_VAR 0 4
27851: PPUSH
27852: LD_INT 18
27854: PPUSH
27855: CALL 80935 0 2
27859: DIFF
27860: ST_TO_ADDR
// if tmp then
27861: LD_VAR 0 4
27865: IFFALSE 27896
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
27867: LD_VAR 0 2
27871: PPUSH
27872: LD_VAR 0 4
27876: PPUSH
27877: LD_EXP 94
27881: PUSH
27882: LD_VAR 0 2
27886: ARRAY
27887: PPUSH
27888: CALL 42637 0 3
// exit ;
27892: POP
27893: POP
27894: GO 27991
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
27896: LD_EXP 92
27900: PUSH
27901: LD_VAR 0 2
27905: ARRAY
27906: PUSH
27907: LD_EXP 91
27911: PUSH
27912: LD_VAR 0 2
27916: ARRAY
27917: AND
27918: IFFALSE 27987
// begin tmp := mc_defender [ i ] ;
27920: LD_ADDR_VAR 0 4
27924: PUSH
27925: LD_EXP 91
27929: PUSH
27930: LD_VAR 0 2
27934: ARRAY
27935: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
27936: LD_ADDR_EXP 91
27940: PUSH
27941: LD_EXP 91
27945: PPUSH
27946: LD_VAR 0 2
27950: PPUSH
27951: EMPTY
27952: PPUSH
27953: CALL_OW 1
27957: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
27958: LD_VAR 0 2
27962: PPUSH
27963: LD_VAR 0 4
27967: PPUSH
27968: LD_EXP 92
27972: PUSH
27973: LD_VAR 0 2
27977: ARRAY
27978: PPUSH
27979: CALL 43135 0 3
// exit ;
27983: POP
27984: POP
27985: GO 27991
// end ; end ;
27987: GO 27402
27989: POP
27990: POP
// end ;
27991: LD_VAR 0 1
27995: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
27996: LD_INT 0
27998: PPUSH
27999: PPUSH
28000: PPUSH
28001: PPUSH
28002: PPUSH
28003: PPUSH
28004: PPUSH
28005: PPUSH
28006: PPUSH
28007: PPUSH
28008: PPUSH
// if not mc_bases then
28009: LD_EXP 69
28013: NOT
28014: IFFALSE 28018
// exit ;
28016: GO 29105
// for i = 1 to mc_bases do
28018: LD_ADDR_VAR 0 2
28022: PUSH
28023: DOUBLE
28024: LD_INT 1
28026: DEC
28027: ST_TO_ADDR
28028: LD_EXP 69
28032: PUSH
28033: FOR_TO
28034: IFFALSE 29103
// begin tmp := mc_lab [ i ] ;
28036: LD_ADDR_VAR 0 6
28040: PUSH
28041: LD_EXP 102
28045: PUSH
28046: LD_VAR 0 2
28050: ARRAY
28051: ST_TO_ADDR
// if not tmp then
28052: LD_VAR 0 6
28056: NOT
28057: IFFALSE 28061
// continue ;
28059: GO 28033
// idle_lab := 0 ;
28061: LD_ADDR_VAR 0 11
28065: PUSH
28066: LD_INT 0
28068: ST_TO_ADDR
// for j in tmp do
28069: LD_ADDR_VAR 0 3
28073: PUSH
28074: LD_VAR 0 6
28078: PUSH
28079: FOR_IN
28080: IFFALSE 29099
// begin researching := false ;
28082: LD_ADDR_VAR 0 10
28086: PUSH
28087: LD_INT 0
28089: ST_TO_ADDR
// side := GetSide ( j ) ;
28090: LD_ADDR_VAR 0 4
28094: PUSH
28095: LD_VAR 0 3
28099: PPUSH
28100: CALL_OW 255
28104: ST_TO_ADDR
// if not mc_tech [ side ] then
28105: LD_EXP 96
28109: PUSH
28110: LD_VAR 0 4
28114: ARRAY
28115: NOT
28116: IFFALSE 28120
// continue ;
28118: GO 28079
// if BuildingStatus ( j ) = bs_idle then
28120: LD_VAR 0 3
28124: PPUSH
28125: CALL_OW 461
28129: PUSH
28130: LD_INT 2
28132: EQUAL
28133: IFFALSE 28321
// begin if idle_lab and UnitsInside ( j ) < 6 then
28135: LD_VAR 0 11
28139: PUSH
28140: LD_VAR 0 3
28144: PPUSH
28145: CALL_OW 313
28149: PUSH
28150: LD_INT 6
28152: LESS
28153: AND
28154: IFFALSE 28225
// begin tmp2 := UnitsInside ( idle_lab ) ;
28156: LD_ADDR_VAR 0 9
28160: PUSH
28161: LD_VAR 0 11
28165: PPUSH
28166: CALL_OW 313
28170: ST_TO_ADDR
// if tmp2 then
28171: LD_VAR 0 9
28175: IFFALSE 28217
// for x in tmp2 do
28177: LD_ADDR_VAR 0 7
28181: PUSH
28182: LD_VAR 0 9
28186: PUSH
28187: FOR_IN
28188: IFFALSE 28215
// begin ComExitBuilding ( x ) ;
28190: LD_VAR 0 7
28194: PPUSH
28195: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
28199: LD_VAR 0 7
28203: PPUSH
28204: LD_VAR 0 3
28208: PPUSH
28209: CALL_OW 180
// end ;
28213: GO 28187
28215: POP
28216: POP
// idle_lab := 0 ;
28217: LD_ADDR_VAR 0 11
28221: PUSH
28222: LD_INT 0
28224: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
28225: LD_ADDR_VAR 0 5
28229: PUSH
28230: LD_EXP 96
28234: PUSH
28235: LD_VAR 0 4
28239: ARRAY
28240: PUSH
28241: FOR_IN
28242: IFFALSE 28302
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
28244: LD_VAR 0 3
28248: PPUSH
28249: LD_VAR 0 5
28253: PPUSH
28254: CALL_OW 430
28258: PUSH
28259: LD_VAR 0 4
28263: PPUSH
28264: LD_VAR 0 5
28268: PPUSH
28269: CALL 41707 0 2
28273: AND
28274: IFFALSE 28300
// begin researching := true ;
28276: LD_ADDR_VAR 0 10
28280: PUSH
28281: LD_INT 1
28283: ST_TO_ADDR
// ComResearch ( j , t ) ;
28284: LD_VAR 0 3
28288: PPUSH
28289: LD_VAR 0 5
28293: PPUSH
28294: CALL_OW 124
// break ;
28298: GO 28302
// end ;
28300: GO 28241
28302: POP
28303: POP
// if not researching then
28304: LD_VAR 0 10
28308: NOT
28309: IFFALSE 28321
// idle_lab := j ;
28311: LD_ADDR_VAR 0 11
28315: PUSH
28316: LD_VAR 0 3
28320: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
28321: LD_VAR 0 3
28325: PPUSH
28326: CALL_OW 461
28330: PUSH
28331: LD_INT 10
28333: EQUAL
28334: IFFALSE 28922
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
28336: LD_EXP 98
28340: PUSH
28341: LD_VAR 0 2
28345: ARRAY
28346: NOT
28347: PUSH
28348: LD_EXP 99
28352: PUSH
28353: LD_VAR 0 2
28357: ARRAY
28358: NOT
28359: AND
28360: PUSH
28361: LD_EXP 96
28365: PUSH
28366: LD_VAR 0 4
28370: ARRAY
28371: PUSH
28372: LD_INT 1
28374: GREATER
28375: AND
28376: IFFALSE 28507
// begin ComCancel ( j ) ;
28378: LD_VAR 0 3
28382: PPUSH
28383: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
28387: LD_ADDR_EXP 96
28391: PUSH
28392: LD_EXP 96
28396: PPUSH
28397: LD_VAR 0 4
28401: PPUSH
28402: LD_EXP 96
28406: PUSH
28407: LD_VAR 0 4
28411: ARRAY
28412: PPUSH
28413: LD_EXP 96
28417: PUSH
28418: LD_VAR 0 4
28422: ARRAY
28423: PUSH
28424: LD_INT 1
28426: MINUS
28427: PPUSH
28428: LD_EXP 96
28432: PUSH
28433: LD_VAR 0 4
28437: ARRAY
28438: PPUSH
28439: LD_INT 0
28441: PPUSH
28442: CALL 47156 0 4
28446: PPUSH
28447: CALL_OW 1
28451: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
28452: LD_ADDR_EXP 96
28456: PUSH
28457: LD_EXP 96
28461: PPUSH
28462: LD_VAR 0 4
28466: PPUSH
28467: LD_EXP 96
28471: PUSH
28472: LD_VAR 0 4
28476: ARRAY
28477: PPUSH
28478: LD_EXP 96
28482: PUSH
28483: LD_VAR 0 4
28487: ARRAY
28488: PPUSH
28489: LD_INT 1
28491: PPUSH
28492: LD_INT 0
28494: PPUSH
28495: CALL 47156 0 4
28499: PPUSH
28500: CALL_OW 1
28504: ST_TO_ADDR
// continue ;
28505: GO 28079
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
28507: LD_EXP 98
28511: PUSH
28512: LD_VAR 0 2
28516: ARRAY
28517: PUSH
28518: LD_EXP 99
28522: PUSH
28523: LD_VAR 0 2
28527: ARRAY
28528: NOT
28529: AND
28530: IFFALSE 28657
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
28532: LD_ADDR_EXP 99
28536: PUSH
28537: LD_EXP 99
28541: PPUSH
28542: LD_VAR 0 2
28546: PUSH
28547: LD_EXP 99
28551: PUSH
28552: LD_VAR 0 2
28556: ARRAY
28557: PUSH
28558: LD_INT 1
28560: PLUS
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PPUSH
28566: LD_EXP 98
28570: PUSH
28571: LD_VAR 0 2
28575: ARRAY
28576: PUSH
28577: LD_INT 1
28579: ARRAY
28580: PPUSH
28581: CALL 47738 0 3
28585: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
28586: LD_EXP 98
28590: PUSH
28591: LD_VAR 0 2
28595: ARRAY
28596: PUSH
28597: LD_INT 1
28599: ARRAY
28600: PPUSH
28601: LD_INT 112
28603: PPUSH
28604: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
28608: LD_ADDR_VAR 0 9
28612: PUSH
28613: LD_EXP 98
28617: PUSH
28618: LD_VAR 0 2
28622: ARRAY
28623: PPUSH
28624: LD_INT 1
28626: PPUSH
28627: CALL_OW 3
28631: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
28632: LD_ADDR_EXP 98
28636: PUSH
28637: LD_EXP 98
28641: PPUSH
28642: LD_VAR 0 2
28646: PPUSH
28647: LD_VAR 0 9
28651: PPUSH
28652: CALL_OW 1
28656: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
28657: LD_EXP 98
28661: PUSH
28662: LD_VAR 0 2
28666: ARRAY
28667: PUSH
28668: LD_EXP 99
28672: PUSH
28673: LD_VAR 0 2
28677: ARRAY
28678: AND
28679: PUSH
28680: LD_EXP 99
28684: PUSH
28685: LD_VAR 0 2
28689: ARRAY
28690: PUSH
28691: LD_INT 1
28693: ARRAY
28694: PPUSH
28695: CALL_OW 310
28699: NOT
28700: AND
28701: PUSH
28702: LD_VAR 0 3
28706: PPUSH
28707: CALL_OW 313
28711: PUSH
28712: LD_INT 6
28714: EQUAL
28715: AND
28716: IFFALSE 28772
// begin tmp2 := UnitsInside ( j ) ;
28718: LD_ADDR_VAR 0 9
28722: PUSH
28723: LD_VAR 0 3
28727: PPUSH
28728: CALL_OW 313
28732: ST_TO_ADDR
// if tmp2 = 6 then
28733: LD_VAR 0 9
28737: PUSH
28738: LD_INT 6
28740: EQUAL
28741: IFFALSE 28772
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
28743: LD_VAR 0 9
28747: PUSH
28748: LD_INT 1
28750: ARRAY
28751: PPUSH
28752: LD_INT 112
28754: PPUSH
28755: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
28759: LD_VAR 0 9
28763: PUSH
28764: LD_INT 1
28766: ARRAY
28767: PPUSH
28768: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
28772: LD_EXP 99
28776: PUSH
28777: LD_VAR 0 2
28781: ARRAY
28782: PUSH
28783: LD_EXP 99
28787: PUSH
28788: LD_VAR 0 2
28792: ARRAY
28793: PUSH
28794: LD_INT 1
28796: ARRAY
28797: PPUSH
28798: CALL_OW 314
28802: NOT
28803: AND
28804: PUSH
28805: LD_EXP 99
28809: PUSH
28810: LD_VAR 0 2
28814: ARRAY
28815: PUSH
28816: LD_INT 1
28818: ARRAY
28819: PPUSH
28820: CALL_OW 310
28824: NOT
28825: AND
28826: IFFALSE 28852
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
28828: LD_EXP 99
28832: PUSH
28833: LD_VAR 0 2
28837: ARRAY
28838: PUSH
28839: LD_INT 1
28841: ARRAY
28842: PPUSH
28843: LD_VAR 0 3
28847: PPUSH
28848: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
28852: LD_EXP 99
28856: PUSH
28857: LD_VAR 0 2
28861: ARRAY
28862: PUSH
28863: LD_INT 1
28865: ARRAY
28866: PPUSH
28867: CALL_OW 310
28871: PUSH
28872: LD_EXP 99
28876: PUSH
28877: LD_VAR 0 2
28881: ARRAY
28882: PUSH
28883: LD_INT 1
28885: ARRAY
28886: PPUSH
28887: CALL_OW 310
28891: PPUSH
28892: CALL_OW 461
28896: PUSH
28897: LD_INT 3
28899: NONEQUAL
28900: AND
28901: IFFALSE 28922
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
28903: LD_EXP 99
28907: PUSH
28908: LD_VAR 0 2
28912: ARRAY
28913: PUSH
28914: LD_INT 1
28916: ARRAY
28917: PPUSH
28918: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
28922: LD_VAR 0 3
28926: PPUSH
28927: CALL_OW 461
28931: PUSH
28932: LD_INT 6
28934: EQUAL
28935: PUSH
28936: LD_VAR 0 6
28940: PUSH
28941: LD_INT 1
28943: GREATER
28944: AND
28945: IFFALSE 29097
// begin sci := [ ] ;
28947: LD_ADDR_VAR 0 8
28951: PUSH
28952: EMPTY
28953: ST_TO_ADDR
// for x in ( tmp diff j ) do
28954: LD_ADDR_VAR 0 7
28958: PUSH
28959: LD_VAR 0 6
28963: PUSH
28964: LD_VAR 0 3
28968: DIFF
28969: PUSH
28970: FOR_IN
28971: IFFALSE 29023
// begin if sci = 6 then
28973: LD_VAR 0 8
28977: PUSH
28978: LD_INT 6
28980: EQUAL
28981: IFFALSE 28985
// break ;
28983: GO 29023
// if BuildingStatus ( x ) = bs_idle then
28985: LD_VAR 0 7
28989: PPUSH
28990: CALL_OW 461
28994: PUSH
28995: LD_INT 2
28997: EQUAL
28998: IFFALSE 29021
// sci := sci ^ UnitsInside ( x ) ;
29000: LD_ADDR_VAR 0 8
29004: PUSH
29005: LD_VAR 0 8
29009: PUSH
29010: LD_VAR 0 7
29014: PPUSH
29015: CALL_OW 313
29019: ADD
29020: ST_TO_ADDR
// end ;
29021: GO 28970
29023: POP
29024: POP
// if not sci then
29025: LD_VAR 0 8
29029: NOT
29030: IFFALSE 29034
// continue ;
29032: GO 28079
// for x in sci do
29034: LD_ADDR_VAR 0 7
29038: PUSH
29039: LD_VAR 0 8
29043: PUSH
29044: FOR_IN
29045: IFFALSE 29095
// if IsInUnit ( x ) and not HasTask ( x ) then
29047: LD_VAR 0 7
29051: PPUSH
29052: CALL_OW 310
29056: PUSH
29057: LD_VAR 0 7
29061: PPUSH
29062: CALL_OW 314
29066: NOT
29067: AND
29068: IFFALSE 29093
// begin ComExitBuilding ( x ) ;
29070: LD_VAR 0 7
29074: PPUSH
29075: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
29079: LD_VAR 0 7
29083: PPUSH
29084: LD_VAR 0 3
29088: PPUSH
29089: CALL_OW 180
// end ;
29093: GO 29044
29095: POP
29096: POP
// end ; end ;
29097: GO 28079
29099: POP
29100: POP
// end ;
29101: GO 28033
29103: POP
29104: POP
// end ;
29105: LD_VAR 0 1
29109: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
29110: LD_INT 0
29112: PPUSH
29113: PPUSH
// if not mc_bases then
29114: LD_EXP 69
29118: NOT
29119: IFFALSE 29123
// exit ;
29121: GO 29204
// for i = 1 to mc_bases do
29123: LD_ADDR_VAR 0 2
29127: PUSH
29128: DOUBLE
29129: LD_INT 1
29131: DEC
29132: ST_TO_ADDR
29133: LD_EXP 69
29137: PUSH
29138: FOR_TO
29139: IFFALSE 29202
// if mc_mines [ i ] and mc_miners [ i ] then
29141: LD_EXP 82
29145: PUSH
29146: LD_VAR 0 2
29150: ARRAY
29151: PUSH
29152: LD_EXP 83
29156: PUSH
29157: LD_VAR 0 2
29161: ARRAY
29162: AND
29163: IFFALSE 29200
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
29165: LD_EXP 83
29169: PUSH
29170: LD_VAR 0 2
29174: ARRAY
29175: PUSH
29176: LD_INT 1
29178: ARRAY
29179: PPUSH
29180: CALL_OW 255
29184: PPUSH
29185: LD_EXP 82
29189: PUSH
29190: LD_VAR 0 2
29194: ARRAY
29195: PPUSH
29196: CALL 44795 0 2
29200: GO 29138
29202: POP
29203: POP
// end ;
29204: LD_VAR 0 1
29208: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
29209: LD_INT 0
29211: PPUSH
29212: PPUSH
29213: PPUSH
29214: PPUSH
29215: PPUSH
29216: PPUSH
29217: PPUSH
29218: PPUSH
// if not mc_bases or not mc_parking then
29219: LD_EXP 69
29223: NOT
29224: PUSH
29225: LD_EXP 93
29229: NOT
29230: OR
29231: IFFALSE 29235
// exit ;
29233: GO 29947
// for i = 1 to mc_bases do
29235: LD_ADDR_VAR 0 2
29239: PUSH
29240: DOUBLE
29241: LD_INT 1
29243: DEC
29244: ST_TO_ADDR
29245: LD_EXP 69
29249: PUSH
29250: FOR_TO
29251: IFFALSE 29945
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
29253: LD_EXP 69
29257: PUSH
29258: LD_VAR 0 2
29262: ARRAY
29263: NOT
29264: PUSH
29265: LD_EXP 93
29269: PUSH
29270: LD_VAR 0 2
29274: ARRAY
29275: NOT
29276: OR
29277: IFFALSE 29281
// continue ;
29279: GO 29250
// if mc_scan [ i ] then
29281: LD_EXP 92
29285: PUSH
29286: LD_VAR 0 2
29290: ARRAY
29291: IFFALSE 29317
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
29293: LD_ADDR_EXP 81
29297: PUSH
29298: LD_EXP 81
29302: PPUSH
29303: LD_VAR 0 2
29307: PPUSH
29308: EMPTY
29309: PPUSH
29310: CALL_OW 1
29314: ST_TO_ADDR
// continue ;
29315: GO 29250
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
29317: LD_ADDR_VAR 0 5
29321: PUSH
29322: LD_EXP 69
29326: PUSH
29327: LD_VAR 0 2
29331: ARRAY
29332: PUSH
29333: LD_INT 1
29335: ARRAY
29336: PPUSH
29337: CALL_OW 255
29341: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29342: LD_ADDR_VAR 0 6
29346: PUSH
29347: LD_EXP 69
29351: PUSH
29352: LD_VAR 0 2
29356: ARRAY
29357: PPUSH
29358: LD_INT 30
29360: PUSH
29361: LD_INT 3
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PPUSH
29368: CALL_OW 72
29372: ST_TO_ADDR
// if not fac then
29373: LD_VAR 0 6
29377: NOT
29378: IFFALSE 29429
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29380: LD_ADDR_VAR 0 6
29384: PUSH
29385: LD_EXP 69
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PPUSH
29396: LD_INT 2
29398: PUSH
29399: LD_INT 30
29401: PUSH
29402: LD_INT 0
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: PUSH
29409: LD_INT 30
29411: PUSH
29412: LD_INT 1
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: LIST
29423: PPUSH
29424: CALL_OW 72
29428: ST_TO_ADDR
// if not fac then
29429: LD_VAR 0 6
29433: NOT
29434: IFFALSE 29438
// continue ;
29436: GO 29250
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29438: LD_ADDR_VAR 0 7
29442: PUSH
29443: LD_EXP 93
29447: PUSH
29448: LD_VAR 0 2
29452: ARRAY
29453: PPUSH
29454: LD_INT 22
29456: PUSH
29457: LD_VAR 0 5
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 21
29468: PUSH
29469: LD_INT 2
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 3
29478: PUSH
29479: LD_INT 24
29481: PUSH
29482: LD_INT 1000
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: EMPTY
29490: LIST
29491: LIST
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: LIST
29497: PPUSH
29498: CALL_OW 70
29502: PUSH
29503: LD_INT 22
29505: PUSH
29506: LD_VAR 0 5
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 91
29517: PUSH
29518: LD_VAR 0 6
29522: PUSH
29523: LD_INT 1
29525: ARRAY
29526: PUSH
29527: LD_INT 25
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 21
29537: PUSH
29538: LD_INT 2
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 3
29547: PUSH
29548: LD_INT 24
29550: PUSH
29551: LD_INT 1000
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: LIST
29566: LIST
29567: PPUSH
29568: CALL_OW 69
29572: UNION
29573: ST_TO_ADDR
// if not vehs then
29574: LD_VAR 0 7
29578: NOT
29579: IFFALSE 29605
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
29581: LD_ADDR_EXP 81
29585: PUSH
29586: LD_EXP 81
29590: PPUSH
29591: LD_VAR 0 2
29595: PPUSH
29596: EMPTY
29597: PPUSH
29598: CALL_OW 1
29602: ST_TO_ADDR
// continue ;
29603: GO 29250
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29605: LD_ADDR_VAR 0 8
29609: PUSH
29610: LD_EXP 69
29614: PUSH
29615: LD_VAR 0 2
29619: ARRAY
29620: PPUSH
29621: LD_INT 30
29623: PUSH
29624: LD_INT 3
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PPUSH
29631: CALL_OW 72
29635: ST_TO_ADDR
// if tmp then
29636: LD_VAR 0 8
29640: IFFALSE 29743
// begin for j in tmp do
29642: LD_ADDR_VAR 0 3
29646: PUSH
29647: LD_VAR 0 8
29651: PUSH
29652: FOR_IN
29653: IFFALSE 29741
// for k in UnitsInside ( j ) do
29655: LD_ADDR_VAR 0 4
29659: PUSH
29660: LD_VAR 0 3
29664: PPUSH
29665: CALL_OW 313
29669: PUSH
29670: FOR_IN
29671: IFFALSE 29737
// if k then
29673: LD_VAR 0 4
29677: IFFALSE 29735
// if not k in mc_repair_vehicle [ i ] then
29679: LD_VAR 0 4
29683: PUSH
29684: LD_EXP 81
29688: PUSH
29689: LD_VAR 0 2
29693: ARRAY
29694: IN
29695: NOT
29696: IFFALSE 29735
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
29698: LD_ADDR_EXP 81
29702: PUSH
29703: LD_EXP 81
29707: PPUSH
29708: LD_VAR 0 2
29712: PPUSH
29713: LD_EXP 81
29717: PUSH
29718: LD_VAR 0 2
29722: ARRAY
29723: PUSH
29724: LD_VAR 0 4
29728: UNION
29729: PPUSH
29730: CALL_OW 1
29734: ST_TO_ADDR
29735: GO 29670
29737: POP
29738: POP
29739: GO 29652
29741: POP
29742: POP
// end ; if not mc_repair_vehicle [ i ] then
29743: LD_EXP 81
29747: PUSH
29748: LD_VAR 0 2
29752: ARRAY
29753: NOT
29754: IFFALSE 29758
// continue ;
29756: GO 29250
// for j in mc_repair_vehicle [ i ] do
29758: LD_ADDR_VAR 0 3
29762: PUSH
29763: LD_EXP 81
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: PUSH
29774: FOR_IN
29775: IFFALSE 29941
// begin if GetClass ( j ) <> 3 then
29777: LD_VAR 0 3
29781: PPUSH
29782: CALL_OW 257
29786: PUSH
29787: LD_INT 3
29789: NONEQUAL
29790: IFFALSE 29831
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
29792: LD_ADDR_EXP 81
29796: PUSH
29797: LD_EXP 81
29801: PPUSH
29802: LD_VAR 0 2
29806: PPUSH
29807: LD_EXP 81
29811: PUSH
29812: LD_VAR 0 2
29816: ARRAY
29817: PUSH
29818: LD_VAR 0 3
29822: DIFF
29823: PPUSH
29824: CALL_OW 1
29828: ST_TO_ADDR
// continue ;
29829: GO 29774
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
29831: LD_VAR 0 3
29835: PPUSH
29836: CALL_OW 311
29840: NOT
29841: PUSH
29842: LD_VAR 0 3
29846: PUSH
29847: LD_EXP 72
29851: PUSH
29852: LD_VAR 0 2
29856: ARRAY
29857: PUSH
29858: LD_INT 1
29860: ARRAY
29861: IN
29862: NOT
29863: AND
29864: PUSH
29865: LD_VAR 0 3
29869: PUSH
29870: LD_EXP 72
29874: PUSH
29875: LD_VAR 0 2
29879: ARRAY
29880: PUSH
29881: LD_INT 2
29883: ARRAY
29884: IN
29885: NOT
29886: AND
29887: IFFALSE 29939
// begin if IsInUnit ( j ) then
29889: LD_VAR 0 3
29893: PPUSH
29894: CALL_OW 310
29898: IFFALSE 29909
// ComExitBuilding ( j ) ;
29900: LD_VAR 0 3
29904: PPUSH
29905: CALL_OW 122
// if not HasTask ( j ) then
29909: LD_VAR 0 3
29913: PPUSH
29914: CALL_OW 314
29918: NOT
29919: IFFALSE 29939
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
29921: LD_VAR 0 3
29925: PPUSH
29926: LD_VAR 0 7
29930: PUSH
29931: LD_INT 1
29933: ARRAY
29934: PPUSH
29935: CALL_OW 189
// end ; end ;
29939: GO 29774
29941: POP
29942: POP
// end ;
29943: GO 29250
29945: POP
29946: POP
// end ;
29947: LD_VAR 0 1
29951: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
29952: LD_INT 0
29954: PPUSH
29955: PPUSH
29956: PPUSH
29957: PPUSH
29958: PPUSH
29959: PPUSH
29960: PPUSH
29961: PPUSH
29962: PPUSH
29963: PPUSH
29964: PPUSH
// if not mc_bases then
29965: LD_EXP 69
29969: NOT
29970: IFFALSE 29974
// exit ;
29972: GO 30776
// for i = 1 to mc_bases do
29974: LD_ADDR_VAR 0 2
29978: PUSH
29979: DOUBLE
29980: LD_INT 1
29982: DEC
29983: ST_TO_ADDR
29984: LD_EXP 69
29988: PUSH
29989: FOR_TO
29990: IFFALSE 30774
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
29992: LD_EXP 97
29996: PUSH
29997: LD_VAR 0 2
30001: ARRAY
30002: NOT
30003: PUSH
30004: LD_EXP 72
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: PUSH
30015: LD_INT 1
30017: ARRAY
30018: OR
30019: PUSH
30020: LD_EXP 72
30024: PUSH
30025: LD_VAR 0 2
30029: ARRAY
30030: PUSH
30031: LD_INT 2
30033: ARRAY
30034: OR
30035: PUSH
30036: LD_EXP 95
30040: PUSH
30041: LD_VAR 0 2
30045: ARRAY
30046: PPUSH
30047: LD_INT 1
30049: PPUSH
30050: CALL_OW 325
30054: NOT
30055: OR
30056: PUSH
30057: LD_EXP 92
30061: PUSH
30062: LD_VAR 0 2
30066: ARRAY
30067: OR
30068: IFFALSE 30072
// continue ;
30070: GO 29989
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
30072: LD_ADDR_VAR 0 8
30076: PUSH
30077: LD_EXP 69
30081: PUSH
30082: LD_VAR 0 2
30086: ARRAY
30087: PPUSH
30088: LD_INT 25
30090: PUSH
30091: LD_INT 4
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 50
30100: PUSH
30101: EMPTY
30102: LIST
30103: PUSH
30104: LD_INT 3
30106: PUSH
30107: LD_INT 60
30109: PUSH
30110: EMPTY
30111: LIST
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: LIST
30121: PPUSH
30122: CALL_OW 72
30126: PUSH
30127: LD_EXP 73
30131: PUSH
30132: LD_VAR 0 2
30136: ARRAY
30137: DIFF
30138: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30139: LD_ADDR_VAR 0 9
30143: PUSH
30144: LD_EXP 69
30148: PUSH
30149: LD_VAR 0 2
30153: ARRAY
30154: PPUSH
30155: LD_INT 2
30157: PUSH
30158: LD_INT 30
30160: PUSH
30161: LD_INT 0
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 30
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: LIST
30182: PPUSH
30183: CALL_OW 72
30187: ST_TO_ADDR
// if not tmp or not dep then
30188: LD_VAR 0 8
30192: NOT
30193: PUSH
30194: LD_VAR 0 9
30198: NOT
30199: OR
30200: IFFALSE 30204
// continue ;
30202: GO 29989
// side := GetSide ( tmp [ 1 ] ) ;
30204: LD_ADDR_VAR 0 11
30208: PUSH
30209: LD_VAR 0 8
30213: PUSH
30214: LD_INT 1
30216: ARRAY
30217: PPUSH
30218: CALL_OW 255
30222: ST_TO_ADDR
// dep := dep [ 1 ] ;
30223: LD_ADDR_VAR 0 9
30227: PUSH
30228: LD_VAR 0 9
30232: PUSH
30233: LD_INT 1
30235: ARRAY
30236: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
30237: LD_ADDR_VAR 0 7
30241: PUSH
30242: LD_EXP 97
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PPUSH
30253: LD_INT 22
30255: PUSH
30256: LD_INT 0
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 25
30265: PUSH
30266: LD_INT 12
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PPUSH
30277: CALL_OW 70
30281: PUSH
30282: LD_INT 22
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 25
30294: PUSH
30295: LD_INT 12
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 91
30304: PUSH
30305: LD_VAR 0 9
30309: PUSH
30310: LD_INT 20
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: LIST
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: LIST
30322: PPUSH
30323: CALL_OW 69
30327: UNION
30328: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
30329: LD_ADDR_VAR 0 10
30333: PUSH
30334: LD_EXP 97
30338: PUSH
30339: LD_VAR 0 2
30343: ARRAY
30344: PPUSH
30345: LD_INT 81
30347: PUSH
30348: LD_VAR 0 11
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PPUSH
30357: CALL_OW 70
30361: ST_TO_ADDR
// if not apes or danger_at_area then
30362: LD_VAR 0 7
30366: NOT
30367: PUSH
30368: LD_VAR 0 10
30372: OR
30373: IFFALSE 30423
// begin if mc_taming [ i ] then
30375: LD_EXP 100
30379: PUSH
30380: LD_VAR 0 2
30384: ARRAY
30385: IFFALSE 30421
// begin MC_Reset ( i , 121 ) ;
30387: LD_VAR 0 2
30391: PPUSH
30392: LD_INT 121
30394: PPUSH
30395: CALL 16381 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30399: LD_ADDR_EXP 100
30403: PUSH
30404: LD_EXP 100
30408: PPUSH
30409: LD_VAR 0 2
30413: PPUSH
30414: EMPTY
30415: PPUSH
30416: CALL_OW 1
30420: ST_TO_ADDR
// end ; continue ;
30421: GO 29989
// end ; for j in tmp do
30423: LD_ADDR_VAR 0 3
30427: PUSH
30428: LD_VAR 0 8
30432: PUSH
30433: FOR_IN
30434: IFFALSE 30770
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
30436: LD_VAR 0 3
30440: PUSH
30441: LD_EXP 100
30445: PUSH
30446: LD_VAR 0 2
30450: ARRAY
30451: IN
30452: NOT
30453: PUSH
30454: LD_EXP 100
30458: PUSH
30459: LD_VAR 0 2
30463: ARRAY
30464: PUSH
30465: LD_INT 3
30467: LESS
30468: AND
30469: IFFALSE 30527
// begin SetTag ( j , 121 ) ;
30471: LD_VAR 0 3
30475: PPUSH
30476: LD_INT 121
30478: PPUSH
30479: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
30483: LD_ADDR_EXP 100
30487: PUSH
30488: LD_EXP 100
30492: PPUSH
30493: LD_VAR 0 2
30497: PUSH
30498: LD_EXP 100
30502: PUSH
30503: LD_VAR 0 2
30507: ARRAY
30508: PUSH
30509: LD_INT 1
30511: PLUS
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PPUSH
30517: LD_VAR 0 3
30521: PPUSH
30522: CALL 47738 0 3
30526: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
30527: LD_VAR 0 3
30531: PUSH
30532: LD_EXP 100
30536: PUSH
30537: LD_VAR 0 2
30541: ARRAY
30542: IN
30543: IFFALSE 30768
// begin if GetClass ( j ) <> 4 then
30545: LD_VAR 0 3
30549: PPUSH
30550: CALL_OW 257
30554: PUSH
30555: LD_INT 4
30557: NONEQUAL
30558: IFFALSE 30611
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
30560: LD_ADDR_EXP 100
30564: PUSH
30565: LD_EXP 100
30569: PPUSH
30570: LD_VAR 0 2
30574: PPUSH
30575: LD_EXP 100
30579: PUSH
30580: LD_VAR 0 2
30584: ARRAY
30585: PUSH
30586: LD_VAR 0 3
30590: DIFF
30591: PPUSH
30592: CALL_OW 1
30596: ST_TO_ADDR
// SetTag ( j , 0 ) ;
30597: LD_VAR 0 3
30601: PPUSH
30602: LD_INT 0
30604: PPUSH
30605: CALL_OW 109
// continue ;
30609: GO 30433
// end ; if IsInUnit ( j ) then
30611: LD_VAR 0 3
30615: PPUSH
30616: CALL_OW 310
30620: IFFALSE 30631
// ComExitBuilding ( j ) ;
30622: LD_VAR 0 3
30626: PPUSH
30627: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
30631: LD_ADDR_VAR 0 6
30635: PUSH
30636: LD_VAR 0 7
30640: PPUSH
30641: LD_VAR 0 3
30645: PPUSH
30646: CALL_OW 74
30650: ST_TO_ADDR
// if not ape then
30651: LD_VAR 0 6
30655: NOT
30656: IFFALSE 30660
// break ;
30658: GO 30770
// x := GetX ( ape ) ;
30660: LD_ADDR_VAR 0 4
30664: PUSH
30665: LD_VAR 0 6
30669: PPUSH
30670: CALL_OW 250
30674: ST_TO_ADDR
// y := GetY ( ape ) ;
30675: LD_ADDR_VAR 0 5
30679: PUSH
30680: LD_VAR 0 6
30684: PPUSH
30685: CALL_OW 251
30689: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30690: LD_VAR 0 4
30694: PPUSH
30695: LD_VAR 0 5
30699: PPUSH
30700: CALL_OW 488
30704: NOT
30705: PUSH
30706: LD_VAR 0 11
30710: PPUSH
30711: LD_VAR 0 4
30715: PPUSH
30716: LD_VAR 0 5
30720: PPUSH
30721: LD_INT 20
30723: PPUSH
30724: CALL 48634 0 4
30728: PUSH
30729: LD_INT 4
30731: ARRAY
30732: OR
30733: IFFALSE 30737
// break ;
30735: GO 30770
// if not HasTask ( j ) then
30737: LD_VAR 0 3
30741: PPUSH
30742: CALL_OW 314
30746: NOT
30747: IFFALSE 30768
// ComTameXY ( j , x , y ) ;
30749: LD_VAR 0 3
30753: PPUSH
30754: LD_VAR 0 4
30758: PPUSH
30759: LD_VAR 0 5
30763: PPUSH
30764: CALL_OW 131
// end ; end ;
30768: GO 30433
30770: POP
30771: POP
// end ;
30772: GO 29989
30774: POP
30775: POP
// end ;
30776: LD_VAR 0 1
30780: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
30781: LD_INT 0
30783: PPUSH
30784: PPUSH
30785: PPUSH
30786: PPUSH
30787: PPUSH
30788: PPUSH
30789: PPUSH
30790: PPUSH
// if not mc_bases then
30791: LD_EXP 69
30795: NOT
30796: IFFALSE 30800
// exit ;
30798: GO 31426
// for i = 1 to mc_bases do
30800: LD_ADDR_VAR 0 2
30804: PUSH
30805: DOUBLE
30806: LD_INT 1
30808: DEC
30809: ST_TO_ADDR
30810: LD_EXP 69
30814: PUSH
30815: FOR_TO
30816: IFFALSE 31424
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
30818: LD_EXP 98
30822: PUSH
30823: LD_VAR 0 2
30827: ARRAY
30828: NOT
30829: PUSH
30830: LD_EXP 98
30834: PUSH
30835: LD_VAR 0 2
30839: ARRAY
30840: PPUSH
30841: LD_INT 25
30843: PUSH
30844: LD_INT 12
30846: PUSH
30847: EMPTY
30848: LIST
30849: LIST
30850: PPUSH
30851: CALL_OW 72
30855: NOT
30856: OR
30857: IFFALSE 30861
// continue ;
30859: GO 30815
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
30861: LD_ADDR_VAR 0 5
30865: PUSH
30866: LD_EXP 98
30870: PUSH
30871: LD_VAR 0 2
30875: ARRAY
30876: PUSH
30877: LD_INT 1
30879: ARRAY
30880: PPUSH
30881: CALL_OW 255
30885: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
30886: LD_VAR 0 5
30890: PPUSH
30891: LD_INT 2
30893: PPUSH
30894: CALL_OW 325
30898: IFFALSE 31151
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
30900: LD_ADDR_VAR 0 4
30904: PUSH
30905: LD_EXP 98
30909: PUSH
30910: LD_VAR 0 2
30914: ARRAY
30915: PPUSH
30916: LD_INT 25
30918: PUSH
30919: LD_INT 16
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PPUSH
30926: CALL_OW 72
30930: ST_TO_ADDR
// if tmp < 6 then
30931: LD_VAR 0 4
30935: PUSH
30936: LD_INT 6
30938: LESS
30939: IFFALSE 31151
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30941: LD_ADDR_VAR 0 6
30945: PUSH
30946: LD_EXP 69
30950: PUSH
30951: LD_VAR 0 2
30955: ARRAY
30956: PPUSH
30957: LD_INT 2
30959: PUSH
30960: LD_INT 30
30962: PUSH
30963: LD_INT 0
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 30
30972: PUSH
30973: LD_INT 1
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: LIST
30984: PPUSH
30985: CALL_OW 72
30989: ST_TO_ADDR
// if depot then
30990: LD_VAR 0 6
30994: IFFALSE 31151
// begin selected := 0 ;
30996: LD_ADDR_VAR 0 7
31000: PUSH
31001: LD_INT 0
31003: ST_TO_ADDR
// for j in depot do
31004: LD_ADDR_VAR 0 3
31008: PUSH
31009: LD_VAR 0 6
31013: PUSH
31014: FOR_IN
31015: IFFALSE 31046
// begin if UnitsInside ( j ) < 6 then
31017: LD_VAR 0 3
31021: PPUSH
31022: CALL_OW 313
31026: PUSH
31027: LD_INT 6
31029: LESS
31030: IFFALSE 31044
// begin selected := j ;
31032: LD_ADDR_VAR 0 7
31036: PUSH
31037: LD_VAR 0 3
31041: ST_TO_ADDR
// break ;
31042: GO 31046
// end ; end ;
31044: GO 31014
31046: POP
31047: POP
// if selected then
31048: LD_VAR 0 7
31052: IFFALSE 31151
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
31054: LD_ADDR_VAR 0 3
31058: PUSH
31059: LD_EXP 98
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PPUSH
31070: LD_INT 25
31072: PUSH
31073: LD_INT 12
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PPUSH
31080: CALL_OW 72
31084: PUSH
31085: FOR_IN
31086: IFFALSE 31149
// if not HasTask ( j ) then
31088: LD_VAR 0 3
31092: PPUSH
31093: CALL_OW 314
31097: NOT
31098: IFFALSE 31147
// begin if not IsInUnit ( j ) then
31100: LD_VAR 0 3
31104: PPUSH
31105: CALL_OW 310
31109: NOT
31110: IFFALSE 31126
// ComEnterUnit ( j , selected ) ;
31112: LD_VAR 0 3
31116: PPUSH
31117: LD_VAR 0 7
31121: PPUSH
31122: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
31126: LD_VAR 0 3
31130: PPUSH
31131: LD_INT 16
31133: PPUSH
31134: CALL_OW 183
// AddComExitBuilding ( j ) ;
31138: LD_VAR 0 3
31142: PPUSH
31143: CALL_OW 182
// end ;
31147: GO 31085
31149: POP
31150: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
31151: LD_VAR 0 5
31155: PPUSH
31156: LD_INT 11
31158: PPUSH
31159: CALL_OW 325
31163: IFFALSE 31422
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
31165: LD_ADDR_VAR 0 4
31169: PUSH
31170: LD_EXP 98
31174: PUSH
31175: LD_VAR 0 2
31179: ARRAY
31180: PPUSH
31181: LD_INT 25
31183: PUSH
31184: LD_INT 16
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PPUSH
31191: CALL_OW 72
31195: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
31196: LD_VAR 0 4
31200: PUSH
31201: LD_INT 6
31203: GREATEREQUAL
31204: PUSH
31205: LD_VAR 0 5
31209: PPUSH
31210: LD_INT 2
31212: PPUSH
31213: CALL_OW 325
31217: NOT
31218: OR
31219: IFFALSE 31422
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
31221: LD_ADDR_VAR 0 8
31225: PUSH
31226: LD_EXP 69
31230: PUSH
31231: LD_VAR 0 2
31235: ARRAY
31236: PPUSH
31237: LD_INT 2
31239: PUSH
31240: LD_INT 30
31242: PUSH
31243: LD_INT 4
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 30
31252: PUSH
31253: LD_INT 5
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: LIST
31264: PPUSH
31265: CALL_OW 72
31269: ST_TO_ADDR
// if barracks then
31270: LD_VAR 0 8
31274: IFFALSE 31422
// begin selected := 0 ;
31276: LD_ADDR_VAR 0 7
31280: PUSH
31281: LD_INT 0
31283: ST_TO_ADDR
// for j in barracks do
31284: LD_ADDR_VAR 0 3
31288: PUSH
31289: LD_VAR 0 8
31293: PUSH
31294: FOR_IN
31295: IFFALSE 31326
// begin if UnitsInside ( j ) < 6 then
31297: LD_VAR 0 3
31301: PPUSH
31302: CALL_OW 313
31306: PUSH
31307: LD_INT 6
31309: LESS
31310: IFFALSE 31324
// begin selected := j ;
31312: LD_ADDR_VAR 0 7
31316: PUSH
31317: LD_VAR 0 3
31321: ST_TO_ADDR
// break ;
31322: GO 31326
// end ; end ;
31324: GO 31294
31326: POP
31327: POP
// if selected then
31328: LD_VAR 0 7
31332: IFFALSE 31422
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
31334: LD_ADDR_VAR 0 3
31338: PUSH
31339: LD_EXP 98
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: PPUSH
31350: LD_INT 25
31352: PUSH
31353: LD_INT 12
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PPUSH
31360: CALL_OW 72
31364: PUSH
31365: FOR_IN
31366: IFFALSE 31420
// if not IsInUnit ( j ) and not HasTask ( j ) then
31368: LD_VAR 0 3
31372: PPUSH
31373: CALL_OW 310
31377: NOT
31378: PUSH
31379: LD_VAR 0 3
31383: PPUSH
31384: CALL_OW 314
31388: NOT
31389: AND
31390: IFFALSE 31418
// begin ComEnterUnit ( j , selected ) ;
31392: LD_VAR 0 3
31396: PPUSH
31397: LD_VAR 0 7
31401: PPUSH
31402: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
31406: LD_VAR 0 3
31410: PPUSH
31411: LD_INT 15
31413: PPUSH
31414: CALL_OW 183
// end ;
31418: GO 31365
31420: POP
31421: POP
// end ; end ; end ; end ; end ;
31422: GO 30815
31424: POP
31425: POP
// end ;
31426: LD_VAR 0 1
31430: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
31431: LD_INT 0
31433: PPUSH
31434: PPUSH
31435: PPUSH
31436: PPUSH
// if not mc_bases then
31437: LD_EXP 69
31441: NOT
31442: IFFALSE 31446
// exit ;
31444: GO 31624
// for i = 1 to mc_bases do
31446: LD_ADDR_VAR 0 2
31450: PUSH
31451: DOUBLE
31452: LD_INT 1
31454: DEC
31455: ST_TO_ADDR
31456: LD_EXP 69
31460: PUSH
31461: FOR_TO
31462: IFFALSE 31622
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
31464: LD_ADDR_VAR 0 4
31468: PUSH
31469: LD_EXP 69
31473: PUSH
31474: LD_VAR 0 2
31478: ARRAY
31479: PPUSH
31480: LD_INT 25
31482: PUSH
31483: LD_INT 9
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PPUSH
31490: CALL_OW 72
31494: ST_TO_ADDR
// if not tmp then
31495: LD_VAR 0 4
31499: NOT
31500: IFFALSE 31504
// continue ;
31502: GO 31461
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
31504: LD_EXP 95
31508: PUSH
31509: LD_VAR 0 2
31513: ARRAY
31514: PPUSH
31515: LD_INT 29
31517: PPUSH
31518: CALL_OW 325
31522: NOT
31523: PUSH
31524: LD_EXP 95
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: PPUSH
31535: LD_INT 28
31537: PPUSH
31538: CALL_OW 325
31542: NOT
31543: AND
31544: IFFALSE 31548
// continue ;
31546: GO 31461
// for j in tmp do
31548: LD_ADDR_VAR 0 3
31552: PUSH
31553: LD_VAR 0 4
31557: PUSH
31558: FOR_IN
31559: IFFALSE 31618
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
31561: LD_VAR 0 3
31565: PUSH
31566: LD_EXP 72
31570: PUSH
31571: LD_VAR 0 2
31575: ARRAY
31576: PUSH
31577: LD_INT 1
31579: ARRAY
31580: IN
31581: NOT
31582: PUSH
31583: LD_VAR 0 3
31587: PUSH
31588: LD_EXP 72
31592: PUSH
31593: LD_VAR 0 2
31597: ARRAY
31598: PUSH
31599: LD_INT 2
31601: ARRAY
31602: IN
31603: NOT
31604: AND
31605: IFFALSE 31616
// ComSpaceTimeShoot ( j ) ;
31607: LD_VAR 0 3
31611: PPUSH
31612: CALL 41798 0 1
31616: GO 31558
31618: POP
31619: POP
// end ;
31620: GO 31461
31622: POP
31623: POP
// end ;
31624: LD_VAR 0 1
31628: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
31629: LD_INT 0
31631: PPUSH
31632: PPUSH
31633: PPUSH
31634: PPUSH
31635: PPUSH
31636: PPUSH
31637: PPUSH
31638: PPUSH
31639: PPUSH
// if not mc_bases then
31640: LD_EXP 69
31644: NOT
31645: IFFALSE 31649
// exit ;
31647: GO 32271
// for i = 1 to mc_bases do
31649: LD_ADDR_VAR 0 2
31653: PUSH
31654: DOUBLE
31655: LD_INT 1
31657: DEC
31658: ST_TO_ADDR
31659: LD_EXP 69
31663: PUSH
31664: FOR_TO
31665: IFFALSE 32269
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
31667: LD_EXP 104
31671: PUSH
31672: LD_VAR 0 2
31676: ARRAY
31677: NOT
31678: PUSH
31679: LD_INT 38
31681: PPUSH
31682: LD_EXP 95
31686: PUSH
31687: LD_VAR 0 2
31691: ARRAY
31692: PPUSH
31693: CALL_OW 321
31697: PUSH
31698: LD_INT 2
31700: NONEQUAL
31701: OR
31702: IFFALSE 31706
// continue ;
31704: GO 31664
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
31706: LD_ADDR_VAR 0 8
31710: PUSH
31711: LD_EXP 69
31715: PUSH
31716: LD_VAR 0 2
31720: ARRAY
31721: PPUSH
31722: LD_INT 30
31724: PUSH
31725: LD_INT 34
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PPUSH
31732: CALL_OW 72
31736: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
31737: LD_ADDR_VAR 0 9
31741: PUSH
31742: LD_EXP 69
31746: PUSH
31747: LD_VAR 0 2
31751: ARRAY
31752: PPUSH
31753: LD_INT 25
31755: PUSH
31756: LD_INT 4
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PPUSH
31763: CALL_OW 72
31767: PPUSH
31768: LD_INT 0
31770: PPUSH
31771: CALL 80935 0 2
31775: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
31776: LD_VAR 0 9
31780: NOT
31781: PUSH
31782: LD_VAR 0 8
31786: NOT
31787: OR
31788: PUSH
31789: LD_EXP 69
31793: PUSH
31794: LD_VAR 0 2
31798: ARRAY
31799: PPUSH
31800: LD_INT 124
31802: PPUSH
31803: CALL 80935 0 2
31807: OR
31808: IFFALSE 31812
// continue ;
31810: GO 31664
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
31812: LD_EXP 105
31816: PUSH
31817: LD_VAR 0 2
31821: ARRAY
31822: PUSH
31823: LD_EXP 104
31827: PUSH
31828: LD_VAR 0 2
31832: ARRAY
31833: LESS
31834: PUSH
31835: LD_EXP 105
31839: PUSH
31840: LD_VAR 0 2
31844: ARRAY
31845: PUSH
31846: LD_VAR 0 8
31850: LESS
31851: AND
31852: IFFALSE 32267
// begin tmp := sci [ 1 ] ;
31854: LD_ADDR_VAR 0 7
31858: PUSH
31859: LD_VAR 0 9
31863: PUSH
31864: LD_INT 1
31866: ARRAY
31867: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
31868: LD_VAR 0 7
31872: PPUSH
31873: LD_INT 124
31875: PPUSH
31876: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
31880: LD_ADDR_VAR 0 3
31884: PUSH
31885: DOUBLE
31886: LD_EXP 104
31890: PUSH
31891: LD_VAR 0 2
31895: ARRAY
31896: INC
31897: ST_TO_ADDR
31898: LD_EXP 104
31902: PUSH
31903: LD_VAR 0 2
31907: ARRAY
31908: PUSH
31909: FOR_DOWNTO
31910: IFFALSE 32253
// begin if IsInUnit ( tmp ) then
31912: LD_VAR 0 7
31916: PPUSH
31917: CALL_OW 310
31921: IFFALSE 31932
// ComExitBuilding ( tmp ) ;
31923: LD_VAR 0 7
31927: PPUSH
31928: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
31932: LD_INT 35
31934: PPUSH
31935: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
31939: LD_VAR 0 7
31943: PPUSH
31944: CALL_OW 310
31948: NOT
31949: PUSH
31950: LD_VAR 0 7
31954: PPUSH
31955: CALL_OW 314
31959: NOT
31960: AND
31961: IFFALSE 31932
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
31963: LD_ADDR_VAR 0 6
31967: PUSH
31968: LD_VAR 0 7
31972: PPUSH
31973: CALL_OW 250
31977: PUSH
31978: LD_VAR 0 7
31982: PPUSH
31983: CALL_OW 251
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31992: LD_INT 35
31994: PPUSH
31995: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
31999: LD_ADDR_VAR 0 4
32003: PUSH
32004: LD_EXP 104
32008: PUSH
32009: LD_VAR 0 2
32013: ARRAY
32014: PUSH
32015: LD_VAR 0 3
32019: ARRAY
32020: PUSH
32021: LD_INT 1
32023: ARRAY
32024: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
32025: LD_ADDR_VAR 0 5
32029: PUSH
32030: LD_EXP 104
32034: PUSH
32035: LD_VAR 0 2
32039: ARRAY
32040: PUSH
32041: LD_VAR 0 3
32045: ARRAY
32046: PUSH
32047: LD_INT 2
32049: ARRAY
32050: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
32051: LD_VAR 0 7
32055: PPUSH
32056: LD_INT 10
32058: PPUSH
32059: CALL 50331 0 2
32063: PUSH
32064: LD_INT 4
32066: ARRAY
32067: IFFALSE 32105
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
32069: LD_VAR 0 7
32073: PPUSH
32074: LD_VAR 0 6
32078: PUSH
32079: LD_INT 1
32081: ARRAY
32082: PPUSH
32083: LD_VAR 0 6
32087: PUSH
32088: LD_INT 2
32090: ARRAY
32091: PPUSH
32092: CALL_OW 111
// wait ( 0 0$10 ) ;
32096: LD_INT 350
32098: PPUSH
32099: CALL_OW 67
// end else
32103: GO 32131
// begin ComMoveXY ( tmp , x , y ) ;
32105: LD_VAR 0 7
32109: PPUSH
32110: LD_VAR 0 4
32114: PPUSH
32115: LD_VAR 0 5
32119: PPUSH
32120: CALL_OW 111
// wait ( 0 0$3 ) ;
32124: LD_INT 105
32126: PPUSH
32127: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
32131: LD_VAR 0 7
32135: PPUSH
32136: LD_VAR 0 4
32140: PPUSH
32141: LD_VAR 0 5
32145: PPUSH
32146: CALL_OW 307
32150: IFFALSE 31992
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
32152: LD_VAR 0 7
32156: PPUSH
32157: LD_VAR 0 4
32161: PPUSH
32162: LD_VAR 0 5
32166: PPUSH
32167: LD_VAR 0 8
32171: PUSH
32172: LD_VAR 0 3
32176: ARRAY
32177: PPUSH
32178: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
32182: LD_INT 35
32184: PPUSH
32185: CALL_OW 67
// until not HasTask ( tmp ) ;
32189: LD_VAR 0 7
32193: PPUSH
32194: CALL_OW 314
32198: NOT
32199: IFFALSE 32182
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
32201: LD_ADDR_EXP 105
32205: PUSH
32206: LD_EXP 105
32210: PPUSH
32211: LD_VAR 0 2
32215: PUSH
32216: LD_EXP 105
32220: PUSH
32221: LD_VAR 0 2
32225: ARRAY
32226: PUSH
32227: LD_INT 1
32229: PLUS
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PPUSH
32235: LD_VAR 0 8
32239: PUSH
32240: LD_VAR 0 3
32244: ARRAY
32245: PPUSH
32246: CALL 47738 0 3
32250: ST_TO_ADDR
// end ;
32251: GO 31909
32253: POP
32254: POP
// MC_Reset ( i , 124 ) ;
32255: LD_VAR 0 2
32259: PPUSH
32260: LD_INT 124
32262: PPUSH
32263: CALL 16381 0 2
// end ; end ;
32267: GO 31664
32269: POP
32270: POP
// end ;
32271: LD_VAR 0 1
32275: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
32276: LD_INT 0
32278: PPUSH
32279: PPUSH
32280: PPUSH
// if not mc_bases then
32281: LD_EXP 69
32285: NOT
32286: IFFALSE 32290
// exit ;
32288: GO 32896
// for i = 1 to mc_bases do
32290: LD_ADDR_VAR 0 2
32294: PUSH
32295: DOUBLE
32296: LD_INT 1
32298: DEC
32299: ST_TO_ADDR
32300: LD_EXP 69
32304: PUSH
32305: FOR_TO
32306: IFFALSE 32894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32308: LD_ADDR_VAR 0 3
32312: PUSH
32313: LD_EXP 69
32317: PUSH
32318: LD_VAR 0 2
32322: ARRAY
32323: PPUSH
32324: LD_INT 25
32326: PUSH
32327: LD_INT 4
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PPUSH
32334: CALL_OW 72
32338: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
32339: LD_VAR 0 3
32343: NOT
32344: PUSH
32345: LD_EXP 106
32349: PUSH
32350: LD_VAR 0 2
32354: ARRAY
32355: NOT
32356: OR
32357: PUSH
32358: LD_EXP 69
32362: PUSH
32363: LD_VAR 0 2
32367: ARRAY
32368: PPUSH
32369: LD_INT 2
32371: PUSH
32372: LD_INT 30
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 30
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: LIST
32396: PPUSH
32397: CALL_OW 72
32401: NOT
32402: OR
32403: IFFALSE 32453
// begin if mc_deposits_finder [ i ] then
32405: LD_EXP 107
32409: PUSH
32410: LD_VAR 0 2
32414: ARRAY
32415: IFFALSE 32451
// begin MC_Reset ( i , 125 ) ;
32417: LD_VAR 0 2
32421: PPUSH
32422: LD_INT 125
32424: PPUSH
32425: CALL 16381 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
32429: LD_ADDR_EXP 107
32433: PUSH
32434: LD_EXP 107
32438: PPUSH
32439: LD_VAR 0 2
32443: PPUSH
32444: EMPTY
32445: PPUSH
32446: CALL_OW 1
32450: ST_TO_ADDR
// end ; continue ;
32451: GO 32305
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
32453: LD_EXP 106
32457: PUSH
32458: LD_VAR 0 2
32462: ARRAY
32463: PUSH
32464: LD_INT 1
32466: ARRAY
32467: PUSH
32468: LD_INT 3
32470: ARRAY
32471: PUSH
32472: LD_INT 1
32474: EQUAL
32475: PUSH
32476: LD_INT 20
32478: PPUSH
32479: LD_EXP 95
32483: PUSH
32484: LD_VAR 0 2
32488: ARRAY
32489: PPUSH
32490: CALL_OW 321
32494: PUSH
32495: LD_INT 2
32497: NONEQUAL
32498: AND
32499: IFFALSE 32549
// begin if mc_deposits_finder [ i ] then
32501: LD_EXP 107
32505: PUSH
32506: LD_VAR 0 2
32510: ARRAY
32511: IFFALSE 32547
// begin MC_Reset ( i , 125 ) ;
32513: LD_VAR 0 2
32517: PPUSH
32518: LD_INT 125
32520: PPUSH
32521: CALL 16381 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
32525: LD_ADDR_EXP 107
32529: PUSH
32530: LD_EXP 107
32534: PPUSH
32535: LD_VAR 0 2
32539: PPUSH
32540: EMPTY
32541: PPUSH
32542: CALL_OW 1
32546: ST_TO_ADDR
// end ; continue ;
32547: GO 32305
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
32549: LD_EXP 106
32553: PUSH
32554: LD_VAR 0 2
32558: ARRAY
32559: PUSH
32560: LD_INT 1
32562: ARRAY
32563: PUSH
32564: LD_INT 1
32566: ARRAY
32567: PPUSH
32568: LD_EXP 106
32572: PUSH
32573: LD_VAR 0 2
32577: ARRAY
32578: PUSH
32579: LD_INT 1
32581: ARRAY
32582: PUSH
32583: LD_INT 2
32585: ARRAY
32586: PPUSH
32587: LD_EXP 95
32591: PUSH
32592: LD_VAR 0 2
32596: ARRAY
32597: PPUSH
32598: CALL_OW 440
32602: IFFALSE 32645
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
32604: LD_ADDR_EXP 106
32608: PUSH
32609: LD_EXP 106
32613: PPUSH
32614: LD_VAR 0 2
32618: PPUSH
32619: LD_EXP 106
32623: PUSH
32624: LD_VAR 0 2
32628: ARRAY
32629: PPUSH
32630: LD_INT 1
32632: PPUSH
32633: CALL_OW 3
32637: PPUSH
32638: CALL_OW 1
32642: ST_TO_ADDR
32643: GO 32892
// begin if not mc_deposits_finder [ i ] then
32645: LD_EXP 107
32649: PUSH
32650: LD_VAR 0 2
32654: ARRAY
32655: NOT
32656: IFFALSE 32708
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
32658: LD_ADDR_EXP 107
32662: PUSH
32663: LD_EXP 107
32667: PPUSH
32668: LD_VAR 0 2
32672: PPUSH
32673: LD_VAR 0 3
32677: PUSH
32678: LD_INT 1
32680: ARRAY
32681: PUSH
32682: EMPTY
32683: LIST
32684: PPUSH
32685: CALL_OW 1
32689: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
32690: LD_VAR 0 3
32694: PUSH
32695: LD_INT 1
32697: ARRAY
32698: PPUSH
32699: LD_INT 125
32701: PPUSH
32702: CALL_OW 109
// end else
32706: GO 32892
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
32708: LD_EXP 107
32712: PUSH
32713: LD_VAR 0 2
32717: ARRAY
32718: PUSH
32719: LD_INT 1
32721: ARRAY
32722: PPUSH
32723: CALL_OW 310
32727: IFFALSE 32750
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
32729: LD_EXP 107
32733: PUSH
32734: LD_VAR 0 2
32738: ARRAY
32739: PUSH
32740: LD_INT 1
32742: ARRAY
32743: PPUSH
32744: CALL_OW 122
32748: GO 32892
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
32750: LD_EXP 107
32754: PUSH
32755: LD_VAR 0 2
32759: ARRAY
32760: PUSH
32761: LD_INT 1
32763: ARRAY
32764: PPUSH
32765: CALL_OW 314
32769: NOT
32770: PUSH
32771: LD_EXP 107
32775: PUSH
32776: LD_VAR 0 2
32780: ARRAY
32781: PUSH
32782: LD_INT 1
32784: ARRAY
32785: PPUSH
32786: LD_EXP 106
32790: PUSH
32791: LD_VAR 0 2
32795: ARRAY
32796: PUSH
32797: LD_INT 1
32799: ARRAY
32800: PUSH
32801: LD_INT 1
32803: ARRAY
32804: PPUSH
32805: LD_EXP 106
32809: PUSH
32810: LD_VAR 0 2
32814: ARRAY
32815: PUSH
32816: LD_INT 1
32818: ARRAY
32819: PUSH
32820: LD_INT 2
32822: ARRAY
32823: PPUSH
32824: CALL_OW 297
32828: PUSH
32829: LD_INT 6
32831: GREATER
32832: AND
32833: IFFALSE 32892
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
32835: LD_EXP 107
32839: PUSH
32840: LD_VAR 0 2
32844: ARRAY
32845: PUSH
32846: LD_INT 1
32848: ARRAY
32849: PPUSH
32850: LD_EXP 106
32854: PUSH
32855: LD_VAR 0 2
32859: ARRAY
32860: PUSH
32861: LD_INT 1
32863: ARRAY
32864: PUSH
32865: LD_INT 1
32867: ARRAY
32868: PPUSH
32869: LD_EXP 106
32873: PUSH
32874: LD_VAR 0 2
32878: ARRAY
32879: PUSH
32880: LD_INT 1
32882: ARRAY
32883: PUSH
32884: LD_INT 2
32886: ARRAY
32887: PPUSH
32888: CALL_OW 111
// end ; end ; end ;
32892: GO 32305
32894: POP
32895: POP
// end ;
32896: LD_VAR 0 1
32900: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
32901: LD_INT 0
32903: PPUSH
32904: PPUSH
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
32910: PPUSH
32911: PPUSH
32912: PPUSH
32913: PPUSH
// if not mc_bases then
32914: LD_EXP 69
32918: NOT
32919: IFFALSE 32923
// exit ;
32921: GO 33647
// for i = 1 to mc_bases do
32923: LD_ADDR_VAR 0 2
32927: PUSH
32928: DOUBLE
32929: LD_INT 1
32931: DEC
32932: ST_TO_ADDR
32933: LD_EXP 69
32937: PUSH
32938: FOR_TO
32939: IFFALSE 33645
// begin if not mc_bases [ i ] then
32941: LD_EXP 69
32945: PUSH
32946: LD_VAR 0 2
32950: ARRAY
32951: NOT
32952: IFFALSE 32956
// continue ;
32954: GO 32938
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
32956: LD_ADDR_VAR 0 7
32960: PUSH
32961: LD_EXP 69
32965: PUSH
32966: LD_VAR 0 2
32970: ARRAY
32971: PUSH
32972: LD_INT 1
32974: ARRAY
32975: PPUSH
32976: CALL_OW 248
32980: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
32981: LD_VAR 0 7
32985: PUSH
32986: LD_INT 3
32988: EQUAL
32989: PUSH
32990: LD_EXP 88
32994: PUSH
32995: LD_VAR 0 2
32999: ARRAY
33000: PUSH
33001: LD_EXP 91
33005: PUSH
33006: LD_VAR 0 2
33010: ARRAY
33011: UNION
33012: PPUSH
33013: LD_INT 33
33015: PUSH
33016: LD_INT 2
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PPUSH
33023: CALL_OW 72
33027: NOT
33028: OR
33029: IFFALSE 33033
// continue ;
33031: GO 32938
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
33033: LD_ADDR_VAR 0 9
33037: PUSH
33038: LD_EXP 69
33042: PUSH
33043: LD_VAR 0 2
33047: ARRAY
33048: PPUSH
33049: LD_INT 30
33051: PUSH
33052: LD_INT 36
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PPUSH
33059: CALL_OW 72
33063: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
33064: LD_ADDR_VAR 0 10
33068: PUSH
33069: LD_EXP 88
33073: PUSH
33074: LD_VAR 0 2
33078: ARRAY
33079: PPUSH
33080: LD_INT 34
33082: PUSH
33083: LD_INT 31
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PPUSH
33090: CALL_OW 72
33094: ST_TO_ADDR
// if not cts and not mcts then
33095: LD_VAR 0 9
33099: NOT
33100: PUSH
33101: LD_VAR 0 10
33105: NOT
33106: AND
33107: IFFALSE 33111
// continue ;
33109: GO 32938
// x := cts ;
33111: LD_ADDR_VAR 0 11
33115: PUSH
33116: LD_VAR 0 9
33120: ST_TO_ADDR
// if not x then
33121: LD_VAR 0 11
33125: NOT
33126: IFFALSE 33138
// x := mcts ;
33128: LD_ADDR_VAR 0 11
33132: PUSH
33133: LD_VAR 0 10
33137: ST_TO_ADDR
// if mc_remote_driver [ i ] then
33138: LD_EXP 109
33142: PUSH
33143: LD_VAR 0 2
33147: ARRAY
33148: IFFALSE 33417
// for j in mc_remote_driver [ i ] do
33150: LD_ADDR_VAR 0 3
33154: PUSH
33155: LD_EXP 109
33159: PUSH
33160: LD_VAR 0 2
33164: ARRAY
33165: PUSH
33166: FOR_IN
33167: IFFALSE 33415
// begin if GetClass ( j ) <> 3 then
33169: LD_VAR 0 3
33173: PPUSH
33174: CALL_OW 257
33178: PUSH
33179: LD_INT 3
33181: NONEQUAL
33182: IFFALSE 33235
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
33184: LD_ADDR_EXP 109
33188: PUSH
33189: LD_EXP 109
33193: PPUSH
33194: LD_VAR 0 2
33198: PPUSH
33199: LD_EXP 109
33203: PUSH
33204: LD_VAR 0 2
33208: ARRAY
33209: PUSH
33210: LD_VAR 0 3
33214: DIFF
33215: PPUSH
33216: CALL_OW 1
33220: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33221: LD_VAR 0 3
33225: PPUSH
33226: LD_INT 0
33228: PPUSH
33229: CALL_OW 109
// continue ;
33233: GO 33166
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
33235: LD_VAR 0 3
33239: PPUSH
33240: CALL_OW 310
33244: NOT
33245: PUSH
33246: LD_VAR 0 3
33250: PPUSH
33251: CALL_OW 310
33255: PPUSH
33256: CALL_OW 266
33260: PUSH
33261: LD_INT 36
33263: NONEQUAL
33264: PUSH
33265: LD_VAR 0 3
33269: PPUSH
33270: CALL 81023 0 1
33274: NOT
33275: AND
33276: OR
33277: IFFALSE 33413
// begin if IsInUnit ( j ) then
33279: LD_VAR 0 3
33283: PPUSH
33284: CALL_OW 310
33288: IFFALSE 33299
// ComExitBuilding ( j ) ;
33290: LD_VAR 0 3
33294: PPUSH
33295: CALL_OW 122
// ct := 0 ;
33299: LD_ADDR_VAR 0 8
33303: PUSH
33304: LD_INT 0
33306: ST_TO_ADDR
// for k in x do
33307: LD_ADDR_VAR 0 4
33311: PUSH
33312: LD_VAR 0 11
33316: PUSH
33317: FOR_IN
33318: IFFALSE 33391
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
33320: LD_VAR 0 4
33324: PPUSH
33325: CALL_OW 264
33329: PUSH
33330: LD_INT 31
33332: EQUAL
33333: PUSH
33334: LD_VAR 0 4
33338: PPUSH
33339: CALL_OW 311
33343: NOT
33344: AND
33345: PUSH
33346: LD_VAR 0 4
33350: PPUSH
33351: CALL_OW 266
33355: PUSH
33356: LD_INT 36
33358: EQUAL
33359: PUSH
33360: LD_VAR 0 4
33364: PPUSH
33365: CALL_OW 313
33369: PUSH
33370: LD_INT 3
33372: LESS
33373: AND
33374: OR
33375: IFFALSE 33389
// begin ct := k ;
33377: LD_ADDR_VAR 0 8
33381: PUSH
33382: LD_VAR 0 4
33386: ST_TO_ADDR
// break ;
33387: GO 33391
// end ;
33389: GO 33317
33391: POP
33392: POP
// if ct then
33393: LD_VAR 0 8
33397: IFFALSE 33413
// ComEnterUnit ( j , ct ) ;
33399: LD_VAR 0 3
33403: PPUSH
33404: LD_VAR 0 8
33408: PPUSH
33409: CALL_OW 120
// end ; end ;
33413: GO 33166
33415: POP
33416: POP
// places := 0 ;
33417: LD_ADDR_VAR 0 5
33421: PUSH
33422: LD_INT 0
33424: ST_TO_ADDR
// for j = 1 to x do
33425: LD_ADDR_VAR 0 3
33429: PUSH
33430: DOUBLE
33431: LD_INT 1
33433: DEC
33434: ST_TO_ADDR
33435: LD_VAR 0 11
33439: PUSH
33440: FOR_TO
33441: IFFALSE 33496
// if GetWeapon ( x [ j ] ) = ar_control_tower then
33443: LD_VAR 0 11
33447: PUSH
33448: LD_VAR 0 3
33452: ARRAY
33453: PPUSH
33454: CALL_OW 264
33458: PUSH
33459: LD_INT 31
33461: EQUAL
33462: IFFALSE 33480
// places := places + 1 else
33464: LD_ADDR_VAR 0 5
33468: PUSH
33469: LD_VAR 0 5
33473: PUSH
33474: LD_INT 1
33476: PLUS
33477: ST_TO_ADDR
33478: GO 33494
// places := places + 3 ;
33480: LD_ADDR_VAR 0 5
33484: PUSH
33485: LD_VAR 0 5
33489: PUSH
33490: LD_INT 3
33492: PLUS
33493: ST_TO_ADDR
33494: GO 33440
33496: POP
33497: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
33498: LD_ADDR_VAR 0 6
33502: PUSH
33503: LD_EXP 69
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: PPUSH
33514: LD_INT 25
33516: PUSH
33517: LD_INT 3
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PPUSH
33524: CALL_OW 72
33528: PUSH
33529: LD_EXP 109
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: DIFF
33540: PPUSH
33541: LD_INT 3
33543: PPUSH
33544: CALL 81923 0 2
33548: ST_TO_ADDR
// if not tmp then
33549: LD_VAR 0 6
33553: NOT
33554: IFFALSE 33558
// continue ;
33556: GO 32938
// places := places - mc_remote_driver [ i ] ;
33558: LD_ADDR_VAR 0 5
33562: PUSH
33563: LD_VAR 0 5
33567: PUSH
33568: LD_EXP 109
33572: PUSH
33573: LD_VAR 0 2
33577: ARRAY
33578: MINUS
33579: ST_TO_ADDR
// if places then
33580: LD_VAR 0 5
33584: IFFALSE 33643
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
33586: LD_ADDR_EXP 109
33590: PUSH
33591: LD_EXP 109
33595: PPUSH
33596: LD_VAR 0 2
33600: PPUSH
33601: LD_EXP 109
33605: PUSH
33606: LD_VAR 0 2
33610: ARRAY
33611: PUSH
33612: LD_VAR 0 6
33616: PUSH
33617: LD_INT 1
33619: ARRAY
33620: UNION
33621: PPUSH
33622: CALL_OW 1
33626: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
33627: LD_VAR 0 6
33631: PUSH
33632: LD_INT 1
33634: ARRAY
33635: PPUSH
33636: LD_INT 126
33638: PPUSH
33639: CALL_OW 109
// end ; end ;
33643: GO 32938
33645: POP
33646: POP
// end ;
33647: LD_VAR 0 1
33651: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
33652: LD_INT 0
33654: PPUSH
33655: PPUSH
33656: PPUSH
33657: PPUSH
33658: PPUSH
33659: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
33660: LD_VAR 0 1
33664: NOT
33665: PUSH
33666: LD_VAR 0 2
33670: NOT
33671: OR
33672: PUSH
33673: LD_VAR 0 3
33677: NOT
33678: OR
33679: PUSH
33680: LD_VAR 0 4
33684: PUSH
33685: LD_INT 1
33687: PUSH
33688: LD_INT 2
33690: PUSH
33691: LD_INT 3
33693: PUSH
33694: LD_INT 4
33696: PUSH
33697: LD_INT 5
33699: PUSH
33700: LD_INT 8
33702: PUSH
33703: LD_INT 9
33705: PUSH
33706: LD_INT 15
33708: PUSH
33709: LD_INT 16
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: IN
33723: NOT
33724: OR
33725: IFFALSE 33729
// exit ;
33727: GO 34629
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
33729: LD_ADDR_VAR 0 2
33733: PUSH
33734: LD_VAR 0 2
33738: PPUSH
33739: LD_INT 21
33741: PUSH
33742: LD_INT 3
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 24
33751: PUSH
33752: LD_INT 250
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PPUSH
33763: CALL_OW 72
33767: ST_TO_ADDR
// case class of 1 , 15 :
33768: LD_VAR 0 4
33772: PUSH
33773: LD_INT 1
33775: DOUBLE
33776: EQUAL
33777: IFTRUE 33787
33779: LD_INT 15
33781: DOUBLE
33782: EQUAL
33783: IFTRUE 33787
33785: GO 33872
33787: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
33788: LD_ADDR_VAR 0 8
33792: PUSH
33793: LD_VAR 0 2
33797: PPUSH
33798: LD_INT 2
33800: PUSH
33801: LD_INT 30
33803: PUSH
33804: LD_INT 32
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 30
33813: PUSH
33814: LD_INT 31
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: LIST
33825: PPUSH
33826: CALL_OW 72
33830: PUSH
33831: LD_VAR 0 2
33835: PPUSH
33836: LD_INT 2
33838: PUSH
33839: LD_INT 30
33841: PUSH
33842: LD_INT 4
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 30
33851: PUSH
33852: LD_INT 5
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: LIST
33863: PPUSH
33864: CALL_OW 72
33868: ADD
33869: ST_TO_ADDR
33870: GO 34118
33872: LD_INT 2
33874: DOUBLE
33875: EQUAL
33876: IFTRUE 33886
33878: LD_INT 16
33880: DOUBLE
33881: EQUAL
33882: IFTRUE 33886
33884: GO 33932
33886: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
33887: LD_ADDR_VAR 0 8
33891: PUSH
33892: LD_VAR 0 2
33896: PPUSH
33897: LD_INT 2
33899: PUSH
33900: LD_INT 30
33902: PUSH
33903: LD_INT 0
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 30
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: LIST
33924: PPUSH
33925: CALL_OW 72
33929: ST_TO_ADDR
33930: GO 34118
33932: LD_INT 3
33934: DOUBLE
33935: EQUAL
33936: IFTRUE 33940
33938: GO 33986
33940: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
33941: LD_ADDR_VAR 0 8
33945: PUSH
33946: LD_VAR 0 2
33950: PPUSH
33951: LD_INT 2
33953: PUSH
33954: LD_INT 30
33956: PUSH
33957: LD_INT 2
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PUSH
33964: LD_INT 30
33966: PUSH
33967: LD_INT 3
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: LIST
33978: PPUSH
33979: CALL_OW 72
33983: ST_TO_ADDR
33984: GO 34118
33986: LD_INT 4
33988: DOUBLE
33989: EQUAL
33990: IFTRUE 33994
33992: GO 34051
33994: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
33995: LD_ADDR_VAR 0 8
33999: PUSH
34000: LD_VAR 0 2
34004: PPUSH
34005: LD_INT 2
34007: PUSH
34008: LD_INT 30
34010: PUSH
34011: LD_INT 6
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 30
34020: PUSH
34021: LD_INT 7
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: PUSH
34028: LD_INT 30
34030: PUSH
34031: LD_INT 8
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: PPUSH
34044: CALL_OW 72
34048: ST_TO_ADDR
34049: GO 34118
34051: LD_INT 5
34053: DOUBLE
34054: EQUAL
34055: IFTRUE 34071
34057: LD_INT 8
34059: DOUBLE
34060: EQUAL
34061: IFTRUE 34071
34063: LD_INT 9
34065: DOUBLE
34066: EQUAL
34067: IFTRUE 34071
34069: GO 34117
34071: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
34072: LD_ADDR_VAR 0 8
34076: PUSH
34077: LD_VAR 0 2
34081: PPUSH
34082: LD_INT 2
34084: PUSH
34085: LD_INT 30
34087: PUSH
34088: LD_INT 4
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 30
34097: PUSH
34098: LD_INT 5
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: LIST
34109: PPUSH
34110: CALL_OW 72
34114: ST_TO_ADDR
34115: GO 34118
34117: POP
// if not tmp then
34118: LD_VAR 0 8
34122: NOT
34123: IFFALSE 34127
// exit ;
34125: GO 34629
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
34127: LD_VAR 0 4
34131: PUSH
34132: LD_INT 1
34134: PUSH
34135: LD_INT 15
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: IN
34142: PUSH
34143: LD_EXP 78
34147: PUSH
34148: LD_VAR 0 1
34152: ARRAY
34153: AND
34154: IFFALSE 34310
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
34156: LD_ADDR_VAR 0 9
34160: PUSH
34161: LD_EXP 78
34165: PUSH
34166: LD_VAR 0 1
34170: ARRAY
34171: PUSH
34172: LD_INT 1
34174: ARRAY
34175: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
34176: LD_VAR 0 9
34180: PUSH
34181: LD_EXP 79
34185: PUSH
34186: LD_VAR 0 1
34190: ARRAY
34191: IN
34192: NOT
34193: IFFALSE 34308
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
34195: LD_ADDR_EXP 79
34199: PUSH
34200: LD_EXP 79
34204: PPUSH
34205: LD_VAR 0 1
34209: PUSH
34210: LD_EXP 79
34214: PUSH
34215: LD_VAR 0 1
34219: ARRAY
34220: PUSH
34221: LD_INT 1
34223: PLUS
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PPUSH
34229: LD_VAR 0 9
34233: PPUSH
34234: CALL 47738 0 3
34238: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
34239: LD_ADDR_EXP 78
34243: PUSH
34244: LD_EXP 78
34248: PPUSH
34249: LD_VAR 0 1
34253: PPUSH
34254: LD_EXP 78
34258: PUSH
34259: LD_VAR 0 1
34263: ARRAY
34264: PUSH
34265: LD_VAR 0 9
34269: DIFF
34270: PPUSH
34271: CALL_OW 1
34275: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
34276: LD_VAR 0 3
34280: PPUSH
34281: LD_EXP 79
34285: PUSH
34286: LD_VAR 0 1
34290: ARRAY
34291: PUSH
34292: LD_EXP 79
34296: PUSH
34297: LD_VAR 0 1
34301: ARRAY
34302: ARRAY
34303: PPUSH
34304: CALL_OW 120
// end ; exit ;
34308: GO 34629
// end ; if tmp > 1 then
34310: LD_VAR 0 8
34314: PUSH
34315: LD_INT 1
34317: GREATER
34318: IFFALSE 34422
// for i = 2 to tmp do
34320: LD_ADDR_VAR 0 6
34324: PUSH
34325: DOUBLE
34326: LD_INT 2
34328: DEC
34329: ST_TO_ADDR
34330: LD_VAR 0 8
34334: PUSH
34335: FOR_TO
34336: IFFALSE 34420
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
34338: LD_VAR 0 8
34342: PUSH
34343: LD_VAR 0 6
34347: ARRAY
34348: PPUSH
34349: CALL_OW 461
34353: PUSH
34354: LD_INT 6
34356: EQUAL
34357: IFFALSE 34418
// begin x := tmp [ i ] ;
34359: LD_ADDR_VAR 0 9
34363: PUSH
34364: LD_VAR 0 8
34368: PUSH
34369: LD_VAR 0 6
34373: ARRAY
34374: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
34375: LD_ADDR_VAR 0 8
34379: PUSH
34380: LD_VAR 0 8
34384: PPUSH
34385: LD_VAR 0 6
34389: PPUSH
34390: CALL_OW 3
34394: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
34395: LD_ADDR_VAR 0 8
34399: PUSH
34400: LD_VAR 0 8
34404: PPUSH
34405: LD_INT 1
34407: PPUSH
34408: LD_VAR 0 9
34412: PPUSH
34413: CALL_OW 2
34417: ST_TO_ADDR
// end ;
34418: GO 34335
34420: POP
34421: POP
// for i in tmp do
34422: LD_ADDR_VAR 0 6
34426: PUSH
34427: LD_VAR 0 8
34431: PUSH
34432: FOR_IN
34433: IFFALSE 34502
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
34435: LD_VAR 0 6
34439: PPUSH
34440: CALL_OW 313
34444: PUSH
34445: LD_INT 6
34447: LESS
34448: PUSH
34449: LD_VAR 0 6
34453: PPUSH
34454: CALL_OW 266
34458: PUSH
34459: LD_INT 31
34461: PUSH
34462: LD_INT 32
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: IN
34469: NOT
34470: AND
34471: PUSH
34472: LD_VAR 0 6
34476: PPUSH
34477: CALL_OW 313
34481: PUSH
34482: LD_INT 0
34484: EQUAL
34485: OR
34486: IFFALSE 34500
// begin j := i ;
34488: LD_ADDR_VAR 0 7
34492: PUSH
34493: LD_VAR 0 6
34497: ST_TO_ADDR
// break ;
34498: GO 34502
// end ; end ;
34500: GO 34432
34502: POP
34503: POP
// if j then
34504: LD_VAR 0 7
34508: IFFALSE 34526
// ComEnterUnit ( unit , j ) else
34510: LD_VAR 0 3
34514: PPUSH
34515: LD_VAR 0 7
34519: PPUSH
34520: CALL_OW 120
34524: GO 34629
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34526: LD_ADDR_VAR 0 10
34530: PUSH
34531: LD_VAR 0 2
34535: PPUSH
34536: LD_INT 2
34538: PUSH
34539: LD_INT 30
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 30
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: LIST
34563: PPUSH
34564: CALL_OW 72
34568: ST_TO_ADDR
// if depot then
34569: LD_VAR 0 10
34573: IFFALSE 34629
// begin depot := NearestUnitToUnit ( depot , unit ) ;
34575: LD_ADDR_VAR 0 10
34579: PUSH
34580: LD_VAR 0 10
34584: PPUSH
34585: LD_VAR 0 3
34589: PPUSH
34590: CALL_OW 74
34594: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
34595: LD_VAR 0 3
34599: PPUSH
34600: LD_VAR 0 10
34604: PPUSH
34605: CALL_OW 296
34609: PUSH
34610: LD_INT 10
34612: GREATER
34613: IFFALSE 34629
// ComStandNearbyBuilding ( unit , depot ) ;
34615: LD_VAR 0 3
34619: PPUSH
34620: LD_VAR 0 10
34624: PPUSH
34625: CALL 42415 0 2
// end ; end ; end ;
34629: LD_VAR 0 5
34633: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
34634: LD_INT 0
34636: PPUSH
34637: PPUSH
34638: PPUSH
34639: PPUSH
// if not mc_bases then
34640: LD_EXP 69
34644: NOT
34645: IFFALSE 34649
// exit ;
34647: GO 34888
// for i = 1 to mc_bases do
34649: LD_ADDR_VAR 0 2
34653: PUSH
34654: DOUBLE
34655: LD_INT 1
34657: DEC
34658: ST_TO_ADDR
34659: LD_EXP 69
34663: PUSH
34664: FOR_TO
34665: IFFALSE 34886
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
34667: LD_ADDR_VAR 0 4
34671: PUSH
34672: LD_EXP 69
34676: PUSH
34677: LD_VAR 0 2
34681: ARRAY
34682: PPUSH
34683: LD_INT 21
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PPUSH
34693: CALL_OW 72
34697: PUSH
34698: LD_EXP 98
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: UNION
34709: ST_TO_ADDR
// if not tmp then
34710: LD_VAR 0 4
34714: NOT
34715: IFFALSE 34719
// continue ;
34717: GO 34664
// for j in tmp do
34719: LD_ADDR_VAR 0 3
34723: PUSH
34724: LD_VAR 0 4
34728: PUSH
34729: FOR_IN
34730: IFFALSE 34882
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
34732: LD_VAR 0 3
34736: PPUSH
34737: CALL_OW 110
34741: NOT
34742: PUSH
34743: LD_VAR 0 3
34747: PPUSH
34748: CALL_OW 314
34752: NOT
34753: AND
34754: PUSH
34755: LD_VAR 0 3
34759: PPUSH
34760: CALL_OW 311
34764: NOT
34765: AND
34766: PUSH
34767: LD_VAR 0 3
34771: PPUSH
34772: CALL_OW 310
34776: NOT
34777: AND
34778: PUSH
34779: LD_VAR 0 3
34783: PUSH
34784: LD_EXP 72
34788: PUSH
34789: LD_VAR 0 2
34793: ARRAY
34794: PUSH
34795: LD_INT 1
34797: ARRAY
34798: IN
34799: NOT
34800: AND
34801: PUSH
34802: LD_VAR 0 3
34806: PUSH
34807: LD_EXP 72
34811: PUSH
34812: LD_VAR 0 2
34816: ARRAY
34817: PUSH
34818: LD_INT 2
34820: ARRAY
34821: IN
34822: NOT
34823: AND
34824: PUSH
34825: LD_VAR 0 3
34829: PUSH
34830: LD_EXP 81
34834: PUSH
34835: LD_VAR 0 2
34839: ARRAY
34840: IN
34841: NOT
34842: AND
34843: IFFALSE 34880
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
34845: LD_VAR 0 2
34849: PPUSH
34850: LD_EXP 69
34854: PUSH
34855: LD_VAR 0 2
34859: ARRAY
34860: PPUSH
34861: LD_VAR 0 3
34865: PPUSH
34866: LD_VAR 0 3
34870: PPUSH
34871: CALL_OW 257
34875: PPUSH
34876: CALL 33652 0 4
// end ;
34880: GO 34729
34882: POP
34883: POP
// end ;
34884: GO 34664
34886: POP
34887: POP
// end ;
34888: LD_VAR 0 1
34892: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
34893: LD_INT 0
34895: PPUSH
34896: PPUSH
34897: PPUSH
34898: PPUSH
34899: PPUSH
34900: PPUSH
// if not mc_bases [ base ] then
34901: LD_EXP 69
34905: PUSH
34906: LD_VAR 0 1
34910: ARRAY
34911: NOT
34912: IFFALSE 34916
// exit ;
34914: GO 35098
// tmp := [ ] ;
34916: LD_ADDR_VAR 0 6
34920: PUSH
34921: EMPTY
34922: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
34923: LD_ADDR_VAR 0 7
34927: PUSH
34928: LD_VAR 0 3
34932: PPUSH
34933: LD_INT 0
34935: PPUSH
34936: CALL_OW 517
34940: ST_TO_ADDR
// if not list then
34941: LD_VAR 0 7
34945: NOT
34946: IFFALSE 34950
// exit ;
34948: GO 35098
// for i = 1 to amount do
34950: LD_ADDR_VAR 0 5
34954: PUSH
34955: DOUBLE
34956: LD_INT 1
34958: DEC
34959: ST_TO_ADDR
34960: LD_VAR 0 2
34964: PUSH
34965: FOR_TO
34966: IFFALSE 35046
// begin x := rand ( 1 , list [ 1 ] ) ;
34968: LD_ADDR_VAR 0 8
34972: PUSH
34973: LD_INT 1
34975: PPUSH
34976: LD_VAR 0 7
34980: PUSH
34981: LD_INT 1
34983: ARRAY
34984: PPUSH
34985: CALL_OW 12
34989: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
34990: LD_ADDR_VAR 0 6
34994: PUSH
34995: LD_VAR 0 6
34999: PPUSH
35000: LD_VAR 0 5
35004: PPUSH
35005: LD_VAR 0 7
35009: PUSH
35010: LD_INT 1
35012: ARRAY
35013: PUSH
35014: LD_VAR 0 8
35018: ARRAY
35019: PUSH
35020: LD_VAR 0 7
35024: PUSH
35025: LD_INT 2
35027: ARRAY
35028: PUSH
35029: LD_VAR 0 8
35033: ARRAY
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PPUSH
35039: CALL_OW 1
35043: ST_TO_ADDR
// end ;
35044: GO 34965
35046: POP
35047: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
35048: LD_ADDR_EXP 82
35052: PUSH
35053: LD_EXP 82
35057: PPUSH
35058: LD_VAR 0 1
35062: PPUSH
35063: LD_VAR 0 6
35067: PPUSH
35068: CALL_OW 1
35072: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
35073: LD_ADDR_EXP 84
35077: PUSH
35078: LD_EXP 84
35082: PPUSH
35083: LD_VAR 0 1
35087: PPUSH
35088: LD_VAR 0 3
35092: PPUSH
35093: CALL_OW 1
35097: ST_TO_ADDR
// end ;
35098: LD_VAR 0 4
35102: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
35103: LD_INT 0
35105: PPUSH
// if not mc_bases [ base ] then
35106: LD_EXP 69
35110: PUSH
35111: LD_VAR 0 1
35115: ARRAY
35116: NOT
35117: IFFALSE 35121
// exit ;
35119: GO 35146
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
35121: LD_ADDR_EXP 74
35125: PUSH
35126: LD_EXP 74
35130: PPUSH
35131: LD_VAR 0 1
35135: PPUSH
35136: LD_VAR 0 2
35140: PPUSH
35141: CALL_OW 1
35145: ST_TO_ADDR
// end ;
35146: LD_VAR 0 3
35150: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
35151: LD_INT 0
35153: PPUSH
// if not mc_bases [ base ] then
35154: LD_EXP 69
35158: PUSH
35159: LD_VAR 0 1
35163: ARRAY
35164: NOT
35165: IFFALSE 35169
// exit ;
35167: GO 35206
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
35169: LD_ADDR_EXP 74
35173: PUSH
35174: LD_EXP 74
35178: PPUSH
35179: LD_VAR 0 1
35183: PPUSH
35184: LD_EXP 74
35188: PUSH
35189: LD_VAR 0 1
35193: ARRAY
35194: PUSH
35195: LD_VAR 0 2
35199: UNION
35200: PPUSH
35201: CALL_OW 1
35205: ST_TO_ADDR
// end ;
35206: LD_VAR 0 3
35210: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
35211: LD_INT 0
35213: PPUSH
// if not mc_bases [ base ] then
35214: LD_EXP 69
35218: PUSH
35219: LD_VAR 0 1
35223: ARRAY
35224: NOT
35225: IFFALSE 35229
// exit ;
35227: GO 35254
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
35229: LD_ADDR_EXP 90
35233: PUSH
35234: LD_EXP 90
35238: PPUSH
35239: LD_VAR 0 1
35243: PPUSH
35244: LD_VAR 0 2
35248: PPUSH
35249: CALL_OW 1
35253: ST_TO_ADDR
// end ;
35254: LD_VAR 0 3
35258: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
35259: LD_INT 0
35261: PPUSH
// if not mc_bases [ base ] then
35262: LD_EXP 69
35266: PUSH
35267: LD_VAR 0 1
35271: ARRAY
35272: NOT
35273: IFFALSE 35277
// exit ;
35275: GO 35314
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
35277: LD_ADDR_EXP 90
35281: PUSH
35282: LD_EXP 90
35286: PPUSH
35287: LD_VAR 0 1
35291: PPUSH
35292: LD_EXP 90
35296: PUSH
35297: LD_VAR 0 1
35301: ARRAY
35302: PUSH
35303: LD_VAR 0 2
35307: UNION
35308: PPUSH
35309: CALL_OW 1
35313: ST_TO_ADDR
// end ;
35314: LD_VAR 0 3
35318: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
35319: LD_INT 0
35321: PPUSH
// if not mc_bases [ base ] then
35322: LD_EXP 69
35326: PUSH
35327: LD_VAR 0 1
35331: ARRAY
35332: NOT
35333: IFFALSE 35337
// exit ;
35335: GO 35449
// mc_defender := Replace ( mc_defender , base , deflist ) ;
35337: LD_ADDR_EXP 91
35341: PUSH
35342: LD_EXP 91
35346: PPUSH
35347: LD_VAR 0 1
35351: PPUSH
35352: LD_VAR 0 2
35356: PPUSH
35357: CALL_OW 1
35361: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
35362: LD_ADDR_EXP 80
35366: PUSH
35367: LD_EXP 80
35371: PPUSH
35372: LD_VAR 0 1
35376: PPUSH
35377: LD_VAR 0 2
35381: PUSH
35382: LD_INT 0
35384: PLUS
35385: PPUSH
35386: CALL_OW 1
35390: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
35391: LD_ADDR_EXP 88
35395: PUSH
35396: LD_EXP 88
35400: PPUSH
35401: LD_VAR 0 1
35405: PPUSH
35406: LD_EXP 88
35410: PUSH
35411: LD_VAR 0 1
35415: ARRAY
35416: PUSH
35417: LD_EXP 91
35421: PUSH
35422: LD_VAR 0 1
35426: ARRAY
35427: PPUSH
35428: LD_INT 21
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PPUSH
35438: CALL_OW 72
35442: UNION
35443: PPUSH
35444: CALL_OW 1
35448: ST_TO_ADDR
// end ;
35449: LD_VAR 0 3
35453: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
35454: LD_INT 0
35456: PPUSH
// if not mc_bases [ base ] then
35457: LD_EXP 69
35461: PUSH
35462: LD_VAR 0 1
35466: ARRAY
35467: NOT
35468: IFFALSE 35472
// exit ;
35470: GO 35497
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
35472: LD_ADDR_EXP 80
35476: PUSH
35477: LD_EXP 80
35481: PPUSH
35482: LD_VAR 0 1
35486: PPUSH
35487: LD_VAR 0 2
35491: PPUSH
35492: CALL_OW 1
35496: ST_TO_ADDR
// end ;
35497: LD_VAR 0 3
35501: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
35502: LD_INT 0
35504: PPUSH
35505: PPUSH
35506: PPUSH
35507: PPUSH
// if not mc_bases [ base ] then
35508: LD_EXP 69
35512: PUSH
35513: LD_VAR 0 1
35517: ARRAY
35518: NOT
35519: IFFALSE 35523
// exit ;
35521: GO 35588
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
35523: LD_ADDR_EXP 89
35527: PUSH
35528: LD_EXP 89
35532: PPUSH
35533: LD_VAR 0 1
35537: PUSH
35538: LD_EXP 89
35542: PUSH
35543: LD_VAR 0 1
35547: ARRAY
35548: PUSH
35549: LD_INT 1
35551: PLUS
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PPUSH
35557: LD_VAR 0 1
35561: PUSH
35562: LD_VAR 0 2
35566: PUSH
35567: LD_VAR 0 3
35571: PUSH
35572: LD_VAR 0 4
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: PPUSH
35583: CALL 47738 0 3
35587: ST_TO_ADDR
// end ;
35588: LD_VAR 0 5
35592: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
35593: LD_INT 0
35595: PPUSH
// if not mc_bases [ base ] then
35596: LD_EXP 69
35600: PUSH
35601: LD_VAR 0 1
35605: ARRAY
35606: NOT
35607: IFFALSE 35611
// exit ;
35609: GO 35636
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
35611: LD_ADDR_EXP 106
35615: PUSH
35616: LD_EXP 106
35620: PPUSH
35621: LD_VAR 0 1
35625: PPUSH
35626: LD_VAR 0 2
35630: PPUSH
35631: CALL_OW 1
35635: ST_TO_ADDR
// end ;
35636: LD_VAR 0 3
35640: RET
// export function MC_GetMinesField ( base ) ; begin
35641: LD_INT 0
35643: PPUSH
// result := mc_mines [ base ] ;
35644: LD_ADDR_VAR 0 2
35648: PUSH
35649: LD_EXP 82
35653: PUSH
35654: LD_VAR 0 1
35658: ARRAY
35659: ST_TO_ADDR
// end ;
35660: LD_VAR 0 2
35664: RET
// export function MC_GetProduceList ( base ) ; begin
35665: LD_INT 0
35667: PPUSH
// result := mc_produce [ base ] ;
35668: LD_ADDR_VAR 0 2
35672: PUSH
35673: LD_EXP 90
35677: PUSH
35678: LD_VAR 0 1
35682: ARRAY
35683: ST_TO_ADDR
// end ;
35684: LD_VAR 0 2
35688: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
35689: LD_INT 0
35691: PPUSH
35692: PPUSH
// if not mc_bases then
35693: LD_EXP 69
35697: NOT
35698: IFFALSE 35702
// exit ;
35700: GO 35767
// if mc_bases [ base ] then
35702: LD_EXP 69
35706: PUSH
35707: LD_VAR 0 1
35711: ARRAY
35712: IFFALSE 35767
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
35714: LD_ADDR_VAR 0 3
35718: PUSH
35719: LD_EXP 69
35723: PUSH
35724: LD_VAR 0 1
35728: ARRAY
35729: PPUSH
35730: LD_INT 30
35732: PUSH
35733: LD_VAR 0 2
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PPUSH
35742: CALL_OW 72
35746: ST_TO_ADDR
// if result then
35747: LD_VAR 0 3
35751: IFFALSE 35767
// result := result [ 1 ] ;
35753: LD_ADDR_VAR 0 3
35757: PUSH
35758: LD_VAR 0 3
35762: PUSH
35763: LD_INT 1
35765: ARRAY
35766: ST_TO_ADDR
// end ; end ;
35767: LD_VAR 0 3
35771: RET
// export function MC_SetTame ( base , area ) ; begin
35772: LD_INT 0
35774: PPUSH
// if not mc_bases or not base then
35775: LD_EXP 69
35779: NOT
35780: PUSH
35781: LD_VAR 0 1
35785: NOT
35786: OR
35787: IFFALSE 35791
// exit ;
35789: GO 35816
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
35791: LD_ADDR_EXP 97
35795: PUSH
35796: LD_EXP 97
35800: PPUSH
35801: LD_VAR 0 1
35805: PPUSH
35806: LD_VAR 0 2
35810: PPUSH
35811: CALL_OW 1
35815: ST_TO_ADDR
// end ;
35816: LD_VAR 0 3
35820: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
35821: LD_INT 0
35823: PPUSH
35824: PPUSH
// if not mc_bases or not base then
35825: LD_EXP 69
35829: NOT
35830: PUSH
35831: LD_VAR 0 1
35835: NOT
35836: OR
35837: IFFALSE 35841
// exit ;
35839: GO 35943
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
35841: LD_ADDR_VAR 0 4
35845: PUSH
35846: LD_EXP 69
35850: PUSH
35851: LD_VAR 0 1
35855: ARRAY
35856: PPUSH
35857: LD_INT 30
35859: PUSH
35860: LD_VAR 0 2
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PPUSH
35869: CALL_OW 72
35873: ST_TO_ADDR
// if not tmp then
35874: LD_VAR 0 4
35878: NOT
35879: IFFALSE 35883
// exit ;
35881: GO 35943
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
35883: LD_ADDR_EXP 101
35887: PUSH
35888: LD_EXP 101
35892: PPUSH
35893: LD_VAR 0 1
35897: PPUSH
35898: LD_EXP 101
35902: PUSH
35903: LD_VAR 0 1
35907: ARRAY
35908: PPUSH
35909: LD_EXP 101
35913: PUSH
35914: LD_VAR 0 1
35918: ARRAY
35919: PUSH
35920: LD_INT 1
35922: PLUS
35923: PPUSH
35924: LD_VAR 0 4
35928: PUSH
35929: LD_INT 1
35931: ARRAY
35932: PPUSH
35933: CALL_OW 2
35937: PPUSH
35938: CALL_OW 1
35942: ST_TO_ADDR
// end ;
35943: LD_VAR 0 3
35947: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
35948: LD_INT 0
35950: PPUSH
35951: PPUSH
// if not mc_bases or not base or not kinds then
35952: LD_EXP 69
35956: NOT
35957: PUSH
35958: LD_VAR 0 1
35962: NOT
35963: OR
35964: PUSH
35965: LD_VAR 0 2
35969: NOT
35970: OR
35971: IFFALSE 35975
// exit ;
35973: GO 36036
// for i in kinds do
35975: LD_ADDR_VAR 0 4
35979: PUSH
35980: LD_VAR 0 2
35984: PUSH
35985: FOR_IN
35986: IFFALSE 36034
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
35988: LD_ADDR_EXP 103
35992: PUSH
35993: LD_EXP 103
35997: PPUSH
35998: LD_VAR 0 1
36002: PUSH
36003: LD_EXP 103
36007: PUSH
36008: LD_VAR 0 1
36012: ARRAY
36013: PUSH
36014: LD_INT 1
36016: PLUS
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PPUSH
36022: LD_VAR 0 4
36026: PPUSH
36027: CALL 47738 0 3
36031: ST_TO_ADDR
36032: GO 35985
36034: POP
36035: POP
// end ;
36036: LD_VAR 0 3
36040: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
36041: LD_INT 0
36043: PPUSH
// if not mc_bases or not base or not areas then
36044: LD_EXP 69
36048: NOT
36049: PUSH
36050: LD_VAR 0 1
36054: NOT
36055: OR
36056: PUSH
36057: LD_VAR 0 2
36061: NOT
36062: OR
36063: IFFALSE 36067
// exit ;
36065: GO 36092
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
36067: LD_ADDR_EXP 87
36071: PUSH
36072: LD_EXP 87
36076: PPUSH
36077: LD_VAR 0 1
36081: PPUSH
36082: LD_VAR 0 2
36086: PPUSH
36087: CALL_OW 1
36091: ST_TO_ADDR
// end ;
36092: LD_VAR 0 3
36096: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
36097: LD_INT 0
36099: PPUSH
// if not mc_bases or not base or not teleports_exit then
36100: LD_EXP 69
36104: NOT
36105: PUSH
36106: LD_VAR 0 1
36110: NOT
36111: OR
36112: PUSH
36113: LD_VAR 0 2
36117: NOT
36118: OR
36119: IFFALSE 36123
// exit ;
36121: GO 36148
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
36123: LD_ADDR_EXP 104
36127: PUSH
36128: LD_EXP 104
36132: PPUSH
36133: LD_VAR 0 1
36137: PPUSH
36138: LD_VAR 0 2
36142: PPUSH
36143: CALL_OW 1
36147: ST_TO_ADDR
// end ;
36148: LD_VAR 0 3
36152: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
36153: LD_INT 0
36155: PPUSH
36156: PPUSH
36157: PPUSH
// if not mc_bases or not base or not ext_list then
36158: LD_EXP 69
36162: NOT
36163: PUSH
36164: LD_VAR 0 1
36168: NOT
36169: OR
36170: PUSH
36171: LD_VAR 0 5
36175: NOT
36176: OR
36177: IFFALSE 36181
// exit ;
36179: GO 36354
// tmp := GetFacExtXYD ( x , y , d ) ;
36181: LD_ADDR_VAR 0 8
36185: PUSH
36186: LD_VAR 0 2
36190: PPUSH
36191: LD_VAR 0 3
36195: PPUSH
36196: LD_VAR 0 4
36200: PPUSH
36201: CALL 81053 0 3
36205: ST_TO_ADDR
// if not tmp then
36206: LD_VAR 0 8
36210: NOT
36211: IFFALSE 36215
// exit ;
36213: GO 36354
// for i in tmp do
36215: LD_ADDR_VAR 0 7
36219: PUSH
36220: LD_VAR 0 8
36224: PUSH
36225: FOR_IN
36226: IFFALSE 36352
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
36228: LD_ADDR_EXP 74
36232: PUSH
36233: LD_EXP 74
36237: PPUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_EXP 74
36247: PUSH
36248: LD_VAR 0 1
36252: ARRAY
36253: PPUSH
36254: LD_EXP 74
36258: PUSH
36259: LD_VAR 0 1
36263: ARRAY
36264: PUSH
36265: LD_INT 1
36267: PLUS
36268: PPUSH
36269: LD_VAR 0 5
36273: PUSH
36274: LD_INT 1
36276: ARRAY
36277: PUSH
36278: LD_VAR 0 7
36282: PUSH
36283: LD_INT 1
36285: ARRAY
36286: PUSH
36287: LD_VAR 0 7
36291: PUSH
36292: LD_INT 2
36294: ARRAY
36295: PUSH
36296: LD_VAR 0 7
36300: PUSH
36301: LD_INT 3
36303: ARRAY
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: PPUSH
36311: CALL_OW 2
36315: PPUSH
36316: CALL_OW 1
36320: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
36321: LD_ADDR_VAR 0 5
36325: PUSH
36326: LD_VAR 0 5
36330: PPUSH
36331: LD_INT 1
36333: PPUSH
36334: CALL_OW 3
36338: ST_TO_ADDR
// if not ext_list then
36339: LD_VAR 0 5
36343: NOT
36344: IFFALSE 36350
// exit ;
36346: POP
36347: POP
36348: GO 36354
// end ;
36350: GO 36225
36352: POP
36353: POP
// end ;
36354: LD_VAR 0 6
36358: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
36359: LD_INT 0
36361: PPUSH
// if not mc_bases or not base or not weapon_list then
36362: LD_EXP 69
36366: NOT
36367: PUSH
36368: LD_VAR 0 1
36372: NOT
36373: OR
36374: PUSH
36375: LD_VAR 0 2
36379: NOT
36380: OR
36381: IFFALSE 36385
// exit ;
36383: GO 36410
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
36385: LD_ADDR_EXP 108
36389: PUSH
36390: LD_EXP 108
36394: PPUSH
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_VAR 0 2
36404: PPUSH
36405: CALL_OW 1
36409: ST_TO_ADDR
// end ;
36410: LD_VAR 0 3
36414: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
36415: LD_INT 0
36417: PPUSH
// if not mc_bases or not base or not tech_list then
36418: LD_EXP 69
36422: NOT
36423: PUSH
36424: LD_VAR 0 1
36428: NOT
36429: OR
36430: PUSH
36431: LD_VAR 0 2
36435: NOT
36436: OR
36437: IFFALSE 36441
// exit ;
36439: GO 36466
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
36441: LD_ADDR_EXP 96
36445: PUSH
36446: LD_EXP 96
36450: PPUSH
36451: LD_VAR 0 1
36455: PPUSH
36456: LD_VAR 0 2
36460: PPUSH
36461: CALL_OW 1
36465: ST_TO_ADDR
// end ;
36466: LD_VAR 0 3
36470: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
36471: LD_INT 0
36473: PPUSH
// if not mc_bases or not parking_area or not base then
36474: LD_EXP 69
36478: NOT
36479: PUSH
36480: LD_VAR 0 2
36484: NOT
36485: OR
36486: PUSH
36487: LD_VAR 0 1
36491: NOT
36492: OR
36493: IFFALSE 36497
// exit ;
36495: GO 36522
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
36497: LD_ADDR_EXP 93
36501: PUSH
36502: LD_EXP 93
36506: PPUSH
36507: LD_VAR 0 1
36511: PPUSH
36512: LD_VAR 0 2
36516: PPUSH
36517: CALL_OW 1
36521: ST_TO_ADDR
// end ;
36522: LD_VAR 0 3
36526: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
36527: LD_INT 0
36529: PPUSH
// if not mc_bases or not base or not scan_area then
36530: LD_EXP 69
36534: NOT
36535: PUSH
36536: LD_VAR 0 1
36540: NOT
36541: OR
36542: PUSH
36543: LD_VAR 0 2
36547: NOT
36548: OR
36549: IFFALSE 36553
// exit ;
36551: GO 36578
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
36553: LD_ADDR_EXP 94
36557: PUSH
36558: LD_EXP 94
36562: PPUSH
36563: LD_VAR 0 1
36567: PPUSH
36568: LD_VAR 0 2
36572: PPUSH
36573: CALL_OW 1
36577: ST_TO_ADDR
// end ;
36578: LD_VAR 0 3
36582: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
36583: LD_INT 0
36585: PPUSH
36586: PPUSH
// if not mc_bases or not base then
36587: LD_EXP 69
36591: NOT
36592: PUSH
36593: LD_VAR 0 1
36597: NOT
36598: OR
36599: IFFALSE 36603
// exit ;
36601: GO 36667
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
36603: LD_ADDR_VAR 0 3
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 2
36613: PUSH
36614: LD_INT 3
36616: PUSH
36617: LD_INT 4
36619: PUSH
36620: LD_INT 11
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
36630: LD_ADDR_EXP 96
36634: PUSH
36635: LD_EXP 96
36639: PPUSH
36640: LD_VAR 0 1
36644: PPUSH
36645: LD_EXP 96
36649: PUSH
36650: LD_VAR 0 1
36654: ARRAY
36655: PUSH
36656: LD_VAR 0 3
36660: DIFF
36661: PPUSH
36662: CALL_OW 1
36666: ST_TO_ADDR
// end ; end_of_file
36667: LD_VAR 0 2
36671: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
36672: LD_INT 0
36674: PPUSH
36675: PPUSH
36676: PPUSH
// if not mc_bases or not skirmish then
36677: LD_EXP 69
36681: NOT
36682: PUSH
36683: LD_EXP 67
36687: NOT
36688: OR
36689: IFFALSE 36693
// exit ;
36691: GO 36858
// for i = 1 to mc_bases do
36693: LD_ADDR_VAR 0 4
36697: PUSH
36698: DOUBLE
36699: LD_INT 1
36701: DEC
36702: ST_TO_ADDR
36703: LD_EXP 69
36707: PUSH
36708: FOR_TO
36709: IFFALSE 36856
// begin if sci in mc_bases [ i ] then
36711: LD_VAR 0 2
36715: PUSH
36716: LD_EXP 69
36720: PUSH
36721: LD_VAR 0 4
36725: ARRAY
36726: IN
36727: IFFALSE 36854
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
36729: LD_ADDR_EXP 98
36733: PUSH
36734: LD_EXP 98
36738: PPUSH
36739: LD_VAR 0 4
36743: PUSH
36744: LD_EXP 98
36748: PUSH
36749: LD_VAR 0 4
36753: ARRAY
36754: PUSH
36755: LD_INT 1
36757: PLUS
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PPUSH
36763: LD_VAR 0 1
36767: PPUSH
36768: CALL 47738 0 3
36772: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
36773: LD_ADDR_VAR 0 5
36777: PUSH
36778: LD_EXP 69
36782: PUSH
36783: LD_VAR 0 4
36787: ARRAY
36788: PPUSH
36789: LD_INT 2
36791: PUSH
36792: LD_INT 30
36794: PUSH
36795: LD_INT 0
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 30
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: LIST
36816: PPUSH
36817: CALL_OW 72
36821: PPUSH
36822: LD_VAR 0 1
36826: PPUSH
36827: CALL_OW 74
36831: ST_TO_ADDR
// if tmp then
36832: LD_VAR 0 5
36836: IFFALSE 36852
// ComStandNearbyBuilding ( ape , tmp ) ;
36838: LD_VAR 0 1
36842: PPUSH
36843: LD_VAR 0 5
36847: PPUSH
36848: CALL 42415 0 2
// break ;
36852: GO 36856
// end ; end ;
36854: GO 36708
36856: POP
36857: POP
// end ;
36858: LD_VAR 0 3
36862: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
36863: LD_INT 0
36865: PPUSH
36866: PPUSH
36867: PPUSH
// if not mc_bases or not skirmish then
36868: LD_EXP 69
36872: NOT
36873: PUSH
36874: LD_EXP 67
36878: NOT
36879: OR
36880: IFFALSE 36884
// exit ;
36882: GO 36973
// for i = 1 to mc_bases do
36884: LD_ADDR_VAR 0 4
36888: PUSH
36889: DOUBLE
36890: LD_INT 1
36892: DEC
36893: ST_TO_ADDR
36894: LD_EXP 69
36898: PUSH
36899: FOR_TO
36900: IFFALSE 36971
// begin if building in mc_busy_turret_list [ i ] then
36902: LD_VAR 0 1
36906: PUSH
36907: LD_EXP 79
36911: PUSH
36912: LD_VAR 0 4
36916: ARRAY
36917: IN
36918: IFFALSE 36969
// begin tmp := mc_busy_turret_list [ i ] diff building ;
36920: LD_ADDR_VAR 0 5
36924: PUSH
36925: LD_EXP 79
36929: PUSH
36930: LD_VAR 0 4
36934: ARRAY
36935: PUSH
36936: LD_VAR 0 1
36940: DIFF
36941: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
36942: LD_ADDR_EXP 79
36946: PUSH
36947: LD_EXP 79
36951: PPUSH
36952: LD_VAR 0 4
36956: PPUSH
36957: LD_VAR 0 5
36961: PPUSH
36962: CALL_OW 1
36966: ST_TO_ADDR
// break ;
36967: GO 36971
// end ; end ;
36969: GO 36899
36971: POP
36972: POP
// end ;
36973: LD_VAR 0 3
36977: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
36978: LD_INT 0
36980: PPUSH
36981: PPUSH
36982: PPUSH
// if not mc_bases or not skirmish then
36983: LD_EXP 69
36987: NOT
36988: PUSH
36989: LD_EXP 67
36993: NOT
36994: OR
36995: IFFALSE 36999
// exit ;
36997: GO 37198
// for i = 1 to mc_bases do
36999: LD_ADDR_VAR 0 5
37003: PUSH
37004: DOUBLE
37005: LD_INT 1
37007: DEC
37008: ST_TO_ADDR
37009: LD_EXP 69
37013: PUSH
37014: FOR_TO
37015: IFFALSE 37196
// if building in mc_bases [ i ] then
37017: LD_VAR 0 1
37021: PUSH
37022: LD_EXP 69
37026: PUSH
37027: LD_VAR 0 5
37031: ARRAY
37032: IN
37033: IFFALSE 37194
// begin tmp := mc_bases [ i ] diff building ;
37035: LD_ADDR_VAR 0 6
37039: PUSH
37040: LD_EXP 69
37044: PUSH
37045: LD_VAR 0 5
37049: ARRAY
37050: PUSH
37051: LD_VAR 0 1
37055: DIFF
37056: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
37057: LD_ADDR_EXP 69
37061: PUSH
37062: LD_EXP 69
37066: PPUSH
37067: LD_VAR 0 5
37071: PPUSH
37072: LD_VAR 0 6
37076: PPUSH
37077: CALL_OW 1
37081: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
37082: LD_VAR 0 1
37086: PUSH
37087: LD_EXP 77
37091: PUSH
37092: LD_VAR 0 5
37096: ARRAY
37097: IN
37098: IFFALSE 37137
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
37100: LD_ADDR_EXP 77
37104: PUSH
37105: LD_EXP 77
37109: PPUSH
37110: LD_VAR 0 5
37114: PPUSH
37115: LD_EXP 77
37119: PUSH
37120: LD_VAR 0 5
37124: ARRAY
37125: PUSH
37126: LD_VAR 0 1
37130: DIFF
37131: PPUSH
37132: CALL_OW 1
37136: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
37137: LD_VAR 0 1
37141: PUSH
37142: LD_EXP 78
37146: PUSH
37147: LD_VAR 0 5
37151: ARRAY
37152: IN
37153: IFFALSE 37192
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
37155: LD_ADDR_EXP 78
37159: PUSH
37160: LD_EXP 78
37164: PPUSH
37165: LD_VAR 0 5
37169: PPUSH
37170: LD_EXP 78
37174: PUSH
37175: LD_VAR 0 5
37179: ARRAY
37180: PUSH
37181: LD_VAR 0 1
37185: DIFF
37186: PPUSH
37187: CALL_OW 1
37191: ST_TO_ADDR
// break ;
37192: GO 37196
// end ;
37194: GO 37014
37196: POP
37197: POP
// end ;
37198: LD_VAR 0 4
37202: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
37203: LD_INT 0
37205: PPUSH
37206: PPUSH
37207: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
37208: LD_EXP 69
37212: NOT
37213: PUSH
37214: LD_EXP 67
37218: NOT
37219: OR
37220: PUSH
37221: LD_VAR 0 3
37225: PUSH
37226: LD_EXP 95
37230: IN
37231: NOT
37232: OR
37233: IFFALSE 37237
// exit ;
37235: GO 37360
// for i = 1 to mc_vehicles do
37237: LD_ADDR_VAR 0 6
37241: PUSH
37242: DOUBLE
37243: LD_INT 1
37245: DEC
37246: ST_TO_ADDR
37247: LD_EXP 88
37251: PUSH
37252: FOR_TO
37253: IFFALSE 37358
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
37255: LD_VAR 0 2
37259: PUSH
37260: LD_EXP 88
37264: PUSH
37265: LD_VAR 0 6
37269: ARRAY
37270: IN
37271: PUSH
37272: LD_VAR 0 1
37276: PUSH
37277: LD_EXP 88
37281: PUSH
37282: LD_VAR 0 6
37286: ARRAY
37287: IN
37288: OR
37289: IFFALSE 37356
// begin tmp := mc_vehicles [ i ] diff old ;
37291: LD_ADDR_VAR 0 7
37295: PUSH
37296: LD_EXP 88
37300: PUSH
37301: LD_VAR 0 6
37305: ARRAY
37306: PUSH
37307: LD_VAR 0 2
37311: DIFF
37312: ST_TO_ADDR
// tmp := tmp diff new ;
37313: LD_ADDR_VAR 0 7
37317: PUSH
37318: LD_VAR 0 7
37322: PUSH
37323: LD_VAR 0 1
37327: DIFF
37328: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
37329: LD_ADDR_EXP 88
37333: PUSH
37334: LD_EXP 88
37338: PPUSH
37339: LD_VAR 0 6
37343: PPUSH
37344: LD_VAR 0 7
37348: PPUSH
37349: CALL_OW 1
37353: ST_TO_ADDR
// break ;
37354: GO 37358
// end ;
37356: GO 37252
37358: POP
37359: POP
// end ;
37360: LD_VAR 0 5
37364: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
37365: LD_INT 0
37367: PPUSH
37368: PPUSH
37369: PPUSH
37370: PPUSH
// if not mc_bases or not skirmish then
37371: LD_EXP 69
37375: NOT
37376: PUSH
37377: LD_EXP 67
37381: NOT
37382: OR
37383: IFFALSE 37387
// exit ;
37385: GO 37770
// side := GetSide ( vehicle ) ;
37387: LD_ADDR_VAR 0 5
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL_OW 255
37401: ST_TO_ADDR
// for i = 1 to mc_bases do
37402: LD_ADDR_VAR 0 4
37406: PUSH
37407: DOUBLE
37408: LD_INT 1
37410: DEC
37411: ST_TO_ADDR
37412: LD_EXP 69
37416: PUSH
37417: FOR_TO
37418: IFFALSE 37768
// begin if factory in mc_bases [ i ] then
37420: LD_VAR 0 2
37424: PUSH
37425: LD_EXP 69
37429: PUSH
37430: LD_VAR 0 4
37434: ARRAY
37435: IN
37436: IFFALSE 37766
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
37438: LD_EXP 91
37442: PUSH
37443: LD_VAR 0 4
37447: ARRAY
37448: PUSH
37449: LD_EXP 80
37453: PUSH
37454: LD_VAR 0 4
37458: ARRAY
37459: LESS
37460: PUSH
37461: LD_VAR 0 1
37465: PPUSH
37466: CALL_OW 264
37470: PUSH
37471: LD_INT 31
37473: PUSH
37474: LD_INT 32
37476: PUSH
37477: LD_INT 51
37479: PUSH
37480: LD_EXP 63
37484: PUSH
37485: LD_INT 12
37487: PUSH
37488: LD_INT 30
37490: PUSH
37491: LD_EXP 62
37495: PUSH
37496: LD_INT 11
37498: PUSH
37499: LD_INT 53
37501: PUSH
37502: LD_INT 14
37504: PUSH
37505: LD_EXP 66
37509: PUSH
37510: LD_INT 29
37512: PUSH
37513: LD_EXP 64
37517: PUSH
37518: LD_INT 13
37520: PUSH
37521: LD_INT 52
37523: PUSH
37524: LD_INT 48
37526: PUSH
37527: LD_INT 8
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: IN
37549: NOT
37550: AND
37551: IFFALSE 37592
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
37553: LD_ADDR_EXP 91
37557: PUSH
37558: LD_EXP 91
37562: PPUSH
37563: LD_VAR 0 4
37567: PPUSH
37568: LD_EXP 91
37572: PUSH
37573: LD_VAR 0 4
37577: ARRAY
37578: PUSH
37579: LD_VAR 0 1
37583: ADD
37584: PPUSH
37585: CALL_OW 1
37589: ST_TO_ADDR
37590: GO 37636
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
37592: LD_ADDR_EXP 88
37596: PUSH
37597: LD_EXP 88
37601: PPUSH
37602: LD_VAR 0 4
37606: PUSH
37607: LD_EXP 88
37611: PUSH
37612: LD_VAR 0 4
37616: ARRAY
37617: PUSH
37618: LD_INT 1
37620: PLUS
37621: PUSH
37622: EMPTY
37623: LIST
37624: LIST
37625: PPUSH
37626: LD_VAR 0 1
37630: PPUSH
37631: CALL 47738 0 3
37635: ST_TO_ADDR
// if not mc_scan [ i ] then
37636: LD_EXP 92
37640: PUSH
37641: LD_VAR 0 4
37645: ARRAY
37646: NOT
37647: IFFALSE 37766
// begin if GetControl ( vehicle ) = control_remote then
37649: LD_VAR 0 1
37653: PPUSH
37654: CALL_OW 263
37658: PUSH
37659: LD_INT 2
37661: EQUAL
37662: IFFALSE 37682
// repeat wait ( 0 0$1 ) ;
37664: LD_INT 35
37666: PPUSH
37667: CALL_OW 67
// until IsControledBy ( vehicle ) ;
37671: LD_VAR 0 1
37675: PPUSH
37676: CALL_OW 312
37680: IFFALSE 37664
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
37682: LD_VAR 0 1
37686: PPUSH
37687: LD_EXP 93
37691: PUSH
37692: LD_VAR 0 4
37696: ARRAY
37697: PPUSH
37698: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
37702: LD_VAR 0 1
37706: PPUSH
37707: CALL_OW 263
37711: PUSH
37712: LD_INT 1
37714: NONEQUAL
37715: IFFALSE 37719
// break ;
37717: GO 37768
// repeat wait ( 0 0$1 ) ;
37719: LD_INT 35
37721: PPUSH
37722: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
37726: LD_VAR 0 1
37730: PPUSH
37731: LD_EXP 93
37735: PUSH
37736: LD_VAR 0 4
37740: ARRAY
37741: PPUSH
37742: CALL_OW 308
37746: IFFALSE 37719
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
37748: LD_VAR 0 1
37752: PPUSH
37753: CALL_OW 311
37757: PPUSH
37758: CALL_OW 121
// exit ;
37762: POP
37763: POP
37764: GO 37770
// end ; end ; end ;
37766: GO 37417
37768: POP
37769: POP
// end ;
37770: LD_VAR 0 3
37774: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
37775: LD_INT 0
37777: PPUSH
37778: PPUSH
37779: PPUSH
37780: PPUSH
// if not mc_bases or not skirmish then
37781: LD_EXP 69
37785: NOT
37786: PUSH
37787: LD_EXP 67
37791: NOT
37792: OR
37793: IFFALSE 37797
// exit ;
37795: GO 38150
// repeat wait ( 0 0$1 ) ;
37797: LD_INT 35
37799: PPUSH
37800: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
37804: LD_VAR 0 2
37808: PPUSH
37809: LD_VAR 0 3
37813: PPUSH
37814: CALL_OW 284
37818: IFFALSE 37797
// if GetResourceTypeXY ( x , y ) = mat_artefact then
37820: LD_VAR 0 2
37824: PPUSH
37825: LD_VAR 0 3
37829: PPUSH
37830: CALL_OW 283
37834: PUSH
37835: LD_INT 4
37837: EQUAL
37838: IFFALSE 37842
// exit ;
37840: GO 38150
// for i = 1 to mc_bases do
37842: LD_ADDR_VAR 0 7
37846: PUSH
37847: DOUBLE
37848: LD_INT 1
37850: DEC
37851: ST_TO_ADDR
37852: LD_EXP 69
37856: PUSH
37857: FOR_TO
37858: IFFALSE 38148
// begin if mc_crates_area [ i ] then
37860: LD_EXP 87
37864: PUSH
37865: LD_VAR 0 7
37869: ARRAY
37870: IFFALSE 37981
// for j in mc_crates_area [ i ] do
37872: LD_ADDR_VAR 0 8
37876: PUSH
37877: LD_EXP 87
37881: PUSH
37882: LD_VAR 0 7
37886: ARRAY
37887: PUSH
37888: FOR_IN
37889: IFFALSE 37979
// if InArea ( x , y , j ) then
37891: LD_VAR 0 2
37895: PPUSH
37896: LD_VAR 0 3
37900: PPUSH
37901: LD_VAR 0 8
37905: PPUSH
37906: CALL_OW 309
37910: IFFALSE 37977
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
37912: LD_ADDR_EXP 85
37916: PUSH
37917: LD_EXP 85
37921: PPUSH
37922: LD_VAR 0 7
37926: PUSH
37927: LD_EXP 85
37931: PUSH
37932: LD_VAR 0 7
37936: ARRAY
37937: PUSH
37938: LD_INT 1
37940: PLUS
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PPUSH
37946: LD_VAR 0 4
37950: PUSH
37951: LD_VAR 0 2
37955: PUSH
37956: LD_VAR 0 3
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: LIST
37965: PPUSH
37966: CALL 47738 0 3
37970: ST_TO_ADDR
// exit ;
37971: POP
37972: POP
37973: POP
37974: POP
37975: GO 38150
// end ;
37977: GO 37888
37979: POP
37980: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37981: LD_ADDR_VAR 0 9
37985: PUSH
37986: LD_EXP 69
37990: PUSH
37991: LD_VAR 0 7
37995: ARRAY
37996: PPUSH
37997: LD_INT 2
37999: PUSH
38000: LD_INT 30
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 30
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: LIST
38024: PPUSH
38025: CALL_OW 72
38029: ST_TO_ADDR
// if not depot then
38030: LD_VAR 0 9
38034: NOT
38035: IFFALSE 38039
// continue ;
38037: GO 37857
// for j in depot do
38039: LD_ADDR_VAR 0 8
38043: PUSH
38044: LD_VAR 0 9
38048: PUSH
38049: FOR_IN
38050: IFFALSE 38144
// if GetDistUnitXY ( j , x , y ) < 30 then
38052: LD_VAR 0 8
38056: PPUSH
38057: LD_VAR 0 2
38061: PPUSH
38062: LD_VAR 0 3
38066: PPUSH
38067: CALL_OW 297
38071: PUSH
38072: LD_INT 30
38074: LESS
38075: IFFALSE 38142
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
38077: LD_ADDR_EXP 85
38081: PUSH
38082: LD_EXP 85
38086: PPUSH
38087: LD_VAR 0 7
38091: PUSH
38092: LD_EXP 85
38096: PUSH
38097: LD_VAR 0 7
38101: ARRAY
38102: PUSH
38103: LD_INT 1
38105: PLUS
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PPUSH
38111: LD_VAR 0 4
38115: PUSH
38116: LD_VAR 0 2
38120: PUSH
38121: LD_VAR 0 3
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: LIST
38130: PPUSH
38131: CALL 47738 0 3
38135: ST_TO_ADDR
// exit ;
38136: POP
38137: POP
38138: POP
38139: POP
38140: GO 38150
// end ;
38142: GO 38049
38144: POP
38145: POP
// end ;
38146: GO 37857
38148: POP
38149: POP
// end ;
38150: LD_VAR 0 6
38154: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
38155: LD_INT 0
38157: PPUSH
38158: PPUSH
38159: PPUSH
38160: PPUSH
// if not mc_bases or not skirmish then
38161: LD_EXP 69
38165: NOT
38166: PUSH
38167: LD_EXP 67
38171: NOT
38172: OR
38173: IFFALSE 38177
// exit ;
38175: GO 38454
// side := GetSide ( lab ) ;
38177: LD_ADDR_VAR 0 4
38181: PUSH
38182: LD_VAR 0 2
38186: PPUSH
38187: CALL_OW 255
38191: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
38192: LD_VAR 0 4
38196: PUSH
38197: LD_EXP 95
38201: IN
38202: NOT
38203: PUSH
38204: LD_EXP 96
38208: NOT
38209: OR
38210: PUSH
38211: LD_EXP 69
38215: NOT
38216: OR
38217: IFFALSE 38221
// exit ;
38219: GO 38454
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
38221: LD_ADDR_EXP 96
38225: PUSH
38226: LD_EXP 96
38230: PPUSH
38231: LD_VAR 0 4
38235: PPUSH
38236: LD_EXP 96
38240: PUSH
38241: LD_VAR 0 4
38245: ARRAY
38246: PUSH
38247: LD_VAR 0 1
38251: DIFF
38252: PPUSH
38253: CALL_OW 1
38257: ST_TO_ADDR
// for i = 1 to mc_bases do
38258: LD_ADDR_VAR 0 5
38262: PUSH
38263: DOUBLE
38264: LD_INT 1
38266: DEC
38267: ST_TO_ADDR
38268: LD_EXP 69
38272: PUSH
38273: FOR_TO
38274: IFFALSE 38452
// begin if lab in mc_bases [ i ] then
38276: LD_VAR 0 2
38280: PUSH
38281: LD_EXP 69
38285: PUSH
38286: LD_VAR 0 5
38290: ARRAY
38291: IN
38292: IFFALSE 38450
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
38294: LD_VAR 0 1
38298: PUSH
38299: LD_INT 11
38301: PUSH
38302: LD_INT 4
38304: PUSH
38305: LD_INT 3
38307: PUSH
38308: LD_INT 2
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: IN
38317: PUSH
38318: LD_EXP 99
38322: PUSH
38323: LD_VAR 0 5
38327: ARRAY
38328: AND
38329: IFFALSE 38450
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
38331: LD_ADDR_VAR 0 6
38335: PUSH
38336: LD_EXP 99
38340: PUSH
38341: LD_VAR 0 5
38345: ARRAY
38346: PUSH
38347: LD_INT 1
38349: ARRAY
38350: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38351: LD_ADDR_EXP 99
38355: PUSH
38356: LD_EXP 99
38360: PPUSH
38361: LD_VAR 0 5
38365: PPUSH
38366: EMPTY
38367: PPUSH
38368: CALL_OW 1
38372: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
38373: LD_VAR 0 6
38377: PPUSH
38378: LD_INT 0
38380: PPUSH
38381: CALL_OW 109
// ComExitBuilding ( tmp ) ;
38385: LD_VAR 0 6
38389: PPUSH
38390: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
38394: LD_ADDR_EXP 98
38398: PUSH
38399: LD_EXP 98
38403: PPUSH
38404: LD_VAR 0 5
38408: PPUSH
38409: LD_EXP 98
38413: PUSH
38414: LD_VAR 0 5
38418: ARRAY
38419: PPUSH
38420: LD_INT 1
38422: PPUSH
38423: LD_VAR 0 6
38427: PPUSH
38428: CALL_OW 2
38432: PPUSH
38433: CALL_OW 1
38437: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
38438: LD_VAR 0 5
38442: PPUSH
38443: LD_INT 112
38445: PPUSH
38446: CALL 16381 0 2
// end ; end ; end ;
38450: GO 38273
38452: POP
38453: POP
// end ;
38454: LD_VAR 0 3
38458: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
38459: LD_INT 0
38461: PPUSH
38462: PPUSH
38463: PPUSH
38464: PPUSH
38465: PPUSH
38466: PPUSH
38467: PPUSH
38468: PPUSH
// if not mc_bases or not skirmish then
38469: LD_EXP 69
38473: NOT
38474: PUSH
38475: LD_EXP 67
38479: NOT
38480: OR
38481: IFFALSE 38485
// exit ;
38483: GO 39428
// for i = 1 to mc_bases do
38485: LD_ADDR_VAR 0 3
38489: PUSH
38490: DOUBLE
38491: LD_INT 1
38493: DEC
38494: ST_TO_ADDR
38495: LD_EXP 69
38499: PUSH
38500: FOR_TO
38501: IFFALSE 39426
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
38503: LD_VAR 0 1
38507: PUSH
38508: LD_EXP 69
38512: PUSH
38513: LD_VAR 0 3
38517: ARRAY
38518: IN
38519: PUSH
38520: LD_VAR 0 1
38524: PUSH
38525: LD_EXP 76
38529: PUSH
38530: LD_VAR 0 3
38534: ARRAY
38535: IN
38536: OR
38537: PUSH
38538: LD_VAR 0 1
38542: PUSH
38543: LD_EXP 88
38547: PUSH
38548: LD_VAR 0 3
38552: ARRAY
38553: IN
38554: OR
38555: PUSH
38556: LD_VAR 0 1
38560: PUSH
38561: LD_EXP 98
38565: PUSH
38566: LD_VAR 0 3
38570: ARRAY
38571: IN
38572: OR
38573: PUSH
38574: LD_VAR 0 1
38578: PUSH
38579: LD_EXP 99
38583: PUSH
38584: LD_VAR 0 3
38588: ARRAY
38589: IN
38590: OR
38591: IFFALSE 39424
// begin if un in mc_ape [ i ] then
38593: LD_VAR 0 1
38597: PUSH
38598: LD_EXP 98
38602: PUSH
38603: LD_VAR 0 3
38607: ARRAY
38608: IN
38609: IFFALSE 38648
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
38611: LD_ADDR_EXP 98
38615: PUSH
38616: LD_EXP 98
38620: PPUSH
38621: LD_VAR 0 3
38625: PPUSH
38626: LD_EXP 98
38630: PUSH
38631: LD_VAR 0 3
38635: ARRAY
38636: PUSH
38637: LD_VAR 0 1
38641: DIFF
38642: PPUSH
38643: CALL_OW 1
38647: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
38648: LD_VAR 0 1
38652: PUSH
38653: LD_EXP 99
38657: PUSH
38658: LD_VAR 0 3
38662: ARRAY
38663: IN
38664: IFFALSE 38688
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38666: LD_ADDR_EXP 99
38670: PUSH
38671: LD_EXP 99
38675: PPUSH
38676: LD_VAR 0 3
38680: PPUSH
38681: EMPTY
38682: PPUSH
38683: CALL_OW 1
38687: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
38688: LD_VAR 0 1
38692: PPUSH
38693: CALL_OW 247
38697: PUSH
38698: LD_INT 2
38700: EQUAL
38701: PUSH
38702: LD_VAR 0 1
38706: PPUSH
38707: CALL_OW 110
38711: PUSH
38712: LD_INT 20
38714: EQUAL
38715: AND
38716: IFFALSE 38819
// begin fac := MC_GetBuilding ( i , b_factory ) ;
38718: LD_ADDR_VAR 0 8
38722: PUSH
38723: LD_VAR 0 3
38727: PPUSH
38728: LD_INT 3
38730: PPUSH
38731: CALL 35689 0 2
38735: ST_TO_ADDR
// if fac then
38736: LD_VAR 0 8
38740: IFFALSE 38819
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
38742: LD_ADDR_VAR 0 9
38746: PUSH
38747: LD_VAR 0 8
38751: PPUSH
38752: LD_VAR 0 1
38756: PPUSH
38757: CALL_OW 265
38761: PPUSH
38762: LD_VAR 0 1
38766: PPUSH
38767: CALL_OW 262
38771: PPUSH
38772: LD_VAR 0 1
38776: PPUSH
38777: CALL_OW 263
38781: PPUSH
38782: LD_VAR 0 1
38786: PPUSH
38787: CALL_OW 264
38791: PPUSH
38792: CALL 45338 0 5
38796: ST_TO_ADDR
// if components then
38797: LD_VAR 0 9
38801: IFFALSE 38817
// MC_InsertProduceList ( i , components ) ;
38803: LD_VAR 0 3
38807: PPUSH
38808: LD_VAR 0 9
38812: PPUSH
38813: CALL 35259 0 2
// break ;
38817: GO 39426
// end ; end ; if GetType ( un ) = unit_building then
38819: LD_VAR 0 1
38823: PPUSH
38824: CALL_OW 247
38828: PUSH
38829: LD_INT 3
38831: EQUAL
38832: IFFALSE 39147
// begin btype := GetBType ( un ) ;
38834: LD_ADDR_VAR 0 5
38838: PUSH
38839: LD_VAR 0 1
38843: PPUSH
38844: CALL_OW 266
38848: ST_TO_ADDR
// if btype = b_warehouse then
38849: LD_VAR 0 5
38853: PUSH
38854: LD_INT 1
38856: EQUAL
38857: IFFALSE 38875
// begin btype := b_depot ;
38859: LD_ADDR_VAR 0 5
38863: PUSH
38864: LD_INT 0
38866: ST_TO_ADDR
// pos := 1 ;
38867: LD_ADDR_VAR 0 6
38871: PUSH
38872: LD_INT 1
38874: ST_TO_ADDR
// end ; if btype = b_factory then
38875: LD_VAR 0 5
38879: PUSH
38880: LD_INT 3
38882: EQUAL
38883: IFFALSE 38901
// begin btype := b_workshop ;
38885: LD_ADDR_VAR 0 5
38889: PUSH
38890: LD_INT 2
38892: ST_TO_ADDR
// pos := 1 ;
38893: LD_ADDR_VAR 0 6
38897: PUSH
38898: LD_INT 1
38900: ST_TO_ADDR
// end ; if btype = b_barracks then
38901: LD_VAR 0 5
38905: PUSH
38906: LD_INT 5
38908: EQUAL
38909: IFFALSE 38919
// btype := b_armoury ;
38911: LD_ADDR_VAR 0 5
38915: PUSH
38916: LD_INT 4
38918: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
38919: LD_VAR 0 5
38923: PUSH
38924: LD_INT 7
38926: PUSH
38927: LD_INT 8
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: IN
38934: IFFALSE 38944
// btype := b_lab ;
38936: LD_ADDR_VAR 0 5
38940: PUSH
38941: LD_INT 6
38943: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
38944: LD_ADDR_EXP 74
38948: PUSH
38949: LD_EXP 74
38953: PPUSH
38954: LD_VAR 0 3
38958: PUSH
38959: LD_EXP 74
38963: PUSH
38964: LD_VAR 0 3
38968: ARRAY
38969: PUSH
38970: LD_INT 1
38972: PLUS
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PPUSH
38978: LD_VAR 0 5
38982: PUSH
38983: LD_VAR 0 1
38987: PPUSH
38988: CALL_OW 250
38992: PUSH
38993: LD_VAR 0 1
38997: PPUSH
38998: CALL_OW 251
39002: PUSH
39003: LD_VAR 0 1
39007: PPUSH
39008: CALL_OW 254
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: PPUSH
39019: CALL 47738 0 3
39023: ST_TO_ADDR
// if pos = 1 then
39024: LD_VAR 0 6
39028: PUSH
39029: LD_INT 1
39031: EQUAL
39032: IFFALSE 39147
// begin tmp := mc_build_list [ i ] ;
39034: LD_ADDR_VAR 0 7
39038: PUSH
39039: LD_EXP 74
39043: PUSH
39044: LD_VAR 0 3
39048: ARRAY
39049: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39050: LD_VAR 0 7
39054: PPUSH
39055: LD_INT 2
39057: PUSH
39058: LD_INT 30
39060: PUSH
39061: LD_INT 0
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 30
39070: PUSH
39071: LD_INT 1
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: LIST
39082: PPUSH
39083: CALL_OW 72
39087: IFFALSE 39097
// pos := 2 ;
39089: LD_ADDR_VAR 0 6
39093: PUSH
39094: LD_INT 2
39096: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
39097: LD_ADDR_VAR 0 7
39101: PUSH
39102: LD_VAR 0 7
39106: PPUSH
39107: LD_VAR 0 6
39111: PPUSH
39112: LD_VAR 0 7
39116: PPUSH
39117: CALL 48064 0 3
39121: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
39122: LD_ADDR_EXP 74
39126: PUSH
39127: LD_EXP 74
39131: PPUSH
39132: LD_VAR 0 3
39136: PPUSH
39137: LD_VAR 0 7
39141: PPUSH
39142: CALL_OW 1
39146: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
39147: LD_VAR 0 1
39151: PUSH
39152: LD_EXP 69
39156: PUSH
39157: LD_VAR 0 3
39161: ARRAY
39162: IN
39163: IFFALSE 39202
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
39165: LD_ADDR_EXP 69
39169: PUSH
39170: LD_EXP 69
39174: PPUSH
39175: LD_VAR 0 3
39179: PPUSH
39180: LD_EXP 69
39184: PUSH
39185: LD_VAR 0 3
39189: ARRAY
39190: PUSH
39191: LD_VAR 0 1
39195: DIFF
39196: PPUSH
39197: CALL_OW 1
39201: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
39202: LD_VAR 0 1
39206: PUSH
39207: LD_EXP 76
39211: PUSH
39212: LD_VAR 0 3
39216: ARRAY
39217: IN
39218: IFFALSE 39257
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
39220: LD_ADDR_EXP 76
39224: PUSH
39225: LD_EXP 76
39229: PPUSH
39230: LD_VAR 0 3
39234: PPUSH
39235: LD_EXP 76
39239: PUSH
39240: LD_VAR 0 3
39244: ARRAY
39245: PUSH
39246: LD_VAR 0 1
39250: DIFF
39251: PPUSH
39252: CALL_OW 1
39256: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
39257: LD_VAR 0 1
39261: PUSH
39262: LD_EXP 88
39266: PUSH
39267: LD_VAR 0 3
39271: ARRAY
39272: IN
39273: IFFALSE 39312
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
39275: LD_ADDR_EXP 88
39279: PUSH
39280: LD_EXP 88
39284: PPUSH
39285: LD_VAR 0 3
39289: PPUSH
39290: LD_EXP 88
39294: PUSH
39295: LD_VAR 0 3
39299: ARRAY
39300: PUSH
39301: LD_VAR 0 1
39305: DIFF
39306: PPUSH
39307: CALL_OW 1
39311: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
39312: LD_VAR 0 1
39316: PUSH
39317: LD_EXP 78
39321: PUSH
39322: LD_VAR 0 3
39326: ARRAY
39327: IN
39328: IFFALSE 39367
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
39330: LD_ADDR_EXP 78
39334: PUSH
39335: LD_EXP 78
39339: PPUSH
39340: LD_VAR 0 3
39344: PPUSH
39345: LD_EXP 78
39349: PUSH
39350: LD_VAR 0 3
39354: ARRAY
39355: PUSH
39356: LD_VAR 0 1
39360: DIFF
39361: PPUSH
39362: CALL_OW 1
39366: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
39367: LD_VAR 0 1
39371: PUSH
39372: LD_EXP 77
39376: PUSH
39377: LD_VAR 0 3
39381: ARRAY
39382: IN
39383: IFFALSE 39422
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
39385: LD_ADDR_EXP 77
39389: PUSH
39390: LD_EXP 77
39394: PPUSH
39395: LD_VAR 0 3
39399: PPUSH
39400: LD_EXP 77
39404: PUSH
39405: LD_VAR 0 3
39409: ARRAY
39410: PUSH
39411: LD_VAR 0 1
39415: DIFF
39416: PPUSH
39417: CALL_OW 1
39421: ST_TO_ADDR
// end ; break ;
39422: GO 39426
// end ;
39424: GO 38500
39426: POP
39427: POP
// end ;
39428: LD_VAR 0 2
39432: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
39433: LD_INT 0
39435: PPUSH
39436: PPUSH
39437: PPUSH
// if not mc_bases or not skirmish then
39438: LD_EXP 69
39442: NOT
39443: PUSH
39444: LD_EXP 67
39448: NOT
39449: OR
39450: IFFALSE 39454
// exit ;
39452: GO 39669
// for i = 1 to mc_bases do
39454: LD_ADDR_VAR 0 3
39458: PUSH
39459: DOUBLE
39460: LD_INT 1
39462: DEC
39463: ST_TO_ADDR
39464: LD_EXP 69
39468: PUSH
39469: FOR_TO
39470: IFFALSE 39667
// begin if building in mc_construct_list [ i ] then
39472: LD_VAR 0 1
39476: PUSH
39477: LD_EXP 76
39481: PUSH
39482: LD_VAR 0 3
39486: ARRAY
39487: IN
39488: IFFALSE 39665
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
39490: LD_ADDR_EXP 76
39494: PUSH
39495: LD_EXP 76
39499: PPUSH
39500: LD_VAR 0 3
39504: PPUSH
39505: LD_EXP 76
39509: PUSH
39510: LD_VAR 0 3
39514: ARRAY
39515: PUSH
39516: LD_VAR 0 1
39520: DIFF
39521: PPUSH
39522: CALL_OW 1
39526: ST_TO_ADDR
// if building in mc_lab [ i ] then
39527: LD_VAR 0 1
39531: PUSH
39532: LD_EXP 102
39536: PUSH
39537: LD_VAR 0 3
39541: ARRAY
39542: IN
39543: IFFALSE 39598
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
39545: LD_ADDR_EXP 103
39549: PUSH
39550: LD_EXP 103
39554: PPUSH
39555: LD_VAR 0 3
39559: PPUSH
39560: LD_EXP 103
39564: PUSH
39565: LD_VAR 0 3
39569: ARRAY
39570: PPUSH
39571: LD_INT 1
39573: PPUSH
39574: LD_EXP 103
39578: PUSH
39579: LD_VAR 0 3
39583: ARRAY
39584: PPUSH
39585: LD_INT 0
39587: PPUSH
39588: CALL 47156 0 4
39592: PPUSH
39593: CALL_OW 1
39597: ST_TO_ADDR
// if not building in mc_bases [ i ] then
39598: LD_VAR 0 1
39602: PUSH
39603: LD_EXP 69
39607: PUSH
39608: LD_VAR 0 3
39612: ARRAY
39613: IN
39614: NOT
39615: IFFALSE 39661
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
39617: LD_ADDR_EXP 69
39621: PUSH
39622: LD_EXP 69
39626: PPUSH
39627: LD_VAR 0 3
39631: PUSH
39632: LD_EXP 69
39636: PUSH
39637: LD_VAR 0 3
39641: ARRAY
39642: PUSH
39643: LD_INT 1
39645: PLUS
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PPUSH
39651: LD_VAR 0 1
39655: PPUSH
39656: CALL 47738 0 3
39660: ST_TO_ADDR
// exit ;
39661: POP
39662: POP
39663: GO 39669
// end ; end ;
39665: GO 39469
39667: POP
39668: POP
// end ;
39669: LD_VAR 0 2
39673: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
39674: LD_INT 0
39676: PPUSH
39677: PPUSH
39678: PPUSH
39679: PPUSH
39680: PPUSH
39681: PPUSH
39682: PPUSH
// if not mc_bases or not skirmish then
39683: LD_EXP 69
39687: NOT
39688: PUSH
39689: LD_EXP 67
39693: NOT
39694: OR
39695: IFFALSE 39699
// exit ;
39697: GO 40360
// for i = 1 to mc_bases do
39699: LD_ADDR_VAR 0 3
39703: PUSH
39704: DOUBLE
39705: LD_INT 1
39707: DEC
39708: ST_TO_ADDR
39709: LD_EXP 69
39713: PUSH
39714: FOR_TO
39715: IFFALSE 40358
// begin if building in mc_construct_list [ i ] then
39717: LD_VAR 0 1
39721: PUSH
39722: LD_EXP 76
39726: PUSH
39727: LD_VAR 0 3
39731: ARRAY
39732: IN
39733: IFFALSE 40356
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
39735: LD_ADDR_EXP 76
39739: PUSH
39740: LD_EXP 76
39744: PPUSH
39745: LD_VAR 0 3
39749: PPUSH
39750: LD_EXP 76
39754: PUSH
39755: LD_VAR 0 3
39759: ARRAY
39760: PUSH
39761: LD_VAR 0 1
39765: DIFF
39766: PPUSH
39767: CALL_OW 1
39771: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
39772: LD_ADDR_EXP 69
39776: PUSH
39777: LD_EXP 69
39781: PPUSH
39782: LD_VAR 0 3
39786: PUSH
39787: LD_EXP 69
39791: PUSH
39792: LD_VAR 0 3
39796: ARRAY
39797: PUSH
39798: LD_INT 1
39800: PLUS
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PPUSH
39806: LD_VAR 0 1
39810: PPUSH
39811: CALL 47738 0 3
39815: ST_TO_ADDR
// btype := GetBType ( building ) ;
39816: LD_ADDR_VAR 0 5
39820: PUSH
39821: LD_VAR 0 1
39825: PPUSH
39826: CALL_OW 266
39830: ST_TO_ADDR
// side := GetSide ( building ) ;
39831: LD_ADDR_VAR 0 8
39835: PUSH
39836: LD_VAR 0 1
39840: PPUSH
39841: CALL_OW 255
39845: ST_TO_ADDR
// if btype = b_lab then
39846: LD_VAR 0 5
39850: PUSH
39851: LD_INT 6
39853: EQUAL
39854: IFFALSE 39904
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
39856: LD_ADDR_EXP 102
39860: PUSH
39861: LD_EXP 102
39865: PPUSH
39866: LD_VAR 0 3
39870: PUSH
39871: LD_EXP 102
39875: PUSH
39876: LD_VAR 0 3
39880: ARRAY
39881: PUSH
39882: LD_INT 1
39884: PLUS
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: PPUSH
39890: LD_VAR 0 1
39894: PPUSH
39895: CALL 47738 0 3
39899: ST_TO_ADDR
// exit ;
39900: POP
39901: POP
39902: GO 40360
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
39904: LD_VAR 0 5
39908: PUSH
39909: LD_INT 0
39911: PUSH
39912: LD_INT 2
39914: PUSH
39915: LD_INT 4
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: LIST
39922: IN
39923: IFFALSE 40047
// begin if btype = b_armoury then
39925: LD_VAR 0 5
39929: PUSH
39930: LD_INT 4
39932: EQUAL
39933: IFFALSE 39943
// btype := b_barracks ;
39935: LD_ADDR_VAR 0 5
39939: PUSH
39940: LD_INT 5
39942: ST_TO_ADDR
// if btype = b_depot then
39943: LD_VAR 0 5
39947: PUSH
39948: LD_INT 0
39950: EQUAL
39951: IFFALSE 39961
// btype := b_warehouse ;
39953: LD_ADDR_VAR 0 5
39957: PUSH
39958: LD_INT 1
39960: ST_TO_ADDR
// if btype = b_workshop then
39961: LD_VAR 0 5
39965: PUSH
39966: LD_INT 2
39968: EQUAL
39969: IFFALSE 39979
// btype := b_factory ;
39971: LD_ADDR_VAR 0 5
39975: PUSH
39976: LD_INT 3
39978: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
39979: LD_VAR 0 5
39983: PPUSH
39984: LD_VAR 0 8
39988: PPUSH
39989: CALL_OW 323
39993: PUSH
39994: LD_INT 1
39996: EQUAL
39997: IFFALSE 40043
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
39999: LD_ADDR_EXP 101
40003: PUSH
40004: LD_EXP 101
40008: PPUSH
40009: LD_VAR 0 3
40013: PUSH
40014: LD_EXP 101
40018: PUSH
40019: LD_VAR 0 3
40023: ARRAY
40024: PUSH
40025: LD_INT 1
40027: PLUS
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PPUSH
40033: LD_VAR 0 1
40037: PPUSH
40038: CALL 47738 0 3
40042: ST_TO_ADDR
// exit ;
40043: POP
40044: POP
40045: GO 40360
// end ; if btype in [ b_bunker , b_turret ] then
40047: LD_VAR 0 5
40051: PUSH
40052: LD_INT 32
40054: PUSH
40055: LD_INT 33
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: IN
40062: IFFALSE 40352
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
40064: LD_ADDR_EXP 77
40068: PUSH
40069: LD_EXP 77
40073: PPUSH
40074: LD_VAR 0 3
40078: PUSH
40079: LD_EXP 77
40083: PUSH
40084: LD_VAR 0 3
40088: ARRAY
40089: PUSH
40090: LD_INT 1
40092: PLUS
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PPUSH
40098: LD_VAR 0 1
40102: PPUSH
40103: CALL 47738 0 3
40107: ST_TO_ADDR
// if btype = b_bunker then
40108: LD_VAR 0 5
40112: PUSH
40113: LD_INT 32
40115: EQUAL
40116: IFFALSE 40352
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
40118: LD_ADDR_EXP 78
40122: PUSH
40123: LD_EXP 78
40127: PPUSH
40128: LD_VAR 0 3
40132: PUSH
40133: LD_EXP 78
40137: PUSH
40138: LD_VAR 0 3
40142: ARRAY
40143: PUSH
40144: LD_INT 1
40146: PLUS
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PPUSH
40152: LD_VAR 0 1
40156: PPUSH
40157: CALL 47738 0 3
40161: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
40162: LD_ADDR_VAR 0 6
40166: PUSH
40167: LD_EXP 69
40171: PUSH
40172: LD_VAR 0 3
40176: ARRAY
40177: PPUSH
40178: LD_INT 25
40180: PUSH
40181: LD_INT 1
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 3
40190: PUSH
40191: LD_INT 54
40193: PUSH
40194: EMPTY
40195: LIST
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PPUSH
40205: CALL_OW 72
40209: ST_TO_ADDR
// if tmp then
40210: LD_VAR 0 6
40214: IFFALSE 40220
// exit ;
40216: POP
40217: POP
40218: GO 40360
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40220: LD_ADDR_VAR 0 6
40224: PUSH
40225: LD_EXP 69
40229: PUSH
40230: LD_VAR 0 3
40234: ARRAY
40235: PPUSH
40236: LD_INT 2
40238: PUSH
40239: LD_INT 30
40241: PUSH
40242: LD_INT 4
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 30
40251: PUSH
40252: LD_INT 5
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: LIST
40263: PPUSH
40264: CALL_OW 72
40268: ST_TO_ADDR
// if not tmp then
40269: LD_VAR 0 6
40273: NOT
40274: IFFALSE 40280
// exit ;
40276: POP
40277: POP
40278: GO 40360
// for j in tmp do
40280: LD_ADDR_VAR 0 4
40284: PUSH
40285: LD_VAR 0 6
40289: PUSH
40290: FOR_IN
40291: IFFALSE 40350
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
40293: LD_ADDR_VAR 0 7
40297: PUSH
40298: LD_VAR 0 4
40302: PPUSH
40303: CALL_OW 313
40307: PPUSH
40308: LD_INT 25
40310: PUSH
40311: LD_INT 1
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PPUSH
40318: CALL_OW 72
40322: ST_TO_ADDR
// if units then
40323: LD_VAR 0 7
40327: IFFALSE 40348
// begin ComExitBuilding ( units [ 1 ] ) ;
40329: LD_VAR 0 7
40333: PUSH
40334: LD_INT 1
40336: ARRAY
40337: PPUSH
40338: CALL_OW 122
// exit ;
40342: POP
40343: POP
40344: POP
40345: POP
40346: GO 40360
// end ; end ;
40348: GO 40290
40350: POP
40351: POP
// end ; end ; exit ;
40352: POP
40353: POP
40354: GO 40360
// end ; end ;
40356: GO 39714
40358: POP
40359: POP
// end ;
40360: LD_VAR 0 2
40364: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
40365: LD_INT 0
40367: PPUSH
40368: PPUSH
40369: PPUSH
40370: PPUSH
40371: PPUSH
40372: PPUSH
40373: PPUSH
// if not mc_bases or not skirmish then
40374: LD_EXP 69
40378: NOT
40379: PUSH
40380: LD_EXP 67
40384: NOT
40385: OR
40386: IFFALSE 40390
// exit ;
40388: GO 40621
// btype := GetBType ( building ) ;
40390: LD_ADDR_VAR 0 6
40394: PUSH
40395: LD_VAR 0 1
40399: PPUSH
40400: CALL_OW 266
40404: ST_TO_ADDR
// x := GetX ( building ) ;
40405: LD_ADDR_VAR 0 7
40409: PUSH
40410: LD_VAR 0 1
40414: PPUSH
40415: CALL_OW 250
40419: ST_TO_ADDR
// y := GetY ( building ) ;
40420: LD_ADDR_VAR 0 8
40424: PUSH
40425: LD_VAR 0 1
40429: PPUSH
40430: CALL_OW 251
40434: ST_TO_ADDR
// d := GetDir ( building ) ;
40435: LD_ADDR_VAR 0 9
40439: PUSH
40440: LD_VAR 0 1
40444: PPUSH
40445: CALL_OW 254
40449: ST_TO_ADDR
// for i = 1 to mc_bases do
40450: LD_ADDR_VAR 0 4
40454: PUSH
40455: DOUBLE
40456: LD_INT 1
40458: DEC
40459: ST_TO_ADDR
40460: LD_EXP 69
40464: PUSH
40465: FOR_TO
40466: IFFALSE 40619
// begin if not mc_build_list [ i ] then
40468: LD_EXP 74
40472: PUSH
40473: LD_VAR 0 4
40477: ARRAY
40478: NOT
40479: IFFALSE 40483
// continue ;
40481: GO 40465
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
40483: LD_VAR 0 6
40487: PUSH
40488: LD_VAR 0 7
40492: PUSH
40493: LD_VAR 0 8
40497: PUSH
40498: LD_VAR 0 9
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: PPUSH
40509: LD_EXP 74
40513: PUSH
40514: LD_VAR 0 4
40518: ARRAY
40519: PUSH
40520: LD_INT 1
40522: ARRAY
40523: PPUSH
40524: CALL 53907 0 2
40528: IFFALSE 40617
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
40530: LD_ADDR_EXP 74
40534: PUSH
40535: LD_EXP 74
40539: PPUSH
40540: LD_VAR 0 4
40544: PPUSH
40545: LD_EXP 74
40549: PUSH
40550: LD_VAR 0 4
40554: ARRAY
40555: PPUSH
40556: LD_INT 1
40558: PPUSH
40559: CALL_OW 3
40563: PPUSH
40564: CALL_OW 1
40568: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
40569: LD_ADDR_EXP 76
40573: PUSH
40574: LD_EXP 76
40578: PPUSH
40579: LD_VAR 0 4
40583: PUSH
40584: LD_EXP 76
40588: PUSH
40589: LD_VAR 0 4
40593: ARRAY
40594: PUSH
40595: LD_INT 1
40597: PLUS
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PPUSH
40603: LD_VAR 0 1
40607: PPUSH
40608: CALL 47738 0 3
40612: ST_TO_ADDR
// exit ;
40613: POP
40614: POP
40615: GO 40621
// end ; end ;
40617: GO 40465
40619: POP
40620: POP
// end ;
40621: LD_VAR 0 3
40625: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
40626: LD_INT 0
40628: PPUSH
40629: PPUSH
40630: PPUSH
// if not mc_bases or not skirmish then
40631: LD_EXP 69
40635: NOT
40636: PUSH
40637: LD_EXP 67
40641: NOT
40642: OR
40643: IFFALSE 40647
// exit ;
40645: GO 40837
// for i = 1 to mc_bases do
40647: LD_ADDR_VAR 0 4
40651: PUSH
40652: DOUBLE
40653: LD_INT 1
40655: DEC
40656: ST_TO_ADDR
40657: LD_EXP 69
40661: PUSH
40662: FOR_TO
40663: IFFALSE 40750
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
40665: LD_VAR 0 1
40669: PUSH
40670: LD_EXP 77
40674: PUSH
40675: LD_VAR 0 4
40679: ARRAY
40680: IN
40681: PUSH
40682: LD_VAR 0 1
40686: PUSH
40687: LD_EXP 78
40691: PUSH
40692: LD_VAR 0 4
40696: ARRAY
40697: IN
40698: NOT
40699: AND
40700: IFFALSE 40748
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
40702: LD_ADDR_EXP 78
40706: PUSH
40707: LD_EXP 78
40711: PPUSH
40712: LD_VAR 0 4
40716: PUSH
40717: LD_EXP 78
40721: PUSH
40722: LD_VAR 0 4
40726: ARRAY
40727: PUSH
40728: LD_INT 1
40730: PLUS
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PPUSH
40736: LD_VAR 0 1
40740: PPUSH
40741: CALL 47738 0 3
40745: ST_TO_ADDR
// break ;
40746: GO 40750
// end ; end ;
40748: GO 40662
40750: POP
40751: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
40752: LD_VAR 0 1
40756: PPUSH
40757: CALL_OW 257
40761: PUSH
40762: LD_EXP 95
40766: IN
40767: PUSH
40768: LD_VAR 0 1
40772: PPUSH
40773: CALL_OW 266
40777: PUSH
40778: LD_INT 5
40780: EQUAL
40781: AND
40782: PUSH
40783: LD_VAR 0 2
40787: PPUSH
40788: CALL_OW 110
40792: PUSH
40793: LD_INT 18
40795: NONEQUAL
40796: AND
40797: IFFALSE 40837
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
40799: LD_VAR 0 2
40803: PPUSH
40804: CALL_OW 257
40808: PUSH
40809: LD_INT 5
40811: PUSH
40812: LD_INT 8
40814: PUSH
40815: LD_INT 9
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: LIST
40822: IN
40823: IFFALSE 40837
// SetClass ( unit , 1 ) ;
40825: LD_VAR 0 2
40829: PPUSH
40830: LD_INT 1
40832: PPUSH
40833: CALL_OW 336
// end ;
40837: LD_VAR 0 3
40841: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
40842: LD_INT 0
40844: PPUSH
40845: PPUSH
// if not mc_bases or not skirmish then
40846: LD_EXP 69
40850: NOT
40851: PUSH
40852: LD_EXP 67
40856: NOT
40857: OR
40858: IFFALSE 40862
// exit ;
40860: GO 40978
// if GetLives ( abandoned_vehicle ) > 250 then
40862: LD_VAR 0 2
40866: PPUSH
40867: CALL_OW 256
40871: PUSH
40872: LD_INT 250
40874: GREATER
40875: IFFALSE 40879
// exit ;
40877: GO 40978
// for i = 1 to mc_bases do
40879: LD_ADDR_VAR 0 6
40883: PUSH
40884: DOUBLE
40885: LD_INT 1
40887: DEC
40888: ST_TO_ADDR
40889: LD_EXP 69
40893: PUSH
40894: FOR_TO
40895: IFFALSE 40976
// begin if driver in mc_bases [ i ] then
40897: LD_VAR 0 1
40901: PUSH
40902: LD_EXP 69
40906: PUSH
40907: LD_VAR 0 6
40911: ARRAY
40912: IN
40913: IFFALSE 40974
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
40915: LD_VAR 0 1
40919: PPUSH
40920: LD_EXP 69
40924: PUSH
40925: LD_VAR 0 6
40929: ARRAY
40930: PPUSH
40931: LD_INT 2
40933: PUSH
40934: LD_INT 30
40936: PUSH
40937: LD_INT 0
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 30
40946: PUSH
40947: LD_INT 1
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: LIST
40958: PPUSH
40959: CALL_OW 72
40963: PUSH
40964: LD_INT 1
40966: ARRAY
40967: PPUSH
40968: CALL_OW 112
// break ;
40972: GO 40976
// end ; end ;
40974: GO 40894
40976: POP
40977: POP
// end ; end_of_file
40978: LD_VAR 0 5
40982: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
40983: LD_INT 0
40985: PPUSH
40986: PPUSH
// if exist_mode then
40987: LD_VAR 0 2
40991: IFFALSE 41016
// unit := CreateCharacter ( prefix & ident ) else
40993: LD_ADDR_VAR 0 5
40997: PUSH
40998: LD_VAR 0 3
41002: PUSH
41003: LD_VAR 0 1
41007: STR
41008: PPUSH
41009: CALL_OW 34
41013: ST_TO_ADDR
41014: GO 41031
// unit := NewCharacter ( ident ) ;
41016: LD_ADDR_VAR 0 5
41020: PUSH
41021: LD_VAR 0 1
41025: PPUSH
41026: CALL_OW 25
41030: ST_TO_ADDR
// result := unit ;
41031: LD_ADDR_VAR 0 4
41035: PUSH
41036: LD_VAR 0 5
41040: ST_TO_ADDR
// end ;
41041: LD_VAR 0 4
41045: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
41046: LD_INT 0
41048: PPUSH
41049: PPUSH
// if not side or not nation then
41050: LD_VAR 0 1
41054: NOT
41055: PUSH
41056: LD_VAR 0 2
41060: NOT
41061: OR
41062: IFFALSE 41066
// exit ;
41064: GO 41702
// case nation of nation_american :
41066: LD_VAR 0 2
41070: PUSH
41071: LD_INT 1
41073: DOUBLE
41074: EQUAL
41075: IFTRUE 41079
41077: GO 41249
41079: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
41080: LD_ADDR_VAR 0 4
41084: PUSH
41085: LD_INT 35
41087: PUSH
41088: LD_INT 45
41090: PUSH
41091: LD_INT 46
41093: PUSH
41094: LD_INT 47
41096: PUSH
41097: LD_INT 1
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: LD_INT 6
41105: PUSH
41106: LD_INT 15
41108: PUSH
41109: LD_INT 16
41111: PUSH
41112: LD_INT 7
41114: PUSH
41115: LD_INT 12
41117: PUSH
41118: LD_INT 13
41120: PUSH
41121: LD_INT 10
41123: PUSH
41124: LD_INT 14
41126: PUSH
41127: LD_INT 20
41129: PUSH
41130: LD_INT 21
41132: PUSH
41133: LD_INT 22
41135: PUSH
41136: LD_INT 25
41138: PUSH
41139: LD_INT 32
41141: PUSH
41142: LD_INT 27
41144: PUSH
41145: LD_INT 36
41147: PUSH
41148: LD_INT 69
41150: PUSH
41151: LD_INT 39
41153: PUSH
41154: LD_INT 34
41156: PUSH
41157: LD_INT 40
41159: PUSH
41160: LD_INT 48
41162: PUSH
41163: LD_INT 49
41165: PUSH
41166: LD_INT 50
41168: PUSH
41169: LD_INT 51
41171: PUSH
41172: LD_INT 52
41174: PUSH
41175: LD_INT 53
41177: PUSH
41178: LD_INT 54
41180: PUSH
41181: LD_INT 55
41183: PUSH
41184: LD_INT 56
41186: PUSH
41187: LD_INT 57
41189: PUSH
41190: LD_INT 58
41192: PUSH
41193: LD_INT 59
41195: PUSH
41196: LD_INT 60
41198: PUSH
41199: LD_INT 61
41201: PUSH
41202: LD_INT 62
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: LIST
41223: LIST
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: ST_TO_ADDR
41247: GO 41626
41249: LD_INT 2
41251: DOUBLE
41252: EQUAL
41253: IFTRUE 41257
41255: GO 41435
41257: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
41258: LD_ADDR_VAR 0 4
41262: PUSH
41263: LD_INT 35
41265: PUSH
41266: LD_INT 45
41268: PUSH
41269: LD_INT 46
41271: PUSH
41272: LD_INT 47
41274: PUSH
41275: LD_INT 70
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: LD_INT 11
41283: PUSH
41284: LD_INT 3
41286: PUSH
41287: LD_INT 4
41289: PUSH
41290: LD_INT 5
41292: PUSH
41293: LD_INT 6
41295: PUSH
41296: LD_INT 15
41298: PUSH
41299: LD_INT 18
41301: PUSH
41302: LD_INT 7
41304: PUSH
41305: LD_INT 17
41307: PUSH
41308: LD_INT 8
41310: PUSH
41311: LD_INT 20
41313: PUSH
41314: LD_INT 21
41316: PUSH
41317: LD_INT 22
41319: PUSH
41320: LD_INT 72
41322: PUSH
41323: LD_INT 26
41325: PUSH
41326: LD_INT 69
41328: PUSH
41329: LD_INT 39
41331: PUSH
41332: LD_INT 40
41334: PUSH
41335: LD_INT 41
41337: PUSH
41338: LD_INT 42
41340: PUSH
41341: LD_INT 43
41343: PUSH
41344: LD_INT 48
41346: PUSH
41347: LD_INT 49
41349: PUSH
41350: LD_INT 50
41352: PUSH
41353: LD_INT 51
41355: PUSH
41356: LD_INT 52
41358: PUSH
41359: LD_INT 53
41361: PUSH
41362: LD_INT 54
41364: PUSH
41365: LD_INT 55
41367: PUSH
41368: LD_INT 56
41370: PUSH
41371: LD_INT 60
41373: PUSH
41374: LD_INT 61
41376: PUSH
41377: LD_INT 62
41379: PUSH
41380: LD_INT 66
41382: PUSH
41383: LD_INT 67
41385: PUSH
41386: LD_INT 68
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: LIST
41403: LIST
41404: LIST
41405: LIST
41406: LIST
41407: LIST
41408: LIST
41409: LIST
41410: LIST
41411: LIST
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: LIST
41423: LIST
41424: LIST
41425: LIST
41426: LIST
41427: LIST
41428: LIST
41429: LIST
41430: LIST
41431: LIST
41432: ST_TO_ADDR
41433: GO 41626
41435: LD_INT 3
41437: DOUBLE
41438: EQUAL
41439: IFTRUE 41443
41441: GO 41625
41443: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
41444: LD_ADDR_VAR 0 4
41448: PUSH
41449: LD_INT 46
41451: PUSH
41452: LD_INT 47
41454: PUSH
41455: LD_INT 1
41457: PUSH
41458: LD_INT 2
41460: PUSH
41461: LD_INT 11
41463: PUSH
41464: LD_INT 9
41466: PUSH
41467: LD_INT 20
41469: PUSH
41470: LD_INT 19
41472: PUSH
41473: LD_INT 21
41475: PUSH
41476: LD_INT 24
41478: PUSH
41479: LD_INT 22
41481: PUSH
41482: LD_INT 25
41484: PUSH
41485: LD_INT 28
41487: PUSH
41488: LD_INT 29
41490: PUSH
41491: LD_INT 30
41493: PUSH
41494: LD_INT 31
41496: PUSH
41497: LD_INT 37
41499: PUSH
41500: LD_INT 38
41502: PUSH
41503: LD_INT 32
41505: PUSH
41506: LD_INT 27
41508: PUSH
41509: LD_INT 33
41511: PUSH
41512: LD_INT 69
41514: PUSH
41515: LD_INT 39
41517: PUSH
41518: LD_INT 34
41520: PUSH
41521: LD_INT 40
41523: PUSH
41524: LD_INT 71
41526: PUSH
41527: LD_INT 23
41529: PUSH
41530: LD_INT 44
41532: PUSH
41533: LD_INT 48
41535: PUSH
41536: LD_INT 49
41538: PUSH
41539: LD_INT 50
41541: PUSH
41542: LD_INT 51
41544: PUSH
41545: LD_INT 52
41547: PUSH
41548: LD_INT 53
41550: PUSH
41551: LD_INT 54
41553: PUSH
41554: LD_INT 55
41556: PUSH
41557: LD_INT 56
41559: PUSH
41560: LD_INT 57
41562: PUSH
41563: LD_INT 58
41565: PUSH
41566: LD_INT 59
41568: PUSH
41569: LD_INT 63
41571: PUSH
41572: LD_INT 64
41574: PUSH
41575: LD_INT 65
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: ST_TO_ADDR
41623: GO 41626
41625: POP
// if state > - 1 and state < 3 then
41626: LD_VAR 0 3
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: GREATER
41635: PUSH
41636: LD_VAR 0 3
41640: PUSH
41641: LD_INT 3
41643: LESS
41644: AND
41645: IFFALSE 41702
// for i in result do
41647: LD_ADDR_VAR 0 5
41651: PUSH
41652: LD_VAR 0 4
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41700
// if GetTech ( i , side ) <> state then
41660: LD_VAR 0 5
41664: PPUSH
41665: LD_VAR 0 1
41669: PPUSH
41670: CALL_OW 321
41674: PUSH
41675: LD_VAR 0 3
41679: NONEQUAL
41680: IFFALSE 41698
// result := result diff i ;
41682: LD_ADDR_VAR 0 4
41686: PUSH
41687: LD_VAR 0 4
41691: PUSH
41692: LD_VAR 0 5
41696: DIFF
41697: ST_TO_ADDR
41698: GO 41657
41700: POP
41701: POP
// end ;
41702: LD_VAR 0 4
41706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
41707: LD_INT 0
41709: PPUSH
41710: PPUSH
41711: PPUSH
// result := true ;
41712: LD_ADDR_VAR 0 3
41716: PUSH
41717: LD_INT 1
41719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
41720: LD_ADDR_VAR 0 5
41724: PUSH
41725: LD_VAR 0 2
41729: PPUSH
41730: CALL_OW 480
41734: ST_TO_ADDR
// if not tmp then
41735: LD_VAR 0 5
41739: NOT
41740: IFFALSE 41744
// exit ;
41742: GO 41793
// for i in tmp do
41744: LD_ADDR_VAR 0 4
41748: PUSH
41749: LD_VAR 0 5
41753: PUSH
41754: FOR_IN
41755: IFFALSE 41791
// if GetTech ( i , side ) <> state_researched then
41757: LD_VAR 0 4
41761: PPUSH
41762: LD_VAR 0 1
41766: PPUSH
41767: CALL_OW 321
41771: PUSH
41772: LD_INT 2
41774: NONEQUAL
41775: IFFALSE 41789
// begin result := false ;
41777: LD_ADDR_VAR 0 3
41781: PUSH
41782: LD_INT 0
41784: ST_TO_ADDR
// exit ;
41785: POP
41786: POP
41787: GO 41793
// end ;
41789: GO 41754
41791: POP
41792: POP
// end ;
41793: LD_VAR 0 3
41797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
41798: LD_INT 0
41800: PPUSH
41801: PPUSH
41802: PPUSH
41803: PPUSH
41804: PPUSH
41805: PPUSH
41806: PPUSH
41807: PPUSH
41808: PPUSH
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
41813: LD_VAR 0 1
41817: NOT
41818: PUSH
41819: LD_VAR 0 1
41823: PPUSH
41824: CALL_OW 257
41828: PUSH
41829: LD_INT 9
41831: NONEQUAL
41832: OR
41833: IFFALSE 41837
// exit ;
41835: GO 42410
// side := GetSide ( unit ) ;
41837: LD_ADDR_VAR 0 9
41841: PUSH
41842: LD_VAR 0 1
41846: PPUSH
41847: CALL_OW 255
41851: ST_TO_ADDR
// tech_space := tech_spacanom ;
41852: LD_ADDR_VAR 0 12
41856: PUSH
41857: LD_INT 29
41859: ST_TO_ADDR
// tech_time := tech_taurad ;
41860: LD_ADDR_VAR 0 13
41864: PUSH
41865: LD_INT 28
41867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
41868: LD_ADDR_VAR 0 11
41872: PUSH
41873: LD_VAR 0 1
41877: PPUSH
41878: CALL_OW 310
41882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
41883: LD_VAR 0 11
41887: PPUSH
41888: CALL_OW 247
41892: PUSH
41893: LD_INT 2
41895: EQUAL
41896: IFFALSE 41900
// exit ;
41898: GO 42410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
41900: LD_ADDR_VAR 0 8
41904: PUSH
41905: LD_INT 81
41907: PUSH
41908: LD_VAR 0 9
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 3
41919: PUSH
41920: LD_INT 21
41922: PUSH
41923: LD_INT 3
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PPUSH
41938: CALL_OW 69
41942: ST_TO_ADDR
// if not tmp then
41943: LD_VAR 0 8
41947: NOT
41948: IFFALSE 41952
// exit ;
41950: GO 42410
// if in_unit then
41952: LD_VAR 0 11
41956: IFFALSE 41980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
41958: LD_ADDR_VAR 0 10
41962: PUSH
41963: LD_VAR 0 8
41967: PPUSH
41968: LD_VAR 0 11
41972: PPUSH
41973: CALL_OW 74
41977: ST_TO_ADDR
41978: GO 42000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
41980: LD_ADDR_VAR 0 10
41984: PUSH
41985: LD_VAR 0 8
41989: PPUSH
41990: LD_VAR 0 1
41994: PPUSH
41995: CALL_OW 74
41999: ST_TO_ADDR
// if not enemy then
42000: LD_VAR 0 10
42004: NOT
42005: IFFALSE 42009
// exit ;
42007: GO 42410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
42009: LD_VAR 0 11
42013: PUSH
42014: LD_VAR 0 11
42018: PPUSH
42019: LD_VAR 0 10
42023: PPUSH
42024: CALL_OW 296
42028: PUSH
42029: LD_INT 13
42031: GREATER
42032: AND
42033: PUSH
42034: LD_VAR 0 1
42038: PPUSH
42039: LD_VAR 0 10
42043: PPUSH
42044: CALL_OW 296
42048: PUSH
42049: LD_INT 12
42051: GREATER
42052: OR
42053: IFFALSE 42057
// exit ;
42055: GO 42410
// missile := [ 1 ] ;
42057: LD_ADDR_VAR 0 14
42061: PUSH
42062: LD_INT 1
42064: PUSH
42065: EMPTY
42066: LIST
42067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
42068: LD_VAR 0 9
42072: PPUSH
42073: LD_VAR 0 12
42077: PPUSH
42078: CALL_OW 325
42082: IFFALSE 42111
// missile := Insert ( missile , missile + 1 , 2 ) ;
42084: LD_ADDR_VAR 0 14
42088: PUSH
42089: LD_VAR 0 14
42093: PPUSH
42094: LD_VAR 0 14
42098: PUSH
42099: LD_INT 1
42101: PLUS
42102: PPUSH
42103: LD_INT 2
42105: PPUSH
42106: CALL_OW 2
42110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
42111: LD_VAR 0 9
42115: PPUSH
42116: LD_VAR 0 13
42120: PPUSH
42121: CALL_OW 325
42125: PUSH
42126: LD_VAR 0 10
42130: PPUSH
42131: CALL_OW 255
42135: PPUSH
42136: LD_VAR 0 13
42140: PPUSH
42141: CALL_OW 325
42145: NOT
42146: AND
42147: IFFALSE 42176
// missile := Insert ( missile , missile + 1 , 3 ) ;
42149: LD_ADDR_VAR 0 14
42153: PUSH
42154: LD_VAR 0 14
42158: PPUSH
42159: LD_VAR 0 14
42163: PUSH
42164: LD_INT 1
42166: PLUS
42167: PPUSH
42168: LD_INT 3
42170: PPUSH
42171: CALL_OW 2
42175: ST_TO_ADDR
// if missile < 2 then
42176: LD_VAR 0 14
42180: PUSH
42181: LD_INT 2
42183: LESS
42184: IFFALSE 42188
// exit ;
42186: GO 42410
// x := GetX ( enemy ) ;
42188: LD_ADDR_VAR 0 4
42192: PUSH
42193: LD_VAR 0 10
42197: PPUSH
42198: CALL_OW 250
42202: ST_TO_ADDR
// y := GetY ( enemy ) ;
42203: LD_ADDR_VAR 0 5
42207: PUSH
42208: LD_VAR 0 10
42212: PPUSH
42213: CALL_OW 251
42217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
42218: LD_ADDR_VAR 0 6
42222: PUSH
42223: LD_VAR 0 4
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PPUSH
42232: LD_INT 1
42234: PPUSH
42235: CALL_OW 12
42239: PLUS
42240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
42241: LD_ADDR_VAR 0 7
42245: PUSH
42246: LD_VAR 0 5
42250: PUSH
42251: LD_INT 1
42253: NEG
42254: PPUSH
42255: LD_INT 1
42257: PPUSH
42258: CALL_OW 12
42262: PLUS
42263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
42264: LD_VAR 0 6
42268: PPUSH
42269: LD_VAR 0 7
42273: PPUSH
42274: CALL_OW 488
42278: NOT
42279: IFFALSE 42301
// begin _x := x ;
42281: LD_ADDR_VAR 0 6
42285: PUSH
42286: LD_VAR 0 4
42290: ST_TO_ADDR
// _y := y ;
42291: LD_ADDR_VAR 0 7
42295: PUSH
42296: LD_VAR 0 5
42300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
42301: LD_ADDR_VAR 0 3
42305: PUSH
42306: LD_INT 1
42308: PPUSH
42309: LD_VAR 0 14
42313: PPUSH
42314: CALL_OW 12
42318: ST_TO_ADDR
// case i of 1 :
42319: LD_VAR 0 3
42323: PUSH
42324: LD_INT 1
42326: DOUBLE
42327: EQUAL
42328: IFTRUE 42332
42330: GO 42349
42332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
42333: LD_VAR 0 1
42337: PPUSH
42338: LD_VAR 0 10
42342: PPUSH
42343: CALL_OW 115
42347: GO 42410
42349: LD_INT 2
42351: DOUBLE
42352: EQUAL
42353: IFTRUE 42357
42355: GO 42379
42357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
42358: LD_VAR 0 1
42362: PPUSH
42363: LD_VAR 0 6
42367: PPUSH
42368: LD_VAR 0 7
42372: PPUSH
42373: CALL_OW 153
42377: GO 42410
42379: LD_INT 3
42381: DOUBLE
42382: EQUAL
42383: IFTRUE 42387
42385: GO 42409
42387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
42388: LD_VAR 0 1
42392: PPUSH
42393: LD_VAR 0 6
42397: PPUSH
42398: LD_VAR 0 7
42402: PPUSH
42403: CALL_OW 154
42407: GO 42410
42409: POP
// end ;
42410: LD_VAR 0 2
42414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
42415: LD_INT 0
42417: PPUSH
42418: PPUSH
42419: PPUSH
42420: PPUSH
42421: PPUSH
42422: PPUSH
// if not unit or not building then
42423: LD_VAR 0 1
42427: NOT
42428: PUSH
42429: LD_VAR 0 2
42433: NOT
42434: OR
42435: IFFALSE 42439
// exit ;
42437: GO 42597
// x := GetX ( building ) ;
42439: LD_ADDR_VAR 0 5
42443: PUSH
42444: LD_VAR 0 2
42448: PPUSH
42449: CALL_OW 250
42453: ST_TO_ADDR
// y := GetY ( building ) ;
42454: LD_ADDR_VAR 0 6
42458: PUSH
42459: LD_VAR 0 2
42463: PPUSH
42464: CALL_OW 251
42468: ST_TO_ADDR
// for i = 0 to 5 do
42469: LD_ADDR_VAR 0 4
42473: PUSH
42474: DOUBLE
42475: LD_INT 0
42477: DEC
42478: ST_TO_ADDR
42479: LD_INT 5
42481: PUSH
42482: FOR_TO
42483: IFFALSE 42595
// begin _x := ShiftX ( x , i , 3 ) ;
42485: LD_ADDR_VAR 0 7
42489: PUSH
42490: LD_VAR 0 5
42494: PPUSH
42495: LD_VAR 0 4
42499: PPUSH
42500: LD_INT 3
42502: PPUSH
42503: CALL_OW 272
42507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
42508: LD_ADDR_VAR 0 8
42512: PUSH
42513: LD_VAR 0 6
42517: PPUSH
42518: LD_VAR 0 4
42522: PPUSH
42523: LD_INT 3
42525: PPUSH
42526: CALL_OW 273
42530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
42531: LD_VAR 0 7
42535: PPUSH
42536: LD_VAR 0 8
42540: PPUSH
42541: CALL_OW 488
42545: NOT
42546: IFFALSE 42550
// continue ;
42548: GO 42482
// if HexInfo ( _x , _y ) = 0 then
42550: LD_VAR 0 7
42554: PPUSH
42555: LD_VAR 0 8
42559: PPUSH
42560: CALL_OW 428
42564: PUSH
42565: LD_INT 0
42567: EQUAL
42568: IFFALSE 42593
// begin ComMoveXY ( unit , _x , _y ) ;
42570: LD_VAR 0 1
42574: PPUSH
42575: LD_VAR 0 7
42579: PPUSH
42580: LD_VAR 0 8
42584: PPUSH
42585: CALL_OW 111
// exit ;
42589: POP
42590: POP
42591: GO 42597
// end ; end ;
42593: GO 42482
42595: POP
42596: POP
// end ;
42597: LD_VAR 0 3
42601: RET
// export function ScanBase ( side , base_area ) ; begin
42602: LD_INT 0
42604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
42605: LD_ADDR_VAR 0 3
42609: PUSH
42610: LD_VAR 0 2
42614: PPUSH
42615: LD_INT 81
42617: PUSH
42618: LD_VAR 0 1
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PPUSH
42627: CALL_OW 70
42631: ST_TO_ADDR
// end ;
42632: LD_VAR 0 3
42636: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
42637: LD_INT 0
42639: PPUSH
42640: PPUSH
42641: PPUSH
42642: PPUSH
42643: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
42644: LD_VAR 0 1
42648: NOT
42649: PUSH
42650: LD_EXP 69
42654: PUSH
42655: LD_VAR 0 1
42659: ARRAY
42660: NOT
42661: OR
42662: PUSH
42663: LD_VAR 0 2
42667: NOT
42668: OR
42669: PUSH
42670: LD_VAR 0 3
42674: NOT
42675: OR
42676: IFFALSE 42680
// exit ;
42678: GO 43130
// side := mc_sides [ base ] ;
42680: LD_ADDR_VAR 0 6
42684: PUSH
42685: LD_EXP 95
42689: PUSH
42690: LD_VAR 0 1
42694: ARRAY
42695: ST_TO_ADDR
// if not side then
42696: LD_VAR 0 6
42700: NOT
42701: IFFALSE 42705
// exit ;
42703: GO 43130
// for i in solds do
42705: LD_ADDR_VAR 0 7
42709: PUSH
42710: LD_VAR 0 2
42714: PUSH
42715: FOR_IN
42716: IFFALSE 42777
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
42718: LD_VAR 0 7
42722: PPUSH
42723: CALL_OW 310
42727: PPUSH
42728: CALL_OW 266
42732: PUSH
42733: LD_INT 32
42735: PUSH
42736: LD_INT 31
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: IN
42743: IFFALSE 42763
// solds := solds diff i else
42745: LD_ADDR_VAR 0 2
42749: PUSH
42750: LD_VAR 0 2
42754: PUSH
42755: LD_VAR 0 7
42759: DIFF
42760: ST_TO_ADDR
42761: GO 42775
// SetTag ( i , 18 ) ;
42763: LD_VAR 0 7
42767: PPUSH
42768: LD_INT 18
42770: PPUSH
42771: CALL_OW 109
42775: GO 42715
42777: POP
42778: POP
// if not solds then
42779: LD_VAR 0 2
42783: NOT
42784: IFFALSE 42788
// exit ;
42786: GO 43130
// repeat wait ( 0 0$1 ) ;
42788: LD_INT 35
42790: PPUSH
42791: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
42795: LD_ADDR_VAR 0 5
42799: PUSH
42800: LD_VAR 0 6
42804: PPUSH
42805: LD_VAR 0 3
42809: PPUSH
42810: CALL 42602 0 2
42814: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
42815: LD_VAR 0 5
42819: NOT
42820: PUSH
42821: LD_VAR 0 5
42825: PUSH
42826: LD_INT 3
42828: GREATER
42829: OR
42830: PUSH
42831: LD_EXP 91
42835: PUSH
42836: LD_VAR 0 1
42840: ARRAY
42841: OR
42842: IFFALSE 42883
// begin for i in solds do
42844: LD_ADDR_VAR 0 7
42848: PUSH
42849: LD_VAR 0 2
42853: PUSH
42854: FOR_IN
42855: IFFALSE 42879
// if HasTask ( i ) then
42857: LD_VAR 0 7
42861: PPUSH
42862: CALL_OW 314
42866: IFFALSE 42877
// ComStop ( i ) ;
42868: LD_VAR 0 7
42872: PPUSH
42873: CALL_OW 141
42877: GO 42854
42879: POP
42880: POP
// break ;
42881: GO 43118
// end ; for i in solds do
42883: LD_ADDR_VAR 0 7
42887: PUSH
42888: LD_VAR 0 2
42892: PUSH
42893: FOR_IN
42894: IFFALSE 43110
// begin if IsInUnit ( i ) then
42896: LD_VAR 0 7
42900: PPUSH
42901: CALL_OW 310
42905: IFFALSE 42916
// ComExitBuilding ( i ) ;
42907: LD_VAR 0 7
42911: PPUSH
42912: CALL_OW 122
// if GetLives ( i ) > 333 then
42916: LD_VAR 0 7
42920: PPUSH
42921: CALL_OW 256
42925: PUSH
42926: LD_INT 333
42928: GREATER
42929: IFFALSE 42957
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
42931: LD_VAR 0 7
42935: PPUSH
42936: LD_VAR 0 5
42940: PPUSH
42941: LD_VAR 0 7
42945: PPUSH
42946: CALL_OW 74
42950: PPUSH
42951: CALL_OW 115
42955: GO 43108
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
42957: LD_ADDR_VAR 0 8
42961: PUSH
42962: LD_EXP 69
42966: PUSH
42967: LD_VAR 0 1
42971: ARRAY
42972: PPUSH
42973: LD_INT 2
42975: PUSH
42976: LD_INT 30
42978: PUSH
42979: LD_INT 0
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 30
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 30
42998: PUSH
42999: LD_INT 6
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: LIST
43011: PPUSH
43012: CALL_OW 72
43016: PPUSH
43017: LD_VAR 0 7
43021: PPUSH
43022: CALL_OW 74
43026: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
43027: LD_VAR 0 7
43031: PPUSH
43032: LD_VAR 0 8
43036: PPUSH
43037: CALL_OW 250
43041: PPUSH
43042: LD_INT 3
43044: PPUSH
43045: LD_INT 5
43047: PPUSH
43048: CALL_OW 272
43052: PPUSH
43053: LD_VAR 0 8
43057: PPUSH
43058: CALL_OW 251
43062: PPUSH
43063: LD_INT 3
43065: PPUSH
43066: LD_INT 5
43068: PPUSH
43069: CALL_OW 273
43073: PPUSH
43074: CALL_OW 111
// SetTag ( i , 0 ) ;
43078: LD_VAR 0 7
43082: PPUSH
43083: LD_INT 0
43085: PPUSH
43086: CALL_OW 109
// solds := solds diff i ;
43090: LD_ADDR_VAR 0 2
43094: PUSH
43095: LD_VAR 0 2
43099: PUSH
43100: LD_VAR 0 7
43104: DIFF
43105: ST_TO_ADDR
// continue ;
43106: GO 42893
// end ; end ;
43108: GO 42893
43110: POP
43111: POP
// until solds ;
43112: LD_VAR 0 2
43116: IFFALSE 42788
// MC_Reset ( base , 18 ) ;
43118: LD_VAR 0 1
43122: PPUSH
43123: LD_INT 18
43125: PPUSH
43126: CALL 16381 0 2
// end ;
43130: LD_VAR 0 4
43134: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
43135: LD_INT 0
43137: PPUSH
43138: PPUSH
43139: PPUSH
43140: PPUSH
43141: PPUSH
43142: PPUSH
43143: PPUSH
43144: PPUSH
43145: PPUSH
43146: PPUSH
43147: PPUSH
43148: PPUSH
43149: PPUSH
43150: PPUSH
43151: PPUSH
43152: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43153: LD_ADDR_VAR 0 12
43157: PUSH
43158: LD_EXP 69
43162: PUSH
43163: LD_VAR 0 1
43167: ARRAY
43168: PPUSH
43169: LD_INT 25
43171: PUSH
43172: LD_INT 3
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PPUSH
43179: CALL_OW 72
43183: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43184: LD_ADDR_VAR 0 8
43188: PUSH
43189: LD_EXP 69
43193: PUSH
43194: LD_VAR 0 1
43198: ARRAY
43199: PPUSH
43200: LD_INT 2
43202: PUSH
43203: LD_INT 25
43205: PUSH
43206: LD_INT 1
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: LD_INT 25
43215: PUSH
43216: LD_INT 5
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: LD_INT 25
43225: PUSH
43226: LD_INT 8
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: PUSH
43233: LD_INT 25
43235: PUSH
43236: LD_INT 9
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: LIST
43247: LIST
43248: LIST
43249: PPUSH
43250: CALL_OW 72
43254: ST_TO_ADDR
// if not defenders and not solds then
43255: LD_VAR 0 2
43259: NOT
43260: PUSH
43261: LD_VAR 0 8
43265: NOT
43266: AND
43267: IFFALSE 43271
// exit ;
43269: GO 44637
// depot_under_attack := false ;
43271: LD_ADDR_VAR 0 16
43275: PUSH
43276: LD_INT 0
43278: ST_TO_ADDR
// sold_defenders := [ ] ;
43279: LD_ADDR_VAR 0 17
43283: PUSH
43284: EMPTY
43285: ST_TO_ADDR
// if mechs then
43286: LD_VAR 0 12
43290: IFFALSE 43419
// for i in defenders do
43292: LD_ADDR_VAR 0 5
43296: PUSH
43297: LD_VAR 0 2
43301: PUSH
43302: FOR_IN
43303: IFFALSE 43417
// begin SetTag ( i , 20 ) ;
43305: LD_VAR 0 5
43309: PPUSH
43310: LD_INT 20
43312: PPUSH
43313: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
43317: LD_VAR 0 5
43321: PPUSH
43322: CALL_OW 263
43326: PUSH
43327: LD_INT 1
43329: EQUAL
43330: PUSH
43331: LD_VAR 0 5
43335: PPUSH
43336: CALL_OW 311
43340: NOT
43341: AND
43342: PUSH
43343: LD_VAR 0 12
43347: AND
43348: IFFALSE 43415
// begin un := mechs [ 1 ] ;
43350: LD_ADDR_VAR 0 10
43354: PUSH
43355: LD_VAR 0 12
43359: PUSH
43360: LD_INT 1
43362: ARRAY
43363: ST_TO_ADDR
// ComExitBuilding ( un ) ;
43364: LD_VAR 0 10
43368: PPUSH
43369: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
43373: LD_VAR 0 10
43377: PPUSH
43378: LD_VAR 0 5
43382: PPUSH
43383: CALL_OW 180
// SetTag ( un , 19 ) ;
43387: LD_VAR 0 10
43391: PPUSH
43392: LD_INT 19
43394: PPUSH
43395: CALL_OW 109
// mechs := mechs diff un ;
43399: LD_ADDR_VAR 0 12
43403: PUSH
43404: LD_VAR 0 12
43408: PUSH
43409: LD_VAR 0 10
43413: DIFF
43414: ST_TO_ADDR
// end ; end ;
43415: GO 43302
43417: POP
43418: POP
// if solds then
43419: LD_VAR 0 8
43423: IFFALSE 43482
// for i in solds do
43425: LD_ADDR_VAR 0 5
43429: PUSH
43430: LD_VAR 0 8
43434: PUSH
43435: FOR_IN
43436: IFFALSE 43480
// if not GetTag ( i ) then
43438: LD_VAR 0 5
43442: PPUSH
43443: CALL_OW 110
43447: NOT
43448: IFFALSE 43478
// begin defenders := defenders union i ;
43450: LD_ADDR_VAR 0 2
43454: PUSH
43455: LD_VAR 0 2
43459: PUSH
43460: LD_VAR 0 5
43464: UNION
43465: ST_TO_ADDR
// SetTag ( i , 18 ) ;
43466: LD_VAR 0 5
43470: PPUSH
43471: LD_INT 18
43473: PPUSH
43474: CALL_OW 109
// end ;
43478: GO 43435
43480: POP
43481: POP
// repeat wait ( 0 0$1 ) ;
43482: LD_INT 35
43484: PPUSH
43485: CALL_OW 67
// enemy := mc_scan [ base ] ;
43489: LD_ADDR_VAR 0 3
43493: PUSH
43494: LD_EXP 92
43498: PUSH
43499: LD_VAR 0 1
43503: ARRAY
43504: ST_TO_ADDR
// for i in defenders do
43505: LD_ADDR_VAR 0 5
43509: PUSH
43510: LD_VAR 0 2
43514: PUSH
43515: FOR_IN
43516: IFFALSE 44201
// begin e := NearestUnitToUnit ( enemy , i ) ;
43518: LD_ADDR_VAR 0 13
43522: PUSH
43523: LD_VAR 0 3
43527: PPUSH
43528: LD_VAR 0 5
43532: PPUSH
43533: CALL_OW 74
43537: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
43538: LD_ADDR_VAR 0 16
43542: PUSH
43543: LD_EXP 69
43547: PUSH
43548: LD_VAR 0 1
43552: ARRAY
43553: PPUSH
43554: LD_INT 2
43556: PUSH
43557: LD_INT 30
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 30
43569: PUSH
43570: LD_INT 1
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: LIST
43581: PPUSH
43582: CALL_OW 72
43586: NOT
43587: PUSH
43588: LD_EXP 69
43592: PUSH
43593: LD_VAR 0 1
43597: ARRAY
43598: PPUSH
43599: LD_INT 2
43601: PUSH
43602: LD_INT 30
43604: PUSH
43605: LD_INT 0
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 30
43614: PUSH
43615: LD_INT 1
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: LIST
43626: PPUSH
43627: CALL_OW 72
43631: PPUSH
43632: CALL_OW 256
43636: PUSH
43637: LD_INT 600
43639: LESS
43640: OR
43641: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
43642: LD_VAR 0 5
43646: PPUSH
43647: CALL_OW 247
43651: PUSH
43652: LD_INT 2
43654: DOUBLE
43655: EQUAL
43656: IFTRUE 43660
43658: GO 43907
43660: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
43661: LD_VAR 0 5
43665: PPUSH
43666: CALL_OW 256
43670: PUSH
43671: LD_INT 650
43673: GREATER
43674: PUSH
43675: LD_VAR 0 5
43679: PPUSH
43680: LD_VAR 0 13
43684: PPUSH
43685: CALL_OW 296
43689: PUSH
43690: LD_INT 40
43692: LESS
43693: AND
43694: IFFALSE 43712
// ComAttackUnit ( i , e ) else
43696: LD_VAR 0 5
43700: PPUSH
43701: LD_VAR 0 13
43705: PPUSH
43706: CALL_OW 115
43710: GO 43790
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
43712: LD_VAR 0 5
43716: PPUSH
43717: LD_VAR 0 13
43721: PPUSH
43722: CALL_OW 296
43726: PUSH
43727: LD_INT 30
43729: GREATEREQUAL
43730: PUSH
43731: LD_VAR 0 5
43735: PPUSH
43736: CALL_OW 256
43740: PUSH
43741: LD_INT 650
43743: LESSEQUAL
43744: OR
43745: PUSH
43746: LD_VAR 0 5
43750: PPUSH
43751: LD_EXP 93
43755: PUSH
43756: LD_VAR 0 1
43760: ARRAY
43761: PPUSH
43762: CALL_OW 308
43766: NOT
43767: AND
43768: IFFALSE 43790
// ComMoveToArea ( i , mc_parking [ base ] ) ;
43770: LD_VAR 0 5
43774: PPUSH
43775: LD_EXP 93
43779: PUSH
43780: LD_VAR 0 1
43784: ARRAY
43785: PPUSH
43786: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
43790: LD_VAR 0 5
43794: PPUSH
43795: CALL_OW 256
43799: PUSH
43800: LD_INT 998
43802: LESS
43803: PUSH
43804: LD_VAR 0 5
43808: PPUSH
43809: CALL_OW 263
43813: PUSH
43814: LD_INT 1
43816: EQUAL
43817: AND
43818: PUSH
43819: LD_VAR 0 5
43823: PPUSH
43824: CALL_OW 311
43828: AND
43829: PUSH
43830: LD_VAR 0 5
43834: PPUSH
43835: LD_EXP 93
43839: PUSH
43840: LD_VAR 0 1
43844: ARRAY
43845: PPUSH
43846: CALL_OW 308
43850: AND
43851: IFFALSE 43905
// begin mech := IsDrivenBy ( i ) ;
43853: LD_ADDR_VAR 0 9
43857: PUSH
43858: LD_VAR 0 5
43862: PPUSH
43863: CALL_OW 311
43867: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
43868: LD_VAR 0 9
43872: PPUSH
43873: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
43877: LD_VAR 0 9
43881: PPUSH
43882: LD_VAR 0 5
43886: PPUSH
43887: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
43891: LD_VAR 0 9
43895: PPUSH
43896: LD_VAR 0 5
43900: PPUSH
43901: CALL_OW 180
// end ; end ; unit_human :
43905: GO 44172
43907: LD_INT 1
43909: DOUBLE
43910: EQUAL
43911: IFTRUE 43915
43913: GO 44171
43915: POP
// begin b := IsInUnit ( i ) ;
43916: LD_ADDR_VAR 0 18
43920: PUSH
43921: LD_VAR 0 5
43925: PPUSH
43926: CALL_OW 310
43930: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
43931: LD_ADDR_VAR 0 19
43935: PUSH
43936: LD_VAR 0 18
43940: NOT
43941: PUSH
43942: LD_VAR 0 18
43946: PPUSH
43947: CALL_OW 266
43951: PUSH
43952: LD_INT 32
43954: PUSH
43955: LD_INT 31
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: IN
43962: OR
43963: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
43964: LD_VAR 0 16
43968: PUSH
43969: LD_VAR 0 2
43973: PPUSH
43974: LD_INT 21
43976: PUSH
43977: LD_INT 2
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PPUSH
43984: CALL_OW 72
43988: PUSH
43989: LD_INT 1
43991: LESSEQUAL
43992: OR
43993: PUSH
43994: LD_VAR 0 19
43998: AND
43999: PUSH
44000: LD_VAR 0 5
44004: PUSH
44005: LD_VAR 0 17
44009: IN
44010: NOT
44011: AND
44012: IFFALSE 44105
// begin if b then
44014: LD_VAR 0 18
44018: IFFALSE 44067
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
44020: LD_VAR 0 18
44024: PPUSH
44025: LD_VAR 0 3
44029: PPUSH
44030: LD_VAR 0 18
44034: PPUSH
44035: CALL_OW 74
44039: PPUSH
44040: CALL_OW 296
44044: PUSH
44045: LD_INT 10
44047: LESS
44048: PUSH
44049: LD_VAR 0 18
44053: PPUSH
44054: CALL_OW 461
44058: PUSH
44059: LD_INT 7
44061: NONEQUAL
44062: AND
44063: IFFALSE 44067
// continue ;
44065: GO 43515
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
44067: LD_ADDR_VAR 0 17
44071: PUSH
44072: LD_VAR 0 17
44076: PPUSH
44077: LD_VAR 0 17
44081: PUSH
44082: LD_INT 1
44084: PLUS
44085: PPUSH
44086: LD_VAR 0 5
44090: PPUSH
44091: CALL_OW 1
44095: ST_TO_ADDR
// ComExitBuilding ( i ) ;
44096: LD_VAR 0 5
44100: PPUSH
44101: CALL_OW 122
// end ; if sold_defenders then
44105: LD_VAR 0 17
44109: IFFALSE 44169
// if i in sold_defenders then
44111: LD_VAR 0 5
44115: PUSH
44116: LD_VAR 0 17
44120: IN
44121: IFFALSE 44169
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
44123: LD_VAR 0 5
44127: PPUSH
44128: CALL_OW 314
44132: NOT
44133: PUSH
44134: LD_VAR 0 5
44138: PPUSH
44139: LD_VAR 0 13
44143: PPUSH
44144: CALL_OW 296
44148: PUSH
44149: LD_INT 30
44151: LESS
44152: AND
44153: IFFALSE 44169
// ComAttackUnit ( i , e ) ;
44155: LD_VAR 0 5
44159: PPUSH
44160: LD_VAR 0 13
44164: PPUSH
44165: CALL_OW 115
// end ; end ; end ;
44169: GO 44172
44171: POP
// if IsDead ( i ) then
44172: LD_VAR 0 5
44176: PPUSH
44177: CALL_OW 301
44181: IFFALSE 44199
// defenders := defenders diff i ;
44183: LD_ADDR_VAR 0 2
44187: PUSH
44188: LD_VAR 0 2
44192: PUSH
44193: LD_VAR 0 5
44197: DIFF
44198: ST_TO_ADDR
// end ;
44199: GO 43515
44201: POP
44202: POP
// until not enemy or not defenders ;
44203: LD_VAR 0 3
44207: NOT
44208: PUSH
44209: LD_VAR 0 2
44213: NOT
44214: OR
44215: IFFALSE 43482
// MC_Reset ( base , 18 ) ;
44217: LD_VAR 0 1
44221: PPUSH
44222: LD_INT 18
44224: PPUSH
44225: CALL 16381 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44229: LD_ADDR_VAR 0 2
44233: PUSH
44234: LD_VAR 0 2
44238: PUSH
44239: LD_VAR 0 2
44243: PPUSH
44244: LD_INT 2
44246: PUSH
44247: LD_INT 25
44249: PUSH
44250: LD_INT 1
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 25
44259: PUSH
44260: LD_INT 5
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 25
44269: PUSH
44270: LD_INT 8
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 25
44279: PUSH
44280: LD_INT 9
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: PPUSH
44294: CALL_OW 72
44298: DIFF
44299: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
44300: LD_VAR 0 3
44304: NOT
44305: PUSH
44306: LD_VAR 0 2
44310: PPUSH
44311: LD_INT 21
44313: PUSH
44314: LD_INT 2
44316: PUSH
44317: EMPTY
44318: LIST
44319: LIST
44320: PPUSH
44321: CALL_OW 72
44325: AND
44326: IFFALSE 44588
// begin tmp := FilterByTag ( defenders , 19 ) ;
44328: LD_ADDR_VAR 0 11
44332: PUSH
44333: LD_VAR 0 2
44337: PPUSH
44338: LD_INT 19
44340: PPUSH
44341: CALL 80935 0 2
44345: ST_TO_ADDR
// if tmp then
44346: LD_VAR 0 11
44350: IFFALSE 44420
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
44352: LD_ADDR_VAR 0 11
44356: PUSH
44357: LD_VAR 0 11
44361: PPUSH
44362: LD_INT 25
44364: PUSH
44365: LD_INT 3
44367: PUSH
44368: EMPTY
44369: LIST
44370: LIST
44371: PPUSH
44372: CALL_OW 72
44376: ST_TO_ADDR
// if tmp then
44377: LD_VAR 0 11
44381: IFFALSE 44420
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
44383: LD_ADDR_EXP 81
44387: PUSH
44388: LD_EXP 81
44392: PPUSH
44393: LD_VAR 0 1
44397: PPUSH
44398: LD_EXP 81
44402: PUSH
44403: LD_VAR 0 1
44407: ARRAY
44408: PUSH
44409: LD_VAR 0 11
44413: UNION
44414: PPUSH
44415: CALL_OW 1
44419: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
44420: LD_VAR 0 1
44424: PPUSH
44425: LD_INT 19
44427: PPUSH
44428: CALL 16381 0 2
// repeat wait ( 0 0$1 ) ;
44432: LD_INT 35
44434: PPUSH
44435: CALL_OW 67
// for i in defenders do
44439: LD_ADDR_VAR 0 5
44443: PUSH
44444: LD_VAR 0 2
44448: PUSH
44449: FOR_IN
44450: IFFALSE 44539
// begin if not IsInArea ( i , mc_parking [ base ] ) then
44452: LD_VAR 0 5
44456: PPUSH
44457: LD_EXP 93
44461: PUSH
44462: LD_VAR 0 1
44466: ARRAY
44467: PPUSH
44468: CALL_OW 308
44472: NOT
44473: IFFALSE 44497
// ComMoveToArea ( i , mc_parking [ base ] ) else
44475: LD_VAR 0 5
44479: PPUSH
44480: LD_EXP 93
44484: PUSH
44485: LD_VAR 0 1
44489: ARRAY
44490: PPUSH
44491: CALL_OW 113
44495: GO 44537
// if GetControl ( i ) = control_manual then
44497: LD_VAR 0 5
44501: PPUSH
44502: CALL_OW 263
44506: PUSH
44507: LD_INT 1
44509: EQUAL
44510: IFFALSE 44537
// if IsDrivenBy ( i ) then
44512: LD_VAR 0 5
44516: PPUSH
44517: CALL_OW 311
44521: IFFALSE 44537
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
44523: LD_VAR 0 5
44527: PPUSH
44528: CALL_OW 311
44532: PPUSH
44533: CALL_OW 121
// end ;
44537: GO 44449
44539: POP
44540: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
44541: LD_VAR 0 2
44545: PPUSH
44546: LD_INT 95
44548: PUSH
44549: LD_EXP 93
44553: PUSH
44554: LD_VAR 0 1
44558: ARRAY
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PPUSH
44564: CALL_OW 72
44568: PUSH
44569: LD_VAR 0 2
44573: EQUAL
44574: PUSH
44575: LD_EXP 92
44579: PUSH
44580: LD_VAR 0 1
44584: ARRAY
44585: OR
44586: IFFALSE 44432
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
44588: LD_ADDR_EXP 91
44592: PUSH
44593: LD_EXP 91
44597: PPUSH
44598: LD_VAR 0 1
44602: PPUSH
44603: LD_EXP 91
44607: PUSH
44608: LD_VAR 0 1
44612: ARRAY
44613: PUSH
44614: LD_VAR 0 2
44618: UNION
44619: PPUSH
44620: CALL_OW 1
44624: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
44625: LD_VAR 0 1
44629: PPUSH
44630: LD_INT 20
44632: PPUSH
44633: CALL 16381 0 2
// end ;
44637: LD_VAR 0 4
44641: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
44642: LD_INT 0
44644: PPUSH
44645: PPUSH
44646: PPUSH
44647: PPUSH
// result := false ;
44648: LD_ADDR_VAR 0 2
44652: PUSH
44653: LD_INT 0
44655: ST_TO_ADDR
// side := GetSide ( unit ) ;
44656: LD_ADDR_VAR 0 3
44660: PUSH
44661: LD_VAR 0 1
44665: PPUSH
44666: CALL_OW 255
44670: ST_TO_ADDR
// nat := GetNation ( unit ) ;
44671: LD_ADDR_VAR 0 4
44675: PUSH
44676: LD_VAR 0 1
44680: PPUSH
44681: CALL_OW 248
44685: ST_TO_ADDR
// case nat of 1 :
44686: LD_VAR 0 4
44690: PUSH
44691: LD_INT 1
44693: DOUBLE
44694: EQUAL
44695: IFTRUE 44699
44697: GO 44710
44699: POP
// tech := tech_lassight ; 2 :
44700: LD_ADDR_VAR 0 5
44704: PUSH
44705: LD_INT 12
44707: ST_TO_ADDR
44708: GO 44749
44710: LD_INT 2
44712: DOUBLE
44713: EQUAL
44714: IFTRUE 44718
44716: GO 44729
44718: POP
// tech := tech_mortar ; 3 :
44719: LD_ADDR_VAR 0 5
44723: PUSH
44724: LD_INT 41
44726: ST_TO_ADDR
44727: GO 44749
44729: LD_INT 3
44731: DOUBLE
44732: EQUAL
44733: IFTRUE 44737
44735: GO 44748
44737: POP
// tech := tech_bazooka ; end ;
44738: LD_ADDR_VAR 0 5
44742: PUSH
44743: LD_INT 44
44745: ST_TO_ADDR
44746: GO 44749
44748: POP
// if Researched ( side , tech ) then
44749: LD_VAR 0 3
44753: PPUSH
44754: LD_VAR 0 5
44758: PPUSH
44759: CALL_OW 325
44763: IFFALSE 44790
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
44765: LD_ADDR_VAR 0 2
44769: PUSH
44770: LD_INT 5
44772: PUSH
44773: LD_INT 8
44775: PUSH
44776: LD_INT 9
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: LIST
44783: PUSH
44784: LD_VAR 0 4
44788: ARRAY
44789: ST_TO_ADDR
// end ;
44790: LD_VAR 0 2
44794: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
44795: LD_INT 0
44797: PPUSH
44798: PPUSH
44799: PPUSH
// if not mines then
44800: LD_VAR 0 2
44804: NOT
44805: IFFALSE 44809
// exit ;
44807: GO 44953
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
44809: LD_ADDR_VAR 0 5
44813: PUSH
44814: LD_INT 81
44816: PUSH
44817: LD_VAR 0 1
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 3
44828: PUSH
44829: LD_INT 21
44831: PUSH
44832: LD_INT 3
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PPUSH
44847: CALL_OW 69
44851: ST_TO_ADDR
// for i in mines do
44852: LD_ADDR_VAR 0 4
44856: PUSH
44857: LD_VAR 0 2
44861: PUSH
44862: FOR_IN
44863: IFFALSE 44951
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
44865: LD_VAR 0 4
44869: PUSH
44870: LD_INT 1
44872: ARRAY
44873: PPUSH
44874: LD_VAR 0 4
44878: PUSH
44879: LD_INT 2
44881: ARRAY
44882: PPUSH
44883: CALL_OW 458
44887: NOT
44888: IFFALSE 44892
// continue ;
44890: GO 44862
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
44892: LD_VAR 0 4
44896: PUSH
44897: LD_INT 1
44899: ARRAY
44900: PPUSH
44901: LD_VAR 0 4
44905: PUSH
44906: LD_INT 2
44908: ARRAY
44909: PPUSH
44910: CALL_OW 428
44914: PUSH
44915: LD_VAR 0 5
44919: IN
44920: IFFALSE 44949
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
44922: LD_VAR 0 4
44926: PUSH
44927: LD_INT 1
44929: ARRAY
44930: PPUSH
44931: LD_VAR 0 4
44935: PUSH
44936: LD_INT 2
44938: ARRAY
44939: PPUSH
44940: LD_VAR 0 1
44944: PPUSH
44945: CALL_OW 456
// end ;
44949: GO 44862
44951: POP
44952: POP
// end ;
44953: LD_VAR 0 3
44957: RET
// export function Count ( array ) ; var i ; begin
44958: LD_INT 0
44960: PPUSH
44961: PPUSH
// result := 0 ;
44962: LD_ADDR_VAR 0 2
44966: PUSH
44967: LD_INT 0
44969: ST_TO_ADDR
// for i in array do
44970: LD_ADDR_VAR 0 3
44974: PUSH
44975: LD_VAR 0 1
44979: PUSH
44980: FOR_IN
44981: IFFALSE 45005
// if i then
44983: LD_VAR 0 3
44987: IFFALSE 45003
// result := result + 1 ;
44989: LD_ADDR_VAR 0 2
44993: PUSH
44994: LD_VAR 0 2
44998: PUSH
44999: LD_INT 1
45001: PLUS
45002: ST_TO_ADDR
45003: GO 44980
45005: POP
45006: POP
// end ;
45007: LD_VAR 0 2
45011: RET
// export function IsEmpty ( building ) ; begin
45012: LD_INT 0
45014: PPUSH
// if not building then
45015: LD_VAR 0 1
45019: NOT
45020: IFFALSE 45024
// exit ;
45022: GO 45067
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
45024: LD_ADDR_VAR 0 2
45028: PUSH
45029: LD_VAR 0 1
45033: PUSH
45034: LD_INT 22
45036: PUSH
45037: LD_VAR 0 1
45041: PPUSH
45042: CALL_OW 255
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 58
45053: PUSH
45054: EMPTY
45055: LIST
45056: PUSH
45057: EMPTY
45058: LIST
45059: LIST
45060: PPUSH
45061: CALL_OW 69
45065: IN
45066: ST_TO_ADDR
// end ;
45067: LD_VAR 0 2
45071: RET
// export function IsNotFull ( building ) ; begin
45072: LD_INT 0
45074: PPUSH
// if not building then
45075: LD_VAR 0 1
45079: NOT
45080: IFFALSE 45084
// exit ;
45082: GO 45103
// result := UnitsInside ( building ) < 6 ;
45084: LD_ADDR_VAR 0 2
45088: PUSH
45089: LD_VAR 0 1
45093: PPUSH
45094: CALL_OW 313
45098: PUSH
45099: LD_INT 6
45101: LESS
45102: ST_TO_ADDR
// end ;
45103: LD_VAR 0 2
45107: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
45108: LD_INT 0
45110: PPUSH
45111: PPUSH
45112: PPUSH
45113: PPUSH
// tmp := [ ] ;
45114: LD_ADDR_VAR 0 3
45118: PUSH
45119: EMPTY
45120: ST_TO_ADDR
// list := [ ] ;
45121: LD_ADDR_VAR 0 5
45125: PUSH
45126: EMPTY
45127: ST_TO_ADDR
// for i = 16 to 25 do
45128: LD_ADDR_VAR 0 4
45132: PUSH
45133: DOUBLE
45134: LD_INT 16
45136: DEC
45137: ST_TO_ADDR
45138: LD_INT 25
45140: PUSH
45141: FOR_TO
45142: IFFALSE 45215
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
45144: LD_ADDR_VAR 0 3
45148: PUSH
45149: LD_VAR 0 3
45153: PUSH
45154: LD_INT 22
45156: PUSH
45157: LD_VAR 0 1
45161: PPUSH
45162: CALL_OW 255
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 91
45173: PUSH
45174: LD_VAR 0 1
45178: PUSH
45179: LD_INT 6
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 30
45189: PUSH
45190: LD_VAR 0 4
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: LIST
45203: PUSH
45204: EMPTY
45205: LIST
45206: PPUSH
45207: CALL_OW 69
45211: ADD
45212: ST_TO_ADDR
45213: GO 45141
45215: POP
45216: POP
// for i = 1 to tmp do
45217: LD_ADDR_VAR 0 4
45221: PUSH
45222: DOUBLE
45223: LD_INT 1
45225: DEC
45226: ST_TO_ADDR
45227: LD_VAR 0 3
45231: PUSH
45232: FOR_TO
45233: IFFALSE 45321
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
45235: LD_ADDR_VAR 0 5
45239: PUSH
45240: LD_VAR 0 5
45244: PUSH
45245: LD_VAR 0 3
45249: PUSH
45250: LD_VAR 0 4
45254: ARRAY
45255: PPUSH
45256: CALL_OW 266
45260: PUSH
45261: LD_VAR 0 3
45265: PUSH
45266: LD_VAR 0 4
45270: ARRAY
45271: PPUSH
45272: CALL_OW 250
45276: PUSH
45277: LD_VAR 0 3
45281: PUSH
45282: LD_VAR 0 4
45286: ARRAY
45287: PPUSH
45288: CALL_OW 251
45292: PUSH
45293: LD_VAR 0 3
45297: PUSH
45298: LD_VAR 0 4
45302: ARRAY
45303: PPUSH
45304: CALL_OW 254
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: PUSH
45315: EMPTY
45316: LIST
45317: ADD
45318: ST_TO_ADDR
45319: GO 45232
45321: POP
45322: POP
// result := list ;
45323: LD_ADDR_VAR 0 2
45327: PUSH
45328: LD_VAR 0 5
45332: ST_TO_ADDR
// end ;
45333: LD_VAR 0 2
45337: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
45338: LD_INT 0
45340: PPUSH
45341: PPUSH
45342: PPUSH
45343: PPUSH
45344: PPUSH
45345: PPUSH
45346: PPUSH
// if not factory then
45347: LD_VAR 0 1
45351: NOT
45352: IFFALSE 45356
// exit ;
45354: GO 45881
// if control = control_apeman then
45356: LD_VAR 0 4
45360: PUSH
45361: LD_INT 5
45363: EQUAL
45364: IFFALSE 45473
// begin tmp := UnitsInside ( factory ) ;
45366: LD_ADDR_VAR 0 8
45370: PUSH
45371: LD_VAR 0 1
45375: PPUSH
45376: CALL_OW 313
45380: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
45381: LD_VAR 0 8
45385: PPUSH
45386: LD_INT 25
45388: PUSH
45389: LD_INT 12
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PPUSH
45396: CALL_OW 72
45400: NOT
45401: IFFALSE 45411
// control := control_manual ;
45403: LD_ADDR_VAR 0 4
45407: PUSH
45408: LD_INT 1
45410: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
45411: LD_ADDR_VAR 0 8
45415: PUSH
45416: LD_VAR 0 1
45420: PPUSH
45421: CALL 45108 0 1
45425: ST_TO_ADDR
// if tmp then
45426: LD_VAR 0 8
45430: IFFALSE 45473
// begin for i in tmp do
45432: LD_ADDR_VAR 0 7
45436: PUSH
45437: LD_VAR 0 8
45441: PUSH
45442: FOR_IN
45443: IFFALSE 45471
// if i [ 1 ] = b_ext_radar then
45445: LD_VAR 0 7
45449: PUSH
45450: LD_INT 1
45452: ARRAY
45453: PUSH
45454: LD_INT 20
45456: EQUAL
45457: IFFALSE 45469
// begin control := control_remote ;
45459: LD_ADDR_VAR 0 4
45463: PUSH
45464: LD_INT 2
45466: ST_TO_ADDR
// break ;
45467: GO 45471
// end ;
45469: GO 45442
45471: POP
45472: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
45473: LD_VAR 0 1
45477: PPUSH
45478: LD_VAR 0 2
45482: PPUSH
45483: LD_VAR 0 3
45487: PPUSH
45488: LD_VAR 0 4
45492: PPUSH
45493: LD_VAR 0 5
45497: PPUSH
45498: CALL_OW 448
45502: IFFALSE 45537
// begin result := [ chassis , engine , control , weapon ] ;
45504: LD_ADDR_VAR 0 6
45508: PUSH
45509: LD_VAR 0 2
45513: PUSH
45514: LD_VAR 0 3
45518: PUSH
45519: LD_VAR 0 4
45523: PUSH
45524: LD_VAR 0 5
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: ST_TO_ADDR
// exit ;
45535: GO 45881
// end ; _chassis := AvailableChassisList ( factory ) ;
45537: LD_ADDR_VAR 0 9
45541: PUSH
45542: LD_VAR 0 1
45546: PPUSH
45547: CALL_OW 475
45551: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
45552: LD_ADDR_VAR 0 11
45556: PUSH
45557: LD_VAR 0 1
45561: PPUSH
45562: CALL_OW 476
45566: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
45567: LD_ADDR_VAR 0 12
45571: PUSH
45572: LD_VAR 0 1
45576: PPUSH
45577: CALL_OW 477
45581: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
45582: LD_ADDR_VAR 0 10
45586: PUSH
45587: LD_VAR 0 1
45591: PPUSH
45592: CALL_OW 478
45596: ST_TO_ADDR
// if not chassis in _chassis then
45597: LD_VAR 0 2
45601: PUSH
45602: LD_VAR 0 9
45606: IN
45607: NOT
45608: IFFALSE 45634
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
45610: LD_ADDR_VAR 0 2
45614: PUSH
45615: LD_VAR 0 9
45619: PUSH
45620: LD_INT 1
45622: PPUSH
45623: LD_VAR 0 9
45627: PPUSH
45628: CALL_OW 12
45632: ARRAY
45633: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
45634: LD_VAR 0 2
45638: PPUSH
45639: LD_VAR 0 3
45643: PPUSH
45644: CALL 45886 0 2
45648: NOT
45649: IFFALSE 45708
// repeat engine := _engine [ 1 ] ;
45651: LD_ADDR_VAR 0 3
45655: PUSH
45656: LD_VAR 0 11
45660: PUSH
45661: LD_INT 1
45663: ARRAY
45664: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
45665: LD_ADDR_VAR 0 11
45669: PUSH
45670: LD_VAR 0 11
45674: PPUSH
45675: LD_INT 1
45677: PPUSH
45678: CALL_OW 3
45682: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
45683: LD_VAR 0 2
45687: PPUSH
45688: LD_VAR 0 3
45692: PPUSH
45693: CALL 45886 0 2
45697: PUSH
45698: LD_VAR 0 11
45702: PUSH
45703: EMPTY
45704: EQUAL
45705: OR
45706: IFFALSE 45651
// if not control in _control then
45708: LD_VAR 0 4
45712: PUSH
45713: LD_VAR 0 12
45717: IN
45718: NOT
45719: IFFALSE 45745
// control := _control [ rand ( 1 , _control ) ] ;
45721: LD_ADDR_VAR 0 4
45725: PUSH
45726: LD_VAR 0 12
45730: PUSH
45731: LD_INT 1
45733: PPUSH
45734: LD_VAR 0 12
45738: PPUSH
45739: CALL_OW 12
45743: ARRAY
45744: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
45745: LD_VAR 0 2
45749: PPUSH
45750: LD_VAR 0 5
45754: PPUSH
45755: CALL 46106 0 2
45759: NOT
45760: IFFALSE 45819
// repeat weapon := _weapon [ 1 ] ;
45762: LD_ADDR_VAR 0 5
45766: PUSH
45767: LD_VAR 0 10
45771: PUSH
45772: LD_INT 1
45774: ARRAY
45775: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
45776: LD_ADDR_VAR 0 10
45780: PUSH
45781: LD_VAR 0 10
45785: PPUSH
45786: LD_INT 1
45788: PPUSH
45789: CALL_OW 3
45793: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
45794: LD_VAR 0 2
45798: PPUSH
45799: LD_VAR 0 5
45803: PPUSH
45804: CALL 46106 0 2
45808: PUSH
45809: LD_VAR 0 10
45813: PUSH
45814: EMPTY
45815: EQUAL
45816: OR
45817: IFFALSE 45762
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
45819: LD_VAR 0 1
45823: PPUSH
45824: LD_VAR 0 2
45828: PPUSH
45829: LD_VAR 0 3
45833: PPUSH
45834: LD_VAR 0 4
45838: PPUSH
45839: LD_VAR 0 5
45843: PPUSH
45844: CALL_OW 448
45848: IFFALSE 45881
// result := [ chassis , engine , control , weapon ] ;
45850: LD_ADDR_VAR 0 6
45854: PUSH
45855: LD_VAR 0 2
45859: PUSH
45860: LD_VAR 0 3
45864: PUSH
45865: LD_VAR 0 4
45869: PUSH
45870: LD_VAR 0 5
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: ST_TO_ADDR
// end ;
45881: LD_VAR 0 6
45885: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
45886: LD_INT 0
45888: PPUSH
// if not chassis or not engine then
45889: LD_VAR 0 1
45893: NOT
45894: PUSH
45895: LD_VAR 0 2
45899: NOT
45900: OR
45901: IFFALSE 45905
// exit ;
45903: GO 46101
// case engine of engine_solar :
45905: LD_VAR 0 2
45909: PUSH
45910: LD_INT 2
45912: DOUBLE
45913: EQUAL
45914: IFTRUE 45918
45916: GO 45956
45918: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
45919: LD_ADDR_VAR 0 3
45923: PUSH
45924: LD_INT 11
45926: PUSH
45927: LD_INT 12
45929: PUSH
45930: LD_INT 13
45932: PUSH
45933: LD_INT 14
45935: PUSH
45936: LD_INT 1
45938: PUSH
45939: LD_INT 2
45941: PUSH
45942: LD_INT 3
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: ST_TO_ADDR
45954: GO 46085
45956: LD_INT 1
45958: DOUBLE
45959: EQUAL
45960: IFTRUE 45964
45962: GO 46026
45964: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
45965: LD_ADDR_VAR 0 3
45969: PUSH
45970: LD_INT 11
45972: PUSH
45973: LD_INT 12
45975: PUSH
45976: LD_INT 13
45978: PUSH
45979: LD_INT 14
45981: PUSH
45982: LD_INT 1
45984: PUSH
45985: LD_INT 2
45987: PUSH
45988: LD_INT 3
45990: PUSH
45991: LD_INT 4
45993: PUSH
45994: LD_INT 5
45996: PUSH
45997: LD_INT 21
45999: PUSH
46000: LD_INT 23
46002: PUSH
46003: LD_INT 22
46005: PUSH
46006: LD_INT 24
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: ST_TO_ADDR
46024: GO 46085
46026: LD_INT 3
46028: DOUBLE
46029: EQUAL
46030: IFTRUE 46034
46032: GO 46084
46034: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
46035: LD_ADDR_VAR 0 3
46039: PUSH
46040: LD_INT 13
46042: PUSH
46043: LD_INT 14
46045: PUSH
46046: LD_INT 2
46048: PUSH
46049: LD_INT 3
46051: PUSH
46052: LD_INT 4
46054: PUSH
46055: LD_INT 5
46057: PUSH
46058: LD_INT 21
46060: PUSH
46061: LD_INT 22
46063: PUSH
46064: LD_INT 23
46066: PUSH
46067: LD_INT 24
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: LIST
46078: LIST
46079: LIST
46080: LIST
46081: ST_TO_ADDR
46082: GO 46085
46084: POP
// result := ( chassis in result ) ;
46085: LD_ADDR_VAR 0 3
46089: PUSH
46090: LD_VAR 0 1
46094: PUSH
46095: LD_VAR 0 3
46099: IN
46100: ST_TO_ADDR
// end ;
46101: LD_VAR 0 3
46105: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
46106: LD_INT 0
46108: PPUSH
// if not chassis or not weapon then
46109: LD_VAR 0 1
46113: NOT
46114: PUSH
46115: LD_VAR 0 2
46119: NOT
46120: OR
46121: IFFALSE 46125
// exit ;
46123: GO 47151
// case weapon of us_machine_gun :
46125: LD_VAR 0 2
46129: PUSH
46130: LD_INT 2
46132: DOUBLE
46133: EQUAL
46134: IFTRUE 46138
46136: GO 46168
46138: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
46139: LD_ADDR_VAR 0 3
46143: PUSH
46144: LD_INT 1
46146: PUSH
46147: LD_INT 2
46149: PUSH
46150: LD_INT 3
46152: PUSH
46153: LD_INT 4
46155: PUSH
46156: LD_INT 5
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: ST_TO_ADDR
46166: GO 47135
46168: LD_INT 3
46170: DOUBLE
46171: EQUAL
46172: IFTRUE 46176
46174: GO 46206
46176: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
46177: LD_ADDR_VAR 0 3
46181: PUSH
46182: LD_INT 1
46184: PUSH
46185: LD_INT 2
46187: PUSH
46188: LD_INT 3
46190: PUSH
46191: LD_INT 4
46193: PUSH
46194: LD_INT 5
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: ST_TO_ADDR
46204: GO 47135
46206: LD_INT 11
46208: DOUBLE
46209: EQUAL
46210: IFTRUE 46214
46212: GO 46244
46214: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
46215: LD_ADDR_VAR 0 3
46219: PUSH
46220: LD_INT 1
46222: PUSH
46223: LD_INT 2
46225: PUSH
46226: LD_INT 3
46228: PUSH
46229: LD_INT 4
46231: PUSH
46232: LD_INT 5
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: ST_TO_ADDR
46242: GO 47135
46244: LD_INT 4
46246: DOUBLE
46247: EQUAL
46248: IFTRUE 46252
46250: GO 46278
46252: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
46253: LD_ADDR_VAR 0 3
46257: PUSH
46258: LD_INT 2
46260: PUSH
46261: LD_INT 3
46263: PUSH
46264: LD_INT 4
46266: PUSH
46267: LD_INT 5
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: LIST
46274: LIST
46275: ST_TO_ADDR
46276: GO 47135
46278: LD_INT 5
46280: DOUBLE
46281: EQUAL
46282: IFTRUE 46286
46284: GO 46312
46286: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
46287: LD_ADDR_VAR 0 3
46291: PUSH
46292: LD_INT 2
46294: PUSH
46295: LD_INT 3
46297: PUSH
46298: LD_INT 4
46300: PUSH
46301: LD_INT 5
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: ST_TO_ADDR
46310: GO 47135
46312: LD_INT 9
46314: DOUBLE
46315: EQUAL
46316: IFTRUE 46320
46318: GO 46346
46320: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
46321: LD_ADDR_VAR 0 3
46325: PUSH
46326: LD_INT 2
46328: PUSH
46329: LD_INT 3
46331: PUSH
46332: LD_INT 4
46334: PUSH
46335: LD_INT 5
46337: PUSH
46338: EMPTY
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: ST_TO_ADDR
46344: GO 47135
46346: LD_INT 7
46348: DOUBLE
46349: EQUAL
46350: IFTRUE 46354
46352: GO 46380
46354: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
46355: LD_ADDR_VAR 0 3
46359: PUSH
46360: LD_INT 2
46362: PUSH
46363: LD_INT 3
46365: PUSH
46366: LD_INT 4
46368: PUSH
46369: LD_INT 5
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: ST_TO_ADDR
46378: GO 47135
46380: LD_INT 12
46382: DOUBLE
46383: EQUAL
46384: IFTRUE 46388
46386: GO 46414
46388: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
46389: LD_ADDR_VAR 0 3
46393: PUSH
46394: LD_INT 2
46396: PUSH
46397: LD_INT 3
46399: PUSH
46400: LD_INT 4
46402: PUSH
46403: LD_INT 5
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: ST_TO_ADDR
46412: GO 47135
46414: LD_INT 13
46416: DOUBLE
46417: EQUAL
46418: IFTRUE 46422
46420: GO 46448
46422: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
46423: LD_ADDR_VAR 0 3
46427: PUSH
46428: LD_INT 2
46430: PUSH
46431: LD_INT 3
46433: PUSH
46434: LD_INT 4
46436: PUSH
46437: LD_INT 5
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: ST_TO_ADDR
46446: GO 47135
46448: LD_INT 14
46450: DOUBLE
46451: EQUAL
46452: IFTRUE 46456
46454: GO 46474
46456: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
46457: LD_ADDR_VAR 0 3
46461: PUSH
46462: LD_INT 4
46464: PUSH
46465: LD_INT 5
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: ST_TO_ADDR
46472: GO 47135
46474: LD_INT 6
46476: DOUBLE
46477: EQUAL
46478: IFTRUE 46482
46480: GO 46500
46482: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
46483: LD_ADDR_VAR 0 3
46487: PUSH
46488: LD_INT 4
46490: PUSH
46491: LD_INT 5
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: ST_TO_ADDR
46498: GO 47135
46500: LD_INT 10
46502: DOUBLE
46503: EQUAL
46504: IFTRUE 46508
46506: GO 46526
46508: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
46509: LD_ADDR_VAR 0 3
46513: PUSH
46514: LD_INT 4
46516: PUSH
46517: LD_INT 5
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: ST_TO_ADDR
46524: GO 47135
46526: LD_INT 22
46528: DOUBLE
46529: EQUAL
46530: IFTRUE 46534
46532: GO 46560
46534: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
46535: LD_ADDR_VAR 0 3
46539: PUSH
46540: LD_INT 11
46542: PUSH
46543: LD_INT 12
46545: PUSH
46546: LD_INT 13
46548: PUSH
46549: LD_INT 14
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: ST_TO_ADDR
46558: GO 47135
46560: LD_INT 23
46562: DOUBLE
46563: EQUAL
46564: IFTRUE 46568
46566: GO 46594
46568: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
46569: LD_ADDR_VAR 0 3
46573: PUSH
46574: LD_INT 11
46576: PUSH
46577: LD_INT 12
46579: PUSH
46580: LD_INT 13
46582: PUSH
46583: LD_INT 14
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: ST_TO_ADDR
46592: GO 47135
46594: LD_INT 24
46596: DOUBLE
46597: EQUAL
46598: IFTRUE 46602
46600: GO 46628
46602: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
46603: LD_ADDR_VAR 0 3
46607: PUSH
46608: LD_INT 11
46610: PUSH
46611: LD_INT 12
46613: PUSH
46614: LD_INT 13
46616: PUSH
46617: LD_INT 14
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: ST_TO_ADDR
46626: GO 47135
46628: LD_INT 30
46630: DOUBLE
46631: EQUAL
46632: IFTRUE 46636
46634: GO 46662
46636: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
46637: LD_ADDR_VAR 0 3
46641: PUSH
46642: LD_INT 11
46644: PUSH
46645: LD_INT 12
46647: PUSH
46648: LD_INT 13
46650: PUSH
46651: LD_INT 14
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: ST_TO_ADDR
46660: GO 47135
46662: LD_INT 25
46664: DOUBLE
46665: EQUAL
46666: IFTRUE 46670
46668: GO 46688
46670: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
46671: LD_ADDR_VAR 0 3
46675: PUSH
46676: LD_INT 13
46678: PUSH
46679: LD_INT 14
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: ST_TO_ADDR
46686: GO 47135
46688: LD_INT 27
46690: DOUBLE
46691: EQUAL
46692: IFTRUE 46696
46694: GO 46714
46696: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
46697: LD_ADDR_VAR 0 3
46701: PUSH
46702: LD_INT 13
46704: PUSH
46705: LD_INT 14
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: ST_TO_ADDR
46712: GO 47135
46714: LD_INT 28
46716: DOUBLE
46717: EQUAL
46718: IFTRUE 46722
46720: GO 46740
46722: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
46723: LD_ADDR_VAR 0 3
46727: PUSH
46728: LD_INT 13
46730: PUSH
46731: LD_INT 14
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: ST_TO_ADDR
46738: GO 47135
46740: LD_INT 29
46742: DOUBLE
46743: EQUAL
46744: IFTRUE 46748
46746: GO 46766
46748: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
46749: LD_ADDR_VAR 0 3
46753: PUSH
46754: LD_INT 13
46756: PUSH
46757: LD_INT 14
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: ST_TO_ADDR
46764: GO 47135
46766: LD_INT 31
46768: DOUBLE
46769: EQUAL
46770: IFTRUE 46774
46772: GO 46792
46774: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
46775: LD_ADDR_VAR 0 3
46779: PUSH
46780: LD_INT 13
46782: PUSH
46783: LD_INT 14
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: ST_TO_ADDR
46790: GO 47135
46792: LD_INT 26
46794: DOUBLE
46795: EQUAL
46796: IFTRUE 46800
46798: GO 46818
46800: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
46801: LD_ADDR_VAR 0 3
46805: PUSH
46806: LD_INT 13
46808: PUSH
46809: LD_INT 14
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: ST_TO_ADDR
46816: GO 47135
46818: LD_INT 42
46820: DOUBLE
46821: EQUAL
46822: IFTRUE 46826
46824: GO 46852
46826: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
46827: LD_ADDR_VAR 0 3
46831: PUSH
46832: LD_INT 21
46834: PUSH
46835: LD_INT 22
46837: PUSH
46838: LD_INT 23
46840: PUSH
46841: LD_INT 24
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: ST_TO_ADDR
46850: GO 47135
46852: LD_INT 43
46854: DOUBLE
46855: EQUAL
46856: IFTRUE 46860
46858: GO 46886
46860: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
46861: LD_ADDR_VAR 0 3
46865: PUSH
46866: LD_INT 21
46868: PUSH
46869: LD_INT 22
46871: PUSH
46872: LD_INT 23
46874: PUSH
46875: LD_INT 24
46877: PUSH
46878: EMPTY
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: ST_TO_ADDR
46884: GO 47135
46886: LD_INT 44
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 46920
46894: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
46895: LD_ADDR_VAR 0 3
46899: PUSH
46900: LD_INT 21
46902: PUSH
46903: LD_INT 22
46905: PUSH
46906: LD_INT 23
46908: PUSH
46909: LD_INT 24
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: ST_TO_ADDR
46918: GO 47135
46920: LD_INT 45
46922: DOUBLE
46923: EQUAL
46924: IFTRUE 46928
46926: GO 46954
46928: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
46929: LD_ADDR_VAR 0 3
46933: PUSH
46934: LD_INT 21
46936: PUSH
46937: LD_INT 22
46939: PUSH
46940: LD_INT 23
46942: PUSH
46943: LD_INT 24
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: ST_TO_ADDR
46952: GO 47135
46954: LD_INT 49
46956: DOUBLE
46957: EQUAL
46958: IFTRUE 46962
46960: GO 46988
46962: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
46963: LD_ADDR_VAR 0 3
46967: PUSH
46968: LD_INT 21
46970: PUSH
46971: LD_INT 22
46973: PUSH
46974: LD_INT 23
46976: PUSH
46977: LD_INT 24
46979: PUSH
46980: EMPTY
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: ST_TO_ADDR
46986: GO 47135
46988: LD_INT 51
46990: DOUBLE
46991: EQUAL
46992: IFTRUE 46996
46994: GO 47022
46996: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
46997: LD_ADDR_VAR 0 3
47001: PUSH
47002: LD_INT 21
47004: PUSH
47005: LD_INT 22
47007: PUSH
47008: LD_INT 23
47010: PUSH
47011: LD_INT 24
47013: PUSH
47014: EMPTY
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: ST_TO_ADDR
47020: GO 47135
47022: LD_INT 52
47024: DOUBLE
47025: EQUAL
47026: IFTRUE 47030
47028: GO 47056
47030: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
47031: LD_ADDR_VAR 0 3
47035: PUSH
47036: LD_INT 21
47038: PUSH
47039: LD_INT 22
47041: PUSH
47042: LD_INT 23
47044: PUSH
47045: LD_INT 24
47047: PUSH
47048: EMPTY
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: ST_TO_ADDR
47054: GO 47135
47056: LD_INT 53
47058: DOUBLE
47059: EQUAL
47060: IFTRUE 47064
47062: GO 47082
47064: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
47065: LD_ADDR_VAR 0 3
47069: PUSH
47070: LD_INT 23
47072: PUSH
47073: LD_INT 24
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: ST_TO_ADDR
47080: GO 47135
47082: LD_INT 46
47084: DOUBLE
47085: EQUAL
47086: IFTRUE 47090
47088: GO 47108
47090: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
47091: LD_ADDR_VAR 0 3
47095: PUSH
47096: LD_INT 23
47098: PUSH
47099: LD_INT 24
47101: PUSH
47102: EMPTY
47103: LIST
47104: LIST
47105: ST_TO_ADDR
47106: GO 47135
47108: LD_INT 47
47110: DOUBLE
47111: EQUAL
47112: IFTRUE 47116
47114: GO 47134
47116: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
47117: LD_ADDR_VAR 0 3
47121: PUSH
47122: LD_INT 23
47124: PUSH
47125: LD_INT 24
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: ST_TO_ADDR
47132: GO 47135
47134: POP
// result := ( chassis in result ) ;
47135: LD_ADDR_VAR 0 3
47139: PUSH
47140: LD_VAR 0 1
47144: PUSH
47145: LD_VAR 0 3
47149: IN
47150: ST_TO_ADDR
// end ;
47151: LD_VAR 0 3
47155: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
47156: LD_INT 0
47158: PPUSH
47159: PPUSH
47160: PPUSH
47161: PPUSH
47162: PPUSH
47163: PPUSH
47164: PPUSH
// result := array ;
47165: LD_ADDR_VAR 0 5
47169: PUSH
47170: LD_VAR 0 1
47174: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
47175: LD_VAR 0 1
47179: NOT
47180: PUSH
47181: LD_VAR 0 2
47185: NOT
47186: OR
47187: PUSH
47188: LD_VAR 0 3
47192: NOT
47193: OR
47194: PUSH
47195: LD_VAR 0 2
47199: PUSH
47200: LD_VAR 0 1
47204: GREATER
47205: OR
47206: PUSH
47207: LD_VAR 0 3
47211: PUSH
47212: LD_VAR 0 1
47216: GREATER
47217: OR
47218: IFFALSE 47222
// exit ;
47220: GO 47518
// if direction then
47222: LD_VAR 0 4
47226: IFFALSE 47290
// begin d := 1 ;
47228: LD_ADDR_VAR 0 9
47232: PUSH
47233: LD_INT 1
47235: ST_TO_ADDR
// if i_from > i_to then
47236: LD_VAR 0 2
47240: PUSH
47241: LD_VAR 0 3
47245: GREATER
47246: IFFALSE 47272
// length := ( array - i_from ) + i_to else
47248: LD_ADDR_VAR 0 11
47252: PUSH
47253: LD_VAR 0 1
47257: PUSH
47258: LD_VAR 0 2
47262: MINUS
47263: PUSH
47264: LD_VAR 0 3
47268: PLUS
47269: ST_TO_ADDR
47270: GO 47288
// length := i_to - i_from ;
47272: LD_ADDR_VAR 0 11
47276: PUSH
47277: LD_VAR 0 3
47281: PUSH
47282: LD_VAR 0 2
47286: MINUS
47287: ST_TO_ADDR
// end else
47288: GO 47351
// begin d := - 1 ;
47290: LD_ADDR_VAR 0 9
47294: PUSH
47295: LD_INT 1
47297: NEG
47298: ST_TO_ADDR
// if i_from > i_to then
47299: LD_VAR 0 2
47303: PUSH
47304: LD_VAR 0 3
47308: GREATER
47309: IFFALSE 47329
// length := i_from - i_to else
47311: LD_ADDR_VAR 0 11
47315: PUSH
47316: LD_VAR 0 2
47320: PUSH
47321: LD_VAR 0 3
47325: MINUS
47326: ST_TO_ADDR
47327: GO 47351
// length := ( array - i_to ) + i_from ;
47329: LD_ADDR_VAR 0 11
47333: PUSH
47334: LD_VAR 0 1
47338: PUSH
47339: LD_VAR 0 3
47343: MINUS
47344: PUSH
47345: LD_VAR 0 2
47349: PLUS
47350: ST_TO_ADDR
// end ; if not length then
47351: LD_VAR 0 11
47355: NOT
47356: IFFALSE 47360
// exit ;
47358: GO 47518
// tmp := array ;
47360: LD_ADDR_VAR 0 10
47364: PUSH
47365: LD_VAR 0 1
47369: ST_TO_ADDR
// for i = 1 to length do
47370: LD_ADDR_VAR 0 6
47374: PUSH
47375: DOUBLE
47376: LD_INT 1
47378: DEC
47379: ST_TO_ADDR
47380: LD_VAR 0 11
47384: PUSH
47385: FOR_TO
47386: IFFALSE 47506
// begin for j = 1 to array do
47388: LD_ADDR_VAR 0 7
47392: PUSH
47393: DOUBLE
47394: LD_INT 1
47396: DEC
47397: ST_TO_ADDR
47398: LD_VAR 0 1
47402: PUSH
47403: FOR_TO
47404: IFFALSE 47492
// begin k := j + d ;
47406: LD_ADDR_VAR 0 8
47410: PUSH
47411: LD_VAR 0 7
47415: PUSH
47416: LD_VAR 0 9
47420: PLUS
47421: ST_TO_ADDR
// if k > array then
47422: LD_VAR 0 8
47426: PUSH
47427: LD_VAR 0 1
47431: GREATER
47432: IFFALSE 47442
// k := 1 ;
47434: LD_ADDR_VAR 0 8
47438: PUSH
47439: LD_INT 1
47441: ST_TO_ADDR
// if not k then
47442: LD_VAR 0 8
47446: NOT
47447: IFFALSE 47459
// k := array ;
47449: LD_ADDR_VAR 0 8
47453: PUSH
47454: LD_VAR 0 1
47458: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
47459: LD_ADDR_VAR 0 10
47463: PUSH
47464: LD_VAR 0 10
47468: PPUSH
47469: LD_VAR 0 8
47473: PPUSH
47474: LD_VAR 0 1
47478: PUSH
47479: LD_VAR 0 7
47483: ARRAY
47484: PPUSH
47485: CALL_OW 1
47489: ST_TO_ADDR
// end ;
47490: GO 47403
47492: POP
47493: POP
// array := tmp ;
47494: LD_ADDR_VAR 0 1
47498: PUSH
47499: LD_VAR 0 10
47503: ST_TO_ADDR
// end ;
47504: GO 47385
47506: POP
47507: POP
// result := array ;
47508: LD_ADDR_VAR 0 5
47512: PUSH
47513: LD_VAR 0 1
47517: ST_TO_ADDR
// end ;
47518: LD_VAR 0 5
47522: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
47523: LD_INT 0
47525: PPUSH
47526: PPUSH
// result := 0 ;
47527: LD_ADDR_VAR 0 3
47531: PUSH
47532: LD_INT 0
47534: ST_TO_ADDR
// if not array or not value in array then
47535: LD_VAR 0 1
47539: NOT
47540: PUSH
47541: LD_VAR 0 2
47545: PUSH
47546: LD_VAR 0 1
47550: IN
47551: NOT
47552: OR
47553: IFFALSE 47557
// exit ;
47555: GO 47611
// for i = 1 to array do
47557: LD_ADDR_VAR 0 4
47561: PUSH
47562: DOUBLE
47563: LD_INT 1
47565: DEC
47566: ST_TO_ADDR
47567: LD_VAR 0 1
47571: PUSH
47572: FOR_TO
47573: IFFALSE 47609
// if value = array [ i ] then
47575: LD_VAR 0 2
47579: PUSH
47580: LD_VAR 0 1
47584: PUSH
47585: LD_VAR 0 4
47589: ARRAY
47590: EQUAL
47591: IFFALSE 47607
// begin result := i ;
47593: LD_ADDR_VAR 0 3
47597: PUSH
47598: LD_VAR 0 4
47602: ST_TO_ADDR
// exit ;
47603: POP
47604: POP
47605: GO 47611
// end ;
47607: GO 47572
47609: POP
47610: POP
// end ;
47611: LD_VAR 0 3
47615: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
47616: LD_INT 0
47618: PPUSH
// vc_chassis := chassis ;
47619: LD_ADDR_OWVAR 37
47623: PUSH
47624: LD_VAR 0 1
47628: ST_TO_ADDR
// vc_engine := engine ;
47629: LD_ADDR_OWVAR 39
47633: PUSH
47634: LD_VAR 0 2
47638: ST_TO_ADDR
// vc_control := control ;
47639: LD_ADDR_OWVAR 38
47643: PUSH
47644: LD_VAR 0 3
47648: ST_TO_ADDR
// vc_weapon := weapon ;
47649: LD_ADDR_OWVAR 40
47653: PUSH
47654: LD_VAR 0 4
47658: ST_TO_ADDR
// vc_fuel_battery := fuel ;
47659: LD_ADDR_OWVAR 41
47663: PUSH
47664: LD_VAR 0 5
47668: ST_TO_ADDR
// end ;
47669: LD_VAR 0 6
47673: RET
// export function WantPlant ( unit ) ; var task ; begin
47674: LD_INT 0
47676: PPUSH
47677: PPUSH
// result := false ;
47678: LD_ADDR_VAR 0 2
47682: PUSH
47683: LD_INT 0
47685: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
47686: LD_ADDR_VAR 0 3
47690: PUSH
47691: LD_VAR 0 1
47695: PPUSH
47696: CALL_OW 437
47700: ST_TO_ADDR
// if task then
47701: LD_VAR 0 3
47705: IFFALSE 47733
// if task [ 1 ] [ 1 ] = p then
47707: LD_VAR 0 3
47711: PUSH
47712: LD_INT 1
47714: ARRAY
47715: PUSH
47716: LD_INT 1
47718: ARRAY
47719: PUSH
47720: LD_STRING p
47722: EQUAL
47723: IFFALSE 47733
// result := true ;
47725: LD_ADDR_VAR 0 2
47729: PUSH
47730: LD_INT 1
47732: ST_TO_ADDR
// end ;
47733: LD_VAR 0 2
47737: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
47738: LD_INT 0
47740: PPUSH
47741: PPUSH
47742: PPUSH
47743: PPUSH
// if pos < 1 then
47744: LD_VAR 0 2
47748: PUSH
47749: LD_INT 1
47751: LESS
47752: IFFALSE 47756
// exit ;
47754: GO 48059
// if pos = 1 then
47756: LD_VAR 0 2
47760: PUSH
47761: LD_INT 1
47763: EQUAL
47764: IFFALSE 47797
// result := Replace ( arr , pos [ 1 ] , value ) else
47766: LD_ADDR_VAR 0 4
47770: PUSH
47771: LD_VAR 0 1
47775: PPUSH
47776: LD_VAR 0 2
47780: PUSH
47781: LD_INT 1
47783: ARRAY
47784: PPUSH
47785: LD_VAR 0 3
47789: PPUSH
47790: CALL_OW 1
47794: ST_TO_ADDR
47795: GO 48059
// begin tmp := arr ;
47797: LD_ADDR_VAR 0 6
47801: PUSH
47802: LD_VAR 0 1
47806: ST_TO_ADDR
// s_arr := [ tmp ] ;
47807: LD_ADDR_VAR 0 7
47811: PUSH
47812: LD_VAR 0 6
47816: PUSH
47817: EMPTY
47818: LIST
47819: ST_TO_ADDR
// for i = 1 to pos - 1 do
47820: LD_ADDR_VAR 0 5
47824: PUSH
47825: DOUBLE
47826: LD_INT 1
47828: DEC
47829: ST_TO_ADDR
47830: LD_VAR 0 2
47834: PUSH
47835: LD_INT 1
47837: MINUS
47838: PUSH
47839: FOR_TO
47840: IFFALSE 47885
// begin tmp := tmp [ pos [ i ] ] ;
47842: LD_ADDR_VAR 0 6
47846: PUSH
47847: LD_VAR 0 6
47851: PUSH
47852: LD_VAR 0 2
47856: PUSH
47857: LD_VAR 0 5
47861: ARRAY
47862: ARRAY
47863: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
47864: LD_ADDR_VAR 0 7
47868: PUSH
47869: LD_VAR 0 7
47873: PUSH
47874: LD_VAR 0 6
47878: PUSH
47879: EMPTY
47880: LIST
47881: ADD
47882: ST_TO_ADDR
// end ;
47883: GO 47839
47885: POP
47886: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
47887: LD_ADDR_VAR 0 6
47891: PUSH
47892: LD_VAR 0 6
47896: PPUSH
47897: LD_VAR 0 2
47901: PUSH
47902: LD_VAR 0 2
47906: ARRAY
47907: PPUSH
47908: LD_VAR 0 3
47912: PPUSH
47913: CALL_OW 1
47917: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
47918: LD_ADDR_VAR 0 7
47922: PUSH
47923: LD_VAR 0 7
47927: PPUSH
47928: LD_VAR 0 7
47932: PPUSH
47933: LD_VAR 0 6
47937: PPUSH
47938: CALL_OW 1
47942: ST_TO_ADDR
// for i = s_arr downto 2 do
47943: LD_ADDR_VAR 0 5
47947: PUSH
47948: DOUBLE
47949: LD_VAR 0 7
47953: INC
47954: ST_TO_ADDR
47955: LD_INT 2
47957: PUSH
47958: FOR_DOWNTO
47959: IFFALSE 48043
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
47961: LD_ADDR_VAR 0 6
47965: PUSH
47966: LD_VAR 0 7
47970: PUSH
47971: LD_VAR 0 5
47975: PUSH
47976: LD_INT 1
47978: MINUS
47979: ARRAY
47980: PPUSH
47981: LD_VAR 0 2
47985: PUSH
47986: LD_VAR 0 5
47990: PUSH
47991: LD_INT 1
47993: MINUS
47994: ARRAY
47995: PPUSH
47996: LD_VAR 0 7
48000: PUSH
48001: LD_VAR 0 5
48005: ARRAY
48006: PPUSH
48007: CALL_OW 1
48011: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
48012: LD_ADDR_VAR 0 7
48016: PUSH
48017: LD_VAR 0 7
48021: PPUSH
48022: LD_VAR 0 5
48026: PUSH
48027: LD_INT 1
48029: MINUS
48030: PPUSH
48031: LD_VAR 0 6
48035: PPUSH
48036: CALL_OW 1
48040: ST_TO_ADDR
// end ;
48041: GO 47958
48043: POP
48044: POP
// result := s_arr [ 1 ] ;
48045: LD_ADDR_VAR 0 4
48049: PUSH
48050: LD_VAR 0 7
48054: PUSH
48055: LD_INT 1
48057: ARRAY
48058: ST_TO_ADDR
// end ; end ;
48059: LD_VAR 0 4
48063: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
48064: LD_INT 0
48066: PPUSH
48067: PPUSH
// if not list then
48068: LD_VAR 0 1
48072: NOT
48073: IFFALSE 48077
// exit ;
48075: GO 48168
// i := list [ pos1 ] ;
48077: LD_ADDR_VAR 0 5
48081: PUSH
48082: LD_VAR 0 1
48086: PUSH
48087: LD_VAR 0 2
48091: ARRAY
48092: ST_TO_ADDR
// if not i then
48093: LD_VAR 0 5
48097: NOT
48098: IFFALSE 48102
// exit ;
48100: GO 48168
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
48102: LD_ADDR_VAR 0 1
48106: PUSH
48107: LD_VAR 0 1
48111: PPUSH
48112: LD_VAR 0 2
48116: PPUSH
48117: LD_VAR 0 1
48121: PUSH
48122: LD_VAR 0 3
48126: ARRAY
48127: PPUSH
48128: CALL_OW 1
48132: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
48133: LD_ADDR_VAR 0 1
48137: PUSH
48138: LD_VAR 0 1
48142: PPUSH
48143: LD_VAR 0 3
48147: PPUSH
48148: LD_VAR 0 5
48152: PPUSH
48153: CALL_OW 1
48157: ST_TO_ADDR
// result := list ;
48158: LD_ADDR_VAR 0 4
48162: PUSH
48163: LD_VAR 0 1
48167: ST_TO_ADDR
// end ;
48168: LD_VAR 0 4
48172: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
48173: LD_INT 0
48175: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
48176: LD_ADDR_VAR 0 5
48180: PUSH
48181: LD_VAR 0 1
48185: PPUSH
48186: CALL_OW 250
48190: PPUSH
48191: LD_VAR 0 1
48195: PPUSH
48196: CALL_OW 251
48200: PPUSH
48201: LD_VAR 0 2
48205: PPUSH
48206: LD_VAR 0 3
48210: PPUSH
48211: LD_VAR 0 4
48215: PPUSH
48216: CALL 48226 0 5
48220: ST_TO_ADDR
// end ;
48221: LD_VAR 0 5
48225: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
48226: LD_INT 0
48228: PPUSH
48229: PPUSH
48230: PPUSH
48231: PPUSH
// if not list then
48232: LD_VAR 0 3
48236: NOT
48237: IFFALSE 48241
// exit ;
48239: GO 48629
// result := [ ] ;
48241: LD_ADDR_VAR 0 6
48245: PUSH
48246: EMPTY
48247: ST_TO_ADDR
// for i in list do
48248: LD_ADDR_VAR 0 7
48252: PUSH
48253: LD_VAR 0 3
48257: PUSH
48258: FOR_IN
48259: IFFALSE 48461
// begin tmp := GetDistUnitXY ( i , x , y ) ;
48261: LD_ADDR_VAR 0 9
48265: PUSH
48266: LD_VAR 0 7
48270: PPUSH
48271: LD_VAR 0 1
48275: PPUSH
48276: LD_VAR 0 2
48280: PPUSH
48281: CALL_OW 297
48285: ST_TO_ADDR
// if not result then
48286: LD_VAR 0 6
48290: NOT
48291: IFFALSE 48317
// result := [ [ i , tmp ] ] else
48293: LD_ADDR_VAR 0 6
48297: PUSH
48298: LD_VAR 0 7
48302: PUSH
48303: LD_VAR 0 9
48307: PUSH
48308: EMPTY
48309: LIST
48310: LIST
48311: PUSH
48312: EMPTY
48313: LIST
48314: ST_TO_ADDR
48315: GO 48459
// begin if result [ result ] [ 2 ] < tmp then
48317: LD_VAR 0 6
48321: PUSH
48322: LD_VAR 0 6
48326: ARRAY
48327: PUSH
48328: LD_INT 2
48330: ARRAY
48331: PUSH
48332: LD_VAR 0 9
48336: LESS
48337: IFFALSE 48379
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
48339: LD_ADDR_VAR 0 6
48343: PUSH
48344: LD_VAR 0 6
48348: PPUSH
48349: LD_VAR 0 6
48353: PUSH
48354: LD_INT 1
48356: PLUS
48357: PPUSH
48358: LD_VAR 0 7
48362: PUSH
48363: LD_VAR 0 9
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PPUSH
48372: CALL_OW 2
48376: ST_TO_ADDR
48377: GO 48459
// for j = 1 to result do
48379: LD_ADDR_VAR 0 8
48383: PUSH
48384: DOUBLE
48385: LD_INT 1
48387: DEC
48388: ST_TO_ADDR
48389: LD_VAR 0 6
48393: PUSH
48394: FOR_TO
48395: IFFALSE 48457
// begin if tmp < result [ j ] [ 2 ] then
48397: LD_VAR 0 9
48401: PUSH
48402: LD_VAR 0 6
48406: PUSH
48407: LD_VAR 0 8
48411: ARRAY
48412: PUSH
48413: LD_INT 2
48415: ARRAY
48416: LESS
48417: IFFALSE 48455
// begin result := Insert ( result , j , [ i , tmp ] ) ;
48419: LD_ADDR_VAR 0 6
48423: PUSH
48424: LD_VAR 0 6
48428: PPUSH
48429: LD_VAR 0 8
48433: PPUSH
48434: LD_VAR 0 7
48438: PUSH
48439: LD_VAR 0 9
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: PPUSH
48448: CALL_OW 2
48452: ST_TO_ADDR
// break ;
48453: GO 48457
// end ; end ;
48455: GO 48394
48457: POP
48458: POP
// end ; end ;
48459: GO 48258
48461: POP
48462: POP
// if result and not asc then
48463: LD_VAR 0 6
48467: PUSH
48468: LD_VAR 0 4
48472: NOT
48473: AND
48474: IFFALSE 48549
// begin tmp := result ;
48476: LD_ADDR_VAR 0 9
48480: PUSH
48481: LD_VAR 0 6
48485: ST_TO_ADDR
// for i = tmp downto 1 do
48486: LD_ADDR_VAR 0 7
48490: PUSH
48491: DOUBLE
48492: LD_VAR 0 9
48496: INC
48497: ST_TO_ADDR
48498: LD_INT 1
48500: PUSH
48501: FOR_DOWNTO
48502: IFFALSE 48547
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
48504: LD_ADDR_VAR 0 6
48508: PUSH
48509: LD_VAR 0 6
48513: PPUSH
48514: LD_VAR 0 9
48518: PUSH
48519: LD_VAR 0 7
48523: MINUS
48524: PUSH
48525: LD_INT 1
48527: PLUS
48528: PPUSH
48529: LD_VAR 0 9
48533: PUSH
48534: LD_VAR 0 7
48538: ARRAY
48539: PPUSH
48540: CALL_OW 1
48544: ST_TO_ADDR
48545: GO 48501
48547: POP
48548: POP
// end ; tmp := [ ] ;
48549: LD_ADDR_VAR 0 9
48553: PUSH
48554: EMPTY
48555: ST_TO_ADDR
// if mode then
48556: LD_VAR 0 5
48560: IFFALSE 48629
// begin for i = 1 to result do
48562: LD_ADDR_VAR 0 7
48566: PUSH
48567: DOUBLE
48568: LD_INT 1
48570: DEC
48571: ST_TO_ADDR
48572: LD_VAR 0 6
48576: PUSH
48577: FOR_TO
48578: IFFALSE 48617
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
48580: LD_ADDR_VAR 0 9
48584: PUSH
48585: LD_VAR 0 9
48589: PPUSH
48590: LD_VAR 0 7
48594: PPUSH
48595: LD_VAR 0 6
48599: PUSH
48600: LD_VAR 0 7
48604: ARRAY
48605: PUSH
48606: LD_INT 1
48608: ARRAY
48609: PPUSH
48610: CALL_OW 1
48614: ST_TO_ADDR
48615: GO 48577
48617: POP
48618: POP
// result := tmp ;
48619: LD_ADDR_VAR 0 6
48623: PUSH
48624: LD_VAR 0 9
48628: ST_TO_ADDR
// end ; end ;
48629: LD_VAR 0 6
48633: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
48634: LD_INT 0
48636: PPUSH
48637: PPUSH
48638: PPUSH
48639: PPUSH
48640: PPUSH
48641: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
48642: LD_ADDR_VAR 0 5
48646: PUSH
48647: LD_INT 0
48649: PUSH
48650: LD_INT 0
48652: PUSH
48653: LD_INT 0
48655: PUSH
48656: EMPTY
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: ST_TO_ADDR
// if not x or not y then
48664: LD_VAR 0 2
48668: NOT
48669: PUSH
48670: LD_VAR 0 3
48674: NOT
48675: OR
48676: IFFALSE 48680
// exit ;
48678: GO 50326
// if not range then
48680: LD_VAR 0 4
48684: NOT
48685: IFFALSE 48695
// range := 10 ;
48687: LD_ADDR_VAR 0 4
48691: PUSH
48692: LD_INT 10
48694: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48695: LD_ADDR_VAR 0 8
48699: PUSH
48700: LD_INT 81
48702: PUSH
48703: LD_VAR 0 1
48707: PUSH
48708: EMPTY
48709: LIST
48710: LIST
48711: PUSH
48712: LD_INT 92
48714: PUSH
48715: LD_VAR 0 2
48719: PUSH
48720: LD_VAR 0 3
48724: PUSH
48725: LD_VAR 0 4
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: LIST
48734: LIST
48735: PUSH
48736: LD_INT 3
48738: PUSH
48739: LD_INT 21
48741: PUSH
48742: LD_INT 3
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: PUSH
48749: EMPTY
48750: LIST
48751: LIST
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: LIST
48757: PPUSH
48758: CALL_OW 69
48762: ST_TO_ADDR
// if not tmp then
48763: LD_VAR 0 8
48767: NOT
48768: IFFALSE 48772
// exit ;
48770: GO 50326
// for i in tmp do
48772: LD_ADDR_VAR 0 6
48776: PUSH
48777: LD_VAR 0 8
48781: PUSH
48782: FOR_IN
48783: IFFALSE 50301
// begin points := [ 0 , 0 , 0 ] ;
48785: LD_ADDR_VAR 0 9
48789: PUSH
48790: LD_INT 0
48792: PUSH
48793: LD_INT 0
48795: PUSH
48796: LD_INT 0
48798: PUSH
48799: EMPTY
48800: LIST
48801: LIST
48802: LIST
48803: ST_TO_ADDR
// bpoints := 1 ;
48804: LD_ADDR_VAR 0 10
48808: PUSH
48809: LD_INT 1
48811: ST_TO_ADDR
// case GetType ( i ) of unit_human :
48812: LD_VAR 0 6
48816: PPUSH
48817: CALL_OW 247
48821: PUSH
48822: LD_INT 1
48824: DOUBLE
48825: EQUAL
48826: IFTRUE 48830
48828: GO 49408
48830: POP
// begin if GetClass ( i ) = 1 then
48831: LD_VAR 0 6
48835: PPUSH
48836: CALL_OW 257
48840: PUSH
48841: LD_INT 1
48843: EQUAL
48844: IFFALSE 48865
// points := [ 10 , 5 , 3 ] ;
48846: LD_ADDR_VAR 0 9
48850: PUSH
48851: LD_INT 10
48853: PUSH
48854: LD_INT 5
48856: PUSH
48857: LD_INT 3
48859: PUSH
48860: EMPTY
48861: LIST
48862: LIST
48863: LIST
48864: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
48865: LD_VAR 0 6
48869: PPUSH
48870: CALL_OW 257
48874: PUSH
48875: LD_INT 2
48877: PUSH
48878: LD_INT 3
48880: PUSH
48881: LD_INT 4
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: LIST
48888: IN
48889: IFFALSE 48910
// points := [ 3 , 2 , 1 ] ;
48891: LD_ADDR_VAR 0 9
48895: PUSH
48896: LD_INT 3
48898: PUSH
48899: LD_INT 2
48901: PUSH
48902: LD_INT 1
48904: PUSH
48905: EMPTY
48906: LIST
48907: LIST
48908: LIST
48909: ST_TO_ADDR
// if GetClass ( i ) = 5 then
48910: LD_VAR 0 6
48914: PPUSH
48915: CALL_OW 257
48919: PUSH
48920: LD_INT 5
48922: EQUAL
48923: IFFALSE 48944
// points := [ 130 , 5 , 2 ] ;
48925: LD_ADDR_VAR 0 9
48929: PUSH
48930: LD_INT 130
48932: PUSH
48933: LD_INT 5
48935: PUSH
48936: LD_INT 2
48938: PUSH
48939: EMPTY
48940: LIST
48941: LIST
48942: LIST
48943: ST_TO_ADDR
// if GetClass ( i ) = 8 then
48944: LD_VAR 0 6
48948: PPUSH
48949: CALL_OW 257
48953: PUSH
48954: LD_INT 8
48956: EQUAL
48957: IFFALSE 48978
// points := [ 35 , 35 , 30 ] ;
48959: LD_ADDR_VAR 0 9
48963: PUSH
48964: LD_INT 35
48966: PUSH
48967: LD_INT 35
48969: PUSH
48970: LD_INT 30
48972: PUSH
48973: EMPTY
48974: LIST
48975: LIST
48976: LIST
48977: ST_TO_ADDR
// if GetClass ( i ) = 9 then
48978: LD_VAR 0 6
48982: PPUSH
48983: CALL_OW 257
48987: PUSH
48988: LD_INT 9
48990: EQUAL
48991: IFFALSE 49012
// points := [ 20 , 55 , 40 ] ;
48993: LD_ADDR_VAR 0 9
48997: PUSH
48998: LD_INT 20
49000: PUSH
49001: LD_INT 55
49003: PUSH
49004: LD_INT 40
49006: PUSH
49007: EMPTY
49008: LIST
49009: LIST
49010: LIST
49011: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
49012: LD_VAR 0 6
49016: PPUSH
49017: CALL_OW 257
49021: PUSH
49022: LD_INT 12
49024: PUSH
49025: LD_INT 16
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: IN
49032: IFFALSE 49053
// points := [ 5 , 3 , 2 ] ;
49034: LD_ADDR_VAR 0 9
49038: PUSH
49039: LD_INT 5
49041: PUSH
49042: LD_INT 3
49044: PUSH
49045: LD_INT 2
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: LIST
49052: ST_TO_ADDR
// if GetClass ( i ) = 17 then
49053: LD_VAR 0 6
49057: PPUSH
49058: CALL_OW 257
49062: PUSH
49063: LD_INT 17
49065: EQUAL
49066: IFFALSE 49087
// points := [ 100 , 50 , 75 ] ;
49068: LD_ADDR_VAR 0 9
49072: PUSH
49073: LD_INT 100
49075: PUSH
49076: LD_INT 50
49078: PUSH
49079: LD_INT 75
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: LIST
49086: ST_TO_ADDR
// if GetClass ( i ) = 15 then
49087: LD_VAR 0 6
49091: PPUSH
49092: CALL_OW 257
49096: PUSH
49097: LD_INT 15
49099: EQUAL
49100: IFFALSE 49121
// points := [ 10 , 5 , 3 ] ;
49102: LD_ADDR_VAR 0 9
49106: PUSH
49107: LD_INT 10
49109: PUSH
49110: LD_INT 5
49112: PUSH
49113: LD_INT 3
49115: PUSH
49116: EMPTY
49117: LIST
49118: LIST
49119: LIST
49120: ST_TO_ADDR
// if GetClass ( i ) = 14 then
49121: LD_VAR 0 6
49125: PPUSH
49126: CALL_OW 257
49130: PUSH
49131: LD_INT 14
49133: EQUAL
49134: IFFALSE 49155
// points := [ 10 , 0 , 0 ] ;
49136: LD_ADDR_VAR 0 9
49140: PUSH
49141: LD_INT 10
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: LD_INT 0
49149: PUSH
49150: EMPTY
49151: LIST
49152: LIST
49153: LIST
49154: ST_TO_ADDR
// if GetClass ( i ) = 11 then
49155: LD_VAR 0 6
49159: PPUSH
49160: CALL_OW 257
49164: PUSH
49165: LD_INT 11
49167: EQUAL
49168: IFFALSE 49189
// points := [ 30 , 10 , 5 ] ;
49170: LD_ADDR_VAR 0 9
49174: PUSH
49175: LD_INT 30
49177: PUSH
49178: LD_INT 10
49180: PUSH
49181: LD_INT 5
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: LIST
49188: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
49189: LD_VAR 0 1
49193: PPUSH
49194: LD_INT 5
49196: PPUSH
49197: CALL_OW 321
49201: PUSH
49202: LD_INT 2
49204: EQUAL
49205: IFFALSE 49222
// bpoints := bpoints * 1.8 ;
49207: LD_ADDR_VAR 0 10
49211: PUSH
49212: LD_VAR 0 10
49216: PUSH
49217: LD_REAL  1.80000000000000E+0000
49220: MUL
49221: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
49222: LD_VAR 0 6
49226: PPUSH
49227: CALL_OW 257
49231: PUSH
49232: LD_INT 1
49234: PUSH
49235: LD_INT 2
49237: PUSH
49238: LD_INT 3
49240: PUSH
49241: LD_INT 4
49243: PUSH
49244: EMPTY
49245: LIST
49246: LIST
49247: LIST
49248: LIST
49249: IN
49250: PUSH
49251: LD_VAR 0 1
49255: PPUSH
49256: LD_INT 51
49258: PPUSH
49259: CALL_OW 321
49263: PUSH
49264: LD_INT 2
49266: EQUAL
49267: AND
49268: IFFALSE 49285
// bpoints := bpoints * 1.2 ;
49270: LD_ADDR_VAR 0 10
49274: PUSH
49275: LD_VAR 0 10
49279: PUSH
49280: LD_REAL  1.20000000000000E+0000
49283: MUL
49284: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
49285: LD_VAR 0 6
49289: PPUSH
49290: CALL_OW 257
49294: PUSH
49295: LD_INT 5
49297: PUSH
49298: LD_INT 7
49300: PUSH
49301: LD_INT 9
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: LIST
49308: IN
49309: PUSH
49310: LD_VAR 0 1
49314: PPUSH
49315: LD_INT 52
49317: PPUSH
49318: CALL_OW 321
49322: PUSH
49323: LD_INT 2
49325: EQUAL
49326: AND
49327: IFFALSE 49344
// bpoints := bpoints * 1.5 ;
49329: LD_ADDR_VAR 0 10
49333: PUSH
49334: LD_VAR 0 10
49338: PUSH
49339: LD_REAL  1.50000000000000E+0000
49342: MUL
49343: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
49344: LD_VAR 0 1
49348: PPUSH
49349: LD_INT 66
49351: PPUSH
49352: CALL_OW 321
49356: PUSH
49357: LD_INT 2
49359: EQUAL
49360: IFFALSE 49377
// bpoints := bpoints * 1.1 ;
49362: LD_ADDR_VAR 0 10
49366: PUSH
49367: LD_VAR 0 10
49371: PUSH
49372: LD_REAL  1.10000000000000E+0000
49375: MUL
49376: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
49377: LD_ADDR_VAR 0 10
49381: PUSH
49382: LD_VAR 0 10
49386: PUSH
49387: LD_VAR 0 6
49391: PPUSH
49392: LD_INT 1
49394: PPUSH
49395: CALL_OW 259
49399: PUSH
49400: LD_REAL  1.15000000000000E+0000
49403: MUL
49404: MUL
49405: ST_TO_ADDR
// end ; unit_vehicle :
49406: GO 50230
49408: LD_INT 2
49410: DOUBLE
49411: EQUAL
49412: IFTRUE 49416
49414: GO 50218
49416: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
49417: LD_VAR 0 6
49421: PPUSH
49422: CALL_OW 264
49426: PUSH
49427: LD_INT 2
49429: PUSH
49430: LD_INT 42
49432: PUSH
49433: LD_INT 24
49435: PUSH
49436: EMPTY
49437: LIST
49438: LIST
49439: LIST
49440: IN
49441: IFFALSE 49462
// points := [ 25 , 5 , 3 ] ;
49443: LD_ADDR_VAR 0 9
49447: PUSH
49448: LD_INT 25
49450: PUSH
49451: LD_INT 5
49453: PUSH
49454: LD_INT 3
49456: PUSH
49457: EMPTY
49458: LIST
49459: LIST
49460: LIST
49461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
49462: LD_VAR 0 6
49466: PPUSH
49467: CALL_OW 264
49471: PUSH
49472: LD_INT 4
49474: PUSH
49475: LD_INT 43
49477: PUSH
49478: LD_INT 25
49480: PUSH
49481: EMPTY
49482: LIST
49483: LIST
49484: LIST
49485: IN
49486: IFFALSE 49507
// points := [ 40 , 15 , 5 ] ;
49488: LD_ADDR_VAR 0 9
49492: PUSH
49493: LD_INT 40
49495: PUSH
49496: LD_INT 15
49498: PUSH
49499: LD_INT 5
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: LIST
49506: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
49507: LD_VAR 0 6
49511: PPUSH
49512: CALL_OW 264
49516: PUSH
49517: LD_INT 3
49519: PUSH
49520: LD_INT 23
49522: PUSH
49523: EMPTY
49524: LIST
49525: LIST
49526: IN
49527: IFFALSE 49548
// points := [ 7 , 25 , 8 ] ;
49529: LD_ADDR_VAR 0 9
49533: PUSH
49534: LD_INT 7
49536: PUSH
49537: LD_INT 25
49539: PUSH
49540: LD_INT 8
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: LIST
49547: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
49548: LD_VAR 0 6
49552: PPUSH
49553: CALL_OW 264
49557: PUSH
49558: LD_INT 5
49560: PUSH
49561: LD_INT 27
49563: PUSH
49564: LD_INT 44
49566: PUSH
49567: EMPTY
49568: LIST
49569: LIST
49570: LIST
49571: IN
49572: IFFALSE 49593
// points := [ 14 , 50 , 16 ] ;
49574: LD_ADDR_VAR 0 9
49578: PUSH
49579: LD_INT 14
49581: PUSH
49582: LD_INT 50
49584: PUSH
49585: LD_INT 16
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: LIST
49592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
49593: LD_VAR 0 6
49597: PPUSH
49598: CALL_OW 264
49602: PUSH
49603: LD_INT 6
49605: PUSH
49606: LD_INT 46
49608: PUSH
49609: EMPTY
49610: LIST
49611: LIST
49612: IN
49613: IFFALSE 49634
// points := [ 32 , 120 , 70 ] ;
49615: LD_ADDR_VAR 0 9
49619: PUSH
49620: LD_INT 32
49622: PUSH
49623: LD_INT 120
49625: PUSH
49626: LD_INT 70
49628: PUSH
49629: EMPTY
49630: LIST
49631: LIST
49632: LIST
49633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
49634: LD_VAR 0 6
49638: PPUSH
49639: CALL_OW 264
49643: PUSH
49644: LD_INT 7
49646: PUSH
49647: LD_INT 28
49649: PUSH
49650: LD_INT 45
49652: PUSH
49653: EMPTY
49654: LIST
49655: LIST
49656: LIST
49657: IN
49658: IFFALSE 49679
// points := [ 35 , 20 , 45 ] ;
49660: LD_ADDR_VAR 0 9
49664: PUSH
49665: LD_INT 35
49667: PUSH
49668: LD_INT 20
49670: PUSH
49671: LD_INT 45
49673: PUSH
49674: EMPTY
49675: LIST
49676: LIST
49677: LIST
49678: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
49679: LD_VAR 0 6
49683: PPUSH
49684: CALL_OW 264
49688: PUSH
49689: LD_INT 47
49691: PUSH
49692: EMPTY
49693: LIST
49694: IN
49695: IFFALSE 49716
// points := [ 67 , 45 , 75 ] ;
49697: LD_ADDR_VAR 0 9
49701: PUSH
49702: LD_INT 67
49704: PUSH
49705: LD_INT 45
49707: PUSH
49708: LD_INT 75
49710: PUSH
49711: EMPTY
49712: LIST
49713: LIST
49714: LIST
49715: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
49716: LD_VAR 0 6
49720: PPUSH
49721: CALL_OW 264
49725: PUSH
49726: LD_INT 26
49728: PUSH
49729: EMPTY
49730: LIST
49731: IN
49732: IFFALSE 49753
// points := [ 120 , 30 , 80 ] ;
49734: LD_ADDR_VAR 0 9
49738: PUSH
49739: LD_INT 120
49741: PUSH
49742: LD_INT 30
49744: PUSH
49745: LD_INT 80
49747: PUSH
49748: EMPTY
49749: LIST
49750: LIST
49751: LIST
49752: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
49753: LD_VAR 0 6
49757: PPUSH
49758: CALL_OW 264
49762: PUSH
49763: LD_INT 22
49765: PUSH
49766: EMPTY
49767: LIST
49768: IN
49769: IFFALSE 49790
// points := [ 40 , 1 , 1 ] ;
49771: LD_ADDR_VAR 0 9
49775: PUSH
49776: LD_INT 40
49778: PUSH
49779: LD_INT 1
49781: PUSH
49782: LD_INT 1
49784: PUSH
49785: EMPTY
49786: LIST
49787: LIST
49788: LIST
49789: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
49790: LD_VAR 0 6
49794: PPUSH
49795: CALL_OW 264
49799: PUSH
49800: LD_INT 29
49802: PUSH
49803: EMPTY
49804: LIST
49805: IN
49806: IFFALSE 49827
// points := [ 70 , 200 , 400 ] ;
49808: LD_ADDR_VAR 0 9
49812: PUSH
49813: LD_INT 70
49815: PUSH
49816: LD_INT 200
49818: PUSH
49819: LD_INT 400
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
49827: LD_VAR 0 6
49831: PPUSH
49832: CALL_OW 264
49836: PUSH
49837: LD_INT 14
49839: PUSH
49840: LD_INT 53
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: IN
49847: IFFALSE 49868
// points := [ 40 , 10 , 20 ] ;
49849: LD_ADDR_VAR 0 9
49853: PUSH
49854: LD_INT 40
49856: PUSH
49857: LD_INT 10
49859: PUSH
49860: LD_INT 20
49862: PUSH
49863: EMPTY
49864: LIST
49865: LIST
49866: LIST
49867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
49868: LD_VAR 0 6
49872: PPUSH
49873: CALL_OW 264
49877: PUSH
49878: LD_INT 9
49880: PUSH
49881: EMPTY
49882: LIST
49883: IN
49884: IFFALSE 49905
// points := [ 5 , 70 , 20 ] ;
49886: LD_ADDR_VAR 0 9
49890: PUSH
49891: LD_INT 5
49893: PUSH
49894: LD_INT 70
49896: PUSH
49897: LD_INT 20
49899: PUSH
49900: EMPTY
49901: LIST
49902: LIST
49903: LIST
49904: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
49905: LD_VAR 0 6
49909: PPUSH
49910: CALL_OW 264
49914: PUSH
49915: LD_INT 10
49917: PUSH
49918: EMPTY
49919: LIST
49920: IN
49921: IFFALSE 49942
// points := [ 35 , 110 , 70 ] ;
49923: LD_ADDR_VAR 0 9
49927: PUSH
49928: LD_INT 35
49930: PUSH
49931: LD_INT 110
49933: PUSH
49934: LD_INT 70
49936: PUSH
49937: EMPTY
49938: LIST
49939: LIST
49940: LIST
49941: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
49942: LD_VAR 0 6
49946: PPUSH
49947: CALL_OW 265
49951: PUSH
49952: LD_INT 25
49954: EQUAL
49955: IFFALSE 49976
// points := [ 80 , 65 , 100 ] ;
49957: LD_ADDR_VAR 0 9
49961: PUSH
49962: LD_INT 80
49964: PUSH
49965: LD_INT 65
49967: PUSH
49968: LD_INT 100
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: LIST
49975: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
49976: LD_VAR 0 6
49980: PPUSH
49981: CALL_OW 263
49985: PUSH
49986: LD_INT 1
49988: EQUAL
49989: IFFALSE 50024
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
49991: LD_ADDR_VAR 0 10
49995: PUSH
49996: LD_VAR 0 10
50000: PUSH
50001: LD_VAR 0 6
50005: PPUSH
50006: CALL_OW 311
50010: PPUSH
50011: LD_INT 3
50013: PPUSH
50014: CALL_OW 259
50018: PUSH
50019: LD_INT 4
50021: MUL
50022: MUL
50023: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
50024: LD_VAR 0 6
50028: PPUSH
50029: CALL_OW 263
50033: PUSH
50034: LD_INT 2
50036: EQUAL
50037: IFFALSE 50088
// begin j := IsControledBy ( i ) ;
50039: LD_ADDR_VAR 0 7
50043: PUSH
50044: LD_VAR 0 6
50048: PPUSH
50049: CALL_OW 312
50053: ST_TO_ADDR
// if j then
50054: LD_VAR 0 7
50058: IFFALSE 50088
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
50060: LD_ADDR_VAR 0 10
50064: PUSH
50065: LD_VAR 0 10
50069: PUSH
50070: LD_VAR 0 7
50074: PPUSH
50075: LD_INT 3
50077: PPUSH
50078: CALL_OW 259
50082: PUSH
50083: LD_INT 3
50085: MUL
50086: MUL
50087: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
50088: LD_VAR 0 6
50092: PPUSH
50093: CALL_OW 264
50097: PUSH
50098: LD_INT 5
50100: PUSH
50101: LD_INT 6
50103: PUSH
50104: LD_INT 46
50106: PUSH
50107: LD_INT 44
50109: PUSH
50110: LD_INT 47
50112: PUSH
50113: LD_INT 45
50115: PUSH
50116: LD_INT 28
50118: PUSH
50119: LD_INT 7
50121: PUSH
50122: LD_INT 27
50124: PUSH
50125: LD_INT 29
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: LIST
50132: LIST
50133: LIST
50134: LIST
50135: LIST
50136: LIST
50137: LIST
50138: LIST
50139: IN
50140: PUSH
50141: LD_VAR 0 1
50145: PPUSH
50146: LD_INT 52
50148: PPUSH
50149: CALL_OW 321
50153: PUSH
50154: LD_INT 2
50156: EQUAL
50157: AND
50158: IFFALSE 50175
// bpoints := bpoints * 1.2 ;
50160: LD_ADDR_VAR 0 10
50164: PUSH
50165: LD_VAR 0 10
50169: PUSH
50170: LD_REAL  1.20000000000000E+0000
50173: MUL
50174: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
50175: LD_VAR 0 6
50179: PPUSH
50180: CALL_OW 264
50184: PUSH
50185: LD_INT 6
50187: PUSH
50188: LD_INT 46
50190: PUSH
50191: LD_INT 47
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: LIST
50198: IN
50199: IFFALSE 50216
// bpoints := bpoints * 1.2 ;
50201: LD_ADDR_VAR 0 10
50205: PUSH
50206: LD_VAR 0 10
50210: PUSH
50211: LD_REAL  1.20000000000000E+0000
50214: MUL
50215: ST_TO_ADDR
// end ; unit_building :
50216: GO 50230
50218: LD_INT 3
50220: DOUBLE
50221: EQUAL
50222: IFTRUE 50226
50224: GO 50229
50226: POP
// ; end ;
50227: GO 50230
50229: POP
// for j = 1 to 3 do
50230: LD_ADDR_VAR 0 7
50234: PUSH
50235: DOUBLE
50236: LD_INT 1
50238: DEC
50239: ST_TO_ADDR
50240: LD_INT 3
50242: PUSH
50243: FOR_TO
50244: IFFALSE 50297
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
50246: LD_ADDR_VAR 0 5
50250: PUSH
50251: LD_VAR 0 5
50255: PPUSH
50256: LD_VAR 0 7
50260: PPUSH
50261: LD_VAR 0 5
50265: PUSH
50266: LD_VAR 0 7
50270: ARRAY
50271: PUSH
50272: LD_VAR 0 9
50276: PUSH
50277: LD_VAR 0 7
50281: ARRAY
50282: PUSH
50283: LD_VAR 0 10
50287: MUL
50288: PLUS
50289: PPUSH
50290: CALL_OW 1
50294: ST_TO_ADDR
50295: GO 50243
50297: POP
50298: POP
// end ;
50299: GO 48782
50301: POP
50302: POP
// result := Replace ( result , 4 , tmp ) ;
50303: LD_ADDR_VAR 0 5
50307: PUSH
50308: LD_VAR 0 5
50312: PPUSH
50313: LD_INT 4
50315: PPUSH
50316: LD_VAR 0 8
50320: PPUSH
50321: CALL_OW 1
50325: ST_TO_ADDR
// end ;
50326: LD_VAR 0 5
50330: RET
// export function DangerAtRange ( unit , range ) ; begin
50331: LD_INT 0
50333: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
50334: LD_ADDR_VAR 0 3
50338: PUSH
50339: LD_VAR 0 1
50343: PPUSH
50344: CALL_OW 255
50348: PPUSH
50349: LD_VAR 0 1
50353: PPUSH
50354: CALL_OW 250
50358: PPUSH
50359: LD_VAR 0 1
50363: PPUSH
50364: CALL_OW 251
50368: PPUSH
50369: LD_VAR 0 2
50373: PPUSH
50374: CALL 48634 0 4
50378: ST_TO_ADDR
// end ;
50379: LD_VAR 0 3
50383: RET
// export function DangerInArea ( side , area ) ; begin
50384: LD_INT 0
50386: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
50387: LD_ADDR_VAR 0 3
50391: PUSH
50392: LD_VAR 0 2
50396: PPUSH
50397: LD_INT 81
50399: PUSH
50400: LD_VAR 0 1
50404: PUSH
50405: EMPTY
50406: LIST
50407: LIST
50408: PPUSH
50409: CALL_OW 70
50413: ST_TO_ADDR
// end ;
50414: LD_VAR 0 3
50418: RET
// export function IsExtension ( b ) ; begin
50419: LD_INT 0
50421: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
50422: LD_ADDR_VAR 0 2
50426: PUSH
50427: LD_VAR 0 1
50431: PUSH
50432: LD_INT 23
50434: PUSH
50435: LD_INT 20
50437: PUSH
50438: LD_INT 22
50440: PUSH
50441: LD_INT 17
50443: PUSH
50444: LD_INT 24
50446: PUSH
50447: LD_INT 21
50449: PUSH
50450: LD_INT 19
50452: PUSH
50453: LD_INT 16
50455: PUSH
50456: LD_INT 25
50458: PUSH
50459: LD_INT 18
50461: PUSH
50462: EMPTY
50463: LIST
50464: LIST
50465: LIST
50466: LIST
50467: LIST
50468: LIST
50469: LIST
50470: LIST
50471: LIST
50472: LIST
50473: IN
50474: ST_TO_ADDR
// end ;
50475: LD_VAR 0 2
50479: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
50480: LD_INT 0
50482: PPUSH
50483: PPUSH
50484: PPUSH
// result := [ ] ;
50485: LD_ADDR_VAR 0 3
50489: PUSH
50490: EMPTY
50491: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
50492: LD_ADDR_VAR 0 4
50496: PUSH
50497: LD_VAR 0 2
50501: PPUSH
50502: LD_INT 21
50504: PUSH
50505: LD_INT 3
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: PPUSH
50512: CALL_OW 70
50516: ST_TO_ADDR
// if not tmp then
50517: LD_VAR 0 4
50521: NOT
50522: IFFALSE 50526
// exit ;
50524: GO 50584
// for i in tmp do
50526: LD_ADDR_VAR 0 5
50530: PUSH
50531: LD_VAR 0 4
50535: PUSH
50536: FOR_IN
50537: IFFALSE 50572
// if GetBase ( i ) <> base then
50539: LD_VAR 0 5
50543: PPUSH
50544: CALL_OW 274
50548: PUSH
50549: LD_VAR 0 1
50553: NONEQUAL
50554: IFFALSE 50570
// ComLinkToBase ( base , i ) ;
50556: LD_VAR 0 1
50560: PPUSH
50561: LD_VAR 0 5
50565: PPUSH
50566: CALL_OW 169
50570: GO 50536
50572: POP
50573: POP
// result := tmp ;
50574: LD_ADDR_VAR 0 3
50578: PUSH
50579: LD_VAR 0 4
50583: ST_TO_ADDR
// end ;
50584: LD_VAR 0 3
50588: RET
// export function ComComplete ( unit , b ) ; var i ; begin
50589: LD_INT 0
50591: PPUSH
50592: PPUSH
// if BuildingStatus ( b ) = bs_build then
50593: LD_VAR 0 2
50597: PPUSH
50598: CALL_OW 461
50602: PUSH
50603: LD_INT 1
50605: EQUAL
50606: IFFALSE 50666
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
50608: LD_VAR 0 1
50612: PPUSH
50613: LD_STRING h
50615: PUSH
50616: LD_VAR 0 2
50620: PPUSH
50621: CALL_OW 250
50625: PUSH
50626: LD_VAR 0 2
50630: PPUSH
50631: CALL_OW 251
50635: PUSH
50636: LD_VAR 0 2
50640: PUSH
50641: LD_INT 0
50643: PUSH
50644: LD_INT 0
50646: PUSH
50647: LD_INT 0
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: LIST
50654: LIST
50655: LIST
50656: LIST
50657: LIST
50658: PUSH
50659: EMPTY
50660: LIST
50661: PPUSH
50662: CALL_OW 446
// end ;
50666: LD_VAR 0 3
50670: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
50671: LD_INT 0
50673: PPUSH
50674: PPUSH
50675: PPUSH
50676: PPUSH
50677: PPUSH
50678: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
50679: LD_VAR 0 1
50683: NOT
50684: PUSH
50685: LD_VAR 0 1
50689: PPUSH
50690: CALL_OW 263
50694: PUSH
50695: LD_INT 2
50697: EQUAL
50698: NOT
50699: OR
50700: IFFALSE 50704
// exit ;
50702: GO 51020
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
50704: LD_ADDR_VAR 0 6
50708: PUSH
50709: LD_INT 22
50711: PUSH
50712: LD_VAR 0 1
50716: PPUSH
50717: CALL_OW 255
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: PUSH
50726: LD_INT 2
50728: PUSH
50729: LD_INT 30
50731: PUSH
50732: LD_INT 36
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 34
50741: PUSH
50742: LD_INT 31
50744: PUSH
50745: EMPTY
50746: LIST
50747: LIST
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: LIST
50753: PUSH
50754: EMPTY
50755: LIST
50756: LIST
50757: PPUSH
50758: CALL_OW 69
50762: ST_TO_ADDR
// if not tmp then
50763: LD_VAR 0 6
50767: NOT
50768: IFFALSE 50772
// exit ;
50770: GO 51020
// result := [ ] ;
50772: LD_ADDR_VAR 0 2
50776: PUSH
50777: EMPTY
50778: ST_TO_ADDR
// for i in tmp do
50779: LD_ADDR_VAR 0 3
50783: PUSH
50784: LD_VAR 0 6
50788: PUSH
50789: FOR_IN
50790: IFFALSE 50861
// begin t := UnitsInside ( i ) ;
50792: LD_ADDR_VAR 0 4
50796: PUSH
50797: LD_VAR 0 3
50801: PPUSH
50802: CALL_OW 313
50806: ST_TO_ADDR
// if t then
50807: LD_VAR 0 4
50811: IFFALSE 50859
// for j in t do
50813: LD_ADDR_VAR 0 7
50817: PUSH
50818: LD_VAR 0 4
50822: PUSH
50823: FOR_IN
50824: IFFALSE 50857
// result := Insert ( result , result + 1 , j ) ;
50826: LD_ADDR_VAR 0 2
50830: PUSH
50831: LD_VAR 0 2
50835: PPUSH
50836: LD_VAR 0 2
50840: PUSH
50841: LD_INT 1
50843: PLUS
50844: PPUSH
50845: LD_VAR 0 7
50849: PPUSH
50850: CALL_OW 2
50854: ST_TO_ADDR
50855: GO 50823
50857: POP
50858: POP
// end ;
50859: GO 50789
50861: POP
50862: POP
// if not result then
50863: LD_VAR 0 2
50867: NOT
50868: IFFALSE 50872
// exit ;
50870: GO 51020
// mech := result [ 1 ] ;
50872: LD_ADDR_VAR 0 5
50876: PUSH
50877: LD_VAR 0 2
50881: PUSH
50882: LD_INT 1
50884: ARRAY
50885: ST_TO_ADDR
// if result > 1 then
50886: LD_VAR 0 2
50890: PUSH
50891: LD_INT 1
50893: GREATER
50894: IFFALSE 51006
// for i = 2 to result do
50896: LD_ADDR_VAR 0 3
50900: PUSH
50901: DOUBLE
50902: LD_INT 2
50904: DEC
50905: ST_TO_ADDR
50906: LD_VAR 0 2
50910: PUSH
50911: FOR_TO
50912: IFFALSE 51004
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
50914: LD_ADDR_VAR 0 4
50918: PUSH
50919: LD_VAR 0 2
50923: PUSH
50924: LD_VAR 0 3
50928: ARRAY
50929: PPUSH
50930: LD_INT 3
50932: PPUSH
50933: CALL_OW 259
50937: PUSH
50938: LD_VAR 0 2
50942: PUSH
50943: LD_VAR 0 3
50947: ARRAY
50948: PPUSH
50949: CALL_OW 432
50953: MINUS
50954: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
50955: LD_VAR 0 4
50959: PUSH
50960: LD_VAR 0 5
50964: PPUSH
50965: LD_INT 3
50967: PPUSH
50968: CALL_OW 259
50972: PUSH
50973: LD_VAR 0 5
50977: PPUSH
50978: CALL_OW 432
50982: MINUS
50983: GREATEREQUAL
50984: IFFALSE 51002
// mech := result [ i ] ;
50986: LD_ADDR_VAR 0 5
50990: PUSH
50991: LD_VAR 0 2
50995: PUSH
50996: LD_VAR 0 3
51000: ARRAY
51001: ST_TO_ADDR
// end ;
51002: GO 50911
51004: POP
51005: POP
// ComLinkTo ( vehicle , mech ) ;
51006: LD_VAR 0 1
51010: PPUSH
51011: LD_VAR 0 5
51015: PPUSH
51016: CALL_OW 135
// end ;
51020: LD_VAR 0 2
51024: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
51025: LD_INT 0
51027: PPUSH
51028: PPUSH
51029: PPUSH
51030: PPUSH
51031: PPUSH
51032: PPUSH
51033: PPUSH
51034: PPUSH
51035: PPUSH
51036: PPUSH
51037: PPUSH
51038: PPUSH
51039: PPUSH
// result := [ ] ;
51040: LD_ADDR_VAR 0 7
51044: PUSH
51045: EMPTY
51046: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
51047: LD_VAR 0 1
51051: PPUSH
51052: CALL_OW 266
51056: PUSH
51057: LD_INT 0
51059: PUSH
51060: LD_INT 1
51062: PUSH
51063: EMPTY
51064: LIST
51065: LIST
51066: IN
51067: NOT
51068: IFFALSE 51072
// exit ;
51070: GO 52703
// if name then
51072: LD_VAR 0 3
51076: IFFALSE 51092
// SetBName ( base_dep , name ) ;
51078: LD_VAR 0 1
51082: PPUSH
51083: LD_VAR 0 3
51087: PPUSH
51088: CALL_OW 500
// base := GetBase ( base_dep ) ;
51092: LD_ADDR_VAR 0 15
51096: PUSH
51097: LD_VAR 0 1
51101: PPUSH
51102: CALL_OW 274
51106: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
51107: LD_ADDR_VAR 0 16
51111: PUSH
51112: LD_VAR 0 1
51116: PPUSH
51117: CALL_OW 255
51121: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
51122: LD_ADDR_VAR 0 17
51126: PUSH
51127: LD_VAR 0 1
51131: PPUSH
51132: CALL_OW 248
51136: ST_TO_ADDR
// if sources then
51137: LD_VAR 0 5
51141: IFFALSE 51188
// for i = 1 to 3 do
51143: LD_ADDR_VAR 0 8
51147: PUSH
51148: DOUBLE
51149: LD_INT 1
51151: DEC
51152: ST_TO_ADDR
51153: LD_INT 3
51155: PUSH
51156: FOR_TO
51157: IFFALSE 51186
// AddResourceType ( base , i , sources [ i ] ) ;
51159: LD_VAR 0 15
51163: PPUSH
51164: LD_VAR 0 8
51168: PPUSH
51169: LD_VAR 0 5
51173: PUSH
51174: LD_VAR 0 8
51178: ARRAY
51179: PPUSH
51180: CALL_OW 276
51184: GO 51156
51186: POP
51187: POP
// buildings := GetBaseBuildings ( base , area ) ;
51188: LD_ADDR_VAR 0 18
51192: PUSH
51193: LD_VAR 0 15
51197: PPUSH
51198: LD_VAR 0 2
51202: PPUSH
51203: CALL 50480 0 2
51207: ST_TO_ADDR
// InitHc ;
51208: CALL_OW 19
// InitUc ;
51212: CALL_OW 18
// uc_side := side ;
51216: LD_ADDR_OWVAR 20
51220: PUSH
51221: LD_VAR 0 16
51225: ST_TO_ADDR
// uc_nation := nation ;
51226: LD_ADDR_OWVAR 21
51230: PUSH
51231: LD_VAR 0 17
51235: ST_TO_ADDR
// if buildings then
51236: LD_VAR 0 18
51240: IFFALSE 52562
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
51242: LD_ADDR_VAR 0 19
51246: PUSH
51247: LD_VAR 0 18
51251: PPUSH
51252: LD_INT 2
51254: PUSH
51255: LD_INT 30
51257: PUSH
51258: LD_INT 29
51260: PUSH
51261: EMPTY
51262: LIST
51263: LIST
51264: PUSH
51265: LD_INT 30
51267: PUSH
51268: LD_INT 30
51270: PUSH
51271: EMPTY
51272: LIST
51273: LIST
51274: PUSH
51275: EMPTY
51276: LIST
51277: LIST
51278: LIST
51279: PPUSH
51280: CALL_OW 72
51284: ST_TO_ADDR
// if tmp then
51285: LD_VAR 0 19
51289: IFFALSE 51337
// for i in tmp do
51291: LD_ADDR_VAR 0 8
51295: PUSH
51296: LD_VAR 0 19
51300: PUSH
51301: FOR_IN
51302: IFFALSE 51335
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
51304: LD_VAR 0 8
51308: PPUSH
51309: CALL_OW 250
51313: PPUSH
51314: LD_VAR 0 8
51318: PPUSH
51319: CALL_OW 251
51323: PPUSH
51324: LD_VAR 0 16
51328: PPUSH
51329: CALL_OW 441
51333: GO 51301
51335: POP
51336: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
51337: LD_VAR 0 18
51341: PPUSH
51342: LD_INT 2
51344: PUSH
51345: LD_INT 30
51347: PUSH
51348: LD_INT 32
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: PUSH
51355: LD_INT 30
51357: PUSH
51358: LD_INT 33
51360: PUSH
51361: EMPTY
51362: LIST
51363: LIST
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: LIST
51369: PPUSH
51370: CALL_OW 72
51374: IFFALSE 51462
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
51376: LD_ADDR_VAR 0 8
51380: PUSH
51381: LD_VAR 0 18
51385: PPUSH
51386: LD_INT 2
51388: PUSH
51389: LD_INT 30
51391: PUSH
51392: LD_INT 32
51394: PUSH
51395: EMPTY
51396: LIST
51397: LIST
51398: PUSH
51399: LD_INT 30
51401: PUSH
51402: LD_INT 33
51404: PUSH
51405: EMPTY
51406: LIST
51407: LIST
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: LIST
51413: PPUSH
51414: CALL_OW 72
51418: PUSH
51419: FOR_IN
51420: IFFALSE 51460
// begin if not GetBWeapon ( i ) then
51422: LD_VAR 0 8
51426: PPUSH
51427: CALL_OW 269
51431: NOT
51432: IFFALSE 51458
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
51434: LD_VAR 0 8
51438: PPUSH
51439: LD_VAR 0 8
51443: PPUSH
51444: LD_VAR 0 2
51448: PPUSH
51449: CALL 52708 0 2
51453: PPUSH
51454: CALL_OW 431
// end ;
51458: GO 51419
51460: POP
51461: POP
// end ; for i = 1 to personel do
51462: LD_ADDR_VAR 0 8
51466: PUSH
51467: DOUBLE
51468: LD_INT 1
51470: DEC
51471: ST_TO_ADDR
51472: LD_VAR 0 6
51476: PUSH
51477: FOR_TO
51478: IFFALSE 52542
// begin if i > 4 then
51480: LD_VAR 0 8
51484: PUSH
51485: LD_INT 4
51487: GREATER
51488: IFFALSE 51492
// break ;
51490: GO 52542
// case i of 1 :
51492: LD_VAR 0 8
51496: PUSH
51497: LD_INT 1
51499: DOUBLE
51500: EQUAL
51501: IFTRUE 51505
51503: GO 51585
51505: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
51506: LD_ADDR_VAR 0 12
51510: PUSH
51511: LD_VAR 0 18
51515: PPUSH
51516: LD_INT 22
51518: PUSH
51519: LD_VAR 0 16
51523: PUSH
51524: EMPTY
51525: LIST
51526: LIST
51527: PUSH
51528: LD_INT 58
51530: PUSH
51531: EMPTY
51532: LIST
51533: PUSH
51534: LD_INT 2
51536: PUSH
51537: LD_INT 30
51539: PUSH
51540: LD_INT 32
51542: PUSH
51543: EMPTY
51544: LIST
51545: LIST
51546: PUSH
51547: LD_INT 30
51549: PUSH
51550: LD_INT 4
51552: PUSH
51553: EMPTY
51554: LIST
51555: LIST
51556: PUSH
51557: LD_INT 30
51559: PUSH
51560: LD_INT 5
51562: PUSH
51563: EMPTY
51564: LIST
51565: LIST
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: LIST
51577: PPUSH
51578: CALL_OW 72
51582: ST_TO_ADDR
51583: GO 51807
51585: LD_INT 2
51587: DOUBLE
51588: EQUAL
51589: IFTRUE 51593
51591: GO 51655
51593: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
51594: LD_ADDR_VAR 0 12
51598: PUSH
51599: LD_VAR 0 18
51603: PPUSH
51604: LD_INT 22
51606: PUSH
51607: LD_VAR 0 16
51611: PUSH
51612: EMPTY
51613: LIST
51614: LIST
51615: PUSH
51616: LD_INT 2
51618: PUSH
51619: LD_INT 30
51621: PUSH
51622: LD_INT 0
51624: PUSH
51625: EMPTY
51626: LIST
51627: LIST
51628: PUSH
51629: LD_INT 30
51631: PUSH
51632: LD_INT 1
51634: PUSH
51635: EMPTY
51636: LIST
51637: LIST
51638: PUSH
51639: EMPTY
51640: LIST
51641: LIST
51642: LIST
51643: PUSH
51644: EMPTY
51645: LIST
51646: LIST
51647: PPUSH
51648: CALL_OW 72
51652: ST_TO_ADDR
51653: GO 51807
51655: LD_INT 3
51657: DOUBLE
51658: EQUAL
51659: IFTRUE 51663
51661: GO 51725
51663: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
51664: LD_ADDR_VAR 0 12
51668: PUSH
51669: LD_VAR 0 18
51673: PPUSH
51674: LD_INT 22
51676: PUSH
51677: LD_VAR 0 16
51681: PUSH
51682: EMPTY
51683: LIST
51684: LIST
51685: PUSH
51686: LD_INT 2
51688: PUSH
51689: LD_INT 30
51691: PUSH
51692: LD_INT 2
51694: PUSH
51695: EMPTY
51696: LIST
51697: LIST
51698: PUSH
51699: LD_INT 30
51701: PUSH
51702: LD_INT 3
51704: PUSH
51705: EMPTY
51706: LIST
51707: LIST
51708: PUSH
51709: EMPTY
51710: LIST
51711: LIST
51712: LIST
51713: PUSH
51714: EMPTY
51715: LIST
51716: LIST
51717: PPUSH
51718: CALL_OW 72
51722: ST_TO_ADDR
51723: GO 51807
51725: LD_INT 4
51727: DOUBLE
51728: EQUAL
51729: IFTRUE 51733
51731: GO 51806
51733: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
51734: LD_ADDR_VAR 0 12
51738: PUSH
51739: LD_VAR 0 18
51743: PPUSH
51744: LD_INT 22
51746: PUSH
51747: LD_VAR 0 16
51751: PUSH
51752: EMPTY
51753: LIST
51754: LIST
51755: PUSH
51756: LD_INT 2
51758: PUSH
51759: LD_INT 30
51761: PUSH
51762: LD_INT 6
51764: PUSH
51765: EMPTY
51766: LIST
51767: LIST
51768: PUSH
51769: LD_INT 30
51771: PUSH
51772: LD_INT 7
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: PUSH
51779: LD_INT 30
51781: PUSH
51782: LD_INT 8
51784: PUSH
51785: EMPTY
51786: LIST
51787: LIST
51788: PUSH
51789: EMPTY
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: PUSH
51795: EMPTY
51796: LIST
51797: LIST
51798: PPUSH
51799: CALL_OW 72
51803: ST_TO_ADDR
51804: GO 51807
51806: POP
// if i = 1 then
51807: LD_VAR 0 8
51811: PUSH
51812: LD_INT 1
51814: EQUAL
51815: IFFALSE 51926
// begin tmp := [ ] ;
51817: LD_ADDR_VAR 0 19
51821: PUSH
51822: EMPTY
51823: ST_TO_ADDR
// for j in f do
51824: LD_ADDR_VAR 0 9
51828: PUSH
51829: LD_VAR 0 12
51833: PUSH
51834: FOR_IN
51835: IFFALSE 51908
// if GetBType ( j ) = b_bunker then
51837: LD_VAR 0 9
51841: PPUSH
51842: CALL_OW 266
51846: PUSH
51847: LD_INT 32
51849: EQUAL
51850: IFFALSE 51877
// tmp := Insert ( tmp , 1 , j ) else
51852: LD_ADDR_VAR 0 19
51856: PUSH
51857: LD_VAR 0 19
51861: PPUSH
51862: LD_INT 1
51864: PPUSH
51865: LD_VAR 0 9
51869: PPUSH
51870: CALL_OW 2
51874: ST_TO_ADDR
51875: GO 51906
// tmp := Insert ( tmp , tmp + 1 , j ) ;
51877: LD_ADDR_VAR 0 19
51881: PUSH
51882: LD_VAR 0 19
51886: PPUSH
51887: LD_VAR 0 19
51891: PUSH
51892: LD_INT 1
51894: PLUS
51895: PPUSH
51896: LD_VAR 0 9
51900: PPUSH
51901: CALL_OW 2
51905: ST_TO_ADDR
51906: GO 51834
51908: POP
51909: POP
// if tmp then
51910: LD_VAR 0 19
51914: IFFALSE 51926
// f := tmp ;
51916: LD_ADDR_VAR 0 12
51920: PUSH
51921: LD_VAR 0 19
51925: ST_TO_ADDR
// end ; x := personel [ i ] ;
51926: LD_ADDR_VAR 0 13
51930: PUSH
51931: LD_VAR 0 6
51935: PUSH
51936: LD_VAR 0 8
51940: ARRAY
51941: ST_TO_ADDR
// if x = - 1 then
51942: LD_VAR 0 13
51946: PUSH
51947: LD_INT 1
51949: NEG
51950: EQUAL
51951: IFFALSE 52160
// begin for j in f do
51953: LD_ADDR_VAR 0 9
51957: PUSH
51958: LD_VAR 0 12
51962: PUSH
51963: FOR_IN
51964: IFFALSE 52156
// repeat InitHc ;
51966: CALL_OW 19
// if GetBType ( j ) = b_barracks then
51970: LD_VAR 0 9
51974: PPUSH
51975: CALL_OW 266
51979: PUSH
51980: LD_INT 5
51982: EQUAL
51983: IFFALSE 52053
// begin if UnitsInside ( j ) < 3 then
51985: LD_VAR 0 9
51989: PPUSH
51990: CALL_OW 313
51994: PUSH
51995: LD_INT 3
51997: LESS
51998: IFFALSE 52034
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
52000: LD_INT 0
52002: PPUSH
52003: LD_INT 5
52005: PUSH
52006: LD_INT 8
52008: PUSH
52009: LD_INT 9
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: LIST
52016: PUSH
52017: LD_VAR 0 17
52021: ARRAY
52022: PPUSH
52023: LD_VAR 0 4
52027: PPUSH
52028: CALL_OW 380
52032: GO 52051
// PrepareHuman ( false , i , skill ) ;
52034: LD_INT 0
52036: PPUSH
52037: LD_VAR 0 8
52041: PPUSH
52042: LD_VAR 0 4
52046: PPUSH
52047: CALL_OW 380
// end else
52051: GO 52070
// PrepareHuman ( false , i , skill ) ;
52053: LD_INT 0
52055: PPUSH
52056: LD_VAR 0 8
52060: PPUSH
52061: LD_VAR 0 4
52065: PPUSH
52066: CALL_OW 380
// un := CreateHuman ;
52070: LD_ADDR_VAR 0 14
52074: PUSH
52075: CALL_OW 44
52079: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
52080: LD_ADDR_VAR 0 7
52084: PUSH
52085: LD_VAR 0 7
52089: PPUSH
52090: LD_INT 1
52092: PPUSH
52093: LD_VAR 0 14
52097: PPUSH
52098: CALL_OW 2
52102: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
52103: LD_VAR 0 14
52107: PPUSH
52108: LD_VAR 0 9
52112: PPUSH
52113: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
52117: LD_VAR 0 9
52121: PPUSH
52122: CALL_OW 313
52126: PUSH
52127: LD_INT 6
52129: EQUAL
52130: PUSH
52131: LD_VAR 0 9
52135: PPUSH
52136: CALL_OW 266
52140: PUSH
52141: LD_INT 32
52143: PUSH
52144: LD_INT 31
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: IN
52151: OR
52152: IFFALSE 51966
52154: GO 51963
52156: POP
52157: POP
// end else
52158: GO 52540
// for j = 1 to x do
52160: LD_ADDR_VAR 0 9
52164: PUSH
52165: DOUBLE
52166: LD_INT 1
52168: DEC
52169: ST_TO_ADDR
52170: LD_VAR 0 13
52174: PUSH
52175: FOR_TO
52176: IFFALSE 52538
// begin InitHc ;
52178: CALL_OW 19
// if not f then
52182: LD_VAR 0 12
52186: NOT
52187: IFFALSE 52276
// begin PrepareHuman ( false , i , skill ) ;
52189: LD_INT 0
52191: PPUSH
52192: LD_VAR 0 8
52196: PPUSH
52197: LD_VAR 0 4
52201: PPUSH
52202: CALL_OW 380
// un := CreateHuman ;
52206: LD_ADDR_VAR 0 14
52210: PUSH
52211: CALL_OW 44
52215: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
52216: LD_ADDR_VAR 0 7
52220: PUSH
52221: LD_VAR 0 7
52225: PPUSH
52226: LD_INT 1
52228: PPUSH
52229: LD_VAR 0 14
52233: PPUSH
52234: CALL_OW 2
52238: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
52239: LD_VAR 0 14
52243: PPUSH
52244: LD_VAR 0 1
52248: PPUSH
52249: CALL_OW 250
52253: PPUSH
52254: LD_VAR 0 1
52258: PPUSH
52259: CALL_OW 251
52263: PPUSH
52264: LD_INT 10
52266: PPUSH
52267: LD_INT 0
52269: PPUSH
52270: CALL_OW 50
// continue ;
52274: GO 52175
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
52276: LD_VAR 0 12
52280: PUSH
52281: LD_INT 1
52283: ARRAY
52284: PPUSH
52285: CALL_OW 313
52289: PUSH
52290: LD_VAR 0 12
52294: PUSH
52295: LD_INT 1
52297: ARRAY
52298: PPUSH
52299: CALL_OW 266
52303: PUSH
52304: LD_INT 32
52306: PUSH
52307: LD_INT 31
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: IN
52314: AND
52315: PUSH
52316: LD_VAR 0 12
52320: PUSH
52321: LD_INT 1
52323: ARRAY
52324: PPUSH
52325: CALL_OW 313
52329: PUSH
52330: LD_INT 6
52332: EQUAL
52333: OR
52334: IFFALSE 52354
// f := Delete ( f , 1 ) ;
52336: LD_ADDR_VAR 0 12
52340: PUSH
52341: LD_VAR 0 12
52345: PPUSH
52346: LD_INT 1
52348: PPUSH
52349: CALL_OW 3
52353: ST_TO_ADDR
// if not f then
52354: LD_VAR 0 12
52358: NOT
52359: IFFALSE 52377
// begin x := x + 2 ;
52361: LD_ADDR_VAR 0 13
52365: PUSH
52366: LD_VAR 0 13
52370: PUSH
52371: LD_INT 2
52373: PLUS
52374: ST_TO_ADDR
// continue ;
52375: GO 52175
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
52377: LD_VAR 0 12
52381: PUSH
52382: LD_INT 1
52384: ARRAY
52385: PPUSH
52386: CALL_OW 266
52390: PUSH
52391: LD_INT 5
52393: EQUAL
52394: IFFALSE 52468
// begin if UnitsInside ( f [ 1 ] ) < 3 then
52396: LD_VAR 0 12
52400: PUSH
52401: LD_INT 1
52403: ARRAY
52404: PPUSH
52405: CALL_OW 313
52409: PUSH
52410: LD_INT 3
52412: LESS
52413: IFFALSE 52449
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
52415: LD_INT 0
52417: PPUSH
52418: LD_INT 5
52420: PUSH
52421: LD_INT 8
52423: PUSH
52424: LD_INT 9
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: LIST
52431: PUSH
52432: LD_VAR 0 17
52436: ARRAY
52437: PPUSH
52438: LD_VAR 0 4
52442: PPUSH
52443: CALL_OW 380
52447: GO 52466
// PrepareHuman ( false , i , skill ) ;
52449: LD_INT 0
52451: PPUSH
52452: LD_VAR 0 8
52456: PPUSH
52457: LD_VAR 0 4
52461: PPUSH
52462: CALL_OW 380
// end else
52466: GO 52485
// PrepareHuman ( false , i , skill ) ;
52468: LD_INT 0
52470: PPUSH
52471: LD_VAR 0 8
52475: PPUSH
52476: LD_VAR 0 4
52480: PPUSH
52481: CALL_OW 380
// un := CreateHuman ;
52485: LD_ADDR_VAR 0 14
52489: PUSH
52490: CALL_OW 44
52494: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
52495: LD_ADDR_VAR 0 7
52499: PUSH
52500: LD_VAR 0 7
52504: PPUSH
52505: LD_INT 1
52507: PPUSH
52508: LD_VAR 0 14
52512: PPUSH
52513: CALL_OW 2
52517: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
52518: LD_VAR 0 14
52522: PPUSH
52523: LD_VAR 0 12
52527: PUSH
52528: LD_INT 1
52530: ARRAY
52531: PPUSH
52532: CALL_OW 52
// end ;
52536: GO 52175
52538: POP
52539: POP
// end ;
52540: GO 51477
52542: POP
52543: POP
// result := result ^ buildings ;
52544: LD_ADDR_VAR 0 7
52548: PUSH
52549: LD_VAR 0 7
52553: PUSH
52554: LD_VAR 0 18
52558: ADD
52559: ST_TO_ADDR
// end else
52560: GO 52703
// begin for i = 1 to personel do
52562: LD_ADDR_VAR 0 8
52566: PUSH
52567: DOUBLE
52568: LD_INT 1
52570: DEC
52571: ST_TO_ADDR
52572: LD_VAR 0 6
52576: PUSH
52577: FOR_TO
52578: IFFALSE 52701
// begin if i > 4 then
52580: LD_VAR 0 8
52584: PUSH
52585: LD_INT 4
52587: GREATER
52588: IFFALSE 52592
// break ;
52590: GO 52701
// x := personel [ i ] ;
52592: LD_ADDR_VAR 0 13
52596: PUSH
52597: LD_VAR 0 6
52601: PUSH
52602: LD_VAR 0 8
52606: ARRAY
52607: ST_TO_ADDR
// if x = - 1 then
52608: LD_VAR 0 13
52612: PUSH
52613: LD_INT 1
52615: NEG
52616: EQUAL
52617: IFFALSE 52621
// continue ;
52619: GO 52577
// PrepareHuman ( false , i , skill ) ;
52621: LD_INT 0
52623: PPUSH
52624: LD_VAR 0 8
52628: PPUSH
52629: LD_VAR 0 4
52633: PPUSH
52634: CALL_OW 380
// un := CreateHuman ;
52638: LD_ADDR_VAR 0 14
52642: PUSH
52643: CALL_OW 44
52647: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
52648: LD_VAR 0 14
52652: PPUSH
52653: LD_VAR 0 1
52657: PPUSH
52658: CALL_OW 250
52662: PPUSH
52663: LD_VAR 0 1
52667: PPUSH
52668: CALL_OW 251
52672: PPUSH
52673: LD_INT 10
52675: PPUSH
52676: LD_INT 0
52678: PPUSH
52679: CALL_OW 50
// result := result ^ un ;
52683: LD_ADDR_VAR 0 7
52687: PUSH
52688: LD_VAR 0 7
52692: PUSH
52693: LD_VAR 0 14
52697: ADD
52698: ST_TO_ADDR
// end ;
52699: GO 52577
52701: POP
52702: POP
// end ; end ;
52703: LD_VAR 0 7
52707: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
52708: LD_INT 0
52710: PPUSH
52711: PPUSH
52712: PPUSH
52713: PPUSH
52714: PPUSH
52715: PPUSH
52716: PPUSH
52717: PPUSH
52718: PPUSH
52719: PPUSH
52720: PPUSH
52721: PPUSH
52722: PPUSH
52723: PPUSH
52724: PPUSH
52725: PPUSH
// result := false ;
52726: LD_ADDR_VAR 0 3
52730: PUSH
52731: LD_INT 0
52733: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
52734: LD_VAR 0 1
52738: NOT
52739: PUSH
52740: LD_VAR 0 1
52744: PPUSH
52745: CALL_OW 266
52749: PUSH
52750: LD_INT 32
52752: PUSH
52753: LD_INT 33
52755: PUSH
52756: EMPTY
52757: LIST
52758: LIST
52759: IN
52760: NOT
52761: OR
52762: IFFALSE 52766
// exit ;
52764: GO 53902
// nat := GetNation ( tower ) ;
52766: LD_ADDR_VAR 0 12
52770: PUSH
52771: LD_VAR 0 1
52775: PPUSH
52776: CALL_OW 248
52780: ST_TO_ADDR
// side := GetSide ( tower ) ;
52781: LD_ADDR_VAR 0 16
52785: PUSH
52786: LD_VAR 0 1
52790: PPUSH
52791: CALL_OW 255
52795: ST_TO_ADDR
// x := GetX ( tower ) ;
52796: LD_ADDR_VAR 0 10
52800: PUSH
52801: LD_VAR 0 1
52805: PPUSH
52806: CALL_OW 250
52810: ST_TO_ADDR
// y := GetY ( tower ) ;
52811: LD_ADDR_VAR 0 11
52815: PUSH
52816: LD_VAR 0 1
52820: PPUSH
52821: CALL_OW 251
52825: ST_TO_ADDR
// if not x or not y then
52826: LD_VAR 0 10
52830: NOT
52831: PUSH
52832: LD_VAR 0 11
52836: NOT
52837: OR
52838: IFFALSE 52842
// exit ;
52840: GO 53902
// weapon := 0 ;
52842: LD_ADDR_VAR 0 18
52846: PUSH
52847: LD_INT 0
52849: ST_TO_ADDR
// fac_list := [ ] ;
52850: LD_ADDR_VAR 0 17
52854: PUSH
52855: EMPTY
52856: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
52857: LD_ADDR_VAR 0 6
52861: PUSH
52862: LD_VAR 0 1
52866: PPUSH
52867: CALL_OW 274
52871: PPUSH
52872: LD_VAR 0 2
52876: PPUSH
52877: CALL 50480 0 2
52881: PPUSH
52882: LD_INT 30
52884: PUSH
52885: LD_INT 3
52887: PUSH
52888: EMPTY
52889: LIST
52890: LIST
52891: PPUSH
52892: CALL_OW 72
52896: ST_TO_ADDR
// if not factories then
52897: LD_VAR 0 6
52901: NOT
52902: IFFALSE 52906
// exit ;
52904: GO 53902
// for i in factories do
52906: LD_ADDR_VAR 0 8
52910: PUSH
52911: LD_VAR 0 6
52915: PUSH
52916: FOR_IN
52917: IFFALSE 52942
// fac_list := fac_list union AvailableWeaponList ( i ) ;
52919: LD_ADDR_VAR 0 17
52923: PUSH
52924: LD_VAR 0 17
52928: PUSH
52929: LD_VAR 0 8
52933: PPUSH
52934: CALL_OW 478
52938: UNION
52939: ST_TO_ADDR
52940: GO 52916
52942: POP
52943: POP
// if not fac_list then
52944: LD_VAR 0 17
52948: NOT
52949: IFFALSE 52953
// exit ;
52951: GO 53902
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
52953: LD_ADDR_VAR 0 5
52957: PUSH
52958: LD_INT 4
52960: PUSH
52961: LD_INT 5
52963: PUSH
52964: LD_INT 9
52966: PUSH
52967: LD_INT 10
52969: PUSH
52970: LD_INT 6
52972: PUSH
52973: LD_INT 7
52975: PUSH
52976: LD_INT 11
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: LIST
52983: LIST
52984: LIST
52985: LIST
52986: LIST
52987: PUSH
52988: LD_INT 27
52990: PUSH
52991: LD_INT 28
52993: PUSH
52994: LD_INT 26
52996: PUSH
52997: LD_INT 30
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: LIST
53004: LIST
53005: PUSH
53006: LD_INT 43
53008: PUSH
53009: LD_INT 44
53011: PUSH
53012: LD_INT 46
53014: PUSH
53015: LD_INT 45
53017: PUSH
53018: LD_INT 47
53020: PUSH
53021: LD_INT 49
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: LIST
53028: LIST
53029: LIST
53030: LIST
53031: PUSH
53032: EMPTY
53033: LIST
53034: LIST
53035: LIST
53036: PUSH
53037: LD_VAR 0 12
53041: ARRAY
53042: ST_TO_ADDR
// for i in list do
53043: LD_ADDR_VAR 0 8
53047: PUSH
53048: LD_VAR 0 5
53052: PUSH
53053: FOR_IN
53054: IFFALSE 53087
// if not i in fac_list then
53056: LD_VAR 0 8
53060: PUSH
53061: LD_VAR 0 17
53065: IN
53066: NOT
53067: IFFALSE 53085
// list := list diff i ;
53069: LD_ADDR_VAR 0 5
53073: PUSH
53074: LD_VAR 0 5
53078: PUSH
53079: LD_VAR 0 8
53083: DIFF
53084: ST_TO_ADDR
53085: GO 53053
53087: POP
53088: POP
// if not list then
53089: LD_VAR 0 5
53093: NOT
53094: IFFALSE 53098
// exit ;
53096: GO 53902
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
53098: LD_VAR 0 12
53102: PUSH
53103: LD_INT 3
53105: EQUAL
53106: PUSH
53107: LD_INT 49
53109: PUSH
53110: LD_VAR 0 5
53114: IN
53115: AND
53116: PUSH
53117: LD_INT 31
53119: PPUSH
53120: LD_VAR 0 16
53124: PPUSH
53125: CALL_OW 321
53129: PUSH
53130: LD_INT 2
53132: EQUAL
53133: AND
53134: IFFALSE 53194
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
53136: LD_INT 22
53138: PUSH
53139: LD_VAR 0 16
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: PUSH
53148: LD_INT 35
53150: PUSH
53151: LD_INT 49
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PUSH
53158: LD_INT 91
53160: PUSH
53161: LD_VAR 0 1
53165: PUSH
53166: LD_INT 10
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: LIST
53173: PUSH
53174: EMPTY
53175: LIST
53176: LIST
53177: LIST
53178: PPUSH
53179: CALL_OW 69
53183: NOT
53184: IFFALSE 53194
// weapon := ru_time_lapser ;
53186: LD_ADDR_VAR 0 18
53190: PUSH
53191: LD_INT 49
53193: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
53194: LD_VAR 0 12
53198: PUSH
53199: LD_INT 1
53201: PUSH
53202: LD_INT 2
53204: PUSH
53205: EMPTY
53206: LIST
53207: LIST
53208: IN
53209: PUSH
53210: LD_INT 11
53212: PUSH
53213: LD_VAR 0 5
53217: IN
53218: PUSH
53219: LD_INT 30
53221: PUSH
53222: LD_VAR 0 5
53226: IN
53227: OR
53228: AND
53229: PUSH
53230: LD_INT 6
53232: PPUSH
53233: LD_VAR 0 16
53237: PPUSH
53238: CALL_OW 321
53242: PUSH
53243: LD_INT 2
53245: EQUAL
53246: AND
53247: IFFALSE 53412
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
53249: LD_INT 22
53251: PUSH
53252: LD_VAR 0 16
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: PUSH
53261: LD_INT 2
53263: PUSH
53264: LD_INT 35
53266: PUSH
53267: LD_INT 11
53269: PUSH
53270: EMPTY
53271: LIST
53272: LIST
53273: PUSH
53274: LD_INT 35
53276: PUSH
53277: LD_INT 30
53279: PUSH
53280: EMPTY
53281: LIST
53282: LIST
53283: PUSH
53284: EMPTY
53285: LIST
53286: LIST
53287: LIST
53288: PUSH
53289: LD_INT 91
53291: PUSH
53292: LD_VAR 0 1
53296: PUSH
53297: LD_INT 18
53299: PUSH
53300: EMPTY
53301: LIST
53302: LIST
53303: LIST
53304: PUSH
53305: EMPTY
53306: LIST
53307: LIST
53308: LIST
53309: PPUSH
53310: CALL_OW 69
53314: NOT
53315: PUSH
53316: LD_INT 22
53318: PUSH
53319: LD_VAR 0 16
53323: PUSH
53324: EMPTY
53325: LIST
53326: LIST
53327: PUSH
53328: LD_INT 2
53330: PUSH
53331: LD_INT 30
53333: PUSH
53334: LD_INT 32
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: PUSH
53341: LD_INT 30
53343: PUSH
53344: LD_INT 33
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: LIST
53355: PUSH
53356: LD_INT 91
53358: PUSH
53359: LD_VAR 0 1
53363: PUSH
53364: LD_INT 12
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: LIST
53371: PUSH
53372: EMPTY
53373: LIST
53374: LIST
53375: LIST
53376: PUSH
53377: EMPTY
53378: LIST
53379: PPUSH
53380: CALL_OW 69
53384: PUSH
53385: LD_INT 2
53387: GREATER
53388: AND
53389: IFFALSE 53412
// weapon := [ us_radar , ar_radar ] [ nat ] ;
53391: LD_ADDR_VAR 0 18
53395: PUSH
53396: LD_INT 11
53398: PUSH
53399: LD_INT 30
53401: PUSH
53402: EMPTY
53403: LIST
53404: LIST
53405: PUSH
53406: LD_VAR 0 12
53410: ARRAY
53411: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
53412: LD_VAR 0 18
53416: NOT
53417: PUSH
53418: LD_INT 40
53420: PPUSH
53421: LD_VAR 0 16
53425: PPUSH
53426: CALL_OW 321
53430: PUSH
53431: LD_INT 2
53433: EQUAL
53434: AND
53435: PUSH
53436: LD_INT 7
53438: PUSH
53439: LD_VAR 0 5
53443: IN
53444: PUSH
53445: LD_INT 28
53447: PUSH
53448: LD_VAR 0 5
53452: IN
53453: OR
53454: PUSH
53455: LD_INT 45
53457: PUSH
53458: LD_VAR 0 5
53462: IN
53463: OR
53464: AND
53465: IFFALSE 53719
// begin hex := GetHexInfo ( x , y ) ;
53467: LD_ADDR_VAR 0 4
53471: PUSH
53472: LD_VAR 0 10
53476: PPUSH
53477: LD_VAR 0 11
53481: PPUSH
53482: CALL_OW 546
53486: ST_TO_ADDR
// if hex [ 1 ] then
53487: LD_VAR 0 4
53491: PUSH
53492: LD_INT 1
53494: ARRAY
53495: IFFALSE 53499
// exit ;
53497: GO 53902
// height := hex [ 2 ] ;
53499: LD_ADDR_VAR 0 15
53503: PUSH
53504: LD_VAR 0 4
53508: PUSH
53509: LD_INT 2
53511: ARRAY
53512: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
53513: LD_ADDR_VAR 0 14
53517: PUSH
53518: LD_INT 0
53520: PUSH
53521: LD_INT 2
53523: PUSH
53524: LD_INT 3
53526: PUSH
53527: LD_INT 5
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: LIST
53534: LIST
53535: ST_TO_ADDR
// for i in tmp do
53536: LD_ADDR_VAR 0 8
53540: PUSH
53541: LD_VAR 0 14
53545: PUSH
53546: FOR_IN
53547: IFFALSE 53717
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
53549: LD_ADDR_VAR 0 9
53553: PUSH
53554: LD_VAR 0 10
53558: PPUSH
53559: LD_VAR 0 8
53563: PPUSH
53564: LD_INT 5
53566: PPUSH
53567: CALL_OW 272
53571: PUSH
53572: LD_VAR 0 11
53576: PPUSH
53577: LD_VAR 0 8
53581: PPUSH
53582: LD_INT 5
53584: PPUSH
53585: CALL_OW 273
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53594: LD_VAR 0 9
53598: PUSH
53599: LD_INT 1
53601: ARRAY
53602: PPUSH
53603: LD_VAR 0 9
53607: PUSH
53608: LD_INT 2
53610: ARRAY
53611: PPUSH
53612: CALL_OW 488
53616: IFFALSE 53715
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
53618: LD_ADDR_VAR 0 4
53622: PUSH
53623: LD_VAR 0 9
53627: PUSH
53628: LD_INT 1
53630: ARRAY
53631: PPUSH
53632: LD_VAR 0 9
53636: PUSH
53637: LD_INT 2
53639: ARRAY
53640: PPUSH
53641: CALL_OW 546
53645: ST_TO_ADDR
// if hex [ 1 ] then
53646: LD_VAR 0 4
53650: PUSH
53651: LD_INT 1
53653: ARRAY
53654: IFFALSE 53658
// continue ;
53656: GO 53546
// h := hex [ 2 ] ;
53658: LD_ADDR_VAR 0 13
53662: PUSH
53663: LD_VAR 0 4
53667: PUSH
53668: LD_INT 2
53670: ARRAY
53671: ST_TO_ADDR
// if h + 7 < height then
53672: LD_VAR 0 13
53676: PUSH
53677: LD_INT 7
53679: PLUS
53680: PUSH
53681: LD_VAR 0 15
53685: LESS
53686: IFFALSE 53715
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
53688: LD_ADDR_VAR 0 18
53692: PUSH
53693: LD_INT 7
53695: PUSH
53696: LD_INT 28
53698: PUSH
53699: LD_INT 45
53701: PUSH
53702: EMPTY
53703: LIST
53704: LIST
53705: LIST
53706: PUSH
53707: LD_VAR 0 12
53711: ARRAY
53712: ST_TO_ADDR
// break ;
53713: GO 53717
// end ; end ; end ;
53715: GO 53546
53717: POP
53718: POP
// end ; if not weapon then
53719: LD_VAR 0 18
53723: NOT
53724: IFFALSE 53784
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
53726: LD_ADDR_VAR 0 5
53730: PUSH
53731: LD_VAR 0 5
53735: PUSH
53736: LD_INT 11
53738: PUSH
53739: LD_INT 30
53741: PUSH
53742: LD_INT 49
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: DIFF
53750: ST_TO_ADDR
// if not list then
53751: LD_VAR 0 5
53755: NOT
53756: IFFALSE 53760
// exit ;
53758: GO 53902
// weapon := list [ rand ( 1 , list ) ] ;
53760: LD_ADDR_VAR 0 18
53764: PUSH
53765: LD_VAR 0 5
53769: PUSH
53770: LD_INT 1
53772: PPUSH
53773: LD_VAR 0 5
53777: PPUSH
53778: CALL_OW 12
53782: ARRAY
53783: ST_TO_ADDR
// end ; if weapon then
53784: LD_VAR 0 18
53788: IFFALSE 53902
// begin tmp := CostOfWeapon ( weapon ) ;
53790: LD_ADDR_VAR 0 14
53794: PUSH
53795: LD_VAR 0 18
53799: PPUSH
53800: CALL_OW 451
53804: ST_TO_ADDR
// j := GetBase ( tower ) ;
53805: LD_ADDR_VAR 0 9
53809: PUSH
53810: LD_VAR 0 1
53814: PPUSH
53815: CALL_OW 274
53819: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
53820: LD_VAR 0 9
53824: PPUSH
53825: LD_INT 1
53827: PPUSH
53828: CALL_OW 275
53832: PUSH
53833: LD_VAR 0 14
53837: PUSH
53838: LD_INT 1
53840: ARRAY
53841: GREATEREQUAL
53842: PUSH
53843: LD_VAR 0 9
53847: PPUSH
53848: LD_INT 2
53850: PPUSH
53851: CALL_OW 275
53855: PUSH
53856: LD_VAR 0 14
53860: PUSH
53861: LD_INT 2
53863: ARRAY
53864: GREATEREQUAL
53865: AND
53866: PUSH
53867: LD_VAR 0 9
53871: PPUSH
53872: LD_INT 3
53874: PPUSH
53875: CALL_OW 275
53879: PUSH
53880: LD_VAR 0 14
53884: PUSH
53885: LD_INT 3
53887: ARRAY
53888: GREATEREQUAL
53889: AND
53890: IFFALSE 53902
// result := weapon ;
53892: LD_ADDR_VAR 0 3
53896: PUSH
53897: LD_VAR 0 18
53901: ST_TO_ADDR
// end ; end ;
53902: LD_VAR 0 3
53906: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
53907: LD_INT 0
53909: PPUSH
53910: PPUSH
// result := true ;
53911: LD_ADDR_VAR 0 3
53915: PUSH
53916: LD_INT 1
53918: ST_TO_ADDR
// if array1 = array2 then
53919: LD_VAR 0 1
53923: PUSH
53924: LD_VAR 0 2
53928: EQUAL
53929: IFFALSE 53989
// begin for i = 1 to array1 do
53931: LD_ADDR_VAR 0 4
53935: PUSH
53936: DOUBLE
53937: LD_INT 1
53939: DEC
53940: ST_TO_ADDR
53941: LD_VAR 0 1
53945: PUSH
53946: FOR_TO
53947: IFFALSE 53985
// if array1 [ i ] <> array2 [ i ] then
53949: LD_VAR 0 1
53953: PUSH
53954: LD_VAR 0 4
53958: ARRAY
53959: PUSH
53960: LD_VAR 0 2
53964: PUSH
53965: LD_VAR 0 4
53969: ARRAY
53970: NONEQUAL
53971: IFFALSE 53983
// begin result := false ;
53973: LD_ADDR_VAR 0 3
53977: PUSH
53978: LD_INT 0
53980: ST_TO_ADDR
// break ;
53981: GO 53985
// end ;
53983: GO 53946
53985: POP
53986: POP
// end else
53987: GO 53997
// result := false ;
53989: LD_ADDR_VAR 0 3
53993: PUSH
53994: LD_INT 0
53996: ST_TO_ADDR
// end ;
53997: LD_VAR 0 3
54001: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
54002: LD_INT 0
54004: PPUSH
54005: PPUSH
54006: PPUSH
// pom := GetBase ( fac ) ;
54007: LD_ADDR_VAR 0 5
54011: PUSH
54012: LD_VAR 0 1
54016: PPUSH
54017: CALL_OW 274
54021: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
54022: LD_ADDR_VAR 0 4
54026: PUSH
54027: LD_VAR 0 2
54031: PUSH
54032: LD_INT 1
54034: ARRAY
54035: PPUSH
54036: LD_VAR 0 2
54040: PUSH
54041: LD_INT 2
54043: ARRAY
54044: PPUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 3
54052: ARRAY
54053: PPUSH
54054: LD_VAR 0 2
54058: PUSH
54059: LD_INT 4
54061: ARRAY
54062: PPUSH
54063: CALL_OW 449
54067: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
54068: LD_ADDR_VAR 0 3
54072: PUSH
54073: LD_VAR 0 5
54077: PPUSH
54078: LD_INT 1
54080: PPUSH
54081: CALL_OW 275
54085: PUSH
54086: LD_VAR 0 4
54090: PUSH
54091: LD_INT 1
54093: ARRAY
54094: GREATEREQUAL
54095: PUSH
54096: LD_VAR 0 5
54100: PPUSH
54101: LD_INT 2
54103: PPUSH
54104: CALL_OW 275
54108: PUSH
54109: LD_VAR 0 4
54113: PUSH
54114: LD_INT 2
54116: ARRAY
54117: GREATEREQUAL
54118: AND
54119: PUSH
54120: LD_VAR 0 5
54124: PPUSH
54125: LD_INT 3
54127: PPUSH
54128: CALL_OW 275
54132: PUSH
54133: LD_VAR 0 4
54137: PUSH
54138: LD_INT 3
54140: ARRAY
54141: GREATEREQUAL
54142: AND
54143: ST_TO_ADDR
// end ;
54144: LD_VAR 0 3
54148: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
54149: LD_INT 0
54151: PPUSH
54152: PPUSH
54153: PPUSH
54154: PPUSH
// pom := GetBase ( building ) ;
54155: LD_ADDR_VAR 0 3
54159: PUSH
54160: LD_VAR 0 1
54164: PPUSH
54165: CALL_OW 274
54169: ST_TO_ADDR
// if not pom then
54170: LD_VAR 0 3
54174: NOT
54175: IFFALSE 54179
// exit ;
54177: GO 54349
// btype := GetBType ( building ) ;
54179: LD_ADDR_VAR 0 5
54183: PUSH
54184: LD_VAR 0 1
54188: PPUSH
54189: CALL_OW 266
54193: ST_TO_ADDR
// if btype = b_armoury then
54194: LD_VAR 0 5
54198: PUSH
54199: LD_INT 4
54201: EQUAL
54202: IFFALSE 54212
// btype := b_barracks ;
54204: LD_ADDR_VAR 0 5
54208: PUSH
54209: LD_INT 5
54211: ST_TO_ADDR
// if btype = b_depot then
54212: LD_VAR 0 5
54216: PUSH
54217: LD_INT 0
54219: EQUAL
54220: IFFALSE 54230
// btype := b_warehouse ;
54222: LD_ADDR_VAR 0 5
54226: PUSH
54227: LD_INT 1
54229: ST_TO_ADDR
// if btype = b_workshop then
54230: LD_VAR 0 5
54234: PUSH
54235: LD_INT 2
54237: EQUAL
54238: IFFALSE 54248
// btype := b_factory ;
54240: LD_ADDR_VAR 0 5
54244: PUSH
54245: LD_INT 3
54247: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
54248: LD_ADDR_VAR 0 4
54252: PUSH
54253: LD_VAR 0 5
54257: PPUSH
54258: LD_VAR 0 1
54262: PPUSH
54263: CALL_OW 248
54267: PPUSH
54268: CALL_OW 450
54272: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
54273: LD_ADDR_VAR 0 2
54277: PUSH
54278: LD_VAR 0 3
54282: PPUSH
54283: LD_INT 1
54285: PPUSH
54286: CALL_OW 275
54290: PUSH
54291: LD_VAR 0 4
54295: PUSH
54296: LD_INT 1
54298: ARRAY
54299: GREATEREQUAL
54300: PUSH
54301: LD_VAR 0 3
54305: PPUSH
54306: LD_INT 2
54308: PPUSH
54309: CALL_OW 275
54313: PUSH
54314: LD_VAR 0 4
54318: PUSH
54319: LD_INT 2
54321: ARRAY
54322: GREATEREQUAL
54323: AND
54324: PUSH
54325: LD_VAR 0 3
54329: PPUSH
54330: LD_INT 3
54332: PPUSH
54333: CALL_OW 275
54337: PUSH
54338: LD_VAR 0 4
54342: PUSH
54343: LD_INT 3
54345: ARRAY
54346: GREATEREQUAL
54347: AND
54348: ST_TO_ADDR
// end ;
54349: LD_VAR 0 2
54353: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
54354: LD_INT 0
54356: PPUSH
54357: PPUSH
54358: PPUSH
// pom := GetBase ( building ) ;
54359: LD_ADDR_VAR 0 4
54363: PUSH
54364: LD_VAR 0 1
54368: PPUSH
54369: CALL_OW 274
54373: ST_TO_ADDR
// if not pom then
54374: LD_VAR 0 4
54378: NOT
54379: IFFALSE 54383
// exit ;
54381: GO 54484
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
54383: LD_ADDR_VAR 0 5
54387: PUSH
54388: LD_VAR 0 2
54392: PPUSH
54393: LD_VAR 0 1
54397: PPUSH
54398: CALL_OW 248
54402: PPUSH
54403: CALL_OW 450
54407: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
54408: LD_ADDR_VAR 0 3
54412: PUSH
54413: LD_VAR 0 4
54417: PPUSH
54418: LD_INT 1
54420: PPUSH
54421: CALL_OW 275
54425: PUSH
54426: LD_VAR 0 5
54430: PUSH
54431: LD_INT 1
54433: ARRAY
54434: GREATEREQUAL
54435: PUSH
54436: LD_VAR 0 4
54440: PPUSH
54441: LD_INT 2
54443: PPUSH
54444: CALL_OW 275
54448: PUSH
54449: LD_VAR 0 5
54453: PUSH
54454: LD_INT 2
54456: ARRAY
54457: GREATEREQUAL
54458: AND
54459: PUSH
54460: LD_VAR 0 4
54464: PPUSH
54465: LD_INT 3
54467: PPUSH
54468: CALL_OW 275
54472: PUSH
54473: LD_VAR 0 5
54477: PUSH
54478: LD_INT 3
54480: ARRAY
54481: GREATEREQUAL
54482: AND
54483: ST_TO_ADDR
// end ;
54484: LD_VAR 0 3
54488: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
54489: LD_INT 0
54491: PPUSH
54492: PPUSH
54493: PPUSH
54494: PPUSH
54495: PPUSH
54496: PPUSH
54497: PPUSH
54498: PPUSH
54499: PPUSH
54500: PPUSH
// result := false ;
54501: LD_ADDR_VAR 0 6
54505: PUSH
54506: LD_INT 0
54508: ST_TO_ADDR
// if not base or not btype or not x or not y then
54509: LD_VAR 0 1
54513: NOT
54514: PUSH
54515: LD_VAR 0 2
54519: NOT
54520: OR
54521: PUSH
54522: LD_VAR 0 3
54526: NOT
54527: OR
54528: PUSH
54529: LD_VAR 0 4
54533: NOT
54534: OR
54535: IFFALSE 54539
// exit ;
54537: GO 55130
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
54539: LD_ADDR_VAR 0 12
54543: PUSH
54544: LD_VAR 0 2
54548: PPUSH
54549: LD_VAR 0 3
54553: PPUSH
54554: LD_VAR 0 4
54558: PPUSH
54559: LD_VAR 0 5
54563: PPUSH
54564: LD_VAR 0 1
54568: PUSH
54569: LD_INT 1
54571: ARRAY
54572: PPUSH
54573: CALL_OW 248
54577: PPUSH
54578: LD_INT 0
54580: PPUSH
54581: CALL 55967 0 6
54585: ST_TO_ADDR
// if not hexes then
54586: LD_VAR 0 12
54590: NOT
54591: IFFALSE 54595
// exit ;
54593: GO 55130
// for i = 1 to hexes do
54595: LD_ADDR_VAR 0 7
54599: PUSH
54600: DOUBLE
54601: LD_INT 1
54603: DEC
54604: ST_TO_ADDR
54605: LD_VAR 0 12
54609: PUSH
54610: FOR_TO
54611: IFFALSE 55128
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
54613: LD_ADDR_VAR 0 11
54617: PUSH
54618: LD_VAR 0 12
54622: PUSH
54623: LD_VAR 0 7
54627: ARRAY
54628: PUSH
54629: LD_INT 1
54631: ARRAY
54632: PPUSH
54633: LD_VAR 0 12
54637: PUSH
54638: LD_VAR 0 7
54642: ARRAY
54643: PUSH
54644: LD_INT 2
54646: ARRAY
54647: PPUSH
54648: CALL_OW 428
54652: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
54653: LD_VAR 0 12
54657: PUSH
54658: LD_VAR 0 7
54662: ARRAY
54663: PUSH
54664: LD_INT 1
54666: ARRAY
54667: PPUSH
54668: LD_VAR 0 12
54672: PUSH
54673: LD_VAR 0 7
54677: ARRAY
54678: PUSH
54679: LD_INT 2
54681: ARRAY
54682: PPUSH
54683: CALL_OW 351
54687: PUSH
54688: LD_VAR 0 12
54692: PUSH
54693: LD_VAR 0 7
54697: ARRAY
54698: PUSH
54699: LD_INT 1
54701: ARRAY
54702: PPUSH
54703: LD_VAR 0 12
54707: PUSH
54708: LD_VAR 0 7
54712: ARRAY
54713: PUSH
54714: LD_INT 2
54716: ARRAY
54717: PPUSH
54718: CALL_OW 488
54722: NOT
54723: OR
54724: PUSH
54725: LD_VAR 0 11
54729: PPUSH
54730: CALL_OW 247
54734: PUSH
54735: LD_INT 3
54737: EQUAL
54738: OR
54739: IFFALSE 54745
// exit ;
54741: POP
54742: POP
54743: GO 55130
// if not tmp then
54745: LD_VAR 0 11
54749: NOT
54750: IFFALSE 54754
// continue ;
54752: GO 54610
// result := true ;
54754: LD_ADDR_VAR 0 6
54758: PUSH
54759: LD_INT 1
54761: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
54762: LD_ADDR_VAR 0 15
54766: PUSH
54767: LD_INT 22
54769: PUSH
54770: LD_VAR 0 11
54774: PPUSH
54775: CALL_OW 255
54779: PUSH
54780: EMPTY
54781: LIST
54782: LIST
54783: PUSH
54784: LD_INT 2
54786: PUSH
54787: LD_INT 30
54789: PUSH
54790: LD_INT 0
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PUSH
54797: LD_INT 30
54799: PUSH
54800: LD_INT 1
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: LIST
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: PPUSH
54816: CALL_OW 69
54820: ST_TO_ADDR
// if dep then
54821: LD_VAR 0 15
54825: IFFALSE 54961
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
54827: LD_ADDR_VAR 0 14
54831: PUSH
54832: LD_VAR 0 15
54836: PUSH
54837: LD_INT 1
54839: ARRAY
54840: PPUSH
54841: CALL_OW 250
54845: PPUSH
54846: LD_VAR 0 15
54850: PUSH
54851: LD_INT 1
54853: ARRAY
54854: PPUSH
54855: CALL_OW 254
54859: PPUSH
54860: LD_INT 5
54862: PPUSH
54863: CALL_OW 272
54867: PUSH
54868: LD_VAR 0 15
54872: PUSH
54873: LD_INT 1
54875: ARRAY
54876: PPUSH
54877: CALL_OW 251
54881: PPUSH
54882: LD_VAR 0 15
54886: PUSH
54887: LD_INT 1
54889: ARRAY
54890: PPUSH
54891: CALL_OW 254
54895: PPUSH
54896: LD_INT 5
54898: PPUSH
54899: CALL_OW 273
54903: PUSH
54904: EMPTY
54905: LIST
54906: LIST
54907: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
54908: LD_VAR 0 14
54912: PUSH
54913: LD_INT 1
54915: ARRAY
54916: PPUSH
54917: LD_VAR 0 14
54921: PUSH
54922: LD_INT 2
54924: ARRAY
54925: PPUSH
54926: CALL_OW 488
54930: IFFALSE 54961
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
54932: LD_VAR 0 11
54936: PPUSH
54937: LD_VAR 0 14
54941: PUSH
54942: LD_INT 1
54944: ARRAY
54945: PPUSH
54946: LD_VAR 0 14
54950: PUSH
54951: LD_INT 2
54953: ARRAY
54954: PPUSH
54955: CALL_OW 111
// continue ;
54959: GO 54610
// end ; end ; r := GetDir ( tmp ) ;
54961: LD_ADDR_VAR 0 13
54965: PUSH
54966: LD_VAR 0 11
54970: PPUSH
54971: CALL_OW 254
54975: ST_TO_ADDR
// if r = 5 then
54976: LD_VAR 0 13
54980: PUSH
54981: LD_INT 5
54983: EQUAL
54984: IFFALSE 54994
// r := 0 ;
54986: LD_ADDR_VAR 0 13
54990: PUSH
54991: LD_INT 0
54993: ST_TO_ADDR
// for j = r to 5 do
54994: LD_ADDR_VAR 0 8
54998: PUSH
54999: DOUBLE
55000: LD_VAR 0 13
55004: DEC
55005: ST_TO_ADDR
55006: LD_INT 5
55008: PUSH
55009: FOR_TO
55010: IFFALSE 55124
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
55012: LD_ADDR_VAR 0 9
55016: PUSH
55017: LD_VAR 0 11
55021: PPUSH
55022: CALL_OW 250
55026: PPUSH
55027: LD_VAR 0 8
55031: PPUSH
55032: LD_INT 2
55034: PPUSH
55035: CALL_OW 272
55039: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
55040: LD_ADDR_VAR 0 10
55044: PUSH
55045: LD_VAR 0 11
55049: PPUSH
55050: CALL_OW 251
55054: PPUSH
55055: LD_VAR 0 8
55059: PPUSH
55060: LD_INT 2
55062: PPUSH
55063: CALL_OW 273
55067: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
55068: LD_VAR 0 9
55072: PPUSH
55073: LD_VAR 0 10
55077: PPUSH
55078: CALL_OW 488
55082: PUSH
55083: LD_VAR 0 9
55087: PPUSH
55088: LD_VAR 0 10
55092: PPUSH
55093: CALL_OW 428
55097: NOT
55098: AND
55099: IFFALSE 55122
// begin ComMoveXY ( tmp , _x , _y ) ;
55101: LD_VAR 0 11
55105: PPUSH
55106: LD_VAR 0 9
55110: PPUSH
55111: LD_VAR 0 10
55115: PPUSH
55116: CALL_OW 111
// break ;
55120: GO 55124
// end ; end ;
55122: GO 55009
55124: POP
55125: POP
// end ;
55126: GO 54610
55128: POP
55129: POP
// end ;
55130: LD_VAR 0 6
55134: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
55135: LD_INT 0
55137: PPUSH
55138: PPUSH
55139: PPUSH
55140: PPUSH
55141: PPUSH
55142: PPUSH
55143: PPUSH
55144: PPUSH
55145: PPUSH
55146: PPUSH
// result := false ;
55147: LD_ADDR_VAR 0 6
55151: PUSH
55152: LD_INT 0
55154: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
55155: LD_VAR 0 1
55159: NOT
55160: PUSH
55161: LD_VAR 0 1
55165: PPUSH
55166: CALL_OW 266
55170: PUSH
55171: LD_INT 0
55173: PUSH
55174: LD_INT 1
55176: PUSH
55177: EMPTY
55178: LIST
55179: LIST
55180: IN
55181: NOT
55182: OR
55183: PUSH
55184: LD_VAR 0 2
55188: NOT
55189: OR
55190: PUSH
55191: LD_VAR 0 5
55195: PUSH
55196: LD_INT 0
55198: PUSH
55199: LD_INT 1
55201: PUSH
55202: LD_INT 2
55204: PUSH
55205: LD_INT 3
55207: PUSH
55208: LD_INT 4
55210: PUSH
55211: LD_INT 5
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: LIST
55218: LIST
55219: LIST
55220: LIST
55221: IN
55222: NOT
55223: OR
55224: PUSH
55225: LD_VAR 0 3
55229: PPUSH
55230: LD_VAR 0 4
55234: PPUSH
55235: CALL_OW 488
55239: NOT
55240: OR
55241: IFFALSE 55245
// exit ;
55243: GO 55962
// pom := GetBase ( bdepot ) ;
55245: LD_ADDR_VAR 0 10
55249: PUSH
55250: LD_VAR 0 1
55254: PPUSH
55255: CALL_OW 274
55259: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
55260: LD_ADDR_VAR 0 11
55264: PUSH
55265: LD_VAR 0 2
55269: PPUSH
55270: LD_VAR 0 1
55274: PPUSH
55275: CALL_OW 248
55279: PPUSH
55280: CALL_OW 450
55284: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
55285: LD_VAR 0 10
55289: PPUSH
55290: LD_INT 1
55292: PPUSH
55293: CALL_OW 275
55297: PUSH
55298: LD_VAR 0 11
55302: PUSH
55303: LD_INT 1
55305: ARRAY
55306: GREATEREQUAL
55307: PUSH
55308: LD_VAR 0 10
55312: PPUSH
55313: LD_INT 2
55315: PPUSH
55316: CALL_OW 275
55320: PUSH
55321: LD_VAR 0 11
55325: PUSH
55326: LD_INT 2
55328: ARRAY
55329: GREATEREQUAL
55330: AND
55331: PUSH
55332: LD_VAR 0 10
55336: PPUSH
55337: LD_INT 3
55339: PPUSH
55340: CALL_OW 275
55344: PUSH
55345: LD_VAR 0 11
55349: PUSH
55350: LD_INT 3
55352: ARRAY
55353: GREATEREQUAL
55354: AND
55355: NOT
55356: IFFALSE 55360
// exit ;
55358: GO 55962
// if GetBType ( bdepot ) = b_depot then
55360: LD_VAR 0 1
55364: PPUSH
55365: CALL_OW 266
55369: PUSH
55370: LD_INT 0
55372: EQUAL
55373: IFFALSE 55385
// dist := 28 else
55375: LD_ADDR_VAR 0 14
55379: PUSH
55380: LD_INT 28
55382: ST_TO_ADDR
55383: GO 55393
// dist := 36 ;
55385: LD_ADDR_VAR 0 14
55389: PUSH
55390: LD_INT 36
55392: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
55393: LD_VAR 0 1
55397: PPUSH
55398: LD_VAR 0 3
55402: PPUSH
55403: LD_VAR 0 4
55407: PPUSH
55408: CALL_OW 297
55412: PUSH
55413: LD_VAR 0 14
55417: GREATER
55418: IFFALSE 55422
// exit ;
55420: GO 55962
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
55422: LD_ADDR_VAR 0 12
55426: PUSH
55427: LD_VAR 0 2
55431: PPUSH
55432: LD_VAR 0 3
55436: PPUSH
55437: LD_VAR 0 4
55441: PPUSH
55442: LD_VAR 0 5
55446: PPUSH
55447: LD_VAR 0 1
55451: PPUSH
55452: CALL_OW 248
55456: PPUSH
55457: LD_INT 0
55459: PPUSH
55460: CALL 55967 0 6
55464: ST_TO_ADDR
// if not hexes then
55465: LD_VAR 0 12
55469: NOT
55470: IFFALSE 55474
// exit ;
55472: GO 55962
// hex := GetHexInfo ( x , y ) ;
55474: LD_ADDR_VAR 0 15
55478: PUSH
55479: LD_VAR 0 3
55483: PPUSH
55484: LD_VAR 0 4
55488: PPUSH
55489: CALL_OW 546
55493: ST_TO_ADDR
// if hex [ 1 ] then
55494: LD_VAR 0 15
55498: PUSH
55499: LD_INT 1
55501: ARRAY
55502: IFFALSE 55506
// exit ;
55504: GO 55962
// height := hex [ 2 ] ;
55506: LD_ADDR_VAR 0 13
55510: PUSH
55511: LD_VAR 0 15
55515: PUSH
55516: LD_INT 2
55518: ARRAY
55519: ST_TO_ADDR
// for i = 1 to hexes do
55520: LD_ADDR_VAR 0 7
55524: PUSH
55525: DOUBLE
55526: LD_INT 1
55528: DEC
55529: ST_TO_ADDR
55530: LD_VAR 0 12
55534: PUSH
55535: FOR_TO
55536: IFFALSE 55866
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
55538: LD_VAR 0 12
55542: PUSH
55543: LD_VAR 0 7
55547: ARRAY
55548: PUSH
55549: LD_INT 1
55551: ARRAY
55552: PPUSH
55553: LD_VAR 0 12
55557: PUSH
55558: LD_VAR 0 7
55562: ARRAY
55563: PUSH
55564: LD_INT 2
55566: ARRAY
55567: PPUSH
55568: CALL_OW 488
55572: NOT
55573: PUSH
55574: LD_VAR 0 12
55578: PUSH
55579: LD_VAR 0 7
55583: ARRAY
55584: PUSH
55585: LD_INT 1
55587: ARRAY
55588: PPUSH
55589: LD_VAR 0 12
55593: PUSH
55594: LD_VAR 0 7
55598: ARRAY
55599: PUSH
55600: LD_INT 2
55602: ARRAY
55603: PPUSH
55604: CALL_OW 428
55608: PUSH
55609: LD_INT 0
55611: GREATER
55612: OR
55613: PUSH
55614: LD_VAR 0 12
55618: PUSH
55619: LD_VAR 0 7
55623: ARRAY
55624: PUSH
55625: LD_INT 1
55627: ARRAY
55628: PPUSH
55629: LD_VAR 0 12
55633: PUSH
55634: LD_VAR 0 7
55638: ARRAY
55639: PUSH
55640: LD_INT 2
55642: ARRAY
55643: PPUSH
55644: CALL_OW 351
55648: OR
55649: IFFALSE 55655
// exit ;
55651: POP
55652: POP
55653: GO 55962
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
55655: LD_ADDR_VAR 0 8
55659: PUSH
55660: LD_VAR 0 12
55664: PUSH
55665: LD_VAR 0 7
55669: ARRAY
55670: PUSH
55671: LD_INT 1
55673: ARRAY
55674: PPUSH
55675: LD_VAR 0 12
55679: PUSH
55680: LD_VAR 0 7
55684: ARRAY
55685: PUSH
55686: LD_INT 2
55688: ARRAY
55689: PPUSH
55690: CALL_OW 546
55694: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
55695: LD_VAR 0 8
55699: PUSH
55700: LD_INT 1
55702: ARRAY
55703: PUSH
55704: LD_VAR 0 8
55708: PUSH
55709: LD_INT 2
55711: ARRAY
55712: PUSH
55713: LD_VAR 0 13
55717: PUSH
55718: LD_INT 2
55720: PLUS
55721: GREATER
55722: OR
55723: PUSH
55724: LD_VAR 0 8
55728: PUSH
55729: LD_INT 2
55731: ARRAY
55732: PUSH
55733: LD_VAR 0 13
55737: PUSH
55738: LD_INT 2
55740: MINUS
55741: LESS
55742: OR
55743: PUSH
55744: LD_VAR 0 8
55748: PUSH
55749: LD_INT 3
55751: ARRAY
55752: PUSH
55753: LD_INT 0
55755: PUSH
55756: LD_INT 8
55758: PUSH
55759: LD_INT 9
55761: PUSH
55762: LD_INT 10
55764: PUSH
55765: LD_INT 11
55767: PUSH
55768: LD_INT 12
55770: PUSH
55771: LD_INT 13
55773: PUSH
55774: LD_INT 16
55776: PUSH
55777: LD_INT 17
55779: PUSH
55780: LD_INT 18
55782: PUSH
55783: LD_INT 19
55785: PUSH
55786: LD_INT 20
55788: PUSH
55789: LD_INT 21
55791: PUSH
55792: EMPTY
55793: LIST
55794: LIST
55795: LIST
55796: LIST
55797: LIST
55798: LIST
55799: LIST
55800: LIST
55801: LIST
55802: LIST
55803: LIST
55804: LIST
55805: LIST
55806: IN
55807: NOT
55808: OR
55809: PUSH
55810: LD_VAR 0 8
55814: PUSH
55815: LD_INT 5
55817: ARRAY
55818: NOT
55819: OR
55820: PUSH
55821: LD_VAR 0 8
55825: PUSH
55826: LD_INT 6
55828: ARRAY
55829: PUSH
55830: LD_INT 1
55832: PUSH
55833: LD_INT 2
55835: PUSH
55836: LD_INT 7
55838: PUSH
55839: LD_INT 9
55841: PUSH
55842: LD_INT 10
55844: PUSH
55845: LD_INT 11
55847: PUSH
55848: EMPTY
55849: LIST
55850: LIST
55851: LIST
55852: LIST
55853: LIST
55854: LIST
55855: IN
55856: NOT
55857: OR
55858: IFFALSE 55864
// exit ;
55860: POP
55861: POP
55862: GO 55962
// end ;
55864: GO 55535
55866: POP
55867: POP
// side := GetSide ( bdepot ) ;
55868: LD_ADDR_VAR 0 9
55872: PUSH
55873: LD_VAR 0 1
55877: PPUSH
55878: CALL_OW 255
55882: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
55883: LD_VAR 0 9
55887: PPUSH
55888: LD_VAR 0 3
55892: PPUSH
55893: LD_VAR 0 4
55897: PPUSH
55898: LD_INT 20
55900: PPUSH
55901: CALL 48634 0 4
55905: PUSH
55906: LD_INT 4
55908: ARRAY
55909: IFFALSE 55913
// exit ;
55911: GO 55962
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
55913: LD_VAR 0 2
55917: PUSH
55918: LD_INT 29
55920: PUSH
55921: LD_INT 30
55923: PUSH
55924: EMPTY
55925: LIST
55926: LIST
55927: IN
55928: PUSH
55929: LD_VAR 0 3
55933: PPUSH
55934: LD_VAR 0 4
55938: PPUSH
55939: LD_VAR 0 9
55943: PPUSH
55944: CALL_OW 440
55948: NOT
55949: AND
55950: IFFALSE 55954
// exit ;
55952: GO 55962
// result := true ;
55954: LD_ADDR_VAR 0 6
55958: PUSH
55959: LD_INT 1
55961: ST_TO_ADDR
// end ;
55962: LD_VAR 0 6
55966: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
55967: LD_INT 0
55969: PPUSH
55970: PPUSH
55971: PPUSH
55972: PPUSH
55973: PPUSH
55974: PPUSH
55975: PPUSH
55976: PPUSH
55977: PPUSH
55978: PPUSH
55979: PPUSH
55980: PPUSH
55981: PPUSH
55982: PPUSH
55983: PPUSH
55984: PPUSH
55985: PPUSH
55986: PPUSH
55987: PPUSH
55988: PPUSH
55989: PPUSH
55990: PPUSH
55991: PPUSH
55992: PPUSH
55993: PPUSH
55994: PPUSH
55995: PPUSH
55996: PPUSH
55997: PPUSH
55998: PPUSH
55999: PPUSH
56000: PPUSH
56001: PPUSH
56002: PPUSH
56003: PPUSH
56004: PPUSH
56005: PPUSH
56006: PPUSH
56007: PPUSH
56008: PPUSH
56009: PPUSH
56010: PPUSH
56011: PPUSH
56012: PPUSH
56013: PPUSH
56014: PPUSH
56015: PPUSH
56016: PPUSH
56017: PPUSH
56018: PPUSH
56019: PPUSH
56020: PPUSH
56021: PPUSH
56022: PPUSH
56023: PPUSH
56024: PPUSH
56025: PPUSH
56026: PPUSH
// result = [ ] ;
56027: LD_ADDR_VAR 0 7
56031: PUSH
56032: EMPTY
56033: ST_TO_ADDR
// temp_list = [ ] ;
56034: LD_ADDR_VAR 0 9
56038: PUSH
56039: EMPTY
56040: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
56041: LD_VAR 0 4
56045: PUSH
56046: LD_INT 0
56048: PUSH
56049: LD_INT 1
56051: PUSH
56052: LD_INT 2
56054: PUSH
56055: LD_INT 3
56057: PUSH
56058: LD_INT 4
56060: PUSH
56061: LD_INT 5
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: IN
56072: NOT
56073: PUSH
56074: LD_VAR 0 1
56078: PUSH
56079: LD_INT 0
56081: PUSH
56082: LD_INT 1
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: IN
56089: PUSH
56090: LD_VAR 0 5
56094: PUSH
56095: LD_INT 1
56097: PUSH
56098: LD_INT 2
56100: PUSH
56101: LD_INT 3
56103: PUSH
56104: EMPTY
56105: LIST
56106: LIST
56107: LIST
56108: IN
56109: NOT
56110: AND
56111: OR
56112: IFFALSE 56116
// exit ;
56114: GO 74501
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
56116: LD_VAR 0 1
56120: PUSH
56121: LD_INT 6
56123: PUSH
56124: LD_INT 7
56126: PUSH
56127: LD_INT 8
56129: PUSH
56130: LD_INT 13
56132: PUSH
56133: LD_INT 12
56135: PUSH
56136: LD_INT 15
56138: PUSH
56139: LD_INT 11
56141: PUSH
56142: LD_INT 14
56144: PUSH
56145: LD_INT 10
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: LIST
56152: LIST
56153: LIST
56154: LIST
56155: LIST
56156: LIST
56157: LIST
56158: IN
56159: IFFALSE 56169
// btype = b_lab ;
56161: LD_ADDR_VAR 0 1
56165: PUSH
56166: LD_INT 6
56168: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
56169: LD_VAR 0 6
56173: PUSH
56174: LD_INT 0
56176: PUSH
56177: LD_INT 1
56179: PUSH
56180: LD_INT 2
56182: PUSH
56183: EMPTY
56184: LIST
56185: LIST
56186: LIST
56187: IN
56188: NOT
56189: PUSH
56190: LD_VAR 0 1
56194: PUSH
56195: LD_INT 0
56197: PUSH
56198: LD_INT 1
56200: PUSH
56201: LD_INT 2
56203: PUSH
56204: LD_INT 3
56206: PUSH
56207: LD_INT 6
56209: PUSH
56210: LD_INT 36
56212: PUSH
56213: LD_INT 4
56215: PUSH
56216: LD_INT 5
56218: PUSH
56219: LD_INT 31
56221: PUSH
56222: LD_INT 32
56224: PUSH
56225: LD_INT 33
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: LIST
56234: LIST
56235: LIST
56236: LIST
56237: LIST
56238: LIST
56239: LIST
56240: IN
56241: NOT
56242: PUSH
56243: LD_VAR 0 6
56247: PUSH
56248: LD_INT 1
56250: EQUAL
56251: AND
56252: OR
56253: PUSH
56254: LD_VAR 0 1
56258: PUSH
56259: LD_INT 2
56261: PUSH
56262: LD_INT 3
56264: PUSH
56265: EMPTY
56266: LIST
56267: LIST
56268: IN
56269: NOT
56270: PUSH
56271: LD_VAR 0 6
56275: PUSH
56276: LD_INT 2
56278: EQUAL
56279: AND
56280: OR
56281: IFFALSE 56291
// mode = 0 ;
56283: LD_ADDR_VAR 0 6
56287: PUSH
56288: LD_INT 0
56290: ST_TO_ADDR
// case mode of 0 :
56291: LD_VAR 0 6
56295: PUSH
56296: LD_INT 0
56298: DOUBLE
56299: EQUAL
56300: IFTRUE 56304
56302: GO 67757
56304: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
56305: LD_ADDR_VAR 0 11
56309: PUSH
56310: LD_INT 0
56312: PUSH
56313: LD_INT 0
56315: PUSH
56316: EMPTY
56317: LIST
56318: LIST
56319: PUSH
56320: LD_INT 0
56322: PUSH
56323: LD_INT 1
56325: NEG
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: PUSH
56331: LD_INT 1
56333: PUSH
56334: LD_INT 0
56336: PUSH
56337: EMPTY
56338: LIST
56339: LIST
56340: PUSH
56341: LD_INT 1
56343: PUSH
56344: LD_INT 1
56346: PUSH
56347: EMPTY
56348: LIST
56349: LIST
56350: PUSH
56351: LD_INT 0
56353: PUSH
56354: LD_INT 1
56356: PUSH
56357: EMPTY
56358: LIST
56359: LIST
56360: PUSH
56361: LD_INT 1
56363: NEG
56364: PUSH
56365: LD_INT 0
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: PUSH
56372: LD_INT 1
56374: NEG
56375: PUSH
56376: LD_INT 1
56378: NEG
56379: PUSH
56380: EMPTY
56381: LIST
56382: LIST
56383: PUSH
56384: LD_INT 1
56386: NEG
56387: PUSH
56388: LD_INT 2
56390: NEG
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: PUSH
56396: LD_INT 0
56398: PUSH
56399: LD_INT 2
56401: NEG
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: PUSH
56407: LD_INT 1
56409: PUSH
56410: LD_INT 1
56412: NEG
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: PUSH
56418: LD_INT 1
56420: PUSH
56421: LD_INT 2
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: PUSH
56428: LD_INT 0
56430: PUSH
56431: LD_INT 2
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: PUSH
56438: LD_INT 1
56440: NEG
56441: PUSH
56442: LD_INT 1
56444: PUSH
56445: EMPTY
56446: LIST
56447: LIST
56448: PUSH
56449: LD_INT 1
56451: PUSH
56452: LD_INT 3
56454: PUSH
56455: EMPTY
56456: LIST
56457: LIST
56458: PUSH
56459: LD_INT 0
56461: PUSH
56462: LD_INT 3
56464: PUSH
56465: EMPTY
56466: LIST
56467: LIST
56468: PUSH
56469: LD_INT 1
56471: NEG
56472: PUSH
56473: LD_INT 2
56475: PUSH
56476: EMPTY
56477: LIST
56478: LIST
56479: PUSH
56480: EMPTY
56481: LIST
56482: LIST
56483: LIST
56484: LIST
56485: LIST
56486: LIST
56487: LIST
56488: LIST
56489: LIST
56490: LIST
56491: LIST
56492: LIST
56493: LIST
56494: LIST
56495: LIST
56496: LIST
56497: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
56498: LD_ADDR_VAR 0 12
56502: PUSH
56503: LD_INT 0
56505: PUSH
56506: LD_INT 0
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: PUSH
56513: LD_INT 0
56515: PUSH
56516: LD_INT 1
56518: NEG
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PUSH
56524: LD_INT 1
56526: PUSH
56527: LD_INT 0
56529: PUSH
56530: EMPTY
56531: LIST
56532: LIST
56533: PUSH
56534: LD_INT 1
56536: PUSH
56537: LD_INT 1
56539: PUSH
56540: EMPTY
56541: LIST
56542: LIST
56543: PUSH
56544: LD_INT 0
56546: PUSH
56547: LD_INT 1
56549: PUSH
56550: EMPTY
56551: LIST
56552: LIST
56553: PUSH
56554: LD_INT 1
56556: NEG
56557: PUSH
56558: LD_INT 0
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: PUSH
56565: LD_INT 1
56567: NEG
56568: PUSH
56569: LD_INT 1
56571: NEG
56572: PUSH
56573: EMPTY
56574: LIST
56575: LIST
56576: PUSH
56577: LD_INT 1
56579: PUSH
56580: LD_INT 1
56582: NEG
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: PUSH
56588: LD_INT 2
56590: PUSH
56591: LD_INT 0
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PUSH
56598: LD_INT 2
56600: PUSH
56601: LD_INT 1
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: PUSH
56608: LD_INT 1
56610: NEG
56611: PUSH
56612: LD_INT 1
56614: PUSH
56615: EMPTY
56616: LIST
56617: LIST
56618: PUSH
56619: LD_INT 2
56621: NEG
56622: PUSH
56623: LD_INT 0
56625: PUSH
56626: EMPTY
56627: LIST
56628: LIST
56629: PUSH
56630: LD_INT 2
56632: NEG
56633: PUSH
56634: LD_INT 1
56636: NEG
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: PUSH
56642: LD_INT 2
56644: NEG
56645: PUSH
56646: LD_INT 1
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: PUSH
56653: LD_INT 3
56655: NEG
56656: PUSH
56657: LD_INT 0
56659: PUSH
56660: EMPTY
56661: LIST
56662: LIST
56663: PUSH
56664: LD_INT 3
56666: NEG
56667: PUSH
56668: LD_INT 1
56670: NEG
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: PUSH
56676: EMPTY
56677: LIST
56678: LIST
56679: LIST
56680: LIST
56681: LIST
56682: LIST
56683: LIST
56684: LIST
56685: LIST
56686: LIST
56687: LIST
56688: LIST
56689: LIST
56690: LIST
56691: LIST
56692: LIST
56693: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
56694: LD_ADDR_VAR 0 13
56698: PUSH
56699: LD_INT 0
56701: PUSH
56702: LD_INT 0
56704: PUSH
56705: EMPTY
56706: LIST
56707: LIST
56708: PUSH
56709: LD_INT 0
56711: PUSH
56712: LD_INT 1
56714: NEG
56715: PUSH
56716: EMPTY
56717: LIST
56718: LIST
56719: PUSH
56720: LD_INT 1
56722: PUSH
56723: LD_INT 0
56725: PUSH
56726: EMPTY
56727: LIST
56728: LIST
56729: PUSH
56730: LD_INT 1
56732: PUSH
56733: LD_INT 1
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: PUSH
56740: LD_INT 0
56742: PUSH
56743: LD_INT 1
56745: PUSH
56746: EMPTY
56747: LIST
56748: LIST
56749: PUSH
56750: LD_INT 1
56752: NEG
56753: PUSH
56754: LD_INT 0
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: PUSH
56761: LD_INT 1
56763: NEG
56764: PUSH
56765: LD_INT 1
56767: NEG
56768: PUSH
56769: EMPTY
56770: LIST
56771: LIST
56772: PUSH
56773: LD_INT 1
56775: NEG
56776: PUSH
56777: LD_INT 2
56779: NEG
56780: PUSH
56781: EMPTY
56782: LIST
56783: LIST
56784: PUSH
56785: LD_INT 2
56787: PUSH
56788: LD_INT 1
56790: PUSH
56791: EMPTY
56792: LIST
56793: LIST
56794: PUSH
56795: LD_INT 2
56797: PUSH
56798: LD_INT 2
56800: PUSH
56801: EMPTY
56802: LIST
56803: LIST
56804: PUSH
56805: LD_INT 1
56807: PUSH
56808: LD_INT 2
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: LD_INT 2
56817: NEG
56818: PUSH
56819: LD_INT 1
56821: NEG
56822: PUSH
56823: EMPTY
56824: LIST
56825: LIST
56826: PUSH
56827: LD_INT 2
56829: NEG
56830: PUSH
56831: LD_INT 2
56833: NEG
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: PUSH
56839: LD_INT 2
56841: NEG
56842: PUSH
56843: LD_INT 3
56845: NEG
56846: PUSH
56847: EMPTY
56848: LIST
56849: LIST
56850: PUSH
56851: LD_INT 3
56853: NEG
56854: PUSH
56855: LD_INT 2
56857: NEG
56858: PUSH
56859: EMPTY
56860: LIST
56861: LIST
56862: PUSH
56863: LD_INT 3
56865: NEG
56866: PUSH
56867: LD_INT 3
56869: NEG
56870: PUSH
56871: EMPTY
56872: LIST
56873: LIST
56874: PUSH
56875: EMPTY
56876: LIST
56877: LIST
56878: LIST
56879: LIST
56880: LIST
56881: LIST
56882: LIST
56883: LIST
56884: LIST
56885: LIST
56886: LIST
56887: LIST
56888: LIST
56889: LIST
56890: LIST
56891: LIST
56892: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
56893: LD_ADDR_VAR 0 14
56897: PUSH
56898: LD_INT 0
56900: PUSH
56901: LD_INT 0
56903: PUSH
56904: EMPTY
56905: LIST
56906: LIST
56907: PUSH
56908: LD_INT 0
56910: PUSH
56911: LD_INT 1
56913: NEG
56914: PUSH
56915: EMPTY
56916: LIST
56917: LIST
56918: PUSH
56919: LD_INT 1
56921: PUSH
56922: LD_INT 0
56924: PUSH
56925: EMPTY
56926: LIST
56927: LIST
56928: PUSH
56929: LD_INT 1
56931: PUSH
56932: LD_INT 1
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PUSH
56939: LD_INT 0
56941: PUSH
56942: LD_INT 1
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: PUSH
56949: LD_INT 1
56951: NEG
56952: PUSH
56953: LD_INT 0
56955: PUSH
56956: EMPTY
56957: LIST
56958: LIST
56959: PUSH
56960: LD_INT 1
56962: NEG
56963: PUSH
56964: LD_INT 1
56966: NEG
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: PUSH
56972: LD_INT 1
56974: NEG
56975: PUSH
56976: LD_INT 2
56978: NEG
56979: PUSH
56980: EMPTY
56981: LIST
56982: LIST
56983: PUSH
56984: LD_INT 0
56986: PUSH
56987: LD_INT 2
56989: NEG
56990: PUSH
56991: EMPTY
56992: LIST
56993: LIST
56994: PUSH
56995: LD_INT 1
56997: PUSH
56998: LD_INT 1
57000: NEG
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: PUSH
57006: LD_INT 1
57008: PUSH
57009: LD_INT 2
57011: PUSH
57012: EMPTY
57013: LIST
57014: LIST
57015: PUSH
57016: LD_INT 0
57018: PUSH
57019: LD_INT 2
57021: PUSH
57022: EMPTY
57023: LIST
57024: LIST
57025: PUSH
57026: LD_INT 1
57028: NEG
57029: PUSH
57030: LD_INT 1
57032: PUSH
57033: EMPTY
57034: LIST
57035: LIST
57036: PUSH
57037: LD_INT 1
57039: NEG
57040: PUSH
57041: LD_INT 3
57043: NEG
57044: PUSH
57045: EMPTY
57046: LIST
57047: LIST
57048: PUSH
57049: LD_INT 0
57051: PUSH
57052: LD_INT 3
57054: NEG
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: PUSH
57060: LD_INT 1
57062: PUSH
57063: LD_INT 2
57065: NEG
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: PUSH
57071: EMPTY
57072: LIST
57073: LIST
57074: LIST
57075: LIST
57076: LIST
57077: LIST
57078: LIST
57079: LIST
57080: LIST
57081: LIST
57082: LIST
57083: LIST
57084: LIST
57085: LIST
57086: LIST
57087: LIST
57088: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
57089: LD_ADDR_VAR 0 15
57093: PUSH
57094: LD_INT 0
57096: PUSH
57097: LD_INT 0
57099: PUSH
57100: EMPTY
57101: LIST
57102: LIST
57103: PUSH
57104: LD_INT 0
57106: PUSH
57107: LD_INT 1
57109: NEG
57110: PUSH
57111: EMPTY
57112: LIST
57113: LIST
57114: PUSH
57115: LD_INT 1
57117: PUSH
57118: LD_INT 0
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: PUSH
57125: LD_INT 1
57127: PUSH
57128: LD_INT 1
57130: PUSH
57131: EMPTY
57132: LIST
57133: LIST
57134: PUSH
57135: LD_INT 0
57137: PUSH
57138: LD_INT 1
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: PUSH
57145: LD_INT 1
57147: NEG
57148: PUSH
57149: LD_INT 0
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: PUSH
57156: LD_INT 1
57158: NEG
57159: PUSH
57160: LD_INT 1
57162: NEG
57163: PUSH
57164: EMPTY
57165: LIST
57166: LIST
57167: PUSH
57168: LD_INT 1
57170: PUSH
57171: LD_INT 1
57173: NEG
57174: PUSH
57175: EMPTY
57176: LIST
57177: LIST
57178: PUSH
57179: LD_INT 2
57181: PUSH
57182: LD_INT 0
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: PUSH
57189: LD_INT 2
57191: PUSH
57192: LD_INT 1
57194: PUSH
57195: EMPTY
57196: LIST
57197: LIST
57198: PUSH
57199: LD_INT 1
57201: NEG
57202: PUSH
57203: LD_INT 1
57205: PUSH
57206: EMPTY
57207: LIST
57208: LIST
57209: PUSH
57210: LD_INT 2
57212: NEG
57213: PUSH
57214: LD_INT 0
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: PUSH
57221: LD_INT 2
57223: NEG
57224: PUSH
57225: LD_INT 1
57227: NEG
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: LD_INT 2
57235: PUSH
57236: LD_INT 1
57238: NEG
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PUSH
57244: LD_INT 3
57246: PUSH
57247: LD_INT 0
57249: PUSH
57250: EMPTY
57251: LIST
57252: LIST
57253: PUSH
57254: LD_INT 3
57256: PUSH
57257: LD_INT 1
57259: PUSH
57260: EMPTY
57261: LIST
57262: LIST
57263: PUSH
57264: EMPTY
57265: LIST
57266: LIST
57267: LIST
57268: LIST
57269: LIST
57270: LIST
57271: LIST
57272: LIST
57273: LIST
57274: LIST
57275: LIST
57276: LIST
57277: LIST
57278: LIST
57279: LIST
57280: LIST
57281: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
57282: LD_ADDR_VAR 0 16
57286: PUSH
57287: LD_INT 0
57289: PUSH
57290: LD_INT 0
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: PUSH
57297: LD_INT 0
57299: PUSH
57300: LD_INT 1
57302: NEG
57303: PUSH
57304: EMPTY
57305: LIST
57306: LIST
57307: PUSH
57308: LD_INT 1
57310: PUSH
57311: LD_INT 0
57313: PUSH
57314: EMPTY
57315: LIST
57316: LIST
57317: PUSH
57318: LD_INT 1
57320: PUSH
57321: LD_INT 1
57323: PUSH
57324: EMPTY
57325: LIST
57326: LIST
57327: PUSH
57328: LD_INT 0
57330: PUSH
57331: LD_INT 1
57333: PUSH
57334: EMPTY
57335: LIST
57336: LIST
57337: PUSH
57338: LD_INT 1
57340: NEG
57341: PUSH
57342: LD_INT 0
57344: PUSH
57345: EMPTY
57346: LIST
57347: LIST
57348: PUSH
57349: LD_INT 1
57351: NEG
57352: PUSH
57353: LD_INT 1
57355: NEG
57356: PUSH
57357: EMPTY
57358: LIST
57359: LIST
57360: PUSH
57361: LD_INT 1
57363: NEG
57364: PUSH
57365: LD_INT 2
57367: NEG
57368: PUSH
57369: EMPTY
57370: LIST
57371: LIST
57372: PUSH
57373: LD_INT 2
57375: PUSH
57376: LD_INT 1
57378: PUSH
57379: EMPTY
57380: LIST
57381: LIST
57382: PUSH
57383: LD_INT 2
57385: PUSH
57386: LD_INT 2
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PUSH
57393: LD_INT 1
57395: PUSH
57396: LD_INT 2
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: PUSH
57403: LD_INT 2
57405: NEG
57406: PUSH
57407: LD_INT 1
57409: NEG
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: PUSH
57415: LD_INT 2
57417: NEG
57418: PUSH
57419: LD_INT 2
57421: NEG
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: PUSH
57427: LD_INT 3
57429: PUSH
57430: LD_INT 2
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: LD_INT 3
57439: PUSH
57440: LD_INT 3
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PUSH
57447: LD_INT 2
57449: PUSH
57450: LD_INT 3
57452: PUSH
57453: EMPTY
57454: LIST
57455: LIST
57456: PUSH
57457: EMPTY
57458: LIST
57459: LIST
57460: LIST
57461: LIST
57462: LIST
57463: LIST
57464: LIST
57465: LIST
57466: LIST
57467: LIST
57468: LIST
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: LIST
57474: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57475: LD_ADDR_VAR 0 17
57479: PUSH
57480: LD_INT 0
57482: PUSH
57483: LD_INT 0
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: PUSH
57490: LD_INT 0
57492: PUSH
57493: LD_INT 1
57495: NEG
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: PUSH
57501: LD_INT 1
57503: PUSH
57504: LD_INT 0
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: PUSH
57511: LD_INT 1
57513: PUSH
57514: LD_INT 1
57516: PUSH
57517: EMPTY
57518: LIST
57519: LIST
57520: PUSH
57521: LD_INT 0
57523: PUSH
57524: LD_INT 1
57526: PUSH
57527: EMPTY
57528: LIST
57529: LIST
57530: PUSH
57531: LD_INT 1
57533: NEG
57534: PUSH
57535: LD_INT 0
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PUSH
57542: LD_INT 1
57544: NEG
57545: PUSH
57546: LD_INT 1
57548: NEG
57549: PUSH
57550: EMPTY
57551: LIST
57552: LIST
57553: PUSH
57554: LD_INT 1
57556: NEG
57557: PUSH
57558: LD_INT 2
57560: NEG
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: PUSH
57566: LD_INT 0
57568: PUSH
57569: LD_INT 2
57571: NEG
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: PUSH
57577: LD_INT 1
57579: PUSH
57580: LD_INT 1
57582: NEG
57583: PUSH
57584: EMPTY
57585: LIST
57586: LIST
57587: PUSH
57588: LD_INT 2
57590: PUSH
57591: LD_INT 0
57593: PUSH
57594: EMPTY
57595: LIST
57596: LIST
57597: PUSH
57598: LD_INT 2
57600: PUSH
57601: LD_INT 1
57603: PUSH
57604: EMPTY
57605: LIST
57606: LIST
57607: PUSH
57608: LD_INT 2
57610: PUSH
57611: LD_INT 2
57613: PUSH
57614: EMPTY
57615: LIST
57616: LIST
57617: PUSH
57618: LD_INT 1
57620: PUSH
57621: LD_INT 2
57623: PUSH
57624: EMPTY
57625: LIST
57626: LIST
57627: PUSH
57628: LD_INT 0
57630: PUSH
57631: LD_INT 2
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: PUSH
57638: LD_INT 1
57640: NEG
57641: PUSH
57642: LD_INT 1
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: PUSH
57649: LD_INT 2
57651: NEG
57652: PUSH
57653: LD_INT 0
57655: PUSH
57656: EMPTY
57657: LIST
57658: LIST
57659: PUSH
57660: LD_INT 2
57662: NEG
57663: PUSH
57664: LD_INT 1
57666: NEG
57667: PUSH
57668: EMPTY
57669: LIST
57670: LIST
57671: PUSH
57672: LD_INT 2
57674: NEG
57675: PUSH
57676: LD_INT 2
57678: NEG
57679: PUSH
57680: EMPTY
57681: LIST
57682: LIST
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: LIST
57688: LIST
57689: LIST
57690: LIST
57691: LIST
57692: LIST
57693: LIST
57694: LIST
57695: LIST
57696: LIST
57697: LIST
57698: LIST
57699: LIST
57700: LIST
57701: LIST
57702: LIST
57703: LIST
57704: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57705: LD_ADDR_VAR 0 18
57709: PUSH
57710: LD_INT 0
57712: PUSH
57713: LD_INT 0
57715: PUSH
57716: EMPTY
57717: LIST
57718: LIST
57719: PUSH
57720: LD_INT 0
57722: PUSH
57723: LD_INT 1
57725: NEG
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: PUSH
57731: LD_INT 1
57733: PUSH
57734: LD_INT 0
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: LD_INT 1
57743: PUSH
57744: LD_INT 1
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: LD_INT 0
57753: PUSH
57754: LD_INT 1
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: LD_INT 1
57763: NEG
57764: PUSH
57765: LD_INT 0
57767: PUSH
57768: EMPTY
57769: LIST
57770: LIST
57771: PUSH
57772: LD_INT 1
57774: NEG
57775: PUSH
57776: LD_INT 1
57778: NEG
57779: PUSH
57780: EMPTY
57781: LIST
57782: LIST
57783: PUSH
57784: LD_INT 1
57786: NEG
57787: PUSH
57788: LD_INT 2
57790: NEG
57791: PUSH
57792: EMPTY
57793: LIST
57794: LIST
57795: PUSH
57796: LD_INT 0
57798: PUSH
57799: LD_INT 2
57801: NEG
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: PUSH
57807: LD_INT 1
57809: PUSH
57810: LD_INT 1
57812: NEG
57813: PUSH
57814: EMPTY
57815: LIST
57816: LIST
57817: PUSH
57818: LD_INT 2
57820: PUSH
57821: LD_INT 0
57823: PUSH
57824: EMPTY
57825: LIST
57826: LIST
57827: PUSH
57828: LD_INT 2
57830: PUSH
57831: LD_INT 1
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: PUSH
57838: LD_INT 2
57840: PUSH
57841: LD_INT 2
57843: PUSH
57844: EMPTY
57845: LIST
57846: LIST
57847: PUSH
57848: LD_INT 1
57850: PUSH
57851: LD_INT 2
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: LD_INT 0
57860: PUSH
57861: LD_INT 2
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PUSH
57868: LD_INT 1
57870: NEG
57871: PUSH
57872: LD_INT 1
57874: PUSH
57875: EMPTY
57876: LIST
57877: LIST
57878: PUSH
57879: LD_INT 2
57881: NEG
57882: PUSH
57883: LD_INT 0
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: PUSH
57890: LD_INT 2
57892: NEG
57893: PUSH
57894: LD_INT 1
57896: NEG
57897: PUSH
57898: EMPTY
57899: LIST
57900: LIST
57901: PUSH
57902: LD_INT 2
57904: NEG
57905: PUSH
57906: LD_INT 2
57908: NEG
57909: PUSH
57910: EMPTY
57911: LIST
57912: LIST
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: LIST
57918: LIST
57919: LIST
57920: LIST
57921: LIST
57922: LIST
57923: LIST
57924: LIST
57925: LIST
57926: LIST
57927: LIST
57928: LIST
57929: LIST
57930: LIST
57931: LIST
57932: LIST
57933: LIST
57934: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57935: LD_ADDR_VAR 0 19
57939: PUSH
57940: LD_INT 0
57942: PUSH
57943: LD_INT 0
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: PUSH
57950: LD_INT 0
57952: PUSH
57953: LD_INT 1
57955: NEG
57956: PUSH
57957: EMPTY
57958: LIST
57959: LIST
57960: PUSH
57961: LD_INT 1
57963: PUSH
57964: LD_INT 0
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: PUSH
57971: LD_INT 1
57973: PUSH
57974: LD_INT 1
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: PUSH
57981: LD_INT 0
57983: PUSH
57984: LD_INT 1
57986: PUSH
57987: EMPTY
57988: LIST
57989: LIST
57990: PUSH
57991: LD_INT 1
57993: NEG
57994: PUSH
57995: LD_INT 0
57997: PUSH
57998: EMPTY
57999: LIST
58000: LIST
58001: PUSH
58002: LD_INT 1
58004: NEG
58005: PUSH
58006: LD_INT 1
58008: NEG
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PUSH
58014: LD_INT 1
58016: NEG
58017: PUSH
58018: LD_INT 2
58020: NEG
58021: PUSH
58022: EMPTY
58023: LIST
58024: LIST
58025: PUSH
58026: LD_INT 0
58028: PUSH
58029: LD_INT 2
58031: NEG
58032: PUSH
58033: EMPTY
58034: LIST
58035: LIST
58036: PUSH
58037: LD_INT 1
58039: PUSH
58040: LD_INT 1
58042: NEG
58043: PUSH
58044: EMPTY
58045: LIST
58046: LIST
58047: PUSH
58048: LD_INT 2
58050: PUSH
58051: LD_INT 0
58053: PUSH
58054: EMPTY
58055: LIST
58056: LIST
58057: PUSH
58058: LD_INT 2
58060: PUSH
58061: LD_INT 1
58063: PUSH
58064: EMPTY
58065: LIST
58066: LIST
58067: PUSH
58068: LD_INT 2
58070: PUSH
58071: LD_INT 2
58073: PUSH
58074: EMPTY
58075: LIST
58076: LIST
58077: PUSH
58078: LD_INT 1
58080: PUSH
58081: LD_INT 2
58083: PUSH
58084: EMPTY
58085: LIST
58086: LIST
58087: PUSH
58088: LD_INT 0
58090: PUSH
58091: LD_INT 2
58093: PUSH
58094: EMPTY
58095: LIST
58096: LIST
58097: PUSH
58098: LD_INT 1
58100: NEG
58101: PUSH
58102: LD_INT 1
58104: PUSH
58105: EMPTY
58106: LIST
58107: LIST
58108: PUSH
58109: LD_INT 2
58111: NEG
58112: PUSH
58113: LD_INT 0
58115: PUSH
58116: EMPTY
58117: LIST
58118: LIST
58119: PUSH
58120: LD_INT 2
58122: NEG
58123: PUSH
58124: LD_INT 1
58126: NEG
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PUSH
58132: LD_INT 2
58134: NEG
58135: PUSH
58136: LD_INT 2
58138: NEG
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: LIST
58148: LIST
58149: LIST
58150: LIST
58151: LIST
58152: LIST
58153: LIST
58154: LIST
58155: LIST
58156: LIST
58157: LIST
58158: LIST
58159: LIST
58160: LIST
58161: LIST
58162: LIST
58163: LIST
58164: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
58165: LD_ADDR_VAR 0 20
58169: PUSH
58170: LD_INT 0
58172: PUSH
58173: LD_INT 0
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: PUSH
58180: LD_INT 0
58182: PUSH
58183: LD_INT 1
58185: NEG
58186: PUSH
58187: EMPTY
58188: LIST
58189: LIST
58190: PUSH
58191: LD_INT 1
58193: PUSH
58194: LD_INT 0
58196: PUSH
58197: EMPTY
58198: LIST
58199: LIST
58200: PUSH
58201: LD_INT 1
58203: PUSH
58204: LD_INT 1
58206: PUSH
58207: EMPTY
58208: LIST
58209: LIST
58210: PUSH
58211: LD_INT 0
58213: PUSH
58214: LD_INT 1
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: PUSH
58221: LD_INT 1
58223: NEG
58224: PUSH
58225: LD_INT 0
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: PUSH
58232: LD_INT 1
58234: NEG
58235: PUSH
58236: LD_INT 1
58238: NEG
58239: PUSH
58240: EMPTY
58241: LIST
58242: LIST
58243: PUSH
58244: LD_INT 1
58246: NEG
58247: PUSH
58248: LD_INT 2
58250: NEG
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: PUSH
58256: LD_INT 0
58258: PUSH
58259: LD_INT 2
58261: NEG
58262: PUSH
58263: EMPTY
58264: LIST
58265: LIST
58266: PUSH
58267: LD_INT 1
58269: PUSH
58270: LD_INT 1
58272: NEG
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: PUSH
58278: LD_INT 2
58280: PUSH
58281: LD_INT 0
58283: PUSH
58284: EMPTY
58285: LIST
58286: LIST
58287: PUSH
58288: LD_INT 2
58290: PUSH
58291: LD_INT 1
58293: PUSH
58294: EMPTY
58295: LIST
58296: LIST
58297: PUSH
58298: LD_INT 2
58300: PUSH
58301: LD_INT 2
58303: PUSH
58304: EMPTY
58305: LIST
58306: LIST
58307: PUSH
58308: LD_INT 1
58310: PUSH
58311: LD_INT 2
58313: PUSH
58314: EMPTY
58315: LIST
58316: LIST
58317: PUSH
58318: LD_INT 0
58320: PUSH
58321: LD_INT 2
58323: PUSH
58324: EMPTY
58325: LIST
58326: LIST
58327: PUSH
58328: LD_INT 1
58330: NEG
58331: PUSH
58332: LD_INT 1
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PUSH
58339: LD_INT 2
58341: NEG
58342: PUSH
58343: LD_INT 0
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: PUSH
58350: LD_INT 2
58352: NEG
58353: PUSH
58354: LD_INT 1
58356: NEG
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: PUSH
58362: LD_INT 2
58364: NEG
58365: PUSH
58366: LD_INT 2
58368: NEG
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: EMPTY
58375: LIST
58376: LIST
58377: LIST
58378: LIST
58379: LIST
58380: LIST
58381: LIST
58382: LIST
58383: LIST
58384: LIST
58385: LIST
58386: LIST
58387: LIST
58388: LIST
58389: LIST
58390: LIST
58391: LIST
58392: LIST
58393: LIST
58394: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
58395: LD_ADDR_VAR 0 21
58399: PUSH
58400: LD_INT 0
58402: PUSH
58403: LD_INT 0
58405: PUSH
58406: EMPTY
58407: LIST
58408: LIST
58409: PUSH
58410: LD_INT 0
58412: PUSH
58413: LD_INT 1
58415: NEG
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PUSH
58421: LD_INT 1
58423: PUSH
58424: LD_INT 0
58426: PUSH
58427: EMPTY
58428: LIST
58429: LIST
58430: PUSH
58431: LD_INT 1
58433: PUSH
58434: LD_INT 1
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: PUSH
58441: LD_INT 0
58443: PUSH
58444: LD_INT 1
58446: PUSH
58447: EMPTY
58448: LIST
58449: LIST
58450: PUSH
58451: LD_INT 1
58453: NEG
58454: PUSH
58455: LD_INT 0
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: PUSH
58462: LD_INT 1
58464: NEG
58465: PUSH
58466: LD_INT 1
58468: NEG
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: PUSH
58474: LD_INT 1
58476: NEG
58477: PUSH
58478: LD_INT 2
58480: NEG
58481: PUSH
58482: EMPTY
58483: LIST
58484: LIST
58485: PUSH
58486: LD_INT 0
58488: PUSH
58489: LD_INT 2
58491: NEG
58492: PUSH
58493: EMPTY
58494: LIST
58495: LIST
58496: PUSH
58497: LD_INT 1
58499: PUSH
58500: LD_INT 1
58502: NEG
58503: PUSH
58504: EMPTY
58505: LIST
58506: LIST
58507: PUSH
58508: LD_INT 2
58510: PUSH
58511: LD_INT 0
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: PUSH
58518: LD_INT 2
58520: PUSH
58521: LD_INT 1
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: PUSH
58528: LD_INT 2
58530: PUSH
58531: LD_INT 2
58533: PUSH
58534: EMPTY
58535: LIST
58536: LIST
58537: PUSH
58538: LD_INT 1
58540: PUSH
58541: LD_INT 2
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: PUSH
58548: LD_INT 0
58550: PUSH
58551: LD_INT 2
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: PUSH
58558: LD_INT 1
58560: NEG
58561: PUSH
58562: LD_INT 1
58564: PUSH
58565: EMPTY
58566: LIST
58567: LIST
58568: PUSH
58569: LD_INT 2
58571: NEG
58572: PUSH
58573: LD_INT 0
58575: PUSH
58576: EMPTY
58577: LIST
58578: LIST
58579: PUSH
58580: LD_INT 2
58582: NEG
58583: PUSH
58584: LD_INT 1
58586: NEG
58587: PUSH
58588: EMPTY
58589: LIST
58590: LIST
58591: PUSH
58592: LD_INT 2
58594: NEG
58595: PUSH
58596: LD_INT 2
58598: NEG
58599: PUSH
58600: EMPTY
58601: LIST
58602: LIST
58603: PUSH
58604: EMPTY
58605: LIST
58606: LIST
58607: LIST
58608: LIST
58609: LIST
58610: LIST
58611: LIST
58612: LIST
58613: LIST
58614: LIST
58615: LIST
58616: LIST
58617: LIST
58618: LIST
58619: LIST
58620: LIST
58621: LIST
58622: LIST
58623: LIST
58624: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
58625: LD_ADDR_VAR 0 22
58629: PUSH
58630: LD_INT 0
58632: PUSH
58633: LD_INT 0
58635: PUSH
58636: EMPTY
58637: LIST
58638: LIST
58639: PUSH
58640: LD_INT 0
58642: PUSH
58643: LD_INT 1
58645: NEG
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: PUSH
58651: LD_INT 1
58653: PUSH
58654: LD_INT 0
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: PUSH
58661: LD_INT 1
58663: PUSH
58664: LD_INT 1
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: PUSH
58671: LD_INT 0
58673: PUSH
58674: LD_INT 1
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: PUSH
58681: LD_INT 1
58683: NEG
58684: PUSH
58685: LD_INT 0
58687: PUSH
58688: EMPTY
58689: LIST
58690: LIST
58691: PUSH
58692: LD_INT 1
58694: NEG
58695: PUSH
58696: LD_INT 1
58698: NEG
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: PUSH
58704: LD_INT 1
58706: NEG
58707: PUSH
58708: LD_INT 2
58710: NEG
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: PUSH
58716: LD_INT 0
58718: PUSH
58719: LD_INT 2
58721: NEG
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: PUSH
58727: LD_INT 1
58729: PUSH
58730: LD_INT 1
58732: NEG
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PUSH
58738: LD_INT 2
58740: PUSH
58741: LD_INT 0
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: PUSH
58748: LD_INT 2
58750: PUSH
58751: LD_INT 1
58753: PUSH
58754: EMPTY
58755: LIST
58756: LIST
58757: PUSH
58758: LD_INT 2
58760: PUSH
58761: LD_INT 2
58763: PUSH
58764: EMPTY
58765: LIST
58766: LIST
58767: PUSH
58768: LD_INT 1
58770: PUSH
58771: LD_INT 2
58773: PUSH
58774: EMPTY
58775: LIST
58776: LIST
58777: PUSH
58778: LD_INT 0
58780: PUSH
58781: LD_INT 2
58783: PUSH
58784: EMPTY
58785: LIST
58786: LIST
58787: PUSH
58788: LD_INT 1
58790: NEG
58791: PUSH
58792: LD_INT 1
58794: PUSH
58795: EMPTY
58796: LIST
58797: LIST
58798: PUSH
58799: LD_INT 2
58801: NEG
58802: PUSH
58803: LD_INT 0
58805: PUSH
58806: EMPTY
58807: LIST
58808: LIST
58809: PUSH
58810: LD_INT 2
58812: NEG
58813: PUSH
58814: LD_INT 1
58816: NEG
58817: PUSH
58818: EMPTY
58819: LIST
58820: LIST
58821: PUSH
58822: LD_INT 2
58824: NEG
58825: PUSH
58826: LD_INT 2
58828: NEG
58829: PUSH
58830: EMPTY
58831: LIST
58832: LIST
58833: PUSH
58834: EMPTY
58835: LIST
58836: LIST
58837: LIST
58838: LIST
58839: LIST
58840: LIST
58841: LIST
58842: LIST
58843: LIST
58844: LIST
58845: LIST
58846: LIST
58847: LIST
58848: LIST
58849: LIST
58850: LIST
58851: LIST
58852: LIST
58853: LIST
58854: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
58855: LD_ADDR_VAR 0 23
58859: PUSH
58860: LD_INT 0
58862: PUSH
58863: LD_INT 0
58865: PUSH
58866: EMPTY
58867: LIST
58868: LIST
58869: PUSH
58870: LD_INT 0
58872: PUSH
58873: LD_INT 1
58875: NEG
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: PUSH
58881: LD_INT 1
58883: PUSH
58884: LD_INT 0
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: PUSH
58891: LD_INT 1
58893: PUSH
58894: LD_INT 1
58896: PUSH
58897: EMPTY
58898: LIST
58899: LIST
58900: PUSH
58901: LD_INT 0
58903: PUSH
58904: LD_INT 1
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PUSH
58911: LD_INT 1
58913: NEG
58914: PUSH
58915: LD_INT 0
58917: PUSH
58918: EMPTY
58919: LIST
58920: LIST
58921: PUSH
58922: LD_INT 1
58924: NEG
58925: PUSH
58926: LD_INT 1
58928: NEG
58929: PUSH
58930: EMPTY
58931: LIST
58932: LIST
58933: PUSH
58934: LD_INT 1
58936: NEG
58937: PUSH
58938: LD_INT 2
58940: NEG
58941: PUSH
58942: EMPTY
58943: LIST
58944: LIST
58945: PUSH
58946: LD_INT 0
58948: PUSH
58949: LD_INT 2
58951: NEG
58952: PUSH
58953: EMPTY
58954: LIST
58955: LIST
58956: PUSH
58957: LD_INT 1
58959: PUSH
58960: LD_INT 1
58962: NEG
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: PUSH
58968: LD_INT 2
58970: PUSH
58971: LD_INT 0
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: PUSH
58978: LD_INT 2
58980: PUSH
58981: LD_INT 1
58983: PUSH
58984: EMPTY
58985: LIST
58986: LIST
58987: PUSH
58988: LD_INT 2
58990: PUSH
58991: LD_INT 2
58993: PUSH
58994: EMPTY
58995: LIST
58996: LIST
58997: PUSH
58998: LD_INT 1
59000: PUSH
59001: LD_INT 2
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: PUSH
59008: LD_INT 0
59010: PUSH
59011: LD_INT 2
59013: PUSH
59014: EMPTY
59015: LIST
59016: LIST
59017: PUSH
59018: LD_INT 1
59020: NEG
59021: PUSH
59022: LD_INT 1
59024: PUSH
59025: EMPTY
59026: LIST
59027: LIST
59028: PUSH
59029: LD_INT 2
59031: NEG
59032: PUSH
59033: LD_INT 0
59035: PUSH
59036: EMPTY
59037: LIST
59038: LIST
59039: PUSH
59040: LD_INT 2
59042: NEG
59043: PUSH
59044: LD_INT 1
59046: NEG
59047: PUSH
59048: EMPTY
59049: LIST
59050: LIST
59051: PUSH
59052: LD_INT 2
59054: NEG
59055: PUSH
59056: LD_INT 2
59058: NEG
59059: PUSH
59060: EMPTY
59061: LIST
59062: LIST
59063: PUSH
59064: LD_INT 2
59066: NEG
59067: PUSH
59068: LD_INT 3
59070: NEG
59071: PUSH
59072: EMPTY
59073: LIST
59074: LIST
59075: PUSH
59076: LD_INT 1
59078: NEG
59079: PUSH
59080: LD_INT 3
59082: NEG
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: PUSH
59088: LD_INT 1
59090: PUSH
59091: LD_INT 2
59093: NEG
59094: PUSH
59095: EMPTY
59096: LIST
59097: LIST
59098: PUSH
59099: LD_INT 2
59101: PUSH
59102: LD_INT 1
59104: NEG
59105: PUSH
59106: EMPTY
59107: LIST
59108: LIST
59109: PUSH
59110: EMPTY
59111: LIST
59112: LIST
59113: LIST
59114: LIST
59115: LIST
59116: LIST
59117: LIST
59118: LIST
59119: LIST
59120: LIST
59121: LIST
59122: LIST
59123: LIST
59124: LIST
59125: LIST
59126: LIST
59127: LIST
59128: LIST
59129: LIST
59130: LIST
59131: LIST
59132: LIST
59133: LIST
59134: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
59135: LD_ADDR_VAR 0 24
59139: PUSH
59140: LD_INT 0
59142: PUSH
59143: LD_INT 0
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: PUSH
59150: LD_INT 0
59152: PUSH
59153: LD_INT 1
59155: NEG
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: PUSH
59161: LD_INT 1
59163: PUSH
59164: LD_INT 0
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: PUSH
59171: LD_INT 1
59173: PUSH
59174: LD_INT 1
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PUSH
59181: LD_INT 0
59183: PUSH
59184: LD_INT 1
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PUSH
59191: LD_INT 1
59193: NEG
59194: PUSH
59195: LD_INT 0
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: PUSH
59202: LD_INT 1
59204: NEG
59205: PUSH
59206: LD_INT 1
59208: NEG
59209: PUSH
59210: EMPTY
59211: LIST
59212: LIST
59213: PUSH
59214: LD_INT 1
59216: NEG
59217: PUSH
59218: LD_INT 2
59220: NEG
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: PUSH
59226: LD_INT 0
59228: PUSH
59229: LD_INT 2
59231: NEG
59232: PUSH
59233: EMPTY
59234: LIST
59235: LIST
59236: PUSH
59237: LD_INT 1
59239: PUSH
59240: LD_INT 1
59242: NEG
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: PUSH
59248: LD_INT 2
59250: PUSH
59251: LD_INT 0
59253: PUSH
59254: EMPTY
59255: LIST
59256: LIST
59257: PUSH
59258: LD_INT 2
59260: PUSH
59261: LD_INT 1
59263: PUSH
59264: EMPTY
59265: LIST
59266: LIST
59267: PUSH
59268: LD_INT 2
59270: PUSH
59271: LD_INT 2
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: PUSH
59278: LD_INT 1
59280: PUSH
59281: LD_INT 2
59283: PUSH
59284: EMPTY
59285: LIST
59286: LIST
59287: PUSH
59288: LD_INT 0
59290: PUSH
59291: LD_INT 2
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: PUSH
59298: LD_INT 1
59300: NEG
59301: PUSH
59302: LD_INT 1
59304: PUSH
59305: EMPTY
59306: LIST
59307: LIST
59308: PUSH
59309: LD_INT 2
59311: NEG
59312: PUSH
59313: LD_INT 0
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PUSH
59320: LD_INT 2
59322: NEG
59323: PUSH
59324: LD_INT 1
59326: NEG
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: PUSH
59332: LD_INT 2
59334: NEG
59335: PUSH
59336: LD_INT 2
59338: NEG
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: PUSH
59344: LD_INT 1
59346: PUSH
59347: LD_INT 2
59349: NEG
59350: PUSH
59351: EMPTY
59352: LIST
59353: LIST
59354: PUSH
59355: LD_INT 2
59357: PUSH
59358: LD_INT 1
59360: NEG
59361: PUSH
59362: EMPTY
59363: LIST
59364: LIST
59365: PUSH
59366: LD_INT 3
59368: PUSH
59369: LD_INT 1
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: PUSH
59376: LD_INT 3
59378: PUSH
59379: LD_INT 2
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: PUSH
59386: EMPTY
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: LIST
59393: LIST
59394: LIST
59395: LIST
59396: LIST
59397: LIST
59398: LIST
59399: LIST
59400: LIST
59401: LIST
59402: LIST
59403: LIST
59404: LIST
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: LIST
59410: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
59411: LD_ADDR_VAR 0 25
59415: PUSH
59416: LD_INT 0
59418: PUSH
59419: LD_INT 0
59421: PUSH
59422: EMPTY
59423: LIST
59424: LIST
59425: PUSH
59426: LD_INT 0
59428: PUSH
59429: LD_INT 1
59431: NEG
59432: PUSH
59433: EMPTY
59434: LIST
59435: LIST
59436: PUSH
59437: LD_INT 1
59439: PUSH
59440: LD_INT 0
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PUSH
59447: LD_INT 1
59449: PUSH
59450: LD_INT 1
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: LD_INT 0
59459: PUSH
59460: LD_INT 1
59462: PUSH
59463: EMPTY
59464: LIST
59465: LIST
59466: PUSH
59467: LD_INT 1
59469: NEG
59470: PUSH
59471: LD_INT 0
59473: PUSH
59474: EMPTY
59475: LIST
59476: LIST
59477: PUSH
59478: LD_INT 1
59480: NEG
59481: PUSH
59482: LD_INT 1
59484: NEG
59485: PUSH
59486: EMPTY
59487: LIST
59488: LIST
59489: PUSH
59490: LD_INT 1
59492: NEG
59493: PUSH
59494: LD_INT 2
59496: NEG
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: LD_INT 0
59504: PUSH
59505: LD_INT 2
59507: NEG
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 1
59515: PUSH
59516: LD_INT 1
59518: NEG
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: LD_INT 2
59526: PUSH
59527: LD_INT 0
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: PUSH
59534: LD_INT 2
59536: PUSH
59537: LD_INT 1
59539: PUSH
59540: EMPTY
59541: LIST
59542: LIST
59543: PUSH
59544: LD_INT 2
59546: PUSH
59547: LD_INT 2
59549: PUSH
59550: EMPTY
59551: LIST
59552: LIST
59553: PUSH
59554: LD_INT 1
59556: PUSH
59557: LD_INT 2
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: PUSH
59564: LD_INT 0
59566: PUSH
59567: LD_INT 2
59569: PUSH
59570: EMPTY
59571: LIST
59572: LIST
59573: PUSH
59574: LD_INT 1
59576: NEG
59577: PUSH
59578: LD_INT 1
59580: PUSH
59581: EMPTY
59582: LIST
59583: LIST
59584: PUSH
59585: LD_INT 2
59587: NEG
59588: PUSH
59589: LD_INT 0
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: PUSH
59596: LD_INT 2
59598: NEG
59599: PUSH
59600: LD_INT 1
59602: NEG
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: PUSH
59608: LD_INT 2
59610: NEG
59611: PUSH
59612: LD_INT 2
59614: NEG
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: PUSH
59620: LD_INT 3
59622: PUSH
59623: LD_INT 1
59625: PUSH
59626: EMPTY
59627: LIST
59628: LIST
59629: PUSH
59630: LD_INT 3
59632: PUSH
59633: LD_INT 2
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: PUSH
59640: LD_INT 2
59642: PUSH
59643: LD_INT 3
59645: PUSH
59646: EMPTY
59647: LIST
59648: LIST
59649: PUSH
59650: LD_INT 1
59652: PUSH
59653: LD_INT 3
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: LIST
59664: LIST
59665: LIST
59666: LIST
59667: LIST
59668: LIST
59669: LIST
59670: LIST
59671: LIST
59672: LIST
59673: LIST
59674: LIST
59675: LIST
59676: LIST
59677: LIST
59678: LIST
59679: LIST
59680: LIST
59681: LIST
59682: LIST
59683: LIST
59684: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
59685: LD_ADDR_VAR 0 26
59689: PUSH
59690: LD_INT 0
59692: PUSH
59693: LD_INT 0
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: PUSH
59700: LD_INT 0
59702: PUSH
59703: LD_INT 1
59705: NEG
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PUSH
59711: LD_INT 1
59713: PUSH
59714: LD_INT 0
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: PUSH
59721: LD_INT 1
59723: PUSH
59724: LD_INT 1
59726: PUSH
59727: EMPTY
59728: LIST
59729: LIST
59730: PUSH
59731: LD_INT 0
59733: PUSH
59734: LD_INT 1
59736: PUSH
59737: EMPTY
59738: LIST
59739: LIST
59740: PUSH
59741: LD_INT 1
59743: NEG
59744: PUSH
59745: LD_INT 0
59747: PUSH
59748: EMPTY
59749: LIST
59750: LIST
59751: PUSH
59752: LD_INT 1
59754: NEG
59755: PUSH
59756: LD_INT 1
59758: NEG
59759: PUSH
59760: EMPTY
59761: LIST
59762: LIST
59763: PUSH
59764: LD_INT 1
59766: NEG
59767: PUSH
59768: LD_INT 2
59770: NEG
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: LD_INT 0
59778: PUSH
59779: LD_INT 2
59781: NEG
59782: PUSH
59783: EMPTY
59784: LIST
59785: LIST
59786: PUSH
59787: LD_INT 1
59789: PUSH
59790: LD_INT 1
59792: NEG
59793: PUSH
59794: EMPTY
59795: LIST
59796: LIST
59797: PUSH
59798: LD_INT 2
59800: PUSH
59801: LD_INT 0
59803: PUSH
59804: EMPTY
59805: LIST
59806: LIST
59807: PUSH
59808: LD_INT 2
59810: PUSH
59811: LD_INT 1
59813: PUSH
59814: EMPTY
59815: LIST
59816: LIST
59817: PUSH
59818: LD_INT 2
59820: PUSH
59821: LD_INT 2
59823: PUSH
59824: EMPTY
59825: LIST
59826: LIST
59827: PUSH
59828: LD_INT 1
59830: PUSH
59831: LD_INT 2
59833: PUSH
59834: EMPTY
59835: LIST
59836: LIST
59837: PUSH
59838: LD_INT 0
59840: PUSH
59841: LD_INT 2
59843: PUSH
59844: EMPTY
59845: LIST
59846: LIST
59847: PUSH
59848: LD_INT 1
59850: NEG
59851: PUSH
59852: LD_INT 1
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: LD_INT 2
59861: NEG
59862: PUSH
59863: LD_INT 0
59865: PUSH
59866: EMPTY
59867: LIST
59868: LIST
59869: PUSH
59870: LD_INT 2
59872: NEG
59873: PUSH
59874: LD_INT 1
59876: NEG
59877: PUSH
59878: EMPTY
59879: LIST
59880: LIST
59881: PUSH
59882: LD_INT 2
59884: NEG
59885: PUSH
59886: LD_INT 2
59888: NEG
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: PUSH
59894: LD_INT 2
59896: PUSH
59897: LD_INT 3
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PUSH
59904: LD_INT 1
59906: PUSH
59907: LD_INT 3
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: PUSH
59914: LD_INT 1
59916: NEG
59917: PUSH
59918: LD_INT 2
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: LD_INT 2
59927: NEG
59928: PUSH
59929: LD_INT 1
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: LIST
59940: LIST
59941: LIST
59942: LIST
59943: LIST
59944: LIST
59945: LIST
59946: LIST
59947: LIST
59948: LIST
59949: LIST
59950: LIST
59951: LIST
59952: LIST
59953: LIST
59954: LIST
59955: LIST
59956: LIST
59957: LIST
59958: LIST
59959: LIST
59960: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59961: LD_ADDR_VAR 0 27
59965: PUSH
59966: LD_INT 0
59968: PUSH
59969: LD_INT 0
59971: PUSH
59972: EMPTY
59973: LIST
59974: LIST
59975: PUSH
59976: LD_INT 0
59978: PUSH
59979: LD_INT 1
59981: NEG
59982: PUSH
59983: EMPTY
59984: LIST
59985: LIST
59986: PUSH
59987: LD_INT 1
59989: PUSH
59990: LD_INT 0
59992: PUSH
59993: EMPTY
59994: LIST
59995: LIST
59996: PUSH
59997: LD_INT 1
59999: PUSH
60000: LD_INT 1
60002: PUSH
60003: EMPTY
60004: LIST
60005: LIST
60006: PUSH
60007: LD_INT 0
60009: PUSH
60010: LD_INT 1
60012: PUSH
60013: EMPTY
60014: LIST
60015: LIST
60016: PUSH
60017: LD_INT 1
60019: NEG
60020: PUSH
60021: LD_INT 0
60023: PUSH
60024: EMPTY
60025: LIST
60026: LIST
60027: PUSH
60028: LD_INT 1
60030: NEG
60031: PUSH
60032: LD_INT 1
60034: NEG
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: PUSH
60040: LD_INT 1
60042: NEG
60043: PUSH
60044: LD_INT 2
60046: NEG
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PUSH
60052: LD_INT 0
60054: PUSH
60055: LD_INT 2
60057: NEG
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PUSH
60063: LD_INT 1
60065: PUSH
60066: LD_INT 1
60068: NEG
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PUSH
60074: LD_INT 2
60076: PUSH
60077: LD_INT 0
60079: PUSH
60080: EMPTY
60081: LIST
60082: LIST
60083: PUSH
60084: LD_INT 2
60086: PUSH
60087: LD_INT 1
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PUSH
60094: LD_INT 2
60096: PUSH
60097: LD_INT 2
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PUSH
60104: LD_INT 1
60106: PUSH
60107: LD_INT 2
60109: PUSH
60110: EMPTY
60111: LIST
60112: LIST
60113: PUSH
60114: LD_INT 0
60116: PUSH
60117: LD_INT 2
60119: PUSH
60120: EMPTY
60121: LIST
60122: LIST
60123: PUSH
60124: LD_INT 1
60126: NEG
60127: PUSH
60128: LD_INT 1
60130: PUSH
60131: EMPTY
60132: LIST
60133: LIST
60134: PUSH
60135: LD_INT 2
60137: NEG
60138: PUSH
60139: LD_INT 0
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: LD_INT 2
60148: NEG
60149: PUSH
60150: LD_INT 1
60152: NEG
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PUSH
60158: LD_INT 2
60160: NEG
60161: PUSH
60162: LD_INT 2
60164: NEG
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: PUSH
60170: LD_INT 1
60172: NEG
60173: PUSH
60174: LD_INT 2
60176: PUSH
60177: EMPTY
60178: LIST
60179: LIST
60180: PUSH
60181: LD_INT 2
60183: NEG
60184: PUSH
60185: LD_INT 1
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: LD_INT 3
60194: NEG
60195: PUSH
60196: LD_INT 1
60198: NEG
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: PUSH
60204: LD_INT 3
60206: NEG
60207: PUSH
60208: LD_INT 2
60210: NEG
60211: PUSH
60212: EMPTY
60213: LIST
60214: LIST
60215: PUSH
60216: EMPTY
60217: LIST
60218: LIST
60219: LIST
60220: LIST
60221: LIST
60222: LIST
60223: LIST
60224: LIST
60225: LIST
60226: LIST
60227: LIST
60228: LIST
60229: LIST
60230: LIST
60231: LIST
60232: LIST
60233: LIST
60234: LIST
60235: LIST
60236: LIST
60237: LIST
60238: LIST
60239: LIST
60240: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
60241: LD_ADDR_VAR 0 28
60245: PUSH
60246: LD_INT 0
60248: PUSH
60249: LD_INT 0
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: PUSH
60256: LD_INT 0
60258: PUSH
60259: LD_INT 1
60261: NEG
60262: PUSH
60263: EMPTY
60264: LIST
60265: LIST
60266: PUSH
60267: LD_INT 1
60269: PUSH
60270: LD_INT 0
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: PUSH
60277: LD_INT 1
60279: PUSH
60280: LD_INT 1
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: PUSH
60287: LD_INT 0
60289: PUSH
60290: LD_INT 1
60292: PUSH
60293: EMPTY
60294: LIST
60295: LIST
60296: PUSH
60297: LD_INT 1
60299: NEG
60300: PUSH
60301: LD_INT 0
60303: PUSH
60304: EMPTY
60305: LIST
60306: LIST
60307: PUSH
60308: LD_INT 1
60310: NEG
60311: PUSH
60312: LD_INT 1
60314: NEG
60315: PUSH
60316: EMPTY
60317: LIST
60318: LIST
60319: PUSH
60320: LD_INT 1
60322: NEG
60323: PUSH
60324: LD_INT 2
60326: NEG
60327: PUSH
60328: EMPTY
60329: LIST
60330: LIST
60331: PUSH
60332: LD_INT 0
60334: PUSH
60335: LD_INT 2
60337: NEG
60338: PUSH
60339: EMPTY
60340: LIST
60341: LIST
60342: PUSH
60343: LD_INT 1
60345: PUSH
60346: LD_INT 1
60348: NEG
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: LD_INT 2
60356: PUSH
60357: LD_INT 0
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: PUSH
60364: LD_INT 2
60366: PUSH
60367: LD_INT 1
60369: PUSH
60370: EMPTY
60371: LIST
60372: LIST
60373: PUSH
60374: LD_INT 2
60376: PUSH
60377: LD_INT 2
60379: PUSH
60380: EMPTY
60381: LIST
60382: LIST
60383: PUSH
60384: LD_INT 1
60386: PUSH
60387: LD_INT 2
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PUSH
60394: LD_INT 0
60396: PUSH
60397: LD_INT 2
60399: PUSH
60400: EMPTY
60401: LIST
60402: LIST
60403: PUSH
60404: LD_INT 1
60406: NEG
60407: PUSH
60408: LD_INT 1
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: LD_INT 2
60417: NEG
60418: PUSH
60419: LD_INT 0
60421: PUSH
60422: EMPTY
60423: LIST
60424: LIST
60425: PUSH
60426: LD_INT 2
60428: NEG
60429: PUSH
60430: LD_INT 1
60432: NEG
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: PUSH
60438: LD_INT 2
60440: NEG
60441: PUSH
60442: LD_INT 2
60444: NEG
60445: PUSH
60446: EMPTY
60447: LIST
60448: LIST
60449: PUSH
60450: LD_INT 2
60452: NEG
60453: PUSH
60454: LD_INT 3
60456: NEG
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: LD_INT 1
60464: NEG
60465: PUSH
60466: LD_INT 3
60468: NEG
60469: PUSH
60470: EMPTY
60471: LIST
60472: LIST
60473: PUSH
60474: LD_INT 3
60476: NEG
60477: PUSH
60478: LD_INT 1
60480: NEG
60481: PUSH
60482: EMPTY
60483: LIST
60484: LIST
60485: PUSH
60486: LD_INT 3
60488: NEG
60489: PUSH
60490: LD_INT 2
60492: NEG
60493: PUSH
60494: EMPTY
60495: LIST
60496: LIST
60497: PUSH
60498: EMPTY
60499: LIST
60500: LIST
60501: LIST
60502: LIST
60503: LIST
60504: LIST
60505: LIST
60506: LIST
60507: LIST
60508: LIST
60509: LIST
60510: LIST
60511: LIST
60512: LIST
60513: LIST
60514: LIST
60515: LIST
60516: LIST
60517: LIST
60518: LIST
60519: LIST
60520: LIST
60521: LIST
60522: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
60523: LD_ADDR_VAR 0 29
60527: PUSH
60528: LD_INT 0
60530: PUSH
60531: LD_INT 0
60533: PUSH
60534: EMPTY
60535: LIST
60536: LIST
60537: PUSH
60538: LD_INT 0
60540: PUSH
60541: LD_INT 1
60543: NEG
60544: PUSH
60545: EMPTY
60546: LIST
60547: LIST
60548: PUSH
60549: LD_INT 1
60551: PUSH
60552: LD_INT 0
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: PUSH
60559: LD_INT 1
60561: PUSH
60562: LD_INT 1
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: PUSH
60569: LD_INT 0
60571: PUSH
60572: LD_INT 1
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: PUSH
60579: LD_INT 1
60581: NEG
60582: PUSH
60583: LD_INT 0
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: PUSH
60590: LD_INT 1
60592: NEG
60593: PUSH
60594: LD_INT 1
60596: NEG
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PUSH
60602: LD_INT 1
60604: NEG
60605: PUSH
60606: LD_INT 2
60608: NEG
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PUSH
60614: LD_INT 0
60616: PUSH
60617: LD_INT 2
60619: NEG
60620: PUSH
60621: EMPTY
60622: LIST
60623: LIST
60624: PUSH
60625: LD_INT 1
60627: PUSH
60628: LD_INT 1
60630: NEG
60631: PUSH
60632: EMPTY
60633: LIST
60634: LIST
60635: PUSH
60636: LD_INT 2
60638: PUSH
60639: LD_INT 0
60641: PUSH
60642: EMPTY
60643: LIST
60644: LIST
60645: PUSH
60646: LD_INT 2
60648: PUSH
60649: LD_INT 1
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: PUSH
60656: LD_INT 1
60658: PUSH
60659: LD_INT 2
60661: PUSH
60662: EMPTY
60663: LIST
60664: LIST
60665: PUSH
60666: LD_INT 0
60668: PUSH
60669: LD_INT 2
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: PUSH
60676: LD_INT 1
60678: NEG
60679: PUSH
60680: LD_INT 1
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: PUSH
60687: LD_INT 2
60689: NEG
60690: PUSH
60691: LD_INT 1
60693: NEG
60694: PUSH
60695: EMPTY
60696: LIST
60697: LIST
60698: PUSH
60699: LD_INT 2
60701: NEG
60702: PUSH
60703: LD_INT 2
60705: NEG
60706: PUSH
60707: EMPTY
60708: LIST
60709: LIST
60710: PUSH
60711: LD_INT 2
60713: NEG
60714: PUSH
60715: LD_INT 3
60717: NEG
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PUSH
60723: LD_INT 2
60725: PUSH
60726: LD_INT 1
60728: NEG
60729: PUSH
60730: EMPTY
60731: LIST
60732: LIST
60733: PUSH
60734: LD_INT 3
60736: PUSH
60737: LD_INT 1
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: LD_INT 1
60746: PUSH
60747: LD_INT 3
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: LD_INT 1
60756: NEG
60757: PUSH
60758: LD_INT 2
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PUSH
60765: LD_INT 3
60767: NEG
60768: PUSH
60769: LD_INT 2
60771: NEG
60772: PUSH
60773: EMPTY
60774: LIST
60775: LIST
60776: PUSH
60777: EMPTY
60778: LIST
60779: LIST
60780: LIST
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: LIST
60786: LIST
60787: LIST
60788: LIST
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: LIST
60798: LIST
60799: LIST
60800: LIST
60801: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
60802: LD_ADDR_VAR 0 30
60806: PUSH
60807: LD_INT 0
60809: PUSH
60810: LD_INT 0
60812: PUSH
60813: EMPTY
60814: LIST
60815: LIST
60816: PUSH
60817: LD_INT 0
60819: PUSH
60820: LD_INT 1
60822: NEG
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: PUSH
60828: LD_INT 1
60830: PUSH
60831: LD_INT 0
60833: PUSH
60834: EMPTY
60835: LIST
60836: LIST
60837: PUSH
60838: LD_INT 1
60840: PUSH
60841: LD_INT 1
60843: PUSH
60844: EMPTY
60845: LIST
60846: LIST
60847: PUSH
60848: LD_INT 0
60850: PUSH
60851: LD_INT 1
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: PUSH
60858: LD_INT 1
60860: NEG
60861: PUSH
60862: LD_INT 0
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: LD_INT 1
60871: NEG
60872: PUSH
60873: LD_INT 1
60875: NEG
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: LD_INT 1
60883: NEG
60884: PUSH
60885: LD_INT 2
60887: NEG
60888: PUSH
60889: EMPTY
60890: LIST
60891: LIST
60892: PUSH
60893: LD_INT 0
60895: PUSH
60896: LD_INT 2
60898: NEG
60899: PUSH
60900: EMPTY
60901: LIST
60902: LIST
60903: PUSH
60904: LD_INT 1
60906: PUSH
60907: LD_INT 1
60909: NEG
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: LD_INT 2
60917: PUSH
60918: LD_INT 0
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PUSH
60925: LD_INT 2
60927: PUSH
60928: LD_INT 1
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: LD_INT 2
60937: PUSH
60938: LD_INT 2
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: PUSH
60945: LD_INT 1
60947: PUSH
60948: LD_INT 2
60950: PUSH
60951: EMPTY
60952: LIST
60953: LIST
60954: PUSH
60955: LD_INT 1
60957: NEG
60958: PUSH
60959: LD_INT 1
60961: PUSH
60962: EMPTY
60963: LIST
60964: LIST
60965: PUSH
60966: LD_INT 2
60968: NEG
60969: PUSH
60970: LD_INT 0
60972: PUSH
60973: EMPTY
60974: LIST
60975: LIST
60976: PUSH
60977: LD_INT 2
60979: NEG
60980: PUSH
60981: LD_INT 1
60983: NEG
60984: PUSH
60985: EMPTY
60986: LIST
60987: LIST
60988: PUSH
60989: LD_INT 1
60991: NEG
60992: PUSH
60993: LD_INT 3
60995: NEG
60996: PUSH
60997: EMPTY
60998: LIST
60999: LIST
61000: PUSH
61001: LD_INT 1
61003: PUSH
61004: LD_INT 2
61006: NEG
61007: PUSH
61008: EMPTY
61009: LIST
61010: LIST
61011: PUSH
61012: LD_INT 3
61014: PUSH
61015: LD_INT 2
61017: PUSH
61018: EMPTY
61019: LIST
61020: LIST
61021: PUSH
61022: LD_INT 2
61024: PUSH
61025: LD_INT 3
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PUSH
61032: LD_INT 2
61034: NEG
61035: PUSH
61036: LD_INT 1
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PUSH
61043: LD_INT 3
61045: NEG
61046: PUSH
61047: LD_INT 1
61049: NEG
61050: PUSH
61051: EMPTY
61052: LIST
61053: LIST
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: LIST
61059: LIST
61060: LIST
61061: LIST
61062: LIST
61063: LIST
61064: LIST
61065: LIST
61066: LIST
61067: LIST
61068: LIST
61069: LIST
61070: LIST
61071: LIST
61072: LIST
61073: LIST
61074: LIST
61075: LIST
61076: LIST
61077: LIST
61078: LIST
61079: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
61080: LD_ADDR_VAR 0 31
61084: PUSH
61085: LD_INT 0
61087: PUSH
61088: LD_INT 0
61090: PUSH
61091: EMPTY
61092: LIST
61093: LIST
61094: PUSH
61095: LD_INT 0
61097: PUSH
61098: LD_INT 1
61100: NEG
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: LD_INT 1
61108: PUSH
61109: LD_INT 0
61111: PUSH
61112: EMPTY
61113: LIST
61114: LIST
61115: PUSH
61116: LD_INT 1
61118: PUSH
61119: LD_INT 1
61121: PUSH
61122: EMPTY
61123: LIST
61124: LIST
61125: PUSH
61126: LD_INT 0
61128: PUSH
61129: LD_INT 1
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 1
61138: NEG
61139: PUSH
61140: LD_INT 0
61142: PUSH
61143: EMPTY
61144: LIST
61145: LIST
61146: PUSH
61147: LD_INT 1
61149: NEG
61150: PUSH
61151: LD_INT 1
61153: NEG
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: PUSH
61159: LD_INT 1
61161: NEG
61162: PUSH
61163: LD_INT 2
61165: NEG
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: PUSH
61171: LD_INT 1
61173: PUSH
61174: LD_INT 1
61176: NEG
61177: PUSH
61178: EMPTY
61179: LIST
61180: LIST
61181: PUSH
61182: LD_INT 2
61184: PUSH
61185: LD_INT 0
61187: PUSH
61188: EMPTY
61189: LIST
61190: LIST
61191: PUSH
61192: LD_INT 2
61194: PUSH
61195: LD_INT 1
61197: PUSH
61198: EMPTY
61199: LIST
61200: LIST
61201: PUSH
61202: LD_INT 2
61204: PUSH
61205: LD_INT 2
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 1
61214: PUSH
61215: LD_INT 2
61217: PUSH
61218: EMPTY
61219: LIST
61220: LIST
61221: PUSH
61222: LD_INT 0
61224: PUSH
61225: LD_INT 2
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PUSH
61232: LD_INT 1
61234: NEG
61235: PUSH
61236: LD_INT 1
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: PUSH
61243: LD_INT 2
61245: NEG
61246: PUSH
61247: LD_INT 1
61249: NEG
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: PUSH
61255: LD_INT 2
61257: NEG
61258: PUSH
61259: LD_INT 2
61261: NEG
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: PUSH
61267: LD_INT 2
61269: NEG
61270: PUSH
61271: LD_INT 3
61273: NEG
61274: PUSH
61275: EMPTY
61276: LIST
61277: LIST
61278: PUSH
61279: LD_INT 2
61281: PUSH
61282: LD_INT 1
61284: NEG
61285: PUSH
61286: EMPTY
61287: LIST
61288: LIST
61289: PUSH
61290: LD_INT 3
61292: PUSH
61293: LD_INT 1
61295: PUSH
61296: EMPTY
61297: LIST
61298: LIST
61299: PUSH
61300: LD_INT 1
61302: PUSH
61303: LD_INT 3
61305: PUSH
61306: EMPTY
61307: LIST
61308: LIST
61309: PUSH
61310: LD_INT 1
61312: NEG
61313: PUSH
61314: LD_INT 2
61316: PUSH
61317: EMPTY
61318: LIST
61319: LIST
61320: PUSH
61321: LD_INT 3
61323: NEG
61324: PUSH
61325: LD_INT 2
61327: NEG
61328: PUSH
61329: EMPTY
61330: LIST
61331: LIST
61332: PUSH
61333: EMPTY
61334: LIST
61335: LIST
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: LIST
61347: LIST
61348: LIST
61349: LIST
61350: LIST
61351: LIST
61352: LIST
61353: LIST
61354: LIST
61355: LIST
61356: LIST
61357: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
61358: LD_ADDR_VAR 0 32
61362: PUSH
61363: LD_INT 0
61365: PUSH
61366: LD_INT 0
61368: PUSH
61369: EMPTY
61370: LIST
61371: LIST
61372: PUSH
61373: LD_INT 0
61375: PUSH
61376: LD_INT 1
61378: NEG
61379: PUSH
61380: EMPTY
61381: LIST
61382: LIST
61383: PUSH
61384: LD_INT 1
61386: PUSH
61387: LD_INT 0
61389: PUSH
61390: EMPTY
61391: LIST
61392: LIST
61393: PUSH
61394: LD_INT 1
61396: PUSH
61397: LD_INT 1
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 0
61406: PUSH
61407: LD_INT 1
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: LD_INT 1
61416: NEG
61417: PUSH
61418: LD_INT 0
61420: PUSH
61421: EMPTY
61422: LIST
61423: LIST
61424: PUSH
61425: LD_INT 1
61427: NEG
61428: PUSH
61429: LD_INT 1
61431: NEG
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: PUSH
61437: LD_INT 1
61439: NEG
61440: PUSH
61441: LD_INT 2
61443: NEG
61444: PUSH
61445: EMPTY
61446: LIST
61447: LIST
61448: PUSH
61449: LD_INT 0
61451: PUSH
61452: LD_INT 2
61454: NEG
61455: PUSH
61456: EMPTY
61457: LIST
61458: LIST
61459: PUSH
61460: LD_INT 1
61462: PUSH
61463: LD_INT 1
61465: NEG
61466: PUSH
61467: EMPTY
61468: LIST
61469: LIST
61470: PUSH
61471: LD_INT 2
61473: PUSH
61474: LD_INT 1
61476: PUSH
61477: EMPTY
61478: LIST
61479: LIST
61480: PUSH
61481: LD_INT 2
61483: PUSH
61484: LD_INT 2
61486: PUSH
61487: EMPTY
61488: LIST
61489: LIST
61490: PUSH
61491: LD_INT 1
61493: PUSH
61494: LD_INT 2
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: LD_INT 0
61503: PUSH
61504: LD_INT 2
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: PUSH
61511: LD_INT 1
61513: NEG
61514: PUSH
61515: LD_INT 1
61517: PUSH
61518: EMPTY
61519: LIST
61520: LIST
61521: PUSH
61522: LD_INT 2
61524: NEG
61525: PUSH
61526: LD_INT 0
61528: PUSH
61529: EMPTY
61530: LIST
61531: LIST
61532: PUSH
61533: LD_INT 2
61535: NEG
61536: PUSH
61537: LD_INT 1
61539: NEG
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: LD_INT 1
61547: NEG
61548: PUSH
61549: LD_INT 3
61551: NEG
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: PUSH
61557: LD_INT 1
61559: PUSH
61560: LD_INT 2
61562: NEG
61563: PUSH
61564: EMPTY
61565: LIST
61566: LIST
61567: PUSH
61568: LD_INT 3
61570: PUSH
61571: LD_INT 2
61573: PUSH
61574: EMPTY
61575: LIST
61576: LIST
61577: PUSH
61578: LD_INT 2
61580: PUSH
61581: LD_INT 3
61583: PUSH
61584: EMPTY
61585: LIST
61586: LIST
61587: PUSH
61588: LD_INT 2
61590: NEG
61591: PUSH
61592: LD_INT 1
61594: PUSH
61595: EMPTY
61596: LIST
61597: LIST
61598: PUSH
61599: LD_INT 3
61601: NEG
61602: PUSH
61603: LD_INT 1
61605: NEG
61606: PUSH
61607: EMPTY
61608: LIST
61609: LIST
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: LIST
61615: LIST
61616: LIST
61617: LIST
61618: LIST
61619: LIST
61620: LIST
61621: LIST
61622: LIST
61623: LIST
61624: LIST
61625: LIST
61626: LIST
61627: LIST
61628: LIST
61629: LIST
61630: LIST
61631: LIST
61632: LIST
61633: LIST
61634: LIST
61635: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
61636: LD_ADDR_VAR 0 33
61640: PUSH
61641: LD_INT 0
61643: PUSH
61644: LD_INT 0
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: PUSH
61651: LD_INT 0
61653: PUSH
61654: LD_INT 1
61656: NEG
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: LD_INT 1
61664: PUSH
61665: LD_INT 0
61667: PUSH
61668: EMPTY
61669: LIST
61670: LIST
61671: PUSH
61672: LD_INT 1
61674: PUSH
61675: LD_INT 1
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: PUSH
61682: LD_INT 0
61684: PUSH
61685: LD_INT 1
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PUSH
61692: LD_INT 1
61694: NEG
61695: PUSH
61696: LD_INT 0
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: LD_INT 1
61705: NEG
61706: PUSH
61707: LD_INT 1
61709: NEG
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: PUSH
61715: LD_INT 1
61717: NEG
61718: PUSH
61719: LD_INT 2
61721: NEG
61722: PUSH
61723: EMPTY
61724: LIST
61725: LIST
61726: PUSH
61727: LD_INT 1
61729: PUSH
61730: LD_INT 1
61732: NEG
61733: PUSH
61734: EMPTY
61735: LIST
61736: LIST
61737: PUSH
61738: LD_INT 2
61740: PUSH
61741: LD_INT 0
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: LD_INT 2
61750: PUSH
61751: LD_INT 1
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PUSH
61758: LD_INT 1
61760: PUSH
61761: LD_INT 2
61763: PUSH
61764: EMPTY
61765: LIST
61766: LIST
61767: PUSH
61768: LD_INT 0
61770: PUSH
61771: LD_INT 2
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: PUSH
61778: LD_INT 1
61780: NEG
61781: PUSH
61782: LD_INT 1
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: PUSH
61789: LD_INT 2
61791: NEG
61792: PUSH
61793: LD_INT 0
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: PUSH
61800: LD_INT 2
61802: NEG
61803: PUSH
61804: LD_INT 1
61806: NEG
61807: PUSH
61808: EMPTY
61809: LIST
61810: LIST
61811: PUSH
61812: LD_INT 2
61814: NEG
61815: PUSH
61816: LD_INT 2
61818: NEG
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: PUSH
61824: LD_INT 2
61826: NEG
61827: PUSH
61828: LD_INT 3
61830: NEG
61831: PUSH
61832: EMPTY
61833: LIST
61834: LIST
61835: PUSH
61836: LD_INT 2
61838: PUSH
61839: LD_INT 1
61841: NEG
61842: PUSH
61843: EMPTY
61844: LIST
61845: LIST
61846: PUSH
61847: LD_INT 3
61849: PUSH
61850: LD_INT 1
61852: PUSH
61853: EMPTY
61854: LIST
61855: LIST
61856: PUSH
61857: LD_INT 1
61859: PUSH
61860: LD_INT 3
61862: PUSH
61863: EMPTY
61864: LIST
61865: LIST
61866: PUSH
61867: LD_INT 1
61869: NEG
61870: PUSH
61871: LD_INT 2
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PUSH
61878: LD_INT 3
61880: NEG
61881: PUSH
61882: LD_INT 2
61884: NEG
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: PUSH
61890: EMPTY
61891: LIST
61892: LIST
61893: LIST
61894: LIST
61895: LIST
61896: LIST
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: LIST
61908: LIST
61909: LIST
61910: LIST
61911: LIST
61912: LIST
61913: LIST
61914: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
61915: LD_ADDR_VAR 0 34
61919: PUSH
61920: LD_INT 0
61922: PUSH
61923: LD_INT 0
61925: PUSH
61926: EMPTY
61927: LIST
61928: LIST
61929: PUSH
61930: LD_INT 0
61932: PUSH
61933: LD_INT 1
61935: NEG
61936: PUSH
61937: EMPTY
61938: LIST
61939: LIST
61940: PUSH
61941: LD_INT 1
61943: PUSH
61944: LD_INT 0
61946: PUSH
61947: EMPTY
61948: LIST
61949: LIST
61950: PUSH
61951: LD_INT 1
61953: PUSH
61954: LD_INT 1
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: PUSH
61961: LD_INT 0
61963: PUSH
61964: LD_INT 1
61966: PUSH
61967: EMPTY
61968: LIST
61969: LIST
61970: PUSH
61971: LD_INT 1
61973: NEG
61974: PUSH
61975: LD_INT 0
61977: PUSH
61978: EMPTY
61979: LIST
61980: LIST
61981: PUSH
61982: LD_INT 1
61984: NEG
61985: PUSH
61986: LD_INT 1
61988: NEG
61989: PUSH
61990: EMPTY
61991: LIST
61992: LIST
61993: PUSH
61994: LD_INT 1
61996: NEG
61997: PUSH
61998: LD_INT 2
62000: NEG
62001: PUSH
62002: EMPTY
62003: LIST
62004: LIST
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: LD_INT 2
62011: NEG
62012: PUSH
62013: EMPTY
62014: LIST
62015: LIST
62016: PUSH
62017: LD_INT 1
62019: PUSH
62020: LD_INT 1
62022: NEG
62023: PUSH
62024: EMPTY
62025: LIST
62026: LIST
62027: PUSH
62028: LD_INT 2
62030: PUSH
62031: LD_INT 1
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 2
62040: PUSH
62041: LD_INT 2
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: LD_INT 1
62050: PUSH
62051: LD_INT 2
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 1
62060: NEG
62061: PUSH
62062: LD_INT 1
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PUSH
62069: LD_INT 2
62071: NEG
62072: PUSH
62073: LD_INT 0
62075: PUSH
62076: EMPTY
62077: LIST
62078: LIST
62079: PUSH
62080: LD_INT 2
62082: NEG
62083: PUSH
62084: LD_INT 1
62086: NEG
62087: PUSH
62088: EMPTY
62089: LIST
62090: LIST
62091: PUSH
62092: LD_INT 2
62094: NEG
62095: PUSH
62096: LD_INT 2
62098: NEG
62099: PUSH
62100: EMPTY
62101: LIST
62102: LIST
62103: PUSH
62104: LD_INT 1
62106: NEG
62107: PUSH
62108: LD_INT 3
62110: NEG
62111: PUSH
62112: EMPTY
62113: LIST
62114: LIST
62115: PUSH
62116: LD_INT 1
62118: PUSH
62119: LD_INT 2
62121: NEG
62122: PUSH
62123: EMPTY
62124: LIST
62125: LIST
62126: PUSH
62127: LD_INT 3
62129: PUSH
62130: LD_INT 2
62132: PUSH
62133: EMPTY
62134: LIST
62135: LIST
62136: PUSH
62137: LD_INT 2
62139: PUSH
62140: LD_INT 3
62142: PUSH
62143: EMPTY
62144: LIST
62145: LIST
62146: PUSH
62147: LD_INT 2
62149: NEG
62150: PUSH
62151: LD_INT 1
62153: PUSH
62154: EMPTY
62155: LIST
62156: LIST
62157: PUSH
62158: LD_INT 3
62160: NEG
62161: PUSH
62162: LD_INT 1
62164: NEG
62165: PUSH
62166: EMPTY
62167: LIST
62168: LIST
62169: PUSH
62170: EMPTY
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: LIST
62184: LIST
62185: LIST
62186: LIST
62187: LIST
62188: LIST
62189: LIST
62190: LIST
62191: LIST
62192: LIST
62193: LIST
62194: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
62195: LD_ADDR_VAR 0 35
62199: PUSH
62200: LD_INT 0
62202: PUSH
62203: LD_INT 0
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: PUSH
62210: LD_INT 0
62212: PUSH
62213: LD_INT 1
62215: NEG
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 1
62223: PUSH
62224: LD_INT 0
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: LD_INT 1
62233: PUSH
62234: LD_INT 1
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: LD_INT 0
62243: PUSH
62244: LD_INT 1
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: LD_INT 1
62253: NEG
62254: PUSH
62255: LD_INT 0
62257: PUSH
62258: EMPTY
62259: LIST
62260: LIST
62261: PUSH
62262: LD_INT 1
62264: NEG
62265: PUSH
62266: LD_INT 1
62268: NEG
62269: PUSH
62270: EMPTY
62271: LIST
62272: LIST
62273: PUSH
62274: LD_INT 2
62276: PUSH
62277: LD_INT 1
62279: PUSH
62280: EMPTY
62281: LIST
62282: LIST
62283: PUSH
62284: LD_INT 2
62286: NEG
62287: PUSH
62288: LD_INT 1
62290: NEG
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: LIST
62305: LIST
62306: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
62307: LD_ADDR_VAR 0 36
62311: PUSH
62312: LD_INT 0
62314: PUSH
62315: LD_INT 0
62317: PUSH
62318: EMPTY
62319: LIST
62320: LIST
62321: PUSH
62322: LD_INT 0
62324: PUSH
62325: LD_INT 1
62327: NEG
62328: PUSH
62329: EMPTY
62330: LIST
62331: LIST
62332: PUSH
62333: LD_INT 1
62335: PUSH
62336: LD_INT 0
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: PUSH
62343: LD_INT 1
62345: PUSH
62346: LD_INT 1
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: PUSH
62353: LD_INT 0
62355: PUSH
62356: LD_INT 1
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PUSH
62363: LD_INT 1
62365: NEG
62366: PUSH
62367: LD_INT 0
62369: PUSH
62370: EMPTY
62371: LIST
62372: LIST
62373: PUSH
62374: LD_INT 1
62376: NEG
62377: PUSH
62378: LD_INT 1
62380: NEG
62381: PUSH
62382: EMPTY
62383: LIST
62384: LIST
62385: PUSH
62386: LD_INT 1
62388: NEG
62389: PUSH
62390: LD_INT 2
62392: NEG
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: PUSH
62398: LD_INT 1
62400: PUSH
62401: LD_INT 2
62403: PUSH
62404: EMPTY
62405: LIST
62406: LIST
62407: PUSH
62408: EMPTY
62409: LIST
62410: LIST
62411: LIST
62412: LIST
62413: LIST
62414: LIST
62415: LIST
62416: LIST
62417: LIST
62418: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
62419: LD_ADDR_VAR 0 37
62423: PUSH
62424: LD_INT 0
62426: PUSH
62427: LD_INT 0
62429: PUSH
62430: EMPTY
62431: LIST
62432: LIST
62433: PUSH
62434: LD_INT 0
62436: PUSH
62437: LD_INT 1
62439: NEG
62440: PUSH
62441: EMPTY
62442: LIST
62443: LIST
62444: PUSH
62445: LD_INT 1
62447: PUSH
62448: LD_INT 0
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: PUSH
62455: LD_INT 1
62457: PUSH
62458: LD_INT 1
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: PUSH
62465: LD_INT 0
62467: PUSH
62468: LD_INT 1
62470: PUSH
62471: EMPTY
62472: LIST
62473: LIST
62474: PUSH
62475: LD_INT 1
62477: NEG
62478: PUSH
62479: LD_INT 0
62481: PUSH
62482: EMPTY
62483: LIST
62484: LIST
62485: PUSH
62486: LD_INT 1
62488: NEG
62489: PUSH
62490: LD_INT 1
62492: NEG
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 1
62500: PUSH
62501: LD_INT 1
62503: NEG
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 1
62511: NEG
62512: PUSH
62513: LD_INT 1
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: LIST
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: LIST
62529: LIST
62530: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
62531: LD_ADDR_VAR 0 38
62535: PUSH
62536: LD_INT 0
62538: PUSH
62539: LD_INT 0
62541: PUSH
62542: EMPTY
62543: LIST
62544: LIST
62545: PUSH
62546: LD_INT 0
62548: PUSH
62549: LD_INT 1
62551: NEG
62552: PUSH
62553: EMPTY
62554: LIST
62555: LIST
62556: PUSH
62557: LD_INT 1
62559: PUSH
62560: LD_INT 0
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: PUSH
62567: LD_INT 1
62569: PUSH
62570: LD_INT 1
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: PUSH
62577: LD_INT 0
62579: PUSH
62580: LD_INT 1
62582: PUSH
62583: EMPTY
62584: LIST
62585: LIST
62586: PUSH
62587: LD_INT 1
62589: NEG
62590: PUSH
62591: LD_INT 0
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PUSH
62598: LD_INT 1
62600: NEG
62601: PUSH
62602: LD_INT 1
62604: NEG
62605: PUSH
62606: EMPTY
62607: LIST
62608: LIST
62609: PUSH
62610: LD_INT 2
62612: PUSH
62613: LD_INT 1
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PUSH
62620: LD_INT 2
62622: NEG
62623: PUSH
62624: LD_INT 1
62626: NEG
62627: PUSH
62628: EMPTY
62629: LIST
62630: LIST
62631: PUSH
62632: EMPTY
62633: LIST
62634: LIST
62635: LIST
62636: LIST
62637: LIST
62638: LIST
62639: LIST
62640: LIST
62641: LIST
62642: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
62643: LD_ADDR_VAR 0 39
62647: PUSH
62648: LD_INT 0
62650: PUSH
62651: LD_INT 0
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PUSH
62658: LD_INT 0
62660: PUSH
62661: LD_INT 1
62663: NEG
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 1
62671: PUSH
62672: LD_INT 0
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: LD_INT 1
62681: PUSH
62682: LD_INT 1
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 0
62691: PUSH
62692: LD_INT 1
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 1
62701: NEG
62702: PUSH
62703: LD_INT 0
62705: PUSH
62706: EMPTY
62707: LIST
62708: LIST
62709: PUSH
62710: LD_INT 1
62712: NEG
62713: PUSH
62714: LD_INT 1
62716: NEG
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: PUSH
62722: LD_INT 1
62724: NEG
62725: PUSH
62726: LD_INT 2
62728: NEG
62729: PUSH
62730: EMPTY
62731: LIST
62732: LIST
62733: PUSH
62734: LD_INT 1
62736: PUSH
62737: LD_INT 2
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: PUSH
62744: EMPTY
62745: LIST
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
62755: LD_ADDR_VAR 0 40
62759: PUSH
62760: LD_INT 0
62762: PUSH
62763: LD_INT 0
62765: PUSH
62766: EMPTY
62767: LIST
62768: LIST
62769: PUSH
62770: LD_INT 0
62772: PUSH
62773: LD_INT 1
62775: NEG
62776: PUSH
62777: EMPTY
62778: LIST
62779: LIST
62780: PUSH
62781: LD_INT 1
62783: PUSH
62784: LD_INT 0
62786: PUSH
62787: EMPTY
62788: LIST
62789: LIST
62790: PUSH
62791: LD_INT 1
62793: PUSH
62794: LD_INT 1
62796: PUSH
62797: EMPTY
62798: LIST
62799: LIST
62800: PUSH
62801: LD_INT 0
62803: PUSH
62804: LD_INT 1
62806: PUSH
62807: EMPTY
62808: LIST
62809: LIST
62810: PUSH
62811: LD_INT 1
62813: NEG
62814: PUSH
62815: LD_INT 0
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: LD_INT 1
62824: NEG
62825: PUSH
62826: LD_INT 1
62828: NEG
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: PUSH
62834: LD_INT 1
62836: PUSH
62837: LD_INT 1
62839: NEG
62840: PUSH
62841: EMPTY
62842: LIST
62843: LIST
62844: PUSH
62845: LD_INT 1
62847: NEG
62848: PUSH
62849: LD_INT 1
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: LIST
62860: LIST
62861: LIST
62862: LIST
62863: LIST
62864: LIST
62865: LIST
62866: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62867: LD_ADDR_VAR 0 41
62871: PUSH
62872: LD_INT 0
62874: PUSH
62875: LD_INT 0
62877: PUSH
62878: EMPTY
62879: LIST
62880: LIST
62881: PUSH
62882: LD_INT 0
62884: PUSH
62885: LD_INT 1
62887: NEG
62888: PUSH
62889: EMPTY
62890: LIST
62891: LIST
62892: PUSH
62893: LD_INT 1
62895: PUSH
62896: LD_INT 0
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: PUSH
62903: LD_INT 1
62905: PUSH
62906: LD_INT 1
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: PUSH
62913: LD_INT 0
62915: PUSH
62916: LD_INT 1
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: PUSH
62923: LD_INT 1
62925: NEG
62926: PUSH
62927: LD_INT 0
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: PUSH
62934: LD_INT 1
62936: NEG
62937: PUSH
62938: LD_INT 1
62940: NEG
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: LD_INT 1
62948: NEG
62949: PUSH
62950: LD_INT 2
62952: NEG
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: PUSH
62958: LD_INT 1
62960: PUSH
62961: LD_INT 1
62963: NEG
62964: PUSH
62965: EMPTY
62966: LIST
62967: LIST
62968: PUSH
62969: LD_INT 2
62971: PUSH
62972: LD_INT 0
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: PUSH
62979: LD_INT 2
62981: PUSH
62982: LD_INT 1
62984: PUSH
62985: EMPTY
62986: LIST
62987: LIST
62988: PUSH
62989: LD_INT 2
62991: PUSH
62992: LD_INT 2
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: LD_INT 1
63001: PUSH
63002: LD_INT 2
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: LD_INT 1
63011: NEG
63012: PUSH
63013: LD_INT 1
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: PUSH
63020: LD_INT 2
63022: NEG
63023: PUSH
63024: LD_INT 0
63026: PUSH
63027: EMPTY
63028: LIST
63029: LIST
63030: PUSH
63031: LD_INT 2
63033: NEG
63034: PUSH
63035: LD_INT 1
63037: NEG
63038: PUSH
63039: EMPTY
63040: LIST
63041: LIST
63042: PUSH
63043: LD_INT 2
63045: NEG
63046: PUSH
63047: LD_INT 2
63049: NEG
63050: PUSH
63051: EMPTY
63052: LIST
63053: LIST
63054: PUSH
63055: LD_INT 2
63057: NEG
63058: PUSH
63059: LD_INT 3
63061: NEG
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: PUSH
63067: LD_INT 2
63069: PUSH
63070: LD_INT 1
63072: NEG
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: LD_INT 3
63080: PUSH
63081: LD_INT 0
63083: PUSH
63084: EMPTY
63085: LIST
63086: LIST
63087: PUSH
63088: LD_INT 3
63090: PUSH
63091: LD_INT 1
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: LD_INT 3
63100: PUSH
63101: LD_INT 2
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 3
63110: PUSH
63111: LD_INT 3
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 2
63120: PUSH
63121: LD_INT 3
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 2
63130: NEG
63131: PUSH
63132: LD_INT 1
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: LD_INT 3
63141: NEG
63142: PUSH
63143: LD_INT 0
63145: PUSH
63146: EMPTY
63147: LIST
63148: LIST
63149: PUSH
63150: LD_INT 3
63152: NEG
63153: PUSH
63154: LD_INT 1
63156: NEG
63157: PUSH
63158: EMPTY
63159: LIST
63160: LIST
63161: PUSH
63162: LD_INT 3
63164: NEG
63165: PUSH
63166: LD_INT 2
63168: NEG
63169: PUSH
63170: EMPTY
63171: LIST
63172: LIST
63173: PUSH
63174: LD_INT 3
63176: NEG
63177: PUSH
63178: LD_INT 3
63180: NEG
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: LIST
63190: LIST
63191: LIST
63192: LIST
63193: LIST
63194: LIST
63195: LIST
63196: LIST
63197: LIST
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63217: LD_ADDR_VAR 0 42
63221: PUSH
63222: LD_INT 0
63224: PUSH
63225: LD_INT 0
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: PUSH
63232: LD_INT 0
63234: PUSH
63235: LD_INT 1
63237: NEG
63238: PUSH
63239: EMPTY
63240: LIST
63241: LIST
63242: PUSH
63243: LD_INT 1
63245: PUSH
63246: LD_INT 0
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: PUSH
63253: LD_INT 1
63255: PUSH
63256: LD_INT 1
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: LD_INT 0
63265: PUSH
63266: LD_INT 1
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PUSH
63273: LD_INT 1
63275: NEG
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 1
63286: NEG
63287: PUSH
63288: LD_INT 1
63290: NEG
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 1
63298: NEG
63299: PUSH
63300: LD_INT 2
63302: NEG
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 0
63310: PUSH
63311: LD_INT 2
63313: NEG
63314: PUSH
63315: EMPTY
63316: LIST
63317: LIST
63318: PUSH
63319: LD_INT 1
63321: PUSH
63322: LD_INT 1
63324: NEG
63325: PUSH
63326: EMPTY
63327: LIST
63328: LIST
63329: PUSH
63330: LD_INT 2
63332: PUSH
63333: LD_INT 1
63335: PUSH
63336: EMPTY
63337: LIST
63338: LIST
63339: PUSH
63340: LD_INT 2
63342: PUSH
63343: LD_INT 2
63345: PUSH
63346: EMPTY
63347: LIST
63348: LIST
63349: PUSH
63350: LD_INT 1
63352: PUSH
63353: LD_INT 2
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: PUSH
63360: LD_INT 0
63362: PUSH
63363: LD_INT 2
63365: PUSH
63366: EMPTY
63367: LIST
63368: LIST
63369: PUSH
63370: LD_INT 1
63372: NEG
63373: PUSH
63374: LD_INT 1
63376: PUSH
63377: EMPTY
63378: LIST
63379: LIST
63380: PUSH
63381: LD_INT 2
63383: NEG
63384: PUSH
63385: LD_INT 1
63387: NEG
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PUSH
63393: LD_INT 2
63395: NEG
63396: PUSH
63397: LD_INT 2
63399: NEG
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PUSH
63405: LD_INT 2
63407: NEG
63408: PUSH
63409: LD_INT 3
63411: NEG
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_INT 1
63419: NEG
63420: PUSH
63421: LD_INT 3
63423: NEG
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: PUSH
63429: LD_INT 0
63431: PUSH
63432: LD_INT 3
63434: NEG
63435: PUSH
63436: EMPTY
63437: LIST
63438: LIST
63439: PUSH
63440: LD_INT 1
63442: PUSH
63443: LD_INT 2
63445: NEG
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: PUSH
63451: LD_INT 3
63453: PUSH
63454: LD_INT 2
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: PUSH
63461: LD_INT 3
63463: PUSH
63464: LD_INT 3
63466: PUSH
63467: EMPTY
63468: LIST
63469: LIST
63470: PUSH
63471: LD_INT 2
63473: PUSH
63474: LD_INT 3
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: LD_INT 1
63483: PUSH
63484: LD_INT 3
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 0
63493: PUSH
63494: LD_INT 3
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: LD_INT 2
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 3
63514: NEG
63515: PUSH
63516: LD_INT 2
63518: NEG
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 3
63526: NEG
63527: PUSH
63528: LD_INT 3
63530: NEG
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: LIST
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: LIST
63564: LIST
63565: LIST
63566: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63567: LD_ADDR_VAR 0 43
63571: PUSH
63572: LD_INT 0
63574: PUSH
63575: LD_INT 0
63577: PUSH
63578: EMPTY
63579: LIST
63580: LIST
63581: PUSH
63582: LD_INT 0
63584: PUSH
63585: LD_INT 1
63587: NEG
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: PUSH
63593: LD_INT 1
63595: PUSH
63596: LD_INT 0
63598: PUSH
63599: EMPTY
63600: LIST
63601: LIST
63602: PUSH
63603: LD_INT 1
63605: PUSH
63606: LD_INT 1
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: PUSH
63613: LD_INT 0
63615: PUSH
63616: LD_INT 1
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PUSH
63623: LD_INT 1
63625: NEG
63626: PUSH
63627: LD_INT 0
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: PUSH
63634: LD_INT 1
63636: NEG
63637: PUSH
63638: LD_INT 1
63640: NEG
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: LD_INT 1
63648: NEG
63649: PUSH
63650: LD_INT 2
63652: NEG
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PUSH
63658: LD_INT 0
63660: PUSH
63661: LD_INT 2
63663: NEG
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: PUSH
63669: LD_INT 1
63671: PUSH
63672: LD_INT 1
63674: NEG
63675: PUSH
63676: EMPTY
63677: LIST
63678: LIST
63679: PUSH
63680: LD_INT 2
63682: PUSH
63683: LD_INT 0
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: LD_INT 2
63692: PUSH
63693: LD_INT 1
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 1
63702: PUSH
63703: LD_INT 2
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 0
63712: PUSH
63713: LD_INT 2
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: NEG
63723: PUSH
63724: LD_INT 1
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 2
63733: NEG
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 2
63744: NEG
63745: PUSH
63746: LD_INT 1
63748: NEG
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PUSH
63754: LD_INT 1
63756: NEG
63757: PUSH
63758: LD_INT 3
63760: NEG
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 0
63768: PUSH
63769: LD_INT 3
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: LD_INT 2
63782: NEG
63783: PUSH
63784: EMPTY
63785: LIST
63786: LIST
63787: PUSH
63788: LD_INT 2
63790: PUSH
63791: LD_INT 1
63793: NEG
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PUSH
63799: LD_INT 3
63801: PUSH
63802: LD_INT 0
63804: PUSH
63805: EMPTY
63806: LIST
63807: LIST
63808: PUSH
63809: LD_INT 3
63811: PUSH
63812: LD_INT 1
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 1
63821: PUSH
63822: LD_INT 3
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 0
63831: PUSH
63832: LD_INT 3
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: NEG
63842: PUSH
63843: LD_INT 2
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: LD_INT 2
63852: NEG
63853: PUSH
63854: LD_INT 1
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 3
63863: NEG
63864: PUSH
63865: LD_INT 0
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PUSH
63872: LD_INT 3
63874: NEG
63875: PUSH
63876: LD_INT 1
63878: NEG
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63915: LD_ADDR_VAR 0 44
63919: PUSH
63920: LD_INT 0
63922: PUSH
63923: LD_INT 0
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: PUSH
63930: LD_INT 0
63932: PUSH
63933: LD_INT 1
63935: NEG
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 1
63943: PUSH
63944: LD_INT 0
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 1
63953: PUSH
63954: LD_INT 1
63956: PUSH
63957: EMPTY
63958: LIST
63959: LIST
63960: PUSH
63961: LD_INT 0
63963: PUSH
63964: LD_INT 1
63966: PUSH
63967: EMPTY
63968: LIST
63969: LIST
63970: PUSH
63971: LD_INT 1
63973: NEG
63974: PUSH
63975: LD_INT 0
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: PUSH
63982: LD_INT 1
63984: NEG
63985: PUSH
63986: LD_INT 1
63988: NEG
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: PUSH
63994: LD_INT 1
63996: NEG
63997: PUSH
63998: LD_INT 2
64000: NEG
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 1
64008: PUSH
64009: LD_INT 1
64011: NEG
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 2
64019: PUSH
64020: LD_INT 0
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 2
64029: PUSH
64030: LD_INT 1
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 2
64039: PUSH
64040: LD_INT 2
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: PUSH
64047: LD_INT 1
64049: PUSH
64050: LD_INT 2
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: LD_INT 1
64059: NEG
64060: PUSH
64061: LD_INT 1
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 2
64070: NEG
64071: PUSH
64072: LD_INT 0
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 2
64081: NEG
64082: PUSH
64083: LD_INT 1
64085: NEG
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: PUSH
64091: LD_INT 2
64093: NEG
64094: PUSH
64095: LD_INT 2
64097: NEG
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: PUSH
64103: LD_INT 2
64105: NEG
64106: PUSH
64107: LD_INT 3
64109: NEG
64110: PUSH
64111: EMPTY
64112: LIST
64113: LIST
64114: PUSH
64115: LD_INT 2
64117: PUSH
64118: LD_INT 1
64120: NEG
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: PUSH
64126: LD_INT 3
64128: PUSH
64129: LD_INT 0
64131: PUSH
64132: EMPTY
64133: LIST
64134: LIST
64135: PUSH
64136: LD_INT 3
64138: PUSH
64139: LD_INT 1
64141: PUSH
64142: EMPTY
64143: LIST
64144: LIST
64145: PUSH
64146: LD_INT 3
64148: PUSH
64149: LD_INT 2
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: PUSH
64156: LD_INT 3
64158: PUSH
64159: LD_INT 3
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 2
64168: PUSH
64169: LD_INT 3
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 2
64178: NEG
64179: PUSH
64180: LD_INT 1
64182: PUSH
64183: EMPTY
64184: LIST
64185: LIST
64186: PUSH
64187: LD_INT 3
64189: NEG
64190: PUSH
64191: LD_INT 0
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 3
64200: NEG
64201: PUSH
64202: LD_INT 1
64204: NEG
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 3
64212: NEG
64213: PUSH
64214: LD_INT 2
64216: NEG
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: PUSH
64222: LD_INT 3
64224: NEG
64225: PUSH
64226: LD_INT 3
64228: NEG
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: LIST
64256: LIST
64257: LIST
64258: LIST
64259: LIST
64260: LIST
64261: LIST
64262: LIST
64263: LIST
64264: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64265: LD_ADDR_VAR 0 45
64269: PUSH
64270: LD_INT 0
64272: PUSH
64273: LD_INT 0
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: LD_INT 0
64282: PUSH
64283: LD_INT 1
64285: NEG
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: PUSH
64291: LD_INT 1
64293: PUSH
64294: LD_INT 0
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: LD_INT 1
64303: PUSH
64304: LD_INT 1
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 0
64313: PUSH
64314: LD_INT 1
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: LD_INT 1
64323: NEG
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 1
64334: NEG
64335: PUSH
64336: LD_INT 1
64338: NEG
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: LD_INT 1
64346: NEG
64347: PUSH
64348: LD_INT 2
64350: NEG
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 0
64358: PUSH
64359: LD_INT 2
64361: NEG
64362: PUSH
64363: EMPTY
64364: LIST
64365: LIST
64366: PUSH
64367: LD_INT 1
64369: PUSH
64370: LD_INT 1
64372: NEG
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PUSH
64378: LD_INT 2
64380: PUSH
64381: LD_INT 1
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 2
64390: PUSH
64391: LD_INT 2
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PUSH
64398: LD_INT 1
64400: PUSH
64401: LD_INT 2
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: PUSH
64408: LD_INT 0
64410: PUSH
64411: LD_INT 2
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 1
64420: NEG
64421: PUSH
64422: LD_INT 1
64424: PUSH
64425: EMPTY
64426: LIST
64427: LIST
64428: PUSH
64429: LD_INT 2
64431: NEG
64432: PUSH
64433: LD_INT 1
64435: NEG
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 2
64443: NEG
64444: PUSH
64445: LD_INT 2
64447: NEG
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 2
64455: NEG
64456: PUSH
64457: LD_INT 3
64459: NEG
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 1
64467: NEG
64468: PUSH
64469: LD_INT 3
64471: NEG
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PUSH
64477: LD_INT 0
64479: PUSH
64480: LD_INT 3
64482: NEG
64483: PUSH
64484: EMPTY
64485: LIST
64486: LIST
64487: PUSH
64488: LD_INT 1
64490: PUSH
64491: LD_INT 2
64493: NEG
64494: PUSH
64495: EMPTY
64496: LIST
64497: LIST
64498: PUSH
64499: LD_INT 3
64501: PUSH
64502: LD_INT 2
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 3
64511: PUSH
64512: LD_INT 3
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 2
64521: PUSH
64522: LD_INT 3
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PUSH
64529: LD_INT 1
64531: PUSH
64532: LD_INT 3
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 0
64541: PUSH
64542: LD_INT 3
64544: PUSH
64545: EMPTY
64546: LIST
64547: LIST
64548: PUSH
64549: LD_INT 1
64551: NEG
64552: PUSH
64553: LD_INT 2
64555: PUSH
64556: EMPTY
64557: LIST
64558: LIST
64559: PUSH
64560: LD_INT 3
64562: NEG
64563: PUSH
64564: LD_INT 2
64566: NEG
64567: PUSH
64568: EMPTY
64569: LIST
64570: LIST
64571: PUSH
64572: LD_INT 3
64574: NEG
64575: PUSH
64576: LD_INT 3
64578: NEG
64579: PUSH
64580: EMPTY
64581: LIST
64582: LIST
64583: PUSH
64584: EMPTY
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64615: LD_ADDR_VAR 0 46
64619: PUSH
64620: LD_INT 0
64622: PUSH
64623: LD_INT 0
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: PUSH
64630: LD_INT 0
64632: PUSH
64633: LD_INT 1
64635: NEG
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 1
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 1
64653: PUSH
64654: LD_INT 1
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 0
64663: PUSH
64664: LD_INT 1
64666: PUSH
64667: EMPTY
64668: LIST
64669: LIST
64670: PUSH
64671: LD_INT 1
64673: NEG
64674: PUSH
64675: LD_INT 0
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 1
64684: NEG
64685: PUSH
64686: LD_INT 1
64688: NEG
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: PUSH
64694: LD_INT 1
64696: NEG
64697: PUSH
64698: LD_INT 2
64700: NEG
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: LD_INT 2
64711: NEG
64712: PUSH
64713: EMPTY
64714: LIST
64715: LIST
64716: PUSH
64717: LD_INT 1
64719: PUSH
64720: LD_INT 1
64722: NEG
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PUSH
64728: LD_INT 2
64730: PUSH
64731: LD_INT 0
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 2
64740: PUSH
64741: LD_INT 1
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 1
64750: PUSH
64751: LD_INT 2
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: LD_INT 0
64760: PUSH
64761: LD_INT 2
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 1
64770: NEG
64771: PUSH
64772: LD_INT 1
64774: PUSH
64775: EMPTY
64776: LIST
64777: LIST
64778: PUSH
64779: LD_INT 2
64781: NEG
64782: PUSH
64783: LD_INT 0
64785: PUSH
64786: EMPTY
64787: LIST
64788: LIST
64789: PUSH
64790: LD_INT 2
64792: NEG
64793: PUSH
64794: LD_INT 1
64796: NEG
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: PUSH
64802: LD_INT 1
64804: NEG
64805: PUSH
64806: LD_INT 3
64808: NEG
64809: PUSH
64810: EMPTY
64811: LIST
64812: LIST
64813: PUSH
64814: LD_INT 0
64816: PUSH
64817: LD_INT 3
64819: NEG
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: PUSH
64825: LD_INT 1
64827: PUSH
64828: LD_INT 2
64830: NEG
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 2
64838: PUSH
64839: LD_INT 1
64841: NEG
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 3
64849: PUSH
64850: LD_INT 0
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 3
64859: PUSH
64860: LD_INT 1
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 1
64869: PUSH
64870: LD_INT 3
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PUSH
64877: LD_INT 0
64879: PUSH
64880: LD_INT 3
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 1
64889: NEG
64890: PUSH
64891: LD_INT 2
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: LD_INT 2
64900: NEG
64901: PUSH
64902: LD_INT 1
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: PUSH
64909: LD_INT 3
64911: NEG
64912: PUSH
64913: LD_INT 0
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PUSH
64920: LD_INT 3
64922: NEG
64923: PUSH
64924: LD_INT 1
64926: NEG
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: LIST
64948: LIST
64949: LIST
64950: LIST
64951: LIST
64952: LIST
64953: LIST
64954: LIST
64955: LIST
64956: LIST
64957: LIST
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64963: LD_ADDR_VAR 0 47
64967: PUSH
64968: LD_INT 0
64970: PUSH
64971: LD_INT 0
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 0
64980: PUSH
64981: LD_INT 1
64983: NEG
64984: PUSH
64985: EMPTY
64986: LIST
64987: LIST
64988: PUSH
64989: LD_INT 1
64991: PUSH
64992: LD_INT 0
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 1
65001: PUSH
65002: LD_INT 1
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PUSH
65009: LD_INT 0
65011: PUSH
65012: LD_INT 1
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: LD_INT 1
65021: NEG
65022: PUSH
65023: LD_INT 0
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 1
65032: NEG
65033: PUSH
65034: LD_INT 1
65036: NEG
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 1
65044: NEG
65045: PUSH
65046: LD_INT 2
65048: NEG
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 0
65056: PUSH
65057: LD_INT 2
65059: NEG
65060: PUSH
65061: EMPTY
65062: LIST
65063: LIST
65064: PUSH
65065: LD_INT 1
65067: PUSH
65068: LD_INT 1
65070: NEG
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: PUSH
65076: LD_INT 2
65078: NEG
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 2
65090: NEG
65091: PUSH
65092: LD_INT 2
65094: NEG
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: LIST
65104: LIST
65105: LIST
65106: LIST
65107: LIST
65108: LIST
65109: LIST
65110: LIST
65111: LIST
65112: LIST
65113: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
65114: LD_ADDR_VAR 0 48
65118: PUSH
65119: LD_INT 0
65121: PUSH
65122: LD_INT 0
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: LD_INT 1
65134: NEG
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: PUSH
65140: LD_INT 1
65142: PUSH
65143: LD_INT 0
65145: PUSH
65146: EMPTY
65147: LIST
65148: LIST
65149: PUSH
65150: LD_INT 1
65152: PUSH
65153: LD_INT 1
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: LD_INT 0
65162: PUSH
65163: LD_INT 1
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PUSH
65170: LD_INT 1
65172: NEG
65173: PUSH
65174: LD_INT 0
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PUSH
65181: LD_INT 1
65183: NEG
65184: PUSH
65185: LD_INT 1
65187: NEG
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 1
65195: NEG
65196: PUSH
65197: LD_INT 2
65199: NEG
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: LD_INT 0
65207: PUSH
65208: LD_INT 2
65210: NEG
65211: PUSH
65212: EMPTY
65213: LIST
65214: LIST
65215: PUSH
65216: LD_INT 1
65218: PUSH
65219: LD_INT 1
65221: NEG
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 2
65229: PUSH
65230: LD_INT 0
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 2
65239: PUSH
65240: LD_INT 1
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: PUSH
65247: EMPTY
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
65261: LD_ADDR_VAR 0 49
65265: PUSH
65266: LD_INT 0
65268: PUSH
65269: LD_INT 0
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 0
65278: PUSH
65279: LD_INT 1
65281: NEG
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 1
65289: PUSH
65290: LD_INT 0
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 1
65299: PUSH
65300: LD_INT 1
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: LD_INT 1
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 1
65319: NEG
65320: PUSH
65321: LD_INT 0
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 1
65330: NEG
65331: PUSH
65332: LD_INT 1
65334: NEG
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: PUSH
65340: LD_INT 1
65342: PUSH
65343: LD_INT 1
65345: NEG
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 2
65353: PUSH
65354: LD_INT 0
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 2
65363: PUSH
65364: LD_INT 1
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 2
65373: PUSH
65374: LD_INT 2
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 1
65383: PUSH
65384: LD_INT 2
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: EMPTY
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
65405: LD_ADDR_VAR 0 50
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: LD_INT 0
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: LD_INT 0
65422: PUSH
65423: LD_INT 1
65425: NEG
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: LD_INT 1
65433: PUSH
65434: LD_INT 0
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: PUSH
65441: LD_INT 1
65443: PUSH
65444: LD_INT 1
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 0
65453: PUSH
65454: LD_INT 1
65456: PUSH
65457: EMPTY
65458: LIST
65459: LIST
65460: PUSH
65461: LD_INT 1
65463: NEG
65464: PUSH
65465: LD_INT 0
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: LD_INT 1
65474: NEG
65475: PUSH
65476: LD_INT 1
65478: NEG
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 2
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 2
65496: PUSH
65497: LD_INT 2
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 1
65506: PUSH
65507: LD_INT 2
65509: PUSH
65510: EMPTY
65511: LIST
65512: LIST
65513: PUSH
65514: LD_INT 0
65516: PUSH
65517: LD_INT 2
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 1
65526: NEG
65527: PUSH
65528: LD_INT 1
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: LIST
65548: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
65549: LD_ADDR_VAR 0 51
65553: PUSH
65554: LD_INT 0
65556: PUSH
65557: LD_INT 0
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: PUSH
65564: LD_INT 0
65566: PUSH
65567: LD_INT 1
65569: NEG
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: LD_INT 0
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: LD_INT 1
65587: PUSH
65588: LD_INT 1
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: LD_INT 0
65597: PUSH
65598: LD_INT 1
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 1
65607: NEG
65608: PUSH
65609: LD_INT 0
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 1
65618: NEG
65619: PUSH
65620: LD_INT 1
65622: NEG
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 1
65630: PUSH
65631: LD_INT 2
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: LD_INT 0
65640: PUSH
65641: LD_INT 2
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 1
65650: NEG
65651: PUSH
65652: LD_INT 1
65654: PUSH
65655: EMPTY
65656: LIST
65657: LIST
65658: PUSH
65659: LD_INT 2
65661: NEG
65662: PUSH
65663: LD_INT 0
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 2
65672: NEG
65673: PUSH
65674: LD_INT 1
65676: NEG
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65696: LD_ADDR_VAR 0 52
65700: PUSH
65701: LD_INT 0
65703: PUSH
65704: LD_INT 0
65706: PUSH
65707: EMPTY
65708: LIST
65709: LIST
65710: PUSH
65711: LD_INT 0
65713: PUSH
65714: LD_INT 1
65716: NEG
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: LD_INT 1
65724: PUSH
65725: LD_INT 0
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 1
65734: PUSH
65735: LD_INT 1
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 0
65744: PUSH
65745: LD_INT 1
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 1
65754: NEG
65755: PUSH
65756: LD_INT 0
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: PUSH
65763: LD_INT 1
65765: NEG
65766: PUSH
65767: LD_INT 1
65769: NEG
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 1
65777: NEG
65778: PUSH
65779: LD_INT 2
65781: NEG
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 1
65789: NEG
65790: PUSH
65791: LD_INT 1
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 2
65800: NEG
65801: PUSH
65802: LD_INT 0
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: PUSH
65809: LD_INT 2
65811: NEG
65812: PUSH
65813: LD_INT 1
65815: NEG
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 2
65823: NEG
65824: PUSH
65825: LD_INT 2
65827: NEG
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65847: LD_ADDR_VAR 0 53
65851: PUSH
65852: LD_INT 0
65854: PUSH
65855: LD_INT 0
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 0
65864: PUSH
65865: LD_INT 1
65867: NEG
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 1
65875: PUSH
65876: LD_INT 0
65878: PUSH
65879: EMPTY
65880: LIST
65881: LIST
65882: PUSH
65883: LD_INT 1
65885: PUSH
65886: LD_INT 1
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: PUSH
65893: LD_INT 0
65895: PUSH
65896: LD_INT 1
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 1
65905: NEG
65906: PUSH
65907: LD_INT 0
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: PUSH
65914: LD_INT 1
65916: NEG
65917: PUSH
65918: LD_INT 1
65920: NEG
65921: PUSH
65922: EMPTY
65923: LIST
65924: LIST
65925: PUSH
65926: LD_INT 1
65928: NEG
65929: PUSH
65930: LD_INT 2
65932: NEG
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: LD_INT 2
65943: NEG
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PUSH
65949: LD_INT 1
65951: PUSH
65952: LD_INT 1
65954: NEG
65955: PUSH
65956: EMPTY
65957: LIST
65958: LIST
65959: PUSH
65960: LD_INT 2
65962: PUSH
65963: LD_INT 0
65965: PUSH
65966: EMPTY
65967: LIST
65968: LIST
65969: PUSH
65970: LD_INT 2
65972: PUSH
65973: LD_INT 1
65975: PUSH
65976: EMPTY
65977: LIST
65978: LIST
65979: PUSH
65980: LD_INT 2
65982: PUSH
65983: LD_INT 2
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: PUSH
65990: LD_INT 1
65992: PUSH
65993: LD_INT 2
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: LD_INT 0
66002: PUSH
66003: LD_INT 2
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 1
66012: NEG
66013: PUSH
66014: LD_INT 1
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 2
66023: NEG
66024: PUSH
66025: LD_INT 0
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: LD_INT 2
66034: NEG
66035: PUSH
66036: LD_INT 1
66038: NEG
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 2
66046: NEG
66047: PUSH
66048: LD_INT 2
66050: NEG
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66077: LD_ADDR_VAR 0 54
66081: PUSH
66082: LD_INT 0
66084: PUSH
66085: LD_INT 0
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 0
66094: PUSH
66095: LD_INT 1
66097: NEG
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 1
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 1
66115: PUSH
66116: LD_INT 1
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 0
66125: PUSH
66126: LD_INT 1
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 1
66135: NEG
66136: PUSH
66137: LD_INT 0
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 1
66146: NEG
66147: PUSH
66148: LD_INT 1
66150: NEG
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: PUSH
66156: LD_INT 1
66158: NEG
66159: PUSH
66160: LD_INT 2
66162: NEG
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 0
66170: PUSH
66171: LD_INT 2
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: LD_INT 1
66184: NEG
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: PUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 0
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 2
66202: PUSH
66203: LD_INT 1
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: PUSH
66210: LD_INT 2
66212: PUSH
66213: LD_INT 2
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 1
66222: PUSH
66223: LD_INT 2
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 0
66232: PUSH
66233: LD_INT 2
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 1
66242: NEG
66243: PUSH
66244: LD_INT 1
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 2
66253: NEG
66254: PUSH
66255: LD_INT 0
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PUSH
66262: LD_INT 2
66264: NEG
66265: PUSH
66266: LD_INT 1
66268: NEG
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: LD_INT 2
66276: NEG
66277: PUSH
66278: LD_INT 2
66280: NEG
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66307: LD_ADDR_VAR 0 55
66311: PUSH
66312: LD_INT 0
66314: PUSH
66315: LD_INT 0
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: PUSH
66322: LD_INT 0
66324: PUSH
66325: LD_INT 1
66327: NEG
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: LD_INT 1
66335: PUSH
66336: LD_INT 0
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 1
66345: PUSH
66346: LD_INT 1
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 1
66365: NEG
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: PUSH
66374: LD_INT 1
66376: NEG
66377: PUSH
66378: LD_INT 1
66380: NEG
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 1
66388: NEG
66389: PUSH
66390: LD_INT 2
66392: NEG
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 0
66400: PUSH
66401: LD_INT 2
66403: NEG
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 1
66411: PUSH
66412: LD_INT 1
66414: NEG
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 2
66422: PUSH
66423: LD_INT 0
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 2
66432: PUSH
66433: LD_INT 1
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: LD_INT 2
66442: PUSH
66443: LD_INT 2
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: PUSH
66450: LD_INT 1
66452: PUSH
66453: LD_INT 2
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 0
66462: PUSH
66463: LD_INT 2
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: LD_INT 1
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 2
66483: NEG
66484: PUSH
66485: LD_INT 0
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 2
66494: NEG
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 2
66506: NEG
66507: PUSH
66508: LD_INT 2
66510: NEG
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66537: LD_ADDR_VAR 0 56
66541: PUSH
66542: LD_INT 0
66544: PUSH
66545: LD_INT 0
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 0
66554: PUSH
66555: LD_INT 1
66557: NEG
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 1
66575: PUSH
66576: LD_INT 1
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 0
66585: PUSH
66586: LD_INT 1
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: NEG
66607: PUSH
66608: LD_INT 1
66610: NEG
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: NEG
66619: PUSH
66620: LD_INT 2
66622: NEG
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: LD_INT 2
66633: NEG
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: PUSH
66639: LD_INT 1
66641: PUSH
66642: LD_INT 1
66644: NEG
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 2
66652: PUSH
66653: LD_INT 0
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 2
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 2
66672: PUSH
66673: LD_INT 2
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 1
66682: PUSH
66683: LD_INT 2
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: LD_INT 0
66692: PUSH
66693: LD_INT 2
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: PUSH
66704: LD_INT 1
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: NEG
66714: PUSH
66715: LD_INT 0
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: LD_INT 2
66724: NEG
66725: PUSH
66726: LD_INT 1
66728: NEG
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 2
66736: NEG
66737: PUSH
66738: LD_INT 2
66740: NEG
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66767: LD_ADDR_VAR 0 57
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: LD_INT 1
66787: NEG
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: LD_INT 0
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 0
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: NEG
66837: PUSH
66838: LD_INT 1
66840: NEG
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: LD_INT 2
66852: NEG
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 0
66860: PUSH
66861: LD_INT 2
66863: NEG
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 1
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: PUSH
66880: LD_INT 2
66882: PUSH
66883: LD_INT 0
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 2
66892: PUSH
66893: LD_INT 1
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 2
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 1
66912: PUSH
66913: LD_INT 2
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 0
66922: PUSH
66923: LD_INT 2
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 1
66932: NEG
66933: PUSH
66934: LD_INT 1
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: NEG
66944: PUSH
66945: LD_INT 0
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 2
66954: NEG
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 2
66966: NEG
66967: PUSH
66968: LD_INT 2
66970: NEG
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: LIST
66980: LIST
66981: LIST
66982: LIST
66983: LIST
66984: LIST
66985: LIST
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66997: LD_ADDR_VAR 0 58
67001: PUSH
67002: LD_INT 0
67004: PUSH
67005: LD_INT 0
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PUSH
67012: LD_INT 0
67014: PUSH
67015: LD_INT 1
67017: NEG
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: PUSH
67023: LD_INT 1
67025: PUSH
67026: LD_INT 0
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: PUSH
67036: LD_INT 1
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: PUSH
67043: LD_INT 0
67045: PUSH
67046: LD_INT 1
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: PUSH
67053: LD_INT 1
67055: NEG
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: LD_INT 1
67070: NEG
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: LD_INT 2
67082: NEG
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 0
67090: PUSH
67091: LD_INT 2
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: PUSH
67102: LD_INT 1
67104: NEG
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 2
67112: PUSH
67113: LD_INT 0
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 2
67122: PUSH
67123: LD_INT 1
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 2
67132: PUSH
67133: LD_INT 2
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 1
67142: PUSH
67143: LD_INT 2
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 0
67152: PUSH
67153: LD_INT 2
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 1
67162: NEG
67163: PUSH
67164: LD_INT 1
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 2
67173: NEG
67174: PUSH
67175: LD_INT 0
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 2
67184: NEG
67185: PUSH
67186: LD_INT 1
67188: NEG
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 2
67196: NEG
67197: PUSH
67198: LD_INT 2
67200: NEG
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67227: LD_ADDR_VAR 0 59
67231: PUSH
67232: LD_INT 0
67234: PUSH
67235: LD_INT 0
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 0
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 1
67255: PUSH
67256: LD_INT 0
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 1
67265: PUSH
67266: LD_INT 1
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 0
67275: PUSH
67276: LD_INT 1
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: LD_INT 1
67285: NEG
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 1
67296: NEG
67297: PUSH
67298: LD_INT 1
67300: NEG
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67315: LD_ADDR_VAR 0 60
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 0
67332: PUSH
67333: LD_INT 1
67335: NEG
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 1
67343: PUSH
67344: LD_INT 0
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 1
67353: PUSH
67354: LD_INT 1
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 0
67363: PUSH
67364: LD_INT 1
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 1
67373: NEG
67374: PUSH
67375: LD_INT 0
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 1
67384: NEG
67385: PUSH
67386: LD_INT 1
67388: NEG
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: LIST
67402: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67403: LD_ADDR_VAR 0 61
67407: PUSH
67408: LD_INT 0
67410: PUSH
67411: LD_INT 0
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 0
67420: PUSH
67421: LD_INT 1
67423: NEG
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 1
67431: PUSH
67432: LD_INT 0
67434: PUSH
67435: EMPTY
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: LD_INT 1
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_INT 1
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: LD_INT 1
67461: NEG
67462: PUSH
67463: LD_INT 0
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 1
67472: NEG
67473: PUSH
67474: LD_INT 1
67476: NEG
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67491: LD_ADDR_VAR 0 62
67495: PUSH
67496: LD_INT 0
67498: PUSH
67499: LD_INT 0
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 0
67508: PUSH
67509: LD_INT 1
67511: NEG
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 1
67519: PUSH
67520: LD_INT 0
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 1
67529: PUSH
67530: LD_INT 1
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: LD_INT 0
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 1
67560: NEG
67561: PUSH
67562: LD_INT 1
67564: NEG
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67579: LD_ADDR_VAR 0 63
67583: PUSH
67584: LD_INT 0
67586: PUSH
67587: LD_INT 0
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 0
67596: PUSH
67597: LD_INT 1
67599: NEG
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: PUSH
67608: LD_INT 0
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 1
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: LD_INT 0
67627: PUSH
67628: LD_INT 1
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 1
67637: NEG
67638: PUSH
67639: LD_INT 0
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 1
67648: NEG
67649: PUSH
67650: LD_INT 1
67652: NEG
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: LIST
67666: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67667: LD_ADDR_VAR 0 64
67671: PUSH
67672: LD_INT 0
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: PUSH
67696: LD_INT 0
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 1
67705: PUSH
67706: LD_INT 1
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: LD_INT 1
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: LD_INT 0
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 1
67736: NEG
67737: PUSH
67738: LD_INT 1
67740: NEG
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: ST_TO_ADDR
// end ; 1 :
67755: GO 73652
67757: LD_INT 1
67759: DOUBLE
67760: EQUAL
67761: IFTRUE 67765
67763: GO 70388
67765: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67766: LD_ADDR_VAR 0 11
67770: PUSH
67771: LD_INT 1
67773: NEG
67774: PUSH
67775: LD_INT 3
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: LD_INT 3
67788: NEG
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: LD_INT 2
67799: NEG
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: LIST
67809: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67810: LD_ADDR_VAR 0 12
67814: PUSH
67815: LD_INT 2
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 3
67828: PUSH
67829: LD_INT 0
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 3
67838: PUSH
67839: LD_INT 1
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: LIST
67850: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67851: LD_ADDR_VAR 0 13
67855: PUSH
67856: LD_INT 3
67858: PUSH
67859: LD_INT 2
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: LD_INT 3
67868: PUSH
67869: LD_INT 3
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: LD_INT 3
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: LIST
67890: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67891: LD_ADDR_VAR 0 14
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: LD_INT 3
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 0
67908: PUSH
67909: LD_INT 3
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 1
67918: NEG
67919: PUSH
67920: LD_INT 2
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: LIST
67931: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67932: LD_ADDR_VAR 0 15
67936: PUSH
67937: LD_INT 2
67939: NEG
67940: PUSH
67941: LD_INT 1
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: PUSH
67948: LD_INT 3
67950: NEG
67951: PUSH
67952: LD_INT 0
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 3
67961: NEG
67962: PUSH
67963: LD_INT 1
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: LIST
67975: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67976: LD_ADDR_VAR 0 16
67980: PUSH
67981: LD_INT 2
67983: NEG
67984: PUSH
67985: LD_INT 3
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 3
67995: NEG
67996: PUSH
67997: LD_INT 2
67999: NEG
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 3
68007: NEG
68008: PUSH
68009: LD_INT 3
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: LIST
68021: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68022: LD_ADDR_VAR 0 17
68026: PUSH
68027: LD_INT 1
68029: NEG
68030: PUSH
68031: LD_INT 3
68033: NEG
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: LD_INT 3
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 1
68052: PUSH
68053: LD_INT 2
68055: NEG
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: LIST
68065: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
68066: LD_ADDR_VAR 0 18
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 3
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 3
68094: PUSH
68095: LD_INT 1
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: LIST
68106: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68107: LD_ADDR_VAR 0 19
68111: PUSH
68112: LD_INT 3
68114: PUSH
68115: LD_INT 2
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 3
68124: PUSH
68125: LD_INT 3
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 2
68134: PUSH
68135: LD_INT 3
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: LIST
68146: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
68147: LD_ADDR_VAR 0 20
68151: PUSH
68152: LD_INT 1
68154: PUSH
68155: LD_INT 3
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 0
68164: PUSH
68165: LD_INT 3
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 1
68174: NEG
68175: PUSH
68176: LD_INT 2
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: LIST
68187: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68188: LD_ADDR_VAR 0 21
68192: PUSH
68193: LD_INT 2
68195: NEG
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 3
68206: NEG
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PUSH
68215: LD_INT 3
68217: NEG
68218: PUSH
68219: LD_INT 1
68221: NEG
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: LIST
68231: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68232: LD_ADDR_VAR 0 22
68236: PUSH
68237: LD_INT 2
68239: NEG
68240: PUSH
68241: LD_INT 3
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 3
68251: NEG
68252: PUSH
68253: LD_INT 2
68255: NEG
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 3
68263: NEG
68264: PUSH
68265: LD_INT 3
68267: NEG
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: LIST
68277: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
68278: LD_ADDR_VAR 0 23
68282: PUSH
68283: LD_INT 0
68285: PUSH
68286: LD_INT 3
68288: NEG
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 1
68296: NEG
68297: PUSH
68298: LD_INT 4
68300: NEG
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: PUSH
68306: LD_INT 1
68308: PUSH
68309: LD_INT 3
68311: NEG
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: LIST
68321: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
68322: LD_ADDR_VAR 0 24
68326: PUSH
68327: LD_INT 3
68329: PUSH
68330: LD_INT 0
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 3
68339: PUSH
68340: LD_INT 1
68342: NEG
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: PUSH
68348: LD_INT 4
68350: PUSH
68351: LD_INT 1
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: LIST
68362: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
68363: LD_ADDR_VAR 0 25
68367: PUSH
68368: LD_INT 3
68370: PUSH
68371: LD_INT 3
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 4
68380: PUSH
68381: LD_INT 3
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 3
68390: PUSH
68391: LD_INT 4
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: LIST
68402: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
68403: LD_ADDR_VAR 0 26
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: LD_INT 3
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 1
68420: PUSH
68421: LD_INT 4
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: LD_INT 3
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: LIST
68443: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
68444: LD_ADDR_VAR 0 27
68448: PUSH
68449: LD_INT 3
68451: NEG
68452: PUSH
68453: LD_INT 0
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 3
68462: NEG
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 4
68473: NEG
68474: PUSH
68475: LD_INT 1
68477: NEG
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: LIST
68487: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
68488: LD_ADDR_VAR 0 28
68492: PUSH
68493: LD_INT 3
68495: NEG
68496: PUSH
68497: LD_INT 3
68499: NEG
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 3
68507: NEG
68508: PUSH
68509: LD_INT 4
68511: NEG
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 4
68519: NEG
68520: PUSH
68521: LD_INT 3
68523: NEG
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: LIST
68533: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
68534: LD_ADDR_VAR 0 29
68538: PUSH
68539: LD_INT 1
68541: NEG
68542: PUSH
68543: LD_INT 3
68545: NEG
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 0
68553: PUSH
68554: LD_INT 3
68556: NEG
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 2
68567: NEG
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: LD_INT 4
68579: NEG
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 0
68587: PUSH
68588: LD_INT 4
68590: NEG
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 1
68598: PUSH
68599: LD_INT 3
68601: NEG
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: LD_INT 5
68613: NEG
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 0
68621: PUSH
68622: LD_INT 5
68624: NEG
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 1
68632: PUSH
68633: LD_INT 4
68635: NEG
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 1
68643: NEG
68644: PUSH
68645: LD_INT 6
68647: NEG
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 0
68655: PUSH
68656: LD_INT 6
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 1
68666: PUSH
68667: LD_INT 5
68669: NEG
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
68689: LD_ADDR_VAR 0 30
68693: PUSH
68694: LD_INT 2
68696: PUSH
68697: LD_INT 1
68699: NEG
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: PUSH
68705: LD_INT 3
68707: PUSH
68708: LD_INT 0
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 3
68717: PUSH
68718: LD_INT 1
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 3
68727: PUSH
68728: LD_INT 1
68730: NEG
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 4
68738: PUSH
68739: LD_INT 0
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 4
68748: PUSH
68749: LD_INT 1
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 4
68758: PUSH
68759: LD_INT 1
68761: NEG
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 5
68769: PUSH
68770: LD_INT 0
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 5
68779: PUSH
68780: LD_INT 1
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 5
68789: PUSH
68790: LD_INT 1
68792: NEG
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 6
68800: PUSH
68801: LD_INT 0
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: PUSH
68808: LD_INT 6
68810: PUSH
68811: LD_INT 1
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
68832: LD_ADDR_VAR 0 31
68836: PUSH
68837: LD_INT 3
68839: PUSH
68840: LD_INT 2
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 3
68849: PUSH
68850: LD_INT 3
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 2
68859: PUSH
68860: LD_INT 3
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: PUSH
68867: LD_INT 4
68869: PUSH
68870: LD_INT 3
68872: PUSH
68873: EMPTY
68874: LIST
68875: LIST
68876: PUSH
68877: LD_INT 4
68879: PUSH
68880: LD_INT 4
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 3
68889: PUSH
68890: LD_INT 4
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 5
68899: PUSH
68900: LD_INT 4
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: LD_INT 5
68909: PUSH
68910: LD_INT 5
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: LD_INT 4
68919: PUSH
68920: LD_INT 5
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 6
68929: PUSH
68930: LD_INT 5
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: LD_INT 6
68939: PUSH
68940: LD_INT 6
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 5
68949: PUSH
68950: LD_INT 6
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
68971: LD_ADDR_VAR 0 32
68975: PUSH
68976: LD_INT 1
68978: PUSH
68979: LD_INT 3
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: LD_INT 3
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 1
68998: NEG
68999: PUSH
69000: LD_INT 2
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: PUSH
69010: LD_INT 4
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 0
69019: PUSH
69020: LD_INT 4
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: NEG
69030: PUSH
69031: LD_INT 3
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: PUSH
69041: LD_INT 5
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 0
69050: PUSH
69051: LD_INT 5
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 1
69060: NEG
69061: PUSH
69062: LD_INT 4
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: LD_INT 6
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 0
69081: PUSH
69082: LD_INT 6
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 1
69091: NEG
69092: PUSH
69093: LD_INT 5
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: LIST
69104: LIST
69105: LIST
69106: LIST
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
69114: LD_ADDR_VAR 0 33
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: LD_INT 1
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 3
69132: NEG
69133: PUSH
69134: LD_INT 0
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: LD_INT 3
69143: NEG
69144: PUSH
69145: LD_INT 1
69147: NEG
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 3
69155: NEG
69156: PUSH
69157: LD_INT 1
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 4
69166: NEG
69167: PUSH
69168: LD_INT 0
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 4
69177: NEG
69178: PUSH
69179: LD_INT 1
69181: NEG
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 4
69189: NEG
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 5
69200: NEG
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 5
69211: NEG
69212: PUSH
69213: LD_INT 1
69215: NEG
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 5
69223: NEG
69224: PUSH
69225: LD_INT 1
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 6
69234: NEG
69235: PUSH
69236: LD_INT 0
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 6
69245: NEG
69246: PUSH
69247: LD_INT 1
69249: NEG
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
69269: LD_ADDR_VAR 0 34
69273: PUSH
69274: LD_INT 2
69276: NEG
69277: PUSH
69278: LD_INT 3
69280: NEG
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 3
69288: NEG
69289: PUSH
69290: LD_INT 2
69292: NEG
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 3
69300: NEG
69301: PUSH
69302: LD_INT 3
69304: NEG
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 3
69312: NEG
69313: PUSH
69314: LD_INT 4
69316: NEG
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 4
69324: NEG
69325: PUSH
69326: LD_INT 3
69328: NEG
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 4
69336: NEG
69337: PUSH
69338: LD_INT 4
69340: NEG
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 4
69348: NEG
69349: PUSH
69350: LD_INT 5
69352: NEG
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PUSH
69358: LD_INT 5
69360: NEG
69361: PUSH
69362: LD_INT 4
69364: NEG
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 5
69372: NEG
69373: PUSH
69374: LD_INT 5
69376: NEG
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 5
69384: NEG
69385: PUSH
69386: LD_INT 6
69388: NEG
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 6
69396: NEG
69397: PUSH
69398: LD_INT 5
69400: NEG
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 6
69408: NEG
69409: PUSH
69410: LD_INT 6
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
69432: LD_ADDR_VAR 0 41
69436: PUSH
69437: LD_INT 0
69439: PUSH
69440: LD_INT 2
69442: NEG
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 1
69450: NEG
69451: PUSH
69452: LD_INT 3
69454: NEG
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: LD_INT 2
69465: NEG
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: LIST
69475: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
69476: LD_ADDR_VAR 0 42
69480: PUSH
69481: LD_INT 2
69483: PUSH
69484: LD_INT 0
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 1
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 3
69504: PUSH
69505: LD_INT 1
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: LIST
69516: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
69517: LD_ADDR_VAR 0 43
69521: PUSH
69522: LD_INT 2
69524: PUSH
69525: LD_INT 2
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 3
69534: PUSH
69535: LD_INT 2
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 2
69544: PUSH
69545: LD_INT 3
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: LIST
69556: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
69557: LD_ADDR_VAR 0 44
69561: PUSH
69562: LD_INT 0
69564: PUSH
69565: LD_INT 2
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 1
69574: PUSH
69575: LD_INT 3
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 1
69584: NEG
69585: PUSH
69586: LD_INT 2
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: LIST
69597: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69598: LD_ADDR_VAR 0 45
69602: PUSH
69603: LD_INT 2
69605: NEG
69606: PUSH
69607: LD_INT 0
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 2
69616: NEG
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 3
69627: NEG
69628: PUSH
69629: LD_INT 1
69631: NEG
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: LIST
69641: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
69642: LD_ADDR_VAR 0 46
69646: PUSH
69647: LD_INT 2
69649: NEG
69650: PUSH
69651: LD_INT 2
69653: NEG
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 2
69661: NEG
69662: PUSH
69663: LD_INT 3
69665: NEG
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 3
69673: NEG
69674: PUSH
69675: LD_INT 2
69677: NEG
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
69688: LD_ADDR_VAR 0 47
69692: PUSH
69693: LD_INT 2
69695: NEG
69696: PUSH
69697: LD_INT 3
69699: NEG
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 1
69707: NEG
69708: PUSH
69709: LD_INT 3
69711: NEG
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69721: LD_ADDR_VAR 0 48
69725: PUSH
69726: LD_INT 1
69728: PUSH
69729: LD_INT 2
69731: NEG
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: PUSH
69737: LD_INT 2
69739: PUSH
69740: LD_INT 1
69742: NEG
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
69752: LD_ADDR_VAR 0 49
69756: PUSH
69757: LD_INT 3
69759: PUSH
69760: LD_INT 1
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 3
69769: PUSH
69770: LD_INT 2
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
69781: LD_ADDR_VAR 0 50
69785: PUSH
69786: LD_INT 2
69788: PUSH
69789: LD_INT 3
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: PUSH
69796: LD_INT 1
69798: PUSH
69799: LD_INT 3
69801: PUSH
69802: EMPTY
69803: LIST
69804: LIST
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69810: LD_ADDR_VAR 0 51
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: LD_INT 2
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69841: LD_ADDR_VAR 0 52
69845: PUSH
69846: LD_INT 3
69848: NEG
69849: PUSH
69850: LD_INT 1
69852: NEG
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 3
69860: NEG
69861: PUSH
69862: LD_INT 2
69864: NEG
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69874: LD_ADDR_VAR 0 53
69878: PUSH
69879: LD_INT 1
69881: NEG
69882: PUSH
69883: LD_INT 3
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 0
69893: PUSH
69894: LD_INT 3
69896: NEG
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 1
69904: PUSH
69905: LD_INT 2
69907: NEG
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: LIST
69917: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69918: LD_ADDR_VAR 0 54
69922: PUSH
69923: LD_INT 2
69925: PUSH
69926: LD_INT 1
69928: NEG
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 3
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 3
69946: PUSH
69947: LD_INT 1
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: LIST
69958: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69959: LD_ADDR_VAR 0 55
69963: PUSH
69964: LD_INT 3
69966: PUSH
69967: LD_INT 2
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 3
69976: PUSH
69977: LD_INT 3
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 2
69986: PUSH
69987: LD_INT 3
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: LIST
69998: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69999: LD_ADDR_VAR 0 56
70003: PUSH
70004: LD_INT 1
70006: PUSH
70007: LD_INT 3
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: LD_INT 3
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: NEG
70027: PUSH
70028: LD_INT 2
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: LIST
70039: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70040: LD_ADDR_VAR 0 57
70044: PUSH
70045: LD_INT 2
70047: NEG
70048: PUSH
70049: LD_INT 1
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 3
70058: NEG
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 3
70069: NEG
70070: PUSH
70071: LD_INT 1
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: LIST
70083: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70084: LD_ADDR_VAR 0 58
70088: PUSH
70089: LD_INT 2
70091: NEG
70092: PUSH
70093: LD_INT 3
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 3
70103: NEG
70104: PUSH
70105: LD_INT 2
70107: NEG
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 3
70115: NEG
70116: PUSH
70117: LD_INT 3
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: LIST
70129: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
70130: LD_ADDR_VAR 0 59
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: LD_INT 2
70141: NEG
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 0
70149: PUSH
70150: LD_INT 2
70152: NEG
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 1
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: LIST
70173: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
70174: LD_ADDR_VAR 0 60
70178: PUSH
70179: LD_INT 1
70181: PUSH
70182: LD_INT 1
70184: NEG
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 0
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 2
70202: PUSH
70203: LD_INT 1
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: LIST
70214: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
70215: LD_ADDR_VAR 0 61
70219: PUSH
70220: LD_INT 2
70222: PUSH
70223: LD_INT 1
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 2
70232: PUSH
70233: LD_INT 2
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: LD_INT 2
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: LIST
70254: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70255: LD_ADDR_VAR 0 62
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 2
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 0
70272: PUSH
70273: LD_INT 2
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: NEG
70283: PUSH
70284: LD_INT 1
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: LIST
70295: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70296: LD_ADDR_VAR 0 63
70300: PUSH
70301: LD_INT 1
70303: NEG
70304: PUSH
70305: LD_INT 1
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: PUSH
70312: LD_INT 2
70314: NEG
70315: PUSH
70316: LD_INT 0
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 2
70325: NEG
70326: PUSH
70327: LD_INT 1
70329: NEG
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: LIST
70339: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70340: LD_ADDR_VAR 0 64
70344: PUSH
70345: LD_INT 1
70347: NEG
70348: PUSH
70349: LD_INT 2
70351: NEG
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 2
70359: NEG
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 2
70371: NEG
70372: PUSH
70373: LD_INT 2
70375: NEG
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: LIST
70385: ST_TO_ADDR
// end ; 2 :
70386: GO 73652
70388: LD_INT 2
70390: DOUBLE
70391: EQUAL
70392: IFTRUE 70396
70394: GO 73651
70396: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
70397: LD_ADDR_VAR 0 29
70401: PUSH
70402: LD_INT 4
70404: PUSH
70405: LD_INT 0
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 4
70414: PUSH
70415: LD_INT 1
70417: NEG
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: LD_INT 5
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 5
70435: PUSH
70436: LD_INT 1
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 4
70445: PUSH
70446: LD_INT 1
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: PUSH
70453: LD_INT 3
70455: PUSH
70456: LD_INT 0
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: LD_INT 3
70465: PUSH
70466: LD_INT 1
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 3
70476: PUSH
70477: LD_INT 2
70479: NEG
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 5
70487: PUSH
70488: LD_INT 2
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 3
70497: PUSH
70498: LD_INT 3
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 3
70507: PUSH
70508: LD_INT 2
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 4
70517: PUSH
70518: LD_INT 3
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 4
70527: PUSH
70528: LD_INT 4
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 3
70537: PUSH
70538: LD_INT 4
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 2
70547: PUSH
70548: LD_INT 3
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 2
70557: PUSH
70558: LD_INT 2
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 4
70567: PUSH
70568: LD_INT 2
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 2
70577: PUSH
70578: LD_INT 4
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 0
70587: PUSH
70588: LD_INT 4
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 0
70597: PUSH
70598: LD_INT 3
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: LD_INT 1
70607: PUSH
70608: LD_INT 4
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 1
70617: PUSH
70618: LD_INT 5
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 0
70627: PUSH
70628: LD_INT 5
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 1
70637: NEG
70638: PUSH
70639: LD_INT 4
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 1
70648: NEG
70649: PUSH
70650: LD_INT 3
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 2
70659: PUSH
70660: LD_INT 5
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 2
70669: NEG
70670: PUSH
70671: LD_INT 3
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 3
70680: NEG
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 3
70691: NEG
70692: PUSH
70693: LD_INT 1
70695: NEG
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 2
70703: NEG
70704: PUSH
70705: LD_INT 0
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 2
70714: NEG
70715: PUSH
70716: LD_INT 1
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 3
70725: NEG
70726: PUSH
70727: LD_INT 1
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 4
70736: NEG
70737: PUSH
70738: LD_INT 0
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: LD_INT 4
70747: NEG
70748: PUSH
70749: LD_INT 1
70751: NEG
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 4
70759: NEG
70760: PUSH
70761: LD_INT 2
70763: NEG
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: PUSH
70769: LD_INT 2
70771: NEG
70772: PUSH
70773: LD_INT 2
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 4
70782: NEG
70783: PUSH
70784: LD_INT 4
70786: NEG
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 4
70794: NEG
70795: PUSH
70796: LD_INT 5
70798: NEG
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 3
70806: NEG
70807: PUSH
70808: LD_INT 4
70810: NEG
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 3
70818: NEG
70819: PUSH
70820: LD_INT 3
70822: NEG
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 4
70830: NEG
70831: PUSH
70832: LD_INT 3
70834: NEG
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 5
70842: NEG
70843: PUSH
70844: LD_INT 4
70846: NEG
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 5
70854: NEG
70855: PUSH
70856: LD_INT 5
70858: NEG
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 3
70866: NEG
70867: PUSH
70868: LD_INT 5
70870: NEG
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 5
70878: NEG
70879: PUSH
70880: LD_INT 3
70882: NEG
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
70935: LD_ADDR_VAR 0 30
70939: PUSH
70940: LD_INT 4
70942: PUSH
70943: LD_INT 4
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 4
70952: PUSH
70953: LD_INT 3
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 5
70962: PUSH
70963: LD_INT 4
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 5
70972: PUSH
70973: LD_INT 5
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 4
70982: PUSH
70983: LD_INT 5
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: LD_INT 3
70992: PUSH
70993: LD_INT 4
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 3
71002: PUSH
71003: LD_INT 3
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 5
71012: PUSH
71013: LD_INT 3
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 3
71022: PUSH
71023: LD_INT 5
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 0
71032: PUSH
71033: LD_INT 3
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: LD_INT 2
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 1
71052: PUSH
71053: LD_INT 3
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 1
71062: PUSH
71063: LD_INT 4
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 0
71072: PUSH
71073: LD_INT 4
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 1
71082: NEG
71083: PUSH
71084: LD_INT 3
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 1
71093: NEG
71094: PUSH
71095: LD_INT 2
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 2
71104: PUSH
71105: LD_INT 4
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 2
71114: NEG
71115: PUSH
71116: LD_INT 2
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 4
71125: NEG
71126: PUSH
71127: LD_INT 0
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PUSH
71134: LD_INT 4
71136: NEG
71137: PUSH
71138: LD_INT 1
71140: NEG
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 3
71148: NEG
71149: PUSH
71150: LD_INT 0
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 3
71159: NEG
71160: PUSH
71161: LD_INT 1
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_INT 4
71170: NEG
71171: PUSH
71172: LD_INT 1
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 5
71181: NEG
71182: PUSH
71183: LD_INT 0
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 5
71192: NEG
71193: PUSH
71194: LD_INT 1
71196: NEG
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 5
71204: NEG
71205: PUSH
71206: LD_INT 2
71208: NEG
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 3
71216: NEG
71217: PUSH
71218: LD_INT 2
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: LD_INT 3
71227: NEG
71228: PUSH
71229: LD_INT 3
71231: NEG
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 3
71239: NEG
71240: PUSH
71241: LD_INT 4
71243: NEG
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 2
71251: NEG
71252: PUSH
71253: LD_INT 3
71255: NEG
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 2
71263: NEG
71264: PUSH
71265: LD_INT 2
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 3
71275: NEG
71276: PUSH
71277: LD_INT 2
71279: NEG
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 4
71287: NEG
71288: PUSH
71289: LD_INT 3
71291: NEG
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 4
71299: NEG
71300: PUSH
71301: LD_INT 4
71303: NEG
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 2
71311: NEG
71312: PUSH
71313: LD_INT 4
71315: NEG
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 4
71323: NEG
71324: PUSH
71325: LD_INT 2
71327: NEG
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 0
71335: PUSH
71336: LD_INT 4
71338: NEG
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 0
71346: PUSH
71347: LD_INT 5
71349: NEG
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 1
71357: PUSH
71358: LD_INT 4
71360: NEG
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 1
71368: PUSH
71369: LD_INT 3
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 0
71379: PUSH
71380: LD_INT 3
71382: NEG
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 1
71390: NEG
71391: PUSH
71392: LD_INT 4
71394: NEG
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: LD_INT 5
71406: NEG
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 2
71414: PUSH
71415: LD_INT 3
71417: NEG
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 2
71425: NEG
71426: PUSH
71427: LD_INT 5
71429: NEG
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: LIST
71450: LIST
71451: LIST
71452: LIST
71453: LIST
71454: LIST
71455: LIST
71456: LIST
71457: LIST
71458: LIST
71459: LIST
71460: LIST
71461: LIST
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: LIST
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: LIST
71479: LIST
71480: LIST
71481: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
71482: LD_ADDR_VAR 0 31
71486: PUSH
71487: LD_INT 0
71489: PUSH
71490: LD_INT 4
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 0
71499: PUSH
71500: LD_INT 3
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 1
71509: PUSH
71510: LD_INT 4
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 1
71519: PUSH
71520: LD_INT 5
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 0
71529: PUSH
71530: LD_INT 5
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 1
71539: NEG
71540: PUSH
71541: LD_INT 4
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 1
71550: NEG
71551: PUSH
71552: LD_INT 3
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 2
71561: PUSH
71562: LD_INT 5
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 2
71571: NEG
71572: PUSH
71573: LD_INT 3
71575: PUSH
71576: EMPTY
71577: LIST
71578: LIST
71579: PUSH
71580: LD_INT 3
71582: NEG
71583: PUSH
71584: LD_INT 0
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 3
71593: NEG
71594: PUSH
71595: LD_INT 1
71597: NEG
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 2
71605: NEG
71606: PUSH
71607: LD_INT 0
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 2
71616: NEG
71617: PUSH
71618: LD_INT 1
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 3
71627: NEG
71628: PUSH
71629: LD_INT 1
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 4
71638: NEG
71639: PUSH
71640: LD_INT 0
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 4
71649: NEG
71650: PUSH
71651: LD_INT 1
71653: NEG
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 4
71661: NEG
71662: PUSH
71663: LD_INT 2
71665: NEG
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 2
71673: NEG
71674: PUSH
71675: LD_INT 2
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 4
71684: NEG
71685: PUSH
71686: LD_INT 4
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 4
71696: NEG
71697: PUSH
71698: LD_INT 5
71700: NEG
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 3
71708: NEG
71709: PUSH
71710: LD_INT 4
71712: NEG
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 3
71720: NEG
71721: PUSH
71722: LD_INT 3
71724: NEG
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 4
71732: NEG
71733: PUSH
71734: LD_INT 3
71736: NEG
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: LD_INT 5
71744: NEG
71745: PUSH
71746: LD_INT 4
71748: NEG
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: PUSH
71754: LD_INT 5
71756: NEG
71757: PUSH
71758: LD_INT 5
71760: NEG
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: LD_INT 3
71768: NEG
71769: PUSH
71770: LD_INT 5
71772: NEG
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 5
71780: NEG
71781: PUSH
71782: LD_INT 3
71784: NEG
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 0
71792: PUSH
71793: LD_INT 3
71795: NEG
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 0
71803: PUSH
71804: LD_INT 4
71806: NEG
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 1
71814: PUSH
71815: LD_INT 3
71817: NEG
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 1
71825: PUSH
71826: LD_INT 2
71828: NEG
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 0
71836: PUSH
71837: LD_INT 2
71839: NEG
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 1
71847: NEG
71848: PUSH
71849: LD_INT 3
71851: NEG
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: LD_INT 4
71863: NEG
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 2
71871: PUSH
71872: LD_INT 2
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 2
71882: NEG
71883: PUSH
71884: LD_INT 4
71886: NEG
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 4
71894: PUSH
71895: LD_INT 0
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 4
71904: PUSH
71905: LD_INT 1
71907: NEG
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 5
71915: PUSH
71916: LD_INT 0
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 5
71925: PUSH
71926: LD_INT 1
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 4
71935: PUSH
71936: LD_INT 1
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 3
71945: PUSH
71946: LD_INT 0
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 3
71955: PUSH
71956: LD_INT 1
71958: NEG
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 3
71966: PUSH
71967: LD_INT 2
71969: NEG
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 5
71977: PUSH
71978: LD_INT 2
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: LIST
72007: LIST
72008: LIST
72009: LIST
72010: LIST
72011: LIST
72012: LIST
72013: LIST
72014: LIST
72015: LIST
72016: LIST
72017: LIST
72018: LIST
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
72032: LD_ADDR_VAR 0 32
72036: PUSH
72037: LD_INT 4
72039: NEG
72040: PUSH
72041: LD_INT 0
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 4
72050: NEG
72051: PUSH
72052: LD_INT 1
72054: NEG
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 3
72062: NEG
72063: PUSH
72064: LD_INT 0
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 3
72073: NEG
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 4
72084: NEG
72085: PUSH
72086: LD_INT 1
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: LD_INT 5
72095: NEG
72096: PUSH
72097: LD_INT 0
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 5
72106: NEG
72107: PUSH
72108: LD_INT 1
72110: NEG
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 5
72118: NEG
72119: PUSH
72120: LD_INT 2
72122: NEG
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 3
72130: NEG
72131: PUSH
72132: LD_INT 2
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 3
72141: NEG
72142: PUSH
72143: LD_INT 3
72145: NEG
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 3
72153: NEG
72154: PUSH
72155: LD_INT 4
72157: NEG
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 2
72165: NEG
72166: PUSH
72167: LD_INT 3
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 2
72177: NEG
72178: PUSH
72179: LD_INT 2
72181: NEG
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 3
72189: NEG
72190: PUSH
72191: LD_INT 2
72193: NEG
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 4
72201: NEG
72202: PUSH
72203: LD_INT 3
72205: NEG
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PUSH
72211: LD_INT 4
72213: NEG
72214: PUSH
72215: LD_INT 4
72217: NEG
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 2
72225: NEG
72226: PUSH
72227: LD_INT 4
72229: NEG
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 4
72237: NEG
72238: PUSH
72239: LD_INT 2
72241: NEG
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 0
72249: PUSH
72250: LD_INT 4
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 0
72260: PUSH
72261: LD_INT 5
72263: NEG
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: LD_INT 1
72271: PUSH
72272: LD_INT 4
72274: NEG
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: LD_INT 3
72285: NEG
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: LD_INT 3
72296: NEG
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: LD_INT 4
72308: NEG
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: NEG
72317: PUSH
72318: LD_INT 5
72320: NEG
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 2
72328: PUSH
72329: LD_INT 3
72331: NEG
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: NEG
72340: PUSH
72341: LD_INT 5
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 3
72351: PUSH
72352: LD_INT 0
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 3
72361: PUSH
72362: LD_INT 1
72364: NEG
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 4
72372: PUSH
72373: LD_INT 0
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 4
72382: PUSH
72383: LD_INT 1
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: PUSH
72390: LD_INT 3
72392: PUSH
72393: LD_INT 1
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PUSH
72400: LD_INT 2
72402: PUSH
72403: LD_INT 0
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: LD_INT 2
72412: PUSH
72413: LD_INT 1
72415: NEG
72416: PUSH
72417: EMPTY
72418: LIST
72419: LIST
72420: PUSH
72421: LD_INT 2
72423: PUSH
72424: LD_INT 2
72426: NEG
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 4
72434: PUSH
72435: LD_INT 2
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: LD_INT 4
72444: PUSH
72445: LD_INT 4
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: PUSH
72452: LD_INT 4
72454: PUSH
72455: LD_INT 3
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: PUSH
72462: LD_INT 5
72464: PUSH
72465: LD_INT 4
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 5
72474: PUSH
72475: LD_INT 5
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 4
72484: PUSH
72485: LD_INT 5
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 3
72494: PUSH
72495: LD_INT 4
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 3
72504: PUSH
72505: LD_INT 3
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 5
72514: PUSH
72515: LD_INT 3
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 3
72524: PUSH
72525: LD_INT 5
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: LIST
72536: LIST
72537: LIST
72538: LIST
72539: LIST
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: LIST
72559: LIST
72560: LIST
72561: LIST
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: LIST
72574: LIST
72575: LIST
72576: LIST
72577: LIST
72578: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
72579: LD_ADDR_VAR 0 33
72583: PUSH
72584: LD_INT 4
72586: NEG
72587: PUSH
72588: LD_INT 4
72590: NEG
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: LD_INT 4
72598: NEG
72599: PUSH
72600: LD_INT 5
72602: NEG
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 3
72610: NEG
72611: PUSH
72612: LD_INT 4
72614: NEG
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 3
72622: NEG
72623: PUSH
72624: LD_INT 3
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 4
72634: NEG
72635: PUSH
72636: LD_INT 3
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 5
72646: NEG
72647: PUSH
72648: LD_INT 4
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 5
72658: NEG
72659: PUSH
72660: LD_INT 5
72662: NEG
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 3
72670: NEG
72671: PUSH
72672: LD_INT 5
72674: NEG
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 5
72682: NEG
72683: PUSH
72684: LD_INT 3
72686: NEG
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: LD_INT 3
72697: NEG
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 0
72705: PUSH
72706: LD_INT 4
72708: NEG
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 1
72716: PUSH
72717: LD_INT 3
72719: NEG
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 1
72727: PUSH
72728: LD_INT 2
72730: NEG
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 0
72738: PUSH
72739: LD_INT 2
72741: NEG
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: PUSH
72747: LD_INT 1
72749: NEG
72750: PUSH
72751: LD_INT 3
72753: NEG
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 1
72761: NEG
72762: PUSH
72763: LD_INT 4
72765: NEG
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 2
72773: PUSH
72774: LD_INT 2
72776: NEG
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: PUSH
72782: LD_INT 2
72784: NEG
72785: PUSH
72786: LD_INT 4
72788: NEG
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: LD_INT 4
72796: PUSH
72797: LD_INT 0
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 4
72806: PUSH
72807: LD_INT 1
72809: NEG
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 5
72817: PUSH
72818: LD_INT 0
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 5
72827: PUSH
72828: LD_INT 1
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 4
72837: PUSH
72838: LD_INT 1
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 3
72847: PUSH
72848: LD_INT 0
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 3
72857: PUSH
72858: LD_INT 1
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 3
72868: PUSH
72869: LD_INT 2
72871: NEG
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 5
72879: PUSH
72880: LD_INT 2
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 3
72889: PUSH
72890: LD_INT 3
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 3
72899: PUSH
72900: LD_INT 2
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 4
72909: PUSH
72910: LD_INT 3
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: LD_INT 4
72919: PUSH
72920: LD_INT 4
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 3
72929: PUSH
72930: LD_INT 4
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: PUSH
72937: LD_INT 2
72939: PUSH
72940: LD_INT 3
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 2
72949: PUSH
72950: LD_INT 2
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 4
72959: PUSH
72960: LD_INT 2
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: LD_INT 4
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 0
72979: PUSH
72980: LD_INT 4
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 0
72989: PUSH
72990: LD_INT 3
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 1
72999: PUSH
73000: LD_INT 4
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PUSH
73007: LD_INT 1
73009: PUSH
73010: LD_INT 5
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 0
73019: PUSH
73020: LD_INT 5
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 1
73029: NEG
73030: PUSH
73031: LD_INT 4
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 1
73040: NEG
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 2
73051: PUSH
73052: LD_INT 5
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 2
73061: NEG
73062: PUSH
73063: LD_INT 3
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: LIST
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: LIST
73101: LIST
73102: LIST
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
73117: LD_ADDR_VAR 0 34
73121: PUSH
73122: LD_INT 0
73124: PUSH
73125: LD_INT 4
73127: NEG
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 0
73135: PUSH
73136: LD_INT 5
73138: NEG
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 1
73146: PUSH
73147: LD_INT 4
73149: NEG
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: LD_INT 3
73160: NEG
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: LD_INT 3
73171: NEG
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 1
73179: NEG
73180: PUSH
73181: LD_INT 4
73183: NEG
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 1
73191: NEG
73192: PUSH
73193: LD_INT 5
73195: NEG
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 2
73203: PUSH
73204: LD_INT 3
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: LD_INT 5
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 3
73226: PUSH
73227: LD_INT 0
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 3
73236: PUSH
73237: LD_INT 1
73239: NEG
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 4
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 4
73257: PUSH
73258: LD_INT 1
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 3
73267: PUSH
73268: LD_INT 1
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: PUSH
73278: LD_INT 0
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: LD_INT 2
73287: PUSH
73288: LD_INT 1
73290: NEG
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 2
73298: PUSH
73299: LD_INT 2
73301: NEG
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 4
73309: PUSH
73310: LD_INT 2
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 4
73319: PUSH
73320: LD_INT 4
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 4
73329: PUSH
73330: LD_INT 3
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: LD_INT 5
73339: PUSH
73340: LD_INT 4
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 5
73349: PUSH
73350: LD_INT 5
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 4
73359: PUSH
73360: LD_INT 5
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 3
73369: PUSH
73370: LD_INT 4
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PUSH
73377: LD_INT 3
73379: PUSH
73380: LD_INT 3
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 5
73389: PUSH
73390: LD_INT 3
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 3
73399: PUSH
73400: LD_INT 5
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: LD_INT 3
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 0
73419: PUSH
73420: LD_INT 2
73422: PUSH
73423: EMPTY
73424: LIST
73425: LIST
73426: PUSH
73427: LD_INT 1
73429: PUSH
73430: LD_INT 3
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: LD_INT 4
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PUSH
73447: LD_INT 0
73449: PUSH
73450: LD_INT 4
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PUSH
73457: LD_INT 1
73459: NEG
73460: PUSH
73461: LD_INT 3
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 1
73470: NEG
73471: PUSH
73472: LD_INT 2
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 2
73481: PUSH
73482: LD_INT 4
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 2
73491: NEG
73492: PUSH
73493: LD_INT 2
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 4
73502: NEG
73503: PUSH
73504: LD_INT 0
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 4
73513: NEG
73514: PUSH
73515: LD_INT 1
73517: NEG
73518: PUSH
73519: EMPTY
73520: LIST
73521: LIST
73522: PUSH
73523: LD_INT 3
73525: NEG
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 3
73536: NEG
73537: PUSH
73538: LD_INT 1
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 4
73547: NEG
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 5
73558: NEG
73559: PUSH
73560: LD_INT 0
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 5
73569: NEG
73570: PUSH
73571: LD_INT 1
73573: NEG
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 5
73581: NEG
73582: PUSH
73583: LD_INT 2
73585: NEG
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: PUSH
73591: LD_INT 3
73593: NEG
73594: PUSH
73595: LD_INT 2
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: LIST
73630: LIST
73631: LIST
73632: LIST
73633: LIST
73634: LIST
73635: LIST
73636: LIST
73637: LIST
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: LIST
73645: LIST
73646: LIST
73647: LIST
73648: ST_TO_ADDR
// end ; end ;
73649: GO 73652
73651: POP
// case btype of b_depot , b_warehouse :
73652: LD_VAR 0 1
73656: PUSH
73657: LD_INT 0
73659: DOUBLE
73660: EQUAL
73661: IFTRUE 73671
73663: LD_INT 1
73665: DOUBLE
73666: EQUAL
73667: IFTRUE 73671
73669: GO 73872
73671: POP
// case nation of nation_american :
73672: LD_VAR 0 5
73676: PUSH
73677: LD_INT 1
73679: DOUBLE
73680: EQUAL
73681: IFTRUE 73685
73683: GO 73741
73685: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
73686: LD_ADDR_VAR 0 9
73690: PUSH
73691: LD_VAR 0 11
73695: PUSH
73696: LD_VAR 0 12
73700: PUSH
73701: LD_VAR 0 13
73705: PUSH
73706: LD_VAR 0 14
73710: PUSH
73711: LD_VAR 0 15
73715: PUSH
73716: LD_VAR 0 16
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: PUSH
73729: LD_VAR 0 4
73733: PUSH
73734: LD_INT 1
73736: PLUS
73737: ARRAY
73738: ST_TO_ADDR
73739: GO 73870
73741: LD_INT 2
73743: DOUBLE
73744: EQUAL
73745: IFTRUE 73749
73747: GO 73805
73749: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
73750: LD_ADDR_VAR 0 9
73754: PUSH
73755: LD_VAR 0 17
73759: PUSH
73760: LD_VAR 0 18
73764: PUSH
73765: LD_VAR 0 19
73769: PUSH
73770: LD_VAR 0 20
73774: PUSH
73775: LD_VAR 0 21
73779: PUSH
73780: LD_VAR 0 22
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: PUSH
73793: LD_VAR 0 4
73797: PUSH
73798: LD_INT 1
73800: PLUS
73801: ARRAY
73802: ST_TO_ADDR
73803: GO 73870
73805: LD_INT 3
73807: DOUBLE
73808: EQUAL
73809: IFTRUE 73813
73811: GO 73869
73813: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
73814: LD_ADDR_VAR 0 9
73818: PUSH
73819: LD_VAR 0 23
73823: PUSH
73824: LD_VAR 0 24
73828: PUSH
73829: LD_VAR 0 25
73833: PUSH
73834: LD_VAR 0 26
73838: PUSH
73839: LD_VAR 0 27
73843: PUSH
73844: LD_VAR 0 28
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: PUSH
73857: LD_VAR 0 4
73861: PUSH
73862: LD_INT 1
73864: PLUS
73865: ARRAY
73866: ST_TO_ADDR
73867: GO 73870
73869: POP
73870: GO 74419
73872: LD_INT 2
73874: DOUBLE
73875: EQUAL
73876: IFTRUE 73886
73878: LD_INT 3
73880: DOUBLE
73881: EQUAL
73882: IFTRUE 73886
73884: GO 73942
73886: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
73887: LD_ADDR_VAR 0 9
73891: PUSH
73892: LD_VAR 0 29
73896: PUSH
73897: LD_VAR 0 30
73901: PUSH
73902: LD_VAR 0 31
73906: PUSH
73907: LD_VAR 0 32
73911: PUSH
73912: LD_VAR 0 33
73916: PUSH
73917: LD_VAR 0 34
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: PUSH
73930: LD_VAR 0 4
73934: PUSH
73935: LD_INT 1
73937: PLUS
73938: ARRAY
73939: ST_TO_ADDR
73940: GO 74419
73942: LD_INT 16
73944: DOUBLE
73945: EQUAL
73946: IFTRUE 73998
73948: LD_INT 17
73950: DOUBLE
73951: EQUAL
73952: IFTRUE 73998
73954: LD_INT 18
73956: DOUBLE
73957: EQUAL
73958: IFTRUE 73998
73960: LD_INT 19
73962: DOUBLE
73963: EQUAL
73964: IFTRUE 73998
73966: LD_INT 20
73968: DOUBLE
73969: EQUAL
73970: IFTRUE 73998
73972: LD_INT 21
73974: DOUBLE
73975: EQUAL
73976: IFTRUE 73998
73978: LD_INT 23
73980: DOUBLE
73981: EQUAL
73982: IFTRUE 73998
73984: LD_INT 24
73986: DOUBLE
73987: EQUAL
73988: IFTRUE 73998
73990: LD_INT 25
73992: DOUBLE
73993: EQUAL
73994: IFTRUE 73998
73996: GO 74054
73998: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
73999: LD_ADDR_VAR 0 9
74003: PUSH
74004: LD_VAR 0 35
74008: PUSH
74009: LD_VAR 0 36
74013: PUSH
74014: LD_VAR 0 37
74018: PUSH
74019: LD_VAR 0 38
74023: PUSH
74024: LD_VAR 0 39
74028: PUSH
74029: LD_VAR 0 40
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: PUSH
74042: LD_VAR 0 4
74046: PUSH
74047: LD_INT 1
74049: PLUS
74050: ARRAY
74051: ST_TO_ADDR
74052: GO 74419
74054: LD_INT 6
74056: DOUBLE
74057: EQUAL
74058: IFTRUE 74110
74060: LD_INT 7
74062: DOUBLE
74063: EQUAL
74064: IFTRUE 74110
74066: LD_INT 8
74068: DOUBLE
74069: EQUAL
74070: IFTRUE 74110
74072: LD_INT 13
74074: DOUBLE
74075: EQUAL
74076: IFTRUE 74110
74078: LD_INT 12
74080: DOUBLE
74081: EQUAL
74082: IFTRUE 74110
74084: LD_INT 15
74086: DOUBLE
74087: EQUAL
74088: IFTRUE 74110
74090: LD_INT 11
74092: DOUBLE
74093: EQUAL
74094: IFTRUE 74110
74096: LD_INT 14
74098: DOUBLE
74099: EQUAL
74100: IFTRUE 74110
74102: LD_INT 10
74104: DOUBLE
74105: EQUAL
74106: IFTRUE 74110
74108: GO 74166
74110: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
74111: LD_ADDR_VAR 0 9
74115: PUSH
74116: LD_VAR 0 41
74120: PUSH
74121: LD_VAR 0 42
74125: PUSH
74126: LD_VAR 0 43
74130: PUSH
74131: LD_VAR 0 44
74135: PUSH
74136: LD_VAR 0 45
74140: PUSH
74141: LD_VAR 0 46
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: LIST
74150: LIST
74151: LIST
74152: LIST
74153: PUSH
74154: LD_VAR 0 4
74158: PUSH
74159: LD_INT 1
74161: PLUS
74162: ARRAY
74163: ST_TO_ADDR
74164: GO 74419
74166: LD_INT 36
74168: DOUBLE
74169: EQUAL
74170: IFTRUE 74174
74172: GO 74230
74174: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
74175: LD_ADDR_VAR 0 9
74179: PUSH
74180: LD_VAR 0 47
74184: PUSH
74185: LD_VAR 0 48
74189: PUSH
74190: LD_VAR 0 49
74194: PUSH
74195: LD_VAR 0 50
74199: PUSH
74200: LD_VAR 0 51
74204: PUSH
74205: LD_VAR 0 52
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: PUSH
74218: LD_VAR 0 4
74222: PUSH
74223: LD_INT 1
74225: PLUS
74226: ARRAY
74227: ST_TO_ADDR
74228: GO 74419
74230: LD_INT 4
74232: DOUBLE
74233: EQUAL
74234: IFTRUE 74256
74236: LD_INT 5
74238: DOUBLE
74239: EQUAL
74240: IFTRUE 74256
74242: LD_INT 34
74244: DOUBLE
74245: EQUAL
74246: IFTRUE 74256
74248: LD_INT 37
74250: DOUBLE
74251: EQUAL
74252: IFTRUE 74256
74254: GO 74312
74256: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
74257: LD_ADDR_VAR 0 9
74261: PUSH
74262: LD_VAR 0 53
74266: PUSH
74267: LD_VAR 0 54
74271: PUSH
74272: LD_VAR 0 55
74276: PUSH
74277: LD_VAR 0 56
74281: PUSH
74282: LD_VAR 0 57
74286: PUSH
74287: LD_VAR 0 58
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: PUSH
74300: LD_VAR 0 4
74304: PUSH
74305: LD_INT 1
74307: PLUS
74308: ARRAY
74309: ST_TO_ADDR
74310: GO 74419
74312: LD_INT 31
74314: DOUBLE
74315: EQUAL
74316: IFTRUE 74362
74318: LD_INT 32
74320: DOUBLE
74321: EQUAL
74322: IFTRUE 74362
74324: LD_INT 33
74326: DOUBLE
74327: EQUAL
74328: IFTRUE 74362
74330: LD_INT 27
74332: DOUBLE
74333: EQUAL
74334: IFTRUE 74362
74336: LD_INT 26
74338: DOUBLE
74339: EQUAL
74340: IFTRUE 74362
74342: LD_INT 28
74344: DOUBLE
74345: EQUAL
74346: IFTRUE 74362
74348: LD_INT 29
74350: DOUBLE
74351: EQUAL
74352: IFTRUE 74362
74354: LD_INT 30
74356: DOUBLE
74357: EQUAL
74358: IFTRUE 74362
74360: GO 74418
74362: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
74363: LD_ADDR_VAR 0 9
74367: PUSH
74368: LD_VAR 0 59
74372: PUSH
74373: LD_VAR 0 60
74377: PUSH
74378: LD_VAR 0 61
74382: PUSH
74383: LD_VAR 0 62
74387: PUSH
74388: LD_VAR 0 63
74392: PUSH
74393: LD_VAR 0 64
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: PUSH
74406: LD_VAR 0 4
74410: PUSH
74411: LD_INT 1
74413: PLUS
74414: ARRAY
74415: ST_TO_ADDR
74416: GO 74419
74418: POP
// temp_list2 = [ ] ;
74419: LD_ADDR_VAR 0 10
74423: PUSH
74424: EMPTY
74425: ST_TO_ADDR
// for i in temp_list do
74426: LD_ADDR_VAR 0 8
74430: PUSH
74431: LD_VAR 0 9
74435: PUSH
74436: FOR_IN
74437: IFFALSE 74489
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
74439: LD_ADDR_VAR 0 10
74443: PUSH
74444: LD_VAR 0 10
74448: PUSH
74449: LD_VAR 0 8
74453: PUSH
74454: LD_INT 1
74456: ARRAY
74457: PUSH
74458: LD_VAR 0 2
74462: PLUS
74463: PUSH
74464: LD_VAR 0 8
74468: PUSH
74469: LD_INT 2
74471: ARRAY
74472: PUSH
74473: LD_VAR 0 3
74477: PLUS
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: EMPTY
74484: LIST
74485: ADD
74486: ST_TO_ADDR
74487: GO 74436
74489: POP
74490: POP
// result = temp_list2 ;
74491: LD_ADDR_VAR 0 7
74495: PUSH
74496: LD_VAR 0 10
74500: ST_TO_ADDR
// end ;
74501: LD_VAR 0 7
74505: RET
// export function EnemyInRange ( unit , dist ) ; begin
74506: LD_INT 0
74508: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
74509: LD_ADDR_VAR 0 3
74513: PUSH
74514: LD_VAR 0 1
74518: PPUSH
74519: CALL_OW 255
74523: PPUSH
74524: LD_VAR 0 1
74528: PPUSH
74529: CALL_OW 250
74533: PPUSH
74534: LD_VAR 0 1
74538: PPUSH
74539: CALL_OW 251
74543: PPUSH
74544: LD_VAR 0 2
74548: PPUSH
74549: CALL 48634 0 4
74553: PUSH
74554: LD_INT 4
74556: ARRAY
74557: ST_TO_ADDR
// end ;
74558: LD_VAR 0 3
74562: RET
// export function PlayerSeeMe ( unit ) ; begin
74563: LD_INT 0
74565: PPUSH
// result := See ( your_side , unit ) ;
74566: LD_ADDR_VAR 0 2
74570: PUSH
74571: LD_OWVAR 2
74575: PPUSH
74576: LD_VAR 0 1
74580: PPUSH
74581: CALL_OW 292
74585: ST_TO_ADDR
// end ;
74586: LD_VAR 0 2
74590: RET
// export function ReverseDir ( unit ) ; begin
74591: LD_INT 0
74593: PPUSH
// if not unit then
74594: LD_VAR 0 1
74598: NOT
74599: IFFALSE 74603
// exit ;
74601: GO 74649
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
74603: LD_ADDR_VAR 0 2
74607: PUSH
74608: LD_INT 3
74610: PUSH
74611: LD_INT 4
74613: PUSH
74614: LD_INT 5
74616: PUSH
74617: LD_INT 0
74619: PUSH
74620: LD_INT 1
74622: PUSH
74623: LD_INT 2
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: PUSH
74634: LD_VAR 0 1
74638: PPUSH
74639: CALL_OW 254
74643: PUSH
74644: LD_INT 1
74646: PLUS
74647: ARRAY
74648: ST_TO_ADDR
// end ;
74649: LD_VAR 0 2
74653: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
74654: LD_INT 0
74656: PPUSH
74657: PPUSH
74658: PPUSH
74659: PPUSH
74660: PPUSH
// if not hexes then
74661: LD_VAR 0 2
74665: NOT
74666: IFFALSE 74670
// exit ;
74668: GO 74818
// dist := 9999 ;
74670: LD_ADDR_VAR 0 5
74674: PUSH
74675: LD_INT 9999
74677: ST_TO_ADDR
// for i = 1 to hexes do
74678: LD_ADDR_VAR 0 4
74682: PUSH
74683: DOUBLE
74684: LD_INT 1
74686: DEC
74687: ST_TO_ADDR
74688: LD_VAR 0 2
74692: PUSH
74693: FOR_TO
74694: IFFALSE 74806
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
74696: LD_VAR 0 1
74700: PPUSH
74701: LD_VAR 0 2
74705: PUSH
74706: LD_VAR 0 4
74710: ARRAY
74711: PUSH
74712: LD_INT 1
74714: ARRAY
74715: PPUSH
74716: LD_VAR 0 2
74720: PUSH
74721: LD_VAR 0 4
74725: ARRAY
74726: PUSH
74727: LD_INT 2
74729: ARRAY
74730: PPUSH
74731: CALL_OW 297
74735: PUSH
74736: LD_VAR 0 5
74740: LESS
74741: IFFALSE 74804
// begin hex := hexes [ i ] ;
74743: LD_ADDR_VAR 0 7
74747: PUSH
74748: LD_VAR 0 2
74752: PUSH
74753: LD_VAR 0 4
74757: ARRAY
74758: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74759: LD_ADDR_VAR 0 5
74763: PUSH
74764: LD_VAR 0 1
74768: PPUSH
74769: LD_VAR 0 2
74773: PUSH
74774: LD_VAR 0 4
74778: ARRAY
74779: PUSH
74780: LD_INT 1
74782: ARRAY
74783: PPUSH
74784: LD_VAR 0 2
74788: PUSH
74789: LD_VAR 0 4
74793: ARRAY
74794: PUSH
74795: LD_INT 2
74797: ARRAY
74798: PPUSH
74799: CALL_OW 297
74803: ST_TO_ADDR
// end ; end ;
74804: GO 74693
74806: POP
74807: POP
// result := hex ;
74808: LD_ADDR_VAR 0 3
74812: PUSH
74813: LD_VAR 0 7
74817: ST_TO_ADDR
// end ;
74818: LD_VAR 0 3
74822: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
74823: LD_INT 0
74825: PPUSH
74826: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
74827: LD_VAR 0 1
74831: NOT
74832: PUSH
74833: LD_VAR 0 1
74837: PUSH
74838: LD_INT 21
74840: PUSH
74841: LD_INT 2
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 23
74850: PUSH
74851: LD_INT 2
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PPUSH
74862: CALL_OW 69
74866: IN
74867: NOT
74868: OR
74869: IFFALSE 74873
// exit ;
74871: GO 74920
// for i = 1 to 3 do
74873: LD_ADDR_VAR 0 3
74877: PUSH
74878: DOUBLE
74879: LD_INT 1
74881: DEC
74882: ST_TO_ADDR
74883: LD_INT 3
74885: PUSH
74886: FOR_TO
74887: IFFALSE 74918
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
74889: LD_VAR 0 1
74893: PPUSH
74894: CALL_OW 250
74898: PPUSH
74899: LD_VAR 0 1
74903: PPUSH
74904: CALL_OW 251
74908: PPUSH
74909: LD_INT 1
74911: PPUSH
74912: CALL_OW 453
74916: GO 74886
74918: POP
74919: POP
// end ;
74920: LD_VAR 0 2
74924: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
74925: LD_INT 0
74927: PPUSH
74928: PPUSH
74929: PPUSH
74930: PPUSH
74931: PPUSH
74932: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
74933: LD_VAR 0 1
74937: NOT
74938: PUSH
74939: LD_VAR 0 2
74943: NOT
74944: OR
74945: PUSH
74946: LD_VAR 0 1
74950: PPUSH
74951: CALL_OW 314
74955: OR
74956: IFFALSE 74960
// exit ;
74958: GO 75401
// x := GetX ( enemy_unit ) ;
74960: LD_ADDR_VAR 0 7
74964: PUSH
74965: LD_VAR 0 2
74969: PPUSH
74970: CALL_OW 250
74974: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
74975: LD_ADDR_VAR 0 8
74979: PUSH
74980: LD_VAR 0 2
74984: PPUSH
74985: CALL_OW 251
74989: ST_TO_ADDR
// if not x or not y then
74990: LD_VAR 0 7
74994: NOT
74995: PUSH
74996: LD_VAR 0 8
75000: NOT
75001: OR
75002: IFFALSE 75006
// exit ;
75004: GO 75401
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
75006: LD_ADDR_VAR 0 6
75010: PUSH
75011: LD_VAR 0 7
75015: PPUSH
75016: LD_INT 0
75018: PPUSH
75019: LD_INT 4
75021: PPUSH
75022: CALL_OW 272
75026: PUSH
75027: LD_VAR 0 8
75031: PPUSH
75032: LD_INT 0
75034: PPUSH
75035: LD_INT 4
75037: PPUSH
75038: CALL_OW 273
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_VAR 0 7
75051: PPUSH
75052: LD_INT 1
75054: PPUSH
75055: LD_INT 4
75057: PPUSH
75058: CALL_OW 272
75062: PUSH
75063: LD_VAR 0 8
75067: PPUSH
75068: LD_INT 1
75070: PPUSH
75071: LD_INT 4
75073: PPUSH
75074: CALL_OW 273
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_VAR 0 7
75087: PPUSH
75088: LD_INT 2
75090: PPUSH
75091: LD_INT 4
75093: PPUSH
75094: CALL_OW 272
75098: PUSH
75099: LD_VAR 0 8
75103: PPUSH
75104: LD_INT 2
75106: PPUSH
75107: LD_INT 4
75109: PPUSH
75110: CALL_OW 273
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_VAR 0 7
75123: PPUSH
75124: LD_INT 3
75126: PPUSH
75127: LD_INT 4
75129: PPUSH
75130: CALL_OW 272
75134: PUSH
75135: LD_VAR 0 8
75139: PPUSH
75140: LD_INT 3
75142: PPUSH
75143: LD_INT 4
75145: PPUSH
75146: CALL_OW 273
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_VAR 0 7
75159: PPUSH
75160: LD_INT 4
75162: PPUSH
75163: LD_INT 4
75165: PPUSH
75166: CALL_OW 272
75170: PUSH
75171: LD_VAR 0 8
75175: PPUSH
75176: LD_INT 4
75178: PPUSH
75179: LD_INT 4
75181: PPUSH
75182: CALL_OW 273
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_VAR 0 7
75195: PPUSH
75196: LD_INT 5
75198: PPUSH
75199: LD_INT 4
75201: PPUSH
75202: CALL_OW 272
75206: PUSH
75207: LD_VAR 0 8
75211: PPUSH
75212: LD_INT 5
75214: PPUSH
75215: LD_INT 4
75217: PPUSH
75218: CALL_OW 273
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: LIST
75231: LIST
75232: LIST
75233: LIST
75234: ST_TO_ADDR
// for i = tmp downto 1 do
75235: LD_ADDR_VAR 0 4
75239: PUSH
75240: DOUBLE
75241: LD_VAR 0 6
75245: INC
75246: ST_TO_ADDR
75247: LD_INT 1
75249: PUSH
75250: FOR_DOWNTO
75251: IFFALSE 75352
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
75253: LD_VAR 0 6
75257: PUSH
75258: LD_VAR 0 4
75262: ARRAY
75263: PUSH
75264: LD_INT 1
75266: ARRAY
75267: PPUSH
75268: LD_VAR 0 6
75272: PUSH
75273: LD_VAR 0 4
75277: ARRAY
75278: PUSH
75279: LD_INT 2
75281: ARRAY
75282: PPUSH
75283: CALL_OW 488
75287: NOT
75288: PUSH
75289: LD_VAR 0 6
75293: PUSH
75294: LD_VAR 0 4
75298: ARRAY
75299: PUSH
75300: LD_INT 1
75302: ARRAY
75303: PPUSH
75304: LD_VAR 0 6
75308: PUSH
75309: LD_VAR 0 4
75313: ARRAY
75314: PUSH
75315: LD_INT 2
75317: ARRAY
75318: PPUSH
75319: CALL_OW 428
75323: PUSH
75324: LD_INT 0
75326: NONEQUAL
75327: OR
75328: IFFALSE 75350
// tmp := Delete ( tmp , i ) ;
75330: LD_ADDR_VAR 0 6
75334: PUSH
75335: LD_VAR 0 6
75339: PPUSH
75340: LD_VAR 0 4
75344: PPUSH
75345: CALL_OW 3
75349: ST_TO_ADDR
75350: GO 75250
75352: POP
75353: POP
// j := GetClosestHex ( unit , tmp ) ;
75354: LD_ADDR_VAR 0 5
75358: PUSH
75359: LD_VAR 0 1
75363: PPUSH
75364: LD_VAR 0 6
75368: PPUSH
75369: CALL 74654 0 2
75373: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
75374: LD_VAR 0 1
75378: PPUSH
75379: LD_VAR 0 5
75383: PUSH
75384: LD_INT 1
75386: ARRAY
75387: PPUSH
75388: LD_VAR 0 5
75392: PUSH
75393: LD_INT 2
75395: ARRAY
75396: PPUSH
75397: CALL_OW 111
// end ;
75401: LD_VAR 0 3
75405: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
75406: LD_INT 0
75408: PPUSH
75409: PPUSH
75410: PPUSH
// uc_side = 0 ;
75411: LD_ADDR_OWVAR 20
75415: PUSH
75416: LD_INT 0
75418: ST_TO_ADDR
// uc_nation = 0 ;
75419: LD_ADDR_OWVAR 21
75423: PUSH
75424: LD_INT 0
75426: ST_TO_ADDR
// InitHc ;
75427: CALL_OW 19
// InitVc ;
75431: CALL_OW 20
// if mastodonts then
75435: LD_VAR 0 6
75439: IFFALSE 75506
// for i = 1 to mastodonts do
75441: LD_ADDR_VAR 0 11
75445: PUSH
75446: DOUBLE
75447: LD_INT 1
75449: DEC
75450: ST_TO_ADDR
75451: LD_VAR 0 6
75455: PUSH
75456: FOR_TO
75457: IFFALSE 75504
// begin vc_chassis := 31 ;
75459: LD_ADDR_OWVAR 37
75463: PUSH
75464: LD_INT 31
75466: ST_TO_ADDR
// vc_control := control_rider ;
75467: LD_ADDR_OWVAR 38
75471: PUSH
75472: LD_INT 4
75474: ST_TO_ADDR
// animal := CreateVehicle ;
75475: LD_ADDR_VAR 0 12
75479: PUSH
75480: CALL_OW 45
75484: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75485: LD_VAR 0 12
75489: PPUSH
75490: LD_VAR 0 8
75494: PPUSH
75495: LD_INT 0
75497: PPUSH
75498: CALL 82212 0 3
// end ;
75502: GO 75456
75504: POP
75505: POP
// if horses then
75506: LD_VAR 0 5
75510: IFFALSE 75577
// for i = 1 to horses do
75512: LD_ADDR_VAR 0 11
75516: PUSH
75517: DOUBLE
75518: LD_INT 1
75520: DEC
75521: ST_TO_ADDR
75522: LD_VAR 0 5
75526: PUSH
75527: FOR_TO
75528: IFFALSE 75575
// begin hc_class := 21 ;
75530: LD_ADDR_OWVAR 28
75534: PUSH
75535: LD_INT 21
75537: ST_TO_ADDR
// hc_gallery :=  ;
75538: LD_ADDR_OWVAR 33
75542: PUSH
75543: LD_STRING 
75545: ST_TO_ADDR
// animal := CreateHuman ;
75546: LD_ADDR_VAR 0 12
75550: PUSH
75551: CALL_OW 44
75555: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75556: LD_VAR 0 12
75560: PPUSH
75561: LD_VAR 0 8
75565: PPUSH
75566: LD_INT 0
75568: PPUSH
75569: CALL 82212 0 3
// end ;
75573: GO 75527
75575: POP
75576: POP
// if birds then
75577: LD_VAR 0 1
75581: IFFALSE 75648
// for i = 1 to birds do
75583: LD_ADDR_VAR 0 11
75587: PUSH
75588: DOUBLE
75589: LD_INT 1
75591: DEC
75592: ST_TO_ADDR
75593: LD_VAR 0 1
75597: PUSH
75598: FOR_TO
75599: IFFALSE 75646
// begin hc_class = 18 ;
75601: LD_ADDR_OWVAR 28
75605: PUSH
75606: LD_INT 18
75608: ST_TO_ADDR
// hc_gallery =  ;
75609: LD_ADDR_OWVAR 33
75613: PUSH
75614: LD_STRING 
75616: ST_TO_ADDR
// animal := CreateHuman ;
75617: LD_ADDR_VAR 0 12
75621: PUSH
75622: CALL_OW 44
75626: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75627: LD_VAR 0 12
75631: PPUSH
75632: LD_VAR 0 8
75636: PPUSH
75637: LD_INT 0
75639: PPUSH
75640: CALL 82212 0 3
// end ;
75644: GO 75598
75646: POP
75647: POP
// if tigers then
75648: LD_VAR 0 2
75652: IFFALSE 75736
// for i = 1 to tigers do
75654: LD_ADDR_VAR 0 11
75658: PUSH
75659: DOUBLE
75660: LD_INT 1
75662: DEC
75663: ST_TO_ADDR
75664: LD_VAR 0 2
75668: PUSH
75669: FOR_TO
75670: IFFALSE 75734
// begin hc_class = class_tiger ;
75672: LD_ADDR_OWVAR 28
75676: PUSH
75677: LD_INT 14
75679: ST_TO_ADDR
// hc_gallery =  ;
75680: LD_ADDR_OWVAR 33
75684: PUSH
75685: LD_STRING 
75687: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
75688: LD_ADDR_OWVAR 35
75692: PUSH
75693: LD_INT 7
75695: NEG
75696: PPUSH
75697: LD_INT 7
75699: PPUSH
75700: CALL_OW 12
75704: ST_TO_ADDR
// animal := CreateHuman ;
75705: LD_ADDR_VAR 0 12
75709: PUSH
75710: CALL_OW 44
75714: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75715: LD_VAR 0 12
75719: PPUSH
75720: LD_VAR 0 8
75724: PPUSH
75725: LD_INT 0
75727: PPUSH
75728: CALL 82212 0 3
// end ;
75732: GO 75669
75734: POP
75735: POP
// if apemans then
75736: LD_VAR 0 3
75740: IFFALSE 75863
// for i = 1 to apemans do
75742: LD_ADDR_VAR 0 11
75746: PUSH
75747: DOUBLE
75748: LD_INT 1
75750: DEC
75751: ST_TO_ADDR
75752: LD_VAR 0 3
75756: PUSH
75757: FOR_TO
75758: IFFALSE 75861
// begin hc_class = class_apeman ;
75760: LD_ADDR_OWVAR 28
75764: PUSH
75765: LD_INT 12
75767: ST_TO_ADDR
// hc_gallery =  ;
75768: LD_ADDR_OWVAR 33
75772: PUSH
75773: LD_STRING 
75775: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
75776: LD_ADDR_OWVAR 35
75780: PUSH
75781: LD_INT 5
75783: NEG
75784: PPUSH
75785: LD_INT 5
75787: PPUSH
75788: CALL_OW 12
75792: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
75793: LD_ADDR_OWVAR 31
75797: PUSH
75798: LD_INT 1
75800: PPUSH
75801: LD_INT 3
75803: PPUSH
75804: CALL_OW 12
75808: PUSH
75809: LD_INT 1
75811: PPUSH
75812: LD_INT 3
75814: PPUSH
75815: CALL_OW 12
75819: PUSH
75820: LD_INT 0
75822: PUSH
75823: LD_INT 0
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: ST_TO_ADDR
// animal := CreateHuman ;
75832: LD_ADDR_VAR 0 12
75836: PUSH
75837: CALL_OW 44
75841: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75842: LD_VAR 0 12
75846: PPUSH
75847: LD_VAR 0 8
75851: PPUSH
75852: LD_INT 0
75854: PPUSH
75855: CALL 82212 0 3
// end ;
75859: GO 75757
75861: POP
75862: POP
// if enchidnas then
75863: LD_VAR 0 4
75867: IFFALSE 75934
// for i = 1 to enchidnas do
75869: LD_ADDR_VAR 0 11
75873: PUSH
75874: DOUBLE
75875: LD_INT 1
75877: DEC
75878: ST_TO_ADDR
75879: LD_VAR 0 4
75883: PUSH
75884: FOR_TO
75885: IFFALSE 75932
// begin hc_class = 13 ;
75887: LD_ADDR_OWVAR 28
75891: PUSH
75892: LD_INT 13
75894: ST_TO_ADDR
// hc_gallery =  ;
75895: LD_ADDR_OWVAR 33
75899: PUSH
75900: LD_STRING 
75902: ST_TO_ADDR
// animal := CreateHuman ;
75903: LD_ADDR_VAR 0 12
75907: PUSH
75908: CALL_OW 44
75912: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75913: LD_VAR 0 12
75917: PPUSH
75918: LD_VAR 0 8
75922: PPUSH
75923: LD_INT 0
75925: PPUSH
75926: CALL 82212 0 3
// end ;
75930: GO 75884
75932: POP
75933: POP
// if fishes then
75934: LD_VAR 0 7
75938: IFFALSE 76005
// for i = 1 to fishes do
75940: LD_ADDR_VAR 0 11
75944: PUSH
75945: DOUBLE
75946: LD_INT 1
75948: DEC
75949: ST_TO_ADDR
75950: LD_VAR 0 7
75954: PUSH
75955: FOR_TO
75956: IFFALSE 76003
// begin hc_class = 20 ;
75958: LD_ADDR_OWVAR 28
75962: PUSH
75963: LD_INT 20
75965: ST_TO_ADDR
// hc_gallery =  ;
75966: LD_ADDR_OWVAR 33
75970: PUSH
75971: LD_STRING 
75973: ST_TO_ADDR
// animal := CreateHuman ;
75974: LD_ADDR_VAR 0 12
75978: PUSH
75979: CALL_OW 44
75983: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
75984: LD_VAR 0 12
75988: PPUSH
75989: LD_VAR 0 9
75993: PPUSH
75994: LD_INT 0
75996: PPUSH
75997: CALL 82212 0 3
// end ;
76001: GO 75955
76003: POP
76004: POP
// end ;
76005: LD_VAR 0 10
76009: RET
// export function WantHeal ( sci , unit ) ; begin
76010: LD_INT 0
76012: PPUSH
// if GetTaskList ( sci ) > 0 then
76013: LD_VAR 0 1
76017: PPUSH
76018: CALL_OW 437
76022: PUSH
76023: LD_INT 0
76025: GREATER
76026: IFFALSE 76096
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
76028: LD_VAR 0 1
76032: PPUSH
76033: CALL_OW 437
76037: PUSH
76038: LD_INT 1
76040: ARRAY
76041: PUSH
76042: LD_INT 1
76044: ARRAY
76045: PUSH
76046: LD_STRING l
76048: EQUAL
76049: PUSH
76050: LD_VAR 0 1
76054: PPUSH
76055: CALL_OW 437
76059: PUSH
76060: LD_INT 1
76062: ARRAY
76063: PUSH
76064: LD_INT 4
76066: ARRAY
76067: PUSH
76068: LD_VAR 0 2
76072: EQUAL
76073: AND
76074: IFFALSE 76086
// result := true else
76076: LD_ADDR_VAR 0 3
76080: PUSH
76081: LD_INT 1
76083: ST_TO_ADDR
76084: GO 76094
// result := false ;
76086: LD_ADDR_VAR 0 3
76090: PUSH
76091: LD_INT 0
76093: ST_TO_ADDR
// end else
76094: GO 76104
// result := false ;
76096: LD_ADDR_VAR 0 3
76100: PUSH
76101: LD_INT 0
76103: ST_TO_ADDR
// end ;
76104: LD_VAR 0 3
76108: RET
// export function HealTarget ( sci ) ; begin
76109: LD_INT 0
76111: PPUSH
// if not sci then
76112: LD_VAR 0 1
76116: NOT
76117: IFFALSE 76121
// exit ;
76119: GO 76186
// result := 0 ;
76121: LD_ADDR_VAR 0 2
76125: PUSH
76126: LD_INT 0
76128: ST_TO_ADDR
// if GetTaskList ( sci ) then
76129: LD_VAR 0 1
76133: PPUSH
76134: CALL_OW 437
76138: IFFALSE 76186
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
76140: LD_VAR 0 1
76144: PPUSH
76145: CALL_OW 437
76149: PUSH
76150: LD_INT 1
76152: ARRAY
76153: PUSH
76154: LD_INT 1
76156: ARRAY
76157: PUSH
76158: LD_STRING l
76160: EQUAL
76161: IFFALSE 76186
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
76163: LD_ADDR_VAR 0 2
76167: PUSH
76168: LD_VAR 0 1
76172: PPUSH
76173: CALL_OW 437
76177: PUSH
76178: LD_INT 1
76180: ARRAY
76181: PUSH
76182: LD_INT 4
76184: ARRAY
76185: ST_TO_ADDR
// end ;
76186: LD_VAR 0 2
76190: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
76191: LD_INT 0
76193: PPUSH
76194: PPUSH
76195: PPUSH
76196: PPUSH
76197: PPUSH
76198: PPUSH
76199: PPUSH
76200: PPUSH
76201: PPUSH
76202: PPUSH
76203: PPUSH
76204: PPUSH
76205: PPUSH
76206: PPUSH
76207: PPUSH
76208: PPUSH
76209: PPUSH
76210: PPUSH
76211: PPUSH
76212: PPUSH
76213: PPUSH
76214: PPUSH
76215: PPUSH
76216: PPUSH
76217: PPUSH
76218: PPUSH
76219: PPUSH
76220: PPUSH
76221: PPUSH
76222: PPUSH
76223: PPUSH
76224: PPUSH
76225: PPUSH
// if not list then
76226: LD_VAR 0 1
76230: NOT
76231: IFFALSE 76235
// exit ;
76233: GO 80823
// base := list [ 1 ] ;
76235: LD_ADDR_VAR 0 3
76239: PUSH
76240: LD_VAR 0 1
76244: PUSH
76245: LD_INT 1
76247: ARRAY
76248: ST_TO_ADDR
// group := list [ 2 ] ;
76249: LD_ADDR_VAR 0 4
76253: PUSH
76254: LD_VAR 0 1
76258: PUSH
76259: LD_INT 2
76261: ARRAY
76262: ST_TO_ADDR
// path := list [ 3 ] ;
76263: LD_ADDR_VAR 0 5
76267: PUSH
76268: LD_VAR 0 1
76272: PUSH
76273: LD_INT 3
76275: ARRAY
76276: ST_TO_ADDR
// flags := list [ 4 ] ;
76277: LD_ADDR_VAR 0 6
76281: PUSH
76282: LD_VAR 0 1
76286: PUSH
76287: LD_INT 4
76289: ARRAY
76290: ST_TO_ADDR
// mined := [ ] ;
76291: LD_ADDR_VAR 0 27
76295: PUSH
76296: EMPTY
76297: ST_TO_ADDR
// bombed := [ ] ;
76298: LD_ADDR_VAR 0 28
76302: PUSH
76303: EMPTY
76304: ST_TO_ADDR
// healers := [ ] ;
76305: LD_ADDR_VAR 0 31
76309: PUSH
76310: EMPTY
76311: ST_TO_ADDR
// to_heal := [ ] ;
76312: LD_ADDR_VAR 0 30
76316: PUSH
76317: EMPTY
76318: ST_TO_ADDR
// repairs := [ ] ;
76319: LD_ADDR_VAR 0 33
76323: PUSH
76324: EMPTY
76325: ST_TO_ADDR
// to_repair := [ ] ;
76326: LD_ADDR_VAR 0 32
76330: PUSH
76331: EMPTY
76332: ST_TO_ADDR
// if not group or not path then
76333: LD_VAR 0 4
76337: NOT
76338: PUSH
76339: LD_VAR 0 5
76343: NOT
76344: OR
76345: IFFALSE 76349
// exit ;
76347: GO 80823
// if flags then
76349: LD_VAR 0 6
76353: IFFALSE 76497
// begin f_ignore_area := flags [ 1 ] ;
76355: LD_ADDR_VAR 0 17
76359: PUSH
76360: LD_VAR 0 6
76364: PUSH
76365: LD_INT 1
76367: ARRAY
76368: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
76369: LD_ADDR_VAR 0 18
76373: PUSH
76374: LD_VAR 0 6
76378: PUSH
76379: LD_INT 2
76381: ARRAY
76382: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
76383: LD_ADDR_VAR 0 19
76387: PUSH
76388: LD_VAR 0 6
76392: PUSH
76393: LD_INT 3
76395: ARRAY
76396: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
76397: LD_ADDR_VAR 0 20
76401: PUSH
76402: LD_VAR 0 6
76406: PUSH
76407: LD_INT 4
76409: ARRAY
76410: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
76411: LD_ADDR_VAR 0 21
76415: PUSH
76416: LD_VAR 0 6
76420: PUSH
76421: LD_INT 5
76423: ARRAY
76424: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
76425: LD_ADDR_VAR 0 22
76429: PUSH
76430: LD_VAR 0 6
76434: PUSH
76435: LD_INT 6
76437: ARRAY
76438: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
76439: LD_ADDR_VAR 0 23
76443: PUSH
76444: LD_VAR 0 6
76448: PUSH
76449: LD_INT 7
76451: ARRAY
76452: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
76453: LD_ADDR_VAR 0 24
76457: PUSH
76458: LD_VAR 0 6
76462: PUSH
76463: LD_INT 8
76465: ARRAY
76466: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
76467: LD_ADDR_VAR 0 25
76471: PUSH
76472: LD_VAR 0 6
76476: PUSH
76477: LD_INT 9
76479: ARRAY
76480: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
76481: LD_ADDR_VAR 0 26
76485: PUSH
76486: LD_VAR 0 6
76490: PUSH
76491: LD_INT 10
76493: ARRAY
76494: ST_TO_ADDR
// end else
76495: GO 76577
// begin f_ignore_area := false ;
76497: LD_ADDR_VAR 0 17
76501: PUSH
76502: LD_INT 0
76504: ST_TO_ADDR
// f_capture := false ;
76505: LD_ADDR_VAR 0 18
76509: PUSH
76510: LD_INT 0
76512: ST_TO_ADDR
// f_ignore_civ := false ;
76513: LD_ADDR_VAR 0 19
76517: PUSH
76518: LD_INT 0
76520: ST_TO_ADDR
// f_murder := false ;
76521: LD_ADDR_VAR 0 20
76525: PUSH
76526: LD_INT 0
76528: ST_TO_ADDR
// f_mines := false ;
76529: LD_ADDR_VAR 0 21
76533: PUSH
76534: LD_INT 0
76536: ST_TO_ADDR
// f_repair := false ;
76537: LD_ADDR_VAR 0 22
76541: PUSH
76542: LD_INT 0
76544: ST_TO_ADDR
// f_heal := false ;
76545: LD_ADDR_VAR 0 23
76549: PUSH
76550: LD_INT 0
76552: ST_TO_ADDR
// f_spacetime := false ;
76553: LD_ADDR_VAR 0 24
76557: PUSH
76558: LD_INT 0
76560: ST_TO_ADDR
// f_attack_depot := false ;
76561: LD_ADDR_VAR 0 25
76565: PUSH
76566: LD_INT 0
76568: ST_TO_ADDR
// f_crawl := false ;
76569: LD_ADDR_VAR 0 26
76573: PUSH
76574: LD_INT 0
76576: ST_TO_ADDR
// end ; if f_heal then
76577: LD_VAR 0 23
76581: IFFALSE 76608
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
76583: LD_ADDR_VAR 0 31
76587: PUSH
76588: LD_VAR 0 4
76592: PPUSH
76593: LD_INT 25
76595: PUSH
76596: LD_INT 4
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PPUSH
76603: CALL_OW 72
76607: ST_TO_ADDR
// if f_repair then
76608: LD_VAR 0 22
76612: IFFALSE 76639
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
76614: LD_ADDR_VAR 0 33
76618: PUSH
76619: LD_VAR 0 4
76623: PPUSH
76624: LD_INT 25
76626: PUSH
76627: LD_INT 3
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PPUSH
76634: CALL_OW 72
76638: ST_TO_ADDR
// units_path := [ ] ;
76639: LD_ADDR_VAR 0 16
76643: PUSH
76644: EMPTY
76645: ST_TO_ADDR
// for i = 1 to group do
76646: LD_ADDR_VAR 0 7
76650: PUSH
76651: DOUBLE
76652: LD_INT 1
76654: DEC
76655: ST_TO_ADDR
76656: LD_VAR 0 4
76660: PUSH
76661: FOR_TO
76662: IFFALSE 76691
// units_path := Replace ( units_path , i , path ) ;
76664: LD_ADDR_VAR 0 16
76668: PUSH
76669: LD_VAR 0 16
76673: PPUSH
76674: LD_VAR 0 7
76678: PPUSH
76679: LD_VAR 0 5
76683: PPUSH
76684: CALL_OW 1
76688: ST_TO_ADDR
76689: GO 76661
76691: POP
76692: POP
// repeat for i = group downto 1 do
76693: LD_ADDR_VAR 0 7
76697: PUSH
76698: DOUBLE
76699: LD_VAR 0 4
76703: INC
76704: ST_TO_ADDR
76705: LD_INT 1
76707: PUSH
76708: FOR_DOWNTO
76709: IFFALSE 80805
// begin wait ( 5 ) ;
76711: LD_INT 5
76713: PPUSH
76714: CALL_OW 67
// tmp := [ ] ;
76718: LD_ADDR_VAR 0 14
76722: PUSH
76723: EMPTY
76724: ST_TO_ADDR
// attacking := false ;
76725: LD_ADDR_VAR 0 29
76729: PUSH
76730: LD_INT 0
76732: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
76733: LD_VAR 0 4
76737: PUSH
76738: LD_VAR 0 7
76742: ARRAY
76743: PPUSH
76744: CALL_OW 301
76748: PUSH
76749: LD_VAR 0 4
76753: PUSH
76754: LD_VAR 0 7
76758: ARRAY
76759: NOT
76760: OR
76761: IFFALSE 76870
// begin if GetType ( group [ i ] ) = unit_human then
76763: LD_VAR 0 4
76767: PUSH
76768: LD_VAR 0 7
76772: ARRAY
76773: PPUSH
76774: CALL_OW 247
76778: PUSH
76779: LD_INT 1
76781: EQUAL
76782: IFFALSE 76828
// begin to_heal := to_heal diff group [ i ] ;
76784: LD_ADDR_VAR 0 30
76788: PUSH
76789: LD_VAR 0 30
76793: PUSH
76794: LD_VAR 0 4
76798: PUSH
76799: LD_VAR 0 7
76803: ARRAY
76804: DIFF
76805: ST_TO_ADDR
// healers := healers diff group [ i ] ;
76806: LD_ADDR_VAR 0 31
76810: PUSH
76811: LD_VAR 0 31
76815: PUSH
76816: LD_VAR 0 4
76820: PUSH
76821: LD_VAR 0 7
76825: ARRAY
76826: DIFF
76827: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
76828: LD_ADDR_VAR 0 4
76832: PUSH
76833: LD_VAR 0 4
76837: PPUSH
76838: LD_VAR 0 7
76842: PPUSH
76843: CALL_OW 3
76847: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
76848: LD_ADDR_VAR 0 16
76852: PUSH
76853: LD_VAR 0 16
76857: PPUSH
76858: LD_VAR 0 7
76862: PPUSH
76863: CALL_OW 3
76867: ST_TO_ADDR
// continue ;
76868: GO 76708
// end ; if f_repair then
76870: LD_VAR 0 22
76874: IFFALSE 77363
// begin if GetType ( group [ i ] ) = unit_vehicle then
76876: LD_VAR 0 4
76880: PUSH
76881: LD_VAR 0 7
76885: ARRAY
76886: PPUSH
76887: CALL_OW 247
76891: PUSH
76892: LD_INT 2
76894: EQUAL
76895: IFFALSE 77085
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
76897: LD_VAR 0 4
76901: PUSH
76902: LD_VAR 0 7
76906: ARRAY
76907: PPUSH
76908: CALL_OW 256
76912: PUSH
76913: LD_INT 700
76915: LESS
76916: PUSH
76917: LD_VAR 0 4
76921: PUSH
76922: LD_VAR 0 7
76926: ARRAY
76927: PUSH
76928: LD_VAR 0 32
76932: IN
76933: NOT
76934: AND
76935: IFFALSE 76959
// to_repair := to_repair union group [ i ] ;
76937: LD_ADDR_VAR 0 32
76941: PUSH
76942: LD_VAR 0 32
76946: PUSH
76947: LD_VAR 0 4
76951: PUSH
76952: LD_VAR 0 7
76956: ARRAY
76957: UNION
76958: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
76959: LD_VAR 0 4
76963: PUSH
76964: LD_VAR 0 7
76968: ARRAY
76969: PPUSH
76970: CALL_OW 256
76974: PUSH
76975: LD_INT 1000
76977: EQUAL
76978: PUSH
76979: LD_VAR 0 4
76983: PUSH
76984: LD_VAR 0 7
76988: ARRAY
76989: PUSH
76990: LD_VAR 0 32
76994: IN
76995: AND
76996: IFFALSE 77020
// to_repair := to_repair diff group [ i ] ;
76998: LD_ADDR_VAR 0 32
77002: PUSH
77003: LD_VAR 0 32
77007: PUSH
77008: LD_VAR 0 4
77012: PUSH
77013: LD_VAR 0 7
77017: ARRAY
77018: DIFF
77019: ST_TO_ADDR
// if group [ i ] in to_repair then
77020: LD_VAR 0 4
77024: PUSH
77025: LD_VAR 0 7
77029: ARRAY
77030: PUSH
77031: LD_VAR 0 32
77035: IN
77036: IFFALSE 77083
// begin if not IsInArea ( group [ i ] , f_repair ) then
77038: LD_VAR 0 4
77042: PUSH
77043: LD_VAR 0 7
77047: ARRAY
77048: PPUSH
77049: LD_VAR 0 22
77053: PPUSH
77054: CALL_OW 308
77058: NOT
77059: IFFALSE 77081
// ComMoveToArea ( group [ i ] , f_repair ) ;
77061: LD_VAR 0 4
77065: PUSH
77066: LD_VAR 0 7
77070: ARRAY
77071: PPUSH
77072: LD_VAR 0 22
77076: PPUSH
77077: CALL_OW 113
// continue ;
77081: GO 76708
// end ; end else
77083: GO 77363
// if group [ i ] in repairs then
77085: LD_VAR 0 4
77089: PUSH
77090: LD_VAR 0 7
77094: ARRAY
77095: PUSH
77096: LD_VAR 0 33
77100: IN
77101: IFFALSE 77363
// begin if IsInUnit ( group [ i ] ) then
77103: LD_VAR 0 4
77107: PUSH
77108: LD_VAR 0 7
77112: ARRAY
77113: PPUSH
77114: CALL_OW 310
77118: IFFALSE 77186
// begin z := IsInUnit ( group [ i ] ) ;
77120: LD_ADDR_VAR 0 13
77124: PUSH
77125: LD_VAR 0 4
77129: PUSH
77130: LD_VAR 0 7
77134: ARRAY
77135: PPUSH
77136: CALL_OW 310
77140: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
77141: LD_VAR 0 13
77145: PUSH
77146: LD_VAR 0 32
77150: IN
77151: PUSH
77152: LD_VAR 0 13
77156: PPUSH
77157: LD_VAR 0 22
77161: PPUSH
77162: CALL_OW 308
77166: AND
77167: IFFALSE 77184
// ComExitVehicle ( group [ i ] ) ;
77169: LD_VAR 0 4
77173: PUSH
77174: LD_VAR 0 7
77178: ARRAY
77179: PPUSH
77180: CALL_OW 121
// end else
77184: GO 77363
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
77186: LD_ADDR_VAR 0 13
77190: PUSH
77191: LD_VAR 0 4
77195: PPUSH
77196: LD_INT 95
77198: PUSH
77199: LD_VAR 0 22
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: LD_INT 58
77210: PUSH
77211: EMPTY
77212: LIST
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PPUSH
77218: CALL_OW 72
77222: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
77223: LD_VAR 0 4
77227: PUSH
77228: LD_VAR 0 7
77232: ARRAY
77233: PPUSH
77234: CALL_OW 314
77238: NOT
77239: IFFALSE 77361
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
77241: LD_ADDR_VAR 0 10
77245: PUSH
77246: LD_VAR 0 13
77250: PPUSH
77251: LD_VAR 0 4
77255: PUSH
77256: LD_VAR 0 7
77260: ARRAY
77261: PPUSH
77262: CALL_OW 74
77266: ST_TO_ADDR
// if not x then
77267: LD_VAR 0 10
77271: NOT
77272: IFFALSE 77276
// continue ;
77274: GO 76708
// if GetLives ( x ) < 1000 then
77276: LD_VAR 0 10
77280: PPUSH
77281: CALL_OW 256
77285: PUSH
77286: LD_INT 1000
77288: LESS
77289: IFFALSE 77313
// ComRepairVehicle ( group [ i ] , x ) else
77291: LD_VAR 0 4
77295: PUSH
77296: LD_VAR 0 7
77300: ARRAY
77301: PPUSH
77302: LD_VAR 0 10
77306: PPUSH
77307: CALL_OW 129
77311: GO 77361
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
77313: LD_VAR 0 23
77317: PUSH
77318: LD_VAR 0 4
77322: PUSH
77323: LD_VAR 0 7
77327: ARRAY
77328: PPUSH
77329: CALL_OW 256
77333: PUSH
77334: LD_INT 1000
77336: LESS
77337: AND
77338: NOT
77339: IFFALSE 77361
// ComEnterUnit ( group [ i ] , x ) ;
77341: LD_VAR 0 4
77345: PUSH
77346: LD_VAR 0 7
77350: ARRAY
77351: PPUSH
77352: LD_VAR 0 10
77356: PPUSH
77357: CALL_OW 120
// end ; continue ;
77361: GO 76708
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
77363: LD_VAR 0 23
77367: PUSH
77368: LD_VAR 0 4
77372: PUSH
77373: LD_VAR 0 7
77377: ARRAY
77378: PPUSH
77379: CALL_OW 247
77383: PUSH
77384: LD_INT 1
77386: EQUAL
77387: AND
77388: IFFALSE 77866
// begin if group [ i ] in healers then
77390: LD_VAR 0 4
77394: PUSH
77395: LD_VAR 0 7
77399: ARRAY
77400: PUSH
77401: LD_VAR 0 31
77405: IN
77406: IFFALSE 77679
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
77408: LD_VAR 0 4
77412: PUSH
77413: LD_VAR 0 7
77417: ARRAY
77418: PPUSH
77419: LD_VAR 0 23
77423: PPUSH
77424: CALL_OW 308
77428: NOT
77429: PUSH
77430: LD_VAR 0 4
77434: PUSH
77435: LD_VAR 0 7
77439: ARRAY
77440: PPUSH
77441: CALL_OW 314
77445: NOT
77446: AND
77447: IFFALSE 77471
// ComMoveToArea ( group [ i ] , f_heal ) else
77449: LD_VAR 0 4
77453: PUSH
77454: LD_VAR 0 7
77458: ARRAY
77459: PPUSH
77460: LD_VAR 0 23
77464: PPUSH
77465: CALL_OW 113
77469: GO 77677
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
77471: LD_VAR 0 4
77475: PUSH
77476: LD_VAR 0 7
77480: ARRAY
77481: PPUSH
77482: CALL 76109 0 1
77486: PPUSH
77487: CALL_OW 256
77491: PUSH
77492: LD_INT 1000
77494: EQUAL
77495: IFFALSE 77514
// ComStop ( group [ i ] ) else
77497: LD_VAR 0 4
77501: PUSH
77502: LD_VAR 0 7
77506: ARRAY
77507: PPUSH
77508: CALL_OW 141
77512: GO 77677
// if not HasTask ( group [ i ] ) and to_heal then
77514: LD_VAR 0 4
77518: PUSH
77519: LD_VAR 0 7
77523: ARRAY
77524: PPUSH
77525: CALL_OW 314
77529: NOT
77530: PUSH
77531: LD_VAR 0 30
77535: AND
77536: IFFALSE 77677
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
77538: LD_ADDR_VAR 0 13
77542: PUSH
77543: LD_VAR 0 30
77547: PPUSH
77548: LD_INT 3
77550: PUSH
77551: LD_INT 54
77553: PUSH
77554: EMPTY
77555: LIST
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PPUSH
77561: CALL_OW 72
77565: PPUSH
77566: LD_VAR 0 4
77570: PUSH
77571: LD_VAR 0 7
77575: ARRAY
77576: PPUSH
77577: CALL_OW 74
77581: ST_TO_ADDR
// if z then
77582: LD_VAR 0 13
77586: IFFALSE 77677
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
77588: LD_INT 91
77590: PUSH
77591: LD_VAR 0 13
77595: PUSH
77596: LD_INT 10
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 81
77606: PUSH
77607: LD_VAR 0 13
77611: PPUSH
77612: CALL_OW 255
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PPUSH
77625: CALL_OW 69
77629: PUSH
77630: LD_INT 0
77632: EQUAL
77633: IFFALSE 77657
// ComHeal ( group [ i ] , z ) else
77635: LD_VAR 0 4
77639: PUSH
77640: LD_VAR 0 7
77644: ARRAY
77645: PPUSH
77646: LD_VAR 0 13
77650: PPUSH
77651: CALL_OW 128
77655: GO 77677
// ComMoveToArea ( group [ i ] , f_heal ) ;
77657: LD_VAR 0 4
77661: PUSH
77662: LD_VAR 0 7
77666: ARRAY
77667: PPUSH
77668: LD_VAR 0 23
77672: PPUSH
77673: CALL_OW 113
// end ; continue ;
77677: GO 76708
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
77679: LD_VAR 0 4
77683: PUSH
77684: LD_VAR 0 7
77688: ARRAY
77689: PPUSH
77690: CALL_OW 256
77694: PUSH
77695: LD_INT 700
77697: LESS
77698: PUSH
77699: LD_VAR 0 4
77703: PUSH
77704: LD_VAR 0 7
77708: ARRAY
77709: PUSH
77710: LD_VAR 0 30
77714: IN
77715: NOT
77716: AND
77717: IFFALSE 77741
// to_heal := to_heal union group [ i ] ;
77719: LD_ADDR_VAR 0 30
77723: PUSH
77724: LD_VAR 0 30
77728: PUSH
77729: LD_VAR 0 4
77733: PUSH
77734: LD_VAR 0 7
77738: ARRAY
77739: UNION
77740: ST_TO_ADDR
// if group [ i ] in to_heal then
77741: LD_VAR 0 4
77745: PUSH
77746: LD_VAR 0 7
77750: ARRAY
77751: PUSH
77752: LD_VAR 0 30
77756: IN
77757: IFFALSE 77866
// begin if GetLives ( group [ i ] ) = 1000 then
77759: LD_VAR 0 4
77763: PUSH
77764: LD_VAR 0 7
77768: ARRAY
77769: PPUSH
77770: CALL_OW 256
77774: PUSH
77775: LD_INT 1000
77777: EQUAL
77778: IFFALSE 77804
// to_heal := to_heal diff group [ i ] else
77780: LD_ADDR_VAR 0 30
77784: PUSH
77785: LD_VAR 0 30
77789: PUSH
77790: LD_VAR 0 4
77794: PUSH
77795: LD_VAR 0 7
77799: ARRAY
77800: DIFF
77801: ST_TO_ADDR
77802: GO 77866
// begin if not IsInArea ( group [ i ] , to_heal ) then
77804: LD_VAR 0 4
77808: PUSH
77809: LD_VAR 0 7
77813: ARRAY
77814: PPUSH
77815: LD_VAR 0 30
77819: PPUSH
77820: CALL_OW 308
77824: NOT
77825: IFFALSE 77849
// ComMoveToArea ( group [ i ] , f_heal ) else
77827: LD_VAR 0 4
77831: PUSH
77832: LD_VAR 0 7
77836: ARRAY
77837: PPUSH
77838: LD_VAR 0 23
77842: PPUSH
77843: CALL_OW 113
77847: GO 77864
// ComHold ( group [ i ] ) ;
77849: LD_VAR 0 4
77853: PUSH
77854: LD_VAR 0 7
77858: ARRAY
77859: PPUSH
77860: CALL_OW 140
// continue ;
77864: GO 76708
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
77866: LD_VAR 0 4
77870: PUSH
77871: LD_VAR 0 7
77875: ARRAY
77876: PPUSH
77877: LD_INT 10
77879: PPUSH
77880: CALL 74506 0 2
77884: NOT
77885: PUSH
77886: LD_VAR 0 16
77890: PUSH
77891: LD_VAR 0 7
77895: ARRAY
77896: PUSH
77897: EMPTY
77898: EQUAL
77899: NOT
77900: AND
77901: IFFALSE 78167
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
77903: LD_VAR 0 4
77907: PUSH
77908: LD_VAR 0 7
77912: ARRAY
77913: PPUSH
77914: CALL_OW 262
77918: PUSH
77919: LD_INT 1
77921: PUSH
77922: LD_INT 2
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: IN
77929: IFFALSE 77970
// if GetFuel ( group [ i ] ) < 10 then
77931: LD_VAR 0 4
77935: PUSH
77936: LD_VAR 0 7
77940: ARRAY
77941: PPUSH
77942: CALL_OW 261
77946: PUSH
77947: LD_INT 10
77949: LESS
77950: IFFALSE 77970
// SetFuel ( group [ i ] , 12 ) ;
77952: LD_VAR 0 4
77956: PUSH
77957: LD_VAR 0 7
77961: ARRAY
77962: PPUSH
77963: LD_INT 12
77965: PPUSH
77966: CALL_OW 240
// if units_path [ i ] then
77970: LD_VAR 0 16
77974: PUSH
77975: LD_VAR 0 7
77979: ARRAY
77980: IFFALSE 78165
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
77982: LD_VAR 0 4
77986: PUSH
77987: LD_VAR 0 7
77991: ARRAY
77992: PPUSH
77993: LD_VAR 0 16
77997: PUSH
77998: LD_VAR 0 7
78002: ARRAY
78003: PUSH
78004: LD_INT 1
78006: ARRAY
78007: PUSH
78008: LD_INT 1
78010: ARRAY
78011: PPUSH
78012: LD_VAR 0 16
78016: PUSH
78017: LD_VAR 0 7
78021: ARRAY
78022: PUSH
78023: LD_INT 1
78025: ARRAY
78026: PUSH
78027: LD_INT 2
78029: ARRAY
78030: PPUSH
78031: CALL_OW 297
78035: PUSH
78036: LD_INT 6
78038: GREATER
78039: IFFALSE 78114
// begin if not HasTask ( group [ i ] ) then
78041: LD_VAR 0 4
78045: PUSH
78046: LD_VAR 0 7
78050: ARRAY
78051: PPUSH
78052: CALL_OW 314
78056: NOT
78057: IFFALSE 78112
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
78059: LD_VAR 0 4
78063: PUSH
78064: LD_VAR 0 7
78068: ARRAY
78069: PPUSH
78070: LD_VAR 0 16
78074: PUSH
78075: LD_VAR 0 7
78079: ARRAY
78080: PUSH
78081: LD_INT 1
78083: ARRAY
78084: PUSH
78085: LD_INT 1
78087: ARRAY
78088: PPUSH
78089: LD_VAR 0 16
78093: PUSH
78094: LD_VAR 0 7
78098: ARRAY
78099: PUSH
78100: LD_INT 1
78102: ARRAY
78103: PUSH
78104: LD_INT 2
78106: ARRAY
78107: PPUSH
78108: CALL_OW 114
// end else
78112: GO 78165
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
78114: LD_ADDR_VAR 0 15
78118: PUSH
78119: LD_VAR 0 16
78123: PUSH
78124: LD_VAR 0 7
78128: ARRAY
78129: PPUSH
78130: LD_INT 1
78132: PPUSH
78133: CALL_OW 3
78137: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
78138: LD_ADDR_VAR 0 16
78142: PUSH
78143: LD_VAR 0 16
78147: PPUSH
78148: LD_VAR 0 7
78152: PPUSH
78153: LD_VAR 0 15
78157: PPUSH
78158: CALL_OW 1
78162: ST_TO_ADDR
// continue ;
78163: GO 76708
// end ; end ; end else
78165: GO 80803
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
78167: LD_ADDR_VAR 0 14
78171: PUSH
78172: LD_INT 81
78174: PUSH
78175: LD_VAR 0 4
78179: PUSH
78180: LD_VAR 0 7
78184: ARRAY
78185: PPUSH
78186: CALL_OW 255
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PPUSH
78195: CALL_OW 69
78199: ST_TO_ADDR
// if not tmp then
78200: LD_VAR 0 14
78204: NOT
78205: IFFALSE 78209
// continue ;
78207: GO 76708
// if f_ignore_area then
78209: LD_VAR 0 17
78213: IFFALSE 78301
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
78215: LD_ADDR_VAR 0 15
78219: PUSH
78220: LD_VAR 0 14
78224: PPUSH
78225: LD_INT 3
78227: PUSH
78228: LD_INT 92
78230: PUSH
78231: LD_VAR 0 17
78235: PUSH
78236: LD_INT 1
78238: ARRAY
78239: PUSH
78240: LD_VAR 0 17
78244: PUSH
78245: LD_INT 2
78247: ARRAY
78248: PUSH
78249: LD_VAR 0 17
78253: PUSH
78254: LD_INT 3
78256: ARRAY
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PPUSH
78268: CALL_OW 72
78272: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
78273: LD_VAR 0 14
78277: PUSH
78278: LD_VAR 0 15
78282: DIFF
78283: IFFALSE 78301
// tmp := tmp diff tmp2 ;
78285: LD_ADDR_VAR 0 14
78289: PUSH
78290: LD_VAR 0 14
78294: PUSH
78295: LD_VAR 0 15
78299: DIFF
78300: ST_TO_ADDR
// end ; if not f_murder then
78301: LD_VAR 0 20
78305: NOT
78306: IFFALSE 78364
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
78308: LD_ADDR_VAR 0 15
78312: PUSH
78313: LD_VAR 0 14
78317: PPUSH
78318: LD_INT 3
78320: PUSH
78321: LD_INT 50
78323: PUSH
78324: EMPTY
78325: LIST
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PPUSH
78331: CALL_OW 72
78335: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
78336: LD_VAR 0 14
78340: PUSH
78341: LD_VAR 0 15
78345: DIFF
78346: IFFALSE 78364
// tmp := tmp diff tmp2 ;
78348: LD_ADDR_VAR 0 14
78352: PUSH
78353: LD_VAR 0 14
78357: PUSH
78358: LD_VAR 0 15
78362: DIFF
78363: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
78364: LD_ADDR_VAR 0 14
78368: PUSH
78369: LD_VAR 0 4
78373: PUSH
78374: LD_VAR 0 7
78378: ARRAY
78379: PPUSH
78380: LD_VAR 0 14
78384: PPUSH
78385: LD_INT 1
78387: PPUSH
78388: LD_INT 1
78390: PPUSH
78391: CALL 48173 0 4
78395: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
78396: LD_VAR 0 4
78400: PUSH
78401: LD_VAR 0 7
78405: ARRAY
78406: PPUSH
78407: CALL_OW 257
78411: PUSH
78412: LD_INT 1
78414: EQUAL
78415: IFFALSE 78863
// begin if WantPlant ( group [ i ] ) then
78417: LD_VAR 0 4
78421: PUSH
78422: LD_VAR 0 7
78426: ARRAY
78427: PPUSH
78428: CALL 47674 0 1
78432: IFFALSE 78436
// continue ;
78434: GO 76708
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
78436: LD_VAR 0 18
78440: PUSH
78441: LD_VAR 0 4
78445: PUSH
78446: LD_VAR 0 7
78450: ARRAY
78451: PPUSH
78452: CALL_OW 310
78456: NOT
78457: AND
78458: PUSH
78459: LD_VAR 0 14
78463: PUSH
78464: LD_INT 1
78466: ARRAY
78467: PUSH
78468: LD_VAR 0 14
78472: PPUSH
78473: LD_INT 21
78475: PUSH
78476: LD_INT 2
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 58
78485: PUSH
78486: EMPTY
78487: LIST
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PPUSH
78493: CALL_OW 72
78497: IN
78498: AND
78499: IFFALSE 78535
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
78501: LD_VAR 0 4
78505: PUSH
78506: LD_VAR 0 7
78510: ARRAY
78511: PPUSH
78512: LD_VAR 0 14
78516: PUSH
78517: LD_INT 1
78519: ARRAY
78520: PPUSH
78521: CALL_OW 120
// attacking := true ;
78525: LD_ADDR_VAR 0 29
78529: PUSH
78530: LD_INT 1
78532: ST_TO_ADDR
// continue ;
78533: GO 76708
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
78535: LD_VAR 0 26
78539: PUSH
78540: LD_VAR 0 4
78544: PUSH
78545: LD_VAR 0 7
78549: ARRAY
78550: PPUSH
78551: CALL_OW 257
78555: PUSH
78556: LD_INT 1
78558: EQUAL
78559: AND
78560: PUSH
78561: LD_VAR 0 4
78565: PUSH
78566: LD_VAR 0 7
78570: ARRAY
78571: PPUSH
78572: CALL_OW 256
78576: PUSH
78577: LD_INT 800
78579: LESS
78580: AND
78581: PUSH
78582: LD_VAR 0 4
78586: PUSH
78587: LD_VAR 0 7
78591: ARRAY
78592: PPUSH
78593: CALL_OW 318
78597: NOT
78598: AND
78599: IFFALSE 78616
// ComCrawl ( group [ i ] ) ;
78601: LD_VAR 0 4
78605: PUSH
78606: LD_VAR 0 7
78610: ARRAY
78611: PPUSH
78612: CALL_OW 137
// if f_mines then
78616: LD_VAR 0 21
78620: IFFALSE 78863
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
78622: LD_VAR 0 14
78626: PUSH
78627: LD_INT 1
78629: ARRAY
78630: PPUSH
78631: CALL_OW 247
78635: PUSH
78636: LD_INT 3
78638: EQUAL
78639: PUSH
78640: LD_VAR 0 14
78644: PUSH
78645: LD_INT 1
78647: ARRAY
78648: PUSH
78649: LD_VAR 0 27
78653: IN
78654: NOT
78655: AND
78656: IFFALSE 78863
// begin x := GetX ( tmp [ 1 ] ) ;
78658: LD_ADDR_VAR 0 10
78662: PUSH
78663: LD_VAR 0 14
78667: PUSH
78668: LD_INT 1
78670: ARRAY
78671: PPUSH
78672: CALL_OW 250
78676: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
78677: LD_ADDR_VAR 0 11
78681: PUSH
78682: LD_VAR 0 14
78686: PUSH
78687: LD_INT 1
78689: ARRAY
78690: PPUSH
78691: CALL_OW 251
78695: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
78696: LD_ADDR_VAR 0 12
78700: PUSH
78701: LD_VAR 0 4
78705: PUSH
78706: LD_VAR 0 7
78710: ARRAY
78711: PPUSH
78712: CALL 74591 0 1
78716: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
78717: LD_VAR 0 4
78721: PUSH
78722: LD_VAR 0 7
78726: ARRAY
78727: PPUSH
78728: LD_VAR 0 10
78732: PPUSH
78733: LD_VAR 0 11
78737: PPUSH
78738: LD_VAR 0 14
78742: PUSH
78743: LD_INT 1
78745: ARRAY
78746: PPUSH
78747: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
78751: LD_VAR 0 4
78755: PUSH
78756: LD_VAR 0 7
78760: ARRAY
78761: PPUSH
78762: LD_VAR 0 10
78766: PPUSH
78767: LD_VAR 0 12
78771: PPUSH
78772: LD_INT 7
78774: PPUSH
78775: CALL_OW 272
78779: PPUSH
78780: LD_VAR 0 11
78784: PPUSH
78785: LD_VAR 0 12
78789: PPUSH
78790: LD_INT 7
78792: PPUSH
78793: CALL_OW 273
78797: PPUSH
78798: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
78802: LD_VAR 0 4
78806: PUSH
78807: LD_VAR 0 7
78811: ARRAY
78812: PPUSH
78813: LD_INT 71
78815: PPUSH
78816: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
78820: LD_ADDR_VAR 0 27
78824: PUSH
78825: LD_VAR 0 27
78829: PPUSH
78830: LD_VAR 0 27
78834: PUSH
78835: LD_INT 1
78837: PLUS
78838: PPUSH
78839: LD_VAR 0 14
78843: PUSH
78844: LD_INT 1
78846: ARRAY
78847: PPUSH
78848: CALL_OW 1
78852: ST_TO_ADDR
// attacking := true ;
78853: LD_ADDR_VAR 0 29
78857: PUSH
78858: LD_INT 1
78860: ST_TO_ADDR
// continue ;
78861: GO 76708
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
78863: LD_VAR 0 4
78867: PUSH
78868: LD_VAR 0 7
78872: ARRAY
78873: PPUSH
78874: CALL_OW 257
78878: PUSH
78879: LD_INT 17
78881: EQUAL
78882: PUSH
78883: LD_VAR 0 4
78887: PUSH
78888: LD_VAR 0 7
78892: ARRAY
78893: PPUSH
78894: CALL_OW 110
78898: PUSH
78899: LD_INT 71
78901: EQUAL
78902: NOT
78903: AND
78904: IFFALSE 79050
// begin attacking := false ;
78906: LD_ADDR_VAR 0 29
78910: PUSH
78911: LD_INT 0
78913: ST_TO_ADDR
// k := 5 ;
78914: LD_ADDR_VAR 0 9
78918: PUSH
78919: LD_INT 5
78921: ST_TO_ADDR
// if tmp < k then
78922: LD_VAR 0 14
78926: PUSH
78927: LD_VAR 0 9
78931: LESS
78932: IFFALSE 78944
// k := tmp ;
78934: LD_ADDR_VAR 0 9
78938: PUSH
78939: LD_VAR 0 14
78943: ST_TO_ADDR
// for j = 1 to k do
78944: LD_ADDR_VAR 0 8
78948: PUSH
78949: DOUBLE
78950: LD_INT 1
78952: DEC
78953: ST_TO_ADDR
78954: LD_VAR 0 9
78958: PUSH
78959: FOR_TO
78960: IFFALSE 79048
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
78962: LD_VAR 0 14
78966: PUSH
78967: LD_VAR 0 8
78971: ARRAY
78972: PUSH
78973: LD_VAR 0 14
78977: PPUSH
78978: LD_INT 58
78980: PUSH
78981: EMPTY
78982: LIST
78983: PPUSH
78984: CALL_OW 72
78988: IN
78989: NOT
78990: IFFALSE 79046
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
78992: LD_VAR 0 4
78996: PUSH
78997: LD_VAR 0 7
79001: ARRAY
79002: PPUSH
79003: LD_VAR 0 14
79007: PUSH
79008: LD_VAR 0 8
79012: ARRAY
79013: PPUSH
79014: CALL_OW 115
// attacking := true ;
79018: LD_ADDR_VAR 0 29
79022: PUSH
79023: LD_INT 1
79025: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
79026: LD_VAR 0 4
79030: PUSH
79031: LD_VAR 0 7
79035: ARRAY
79036: PPUSH
79037: LD_INT 71
79039: PPUSH
79040: CALL_OW 109
// continue ;
79044: GO 78959
// end ; end ;
79046: GO 78959
79048: POP
79049: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
79050: LD_VAR 0 4
79054: PUSH
79055: LD_VAR 0 7
79059: ARRAY
79060: PPUSH
79061: CALL_OW 257
79065: PUSH
79066: LD_INT 8
79068: EQUAL
79069: PUSH
79070: LD_VAR 0 4
79074: PUSH
79075: LD_VAR 0 7
79079: ARRAY
79080: PPUSH
79081: CALL_OW 264
79085: PUSH
79086: LD_INT 28
79088: PUSH
79089: LD_INT 45
79091: PUSH
79092: LD_INT 7
79094: PUSH
79095: LD_INT 47
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: IN
79104: OR
79105: IFFALSE 79335
// begin attacking := false ;
79107: LD_ADDR_VAR 0 29
79111: PUSH
79112: LD_INT 0
79114: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
79115: LD_VAR 0 14
79119: PUSH
79120: LD_INT 1
79122: ARRAY
79123: PPUSH
79124: CALL_OW 266
79128: PUSH
79129: LD_INT 32
79131: PUSH
79132: LD_INT 31
79134: PUSH
79135: LD_INT 33
79137: PUSH
79138: LD_INT 4
79140: PUSH
79141: LD_INT 5
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: IN
79151: IFFALSE 79335
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
79153: LD_ADDR_VAR 0 9
79157: PUSH
79158: LD_VAR 0 14
79162: PUSH
79163: LD_INT 1
79165: ARRAY
79166: PPUSH
79167: CALL_OW 266
79171: PPUSH
79172: LD_VAR 0 14
79176: PUSH
79177: LD_INT 1
79179: ARRAY
79180: PPUSH
79181: CALL_OW 250
79185: PPUSH
79186: LD_VAR 0 14
79190: PUSH
79191: LD_INT 1
79193: ARRAY
79194: PPUSH
79195: CALL_OW 251
79199: PPUSH
79200: LD_VAR 0 14
79204: PUSH
79205: LD_INT 1
79207: ARRAY
79208: PPUSH
79209: CALL_OW 254
79213: PPUSH
79214: LD_VAR 0 14
79218: PUSH
79219: LD_INT 1
79221: ARRAY
79222: PPUSH
79223: CALL_OW 248
79227: PPUSH
79228: LD_INT 0
79230: PPUSH
79231: CALL 55967 0 6
79235: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
79236: LD_ADDR_VAR 0 8
79240: PUSH
79241: LD_VAR 0 4
79245: PUSH
79246: LD_VAR 0 7
79250: ARRAY
79251: PPUSH
79252: LD_VAR 0 9
79256: PPUSH
79257: CALL 74654 0 2
79261: ST_TO_ADDR
// if j then
79262: LD_VAR 0 8
79266: IFFALSE 79335
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79268: LD_VAR 0 8
79272: PUSH
79273: LD_INT 1
79275: ARRAY
79276: PPUSH
79277: LD_VAR 0 8
79281: PUSH
79282: LD_INT 2
79284: ARRAY
79285: PPUSH
79286: CALL_OW 488
79290: IFFALSE 79335
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
79292: LD_VAR 0 4
79296: PUSH
79297: LD_VAR 0 7
79301: ARRAY
79302: PPUSH
79303: LD_VAR 0 8
79307: PUSH
79308: LD_INT 1
79310: ARRAY
79311: PPUSH
79312: LD_VAR 0 8
79316: PUSH
79317: LD_INT 2
79319: ARRAY
79320: PPUSH
79321: CALL_OW 116
// attacking := true ;
79325: LD_ADDR_VAR 0 29
79329: PUSH
79330: LD_INT 1
79332: ST_TO_ADDR
// continue ;
79333: GO 76708
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
79335: LD_VAR 0 4
79339: PUSH
79340: LD_VAR 0 7
79344: ARRAY
79345: PPUSH
79346: CALL_OW 265
79350: PUSH
79351: LD_INT 11
79353: EQUAL
79354: IFFALSE 79632
// begin k := 10 ;
79356: LD_ADDR_VAR 0 9
79360: PUSH
79361: LD_INT 10
79363: ST_TO_ADDR
// x := 0 ;
79364: LD_ADDR_VAR 0 10
79368: PUSH
79369: LD_INT 0
79371: ST_TO_ADDR
// if tmp < k then
79372: LD_VAR 0 14
79376: PUSH
79377: LD_VAR 0 9
79381: LESS
79382: IFFALSE 79394
// k := tmp ;
79384: LD_ADDR_VAR 0 9
79388: PUSH
79389: LD_VAR 0 14
79393: ST_TO_ADDR
// for j = k downto 1 do
79394: LD_ADDR_VAR 0 8
79398: PUSH
79399: DOUBLE
79400: LD_VAR 0 9
79404: INC
79405: ST_TO_ADDR
79406: LD_INT 1
79408: PUSH
79409: FOR_DOWNTO
79410: IFFALSE 79485
// begin if GetType ( tmp [ j ] ) = unit_human then
79412: LD_VAR 0 14
79416: PUSH
79417: LD_VAR 0 8
79421: ARRAY
79422: PPUSH
79423: CALL_OW 247
79427: PUSH
79428: LD_INT 1
79430: EQUAL
79431: IFFALSE 79483
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
79433: LD_VAR 0 4
79437: PUSH
79438: LD_VAR 0 7
79442: ARRAY
79443: PPUSH
79444: LD_VAR 0 14
79448: PUSH
79449: LD_VAR 0 8
79453: ARRAY
79454: PPUSH
79455: CALL 74925 0 2
// x := tmp [ j ] ;
79459: LD_ADDR_VAR 0 10
79463: PUSH
79464: LD_VAR 0 14
79468: PUSH
79469: LD_VAR 0 8
79473: ARRAY
79474: ST_TO_ADDR
// attacking := true ;
79475: LD_ADDR_VAR 0 29
79479: PUSH
79480: LD_INT 1
79482: ST_TO_ADDR
// end ; end ;
79483: GO 79409
79485: POP
79486: POP
// if not x then
79487: LD_VAR 0 10
79491: NOT
79492: IFFALSE 79632
// begin attacking := true ;
79494: LD_ADDR_VAR 0 29
79498: PUSH
79499: LD_INT 1
79501: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
79502: LD_VAR 0 4
79506: PUSH
79507: LD_VAR 0 7
79511: ARRAY
79512: PPUSH
79513: CALL_OW 250
79517: PPUSH
79518: LD_VAR 0 4
79522: PUSH
79523: LD_VAR 0 7
79527: ARRAY
79528: PPUSH
79529: CALL_OW 251
79533: PPUSH
79534: CALL_OW 546
79538: PUSH
79539: LD_INT 2
79541: ARRAY
79542: PUSH
79543: LD_VAR 0 14
79547: PUSH
79548: LD_INT 1
79550: ARRAY
79551: PPUSH
79552: CALL_OW 250
79556: PPUSH
79557: LD_VAR 0 14
79561: PUSH
79562: LD_INT 1
79564: ARRAY
79565: PPUSH
79566: CALL_OW 251
79570: PPUSH
79571: CALL_OW 546
79575: PUSH
79576: LD_INT 2
79578: ARRAY
79579: EQUAL
79580: IFFALSE 79608
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
79582: LD_VAR 0 4
79586: PUSH
79587: LD_VAR 0 7
79591: ARRAY
79592: PPUSH
79593: LD_VAR 0 14
79597: PUSH
79598: LD_INT 1
79600: ARRAY
79601: PPUSH
79602: CALL 74925 0 2
79606: GO 79632
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79608: LD_VAR 0 4
79612: PUSH
79613: LD_VAR 0 7
79617: ARRAY
79618: PPUSH
79619: LD_VAR 0 14
79623: PUSH
79624: LD_INT 1
79626: ARRAY
79627: PPUSH
79628: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
79632: LD_VAR 0 4
79636: PUSH
79637: LD_VAR 0 7
79641: ARRAY
79642: PPUSH
79643: CALL_OW 264
79647: PUSH
79648: LD_INT 29
79650: EQUAL
79651: IFFALSE 80017
// begin if WantsToAttack ( group [ i ] ) in bombed then
79653: LD_VAR 0 4
79657: PUSH
79658: LD_VAR 0 7
79662: ARRAY
79663: PPUSH
79664: CALL_OW 319
79668: PUSH
79669: LD_VAR 0 28
79673: IN
79674: IFFALSE 79678
// continue ;
79676: GO 76708
// k := 8 ;
79678: LD_ADDR_VAR 0 9
79682: PUSH
79683: LD_INT 8
79685: ST_TO_ADDR
// x := 0 ;
79686: LD_ADDR_VAR 0 10
79690: PUSH
79691: LD_INT 0
79693: ST_TO_ADDR
// if tmp < k then
79694: LD_VAR 0 14
79698: PUSH
79699: LD_VAR 0 9
79703: LESS
79704: IFFALSE 79716
// k := tmp ;
79706: LD_ADDR_VAR 0 9
79710: PUSH
79711: LD_VAR 0 14
79715: ST_TO_ADDR
// for j = 1 to k do
79716: LD_ADDR_VAR 0 8
79720: PUSH
79721: DOUBLE
79722: LD_INT 1
79724: DEC
79725: ST_TO_ADDR
79726: LD_VAR 0 9
79730: PUSH
79731: FOR_TO
79732: IFFALSE 79864
// begin if GetType ( tmp [ j ] ) = unit_building then
79734: LD_VAR 0 14
79738: PUSH
79739: LD_VAR 0 8
79743: ARRAY
79744: PPUSH
79745: CALL_OW 247
79749: PUSH
79750: LD_INT 3
79752: EQUAL
79753: IFFALSE 79862
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
79755: LD_VAR 0 14
79759: PUSH
79760: LD_VAR 0 8
79764: ARRAY
79765: PUSH
79766: LD_VAR 0 28
79770: IN
79771: NOT
79772: PUSH
79773: LD_VAR 0 14
79777: PUSH
79778: LD_VAR 0 8
79782: ARRAY
79783: PPUSH
79784: CALL_OW 313
79788: AND
79789: IFFALSE 79862
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79791: LD_VAR 0 4
79795: PUSH
79796: LD_VAR 0 7
79800: ARRAY
79801: PPUSH
79802: LD_VAR 0 14
79806: PUSH
79807: LD_VAR 0 8
79811: ARRAY
79812: PPUSH
79813: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
79817: LD_ADDR_VAR 0 28
79821: PUSH
79822: LD_VAR 0 28
79826: PPUSH
79827: LD_VAR 0 28
79831: PUSH
79832: LD_INT 1
79834: PLUS
79835: PPUSH
79836: LD_VAR 0 14
79840: PUSH
79841: LD_VAR 0 8
79845: ARRAY
79846: PPUSH
79847: CALL_OW 1
79851: ST_TO_ADDR
// attacking := true ;
79852: LD_ADDR_VAR 0 29
79856: PUSH
79857: LD_INT 1
79859: ST_TO_ADDR
// break ;
79860: GO 79864
// end ; end ;
79862: GO 79731
79864: POP
79865: POP
// if not attacking and f_attack_depot then
79866: LD_VAR 0 29
79870: NOT
79871: PUSH
79872: LD_VAR 0 25
79876: AND
79877: IFFALSE 79972
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79879: LD_ADDR_VAR 0 13
79883: PUSH
79884: LD_VAR 0 14
79888: PPUSH
79889: LD_INT 2
79891: PUSH
79892: LD_INT 30
79894: PUSH
79895: LD_INT 0
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 30
79904: PUSH
79905: LD_INT 1
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: LIST
79916: PPUSH
79917: CALL_OW 72
79921: ST_TO_ADDR
// if z then
79922: LD_VAR 0 13
79926: IFFALSE 79972
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
79928: LD_VAR 0 4
79932: PUSH
79933: LD_VAR 0 7
79937: ARRAY
79938: PPUSH
79939: LD_VAR 0 13
79943: PPUSH
79944: LD_VAR 0 4
79948: PUSH
79949: LD_VAR 0 7
79953: ARRAY
79954: PPUSH
79955: CALL_OW 74
79959: PPUSH
79960: CALL_OW 115
// attacking := true ;
79964: LD_ADDR_VAR 0 29
79968: PUSH
79969: LD_INT 1
79971: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
79972: LD_VAR 0 4
79976: PUSH
79977: LD_VAR 0 7
79981: ARRAY
79982: PPUSH
79983: CALL_OW 256
79987: PUSH
79988: LD_INT 500
79990: LESS
79991: IFFALSE 80017
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79993: LD_VAR 0 4
79997: PUSH
79998: LD_VAR 0 7
80002: ARRAY
80003: PPUSH
80004: LD_VAR 0 14
80008: PUSH
80009: LD_INT 1
80011: ARRAY
80012: PPUSH
80013: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
80017: LD_VAR 0 4
80021: PUSH
80022: LD_VAR 0 7
80026: ARRAY
80027: PPUSH
80028: CALL_OW 264
80032: PUSH
80033: LD_INT 49
80035: EQUAL
80036: IFFALSE 80157
// begin if not HasTask ( group [ i ] ) then
80038: LD_VAR 0 4
80042: PUSH
80043: LD_VAR 0 7
80047: ARRAY
80048: PPUSH
80049: CALL_OW 314
80053: NOT
80054: IFFALSE 80157
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
80056: LD_ADDR_VAR 0 9
80060: PUSH
80061: LD_INT 81
80063: PUSH
80064: LD_VAR 0 4
80068: PUSH
80069: LD_VAR 0 7
80073: ARRAY
80074: PPUSH
80075: CALL_OW 255
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PPUSH
80084: CALL_OW 69
80088: PPUSH
80089: LD_VAR 0 4
80093: PUSH
80094: LD_VAR 0 7
80098: ARRAY
80099: PPUSH
80100: CALL_OW 74
80104: ST_TO_ADDR
// if k then
80105: LD_VAR 0 9
80109: IFFALSE 80157
// if GetDistUnits ( group [ i ] , k ) > 10 then
80111: LD_VAR 0 4
80115: PUSH
80116: LD_VAR 0 7
80120: ARRAY
80121: PPUSH
80122: LD_VAR 0 9
80126: PPUSH
80127: CALL_OW 296
80131: PUSH
80132: LD_INT 10
80134: GREATER
80135: IFFALSE 80157
// ComMoveUnit ( group [ i ] , k ) ;
80137: LD_VAR 0 4
80141: PUSH
80142: LD_VAR 0 7
80146: ARRAY
80147: PPUSH
80148: LD_VAR 0 9
80152: PPUSH
80153: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80157: LD_VAR 0 4
80161: PUSH
80162: LD_VAR 0 7
80166: ARRAY
80167: PPUSH
80168: CALL_OW 256
80172: PUSH
80173: LD_INT 250
80175: LESS
80176: PUSH
80177: LD_VAR 0 4
80181: PUSH
80182: LD_VAR 0 7
80186: ARRAY
80187: PUSH
80188: LD_INT 21
80190: PUSH
80191: LD_INT 2
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 23
80200: PUSH
80201: LD_INT 2
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PPUSH
80212: CALL_OW 69
80216: IN
80217: AND
80218: IFFALSE 80343
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
80220: LD_ADDR_VAR 0 9
80224: PUSH
80225: LD_OWVAR 3
80229: PUSH
80230: LD_VAR 0 4
80234: PUSH
80235: LD_VAR 0 7
80239: ARRAY
80240: DIFF
80241: PPUSH
80242: LD_VAR 0 4
80246: PUSH
80247: LD_VAR 0 7
80251: ARRAY
80252: PPUSH
80253: CALL_OW 74
80257: ST_TO_ADDR
// if not k then
80258: LD_VAR 0 9
80262: NOT
80263: IFFALSE 80267
// continue ;
80265: GO 76708
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
80267: LD_VAR 0 9
80271: PUSH
80272: LD_INT 81
80274: PUSH
80275: LD_VAR 0 4
80279: PUSH
80280: LD_VAR 0 7
80284: ARRAY
80285: PPUSH
80286: CALL_OW 255
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PPUSH
80295: CALL_OW 69
80299: IN
80300: PUSH
80301: LD_VAR 0 9
80305: PPUSH
80306: LD_VAR 0 4
80310: PUSH
80311: LD_VAR 0 7
80315: ARRAY
80316: PPUSH
80317: CALL_OW 296
80321: PUSH
80322: LD_INT 5
80324: LESS
80325: AND
80326: IFFALSE 80343
// ComAutodestruct ( group [ i ] ) ;
80328: LD_VAR 0 4
80332: PUSH
80333: LD_VAR 0 7
80337: ARRAY
80338: PPUSH
80339: CALL 74823 0 1
// end ; if f_attack_depot then
80343: LD_VAR 0 25
80347: IFFALSE 80459
// begin k := 6 ;
80349: LD_ADDR_VAR 0 9
80353: PUSH
80354: LD_INT 6
80356: ST_TO_ADDR
// if tmp < k then
80357: LD_VAR 0 14
80361: PUSH
80362: LD_VAR 0 9
80366: LESS
80367: IFFALSE 80379
// k := tmp ;
80369: LD_ADDR_VAR 0 9
80373: PUSH
80374: LD_VAR 0 14
80378: ST_TO_ADDR
// for j = 1 to k do
80379: LD_ADDR_VAR 0 8
80383: PUSH
80384: DOUBLE
80385: LD_INT 1
80387: DEC
80388: ST_TO_ADDR
80389: LD_VAR 0 9
80393: PUSH
80394: FOR_TO
80395: IFFALSE 80457
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
80397: LD_VAR 0 8
80401: PPUSH
80402: CALL_OW 266
80406: PUSH
80407: LD_INT 0
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: IN
80417: IFFALSE 80455
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80419: LD_VAR 0 4
80423: PUSH
80424: LD_VAR 0 7
80428: ARRAY
80429: PPUSH
80430: LD_VAR 0 14
80434: PUSH
80435: LD_VAR 0 8
80439: ARRAY
80440: PPUSH
80441: CALL_OW 115
// attacking := true ;
80445: LD_ADDR_VAR 0 29
80449: PUSH
80450: LD_INT 1
80452: ST_TO_ADDR
// break ;
80453: GO 80457
// end ;
80455: GO 80394
80457: POP
80458: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
80459: LD_VAR 0 4
80463: PUSH
80464: LD_VAR 0 7
80468: ARRAY
80469: PPUSH
80470: CALL_OW 302
80474: PUSH
80475: LD_VAR 0 29
80479: NOT
80480: AND
80481: IFFALSE 80803
// begin if GetTag ( group [ i ] ) = 71 then
80483: LD_VAR 0 4
80487: PUSH
80488: LD_VAR 0 7
80492: ARRAY
80493: PPUSH
80494: CALL_OW 110
80498: PUSH
80499: LD_INT 71
80501: EQUAL
80502: IFFALSE 80543
// begin if HasTask ( group [ i ] ) then
80504: LD_VAR 0 4
80508: PUSH
80509: LD_VAR 0 7
80513: ARRAY
80514: PPUSH
80515: CALL_OW 314
80519: IFFALSE 80525
// continue else
80521: GO 76708
80523: GO 80543
// SetTag ( group [ i ] , 0 ) ;
80525: LD_VAR 0 4
80529: PUSH
80530: LD_VAR 0 7
80534: ARRAY
80535: PPUSH
80536: LD_INT 0
80538: PPUSH
80539: CALL_OW 109
// end ; k := 8 ;
80543: LD_ADDR_VAR 0 9
80547: PUSH
80548: LD_INT 8
80550: ST_TO_ADDR
// x := 0 ;
80551: LD_ADDR_VAR 0 10
80555: PUSH
80556: LD_INT 0
80558: ST_TO_ADDR
// if tmp < k then
80559: LD_VAR 0 14
80563: PUSH
80564: LD_VAR 0 9
80568: LESS
80569: IFFALSE 80581
// k := tmp ;
80571: LD_ADDR_VAR 0 9
80575: PUSH
80576: LD_VAR 0 14
80580: ST_TO_ADDR
// for j = 1 to k do
80581: LD_ADDR_VAR 0 8
80585: PUSH
80586: DOUBLE
80587: LD_INT 1
80589: DEC
80590: ST_TO_ADDR
80591: LD_VAR 0 9
80595: PUSH
80596: FOR_TO
80597: IFFALSE 80695
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
80599: LD_VAR 0 14
80603: PUSH
80604: LD_VAR 0 8
80608: ARRAY
80609: PPUSH
80610: CALL_OW 247
80614: PUSH
80615: LD_INT 1
80617: EQUAL
80618: PUSH
80619: LD_VAR 0 14
80623: PUSH
80624: LD_VAR 0 8
80628: ARRAY
80629: PPUSH
80630: CALL_OW 256
80634: PUSH
80635: LD_INT 250
80637: LESS
80638: PUSH
80639: LD_VAR 0 20
80643: AND
80644: PUSH
80645: LD_VAR 0 20
80649: NOT
80650: PUSH
80651: LD_VAR 0 14
80655: PUSH
80656: LD_VAR 0 8
80660: ARRAY
80661: PPUSH
80662: CALL_OW 256
80666: PUSH
80667: LD_INT 250
80669: GREATEREQUAL
80670: AND
80671: OR
80672: AND
80673: IFFALSE 80693
// begin x := tmp [ j ] ;
80675: LD_ADDR_VAR 0 10
80679: PUSH
80680: LD_VAR 0 14
80684: PUSH
80685: LD_VAR 0 8
80689: ARRAY
80690: ST_TO_ADDR
// break ;
80691: GO 80695
// end ;
80693: GO 80596
80695: POP
80696: POP
// if x then
80697: LD_VAR 0 10
80701: IFFALSE 80725
// ComAttackUnit ( group [ i ] , x ) else
80703: LD_VAR 0 4
80707: PUSH
80708: LD_VAR 0 7
80712: ARRAY
80713: PPUSH
80714: LD_VAR 0 10
80718: PPUSH
80719: CALL_OW 115
80723: GO 80749
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80725: LD_VAR 0 4
80729: PUSH
80730: LD_VAR 0 7
80734: ARRAY
80735: PPUSH
80736: LD_VAR 0 14
80740: PUSH
80741: LD_INT 1
80743: ARRAY
80744: PPUSH
80745: CALL_OW 115
// if not HasTask ( group [ i ] ) then
80749: LD_VAR 0 4
80753: PUSH
80754: LD_VAR 0 7
80758: ARRAY
80759: PPUSH
80760: CALL_OW 314
80764: NOT
80765: IFFALSE 80803
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
80767: LD_VAR 0 4
80771: PUSH
80772: LD_VAR 0 7
80776: ARRAY
80777: PPUSH
80778: LD_VAR 0 14
80782: PPUSH
80783: LD_VAR 0 4
80787: PUSH
80788: LD_VAR 0 7
80792: ARRAY
80793: PPUSH
80794: CALL_OW 74
80798: PPUSH
80799: CALL_OW 115
// end ; end ; end ;
80803: GO 76708
80805: POP
80806: POP
// wait ( 0 0$1 ) ;
80807: LD_INT 35
80809: PPUSH
80810: CALL_OW 67
// until group = [ ] ;
80814: LD_VAR 0 4
80818: PUSH
80819: EMPTY
80820: EQUAL
80821: IFFALSE 76693
// end ;
80823: LD_VAR 0 2
80827: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80828: LD_INT 0
80830: PPUSH
80831: PPUSH
80832: PPUSH
80833: PPUSH
// if not base_units then
80834: LD_VAR 0 1
80838: NOT
80839: IFFALSE 80843
// exit ;
80841: GO 80930
// result := false ;
80843: LD_ADDR_VAR 0 2
80847: PUSH
80848: LD_INT 0
80850: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80851: LD_ADDR_VAR 0 5
80855: PUSH
80856: LD_VAR 0 1
80860: PPUSH
80861: LD_INT 21
80863: PUSH
80864: LD_INT 3
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PPUSH
80871: CALL_OW 72
80875: ST_TO_ADDR
// if not tmp then
80876: LD_VAR 0 5
80880: NOT
80881: IFFALSE 80885
// exit ;
80883: GO 80930
// for i in tmp do
80885: LD_ADDR_VAR 0 3
80889: PUSH
80890: LD_VAR 0 5
80894: PUSH
80895: FOR_IN
80896: IFFALSE 80928
// begin result := EnemyInRange ( i , 22 ) ;
80898: LD_ADDR_VAR 0 2
80902: PUSH
80903: LD_VAR 0 3
80907: PPUSH
80908: LD_INT 22
80910: PPUSH
80911: CALL 74506 0 2
80915: ST_TO_ADDR
// if result then
80916: LD_VAR 0 2
80920: IFFALSE 80926
// exit ;
80922: POP
80923: POP
80924: GO 80930
// end ;
80926: GO 80895
80928: POP
80929: POP
// end ;
80930: LD_VAR 0 2
80934: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
80935: LD_INT 0
80937: PPUSH
80938: PPUSH
// if not units then
80939: LD_VAR 0 1
80943: NOT
80944: IFFALSE 80948
// exit ;
80946: GO 81018
// result := [ ] ;
80948: LD_ADDR_VAR 0 3
80952: PUSH
80953: EMPTY
80954: ST_TO_ADDR
// for i in units do
80955: LD_ADDR_VAR 0 4
80959: PUSH
80960: LD_VAR 0 1
80964: PUSH
80965: FOR_IN
80966: IFFALSE 81016
// if GetTag ( i ) = tag then
80968: LD_VAR 0 4
80972: PPUSH
80973: CALL_OW 110
80977: PUSH
80978: LD_VAR 0 2
80982: EQUAL
80983: IFFALSE 81014
// result := Insert ( result , result + 1 , i ) ;
80985: LD_ADDR_VAR 0 3
80989: PUSH
80990: LD_VAR 0 3
80994: PPUSH
80995: LD_VAR 0 3
80999: PUSH
81000: LD_INT 1
81002: PLUS
81003: PPUSH
81004: LD_VAR 0 4
81008: PPUSH
81009: CALL_OW 2
81013: ST_TO_ADDR
81014: GO 80965
81016: POP
81017: POP
// end ;
81018: LD_VAR 0 3
81022: RET
// export function IsDriver ( un ) ; begin
81023: LD_INT 0
81025: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81026: LD_ADDR_VAR 0 2
81030: PUSH
81031: LD_VAR 0 1
81035: PUSH
81036: LD_INT 55
81038: PUSH
81039: EMPTY
81040: LIST
81041: PPUSH
81042: CALL_OW 69
81046: IN
81047: ST_TO_ADDR
// end ;
81048: LD_VAR 0 2
81052: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81053: LD_INT 0
81055: PPUSH
81056: PPUSH
// list := [ ] ;
81057: LD_ADDR_VAR 0 5
81061: PUSH
81062: EMPTY
81063: ST_TO_ADDR
// case d of 0 :
81064: LD_VAR 0 3
81068: PUSH
81069: LD_INT 0
81071: DOUBLE
81072: EQUAL
81073: IFTRUE 81077
81075: GO 81210
81077: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81078: LD_ADDR_VAR 0 5
81082: PUSH
81083: LD_VAR 0 1
81087: PUSH
81088: LD_INT 4
81090: MINUS
81091: PUSH
81092: LD_VAR 0 2
81096: PUSH
81097: LD_INT 4
81099: MINUS
81100: PUSH
81101: LD_INT 2
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: LIST
81108: PUSH
81109: LD_VAR 0 1
81113: PUSH
81114: LD_INT 3
81116: MINUS
81117: PUSH
81118: LD_VAR 0 2
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: LIST
81130: PUSH
81131: LD_VAR 0 1
81135: PUSH
81136: LD_INT 4
81138: PLUS
81139: PUSH
81140: LD_VAR 0 2
81144: PUSH
81145: LD_INT 4
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: LIST
81152: PUSH
81153: LD_VAR 0 1
81157: PUSH
81158: LD_INT 3
81160: PLUS
81161: PUSH
81162: LD_VAR 0 2
81166: PUSH
81167: LD_INT 3
81169: PLUS
81170: PUSH
81171: LD_INT 5
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: LIST
81178: PUSH
81179: LD_VAR 0 1
81183: PUSH
81184: LD_VAR 0 2
81188: PUSH
81189: LD_INT 4
81191: PLUS
81192: PUSH
81193: LD_INT 0
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: LIST
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: ST_TO_ADDR
// end ; 1 :
81208: GO 81908
81210: LD_INT 1
81212: DOUBLE
81213: EQUAL
81214: IFTRUE 81218
81216: GO 81351
81218: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81219: LD_ADDR_VAR 0 5
81223: PUSH
81224: LD_VAR 0 1
81228: PUSH
81229: LD_VAR 0 2
81233: PUSH
81234: LD_INT 4
81236: MINUS
81237: PUSH
81238: LD_INT 3
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: LIST
81245: PUSH
81246: LD_VAR 0 1
81250: PUSH
81251: LD_INT 3
81253: MINUS
81254: PUSH
81255: LD_VAR 0 2
81259: PUSH
81260: LD_INT 3
81262: MINUS
81263: PUSH
81264: LD_INT 2
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: LIST
81271: PUSH
81272: LD_VAR 0 1
81276: PUSH
81277: LD_INT 4
81279: MINUS
81280: PUSH
81281: LD_VAR 0 2
81285: PUSH
81286: LD_INT 1
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: LIST
81293: PUSH
81294: LD_VAR 0 1
81298: PUSH
81299: LD_VAR 0 2
81303: PUSH
81304: LD_INT 3
81306: PLUS
81307: PUSH
81308: LD_INT 0
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: LIST
81315: PUSH
81316: LD_VAR 0 1
81320: PUSH
81321: LD_INT 4
81323: PLUS
81324: PUSH
81325: LD_VAR 0 2
81329: PUSH
81330: LD_INT 4
81332: PLUS
81333: PUSH
81334: LD_INT 5
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: LIST
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: ST_TO_ADDR
// end ; 2 :
81349: GO 81908
81351: LD_INT 2
81353: DOUBLE
81354: EQUAL
81355: IFTRUE 81359
81357: GO 81488
81359: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81360: LD_ADDR_VAR 0 5
81364: PUSH
81365: LD_VAR 0 1
81369: PUSH
81370: LD_VAR 0 2
81374: PUSH
81375: LD_INT 3
81377: MINUS
81378: PUSH
81379: LD_INT 3
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: LIST
81386: PUSH
81387: LD_VAR 0 1
81391: PUSH
81392: LD_INT 4
81394: PLUS
81395: PUSH
81396: LD_VAR 0 2
81400: PUSH
81401: LD_INT 4
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: LIST
81408: PUSH
81409: LD_VAR 0 1
81413: PUSH
81414: LD_VAR 0 2
81418: PUSH
81419: LD_INT 4
81421: PLUS
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: LIST
81430: PUSH
81431: LD_VAR 0 1
81435: PUSH
81436: LD_INT 3
81438: MINUS
81439: PUSH
81440: LD_VAR 0 2
81444: PUSH
81445: LD_INT 1
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: LIST
81452: PUSH
81453: LD_VAR 0 1
81457: PUSH
81458: LD_INT 4
81460: MINUS
81461: PUSH
81462: LD_VAR 0 2
81466: PUSH
81467: LD_INT 4
81469: MINUS
81470: PUSH
81471: LD_INT 2
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: LIST
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: ST_TO_ADDR
// end ; 3 :
81486: GO 81908
81488: LD_INT 3
81490: DOUBLE
81491: EQUAL
81492: IFTRUE 81496
81494: GO 81629
81496: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81497: LD_ADDR_VAR 0 5
81501: PUSH
81502: LD_VAR 0 1
81506: PUSH
81507: LD_INT 3
81509: PLUS
81510: PUSH
81511: LD_VAR 0 2
81515: PUSH
81516: LD_INT 4
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: LIST
81523: PUSH
81524: LD_VAR 0 1
81528: PUSH
81529: LD_INT 4
81531: PLUS
81532: PUSH
81533: LD_VAR 0 2
81537: PUSH
81538: LD_INT 4
81540: PLUS
81541: PUSH
81542: LD_INT 5
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: LIST
81549: PUSH
81550: LD_VAR 0 1
81554: PUSH
81555: LD_INT 4
81557: MINUS
81558: PUSH
81559: LD_VAR 0 2
81563: PUSH
81564: LD_INT 1
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: LIST
81571: PUSH
81572: LD_VAR 0 1
81576: PUSH
81577: LD_VAR 0 2
81581: PUSH
81582: LD_INT 4
81584: MINUS
81585: PUSH
81586: LD_INT 3
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: LIST
81593: PUSH
81594: LD_VAR 0 1
81598: PUSH
81599: LD_INT 3
81601: MINUS
81602: PUSH
81603: LD_VAR 0 2
81607: PUSH
81608: LD_INT 3
81610: MINUS
81611: PUSH
81612: LD_INT 2
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: LIST
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: ST_TO_ADDR
// end ; 4 :
81627: GO 81908
81629: LD_INT 4
81631: DOUBLE
81632: EQUAL
81633: IFTRUE 81637
81635: GO 81770
81637: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
81638: LD_ADDR_VAR 0 5
81642: PUSH
81643: LD_VAR 0 1
81647: PUSH
81648: LD_VAR 0 2
81652: PUSH
81653: LD_INT 4
81655: PLUS
81656: PUSH
81657: LD_INT 0
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: LIST
81664: PUSH
81665: LD_VAR 0 1
81669: PUSH
81670: LD_INT 3
81672: PLUS
81673: PUSH
81674: LD_VAR 0 2
81678: PUSH
81679: LD_INT 3
81681: PLUS
81682: PUSH
81683: LD_INT 5
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: LIST
81690: PUSH
81691: LD_VAR 0 1
81695: PUSH
81696: LD_INT 4
81698: PLUS
81699: PUSH
81700: LD_VAR 0 2
81704: PUSH
81705: LD_INT 4
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: LIST
81712: PUSH
81713: LD_VAR 0 1
81717: PUSH
81718: LD_VAR 0 2
81722: PUSH
81723: LD_INT 3
81725: MINUS
81726: PUSH
81727: LD_INT 3
81729: PUSH
81730: EMPTY
81731: LIST
81732: LIST
81733: LIST
81734: PUSH
81735: LD_VAR 0 1
81739: PUSH
81740: LD_INT 4
81742: MINUS
81743: PUSH
81744: LD_VAR 0 2
81748: PUSH
81749: LD_INT 4
81751: MINUS
81752: PUSH
81753: LD_INT 2
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: LIST
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: ST_TO_ADDR
// end ; 5 :
81768: GO 81908
81770: LD_INT 5
81772: DOUBLE
81773: EQUAL
81774: IFTRUE 81778
81776: GO 81907
81778: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81779: LD_ADDR_VAR 0 5
81783: PUSH
81784: LD_VAR 0 1
81788: PUSH
81789: LD_INT 4
81791: MINUS
81792: PUSH
81793: LD_VAR 0 2
81797: PUSH
81798: LD_INT 1
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: LIST
81805: PUSH
81806: LD_VAR 0 1
81810: PUSH
81811: LD_VAR 0 2
81815: PUSH
81816: LD_INT 4
81818: MINUS
81819: PUSH
81820: LD_INT 3
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: LIST
81827: PUSH
81828: LD_VAR 0 1
81832: PUSH
81833: LD_INT 4
81835: PLUS
81836: PUSH
81837: LD_VAR 0 2
81841: PUSH
81842: LD_INT 4
81844: PLUS
81845: PUSH
81846: LD_INT 5
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: LIST
81853: PUSH
81854: LD_VAR 0 1
81858: PUSH
81859: LD_INT 3
81861: PLUS
81862: PUSH
81863: LD_VAR 0 2
81867: PUSH
81868: LD_INT 4
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: LIST
81875: PUSH
81876: LD_VAR 0 1
81880: PUSH
81881: LD_VAR 0 2
81885: PUSH
81886: LD_INT 3
81888: PLUS
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: LIST
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: LIST
81902: LIST
81903: LIST
81904: ST_TO_ADDR
// end ; end ;
81905: GO 81908
81907: POP
// result := list ;
81908: LD_ADDR_VAR 0 4
81912: PUSH
81913: LD_VAR 0 5
81917: ST_TO_ADDR
// end ;
81918: LD_VAR 0 4
81922: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
81923: LD_INT 0
81925: PPUSH
81926: PPUSH
81927: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
81928: LD_VAR 0 1
81932: NOT
81933: PUSH
81934: LD_VAR 0 2
81938: PUSH
81939: LD_INT 1
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: LD_INT 3
81947: PUSH
81948: LD_INT 4
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: IN
81957: NOT
81958: OR
81959: IFFALSE 81963
// exit ;
81961: GO 82055
// tmp := [ ] ;
81963: LD_ADDR_VAR 0 5
81967: PUSH
81968: EMPTY
81969: ST_TO_ADDR
// for i in units do
81970: LD_ADDR_VAR 0 4
81974: PUSH
81975: LD_VAR 0 1
81979: PUSH
81980: FOR_IN
81981: IFFALSE 82024
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
81983: LD_ADDR_VAR 0 5
81987: PUSH
81988: LD_VAR 0 5
81992: PPUSH
81993: LD_VAR 0 5
81997: PUSH
81998: LD_INT 1
82000: PLUS
82001: PPUSH
82002: LD_VAR 0 4
82006: PPUSH
82007: LD_VAR 0 2
82011: PPUSH
82012: CALL_OW 259
82016: PPUSH
82017: CALL_OW 2
82021: ST_TO_ADDR
82022: GO 81980
82024: POP
82025: POP
// if not tmp then
82026: LD_VAR 0 5
82030: NOT
82031: IFFALSE 82035
// exit ;
82033: GO 82055
// result := SortListByListDesc ( units , tmp ) ;
82035: LD_ADDR_VAR 0 3
82039: PUSH
82040: LD_VAR 0 1
82044: PPUSH
82045: LD_VAR 0 5
82049: PPUSH
82050: CALL_OW 77
82054: ST_TO_ADDR
// end ;
82055: LD_VAR 0 3
82059: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82060: LD_INT 0
82062: PPUSH
82063: PPUSH
82064: PPUSH
// x := GetX ( building ) ;
82065: LD_ADDR_VAR 0 4
82069: PUSH
82070: LD_VAR 0 2
82074: PPUSH
82075: CALL_OW 250
82079: ST_TO_ADDR
// y := GetY ( building ) ;
82080: LD_ADDR_VAR 0 5
82084: PUSH
82085: LD_VAR 0 2
82089: PPUSH
82090: CALL_OW 251
82094: ST_TO_ADDR
// if GetTaskList ( unit ) then
82095: LD_VAR 0 1
82099: PPUSH
82100: CALL_OW 437
82104: IFFALSE 82199
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82106: LD_STRING e
82108: PUSH
82109: LD_VAR 0 1
82113: PPUSH
82114: CALL_OW 437
82118: PUSH
82119: LD_INT 1
82121: ARRAY
82122: PUSH
82123: LD_INT 1
82125: ARRAY
82126: EQUAL
82127: PUSH
82128: LD_VAR 0 4
82132: PUSH
82133: LD_VAR 0 1
82137: PPUSH
82138: CALL_OW 437
82142: PUSH
82143: LD_INT 1
82145: ARRAY
82146: PUSH
82147: LD_INT 2
82149: ARRAY
82150: EQUAL
82151: AND
82152: PUSH
82153: LD_VAR 0 5
82157: PUSH
82158: LD_VAR 0 1
82162: PPUSH
82163: CALL_OW 437
82167: PUSH
82168: LD_INT 1
82170: ARRAY
82171: PUSH
82172: LD_INT 3
82174: ARRAY
82175: EQUAL
82176: AND
82177: IFFALSE 82189
// result := true else
82179: LD_ADDR_VAR 0 3
82183: PUSH
82184: LD_INT 1
82186: ST_TO_ADDR
82187: GO 82197
// result := false ;
82189: LD_ADDR_VAR 0 3
82193: PUSH
82194: LD_INT 0
82196: ST_TO_ADDR
// end else
82197: GO 82207
// result := false ;
82199: LD_ADDR_VAR 0 3
82203: PUSH
82204: LD_INT 0
82206: ST_TO_ADDR
// end ;
82207: LD_VAR 0 3
82211: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82212: LD_INT 0
82214: PPUSH
82215: PPUSH
82216: PPUSH
82217: PPUSH
// if not unit or not area then
82218: LD_VAR 0 1
82222: NOT
82223: PUSH
82224: LD_VAR 0 2
82228: NOT
82229: OR
82230: IFFALSE 82234
// exit ;
82232: GO 82399
// tmp := AreaToList ( area , i ) ;
82234: LD_ADDR_VAR 0 6
82238: PUSH
82239: LD_VAR 0 2
82243: PPUSH
82244: LD_VAR 0 5
82248: PPUSH
82249: CALL_OW 517
82253: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82254: LD_ADDR_VAR 0 5
82258: PUSH
82259: DOUBLE
82260: LD_INT 1
82262: DEC
82263: ST_TO_ADDR
82264: LD_VAR 0 6
82268: PUSH
82269: LD_INT 1
82271: ARRAY
82272: PUSH
82273: FOR_TO
82274: IFFALSE 82389
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82276: LD_ADDR_VAR 0 7
82280: PUSH
82281: LD_VAR 0 6
82285: PUSH
82286: LD_INT 1
82288: ARRAY
82289: PUSH
82290: LD_VAR 0 5
82294: ARRAY
82295: PUSH
82296: LD_VAR 0 6
82300: PUSH
82301: LD_INT 2
82303: ARRAY
82304: PUSH
82305: LD_VAR 0 5
82309: ARRAY
82310: PUSH
82311: EMPTY
82312: LIST
82313: LIST
82314: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82315: LD_VAR 0 7
82319: PUSH
82320: LD_INT 1
82322: ARRAY
82323: PPUSH
82324: LD_VAR 0 7
82328: PUSH
82329: LD_INT 2
82331: ARRAY
82332: PPUSH
82333: CALL_OW 428
82337: PUSH
82338: LD_INT 0
82340: EQUAL
82341: IFFALSE 82387
// begin result := true ;
82343: LD_ADDR_VAR 0 4
82347: PUSH
82348: LD_INT 1
82350: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82351: LD_VAR 0 1
82355: PPUSH
82356: LD_VAR 0 7
82360: PUSH
82361: LD_INT 1
82363: ARRAY
82364: PPUSH
82365: LD_VAR 0 7
82369: PUSH
82370: LD_INT 2
82372: ARRAY
82373: PPUSH
82374: LD_VAR 0 3
82378: PPUSH
82379: CALL_OW 48
// exit ;
82383: POP
82384: POP
82385: GO 82399
// end ; end ;
82387: GO 82273
82389: POP
82390: POP
// result := false ;
82391: LD_ADDR_VAR 0 4
82395: PUSH
82396: LD_INT 0
82398: ST_TO_ADDR
// end ;
82399: LD_VAR 0 4
82403: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82404: LD_INT 0
82406: PPUSH
82407: PPUSH
82408: PPUSH
// if not side or side > 8 then
82409: LD_VAR 0 1
82413: NOT
82414: PUSH
82415: LD_VAR 0 1
82419: PUSH
82420: LD_INT 8
82422: GREATER
82423: OR
82424: IFFALSE 82428
// exit ;
82426: GO 82615
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82428: LD_ADDR_VAR 0 4
82432: PUSH
82433: LD_INT 22
82435: PUSH
82436: LD_VAR 0 1
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 21
82447: PUSH
82448: LD_INT 3
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PPUSH
82459: CALL_OW 69
82463: ST_TO_ADDR
// if not tmp then
82464: LD_VAR 0 4
82468: NOT
82469: IFFALSE 82473
// exit ;
82471: GO 82615
// enable_addtolog := true ;
82473: LD_ADDR_OWVAR 81
82477: PUSH
82478: LD_INT 1
82480: ST_TO_ADDR
// AddToLog ( [ ) ;
82481: LD_STRING [
82483: PPUSH
82484: CALL_OW 561
// for i in tmp do
82488: LD_ADDR_VAR 0 3
82492: PUSH
82493: LD_VAR 0 4
82497: PUSH
82498: FOR_IN
82499: IFFALSE 82606
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
82501: LD_STRING [
82503: PUSH
82504: LD_VAR 0 3
82508: PPUSH
82509: CALL_OW 266
82513: STR
82514: PUSH
82515: LD_STRING , 
82517: STR
82518: PUSH
82519: LD_VAR 0 3
82523: PPUSH
82524: CALL_OW 250
82528: STR
82529: PUSH
82530: LD_STRING , 
82532: STR
82533: PUSH
82534: LD_VAR 0 3
82538: PPUSH
82539: CALL_OW 251
82543: STR
82544: PUSH
82545: LD_STRING , 
82547: STR
82548: PUSH
82549: LD_VAR 0 3
82553: PPUSH
82554: CALL_OW 254
82558: STR
82559: PUSH
82560: LD_STRING , 
82562: STR
82563: PUSH
82564: LD_VAR 0 3
82568: PPUSH
82569: LD_INT 1
82571: PPUSH
82572: CALL_OW 268
82576: STR
82577: PUSH
82578: LD_STRING , 
82580: STR
82581: PUSH
82582: LD_VAR 0 3
82586: PPUSH
82587: LD_INT 2
82589: PPUSH
82590: CALL_OW 268
82594: STR
82595: PUSH
82596: LD_STRING ],
82598: STR
82599: PPUSH
82600: CALL_OW 561
// end ;
82604: GO 82498
82606: POP
82607: POP
// AddToLog ( ]; ) ;
82608: LD_STRING ];
82610: PPUSH
82611: CALL_OW 561
// end ;
82615: LD_VAR 0 2
82619: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
82620: LD_INT 0
82622: PPUSH
82623: PPUSH
82624: PPUSH
82625: PPUSH
82626: PPUSH
// if not area or not rate or not max then
82627: LD_VAR 0 1
82631: NOT
82632: PUSH
82633: LD_VAR 0 2
82637: NOT
82638: OR
82639: PUSH
82640: LD_VAR 0 4
82644: NOT
82645: OR
82646: IFFALSE 82650
// exit ;
82648: GO 82842
// while 1 do
82650: LD_INT 1
82652: IFFALSE 82842
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
82654: LD_ADDR_VAR 0 9
82658: PUSH
82659: LD_VAR 0 1
82663: PPUSH
82664: LD_INT 1
82666: PPUSH
82667: CALL_OW 287
82671: PUSH
82672: LD_INT 10
82674: MUL
82675: ST_TO_ADDR
// r := rate / 10 ;
82676: LD_ADDR_VAR 0 7
82680: PUSH
82681: LD_VAR 0 2
82685: PUSH
82686: LD_INT 10
82688: DIVREAL
82689: ST_TO_ADDR
// time := 1 1$00 ;
82690: LD_ADDR_VAR 0 8
82694: PUSH
82695: LD_INT 2100
82697: ST_TO_ADDR
// if amount < min then
82698: LD_VAR 0 9
82702: PUSH
82703: LD_VAR 0 3
82707: LESS
82708: IFFALSE 82726
// r := r * 2 else
82710: LD_ADDR_VAR 0 7
82714: PUSH
82715: LD_VAR 0 7
82719: PUSH
82720: LD_INT 2
82722: MUL
82723: ST_TO_ADDR
82724: GO 82752
// if amount > max then
82726: LD_VAR 0 9
82730: PUSH
82731: LD_VAR 0 4
82735: GREATER
82736: IFFALSE 82752
// r := r / 2 ;
82738: LD_ADDR_VAR 0 7
82742: PUSH
82743: LD_VAR 0 7
82747: PUSH
82748: LD_INT 2
82750: DIVREAL
82751: ST_TO_ADDR
// time := time / r ;
82752: LD_ADDR_VAR 0 8
82756: PUSH
82757: LD_VAR 0 8
82761: PUSH
82762: LD_VAR 0 7
82766: DIVREAL
82767: ST_TO_ADDR
// if time < 0 then
82768: LD_VAR 0 8
82772: PUSH
82773: LD_INT 0
82775: LESS
82776: IFFALSE 82793
// time := time * - 1 ;
82778: LD_ADDR_VAR 0 8
82782: PUSH
82783: LD_VAR 0 8
82787: PUSH
82788: LD_INT 1
82790: NEG
82791: MUL
82792: ST_TO_ADDR
// wait ( time ) ;
82793: LD_VAR 0 8
82797: PPUSH
82798: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
82802: LD_INT 35
82804: PPUSH
82805: LD_INT 875
82807: PPUSH
82808: CALL_OW 12
82812: PPUSH
82813: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
82817: LD_INT 1
82819: PPUSH
82820: LD_INT 5
82822: PPUSH
82823: CALL_OW 12
82827: PPUSH
82828: LD_VAR 0 1
82832: PPUSH
82833: LD_INT 1
82835: PPUSH
82836: CALL_OW 55
// end ;
82840: GO 82650
// end ;
82842: LD_VAR 0 5
82846: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
82847: LD_INT 0
82849: PPUSH
82850: PPUSH
82851: PPUSH
82852: PPUSH
82853: PPUSH
82854: PPUSH
82855: PPUSH
82856: PPUSH
// if not turrets or not factories then
82857: LD_VAR 0 1
82861: NOT
82862: PUSH
82863: LD_VAR 0 2
82867: NOT
82868: OR
82869: IFFALSE 82873
// exit ;
82871: GO 83180
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
82873: LD_ADDR_VAR 0 10
82877: PUSH
82878: LD_INT 5
82880: PUSH
82881: LD_INT 6
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 2
82890: PUSH
82891: LD_INT 4
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 3
82900: PUSH
82901: LD_INT 5
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 24
82915: PUSH
82916: LD_INT 25
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 23
82925: PUSH
82926: LD_INT 27
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 42
82939: PUSH
82940: LD_INT 43
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 44
82949: PUSH
82950: LD_INT 46
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 45
82959: PUSH
82960: LD_INT 47
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: LIST
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: LIST
82976: ST_TO_ADDR
// result := [ ] ;
82977: LD_ADDR_VAR 0 3
82981: PUSH
82982: EMPTY
82983: ST_TO_ADDR
// for i in turrets do
82984: LD_ADDR_VAR 0 4
82988: PUSH
82989: LD_VAR 0 1
82993: PUSH
82994: FOR_IN
82995: IFFALSE 83178
// begin nat := GetNation ( i ) ;
82997: LD_ADDR_VAR 0 7
83001: PUSH
83002: LD_VAR 0 4
83006: PPUSH
83007: CALL_OW 248
83011: ST_TO_ADDR
// weapon := 0 ;
83012: LD_ADDR_VAR 0 8
83016: PUSH
83017: LD_INT 0
83019: ST_TO_ADDR
// if not nat then
83020: LD_VAR 0 7
83024: NOT
83025: IFFALSE 83029
// continue ;
83027: GO 82994
// for j in list [ nat ] do
83029: LD_ADDR_VAR 0 5
83033: PUSH
83034: LD_VAR 0 10
83038: PUSH
83039: LD_VAR 0 7
83043: ARRAY
83044: PUSH
83045: FOR_IN
83046: IFFALSE 83087
// if GetBWeapon ( i ) = j [ 1 ] then
83048: LD_VAR 0 4
83052: PPUSH
83053: CALL_OW 269
83057: PUSH
83058: LD_VAR 0 5
83062: PUSH
83063: LD_INT 1
83065: ARRAY
83066: EQUAL
83067: IFFALSE 83085
// begin weapon := j [ 2 ] ;
83069: LD_ADDR_VAR 0 8
83073: PUSH
83074: LD_VAR 0 5
83078: PUSH
83079: LD_INT 2
83081: ARRAY
83082: ST_TO_ADDR
// break ;
83083: GO 83087
// end ;
83085: GO 83045
83087: POP
83088: POP
// if not weapon then
83089: LD_VAR 0 8
83093: NOT
83094: IFFALSE 83098
// continue ;
83096: GO 82994
// for k in factories do
83098: LD_ADDR_VAR 0 6
83102: PUSH
83103: LD_VAR 0 2
83107: PUSH
83108: FOR_IN
83109: IFFALSE 83174
// begin weapons := AvailableWeaponList ( k ) ;
83111: LD_ADDR_VAR 0 9
83115: PUSH
83116: LD_VAR 0 6
83120: PPUSH
83121: CALL_OW 478
83125: ST_TO_ADDR
// if not weapons then
83126: LD_VAR 0 9
83130: NOT
83131: IFFALSE 83135
// continue ;
83133: GO 83108
// if weapon in weapons then
83135: LD_VAR 0 8
83139: PUSH
83140: LD_VAR 0 9
83144: IN
83145: IFFALSE 83172
// begin result := [ i , weapon ] ;
83147: LD_ADDR_VAR 0 3
83151: PUSH
83152: LD_VAR 0 4
83156: PUSH
83157: LD_VAR 0 8
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: ST_TO_ADDR
// exit ;
83166: POP
83167: POP
83168: POP
83169: POP
83170: GO 83180
// end ; end ;
83172: GO 83108
83174: POP
83175: POP
// end ;
83176: GO 82994
83178: POP
83179: POP
// end ;
83180: LD_VAR 0 3
83184: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83185: LD_INT 0
83187: PPUSH
// if not side or side > 8 then
83188: LD_VAR 0 3
83192: NOT
83193: PUSH
83194: LD_VAR 0 3
83198: PUSH
83199: LD_INT 8
83201: GREATER
83202: OR
83203: IFFALSE 83207
// exit ;
83205: GO 83266
// if not range then
83207: LD_VAR 0 4
83211: NOT
83212: IFFALSE 83223
// range := - 12 ;
83214: LD_ADDR_VAR 0 4
83218: PUSH
83219: LD_INT 12
83221: NEG
83222: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83223: LD_VAR 0 1
83227: PPUSH
83228: LD_VAR 0 2
83232: PPUSH
83233: LD_VAR 0 3
83237: PPUSH
83238: LD_VAR 0 4
83242: PPUSH
83243: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83247: LD_VAR 0 1
83251: PPUSH
83252: LD_VAR 0 2
83256: PPUSH
83257: LD_VAR 0 3
83261: PPUSH
83262: CALL_OW 331
// end ;
83266: LD_VAR 0 5
83270: RET
// export function Video ( mode ) ; begin
83271: LD_INT 0
83273: PPUSH
// ingame_video = mode ;
83274: LD_ADDR_OWVAR 52
83278: PUSH
83279: LD_VAR 0 1
83283: ST_TO_ADDR
// interface_hidden = mode ;
83284: LD_ADDR_OWVAR 54
83288: PUSH
83289: LD_VAR 0 1
83293: ST_TO_ADDR
// end ;
83294: LD_VAR 0 2
83298: RET
