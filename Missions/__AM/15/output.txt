// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 37 0 0
// InitMacro ;
   8: CALL 2793 0 0
// PrepareAlliance ;
  12: CALL 1588 0 0
// PrepareRussian ;
  16: CALL 1250 0 0
// PrepareLegion ;
  20: CALL 724 0 0
// PreparePowell ;
  24: CALL 296 0 0
// PrepareAmerican ;
  28: CALL 288 0 0
// MC_Start ( ) ;
  32: CALL 3940 0 0
// end ;
  36: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus ; export function InitVariables ; begin
  37: LD_INT 0
  39: PPUSH
// debug := true ;
  40: LD_ADDR_EXP 1
  44: PUSH
  45: LD_INT 1
  47: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
  48: LD_ADDR_EXP 2
  52: PUSH
  53: LD_STRING 14_KappaStatus_1
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: CALL_OW 30
  63: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 06_KurtStatus_1
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , [ ] ) ;
  80: LD_ADDR_EXP 4
  84: PUSH
  85: LD_STRING 14_JMMVeh_1
  87: PPUSH
  88: EMPTY
  89: PPUSH
  90: CALL_OW 30
  94: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , [ ] ) ;
  95: LD_ADDR_EXP 5
  99: PUSH
 100: LD_STRING 14_JMMGirlVeh_1
 102: PPUSH
 103: EMPTY
 104: PPUSH
 105: CALL_OW 30
 109: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 3 ) ;
 110: LD_ADDR_EXP 7
 114: PUSH
 115: LD_STRING 14_JMMGirl_1
 117: PPUSH
 118: LD_INT 3
 120: PPUSH
 121: CALL_OW 30
 125: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 126: LD_ADDR_EXP 6
 130: PUSH
 131: LD_STRING 14_JMMGirlStatus_1
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: CALL_OW 30
 141: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 142: LD_ADDR_EXP 8
 146: PUSH
 147: LD_STRING 10_KhatamStatus_1
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: CALL_OW 30
 157: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 158: LD_ADDR_EXP 9
 162: PUSH
 163: LD_STRING 13_BurlakStatus_1
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: CALL_OW 30
 173: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 174: LD_ADDR_EXP 10
 178: PUSH
 179: LD_STRING 13_StevensStatus_1
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL_OW 30
 189: ST_TO_ADDR
// end ;
 190: LD_VAR 0 1
 194: RET
// export function CustomInitMacro ( ) ; begin
 195: LD_INT 0
 197: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea ] ;
 198: LD_ADDR_EXP 80
 202: PUSH
 203: LD_INT 2
 205: PUSH
 206: LD_INT 3
 208: PUSH
 209: LD_INT 6
 211: PUSH
 212: EMPTY
 213: LIST
 214: LIST
 215: LIST
 216: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea ] ;
 217: LD_ADDR_EXP 81
 221: PUSH
 222: LD_INT 1
 224: PUSH
 225: LD_INT 4
 227: PUSH
 228: LD_INT 5
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 236: LD_ADDR_EXP 85
 240: PUSH
 241: LD_EXP 85
 245: PPUSH
 246: LD_INT 3
 248: PPUSH
 249: LD_INT 22
 251: PUSH
 252: LD_INT 8
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: PUSH
 259: LD_INT 25
 261: PUSH
 262: LD_INT 15
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL_OW 69
 277: PPUSH
 278: CALL_OW 1
 282: ST_TO_ADDR
// end ; end_of_file
 283: LD_VAR 0 1
 287: RET
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie ; export function PrepareAmerican ; begin
 288: LD_INT 0
 290: PPUSH
// end ; end_of_file
 291: LD_VAR 0 1
 295: RET
// export Powell ; export function PreparePowell ; var i , b , tmp , depot , lab , armoury , workshop ; begin
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
 301: PPUSH
 302: PPUSH
 303: PPUSH
 304: PPUSH
 305: PPUSH
// uc_side := 4 ;
 306: LD_ADDR_OWVAR 20
 310: PUSH
 311: LD_INT 4
 313: ST_TO_ADDR
// uc_nation := 1 ;
 314: LD_ADDR_OWVAR 21
 318: PUSH
 319: LD_INT 1
 321: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 322: LD_ADDR_EXP 27
 326: PUSH
 327: LD_STRING Powell
 329: PPUSH
 330: CALL_OW 25
 334: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
 335: LD_EXP 27
 339: PPUSH
 340: LD_INT 57
 342: PPUSH
 343: LD_INT 94
 345: PPUSH
 346: LD_INT 0
 348: PPUSH
 349: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
 353: LD_EXP 27
 357: PPUSH
 358: LD_INT 58
 360: PPUSH
 361: LD_INT 94
 363: PPUSH
 364: CALL_OW 118
// tmp := CreateCharacterSet ( 13s_others ) ;
 368: LD_ADDR_VAR 0 4
 372: PUSH
 373: LD_STRING 13s_others
 375: PPUSH
 376: CALL_OW 31
 380: ST_TO_ADDR
// if tmp < 14 then
 381: LD_VAR 0 4
 385: PUSH
 386: LD_INT 14
 388: LESS
 389: IFFALSE 456
// for i = 1 to 14 - tmp do
 391: LD_ADDR_VAR 0 2
 395: PUSH
 396: DOUBLE
 397: LD_INT 1
 399: DEC
 400: ST_TO_ADDR
 401: LD_INT 14
 403: PUSH
 404: LD_VAR 0 4
 408: MINUS
 409: PUSH
 410: FOR_TO
 411: IFFALSE 454
// begin PrepareHuman ( false , i mod 4 + 1 , 8 ) ;
 413: LD_INT 0
 415: PPUSH
 416: LD_VAR 0 2
 420: PUSH
 421: LD_INT 4
 423: MOD
 424: PUSH
 425: LD_INT 1
 427: PLUS
 428: PPUSH
 429: LD_INT 8
 431: PPUSH
 432: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
 436: LD_ADDR_VAR 0 4
 440: PUSH
 441: LD_VAR 0 4
 445: PUSH
 446: CALL_OW 44
 450: ADD
 451: ST_TO_ADDR
// end ;
 452: GO 410
 454: POP
 455: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
 456: LD_ADDR_VAR 0 5
 460: PUSH
 461: LD_INT 22
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: EMPTY
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 30
 473: PUSH
 474: LD_INT 0
 476: PUSH
 477: EMPTY
 478: LIST
 479: LIST
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: PPUSH
 485: CALL_OW 69
 489: PUSH
 490: LD_INT 1
 492: ARRAY
 493: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
 494: LD_ADDR_VAR 0 6
 498: PUSH
 499: LD_INT 22
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: PUSH
 509: LD_INT 30
 511: PUSH
 512: LD_INT 6
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL_OW 69
 527: PUSH
 528: LD_INT 1
 530: ARRAY
 531: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
 532: LD_ADDR_VAR 0 7
 536: PUSH
 537: LD_INT 22
 539: PUSH
 540: LD_INT 4
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 30
 549: PUSH
 550: LD_INT 4
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: PPUSH
 561: CALL_OW 69
 565: PUSH
 566: LD_INT 1
 568: ARRAY
 569: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
 570: LD_ADDR_VAR 0 8
 574: PUSH
 575: LD_INT 22
 577: PUSH
 578: LD_INT 4
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 30
 587: PUSH
 588: LD_INT 2
 590: PUSH
 591: EMPTY
 592: LIST
 593: LIST
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: PPUSH
 599: CALL_OW 69
 603: PUSH
 604: LD_INT 1
 606: ARRAY
 607: ST_TO_ADDR
// for i in tmp do
 608: LD_ADDR_VAR 0 2
 612: PUSH
 613: LD_VAR 0 4
 617: PUSH
 618: FOR_IN
 619: IFFALSE 717
// begin b := [ armoury , depot , workshop , lab ] [ GetClass ( i ) ] ;
 621: LD_ADDR_VAR 0 3
 625: PUSH
 626: LD_VAR 0 7
 630: PUSH
 631: LD_VAR 0 5
 635: PUSH
 636: LD_VAR 0 8
 640: PUSH
 641: LD_VAR 0 6
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: PUSH
 652: LD_VAR 0 2
 656: PPUSH
 657: CALL_OW 257
 661: ARRAY
 662: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
 663: LD_VAR 0 3
 667: PPUSH
 668: CALL_OW 313
 672: PUSH
 673: LD_INT 6
 675: LESS
 676: IFFALSE 694
// PlaceHumanInUnit ( i , b ) else
 678: LD_VAR 0 2
 682: PPUSH
 683: LD_VAR 0 3
 687: PPUSH
 688: CALL_OW 52
 692: GO 715
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
 694: LD_VAR 0 2
 698: PPUSH
 699: LD_INT 58
 701: PPUSH
 702: LD_INT 91
 704: PPUSH
 705: LD_INT 6
 707: PPUSH
 708: LD_INT 0
 710: PPUSH
 711: CALL_OW 50
// end ;
 715: GO 618
 717: POP
 718: POP
// end ; end_of_file
 719: LD_VAR 0 1
 723: RET
// export Kurt , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
 724: LD_INT 0
 726: PPUSH
 727: PPUSH
 728: PPUSH
 729: PPUSH
 730: PPUSH
// side := 8 ;
 731: LD_ADDR_VAR 0 3
 735: PUSH
 736: LD_INT 8
 738: ST_TO_ADDR
// uc_side := side ;
 739: LD_ADDR_OWVAR 20
 743: PUSH
 744: LD_VAR 0 3
 748: ST_TO_ADDR
// uc_nation := 2 ;
 749: LD_ADDR_OWVAR 21
 753: PUSH
 754: LD_INT 2
 756: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
 757: LD_ADDR_VAR 0 2
 761: PUSH
 762: LD_INT 22
 764: PUSH
 765: LD_VAR 0 3
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 21
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: EMPTY
 781: LIST
 782: LIST
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL_OW 69
 792: PUSH
 793: FOR_IN
 794: IFFALSE 810
// SetBLevel ( i , 10 ) ;
 796: LD_VAR 0 2
 800: PPUSH
 801: LD_INT 10
 803: PPUSH
 804: CALL_OW 241
 808: GO 793
 810: POP
 811: POP
// if KurtStatus then
 812: LD_EXP 3
 816: IFFALSE 839
// Kurt := PrepareUnit ( Kurt , false ,  ) else
 818: LD_ADDR_EXP 28
 822: PUSH
 823: LD_STRING Kurt
 825: PPUSH
 826: LD_INT 0
 828: PPUSH
 829: LD_STRING 
 831: PPUSH
 832: CALL 30389 0 3
 836: ST_TO_ADDR
 837: GO 861
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
 839: LD_ADDR_EXP 28
 843: PUSH
 844: LD_STRING AltKurt
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_STRING 
 855: PPUSH
 856: CALL 30389 0 3
 860: ST_TO_ADDR
// if not Kurt then
 861: LD_EXP 28
 865: NOT
 866: IFFALSE 892
// begin InitHc ;
 868: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
 872: LD_INT 1
 874: PPUSH
 875: LD_INT 10
 877: PPUSH
 878: CALL_OW 381
// Kurt := CreateHuman ;
 882: LD_ADDR_EXP 28
 886: PUSH
 887: CALL_OW 44
 891: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
 892: LD_EXP 28
 896: PPUSH
 897: LD_INT 324
 899: PPUSH
 900: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
 904: LD_ADDR_EXP 29
 908: PUSH
 909: LD_STRING Kozlov
 911: PPUSH
 912: LD_INT 0
 914: PPUSH
 915: LD_STRING 
 917: PPUSH
 918: CALL 30389 0 3
 922: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
 923: LD_EXP 29
 927: PPUSH
 928: LD_INT 22
 930: PUSH
 931: LD_INT 8
 933: PUSH
 934: EMPTY
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 23
 940: PUSH
 941: LD_INT 3
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: PUSH
 948: LD_INT 30
 950: PUSH
 951: LD_INT 8
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: PUSH
 958: EMPTY
 959: LIST
 960: LIST
 961: LIST
 962: PPUSH
 963: CALL_OW 69
 967: PUSH
 968: LD_INT 1
 970: ARRAY
 971: PPUSH
 972: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
 976: LD_ADDR_VAR 0 5
 980: PUSH
 981: LD_INT 22
 983: PUSH
 984: LD_VAR 0 3
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 30
 995: PUSH
 996: LD_INT 32
 998: PUSH
 999: EMPTY
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 58
1005: PUSH
1006: EMPTY
1007: LIST
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: PPUSH
1014: CALL_OW 69
1018: ST_TO_ADDR
// for i = 1 to 10 do
1019: LD_ADDR_VAR 0 2
1023: PUSH
1024: DOUBLE
1025: LD_INT 1
1027: DEC
1028: ST_TO_ADDR
1029: LD_INT 10
1031: PUSH
1032: FOR_TO
1033: IFFALSE 1105
// begin uc_nation := nation_nature ;
1035: LD_ADDR_OWVAR 21
1039: PUSH
1040: LD_INT 0
1042: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1043: LD_ADDR_OWVAR 28
1047: PUSH
1048: LD_INT 15
1050: ST_TO_ADDR
// hc_gallery :=  ;
1051: LD_ADDR_OWVAR 33
1055: PUSH
1056: LD_STRING 
1058: ST_TO_ADDR
// hc_name :=  ;
1059: LD_ADDR_OWVAR 26
1063: PUSH
1064: LD_STRING 
1066: ST_TO_ADDR
// un := CreateHuman ;
1067: LD_ADDR_VAR 0 4
1071: PUSH
1072: CALL_OW 44
1076: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
1077: LD_VAR 0 4
1081: PPUSH
1082: LD_VAR 0 5
1086: PUSH
1087: LD_VAR 0 5
1091: PUSH
1092: LD_VAR 0 2
1096: MINUS
1097: ARRAY
1098: PPUSH
1099: CALL_OW 52
// end ;
1103: GO 1032
1105: POP
1106: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
1107: LD_INT 324
1109: PPUSH
1110: LD_INT 5
1112: PPUSH
1113: LD_STRING 
1115: PPUSH
1116: LD_INT 8
1118: PUSH
1119: LD_INT 9
1121: PUSH
1122: LD_INT 10
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: LIST
1129: PUSH
1130: LD_OWVAR 67
1134: ARRAY
1135: PPUSH
1136: LD_INT 3000
1138: PUSH
1139: LD_INT 500
1141: PUSH
1142: LD_INT 150
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: PPUSH
1150: LD_INT 16
1152: PUSH
1153: LD_INT 6
1155: PUSH
1156: LD_INT 6
1158: PUSH
1159: LD_INT 8
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PPUSH
1168: CALL 40431 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
1172: LD_ADDR_EXP 56
1176: PUSH
1177: LD_EXP 56
1181: PPUSH
1182: LD_INT 3
1184: PPUSH
1185: LD_INT 22
1187: PUSH
1188: LD_VAR 0 3
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 23
1199: PUSH
1200: LD_INT 2
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 3
1209: PUSH
1210: LD_INT 21
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: PPUSH
1229: CALL_OW 69
1233: PUSH
1234: LD_EXP 28
1238: DIFF
1239: PPUSH
1240: CALL_OW 1
1244: ST_TO_ADDR
// end ; end_of_file
1245: LD_VAR 0 1
1249: RET
// export Platonov , Kovalyuk ; export function PrepareRussian ; var i , base , tmp , side ; begin
1250: LD_INT 0
1252: PPUSH
1253: PPUSH
1254: PPUSH
1255: PPUSH
1256: PPUSH
// side := 3 ;
1257: LD_ADDR_VAR 0 5
1261: PUSH
1262: LD_INT 3
1264: ST_TO_ADDR
// uc_side := side ;
1265: LD_ADDR_OWVAR 20
1269: PUSH
1270: LD_VAR 0 5
1274: ST_TO_ADDR
// uc_nation := 3 ;
1275: LD_ADDR_OWVAR 21
1279: PUSH
1280: LD_INT 3
1282: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
1283: LD_ADDR_VAR 0 2
1287: PUSH
1288: LD_INT 22
1290: PUSH
1291: LD_VAR 0 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: LD_INT 21
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: PPUSH
1314: CALL_OW 69
1318: PUSH
1319: FOR_IN
1320: IFFALSE 1336
// SetBLevel ( i , 10 ) ;
1322: LD_VAR 0 2
1326: PPUSH
1327: LD_INT 10
1329: PPUSH
1330: CALL_OW 241
1334: GO 1319
1336: POP
1337: POP
// Platonov := NewCharacter ( Platonov ) ;
1338: LD_ADDR_EXP 30
1342: PUSH
1343: LD_STRING Platonov
1345: PPUSH
1346: CALL_OW 25
1350: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
1351: LD_ADDR_EXP 31
1355: PUSH
1356: LD_STRING Kovalyuk
1358: PPUSH
1359: CALL_OW 25
1363: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , ru_depot ) ;
1364: LD_EXP 30
1368: PPUSH
1369: LD_INT 126
1371: PPUSH
1372: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
1376: LD_EXP 31
1380: PPUSH
1381: LD_INT 134
1383: PPUSH
1384: CALL_OW 52
// PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 1000 , 300 ] , [ - 1 , 8 , 13 , 8 ] ) ;
1388: LD_INT 126
1390: PPUSH
1391: LD_INT 4
1393: PPUSH
1394: LD_STRING zhukov
1396: PPUSH
1397: LD_INT 9
1399: PUSH
1400: LD_INT 10
1402: PUSH
1403: LD_INT 10
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: PUSH
1411: LD_OWVAR 67
1415: ARRAY
1416: PPUSH
1417: LD_INT 3000
1419: PUSH
1420: LD_INT 1000
1422: PUSH
1423: LD_INT 300
1425: PUSH
1426: EMPTY
1427: LIST
1428: LIST
1429: LIST
1430: PPUSH
1431: LD_INT 1
1433: NEG
1434: PUSH
1435: LD_INT 8
1437: PUSH
1438: LD_INT 13
1440: PUSH
1441: LD_INT 8
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: PPUSH
1450: CALL 40431 0 6
// base := GetBase ( ru_depot2 ) ;
1454: LD_ADDR_VAR 0 3
1458: PUSH
1459: LD_INT 267
1461: PPUSH
1462: CALL_OW 274
1466: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 600 ) ;
1467: LD_VAR 0 3
1471: PPUSH
1472: LD_INT 1
1474: PPUSH
1475: LD_INT 600
1477: PPUSH
1478: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
1482: LD_VAR 0 3
1486: PPUSH
1487: LD_INT 2
1489: PPUSH
1490: LD_INT 200
1492: PPUSH
1493: CALL_OW 277
// SetResourceType ( base , mat_siberit , 20 ) ;
1497: LD_VAR 0 3
1501: PPUSH
1502: LD_INT 3
1504: PPUSH
1505: LD_INT 20
1507: PPUSH
1508: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Platonov , Kovalyuk ] ) ;
1512: LD_ADDR_EXP 56
1516: PUSH
1517: LD_EXP 56
1521: PPUSH
1522: LD_INT 2
1524: PPUSH
1525: LD_INT 22
1527: PUSH
1528: LD_VAR 0 5
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PUSH
1537: LD_INT 3
1539: PUSH
1540: LD_INT 21
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: PUSH
1554: EMPTY
1555: LIST
1556: LIST
1557: PPUSH
1558: CALL_OW 69
1562: PUSH
1563: LD_EXP 30
1567: PUSH
1568: LD_EXP 31
1572: PUSH
1573: EMPTY
1574: LIST
1575: LIST
1576: DIFF
1577: PPUSH
1578: CALL_OW 1
1582: ST_TO_ADDR
// end ; end_of_file
1583: LD_VAR 0 1
1587: RET
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
1588: LD_INT 0
1590: PPUSH
1591: PPUSH
1592: PPUSH
1593: PPUSH
1594: PPUSH
1595: PPUSH
// side := 7 ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_INT 7
1603: ST_TO_ADDR
// uc_side := side ;
1604: LD_ADDR_OWVAR 20
1608: PUSH
1609: LD_VAR 0 5
1613: ST_TO_ADDR
// uc_nation := 1 ;
1614: LD_ADDR_OWVAR 21
1618: PUSH
1619: LD_INT 1
1621: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
1622: LD_ADDR_VAR 0 2
1626: PUSH
1627: LD_INT 22
1629: PUSH
1630: LD_VAR 0 5
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: LD_INT 21
1641: PUSH
1642: LD_INT 3
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PUSH
1649: EMPTY
1650: LIST
1651: LIST
1652: PPUSH
1653: CALL_OW 69
1657: PUSH
1658: FOR_IN
1659: IFFALSE 1675
// SetBLevel ( i , 10 ) ;
1661: LD_VAR 0 2
1665: PPUSH
1666: LD_INT 10
1668: PPUSH
1669: CALL_OW 241
1673: GO 1658
1675: POP
1676: POP
// base := GetBase ( al_depot ) ;
1677: LD_ADDR_VAR 0 4
1681: PUSH
1682: LD_INT 2
1684: PPUSH
1685: CALL_OW 274
1689: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
1690: LD_ADDR_VAR 0 6
1694: PUSH
1695: LD_INT 22
1697: PUSH
1698: LD_VAR 0 5
1702: PUSH
1703: EMPTY
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 30
1709: PUSH
1710: LD_INT 34
1712: PUSH
1713: EMPTY
1714: LIST
1715: LIST
1716: PUSH
1717: EMPTY
1718: LIST
1719: LIST
1720: PPUSH
1721: CALL_OW 69
1725: ST_TO_ADDR
// if teleport then
1726: LD_VAR 0 6
1730: IFFALSE 1751
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
1732: LD_VAR 0 6
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_INT 262
1743: PPUSH
1744: LD_INT 119
1746: PPUSH
1747: CALL_OW 243
// SetResourceType ( base , mat_cans , 2500 ) ;
1751: LD_VAR 0 4
1755: PPUSH
1756: LD_INT 1
1758: PPUSH
1759: LD_INT 2500
1761: PPUSH
1762: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
1766: LD_VAR 0 4
1770: PPUSH
1771: LD_INT 2
1773: PPUSH
1774: LD_INT 200
1776: PPUSH
1777: CALL_OW 277
// SetResourceType ( base , mat_siberit , 50 ) ;
1781: LD_VAR 0 4
1785: PPUSH
1786: LD_INT 3
1788: PPUSH
1789: LD_INT 50
1791: PPUSH
1792: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
1796: LD_ADDR_EXP 32
1800: PUSH
1801: LD_STRING Roth
1803: PPUSH
1804: CALL_OW 25
1808: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
1809: LD_ADDR_EXP 33
1813: PUSH
1814: LD_STRING Simms
1816: PPUSH
1817: LD_EXP 1
1821: NOT
1822: PPUSH
1823: LD_STRING 10c_
1825: PPUSH
1826: CALL 30389 0 3
1830: ST_TO_ADDR
// uc_nation := 3 ;
1831: LD_ADDR_OWVAR 21
1835: PUSH
1836: LD_INT 3
1838: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1839: LD_ADDR_EXP 34
1843: PUSH
1844: LD_STRING Kirilenkova
1846: PPUSH
1847: CALL_OW 25
1851: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1852: LD_ADDR_EXP 48
1856: PUSH
1857: LD_STRING Oblukov
1859: PPUSH
1860: CALL_OW 25
1864: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1865: LD_ADDR_EXP 35
1869: PUSH
1870: LD_STRING Dolgov
1872: PPUSH
1873: CALL_OW 25
1877: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1878: LD_ADDR_EXP 36
1882: PUSH
1883: LD_STRING Petrosyan
1885: PPUSH
1886: CALL_OW 25
1890: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1891: LD_ADDR_EXP 47
1895: PUSH
1896: LD_STRING Scholtze
1898: PPUSH
1899: CALL_OW 25
1903: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1904: LD_ADDR_EXP 46
1908: PUSH
1909: LD_STRING Kapitsova
1911: PPUSH
1912: CALL_OW 25
1916: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
1917: LD_ADDR_EXP 37
1921: PUSH
1922: LD_STRING Petrovova
1924: PPUSH
1925: CALL_OW 25
1929: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
1930: LD_ADDR_EXP 38
1934: PUSH
1935: LD_STRING Kuzmov
1937: PPUSH
1938: CALL_OW 25
1942: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
1943: LD_ADDR_EXP 45
1947: PUSH
1948: LD_STRING Karamazov
1950: PPUSH
1951: CALL_OW 25
1955: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
1956: LD_STRING 13_Lipshchin_1
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: CALL_OW 30
1966: IFFALSE 1981
// Lipshchin := NewCharacter ( Lipshchin ) ;
1968: LD_ADDR_EXP 39
1972: PUSH
1973: LD_STRING Lipshchin
1975: PPUSH
1976: CALL_OW 25
1980: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
1981: LD_STRING 13_Titov_1
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 30
1991: IFFALSE 2006
// Titov := NewCharacter ( Titov ) ;
1993: LD_ADDR_EXP 41
1997: PUSH
1998: LD_STRING Titov
2000: PPUSH
2001: CALL_OW 25
2005: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
2006: LD_STRING 13_Gnyevko_1
2008: PPUSH
2009: LD_INT 0
2011: PPUSH
2012: CALL_OW 30
2016: IFFALSE 2031
// Gnyevko := NewCharacter ( Gnyevko ) ;
2018: LD_ADDR_EXP 40
2022: PUSH
2023: LD_STRING Gnyevko
2025: PPUSH
2026: CALL_OW 25
2030: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
2031: LD_STRING 13_Xavier_1
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 30
2041: IFFALSE 2056
// Xavier := NewCharacter ( Xavier2 ) ;
2043: LD_ADDR_EXP 42
2047: PUSH
2048: LD_STRING Xavier2
2050: PPUSH
2051: CALL_OW 25
2055: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
2056: LD_STRING 13_Belkov_1
2058: PPUSH
2059: LD_INT 0
2061: PPUSH
2062: CALL_OW 30
2066: IFFALSE 2081
// Belkov := NewCharacter ( Belkov ) ;
2068: LD_ADDR_EXP 43
2072: PUSH
2073: LD_STRING Belkov
2075: PPUSH
2076: CALL_OW 25
2080: ST_TO_ADDR
// if not BurlakStatus then
2081: LD_EXP 9
2085: NOT
2086: IFFALSE 2101
// Burlak = NewCharacter ( Burlak ) ;
2088: LD_ADDR_EXP 44
2092: PUSH
2093: LD_STRING Burlak
2095: PPUSH
2096: CALL_OW 25
2100: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
2101: LD_ADDR_VAR 0 3
2105: PUSH
2106: LD_EXP 32
2110: PUSH
2111: LD_EXP 34
2115: PUSH
2116: LD_EXP 48
2120: PUSH
2121: LD_EXP 35
2125: PUSH
2126: LD_EXP 36
2130: PUSH
2131: LD_EXP 47
2135: PUSH
2136: LD_EXP 46
2140: PUSH
2141: LD_EXP 37
2145: PUSH
2146: LD_EXP 38
2150: PUSH
2151: LD_EXP 45
2155: PUSH
2156: EMPTY
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: LIST
2167: ST_TO_ADDR
// if Simms then
2168: LD_EXP 33
2172: IFFALSE 2190
// tmp := tmp ^ Simms ;
2174: LD_ADDR_VAR 0 3
2178: PUSH
2179: LD_VAR 0 3
2183: PUSH
2184: LD_EXP 33
2188: ADD
2189: ST_TO_ADDR
// if Titov then
2190: LD_EXP 41
2194: IFFALSE 2212
// tmp := tmp ^ Titov ;
2196: LD_ADDR_VAR 0 3
2200: PUSH
2201: LD_VAR 0 3
2205: PUSH
2206: LD_EXP 41
2210: ADD
2211: ST_TO_ADDR
// if Lipshchin then
2212: LD_EXP 39
2216: IFFALSE 2234
// tmp := tmp ^ Lipshchin ;
2218: LD_ADDR_VAR 0 3
2222: PUSH
2223: LD_VAR 0 3
2227: PUSH
2228: LD_EXP 39
2232: ADD
2233: ST_TO_ADDR
// if Gnyevko then
2234: LD_EXP 40
2238: IFFALSE 2256
// tmp := tmp ^ Gnyevko ;
2240: LD_ADDR_VAR 0 3
2244: PUSH
2245: LD_VAR 0 3
2249: PUSH
2250: LD_EXP 40
2254: ADD
2255: ST_TO_ADDR
// if Xavier then
2256: LD_EXP 42
2260: IFFALSE 2278
// tmp := tmp ^ Xavier ;
2262: LD_ADDR_VAR 0 3
2266: PUSH
2267: LD_VAR 0 3
2271: PUSH
2272: LD_EXP 42
2276: ADD
2277: ST_TO_ADDR
// if Belkov then
2278: LD_EXP 43
2282: IFFALSE 2300
// tmp := tmp ^ Belkov ;
2284: LD_ADDR_VAR 0 3
2288: PUSH
2289: LD_VAR 0 3
2293: PUSH
2294: LD_EXP 43
2298: ADD
2299: ST_TO_ADDR
// if Burlak then
2300: LD_EXP 44
2304: IFFALSE 2322
// tmp := tmp ^ Burlak ;
2306: LD_ADDR_VAR 0 3
2310: PUSH
2311: LD_VAR 0 3
2315: PUSH
2316: LD_EXP 44
2320: ADD
2321: ST_TO_ADDR
// for i = 1 to 8 do
2322: LD_ADDR_VAR 0 2
2326: PUSH
2327: DOUBLE
2328: LD_INT 1
2330: DEC
2331: ST_TO_ADDR
2332: LD_INT 8
2334: PUSH
2335: FOR_TO
2336: IFFALSE 2402
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2338: LD_ADDR_OWVAR 21
2342: PUSH
2343: LD_INT 1
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 1
2355: PPUSH
2356: LD_INT 2
2358: PPUSH
2359: CALL_OW 12
2363: ARRAY
2364: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
2365: LD_INT 0
2367: PPUSH
2368: LD_VAR 0 2
2372: PUSH
2373: LD_INT 2
2375: DIV
2376: PPUSH
2377: LD_INT 10
2379: PPUSH
2380: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2384: LD_ADDR_VAR 0 3
2388: PUSH
2389: LD_VAR 0 3
2393: PUSH
2394: CALL_OW 44
2398: ADD
2399: ST_TO_ADDR
// end ;
2400: GO 2335
2402: POP
2403: POP
// for i in tmp do
2404: LD_ADDR_VAR 0 2
2408: PUSH
2409: LD_VAR 0 3
2413: PUSH
2414: FOR_IN
2415: IFFALSE 2440
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
2417: LD_VAR 0 2
2421: PPUSH
2422: LD_INT 260
2424: PPUSH
2425: LD_INT 235
2427: PPUSH
2428: LD_INT 8
2430: PPUSH
2431: LD_INT 0
2433: PPUSH
2434: CALL_OW 50
2438: GO 2414
2440: POP
2441: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
2442: LD_ADDR_EXP 56
2446: PUSH
2447: LD_EXP 56
2451: PPUSH
2452: LD_INT 1
2454: PPUSH
2455: LD_INT 22
2457: PUSH
2458: LD_VAR 0 5
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PUSH
2467: LD_INT 3
2469: PUSH
2470: LD_INT 21
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: PPUSH
2488: CALL_OW 69
2492: PPUSH
2493: CALL_OW 1
2497: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
2498: LD_VAR 0 1
2502: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
2503: LD_VAR 0 1
2507: PPUSH
2508: CALL 27907 0 1
// end ;
2512: PPOPN 1
2514: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 2
2524: PPUSH
2525: CALL 29792 0 2
// end ;
2529: PPOPN 2
2531: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
2532: LD_VAR 0 1
2536: PPUSH
2537: CALL 28874 0 1
// end ;
2541: PPOPN 1
2543: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
2544: LD_VAR 0 1
2548: PPUSH
2549: CALL 29108 0 1
// end ;
2553: PPOPN 1
2555: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
2556: LD_VAR 0 1
2560: PPUSH
2561: LD_VAR 0 2
2565: PPUSH
2566: CALL 27619 0 2
// end ;
2570: PPOPN 2
2572: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
2573: LD_VAR 0 1
2577: PPUSH
2578: LD_VAR 0 2
2582: PPUSH
2583: LD_VAR 0 3
2587: PPUSH
2588: LD_VAR 0 4
2592: PPUSH
2593: LD_VAR 0 5
2597: PPUSH
2598: CALL 27246 0 5
// end ;
2602: PPOPN 5
2604: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
2605: LD_VAR 0 1
2609: PPUSH
2610: LD_VAR 0 2
2614: PPUSH
2615: CALL 26843 0 2
// end ;
2619: PPOPN 2
2621: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
2622: LD_VAR 0 1
2626: PPUSH
2627: LD_VAR 0 2
2631: PPUSH
2632: LD_VAR 0 3
2636: PPUSH
2637: LD_VAR 0 4
2641: PPUSH
2642: CALL 26688 0 4
// end ;
2646: PPOPN 4
2648: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
2649: LD_VAR 0 1
2653: PPUSH
2654: LD_VAR 0 2
2658: PPUSH
2659: LD_VAR 0 3
2663: PPUSH
2664: CALL 26470 0 3
// end ;
2668: PPOPN 3
2670: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
2671: LD_VAR 0 1
2675: PPUSH
2676: LD_VAR 0 2
2680: PPUSH
2681: CALL 26362 0 2
// end ;
2685: PPOPN 2
2687: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
2688: LD_VAR 0 1
2692: PPUSH
2693: LD_VAR 0 2
2697: PPUSH
2698: CALL 30046 0 2
// end ;
2702: PPOPN 2
2704: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
2705: LD_VAR 0 1
2709: PPUSH
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_VAR 0 3
2719: PPUSH
2720: LD_VAR 0 4
2724: PPUSH
2725: CALL 30255 0 4
// end ;
2729: PPOPN 4
2731: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
2732: LD_VAR 0 1
2736: PPUSH
2737: LD_VAR 0 2
2741: PPUSH
2742: CALL 26178 0 2
// end ; end_of_file
2746: PPOPN 2
2748: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
2749: GO 2751
2751: DISABLE
// begin ru_radar := 98 ;
2752: LD_ADDR_EXP 49
2756: PUSH
2757: LD_INT 98
2759: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
2760: LD_ADDR_EXP 50
2764: PUSH
2765: LD_INT 89
2767: ST_TO_ADDR
// us_hack := 99 ;
2768: LD_ADDR_EXP 51
2772: PUSH
2773: LD_INT 99
2775: ST_TO_ADDR
// us_artillery := 97 ;
2776: LD_ADDR_EXP 52
2780: PUSH
2781: LD_INT 97
2783: ST_TO_ADDR
// ar_bio_bomb := 91 ;
2784: LD_ADDR_EXP 53
2788: PUSH
2789: LD_INT 91
2791: ST_TO_ADDR
// end ; end_of_file
2792: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
2793: LD_INT 0
2795: PPUSH
2796: PPUSH
// skirmish := false ;
2797: LD_ADDR_EXP 54
2801: PUSH
2802: LD_INT 0
2804: ST_TO_ADDR
// debug_mc := false ;
2805: LD_ADDR_EXP 55
2809: PUSH
2810: LD_INT 0
2812: ST_TO_ADDR
// mc_bases := [ ] ;
2813: LD_ADDR_EXP 56
2817: PUSH
2818: EMPTY
2819: ST_TO_ADDR
// mc_sides := [ ] ;
2820: LD_ADDR_EXP 82
2824: PUSH
2825: EMPTY
2826: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
2827: LD_ADDR_EXP 57
2831: PUSH
2832: EMPTY
2833: ST_TO_ADDR
// mc_building_repairs := [ ] ;
2834: LD_ADDR_EXP 58
2838: PUSH
2839: EMPTY
2840: ST_TO_ADDR
// mc_need_heal := [ ] ;
2841: LD_ADDR_EXP 59
2845: PUSH
2846: EMPTY
2847: ST_TO_ADDR
// mc_healers := [ ] ;
2848: LD_ADDR_EXP 60
2852: PUSH
2853: EMPTY
2854: ST_TO_ADDR
// mc_build_list := [ ] ;
2855: LD_ADDR_EXP 61
2859: PUSH
2860: EMPTY
2861: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
2862: LD_ADDR_EXP 88
2866: PUSH
2867: EMPTY
2868: ST_TO_ADDR
// mc_builders := [ ] ;
2869: LD_ADDR_EXP 62
2873: PUSH
2874: EMPTY
2875: ST_TO_ADDR
// mc_construct_list := [ ] ;
2876: LD_ADDR_EXP 63
2880: PUSH
2881: EMPTY
2882: ST_TO_ADDR
// mc_turret_list := [ ] ;
2883: LD_ADDR_EXP 64
2887: PUSH
2888: EMPTY
2889: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
2890: LD_ADDR_EXP 65
2894: PUSH
2895: EMPTY
2896: ST_TO_ADDR
// mc_miners := [ ] ;
2897: LD_ADDR_EXP 70
2901: PUSH
2902: EMPTY
2903: ST_TO_ADDR
// mc_mines := [ ] ;
2904: LD_ADDR_EXP 69
2908: PUSH
2909: EMPTY
2910: ST_TO_ADDR
// mc_minefields := [ ] ;
2911: LD_ADDR_EXP 71
2915: PUSH
2916: EMPTY
2917: ST_TO_ADDR
// mc_crates := [ ] ;
2918: LD_ADDR_EXP 72
2922: PUSH
2923: EMPTY
2924: ST_TO_ADDR
// mc_crates_collector := [ ] ;
2925: LD_ADDR_EXP 73
2929: PUSH
2930: EMPTY
2931: ST_TO_ADDR
// mc_crates_area := [ ] ;
2932: LD_ADDR_EXP 74
2936: PUSH
2937: EMPTY
2938: ST_TO_ADDR
// mc_vehicles := [ ] ;
2939: LD_ADDR_EXP 75
2943: PUSH
2944: EMPTY
2945: ST_TO_ADDR
// mc_attack := [ ] ;
2946: LD_ADDR_EXP 76
2950: PUSH
2951: EMPTY
2952: ST_TO_ADDR
// mc_produce := [ ] ;
2953: LD_ADDR_EXP 77
2957: PUSH
2958: EMPTY
2959: ST_TO_ADDR
// mc_defender := [ ] ;
2960: LD_ADDR_EXP 78
2964: PUSH
2965: EMPTY
2966: ST_TO_ADDR
// mc_parking := [ ] ;
2967: LD_ADDR_EXP 80
2971: PUSH
2972: EMPTY
2973: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
2974: LD_ADDR_EXP 66
2978: PUSH
2979: EMPTY
2980: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
2981: LD_ADDR_EXP 68
2985: PUSH
2986: EMPTY
2987: ST_TO_ADDR
// mc_scan := [ ] ;
2988: LD_ADDR_EXP 79
2992: PUSH
2993: EMPTY
2994: ST_TO_ADDR
// mc_scan_area := [ ] ;
2995: LD_ADDR_EXP 81
2999: PUSH
3000: EMPTY
3001: ST_TO_ADDR
// mc_tech := [ ] ;
3002: LD_ADDR_EXP 83
3006: PUSH
3007: EMPTY
3008: ST_TO_ADDR
// mc_class := [ ] ;
3009: LD_ADDR_EXP 97
3013: PUSH
3014: EMPTY
3015: ST_TO_ADDR
// mc_class_case_use := [ ] ;
3016: LD_ADDR_EXP 98
3020: PUSH
3021: EMPTY
3022: ST_TO_ADDR
// end ;
3023: LD_VAR 0 1
3027: RET
// export function MC_Kill ( base ) ; begin
3028: LD_INT 0
3030: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
3031: LD_ADDR_EXP 56
3035: PUSH
3036: LD_EXP 56
3040: PPUSH
3041: LD_VAR 0 1
3045: PPUSH
3046: EMPTY
3047: PPUSH
3048: CALL_OW 1
3052: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
3053: LD_ADDR_EXP 57
3057: PUSH
3058: LD_EXP 57
3062: PPUSH
3063: LD_VAR 0 1
3067: PPUSH
3068: EMPTY
3069: PPUSH
3070: CALL_OW 1
3074: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
3075: LD_ADDR_EXP 58
3079: PUSH
3080: LD_EXP 58
3084: PPUSH
3085: LD_VAR 0 1
3089: PPUSH
3090: EMPTY
3091: PPUSH
3092: CALL_OW 1
3096: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
3097: LD_ADDR_EXP 59
3101: PUSH
3102: LD_EXP 59
3106: PPUSH
3107: LD_VAR 0 1
3111: PPUSH
3112: EMPTY
3113: PPUSH
3114: CALL_OW 1
3118: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
3119: LD_ADDR_EXP 60
3123: PUSH
3124: LD_EXP 60
3128: PPUSH
3129: LD_VAR 0 1
3133: PPUSH
3134: EMPTY
3135: PPUSH
3136: CALL_OW 1
3140: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
3141: LD_ADDR_EXP 61
3145: PUSH
3146: LD_EXP 61
3150: PPUSH
3151: LD_VAR 0 1
3155: PPUSH
3156: EMPTY
3157: PPUSH
3158: CALL_OW 1
3162: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
3163: LD_ADDR_EXP 62
3167: PUSH
3168: LD_EXP 62
3172: PPUSH
3173: LD_VAR 0 1
3177: PPUSH
3178: EMPTY
3179: PPUSH
3180: CALL_OW 1
3184: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
3185: LD_ADDR_EXP 63
3189: PUSH
3190: LD_EXP 63
3194: PPUSH
3195: LD_VAR 0 1
3199: PPUSH
3200: EMPTY
3201: PPUSH
3202: CALL_OW 1
3206: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
3207: LD_ADDR_EXP 64
3211: PUSH
3212: LD_EXP 64
3216: PPUSH
3217: LD_VAR 0 1
3221: PPUSH
3222: EMPTY
3223: PPUSH
3224: CALL_OW 1
3228: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
3229: LD_ADDR_EXP 65
3233: PUSH
3234: LD_EXP 65
3238: PPUSH
3239: LD_VAR 0 1
3243: PPUSH
3244: EMPTY
3245: PPUSH
3246: CALL_OW 1
3250: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
3251: LD_ADDR_EXP 66
3255: PUSH
3256: LD_EXP 66
3260: PPUSH
3261: LD_VAR 0 1
3265: PPUSH
3266: EMPTY
3267: PPUSH
3268: CALL_OW 1
3272: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
3273: LD_ADDR_EXP 67
3277: PUSH
3278: LD_EXP 67
3282: PPUSH
3283: LD_VAR 0 1
3287: PPUSH
3288: LD_INT 0
3290: PPUSH
3291: CALL_OW 1
3295: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
3296: LD_ADDR_EXP 68
3300: PUSH
3301: LD_EXP 68
3305: PPUSH
3306: LD_VAR 0 1
3310: PPUSH
3311: EMPTY
3312: PPUSH
3313: CALL_OW 1
3317: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
3318: LD_ADDR_EXP 69
3322: PUSH
3323: LD_EXP 69
3327: PPUSH
3328: LD_VAR 0 1
3332: PPUSH
3333: EMPTY
3334: PPUSH
3335: CALL_OW 1
3339: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
3340: LD_ADDR_EXP 70
3344: PUSH
3345: LD_EXP 70
3349: PPUSH
3350: LD_VAR 0 1
3354: PPUSH
3355: EMPTY
3356: PPUSH
3357: CALL_OW 1
3361: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
3362: LD_ADDR_EXP 71
3366: PUSH
3367: LD_EXP 71
3371: PPUSH
3372: LD_VAR 0 1
3376: PPUSH
3377: EMPTY
3378: PPUSH
3379: CALL_OW 1
3383: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
3384: LD_ADDR_EXP 72
3388: PUSH
3389: LD_EXP 72
3393: PPUSH
3394: LD_VAR 0 1
3398: PPUSH
3399: EMPTY
3400: PPUSH
3401: CALL_OW 1
3405: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
3406: LD_ADDR_EXP 73
3410: PUSH
3411: LD_EXP 73
3415: PPUSH
3416: LD_VAR 0 1
3420: PPUSH
3421: EMPTY
3422: PPUSH
3423: CALL_OW 1
3427: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
3428: LD_ADDR_EXP 74
3432: PUSH
3433: LD_EXP 74
3437: PPUSH
3438: LD_VAR 0 1
3442: PPUSH
3443: EMPTY
3444: PPUSH
3445: CALL_OW 1
3449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
3450: LD_ADDR_EXP 75
3454: PUSH
3455: LD_EXP 75
3459: PPUSH
3460: LD_VAR 0 1
3464: PPUSH
3465: EMPTY
3466: PPUSH
3467: CALL_OW 1
3471: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
3472: LD_ADDR_EXP 76
3476: PUSH
3477: LD_EXP 76
3481: PPUSH
3482: LD_VAR 0 1
3486: PPUSH
3487: EMPTY
3488: PPUSH
3489: CALL_OW 1
3493: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
3494: LD_ADDR_EXP 77
3498: PUSH
3499: LD_EXP 77
3503: PPUSH
3504: LD_VAR 0 1
3508: PPUSH
3509: EMPTY
3510: PPUSH
3511: CALL_OW 1
3515: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
3516: LD_ADDR_EXP 78
3520: PUSH
3521: LD_EXP 78
3525: PPUSH
3526: LD_VAR 0 1
3530: PPUSH
3531: EMPTY
3532: PPUSH
3533: CALL_OW 1
3537: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
3538: LD_ADDR_EXP 79
3542: PUSH
3543: LD_EXP 79
3547: PPUSH
3548: LD_VAR 0 1
3552: PPUSH
3553: EMPTY
3554: PPUSH
3555: CALL_OW 1
3559: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
3560: LD_ADDR_EXP 80
3564: PUSH
3565: LD_EXP 80
3569: PPUSH
3570: LD_VAR 0 1
3574: PPUSH
3575: EMPTY
3576: PPUSH
3577: CALL_OW 1
3581: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
3582: LD_ADDR_EXP 81
3586: PUSH
3587: LD_EXP 81
3591: PPUSH
3592: LD_VAR 0 1
3596: PPUSH
3597: EMPTY
3598: PPUSH
3599: CALL_OW 1
3603: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
3604: LD_ADDR_EXP 83
3608: PUSH
3609: LD_EXP 83
3613: PPUSH
3614: LD_VAR 0 1
3618: PPUSH
3619: EMPTY
3620: PPUSH
3621: CALL_OW 1
3625: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
3626: LD_ADDR_EXP 85
3630: PUSH
3631: LD_EXP 85
3635: PPUSH
3636: LD_VAR 0 1
3640: PPUSH
3641: EMPTY
3642: PPUSH
3643: CALL_OW 1
3647: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
3648: LD_ADDR_EXP 86
3652: PUSH
3653: LD_EXP 86
3657: PPUSH
3658: LD_VAR 0 1
3662: PPUSH
3663: EMPTY
3664: PPUSH
3665: CALL_OW 1
3669: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
3670: LD_ADDR_EXP 87
3674: PUSH
3675: LD_EXP 87
3679: PPUSH
3680: LD_VAR 0 1
3684: PPUSH
3685: EMPTY
3686: PPUSH
3687: CALL_OW 1
3691: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
3692: LD_ADDR_EXP 88
3696: PUSH
3697: LD_EXP 88
3701: PPUSH
3702: LD_VAR 0 1
3706: PPUSH
3707: EMPTY
3708: PPUSH
3709: CALL_OW 1
3713: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
3714: LD_ADDR_EXP 89
3718: PUSH
3719: LD_EXP 89
3723: PPUSH
3724: LD_VAR 0 1
3728: PPUSH
3729: EMPTY
3730: PPUSH
3731: CALL_OW 1
3735: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
3736: LD_ADDR_EXP 90
3740: PUSH
3741: LD_EXP 90
3745: PPUSH
3746: LD_VAR 0 1
3750: PPUSH
3751: EMPTY
3752: PPUSH
3753: CALL_OW 1
3757: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
3758: LD_ADDR_EXP 91
3762: PUSH
3763: LD_EXP 91
3767: PPUSH
3768: LD_VAR 0 1
3772: PPUSH
3773: EMPTY
3774: PPUSH
3775: CALL_OW 1
3779: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
3780: LD_ADDR_EXP 92
3784: PUSH
3785: LD_EXP 92
3789: PPUSH
3790: LD_VAR 0 1
3794: PPUSH
3795: EMPTY
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
3802: LD_ADDR_EXP 93
3806: PUSH
3807: LD_EXP 93
3811: PPUSH
3812: LD_VAR 0 1
3816: PPUSH
3817: EMPTY
3818: PPUSH
3819: CALL_OW 1
3823: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
3824: LD_ADDR_EXP 94
3828: PUSH
3829: LD_EXP 94
3833: PPUSH
3834: LD_VAR 0 1
3838: PPUSH
3839: EMPTY
3840: PPUSH
3841: CALL_OW 1
3845: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
3846: LD_ADDR_EXP 95
3850: PUSH
3851: LD_EXP 95
3855: PPUSH
3856: LD_VAR 0 1
3860: PPUSH
3861: EMPTY
3862: PPUSH
3863: CALL_OW 1
3867: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
3868: LD_ADDR_EXP 96
3872: PUSH
3873: LD_EXP 96
3877: PPUSH
3878: LD_VAR 0 1
3882: PPUSH
3883: EMPTY
3884: PPUSH
3885: CALL_OW 1
3889: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
3890: LD_ADDR_EXP 97
3894: PUSH
3895: LD_EXP 97
3899: PPUSH
3900: LD_VAR 0 1
3904: PPUSH
3905: EMPTY
3906: PPUSH
3907: CALL_OW 1
3911: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
3912: LD_ADDR_EXP 98
3916: PUSH
3917: LD_EXP 98
3921: PPUSH
3922: LD_VAR 0 1
3926: PPUSH
3927: LD_INT 0
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// end ;
3935: LD_VAR 0 2
3939: RET
// export function MC_Start ( ) ; var i ; begin
3940: LD_INT 0
3942: PPUSH
3943: PPUSH
// for i = 1 to mc_bases do
3944: LD_ADDR_VAR 0 2
3948: PUSH
3949: DOUBLE
3950: LD_INT 1
3952: DEC
3953: ST_TO_ADDR
3954: LD_EXP 56
3958: PUSH
3959: FOR_TO
3960: IFFALSE 5037
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
3962: LD_ADDR_EXP 56
3966: PUSH
3967: LD_EXP 56
3971: PPUSH
3972: LD_VAR 0 2
3976: PPUSH
3977: LD_EXP 56
3981: PUSH
3982: LD_VAR 0 2
3986: ARRAY
3987: PUSH
3988: LD_INT 0
3990: DIFF
3991: PPUSH
3992: CALL_OW 1
3996: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
3997: LD_ADDR_EXP 57
4001: PUSH
4002: LD_EXP 57
4006: PPUSH
4007: LD_VAR 0 2
4011: PPUSH
4012: EMPTY
4013: PPUSH
4014: CALL_OW 1
4018: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
4019: LD_ADDR_EXP 58
4023: PUSH
4024: LD_EXP 58
4028: PPUSH
4029: LD_VAR 0 2
4033: PPUSH
4034: EMPTY
4035: PPUSH
4036: CALL_OW 1
4040: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
4041: LD_ADDR_EXP 59
4045: PUSH
4046: LD_EXP 59
4050: PPUSH
4051: LD_VAR 0 2
4055: PPUSH
4056: EMPTY
4057: PPUSH
4058: CALL_OW 1
4062: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
4063: LD_ADDR_EXP 60
4067: PUSH
4068: LD_EXP 60
4072: PPUSH
4073: LD_VAR 0 2
4077: PPUSH
4078: EMPTY
4079: PUSH
4080: EMPTY
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PPUSH
4086: CALL_OW 1
4090: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
4091: LD_ADDR_EXP 61
4095: PUSH
4096: LD_EXP 61
4100: PPUSH
4101: LD_VAR 0 2
4105: PPUSH
4106: EMPTY
4107: PPUSH
4108: CALL_OW 1
4112: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
4113: LD_ADDR_EXP 88
4117: PUSH
4118: LD_EXP 88
4122: PPUSH
4123: LD_VAR 0 2
4127: PPUSH
4128: EMPTY
4129: PPUSH
4130: CALL_OW 1
4134: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
4135: LD_ADDR_EXP 62
4139: PUSH
4140: LD_EXP 62
4144: PPUSH
4145: LD_VAR 0 2
4149: PPUSH
4150: EMPTY
4151: PPUSH
4152: CALL_OW 1
4156: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
4157: LD_ADDR_EXP 63
4161: PUSH
4162: LD_EXP 63
4166: PPUSH
4167: LD_VAR 0 2
4171: PPUSH
4172: EMPTY
4173: PPUSH
4174: CALL_OW 1
4178: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
4179: LD_ADDR_EXP 64
4183: PUSH
4184: LD_EXP 64
4188: PPUSH
4189: LD_VAR 0 2
4193: PPUSH
4194: LD_EXP 56
4198: PUSH
4199: LD_VAR 0 2
4203: ARRAY
4204: PPUSH
4205: LD_INT 2
4207: PUSH
4208: LD_INT 30
4210: PUSH
4211: LD_INT 32
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 30
4220: PUSH
4221: LD_INT 33
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: LIST
4232: PPUSH
4233: CALL_OW 72
4237: PPUSH
4238: CALL_OW 1
4242: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
4243: LD_ADDR_EXP 65
4247: PUSH
4248: LD_EXP 65
4252: PPUSH
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_EXP 56
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PPUSH
4269: LD_INT 2
4271: PUSH
4272: LD_INT 30
4274: PUSH
4275: LD_INT 32
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 30
4284: PUSH
4285: LD_INT 31
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 58
4299: PUSH
4300: EMPTY
4301: LIST
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PPUSH
4307: CALL_OW 72
4311: PPUSH
4312: CALL_OW 1
4316: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
4317: LD_ADDR_EXP 66
4321: PUSH
4322: LD_EXP 66
4326: PPUSH
4327: LD_VAR 0 2
4331: PPUSH
4332: EMPTY
4333: PPUSH
4334: CALL_OW 1
4338: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
4339: LD_ADDR_EXP 70
4343: PUSH
4344: LD_EXP 70
4348: PPUSH
4349: LD_VAR 0 2
4353: PPUSH
4354: EMPTY
4355: PPUSH
4356: CALL_OW 1
4360: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
4361: LD_ADDR_EXP 69
4365: PUSH
4366: LD_EXP 69
4370: PPUSH
4371: LD_VAR 0 2
4375: PPUSH
4376: EMPTY
4377: PPUSH
4378: CALL_OW 1
4382: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
4383: LD_ADDR_EXP 71
4387: PUSH
4388: LD_EXP 71
4392: PPUSH
4393: LD_VAR 0 2
4397: PPUSH
4398: EMPTY
4399: PPUSH
4400: CALL_OW 1
4404: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
4405: LD_ADDR_EXP 72
4409: PUSH
4410: LD_EXP 72
4414: PPUSH
4415: LD_VAR 0 2
4419: PPUSH
4420: EMPTY
4421: PPUSH
4422: CALL_OW 1
4426: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
4427: LD_ADDR_EXP 73
4431: PUSH
4432: LD_EXP 73
4436: PPUSH
4437: LD_VAR 0 2
4441: PPUSH
4442: EMPTY
4443: PPUSH
4444: CALL_OW 1
4448: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
4449: LD_ADDR_EXP 74
4453: PUSH
4454: LD_EXP 74
4458: PPUSH
4459: LD_VAR 0 2
4463: PPUSH
4464: EMPTY
4465: PPUSH
4466: CALL_OW 1
4470: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
4471: LD_ADDR_EXP 75
4475: PUSH
4476: LD_EXP 75
4480: PPUSH
4481: LD_VAR 0 2
4485: PPUSH
4486: EMPTY
4487: PPUSH
4488: CALL_OW 1
4492: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
4493: LD_ADDR_EXP 76
4497: PUSH
4498: LD_EXP 76
4502: PPUSH
4503: LD_VAR 0 2
4507: PPUSH
4508: EMPTY
4509: PPUSH
4510: CALL_OW 1
4514: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
4515: LD_ADDR_EXP 77
4519: PUSH
4520: LD_EXP 77
4524: PPUSH
4525: LD_VAR 0 2
4529: PPUSH
4530: EMPTY
4531: PPUSH
4532: CALL_OW 1
4536: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
4537: LD_ADDR_EXP 78
4541: PUSH
4542: LD_EXP 78
4546: PPUSH
4547: LD_VAR 0 2
4551: PPUSH
4552: EMPTY
4553: PPUSH
4554: CALL_OW 1
4558: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
4559: LD_ADDR_EXP 67
4563: PUSH
4564: LD_EXP 67
4568: PPUSH
4569: LD_VAR 0 2
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: CALL_OW 1
4581: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
4582: LD_ADDR_EXP 80
4586: PUSH
4587: LD_EXP 80
4591: PPUSH
4592: LD_VAR 0 2
4596: PPUSH
4597: LD_INT 0
4599: PPUSH
4600: CALL_OW 1
4604: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
4605: LD_ADDR_EXP 68
4609: PUSH
4610: LD_EXP 68
4614: PPUSH
4615: LD_VAR 0 2
4619: PPUSH
4620: EMPTY
4621: PPUSH
4622: CALL_OW 1
4626: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
4627: LD_ADDR_EXP 79
4631: PUSH
4632: LD_EXP 79
4636: PPUSH
4637: LD_VAR 0 2
4641: PPUSH
4642: LD_INT 0
4644: PPUSH
4645: CALL_OW 1
4649: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
4650: LD_ADDR_EXP 81
4654: PUSH
4655: LD_EXP 81
4659: PPUSH
4660: LD_VAR 0 2
4664: PPUSH
4665: EMPTY
4666: PPUSH
4667: CALL_OW 1
4671: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
4672: LD_ADDR_EXP 84
4676: PUSH
4677: LD_EXP 84
4681: PPUSH
4682: LD_VAR 0 2
4686: PPUSH
4687: LD_INT 0
4689: PPUSH
4690: CALL_OW 1
4694: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
4695: LD_ADDR_EXP 85
4699: PUSH
4700: LD_EXP 85
4704: PPUSH
4705: LD_VAR 0 2
4709: PPUSH
4710: EMPTY
4711: PPUSH
4712: CALL_OW 1
4716: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
4717: LD_ADDR_EXP 86
4721: PUSH
4722: LD_EXP 86
4726: PPUSH
4727: LD_VAR 0 2
4731: PPUSH
4732: EMPTY
4733: PPUSH
4734: CALL_OW 1
4738: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
4739: LD_ADDR_EXP 87
4743: PUSH
4744: LD_EXP 87
4748: PPUSH
4749: LD_VAR 0 2
4753: PPUSH
4754: EMPTY
4755: PPUSH
4756: CALL_OW 1
4760: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
4761: LD_ADDR_EXP 89
4765: PUSH
4766: LD_EXP 89
4770: PPUSH
4771: LD_VAR 0 2
4775: PPUSH
4776: LD_EXP 56
4780: PUSH
4781: LD_VAR 0 2
4785: ARRAY
4786: PPUSH
4787: LD_INT 2
4789: PUSH
4790: LD_INT 30
4792: PUSH
4793: LD_INT 6
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 30
4802: PUSH
4803: LD_INT 7
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: PUSH
4810: LD_INT 30
4812: PUSH
4813: LD_INT 8
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: PUSH
4820: EMPTY
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: PPUSH
4826: CALL_OW 72
4830: PPUSH
4831: CALL_OW 1
4835: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
4836: LD_ADDR_EXP 90
4840: PUSH
4841: LD_EXP 90
4845: PPUSH
4846: LD_VAR 0 2
4850: PPUSH
4851: EMPTY
4852: PPUSH
4853: CALL_OW 1
4857: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
4858: LD_ADDR_EXP 91
4862: PUSH
4863: LD_EXP 91
4867: PPUSH
4868: LD_VAR 0 2
4872: PPUSH
4873: EMPTY
4874: PPUSH
4875: CALL_OW 1
4879: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
4880: LD_ADDR_EXP 92
4884: PUSH
4885: LD_EXP 92
4889: PPUSH
4890: LD_VAR 0 2
4894: PPUSH
4895: EMPTY
4896: PPUSH
4897: CALL_OW 1
4901: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
4902: LD_ADDR_EXP 93
4906: PUSH
4907: LD_EXP 93
4911: PPUSH
4912: LD_VAR 0 2
4916: PPUSH
4917: EMPTY
4918: PPUSH
4919: CALL_OW 1
4923: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
4924: LD_ADDR_EXP 94
4928: PUSH
4929: LD_EXP 94
4933: PPUSH
4934: LD_VAR 0 2
4938: PPUSH
4939: EMPTY
4940: PPUSH
4941: CALL_OW 1
4945: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
4946: LD_ADDR_EXP 95
4950: PUSH
4951: LD_EXP 95
4955: PPUSH
4956: LD_VAR 0 2
4960: PPUSH
4961: EMPTY
4962: PPUSH
4963: CALL_OW 1
4967: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
4968: LD_ADDR_EXP 96
4972: PUSH
4973: LD_EXP 96
4977: PPUSH
4978: LD_VAR 0 2
4982: PPUSH
4983: EMPTY
4984: PPUSH
4985: CALL_OW 1
4989: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
4990: LD_ADDR_EXP 97
4994: PUSH
4995: LD_EXP 97
4999: PPUSH
5000: LD_VAR 0 2
5004: PPUSH
5005: EMPTY
5006: PPUSH
5007: CALL_OW 1
5011: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
5012: LD_ADDR_EXP 98
5016: PUSH
5017: LD_EXP 98
5021: PPUSH
5022: LD_VAR 0 2
5026: PPUSH
5027: LD_INT 0
5029: PPUSH
5030: CALL_OW 1
5034: ST_TO_ADDR
// end ;
5035: GO 3959
5037: POP
5038: POP
// MC_InitSides ( ) ;
5039: CALL 5325 0 0
// MC_InitResearch ( ) ;
5043: CALL 5064 0 0
// CustomInitMacro ( ) ;
5047: CALL 195 0 0
// skirmish := true ;
5051: LD_ADDR_EXP 54
5055: PUSH
5056: LD_INT 1
5058: ST_TO_ADDR
// end ;
5059: LD_VAR 0 1
5063: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
5064: LD_INT 0
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
5071: PPUSH
// if not mc_bases then
5072: LD_EXP 56
5076: NOT
5077: IFFALSE 5081
// exit ;
5079: GO 5320
// for i = 1 to 8 do
5081: LD_ADDR_VAR 0 2
5085: PUSH
5086: DOUBLE
5087: LD_INT 1
5089: DEC
5090: ST_TO_ADDR
5091: LD_INT 8
5093: PUSH
5094: FOR_TO
5095: IFFALSE 5121
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
5097: LD_ADDR_EXP 83
5101: PUSH
5102: LD_EXP 83
5106: PPUSH
5107: LD_VAR 0 2
5111: PPUSH
5112: EMPTY
5113: PPUSH
5114: CALL_OW 1
5118: ST_TO_ADDR
5119: GO 5094
5121: POP
5122: POP
// tmp := [ ] ;
5123: LD_ADDR_VAR 0 5
5127: PUSH
5128: EMPTY
5129: ST_TO_ADDR
// for i = 1 to mc_sides do
5130: LD_ADDR_VAR 0 2
5134: PUSH
5135: DOUBLE
5136: LD_INT 1
5138: DEC
5139: ST_TO_ADDR
5140: LD_EXP 82
5144: PUSH
5145: FOR_TO
5146: IFFALSE 5204
// if not mc_sides [ i ] in tmp then
5148: LD_EXP 82
5152: PUSH
5153: LD_VAR 0 2
5157: ARRAY
5158: PUSH
5159: LD_VAR 0 5
5163: IN
5164: NOT
5165: IFFALSE 5202
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
5167: LD_ADDR_VAR 0 5
5171: PUSH
5172: LD_VAR 0 5
5176: PPUSH
5177: LD_VAR 0 5
5181: PUSH
5182: LD_INT 1
5184: PLUS
5185: PPUSH
5186: LD_EXP 82
5190: PUSH
5191: LD_VAR 0 2
5195: ARRAY
5196: PPUSH
5197: CALL_OW 2
5201: ST_TO_ADDR
5202: GO 5145
5204: POP
5205: POP
// if not tmp then
5206: LD_VAR 0 5
5210: NOT
5211: IFFALSE 5215
// exit ;
5213: GO 5320
// for j in tmp do
5215: LD_ADDR_VAR 0 3
5219: PUSH
5220: LD_VAR 0 5
5224: PUSH
5225: FOR_IN
5226: IFFALSE 5318
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_INT 22
5235: PUSH
5236: LD_VAR 0 3
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PPUSH
5245: CALL_OW 69
5249: ST_TO_ADDR
// if not un then
5250: LD_VAR 0 6
5254: NOT
5255: IFFALSE 5259
// continue ;
5257: GO 5225
// nation := GetNation ( un [ 1 ] ) ;
5259: LD_ADDR_VAR 0 4
5263: PUSH
5264: LD_VAR 0 6
5268: PUSH
5269: LD_INT 1
5271: ARRAY
5272: PPUSH
5273: CALL_OW 248
5277: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
5278: LD_ADDR_EXP 83
5282: PUSH
5283: LD_EXP 83
5287: PPUSH
5288: LD_VAR 0 3
5292: PPUSH
5293: LD_VAR 0 3
5297: PPUSH
5298: LD_VAR 0 4
5302: PPUSH
5303: LD_INT 1
5305: PPUSH
5306: CALL 30452 0 3
5310: PPUSH
5311: CALL_OW 1
5315: ST_TO_ADDR
// end ;
5316: GO 5225
5318: POP
5319: POP
// end ;
5320: LD_VAR 0 1
5324: RET
// export function MC_InitSides ( ) ; var i ; begin
5325: LD_INT 0
5327: PPUSH
5328: PPUSH
// if not mc_bases then
5329: LD_EXP 56
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5412
// for i = 1 to mc_bases do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: DOUBLE
5344: LD_INT 1
5346: DEC
5347: ST_TO_ADDR
5348: LD_EXP 56
5352: PUSH
5353: FOR_TO
5354: IFFALSE 5410
// if mc_bases [ i ] then
5356: LD_EXP 56
5360: PUSH
5361: LD_VAR 0 2
5365: ARRAY
5366: IFFALSE 5408
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
5368: LD_ADDR_EXP 82
5372: PUSH
5373: LD_EXP 82
5377: PPUSH
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_EXP 56
5387: PUSH
5388: LD_VAR 0 2
5392: ARRAY
5393: PUSH
5394: LD_INT 1
5396: ARRAY
5397: PPUSH
5398: CALL_OW 255
5402: PPUSH
5403: CALL_OW 1
5407: ST_TO_ADDR
5408: GO 5353
5410: POP
5411: POP
// end ;
5412: LD_VAR 0 1
5416: RET
// every 0 0$01 trigger skirmish do
5417: LD_EXP 54
5421: IFFALSE 5575
5423: GO 5425
5425: DISABLE
// begin enable ;
5426: ENABLE
// MC_CheckBuildings ( ) ;
5427: CALL 9722 0 0
// MC_CheckPeopleLife ( ) ;
5431: CALL 9847 0 0
// RaiseSailEvent ( 100 ) ;
5435: LD_INT 100
5437: PPUSH
5438: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
5442: LD_INT 103
5444: PPUSH
5445: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
5449: LD_INT 104
5451: PPUSH
5452: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
5456: LD_INT 105
5458: PPUSH
5459: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
5463: LD_INT 106
5465: PPUSH
5466: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
5470: LD_INT 107
5472: PPUSH
5473: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
5477: LD_INT 108
5479: PPUSH
5480: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
5484: LD_INT 109
5486: PPUSH
5487: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
5491: LD_INT 110
5493: PPUSH
5494: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
5498: LD_INT 111
5500: PPUSH
5501: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
5505: LD_INT 112
5507: PPUSH
5508: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
5512: LD_INT 113
5514: PPUSH
5515: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
5519: LD_INT 120
5521: PPUSH
5522: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
5526: LD_INT 121
5528: PPUSH
5529: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
5533: LD_INT 122
5535: PPUSH
5536: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
5540: LD_INT 123
5542: PPUSH
5543: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
5547: LD_INT 124
5549: PPUSH
5550: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
5554: LD_INT 125
5556: PPUSH
5557: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
5561: LD_INT 126
5563: PPUSH
5564: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
5568: LD_INT 200
5570: PPUSH
5571: CALL_OW 427
// end ;
5575: END
// on SailEvent ( event ) do begin if event = 100 then
5576: LD_VAR 0 1
5580: PUSH
5581: LD_INT 100
5583: EQUAL
5584: IFFALSE 5590
// MC_ClassManager ( ) ;
5586: CALL 5982 0 0
// if event = 101 then
5590: LD_VAR 0 1
5594: PUSH
5595: LD_INT 101
5597: EQUAL
5598: IFFALSE 5604
// MC_RepairBuildings ( ) ;
5600: CALL 10443 0 0
// if event = 102 then
5604: LD_VAR 0 1
5608: PUSH
5609: LD_INT 102
5611: EQUAL
5612: IFFALSE 5618
// MC_Heal ( ) ;
5614: CALL 10849 0 0
// if event = 103 then
5618: LD_VAR 0 1
5622: PUSH
5623: LD_INT 103
5625: EQUAL
5626: IFFALSE 5632
// MC_Build ( ) ;
5628: CALL 11271 0 0
// if event = 104 then
5632: LD_VAR 0 1
5636: PUSH
5637: LD_INT 104
5639: EQUAL
5640: IFFALSE 5646
// MC_TurretWeapon ( ) ;
5642: CALL 12884 0 0
// if event = 105 then
5646: LD_VAR 0 1
5650: PUSH
5651: LD_INT 105
5653: EQUAL
5654: IFFALSE 5660
// MC_BuildUpgrade ( ) ;
5656: CALL 12435 0 0
// if event = 106 then
5660: LD_VAR 0 1
5664: PUSH
5665: LD_INT 106
5667: EQUAL
5668: IFFALSE 5674
// MC_PlantMines ( ) ;
5670: CALL 13314 0 0
// if event = 107 then
5674: LD_VAR 0 1
5678: PUSH
5679: LD_INT 107
5681: EQUAL
5682: IFFALSE 5688
// MC_CollectCrates ( ) ;
5684: CALL 14348 0 0
// if event = 108 then
5688: LD_VAR 0 1
5692: PUSH
5693: LD_INT 108
5695: EQUAL
5696: IFFALSE 5702
// MC_LinkRemoteControl ( ) ;
5698: CALL 16105 0 0
// if event = 109 then
5702: LD_VAR 0 1
5706: PUSH
5707: LD_INT 109
5709: EQUAL
5710: IFFALSE 5716
// MC_ProduceVehicle ( ) ;
5712: CALL 16286 0 0
// if event = 110 then
5716: LD_VAR 0 1
5720: PUSH
5721: LD_INT 110
5723: EQUAL
5724: IFFALSE 5730
// MC_SendAttack ( ) ;
5726: CALL 16767 0 0
// if event = 111 then
5730: LD_VAR 0 1
5734: PUSH
5735: LD_INT 111
5737: EQUAL
5738: IFFALSE 5744
// MC_Defend ( ) ;
5740: CALL 16875 0 0
// if event = 112 then
5744: LD_VAR 0 1
5748: PUSH
5749: LD_INT 112
5751: EQUAL
5752: IFFALSE 5758
// MC_Research ( ) ;
5754: CALL 17502 0 0
// if event = 113 then
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 113
5765: EQUAL
5766: IFFALSE 5772
// MC_MinesTrigger ( ) ;
5768: CALL 18616 0 0
// if event = 120 then
5772: LD_VAR 0 1
5776: PUSH
5777: LD_INT 120
5779: EQUAL
5780: IFFALSE 5786
// MC_RepairVehicle ( ) ;
5782: CALL 18715 0 0
// if event = 121 then
5786: LD_VAR 0 1
5790: PUSH
5791: LD_INT 121
5793: EQUAL
5794: IFFALSE 5800
// MC_TameApe ( ) ;
5796: CALL 19458 0 0
// if event = 122 then
5800: LD_VAR 0 1
5804: PUSH
5805: LD_INT 122
5807: EQUAL
5808: IFFALSE 5814
// MC_ChangeApeClass ( ) ;
5810: CALL 20287 0 0
// if event = 123 then
5814: LD_VAR 0 1
5818: PUSH
5819: LD_INT 123
5821: EQUAL
5822: IFFALSE 5828
// MC_Bazooka ( ) ;
5824: CALL 20937 0 0
// if event = 124 then
5828: LD_VAR 0 1
5832: PUSH
5833: LD_INT 124
5835: EQUAL
5836: IFFALSE 5842
// MC_TeleportExit ( ) ;
5838: CALL 21135 0 0
// if event = 125 then
5842: LD_VAR 0 1
5846: PUSH
5847: LD_INT 125
5849: EQUAL
5850: IFFALSE 5856
// MC_Deposits ( ) ;
5852: CALL 21782 0 0
// if event = 126 then
5856: LD_VAR 0 1
5860: PUSH
5861: LD_INT 126
5863: EQUAL
5864: IFFALSE 5870
// MC_RemoteDriver ( ) ;
5866: CALL 22407 0 0
// if event = 200 then
5870: LD_VAR 0 1
5874: PUSH
5875: LD_INT 200
5877: EQUAL
5878: IFFALSE 5884
// MC_Idle ( ) ;
5880: CALL 24140 0 0
// end ;
5884: PPOPN 1
5886: END
// export function MC_Reset ( base , tag ) ; var i ; begin
5887: LD_INT 0
5889: PPUSH
5890: PPUSH
// if not mc_bases [ base ] or not tag then
5891: LD_EXP 56
5895: PUSH
5896: LD_VAR 0 1
5900: ARRAY
5901: NOT
5902: PUSH
5903: LD_VAR 0 2
5907: NOT
5908: OR
5909: IFFALSE 5913
// exit ;
5911: GO 5977
// for i in mc_bases [ base ] union mc_ape [ base ] do
5913: LD_ADDR_VAR 0 4
5917: PUSH
5918: LD_EXP 56
5922: PUSH
5923: LD_VAR 0 1
5927: ARRAY
5928: PUSH
5929: LD_EXP 85
5933: PUSH
5934: LD_VAR 0 1
5938: ARRAY
5939: UNION
5940: PUSH
5941: FOR_IN
5942: IFFALSE 5975
// if GetTag ( i ) = tag then
5944: LD_VAR 0 4
5948: PPUSH
5949: CALL_OW 110
5953: PUSH
5954: LD_VAR 0 2
5958: EQUAL
5959: IFFALSE 5973
// SetTag ( i , 0 ) ;
5961: LD_VAR 0 4
5965: PPUSH
5966: LD_INT 0
5968: PPUSH
5969: CALL_OW 109
5973: GO 5941
5975: POP
5976: POP
// end ;
5977: LD_VAR 0 3
5981: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
5982: LD_INT 0
5984: PPUSH
5985: PPUSH
5986: PPUSH
5987: PPUSH
5988: PPUSH
5989: PPUSH
5990: PPUSH
5991: PPUSH
// if not mc_bases then
5992: LD_EXP 56
5996: NOT
5997: IFFALSE 6001
// exit ;
5999: GO 6459
// for i = 1 to mc_bases do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: DOUBLE
6007: LD_INT 1
6009: DEC
6010: ST_TO_ADDR
6011: LD_EXP 56
6015: PUSH
6016: FOR_TO
6017: IFFALSE 6457
// begin tmp := MC_ClassCheckReq ( i ) ;
6019: LD_ADDR_VAR 0 4
6023: PUSH
6024: LD_VAR 0 2
6028: PPUSH
6029: CALL 6464 0 1
6033: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
6034: LD_ADDR_EXP 97
6038: PUSH
6039: LD_EXP 97
6043: PPUSH
6044: LD_VAR 0 2
6048: PPUSH
6049: LD_VAR 0 4
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// if not tmp then
6059: LD_VAR 0 4
6063: NOT
6064: IFFALSE 6068
// continue ;
6066: GO 6016
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
6068: LD_ADDR_VAR 0 6
6072: PUSH
6073: LD_EXP 56
6077: PUSH
6078: LD_VAR 0 2
6082: ARRAY
6083: PPUSH
6084: LD_INT 2
6086: PUSH
6087: LD_INT 30
6089: PUSH
6090: LD_INT 4
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 30
6099: PUSH
6100: LD_INT 5
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: LIST
6111: PPUSH
6112: CALL_OW 72
6116: PUSH
6117: LD_EXP 56
6121: PUSH
6122: LD_VAR 0 2
6126: ARRAY
6127: PPUSH
6128: LD_INT 2
6130: PUSH
6131: LD_INT 30
6133: PUSH
6134: LD_INT 0
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 30
6143: PUSH
6144: LD_INT 1
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 72
6160: PUSH
6161: LD_EXP 56
6165: PUSH
6166: LD_VAR 0 2
6170: ARRAY
6171: PPUSH
6172: LD_INT 30
6174: PUSH
6175: LD_INT 3
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_EXP 56
6191: PUSH
6192: LD_VAR 0 2
6196: ARRAY
6197: PPUSH
6198: LD_INT 2
6200: PUSH
6201: LD_INT 30
6203: PUSH
6204: LD_INT 6
6206: PUSH
6207: EMPTY
6208: LIST
6209: LIST
6210: PUSH
6211: LD_INT 30
6213: PUSH
6214: LD_INT 7
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 30
6223: PUSH
6224: LD_INT 8
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 72
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: LIST
6246: LIST
6247: ST_TO_ADDR
// for j = 1 to 4 do
6248: LD_ADDR_VAR 0 3
6252: PUSH
6253: DOUBLE
6254: LD_INT 1
6256: DEC
6257: ST_TO_ADDR
6258: LD_INT 4
6260: PUSH
6261: FOR_TO
6262: IFFALSE 6453
// begin if not tmp [ j ] then
6264: LD_VAR 0 4
6268: PUSH
6269: LD_VAR 0 3
6273: ARRAY
6274: NOT
6275: IFFALSE 6279
// continue ;
6277: GO 6261
// for p in tmp [ j ] do
6279: LD_ADDR_VAR 0 5
6283: PUSH
6284: LD_VAR 0 4
6288: PUSH
6289: LD_VAR 0 3
6293: ARRAY
6294: PUSH
6295: FOR_IN
6296: IFFALSE 6449
// begin if not b [ j ] then
6298: LD_VAR 0 6
6302: PUSH
6303: LD_VAR 0 3
6307: ARRAY
6308: NOT
6309: IFFALSE 6313
// break ;
6311: GO 6449
// e := 0 ;
6313: LD_ADDR_VAR 0 7
6317: PUSH
6318: LD_INT 0
6320: ST_TO_ADDR
// for k in b [ j ] do
6321: LD_ADDR_VAR 0 8
6325: PUSH
6326: LD_VAR 0 6
6330: PUSH
6331: LD_VAR 0 3
6335: ARRAY
6336: PUSH
6337: FOR_IN
6338: IFFALSE 6365
// if IsNotFull ( k ) then
6340: LD_VAR 0 8
6344: PPUSH
6345: CALL 34478 0 1
6349: IFFALSE 6363
// begin e := k ;
6351: LD_ADDR_VAR 0 7
6355: PUSH
6356: LD_VAR 0 8
6360: ST_TO_ADDR
// break ;
6361: GO 6365
// end ;
6363: GO 6337
6365: POP
6366: POP
// if e and not UnitGoingToBuilding ( p , e ) then
6367: LD_VAR 0 7
6371: PUSH
6372: LD_VAR 0 5
6376: PPUSH
6377: LD_VAR 0 7
6381: PPUSH
6382: CALL 71466 0 2
6386: NOT
6387: AND
6388: IFFALSE 6447
// begin if IsInUnit ( p ) then
6390: LD_VAR 0 5
6394: PPUSH
6395: CALL_OW 310
6399: IFFALSE 6410
// ComExitBuilding ( p ) ;
6401: LD_VAR 0 5
6405: PPUSH
6406: CALL_OW 122
// ComEnterUnit ( p , e ) ;
6410: LD_VAR 0 5
6414: PPUSH
6415: LD_VAR 0 7
6419: PPUSH
6420: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
6424: LD_VAR 0 5
6428: PPUSH
6429: LD_VAR 0 3
6433: PPUSH
6434: CALL_OW 183
// AddComExitBuilding ( p ) ;
6438: LD_VAR 0 5
6442: PPUSH
6443: CALL_OW 182
// end ; end ;
6447: GO 6295
6449: POP
6450: POP
// end ;
6451: GO 6261
6453: POP
6454: POP
// end ;
6455: GO 6016
6457: POP
6458: POP
// end ;
6459: LD_VAR 0 1
6463: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
6464: LD_INT 0
6466: PPUSH
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
6477: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
6478: LD_VAR 0 1
6482: NOT
6483: PUSH
6484: LD_EXP 56
6488: PUSH
6489: LD_VAR 0 1
6493: ARRAY
6494: NOT
6495: OR
6496: PUSH
6497: LD_EXP 56
6501: PUSH
6502: LD_VAR 0 1
6506: ARRAY
6507: PPUSH
6508: LD_INT 2
6510: PUSH
6511: LD_INT 30
6513: PUSH
6514: LD_INT 0
6516: PUSH
6517: EMPTY
6518: LIST
6519: LIST
6520: PUSH
6521: LD_INT 30
6523: PUSH
6524: LD_INT 1
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: LIST
6535: PPUSH
6536: CALL_OW 72
6540: NOT
6541: OR
6542: IFFALSE 6546
// exit ;
6544: GO 9717
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
6546: LD_ADDR_VAR 0 4
6550: PUSH
6551: LD_EXP 56
6555: PUSH
6556: LD_VAR 0 1
6560: ARRAY
6561: PPUSH
6562: LD_INT 2
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: LD_INT 1
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PUSH
6575: LD_INT 25
6577: PUSH
6578: LD_INT 2
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: LD_INT 25
6587: PUSH
6588: LD_INT 3
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: PUSH
6595: LD_INT 25
6597: PUSH
6598: LD_INT 4
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: PUSH
6605: LD_INT 25
6607: PUSH
6608: LD_INT 5
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 25
6617: PUSH
6618: LD_INT 8
6620: PUSH
6621: EMPTY
6622: LIST
6623: LIST
6624: PUSH
6625: LD_INT 25
6627: PUSH
6628: LD_INT 9
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: LIST
6642: LIST
6643: LIST
6644: PPUSH
6645: CALL_OW 72
6649: ST_TO_ADDR
// for i in tmp do
6650: LD_ADDR_VAR 0 3
6654: PUSH
6655: LD_VAR 0 4
6659: PUSH
6660: FOR_IN
6661: IFFALSE 6692
// if GetTag ( i ) then
6663: LD_VAR 0 3
6667: PPUSH
6668: CALL_OW 110
6672: IFFALSE 6690
// tmp := tmp diff i ;
6674: LD_ADDR_VAR 0 4
6678: PUSH
6679: LD_VAR 0 4
6683: PUSH
6684: LD_VAR 0 3
6688: DIFF
6689: ST_TO_ADDR
6690: GO 6660
6692: POP
6693: POP
// if not tmp then
6694: LD_VAR 0 4
6698: NOT
6699: IFFALSE 6703
// exit ;
6701: GO 9717
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
6703: LD_ADDR_VAR 0 5
6707: PUSH
6708: LD_EXP 56
6712: PUSH
6713: LD_VAR 0 1
6717: ARRAY
6718: PPUSH
6719: LD_INT 2
6721: PUSH
6722: LD_INT 25
6724: PUSH
6725: LD_INT 1
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: LD_INT 25
6734: PUSH
6735: LD_INT 5
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 25
6744: PUSH
6745: LD_INT 8
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 25
6754: PUSH
6755: LD_INT 9
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: LIST
6768: PPUSH
6769: CALL_OW 72
6773: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
6774: LD_ADDR_VAR 0 6
6778: PUSH
6779: LD_EXP 56
6783: PUSH
6784: LD_VAR 0 1
6788: ARRAY
6789: PPUSH
6790: LD_INT 25
6792: PUSH
6793: LD_INT 2
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 72
6804: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
6805: LD_ADDR_VAR 0 7
6809: PUSH
6810: LD_EXP 56
6814: PUSH
6815: LD_VAR 0 1
6819: ARRAY
6820: PPUSH
6821: LD_INT 25
6823: PUSH
6824: LD_INT 3
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: PPUSH
6831: CALL_OW 72
6835: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
6836: LD_ADDR_VAR 0 8
6840: PUSH
6841: LD_EXP 56
6845: PUSH
6846: LD_VAR 0 1
6850: ARRAY
6851: PPUSH
6852: LD_INT 25
6854: PUSH
6855: LD_INT 4
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 24
6864: PUSH
6865: LD_INT 251
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: PUSH
6872: EMPTY
6873: LIST
6874: LIST
6875: PPUSH
6876: CALL_OW 72
6880: ST_TO_ADDR
// if mc_scan [ base ] then
6881: LD_EXP 79
6885: PUSH
6886: LD_VAR 0 1
6890: ARRAY
6891: IFFALSE 7352
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
6893: LD_ADDR_EXP 98
6897: PUSH
6898: LD_EXP 98
6902: PPUSH
6903: LD_VAR 0 1
6907: PPUSH
6908: LD_INT 4
6910: PPUSH
6911: CALL_OW 1
6915: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
6916: LD_ADDR_VAR 0 12
6920: PUSH
6921: LD_EXP 56
6925: PUSH
6926: LD_VAR 0 1
6930: ARRAY
6931: PPUSH
6932: LD_INT 2
6934: PUSH
6935: LD_INT 30
6937: PUSH
6938: LD_INT 4
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: LD_INT 30
6947: PUSH
6948: LD_INT 5
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: LIST
6959: PPUSH
6960: CALL_OW 72
6964: ST_TO_ADDR
// if not b then
6965: LD_VAR 0 12
6969: NOT
6970: IFFALSE 6974
// exit ;
6972: GO 9717
// p := [ ] ;
6974: LD_ADDR_VAR 0 11
6978: PUSH
6979: EMPTY
6980: ST_TO_ADDR
// if sci >= 2 then
6981: LD_VAR 0 8
6985: PUSH
6986: LD_INT 2
6988: GREATEREQUAL
6989: IFFALSE 7020
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
6991: LD_ADDR_VAR 0 8
6995: PUSH
6996: LD_VAR 0 8
7000: PUSH
7001: LD_INT 1
7003: ARRAY
7004: PUSH
7005: LD_VAR 0 8
7009: PUSH
7010: LD_INT 2
7012: ARRAY
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: ST_TO_ADDR
7018: GO 7081
// if sci = 1 then
7020: LD_VAR 0 8
7024: PUSH
7025: LD_INT 1
7027: EQUAL
7028: IFFALSE 7049
// sci := [ sci [ 1 ] ] else
7030: LD_ADDR_VAR 0 8
7034: PUSH
7035: LD_VAR 0 8
7039: PUSH
7040: LD_INT 1
7042: ARRAY
7043: PUSH
7044: EMPTY
7045: LIST
7046: ST_TO_ADDR
7047: GO 7081
// if sci = 0 then
7049: LD_VAR 0 8
7053: PUSH
7054: LD_INT 0
7056: EQUAL
7057: IFFALSE 7081
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
7059: LD_ADDR_VAR 0 11
7063: PUSH
7064: LD_VAR 0 4
7068: PPUSH
7069: LD_INT 4
7071: PPUSH
7072: CALL 71329 0 2
7076: PUSH
7077: LD_INT 1
7079: ARRAY
7080: ST_TO_ADDR
// if eng > 4 then
7081: LD_VAR 0 6
7085: PUSH
7086: LD_INT 4
7088: GREATER
7089: IFFALSE 7135
// for i = eng downto 4 do
7091: LD_ADDR_VAR 0 3
7095: PUSH
7096: DOUBLE
7097: LD_VAR 0 6
7101: INC
7102: ST_TO_ADDR
7103: LD_INT 4
7105: PUSH
7106: FOR_DOWNTO
7107: IFFALSE 7133
// eng := eng diff eng [ i ] ;
7109: LD_ADDR_VAR 0 6
7113: PUSH
7114: LD_VAR 0 6
7118: PUSH
7119: LD_VAR 0 6
7123: PUSH
7124: LD_VAR 0 3
7128: ARRAY
7129: DIFF
7130: ST_TO_ADDR
7131: GO 7106
7133: POP
7134: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
7135: LD_ADDR_VAR 0 4
7139: PUSH
7140: LD_VAR 0 4
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: LD_VAR 0 6
7154: UNION
7155: PUSH
7156: LD_VAR 0 7
7160: UNION
7161: PUSH
7162: LD_VAR 0 8
7166: UNION
7167: DIFF
7168: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
7169: LD_ADDR_VAR 0 13
7173: PUSH
7174: LD_EXP 56
7178: PUSH
7179: LD_VAR 0 1
7183: ARRAY
7184: PPUSH
7185: LD_INT 2
7187: PUSH
7188: LD_INT 30
7190: PUSH
7191: LD_INT 32
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 30
7200: PUSH
7201: LD_INT 31
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: PPUSH
7213: CALL_OW 72
7217: PUSH
7218: LD_EXP 56
7222: PUSH
7223: LD_VAR 0 1
7227: ARRAY
7228: PPUSH
7229: LD_INT 2
7231: PUSH
7232: LD_INT 30
7234: PUSH
7235: LD_INT 4
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 30
7244: PUSH
7245: LD_INT 5
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: LIST
7256: PPUSH
7257: CALL_OW 72
7261: PUSH
7262: LD_INT 6
7264: MUL
7265: PLUS
7266: ST_TO_ADDR
// if bcount < tmp then
7267: LD_VAR 0 13
7271: PUSH
7272: LD_VAR 0 4
7276: LESS
7277: IFFALSE 7323
// for i = tmp downto bcount do
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: DOUBLE
7285: LD_VAR 0 4
7289: INC
7290: ST_TO_ADDR
7291: LD_VAR 0 13
7295: PUSH
7296: FOR_DOWNTO
7297: IFFALSE 7321
// tmp := Delete ( tmp , tmp ) ;
7299: LD_ADDR_VAR 0 4
7303: PUSH
7304: LD_VAR 0 4
7308: PPUSH
7309: LD_VAR 0 4
7313: PPUSH
7314: CALL_OW 3
7318: ST_TO_ADDR
7319: GO 7296
7321: POP
7322: POP
// result := [ tmp , 0 , 0 , p ] ;
7323: LD_ADDR_VAR 0 2
7327: PUSH
7328: LD_VAR 0 4
7332: PUSH
7333: LD_INT 0
7335: PUSH
7336: LD_INT 0
7338: PUSH
7339: LD_VAR 0 11
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: ST_TO_ADDR
// exit ;
7350: GO 9717
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
7352: LD_EXP 56
7356: PUSH
7357: LD_VAR 0 1
7361: ARRAY
7362: PPUSH
7363: LD_INT 2
7365: PUSH
7366: LD_INT 30
7368: PUSH
7369: LD_INT 6
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PUSH
7376: LD_INT 30
7378: PUSH
7379: LD_INT 7
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 30
7388: PUSH
7389: LD_INT 8
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: PPUSH
7402: CALL_OW 72
7406: NOT
7407: PUSH
7408: LD_EXP 56
7412: PUSH
7413: LD_VAR 0 1
7417: ARRAY
7418: PPUSH
7419: LD_INT 30
7421: PUSH
7422: LD_INT 3
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PPUSH
7429: CALL_OW 72
7433: NOT
7434: AND
7435: IFFALSE 7507
// begin if eng = tmp then
7437: LD_VAR 0 6
7441: PUSH
7442: LD_VAR 0 4
7446: EQUAL
7447: IFFALSE 7451
// exit ;
7449: GO 9717
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
7451: LD_ADDR_EXP 98
7455: PUSH
7456: LD_EXP 98
7460: PPUSH
7461: LD_VAR 0 1
7465: PPUSH
7466: LD_INT 1
7468: PPUSH
7469: CALL_OW 1
7473: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
7474: LD_ADDR_VAR 0 2
7478: PUSH
7479: LD_INT 0
7481: PUSH
7482: LD_VAR 0 4
7486: PUSH
7487: LD_VAR 0 6
7491: DIFF
7492: PUSH
7493: LD_INT 0
7495: PUSH
7496: LD_INT 0
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: ST_TO_ADDR
// exit ;
7505: GO 9717
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
7507: LD_EXP 83
7511: PUSH
7512: LD_EXP 82
7516: PUSH
7517: LD_VAR 0 1
7521: ARRAY
7522: ARRAY
7523: PUSH
7524: LD_EXP 56
7528: PUSH
7529: LD_VAR 0 1
7533: ARRAY
7534: PPUSH
7535: LD_INT 2
7537: PUSH
7538: LD_INT 30
7540: PUSH
7541: LD_INT 6
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 30
7550: PUSH
7551: LD_INT 7
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 30
7560: PUSH
7561: LD_INT 8
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: PPUSH
7574: CALL_OW 72
7578: AND
7579: PUSH
7580: LD_EXP 56
7584: PUSH
7585: LD_VAR 0 1
7589: ARRAY
7590: PPUSH
7591: LD_INT 30
7593: PUSH
7594: LD_INT 3
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: PPUSH
7601: CALL_OW 72
7605: NOT
7606: AND
7607: IFFALSE 7821
// begin if sci >= 6 then
7609: LD_VAR 0 8
7613: PUSH
7614: LD_INT 6
7616: GREATEREQUAL
7617: IFFALSE 7621
// exit ;
7619: GO 9717
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
7621: LD_ADDR_EXP 98
7625: PUSH
7626: LD_EXP 98
7630: PPUSH
7631: LD_VAR 0 1
7635: PPUSH
7636: LD_INT 2
7638: PPUSH
7639: CALL_OW 1
7643: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
7644: LD_ADDR_VAR 0 9
7648: PUSH
7649: LD_VAR 0 4
7653: PUSH
7654: LD_VAR 0 8
7658: DIFF
7659: PPUSH
7660: LD_INT 4
7662: PPUSH
7663: CALL 71329 0 2
7667: ST_TO_ADDR
// p := [ ] ;
7668: LD_ADDR_VAR 0 11
7672: PUSH
7673: EMPTY
7674: ST_TO_ADDR
// if sci < 6 and sort > 6 then
7675: LD_VAR 0 8
7679: PUSH
7680: LD_INT 6
7682: LESS
7683: PUSH
7684: LD_VAR 0 9
7688: PUSH
7689: LD_INT 6
7691: GREATER
7692: AND
7693: IFFALSE 7774
// begin for i = 1 to 6 - sci do
7695: LD_ADDR_VAR 0 3
7699: PUSH
7700: DOUBLE
7701: LD_INT 1
7703: DEC
7704: ST_TO_ADDR
7705: LD_INT 6
7707: PUSH
7708: LD_VAR 0 8
7712: MINUS
7713: PUSH
7714: FOR_TO
7715: IFFALSE 7770
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
7717: LD_ADDR_VAR 0 11
7721: PUSH
7722: LD_VAR 0 11
7726: PPUSH
7727: LD_VAR 0 11
7731: PUSH
7732: LD_INT 1
7734: PLUS
7735: PPUSH
7736: LD_VAR 0 9
7740: PUSH
7741: LD_INT 1
7743: ARRAY
7744: PPUSH
7745: CALL_OW 2
7749: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
7750: LD_ADDR_VAR 0 9
7754: PUSH
7755: LD_VAR 0 9
7759: PPUSH
7760: LD_INT 1
7762: PPUSH
7763: CALL_OW 3
7767: ST_TO_ADDR
// end ;
7768: GO 7714
7770: POP
7771: POP
// end else
7772: GO 7794
// if sort then
7774: LD_VAR 0 9
7778: IFFALSE 7794
// p := sort [ 1 ] ;
7780: LD_ADDR_VAR 0 11
7784: PUSH
7785: LD_VAR 0 9
7789: PUSH
7790: LD_INT 1
7792: ARRAY
7793: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
7794: LD_ADDR_VAR 0 2
7798: PUSH
7799: LD_INT 0
7801: PUSH
7802: LD_INT 0
7804: PUSH
7805: LD_INT 0
7807: PUSH
7808: LD_VAR 0 11
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: LIST
7817: LIST
7818: ST_TO_ADDR
// exit ;
7819: GO 9717
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
7821: LD_EXP 83
7825: PUSH
7826: LD_EXP 82
7830: PUSH
7831: LD_VAR 0 1
7835: ARRAY
7836: ARRAY
7837: PUSH
7838: LD_EXP 56
7842: PUSH
7843: LD_VAR 0 1
7847: ARRAY
7848: PPUSH
7849: LD_INT 2
7851: PUSH
7852: LD_INT 30
7854: PUSH
7855: LD_INT 6
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: LD_INT 30
7864: PUSH
7865: LD_INT 7
7867: PUSH
7868: EMPTY
7869: LIST
7870: LIST
7871: PUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 8
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: PPUSH
7888: CALL_OW 72
7892: AND
7893: PUSH
7894: LD_EXP 56
7898: PUSH
7899: LD_VAR 0 1
7903: ARRAY
7904: PPUSH
7905: LD_INT 30
7907: PUSH
7908: LD_INT 3
7910: PUSH
7911: EMPTY
7912: LIST
7913: LIST
7914: PPUSH
7915: CALL_OW 72
7919: AND
7920: IFFALSE 8447
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
7922: LD_ADDR_EXP 98
7926: PUSH
7927: LD_EXP 98
7931: PPUSH
7932: LD_VAR 0 1
7936: PPUSH
7937: LD_INT 3
7939: PPUSH
7940: CALL_OW 1
7944: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
7945: LD_ADDR_VAR 0 2
7949: PUSH
7950: LD_INT 0
7952: PUSH
7953: LD_INT 0
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: ST_TO_ADDR
// if not eng then
7968: LD_VAR 0 6
7972: NOT
7973: IFFALSE 8036
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
7975: LD_ADDR_VAR 0 11
7979: PUSH
7980: LD_VAR 0 4
7984: PPUSH
7985: LD_INT 2
7987: PPUSH
7988: CALL 71329 0 2
7992: PUSH
7993: LD_INT 1
7995: ARRAY
7996: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
7997: LD_ADDR_VAR 0 2
8001: PUSH
8002: LD_VAR 0 2
8006: PPUSH
8007: LD_INT 2
8009: PPUSH
8010: LD_VAR 0 11
8014: PPUSH
8015: CALL_OW 1
8019: ST_TO_ADDR
// tmp := tmp diff p ;
8020: LD_ADDR_VAR 0 4
8024: PUSH
8025: LD_VAR 0 4
8029: PUSH
8030: LD_VAR 0 11
8034: DIFF
8035: ST_TO_ADDR
// end ; if not eng then
8036: LD_VAR 0 6
8040: NOT
8041: IFFALSE 8067
// tmp := tmp diff ( mech union sci ) else
8043: LD_ADDR_VAR 0 4
8047: PUSH
8048: LD_VAR 0 4
8052: PUSH
8053: LD_VAR 0 7
8057: PUSH
8058: LD_VAR 0 8
8062: UNION
8063: DIFF
8064: ST_TO_ADDR
8065: GO 8099
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
8067: LD_ADDR_VAR 0 4
8071: PUSH
8072: LD_VAR 0 4
8076: PUSH
8077: LD_VAR 0 6
8081: PUSH
8082: LD_INT 1
8084: ARRAY
8085: PUSH
8086: LD_VAR 0 7
8090: UNION
8091: PUSH
8092: LD_VAR 0 8
8096: UNION
8097: DIFF
8098: ST_TO_ADDR
// if tmp and sci < 6 then
8099: LD_VAR 0 4
8103: PUSH
8104: LD_VAR 0 8
8108: PUSH
8109: LD_INT 6
8111: LESS
8112: AND
8113: IFFALSE 8272
// begin sort := SortBySkill ( tmp , 4 ) ;
8115: LD_ADDR_VAR 0 9
8119: PUSH
8120: LD_VAR 0 4
8124: PPUSH
8125: LD_INT 4
8127: PPUSH
8128: CALL 71329 0 2
8132: ST_TO_ADDR
// p := [ ] ;
8133: LD_ADDR_VAR 0 11
8137: PUSH
8138: EMPTY
8139: ST_TO_ADDR
// if sort then
8140: LD_VAR 0 9
8144: IFFALSE 8243
// for i = 1 to 6 - sci do
8146: LD_ADDR_VAR 0 3
8150: PUSH
8151: DOUBLE
8152: LD_INT 1
8154: DEC
8155: ST_TO_ADDR
8156: LD_INT 6
8158: PUSH
8159: LD_VAR 0 8
8163: MINUS
8164: PUSH
8165: FOR_TO
8166: IFFALSE 8241
// begin if i = sort then
8168: LD_VAR 0 3
8172: PUSH
8173: LD_VAR 0 9
8177: EQUAL
8178: IFFALSE 8182
// break ;
8180: GO 8241
// p := Insert ( p , p + 1 , sort [ i ] ) ;
8182: LD_ADDR_VAR 0 11
8186: PUSH
8187: LD_VAR 0 11
8191: PPUSH
8192: LD_VAR 0 11
8196: PUSH
8197: LD_INT 1
8199: PLUS
8200: PPUSH
8201: LD_VAR 0 9
8205: PUSH
8206: LD_VAR 0 3
8210: ARRAY
8211: PPUSH
8212: CALL_OW 2
8216: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
8217: LD_ADDR_VAR 0 4
8221: PUSH
8222: LD_VAR 0 4
8226: PUSH
8227: LD_VAR 0 9
8231: PUSH
8232: LD_VAR 0 3
8236: ARRAY
8237: DIFF
8238: ST_TO_ADDR
// end ;
8239: GO 8165
8241: POP
8242: POP
// if p then
8243: LD_VAR 0 11
8247: IFFALSE 8272
// result := Replace ( result , 4 , p ) ;
8249: LD_ADDR_VAR 0 2
8253: PUSH
8254: LD_VAR 0 2
8258: PPUSH
8259: LD_INT 4
8261: PPUSH
8262: LD_VAR 0 11
8266: PPUSH
8267: CALL_OW 1
8271: ST_TO_ADDR
// end ; if tmp and mech < 6 then
8272: LD_VAR 0 4
8276: PUSH
8277: LD_VAR 0 7
8281: PUSH
8282: LD_INT 6
8284: LESS
8285: AND
8286: IFFALSE 8445
// begin sort := SortBySkill ( tmp , 3 ) ;
8288: LD_ADDR_VAR 0 9
8292: PUSH
8293: LD_VAR 0 4
8297: PPUSH
8298: LD_INT 3
8300: PPUSH
8301: CALL 71329 0 2
8305: ST_TO_ADDR
// p := [ ] ;
8306: LD_ADDR_VAR 0 11
8310: PUSH
8311: EMPTY
8312: ST_TO_ADDR
// if sort then
8313: LD_VAR 0 9
8317: IFFALSE 8416
// for i = 1 to 6 - mech do
8319: LD_ADDR_VAR 0 3
8323: PUSH
8324: DOUBLE
8325: LD_INT 1
8327: DEC
8328: ST_TO_ADDR
8329: LD_INT 6
8331: PUSH
8332: LD_VAR 0 7
8336: MINUS
8337: PUSH
8338: FOR_TO
8339: IFFALSE 8414
// begin if i = sort then
8341: LD_VAR 0 3
8345: PUSH
8346: LD_VAR 0 9
8350: EQUAL
8351: IFFALSE 8355
// break ;
8353: GO 8414
// p := Insert ( p , p + 1 , sort [ i ] ) ;
8355: LD_ADDR_VAR 0 11
8359: PUSH
8360: LD_VAR 0 11
8364: PPUSH
8365: LD_VAR 0 11
8369: PUSH
8370: LD_INT 1
8372: PLUS
8373: PPUSH
8374: LD_VAR 0 9
8378: PUSH
8379: LD_VAR 0 3
8383: ARRAY
8384: PPUSH
8385: CALL_OW 2
8389: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
8390: LD_ADDR_VAR 0 4
8394: PUSH
8395: LD_VAR 0 4
8399: PUSH
8400: LD_VAR 0 9
8404: PUSH
8405: LD_VAR 0 3
8409: ARRAY
8410: DIFF
8411: ST_TO_ADDR
// end ;
8412: GO 8338
8414: POP
8415: POP
// if p then
8416: LD_VAR 0 11
8420: IFFALSE 8445
// result := Replace ( result , 3 , p ) ;
8422: LD_ADDR_VAR 0 2
8426: PUSH
8427: LD_VAR 0 2
8431: PPUSH
8432: LD_INT 3
8434: PPUSH
8435: LD_VAR 0 11
8439: PPUSH
8440: CALL_OW 1
8444: ST_TO_ADDR
// end ; exit ;
8445: GO 9717
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
8447: LD_EXP 83
8451: PUSH
8452: LD_EXP 82
8456: PUSH
8457: LD_VAR 0 1
8461: ARRAY
8462: ARRAY
8463: NOT
8464: PUSH
8465: LD_EXP 56
8469: PUSH
8470: LD_VAR 0 1
8474: ARRAY
8475: PPUSH
8476: LD_INT 30
8478: PUSH
8479: LD_INT 3
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: PPUSH
8486: CALL_OW 72
8490: AND
8491: PUSH
8492: LD_EXP 61
8496: PUSH
8497: LD_VAR 0 1
8501: ARRAY
8502: AND
8503: IFFALSE 9047
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
8505: LD_ADDR_EXP 98
8509: PUSH
8510: LD_EXP 98
8514: PPUSH
8515: LD_VAR 0 1
8519: PPUSH
8520: LD_INT 5
8522: PPUSH
8523: CALL_OW 1
8527: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
8528: LD_ADDR_VAR 0 2
8532: PUSH
8533: LD_INT 0
8535: PUSH
8536: LD_INT 0
8538: PUSH
8539: LD_INT 0
8541: PUSH
8542: LD_INT 0
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: ST_TO_ADDR
// if sci > 1 then
8551: LD_VAR 0 8
8555: PUSH
8556: LD_INT 1
8558: GREATER
8559: IFFALSE 8587
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
8561: LD_ADDR_VAR 0 4
8565: PUSH
8566: LD_VAR 0 4
8570: PUSH
8571: LD_VAR 0 8
8575: PUSH
8576: LD_VAR 0 8
8580: PUSH
8581: LD_INT 1
8583: ARRAY
8584: DIFF
8585: DIFF
8586: ST_TO_ADDR
// if tmp and not sci then
8587: LD_VAR 0 4
8591: PUSH
8592: LD_VAR 0 8
8596: NOT
8597: AND
8598: IFFALSE 8667
// begin sort := SortBySkill ( tmp , 4 ) ;
8600: LD_ADDR_VAR 0 9
8604: PUSH
8605: LD_VAR 0 4
8609: PPUSH
8610: LD_INT 4
8612: PPUSH
8613: CALL 71329 0 2
8617: ST_TO_ADDR
// if sort then
8618: LD_VAR 0 9
8622: IFFALSE 8638
// p := sort [ 1 ] ;
8624: LD_ADDR_VAR 0 11
8628: PUSH
8629: LD_VAR 0 9
8633: PUSH
8634: LD_INT 1
8636: ARRAY
8637: ST_TO_ADDR
// if p then
8638: LD_VAR 0 11
8642: IFFALSE 8667
// result := Replace ( result , 4 , p ) ;
8644: LD_ADDR_VAR 0 2
8648: PUSH
8649: LD_VAR 0 2
8653: PPUSH
8654: LD_INT 4
8656: PPUSH
8657: LD_VAR 0 11
8661: PPUSH
8662: CALL_OW 1
8666: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
8667: LD_ADDR_VAR 0 4
8671: PUSH
8672: LD_VAR 0 4
8676: PUSH
8677: LD_VAR 0 7
8681: DIFF
8682: ST_TO_ADDR
// if tmp and mech < 6 then
8683: LD_VAR 0 4
8687: PUSH
8688: LD_VAR 0 7
8692: PUSH
8693: LD_INT 6
8695: LESS
8696: AND
8697: IFFALSE 8856
// begin sort := SortBySkill ( tmp , 3 ) ;
8699: LD_ADDR_VAR 0 9
8703: PUSH
8704: LD_VAR 0 4
8708: PPUSH
8709: LD_INT 3
8711: PPUSH
8712: CALL 71329 0 2
8716: ST_TO_ADDR
// p := [ ] ;
8717: LD_ADDR_VAR 0 11
8721: PUSH
8722: EMPTY
8723: ST_TO_ADDR
// if sort then
8724: LD_VAR 0 9
8728: IFFALSE 8827
// for i = 1 to 6 - mech do
8730: LD_ADDR_VAR 0 3
8734: PUSH
8735: DOUBLE
8736: LD_INT 1
8738: DEC
8739: ST_TO_ADDR
8740: LD_INT 6
8742: PUSH
8743: LD_VAR 0 7
8747: MINUS
8748: PUSH
8749: FOR_TO
8750: IFFALSE 8825
// begin if i = sort then
8752: LD_VAR 0 3
8756: PUSH
8757: LD_VAR 0 9
8761: EQUAL
8762: IFFALSE 8766
// break ;
8764: GO 8825
// p := Insert ( p , p + 1 , sort [ i ] ) ;
8766: LD_ADDR_VAR 0 11
8770: PUSH
8771: LD_VAR 0 11
8775: PPUSH
8776: LD_VAR 0 11
8780: PUSH
8781: LD_INT 1
8783: PLUS
8784: PPUSH
8785: LD_VAR 0 9
8789: PUSH
8790: LD_VAR 0 3
8794: ARRAY
8795: PPUSH
8796: CALL_OW 2
8800: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
8801: LD_ADDR_VAR 0 4
8805: PUSH
8806: LD_VAR 0 4
8810: PUSH
8811: LD_VAR 0 9
8815: PUSH
8816: LD_VAR 0 3
8820: ARRAY
8821: DIFF
8822: ST_TO_ADDR
// end ;
8823: GO 8749
8825: POP
8826: POP
// if p then
8827: LD_VAR 0 11
8831: IFFALSE 8856
// result := Replace ( result , 3 , p ) ;
8833: LD_ADDR_VAR 0 2
8837: PUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: LD_INT 3
8845: PPUSH
8846: LD_VAR 0 11
8850: PPUSH
8851: CALL_OW 1
8855: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
8856: LD_ADDR_VAR 0 4
8860: PUSH
8861: LD_VAR 0 4
8865: PUSH
8866: LD_VAR 0 6
8870: DIFF
8871: ST_TO_ADDR
// if tmp and eng < 6 then
8872: LD_VAR 0 4
8876: PUSH
8877: LD_VAR 0 6
8881: PUSH
8882: LD_INT 6
8884: LESS
8885: AND
8886: IFFALSE 9045
// begin sort := SortBySkill ( tmp , 2 ) ;
8888: LD_ADDR_VAR 0 9
8892: PUSH
8893: LD_VAR 0 4
8897: PPUSH
8898: LD_INT 2
8900: PPUSH
8901: CALL 71329 0 2
8905: ST_TO_ADDR
// p := [ ] ;
8906: LD_ADDR_VAR 0 11
8910: PUSH
8911: EMPTY
8912: ST_TO_ADDR
// if sort then
8913: LD_VAR 0 9
8917: IFFALSE 9016
// for i = 1 to 6 - eng do
8919: LD_ADDR_VAR 0 3
8923: PUSH
8924: DOUBLE
8925: LD_INT 1
8927: DEC
8928: ST_TO_ADDR
8929: LD_INT 6
8931: PUSH
8932: LD_VAR 0 6
8936: MINUS
8937: PUSH
8938: FOR_TO
8939: IFFALSE 9014
// begin if i = sort then
8941: LD_VAR 0 3
8945: PUSH
8946: LD_VAR 0 9
8950: EQUAL
8951: IFFALSE 8955
// break ;
8953: GO 9014
// p := Insert ( p , p + 1 , sort [ i ] ) ;
8955: LD_ADDR_VAR 0 11
8959: PUSH
8960: LD_VAR 0 11
8964: PPUSH
8965: LD_VAR 0 11
8969: PUSH
8970: LD_INT 1
8972: PLUS
8973: PPUSH
8974: LD_VAR 0 9
8978: PUSH
8979: LD_VAR 0 3
8983: ARRAY
8984: PPUSH
8985: CALL_OW 2
8989: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
8990: LD_ADDR_VAR 0 4
8994: PUSH
8995: LD_VAR 0 4
8999: PUSH
9000: LD_VAR 0 9
9004: PUSH
9005: LD_VAR 0 3
9009: ARRAY
9010: DIFF
9011: ST_TO_ADDR
// end ;
9012: GO 8938
9014: POP
9015: POP
// if p then
9016: LD_VAR 0 11
9020: IFFALSE 9045
// result := Replace ( result , 2 , p ) ;
9022: LD_ADDR_VAR 0 2
9026: PUSH
9027: LD_VAR 0 2
9031: PPUSH
9032: LD_INT 2
9034: PPUSH
9035: LD_VAR 0 11
9039: PPUSH
9040: CALL_OW 1
9044: ST_TO_ADDR
// end ; exit ;
9045: GO 9717
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
9047: LD_EXP 83
9051: PUSH
9052: LD_EXP 82
9056: PUSH
9057: LD_VAR 0 1
9061: ARRAY
9062: ARRAY
9063: NOT
9064: PUSH
9065: LD_EXP 56
9069: PUSH
9070: LD_VAR 0 1
9074: ARRAY
9075: PPUSH
9076: LD_INT 30
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PPUSH
9086: CALL_OW 72
9090: AND
9091: PUSH
9092: LD_EXP 61
9096: PUSH
9097: LD_VAR 0 1
9101: ARRAY
9102: NOT
9103: AND
9104: IFFALSE 9717
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
9106: LD_ADDR_EXP 98
9110: PUSH
9111: LD_EXP 98
9115: PPUSH
9116: LD_VAR 0 1
9120: PPUSH
9121: LD_INT 6
9123: PPUSH
9124: CALL_OW 1
9128: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
9129: LD_ADDR_VAR 0 2
9133: PUSH
9134: LD_INT 0
9136: PUSH
9137: LD_INT 0
9139: PUSH
9140: LD_INT 0
9142: PUSH
9143: LD_INT 0
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: ST_TO_ADDR
// if sci >= 1 then
9152: LD_VAR 0 8
9156: PUSH
9157: LD_INT 1
9159: GREATEREQUAL
9160: IFFALSE 9182
// tmp := tmp diff sci [ 1 ] ;
9162: LD_ADDR_VAR 0 4
9166: PUSH
9167: LD_VAR 0 4
9171: PUSH
9172: LD_VAR 0 8
9176: PUSH
9177: LD_INT 1
9179: ARRAY
9180: DIFF
9181: ST_TO_ADDR
// if tmp and not sci then
9182: LD_VAR 0 4
9186: PUSH
9187: LD_VAR 0 8
9191: NOT
9192: AND
9193: IFFALSE 9262
// begin sort := SortBySkill ( tmp , 4 ) ;
9195: LD_ADDR_VAR 0 9
9199: PUSH
9200: LD_VAR 0 4
9204: PPUSH
9205: LD_INT 4
9207: PPUSH
9208: CALL 71329 0 2
9212: ST_TO_ADDR
// if sort then
9213: LD_VAR 0 9
9217: IFFALSE 9233
// p := sort [ 1 ] ;
9219: LD_ADDR_VAR 0 11
9223: PUSH
9224: LD_VAR 0 9
9228: PUSH
9229: LD_INT 1
9231: ARRAY
9232: ST_TO_ADDR
// if p then
9233: LD_VAR 0 11
9237: IFFALSE 9262
// result := Replace ( result , 4 , p ) ;
9239: LD_ADDR_VAR 0 2
9243: PUSH
9244: LD_VAR 0 2
9248: PPUSH
9249: LD_INT 4
9251: PPUSH
9252: LD_VAR 0 11
9256: PPUSH
9257: CALL_OW 1
9261: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
9262: LD_ADDR_VAR 0 4
9266: PUSH
9267: LD_VAR 0 4
9271: PUSH
9272: LD_VAR 0 7
9276: DIFF
9277: ST_TO_ADDR
// if tmp and mech < 6 then
9278: LD_VAR 0 4
9282: PUSH
9283: LD_VAR 0 7
9287: PUSH
9288: LD_INT 6
9290: LESS
9291: AND
9292: IFFALSE 9451
// begin sort := SortBySkill ( tmp , 3 ) ;
9294: LD_ADDR_VAR 0 9
9298: PUSH
9299: LD_VAR 0 4
9303: PPUSH
9304: LD_INT 3
9306: PPUSH
9307: CALL 71329 0 2
9311: ST_TO_ADDR
// p := [ ] ;
9312: LD_ADDR_VAR 0 11
9316: PUSH
9317: EMPTY
9318: ST_TO_ADDR
// if sort then
9319: LD_VAR 0 9
9323: IFFALSE 9422
// for i = 1 to 6 - mech do
9325: LD_ADDR_VAR 0 3
9329: PUSH
9330: DOUBLE
9331: LD_INT 1
9333: DEC
9334: ST_TO_ADDR
9335: LD_INT 6
9337: PUSH
9338: LD_VAR 0 7
9342: MINUS
9343: PUSH
9344: FOR_TO
9345: IFFALSE 9420
// begin if i = sort then
9347: LD_VAR 0 3
9351: PUSH
9352: LD_VAR 0 9
9356: EQUAL
9357: IFFALSE 9361
// break ;
9359: GO 9420
// p := Insert ( p , p + 1 , sort [ i ] ) ;
9361: LD_ADDR_VAR 0 11
9365: PUSH
9366: LD_VAR 0 11
9370: PPUSH
9371: LD_VAR 0 11
9375: PUSH
9376: LD_INT 1
9378: PLUS
9379: PPUSH
9380: LD_VAR 0 9
9384: PUSH
9385: LD_VAR 0 3
9389: ARRAY
9390: PPUSH
9391: CALL_OW 2
9395: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
9396: LD_ADDR_VAR 0 4
9400: PUSH
9401: LD_VAR 0 4
9405: PUSH
9406: LD_VAR 0 9
9410: PUSH
9411: LD_VAR 0 3
9415: ARRAY
9416: DIFF
9417: ST_TO_ADDR
// end ;
9418: GO 9344
9420: POP
9421: POP
// if p then
9422: LD_VAR 0 11
9426: IFFALSE 9451
// result := Replace ( result , 3 , p ) ;
9428: LD_ADDR_VAR 0 2
9432: PUSH
9433: LD_VAR 0 2
9437: PPUSH
9438: LD_INT 3
9440: PPUSH
9441: LD_VAR 0 11
9445: PPUSH
9446: CALL_OW 1
9450: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
9451: LD_ADDR_VAR 0 4
9455: PUSH
9456: LD_VAR 0 4
9460: PUSH
9461: LD_VAR 0 6
9465: DIFF
9466: ST_TO_ADDR
// if tmp and eng < 4 then
9467: LD_VAR 0 4
9471: PUSH
9472: LD_VAR 0 6
9476: PUSH
9477: LD_INT 4
9479: LESS
9480: AND
9481: IFFALSE 9642
// begin sort := SortBySkill ( tmp , 2 ) ;
9483: LD_ADDR_VAR 0 9
9487: PUSH
9488: LD_VAR 0 4
9492: PPUSH
9493: LD_INT 2
9495: PPUSH
9496: CALL 71329 0 2
9500: ST_TO_ADDR
// p := [ ] ;
9501: LD_ADDR_VAR 0 11
9505: PUSH
9506: EMPTY
9507: ST_TO_ADDR
// if sort then
9508: LD_VAR 0 9
9512: IFFALSE 9611
// for i = 1 to 4 - eng do
9514: LD_ADDR_VAR 0 3
9518: PUSH
9519: DOUBLE
9520: LD_INT 1
9522: DEC
9523: ST_TO_ADDR
9524: LD_INT 4
9526: PUSH
9527: LD_VAR 0 6
9531: MINUS
9532: PUSH
9533: FOR_TO
9534: IFFALSE 9609
// begin if i = sort then
9536: LD_VAR 0 3
9540: PUSH
9541: LD_VAR 0 9
9545: EQUAL
9546: IFFALSE 9550
// break ;
9548: GO 9609
// p := Insert ( p , p + 1 , sort [ i ] ) ;
9550: LD_ADDR_VAR 0 11
9554: PUSH
9555: LD_VAR 0 11
9559: PPUSH
9560: LD_VAR 0 11
9564: PUSH
9565: LD_INT 1
9567: PLUS
9568: PPUSH
9569: LD_VAR 0 9
9573: PUSH
9574: LD_VAR 0 3
9578: ARRAY
9579: PPUSH
9580: CALL_OW 2
9584: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
9585: LD_ADDR_VAR 0 4
9589: PUSH
9590: LD_VAR 0 4
9594: PUSH
9595: LD_VAR 0 9
9599: PUSH
9600: LD_VAR 0 3
9604: ARRAY
9605: DIFF
9606: ST_TO_ADDR
// end ;
9607: GO 9533
9609: POP
9610: POP
// if p then
9611: LD_VAR 0 11
9615: IFFALSE 9640
// result := Replace ( result , 2 , p ) ;
9617: LD_ADDR_VAR 0 2
9621: PUSH
9622: LD_VAR 0 2
9626: PPUSH
9627: LD_INT 2
9629: PPUSH
9630: LD_VAR 0 11
9634: PPUSH
9635: CALL_OW 1
9639: ST_TO_ADDR
// end else
9640: GO 9686
// for i = eng downto 5 do
9642: LD_ADDR_VAR 0 3
9646: PUSH
9647: DOUBLE
9648: LD_VAR 0 6
9652: INC
9653: ST_TO_ADDR
9654: LD_INT 5
9656: PUSH
9657: FOR_DOWNTO
9658: IFFALSE 9684
// tmp := tmp union eng [ i ] ;
9660: LD_ADDR_VAR 0 4
9664: PUSH
9665: LD_VAR 0 4
9669: PUSH
9670: LD_VAR 0 6
9674: PUSH
9675: LD_VAR 0 3
9679: ARRAY
9680: UNION
9681: ST_TO_ADDR
9682: GO 9657
9684: POP
9685: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_VAR 0 2
9695: PPUSH
9696: LD_INT 1
9698: PPUSH
9699: LD_VAR 0 4
9703: PUSH
9704: LD_VAR 0 5
9708: DIFF
9709: PPUSH
9710: CALL_OW 1
9714: ST_TO_ADDR
// exit ;
9715: GO 9717
// end ; end ;
9717: LD_VAR 0 2
9721: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
9722: LD_INT 0
9724: PPUSH
9725: PPUSH
9726: PPUSH
// if not mc_bases then
9727: LD_EXP 56
9731: NOT
9732: IFFALSE 9736
// exit ;
9734: GO 9842
// for i = 1 to mc_bases do
9736: LD_ADDR_VAR 0 2
9740: PUSH
9741: DOUBLE
9742: LD_INT 1
9744: DEC
9745: ST_TO_ADDR
9746: LD_EXP 56
9750: PUSH
9751: FOR_TO
9752: IFFALSE 9833
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9754: LD_ADDR_VAR 0 3
9758: PUSH
9759: LD_EXP 56
9763: PUSH
9764: LD_VAR 0 2
9768: ARRAY
9769: PPUSH
9770: LD_INT 21
9772: PUSH
9773: LD_INT 3
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PUSH
9780: LD_INT 3
9782: PUSH
9783: LD_INT 24
9785: PUSH
9786: LD_INT 1000
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: EMPTY
9798: LIST
9799: LIST
9800: PPUSH
9801: CALL_OW 72
9805: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
9806: LD_ADDR_EXP 57
9810: PUSH
9811: LD_EXP 57
9815: PPUSH
9816: LD_VAR 0 2
9820: PPUSH
9821: LD_VAR 0 3
9825: PPUSH
9826: CALL_OW 1
9830: ST_TO_ADDR
// end ;
9831: GO 9751
9833: POP
9834: POP
// RaiseSailEvent ( 101 ) ;
9835: LD_INT 101
9837: PPUSH
9838: CALL_OW 427
// end ;
9842: LD_VAR 0 1
9846: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
9847: LD_INT 0
9849: PPUSH
9850: PPUSH
9851: PPUSH
9852: PPUSH
9853: PPUSH
9854: PPUSH
9855: PPUSH
// if not mc_bases then
9856: LD_EXP 56
9860: NOT
9861: IFFALSE 9865
// exit ;
9863: GO 10438
// for i = 1 to mc_bases do
9865: LD_ADDR_VAR 0 2
9869: PUSH
9870: DOUBLE
9871: LD_INT 1
9873: DEC
9874: ST_TO_ADDR
9875: LD_EXP 56
9879: PUSH
9880: FOR_TO
9881: IFFALSE 10429
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
9883: LD_ADDR_VAR 0 5
9887: PUSH
9888: LD_EXP 56
9892: PUSH
9893: LD_VAR 0 2
9897: ARRAY
9898: PUSH
9899: LD_EXP 85
9903: PUSH
9904: LD_VAR 0 2
9908: ARRAY
9909: UNION
9910: PPUSH
9911: LD_INT 21
9913: PUSH
9914: LD_INT 1
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: PUSH
9921: LD_INT 1
9923: PUSH
9924: LD_INT 3
9926: PUSH
9927: LD_INT 54
9929: PUSH
9930: EMPTY
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: LD_INT 24
9942: PUSH
9943: LD_INT 750
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: LIST
9958: PUSH
9959: EMPTY
9960: LIST
9961: LIST
9962: PPUSH
9963: CALL_OW 72
9967: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
9968: LD_ADDR_VAR 0 6
9972: PUSH
9973: LD_EXP 56
9977: PUSH
9978: LD_VAR 0 2
9982: ARRAY
9983: PPUSH
9984: LD_INT 21
9986: PUSH
9987: LD_INT 1
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: PUSH
9994: LD_INT 1
9996: PUSH
9997: LD_INT 3
9999: PUSH
10000: LD_INT 54
10002: PUSH
10003: EMPTY
10004: LIST
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PUSH
10010: LD_INT 3
10012: PUSH
10013: LD_INT 24
10015: PUSH
10016: LD_INT 250
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 72
10040: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
10041: LD_ADDR_VAR 0 7
10045: PUSH
10046: LD_VAR 0 5
10050: PUSH
10051: LD_VAR 0 6
10055: DIFF
10056: ST_TO_ADDR
// if not need_heal_1 then
10057: LD_VAR 0 6
10061: NOT
10062: IFFALSE 10095
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
10064: LD_ADDR_EXP 59
10068: PUSH
10069: LD_EXP 59
10073: PPUSH
10074: LD_VAR 0 2
10078: PUSH
10079: LD_INT 1
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: PPUSH
10086: EMPTY
10087: PPUSH
10088: CALL 37144 0 3
10092: ST_TO_ADDR
10093: GO 10165
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
10095: LD_ADDR_EXP 59
10099: PUSH
10100: LD_EXP 59
10104: PPUSH
10105: LD_VAR 0 2
10109: PUSH
10110: LD_INT 1
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: PPUSH
10117: LD_EXP 59
10121: PUSH
10122: LD_VAR 0 2
10126: ARRAY
10127: PUSH
10128: LD_INT 1
10130: ARRAY
10131: PPUSH
10132: LD_INT 3
10134: PUSH
10135: LD_INT 24
10137: PUSH
10138: LD_INT 1000
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PPUSH
10149: CALL_OW 72
10153: PUSH
10154: LD_VAR 0 6
10158: UNION
10159: PPUSH
10160: CALL 37144 0 3
10164: ST_TO_ADDR
// if not need_heal_2 then
10165: LD_VAR 0 7
10169: NOT
10170: IFFALSE 10203
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
10172: LD_ADDR_EXP 59
10176: PUSH
10177: LD_EXP 59
10181: PPUSH
10182: LD_VAR 0 2
10186: PUSH
10187: LD_INT 2
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: EMPTY
10195: PPUSH
10196: CALL 37144 0 3
10200: ST_TO_ADDR
10201: GO 10235
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
10203: LD_ADDR_EXP 59
10207: PUSH
10208: LD_EXP 59
10212: PPUSH
10213: LD_VAR 0 2
10217: PUSH
10218: LD_INT 2
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PPUSH
10225: LD_VAR 0 7
10229: PPUSH
10230: CALL 37144 0 3
10234: ST_TO_ADDR
// if need_heal_2 then
10235: LD_VAR 0 7
10239: IFFALSE 10411
// for j in need_heal_2 do
10241: LD_ADDR_VAR 0 3
10245: PUSH
10246: LD_VAR 0 7
10250: PUSH
10251: FOR_IN
10252: IFFALSE 10409
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
10254: LD_ADDR_VAR 0 5
10258: PUSH
10259: LD_EXP 56
10263: PUSH
10264: LD_VAR 0 2
10268: ARRAY
10269: PPUSH
10270: LD_INT 2
10272: PUSH
10273: LD_INT 30
10275: PUSH
10276: LD_INT 6
10278: PUSH
10279: EMPTY
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 7
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 8
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: LD_INT 30
10305: PUSH
10306: LD_INT 0
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 30
10315: PUSH
10316: LD_INT 1
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PUSH
10323: LD_INT 25
10325: PUSH
10326: LD_INT 4
10328: PUSH
10329: EMPTY
10330: LIST
10331: LIST
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PPUSH
10342: CALL_OW 72
10346: ST_TO_ADDR
// if tmp then
10347: LD_VAR 0 5
10351: IFFALSE 10407
// begin k := NearestUnitToUnit ( tmp , j ) ;
10353: LD_ADDR_VAR 0 4
10357: PUSH
10358: LD_VAR 0 5
10362: PPUSH
10363: LD_VAR 0 3
10367: PPUSH
10368: CALL_OW 74
10372: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
10373: LD_VAR 0 3
10377: PPUSH
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 296
10387: PUSH
10388: LD_INT 7
10390: GREATER
10391: IFFALSE 10407
// ComMoveUnit ( j , k ) ;
10393: LD_VAR 0 3
10397: PPUSH
10398: LD_VAR 0 4
10402: PPUSH
10403: CALL_OW 112
// end ; end ;
10407: GO 10251
10409: POP
10410: POP
// if not need_heal_1 and not need_heal_2 then
10411: LD_VAR 0 6
10415: NOT
10416: PUSH
10417: LD_VAR 0 7
10421: NOT
10422: AND
10423: IFFALSE 10427
// continue ;
10425: GO 9880
// end ;
10427: GO 9880
10429: POP
10430: POP
// RaiseSailEvent ( 102 ) ;
10431: LD_INT 102
10433: PPUSH
10434: CALL_OW 427
// end ;
10438: LD_VAR 0 1
10442: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
10443: LD_INT 0
10445: PPUSH
10446: PPUSH
10447: PPUSH
10448: PPUSH
10449: PPUSH
// if not mc_bases then
10450: LD_EXP 56
10454: NOT
10455: IFFALSE 10459
// exit ;
10457: GO 10844
// for i = 1 to mc_bases do
10459: LD_ADDR_VAR 0 2
10463: PUSH
10464: DOUBLE
10465: LD_INT 1
10467: DEC
10468: ST_TO_ADDR
10469: LD_EXP 56
10473: PUSH
10474: FOR_TO
10475: IFFALSE 10842
// begin if not mc_building_need_repair [ i ] then
10477: LD_EXP 57
10481: PUSH
10482: LD_VAR 0 2
10486: ARRAY
10487: NOT
10488: IFFALSE 10526
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
10490: LD_ADDR_EXP 58
10494: PUSH
10495: LD_EXP 58
10499: PPUSH
10500: LD_VAR 0 2
10504: PPUSH
10505: EMPTY
10506: PPUSH
10507: CALL_OW 1
10511: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
10512: LD_VAR 0 2
10516: PPUSH
10517: LD_INT 101
10519: PPUSH
10520: CALL 5887 0 2
// continue ;
10524: GO 10474
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
10526: LD_ADDR_EXP 62
10530: PUSH
10531: LD_EXP 62
10535: PPUSH
10536: LD_VAR 0 2
10540: PPUSH
10541: EMPTY
10542: PPUSH
10543: CALL_OW 1
10547: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
10548: LD_VAR 0 2
10552: PPUSH
10553: LD_INT 103
10555: PPUSH
10556: CALL 5887 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
10560: LD_ADDR_VAR 0 5
10564: PUSH
10565: LD_EXP 56
10569: PUSH
10570: LD_VAR 0 2
10574: ARRAY
10575: PUSH
10576: LD_EXP 85
10580: PUSH
10581: LD_VAR 0 2
10585: ARRAY
10586: UNION
10587: PPUSH
10588: LD_INT 2
10590: PUSH
10591: LD_INT 25
10593: PUSH
10594: LD_INT 2
10596: PUSH
10597: EMPTY
10598: LIST
10599: LIST
10600: PUSH
10601: LD_INT 25
10603: PUSH
10604: LD_INT 16
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: EMPTY
10617: LIST
10618: PPUSH
10619: CALL_OW 72
10623: ST_TO_ADDR
// if not tmp then
10624: LD_VAR 0 5
10628: NOT
10629: IFFALSE 10633
// continue ;
10631: GO 10474
// for j in tmp do
10633: LD_ADDR_VAR 0 3
10637: PUSH
10638: LD_VAR 0 5
10642: PUSH
10643: FOR_IN
10644: IFFALSE 10838
// begin if mc_need_heal [ i ] then
10646: LD_EXP 59
10650: PUSH
10651: LD_VAR 0 2
10655: ARRAY
10656: IFFALSE 10704
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
10658: LD_VAR 0 3
10662: PUSH
10663: LD_EXP 59
10667: PUSH
10668: LD_VAR 0 2
10672: ARRAY
10673: PUSH
10674: LD_INT 1
10676: ARRAY
10677: IN
10678: PUSH
10679: LD_VAR 0 3
10683: PUSH
10684: LD_EXP 59
10688: PUSH
10689: LD_VAR 0 2
10693: ARRAY
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: IN
10699: OR
10700: IFFALSE 10704
// continue ;
10702: GO 10643
// if IsInUnit ( j ) then
10704: LD_VAR 0 3
10708: PPUSH
10709: CALL_OW 310
10713: IFFALSE 10724
// ComExitBuilding ( j ) ;
10715: LD_VAR 0 3
10719: PPUSH
10720: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
10724: LD_VAR 0 3
10728: PUSH
10729: LD_EXP 58
10733: PUSH
10734: LD_VAR 0 2
10738: ARRAY
10739: IN
10740: NOT
10741: IFFALSE 10799
// begin SetTag ( j , 101 ) ;
10743: LD_VAR 0 3
10747: PPUSH
10748: LD_INT 101
10750: PPUSH
10751: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
10755: LD_ADDR_EXP 58
10759: PUSH
10760: LD_EXP 58
10764: PPUSH
10765: LD_VAR 0 2
10769: PUSH
10770: LD_EXP 58
10774: PUSH
10775: LD_VAR 0 2
10779: ARRAY
10780: PUSH
10781: LD_INT 1
10783: PLUS
10784: PUSH
10785: EMPTY
10786: LIST
10787: LIST
10788: PPUSH
10789: LD_VAR 0 3
10793: PPUSH
10794: CALL 37144 0 3
10798: ST_TO_ADDR
// end ; wait ( 1 ) ;
10799: LD_INT 1
10801: PPUSH
10802: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
10806: LD_VAR 0 3
10810: PPUSH
10811: LD_EXP 57
10815: PUSH
10816: LD_VAR 0 2
10820: ARRAY
10821: PPUSH
10822: LD_VAR 0 3
10826: PPUSH
10827: CALL_OW 74
10831: PPUSH
10832: CALL_OW 130
// end ;
10836: GO 10643
10838: POP
10839: POP
// end ;
10840: GO 10474
10842: POP
10843: POP
// end ;
10844: LD_VAR 0 1
10848: RET
// export function MC_Heal ; var i , j , tmp ; begin
10849: LD_INT 0
10851: PPUSH
10852: PPUSH
10853: PPUSH
10854: PPUSH
// if not mc_bases then
10855: LD_EXP 56
10859: NOT
10860: IFFALSE 10864
// exit ;
10862: GO 11266
// for i = 1 to mc_bases do
10864: LD_ADDR_VAR 0 2
10868: PUSH
10869: DOUBLE
10870: LD_INT 1
10872: DEC
10873: ST_TO_ADDR
10874: LD_EXP 56
10878: PUSH
10879: FOR_TO
10880: IFFALSE 11264
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
10882: LD_EXP 59
10886: PUSH
10887: LD_VAR 0 2
10891: ARRAY
10892: PUSH
10893: LD_INT 1
10895: ARRAY
10896: NOT
10897: PUSH
10898: LD_EXP 59
10902: PUSH
10903: LD_VAR 0 2
10907: ARRAY
10908: PUSH
10909: LD_INT 2
10911: ARRAY
10912: NOT
10913: AND
10914: IFFALSE 10952
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
10916: LD_ADDR_EXP 60
10920: PUSH
10921: LD_EXP 60
10925: PPUSH
10926: LD_VAR 0 2
10930: PPUSH
10931: EMPTY
10932: PPUSH
10933: CALL_OW 1
10937: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
10938: LD_VAR 0 2
10942: PPUSH
10943: LD_INT 102
10945: PPUSH
10946: CALL 5887 0 2
// continue ;
10950: GO 10879
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
10952: LD_ADDR_VAR 0 4
10956: PUSH
10957: LD_EXP 56
10961: PUSH
10962: LD_VAR 0 2
10966: ARRAY
10967: PPUSH
10968: LD_INT 25
10970: PUSH
10971: LD_INT 4
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PPUSH
10978: CALL_OW 72
10982: ST_TO_ADDR
// if not tmp then
10983: LD_VAR 0 4
10987: NOT
10988: IFFALSE 10992
// continue ;
10990: GO 10879
// if mc_taming [ i ] then
10992: LD_EXP 87
10996: PUSH
10997: LD_VAR 0 2
11001: ARRAY
11002: IFFALSE 11026
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
11004: LD_ADDR_EXP 87
11008: PUSH
11009: LD_EXP 87
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: EMPTY
11020: PPUSH
11021: CALL_OW 1
11025: ST_TO_ADDR
// for j in tmp do
11026: LD_ADDR_VAR 0 3
11030: PUSH
11031: LD_VAR 0 4
11035: PUSH
11036: FOR_IN
11037: IFFALSE 11260
// begin if IsInUnit ( j ) then
11039: LD_VAR 0 3
11043: PPUSH
11044: CALL_OW 310
11048: IFFALSE 11059
// ComExitBuilding ( j ) ;
11050: LD_VAR 0 3
11054: PPUSH
11055: CALL_OW 122
// if not j in mc_healers [ i ] then
11059: LD_VAR 0 3
11063: PUSH
11064: LD_EXP 60
11068: PUSH
11069: LD_VAR 0 2
11073: ARRAY
11074: IN
11075: NOT
11076: IFFALSE 11122
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
11078: LD_ADDR_EXP 60
11082: PUSH
11083: LD_EXP 60
11087: PPUSH
11088: LD_VAR 0 2
11092: PUSH
11093: LD_EXP 60
11097: PUSH
11098: LD_VAR 0 2
11102: ARRAY
11103: PUSH
11104: LD_INT 1
11106: PLUS
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PPUSH
11112: LD_VAR 0 3
11116: PPUSH
11117: CALL 37144 0 3
11121: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
11122: LD_VAR 0 3
11126: PPUSH
11127: CALL_OW 110
11131: PUSH
11132: LD_INT 102
11134: NONEQUAL
11135: IFFALSE 11149
// SetTag ( j , 102 ) ;
11137: LD_VAR 0 3
11141: PPUSH
11142: LD_INT 102
11144: PPUSH
11145: CALL_OW 109
// Wait ( 3 ) ;
11149: LD_INT 3
11151: PPUSH
11152: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
11156: LD_EXP 59
11160: PUSH
11161: LD_VAR 0 2
11165: ARRAY
11166: PUSH
11167: LD_INT 1
11169: ARRAY
11170: IFFALSE 11202
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
11172: LD_VAR 0 3
11176: PPUSH
11177: LD_EXP 59
11181: PUSH
11182: LD_VAR 0 2
11186: ARRAY
11187: PUSH
11188: LD_INT 1
11190: ARRAY
11191: PUSH
11192: LD_INT 1
11194: ARRAY
11195: PPUSH
11196: CALL_OW 128
11200: GO 11258
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
11202: LD_VAR 0 3
11206: PPUSH
11207: CALL_OW 314
11211: NOT
11212: PUSH
11213: LD_EXP 59
11217: PUSH
11218: LD_VAR 0 2
11222: ARRAY
11223: PUSH
11224: LD_INT 2
11226: ARRAY
11227: AND
11228: IFFALSE 11258
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
11230: LD_VAR 0 3
11234: PPUSH
11235: LD_EXP 59
11239: PUSH
11240: LD_VAR 0 2
11244: ARRAY
11245: PUSH
11246: LD_INT 2
11248: ARRAY
11249: PUSH
11250: LD_INT 1
11252: ARRAY
11253: PPUSH
11254: CALL_OW 128
// end ;
11258: GO 11036
11260: POP
11261: POP
// end ;
11262: GO 10879
11264: POP
11265: POP
// end ;
11266: LD_VAR 0 1
11270: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
11271: LD_INT 0
11273: PPUSH
11274: PPUSH
11275: PPUSH
11276: PPUSH
11277: PPUSH
// if not mc_bases then
11278: LD_EXP 56
11282: NOT
11283: IFFALSE 11287
// exit ;
11285: GO 12430
// for i = 1 to mc_bases do
11287: LD_ADDR_VAR 0 2
11291: PUSH
11292: DOUBLE
11293: LD_INT 1
11295: DEC
11296: ST_TO_ADDR
11297: LD_EXP 56
11301: PUSH
11302: FOR_TO
11303: IFFALSE 12428
// begin if mc_scan [ i ] then
11305: LD_EXP 79
11309: PUSH
11310: LD_VAR 0 2
11314: ARRAY
11315: IFFALSE 11319
// continue ;
11317: GO 11302
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
11319: LD_EXP 61
11323: PUSH
11324: LD_VAR 0 2
11328: ARRAY
11329: NOT
11330: PUSH
11331: LD_EXP 63
11335: PUSH
11336: LD_VAR 0 2
11340: ARRAY
11341: NOT
11342: AND
11343: PUSH
11344: LD_EXP 62
11348: PUSH
11349: LD_VAR 0 2
11353: ARRAY
11354: AND
11355: IFFALSE 11393
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
11357: LD_ADDR_EXP 62
11361: PUSH
11362: LD_EXP 62
11366: PPUSH
11367: LD_VAR 0 2
11371: PPUSH
11372: EMPTY
11373: PPUSH
11374: CALL_OW 1
11378: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
11379: LD_VAR 0 2
11383: PPUSH
11384: LD_INT 103
11386: PPUSH
11387: CALL 5887 0 2
// continue ;
11391: GO 11302
// end ; if mc_construct_list [ i ] then
11393: LD_EXP 63
11397: PUSH
11398: LD_VAR 0 2
11402: ARRAY
11403: IFFALSE 11623
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
11405: LD_ADDR_VAR 0 4
11409: PUSH
11410: LD_EXP 56
11414: PUSH
11415: LD_VAR 0 2
11419: ARRAY
11420: PPUSH
11421: LD_INT 25
11423: PUSH
11424: LD_INT 2
11426: PUSH
11427: EMPTY
11428: LIST
11429: LIST
11430: PPUSH
11431: CALL_OW 72
11435: PUSH
11436: LD_EXP 58
11440: PUSH
11441: LD_VAR 0 2
11445: ARRAY
11446: DIFF
11447: ST_TO_ADDR
// if not tmp then
11448: LD_VAR 0 4
11452: NOT
11453: IFFALSE 11457
// continue ;
11455: GO 11302
// for j in tmp do
11457: LD_ADDR_VAR 0 3
11461: PUSH
11462: LD_VAR 0 4
11466: PUSH
11467: FOR_IN
11468: IFFALSE 11619
// begin if not mc_builders [ i ] then
11470: LD_EXP 62
11474: PUSH
11475: LD_VAR 0 2
11479: ARRAY
11480: NOT
11481: IFFALSE 11539
// begin SetTag ( j , 103 ) ;
11483: LD_VAR 0 3
11487: PPUSH
11488: LD_INT 103
11490: PPUSH
11491: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
11495: LD_ADDR_EXP 62
11499: PUSH
11500: LD_EXP 62
11504: PPUSH
11505: LD_VAR 0 2
11509: PUSH
11510: LD_EXP 62
11514: PUSH
11515: LD_VAR 0 2
11519: ARRAY
11520: PUSH
11521: LD_INT 1
11523: PLUS
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PPUSH
11529: LD_VAR 0 3
11533: PPUSH
11534: CALL 37144 0 3
11538: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
11539: LD_VAR 0 3
11543: PPUSH
11544: CALL_OW 310
11548: IFFALSE 11559
// ComExitBuilding ( j ) ;
11550: LD_VAR 0 3
11554: PPUSH
11555: CALL_OW 122
// wait ( 3 ) ;
11559: LD_INT 3
11561: PPUSH
11562: CALL_OW 67
// if not mc_construct_list [ i ] then
11566: LD_EXP 63
11570: PUSH
11571: LD_VAR 0 2
11575: ARRAY
11576: NOT
11577: IFFALSE 11581
// break ;
11579: GO 11619
// if not HasTask ( j ) then
11581: LD_VAR 0 3
11585: PPUSH
11586: CALL_OW 314
11590: NOT
11591: IFFALSE 11617
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
11593: LD_VAR 0 3
11597: PPUSH
11598: LD_EXP 63
11602: PUSH
11603: LD_VAR 0 2
11607: ARRAY
11608: PUSH
11609: LD_INT 1
11611: ARRAY
11612: PPUSH
11613: CALL 39995 0 2
// end ;
11617: GO 11467
11619: POP
11620: POP
// end else
11621: GO 12426
// if mc_build_list [ i ] then
11623: LD_EXP 61
11627: PUSH
11628: LD_VAR 0 2
11632: ARRAY
11633: IFFALSE 12426
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
11635: LD_ADDR_VAR 0 5
11639: PUSH
11640: LD_EXP 56
11644: PUSH
11645: LD_VAR 0 2
11649: ARRAY
11650: PPUSH
11651: LD_INT 2
11653: PUSH
11654: LD_INT 30
11656: PUSH
11657: LD_INT 0
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 30
11666: PUSH
11667: LD_INT 1
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: LIST
11678: PPUSH
11679: CALL_OW 72
11683: ST_TO_ADDR
// if depot then
11684: LD_VAR 0 5
11688: IFFALSE 11706
// depot := depot [ 1 ] else
11690: LD_ADDR_VAR 0 5
11694: PUSH
11695: LD_VAR 0 5
11699: PUSH
11700: LD_INT 1
11702: ARRAY
11703: ST_TO_ADDR
11704: GO 11714
// depot := 0 ;
11706: LD_ADDR_VAR 0 5
11710: PUSH
11711: LD_INT 0
11713: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
11714: LD_EXP 61
11718: PUSH
11719: LD_VAR 0 2
11723: ARRAY
11724: PUSH
11725: LD_INT 1
11727: ARRAY
11728: PUSH
11729: LD_INT 1
11731: ARRAY
11732: PPUSH
11733: CALL 39825 0 1
11737: PUSH
11738: LD_EXP 56
11742: PUSH
11743: LD_VAR 0 2
11747: ARRAY
11748: PPUSH
11749: LD_INT 2
11751: PUSH
11752: LD_INT 30
11754: PUSH
11755: LD_INT 2
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 30
11764: PUSH
11765: LD_INT 3
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: PPUSH
11777: CALL_OW 72
11781: NOT
11782: AND
11783: IFFALSE 11888
// begin for j = 1 to mc_build_list [ i ] do
11785: LD_ADDR_VAR 0 3
11789: PUSH
11790: DOUBLE
11791: LD_INT 1
11793: DEC
11794: ST_TO_ADDR
11795: LD_EXP 61
11799: PUSH
11800: LD_VAR 0 2
11804: ARRAY
11805: PUSH
11806: FOR_TO
11807: IFFALSE 11886
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
11809: LD_EXP 61
11813: PUSH
11814: LD_VAR 0 2
11818: ARRAY
11819: PUSH
11820: LD_VAR 0 3
11824: ARRAY
11825: PUSH
11826: LD_INT 1
11828: ARRAY
11829: PUSH
11830: LD_INT 2
11832: EQUAL
11833: IFFALSE 11884
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
11835: LD_ADDR_EXP 61
11839: PUSH
11840: LD_EXP 61
11844: PPUSH
11845: LD_VAR 0 2
11849: PPUSH
11850: LD_EXP 61
11854: PUSH
11855: LD_VAR 0 2
11859: ARRAY
11860: PPUSH
11861: LD_VAR 0 3
11865: PPUSH
11866: LD_INT 1
11868: PPUSH
11869: LD_INT 0
11871: PPUSH
11872: CALL 36562 0 4
11876: PPUSH
11877: CALL_OW 1
11881: ST_TO_ADDR
// break ;
11882: GO 11886
// end ;
11884: GO 11806
11886: POP
11887: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
11888: LD_EXP 61
11892: PUSH
11893: LD_VAR 0 2
11897: ARRAY
11898: PUSH
11899: LD_INT 1
11901: ARRAY
11902: PUSH
11903: LD_INT 1
11905: ARRAY
11906: PUSH
11907: LD_INT 0
11909: EQUAL
11910: PUSH
11911: LD_VAR 0 5
11915: PUSH
11916: LD_VAR 0 5
11920: PPUSH
11921: LD_EXP 61
11925: PUSH
11926: LD_VAR 0 2
11930: ARRAY
11931: PUSH
11932: LD_INT 1
11934: ARRAY
11935: PUSH
11936: LD_INT 1
11938: ARRAY
11939: PPUSH
11940: LD_EXP 61
11944: PUSH
11945: LD_VAR 0 2
11949: ARRAY
11950: PUSH
11951: LD_INT 1
11953: ARRAY
11954: PUSH
11955: LD_INT 2
11957: ARRAY
11958: PPUSH
11959: LD_EXP 61
11963: PUSH
11964: LD_VAR 0 2
11968: ARRAY
11969: PUSH
11970: LD_INT 1
11972: ARRAY
11973: PUSH
11974: LD_INT 3
11976: ARRAY
11977: PPUSH
11978: LD_EXP 61
11982: PUSH
11983: LD_VAR 0 2
11987: ARRAY
11988: PUSH
11989: LD_INT 1
11991: ARRAY
11992: PUSH
11993: LD_INT 4
11995: ARRAY
11996: PPUSH
11997: CALL 44541 0 5
12001: AND
12002: OR
12003: IFFALSE 12284
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
12005: LD_ADDR_VAR 0 4
12009: PUSH
12010: LD_EXP 56
12014: PUSH
12015: LD_VAR 0 2
12019: ARRAY
12020: PPUSH
12021: LD_INT 25
12023: PUSH
12024: LD_INT 2
12026: PUSH
12027: EMPTY
12028: LIST
12029: LIST
12030: PPUSH
12031: CALL_OW 72
12035: PUSH
12036: LD_EXP 58
12040: PUSH
12041: LD_VAR 0 2
12045: ARRAY
12046: DIFF
12047: ST_TO_ADDR
// if not tmp then
12048: LD_VAR 0 4
12052: NOT
12053: IFFALSE 12057
// continue ;
12055: GO 11302
// for j in tmp do
12057: LD_ADDR_VAR 0 3
12061: PUSH
12062: LD_VAR 0 4
12066: PUSH
12067: FOR_IN
12068: IFFALSE 12280
// begin if not mc_builders [ i ] then
12070: LD_EXP 62
12074: PUSH
12075: LD_VAR 0 2
12079: ARRAY
12080: NOT
12081: IFFALSE 12139
// begin SetTag ( j , 103 ) ;
12083: LD_VAR 0 3
12087: PPUSH
12088: LD_INT 103
12090: PPUSH
12091: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
12095: LD_ADDR_EXP 62
12099: PUSH
12100: LD_EXP 62
12104: PPUSH
12105: LD_VAR 0 2
12109: PUSH
12110: LD_EXP 62
12114: PUSH
12115: LD_VAR 0 2
12119: ARRAY
12120: PUSH
12121: LD_INT 1
12123: PLUS
12124: PUSH
12125: EMPTY
12126: LIST
12127: LIST
12128: PPUSH
12129: LD_VAR 0 3
12133: PPUSH
12134: CALL 37144 0 3
12138: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
12139: LD_VAR 0 3
12143: PPUSH
12144: CALL_OW 310
12148: IFFALSE 12159
// ComExitBuilding ( j ) ;
12150: LD_VAR 0 3
12154: PPUSH
12155: CALL_OW 122
// wait ( 3 ) ;
12159: LD_INT 3
12161: PPUSH
12162: CALL_OW 67
// if not mc_build_list [ i ] then
12166: LD_EXP 61
12170: PUSH
12171: LD_VAR 0 2
12175: ARRAY
12176: NOT
12177: IFFALSE 12181
// break ;
12179: GO 12280
// if not HasTask ( j ) then
12181: LD_VAR 0 3
12185: PPUSH
12186: CALL_OW 314
12190: NOT
12191: IFFALSE 12278
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
12193: LD_VAR 0 3
12197: PPUSH
12198: LD_EXP 61
12202: PUSH
12203: LD_VAR 0 2
12207: ARRAY
12208: PUSH
12209: LD_INT 1
12211: ARRAY
12212: PUSH
12213: LD_INT 1
12215: ARRAY
12216: PPUSH
12217: LD_EXP 61
12221: PUSH
12222: LD_VAR 0 2
12226: ARRAY
12227: PUSH
12228: LD_INT 1
12230: ARRAY
12231: PUSH
12232: LD_INT 2
12234: ARRAY
12235: PPUSH
12236: LD_EXP 61
12240: PUSH
12241: LD_VAR 0 2
12245: ARRAY
12246: PUSH
12247: LD_INT 1
12249: ARRAY
12250: PUSH
12251: LD_INT 3
12253: ARRAY
12254: PPUSH
12255: LD_EXP 61
12259: PUSH
12260: LD_VAR 0 2
12264: ARRAY
12265: PUSH
12266: LD_INT 1
12268: ARRAY
12269: PUSH
12270: LD_INT 4
12272: ARRAY
12273: PPUSH
12274: CALL_OW 145
// end ;
12278: GO 12067
12280: POP
12281: POP
// end else
12282: GO 12426
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
12284: LD_EXP 56
12288: PUSH
12289: LD_VAR 0 2
12293: ARRAY
12294: PPUSH
12295: LD_EXP 61
12299: PUSH
12300: LD_VAR 0 2
12304: ARRAY
12305: PUSH
12306: LD_INT 1
12308: ARRAY
12309: PUSH
12310: LD_INT 1
12312: ARRAY
12313: PPUSH
12314: LD_EXP 61
12318: PUSH
12319: LD_VAR 0 2
12323: ARRAY
12324: PUSH
12325: LD_INT 1
12327: ARRAY
12328: PUSH
12329: LD_INT 2
12331: ARRAY
12332: PPUSH
12333: LD_EXP 61
12337: PUSH
12338: LD_VAR 0 2
12342: ARRAY
12343: PUSH
12344: LD_INT 1
12346: ARRAY
12347: PUSH
12348: LD_INT 3
12350: ARRAY
12351: PPUSH
12352: LD_EXP 61
12356: PUSH
12357: LD_VAR 0 2
12361: ARRAY
12362: PUSH
12363: LD_INT 1
12365: ARRAY
12366: PUSH
12367: LD_INT 4
12369: ARRAY
12370: PPUSH
12371: CALL 43895 0 5
12375: NOT
12376: IFFALSE 12426
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
12378: LD_ADDR_EXP 61
12382: PUSH
12383: LD_EXP 61
12387: PPUSH
12388: LD_VAR 0 2
12392: PPUSH
12393: LD_EXP 61
12397: PUSH
12398: LD_VAR 0 2
12402: ARRAY
12403: PPUSH
12404: LD_INT 1
12406: PPUSH
12407: LD_INT 1
12409: NEG
12410: PPUSH
12411: LD_INT 0
12413: PPUSH
12414: CALL 36562 0 4
12418: PPUSH
12419: CALL_OW 1
12423: ST_TO_ADDR
// continue ;
12424: GO 11302
// end ; end ; end ;
12426: GO 11302
12428: POP
12429: POP
// end ;
12430: LD_VAR 0 1
12434: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
12435: LD_INT 0
12437: PPUSH
12438: PPUSH
12439: PPUSH
12440: PPUSH
12441: PPUSH
12442: PPUSH
// if not mc_bases then
12443: LD_EXP 56
12447: NOT
12448: IFFALSE 12452
// exit ;
12450: GO 12879
// for i = 1 to mc_bases do
12452: LD_ADDR_VAR 0 2
12456: PUSH
12457: DOUBLE
12458: LD_INT 1
12460: DEC
12461: ST_TO_ADDR
12462: LD_EXP 56
12466: PUSH
12467: FOR_TO
12468: IFFALSE 12877
// begin tmp := mc_build_upgrade [ i ] ;
12470: LD_ADDR_VAR 0 4
12474: PUSH
12475: LD_EXP 88
12479: PUSH
12480: LD_VAR 0 2
12484: ARRAY
12485: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
12486: LD_ADDR_VAR 0 6
12490: PUSH
12491: LD_EXP 89
12495: PUSH
12496: LD_VAR 0 2
12500: ARRAY
12501: PPUSH
12502: LD_INT 2
12504: PUSH
12505: LD_INT 30
12507: PUSH
12508: LD_INT 6
12510: PUSH
12511: EMPTY
12512: LIST
12513: LIST
12514: PUSH
12515: LD_INT 30
12517: PUSH
12518: LD_INT 7
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: LIST
12529: PPUSH
12530: CALL_OW 72
12534: ST_TO_ADDR
// if not tmp and not lab then
12535: LD_VAR 0 4
12539: NOT
12540: PUSH
12541: LD_VAR 0 6
12545: NOT
12546: AND
12547: IFFALSE 12551
// continue ;
12549: GO 12467
// if tmp then
12551: LD_VAR 0 4
12555: IFFALSE 12675
// for j in tmp do
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: LD_VAR 0 4
12566: PUSH
12567: FOR_IN
12568: IFFALSE 12673
// begin if UpgradeCost ( j ) then
12570: LD_VAR 0 3
12574: PPUSH
12575: CALL 43555 0 1
12579: IFFALSE 12671
// begin ComUpgrade ( j ) ;
12581: LD_VAR 0 3
12585: PPUSH
12586: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
12590: LD_ADDR_EXP 88
12594: PUSH
12595: LD_EXP 88
12599: PPUSH
12600: LD_VAR 0 2
12604: PPUSH
12605: LD_EXP 88
12609: PUSH
12610: LD_VAR 0 2
12614: ARRAY
12615: PUSH
12616: LD_VAR 0 3
12620: DIFF
12621: PPUSH
12622: CALL_OW 1
12626: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
12627: LD_ADDR_EXP 63
12631: PUSH
12632: LD_EXP 63
12636: PPUSH
12637: LD_VAR 0 2
12641: PUSH
12642: LD_EXP 63
12646: PUSH
12647: LD_VAR 0 2
12651: ARRAY
12652: PUSH
12653: LD_INT 1
12655: PLUS
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PPUSH
12661: LD_VAR 0 3
12665: PPUSH
12666: CALL 37144 0 3
12670: ST_TO_ADDR
// end ; end ;
12671: GO 12567
12673: POP
12674: POP
// if not lab or not mc_lab_upgrade [ i ] then
12675: LD_VAR 0 6
12679: NOT
12680: PUSH
12681: LD_EXP 90
12685: PUSH
12686: LD_VAR 0 2
12690: ARRAY
12691: NOT
12692: OR
12693: IFFALSE 12697
// continue ;
12695: GO 12467
// for j in lab do
12697: LD_ADDR_VAR 0 3
12701: PUSH
12702: LD_VAR 0 6
12706: PUSH
12707: FOR_IN
12708: IFFALSE 12873
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
12710: LD_VAR 0 3
12714: PPUSH
12715: CALL_OW 266
12719: PUSH
12720: LD_INT 6
12722: PUSH
12723: LD_INT 7
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: IN
12730: PUSH
12731: LD_VAR 0 3
12735: PPUSH
12736: CALL_OW 461
12740: PUSH
12741: LD_INT 1
12743: NONEQUAL
12744: AND
12745: IFFALSE 12871
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
12747: LD_VAR 0 3
12751: PPUSH
12752: LD_EXP 90
12756: PUSH
12757: LD_VAR 0 2
12761: ARRAY
12762: PUSH
12763: LD_INT 1
12765: ARRAY
12766: PPUSH
12767: CALL 43760 0 2
12771: IFFALSE 12871
// begin ComCancel ( j ) ;
12773: LD_VAR 0 3
12777: PPUSH
12778: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
12782: LD_VAR 0 3
12786: PPUSH
12787: LD_EXP 90
12791: PUSH
12792: LD_VAR 0 2
12796: ARRAY
12797: PUSH
12798: LD_INT 1
12800: ARRAY
12801: PPUSH
12802: CALL_OW 207
// if not j in mc_construct_list [ i ] then
12806: LD_VAR 0 3
12810: PUSH
12811: LD_EXP 63
12815: PUSH
12816: LD_VAR 0 2
12820: ARRAY
12821: IN
12822: NOT
12823: IFFALSE 12869
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
12825: LD_ADDR_EXP 63
12829: PUSH
12830: LD_EXP 63
12834: PPUSH
12835: LD_VAR 0 2
12839: PUSH
12840: LD_EXP 63
12844: PUSH
12845: LD_VAR 0 2
12849: ARRAY
12850: PUSH
12851: LD_INT 1
12853: PLUS
12854: PUSH
12855: EMPTY
12856: LIST
12857: LIST
12858: PPUSH
12859: LD_VAR 0 3
12863: PPUSH
12864: CALL 37144 0 3
12868: ST_TO_ADDR
// break ;
12869: GO 12873
// end ; end ; end ;
12871: GO 12707
12873: POP
12874: POP
// end ;
12875: GO 12467
12877: POP
12878: POP
// end ;
12879: LD_VAR 0 1
12883: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
12884: LD_INT 0
12886: PPUSH
12887: PPUSH
12888: PPUSH
12889: PPUSH
12890: PPUSH
12891: PPUSH
12892: PPUSH
12893: PPUSH
12894: PPUSH
// if not mc_bases then
12895: LD_EXP 56
12899: NOT
12900: IFFALSE 12904
// exit ;
12902: GO 13309
// for i = 1 to mc_bases do
12904: LD_ADDR_VAR 0 2
12908: PUSH
12909: DOUBLE
12910: LD_INT 1
12912: DEC
12913: ST_TO_ADDR
12914: LD_EXP 56
12918: PUSH
12919: FOR_TO
12920: IFFALSE 13307
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
12922: LD_EXP 64
12926: PUSH
12927: LD_VAR 0 2
12931: ARRAY
12932: NOT
12933: PUSH
12934: LD_EXP 56
12938: PUSH
12939: LD_VAR 0 2
12943: ARRAY
12944: PPUSH
12945: LD_INT 30
12947: PUSH
12948: LD_INT 3
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PPUSH
12955: CALL_OW 72
12959: NOT
12960: OR
12961: IFFALSE 12965
// continue ;
12963: GO 12919
// busy := false ;
12965: LD_ADDR_VAR 0 8
12969: PUSH
12970: LD_INT 0
12972: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
12973: LD_ADDR_VAR 0 4
12977: PUSH
12978: LD_EXP 56
12982: PUSH
12983: LD_VAR 0 2
12987: ARRAY
12988: PPUSH
12989: LD_INT 30
12991: PUSH
12992: LD_INT 3
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PPUSH
12999: CALL_OW 72
13003: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
13004: LD_ADDR_VAR 0 6
13008: PUSH
13009: LD_EXP 64
13013: PUSH
13014: LD_VAR 0 2
13018: ARRAY
13019: PPUSH
13020: LD_INT 2
13022: PUSH
13023: LD_INT 30
13025: PUSH
13026: LD_INT 32
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: LD_INT 30
13035: PUSH
13036: LD_INT 33
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: LIST
13047: PPUSH
13048: CALL_OW 72
13052: ST_TO_ADDR
// if not t then
13053: LD_VAR 0 6
13057: NOT
13058: IFFALSE 13062
// continue ;
13060: GO 12919
// for j in tmp do
13062: LD_ADDR_VAR 0 3
13066: PUSH
13067: LD_VAR 0 4
13071: PUSH
13072: FOR_IN
13073: IFFALSE 13103
// if not BuildingStatus ( j ) = bs_idle then
13075: LD_VAR 0 3
13079: PPUSH
13080: CALL_OW 461
13084: PUSH
13085: LD_INT 2
13087: EQUAL
13088: NOT
13089: IFFALSE 13101
// begin busy := true ;
13091: LD_ADDR_VAR 0 8
13095: PUSH
13096: LD_INT 1
13098: ST_TO_ADDR
// break ;
13099: GO 13103
// end ;
13101: GO 13072
13103: POP
13104: POP
// if busy then
13105: LD_VAR 0 8
13109: IFFALSE 13113
// continue ;
13111: GO 12919
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
13113: LD_ADDR_VAR 0 7
13117: PUSH
13118: LD_VAR 0 6
13122: PPUSH
13123: LD_INT 35
13125: PUSH
13126: LD_INT 0
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: PPUSH
13133: CALL_OW 72
13137: ST_TO_ADDR
// if tw then
13138: LD_VAR 0 7
13142: IFFALSE 13219
// begin tw := tw [ 1 ] ;
13144: LD_ADDR_VAR 0 7
13148: PUSH
13149: LD_VAR 0 7
13153: PUSH
13154: LD_INT 1
13156: ARRAY
13157: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
13158: LD_ADDR_VAR 0 9
13162: PUSH
13163: LD_VAR 0 7
13167: PPUSH
13168: LD_EXP 81
13172: PUSH
13173: LD_VAR 0 2
13177: ARRAY
13178: PPUSH
13179: CALL 42114 0 2
13183: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
13184: LD_EXP 95
13188: PUSH
13189: LD_VAR 0 2
13193: ARRAY
13194: IFFALSE 13217
// if not weapon in mc_allowed_tower_weapons [ i ] then
13196: LD_VAR 0 9
13200: PUSH
13201: LD_EXP 95
13205: PUSH
13206: LD_VAR 0 2
13210: ARRAY
13211: IN
13212: NOT
13213: IFFALSE 13217
// continue ;
13215: GO 12919
// end else
13217: GO 13282
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
13219: LD_ADDR_VAR 0 5
13223: PUSH
13224: LD_EXP 64
13228: PUSH
13229: LD_VAR 0 2
13233: ARRAY
13234: PPUSH
13235: LD_VAR 0 4
13239: PPUSH
13240: CALL 72253 0 2
13244: ST_TO_ADDR
// if not tmp2 then
13245: LD_VAR 0 5
13249: NOT
13250: IFFALSE 13254
// continue ;
13252: GO 12919
// tw := tmp2 [ 1 ] ;
13254: LD_ADDR_VAR 0 7
13258: PUSH
13259: LD_VAR 0 5
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
13268: LD_ADDR_VAR 0 9
13272: PUSH
13273: LD_VAR 0 5
13277: PUSH
13278: LD_INT 2
13280: ARRAY
13281: ST_TO_ADDR
// end ; if not weapon then
13282: LD_VAR 0 9
13286: NOT
13287: IFFALSE 13291
// continue ;
13289: GO 12919
// ComPlaceWeapon ( tw , weapon ) ;
13291: LD_VAR 0 7
13295: PPUSH
13296: LD_VAR 0 9
13300: PPUSH
13301: CALL_OW 148
// end ;
13305: GO 12919
13307: POP
13308: POP
// end ;
13309: LD_VAR 0 1
13313: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
13314: LD_INT 0
13316: PPUSH
13317: PPUSH
13318: PPUSH
13319: PPUSH
13320: PPUSH
13321: PPUSH
// if not mc_bases then
13322: LD_EXP 56
13326: NOT
13327: IFFALSE 13331
// exit ;
13329: GO 14343
// for i = 1 to mc_bases do
13331: LD_ADDR_VAR 0 2
13335: PUSH
13336: DOUBLE
13337: LD_INT 1
13339: DEC
13340: ST_TO_ADDR
13341: LD_EXP 56
13345: PUSH
13346: FOR_TO
13347: IFFALSE 14341
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
13349: LD_EXP 69
13353: PUSH
13354: LD_VAR 0 2
13358: ARRAY
13359: NOT
13360: PUSH
13361: LD_EXP 69
13365: PUSH
13366: LD_VAR 0 2
13370: ARRAY
13371: PUSH
13372: LD_EXP 70
13376: PUSH
13377: LD_VAR 0 2
13381: ARRAY
13382: EQUAL
13383: OR
13384: IFFALSE 13388
// continue ;
13386: GO 13346
// if mc_miners [ i ] then
13388: LD_EXP 70
13392: PUSH
13393: LD_VAR 0 2
13397: ARRAY
13398: IFFALSE 14028
// begin k := 1 ;
13400: LD_ADDR_VAR 0 4
13404: PUSH
13405: LD_INT 1
13407: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
13408: LD_ADDR_VAR 0 3
13412: PUSH
13413: DOUBLE
13414: LD_EXP 70
13418: PUSH
13419: LD_VAR 0 2
13423: ARRAY
13424: INC
13425: ST_TO_ADDR
13426: LD_INT 1
13428: PUSH
13429: FOR_DOWNTO
13430: IFFALSE 14026
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
13432: LD_EXP 70
13436: PUSH
13437: LD_VAR 0 2
13441: ARRAY
13442: PUSH
13443: LD_VAR 0 3
13447: ARRAY
13448: PPUSH
13449: CALL_OW 301
13453: PUSH
13454: LD_EXP 70
13458: PUSH
13459: LD_VAR 0 2
13463: ARRAY
13464: PUSH
13465: LD_VAR 0 3
13469: ARRAY
13470: PPUSH
13471: CALL_OW 257
13475: PUSH
13476: LD_INT 1
13478: NONEQUAL
13479: OR
13480: IFFALSE 13543
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
13482: LD_ADDR_VAR 0 5
13486: PUSH
13487: LD_EXP 70
13491: PUSH
13492: LD_VAR 0 2
13496: ARRAY
13497: PUSH
13498: LD_EXP 70
13502: PUSH
13503: LD_VAR 0 2
13507: ARRAY
13508: PUSH
13509: LD_VAR 0 3
13513: ARRAY
13514: DIFF
13515: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
13516: LD_ADDR_EXP 70
13520: PUSH
13521: LD_EXP 70
13525: PPUSH
13526: LD_VAR 0 2
13530: PPUSH
13531: LD_VAR 0 5
13535: PPUSH
13536: CALL_OW 1
13540: ST_TO_ADDR
// continue ;
13541: GO 13429
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
13543: LD_EXP 70
13547: PUSH
13548: LD_VAR 0 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 3
13558: ARRAY
13559: PPUSH
13560: CALL 37080 0 1
13564: PUSH
13565: LD_EXP 70
13569: PUSH
13570: LD_VAR 0 2
13574: ARRAY
13575: PUSH
13576: LD_VAR 0 3
13580: ARRAY
13581: PPUSH
13582: CALL_OW 255
13586: PPUSH
13587: LD_EXP 69
13591: PUSH
13592: LD_VAR 0 2
13596: ARRAY
13597: PUSH
13598: LD_VAR 0 4
13602: ARRAY
13603: PUSH
13604: LD_INT 1
13606: ARRAY
13607: PPUSH
13608: LD_EXP 69
13612: PUSH
13613: LD_VAR 0 2
13617: ARRAY
13618: PUSH
13619: LD_VAR 0 4
13623: ARRAY
13624: PUSH
13625: LD_INT 2
13627: ARRAY
13628: PPUSH
13629: LD_INT 15
13631: PPUSH
13632: CALL 38040 0 4
13636: PUSH
13637: LD_INT 4
13639: ARRAY
13640: PUSH
13641: LD_EXP 70
13645: PUSH
13646: LD_VAR 0 2
13650: ARRAY
13651: PUSH
13652: LD_VAR 0 3
13656: ARRAY
13657: PPUSH
13658: LD_INT 10
13660: PPUSH
13661: CALL 39737 0 2
13665: PUSH
13666: LD_INT 4
13668: ARRAY
13669: OR
13670: AND
13671: IFFALSE 13694
// ComStop ( mc_miners [ i ] [ j ] ) ;
13673: LD_EXP 70
13677: PUSH
13678: LD_VAR 0 2
13682: ARRAY
13683: PUSH
13684: LD_VAR 0 3
13688: ARRAY
13689: PPUSH
13690: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
13694: LD_EXP 70
13698: PUSH
13699: LD_VAR 0 2
13703: ARRAY
13704: PUSH
13705: LD_VAR 0 3
13709: ARRAY
13710: PPUSH
13711: CALL_OW 257
13715: PUSH
13716: LD_INT 1
13718: EQUAL
13719: PUSH
13720: LD_EXP 70
13724: PUSH
13725: LD_VAR 0 2
13729: ARRAY
13730: PUSH
13731: LD_VAR 0 3
13735: ARRAY
13736: PPUSH
13737: CALL_OW 459
13741: NOT
13742: AND
13743: PUSH
13744: LD_EXP 70
13748: PUSH
13749: LD_VAR 0 2
13753: ARRAY
13754: PUSH
13755: LD_VAR 0 3
13759: ARRAY
13760: PPUSH
13761: CALL_OW 255
13765: PPUSH
13766: LD_EXP 69
13770: PUSH
13771: LD_VAR 0 2
13775: ARRAY
13776: PUSH
13777: LD_VAR 0 4
13781: ARRAY
13782: PUSH
13783: LD_INT 1
13785: ARRAY
13786: PPUSH
13787: LD_EXP 69
13791: PUSH
13792: LD_VAR 0 2
13796: ARRAY
13797: PUSH
13798: LD_VAR 0 4
13802: ARRAY
13803: PUSH
13804: LD_INT 2
13806: ARRAY
13807: PPUSH
13808: LD_INT 15
13810: PPUSH
13811: CALL 38040 0 4
13815: PUSH
13816: LD_INT 4
13818: ARRAY
13819: PUSH
13820: LD_INT 0
13822: EQUAL
13823: AND
13824: PUSH
13825: LD_EXP 70
13829: PUSH
13830: LD_VAR 0 2
13834: ARRAY
13835: PUSH
13836: LD_VAR 0 3
13840: ARRAY
13841: PPUSH
13842: CALL_OW 314
13846: NOT
13847: AND
13848: IFFALSE 14024
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
13850: LD_EXP 70
13854: PUSH
13855: LD_VAR 0 2
13859: ARRAY
13860: PUSH
13861: LD_VAR 0 3
13865: ARRAY
13866: PPUSH
13867: CALL_OW 310
13871: IFFALSE 13894
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
13873: LD_EXP 70
13877: PUSH
13878: LD_VAR 0 2
13882: ARRAY
13883: PUSH
13884: LD_VAR 0 3
13888: ARRAY
13889: PPUSH
13890: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
13894: LD_EXP 70
13898: PUSH
13899: LD_VAR 0 2
13903: ARRAY
13904: PUSH
13905: LD_VAR 0 3
13909: ARRAY
13910: PPUSH
13911: CALL_OW 314
13915: NOT
13916: IFFALSE 13984
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
13918: LD_EXP 70
13922: PUSH
13923: LD_VAR 0 2
13927: ARRAY
13928: PUSH
13929: LD_VAR 0 3
13933: ARRAY
13934: PPUSH
13935: LD_EXP 69
13939: PUSH
13940: LD_VAR 0 2
13944: ARRAY
13945: PUSH
13946: LD_VAR 0 4
13950: ARRAY
13951: PUSH
13952: LD_INT 1
13954: ARRAY
13955: PPUSH
13956: LD_EXP 69
13960: PUSH
13961: LD_VAR 0 2
13965: ARRAY
13966: PUSH
13967: LD_VAR 0 4
13971: ARRAY
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: PPUSH
13977: LD_INT 0
13979: PPUSH
13980: CALL_OW 193
// k := k + 1 ;
13984: LD_ADDR_VAR 0 4
13988: PUSH
13989: LD_VAR 0 4
13993: PUSH
13994: LD_INT 1
13996: PLUS
13997: ST_TO_ADDR
// if k > mc_mines [ i ] then
13998: LD_VAR 0 4
14002: PUSH
14003: LD_EXP 69
14007: PUSH
14008: LD_VAR 0 2
14012: ARRAY
14013: GREATER
14014: IFFALSE 14024
// k := 1 ;
14016: LD_ADDR_VAR 0 4
14020: PUSH
14021: LD_INT 1
14023: ST_TO_ADDR
// end ; end ;
14024: GO 13429
14026: POP
14027: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
14028: LD_ADDR_VAR 0 5
14032: PUSH
14033: LD_EXP 56
14037: PUSH
14038: LD_VAR 0 2
14042: ARRAY
14043: PPUSH
14044: LD_INT 2
14046: PUSH
14047: LD_INT 30
14049: PUSH
14050: LD_INT 4
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: PUSH
14057: LD_INT 30
14059: PUSH
14060: LD_INT 5
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: PUSH
14067: LD_INT 30
14069: PUSH
14070: LD_INT 32
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: PPUSH
14083: CALL_OW 72
14087: ST_TO_ADDR
// if not tmp then
14088: LD_VAR 0 5
14092: NOT
14093: IFFALSE 14097
// continue ;
14095: GO 13346
// list := [ ] ;
14097: LD_ADDR_VAR 0 6
14101: PUSH
14102: EMPTY
14103: ST_TO_ADDR
// for j in tmp do
14104: LD_ADDR_VAR 0 3
14108: PUSH
14109: LD_VAR 0 5
14113: PUSH
14114: FOR_IN
14115: IFFALSE 14184
// begin for k in UnitsInside ( j ) do
14117: LD_ADDR_VAR 0 4
14121: PUSH
14122: LD_VAR 0 3
14126: PPUSH
14127: CALL_OW 313
14131: PUSH
14132: FOR_IN
14133: IFFALSE 14180
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
14135: LD_VAR 0 4
14139: PPUSH
14140: CALL_OW 257
14144: PUSH
14145: LD_INT 1
14147: EQUAL
14148: PUSH
14149: LD_VAR 0 4
14153: PPUSH
14154: CALL_OW 459
14158: NOT
14159: AND
14160: IFFALSE 14178
// list := list ^ k ;
14162: LD_ADDR_VAR 0 6
14166: PUSH
14167: LD_VAR 0 6
14171: PUSH
14172: LD_VAR 0 4
14176: ADD
14177: ST_TO_ADDR
14178: GO 14132
14180: POP
14181: POP
// end ;
14182: GO 14114
14184: POP
14185: POP
// list := list diff mc_miners [ i ] ;
14186: LD_ADDR_VAR 0 6
14190: PUSH
14191: LD_VAR 0 6
14195: PUSH
14196: LD_EXP 70
14200: PUSH
14201: LD_VAR 0 2
14205: ARRAY
14206: DIFF
14207: ST_TO_ADDR
// if not list then
14208: LD_VAR 0 6
14212: NOT
14213: IFFALSE 14217
// continue ;
14215: GO 13346
// k := mc_mines [ i ] - mc_miners [ i ] ;
14217: LD_ADDR_VAR 0 4
14221: PUSH
14222: LD_EXP 69
14226: PUSH
14227: LD_VAR 0 2
14231: ARRAY
14232: PUSH
14233: LD_EXP 70
14237: PUSH
14238: LD_VAR 0 2
14242: ARRAY
14243: MINUS
14244: ST_TO_ADDR
// if k > list then
14245: LD_VAR 0 4
14249: PUSH
14250: LD_VAR 0 6
14254: GREATER
14255: IFFALSE 14267
// k := list ;
14257: LD_ADDR_VAR 0 4
14261: PUSH
14262: LD_VAR 0 6
14266: ST_TO_ADDR
// for j = 1 to k do
14267: LD_ADDR_VAR 0 3
14271: PUSH
14272: DOUBLE
14273: LD_INT 1
14275: DEC
14276: ST_TO_ADDR
14277: LD_VAR 0 4
14281: PUSH
14282: FOR_TO
14283: IFFALSE 14337
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
14285: LD_ADDR_EXP 70
14289: PUSH
14290: LD_EXP 70
14294: PPUSH
14295: LD_VAR 0 2
14299: PUSH
14300: LD_EXP 70
14304: PUSH
14305: LD_VAR 0 2
14309: ARRAY
14310: PUSH
14311: LD_INT 1
14313: PLUS
14314: PUSH
14315: EMPTY
14316: LIST
14317: LIST
14318: PPUSH
14319: LD_VAR 0 6
14323: PUSH
14324: LD_VAR 0 3
14328: ARRAY
14329: PPUSH
14330: CALL 37144 0 3
14334: ST_TO_ADDR
14335: GO 14282
14337: POP
14338: POP
// end ;
14339: GO 13346
14341: POP
14342: POP
// end ;
14343: LD_VAR 0 1
14347: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
14348: LD_INT 0
14350: PPUSH
14351: PPUSH
14352: PPUSH
14353: PPUSH
14354: PPUSH
14355: PPUSH
14356: PPUSH
14357: PPUSH
14358: PPUSH
14359: PPUSH
// if not mc_bases then
14360: LD_EXP 56
14364: NOT
14365: IFFALSE 14369
// exit ;
14367: GO 16100
// for i = 1 to mc_bases do
14369: LD_ADDR_VAR 0 2
14373: PUSH
14374: DOUBLE
14375: LD_INT 1
14377: DEC
14378: ST_TO_ADDR
14379: LD_EXP 56
14383: PUSH
14384: FOR_TO
14385: IFFALSE 16098
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
14387: LD_EXP 56
14391: PUSH
14392: LD_VAR 0 2
14396: ARRAY
14397: NOT
14398: PUSH
14399: LD_EXP 63
14403: PUSH
14404: LD_VAR 0 2
14408: ARRAY
14409: OR
14410: IFFALSE 14414
// continue ;
14412: GO 14384
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
14414: LD_EXP 72
14418: PUSH
14419: LD_VAR 0 2
14423: ARRAY
14424: NOT
14425: PUSH
14426: LD_EXP 73
14430: PUSH
14431: LD_VAR 0 2
14435: ARRAY
14436: AND
14437: IFFALSE 14475
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
14439: LD_ADDR_EXP 73
14443: PUSH
14444: LD_EXP 73
14448: PPUSH
14449: LD_VAR 0 2
14453: PPUSH
14454: EMPTY
14455: PPUSH
14456: CALL_OW 1
14460: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
14461: LD_VAR 0 2
14465: PPUSH
14466: LD_INT 107
14468: PPUSH
14469: CALL 5887 0 2
// continue ;
14473: GO 14384
// end ; target := [ ] ;
14475: LD_ADDR_VAR 0 6
14479: PUSH
14480: EMPTY
14481: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: DOUBLE
14488: LD_EXP 72
14492: PUSH
14493: LD_VAR 0 2
14497: ARRAY
14498: INC
14499: ST_TO_ADDR
14500: LD_INT 1
14502: PUSH
14503: FOR_DOWNTO
14504: IFFALSE 14764
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
14506: LD_EXP 72
14510: PUSH
14511: LD_VAR 0 2
14515: ARRAY
14516: PUSH
14517: LD_VAR 0 3
14521: ARRAY
14522: PUSH
14523: LD_INT 2
14525: ARRAY
14526: PPUSH
14527: LD_EXP 72
14531: PUSH
14532: LD_VAR 0 2
14536: ARRAY
14537: PUSH
14538: LD_VAR 0 3
14542: ARRAY
14543: PUSH
14544: LD_INT 3
14546: ARRAY
14547: PPUSH
14548: CALL_OW 488
14552: PUSH
14553: LD_EXP 72
14557: PUSH
14558: LD_VAR 0 2
14562: ARRAY
14563: PUSH
14564: LD_VAR 0 3
14568: ARRAY
14569: PUSH
14570: LD_INT 2
14572: ARRAY
14573: PPUSH
14574: LD_EXP 72
14578: PUSH
14579: LD_VAR 0 2
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: ARRAY
14590: PUSH
14591: LD_INT 3
14593: ARRAY
14594: PPUSH
14595: CALL_OW 284
14599: PUSH
14600: LD_INT 0
14602: EQUAL
14603: AND
14604: IFFALSE 14659
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
14606: LD_ADDR_VAR 0 5
14610: PUSH
14611: LD_EXP 72
14615: PUSH
14616: LD_VAR 0 2
14620: ARRAY
14621: PPUSH
14622: LD_VAR 0 3
14626: PPUSH
14627: CALL_OW 3
14631: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
14632: LD_ADDR_EXP 72
14636: PUSH
14637: LD_EXP 72
14641: PPUSH
14642: LD_VAR 0 2
14646: PPUSH
14647: LD_VAR 0 5
14651: PPUSH
14652: CALL_OW 1
14656: ST_TO_ADDR
// continue ;
14657: GO 14503
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
14659: LD_EXP 56
14663: PUSH
14664: LD_VAR 0 2
14668: ARRAY
14669: PUSH
14670: LD_INT 1
14672: ARRAY
14673: PPUSH
14674: CALL_OW 255
14678: PPUSH
14679: LD_EXP 72
14683: PUSH
14684: LD_VAR 0 2
14688: ARRAY
14689: PUSH
14690: LD_VAR 0 3
14694: ARRAY
14695: PUSH
14696: LD_INT 2
14698: ARRAY
14699: PPUSH
14700: LD_EXP 72
14704: PUSH
14705: LD_VAR 0 2
14709: ARRAY
14710: PUSH
14711: LD_VAR 0 3
14715: ARRAY
14716: PUSH
14717: LD_INT 3
14719: ARRAY
14720: PPUSH
14721: LD_INT 30
14723: PPUSH
14724: CALL 38040 0 4
14728: PUSH
14729: LD_INT 4
14731: ARRAY
14732: PUSH
14733: LD_INT 0
14735: EQUAL
14736: IFFALSE 14762
// begin target := mc_crates [ i ] [ j ] ;
14738: LD_ADDR_VAR 0 6
14742: PUSH
14743: LD_EXP 72
14747: PUSH
14748: LD_VAR 0 2
14752: ARRAY
14753: PUSH
14754: LD_VAR 0 3
14758: ARRAY
14759: ST_TO_ADDR
// break ;
14760: GO 14764
// end ; end ;
14762: GO 14503
14764: POP
14765: POP
// if not target then
14766: LD_VAR 0 6
14770: NOT
14771: IFFALSE 14775
// continue ;
14773: GO 14384
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
14775: LD_ADDR_VAR 0 7
14779: PUSH
14780: LD_EXP 75
14784: PUSH
14785: LD_VAR 0 2
14789: ARRAY
14790: PPUSH
14791: LD_INT 2
14793: PUSH
14794: LD_INT 3
14796: PUSH
14797: LD_INT 58
14799: PUSH
14800: EMPTY
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PUSH
14807: LD_INT 61
14809: PUSH
14810: EMPTY
14811: LIST
14812: PUSH
14813: LD_INT 33
14815: PUSH
14816: LD_INT 5
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 33
14825: PUSH
14826: LD_INT 3
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: PUSH
14840: LD_INT 2
14842: PUSH
14843: LD_INT 34
14845: PUSH
14846: LD_INT 32
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 34
14855: PUSH
14856: LD_INT 51
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PUSH
14863: LD_INT 34
14865: PUSH
14866: LD_INT 12
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: LIST
14877: LIST
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 72
14887: ST_TO_ADDR
// if not cargo then
14888: LD_VAR 0 7
14892: NOT
14893: IFFALSE 15536
// begin if mc_crates_collector [ i ] < 5 then
14895: LD_EXP 73
14899: PUSH
14900: LD_VAR 0 2
14904: ARRAY
14905: PUSH
14906: LD_INT 5
14908: LESS
14909: IFFALSE 15275
// begin if mc_ape [ i ] then
14911: LD_EXP 85
14915: PUSH
14916: LD_VAR 0 2
14920: ARRAY
14921: IFFALSE 14968
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
14923: LD_ADDR_VAR 0 5
14927: PUSH
14928: LD_EXP 85
14932: PUSH
14933: LD_VAR 0 2
14937: ARRAY
14938: PPUSH
14939: LD_INT 25
14941: PUSH
14942: LD_INT 16
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PUSH
14949: LD_INT 24
14951: PUSH
14952: LD_INT 750
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PPUSH
14963: CALL_OW 72
14967: ST_TO_ADDR
// if not tmp then
14968: LD_VAR 0 5
14972: NOT
14973: IFFALSE 15020
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
14975: LD_ADDR_VAR 0 5
14979: PUSH
14980: LD_EXP 56
14984: PUSH
14985: LD_VAR 0 2
14989: ARRAY
14990: PPUSH
14991: LD_INT 25
14993: PUSH
14994: LD_INT 2
14996: PUSH
14997: EMPTY
14998: LIST
14999: LIST
15000: PUSH
15001: LD_INT 24
15003: PUSH
15004: LD_INT 750
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: PPUSH
15015: CALL_OW 72
15019: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
15020: LD_EXP 85
15024: PUSH
15025: LD_VAR 0 2
15029: ARRAY
15030: PUSH
15031: LD_EXP 56
15035: PUSH
15036: LD_VAR 0 2
15040: ARRAY
15041: PPUSH
15042: LD_INT 25
15044: PUSH
15045: LD_INT 2
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PUSH
15052: LD_INT 24
15054: PUSH
15055: LD_INT 750
15057: PUSH
15058: EMPTY
15059: LIST
15060: LIST
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: PPUSH
15066: CALL_OW 72
15070: AND
15071: PUSH
15072: LD_VAR 0 5
15076: PUSH
15077: LD_INT 5
15079: LESS
15080: AND
15081: IFFALSE 15163
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
15083: LD_ADDR_VAR 0 3
15087: PUSH
15088: LD_EXP 56
15092: PUSH
15093: LD_VAR 0 2
15097: ARRAY
15098: PPUSH
15099: LD_INT 25
15101: PUSH
15102: LD_INT 2
15104: PUSH
15105: EMPTY
15106: LIST
15107: LIST
15108: PUSH
15109: LD_INT 24
15111: PUSH
15112: LD_INT 750
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: PPUSH
15123: CALL_OW 72
15127: PUSH
15128: FOR_IN
15129: IFFALSE 15161
// begin tmp := tmp union j ;
15131: LD_ADDR_VAR 0 5
15135: PUSH
15136: LD_VAR 0 5
15140: PUSH
15141: LD_VAR 0 3
15145: UNION
15146: ST_TO_ADDR
// if tmp >= 5 then
15147: LD_VAR 0 5
15151: PUSH
15152: LD_INT 5
15154: GREATEREQUAL
15155: IFFALSE 15159
// break ;
15157: GO 15161
// end ;
15159: GO 15128
15161: POP
15162: POP
// end ; if not tmp then
15163: LD_VAR 0 5
15167: NOT
15168: IFFALSE 15172
// continue ;
15170: GO 14384
// for j in tmp do
15172: LD_ADDR_VAR 0 3
15176: PUSH
15177: LD_VAR 0 5
15181: PUSH
15182: FOR_IN
15183: IFFALSE 15273
// if not GetTag ( j ) then
15185: LD_VAR 0 3
15189: PPUSH
15190: CALL_OW 110
15194: NOT
15195: IFFALSE 15271
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
15197: LD_ADDR_EXP 73
15201: PUSH
15202: LD_EXP 73
15206: PPUSH
15207: LD_VAR 0 2
15211: PUSH
15212: LD_EXP 73
15216: PUSH
15217: LD_VAR 0 2
15221: ARRAY
15222: PUSH
15223: LD_INT 1
15225: PLUS
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: PPUSH
15231: LD_VAR 0 3
15235: PPUSH
15236: CALL 37144 0 3
15240: ST_TO_ADDR
// SetTag ( j , 107 ) ;
15241: LD_VAR 0 3
15245: PPUSH
15246: LD_INT 107
15248: PPUSH
15249: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
15253: LD_EXP 73
15257: PUSH
15258: LD_VAR 0 2
15262: ARRAY
15263: PUSH
15264: LD_INT 5
15266: GREATEREQUAL
15267: IFFALSE 15271
// break ;
15269: GO 15273
// end ;
15271: GO 15182
15273: POP
15274: POP
// end ; if mc_crates_collector [ i ] and target then
15275: LD_EXP 73
15279: PUSH
15280: LD_VAR 0 2
15284: ARRAY
15285: PUSH
15286: LD_VAR 0 6
15290: AND
15291: IFFALSE 15534
// begin if mc_crates_collector [ i ] < target [ 1 ] then
15293: LD_EXP 73
15297: PUSH
15298: LD_VAR 0 2
15302: ARRAY
15303: PUSH
15304: LD_VAR 0 6
15308: PUSH
15309: LD_INT 1
15311: ARRAY
15312: LESS
15313: IFFALSE 15333
// tmp := mc_crates_collector [ i ] else
15315: LD_ADDR_VAR 0 5
15319: PUSH
15320: LD_EXP 73
15324: PUSH
15325: LD_VAR 0 2
15329: ARRAY
15330: ST_TO_ADDR
15331: GO 15347
// tmp := target [ 1 ] ;
15333: LD_ADDR_VAR 0 5
15337: PUSH
15338: LD_VAR 0 6
15342: PUSH
15343: LD_INT 1
15345: ARRAY
15346: ST_TO_ADDR
// k := 0 ;
15347: LD_ADDR_VAR 0 4
15351: PUSH
15352: LD_INT 0
15354: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
15355: LD_ADDR_VAR 0 3
15359: PUSH
15360: LD_EXP 73
15364: PUSH
15365: LD_VAR 0 2
15369: ARRAY
15370: PUSH
15371: FOR_IN
15372: IFFALSE 15532
// begin k := k + 1 ;
15374: LD_ADDR_VAR 0 4
15378: PUSH
15379: LD_VAR 0 4
15383: PUSH
15384: LD_INT 1
15386: PLUS
15387: ST_TO_ADDR
// if k > tmp then
15388: LD_VAR 0 4
15392: PUSH
15393: LD_VAR 0 5
15397: GREATER
15398: IFFALSE 15402
// break ;
15400: GO 15532
// if not GetClass ( j ) in [ 2 , 16 ] then
15402: LD_VAR 0 3
15406: PPUSH
15407: CALL_OW 257
15411: PUSH
15412: LD_INT 2
15414: PUSH
15415: LD_INT 16
15417: PUSH
15418: EMPTY
15419: LIST
15420: LIST
15421: IN
15422: NOT
15423: IFFALSE 15476
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
15425: LD_ADDR_EXP 73
15429: PUSH
15430: LD_EXP 73
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: LD_EXP 73
15444: PUSH
15445: LD_VAR 0 2
15449: ARRAY
15450: PUSH
15451: LD_VAR 0 3
15455: DIFF
15456: PPUSH
15457: CALL_OW 1
15461: ST_TO_ADDR
// SetTag ( j , 0 ) ;
15462: LD_VAR 0 3
15466: PPUSH
15467: LD_INT 0
15469: PPUSH
15470: CALL_OW 109
// continue ;
15474: GO 15371
// end ; if IsInUnit ( j ) then
15476: LD_VAR 0 3
15480: PPUSH
15481: CALL_OW 310
15485: IFFALSE 15496
// ComExitBuilding ( j ) ;
15487: LD_VAR 0 3
15491: PPUSH
15492: CALL_OW 122
// wait ( 3 ) ;
15496: LD_INT 3
15498: PPUSH
15499: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
15503: LD_VAR 0 3
15507: PPUSH
15508: LD_VAR 0 6
15512: PUSH
15513: LD_INT 2
15515: ARRAY
15516: PPUSH
15517: LD_VAR 0 6
15521: PUSH
15522: LD_INT 3
15524: ARRAY
15525: PPUSH
15526: CALL_OW 117
// end ;
15530: GO 15371
15532: POP
15533: POP
// end ; end else
15534: GO 16096
// begin for j in cargo do
15536: LD_ADDR_VAR 0 3
15540: PUSH
15541: LD_VAR 0 7
15545: PUSH
15546: FOR_IN
15547: IFFALSE 16094
// begin if GetTag ( j ) <> 0 then
15549: LD_VAR 0 3
15553: PPUSH
15554: CALL_OW 110
15558: PUSH
15559: LD_INT 0
15561: NONEQUAL
15562: IFFALSE 15566
// continue ;
15564: GO 15546
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
15566: LD_VAR 0 3
15570: PPUSH
15571: CALL_OW 256
15575: PUSH
15576: LD_INT 1000
15578: LESS
15579: PUSH
15580: LD_VAR 0 3
15584: PPUSH
15585: LD_EXP 80
15589: PUSH
15590: LD_VAR 0 2
15594: ARRAY
15595: PPUSH
15596: CALL_OW 308
15600: NOT
15601: AND
15602: IFFALSE 15624
// ComMoveToArea ( j , mc_parking [ i ] ) ;
15604: LD_VAR 0 3
15608: PPUSH
15609: LD_EXP 80
15613: PUSH
15614: LD_VAR 0 2
15618: ARRAY
15619: PPUSH
15620: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
15624: LD_VAR 0 3
15628: PPUSH
15629: CALL_OW 256
15633: PUSH
15634: LD_INT 1000
15636: LESS
15637: PUSH
15638: LD_VAR 0 3
15642: PPUSH
15643: LD_EXP 80
15647: PUSH
15648: LD_VAR 0 2
15652: ARRAY
15653: PPUSH
15654: CALL_OW 308
15658: AND
15659: IFFALSE 15663
// continue ;
15661: GO 15546
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
15663: LD_VAR 0 3
15667: PPUSH
15668: CALL_OW 262
15672: PUSH
15673: LD_INT 2
15675: EQUAL
15676: PUSH
15677: LD_VAR 0 3
15681: PPUSH
15682: CALL_OW 261
15686: PUSH
15687: LD_INT 15
15689: LESS
15690: AND
15691: IFFALSE 15695
// continue ;
15693: GO 15546
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
15695: LD_VAR 0 3
15699: PPUSH
15700: CALL_OW 262
15704: PUSH
15705: LD_INT 1
15707: EQUAL
15708: PUSH
15709: LD_VAR 0 3
15713: PPUSH
15714: CALL_OW 261
15718: PUSH
15719: LD_INT 10
15721: LESS
15722: AND
15723: IFFALSE 16033
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
15725: LD_ADDR_VAR 0 8
15729: PUSH
15730: LD_EXP 56
15734: PUSH
15735: LD_VAR 0 2
15739: ARRAY
15740: PPUSH
15741: LD_INT 2
15743: PUSH
15744: LD_INT 30
15746: PUSH
15747: LD_INT 0
15749: PUSH
15750: EMPTY
15751: LIST
15752: LIST
15753: PUSH
15754: LD_INT 30
15756: PUSH
15757: LD_INT 1
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: PPUSH
15769: CALL_OW 72
15773: ST_TO_ADDR
// if not depot then
15774: LD_VAR 0 8
15778: NOT
15779: IFFALSE 15783
// continue ;
15781: GO 15546
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
15783: LD_VAR 0 3
15787: PPUSH
15788: LD_VAR 0 8
15792: PPUSH
15793: LD_VAR 0 3
15797: PPUSH
15798: CALL_OW 74
15802: PPUSH
15803: CALL_OW 296
15807: PUSH
15808: LD_INT 6
15810: LESS
15811: IFFALSE 15827
// SetFuel ( j , 100 ) else
15813: LD_VAR 0 3
15817: PPUSH
15818: LD_INT 100
15820: PPUSH
15821: CALL_OW 240
15825: GO 16033
// if GetFuel ( j ) = 0 then
15827: LD_VAR 0 3
15831: PPUSH
15832: CALL_OW 261
15836: PUSH
15837: LD_INT 0
15839: EQUAL
15840: IFFALSE 16033
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
15842: LD_ADDR_EXP 75
15846: PUSH
15847: LD_EXP 75
15851: PPUSH
15852: LD_VAR 0 2
15856: PPUSH
15857: LD_EXP 75
15861: PUSH
15862: LD_VAR 0 2
15866: ARRAY
15867: PUSH
15868: LD_VAR 0 3
15872: DIFF
15873: PPUSH
15874: CALL_OW 1
15878: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
15879: LD_VAR 0 3
15883: PPUSH
15884: CALL_OW 263
15888: PUSH
15889: LD_INT 1
15891: EQUAL
15892: IFFALSE 15908
// ComExitVehicle ( IsInUnit ( j ) ) ;
15894: LD_VAR 0 3
15898: PPUSH
15899: CALL_OW 310
15903: PPUSH
15904: CALL_OW 121
// if GetControl ( j ) = control_remote then
15908: LD_VAR 0 3
15912: PPUSH
15913: CALL_OW 263
15917: PUSH
15918: LD_INT 2
15920: EQUAL
15921: IFFALSE 15932
// ComUnlink ( j ) ;
15923: LD_VAR 0 3
15927: PPUSH
15928: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
15932: LD_ADDR_VAR 0 9
15936: PUSH
15937: LD_VAR 0 2
15941: PPUSH
15942: LD_INT 3
15944: PPUSH
15945: CALL 25195 0 2
15949: ST_TO_ADDR
// if fac then
15950: LD_VAR 0 9
15954: IFFALSE 16031
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
15956: LD_ADDR_VAR 0 10
15960: PUSH
15961: LD_VAR 0 9
15965: PPUSH
15966: LD_VAR 0 3
15970: PPUSH
15971: CALL_OW 265
15975: PPUSH
15976: LD_VAR 0 3
15980: PPUSH
15981: CALL_OW 262
15985: PPUSH
15986: LD_VAR 0 3
15990: PPUSH
15991: CALL_OW 263
15995: PPUSH
15996: LD_VAR 0 3
16000: PPUSH
16001: CALL_OW 264
16005: PPUSH
16006: CALL 34744 0 5
16010: ST_TO_ADDR
// if components then
16011: LD_VAR 0 10
16015: IFFALSE 16031
// MC_InsertProduceList ( i , components ) ;
16017: LD_VAR 0 2
16021: PPUSH
16022: LD_VAR 0 10
16026: PPUSH
16027: CALL 24765 0 2
// end ; continue ;
16031: GO 15546
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
16033: LD_VAR 0 3
16037: PPUSH
16038: LD_INT 1
16040: PPUSH
16041: CALL_OW 289
16045: PUSH
16046: LD_INT 100
16048: LESS
16049: PUSH
16050: LD_VAR 0 3
16054: PPUSH
16055: CALL_OW 314
16059: NOT
16060: AND
16061: IFFALSE 16090
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
16063: LD_VAR 0 3
16067: PPUSH
16068: LD_VAR 0 6
16072: PUSH
16073: LD_INT 2
16075: ARRAY
16076: PPUSH
16077: LD_VAR 0 6
16081: PUSH
16082: LD_INT 3
16084: ARRAY
16085: PPUSH
16086: CALL_OW 117
// break ;
16090: GO 16094
// end ;
16092: GO 15546
16094: POP
16095: POP
// end ; end ;
16096: GO 14384
16098: POP
16099: POP
// end ;
16100: LD_VAR 0 1
16104: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
16105: LD_INT 0
16107: PPUSH
16108: PPUSH
16109: PPUSH
16110: PPUSH
// if not mc_bases then
16111: LD_EXP 56
16115: NOT
16116: IFFALSE 16120
// exit ;
16118: GO 16281
// for i = 1 to mc_bases do
16120: LD_ADDR_VAR 0 2
16124: PUSH
16125: DOUBLE
16126: LD_INT 1
16128: DEC
16129: ST_TO_ADDR
16130: LD_EXP 56
16134: PUSH
16135: FOR_TO
16136: IFFALSE 16279
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
16138: LD_ADDR_VAR 0 4
16142: PUSH
16143: LD_EXP 75
16147: PUSH
16148: LD_VAR 0 2
16152: ARRAY
16153: PUSH
16154: LD_EXP 78
16158: PUSH
16159: LD_VAR 0 2
16163: ARRAY
16164: UNION
16165: PPUSH
16166: LD_INT 33
16168: PUSH
16169: LD_INT 2
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PPUSH
16176: CALL_OW 72
16180: ST_TO_ADDR
// if tmp then
16181: LD_VAR 0 4
16185: IFFALSE 16277
// for j in tmp do
16187: LD_ADDR_VAR 0 3
16191: PUSH
16192: LD_VAR 0 4
16196: PUSH
16197: FOR_IN
16198: IFFALSE 16275
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
16200: LD_VAR 0 3
16204: PPUSH
16205: CALL_OW 312
16209: NOT
16210: PUSH
16211: LD_VAR 0 3
16215: PPUSH
16216: CALL_OW 256
16220: PUSH
16221: LD_INT 250
16223: GREATEREQUAL
16224: AND
16225: IFFALSE 16238
// Connect ( j ) else
16227: LD_VAR 0 3
16231: PPUSH
16232: CALL 40077 0 1
16236: GO 16273
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
16238: LD_VAR 0 3
16242: PPUSH
16243: CALL_OW 256
16247: PUSH
16248: LD_INT 250
16250: LESS
16251: PUSH
16252: LD_VAR 0 3
16256: PPUSH
16257: CALL_OW 312
16261: AND
16262: IFFALSE 16273
// ComUnlink ( j ) ;
16264: LD_VAR 0 3
16268: PPUSH
16269: CALL_OW 136
16273: GO 16197
16275: POP
16276: POP
// end ;
16277: GO 16135
16279: POP
16280: POP
// end ;
16281: LD_VAR 0 1
16285: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
16286: LD_INT 0
16288: PPUSH
16289: PPUSH
16290: PPUSH
16291: PPUSH
16292: PPUSH
// if not mc_bases then
16293: LD_EXP 56
16297: NOT
16298: IFFALSE 16302
// exit ;
16300: GO 16762
// for i = 1 to mc_bases do
16302: LD_ADDR_VAR 0 2
16306: PUSH
16307: DOUBLE
16308: LD_INT 1
16310: DEC
16311: ST_TO_ADDR
16312: LD_EXP 56
16316: PUSH
16317: FOR_TO
16318: IFFALSE 16760
// begin if not mc_produce [ i ] then
16320: LD_EXP 77
16324: PUSH
16325: LD_VAR 0 2
16329: ARRAY
16330: NOT
16331: IFFALSE 16335
// continue ;
16333: GO 16317
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
16335: LD_ADDR_VAR 0 5
16339: PUSH
16340: LD_EXP 56
16344: PUSH
16345: LD_VAR 0 2
16349: ARRAY
16350: PPUSH
16351: LD_INT 30
16353: PUSH
16354: LD_INT 3
16356: PUSH
16357: EMPTY
16358: LIST
16359: LIST
16360: PPUSH
16361: CALL_OW 72
16365: ST_TO_ADDR
// if not fac then
16366: LD_VAR 0 5
16370: NOT
16371: IFFALSE 16375
// continue ;
16373: GO 16317
// for j in fac do
16375: LD_ADDR_VAR 0 3
16379: PUSH
16380: LD_VAR 0 5
16384: PUSH
16385: FOR_IN
16386: IFFALSE 16756
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
16388: LD_VAR 0 3
16392: PPUSH
16393: CALL_OW 461
16397: PUSH
16398: LD_INT 2
16400: NONEQUAL
16401: PUSH
16402: LD_VAR 0 3
16406: PPUSH
16407: LD_INT 15
16409: PPUSH
16410: CALL 39737 0 2
16414: PUSH
16415: LD_INT 4
16417: ARRAY
16418: OR
16419: PUSH
16420: LD_VAR 0 3
16424: PPUSH
16425: CALL_OW 313
16429: PUSH
16430: LD_INT 0
16432: EQUAL
16433: OR
16434: IFFALSE 16438
// continue ;
16436: GO 16385
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
16438: LD_VAR 0 3
16442: PPUSH
16443: LD_EXP 77
16447: PUSH
16448: LD_VAR 0 2
16452: ARRAY
16453: PUSH
16454: LD_INT 1
16456: ARRAY
16457: PUSH
16458: LD_INT 1
16460: ARRAY
16461: PPUSH
16462: LD_EXP 77
16466: PUSH
16467: LD_VAR 0 2
16471: ARRAY
16472: PUSH
16473: LD_INT 1
16475: ARRAY
16476: PUSH
16477: LD_INT 2
16479: ARRAY
16480: PPUSH
16481: LD_EXP 77
16485: PUSH
16486: LD_VAR 0 2
16490: ARRAY
16491: PUSH
16492: LD_INT 1
16494: ARRAY
16495: PUSH
16496: LD_INT 3
16498: ARRAY
16499: PPUSH
16500: LD_EXP 77
16504: PUSH
16505: LD_VAR 0 2
16509: ARRAY
16510: PUSH
16511: LD_INT 1
16513: ARRAY
16514: PUSH
16515: LD_INT 4
16517: ARRAY
16518: PPUSH
16519: CALL_OW 448
16523: PUSH
16524: LD_VAR 0 3
16528: PPUSH
16529: LD_EXP 77
16533: PUSH
16534: LD_VAR 0 2
16538: ARRAY
16539: PUSH
16540: LD_INT 1
16542: ARRAY
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: PUSH
16548: LD_EXP 77
16552: PUSH
16553: LD_VAR 0 2
16557: ARRAY
16558: PUSH
16559: LD_INT 1
16561: ARRAY
16562: PUSH
16563: LD_INT 2
16565: ARRAY
16566: PUSH
16567: LD_EXP 77
16571: PUSH
16572: LD_VAR 0 2
16576: ARRAY
16577: PUSH
16578: LD_INT 1
16580: ARRAY
16581: PUSH
16582: LD_INT 3
16584: ARRAY
16585: PUSH
16586: LD_EXP 77
16590: PUSH
16591: LD_VAR 0 2
16595: ARRAY
16596: PUSH
16597: LD_INT 1
16599: ARRAY
16600: PUSH
16601: LD_INT 4
16603: ARRAY
16604: PUSH
16605: EMPTY
16606: LIST
16607: LIST
16608: LIST
16609: LIST
16610: PPUSH
16611: CALL 43408 0 2
16615: AND
16616: IFFALSE 16754
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
16618: LD_VAR 0 3
16622: PPUSH
16623: LD_EXP 77
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: PUSH
16634: LD_INT 1
16636: ARRAY
16637: PUSH
16638: LD_INT 1
16640: ARRAY
16641: PPUSH
16642: LD_EXP 77
16646: PUSH
16647: LD_VAR 0 2
16651: ARRAY
16652: PUSH
16653: LD_INT 1
16655: ARRAY
16656: PUSH
16657: LD_INT 2
16659: ARRAY
16660: PPUSH
16661: LD_EXP 77
16665: PUSH
16666: LD_VAR 0 2
16670: ARRAY
16671: PUSH
16672: LD_INT 1
16674: ARRAY
16675: PUSH
16676: LD_INT 3
16678: ARRAY
16679: PPUSH
16680: LD_EXP 77
16684: PUSH
16685: LD_VAR 0 2
16689: ARRAY
16690: PUSH
16691: LD_INT 1
16693: ARRAY
16694: PUSH
16695: LD_INT 4
16697: ARRAY
16698: PPUSH
16699: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
16703: LD_ADDR_VAR 0 4
16707: PUSH
16708: LD_EXP 77
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_INT 1
16721: PPUSH
16722: CALL_OW 3
16726: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
16727: LD_ADDR_EXP 77
16731: PUSH
16732: LD_EXP 77
16736: PPUSH
16737: LD_VAR 0 2
16741: PPUSH
16742: LD_VAR 0 4
16746: PPUSH
16747: CALL_OW 1
16751: ST_TO_ADDR
// break ;
16752: GO 16756
// end ; end ;
16754: GO 16385
16756: POP
16757: POP
// end ;
16758: GO 16317
16760: POP
16761: POP
// end ;
16762: LD_VAR 0 1
16766: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
16767: LD_INT 0
16769: PPUSH
16770: PPUSH
16771: PPUSH
// if not mc_bases then
16772: LD_EXP 56
16776: NOT
16777: IFFALSE 16781
// exit ;
16779: GO 16870
// for i = 1 to mc_bases do
16781: LD_ADDR_VAR 0 2
16785: PUSH
16786: DOUBLE
16787: LD_INT 1
16789: DEC
16790: ST_TO_ADDR
16791: LD_EXP 56
16795: PUSH
16796: FOR_TO
16797: IFFALSE 16868
// begin if mc_attack [ i ] then
16799: LD_EXP 76
16803: PUSH
16804: LD_VAR 0 2
16808: ARRAY
16809: IFFALSE 16866
// begin tmp := mc_attack [ i ] [ 1 ] ;
16811: LD_ADDR_VAR 0 3
16815: PUSH
16816: LD_EXP 76
16820: PUSH
16821: LD_VAR 0 2
16825: ARRAY
16826: PUSH
16827: LD_INT 1
16829: ARRAY
16830: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
16831: LD_ADDR_EXP 76
16835: PUSH
16836: LD_EXP 76
16840: PPUSH
16841: LD_VAR 0 2
16845: PPUSH
16846: EMPTY
16847: PPUSH
16848: CALL_OW 1
16852: ST_TO_ADDR
// Attack ( tmp ) ;
16853: LD_VAR 0 3
16857: PPUSH
16858: CALL 65597 0 1
// exit ;
16862: POP
16863: POP
16864: GO 16870
// end ; end ;
16866: GO 16796
16868: POP
16869: POP
// end ;
16870: LD_VAR 0 1
16874: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
16875: LD_INT 0
16877: PPUSH
16878: PPUSH
16879: PPUSH
16880: PPUSH
16881: PPUSH
16882: PPUSH
16883: PPUSH
// if not mc_bases then
16884: LD_EXP 56
16888: NOT
16889: IFFALSE 16893
// exit ;
16891: GO 17497
// for i = 1 to mc_bases do
16893: LD_ADDR_VAR 0 2
16897: PUSH
16898: DOUBLE
16899: LD_INT 1
16901: DEC
16902: ST_TO_ADDR
16903: LD_EXP 56
16907: PUSH
16908: FOR_TO
16909: IFFALSE 17495
// begin if not mc_bases [ i ] then
16911: LD_EXP 56
16915: PUSH
16916: LD_VAR 0 2
16920: ARRAY
16921: NOT
16922: IFFALSE 16926
// continue ;
16924: GO 16908
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
16926: LD_ADDR_VAR 0 7
16930: PUSH
16931: LD_EXP 56
16935: PUSH
16936: LD_VAR 0 2
16940: ARRAY
16941: PUSH
16942: LD_INT 1
16944: ARRAY
16945: PPUSH
16946: CALL 34048 0 1
16950: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
16951: LD_ADDR_EXP 79
16955: PUSH
16956: LD_EXP 79
16960: PPUSH
16961: LD_VAR 0 2
16965: PPUSH
16966: LD_EXP 56
16970: PUSH
16971: LD_VAR 0 2
16975: ARRAY
16976: PUSH
16977: LD_INT 1
16979: ARRAY
16980: PPUSH
16981: CALL_OW 255
16985: PPUSH
16986: LD_EXP 81
16990: PUSH
16991: LD_VAR 0 2
16995: ARRAY
16996: PPUSH
16997: CALL 32008 0 2
17001: PPUSH
17002: CALL_OW 1
17006: ST_TO_ADDR
// if not mc_scan [ i ] then
17007: LD_EXP 79
17011: PUSH
17012: LD_VAR 0 2
17016: ARRAY
17017: NOT
17018: IFFALSE 17173
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17020: LD_ADDR_VAR 0 4
17024: PUSH
17025: LD_EXP 56
17029: PUSH
17030: LD_VAR 0 2
17034: ARRAY
17035: PPUSH
17036: LD_INT 2
17038: PUSH
17039: LD_INT 25
17041: PUSH
17042: LD_INT 5
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 25
17051: PUSH
17052: LD_INT 8
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PUSH
17059: LD_INT 25
17061: PUSH
17062: LD_INT 9
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: LIST
17073: LIST
17074: PPUSH
17075: CALL_OW 72
17079: ST_TO_ADDR
// if not tmp then
17080: LD_VAR 0 4
17084: NOT
17085: IFFALSE 17089
// continue ;
17087: GO 16908
// for j in tmp do
17089: LD_ADDR_VAR 0 3
17093: PUSH
17094: LD_VAR 0 4
17098: PUSH
17099: FOR_IN
17100: IFFALSE 17171
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
17102: LD_VAR 0 3
17106: PPUSH
17107: CALL_OW 310
17111: PPUSH
17112: CALL_OW 266
17116: PUSH
17117: LD_INT 5
17119: EQUAL
17120: PUSH
17121: LD_VAR 0 3
17125: PPUSH
17126: CALL_OW 257
17130: PUSH
17131: LD_INT 1
17133: EQUAL
17134: AND
17135: PUSH
17136: LD_VAR 0 3
17140: PPUSH
17141: CALL_OW 459
17145: NOT
17146: AND
17147: PUSH
17148: LD_VAR 0 7
17152: AND
17153: IFFALSE 17169
// ComChangeProfession ( j , class ) ;
17155: LD_VAR 0 3
17159: PPUSH
17160: LD_VAR 0 7
17164: PPUSH
17165: CALL_OW 123
17169: GO 17099
17171: POP
17172: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
17173: LD_EXP 79
17177: PUSH
17178: LD_VAR 0 2
17182: ARRAY
17183: PUSH
17184: LD_EXP 78
17188: PUSH
17189: LD_VAR 0 2
17193: ARRAY
17194: NOT
17195: AND
17196: PUSH
17197: LD_EXP 56
17201: PUSH
17202: LD_VAR 0 2
17206: ARRAY
17207: PPUSH
17208: LD_INT 30
17210: PUSH
17211: LD_INT 32
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PPUSH
17218: CALL_OW 72
17222: NOT
17223: AND
17224: PUSH
17225: LD_EXP 56
17229: PUSH
17230: LD_VAR 0 2
17234: ARRAY
17235: PPUSH
17236: LD_INT 2
17238: PUSH
17239: LD_INT 30
17241: PUSH
17242: LD_INT 4
17244: PUSH
17245: EMPTY
17246: LIST
17247: LIST
17248: PUSH
17249: LD_INT 30
17251: PUSH
17252: LD_INT 5
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: LIST
17263: PPUSH
17264: CALL_OW 72
17268: NOT
17269: AND
17270: IFFALSE 17402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17272: LD_ADDR_VAR 0 4
17276: PUSH
17277: LD_EXP 56
17281: PUSH
17282: LD_VAR 0 2
17286: ARRAY
17287: PPUSH
17288: LD_INT 2
17290: PUSH
17291: LD_INT 25
17293: PUSH
17294: LD_INT 1
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 5
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 25
17313: PUSH
17314: LD_INT 8
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 25
17323: PUSH
17324: LD_INT 9
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: PPUSH
17338: CALL_OW 72
17342: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
17343: LD_ADDR_VAR 0 4
17347: PUSH
17348: LD_VAR 0 4
17352: PUSH
17353: LD_VAR 0 4
17357: PPUSH
17358: LD_INT 18
17360: PPUSH
17361: CALL 70341 0 2
17365: DIFF
17366: ST_TO_ADDR
// if tmp then
17367: LD_VAR 0 4
17371: IFFALSE 17402
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
17373: LD_VAR 0 2
17377: PPUSH
17378: LD_VAR 0 4
17382: PPUSH
17383: LD_EXP 81
17387: PUSH
17388: LD_VAR 0 2
17392: ARRAY
17393: PPUSH
17394: CALL 32043 0 3
// exit ;
17398: POP
17399: POP
17400: GO 17497
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
17402: LD_EXP 79
17406: PUSH
17407: LD_VAR 0 2
17411: ARRAY
17412: PUSH
17413: LD_EXP 78
17417: PUSH
17418: LD_VAR 0 2
17422: ARRAY
17423: AND
17424: IFFALSE 17493
// begin tmp := mc_defender [ i ] ;
17426: LD_ADDR_VAR 0 4
17430: PUSH
17431: LD_EXP 78
17435: PUSH
17436: LD_VAR 0 2
17440: ARRAY
17441: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
17442: LD_ADDR_EXP 78
17446: PUSH
17447: LD_EXP 78
17451: PPUSH
17452: LD_VAR 0 2
17456: PPUSH
17457: EMPTY
17458: PPUSH
17459: CALL_OW 1
17463: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
17464: LD_VAR 0 2
17468: PPUSH
17469: LD_VAR 0 4
17473: PPUSH
17474: LD_EXP 79
17478: PUSH
17479: LD_VAR 0 2
17483: ARRAY
17484: PPUSH
17485: CALL 32541 0 3
// exit ;
17489: POP
17490: POP
17491: GO 17497
// end ; end ;
17493: GO 16908
17495: POP
17496: POP
// end ;
17497: LD_VAR 0 1
17501: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
17502: LD_INT 0
17504: PPUSH
17505: PPUSH
17506: PPUSH
17507: PPUSH
17508: PPUSH
17509: PPUSH
17510: PPUSH
17511: PPUSH
17512: PPUSH
17513: PPUSH
17514: PPUSH
// if not mc_bases then
17515: LD_EXP 56
17519: NOT
17520: IFFALSE 17524
// exit ;
17522: GO 18611
// for i = 1 to mc_bases do
17524: LD_ADDR_VAR 0 2
17528: PUSH
17529: DOUBLE
17530: LD_INT 1
17532: DEC
17533: ST_TO_ADDR
17534: LD_EXP 56
17538: PUSH
17539: FOR_TO
17540: IFFALSE 18609
// begin tmp := mc_lab [ i ] ;
17542: LD_ADDR_VAR 0 6
17546: PUSH
17547: LD_EXP 89
17551: PUSH
17552: LD_VAR 0 2
17556: ARRAY
17557: ST_TO_ADDR
// if not tmp then
17558: LD_VAR 0 6
17562: NOT
17563: IFFALSE 17567
// continue ;
17565: GO 17539
// idle_lab := 0 ;
17567: LD_ADDR_VAR 0 11
17571: PUSH
17572: LD_INT 0
17574: ST_TO_ADDR
// for j in tmp do
17575: LD_ADDR_VAR 0 3
17579: PUSH
17580: LD_VAR 0 6
17584: PUSH
17585: FOR_IN
17586: IFFALSE 18605
// begin researching := false ;
17588: LD_ADDR_VAR 0 10
17592: PUSH
17593: LD_INT 0
17595: ST_TO_ADDR
// side := GetSide ( j ) ;
17596: LD_ADDR_VAR 0 4
17600: PUSH
17601: LD_VAR 0 3
17605: PPUSH
17606: CALL_OW 255
17610: ST_TO_ADDR
// if not mc_tech [ side ] then
17611: LD_EXP 83
17615: PUSH
17616: LD_VAR 0 4
17620: ARRAY
17621: NOT
17622: IFFALSE 17626
// continue ;
17624: GO 17585
// if BuildingStatus ( j ) = bs_idle then
17626: LD_VAR 0 3
17630: PPUSH
17631: CALL_OW 461
17635: PUSH
17636: LD_INT 2
17638: EQUAL
17639: IFFALSE 17827
// begin if idle_lab and UnitsInside ( j ) < 6 then
17641: LD_VAR 0 11
17645: PUSH
17646: LD_VAR 0 3
17650: PPUSH
17651: CALL_OW 313
17655: PUSH
17656: LD_INT 6
17658: LESS
17659: AND
17660: IFFALSE 17731
// begin tmp2 := UnitsInside ( idle_lab ) ;
17662: LD_ADDR_VAR 0 9
17666: PUSH
17667: LD_VAR 0 11
17671: PPUSH
17672: CALL_OW 313
17676: ST_TO_ADDR
// if tmp2 then
17677: LD_VAR 0 9
17681: IFFALSE 17723
// for x in tmp2 do
17683: LD_ADDR_VAR 0 7
17687: PUSH
17688: LD_VAR 0 9
17692: PUSH
17693: FOR_IN
17694: IFFALSE 17721
// begin ComExitBuilding ( x ) ;
17696: LD_VAR 0 7
17700: PPUSH
17701: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
17705: LD_VAR 0 7
17709: PPUSH
17710: LD_VAR 0 3
17714: PPUSH
17715: CALL_OW 180
// end ;
17719: GO 17693
17721: POP
17722: POP
// idle_lab := 0 ;
17723: LD_ADDR_VAR 0 11
17727: PUSH
17728: LD_INT 0
17730: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
17731: LD_ADDR_VAR 0 5
17735: PUSH
17736: LD_EXP 83
17740: PUSH
17741: LD_VAR 0 4
17745: ARRAY
17746: PUSH
17747: FOR_IN
17748: IFFALSE 17808
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
17750: LD_VAR 0 3
17754: PPUSH
17755: LD_VAR 0 5
17759: PPUSH
17760: CALL_OW 430
17764: PUSH
17765: LD_VAR 0 4
17769: PPUSH
17770: LD_VAR 0 5
17774: PPUSH
17775: CALL 31113 0 2
17779: AND
17780: IFFALSE 17806
// begin researching := true ;
17782: LD_ADDR_VAR 0 10
17786: PUSH
17787: LD_INT 1
17789: ST_TO_ADDR
// ComResearch ( j , t ) ;
17790: LD_VAR 0 3
17794: PPUSH
17795: LD_VAR 0 5
17799: PPUSH
17800: CALL_OW 124
// break ;
17804: GO 17808
// end ;
17806: GO 17747
17808: POP
17809: POP
// if not researching then
17810: LD_VAR 0 10
17814: NOT
17815: IFFALSE 17827
// idle_lab := j ;
17817: LD_ADDR_VAR 0 11
17821: PUSH
17822: LD_VAR 0 3
17826: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
17827: LD_VAR 0 3
17831: PPUSH
17832: CALL_OW 461
17836: PUSH
17837: LD_INT 10
17839: EQUAL
17840: IFFALSE 18428
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_VAR 0 2
17851: ARRAY
17852: NOT
17853: PUSH
17854: LD_EXP 86
17858: PUSH
17859: LD_VAR 0 2
17863: ARRAY
17864: NOT
17865: AND
17866: PUSH
17867: LD_EXP 83
17871: PUSH
17872: LD_VAR 0 4
17876: ARRAY
17877: PUSH
17878: LD_INT 1
17880: GREATER
17881: AND
17882: IFFALSE 18013
// begin ComCancel ( j ) ;
17884: LD_VAR 0 3
17888: PPUSH
17889: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
17893: LD_ADDR_EXP 83
17897: PUSH
17898: LD_EXP 83
17902: PPUSH
17903: LD_VAR 0 4
17907: PPUSH
17908: LD_EXP 83
17912: PUSH
17913: LD_VAR 0 4
17917: ARRAY
17918: PPUSH
17919: LD_EXP 83
17923: PUSH
17924: LD_VAR 0 4
17928: ARRAY
17929: PUSH
17930: LD_INT 1
17932: MINUS
17933: PPUSH
17934: LD_EXP 83
17938: PUSH
17939: LD_VAR 0 4
17943: ARRAY
17944: PPUSH
17945: LD_INT 0
17947: PPUSH
17948: CALL 36562 0 4
17952: PPUSH
17953: CALL_OW 1
17957: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
17958: LD_ADDR_EXP 83
17962: PUSH
17963: LD_EXP 83
17967: PPUSH
17968: LD_VAR 0 4
17972: PPUSH
17973: LD_EXP 83
17977: PUSH
17978: LD_VAR 0 4
17982: ARRAY
17983: PPUSH
17984: LD_EXP 83
17988: PUSH
17989: LD_VAR 0 4
17993: ARRAY
17994: PPUSH
17995: LD_INT 1
17997: PPUSH
17998: LD_INT 0
18000: PPUSH
18001: CALL 36562 0 4
18005: PPUSH
18006: CALL_OW 1
18010: ST_TO_ADDR
// continue ;
18011: GO 17585
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
18013: LD_EXP 85
18017: PUSH
18018: LD_VAR 0 2
18022: ARRAY
18023: PUSH
18024: LD_EXP 86
18028: PUSH
18029: LD_VAR 0 2
18033: ARRAY
18034: NOT
18035: AND
18036: IFFALSE 18163
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
18038: LD_ADDR_EXP 86
18042: PUSH
18043: LD_EXP 86
18047: PPUSH
18048: LD_VAR 0 2
18052: PUSH
18053: LD_EXP 86
18057: PUSH
18058: LD_VAR 0 2
18062: ARRAY
18063: PUSH
18064: LD_INT 1
18066: PLUS
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: PPUSH
18072: LD_EXP 85
18076: PUSH
18077: LD_VAR 0 2
18081: ARRAY
18082: PUSH
18083: LD_INT 1
18085: ARRAY
18086: PPUSH
18087: CALL 37144 0 3
18091: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
18092: LD_EXP 85
18096: PUSH
18097: LD_VAR 0 2
18101: ARRAY
18102: PUSH
18103: LD_INT 1
18105: ARRAY
18106: PPUSH
18107: LD_INT 112
18109: PPUSH
18110: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
18114: LD_ADDR_VAR 0 9
18118: PUSH
18119: LD_EXP 85
18123: PUSH
18124: LD_VAR 0 2
18128: ARRAY
18129: PPUSH
18130: LD_INT 1
18132: PPUSH
18133: CALL_OW 3
18137: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
18138: LD_ADDR_EXP 85
18142: PUSH
18143: LD_EXP 85
18147: PPUSH
18148: LD_VAR 0 2
18152: PPUSH
18153: LD_VAR 0 9
18157: PPUSH
18158: CALL_OW 1
18162: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
18163: LD_EXP 85
18167: PUSH
18168: LD_VAR 0 2
18172: ARRAY
18173: PUSH
18174: LD_EXP 86
18178: PUSH
18179: LD_VAR 0 2
18183: ARRAY
18184: AND
18185: PUSH
18186: LD_EXP 86
18190: PUSH
18191: LD_VAR 0 2
18195: ARRAY
18196: PUSH
18197: LD_INT 1
18199: ARRAY
18200: PPUSH
18201: CALL_OW 310
18205: NOT
18206: AND
18207: PUSH
18208: LD_VAR 0 3
18212: PPUSH
18213: CALL_OW 313
18217: PUSH
18218: LD_INT 6
18220: EQUAL
18221: AND
18222: IFFALSE 18278
// begin tmp2 := UnitsInside ( j ) ;
18224: LD_ADDR_VAR 0 9
18228: PUSH
18229: LD_VAR 0 3
18233: PPUSH
18234: CALL_OW 313
18238: ST_TO_ADDR
// if tmp2 = 6 then
18239: LD_VAR 0 9
18243: PUSH
18244: LD_INT 6
18246: EQUAL
18247: IFFALSE 18278
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
18249: LD_VAR 0 9
18253: PUSH
18254: LD_INT 1
18256: ARRAY
18257: PPUSH
18258: LD_INT 112
18260: PPUSH
18261: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
18265: LD_VAR 0 9
18269: PUSH
18270: LD_INT 1
18272: ARRAY
18273: PPUSH
18274: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
18278: LD_EXP 86
18282: PUSH
18283: LD_VAR 0 2
18287: ARRAY
18288: PUSH
18289: LD_EXP 86
18293: PUSH
18294: LD_VAR 0 2
18298: ARRAY
18299: PUSH
18300: LD_INT 1
18302: ARRAY
18303: PPUSH
18304: CALL_OW 314
18308: NOT
18309: AND
18310: PUSH
18311: LD_EXP 86
18315: PUSH
18316: LD_VAR 0 2
18320: ARRAY
18321: PUSH
18322: LD_INT 1
18324: ARRAY
18325: PPUSH
18326: CALL_OW 310
18330: NOT
18331: AND
18332: IFFALSE 18358
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
18334: LD_EXP 86
18338: PUSH
18339: LD_VAR 0 2
18343: ARRAY
18344: PUSH
18345: LD_INT 1
18347: ARRAY
18348: PPUSH
18349: LD_VAR 0 3
18353: PPUSH
18354: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
18358: LD_EXP 86
18362: PUSH
18363: LD_VAR 0 2
18367: ARRAY
18368: PUSH
18369: LD_INT 1
18371: ARRAY
18372: PPUSH
18373: CALL_OW 310
18377: PUSH
18378: LD_EXP 86
18382: PUSH
18383: LD_VAR 0 2
18387: ARRAY
18388: PUSH
18389: LD_INT 1
18391: ARRAY
18392: PPUSH
18393: CALL_OW 310
18397: PPUSH
18398: CALL_OW 461
18402: PUSH
18403: LD_INT 3
18405: NONEQUAL
18406: AND
18407: IFFALSE 18428
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
18409: LD_EXP 86
18413: PUSH
18414: LD_VAR 0 2
18418: ARRAY
18419: PUSH
18420: LD_INT 1
18422: ARRAY
18423: PPUSH
18424: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
18428: LD_VAR 0 3
18432: PPUSH
18433: CALL_OW 461
18437: PUSH
18438: LD_INT 6
18440: EQUAL
18441: PUSH
18442: LD_VAR 0 6
18446: PUSH
18447: LD_INT 1
18449: GREATER
18450: AND
18451: IFFALSE 18603
// begin sci := [ ] ;
18453: LD_ADDR_VAR 0 8
18457: PUSH
18458: EMPTY
18459: ST_TO_ADDR
// for x in ( tmp diff j ) do
18460: LD_ADDR_VAR 0 7
18464: PUSH
18465: LD_VAR 0 6
18469: PUSH
18470: LD_VAR 0 3
18474: DIFF
18475: PUSH
18476: FOR_IN
18477: IFFALSE 18529
// begin if sci = 6 then
18479: LD_VAR 0 8
18483: PUSH
18484: LD_INT 6
18486: EQUAL
18487: IFFALSE 18491
// break ;
18489: GO 18529
// if BuildingStatus ( x ) = bs_idle then
18491: LD_VAR 0 7
18495: PPUSH
18496: CALL_OW 461
18500: PUSH
18501: LD_INT 2
18503: EQUAL
18504: IFFALSE 18527
// sci := sci ^ UnitsInside ( x ) ;
18506: LD_ADDR_VAR 0 8
18510: PUSH
18511: LD_VAR 0 8
18515: PUSH
18516: LD_VAR 0 7
18520: PPUSH
18521: CALL_OW 313
18525: ADD
18526: ST_TO_ADDR
// end ;
18527: GO 18476
18529: POP
18530: POP
// if not sci then
18531: LD_VAR 0 8
18535: NOT
18536: IFFALSE 18540
// continue ;
18538: GO 17585
// for x in sci do
18540: LD_ADDR_VAR 0 7
18544: PUSH
18545: LD_VAR 0 8
18549: PUSH
18550: FOR_IN
18551: IFFALSE 18601
// if IsInUnit ( x ) and not HasTask ( x ) then
18553: LD_VAR 0 7
18557: PPUSH
18558: CALL_OW 310
18562: PUSH
18563: LD_VAR 0 7
18567: PPUSH
18568: CALL_OW 314
18572: NOT
18573: AND
18574: IFFALSE 18599
// begin ComExitBuilding ( x ) ;
18576: LD_VAR 0 7
18580: PPUSH
18581: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
18585: LD_VAR 0 7
18589: PPUSH
18590: LD_VAR 0 3
18594: PPUSH
18595: CALL_OW 180
// end ;
18599: GO 18550
18601: POP
18602: POP
// end ; end ;
18603: GO 17585
18605: POP
18606: POP
// end ;
18607: GO 17539
18609: POP
18610: POP
// end ;
18611: LD_VAR 0 1
18615: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
18616: LD_INT 0
18618: PPUSH
18619: PPUSH
// if not mc_bases then
18620: LD_EXP 56
18624: NOT
18625: IFFALSE 18629
// exit ;
18627: GO 18710
// for i = 1 to mc_bases do
18629: LD_ADDR_VAR 0 2
18633: PUSH
18634: DOUBLE
18635: LD_INT 1
18637: DEC
18638: ST_TO_ADDR
18639: LD_EXP 56
18643: PUSH
18644: FOR_TO
18645: IFFALSE 18708
// if mc_mines [ i ] and mc_miners [ i ] then
18647: LD_EXP 69
18651: PUSH
18652: LD_VAR 0 2
18656: ARRAY
18657: PUSH
18658: LD_EXP 70
18662: PUSH
18663: LD_VAR 0 2
18667: ARRAY
18668: AND
18669: IFFALSE 18706
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
18671: LD_EXP 70
18675: PUSH
18676: LD_VAR 0 2
18680: ARRAY
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PPUSH
18686: CALL_OW 255
18690: PPUSH
18691: LD_EXP 69
18695: PUSH
18696: LD_VAR 0 2
18700: ARRAY
18701: PPUSH
18702: CALL 34201 0 2
18706: GO 18644
18708: POP
18709: POP
// end ;
18710: LD_VAR 0 1
18714: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
18715: LD_INT 0
18717: PPUSH
18718: PPUSH
18719: PPUSH
18720: PPUSH
18721: PPUSH
18722: PPUSH
18723: PPUSH
18724: PPUSH
// if not mc_bases or not mc_parking then
18725: LD_EXP 56
18729: NOT
18730: PUSH
18731: LD_EXP 80
18735: NOT
18736: OR
18737: IFFALSE 18741
// exit ;
18739: GO 19453
// for i = 1 to mc_bases do
18741: LD_ADDR_VAR 0 2
18745: PUSH
18746: DOUBLE
18747: LD_INT 1
18749: DEC
18750: ST_TO_ADDR
18751: LD_EXP 56
18755: PUSH
18756: FOR_TO
18757: IFFALSE 19451
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
18759: LD_EXP 56
18763: PUSH
18764: LD_VAR 0 2
18768: ARRAY
18769: NOT
18770: PUSH
18771: LD_EXP 80
18775: PUSH
18776: LD_VAR 0 2
18780: ARRAY
18781: NOT
18782: OR
18783: IFFALSE 18787
// continue ;
18785: GO 18756
// if mc_scan [ i ] then
18787: LD_EXP 79
18791: PUSH
18792: LD_VAR 0 2
18796: ARRAY
18797: IFFALSE 18823
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
18799: LD_ADDR_EXP 68
18803: PUSH
18804: LD_EXP 68
18808: PPUSH
18809: LD_VAR 0 2
18813: PPUSH
18814: EMPTY
18815: PPUSH
18816: CALL_OW 1
18820: ST_TO_ADDR
// continue ;
18821: GO 18756
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
18823: LD_ADDR_VAR 0 5
18827: PUSH
18828: LD_EXP 56
18832: PUSH
18833: LD_VAR 0 2
18837: ARRAY
18838: PUSH
18839: LD_INT 1
18841: ARRAY
18842: PPUSH
18843: CALL_OW 255
18847: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
18848: LD_ADDR_VAR 0 6
18852: PUSH
18853: LD_EXP 56
18857: PUSH
18858: LD_VAR 0 2
18862: ARRAY
18863: PPUSH
18864: LD_INT 30
18866: PUSH
18867: LD_INT 3
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: PPUSH
18874: CALL_OW 72
18878: ST_TO_ADDR
// if not fac then
18879: LD_VAR 0 6
18883: NOT
18884: IFFALSE 18935
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
18886: LD_ADDR_VAR 0 6
18890: PUSH
18891: LD_EXP 56
18895: PUSH
18896: LD_VAR 0 2
18900: ARRAY
18901: PPUSH
18902: LD_INT 2
18904: PUSH
18905: LD_INT 30
18907: PUSH
18908: LD_INT 0
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: PUSH
18915: LD_INT 30
18917: PUSH
18918: LD_INT 1
18920: PUSH
18921: EMPTY
18922: LIST
18923: LIST
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: LIST
18929: PPUSH
18930: CALL_OW 72
18934: ST_TO_ADDR
// if not fac then
18935: LD_VAR 0 6
18939: NOT
18940: IFFALSE 18944
// continue ;
18942: GO 18756
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
18944: LD_ADDR_VAR 0 7
18948: PUSH
18949: LD_EXP 80
18953: PUSH
18954: LD_VAR 0 2
18958: ARRAY
18959: PPUSH
18960: LD_INT 22
18962: PUSH
18963: LD_VAR 0 5
18967: PUSH
18968: EMPTY
18969: LIST
18970: LIST
18971: PUSH
18972: LD_INT 21
18974: PUSH
18975: LD_INT 2
18977: PUSH
18978: EMPTY
18979: LIST
18980: LIST
18981: PUSH
18982: LD_INT 3
18984: PUSH
18985: LD_INT 24
18987: PUSH
18988: LD_INT 1000
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: LIST
19003: PPUSH
19004: CALL_OW 70
19008: PUSH
19009: LD_INT 22
19011: PUSH
19012: LD_VAR 0 5
19016: PUSH
19017: EMPTY
19018: LIST
19019: LIST
19020: PUSH
19021: LD_INT 91
19023: PUSH
19024: LD_VAR 0 6
19028: PUSH
19029: LD_INT 1
19031: ARRAY
19032: PUSH
19033: LD_INT 25
19035: PUSH
19036: EMPTY
19037: LIST
19038: LIST
19039: LIST
19040: PUSH
19041: LD_INT 21
19043: PUSH
19044: LD_INT 2
19046: PUSH
19047: EMPTY
19048: LIST
19049: LIST
19050: PUSH
19051: LD_INT 3
19053: PUSH
19054: LD_INT 24
19056: PUSH
19057: LD_INT 1000
19059: PUSH
19060: EMPTY
19061: LIST
19062: LIST
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: PUSH
19068: EMPTY
19069: LIST
19070: LIST
19071: LIST
19072: LIST
19073: PPUSH
19074: CALL_OW 69
19078: UNION
19079: ST_TO_ADDR
// if not vehs then
19080: LD_VAR 0 7
19084: NOT
19085: IFFALSE 19111
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19087: LD_ADDR_EXP 68
19091: PUSH
19092: LD_EXP 68
19096: PPUSH
19097: LD_VAR 0 2
19101: PPUSH
19102: EMPTY
19103: PPUSH
19104: CALL_OW 1
19108: ST_TO_ADDR
// continue ;
19109: GO 18756
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
19111: LD_ADDR_VAR 0 8
19115: PUSH
19116: LD_EXP 56
19120: PUSH
19121: LD_VAR 0 2
19125: ARRAY
19126: PPUSH
19127: LD_INT 30
19129: PUSH
19130: LD_INT 3
19132: PUSH
19133: EMPTY
19134: LIST
19135: LIST
19136: PPUSH
19137: CALL_OW 72
19141: ST_TO_ADDR
// if tmp then
19142: LD_VAR 0 8
19146: IFFALSE 19249
// begin for j in tmp do
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: LD_VAR 0 8
19157: PUSH
19158: FOR_IN
19159: IFFALSE 19247
// for k in UnitsInside ( j ) do
19161: LD_ADDR_VAR 0 4
19165: PUSH
19166: LD_VAR 0 3
19170: PPUSH
19171: CALL_OW 313
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19243
// if k then
19179: LD_VAR 0 4
19183: IFFALSE 19241
// if not k in mc_repair_vehicle [ i ] then
19185: LD_VAR 0 4
19189: PUSH
19190: LD_EXP 68
19194: PUSH
19195: LD_VAR 0 2
19199: ARRAY
19200: IN
19201: NOT
19202: IFFALSE 19241
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
19204: LD_ADDR_EXP 68
19208: PUSH
19209: LD_EXP 68
19213: PPUSH
19214: LD_VAR 0 2
19218: PPUSH
19219: LD_EXP 68
19223: PUSH
19224: LD_VAR 0 2
19228: ARRAY
19229: PUSH
19230: LD_VAR 0 4
19234: UNION
19235: PPUSH
19236: CALL_OW 1
19240: ST_TO_ADDR
19241: GO 19176
19243: POP
19244: POP
19245: GO 19158
19247: POP
19248: POP
// end ; if not mc_repair_vehicle [ i ] then
19249: LD_EXP 68
19253: PUSH
19254: LD_VAR 0 2
19258: ARRAY
19259: NOT
19260: IFFALSE 19264
// continue ;
19262: GO 18756
// for j in mc_repair_vehicle [ i ] do
19264: LD_ADDR_VAR 0 3
19268: PUSH
19269: LD_EXP 68
19273: PUSH
19274: LD_VAR 0 2
19278: ARRAY
19279: PUSH
19280: FOR_IN
19281: IFFALSE 19447
// begin if GetClass ( j ) <> 3 then
19283: LD_VAR 0 3
19287: PPUSH
19288: CALL_OW 257
19292: PUSH
19293: LD_INT 3
19295: NONEQUAL
19296: IFFALSE 19337
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
19298: LD_ADDR_EXP 68
19302: PUSH
19303: LD_EXP 68
19307: PPUSH
19308: LD_VAR 0 2
19312: PPUSH
19313: LD_EXP 68
19317: PUSH
19318: LD_VAR 0 2
19322: ARRAY
19323: PUSH
19324: LD_VAR 0 3
19328: DIFF
19329: PPUSH
19330: CALL_OW 1
19334: ST_TO_ADDR
// continue ;
19335: GO 19280
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
19337: LD_VAR 0 3
19341: PPUSH
19342: CALL_OW 311
19346: NOT
19347: PUSH
19348: LD_VAR 0 3
19352: PUSH
19353: LD_EXP 59
19357: PUSH
19358: LD_VAR 0 2
19362: ARRAY
19363: PUSH
19364: LD_INT 1
19366: ARRAY
19367: IN
19368: NOT
19369: AND
19370: PUSH
19371: LD_VAR 0 3
19375: PUSH
19376: LD_EXP 59
19380: PUSH
19381: LD_VAR 0 2
19385: ARRAY
19386: PUSH
19387: LD_INT 2
19389: ARRAY
19390: IN
19391: NOT
19392: AND
19393: IFFALSE 19445
// begin if IsInUnit ( j ) then
19395: LD_VAR 0 3
19399: PPUSH
19400: CALL_OW 310
19404: IFFALSE 19415
// ComExitBuilding ( j ) ;
19406: LD_VAR 0 3
19410: PPUSH
19411: CALL_OW 122
// if not HasTask ( j ) then
19415: LD_VAR 0 3
19419: PPUSH
19420: CALL_OW 314
19424: NOT
19425: IFFALSE 19445
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
19427: LD_VAR 0 3
19431: PPUSH
19432: LD_VAR 0 7
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: CALL_OW 189
// end ; end ;
19445: GO 19280
19447: POP
19448: POP
// end ;
19449: GO 18756
19451: POP
19452: POP
// end ;
19453: LD_VAR 0 1
19457: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
19458: LD_INT 0
19460: PPUSH
19461: PPUSH
19462: PPUSH
19463: PPUSH
19464: PPUSH
19465: PPUSH
19466: PPUSH
19467: PPUSH
19468: PPUSH
19469: PPUSH
19470: PPUSH
// if not mc_bases then
19471: LD_EXP 56
19475: NOT
19476: IFFALSE 19480
// exit ;
19478: GO 20282
// for i = 1 to mc_bases do
19480: LD_ADDR_VAR 0 2
19484: PUSH
19485: DOUBLE
19486: LD_INT 1
19488: DEC
19489: ST_TO_ADDR
19490: LD_EXP 56
19494: PUSH
19495: FOR_TO
19496: IFFALSE 20280
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
19498: LD_EXP 84
19502: PUSH
19503: LD_VAR 0 2
19507: ARRAY
19508: NOT
19509: PUSH
19510: LD_EXP 59
19514: PUSH
19515: LD_VAR 0 2
19519: ARRAY
19520: PUSH
19521: LD_INT 1
19523: ARRAY
19524: OR
19525: PUSH
19526: LD_EXP 59
19530: PUSH
19531: LD_VAR 0 2
19535: ARRAY
19536: PUSH
19537: LD_INT 2
19539: ARRAY
19540: OR
19541: PUSH
19542: LD_EXP 82
19546: PUSH
19547: LD_VAR 0 2
19551: ARRAY
19552: PPUSH
19553: LD_INT 1
19555: PPUSH
19556: CALL_OW 325
19560: NOT
19561: OR
19562: PUSH
19563: LD_EXP 79
19567: PUSH
19568: LD_VAR 0 2
19572: ARRAY
19573: OR
19574: IFFALSE 19578
// continue ;
19576: GO 19495
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
19578: LD_ADDR_VAR 0 8
19582: PUSH
19583: LD_EXP 56
19587: PUSH
19588: LD_VAR 0 2
19592: ARRAY
19593: PPUSH
19594: LD_INT 25
19596: PUSH
19597: LD_INT 4
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: PUSH
19604: LD_INT 50
19606: PUSH
19607: EMPTY
19608: LIST
19609: PUSH
19610: LD_INT 3
19612: PUSH
19613: LD_INT 60
19615: PUSH
19616: EMPTY
19617: LIST
19618: PUSH
19619: EMPTY
19620: LIST
19621: LIST
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: PPUSH
19628: CALL_OW 72
19632: PUSH
19633: LD_EXP 60
19637: PUSH
19638: LD_VAR 0 2
19642: ARRAY
19643: DIFF
19644: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
19645: LD_ADDR_VAR 0 9
19649: PUSH
19650: LD_EXP 56
19654: PUSH
19655: LD_VAR 0 2
19659: ARRAY
19660: PPUSH
19661: LD_INT 2
19663: PUSH
19664: LD_INT 30
19666: PUSH
19667: LD_INT 0
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 30
19676: PUSH
19677: LD_INT 1
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: LIST
19688: PPUSH
19689: CALL_OW 72
19693: ST_TO_ADDR
// if not tmp or not dep then
19694: LD_VAR 0 8
19698: NOT
19699: PUSH
19700: LD_VAR 0 9
19704: NOT
19705: OR
19706: IFFALSE 19710
// continue ;
19708: GO 19495
// side := GetSide ( tmp [ 1 ] ) ;
19710: LD_ADDR_VAR 0 11
19714: PUSH
19715: LD_VAR 0 8
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: CALL_OW 255
19728: ST_TO_ADDR
// dep := dep [ 1 ] ;
19729: LD_ADDR_VAR 0 9
19733: PUSH
19734: LD_VAR 0 9
19738: PUSH
19739: LD_INT 1
19741: ARRAY
19742: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
19743: LD_ADDR_VAR 0 7
19747: PUSH
19748: LD_EXP 84
19752: PUSH
19753: LD_VAR 0 2
19757: ARRAY
19758: PPUSH
19759: LD_INT 22
19761: PUSH
19762: LD_INT 0
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: PUSH
19769: LD_INT 25
19771: PUSH
19772: LD_INT 12
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: PPUSH
19783: CALL_OW 70
19787: PUSH
19788: LD_INT 22
19790: PUSH
19791: LD_INT 0
19793: PUSH
19794: EMPTY
19795: LIST
19796: LIST
19797: PUSH
19798: LD_INT 25
19800: PUSH
19801: LD_INT 12
19803: PUSH
19804: EMPTY
19805: LIST
19806: LIST
19807: PUSH
19808: LD_INT 91
19810: PUSH
19811: LD_VAR 0 9
19815: PUSH
19816: LD_INT 20
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: LIST
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: LIST
19828: PPUSH
19829: CALL_OW 69
19833: UNION
19834: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
19835: LD_ADDR_VAR 0 10
19839: PUSH
19840: LD_EXP 84
19844: PUSH
19845: LD_VAR 0 2
19849: ARRAY
19850: PPUSH
19851: LD_INT 81
19853: PUSH
19854: LD_VAR 0 11
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: PPUSH
19863: CALL_OW 70
19867: ST_TO_ADDR
// if not apes or danger_at_area then
19868: LD_VAR 0 7
19872: NOT
19873: PUSH
19874: LD_VAR 0 10
19878: OR
19879: IFFALSE 19929
// begin if mc_taming [ i ] then
19881: LD_EXP 87
19885: PUSH
19886: LD_VAR 0 2
19890: ARRAY
19891: IFFALSE 19927
// begin MC_Reset ( i , 121 ) ;
19893: LD_VAR 0 2
19897: PPUSH
19898: LD_INT 121
19900: PPUSH
19901: CALL 5887 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
19905: LD_ADDR_EXP 87
19909: PUSH
19910: LD_EXP 87
19914: PPUSH
19915: LD_VAR 0 2
19919: PPUSH
19920: EMPTY
19921: PPUSH
19922: CALL_OW 1
19926: ST_TO_ADDR
// end ; continue ;
19927: GO 19495
// end ; for j in tmp do
19929: LD_ADDR_VAR 0 3
19933: PUSH
19934: LD_VAR 0 8
19938: PUSH
19939: FOR_IN
19940: IFFALSE 20276
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
19942: LD_VAR 0 3
19946: PUSH
19947: LD_EXP 87
19951: PUSH
19952: LD_VAR 0 2
19956: ARRAY
19957: IN
19958: NOT
19959: PUSH
19960: LD_EXP 87
19964: PUSH
19965: LD_VAR 0 2
19969: ARRAY
19970: PUSH
19971: LD_INT 3
19973: LESS
19974: AND
19975: IFFALSE 20033
// begin SetTag ( j , 121 ) ;
19977: LD_VAR 0 3
19981: PPUSH
19982: LD_INT 121
19984: PPUSH
19985: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
19989: LD_ADDR_EXP 87
19993: PUSH
19994: LD_EXP 87
19998: PPUSH
19999: LD_VAR 0 2
20003: PUSH
20004: LD_EXP 87
20008: PUSH
20009: LD_VAR 0 2
20013: ARRAY
20014: PUSH
20015: LD_INT 1
20017: PLUS
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: PPUSH
20023: LD_VAR 0 3
20027: PPUSH
20028: CALL 37144 0 3
20032: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
20033: LD_VAR 0 3
20037: PUSH
20038: LD_EXP 87
20042: PUSH
20043: LD_VAR 0 2
20047: ARRAY
20048: IN
20049: IFFALSE 20274
// begin if GetClass ( j ) <> 4 then
20051: LD_VAR 0 3
20055: PPUSH
20056: CALL_OW 257
20060: PUSH
20061: LD_INT 4
20063: NONEQUAL
20064: IFFALSE 20117
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
20066: LD_ADDR_EXP 87
20070: PUSH
20071: LD_EXP 87
20075: PPUSH
20076: LD_VAR 0 2
20080: PPUSH
20081: LD_EXP 87
20085: PUSH
20086: LD_VAR 0 2
20090: ARRAY
20091: PUSH
20092: LD_VAR 0 3
20096: DIFF
20097: PPUSH
20098: CALL_OW 1
20102: ST_TO_ADDR
// SetTag ( j , 0 ) ;
20103: LD_VAR 0 3
20107: PPUSH
20108: LD_INT 0
20110: PPUSH
20111: CALL_OW 109
// continue ;
20115: GO 19939
// end ; if IsInUnit ( j ) then
20117: LD_VAR 0 3
20121: PPUSH
20122: CALL_OW 310
20126: IFFALSE 20137
// ComExitBuilding ( j ) ;
20128: LD_VAR 0 3
20132: PPUSH
20133: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
20137: LD_ADDR_VAR 0 6
20141: PUSH
20142: LD_VAR 0 7
20146: PPUSH
20147: LD_VAR 0 3
20151: PPUSH
20152: CALL_OW 74
20156: ST_TO_ADDR
// if not ape then
20157: LD_VAR 0 6
20161: NOT
20162: IFFALSE 20166
// break ;
20164: GO 20276
// x := GetX ( ape ) ;
20166: LD_ADDR_VAR 0 4
20170: PUSH
20171: LD_VAR 0 6
20175: PPUSH
20176: CALL_OW 250
20180: ST_TO_ADDR
// y := GetY ( ape ) ;
20181: LD_ADDR_VAR 0 5
20185: PUSH
20186: LD_VAR 0 6
20190: PPUSH
20191: CALL_OW 251
20195: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
20196: LD_VAR 0 4
20200: PPUSH
20201: LD_VAR 0 5
20205: PPUSH
20206: CALL_OW 488
20210: NOT
20211: PUSH
20212: LD_VAR 0 11
20216: PPUSH
20217: LD_VAR 0 4
20221: PPUSH
20222: LD_VAR 0 5
20226: PPUSH
20227: LD_INT 20
20229: PPUSH
20230: CALL 38040 0 4
20234: PUSH
20235: LD_INT 4
20237: ARRAY
20238: OR
20239: IFFALSE 20243
// break ;
20241: GO 20276
// if not HasTask ( j ) then
20243: LD_VAR 0 3
20247: PPUSH
20248: CALL_OW 314
20252: NOT
20253: IFFALSE 20274
// ComTameXY ( j , x , y ) ;
20255: LD_VAR 0 3
20259: PPUSH
20260: LD_VAR 0 4
20264: PPUSH
20265: LD_VAR 0 5
20269: PPUSH
20270: CALL_OW 131
// end ; end ;
20274: GO 19939
20276: POP
20277: POP
// end ;
20278: GO 19495
20280: POP
20281: POP
// end ;
20282: LD_VAR 0 1
20286: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
20287: LD_INT 0
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
20295: PPUSH
20296: PPUSH
// if not mc_bases then
20297: LD_EXP 56
20301: NOT
20302: IFFALSE 20306
// exit ;
20304: GO 20932
// for i = 1 to mc_bases do
20306: LD_ADDR_VAR 0 2
20310: PUSH
20311: DOUBLE
20312: LD_INT 1
20314: DEC
20315: ST_TO_ADDR
20316: LD_EXP 56
20320: PUSH
20321: FOR_TO
20322: IFFALSE 20930
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
20324: LD_EXP 85
20328: PUSH
20329: LD_VAR 0 2
20333: ARRAY
20334: NOT
20335: PUSH
20336: LD_EXP 85
20340: PUSH
20341: LD_VAR 0 2
20345: ARRAY
20346: PPUSH
20347: LD_INT 25
20349: PUSH
20350: LD_INT 12
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: PPUSH
20357: CALL_OW 72
20361: NOT
20362: OR
20363: IFFALSE 20367
// continue ;
20365: GO 20321
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
20367: LD_ADDR_VAR 0 5
20371: PUSH
20372: LD_EXP 85
20376: PUSH
20377: LD_VAR 0 2
20381: ARRAY
20382: PUSH
20383: LD_INT 1
20385: ARRAY
20386: PPUSH
20387: CALL_OW 255
20391: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
20392: LD_VAR 0 5
20396: PPUSH
20397: LD_INT 2
20399: PPUSH
20400: CALL_OW 325
20404: IFFALSE 20657
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
20406: LD_ADDR_VAR 0 4
20410: PUSH
20411: LD_EXP 85
20415: PUSH
20416: LD_VAR 0 2
20420: ARRAY
20421: PPUSH
20422: LD_INT 25
20424: PUSH
20425: LD_INT 16
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: PPUSH
20432: CALL_OW 72
20436: ST_TO_ADDR
// if tmp < 6 then
20437: LD_VAR 0 4
20441: PUSH
20442: LD_INT 6
20444: LESS
20445: IFFALSE 20657
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
20447: LD_ADDR_VAR 0 6
20451: PUSH
20452: LD_EXP 56
20456: PUSH
20457: LD_VAR 0 2
20461: ARRAY
20462: PPUSH
20463: LD_INT 2
20465: PUSH
20466: LD_INT 30
20468: PUSH
20469: LD_INT 0
20471: PUSH
20472: EMPTY
20473: LIST
20474: LIST
20475: PUSH
20476: LD_INT 30
20478: PUSH
20479: LD_INT 1
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: LIST
20490: PPUSH
20491: CALL_OW 72
20495: ST_TO_ADDR
// if depot then
20496: LD_VAR 0 6
20500: IFFALSE 20657
// begin selected := 0 ;
20502: LD_ADDR_VAR 0 7
20506: PUSH
20507: LD_INT 0
20509: ST_TO_ADDR
// for j in depot do
20510: LD_ADDR_VAR 0 3
20514: PUSH
20515: LD_VAR 0 6
20519: PUSH
20520: FOR_IN
20521: IFFALSE 20552
// begin if UnitsInside ( j ) < 6 then
20523: LD_VAR 0 3
20527: PPUSH
20528: CALL_OW 313
20532: PUSH
20533: LD_INT 6
20535: LESS
20536: IFFALSE 20550
// begin selected := j ;
20538: LD_ADDR_VAR 0 7
20542: PUSH
20543: LD_VAR 0 3
20547: ST_TO_ADDR
// break ;
20548: GO 20552
// end ; end ;
20550: GO 20520
20552: POP
20553: POP
// if selected then
20554: LD_VAR 0 7
20558: IFFALSE 20657
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
20560: LD_ADDR_VAR 0 3
20564: PUSH
20565: LD_EXP 85
20569: PUSH
20570: LD_VAR 0 2
20574: ARRAY
20575: PPUSH
20576: LD_INT 25
20578: PUSH
20579: LD_INT 12
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: PPUSH
20586: CALL_OW 72
20590: PUSH
20591: FOR_IN
20592: IFFALSE 20655
// if not HasTask ( j ) then
20594: LD_VAR 0 3
20598: PPUSH
20599: CALL_OW 314
20603: NOT
20604: IFFALSE 20653
// begin if not IsInUnit ( j ) then
20606: LD_VAR 0 3
20610: PPUSH
20611: CALL_OW 310
20615: NOT
20616: IFFALSE 20632
// ComEnterUnit ( j , selected ) ;
20618: LD_VAR 0 3
20622: PPUSH
20623: LD_VAR 0 7
20627: PPUSH
20628: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
20632: LD_VAR 0 3
20636: PPUSH
20637: LD_INT 16
20639: PPUSH
20640: CALL_OW 183
// AddComExitBuilding ( j ) ;
20644: LD_VAR 0 3
20648: PPUSH
20649: CALL_OW 182
// end ;
20653: GO 20591
20655: POP
20656: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
20657: LD_VAR 0 5
20661: PPUSH
20662: LD_INT 11
20664: PPUSH
20665: CALL_OW 325
20669: IFFALSE 20928
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
20671: LD_ADDR_VAR 0 4
20675: PUSH
20676: LD_EXP 85
20680: PUSH
20681: LD_VAR 0 2
20685: ARRAY
20686: PPUSH
20687: LD_INT 25
20689: PUSH
20690: LD_INT 16
20692: PUSH
20693: EMPTY
20694: LIST
20695: LIST
20696: PPUSH
20697: CALL_OW 72
20701: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
20702: LD_VAR 0 4
20706: PUSH
20707: LD_INT 6
20709: GREATEREQUAL
20710: PUSH
20711: LD_VAR 0 5
20715: PPUSH
20716: LD_INT 2
20718: PPUSH
20719: CALL_OW 325
20723: NOT
20724: OR
20725: IFFALSE 20928
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
20727: LD_ADDR_VAR 0 8
20731: PUSH
20732: LD_EXP 56
20736: PUSH
20737: LD_VAR 0 2
20741: ARRAY
20742: PPUSH
20743: LD_INT 2
20745: PUSH
20746: LD_INT 30
20748: PUSH
20749: LD_INT 4
20751: PUSH
20752: EMPTY
20753: LIST
20754: LIST
20755: PUSH
20756: LD_INT 30
20758: PUSH
20759: LD_INT 5
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: LIST
20770: PPUSH
20771: CALL_OW 72
20775: ST_TO_ADDR
// if barracks then
20776: LD_VAR 0 8
20780: IFFALSE 20928
// begin selected := 0 ;
20782: LD_ADDR_VAR 0 7
20786: PUSH
20787: LD_INT 0
20789: ST_TO_ADDR
// for j in barracks do
20790: LD_ADDR_VAR 0 3
20794: PUSH
20795: LD_VAR 0 8
20799: PUSH
20800: FOR_IN
20801: IFFALSE 20832
// begin if UnitsInside ( j ) < 6 then
20803: LD_VAR 0 3
20807: PPUSH
20808: CALL_OW 313
20812: PUSH
20813: LD_INT 6
20815: LESS
20816: IFFALSE 20830
// begin selected := j ;
20818: LD_ADDR_VAR 0 7
20822: PUSH
20823: LD_VAR 0 3
20827: ST_TO_ADDR
// break ;
20828: GO 20832
// end ; end ;
20830: GO 20800
20832: POP
20833: POP
// if selected then
20834: LD_VAR 0 7
20838: IFFALSE 20928
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
20840: LD_ADDR_VAR 0 3
20844: PUSH
20845: LD_EXP 85
20849: PUSH
20850: LD_VAR 0 2
20854: ARRAY
20855: PPUSH
20856: LD_INT 25
20858: PUSH
20859: LD_INT 12
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: PPUSH
20866: CALL_OW 72
20870: PUSH
20871: FOR_IN
20872: IFFALSE 20926
// if not IsInUnit ( j ) and not HasTask ( j ) then
20874: LD_VAR 0 3
20878: PPUSH
20879: CALL_OW 310
20883: NOT
20884: PUSH
20885: LD_VAR 0 3
20889: PPUSH
20890: CALL_OW 314
20894: NOT
20895: AND
20896: IFFALSE 20924
// begin ComEnterUnit ( j , selected ) ;
20898: LD_VAR 0 3
20902: PPUSH
20903: LD_VAR 0 7
20907: PPUSH
20908: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
20912: LD_VAR 0 3
20916: PPUSH
20917: LD_INT 15
20919: PPUSH
20920: CALL_OW 183
// end ;
20924: GO 20871
20926: POP
20927: POP
// end ; end ; end ; end ; end ;
20928: GO 20321
20930: POP
20931: POP
// end ;
20932: LD_VAR 0 1
20936: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
20937: LD_INT 0
20939: PPUSH
20940: PPUSH
20941: PPUSH
20942: PPUSH
// if not mc_bases then
20943: LD_EXP 56
20947: NOT
20948: IFFALSE 20952
// exit ;
20950: GO 21130
// for i = 1 to mc_bases do
20952: LD_ADDR_VAR 0 2
20956: PUSH
20957: DOUBLE
20958: LD_INT 1
20960: DEC
20961: ST_TO_ADDR
20962: LD_EXP 56
20966: PUSH
20967: FOR_TO
20968: IFFALSE 21128
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
20970: LD_ADDR_VAR 0 4
20974: PUSH
20975: LD_EXP 56
20979: PUSH
20980: LD_VAR 0 2
20984: ARRAY
20985: PPUSH
20986: LD_INT 25
20988: PUSH
20989: LD_INT 9
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: PPUSH
20996: CALL_OW 72
21000: ST_TO_ADDR
// if not tmp then
21001: LD_VAR 0 4
21005: NOT
21006: IFFALSE 21010
// continue ;
21008: GO 20967
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
21010: LD_EXP 82
21014: PUSH
21015: LD_VAR 0 2
21019: ARRAY
21020: PPUSH
21021: LD_INT 29
21023: PPUSH
21024: CALL_OW 325
21028: NOT
21029: PUSH
21030: LD_EXP 82
21034: PUSH
21035: LD_VAR 0 2
21039: ARRAY
21040: PPUSH
21041: LD_INT 28
21043: PPUSH
21044: CALL_OW 325
21048: NOT
21049: AND
21050: IFFALSE 21054
// continue ;
21052: GO 20967
// for j in tmp do
21054: LD_ADDR_VAR 0 3
21058: PUSH
21059: LD_VAR 0 4
21063: PUSH
21064: FOR_IN
21065: IFFALSE 21124
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
21067: LD_VAR 0 3
21071: PUSH
21072: LD_EXP 59
21076: PUSH
21077: LD_VAR 0 2
21081: ARRAY
21082: PUSH
21083: LD_INT 1
21085: ARRAY
21086: IN
21087: NOT
21088: PUSH
21089: LD_VAR 0 3
21093: PUSH
21094: LD_EXP 59
21098: PUSH
21099: LD_VAR 0 2
21103: ARRAY
21104: PUSH
21105: LD_INT 2
21107: ARRAY
21108: IN
21109: NOT
21110: AND
21111: IFFALSE 21122
// ComSpaceTimeShoot ( j ) ;
21113: LD_VAR 0 3
21117: PPUSH
21118: CALL 31204 0 1
21122: GO 21064
21124: POP
21125: POP
// end ;
21126: GO 20967
21128: POP
21129: POP
// end ;
21130: LD_VAR 0 1
21134: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
21135: LD_INT 0
21137: PPUSH
21138: PPUSH
21139: PPUSH
21140: PPUSH
21141: PPUSH
21142: PPUSH
21143: PPUSH
21144: PPUSH
21145: PPUSH
// if not mc_bases then
21146: LD_EXP 56
21150: NOT
21151: IFFALSE 21155
// exit ;
21153: GO 21777
// for i = 1 to mc_bases do
21155: LD_ADDR_VAR 0 2
21159: PUSH
21160: DOUBLE
21161: LD_INT 1
21163: DEC
21164: ST_TO_ADDR
21165: LD_EXP 56
21169: PUSH
21170: FOR_TO
21171: IFFALSE 21775
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
21173: LD_EXP 91
21177: PUSH
21178: LD_VAR 0 2
21182: ARRAY
21183: NOT
21184: PUSH
21185: LD_INT 38
21187: PPUSH
21188: LD_EXP 82
21192: PUSH
21193: LD_VAR 0 2
21197: ARRAY
21198: PPUSH
21199: CALL_OW 321
21203: PUSH
21204: LD_INT 2
21206: NONEQUAL
21207: OR
21208: IFFALSE 21212
// continue ;
21210: GO 21170
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
21212: LD_ADDR_VAR 0 8
21216: PUSH
21217: LD_EXP 56
21221: PUSH
21222: LD_VAR 0 2
21226: ARRAY
21227: PPUSH
21228: LD_INT 30
21230: PUSH
21231: LD_INT 34
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PPUSH
21238: CALL_OW 72
21242: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
21243: LD_ADDR_VAR 0 9
21247: PUSH
21248: LD_EXP 56
21252: PUSH
21253: LD_VAR 0 2
21257: ARRAY
21258: PPUSH
21259: LD_INT 25
21261: PUSH
21262: LD_INT 4
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PPUSH
21269: CALL_OW 72
21273: PPUSH
21274: LD_INT 0
21276: PPUSH
21277: CALL 70341 0 2
21281: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
21282: LD_VAR 0 9
21286: NOT
21287: PUSH
21288: LD_VAR 0 8
21292: NOT
21293: OR
21294: PUSH
21295: LD_EXP 56
21299: PUSH
21300: LD_VAR 0 2
21304: ARRAY
21305: PPUSH
21306: LD_INT 124
21308: PPUSH
21309: CALL 70341 0 2
21313: OR
21314: IFFALSE 21318
// continue ;
21316: GO 21170
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
21318: LD_EXP 92
21322: PUSH
21323: LD_VAR 0 2
21327: ARRAY
21328: PUSH
21329: LD_EXP 91
21333: PUSH
21334: LD_VAR 0 2
21338: ARRAY
21339: LESS
21340: PUSH
21341: LD_EXP 92
21345: PUSH
21346: LD_VAR 0 2
21350: ARRAY
21351: PUSH
21352: LD_VAR 0 8
21356: LESS
21357: AND
21358: IFFALSE 21773
// begin tmp := sci [ 1 ] ;
21360: LD_ADDR_VAR 0 7
21364: PUSH
21365: LD_VAR 0 9
21369: PUSH
21370: LD_INT 1
21372: ARRAY
21373: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
21374: LD_VAR 0 7
21378: PPUSH
21379: LD_INT 124
21381: PPUSH
21382: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
21386: LD_ADDR_VAR 0 3
21390: PUSH
21391: DOUBLE
21392: LD_EXP 91
21396: PUSH
21397: LD_VAR 0 2
21401: ARRAY
21402: INC
21403: ST_TO_ADDR
21404: LD_EXP 91
21408: PUSH
21409: LD_VAR 0 2
21413: ARRAY
21414: PUSH
21415: FOR_DOWNTO
21416: IFFALSE 21759
// begin if IsInUnit ( tmp ) then
21418: LD_VAR 0 7
21422: PPUSH
21423: CALL_OW 310
21427: IFFALSE 21438
// ComExitBuilding ( tmp ) ;
21429: LD_VAR 0 7
21433: PPUSH
21434: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
21438: LD_INT 35
21440: PPUSH
21441: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
21445: LD_VAR 0 7
21449: PPUSH
21450: CALL_OW 310
21454: NOT
21455: PUSH
21456: LD_VAR 0 7
21460: PPUSH
21461: CALL_OW 314
21465: NOT
21466: AND
21467: IFFALSE 21438
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
21469: LD_ADDR_VAR 0 6
21473: PUSH
21474: LD_VAR 0 7
21478: PPUSH
21479: CALL_OW 250
21483: PUSH
21484: LD_VAR 0 7
21488: PPUSH
21489: CALL_OW 251
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21498: LD_INT 35
21500: PPUSH
21501: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
21505: LD_ADDR_VAR 0 4
21509: PUSH
21510: LD_EXP 91
21514: PUSH
21515: LD_VAR 0 2
21519: ARRAY
21520: PUSH
21521: LD_VAR 0 3
21525: ARRAY
21526: PUSH
21527: LD_INT 1
21529: ARRAY
21530: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
21531: LD_ADDR_VAR 0 5
21535: PUSH
21536: LD_EXP 91
21540: PUSH
21541: LD_VAR 0 2
21545: ARRAY
21546: PUSH
21547: LD_VAR 0 3
21551: ARRAY
21552: PUSH
21553: LD_INT 2
21555: ARRAY
21556: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
21557: LD_VAR 0 7
21561: PPUSH
21562: LD_INT 10
21564: PPUSH
21565: CALL 39737 0 2
21569: PUSH
21570: LD_INT 4
21572: ARRAY
21573: IFFALSE 21611
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
21575: LD_VAR 0 7
21579: PPUSH
21580: LD_VAR 0 6
21584: PUSH
21585: LD_INT 1
21587: ARRAY
21588: PPUSH
21589: LD_VAR 0 6
21593: PUSH
21594: LD_INT 2
21596: ARRAY
21597: PPUSH
21598: CALL_OW 111
// wait ( 0 0$10 ) ;
21602: LD_INT 350
21604: PPUSH
21605: CALL_OW 67
// end else
21609: GO 21637
// begin ComMoveXY ( tmp , x , y ) ;
21611: LD_VAR 0 7
21615: PPUSH
21616: LD_VAR 0 4
21620: PPUSH
21621: LD_VAR 0 5
21625: PPUSH
21626: CALL_OW 111
// wait ( 0 0$3 ) ;
21630: LD_INT 105
21632: PPUSH
21633: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
21637: LD_VAR 0 7
21641: PPUSH
21642: LD_VAR 0 4
21646: PPUSH
21647: LD_VAR 0 5
21651: PPUSH
21652: CALL_OW 307
21656: IFFALSE 21498
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
21658: LD_VAR 0 7
21662: PPUSH
21663: LD_VAR 0 4
21667: PPUSH
21668: LD_VAR 0 5
21672: PPUSH
21673: LD_VAR 0 8
21677: PUSH
21678: LD_VAR 0 3
21682: ARRAY
21683: PPUSH
21684: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
21688: LD_INT 35
21690: PPUSH
21691: CALL_OW 67
// until not HasTask ( tmp ) ;
21695: LD_VAR 0 7
21699: PPUSH
21700: CALL_OW 314
21704: NOT
21705: IFFALSE 21688
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
21707: LD_ADDR_EXP 92
21711: PUSH
21712: LD_EXP 92
21716: PPUSH
21717: LD_VAR 0 2
21721: PUSH
21722: LD_EXP 92
21726: PUSH
21727: LD_VAR 0 2
21731: ARRAY
21732: PUSH
21733: LD_INT 1
21735: PLUS
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: LD_VAR 0 8
21745: PUSH
21746: LD_VAR 0 3
21750: ARRAY
21751: PPUSH
21752: CALL 37144 0 3
21756: ST_TO_ADDR
// end ;
21757: GO 21415
21759: POP
21760: POP
// MC_Reset ( i , 124 ) ;
21761: LD_VAR 0 2
21765: PPUSH
21766: LD_INT 124
21768: PPUSH
21769: CALL 5887 0 2
// end ; end ;
21773: GO 21170
21775: POP
21776: POP
// end ;
21777: LD_VAR 0 1
21781: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
21782: LD_INT 0
21784: PPUSH
21785: PPUSH
21786: PPUSH
// if not mc_bases then
21787: LD_EXP 56
21791: NOT
21792: IFFALSE 21796
// exit ;
21794: GO 22402
// for i = 1 to mc_bases do
21796: LD_ADDR_VAR 0 2
21800: PUSH
21801: DOUBLE
21802: LD_INT 1
21804: DEC
21805: ST_TO_ADDR
21806: LD_EXP 56
21810: PUSH
21811: FOR_TO
21812: IFFALSE 22400
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
21814: LD_ADDR_VAR 0 3
21818: PUSH
21819: LD_EXP 56
21823: PUSH
21824: LD_VAR 0 2
21828: ARRAY
21829: PPUSH
21830: LD_INT 25
21832: PUSH
21833: LD_INT 4
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: PPUSH
21840: CALL_OW 72
21844: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21845: LD_VAR 0 3
21849: NOT
21850: PUSH
21851: LD_EXP 93
21855: PUSH
21856: LD_VAR 0 2
21860: ARRAY
21861: NOT
21862: OR
21863: PUSH
21864: LD_EXP 56
21868: PUSH
21869: LD_VAR 0 2
21873: ARRAY
21874: PPUSH
21875: LD_INT 2
21877: PUSH
21878: LD_INT 30
21880: PUSH
21881: LD_INT 0
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: PUSH
21888: LD_INT 30
21890: PUSH
21891: LD_INT 1
21893: PUSH
21894: EMPTY
21895: LIST
21896: LIST
21897: PUSH
21898: EMPTY
21899: LIST
21900: LIST
21901: LIST
21902: PPUSH
21903: CALL_OW 72
21907: NOT
21908: OR
21909: IFFALSE 21959
// begin if mc_deposits_finder [ i ] then
21911: LD_EXP 94
21915: PUSH
21916: LD_VAR 0 2
21920: ARRAY
21921: IFFALSE 21957
// begin MC_Reset ( i , 125 ) ;
21923: LD_VAR 0 2
21927: PPUSH
21928: LD_INT 125
21930: PPUSH
21931: CALL 5887 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21935: LD_ADDR_EXP 94
21939: PUSH
21940: LD_EXP 94
21944: PPUSH
21945: LD_VAR 0 2
21949: PPUSH
21950: EMPTY
21951: PPUSH
21952: CALL_OW 1
21956: ST_TO_ADDR
// end ; continue ;
21957: GO 21811
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
21959: LD_EXP 93
21963: PUSH
21964: LD_VAR 0 2
21968: ARRAY
21969: PUSH
21970: LD_INT 1
21972: ARRAY
21973: PUSH
21974: LD_INT 3
21976: ARRAY
21977: PUSH
21978: LD_INT 1
21980: EQUAL
21981: PUSH
21982: LD_INT 20
21984: PPUSH
21985: LD_EXP 82
21989: PUSH
21990: LD_VAR 0 2
21994: ARRAY
21995: PPUSH
21996: CALL_OW 321
22000: PUSH
22001: LD_INT 2
22003: NONEQUAL
22004: AND
22005: IFFALSE 22055
// begin if mc_deposits_finder [ i ] then
22007: LD_EXP 94
22011: PUSH
22012: LD_VAR 0 2
22016: ARRAY
22017: IFFALSE 22053
// begin MC_Reset ( i , 125 ) ;
22019: LD_VAR 0 2
22023: PPUSH
22024: LD_INT 125
22026: PPUSH
22027: CALL 5887 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
22031: LD_ADDR_EXP 94
22035: PUSH
22036: LD_EXP 94
22040: PPUSH
22041: LD_VAR 0 2
22045: PPUSH
22046: EMPTY
22047: PPUSH
22048: CALL_OW 1
22052: ST_TO_ADDR
// end ; continue ;
22053: GO 21811
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
22055: LD_EXP 93
22059: PUSH
22060: LD_VAR 0 2
22064: ARRAY
22065: PUSH
22066: LD_INT 1
22068: ARRAY
22069: PUSH
22070: LD_INT 1
22072: ARRAY
22073: PPUSH
22074: LD_EXP 93
22078: PUSH
22079: LD_VAR 0 2
22083: ARRAY
22084: PUSH
22085: LD_INT 1
22087: ARRAY
22088: PUSH
22089: LD_INT 2
22091: ARRAY
22092: PPUSH
22093: LD_EXP 82
22097: PUSH
22098: LD_VAR 0 2
22102: ARRAY
22103: PPUSH
22104: CALL_OW 440
22108: IFFALSE 22151
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
22110: LD_ADDR_EXP 93
22114: PUSH
22115: LD_EXP 93
22119: PPUSH
22120: LD_VAR 0 2
22124: PPUSH
22125: LD_EXP 93
22129: PUSH
22130: LD_VAR 0 2
22134: ARRAY
22135: PPUSH
22136: LD_INT 1
22138: PPUSH
22139: CALL_OW 3
22143: PPUSH
22144: CALL_OW 1
22148: ST_TO_ADDR
22149: GO 22398
// begin if not mc_deposits_finder [ i ] then
22151: LD_EXP 94
22155: PUSH
22156: LD_VAR 0 2
22160: ARRAY
22161: NOT
22162: IFFALSE 22214
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
22164: LD_ADDR_EXP 94
22168: PUSH
22169: LD_EXP 94
22173: PPUSH
22174: LD_VAR 0 2
22178: PPUSH
22179: LD_VAR 0 3
22183: PUSH
22184: LD_INT 1
22186: ARRAY
22187: PUSH
22188: EMPTY
22189: LIST
22190: PPUSH
22191: CALL_OW 1
22195: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
22196: LD_VAR 0 3
22200: PUSH
22201: LD_INT 1
22203: ARRAY
22204: PPUSH
22205: LD_INT 125
22207: PPUSH
22208: CALL_OW 109
// end else
22212: GO 22398
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
22214: LD_EXP 94
22218: PUSH
22219: LD_VAR 0 2
22223: ARRAY
22224: PUSH
22225: LD_INT 1
22227: ARRAY
22228: PPUSH
22229: CALL_OW 310
22233: IFFALSE 22256
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
22235: LD_EXP 94
22239: PUSH
22240: LD_VAR 0 2
22244: ARRAY
22245: PUSH
22246: LD_INT 1
22248: ARRAY
22249: PPUSH
22250: CALL_OW 122
22254: GO 22398
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
22256: LD_EXP 94
22260: PUSH
22261: LD_VAR 0 2
22265: ARRAY
22266: PUSH
22267: LD_INT 1
22269: ARRAY
22270: PPUSH
22271: CALL_OW 314
22275: NOT
22276: PUSH
22277: LD_EXP 94
22281: PUSH
22282: LD_VAR 0 2
22286: ARRAY
22287: PUSH
22288: LD_INT 1
22290: ARRAY
22291: PPUSH
22292: LD_EXP 93
22296: PUSH
22297: LD_VAR 0 2
22301: ARRAY
22302: PUSH
22303: LD_INT 1
22305: ARRAY
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PPUSH
22311: LD_EXP 93
22315: PUSH
22316: LD_VAR 0 2
22320: ARRAY
22321: PUSH
22322: LD_INT 1
22324: ARRAY
22325: PUSH
22326: LD_INT 2
22328: ARRAY
22329: PPUSH
22330: CALL_OW 297
22334: PUSH
22335: LD_INT 6
22337: GREATER
22338: AND
22339: IFFALSE 22398
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
22341: LD_EXP 94
22345: PUSH
22346: LD_VAR 0 2
22350: ARRAY
22351: PUSH
22352: LD_INT 1
22354: ARRAY
22355: PPUSH
22356: LD_EXP 93
22360: PUSH
22361: LD_VAR 0 2
22365: ARRAY
22366: PUSH
22367: LD_INT 1
22369: ARRAY
22370: PUSH
22371: LD_INT 1
22373: ARRAY
22374: PPUSH
22375: LD_EXP 93
22379: PUSH
22380: LD_VAR 0 2
22384: ARRAY
22385: PUSH
22386: LD_INT 1
22388: ARRAY
22389: PUSH
22390: LD_INT 2
22392: ARRAY
22393: PPUSH
22394: CALL_OW 111
// end ; end ; end ;
22398: GO 21811
22400: POP
22401: POP
// end ;
22402: LD_VAR 0 1
22406: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
22407: LD_INT 0
22409: PPUSH
22410: PPUSH
22411: PPUSH
22412: PPUSH
22413: PPUSH
22414: PPUSH
22415: PPUSH
22416: PPUSH
22417: PPUSH
22418: PPUSH
22419: PPUSH
// if not mc_bases then
22420: LD_EXP 56
22424: NOT
22425: IFFALSE 22429
// exit ;
22427: GO 23153
// for i = 1 to mc_bases do
22429: LD_ADDR_VAR 0 2
22433: PUSH
22434: DOUBLE
22435: LD_INT 1
22437: DEC
22438: ST_TO_ADDR
22439: LD_EXP 56
22443: PUSH
22444: FOR_TO
22445: IFFALSE 23151
// begin if not mc_bases [ i ] then
22447: LD_EXP 56
22451: PUSH
22452: LD_VAR 0 2
22456: ARRAY
22457: NOT
22458: IFFALSE 22462
// continue ;
22460: GO 22444
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
22462: LD_ADDR_VAR 0 7
22466: PUSH
22467: LD_EXP 56
22471: PUSH
22472: LD_VAR 0 2
22476: ARRAY
22477: PUSH
22478: LD_INT 1
22480: ARRAY
22481: PPUSH
22482: CALL_OW 248
22486: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
22487: LD_VAR 0 7
22491: PUSH
22492: LD_INT 3
22494: EQUAL
22495: PUSH
22496: LD_EXP 75
22500: PUSH
22501: LD_VAR 0 2
22505: ARRAY
22506: PUSH
22507: LD_EXP 78
22511: PUSH
22512: LD_VAR 0 2
22516: ARRAY
22517: UNION
22518: PPUSH
22519: LD_INT 33
22521: PUSH
22522: LD_INT 2
22524: PUSH
22525: EMPTY
22526: LIST
22527: LIST
22528: PPUSH
22529: CALL_OW 72
22533: NOT
22534: OR
22535: IFFALSE 22539
// continue ;
22537: GO 22444
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
22539: LD_ADDR_VAR 0 9
22543: PUSH
22544: LD_EXP 56
22548: PUSH
22549: LD_VAR 0 2
22553: ARRAY
22554: PPUSH
22555: LD_INT 30
22557: PUSH
22558: LD_INT 36
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PPUSH
22565: CALL_OW 72
22569: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
22570: LD_ADDR_VAR 0 10
22574: PUSH
22575: LD_EXP 75
22579: PUSH
22580: LD_VAR 0 2
22584: ARRAY
22585: PPUSH
22586: LD_INT 34
22588: PUSH
22589: LD_INT 31
22591: PUSH
22592: EMPTY
22593: LIST
22594: LIST
22595: PPUSH
22596: CALL_OW 72
22600: ST_TO_ADDR
// if not cts and not mcts then
22601: LD_VAR 0 9
22605: NOT
22606: PUSH
22607: LD_VAR 0 10
22611: NOT
22612: AND
22613: IFFALSE 22617
// continue ;
22615: GO 22444
// x := cts ;
22617: LD_ADDR_VAR 0 11
22621: PUSH
22622: LD_VAR 0 9
22626: ST_TO_ADDR
// if not x then
22627: LD_VAR 0 11
22631: NOT
22632: IFFALSE 22644
// x := mcts ;
22634: LD_ADDR_VAR 0 11
22638: PUSH
22639: LD_VAR 0 10
22643: ST_TO_ADDR
// if mc_remote_driver [ i ] then
22644: LD_EXP 96
22648: PUSH
22649: LD_VAR 0 2
22653: ARRAY
22654: IFFALSE 22923
// for j in mc_remote_driver [ i ] do
22656: LD_ADDR_VAR 0 3
22660: PUSH
22661: LD_EXP 96
22665: PUSH
22666: LD_VAR 0 2
22670: ARRAY
22671: PUSH
22672: FOR_IN
22673: IFFALSE 22921
// begin if GetClass ( j ) <> 3 then
22675: LD_VAR 0 3
22679: PPUSH
22680: CALL_OW 257
22684: PUSH
22685: LD_INT 3
22687: NONEQUAL
22688: IFFALSE 22741
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
22690: LD_ADDR_EXP 96
22694: PUSH
22695: LD_EXP 96
22699: PPUSH
22700: LD_VAR 0 2
22704: PPUSH
22705: LD_EXP 96
22709: PUSH
22710: LD_VAR 0 2
22714: ARRAY
22715: PUSH
22716: LD_VAR 0 3
22720: DIFF
22721: PPUSH
22722: CALL_OW 1
22726: ST_TO_ADDR
// SetTag ( j , 0 ) ;
22727: LD_VAR 0 3
22731: PPUSH
22732: LD_INT 0
22734: PPUSH
22735: CALL_OW 109
// continue ;
22739: GO 22672
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
22741: LD_VAR 0 3
22745: PPUSH
22746: CALL_OW 310
22750: NOT
22751: PUSH
22752: LD_VAR 0 3
22756: PPUSH
22757: CALL_OW 310
22761: PPUSH
22762: CALL_OW 266
22766: PUSH
22767: LD_INT 36
22769: NONEQUAL
22770: PUSH
22771: LD_VAR 0 3
22775: PPUSH
22776: CALL 70429 0 1
22780: NOT
22781: AND
22782: OR
22783: IFFALSE 22919
// begin if IsInUnit ( j ) then
22785: LD_VAR 0 3
22789: PPUSH
22790: CALL_OW 310
22794: IFFALSE 22805
// ComExitBuilding ( j ) ;
22796: LD_VAR 0 3
22800: PPUSH
22801: CALL_OW 122
// ct := 0 ;
22805: LD_ADDR_VAR 0 8
22809: PUSH
22810: LD_INT 0
22812: ST_TO_ADDR
// for k in x do
22813: LD_ADDR_VAR 0 4
22817: PUSH
22818: LD_VAR 0 11
22822: PUSH
22823: FOR_IN
22824: IFFALSE 22897
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
22826: LD_VAR 0 4
22830: PPUSH
22831: CALL_OW 264
22835: PUSH
22836: LD_INT 31
22838: EQUAL
22839: PUSH
22840: LD_VAR 0 4
22844: PPUSH
22845: CALL_OW 311
22849: NOT
22850: AND
22851: PUSH
22852: LD_VAR 0 4
22856: PPUSH
22857: CALL_OW 266
22861: PUSH
22862: LD_INT 36
22864: EQUAL
22865: PUSH
22866: LD_VAR 0 4
22870: PPUSH
22871: CALL_OW 313
22875: PUSH
22876: LD_INT 3
22878: LESS
22879: AND
22880: OR
22881: IFFALSE 22895
// begin ct := k ;
22883: LD_ADDR_VAR 0 8
22887: PUSH
22888: LD_VAR 0 4
22892: ST_TO_ADDR
// break ;
22893: GO 22897
// end ;
22895: GO 22823
22897: POP
22898: POP
// if ct then
22899: LD_VAR 0 8
22903: IFFALSE 22919
// ComEnterUnit ( j , ct ) ;
22905: LD_VAR 0 3
22909: PPUSH
22910: LD_VAR 0 8
22914: PPUSH
22915: CALL_OW 120
// end ; end ;
22919: GO 22672
22921: POP
22922: POP
// places := 0 ;
22923: LD_ADDR_VAR 0 5
22927: PUSH
22928: LD_INT 0
22930: ST_TO_ADDR
// for j = 1 to x do
22931: LD_ADDR_VAR 0 3
22935: PUSH
22936: DOUBLE
22937: LD_INT 1
22939: DEC
22940: ST_TO_ADDR
22941: LD_VAR 0 11
22945: PUSH
22946: FOR_TO
22947: IFFALSE 23002
// if GetWeapon ( x [ j ] ) = ar_control_tower then
22949: LD_VAR 0 11
22953: PUSH
22954: LD_VAR 0 3
22958: ARRAY
22959: PPUSH
22960: CALL_OW 264
22964: PUSH
22965: LD_INT 31
22967: EQUAL
22968: IFFALSE 22986
// places := places + 1 else
22970: LD_ADDR_VAR 0 5
22974: PUSH
22975: LD_VAR 0 5
22979: PUSH
22980: LD_INT 1
22982: PLUS
22983: ST_TO_ADDR
22984: GO 23000
// places := places + 3 ;
22986: LD_ADDR_VAR 0 5
22990: PUSH
22991: LD_VAR 0 5
22995: PUSH
22996: LD_INT 3
22998: PLUS
22999: ST_TO_ADDR
23000: GO 22946
23002: POP
23003: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
23004: LD_ADDR_VAR 0 6
23008: PUSH
23009: LD_EXP 56
23013: PUSH
23014: LD_VAR 0 2
23018: ARRAY
23019: PPUSH
23020: LD_INT 25
23022: PUSH
23023: LD_INT 3
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL_OW 72
23034: PUSH
23035: LD_EXP 96
23039: PUSH
23040: LD_VAR 0 2
23044: ARRAY
23045: DIFF
23046: PPUSH
23047: LD_INT 3
23049: PPUSH
23050: CALL 71329 0 2
23054: ST_TO_ADDR
// if not tmp then
23055: LD_VAR 0 6
23059: NOT
23060: IFFALSE 23064
// continue ;
23062: GO 22444
// places := places - mc_remote_driver [ i ] ;
23064: LD_ADDR_VAR 0 5
23068: PUSH
23069: LD_VAR 0 5
23073: PUSH
23074: LD_EXP 96
23078: PUSH
23079: LD_VAR 0 2
23083: ARRAY
23084: MINUS
23085: ST_TO_ADDR
// if places then
23086: LD_VAR 0 5
23090: IFFALSE 23149
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
23092: LD_ADDR_EXP 96
23096: PUSH
23097: LD_EXP 96
23101: PPUSH
23102: LD_VAR 0 2
23106: PPUSH
23107: LD_EXP 96
23111: PUSH
23112: LD_VAR 0 2
23116: ARRAY
23117: PUSH
23118: LD_VAR 0 6
23122: PUSH
23123: LD_INT 1
23125: ARRAY
23126: UNION
23127: PPUSH
23128: CALL_OW 1
23132: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
23133: LD_VAR 0 6
23137: PUSH
23138: LD_INT 1
23140: ARRAY
23141: PPUSH
23142: LD_INT 126
23144: PPUSH
23145: CALL_OW 109
// end ; end ;
23149: GO 22444
23151: POP
23152: POP
// end ;
23153: LD_VAR 0 1
23157: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
23158: LD_INT 0
23160: PPUSH
23161: PPUSH
23162: PPUSH
23163: PPUSH
23164: PPUSH
23165: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
23166: LD_VAR 0 1
23170: NOT
23171: PUSH
23172: LD_VAR 0 2
23176: NOT
23177: OR
23178: PUSH
23179: LD_VAR 0 3
23183: NOT
23184: OR
23185: PUSH
23186: LD_VAR 0 4
23190: PUSH
23191: LD_INT 1
23193: PUSH
23194: LD_INT 2
23196: PUSH
23197: LD_INT 3
23199: PUSH
23200: LD_INT 4
23202: PUSH
23203: LD_INT 5
23205: PUSH
23206: LD_INT 8
23208: PUSH
23209: LD_INT 9
23211: PUSH
23212: LD_INT 15
23214: PUSH
23215: LD_INT 16
23217: PUSH
23218: EMPTY
23219: LIST
23220: LIST
23221: LIST
23222: LIST
23223: LIST
23224: LIST
23225: LIST
23226: LIST
23227: LIST
23228: IN
23229: NOT
23230: OR
23231: IFFALSE 23235
// exit ;
23233: GO 24135
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
23235: LD_ADDR_VAR 0 2
23239: PUSH
23240: LD_VAR 0 2
23244: PPUSH
23245: LD_INT 21
23247: PUSH
23248: LD_INT 3
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: PUSH
23255: LD_INT 24
23257: PUSH
23258: LD_INT 250
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PPUSH
23269: CALL_OW 72
23273: ST_TO_ADDR
// case class of 1 , 15 :
23274: LD_VAR 0 4
23278: PUSH
23279: LD_INT 1
23281: DOUBLE
23282: EQUAL
23283: IFTRUE 23293
23285: LD_INT 15
23287: DOUBLE
23288: EQUAL
23289: IFTRUE 23293
23291: GO 23378
23293: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
23294: LD_ADDR_VAR 0 8
23298: PUSH
23299: LD_VAR 0 2
23303: PPUSH
23304: LD_INT 2
23306: PUSH
23307: LD_INT 30
23309: PUSH
23310: LD_INT 32
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PUSH
23317: LD_INT 30
23319: PUSH
23320: LD_INT 31
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: PUSH
23327: EMPTY
23328: LIST
23329: LIST
23330: LIST
23331: PPUSH
23332: CALL_OW 72
23336: PUSH
23337: LD_VAR 0 2
23341: PPUSH
23342: LD_INT 2
23344: PUSH
23345: LD_INT 30
23347: PUSH
23348: LD_INT 4
23350: PUSH
23351: EMPTY
23352: LIST
23353: LIST
23354: PUSH
23355: LD_INT 30
23357: PUSH
23358: LD_INT 5
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: LIST
23369: PPUSH
23370: CALL_OW 72
23374: ADD
23375: ST_TO_ADDR
23376: GO 23624
23378: LD_INT 2
23380: DOUBLE
23381: EQUAL
23382: IFTRUE 23392
23384: LD_INT 16
23386: DOUBLE
23387: EQUAL
23388: IFTRUE 23392
23390: GO 23438
23392: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
23393: LD_ADDR_VAR 0 8
23397: PUSH
23398: LD_VAR 0 2
23402: PPUSH
23403: LD_INT 2
23405: PUSH
23406: LD_INT 30
23408: PUSH
23409: LD_INT 0
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: PUSH
23416: LD_INT 30
23418: PUSH
23419: LD_INT 1
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: PUSH
23426: EMPTY
23427: LIST
23428: LIST
23429: LIST
23430: PPUSH
23431: CALL_OW 72
23435: ST_TO_ADDR
23436: GO 23624
23438: LD_INT 3
23440: DOUBLE
23441: EQUAL
23442: IFTRUE 23446
23444: GO 23492
23446: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
23447: LD_ADDR_VAR 0 8
23451: PUSH
23452: LD_VAR 0 2
23456: PPUSH
23457: LD_INT 2
23459: PUSH
23460: LD_INT 30
23462: PUSH
23463: LD_INT 2
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: PUSH
23470: LD_INT 30
23472: PUSH
23473: LD_INT 3
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: PPUSH
23485: CALL_OW 72
23489: ST_TO_ADDR
23490: GO 23624
23492: LD_INT 4
23494: DOUBLE
23495: EQUAL
23496: IFTRUE 23500
23498: GO 23557
23500: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
23501: LD_ADDR_VAR 0 8
23505: PUSH
23506: LD_VAR 0 2
23510: PPUSH
23511: LD_INT 2
23513: PUSH
23514: LD_INT 30
23516: PUSH
23517: LD_INT 6
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: PUSH
23524: LD_INT 30
23526: PUSH
23527: LD_INT 7
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 30
23536: PUSH
23537: LD_INT 8
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: PPUSH
23550: CALL_OW 72
23554: ST_TO_ADDR
23555: GO 23624
23557: LD_INT 5
23559: DOUBLE
23560: EQUAL
23561: IFTRUE 23577
23563: LD_INT 8
23565: DOUBLE
23566: EQUAL
23567: IFTRUE 23577
23569: LD_INT 9
23571: DOUBLE
23572: EQUAL
23573: IFTRUE 23577
23575: GO 23623
23577: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
23578: LD_ADDR_VAR 0 8
23582: PUSH
23583: LD_VAR 0 2
23587: PPUSH
23588: LD_INT 2
23590: PUSH
23591: LD_INT 30
23593: PUSH
23594: LD_INT 4
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: LD_INT 30
23603: PUSH
23604: LD_INT 5
23606: PUSH
23607: EMPTY
23608: LIST
23609: LIST
23610: PUSH
23611: EMPTY
23612: LIST
23613: LIST
23614: LIST
23615: PPUSH
23616: CALL_OW 72
23620: ST_TO_ADDR
23621: GO 23624
23623: POP
// if not tmp then
23624: LD_VAR 0 8
23628: NOT
23629: IFFALSE 23633
// exit ;
23631: GO 24135
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
23633: LD_VAR 0 4
23637: PUSH
23638: LD_INT 1
23640: PUSH
23641: LD_INT 15
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: IN
23648: PUSH
23649: LD_EXP 65
23653: PUSH
23654: LD_VAR 0 1
23658: ARRAY
23659: AND
23660: IFFALSE 23816
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
23662: LD_ADDR_VAR 0 9
23666: PUSH
23667: LD_EXP 65
23671: PUSH
23672: LD_VAR 0 1
23676: ARRAY
23677: PUSH
23678: LD_INT 1
23680: ARRAY
23681: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
23682: LD_VAR 0 9
23686: PUSH
23687: LD_EXP 66
23691: PUSH
23692: LD_VAR 0 1
23696: ARRAY
23697: IN
23698: NOT
23699: IFFALSE 23814
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
23701: LD_ADDR_EXP 66
23705: PUSH
23706: LD_EXP 66
23710: PPUSH
23711: LD_VAR 0 1
23715: PUSH
23716: LD_EXP 66
23720: PUSH
23721: LD_VAR 0 1
23725: ARRAY
23726: PUSH
23727: LD_INT 1
23729: PLUS
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PPUSH
23735: LD_VAR 0 9
23739: PPUSH
23740: CALL 37144 0 3
23744: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
23745: LD_ADDR_EXP 65
23749: PUSH
23750: LD_EXP 65
23754: PPUSH
23755: LD_VAR 0 1
23759: PPUSH
23760: LD_EXP 65
23764: PUSH
23765: LD_VAR 0 1
23769: ARRAY
23770: PUSH
23771: LD_VAR 0 9
23775: DIFF
23776: PPUSH
23777: CALL_OW 1
23781: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
23782: LD_VAR 0 3
23786: PPUSH
23787: LD_EXP 66
23791: PUSH
23792: LD_VAR 0 1
23796: ARRAY
23797: PUSH
23798: LD_EXP 66
23802: PUSH
23803: LD_VAR 0 1
23807: ARRAY
23808: ARRAY
23809: PPUSH
23810: CALL_OW 120
// end ; exit ;
23814: GO 24135
// end ; if tmp > 1 then
23816: LD_VAR 0 8
23820: PUSH
23821: LD_INT 1
23823: GREATER
23824: IFFALSE 23928
// for i = 2 to tmp do
23826: LD_ADDR_VAR 0 6
23830: PUSH
23831: DOUBLE
23832: LD_INT 2
23834: DEC
23835: ST_TO_ADDR
23836: LD_VAR 0 8
23840: PUSH
23841: FOR_TO
23842: IFFALSE 23926
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
23844: LD_VAR 0 8
23848: PUSH
23849: LD_VAR 0 6
23853: ARRAY
23854: PPUSH
23855: CALL_OW 461
23859: PUSH
23860: LD_INT 6
23862: EQUAL
23863: IFFALSE 23924
// begin x := tmp [ i ] ;
23865: LD_ADDR_VAR 0 9
23869: PUSH
23870: LD_VAR 0 8
23874: PUSH
23875: LD_VAR 0 6
23879: ARRAY
23880: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
23881: LD_ADDR_VAR 0 8
23885: PUSH
23886: LD_VAR 0 8
23890: PPUSH
23891: LD_VAR 0 6
23895: PPUSH
23896: CALL_OW 3
23900: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
23901: LD_ADDR_VAR 0 8
23905: PUSH
23906: LD_VAR 0 8
23910: PPUSH
23911: LD_INT 1
23913: PPUSH
23914: LD_VAR 0 9
23918: PPUSH
23919: CALL_OW 2
23923: ST_TO_ADDR
// end ;
23924: GO 23841
23926: POP
23927: POP
// for i in tmp do
23928: LD_ADDR_VAR 0 6
23932: PUSH
23933: LD_VAR 0 8
23937: PUSH
23938: FOR_IN
23939: IFFALSE 24008
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
23941: LD_VAR 0 6
23945: PPUSH
23946: CALL_OW 313
23950: PUSH
23951: LD_INT 6
23953: LESS
23954: PUSH
23955: LD_VAR 0 6
23959: PPUSH
23960: CALL_OW 266
23964: PUSH
23965: LD_INT 31
23967: PUSH
23968: LD_INT 32
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: IN
23975: NOT
23976: AND
23977: PUSH
23978: LD_VAR 0 6
23982: PPUSH
23983: CALL_OW 313
23987: PUSH
23988: LD_INT 0
23990: EQUAL
23991: OR
23992: IFFALSE 24006
// begin j := i ;
23994: LD_ADDR_VAR 0 7
23998: PUSH
23999: LD_VAR 0 6
24003: ST_TO_ADDR
// break ;
24004: GO 24008
// end ; end ;
24006: GO 23938
24008: POP
24009: POP
// if j then
24010: LD_VAR 0 7
24014: IFFALSE 24032
// ComEnterUnit ( unit , j ) else
24016: LD_VAR 0 3
24020: PPUSH
24021: LD_VAR 0 7
24025: PPUSH
24026: CALL_OW 120
24030: GO 24135
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
24032: LD_ADDR_VAR 0 10
24036: PUSH
24037: LD_VAR 0 2
24041: PPUSH
24042: LD_INT 2
24044: PUSH
24045: LD_INT 30
24047: PUSH
24048: LD_INT 0
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 30
24057: PUSH
24058: LD_INT 1
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: LIST
24069: PPUSH
24070: CALL_OW 72
24074: ST_TO_ADDR
// if depot then
24075: LD_VAR 0 10
24079: IFFALSE 24135
// begin depot := NearestUnitToUnit ( depot , unit ) ;
24081: LD_ADDR_VAR 0 10
24085: PUSH
24086: LD_VAR 0 10
24090: PPUSH
24091: LD_VAR 0 3
24095: PPUSH
24096: CALL_OW 74
24100: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
24101: LD_VAR 0 3
24105: PPUSH
24106: LD_VAR 0 10
24110: PPUSH
24111: CALL_OW 296
24115: PUSH
24116: LD_INT 10
24118: GREATER
24119: IFFALSE 24135
// ComStandNearbyBuilding ( unit , depot ) ;
24121: LD_VAR 0 3
24125: PPUSH
24126: LD_VAR 0 10
24130: PPUSH
24131: CALL 31821 0 2
// end ; end ; end ;
24135: LD_VAR 0 5
24139: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
24140: LD_INT 0
24142: PPUSH
24143: PPUSH
24144: PPUSH
24145: PPUSH
// if not mc_bases then
24146: LD_EXP 56
24150: NOT
24151: IFFALSE 24155
// exit ;
24153: GO 24394
// for i = 1 to mc_bases do
24155: LD_ADDR_VAR 0 2
24159: PUSH
24160: DOUBLE
24161: LD_INT 1
24163: DEC
24164: ST_TO_ADDR
24165: LD_EXP 56
24169: PUSH
24170: FOR_TO
24171: IFFALSE 24392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
24173: LD_ADDR_VAR 0 4
24177: PUSH
24178: LD_EXP 56
24182: PUSH
24183: LD_VAR 0 2
24187: ARRAY
24188: PPUSH
24189: LD_INT 21
24191: PUSH
24192: LD_INT 1
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PPUSH
24199: CALL_OW 72
24203: PUSH
24204: LD_EXP 85
24208: PUSH
24209: LD_VAR 0 2
24213: ARRAY
24214: UNION
24215: ST_TO_ADDR
// if not tmp then
24216: LD_VAR 0 4
24220: NOT
24221: IFFALSE 24225
// continue ;
24223: GO 24170
// for j in tmp do
24225: LD_ADDR_VAR 0 3
24229: PUSH
24230: LD_VAR 0 4
24234: PUSH
24235: FOR_IN
24236: IFFALSE 24388
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
24238: LD_VAR 0 3
24242: PPUSH
24243: CALL_OW 110
24247: NOT
24248: PUSH
24249: LD_VAR 0 3
24253: PPUSH
24254: CALL_OW 314
24258: NOT
24259: AND
24260: PUSH
24261: LD_VAR 0 3
24265: PPUSH
24266: CALL_OW 311
24270: NOT
24271: AND
24272: PUSH
24273: LD_VAR 0 3
24277: PPUSH
24278: CALL_OW 310
24282: NOT
24283: AND
24284: PUSH
24285: LD_VAR 0 3
24289: PUSH
24290: LD_EXP 59
24294: PUSH
24295: LD_VAR 0 2
24299: ARRAY
24300: PUSH
24301: LD_INT 1
24303: ARRAY
24304: IN
24305: NOT
24306: AND
24307: PUSH
24308: LD_VAR 0 3
24312: PUSH
24313: LD_EXP 59
24317: PUSH
24318: LD_VAR 0 2
24322: ARRAY
24323: PUSH
24324: LD_INT 2
24326: ARRAY
24327: IN
24328: NOT
24329: AND
24330: PUSH
24331: LD_VAR 0 3
24335: PUSH
24336: LD_EXP 68
24340: PUSH
24341: LD_VAR 0 2
24345: ARRAY
24346: IN
24347: NOT
24348: AND
24349: IFFALSE 24386
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
24351: LD_VAR 0 2
24355: PPUSH
24356: LD_EXP 56
24360: PUSH
24361: LD_VAR 0 2
24365: ARRAY
24366: PPUSH
24367: LD_VAR 0 3
24371: PPUSH
24372: LD_VAR 0 3
24376: PPUSH
24377: CALL_OW 257
24381: PPUSH
24382: CALL 23158 0 4
// end ;
24386: GO 24235
24388: POP
24389: POP
// end ;
24390: GO 24170
24392: POP
24393: POP
// end ;
24394: LD_VAR 0 1
24398: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
24399: LD_INT 0
24401: PPUSH
24402: PPUSH
24403: PPUSH
24404: PPUSH
24405: PPUSH
24406: PPUSH
// if not mc_bases [ base ] then
24407: LD_EXP 56
24411: PUSH
24412: LD_VAR 0 1
24416: ARRAY
24417: NOT
24418: IFFALSE 24422
// exit ;
24420: GO 24604
// tmp := [ ] ;
24422: LD_ADDR_VAR 0 6
24426: PUSH
24427: EMPTY
24428: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
24429: LD_ADDR_VAR 0 7
24433: PUSH
24434: LD_VAR 0 3
24438: PPUSH
24439: LD_INT 0
24441: PPUSH
24442: CALL_OW 517
24446: ST_TO_ADDR
// if not list then
24447: LD_VAR 0 7
24451: NOT
24452: IFFALSE 24456
// exit ;
24454: GO 24604
// for i = 1 to amount do
24456: LD_ADDR_VAR 0 5
24460: PUSH
24461: DOUBLE
24462: LD_INT 1
24464: DEC
24465: ST_TO_ADDR
24466: LD_VAR 0 2
24470: PUSH
24471: FOR_TO
24472: IFFALSE 24552
// begin x := rand ( 1 , list [ 1 ] ) ;
24474: LD_ADDR_VAR 0 8
24478: PUSH
24479: LD_INT 1
24481: PPUSH
24482: LD_VAR 0 7
24486: PUSH
24487: LD_INT 1
24489: ARRAY
24490: PPUSH
24491: CALL_OW 12
24495: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
24496: LD_ADDR_VAR 0 6
24500: PUSH
24501: LD_VAR 0 6
24505: PPUSH
24506: LD_VAR 0 5
24510: PPUSH
24511: LD_VAR 0 7
24515: PUSH
24516: LD_INT 1
24518: ARRAY
24519: PUSH
24520: LD_VAR 0 8
24524: ARRAY
24525: PUSH
24526: LD_VAR 0 7
24530: PUSH
24531: LD_INT 2
24533: ARRAY
24534: PUSH
24535: LD_VAR 0 8
24539: ARRAY
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PPUSH
24545: CALL_OW 1
24549: ST_TO_ADDR
// end ;
24550: GO 24471
24552: POP
24553: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
24554: LD_ADDR_EXP 69
24558: PUSH
24559: LD_EXP 69
24563: PPUSH
24564: LD_VAR 0 1
24568: PPUSH
24569: LD_VAR 0 6
24573: PPUSH
24574: CALL_OW 1
24578: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
24579: LD_ADDR_EXP 71
24583: PUSH
24584: LD_EXP 71
24588: PPUSH
24589: LD_VAR 0 1
24593: PPUSH
24594: LD_VAR 0 3
24598: PPUSH
24599: CALL_OW 1
24603: ST_TO_ADDR
// end ;
24604: LD_VAR 0 4
24608: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
24609: LD_INT 0
24611: PPUSH
// if not mc_bases [ base ] then
24612: LD_EXP 56
24616: PUSH
24617: LD_VAR 0 1
24621: ARRAY
24622: NOT
24623: IFFALSE 24627
// exit ;
24625: GO 24652
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
24627: LD_ADDR_EXP 61
24631: PUSH
24632: LD_EXP 61
24636: PPUSH
24637: LD_VAR 0 1
24641: PPUSH
24642: LD_VAR 0 2
24646: PPUSH
24647: CALL_OW 1
24651: ST_TO_ADDR
// end ;
24652: LD_VAR 0 3
24656: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
24657: LD_INT 0
24659: PPUSH
// if not mc_bases [ base ] then
24660: LD_EXP 56
24664: PUSH
24665: LD_VAR 0 1
24669: ARRAY
24670: NOT
24671: IFFALSE 24675
// exit ;
24673: GO 24712
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
24675: LD_ADDR_EXP 61
24679: PUSH
24680: LD_EXP 61
24684: PPUSH
24685: LD_VAR 0 1
24689: PPUSH
24690: LD_EXP 61
24694: PUSH
24695: LD_VAR 0 1
24699: ARRAY
24700: PUSH
24701: LD_VAR 0 2
24705: UNION
24706: PPUSH
24707: CALL_OW 1
24711: ST_TO_ADDR
// end ;
24712: LD_VAR 0 3
24716: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
24717: LD_INT 0
24719: PPUSH
// if not mc_bases [ base ] then
24720: LD_EXP 56
24724: PUSH
24725: LD_VAR 0 1
24729: ARRAY
24730: NOT
24731: IFFALSE 24735
// exit ;
24733: GO 24760
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
24735: LD_ADDR_EXP 77
24739: PUSH
24740: LD_EXP 77
24744: PPUSH
24745: LD_VAR 0 1
24749: PPUSH
24750: LD_VAR 0 2
24754: PPUSH
24755: CALL_OW 1
24759: ST_TO_ADDR
// end ;
24760: LD_VAR 0 3
24764: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
24765: LD_INT 0
24767: PPUSH
// if not mc_bases [ base ] then
24768: LD_EXP 56
24772: PUSH
24773: LD_VAR 0 1
24777: ARRAY
24778: NOT
24779: IFFALSE 24783
// exit ;
24781: GO 24820
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
24783: LD_ADDR_EXP 77
24787: PUSH
24788: LD_EXP 77
24792: PPUSH
24793: LD_VAR 0 1
24797: PPUSH
24798: LD_EXP 77
24802: PUSH
24803: LD_VAR 0 1
24807: ARRAY
24808: PUSH
24809: LD_VAR 0 2
24813: UNION
24814: PPUSH
24815: CALL_OW 1
24819: ST_TO_ADDR
// end ;
24820: LD_VAR 0 3
24824: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
24825: LD_INT 0
24827: PPUSH
// if not mc_bases [ base ] then
24828: LD_EXP 56
24832: PUSH
24833: LD_VAR 0 1
24837: ARRAY
24838: NOT
24839: IFFALSE 24843
// exit ;
24841: GO 24955
// mc_defender := Replace ( mc_defender , base , deflist ) ;
24843: LD_ADDR_EXP 78
24847: PUSH
24848: LD_EXP 78
24852: PPUSH
24853: LD_VAR 0 1
24857: PPUSH
24858: LD_VAR 0 2
24862: PPUSH
24863: CALL_OW 1
24867: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
24868: LD_ADDR_EXP 67
24872: PUSH
24873: LD_EXP 67
24877: PPUSH
24878: LD_VAR 0 1
24882: PPUSH
24883: LD_VAR 0 2
24887: PUSH
24888: LD_INT 0
24890: PLUS
24891: PPUSH
24892: CALL_OW 1
24896: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
24897: LD_ADDR_EXP 75
24901: PUSH
24902: LD_EXP 75
24906: PPUSH
24907: LD_VAR 0 1
24911: PPUSH
24912: LD_EXP 75
24916: PUSH
24917: LD_VAR 0 1
24921: ARRAY
24922: PUSH
24923: LD_EXP 78
24927: PUSH
24928: LD_VAR 0 1
24932: ARRAY
24933: PPUSH
24934: LD_INT 21
24936: PUSH
24937: LD_INT 2
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: PPUSH
24944: CALL_OW 72
24948: UNION
24949: PPUSH
24950: CALL_OW 1
24954: ST_TO_ADDR
// end ;
24955: LD_VAR 0 3
24959: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
24960: LD_INT 0
24962: PPUSH
// if not mc_bases [ base ] then
24963: LD_EXP 56
24967: PUSH
24968: LD_VAR 0 1
24972: ARRAY
24973: NOT
24974: IFFALSE 24978
// exit ;
24976: GO 25003
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
24978: LD_ADDR_EXP 67
24982: PUSH
24983: LD_EXP 67
24987: PPUSH
24988: LD_VAR 0 1
24992: PPUSH
24993: LD_VAR 0 2
24997: PPUSH
24998: CALL_OW 1
25002: ST_TO_ADDR
// end ;
25003: LD_VAR 0 3
25007: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
25008: LD_INT 0
25010: PPUSH
25011: PPUSH
25012: PPUSH
25013: PPUSH
// if not mc_bases [ base ] then
25014: LD_EXP 56
25018: PUSH
25019: LD_VAR 0 1
25023: ARRAY
25024: NOT
25025: IFFALSE 25029
// exit ;
25027: GO 25094
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
25029: LD_ADDR_EXP 76
25033: PUSH
25034: LD_EXP 76
25038: PPUSH
25039: LD_VAR 0 1
25043: PUSH
25044: LD_EXP 76
25048: PUSH
25049: LD_VAR 0 1
25053: ARRAY
25054: PUSH
25055: LD_INT 1
25057: PLUS
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PPUSH
25063: LD_VAR 0 1
25067: PUSH
25068: LD_VAR 0 2
25072: PUSH
25073: LD_VAR 0 3
25077: PUSH
25078: LD_VAR 0 4
25082: PUSH
25083: EMPTY
25084: LIST
25085: LIST
25086: LIST
25087: LIST
25088: PPUSH
25089: CALL 37144 0 3
25093: ST_TO_ADDR
// end ;
25094: LD_VAR 0 5
25098: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
25099: LD_INT 0
25101: PPUSH
// if not mc_bases [ base ] then
25102: LD_EXP 56
25106: PUSH
25107: LD_VAR 0 1
25111: ARRAY
25112: NOT
25113: IFFALSE 25117
// exit ;
25115: GO 25142
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
25117: LD_ADDR_EXP 93
25121: PUSH
25122: LD_EXP 93
25126: PPUSH
25127: LD_VAR 0 1
25131: PPUSH
25132: LD_VAR 0 2
25136: PPUSH
25137: CALL_OW 1
25141: ST_TO_ADDR
// end ;
25142: LD_VAR 0 3
25146: RET
// export function MC_GetMinesField ( base ) ; begin
25147: LD_INT 0
25149: PPUSH
// result := mc_mines [ base ] ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_EXP 69
25159: PUSH
25160: LD_VAR 0 1
25164: ARRAY
25165: ST_TO_ADDR
// end ;
25166: LD_VAR 0 2
25170: RET
// export function MC_GetProduceList ( base ) ; begin
25171: LD_INT 0
25173: PPUSH
// result := mc_produce [ base ] ;
25174: LD_ADDR_VAR 0 2
25178: PUSH
25179: LD_EXP 77
25183: PUSH
25184: LD_VAR 0 1
25188: ARRAY
25189: ST_TO_ADDR
// end ;
25190: LD_VAR 0 2
25194: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
25195: LD_INT 0
25197: PPUSH
25198: PPUSH
// if not mc_bases then
25199: LD_EXP 56
25203: NOT
25204: IFFALSE 25208
// exit ;
25206: GO 25273
// if mc_bases [ base ] then
25208: LD_EXP 56
25212: PUSH
25213: LD_VAR 0 1
25217: ARRAY
25218: IFFALSE 25273
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
25220: LD_ADDR_VAR 0 3
25224: PUSH
25225: LD_EXP 56
25229: PUSH
25230: LD_VAR 0 1
25234: ARRAY
25235: PPUSH
25236: LD_INT 30
25238: PUSH
25239: LD_VAR 0 2
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PPUSH
25248: CALL_OW 72
25252: ST_TO_ADDR
// if result then
25253: LD_VAR 0 3
25257: IFFALSE 25273
// result := result [ 1 ] ;
25259: LD_ADDR_VAR 0 3
25263: PUSH
25264: LD_VAR 0 3
25268: PUSH
25269: LD_INT 1
25271: ARRAY
25272: ST_TO_ADDR
// end ; end ;
25273: LD_VAR 0 3
25277: RET
// export function MC_SetTame ( base , area ) ; begin
25278: LD_INT 0
25280: PPUSH
// if not mc_bases or not base then
25281: LD_EXP 56
25285: NOT
25286: PUSH
25287: LD_VAR 0 1
25291: NOT
25292: OR
25293: IFFALSE 25297
// exit ;
25295: GO 25322
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
25297: LD_ADDR_EXP 84
25301: PUSH
25302: LD_EXP 84
25306: PPUSH
25307: LD_VAR 0 1
25311: PPUSH
25312: LD_VAR 0 2
25316: PPUSH
25317: CALL_OW 1
25321: ST_TO_ADDR
// end ;
25322: LD_VAR 0 3
25326: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
25327: LD_INT 0
25329: PPUSH
25330: PPUSH
// if not mc_bases or not base then
25331: LD_EXP 56
25335: NOT
25336: PUSH
25337: LD_VAR 0 1
25341: NOT
25342: OR
25343: IFFALSE 25347
// exit ;
25345: GO 25449
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
25347: LD_ADDR_VAR 0 4
25351: PUSH
25352: LD_EXP 56
25356: PUSH
25357: LD_VAR 0 1
25361: ARRAY
25362: PPUSH
25363: LD_INT 30
25365: PUSH
25366: LD_VAR 0 2
25370: PUSH
25371: EMPTY
25372: LIST
25373: LIST
25374: PPUSH
25375: CALL_OW 72
25379: ST_TO_ADDR
// if not tmp then
25380: LD_VAR 0 4
25384: NOT
25385: IFFALSE 25389
// exit ;
25387: GO 25449
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
25389: LD_ADDR_EXP 88
25393: PUSH
25394: LD_EXP 88
25398: PPUSH
25399: LD_VAR 0 1
25403: PPUSH
25404: LD_EXP 88
25408: PUSH
25409: LD_VAR 0 1
25413: ARRAY
25414: PPUSH
25415: LD_EXP 88
25419: PUSH
25420: LD_VAR 0 1
25424: ARRAY
25425: PUSH
25426: LD_INT 1
25428: PLUS
25429: PPUSH
25430: LD_VAR 0 4
25434: PUSH
25435: LD_INT 1
25437: ARRAY
25438: PPUSH
25439: CALL_OW 2
25443: PPUSH
25444: CALL_OW 1
25448: ST_TO_ADDR
// end ;
25449: LD_VAR 0 3
25453: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
25454: LD_INT 0
25456: PPUSH
25457: PPUSH
// if not mc_bases or not base or not kinds then
25458: LD_EXP 56
25462: NOT
25463: PUSH
25464: LD_VAR 0 1
25468: NOT
25469: OR
25470: PUSH
25471: LD_VAR 0 2
25475: NOT
25476: OR
25477: IFFALSE 25481
// exit ;
25479: GO 25542
// for i in kinds do
25481: LD_ADDR_VAR 0 4
25485: PUSH
25486: LD_VAR 0 2
25490: PUSH
25491: FOR_IN
25492: IFFALSE 25540
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
25494: LD_ADDR_EXP 90
25498: PUSH
25499: LD_EXP 90
25503: PPUSH
25504: LD_VAR 0 1
25508: PUSH
25509: LD_EXP 90
25513: PUSH
25514: LD_VAR 0 1
25518: ARRAY
25519: PUSH
25520: LD_INT 1
25522: PLUS
25523: PUSH
25524: EMPTY
25525: LIST
25526: LIST
25527: PPUSH
25528: LD_VAR 0 4
25532: PPUSH
25533: CALL 37144 0 3
25537: ST_TO_ADDR
25538: GO 25491
25540: POP
25541: POP
// end ;
25542: LD_VAR 0 3
25546: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
25547: LD_INT 0
25549: PPUSH
// if not mc_bases or not base or not areas then
25550: LD_EXP 56
25554: NOT
25555: PUSH
25556: LD_VAR 0 1
25560: NOT
25561: OR
25562: PUSH
25563: LD_VAR 0 2
25567: NOT
25568: OR
25569: IFFALSE 25573
// exit ;
25571: GO 25598
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
25573: LD_ADDR_EXP 74
25577: PUSH
25578: LD_EXP 74
25582: PPUSH
25583: LD_VAR 0 1
25587: PPUSH
25588: LD_VAR 0 2
25592: PPUSH
25593: CALL_OW 1
25597: ST_TO_ADDR
// end ;
25598: LD_VAR 0 3
25602: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
25603: LD_INT 0
25605: PPUSH
// if not mc_bases or not base or not teleports_exit then
25606: LD_EXP 56
25610: NOT
25611: PUSH
25612: LD_VAR 0 1
25616: NOT
25617: OR
25618: PUSH
25619: LD_VAR 0 2
25623: NOT
25624: OR
25625: IFFALSE 25629
// exit ;
25627: GO 25654
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
25629: LD_ADDR_EXP 91
25633: PUSH
25634: LD_EXP 91
25638: PPUSH
25639: LD_VAR 0 1
25643: PPUSH
25644: LD_VAR 0 2
25648: PPUSH
25649: CALL_OW 1
25653: ST_TO_ADDR
// end ;
25654: LD_VAR 0 3
25658: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
25659: LD_INT 0
25661: PPUSH
25662: PPUSH
25663: PPUSH
// if not mc_bases or not base or not ext_list then
25664: LD_EXP 56
25668: NOT
25669: PUSH
25670: LD_VAR 0 1
25674: NOT
25675: OR
25676: PUSH
25677: LD_VAR 0 5
25681: NOT
25682: OR
25683: IFFALSE 25687
// exit ;
25685: GO 25860
// tmp := GetFacExtXYD ( x , y , d ) ;
25687: LD_ADDR_VAR 0 8
25691: PUSH
25692: LD_VAR 0 2
25696: PPUSH
25697: LD_VAR 0 3
25701: PPUSH
25702: LD_VAR 0 4
25706: PPUSH
25707: CALL 70459 0 3
25711: ST_TO_ADDR
// if not tmp then
25712: LD_VAR 0 8
25716: NOT
25717: IFFALSE 25721
// exit ;
25719: GO 25860
// for i in tmp do
25721: LD_ADDR_VAR 0 7
25725: PUSH
25726: LD_VAR 0 8
25730: PUSH
25731: FOR_IN
25732: IFFALSE 25858
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
25734: LD_ADDR_EXP 61
25738: PUSH
25739: LD_EXP 61
25743: PPUSH
25744: LD_VAR 0 1
25748: PPUSH
25749: LD_EXP 61
25753: PUSH
25754: LD_VAR 0 1
25758: ARRAY
25759: PPUSH
25760: LD_EXP 61
25764: PUSH
25765: LD_VAR 0 1
25769: ARRAY
25770: PUSH
25771: LD_INT 1
25773: PLUS
25774: PPUSH
25775: LD_VAR 0 5
25779: PUSH
25780: LD_INT 1
25782: ARRAY
25783: PUSH
25784: LD_VAR 0 7
25788: PUSH
25789: LD_INT 1
25791: ARRAY
25792: PUSH
25793: LD_VAR 0 7
25797: PUSH
25798: LD_INT 2
25800: ARRAY
25801: PUSH
25802: LD_VAR 0 7
25806: PUSH
25807: LD_INT 3
25809: ARRAY
25810: PUSH
25811: EMPTY
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: PPUSH
25817: CALL_OW 2
25821: PPUSH
25822: CALL_OW 1
25826: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
25827: LD_ADDR_VAR 0 5
25831: PUSH
25832: LD_VAR 0 5
25836: PPUSH
25837: LD_INT 1
25839: PPUSH
25840: CALL_OW 3
25844: ST_TO_ADDR
// if not ext_list then
25845: LD_VAR 0 5
25849: NOT
25850: IFFALSE 25856
// exit ;
25852: POP
25853: POP
25854: GO 25860
// end ;
25856: GO 25731
25858: POP
25859: POP
// end ;
25860: LD_VAR 0 6
25864: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
25865: LD_INT 0
25867: PPUSH
// if not mc_bases or not base or not weapon_list then
25868: LD_EXP 56
25872: NOT
25873: PUSH
25874: LD_VAR 0 1
25878: NOT
25879: OR
25880: PUSH
25881: LD_VAR 0 2
25885: NOT
25886: OR
25887: IFFALSE 25891
// exit ;
25889: GO 25916
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
25891: LD_ADDR_EXP 95
25895: PUSH
25896: LD_EXP 95
25900: PPUSH
25901: LD_VAR 0 1
25905: PPUSH
25906: LD_VAR 0 2
25910: PPUSH
25911: CALL_OW 1
25915: ST_TO_ADDR
// end ;
25916: LD_VAR 0 3
25920: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
25921: LD_INT 0
25923: PPUSH
// if not mc_bases or not base or not tech_list then
25924: LD_EXP 56
25928: NOT
25929: PUSH
25930: LD_VAR 0 1
25934: NOT
25935: OR
25936: PUSH
25937: LD_VAR 0 2
25941: NOT
25942: OR
25943: IFFALSE 25947
// exit ;
25945: GO 25972
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
25947: LD_ADDR_EXP 83
25951: PUSH
25952: LD_EXP 83
25956: PPUSH
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_VAR 0 2
25966: PPUSH
25967: CALL_OW 1
25971: ST_TO_ADDR
// end ;
25972: LD_VAR 0 3
25976: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
25977: LD_INT 0
25979: PPUSH
// if not mc_bases or not parking_area or not base then
25980: LD_EXP 56
25984: NOT
25985: PUSH
25986: LD_VAR 0 2
25990: NOT
25991: OR
25992: PUSH
25993: LD_VAR 0 1
25997: NOT
25998: OR
25999: IFFALSE 26003
// exit ;
26001: GO 26028
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
26003: LD_ADDR_EXP 80
26007: PUSH
26008: LD_EXP 80
26012: PPUSH
26013: LD_VAR 0 1
26017: PPUSH
26018: LD_VAR 0 2
26022: PPUSH
26023: CALL_OW 1
26027: ST_TO_ADDR
// end ;
26028: LD_VAR 0 3
26032: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
26033: LD_INT 0
26035: PPUSH
// if not mc_bases or not base or not scan_area then
26036: LD_EXP 56
26040: NOT
26041: PUSH
26042: LD_VAR 0 1
26046: NOT
26047: OR
26048: PUSH
26049: LD_VAR 0 2
26053: NOT
26054: OR
26055: IFFALSE 26059
// exit ;
26057: GO 26084
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
26059: LD_ADDR_EXP 81
26063: PUSH
26064: LD_EXP 81
26068: PPUSH
26069: LD_VAR 0 1
26073: PPUSH
26074: LD_VAR 0 2
26078: PPUSH
26079: CALL_OW 1
26083: ST_TO_ADDR
// end ;
26084: LD_VAR 0 3
26088: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
26089: LD_INT 0
26091: PPUSH
26092: PPUSH
// if not mc_bases or not base then
26093: LD_EXP 56
26097: NOT
26098: PUSH
26099: LD_VAR 0 1
26103: NOT
26104: OR
26105: IFFALSE 26109
// exit ;
26107: GO 26173
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
26109: LD_ADDR_VAR 0 3
26113: PUSH
26114: LD_INT 1
26116: PUSH
26117: LD_INT 2
26119: PUSH
26120: LD_INT 3
26122: PUSH
26123: LD_INT 4
26125: PUSH
26126: LD_INT 11
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
26136: LD_ADDR_EXP 83
26140: PUSH
26141: LD_EXP 83
26145: PPUSH
26146: LD_VAR 0 1
26150: PPUSH
26151: LD_EXP 83
26155: PUSH
26156: LD_VAR 0 1
26160: ARRAY
26161: PUSH
26162: LD_VAR 0 3
26166: DIFF
26167: PPUSH
26168: CALL_OW 1
26172: ST_TO_ADDR
// end ; end_of_file
26173: LD_VAR 0 2
26177: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
26178: LD_INT 0
26180: PPUSH
26181: PPUSH
26182: PPUSH
// if not mc_bases then
26183: LD_EXP 56
26187: NOT
26188: IFFALSE 26192
// exit ;
26190: GO 26357
// for i = 1 to mc_bases do
26192: LD_ADDR_VAR 0 4
26196: PUSH
26197: DOUBLE
26198: LD_INT 1
26200: DEC
26201: ST_TO_ADDR
26202: LD_EXP 56
26206: PUSH
26207: FOR_TO
26208: IFFALSE 26355
// begin if sci in mc_bases [ i ] then
26210: LD_VAR 0 2
26214: PUSH
26215: LD_EXP 56
26219: PUSH
26220: LD_VAR 0 4
26224: ARRAY
26225: IN
26226: IFFALSE 26353
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
26228: LD_ADDR_EXP 85
26232: PUSH
26233: LD_EXP 85
26237: PPUSH
26238: LD_VAR 0 4
26242: PUSH
26243: LD_EXP 85
26247: PUSH
26248: LD_VAR 0 4
26252: ARRAY
26253: PUSH
26254: LD_INT 1
26256: PLUS
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PPUSH
26262: LD_VAR 0 1
26266: PPUSH
26267: CALL 37144 0 3
26271: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
26272: LD_ADDR_VAR 0 5
26276: PUSH
26277: LD_EXP 56
26281: PUSH
26282: LD_VAR 0 4
26286: ARRAY
26287: PPUSH
26288: LD_INT 2
26290: PUSH
26291: LD_INT 30
26293: PUSH
26294: LD_INT 0
26296: PUSH
26297: EMPTY
26298: LIST
26299: LIST
26300: PUSH
26301: LD_INT 30
26303: PUSH
26304: LD_INT 1
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: LIST
26315: PPUSH
26316: CALL_OW 72
26320: PPUSH
26321: LD_VAR 0 1
26325: PPUSH
26326: CALL_OW 74
26330: ST_TO_ADDR
// if tmp then
26331: LD_VAR 0 5
26335: IFFALSE 26351
// ComStandNearbyBuilding ( ape , tmp ) ;
26337: LD_VAR 0 1
26341: PPUSH
26342: LD_VAR 0 5
26346: PPUSH
26347: CALL 31821 0 2
// break ;
26351: GO 26355
// end ; end ;
26353: GO 26207
26355: POP
26356: POP
// end ;
26357: LD_VAR 0 3
26361: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
26362: LD_INT 0
26364: PPUSH
26365: PPUSH
26366: PPUSH
// if not mc_bases then
26367: LD_EXP 56
26371: NOT
26372: IFFALSE 26376
// exit ;
26374: GO 26465
// for i = 1 to mc_bases do
26376: LD_ADDR_VAR 0 4
26380: PUSH
26381: DOUBLE
26382: LD_INT 1
26384: DEC
26385: ST_TO_ADDR
26386: LD_EXP 56
26390: PUSH
26391: FOR_TO
26392: IFFALSE 26463
// begin if building in mc_busy_turret_list [ i ] then
26394: LD_VAR 0 1
26398: PUSH
26399: LD_EXP 66
26403: PUSH
26404: LD_VAR 0 4
26408: ARRAY
26409: IN
26410: IFFALSE 26461
// begin tmp := mc_busy_turret_list [ i ] diff building ;
26412: LD_ADDR_VAR 0 5
26416: PUSH
26417: LD_EXP 66
26421: PUSH
26422: LD_VAR 0 4
26426: ARRAY
26427: PUSH
26428: LD_VAR 0 1
26432: DIFF
26433: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
26434: LD_ADDR_EXP 66
26438: PUSH
26439: LD_EXP 66
26443: PPUSH
26444: LD_VAR 0 4
26448: PPUSH
26449: LD_VAR 0 5
26453: PPUSH
26454: CALL_OW 1
26458: ST_TO_ADDR
// break ;
26459: GO 26463
// end ; end ;
26461: GO 26391
26463: POP
26464: POP
// end ;
26465: LD_VAR 0 3
26469: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
26470: LD_INT 0
26472: PPUSH
26473: PPUSH
26474: PPUSH
// if not mc_bases then
26475: LD_EXP 56
26479: NOT
26480: IFFALSE 26484
// exit ;
26482: GO 26683
// for i = 1 to mc_bases do
26484: LD_ADDR_VAR 0 5
26488: PUSH
26489: DOUBLE
26490: LD_INT 1
26492: DEC
26493: ST_TO_ADDR
26494: LD_EXP 56
26498: PUSH
26499: FOR_TO
26500: IFFALSE 26681
// if building in mc_bases [ i ] then
26502: LD_VAR 0 1
26506: PUSH
26507: LD_EXP 56
26511: PUSH
26512: LD_VAR 0 5
26516: ARRAY
26517: IN
26518: IFFALSE 26679
// begin tmp := mc_bases [ i ] diff building ;
26520: LD_ADDR_VAR 0 6
26524: PUSH
26525: LD_EXP 56
26529: PUSH
26530: LD_VAR 0 5
26534: ARRAY
26535: PUSH
26536: LD_VAR 0 1
26540: DIFF
26541: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
26542: LD_ADDR_EXP 56
26546: PUSH
26547: LD_EXP 56
26551: PPUSH
26552: LD_VAR 0 5
26556: PPUSH
26557: LD_VAR 0 6
26561: PPUSH
26562: CALL_OW 1
26566: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
26567: LD_VAR 0 1
26571: PUSH
26572: LD_EXP 64
26576: PUSH
26577: LD_VAR 0 5
26581: ARRAY
26582: IN
26583: IFFALSE 26622
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
26585: LD_ADDR_EXP 64
26589: PUSH
26590: LD_EXP 64
26594: PPUSH
26595: LD_VAR 0 5
26599: PPUSH
26600: LD_EXP 64
26604: PUSH
26605: LD_VAR 0 5
26609: ARRAY
26610: PUSH
26611: LD_VAR 0 1
26615: DIFF
26616: PPUSH
26617: CALL_OW 1
26621: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
26622: LD_VAR 0 1
26626: PUSH
26627: LD_EXP 65
26631: PUSH
26632: LD_VAR 0 5
26636: ARRAY
26637: IN
26638: IFFALSE 26677
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
26640: LD_ADDR_EXP 65
26644: PUSH
26645: LD_EXP 65
26649: PPUSH
26650: LD_VAR 0 5
26654: PPUSH
26655: LD_EXP 65
26659: PUSH
26660: LD_VAR 0 5
26664: ARRAY
26665: PUSH
26666: LD_VAR 0 1
26670: DIFF
26671: PPUSH
26672: CALL_OW 1
26676: ST_TO_ADDR
// break ;
26677: GO 26681
// end ;
26679: GO 26499
26681: POP
26682: POP
// end ;
26683: LD_VAR 0 4
26687: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
26688: LD_INT 0
26690: PPUSH
26691: PPUSH
26692: PPUSH
// if not mc_bases or not side in mc_sides then
26693: LD_EXP 56
26697: NOT
26698: PUSH
26699: LD_VAR 0 3
26703: PUSH
26704: LD_EXP 82
26708: IN
26709: NOT
26710: OR
26711: IFFALSE 26715
// exit ;
26713: GO 26838
// for i = 1 to mc_vehicles do
26715: LD_ADDR_VAR 0 6
26719: PUSH
26720: DOUBLE
26721: LD_INT 1
26723: DEC
26724: ST_TO_ADDR
26725: LD_EXP 75
26729: PUSH
26730: FOR_TO
26731: IFFALSE 26836
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
26733: LD_VAR 0 2
26737: PUSH
26738: LD_EXP 75
26742: PUSH
26743: LD_VAR 0 6
26747: ARRAY
26748: IN
26749: PUSH
26750: LD_VAR 0 1
26754: PUSH
26755: LD_EXP 75
26759: PUSH
26760: LD_VAR 0 6
26764: ARRAY
26765: IN
26766: OR
26767: IFFALSE 26834
// begin tmp := mc_vehicles [ i ] diff old ;
26769: LD_ADDR_VAR 0 7
26773: PUSH
26774: LD_EXP 75
26778: PUSH
26779: LD_VAR 0 6
26783: ARRAY
26784: PUSH
26785: LD_VAR 0 2
26789: DIFF
26790: ST_TO_ADDR
// tmp := tmp diff new ;
26791: LD_ADDR_VAR 0 7
26795: PUSH
26796: LD_VAR 0 7
26800: PUSH
26801: LD_VAR 0 1
26805: DIFF
26806: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
26807: LD_ADDR_EXP 75
26811: PUSH
26812: LD_EXP 75
26816: PPUSH
26817: LD_VAR 0 6
26821: PPUSH
26822: LD_VAR 0 7
26826: PPUSH
26827: CALL_OW 1
26831: ST_TO_ADDR
// break ;
26832: GO 26836
// end ;
26834: GO 26730
26836: POP
26837: POP
// end ;
26838: LD_VAR 0 5
26842: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
26843: LD_INT 0
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
// if not mc_bases then
26849: LD_EXP 56
26853: NOT
26854: IFFALSE 26858
// exit ;
26856: GO 27241
// side := GetSide ( vehicle ) ;
26858: LD_ADDR_VAR 0 5
26862: PUSH
26863: LD_VAR 0 1
26867: PPUSH
26868: CALL_OW 255
26872: ST_TO_ADDR
// for i = 1 to mc_bases do
26873: LD_ADDR_VAR 0 4
26877: PUSH
26878: DOUBLE
26879: LD_INT 1
26881: DEC
26882: ST_TO_ADDR
26883: LD_EXP 56
26887: PUSH
26888: FOR_TO
26889: IFFALSE 27239
// begin if factory in mc_bases [ i ] then
26891: LD_VAR 0 2
26895: PUSH
26896: LD_EXP 56
26900: PUSH
26901: LD_VAR 0 4
26905: ARRAY
26906: IN
26907: IFFALSE 27237
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
26909: LD_EXP 78
26913: PUSH
26914: LD_VAR 0 4
26918: ARRAY
26919: PUSH
26920: LD_EXP 67
26924: PUSH
26925: LD_VAR 0 4
26929: ARRAY
26930: LESS
26931: PUSH
26932: LD_VAR 0 1
26936: PPUSH
26937: CALL_OW 264
26941: PUSH
26942: LD_INT 31
26944: PUSH
26945: LD_INT 32
26947: PUSH
26948: LD_INT 51
26950: PUSH
26951: LD_EXP 50
26955: PUSH
26956: LD_INT 12
26958: PUSH
26959: LD_INT 30
26961: PUSH
26962: LD_EXP 49
26966: PUSH
26967: LD_INT 11
26969: PUSH
26970: LD_INT 53
26972: PUSH
26973: LD_INT 14
26975: PUSH
26976: LD_EXP 53
26980: PUSH
26981: LD_INT 29
26983: PUSH
26984: LD_EXP 51
26988: PUSH
26989: LD_INT 13
26991: PUSH
26992: LD_INT 52
26994: PUSH
26995: LD_INT 48
26997: PUSH
26998: LD_INT 8
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: LIST
27005: LIST
27006: LIST
27007: LIST
27008: LIST
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: IN
27020: NOT
27021: AND
27022: IFFALSE 27063
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
27024: LD_ADDR_EXP 78
27028: PUSH
27029: LD_EXP 78
27033: PPUSH
27034: LD_VAR 0 4
27038: PPUSH
27039: LD_EXP 78
27043: PUSH
27044: LD_VAR 0 4
27048: ARRAY
27049: PUSH
27050: LD_VAR 0 1
27054: ADD
27055: PPUSH
27056: CALL_OW 1
27060: ST_TO_ADDR
27061: GO 27107
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
27063: LD_ADDR_EXP 75
27067: PUSH
27068: LD_EXP 75
27072: PPUSH
27073: LD_VAR 0 4
27077: PUSH
27078: LD_EXP 75
27082: PUSH
27083: LD_VAR 0 4
27087: ARRAY
27088: PUSH
27089: LD_INT 1
27091: PLUS
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: LD_VAR 0 1
27101: PPUSH
27102: CALL 37144 0 3
27106: ST_TO_ADDR
// if not mc_scan [ i ] then
27107: LD_EXP 79
27111: PUSH
27112: LD_VAR 0 4
27116: ARRAY
27117: NOT
27118: IFFALSE 27237
// begin if GetControl ( vehicle ) = control_remote then
27120: LD_VAR 0 1
27124: PPUSH
27125: CALL_OW 263
27129: PUSH
27130: LD_INT 2
27132: EQUAL
27133: IFFALSE 27153
// repeat wait ( 0 0$1 ) ;
27135: LD_INT 35
27137: PPUSH
27138: CALL_OW 67
// until IsControledBy ( vehicle ) ;
27142: LD_VAR 0 1
27146: PPUSH
27147: CALL_OW 312
27151: IFFALSE 27135
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
27153: LD_VAR 0 1
27157: PPUSH
27158: LD_EXP 80
27162: PUSH
27163: LD_VAR 0 4
27167: ARRAY
27168: PPUSH
27169: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
27173: LD_VAR 0 1
27177: PPUSH
27178: CALL_OW 263
27182: PUSH
27183: LD_INT 1
27185: NONEQUAL
27186: IFFALSE 27190
// break ;
27188: GO 27239
// repeat wait ( 0 0$1 ) ;
27190: LD_INT 35
27192: PPUSH
27193: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
27197: LD_VAR 0 1
27201: PPUSH
27202: LD_EXP 80
27206: PUSH
27207: LD_VAR 0 4
27211: ARRAY
27212: PPUSH
27213: CALL_OW 308
27217: IFFALSE 27190
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
27219: LD_VAR 0 1
27223: PPUSH
27224: CALL_OW 311
27228: PPUSH
27229: CALL_OW 121
// exit ;
27233: POP
27234: POP
27235: GO 27241
// end ; end ; end ;
27237: GO 26888
27239: POP
27240: POP
// end ;
27241: LD_VAR 0 3
27245: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
27246: LD_INT 0
27248: PPUSH
27249: PPUSH
27250: PPUSH
27251: PPUSH
// if not mc_bases then
27252: LD_EXP 56
27256: NOT
27257: IFFALSE 27261
// exit ;
27259: GO 27614
// repeat wait ( 0 0$1 ) ;
27261: LD_INT 35
27263: PPUSH
27264: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
27268: LD_VAR 0 2
27272: PPUSH
27273: LD_VAR 0 3
27277: PPUSH
27278: CALL_OW 284
27282: IFFALSE 27261
// if GetResourceTypeXY ( x , y ) = mat_artefact then
27284: LD_VAR 0 2
27288: PPUSH
27289: LD_VAR 0 3
27293: PPUSH
27294: CALL_OW 283
27298: PUSH
27299: LD_INT 4
27301: EQUAL
27302: IFFALSE 27306
// exit ;
27304: GO 27614
// for i = 1 to mc_bases do
27306: LD_ADDR_VAR 0 7
27310: PUSH
27311: DOUBLE
27312: LD_INT 1
27314: DEC
27315: ST_TO_ADDR
27316: LD_EXP 56
27320: PUSH
27321: FOR_TO
27322: IFFALSE 27612
// begin if mc_crates_area [ i ] then
27324: LD_EXP 74
27328: PUSH
27329: LD_VAR 0 7
27333: ARRAY
27334: IFFALSE 27445
// for j in mc_crates_area [ i ] do
27336: LD_ADDR_VAR 0 8
27340: PUSH
27341: LD_EXP 74
27345: PUSH
27346: LD_VAR 0 7
27350: ARRAY
27351: PUSH
27352: FOR_IN
27353: IFFALSE 27443
// if InArea ( x , y , j ) then
27355: LD_VAR 0 2
27359: PPUSH
27360: LD_VAR 0 3
27364: PPUSH
27365: LD_VAR 0 8
27369: PPUSH
27370: CALL_OW 309
27374: IFFALSE 27441
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
27376: LD_ADDR_EXP 72
27380: PUSH
27381: LD_EXP 72
27385: PPUSH
27386: LD_VAR 0 7
27390: PUSH
27391: LD_EXP 72
27395: PUSH
27396: LD_VAR 0 7
27400: ARRAY
27401: PUSH
27402: LD_INT 1
27404: PLUS
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PPUSH
27410: LD_VAR 0 4
27414: PUSH
27415: LD_VAR 0 2
27419: PUSH
27420: LD_VAR 0 3
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: LIST
27429: PPUSH
27430: CALL 37144 0 3
27434: ST_TO_ADDR
// exit ;
27435: POP
27436: POP
27437: POP
27438: POP
27439: GO 27614
// end ;
27441: GO 27352
27443: POP
27444: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27445: LD_ADDR_VAR 0 9
27449: PUSH
27450: LD_EXP 56
27454: PUSH
27455: LD_VAR 0 7
27459: ARRAY
27460: PPUSH
27461: LD_INT 2
27463: PUSH
27464: LD_INT 30
27466: PUSH
27467: LD_INT 0
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: LD_INT 30
27476: PUSH
27477: LD_INT 1
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: LIST
27488: PPUSH
27489: CALL_OW 72
27493: ST_TO_ADDR
// if not depot then
27494: LD_VAR 0 9
27498: NOT
27499: IFFALSE 27503
// continue ;
27501: GO 27321
// for j in depot do
27503: LD_ADDR_VAR 0 8
27507: PUSH
27508: LD_VAR 0 9
27512: PUSH
27513: FOR_IN
27514: IFFALSE 27608
// if GetDistUnitXY ( j , x , y ) < 30 then
27516: LD_VAR 0 8
27520: PPUSH
27521: LD_VAR 0 2
27525: PPUSH
27526: LD_VAR 0 3
27530: PPUSH
27531: CALL_OW 297
27535: PUSH
27536: LD_INT 30
27538: LESS
27539: IFFALSE 27606
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
27541: LD_ADDR_EXP 72
27545: PUSH
27546: LD_EXP 72
27550: PPUSH
27551: LD_VAR 0 7
27555: PUSH
27556: LD_EXP 72
27560: PUSH
27561: LD_VAR 0 7
27565: ARRAY
27566: PUSH
27567: LD_INT 1
27569: PLUS
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PPUSH
27575: LD_VAR 0 4
27579: PUSH
27580: LD_VAR 0 2
27584: PUSH
27585: LD_VAR 0 3
27589: PUSH
27590: EMPTY
27591: LIST
27592: LIST
27593: LIST
27594: PPUSH
27595: CALL 37144 0 3
27599: ST_TO_ADDR
// exit ;
27600: POP
27601: POP
27602: POP
27603: POP
27604: GO 27614
// end ;
27606: GO 27513
27608: POP
27609: POP
// end ;
27610: GO 27321
27612: POP
27613: POP
// end ;
27614: LD_VAR 0 6
27618: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
27619: LD_INT 0
27621: PPUSH
27622: PPUSH
27623: PPUSH
27624: PPUSH
// side := GetSide ( lab ) ;
27625: LD_ADDR_VAR 0 4
27629: PUSH
27630: LD_VAR 0 2
27634: PPUSH
27635: CALL_OW 255
27639: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
27640: LD_VAR 0 4
27644: PUSH
27645: LD_EXP 82
27649: IN
27650: NOT
27651: PUSH
27652: LD_EXP 83
27656: NOT
27657: OR
27658: PUSH
27659: LD_EXP 56
27663: NOT
27664: OR
27665: IFFALSE 27669
// exit ;
27667: GO 27902
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
27669: LD_ADDR_EXP 83
27673: PUSH
27674: LD_EXP 83
27678: PPUSH
27679: LD_VAR 0 4
27683: PPUSH
27684: LD_EXP 83
27688: PUSH
27689: LD_VAR 0 4
27693: ARRAY
27694: PUSH
27695: LD_VAR 0 1
27699: DIFF
27700: PPUSH
27701: CALL_OW 1
27705: ST_TO_ADDR
// for i = 1 to mc_bases do
27706: LD_ADDR_VAR 0 5
27710: PUSH
27711: DOUBLE
27712: LD_INT 1
27714: DEC
27715: ST_TO_ADDR
27716: LD_EXP 56
27720: PUSH
27721: FOR_TO
27722: IFFALSE 27900
// begin if lab in mc_bases [ i ] then
27724: LD_VAR 0 2
27728: PUSH
27729: LD_EXP 56
27733: PUSH
27734: LD_VAR 0 5
27738: ARRAY
27739: IN
27740: IFFALSE 27898
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
27742: LD_VAR 0 1
27746: PUSH
27747: LD_INT 11
27749: PUSH
27750: LD_INT 4
27752: PUSH
27753: LD_INT 3
27755: PUSH
27756: LD_INT 2
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: LIST
27763: LIST
27764: IN
27765: PUSH
27766: LD_EXP 86
27770: PUSH
27771: LD_VAR 0 5
27775: ARRAY
27776: AND
27777: IFFALSE 27898
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
27779: LD_ADDR_VAR 0 6
27783: PUSH
27784: LD_EXP 86
27788: PUSH
27789: LD_VAR 0 5
27793: ARRAY
27794: PUSH
27795: LD_INT 1
27797: ARRAY
27798: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
27799: LD_ADDR_EXP 86
27803: PUSH
27804: LD_EXP 86
27808: PPUSH
27809: LD_VAR 0 5
27813: PPUSH
27814: EMPTY
27815: PPUSH
27816: CALL_OW 1
27820: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
27821: LD_VAR 0 6
27825: PPUSH
27826: LD_INT 0
27828: PPUSH
27829: CALL_OW 109
// ComExitBuilding ( tmp ) ;
27833: LD_VAR 0 6
27837: PPUSH
27838: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
27842: LD_ADDR_EXP 85
27846: PUSH
27847: LD_EXP 85
27851: PPUSH
27852: LD_VAR 0 5
27856: PPUSH
27857: LD_EXP 85
27861: PUSH
27862: LD_VAR 0 5
27866: ARRAY
27867: PPUSH
27868: LD_INT 1
27870: PPUSH
27871: LD_VAR 0 6
27875: PPUSH
27876: CALL_OW 2
27880: PPUSH
27881: CALL_OW 1
27885: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
27886: LD_VAR 0 5
27890: PPUSH
27891: LD_INT 112
27893: PPUSH
27894: CALL 5887 0 2
// end ; end ; end ;
27898: GO 27721
27900: POP
27901: POP
// end ;
27902: LD_VAR 0 3
27906: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
27907: LD_INT 0
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
27913: PPUSH
27914: PPUSH
27915: PPUSH
27916: PPUSH
// if not mc_bases then
27917: LD_EXP 56
27921: NOT
27922: IFFALSE 27926
// exit ;
27924: GO 28869
// for i = 1 to mc_bases do
27926: LD_ADDR_VAR 0 3
27930: PUSH
27931: DOUBLE
27932: LD_INT 1
27934: DEC
27935: ST_TO_ADDR
27936: LD_EXP 56
27940: PUSH
27941: FOR_TO
27942: IFFALSE 28867
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
27944: LD_VAR 0 1
27948: PUSH
27949: LD_EXP 56
27953: PUSH
27954: LD_VAR 0 3
27958: ARRAY
27959: IN
27960: PUSH
27961: LD_VAR 0 1
27965: PUSH
27966: LD_EXP 63
27970: PUSH
27971: LD_VAR 0 3
27975: ARRAY
27976: IN
27977: OR
27978: PUSH
27979: LD_VAR 0 1
27983: PUSH
27984: LD_EXP 75
27988: PUSH
27989: LD_VAR 0 3
27993: ARRAY
27994: IN
27995: OR
27996: PUSH
27997: LD_VAR 0 1
28001: PUSH
28002: LD_EXP 85
28006: PUSH
28007: LD_VAR 0 3
28011: ARRAY
28012: IN
28013: OR
28014: PUSH
28015: LD_VAR 0 1
28019: PUSH
28020: LD_EXP 86
28024: PUSH
28025: LD_VAR 0 3
28029: ARRAY
28030: IN
28031: OR
28032: IFFALSE 28865
// begin if un in mc_ape [ i ] then
28034: LD_VAR 0 1
28038: PUSH
28039: LD_EXP 85
28043: PUSH
28044: LD_VAR 0 3
28048: ARRAY
28049: IN
28050: IFFALSE 28089
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
28052: LD_ADDR_EXP 85
28056: PUSH
28057: LD_EXP 85
28061: PPUSH
28062: LD_VAR 0 3
28066: PPUSH
28067: LD_EXP 85
28071: PUSH
28072: LD_VAR 0 3
28076: ARRAY
28077: PUSH
28078: LD_VAR 0 1
28082: DIFF
28083: PPUSH
28084: CALL_OW 1
28088: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
28089: LD_VAR 0 1
28093: PUSH
28094: LD_EXP 86
28098: PUSH
28099: LD_VAR 0 3
28103: ARRAY
28104: IN
28105: IFFALSE 28129
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
28107: LD_ADDR_EXP 86
28111: PUSH
28112: LD_EXP 86
28116: PPUSH
28117: LD_VAR 0 3
28121: PPUSH
28122: EMPTY
28123: PPUSH
28124: CALL_OW 1
28128: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
28129: LD_VAR 0 1
28133: PPUSH
28134: CALL_OW 247
28138: PUSH
28139: LD_INT 2
28141: EQUAL
28142: PUSH
28143: LD_VAR 0 1
28147: PPUSH
28148: CALL_OW 110
28152: PUSH
28153: LD_INT 20
28155: EQUAL
28156: AND
28157: IFFALSE 28260
// begin fac := MC_GetBuilding ( i , b_factory ) ;
28159: LD_ADDR_VAR 0 8
28163: PUSH
28164: LD_VAR 0 3
28168: PPUSH
28169: LD_INT 3
28171: PPUSH
28172: CALL 25195 0 2
28176: ST_TO_ADDR
// if fac then
28177: LD_VAR 0 8
28181: IFFALSE 28260
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
28183: LD_ADDR_VAR 0 9
28187: PUSH
28188: LD_VAR 0 8
28192: PPUSH
28193: LD_VAR 0 1
28197: PPUSH
28198: CALL_OW 265
28202: PPUSH
28203: LD_VAR 0 1
28207: PPUSH
28208: CALL_OW 262
28212: PPUSH
28213: LD_VAR 0 1
28217: PPUSH
28218: CALL_OW 263
28222: PPUSH
28223: LD_VAR 0 1
28227: PPUSH
28228: CALL_OW 264
28232: PPUSH
28233: CALL 34744 0 5
28237: ST_TO_ADDR
// if components then
28238: LD_VAR 0 9
28242: IFFALSE 28258
// MC_InsertProduceList ( i , components ) ;
28244: LD_VAR 0 3
28248: PPUSH
28249: LD_VAR 0 9
28253: PPUSH
28254: CALL 24765 0 2
// break ;
28258: GO 28867
// end ; end ; if GetType ( un ) = unit_building then
28260: LD_VAR 0 1
28264: PPUSH
28265: CALL_OW 247
28269: PUSH
28270: LD_INT 3
28272: EQUAL
28273: IFFALSE 28588
// begin btype := GetBType ( un ) ;
28275: LD_ADDR_VAR 0 5
28279: PUSH
28280: LD_VAR 0 1
28284: PPUSH
28285: CALL_OW 266
28289: ST_TO_ADDR
// if btype = b_warehouse then
28290: LD_VAR 0 5
28294: PUSH
28295: LD_INT 1
28297: EQUAL
28298: IFFALSE 28316
// begin btype := b_depot ;
28300: LD_ADDR_VAR 0 5
28304: PUSH
28305: LD_INT 0
28307: ST_TO_ADDR
// pos := 1 ;
28308: LD_ADDR_VAR 0 6
28312: PUSH
28313: LD_INT 1
28315: ST_TO_ADDR
// end ; if btype = b_factory then
28316: LD_VAR 0 5
28320: PUSH
28321: LD_INT 3
28323: EQUAL
28324: IFFALSE 28342
// begin btype := b_workshop ;
28326: LD_ADDR_VAR 0 5
28330: PUSH
28331: LD_INT 2
28333: ST_TO_ADDR
// pos := 1 ;
28334: LD_ADDR_VAR 0 6
28338: PUSH
28339: LD_INT 1
28341: ST_TO_ADDR
// end ; if btype = b_barracks then
28342: LD_VAR 0 5
28346: PUSH
28347: LD_INT 5
28349: EQUAL
28350: IFFALSE 28360
// btype := b_armoury ;
28352: LD_ADDR_VAR 0 5
28356: PUSH
28357: LD_INT 4
28359: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
28360: LD_VAR 0 5
28364: PUSH
28365: LD_INT 7
28367: PUSH
28368: LD_INT 8
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: IN
28375: IFFALSE 28385
// btype := b_lab ;
28377: LD_ADDR_VAR 0 5
28381: PUSH
28382: LD_INT 6
28384: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
28385: LD_ADDR_EXP 61
28389: PUSH
28390: LD_EXP 61
28394: PPUSH
28395: LD_VAR 0 3
28399: PUSH
28400: LD_EXP 61
28404: PUSH
28405: LD_VAR 0 3
28409: ARRAY
28410: PUSH
28411: LD_INT 1
28413: PLUS
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: PPUSH
28419: LD_VAR 0 5
28423: PUSH
28424: LD_VAR 0 1
28428: PPUSH
28429: CALL_OW 250
28433: PUSH
28434: LD_VAR 0 1
28438: PPUSH
28439: CALL_OW 251
28443: PUSH
28444: LD_VAR 0 1
28448: PPUSH
28449: CALL_OW 254
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: PPUSH
28460: CALL 37144 0 3
28464: ST_TO_ADDR
// if pos = 1 then
28465: LD_VAR 0 6
28469: PUSH
28470: LD_INT 1
28472: EQUAL
28473: IFFALSE 28588
// begin tmp := mc_build_list [ i ] ;
28475: LD_ADDR_VAR 0 7
28479: PUSH
28480: LD_EXP 61
28484: PUSH
28485: LD_VAR 0 3
28489: ARRAY
28490: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
28491: LD_VAR 0 7
28495: PPUSH
28496: LD_INT 2
28498: PUSH
28499: LD_INT 30
28501: PUSH
28502: LD_INT 0
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PUSH
28509: LD_INT 30
28511: PUSH
28512: LD_INT 1
28514: PUSH
28515: EMPTY
28516: LIST
28517: LIST
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: LIST
28523: PPUSH
28524: CALL_OW 72
28528: IFFALSE 28538
// pos := 2 ;
28530: LD_ADDR_VAR 0 6
28534: PUSH
28535: LD_INT 2
28537: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
28538: LD_ADDR_VAR 0 7
28542: PUSH
28543: LD_VAR 0 7
28547: PPUSH
28548: LD_VAR 0 6
28552: PPUSH
28553: LD_VAR 0 7
28557: PPUSH
28558: CALL 37470 0 3
28562: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
28563: LD_ADDR_EXP 61
28567: PUSH
28568: LD_EXP 61
28572: PPUSH
28573: LD_VAR 0 3
28577: PPUSH
28578: LD_VAR 0 7
28582: PPUSH
28583: CALL_OW 1
28587: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
28588: LD_VAR 0 1
28592: PUSH
28593: LD_EXP 56
28597: PUSH
28598: LD_VAR 0 3
28602: ARRAY
28603: IN
28604: IFFALSE 28643
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
28606: LD_ADDR_EXP 56
28610: PUSH
28611: LD_EXP 56
28615: PPUSH
28616: LD_VAR 0 3
28620: PPUSH
28621: LD_EXP 56
28625: PUSH
28626: LD_VAR 0 3
28630: ARRAY
28631: PUSH
28632: LD_VAR 0 1
28636: DIFF
28637: PPUSH
28638: CALL_OW 1
28642: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
28643: LD_VAR 0 1
28647: PUSH
28648: LD_EXP 63
28652: PUSH
28653: LD_VAR 0 3
28657: ARRAY
28658: IN
28659: IFFALSE 28698
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
28661: LD_ADDR_EXP 63
28665: PUSH
28666: LD_EXP 63
28670: PPUSH
28671: LD_VAR 0 3
28675: PPUSH
28676: LD_EXP 63
28680: PUSH
28681: LD_VAR 0 3
28685: ARRAY
28686: PUSH
28687: LD_VAR 0 1
28691: DIFF
28692: PPUSH
28693: CALL_OW 1
28697: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
28698: LD_VAR 0 1
28702: PUSH
28703: LD_EXP 75
28707: PUSH
28708: LD_VAR 0 3
28712: ARRAY
28713: IN
28714: IFFALSE 28753
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
28716: LD_ADDR_EXP 75
28720: PUSH
28721: LD_EXP 75
28725: PPUSH
28726: LD_VAR 0 3
28730: PPUSH
28731: LD_EXP 75
28735: PUSH
28736: LD_VAR 0 3
28740: ARRAY
28741: PUSH
28742: LD_VAR 0 1
28746: DIFF
28747: PPUSH
28748: CALL_OW 1
28752: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
28753: LD_VAR 0 1
28757: PUSH
28758: LD_EXP 65
28762: PUSH
28763: LD_VAR 0 3
28767: ARRAY
28768: IN
28769: IFFALSE 28808
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
28771: LD_ADDR_EXP 65
28775: PUSH
28776: LD_EXP 65
28780: PPUSH
28781: LD_VAR 0 3
28785: PPUSH
28786: LD_EXP 65
28790: PUSH
28791: LD_VAR 0 3
28795: ARRAY
28796: PUSH
28797: LD_VAR 0 1
28801: DIFF
28802: PPUSH
28803: CALL_OW 1
28807: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
28808: LD_VAR 0 1
28812: PUSH
28813: LD_EXP 64
28817: PUSH
28818: LD_VAR 0 3
28822: ARRAY
28823: IN
28824: IFFALSE 28863
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
28826: LD_ADDR_EXP 64
28830: PUSH
28831: LD_EXP 64
28835: PPUSH
28836: LD_VAR 0 3
28840: PPUSH
28841: LD_EXP 64
28845: PUSH
28846: LD_VAR 0 3
28850: ARRAY
28851: PUSH
28852: LD_VAR 0 1
28856: DIFF
28857: PPUSH
28858: CALL_OW 1
28862: ST_TO_ADDR
// end ; break ;
28863: GO 28867
// end ;
28865: GO 27941
28867: POP
28868: POP
// end ;
28869: LD_VAR 0 2
28873: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
28874: LD_INT 0
28876: PPUSH
28877: PPUSH
28878: PPUSH
// if not mc_bases then
28879: LD_EXP 56
28883: NOT
28884: IFFALSE 28888
// exit ;
28886: GO 29103
// for i = 1 to mc_bases do
28888: LD_ADDR_VAR 0 3
28892: PUSH
28893: DOUBLE
28894: LD_INT 1
28896: DEC
28897: ST_TO_ADDR
28898: LD_EXP 56
28902: PUSH
28903: FOR_TO
28904: IFFALSE 29101
// begin if building in mc_construct_list [ i ] then
28906: LD_VAR 0 1
28910: PUSH
28911: LD_EXP 63
28915: PUSH
28916: LD_VAR 0 3
28920: ARRAY
28921: IN
28922: IFFALSE 29099
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
28924: LD_ADDR_EXP 63
28928: PUSH
28929: LD_EXP 63
28933: PPUSH
28934: LD_VAR 0 3
28938: PPUSH
28939: LD_EXP 63
28943: PUSH
28944: LD_VAR 0 3
28948: ARRAY
28949: PUSH
28950: LD_VAR 0 1
28954: DIFF
28955: PPUSH
28956: CALL_OW 1
28960: ST_TO_ADDR
// if building in mc_lab [ i ] then
28961: LD_VAR 0 1
28965: PUSH
28966: LD_EXP 89
28970: PUSH
28971: LD_VAR 0 3
28975: ARRAY
28976: IN
28977: IFFALSE 29032
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
28979: LD_ADDR_EXP 90
28983: PUSH
28984: LD_EXP 90
28988: PPUSH
28989: LD_VAR 0 3
28993: PPUSH
28994: LD_EXP 90
28998: PUSH
28999: LD_VAR 0 3
29003: ARRAY
29004: PPUSH
29005: LD_INT 1
29007: PPUSH
29008: LD_EXP 90
29012: PUSH
29013: LD_VAR 0 3
29017: ARRAY
29018: PPUSH
29019: LD_INT 0
29021: PPUSH
29022: CALL 36562 0 4
29026: PPUSH
29027: CALL_OW 1
29031: ST_TO_ADDR
// if not building in mc_bases [ i ] then
29032: LD_VAR 0 1
29036: PUSH
29037: LD_EXP 56
29041: PUSH
29042: LD_VAR 0 3
29046: ARRAY
29047: IN
29048: NOT
29049: IFFALSE 29095
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
29051: LD_ADDR_EXP 56
29055: PUSH
29056: LD_EXP 56
29060: PPUSH
29061: LD_VAR 0 3
29065: PUSH
29066: LD_EXP 56
29070: PUSH
29071: LD_VAR 0 3
29075: ARRAY
29076: PUSH
29077: LD_INT 1
29079: PLUS
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PPUSH
29085: LD_VAR 0 1
29089: PPUSH
29090: CALL 37144 0 3
29094: ST_TO_ADDR
// exit ;
29095: POP
29096: POP
29097: GO 29103
// end ; end ;
29099: GO 28903
29101: POP
29102: POP
// end ;
29103: LD_VAR 0 2
29107: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
29108: LD_INT 0
29110: PPUSH
29111: PPUSH
29112: PPUSH
29113: PPUSH
29114: PPUSH
29115: PPUSH
29116: PPUSH
// if not mc_bases then
29117: LD_EXP 56
29121: NOT
29122: IFFALSE 29126
// exit ;
29124: GO 29787
// for i = 1 to mc_bases do
29126: LD_ADDR_VAR 0 3
29130: PUSH
29131: DOUBLE
29132: LD_INT 1
29134: DEC
29135: ST_TO_ADDR
29136: LD_EXP 56
29140: PUSH
29141: FOR_TO
29142: IFFALSE 29785
// begin if building in mc_construct_list [ i ] then
29144: LD_VAR 0 1
29148: PUSH
29149: LD_EXP 63
29153: PUSH
29154: LD_VAR 0 3
29158: ARRAY
29159: IN
29160: IFFALSE 29783
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
29162: LD_ADDR_EXP 63
29166: PUSH
29167: LD_EXP 63
29171: PPUSH
29172: LD_VAR 0 3
29176: PPUSH
29177: LD_EXP 63
29181: PUSH
29182: LD_VAR 0 3
29186: ARRAY
29187: PUSH
29188: LD_VAR 0 1
29192: DIFF
29193: PPUSH
29194: CALL_OW 1
29198: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
29199: LD_ADDR_EXP 56
29203: PUSH
29204: LD_EXP 56
29208: PPUSH
29209: LD_VAR 0 3
29213: PUSH
29214: LD_EXP 56
29218: PUSH
29219: LD_VAR 0 3
29223: ARRAY
29224: PUSH
29225: LD_INT 1
29227: PLUS
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PPUSH
29233: LD_VAR 0 1
29237: PPUSH
29238: CALL 37144 0 3
29242: ST_TO_ADDR
// btype := GetBType ( building ) ;
29243: LD_ADDR_VAR 0 5
29247: PUSH
29248: LD_VAR 0 1
29252: PPUSH
29253: CALL_OW 266
29257: ST_TO_ADDR
// side := GetSide ( building ) ;
29258: LD_ADDR_VAR 0 8
29262: PUSH
29263: LD_VAR 0 1
29267: PPUSH
29268: CALL_OW 255
29272: ST_TO_ADDR
// if btype = b_lab then
29273: LD_VAR 0 5
29277: PUSH
29278: LD_INT 6
29280: EQUAL
29281: IFFALSE 29331
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
29283: LD_ADDR_EXP 89
29287: PUSH
29288: LD_EXP 89
29292: PPUSH
29293: LD_VAR 0 3
29297: PUSH
29298: LD_EXP 89
29302: PUSH
29303: LD_VAR 0 3
29307: ARRAY
29308: PUSH
29309: LD_INT 1
29311: PLUS
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PPUSH
29317: LD_VAR 0 1
29321: PPUSH
29322: CALL 37144 0 3
29326: ST_TO_ADDR
// exit ;
29327: POP
29328: POP
29329: GO 29787
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
29331: LD_VAR 0 5
29335: PUSH
29336: LD_INT 0
29338: PUSH
29339: LD_INT 2
29341: PUSH
29342: LD_INT 4
29344: PUSH
29345: EMPTY
29346: LIST
29347: LIST
29348: LIST
29349: IN
29350: IFFALSE 29474
// begin if btype = b_armoury then
29352: LD_VAR 0 5
29356: PUSH
29357: LD_INT 4
29359: EQUAL
29360: IFFALSE 29370
// btype := b_barracks ;
29362: LD_ADDR_VAR 0 5
29366: PUSH
29367: LD_INT 5
29369: ST_TO_ADDR
// if btype = b_depot then
29370: LD_VAR 0 5
29374: PUSH
29375: LD_INT 0
29377: EQUAL
29378: IFFALSE 29388
// btype := b_warehouse ;
29380: LD_ADDR_VAR 0 5
29384: PUSH
29385: LD_INT 1
29387: ST_TO_ADDR
// if btype = b_workshop then
29388: LD_VAR 0 5
29392: PUSH
29393: LD_INT 2
29395: EQUAL
29396: IFFALSE 29406
// btype := b_factory ;
29398: LD_ADDR_VAR 0 5
29402: PUSH
29403: LD_INT 3
29405: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
29406: LD_VAR 0 5
29410: PPUSH
29411: LD_VAR 0 8
29415: PPUSH
29416: CALL_OW 323
29420: PUSH
29421: LD_INT 1
29423: EQUAL
29424: IFFALSE 29470
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
29426: LD_ADDR_EXP 88
29430: PUSH
29431: LD_EXP 88
29435: PPUSH
29436: LD_VAR 0 3
29440: PUSH
29441: LD_EXP 88
29445: PUSH
29446: LD_VAR 0 3
29450: ARRAY
29451: PUSH
29452: LD_INT 1
29454: PLUS
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PPUSH
29460: LD_VAR 0 1
29464: PPUSH
29465: CALL 37144 0 3
29469: ST_TO_ADDR
// exit ;
29470: POP
29471: POP
29472: GO 29787
// end ; if btype in [ b_bunker , b_turret ] then
29474: LD_VAR 0 5
29478: PUSH
29479: LD_INT 32
29481: PUSH
29482: LD_INT 33
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: IN
29489: IFFALSE 29779
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
29491: LD_ADDR_EXP 64
29495: PUSH
29496: LD_EXP 64
29500: PPUSH
29501: LD_VAR 0 3
29505: PUSH
29506: LD_EXP 64
29510: PUSH
29511: LD_VAR 0 3
29515: ARRAY
29516: PUSH
29517: LD_INT 1
29519: PLUS
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PPUSH
29525: LD_VAR 0 1
29529: PPUSH
29530: CALL 37144 0 3
29534: ST_TO_ADDR
// if btype = b_bunker then
29535: LD_VAR 0 5
29539: PUSH
29540: LD_INT 32
29542: EQUAL
29543: IFFALSE 29779
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
29545: LD_ADDR_EXP 65
29549: PUSH
29550: LD_EXP 65
29554: PPUSH
29555: LD_VAR 0 3
29559: PUSH
29560: LD_EXP 65
29564: PUSH
29565: LD_VAR 0 3
29569: ARRAY
29570: PUSH
29571: LD_INT 1
29573: PLUS
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PPUSH
29579: LD_VAR 0 1
29583: PPUSH
29584: CALL 37144 0 3
29588: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
29589: LD_ADDR_VAR 0 6
29593: PUSH
29594: LD_EXP 56
29598: PUSH
29599: LD_VAR 0 3
29603: ARRAY
29604: PPUSH
29605: LD_INT 25
29607: PUSH
29608: LD_INT 1
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: PUSH
29615: LD_INT 3
29617: PUSH
29618: LD_INT 54
29620: PUSH
29621: EMPTY
29622: LIST
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PPUSH
29632: CALL_OW 72
29636: ST_TO_ADDR
// if tmp then
29637: LD_VAR 0 6
29641: IFFALSE 29647
// exit ;
29643: POP
29644: POP
29645: GO 29787
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
29647: LD_ADDR_VAR 0 6
29651: PUSH
29652: LD_EXP 56
29656: PUSH
29657: LD_VAR 0 3
29661: ARRAY
29662: PPUSH
29663: LD_INT 2
29665: PUSH
29666: LD_INT 30
29668: PUSH
29669: LD_INT 4
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: PUSH
29676: LD_INT 30
29678: PUSH
29679: LD_INT 5
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: LIST
29690: PPUSH
29691: CALL_OW 72
29695: ST_TO_ADDR
// if not tmp then
29696: LD_VAR 0 6
29700: NOT
29701: IFFALSE 29707
// exit ;
29703: POP
29704: POP
29705: GO 29787
// for j in tmp do
29707: LD_ADDR_VAR 0 4
29711: PUSH
29712: LD_VAR 0 6
29716: PUSH
29717: FOR_IN
29718: IFFALSE 29777
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
29720: LD_ADDR_VAR 0 7
29724: PUSH
29725: LD_VAR 0 4
29729: PPUSH
29730: CALL_OW 313
29734: PPUSH
29735: LD_INT 25
29737: PUSH
29738: LD_INT 1
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PPUSH
29745: CALL_OW 72
29749: ST_TO_ADDR
// if units then
29750: LD_VAR 0 7
29754: IFFALSE 29775
// begin ComExitBuilding ( units [ 1 ] ) ;
29756: LD_VAR 0 7
29760: PUSH
29761: LD_INT 1
29763: ARRAY
29764: PPUSH
29765: CALL_OW 122
// exit ;
29769: POP
29770: POP
29771: POP
29772: POP
29773: GO 29787
// end ; end ;
29775: GO 29717
29777: POP
29778: POP
// end ; end ; exit ;
29779: POP
29780: POP
29781: GO 29787
// end ; end ;
29783: GO 29141
29785: POP
29786: POP
// end ;
29787: LD_VAR 0 2
29791: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
29792: LD_INT 0
29794: PPUSH
29795: PPUSH
29796: PPUSH
29797: PPUSH
29798: PPUSH
29799: PPUSH
29800: PPUSH
// if not mc_bases then
29801: LD_EXP 56
29805: NOT
29806: IFFALSE 29810
// exit ;
29808: GO 30041
// btype := GetBType ( building ) ;
29810: LD_ADDR_VAR 0 6
29814: PUSH
29815: LD_VAR 0 1
29819: PPUSH
29820: CALL_OW 266
29824: ST_TO_ADDR
// x := GetX ( building ) ;
29825: LD_ADDR_VAR 0 7
29829: PUSH
29830: LD_VAR 0 1
29834: PPUSH
29835: CALL_OW 250
29839: ST_TO_ADDR
// y := GetY ( building ) ;
29840: LD_ADDR_VAR 0 8
29844: PUSH
29845: LD_VAR 0 1
29849: PPUSH
29850: CALL_OW 251
29854: ST_TO_ADDR
// d := GetDir ( building ) ;
29855: LD_ADDR_VAR 0 9
29859: PUSH
29860: LD_VAR 0 1
29864: PPUSH
29865: CALL_OW 254
29869: ST_TO_ADDR
// for i = 1 to mc_bases do
29870: LD_ADDR_VAR 0 4
29874: PUSH
29875: DOUBLE
29876: LD_INT 1
29878: DEC
29879: ST_TO_ADDR
29880: LD_EXP 56
29884: PUSH
29885: FOR_TO
29886: IFFALSE 30039
// begin if not mc_build_list [ i ] then
29888: LD_EXP 61
29892: PUSH
29893: LD_VAR 0 4
29897: ARRAY
29898: NOT
29899: IFFALSE 29903
// continue ;
29901: GO 29885
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
29903: LD_VAR 0 6
29907: PUSH
29908: LD_VAR 0 7
29912: PUSH
29913: LD_VAR 0 8
29917: PUSH
29918: LD_VAR 0 9
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: PPUSH
29929: LD_EXP 61
29933: PUSH
29934: LD_VAR 0 4
29938: ARRAY
29939: PUSH
29940: LD_INT 1
29942: ARRAY
29943: PPUSH
29944: CALL 43313 0 2
29948: IFFALSE 30037
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
29950: LD_ADDR_EXP 61
29954: PUSH
29955: LD_EXP 61
29959: PPUSH
29960: LD_VAR 0 4
29964: PPUSH
29965: LD_EXP 61
29969: PUSH
29970: LD_VAR 0 4
29974: ARRAY
29975: PPUSH
29976: LD_INT 1
29978: PPUSH
29979: CALL_OW 3
29983: PPUSH
29984: CALL_OW 1
29988: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
29989: LD_ADDR_EXP 63
29993: PUSH
29994: LD_EXP 63
29998: PPUSH
29999: LD_VAR 0 4
30003: PUSH
30004: LD_EXP 63
30008: PUSH
30009: LD_VAR 0 4
30013: ARRAY
30014: PUSH
30015: LD_INT 1
30017: PLUS
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PPUSH
30023: LD_VAR 0 1
30027: PPUSH
30028: CALL 37144 0 3
30032: ST_TO_ADDR
// exit ;
30033: POP
30034: POP
30035: GO 30041
// end ; end ;
30037: GO 29885
30039: POP
30040: POP
// end ;
30041: LD_VAR 0 3
30045: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
30046: LD_INT 0
30048: PPUSH
30049: PPUSH
30050: PPUSH
// if not mc_bases then
30051: LD_EXP 56
30055: NOT
30056: IFFALSE 30060
// exit ;
30058: GO 30250
// for i = 1 to mc_bases do
30060: LD_ADDR_VAR 0 4
30064: PUSH
30065: DOUBLE
30066: LD_INT 1
30068: DEC
30069: ST_TO_ADDR
30070: LD_EXP 56
30074: PUSH
30075: FOR_TO
30076: IFFALSE 30163
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
30078: LD_VAR 0 1
30082: PUSH
30083: LD_EXP 64
30087: PUSH
30088: LD_VAR 0 4
30092: ARRAY
30093: IN
30094: PUSH
30095: LD_VAR 0 1
30099: PUSH
30100: LD_EXP 65
30104: PUSH
30105: LD_VAR 0 4
30109: ARRAY
30110: IN
30111: NOT
30112: AND
30113: IFFALSE 30161
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
30115: LD_ADDR_EXP 65
30119: PUSH
30120: LD_EXP 65
30124: PPUSH
30125: LD_VAR 0 4
30129: PUSH
30130: LD_EXP 65
30134: PUSH
30135: LD_VAR 0 4
30139: ARRAY
30140: PUSH
30141: LD_INT 1
30143: PLUS
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PPUSH
30149: LD_VAR 0 1
30153: PPUSH
30154: CALL 37144 0 3
30158: ST_TO_ADDR
// break ;
30159: GO 30163
// end ; end ;
30161: GO 30075
30163: POP
30164: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
30165: LD_VAR 0 1
30169: PPUSH
30170: CALL_OW 257
30174: PUSH
30175: LD_EXP 82
30179: IN
30180: PUSH
30181: LD_VAR 0 1
30185: PPUSH
30186: CALL_OW 266
30190: PUSH
30191: LD_INT 5
30193: EQUAL
30194: AND
30195: PUSH
30196: LD_VAR 0 2
30200: PPUSH
30201: CALL_OW 110
30205: PUSH
30206: LD_INT 18
30208: NONEQUAL
30209: AND
30210: IFFALSE 30250
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
30212: LD_VAR 0 2
30216: PPUSH
30217: CALL_OW 257
30221: PUSH
30222: LD_INT 5
30224: PUSH
30225: LD_INT 8
30227: PUSH
30228: LD_INT 9
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: LIST
30235: IN
30236: IFFALSE 30250
// SetClass ( unit , 1 ) ;
30238: LD_VAR 0 2
30242: PPUSH
30243: LD_INT 1
30245: PPUSH
30246: CALL_OW 336
// end ;
30250: LD_VAR 0 3
30254: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
30255: LD_INT 0
30257: PPUSH
30258: PPUSH
// if not mc_bases then
30259: LD_EXP 56
30263: NOT
30264: IFFALSE 30268
// exit ;
30266: GO 30384
// if GetLives ( abandoned_vehicle ) > 250 then
30268: LD_VAR 0 2
30272: PPUSH
30273: CALL_OW 256
30277: PUSH
30278: LD_INT 250
30280: GREATER
30281: IFFALSE 30285
// exit ;
30283: GO 30384
// for i = 1 to mc_bases do
30285: LD_ADDR_VAR 0 6
30289: PUSH
30290: DOUBLE
30291: LD_INT 1
30293: DEC
30294: ST_TO_ADDR
30295: LD_EXP 56
30299: PUSH
30300: FOR_TO
30301: IFFALSE 30382
// begin if driver in mc_bases [ i ] then
30303: LD_VAR 0 1
30307: PUSH
30308: LD_EXP 56
30312: PUSH
30313: LD_VAR 0 6
30317: ARRAY
30318: IN
30319: IFFALSE 30380
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
30321: LD_VAR 0 1
30325: PPUSH
30326: LD_EXP 56
30330: PUSH
30331: LD_VAR 0 6
30335: ARRAY
30336: PPUSH
30337: LD_INT 2
30339: PUSH
30340: LD_INT 30
30342: PUSH
30343: LD_INT 0
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 30
30352: PUSH
30353: LD_INT 1
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: LIST
30364: PPUSH
30365: CALL_OW 72
30369: PUSH
30370: LD_INT 1
30372: ARRAY
30373: PPUSH
30374: CALL_OW 112
// break ;
30378: GO 30382
// end ; end ;
30380: GO 30300
30382: POP
30383: POP
// end ; end_of_file
30384: LD_VAR 0 5
30388: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
30389: LD_INT 0
30391: PPUSH
30392: PPUSH
// if exist_mode then
30393: LD_VAR 0 2
30397: IFFALSE 30422
// unit := CreateCharacter ( prefix & ident ) else
30399: LD_ADDR_VAR 0 5
30403: PUSH
30404: LD_VAR 0 3
30408: PUSH
30409: LD_VAR 0 1
30413: STR
30414: PPUSH
30415: CALL_OW 34
30419: ST_TO_ADDR
30420: GO 30437
// unit := NewCharacter ( ident ) ;
30422: LD_ADDR_VAR 0 5
30426: PUSH
30427: LD_VAR 0 1
30431: PPUSH
30432: CALL_OW 25
30436: ST_TO_ADDR
// result := unit ;
30437: LD_ADDR_VAR 0 4
30441: PUSH
30442: LD_VAR 0 5
30446: ST_TO_ADDR
// end ;
30447: LD_VAR 0 4
30451: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
30452: LD_INT 0
30454: PPUSH
30455: PPUSH
// if not side or not nation then
30456: LD_VAR 0 1
30460: NOT
30461: PUSH
30462: LD_VAR 0 2
30466: NOT
30467: OR
30468: IFFALSE 30472
// exit ;
30470: GO 31108
// case nation of nation_american :
30472: LD_VAR 0 2
30476: PUSH
30477: LD_INT 1
30479: DOUBLE
30480: EQUAL
30481: IFTRUE 30485
30483: GO 30655
30485: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
30486: LD_ADDR_VAR 0 4
30490: PUSH
30491: LD_INT 35
30493: PUSH
30494: LD_INT 45
30496: PUSH
30497: LD_INT 46
30499: PUSH
30500: LD_INT 47
30502: PUSH
30503: LD_INT 1
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 6
30511: PUSH
30512: LD_INT 15
30514: PUSH
30515: LD_INT 16
30517: PUSH
30518: LD_INT 7
30520: PUSH
30521: LD_INT 12
30523: PUSH
30524: LD_INT 13
30526: PUSH
30527: LD_INT 10
30529: PUSH
30530: LD_INT 14
30532: PUSH
30533: LD_INT 20
30535: PUSH
30536: LD_INT 21
30538: PUSH
30539: LD_INT 22
30541: PUSH
30542: LD_INT 25
30544: PUSH
30545: LD_INT 32
30547: PUSH
30548: LD_INT 27
30550: PUSH
30551: LD_INT 36
30553: PUSH
30554: LD_INT 69
30556: PUSH
30557: LD_INT 39
30559: PUSH
30560: LD_INT 34
30562: PUSH
30563: LD_INT 40
30565: PUSH
30566: LD_INT 48
30568: PUSH
30569: LD_INT 49
30571: PUSH
30572: LD_INT 50
30574: PUSH
30575: LD_INT 51
30577: PUSH
30578: LD_INT 52
30580: PUSH
30581: LD_INT 53
30583: PUSH
30584: LD_INT 54
30586: PUSH
30587: LD_INT 55
30589: PUSH
30590: LD_INT 56
30592: PUSH
30593: LD_INT 57
30595: PUSH
30596: LD_INT 58
30598: PUSH
30599: LD_INT 59
30601: PUSH
30602: LD_INT 60
30604: PUSH
30605: LD_INT 61
30607: PUSH
30608: LD_INT 62
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: ST_TO_ADDR
30653: GO 31032
30655: LD_INT 2
30657: DOUBLE
30658: EQUAL
30659: IFTRUE 30663
30661: GO 30841
30663: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
30664: LD_ADDR_VAR 0 4
30668: PUSH
30669: LD_INT 35
30671: PUSH
30672: LD_INT 45
30674: PUSH
30675: LD_INT 46
30677: PUSH
30678: LD_INT 47
30680: PUSH
30681: LD_INT 70
30683: PUSH
30684: LD_INT 1
30686: PUSH
30687: LD_INT 11
30689: PUSH
30690: LD_INT 3
30692: PUSH
30693: LD_INT 4
30695: PUSH
30696: LD_INT 5
30698: PUSH
30699: LD_INT 6
30701: PUSH
30702: LD_INT 15
30704: PUSH
30705: LD_INT 18
30707: PUSH
30708: LD_INT 7
30710: PUSH
30711: LD_INT 17
30713: PUSH
30714: LD_INT 8
30716: PUSH
30717: LD_INT 20
30719: PUSH
30720: LD_INT 21
30722: PUSH
30723: LD_INT 22
30725: PUSH
30726: LD_INT 72
30728: PUSH
30729: LD_INT 26
30731: PUSH
30732: LD_INT 69
30734: PUSH
30735: LD_INT 39
30737: PUSH
30738: LD_INT 40
30740: PUSH
30741: LD_INT 41
30743: PUSH
30744: LD_INT 42
30746: PUSH
30747: LD_INT 43
30749: PUSH
30750: LD_INT 48
30752: PUSH
30753: LD_INT 49
30755: PUSH
30756: LD_INT 50
30758: PUSH
30759: LD_INT 51
30761: PUSH
30762: LD_INT 52
30764: PUSH
30765: LD_INT 53
30767: PUSH
30768: LD_INT 54
30770: PUSH
30771: LD_INT 55
30773: PUSH
30774: LD_INT 56
30776: PUSH
30777: LD_INT 60
30779: PUSH
30780: LD_INT 61
30782: PUSH
30783: LD_INT 62
30785: PUSH
30786: LD_INT 66
30788: PUSH
30789: LD_INT 67
30791: PUSH
30792: LD_INT 68
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: LIST
30821: LIST
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: ST_TO_ADDR
30839: GO 31032
30841: LD_INT 3
30843: DOUBLE
30844: EQUAL
30845: IFTRUE 30849
30847: GO 31031
30849: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
30850: LD_ADDR_VAR 0 4
30854: PUSH
30855: LD_INT 46
30857: PUSH
30858: LD_INT 47
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: LD_INT 11
30869: PUSH
30870: LD_INT 9
30872: PUSH
30873: LD_INT 20
30875: PUSH
30876: LD_INT 19
30878: PUSH
30879: LD_INT 21
30881: PUSH
30882: LD_INT 24
30884: PUSH
30885: LD_INT 22
30887: PUSH
30888: LD_INT 25
30890: PUSH
30891: LD_INT 28
30893: PUSH
30894: LD_INT 29
30896: PUSH
30897: LD_INT 30
30899: PUSH
30900: LD_INT 31
30902: PUSH
30903: LD_INT 37
30905: PUSH
30906: LD_INT 38
30908: PUSH
30909: LD_INT 32
30911: PUSH
30912: LD_INT 27
30914: PUSH
30915: LD_INT 33
30917: PUSH
30918: LD_INT 69
30920: PUSH
30921: LD_INT 39
30923: PUSH
30924: LD_INT 34
30926: PUSH
30927: LD_INT 40
30929: PUSH
30930: LD_INT 71
30932: PUSH
30933: LD_INT 23
30935: PUSH
30936: LD_INT 44
30938: PUSH
30939: LD_INT 48
30941: PUSH
30942: LD_INT 49
30944: PUSH
30945: LD_INT 50
30947: PUSH
30948: LD_INT 51
30950: PUSH
30951: LD_INT 52
30953: PUSH
30954: LD_INT 53
30956: PUSH
30957: LD_INT 54
30959: PUSH
30960: LD_INT 55
30962: PUSH
30963: LD_INT 56
30965: PUSH
30966: LD_INT 57
30968: PUSH
30969: LD_INT 58
30971: PUSH
30972: LD_INT 59
30974: PUSH
30975: LD_INT 63
30977: PUSH
30978: LD_INT 64
30980: PUSH
30981: LD_INT 65
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: ST_TO_ADDR
31029: GO 31032
31031: POP
// if state > - 1 and state < 3 then
31032: LD_VAR 0 3
31036: PUSH
31037: LD_INT 1
31039: NEG
31040: GREATER
31041: PUSH
31042: LD_VAR 0 3
31046: PUSH
31047: LD_INT 3
31049: LESS
31050: AND
31051: IFFALSE 31108
// for i in result do
31053: LD_ADDR_VAR 0 5
31057: PUSH
31058: LD_VAR 0 4
31062: PUSH
31063: FOR_IN
31064: IFFALSE 31106
// if GetTech ( i , side ) <> state then
31066: LD_VAR 0 5
31070: PPUSH
31071: LD_VAR 0 1
31075: PPUSH
31076: CALL_OW 321
31080: PUSH
31081: LD_VAR 0 3
31085: NONEQUAL
31086: IFFALSE 31104
// result := result diff i ;
31088: LD_ADDR_VAR 0 4
31092: PUSH
31093: LD_VAR 0 4
31097: PUSH
31098: LD_VAR 0 5
31102: DIFF
31103: ST_TO_ADDR
31104: GO 31063
31106: POP
31107: POP
// end ;
31108: LD_VAR 0 4
31112: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
31113: LD_INT 0
31115: PPUSH
31116: PPUSH
31117: PPUSH
// result := true ;
31118: LD_ADDR_VAR 0 3
31122: PUSH
31123: LD_INT 1
31125: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
31126: LD_ADDR_VAR 0 5
31130: PUSH
31131: LD_VAR 0 2
31135: PPUSH
31136: CALL_OW 480
31140: ST_TO_ADDR
// if not tmp then
31141: LD_VAR 0 5
31145: NOT
31146: IFFALSE 31150
// exit ;
31148: GO 31199
// for i in tmp do
31150: LD_ADDR_VAR 0 4
31154: PUSH
31155: LD_VAR 0 5
31159: PUSH
31160: FOR_IN
31161: IFFALSE 31197
// if GetTech ( i , side ) <> state_researched then
31163: LD_VAR 0 4
31167: PPUSH
31168: LD_VAR 0 1
31172: PPUSH
31173: CALL_OW 321
31177: PUSH
31178: LD_INT 2
31180: NONEQUAL
31181: IFFALSE 31195
// begin result := false ;
31183: LD_ADDR_VAR 0 3
31187: PUSH
31188: LD_INT 0
31190: ST_TO_ADDR
// exit ;
31191: POP
31192: POP
31193: GO 31199
// end ;
31195: GO 31160
31197: POP
31198: POP
// end ;
31199: LD_VAR 0 3
31203: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
31204: LD_INT 0
31206: PPUSH
31207: PPUSH
31208: PPUSH
31209: PPUSH
31210: PPUSH
31211: PPUSH
31212: PPUSH
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
31217: PPUSH
31218: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
31219: LD_VAR 0 1
31223: NOT
31224: PUSH
31225: LD_VAR 0 1
31229: PPUSH
31230: CALL_OW 257
31234: PUSH
31235: LD_INT 9
31237: NONEQUAL
31238: OR
31239: IFFALSE 31243
// exit ;
31241: GO 31816
// side := GetSide ( unit ) ;
31243: LD_ADDR_VAR 0 9
31247: PUSH
31248: LD_VAR 0 1
31252: PPUSH
31253: CALL_OW 255
31257: ST_TO_ADDR
// tech_space := tech_spacanom ;
31258: LD_ADDR_VAR 0 12
31262: PUSH
31263: LD_INT 29
31265: ST_TO_ADDR
// tech_time := tech_taurad ;
31266: LD_ADDR_VAR 0 13
31270: PUSH
31271: LD_INT 28
31273: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
31274: LD_ADDR_VAR 0 11
31278: PUSH
31279: LD_VAR 0 1
31283: PPUSH
31284: CALL_OW 310
31288: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
31289: LD_VAR 0 11
31293: PPUSH
31294: CALL_OW 247
31298: PUSH
31299: LD_INT 2
31301: EQUAL
31302: IFFALSE 31306
// exit ;
31304: GO 31816
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
31306: LD_ADDR_VAR 0 8
31310: PUSH
31311: LD_INT 81
31313: PUSH
31314: LD_VAR 0 9
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 3
31325: PUSH
31326: LD_INT 21
31328: PUSH
31329: LD_INT 3
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PPUSH
31344: CALL_OW 69
31348: ST_TO_ADDR
// if not tmp then
31349: LD_VAR 0 8
31353: NOT
31354: IFFALSE 31358
// exit ;
31356: GO 31816
// if in_unit then
31358: LD_VAR 0 11
31362: IFFALSE 31386
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
31364: LD_ADDR_VAR 0 10
31368: PUSH
31369: LD_VAR 0 8
31373: PPUSH
31374: LD_VAR 0 11
31378: PPUSH
31379: CALL_OW 74
31383: ST_TO_ADDR
31384: GO 31406
// enemy := NearestUnitToUnit ( tmp , unit ) ;
31386: LD_ADDR_VAR 0 10
31390: PUSH
31391: LD_VAR 0 8
31395: PPUSH
31396: LD_VAR 0 1
31400: PPUSH
31401: CALL_OW 74
31405: ST_TO_ADDR
// if not enemy then
31406: LD_VAR 0 10
31410: NOT
31411: IFFALSE 31415
// exit ;
31413: GO 31816
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
31415: LD_VAR 0 11
31419: PUSH
31420: LD_VAR 0 11
31424: PPUSH
31425: LD_VAR 0 10
31429: PPUSH
31430: CALL_OW 296
31434: PUSH
31435: LD_INT 13
31437: GREATER
31438: AND
31439: PUSH
31440: LD_VAR 0 1
31444: PPUSH
31445: LD_VAR 0 10
31449: PPUSH
31450: CALL_OW 296
31454: PUSH
31455: LD_INT 12
31457: GREATER
31458: OR
31459: IFFALSE 31463
// exit ;
31461: GO 31816
// missile := [ 1 ] ;
31463: LD_ADDR_VAR 0 14
31467: PUSH
31468: LD_INT 1
31470: PUSH
31471: EMPTY
31472: LIST
31473: ST_TO_ADDR
// if Researched ( side , tech_space ) then
31474: LD_VAR 0 9
31478: PPUSH
31479: LD_VAR 0 12
31483: PPUSH
31484: CALL_OW 325
31488: IFFALSE 31517
// missile := Insert ( missile , missile + 1 , 2 ) ;
31490: LD_ADDR_VAR 0 14
31494: PUSH
31495: LD_VAR 0 14
31499: PPUSH
31500: LD_VAR 0 14
31504: PUSH
31505: LD_INT 1
31507: PLUS
31508: PPUSH
31509: LD_INT 2
31511: PPUSH
31512: CALL_OW 2
31516: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
31517: LD_VAR 0 9
31521: PPUSH
31522: LD_VAR 0 13
31526: PPUSH
31527: CALL_OW 325
31531: PUSH
31532: LD_VAR 0 10
31536: PPUSH
31537: CALL_OW 255
31541: PPUSH
31542: LD_VAR 0 13
31546: PPUSH
31547: CALL_OW 325
31551: NOT
31552: AND
31553: IFFALSE 31582
// missile := Insert ( missile , missile + 1 , 3 ) ;
31555: LD_ADDR_VAR 0 14
31559: PUSH
31560: LD_VAR 0 14
31564: PPUSH
31565: LD_VAR 0 14
31569: PUSH
31570: LD_INT 1
31572: PLUS
31573: PPUSH
31574: LD_INT 3
31576: PPUSH
31577: CALL_OW 2
31581: ST_TO_ADDR
// if missile < 2 then
31582: LD_VAR 0 14
31586: PUSH
31587: LD_INT 2
31589: LESS
31590: IFFALSE 31594
// exit ;
31592: GO 31816
// x := GetX ( enemy ) ;
31594: LD_ADDR_VAR 0 4
31598: PUSH
31599: LD_VAR 0 10
31603: PPUSH
31604: CALL_OW 250
31608: ST_TO_ADDR
// y := GetY ( enemy ) ;
31609: LD_ADDR_VAR 0 5
31613: PUSH
31614: LD_VAR 0 10
31618: PPUSH
31619: CALL_OW 251
31623: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
31624: LD_ADDR_VAR 0 6
31628: PUSH
31629: LD_VAR 0 4
31633: PUSH
31634: LD_INT 1
31636: NEG
31637: PPUSH
31638: LD_INT 1
31640: PPUSH
31641: CALL_OW 12
31645: PLUS
31646: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
31647: LD_ADDR_VAR 0 7
31651: PUSH
31652: LD_VAR 0 5
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PPUSH
31661: LD_INT 1
31663: PPUSH
31664: CALL_OW 12
31668: PLUS
31669: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
31670: LD_VAR 0 6
31674: PPUSH
31675: LD_VAR 0 7
31679: PPUSH
31680: CALL_OW 488
31684: NOT
31685: IFFALSE 31707
// begin _x := x ;
31687: LD_ADDR_VAR 0 6
31691: PUSH
31692: LD_VAR 0 4
31696: ST_TO_ADDR
// _y := y ;
31697: LD_ADDR_VAR 0 7
31701: PUSH
31702: LD_VAR 0 5
31706: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
31707: LD_ADDR_VAR 0 3
31711: PUSH
31712: LD_INT 1
31714: PPUSH
31715: LD_VAR 0 14
31719: PPUSH
31720: CALL_OW 12
31724: ST_TO_ADDR
// case i of 1 :
31725: LD_VAR 0 3
31729: PUSH
31730: LD_INT 1
31732: DOUBLE
31733: EQUAL
31734: IFTRUE 31738
31736: GO 31755
31738: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
31739: LD_VAR 0 1
31743: PPUSH
31744: LD_VAR 0 10
31748: PPUSH
31749: CALL_OW 115
31753: GO 31816
31755: LD_INT 2
31757: DOUBLE
31758: EQUAL
31759: IFTRUE 31763
31761: GO 31785
31763: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
31764: LD_VAR 0 1
31768: PPUSH
31769: LD_VAR 0 6
31773: PPUSH
31774: LD_VAR 0 7
31778: PPUSH
31779: CALL_OW 153
31783: GO 31816
31785: LD_INT 3
31787: DOUBLE
31788: EQUAL
31789: IFTRUE 31793
31791: GO 31815
31793: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
31794: LD_VAR 0 1
31798: PPUSH
31799: LD_VAR 0 6
31803: PPUSH
31804: LD_VAR 0 7
31808: PPUSH
31809: CALL_OW 154
31813: GO 31816
31815: POP
// end ;
31816: LD_VAR 0 2
31820: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
31821: LD_INT 0
31823: PPUSH
31824: PPUSH
31825: PPUSH
31826: PPUSH
31827: PPUSH
31828: PPUSH
// if not unit or not building then
31829: LD_VAR 0 1
31833: NOT
31834: PUSH
31835: LD_VAR 0 2
31839: NOT
31840: OR
31841: IFFALSE 31845
// exit ;
31843: GO 32003
// x := GetX ( building ) ;
31845: LD_ADDR_VAR 0 5
31849: PUSH
31850: LD_VAR 0 2
31854: PPUSH
31855: CALL_OW 250
31859: ST_TO_ADDR
// y := GetY ( building ) ;
31860: LD_ADDR_VAR 0 6
31864: PUSH
31865: LD_VAR 0 2
31869: PPUSH
31870: CALL_OW 251
31874: ST_TO_ADDR
// for i = 0 to 5 do
31875: LD_ADDR_VAR 0 4
31879: PUSH
31880: DOUBLE
31881: LD_INT 0
31883: DEC
31884: ST_TO_ADDR
31885: LD_INT 5
31887: PUSH
31888: FOR_TO
31889: IFFALSE 32001
// begin _x := ShiftX ( x , i , 3 ) ;
31891: LD_ADDR_VAR 0 7
31895: PUSH
31896: LD_VAR 0 5
31900: PPUSH
31901: LD_VAR 0 4
31905: PPUSH
31906: LD_INT 3
31908: PPUSH
31909: CALL_OW 272
31913: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
31914: LD_ADDR_VAR 0 8
31918: PUSH
31919: LD_VAR 0 6
31923: PPUSH
31924: LD_VAR 0 4
31928: PPUSH
31929: LD_INT 3
31931: PPUSH
31932: CALL_OW 273
31936: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
31937: LD_VAR 0 7
31941: PPUSH
31942: LD_VAR 0 8
31946: PPUSH
31947: CALL_OW 488
31951: NOT
31952: IFFALSE 31956
// continue ;
31954: GO 31888
// if HexInfo ( _x , _y ) = 0 then
31956: LD_VAR 0 7
31960: PPUSH
31961: LD_VAR 0 8
31965: PPUSH
31966: CALL_OW 428
31970: PUSH
31971: LD_INT 0
31973: EQUAL
31974: IFFALSE 31999
// begin ComMoveXY ( unit , _x , _y ) ;
31976: LD_VAR 0 1
31980: PPUSH
31981: LD_VAR 0 7
31985: PPUSH
31986: LD_VAR 0 8
31990: PPUSH
31991: CALL_OW 111
// exit ;
31995: POP
31996: POP
31997: GO 32003
// end ; end ;
31999: GO 31888
32001: POP
32002: POP
// end ;
32003: LD_VAR 0 3
32007: RET
// export function ScanBase ( side , base_area ) ; begin
32008: LD_INT 0
32010: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
32011: LD_ADDR_VAR 0 3
32015: PUSH
32016: LD_VAR 0 2
32020: PPUSH
32021: LD_INT 81
32023: PUSH
32024: LD_VAR 0 1
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PPUSH
32033: CALL_OW 70
32037: ST_TO_ADDR
// end ;
32038: LD_VAR 0 3
32042: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
32043: LD_INT 0
32045: PPUSH
32046: PPUSH
32047: PPUSH
32048: PPUSH
32049: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
32050: LD_VAR 0 1
32054: NOT
32055: PUSH
32056: LD_EXP 56
32060: PUSH
32061: LD_VAR 0 1
32065: ARRAY
32066: NOT
32067: OR
32068: PUSH
32069: LD_VAR 0 2
32073: NOT
32074: OR
32075: PUSH
32076: LD_VAR 0 3
32080: NOT
32081: OR
32082: IFFALSE 32086
// exit ;
32084: GO 32536
// side := mc_sides [ base ] ;
32086: LD_ADDR_VAR 0 6
32090: PUSH
32091: LD_EXP 82
32095: PUSH
32096: LD_VAR 0 1
32100: ARRAY
32101: ST_TO_ADDR
// if not side then
32102: LD_VAR 0 6
32106: NOT
32107: IFFALSE 32111
// exit ;
32109: GO 32536
// for i in solds do
32111: LD_ADDR_VAR 0 7
32115: PUSH
32116: LD_VAR 0 2
32120: PUSH
32121: FOR_IN
32122: IFFALSE 32183
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
32124: LD_VAR 0 7
32128: PPUSH
32129: CALL_OW 310
32133: PPUSH
32134: CALL_OW 266
32138: PUSH
32139: LD_INT 32
32141: PUSH
32142: LD_INT 31
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: IN
32149: IFFALSE 32169
// solds := solds diff i else
32151: LD_ADDR_VAR 0 2
32155: PUSH
32156: LD_VAR 0 2
32160: PUSH
32161: LD_VAR 0 7
32165: DIFF
32166: ST_TO_ADDR
32167: GO 32181
// SetTag ( i , 18 ) ;
32169: LD_VAR 0 7
32173: PPUSH
32174: LD_INT 18
32176: PPUSH
32177: CALL_OW 109
32181: GO 32121
32183: POP
32184: POP
// if not solds then
32185: LD_VAR 0 2
32189: NOT
32190: IFFALSE 32194
// exit ;
32192: GO 32536
// repeat wait ( 0 0$1 ) ;
32194: LD_INT 35
32196: PPUSH
32197: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
32201: LD_ADDR_VAR 0 5
32205: PUSH
32206: LD_VAR 0 6
32210: PPUSH
32211: LD_VAR 0 3
32215: PPUSH
32216: CALL 32008 0 2
32220: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
32221: LD_VAR 0 5
32225: NOT
32226: PUSH
32227: LD_VAR 0 5
32231: PUSH
32232: LD_INT 3
32234: GREATER
32235: OR
32236: PUSH
32237: LD_EXP 78
32241: PUSH
32242: LD_VAR 0 1
32246: ARRAY
32247: OR
32248: IFFALSE 32289
// begin for i in solds do
32250: LD_ADDR_VAR 0 7
32254: PUSH
32255: LD_VAR 0 2
32259: PUSH
32260: FOR_IN
32261: IFFALSE 32285
// if HasTask ( i ) then
32263: LD_VAR 0 7
32267: PPUSH
32268: CALL_OW 314
32272: IFFALSE 32283
// ComStop ( i ) ;
32274: LD_VAR 0 7
32278: PPUSH
32279: CALL_OW 141
32283: GO 32260
32285: POP
32286: POP
// break ;
32287: GO 32524
// end ; for i in solds do
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_VAR 0 2
32298: PUSH
32299: FOR_IN
32300: IFFALSE 32516
// begin if IsInUnit ( i ) then
32302: LD_VAR 0 7
32306: PPUSH
32307: CALL_OW 310
32311: IFFALSE 32322
// ComExitBuilding ( i ) ;
32313: LD_VAR 0 7
32317: PPUSH
32318: CALL_OW 122
// if GetLives ( i ) > 333 then
32322: LD_VAR 0 7
32326: PPUSH
32327: CALL_OW 256
32331: PUSH
32332: LD_INT 333
32334: GREATER
32335: IFFALSE 32363
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
32337: LD_VAR 0 7
32341: PPUSH
32342: LD_VAR 0 5
32346: PPUSH
32347: LD_VAR 0 7
32351: PPUSH
32352: CALL_OW 74
32356: PPUSH
32357: CALL_OW 115
32361: GO 32514
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
32363: LD_ADDR_VAR 0 8
32367: PUSH
32368: LD_EXP 56
32372: PUSH
32373: LD_VAR 0 1
32377: ARRAY
32378: PPUSH
32379: LD_INT 2
32381: PUSH
32382: LD_INT 30
32384: PUSH
32385: LD_INT 0
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 30
32394: PUSH
32395: LD_INT 1
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 30
32404: PUSH
32405: LD_INT 6
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: PPUSH
32418: CALL_OW 72
32422: PPUSH
32423: LD_VAR 0 7
32427: PPUSH
32428: CALL_OW 74
32432: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
32433: LD_VAR 0 7
32437: PPUSH
32438: LD_VAR 0 8
32442: PPUSH
32443: CALL_OW 250
32447: PPUSH
32448: LD_INT 3
32450: PPUSH
32451: LD_INT 5
32453: PPUSH
32454: CALL_OW 272
32458: PPUSH
32459: LD_VAR 0 8
32463: PPUSH
32464: CALL_OW 251
32468: PPUSH
32469: LD_INT 3
32471: PPUSH
32472: LD_INT 5
32474: PPUSH
32475: CALL_OW 273
32479: PPUSH
32480: CALL_OW 111
// SetTag ( i , 0 ) ;
32484: LD_VAR 0 7
32488: PPUSH
32489: LD_INT 0
32491: PPUSH
32492: CALL_OW 109
// solds := solds diff i ;
32496: LD_ADDR_VAR 0 2
32500: PUSH
32501: LD_VAR 0 2
32505: PUSH
32506: LD_VAR 0 7
32510: DIFF
32511: ST_TO_ADDR
// continue ;
32512: GO 32299
// end ; end ;
32514: GO 32299
32516: POP
32517: POP
// until solds ;
32518: LD_VAR 0 2
32522: IFFALSE 32194
// MC_Reset ( base , 18 ) ;
32524: LD_VAR 0 1
32528: PPUSH
32529: LD_INT 18
32531: PPUSH
32532: CALL 5887 0 2
// end ;
32536: LD_VAR 0 4
32540: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
32541: LD_INT 0
32543: PPUSH
32544: PPUSH
32545: PPUSH
32546: PPUSH
32547: PPUSH
32548: PPUSH
32549: PPUSH
32550: PPUSH
32551: PPUSH
32552: PPUSH
32553: PPUSH
32554: PPUSH
32555: PPUSH
32556: PPUSH
32557: PPUSH
32558: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
32559: LD_ADDR_VAR 0 12
32563: PUSH
32564: LD_EXP 56
32568: PUSH
32569: LD_VAR 0 1
32573: ARRAY
32574: PPUSH
32575: LD_INT 25
32577: PUSH
32578: LD_INT 3
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PPUSH
32585: CALL_OW 72
32589: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32590: LD_ADDR_VAR 0 8
32594: PUSH
32595: LD_EXP 56
32599: PUSH
32600: LD_VAR 0 1
32604: ARRAY
32605: PPUSH
32606: LD_INT 2
32608: PUSH
32609: LD_INT 25
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 25
32621: PUSH
32622: LD_INT 5
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 25
32631: PUSH
32632: LD_INT 8
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 25
32641: PUSH
32642: LD_INT 9
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: PPUSH
32656: CALL_OW 72
32660: ST_TO_ADDR
// if not defenders and not solds then
32661: LD_VAR 0 2
32665: NOT
32666: PUSH
32667: LD_VAR 0 8
32671: NOT
32672: AND
32673: IFFALSE 32677
// exit ;
32675: GO 34043
// depot_under_attack := false ;
32677: LD_ADDR_VAR 0 16
32681: PUSH
32682: LD_INT 0
32684: ST_TO_ADDR
// sold_defenders := [ ] ;
32685: LD_ADDR_VAR 0 17
32689: PUSH
32690: EMPTY
32691: ST_TO_ADDR
// if mechs then
32692: LD_VAR 0 12
32696: IFFALSE 32825
// for i in defenders do
32698: LD_ADDR_VAR 0 5
32702: PUSH
32703: LD_VAR 0 2
32707: PUSH
32708: FOR_IN
32709: IFFALSE 32823
// begin SetTag ( i , 20 ) ;
32711: LD_VAR 0 5
32715: PPUSH
32716: LD_INT 20
32718: PPUSH
32719: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
32723: LD_VAR 0 5
32727: PPUSH
32728: CALL_OW 263
32732: PUSH
32733: LD_INT 1
32735: EQUAL
32736: PUSH
32737: LD_VAR 0 5
32741: PPUSH
32742: CALL_OW 311
32746: NOT
32747: AND
32748: PUSH
32749: LD_VAR 0 12
32753: AND
32754: IFFALSE 32821
// begin un := mechs [ 1 ] ;
32756: LD_ADDR_VAR 0 10
32760: PUSH
32761: LD_VAR 0 12
32765: PUSH
32766: LD_INT 1
32768: ARRAY
32769: ST_TO_ADDR
// ComExitBuilding ( un ) ;
32770: LD_VAR 0 10
32774: PPUSH
32775: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
32779: LD_VAR 0 10
32783: PPUSH
32784: LD_VAR 0 5
32788: PPUSH
32789: CALL_OW 180
// SetTag ( un , 19 ) ;
32793: LD_VAR 0 10
32797: PPUSH
32798: LD_INT 19
32800: PPUSH
32801: CALL_OW 109
// mechs := mechs diff un ;
32805: LD_ADDR_VAR 0 12
32809: PUSH
32810: LD_VAR 0 12
32814: PUSH
32815: LD_VAR 0 10
32819: DIFF
32820: ST_TO_ADDR
// end ; end ;
32821: GO 32708
32823: POP
32824: POP
// if solds then
32825: LD_VAR 0 8
32829: IFFALSE 32888
// for i in solds do
32831: LD_ADDR_VAR 0 5
32835: PUSH
32836: LD_VAR 0 8
32840: PUSH
32841: FOR_IN
32842: IFFALSE 32886
// if not GetTag ( i ) then
32844: LD_VAR 0 5
32848: PPUSH
32849: CALL_OW 110
32853: NOT
32854: IFFALSE 32884
// begin defenders := defenders union i ;
32856: LD_ADDR_VAR 0 2
32860: PUSH
32861: LD_VAR 0 2
32865: PUSH
32866: LD_VAR 0 5
32870: UNION
32871: ST_TO_ADDR
// SetTag ( i , 18 ) ;
32872: LD_VAR 0 5
32876: PPUSH
32877: LD_INT 18
32879: PPUSH
32880: CALL_OW 109
// end ;
32884: GO 32841
32886: POP
32887: POP
// repeat wait ( 0 0$1 ) ;
32888: LD_INT 35
32890: PPUSH
32891: CALL_OW 67
// enemy := mc_scan [ base ] ;
32895: LD_ADDR_VAR 0 3
32899: PUSH
32900: LD_EXP 79
32904: PUSH
32905: LD_VAR 0 1
32909: ARRAY
32910: ST_TO_ADDR
// for i in defenders do
32911: LD_ADDR_VAR 0 5
32915: PUSH
32916: LD_VAR 0 2
32920: PUSH
32921: FOR_IN
32922: IFFALSE 33607
// begin e := NearestUnitToUnit ( enemy , i ) ;
32924: LD_ADDR_VAR 0 13
32928: PUSH
32929: LD_VAR 0 3
32933: PPUSH
32934: LD_VAR 0 5
32938: PPUSH
32939: CALL_OW 74
32943: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
32944: LD_ADDR_VAR 0 16
32948: PUSH
32949: LD_EXP 56
32953: PUSH
32954: LD_VAR 0 1
32958: ARRAY
32959: PPUSH
32960: LD_INT 2
32962: PUSH
32963: LD_INT 30
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 30
32975: PUSH
32976: LD_INT 1
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: LIST
32987: PPUSH
32988: CALL_OW 72
32992: NOT
32993: PUSH
32994: LD_EXP 56
32998: PUSH
32999: LD_VAR 0 1
33003: ARRAY
33004: PPUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 30
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 30
33020: PUSH
33021: LD_INT 1
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: LIST
33032: PPUSH
33033: CALL_OW 72
33037: PPUSH
33038: CALL_OW 256
33042: PUSH
33043: LD_INT 600
33045: LESS
33046: OR
33047: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
33048: LD_VAR 0 5
33052: PPUSH
33053: CALL_OW 247
33057: PUSH
33058: LD_INT 2
33060: DOUBLE
33061: EQUAL
33062: IFTRUE 33066
33064: GO 33313
33066: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
33067: LD_VAR 0 5
33071: PPUSH
33072: CALL_OW 256
33076: PUSH
33077: LD_INT 650
33079: GREATER
33080: PUSH
33081: LD_VAR 0 5
33085: PPUSH
33086: LD_VAR 0 13
33090: PPUSH
33091: CALL_OW 296
33095: PUSH
33096: LD_INT 40
33098: LESS
33099: AND
33100: IFFALSE 33118
// ComAttackUnit ( i , e ) else
33102: LD_VAR 0 5
33106: PPUSH
33107: LD_VAR 0 13
33111: PPUSH
33112: CALL_OW 115
33116: GO 33196
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
33118: LD_VAR 0 5
33122: PPUSH
33123: LD_VAR 0 13
33127: PPUSH
33128: CALL_OW 296
33132: PUSH
33133: LD_INT 30
33135: GREATEREQUAL
33136: PUSH
33137: LD_VAR 0 5
33141: PPUSH
33142: CALL_OW 256
33146: PUSH
33147: LD_INT 650
33149: LESSEQUAL
33150: OR
33151: PUSH
33152: LD_VAR 0 5
33156: PPUSH
33157: LD_EXP 80
33161: PUSH
33162: LD_VAR 0 1
33166: ARRAY
33167: PPUSH
33168: CALL_OW 308
33172: NOT
33173: AND
33174: IFFALSE 33196
// ComMoveToArea ( i , mc_parking [ base ] ) ;
33176: LD_VAR 0 5
33180: PPUSH
33181: LD_EXP 80
33185: PUSH
33186: LD_VAR 0 1
33190: ARRAY
33191: PPUSH
33192: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
33196: LD_VAR 0 5
33200: PPUSH
33201: CALL_OW 256
33205: PUSH
33206: LD_INT 998
33208: LESS
33209: PUSH
33210: LD_VAR 0 5
33214: PPUSH
33215: CALL_OW 263
33219: PUSH
33220: LD_INT 1
33222: EQUAL
33223: AND
33224: PUSH
33225: LD_VAR 0 5
33229: PPUSH
33230: CALL_OW 311
33234: AND
33235: PUSH
33236: LD_VAR 0 5
33240: PPUSH
33241: LD_EXP 80
33245: PUSH
33246: LD_VAR 0 1
33250: ARRAY
33251: PPUSH
33252: CALL_OW 308
33256: AND
33257: IFFALSE 33311
// begin mech := IsDrivenBy ( i ) ;
33259: LD_ADDR_VAR 0 9
33263: PUSH
33264: LD_VAR 0 5
33268: PPUSH
33269: CALL_OW 311
33273: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
33274: LD_VAR 0 9
33278: PPUSH
33279: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
33283: LD_VAR 0 9
33287: PPUSH
33288: LD_VAR 0 5
33292: PPUSH
33293: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
33297: LD_VAR 0 9
33301: PPUSH
33302: LD_VAR 0 5
33306: PPUSH
33307: CALL_OW 180
// end ; end ; unit_human :
33311: GO 33578
33313: LD_INT 1
33315: DOUBLE
33316: EQUAL
33317: IFTRUE 33321
33319: GO 33577
33321: POP
// begin b := IsInUnit ( i ) ;
33322: LD_ADDR_VAR 0 18
33326: PUSH
33327: LD_VAR 0 5
33331: PPUSH
33332: CALL_OW 310
33336: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
33337: LD_ADDR_VAR 0 19
33341: PUSH
33342: LD_VAR 0 18
33346: NOT
33347: PUSH
33348: LD_VAR 0 18
33352: PPUSH
33353: CALL_OW 266
33357: PUSH
33358: LD_INT 32
33360: PUSH
33361: LD_INT 31
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: IN
33368: OR
33369: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
33370: LD_VAR 0 16
33374: PUSH
33375: LD_VAR 0 2
33379: PPUSH
33380: LD_INT 21
33382: PUSH
33383: LD_INT 2
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PPUSH
33390: CALL_OW 72
33394: PUSH
33395: LD_INT 1
33397: LESSEQUAL
33398: OR
33399: PUSH
33400: LD_VAR 0 19
33404: AND
33405: PUSH
33406: LD_VAR 0 5
33410: PUSH
33411: LD_VAR 0 17
33415: IN
33416: NOT
33417: AND
33418: IFFALSE 33511
// begin if b then
33420: LD_VAR 0 18
33424: IFFALSE 33473
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
33426: LD_VAR 0 18
33430: PPUSH
33431: LD_VAR 0 3
33435: PPUSH
33436: LD_VAR 0 18
33440: PPUSH
33441: CALL_OW 74
33445: PPUSH
33446: CALL_OW 296
33450: PUSH
33451: LD_INT 10
33453: LESS
33454: PUSH
33455: LD_VAR 0 18
33459: PPUSH
33460: CALL_OW 461
33464: PUSH
33465: LD_INT 7
33467: NONEQUAL
33468: AND
33469: IFFALSE 33473
// continue ;
33471: GO 32921
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
33473: LD_ADDR_VAR 0 17
33477: PUSH
33478: LD_VAR 0 17
33482: PPUSH
33483: LD_VAR 0 17
33487: PUSH
33488: LD_INT 1
33490: PLUS
33491: PPUSH
33492: LD_VAR 0 5
33496: PPUSH
33497: CALL_OW 1
33501: ST_TO_ADDR
// ComExitBuilding ( i ) ;
33502: LD_VAR 0 5
33506: PPUSH
33507: CALL_OW 122
// end ; if sold_defenders then
33511: LD_VAR 0 17
33515: IFFALSE 33575
// if i in sold_defenders then
33517: LD_VAR 0 5
33521: PUSH
33522: LD_VAR 0 17
33526: IN
33527: IFFALSE 33575
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
33529: LD_VAR 0 5
33533: PPUSH
33534: CALL_OW 314
33538: NOT
33539: PUSH
33540: LD_VAR 0 5
33544: PPUSH
33545: LD_VAR 0 13
33549: PPUSH
33550: CALL_OW 296
33554: PUSH
33555: LD_INT 30
33557: LESS
33558: AND
33559: IFFALSE 33575
// ComAttackUnit ( i , e ) ;
33561: LD_VAR 0 5
33565: PPUSH
33566: LD_VAR 0 13
33570: PPUSH
33571: CALL_OW 115
// end ; end ; end ;
33575: GO 33578
33577: POP
// if IsDead ( i ) then
33578: LD_VAR 0 5
33582: PPUSH
33583: CALL_OW 301
33587: IFFALSE 33605
// defenders := defenders diff i ;
33589: LD_ADDR_VAR 0 2
33593: PUSH
33594: LD_VAR 0 2
33598: PUSH
33599: LD_VAR 0 5
33603: DIFF
33604: ST_TO_ADDR
// end ;
33605: GO 32921
33607: POP
33608: POP
// until not enemy or not defenders ;
33609: LD_VAR 0 3
33613: NOT
33614: PUSH
33615: LD_VAR 0 2
33619: NOT
33620: OR
33621: IFFALSE 32888
// MC_Reset ( base , 18 ) ;
33623: LD_VAR 0 1
33627: PPUSH
33628: LD_INT 18
33630: PPUSH
33631: CALL 5887 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33635: LD_ADDR_VAR 0 2
33639: PUSH
33640: LD_VAR 0 2
33644: PUSH
33645: LD_VAR 0 2
33649: PPUSH
33650: LD_INT 2
33652: PUSH
33653: LD_INT 25
33655: PUSH
33656: LD_INT 1
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 25
33665: PUSH
33666: LD_INT 5
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 25
33675: PUSH
33676: LD_INT 8
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 25
33685: PUSH
33686: LD_INT 9
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: PPUSH
33700: CALL_OW 72
33704: DIFF
33705: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
33706: LD_VAR 0 3
33710: NOT
33711: PUSH
33712: LD_VAR 0 2
33716: PPUSH
33717: LD_INT 21
33719: PUSH
33720: LD_INT 2
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PPUSH
33727: CALL_OW 72
33731: AND
33732: IFFALSE 33994
// begin tmp := FilterByTag ( defenders , 19 ) ;
33734: LD_ADDR_VAR 0 11
33738: PUSH
33739: LD_VAR 0 2
33743: PPUSH
33744: LD_INT 19
33746: PPUSH
33747: CALL 70341 0 2
33751: ST_TO_ADDR
// if tmp then
33752: LD_VAR 0 11
33756: IFFALSE 33826
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
33758: LD_ADDR_VAR 0 11
33762: PUSH
33763: LD_VAR 0 11
33767: PPUSH
33768: LD_INT 25
33770: PUSH
33771: LD_INT 3
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PPUSH
33778: CALL_OW 72
33782: ST_TO_ADDR
// if tmp then
33783: LD_VAR 0 11
33787: IFFALSE 33826
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
33789: LD_ADDR_EXP 68
33793: PUSH
33794: LD_EXP 68
33798: PPUSH
33799: LD_VAR 0 1
33803: PPUSH
33804: LD_EXP 68
33808: PUSH
33809: LD_VAR 0 1
33813: ARRAY
33814: PUSH
33815: LD_VAR 0 11
33819: UNION
33820: PPUSH
33821: CALL_OW 1
33825: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
33826: LD_VAR 0 1
33830: PPUSH
33831: LD_INT 19
33833: PPUSH
33834: CALL 5887 0 2
// repeat wait ( 0 0$1 ) ;
33838: LD_INT 35
33840: PPUSH
33841: CALL_OW 67
// for i in defenders do
33845: LD_ADDR_VAR 0 5
33849: PUSH
33850: LD_VAR 0 2
33854: PUSH
33855: FOR_IN
33856: IFFALSE 33945
// begin if not IsInArea ( i , mc_parking [ base ] ) then
33858: LD_VAR 0 5
33862: PPUSH
33863: LD_EXP 80
33867: PUSH
33868: LD_VAR 0 1
33872: ARRAY
33873: PPUSH
33874: CALL_OW 308
33878: NOT
33879: IFFALSE 33903
// ComMoveToArea ( i , mc_parking [ base ] ) else
33881: LD_VAR 0 5
33885: PPUSH
33886: LD_EXP 80
33890: PUSH
33891: LD_VAR 0 1
33895: ARRAY
33896: PPUSH
33897: CALL_OW 113
33901: GO 33943
// if GetControl ( i ) = control_manual then
33903: LD_VAR 0 5
33907: PPUSH
33908: CALL_OW 263
33912: PUSH
33913: LD_INT 1
33915: EQUAL
33916: IFFALSE 33943
// if IsDrivenBy ( i ) then
33918: LD_VAR 0 5
33922: PPUSH
33923: CALL_OW 311
33927: IFFALSE 33943
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
33929: LD_VAR 0 5
33933: PPUSH
33934: CALL_OW 311
33938: PPUSH
33939: CALL_OW 121
// end ;
33943: GO 33855
33945: POP
33946: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
33947: LD_VAR 0 2
33951: PPUSH
33952: LD_INT 95
33954: PUSH
33955: LD_EXP 80
33959: PUSH
33960: LD_VAR 0 1
33964: ARRAY
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PPUSH
33970: CALL_OW 72
33974: PUSH
33975: LD_VAR 0 2
33979: EQUAL
33980: PUSH
33981: LD_EXP 79
33985: PUSH
33986: LD_VAR 0 1
33990: ARRAY
33991: OR
33992: IFFALSE 33838
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
33994: LD_ADDR_EXP 78
33998: PUSH
33999: LD_EXP 78
34003: PPUSH
34004: LD_VAR 0 1
34008: PPUSH
34009: LD_EXP 78
34013: PUSH
34014: LD_VAR 0 1
34018: ARRAY
34019: PUSH
34020: LD_VAR 0 2
34024: UNION
34025: PPUSH
34026: CALL_OW 1
34030: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
34031: LD_VAR 0 1
34035: PPUSH
34036: LD_INT 20
34038: PPUSH
34039: CALL 5887 0 2
// end ;
34043: LD_VAR 0 4
34047: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
34048: LD_INT 0
34050: PPUSH
34051: PPUSH
34052: PPUSH
34053: PPUSH
// result := false ;
34054: LD_ADDR_VAR 0 2
34058: PUSH
34059: LD_INT 0
34061: ST_TO_ADDR
// side := GetSide ( unit ) ;
34062: LD_ADDR_VAR 0 3
34066: PUSH
34067: LD_VAR 0 1
34071: PPUSH
34072: CALL_OW 255
34076: ST_TO_ADDR
// nat := GetNation ( unit ) ;
34077: LD_ADDR_VAR 0 4
34081: PUSH
34082: LD_VAR 0 1
34086: PPUSH
34087: CALL_OW 248
34091: ST_TO_ADDR
// case nat of 1 :
34092: LD_VAR 0 4
34096: PUSH
34097: LD_INT 1
34099: DOUBLE
34100: EQUAL
34101: IFTRUE 34105
34103: GO 34116
34105: POP
// tech := tech_lassight ; 2 :
34106: LD_ADDR_VAR 0 5
34110: PUSH
34111: LD_INT 12
34113: ST_TO_ADDR
34114: GO 34155
34116: LD_INT 2
34118: DOUBLE
34119: EQUAL
34120: IFTRUE 34124
34122: GO 34135
34124: POP
// tech := tech_mortar ; 3 :
34125: LD_ADDR_VAR 0 5
34129: PUSH
34130: LD_INT 41
34132: ST_TO_ADDR
34133: GO 34155
34135: LD_INT 3
34137: DOUBLE
34138: EQUAL
34139: IFTRUE 34143
34141: GO 34154
34143: POP
// tech := tech_bazooka ; end ;
34144: LD_ADDR_VAR 0 5
34148: PUSH
34149: LD_INT 44
34151: ST_TO_ADDR
34152: GO 34155
34154: POP
// if Researched ( side , tech ) then
34155: LD_VAR 0 3
34159: PPUSH
34160: LD_VAR 0 5
34164: PPUSH
34165: CALL_OW 325
34169: IFFALSE 34196
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
34171: LD_ADDR_VAR 0 2
34175: PUSH
34176: LD_INT 5
34178: PUSH
34179: LD_INT 8
34181: PUSH
34182: LD_INT 9
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: LIST
34189: PUSH
34190: LD_VAR 0 4
34194: ARRAY
34195: ST_TO_ADDR
// end ;
34196: LD_VAR 0 2
34200: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
34201: LD_INT 0
34203: PPUSH
34204: PPUSH
34205: PPUSH
// if not mines then
34206: LD_VAR 0 2
34210: NOT
34211: IFFALSE 34215
// exit ;
34213: GO 34359
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
34215: LD_ADDR_VAR 0 5
34219: PUSH
34220: LD_INT 81
34222: PUSH
34223: LD_VAR 0 1
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 3
34234: PUSH
34235: LD_INT 21
34237: PUSH
34238: LD_INT 3
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PPUSH
34253: CALL_OW 69
34257: ST_TO_ADDR
// for i in mines do
34258: LD_ADDR_VAR 0 4
34262: PUSH
34263: LD_VAR 0 2
34267: PUSH
34268: FOR_IN
34269: IFFALSE 34357
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
34271: LD_VAR 0 4
34275: PUSH
34276: LD_INT 1
34278: ARRAY
34279: PPUSH
34280: LD_VAR 0 4
34284: PUSH
34285: LD_INT 2
34287: ARRAY
34288: PPUSH
34289: CALL_OW 458
34293: NOT
34294: IFFALSE 34298
// continue ;
34296: GO 34268
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
34298: LD_VAR 0 4
34302: PUSH
34303: LD_INT 1
34305: ARRAY
34306: PPUSH
34307: LD_VAR 0 4
34311: PUSH
34312: LD_INT 2
34314: ARRAY
34315: PPUSH
34316: CALL_OW 428
34320: PUSH
34321: LD_VAR 0 5
34325: IN
34326: IFFALSE 34355
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
34328: LD_VAR 0 4
34332: PUSH
34333: LD_INT 1
34335: ARRAY
34336: PPUSH
34337: LD_VAR 0 4
34341: PUSH
34342: LD_INT 2
34344: ARRAY
34345: PPUSH
34346: LD_VAR 0 1
34350: PPUSH
34351: CALL_OW 456
// end ;
34355: GO 34268
34357: POP
34358: POP
// end ;
34359: LD_VAR 0 3
34363: RET
// export function Count ( array ) ; var i ; begin
34364: LD_INT 0
34366: PPUSH
34367: PPUSH
// result := 0 ;
34368: LD_ADDR_VAR 0 2
34372: PUSH
34373: LD_INT 0
34375: ST_TO_ADDR
// for i in array do
34376: LD_ADDR_VAR 0 3
34380: PUSH
34381: LD_VAR 0 1
34385: PUSH
34386: FOR_IN
34387: IFFALSE 34411
// if i then
34389: LD_VAR 0 3
34393: IFFALSE 34409
// result := result + 1 ;
34395: LD_ADDR_VAR 0 2
34399: PUSH
34400: LD_VAR 0 2
34404: PUSH
34405: LD_INT 1
34407: PLUS
34408: ST_TO_ADDR
34409: GO 34386
34411: POP
34412: POP
// end ;
34413: LD_VAR 0 2
34417: RET
// export function IsEmpty ( building ) ; begin
34418: LD_INT 0
34420: PPUSH
// if not building then
34421: LD_VAR 0 1
34425: NOT
34426: IFFALSE 34430
// exit ;
34428: GO 34473
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
34430: LD_ADDR_VAR 0 2
34434: PUSH
34435: LD_VAR 0 1
34439: PUSH
34440: LD_INT 22
34442: PUSH
34443: LD_VAR 0 1
34447: PPUSH
34448: CALL_OW 255
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 58
34459: PUSH
34460: EMPTY
34461: LIST
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PPUSH
34467: CALL_OW 69
34471: IN
34472: ST_TO_ADDR
// end ;
34473: LD_VAR 0 2
34477: RET
// export function IsNotFull ( building ) ; begin
34478: LD_INT 0
34480: PPUSH
// if not building then
34481: LD_VAR 0 1
34485: NOT
34486: IFFALSE 34490
// exit ;
34488: GO 34509
// result := UnitsInside ( building ) < 6 ;
34490: LD_ADDR_VAR 0 2
34494: PUSH
34495: LD_VAR 0 1
34499: PPUSH
34500: CALL_OW 313
34504: PUSH
34505: LD_INT 6
34507: LESS
34508: ST_TO_ADDR
// end ;
34509: LD_VAR 0 2
34513: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
34514: LD_INT 0
34516: PPUSH
34517: PPUSH
34518: PPUSH
34519: PPUSH
// tmp := [ ] ;
34520: LD_ADDR_VAR 0 3
34524: PUSH
34525: EMPTY
34526: ST_TO_ADDR
// list := [ ] ;
34527: LD_ADDR_VAR 0 5
34531: PUSH
34532: EMPTY
34533: ST_TO_ADDR
// for i = 16 to 25 do
34534: LD_ADDR_VAR 0 4
34538: PUSH
34539: DOUBLE
34540: LD_INT 16
34542: DEC
34543: ST_TO_ADDR
34544: LD_INT 25
34546: PUSH
34547: FOR_TO
34548: IFFALSE 34621
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
34550: LD_ADDR_VAR 0 3
34554: PUSH
34555: LD_VAR 0 3
34559: PUSH
34560: LD_INT 22
34562: PUSH
34563: LD_VAR 0 1
34567: PPUSH
34568: CALL_OW 255
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 91
34579: PUSH
34580: LD_VAR 0 1
34584: PUSH
34585: LD_INT 6
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 30
34595: PUSH
34596: LD_VAR 0 4
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: LIST
34609: PUSH
34610: EMPTY
34611: LIST
34612: PPUSH
34613: CALL_OW 69
34617: ADD
34618: ST_TO_ADDR
34619: GO 34547
34621: POP
34622: POP
// for i = 1 to tmp do
34623: LD_ADDR_VAR 0 4
34627: PUSH
34628: DOUBLE
34629: LD_INT 1
34631: DEC
34632: ST_TO_ADDR
34633: LD_VAR 0 3
34637: PUSH
34638: FOR_TO
34639: IFFALSE 34727
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
34641: LD_ADDR_VAR 0 5
34645: PUSH
34646: LD_VAR 0 5
34650: PUSH
34651: LD_VAR 0 3
34655: PUSH
34656: LD_VAR 0 4
34660: ARRAY
34661: PPUSH
34662: CALL_OW 266
34666: PUSH
34667: LD_VAR 0 3
34671: PUSH
34672: LD_VAR 0 4
34676: ARRAY
34677: PPUSH
34678: CALL_OW 250
34682: PUSH
34683: LD_VAR 0 3
34687: PUSH
34688: LD_VAR 0 4
34692: ARRAY
34693: PPUSH
34694: CALL_OW 251
34698: PUSH
34699: LD_VAR 0 3
34703: PUSH
34704: LD_VAR 0 4
34708: ARRAY
34709: PPUSH
34710: CALL_OW 254
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: PUSH
34721: EMPTY
34722: LIST
34723: ADD
34724: ST_TO_ADDR
34725: GO 34638
34727: POP
34728: POP
// result := list ;
34729: LD_ADDR_VAR 0 2
34733: PUSH
34734: LD_VAR 0 5
34738: ST_TO_ADDR
// end ;
34739: LD_VAR 0 2
34743: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
34744: LD_INT 0
34746: PPUSH
34747: PPUSH
34748: PPUSH
34749: PPUSH
34750: PPUSH
34751: PPUSH
34752: PPUSH
// if not factory then
34753: LD_VAR 0 1
34757: NOT
34758: IFFALSE 34762
// exit ;
34760: GO 35287
// if control = control_apeman then
34762: LD_VAR 0 4
34766: PUSH
34767: LD_INT 5
34769: EQUAL
34770: IFFALSE 34879
// begin tmp := UnitsInside ( factory ) ;
34772: LD_ADDR_VAR 0 8
34776: PUSH
34777: LD_VAR 0 1
34781: PPUSH
34782: CALL_OW 313
34786: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
34787: LD_VAR 0 8
34791: PPUSH
34792: LD_INT 25
34794: PUSH
34795: LD_INT 12
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PPUSH
34802: CALL_OW 72
34806: NOT
34807: IFFALSE 34817
// control := control_manual ;
34809: LD_ADDR_VAR 0 4
34813: PUSH
34814: LD_INT 1
34816: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
34817: LD_ADDR_VAR 0 8
34821: PUSH
34822: LD_VAR 0 1
34826: PPUSH
34827: CALL 34514 0 1
34831: ST_TO_ADDR
// if tmp then
34832: LD_VAR 0 8
34836: IFFALSE 34879
// begin for i in tmp do
34838: LD_ADDR_VAR 0 7
34842: PUSH
34843: LD_VAR 0 8
34847: PUSH
34848: FOR_IN
34849: IFFALSE 34877
// if i [ 1 ] = b_ext_radar then
34851: LD_VAR 0 7
34855: PUSH
34856: LD_INT 1
34858: ARRAY
34859: PUSH
34860: LD_INT 20
34862: EQUAL
34863: IFFALSE 34875
// begin control := control_remote ;
34865: LD_ADDR_VAR 0 4
34869: PUSH
34870: LD_INT 2
34872: ST_TO_ADDR
// break ;
34873: GO 34877
// end ;
34875: GO 34848
34877: POP
34878: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
34879: LD_VAR 0 1
34883: PPUSH
34884: LD_VAR 0 2
34888: PPUSH
34889: LD_VAR 0 3
34893: PPUSH
34894: LD_VAR 0 4
34898: PPUSH
34899: LD_VAR 0 5
34903: PPUSH
34904: CALL_OW 448
34908: IFFALSE 34943
// begin result := [ chassis , engine , control , weapon ] ;
34910: LD_ADDR_VAR 0 6
34914: PUSH
34915: LD_VAR 0 2
34919: PUSH
34920: LD_VAR 0 3
34924: PUSH
34925: LD_VAR 0 4
34929: PUSH
34930: LD_VAR 0 5
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: ST_TO_ADDR
// exit ;
34941: GO 35287
// end ; _chassis := AvailableChassisList ( factory ) ;
34943: LD_ADDR_VAR 0 9
34947: PUSH
34948: LD_VAR 0 1
34952: PPUSH
34953: CALL_OW 475
34957: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
34958: LD_ADDR_VAR 0 11
34962: PUSH
34963: LD_VAR 0 1
34967: PPUSH
34968: CALL_OW 476
34972: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
34973: LD_ADDR_VAR 0 12
34977: PUSH
34978: LD_VAR 0 1
34982: PPUSH
34983: CALL_OW 477
34987: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
34988: LD_ADDR_VAR 0 10
34992: PUSH
34993: LD_VAR 0 1
34997: PPUSH
34998: CALL_OW 478
35002: ST_TO_ADDR
// if not chassis in _chassis then
35003: LD_VAR 0 2
35007: PUSH
35008: LD_VAR 0 9
35012: IN
35013: NOT
35014: IFFALSE 35040
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
35016: LD_ADDR_VAR 0 2
35020: PUSH
35021: LD_VAR 0 9
35025: PUSH
35026: LD_INT 1
35028: PPUSH
35029: LD_VAR 0 9
35033: PPUSH
35034: CALL_OW 12
35038: ARRAY
35039: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
35040: LD_VAR 0 2
35044: PPUSH
35045: LD_VAR 0 3
35049: PPUSH
35050: CALL 35292 0 2
35054: NOT
35055: IFFALSE 35114
// repeat engine := _engine [ 1 ] ;
35057: LD_ADDR_VAR 0 3
35061: PUSH
35062: LD_VAR 0 11
35066: PUSH
35067: LD_INT 1
35069: ARRAY
35070: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
35071: LD_ADDR_VAR 0 11
35075: PUSH
35076: LD_VAR 0 11
35080: PPUSH
35081: LD_INT 1
35083: PPUSH
35084: CALL_OW 3
35088: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
35089: LD_VAR 0 2
35093: PPUSH
35094: LD_VAR 0 3
35098: PPUSH
35099: CALL 35292 0 2
35103: PUSH
35104: LD_VAR 0 11
35108: PUSH
35109: EMPTY
35110: EQUAL
35111: OR
35112: IFFALSE 35057
// if not control in _control then
35114: LD_VAR 0 4
35118: PUSH
35119: LD_VAR 0 12
35123: IN
35124: NOT
35125: IFFALSE 35151
// control := _control [ rand ( 1 , _control ) ] ;
35127: LD_ADDR_VAR 0 4
35131: PUSH
35132: LD_VAR 0 12
35136: PUSH
35137: LD_INT 1
35139: PPUSH
35140: LD_VAR 0 12
35144: PPUSH
35145: CALL_OW 12
35149: ARRAY
35150: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
35151: LD_VAR 0 2
35155: PPUSH
35156: LD_VAR 0 5
35160: PPUSH
35161: CALL 35512 0 2
35165: NOT
35166: IFFALSE 35225
// repeat weapon := _weapon [ 1 ] ;
35168: LD_ADDR_VAR 0 5
35172: PUSH
35173: LD_VAR 0 10
35177: PUSH
35178: LD_INT 1
35180: ARRAY
35181: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
35182: LD_ADDR_VAR 0 10
35186: PUSH
35187: LD_VAR 0 10
35191: PPUSH
35192: LD_INT 1
35194: PPUSH
35195: CALL_OW 3
35199: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
35200: LD_VAR 0 2
35204: PPUSH
35205: LD_VAR 0 5
35209: PPUSH
35210: CALL 35512 0 2
35214: PUSH
35215: LD_VAR 0 10
35219: PUSH
35220: EMPTY
35221: EQUAL
35222: OR
35223: IFFALSE 35168
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
35225: LD_VAR 0 1
35229: PPUSH
35230: LD_VAR 0 2
35234: PPUSH
35235: LD_VAR 0 3
35239: PPUSH
35240: LD_VAR 0 4
35244: PPUSH
35245: LD_VAR 0 5
35249: PPUSH
35250: CALL_OW 448
35254: IFFALSE 35287
// result := [ chassis , engine , control , weapon ] ;
35256: LD_ADDR_VAR 0 6
35260: PUSH
35261: LD_VAR 0 2
35265: PUSH
35266: LD_VAR 0 3
35270: PUSH
35271: LD_VAR 0 4
35275: PUSH
35276: LD_VAR 0 5
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: ST_TO_ADDR
// end ;
35287: LD_VAR 0 6
35291: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
35292: LD_INT 0
35294: PPUSH
// if not chassis or not engine then
35295: LD_VAR 0 1
35299: NOT
35300: PUSH
35301: LD_VAR 0 2
35305: NOT
35306: OR
35307: IFFALSE 35311
// exit ;
35309: GO 35507
// case engine of engine_solar :
35311: LD_VAR 0 2
35315: PUSH
35316: LD_INT 2
35318: DOUBLE
35319: EQUAL
35320: IFTRUE 35324
35322: GO 35362
35324: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
35325: LD_ADDR_VAR 0 3
35329: PUSH
35330: LD_INT 11
35332: PUSH
35333: LD_INT 12
35335: PUSH
35336: LD_INT 13
35338: PUSH
35339: LD_INT 14
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: LD_INT 2
35347: PUSH
35348: LD_INT 3
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: ST_TO_ADDR
35360: GO 35491
35362: LD_INT 1
35364: DOUBLE
35365: EQUAL
35366: IFTRUE 35370
35368: GO 35432
35370: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
35371: LD_ADDR_VAR 0 3
35375: PUSH
35376: LD_INT 11
35378: PUSH
35379: LD_INT 12
35381: PUSH
35382: LD_INT 13
35384: PUSH
35385: LD_INT 14
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: LD_INT 2
35393: PUSH
35394: LD_INT 3
35396: PUSH
35397: LD_INT 4
35399: PUSH
35400: LD_INT 5
35402: PUSH
35403: LD_INT 21
35405: PUSH
35406: LD_INT 23
35408: PUSH
35409: LD_INT 22
35411: PUSH
35412: LD_INT 24
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: ST_TO_ADDR
35430: GO 35491
35432: LD_INT 3
35434: DOUBLE
35435: EQUAL
35436: IFTRUE 35440
35438: GO 35490
35440: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
35441: LD_ADDR_VAR 0 3
35445: PUSH
35446: LD_INT 13
35448: PUSH
35449: LD_INT 14
35451: PUSH
35452: LD_INT 2
35454: PUSH
35455: LD_INT 3
35457: PUSH
35458: LD_INT 4
35460: PUSH
35461: LD_INT 5
35463: PUSH
35464: LD_INT 21
35466: PUSH
35467: LD_INT 22
35469: PUSH
35470: LD_INT 23
35472: PUSH
35473: LD_INT 24
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: ST_TO_ADDR
35488: GO 35491
35490: POP
// result := ( chassis in result ) ;
35491: LD_ADDR_VAR 0 3
35495: PUSH
35496: LD_VAR 0 1
35500: PUSH
35501: LD_VAR 0 3
35505: IN
35506: ST_TO_ADDR
// end ;
35507: LD_VAR 0 3
35511: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
35512: LD_INT 0
35514: PPUSH
// if not chassis or not weapon then
35515: LD_VAR 0 1
35519: NOT
35520: PUSH
35521: LD_VAR 0 2
35525: NOT
35526: OR
35527: IFFALSE 35531
// exit ;
35529: GO 36557
// case weapon of us_machine_gun :
35531: LD_VAR 0 2
35535: PUSH
35536: LD_INT 2
35538: DOUBLE
35539: EQUAL
35540: IFTRUE 35544
35542: GO 35574
35544: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
35545: LD_ADDR_VAR 0 3
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: LD_INT 2
35555: PUSH
35556: LD_INT 3
35558: PUSH
35559: LD_INT 4
35561: PUSH
35562: LD_INT 5
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: ST_TO_ADDR
35572: GO 36541
35574: LD_INT 3
35576: DOUBLE
35577: EQUAL
35578: IFTRUE 35582
35580: GO 35612
35582: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
35583: LD_ADDR_VAR 0 3
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: LD_INT 3
35596: PUSH
35597: LD_INT 4
35599: PUSH
35600: LD_INT 5
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: LIST
35607: LIST
35608: LIST
35609: ST_TO_ADDR
35610: GO 36541
35612: LD_INT 11
35614: DOUBLE
35615: EQUAL
35616: IFTRUE 35620
35618: GO 35650
35620: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
35621: LD_ADDR_VAR 0 3
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: LD_INT 2
35631: PUSH
35632: LD_INT 3
35634: PUSH
35635: LD_INT 4
35637: PUSH
35638: LD_INT 5
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: ST_TO_ADDR
35648: GO 36541
35650: LD_INT 4
35652: DOUBLE
35653: EQUAL
35654: IFTRUE 35658
35656: GO 35684
35658: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
35659: LD_ADDR_VAR 0 3
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: LD_INT 3
35669: PUSH
35670: LD_INT 4
35672: PUSH
35673: LD_INT 5
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: ST_TO_ADDR
35682: GO 36541
35684: LD_INT 5
35686: DOUBLE
35687: EQUAL
35688: IFTRUE 35692
35690: GO 35718
35692: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
35693: LD_ADDR_VAR 0 3
35697: PUSH
35698: LD_INT 2
35700: PUSH
35701: LD_INT 3
35703: PUSH
35704: LD_INT 4
35706: PUSH
35707: LD_INT 5
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: ST_TO_ADDR
35716: GO 36541
35718: LD_INT 9
35720: DOUBLE
35721: EQUAL
35722: IFTRUE 35726
35724: GO 35752
35726: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
35727: LD_ADDR_VAR 0 3
35731: PUSH
35732: LD_INT 2
35734: PUSH
35735: LD_INT 3
35737: PUSH
35738: LD_INT 4
35740: PUSH
35741: LD_INT 5
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: ST_TO_ADDR
35750: GO 36541
35752: LD_INT 7
35754: DOUBLE
35755: EQUAL
35756: IFTRUE 35760
35758: GO 35786
35760: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
35761: LD_ADDR_VAR 0 3
35765: PUSH
35766: LD_INT 2
35768: PUSH
35769: LD_INT 3
35771: PUSH
35772: LD_INT 4
35774: PUSH
35775: LD_INT 5
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: ST_TO_ADDR
35784: GO 36541
35786: LD_INT 12
35788: DOUBLE
35789: EQUAL
35790: IFTRUE 35794
35792: GO 35820
35794: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
35795: LD_ADDR_VAR 0 3
35799: PUSH
35800: LD_INT 2
35802: PUSH
35803: LD_INT 3
35805: PUSH
35806: LD_INT 4
35808: PUSH
35809: LD_INT 5
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: ST_TO_ADDR
35818: GO 36541
35820: LD_INT 13
35822: DOUBLE
35823: EQUAL
35824: IFTRUE 35828
35826: GO 35854
35828: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
35829: LD_ADDR_VAR 0 3
35833: PUSH
35834: LD_INT 2
35836: PUSH
35837: LD_INT 3
35839: PUSH
35840: LD_INT 4
35842: PUSH
35843: LD_INT 5
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: ST_TO_ADDR
35852: GO 36541
35854: LD_INT 14
35856: DOUBLE
35857: EQUAL
35858: IFTRUE 35862
35860: GO 35880
35862: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
35863: LD_ADDR_VAR 0 3
35867: PUSH
35868: LD_INT 4
35870: PUSH
35871: LD_INT 5
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: ST_TO_ADDR
35878: GO 36541
35880: LD_INT 6
35882: DOUBLE
35883: EQUAL
35884: IFTRUE 35888
35886: GO 35906
35888: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
35889: LD_ADDR_VAR 0 3
35893: PUSH
35894: LD_INT 4
35896: PUSH
35897: LD_INT 5
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: ST_TO_ADDR
35904: GO 36541
35906: LD_INT 10
35908: DOUBLE
35909: EQUAL
35910: IFTRUE 35914
35912: GO 35932
35914: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
35915: LD_ADDR_VAR 0 3
35919: PUSH
35920: LD_INT 4
35922: PUSH
35923: LD_INT 5
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: ST_TO_ADDR
35930: GO 36541
35932: LD_INT 22
35934: DOUBLE
35935: EQUAL
35936: IFTRUE 35940
35938: GO 35966
35940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
35941: LD_ADDR_VAR 0 3
35945: PUSH
35946: LD_INT 11
35948: PUSH
35949: LD_INT 12
35951: PUSH
35952: LD_INT 13
35954: PUSH
35955: LD_INT 14
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: ST_TO_ADDR
35964: GO 36541
35966: LD_INT 23
35968: DOUBLE
35969: EQUAL
35970: IFTRUE 35974
35972: GO 36000
35974: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
35975: LD_ADDR_VAR 0 3
35979: PUSH
35980: LD_INT 11
35982: PUSH
35983: LD_INT 12
35985: PUSH
35986: LD_INT 13
35988: PUSH
35989: LD_INT 14
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: ST_TO_ADDR
35998: GO 36541
36000: LD_INT 24
36002: DOUBLE
36003: EQUAL
36004: IFTRUE 36008
36006: GO 36034
36008: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
36009: LD_ADDR_VAR 0 3
36013: PUSH
36014: LD_INT 11
36016: PUSH
36017: LD_INT 12
36019: PUSH
36020: LD_INT 13
36022: PUSH
36023: LD_INT 14
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: LIST
36030: LIST
36031: ST_TO_ADDR
36032: GO 36541
36034: LD_INT 30
36036: DOUBLE
36037: EQUAL
36038: IFTRUE 36042
36040: GO 36068
36042: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
36043: LD_ADDR_VAR 0 3
36047: PUSH
36048: LD_INT 11
36050: PUSH
36051: LD_INT 12
36053: PUSH
36054: LD_INT 13
36056: PUSH
36057: LD_INT 14
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: LIST
36064: LIST
36065: ST_TO_ADDR
36066: GO 36541
36068: LD_INT 25
36070: DOUBLE
36071: EQUAL
36072: IFTRUE 36076
36074: GO 36094
36076: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
36077: LD_ADDR_VAR 0 3
36081: PUSH
36082: LD_INT 13
36084: PUSH
36085: LD_INT 14
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: ST_TO_ADDR
36092: GO 36541
36094: LD_INT 27
36096: DOUBLE
36097: EQUAL
36098: IFTRUE 36102
36100: GO 36120
36102: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
36103: LD_ADDR_VAR 0 3
36107: PUSH
36108: LD_INT 13
36110: PUSH
36111: LD_INT 14
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: ST_TO_ADDR
36118: GO 36541
36120: LD_INT 28
36122: DOUBLE
36123: EQUAL
36124: IFTRUE 36128
36126: GO 36146
36128: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
36129: LD_ADDR_VAR 0 3
36133: PUSH
36134: LD_INT 13
36136: PUSH
36137: LD_INT 14
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: ST_TO_ADDR
36144: GO 36541
36146: LD_INT 29
36148: DOUBLE
36149: EQUAL
36150: IFTRUE 36154
36152: GO 36172
36154: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
36155: LD_ADDR_VAR 0 3
36159: PUSH
36160: LD_INT 13
36162: PUSH
36163: LD_INT 14
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: ST_TO_ADDR
36170: GO 36541
36172: LD_INT 31
36174: DOUBLE
36175: EQUAL
36176: IFTRUE 36180
36178: GO 36198
36180: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
36181: LD_ADDR_VAR 0 3
36185: PUSH
36186: LD_INT 13
36188: PUSH
36189: LD_INT 14
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: ST_TO_ADDR
36196: GO 36541
36198: LD_INT 26
36200: DOUBLE
36201: EQUAL
36202: IFTRUE 36206
36204: GO 36224
36206: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
36207: LD_ADDR_VAR 0 3
36211: PUSH
36212: LD_INT 13
36214: PUSH
36215: LD_INT 14
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: ST_TO_ADDR
36222: GO 36541
36224: LD_INT 42
36226: DOUBLE
36227: EQUAL
36228: IFTRUE 36232
36230: GO 36258
36232: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
36233: LD_ADDR_VAR 0 3
36237: PUSH
36238: LD_INT 21
36240: PUSH
36241: LD_INT 22
36243: PUSH
36244: LD_INT 23
36246: PUSH
36247: LD_INT 24
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: ST_TO_ADDR
36256: GO 36541
36258: LD_INT 43
36260: DOUBLE
36261: EQUAL
36262: IFTRUE 36266
36264: GO 36292
36266: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
36267: LD_ADDR_VAR 0 3
36271: PUSH
36272: LD_INT 21
36274: PUSH
36275: LD_INT 22
36277: PUSH
36278: LD_INT 23
36280: PUSH
36281: LD_INT 24
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: ST_TO_ADDR
36290: GO 36541
36292: LD_INT 44
36294: DOUBLE
36295: EQUAL
36296: IFTRUE 36300
36298: GO 36326
36300: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
36301: LD_ADDR_VAR 0 3
36305: PUSH
36306: LD_INT 21
36308: PUSH
36309: LD_INT 22
36311: PUSH
36312: LD_INT 23
36314: PUSH
36315: LD_INT 24
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: ST_TO_ADDR
36324: GO 36541
36326: LD_INT 45
36328: DOUBLE
36329: EQUAL
36330: IFTRUE 36334
36332: GO 36360
36334: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
36335: LD_ADDR_VAR 0 3
36339: PUSH
36340: LD_INT 21
36342: PUSH
36343: LD_INT 22
36345: PUSH
36346: LD_INT 23
36348: PUSH
36349: LD_INT 24
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: ST_TO_ADDR
36358: GO 36541
36360: LD_INT 49
36362: DOUBLE
36363: EQUAL
36364: IFTRUE 36368
36366: GO 36394
36368: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
36369: LD_ADDR_VAR 0 3
36373: PUSH
36374: LD_INT 21
36376: PUSH
36377: LD_INT 22
36379: PUSH
36380: LD_INT 23
36382: PUSH
36383: LD_INT 24
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: ST_TO_ADDR
36392: GO 36541
36394: LD_INT 51
36396: DOUBLE
36397: EQUAL
36398: IFTRUE 36402
36400: GO 36428
36402: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
36403: LD_ADDR_VAR 0 3
36407: PUSH
36408: LD_INT 21
36410: PUSH
36411: LD_INT 22
36413: PUSH
36414: LD_INT 23
36416: PUSH
36417: LD_INT 24
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: LIST
36424: LIST
36425: ST_TO_ADDR
36426: GO 36541
36428: LD_INT 52
36430: DOUBLE
36431: EQUAL
36432: IFTRUE 36436
36434: GO 36462
36436: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
36437: LD_ADDR_VAR 0 3
36441: PUSH
36442: LD_INT 21
36444: PUSH
36445: LD_INT 22
36447: PUSH
36448: LD_INT 23
36450: PUSH
36451: LD_INT 24
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: ST_TO_ADDR
36460: GO 36541
36462: LD_INT 53
36464: DOUBLE
36465: EQUAL
36466: IFTRUE 36470
36468: GO 36488
36470: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
36471: LD_ADDR_VAR 0 3
36475: PUSH
36476: LD_INT 23
36478: PUSH
36479: LD_INT 24
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: ST_TO_ADDR
36486: GO 36541
36488: LD_INT 46
36490: DOUBLE
36491: EQUAL
36492: IFTRUE 36496
36494: GO 36514
36496: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
36497: LD_ADDR_VAR 0 3
36501: PUSH
36502: LD_INT 23
36504: PUSH
36505: LD_INT 24
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: ST_TO_ADDR
36512: GO 36541
36514: LD_INT 47
36516: DOUBLE
36517: EQUAL
36518: IFTRUE 36522
36520: GO 36540
36522: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
36523: LD_ADDR_VAR 0 3
36527: PUSH
36528: LD_INT 23
36530: PUSH
36531: LD_INT 24
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: ST_TO_ADDR
36538: GO 36541
36540: POP
// result := ( chassis in result ) ;
36541: LD_ADDR_VAR 0 3
36545: PUSH
36546: LD_VAR 0 1
36550: PUSH
36551: LD_VAR 0 3
36555: IN
36556: ST_TO_ADDR
// end ;
36557: LD_VAR 0 3
36561: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
36562: LD_INT 0
36564: PPUSH
36565: PPUSH
36566: PPUSH
36567: PPUSH
36568: PPUSH
36569: PPUSH
36570: PPUSH
// result := array ;
36571: LD_ADDR_VAR 0 5
36575: PUSH
36576: LD_VAR 0 1
36580: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
36581: LD_VAR 0 1
36585: NOT
36586: PUSH
36587: LD_VAR 0 2
36591: NOT
36592: OR
36593: PUSH
36594: LD_VAR 0 3
36598: NOT
36599: OR
36600: PUSH
36601: LD_VAR 0 2
36605: PUSH
36606: LD_VAR 0 1
36610: GREATER
36611: OR
36612: PUSH
36613: LD_VAR 0 3
36617: PUSH
36618: LD_VAR 0 1
36622: GREATER
36623: OR
36624: IFFALSE 36628
// exit ;
36626: GO 36924
// if direction then
36628: LD_VAR 0 4
36632: IFFALSE 36696
// begin d := 1 ;
36634: LD_ADDR_VAR 0 9
36638: PUSH
36639: LD_INT 1
36641: ST_TO_ADDR
// if i_from > i_to then
36642: LD_VAR 0 2
36646: PUSH
36647: LD_VAR 0 3
36651: GREATER
36652: IFFALSE 36678
// length := ( array - i_from ) + i_to else
36654: LD_ADDR_VAR 0 11
36658: PUSH
36659: LD_VAR 0 1
36663: PUSH
36664: LD_VAR 0 2
36668: MINUS
36669: PUSH
36670: LD_VAR 0 3
36674: PLUS
36675: ST_TO_ADDR
36676: GO 36694
// length := i_to - i_from ;
36678: LD_ADDR_VAR 0 11
36682: PUSH
36683: LD_VAR 0 3
36687: PUSH
36688: LD_VAR 0 2
36692: MINUS
36693: ST_TO_ADDR
// end else
36694: GO 36757
// begin d := - 1 ;
36696: LD_ADDR_VAR 0 9
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: ST_TO_ADDR
// if i_from > i_to then
36705: LD_VAR 0 2
36709: PUSH
36710: LD_VAR 0 3
36714: GREATER
36715: IFFALSE 36735
// length := i_from - i_to else
36717: LD_ADDR_VAR 0 11
36721: PUSH
36722: LD_VAR 0 2
36726: PUSH
36727: LD_VAR 0 3
36731: MINUS
36732: ST_TO_ADDR
36733: GO 36757
// length := ( array - i_to ) + i_from ;
36735: LD_ADDR_VAR 0 11
36739: PUSH
36740: LD_VAR 0 1
36744: PUSH
36745: LD_VAR 0 3
36749: MINUS
36750: PUSH
36751: LD_VAR 0 2
36755: PLUS
36756: ST_TO_ADDR
// end ; if not length then
36757: LD_VAR 0 11
36761: NOT
36762: IFFALSE 36766
// exit ;
36764: GO 36924
// tmp := array ;
36766: LD_ADDR_VAR 0 10
36770: PUSH
36771: LD_VAR 0 1
36775: ST_TO_ADDR
// for i = 1 to length do
36776: LD_ADDR_VAR 0 6
36780: PUSH
36781: DOUBLE
36782: LD_INT 1
36784: DEC
36785: ST_TO_ADDR
36786: LD_VAR 0 11
36790: PUSH
36791: FOR_TO
36792: IFFALSE 36912
// begin for j = 1 to array do
36794: LD_ADDR_VAR 0 7
36798: PUSH
36799: DOUBLE
36800: LD_INT 1
36802: DEC
36803: ST_TO_ADDR
36804: LD_VAR 0 1
36808: PUSH
36809: FOR_TO
36810: IFFALSE 36898
// begin k := j + d ;
36812: LD_ADDR_VAR 0 8
36816: PUSH
36817: LD_VAR 0 7
36821: PUSH
36822: LD_VAR 0 9
36826: PLUS
36827: ST_TO_ADDR
// if k > array then
36828: LD_VAR 0 8
36832: PUSH
36833: LD_VAR 0 1
36837: GREATER
36838: IFFALSE 36848
// k := 1 ;
36840: LD_ADDR_VAR 0 8
36844: PUSH
36845: LD_INT 1
36847: ST_TO_ADDR
// if not k then
36848: LD_VAR 0 8
36852: NOT
36853: IFFALSE 36865
// k := array ;
36855: LD_ADDR_VAR 0 8
36859: PUSH
36860: LD_VAR 0 1
36864: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
36865: LD_ADDR_VAR 0 10
36869: PUSH
36870: LD_VAR 0 10
36874: PPUSH
36875: LD_VAR 0 8
36879: PPUSH
36880: LD_VAR 0 1
36884: PUSH
36885: LD_VAR 0 7
36889: ARRAY
36890: PPUSH
36891: CALL_OW 1
36895: ST_TO_ADDR
// end ;
36896: GO 36809
36898: POP
36899: POP
// array := tmp ;
36900: LD_ADDR_VAR 0 1
36904: PUSH
36905: LD_VAR 0 10
36909: ST_TO_ADDR
// end ;
36910: GO 36791
36912: POP
36913: POP
// result := array ;
36914: LD_ADDR_VAR 0 5
36918: PUSH
36919: LD_VAR 0 1
36923: ST_TO_ADDR
// end ;
36924: LD_VAR 0 5
36928: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
36929: LD_INT 0
36931: PPUSH
36932: PPUSH
// result := 0 ;
36933: LD_ADDR_VAR 0 3
36937: PUSH
36938: LD_INT 0
36940: ST_TO_ADDR
// if not array or not value in array then
36941: LD_VAR 0 1
36945: NOT
36946: PUSH
36947: LD_VAR 0 2
36951: PUSH
36952: LD_VAR 0 1
36956: IN
36957: NOT
36958: OR
36959: IFFALSE 36963
// exit ;
36961: GO 37017
// for i = 1 to array do
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: DOUBLE
36969: LD_INT 1
36971: DEC
36972: ST_TO_ADDR
36973: LD_VAR 0 1
36977: PUSH
36978: FOR_TO
36979: IFFALSE 37015
// if value = array [ i ] then
36981: LD_VAR 0 2
36985: PUSH
36986: LD_VAR 0 1
36990: PUSH
36991: LD_VAR 0 4
36995: ARRAY
36996: EQUAL
36997: IFFALSE 37013
// begin result := i ;
36999: LD_ADDR_VAR 0 3
37003: PUSH
37004: LD_VAR 0 4
37008: ST_TO_ADDR
// exit ;
37009: POP
37010: POP
37011: GO 37017
// end ;
37013: GO 36978
37015: POP
37016: POP
// end ;
37017: LD_VAR 0 3
37021: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
37022: LD_INT 0
37024: PPUSH
// vc_chassis := chassis ;
37025: LD_ADDR_OWVAR 37
37029: PUSH
37030: LD_VAR 0 1
37034: ST_TO_ADDR
// vc_engine := engine ;
37035: LD_ADDR_OWVAR 39
37039: PUSH
37040: LD_VAR 0 2
37044: ST_TO_ADDR
// vc_control := control ;
37045: LD_ADDR_OWVAR 38
37049: PUSH
37050: LD_VAR 0 3
37054: ST_TO_ADDR
// vc_weapon := weapon ;
37055: LD_ADDR_OWVAR 40
37059: PUSH
37060: LD_VAR 0 4
37064: ST_TO_ADDR
// vc_fuel_battery := fuel ;
37065: LD_ADDR_OWVAR 41
37069: PUSH
37070: LD_VAR 0 5
37074: ST_TO_ADDR
// end ;
37075: LD_VAR 0 6
37079: RET
// export function WantPlant ( unit ) ; var task ; begin
37080: LD_INT 0
37082: PPUSH
37083: PPUSH
// result := false ;
37084: LD_ADDR_VAR 0 2
37088: PUSH
37089: LD_INT 0
37091: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
37092: LD_ADDR_VAR 0 3
37096: PUSH
37097: LD_VAR 0 1
37101: PPUSH
37102: CALL_OW 437
37106: ST_TO_ADDR
// if task then
37107: LD_VAR 0 3
37111: IFFALSE 37139
// if task [ 1 ] [ 1 ] = p then
37113: LD_VAR 0 3
37117: PUSH
37118: LD_INT 1
37120: ARRAY
37121: PUSH
37122: LD_INT 1
37124: ARRAY
37125: PUSH
37126: LD_STRING p
37128: EQUAL
37129: IFFALSE 37139
// result := true ;
37131: LD_ADDR_VAR 0 2
37135: PUSH
37136: LD_INT 1
37138: ST_TO_ADDR
// end ;
37139: LD_VAR 0 2
37143: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
37144: LD_INT 0
37146: PPUSH
37147: PPUSH
37148: PPUSH
37149: PPUSH
// if pos < 1 then
37150: LD_VAR 0 2
37154: PUSH
37155: LD_INT 1
37157: LESS
37158: IFFALSE 37162
// exit ;
37160: GO 37465
// if pos = 1 then
37162: LD_VAR 0 2
37166: PUSH
37167: LD_INT 1
37169: EQUAL
37170: IFFALSE 37203
// result := Replace ( arr , pos [ 1 ] , value ) else
37172: LD_ADDR_VAR 0 4
37176: PUSH
37177: LD_VAR 0 1
37181: PPUSH
37182: LD_VAR 0 2
37186: PUSH
37187: LD_INT 1
37189: ARRAY
37190: PPUSH
37191: LD_VAR 0 3
37195: PPUSH
37196: CALL_OW 1
37200: ST_TO_ADDR
37201: GO 37465
// begin tmp := arr ;
37203: LD_ADDR_VAR 0 6
37207: PUSH
37208: LD_VAR 0 1
37212: ST_TO_ADDR
// s_arr := [ tmp ] ;
37213: LD_ADDR_VAR 0 7
37217: PUSH
37218: LD_VAR 0 6
37222: PUSH
37223: EMPTY
37224: LIST
37225: ST_TO_ADDR
// for i = 1 to pos - 1 do
37226: LD_ADDR_VAR 0 5
37230: PUSH
37231: DOUBLE
37232: LD_INT 1
37234: DEC
37235: ST_TO_ADDR
37236: LD_VAR 0 2
37240: PUSH
37241: LD_INT 1
37243: MINUS
37244: PUSH
37245: FOR_TO
37246: IFFALSE 37291
// begin tmp := tmp [ pos [ i ] ] ;
37248: LD_ADDR_VAR 0 6
37252: PUSH
37253: LD_VAR 0 6
37257: PUSH
37258: LD_VAR 0 2
37262: PUSH
37263: LD_VAR 0 5
37267: ARRAY
37268: ARRAY
37269: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
37270: LD_ADDR_VAR 0 7
37274: PUSH
37275: LD_VAR 0 7
37279: PUSH
37280: LD_VAR 0 6
37284: PUSH
37285: EMPTY
37286: LIST
37287: ADD
37288: ST_TO_ADDR
// end ;
37289: GO 37245
37291: POP
37292: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
37293: LD_ADDR_VAR 0 6
37297: PUSH
37298: LD_VAR 0 6
37302: PPUSH
37303: LD_VAR 0 2
37307: PUSH
37308: LD_VAR 0 2
37312: ARRAY
37313: PPUSH
37314: LD_VAR 0 3
37318: PPUSH
37319: CALL_OW 1
37323: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
37324: LD_ADDR_VAR 0 7
37328: PUSH
37329: LD_VAR 0 7
37333: PPUSH
37334: LD_VAR 0 7
37338: PPUSH
37339: LD_VAR 0 6
37343: PPUSH
37344: CALL_OW 1
37348: ST_TO_ADDR
// for i = s_arr downto 2 do
37349: LD_ADDR_VAR 0 5
37353: PUSH
37354: DOUBLE
37355: LD_VAR 0 7
37359: INC
37360: ST_TO_ADDR
37361: LD_INT 2
37363: PUSH
37364: FOR_DOWNTO
37365: IFFALSE 37449
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
37367: LD_ADDR_VAR 0 6
37371: PUSH
37372: LD_VAR 0 7
37376: PUSH
37377: LD_VAR 0 5
37381: PUSH
37382: LD_INT 1
37384: MINUS
37385: ARRAY
37386: PPUSH
37387: LD_VAR 0 2
37391: PUSH
37392: LD_VAR 0 5
37396: PUSH
37397: LD_INT 1
37399: MINUS
37400: ARRAY
37401: PPUSH
37402: LD_VAR 0 7
37406: PUSH
37407: LD_VAR 0 5
37411: ARRAY
37412: PPUSH
37413: CALL_OW 1
37417: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
37418: LD_ADDR_VAR 0 7
37422: PUSH
37423: LD_VAR 0 7
37427: PPUSH
37428: LD_VAR 0 5
37432: PUSH
37433: LD_INT 1
37435: MINUS
37436: PPUSH
37437: LD_VAR 0 6
37441: PPUSH
37442: CALL_OW 1
37446: ST_TO_ADDR
// end ;
37447: GO 37364
37449: POP
37450: POP
// result := s_arr [ 1 ] ;
37451: LD_ADDR_VAR 0 4
37455: PUSH
37456: LD_VAR 0 7
37460: PUSH
37461: LD_INT 1
37463: ARRAY
37464: ST_TO_ADDR
// end ; end ;
37465: LD_VAR 0 4
37469: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
37470: LD_INT 0
37472: PPUSH
37473: PPUSH
// if not list then
37474: LD_VAR 0 1
37478: NOT
37479: IFFALSE 37483
// exit ;
37481: GO 37574
// i := list [ pos1 ] ;
37483: LD_ADDR_VAR 0 5
37487: PUSH
37488: LD_VAR 0 1
37492: PUSH
37493: LD_VAR 0 2
37497: ARRAY
37498: ST_TO_ADDR
// if not i then
37499: LD_VAR 0 5
37503: NOT
37504: IFFALSE 37508
// exit ;
37506: GO 37574
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
37508: LD_ADDR_VAR 0 1
37512: PUSH
37513: LD_VAR 0 1
37517: PPUSH
37518: LD_VAR 0 2
37522: PPUSH
37523: LD_VAR 0 1
37527: PUSH
37528: LD_VAR 0 3
37532: ARRAY
37533: PPUSH
37534: CALL_OW 1
37538: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
37539: LD_ADDR_VAR 0 1
37543: PUSH
37544: LD_VAR 0 1
37548: PPUSH
37549: LD_VAR 0 3
37553: PPUSH
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 1
37563: ST_TO_ADDR
// result := list ;
37564: LD_ADDR_VAR 0 4
37568: PUSH
37569: LD_VAR 0 1
37573: ST_TO_ADDR
// end ;
37574: LD_VAR 0 4
37578: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
37579: LD_INT 0
37581: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
37582: LD_ADDR_VAR 0 5
37586: PUSH
37587: LD_VAR 0 1
37591: PPUSH
37592: CALL_OW 250
37596: PPUSH
37597: LD_VAR 0 1
37601: PPUSH
37602: CALL_OW 251
37606: PPUSH
37607: LD_VAR 0 2
37611: PPUSH
37612: LD_VAR 0 3
37616: PPUSH
37617: LD_VAR 0 4
37621: PPUSH
37622: CALL 37632 0 5
37626: ST_TO_ADDR
// end ;
37627: LD_VAR 0 5
37631: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
37632: LD_INT 0
37634: PPUSH
37635: PPUSH
37636: PPUSH
37637: PPUSH
// if not list then
37638: LD_VAR 0 3
37642: NOT
37643: IFFALSE 37647
// exit ;
37645: GO 38035
// result := [ ] ;
37647: LD_ADDR_VAR 0 6
37651: PUSH
37652: EMPTY
37653: ST_TO_ADDR
// for i in list do
37654: LD_ADDR_VAR 0 7
37658: PUSH
37659: LD_VAR 0 3
37663: PUSH
37664: FOR_IN
37665: IFFALSE 37867
// begin tmp := GetDistUnitXY ( i , x , y ) ;
37667: LD_ADDR_VAR 0 9
37671: PUSH
37672: LD_VAR 0 7
37676: PPUSH
37677: LD_VAR 0 1
37681: PPUSH
37682: LD_VAR 0 2
37686: PPUSH
37687: CALL_OW 297
37691: ST_TO_ADDR
// if not result then
37692: LD_VAR 0 6
37696: NOT
37697: IFFALSE 37723
// result := [ [ i , tmp ] ] else
37699: LD_ADDR_VAR 0 6
37703: PUSH
37704: LD_VAR 0 7
37708: PUSH
37709: LD_VAR 0 9
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: EMPTY
37719: LIST
37720: ST_TO_ADDR
37721: GO 37865
// begin if result [ result ] [ 2 ] < tmp then
37723: LD_VAR 0 6
37727: PUSH
37728: LD_VAR 0 6
37732: ARRAY
37733: PUSH
37734: LD_INT 2
37736: ARRAY
37737: PUSH
37738: LD_VAR 0 9
37742: LESS
37743: IFFALSE 37785
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
37745: LD_ADDR_VAR 0 6
37749: PUSH
37750: LD_VAR 0 6
37754: PPUSH
37755: LD_VAR 0 6
37759: PUSH
37760: LD_INT 1
37762: PLUS
37763: PPUSH
37764: LD_VAR 0 7
37768: PUSH
37769: LD_VAR 0 9
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PPUSH
37778: CALL_OW 2
37782: ST_TO_ADDR
37783: GO 37865
// for j = 1 to result do
37785: LD_ADDR_VAR 0 8
37789: PUSH
37790: DOUBLE
37791: LD_INT 1
37793: DEC
37794: ST_TO_ADDR
37795: LD_VAR 0 6
37799: PUSH
37800: FOR_TO
37801: IFFALSE 37863
// begin if tmp < result [ j ] [ 2 ] then
37803: LD_VAR 0 9
37807: PUSH
37808: LD_VAR 0 6
37812: PUSH
37813: LD_VAR 0 8
37817: ARRAY
37818: PUSH
37819: LD_INT 2
37821: ARRAY
37822: LESS
37823: IFFALSE 37861
// begin result := Insert ( result , j , [ i , tmp ] ) ;
37825: LD_ADDR_VAR 0 6
37829: PUSH
37830: LD_VAR 0 6
37834: PPUSH
37835: LD_VAR 0 8
37839: PPUSH
37840: LD_VAR 0 7
37844: PUSH
37845: LD_VAR 0 9
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PPUSH
37854: CALL_OW 2
37858: ST_TO_ADDR
// break ;
37859: GO 37863
// end ; end ;
37861: GO 37800
37863: POP
37864: POP
// end ; end ;
37865: GO 37664
37867: POP
37868: POP
// if result and not asc then
37869: LD_VAR 0 6
37873: PUSH
37874: LD_VAR 0 4
37878: NOT
37879: AND
37880: IFFALSE 37955
// begin tmp := result ;
37882: LD_ADDR_VAR 0 9
37886: PUSH
37887: LD_VAR 0 6
37891: ST_TO_ADDR
// for i = tmp downto 1 do
37892: LD_ADDR_VAR 0 7
37896: PUSH
37897: DOUBLE
37898: LD_VAR 0 9
37902: INC
37903: ST_TO_ADDR
37904: LD_INT 1
37906: PUSH
37907: FOR_DOWNTO
37908: IFFALSE 37953
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
37910: LD_ADDR_VAR 0 6
37914: PUSH
37915: LD_VAR 0 6
37919: PPUSH
37920: LD_VAR 0 9
37924: PUSH
37925: LD_VAR 0 7
37929: MINUS
37930: PUSH
37931: LD_INT 1
37933: PLUS
37934: PPUSH
37935: LD_VAR 0 9
37939: PUSH
37940: LD_VAR 0 7
37944: ARRAY
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
37951: GO 37907
37953: POP
37954: POP
// end ; tmp := [ ] ;
37955: LD_ADDR_VAR 0 9
37959: PUSH
37960: EMPTY
37961: ST_TO_ADDR
// if mode then
37962: LD_VAR 0 5
37966: IFFALSE 38035
// begin for i = 1 to result do
37968: LD_ADDR_VAR 0 7
37972: PUSH
37973: DOUBLE
37974: LD_INT 1
37976: DEC
37977: ST_TO_ADDR
37978: LD_VAR 0 6
37982: PUSH
37983: FOR_TO
37984: IFFALSE 38023
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
37986: LD_ADDR_VAR 0 9
37990: PUSH
37991: LD_VAR 0 9
37995: PPUSH
37996: LD_VAR 0 7
38000: PPUSH
38001: LD_VAR 0 6
38005: PUSH
38006: LD_VAR 0 7
38010: ARRAY
38011: PUSH
38012: LD_INT 1
38014: ARRAY
38015: PPUSH
38016: CALL_OW 1
38020: ST_TO_ADDR
38021: GO 37983
38023: POP
38024: POP
// result := tmp ;
38025: LD_ADDR_VAR 0 6
38029: PUSH
38030: LD_VAR 0 9
38034: ST_TO_ADDR
// end ; end ;
38035: LD_VAR 0 6
38039: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
38040: LD_INT 0
38042: PPUSH
38043: PPUSH
38044: PPUSH
38045: PPUSH
38046: PPUSH
38047: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
38048: LD_ADDR_VAR 0 5
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: LD_INT 0
38061: PUSH
38062: EMPTY
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: ST_TO_ADDR
// if not x or not y then
38070: LD_VAR 0 2
38074: NOT
38075: PUSH
38076: LD_VAR 0 3
38080: NOT
38081: OR
38082: IFFALSE 38086
// exit ;
38084: GO 39732
// if not range then
38086: LD_VAR 0 4
38090: NOT
38091: IFFALSE 38101
// range := 10 ;
38093: LD_ADDR_VAR 0 4
38097: PUSH
38098: LD_INT 10
38100: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
38101: LD_ADDR_VAR 0 8
38105: PUSH
38106: LD_INT 81
38108: PUSH
38109: LD_VAR 0 1
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: PUSH
38118: LD_INT 92
38120: PUSH
38121: LD_VAR 0 2
38125: PUSH
38126: LD_VAR 0 3
38130: PUSH
38131: LD_VAR 0 4
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 3
38144: PUSH
38145: LD_INT 21
38147: PUSH
38148: LD_INT 3
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: LIST
38163: PPUSH
38164: CALL_OW 69
38168: ST_TO_ADDR
// if not tmp then
38169: LD_VAR 0 8
38173: NOT
38174: IFFALSE 38178
// exit ;
38176: GO 39732
// for i in tmp do
38178: LD_ADDR_VAR 0 6
38182: PUSH
38183: LD_VAR 0 8
38187: PUSH
38188: FOR_IN
38189: IFFALSE 39707
// begin points := [ 0 , 0 , 0 ] ;
38191: LD_ADDR_VAR 0 9
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: LD_INT 0
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: LIST
38209: ST_TO_ADDR
// bpoints := 1 ;
38210: LD_ADDR_VAR 0 10
38214: PUSH
38215: LD_INT 1
38217: ST_TO_ADDR
// case GetType ( i ) of unit_human :
38218: LD_VAR 0 6
38222: PPUSH
38223: CALL_OW 247
38227: PUSH
38228: LD_INT 1
38230: DOUBLE
38231: EQUAL
38232: IFTRUE 38236
38234: GO 38814
38236: POP
// begin if GetClass ( i ) = 1 then
38237: LD_VAR 0 6
38241: PPUSH
38242: CALL_OW 257
38246: PUSH
38247: LD_INT 1
38249: EQUAL
38250: IFFALSE 38271
// points := [ 10 , 5 , 3 ] ;
38252: LD_ADDR_VAR 0 9
38256: PUSH
38257: LD_INT 10
38259: PUSH
38260: LD_INT 5
38262: PUSH
38263: LD_INT 3
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
38271: LD_VAR 0 6
38275: PPUSH
38276: CALL_OW 257
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: LD_INT 3
38286: PUSH
38287: LD_INT 4
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: LIST
38294: IN
38295: IFFALSE 38316
// points := [ 3 , 2 , 1 ] ;
38297: LD_ADDR_VAR 0 9
38301: PUSH
38302: LD_INT 3
38304: PUSH
38305: LD_INT 2
38307: PUSH
38308: LD_INT 1
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: LIST
38315: ST_TO_ADDR
// if GetClass ( i ) = 5 then
38316: LD_VAR 0 6
38320: PPUSH
38321: CALL_OW 257
38325: PUSH
38326: LD_INT 5
38328: EQUAL
38329: IFFALSE 38350
// points := [ 130 , 5 , 2 ] ;
38331: LD_ADDR_VAR 0 9
38335: PUSH
38336: LD_INT 130
38338: PUSH
38339: LD_INT 5
38341: PUSH
38342: LD_INT 2
38344: PUSH
38345: EMPTY
38346: LIST
38347: LIST
38348: LIST
38349: ST_TO_ADDR
// if GetClass ( i ) = 8 then
38350: LD_VAR 0 6
38354: PPUSH
38355: CALL_OW 257
38359: PUSH
38360: LD_INT 8
38362: EQUAL
38363: IFFALSE 38384
// points := [ 35 , 35 , 30 ] ;
38365: LD_ADDR_VAR 0 9
38369: PUSH
38370: LD_INT 35
38372: PUSH
38373: LD_INT 35
38375: PUSH
38376: LD_INT 30
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: LIST
38383: ST_TO_ADDR
// if GetClass ( i ) = 9 then
38384: LD_VAR 0 6
38388: PPUSH
38389: CALL_OW 257
38393: PUSH
38394: LD_INT 9
38396: EQUAL
38397: IFFALSE 38418
// points := [ 20 , 55 , 40 ] ;
38399: LD_ADDR_VAR 0 9
38403: PUSH
38404: LD_INT 20
38406: PUSH
38407: LD_INT 55
38409: PUSH
38410: LD_INT 40
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: LIST
38417: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
38418: LD_VAR 0 6
38422: PPUSH
38423: CALL_OW 257
38427: PUSH
38428: LD_INT 12
38430: PUSH
38431: LD_INT 16
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: IN
38438: IFFALSE 38459
// points := [ 5 , 3 , 2 ] ;
38440: LD_ADDR_VAR 0 9
38444: PUSH
38445: LD_INT 5
38447: PUSH
38448: LD_INT 3
38450: PUSH
38451: LD_INT 2
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: LIST
38458: ST_TO_ADDR
// if GetClass ( i ) = 17 then
38459: LD_VAR 0 6
38463: PPUSH
38464: CALL_OW 257
38468: PUSH
38469: LD_INT 17
38471: EQUAL
38472: IFFALSE 38493
// points := [ 100 , 50 , 75 ] ;
38474: LD_ADDR_VAR 0 9
38478: PUSH
38479: LD_INT 100
38481: PUSH
38482: LD_INT 50
38484: PUSH
38485: LD_INT 75
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: LIST
38492: ST_TO_ADDR
// if GetClass ( i ) = 15 then
38493: LD_VAR 0 6
38497: PPUSH
38498: CALL_OW 257
38502: PUSH
38503: LD_INT 15
38505: EQUAL
38506: IFFALSE 38527
// points := [ 10 , 5 , 3 ] ;
38508: LD_ADDR_VAR 0 9
38512: PUSH
38513: LD_INT 10
38515: PUSH
38516: LD_INT 5
38518: PUSH
38519: LD_INT 3
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: LIST
38526: ST_TO_ADDR
// if GetClass ( i ) = 14 then
38527: LD_VAR 0 6
38531: PPUSH
38532: CALL_OW 257
38536: PUSH
38537: LD_INT 14
38539: EQUAL
38540: IFFALSE 38561
// points := [ 10 , 0 , 0 ] ;
38542: LD_ADDR_VAR 0 9
38546: PUSH
38547: LD_INT 10
38549: PUSH
38550: LD_INT 0
38552: PUSH
38553: LD_INT 0
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: LIST
38560: ST_TO_ADDR
// if GetClass ( i ) = 11 then
38561: LD_VAR 0 6
38565: PPUSH
38566: CALL_OW 257
38570: PUSH
38571: LD_INT 11
38573: EQUAL
38574: IFFALSE 38595
// points := [ 30 , 10 , 5 ] ;
38576: LD_ADDR_VAR 0 9
38580: PUSH
38581: LD_INT 30
38583: PUSH
38584: LD_INT 10
38586: PUSH
38587: LD_INT 5
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: LIST
38594: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
38595: LD_VAR 0 1
38599: PPUSH
38600: LD_INT 5
38602: PPUSH
38603: CALL_OW 321
38607: PUSH
38608: LD_INT 2
38610: EQUAL
38611: IFFALSE 38628
// bpoints := bpoints * 1.8 ;
38613: LD_ADDR_VAR 0 10
38617: PUSH
38618: LD_VAR 0 10
38622: PUSH
38623: LD_REAL  1.80000000000000E+0000
38626: MUL
38627: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
38628: LD_VAR 0 6
38632: PPUSH
38633: CALL_OW 257
38637: PUSH
38638: LD_INT 1
38640: PUSH
38641: LD_INT 2
38643: PUSH
38644: LD_INT 3
38646: PUSH
38647: LD_INT 4
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: LIST
38654: LIST
38655: IN
38656: PUSH
38657: LD_VAR 0 1
38661: PPUSH
38662: LD_INT 51
38664: PPUSH
38665: CALL_OW 321
38669: PUSH
38670: LD_INT 2
38672: EQUAL
38673: AND
38674: IFFALSE 38691
// bpoints := bpoints * 1.2 ;
38676: LD_ADDR_VAR 0 10
38680: PUSH
38681: LD_VAR 0 10
38685: PUSH
38686: LD_REAL  1.20000000000000E+0000
38689: MUL
38690: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
38691: LD_VAR 0 6
38695: PPUSH
38696: CALL_OW 257
38700: PUSH
38701: LD_INT 5
38703: PUSH
38704: LD_INT 7
38706: PUSH
38707: LD_INT 9
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: LIST
38714: IN
38715: PUSH
38716: LD_VAR 0 1
38720: PPUSH
38721: LD_INT 52
38723: PPUSH
38724: CALL_OW 321
38728: PUSH
38729: LD_INT 2
38731: EQUAL
38732: AND
38733: IFFALSE 38750
// bpoints := bpoints * 1.5 ;
38735: LD_ADDR_VAR 0 10
38739: PUSH
38740: LD_VAR 0 10
38744: PUSH
38745: LD_REAL  1.50000000000000E+0000
38748: MUL
38749: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
38750: LD_VAR 0 1
38754: PPUSH
38755: LD_INT 66
38757: PPUSH
38758: CALL_OW 321
38762: PUSH
38763: LD_INT 2
38765: EQUAL
38766: IFFALSE 38783
// bpoints := bpoints * 1.1 ;
38768: LD_ADDR_VAR 0 10
38772: PUSH
38773: LD_VAR 0 10
38777: PUSH
38778: LD_REAL  1.10000000000000E+0000
38781: MUL
38782: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
38783: LD_ADDR_VAR 0 10
38787: PUSH
38788: LD_VAR 0 10
38792: PUSH
38793: LD_VAR 0 6
38797: PPUSH
38798: LD_INT 1
38800: PPUSH
38801: CALL_OW 259
38805: PUSH
38806: LD_REAL  1.15000000000000E+0000
38809: MUL
38810: MUL
38811: ST_TO_ADDR
// end ; unit_vehicle :
38812: GO 39636
38814: LD_INT 2
38816: DOUBLE
38817: EQUAL
38818: IFTRUE 38822
38820: GO 39624
38822: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
38823: LD_VAR 0 6
38827: PPUSH
38828: CALL_OW 264
38832: PUSH
38833: LD_INT 2
38835: PUSH
38836: LD_INT 42
38838: PUSH
38839: LD_INT 24
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: LIST
38846: IN
38847: IFFALSE 38868
// points := [ 25 , 5 , 3 ] ;
38849: LD_ADDR_VAR 0 9
38853: PUSH
38854: LD_INT 25
38856: PUSH
38857: LD_INT 5
38859: PUSH
38860: LD_INT 3
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: LIST
38867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
38868: LD_VAR 0 6
38872: PPUSH
38873: CALL_OW 264
38877: PUSH
38878: LD_INT 4
38880: PUSH
38881: LD_INT 43
38883: PUSH
38884: LD_INT 25
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: LIST
38891: IN
38892: IFFALSE 38913
// points := [ 40 , 15 , 5 ] ;
38894: LD_ADDR_VAR 0 9
38898: PUSH
38899: LD_INT 40
38901: PUSH
38902: LD_INT 15
38904: PUSH
38905: LD_INT 5
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: LIST
38912: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
38913: LD_VAR 0 6
38917: PPUSH
38918: CALL_OW 264
38922: PUSH
38923: LD_INT 3
38925: PUSH
38926: LD_INT 23
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: IN
38933: IFFALSE 38954
// points := [ 7 , 25 , 8 ] ;
38935: LD_ADDR_VAR 0 9
38939: PUSH
38940: LD_INT 7
38942: PUSH
38943: LD_INT 25
38945: PUSH
38946: LD_INT 8
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: LIST
38953: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
38954: LD_VAR 0 6
38958: PPUSH
38959: CALL_OW 264
38963: PUSH
38964: LD_INT 5
38966: PUSH
38967: LD_INT 27
38969: PUSH
38970: LD_INT 44
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: LIST
38977: IN
38978: IFFALSE 38999
// points := [ 14 , 50 , 16 ] ;
38980: LD_ADDR_VAR 0 9
38984: PUSH
38985: LD_INT 14
38987: PUSH
38988: LD_INT 50
38990: PUSH
38991: LD_INT 16
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: LIST
38998: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
38999: LD_VAR 0 6
39003: PPUSH
39004: CALL_OW 264
39008: PUSH
39009: LD_INT 6
39011: PUSH
39012: LD_INT 46
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: IN
39019: IFFALSE 39040
// points := [ 32 , 120 , 70 ] ;
39021: LD_ADDR_VAR 0 9
39025: PUSH
39026: LD_INT 32
39028: PUSH
39029: LD_INT 120
39031: PUSH
39032: LD_INT 70
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: LIST
39039: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
39040: LD_VAR 0 6
39044: PPUSH
39045: CALL_OW 264
39049: PUSH
39050: LD_INT 7
39052: PUSH
39053: LD_INT 28
39055: PUSH
39056: LD_INT 45
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: LIST
39063: IN
39064: IFFALSE 39085
// points := [ 35 , 20 , 45 ] ;
39066: LD_ADDR_VAR 0 9
39070: PUSH
39071: LD_INT 35
39073: PUSH
39074: LD_INT 20
39076: PUSH
39077: LD_INT 45
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: LIST
39084: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
39085: LD_VAR 0 6
39089: PPUSH
39090: CALL_OW 264
39094: PUSH
39095: LD_INT 47
39097: PUSH
39098: EMPTY
39099: LIST
39100: IN
39101: IFFALSE 39122
// points := [ 67 , 45 , 75 ] ;
39103: LD_ADDR_VAR 0 9
39107: PUSH
39108: LD_INT 67
39110: PUSH
39111: LD_INT 45
39113: PUSH
39114: LD_INT 75
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: LIST
39121: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
39122: LD_VAR 0 6
39126: PPUSH
39127: CALL_OW 264
39131: PUSH
39132: LD_INT 26
39134: PUSH
39135: EMPTY
39136: LIST
39137: IN
39138: IFFALSE 39159
// points := [ 120 , 30 , 80 ] ;
39140: LD_ADDR_VAR 0 9
39144: PUSH
39145: LD_INT 120
39147: PUSH
39148: LD_INT 30
39150: PUSH
39151: LD_INT 80
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: LIST
39158: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
39159: LD_VAR 0 6
39163: PPUSH
39164: CALL_OW 264
39168: PUSH
39169: LD_INT 22
39171: PUSH
39172: EMPTY
39173: LIST
39174: IN
39175: IFFALSE 39196
// points := [ 40 , 1 , 1 ] ;
39177: LD_ADDR_VAR 0 9
39181: PUSH
39182: LD_INT 40
39184: PUSH
39185: LD_INT 1
39187: PUSH
39188: LD_INT 1
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: LIST
39195: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
39196: LD_VAR 0 6
39200: PPUSH
39201: CALL_OW 264
39205: PUSH
39206: LD_INT 29
39208: PUSH
39209: EMPTY
39210: LIST
39211: IN
39212: IFFALSE 39233
// points := [ 70 , 200 , 400 ] ;
39214: LD_ADDR_VAR 0 9
39218: PUSH
39219: LD_INT 70
39221: PUSH
39222: LD_INT 200
39224: PUSH
39225: LD_INT 400
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
39233: LD_VAR 0 6
39237: PPUSH
39238: CALL_OW 264
39242: PUSH
39243: LD_INT 14
39245: PUSH
39246: LD_INT 53
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: IN
39253: IFFALSE 39274
// points := [ 40 , 10 , 20 ] ;
39255: LD_ADDR_VAR 0 9
39259: PUSH
39260: LD_INT 40
39262: PUSH
39263: LD_INT 10
39265: PUSH
39266: LD_INT 20
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
39274: LD_VAR 0 6
39278: PPUSH
39279: CALL_OW 264
39283: PUSH
39284: LD_INT 9
39286: PUSH
39287: EMPTY
39288: LIST
39289: IN
39290: IFFALSE 39311
// points := [ 5 , 70 , 20 ] ;
39292: LD_ADDR_VAR 0 9
39296: PUSH
39297: LD_INT 5
39299: PUSH
39300: LD_INT 70
39302: PUSH
39303: LD_INT 20
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: LIST
39310: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
39311: LD_VAR 0 6
39315: PPUSH
39316: CALL_OW 264
39320: PUSH
39321: LD_INT 10
39323: PUSH
39324: EMPTY
39325: LIST
39326: IN
39327: IFFALSE 39348
// points := [ 35 , 110 , 70 ] ;
39329: LD_ADDR_VAR 0 9
39333: PUSH
39334: LD_INT 35
39336: PUSH
39337: LD_INT 110
39339: PUSH
39340: LD_INT 70
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: LIST
39347: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
39348: LD_VAR 0 6
39352: PPUSH
39353: CALL_OW 265
39357: PUSH
39358: LD_INT 25
39360: EQUAL
39361: IFFALSE 39382
// points := [ 80 , 65 , 100 ] ;
39363: LD_ADDR_VAR 0 9
39367: PUSH
39368: LD_INT 80
39370: PUSH
39371: LD_INT 65
39373: PUSH
39374: LD_INT 100
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: LIST
39381: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
39382: LD_VAR 0 6
39386: PPUSH
39387: CALL_OW 263
39391: PUSH
39392: LD_INT 1
39394: EQUAL
39395: IFFALSE 39430
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
39397: LD_ADDR_VAR 0 10
39401: PUSH
39402: LD_VAR 0 10
39406: PUSH
39407: LD_VAR 0 6
39411: PPUSH
39412: CALL_OW 311
39416: PPUSH
39417: LD_INT 3
39419: PPUSH
39420: CALL_OW 259
39424: PUSH
39425: LD_INT 4
39427: MUL
39428: MUL
39429: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
39430: LD_VAR 0 6
39434: PPUSH
39435: CALL_OW 263
39439: PUSH
39440: LD_INT 2
39442: EQUAL
39443: IFFALSE 39494
// begin j := IsControledBy ( i ) ;
39445: LD_ADDR_VAR 0 7
39449: PUSH
39450: LD_VAR 0 6
39454: PPUSH
39455: CALL_OW 312
39459: ST_TO_ADDR
// if j then
39460: LD_VAR 0 7
39464: IFFALSE 39494
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
39466: LD_ADDR_VAR 0 10
39470: PUSH
39471: LD_VAR 0 10
39475: PUSH
39476: LD_VAR 0 7
39480: PPUSH
39481: LD_INT 3
39483: PPUSH
39484: CALL_OW 259
39488: PUSH
39489: LD_INT 3
39491: MUL
39492: MUL
39493: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
39494: LD_VAR 0 6
39498: PPUSH
39499: CALL_OW 264
39503: PUSH
39504: LD_INT 5
39506: PUSH
39507: LD_INT 6
39509: PUSH
39510: LD_INT 46
39512: PUSH
39513: LD_INT 44
39515: PUSH
39516: LD_INT 47
39518: PUSH
39519: LD_INT 45
39521: PUSH
39522: LD_INT 28
39524: PUSH
39525: LD_INT 7
39527: PUSH
39528: LD_INT 27
39530: PUSH
39531: LD_INT 29
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: IN
39546: PUSH
39547: LD_VAR 0 1
39551: PPUSH
39552: LD_INT 52
39554: PPUSH
39555: CALL_OW 321
39559: PUSH
39560: LD_INT 2
39562: EQUAL
39563: AND
39564: IFFALSE 39581
// bpoints := bpoints * 1.2 ;
39566: LD_ADDR_VAR 0 10
39570: PUSH
39571: LD_VAR 0 10
39575: PUSH
39576: LD_REAL  1.20000000000000E+0000
39579: MUL
39580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
39581: LD_VAR 0 6
39585: PPUSH
39586: CALL_OW 264
39590: PUSH
39591: LD_INT 6
39593: PUSH
39594: LD_INT 46
39596: PUSH
39597: LD_INT 47
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: LIST
39604: IN
39605: IFFALSE 39622
// bpoints := bpoints * 1.2 ;
39607: LD_ADDR_VAR 0 10
39611: PUSH
39612: LD_VAR 0 10
39616: PUSH
39617: LD_REAL  1.20000000000000E+0000
39620: MUL
39621: ST_TO_ADDR
// end ; unit_building :
39622: GO 39636
39624: LD_INT 3
39626: DOUBLE
39627: EQUAL
39628: IFTRUE 39632
39630: GO 39635
39632: POP
// ; end ;
39633: GO 39636
39635: POP
// for j = 1 to 3 do
39636: LD_ADDR_VAR 0 7
39640: PUSH
39641: DOUBLE
39642: LD_INT 1
39644: DEC
39645: ST_TO_ADDR
39646: LD_INT 3
39648: PUSH
39649: FOR_TO
39650: IFFALSE 39703
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
39652: LD_ADDR_VAR 0 5
39656: PUSH
39657: LD_VAR 0 5
39661: PPUSH
39662: LD_VAR 0 7
39666: PPUSH
39667: LD_VAR 0 5
39671: PUSH
39672: LD_VAR 0 7
39676: ARRAY
39677: PUSH
39678: LD_VAR 0 9
39682: PUSH
39683: LD_VAR 0 7
39687: ARRAY
39688: PUSH
39689: LD_VAR 0 10
39693: MUL
39694: PLUS
39695: PPUSH
39696: CALL_OW 1
39700: ST_TO_ADDR
39701: GO 39649
39703: POP
39704: POP
// end ;
39705: GO 38188
39707: POP
39708: POP
// result := Replace ( result , 4 , tmp ) ;
39709: LD_ADDR_VAR 0 5
39713: PUSH
39714: LD_VAR 0 5
39718: PPUSH
39719: LD_INT 4
39721: PPUSH
39722: LD_VAR 0 8
39726: PPUSH
39727: CALL_OW 1
39731: ST_TO_ADDR
// end ;
39732: LD_VAR 0 5
39736: RET
// export function DangerAtRange ( unit , range ) ; begin
39737: LD_INT 0
39739: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
39740: LD_ADDR_VAR 0 3
39744: PUSH
39745: LD_VAR 0 1
39749: PPUSH
39750: CALL_OW 255
39754: PPUSH
39755: LD_VAR 0 1
39759: PPUSH
39760: CALL_OW 250
39764: PPUSH
39765: LD_VAR 0 1
39769: PPUSH
39770: CALL_OW 251
39774: PPUSH
39775: LD_VAR 0 2
39779: PPUSH
39780: CALL 38040 0 4
39784: ST_TO_ADDR
// end ;
39785: LD_VAR 0 3
39789: RET
// export function DangerInArea ( side , area ) ; begin
39790: LD_INT 0
39792: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
39793: LD_ADDR_VAR 0 3
39797: PUSH
39798: LD_VAR 0 2
39802: PPUSH
39803: LD_INT 81
39805: PUSH
39806: LD_VAR 0 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PPUSH
39815: CALL_OW 70
39819: ST_TO_ADDR
// end ;
39820: LD_VAR 0 3
39824: RET
// export function IsExtension ( b ) ; begin
39825: LD_INT 0
39827: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
39828: LD_ADDR_VAR 0 2
39832: PUSH
39833: LD_VAR 0 1
39837: PUSH
39838: LD_INT 23
39840: PUSH
39841: LD_INT 20
39843: PUSH
39844: LD_INT 22
39846: PUSH
39847: LD_INT 17
39849: PUSH
39850: LD_INT 24
39852: PUSH
39853: LD_INT 21
39855: PUSH
39856: LD_INT 19
39858: PUSH
39859: LD_INT 16
39861: PUSH
39862: LD_INT 25
39864: PUSH
39865: LD_INT 18
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: IN
39880: ST_TO_ADDR
// end ;
39881: LD_VAR 0 2
39885: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
39886: LD_INT 0
39888: PPUSH
39889: PPUSH
39890: PPUSH
// result := [ ] ;
39891: LD_ADDR_VAR 0 3
39895: PUSH
39896: EMPTY
39897: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
39898: LD_ADDR_VAR 0 4
39902: PUSH
39903: LD_VAR 0 2
39907: PPUSH
39908: LD_INT 21
39910: PUSH
39911: LD_INT 3
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PPUSH
39918: CALL_OW 70
39922: ST_TO_ADDR
// if not tmp then
39923: LD_VAR 0 4
39927: NOT
39928: IFFALSE 39932
// exit ;
39930: GO 39990
// for i in tmp do
39932: LD_ADDR_VAR 0 5
39936: PUSH
39937: LD_VAR 0 4
39941: PUSH
39942: FOR_IN
39943: IFFALSE 39978
// if GetBase ( i ) <> base then
39945: LD_VAR 0 5
39949: PPUSH
39950: CALL_OW 274
39954: PUSH
39955: LD_VAR 0 1
39959: NONEQUAL
39960: IFFALSE 39976
// ComLinkToBase ( base , i ) ;
39962: LD_VAR 0 1
39966: PPUSH
39967: LD_VAR 0 5
39971: PPUSH
39972: CALL_OW 169
39976: GO 39942
39978: POP
39979: POP
// result := tmp ;
39980: LD_ADDR_VAR 0 3
39984: PUSH
39985: LD_VAR 0 4
39989: ST_TO_ADDR
// end ;
39990: LD_VAR 0 3
39994: RET
// export function ComComplete ( unit , b ) ; var i ; begin
39995: LD_INT 0
39997: PPUSH
39998: PPUSH
// if BuildingStatus ( b ) = bs_build then
39999: LD_VAR 0 2
40003: PPUSH
40004: CALL_OW 461
40008: PUSH
40009: LD_INT 1
40011: EQUAL
40012: IFFALSE 40072
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
40014: LD_VAR 0 1
40018: PPUSH
40019: LD_STRING h
40021: PUSH
40022: LD_VAR 0 2
40026: PPUSH
40027: CALL_OW 250
40031: PUSH
40032: LD_VAR 0 2
40036: PPUSH
40037: CALL_OW 251
40041: PUSH
40042: LD_VAR 0 2
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: LD_INT 0
40052: PUSH
40053: LD_INT 0
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: PUSH
40065: EMPTY
40066: LIST
40067: PPUSH
40068: CALL_OW 446
// end ;
40072: LD_VAR 0 3
40076: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
40077: LD_INT 0
40079: PPUSH
40080: PPUSH
40081: PPUSH
40082: PPUSH
40083: PPUSH
40084: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
40085: LD_VAR 0 1
40089: NOT
40090: PUSH
40091: LD_VAR 0 1
40095: PPUSH
40096: CALL_OW 263
40100: PUSH
40101: LD_INT 2
40103: EQUAL
40104: NOT
40105: OR
40106: IFFALSE 40110
// exit ;
40108: GO 40426
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
40110: LD_ADDR_VAR 0 6
40114: PUSH
40115: LD_INT 22
40117: PUSH
40118: LD_VAR 0 1
40122: PPUSH
40123: CALL_OW 255
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 2
40134: PUSH
40135: LD_INT 30
40137: PUSH
40138: LD_INT 36
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 34
40147: PUSH
40148: LD_INT 31
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: LIST
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PPUSH
40164: CALL_OW 69
40168: ST_TO_ADDR
// if not tmp then
40169: LD_VAR 0 6
40173: NOT
40174: IFFALSE 40178
// exit ;
40176: GO 40426
// result := [ ] ;
40178: LD_ADDR_VAR 0 2
40182: PUSH
40183: EMPTY
40184: ST_TO_ADDR
// for i in tmp do
40185: LD_ADDR_VAR 0 3
40189: PUSH
40190: LD_VAR 0 6
40194: PUSH
40195: FOR_IN
40196: IFFALSE 40267
// begin t := UnitsInside ( i ) ;
40198: LD_ADDR_VAR 0 4
40202: PUSH
40203: LD_VAR 0 3
40207: PPUSH
40208: CALL_OW 313
40212: ST_TO_ADDR
// if t then
40213: LD_VAR 0 4
40217: IFFALSE 40265
// for j in t do
40219: LD_ADDR_VAR 0 7
40223: PUSH
40224: LD_VAR 0 4
40228: PUSH
40229: FOR_IN
40230: IFFALSE 40263
// result := Insert ( result , result + 1 , j ) ;
40232: LD_ADDR_VAR 0 2
40236: PUSH
40237: LD_VAR 0 2
40241: PPUSH
40242: LD_VAR 0 2
40246: PUSH
40247: LD_INT 1
40249: PLUS
40250: PPUSH
40251: LD_VAR 0 7
40255: PPUSH
40256: CALL_OW 2
40260: ST_TO_ADDR
40261: GO 40229
40263: POP
40264: POP
// end ;
40265: GO 40195
40267: POP
40268: POP
// if not result then
40269: LD_VAR 0 2
40273: NOT
40274: IFFALSE 40278
// exit ;
40276: GO 40426
// mech := result [ 1 ] ;
40278: LD_ADDR_VAR 0 5
40282: PUSH
40283: LD_VAR 0 2
40287: PUSH
40288: LD_INT 1
40290: ARRAY
40291: ST_TO_ADDR
// if result > 1 then
40292: LD_VAR 0 2
40296: PUSH
40297: LD_INT 1
40299: GREATER
40300: IFFALSE 40412
// for i = 2 to result do
40302: LD_ADDR_VAR 0 3
40306: PUSH
40307: DOUBLE
40308: LD_INT 2
40310: DEC
40311: ST_TO_ADDR
40312: LD_VAR 0 2
40316: PUSH
40317: FOR_TO
40318: IFFALSE 40410
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
40320: LD_ADDR_VAR 0 4
40324: PUSH
40325: LD_VAR 0 2
40329: PUSH
40330: LD_VAR 0 3
40334: ARRAY
40335: PPUSH
40336: LD_INT 3
40338: PPUSH
40339: CALL_OW 259
40343: PUSH
40344: LD_VAR 0 2
40348: PUSH
40349: LD_VAR 0 3
40353: ARRAY
40354: PPUSH
40355: CALL_OW 432
40359: MINUS
40360: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
40361: LD_VAR 0 4
40365: PUSH
40366: LD_VAR 0 5
40370: PPUSH
40371: LD_INT 3
40373: PPUSH
40374: CALL_OW 259
40378: PUSH
40379: LD_VAR 0 5
40383: PPUSH
40384: CALL_OW 432
40388: MINUS
40389: GREATEREQUAL
40390: IFFALSE 40408
// mech := result [ i ] ;
40392: LD_ADDR_VAR 0 5
40396: PUSH
40397: LD_VAR 0 2
40401: PUSH
40402: LD_VAR 0 3
40406: ARRAY
40407: ST_TO_ADDR
// end ;
40408: GO 40317
40410: POP
40411: POP
// ComLinkTo ( vehicle , mech ) ;
40412: LD_VAR 0 1
40416: PPUSH
40417: LD_VAR 0 5
40421: PPUSH
40422: CALL_OW 135
// end ;
40426: LD_VAR 0 2
40430: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
40431: LD_INT 0
40433: PPUSH
40434: PPUSH
40435: PPUSH
40436: PPUSH
40437: PPUSH
40438: PPUSH
40439: PPUSH
40440: PPUSH
40441: PPUSH
40442: PPUSH
40443: PPUSH
40444: PPUSH
40445: PPUSH
// result := [ ] ;
40446: LD_ADDR_VAR 0 7
40450: PUSH
40451: EMPTY
40452: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
40453: LD_VAR 0 1
40457: PPUSH
40458: CALL_OW 266
40462: PUSH
40463: LD_INT 0
40465: PUSH
40466: LD_INT 1
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: IN
40473: NOT
40474: IFFALSE 40478
// exit ;
40476: GO 42109
// if name then
40478: LD_VAR 0 3
40482: IFFALSE 40498
// SetBName ( base_dep , name ) ;
40484: LD_VAR 0 1
40488: PPUSH
40489: LD_VAR 0 3
40493: PPUSH
40494: CALL_OW 500
// base := GetBase ( base_dep ) ;
40498: LD_ADDR_VAR 0 15
40502: PUSH
40503: LD_VAR 0 1
40507: PPUSH
40508: CALL_OW 274
40512: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
40513: LD_ADDR_VAR 0 16
40517: PUSH
40518: LD_VAR 0 1
40522: PPUSH
40523: CALL_OW 255
40527: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
40528: LD_ADDR_VAR 0 17
40532: PUSH
40533: LD_VAR 0 1
40537: PPUSH
40538: CALL_OW 248
40542: ST_TO_ADDR
// if sources then
40543: LD_VAR 0 5
40547: IFFALSE 40594
// for i = 1 to 3 do
40549: LD_ADDR_VAR 0 8
40553: PUSH
40554: DOUBLE
40555: LD_INT 1
40557: DEC
40558: ST_TO_ADDR
40559: LD_INT 3
40561: PUSH
40562: FOR_TO
40563: IFFALSE 40592
// AddResourceType ( base , i , sources [ i ] ) ;
40565: LD_VAR 0 15
40569: PPUSH
40570: LD_VAR 0 8
40574: PPUSH
40575: LD_VAR 0 5
40579: PUSH
40580: LD_VAR 0 8
40584: ARRAY
40585: PPUSH
40586: CALL_OW 276
40590: GO 40562
40592: POP
40593: POP
// buildings := GetBaseBuildings ( base , area ) ;
40594: LD_ADDR_VAR 0 18
40598: PUSH
40599: LD_VAR 0 15
40603: PPUSH
40604: LD_VAR 0 2
40608: PPUSH
40609: CALL 39886 0 2
40613: ST_TO_ADDR
// InitHc ;
40614: CALL_OW 19
// InitUc ;
40618: CALL_OW 18
// uc_side := side ;
40622: LD_ADDR_OWVAR 20
40626: PUSH
40627: LD_VAR 0 16
40631: ST_TO_ADDR
// uc_nation := nation ;
40632: LD_ADDR_OWVAR 21
40636: PUSH
40637: LD_VAR 0 17
40641: ST_TO_ADDR
// if buildings then
40642: LD_VAR 0 18
40646: IFFALSE 41968
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
40648: LD_ADDR_VAR 0 19
40652: PUSH
40653: LD_VAR 0 18
40657: PPUSH
40658: LD_INT 2
40660: PUSH
40661: LD_INT 30
40663: PUSH
40664: LD_INT 29
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 30
40673: PUSH
40674: LD_INT 30
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: LIST
40685: PPUSH
40686: CALL_OW 72
40690: ST_TO_ADDR
// if tmp then
40691: LD_VAR 0 19
40695: IFFALSE 40743
// for i in tmp do
40697: LD_ADDR_VAR 0 8
40701: PUSH
40702: LD_VAR 0 19
40706: PUSH
40707: FOR_IN
40708: IFFALSE 40741
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
40710: LD_VAR 0 8
40714: PPUSH
40715: CALL_OW 250
40719: PPUSH
40720: LD_VAR 0 8
40724: PPUSH
40725: CALL_OW 251
40729: PPUSH
40730: LD_VAR 0 16
40734: PPUSH
40735: CALL_OW 441
40739: GO 40707
40741: POP
40742: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
40743: LD_VAR 0 18
40747: PPUSH
40748: LD_INT 2
40750: PUSH
40751: LD_INT 30
40753: PUSH
40754: LD_INT 32
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 30
40763: PUSH
40764: LD_INT 33
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: LIST
40775: PPUSH
40776: CALL_OW 72
40780: IFFALSE 40868
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
40782: LD_ADDR_VAR 0 8
40786: PUSH
40787: LD_VAR 0 18
40791: PPUSH
40792: LD_INT 2
40794: PUSH
40795: LD_INT 30
40797: PUSH
40798: LD_INT 32
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 30
40807: PUSH
40808: LD_INT 33
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: LIST
40819: PPUSH
40820: CALL_OW 72
40824: PUSH
40825: FOR_IN
40826: IFFALSE 40866
// begin if not GetBWeapon ( i ) then
40828: LD_VAR 0 8
40832: PPUSH
40833: CALL_OW 269
40837: NOT
40838: IFFALSE 40864
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
40840: LD_VAR 0 8
40844: PPUSH
40845: LD_VAR 0 8
40849: PPUSH
40850: LD_VAR 0 2
40854: PPUSH
40855: CALL 42114 0 2
40859: PPUSH
40860: CALL_OW 431
// end ;
40864: GO 40825
40866: POP
40867: POP
// end ; for i = 1 to personel do
40868: LD_ADDR_VAR 0 8
40872: PUSH
40873: DOUBLE
40874: LD_INT 1
40876: DEC
40877: ST_TO_ADDR
40878: LD_VAR 0 6
40882: PUSH
40883: FOR_TO
40884: IFFALSE 41948
// begin if i > 4 then
40886: LD_VAR 0 8
40890: PUSH
40891: LD_INT 4
40893: GREATER
40894: IFFALSE 40898
// break ;
40896: GO 41948
// case i of 1 :
40898: LD_VAR 0 8
40902: PUSH
40903: LD_INT 1
40905: DOUBLE
40906: EQUAL
40907: IFTRUE 40911
40909: GO 40991
40911: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
40912: LD_ADDR_VAR 0 12
40916: PUSH
40917: LD_VAR 0 18
40921: PPUSH
40922: LD_INT 22
40924: PUSH
40925: LD_VAR 0 16
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 58
40936: PUSH
40937: EMPTY
40938: LIST
40939: PUSH
40940: LD_INT 2
40942: PUSH
40943: LD_INT 30
40945: PUSH
40946: LD_INT 32
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 30
40955: PUSH
40956: LD_INT 4
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 30
40965: PUSH
40966: LD_INT 5
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: LIST
40983: PPUSH
40984: CALL_OW 72
40988: ST_TO_ADDR
40989: GO 41213
40991: LD_INT 2
40993: DOUBLE
40994: EQUAL
40995: IFTRUE 40999
40997: GO 41061
40999: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
41000: LD_ADDR_VAR 0 12
41004: PUSH
41005: LD_VAR 0 18
41009: PPUSH
41010: LD_INT 22
41012: PUSH
41013: LD_VAR 0 16
41017: PUSH
41018: EMPTY
41019: LIST
41020: LIST
41021: PUSH
41022: LD_INT 2
41024: PUSH
41025: LD_INT 30
41027: PUSH
41028: LD_INT 0
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 30
41037: PUSH
41038: LD_INT 1
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: LIST
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PPUSH
41054: CALL_OW 72
41058: ST_TO_ADDR
41059: GO 41213
41061: LD_INT 3
41063: DOUBLE
41064: EQUAL
41065: IFTRUE 41069
41067: GO 41131
41069: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
41070: LD_ADDR_VAR 0 12
41074: PUSH
41075: LD_VAR 0 18
41079: PPUSH
41080: LD_INT 22
41082: PUSH
41083: LD_VAR 0 16
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 2
41094: PUSH
41095: LD_INT 30
41097: PUSH
41098: LD_INT 2
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 30
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: LIST
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PPUSH
41124: CALL_OW 72
41128: ST_TO_ADDR
41129: GO 41213
41131: LD_INT 4
41133: DOUBLE
41134: EQUAL
41135: IFTRUE 41139
41137: GO 41212
41139: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
41140: LD_ADDR_VAR 0 12
41144: PUSH
41145: LD_VAR 0 18
41149: PPUSH
41150: LD_INT 22
41152: PUSH
41153: LD_VAR 0 16
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 2
41164: PUSH
41165: LD_INT 30
41167: PUSH
41168: LD_INT 6
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: LD_INT 30
41177: PUSH
41178: LD_INT 7
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 30
41187: PUSH
41188: LD_INT 8
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: PPUSH
41205: CALL_OW 72
41209: ST_TO_ADDR
41210: GO 41213
41212: POP
// if i = 1 then
41213: LD_VAR 0 8
41217: PUSH
41218: LD_INT 1
41220: EQUAL
41221: IFFALSE 41332
// begin tmp := [ ] ;
41223: LD_ADDR_VAR 0 19
41227: PUSH
41228: EMPTY
41229: ST_TO_ADDR
// for j in f do
41230: LD_ADDR_VAR 0 9
41234: PUSH
41235: LD_VAR 0 12
41239: PUSH
41240: FOR_IN
41241: IFFALSE 41314
// if GetBType ( j ) = b_bunker then
41243: LD_VAR 0 9
41247: PPUSH
41248: CALL_OW 266
41252: PUSH
41253: LD_INT 32
41255: EQUAL
41256: IFFALSE 41283
// tmp := Insert ( tmp , 1 , j ) else
41258: LD_ADDR_VAR 0 19
41262: PUSH
41263: LD_VAR 0 19
41267: PPUSH
41268: LD_INT 1
41270: PPUSH
41271: LD_VAR 0 9
41275: PPUSH
41276: CALL_OW 2
41280: ST_TO_ADDR
41281: GO 41312
// tmp := Insert ( tmp , tmp + 1 , j ) ;
41283: LD_ADDR_VAR 0 19
41287: PUSH
41288: LD_VAR 0 19
41292: PPUSH
41293: LD_VAR 0 19
41297: PUSH
41298: LD_INT 1
41300: PLUS
41301: PPUSH
41302: LD_VAR 0 9
41306: PPUSH
41307: CALL_OW 2
41311: ST_TO_ADDR
41312: GO 41240
41314: POP
41315: POP
// if tmp then
41316: LD_VAR 0 19
41320: IFFALSE 41332
// f := tmp ;
41322: LD_ADDR_VAR 0 12
41326: PUSH
41327: LD_VAR 0 19
41331: ST_TO_ADDR
// end ; x := personel [ i ] ;
41332: LD_ADDR_VAR 0 13
41336: PUSH
41337: LD_VAR 0 6
41341: PUSH
41342: LD_VAR 0 8
41346: ARRAY
41347: ST_TO_ADDR
// if x = - 1 then
41348: LD_VAR 0 13
41352: PUSH
41353: LD_INT 1
41355: NEG
41356: EQUAL
41357: IFFALSE 41566
// begin for j in f do
41359: LD_ADDR_VAR 0 9
41363: PUSH
41364: LD_VAR 0 12
41368: PUSH
41369: FOR_IN
41370: IFFALSE 41562
// repeat InitHc ;
41372: CALL_OW 19
// if GetBType ( j ) = b_barracks then
41376: LD_VAR 0 9
41380: PPUSH
41381: CALL_OW 266
41385: PUSH
41386: LD_INT 5
41388: EQUAL
41389: IFFALSE 41459
// begin if UnitsInside ( j ) < 3 then
41391: LD_VAR 0 9
41395: PPUSH
41396: CALL_OW 313
41400: PUSH
41401: LD_INT 3
41403: LESS
41404: IFFALSE 41440
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
41406: LD_INT 0
41408: PPUSH
41409: LD_INT 5
41411: PUSH
41412: LD_INT 8
41414: PUSH
41415: LD_INT 9
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: LIST
41422: PUSH
41423: LD_VAR 0 17
41427: ARRAY
41428: PPUSH
41429: LD_VAR 0 4
41433: PPUSH
41434: CALL_OW 380
41438: GO 41457
// PrepareHuman ( false , i , skill ) ;
41440: LD_INT 0
41442: PPUSH
41443: LD_VAR 0 8
41447: PPUSH
41448: LD_VAR 0 4
41452: PPUSH
41453: CALL_OW 380
// end else
41457: GO 41476
// PrepareHuman ( false , i , skill ) ;
41459: LD_INT 0
41461: PPUSH
41462: LD_VAR 0 8
41466: PPUSH
41467: LD_VAR 0 4
41471: PPUSH
41472: CALL_OW 380
// un := CreateHuman ;
41476: LD_ADDR_VAR 0 14
41480: PUSH
41481: CALL_OW 44
41485: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
41486: LD_ADDR_VAR 0 7
41490: PUSH
41491: LD_VAR 0 7
41495: PPUSH
41496: LD_INT 1
41498: PPUSH
41499: LD_VAR 0 14
41503: PPUSH
41504: CALL_OW 2
41508: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
41509: LD_VAR 0 14
41513: PPUSH
41514: LD_VAR 0 9
41518: PPUSH
41519: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
41523: LD_VAR 0 9
41527: PPUSH
41528: CALL_OW 313
41532: PUSH
41533: LD_INT 6
41535: EQUAL
41536: PUSH
41537: LD_VAR 0 9
41541: PPUSH
41542: CALL_OW 266
41546: PUSH
41547: LD_INT 32
41549: PUSH
41550: LD_INT 31
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: IN
41557: OR
41558: IFFALSE 41372
41560: GO 41369
41562: POP
41563: POP
// end else
41564: GO 41946
// for j = 1 to x do
41566: LD_ADDR_VAR 0 9
41570: PUSH
41571: DOUBLE
41572: LD_INT 1
41574: DEC
41575: ST_TO_ADDR
41576: LD_VAR 0 13
41580: PUSH
41581: FOR_TO
41582: IFFALSE 41944
// begin InitHc ;
41584: CALL_OW 19
// if not f then
41588: LD_VAR 0 12
41592: NOT
41593: IFFALSE 41682
// begin PrepareHuman ( false , i , skill ) ;
41595: LD_INT 0
41597: PPUSH
41598: LD_VAR 0 8
41602: PPUSH
41603: LD_VAR 0 4
41607: PPUSH
41608: CALL_OW 380
// un := CreateHuman ;
41612: LD_ADDR_VAR 0 14
41616: PUSH
41617: CALL_OW 44
41621: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
41622: LD_ADDR_VAR 0 7
41626: PUSH
41627: LD_VAR 0 7
41631: PPUSH
41632: LD_INT 1
41634: PPUSH
41635: LD_VAR 0 14
41639: PPUSH
41640: CALL_OW 2
41644: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
41645: LD_VAR 0 14
41649: PPUSH
41650: LD_VAR 0 1
41654: PPUSH
41655: CALL_OW 250
41659: PPUSH
41660: LD_VAR 0 1
41664: PPUSH
41665: CALL_OW 251
41669: PPUSH
41670: LD_INT 10
41672: PPUSH
41673: LD_INT 0
41675: PPUSH
41676: CALL_OW 50
// continue ;
41680: GO 41581
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
41682: LD_VAR 0 12
41686: PUSH
41687: LD_INT 1
41689: ARRAY
41690: PPUSH
41691: CALL_OW 313
41695: PUSH
41696: LD_VAR 0 12
41700: PUSH
41701: LD_INT 1
41703: ARRAY
41704: PPUSH
41705: CALL_OW 266
41709: PUSH
41710: LD_INT 32
41712: PUSH
41713: LD_INT 31
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: IN
41720: AND
41721: PUSH
41722: LD_VAR 0 12
41726: PUSH
41727: LD_INT 1
41729: ARRAY
41730: PPUSH
41731: CALL_OW 313
41735: PUSH
41736: LD_INT 6
41738: EQUAL
41739: OR
41740: IFFALSE 41760
// f := Delete ( f , 1 ) ;
41742: LD_ADDR_VAR 0 12
41746: PUSH
41747: LD_VAR 0 12
41751: PPUSH
41752: LD_INT 1
41754: PPUSH
41755: CALL_OW 3
41759: ST_TO_ADDR
// if not f then
41760: LD_VAR 0 12
41764: NOT
41765: IFFALSE 41783
// begin x := x + 2 ;
41767: LD_ADDR_VAR 0 13
41771: PUSH
41772: LD_VAR 0 13
41776: PUSH
41777: LD_INT 2
41779: PLUS
41780: ST_TO_ADDR
// continue ;
41781: GO 41581
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
41783: LD_VAR 0 12
41787: PUSH
41788: LD_INT 1
41790: ARRAY
41791: PPUSH
41792: CALL_OW 266
41796: PUSH
41797: LD_INT 5
41799: EQUAL
41800: IFFALSE 41874
// begin if UnitsInside ( f [ 1 ] ) < 3 then
41802: LD_VAR 0 12
41806: PUSH
41807: LD_INT 1
41809: ARRAY
41810: PPUSH
41811: CALL_OW 313
41815: PUSH
41816: LD_INT 3
41818: LESS
41819: IFFALSE 41855
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
41821: LD_INT 0
41823: PPUSH
41824: LD_INT 5
41826: PUSH
41827: LD_INT 8
41829: PUSH
41830: LD_INT 9
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: LIST
41837: PUSH
41838: LD_VAR 0 17
41842: ARRAY
41843: PPUSH
41844: LD_VAR 0 4
41848: PPUSH
41849: CALL_OW 380
41853: GO 41872
// PrepareHuman ( false , i , skill ) ;
41855: LD_INT 0
41857: PPUSH
41858: LD_VAR 0 8
41862: PPUSH
41863: LD_VAR 0 4
41867: PPUSH
41868: CALL_OW 380
// end else
41872: GO 41891
// PrepareHuman ( false , i , skill ) ;
41874: LD_INT 0
41876: PPUSH
41877: LD_VAR 0 8
41881: PPUSH
41882: LD_VAR 0 4
41886: PPUSH
41887: CALL_OW 380
// un := CreateHuman ;
41891: LD_ADDR_VAR 0 14
41895: PUSH
41896: CALL_OW 44
41900: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
41901: LD_ADDR_VAR 0 7
41905: PUSH
41906: LD_VAR 0 7
41910: PPUSH
41911: LD_INT 1
41913: PPUSH
41914: LD_VAR 0 14
41918: PPUSH
41919: CALL_OW 2
41923: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
41924: LD_VAR 0 14
41928: PPUSH
41929: LD_VAR 0 12
41933: PUSH
41934: LD_INT 1
41936: ARRAY
41937: PPUSH
41938: CALL_OW 52
// end ;
41942: GO 41581
41944: POP
41945: POP
// end ;
41946: GO 40883
41948: POP
41949: POP
// result := result ^ buildings ;
41950: LD_ADDR_VAR 0 7
41954: PUSH
41955: LD_VAR 0 7
41959: PUSH
41960: LD_VAR 0 18
41964: ADD
41965: ST_TO_ADDR
// end else
41966: GO 42109
// begin for i = 1 to personel do
41968: LD_ADDR_VAR 0 8
41972: PUSH
41973: DOUBLE
41974: LD_INT 1
41976: DEC
41977: ST_TO_ADDR
41978: LD_VAR 0 6
41982: PUSH
41983: FOR_TO
41984: IFFALSE 42107
// begin if i > 4 then
41986: LD_VAR 0 8
41990: PUSH
41991: LD_INT 4
41993: GREATER
41994: IFFALSE 41998
// break ;
41996: GO 42107
// x := personel [ i ] ;
41998: LD_ADDR_VAR 0 13
42002: PUSH
42003: LD_VAR 0 6
42007: PUSH
42008: LD_VAR 0 8
42012: ARRAY
42013: ST_TO_ADDR
// if x = - 1 then
42014: LD_VAR 0 13
42018: PUSH
42019: LD_INT 1
42021: NEG
42022: EQUAL
42023: IFFALSE 42027
// continue ;
42025: GO 41983
// PrepareHuman ( false , i , skill ) ;
42027: LD_INT 0
42029: PPUSH
42030: LD_VAR 0 8
42034: PPUSH
42035: LD_VAR 0 4
42039: PPUSH
42040: CALL_OW 380
// un := CreateHuman ;
42044: LD_ADDR_VAR 0 14
42048: PUSH
42049: CALL_OW 44
42053: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
42054: LD_VAR 0 14
42058: PPUSH
42059: LD_VAR 0 1
42063: PPUSH
42064: CALL_OW 250
42068: PPUSH
42069: LD_VAR 0 1
42073: PPUSH
42074: CALL_OW 251
42078: PPUSH
42079: LD_INT 10
42081: PPUSH
42082: LD_INT 0
42084: PPUSH
42085: CALL_OW 50
// result := result ^ un ;
42089: LD_ADDR_VAR 0 7
42093: PUSH
42094: LD_VAR 0 7
42098: PUSH
42099: LD_VAR 0 14
42103: ADD
42104: ST_TO_ADDR
// end ;
42105: GO 41983
42107: POP
42108: POP
// end ; end ;
42109: LD_VAR 0 7
42113: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
42114: LD_INT 0
42116: PPUSH
42117: PPUSH
42118: PPUSH
42119: PPUSH
42120: PPUSH
42121: PPUSH
42122: PPUSH
42123: PPUSH
42124: PPUSH
42125: PPUSH
42126: PPUSH
42127: PPUSH
42128: PPUSH
42129: PPUSH
42130: PPUSH
42131: PPUSH
// result := false ;
42132: LD_ADDR_VAR 0 3
42136: PUSH
42137: LD_INT 0
42139: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
42140: LD_VAR 0 1
42144: NOT
42145: PUSH
42146: LD_VAR 0 1
42150: PPUSH
42151: CALL_OW 266
42155: PUSH
42156: LD_INT 32
42158: PUSH
42159: LD_INT 33
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: IN
42166: NOT
42167: OR
42168: IFFALSE 42172
// exit ;
42170: GO 43308
// nat := GetNation ( tower ) ;
42172: LD_ADDR_VAR 0 12
42176: PUSH
42177: LD_VAR 0 1
42181: PPUSH
42182: CALL_OW 248
42186: ST_TO_ADDR
// side := GetSide ( tower ) ;
42187: LD_ADDR_VAR 0 16
42191: PUSH
42192: LD_VAR 0 1
42196: PPUSH
42197: CALL_OW 255
42201: ST_TO_ADDR
// x := GetX ( tower ) ;
42202: LD_ADDR_VAR 0 10
42206: PUSH
42207: LD_VAR 0 1
42211: PPUSH
42212: CALL_OW 250
42216: ST_TO_ADDR
// y := GetY ( tower ) ;
42217: LD_ADDR_VAR 0 11
42221: PUSH
42222: LD_VAR 0 1
42226: PPUSH
42227: CALL_OW 251
42231: ST_TO_ADDR
// if not x or not y then
42232: LD_VAR 0 10
42236: NOT
42237: PUSH
42238: LD_VAR 0 11
42242: NOT
42243: OR
42244: IFFALSE 42248
// exit ;
42246: GO 43308
// weapon := 0 ;
42248: LD_ADDR_VAR 0 18
42252: PUSH
42253: LD_INT 0
42255: ST_TO_ADDR
// fac_list := [ ] ;
42256: LD_ADDR_VAR 0 17
42260: PUSH
42261: EMPTY
42262: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
42263: LD_ADDR_VAR 0 6
42267: PUSH
42268: LD_VAR 0 1
42272: PPUSH
42273: CALL_OW 274
42277: PPUSH
42278: LD_VAR 0 2
42282: PPUSH
42283: CALL 39886 0 2
42287: PPUSH
42288: LD_INT 30
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PPUSH
42298: CALL_OW 72
42302: ST_TO_ADDR
// if not factories then
42303: LD_VAR 0 6
42307: NOT
42308: IFFALSE 42312
// exit ;
42310: GO 43308
// for i in factories do
42312: LD_ADDR_VAR 0 8
42316: PUSH
42317: LD_VAR 0 6
42321: PUSH
42322: FOR_IN
42323: IFFALSE 42348
// fac_list := fac_list union AvailableWeaponList ( i ) ;
42325: LD_ADDR_VAR 0 17
42329: PUSH
42330: LD_VAR 0 17
42334: PUSH
42335: LD_VAR 0 8
42339: PPUSH
42340: CALL_OW 478
42344: UNION
42345: ST_TO_ADDR
42346: GO 42322
42348: POP
42349: POP
// if not fac_list then
42350: LD_VAR 0 17
42354: NOT
42355: IFFALSE 42359
// exit ;
42357: GO 43308
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
42359: LD_ADDR_VAR 0 5
42363: PUSH
42364: LD_INT 4
42366: PUSH
42367: LD_INT 5
42369: PUSH
42370: LD_INT 9
42372: PUSH
42373: LD_INT 10
42375: PUSH
42376: LD_INT 6
42378: PUSH
42379: LD_INT 7
42381: PUSH
42382: LD_INT 11
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: LIST
42389: LIST
42390: LIST
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 27
42396: PUSH
42397: LD_INT 28
42399: PUSH
42400: LD_INT 26
42402: PUSH
42403: LD_INT 30
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: PUSH
42412: LD_INT 43
42414: PUSH
42415: LD_INT 44
42417: PUSH
42418: LD_INT 46
42420: PUSH
42421: LD_INT 45
42423: PUSH
42424: LD_INT 47
42426: PUSH
42427: LD_INT 49
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: LIST
42442: PUSH
42443: LD_VAR 0 12
42447: ARRAY
42448: ST_TO_ADDR
// for i in list do
42449: LD_ADDR_VAR 0 8
42453: PUSH
42454: LD_VAR 0 5
42458: PUSH
42459: FOR_IN
42460: IFFALSE 42493
// if not i in fac_list then
42462: LD_VAR 0 8
42466: PUSH
42467: LD_VAR 0 17
42471: IN
42472: NOT
42473: IFFALSE 42491
// list := list diff i ;
42475: LD_ADDR_VAR 0 5
42479: PUSH
42480: LD_VAR 0 5
42484: PUSH
42485: LD_VAR 0 8
42489: DIFF
42490: ST_TO_ADDR
42491: GO 42459
42493: POP
42494: POP
// if not list then
42495: LD_VAR 0 5
42499: NOT
42500: IFFALSE 42504
// exit ;
42502: GO 43308
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
42504: LD_VAR 0 12
42508: PUSH
42509: LD_INT 3
42511: EQUAL
42512: PUSH
42513: LD_INT 49
42515: PUSH
42516: LD_VAR 0 5
42520: IN
42521: AND
42522: PUSH
42523: LD_INT 31
42525: PPUSH
42526: LD_VAR 0 16
42530: PPUSH
42531: CALL_OW 321
42535: PUSH
42536: LD_INT 2
42538: EQUAL
42539: AND
42540: IFFALSE 42600
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
42542: LD_INT 22
42544: PUSH
42545: LD_VAR 0 16
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 35
42556: PUSH
42557: LD_INT 49
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 91
42566: PUSH
42567: LD_VAR 0 1
42571: PUSH
42572: LD_INT 10
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: PPUSH
42585: CALL_OW 69
42589: NOT
42590: IFFALSE 42600
// weapon := ru_time_lapser ;
42592: LD_ADDR_VAR 0 18
42596: PUSH
42597: LD_INT 49
42599: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
42600: LD_VAR 0 12
42604: PUSH
42605: LD_INT 1
42607: PUSH
42608: LD_INT 2
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: IN
42615: PUSH
42616: LD_INT 11
42618: PUSH
42619: LD_VAR 0 5
42623: IN
42624: PUSH
42625: LD_INT 30
42627: PUSH
42628: LD_VAR 0 5
42632: IN
42633: OR
42634: AND
42635: PUSH
42636: LD_INT 6
42638: PPUSH
42639: LD_VAR 0 16
42643: PPUSH
42644: CALL_OW 321
42648: PUSH
42649: LD_INT 2
42651: EQUAL
42652: AND
42653: IFFALSE 42818
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
42655: LD_INT 22
42657: PUSH
42658: LD_VAR 0 16
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 2
42669: PUSH
42670: LD_INT 35
42672: PUSH
42673: LD_INT 11
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 35
42682: PUSH
42683: LD_INT 30
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: LIST
42694: PUSH
42695: LD_INT 91
42697: PUSH
42698: LD_VAR 0 1
42702: PUSH
42703: LD_INT 18
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: LIST
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: LIST
42715: PPUSH
42716: CALL_OW 69
42720: NOT
42721: PUSH
42722: LD_INT 22
42724: PUSH
42725: LD_VAR 0 16
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 2
42736: PUSH
42737: LD_INT 30
42739: PUSH
42740: LD_INT 32
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 30
42749: PUSH
42750: LD_INT 33
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 91
42764: PUSH
42765: LD_VAR 0 1
42769: PUSH
42770: LD_INT 12
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: LIST
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: LIST
42782: PUSH
42783: EMPTY
42784: LIST
42785: PPUSH
42786: CALL_OW 69
42790: PUSH
42791: LD_INT 2
42793: GREATER
42794: AND
42795: IFFALSE 42818
// weapon := [ us_radar , ar_radar ] [ nat ] ;
42797: LD_ADDR_VAR 0 18
42801: PUSH
42802: LD_INT 11
42804: PUSH
42805: LD_INT 30
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_VAR 0 12
42816: ARRAY
42817: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
42818: LD_VAR 0 18
42822: NOT
42823: PUSH
42824: LD_INT 40
42826: PPUSH
42827: LD_VAR 0 16
42831: PPUSH
42832: CALL_OW 321
42836: PUSH
42837: LD_INT 2
42839: EQUAL
42840: AND
42841: PUSH
42842: LD_INT 7
42844: PUSH
42845: LD_VAR 0 5
42849: IN
42850: PUSH
42851: LD_INT 28
42853: PUSH
42854: LD_VAR 0 5
42858: IN
42859: OR
42860: PUSH
42861: LD_INT 45
42863: PUSH
42864: LD_VAR 0 5
42868: IN
42869: OR
42870: AND
42871: IFFALSE 43125
// begin hex := GetHexInfo ( x , y ) ;
42873: LD_ADDR_VAR 0 4
42877: PUSH
42878: LD_VAR 0 10
42882: PPUSH
42883: LD_VAR 0 11
42887: PPUSH
42888: CALL_OW 546
42892: ST_TO_ADDR
// if hex [ 1 ] then
42893: LD_VAR 0 4
42897: PUSH
42898: LD_INT 1
42900: ARRAY
42901: IFFALSE 42905
// exit ;
42903: GO 43308
// height := hex [ 2 ] ;
42905: LD_ADDR_VAR 0 15
42909: PUSH
42910: LD_VAR 0 4
42914: PUSH
42915: LD_INT 2
42917: ARRAY
42918: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
42919: LD_ADDR_VAR 0 14
42923: PUSH
42924: LD_INT 0
42926: PUSH
42927: LD_INT 2
42929: PUSH
42930: LD_INT 3
42932: PUSH
42933: LD_INT 5
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: ST_TO_ADDR
// for i in tmp do
42942: LD_ADDR_VAR 0 8
42946: PUSH
42947: LD_VAR 0 14
42951: PUSH
42952: FOR_IN
42953: IFFALSE 43123
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
42955: LD_ADDR_VAR 0 9
42959: PUSH
42960: LD_VAR 0 10
42964: PPUSH
42965: LD_VAR 0 8
42969: PPUSH
42970: LD_INT 5
42972: PPUSH
42973: CALL_OW 272
42977: PUSH
42978: LD_VAR 0 11
42982: PPUSH
42983: LD_VAR 0 8
42987: PPUSH
42988: LD_INT 5
42990: PPUSH
42991: CALL_OW 273
42995: PUSH
42996: EMPTY
42997: LIST
42998: LIST
42999: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
43000: LD_VAR 0 9
43004: PUSH
43005: LD_INT 1
43007: ARRAY
43008: PPUSH
43009: LD_VAR 0 9
43013: PUSH
43014: LD_INT 2
43016: ARRAY
43017: PPUSH
43018: CALL_OW 488
43022: IFFALSE 43121
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
43024: LD_ADDR_VAR 0 4
43028: PUSH
43029: LD_VAR 0 9
43033: PUSH
43034: LD_INT 1
43036: ARRAY
43037: PPUSH
43038: LD_VAR 0 9
43042: PUSH
43043: LD_INT 2
43045: ARRAY
43046: PPUSH
43047: CALL_OW 546
43051: ST_TO_ADDR
// if hex [ 1 ] then
43052: LD_VAR 0 4
43056: PUSH
43057: LD_INT 1
43059: ARRAY
43060: IFFALSE 43064
// continue ;
43062: GO 42952
// h := hex [ 2 ] ;
43064: LD_ADDR_VAR 0 13
43068: PUSH
43069: LD_VAR 0 4
43073: PUSH
43074: LD_INT 2
43076: ARRAY
43077: ST_TO_ADDR
// if h + 7 < height then
43078: LD_VAR 0 13
43082: PUSH
43083: LD_INT 7
43085: PLUS
43086: PUSH
43087: LD_VAR 0 15
43091: LESS
43092: IFFALSE 43121
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
43094: LD_ADDR_VAR 0 18
43098: PUSH
43099: LD_INT 7
43101: PUSH
43102: LD_INT 28
43104: PUSH
43105: LD_INT 45
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: LIST
43112: PUSH
43113: LD_VAR 0 12
43117: ARRAY
43118: ST_TO_ADDR
// break ;
43119: GO 43123
// end ; end ; end ;
43121: GO 42952
43123: POP
43124: POP
// end ; if not weapon then
43125: LD_VAR 0 18
43129: NOT
43130: IFFALSE 43190
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
43132: LD_ADDR_VAR 0 5
43136: PUSH
43137: LD_VAR 0 5
43141: PUSH
43142: LD_INT 11
43144: PUSH
43145: LD_INT 30
43147: PUSH
43148: LD_INT 49
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: LIST
43155: DIFF
43156: ST_TO_ADDR
// if not list then
43157: LD_VAR 0 5
43161: NOT
43162: IFFALSE 43166
// exit ;
43164: GO 43308
// weapon := list [ rand ( 1 , list ) ] ;
43166: LD_ADDR_VAR 0 18
43170: PUSH
43171: LD_VAR 0 5
43175: PUSH
43176: LD_INT 1
43178: PPUSH
43179: LD_VAR 0 5
43183: PPUSH
43184: CALL_OW 12
43188: ARRAY
43189: ST_TO_ADDR
// end ; if weapon then
43190: LD_VAR 0 18
43194: IFFALSE 43308
// begin tmp := CostOfWeapon ( weapon ) ;
43196: LD_ADDR_VAR 0 14
43200: PUSH
43201: LD_VAR 0 18
43205: PPUSH
43206: CALL_OW 451
43210: ST_TO_ADDR
// j := GetBase ( tower ) ;
43211: LD_ADDR_VAR 0 9
43215: PUSH
43216: LD_VAR 0 1
43220: PPUSH
43221: CALL_OW 274
43225: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
43226: LD_VAR 0 9
43230: PPUSH
43231: LD_INT 1
43233: PPUSH
43234: CALL_OW 275
43238: PUSH
43239: LD_VAR 0 14
43243: PUSH
43244: LD_INT 1
43246: ARRAY
43247: GREATEREQUAL
43248: PUSH
43249: LD_VAR 0 9
43253: PPUSH
43254: LD_INT 2
43256: PPUSH
43257: CALL_OW 275
43261: PUSH
43262: LD_VAR 0 14
43266: PUSH
43267: LD_INT 2
43269: ARRAY
43270: GREATEREQUAL
43271: AND
43272: PUSH
43273: LD_VAR 0 9
43277: PPUSH
43278: LD_INT 3
43280: PPUSH
43281: CALL_OW 275
43285: PUSH
43286: LD_VAR 0 14
43290: PUSH
43291: LD_INT 3
43293: ARRAY
43294: GREATEREQUAL
43295: AND
43296: IFFALSE 43308
// result := weapon ;
43298: LD_ADDR_VAR 0 3
43302: PUSH
43303: LD_VAR 0 18
43307: ST_TO_ADDR
// end ; end ;
43308: LD_VAR 0 3
43312: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
43313: LD_INT 0
43315: PPUSH
43316: PPUSH
// result := true ;
43317: LD_ADDR_VAR 0 3
43321: PUSH
43322: LD_INT 1
43324: ST_TO_ADDR
// if array1 = array2 then
43325: LD_VAR 0 1
43329: PUSH
43330: LD_VAR 0 2
43334: EQUAL
43335: IFFALSE 43395
// begin for i = 1 to array1 do
43337: LD_ADDR_VAR 0 4
43341: PUSH
43342: DOUBLE
43343: LD_INT 1
43345: DEC
43346: ST_TO_ADDR
43347: LD_VAR 0 1
43351: PUSH
43352: FOR_TO
43353: IFFALSE 43391
// if array1 [ i ] <> array2 [ i ] then
43355: LD_VAR 0 1
43359: PUSH
43360: LD_VAR 0 4
43364: ARRAY
43365: PUSH
43366: LD_VAR 0 2
43370: PUSH
43371: LD_VAR 0 4
43375: ARRAY
43376: NONEQUAL
43377: IFFALSE 43389
// begin result := false ;
43379: LD_ADDR_VAR 0 3
43383: PUSH
43384: LD_INT 0
43386: ST_TO_ADDR
// break ;
43387: GO 43391
// end ;
43389: GO 43352
43391: POP
43392: POP
// end else
43393: GO 43403
// result := false ;
43395: LD_ADDR_VAR 0 3
43399: PUSH
43400: LD_INT 0
43402: ST_TO_ADDR
// end ;
43403: LD_VAR 0 3
43407: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
43408: LD_INT 0
43410: PPUSH
43411: PPUSH
43412: PPUSH
// pom := GetBase ( fac ) ;
43413: LD_ADDR_VAR 0 5
43417: PUSH
43418: LD_VAR 0 1
43422: PPUSH
43423: CALL_OW 274
43427: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
43428: LD_ADDR_VAR 0 4
43432: PUSH
43433: LD_VAR 0 2
43437: PUSH
43438: LD_INT 1
43440: ARRAY
43441: PPUSH
43442: LD_VAR 0 2
43446: PUSH
43447: LD_INT 2
43449: ARRAY
43450: PPUSH
43451: LD_VAR 0 2
43455: PUSH
43456: LD_INT 3
43458: ARRAY
43459: PPUSH
43460: LD_VAR 0 2
43464: PUSH
43465: LD_INT 4
43467: ARRAY
43468: PPUSH
43469: CALL_OW 449
43473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
43474: LD_ADDR_VAR 0 3
43478: PUSH
43479: LD_VAR 0 5
43483: PPUSH
43484: LD_INT 1
43486: PPUSH
43487: CALL_OW 275
43491: PUSH
43492: LD_VAR 0 4
43496: PUSH
43497: LD_INT 1
43499: ARRAY
43500: GREATEREQUAL
43501: PUSH
43502: LD_VAR 0 5
43506: PPUSH
43507: LD_INT 2
43509: PPUSH
43510: CALL_OW 275
43514: PUSH
43515: LD_VAR 0 4
43519: PUSH
43520: LD_INT 2
43522: ARRAY
43523: GREATEREQUAL
43524: AND
43525: PUSH
43526: LD_VAR 0 5
43530: PPUSH
43531: LD_INT 3
43533: PPUSH
43534: CALL_OW 275
43538: PUSH
43539: LD_VAR 0 4
43543: PUSH
43544: LD_INT 3
43546: ARRAY
43547: GREATEREQUAL
43548: AND
43549: ST_TO_ADDR
// end ;
43550: LD_VAR 0 3
43554: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
43555: LD_INT 0
43557: PPUSH
43558: PPUSH
43559: PPUSH
43560: PPUSH
// pom := GetBase ( building ) ;
43561: LD_ADDR_VAR 0 3
43565: PUSH
43566: LD_VAR 0 1
43570: PPUSH
43571: CALL_OW 274
43575: ST_TO_ADDR
// if not pom then
43576: LD_VAR 0 3
43580: NOT
43581: IFFALSE 43585
// exit ;
43583: GO 43755
// btype := GetBType ( building ) ;
43585: LD_ADDR_VAR 0 5
43589: PUSH
43590: LD_VAR 0 1
43594: PPUSH
43595: CALL_OW 266
43599: ST_TO_ADDR
// if btype = b_armoury then
43600: LD_VAR 0 5
43604: PUSH
43605: LD_INT 4
43607: EQUAL
43608: IFFALSE 43618
// btype := b_barracks ;
43610: LD_ADDR_VAR 0 5
43614: PUSH
43615: LD_INT 5
43617: ST_TO_ADDR
// if btype = b_depot then
43618: LD_VAR 0 5
43622: PUSH
43623: LD_INT 0
43625: EQUAL
43626: IFFALSE 43636
// btype := b_warehouse ;
43628: LD_ADDR_VAR 0 5
43632: PUSH
43633: LD_INT 1
43635: ST_TO_ADDR
// if btype = b_workshop then
43636: LD_VAR 0 5
43640: PUSH
43641: LD_INT 2
43643: EQUAL
43644: IFFALSE 43654
// btype := b_factory ;
43646: LD_ADDR_VAR 0 5
43650: PUSH
43651: LD_INT 3
43653: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
43654: LD_ADDR_VAR 0 4
43658: PUSH
43659: LD_VAR 0 5
43663: PPUSH
43664: LD_VAR 0 1
43668: PPUSH
43669: CALL_OW 248
43673: PPUSH
43674: CALL_OW 450
43678: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
43679: LD_ADDR_VAR 0 2
43683: PUSH
43684: LD_VAR 0 3
43688: PPUSH
43689: LD_INT 1
43691: PPUSH
43692: CALL_OW 275
43696: PUSH
43697: LD_VAR 0 4
43701: PUSH
43702: LD_INT 1
43704: ARRAY
43705: GREATEREQUAL
43706: PUSH
43707: LD_VAR 0 3
43711: PPUSH
43712: LD_INT 2
43714: PPUSH
43715: CALL_OW 275
43719: PUSH
43720: LD_VAR 0 4
43724: PUSH
43725: LD_INT 2
43727: ARRAY
43728: GREATEREQUAL
43729: AND
43730: PUSH
43731: LD_VAR 0 3
43735: PPUSH
43736: LD_INT 3
43738: PPUSH
43739: CALL_OW 275
43743: PUSH
43744: LD_VAR 0 4
43748: PUSH
43749: LD_INT 3
43751: ARRAY
43752: GREATEREQUAL
43753: AND
43754: ST_TO_ADDR
// end ;
43755: LD_VAR 0 2
43759: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
43760: LD_INT 0
43762: PPUSH
43763: PPUSH
43764: PPUSH
// pom := GetBase ( building ) ;
43765: LD_ADDR_VAR 0 4
43769: PUSH
43770: LD_VAR 0 1
43774: PPUSH
43775: CALL_OW 274
43779: ST_TO_ADDR
// if not pom then
43780: LD_VAR 0 4
43784: NOT
43785: IFFALSE 43789
// exit ;
43787: GO 43890
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
43789: LD_ADDR_VAR 0 5
43793: PUSH
43794: LD_VAR 0 2
43798: PPUSH
43799: LD_VAR 0 1
43803: PPUSH
43804: CALL_OW 248
43808: PPUSH
43809: CALL_OW 450
43813: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
43814: LD_ADDR_VAR 0 3
43818: PUSH
43819: LD_VAR 0 4
43823: PPUSH
43824: LD_INT 1
43826: PPUSH
43827: CALL_OW 275
43831: PUSH
43832: LD_VAR 0 5
43836: PUSH
43837: LD_INT 1
43839: ARRAY
43840: GREATEREQUAL
43841: PUSH
43842: LD_VAR 0 4
43846: PPUSH
43847: LD_INT 2
43849: PPUSH
43850: CALL_OW 275
43854: PUSH
43855: LD_VAR 0 5
43859: PUSH
43860: LD_INT 2
43862: ARRAY
43863: GREATEREQUAL
43864: AND
43865: PUSH
43866: LD_VAR 0 4
43870: PPUSH
43871: LD_INT 3
43873: PPUSH
43874: CALL_OW 275
43878: PUSH
43879: LD_VAR 0 5
43883: PUSH
43884: LD_INT 3
43886: ARRAY
43887: GREATEREQUAL
43888: AND
43889: ST_TO_ADDR
// end ;
43890: LD_VAR 0 3
43894: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
43895: LD_INT 0
43897: PPUSH
43898: PPUSH
43899: PPUSH
43900: PPUSH
43901: PPUSH
43902: PPUSH
43903: PPUSH
43904: PPUSH
43905: PPUSH
43906: PPUSH
// result := false ;
43907: LD_ADDR_VAR 0 6
43911: PUSH
43912: LD_INT 0
43914: ST_TO_ADDR
// if not base or not btype or not x or not y then
43915: LD_VAR 0 1
43919: NOT
43920: PUSH
43921: LD_VAR 0 2
43925: NOT
43926: OR
43927: PUSH
43928: LD_VAR 0 3
43932: NOT
43933: OR
43934: PUSH
43935: LD_VAR 0 4
43939: NOT
43940: OR
43941: IFFALSE 43945
// exit ;
43943: GO 44536
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
43945: LD_ADDR_VAR 0 12
43949: PUSH
43950: LD_VAR 0 2
43954: PPUSH
43955: LD_VAR 0 3
43959: PPUSH
43960: LD_VAR 0 4
43964: PPUSH
43965: LD_VAR 0 5
43969: PPUSH
43970: LD_VAR 0 1
43974: PUSH
43975: LD_INT 1
43977: ARRAY
43978: PPUSH
43979: CALL_OW 248
43983: PPUSH
43984: LD_INT 0
43986: PPUSH
43987: CALL 45373 0 6
43991: ST_TO_ADDR
// if not hexes then
43992: LD_VAR 0 12
43996: NOT
43997: IFFALSE 44001
// exit ;
43999: GO 44536
// for i = 1 to hexes do
44001: LD_ADDR_VAR 0 7
44005: PUSH
44006: DOUBLE
44007: LD_INT 1
44009: DEC
44010: ST_TO_ADDR
44011: LD_VAR 0 12
44015: PUSH
44016: FOR_TO
44017: IFFALSE 44534
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44019: LD_ADDR_VAR 0 11
44023: PUSH
44024: LD_VAR 0 12
44028: PUSH
44029: LD_VAR 0 7
44033: ARRAY
44034: PUSH
44035: LD_INT 1
44037: ARRAY
44038: PPUSH
44039: LD_VAR 0 12
44043: PUSH
44044: LD_VAR 0 7
44048: ARRAY
44049: PUSH
44050: LD_INT 2
44052: ARRAY
44053: PPUSH
44054: CALL_OW 428
44058: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
44059: LD_VAR 0 12
44063: PUSH
44064: LD_VAR 0 7
44068: ARRAY
44069: PUSH
44070: LD_INT 1
44072: ARRAY
44073: PPUSH
44074: LD_VAR 0 12
44078: PUSH
44079: LD_VAR 0 7
44083: ARRAY
44084: PUSH
44085: LD_INT 2
44087: ARRAY
44088: PPUSH
44089: CALL_OW 351
44093: PUSH
44094: LD_VAR 0 12
44098: PUSH
44099: LD_VAR 0 7
44103: ARRAY
44104: PUSH
44105: LD_INT 1
44107: ARRAY
44108: PPUSH
44109: LD_VAR 0 12
44113: PUSH
44114: LD_VAR 0 7
44118: ARRAY
44119: PUSH
44120: LD_INT 2
44122: ARRAY
44123: PPUSH
44124: CALL_OW 488
44128: NOT
44129: OR
44130: PUSH
44131: LD_VAR 0 11
44135: PPUSH
44136: CALL_OW 247
44140: PUSH
44141: LD_INT 3
44143: EQUAL
44144: OR
44145: IFFALSE 44151
// exit ;
44147: POP
44148: POP
44149: GO 44536
// if not tmp then
44151: LD_VAR 0 11
44155: NOT
44156: IFFALSE 44160
// continue ;
44158: GO 44016
// result := true ;
44160: LD_ADDR_VAR 0 6
44164: PUSH
44165: LD_INT 1
44167: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
44168: LD_ADDR_VAR 0 15
44172: PUSH
44173: LD_INT 22
44175: PUSH
44176: LD_VAR 0 11
44180: PPUSH
44181: CALL_OW 255
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 2
44192: PUSH
44193: LD_INT 30
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 30
44205: PUSH
44206: LD_INT 1
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: LIST
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PPUSH
44222: CALL_OW 69
44226: ST_TO_ADDR
// if dep then
44227: LD_VAR 0 15
44231: IFFALSE 44367
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
44233: LD_ADDR_VAR 0 14
44237: PUSH
44238: LD_VAR 0 15
44242: PUSH
44243: LD_INT 1
44245: ARRAY
44246: PPUSH
44247: CALL_OW 250
44251: PPUSH
44252: LD_VAR 0 15
44256: PUSH
44257: LD_INT 1
44259: ARRAY
44260: PPUSH
44261: CALL_OW 254
44265: PPUSH
44266: LD_INT 5
44268: PPUSH
44269: CALL_OW 272
44273: PUSH
44274: LD_VAR 0 15
44278: PUSH
44279: LD_INT 1
44281: ARRAY
44282: PPUSH
44283: CALL_OW 251
44287: PPUSH
44288: LD_VAR 0 15
44292: PUSH
44293: LD_INT 1
44295: ARRAY
44296: PPUSH
44297: CALL_OW 254
44301: PPUSH
44302: LD_INT 5
44304: PPUSH
44305: CALL_OW 273
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
44314: LD_VAR 0 14
44318: PUSH
44319: LD_INT 1
44321: ARRAY
44322: PPUSH
44323: LD_VAR 0 14
44327: PUSH
44328: LD_INT 2
44330: ARRAY
44331: PPUSH
44332: CALL_OW 488
44336: IFFALSE 44367
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
44338: LD_VAR 0 11
44342: PPUSH
44343: LD_VAR 0 14
44347: PUSH
44348: LD_INT 1
44350: ARRAY
44351: PPUSH
44352: LD_VAR 0 14
44356: PUSH
44357: LD_INT 2
44359: ARRAY
44360: PPUSH
44361: CALL_OW 111
// continue ;
44365: GO 44016
// end ; end ; r := GetDir ( tmp ) ;
44367: LD_ADDR_VAR 0 13
44371: PUSH
44372: LD_VAR 0 11
44376: PPUSH
44377: CALL_OW 254
44381: ST_TO_ADDR
// if r = 5 then
44382: LD_VAR 0 13
44386: PUSH
44387: LD_INT 5
44389: EQUAL
44390: IFFALSE 44400
// r := 0 ;
44392: LD_ADDR_VAR 0 13
44396: PUSH
44397: LD_INT 0
44399: ST_TO_ADDR
// for j = r to 5 do
44400: LD_ADDR_VAR 0 8
44404: PUSH
44405: DOUBLE
44406: LD_VAR 0 13
44410: DEC
44411: ST_TO_ADDR
44412: LD_INT 5
44414: PUSH
44415: FOR_TO
44416: IFFALSE 44530
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
44418: LD_ADDR_VAR 0 9
44422: PUSH
44423: LD_VAR 0 11
44427: PPUSH
44428: CALL_OW 250
44432: PPUSH
44433: LD_VAR 0 8
44437: PPUSH
44438: LD_INT 2
44440: PPUSH
44441: CALL_OW 272
44445: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
44446: LD_ADDR_VAR 0 10
44450: PUSH
44451: LD_VAR 0 11
44455: PPUSH
44456: CALL_OW 251
44460: PPUSH
44461: LD_VAR 0 8
44465: PPUSH
44466: LD_INT 2
44468: PPUSH
44469: CALL_OW 273
44473: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
44474: LD_VAR 0 9
44478: PPUSH
44479: LD_VAR 0 10
44483: PPUSH
44484: CALL_OW 488
44488: PUSH
44489: LD_VAR 0 9
44493: PPUSH
44494: LD_VAR 0 10
44498: PPUSH
44499: CALL_OW 428
44503: NOT
44504: AND
44505: IFFALSE 44528
// begin ComMoveXY ( tmp , _x , _y ) ;
44507: LD_VAR 0 11
44511: PPUSH
44512: LD_VAR 0 9
44516: PPUSH
44517: LD_VAR 0 10
44521: PPUSH
44522: CALL_OW 111
// break ;
44526: GO 44530
// end ; end ;
44528: GO 44415
44530: POP
44531: POP
// end ;
44532: GO 44016
44534: POP
44535: POP
// end ;
44536: LD_VAR 0 6
44540: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
44541: LD_INT 0
44543: PPUSH
44544: PPUSH
44545: PPUSH
44546: PPUSH
44547: PPUSH
44548: PPUSH
44549: PPUSH
44550: PPUSH
44551: PPUSH
44552: PPUSH
// result := false ;
44553: LD_ADDR_VAR 0 6
44557: PUSH
44558: LD_INT 0
44560: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
44561: LD_VAR 0 1
44565: NOT
44566: PUSH
44567: LD_VAR 0 1
44571: PPUSH
44572: CALL_OW 266
44576: PUSH
44577: LD_INT 0
44579: PUSH
44580: LD_INT 1
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: IN
44587: NOT
44588: OR
44589: PUSH
44590: LD_VAR 0 2
44594: NOT
44595: OR
44596: PUSH
44597: LD_VAR 0 5
44601: PUSH
44602: LD_INT 0
44604: PUSH
44605: LD_INT 1
44607: PUSH
44608: LD_INT 2
44610: PUSH
44611: LD_INT 3
44613: PUSH
44614: LD_INT 4
44616: PUSH
44617: LD_INT 5
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: IN
44628: NOT
44629: OR
44630: PUSH
44631: LD_VAR 0 3
44635: PPUSH
44636: LD_VAR 0 4
44640: PPUSH
44641: CALL_OW 488
44645: NOT
44646: OR
44647: IFFALSE 44651
// exit ;
44649: GO 45368
// pom := GetBase ( bdepot ) ;
44651: LD_ADDR_VAR 0 10
44655: PUSH
44656: LD_VAR 0 1
44660: PPUSH
44661: CALL_OW 274
44665: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
44666: LD_ADDR_VAR 0 11
44670: PUSH
44671: LD_VAR 0 2
44675: PPUSH
44676: LD_VAR 0 1
44680: PPUSH
44681: CALL_OW 248
44685: PPUSH
44686: CALL_OW 450
44690: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
44691: LD_VAR 0 10
44695: PPUSH
44696: LD_INT 1
44698: PPUSH
44699: CALL_OW 275
44703: PUSH
44704: LD_VAR 0 11
44708: PUSH
44709: LD_INT 1
44711: ARRAY
44712: GREATEREQUAL
44713: PUSH
44714: LD_VAR 0 10
44718: PPUSH
44719: LD_INT 2
44721: PPUSH
44722: CALL_OW 275
44726: PUSH
44727: LD_VAR 0 11
44731: PUSH
44732: LD_INT 2
44734: ARRAY
44735: GREATEREQUAL
44736: AND
44737: PUSH
44738: LD_VAR 0 10
44742: PPUSH
44743: LD_INT 3
44745: PPUSH
44746: CALL_OW 275
44750: PUSH
44751: LD_VAR 0 11
44755: PUSH
44756: LD_INT 3
44758: ARRAY
44759: GREATEREQUAL
44760: AND
44761: NOT
44762: IFFALSE 44766
// exit ;
44764: GO 45368
// if GetBType ( bdepot ) = b_depot then
44766: LD_VAR 0 1
44770: PPUSH
44771: CALL_OW 266
44775: PUSH
44776: LD_INT 0
44778: EQUAL
44779: IFFALSE 44791
// dist := 28 else
44781: LD_ADDR_VAR 0 14
44785: PUSH
44786: LD_INT 28
44788: ST_TO_ADDR
44789: GO 44799
// dist := 36 ;
44791: LD_ADDR_VAR 0 14
44795: PUSH
44796: LD_INT 36
44798: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
44799: LD_VAR 0 1
44803: PPUSH
44804: LD_VAR 0 3
44808: PPUSH
44809: LD_VAR 0 4
44813: PPUSH
44814: CALL_OW 297
44818: PUSH
44819: LD_VAR 0 14
44823: GREATER
44824: IFFALSE 44828
// exit ;
44826: GO 45368
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
44828: LD_ADDR_VAR 0 12
44832: PUSH
44833: LD_VAR 0 2
44837: PPUSH
44838: LD_VAR 0 3
44842: PPUSH
44843: LD_VAR 0 4
44847: PPUSH
44848: LD_VAR 0 5
44852: PPUSH
44853: LD_VAR 0 1
44857: PPUSH
44858: CALL_OW 248
44862: PPUSH
44863: LD_INT 0
44865: PPUSH
44866: CALL 45373 0 6
44870: ST_TO_ADDR
// if not hexes then
44871: LD_VAR 0 12
44875: NOT
44876: IFFALSE 44880
// exit ;
44878: GO 45368
// hex := GetHexInfo ( x , y ) ;
44880: LD_ADDR_VAR 0 15
44884: PUSH
44885: LD_VAR 0 3
44889: PPUSH
44890: LD_VAR 0 4
44894: PPUSH
44895: CALL_OW 546
44899: ST_TO_ADDR
// if hex [ 1 ] then
44900: LD_VAR 0 15
44904: PUSH
44905: LD_INT 1
44907: ARRAY
44908: IFFALSE 44912
// exit ;
44910: GO 45368
// height := hex [ 2 ] ;
44912: LD_ADDR_VAR 0 13
44916: PUSH
44917: LD_VAR 0 15
44921: PUSH
44922: LD_INT 2
44924: ARRAY
44925: ST_TO_ADDR
// for i = 1 to hexes do
44926: LD_ADDR_VAR 0 7
44930: PUSH
44931: DOUBLE
44932: LD_INT 1
44934: DEC
44935: ST_TO_ADDR
44936: LD_VAR 0 12
44940: PUSH
44941: FOR_TO
44942: IFFALSE 45272
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
44944: LD_VAR 0 12
44948: PUSH
44949: LD_VAR 0 7
44953: ARRAY
44954: PUSH
44955: LD_INT 1
44957: ARRAY
44958: PPUSH
44959: LD_VAR 0 12
44963: PUSH
44964: LD_VAR 0 7
44968: ARRAY
44969: PUSH
44970: LD_INT 2
44972: ARRAY
44973: PPUSH
44974: CALL_OW 488
44978: NOT
44979: PUSH
44980: LD_VAR 0 12
44984: PUSH
44985: LD_VAR 0 7
44989: ARRAY
44990: PUSH
44991: LD_INT 1
44993: ARRAY
44994: PPUSH
44995: LD_VAR 0 12
44999: PUSH
45000: LD_VAR 0 7
45004: ARRAY
45005: PUSH
45006: LD_INT 2
45008: ARRAY
45009: PPUSH
45010: CALL_OW 428
45014: PUSH
45015: LD_INT 0
45017: GREATER
45018: OR
45019: PUSH
45020: LD_VAR 0 12
45024: PUSH
45025: LD_VAR 0 7
45029: ARRAY
45030: PUSH
45031: LD_INT 1
45033: ARRAY
45034: PPUSH
45035: LD_VAR 0 12
45039: PUSH
45040: LD_VAR 0 7
45044: ARRAY
45045: PUSH
45046: LD_INT 2
45048: ARRAY
45049: PPUSH
45050: CALL_OW 351
45054: OR
45055: IFFALSE 45061
// exit ;
45057: POP
45058: POP
45059: GO 45368
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45061: LD_ADDR_VAR 0 8
45065: PUSH
45066: LD_VAR 0 12
45070: PUSH
45071: LD_VAR 0 7
45075: ARRAY
45076: PUSH
45077: LD_INT 1
45079: ARRAY
45080: PPUSH
45081: LD_VAR 0 12
45085: PUSH
45086: LD_VAR 0 7
45090: ARRAY
45091: PUSH
45092: LD_INT 2
45094: ARRAY
45095: PPUSH
45096: CALL_OW 546
45100: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
45101: LD_VAR 0 8
45105: PUSH
45106: LD_INT 1
45108: ARRAY
45109: PUSH
45110: LD_VAR 0 8
45114: PUSH
45115: LD_INT 2
45117: ARRAY
45118: PUSH
45119: LD_VAR 0 13
45123: PUSH
45124: LD_INT 2
45126: PLUS
45127: GREATER
45128: OR
45129: PUSH
45130: LD_VAR 0 8
45134: PUSH
45135: LD_INT 2
45137: ARRAY
45138: PUSH
45139: LD_VAR 0 13
45143: PUSH
45144: LD_INT 2
45146: MINUS
45147: LESS
45148: OR
45149: PUSH
45150: LD_VAR 0 8
45154: PUSH
45155: LD_INT 3
45157: ARRAY
45158: PUSH
45159: LD_INT 0
45161: PUSH
45162: LD_INT 8
45164: PUSH
45165: LD_INT 9
45167: PUSH
45168: LD_INT 10
45170: PUSH
45171: LD_INT 11
45173: PUSH
45174: LD_INT 12
45176: PUSH
45177: LD_INT 13
45179: PUSH
45180: LD_INT 16
45182: PUSH
45183: LD_INT 17
45185: PUSH
45186: LD_INT 18
45188: PUSH
45189: LD_INT 19
45191: PUSH
45192: LD_INT 20
45194: PUSH
45195: LD_INT 21
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: IN
45213: NOT
45214: OR
45215: PUSH
45216: LD_VAR 0 8
45220: PUSH
45221: LD_INT 5
45223: ARRAY
45224: NOT
45225: OR
45226: PUSH
45227: LD_VAR 0 8
45231: PUSH
45232: LD_INT 6
45234: ARRAY
45235: PUSH
45236: LD_INT 1
45238: PUSH
45239: LD_INT 2
45241: PUSH
45242: LD_INT 7
45244: PUSH
45245: LD_INT 9
45247: PUSH
45248: LD_INT 10
45250: PUSH
45251: LD_INT 11
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: IN
45262: NOT
45263: OR
45264: IFFALSE 45270
// exit ;
45266: POP
45267: POP
45268: GO 45368
// end ;
45270: GO 44941
45272: POP
45273: POP
// side := GetSide ( bdepot ) ;
45274: LD_ADDR_VAR 0 9
45278: PUSH
45279: LD_VAR 0 1
45283: PPUSH
45284: CALL_OW 255
45288: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
45289: LD_VAR 0 9
45293: PPUSH
45294: LD_VAR 0 3
45298: PPUSH
45299: LD_VAR 0 4
45303: PPUSH
45304: LD_INT 20
45306: PPUSH
45307: CALL 38040 0 4
45311: PUSH
45312: LD_INT 4
45314: ARRAY
45315: IFFALSE 45319
// exit ;
45317: GO 45368
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
45319: LD_VAR 0 2
45323: PUSH
45324: LD_INT 29
45326: PUSH
45327: LD_INT 30
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: IN
45334: PUSH
45335: LD_VAR 0 3
45339: PPUSH
45340: LD_VAR 0 4
45344: PPUSH
45345: LD_VAR 0 9
45349: PPUSH
45350: CALL_OW 440
45354: NOT
45355: AND
45356: IFFALSE 45360
// exit ;
45358: GO 45368
// result := true ;
45360: LD_ADDR_VAR 0 6
45364: PUSH
45365: LD_INT 1
45367: ST_TO_ADDR
// end ;
45368: LD_VAR 0 6
45372: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
45373: LD_INT 0
45375: PPUSH
45376: PPUSH
45377: PPUSH
45378: PPUSH
45379: PPUSH
45380: PPUSH
45381: PPUSH
45382: PPUSH
45383: PPUSH
45384: PPUSH
45385: PPUSH
45386: PPUSH
45387: PPUSH
45388: PPUSH
45389: PPUSH
45390: PPUSH
45391: PPUSH
45392: PPUSH
45393: PPUSH
45394: PPUSH
45395: PPUSH
45396: PPUSH
45397: PPUSH
45398: PPUSH
45399: PPUSH
45400: PPUSH
45401: PPUSH
45402: PPUSH
45403: PPUSH
45404: PPUSH
45405: PPUSH
45406: PPUSH
45407: PPUSH
45408: PPUSH
45409: PPUSH
45410: PPUSH
45411: PPUSH
45412: PPUSH
45413: PPUSH
45414: PPUSH
45415: PPUSH
45416: PPUSH
45417: PPUSH
45418: PPUSH
45419: PPUSH
45420: PPUSH
45421: PPUSH
45422: PPUSH
45423: PPUSH
45424: PPUSH
45425: PPUSH
45426: PPUSH
45427: PPUSH
45428: PPUSH
45429: PPUSH
45430: PPUSH
45431: PPUSH
45432: PPUSH
// result = [ ] ;
45433: LD_ADDR_VAR 0 7
45437: PUSH
45438: EMPTY
45439: ST_TO_ADDR
// temp_list = [ ] ;
45440: LD_ADDR_VAR 0 9
45444: PUSH
45445: EMPTY
45446: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
45447: LD_VAR 0 4
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: LD_INT 1
45457: PUSH
45458: LD_INT 2
45460: PUSH
45461: LD_INT 3
45463: PUSH
45464: LD_INT 4
45466: PUSH
45467: LD_INT 5
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: IN
45478: NOT
45479: PUSH
45480: LD_VAR 0 1
45484: PUSH
45485: LD_INT 0
45487: PUSH
45488: LD_INT 1
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: IN
45495: PUSH
45496: LD_VAR 0 5
45500: PUSH
45501: LD_INT 1
45503: PUSH
45504: LD_INT 2
45506: PUSH
45507: LD_INT 3
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: LIST
45514: IN
45515: NOT
45516: AND
45517: OR
45518: IFFALSE 45522
// exit ;
45520: GO 63907
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
45522: LD_VAR 0 1
45526: PUSH
45527: LD_INT 6
45529: PUSH
45530: LD_INT 7
45532: PUSH
45533: LD_INT 8
45535: PUSH
45536: LD_INT 13
45538: PUSH
45539: LD_INT 12
45541: PUSH
45542: LD_INT 15
45544: PUSH
45545: LD_INT 11
45547: PUSH
45548: LD_INT 14
45550: PUSH
45551: LD_INT 10
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: IN
45565: IFFALSE 45575
// btype = b_lab ;
45567: LD_ADDR_VAR 0 1
45571: PUSH
45572: LD_INT 6
45574: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
45575: LD_VAR 0 6
45579: PUSH
45580: LD_INT 0
45582: PUSH
45583: LD_INT 1
45585: PUSH
45586: LD_INT 2
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: LIST
45593: IN
45594: NOT
45595: PUSH
45596: LD_VAR 0 1
45600: PUSH
45601: LD_INT 0
45603: PUSH
45604: LD_INT 1
45606: PUSH
45607: LD_INT 2
45609: PUSH
45610: LD_INT 3
45612: PUSH
45613: LD_INT 6
45615: PUSH
45616: LD_INT 36
45618: PUSH
45619: LD_INT 4
45621: PUSH
45622: LD_INT 5
45624: PUSH
45625: LD_INT 31
45627: PUSH
45628: LD_INT 32
45630: PUSH
45631: LD_INT 33
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: IN
45647: NOT
45648: PUSH
45649: LD_VAR 0 6
45653: PUSH
45654: LD_INT 1
45656: EQUAL
45657: AND
45658: OR
45659: PUSH
45660: LD_VAR 0 1
45664: PUSH
45665: LD_INT 2
45667: PUSH
45668: LD_INT 3
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: IN
45675: NOT
45676: PUSH
45677: LD_VAR 0 6
45681: PUSH
45682: LD_INT 2
45684: EQUAL
45685: AND
45686: OR
45687: IFFALSE 45697
// mode = 0 ;
45689: LD_ADDR_VAR 0 6
45693: PUSH
45694: LD_INT 0
45696: ST_TO_ADDR
// case mode of 0 :
45697: LD_VAR 0 6
45701: PUSH
45702: LD_INT 0
45704: DOUBLE
45705: EQUAL
45706: IFTRUE 45710
45708: GO 57163
45710: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45711: LD_ADDR_VAR 0 11
45715: PUSH
45716: LD_INT 0
45718: PUSH
45719: LD_INT 0
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 0
45728: PUSH
45729: LD_INT 1
45731: NEG
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: PUSH
45740: LD_INT 0
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 1
45749: PUSH
45750: LD_INT 1
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 0
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 1
45769: NEG
45770: PUSH
45771: LD_INT 0
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: PUSH
45778: LD_INT 1
45780: NEG
45781: PUSH
45782: LD_INT 1
45784: NEG
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: LD_INT 1
45792: NEG
45793: PUSH
45794: LD_INT 2
45796: NEG
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: PUSH
45802: LD_INT 0
45804: PUSH
45805: LD_INT 2
45807: NEG
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: PUSH
45813: LD_INT 1
45815: PUSH
45816: LD_INT 1
45818: NEG
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: LD_INT 1
45826: PUSH
45827: LD_INT 2
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 0
45836: PUSH
45837: LD_INT 2
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 1
45846: NEG
45847: PUSH
45848: LD_INT 1
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: PUSH
45855: LD_INT 1
45857: PUSH
45858: LD_INT 3
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: PUSH
45865: LD_INT 0
45867: PUSH
45868: LD_INT 3
45870: PUSH
45871: EMPTY
45872: LIST
45873: LIST
45874: PUSH
45875: LD_INT 1
45877: NEG
45878: PUSH
45879: LD_INT 2
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45904: LD_ADDR_VAR 0 12
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: LD_INT 0
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 0
45921: PUSH
45922: LD_INT 1
45924: NEG
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: LD_INT 1
45932: PUSH
45933: LD_INT 0
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 1
45942: PUSH
45943: LD_INT 1
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: PUSH
45950: LD_INT 0
45952: PUSH
45953: LD_INT 1
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 1
45962: NEG
45963: PUSH
45964: LD_INT 0
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PUSH
45971: LD_INT 1
45973: NEG
45974: PUSH
45975: LD_INT 1
45977: NEG
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PUSH
45983: LD_INT 1
45985: PUSH
45986: LD_INT 1
45988: NEG
45989: PUSH
45990: EMPTY
45991: LIST
45992: LIST
45993: PUSH
45994: LD_INT 2
45996: PUSH
45997: LD_INT 0
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: LD_INT 1
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: PUSH
46014: LD_INT 1
46016: NEG
46017: PUSH
46018: LD_INT 1
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PUSH
46025: LD_INT 2
46027: NEG
46028: PUSH
46029: LD_INT 0
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 2
46038: NEG
46039: PUSH
46040: LD_INT 1
46042: NEG
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 2
46050: NEG
46051: PUSH
46052: LD_INT 1
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 3
46061: NEG
46062: PUSH
46063: LD_INT 0
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 3
46072: NEG
46073: PUSH
46074: LD_INT 1
46076: NEG
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46100: LD_ADDR_VAR 0 13
46104: PUSH
46105: LD_INT 0
46107: PUSH
46108: LD_INT 0
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 0
46117: PUSH
46118: LD_INT 1
46120: NEG
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 1
46128: PUSH
46129: LD_INT 0
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 1
46138: PUSH
46139: LD_INT 1
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 0
46148: PUSH
46149: LD_INT 1
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 1
46158: NEG
46159: PUSH
46160: LD_INT 0
46162: PUSH
46163: EMPTY
46164: LIST
46165: LIST
46166: PUSH
46167: LD_INT 1
46169: NEG
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 1
46181: NEG
46182: PUSH
46183: LD_INT 2
46185: NEG
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: LD_INT 2
46193: PUSH
46194: LD_INT 1
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 2
46203: PUSH
46204: LD_INT 2
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 1
46213: PUSH
46214: LD_INT 2
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: LD_INT 2
46223: NEG
46224: PUSH
46225: LD_INT 1
46227: NEG
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 2
46235: NEG
46236: PUSH
46237: LD_INT 2
46239: NEG
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 2
46247: NEG
46248: PUSH
46249: LD_INT 3
46251: NEG
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 3
46259: NEG
46260: PUSH
46261: LD_INT 2
46263: NEG
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: LD_INT 3
46271: NEG
46272: PUSH
46273: LD_INT 3
46275: NEG
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: LIST
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: LIST
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46299: LD_ADDR_VAR 0 14
46303: PUSH
46304: LD_INT 0
46306: PUSH
46307: LD_INT 0
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 0
46316: PUSH
46317: LD_INT 1
46319: NEG
46320: PUSH
46321: EMPTY
46322: LIST
46323: LIST
46324: PUSH
46325: LD_INT 1
46327: PUSH
46328: LD_INT 0
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 1
46337: PUSH
46338: LD_INT 1
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 0
46347: PUSH
46348: LD_INT 1
46350: PUSH
46351: EMPTY
46352: LIST
46353: LIST
46354: PUSH
46355: LD_INT 1
46357: NEG
46358: PUSH
46359: LD_INT 0
46361: PUSH
46362: EMPTY
46363: LIST
46364: LIST
46365: PUSH
46366: LD_INT 1
46368: NEG
46369: PUSH
46370: LD_INT 1
46372: NEG
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 1
46380: NEG
46381: PUSH
46382: LD_INT 2
46384: NEG
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 0
46392: PUSH
46393: LD_INT 2
46395: NEG
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 1
46403: PUSH
46404: LD_INT 1
46406: NEG
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 1
46414: PUSH
46415: LD_INT 2
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 0
46424: PUSH
46425: LD_INT 2
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: LD_INT 1
46434: NEG
46435: PUSH
46436: LD_INT 1
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: PUSH
46443: LD_INT 1
46445: NEG
46446: PUSH
46447: LD_INT 3
46449: NEG
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: PUSH
46455: LD_INT 0
46457: PUSH
46458: LD_INT 3
46460: NEG
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: LD_INT 1
46468: PUSH
46469: LD_INT 2
46471: NEG
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: LIST
46488: LIST
46489: LIST
46490: LIST
46491: LIST
46492: LIST
46493: LIST
46494: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46495: LD_ADDR_VAR 0 15
46499: PUSH
46500: LD_INT 0
46502: PUSH
46503: LD_INT 0
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PUSH
46510: LD_INT 0
46512: PUSH
46513: LD_INT 1
46515: NEG
46516: PUSH
46517: EMPTY
46518: LIST
46519: LIST
46520: PUSH
46521: LD_INT 1
46523: PUSH
46524: LD_INT 0
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: PUSH
46531: LD_INT 1
46533: PUSH
46534: LD_INT 1
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 0
46543: PUSH
46544: LD_INT 1
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: PUSH
46551: LD_INT 1
46553: NEG
46554: PUSH
46555: LD_INT 0
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PUSH
46562: LD_INT 1
46564: NEG
46565: PUSH
46566: LD_INT 1
46568: NEG
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PUSH
46574: LD_INT 1
46576: PUSH
46577: LD_INT 1
46579: NEG
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: LD_INT 2
46587: PUSH
46588: LD_INT 0
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 2
46597: PUSH
46598: LD_INT 1
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 1
46607: NEG
46608: PUSH
46609: LD_INT 1
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: LD_INT 2
46618: NEG
46619: PUSH
46620: LD_INT 0
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: LD_INT 2
46629: NEG
46630: PUSH
46631: LD_INT 1
46633: NEG
46634: PUSH
46635: EMPTY
46636: LIST
46637: LIST
46638: PUSH
46639: LD_INT 2
46641: PUSH
46642: LD_INT 1
46644: NEG
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PUSH
46650: LD_INT 3
46652: PUSH
46653: LD_INT 0
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: PUSH
46660: LD_INT 3
46662: PUSH
46663: LD_INT 1
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: PUSH
46670: EMPTY
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46688: LD_ADDR_VAR 0 16
46692: PUSH
46693: LD_INT 0
46695: PUSH
46696: LD_INT 0
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: PUSH
46703: LD_INT 0
46705: PUSH
46706: LD_INT 1
46708: NEG
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PUSH
46714: LD_INT 1
46716: PUSH
46717: LD_INT 0
46719: PUSH
46720: EMPTY
46721: LIST
46722: LIST
46723: PUSH
46724: LD_INT 1
46726: PUSH
46727: LD_INT 1
46729: PUSH
46730: EMPTY
46731: LIST
46732: LIST
46733: PUSH
46734: LD_INT 0
46736: PUSH
46737: LD_INT 1
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: PUSH
46744: LD_INT 1
46746: NEG
46747: PUSH
46748: LD_INT 0
46750: PUSH
46751: EMPTY
46752: LIST
46753: LIST
46754: PUSH
46755: LD_INT 1
46757: NEG
46758: PUSH
46759: LD_INT 1
46761: NEG
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: PUSH
46767: LD_INT 1
46769: NEG
46770: PUSH
46771: LD_INT 2
46773: NEG
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: PUSH
46779: LD_INT 2
46781: PUSH
46782: LD_INT 1
46784: PUSH
46785: EMPTY
46786: LIST
46787: LIST
46788: PUSH
46789: LD_INT 2
46791: PUSH
46792: LD_INT 2
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 1
46801: PUSH
46802: LD_INT 2
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: PUSH
46809: LD_INT 2
46811: NEG
46812: PUSH
46813: LD_INT 1
46815: NEG
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: LD_INT 2
46823: NEG
46824: PUSH
46825: LD_INT 2
46827: NEG
46828: PUSH
46829: EMPTY
46830: LIST
46831: LIST
46832: PUSH
46833: LD_INT 3
46835: PUSH
46836: LD_INT 2
46838: PUSH
46839: EMPTY
46840: LIST
46841: LIST
46842: PUSH
46843: LD_INT 3
46845: PUSH
46846: LD_INT 3
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 2
46855: PUSH
46856: LD_INT 3
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: LIST
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
46881: LD_ADDR_VAR 0 17
46885: PUSH
46886: LD_INT 0
46888: PUSH
46889: LD_INT 0
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: PUSH
46896: LD_INT 0
46898: PUSH
46899: LD_INT 1
46901: NEG
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PUSH
46907: LD_INT 1
46909: PUSH
46910: LD_INT 0
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: PUSH
46917: LD_INT 1
46919: PUSH
46920: LD_INT 1
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: PUSH
46927: LD_INT 0
46929: PUSH
46930: LD_INT 1
46932: PUSH
46933: EMPTY
46934: LIST
46935: LIST
46936: PUSH
46937: LD_INT 1
46939: NEG
46940: PUSH
46941: LD_INT 0
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: PUSH
46948: LD_INT 1
46950: NEG
46951: PUSH
46952: LD_INT 1
46954: NEG
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: LD_INT 1
46962: NEG
46963: PUSH
46964: LD_INT 2
46966: NEG
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: PUSH
46972: LD_INT 0
46974: PUSH
46975: LD_INT 2
46977: NEG
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PUSH
46983: LD_INT 1
46985: PUSH
46986: LD_INT 1
46988: NEG
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 2
46996: PUSH
46997: LD_INT 0
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: LD_INT 2
47006: PUSH
47007: LD_INT 1
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: PUSH
47014: LD_INT 2
47016: PUSH
47017: LD_INT 2
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 1
47026: PUSH
47027: LD_INT 2
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: LD_INT 2
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 1
47046: NEG
47047: PUSH
47048: LD_INT 1
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 2
47057: NEG
47058: PUSH
47059: LD_INT 0
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 2
47068: NEG
47069: PUSH
47070: LD_INT 1
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 2
47080: NEG
47081: PUSH
47082: LD_INT 2
47084: NEG
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47111: LD_ADDR_VAR 0 18
47115: PUSH
47116: LD_INT 0
47118: PUSH
47119: LD_INT 0
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PUSH
47126: LD_INT 0
47128: PUSH
47129: LD_INT 1
47131: NEG
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 1
47139: PUSH
47140: LD_INT 0
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 1
47149: PUSH
47150: LD_INT 1
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 0
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 1
47169: NEG
47170: PUSH
47171: LD_INT 0
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 1
47180: NEG
47181: PUSH
47182: LD_INT 1
47184: NEG
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: LD_INT 1
47192: NEG
47193: PUSH
47194: LD_INT 2
47196: NEG
47197: PUSH
47198: EMPTY
47199: LIST
47200: LIST
47201: PUSH
47202: LD_INT 0
47204: PUSH
47205: LD_INT 2
47207: NEG
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PUSH
47213: LD_INT 1
47215: PUSH
47216: LD_INT 1
47218: NEG
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 2
47226: PUSH
47227: LD_INT 0
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 2
47236: PUSH
47237: LD_INT 1
47239: PUSH
47240: EMPTY
47241: LIST
47242: LIST
47243: PUSH
47244: LD_INT 2
47246: PUSH
47247: LD_INT 2
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: PUSH
47254: LD_INT 1
47256: PUSH
47257: LD_INT 2
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: LD_INT 0
47266: PUSH
47267: LD_INT 2
47269: PUSH
47270: EMPTY
47271: LIST
47272: LIST
47273: PUSH
47274: LD_INT 1
47276: NEG
47277: PUSH
47278: LD_INT 1
47280: PUSH
47281: EMPTY
47282: LIST
47283: LIST
47284: PUSH
47285: LD_INT 2
47287: NEG
47288: PUSH
47289: LD_INT 0
47291: PUSH
47292: EMPTY
47293: LIST
47294: LIST
47295: PUSH
47296: LD_INT 2
47298: NEG
47299: PUSH
47300: LD_INT 1
47302: NEG
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: PUSH
47308: LD_INT 2
47310: NEG
47311: PUSH
47312: LD_INT 2
47314: NEG
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: PUSH
47320: EMPTY
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47341: LD_ADDR_VAR 0 19
47345: PUSH
47346: LD_INT 0
47348: PUSH
47349: LD_INT 0
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 0
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 1
47369: PUSH
47370: LD_INT 0
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: LD_INT 1
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: PUSH
47387: LD_INT 0
47389: PUSH
47390: LD_INT 1
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 1
47399: NEG
47400: PUSH
47401: LD_INT 0
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: LD_INT 1
47410: NEG
47411: PUSH
47412: LD_INT 1
47414: NEG
47415: PUSH
47416: EMPTY
47417: LIST
47418: LIST
47419: PUSH
47420: LD_INT 1
47422: NEG
47423: PUSH
47424: LD_INT 2
47426: NEG
47427: PUSH
47428: EMPTY
47429: LIST
47430: LIST
47431: PUSH
47432: LD_INT 0
47434: PUSH
47435: LD_INT 2
47437: NEG
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: PUSH
47443: LD_INT 1
47445: PUSH
47446: LD_INT 1
47448: NEG
47449: PUSH
47450: EMPTY
47451: LIST
47452: LIST
47453: PUSH
47454: LD_INT 2
47456: PUSH
47457: LD_INT 0
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PUSH
47464: LD_INT 2
47466: PUSH
47467: LD_INT 1
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: LD_INT 2
47476: PUSH
47477: LD_INT 2
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: PUSH
47484: LD_INT 1
47486: PUSH
47487: LD_INT 2
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: PUSH
47494: LD_INT 0
47496: PUSH
47497: LD_INT 2
47499: PUSH
47500: EMPTY
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 1
47506: NEG
47507: PUSH
47508: LD_INT 1
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: LD_INT 2
47517: NEG
47518: PUSH
47519: LD_INT 0
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: PUSH
47526: LD_INT 2
47528: NEG
47529: PUSH
47530: LD_INT 1
47532: NEG
47533: PUSH
47534: EMPTY
47535: LIST
47536: LIST
47537: PUSH
47538: LD_INT 2
47540: NEG
47541: PUSH
47542: LD_INT 2
47544: NEG
47545: PUSH
47546: EMPTY
47547: LIST
47548: LIST
47549: PUSH
47550: EMPTY
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47571: LD_ADDR_VAR 0 20
47575: PUSH
47576: LD_INT 0
47578: PUSH
47579: LD_INT 0
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: PUSH
47586: LD_INT 0
47588: PUSH
47589: LD_INT 1
47591: NEG
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: PUSH
47597: LD_INT 1
47599: PUSH
47600: LD_INT 0
47602: PUSH
47603: EMPTY
47604: LIST
47605: LIST
47606: PUSH
47607: LD_INT 1
47609: PUSH
47610: LD_INT 1
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: LD_INT 0
47619: PUSH
47620: LD_INT 1
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PUSH
47627: LD_INT 1
47629: NEG
47630: PUSH
47631: LD_INT 0
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: PUSH
47638: LD_INT 1
47640: NEG
47641: PUSH
47642: LD_INT 1
47644: NEG
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: PUSH
47650: LD_INT 1
47652: NEG
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PUSH
47662: LD_INT 0
47664: PUSH
47665: LD_INT 2
47667: NEG
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 1
47675: PUSH
47676: LD_INT 1
47678: NEG
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 2
47686: PUSH
47687: LD_INT 0
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: LD_INT 2
47696: PUSH
47697: LD_INT 1
47699: PUSH
47700: EMPTY
47701: LIST
47702: LIST
47703: PUSH
47704: LD_INT 2
47706: PUSH
47707: LD_INT 2
47709: PUSH
47710: EMPTY
47711: LIST
47712: LIST
47713: PUSH
47714: LD_INT 1
47716: PUSH
47717: LD_INT 2
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: PUSH
47724: LD_INT 0
47726: PUSH
47727: LD_INT 2
47729: PUSH
47730: EMPTY
47731: LIST
47732: LIST
47733: PUSH
47734: LD_INT 1
47736: NEG
47737: PUSH
47738: LD_INT 1
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: PUSH
47745: LD_INT 2
47747: NEG
47748: PUSH
47749: LD_INT 0
47751: PUSH
47752: EMPTY
47753: LIST
47754: LIST
47755: PUSH
47756: LD_INT 2
47758: NEG
47759: PUSH
47760: LD_INT 1
47762: NEG
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: PUSH
47768: LD_INT 2
47770: NEG
47771: PUSH
47772: LD_INT 2
47774: NEG
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47801: LD_ADDR_VAR 0 21
47805: PUSH
47806: LD_INT 0
47808: PUSH
47809: LD_INT 0
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 0
47818: PUSH
47819: LD_INT 1
47821: NEG
47822: PUSH
47823: EMPTY
47824: LIST
47825: LIST
47826: PUSH
47827: LD_INT 1
47829: PUSH
47830: LD_INT 0
47832: PUSH
47833: EMPTY
47834: LIST
47835: LIST
47836: PUSH
47837: LD_INT 1
47839: PUSH
47840: LD_INT 1
47842: PUSH
47843: EMPTY
47844: LIST
47845: LIST
47846: PUSH
47847: LD_INT 0
47849: PUSH
47850: LD_INT 1
47852: PUSH
47853: EMPTY
47854: LIST
47855: LIST
47856: PUSH
47857: LD_INT 1
47859: NEG
47860: PUSH
47861: LD_INT 0
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PUSH
47868: LD_INT 1
47870: NEG
47871: PUSH
47872: LD_INT 1
47874: NEG
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PUSH
47880: LD_INT 1
47882: NEG
47883: PUSH
47884: LD_INT 2
47886: NEG
47887: PUSH
47888: EMPTY
47889: LIST
47890: LIST
47891: PUSH
47892: LD_INT 0
47894: PUSH
47895: LD_INT 2
47897: NEG
47898: PUSH
47899: EMPTY
47900: LIST
47901: LIST
47902: PUSH
47903: LD_INT 1
47905: PUSH
47906: LD_INT 1
47908: NEG
47909: PUSH
47910: EMPTY
47911: LIST
47912: LIST
47913: PUSH
47914: LD_INT 2
47916: PUSH
47917: LD_INT 0
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 2
47926: PUSH
47927: LD_INT 1
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: PUSH
47934: LD_INT 2
47936: PUSH
47937: LD_INT 2
47939: PUSH
47940: EMPTY
47941: LIST
47942: LIST
47943: PUSH
47944: LD_INT 1
47946: PUSH
47947: LD_INT 2
47949: PUSH
47950: EMPTY
47951: LIST
47952: LIST
47953: PUSH
47954: LD_INT 0
47956: PUSH
47957: LD_INT 2
47959: PUSH
47960: EMPTY
47961: LIST
47962: LIST
47963: PUSH
47964: LD_INT 1
47966: NEG
47967: PUSH
47968: LD_INT 1
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: PUSH
47975: LD_INT 2
47977: NEG
47978: PUSH
47979: LD_INT 0
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: LD_INT 2
47988: NEG
47989: PUSH
47990: LD_INT 1
47992: NEG
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: LD_INT 2
48000: NEG
48001: PUSH
48002: LD_INT 2
48004: NEG
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: EMPTY
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48031: LD_ADDR_VAR 0 22
48035: PUSH
48036: LD_INT 0
48038: PUSH
48039: LD_INT 0
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_INT 0
48048: PUSH
48049: LD_INT 1
48051: NEG
48052: PUSH
48053: EMPTY
48054: LIST
48055: LIST
48056: PUSH
48057: LD_INT 1
48059: PUSH
48060: LD_INT 0
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: PUSH
48067: LD_INT 1
48069: PUSH
48070: LD_INT 1
48072: PUSH
48073: EMPTY
48074: LIST
48075: LIST
48076: PUSH
48077: LD_INT 0
48079: PUSH
48080: LD_INT 1
48082: PUSH
48083: EMPTY
48084: LIST
48085: LIST
48086: PUSH
48087: LD_INT 1
48089: NEG
48090: PUSH
48091: LD_INT 0
48093: PUSH
48094: EMPTY
48095: LIST
48096: LIST
48097: PUSH
48098: LD_INT 1
48100: NEG
48101: PUSH
48102: LD_INT 1
48104: NEG
48105: PUSH
48106: EMPTY
48107: LIST
48108: LIST
48109: PUSH
48110: LD_INT 1
48112: NEG
48113: PUSH
48114: LD_INT 2
48116: NEG
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: PUSH
48122: LD_INT 0
48124: PUSH
48125: LD_INT 2
48127: NEG
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: LD_INT 1
48135: PUSH
48136: LD_INT 1
48138: NEG
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: PUSH
48144: LD_INT 2
48146: PUSH
48147: LD_INT 0
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_INT 2
48156: PUSH
48157: LD_INT 1
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: PUSH
48164: LD_INT 2
48166: PUSH
48167: LD_INT 2
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PUSH
48174: LD_INT 1
48176: PUSH
48177: LD_INT 2
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: PUSH
48184: LD_INT 0
48186: PUSH
48187: LD_INT 2
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 1
48196: NEG
48197: PUSH
48198: LD_INT 1
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: PUSH
48205: LD_INT 2
48207: NEG
48208: PUSH
48209: LD_INT 0
48211: PUSH
48212: EMPTY
48213: LIST
48214: LIST
48215: PUSH
48216: LD_INT 2
48218: NEG
48219: PUSH
48220: LD_INT 1
48222: NEG
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 2
48230: NEG
48231: PUSH
48232: LD_INT 2
48234: NEG
48235: PUSH
48236: EMPTY
48237: LIST
48238: LIST
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
48261: LD_ADDR_VAR 0 23
48265: PUSH
48266: LD_INT 0
48268: PUSH
48269: LD_INT 0
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 0
48278: PUSH
48279: LD_INT 1
48281: NEG
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: LD_INT 0
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: LD_INT 1
48299: PUSH
48300: LD_INT 1
48302: PUSH
48303: EMPTY
48304: LIST
48305: LIST
48306: PUSH
48307: LD_INT 0
48309: PUSH
48310: LD_INT 1
48312: PUSH
48313: EMPTY
48314: LIST
48315: LIST
48316: PUSH
48317: LD_INT 1
48319: NEG
48320: PUSH
48321: LD_INT 0
48323: PUSH
48324: EMPTY
48325: LIST
48326: LIST
48327: PUSH
48328: LD_INT 1
48330: NEG
48331: PUSH
48332: LD_INT 1
48334: NEG
48335: PUSH
48336: EMPTY
48337: LIST
48338: LIST
48339: PUSH
48340: LD_INT 1
48342: NEG
48343: PUSH
48344: LD_INT 2
48346: NEG
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: PUSH
48352: LD_INT 0
48354: PUSH
48355: LD_INT 2
48357: NEG
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 1
48365: PUSH
48366: LD_INT 1
48368: NEG
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: PUSH
48374: LD_INT 2
48376: PUSH
48377: LD_INT 0
48379: PUSH
48380: EMPTY
48381: LIST
48382: LIST
48383: PUSH
48384: LD_INT 2
48386: PUSH
48387: LD_INT 1
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: PUSH
48394: LD_INT 2
48396: PUSH
48397: LD_INT 2
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: LD_INT 1
48406: PUSH
48407: LD_INT 2
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: PUSH
48414: LD_INT 0
48416: PUSH
48417: LD_INT 2
48419: PUSH
48420: EMPTY
48421: LIST
48422: LIST
48423: PUSH
48424: LD_INT 1
48426: NEG
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 2
48437: NEG
48438: PUSH
48439: LD_INT 0
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 2
48448: NEG
48449: PUSH
48450: LD_INT 1
48452: NEG
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PUSH
48458: LD_INT 2
48460: NEG
48461: PUSH
48462: LD_INT 2
48464: NEG
48465: PUSH
48466: EMPTY
48467: LIST
48468: LIST
48469: PUSH
48470: LD_INT 2
48472: NEG
48473: PUSH
48474: LD_INT 3
48476: NEG
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: PUSH
48482: LD_INT 1
48484: NEG
48485: PUSH
48486: LD_INT 3
48488: NEG
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: PUSH
48494: LD_INT 1
48496: PUSH
48497: LD_INT 2
48499: NEG
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: PUSH
48505: LD_INT 2
48507: PUSH
48508: LD_INT 1
48510: NEG
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: LIST
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: LIST
48530: LIST
48531: LIST
48532: LIST
48533: LIST
48534: LIST
48535: LIST
48536: LIST
48537: LIST
48538: LIST
48539: LIST
48540: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
48541: LD_ADDR_VAR 0 24
48545: PUSH
48546: LD_INT 0
48548: PUSH
48549: LD_INT 0
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: PUSH
48556: LD_INT 0
48558: PUSH
48559: LD_INT 1
48561: NEG
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: PUSH
48567: LD_INT 1
48569: PUSH
48570: LD_INT 0
48572: PUSH
48573: EMPTY
48574: LIST
48575: LIST
48576: PUSH
48577: LD_INT 1
48579: PUSH
48580: LD_INT 1
48582: PUSH
48583: EMPTY
48584: LIST
48585: LIST
48586: PUSH
48587: LD_INT 0
48589: PUSH
48590: LD_INT 1
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 1
48599: NEG
48600: PUSH
48601: LD_INT 0
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 1
48610: NEG
48611: PUSH
48612: LD_INT 1
48614: NEG
48615: PUSH
48616: EMPTY
48617: LIST
48618: LIST
48619: PUSH
48620: LD_INT 1
48622: NEG
48623: PUSH
48624: LD_INT 2
48626: NEG
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 0
48634: PUSH
48635: LD_INT 2
48637: NEG
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: LD_INT 1
48645: PUSH
48646: LD_INT 1
48648: NEG
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PUSH
48654: LD_INT 2
48656: PUSH
48657: LD_INT 0
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PUSH
48664: LD_INT 2
48666: PUSH
48667: LD_INT 1
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: PUSH
48674: LD_INT 2
48676: PUSH
48677: LD_INT 2
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: LD_INT 1
48686: PUSH
48687: LD_INT 2
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: PUSH
48694: LD_INT 0
48696: PUSH
48697: LD_INT 2
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 1
48706: NEG
48707: PUSH
48708: LD_INT 1
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 2
48717: NEG
48718: PUSH
48719: LD_INT 0
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: PUSH
48726: LD_INT 2
48728: NEG
48729: PUSH
48730: LD_INT 1
48732: NEG
48733: PUSH
48734: EMPTY
48735: LIST
48736: LIST
48737: PUSH
48738: LD_INT 2
48740: NEG
48741: PUSH
48742: LD_INT 2
48744: NEG
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PUSH
48750: LD_INT 1
48752: PUSH
48753: LD_INT 2
48755: NEG
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: PUSH
48761: LD_INT 2
48763: PUSH
48764: LD_INT 1
48766: NEG
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 3
48774: PUSH
48775: LD_INT 1
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: PUSH
48782: LD_INT 3
48784: PUSH
48785: LD_INT 2
48787: PUSH
48788: EMPTY
48789: LIST
48790: LIST
48791: PUSH
48792: EMPTY
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
48817: LD_ADDR_VAR 0 25
48821: PUSH
48822: LD_INT 0
48824: PUSH
48825: LD_INT 0
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PUSH
48832: LD_INT 0
48834: PUSH
48835: LD_INT 1
48837: NEG
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_INT 1
48845: PUSH
48846: LD_INT 0
48848: PUSH
48849: EMPTY
48850: LIST
48851: LIST
48852: PUSH
48853: LD_INT 1
48855: PUSH
48856: LD_INT 1
48858: PUSH
48859: EMPTY
48860: LIST
48861: LIST
48862: PUSH
48863: LD_INT 0
48865: PUSH
48866: LD_INT 1
48868: PUSH
48869: EMPTY
48870: LIST
48871: LIST
48872: PUSH
48873: LD_INT 1
48875: NEG
48876: PUSH
48877: LD_INT 0
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PUSH
48884: LD_INT 1
48886: NEG
48887: PUSH
48888: LD_INT 1
48890: NEG
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: PUSH
48896: LD_INT 1
48898: NEG
48899: PUSH
48900: LD_INT 2
48902: NEG
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: LD_INT 0
48910: PUSH
48911: LD_INT 2
48913: NEG
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: PUSH
48919: LD_INT 1
48921: PUSH
48922: LD_INT 1
48924: NEG
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: PUSH
48930: LD_INT 2
48932: PUSH
48933: LD_INT 0
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 2
48942: PUSH
48943: LD_INT 1
48945: PUSH
48946: EMPTY
48947: LIST
48948: LIST
48949: PUSH
48950: LD_INT 2
48952: PUSH
48953: LD_INT 2
48955: PUSH
48956: EMPTY
48957: LIST
48958: LIST
48959: PUSH
48960: LD_INT 1
48962: PUSH
48963: LD_INT 2
48965: PUSH
48966: EMPTY
48967: LIST
48968: LIST
48969: PUSH
48970: LD_INT 0
48972: PUSH
48973: LD_INT 2
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PUSH
48980: LD_INT 1
48982: NEG
48983: PUSH
48984: LD_INT 1
48986: PUSH
48987: EMPTY
48988: LIST
48989: LIST
48990: PUSH
48991: LD_INT 2
48993: NEG
48994: PUSH
48995: LD_INT 0
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PUSH
49002: LD_INT 2
49004: NEG
49005: PUSH
49006: LD_INT 1
49008: NEG
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 2
49016: NEG
49017: PUSH
49018: LD_INT 2
49020: NEG
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PUSH
49026: LD_INT 3
49028: PUSH
49029: LD_INT 1
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 3
49038: PUSH
49039: LD_INT 2
49041: PUSH
49042: EMPTY
49043: LIST
49044: LIST
49045: PUSH
49046: LD_INT 2
49048: PUSH
49049: LD_INT 3
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 1
49058: PUSH
49059: LD_INT 3
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
49091: LD_ADDR_VAR 0 26
49095: PUSH
49096: LD_INT 0
49098: PUSH
49099: LD_INT 0
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: PUSH
49106: LD_INT 0
49108: PUSH
49109: LD_INT 1
49111: NEG
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 1
49119: PUSH
49120: LD_INT 0
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 1
49129: PUSH
49130: LD_INT 1
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: LD_INT 0
49139: PUSH
49140: LD_INT 1
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PUSH
49147: LD_INT 1
49149: NEG
49150: PUSH
49151: LD_INT 0
49153: PUSH
49154: EMPTY
49155: LIST
49156: LIST
49157: PUSH
49158: LD_INT 1
49160: NEG
49161: PUSH
49162: LD_INT 1
49164: NEG
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PUSH
49170: LD_INT 1
49172: NEG
49173: PUSH
49174: LD_INT 2
49176: NEG
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: PUSH
49182: LD_INT 0
49184: PUSH
49185: LD_INT 2
49187: NEG
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PUSH
49193: LD_INT 1
49195: PUSH
49196: LD_INT 1
49198: NEG
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: PUSH
49204: LD_INT 2
49206: PUSH
49207: LD_INT 0
49209: PUSH
49210: EMPTY
49211: LIST
49212: LIST
49213: PUSH
49214: LD_INT 2
49216: PUSH
49217: LD_INT 1
49219: PUSH
49220: EMPTY
49221: LIST
49222: LIST
49223: PUSH
49224: LD_INT 2
49226: PUSH
49227: LD_INT 2
49229: PUSH
49230: EMPTY
49231: LIST
49232: LIST
49233: PUSH
49234: LD_INT 1
49236: PUSH
49237: LD_INT 2
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PUSH
49244: LD_INT 0
49246: PUSH
49247: LD_INT 2
49249: PUSH
49250: EMPTY
49251: LIST
49252: LIST
49253: PUSH
49254: LD_INT 1
49256: NEG
49257: PUSH
49258: LD_INT 1
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: LD_INT 2
49267: NEG
49268: PUSH
49269: LD_INT 0
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 2
49278: NEG
49279: PUSH
49280: LD_INT 1
49282: NEG
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: PUSH
49288: LD_INT 2
49290: NEG
49291: PUSH
49292: LD_INT 2
49294: NEG
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 2
49302: PUSH
49303: LD_INT 3
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: PUSH
49310: LD_INT 1
49312: PUSH
49313: LD_INT 3
49315: PUSH
49316: EMPTY
49317: LIST
49318: LIST
49319: PUSH
49320: LD_INT 1
49322: NEG
49323: PUSH
49324: LD_INT 2
49326: PUSH
49327: EMPTY
49328: LIST
49329: LIST
49330: PUSH
49331: LD_INT 2
49333: NEG
49334: PUSH
49335: LD_INT 1
49337: PUSH
49338: EMPTY
49339: LIST
49340: LIST
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
49367: LD_ADDR_VAR 0 27
49371: PUSH
49372: LD_INT 0
49374: PUSH
49375: LD_INT 0
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 0
49384: PUSH
49385: LD_INT 1
49387: NEG
49388: PUSH
49389: EMPTY
49390: LIST
49391: LIST
49392: PUSH
49393: LD_INT 1
49395: PUSH
49396: LD_INT 0
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 1
49405: PUSH
49406: LD_INT 1
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PUSH
49413: LD_INT 0
49415: PUSH
49416: LD_INT 1
49418: PUSH
49419: EMPTY
49420: LIST
49421: LIST
49422: PUSH
49423: LD_INT 1
49425: NEG
49426: PUSH
49427: LD_INT 0
49429: PUSH
49430: EMPTY
49431: LIST
49432: LIST
49433: PUSH
49434: LD_INT 1
49436: NEG
49437: PUSH
49438: LD_INT 1
49440: NEG
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: PUSH
49446: LD_INT 1
49448: NEG
49449: PUSH
49450: LD_INT 2
49452: NEG
49453: PUSH
49454: EMPTY
49455: LIST
49456: LIST
49457: PUSH
49458: LD_INT 0
49460: PUSH
49461: LD_INT 2
49463: NEG
49464: PUSH
49465: EMPTY
49466: LIST
49467: LIST
49468: PUSH
49469: LD_INT 1
49471: PUSH
49472: LD_INT 1
49474: NEG
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: PUSH
49480: LD_INT 2
49482: PUSH
49483: LD_INT 0
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: PUSH
49490: LD_INT 2
49492: PUSH
49493: LD_INT 1
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 2
49502: PUSH
49503: LD_INT 2
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 1
49512: PUSH
49513: LD_INT 2
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 0
49522: PUSH
49523: LD_INT 2
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 1
49532: NEG
49533: PUSH
49534: LD_INT 1
49536: PUSH
49537: EMPTY
49538: LIST
49539: LIST
49540: PUSH
49541: LD_INT 2
49543: NEG
49544: PUSH
49545: LD_INT 0
49547: PUSH
49548: EMPTY
49549: LIST
49550: LIST
49551: PUSH
49552: LD_INT 2
49554: NEG
49555: PUSH
49556: LD_INT 1
49558: NEG
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: PUSH
49564: LD_INT 2
49566: NEG
49567: PUSH
49568: LD_INT 2
49570: NEG
49571: PUSH
49572: EMPTY
49573: LIST
49574: LIST
49575: PUSH
49576: LD_INT 1
49578: NEG
49579: PUSH
49580: LD_INT 2
49582: PUSH
49583: EMPTY
49584: LIST
49585: LIST
49586: PUSH
49587: LD_INT 2
49589: NEG
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 3
49600: NEG
49601: PUSH
49602: LD_INT 1
49604: NEG
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: PUSH
49610: LD_INT 3
49612: NEG
49613: PUSH
49614: LD_INT 2
49616: NEG
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: PUSH
49622: EMPTY
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
49647: LD_ADDR_VAR 0 28
49651: PUSH
49652: LD_INT 0
49654: PUSH
49655: LD_INT 0
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 0
49664: PUSH
49665: LD_INT 1
49667: NEG
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: LD_INT 1
49675: PUSH
49676: LD_INT 0
49678: PUSH
49679: EMPTY
49680: LIST
49681: LIST
49682: PUSH
49683: LD_INT 1
49685: PUSH
49686: LD_INT 1
49688: PUSH
49689: EMPTY
49690: LIST
49691: LIST
49692: PUSH
49693: LD_INT 0
49695: PUSH
49696: LD_INT 1
49698: PUSH
49699: EMPTY
49700: LIST
49701: LIST
49702: PUSH
49703: LD_INT 1
49705: NEG
49706: PUSH
49707: LD_INT 0
49709: PUSH
49710: EMPTY
49711: LIST
49712: LIST
49713: PUSH
49714: LD_INT 1
49716: NEG
49717: PUSH
49718: LD_INT 1
49720: NEG
49721: PUSH
49722: EMPTY
49723: LIST
49724: LIST
49725: PUSH
49726: LD_INT 1
49728: NEG
49729: PUSH
49730: LD_INT 2
49732: NEG
49733: PUSH
49734: EMPTY
49735: LIST
49736: LIST
49737: PUSH
49738: LD_INT 0
49740: PUSH
49741: LD_INT 2
49743: NEG
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: LD_INT 1
49751: PUSH
49752: LD_INT 1
49754: NEG
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PUSH
49760: LD_INT 2
49762: PUSH
49763: LD_INT 0
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: PUSH
49770: LD_INT 2
49772: PUSH
49773: LD_INT 1
49775: PUSH
49776: EMPTY
49777: LIST
49778: LIST
49779: PUSH
49780: LD_INT 2
49782: PUSH
49783: LD_INT 2
49785: PUSH
49786: EMPTY
49787: LIST
49788: LIST
49789: PUSH
49790: LD_INT 1
49792: PUSH
49793: LD_INT 2
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PUSH
49800: LD_INT 0
49802: PUSH
49803: LD_INT 2
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 1
49812: NEG
49813: PUSH
49814: LD_INT 1
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: PUSH
49821: LD_INT 2
49823: NEG
49824: PUSH
49825: LD_INT 0
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PUSH
49832: LD_INT 2
49834: NEG
49835: PUSH
49836: LD_INT 1
49838: NEG
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PUSH
49844: LD_INT 2
49846: NEG
49847: PUSH
49848: LD_INT 2
49850: NEG
49851: PUSH
49852: EMPTY
49853: LIST
49854: LIST
49855: PUSH
49856: LD_INT 2
49858: NEG
49859: PUSH
49860: LD_INT 3
49862: NEG
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PUSH
49868: LD_INT 1
49870: NEG
49871: PUSH
49872: LD_INT 3
49874: NEG
49875: PUSH
49876: EMPTY
49877: LIST
49878: LIST
49879: PUSH
49880: LD_INT 3
49882: NEG
49883: PUSH
49884: LD_INT 1
49886: NEG
49887: PUSH
49888: EMPTY
49889: LIST
49890: LIST
49891: PUSH
49892: LD_INT 3
49894: NEG
49895: PUSH
49896: LD_INT 2
49898: NEG
49899: PUSH
49900: EMPTY
49901: LIST
49902: LIST
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: LIST
49925: LIST
49926: LIST
49927: LIST
49928: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
49929: LD_ADDR_VAR 0 29
49933: PUSH
49934: LD_INT 0
49936: PUSH
49937: LD_INT 0
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: PUSH
49944: LD_INT 0
49946: PUSH
49947: LD_INT 1
49949: NEG
49950: PUSH
49951: EMPTY
49952: LIST
49953: LIST
49954: PUSH
49955: LD_INT 1
49957: PUSH
49958: LD_INT 0
49960: PUSH
49961: EMPTY
49962: LIST
49963: LIST
49964: PUSH
49965: LD_INT 1
49967: PUSH
49968: LD_INT 1
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: PUSH
49975: LD_INT 0
49977: PUSH
49978: LD_INT 1
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: LD_INT 1
49987: NEG
49988: PUSH
49989: LD_INT 0
49991: PUSH
49992: EMPTY
49993: LIST
49994: LIST
49995: PUSH
49996: LD_INT 1
49998: NEG
49999: PUSH
50000: LD_INT 1
50002: NEG
50003: PUSH
50004: EMPTY
50005: LIST
50006: LIST
50007: PUSH
50008: LD_INT 1
50010: NEG
50011: PUSH
50012: LD_INT 2
50014: NEG
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: LD_INT 0
50022: PUSH
50023: LD_INT 2
50025: NEG
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: LD_INT 1
50033: PUSH
50034: LD_INT 1
50036: NEG
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: PUSH
50042: LD_INT 2
50044: PUSH
50045: LD_INT 0
50047: PUSH
50048: EMPTY
50049: LIST
50050: LIST
50051: PUSH
50052: LD_INT 2
50054: PUSH
50055: LD_INT 1
50057: PUSH
50058: EMPTY
50059: LIST
50060: LIST
50061: PUSH
50062: LD_INT 1
50064: PUSH
50065: LD_INT 2
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: PUSH
50072: LD_INT 0
50074: PUSH
50075: LD_INT 2
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 1
50084: NEG
50085: PUSH
50086: LD_INT 1
50088: PUSH
50089: EMPTY
50090: LIST
50091: LIST
50092: PUSH
50093: LD_INT 2
50095: NEG
50096: PUSH
50097: LD_INT 1
50099: NEG
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 2
50107: NEG
50108: PUSH
50109: LD_INT 2
50111: NEG
50112: PUSH
50113: EMPTY
50114: LIST
50115: LIST
50116: PUSH
50117: LD_INT 2
50119: NEG
50120: PUSH
50121: LD_INT 3
50123: NEG
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PUSH
50129: LD_INT 2
50131: PUSH
50132: LD_INT 1
50134: NEG
50135: PUSH
50136: EMPTY
50137: LIST
50138: LIST
50139: PUSH
50140: LD_INT 3
50142: PUSH
50143: LD_INT 1
50145: PUSH
50146: EMPTY
50147: LIST
50148: LIST
50149: PUSH
50150: LD_INT 1
50152: PUSH
50153: LD_INT 3
50155: PUSH
50156: EMPTY
50157: LIST
50158: LIST
50159: PUSH
50160: LD_INT 1
50162: NEG
50163: PUSH
50164: LD_INT 2
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: LD_INT 3
50173: NEG
50174: PUSH
50175: LD_INT 2
50177: NEG
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: LIST
50189: LIST
50190: LIST
50191: LIST
50192: LIST
50193: LIST
50194: LIST
50195: LIST
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: LIST
50202: LIST
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
50208: LD_ADDR_VAR 0 30
50212: PUSH
50213: LD_INT 0
50215: PUSH
50216: LD_INT 0
50218: PUSH
50219: EMPTY
50220: LIST
50221: LIST
50222: PUSH
50223: LD_INT 0
50225: PUSH
50226: LD_INT 1
50228: NEG
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: PUSH
50234: LD_INT 1
50236: PUSH
50237: LD_INT 0
50239: PUSH
50240: EMPTY
50241: LIST
50242: LIST
50243: PUSH
50244: LD_INT 1
50246: PUSH
50247: LD_INT 1
50249: PUSH
50250: EMPTY
50251: LIST
50252: LIST
50253: PUSH
50254: LD_INT 0
50256: PUSH
50257: LD_INT 1
50259: PUSH
50260: EMPTY
50261: LIST
50262: LIST
50263: PUSH
50264: LD_INT 1
50266: NEG
50267: PUSH
50268: LD_INT 0
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PUSH
50275: LD_INT 1
50277: NEG
50278: PUSH
50279: LD_INT 1
50281: NEG
50282: PUSH
50283: EMPTY
50284: LIST
50285: LIST
50286: PUSH
50287: LD_INT 1
50289: NEG
50290: PUSH
50291: LD_INT 2
50293: NEG
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PUSH
50299: LD_INT 0
50301: PUSH
50302: LD_INT 2
50304: NEG
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PUSH
50310: LD_INT 1
50312: PUSH
50313: LD_INT 1
50315: NEG
50316: PUSH
50317: EMPTY
50318: LIST
50319: LIST
50320: PUSH
50321: LD_INT 2
50323: PUSH
50324: LD_INT 0
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 2
50333: PUSH
50334: LD_INT 1
50336: PUSH
50337: EMPTY
50338: LIST
50339: LIST
50340: PUSH
50341: LD_INT 2
50343: PUSH
50344: LD_INT 2
50346: PUSH
50347: EMPTY
50348: LIST
50349: LIST
50350: PUSH
50351: LD_INT 1
50353: PUSH
50354: LD_INT 2
50356: PUSH
50357: EMPTY
50358: LIST
50359: LIST
50360: PUSH
50361: LD_INT 1
50363: NEG
50364: PUSH
50365: LD_INT 1
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: LD_INT 2
50374: NEG
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 2
50385: NEG
50386: PUSH
50387: LD_INT 1
50389: NEG
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: PUSH
50395: LD_INT 1
50397: NEG
50398: PUSH
50399: LD_INT 3
50401: NEG
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: PUSH
50407: LD_INT 1
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: EMPTY
50415: LIST
50416: LIST
50417: PUSH
50418: LD_INT 3
50420: PUSH
50421: LD_INT 2
50423: PUSH
50424: EMPTY
50425: LIST
50426: LIST
50427: PUSH
50428: LD_INT 2
50430: PUSH
50431: LD_INT 3
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PUSH
50438: LD_INT 2
50440: NEG
50441: PUSH
50442: LD_INT 1
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: PUSH
50449: LD_INT 3
50451: NEG
50452: PUSH
50453: LD_INT 1
50455: NEG
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: LIST
50465: LIST
50466: LIST
50467: LIST
50468: LIST
50469: LIST
50470: LIST
50471: LIST
50472: LIST
50473: LIST
50474: LIST
50475: LIST
50476: LIST
50477: LIST
50478: LIST
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: LIST
50484: LIST
50485: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
50486: LD_ADDR_VAR 0 31
50490: PUSH
50491: LD_INT 0
50493: PUSH
50494: LD_INT 0
50496: PUSH
50497: EMPTY
50498: LIST
50499: LIST
50500: PUSH
50501: LD_INT 0
50503: PUSH
50504: LD_INT 1
50506: NEG
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: PUSH
50512: LD_INT 1
50514: PUSH
50515: LD_INT 0
50517: PUSH
50518: EMPTY
50519: LIST
50520: LIST
50521: PUSH
50522: LD_INT 1
50524: PUSH
50525: LD_INT 1
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: PUSH
50532: LD_INT 0
50534: PUSH
50535: LD_INT 1
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PUSH
50542: LD_INT 1
50544: NEG
50545: PUSH
50546: LD_INT 0
50548: PUSH
50549: EMPTY
50550: LIST
50551: LIST
50552: PUSH
50553: LD_INT 1
50555: NEG
50556: PUSH
50557: LD_INT 1
50559: NEG
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: LD_INT 1
50567: NEG
50568: PUSH
50569: LD_INT 2
50571: NEG
50572: PUSH
50573: EMPTY
50574: LIST
50575: LIST
50576: PUSH
50577: LD_INT 1
50579: PUSH
50580: LD_INT 1
50582: NEG
50583: PUSH
50584: EMPTY
50585: LIST
50586: LIST
50587: PUSH
50588: LD_INT 2
50590: PUSH
50591: LD_INT 0
50593: PUSH
50594: EMPTY
50595: LIST
50596: LIST
50597: PUSH
50598: LD_INT 2
50600: PUSH
50601: LD_INT 1
50603: PUSH
50604: EMPTY
50605: LIST
50606: LIST
50607: PUSH
50608: LD_INT 2
50610: PUSH
50611: LD_INT 2
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: LD_INT 1
50620: PUSH
50621: LD_INT 2
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PUSH
50628: LD_INT 0
50630: PUSH
50631: LD_INT 2
50633: PUSH
50634: EMPTY
50635: LIST
50636: LIST
50637: PUSH
50638: LD_INT 1
50640: NEG
50641: PUSH
50642: LD_INT 1
50644: PUSH
50645: EMPTY
50646: LIST
50647: LIST
50648: PUSH
50649: LD_INT 2
50651: NEG
50652: PUSH
50653: LD_INT 1
50655: NEG
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: PUSH
50661: LD_INT 2
50663: NEG
50664: PUSH
50665: LD_INT 2
50667: NEG
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: PUSH
50673: LD_INT 2
50675: NEG
50676: PUSH
50677: LD_INT 3
50679: NEG
50680: PUSH
50681: EMPTY
50682: LIST
50683: LIST
50684: PUSH
50685: LD_INT 2
50687: PUSH
50688: LD_INT 1
50690: NEG
50691: PUSH
50692: EMPTY
50693: LIST
50694: LIST
50695: PUSH
50696: LD_INT 3
50698: PUSH
50699: LD_INT 1
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PUSH
50706: LD_INT 1
50708: PUSH
50709: LD_INT 3
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: PUSH
50716: LD_INT 1
50718: NEG
50719: PUSH
50720: LD_INT 2
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PUSH
50727: LD_INT 3
50729: NEG
50730: PUSH
50731: LD_INT 2
50733: NEG
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: LIST
50745: LIST
50746: LIST
50747: LIST
50748: LIST
50749: LIST
50750: LIST
50751: LIST
50752: LIST
50753: LIST
50754: LIST
50755: LIST
50756: LIST
50757: LIST
50758: LIST
50759: LIST
50760: LIST
50761: LIST
50762: LIST
50763: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
50764: LD_ADDR_VAR 0 32
50768: PUSH
50769: LD_INT 0
50771: PUSH
50772: LD_INT 0
50774: PUSH
50775: EMPTY
50776: LIST
50777: LIST
50778: PUSH
50779: LD_INT 0
50781: PUSH
50782: LD_INT 1
50784: NEG
50785: PUSH
50786: EMPTY
50787: LIST
50788: LIST
50789: PUSH
50790: LD_INT 1
50792: PUSH
50793: LD_INT 0
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: LD_INT 1
50802: PUSH
50803: LD_INT 1
50805: PUSH
50806: EMPTY
50807: LIST
50808: LIST
50809: PUSH
50810: LD_INT 0
50812: PUSH
50813: LD_INT 1
50815: PUSH
50816: EMPTY
50817: LIST
50818: LIST
50819: PUSH
50820: LD_INT 1
50822: NEG
50823: PUSH
50824: LD_INT 0
50826: PUSH
50827: EMPTY
50828: LIST
50829: LIST
50830: PUSH
50831: LD_INT 1
50833: NEG
50834: PUSH
50835: LD_INT 1
50837: NEG
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 1
50845: NEG
50846: PUSH
50847: LD_INT 2
50849: NEG
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: PUSH
50855: LD_INT 0
50857: PUSH
50858: LD_INT 2
50860: NEG
50861: PUSH
50862: EMPTY
50863: LIST
50864: LIST
50865: PUSH
50866: LD_INT 1
50868: PUSH
50869: LD_INT 1
50871: NEG
50872: PUSH
50873: EMPTY
50874: LIST
50875: LIST
50876: PUSH
50877: LD_INT 2
50879: PUSH
50880: LD_INT 1
50882: PUSH
50883: EMPTY
50884: LIST
50885: LIST
50886: PUSH
50887: LD_INT 2
50889: PUSH
50890: LD_INT 2
50892: PUSH
50893: EMPTY
50894: LIST
50895: LIST
50896: PUSH
50897: LD_INT 1
50899: PUSH
50900: LD_INT 2
50902: PUSH
50903: EMPTY
50904: LIST
50905: LIST
50906: PUSH
50907: LD_INT 0
50909: PUSH
50910: LD_INT 2
50912: PUSH
50913: EMPTY
50914: LIST
50915: LIST
50916: PUSH
50917: LD_INT 1
50919: NEG
50920: PUSH
50921: LD_INT 1
50923: PUSH
50924: EMPTY
50925: LIST
50926: LIST
50927: PUSH
50928: LD_INT 2
50930: NEG
50931: PUSH
50932: LD_INT 0
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 2
50941: NEG
50942: PUSH
50943: LD_INT 1
50945: NEG
50946: PUSH
50947: EMPTY
50948: LIST
50949: LIST
50950: PUSH
50951: LD_INT 1
50953: NEG
50954: PUSH
50955: LD_INT 3
50957: NEG
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: PUSH
50963: LD_INT 1
50965: PUSH
50966: LD_INT 2
50968: NEG
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: PUSH
50974: LD_INT 3
50976: PUSH
50977: LD_INT 2
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: PUSH
50984: LD_INT 2
50986: PUSH
50987: LD_INT 3
50989: PUSH
50990: EMPTY
50991: LIST
50992: LIST
50993: PUSH
50994: LD_INT 2
50996: NEG
50997: PUSH
50998: LD_INT 1
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: PUSH
51005: LD_INT 3
51007: NEG
51008: PUSH
51009: LD_INT 1
51011: NEG
51012: PUSH
51013: EMPTY
51014: LIST
51015: LIST
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: LIST
51028: LIST
51029: LIST
51030: LIST
51031: LIST
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
51042: LD_ADDR_VAR 0 33
51046: PUSH
51047: LD_INT 0
51049: PUSH
51050: LD_INT 0
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: PUSH
51057: LD_INT 0
51059: PUSH
51060: LD_INT 1
51062: NEG
51063: PUSH
51064: EMPTY
51065: LIST
51066: LIST
51067: PUSH
51068: LD_INT 1
51070: PUSH
51071: LD_INT 0
51073: PUSH
51074: EMPTY
51075: LIST
51076: LIST
51077: PUSH
51078: LD_INT 1
51080: PUSH
51081: LD_INT 1
51083: PUSH
51084: EMPTY
51085: LIST
51086: LIST
51087: PUSH
51088: LD_INT 0
51090: PUSH
51091: LD_INT 1
51093: PUSH
51094: EMPTY
51095: LIST
51096: LIST
51097: PUSH
51098: LD_INT 1
51100: NEG
51101: PUSH
51102: LD_INT 0
51104: PUSH
51105: EMPTY
51106: LIST
51107: LIST
51108: PUSH
51109: LD_INT 1
51111: NEG
51112: PUSH
51113: LD_INT 1
51115: NEG
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: PUSH
51121: LD_INT 1
51123: NEG
51124: PUSH
51125: LD_INT 2
51127: NEG
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: PUSH
51133: LD_INT 1
51135: PUSH
51136: LD_INT 1
51138: NEG
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: PUSH
51144: LD_INT 2
51146: PUSH
51147: LD_INT 0
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: PUSH
51154: LD_INT 2
51156: PUSH
51157: LD_INT 1
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PUSH
51164: LD_INT 1
51166: PUSH
51167: LD_INT 2
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PUSH
51174: LD_INT 0
51176: PUSH
51177: LD_INT 2
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 1
51186: NEG
51187: PUSH
51188: LD_INT 1
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PUSH
51195: LD_INT 2
51197: NEG
51198: PUSH
51199: LD_INT 0
51201: PUSH
51202: EMPTY
51203: LIST
51204: LIST
51205: PUSH
51206: LD_INT 2
51208: NEG
51209: PUSH
51210: LD_INT 1
51212: NEG
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: PUSH
51218: LD_INT 2
51220: NEG
51221: PUSH
51222: LD_INT 2
51224: NEG
51225: PUSH
51226: EMPTY
51227: LIST
51228: LIST
51229: PUSH
51230: LD_INT 2
51232: NEG
51233: PUSH
51234: LD_INT 3
51236: NEG
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 2
51244: PUSH
51245: LD_INT 1
51247: NEG
51248: PUSH
51249: EMPTY
51250: LIST
51251: LIST
51252: PUSH
51253: LD_INT 3
51255: PUSH
51256: LD_INT 1
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: PUSH
51263: LD_INT 1
51265: PUSH
51266: LD_INT 3
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: PUSH
51273: LD_INT 1
51275: NEG
51276: PUSH
51277: LD_INT 2
51279: PUSH
51280: EMPTY
51281: LIST
51282: LIST
51283: PUSH
51284: LD_INT 3
51286: NEG
51287: PUSH
51288: LD_INT 2
51290: NEG
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PUSH
51296: EMPTY
51297: LIST
51298: LIST
51299: LIST
51300: LIST
51301: LIST
51302: LIST
51303: LIST
51304: LIST
51305: LIST
51306: LIST
51307: LIST
51308: LIST
51309: LIST
51310: LIST
51311: LIST
51312: LIST
51313: LIST
51314: LIST
51315: LIST
51316: LIST
51317: LIST
51318: LIST
51319: LIST
51320: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
51321: LD_ADDR_VAR 0 34
51325: PUSH
51326: LD_INT 0
51328: PUSH
51329: LD_INT 0
51331: PUSH
51332: EMPTY
51333: LIST
51334: LIST
51335: PUSH
51336: LD_INT 0
51338: PUSH
51339: LD_INT 1
51341: NEG
51342: PUSH
51343: EMPTY
51344: LIST
51345: LIST
51346: PUSH
51347: LD_INT 1
51349: PUSH
51350: LD_INT 0
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: PUSH
51357: LD_INT 1
51359: PUSH
51360: LD_INT 1
51362: PUSH
51363: EMPTY
51364: LIST
51365: LIST
51366: PUSH
51367: LD_INT 0
51369: PUSH
51370: LD_INT 1
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: PUSH
51377: LD_INT 1
51379: NEG
51380: PUSH
51381: LD_INT 0
51383: PUSH
51384: EMPTY
51385: LIST
51386: LIST
51387: PUSH
51388: LD_INT 1
51390: NEG
51391: PUSH
51392: LD_INT 1
51394: NEG
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 1
51402: NEG
51403: PUSH
51404: LD_INT 2
51406: NEG
51407: PUSH
51408: EMPTY
51409: LIST
51410: LIST
51411: PUSH
51412: LD_INT 0
51414: PUSH
51415: LD_INT 2
51417: NEG
51418: PUSH
51419: EMPTY
51420: LIST
51421: LIST
51422: PUSH
51423: LD_INT 1
51425: PUSH
51426: LD_INT 1
51428: NEG
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: PUSH
51434: LD_INT 2
51436: PUSH
51437: LD_INT 1
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: PUSH
51444: LD_INT 2
51446: PUSH
51447: LD_INT 2
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: PUSH
51454: LD_INT 1
51456: PUSH
51457: LD_INT 2
51459: PUSH
51460: EMPTY
51461: LIST
51462: LIST
51463: PUSH
51464: LD_INT 1
51466: NEG
51467: PUSH
51468: LD_INT 1
51470: PUSH
51471: EMPTY
51472: LIST
51473: LIST
51474: PUSH
51475: LD_INT 2
51477: NEG
51478: PUSH
51479: LD_INT 0
51481: PUSH
51482: EMPTY
51483: LIST
51484: LIST
51485: PUSH
51486: LD_INT 2
51488: NEG
51489: PUSH
51490: LD_INT 1
51492: NEG
51493: PUSH
51494: EMPTY
51495: LIST
51496: LIST
51497: PUSH
51498: LD_INT 2
51500: NEG
51501: PUSH
51502: LD_INT 2
51504: NEG
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: PUSH
51510: LD_INT 1
51512: NEG
51513: PUSH
51514: LD_INT 3
51516: NEG
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: PUSH
51522: LD_INT 1
51524: PUSH
51525: LD_INT 2
51527: NEG
51528: PUSH
51529: EMPTY
51530: LIST
51531: LIST
51532: PUSH
51533: LD_INT 3
51535: PUSH
51536: LD_INT 2
51538: PUSH
51539: EMPTY
51540: LIST
51541: LIST
51542: PUSH
51543: LD_INT 2
51545: PUSH
51546: LD_INT 3
51548: PUSH
51549: EMPTY
51550: LIST
51551: LIST
51552: PUSH
51553: LD_INT 2
51555: NEG
51556: PUSH
51557: LD_INT 1
51559: PUSH
51560: EMPTY
51561: LIST
51562: LIST
51563: PUSH
51564: LD_INT 3
51566: NEG
51567: PUSH
51568: LD_INT 1
51570: NEG
51571: PUSH
51572: EMPTY
51573: LIST
51574: LIST
51575: PUSH
51576: EMPTY
51577: LIST
51578: LIST
51579: LIST
51580: LIST
51581: LIST
51582: LIST
51583: LIST
51584: LIST
51585: LIST
51586: LIST
51587: LIST
51588: LIST
51589: LIST
51590: LIST
51591: LIST
51592: LIST
51593: LIST
51594: LIST
51595: LIST
51596: LIST
51597: LIST
51598: LIST
51599: LIST
51600: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
51601: LD_ADDR_VAR 0 35
51605: PUSH
51606: LD_INT 0
51608: PUSH
51609: LD_INT 0
51611: PUSH
51612: EMPTY
51613: LIST
51614: LIST
51615: PUSH
51616: LD_INT 0
51618: PUSH
51619: LD_INT 1
51621: NEG
51622: PUSH
51623: EMPTY
51624: LIST
51625: LIST
51626: PUSH
51627: LD_INT 1
51629: PUSH
51630: LD_INT 0
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: PUSH
51637: LD_INT 1
51639: PUSH
51640: LD_INT 1
51642: PUSH
51643: EMPTY
51644: LIST
51645: LIST
51646: PUSH
51647: LD_INT 0
51649: PUSH
51650: LD_INT 1
51652: PUSH
51653: EMPTY
51654: LIST
51655: LIST
51656: PUSH
51657: LD_INT 1
51659: NEG
51660: PUSH
51661: LD_INT 0
51663: PUSH
51664: EMPTY
51665: LIST
51666: LIST
51667: PUSH
51668: LD_INT 1
51670: NEG
51671: PUSH
51672: LD_INT 1
51674: NEG
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PUSH
51680: LD_INT 2
51682: PUSH
51683: LD_INT 1
51685: PUSH
51686: EMPTY
51687: LIST
51688: LIST
51689: PUSH
51690: LD_INT 2
51692: NEG
51693: PUSH
51694: LD_INT 1
51696: NEG
51697: PUSH
51698: EMPTY
51699: LIST
51700: LIST
51701: PUSH
51702: EMPTY
51703: LIST
51704: LIST
51705: LIST
51706: LIST
51707: LIST
51708: LIST
51709: LIST
51710: LIST
51711: LIST
51712: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
51713: LD_ADDR_VAR 0 36
51717: PUSH
51718: LD_INT 0
51720: PUSH
51721: LD_INT 0
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: PUSH
51728: LD_INT 0
51730: PUSH
51731: LD_INT 1
51733: NEG
51734: PUSH
51735: EMPTY
51736: LIST
51737: LIST
51738: PUSH
51739: LD_INT 1
51741: PUSH
51742: LD_INT 0
51744: PUSH
51745: EMPTY
51746: LIST
51747: LIST
51748: PUSH
51749: LD_INT 1
51751: PUSH
51752: LD_INT 1
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: PUSH
51759: LD_INT 0
51761: PUSH
51762: LD_INT 1
51764: PUSH
51765: EMPTY
51766: LIST
51767: LIST
51768: PUSH
51769: LD_INT 1
51771: NEG
51772: PUSH
51773: LD_INT 0
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: PUSH
51780: LD_INT 1
51782: NEG
51783: PUSH
51784: LD_INT 1
51786: NEG
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: PUSH
51792: LD_INT 1
51794: NEG
51795: PUSH
51796: LD_INT 2
51798: NEG
51799: PUSH
51800: EMPTY
51801: LIST
51802: LIST
51803: PUSH
51804: LD_INT 1
51806: PUSH
51807: LD_INT 2
51809: PUSH
51810: EMPTY
51811: LIST
51812: LIST
51813: PUSH
51814: EMPTY
51815: LIST
51816: LIST
51817: LIST
51818: LIST
51819: LIST
51820: LIST
51821: LIST
51822: LIST
51823: LIST
51824: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
51825: LD_ADDR_VAR 0 37
51829: PUSH
51830: LD_INT 0
51832: PUSH
51833: LD_INT 0
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: PUSH
51840: LD_INT 0
51842: PUSH
51843: LD_INT 1
51845: NEG
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: PUSH
51851: LD_INT 1
51853: PUSH
51854: LD_INT 0
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: PUSH
51861: LD_INT 1
51863: PUSH
51864: LD_INT 1
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: PUSH
51871: LD_INT 0
51873: PUSH
51874: LD_INT 1
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: PUSH
51881: LD_INT 1
51883: NEG
51884: PUSH
51885: LD_INT 0
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: PUSH
51892: LD_INT 1
51894: NEG
51895: PUSH
51896: LD_INT 1
51898: NEG
51899: PUSH
51900: EMPTY
51901: LIST
51902: LIST
51903: PUSH
51904: LD_INT 1
51906: PUSH
51907: LD_INT 1
51909: NEG
51910: PUSH
51911: EMPTY
51912: LIST
51913: LIST
51914: PUSH
51915: LD_INT 1
51917: NEG
51918: PUSH
51919: LD_INT 1
51921: PUSH
51922: EMPTY
51923: LIST
51924: LIST
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: LIST
51933: LIST
51934: LIST
51935: LIST
51936: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
51937: LD_ADDR_VAR 0 38
51941: PUSH
51942: LD_INT 0
51944: PUSH
51945: LD_INT 0
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: PUSH
51952: LD_INT 0
51954: PUSH
51955: LD_INT 1
51957: NEG
51958: PUSH
51959: EMPTY
51960: LIST
51961: LIST
51962: PUSH
51963: LD_INT 1
51965: PUSH
51966: LD_INT 0
51968: PUSH
51969: EMPTY
51970: LIST
51971: LIST
51972: PUSH
51973: LD_INT 1
51975: PUSH
51976: LD_INT 1
51978: PUSH
51979: EMPTY
51980: LIST
51981: LIST
51982: PUSH
51983: LD_INT 0
51985: PUSH
51986: LD_INT 1
51988: PUSH
51989: EMPTY
51990: LIST
51991: LIST
51992: PUSH
51993: LD_INT 1
51995: NEG
51996: PUSH
51997: LD_INT 0
51999: PUSH
52000: EMPTY
52001: LIST
52002: LIST
52003: PUSH
52004: LD_INT 1
52006: NEG
52007: PUSH
52008: LD_INT 1
52010: NEG
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: PUSH
52016: LD_INT 2
52018: PUSH
52019: LD_INT 1
52021: PUSH
52022: EMPTY
52023: LIST
52024: LIST
52025: PUSH
52026: LD_INT 2
52028: NEG
52029: PUSH
52030: LD_INT 1
52032: NEG
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: PUSH
52038: EMPTY
52039: LIST
52040: LIST
52041: LIST
52042: LIST
52043: LIST
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
52049: LD_ADDR_VAR 0 39
52053: PUSH
52054: LD_INT 0
52056: PUSH
52057: LD_INT 0
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: PUSH
52064: LD_INT 0
52066: PUSH
52067: LD_INT 1
52069: NEG
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: PUSH
52075: LD_INT 1
52077: PUSH
52078: LD_INT 0
52080: PUSH
52081: EMPTY
52082: LIST
52083: LIST
52084: PUSH
52085: LD_INT 1
52087: PUSH
52088: LD_INT 1
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PUSH
52095: LD_INT 0
52097: PUSH
52098: LD_INT 1
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: PUSH
52105: LD_INT 1
52107: NEG
52108: PUSH
52109: LD_INT 0
52111: PUSH
52112: EMPTY
52113: LIST
52114: LIST
52115: PUSH
52116: LD_INT 1
52118: NEG
52119: PUSH
52120: LD_INT 1
52122: NEG
52123: PUSH
52124: EMPTY
52125: LIST
52126: LIST
52127: PUSH
52128: LD_INT 1
52130: NEG
52131: PUSH
52132: LD_INT 2
52134: NEG
52135: PUSH
52136: EMPTY
52137: LIST
52138: LIST
52139: PUSH
52140: LD_INT 1
52142: PUSH
52143: LD_INT 2
52145: PUSH
52146: EMPTY
52147: LIST
52148: LIST
52149: PUSH
52150: EMPTY
52151: LIST
52152: LIST
52153: LIST
52154: LIST
52155: LIST
52156: LIST
52157: LIST
52158: LIST
52159: LIST
52160: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
52161: LD_ADDR_VAR 0 40
52165: PUSH
52166: LD_INT 0
52168: PUSH
52169: LD_INT 0
52171: PUSH
52172: EMPTY
52173: LIST
52174: LIST
52175: PUSH
52176: LD_INT 0
52178: PUSH
52179: LD_INT 1
52181: NEG
52182: PUSH
52183: EMPTY
52184: LIST
52185: LIST
52186: PUSH
52187: LD_INT 1
52189: PUSH
52190: LD_INT 0
52192: PUSH
52193: EMPTY
52194: LIST
52195: LIST
52196: PUSH
52197: LD_INT 1
52199: PUSH
52200: LD_INT 1
52202: PUSH
52203: EMPTY
52204: LIST
52205: LIST
52206: PUSH
52207: LD_INT 0
52209: PUSH
52210: LD_INT 1
52212: PUSH
52213: EMPTY
52214: LIST
52215: LIST
52216: PUSH
52217: LD_INT 1
52219: NEG
52220: PUSH
52221: LD_INT 0
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PUSH
52228: LD_INT 1
52230: NEG
52231: PUSH
52232: LD_INT 1
52234: NEG
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PUSH
52240: LD_INT 1
52242: PUSH
52243: LD_INT 1
52245: NEG
52246: PUSH
52247: EMPTY
52248: LIST
52249: LIST
52250: PUSH
52251: LD_INT 1
52253: NEG
52254: PUSH
52255: LD_INT 1
52257: PUSH
52258: EMPTY
52259: LIST
52260: LIST
52261: PUSH
52262: EMPTY
52263: LIST
52264: LIST
52265: LIST
52266: LIST
52267: LIST
52268: LIST
52269: LIST
52270: LIST
52271: LIST
52272: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
52273: LD_ADDR_VAR 0 41
52277: PUSH
52278: LD_INT 0
52280: PUSH
52281: LD_INT 0
52283: PUSH
52284: EMPTY
52285: LIST
52286: LIST
52287: PUSH
52288: LD_INT 0
52290: PUSH
52291: LD_INT 1
52293: NEG
52294: PUSH
52295: EMPTY
52296: LIST
52297: LIST
52298: PUSH
52299: LD_INT 1
52301: PUSH
52302: LD_INT 0
52304: PUSH
52305: EMPTY
52306: LIST
52307: LIST
52308: PUSH
52309: LD_INT 1
52311: PUSH
52312: LD_INT 1
52314: PUSH
52315: EMPTY
52316: LIST
52317: LIST
52318: PUSH
52319: LD_INT 0
52321: PUSH
52322: LD_INT 1
52324: PUSH
52325: EMPTY
52326: LIST
52327: LIST
52328: PUSH
52329: LD_INT 1
52331: NEG
52332: PUSH
52333: LD_INT 0
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: PUSH
52340: LD_INT 1
52342: NEG
52343: PUSH
52344: LD_INT 1
52346: NEG
52347: PUSH
52348: EMPTY
52349: LIST
52350: LIST
52351: PUSH
52352: LD_INT 1
52354: NEG
52355: PUSH
52356: LD_INT 2
52358: NEG
52359: PUSH
52360: EMPTY
52361: LIST
52362: LIST
52363: PUSH
52364: LD_INT 1
52366: PUSH
52367: LD_INT 1
52369: NEG
52370: PUSH
52371: EMPTY
52372: LIST
52373: LIST
52374: PUSH
52375: LD_INT 2
52377: PUSH
52378: LD_INT 0
52380: PUSH
52381: EMPTY
52382: LIST
52383: LIST
52384: PUSH
52385: LD_INT 2
52387: PUSH
52388: LD_INT 1
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PUSH
52395: LD_INT 2
52397: PUSH
52398: LD_INT 2
52400: PUSH
52401: EMPTY
52402: LIST
52403: LIST
52404: PUSH
52405: LD_INT 1
52407: PUSH
52408: LD_INT 2
52410: PUSH
52411: EMPTY
52412: LIST
52413: LIST
52414: PUSH
52415: LD_INT 1
52417: NEG
52418: PUSH
52419: LD_INT 1
52421: PUSH
52422: EMPTY
52423: LIST
52424: LIST
52425: PUSH
52426: LD_INT 2
52428: NEG
52429: PUSH
52430: LD_INT 0
52432: PUSH
52433: EMPTY
52434: LIST
52435: LIST
52436: PUSH
52437: LD_INT 2
52439: NEG
52440: PUSH
52441: LD_INT 1
52443: NEG
52444: PUSH
52445: EMPTY
52446: LIST
52447: LIST
52448: PUSH
52449: LD_INT 2
52451: NEG
52452: PUSH
52453: LD_INT 2
52455: NEG
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: PUSH
52461: LD_INT 2
52463: NEG
52464: PUSH
52465: LD_INT 3
52467: NEG
52468: PUSH
52469: EMPTY
52470: LIST
52471: LIST
52472: PUSH
52473: LD_INT 2
52475: PUSH
52476: LD_INT 1
52478: NEG
52479: PUSH
52480: EMPTY
52481: LIST
52482: LIST
52483: PUSH
52484: LD_INT 3
52486: PUSH
52487: LD_INT 0
52489: PUSH
52490: EMPTY
52491: LIST
52492: LIST
52493: PUSH
52494: LD_INT 3
52496: PUSH
52497: LD_INT 1
52499: PUSH
52500: EMPTY
52501: LIST
52502: LIST
52503: PUSH
52504: LD_INT 3
52506: PUSH
52507: LD_INT 2
52509: PUSH
52510: EMPTY
52511: LIST
52512: LIST
52513: PUSH
52514: LD_INT 3
52516: PUSH
52517: LD_INT 3
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: PUSH
52524: LD_INT 2
52526: PUSH
52527: LD_INT 3
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: PUSH
52534: LD_INT 2
52536: NEG
52537: PUSH
52538: LD_INT 1
52540: PUSH
52541: EMPTY
52542: LIST
52543: LIST
52544: PUSH
52545: LD_INT 3
52547: NEG
52548: PUSH
52549: LD_INT 0
52551: PUSH
52552: EMPTY
52553: LIST
52554: LIST
52555: PUSH
52556: LD_INT 3
52558: NEG
52559: PUSH
52560: LD_INT 1
52562: NEG
52563: PUSH
52564: EMPTY
52565: LIST
52566: LIST
52567: PUSH
52568: LD_INT 3
52570: NEG
52571: PUSH
52572: LD_INT 2
52574: NEG
52575: PUSH
52576: EMPTY
52577: LIST
52578: LIST
52579: PUSH
52580: LD_INT 3
52582: NEG
52583: PUSH
52584: LD_INT 3
52586: NEG
52587: PUSH
52588: EMPTY
52589: LIST
52590: LIST
52591: PUSH
52592: EMPTY
52593: LIST
52594: LIST
52595: LIST
52596: LIST
52597: LIST
52598: LIST
52599: LIST
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: LIST
52605: LIST
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: LIST
52612: LIST
52613: LIST
52614: LIST
52615: LIST
52616: LIST
52617: LIST
52618: LIST
52619: LIST
52620: LIST
52621: LIST
52622: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
52623: LD_ADDR_VAR 0 42
52627: PUSH
52628: LD_INT 0
52630: PUSH
52631: LD_INT 0
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: PUSH
52638: LD_INT 0
52640: PUSH
52641: LD_INT 1
52643: NEG
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: PUSH
52649: LD_INT 1
52651: PUSH
52652: LD_INT 0
52654: PUSH
52655: EMPTY
52656: LIST
52657: LIST
52658: PUSH
52659: LD_INT 1
52661: PUSH
52662: LD_INT 1
52664: PUSH
52665: EMPTY
52666: LIST
52667: LIST
52668: PUSH
52669: LD_INT 0
52671: PUSH
52672: LD_INT 1
52674: PUSH
52675: EMPTY
52676: LIST
52677: LIST
52678: PUSH
52679: LD_INT 1
52681: NEG
52682: PUSH
52683: LD_INT 0
52685: PUSH
52686: EMPTY
52687: LIST
52688: LIST
52689: PUSH
52690: LD_INT 1
52692: NEG
52693: PUSH
52694: LD_INT 1
52696: NEG
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: PUSH
52702: LD_INT 1
52704: NEG
52705: PUSH
52706: LD_INT 2
52708: NEG
52709: PUSH
52710: EMPTY
52711: LIST
52712: LIST
52713: PUSH
52714: LD_INT 0
52716: PUSH
52717: LD_INT 2
52719: NEG
52720: PUSH
52721: EMPTY
52722: LIST
52723: LIST
52724: PUSH
52725: LD_INT 1
52727: PUSH
52728: LD_INT 1
52730: NEG
52731: PUSH
52732: EMPTY
52733: LIST
52734: LIST
52735: PUSH
52736: LD_INT 2
52738: PUSH
52739: LD_INT 1
52741: PUSH
52742: EMPTY
52743: LIST
52744: LIST
52745: PUSH
52746: LD_INT 2
52748: PUSH
52749: LD_INT 2
52751: PUSH
52752: EMPTY
52753: LIST
52754: LIST
52755: PUSH
52756: LD_INT 1
52758: PUSH
52759: LD_INT 2
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: PUSH
52766: LD_INT 0
52768: PUSH
52769: LD_INT 2
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: PUSH
52776: LD_INT 1
52778: NEG
52779: PUSH
52780: LD_INT 1
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: PUSH
52787: LD_INT 2
52789: NEG
52790: PUSH
52791: LD_INT 1
52793: NEG
52794: PUSH
52795: EMPTY
52796: LIST
52797: LIST
52798: PUSH
52799: LD_INT 2
52801: NEG
52802: PUSH
52803: LD_INT 2
52805: NEG
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: PUSH
52811: LD_INT 2
52813: NEG
52814: PUSH
52815: LD_INT 3
52817: NEG
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: LD_INT 1
52825: NEG
52826: PUSH
52827: LD_INT 3
52829: NEG
52830: PUSH
52831: EMPTY
52832: LIST
52833: LIST
52834: PUSH
52835: LD_INT 0
52837: PUSH
52838: LD_INT 3
52840: NEG
52841: PUSH
52842: EMPTY
52843: LIST
52844: LIST
52845: PUSH
52846: LD_INT 1
52848: PUSH
52849: LD_INT 2
52851: NEG
52852: PUSH
52853: EMPTY
52854: LIST
52855: LIST
52856: PUSH
52857: LD_INT 3
52859: PUSH
52860: LD_INT 2
52862: PUSH
52863: EMPTY
52864: LIST
52865: LIST
52866: PUSH
52867: LD_INT 3
52869: PUSH
52870: LD_INT 3
52872: PUSH
52873: EMPTY
52874: LIST
52875: LIST
52876: PUSH
52877: LD_INT 2
52879: PUSH
52880: LD_INT 3
52882: PUSH
52883: EMPTY
52884: LIST
52885: LIST
52886: PUSH
52887: LD_INT 1
52889: PUSH
52890: LD_INT 3
52892: PUSH
52893: EMPTY
52894: LIST
52895: LIST
52896: PUSH
52897: LD_INT 0
52899: PUSH
52900: LD_INT 3
52902: PUSH
52903: EMPTY
52904: LIST
52905: LIST
52906: PUSH
52907: LD_INT 1
52909: NEG
52910: PUSH
52911: LD_INT 2
52913: PUSH
52914: EMPTY
52915: LIST
52916: LIST
52917: PUSH
52918: LD_INT 3
52920: NEG
52921: PUSH
52922: LD_INT 2
52924: NEG
52925: PUSH
52926: EMPTY
52927: LIST
52928: LIST
52929: PUSH
52930: LD_INT 3
52932: NEG
52933: PUSH
52934: LD_INT 3
52936: NEG
52937: PUSH
52938: EMPTY
52939: LIST
52940: LIST
52941: PUSH
52942: EMPTY
52943: LIST
52944: LIST
52945: LIST
52946: LIST
52947: LIST
52948: LIST
52949: LIST
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: LIST
52955: LIST
52956: LIST
52957: LIST
52958: LIST
52959: LIST
52960: LIST
52961: LIST
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: LIST
52969: LIST
52970: LIST
52971: LIST
52972: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
52973: LD_ADDR_VAR 0 43
52977: PUSH
52978: LD_INT 0
52980: PUSH
52981: LD_INT 0
52983: PUSH
52984: EMPTY
52985: LIST
52986: LIST
52987: PUSH
52988: LD_INT 0
52990: PUSH
52991: LD_INT 1
52993: NEG
52994: PUSH
52995: EMPTY
52996: LIST
52997: LIST
52998: PUSH
52999: LD_INT 1
53001: PUSH
53002: LD_INT 0
53004: PUSH
53005: EMPTY
53006: LIST
53007: LIST
53008: PUSH
53009: LD_INT 1
53011: PUSH
53012: LD_INT 1
53014: PUSH
53015: EMPTY
53016: LIST
53017: LIST
53018: PUSH
53019: LD_INT 0
53021: PUSH
53022: LD_INT 1
53024: PUSH
53025: EMPTY
53026: LIST
53027: LIST
53028: PUSH
53029: LD_INT 1
53031: NEG
53032: PUSH
53033: LD_INT 0
53035: PUSH
53036: EMPTY
53037: LIST
53038: LIST
53039: PUSH
53040: LD_INT 1
53042: NEG
53043: PUSH
53044: LD_INT 1
53046: NEG
53047: PUSH
53048: EMPTY
53049: LIST
53050: LIST
53051: PUSH
53052: LD_INT 1
53054: NEG
53055: PUSH
53056: LD_INT 2
53058: NEG
53059: PUSH
53060: EMPTY
53061: LIST
53062: LIST
53063: PUSH
53064: LD_INT 0
53066: PUSH
53067: LD_INT 2
53069: NEG
53070: PUSH
53071: EMPTY
53072: LIST
53073: LIST
53074: PUSH
53075: LD_INT 1
53077: PUSH
53078: LD_INT 1
53080: NEG
53081: PUSH
53082: EMPTY
53083: LIST
53084: LIST
53085: PUSH
53086: LD_INT 2
53088: PUSH
53089: LD_INT 0
53091: PUSH
53092: EMPTY
53093: LIST
53094: LIST
53095: PUSH
53096: LD_INT 2
53098: PUSH
53099: LD_INT 1
53101: PUSH
53102: EMPTY
53103: LIST
53104: LIST
53105: PUSH
53106: LD_INT 1
53108: PUSH
53109: LD_INT 2
53111: PUSH
53112: EMPTY
53113: LIST
53114: LIST
53115: PUSH
53116: LD_INT 0
53118: PUSH
53119: LD_INT 2
53121: PUSH
53122: EMPTY
53123: LIST
53124: LIST
53125: PUSH
53126: LD_INT 1
53128: NEG
53129: PUSH
53130: LD_INT 1
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: PUSH
53137: LD_INT 2
53139: NEG
53140: PUSH
53141: LD_INT 0
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: PUSH
53148: LD_INT 2
53150: NEG
53151: PUSH
53152: LD_INT 1
53154: NEG
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PUSH
53160: LD_INT 1
53162: NEG
53163: PUSH
53164: LD_INT 3
53166: NEG
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: PUSH
53172: LD_INT 0
53174: PUSH
53175: LD_INT 3
53177: NEG
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: PUSH
53183: LD_INT 1
53185: PUSH
53186: LD_INT 2
53188: NEG
53189: PUSH
53190: EMPTY
53191: LIST
53192: LIST
53193: PUSH
53194: LD_INT 2
53196: PUSH
53197: LD_INT 1
53199: NEG
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: PUSH
53205: LD_INT 3
53207: PUSH
53208: LD_INT 0
53210: PUSH
53211: EMPTY
53212: LIST
53213: LIST
53214: PUSH
53215: LD_INT 3
53217: PUSH
53218: LD_INT 1
53220: PUSH
53221: EMPTY
53222: LIST
53223: LIST
53224: PUSH
53225: LD_INT 1
53227: PUSH
53228: LD_INT 3
53230: PUSH
53231: EMPTY
53232: LIST
53233: LIST
53234: PUSH
53235: LD_INT 0
53237: PUSH
53238: LD_INT 3
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: PUSH
53245: LD_INT 1
53247: NEG
53248: PUSH
53249: LD_INT 2
53251: PUSH
53252: EMPTY
53253: LIST
53254: LIST
53255: PUSH
53256: LD_INT 2
53258: NEG
53259: PUSH
53260: LD_INT 1
53262: PUSH
53263: EMPTY
53264: LIST
53265: LIST
53266: PUSH
53267: LD_INT 3
53269: NEG
53270: PUSH
53271: LD_INT 0
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: PUSH
53278: LD_INT 3
53280: NEG
53281: PUSH
53282: LD_INT 1
53284: NEG
53285: PUSH
53286: EMPTY
53287: LIST
53288: LIST
53289: PUSH
53290: EMPTY
53291: LIST
53292: LIST
53293: LIST
53294: LIST
53295: LIST
53296: LIST
53297: LIST
53298: LIST
53299: LIST
53300: LIST
53301: LIST
53302: LIST
53303: LIST
53304: LIST
53305: LIST
53306: LIST
53307: LIST
53308: LIST
53309: LIST
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: LIST
53316: LIST
53317: LIST
53318: LIST
53319: LIST
53320: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
53321: LD_ADDR_VAR 0 44
53325: PUSH
53326: LD_INT 0
53328: PUSH
53329: LD_INT 0
53331: PUSH
53332: EMPTY
53333: LIST
53334: LIST
53335: PUSH
53336: LD_INT 0
53338: PUSH
53339: LD_INT 1
53341: NEG
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: PUSH
53347: LD_INT 1
53349: PUSH
53350: LD_INT 0
53352: PUSH
53353: EMPTY
53354: LIST
53355: LIST
53356: PUSH
53357: LD_INT 1
53359: PUSH
53360: LD_INT 1
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: PUSH
53367: LD_INT 0
53369: PUSH
53370: LD_INT 1
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: PUSH
53377: LD_INT 1
53379: NEG
53380: PUSH
53381: LD_INT 0
53383: PUSH
53384: EMPTY
53385: LIST
53386: LIST
53387: PUSH
53388: LD_INT 1
53390: NEG
53391: PUSH
53392: LD_INT 1
53394: NEG
53395: PUSH
53396: EMPTY
53397: LIST
53398: LIST
53399: PUSH
53400: LD_INT 1
53402: NEG
53403: PUSH
53404: LD_INT 2
53406: NEG
53407: PUSH
53408: EMPTY
53409: LIST
53410: LIST
53411: PUSH
53412: LD_INT 1
53414: PUSH
53415: LD_INT 1
53417: NEG
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: PUSH
53423: LD_INT 2
53425: PUSH
53426: LD_INT 0
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: PUSH
53433: LD_INT 2
53435: PUSH
53436: LD_INT 1
53438: PUSH
53439: EMPTY
53440: LIST
53441: LIST
53442: PUSH
53443: LD_INT 2
53445: PUSH
53446: LD_INT 2
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PUSH
53453: LD_INT 1
53455: PUSH
53456: LD_INT 2
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: LD_INT 1
53465: NEG
53466: PUSH
53467: LD_INT 1
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PUSH
53474: LD_INT 2
53476: NEG
53477: PUSH
53478: LD_INT 0
53480: PUSH
53481: EMPTY
53482: LIST
53483: LIST
53484: PUSH
53485: LD_INT 2
53487: NEG
53488: PUSH
53489: LD_INT 1
53491: NEG
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: PUSH
53497: LD_INT 2
53499: NEG
53500: PUSH
53501: LD_INT 2
53503: NEG
53504: PUSH
53505: EMPTY
53506: LIST
53507: LIST
53508: PUSH
53509: LD_INT 2
53511: NEG
53512: PUSH
53513: LD_INT 3
53515: NEG
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: PUSH
53521: LD_INT 2
53523: PUSH
53524: LD_INT 1
53526: NEG
53527: PUSH
53528: EMPTY
53529: LIST
53530: LIST
53531: PUSH
53532: LD_INT 3
53534: PUSH
53535: LD_INT 0
53537: PUSH
53538: EMPTY
53539: LIST
53540: LIST
53541: PUSH
53542: LD_INT 3
53544: PUSH
53545: LD_INT 1
53547: PUSH
53548: EMPTY
53549: LIST
53550: LIST
53551: PUSH
53552: LD_INT 3
53554: PUSH
53555: LD_INT 2
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: PUSH
53562: LD_INT 3
53564: PUSH
53565: LD_INT 3
53567: PUSH
53568: EMPTY
53569: LIST
53570: LIST
53571: PUSH
53572: LD_INT 2
53574: PUSH
53575: LD_INT 3
53577: PUSH
53578: EMPTY
53579: LIST
53580: LIST
53581: PUSH
53582: LD_INT 2
53584: NEG
53585: PUSH
53586: LD_INT 1
53588: PUSH
53589: EMPTY
53590: LIST
53591: LIST
53592: PUSH
53593: LD_INT 3
53595: NEG
53596: PUSH
53597: LD_INT 0
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: PUSH
53604: LD_INT 3
53606: NEG
53607: PUSH
53608: LD_INT 1
53610: NEG
53611: PUSH
53612: EMPTY
53613: LIST
53614: LIST
53615: PUSH
53616: LD_INT 3
53618: NEG
53619: PUSH
53620: LD_INT 2
53622: NEG
53623: PUSH
53624: EMPTY
53625: LIST
53626: LIST
53627: PUSH
53628: LD_INT 3
53630: NEG
53631: PUSH
53632: LD_INT 3
53634: NEG
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: LIST
53644: LIST
53645: LIST
53646: LIST
53647: LIST
53648: LIST
53649: LIST
53650: LIST
53651: LIST
53652: LIST
53653: LIST
53654: LIST
53655: LIST
53656: LIST
53657: LIST
53658: LIST
53659: LIST
53660: LIST
53661: LIST
53662: LIST
53663: LIST
53664: LIST
53665: LIST
53666: LIST
53667: LIST
53668: LIST
53669: LIST
53670: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
53671: LD_ADDR_VAR 0 45
53675: PUSH
53676: LD_INT 0
53678: PUSH
53679: LD_INT 0
53681: PUSH
53682: EMPTY
53683: LIST
53684: LIST
53685: PUSH
53686: LD_INT 0
53688: PUSH
53689: LD_INT 1
53691: NEG
53692: PUSH
53693: EMPTY
53694: LIST
53695: LIST
53696: PUSH
53697: LD_INT 1
53699: PUSH
53700: LD_INT 0
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: PUSH
53707: LD_INT 1
53709: PUSH
53710: LD_INT 1
53712: PUSH
53713: EMPTY
53714: LIST
53715: LIST
53716: PUSH
53717: LD_INT 0
53719: PUSH
53720: LD_INT 1
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: PUSH
53727: LD_INT 1
53729: NEG
53730: PUSH
53731: LD_INT 0
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: PUSH
53738: LD_INT 1
53740: NEG
53741: PUSH
53742: LD_INT 1
53744: NEG
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PUSH
53750: LD_INT 1
53752: NEG
53753: PUSH
53754: LD_INT 2
53756: NEG
53757: PUSH
53758: EMPTY
53759: LIST
53760: LIST
53761: PUSH
53762: LD_INT 0
53764: PUSH
53765: LD_INT 2
53767: NEG
53768: PUSH
53769: EMPTY
53770: LIST
53771: LIST
53772: PUSH
53773: LD_INT 1
53775: PUSH
53776: LD_INT 1
53778: NEG
53779: PUSH
53780: EMPTY
53781: LIST
53782: LIST
53783: PUSH
53784: LD_INT 2
53786: PUSH
53787: LD_INT 1
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PUSH
53794: LD_INT 2
53796: PUSH
53797: LD_INT 2
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: PUSH
53804: LD_INT 1
53806: PUSH
53807: LD_INT 2
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PUSH
53814: LD_INT 0
53816: PUSH
53817: LD_INT 2
53819: PUSH
53820: EMPTY
53821: LIST
53822: LIST
53823: PUSH
53824: LD_INT 1
53826: NEG
53827: PUSH
53828: LD_INT 1
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: PUSH
53835: LD_INT 2
53837: NEG
53838: PUSH
53839: LD_INT 1
53841: NEG
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: PUSH
53847: LD_INT 2
53849: NEG
53850: PUSH
53851: LD_INT 2
53853: NEG
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: PUSH
53859: LD_INT 2
53861: NEG
53862: PUSH
53863: LD_INT 3
53865: NEG
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: PUSH
53871: LD_INT 1
53873: NEG
53874: PUSH
53875: LD_INT 3
53877: NEG
53878: PUSH
53879: EMPTY
53880: LIST
53881: LIST
53882: PUSH
53883: LD_INT 0
53885: PUSH
53886: LD_INT 3
53888: NEG
53889: PUSH
53890: EMPTY
53891: LIST
53892: LIST
53893: PUSH
53894: LD_INT 1
53896: PUSH
53897: LD_INT 2
53899: NEG
53900: PUSH
53901: EMPTY
53902: LIST
53903: LIST
53904: PUSH
53905: LD_INT 3
53907: PUSH
53908: LD_INT 2
53910: PUSH
53911: EMPTY
53912: LIST
53913: LIST
53914: PUSH
53915: LD_INT 3
53917: PUSH
53918: LD_INT 3
53920: PUSH
53921: EMPTY
53922: LIST
53923: LIST
53924: PUSH
53925: LD_INT 2
53927: PUSH
53928: LD_INT 3
53930: PUSH
53931: EMPTY
53932: LIST
53933: LIST
53934: PUSH
53935: LD_INT 1
53937: PUSH
53938: LD_INT 3
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: PUSH
53945: LD_INT 0
53947: PUSH
53948: LD_INT 3
53950: PUSH
53951: EMPTY
53952: LIST
53953: LIST
53954: PUSH
53955: LD_INT 1
53957: NEG
53958: PUSH
53959: LD_INT 2
53961: PUSH
53962: EMPTY
53963: LIST
53964: LIST
53965: PUSH
53966: LD_INT 3
53968: NEG
53969: PUSH
53970: LD_INT 2
53972: NEG
53973: PUSH
53974: EMPTY
53975: LIST
53976: LIST
53977: PUSH
53978: LD_INT 3
53980: NEG
53981: PUSH
53982: LD_INT 3
53984: NEG
53985: PUSH
53986: EMPTY
53987: LIST
53988: LIST
53989: PUSH
53990: EMPTY
53991: LIST
53992: LIST
53993: LIST
53994: LIST
53995: LIST
53996: LIST
53997: LIST
53998: LIST
53999: LIST
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: LIST
54005: LIST
54006: LIST
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: LIST
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: LIST
54018: LIST
54019: LIST
54020: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
54021: LD_ADDR_VAR 0 46
54025: PUSH
54026: LD_INT 0
54028: PUSH
54029: LD_INT 0
54031: PUSH
54032: EMPTY
54033: LIST
54034: LIST
54035: PUSH
54036: LD_INT 0
54038: PUSH
54039: LD_INT 1
54041: NEG
54042: PUSH
54043: EMPTY
54044: LIST
54045: LIST
54046: PUSH
54047: LD_INT 1
54049: PUSH
54050: LD_INT 0
54052: PUSH
54053: EMPTY
54054: LIST
54055: LIST
54056: PUSH
54057: LD_INT 1
54059: PUSH
54060: LD_INT 1
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: PUSH
54067: LD_INT 0
54069: PUSH
54070: LD_INT 1
54072: PUSH
54073: EMPTY
54074: LIST
54075: LIST
54076: PUSH
54077: LD_INT 1
54079: NEG
54080: PUSH
54081: LD_INT 0
54083: PUSH
54084: EMPTY
54085: LIST
54086: LIST
54087: PUSH
54088: LD_INT 1
54090: NEG
54091: PUSH
54092: LD_INT 1
54094: NEG
54095: PUSH
54096: EMPTY
54097: LIST
54098: LIST
54099: PUSH
54100: LD_INT 1
54102: NEG
54103: PUSH
54104: LD_INT 2
54106: NEG
54107: PUSH
54108: EMPTY
54109: LIST
54110: LIST
54111: PUSH
54112: LD_INT 0
54114: PUSH
54115: LD_INT 2
54117: NEG
54118: PUSH
54119: EMPTY
54120: LIST
54121: LIST
54122: PUSH
54123: LD_INT 1
54125: PUSH
54126: LD_INT 1
54128: NEG
54129: PUSH
54130: EMPTY
54131: LIST
54132: LIST
54133: PUSH
54134: LD_INT 2
54136: PUSH
54137: LD_INT 0
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: PUSH
54144: LD_INT 2
54146: PUSH
54147: LD_INT 1
54149: PUSH
54150: EMPTY
54151: LIST
54152: LIST
54153: PUSH
54154: LD_INT 1
54156: PUSH
54157: LD_INT 2
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: PUSH
54164: LD_INT 0
54166: PUSH
54167: LD_INT 2
54169: PUSH
54170: EMPTY
54171: LIST
54172: LIST
54173: PUSH
54174: LD_INT 1
54176: NEG
54177: PUSH
54178: LD_INT 1
54180: PUSH
54181: EMPTY
54182: LIST
54183: LIST
54184: PUSH
54185: LD_INT 2
54187: NEG
54188: PUSH
54189: LD_INT 0
54191: PUSH
54192: EMPTY
54193: LIST
54194: LIST
54195: PUSH
54196: LD_INT 2
54198: NEG
54199: PUSH
54200: LD_INT 1
54202: NEG
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: PUSH
54208: LD_INT 1
54210: NEG
54211: PUSH
54212: LD_INT 3
54214: NEG
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: PUSH
54220: LD_INT 0
54222: PUSH
54223: LD_INT 3
54225: NEG
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PUSH
54231: LD_INT 1
54233: PUSH
54234: LD_INT 2
54236: NEG
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: PUSH
54242: LD_INT 2
54244: PUSH
54245: LD_INT 1
54247: NEG
54248: PUSH
54249: EMPTY
54250: LIST
54251: LIST
54252: PUSH
54253: LD_INT 3
54255: PUSH
54256: LD_INT 0
54258: PUSH
54259: EMPTY
54260: LIST
54261: LIST
54262: PUSH
54263: LD_INT 3
54265: PUSH
54266: LD_INT 1
54268: PUSH
54269: EMPTY
54270: LIST
54271: LIST
54272: PUSH
54273: LD_INT 1
54275: PUSH
54276: LD_INT 3
54278: PUSH
54279: EMPTY
54280: LIST
54281: LIST
54282: PUSH
54283: LD_INT 0
54285: PUSH
54286: LD_INT 3
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: PUSH
54293: LD_INT 1
54295: NEG
54296: PUSH
54297: LD_INT 2
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: PUSH
54304: LD_INT 2
54306: NEG
54307: PUSH
54308: LD_INT 1
54310: PUSH
54311: EMPTY
54312: LIST
54313: LIST
54314: PUSH
54315: LD_INT 3
54317: NEG
54318: PUSH
54319: LD_INT 0
54321: PUSH
54322: EMPTY
54323: LIST
54324: LIST
54325: PUSH
54326: LD_INT 3
54328: NEG
54329: PUSH
54330: LD_INT 1
54332: NEG
54333: PUSH
54334: EMPTY
54335: LIST
54336: LIST
54337: PUSH
54338: EMPTY
54339: LIST
54340: LIST
54341: LIST
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: LIST
54347: LIST
54348: LIST
54349: LIST
54350: LIST
54351: LIST
54352: LIST
54353: LIST
54354: LIST
54355: LIST
54356: LIST
54357: LIST
54358: LIST
54359: LIST
54360: LIST
54361: LIST
54362: LIST
54363: LIST
54364: LIST
54365: LIST
54366: LIST
54367: LIST
54368: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
54369: LD_ADDR_VAR 0 47
54373: PUSH
54374: LD_INT 0
54376: PUSH
54377: LD_INT 0
54379: PUSH
54380: EMPTY
54381: LIST
54382: LIST
54383: PUSH
54384: LD_INT 0
54386: PUSH
54387: LD_INT 1
54389: NEG
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: PUSH
54395: LD_INT 1
54397: PUSH
54398: LD_INT 0
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PUSH
54405: LD_INT 1
54407: PUSH
54408: LD_INT 1
54410: PUSH
54411: EMPTY
54412: LIST
54413: LIST
54414: PUSH
54415: LD_INT 0
54417: PUSH
54418: LD_INT 1
54420: PUSH
54421: EMPTY
54422: LIST
54423: LIST
54424: PUSH
54425: LD_INT 1
54427: NEG
54428: PUSH
54429: LD_INT 0
54431: PUSH
54432: EMPTY
54433: LIST
54434: LIST
54435: PUSH
54436: LD_INT 1
54438: NEG
54439: PUSH
54440: LD_INT 1
54442: NEG
54443: PUSH
54444: EMPTY
54445: LIST
54446: LIST
54447: PUSH
54448: LD_INT 1
54450: NEG
54451: PUSH
54452: LD_INT 2
54454: NEG
54455: PUSH
54456: EMPTY
54457: LIST
54458: LIST
54459: PUSH
54460: LD_INT 0
54462: PUSH
54463: LD_INT 2
54465: NEG
54466: PUSH
54467: EMPTY
54468: LIST
54469: LIST
54470: PUSH
54471: LD_INT 1
54473: PUSH
54474: LD_INT 1
54476: NEG
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: PUSH
54482: LD_INT 2
54484: NEG
54485: PUSH
54486: LD_INT 1
54488: NEG
54489: PUSH
54490: EMPTY
54491: LIST
54492: LIST
54493: PUSH
54494: LD_INT 2
54496: NEG
54497: PUSH
54498: LD_INT 2
54500: NEG
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: PUSH
54506: EMPTY
54507: LIST
54508: LIST
54509: LIST
54510: LIST
54511: LIST
54512: LIST
54513: LIST
54514: LIST
54515: LIST
54516: LIST
54517: LIST
54518: LIST
54519: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
54520: LD_ADDR_VAR 0 48
54524: PUSH
54525: LD_INT 0
54527: PUSH
54528: LD_INT 0
54530: PUSH
54531: EMPTY
54532: LIST
54533: LIST
54534: PUSH
54535: LD_INT 0
54537: PUSH
54538: LD_INT 1
54540: NEG
54541: PUSH
54542: EMPTY
54543: LIST
54544: LIST
54545: PUSH
54546: LD_INT 1
54548: PUSH
54549: LD_INT 0
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: PUSH
54556: LD_INT 1
54558: PUSH
54559: LD_INT 1
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: PUSH
54566: LD_INT 0
54568: PUSH
54569: LD_INT 1
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PUSH
54576: LD_INT 1
54578: NEG
54579: PUSH
54580: LD_INT 0
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: PUSH
54587: LD_INT 1
54589: NEG
54590: PUSH
54591: LD_INT 1
54593: NEG
54594: PUSH
54595: EMPTY
54596: LIST
54597: LIST
54598: PUSH
54599: LD_INT 1
54601: NEG
54602: PUSH
54603: LD_INT 2
54605: NEG
54606: PUSH
54607: EMPTY
54608: LIST
54609: LIST
54610: PUSH
54611: LD_INT 0
54613: PUSH
54614: LD_INT 2
54616: NEG
54617: PUSH
54618: EMPTY
54619: LIST
54620: LIST
54621: PUSH
54622: LD_INT 1
54624: PUSH
54625: LD_INT 1
54627: NEG
54628: PUSH
54629: EMPTY
54630: LIST
54631: LIST
54632: PUSH
54633: LD_INT 2
54635: PUSH
54636: LD_INT 0
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: PUSH
54643: LD_INT 2
54645: PUSH
54646: LD_INT 1
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: PUSH
54653: EMPTY
54654: LIST
54655: LIST
54656: LIST
54657: LIST
54658: LIST
54659: LIST
54660: LIST
54661: LIST
54662: LIST
54663: LIST
54664: LIST
54665: LIST
54666: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
54667: LD_ADDR_VAR 0 49
54671: PUSH
54672: LD_INT 0
54674: PUSH
54675: LD_INT 0
54677: PUSH
54678: EMPTY
54679: LIST
54680: LIST
54681: PUSH
54682: LD_INT 0
54684: PUSH
54685: LD_INT 1
54687: NEG
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: PUSH
54693: LD_INT 1
54695: PUSH
54696: LD_INT 0
54698: PUSH
54699: EMPTY
54700: LIST
54701: LIST
54702: PUSH
54703: LD_INT 1
54705: PUSH
54706: LD_INT 1
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: PUSH
54713: LD_INT 0
54715: PUSH
54716: LD_INT 1
54718: PUSH
54719: EMPTY
54720: LIST
54721: LIST
54722: PUSH
54723: LD_INT 1
54725: NEG
54726: PUSH
54727: LD_INT 0
54729: PUSH
54730: EMPTY
54731: LIST
54732: LIST
54733: PUSH
54734: LD_INT 1
54736: NEG
54737: PUSH
54738: LD_INT 1
54740: NEG
54741: PUSH
54742: EMPTY
54743: LIST
54744: LIST
54745: PUSH
54746: LD_INT 1
54748: PUSH
54749: LD_INT 1
54751: NEG
54752: PUSH
54753: EMPTY
54754: LIST
54755: LIST
54756: PUSH
54757: LD_INT 2
54759: PUSH
54760: LD_INT 0
54762: PUSH
54763: EMPTY
54764: LIST
54765: LIST
54766: PUSH
54767: LD_INT 2
54769: PUSH
54770: LD_INT 1
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PUSH
54777: LD_INT 2
54779: PUSH
54780: LD_INT 2
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: PUSH
54787: LD_INT 1
54789: PUSH
54790: LD_INT 2
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: LIST
54801: LIST
54802: LIST
54803: LIST
54804: LIST
54805: LIST
54806: LIST
54807: LIST
54808: LIST
54809: LIST
54810: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
54811: LD_ADDR_VAR 0 50
54815: PUSH
54816: LD_INT 0
54818: PUSH
54819: LD_INT 0
54821: PUSH
54822: EMPTY
54823: LIST
54824: LIST
54825: PUSH
54826: LD_INT 0
54828: PUSH
54829: LD_INT 1
54831: NEG
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: PUSH
54837: LD_INT 1
54839: PUSH
54840: LD_INT 0
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: PUSH
54847: LD_INT 1
54849: PUSH
54850: LD_INT 1
54852: PUSH
54853: EMPTY
54854: LIST
54855: LIST
54856: PUSH
54857: LD_INT 0
54859: PUSH
54860: LD_INT 1
54862: PUSH
54863: EMPTY
54864: LIST
54865: LIST
54866: PUSH
54867: LD_INT 1
54869: NEG
54870: PUSH
54871: LD_INT 0
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: PUSH
54878: LD_INT 1
54880: NEG
54881: PUSH
54882: LD_INT 1
54884: NEG
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PUSH
54890: LD_INT 2
54892: PUSH
54893: LD_INT 1
54895: PUSH
54896: EMPTY
54897: LIST
54898: LIST
54899: PUSH
54900: LD_INT 2
54902: PUSH
54903: LD_INT 2
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: PUSH
54910: LD_INT 1
54912: PUSH
54913: LD_INT 2
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: PUSH
54920: LD_INT 0
54922: PUSH
54923: LD_INT 2
54925: PUSH
54926: EMPTY
54927: LIST
54928: LIST
54929: PUSH
54930: LD_INT 1
54932: NEG
54933: PUSH
54934: LD_INT 1
54936: PUSH
54937: EMPTY
54938: LIST
54939: LIST
54940: PUSH
54941: EMPTY
54942: LIST
54943: LIST
54944: LIST
54945: LIST
54946: LIST
54947: LIST
54948: LIST
54949: LIST
54950: LIST
54951: LIST
54952: LIST
54953: LIST
54954: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
54955: LD_ADDR_VAR 0 51
54959: PUSH
54960: LD_INT 0
54962: PUSH
54963: LD_INT 0
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: PUSH
54970: LD_INT 0
54972: PUSH
54973: LD_INT 1
54975: NEG
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: PUSH
54981: LD_INT 1
54983: PUSH
54984: LD_INT 0
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PUSH
54991: LD_INT 1
54993: PUSH
54994: LD_INT 1
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: PUSH
55001: LD_INT 0
55003: PUSH
55004: LD_INT 1
55006: PUSH
55007: EMPTY
55008: LIST
55009: LIST
55010: PUSH
55011: LD_INT 1
55013: NEG
55014: PUSH
55015: LD_INT 0
55017: PUSH
55018: EMPTY
55019: LIST
55020: LIST
55021: PUSH
55022: LD_INT 1
55024: NEG
55025: PUSH
55026: LD_INT 1
55028: NEG
55029: PUSH
55030: EMPTY
55031: LIST
55032: LIST
55033: PUSH
55034: LD_INT 1
55036: PUSH
55037: LD_INT 2
55039: PUSH
55040: EMPTY
55041: LIST
55042: LIST
55043: PUSH
55044: LD_INT 0
55046: PUSH
55047: LD_INT 2
55049: PUSH
55050: EMPTY
55051: LIST
55052: LIST
55053: PUSH
55054: LD_INT 1
55056: NEG
55057: PUSH
55058: LD_INT 1
55060: PUSH
55061: EMPTY
55062: LIST
55063: LIST
55064: PUSH
55065: LD_INT 2
55067: NEG
55068: PUSH
55069: LD_INT 0
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PUSH
55076: LD_INT 2
55078: NEG
55079: PUSH
55080: LD_INT 1
55082: NEG
55083: PUSH
55084: EMPTY
55085: LIST
55086: LIST
55087: PUSH
55088: EMPTY
55089: LIST
55090: LIST
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: LIST
55099: LIST
55100: LIST
55101: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55102: LD_ADDR_VAR 0 52
55106: PUSH
55107: LD_INT 0
55109: PUSH
55110: LD_INT 0
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: LD_INT 0
55119: PUSH
55120: LD_INT 1
55122: NEG
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: PUSH
55128: LD_INT 1
55130: PUSH
55131: LD_INT 0
55133: PUSH
55134: EMPTY
55135: LIST
55136: LIST
55137: PUSH
55138: LD_INT 1
55140: PUSH
55141: LD_INT 1
55143: PUSH
55144: EMPTY
55145: LIST
55146: LIST
55147: PUSH
55148: LD_INT 0
55150: PUSH
55151: LD_INT 1
55153: PUSH
55154: EMPTY
55155: LIST
55156: LIST
55157: PUSH
55158: LD_INT 1
55160: NEG
55161: PUSH
55162: LD_INT 0
55164: PUSH
55165: EMPTY
55166: LIST
55167: LIST
55168: PUSH
55169: LD_INT 1
55171: NEG
55172: PUSH
55173: LD_INT 1
55175: NEG
55176: PUSH
55177: EMPTY
55178: LIST
55179: LIST
55180: PUSH
55181: LD_INT 1
55183: NEG
55184: PUSH
55185: LD_INT 2
55187: NEG
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: PUSH
55193: LD_INT 1
55195: NEG
55196: PUSH
55197: LD_INT 1
55199: PUSH
55200: EMPTY
55201: LIST
55202: LIST
55203: PUSH
55204: LD_INT 2
55206: NEG
55207: PUSH
55208: LD_INT 0
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: PUSH
55215: LD_INT 2
55217: NEG
55218: PUSH
55219: LD_INT 1
55221: NEG
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: PUSH
55227: LD_INT 2
55229: NEG
55230: PUSH
55231: LD_INT 2
55233: NEG
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: PUSH
55239: EMPTY
55240: LIST
55241: LIST
55242: LIST
55243: LIST
55244: LIST
55245: LIST
55246: LIST
55247: LIST
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55253: LD_ADDR_VAR 0 53
55257: PUSH
55258: LD_INT 0
55260: PUSH
55261: LD_INT 0
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: PUSH
55268: LD_INT 0
55270: PUSH
55271: LD_INT 1
55273: NEG
55274: PUSH
55275: EMPTY
55276: LIST
55277: LIST
55278: PUSH
55279: LD_INT 1
55281: PUSH
55282: LD_INT 0
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: PUSH
55289: LD_INT 1
55291: PUSH
55292: LD_INT 1
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: PUSH
55299: LD_INT 0
55301: PUSH
55302: LD_INT 1
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: PUSH
55309: LD_INT 1
55311: NEG
55312: PUSH
55313: LD_INT 0
55315: PUSH
55316: EMPTY
55317: LIST
55318: LIST
55319: PUSH
55320: LD_INT 1
55322: NEG
55323: PUSH
55324: LD_INT 1
55326: NEG
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PUSH
55332: LD_INT 1
55334: NEG
55335: PUSH
55336: LD_INT 2
55338: NEG
55339: PUSH
55340: EMPTY
55341: LIST
55342: LIST
55343: PUSH
55344: LD_INT 0
55346: PUSH
55347: LD_INT 2
55349: NEG
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: PUSH
55355: LD_INT 1
55357: PUSH
55358: LD_INT 1
55360: NEG
55361: PUSH
55362: EMPTY
55363: LIST
55364: LIST
55365: PUSH
55366: LD_INT 2
55368: PUSH
55369: LD_INT 0
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: PUSH
55376: LD_INT 2
55378: PUSH
55379: LD_INT 1
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: PUSH
55386: LD_INT 2
55388: PUSH
55389: LD_INT 2
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PUSH
55396: LD_INT 1
55398: PUSH
55399: LD_INT 2
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: PUSH
55406: LD_INT 0
55408: PUSH
55409: LD_INT 2
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: PUSH
55416: LD_INT 1
55418: NEG
55419: PUSH
55420: LD_INT 1
55422: PUSH
55423: EMPTY
55424: LIST
55425: LIST
55426: PUSH
55427: LD_INT 2
55429: NEG
55430: PUSH
55431: LD_INT 0
55433: PUSH
55434: EMPTY
55435: LIST
55436: LIST
55437: PUSH
55438: LD_INT 2
55440: NEG
55441: PUSH
55442: LD_INT 1
55444: NEG
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: PUSH
55450: LD_INT 2
55452: NEG
55453: PUSH
55454: LD_INT 2
55456: NEG
55457: PUSH
55458: EMPTY
55459: LIST
55460: LIST
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: LIST
55466: LIST
55467: LIST
55468: LIST
55469: LIST
55470: LIST
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: LIST
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: LIST
55481: LIST
55482: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55483: LD_ADDR_VAR 0 54
55487: PUSH
55488: LD_INT 0
55490: PUSH
55491: LD_INT 0
55493: PUSH
55494: EMPTY
55495: LIST
55496: LIST
55497: PUSH
55498: LD_INT 0
55500: PUSH
55501: LD_INT 1
55503: NEG
55504: PUSH
55505: EMPTY
55506: LIST
55507: LIST
55508: PUSH
55509: LD_INT 1
55511: PUSH
55512: LD_INT 0
55514: PUSH
55515: EMPTY
55516: LIST
55517: LIST
55518: PUSH
55519: LD_INT 1
55521: PUSH
55522: LD_INT 1
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: PUSH
55529: LD_INT 0
55531: PUSH
55532: LD_INT 1
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: PUSH
55539: LD_INT 1
55541: NEG
55542: PUSH
55543: LD_INT 0
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: LD_INT 1
55552: NEG
55553: PUSH
55554: LD_INT 1
55556: NEG
55557: PUSH
55558: EMPTY
55559: LIST
55560: LIST
55561: PUSH
55562: LD_INT 1
55564: NEG
55565: PUSH
55566: LD_INT 2
55568: NEG
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: PUSH
55574: LD_INT 0
55576: PUSH
55577: LD_INT 2
55579: NEG
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 1
55587: PUSH
55588: LD_INT 1
55590: NEG
55591: PUSH
55592: EMPTY
55593: LIST
55594: LIST
55595: PUSH
55596: LD_INT 2
55598: PUSH
55599: LD_INT 0
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: PUSH
55606: LD_INT 2
55608: PUSH
55609: LD_INT 1
55611: PUSH
55612: EMPTY
55613: LIST
55614: LIST
55615: PUSH
55616: LD_INT 2
55618: PUSH
55619: LD_INT 2
55621: PUSH
55622: EMPTY
55623: LIST
55624: LIST
55625: PUSH
55626: LD_INT 1
55628: PUSH
55629: LD_INT 2
55631: PUSH
55632: EMPTY
55633: LIST
55634: LIST
55635: PUSH
55636: LD_INT 0
55638: PUSH
55639: LD_INT 2
55641: PUSH
55642: EMPTY
55643: LIST
55644: LIST
55645: PUSH
55646: LD_INT 1
55648: NEG
55649: PUSH
55650: LD_INT 1
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: PUSH
55657: LD_INT 2
55659: NEG
55660: PUSH
55661: LD_INT 0
55663: PUSH
55664: EMPTY
55665: LIST
55666: LIST
55667: PUSH
55668: LD_INT 2
55670: NEG
55671: PUSH
55672: LD_INT 1
55674: NEG
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: PUSH
55680: LD_INT 2
55682: NEG
55683: PUSH
55684: LD_INT 2
55686: NEG
55687: PUSH
55688: EMPTY
55689: LIST
55690: LIST
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: LIST
55696: LIST
55697: LIST
55698: LIST
55699: LIST
55700: LIST
55701: LIST
55702: LIST
55703: LIST
55704: LIST
55705: LIST
55706: LIST
55707: LIST
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55713: LD_ADDR_VAR 0 55
55717: PUSH
55718: LD_INT 0
55720: PUSH
55721: LD_INT 0
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PUSH
55728: LD_INT 0
55730: PUSH
55731: LD_INT 1
55733: NEG
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: PUSH
55739: LD_INT 1
55741: PUSH
55742: LD_INT 0
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: PUSH
55749: LD_INT 1
55751: PUSH
55752: LD_INT 1
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: PUSH
55759: LD_INT 0
55761: PUSH
55762: LD_INT 1
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: PUSH
55769: LD_INT 1
55771: NEG
55772: PUSH
55773: LD_INT 0
55775: PUSH
55776: EMPTY
55777: LIST
55778: LIST
55779: PUSH
55780: LD_INT 1
55782: NEG
55783: PUSH
55784: LD_INT 1
55786: NEG
55787: PUSH
55788: EMPTY
55789: LIST
55790: LIST
55791: PUSH
55792: LD_INT 1
55794: NEG
55795: PUSH
55796: LD_INT 2
55798: NEG
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: PUSH
55804: LD_INT 0
55806: PUSH
55807: LD_INT 2
55809: NEG
55810: PUSH
55811: EMPTY
55812: LIST
55813: LIST
55814: PUSH
55815: LD_INT 1
55817: PUSH
55818: LD_INT 1
55820: NEG
55821: PUSH
55822: EMPTY
55823: LIST
55824: LIST
55825: PUSH
55826: LD_INT 2
55828: PUSH
55829: LD_INT 0
55831: PUSH
55832: EMPTY
55833: LIST
55834: LIST
55835: PUSH
55836: LD_INT 2
55838: PUSH
55839: LD_INT 1
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: PUSH
55846: LD_INT 2
55848: PUSH
55849: LD_INT 2
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: PUSH
55856: LD_INT 1
55858: PUSH
55859: LD_INT 2
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: PUSH
55866: LD_INT 0
55868: PUSH
55869: LD_INT 2
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: PUSH
55876: LD_INT 1
55878: NEG
55879: PUSH
55880: LD_INT 1
55882: PUSH
55883: EMPTY
55884: LIST
55885: LIST
55886: PUSH
55887: LD_INT 2
55889: NEG
55890: PUSH
55891: LD_INT 0
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: PUSH
55898: LD_INT 2
55900: NEG
55901: PUSH
55902: LD_INT 1
55904: NEG
55905: PUSH
55906: EMPTY
55907: LIST
55908: LIST
55909: PUSH
55910: LD_INT 2
55912: NEG
55913: PUSH
55914: LD_INT 2
55916: NEG
55917: PUSH
55918: EMPTY
55919: LIST
55920: LIST
55921: PUSH
55922: EMPTY
55923: LIST
55924: LIST
55925: LIST
55926: LIST
55927: LIST
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: LIST
55933: LIST
55934: LIST
55935: LIST
55936: LIST
55937: LIST
55938: LIST
55939: LIST
55940: LIST
55941: LIST
55942: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55943: LD_ADDR_VAR 0 56
55947: PUSH
55948: LD_INT 0
55950: PUSH
55951: LD_INT 0
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PUSH
55958: LD_INT 0
55960: PUSH
55961: LD_INT 1
55963: NEG
55964: PUSH
55965: EMPTY
55966: LIST
55967: LIST
55968: PUSH
55969: LD_INT 1
55971: PUSH
55972: LD_INT 0
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: PUSH
55979: LD_INT 1
55981: PUSH
55982: LD_INT 1
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: PUSH
55989: LD_INT 0
55991: PUSH
55992: LD_INT 1
55994: PUSH
55995: EMPTY
55996: LIST
55997: LIST
55998: PUSH
55999: LD_INT 1
56001: NEG
56002: PUSH
56003: LD_INT 0
56005: PUSH
56006: EMPTY
56007: LIST
56008: LIST
56009: PUSH
56010: LD_INT 1
56012: NEG
56013: PUSH
56014: LD_INT 1
56016: NEG
56017: PUSH
56018: EMPTY
56019: LIST
56020: LIST
56021: PUSH
56022: LD_INT 1
56024: NEG
56025: PUSH
56026: LD_INT 2
56028: NEG
56029: PUSH
56030: EMPTY
56031: LIST
56032: LIST
56033: PUSH
56034: LD_INT 0
56036: PUSH
56037: LD_INT 2
56039: NEG
56040: PUSH
56041: EMPTY
56042: LIST
56043: LIST
56044: PUSH
56045: LD_INT 1
56047: PUSH
56048: LD_INT 1
56050: NEG
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PUSH
56056: LD_INT 2
56058: PUSH
56059: LD_INT 0
56061: PUSH
56062: EMPTY
56063: LIST
56064: LIST
56065: PUSH
56066: LD_INT 2
56068: PUSH
56069: LD_INT 1
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: PUSH
56076: LD_INT 2
56078: PUSH
56079: LD_INT 2
56081: PUSH
56082: EMPTY
56083: LIST
56084: LIST
56085: PUSH
56086: LD_INT 1
56088: PUSH
56089: LD_INT 2
56091: PUSH
56092: EMPTY
56093: LIST
56094: LIST
56095: PUSH
56096: LD_INT 0
56098: PUSH
56099: LD_INT 2
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PUSH
56106: LD_INT 1
56108: NEG
56109: PUSH
56110: LD_INT 1
56112: PUSH
56113: EMPTY
56114: LIST
56115: LIST
56116: PUSH
56117: LD_INT 2
56119: NEG
56120: PUSH
56121: LD_INT 0
56123: PUSH
56124: EMPTY
56125: LIST
56126: LIST
56127: PUSH
56128: LD_INT 2
56130: NEG
56131: PUSH
56132: LD_INT 1
56134: NEG
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: PUSH
56140: LD_INT 2
56142: NEG
56143: PUSH
56144: LD_INT 2
56146: NEG
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: LIST
56156: LIST
56157: LIST
56158: LIST
56159: LIST
56160: LIST
56161: LIST
56162: LIST
56163: LIST
56164: LIST
56165: LIST
56166: LIST
56167: LIST
56168: LIST
56169: LIST
56170: LIST
56171: LIST
56172: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56173: LD_ADDR_VAR 0 57
56177: PUSH
56178: LD_INT 0
56180: PUSH
56181: LD_INT 0
56183: PUSH
56184: EMPTY
56185: LIST
56186: LIST
56187: PUSH
56188: LD_INT 0
56190: PUSH
56191: LD_INT 1
56193: NEG
56194: PUSH
56195: EMPTY
56196: LIST
56197: LIST
56198: PUSH
56199: LD_INT 1
56201: PUSH
56202: LD_INT 0
56204: PUSH
56205: EMPTY
56206: LIST
56207: LIST
56208: PUSH
56209: LD_INT 1
56211: PUSH
56212: LD_INT 1
56214: PUSH
56215: EMPTY
56216: LIST
56217: LIST
56218: PUSH
56219: LD_INT 0
56221: PUSH
56222: LD_INT 1
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: PUSH
56229: LD_INT 1
56231: NEG
56232: PUSH
56233: LD_INT 0
56235: PUSH
56236: EMPTY
56237: LIST
56238: LIST
56239: PUSH
56240: LD_INT 1
56242: NEG
56243: PUSH
56244: LD_INT 1
56246: NEG
56247: PUSH
56248: EMPTY
56249: LIST
56250: LIST
56251: PUSH
56252: LD_INT 1
56254: NEG
56255: PUSH
56256: LD_INT 2
56258: NEG
56259: PUSH
56260: EMPTY
56261: LIST
56262: LIST
56263: PUSH
56264: LD_INT 0
56266: PUSH
56267: LD_INT 2
56269: NEG
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: PUSH
56275: LD_INT 1
56277: PUSH
56278: LD_INT 1
56280: NEG
56281: PUSH
56282: EMPTY
56283: LIST
56284: LIST
56285: PUSH
56286: LD_INT 2
56288: PUSH
56289: LD_INT 0
56291: PUSH
56292: EMPTY
56293: LIST
56294: LIST
56295: PUSH
56296: LD_INT 2
56298: PUSH
56299: LD_INT 1
56301: PUSH
56302: EMPTY
56303: LIST
56304: LIST
56305: PUSH
56306: LD_INT 2
56308: PUSH
56309: LD_INT 2
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: PUSH
56316: LD_INT 1
56318: PUSH
56319: LD_INT 2
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PUSH
56326: LD_INT 0
56328: PUSH
56329: LD_INT 2
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: PUSH
56336: LD_INT 1
56338: NEG
56339: PUSH
56340: LD_INT 1
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: PUSH
56347: LD_INT 2
56349: NEG
56350: PUSH
56351: LD_INT 0
56353: PUSH
56354: EMPTY
56355: LIST
56356: LIST
56357: PUSH
56358: LD_INT 2
56360: NEG
56361: PUSH
56362: LD_INT 1
56364: NEG
56365: PUSH
56366: EMPTY
56367: LIST
56368: LIST
56369: PUSH
56370: LD_INT 2
56372: NEG
56373: PUSH
56374: LD_INT 2
56376: NEG
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: LIST
56386: LIST
56387: LIST
56388: LIST
56389: LIST
56390: LIST
56391: LIST
56392: LIST
56393: LIST
56394: LIST
56395: LIST
56396: LIST
56397: LIST
56398: LIST
56399: LIST
56400: LIST
56401: LIST
56402: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56403: LD_ADDR_VAR 0 58
56407: PUSH
56408: LD_INT 0
56410: PUSH
56411: LD_INT 0
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: PUSH
56418: LD_INT 0
56420: PUSH
56421: LD_INT 1
56423: NEG
56424: PUSH
56425: EMPTY
56426: LIST
56427: LIST
56428: PUSH
56429: LD_INT 1
56431: PUSH
56432: LD_INT 0
56434: PUSH
56435: EMPTY
56436: LIST
56437: LIST
56438: PUSH
56439: LD_INT 1
56441: PUSH
56442: LD_INT 1
56444: PUSH
56445: EMPTY
56446: LIST
56447: LIST
56448: PUSH
56449: LD_INT 0
56451: PUSH
56452: LD_INT 1
56454: PUSH
56455: EMPTY
56456: LIST
56457: LIST
56458: PUSH
56459: LD_INT 1
56461: NEG
56462: PUSH
56463: LD_INT 0
56465: PUSH
56466: EMPTY
56467: LIST
56468: LIST
56469: PUSH
56470: LD_INT 1
56472: NEG
56473: PUSH
56474: LD_INT 1
56476: NEG
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: PUSH
56482: LD_INT 1
56484: NEG
56485: PUSH
56486: LD_INT 2
56488: NEG
56489: PUSH
56490: EMPTY
56491: LIST
56492: LIST
56493: PUSH
56494: LD_INT 0
56496: PUSH
56497: LD_INT 2
56499: NEG
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: PUSH
56505: LD_INT 1
56507: PUSH
56508: LD_INT 1
56510: NEG
56511: PUSH
56512: EMPTY
56513: LIST
56514: LIST
56515: PUSH
56516: LD_INT 2
56518: PUSH
56519: LD_INT 0
56521: PUSH
56522: EMPTY
56523: LIST
56524: LIST
56525: PUSH
56526: LD_INT 2
56528: PUSH
56529: LD_INT 1
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: PUSH
56536: LD_INT 2
56538: PUSH
56539: LD_INT 2
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: PUSH
56546: LD_INT 1
56548: PUSH
56549: LD_INT 2
56551: PUSH
56552: EMPTY
56553: LIST
56554: LIST
56555: PUSH
56556: LD_INT 0
56558: PUSH
56559: LD_INT 2
56561: PUSH
56562: EMPTY
56563: LIST
56564: LIST
56565: PUSH
56566: LD_INT 1
56568: NEG
56569: PUSH
56570: LD_INT 1
56572: PUSH
56573: EMPTY
56574: LIST
56575: LIST
56576: PUSH
56577: LD_INT 2
56579: NEG
56580: PUSH
56581: LD_INT 0
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: PUSH
56588: LD_INT 2
56590: NEG
56591: PUSH
56592: LD_INT 1
56594: NEG
56595: PUSH
56596: EMPTY
56597: LIST
56598: LIST
56599: PUSH
56600: LD_INT 2
56602: NEG
56603: PUSH
56604: LD_INT 2
56606: NEG
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: LIST
56616: LIST
56617: LIST
56618: LIST
56619: LIST
56620: LIST
56621: LIST
56622: LIST
56623: LIST
56624: LIST
56625: LIST
56626: LIST
56627: LIST
56628: LIST
56629: LIST
56630: LIST
56631: LIST
56632: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
56633: LD_ADDR_VAR 0 59
56637: PUSH
56638: LD_INT 0
56640: PUSH
56641: LD_INT 0
56643: PUSH
56644: EMPTY
56645: LIST
56646: LIST
56647: PUSH
56648: LD_INT 0
56650: PUSH
56651: LD_INT 1
56653: NEG
56654: PUSH
56655: EMPTY
56656: LIST
56657: LIST
56658: PUSH
56659: LD_INT 1
56661: PUSH
56662: LD_INT 0
56664: PUSH
56665: EMPTY
56666: LIST
56667: LIST
56668: PUSH
56669: LD_INT 1
56671: PUSH
56672: LD_INT 1
56674: PUSH
56675: EMPTY
56676: LIST
56677: LIST
56678: PUSH
56679: LD_INT 0
56681: PUSH
56682: LD_INT 1
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: PUSH
56689: LD_INT 1
56691: NEG
56692: PUSH
56693: LD_INT 0
56695: PUSH
56696: EMPTY
56697: LIST
56698: LIST
56699: PUSH
56700: LD_INT 1
56702: NEG
56703: PUSH
56704: LD_INT 1
56706: NEG
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: LIST
56716: LIST
56717: LIST
56718: LIST
56719: LIST
56720: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
56721: LD_ADDR_VAR 0 60
56725: PUSH
56726: LD_INT 0
56728: PUSH
56729: LD_INT 0
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: PUSH
56736: LD_INT 0
56738: PUSH
56739: LD_INT 1
56741: NEG
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: PUSH
56747: LD_INT 1
56749: PUSH
56750: LD_INT 0
56752: PUSH
56753: EMPTY
56754: LIST
56755: LIST
56756: PUSH
56757: LD_INT 1
56759: PUSH
56760: LD_INT 1
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: PUSH
56767: LD_INT 0
56769: PUSH
56770: LD_INT 1
56772: PUSH
56773: EMPTY
56774: LIST
56775: LIST
56776: PUSH
56777: LD_INT 1
56779: NEG
56780: PUSH
56781: LD_INT 0
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: PUSH
56788: LD_INT 1
56790: NEG
56791: PUSH
56792: LD_INT 1
56794: NEG
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: LIST
56804: LIST
56805: LIST
56806: LIST
56807: LIST
56808: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
56809: LD_ADDR_VAR 0 61
56813: PUSH
56814: LD_INT 0
56816: PUSH
56817: LD_INT 0
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: PUSH
56824: LD_INT 0
56826: PUSH
56827: LD_INT 1
56829: NEG
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: PUSH
56835: LD_INT 1
56837: PUSH
56838: LD_INT 0
56840: PUSH
56841: EMPTY
56842: LIST
56843: LIST
56844: PUSH
56845: LD_INT 1
56847: PUSH
56848: LD_INT 1
56850: PUSH
56851: EMPTY
56852: LIST
56853: LIST
56854: PUSH
56855: LD_INT 0
56857: PUSH
56858: LD_INT 1
56860: PUSH
56861: EMPTY
56862: LIST
56863: LIST
56864: PUSH
56865: LD_INT 1
56867: NEG
56868: PUSH
56869: LD_INT 0
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: PUSH
56876: LD_INT 1
56878: NEG
56879: PUSH
56880: LD_INT 1
56882: NEG
56883: PUSH
56884: EMPTY
56885: LIST
56886: LIST
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: LIST
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
56897: LD_ADDR_VAR 0 62
56901: PUSH
56902: LD_INT 0
56904: PUSH
56905: LD_INT 0
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PUSH
56912: LD_INT 0
56914: PUSH
56915: LD_INT 1
56917: NEG
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: PUSH
56923: LD_INT 1
56925: PUSH
56926: LD_INT 0
56928: PUSH
56929: EMPTY
56930: LIST
56931: LIST
56932: PUSH
56933: LD_INT 1
56935: PUSH
56936: LD_INT 1
56938: PUSH
56939: EMPTY
56940: LIST
56941: LIST
56942: PUSH
56943: LD_INT 0
56945: PUSH
56946: LD_INT 1
56948: PUSH
56949: EMPTY
56950: LIST
56951: LIST
56952: PUSH
56953: LD_INT 1
56955: NEG
56956: PUSH
56957: LD_INT 0
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: PUSH
56964: LD_INT 1
56966: NEG
56967: PUSH
56968: LD_INT 1
56970: NEG
56971: PUSH
56972: EMPTY
56973: LIST
56974: LIST
56975: PUSH
56976: EMPTY
56977: LIST
56978: LIST
56979: LIST
56980: LIST
56981: LIST
56982: LIST
56983: LIST
56984: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
56985: LD_ADDR_VAR 0 63
56989: PUSH
56990: LD_INT 0
56992: PUSH
56993: LD_INT 0
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: PUSH
57000: LD_INT 0
57002: PUSH
57003: LD_INT 1
57005: NEG
57006: PUSH
57007: EMPTY
57008: LIST
57009: LIST
57010: PUSH
57011: LD_INT 1
57013: PUSH
57014: LD_INT 0
57016: PUSH
57017: EMPTY
57018: LIST
57019: LIST
57020: PUSH
57021: LD_INT 1
57023: PUSH
57024: LD_INT 1
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: PUSH
57031: LD_INT 0
57033: PUSH
57034: LD_INT 1
57036: PUSH
57037: EMPTY
57038: LIST
57039: LIST
57040: PUSH
57041: LD_INT 1
57043: NEG
57044: PUSH
57045: LD_INT 0
57047: PUSH
57048: EMPTY
57049: LIST
57050: LIST
57051: PUSH
57052: LD_INT 1
57054: NEG
57055: PUSH
57056: LD_INT 1
57058: NEG
57059: PUSH
57060: EMPTY
57061: LIST
57062: LIST
57063: PUSH
57064: EMPTY
57065: LIST
57066: LIST
57067: LIST
57068: LIST
57069: LIST
57070: LIST
57071: LIST
57072: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57073: LD_ADDR_VAR 0 64
57077: PUSH
57078: LD_INT 0
57080: PUSH
57081: LD_INT 0
57083: PUSH
57084: EMPTY
57085: LIST
57086: LIST
57087: PUSH
57088: LD_INT 0
57090: PUSH
57091: LD_INT 1
57093: NEG
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: PUSH
57099: LD_INT 1
57101: PUSH
57102: LD_INT 0
57104: PUSH
57105: EMPTY
57106: LIST
57107: LIST
57108: PUSH
57109: LD_INT 1
57111: PUSH
57112: LD_INT 1
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PUSH
57119: LD_INT 0
57121: PUSH
57122: LD_INT 1
57124: PUSH
57125: EMPTY
57126: LIST
57127: LIST
57128: PUSH
57129: LD_INT 1
57131: NEG
57132: PUSH
57133: LD_INT 0
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PUSH
57140: LD_INT 1
57142: NEG
57143: PUSH
57144: LD_INT 1
57146: NEG
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: LIST
57156: LIST
57157: LIST
57158: LIST
57159: LIST
57160: ST_TO_ADDR
// end ; 1 :
57161: GO 63058
57163: LD_INT 1
57165: DOUBLE
57166: EQUAL
57167: IFTRUE 57171
57169: GO 59794
57171: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
57172: LD_ADDR_VAR 0 11
57176: PUSH
57177: LD_INT 1
57179: NEG
57180: PUSH
57181: LD_INT 3
57183: NEG
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: PUSH
57189: LD_INT 0
57191: PUSH
57192: LD_INT 3
57194: NEG
57195: PUSH
57196: EMPTY
57197: LIST
57198: LIST
57199: PUSH
57200: LD_INT 1
57202: PUSH
57203: LD_INT 2
57205: NEG
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: LIST
57215: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
57216: LD_ADDR_VAR 0 12
57220: PUSH
57221: LD_INT 2
57223: PUSH
57224: LD_INT 1
57226: NEG
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 3
57234: PUSH
57235: LD_INT 0
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: LD_INT 3
57244: PUSH
57245: LD_INT 1
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: LIST
57256: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
57257: LD_ADDR_VAR 0 13
57261: PUSH
57262: LD_INT 3
57264: PUSH
57265: LD_INT 2
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PUSH
57272: LD_INT 3
57274: PUSH
57275: LD_INT 3
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: PUSH
57282: LD_INT 2
57284: PUSH
57285: LD_INT 3
57287: PUSH
57288: EMPTY
57289: LIST
57290: LIST
57291: PUSH
57292: EMPTY
57293: LIST
57294: LIST
57295: LIST
57296: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
57297: LD_ADDR_VAR 0 14
57301: PUSH
57302: LD_INT 1
57304: PUSH
57305: LD_INT 3
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: PUSH
57312: LD_INT 0
57314: PUSH
57315: LD_INT 3
57317: PUSH
57318: EMPTY
57319: LIST
57320: LIST
57321: PUSH
57322: LD_INT 1
57324: NEG
57325: PUSH
57326: LD_INT 2
57328: PUSH
57329: EMPTY
57330: LIST
57331: LIST
57332: PUSH
57333: EMPTY
57334: LIST
57335: LIST
57336: LIST
57337: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
57338: LD_ADDR_VAR 0 15
57342: PUSH
57343: LD_INT 2
57345: NEG
57346: PUSH
57347: LD_INT 1
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: PUSH
57354: LD_INT 3
57356: NEG
57357: PUSH
57358: LD_INT 0
57360: PUSH
57361: EMPTY
57362: LIST
57363: LIST
57364: PUSH
57365: LD_INT 3
57367: NEG
57368: PUSH
57369: LD_INT 1
57371: NEG
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: LIST
57381: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
57382: LD_ADDR_VAR 0 16
57386: PUSH
57387: LD_INT 2
57389: NEG
57390: PUSH
57391: LD_INT 3
57393: NEG
57394: PUSH
57395: EMPTY
57396: LIST
57397: LIST
57398: PUSH
57399: LD_INT 3
57401: NEG
57402: PUSH
57403: LD_INT 2
57405: NEG
57406: PUSH
57407: EMPTY
57408: LIST
57409: LIST
57410: PUSH
57411: LD_INT 3
57413: NEG
57414: PUSH
57415: LD_INT 3
57417: NEG
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: LIST
57427: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
57428: LD_ADDR_VAR 0 17
57432: PUSH
57433: LD_INT 1
57435: NEG
57436: PUSH
57437: LD_INT 3
57439: NEG
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: PUSH
57445: LD_INT 0
57447: PUSH
57448: LD_INT 3
57450: NEG
57451: PUSH
57452: EMPTY
57453: LIST
57454: LIST
57455: PUSH
57456: LD_INT 1
57458: PUSH
57459: LD_INT 2
57461: NEG
57462: PUSH
57463: EMPTY
57464: LIST
57465: LIST
57466: PUSH
57467: EMPTY
57468: LIST
57469: LIST
57470: LIST
57471: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
57472: LD_ADDR_VAR 0 18
57476: PUSH
57477: LD_INT 2
57479: PUSH
57480: LD_INT 1
57482: NEG
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 3
57490: PUSH
57491: LD_INT 0
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: PUSH
57498: LD_INT 3
57500: PUSH
57501: LD_INT 1
57503: PUSH
57504: EMPTY
57505: LIST
57506: LIST
57507: PUSH
57508: EMPTY
57509: LIST
57510: LIST
57511: LIST
57512: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
57513: LD_ADDR_VAR 0 19
57517: PUSH
57518: LD_INT 3
57520: PUSH
57521: LD_INT 2
57523: PUSH
57524: EMPTY
57525: LIST
57526: LIST
57527: PUSH
57528: LD_INT 3
57530: PUSH
57531: LD_INT 3
57533: PUSH
57534: EMPTY
57535: LIST
57536: LIST
57537: PUSH
57538: LD_INT 2
57540: PUSH
57541: LD_INT 3
57543: PUSH
57544: EMPTY
57545: LIST
57546: LIST
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: LIST
57552: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
57553: LD_ADDR_VAR 0 20
57557: PUSH
57558: LD_INT 1
57560: PUSH
57561: LD_INT 3
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: PUSH
57568: LD_INT 0
57570: PUSH
57571: LD_INT 3
57573: PUSH
57574: EMPTY
57575: LIST
57576: LIST
57577: PUSH
57578: LD_INT 1
57580: NEG
57581: PUSH
57582: LD_INT 2
57584: PUSH
57585: EMPTY
57586: LIST
57587: LIST
57588: PUSH
57589: EMPTY
57590: LIST
57591: LIST
57592: LIST
57593: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
57594: LD_ADDR_VAR 0 21
57598: PUSH
57599: LD_INT 2
57601: NEG
57602: PUSH
57603: LD_INT 1
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: PUSH
57610: LD_INT 3
57612: NEG
57613: PUSH
57614: LD_INT 0
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: PUSH
57621: LD_INT 3
57623: NEG
57624: PUSH
57625: LD_INT 1
57627: NEG
57628: PUSH
57629: EMPTY
57630: LIST
57631: LIST
57632: PUSH
57633: EMPTY
57634: LIST
57635: LIST
57636: LIST
57637: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
57638: LD_ADDR_VAR 0 22
57642: PUSH
57643: LD_INT 2
57645: NEG
57646: PUSH
57647: LD_INT 3
57649: NEG
57650: PUSH
57651: EMPTY
57652: LIST
57653: LIST
57654: PUSH
57655: LD_INT 3
57657: NEG
57658: PUSH
57659: LD_INT 2
57661: NEG
57662: PUSH
57663: EMPTY
57664: LIST
57665: LIST
57666: PUSH
57667: LD_INT 3
57669: NEG
57670: PUSH
57671: LD_INT 3
57673: NEG
57674: PUSH
57675: EMPTY
57676: LIST
57677: LIST
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: LIST
57683: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
57684: LD_ADDR_VAR 0 23
57688: PUSH
57689: LD_INT 0
57691: PUSH
57692: LD_INT 3
57694: NEG
57695: PUSH
57696: EMPTY
57697: LIST
57698: LIST
57699: PUSH
57700: LD_INT 1
57702: NEG
57703: PUSH
57704: LD_INT 4
57706: NEG
57707: PUSH
57708: EMPTY
57709: LIST
57710: LIST
57711: PUSH
57712: LD_INT 1
57714: PUSH
57715: LD_INT 3
57717: NEG
57718: PUSH
57719: EMPTY
57720: LIST
57721: LIST
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: LIST
57727: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
57728: LD_ADDR_VAR 0 24
57732: PUSH
57733: LD_INT 3
57735: PUSH
57736: LD_INT 0
57738: PUSH
57739: EMPTY
57740: LIST
57741: LIST
57742: PUSH
57743: LD_INT 3
57745: PUSH
57746: LD_INT 1
57748: NEG
57749: PUSH
57750: EMPTY
57751: LIST
57752: LIST
57753: PUSH
57754: LD_INT 4
57756: PUSH
57757: LD_INT 1
57759: PUSH
57760: EMPTY
57761: LIST
57762: LIST
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: LIST
57768: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
57769: LD_ADDR_VAR 0 25
57773: PUSH
57774: LD_INT 3
57776: PUSH
57777: LD_INT 3
57779: PUSH
57780: EMPTY
57781: LIST
57782: LIST
57783: PUSH
57784: LD_INT 4
57786: PUSH
57787: LD_INT 3
57789: PUSH
57790: EMPTY
57791: LIST
57792: LIST
57793: PUSH
57794: LD_INT 3
57796: PUSH
57797: LD_INT 4
57799: PUSH
57800: EMPTY
57801: LIST
57802: LIST
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: LIST
57808: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
57809: LD_ADDR_VAR 0 26
57813: PUSH
57814: LD_INT 0
57816: PUSH
57817: LD_INT 3
57819: PUSH
57820: EMPTY
57821: LIST
57822: LIST
57823: PUSH
57824: LD_INT 1
57826: PUSH
57827: LD_INT 4
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: PUSH
57834: LD_INT 1
57836: NEG
57837: PUSH
57838: LD_INT 3
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PUSH
57845: EMPTY
57846: LIST
57847: LIST
57848: LIST
57849: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
57850: LD_ADDR_VAR 0 27
57854: PUSH
57855: LD_INT 3
57857: NEG
57858: PUSH
57859: LD_INT 0
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: PUSH
57866: LD_INT 3
57868: NEG
57869: PUSH
57870: LD_INT 1
57872: PUSH
57873: EMPTY
57874: LIST
57875: LIST
57876: PUSH
57877: LD_INT 4
57879: NEG
57880: PUSH
57881: LD_INT 1
57883: NEG
57884: PUSH
57885: EMPTY
57886: LIST
57887: LIST
57888: PUSH
57889: EMPTY
57890: LIST
57891: LIST
57892: LIST
57893: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
57894: LD_ADDR_VAR 0 28
57898: PUSH
57899: LD_INT 3
57901: NEG
57902: PUSH
57903: LD_INT 3
57905: NEG
57906: PUSH
57907: EMPTY
57908: LIST
57909: LIST
57910: PUSH
57911: LD_INT 3
57913: NEG
57914: PUSH
57915: LD_INT 4
57917: NEG
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: LD_INT 4
57925: NEG
57926: PUSH
57927: LD_INT 3
57929: NEG
57930: PUSH
57931: EMPTY
57932: LIST
57933: LIST
57934: PUSH
57935: EMPTY
57936: LIST
57937: LIST
57938: LIST
57939: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
57940: LD_ADDR_VAR 0 29
57944: PUSH
57945: LD_INT 1
57947: NEG
57948: PUSH
57949: LD_INT 3
57951: NEG
57952: PUSH
57953: EMPTY
57954: LIST
57955: LIST
57956: PUSH
57957: LD_INT 0
57959: PUSH
57960: LD_INT 3
57962: NEG
57963: PUSH
57964: EMPTY
57965: LIST
57966: LIST
57967: PUSH
57968: LD_INT 1
57970: PUSH
57971: LD_INT 2
57973: NEG
57974: PUSH
57975: EMPTY
57976: LIST
57977: LIST
57978: PUSH
57979: LD_INT 1
57981: NEG
57982: PUSH
57983: LD_INT 4
57985: NEG
57986: PUSH
57987: EMPTY
57988: LIST
57989: LIST
57990: PUSH
57991: LD_INT 0
57993: PUSH
57994: LD_INT 4
57996: NEG
57997: PUSH
57998: EMPTY
57999: LIST
58000: LIST
58001: PUSH
58002: LD_INT 1
58004: PUSH
58005: LD_INT 3
58007: NEG
58008: PUSH
58009: EMPTY
58010: LIST
58011: LIST
58012: PUSH
58013: LD_INT 1
58015: NEG
58016: PUSH
58017: LD_INT 5
58019: NEG
58020: PUSH
58021: EMPTY
58022: LIST
58023: LIST
58024: PUSH
58025: LD_INT 0
58027: PUSH
58028: LD_INT 5
58030: NEG
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: PUSH
58036: LD_INT 1
58038: PUSH
58039: LD_INT 4
58041: NEG
58042: PUSH
58043: EMPTY
58044: LIST
58045: LIST
58046: PUSH
58047: LD_INT 1
58049: NEG
58050: PUSH
58051: LD_INT 6
58053: NEG
58054: PUSH
58055: EMPTY
58056: LIST
58057: LIST
58058: PUSH
58059: LD_INT 0
58061: PUSH
58062: LD_INT 6
58064: NEG
58065: PUSH
58066: EMPTY
58067: LIST
58068: LIST
58069: PUSH
58070: LD_INT 1
58072: PUSH
58073: LD_INT 5
58075: NEG
58076: PUSH
58077: EMPTY
58078: LIST
58079: LIST
58080: PUSH
58081: EMPTY
58082: LIST
58083: LIST
58084: LIST
58085: LIST
58086: LIST
58087: LIST
58088: LIST
58089: LIST
58090: LIST
58091: LIST
58092: LIST
58093: LIST
58094: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
58095: LD_ADDR_VAR 0 30
58099: PUSH
58100: LD_INT 2
58102: PUSH
58103: LD_INT 1
58105: NEG
58106: PUSH
58107: EMPTY
58108: LIST
58109: LIST
58110: PUSH
58111: LD_INT 3
58113: PUSH
58114: LD_INT 0
58116: PUSH
58117: EMPTY
58118: LIST
58119: LIST
58120: PUSH
58121: LD_INT 3
58123: PUSH
58124: LD_INT 1
58126: PUSH
58127: EMPTY
58128: LIST
58129: LIST
58130: PUSH
58131: LD_INT 3
58133: PUSH
58134: LD_INT 1
58136: NEG
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: PUSH
58142: LD_INT 4
58144: PUSH
58145: LD_INT 0
58147: PUSH
58148: EMPTY
58149: LIST
58150: LIST
58151: PUSH
58152: LD_INT 4
58154: PUSH
58155: LD_INT 1
58157: PUSH
58158: EMPTY
58159: LIST
58160: LIST
58161: PUSH
58162: LD_INT 4
58164: PUSH
58165: LD_INT 1
58167: NEG
58168: PUSH
58169: EMPTY
58170: LIST
58171: LIST
58172: PUSH
58173: LD_INT 5
58175: PUSH
58176: LD_INT 0
58178: PUSH
58179: EMPTY
58180: LIST
58181: LIST
58182: PUSH
58183: LD_INT 5
58185: PUSH
58186: LD_INT 1
58188: PUSH
58189: EMPTY
58190: LIST
58191: LIST
58192: PUSH
58193: LD_INT 5
58195: PUSH
58196: LD_INT 1
58198: NEG
58199: PUSH
58200: EMPTY
58201: LIST
58202: LIST
58203: PUSH
58204: LD_INT 6
58206: PUSH
58207: LD_INT 0
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: PUSH
58214: LD_INT 6
58216: PUSH
58217: LD_INT 1
58219: PUSH
58220: EMPTY
58221: LIST
58222: LIST
58223: PUSH
58224: EMPTY
58225: LIST
58226: LIST
58227: LIST
58228: LIST
58229: LIST
58230: LIST
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: LIST
58236: LIST
58237: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
58238: LD_ADDR_VAR 0 31
58242: PUSH
58243: LD_INT 3
58245: PUSH
58246: LD_INT 2
58248: PUSH
58249: EMPTY
58250: LIST
58251: LIST
58252: PUSH
58253: LD_INT 3
58255: PUSH
58256: LD_INT 3
58258: PUSH
58259: EMPTY
58260: LIST
58261: LIST
58262: PUSH
58263: LD_INT 2
58265: PUSH
58266: LD_INT 3
58268: PUSH
58269: EMPTY
58270: LIST
58271: LIST
58272: PUSH
58273: LD_INT 4
58275: PUSH
58276: LD_INT 3
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: PUSH
58283: LD_INT 4
58285: PUSH
58286: LD_INT 4
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: PUSH
58293: LD_INT 3
58295: PUSH
58296: LD_INT 4
58298: PUSH
58299: EMPTY
58300: LIST
58301: LIST
58302: PUSH
58303: LD_INT 5
58305: PUSH
58306: LD_INT 4
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: PUSH
58313: LD_INT 5
58315: PUSH
58316: LD_INT 5
58318: PUSH
58319: EMPTY
58320: LIST
58321: LIST
58322: PUSH
58323: LD_INT 4
58325: PUSH
58326: LD_INT 5
58328: PUSH
58329: EMPTY
58330: LIST
58331: LIST
58332: PUSH
58333: LD_INT 6
58335: PUSH
58336: LD_INT 5
58338: PUSH
58339: EMPTY
58340: LIST
58341: LIST
58342: PUSH
58343: LD_INT 6
58345: PUSH
58346: LD_INT 6
58348: PUSH
58349: EMPTY
58350: LIST
58351: LIST
58352: PUSH
58353: LD_INT 5
58355: PUSH
58356: LD_INT 6
58358: PUSH
58359: EMPTY
58360: LIST
58361: LIST
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: LIST
58367: LIST
58368: LIST
58369: LIST
58370: LIST
58371: LIST
58372: LIST
58373: LIST
58374: LIST
58375: LIST
58376: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
58377: LD_ADDR_VAR 0 32
58381: PUSH
58382: LD_INT 1
58384: PUSH
58385: LD_INT 3
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PUSH
58392: LD_INT 0
58394: PUSH
58395: LD_INT 3
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: PUSH
58402: LD_INT 1
58404: NEG
58405: PUSH
58406: LD_INT 2
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: PUSH
58413: LD_INT 1
58415: PUSH
58416: LD_INT 4
58418: PUSH
58419: EMPTY
58420: LIST
58421: LIST
58422: PUSH
58423: LD_INT 0
58425: PUSH
58426: LD_INT 4
58428: PUSH
58429: EMPTY
58430: LIST
58431: LIST
58432: PUSH
58433: LD_INT 1
58435: NEG
58436: PUSH
58437: LD_INT 3
58439: PUSH
58440: EMPTY
58441: LIST
58442: LIST
58443: PUSH
58444: LD_INT 1
58446: PUSH
58447: LD_INT 5
58449: PUSH
58450: EMPTY
58451: LIST
58452: LIST
58453: PUSH
58454: LD_INT 0
58456: PUSH
58457: LD_INT 5
58459: PUSH
58460: EMPTY
58461: LIST
58462: LIST
58463: PUSH
58464: LD_INT 1
58466: NEG
58467: PUSH
58468: LD_INT 4
58470: PUSH
58471: EMPTY
58472: LIST
58473: LIST
58474: PUSH
58475: LD_INT 1
58477: PUSH
58478: LD_INT 6
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: PUSH
58485: LD_INT 0
58487: PUSH
58488: LD_INT 6
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: PUSH
58495: LD_INT 1
58497: NEG
58498: PUSH
58499: LD_INT 5
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: LIST
58510: LIST
58511: LIST
58512: LIST
58513: LIST
58514: LIST
58515: LIST
58516: LIST
58517: LIST
58518: LIST
58519: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
58520: LD_ADDR_VAR 0 33
58524: PUSH
58525: LD_INT 2
58527: NEG
58528: PUSH
58529: LD_INT 1
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PUSH
58536: LD_INT 3
58538: NEG
58539: PUSH
58540: LD_INT 0
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: PUSH
58547: LD_INT 3
58549: NEG
58550: PUSH
58551: LD_INT 1
58553: NEG
58554: PUSH
58555: EMPTY
58556: LIST
58557: LIST
58558: PUSH
58559: LD_INT 3
58561: NEG
58562: PUSH
58563: LD_INT 1
58565: PUSH
58566: EMPTY
58567: LIST
58568: LIST
58569: PUSH
58570: LD_INT 4
58572: NEG
58573: PUSH
58574: LD_INT 0
58576: PUSH
58577: EMPTY
58578: LIST
58579: LIST
58580: PUSH
58581: LD_INT 4
58583: NEG
58584: PUSH
58585: LD_INT 1
58587: NEG
58588: PUSH
58589: EMPTY
58590: LIST
58591: LIST
58592: PUSH
58593: LD_INT 4
58595: NEG
58596: PUSH
58597: LD_INT 1
58599: PUSH
58600: EMPTY
58601: LIST
58602: LIST
58603: PUSH
58604: LD_INT 5
58606: NEG
58607: PUSH
58608: LD_INT 0
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: PUSH
58615: LD_INT 5
58617: NEG
58618: PUSH
58619: LD_INT 1
58621: NEG
58622: PUSH
58623: EMPTY
58624: LIST
58625: LIST
58626: PUSH
58627: LD_INT 5
58629: NEG
58630: PUSH
58631: LD_INT 1
58633: PUSH
58634: EMPTY
58635: LIST
58636: LIST
58637: PUSH
58638: LD_INT 6
58640: NEG
58641: PUSH
58642: LD_INT 0
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: PUSH
58649: LD_INT 6
58651: NEG
58652: PUSH
58653: LD_INT 1
58655: NEG
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: LIST
58665: LIST
58666: LIST
58667: LIST
58668: LIST
58669: LIST
58670: LIST
58671: LIST
58672: LIST
58673: LIST
58674: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
58675: LD_ADDR_VAR 0 34
58679: PUSH
58680: LD_INT 2
58682: NEG
58683: PUSH
58684: LD_INT 3
58686: NEG
58687: PUSH
58688: EMPTY
58689: LIST
58690: LIST
58691: PUSH
58692: LD_INT 3
58694: NEG
58695: PUSH
58696: LD_INT 2
58698: NEG
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: PUSH
58704: LD_INT 3
58706: NEG
58707: PUSH
58708: LD_INT 3
58710: NEG
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: PUSH
58716: LD_INT 3
58718: NEG
58719: PUSH
58720: LD_INT 4
58722: NEG
58723: PUSH
58724: EMPTY
58725: LIST
58726: LIST
58727: PUSH
58728: LD_INT 4
58730: NEG
58731: PUSH
58732: LD_INT 3
58734: NEG
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: PUSH
58740: LD_INT 4
58742: NEG
58743: PUSH
58744: LD_INT 4
58746: NEG
58747: PUSH
58748: EMPTY
58749: LIST
58750: LIST
58751: PUSH
58752: LD_INT 4
58754: NEG
58755: PUSH
58756: LD_INT 5
58758: NEG
58759: PUSH
58760: EMPTY
58761: LIST
58762: LIST
58763: PUSH
58764: LD_INT 5
58766: NEG
58767: PUSH
58768: LD_INT 4
58770: NEG
58771: PUSH
58772: EMPTY
58773: LIST
58774: LIST
58775: PUSH
58776: LD_INT 5
58778: NEG
58779: PUSH
58780: LD_INT 5
58782: NEG
58783: PUSH
58784: EMPTY
58785: LIST
58786: LIST
58787: PUSH
58788: LD_INT 5
58790: NEG
58791: PUSH
58792: LD_INT 6
58794: NEG
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: PUSH
58800: LD_INT 6
58802: NEG
58803: PUSH
58804: LD_INT 5
58806: NEG
58807: PUSH
58808: EMPTY
58809: LIST
58810: LIST
58811: PUSH
58812: LD_INT 6
58814: NEG
58815: PUSH
58816: LD_INT 6
58818: NEG
58819: PUSH
58820: EMPTY
58821: LIST
58822: LIST
58823: PUSH
58824: EMPTY
58825: LIST
58826: LIST
58827: LIST
58828: LIST
58829: LIST
58830: LIST
58831: LIST
58832: LIST
58833: LIST
58834: LIST
58835: LIST
58836: LIST
58837: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
58838: LD_ADDR_VAR 0 41
58842: PUSH
58843: LD_INT 0
58845: PUSH
58846: LD_INT 2
58848: NEG
58849: PUSH
58850: EMPTY
58851: LIST
58852: LIST
58853: PUSH
58854: LD_INT 1
58856: NEG
58857: PUSH
58858: LD_INT 3
58860: NEG
58861: PUSH
58862: EMPTY
58863: LIST
58864: LIST
58865: PUSH
58866: LD_INT 1
58868: PUSH
58869: LD_INT 2
58871: NEG
58872: PUSH
58873: EMPTY
58874: LIST
58875: LIST
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: LIST
58881: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
58882: LD_ADDR_VAR 0 42
58886: PUSH
58887: LD_INT 2
58889: PUSH
58890: LD_INT 0
58892: PUSH
58893: EMPTY
58894: LIST
58895: LIST
58896: PUSH
58897: LD_INT 2
58899: PUSH
58900: LD_INT 1
58902: NEG
58903: PUSH
58904: EMPTY
58905: LIST
58906: LIST
58907: PUSH
58908: LD_INT 3
58910: PUSH
58911: LD_INT 1
58913: PUSH
58914: EMPTY
58915: LIST
58916: LIST
58917: PUSH
58918: EMPTY
58919: LIST
58920: LIST
58921: LIST
58922: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
58923: LD_ADDR_VAR 0 43
58927: PUSH
58928: LD_INT 2
58930: PUSH
58931: LD_INT 2
58933: PUSH
58934: EMPTY
58935: LIST
58936: LIST
58937: PUSH
58938: LD_INT 3
58940: PUSH
58941: LD_INT 2
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: PUSH
58948: LD_INT 2
58950: PUSH
58951: LD_INT 3
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: PUSH
58958: EMPTY
58959: LIST
58960: LIST
58961: LIST
58962: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
58963: LD_ADDR_VAR 0 44
58967: PUSH
58968: LD_INT 0
58970: PUSH
58971: LD_INT 2
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: PUSH
58978: LD_INT 1
58980: PUSH
58981: LD_INT 3
58983: PUSH
58984: EMPTY
58985: LIST
58986: LIST
58987: PUSH
58988: LD_INT 1
58990: NEG
58991: PUSH
58992: LD_INT 2
58994: PUSH
58995: EMPTY
58996: LIST
58997: LIST
58998: PUSH
58999: EMPTY
59000: LIST
59001: LIST
59002: LIST
59003: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
59004: LD_ADDR_VAR 0 45
59008: PUSH
59009: LD_INT 2
59011: NEG
59012: PUSH
59013: LD_INT 0
59015: PUSH
59016: EMPTY
59017: LIST
59018: LIST
59019: PUSH
59020: LD_INT 2
59022: NEG
59023: PUSH
59024: LD_INT 1
59026: PUSH
59027: EMPTY
59028: LIST
59029: LIST
59030: PUSH
59031: LD_INT 3
59033: NEG
59034: PUSH
59035: LD_INT 1
59037: NEG
59038: PUSH
59039: EMPTY
59040: LIST
59041: LIST
59042: PUSH
59043: EMPTY
59044: LIST
59045: LIST
59046: LIST
59047: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
59048: LD_ADDR_VAR 0 46
59052: PUSH
59053: LD_INT 2
59055: NEG
59056: PUSH
59057: LD_INT 2
59059: NEG
59060: PUSH
59061: EMPTY
59062: LIST
59063: LIST
59064: PUSH
59065: LD_INT 2
59067: NEG
59068: PUSH
59069: LD_INT 3
59071: NEG
59072: PUSH
59073: EMPTY
59074: LIST
59075: LIST
59076: PUSH
59077: LD_INT 3
59079: NEG
59080: PUSH
59081: LD_INT 2
59083: NEG
59084: PUSH
59085: EMPTY
59086: LIST
59087: LIST
59088: PUSH
59089: EMPTY
59090: LIST
59091: LIST
59092: LIST
59093: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
59094: LD_ADDR_VAR 0 47
59098: PUSH
59099: LD_INT 2
59101: NEG
59102: PUSH
59103: LD_INT 3
59105: NEG
59106: PUSH
59107: EMPTY
59108: LIST
59109: LIST
59110: PUSH
59111: LD_INT 1
59113: NEG
59114: PUSH
59115: LD_INT 3
59117: NEG
59118: PUSH
59119: EMPTY
59120: LIST
59121: LIST
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
59127: LD_ADDR_VAR 0 48
59131: PUSH
59132: LD_INT 1
59134: PUSH
59135: LD_INT 2
59137: NEG
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: PUSH
59143: LD_INT 2
59145: PUSH
59146: LD_INT 1
59148: NEG
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
59158: LD_ADDR_VAR 0 49
59162: PUSH
59163: LD_INT 3
59165: PUSH
59166: LD_INT 1
59168: PUSH
59169: EMPTY
59170: LIST
59171: LIST
59172: PUSH
59173: LD_INT 3
59175: PUSH
59176: LD_INT 2
59178: PUSH
59179: EMPTY
59180: LIST
59181: LIST
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
59187: LD_ADDR_VAR 0 50
59191: PUSH
59192: LD_INT 2
59194: PUSH
59195: LD_INT 3
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: PUSH
59202: LD_INT 1
59204: PUSH
59205: LD_INT 3
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PUSH
59212: EMPTY
59213: LIST
59214: LIST
59215: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
59216: LD_ADDR_VAR 0 51
59220: PUSH
59221: LD_INT 1
59223: NEG
59224: PUSH
59225: LD_INT 2
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: PUSH
59232: LD_INT 2
59234: NEG
59235: PUSH
59236: LD_INT 1
59238: PUSH
59239: EMPTY
59240: LIST
59241: LIST
59242: PUSH
59243: EMPTY
59244: LIST
59245: LIST
59246: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59247: LD_ADDR_VAR 0 52
59251: PUSH
59252: LD_INT 3
59254: NEG
59255: PUSH
59256: LD_INT 1
59258: NEG
59259: PUSH
59260: EMPTY
59261: LIST
59262: LIST
59263: PUSH
59264: LD_INT 3
59266: NEG
59267: PUSH
59268: LD_INT 2
59270: NEG
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: PUSH
59276: EMPTY
59277: LIST
59278: LIST
59279: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
59280: LD_ADDR_VAR 0 53
59284: PUSH
59285: LD_INT 1
59287: NEG
59288: PUSH
59289: LD_INT 3
59291: NEG
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: PUSH
59297: LD_INT 0
59299: PUSH
59300: LD_INT 3
59302: NEG
59303: PUSH
59304: EMPTY
59305: LIST
59306: LIST
59307: PUSH
59308: LD_INT 1
59310: PUSH
59311: LD_INT 2
59313: NEG
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: PUSH
59319: EMPTY
59320: LIST
59321: LIST
59322: LIST
59323: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
59324: LD_ADDR_VAR 0 54
59328: PUSH
59329: LD_INT 2
59331: PUSH
59332: LD_INT 1
59334: NEG
59335: PUSH
59336: EMPTY
59337: LIST
59338: LIST
59339: PUSH
59340: LD_INT 3
59342: PUSH
59343: LD_INT 0
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: PUSH
59350: LD_INT 3
59352: PUSH
59353: LD_INT 1
59355: PUSH
59356: EMPTY
59357: LIST
59358: LIST
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: LIST
59364: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
59365: LD_ADDR_VAR 0 55
59369: PUSH
59370: LD_INT 3
59372: PUSH
59373: LD_INT 2
59375: PUSH
59376: EMPTY
59377: LIST
59378: LIST
59379: PUSH
59380: LD_INT 3
59382: PUSH
59383: LD_INT 3
59385: PUSH
59386: EMPTY
59387: LIST
59388: LIST
59389: PUSH
59390: LD_INT 2
59392: PUSH
59393: LD_INT 3
59395: PUSH
59396: EMPTY
59397: LIST
59398: LIST
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: LIST
59404: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
59405: LD_ADDR_VAR 0 56
59409: PUSH
59410: LD_INT 1
59412: PUSH
59413: LD_INT 3
59415: PUSH
59416: EMPTY
59417: LIST
59418: LIST
59419: PUSH
59420: LD_INT 0
59422: PUSH
59423: LD_INT 3
59425: PUSH
59426: EMPTY
59427: LIST
59428: LIST
59429: PUSH
59430: LD_INT 1
59432: NEG
59433: PUSH
59434: LD_INT 2
59436: PUSH
59437: EMPTY
59438: LIST
59439: LIST
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: LIST
59445: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
59446: LD_ADDR_VAR 0 57
59450: PUSH
59451: LD_INT 2
59453: NEG
59454: PUSH
59455: LD_INT 1
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: PUSH
59462: LD_INT 3
59464: NEG
59465: PUSH
59466: LD_INT 0
59468: PUSH
59469: EMPTY
59470: LIST
59471: LIST
59472: PUSH
59473: LD_INT 3
59475: NEG
59476: PUSH
59477: LD_INT 1
59479: NEG
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: LIST
59489: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
59490: LD_ADDR_VAR 0 58
59494: PUSH
59495: LD_INT 2
59497: NEG
59498: PUSH
59499: LD_INT 3
59501: NEG
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: LD_INT 3
59509: NEG
59510: PUSH
59511: LD_INT 2
59513: NEG
59514: PUSH
59515: EMPTY
59516: LIST
59517: LIST
59518: PUSH
59519: LD_INT 3
59521: NEG
59522: PUSH
59523: LD_INT 3
59525: NEG
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: PUSH
59531: EMPTY
59532: LIST
59533: LIST
59534: LIST
59535: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
59536: LD_ADDR_VAR 0 59
59540: PUSH
59541: LD_INT 1
59543: NEG
59544: PUSH
59545: LD_INT 2
59547: NEG
59548: PUSH
59549: EMPTY
59550: LIST
59551: LIST
59552: PUSH
59553: LD_INT 0
59555: PUSH
59556: LD_INT 2
59558: NEG
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: PUSH
59564: LD_INT 1
59566: PUSH
59567: LD_INT 1
59569: NEG
59570: PUSH
59571: EMPTY
59572: LIST
59573: LIST
59574: PUSH
59575: EMPTY
59576: LIST
59577: LIST
59578: LIST
59579: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
59580: LD_ADDR_VAR 0 60
59584: PUSH
59585: LD_INT 1
59587: PUSH
59588: LD_INT 1
59590: NEG
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: PUSH
59596: LD_INT 2
59598: PUSH
59599: LD_INT 0
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: PUSH
59606: LD_INT 2
59608: PUSH
59609: LD_INT 1
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: LIST
59620: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
59621: LD_ADDR_VAR 0 61
59625: PUSH
59626: LD_INT 2
59628: PUSH
59629: LD_INT 1
59631: PUSH
59632: EMPTY
59633: LIST
59634: LIST
59635: PUSH
59636: LD_INT 2
59638: PUSH
59639: LD_INT 2
59641: PUSH
59642: EMPTY
59643: LIST
59644: LIST
59645: PUSH
59646: LD_INT 1
59648: PUSH
59649: LD_INT 2
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: LIST
59660: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
59661: LD_ADDR_VAR 0 62
59665: PUSH
59666: LD_INT 1
59668: PUSH
59669: LD_INT 2
59671: PUSH
59672: EMPTY
59673: LIST
59674: LIST
59675: PUSH
59676: LD_INT 0
59678: PUSH
59679: LD_INT 2
59681: PUSH
59682: EMPTY
59683: LIST
59684: LIST
59685: PUSH
59686: LD_INT 1
59688: NEG
59689: PUSH
59690: LD_INT 1
59692: PUSH
59693: EMPTY
59694: LIST
59695: LIST
59696: PUSH
59697: EMPTY
59698: LIST
59699: LIST
59700: LIST
59701: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
59702: LD_ADDR_VAR 0 63
59706: PUSH
59707: LD_INT 1
59709: NEG
59710: PUSH
59711: LD_INT 1
59713: PUSH
59714: EMPTY
59715: LIST
59716: LIST
59717: PUSH
59718: LD_INT 2
59720: NEG
59721: PUSH
59722: LD_INT 0
59724: PUSH
59725: EMPTY
59726: LIST
59727: LIST
59728: PUSH
59729: LD_INT 2
59731: NEG
59732: PUSH
59733: LD_INT 1
59735: NEG
59736: PUSH
59737: EMPTY
59738: LIST
59739: LIST
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: LIST
59745: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
59746: LD_ADDR_VAR 0 64
59750: PUSH
59751: LD_INT 1
59753: NEG
59754: PUSH
59755: LD_INT 2
59757: NEG
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PUSH
59763: LD_INT 2
59765: NEG
59766: PUSH
59767: LD_INT 1
59769: NEG
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: PUSH
59775: LD_INT 2
59777: NEG
59778: PUSH
59779: LD_INT 2
59781: NEG
59782: PUSH
59783: EMPTY
59784: LIST
59785: LIST
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: LIST
59791: ST_TO_ADDR
// end ; 2 :
59792: GO 63058
59794: LD_INT 2
59796: DOUBLE
59797: EQUAL
59798: IFTRUE 59802
59800: GO 63057
59802: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
59803: LD_ADDR_VAR 0 29
59807: PUSH
59808: LD_INT 4
59810: PUSH
59811: LD_INT 0
59813: PUSH
59814: EMPTY
59815: LIST
59816: LIST
59817: PUSH
59818: LD_INT 4
59820: PUSH
59821: LD_INT 1
59823: NEG
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: PUSH
59829: LD_INT 5
59831: PUSH
59832: LD_INT 0
59834: PUSH
59835: EMPTY
59836: LIST
59837: LIST
59838: PUSH
59839: LD_INT 5
59841: PUSH
59842: LD_INT 1
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: LD_INT 4
59851: PUSH
59852: LD_INT 1
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: LD_INT 3
59861: PUSH
59862: LD_INT 0
59864: PUSH
59865: EMPTY
59866: LIST
59867: LIST
59868: PUSH
59869: LD_INT 3
59871: PUSH
59872: LD_INT 1
59874: NEG
59875: PUSH
59876: EMPTY
59877: LIST
59878: LIST
59879: PUSH
59880: LD_INT 3
59882: PUSH
59883: LD_INT 2
59885: NEG
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PUSH
59891: LD_INT 5
59893: PUSH
59894: LD_INT 2
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: LD_INT 3
59903: PUSH
59904: LD_INT 3
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: LD_INT 3
59913: PUSH
59914: LD_INT 2
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PUSH
59921: LD_INT 4
59923: PUSH
59924: LD_INT 3
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PUSH
59931: LD_INT 4
59933: PUSH
59934: LD_INT 4
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: LD_INT 3
59943: PUSH
59944: LD_INT 4
59946: PUSH
59947: EMPTY
59948: LIST
59949: LIST
59950: PUSH
59951: LD_INT 2
59953: PUSH
59954: LD_INT 3
59956: PUSH
59957: EMPTY
59958: LIST
59959: LIST
59960: PUSH
59961: LD_INT 2
59963: PUSH
59964: LD_INT 2
59966: PUSH
59967: EMPTY
59968: LIST
59969: LIST
59970: PUSH
59971: LD_INT 4
59973: PUSH
59974: LD_INT 2
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: PUSH
59981: LD_INT 2
59983: PUSH
59984: LD_INT 4
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: PUSH
59991: LD_INT 0
59993: PUSH
59994: LD_INT 4
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: PUSH
60001: LD_INT 0
60003: PUSH
60004: LD_INT 3
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PUSH
60011: LD_INT 1
60013: PUSH
60014: LD_INT 4
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: LD_INT 1
60023: PUSH
60024: LD_INT 5
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: LD_INT 0
60033: PUSH
60034: LD_INT 5
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PUSH
60041: LD_INT 1
60043: NEG
60044: PUSH
60045: LD_INT 4
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PUSH
60052: LD_INT 1
60054: NEG
60055: PUSH
60056: LD_INT 3
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PUSH
60063: LD_INT 2
60065: PUSH
60066: LD_INT 5
60068: PUSH
60069: EMPTY
60070: LIST
60071: LIST
60072: PUSH
60073: LD_INT 2
60075: NEG
60076: PUSH
60077: LD_INT 3
60079: PUSH
60080: EMPTY
60081: LIST
60082: LIST
60083: PUSH
60084: LD_INT 3
60086: NEG
60087: PUSH
60088: LD_INT 0
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: PUSH
60095: LD_INT 3
60097: NEG
60098: PUSH
60099: LD_INT 1
60101: NEG
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: PUSH
60107: LD_INT 2
60109: NEG
60110: PUSH
60111: LD_INT 0
60113: PUSH
60114: EMPTY
60115: LIST
60116: LIST
60117: PUSH
60118: LD_INT 2
60120: NEG
60121: PUSH
60122: LD_INT 1
60124: PUSH
60125: EMPTY
60126: LIST
60127: LIST
60128: PUSH
60129: LD_INT 3
60131: NEG
60132: PUSH
60133: LD_INT 1
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: PUSH
60140: LD_INT 4
60142: NEG
60143: PUSH
60144: LD_INT 0
60146: PUSH
60147: EMPTY
60148: LIST
60149: LIST
60150: PUSH
60151: LD_INT 4
60153: NEG
60154: PUSH
60155: LD_INT 1
60157: NEG
60158: PUSH
60159: EMPTY
60160: LIST
60161: LIST
60162: PUSH
60163: LD_INT 4
60165: NEG
60166: PUSH
60167: LD_INT 2
60169: NEG
60170: PUSH
60171: EMPTY
60172: LIST
60173: LIST
60174: PUSH
60175: LD_INT 2
60177: NEG
60178: PUSH
60179: LD_INT 2
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: LD_INT 4
60188: NEG
60189: PUSH
60190: LD_INT 4
60192: NEG
60193: PUSH
60194: EMPTY
60195: LIST
60196: LIST
60197: PUSH
60198: LD_INT 4
60200: NEG
60201: PUSH
60202: LD_INT 5
60204: NEG
60205: PUSH
60206: EMPTY
60207: LIST
60208: LIST
60209: PUSH
60210: LD_INT 3
60212: NEG
60213: PUSH
60214: LD_INT 4
60216: NEG
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 3
60224: NEG
60225: PUSH
60226: LD_INT 3
60228: NEG
60229: PUSH
60230: EMPTY
60231: LIST
60232: LIST
60233: PUSH
60234: LD_INT 4
60236: NEG
60237: PUSH
60238: LD_INT 3
60240: NEG
60241: PUSH
60242: EMPTY
60243: LIST
60244: LIST
60245: PUSH
60246: LD_INT 5
60248: NEG
60249: PUSH
60250: LD_INT 4
60252: NEG
60253: PUSH
60254: EMPTY
60255: LIST
60256: LIST
60257: PUSH
60258: LD_INT 5
60260: NEG
60261: PUSH
60262: LD_INT 5
60264: NEG
60265: PUSH
60266: EMPTY
60267: LIST
60268: LIST
60269: PUSH
60270: LD_INT 3
60272: NEG
60273: PUSH
60274: LD_INT 5
60276: NEG
60277: PUSH
60278: EMPTY
60279: LIST
60280: LIST
60281: PUSH
60282: LD_INT 5
60284: NEG
60285: PUSH
60286: LD_INT 3
60288: NEG
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PUSH
60294: EMPTY
60295: LIST
60296: LIST
60297: LIST
60298: LIST
60299: LIST
60300: LIST
60301: LIST
60302: LIST
60303: LIST
60304: LIST
60305: LIST
60306: LIST
60307: LIST
60308: LIST
60309: LIST
60310: LIST
60311: LIST
60312: LIST
60313: LIST
60314: LIST
60315: LIST
60316: LIST
60317: LIST
60318: LIST
60319: LIST
60320: LIST
60321: LIST
60322: LIST
60323: LIST
60324: LIST
60325: LIST
60326: LIST
60327: LIST
60328: LIST
60329: LIST
60330: LIST
60331: LIST
60332: LIST
60333: LIST
60334: LIST
60335: LIST
60336: LIST
60337: LIST
60338: LIST
60339: LIST
60340: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
60341: LD_ADDR_VAR 0 30
60345: PUSH
60346: LD_INT 4
60348: PUSH
60349: LD_INT 4
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: PUSH
60356: LD_INT 4
60358: PUSH
60359: LD_INT 3
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: PUSH
60366: LD_INT 5
60368: PUSH
60369: LD_INT 4
60371: PUSH
60372: EMPTY
60373: LIST
60374: LIST
60375: PUSH
60376: LD_INT 5
60378: PUSH
60379: LD_INT 5
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: PUSH
60386: LD_INT 4
60388: PUSH
60389: LD_INT 5
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: LD_INT 3
60398: PUSH
60399: LD_INT 4
60401: PUSH
60402: EMPTY
60403: LIST
60404: LIST
60405: PUSH
60406: LD_INT 3
60408: PUSH
60409: LD_INT 3
60411: PUSH
60412: EMPTY
60413: LIST
60414: LIST
60415: PUSH
60416: LD_INT 5
60418: PUSH
60419: LD_INT 3
60421: PUSH
60422: EMPTY
60423: LIST
60424: LIST
60425: PUSH
60426: LD_INT 3
60428: PUSH
60429: LD_INT 5
60431: PUSH
60432: EMPTY
60433: LIST
60434: LIST
60435: PUSH
60436: LD_INT 0
60438: PUSH
60439: LD_INT 3
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: PUSH
60446: LD_INT 0
60448: PUSH
60449: LD_INT 2
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: LD_INT 1
60458: PUSH
60459: LD_INT 3
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: PUSH
60466: LD_INT 1
60468: PUSH
60469: LD_INT 4
60471: PUSH
60472: EMPTY
60473: LIST
60474: LIST
60475: PUSH
60476: LD_INT 0
60478: PUSH
60479: LD_INT 4
60481: PUSH
60482: EMPTY
60483: LIST
60484: LIST
60485: PUSH
60486: LD_INT 1
60488: NEG
60489: PUSH
60490: LD_INT 3
60492: PUSH
60493: EMPTY
60494: LIST
60495: LIST
60496: PUSH
60497: LD_INT 1
60499: NEG
60500: PUSH
60501: LD_INT 2
60503: PUSH
60504: EMPTY
60505: LIST
60506: LIST
60507: PUSH
60508: LD_INT 2
60510: PUSH
60511: LD_INT 4
60513: PUSH
60514: EMPTY
60515: LIST
60516: LIST
60517: PUSH
60518: LD_INT 2
60520: NEG
60521: PUSH
60522: LD_INT 2
60524: PUSH
60525: EMPTY
60526: LIST
60527: LIST
60528: PUSH
60529: LD_INT 4
60531: NEG
60532: PUSH
60533: LD_INT 0
60535: PUSH
60536: EMPTY
60537: LIST
60538: LIST
60539: PUSH
60540: LD_INT 4
60542: NEG
60543: PUSH
60544: LD_INT 1
60546: NEG
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PUSH
60552: LD_INT 3
60554: NEG
60555: PUSH
60556: LD_INT 0
60558: PUSH
60559: EMPTY
60560: LIST
60561: LIST
60562: PUSH
60563: LD_INT 3
60565: NEG
60566: PUSH
60567: LD_INT 1
60569: PUSH
60570: EMPTY
60571: LIST
60572: LIST
60573: PUSH
60574: LD_INT 4
60576: NEG
60577: PUSH
60578: LD_INT 1
60580: PUSH
60581: EMPTY
60582: LIST
60583: LIST
60584: PUSH
60585: LD_INT 5
60587: NEG
60588: PUSH
60589: LD_INT 0
60591: PUSH
60592: EMPTY
60593: LIST
60594: LIST
60595: PUSH
60596: LD_INT 5
60598: NEG
60599: PUSH
60600: LD_INT 1
60602: NEG
60603: PUSH
60604: EMPTY
60605: LIST
60606: LIST
60607: PUSH
60608: LD_INT 5
60610: NEG
60611: PUSH
60612: LD_INT 2
60614: NEG
60615: PUSH
60616: EMPTY
60617: LIST
60618: LIST
60619: PUSH
60620: LD_INT 3
60622: NEG
60623: PUSH
60624: LD_INT 2
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: PUSH
60631: LD_INT 3
60633: NEG
60634: PUSH
60635: LD_INT 3
60637: NEG
60638: PUSH
60639: EMPTY
60640: LIST
60641: LIST
60642: PUSH
60643: LD_INT 3
60645: NEG
60646: PUSH
60647: LD_INT 4
60649: NEG
60650: PUSH
60651: EMPTY
60652: LIST
60653: LIST
60654: PUSH
60655: LD_INT 2
60657: NEG
60658: PUSH
60659: LD_INT 3
60661: NEG
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: PUSH
60667: LD_INT 2
60669: NEG
60670: PUSH
60671: LD_INT 2
60673: NEG
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PUSH
60679: LD_INT 3
60681: NEG
60682: PUSH
60683: LD_INT 2
60685: NEG
60686: PUSH
60687: EMPTY
60688: LIST
60689: LIST
60690: PUSH
60691: LD_INT 4
60693: NEG
60694: PUSH
60695: LD_INT 3
60697: NEG
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PUSH
60703: LD_INT 4
60705: NEG
60706: PUSH
60707: LD_INT 4
60709: NEG
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: PUSH
60715: LD_INT 2
60717: NEG
60718: PUSH
60719: LD_INT 4
60721: NEG
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: PUSH
60727: LD_INT 4
60729: NEG
60730: PUSH
60731: LD_INT 2
60733: NEG
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: PUSH
60739: LD_INT 0
60741: PUSH
60742: LD_INT 4
60744: NEG
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: PUSH
60750: LD_INT 0
60752: PUSH
60753: LD_INT 5
60755: NEG
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: PUSH
60761: LD_INT 1
60763: PUSH
60764: LD_INT 4
60766: NEG
60767: PUSH
60768: EMPTY
60769: LIST
60770: LIST
60771: PUSH
60772: LD_INT 1
60774: PUSH
60775: LD_INT 3
60777: NEG
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: PUSH
60783: LD_INT 0
60785: PUSH
60786: LD_INT 3
60788: NEG
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PUSH
60794: LD_INT 1
60796: NEG
60797: PUSH
60798: LD_INT 4
60800: NEG
60801: PUSH
60802: EMPTY
60803: LIST
60804: LIST
60805: PUSH
60806: LD_INT 1
60808: NEG
60809: PUSH
60810: LD_INT 5
60812: NEG
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: PUSH
60818: LD_INT 2
60820: PUSH
60821: LD_INT 3
60823: NEG
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 2
60831: NEG
60832: PUSH
60833: LD_INT 5
60835: NEG
60836: PUSH
60837: EMPTY
60838: LIST
60839: LIST
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: LIST
60845: LIST
60846: LIST
60847: LIST
60848: LIST
60849: LIST
60850: LIST
60851: LIST
60852: LIST
60853: LIST
60854: LIST
60855: LIST
60856: LIST
60857: LIST
60858: LIST
60859: LIST
60860: LIST
60861: LIST
60862: LIST
60863: LIST
60864: LIST
60865: LIST
60866: LIST
60867: LIST
60868: LIST
60869: LIST
60870: LIST
60871: LIST
60872: LIST
60873: LIST
60874: LIST
60875: LIST
60876: LIST
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
60888: LD_ADDR_VAR 0 31
60892: PUSH
60893: LD_INT 0
60895: PUSH
60896: LD_INT 4
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PUSH
60903: LD_INT 0
60905: PUSH
60906: LD_INT 3
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: PUSH
60913: LD_INT 1
60915: PUSH
60916: LD_INT 4
60918: PUSH
60919: EMPTY
60920: LIST
60921: LIST
60922: PUSH
60923: LD_INT 1
60925: PUSH
60926: LD_INT 5
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PUSH
60933: LD_INT 0
60935: PUSH
60936: LD_INT 5
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: PUSH
60943: LD_INT 1
60945: NEG
60946: PUSH
60947: LD_INT 4
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: PUSH
60954: LD_INT 1
60956: NEG
60957: PUSH
60958: LD_INT 3
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: PUSH
60965: LD_INT 2
60967: PUSH
60968: LD_INT 5
60970: PUSH
60971: EMPTY
60972: LIST
60973: LIST
60974: PUSH
60975: LD_INT 2
60977: NEG
60978: PUSH
60979: LD_INT 3
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: PUSH
60986: LD_INT 3
60988: NEG
60989: PUSH
60990: LD_INT 0
60992: PUSH
60993: EMPTY
60994: LIST
60995: LIST
60996: PUSH
60997: LD_INT 3
60999: NEG
61000: PUSH
61001: LD_INT 1
61003: NEG
61004: PUSH
61005: EMPTY
61006: LIST
61007: LIST
61008: PUSH
61009: LD_INT 2
61011: NEG
61012: PUSH
61013: LD_INT 0
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: PUSH
61020: LD_INT 2
61022: NEG
61023: PUSH
61024: LD_INT 1
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: LD_INT 3
61033: NEG
61034: PUSH
61035: LD_INT 1
61037: PUSH
61038: EMPTY
61039: LIST
61040: LIST
61041: PUSH
61042: LD_INT 4
61044: NEG
61045: PUSH
61046: LD_INT 0
61048: PUSH
61049: EMPTY
61050: LIST
61051: LIST
61052: PUSH
61053: LD_INT 4
61055: NEG
61056: PUSH
61057: LD_INT 1
61059: NEG
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PUSH
61065: LD_INT 4
61067: NEG
61068: PUSH
61069: LD_INT 2
61071: NEG
61072: PUSH
61073: EMPTY
61074: LIST
61075: LIST
61076: PUSH
61077: LD_INT 2
61079: NEG
61080: PUSH
61081: LD_INT 2
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: PUSH
61088: LD_INT 4
61090: NEG
61091: PUSH
61092: LD_INT 4
61094: NEG
61095: PUSH
61096: EMPTY
61097: LIST
61098: LIST
61099: PUSH
61100: LD_INT 4
61102: NEG
61103: PUSH
61104: LD_INT 5
61106: NEG
61107: PUSH
61108: EMPTY
61109: LIST
61110: LIST
61111: PUSH
61112: LD_INT 3
61114: NEG
61115: PUSH
61116: LD_INT 4
61118: NEG
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: LD_INT 3
61126: NEG
61127: PUSH
61128: LD_INT 3
61130: NEG
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 4
61138: NEG
61139: PUSH
61140: LD_INT 3
61142: NEG
61143: PUSH
61144: EMPTY
61145: LIST
61146: LIST
61147: PUSH
61148: LD_INT 5
61150: NEG
61151: PUSH
61152: LD_INT 4
61154: NEG
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: PUSH
61160: LD_INT 5
61162: NEG
61163: PUSH
61164: LD_INT 5
61166: NEG
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: PUSH
61172: LD_INT 3
61174: NEG
61175: PUSH
61176: LD_INT 5
61178: NEG
61179: PUSH
61180: EMPTY
61181: LIST
61182: LIST
61183: PUSH
61184: LD_INT 5
61186: NEG
61187: PUSH
61188: LD_INT 3
61190: NEG
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: PUSH
61196: LD_INT 0
61198: PUSH
61199: LD_INT 3
61201: NEG
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: PUSH
61207: LD_INT 0
61209: PUSH
61210: LD_INT 4
61212: NEG
61213: PUSH
61214: EMPTY
61215: LIST
61216: LIST
61217: PUSH
61218: LD_INT 1
61220: PUSH
61221: LD_INT 3
61223: NEG
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PUSH
61229: LD_INT 1
61231: PUSH
61232: LD_INT 2
61234: NEG
61235: PUSH
61236: EMPTY
61237: LIST
61238: LIST
61239: PUSH
61240: LD_INT 0
61242: PUSH
61243: LD_INT 2
61245: NEG
61246: PUSH
61247: EMPTY
61248: LIST
61249: LIST
61250: PUSH
61251: LD_INT 1
61253: NEG
61254: PUSH
61255: LD_INT 3
61257: NEG
61258: PUSH
61259: EMPTY
61260: LIST
61261: LIST
61262: PUSH
61263: LD_INT 1
61265: NEG
61266: PUSH
61267: LD_INT 4
61269: NEG
61270: PUSH
61271: EMPTY
61272: LIST
61273: LIST
61274: PUSH
61275: LD_INT 2
61277: PUSH
61278: LD_INT 2
61280: NEG
61281: PUSH
61282: EMPTY
61283: LIST
61284: LIST
61285: PUSH
61286: LD_INT 2
61288: NEG
61289: PUSH
61290: LD_INT 4
61292: NEG
61293: PUSH
61294: EMPTY
61295: LIST
61296: LIST
61297: PUSH
61298: LD_INT 4
61300: PUSH
61301: LD_INT 0
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: LD_INT 4
61310: PUSH
61311: LD_INT 1
61313: NEG
61314: PUSH
61315: EMPTY
61316: LIST
61317: LIST
61318: PUSH
61319: LD_INT 5
61321: PUSH
61322: LD_INT 0
61324: PUSH
61325: EMPTY
61326: LIST
61327: LIST
61328: PUSH
61329: LD_INT 5
61331: PUSH
61332: LD_INT 1
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: PUSH
61339: LD_INT 4
61341: PUSH
61342: LD_INT 1
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PUSH
61349: LD_INT 3
61351: PUSH
61352: LD_INT 0
61354: PUSH
61355: EMPTY
61356: LIST
61357: LIST
61358: PUSH
61359: LD_INT 3
61361: PUSH
61362: LD_INT 1
61364: NEG
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PUSH
61370: LD_INT 3
61372: PUSH
61373: LD_INT 2
61375: NEG
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: PUSH
61381: LD_INT 5
61383: PUSH
61384: LD_INT 2
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: LIST
61395: LIST
61396: LIST
61397: LIST
61398: LIST
61399: LIST
61400: LIST
61401: LIST
61402: LIST
61403: LIST
61404: LIST
61405: LIST
61406: LIST
61407: LIST
61408: LIST
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: LIST
61414: LIST
61415: LIST
61416: LIST
61417: LIST
61418: LIST
61419: LIST
61420: LIST
61421: LIST
61422: LIST
61423: LIST
61424: LIST
61425: LIST
61426: LIST
61427: LIST
61428: LIST
61429: LIST
61430: LIST
61431: LIST
61432: LIST
61433: LIST
61434: LIST
61435: LIST
61436: LIST
61437: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
61438: LD_ADDR_VAR 0 32
61442: PUSH
61443: LD_INT 4
61445: NEG
61446: PUSH
61447: LD_INT 0
61449: PUSH
61450: EMPTY
61451: LIST
61452: LIST
61453: PUSH
61454: LD_INT 4
61456: NEG
61457: PUSH
61458: LD_INT 1
61460: NEG
61461: PUSH
61462: EMPTY
61463: LIST
61464: LIST
61465: PUSH
61466: LD_INT 3
61468: NEG
61469: PUSH
61470: LD_INT 0
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PUSH
61477: LD_INT 3
61479: NEG
61480: PUSH
61481: LD_INT 1
61483: PUSH
61484: EMPTY
61485: LIST
61486: LIST
61487: PUSH
61488: LD_INT 4
61490: NEG
61491: PUSH
61492: LD_INT 1
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PUSH
61499: LD_INT 5
61501: NEG
61502: PUSH
61503: LD_INT 0
61505: PUSH
61506: EMPTY
61507: LIST
61508: LIST
61509: PUSH
61510: LD_INT 5
61512: NEG
61513: PUSH
61514: LD_INT 1
61516: NEG
61517: PUSH
61518: EMPTY
61519: LIST
61520: LIST
61521: PUSH
61522: LD_INT 5
61524: NEG
61525: PUSH
61526: LD_INT 2
61528: NEG
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: PUSH
61534: LD_INT 3
61536: NEG
61537: PUSH
61538: LD_INT 2
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: LD_INT 3
61547: NEG
61548: PUSH
61549: LD_INT 3
61551: NEG
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: PUSH
61557: LD_INT 3
61559: NEG
61560: PUSH
61561: LD_INT 4
61563: NEG
61564: PUSH
61565: EMPTY
61566: LIST
61567: LIST
61568: PUSH
61569: LD_INT 2
61571: NEG
61572: PUSH
61573: LD_INT 3
61575: NEG
61576: PUSH
61577: EMPTY
61578: LIST
61579: LIST
61580: PUSH
61581: LD_INT 2
61583: NEG
61584: PUSH
61585: LD_INT 2
61587: NEG
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: PUSH
61593: LD_INT 3
61595: NEG
61596: PUSH
61597: LD_INT 2
61599: NEG
61600: PUSH
61601: EMPTY
61602: LIST
61603: LIST
61604: PUSH
61605: LD_INT 4
61607: NEG
61608: PUSH
61609: LD_INT 3
61611: NEG
61612: PUSH
61613: EMPTY
61614: LIST
61615: LIST
61616: PUSH
61617: LD_INT 4
61619: NEG
61620: PUSH
61621: LD_INT 4
61623: NEG
61624: PUSH
61625: EMPTY
61626: LIST
61627: LIST
61628: PUSH
61629: LD_INT 2
61631: NEG
61632: PUSH
61633: LD_INT 4
61635: NEG
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PUSH
61641: LD_INT 4
61643: NEG
61644: PUSH
61645: LD_INT 2
61647: NEG
61648: PUSH
61649: EMPTY
61650: LIST
61651: LIST
61652: PUSH
61653: LD_INT 0
61655: PUSH
61656: LD_INT 4
61658: NEG
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PUSH
61664: LD_INT 0
61666: PUSH
61667: LD_INT 5
61669: NEG
61670: PUSH
61671: EMPTY
61672: LIST
61673: LIST
61674: PUSH
61675: LD_INT 1
61677: PUSH
61678: LD_INT 4
61680: NEG
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: PUSH
61686: LD_INT 1
61688: PUSH
61689: LD_INT 3
61691: NEG
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: PUSH
61697: LD_INT 0
61699: PUSH
61700: LD_INT 3
61702: NEG
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PUSH
61708: LD_INT 1
61710: NEG
61711: PUSH
61712: LD_INT 4
61714: NEG
61715: PUSH
61716: EMPTY
61717: LIST
61718: LIST
61719: PUSH
61720: LD_INT 1
61722: NEG
61723: PUSH
61724: LD_INT 5
61726: NEG
61727: PUSH
61728: EMPTY
61729: LIST
61730: LIST
61731: PUSH
61732: LD_INT 2
61734: PUSH
61735: LD_INT 3
61737: NEG
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: LD_INT 2
61745: NEG
61746: PUSH
61747: LD_INT 5
61749: NEG
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: PUSH
61755: LD_INT 3
61757: PUSH
61758: LD_INT 0
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PUSH
61765: LD_INT 3
61767: PUSH
61768: LD_INT 1
61770: NEG
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PUSH
61776: LD_INT 4
61778: PUSH
61779: LD_INT 0
61781: PUSH
61782: EMPTY
61783: LIST
61784: LIST
61785: PUSH
61786: LD_INT 4
61788: PUSH
61789: LD_INT 1
61791: PUSH
61792: EMPTY
61793: LIST
61794: LIST
61795: PUSH
61796: LD_INT 3
61798: PUSH
61799: LD_INT 1
61801: PUSH
61802: EMPTY
61803: LIST
61804: LIST
61805: PUSH
61806: LD_INT 2
61808: PUSH
61809: LD_INT 0
61811: PUSH
61812: EMPTY
61813: LIST
61814: LIST
61815: PUSH
61816: LD_INT 2
61818: PUSH
61819: LD_INT 1
61821: NEG
61822: PUSH
61823: EMPTY
61824: LIST
61825: LIST
61826: PUSH
61827: LD_INT 2
61829: PUSH
61830: LD_INT 2
61832: NEG
61833: PUSH
61834: EMPTY
61835: LIST
61836: LIST
61837: PUSH
61838: LD_INT 4
61840: PUSH
61841: LD_INT 2
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: PUSH
61848: LD_INT 4
61850: PUSH
61851: LD_INT 4
61853: PUSH
61854: EMPTY
61855: LIST
61856: LIST
61857: PUSH
61858: LD_INT 4
61860: PUSH
61861: LD_INT 3
61863: PUSH
61864: EMPTY
61865: LIST
61866: LIST
61867: PUSH
61868: LD_INT 5
61870: PUSH
61871: LD_INT 4
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PUSH
61878: LD_INT 5
61880: PUSH
61881: LD_INT 5
61883: PUSH
61884: EMPTY
61885: LIST
61886: LIST
61887: PUSH
61888: LD_INT 4
61890: PUSH
61891: LD_INT 5
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: PUSH
61898: LD_INT 3
61900: PUSH
61901: LD_INT 4
61903: PUSH
61904: EMPTY
61905: LIST
61906: LIST
61907: PUSH
61908: LD_INT 3
61910: PUSH
61911: LD_INT 3
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: PUSH
61918: LD_INT 5
61920: PUSH
61921: LD_INT 3
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 3
61930: PUSH
61931: LD_INT 5
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: PUSH
61938: EMPTY
61939: LIST
61940: LIST
61941: LIST
61942: LIST
61943: LIST
61944: LIST
61945: LIST
61946: LIST
61947: LIST
61948: LIST
61949: LIST
61950: LIST
61951: LIST
61952: LIST
61953: LIST
61954: LIST
61955: LIST
61956: LIST
61957: LIST
61958: LIST
61959: LIST
61960: LIST
61961: LIST
61962: LIST
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
61985: LD_ADDR_VAR 0 33
61989: PUSH
61990: LD_INT 4
61992: NEG
61993: PUSH
61994: LD_INT 4
61996: NEG
61997: PUSH
61998: EMPTY
61999: LIST
62000: LIST
62001: PUSH
62002: LD_INT 4
62004: NEG
62005: PUSH
62006: LD_INT 5
62008: NEG
62009: PUSH
62010: EMPTY
62011: LIST
62012: LIST
62013: PUSH
62014: LD_INT 3
62016: NEG
62017: PUSH
62018: LD_INT 4
62020: NEG
62021: PUSH
62022: EMPTY
62023: LIST
62024: LIST
62025: PUSH
62026: LD_INT 3
62028: NEG
62029: PUSH
62030: LD_INT 3
62032: NEG
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 4
62040: NEG
62041: PUSH
62042: LD_INT 3
62044: NEG
62045: PUSH
62046: EMPTY
62047: LIST
62048: LIST
62049: PUSH
62050: LD_INT 5
62052: NEG
62053: PUSH
62054: LD_INT 4
62056: NEG
62057: PUSH
62058: EMPTY
62059: LIST
62060: LIST
62061: PUSH
62062: LD_INT 5
62064: NEG
62065: PUSH
62066: LD_INT 5
62068: NEG
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: PUSH
62074: LD_INT 3
62076: NEG
62077: PUSH
62078: LD_INT 5
62080: NEG
62081: PUSH
62082: EMPTY
62083: LIST
62084: LIST
62085: PUSH
62086: LD_INT 5
62088: NEG
62089: PUSH
62090: LD_INT 3
62092: NEG
62093: PUSH
62094: EMPTY
62095: LIST
62096: LIST
62097: PUSH
62098: LD_INT 0
62100: PUSH
62101: LD_INT 3
62103: NEG
62104: PUSH
62105: EMPTY
62106: LIST
62107: LIST
62108: PUSH
62109: LD_INT 0
62111: PUSH
62112: LD_INT 4
62114: NEG
62115: PUSH
62116: EMPTY
62117: LIST
62118: LIST
62119: PUSH
62120: LD_INT 1
62122: PUSH
62123: LD_INT 3
62125: NEG
62126: PUSH
62127: EMPTY
62128: LIST
62129: LIST
62130: PUSH
62131: LD_INT 1
62133: PUSH
62134: LD_INT 2
62136: NEG
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 0
62144: PUSH
62145: LD_INT 2
62147: NEG
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PUSH
62153: LD_INT 1
62155: NEG
62156: PUSH
62157: LD_INT 3
62159: NEG
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: PUSH
62165: LD_INT 1
62167: NEG
62168: PUSH
62169: LD_INT 4
62171: NEG
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: PUSH
62177: LD_INT 2
62179: PUSH
62180: LD_INT 2
62182: NEG
62183: PUSH
62184: EMPTY
62185: LIST
62186: LIST
62187: PUSH
62188: LD_INT 2
62190: NEG
62191: PUSH
62192: LD_INT 4
62194: NEG
62195: PUSH
62196: EMPTY
62197: LIST
62198: LIST
62199: PUSH
62200: LD_INT 4
62202: PUSH
62203: LD_INT 0
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: PUSH
62210: LD_INT 4
62212: PUSH
62213: LD_INT 1
62215: NEG
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 5
62223: PUSH
62224: LD_INT 0
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: LD_INT 5
62233: PUSH
62234: LD_INT 1
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: LD_INT 4
62243: PUSH
62244: LD_INT 1
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: LD_INT 3
62253: PUSH
62254: LD_INT 0
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: PUSH
62261: LD_INT 3
62263: PUSH
62264: LD_INT 1
62266: NEG
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: PUSH
62272: LD_INT 3
62274: PUSH
62275: LD_INT 2
62277: NEG
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: LD_INT 5
62285: PUSH
62286: LD_INT 2
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: PUSH
62293: LD_INT 3
62295: PUSH
62296: LD_INT 3
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PUSH
62303: LD_INT 3
62305: PUSH
62306: LD_INT 2
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: PUSH
62313: LD_INT 4
62315: PUSH
62316: LD_INT 3
62318: PUSH
62319: EMPTY
62320: LIST
62321: LIST
62322: PUSH
62323: LD_INT 4
62325: PUSH
62326: LD_INT 4
62328: PUSH
62329: EMPTY
62330: LIST
62331: LIST
62332: PUSH
62333: LD_INT 3
62335: PUSH
62336: LD_INT 4
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: PUSH
62343: LD_INT 2
62345: PUSH
62346: LD_INT 3
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: PUSH
62353: LD_INT 2
62355: PUSH
62356: LD_INT 2
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PUSH
62363: LD_INT 4
62365: PUSH
62366: LD_INT 2
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PUSH
62373: LD_INT 2
62375: PUSH
62376: LD_INT 4
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PUSH
62383: LD_INT 0
62385: PUSH
62386: LD_INT 4
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: PUSH
62393: LD_INT 0
62395: PUSH
62396: LD_INT 3
62398: PUSH
62399: EMPTY
62400: LIST
62401: LIST
62402: PUSH
62403: LD_INT 1
62405: PUSH
62406: LD_INT 4
62408: PUSH
62409: EMPTY
62410: LIST
62411: LIST
62412: PUSH
62413: LD_INT 1
62415: PUSH
62416: LD_INT 5
62418: PUSH
62419: EMPTY
62420: LIST
62421: LIST
62422: PUSH
62423: LD_INT 0
62425: PUSH
62426: LD_INT 5
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PUSH
62433: LD_INT 1
62435: NEG
62436: PUSH
62437: LD_INT 4
62439: PUSH
62440: EMPTY
62441: LIST
62442: LIST
62443: PUSH
62444: LD_INT 1
62446: NEG
62447: PUSH
62448: LD_INT 3
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: PUSH
62455: LD_INT 2
62457: PUSH
62458: LD_INT 5
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: PUSH
62465: LD_INT 2
62467: NEG
62468: PUSH
62469: LD_INT 3
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: PUSH
62476: EMPTY
62477: LIST
62478: LIST
62479: LIST
62480: LIST
62481: LIST
62482: LIST
62483: LIST
62484: LIST
62485: LIST
62486: LIST
62487: LIST
62488: LIST
62489: LIST
62490: LIST
62491: LIST
62492: LIST
62493: LIST
62494: LIST
62495: LIST
62496: LIST
62497: LIST
62498: LIST
62499: LIST
62500: LIST
62501: LIST
62502: LIST
62503: LIST
62504: LIST
62505: LIST
62506: LIST
62507: LIST
62508: LIST
62509: LIST
62510: LIST
62511: LIST
62512: LIST
62513: LIST
62514: LIST
62515: LIST
62516: LIST
62517: LIST
62518: LIST
62519: LIST
62520: LIST
62521: LIST
62522: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
62523: LD_ADDR_VAR 0 34
62527: PUSH
62528: LD_INT 0
62530: PUSH
62531: LD_INT 4
62533: NEG
62534: PUSH
62535: EMPTY
62536: LIST
62537: LIST
62538: PUSH
62539: LD_INT 0
62541: PUSH
62542: LD_INT 5
62544: NEG
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: PUSH
62550: LD_INT 1
62552: PUSH
62553: LD_INT 4
62555: NEG
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: LD_INT 1
62563: PUSH
62564: LD_INT 3
62566: NEG
62567: PUSH
62568: EMPTY
62569: LIST
62570: LIST
62571: PUSH
62572: LD_INT 0
62574: PUSH
62575: LD_INT 3
62577: NEG
62578: PUSH
62579: EMPTY
62580: LIST
62581: LIST
62582: PUSH
62583: LD_INT 1
62585: NEG
62586: PUSH
62587: LD_INT 4
62589: NEG
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PUSH
62595: LD_INT 1
62597: NEG
62598: PUSH
62599: LD_INT 5
62601: NEG
62602: PUSH
62603: EMPTY
62604: LIST
62605: LIST
62606: PUSH
62607: LD_INT 2
62609: PUSH
62610: LD_INT 3
62612: NEG
62613: PUSH
62614: EMPTY
62615: LIST
62616: LIST
62617: PUSH
62618: LD_INT 2
62620: NEG
62621: PUSH
62622: LD_INT 5
62624: NEG
62625: PUSH
62626: EMPTY
62627: LIST
62628: LIST
62629: PUSH
62630: LD_INT 3
62632: PUSH
62633: LD_INT 0
62635: PUSH
62636: EMPTY
62637: LIST
62638: LIST
62639: PUSH
62640: LD_INT 3
62642: PUSH
62643: LD_INT 1
62645: NEG
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: PUSH
62651: LD_INT 4
62653: PUSH
62654: LD_INT 0
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: PUSH
62661: LD_INT 4
62663: PUSH
62664: LD_INT 1
62666: PUSH
62667: EMPTY
62668: LIST
62669: LIST
62670: PUSH
62671: LD_INT 3
62673: PUSH
62674: LD_INT 1
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PUSH
62681: LD_INT 2
62683: PUSH
62684: LD_INT 0
62686: PUSH
62687: EMPTY
62688: LIST
62689: LIST
62690: PUSH
62691: LD_INT 2
62693: PUSH
62694: LD_INT 1
62696: NEG
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: LD_INT 2
62704: PUSH
62705: LD_INT 2
62707: NEG
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PUSH
62713: LD_INT 4
62715: PUSH
62716: LD_INT 2
62718: PUSH
62719: EMPTY
62720: LIST
62721: LIST
62722: PUSH
62723: LD_INT 4
62725: PUSH
62726: LD_INT 4
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 4
62735: PUSH
62736: LD_INT 3
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: LD_INT 5
62745: PUSH
62746: LD_INT 4
62748: PUSH
62749: EMPTY
62750: LIST
62751: LIST
62752: PUSH
62753: LD_INT 5
62755: PUSH
62756: LD_INT 5
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: PUSH
62763: LD_INT 4
62765: PUSH
62766: LD_INT 5
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: LD_INT 3
62775: PUSH
62776: LD_INT 4
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: PUSH
62783: LD_INT 3
62785: PUSH
62786: LD_INT 3
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: PUSH
62793: LD_INT 5
62795: PUSH
62796: LD_INT 3
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: PUSH
62803: LD_INT 3
62805: PUSH
62806: LD_INT 5
62808: PUSH
62809: EMPTY
62810: LIST
62811: LIST
62812: PUSH
62813: LD_INT 0
62815: PUSH
62816: LD_INT 3
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: LD_INT 0
62825: PUSH
62826: LD_INT 2
62828: PUSH
62829: EMPTY
62830: LIST
62831: LIST
62832: PUSH
62833: LD_INT 1
62835: PUSH
62836: LD_INT 3
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: PUSH
62843: LD_INT 1
62845: PUSH
62846: LD_INT 4
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: PUSH
62853: LD_INT 0
62855: PUSH
62856: LD_INT 4
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: PUSH
62863: LD_INT 1
62865: NEG
62866: PUSH
62867: LD_INT 3
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: PUSH
62874: LD_INT 1
62876: NEG
62877: PUSH
62878: LD_INT 2
62880: PUSH
62881: EMPTY
62882: LIST
62883: LIST
62884: PUSH
62885: LD_INT 2
62887: PUSH
62888: LD_INT 4
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PUSH
62895: LD_INT 2
62897: NEG
62898: PUSH
62899: LD_INT 2
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 4
62908: NEG
62909: PUSH
62910: LD_INT 0
62912: PUSH
62913: EMPTY
62914: LIST
62915: LIST
62916: PUSH
62917: LD_INT 4
62919: NEG
62920: PUSH
62921: LD_INT 1
62923: NEG
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PUSH
62929: LD_INT 3
62931: NEG
62932: PUSH
62933: LD_INT 0
62935: PUSH
62936: EMPTY
62937: LIST
62938: LIST
62939: PUSH
62940: LD_INT 3
62942: NEG
62943: PUSH
62944: LD_INT 1
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: PUSH
62951: LD_INT 4
62953: NEG
62954: PUSH
62955: LD_INT 1
62957: PUSH
62958: EMPTY
62959: LIST
62960: LIST
62961: PUSH
62962: LD_INT 5
62964: NEG
62965: PUSH
62966: LD_INT 0
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: PUSH
62973: LD_INT 5
62975: NEG
62976: PUSH
62977: LD_INT 1
62979: NEG
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: PUSH
62985: LD_INT 5
62987: NEG
62988: PUSH
62989: LD_INT 2
62991: NEG
62992: PUSH
62993: EMPTY
62994: LIST
62995: LIST
62996: PUSH
62997: LD_INT 3
62999: NEG
63000: PUSH
63001: LD_INT 2
63003: PUSH
63004: EMPTY
63005: LIST
63006: LIST
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: LIST
63033: LIST
63034: LIST
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: LIST
63040: LIST
63041: LIST
63042: LIST
63043: LIST
63044: LIST
63045: LIST
63046: LIST
63047: LIST
63048: LIST
63049: LIST
63050: LIST
63051: LIST
63052: LIST
63053: LIST
63054: ST_TO_ADDR
// end ; end ;
63055: GO 63058
63057: POP
// case btype of b_depot , b_warehouse :
63058: LD_VAR 0 1
63062: PUSH
63063: LD_INT 0
63065: DOUBLE
63066: EQUAL
63067: IFTRUE 63077
63069: LD_INT 1
63071: DOUBLE
63072: EQUAL
63073: IFTRUE 63077
63075: GO 63278
63077: POP
// case nation of nation_american :
63078: LD_VAR 0 5
63082: PUSH
63083: LD_INT 1
63085: DOUBLE
63086: EQUAL
63087: IFTRUE 63091
63089: GO 63147
63091: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
63092: LD_ADDR_VAR 0 9
63096: PUSH
63097: LD_VAR 0 11
63101: PUSH
63102: LD_VAR 0 12
63106: PUSH
63107: LD_VAR 0 13
63111: PUSH
63112: LD_VAR 0 14
63116: PUSH
63117: LD_VAR 0 15
63121: PUSH
63122: LD_VAR 0 16
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: LIST
63134: PUSH
63135: LD_VAR 0 4
63139: PUSH
63140: LD_INT 1
63142: PLUS
63143: ARRAY
63144: ST_TO_ADDR
63145: GO 63276
63147: LD_INT 2
63149: DOUBLE
63150: EQUAL
63151: IFTRUE 63155
63153: GO 63211
63155: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
63156: LD_ADDR_VAR 0 9
63160: PUSH
63161: LD_VAR 0 17
63165: PUSH
63166: LD_VAR 0 18
63170: PUSH
63171: LD_VAR 0 19
63175: PUSH
63176: LD_VAR 0 20
63180: PUSH
63181: LD_VAR 0 21
63185: PUSH
63186: LD_VAR 0 22
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: LIST
63195: LIST
63196: LIST
63197: LIST
63198: PUSH
63199: LD_VAR 0 4
63203: PUSH
63204: LD_INT 1
63206: PLUS
63207: ARRAY
63208: ST_TO_ADDR
63209: GO 63276
63211: LD_INT 3
63213: DOUBLE
63214: EQUAL
63215: IFTRUE 63219
63217: GO 63275
63219: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
63220: LD_ADDR_VAR 0 9
63224: PUSH
63225: LD_VAR 0 23
63229: PUSH
63230: LD_VAR 0 24
63234: PUSH
63235: LD_VAR 0 25
63239: PUSH
63240: LD_VAR 0 26
63244: PUSH
63245: LD_VAR 0 27
63249: PUSH
63250: LD_VAR 0 28
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: PUSH
63263: LD_VAR 0 4
63267: PUSH
63268: LD_INT 1
63270: PLUS
63271: ARRAY
63272: ST_TO_ADDR
63273: GO 63276
63275: POP
63276: GO 63825
63278: LD_INT 2
63280: DOUBLE
63281: EQUAL
63282: IFTRUE 63292
63284: LD_INT 3
63286: DOUBLE
63287: EQUAL
63288: IFTRUE 63292
63290: GO 63348
63292: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
63293: LD_ADDR_VAR 0 9
63297: PUSH
63298: LD_VAR 0 29
63302: PUSH
63303: LD_VAR 0 30
63307: PUSH
63308: LD_VAR 0 31
63312: PUSH
63313: LD_VAR 0 32
63317: PUSH
63318: LD_VAR 0 33
63322: PUSH
63323: LD_VAR 0 34
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: PUSH
63336: LD_VAR 0 4
63340: PUSH
63341: LD_INT 1
63343: PLUS
63344: ARRAY
63345: ST_TO_ADDR
63346: GO 63825
63348: LD_INT 16
63350: DOUBLE
63351: EQUAL
63352: IFTRUE 63404
63354: LD_INT 17
63356: DOUBLE
63357: EQUAL
63358: IFTRUE 63404
63360: LD_INT 18
63362: DOUBLE
63363: EQUAL
63364: IFTRUE 63404
63366: LD_INT 19
63368: DOUBLE
63369: EQUAL
63370: IFTRUE 63404
63372: LD_INT 20
63374: DOUBLE
63375: EQUAL
63376: IFTRUE 63404
63378: LD_INT 21
63380: DOUBLE
63381: EQUAL
63382: IFTRUE 63404
63384: LD_INT 23
63386: DOUBLE
63387: EQUAL
63388: IFTRUE 63404
63390: LD_INT 24
63392: DOUBLE
63393: EQUAL
63394: IFTRUE 63404
63396: LD_INT 25
63398: DOUBLE
63399: EQUAL
63400: IFTRUE 63404
63402: GO 63460
63404: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
63405: LD_ADDR_VAR 0 9
63409: PUSH
63410: LD_VAR 0 35
63414: PUSH
63415: LD_VAR 0 36
63419: PUSH
63420: LD_VAR 0 37
63424: PUSH
63425: LD_VAR 0 38
63429: PUSH
63430: LD_VAR 0 39
63434: PUSH
63435: LD_VAR 0 40
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: LIST
63444: LIST
63445: LIST
63446: LIST
63447: PUSH
63448: LD_VAR 0 4
63452: PUSH
63453: LD_INT 1
63455: PLUS
63456: ARRAY
63457: ST_TO_ADDR
63458: GO 63825
63460: LD_INT 6
63462: DOUBLE
63463: EQUAL
63464: IFTRUE 63516
63466: LD_INT 7
63468: DOUBLE
63469: EQUAL
63470: IFTRUE 63516
63472: LD_INT 8
63474: DOUBLE
63475: EQUAL
63476: IFTRUE 63516
63478: LD_INT 13
63480: DOUBLE
63481: EQUAL
63482: IFTRUE 63516
63484: LD_INT 12
63486: DOUBLE
63487: EQUAL
63488: IFTRUE 63516
63490: LD_INT 15
63492: DOUBLE
63493: EQUAL
63494: IFTRUE 63516
63496: LD_INT 11
63498: DOUBLE
63499: EQUAL
63500: IFTRUE 63516
63502: LD_INT 14
63504: DOUBLE
63505: EQUAL
63506: IFTRUE 63516
63508: LD_INT 10
63510: DOUBLE
63511: EQUAL
63512: IFTRUE 63516
63514: GO 63572
63516: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
63517: LD_ADDR_VAR 0 9
63521: PUSH
63522: LD_VAR 0 41
63526: PUSH
63527: LD_VAR 0 42
63531: PUSH
63532: LD_VAR 0 43
63536: PUSH
63537: LD_VAR 0 44
63541: PUSH
63542: LD_VAR 0 45
63546: PUSH
63547: LD_VAR 0 46
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: PUSH
63560: LD_VAR 0 4
63564: PUSH
63565: LD_INT 1
63567: PLUS
63568: ARRAY
63569: ST_TO_ADDR
63570: GO 63825
63572: LD_INT 36
63574: DOUBLE
63575: EQUAL
63576: IFTRUE 63580
63578: GO 63636
63580: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
63581: LD_ADDR_VAR 0 9
63585: PUSH
63586: LD_VAR 0 47
63590: PUSH
63591: LD_VAR 0 48
63595: PUSH
63596: LD_VAR 0 49
63600: PUSH
63601: LD_VAR 0 50
63605: PUSH
63606: LD_VAR 0 51
63610: PUSH
63611: LD_VAR 0 52
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: PUSH
63624: LD_VAR 0 4
63628: PUSH
63629: LD_INT 1
63631: PLUS
63632: ARRAY
63633: ST_TO_ADDR
63634: GO 63825
63636: LD_INT 4
63638: DOUBLE
63639: EQUAL
63640: IFTRUE 63662
63642: LD_INT 5
63644: DOUBLE
63645: EQUAL
63646: IFTRUE 63662
63648: LD_INT 34
63650: DOUBLE
63651: EQUAL
63652: IFTRUE 63662
63654: LD_INT 37
63656: DOUBLE
63657: EQUAL
63658: IFTRUE 63662
63660: GO 63718
63662: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
63663: LD_ADDR_VAR 0 9
63667: PUSH
63668: LD_VAR 0 53
63672: PUSH
63673: LD_VAR 0 54
63677: PUSH
63678: LD_VAR 0 55
63682: PUSH
63683: LD_VAR 0 56
63687: PUSH
63688: LD_VAR 0 57
63692: PUSH
63693: LD_VAR 0 58
63697: PUSH
63698: EMPTY
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: PUSH
63706: LD_VAR 0 4
63710: PUSH
63711: LD_INT 1
63713: PLUS
63714: ARRAY
63715: ST_TO_ADDR
63716: GO 63825
63718: LD_INT 31
63720: DOUBLE
63721: EQUAL
63722: IFTRUE 63768
63724: LD_INT 32
63726: DOUBLE
63727: EQUAL
63728: IFTRUE 63768
63730: LD_INT 33
63732: DOUBLE
63733: EQUAL
63734: IFTRUE 63768
63736: LD_INT 27
63738: DOUBLE
63739: EQUAL
63740: IFTRUE 63768
63742: LD_INT 26
63744: DOUBLE
63745: EQUAL
63746: IFTRUE 63768
63748: LD_INT 28
63750: DOUBLE
63751: EQUAL
63752: IFTRUE 63768
63754: LD_INT 29
63756: DOUBLE
63757: EQUAL
63758: IFTRUE 63768
63760: LD_INT 30
63762: DOUBLE
63763: EQUAL
63764: IFTRUE 63768
63766: GO 63824
63768: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
63769: LD_ADDR_VAR 0 9
63773: PUSH
63774: LD_VAR 0 59
63778: PUSH
63779: LD_VAR 0 60
63783: PUSH
63784: LD_VAR 0 61
63788: PUSH
63789: LD_VAR 0 62
63793: PUSH
63794: LD_VAR 0 63
63798: PUSH
63799: LD_VAR 0 64
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: LIST
63808: LIST
63809: LIST
63810: LIST
63811: PUSH
63812: LD_VAR 0 4
63816: PUSH
63817: LD_INT 1
63819: PLUS
63820: ARRAY
63821: ST_TO_ADDR
63822: GO 63825
63824: POP
// temp_list2 = [ ] ;
63825: LD_ADDR_VAR 0 10
63829: PUSH
63830: EMPTY
63831: ST_TO_ADDR
// for i in temp_list do
63832: LD_ADDR_VAR 0 8
63836: PUSH
63837: LD_VAR 0 9
63841: PUSH
63842: FOR_IN
63843: IFFALSE 63895
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
63845: LD_ADDR_VAR 0 10
63849: PUSH
63850: LD_VAR 0 10
63854: PUSH
63855: LD_VAR 0 8
63859: PUSH
63860: LD_INT 1
63862: ARRAY
63863: PUSH
63864: LD_VAR 0 2
63868: PLUS
63869: PUSH
63870: LD_VAR 0 8
63874: PUSH
63875: LD_INT 2
63877: ARRAY
63878: PUSH
63879: LD_VAR 0 3
63883: PLUS
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PUSH
63889: EMPTY
63890: LIST
63891: ADD
63892: ST_TO_ADDR
63893: GO 63842
63895: POP
63896: POP
// result = temp_list2 ;
63897: LD_ADDR_VAR 0 7
63901: PUSH
63902: LD_VAR 0 10
63906: ST_TO_ADDR
// end ;
63907: LD_VAR 0 7
63911: RET
// export function EnemyInRange ( unit , dist ) ; begin
63912: LD_INT 0
63914: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
63915: LD_ADDR_VAR 0 3
63919: PUSH
63920: LD_VAR 0 1
63924: PPUSH
63925: CALL_OW 255
63929: PPUSH
63930: LD_VAR 0 1
63934: PPUSH
63935: CALL_OW 250
63939: PPUSH
63940: LD_VAR 0 1
63944: PPUSH
63945: CALL_OW 251
63949: PPUSH
63950: LD_VAR 0 2
63954: PPUSH
63955: CALL 38040 0 4
63959: PUSH
63960: LD_INT 4
63962: ARRAY
63963: ST_TO_ADDR
// end ;
63964: LD_VAR 0 3
63968: RET
// export function PlayerSeeMe ( unit ) ; begin
63969: LD_INT 0
63971: PPUSH
// result := See ( your_side , unit ) ;
63972: LD_ADDR_VAR 0 2
63976: PUSH
63977: LD_OWVAR 2
63981: PPUSH
63982: LD_VAR 0 1
63986: PPUSH
63987: CALL_OW 292
63991: ST_TO_ADDR
// end ;
63992: LD_VAR 0 2
63996: RET
// export function ReverseDir ( unit ) ; begin
63997: LD_INT 0
63999: PPUSH
// if not unit then
64000: LD_VAR 0 1
64004: NOT
64005: IFFALSE 64009
// exit ;
64007: GO 64055
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
64009: LD_ADDR_VAR 0 2
64013: PUSH
64014: LD_INT 3
64016: PUSH
64017: LD_INT 4
64019: PUSH
64020: LD_INT 5
64022: PUSH
64023: LD_INT 0
64025: PUSH
64026: LD_INT 1
64028: PUSH
64029: LD_INT 2
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: LIST
64036: LIST
64037: LIST
64038: LIST
64039: PUSH
64040: LD_VAR 0 1
64044: PPUSH
64045: CALL_OW 254
64049: PUSH
64050: LD_INT 1
64052: PLUS
64053: ARRAY
64054: ST_TO_ADDR
// end ;
64055: LD_VAR 0 2
64059: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
64060: LD_INT 0
64062: PPUSH
64063: PPUSH
64064: PPUSH
64065: PPUSH
64066: PPUSH
// if not hexes then
64067: LD_VAR 0 2
64071: NOT
64072: IFFALSE 64076
// exit ;
64074: GO 64224
// dist := 9999 ;
64076: LD_ADDR_VAR 0 5
64080: PUSH
64081: LD_INT 9999
64083: ST_TO_ADDR
// for i = 1 to hexes do
64084: LD_ADDR_VAR 0 4
64088: PUSH
64089: DOUBLE
64090: LD_INT 1
64092: DEC
64093: ST_TO_ADDR
64094: LD_VAR 0 2
64098: PUSH
64099: FOR_TO
64100: IFFALSE 64212
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
64102: LD_VAR 0 1
64106: PPUSH
64107: LD_VAR 0 2
64111: PUSH
64112: LD_VAR 0 4
64116: ARRAY
64117: PUSH
64118: LD_INT 1
64120: ARRAY
64121: PPUSH
64122: LD_VAR 0 2
64126: PUSH
64127: LD_VAR 0 4
64131: ARRAY
64132: PUSH
64133: LD_INT 2
64135: ARRAY
64136: PPUSH
64137: CALL_OW 297
64141: PUSH
64142: LD_VAR 0 5
64146: LESS
64147: IFFALSE 64210
// begin hex := hexes [ i ] ;
64149: LD_ADDR_VAR 0 7
64153: PUSH
64154: LD_VAR 0 2
64158: PUSH
64159: LD_VAR 0 4
64163: ARRAY
64164: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64165: LD_ADDR_VAR 0 5
64169: PUSH
64170: LD_VAR 0 1
64174: PPUSH
64175: LD_VAR 0 2
64179: PUSH
64180: LD_VAR 0 4
64184: ARRAY
64185: PUSH
64186: LD_INT 1
64188: ARRAY
64189: PPUSH
64190: LD_VAR 0 2
64194: PUSH
64195: LD_VAR 0 4
64199: ARRAY
64200: PUSH
64201: LD_INT 2
64203: ARRAY
64204: PPUSH
64205: CALL_OW 297
64209: ST_TO_ADDR
// end ; end ;
64210: GO 64099
64212: POP
64213: POP
// result := hex ;
64214: LD_ADDR_VAR 0 3
64218: PUSH
64219: LD_VAR 0 7
64223: ST_TO_ADDR
// end ;
64224: LD_VAR 0 3
64228: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
64229: LD_INT 0
64231: PPUSH
64232: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
64233: LD_VAR 0 1
64237: NOT
64238: PUSH
64239: LD_VAR 0 1
64243: PUSH
64244: LD_INT 21
64246: PUSH
64247: LD_INT 2
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: PUSH
64254: LD_INT 23
64256: PUSH
64257: LD_INT 2
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: PPUSH
64268: CALL_OW 69
64272: IN
64273: NOT
64274: OR
64275: IFFALSE 64279
// exit ;
64277: GO 64326
// for i = 1 to 3 do
64279: LD_ADDR_VAR 0 3
64283: PUSH
64284: DOUBLE
64285: LD_INT 1
64287: DEC
64288: ST_TO_ADDR
64289: LD_INT 3
64291: PUSH
64292: FOR_TO
64293: IFFALSE 64324
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
64295: LD_VAR 0 1
64299: PPUSH
64300: CALL_OW 250
64304: PPUSH
64305: LD_VAR 0 1
64309: PPUSH
64310: CALL_OW 251
64314: PPUSH
64315: LD_INT 1
64317: PPUSH
64318: CALL_OW 453
64322: GO 64292
64324: POP
64325: POP
// end ;
64326: LD_VAR 0 2
64330: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
64331: LD_INT 0
64333: PPUSH
64334: PPUSH
64335: PPUSH
64336: PPUSH
64337: PPUSH
64338: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
64339: LD_VAR 0 1
64343: NOT
64344: PUSH
64345: LD_VAR 0 2
64349: NOT
64350: OR
64351: PUSH
64352: LD_VAR 0 1
64356: PPUSH
64357: CALL_OW 314
64361: OR
64362: IFFALSE 64366
// exit ;
64364: GO 64807
// x := GetX ( enemy_unit ) ;
64366: LD_ADDR_VAR 0 7
64370: PUSH
64371: LD_VAR 0 2
64375: PPUSH
64376: CALL_OW 250
64380: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
64381: LD_ADDR_VAR 0 8
64385: PUSH
64386: LD_VAR 0 2
64390: PPUSH
64391: CALL_OW 251
64395: ST_TO_ADDR
// if not x or not y then
64396: LD_VAR 0 7
64400: NOT
64401: PUSH
64402: LD_VAR 0 8
64406: NOT
64407: OR
64408: IFFALSE 64412
// exit ;
64410: GO 64807
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
64412: LD_ADDR_VAR 0 6
64416: PUSH
64417: LD_VAR 0 7
64421: PPUSH
64422: LD_INT 0
64424: PPUSH
64425: LD_INT 4
64427: PPUSH
64428: CALL_OW 272
64432: PUSH
64433: LD_VAR 0 8
64437: PPUSH
64438: LD_INT 0
64440: PPUSH
64441: LD_INT 4
64443: PPUSH
64444: CALL_OW 273
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_VAR 0 7
64457: PPUSH
64458: LD_INT 1
64460: PPUSH
64461: LD_INT 4
64463: PPUSH
64464: CALL_OW 272
64468: PUSH
64469: LD_VAR 0 8
64473: PPUSH
64474: LD_INT 1
64476: PPUSH
64477: LD_INT 4
64479: PPUSH
64480: CALL_OW 273
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: PUSH
64489: LD_VAR 0 7
64493: PPUSH
64494: LD_INT 2
64496: PPUSH
64497: LD_INT 4
64499: PPUSH
64500: CALL_OW 272
64504: PUSH
64505: LD_VAR 0 8
64509: PPUSH
64510: LD_INT 2
64512: PPUSH
64513: LD_INT 4
64515: PPUSH
64516: CALL_OW 273
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_VAR 0 7
64529: PPUSH
64530: LD_INT 3
64532: PPUSH
64533: LD_INT 4
64535: PPUSH
64536: CALL_OW 272
64540: PUSH
64541: LD_VAR 0 8
64545: PPUSH
64546: LD_INT 3
64548: PPUSH
64549: LD_INT 4
64551: PPUSH
64552: CALL_OW 273
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_VAR 0 7
64565: PPUSH
64566: LD_INT 4
64568: PPUSH
64569: LD_INT 4
64571: PPUSH
64572: CALL_OW 272
64576: PUSH
64577: LD_VAR 0 8
64581: PPUSH
64582: LD_INT 4
64584: PPUSH
64585: LD_INT 4
64587: PPUSH
64588: CALL_OW 273
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_VAR 0 7
64601: PPUSH
64602: LD_INT 5
64604: PPUSH
64605: LD_INT 4
64607: PPUSH
64608: CALL_OW 272
64612: PUSH
64613: LD_VAR 0 8
64617: PPUSH
64618: LD_INT 5
64620: PPUSH
64621: LD_INT 4
64623: PPUSH
64624: CALL_OW 273
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: LIST
64640: ST_TO_ADDR
// for i = tmp downto 1 do
64641: LD_ADDR_VAR 0 4
64645: PUSH
64646: DOUBLE
64647: LD_VAR 0 6
64651: INC
64652: ST_TO_ADDR
64653: LD_INT 1
64655: PUSH
64656: FOR_DOWNTO
64657: IFFALSE 64758
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
64659: LD_VAR 0 6
64663: PUSH
64664: LD_VAR 0 4
64668: ARRAY
64669: PUSH
64670: LD_INT 1
64672: ARRAY
64673: PPUSH
64674: LD_VAR 0 6
64678: PUSH
64679: LD_VAR 0 4
64683: ARRAY
64684: PUSH
64685: LD_INT 2
64687: ARRAY
64688: PPUSH
64689: CALL_OW 488
64693: NOT
64694: PUSH
64695: LD_VAR 0 6
64699: PUSH
64700: LD_VAR 0 4
64704: ARRAY
64705: PUSH
64706: LD_INT 1
64708: ARRAY
64709: PPUSH
64710: LD_VAR 0 6
64714: PUSH
64715: LD_VAR 0 4
64719: ARRAY
64720: PUSH
64721: LD_INT 2
64723: ARRAY
64724: PPUSH
64725: CALL_OW 428
64729: PUSH
64730: LD_INT 0
64732: NONEQUAL
64733: OR
64734: IFFALSE 64756
// tmp := Delete ( tmp , i ) ;
64736: LD_ADDR_VAR 0 6
64740: PUSH
64741: LD_VAR 0 6
64745: PPUSH
64746: LD_VAR 0 4
64750: PPUSH
64751: CALL_OW 3
64755: ST_TO_ADDR
64756: GO 64656
64758: POP
64759: POP
// j := GetClosestHex ( unit , tmp ) ;
64760: LD_ADDR_VAR 0 5
64764: PUSH
64765: LD_VAR 0 1
64769: PPUSH
64770: LD_VAR 0 6
64774: PPUSH
64775: CALL 64060 0 2
64779: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
64780: LD_VAR 0 1
64784: PPUSH
64785: LD_VAR 0 5
64789: PUSH
64790: LD_INT 1
64792: ARRAY
64793: PPUSH
64794: LD_VAR 0 5
64798: PUSH
64799: LD_INT 2
64801: ARRAY
64802: PPUSH
64803: CALL_OW 111
// end ;
64807: LD_VAR 0 3
64811: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
64812: LD_INT 0
64814: PPUSH
64815: PPUSH
64816: PPUSH
// uc_side = 0 ;
64817: LD_ADDR_OWVAR 20
64821: PUSH
64822: LD_INT 0
64824: ST_TO_ADDR
// uc_nation = 0 ;
64825: LD_ADDR_OWVAR 21
64829: PUSH
64830: LD_INT 0
64832: ST_TO_ADDR
// InitHc ;
64833: CALL_OW 19
// InitVc ;
64837: CALL_OW 20
// if mastodonts then
64841: LD_VAR 0 6
64845: IFFALSE 64912
// for i = 1 to mastodonts do
64847: LD_ADDR_VAR 0 11
64851: PUSH
64852: DOUBLE
64853: LD_INT 1
64855: DEC
64856: ST_TO_ADDR
64857: LD_VAR 0 6
64861: PUSH
64862: FOR_TO
64863: IFFALSE 64910
// begin vc_chassis := 31 ;
64865: LD_ADDR_OWVAR 37
64869: PUSH
64870: LD_INT 31
64872: ST_TO_ADDR
// vc_control := control_rider ;
64873: LD_ADDR_OWVAR 38
64877: PUSH
64878: LD_INT 4
64880: ST_TO_ADDR
// animal := CreateVehicle ;
64881: LD_ADDR_VAR 0 12
64885: PUSH
64886: CALL_OW 45
64890: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
64891: LD_VAR 0 12
64895: PPUSH
64896: LD_VAR 0 8
64900: PPUSH
64901: LD_INT 0
64903: PPUSH
64904: CALL 71618 0 3
// end ;
64908: GO 64862
64910: POP
64911: POP
// if horses then
64912: LD_VAR 0 5
64916: IFFALSE 64983
// for i = 1 to horses do
64918: LD_ADDR_VAR 0 11
64922: PUSH
64923: DOUBLE
64924: LD_INT 1
64926: DEC
64927: ST_TO_ADDR
64928: LD_VAR 0 5
64932: PUSH
64933: FOR_TO
64934: IFFALSE 64981
// begin hc_class := 21 ;
64936: LD_ADDR_OWVAR 28
64940: PUSH
64941: LD_INT 21
64943: ST_TO_ADDR
// hc_gallery :=  ;
64944: LD_ADDR_OWVAR 33
64948: PUSH
64949: LD_STRING 
64951: ST_TO_ADDR
// animal := CreateHuman ;
64952: LD_ADDR_VAR 0 12
64956: PUSH
64957: CALL_OW 44
64961: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
64962: LD_VAR 0 12
64966: PPUSH
64967: LD_VAR 0 8
64971: PPUSH
64972: LD_INT 0
64974: PPUSH
64975: CALL 71618 0 3
// end ;
64979: GO 64933
64981: POP
64982: POP
// if birds then
64983: LD_VAR 0 1
64987: IFFALSE 65054
// for i = 1 to birds do
64989: LD_ADDR_VAR 0 11
64993: PUSH
64994: DOUBLE
64995: LD_INT 1
64997: DEC
64998: ST_TO_ADDR
64999: LD_VAR 0 1
65003: PUSH
65004: FOR_TO
65005: IFFALSE 65052
// begin hc_class = 18 ;
65007: LD_ADDR_OWVAR 28
65011: PUSH
65012: LD_INT 18
65014: ST_TO_ADDR
// hc_gallery =  ;
65015: LD_ADDR_OWVAR 33
65019: PUSH
65020: LD_STRING 
65022: ST_TO_ADDR
// animal := CreateHuman ;
65023: LD_ADDR_VAR 0 12
65027: PUSH
65028: CALL_OW 44
65032: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65033: LD_VAR 0 12
65037: PPUSH
65038: LD_VAR 0 8
65042: PPUSH
65043: LD_INT 0
65045: PPUSH
65046: CALL 71618 0 3
// end ;
65050: GO 65004
65052: POP
65053: POP
// if tigers then
65054: LD_VAR 0 2
65058: IFFALSE 65142
// for i = 1 to tigers do
65060: LD_ADDR_VAR 0 11
65064: PUSH
65065: DOUBLE
65066: LD_INT 1
65068: DEC
65069: ST_TO_ADDR
65070: LD_VAR 0 2
65074: PUSH
65075: FOR_TO
65076: IFFALSE 65140
// begin hc_class = class_tiger ;
65078: LD_ADDR_OWVAR 28
65082: PUSH
65083: LD_INT 14
65085: ST_TO_ADDR
// hc_gallery =  ;
65086: LD_ADDR_OWVAR 33
65090: PUSH
65091: LD_STRING 
65093: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
65094: LD_ADDR_OWVAR 35
65098: PUSH
65099: LD_INT 7
65101: NEG
65102: PPUSH
65103: LD_INT 7
65105: PPUSH
65106: CALL_OW 12
65110: ST_TO_ADDR
// animal := CreateHuman ;
65111: LD_ADDR_VAR 0 12
65115: PUSH
65116: CALL_OW 44
65120: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65121: LD_VAR 0 12
65125: PPUSH
65126: LD_VAR 0 8
65130: PPUSH
65131: LD_INT 0
65133: PPUSH
65134: CALL 71618 0 3
// end ;
65138: GO 65075
65140: POP
65141: POP
// if apemans then
65142: LD_VAR 0 3
65146: IFFALSE 65269
// for i = 1 to apemans do
65148: LD_ADDR_VAR 0 11
65152: PUSH
65153: DOUBLE
65154: LD_INT 1
65156: DEC
65157: ST_TO_ADDR
65158: LD_VAR 0 3
65162: PUSH
65163: FOR_TO
65164: IFFALSE 65267
// begin hc_class = class_apeman ;
65166: LD_ADDR_OWVAR 28
65170: PUSH
65171: LD_INT 12
65173: ST_TO_ADDR
// hc_gallery =  ;
65174: LD_ADDR_OWVAR 33
65178: PUSH
65179: LD_STRING 
65181: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
65182: LD_ADDR_OWVAR 35
65186: PUSH
65187: LD_INT 5
65189: NEG
65190: PPUSH
65191: LD_INT 5
65193: PPUSH
65194: CALL_OW 12
65198: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
65199: LD_ADDR_OWVAR 31
65203: PUSH
65204: LD_INT 1
65206: PPUSH
65207: LD_INT 3
65209: PPUSH
65210: CALL_OW 12
65214: PUSH
65215: LD_INT 1
65217: PPUSH
65218: LD_INT 3
65220: PPUSH
65221: CALL_OW 12
65225: PUSH
65226: LD_INT 0
65228: PUSH
65229: LD_INT 0
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: ST_TO_ADDR
// animal := CreateHuman ;
65238: LD_ADDR_VAR 0 12
65242: PUSH
65243: CALL_OW 44
65247: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65248: LD_VAR 0 12
65252: PPUSH
65253: LD_VAR 0 8
65257: PPUSH
65258: LD_INT 0
65260: PPUSH
65261: CALL 71618 0 3
// end ;
65265: GO 65163
65267: POP
65268: POP
// if enchidnas then
65269: LD_VAR 0 4
65273: IFFALSE 65340
// for i = 1 to enchidnas do
65275: LD_ADDR_VAR 0 11
65279: PUSH
65280: DOUBLE
65281: LD_INT 1
65283: DEC
65284: ST_TO_ADDR
65285: LD_VAR 0 4
65289: PUSH
65290: FOR_TO
65291: IFFALSE 65338
// begin hc_class = 13 ;
65293: LD_ADDR_OWVAR 28
65297: PUSH
65298: LD_INT 13
65300: ST_TO_ADDR
// hc_gallery =  ;
65301: LD_ADDR_OWVAR 33
65305: PUSH
65306: LD_STRING 
65308: ST_TO_ADDR
// animal := CreateHuman ;
65309: LD_ADDR_VAR 0 12
65313: PUSH
65314: CALL_OW 44
65318: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65319: LD_VAR 0 12
65323: PPUSH
65324: LD_VAR 0 8
65328: PPUSH
65329: LD_INT 0
65331: PPUSH
65332: CALL 71618 0 3
// end ;
65336: GO 65290
65338: POP
65339: POP
// if fishes then
65340: LD_VAR 0 7
65344: IFFALSE 65411
// for i = 1 to fishes do
65346: LD_ADDR_VAR 0 11
65350: PUSH
65351: DOUBLE
65352: LD_INT 1
65354: DEC
65355: ST_TO_ADDR
65356: LD_VAR 0 7
65360: PUSH
65361: FOR_TO
65362: IFFALSE 65409
// begin hc_class = 20 ;
65364: LD_ADDR_OWVAR 28
65368: PUSH
65369: LD_INT 20
65371: ST_TO_ADDR
// hc_gallery =  ;
65372: LD_ADDR_OWVAR 33
65376: PUSH
65377: LD_STRING 
65379: ST_TO_ADDR
// animal := CreateHuman ;
65380: LD_ADDR_VAR 0 12
65384: PUSH
65385: CALL_OW 44
65389: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
65390: LD_VAR 0 12
65394: PPUSH
65395: LD_VAR 0 9
65399: PPUSH
65400: LD_INT 0
65402: PPUSH
65403: CALL 71618 0 3
// end ;
65407: GO 65361
65409: POP
65410: POP
// end ;
65411: LD_VAR 0 10
65415: RET
// export function WantHeal ( sci , unit ) ; begin
65416: LD_INT 0
65418: PPUSH
// if GetTaskList ( sci ) > 0 then
65419: LD_VAR 0 1
65423: PPUSH
65424: CALL_OW 437
65428: PUSH
65429: LD_INT 0
65431: GREATER
65432: IFFALSE 65502
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
65434: LD_VAR 0 1
65438: PPUSH
65439: CALL_OW 437
65443: PUSH
65444: LD_INT 1
65446: ARRAY
65447: PUSH
65448: LD_INT 1
65450: ARRAY
65451: PUSH
65452: LD_STRING l
65454: EQUAL
65455: PUSH
65456: LD_VAR 0 1
65460: PPUSH
65461: CALL_OW 437
65465: PUSH
65466: LD_INT 1
65468: ARRAY
65469: PUSH
65470: LD_INT 4
65472: ARRAY
65473: PUSH
65474: LD_VAR 0 2
65478: EQUAL
65479: AND
65480: IFFALSE 65492
// result := true else
65482: LD_ADDR_VAR 0 3
65486: PUSH
65487: LD_INT 1
65489: ST_TO_ADDR
65490: GO 65500
// result := false ;
65492: LD_ADDR_VAR 0 3
65496: PUSH
65497: LD_INT 0
65499: ST_TO_ADDR
// end else
65500: GO 65510
// result := false ;
65502: LD_ADDR_VAR 0 3
65506: PUSH
65507: LD_INT 0
65509: ST_TO_ADDR
// end ;
65510: LD_VAR 0 3
65514: RET
// export function HealTarget ( sci ) ; begin
65515: LD_INT 0
65517: PPUSH
// if not sci then
65518: LD_VAR 0 1
65522: NOT
65523: IFFALSE 65527
// exit ;
65525: GO 65592
// result := 0 ;
65527: LD_ADDR_VAR 0 2
65531: PUSH
65532: LD_INT 0
65534: ST_TO_ADDR
// if GetTaskList ( sci ) then
65535: LD_VAR 0 1
65539: PPUSH
65540: CALL_OW 437
65544: IFFALSE 65592
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
65546: LD_VAR 0 1
65550: PPUSH
65551: CALL_OW 437
65555: PUSH
65556: LD_INT 1
65558: ARRAY
65559: PUSH
65560: LD_INT 1
65562: ARRAY
65563: PUSH
65564: LD_STRING l
65566: EQUAL
65567: IFFALSE 65592
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
65569: LD_ADDR_VAR 0 2
65573: PUSH
65574: LD_VAR 0 1
65578: PPUSH
65579: CALL_OW 437
65583: PUSH
65584: LD_INT 1
65586: ARRAY
65587: PUSH
65588: LD_INT 4
65590: ARRAY
65591: ST_TO_ADDR
// end ;
65592: LD_VAR 0 2
65596: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
65597: LD_INT 0
65599: PPUSH
65600: PPUSH
65601: PPUSH
65602: PPUSH
65603: PPUSH
65604: PPUSH
65605: PPUSH
65606: PPUSH
65607: PPUSH
65608: PPUSH
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
65613: PPUSH
65614: PPUSH
65615: PPUSH
65616: PPUSH
65617: PPUSH
65618: PPUSH
65619: PPUSH
65620: PPUSH
65621: PPUSH
65622: PPUSH
65623: PPUSH
65624: PPUSH
65625: PPUSH
65626: PPUSH
65627: PPUSH
65628: PPUSH
65629: PPUSH
65630: PPUSH
65631: PPUSH
// if not list then
65632: LD_VAR 0 1
65636: NOT
65637: IFFALSE 65641
// exit ;
65639: GO 70229
// base := list [ 1 ] ;
65641: LD_ADDR_VAR 0 3
65645: PUSH
65646: LD_VAR 0 1
65650: PUSH
65651: LD_INT 1
65653: ARRAY
65654: ST_TO_ADDR
// group := list [ 2 ] ;
65655: LD_ADDR_VAR 0 4
65659: PUSH
65660: LD_VAR 0 1
65664: PUSH
65665: LD_INT 2
65667: ARRAY
65668: ST_TO_ADDR
// path := list [ 3 ] ;
65669: LD_ADDR_VAR 0 5
65673: PUSH
65674: LD_VAR 0 1
65678: PUSH
65679: LD_INT 3
65681: ARRAY
65682: ST_TO_ADDR
// flags := list [ 4 ] ;
65683: LD_ADDR_VAR 0 6
65687: PUSH
65688: LD_VAR 0 1
65692: PUSH
65693: LD_INT 4
65695: ARRAY
65696: ST_TO_ADDR
// mined := [ ] ;
65697: LD_ADDR_VAR 0 27
65701: PUSH
65702: EMPTY
65703: ST_TO_ADDR
// bombed := [ ] ;
65704: LD_ADDR_VAR 0 28
65708: PUSH
65709: EMPTY
65710: ST_TO_ADDR
// healers := [ ] ;
65711: LD_ADDR_VAR 0 31
65715: PUSH
65716: EMPTY
65717: ST_TO_ADDR
// to_heal := [ ] ;
65718: LD_ADDR_VAR 0 30
65722: PUSH
65723: EMPTY
65724: ST_TO_ADDR
// repairs := [ ] ;
65725: LD_ADDR_VAR 0 33
65729: PUSH
65730: EMPTY
65731: ST_TO_ADDR
// to_repair := [ ] ;
65732: LD_ADDR_VAR 0 32
65736: PUSH
65737: EMPTY
65738: ST_TO_ADDR
// if not group or not path then
65739: LD_VAR 0 4
65743: NOT
65744: PUSH
65745: LD_VAR 0 5
65749: NOT
65750: OR
65751: IFFALSE 65755
// exit ;
65753: GO 70229
// if flags then
65755: LD_VAR 0 6
65759: IFFALSE 65903
// begin f_ignore_area := flags [ 1 ] ;
65761: LD_ADDR_VAR 0 17
65765: PUSH
65766: LD_VAR 0 6
65770: PUSH
65771: LD_INT 1
65773: ARRAY
65774: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
65775: LD_ADDR_VAR 0 18
65779: PUSH
65780: LD_VAR 0 6
65784: PUSH
65785: LD_INT 2
65787: ARRAY
65788: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
65789: LD_ADDR_VAR 0 19
65793: PUSH
65794: LD_VAR 0 6
65798: PUSH
65799: LD_INT 3
65801: ARRAY
65802: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
65803: LD_ADDR_VAR 0 20
65807: PUSH
65808: LD_VAR 0 6
65812: PUSH
65813: LD_INT 4
65815: ARRAY
65816: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
65817: LD_ADDR_VAR 0 21
65821: PUSH
65822: LD_VAR 0 6
65826: PUSH
65827: LD_INT 5
65829: ARRAY
65830: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
65831: LD_ADDR_VAR 0 22
65835: PUSH
65836: LD_VAR 0 6
65840: PUSH
65841: LD_INT 6
65843: ARRAY
65844: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
65845: LD_ADDR_VAR 0 23
65849: PUSH
65850: LD_VAR 0 6
65854: PUSH
65855: LD_INT 7
65857: ARRAY
65858: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
65859: LD_ADDR_VAR 0 24
65863: PUSH
65864: LD_VAR 0 6
65868: PUSH
65869: LD_INT 8
65871: ARRAY
65872: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
65873: LD_ADDR_VAR 0 25
65877: PUSH
65878: LD_VAR 0 6
65882: PUSH
65883: LD_INT 9
65885: ARRAY
65886: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
65887: LD_ADDR_VAR 0 26
65891: PUSH
65892: LD_VAR 0 6
65896: PUSH
65897: LD_INT 10
65899: ARRAY
65900: ST_TO_ADDR
// end else
65901: GO 65983
// begin f_ignore_area := false ;
65903: LD_ADDR_VAR 0 17
65907: PUSH
65908: LD_INT 0
65910: ST_TO_ADDR
// f_capture := false ;
65911: LD_ADDR_VAR 0 18
65915: PUSH
65916: LD_INT 0
65918: ST_TO_ADDR
// f_ignore_civ := false ;
65919: LD_ADDR_VAR 0 19
65923: PUSH
65924: LD_INT 0
65926: ST_TO_ADDR
// f_murder := false ;
65927: LD_ADDR_VAR 0 20
65931: PUSH
65932: LD_INT 0
65934: ST_TO_ADDR
// f_mines := false ;
65935: LD_ADDR_VAR 0 21
65939: PUSH
65940: LD_INT 0
65942: ST_TO_ADDR
// f_repair := false ;
65943: LD_ADDR_VAR 0 22
65947: PUSH
65948: LD_INT 0
65950: ST_TO_ADDR
// f_heal := false ;
65951: LD_ADDR_VAR 0 23
65955: PUSH
65956: LD_INT 0
65958: ST_TO_ADDR
// f_spacetime := false ;
65959: LD_ADDR_VAR 0 24
65963: PUSH
65964: LD_INT 0
65966: ST_TO_ADDR
// f_attack_depot := false ;
65967: LD_ADDR_VAR 0 25
65971: PUSH
65972: LD_INT 0
65974: ST_TO_ADDR
// f_crawl := false ;
65975: LD_ADDR_VAR 0 26
65979: PUSH
65980: LD_INT 0
65982: ST_TO_ADDR
// end ; if f_heal then
65983: LD_VAR 0 23
65987: IFFALSE 66014
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
65989: LD_ADDR_VAR 0 31
65993: PUSH
65994: LD_VAR 0 4
65998: PPUSH
65999: LD_INT 25
66001: PUSH
66002: LD_INT 4
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PPUSH
66009: CALL_OW 72
66013: ST_TO_ADDR
// if f_repair then
66014: LD_VAR 0 22
66018: IFFALSE 66045
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
66020: LD_ADDR_VAR 0 33
66024: PUSH
66025: LD_VAR 0 4
66029: PPUSH
66030: LD_INT 25
66032: PUSH
66033: LD_INT 3
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PPUSH
66040: CALL_OW 72
66044: ST_TO_ADDR
// units_path := [ ] ;
66045: LD_ADDR_VAR 0 16
66049: PUSH
66050: EMPTY
66051: ST_TO_ADDR
// for i = 1 to group do
66052: LD_ADDR_VAR 0 7
66056: PUSH
66057: DOUBLE
66058: LD_INT 1
66060: DEC
66061: ST_TO_ADDR
66062: LD_VAR 0 4
66066: PUSH
66067: FOR_TO
66068: IFFALSE 66097
// units_path := Replace ( units_path , i , path ) ;
66070: LD_ADDR_VAR 0 16
66074: PUSH
66075: LD_VAR 0 16
66079: PPUSH
66080: LD_VAR 0 7
66084: PPUSH
66085: LD_VAR 0 5
66089: PPUSH
66090: CALL_OW 1
66094: ST_TO_ADDR
66095: GO 66067
66097: POP
66098: POP
// repeat for i = group downto 1 do
66099: LD_ADDR_VAR 0 7
66103: PUSH
66104: DOUBLE
66105: LD_VAR 0 4
66109: INC
66110: ST_TO_ADDR
66111: LD_INT 1
66113: PUSH
66114: FOR_DOWNTO
66115: IFFALSE 70211
// begin wait ( 5 ) ;
66117: LD_INT 5
66119: PPUSH
66120: CALL_OW 67
// tmp := [ ] ;
66124: LD_ADDR_VAR 0 14
66128: PUSH
66129: EMPTY
66130: ST_TO_ADDR
// attacking := false ;
66131: LD_ADDR_VAR 0 29
66135: PUSH
66136: LD_INT 0
66138: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
66139: LD_VAR 0 4
66143: PUSH
66144: LD_VAR 0 7
66148: ARRAY
66149: PPUSH
66150: CALL_OW 301
66154: PUSH
66155: LD_VAR 0 4
66159: PUSH
66160: LD_VAR 0 7
66164: ARRAY
66165: NOT
66166: OR
66167: IFFALSE 66276
// begin if GetType ( group [ i ] ) = unit_human then
66169: LD_VAR 0 4
66173: PUSH
66174: LD_VAR 0 7
66178: ARRAY
66179: PPUSH
66180: CALL_OW 247
66184: PUSH
66185: LD_INT 1
66187: EQUAL
66188: IFFALSE 66234
// begin to_heal := to_heal diff group [ i ] ;
66190: LD_ADDR_VAR 0 30
66194: PUSH
66195: LD_VAR 0 30
66199: PUSH
66200: LD_VAR 0 4
66204: PUSH
66205: LD_VAR 0 7
66209: ARRAY
66210: DIFF
66211: ST_TO_ADDR
// healers := healers diff group [ i ] ;
66212: LD_ADDR_VAR 0 31
66216: PUSH
66217: LD_VAR 0 31
66221: PUSH
66222: LD_VAR 0 4
66226: PUSH
66227: LD_VAR 0 7
66231: ARRAY
66232: DIFF
66233: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
66234: LD_ADDR_VAR 0 4
66238: PUSH
66239: LD_VAR 0 4
66243: PPUSH
66244: LD_VAR 0 7
66248: PPUSH
66249: CALL_OW 3
66253: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
66254: LD_ADDR_VAR 0 16
66258: PUSH
66259: LD_VAR 0 16
66263: PPUSH
66264: LD_VAR 0 7
66268: PPUSH
66269: CALL_OW 3
66273: ST_TO_ADDR
// continue ;
66274: GO 66114
// end ; if f_repair then
66276: LD_VAR 0 22
66280: IFFALSE 66769
// begin if GetType ( group [ i ] ) = unit_vehicle then
66282: LD_VAR 0 4
66286: PUSH
66287: LD_VAR 0 7
66291: ARRAY
66292: PPUSH
66293: CALL_OW 247
66297: PUSH
66298: LD_INT 2
66300: EQUAL
66301: IFFALSE 66491
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
66303: LD_VAR 0 4
66307: PUSH
66308: LD_VAR 0 7
66312: ARRAY
66313: PPUSH
66314: CALL_OW 256
66318: PUSH
66319: LD_INT 700
66321: LESS
66322: PUSH
66323: LD_VAR 0 4
66327: PUSH
66328: LD_VAR 0 7
66332: ARRAY
66333: PUSH
66334: LD_VAR 0 32
66338: IN
66339: NOT
66340: AND
66341: IFFALSE 66365
// to_repair := to_repair union group [ i ] ;
66343: LD_ADDR_VAR 0 32
66347: PUSH
66348: LD_VAR 0 32
66352: PUSH
66353: LD_VAR 0 4
66357: PUSH
66358: LD_VAR 0 7
66362: ARRAY
66363: UNION
66364: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
66365: LD_VAR 0 4
66369: PUSH
66370: LD_VAR 0 7
66374: ARRAY
66375: PPUSH
66376: CALL_OW 256
66380: PUSH
66381: LD_INT 1000
66383: EQUAL
66384: PUSH
66385: LD_VAR 0 4
66389: PUSH
66390: LD_VAR 0 7
66394: ARRAY
66395: PUSH
66396: LD_VAR 0 32
66400: IN
66401: AND
66402: IFFALSE 66426
// to_repair := to_repair diff group [ i ] ;
66404: LD_ADDR_VAR 0 32
66408: PUSH
66409: LD_VAR 0 32
66413: PUSH
66414: LD_VAR 0 4
66418: PUSH
66419: LD_VAR 0 7
66423: ARRAY
66424: DIFF
66425: ST_TO_ADDR
// if group [ i ] in to_repair then
66426: LD_VAR 0 4
66430: PUSH
66431: LD_VAR 0 7
66435: ARRAY
66436: PUSH
66437: LD_VAR 0 32
66441: IN
66442: IFFALSE 66489
// begin if not IsInArea ( group [ i ] , f_repair ) then
66444: LD_VAR 0 4
66448: PUSH
66449: LD_VAR 0 7
66453: ARRAY
66454: PPUSH
66455: LD_VAR 0 22
66459: PPUSH
66460: CALL_OW 308
66464: NOT
66465: IFFALSE 66487
// ComMoveToArea ( group [ i ] , f_repair ) ;
66467: LD_VAR 0 4
66471: PUSH
66472: LD_VAR 0 7
66476: ARRAY
66477: PPUSH
66478: LD_VAR 0 22
66482: PPUSH
66483: CALL_OW 113
// continue ;
66487: GO 66114
// end ; end else
66489: GO 66769
// if group [ i ] in repairs then
66491: LD_VAR 0 4
66495: PUSH
66496: LD_VAR 0 7
66500: ARRAY
66501: PUSH
66502: LD_VAR 0 33
66506: IN
66507: IFFALSE 66769
// begin if IsInUnit ( group [ i ] ) then
66509: LD_VAR 0 4
66513: PUSH
66514: LD_VAR 0 7
66518: ARRAY
66519: PPUSH
66520: CALL_OW 310
66524: IFFALSE 66592
// begin z := IsInUnit ( group [ i ] ) ;
66526: LD_ADDR_VAR 0 13
66530: PUSH
66531: LD_VAR 0 4
66535: PUSH
66536: LD_VAR 0 7
66540: ARRAY
66541: PPUSH
66542: CALL_OW 310
66546: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
66547: LD_VAR 0 13
66551: PUSH
66552: LD_VAR 0 32
66556: IN
66557: PUSH
66558: LD_VAR 0 13
66562: PPUSH
66563: LD_VAR 0 22
66567: PPUSH
66568: CALL_OW 308
66572: AND
66573: IFFALSE 66590
// ComExitVehicle ( group [ i ] ) ;
66575: LD_VAR 0 4
66579: PUSH
66580: LD_VAR 0 7
66584: ARRAY
66585: PPUSH
66586: CALL_OW 121
// end else
66590: GO 66769
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
66592: LD_ADDR_VAR 0 13
66596: PUSH
66597: LD_VAR 0 4
66601: PPUSH
66602: LD_INT 95
66604: PUSH
66605: LD_VAR 0 22
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 58
66616: PUSH
66617: EMPTY
66618: LIST
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PPUSH
66624: CALL_OW 72
66628: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
66629: LD_VAR 0 4
66633: PUSH
66634: LD_VAR 0 7
66638: ARRAY
66639: PPUSH
66640: CALL_OW 314
66644: NOT
66645: IFFALSE 66767
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
66647: LD_ADDR_VAR 0 10
66651: PUSH
66652: LD_VAR 0 13
66656: PPUSH
66657: LD_VAR 0 4
66661: PUSH
66662: LD_VAR 0 7
66666: ARRAY
66667: PPUSH
66668: CALL_OW 74
66672: ST_TO_ADDR
// if not x then
66673: LD_VAR 0 10
66677: NOT
66678: IFFALSE 66682
// continue ;
66680: GO 66114
// if GetLives ( x ) < 1000 then
66682: LD_VAR 0 10
66686: PPUSH
66687: CALL_OW 256
66691: PUSH
66692: LD_INT 1000
66694: LESS
66695: IFFALSE 66719
// ComRepairVehicle ( group [ i ] , x ) else
66697: LD_VAR 0 4
66701: PUSH
66702: LD_VAR 0 7
66706: ARRAY
66707: PPUSH
66708: LD_VAR 0 10
66712: PPUSH
66713: CALL_OW 129
66717: GO 66767
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
66719: LD_VAR 0 23
66723: PUSH
66724: LD_VAR 0 4
66728: PUSH
66729: LD_VAR 0 7
66733: ARRAY
66734: PPUSH
66735: CALL_OW 256
66739: PUSH
66740: LD_INT 1000
66742: LESS
66743: AND
66744: NOT
66745: IFFALSE 66767
// ComEnterUnit ( group [ i ] , x ) ;
66747: LD_VAR 0 4
66751: PUSH
66752: LD_VAR 0 7
66756: ARRAY
66757: PPUSH
66758: LD_VAR 0 10
66762: PPUSH
66763: CALL_OW 120
// end ; continue ;
66767: GO 66114
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
66769: LD_VAR 0 23
66773: PUSH
66774: LD_VAR 0 4
66778: PUSH
66779: LD_VAR 0 7
66783: ARRAY
66784: PPUSH
66785: CALL_OW 247
66789: PUSH
66790: LD_INT 1
66792: EQUAL
66793: AND
66794: IFFALSE 67272
// begin if group [ i ] in healers then
66796: LD_VAR 0 4
66800: PUSH
66801: LD_VAR 0 7
66805: ARRAY
66806: PUSH
66807: LD_VAR 0 31
66811: IN
66812: IFFALSE 67085
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
66814: LD_VAR 0 4
66818: PUSH
66819: LD_VAR 0 7
66823: ARRAY
66824: PPUSH
66825: LD_VAR 0 23
66829: PPUSH
66830: CALL_OW 308
66834: NOT
66835: PUSH
66836: LD_VAR 0 4
66840: PUSH
66841: LD_VAR 0 7
66845: ARRAY
66846: PPUSH
66847: CALL_OW 314
66851: NOT
66852: AND
66853: IFFALSE 66877
// ComMoveToArea ( group [ i ] , f_heal ) else
66855: LD_VAR 0 4
66859: PUSH
66860: LD_VAR 0 7
66864: ARRAY
66865: PPUSH
66866: LD_VAR 0 23
66870: PPUSH
66871: CALL_OW 113
66875: GO 67083
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
66877: LD_VAR 0 4
66881: PUSH
66882: LD_VAR 0 7
66886: ARRAY
66887: PPUSH
66888: CALL 65515 0 1
66892: PPUSH
66893: CALL_OW 256
66897: PUSH
66898: LD_INT 1000
66900: EQUAL
66901: IFFALSE 66920
// ComStop ( group [ i ] ) else
66903: LD_VAR 0 4
66907: PUSH
66908: LD_VAR 0 7
66912: ARRAY
66913: PPUSH
66914: CALL_OW 141
66918: GO 67083
// if not HasTask ( group [ i ] ) and to_heal then
66920: LD_VAR 0 4
66924: PUSH
66925: LD_VAR 0 7
66929: ARRAY
66930: PPUSH
66931: CALL_OW 314
66935: NOT
66936: PUSH
66937: LD_VAR 0 30
66941: AND
66942: IFFALSE 67083
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
66944: LD_ADDR_VAR 0 13
66948: PUSH
66949: LD_VAR 0 30
66953: PPUSH
66954: LD_INT 3
66956: PUSH
66957: LD_INT 54
66959: PUSH
66960: EMPTY
66961: LIST
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PPUSH
66967: CALL_OW 72
66971: PPUSH
66972: LD_VAR 0 4
66976: PUSH
66977: LD_VAR 0 7
66981: ARRAY
66982: PPUSH
66983: CALL_OW 74
66987: ST_TO_ADDR
// if z then
66988: LD_VAR 0 13
66992: IFFALSE 67083
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
66994: LD_INT 91
66996: PUSH
66997: LD_VAR 0 13
67001: PUSH
67002: LD_INT 10
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 81
67012: PUSH
67013: LD_VAR 0 13
67017: PPUSH
67018: CALL_OW 255
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PPUSH
67031: CALL_OW 69
67035: PUSH
67036: LD_INT 0
67038: EQUAL
67039: IFFALSE 67063
// ComHeal ( group [ i ] , z ) else
67041: LD_VAR 0 4
67045: PUSH
67046: LD_VAR 0 7
67050: ARRAY
67051: PPUSH
67052: LD_VAR 0 13
67056: PPUSH
67057: CALL_OW 128
67061: GO 67083
// ComMoveToArea ( group [ i ] , f_heal ) ;
67063: LD_VAR 0 4
67067: PUSH
67068: LD_VAR 0 7
67072: ARRAY
67073: PPUSH
67074: LD_VAR 0 23
67078: PPUSH
67079: CALL_OW 113
// end ; continue ;
67083: GO 66114
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
67085: LD_VAR 0 4
67089: PUSH
67090: LD_VAR 0 7
67094: ARRAY
67095: PPUSH
67096: CALL_OW 256
67100: PUSH
67101: LD_INT 700
67103: LESS
67104: PUSH
67105: LD_VAR 0 4
67109: PUSH
67110: LD_VAR 0 7
67114: ARRAY
67115: PUSH
67116: LD_VAR 0 30
67120: IN
67121: NOT
67122: AND
67123: IFFALSE 67147
// to_heal := to_heal union group [ i ] ;
67125: LD_ADDR_VAR 0 30
67129: PUSH
67130: LD_VAR 0 30
67134: PUSH
67135: LD_VAR 0 4
67139: PUSH
67140: LD_VAR 0 7
67144: ARRAY
67145: UNION
67146: ST_TO_ADDR
// if group [ i ] in to_heal then
67147: LD_VAR 0 4
67151: PUSH
67152: LD_VAR 0 7
67156: ARRAY
67157: PUSH
67158: LD_VAR 0 30
67162: IN
67163: IFFALSE 67272
// begin if GetLives ( group [ i ] ) = 1000 then
67165: LD_VAR 0 4
67169: PUSH
67170: LD_VAR 0 7
67174: ARRAY
67175: PPUSH
67176: CALL_OW 256
67180: PUSH
67181: LD_INT 1000
67183: EQUAL
67184: IFFALSE 67210
// to_heal := to_heal diff group [ i ] else
67186: LD_ADDR_VAR 0 30
67190: PUSH
67191: LD_VAR 0 30
67195: PUSH
67196: LD_VAR 0 4
67200: PUSH
67201: LD_VAR 0 7
67205: ARRAY
67206: DIFF
67207: ST_TO_ADDR
67208: GO 67272
// begin if not IsInArea ( group [ i ] , to_heal ) then
67210: LD_VAR 0 4
67214: PUSH
67215: LD_VAR 0 7
67219: ARRAY
67220: PPUSH
67221: LD_VAR 0 30
67225: PPUSH
67226: CALL_OW 308
67230: NOT
67231: IFFALSE 67255
// ComMoveToArea ( group [ i ] , f_heal ) else
67233: LD_VAR 0 4
67237: PUSH
67238: LD_VAR 0 7
67242: ARRAY
67243: PPUSH
67244: LD_VAR 0 23
67248: PPUSH
67249: CALL_OW 113
67253: GO 67270
// ComHold ( group [ i ] ) ;
67255: LD_VAR 0 4
67259: PUSH
67260: LD_VAR 0 7
67264: ARRAY
67265: PPUSH
67266: CALL_OW 140
// continue ;
67270: GO 66114
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
67272: LD_VAR 0 4
67276: PUSH
67277: LD_VAR 0 7
67281: ARRAY
67282: PPUSH
67283: LD_INT 10
67285: PPUSH
67286: CALL 63912 0 2
67290: NOT
67291: PUSH
67292: LD_VAR 0 16
67296: PUSH
67297: LD_VAR 0 7
67301: ARRAY
67302: PUSH
67303: EMPTY
67304: EQUAL
67305: NOT
67306: AND
67307: IFFALSE 67573
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
67309: LD_VAR 0 4
67313: PUSH
67314: LD_VAR 0 7
67318: ARRAY
67319: PPUSH
67320: CALL_OW 262
67324: PUSH
67325: LD_INT 1
67327: PUSH
67328: LD_INT 2
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: IN
67335: IFFALSE 67376
// if GetFuel ( group [ i ] ) < 10 then
67337: LD_VAR 0 4
67341: PUSH
67342: LD_VAR 0 7
67346: ARRAY
67347: PPUSH
67348: CALL_OW 261
67352: PUSH
67353: LD_INT 10
67355: LESS
67356: IFFALSE 67376
// SetFuel ( group [ i ] , 12 ) ;
67358: LD_VAR 0 4
67362: PUSH
67363: LD_VAR 0 7
67367: ARRAY
67368: PPUSH
67369: LD_INT 12
67371: PPUSH
67372: CALL_OW 240
// if units_path [ i ] then
67376: LD_VAR 0 16
67380: PUSH
67381: LD_VAR 0 7
67385: ARRAY
67386: IFFALSE 67571
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
67388: LD_VAR 0 4
67392: PUSH
67393: LD_VAR 0 7
67397: ARRAY
67398: PPUSH
67399: LD_VAR 0 16
67403: PUSH
67404: LD_VAR 0 7
67408: ARRAY
67409: PUSH
67410: LD_INT 1
67412: ARRAY
67413: PUSH
67414: LD_INT 1
67416: ARRAY
67417: PPUSH
67418: LD_VAR 0 16
67422: PUSH
67423: LD_VAR 0 7
67427: ARRAY
67428: PUSH
67429: LD_INT 1
67431: ARRAY
67432: PUSH
67433: LD_INT 2
67435: ARRAY
67436: PPUSH
67437: CALL_OW 297
67441: PUSH
67442: LD_INT 6
67444: GREATER
67445: IFFALSE 67520
// begin if not HasTask ( group [ i ] ) then
67447: LD_VAR 0 4
67451: PUSH
67452: LD_VAR 0 7
67456: ARRAY
67457: PPUSH
67458: CALL_OW 314
67462: NOT
67463: IFFALSE 67518
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
67465: LD_VAR 0 4
67469: PUSH
67470: LD_VAR 0 7
67474: ARRAY
67475: PPUSH
67476: LD_VAR 0 16
67480: PUSH
67481: LD_VAR 0 7
67485: ARRAY
67486: PUSH
67487: LD_INT 1
67489: ARRAY
67490: PUSH
67491: LD_INT 1
67493: ARRAY
67494: PPUSH
67495: LD_VAR 0 16
67499: PUSH
67500: LD_VAR 0 7
67504: ARRAY
67505: PUSH
67506: LD_INT 1
67508: ARRAY
67509: PUSH
67510: LD_INT 2
67512: ARRAY
67513: PPUSH
67514: CALL_OW 114
// end else
67518: GO 67571
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
67520: LD_ADDR_VAR 0 15
67524: PUSH
67525: LD_VAR 0 16
67529: PUSH
67530: LD_VAR 0 7
67534: ARRAY
67535: PPUSH
67536: LD_INT 1
67538: PPUSH
67539: CALL_OW 3
67543: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
67544: LD_ADDR_VAR 0 16
67548: PUSH
67549: LD_VAR 0 16
67553: PPUSH
67554: LD_VAR 0 7
67558: PPUSH
67559: LD_VAR 0 15
67563: PPUSH
67564: CALL_OW 1
67568: ST_TO_ADDR
// continue ;
67569: GO 66114
// end ; end ; end else
67571: GO 70209
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
67573: LD_ADDR_VAR 0 14
67577: PUSH
67578: LD_INT 81
67580: PUSH
67581: LD_VAR 0 4
67585: PUSH
67586: LD_VAR 0 7
67590: ARRAY
67591: PPUSH
67592: CALL_OW 255
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PPUSH
67601: CALL_OW 69
67605: ST_TO_ADDR
// if not tmp then
67606: LD_VAR 0 14
67610: NOT
67611: IFFALSE 67615
// continue ;
67613: GO 66114
// if f_ignore_area then
67615: LD_VAR 0 17
67619: IFFALSE 67707
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
67621: LD_ADDR_VAR 0 15
67625: PUSH
67626: LD_VAR 0 14
67630: PPUSH
67631: LD_INT 3
67633: PUSH
67634: LD_INT 92
67636: PUSH
67637: LD_VAR 0 17
67641: PUSH
67642: LD_INT 1
67644: ARRAY
67645: PUSH
67646: LD_VAR 0 17
67650: PUSH
67651: LD_INT 2
67653: ARRAY
67654: PUSH
67655: LD_VAR 0 17
67659: PUSH
67660: LD_INT 3
67662: ARRAY
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PPUSH
67674: CALL_OW 72
67678: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
67679: LD_VAR 0 14
67683: PUSH
67684: LD_VAR 0 15
67688: DIFF
67689: IFFALSE 67707
// tmp := tmp diff tmp2 ;
67691: LD_ADDR_VAR 0 14
67695: PUSH
67696: LD_VAR 0 14
67700: PUSH
67701: LD_VAR 0 15
67705: DIFF
67706: ST_TO_ADDR
// end ; if not f_murder then
67707: LD_VAR 0 20
67711: NOT
67712: IFFALSE 67770
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
67714: LD_ADDR_VAR 0 15
67718: PUSH
67719: LD_VAR 0 14
67723: PPUSH
67724: LD_INT 3
67726: PUSH
67727: LD_INT 50
67729: PUSH
67730: EMPTY
67731: LIST
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PPUSH
67737: CALL_OW 72
67741: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
67742: LD_VAR 0 14
67746: PUSH
67747: LD_VAR 0 15
67751: DIFF
67752: IFFALSE 67770
// tmp := tmp diff tmp2 ;
67754: LD_ADDR_VAR 0 14
67758: PUSH
67759: LD_VAR 0 14
67763: PUSH
67764: LD_VAR 0 15
67768: DIFF
67769: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
67770: LD_ADDR_VAR 0 14
67774: PUSH
67775: LD_VAR 0 4
67779: PUSH
67780: LD_VAR 0 7
67784: ARRAY
67785: PPUSH
67786: LD_VAR 0 14
67790: PPUSH
67791: LD_INT 1
67793: PPUSH
67794: LD_INT 1
67796: PPUSH
67797: CALL 37579 0 4
67801: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
67802: LD_VAR 0 4
67806: PUSH
67807: LD_VAR 0 7
67811: ARRAY
67812: PPUSH
67813: CALL_OW 257
67817: PUSH
67818: LD_INT 1
67820: EQUAL
67821: IFFALSE 68269
// begin if WantPlant ( group [ i ] ) then
67823: LD_VAR 0 4
67827: PUSH
67828: LD_VAR 0 7
67832: ARRAY
67833: PPUSH
67834: CALL 37080 0 1
67838: IFFALSE 67842
// continue ;
67840: GO 66114
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
67842: LD_VAR 0 18
67846: PUSH
67847: LD_VAR 0 4
67851: PUSH
67852: LD_VAR 0 7
67856: ARRAY
67857: PPUSH
67858: CALL_OW 310
67862: NOT
67863: AND
67864: PUSH
67865: LD_VAR 0 14
67869: PUSH
67870: LD_INT 1
67872: ARRAY
67873: PUSH
67874: LD_VAR 0 14
67878: PPUSH
67879: LD_INT 21
67881: PUSH
67882: LD_INT 2
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: LD_INT 58
67891: PUSH
67892: EMPTY
67893: LIST
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PPUSH
67899: CALL_OW 72
67903: IN
67904: AND
67905: IFFALSE 67941
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
67907: LD_VAR 0 4
67911: PUSH
67912: LD_VAR 0 7
67916: ARRAY
67917: PPUSH
67918: LD_VAR 0 14
67922: PUSH
67923: LD_INT 1
67925: ARRAY
67926: PPUSH
67927: CALL_OW 120
// attacking := true ;
67931: LD_ADDR_VAR 0 29
67935: PUSH
67936: LD_INT 1
67938: ST_TO_ADDR
// continue ;
67939: GO 66114
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
67941: LD_VAR 0 26
67945: PUSH
67946: LD_VAR 0 4
67950: PUSH
67951: LD_VAR 0 7
67955: ARRAY
67956: PPUSH
67957: CALL_OW 257
67961: PUSH
67962: LD_INT 1
67964: EQUAL
67965: AND
67966: PUSH
67967: LD_VAR 0 4
67971: PUSH
67972: LD_VAR 0 7
67976: ARRAY
67977: PPUSH
67978: CALL_OW 256
67982: PUSH
67983: LD_INT 800
67985: LESS
67986: AND
67987: PUSH
67988: LD_VAR 0 4
67992: PUSH
67993: LD_VAR 0 7
67997: ARRAY
67998: PPUSH
67999: CALL_OW 318
68003: NOT
68004: AND
68005: IFFALSE 68022
// ComCrawl ( group [ i ] ) ;
68007: LD_VAR 0 4
68011: PUSH
68012: LD_VAR 0 7
68016: ARRAY
68017: PPUSH
68018: CALL_OW 137
// if f_mines then
68022: LD_VAR 0 21
68026: IFFALSE 68269
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
68028: LD_VAR 0 14
68032: PUSH
68033: LD_INT 1
68035: ARRAY
68036: PPUSH
68037: CALL_OW 247
68041: PUSH
68042: LD_INT 3
68044: EQUAL
68045: PUSH
68046: LD_VAR 0 14
68050: PUSH
68051: LD_INT 1
68053: ARRAY
68054: PUSH
68055: LD_VAR 0 27
68059: IN
68060: NOT
68061: AND
68062: IFFALSE 68269
// begin x := GetX ( tmp [ 1 ] ) ;
68064: LD_ADDR_VAR 0 10
68068: PUSH
68069: LD_VAR 0 14
68073: PUSH
68074: LD_INT 1
68076: ARRAY
68077: PPUSH
68078: CALL_OW 250
68082: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
68083: LD_ADDR_VAR 0 11
68087: PUSH
68088: LD_VAR 0 14
68092: PUSH
68093: LD_INT 1
68095: ARRAY
68096: PPUSH
68097: CALL_OW 251
68101: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
68102: LD_ADDR_VAR 0 12
68106: PUSH
68107: LD_VAR 0 4
68111: PUSH
68112: LD_VAR 0 7
68116: ARRAY
68117: PPUSH
68118: CALL 63997 0 1
68122: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
68123: LD_VAR 0 4
68127: PUSH
68128: LD_VAR 0 7
68132: ARRAY
68133: PPUSH
68134: LD_VAR 0 10
68138: PPUSH
68139: LD_VAR 0 11
68143: PPUSH
68144: LD_VAR 0 14
68148: PUSH
68149: LD_INT 1
68151: ARRAY
68152: PPUSH
68153: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
68157: LD_VAR 0 4
68161: PUSH
68162: LD_VAR 0 7
68166: ARRAY
68167: PPUSH
68168: LD_VAR 0 10
68172: PPUSH
68173: LD_VAR 0 12
68177: PPUSH
68178: LD_INT 7
68180: PPUSH
68181: CALL_OW 272
68185: PPUSH
68186: LD_VAR 0 11
68190: PPUSH
68191: LD_VAR 0 12
68195: PPUSH
68196: LD_INT 7
68198: PPUSH
68199: CALL_OW 273
68203: PPUSH
68204: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
68208: LD_VAR 0 4
68212: PUSH
68213: LD_VAR 0 7
68217: ARRAY
68218: PPUSH
68219: LD_INT 71
68221: PPUSH
68222: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
68226: LD_ADDR_VAR 0 27
68230: PUSH
68231: LD_VAR 0 27
68235: PPUSH
68236: LD_VAR 0 27
68240: PUSH
68241: LD_INT 1
68243: PLUS
68244: PPUSH
68245: LD_VAR 0 14
68249: PUSH
68250: LD_INT 1
68252: ARRAY
68253: PPUSH
68254: CALL_OW 1
68258: ST_TO_ADDR
// attacking := true ;
68259: LD_ADDR_VAR 0 29
68263: PUSH
68264: LD_INT 1
68266: ST_TO_ADDR
// continue ;
68267: GO 66114
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
68269: LD_VAR 0 4
68273: PUSH
68274: LD_VAR 0 7
68278: ARRAY
68279: PPUSH
68280: CALL_OW 257
68284: PUSH
68285: LD_INT 17
68287: EQUAL
68288: PUSH
68289: LD_VAR 0 4
68293: PUSH
68294: LD_VAR 0 7
68298: ARRAY
68299: PPUSH
68300: CALL_OW 110
68304: PUSH
68305: LD_INT 71
68307: EQUAL
68308: NOT
68309: AND
68310: IFFALSE 68456
// begin attacking := false ;
68312: LD_ADDR_VAR 0 29
68316: PUSH
68317: LD_INT 0
68319: ST_TO_ADDR
// k := 5 ;
68320: LD_ADDR_VAR 0 9
68324: PUSH
68325: LD_INT 5
68327: ST_TO_ADDR
// if tmp < k then
68328: LD_VAR 0 14
68332: PUSH
68333: LD_VAR 0 9
68337: LESS
68338: IFFALSE 68350
// k := tmp ;
68340: LD_ADDR_VAR 0 9
68344: PUSH
68345: LD_VAR 0 14
68349: ST_TO_ADDR
// for j = 1 to k do
68350: LD_ADDR_VAR 0 8
68354: PUSH
68355: DOUBLE
68356: LD_INT 1
68358: DEC
68359: ST_TO_ADDR
68360: LD_VAR 0 9
68364: PUSH
68365: FOR_TO
68366: IFFALSE 68454
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
68368: LD_VAR 0 14
68372: PUSH
68373: LD_VAR 0 8
68377: ARRAY
68378: PUSH
68379: LD_VAR 0 14
68383: PPUSH
68384: LD_INT 58
68386: PUSH
68387: EMPTY
68388: LIST
68389: PPUSH
68390: CALL_OW 72
68394: IN
68395: NOT
68396: IFFALSE 68452
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
68398: LD_VAR 0 4
68402: PUSH
68403: LD_VAR 0 7
68407: ARRAY
68408: PPUSH
68409: LD_VAR 0 14
68413: PUSH
68414: LD_VAR 0 8
68418: ARRAY
68419: PPUSH
68420: CALL_OW 115
// attacking := true ;
68424: LD_ADDR_VAR 0 29
68428: PUSH
68429: LD_INT 1
68431: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
68432: LD_VAR 0 4
68436: PUSH
68437: LD_VAR 0 7
68441: ARRAY
68442: PPUSH
68443: LD_INT 71
68445: PPUSH
68446: CALL_OW 109
// continue ;
68450: GO 68365
// end ; end ;
68452: GO 68365
68454: POP
68455: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
68456: LD_VAR 0 4
68460: PUSH
68461: LD_VAR 0 7
68465: ARRAY
68466: PPUSH
68467: CALL_OW 257
68471: PUSH
68472: LD_INT 8
68474: EQUAL
68475: PUSH
68476: LD_VAR 0 4
68480: PUSH
68481: LD_VAR 0 7
68485: ARRAY
68486: PPUSH
68487: CALL_OW 264
68491: PUSH
68492: LD_INT 28
68494: PUSH
68495: LD_INT 45
68497: PUSH
68498: LD_INT 7
68500: PUSH
68501: LD_INT 47
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: IN
68510: OR
68511: IFFALSE 68741
// begin attacking := false ;
68513: LD_ADDR_VAR 0 29
68517: PUSH
68518: LD_INT 0
68520: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
68521: LD_VAR 0 14
68525: PUSH
68526: LD_INT 1
68528: ARRAY
68529: PPUSH
68530: CALL_OW 266
68534: PUSH
68535: LD_INT 32
68537: PUSH
68538: LD_INT 31
68540: PUSH
68541: LD_INT 33
68543: PUSH
68544: LD_INT 4
68546: PUSH
68547: LD_INT 5
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: IN
68557: IFFALSE 68741
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
68559: LD_ADDR_VAR 0 9
68563: PUSH
68564: LD_VAR 0 14
68568: PUSH
68569: LD_INT 1
68571: ARRAY
68572: PPUSH
68573: CALL_OW 266
68577: PPUSH
68578: LD_VAR 0 14
68582: PUSH
68583: LD_INT 1
68585: ARRAY
68586: PPUSH
68587: CALL_OW 250
68591: PPUSH
68592: LD_VAR 0 14
68596: PUSH
68597: LD_INT 1
68599: ARRAY
68600: PPUSH
68601: CALL_OW 251
68605: PPUSH
68606: LD_VAR 0 14
68610: PUSH
68611: LD_INT 1
68613: ARRAY
68614: PPUSH
68615: CALL_OW 254
68619: PPUSH
68620: LD_VAR 0 14
68624: PUSH
68625: LD_INT 1
68627: ARRAY
68628: PPUSH
68629: CALL_OW 248
68633: PPUSH
68634: LD_INT 0
68636: PPUSH
68637: CALL 45373 0 6
68641: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
68642: LD_ADDR_VAR 0 8
68646: PUSH
68647: LD_VAR 0 4
68651: PUSH
68652: LD_VAR 0 7
68656: ARRAY
68657: PPUSH
68658: LD_VAR 0 9
68662: PPUSH
68663: CALL 64060 0 2
68667: ST_TO_ADDR
// if j then
68668: LD_VAR 0 8
68672: IFFALSE 68741
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
68674: LD_VAR 0 8
68678: PUSH
68679: LD_INT 1
68681: ARRAY
68682: PPUSH
68683: LD_VAR 0 8
68687: PUSH
68688: LD_INT 2
68690: ARRAY
68691: PPUSH
68692: CALL_OW 488
68696: IFFALSE 68741
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
68698: LD_VAR 0 4
68702: PUSH
68703: LD_VAR 0 7
68707: ARRAY
68708: PPUSH
68709: LD_VAR 0 8
68713: PUSH
68714: LD_INT 1
68716: ARRAY
68717: PPUSH
68718: LD_VAR 0 8
68722: PUSH
68723: LD_INT 2
68725: ARRAY
68726: PPUSH
68727: CALL_OW 116
// attacking := true ;
68731: LD_ADDR_VAR 0 29
68735: PUSH
68736: LD_INT 1
68738: ST_TO_ADDR
// continue ;
68739: GO 66114
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
68741: LD_VAR 0 4
68745: PUSH
68746: LD_VAR 0 7
68750: ARRAY
68751: PPUSH
68752: CALL_OW 265
68756: PUSH
68757: LD_INT 11
68759: EQUAL
68760: IFFALSE 69038
// begin k := 10 ;
68762: LD_ADDR_VAR 0 9
68766: PUSH
68767: LD_INT 10
68769: ST_TO_ADDR
// x := 0 ;
68770: LD_ADDR_VAR 0 10
68774: PUSH
68775: LD_INT 0
68777: ST_TO_ADDR
// if tmp < k then
68778: LD_VAR 0 14
68782: PUSH
68783: LD_VAR 0 9
68787: LESS
68788: IFFALSE 68800
// k := tmp ;
68790: LD_ADDR_VAR 0 9
68794: PUSH
68795: LD_VAR 0 14
68799: ST_TO_ADDR
// for j = k downto 1 do
68800: LD_ADDR_VAR 0 8
68804: PUSH
68805: DOUBLE
68806: LD_VAR 0 9
68810: INC
68811: ST_TO_ADDR
68812: LD_INT 1
68814: PUSH
68815: FOR_DOWNTO
68816: IFFALSE 68891
// begin if GetType ( tmp [ j ] ) = unit_human then
68818: LD_VAR 0 14
68822: PUSH
68823: LD_VAR 0 8
68827: ARRAY
68828: PPUSH
68829: CALL_OW 247
68833: PUSH
68834: LD_INT 1
68836: EQUAL
68837: IFFALSE 68889
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
68839: LD_VAR 0 4
68843: PUSH
68844: LD_VAR 0 7
68848: ARRAY
68849: PPUSH
68850: LD_VAR 0 14
68854: PUSH
68855: LD_VAR 0 8
68859: ARRAY
68860: PPUSH
68861: CALL 64331 0 2
// x := tmp [ j ] ;
68865: LD_ADDR_VAR 0 10
68869: PUSH
68870: LD_VAR 0 14
68874: PUSH
68875: LD_VAR 0 8
68879: ARRAY
68880: ST_TO_ADDR
// attacking := true ;
68881: LD_ADDR_VAR 0 29
68885: PUSH
68886: LD_INT 1
68888: ST_TO_ADDR
// end ; end ;
68889: GO 68815
68891: POP
68892: POP
// if not x then
68893: LD_VAR 0 10
68897: NOT
68898: IFFALSE 69038
// begin attacking := true ;
68900: LD_ADDR_VAR 0 29
68904: PUSH
68905: LD_INT 1
68907: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
68908: LD_VAR 0 4
68912: PUSH
68913: LD_VAR 0 7
68917: ARRAY
68918: PPUSH
68919: CALL_OW 250
68923: PPUSH
68924: LD_VAR 0 4
68928: PUSH
68929: LD_VAR 0 7
68933: ARRAY
68934: PPUSH
68935: CALL_OW 251
68939: PPUSH
68940: CALL_OW 546
68944: PUSH
68945: LD_INT 2
68947: ARRAY
68948: PUSH
68949: LD_VAR 0 14
68953: PUSH
68954: LD_INT 1
68956: ARRAY
68957: PPUSH
68958: CALL_OW 250
68962: PPUSH
68963: LD_VAR 0 14
68967: PUSH
68968: LD_INT 1
68970: ARRAY
68971: PPUSH
68972: CALL_OW 251
68976: PPUSH
68977: CALL_OW 546
68981: PUSH
68982: LD_INT 2
68984: ARRAY
68985: EQUAL
68986: IFFALSE 69014
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
68988: LD_VAR 0 4
68992: PUSH
68993: LD_VAR 0 7
68997: ARRAY
68998: PPUSH
68999: LD_VAR 0 14
69003: PUSH
69004: LD_INT 1
69006: ARRAY
69007: PPUSH
69008: CALL 64331 0 2
69012: GO 69038
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
69014: LD_VAR 0 4
69018: PUSH
69019: LD_VAR 0 7
69023: ARRAY
69024: PPUSH
69025: LD_VAR 0 14
69029: PUSH
69030: LD_INT 1
69032: ARRAY
69033: PPUSH
69034: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
69038: LD_VAR 0 4
69042: PUSH
69043: LD_VAR 0 7
69047: ARRAY
69048: PPUSH
69049: CALL_OW 264
69053: PUSH
69054: LD_INT 29
69056: EQUAL
69057: IFFALSE 69423
// begin if WantsToAttack ( group [ i ] ) in bombed then
69059: LD_VAR 0 4
69063: PUSH
69064: LD_VAR 0 7
69068: ARRAY
69069: PPUSH
69070: CALL_OW 319
69074: PUSH
69075: LD_VAR 0 28
69079: IN
69080: IFFALSE 69084
// continue ;
69082: GO 66114
// k := 8 ;
69084: LD_ADDR_VAR 0 9
69088: PUSH
69089: LD_INT 8
69091: ST_TO_ADDR
// x := 0 ;
69092: LD_ADDR_VAR 0 10
69096: PUSH
69097: LD_INT 0
69099: ST_TO_ADDR
// if tmp < k then
69100: LD_VAR 0 14
69104: PUSH
69105: LD_VAR 0 9
69109: LESS
69110: IFFALSE 69122
// k := tmp ;
69112: LD_ADDR_VAR 0 9
69116: PUSH
69117: LD_VAR 0 14
69121: ST_TO_ADDR
// for j = 1 to k do
69122: LD_ADDR_VAR 0 8
69126: PUSH
69127: DOUBLE
69128: LD_INT 1
69130: DEC
69131: ST_TO_ADDR
69132: LD_VAR 0 9
69136: PUSH
69137: FOR_TO
69138: IFFALSE 69270
// begin if GetType ( tmp [ j ] ) = unit_building then
69140: LD_VAR 0 14
69144: PUSH
69145: LD_VAR 0 8
69149: ARRAY
69150: PPUSH
69151: CALL_OW 247
69155: PUSH
69156: LD_INT 3
69158: EQUAL
69159: IFFALSE 69268
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
69161: LD_VAR 0 14
69165: PUSH
69166: LD_VAR 0 8
69170: ARRAY
69171: PUSH
69172: LD_VAR 0 28
69176: IN
69177: NOT
69178: PUSH
69179: LD_VAR 0 14
69183: PUSH
69184: LD_VAR 0 8
69188: ARRAY
69189: PPUSH
69190: CALL_OW 313
69194: AND
69195: IFFALSE 69268
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
69197: LD_VAR 0 4
69201: PUSH
69202: LD_VAR 0 7
69206: ARRAY
69207: PPUSH
69208: LD_VAR 0 14
69212: PUSH
69213: LD_VAR 0 8
69217: ARRAY
69218: PPUSH
69219: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
69223: LD_ADDR_VAR 0 28
69227: PUSH
69228: LD_VAR 0 28
69232: PPUSH
69233: LD_VAR 0 28
69237: PUSH
69238: LD_INT 1
69240: PLUS
69241: PPUSH
69242: LD_VAR 0 14
69246: PUSH
69247: LD_VAR 0 8
69251: ARRAY
69252: PPUSH
69253: CALL_OW 1
69257: ST_TO_ADDR
// attacking := true ;
69258: LD_ADDR_VAR 0 29
69262: PUSH
69263: LD_INT 1
69265: ST_TO_ADDR
// break ;
69266: GO 69270
// end ; end ;
69268: GO 69137
69270: POP
69271: POP
// if not attacking and f_attack_depot then
69272: LD_VAR 0 29
69276: NOT
69277: PUSH
69278: LD_VAR 0 25
69282: AND
69283: IFFALSE 69378
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69285: LD_ADDR_VAR 0 13
69289: PUSH
69290: LD_VAR 0 14
69294: PPUSH
69295: LD_INT 2
69297: PUSH
69298: LD_INT 30
69300: PUSH
69301: LD_INT 0
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 30
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: LIST
69322: PPUSH
69323: CALL_OW 72
69327: ST_TO_ADDR
// if z then
69328: LD_VAR 0 13
69332: IFFALSE 69378
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
69334: LD_VAR 0 4
69338: PUSH
69339: LD_VAR 0 7
69343: ARRAY
69344: PPUSH
69345: LD_VAR 0 13
69349: PPUSH
69350: LD_VAR 0 4
69354: PUSH
69355: LD_VAR 0 7
69359: ARRAY
69360: PPUSH
69361: CALL_OW 74
69365: PPUSH
69366: CALL_OW 115
// attacking := true ;
69370: LD_ADDR_VAR 0 29
69374: PUSH
69375: LD_INT 1
69377: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
69378: LD_VAR 0 4
69382: PUSH
69383: LD_VAR 0 7
69387: ARRAY
69388: PPUSH
69389: CALL_OW 256
69393: PUSH
69394: LD_INT 500
69396: LESS
69397: IFFALSE 69423
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
69399: LD_VAR 0 4
69403: PUSH
69404: LD_VAR 0 7
69408: ARRAY
69409: PPUSH
69410: LD_VAR 0 14
69414: PUSH
69415: LD_INT 1
69417: ARRAY
69418: PPUSH
69419: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
69423: LD_VAR 0 4
69427: PUSH
69428: LD_VAR 0 7
69432: ARRAY
69433: PPUSH
69434: CALL_OW 264
69438: PUSH
69439: LD_INT 49
69441: EQUAL
69442: IFFALSE 69563
// begin if not HasTask ( group [ i ] ) then
69444: LD_VAR 0 4
69448: PUSH
69449: LD_VAR 0 7
69453: ARRAY
69454: PPUSH
69455: CALL_OW 314
69459: NOT
69460: IFFALSE 69563
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
69462: LD_ADDR_VAR 0 9
69466: PUSH
69467: LD_INT 81
69469: PUSH
69470: LD_VAR 0 4
69474: PUSH
69475: LD_VAR 0 7
69479: ARRAY
69480: PPUSH
69481: CALL_OW 255
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PPUSH
69490: CALL_OW 69
69494: PPUSH
69495: LD_VAR 0 4
69499: PUSH
69500: LD_VAR 0 7
69504: ARRAY
69505: PPUSH
69506: CALL_OW 74
69510: ST_TO_ADDR
// if k then
69511: LD_VAR 0 9
69515: IFFALSE 69563
// if GetDistUnits ( group [ i ] , k ) > 10 then
69517: LD_VAR 0 4
69521: PUSH
69522: LD_VAR 0 7
69526: ARRAY
69527: PPUSH
69528: LD_VAR 0 9
69532: PPUSH
69533: CALL_OW 296
69537: PUSH
69538: LD_INT 10
69540: GREATER
69541: IFFALSE 69563
// ComMoveUnit ( group [ i ] , k ) ;
69543: LD_VAR 0 4
69547: PUSH
69548: LD_VAR 0 7
69552: ARRAY
69553: PPUSH
69554: LD_VAR 0 9
69558: PPUSH
69559: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
69563: LD_VAR 0 4
69567: PUSH
69568: LD_VAR 0 7
69572: ARRAY
69573: PPUSH
69574: CALL_OW 256
69578: PUSH
69579: LD_INT 250
69581: LESS
69582: PUSH
69583: LD_VAR 0 4
69587: PUSH
69588: LD_VAR 0 7
69592: ARRAY
69593: PUSH
69594: LD_INT 21
69596: PUSH
69597: LD_INT 2
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 23
69606: PUSH
69607: LD_INT 2
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PPUSH
69618: CALL_OW 69
69622: IN
69623: AND
69624: IFFALSE 69749
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
69626: LD_ADDR_VAR 0 9
69630: PUSH
69631: LD_OWVAR 3
69635: PUSH
69636: LD_VAR 0 4
69640: PUSH
69641: LD_VAR 0 7
69645: ARRAY
69646: DIFF
69647: PPUSH
69648: LD_VAR 0 4
69652: PUSH
69653: LD_VAR 0 7
69657: ARRAY
69658: PPUSH
69659: CALL_OW 74
69663: ST_TO_ADDR
// if not k then
69664: LD_VAR 0 9
69668: NOT
69669: IFFALSE 69673
// continue ;
69671: GO 66114
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
69673: LD_VAR 0 9
69677: PUSH
69678: LD_INT 81
69680: PUSH
69681: LD_VAR 0 4
69685: PUSH
69686: LD_VAR 0 7
69690: ARRAY
69691: PPUSH
69692: CALL_OW 255
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PPUSH
69701: CALL_OW 69
69705: IN
69706: PUSH
69707: LD_VAR 0 9
69711: PPUSH
69712: LD_VAR 0 4
69716: PUSH
69717: LD_VAR 0 7
69721: ARRAY
69722: PPUSH
69723: CALL_OW 296
69727: PUSH
69728: LD_INT 5
69730: LESS
69731: AND
69732: IFFALSE 69749
// ComAutodestruct ( group [ i ] ) ;
69734: LD_VAR 0 4
69738: PUSH
69739: LD_VAR 0 7
69743: ARRAY
69744: PPUSH
69745: CALL 64229 0 1
// end ; if f_attack_depot then
69749: LD_VAR 0 25
69753: IFFALSE 69865
// begin k := 6 ;
69755: LD_ADDR_VAR 0 9
69759: PUSH
69760: LD_INT 6
69762: ST_TO_ADDR
// if tmp < k then
69763: LD_VAR 0 14
69767: PUSH
69768: LD_VAR 0 9
69772: LESS
69773: IFFALSE 69785
// k := tmp ;
69775: LD_ADDR_VAR 0 9
69779: PUSH
69780: LD_VAR 0 14
69784: ST_TO_ADDR
// for j = 1 to k do
69785: LD_ADDR_VAR 0 8
69789: PUSH
69790: DOUBLE
69791: LD_INT 1
69793: DEC
69794: ST_TO_ADDR
69795: LD_VAR 0 9
69799: PUSH
69800: FOR_TO
69801: IFFALSE 69863
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
69803: LD_VAR 0 8
69807: PPUSH
69808: CALL_OW 266
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: LD_INT 1
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: IN
69823: IFFALSE 69861
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
69825: LD_VAR 0 4
69829: PUSH
69830: LD_VAR 0 7
69834: ARRAY
69835: PPUSH
69836: LD_VAR 0 14
69840: PUSH
69841: LD_VAR 0 8
69845: ARRAY
69846: PPUSH
69847: CALL_OW 115
// attacking := true ;
69851: LD_ADDR_VAR 0 29
69855: PUSH
69856: LD_INT 1
69858: ST_TO_ADDR
// break ;
69859: GO 69863
// end ;
69861: GO 69800
69863: POP
69864: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
69865: LD_VAR 0 4
69869: PUSH
69870: LD_VAR 0 7
69874: ARRAY
69875: PPUSH
69876: CALL_OW 302
69880: PUSH
69881: LD_VAR 0 29
69885: NOT
69886: AND
69887: IFFALSE 70209
// begin if GetTag ( group [ i ] ) = 71 then
69889: LD_VAR 0 4
69893: PUSH
69894: LD_VAR 0 7
69898: ARRAY
69899: PPUSH
69900: CALL_OW 110
69904: PUSH
69905: LD_INT 71
69907: EQUAL
69908: IFFALSE 69949
// begin if HasTask ( group [ i ] ) then
69910: LD_VAR 0 4
69914: PUSH
69915: LD_VAR 0 7
69919: ARRAY
69920: PPUSH
69921: CALL_OW 314
69925: IFFALSE 69931
// continue else
69927: GO 66114
69929: GO 69949
// SetTag ( group [ i ] , 0 ) ;
69931: LD_VAR 0 4
69935: PUSH
69936: LD_VAR 0 7
69940: ARRAY
69941: PPUSH
69942: LD_INT 0
69944: PPUSH
69945: CALL_OW 109
// end ; k := 8 ;
69949: LD_ADDR_VAR 0 9
69953: PUSH
69954: LD_INT 8
69956: ST_TO_ADDR
// x := 0 ;
69957: LD_ADDR_VAR 0 10
69961: PUSH
69962: LD_INT 0
69964: ST_TO_ADDR
// if tmp < k then
69965: LD_VAR 0 14
69969: PUSH
69970: LD_VAR 0 9
69974: LESS
69975: IFFALSE 69987
// k := tmp ;
69977: LD_ADDR_VAR 0 9
69981: PUSH
69982: LD_VAR 0 14
69986: ST_TO_ADDR
// for j = 1 to k do
69987: LD_ADDR_VAR 0 8
69991: PUSH
69992: DOUBLE
69993: LD_INT 1
69995: DEC
69996: ST_TO_ADDR
69997: LD_VAR 0 9
70001: PUSH
70002: FOR_TO
70003: IFFALSE 70101
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
70005: LD_VAR 0 14
70009: PUSH
70010: LD_VAR 0 8
70014: ARRAY
70015: PPUSH
70016: CALL_OW 247
70020: PUSH
70021: LD_INT 1
70023: EQUAL
70024: PUSH
70025: LD_VAR 0 14
70029: PUSH
70030: LD_VAR 0 8
70034: ARRAY
70035: PPUSH
70036: CALL_OW 256
70040: PUSH
70041: LD_INT 250
70043: LESS
70044: PUSH
70045: LD_VAR 0 20
70049: AND
70050: PUSH
70051: LD_VAR 0 20
70055: NOT
70056: PUSH
70057: LD_VAR 0 14
70061: PUSH
70062: LD_VAR 0 8
70066: ARRAY
70067: PPUSH
70068: CALL_OW 256
70072: PUSH
70073: LD_INT 250
70075: GREATEREQUAL
70076: AND
70077: OR
70078: AND
70079: IFFALSE 70099
// begin x := tmp [ j ] ;
70081: LD_ADDR_VAR 0 10
70085: PUSH
70086: LD_VAR 0 14
70090: PUSH
70091: LD_VAR 0 8
70095: ARRAY
70096: ST_TO_ADDR
// break ;
70097: GO 70101
// end ;
70099: GO 70002
70101: POP
70102: POP
// if x then
70103: LD_VAR 0 10
70107: IFFALSE 70131
// ComAttackUnit ( group [ i ] , x ) else
70109: LD_VAR 0 4
70113: PUSH
70114: LD_VAR 0 7
70118: ARRAY
70119: PPUSH
70120: LD_VAR 0 10
70124: PPUSH
70125: CALL_OW 115
70129: GO 70155
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
70131: LD_VAR 0 4
70135: PUSH
70136: LD_VAR 0 7
70140: ARRAY
70141: PPUSH
70142: LD_VAR 0 14
70146: PUSH
70147: LD_INT 1
70149: ARRAY
70150: PPUSH
70151: CALL_OW 115
// if not HasTask ( group [ i ] ) then
70155: LD_VAR 0 4
70159: PUSH
70160: LD_VAR 0 7
70164: ARRAY
70165: PPUSH
70166: CALL_OW 314
70170: NOT
70171: IFFALSE 70209
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
70173: LD_VAR 0 4
70177: PUSH
70178: LD_VAR 0 7
70182: ARRAY
70183: PPUSH
70184: LD_VAR 0 14
70188: PPUSH
70189: LD_VAR 0 4
70193: PUSH
70194: LD_VAR 0 7
70198: ARRAY
70199: PPUSH
70200: CALL_OW 74
70204: PPUSH
70205: CALL_OW 115
// end ; end ; end ;
70209: GO 66114
70211: POP
70212: POP
// wait ( 0 0$1 ) ;
70213: LD_INT 35
70215: PPUSH
70216: CALL_OW 67
// until group = [ ] ;
70220: LD_VAR 0 4
70224: PUSH
70225: EMPTY
70226: EQUAL
70227: IFFALSE 66099
// end ;
70229: LD_VAR 0 2
70233: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
70234: LD_INT 0
70236: PPUSH
70237: PPUSH
70238: PPUSH
70239: PPUSH
// if not base_units then
70240: LD_VAR 0 1
70244: NOT
70245: IFFALSE 70249
// exit ;
70247: GO 70336
// result := false ;
70249: LD_ADDR_VAR 0 2
70253: PUSH
70254: LD_INT 0
70256: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
70257: LD_ADDR_VAR 0 5
70261: PUSH
70262: LD_VAR 0 1
70266: PPUSH
70267: LD_INT 21
70269: PUSH
70270: LD_INT 3
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PPUSH
70277: CALL_OW 72
70281: ST_TO_ADDR
// if not tmp then
70282: LD_VAR 0 5
70286: NOT
70287: IFFALSE 70291
// exit ;
70289: GO 70336
// for i in tmp do
70291: LD_ADDR_VAR 0 3
70295: PUSH
70296: LD_VAR 0 5
70300: PUSH
70301: FOR_IN
70302: IFFALSE 70334
// begin result := EnemyInRange ( i , 22 ) ;
70304: LD_ADDR_VAR 0 2
70308: PUSH
70309: LD_VAR 0 3
70313: PPUSH
70314: LD_INT 22
70316: PPUSH
70317: CALL 63912 0 2
70321: ST_TO_ADDR
// if result then
70322: LD_VAR 0 2
70326: IFFALSE 70332
// exit ;
70328: POP
70329: POP
70330: GO 70336
// end ;
70332: GO 70301
70334: POP
70335: POP
// end ;
70336: LD_VAR 0 2
70340: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
70341: LD_INT 0
70343: PPUSH
70344: PPUSH
// if not units then
70345: LD_VAR 0 1
70349: NOT
70350: IFFALSE 70354
// exit ;
70352: GO 70424
// result := [ ] ;
70354: LD_ADDR_VAR 0 3
70358: PUSH
70359: EMPTY
70360: ST_TO_ADDR
// for i in units do
70361: LD_ADDR_VAR 0 4
70365: PUSH
70366: LD_VAR 0 1
70370: PUSH
70371: FOR_IN
70372: IFFALSE 70422
// if GetTag ( i ) = tag then
70374: LD_VAR 0 4
70378: PPUSH
70379: CALL_OW 110
70383: PUSH
70384: LD_VAR 0 2
70388: EQUAL
70389: IFFALSE 70420
// result := Insert ( result , result + 1 , i ) ;
70391: LD_ADDR_VAR 0 3
70395: PUSH
70396: LD_VAR 0 3
70400: PPUSH
70401: LD_VAR 0 3
70405: PUSH
70406: LD_INT 1
70408: PLUS
70409: PPUSH
70410: LD_VAR 0 4
70414: PPUSH
70415: CALL_OW 2
70419: ST_TO_ADDR
70420: GO 70371
70422: POP
70423: POP
// end ;
70424: LD_VAR 0 3
70428: RET
// export function IsDriver ( un ) ; begin
70429: LD_INT 0
70431: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
70432: LD_ADDR_VAR 0 2
70436: PUSH
70437: LD_VAR 0 1
70441: PUSH
70442: LD_INT 55
70444: PUSH
70445: EMPTY
70446: LIST
70447: PPUSH
70448: CALL_OW 69
70452: IN
70453: ST_TO_ADDR
// end ;
70454: LD_VAR 0 2
70458: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
70459: LD_INT 0
70461: PPUSH
70462: PPUSH
// list := [ ] ;
70463: LD_ADDR_VAR 0 5
70467: PUSH
70468: EMPTY
70469: ST_TO_ADDR
// case d of 0 :
70470: LD_VAR 0 3
70474: PUSH
70475: LD_INT 0
70477: DOUBLE
70478: EQUAL
70479: IFTRUE 70483
70481: GO 70616
70483: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
70484: LD_ADDR_VAR 0 5
70488: PUSH
70489: LD_VAR 0 1
70493: PUSH
70494: LD_INT 4
70496: MINUS
70497: PUSH
70498: LD_VAR 0 2
70502: PUSH
70503: LD_INT 4
70505: MINUS
70506: PUSH
70507: LD_INT 2
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: LIST
70514: PUSH
70515: LD_VAR 0 1
70519: PUSH
70520: LD_INT 3
70522: MINUS
70523: PUSH
70524: LD_VAR 0 2
70528: PUSH
70529: LD_INT 1
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: LIST
70536: PUSH
70537: LD_VAR 0 1
70541: PUSH
70542: LD_INT 4
70544: PLUS
70545: PUSH
70546: LD_VAR 0 2
70550: PUSH
70551: LD_INT 4
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: LIST
70558: PUSH
70559: LD_VAR 0 1
70563: PUSH
70564: LD_INT 3
70566: PLUS
70567: PUSH
70568: LD_VAR 0 2
70572: PUSH
70573: LD_INT 3
70575: PLUS
70576: PUSH
70577: LD_INT 5
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: LIST
70584: PUSH
70585: LD_VAR 0 1
70589: PUSH
70590: LD_VAR 0 2
70594: PUSH
70595: LD_INT 4
70597: PLUS
70598: PUSH
70599: LD_INT 0
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: LIST
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: ST_TO_ADDR
// end ; 1 :
70614: GO 71314
70616: LD_INT 1
70618: DOUBLE
70619: EQUAL
70620: IFTRUE 70624
70622: GO 70757
70624: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
70625: LD_ADDR_VAR 0 5
70629: PUSH
70630: LD_VAR 0 1
70634: PUSH
70635: LD_VAR 0 2
70639: PUSH
70640: LD_INT 4
70642: MINUS
70643: PUSH
70644: LD_INT 3
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: LIST
70651: PUSH
70652: LD_VAR 0 1
70656: PUSH
70657: LD_INT 3
70659: MINUS
70660: PUSH
70661: LD_VAR 0 2
70665: PUSH
70666: LD_INT 3
70668: MINUS
70669: PUSH
70670: LD_INT 2
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: LIST
70677: PUSH
70678: LD_VAR 0 1
70682: PUSH
70683: LD_INT 4
70685: MINUS
70686: PUSH
70687: LD_VAR 0 2
70691: PUSH
70692: LD_INT 1
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: LIST
70699: PUSH
70700: LD_VAR 0 1
70704: PUSH
70705: LD_VAR 0 2
70709: PUSH
70710: LD_INT 3
70712: PLUS
70713: PUSH
70714: LD_INT 0
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: LIST
70721: PUSH
70722: LD_VAR 0 1
70726: PUSH
70727: LD_INT 4
70729: PLUS
70730: PUSH
70731: LD_VAR 0 2
70735: PUSH
70736: LD_INT 4
70738: PLUS
70739: PUSH
70740: LD_INT 5
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: LIST
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: ST_TO_ADDR
// end ; 2 :
70755: GO 71314
70757: LD_INT 2
70759: DOUBLE
70760: EQUAL
70761: IFTRUE 70765
70763: GO 70894
70765: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
70766: LD_ADDR_VAR 0 5
70770: PUSH
70771: LD_VAR 0 1
70775: PUSH
70776: LD_VAR 0 2
70780: PUSH
70781: LD_INT 3
70783: MINUS
70784: PUSH
70785: LD_INT 3
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: LIST
70792: PUSH
70793: LD_VAR 0 1
70797: PUSH
70798: LD_INT 4
70800: PLUS
70801: PUSH
70802: LD_VAR 0 2
70806: PUSH
70807: LD_INT 4
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: LIST
70814: PUSH
70815: LD_VAR 0 1
70819: PUSH
70820: LD_VAR 0 2
70824: PUSH
70825: LD_INT 4
70827: PLUS
70828: PUSH
70829: LD_INT 0
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: LIST
70836: PUSH
70837: LD_VAR 0 1
70841: PUSH
70842: LD_INT 3
70844: MINUS
70845: PUSH
70846: LD_VAR 0 2
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: LIST
70858: PUSH
70859: LD_VAR 0 1
70863: PUSH
70864: LD_INT 4
70866: MINUS
70867: PUSH
70868: LD_VAR 0 2
70872: PUSH
70873: LD_INT 4
70875: MINUS
70876: PUSH
70877: LD_INT 2
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: LIST
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: ST_TO_ADDR
// end ; 3 :
70892: GO 71314
70894: LD_INT 3
70896: DOUBLE
70897: EQUAL
70898: IFTRUE 70902
70900: GO 71035
70902: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
70903: LD_ADDR_VAR 0 5
70907: PUSH
70908: LD_VAR 0 1
70912: PUSH
70913: LD_INT 3
70915: PLUS
70916: PUSH
70917: LD_VAR 0 2
70921: PUSH
70922: LD_INT 4
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: LIST
70929: PUSH
70930: LD_VAR 0 1
70934: PUSH
70935: LD_INT 4
70937: PLUS
70938: PUSH
70939: LD_VAR 0 2
70943: PUSH
70944: LD_INT 4
70946: PLUS
70947: PUSH
70948: LD_INT 5
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: LIST
70955: PUSH
70956: LD_VAR 0 1
70960: PUSH
70961: LD_INT 4
70963: MINUS
70964: PUSH
70965: LD_VAR 0 2
70969: PUSH
70970: LD_INT 1
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: LIST
70977: PUSH
70978: LD_VAR 0 1
70982: PUSH
70983: LD_VAR 0 2
70987: PUSH
70988: LD_INT 4
70990: MINUS
70991: PUSH
70992: LD_INT 3
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: LIST
70999: PUSH
71000: LD_VAR 0 1
71004: PUSH
71005: LD_INT 3
71007: MINUS
71008: PUSH
71009: LD_VAR 0 2
71013: PUSH
71014: LD_INT 3
71016: MINUS
71017: PUSH
71018: LD_INT 2
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: LIST
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: ST_TO_ADDR
// end ; 4 :
71033: GO 71314
71035: LD_INT 4
71037: DOUBLE
71038: EQUAL
71039: IFTRUE 71043
71041: GO 71176
71043: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
71044: LD_ADDR_VAR 0 5
71048: PUSH
71049: LD_VAR 0 1
71053: PUSH
71054: LD_VAR 0 2
71058: PUSH
71059: LD_INT 4
71061: PLUS
71062: PUSH
71063: LD_INT 0
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: LIST
71070: PUSH
71071: LD_VAR 0 1
71075: PUSH
71076: LD_INT 3
71078: PLUS
71079: PUSH
71080: LD_VAR 0 2
71084: PUSH
71085: LD_INT 3
71087: PLUS
71088: PUSH
71089: LD_INT 5
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: LIST
71096: PUSH
71097: LD_VAR 0 1
71101: PUSH
71102: LD_INT 4
71104: PLUS
71105: PUSH
71106: LD_VAR 0 2
71110: PUSH
71111: LD_INT 4
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: LIST
71118: PUSH
71119: LD_VAR 0 1
71123: PUSH
71124: LD_VAR 0 2
71128: PUSH
71129: LD_INT 3
71131: MINUS
71132: PUSH
71133: LD_INT 3
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: LIST
71140: PUSH
71141: LD_VAR 0 1
71145: PUSH
71146: LD_INT 4
71148: MINUS
71149: PUSH
71150: LD_VAR 0 2
71154: PUSH
71155: LD_INT 4
71157: MINUS
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: LIST
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: ST_TO_ADDR
// end ; 5 :
71174: GO 71314
71176: LD_INT 5
71178: DOUBLE
71179: EQUAL
71180: IFTRUE 71184
71182: GO 71313
71184: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
71185: LD_ADDR_VAR 0 5
71189: PUSH
71190: LD_VAR 0 1
71194: PUSH
71195: LD_INT 4
71197: MINUS
71198: PUSH
71199: LD_VAR 0 2
71203: PUSH
71204: LD_INT 1
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: LIST
71211: PUSH
71212: LD_VAR 0 1
71216: PUSH
71217: LD_VAR 0 2
71221: PUSH
71222: LD_INT 4
71224: MINUS
71225: PUSH
71226: LD_INT 3
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: LIST
71233: PUSH
71234: LD_VAR 0 1
71238: PUSH
71239: LD_INT 4
71241: PLUS
71242: PUSH
71243: LD_VAR 0 2
71247: PUSH
71248: LD_INT 4
71250: PLUS
71251: PUSH
71252: LD_INT 5
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: LIST
71259: PUSH
71260: LD_VAR 0 1
71264: PUSH
71265: LD_INT 3
71267: PLUS
71268: PUSH
71269: LD_VAR 0 2
71273: PUSH
71274: LD_INT 4
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: LIST
71281: PUSH
71282: LD_VAR 0 1
71286: PUSH
71287: LD_VAR 0 2
71291: PUSH
71292: LD_INT 3
71294: PLUS
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: LIST
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: ST_TO_ADDR
// end ; end ;
71311: GO 71314
71313: POP
// result := list ;
71314: LD_ADDR_VAR 0 4
71318: PUSH
71319: LD_VAR 0 5
71323: ST_TO_ADDR
// end ;
71324: LD_VAR 0 4
71328: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
71329: LD_INT 0
71331: PPUSH
71332: PPUSH
71333: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
71334: LD_VAR 0 1
71338: NOT
71339: PUSH
71340: LD_VAR 0 2
71344: PUSH
71345: LD_INT 1
71347: PUSH
71348: LD_INT 2
71350: PUSH
71351: LD_INT 3
71353: PUSH
71354: LD_INT 4
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: IN
71363: NOT
71364: OR
71365: IFFALSE 71369
// exit ;
71367: GO 71461
// tmp := [ ] ;
71369: LD_ADDR_VAR 0 5
71373: PUSH
71374: EMPTY
71375: ST_TO_ADDR
// for i in units do
71376: LD_ADDR_VAR 0 4
71380: PUSH
71381: LD_VAR 0 1
71385: PUSH
71386: FOR_IN
71387: IFFALSE 71430
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
71389: LD_ADDR_VAR 0 5
71393: PUSH
71394: LD_VAR 0 5
71398: PPUSH
71399: LD_VAR 0 5
71403: PUSH
71404: LD_INT 1
71406: PLUS
71407: PPUSH
71408: LD_VAR 0 4
71412: PPUSH
71413: LD_VAR 0 2
71417: PPUSH
71418: CALL_OW 259
71422: PPUSH
71423: CALL_OW 2
71427: ST_TO_ADDR
71428: GO 71386
71430: POP
71431: POP
// if not tmp then
71432: LD_VAR 0 5
71436: NOT
71437: IFFALSE 71441
// exit ;
71439: GO 71461
// result := SortListByListDesc ( units , tmp ) ;
71441: LD_ADDR_VAR 0 3
71445: PUSH
71446: LD_VAR 0 1
71450: PPUSH
71451: LD_VAR 0 5
71455: PPUSH
71456: CALL_OW 77
71460: ST_TO_ADDR
// end ;
71461: LD_VAR 0 3
71465: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
71466: LD_INT 0
71468: PPUSH
71469: PPUSH
71470: PPUSH
// x := GetX ( building ) ;
71471: LD_ADDR_VAR 0 4
71475: PUSH
71476: LD_VAR 0 2
71480: PPUSH
71481: CALL_OW 250
71485: ST_TO_ADDR
// y := GetY ( building ) ;
71486: LD_ADDR_VAR 0 5
71490: PUSH
71491: LD_VAR 0 2
71495: PPUSH
71496: CALL_OW 251
71500: ST_TO_ADDR
// if GetTaskList ( unit ) then
71501: LD_VAR 0 1
71505: PPUSH
71506: CALL_OW 437
71510: IFFALSE 71605
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
71512: LD_STRING e
71514: PUSH
71515: LD_VAR 0 1
71519: PPUSH
71520: CALL_OW 437
71524: PUSH
71525: LD_INT 1
71527: ARRAY
71528: PUSH
71529: LD_INT 1
71531: ARRAY
71532: EQUAL
71533: PUSH
71534: LD_VAR 0 4
71538: PUSH
71539: LD_VAR 0 1
71543: PPUSH
71544: CALL_OW 437
71548: PUSH
71549: LD_INT 1
71551: ARRAY
71552: PUSH
71553: LD_INT 2
71555: ARRAY
71556: EQUAL
71557: AND
71558: PUSH
71559: LD_VAR 0 5
71563: PUSH
71564: LD_VAR 0 1
71568: PPUSH
71569: CALL_OW 437
71573: PUSH
71574: LD_INT 1
71576: ARRAY
71577: PUSH
71578: LD_INT 3
71580: ARRAY
71581: EQUAL
71582: AND
71583: IFFALSE 71595
// result := true else
71585: LD_ADDR_VAR 0 3
71589: PUSH
71590: LD_INT 1
71592: ST_TO_ADDR
71593: GO 71603
// result := false ;
71595: LD_ADDR_VAR 0 3
71599: PUSH
71600: LD_INT 0
71602: ST_TO_ADDR
// end else
71603: GO 71613
// result := false ;
71605: LD_ADDR_VAR 0 3
71609: PUSH
71610: LD_INT 0
71612: ST_TO_ADDR
// end ;
71613: LD_VAR 0 3
71617: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
71618: LD_INT 0
71620: PPUSH
71621: PPUSH
71622: PPUSH
71623: PPUSH
// if not unit or not area then
71624: LD_VAR 0 1
71628: NOT
71629: PUSH
71630: LD_VAR 0 2
71634: NOT
71635: OR
71636: IFFALSE 71640
// exit ;
71638: GO 71805
// tmp := AreaToList ( area , i ) ;
71640: LD_ADDR_VAR 0 6
71644: PUSH
71645: LD_VAR 0 2
71649: PPUSH
71650: LD_VAR 0 5
71654: PPUSH
71655: CALL_OW 517
71659: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
71660: LD_ADDR_VAR 0 5
71664: PUSH
71665: DOUBLE
71666: LD_INT 1
71668: DEC
71669: ST_TO_ADDR
71670: LD_VAR 0 6
71674: PUSH
71675: LD_INT 1
71677: ARRAY
71678: PUSH
71679: FOR_TO
71680: IFFALSE 71795
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
71682: LD_ADDR_VAR 0 7
71686: PUSH
71687: LD_VAR 0 6
71691: PUSH
71692: LD_INT 1
71694: ARRAY
71695: PUSH
71696: LD_VAR 0 5
71700: ARRAY
71701: PUSH
71702: LD_VAR 0 6
71706: PUSH
71707: LD_INT 2
71709: ARRAY
71710: PUSH
71711: LD_VAR 0 5
71715: ARRAY
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
71721: LD_VAR 0 7
71725: PUSH
71726: LD_INT 1
71728: ARRAY
71729: PPUSH
71730: LD_VAR 0 7
71734: PUSH
71735: LD_INT 2
71737: ARRAY
71738: PPUSH
71739: CALL_OW 428
71743: PUSH
71744: LD_INT 0
71746: EQUAL
71747: IFFALSE 71793
// begin result := true ;
71749: LD_ADDR_VAR 0 4
71753: PUSH
71754: LD_INT 1
71756: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
71757: LD_VAR 0 1
71761: PPUSH
71762: LD_VAR 0 7
71766: PUSH
71767: LD_INT 1
71769: ARRAY
71770: PPUSH
71771: LD_VAR 0 7
71775: PUSH
71776: LD_INT 2
71778: ARRAY
71779: PPUSH
71780: LD_VAR 0 3
71784: PPUSH
71785: CALL_OW 48
// exit ;
71789: POP
71790: POP
71791: GO 71805
// end ; end ;
71793: GO 71679
71795: POP
71796: POP
// result := false ;
71797: LD_ADDR_VAR 0 4
71801: PUSH
71802: LD_INT 0
71804: ST_TO_ADDR
// end ;
71805: LD_VAR 0 4
71809: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
71810: LD_INT 0
71812: PPUSH
71813: PPUSH
71814: PPUSH
// if not side or side > 8 then
71815: LD_VAR 0 1
71819: NOT
71820: PUSH
71821: LD_VAR 0 1
71825: PUSH
71826: LD_INT 8
71828: GREATER
71829: OR
71830: IFFALSE 71834
// exit ;
71832: GO 72021
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
71834: LD_ADDR_VAR 0 4
71838: PUSH
71839: LD_INT 22
71841: PUSH
71842: LD_VAR 0 1
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 21
71853: PUSH
71854: LD_INT 3
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PPUSH
71865: CALL_OW 69
71869: ST_TO_ADDR
// if not tmp then
71870: LD_VAR 0 4
71874: NOT
71875: IFFALSE 71879
// exit ;
71877: GO 72021
// enable_addtolog := true ;
71879: LD_ADDR_OWVAR 81
71883: PUSH
71884: LD_INT 1
71886: ST_TO_ADDR
// AddToLog ( [ ) ;
71887: LD_STRING [
71889: PPUSH
71890: CALL_OW 561
// for i in tmp do
71894: LD_ADDR_VAR 0 3
71898: PUSH
71899: LD_VAR 0 4
71903: PUSH
71904: FOR_IN
71905: IFFALSE 72012
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
71907: LD_STRING [
71909: PUSH
71910: LD_VAR 0 3
71914: PPUSH
71915: CALL_OW 266
71919: STR
71920: PUSH
71921: LD_STRING , 
71923: STR
71924: PUSH
71925: LD_VAR 0 3
71929: PPUSH
71930: CALL_OW 250
71934: STR
71935: PUSH
71936: LD_STRING , 
71938: STR
71939: PUSH
71940: LD_VAR 0 3
71944: PPUSH
71945: CALL_OW 251
71949: STR
71950: PUSH
71951: LD_STRING , 
71953: STR
71954: PUSH
71955: LD_VAR 0 3
71959: PPUSH
71960: CALL_OW 254
71964: STR
71965: PUSH
71966: LD_STRING , 
71968: STR
71969: PUSH
71970: LD_VAR 0 3
71974: PPUSH
71975: LD_INT 1
71977: PPUSH
71978: CALL_OW 268
71982: STR
71983: PUSH
71984: LD_STRING , 
71986: STR
71987: PUSH
71988: LD_VAR 0 3
71992: PPUSH
71993: LD_INT 2
71995: PPUSH
71996: CALL_OW 268
72000: STR
72001: PUSH
72002: LD_STRING ],
72004: STR
72005: PPUSH
72006: CALL_OW 561
// end ;
72010: GO 71904
72012: POP
72013: POP
// AddToLog ( ]; ) ;
72014: LD_STRING ];
72016: PPUSH
72017: CALL_OW 561
// end ;
72021: LD_VAR 0 2
72025: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
72026: LD_INT 0
72028: PPUSH
72029: PPUSH
72030: PPUSH
72031: PPUSH
72032: PPUSH
// if not area or not rate or not max then
72033: LD_VAR 0 1
72037: NOT
72038: PUSH
72039: LD_VAR 0 2
72043: NOT
72044: OR
72045: PUSH
72046: LD_VAR 0 4
72050: NOT
72051: OR
72052: IFFALSE 72056
// exit ;
72054: GO 72248
// while 1 do
72056: LD_INT 1
72058: IFFALSE 72248
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
72060: LD_ADDR_VAR 0 9
72064: PUSH
72065: LD_VAR 0 1
72069: PPUSH
72070: LD_INT 1
72072: PPUSH
72073: CALL_OW 287
72077: PUSH
72078: LD_INT 10
72080: MUL
72081: ST_TO_ADDR
// r := rate / 10 ;
72082: LD_ADDR_VAR 0 7
72086: PUSH
72087: LD_VAR 0 2
72091: PUSH
72092: LD_INT 10
72094: DIVREAL
72095: ST_TO_ADDR
// time := 1 1$00 ;
72096: LD_ADDR_VAR 0 8
72100: PUSH
72101: LD_INT 2100
72103: ST_TO_ADDR
// if amount < min then
72104: LD_VAR 0 9
72108: PUSH
72109: LD_VAR 0 3
72113: LESS
72114: IFFALSE 72132
// r := r * 2 else
72116: LD_ADDR_VAR 0 7
72120: PUSH
72121: LD_VAR 0 7
72125: PUSH
72126: LD_INT 2
72128: MUL
72129: ST_TO_ADDR
72130: GO 72158
// if amount > max then
72132: LD_VAR 0 9
72136: PUSH
72137: LD_VAR 0 4
72141: GREATER
72142: IFFALSE 72158
// r := r / 2 ;
72144: LD_ADDR_VAR 0 7
72148: PUSH
72149: LD_VAR 0 7
72153: PUSH
72154: LD_INT 2
72156: DIVREAL
72157: ST_TO_ADDR
// time := time / r ;
72158: LD_ADDR_VAR 0 8
72162: PUSH
72163: LD_VAR 0 8
72167: PUSH
72168: LD_VAR 0 7
72172: DIVREAL
72173: ST_TO_ADDR
// if time < 0 then
72174: LD_VAR 0 8
72178: PUSH
72179: LD_INT 0
72181: LESS
72182: IFFALSE 72199
// time := time * - 1 ;
72184: LD_ADDR_VAR 0 8
72188: PUSH
72189: LD_VAR 0 8
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: MUL
72198: ST_TO_ADDR
// wait ( time ) ;
72199: LD_VAR 0 8
72203: PPUSH
72204: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
72208: LD_INT 35
72210: PPUSH
72211: LD_INT 875
72213: PPUSH
72214: CALL_OW 12
72218: PPUSH
72219: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
72223: LD_INT 1
72225: PPUSH
72226: LD_INT 5
72228: PPUSH
72229: CALL_OW 12
72233: PPUSH
72234: LD_VAR 0 1
72238: PPUSH
72239: LD_INT 1
72241: PPUSH
72242: CALL_OW 55
// end ;
72246: GO 72056
// end ;
72248: LD_VAR 0 5
72252: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
72253: LD_INT 0
72255: PPUSH
72256: PPUSH
72257: PPUSH
72258: PPUSH
72259: PPUSH
72260: PPUSH
72261: PPUSH
72262: PPUSH
// if not turrets or not factories then
72263: LD_VAR 0 1
72267: NOT
72268: PUSH
72269: LD_VAR 0 2
72273: NOT
72274: OR
72275: IFFALSE 72279
// exit ;
72277: GO 72586
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
72279: LD_ADDR_VAR 0 10
72283: PUSH
72284: LD_INT 5
72286: PUSH
72287: LD_INT 6
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 2
72296: PUSH
72297: LD_INT 4
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 3
72306: PUSH
72307: LD_INT 5
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 24
72321: PUSH
72322: LD_INT 25
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 23
72331: PUSH
72332: LD_INT 27
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 42
72345: PUSH
72346: LD_INT 43
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 44
72355: PUSH
72356: LD_INT 46
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 45
72365: PUSH
72366: LD_INT 47
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: LIST
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: LIST
72382: ST_TO_ADDR
// result := [ ] ;
72383: LD_ADDR_VAR 0 3
72387: PUSH
72388: EMPTY
72389: ST_TO_ADDR
// for i in turrets do
72390: LD_ADDR_VAR 0 4
72394: PUSH
72395: LD_VAR 0 1
72399: PUSH
72400: FOR_IN
72401: IFFALSE 72584
// begin nat := GetNation ( i ) ;
72403: LD_ADDR_VAR 0 7
72407: PUSH
72408: LD_VAR 0 4
72412: PPUSH
72413: CALL_OW 248
72417: ST_TO_ADDR
// weapon := 0 ;
72418: LD_ADDR_VAR 0 8
72422: PUSH
72423: LD_INT 0
72425: ST_TO_ADDR
// if not nat then
72426: LD_VAR 0 7
72430: NOT
72431: IFFALSE 72435
// continue ;
72433: GO 72400
// for j in list [ nat ] do
72435: LD_ADDR_VAR 0 5
72439: PUSH
72440: LD_VAR 0 10
72444: PUSH
72445: LD_VAR 0 7
72449: ARRAY
72450: PUSH
72451: FOR_IN
72452: IFFALSE 72493
// if GetBWeapon ( i ) = j [ 1 ] then
72454: LD_VAR 0 4
72458: PPUSH
72459: CALL_OW 269
72463: PUSH
72464: LD_VAR 0 5
72468: PUSH
72469: LD_INT 1
72471: ARRAY
72472: EQUAL
72473: IFFALSE 72491
// begin weapon := j [ 2 ] ;
72475: LD_ADDR_VAR 0 8
72479: PUSH
72480: LD_VAR 0 5
72484: PUSH
72485: LD_INT 2
72487: ARRAY
72488: ST_TO_ADDR
// break ;
72489: GO 72493
// end ;
72491: GO 72451
72493: POP
72494: POP
// if not weapon then
72495: LD_VAR 0 8
72499: NOT
72500: IFFALSE 72504
// continue ;
72502: GO 72400
// for k in factories do
72504: LD_ADDR_VAR 0 6
72508: PUSH
72509: LD_VAR 0 2
72513: PUSH
72514: FOR_IN
72515: IFFALSE 72580
// begin weapons := AvailableWeaponList ( k ) ;
72517: LD_ADDR_VAR 0 9
72521: PUSH
72522: LD_VAR 0 6
72526: PPUSH
72527: CALL_OW 478
72531: ST_TO_ADDR
// if not weapons then
72532: LD_VAR 0 9
72536: NOT
72537: IFFALSE 72541
// continue ;
72539: GO 72514
// if weapon in weapons then
72541: LD_VAR 0 8
72545: PUSH
72546: LD_VAR 0 9
72550: IN
72551: IFFALSE 72578
// begin result := [ i , weapon ] ;
72553: LD_ADDR_VAR 0 3
72557: PUSH
72558: LD_VAR 0 4
72562: PUSH
72563: LD_VAR 0 8
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: ST_TO_ADDR
// exit ;
72572: POP
72573: POP
72574: POP
72575: POP
72576: GO 72586
// end ; end ;
72578: GO 72514
72580: POP
72581: POP
// end ;
72582: GO 72400
72584: POP
72585: POP
// end ;
72586: LD_VAR 0 3
72590: RET
