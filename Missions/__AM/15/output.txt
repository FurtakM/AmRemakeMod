// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 58 0 0
// InitMacro ;
   8: CALL 33318 0 0
// InitNature ;
  12: CALL 33142 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// PrepareAlliance ;
  29: CALL 10685 0 0
// PrepareRussian ;
  33: CALL 6778 0 0
// PrepareLegion ;
  37: CALL 4018 0 0
// PreparePowell ;
  41: CALL 2772 0 0
// PrepareAmerican ;
  45: CALL 1595 0 0
// Action ;
  49: CALL 14592 0 0
// MC_Start ( ) ;
  53: CALL 34465 0 0
// end ;
  57: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  58: LD_INT 0
  60: PPUSH
// debug := false ;
  61: LD_ADDR_EXP 1
  65: PUSH
  66: LD_INT 0
  68: ST_TO_ADDR
// missionStart := false ;
  69: LD_ADDR_EXP 13
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// missionTime := 0 0$00 ;
  77: LD_ADDR_EXP 14
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// missionStage := 1 ;
  85: LD_ADDR_EXP 15
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// activeAttacks := false ;
  93: LD_ADDR_EXP 16
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// powellAnger := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// powellAllowRetreat := true ;
 109: LD_ADDR_EXP 19
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// powellCenterCameraMode := false ;
 117: LD_ADDR_EXP 20
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 125: LD_ADDR_EXP 18
 129: PUSH
 130: EMPTY
 131: PUSH
 132: EMPTY
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// russianDestroyed := false ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// legionDestroyed := false ;
 146: LD_ADDR_EXP 22
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// allianceDestroyed := false ;
 154: LD_ADDR_EXP 23
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 2
 166: PUSH
 167: LD_STRING 14_KappaStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 3
 182: PUSH
 183: LD_STRING 06_KurtStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 194: LD_ADDR_EXP 4
 198: PUSH
 199: LD_STRING 14_JMMVeh_1
 201: PPUSH
 202: LD_INT 0
 204: PPUSH
 205: CALL_OW 30
 209: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 210: LD_ADDR_EXP 5
 214: PUSH
 215: LD_STRING 14_JMMGirlVeh_1
 217: PPUSH
 218: LD_INT 0
 220: PPUSH
 221: CALL_OW 30
 225: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 226: LD_ADDR_EXP 7
 230: PUSH
 231: LD_STRING 14_JMMGirl_1
 233: PPUSH
 234: LD_INT 0
 236: PPUSH
 237: CALL_OW 30
 241: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 242: LD_ADDR_EXP 6
 246: PUSH
 247: LD_STRING 14_JMMGirlStatus_1
 249: PPUSH
 250: LD_INT 0
 252: PPUSH
 253: CALL_OW 30
 257: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 258: LD_ADDR_EXP 8
 262: PUSH
 263: LD_STRING 10_KhatamStatus_1
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 30
 273: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 274: LD_ADDR_EXP 9
 278: PUSH
 279: LD_STRING 13_BurlakStatus_1
 281: PPUSH
 282: LD_INT 0
 284: PPUSH
 285: CALL_OW 30
 289: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 290: LD_ADDR_EXP 10
 294: PUSH
 295: LD_STRING 13_StevensStatus_1
 297: PPUSH
 298: LD_INT 0
 300: PPUSH
 301: CALL_OW 30
 305: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 306: LD_ADDR_EXP 11
 310: PUSH
 311: LD_STRING 14_FastEnd_1
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: CALL_OW 30
 321: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 322: LD_ADDR_EXP 12
 326: PUSH
 327: LD_STRING 12_MainDepositFake_1
 329: PPUSH
 330: LD_INT 0
 332: PPUSH
 333: CALL_OW 30
 337: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 338: LD_ADDR_EXP 24
 342: PUSH
 343: LD_INT 1
 345: ST_TO_ADDR
// behemothUnderConstruct := false ;
 346: LD_ADDR_EXP 26
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 354: LD_ADDR_EXP 27
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// behemothDone := false ;
 362: LD_ADDR_EXP 28
 366: PUSH
 367: LD_INT 0
 369: ST_TO_ADDR
// allowBehemothConstruct := false ;
 370: LD_ADDR_EXP 25
 374: PUSH
 375: LD_INT 0
 377: ST_TO_ADDR
// seeBehemoth := false ;
 378: LD_ADDR_EXP 29
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// platonovHasBomb := false ;
 386: LD_ADDR_EXP 30
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// allianceActive := false ;
 394: LD_ADDR_EXP 31
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// rothCaptured := false ;
 402: LD_ADDR_EXP 33
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// lostCounter := 0 ;
 410: LD_ADDR_EXP 32
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// capturedUnit := [ ] ;
 418: LD_ADDR_EXP 34
 422: PUSH
 423: EMPTY
 424: ST_TO_ADDR
// trueAmericans := [ ] ;
 425: LD_ADDR_EXP 35
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// end ;
 432: LD_VAR 0 1
 436: RET
// export function CustomInitMacro ( ) ; begin
 437: LD_INT 0
 439: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 440: LD_ADDR_EXP 123
 444: PUSH
 445: LD_INT 2
 447: PUSH
 448: LD_INT 3
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 10
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 463: LD_ADDR_EXP 124
 467: PUSH
 468: LD_INT 1
 470: PUSH
 471: LD_INT 4
 473: PUSH
 474: LD_INT 5
 476: PUSH
 477: LD_INT 9
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 486: LD_INT 1
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: PPUSH
 503: CALL 56263 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 507: LD_INT 1
 509: PPUSH
 510: LD_INT 17
 512: PUSH
 513: EMPTY
 514: LIST
 515: PPUSH
 516: CALL 56356 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL 55769 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 24
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: LD_INT 3
 541: PUSH
 542: LD_INT 47
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: LD_INT 24
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 47
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 24
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 47
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 24
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 1
 595: PUSH
 596: LD_INT 47
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 1
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: CALL 55584 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 634: LD_INT 2
 636: PPUSH
 637: LD_INT 10
 639: PUSH
 640: LD_INT 11
 642: PUSH
 643: LD_INT 12
 645: PUSH
 646: LD_INT 14
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PPUSH
 655: CALL 56263 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 16
 664: PUSH
 665: EMPTY
 666: LIST
 667: PPUSH
 668: CALL 56356 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 672: LD_INT 2
 674: PPUSH
 675: LD_INT 21
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 3
 683: PUSH
 684: LD_INT 51
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: LD_INT 24
 695: PUSH
 696: LD_INT 3
 698: PUSH
 699: LD_INT 3
 701: PUSH
 702: LD_INT 47
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: LIST
 709: LIST
 710: PUSH
 711: LD_INT 24
 713: PUSH
 714: LD_INT 3
 716: PUSH
 717: LD_INT 3
 719: PUSH
 720: LD_INT 47
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: PUSH
 729: LD_INT 24
 731: PUSH
 732: LD_INT 3
 734: PUSH
 735: LD_INT 3
 737: PUSH
 738: LD_INT 47
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_INT 24
 749: PUSH
 750: LD_INT 3
 752: PUSH
 753: LD_INT 3
 755: PUSH
 756: LD_INT 47
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: PUSH
 765: LD_INT 24
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: LD_INT 3
 773: PUSH
 774: LD_INT 47
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: LIST
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL 55584 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 795: LD_INT 2
 797: PPUSH
 798: LD_INT 5
 800: PPUSH
 801: CALL 55769 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 805: LD_INT 2
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: CALL 56136 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 815: LD_INT 3
 817: PPUSH
 818: LD_INT 10
 820: PUSH
 821: LD_INT 12
 823: PUSH
 824: LD_INT 15
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_OWVAR 67
 836: ARRAY
 837: PPUSH
 838: LD_INT 27
 840: PPUSH
 841: CALL 55266 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 845: LD_INT 3
 847: PPUSH
 848: LD_INT 10
 850: PUSH
 851: LD_INT 11
 853: PUSH
 854: LD_INT 13
 856: PUSH
 857: LD_INT 15
 859: PUSH
 860: EMPTY
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: PPUSH
 866: CALL 56263 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 870: LD_INT 3
 872: PPUSH
 873: LD_INT 15
 875: PUSH
 876: EMPTY
 877: LIST
 878: PPUSH
 879: CALL 56356 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 883: LD_ADDR_EXP 128
 887: PUSH
 888: LD_EXP 128
 892: PPUSH
 893: LD_INT 3
 895: PPUSH
 896: LD_INT 22
 898: PUSH
 899: LD_INT 8
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: PUSH
 906: LD_INT 25
 908: PUSH
 909: LD_INT 15
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: PPUSH
 920: CALL_OW 69
 924: PPUSH
 925: CALL_OW 1
 929: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 930: LD_INT 3
 932: PPUSH
 933: LD_INT 13
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: LD_INT 1
 941: PUSH
 942: LD_INT 31
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 13
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 1
 959: PUSH
 960: LD_INT 31
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: LIST
 967: LIST
 968: PUSH
 969: LD_INT 13
 971: PUSH
 972: LD_INT 3
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 32
 980: PUSH
 981: EMPTY
 982: LIST
 983: LIST
 984: LIST
 985: LIST
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL 55584 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PPUSH
1009: CALL 56263 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1013: LD_INT 4
1015: PPUSH
1016: LD_INT 9
1018: PUSH
1019: EMPTY
1020: LIST
1021: PPUSH
1022: CALL 56356 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1026: LD_INT 4
1028: PPUSH
1029: LD_INT 26
1031: PUSH
1032: LD_INT 74
1034: PUSH
1035: LD_INT 107
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 77
1052: PUSH
1053: LD_INT 101
1055: PUSH
1056: LD_INT 4
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 69
1070: PUSH
1071: LD_INT 86
1073: PUSH
1074: LD_INT 4
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 27
1085: PUSH
1086: LD_INT 77
1088: PUSH
1089: LD_INT 110
1091: PUSH
1092: LD_INT 3
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 27
1103: PUSH
1104: LD_INT 42
1106: PUSH
1107: LD_INT 79
1109: PUSH
1110: LD_INT 5
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 29
1121: PUSH
1122: LD_INT 86
1124: PUSH
1125: LD_INT 105
1127: PUSH
1128: LD_INT 2
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 30
1139: PUSH
1140: LD_INT 40
1142: PUSH
1143: LD_INT 75
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 32
1157: PUSH
1158: LD_INT 80
1160: PUSH
1161: LD_INT 106
1163: PUSH
1164: LD_INT 4
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 32
1175: PUSH
1176: LD_INT 75
1178: PUSH
1179: LD_INT 114
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 32
1193: PUSH
1194: LD_INT 82
1196: PUSH
1197: LD_INT 110
1199: PUSH
1200: LD_INT 5
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 32
1211: PUSH
1212: LD_INT 62
1214: PUSH
1215: LD_INT 78
1217: PUSH
1218: LD_INT 4
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 4
1229: PUSH
1230: LD_INT 39
1232: PUSH
1233: LD_INT 61
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PPUSH
1259: CALL 55476 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1263: LD_INT 4
1265: PPUSH
1266: LD_INT 5
1268: PUSH
1269: LD_INT 6
1271: PUSH
1272: LD_INT 7
1274: PUSH
1275: LD_INT 9
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PPUSH
1284: CALL 56674 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1288: LD_INT 4
1290: PPUSH
1291: LD_INT 40
1293: PUSH
1294: LD_INT 75
1296: PUSH
1297: LD_INT 1
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 86
1307: PUSH
1308: LD_INT 105
1310: PUSH
1311: LD_INT 0
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PPUSH
1323: CALL 55908 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1327: LD_INT 4
1329: PPUSH
1330: LD_INT 2
1332: PPUSH
1333: CALL 56136 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1337: LD_INT 4
1339: PPUSH
1340: LD_INT 0
1342: PPUSH
1343: CALL 56136 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1347: LD_INT 4
1349: PPUSH
1350: LD_INT 54
1352: PPUSH
1353: LD_INT 85
1355: PPUSH
1356: LD_INT 2
1358: PPUSH
1359: LD_INT 19
1361: PUSH
1362: LD_INT 16
1364: PUSH
1365: LD_INT 17
1367: PUSH
1368: LD_INT 18
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 56468 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 3
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: EMPTY
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 4
1404: PUSH
1405: LD_INT 1
1407: PUSH
1408: LD_INT 1
1410: PUSH
1411: LD_INT 6
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: LD_INT 1
1425: PUSH
1426: LD_INT 1
1428: PUSH
1429: LD_INT 7
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PUSH
1438: LD_INT 4
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: LD_INT 1
1446: PUSH
1447: LD_INT 6
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: PUSH
1456: EMPTY
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL 55584 0 2
// MC_SetTame ( 4 , powellApe ) ;
1466: LD_INT 4
1468: PPUSH
1469: LD_INT 13
1471: PPUSH
1472: CALL 56087 0 2
// end ;
1476: LD_VAR 0 1
1480: RET
// every 0 0$1 trigger debug do var i , tmp ;
1481: LD_EXP 1
1485: IFFALSE 1592
1487: GO 1489
1489: DISABLE
1490: LD_INT 0
1492: PPUSH
1493: PPUSH
// begin enable ;
1494: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1495: LD_ADDR_VAR 0 2
1499: PUSH
1500: LD_INT 22
1502: PUSH
1503: LD_INT 1
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PUSH
1510: LD_INT 3
1512: PUSH
1513: LD_INT 21
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: PUSH
1527: LD_INT 3
1529: PUSH
1530: LD_INT 24
1532: PUSH
1533: LD_INT 999
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: LIST
1548: PPUSH
1549: CALL_OW 69
1553: ST_TO_ADDR
// if not tmp then
1554: LD_VAR 0 2
1558: NOT
1559: IFFALSE 1563
// exit ;
1561: GO 1592
// for i in tmp do
1563: LD_ADDR_VAR 0 1
1567: PUSH
1568: LD_VAR 0 2
1572: PUSH
1573: FOR_IN
1574: IFFALSE 1590
// SetLives ( i , 1000 ) ;
1576: LD_VAR 0 1
1580: PPUSH
1581: LD_INT 1000
1583: PPUSH
1584: CALL_OW 234
1588: GO 1573
1590: POP
1591: POP
// end ; end_of_file
1592: PPOPN 2
1594: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1595: LD_INT 0
1597: PPUSH
// uc_side := 1 ;
1598: LD_ADDR_OWVAR 20
1602: PUSH
1603: LD_INT 1
1605: ST_TO_ADDR
// uc_nation := 1 ;
1606: LD_ADDR_OWVAR 21
1610: PUSH
1611: LD_INT 1
1613: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1614: LD_ADDR_EXP 36
1618: PUSH
1619: LD_STRING JMM
1621: PPUSH
1622: LD_EXP 1
1626: NOT
1627: PPUSH
1628: LD_STRING 14_
1630: PPUSH
1631: CALL 61564 0 3
1635: ST_TO_ADDR
// if not JMMVeh then
1636: LD_EXP 4
1640: NOT
1641: IFFALSE 1664
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 3
1648: PPUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 5
1654: PPUSH
1655: LD_INT 100
1657: PPUSH
1658: CALL 68197 0 5
1662: GO 1723
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1664: LD_EXP 4
1668: PUSH
1669: LD_INT 1
1671: ARRAY
1672: PUSH
1673: LD_INT 1
1675: ARRAY
1676: PPUSH
1677: LD_EXP 4
1681: PUSH
1682: LD_INT 2
1684: ARRAY
1685: PUSH
1686: LD_INT 1
1688: ARRAY
1689: PPUSH
1690: LD_EXP 4
1694: PUSH
1695: LD_INT 3
1697: ARRAY
1698: PUSH
1699: LD_INT 1
1701: ARRAY
1702: PPUSH
1703: LD_EXP 4
1707: PUSH
1708: LD_INT 4
1710: ARRAY
1711: PUSH
1712: LD_INT 1
1714: ARRAY
1715: PPUSH
1716: LD_INT 30
1718: PPUSH
1719: CALL 68197 0 5
// JMMNewVeh := CreateVehicle ;
1723: LD_ADDR_EXP 53
1727: PUSH
1728: CALL_OW 45
1732: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1733: LD_EXP 53
1737: PPUSH
1738: LD_INT 4
1740: PPUSH
1741: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1745: LD_EXP 53
1749: PPUSH
1750: LD_INT 75
1752: PPUSH
1753: LD_INT 92
1755: PPUSH
1756: LD_INT 0
1758: PPUSH
1759: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1763: LD_EXP 36
1767: PPUSH
1768: LD_EXP 53
1772: PPUSH
1773: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1777: LD_EXP 6
1781: PUSH
1782: LD_EXP 2
1786: NOT
1787: AND
1788: IFFALSE 2046
// begin if not JMMGirlVeh then
1790: LD_EXP 5
1794: NOT
1795: IFFALSE 1818
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1797: LD_INT 3
1799: PPUSH
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 9
1808: PPUSH
1809: LD_INT 100
1811: PPUSH
1812: CALL 68197 0 5
1816: GO 1877
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1818: LD_EXP 5
1822: PUSH
1823: LD_INT 1
1825: ARRAY
1826: PUSH
1827: LD_INT 1
1829: ARRAY
1830: PPUSH
1831: LD_EXP 5
1835: PUSH
1836: LD_INT 2
1838: ARRAY
1839: PUSH
1840: LD_INT 1
1842: ARRAY
1843: PPUSH
1844: LD_EXP 5
1848: PUSH
1849: LD_INT 3
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_EXP 5
1861: PUSH
1862: LD_INT 4
1864: ARRAY
1865: PUSH
1866: LD_INT 1
1868: ARRAY
1869: PPUSH
1870: LD_INT 30
1872: PPUSH
1873: CALL 68197 0 5
// GirlNewVeh := CreateVehicle ;
1877: LD_ADDR_EXP 54
1881: PUSH
1882: CALL_OW 45
1886: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1887: LD_EXP 54
1891: PPUSH
1892: LD_INT 4
1894: PPUSH
1895: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1899: LD_EXP 54
1903: PPUSH
1904: LD_INT 82
1906: PPUSH
1907: LD_INT 96
1909: PPUSH
1910: LD_INT 0
1912: PPUSH
1913: CALL_OW 48
// if JMMGirl = 1 then
1917: LD_EXP 7
1921: PUSH
1922: LD_INT 1
1924: EQUAL
1925: IFFALSE 1960
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1927: LD_ADDR_EXP 37
1931: PUSH
1932: LD_STRING Joan
1934: PPUSH
1935: LD_INT 1
1937: PPUSH
1938: LD_STRING 14_
1940: PPUSH
1941: CALL 61564 0 3
1945: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1946: LD_EXP 37
1950: PPUSH
1951: LD_EXP 54
1955: PPUSH
1956: CALL_OW 52
// end ; if JMMGirl = 2 then
1960: LD_EXP 7
1964: PUSH
1965: LD_INT 2
1967: EQUAL
1968: IFFALSE 2003
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1970: LD_ADDR_EXP 39
1974: PUSH
1975: LD_STRING Lisa
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_STRING 14_
1983: PPUSH
1984: CALL 61564 0 3
1988: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1989: LD_EXP 39
1993: PPUSH
1994: LD_EXP 54
1998: PPUSH
1999: CALL_OW 52
// end ; if JMMGirl = 3 then
2003: LD_EXP 7
2007: PUSH
2008: LD_INT 3
2010: EQUAL
2011: IFFALSE 2046
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2013: LD_ADDR_EXP 51
2017: PUSH
2018: LD_STRING Connie
2020: PPUSH
2021: LD_INT 1
2023: PPUSH
2024: LD_STRING 14_
2026: PPUSH
2027: CALL 61564 0 3
2031: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2032: LD_EXP 51
2036: PPUSH
2037: LD_EXP 54
2041: PPUSH
2042: CALL_OW 52
// end ; end ; end ;
2046: LD_VAR 0 1
2050: RET
// export function PrepareStevensSquad ; var tmp ; begin
2051: LD_INT 0
2053: PPUSH
2054: PPUSH
// uc_side := 1 ;
2055: LD_ADDR_OWVAR 20
2059: PUSH
2060: LD_INT 1
2062: ST_TO_ADDR
// uc_nation := 1 ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 1
2070: ST_TO_ADDR
// tmp := [ ] ;
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: EMPTY
2077: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2078: LD_ADDR_EXP 38
2082: PUSH
2083: LD_STRING Stevens
2085: PPUSH
2086: LD_EXP 1
2090: NOT
2091: PPUSH
2092: LD_STRING 13f_
2094: PPUSH
2095: CALL 61564 0 3
2099: ST_TO_ADDR
// if not Stevens then
2100: LD_EXP 38
2104: NOT
2105: IFFALSE 2161
// begin hc_name = Baker Smith ;
2107: LD_ADDR_OWVAR 26
2111: PUSH
2112: LD_STRING Baker Smith
2114: ST_TO_ADDR
// hc_gallery =  ;
2115: LD_ADDR_OWVAR 33
2119: PUSH
2120: LD_STRING 
2122: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2123: LD_INT 1
2125: PPUSH
2126: LD_INT 10
2128: PPUSH
2129: CALL_OW 384
// Baker = CreateHuman ;
2133: LD_ADDR_EXP 52
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_EXP 52
2157: ADD
2158: ST_TO_ADDR
// end else
2159: GO 2177
// tmp := tmp ^ Stevens ;
2161: LD_ADDR_VAR 0 2
2165: PUSH
2166: LD_VAR 0 2
2170: PUSH
2171: LD_EXP 38
2175: ADD
2176: ST_TO_ADDR
// if not Lisa then
2177: LD_EXP 39
2181: NOT
2182: IFFALSE 2228
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2184: LD_ADDR_EXP 39
2188: PUSH
2189: LD_STRING Lisa
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13f_
2200: PPUSH
2201: CALL 61564 0 3
2205: ST_TO_ADDR
// if Lisa then
2206: LD_EXP 39
2210: IFFALSE 2228
// tmp := tmp ^ Lisa ;
2212: LD_ADDR_VAR 0 2
2216: PUSH
2217: LD_VAR 0 2
2221: PUSH
2222: LD_EXP 39
2226: ADD
2227: ST_TO_ADDR
// end ; if not Donaldson then
2228: LD_EXP 40
2232: NOT
2233: IFFALSE 2279
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2235: LD_ADDR_EXP 40
2239: PUSH
2240: LD_STRING Donaldson
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13f_
2251: PPUSH
2252: CALL 61564 0 3
2256: ST_TO_ADDR
// if Donaldson then
2257: LD_EXP 40
2261: IFFALSE 2279
// tmp := tmp ^ Donaldson ;
2263: LD_ADDR_VAR 0 2
2267: PUSH
2268: LD_VAR 0 2
2272: PUSH
2273: LD_EXP 40
2277: ADD
2278: ST_TO_ADDR
// end ; if not Bobby then
2279: LD_EXP 41
2283: NOT
2284: IFFALSE 2330
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2286: LD_ADDR_EXP 41
2290: PUSH
2291: LD_STRING Bobby
2293: PPUSH
2294: LD_EXP 1
2298: NOT
2299: PPUSH
2300: LD_STRING 13f_
2302: PPUSH
2303: CALL 61564 0 3
2307: ST_TO_ADDR
// if Bobby then
2308: LD_EXP 41
2312: IFFALSE 2330
// tmp := tmp ^ Bobby ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 41
2328: ADD
2329: ST_TO_ADDR
// end ; if not Cyrus then
2330: LD_EXP 42
2334: NOT
2335: IFFALSE 2381
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2337: LD_ADDR_EXP 42
2341: PUSH
2342: LD_STRING Cyrus
2344: PPUSH
2345: LD_EXP 1
2349: NOT
2350: PPUSH
2351: LD_STRING 13f_
2353: PPUSH
2354: CALL 61564 0 3
2358: ST_TO_ADDR
// if Cyrus then
2359: LD_EXP 42
2363: IFFALSE 2381
// tmp := tmp ^ Cyrus ;
2365: LD_ADDR_VAR 0 2
2369: PUSH
2370: LD_VAR 0 2
2374: PUSH
2375: LD_EXP 42
2379: ADD
2380: ST_TO_ADDR
// end ; if not Brown then
2381: LD_EXP 44
2385: NOT
2386: IFFALSE 2432
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2388: LD_ADDR_EXP 44
2392: PUSH
2393: LD_STRING Brown
2395: PPUSH
2396: LD_EXP 1
2400: NOT
2401: PPUSH
2402: LD_STRING 13f_
2404: PPUSH
2405: CALL 61564 0 3
2409: ST_TO_ADDR
// if Brown then
2410: LD_EXP 44
2414: IFFALSE 2432
// tmp := tmp ^ Brown ;
2416: LD_ADDR_VAR 0 2
2420: PUSH
2421: LD_VAR 0 2
2425: PUSH
2426: LD_EXP 44
2430: ADD
2431: ST_TO_ADDR
// end ; if not Gladstone then
2432: LD_EXP 45
2436: NOT
2437: IFFALSE 2483
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2439: LD_ADDR_EXP 45
2443: PUSH
2444: LD_STRING Gladstone
2446: PPUSH
2447: LD_EXP 1
2451: NOT
2452: PPUSH
2453: LD_STRING 13f_
2455: PPUSH
2456: CALL 61564 0 3
2460: ST_TO_ADDR
// if Gladstone then
2461: LD_EXP 45
2465: IFFALSE 2483
// tmp := tmp ^ Gladstone ;
2467: LD_ADDR_VAR 0 2
2471: PUSH
2472: LD_VAR 0 2
2476: PUSH
2477: LD_EXP 45
2481: ADD
2482: ST_TO_ADDR
// end ; if not Houten then
2483: LD_EXP 46
2487: NOT
2488: IFFALSE 2534
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2490: LD_ADDR_EXP 46
2494: PUSH
2495: LD_STRING Houten
2497: PPUSH
2498: LD_EXP 1
2502: NOT
2503: PPUSH
2504: LD_STRING 13f_
2506: PPUSH
2507: CALL 61564 0 3
2511: ST_TO_ADDR
// if Houten then
2512: LD_EXP 46
2516: IFFALSE 2534
// tmp := tmp ^ Houten ;
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: LD_VAR 0 2
2527: PUSH
2528: LD_EXP 46
2532: ADD
2533: ST_TO_ADDR
// end ; if not Cornel then
2534: LD_EXP 47
2538: NOT
2539: IFFALSE 2585
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2541: LD_ADDR_EXP 47
2545: PUSH
2546: LD_STRING Cornel
2548: PPUSH
2549: LD_EXP 1
2553: NOT
2554: PPUSH
2555: LD_STRING 13f_
2557: PPUSH
2558: CALL 61564 0 3
2562: ST_TO_ADDR
// if Cornel then
2563: LD_EXP 47
2567: IFFALSE 2585
// tmp := tmp ^ Cornel ;
2569: LD_ADDR_VAR 0 2
2573: PUSH
2574: LD_VAR 0 2
2578: PUSH
2579: LD_EXP 47
2583: ADD
2584: ST_TO_ADDR
// end ; if not Gary then
2585: LD_EXP 48
2589: NOT
2590: IFFALSE 2636
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2592: LD_ADDR_EXP 48
2596: PUSH
2597: LD_STRING Gary
2599: PPUSH
2600: LD_EXP 1
2604: NOT
2605: PPUSH
2606: LD_STRING 13f_
2608: PPUSH
2609: CALL 61564 0 3
2613: ST_TO_ADDR
// if Gary then
2614: LD_EXP 48
2618: IFFALSE 2636
// tmp := tmp ^ Gary ;
2620: LD_ADDR_VAR 0 2
2624: PUSH
2625: LD_VAR 0 2
2629: PUSH
2630: LD_EXP 48
2634: ADD
2635: ST_TO_ADDR
// end ; if not Frank then
2636: LD_EXP 49
2640: NOT
2641: IFFALSE 2687
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2643: LD_ADDR_EXP 49
2647: PUSH
2648: LD_STRING Frank
2650: PPUSH
2651: LD_EXP 1
2655: NOT
2656: PPUSH
2657: LD_STRING 13f_
2659: PPUSH
2660: CALL 61564 0 3
2664: ST_TO_ADDR
// if Frank then
2665: LD_EXP 49
2669: IFFALSE 2687
// tmp := tmp ^ Frank ;
2671: LD_ADDR_VAR 0 2
2675: PUSH
2676: LD_VAR 0 2
2680: PUSH
2681: LD_EXP 49
2685: ADD
2686: ST_TO_ADDR
// end ; if not Kikuchi then
2687: LD_EXP 50
2691: NOT
2692: IFFALSE 2738
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2694: LD_ADDR_EXP 50
2698: PUSH
2699: LD_STRING Kikuchi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_STRING 13f_
2710: PPUSH
2711: CALL 61564 0 3
2715: ST_TO_ADDR
// if Kikuchi then
2716: LD_EXP 50
2720: IFFALSE 2738
// tmp := tmp ^ Kikuchi ;
2722: LD_ADDR_VAR 0 2
2726: PUSH
2727: LD_VAR 0 2
2731: PUSH
2732: LD_EXP 50
2736: ADD
2737: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2738: LD_ADDR_VAR 0 2
2742: PUSH
2743: LD_VAR 0 2
2747: PUSH
2748: LD_STRING 13_other_survivors
2750: PPUSH
2751: CALL_OW 31
2755: UNION
2756: ST_TO_ADDR
// result := tmp ;
2757: LD_ADDR_VAR 0 1
2761: PUSH
2762: LD_VAR 0 2
2766: ST_TO_ADDR
// end ; end_of_file
2767: LD_VAR 0 1
2771: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2772: LD_INT 0
2774: PPUSH
2775: PPUSH
2776: PPUSH
2777: PPUSH
2778: PPUSH
2779: PPUSH
2780: PPUSH
2781: PPUSH
2782: PPUSH
2783: PPUSH
// uc_side := 4 ;
2784: LD_ADDR_OWVAR 20
2788: PUSH
2789: LD_INT 4
2791: ST_TO_ADDR
// uc_nation := 1 ;
2792: LD_ADDR_OWVAR 21
2796: PUSH
2797: LD_INT 1
2799: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2800: LD_INT 387
2802: PPUSH
2803: CALL_OW 274
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 2500
2813: PPUSH
2814: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2818: LD_INT 387
2820: PPUSH
2821: CALL_OW 274
2825: PPUSH
2826: LD_INT 2
2828: PPUSH
2829: LD_INT 400
2831: PPUSH
2832: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2836: LD_INT 387
2838: PPUSH
2839: CALL_OW 274
2843: PPUSH
2844: LD_INT 3
2846: PPUSH
2847: LD_INT 10
2849: PPUSH
2850: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2854: LD_ADDR_EXP 55
2858: PUSH
2859: LD_STRING Powell
2861: PPUSH
2862: CALL_OW 25
2866: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2867: LD_EXP 55
2871: PPUSH
2872: LD_INT 57
2874: PPUSH
2875: LD_INT 94
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2885: LD_EXP 55
2889: PPUSH
2890: LD_INT 58
2892: PPUSH
2893: LD_INT 94
2895: PPUSH
2896: CALL_OW 118
// vip := [ ] ;
2900: LD_ADDR_EXP 56
2904: PUSH
2905: EMPTY
2906: ST_TO_ADDR
// tmp := [ ] ;
2907: LD_ADDR_VAR 0 6
2911: PUSH
2912: EMPTY
2913: ST_TO_ADDR
// if JMMGirl <> 2 then
2914: LD_EXP 7
2918: PUSH
2919: LD_INT 2
2921: NONEQUAL
2922: IFFALSE 2946
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2924: LD_ADDR_EXP 39
2928: PUSH
2929: LD_STRING Lisa
2931: PPUSH
2932: LD_EXP 1
2936: NOT
2937: PPUSH
2938: LD_STRING 13s_
2940: PPUSH
2941: CALL 61564 0 3
2945: ST_TO_ADDR
// if Lisa then
2946: LD_EXP 39
2950: IFFALSE 2968
// tmp := tmp ^ Lisa ;
2952: LD_ADDR_VAR 0 6
2956: PUSH
2957: LD_VAR 0 6
2961: PUSH
2962: LD_EXP 39
2966: ADD
2967: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2968: LD_ADDR_EXP 40
2972: PUSH
2973: LD_STRING Donaldson
2975: PPUSH
2976: LD_EXP 1
2980: NOT
2981: PPUSH
2982: LD_STRING 13s_
2984: PPUSH
2985: CALL 61564 0 3
2989: ST_TO_ADDR
// if Donaldson then
2990: LD_EXP 40
2994: IFFALSE 3012
// tmp := tmp ^ Donaldson ;
2996: LD_ADDR_VAR 0 6
3000: PUSH
3001: LD_VAR 0 6
3005: PUSH
3006: LD_EXP 40
3010: ADD
3011: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3012: LD_ADDR_EXP 41
3016: PUSH
3017: LD_STRING Bobby
3019: PPUSH
3020: LD_EXP 1
3024: NOT
3025: PPUSH
3026: LD_STRING 13s_
3028: PPUSH
3029: CALL 61564 0 3
3033: ST_TO_ADDR
// if Bobby then
3034: LD_EXP 41
3038: IFFALSE 3056
// tmp := tmp ^ Bobby ;
3040: LD_ADDR_VAR 0 6
3044: PUSH
3045: LD_VAR 0 6
3049: PUSH
3050: LD_EXP 41
3054: ADD
3055: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3056: LD_ADDR_EXP 42
3060: PUSH
3061: LD_STRING Cyrus
3063: PPUSH
3064: LD_EXP 1
3068: NOT
3069: PPUSH
3070: LD_STRING 13s_
3072: PPUSH
3073: CALL 61564 0 3
3077: ST_TO_ADDR
// if Cyrus then
3078: LD_EXP 42
3082: IFFALSE 3100
// tmp := tmp ^ Cyrus ;
3084: LD_ADDR_VAR 0 6
3088: PUSH
3089: LD_VAR 0 6
3093: PUSH
3094: LD_EXP 42
3098: ADD
3099: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3100: LD_ADDR_EXP 43
3104: PUSH
3105: LD_STRING Denis
3107: PPUSH
3108: LD_EXP 1
3112: NOT
3113: PPUSH
3114: LD_STRING 13s_
3116: PPUSH
3117: CALL 61564 0 3
3121: ST_TO_ADDR
// if not Denis then
3122: LD_EXP 43
3126: NOT
3127: IFFALSE 3151
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3129: LD_ADDR_EXP 43
3133: PUSH
3134: LD_STRING Denis
3136: PPUSH
3137: LD_EXP 1
3141: NOT
3142: PPUSH
3143: LD_STRING 13f_
3145: PPUSH
3146: CALL 61564 0 3
3150: ST_TO_ADDR
// if Denis then
3151: LD_EXP 43
3155: IFFALSE 3173
// tmp := tmp ^ Denis ;
3157: LD_ADDR_VAR 0 6
3161: PUSH
3162: LD_VAR 0 6
3166: PUSH
3167: LD_EXP 43
3171: ADD
3172: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3173: LD_ADDR_EXP 44
3177: PUSH
3178: LD_STRING Brown
3180: PPUSH
3181: LD_EXP 1
3185: NOT
3186: PPUSH
3187: LD_STRING 13s_
3189: PPUSH
3190: CALL 61564 0 3
3194: ST_TO_ADDR
// if Brown then
3195: LD_EXP 44
3199: IFFALSE 3217
// tmp := tmp ^ Brown ;
3201: LD_ADDR_VAR 0 6
3205: PUSH
3206: LD_VAR 0 6
3210: PUSH
3211: LD_EXP 44
3215: ADD
3216: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 45
3221: PUSH
3222: LD_STRING Gladstone
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 61564 0 3
3238: ST_TO_ADDR
// if Gladstone then
3239: LD_EXP 45
3243: IFFALSE 3261
// tmp := tmp ^ Gladstone ;
3245: LD_ADDR_VAR 0 6
3249: PUSH
3250: LD_VAR 0 6
3254: PUSH
3255: LD_EXP 45
3259: ADD
3260: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 46
3265: PUSH
3266: LD_STRING Houten
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 61564 0 3
3282: ST_TO_ADDR
// if Houten then
3283: LD_EXP 46
3287: IFFALSE 3305
// tmp := tmp ^ Houten ;
3289: LD_ADDR_VAR 0 6
3293: PUSH
3294: LD_VAR 0 6
3298: PUSH
3299: LD_EXP 46
3303: ADD
3304: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 47
3309: PUSH
3310: LD_STRING Cornel
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 61564 0 3
3326: ST_TO_ADDR
// if Cornel then
3327: LD_EXP 47
3331: IFFALSE 3349
// tmp := tmp ^ Cornel ;
3333: LD_ADDR_VAR 0 6
3337: PUSH
3338: LD_VAR 0 6
3342: PUSH
3343: LD_EXP 47
3347: ADD
3348: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 48
3353: PUSH
3354: LD_STRING Gary
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 61564 0 3
3370: ST_TO_ADDR
// if Gary then
3371: LD_EXP 48
3375: IFFALSE 3393
// tmp := tmp ^ Gary ;
3377: LD_ADDR_VAR 0 6
3381: PUSH
3382: LD_VAR 0 6
3386: PUSH
3387: LD_EXP 48
3391: ADD
3392: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 49
3397: PUSH
3398: LD_STRING Frank
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 61564 0 3
3414: ST_TO_ADDR
// if Frank then
3415: LD_EXP 49
3419: IFFALSE 3437
// tmp := tmp ^ Frank ;
3421: LD_ADDR_VAR 0 6
3425: PUSH
3426: LD_VAR 0 6
3430: PUSH
3431: LD_EXP 49
3435: ADD
3436: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3437: LD_ADDR_EXP 50
3441: PUSH
3442: LD_STRING Kikuchi
3444: PPUSH
3445: LD_EXP 1
3449: NOT
3450: PPUSH
3451: LD_STRING 13s_
3453: PPUSH
3454: CALL 61564 0 3
3458: ST_TO_ADDR
// if Kikuchi then
3459: LD_EXP 50
3463: IFFALSE 3481
// tmp := tmp ^ Kikuchi ;
3465: LD_ADDR_VAR 0 6
3469: PUSH
3470: LD_VAR 0 6
3474: PUSH
3475: LD_EXP 50
3479: ADD
3480: ST_TO_ADDR
// vip := tmp ;
3481: LD_ADDR_EXP 56
3485: PUSH
3486: LD_VAR 0 6
3490: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3491: LD_ADDR_VAR 0 6
3495: PUSH
3496: LD_VAR 0 6
3500: PUSH
3501: LD_STRING 13s_others
3503: PPUSH
3504: CALL_OW 31
3508: UNION
3509: ST_TO_ADDR
// if tmp < 20 then
3510: LD_VAR 0 6
3514: PUSH
3515: LD_INT 20
3517: LESS
3518: IFFALSE 3585
// for i = 1 to 20 - tmp do
3520: LD_ADDR_VAR 0 2
3524: PUSH
3525: DOUBLE
3526: LD_INT 1
3528: DEC
3529: ST_TO_ADDR
3530: LD_INT 20
3532: PUSH
3533: LD_VAR 0 6
3537: MINUS
3538: PUSH
3539: FOR_TO
3540: IFFALSE 3583
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3542: LD_INT 1
3544: PPUSH
3545: LD_VAR 0 2
3549: PUSH
3550: LD_INT 4
3552: MOD
3553: PUSH
3554: LD_INT 1
3556: PLUS
3557: PPUSH
3558: LD_INT 5
3560: PPUSH
3561: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: CALL_OW 44
3579: ADD
3580: ST_TO_ADDR
// end ;
3581: GO 3539
3583: POP
3584: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3585: LD_ADDR_VAR 0 7
3589: PUSH
3590: LD_INT 22
3592: PUSH
3593: LD_INT 4
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PUSH
3600: LD_INT 30
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 69
3618: PUSH
3619: LD_INT 1
3621: ARRAY
3622: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3623: LD_ADDR_VAR 0 8
3627: PUSH
3628: LD_INT 22
3630: PUSH
3631: LD_INT 4
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: PUSH
3638: LD_INT 30
3640: PUSH
3641: LD_INT 6
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PPUSH
3652: CALL_OW 69
3656: PUSH
3657: LD_INT 1
3659: ARRAY
3660: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3661: LD_ADDR_VAR 0 9
3665: PUSH
3666: LD_INT 22
3668: PUSH
3669: LD_INT 4
3671: PUSH
3672: EMPTY
3673: LIST
3674: LIST
3675: PUSH
3676: LD_INT 30
3678: PUSH
3679: LD_INT 4
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PPUSH
3690: CALL_OW 69
3694: PUSH
3695: LD_INT 1
3697: ARRAY
3698: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3699: LD_ADDR_VAR 0 10
3703: PUSH
3704: LD_INT 22
3706: PUSH
3707: LD_INT 4
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 30
3716: PUSH
3717: LD_INT 2
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PPUSH
3728: CALL_OW 69
3732: PUSH
3733: LD_INT 1
3735: ARRAY
3736: ST_TO_ADDR
// for i in tmp do
3737: LD_ADDR_VAR 0 2
3741: PUSH
3742: LD_VAR 0 6
3746: PUSH
3747: FOR_IN
3748: IFFALSE 3874
// begin cl := GetClass ( i ) ;
3750: LD_ADDR_VAR 0 5
3754: PUSH
3755: LD_VAR 0 2
3759: PPUSH
3760: CALL_OW 257
3764: ST_TO_ADDR
// if cl > 4 then
3765: LD_VAR 0 5
3769: PUSH
3770: LD_INT 4
3772: GREATER
3773: IFFALSE 3783
// cl := 1 ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_INT 1
3782: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3783: LD_ADDR_VAR 0 3
3787: PUSH
3788: LD_VAR 0 9
3792: PUSH
3793: LD_VAR 0 7
3797: PUSH
3798: LD_VAR 0 10
3802: PUSH
3803: LD_VAR 0 8
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: PUSH
3814: LD_VAR 0 5
3818: ARRAY
3819: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3820: LD_VAR 0 3
3824: PPUSH
3825: CALL_OW 313
3829: PUSH
3830: LD_INT 5
3832: LESS
3833: IFFALSE 3851
// PlaceHumanInUnit ( i , b ) else
3835: LD_VAR 0 2
3839: PPUSH
3840: LD_VAR 0 3
3844: PPUSH
3845: CALL_OW 52
3849: GO 3872
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3851: LD_VAR 0 2
3855: PPUSH
3856: LD_INT 58
3858: PPUSH
3859: LD_INT 91
3861: PPUSH
3862: LD_INT 6
3864: PPUSH
3865: LD_INT 0
3867: PPUSH
3868: CALL_OW 50
// end ;
3872: GO 3747
3874: POP
3875: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3876: LD_INT 2
3878: PPUSH
3879: LD_INT 1
3881: PPUSH
3882: LD_INT 1
3884: PPUSH
3885: LD_INT 12
3887: PPUSH
3888: LD_INT 100
3890: PPUSH
3891: CALL 68197 0 5
// veh := CreateVehicle ;
3895: LD_ADDR_VAR 0 4
3899: PUSH
3900: CALL_OW 45
3904: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3905: LD_VAR 0 4
3909: PPUSH
3910: LD_INT 4
3912: PPUSH
3913: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3917: LD_VAR 0 4
3921: PPUSH
3922: LD_INT 49
3924: PPUSH
3925: LD_INT 88
3927: PPUSH
3928: LD_INT 0
3930: PPUSH
3931: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3935: LD_VAR 0 4
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_INT 100
3945: PPUSH
3946: CALL_OW 290
// uc_side := 0 ;
3950: LD_ADDR_OWVAR 20
3954: PUSH
3955: LD_INT 0
3957: ST_TO_ADDR
// uc_nation := 0 ;
3958: LD_ADDR_OWVAR 21
3962: PUSH
3963: LD_INT 0
3965: ST_TO_ADDR
// for i = 1 to 4 do
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 4
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4011
// begin InitHc ;
3982: CALL_OW 19
// hc_class := class_apeman ;
3986: LD_ADDR_OWVAR 28
3990: PUSH
3991: LD_INT 12
3993: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
3994: CALL_OW 44
3998: PPUSH
3999: LD_INT 13
4001: PPUSH
4002: LD_INT 0
4004: PPUSH
4005: CALL_OW 49
// end ;
4009: GO 3979
4011: POP
4012: POP
// end ; end_of_file
4013: LD_VAR 0 1
4017: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4018: LD_INT 0
4020: PPUSH
4021: PPUSH
4022: PPUSH
4023: PPUSH
4024: PPUSH
// side := 8 ;
4025: LD_ADDR_VAR 0 3
4029: PUSH
4030: LD_INT 8
4032: ST_TO_ADDR
// uc_side := side ;
4033: LD_ADDR_OWVAR 20
4037: PUSH
4038: LD_VAR 0 3
4042: ST_TO_ADDR
// uc_nation := 2 ;
4043: LD_ADDR_OWVAR 21
4047: PUSH
4048: LD_INT 2
4050: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4051: LD_ADDR_VAR 0 2
4055: PUSH
4056: LD_INT 22
4058: PUSH
4059: LD_VAR 0 3
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: PUSH
4068: LD_INT 21
4070: PUSH
4071: LD_INT 3
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: PPUSH
4082: CALL_OW 69
4086: PUSH
4087: FOR_IN
4088: IFFALSE 4104
// SetBLevel ( i , 10 ) ;
4090: LD_VAR 0 2
4094: PPUSH
4095: LD_INT 10
4097: PPUSH
4098: CALL_OW 241
4102: GO 4087
4104: POP
4105: POP
// if KurtStatus then
4106: LD_EXP 3
4110: IFFALSE 4133
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4112: LD_ADDR_EXP 57
4116: PUSH
4117: LD_STRING Kurt
4119: PPUSH
4120: LD_INT 0
4122: PPUSH
4123: LD_STRING 
4125: PPUSH
4126: CALL 61564 0 3
4130: ST_TO_ADDR
4131: GO 4155
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4133: LD_ADDR_EXP 57
4137: PUSH
4138: LD_STRING AltKurt
4140: PPUSH
4141: LD_EXP 1
4145: NOT
4146: PPUSH
4147: LD_STRING 
4149: PPUSH
4150: CALL 61564 0 3
4154: ST_TO_ADDR
// if not Kurt then
4155: LD_EXP 57
4159: NOT
4160: IFFALSE 4186
// begin InitHc ;
4162: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 10
4171: PPUSH
4172: CALL_OW 381
// Kurt := CreateHuman ;
4176: LD_ADDR_EXP 57
4180: PUSH
4181: CALL_OW 44
4185: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4186: LD_EXP 57
4190: PPUSH
4191: LD_INT 324
4193: PPUSH
4194: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4198: LD_ADDR_EXP 58
4202: PUSH
4203: LD_STRING Kozlov
4205: PPUSH
4206: LD_INT 0
4208: PPUSH
4209: LD_STRING 
4211: PPUSH
4212: CALL 61564 0 3
4216: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4217: LD_EXP 58
4221: PPUSH
4222: LD_INT 22
4224: PUSH
4225: LD_INT 8
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 23
4234: PUSH
4235: LD_INT 3
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 8
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: LIST
4256: PPUSH
4257: CALL_OW 69
4261: PUSH
4262: LD_INT 1
4264: ARRAY
4265: PPUSH
4266: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4270: LD_EXP 58
4274: PPUSH
4275: LD_INT 3
4277: PPUSH
4278: LD_INT 10
4280: PPUSH
4281: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4285: LD_ADDR_VAR 0 5
4289: PUSH
4290: LD_INT 22
4292: PUSH
4293: LD_VAR 0 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 30
4304: PUSH
4305: LD_INT 32
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 58
4314: PUSH
4315: EMPTY
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: LIST
4322: PPUSH
4323: CALL_OW 69
4327: ST_TO_ADDR
// for i = 1 to 10 do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: DOUBLE
4334: LD_INT 1
4336: DEC
4337: ST_TO_ADDR
4338: LD_INT 10
4340: PUSH
4341: FOR_TO
4342: IFFALSE 4414
// begin uc_nation := nation_nature ;
4344: LD_ADDR_OWVAR 21
4348: PUSH
4349: LD_INT 0
4351: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4352: LD_ADDR_OWVAR 28
4356: PUSH
4357: LD_INT 15
4359: ST_TO_ADDR
// hc_gallery :=  ;
4360: LD_ADDR_OWVAR 33
4364: PUSH
4365: LD_STRING 
4367: ST_TO_ADDR
// hc_name :=  ;
4368: LD_ADDR_OWVAR 26
4372: PUSH
4373: LD_STRING 
4375: ST_TO_ADDR
// un := CreateHuman ;
4376: LD_ADDR_VAR 0 4
4380: PUSH
4381: CALL_OW 44
4385: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_VAR 0 5
4395: PUSH
4396: LD_VAR 0 5
4400: PUSH
4401: LD_VAR 0 2
4405: MINUS
4406: ARRAY
4407: PPUSH
4408: CALL_OW 52
// end ;
4412: GO 4341
4414: POP
4415: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4416: LD_ADDR_VAR 0 5
4420: PUSH
4421: LD_STRING 12_kurt_squad
4423: PPUSH
4424: CALL_OW 31
4428: ST_TO_ADDR
// if tmp then
4429: LD_VAR 0 5
4433: IFFALSE 4467
// for i in tmp do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: LD_VAR 0 5
4444: PUSH
4445: FOR_IN
4446: IFFALSE 4465
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4448: LD_VAR 0 2
4452: PPUSH
4453: LD_INT 5
4455: PPUSH
4456: LD_INT 0
4458: PPUSH
4459: CALL_OW 49
4463: GO 4445
4465: POP
4466: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4467: LD_INT 324
4469: PPUSH
4470: LD_INT 5
4472: PPUSH
4473: LD_STRING 
4475: PPUSH
4476: LD_INT 8
4478: PUSH
4479: LD_INT 9
4481: PUSH
4482: LD_INT 10
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: LIST
4489: PUSH
4490: LD_OWVAR 67
4494: ARRAY
4495: PPUSH
4496: LD_INT 3000
4498: PUSH
4499: LD_INT 500
4501: PUSH
4502: LD_INT 150
4504: PUSH
4505: EMPTY
4506: LIST
4507: LIST
4508: LIST
4509: PPUSH
4510: LD_INT 16
4512: PUSH
4513: LD_INT 6
4515: PUSH
4516: LD_INT 6
4518: PUSH
4519: LD_INT 8
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: PPUSH
4528: CALL 71606 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4532: LD_ADDR_EXP 99
4536: PUSH
4537: LD_EXP 99
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: LD_INT 22
4547: PUSH
4548: LD_VAR 0 3
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 23
4559: PUSH
4560: LD_INT 2
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: LD_INT 3
4569: PUSH
4570: LD_INT 21
4572: PUSH
4573: LD_INT 2
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: LIST
4588: PPUSH
4589: CALL_OW 69
4593: PUSH
4594: LD_EXP 57
4598: DIFF
4599: PPUSH
4600: CALL_OW 1
4604: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4605: LD_INT 1
4607: PPUSH
4608: LD_INT 7
4610: PPUSH
4611: CALL_OW 383
// Friend := CreateHuman ;
4615: LD_ADDR_EXP 59
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4625: LD_INT 14
4627: PPUSH
4628: LD_INT 3
4630: PPUSH
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 29
4636: PPUSH
4637: LD_INT 100
4639: PPUSH
4640: CALL 68197 0 5
// powellBomb := CreateVehicle ;
4644: LD_ADDR_EXP 60
4648: PUSH
4649: CALL_OW 45
4653: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4654: LD_EXP 60
4658: PPUSH
4659: LD_INT 90
4661: PPUSH
4662: LD_INT 51
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 48
// end ;
4672: LD_VAR 0 1
4676: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if IsLive ( kozlov_fac ) then
4682: LD_INT 332
4684: PPUSH
4685: CALL_OW 300
4689: IFFALSE 4693
// exit ;
4691: GO 5260
// ComExitBuilding ( Kozlov ) ;
4693: LD_EXP 58
4697: PPUSH
4698: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4702: LD_EXP 58
4706: PPUSH
4707: CALL_OW 257
4711: PUSH
4712: LD_INT 2
4714: NONEQUAL
4715: IFFALSE 4750
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4717: LD_EXP 58
4721: PPUSH
4722: LD_INT 324
4724: PPUSH
4725: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4729: LD_EXP 58
4733: PPUSH
4734: LD_INT 2
4736: PPUSH
4737: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4741: LD_EXP 58
4745: PPUSH
4746: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4750: LD_EXP 58
4754: PPUSH
4755: LD_INT 2
4757: PPUSH
4758: LD_INT 93
4760: PPUSH
4761: LD_INT 32
4763: PPUSH
4764: LD_INT 3
4766: PPUSH
4767: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4771: LD_INT 35
4773: PPUSH
4774: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4778: LD_INT 22
4780: PUSH
4781: LD_INT 8
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PUSH
4788: LD_INT 30
4790: PUSH
4791: LD_INT 3
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 23
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 57
4810: PUSH
4811: EMPTY
4812: LIST
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: IFFALSE 4771
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4826: LD_ADDR_VAR 0 2
4830: PUSH
4831: LD_INT 22
4833: PUSH
4834: LD_INT 8
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PUSH
4841: LD_INT 30
4843: PUSH
4844: LD_INT 3
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PUSH
4851: LD_INT 23
4853: PUSH
4854: LD_INT 3
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: PUSH
4861: LD_INT 57
4863: PUSH
4864: EMPTY
4865: LIST
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: CALL_OW 69
4877: PUSH
4878: LD_INT 1
4880: ARRAY
4881: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 21
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: NOT
4922: IFFALSE 5000
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4924: LD_EXP 58
4928: PPUSH
4929: LD_INT 21
4931: PPUSH
4932: LD_INT 97
4934: PPUSH
4935: LD_INT 36
4937: PPUSH
4938: LD_INT 5
4940: PPUSH
4941: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4945: LD_INT 35
4947: PPUSH
4948: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4952: LD_INT 22
4954: PUSH
4955: LD_INT 8
4957: PUSH
4958: EMPTY
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 23
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PUSH
4972: LD_INT 30
4974: PUSH
4975: LD_INT 21
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: LD_INT 57
4984: PUSH
4985: EMPTY
4986: LIST
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: PPUSH
4994: CALL_OW 69
4998: IFFALSE 4945
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5000: LD_INT 22
5002: PUSH
5003: LD_INT 8
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: LD_INT 23
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 30
5022: PUSH
5023: LD_INT 18
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: NOT
5040: IFFALSE 5118
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5042: LD_EXP 58
5046: PPUSH
5047: LD_INT 18
5049: PPUSH
5050: LD_INT 89
5052: PPUSH
5053: LD_INT 32
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5063: LD_INT 35
5065: PPUSH
5066: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5070: LD_INT 22
5072: PUSH
5073: LD_INT 8
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 23
5082: PUSH
5083: LD_INT 3
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: LD_INT 30
5092: PUSH
5093: LD_INT 18
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: PUSH
5100: LD_INT 57
5102: PUSH
5103: EMPTY
5104: LIST
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: PPUSH
5112: CALL_OW 69
5116: IFFALSE 5063
// end ; lab := kozlov_lab ;
5118: LD_ADDR_VAR 0 3
5122: PUSH
5123: LD_INT 336
5125: ST_TO_ADDR
// if not lab then
5126: LD_VAR 0 3
5130: NOT
5131: IFFALSE 5135
// exit ;
5133: GO 5260
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5135: LD_EXP 58
5139: PPUSH
5140: LD_VAR 0 3
5144: PUSH
5145: LD_INT 1
5147: ARRAY
5148: PPUSH
5149: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5153: LD_EXP 58
5157: PPUSH
5158: LD_INT 4
5160: PPUSH
5161: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5165: LD_VAR 0 3
5169: PUSH
5170: LD_INT 1
5172: ARRAY
5173: PPUSH
5174: LD_INT 25
5176: PPUSH
5177: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5181: LD_INT 35
5183: PPUSH
5184: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5188: LD_INT 25
5190: PPUSH
5191: LD_INT 8
5193: PPUSH
5194: CALL_OW 321
5198: PUSH
5199: LD_INT 2
5201: EQUAL
5202: IFFALSE 5181
// ComExitBuilding ( Kozlov ) ;
5204: LD_EXP 58
5208: PPUSH
5209: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5213: LD_EXP 58
5217: PPUSH
5218: LD_VAR 0 2
5222: PPUSH
5223: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5227: LD_EXP 58
5231: PPUSH
5232: LD_INT 3
5234: PPUSH
5235: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5239: LD_VAR 0 2
5243: PPUSH
5244: LD_INT 23
5246: PPUSH
5247: LD_INT 3
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: LD_INT 48
5255: PPUSH
5256: CALL_OW 125
// end ;
5260: LD_VAR 0 1
5264: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5265: LD_EXP 22
5269: NOT
5270: PUSH
5271: LD_EXP 15
5275: PUSH
5276: LD_INT 6
5278: GREATEREQUAL
5279: AND
5280: IFFALSE 5361
5282: GO 5284
5284: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5285: LD_INT 3
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 55769 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 14
5300: PUSH
5301: LD_INT 1
5303: PUSH
5304: LD_INT 1
5306: PUSH
5307: LD_INT 28
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 14
5318: PUSH
5319: LD_INT 1
5321: PUSH
5322: LD_INT 1
5324: PUSH
5325: LD_INT 28
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: LIST
5332: LIST
5333: PUSH
5334: LD_INT 14
5336: PUSH
5337: LD_INT 1
5339: PUSH
5340: LD_INT 1
5342: PUSH
5343: LD_INT 28
5345: PUSH
5346: EMPTY
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL 55632 0 2
// end ;
5361: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5362: LD_EXP 22
5366: NOT
5367: PUSH
5368: LD_EXP 15
5372: PUSH
5373: LD_INT 6
5375: GREATEREQUAL
5376: AND
5377: PUSH
5378: LD_INT 3
5380: PPUSH
5381: LD_INT 1
5383: PPUSH
5384: CALL 56987 0 2
5388: NOT
5389: AND
5390: IFFALSE 6230
5392: GO 5394
5394: DISABLE
5395: LD_INT 0
5397: PPUSH
5398: PPUSH
5399: PPUSH
// begin enable ;
5400: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5401: LD_INT 22
5403: PUSH
5404: LD_INT 8
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: LD_INT 23
5413: PUSH
5414: LD_INT 2
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: LD_INT 30
5423: PUSH
5424: LD_INT 3
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: LIST
5435: PPUSH
5436: CALL_OW 69
5440: NOT
5441: IFFALSE 5445
// exit ;
5443: GO 6230
// if Prob ( 40 ) then
5445: LD_INT 40
5447: PPUSH
5448: CALL_OW 13
5452: IFFALSE 5579
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5454: LD_INT 3
5456: PPUSH
5457: LD_INT 14
5459: PUSH
5460: LD_INT 1
5462: PUSH
5463: LD_INT 2
5465: PUSH
5466: LD_INT 28
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: LIST
5473: LIST
5474: PUSH
5475: LD_INT 14
5477: PUSH
5478: LD_INT 1
5480: PUSH
5481: LD_INT 2
5483: PUSH
5484: LD_INT 28
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 14
5495: PUSH
5496: LD_INT 1
5498: PUSH
5499: LD_INT 2
5501: PUSH
5502: LD_INT 28
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 14
5513: PUSH
5514: LD_INT 1
5516: PUSH
5517: LD_INT 2
5519: PUSH
5520: LD_INT 28
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 14
5531: PUSH
5532: LD_INT 1
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: LD_INT 28
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: LIST
5546: PUSH
5547: LD_INT 14
5549: PUSH
5550: LD_INT 1
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: LD_INT 26
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: LIST
5563: LIST
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: LIST
5572: PPUSH
5573: CALL 55632 0 2
// end else
5577: GO 5770
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5579: LD_INT 3
5581: PPUSH
5582: LD_INT 14
5584: PUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 2
5590: PUSH
5591: LD_INT 27
5593: PUSH
5594: LD_INT 26
5596: PUSH
5597: LD_INT 26
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_OWVAR 67
5609: ARRAY
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 14
5619: PUSH
5620: LD_INT 1
5622: PUSH
5623: LD_INT 2
5625: PUSH
5626: LD_INT 27
5628: PUSH
5629: LD_INT 26
5631: PUSH
5632: LD_INT 26
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_OWVAR 67
5644: ARRAY
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 14
5654: PUSH
5655: LD_INT 1
5657: PUSH
5658: LD_INT 2
5660: PUSH
5661: LD_INT 26
5663: PUSH
5664: LD_INT 26
5666: PUSH
5667: LD_INT 29
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_OWVAR 67
5679: ARRAY
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: PUSH
5687: LD_INT 13
5689: PUSH
5690: LD_INT 1
5692: PUSH
5693: LD_INT 2
5695: PUSH
5696: LD_INT 26
5698: PUSH
5699: LD_INT 29
5701: PUSH
5702: LD_INT 29
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: LD_INT 13
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 29
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: PUSH
5740: LD_INT 14
5742: PUSH
5743: LD_INT 1
5745: PUSH
5746: LD_INT 2
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: LIST
5756: LIST
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: LIST
5765: PPUSH
5766: CALL 55632 0 2
// end ; repeat wait ( 0 0$1 ) ;
5770: LD_INT 35
5772: PPUSH
5773: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5777: LD_INT 3
5779: PPUSH
5780: LD_INT 1
5782: PPUSH
5783: CALL 56987 0 2
5787: PUSH
5788: LD_INT 6
5790: GREATEREQUAL
5791: IFFALSE 5770
// wait ( 0 0$30 ) ;
5793: LD_INT 1050
5795: PPUSH
5796: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 3
5807: PPUSH
5808: LD_INT 1
5810: PPUSH
5811: CALL 56987 0 2
5815: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5816: LD_ADDR_EXP 118
5820: PUSH
5821: LD_EXP 118
5825: PPUSH
5826: LD_INT 3
5828: PPUSH
5829: LD_EXP 118
5833: PUSH
5834: LD_INT 3
5836: ARRAY
5837: PUSH
5838: LD_VAR 0 2
5842: DIFF
5843: PPUSH
5844: CALL_OW 1
5848: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5849: LD_ADDR_VAR 0 3
5853: PUSH
5854: LD_INT 0
5856: PPUSH
5857: LD_INT 2
5859: PPUSH
5860: CALL_OW 12
5864: ST_TO_ADDR
// if target then
5865: LD_VAR 0 3
5869: IFFALSE 5997
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5871: LD_ADDR_VAR 0 2
5875: PUSH
5876: LD_VAR 0 2
5880: PPUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 250
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PPUSH
5891: CALL_OW 72
5895: ST_TO_ADDR
// for i in tmp do
5896: LD_ADDR_VAR 0 1
5900: PUSH
5901: LD_VAR 0 2
5905: PUSH
5906: FOR_IN
5907: IFFALSE 5947
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5909: LD_VAR 0 1
5913: PPUSH
5914: LD_INT 89
5916: PPUSH
5917: LD_INT 71
5919: PPUSH
5920: CALL_OW 297
5924: PUSH
5925: LD_INT 9
5927: GREATER
5928: IFFALSE 5945
// ComMoveXY ( i , 89 , 71 ) ;
5930: LD_VAR 0 1
5934: PPUSH
5935: LD_INT 89
5937: PPUSH
5938: LD_INT 71
5940: PPUSH
5941: CALL_OW 111
5945: GO 5906
5947: POP
5948: POP
// wait ( 0 0$1 ) ;
5949: LD_INT 35
5951: PPUSH
5952: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
5956: LD_VAR 0 2
5960: PPUSH
5961: LD_INT 92
5963: PUSH
5964: LD_INT 89
5966: PUSH
5967: LD_INT 71
5969: PUSH
5970: LD_INT 9
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PPUSH
5979: CALL_OW 72
5983: PUSH
5984: LD_VAR 0 2
5988: PUSH
5989: LD_INT 1
5991: MINUS
5992: GREATEREQUAL
5993: IFFALSE 5871
// end else
5995: GO 6121
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5997: LD_ADDR_VAR 0 2
6001: PUSH
6002: LD_VAR 0 2
6006: PPUSH
6007: LD_INT 24
6009: PUSH
6010: LD_INT 250
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: PPUSH
6017: CALL_OW 72
6021: ST_TO_ADDR
// for i in tmp do
6022: LD_ADDR_VAR 0 1
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: FOR_IN
6033: IFFALSE 6073
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6035: LD_VAR 0 1
6039: PPUSH
6040: LD_INT 125
6042: PPUSH
6043: LD_INT 129
6045: PPUSH
6046: CALL_OW 297
6050: PUSH
6051: LD_INT 9
6053: GREATER
6054: IFFALSE 6071
// ComMoveXY ( i , 125 , 129 ) ;
6056: LD_VAR 0 1
6060: PPUSH
6061: LD_INT 125
6063: PPUSH
6064: LD_INT 129
6066: PPUSH
6067: CALL_OW 111
6071: GO 6032
6073: POP
6074: POP
// wait ( 0 0$1 ) ;
6075: LD_INT 35
6077: PPUSH
6078: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6082: LD_VAR 0 2
6086: PPUSH
6087: LD_INT 92
6089: PUSH
6090: LD_INT 125
6092: PUSH
6093: LD_INT 129
6095: PUSH
6096: LD_INT 9
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 72
6109: PUSH
6110: LD_VAR 0 2
6114: PUSH
6115: LD_INT 1
6117: MINUS
6118: GREATEREQUAL
6119: IFFALSE 5997
// end ; repeat wait ( 0 0$1 ) ;
6121: LD_INT 35
6123: PPUSH
6124: CALL_OW 67
// for i in tmp do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: LD_VAR 0 2
6137: PUSH
6138: FOR_IN
6139: IFFALSE 6221
// begin if GetLives ( i ) > 251 then
6141: LD_VAR 0 1
6145: PPUSH
6146: CALL_OW 256
6150: PUSH
6151: LD_INT 251
6153: GREATER
6154: IFFALSE 6192
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6156: LD_VAR 0 1
6160: PPUSH
6161: LD_INT 81
6163: PUSH
6164: LD_INT 8
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PPUSH
6171: CALL_OW 69
6175: PPUSH
6176: LD_VAR 0 1
6180: PPUSH
6181: CALL_OW 74
6185: PPUSH
6186: CALL_OW 115
6190: GO 6219
// if IsDead ( i ) then
6192: LD_VAR 0 1
6196: PPUSH
6197: CALL_OW 301
6201: IFFALSE 6219
// tmp := tmp diff i ;
6203: LD_ADDR_VAR 0 2
6207: PUSH
6208: LD_VAR 0 2
6212: PUSH
6213: LD_VAR 0 1
6217: DIFF
6218: ST_TO_ADDR
// end ;
6219: GO 6138
6221: POP
6222: POP
// until not tmp ;
6223: LD_VAR 0 2
6227: NOT
6228: IFFALSE 6121
// end ;
6230: PPOPN 3
6232: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6233: LD_EXP 22
6237: NOT
6238: PUSH
6239: LD_EXP 15
6243: PUSH
6244: LD_INT 6
6246: GREATEREQUAL
6247: AND
6248: PUSH
6249: LD_OWVAR 67
6253: PUSH
6254: LD_INT 1
6256: GREATER
6257: AND
6258: IFFALSE 6775
6260: GO 6262
6262: DISABLE
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
// begin enable ;
6268: ENABLE
// tmp := [ ] ;
6269: LD_ADDR_VAR 0 3
6273: PUSH
6274: EMPTY
6275: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6276: LD_ADDR_VAR 0 1
6280: PUSH
6281: DOUBLE
6282: LD_INT 1
6284: DEC
6285: ST_TO_ADDR
6286: LD_INT 4
6288: PUSH
6289: LD_INT 6
6291: PUSH
6292: LD_INT 7
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PUSH
6306: FOR_TO
6307: IFFALSE 6467
// begin uc_side := 8 ;
6309: LD_ADDR_OWVAR 20
6313: PUSH
6314: LD_INT 8
6316: ST_TO_ADDR
// uc_nation := 2 ;
6317: LD_ADDR_OWVAR 21
6321: PUSH
6322: LD_INT 2
6324: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6325: LD_INT 13
6327: PUSH
6328: LD_INT 14
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 1
6337: PPUSH
6338: LD_INT 2
6340: PPUSH
6341: CALL_OW 12
6345: ARRAY
6346: PPUSH
6347: LD_INT 1
6349: PPUSH
6350: LD_INT 5
6352: PPUSH
6353: LD_INT 27
6355: PUSH
6356: LD_INT 28
6358: PUSH
6359: LD_INT 26
6361: PUSH
6362: LD_INT 25
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: PUSH
6371: LD_INT 1
6373: PPUSH
6374: LD_INT 4
6376: PPUSH
6377: CALL_OW 12
6381: ARRAY
6382: PPUSH
6383: LD_INT 88
6385: PPUSH
6386: CALL 68197 0 5
// un := CreateVehicle ;
6390: LD_ADDR_VAR 0 2
6394: PUSH
6395: CALL_OW 45
6399: ST_TO_ADDR
// tmp := tmp ^ un ;
6400: LD_ADDR_VAR 0 3
6404: PUSH
6405: LD_VAR 0 3
6409: PUSH
6410: LD_VAR 0 2
6414: ADD
6415: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6416: LD_VAR 0 2
6420: PPUSH
6421: LD_INT 3
6423: PPUSH
6424: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6428: LD_VAR 0 2
6432: PPUSH
6433: LD_INT 30
6435: PPUSH
6436: LD_INT 0
6438: PPUSH
6439: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6443: LD_VAR 0 2
6447: PPUSH
6448: LD_INT 16
6450: PPUSH
6451: LD_INT 11
6453: PPUSH
6454: CALL_OW 111
// wait ( 0 0$2 ) ;
6458: LD_INT 70
6460: PPUSH
6461: CALL_OW 67
// end ;
6465: GO 6306
6467: POP
6468: POP
// for i = 1 to Difficulty do
6469: LD_ADDR_VAR 0 1
6473: PUSH
6474: DOUBLE
6475: LD_INT 1
6477: DEC
6478: ST_TO_ADDR
6479: LD_OWVAR 67
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6610
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6503: LD_INT 0
6505: PPUSH
6506: LD_INT 8
6508: PPUSH
6509: LD_INT 8
6511: PUSH
6512: LD_INT 8
6514: PUSH
6515: LD_INT 9
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: PUSH
6523: LD_OWVAR 67
6527: ARRAY
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 2
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// tmp := tmp ^ un ;
6543: LD_ADDR_VAR 0 3
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_VAR 0 2
6557: ADD
6558: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6559: LD_VAR 0 2
6563: PPUSH
6564: LD_INT 3
6566: PPUSH
6567: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6571: LD_VAR 0 2
6575: PPUSH
6576: LD_INT 30
6578: PPUSH
6579: LD_INT 0
6581: PPUSH
6582: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6586: LD_VAR 0 2
6590: PPUSH
6591: LD_INT 16
6593: PPUSH
6594: LD_INT 11
6596: PPUSH
6597: CALL_OW 111
// wait ( 0 0$2 ) ;
6601: LD_INT 70
6603: PPUSH
6604: CALL_OW 67
// end ;
6608: GO 6484
6610: POP
6611: POP
// repeat wait ( 0 0$1 ) ;
6612: LD_INT 35
6614: PPUSH
6615: CALL_OW 67
// for i in tmp do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 3
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6766
// begin if GetLives ( i ) > 250 then
6632: LD_VAR 0 1
6636: PPUSH
6637: CALL_OW 256
6641: PUSH
6642: LD_INT 250
6644: GREATER
6645: IFFALSE 6737
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6647: LD_INT 81
6649: PUSH
6650: LD_INT 8
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 91
6659: PUSH
6660: LD_VAR 0 1
6664: PUSH
6665: LD_INT 10
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: LIST
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PPUSH
6677: CALL_OW 69
6681: NOT
6682: IFFALSE 6701
// ComAgressiveMove ( i , 67 , 110 ) else
6684: LD_VAR 0 1
6688: PPUSH
6689: LD_INT 67
6691: PPUSH
6692: LD_INT 110
6694: PPUSH
6695: CALL_OW 114
6699: GO 6735
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6701: LD_VAR 0 1
6705: PPUSH
6706: LD_INT 81
6708: PUSH
6709: LD_INT 8
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 69
6720: PPUSH
6721: LD_VAR 0 1
6725: PPUSH
6726: CALL_OW 74
6730: PPUSH
6731: CALL_OW 115
// end else
6735: GO 6764
// if IsDead ( i ) then
6737: LD_VAR 0 1
6741: PPUSH
6742: CALL_OW 301
6746: IFFALSE 6764
// tmp := tmp diff i ;
6748: LD_ADDR_VAR 0 3
6752: PUSH
6753: LD_VAR 0 3
6757: PUSH
6758: LD_VAR 0 1
6762: DIFF
6763: ST_TO_ADDR
// end ;
6764: GO 6629
6766: POP
6767: POP
// until not tmp ;
6768: LD_VAR 0 3
6772: NOT
6773: IFFALSE 6612
// end ; end_of_file
6775: PPOPN 3
6777: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6778: LD_INT 0
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
6787: PPUSH
6788: PPUSH
// side := 3 ;
6789: LD_ADDR_VAR 0 6
6793: PUSH
6794: LD_INT 3
6796: ST_TO_ADDR
// uc_side := side ;
6797: LD_ADDR_OWVAR 20
6801: PUSH
6802: LD_VAR 0 6
6806: ST_TO_ADDR
// uc_nation := 3 ;
6807: LD_ADDR_OWVAR 21
6811: PUSH
6812: LD_INT 3
6814: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6815: LD_ADDR_VAR 0 2
6819: PUSH
6820: LD_INT 22
6822: PUSH
6823: LD_VAR 0 6
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: LD_INT 21
6834: PUSH
6835: LD_INT 3
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: PPUSH
6846: CALL_OW 69
6850: PUSH
6851: FOR_IN
6852: IFFALSE 6868
// SetBLevel ( i , 10 ) ;
6854: LD_VAR 0 2
6858: PPUSH
6859: LD_INT 10
6861: PPUSH
6862: CALL_OW 241
6866: GO 6851
6868: POP
6869: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6870: LD_ADDR_VAR 0 9
6874: PUSH
6875: LD_INT 22
6877: PUSH
6878: LD_VAR 0 6
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 30
6889: PUSH
6890: LD_INT 34
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PPUSH
6901: CALL_OW 69
6905: ST_TO_ADDR
// if teleport then
6906: LD_VAR 0 9
6910: IFFALSE 6931
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6912: LD_VAR 0 9
6916: PUSH
6917: LD_INT 1
6919: ARRAY
6920: PPUSH
6921: LD_INT 123
6923: PPUSH
6924: LD_INT 122
6926: PPUSH
6927: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6931: LD_ADDR_EXP 61
6935: PUSH
6936: LD_STRING Platonov
6938: PPUSH
6939: CALL_OW 25
6943: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6944: LD_ADDR_EXP 62
6948: PUSH
6949: LD_STRING Kovalyuk
6951: PPUSH
6952: CALL_OW 25
6956: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6957: LD_ADDR_EXP 64
6961: PUSH
6962: LD_STRING Yakotich
6964: PPUSH
6965: CALL_OW 25
6969: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6970: LD_ADDR_EXP 63
6974: PUSH
6975: LD_STRING Bystrov
6977: PPUSH
6978: CALL_OW 25
6982: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6983: LD_ADDR_EXP 65
6987: PUSH
6988: LD_STRING Gleb
6990: PPUSH
6991: CALL_OW 25
6995: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
6996: LD_STRING 03_Cornel
6998: PPUSH
6999: CALL_OW 28
7003: IFFALSE 7051
// begin Bierezov := NewCharacter ( Mikhail ) ;
7005: LD_ADDR_EXP 66
7009: PUSH
7010: LD_STRING Mikhail
7012: PPUSH
7013: CALL_OW 25
7017: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7018: LD_EXP 66
7022: PPUSH
7023: LD_INT 197
7025: PPUSH
7026: LD_INT 111
7028: PPUSH
7029: LD_INT 9
7031: PPUSH
7032: LD_INT 0
7034: PPUSH
7035: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7039: LD_EXP 66
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7051: LD_EXP 61
7055: PPUSH
7056: LD_INT 126
7058: PPUSH
7059: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7063: LD_EXP 62
7067: PPUSH
7068: LD_INT 134
7070: PPUSH
7071: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7075: LD_EXP 64
7079: PPUSH
7080: LD_INT 197
7082: PPUSH
7083: LD_INT 111
7085: PPUSH
7086: LD_INT 9
7088: PPUSH
7089: LD_INT 0
7091: PPUSH
7092: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7096: LD_EXP 63
7100: PPUSH
7101: LD_INT 197
7103: PPUSH
7104: LD_INT 111
7106: PPUSH
7107: LD_INT 9
7109: PPUSH
7110: LD_INT 0
7112: PPUSH
7113: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7117: LD_EXP 65
7121: PPUSH
7122: LD_INT 197
7124: PPUSH
7125: LD_INT 111
7127: PPUSH
7128: LD_INT 9
7130: PPUSH
7131: LD_INT 0
7133: PPUSH
7134: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7138: LD_ADDR_VAR 0 5
7142: PUSH
7143: LD_INT 126
7145: PPUSH
7146: LD_INT 4
7148: PPUSH
7149: LD_STRING zhukov
7151: PPUSH
7152: LD_INT 9
7154: PUSH
7155: LD_INT 10
7157: PUSH
7158: LD_INT 10
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: LD_OWVAR 67
7170: ARRAY
7171: PPUSH
7172: LD_INT 99999
7174: PUSH
7175: LD_INT 1000
7177: PUSH
7178: LD_INT 300
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: LD_INT 12
7188: PUSH
7189: LD_INT 8
7191: PUSH
7192: LD_INT 13
7194: PUSH
7195: LD_INT 8
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: LIST
7202: LIST
7203: PPUSH
7204: CALL 71606 0 6
7208: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7209: LD_ADDR_VAR 0 4
7213: PUSH
7214: LD_INT 267
7216: PPUSH
7217: CALL_OW 274
7221: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7222: LD_VAR 0 4
7226: PPUSH
7227: LD_INT 1
7229: PPUSH
7230: LD_INT 5000
7232: PPUSH
7233: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7237: LD_VAR 0 4
7241: PPUSH
7242: LD_INT 2
7244: PPUSH
7245: LD_INT 200
7247: PPUSH
7248: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7252: LD_VAR 0 4
7256: PPUSH
7257: LD_INT 3
7259: PPUSH
7260: LD_INT 200
7262: PPUSH
7263: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7267: LD_ADDR_EXP 99
7271: PUSH
7272: LD_EXP 99
7276: PPUSH
7277: LD_INT 2
7279: PPUSH
7280: LD_VAR 0 5
7284: PUSH
7285: LD_INT 22
7287: PUSH
7288: LD_VAR 0 6
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 3
7299: PUSH
7300: LD_INT 21
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: CALL_OW 69
7322: UNION
7323: PUSH
7324: LD_EXP 61
7328: DIFF
7329: PPUSH
7330: CALL_OW 1
7334: ST_TO_ADDR
// behemoths := [ ] ;
7335: LD_ADDR_EXP 69
7339: PUSH
7340: EMPTY
7341: ST_TO_ADDR
// behemothBuilders := [ ] ;
7342: LD_ADDR_EXP 70
7346: PUSH
7347: EMPTY
7348: ST_TO_ADDR
// if Kovalyuk then
7349: LD_EXP 62
7353: IFFALSE 7375
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7355: LD_ADDR_EXP 70
7359: PUSH
7360: LD_EXP 70
7364: PPUSH
7365: LD_EXP 62
7369: PPUSH
7370: CALL 103880 0 2
7374: ST_TO_ADDR
// j := 3 ;
7375: LD_ADDR_VAR 0 3
7379: PUSH
7380: LD_INT 3
7382: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7383: LD_ADDR_VAR 0 2
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 25
7400: PUSH
7401: LD_INT 3
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PPUSH
7412: CALL_OW 69
7416: PUSH
7417: LD_EXP 62
7421: DIFF
7422: PUSH
7423: FOR_IN
7424: IFFALSE 7474
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7426: LD_ADDR_EXP 70
7430: PUSH
7431: LD_EXP 70
7435: PPUSH
7436: LD_VAR 0 2
7440: PPUSH
7441: CALL 103880 0 2
7445: ST_TO_ADDR
// j := j - 1 ;
7446: LD_ADDR_VAR 0 3
7450: PUSH
7451: LD_VAR 0 3
7455: PUSH
7456: LD_INT 1
7458: MINUS
7459: ST_TO_ADDR
// if j = 0 then
7460: LD_VAR 0 3
7464: PUSH
7465: LD_INT 0
7467: EQUAL
7468: IFFALSE 7472
// break ;
7470: GO 7474
// end ;
7472: GO 7423
7474: POP
7475: POP
// end ;
7476: LD_VAR 0 1
7480: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7481: LD_INT 0
7483: PPUSH
7484: PPUSH
7485: PPUSH
7486: PPUSH
7487: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7488: LD_ADDR_VAR 0 4
7492: PUSH
7493: LD_INT 209
7495: PUSH
7496: LD_INT 149
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: LD_INT 219
7505: PUSH
7506: LD_INT 154
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PUSH
7513: LD_INT 223
7515: PUSH
7516: LD_INT 149
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: LD_INT 232
7525: PUSH
7526: LD_INT 155
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: LIST
7537: LIST
7538: ST_TO_ADDR
// if not behemothBuilders then
7539: LD_EXP 70
7543: NOT
7544: IFFALSE 7548
// exit ;
7546: GO 7652
// j := 1 ;
7548: LD_ADDR_VAR 0 3
7552: PUSH
7553: LD_INT 1
7555: ST_TO_ADDR
// for i in behemothBuilders do
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_EXP 70
7565: PUSH
7566: FOR_IN
7567: IFFALSE 7650
// begin if IsInUnit ( i ) then
7569: LD_VAR 0 2
7573: PPUSH
7574: CALL_OW 310
7578: IFFALSE 7589
// ComExitBuilding ( i ) ;
7580: LD_VAR 0 2
7584: PPUSH
7585: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7589: LD_VAR 0 2
7593: PPUSH
7594: LD_INT 37
7596: PPUSH
7597: LD_VAR 0 4
7601: PUSH
7602: LD_VAR 0 3
7606: ARRAY
7607: PUSH
7608: LD_INT 1
7610: ARRAY
7611: PPUSH
7612: LD_VAR 0 4
7616: PUSH
7617: LD_VAR 0 3
7621: ARRAY
7622: PUSH
7623: LD_INT 2
7625: ARRAY
7626: PPUSH
7627: LD_INT 0
7629: PPUSH
7630: CALL_OW 230
// j := j + 1 ;
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: LD_VAR 0 3
7643: PUSH
7644: LD_INT 1
7646: PLUS
7647: ST_TO_ADDR
// end ;
7648: GO 7566
7650: POP
7651: POP
// end ;
7652: LD_VAR 0 1
7656: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7657: LD_INT 24
7659: PPUSH
7660: LD_INT 30
7662: PUSH
7663: LD_INT 37
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PPUSH
7670: CALL_OW 70
7674: IFFALSE 7687
7676: GO 7678
7678: DISABLE
// behemothUnderConstruct := true ;
7679: LD_ADDR_EXP 26
7683: PUSH
7684: LD_INT 1
7686: ST_TO_ADDR
7687: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7688: LD_INT 3
7690: PPUSH
7691: CALL 103928 0 1
7695: PUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 30
7708: PUSH
7709: LD_INT 37
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: NOT
7725: AND
7726: IFFALSE 7912
7728: GO 7730
7730: DISABLE
7731: LD_INT 0
7733: PPUSH
7734: PPUSH
// begin enable ;
7735: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7736: LD_ADDR_VAR 0 2
7740: PUSH
7741: LD_INT 3
7743: PPUSH
7744: CALL 103928 0 1
7748: ST_TO_ADDR
// for i in tmp do
7749: LD_ADDR_VAR 0 1
7753: PUSH
7754: LD_VAR 0 2
7758: PUSH
7759: FOR_IN
7760: IFFALSE 7910
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 9
7769: PPUSH
7770: CALL_OW 308
7774: PUSH
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 110
7784: PUSH
7785: LD_INT 2
7787: EQUAL
7788: NOT
7789: AND
7790: IFFALSE 7804
// SetTag ( i , 2 ) ;
7792: LD_VAR 0 1
7796: PPUSH
7797: LD_INT 2
7799: PPUSH
7800: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7804: LD_INT 81
7806: PUSH
7807: LD_INT 3
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 91
7816: PUSH
7817: LD_VAR 0 1
7821: PUSH
7822: LD_INT 12
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: NOT
7839: PUSH
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 110
7849: PUSH
7850: LD_INT 2
7852: EQUAL
7853: NOT
7854: AND
7855: IFFALSE 7874
// ComAgressiveMove ( i , 64 , 93 ) else
7857: LD_VAR 0 1
7861: PPUSH
7862: LD_INT 64
7864: PPUSH
7865: LD_INT 93
7867: PPUSH
7868: CALL_OW 114
7872: GO 7908
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 81
7881: PUSH
7882: LD_INT 3
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PPUSH
7889: CALL_OW 69
7893: PPUSH
7894: LD_VAR 0 1
7898: PPUSH
7899: CALL_OW 74
7903: PPUSH
7904: CALL_OW 115
// end ;
7908: GO 7759
7910: POP
7911: POP
// end ;
7912: PPOPN 2
7914: END
// export function PrepareRussianAttack ( strength ) ; var i ; begin
7915: LD_INT 0
7917: PPUSH
7918: PPUSH
// result := [ ] ;
7919: LD_ADDR_VAR 0 2
7923: PUSH
7924: EMPTY
7925: ST_TO_ADDR
// uc_side := 6 ;
7926: LD_ADDR_OWVAR 20
7930: PUSH
7931: LD_INT 6
7933: ST_TO_ADDR
// uc_nation := 3 ;
7934: LD_ADDR_OWVAR 21
7938: PUSH
7939: LD_INT 3
7941: ST_TO_ADDR
// case strength of 1 :
7942: LD_VAR 0 1
7946: PUSH
7947: LD_INT 1
7949: DOUBLE
7950: EQUAL
7951: IFTRUE 7955
7953: GO 8093
7955: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7956: LD_ADDR_VAR 0 3
7960: PUSH
7961: DOUBLE
7962: LD_INT 1
7964: DEC
7965: ST_TO_ADDR
7966: LD_INT 4
7968: PUSH
7969: LD_INT 5
7971: PUSH
7972: LD_INT 6
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: PUSH
7980: LD_OWVAR 67
7984: ARRAY
7985: PUSH
7986: FOR_TO
7987: IFFALSE 8089
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7989: LD_INT 22
7991: PUSH
7992: LD_INT 24
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: LD_VAR 0 3
8003: PUSH
8004: LD_INT 2
8006: MOD
8007: PUSH
8008: LD_INT 1
8010: PLUS
8011: ARRAY
8012: PPUSH
8013: LD_INT 1
8015: PUSH
8016: LD_INT 3
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: PUSH
8023: LD_INT 1
8025: PPUSH
8026: LD_INT 2
8028: PPUSH
8029: CALL_OW 12
8033: ARRAY
8034: PPUSH
8035: LD_INT 3
8037: PPUSH
8038: LD_INT 43
8040: PUSH
8041: LD_INT 44
8043: PUSH
8044: LD_INT 45
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PUSH
8052: LD_INT 1
8054: PPUSH
8055: LD_INT 3
8057: PPUSH
8058: CALL_OW 12
8062: ARRAY
8063: PPUSH
8064: LD_INT 80
8066: PPUSH
8067: CALL 68197 0 5
// result := result union CreateVehicle ;
8071: LD_ADDR_VAR 0 2
8075: PUSH
8076: LD_VAR 0 2
8080: PUSH
8081: CALL_OW 45
8085: UNION
8086: ST_TO_ADDR
// end ;
8087: GO 7986
8089: POP
8090: POP
// end ; 2 :
8091: GO 8997
8093: LD_INT 2
8095: DOUBLE
8096: EQUAL
8097: IFTRUE 8101
8099: GO 8257
8101: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8102: LD_ADDR_VAR 0 3
8106: PUSH
8107: DOUBLE
8108: LD_INT 1
8110: DEC
8111: ST_TO_ADDR
8112: LD_INT 6
8114: PUSH
8115: LD_INT 6
8117: PUSH
8118: LD_INT 7
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_OWVAR 67
8130: ARRAY
8131: PUSH
8132: FOR_TO
8133: IFFALSE 8253
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8135: LD_INT 22
8137: PUSH
8138: LD_INT 24
8140: PUSH
8141: LD_INT 24
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_VAR 0 3
8153: PUSH
8154: LD_INT 3
8156: MOD
8157: PUSH
8158: LD_INT 1
8160: PLUS
8161: ARRAY
8162: PPUSH
8163: LD_INT 1
8165: PUSH
8166: LD_INT 3
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PUSH
8173: LD_INT 1
8175: PPUSH
8176: LD_INT 2
8178: PPUSH
8179: CALL_OW 12
8183: ARRAY
8184: PPUSH
8185: LD_INT 3
8187: PPUSH
8188: LD_INT 43
8190: PUSH
8191: LD_INT 44
8193: PUSH
8194: LD_INT 45
8196: PUSH
8197: LD_INT 44
8199: PUSH
8200: LD_INT 46
8202: PUSH
8203: LD_INT 46
8205: PUSH
8206: EMPTY
8207: LIST
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_VAR 0 3
8218: PUSH
8219: LD_INT 6
8221: MOD
8222: PUSH
8223: LD_INT 1
8225: PLUS
8226: ARRAY
8227: PPUSH
8228: LD_INT 80
8230: PPUSH
8231: CALL 68197 0 5
// result := result union CreateVehicle ;
8235: LD_ADDR_VAR 0 2
8239: PUSH
8240: LD_VAR 0 2
8244: PUSH
8245: CALL_OW 45
8249: UNION
8250: ST_TO_ADDR
// end ;
8251: GO 8132
8253: POP
8254: POP
// end ; 3 :
8255: GO 8997
8257: LD_INT 3
8259: DOUBLE
8260: EQUAL
8261: IFTRUE 8265
8263: GO 8421
8265: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8266: LD_ADDR_VAR 0 3
8270: PUSH
8271: DOUBLE
8272: LD_INT 1
8274: DEC
8275: ST_TO_ADDR
8276: LD_INT 6
8278: PUSH
8279: LD_INT 7
8281: PUSH
8282: LD_INT 8
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: LIST
8289: PUSH
8290: LD_OWVAR 67
8294: ARRAY
8295: PUSH
8296: FOR_TO
8297: IFFALSE 8417
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8299: LD_INT 22
8301: PUSH
8302: LD_INT 24
8304: PUSH
8305: LD_INT 24
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: LIST
8312: PUSH
8313: LD_VAR 0 3
8317: PUSH
8318: LD_INT 3
8320: MOD
8321: PUSH
8322: LD_INT 1
8324: PLUS
8325: ARRAY
8326: PPUSH
8327: LD_INT 1
8329: PUSH
8330: LD_INT 3
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_INT 1
8339: PPUSH
8340: LD_INT 2
8342: PPUSH
8343: CALL_OW 12
8347: ARRAY
8348: PPUSH
8349: LD_INT 3
8351: PPUSH
8352: LD_INT 43
8354: PUSH
8355: LD_INT 47
8357: PUSH
8358: LD_INT 45
8360: PUSH
8361: LD_INT 45
8363: PUSH
8364: LD_INT 46
8366: PUSH
8367: LD_INT 46
8369: PUSH
8370: EMPTY
8371: LIST
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: PUSH
8378: LD_VAR 0 3
8382: PUSH
8383: LD_INT 6
8385: MOD
8386: PUSH
8387: LD_INT 1
8389: PLUS
8390: ARRAY
8391: PPUSH
8392: LD_INT 80
8394: PPUSH
8395: CALL 68197 0 5
// result := result union CreateVehicle ;
8399: LD_ADDR_VAR 0 2
8403: PUSH
8404: LD_VAR 0 2
8408: PUSH
8409: CALL_OW 45
8413: UNION
8414: ST_TO_ADDR
// end ;
8415: GO 8296
8417: POP
8418: POP
// end ; 4 :
8419: GO 8997
8421: LD_INT 4
8423: DOUBLE
8424: EQUAL
8425: IFTRUE 8429
8427: GO 8996
8429: POP
// begin uc_nation := 3 ;
8430: LD_ADDR_OWVAR 21
8434: PUSH
8435: LD_INT 3
8437: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8438: LD_ADDR_VAR 0 3
8442: PUSH
8443: DOUBLE
8444: LD_INT 1
8446: DEC
8447: ST_TO_ADDR
8448: LD_INT 7
8450: PUSH
8451: LD_INT 8
8453: PUSH
8454: LD_INT 9
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: LIST
8461: PUSH
8462: LD_OWVAR 67
8466: ARRAY
8467: PUSH
8468: FOR_TO
8469: IFFALSE 8589
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8471: LD_INT 22
8473: PUSH
8474: LD_INT 24
8476: PUSH
8477: LD_INT 24
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: LIST
8484: PUSH
8485: LD_VAR 0 3
8489: PUSH
8490: LD_INT 3
8492: MOD
8493: PUSH
8494: LD_INT 1
8496: PLUS
8497: ARRAY
8498: PPUSH
8499: LD_INT 1
8501: PUSH
8502: LD_INT 3
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: LD_INT 1
8511: PPUSH
8512: LD_INT 2
8514: PPUSH
8515: CALL_OW 12
8519: ARRAY
8520: PPUSH
8521: LD_INT 3
8523: PPUSH
8524: LD_INT 45
8526: PUSH
8527: LD_INT 47
8529: PUSH
8530: LD_INT 47
8532: PUSH
8533: LD_INT 45
8535: PUSH
8536: LD_INT 46
8538: PUSH
8539: LD_INT 46
8541: PUSH
8542: EMPTY
8543: LIST
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: LD_VAR 0 3
8554: PUSH
8555: LD_INT 6
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PPUSH
8564: LD_INT 80
8566: PPUSH
8567: CALL 68197 0 5
// result := result union CreateVehicle ;
8571: LD_ADDR_VAR 0 2
8575: PUSH
8576: LD_VAR 0 2
8580: PUSH
8581: CALL_OW 45
8585: UNION
8586: ST_TO_ADDR
// end ;
8587: GO 8468
8589: POP
8590: POP
// if not KappaStatus then
8591: LD_EXP 2
8595: NOT
8596: IFFALSE 8791
// begin uc_nation := 1 ;
8598: LD_ADDR_OWVAR 21
8602: PUSH
8603: LD_INT 1
8605: ST_TO_ADDR
// for i = 1 to 3 do
8606: LD_ADDR_VAR 0 3
8610: PUSH
8611: DOUBLE
8612: LD_INT 1
8614: DEC
8615: ST_TO_ADDR
8616: LD_INT 3
8618: PUSH
8619: FOR_TO
8620: IFFALSE 8716
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 85 ) ;
8622: LD_INT 3
8624: PUSH
8625: LD_INT 5
8627: PUSH
8628: EMPTY
8629: LIST
8630: LIST
8631: PUSH
8632: LD_INT 1
8634: PPUSH
8635: LD_INT 2
8637: PPUSH
8638: CALL_OW 12
8642: ARRAY
8643: PPUSH
8644: LD_INT 1
8646: PUSH
8647: LD_INT 3
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 1
8656: PPUSH
8657: LD_INT 2
8659: PPUSH
8660: CALL_OW 12
8664: ARRAY
8665: PPUSH
8666: LD_INT 3
8668: PPUSH
8669: LD_INT 9
8671: PUSH
8672: LD_INT 7
8674: PUSH
8675: EMPTY
8676: LIST
8677: LIST
8678: PUSH
8679: LD_INT 1
8681: PPUSH
8682: LD_INT 2
8684: PPUSH
8685: CALL_OW 12
8689: ARRAY
8690: PPUSH
8691: LD_INT 85
8693: PPUSH
8694: CALL 68197 0 5
// result := result union CreateVehicle ;
8698: LD_ADDR_VAR 0 2
8702: PUSH
8703: LD_VAR 0 2
8707: PUSH
8708: CALL_OW 45
8712: UNION
8713: ST_TO_ADDR
// end ;
8714: GO 8619
8716: POP
8717: POP
// if vsevolodFirstAttack then
8718: LD_EXP 24
8722: IFFALSE 8789
// begin vsevolodFirstAttack := false ;
8724: LD_ADDR_EXP 24
8728: PUSH
8729: LD_INT 0
8731: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8732: LD_INT 5
8734: PPUSH
8735: LD_INT 3
8737: PPUSH
8738: LD_INT 1
8740: PPUSH
8741: LD_INT 6
8743: PPUSH
8744: LD_INT 100
8746: PPUSH
8747: CALL 68197 0 5
// sewiVeh := CreateVehicle ;
8751: LD_ADDR_EXP 68
8755: PUSH
8756: CALL_OW 45
8760: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8761: LD_EXP 68
8765: PPUSH
8766: LD_INT 1
8768: PPUSH
8769: CALL_OW 242
// result := result union sewiVeh ;
8773: LD_ADDR_VAR 0 2
8777: PUSH
8778: LD_VAR 0 2
8782: PUSH
8783: LD_EXP 68
8787: UNION
8788: ST_TO_ADDR
// end ; end else
8789: GO 8994
// if vsevolodFirstAttack then
8791: LD_EXP 24
8795: IFFALSE 8994
// begin vsevolodFirstAttack := false ;
8797: LD_ADDR_EXP 24
8801: PUSH
8802: LD_INT 0
8804: ST_TO_ADDR
// uc_nation := 3 ;
8805: LD_ADDR_OWVAR 21
8809: PUSH
8810: LD_INT 3
8812: ST_TO_ADDR
// for i = 1 to 3 do
8813: LD_ADDR_VAR 0 3
8817: PUSH
8818: DOUBLE
8819: LD_INT 1
8821: DEC
8822: ST_TO_ADDR
8823: LD_INT 3
8825: PUSH
8826: FOR_TO
8827: IFFALSE 8935
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8829: LD_INT 22
8831: PUSH
8832: LD_INT 24
8834: PUSH
8835: LD_INT 24
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: PUSH
8843: LD_VAR 0 3
8847: PUSH
8848: LD_INT 3
8850: MOD
8851: PUSH
8852: LD_INT 1
8854: PLUS
8855: ARRAY
8856: PPUSH
8857: LD_INT 1
8859: PUSH
8860: LD_INT 3
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: LD_INT 1
8869: PPUSH
8870: LD_INT 2
8872: PPUSH
8873: CALL_OW 12
8877: ARRAY
8878: PPUSH
8879: LD_INT 3
8881: PPUSH
8882: LD_INT 45
8884: PUSH
8885: LD_INT 47
8887: PUSH
8888: LD_INT 47
8890: PUSH
8891: EMPTY
8892: LIST
8893: LIST
8894: LIST
8895: PUSH
8896: LD_VAR 0 3
8900: PUSH
8901: LD_INT 3
8903: MOD
8904: PUSH
8905: LD_INT 1
8907: PLUS
8908: ARRAY
8909: PPUSH
8910: LD_INT 80
8912: PPUSH
8913: CALL 68197 0 5
// result := result union CreateVehicle ;
8917: LD_ADDR_VAR 0 2
8921: PUSH
8922: LD_VAR 0 2
8926: PUSH
8927: CALL_OW 45
8931: UNION
8932: ST_TO_ADDR
// end ;
8933: GO 8826
8935: POP
8936: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8937: LD_INT 24
8939: PPUSH
8940: LD_INT 3
8942: PPUSH
8943: LD_INT 1
8945: PPUSH
8946: LD_INT 47
8948: PPUSH
8949: LD_INT 100
8951: PPUSH
8952: CALL 68197 0 5
// sewiVeh := CreateVehicle ;
8956: LD_ADDR_EXP 68
8960: PUSH
8961: CALL_OW 45
8965: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8966: LD_EXP 68
8970: PPUSH
8971: LD_INT 1
8973: PPUSH
8974: CALL_OW 242
// result := result union sewiVeh ;
8978: LD_ADDR_VAR 0 2
8982: PUSH
8983: LD_VAR 0 2
8987: PUSH
8988: LD_EXP 68
8992: UNION
8993: ST_TO_ADDR
// end ; end ; end ;
8994: GO 8997
8996: POP
// end ;
8997: LD_VAR 0 2
9001: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy , x , y ;
9002: LD_EXP 16
9006: IFFALSE 9695
9008: GO 9010
9010: DISABLE
9011: LD_INT 0
9013: PPUSH
9014: PPUSH
9015: PPUSH
9016: PPUSH
9017: PPUSH
9018: PPUSH
9019: PPUSH
9020: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9021: LD_ADDR_VAR 0 4
9025: PUSH
9026: LD_INT 11
9028: PUSH
9029: LD_INT 12
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9036: LD_ADDR_VAR 0 3
9040: PUSH
9041: LD_INT 8400
9043: PUSH
9044: LD_INT 7350
9046: PUSH
9047: LD_INT 6650
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: LIST
9054: PUSH
9055: LD_OWVAR 67
9059: ARRAY
9060: ST_TO_ADDR
// xy := [ 60 , 96 ] ;
9061: LD_ADDR_VAR 0 6
9065: PUSH
9066: LD_INT 60
9068: PUSH
9069: LD_INT 96
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: ST_TO_ADDR
// repeat if missionStage = 2 then
9076: LD_EXP 15
9080: PUSH
9081: LD_INT 2
9083: EQUAL
9084: IFFALSE 9095
// wait ( 1 1$30 ) else
9086: LD_INT 3150
9088: PPUSH
9089: CALL_OW 67
9093: GO 9104
// wait ( time ) ;
9095: LD_VAR 0 3
9099: PPUSH
9100: CALL_OW 67
// if missionStage = 6 then
9104: LD_EXP 15
9108: PUSH
9109: LD_INT 6
9111: EQUAL
9112: IFFALSE 9140
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9114: LD_INT 51
9116: PPUSH
9117: LD_INT 6
9119: PPUSH
9120: LD_INT 2
9122: PPUSH
9123: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9127: LD_INT 57
9129: PPUSH
9130: LD_INT 6
9132: PPUSH
9133: LD_INT 2
9135: PPUSH
9136: CALL_OW 322
// end ; if missionStage = 8 then
9140: LD_EXP 15
9144: PUSH
9145: LD_INT 8
9147: EQUAL
9148: IFFALSE 9176
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9150: LD_INT 52
9152: PPUSH
9153: LD_INT 6
9155: PPUSH
9156: LD_INT 2
9158: PPUSH
9159: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9163: LD_INT 58
9165: PPUSH
9166: LD_INT 6
9168: PPUSH
9169: LD_INT 2
9171: PPUSH
9172: CALL_OW 322
// end ; if missionStage = 10 then
9176: LD_EXP 15
9180: PUSH
9181: LD_INT 10
9183: EQUAL
9184: IFFALSE 9212
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9186: LD_INT 53
9188: PPUSH
9189: LD_INT 6
9191: PPUSH
9192: LD_INT 2
9194: PPUSH
9195: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9199: LD_INT 59
9201: PPUSH
9202: LD_INT 6
9204: PPUSH
9205: LD_INT 2
9207: PPUSH
9208: CALL_OW 322
// end ; if activeAttacks then
9212: LD_EXP 16
9216: IFFALSE 9689
// begin if missionStage = 2 then
9218: LD_EXP 15
9222: PUSH
9223: LD_INT 2
9225: EQUAL
9226: IFFALSE 9236
// strength := 1 ;
9228: LD_ADDR_VAR 0 5
9232: PUSH
9233: LD_INT 1
9235: ST_TO_ADDR
// if missionStage > 2 then
9236: LD_EXP 15
9240: PUSH
9241: LD_INT 2
9243: GREATER
9244: IFFALSE 9254
// strength := 2 ;
9246: LD_ADDR_VAR 0 5
9250: PUSH
9251: LD_INT 2
9253: ST_TO_ADDR
// if missionStage > 6 then
9254: LD_EXP 15
9258: PUSH
9259: LD_INT 6
9261: GREATER
9262: IFFALSE 9272
// strength := 3 ;
9264: LD_ADDR_VAR 0 5
9268: PUSH
9269: LD_INT 3
9271: ST_TO_ADDR
// if missionStage > 10 then
9272: LD_EXP 15
9276: PUSH
9277: LD_INT 10
9279: GREATER
9280: IFFALSE 9290
// strength := 4 ;
9282: LD_ADDR_VAR 0 5
9286: PUSH
9287: LD_INT 4
9289: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9290: LD_ADDR_VAR 0 2
9294: PUSH
9295: LD_VAR 0 5
9299: PPUSH
9300: CALL 7915 0 1
9304: ST_TO_ADDR
// for i in tmp do
9305: LD_ADDR_VAR 0 1
9309: PUSH
9310: LD_VAR 0 2
9314: PUSH
9315: FOR_IN
9316: IFFALSE 9416
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_VAR 0 4
9327: PUSH
9328: LD_INT 1
9330: PPUSH
9331: LD_INT 2
9333: PPUSH
9334: CALL_OW 12
9338: ARRAY
9339: PPUSH
9340: LD_INT 0
9342: PPUSH
9343: CALL_OW 49
// if i = sewiVeh then
9347: LD_VAR 0 1
9351: PUSH
9352: LD_EXP 68
9356: EQUAL
9357: IFFALSE 9392
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9359: LD_ADDR_EXP 67
9363: PUSH
9364: LD_STRING Vsevolod
9366: PPUSH
9367: LD_INT 0
9369: PPUSH
9370: LD_STRING 
9372: PPUSH
9373: CALL 61564 0 3
9377: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9378: LD_EXP 67
9382: PPUSH
9383: LD_VAR 0 1
9387: PPUSH
9388: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9392: LD_VAR 0 1
9396: PPUSH
9397: LD_INT 111
9399: PPUSH
9400: LD_INT 197
9402: PPUSH
9403: CALL_OW 111
// wait ( 0 0$2 ) ;
9407: LD_INT 70
9409: PPUSH
9410: CALL_OW 67
// end ;
9414: GO 9315
9416: POP
9417: POP
// repeat wait ( 0 0$1 ) ;
9418: LD_INT 35
9420: PPUSH
9421: CALL_OW 67
// for i in tmp do
9425: LD_ADDR_VAR 0 1
9429: PUSH
9430: LD_VAR 0 2
9434: PUSH
9435: FOR_IN
9436: IFFALSE 9670
// begin x := GetX ( i ) ;
9438: LD_ADDR_VAR 0 7
9442: PUSH
9443: LD_VAR 0 1
9447: PPUSH
9448: CALL_OW 250
9452: ST_TO_ADDR
// y := GetY ( i ) ;
9453: LD_ADDR_VAR 0 8
9457: PUSH
9458: LD_VAR 0 1
9462: PPUSH
9463: CALL_OW 251
9467: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) then
9468: LD_INT 81
9470: PUSH
9471: LD_INT 6
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: LD_INT 92
9480: PUSH
9481: LD_VAR 0 7
9485: PUSH
9486: LD_VAR 0 8
9490: PUSH
9491: LD_INT 12
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: LIST
9498: LIST
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PPUSH
9504: CALL_OW 69
9508: IFFALSE 9572
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) , i ) ) else
9510: LD_VAR 0 1
9514: PPUSH
9515: LD_INT 81
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 92
9527: PUSH
9528: LD_VAR 0 7
9532: PUSH
9533: LD_VAR 0 8
9537: PUSH
9538: LD_INT 12
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: PPUSH
9551: CALL_OW 69
9555: PPUSH
9556: LD_VAR 0 1
9560: PPUSH
9561: CALL_OW 74
9565: PPUSH
9566: CALL_OW 115
9570: GO 9668
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 10 then
9572: LD_VAR 0 1
9576: PPUSH
9577: LD_VAR 0 6
9581: PUSH
9582: LD_INT 1
9584: ARRAY
9585: PPUSH
9586: LD_VAR 0 6
9590: PUSH
9591: LD_INT 2
9593: ARRAY
9594: PPUSH
9595: CALL_OW 297
9599: PUSH
9600: LD_INT 10
9602: GREATER
9603: IFFALSE 9634
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) else
9605: LD_VAR 0 1
9609: PPUSH
9610: LD_VAR 0 6
9614: PUSH
9615: LD_INT 1
9617: ARRAY
9618: PPUSH
9619: LD_VAR 0 6
9623: PUSH
9624: LD_INT 2
9626: ARRAY
9627: PPUSH
9628: CALL_OW 114
9632: GO 9668
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9634: LD_VAR 0 1
9638: PPUSH
9639: LD_INT 81
9641: PUSH
9642: LD_INT 6
9644: PUSH
9645: EMPTY
9646: LIST
9647: LIST
9648: PPUSH
9649: CALL_OW 69
9653: PPUSH
9654: LD_VAR 0 1
9658: PPUSH
9659: CALL_OW 74
9663: PPUSH
9664: CALL_OW 115
// end ;
9668: GO 9435
9670: POP
9671: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9672: LD_INT 22
9674: PUSH
9675: LD_INT 6
9677: PUSH
9678: EMPTY
9679: LIST
9680: LIST
9681: PPUSH
9682: CALL_OW 69
9686: NOT
9687: IFFALSE 9418
// end ; until russianDestroyed ;
9689: LD_EXP 21
9693: IFFALSE 9076
// end ;
9695: PPOPN 8
9697: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9698: LD_EXP 21
9702: NOT
9703: PUSH
9704: LD_EXP 15
9708: PUSH
9709: LD_INT 6
9711: GREATEREQUAL
9712: AND
9713: PUSH
9714: LD_INT 2
9716: PPUSH
9717: LD_INT 1
9719: PPUSH
9720: CALL 56987 0 2
9724: NOT
9725: AND
9726: IFFALSE 10682
9728: GO 9730
9730: DISABLE
9731: LD_INT 0
9733: PPUSH
9734: PPUSH
9735: PPUSH
9736: PPUSH
// begin enable ;
9737: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9738: LD_INT 22
9740: PUSH
9741: LD_INT 3
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: PUSH
9748: LD_INT 30
9750: PUSH
9751: LD_INT 3
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: PUSH
9758: EMPTY
9759: LIST
9760: LIST
9761: PPUSH
9762: CALL_OW 69
9766: NOT
9767: IFFALSE 9771
// exit ;
9769: GO 10682
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9771: LD_ADDR_VAR 0 4
9775: PUSH
9776: LD_INT 22
9778: PUSH
9779: LD_INT 3
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PUSH
9786: LD_INT 30
9788: PUSH
9789: LD_INT 34
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PPUSH
9800: CALL_OW 69
9804: ST_TO_ADDR
// if Prob ( 40 ) then
9805: LD_INT 40
9807: PPUSH
9808: CALL_OW 13
9812: IFFALSE 9939
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9814: LD_INT 2
9816: PPUSH
9817: LD_INT 22
9819: PUSH
9820: LD_INT 3
9822: PUSH
9823: LD_INT 3
9825: PUSH
9826: LD_INT 49
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: PUSH
9835: LD_INT 22
9837: PUSH
9838: LD_INT 3
9840: PUSH
9841: LD_INT 3
9843: PUSH
9844: LD_INT 49
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: LD_INT 22
9855: PUSH
9856: LD_INT 3
9858: PUSH
9859: LD_INT 3
9861: PUSH
9862: LD_INT 49
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 24
9873: PUSH
9874: LD_INT 3
9876: PUSH
9877: LD_INT 3
9879: PUSH
9880: LD_INT 46
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 24
9891: PUSH
9892: LD_INT 3
9894: PUSH
9895: LD_INT 3
9897: PUSH
9898: LD_INT 46
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_INT 24
9909: PUSH
9910: LD_INT 3
9912: PUSH
9913: LD_INT 3
9915: PUSH
9916: LD_INT 46
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: LIST
9929: LIST
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL 55632 0 2
// end else
9937: GO 10062
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9939: LD_INT 2
9941: PPUSH
9942: LD_INT 24
9944: PUSH
9945: LD_INT 3
9947: PUSH
9948: LD_INT 3
9950: PUSH
9951: LD_INT 47
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 24
9962: PUSH
9963: LD_INT 3
9965: PUSH
9966: LD_INT 3
9968: PUSH
9969: LD_INT 47
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_INT 24
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 3
9986: PUSH
9987: LD_INT 47
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: PUSH
9996: LD_INT 24
9998: PUSH
9999: LD_INT 3
10001: PUSH
10002: LD_INT 3
10004: PUSH
10005: LD_INT 46
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: PUSH
10014: LD_INT 24
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: LD_INT 3
10022: PUSH
10023: LD_INT 46
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_INT 24
10034: PUSH
10035: LD_INT 3
10037: PUSH
10038: LD_INT 3
10040: PUSH
10041: LD_INT 46
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: LIST
10048: LIST
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: PPUSH
10058: CALL 55632 0 2
// end ; if Difficulty > 1 then
10062: LD_OWVAR 67
10066: PUSH
10067: LD_INT 1
10069: GREATER
10070: IFFALSE 10100
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10072: LD_INT 2
10074: PPUSH
10075: LD_INT 24
10077: PUSH
10078: LD_INT 3
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 47
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: EMPTY
10094: LIST
10095: PPUSH
10096: CALL 55632 0 2
// repeat wait ( 0 0$1 ) ;
10100: LD_INT 35
10102: PPUSH
10103: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10107: LD_INT 2
10109: PPUSH
10110: LD_INT 1
10112: PPUSH
10113: CALL 56987 0 2
10117: PUSH
10118: LD_INT 6
10120: PUSH
10121: LD_INT 7
10123: PUSH
10124: LD_INT 7
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: LIST
10131: PUSH
10132: LD_OWVAR 67
10136: ARRAY
10137: GREATEREQUAL
10138: IFFALSE 10100
// wait ( 0 0$30 ) ;
10140: LD_INT 1050
10142: PPUSH
10143: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10147: LD_ADDR_VAR 0 2
10151: PUSH
10152: LD_INT 2
10154: PPUSH
10155: LD_INT 1
10157: PPUSH
10158: CALL 56987 0 2
10162: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10163: LD_ADDR_EXP 118
10167: PUSH
10168: LD_EXP 118
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: LD_EXP 118
10180: PUSH
10181: LD_INT 2
10183: ARRAY
10184: PUSH
10185: LD_VAR 0 2
10189: DIFF
10190: PPUSH
10191: CALL_OW 1
10195: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10196: LD_ADDR_VAR 0 3
10200: PUSH
10201: LD_INT 0
10203: PPUSH
10204: LD_INT 1
10206: PPUSH
10207: CALL_OW 12
10211: ST_TO_ADDR
// if target then
10212: LD_VAR 0 3
10216: IFFALSE 10344
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10218: LD_ADDR_VAR 0 2
10222: PUSH
10223: LD_VAR 0 2
10227: PPUSH
10228: LD_INT 24
10230: PUSH
10231: LD_INT 250
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 72
10242: ST_TO_ADDR
// for i in tmp do
10243: LD_ADDR_VAR 0 1
10247: PUSH
10248: LD_VAR 0 2
10252: PUSH
10253: FOR_IN
10254: IFFALSE 10294
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10256: LD_VAR 0 1
10260: PPUSH
10261: LD_INT 139
10263: PPUSH
10264: LD_INT 89
10266: PPUSH
10267: CALL_OW 297
10271: PUSH
10272: LD_INT 9
10274: GREATER
10275: IFFALSE 10292
// ComMoveXY ( i , 139 , 89 ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: LD_INT 139
10284: PPUSH
10285: LD_INT 89
10287: PPUSH
10288: CALL_OW 111
10292: GO 10253
10294: POP
10295: POP
// wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10303: LD_VAR 0 2
10307: PPUSH
10308: LD_INT 92
10310: PUSH
10311: LD_INT 139
10313: PUSH
10314: LD_INT 89
10316: PUSH
10317: LD_INT 9
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: PPUSH
10326: CALL_OW 72
10330: PUSH
10331: LD_VAR 0 2
10335: PUSH
10336: LD_INT 1
10338: MINUS
10339: GREATEREQUAL
10340: IFFALSE 10218
// end else
10342: GO 10486
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10344: LD_VAR 0 2
10348: PPUSH
10349: LD_VAR 0 4
10353: PUSH
10354: LD_INT 1
10356: ARRAY
10357: PPUSH
10358: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10362: LD_ADDR_VAR 0 2
10366: PUSH
10367: LD_VAR 0 2
10371: PPUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 250
10377: PUSH
10378: EMPTY
10379: LIST
10380: LIST
10381: PPUSH
10382: CALL_OW 72
10386: ST_TO_ADDR
// for i in tmp do
10387: LD_ADDR_VAR 0 1
10391: PUSH
10392: LD_VAR 0 2
10396: PUSH
10397: FOR_IN
10398: IFFALSE 10438
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10400: LD_VAR 0 1
10404: PPUSH
10405: LD_INT 124
10407: PPUSH
10408: LD_INT 139
10410: PPUSH
10411: CALL_OW 297
10415: PUSH
10416: LD_INT 9
10418: GREATER
10419: IFFALSE 10436
// ComMoveXY ( i , 124 , 139 ) ;
10421: LD_VAR 0 1
10425: PPUSH
10426: LD_INT 124
10428: PPUSH
10429: LD_INT 139
10431: PPUSH
10432: CALL_OW 111
10436: GO 10397
10438: POP
10439: POP
// wait ( 0 0$1 ) ;
10440: LD_INT 35
10442: PPUSH
10443: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10447: LD_VAR 0 2
10451: PPUSH
10452: LD_INT 92
10454: PUSH
10455: LD_INT 124
10457: PUSH
10458: LD_INT 139
10460: PUSH
10461: LD_INT 9
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL_OW 72
10474: PUSH
10475: LD_VAR 0 2
10479: PUSH
10480: LD_INT 1
10482: MINUS
10483: GREATEREQUAL
10484: IFFALSE 10362
// end ; repeat wait ( 0 0$1 ) ;
10486: LD_INT 35
10488: PPUSH
10489: CALL_OW 67
// for i in tmp do
10493: LD_ADDR_VAR 0 1
10497: PUSH
10498: LD_VAR 0 2
10502: PUSH
10503: FOR_IN
10504: IFFALSE 10673
// begin if GetLives ( i ) > 251 then
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL_OW 256
10515: PUSH
10516: LD_INT 251
10518: GREATER
10519: IFFALSE 10644
// begin if GetWeapon ( i ) = ru_time_lapser then
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 264
10530: PUSH
10531: LD_INT 49
10533: EQUAL
10534: IFFALSE 10590
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10536: LD_VAR 0 1
10540: PPUSH
10541: LD_INT 2
10543: PUSH
10544: LD_INT 22
10546: PUSH
10547: LD_INT 1
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: PUSH
10554: LD_INT 22
10556: PUSH
10557: LD_INT 8
10559: PUSH
10560: EMPTY
10561: LIST
10562: LIST
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: PPUSH
10569: CALL_OW 69
10573: PPUSH
10574: LD_VAR 0 1
10578: PPUSH
10579: CALL_OW 74
10583: PPUSH
10584: CALL_OW 112
10588: GO 10642
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_INT 2
10597: PUSH
10598: LD_INT 22
10600: PUSH
10601: LD_INT 1
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PUSH
10608: LD_INT 22
10610: PUSH
10611: LD_INT 8
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL_OW 69
10627: PPUSH
10628: LD_VAR 0 1
10632: PPUSH
10633: CALL_OW 74
10637: PPUSH
10638: CALL_OW 115
// end else
10642: GO 10671
// if IsDead ( i ) then
10644: LD_VAR 0 1
10648: PPUSH
10649: CALL_OW 301
10653: IFFALSE 10671
// tmp := tmp diff i ;
10655: LD_ADDR_VAR 0 2
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: LD_VAR 0 1
10669: DIFF
10670: ST_TO_ADDR
// end ;
10671: GO 10503
10673: POP
10674: POP
// until not tmp ;
10675: LD_VAR 0 2
10679: NOT
10680: IFFALSE 10486
// end ; end_of_file
10682: PPOPN 4
10684: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10685: LD_INT 0
10687: PPUSH
10688: PPUSH
10689: PPUSH
10690: PPUSH
10691: PPUSH
10692: PPUSH
// side := 7 ;
10693: LD_ADDR_VAR 0 5
10697: PUSH
10698: LD_INT 7
10700: ST_TO_ADDR
// uc_side := side ;
10701: LD_ADDR_OWVAR 20
10705: PUSH
10706: LD_VAR 0 5
10710: ST_TO_ADDR
// uc_nation := 1 ;
10711: LD_ADDR_OWVAR 21
10715: PUSH
10716: LD_INT 1
10718: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10719: LD_ADDR_VAR 0 2
10723: PUSH
10724: LD_INT 22
10726: PUSH
10727: LD_VAR 0 5
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: PUSH
10736: LD_INT 21
10738: PUSH
10739: LD_INT 3
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL_OW 69
10754: PUSH
10755: FOR_IN
10756: IFFALSE 10772
// SetBLevel ( i , 10 ) ;
10758: LD_VAR 0 2
10762: PPUSH
10763: LD_INT 10
10765: PPUSH
10766: CALL_OW 241
10770: GO 10755
10772: POP
10773: POP
// base := GetBase ( al_depot ) ;
10774: LD_ADDR_VAR 0 4
10778: PUSH
10779: LD_INT 2
10781: PPUSH
10782: CALL_OW 274
10786: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10787: LD_ADDR_VAR 0 6
10791: PUSH
10792: LD_INT 22
10794: PUSH
10795: LD_VAR 0 5
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 30
10806: PUSH
10807: LD_INT 34
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: ST_TO_ADDR
// if teleport then
10823: LD_VAR 0 6
10827: IFFALSE 10848
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10829: LD_VAR 0 6
10833: PUSH
10834: LD_INT 1
10836: ARRAY
10837: PPUSH
10838: LD_INT 262
10840: PPUSH
10841: LD_INT 119
10843: PPUSH
10844: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
10848: LD_VAR 0 4
10852: PPUSH
10853: LD_INT 1
10855: PPUSH
10856: LD_INT 19500
10858: PPUSH
10859: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10863: LD_VAR 0 4
10867: PPUSH
10868: LD_INT 2
10870: PPUSH
10871: LD_INT 200
10873: PPUSH
10874: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10878: LD_VAR 0 4
10882: PPUSH
10883: LD_INT 3
10885: PPUSH
10886: LD_INT 650
10888: PPUSH
10889: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
10893: LD_ADDR_EXP 71
10897: PUSH
10898: LD_STRING Roth
10900: PPUSH
10901: CALL_OW 25
10905: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
10906: LD_ADDR_EXP 72
10910: PUSH
10911: LD_STRING Simms
10913: PPUSH
10914: LD_EXP 1
10918: NOT
10919: PPUSH
10920: LD_STRING 10c_
10922: PPUSH
10923: CALL 61564 0 3
10927: ST_TO_ADDR
// if not Simms then
10928: LD_EXP 72
10932: NOT
10933: IFFALSE 10963
// begin uc_nation := 1 ;
10935: LD_ADDR_OWVAR 21
10939: PUSH
10940: LD_INT 1
10942: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 10
10948: PPUSH
10949: CALL_OW 384
// Simms := CreateHuman ;
10953: LD_ADDR_EXP 72
10957: PUSH
10958: CALL_OW 44
10962: ST_TO_ADDR
// end ; uc_nation := 3 ;
10963: LD_ADDR_OWVAR 21
10967: PUSH
10968: LD_INT 3
10970: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
10971: LD_ADDR_EXP 73
10975: PUSH
10976: LD_STRING Kirilenkova
10978: PPUSH
10979: CALL_OW 25
10983: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
10984: LD_ADDR_EXP 87
10988: PUSH
10989: LD_STRING Oblukov
10991: PPUSH
10992: CALL_OW 25
10996: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
10997: LD_ADDR_EXP 74
11001: PUSH
11002: LD_STRING Dolgov
11004: PPUSH
11005: CALL_OW 25
11009: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11010: LD_ADDR_EXP 75
11014: PUSH
11015: LD_STRING Petrosyan
11017: PPUSH
11018: CALL_OW 25
11022: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11023: LD_ADDR_EXP 86
11027: PUSH
11028: LD_STRING Scholtze
11030: PPUSH
11031: CALL_OW 25
11035: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11036: LD_ADDR_EXP 85
11040: PUSH
11041: LD_STRING Kapitsova
11043: PPUSH
11044: CALL_OW 25
11048: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11049: LD_ADDR_EXP 76
11053: PUSH
11054: LD_STRING Petrovova
11056: PPUSH
11057: CALL_OW 25
11061: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11062: LD_ADDR_EXP 77
11066: PUSH
11067: LD_STRING Kuzmov
11069: PPUSH
11070: CALL_OW 25
11074: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11075: LD_ADDR_EXP 84
11079: PUSH
11080: LD_STRING Karamazov
11082: PPUSH
11083: CALL_OW 25
11087: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11088: LD_STRING 13_Lipshchin_1
11090: PPUSH
11091: LD_INT 0
11093: PPUSH
11094: CALL_OW 30
11098: IFFALSE 11113
// Lipshchin := NewCharacter ( Lipshchin ) ;
11100: LD_ADDR_EXP 78
11104: PUSH
11105: LD_STRING Lipshchin
11107: PPUSH
11108: CALL_OW 25
11112: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11113: LD_STRING 13_Titov_1
11115: PPUSH
11116: LD_INT 0
11118: PPUSH
11119: CALL_OW 30
11123: IFFALSE 11138
// Titov := NewCharacter ( Titov ) ;
11125: LD_ADDR_EXP 80
11129: PUSH
11130: LD_STRING Titov
11132: PPUSH
11133: CALL_OW 25
11137: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11138: LD_STRING 13_Gnyevko_1
11140: PPUSH
11141: LD_INT 0
11143: PPUSH
11144: CALL_OW 30
11148: IFFALSE 11163
// Gnyevko := NewCharacter ( Gnyevko ) ;
11150: LD_ADDR_EXP 79
11154: PUSH
11155: LD_STRING Gnyevko
11157: PPUSH
11158: CALL_OW 25
11162: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11163: LD_STRING 13_Xavier_1
11165: PPUSH
11166: LD_INT 0
11168: PPUSH
11169: CALL_OW 30
11173: IFFALSE 11188
// Xavier := NewCharacter ( Xavier2 ) ;
11175: LD_ADDR_EXP 81
11179: PUSH
11180: LD_STRING Xavier2
11182: PPUSH
11183: CALL_OW 25
11187: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11188: LD_STRING 13_Belkov_1
11190: PPUSH
11191: LD_INT 0
11193: PPUSH
11194: CALL_OW 30
11198: IFFALSE 11213
// Belkov := NewCharacter ( Belkov ) ;
11200: LD_ADDR_EXP 82
11204: PUSH
11205: LD_STRING Belkov
11207: PPUSH
11208: CALL_OW 25
11212: ST_TO_ADDR
// if not BurlakStatus then
11213: LD_EXP 9
11217: NOT
11218: IFFALSE 11233
// Burlak = NewCharacter ( Burlak ) ;
11220: LD_ADDR_EXP 83
11224: PUSH
11225: LD_STRING Burlak
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11233: LD_ADDR_VAR 0 3
11237: PUSH
11238: LD_EXP 71
11242: PUSH
11243: LD_EXP 73
11247: PUSH
11248: LD_EXP 87
11252: PUSH
11253: LD_EXP 74
11257: PUSH
11258: LD_EXP 75
11262: PUSH
11263: LD_EXP 86
11267: PUSH
11268: LD_EXP 85
11272: PUSH
11273: LD_EXP 76
11277: PUSH
11278: LD_EXP 77
11282: PUSH
11283: LD_EXP 84
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: ST_TO_ADDR
// if Simms then
11300: LD_EXP 72
11304: IFFALSE 11322
// tmp := tmp ^ Simms ;
11306: LD_ADDR_VAR 0 3
11310: PUSH
11311: LD_VAR 0 3
11315: PUSH
11316: LD_EXP 72
11320: ADD
11321: ST_TO_ADDR
// if Titov then
11322: LD_EXP 80
11326: IFFALSE 11344
// tmp := tmp ^ Titov ;
11328: LD_ADDR_VAR 0 3
11332: PUSH
11333: LD_VAR 0 3
11337: PUSH
11338: LD_EXP 80
11342: ADD
11343: ST_TO_ADDR
// if Lipshchin then
11344: LD_EXP 78
11348: IFFALSE 11366
// tmp := tmp ^ Lipshchin ;
11350: LD_ADDR_VAR 0 3
11354: PUSH
11355: LD_VAR 0 3
11359: PUSH
11360: LD_EXP 78
11364: ADD
11365: ST_TO_ADDR
// if Gnyevko then
11366: LD_EXP 79
11370: IFFALSE 11388
// tmp := tmp ^ Gnyevko ;
11372: LD_ADDR_VAR 0 3
11376: PUSH
11377: LD_VAR 0 3
11381: PUSH
11382: LD_EXP 79
11386: ADD
11387: ST_TO_ADDR
// if Xavier then
11388: LD_EXP 81
11392: IFFALSE 11410
// tmp := tmp ^ Xavier ;
11394: LD_ADDR_VAR 0 3
11398: PUSH
11399: LD_VAR 0 3
11403: PUSH
11404: LD_EXP 81
11408: ADD
11409: ST_TO_ADDR
// if Belkov then
11410: LD_EXP 82
11414: IFFALSE 11432
// tmp := tmp ^ Belkov ;
11416: LD_ADDR_VAR 0 3
11420: PUSH
11421: LD_VAR 0 3
11425: PUSH
11426: LD_EXP 82
11430: ADD
11431: ST_TO_ADDR
// if Burlak then
11432: LD_EXP 83
11436: IFFALSE 11454
// tmp := tmp ^ Burlak ;
11438: LD_ADDR_VAR 0 3
11442: PUSH
11443: LD_VAR 0 3
11447: PUSH
11448: LD_EXP 83
11452: ADD
11453: ST_TO_ADDR
// for i = 1 to 8 do
11454: LD_ADDR_VAR 0 2
11458: PUSH
11459: DOUBLE
11460: LD_INT 1
11462: DEC
11463: ST_TO_ADDR
11464: LD_INT 8
11466: PUSH
11467: FOR_TO
11468: IFFALSE 11534
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11470: LD_ADDR_OWVAR 21
11474: PUSH
11475: LD_INT 1
11477: PUSH
11478: LD_INT 3
11480: PUSH
11481: EMPTY
11482: LIST
11483: LIST
11484: PUSH
11485: LD_INT 1
11487: PPUSH
11488: LD_INT 2
11490: PPUSH
11491: CALL_OW 12
11495: ARRAY
11496: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11497: LD_INT 0
11499: PPUSH
11500: LD_VAR 0 2
11504: PUSH
11505: LD_INT 2
11507: DIV
11508: PPUSH
11509: LD_INT 10
11511: PPUSH
11512: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11516: LD_ADDR_VAR 0 3
11520: PUSH
11521: LD_VAR 0 3
11525: PUSH
11526: CALL_OW 44
11530: ADD
11531: ST_TO_ADDR
// end ;
11532: GO 11467
11534: POP
11535: POP
// for i in tmp do
11536: LD_ADDR_VAR 0 2
11540: PUSH
11541: LD_VAR 0 3
11545: PUSH
11546: FOR_IN
11547: IFFALSE 11572
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11549: LD_VAR 0 2
11553: PPUSH
11554: LD_INT 260
11556: PPUSH
11557: LD_INT 235
11559: PPUSH
11560: LD_INT 8
11562: PPUSH
11563: LD_INT 0
11565: PPUSH
11566: CALL_OW 50
11570: GO 11546
11572: POP
11573: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11574: LD_ADDR_EXP 99
11578: PUSH
11579: LD_EXP 99
11583: PPUSH
11584: LD_INT 1
11586: PPUSH
11587: LD_INT 22
11589: PUSH
11590: LD_VAR 0 5
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: LD_INT 3
11601: PUSH
11602: LD_INT 21
11604: PUSH
11605: LD_INT 2
11607: PUSH
11608: EMPTY
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: PPUSH
11620: CALL_OW 69
11624: PUSH
11625: LD_EXP 71
11629: PUSH
11630: LD_EXP 72
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: DIFF
11639: PPUSH
11640: CALL_OW 1
11644: ST_TO_ADDR
// uc_side := 0 ;
11645: LD_ADDR_OWVAR 20
11649: PUSH
11650: LD_INT 0
11652: ST_TO_ADDR
// uc_nation := 0 ;
11653: LD_ADDR_OWVAR 21
11657: PUSH
11658: LD_INT 0
11660: ST_TO_ADDR
// for i = 1 to 5 do
11661: LD_ADDR_VAR 0 2
11665: PUSH
11666: DOUBLE
11667: LD_INT 1
11669: DEC
11670: ST_TO_ADDR
11671: LD_INT 5
11673: PUSH
11674: FOR_TO
11675: IFFALSE 11712
// begin InitHc ;
11677: CALL_OW 19
// hc_class := class_apeman ;
11681: LD_ADDR_OWVAR 28
11685: PUSH
11686: LD_INT 12
11688: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11689: CALL_OW 44
11693: PPUSH
11694: LD_INT 299
11696: PPUSH
11697: LD_INT 229
11699: PPUSH
11700: LD_INT 10
11702: PPUSH
11703: LD_INT 0
11705: PPUSH
11706: CALL_OW 50
// end ;
11710: GO 11674
11712: POP
11713: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11714: LD_EXP 71
11718: PPUSH
11719: LD_INT 259
11721: PPUSH
11722: LD_INT 235
11724: PPUSH
11725: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11729: LD_EXP 71
11733: PPUSH
11734: LD_INT 262
11736: PPUSH
11737: LD_INT 235
11739: PPUSH
11740: CALL_OW 178
// if Simms then
11744: LD_EXP 72
11748: IFFALSE 11779
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11750: LD_EXP 72
11754: PPUSH
11755: LD_INT 262
11757: PPUSH
11758: LD_INT 235
11760: PPUSH
11761: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11765: LD_EXP 72
11769: PPUSH
11770: LD_EXP 71
11774: PPUSH
11775: CALL_OW 179
// end ; end ;
11779: LD_VAR 0 1
11783: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11784: LD_EXP 31
11788: PUSH
11789: LD_EXP 23
11793: NOT
11794: AND
11795: IFFALSE 11971
11797: GO 11799
11799: DISABLE
11800: LD_INT 0
11802: PPUSH
11803: PPUSH
11804: PPUSH
// begin enable ;
11805: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11806: LD_ADDR_VAR 0 2
11810: PUSH
11811: LD_INT 81
11813: PUSH
11814: LD_INT 7
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 2
11823: PUSH
11824: LD_INT 32
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 30
11836: PUSH
11837: LD_INT 30
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 30
11846: PUSH
11847: LD_INT 28
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 34
11856: PUSH
11857: LD_INT 49
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 34
11866: PUSH
11867: LD_INT 10
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: LD_INT 34
11876: PUSH
11877: LD_INT 8
11879: PUSH
11880: EMPTY
11881: LIST
11882: LIST
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PPUSH
11897: CALL_OW 69
11901: ST_TO_ADDR
// if not tmp then
11902: LD_VAR 0 2
11906: NOT
11907: IFFALSE 11911
// exit ;
11909: GO 11971
// target := tmp [ rand ( 1 , tmp ) ] ;
11911: LD_ADDR_VAR 0 3
11915: PUSH
11916: LD_VAR 0 2
11920: PUSH
11921: LD_INT 1
11923: PPUSH
11924: LD_VAR 0 2
11928: PPUSH
11929: CALL_OW 12
11933: ARRAY
11934: ST_TO_ADDR
// if GetSide ( target ) = 1 then
11935: LD_VAR 0 3
11939: PPUSH
11940: CALL_OW 255
11944: PUSH
11945: LD_INT 1
11947: EQUAL
11948: IFFALSE 11959
// CenterNowOnUnits ( target ) ;
11950: LD_VAR 0 3
11954: PPUSH
11955: CALL_OW 87
// SetLives ( target , 0 ) ;
11959: LD_VAR 0 3
11963: PPUSH
11964: LD_INT 0
11966: PPUSH
11967: CALL_OW 234
// end ;
11971: PPOPN 3
11973: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
11974: LD_EXP 23
11978: NOT
11979: PUSH
11980: LD_EXP 31
11984: AND
11985: IFFALSE 12507
11987: GO 11989
11989: DISABLE
11990: LD_INT 0
11992: PPUSH
11993: PPUSH
11994: PPUSH
// begin uc_side := 7 ;
11995: LD_ADDR_OWVAR 20
11999: PUSH
12000: LD_INT 7
12002: ST_TO_ADDR
// uc_nation := 1 ;
12003: LD_ADDR_OWVAR 21
12007: PUSH
12008: LD_INT 1
12010: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12011: LD_ADDR_VAR 0 3
12015: PUSH
12016: LD_INT 125
12018: PUSH
12019: LD_INT 163
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: PUSH
12026: LD_INT 185
12028: PUSH
12029: LD_INT 168
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: LD_INT 111
12038: PUSH
12039: LD_INT 97
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: LIST
12050: PPUSH
12051: CALL 103972 0 1
12055: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12056: LD_ADDR_EXP 88
12060: PUSH
12061: EMPTY
12062: ST_TO_ADDR
// for i = 1 to Difficulty do
12063: LD_ADDR_VAR 0 1
12067: PUSH
12068: DOUBLE
12069: LD_INT 1
12071: DEC
12072: ST_TO_ADDR
12073: LD_OWVAR 67
12077: PUSH
12078: FOR_TO
12079: IFFALSE 12237
// begin InitHc ;
12081: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12085: LD_INT 0
12087: PPUSH
12088: LD_INT 8
12090: PPUSH
12091: CALL_OW 381
// un := CreateHuman ;
12095: LD_ADDR_VAR 0 2
12099: PUSH
12100: CALL_OW 44
12104: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12105: LD_VAR 0 2
12109: PPUSH
12110: LD_INT 258
12112: PPUSH
12113: LD_INT 267
12115: PPUSH
12116: LD_INT 4
12118: PPUSH
12119: LD_INT 0
12121: PPUSH
12122: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12126: LD_ADDR_EXP 88
12130: PUSH
12131: LD_EXP 88
12135: PUSH
12136: LD_VAR 0 2
12140: UNION
12141: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12142: LD_VAR 0 2
12146: PPUSH
12147: LD_VAR 0 3
12151: PUSH
12152: LD_VAR 0 1
12156: ARRAY
12157: PUSH
12158: LD_INT 1
12160: ARRAY
12161: PPUSH
12162: LD_VAR 0 3
12166: PUSH
12167: LD_VAR 0 1
12171: ARRAY
12172: PUSH
12173: LD_INT 2
12175: ARRAY
12176: PPUSH
12177: LD_INT 4
12179: PPUSH
12180: LD_INT 1
12182: PPUSH
12183: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12187: LD_VAR 0 2
12191: PPUSH
12192: LD_VAR 0 3
12196: PUSH
12197: LD_VAR 0 1
12201: ARRAY
12202: PUSH
12203: LD_INT 1
12205: ARRAY
12206: PPUSH
12207: LD_VAR 0 3
12211: PUSH
12212: LD_VAR 0 1
12216: ARRAY
12217: PUSH
12218: LD_INT 2
12220: ARRAY
12221: PPUSH
12222: CALL_OW 171
// AddComInvisible ( un ) ;
12226: LD_VAR 0 2
12230: PPUSH
12231: CALL_OW 212
// end ;
12235: GO 12078
12237: POP
12238: POP
// repeat wait ( 0 0$20 ) ;
12239: LD_INT 700
12241: PPUSH
12242: CALL_OW 67
// for i in allianceSpecialForce do
12246: LD_ADDR_VAR 0 1
12250: PUSH
12251: LD_EXP 88
12255: PUSH
12256: FOR_IN
12257: IFFALSE 12492
// begin if IsInvisible ( i ) then
12259: LD_VAR 0 1
12263: PPUSH
12264: CALL_OW 571
12268: IFFALSE 12461
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12270: LD_ADDR_VAR 0 3
12274: PUSH
12275: LD_INT 22
12277: PUSH
12278: LD_INT 1
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 50
12287: PUSH
12288: EMPTY
12289: LIST
12290: PUSH
12291: LD_INT 56
12293: PUSH
12294: EMPTY
12295: LIST
12296: PUSH
12297: LD_INT 91
12299: PUSH
12300: LD_VAR 0 1
12304: PUSH
12305: LD_INT 25
12307: PUSH
12308: LD_INT 30
12310: PUSH
12311: LD_INT 35
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: LIST
12318: PUSH
12319: LD_OWVAR 67
12323: ARRAY
12324: PUSH
12325: EMPTY
12326: LIST
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 2
12332: PUSH
12333: LD_INT 25
12335: PUSH
12336: LD_INT 1
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PUSH
12343: LD_INT 25
12345: PUSH
12346: LD_INT 2
12348: PUSH
12349: EMPTY
12350: LIST
12351: LIST
12352: PUSH
12353: LD_INT 25
12355: PUSH
12356: LD_INT 3
12358: PUSH
12359: EMPTY
12360: LIST
12361: LIST
12362: PUSH
12363: LD_INT 25
12365: PUSH
12366: LD_INT 4
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PUSH
12373: LD_INT 25
12375: PUSH
12376: LD_INT 5
12378: PUSH
12379: EMPTY
12380: LIST
12381: LIST
12382: PUSH
12383: LD_INT 25
12385: PUSH
12386: LD_INT 8
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: EMPTY
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: PPUSH
12409: CALL_OW 69
12413: ST_TO_ADDR
// if not tmp then
12414: LD_VAR 0 3
12418: NOT
12419: IFFALSE 12423
// continue ;
12421: GO 12256
// if Prob ( 30 * Difficulty ) then
12423: LD_INT 30
12425: PUSH
12426: LD_OWVAR 67
12430: MUL
12431: PPUSH
12432: CALL_OW 13
12436: IFFALSE 12461
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12438: LD_VAR 0 3
12442: PUSH
12443: LD_INT 1
12445: PPUSH
12446: LD_VAR 0 3
12450: PPUSH
12451: CALL_OW 12
12455: ARRAY
12456: PPUSH
12457: CALL 29678 0 1
// end ; if IsDead ( i ) then
12461: LD_VAR 0 1
12465: PPUSH
12466: CALL_OW 301
12470: IFFALSE 12490
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12472: LD_ADDR_EXP 88
12476: PUSH
12477: LD_EXP 88
12481: PUSH
12482: LD_VAR 0 1
12486: DIFF
12487: ST_TO_ADDR
// continue ;
12488: GO 12256
// end ; end ;
12490: GO 12256
12492: POP
12493: POP
// until allianceDestroyed or not allianceSpecialForce ;
12494: LD_EXP 23
12498: PUSH
12499: LD_EXP 88
12503: NOT
12504: OR
12505: IFFALSE 12239
// end ;
12507: PPOPN 3
12509: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12510: LD_EXP 23
12514: NOT
12515: PUSH
12516: LD_EXP 31
12520: AND
12521: PUSH
12522: LD_INT 1
12524: PPUSH
12525: LD_INT 1
12527: PPUSH
12528: CALL 56987 0 2
12532: NOT
12533: AND
12534: IFFALSE 13501
12536: GO 12538
12538: DISABLE
12539: LD_INT 0
12541: PPUSH
12542: PPUSH
12543: PPUSH
12544: PPUSH
// begin enable ;
12545: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12546: LD_INT 22
12548: PUSH
12549: LD_INT 7
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 30
12558: PUSH
12559: LD_INT 3
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PPUSH
12570: CALL_OW 69
12574: NOT
12575: IFFALSE 12579
// exit ;
12577: GO 13501
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12579: LD_ADDR_VAR 0 4
12583: PUSH
12584: LD_INT 22
12586: PUSH
12587: LD_INT 7
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PUSH
12594: LD_INT 30
12596: PUSH
12597: LD_INT 34
12599: PUSH
12600: EMPTY
12601: LIST
12602: LIST
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: PPUSH
12608: CALL_OW 69
12612: ST_TO_ADDR
// if Prob ( 40 ) then
12613: LD_INT 40
12615: PPUSH
12616: CALL_OW 13
12620: IFFALSE 12747
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12622: LD_INT 1
12624: PPUSH
12625: LD_INT 5
12627: PUSH
12628: LD_INT 3
12630: PUSH
12631: LD_INT 2
12633: PUSH
12634: LD_INT 6
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: LIST
12641: LIST
12642: PUSH
12643: LD_INT 5
12645: PUSH
12646: LD_INT 3
12648: PUSH
12649: LD_INT 2
12651: PUSH
12652: LD_INT 6
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 5
12663: PUSH
12664: LD_INT 3
12666: PUSH
12667: LD_INT 2
12669: PUSH
12670: LD_INT 6
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: LIST
12677: LIST
12678: PUSH
12679: LD_INT 24
12681: PUSH
12682: LD_INT 3
12684: PUSH
12685: LD_INT 3
12687: PUSH
12688: LD_INT 45
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 24
12699: PUSH
12700: LD_INT 3
12702: PUSH
12703: LD_INT 3
12705: PUSH
12706: LD_INT 47
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 24
12717: PUSH
12718: LD_INT 3
12720: PUSH
12721: LD_INT 3
12723: PUSH
12724: LD_INT 45
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: LIST
12731: LIST
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: LIST
12740: PPUSH
12741: CALL 55632 0 2
// end else
12745: GO 12870
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12747: LD_INT 1
12749: PPUSH
12750: LD_INT 24
12752: PUSH
12753: LD_INT 3
12755: PUSH
12756: LD_INT 3
12758: PUSH
12759: LD_INT 47
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 24
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: LD_INT 3
12776: PUSH
12777: LD_INT 47
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 5
12788: PUSH
12789: LD_INT 3
12791: PUSH
12792: LD_INT 2
12794: PUSH
12795: LD_INT 9
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 5
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: LD_INT 9
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 24
12824: PUSH
12825: LD_INT 1
12827: PUSH
12828: LD_INT 3
12830: PUSH
12831: LD_INT 45
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: PUSH
12840: LD_INT 24
12842: PUSH
12843: LD_INT 1
12845: PUSH
12846: LD_INT 3
12848: PUSH
12849: LD_INT 45
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: PPUSH
12866: CALL 55632 0 2
// end ; if Difficulty > 1 then
12870: LD_OWVAR 67
12874: PUSH
12875: LD_INT 1
12877: GREATER
12878: IFFALSE 12908
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12880: LD_INT 1
12882: PPUSH
12883: LD_INT 24
12885: PUSH
12886: LD_INT 3
12888: PUSH
12889: LD_INT 3
12891: PUSH
12892: LD_INT 47
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: LIST
12899: LIST
12900: PUSH
12901: EMPTY
12902: LIST
12903: PPUSH
12904: CALL 55632 0 2
// repeat wait ( 0 0$1 ) ;
12908: LD_INT 35
12910: PPUSH
12911: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
12915: LD_INT 1
12917: PPUSH
12918: LD_INT 1
12920: PPUSH
12921: CALL 56987 0 2
12925: PUSH
12926: LD_INT 6
12928: PUSH
12929: LD_INT 7
12931: PUSH
12932: LD_INT 7
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: LIST
12939: PUSH
12940: LD_OWVAR 67
12944: ARRAY
12945: GREATEREQUAL
12946: IFFALSE 12908
// wait ( 0 0$40 ) ;
12948: LD_INT 1400
12950: PPUSH
12951: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
12955: LD_ADDR_VAR 0 2
12959: PUSH
12960: LD_INT 1
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL 56987 0 2
12970: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
12971: LD_ADDR_EXP 118
12975: PUSH
12976: LD_EXP 118
12980: PPUSH
12981: LD_INT 1
12983: PPUSH
12984: LD_EXP 118
12988: PUSH
12989: LD_INT 1
12991: ARRAY
12992: PUSH
12993: LD_VAR 0 2
12997: DIFF
12998: PPUSH
12999: CALL_OW 1
13003: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13004: LD_ADDR_VAR 0 3
13008: PUSH
13009: LD_INT 0
13011: PPUSH
13012: LD_INT 1
13014: PPUSH
13015: CALL_OW 12
13019: ST_TO_ADDR
// if target then
13020: LD_VAR 0 3
13024: IFFALSE 13190
// begin for i in tmp do
13026: LD_ADDR_VAR 0 1
13030: PUSH
13031: LD_VAR 0 2
13035: PUSH
13036: FOR_IN
13037: IFFALSE 13062
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13039: LD_VAR 0 1
13043: PPUSH
13044: LD_INT 179
13046: PPUSH
13047: LD_INT 209
13049: PPUSH
13050: LD_INT 8
13052: PPUSH
13053: LD_INT 1
13055: PPUSH
13056: CALL_OW 483
13060: GO 13036
13062: POP
13063: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13064: LD_ADDR_VAR 0 2
13068: PUSH
13069: LD_VAR 0 2
13073: PPUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 250
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: PPUSH
13084: CALL_OW 72
13088: ST_TO_ADDR
// for i in tmp do
13089: LD_ADDR_VAR 0 1
13093: PUSH
13094: LD_VAR 0 2
13098: PUSH
13099: FOR_IN
13100: IFFALSE 13140
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13102: LD_VAR 0 1
13106: PPUSH
13107: LD_INT 179
13109: PPUSH
13110: LD_INT 209
13112: PPUSH
13113: CALL_OW 297
13117: PUSH
13118: LD_INT 9
13120: GREATER
13121: IFFALSE 13138
// ComMoveXY ( i , 179 , 209 ) ;
13123: LD_VAR 0 1
13127: PPUSH
13128: LD_INT 179
13130: PPUSH
13131: LD_INT 209
13133: PPUSH
13134: CALL_OW 111
13138: GO 13099
13140: POP
13141: POP
// wait ( 0 0$1 ) ;
13142: LD_INT 35
13144: PPUSH
13145: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13149: LD_VAR 0 2
13153: PPUSH
13154: LD_INT 92
13156: PUSH
13157: LD_INT 179
13159: PUSH
13160: LD_INT 209
13162: PUSH
13163: LD_INT 9
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: PPUSH
13172: CALL_OW 72
13176: PUSH
13177: LD_VAR 0 2
13181: PUSH
13182: LD_INT 1
13184: MINUS
13185: GREATEREQUAL
13186: IFFALSE 13064
// end else
13188: GO 13352
// begin for i in tmp do
13190: LD_ADDR_VAR 0 1
13194: PUSH
13195: LD_VAR 0 2
13199: PUSH
13200: FOR_IN
13201: IFFALSE 13226
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13203: LD_VAR 0 1
13207: PPUSH
13208: LD_INT 285
13210: PPUSH
13211: LD_INT 163
13213: PPUSH
13214: LD_INT 8
13216: PPUSH
13217: LD_INT 1
13219: PPUSH
13220: CALL_OW 483
13224: GO 13200
13226: POP
13227: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13228: LD_ADDR_VAR 0 2
13232: PUSH
13233: LD_VAR 0 2
13237: PPUSH
13238: LD_INT 24
13240: PUSH
13241: LD_INT 250
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: PPUSH
13248: CALL_OW 72
13252: ST_TO_ADDR
// for i in tmp do
13253: LD_ADDR_VAR 0 1
13257: PUSH
13258: LD_VAR 0 2
13262: PUSH
13263: FOR_IN
13264: IFFALSE 13304
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13266: LD_VAR 0 1
13270: PPUSH
13271: LD_INT 285
13273: PPUSH
13274: LD_INT 163
13276: PPUSH
13277: CALL_OW 297
13281: PUSH
13282: LD_INT 9
13284: GREATER
13285: IFFALSE 13302
// ComMoveXY ( i , 285 , 163 ) ;
13287: LD_VAR 0 1
13291: PPUSH
13292: LD_INT 285
13294: PPUSH
13295: LD_INT 163
13297: PPUSH
13298: CALL_OW 111
13302: GO 13263
13304: POP
13305: POP
// wait ( 0 0$1 ) ;
13306: LD_INT 35
13308: PPUSH
13309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13313: LD_VAR 0 2
13317: PPUSH
13318: LD_INT 92
13320: PUSH
13321: LD_INT 285
13323: PUSH
13324: LD_INT 163
13326: PUSH
13327: LD_INT 9
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: LIST
13334: LIST
13335: PPUSH
13336: CALL_OW 72
13340: PUSH
13341: LD_VAR 0 2
13345: PUSH
13346: LD_INT 1
13348: MINUS
13349: GREATEREQUAL
13350: IFFALSE 13228
// end ; repeat wait ( 0 0$1 ) ;
13352: LD_INT 35
13354: PPUSH
13355: CALL_OW 67
// for i in tmp do
13359: LD_ADDR_VAR 0 1
13363: PUSH
13364: LD_VAR 0 2
13368: PUSH
13369: FOR_IN
13370: IFFALSE 13492
// if GetLives ( i ) > 251 then
13372: LD_VAR 0 1
13376: PPUSH
13377: CALL_OW 256
13381: PUSH
13382: LD_INT 251
13384: GREATER
13385: IFFALSE 13474
// begin if GetWeapon ( i ) = ru_time_lapser then
13387: LD_VAR 0 1
13391: PPUSH
13392: CALL_OW 264
13396: PUSH
13397: LD_INT 49
13399: EQUAL
13400: IFFALSE 13438
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_INT 81
13409: PUSH
13410: LD_INT 7
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: PPUSH
13417: CALL_OW 69
13421: PPUSH
13422: LD_VAR 0 1
13426: PPUSH
13427: CALL_OW 74
13431: PPUSH
13432: CALL_OW 112
13436: GO 13472
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 81
13445: PUSH
13446: LD_INT 7
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PPUSH
13453: CALL_OW 69
13457: PPUSH
13458: LD_VAR 0 1
13462: PPUSH
13463: CALL_OW 74
13467: PPUSH
13468: CALL_OW 115
// end else
13472: GO 13490
// tmp := tmp diff i ;
13474: LD_ADDR_VAR 0 2
13478: PUSH
13479: LD_VAR 0 2
13483: PUSH
13484: LD_VAR 0 1
13488: DIFF
13489: ST_TO_ADDR
13490: GO 13369
13492: POP
13493: POP
// until not tmp ;
13494: LD_VAR 0 2
13498: NOT
13499: IFFALSE 13352
// end ; end_of_file
13501: PPOPN 4
13503: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13504: LD_INT 0
13506: PPUSH
13507: PPUSH
13508: PPUSH
13509: PPUSH
// missionStage := 13 ;
13510: LD_ADDR_EXP 15
13514: PUSH
13515: LD_INT 13
13517: ST_TO_ADDR
// uc_side := 2 ;
13518: LD_ADDR_OWVAR 20
13522: PUSH
13523: LD_INT 2
13525: ST_TO_ADDR
// uc_nation := 2 ;
13526: LD_ADDR_OWVAR 21
13530: PUSH
13531: LD_INT 2
13533: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13534: LD_ADDR_EXP 89
13538: PUSH
13539: LD_STRING Omar
13541: PPUSH
13542: CALL_OW 25
13546: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13547: LD_EXP 89
13551: PPUSH
13552: LD_INT 4
13554: PPUSH
13555: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13559: LD_EXP 89
13563: PPUSH
13564: LD_INT 242
13566: PPUSH
13567: LD_INT 75
13569: PPUSH
13570: LD_INT 0
13572: PPUSH
13573: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13577: LD_ADDR_EXP 90
13581: PUSH
13582: LD_STRING Heike
13584: PPUSH
13585: CALL_OW 25
13589: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13590: LD_INT 14
13592: PPUSH
13593: LD_INT 3
13595: PPUSH
13596: LD_INT 1
13598: PPUSH
13599: LD_INT 27
13601: PPUSH
13602: LD_INT 100
13604: PPUSH
13605: CALL 68197 0 5
// veh := CreateVehicle ;
13609: LD_ADDR_VAR 0 3
13613: PUSH
13614: CALL_OW 45
13618: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13619: LD_VAR 0 3
13623: PPUSH
13624: LD_INT 1
13626: PPUSH
13627: CALL_OW 242
// SetDir ( veh , 4 ) ;
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_INT 4
13638: PPUSH
13639: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13643: LD_VAR 0 3
13647: PPUSH
13648: LD_INT 241
13650: PPUSH
13651: LD_INT 72
13653: PPUSH
13654: LD_INT 0
13656: PPUSH
13657: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13661: LD_EXP 90
13665: PPUSH
13666: LD_VAR 0 3
13670: PPUSH
13671: CALL_OW 52
// if KhatamStatus then
13675: LD_EXP 8
13679: IFFALSE 13730
// begin Khatam := NewCharacter ( Khatam ) ;
13681: LD_ADDR_EXP 91
13685: PUSH
13686: LD_STRING Khatam
13688: PPUSH
13689: CALL_OW 25
13693: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13694: LD_EXP 91
13698: PPUSH
13699: LD_INT 245
13701: PPUSH
13702: LD_INT 78
13704: PPUSH
13705: LD_INT 3
13707: PPUSH
13708: LD_INT 0
13710: PPUSH
13711: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13715: LD_EXP 91
13719: PPUSH
13720: LD_INT 4
13722: PPUSH
13723: LD_INT 10
13725: PPUSH
13726: CALL_OW 237
// end ; for i = 1 to Difficulty do
13730: LD_ADDR_VAR 0 2
13734: PUSH
13735: DOUBLE
13736: LD_INT 1
13738: DEC
13739: ST_TO_ADDR
13740: LD_OWVAR 67
13744: PUSH
13745: FOR_TO
13746: IFFALSE 13812
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13748: LD_INT 0
13750: PPUSH
13751: LD_INT 7
13753: PUSH
13754: LD_OWVAR 67
13758: PLUS
13759: PPUSH
13760: CALL_OW 384
// un := CreateHuman ;
13764: LD_ADDR_VAR 0 4
13768: PUSH
13769: CALL_OW 44
13773: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13774: LD_VAR 0 4
13778: PPUSH
13779: LD_INT 28
13781: PUSH
13782: LD_INT 29
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: PUSH
13789: LD_VAR 0 2
13793: PUSH
13794: LD_INT 2
13796: MOD
13797: PUSH
13798: LD_INT 1
13800: PLUS
13801: ARRAY
13802: PPUSH
13803: LD_INT 0
13805: PPUSH
13806: CALL_OW 49
// end ;
13810: GO 13745
13812: POP
13813: POP
// for i = 1 to 6 do
13814: LD_ADDR_VAR 0 2
13818: PUSH
13819: DOUBLE
13820: LD_INT 1
13822: DEC
13823: ST_TO_ADDR
13824: LD_INT 6
13826: PUSH
13827: FOR_TO
13828: IFFALSE 13873
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13830: LD_INT 0
13832: PPUSH
13833: LD_INT 7
13835: PUSH
13836: LD_OWVAR 67
13840: PLUS
13841: PPUSH
13842: CALL_OW 381
// un := CreateHuman ;
13846: LD_ADDR_VAR 0 4
13850: PUSH
13851: CALL_OW 44
13855: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13856: LD_VAR 0 4
13860: PPUSH
13861: LD_INT 28
13863: PPUSH
13864: LD_INT 0
13866: PPUSH
13867: CALL_OW 49
// end ;
13871: GO 13827
13873: POP
13874: POP
// for i = 1 to 3 do
13875: LD_ADDR_VAR 0 2
13879: PUSH
13880: DOUBLE
13881: LD_INT 1
13883: DEC
13884: ST_TO_ADDR
13885: LD_INT 3
13887: PUSH
13888: FOR_TO
13889: IFFALSE 13937
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13891: LD_INT 0
13893: PPUSH
13894: LD_INT 8
13896: PPUSH
13897: LD_INT 7
13899: PUSH
13900: LD_OWVAR 67
13904: PLUS
13905: PPUSH
13906: CALL_OW 380
// un := CreateHuman ;
13910: LD_ADDR_VAR 0 4
13914: PUSH
13915: CALL_OW 44
13919: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13920: LD_VAR 0 4
13924: PPUSH
13925: LD_INT 28
13927: PPUSH
13928: LD_INT 0
13930: PPUSH
13931: CALL_OW 49
// end ;
13935: GO 13888
13937: POP
13938: POP
// for i = 1 to 3 do
13939: LD_ADDR_VAR 0 2
13943: PUSH
13944: DOUBLE
13945: LD_INT 1
13947: DEC
13948: ST_TO_ADDR
13949: LD_INT 3
13951: PUSH
13952: FOR_TO
13953: IFFALSE 14043
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
13955: LD_INT 14
13957: PPUSH
13958: LD_INT 2
13960: PPUSH
13961: LD_INT 1
13963: PPUSH
13964: LD_INT 28
13966: PPUSH
13967: LD_INT 80
13969: PPUSH
13970: CALL 68197 0 5
// veh := CreateVehicle ;
13974: LD_ADDR_VAR 0 3
13978: PUSH
13979: CALL_OW 45
13983: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
13984: LD_VAR 0 3
13988: PPUSH
13989: LD_INT 3
13991: PPUSH
13992: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
13996: LD_VAR 0 3
14000: PPUSH
14001: LD_INT 29
14003: PPUSH
14004: LD_INT 0
14006: PPUSH
14007: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14011: LD_INT 0
14013: PPUSH
14014: LD_INT 7
14016: PUSH
14017: LD_OWVAR 67
14021: PLUS
14022: PPUSH
14023: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14027: CALL_OW 44
14031: PPUSH
14032: LD_VAR 0 3
14036: PPUSH
14037: CALL_OW 52
// end ;
14041: GO 13952
14043: POP
14044: POP
// for i = 1 to 5 + Difficulty do
14045: LD_ADDR_VAR 0 2
14049: PUSH
14050: DOUBLE
14051: LD_INT 1
14053: DEC
14054: ST_TO_ADDR
14055: LD_INT 5
14057: PUSH
14058: LD_OWVAR 67
14062: PLUS
14063: PUSH
14064: FOR_TO
14065: IFFALSE 14192
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14067: LD_INT 14
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: LD_INT 3
14075: PPUSH
14076: CALL_OW 12
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: LD_INT 28
14086: PUSH
14087: LD_INT 26
14089: PUSH
14090: LD_INT 27
14092: PUSH
14093: LD_INT 25
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: PUSH
14102: LD_VAR 0 2
14106: PUSH
14107: LD_INT 4
14109: MOD
14110: PUSH
14111: LD_INT 1
14113: PLUS
14114: ARRAY
14115: PPUSH
14116: LD_INT 80
14118: PPUSH
14119: CALL 68197 0 5
// veh := CreateVehicle ;
14123: LD_ADDR_VAR 0 3
14127: PUSH
14128: CALL_OW 45
14132: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14133: LD_VAR 0 3
14137: PPUSH
14138: LD_INT 4
14140: PPUSH
14141: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: LD_INT 28
14152: PPUSH
14153: LD_INT 0
14155: PPUSH
14156: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14160: LD_INT 0
14162: PPUSH
14163: LD_INT 7
14165: PUSH
14166: LD_OWVAR 67
14170: PLUS
14171: PPUSH
14172: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14176: CALL_OW 44
14180: PPUSH
14181: LD_VAR 0 3
14185: PPUSH
14186: CALL_OW 52
// end ;
14190: GO 14064
14192: POP
14193: POP
// for i = 1 to 3 do
14194: LD_ADDR_VAR 0 2
14198: PUSH
14199: DOUBLE
14200: LD_INT 1
14202: DEC
14203: ST_TO_ADDR
14204: LD_INT 3
14206: PUSH
14207: FOR_TO
14208: IFFALSE 14268
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14210: LD_INT 14
14212: PPUSH
14213: LD_INT 3
14215: PPUSH
14216: LD_INT 5
14218: PPUSH
14219: LD_INT 29
14221: PPUSH
14222: LD_INT 80
14224: PPUSH
14225: CALL 68197 0 5
// veh := CreateVehicle ;
14229: LD_ADDR_VAR 0 3
14233: PUSH
14234: CALL_OW 45
14238: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14239: LD_VAR 0 3
14243: PPUSH
14244: LD_INT 4
14246: PPUSH
14247: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14251: LD_VAR 0 3
14255: PPUSH
14256: LD_INT 28
14258: PPUSH
14259: LD_INT 0
14261: PPUSH
14262: CALL_OW 49
// end ;
14266: GO 14207
14268: POP
14269: POP
// end ;
14270: LD_VAR 0 1
14274: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14275: LD_INT 22
14277: PUSH
14278: LD_INT 2
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: PPUSH
14285: CALL_OW 69
14289: IFFALSE 14589
14291: GO 14293
14293: DISABLE
14294: LD_INT 0
14296: PPUSH
14297: PPUSH
14298: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14299: LD_ADDR_VAR 0 3
14303: PUSH
14304: LD_INT 22
14306: PUSH
14307: LD_INT 2
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: PUSH
14314: LD_INT 25
14316: PUSH
14317: LD_INT 4
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: PUSH
14324: EMPTY
14325: LIST
14326: LIST
14327: PPUSH
14328: CALL_OW 69
14332: PUSH
14333: LD_EXP 91
14337: DIFF
14338: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14339: LD_ADDR_VAR 0 2
14343: PUSH
14344: LD_INT 22
14346: PUSH
14347: LD_INT 2
14349: PUSH
14350: EMPTY
14351: LIST
14352: LIST
14353: PPUSH
14354: CALL_OW 69
14358: PUSH
14359: LD_EXP 91
14363: PUSH
14364: LD_VAR 0 3
14368: UNION
14369: DIFF
14370: ST_TO_ADDR
// if Khatam then
14371: LD_EXP 91
14375: IFFALSE 14392
// ComMoveXY ( Khatam , 211 , 92 ) ;
14377: LD_EXP 91
14381: PPUSH
14382: LD_INT 211
14384: PPUSH
14385: LD_INT 92
14387: PPUSH
14388: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14392: LD_INT 197
14394: PPUSH
14395: LD_INT 80
14397: PPUSH
14398: LD_INT 2
14400: PPUSH
14401: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14405: LD_INT 213
14407: PPUSH
14408: LD_INT 90
14410: PPUSH
14411: LD_INT 2
14413: PPUSH
14414: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14418: LD_INT 215
14420: PPUSH
14421: LD_INT 129
14423: PPUSH
14424: LD_INT 2
14426: PPUSH
14427: CALL_OW 441
// if sci then
14431: LD_VAR 0 3
14435: IFFALSE 14456
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14437: LD_VAR 0 3
14441: PUSH
14442: LD_INT 1
14444: ARRAY
14445: PPUSH
14446: LD_INT 197
14448: PPUSH
14449: LD_INT 80
14451: PPUSH
14452: CALL_OW 158
// if sci > 1 then
14456: LD_VAR 0 3
14460: PUSH
14461: LD_INT 1
14463: GREATER
14464: IFFALSE 14485
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14466: LD_VAR 0 3
14470: PUSH
14471: LD_INT 2
14473: ARRAY
14474: PPUSH
14475: LD_INT 213
14477: PPUSH
14478: LD_INT 90
14480: PPUSH
14481: CALL_OW 158
// if sci > 2 then
14485: LD_VAR 0 3
14489: PUSH
14490: LD_INT 2
14492: GREATER
14493: IFFALSE 14514
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14495: LD_VAR 0 3
14499: PUSH
14500: LD_INT 3
14502: ARRAY
14503: PPUSH
14504: LD_INT 215
14506: PPUSH
14507: LD_INT 129
14509: PPUSH
14510: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14514: LD_INT 35
14516: PPUSH
14517: CALL_OW 67
// for i in tmp do
14521: LD_ADDR_VAR 0 1
14525: PUSH
14526: LD_VAR 0 2
14530: PUSH
14531: FOR_IN
14532: IFFALSE 14570
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14534: LD_VAR 0 1
14538: PPUSH
14539: LD_INT 81
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: PPUSH
14549: CALL_OW 69
14553: PPUSH
14554: LD_VAR 0 1
14558: PPUSH
14559: CALL_OW 74
14563: PPUSH
14564: CALL_OW 115
14568: GO 14531
14570: POP
14571: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14572: LD_INT 22
14574: PUSH
14575: LD_INT 2
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PPUSH
14582: CALL_OW 69
14586: NOT
14587: IFFALSE 14514
// end ; end_of_file
14589: PPOPN 3
14591: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14592: LD_INT 0
14594: PPUSH
14595: PPUSH
14596: PPUSH
14597: PPUSH
14598: PPUSH
14599: PPUSH
14600: PPUSH
14601: PPUSH
14602: PPUSH
// Video ( true ) ;
14603: LD_INT 1
14605: PPUSH
14606: CALL 103852 0 1
// if debug then
14610: LD_EXP 1
14614: IFFALSE 14624
// dialogue_skipped := true ;
14616: LD_ADDR_OWVAR 59
14620: PUSH
14621: LD_INT 1
14623: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14624: LD_ADDR_VAR 0 5
14628: PUSH
14629: LD_INT 7
14631: PPUSH
14632: LD_INT 0
14634: PPUSH
14635: CALL_OW 517
14639: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14640: LD_ADDR_VAR 0 2
14644: PUSH
14645: DOUBLE
14646: LD_INT 1
14648: DEC
14649: ST_TO_ADDR
14650: LD_VAR 0 5
14654: PUSH
14655: LD_INT 1
14657: ARRAY
14658: PUSH
14659: FOR_TO
14660: IFFALSE 14705
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14662: LD_VAR 0 5
14666: PUSH
14667: LD_INT 1
14669: ARRAY
14670: PUSH
14671: LD_VAR 0 2
14675: ARRAY
14676: PPUSH
14677: LD_VAR 0 5
14681: PUSH
14682: LD_INT 2
14684: ARRAY
14685: PUSH
14686: LD_VAR 0 2
14690: ARRAY
14691: PPUSH
14692: LD_INT 1
14694: PPUSH
14695: LD_INT 15
14697: NEG
14698: PPUSH
14699: CALL 103766 0 4
14703: GO 14659
14705: POP
14706: POP
// CenterNowOnUnits ( Powell ) ;
14707: LD_EXP 55
14711: PPUSH
14712: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14716: LD_ADDR_VAR 0 5
14720: PUSH
14721: LD_EXP 53
14725: PUSH
14726: EMPTY
14727: LIST
14728: ST_TO_ADDR
// if GirlNewVeh then
14729: LD_EXP 54
14733: IFFALSE 14751
// tmp := tmp ^ GirlNewVeh ;
14735: LD_ADDR_VAR 0 5
14739: PUSH
14740: LD_VAR 0 5
14744: PUSH
14745: LD_EXP 54
14749: ADD
14750: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14751: LD_VAR 0 5
14755: PPUSH
14756: LD_INT 60
14758: PPUSH
14759: LD_INT 109
14761: PPUSH
14762: CALL_OW 111
// if KappaStatus then
14766: LD_EXP 2
14770: IFFALSE 14822
// begin Say ( JMM , D1nT-JMM-1 ) ;
14772: LD_EXP 36
14776: PPUSH
14777: LD_STRING D1nT-JMM-1
14779: PPUSH
14780: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14784: LD_EXP 55
14788: PPUSH
14789: LD_STRING D1T-Pow-1
14791: PPUSH
14792: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14796: LD_EXP 36
14800: PPUSH
14801: LD_STRING D1T-JMM-2
14803: PPUSH
14804: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14808: LD_EXP 55
14812: PPUSH
14813: LD_STRING D1T-Pow-2
14815: PPUSH
14816: CALL_OW 88
// end else
14820: GO 15028
// if JMMGirlStatus then
14822: LD_EXP 6
14826: IFFALSE 14971
// begin Say ( JMM , D1T-JMM-1 ) ;
14828: LD_EXP 36
14832: PPUSH
14833: LD_STRING D1T-JMM-1
14835: PPUSH
14836: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14840: LD_EXP 55
14844: PPUSH
14845: LD_STRING D1T-Pow-1
14847: PPUSH
14848: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14852: LD_EXP 36
14856: PPUSH
14857: LD_STRING D1T-JMM-3
14859: PPUSH
14860: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14864: LD_EXP 55
14868: PPUSH
14869: LD_STRING D1T-Pow-3
14871: PPUSH
14872: CALL_OW 88
// if JMMGirl then
14876: LD_EXP 7
14880: IFFALSE 14969
// begin case JMMGirl of 1 :
14882: LD_EXP 7
14886: PUSH
14887: LD_INT 1
14889: DOUBLE
14890: EQUAL
14891: IFTRUE 14895
14893: GO 14910
14895: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
14896: LD_EXP 37
14900: PPUSH
14901: LD_STRING D1T-Joan-3
14903: PPUSH
14904: CALL_OW 88
14908: GO 14957
14910: LD_INT 2
14912: DOUBLE
14913: EQUAL
14914: IFTRUE 14918
14916: GO 14933
14918: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
14919: LD_EXP 39
14923: PPUSH
14924: LD_STRING D1T-Lisa-3
14926: PPUSH
14927: CALL_OW 88
14931: GO 14957
14933: LD_INT 3
14935: DOUBLE
14936: EQUAL
14937: IFTRUE 14941
14939: GO 14956
14941: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
14942: LD_EXP 51
14946: PPUSH
14947: LD_STRING D1T-Con-3
14949: PPUSH
14950: CALL_OW 88
14954: GO 14957
14956: POP
// Say ( Powell , D1T-Pow-4 ) ;
14957: LD_EXP 55
14961: PPUSH
14962: LD_STRING D1T-Pow-4
14964: PPUSH
14965: CALL_OW 88
// end ; end else
14969: GO 15028
// if not FastEnd then
14971: LD_EXP 11
14975: NOT
14976: IFFALSE 15004
// begin Say ( JMM , D1T-JMM-4 ) ;
14978: LD_EXP 36
14982: PPUSH
14983: LD_STRING D1T-JMM-4
14985: PPUSH
14986: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
14990: LD_EXP 55
14994: PPUSH
14995: LD_STRING D1T-Pow-5
14997: PPUSH
14998: CALL_OW 88
// end else
15002: GO 15028
// begin Say ( JMM , D1nT-JMM-1 ) ;
15004: LD_EXP 36
15008: PPUSH
15009: LD_STRING D1nT-JMM-1
15011: PPUSH
15012: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15016: LD_EXP 55
15020: PPUSH
15021: LD_STRING D1nT-Pow-1
15023: PPUSH
15024: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15028: LD_INT 35
15030: PPUSH
15031: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15035: LD_EXP 53
15039: PPUSH
15040: CALL_OW 314
15044: NOT
15045: IFFALSE 15028
// ComExitVehicle ( JMM ) ;
15047: LD_EXP 36
15051: PPUSH
15052: CALL_OW 121
// wait ( 3 ) ;
15056: LD_INT 3
15058: PPUSH
15059: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15063: LD_EXP 36
15067: PPUSH
15068: LD_INT 60
15070: PPUSH
15071: LD_INT 94
15073: PPUSH
15074: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15078: LD_EXP 36
15082: PPUSH
15083: LD_EXP 55
15087: PPUSH
15088: CALL_OW 179
// if Joan then
15092: LD_EXP 37
15096: IFFALSE 15150
// begin ComExitVehicle ( Joan ) ;
15098: LD_EXP 37
15102: PPUSH
15103: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15107: LD_EXP 37
15111: PPUSH
15112: LD_INT 35
15114: PPUSH
15115: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15119: LD_EXP 37
15123: PPUSH
15124: LD_INT 65
15126: PPUSH
15127: LD_INT 104
15129: PPUSH
15130: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15134: LD_EXP 37
15138: PPUSH
15139: LD_EXP 36
15143: PPUSH
15144: CALL_OW 179
// end else
15148: GO 15284
// if Lisa and JMMGirl = 2 then
15150: LD_EXP 39
15154: PUSH
15155: LD_EXP 7
15159: PUSH
15160: LD_INT 2
15162: EQUAL
15163: AND
15164: IFFALSE 15218
// begin ComExitVehicle ( Lisa ) ;
15166: LD_EXP 39
15170: PPUSH
15171: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15175: LD_EXP 39
15179: PPUSH
15180: LD_INT 35
15182: PPUSH
15183: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15187: LD_EXP 39
15191: PPUSH
15192: LD_INT 65
15194: PPUSH
15195: LD_INT 104
15197: PPUSH
15198: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15202: LD_EXP 39
15206: PPUSH
15207: LD_EXP 36
15211: PPUSH
15212: CALL_OW 179
// end else
15216: GO 15284
// if Connie and JMMGirl = 3 then
15218: LD_EXP 51
15222: PUSH
15223: LD_EXP 7
15227: PUSH
15228: LD_INT 3
15230: EQUAL
15231: AND
15232: IFFALSE 15284
// begin ComExitVehicle ( Connie ) ;
15234: LD_EXP 51
15238: PPUSH
15239: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15243: LD_EXP 51
15247: PPUSH
15248: LD_INT 35
15250: PPUSH
15251: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15255: LD_EXP 51
15259: PPUSH
15260: LD_INT 65
15262: PPUSH
15263: LD_INT 104
15265: PPUSH
15266: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15270: LD_EXP 51
15274: PPUSH
15275: LD_EXP 36
15279: PPUSH
15280: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15284: LD_INT 35
15286: PPUSH
15287: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15291: LD_EXP 36
15295: PPUSH
15296: LD_EXP 55
15300: PPUSH
15301: CALL_OW 296
15305: PUSH
15306: LD_INT 6
15308: LESS
15309: IFFALSE 15284
// wait ( 0 0$0.5 ) ;
15311: LD_INT 18
15313: PPUSH
15314: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15318: LD_EXP 36
15322: PPUSH
15323: LD_STRING D1-JMM-1
15325: PPUSH
15326: CALL_OW 88
// async ;
15330: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15331: LD_EXP 55
15335: PPUSH
15336: LD_STRING D1-Pow-1
15338: PPUSH
15339: CALL_OW 88
// if not dialogue_skipped then
15343: LD_OWVAR 59
15347: NOT
15348: IFFALSE 15357
// wait ( 0 0$2 ) ;
15350: LD_INT 70
15352: PPUSH
15353: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15357: LD_INT 170
15359: PPUSH
15360: LD_INT 99
15362: PPUSH
15363: LD_INT 1
15365: PPUSH
15366: LD_INT 6
15368: NEG
15369: PPUSH
15370: CALL 103766 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15374: LD_INT 174
15376: PPUSH
15377: LD_INT 115
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: LD_INT 6
15385: NEG
15386: PPUSH
15387: CALL 103766 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15391: LD_INT 169
15393: PPUSH
15394: LD_INT 71
15396: PPUSH
15397: LD_INT 1
15399: PPUSH
15400: LD_INT 6
15402: NEG
15403: PPUSH
15404: CALL 103766 0 4
// if not dialogue_skipped then
15408: LD_OWVAR 59
15412: NOT
15413: IFFALSE 15432
// begin CenterOnXY ( 170 , 99 ) ;
15415: LD_INT 170
15417: PPUSH
15418: LD_INT 99
15420: PPUSH
15421: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15425: LD_INT 80
15427: PPUSH
15428: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15432: LD_INT 75
15434: PPUSH
15435: LD_INT 53
15437: PPUSH
15438: LD_INT 1
15440: PPUSH
15441: LD_INT 9
15443: NEG
15444: PPUSH
15445: CALL 103766 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15449: LD_INT 54
15451: PPUSH
15452: LD_INT 42
15454: PPUSH
15455: LD_INT 1
15457: PPUSH
15458: LD_INT 9
15460: NEG
15461: PPUSH
15462: CALL 103766 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15466: LD_INT 62
15468: PPUSH
15469: LD_INT 51
15471: PPUSH
15472: LD_INT 1
15474: PPUSH
15475: LD_INT 9
15477: NEG
15478: PPUSH
15479: CALL 103766 0 4
// if not dialogue_skipped then
15483: LD_OWVAR 59
15487: NOT
15488: IFFALSE 15507
// begin CenterOnXY ( 75 , 53 ) ;
15490: LD_INT 75
15492: PPUSH
15493: LD_INT 53
15495: PPUSH
15496: CALL_OW 84
// wait ( 0 0$4 ) ;
15500: LD_INT 140
15502: PPUSH
15503: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15507: LD_EXP 55
15511: PPUSH
15512: CALL_OW 87
// if not dialogue_skipped then
15516: LD_OWVAR 59
15520: NOT
15521: IFFALSE 15530
// wait ( 0 0$2 ) ;
15523: LD_INT 70
15525: PPUSH
15526: CALL_OW 67
// sync ;
15530: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15531: LD_EXP 36
15535: PPUSH
15536: LD_STRING D1-JMM-2
15538: PPUSH
15539: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15543: LD_EXP 55
15547: PPUSH
15548: LD_STRING D1-Pow-2
15550: PPUSH
15551: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15555: LD_EXP 36
15559: PPUSH
15560: LD_STRING D1-JMM-3
15562: PPUSH
15563: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15567: LD_EXP 55
15571: PPUSH
15572: LD_STRING D1-Pow-3
15574: PPUSH
15575: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15579: LD_EXP 36
15583: PPUSH
15584: LD_STRING D1-JMM-4
15586: PPUSH
15587: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15591: LD_EXP 55
15595: PPUSH
15596: LD_STRING D1-Pow-4
15598: PPUSH
15599: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15603: LD_EXP 36
15607: PPUSH
15608: LD_STRING D1-JMM-5
15610: PPUSH
15611: CALL_OW 88
// async ;
15615: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15616: LD_EXP 55
15620: PPUSH
15621: LD_STRING D1-Pow-5
15623: PPUSH
15624: CALL_OW 88
// if not dialogue_skipped then
15628: LD_OWVAR 59
15632: NOT
15633: IFFALSE 15642
// wait ( 0 0$3.6 ) ;
15635: LD_INT 126
15637: PPUSH
15638: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15642: LD_INT 134
15644: PPUSH
15645: LD_INT 210
15647: PPUSH
15648: LD_INT 1
15650: PPUSH
15651: LD_INT 11
15653: NEG
15654: PPUSH
15655: CALL 103766 0 4
// if not dialogue_skipped then
15659: LD_OWVAR 59
15663: NOT
15664: IFFALSE 15683
// begin CenterOnXY ( 134 , 210 ) ;
15666: LD_INT 134
15668: PPUSH
15669: LD_INT 210
15671: PPUSH
15672: CALL_OW 84
// wait ( 0 0$2 ) ;
15676: LD_INT 70
15678: PPUSH
15679: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15683: LD_INT 101
15685: PPUSH
15686: LD_INT 159
15688: PPUSH
15689: LD_INT 1
15691: PPUSH
15692: LD_INT 10
15694: NEG
15695: PPUSH
15696: CALL 103766 0 4
// if not dialogue_skipped then
15700: LD_OWVAR 59
15704: NOT
15705: IFFALSE 15724
// begin CenterOnXY ( 101 , 159 ) ;
15707: LD_INT 101
15709: PPUSH
15710: LD_INT 159
15712: PPUSH
15713: CALL_OW 84
// wait ( 0 0$2 ) ;
15717: LD_INT 70
15719: PPUSH
15720: CALL_OW 67
// end ; sync ;
15724: SYNC
// CenterNowOnUnits ( Powell ) ;
15725: LD_EXP 55
15729: PPUSH
15730: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15734: LD_ADDR_VAR 0 6
15738: PUSH
15739: LD_INT 1
15741: PUSH
15742: LD_INT 2
15744: PUSH
15745: LD_INT 3
15747: PUSH
15748: LD_INT 4
15750: PUSH
15751: LD_INT 5
15753: PUSH
15754: LD_INT 6
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: LIST
15763: LIST
15764: ST_TO_ADDR
// if not dialogue_skipped then
15765: LD_OWVAR 59
15769: NOT
15770: IFFALSE 15939
// begin game_speed := 4 ;
15772: LD_ADDR_OWVAR 65
15776: PUSH
15777: LD_INT 4
15779: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15780: LD_INT 210
15782: PPUSH
15783: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15787: LD_ADDR_VAR 0 7
15791: PUSH
15792: LD_STRING Q1
15794: PPUSH
15795: LD_VAR 0 6
15799: PPUSH
15800: CALL_OW 98
15804: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15805: LD_ADDR_VAR 0 7
15809: PUSH
15810: LD_STRING Q1
15812: PPUSH
15813: LD_VAR 0 6
15817: PPUSH
15818: CALL_OW 98
15822: ST_TO_ADDR
// options = options diff dec ;
15823: LD_ADDR_VAR 0 6
15827: PUSH
15828: LD_VAR 0 6
15832: PUSH
15833: LD_VAR 0 7
15837: DIFF
15838: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15839: LD_VAR 0 7
15843: PPUSH
15844: LD_VAR 0 6
15848: PPUSH
15849: CALL 17222 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15853: LD_VAR 0 7
15857: PUSH
15858: LD_INT 5
15860: PUSH
15861: LD_INT 6
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: IN
15868: PUSH
15869: LD_VAR 0 6
15873: PUSH
15874: LD_INT 2
15876: EQUAL
15877: OR
15878: IFFALSE 15805
// if not ( dec in [ 5 , 6 ] ) then
15880: LD_VAR 0 7
15884: PUSH
15885: LD_INT 5
15887: PUSH
15888: LD_INT 6
15890: PUSH
15891: EMPTY
15892: LIST
15893: LIST
15894: IN
15895: NOT
15896: IFFALSE 15939
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
15898: LD_ADDR_VAR 0 7
15902: PUSH
15903: LD_STRING Q1a
15905: PPUSH
15906: LD_INT 1
15908: PUSH
15909: LD_INT 2
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PPUSH
15916: CALL_OW 98
15920: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
15921: LD_VAR 0 7
15925: PUSH
15926: LD_INT 4
15928: PLUS
15929: PPUSH
15930: LD_VAR 0 6
15934: PPUSH
15935: CALL 17222 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
15939: LD_INT 81
15941: PPUSH
15942: LD_INT 127
15944: PPUSH
15945: CALL_OW 84
// amount := 5 ;
15949: LD_ADDR_VAR 0 8
15953: PUSH
15954: LD_INT 5
15956: ST_TO_ADDR
// macmilan_squad := [ ] ;
15957: LD_ADDR_VAR 0 9
15961: PUSH
15962: EMPTY
15963: ST_TO_ADDR
// if vip < amount then
15964: LD_EXP 56
15968: PUSH
15969: LD_VAR 0 8
15973: LESS
15974: IFFALSE 16018
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
15976: LD_ADDR_VAR 0 5
15980: PUSH
15981: LD_EXP 56
15985: PUSH
15986: LD_INT 22
15988: PUSH
15989: LD_INT 4
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PUSH
15996: LD_INT 21
15998: PUSH
15999: LD_INT 1
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PUSH
16006: EMPTY
16007: LIST
16008: LIST
16009: PPUSH
16010: CALL_OW 69
16014: UNION
16015: ST_TO_ADDR
16016: GO 16028
// tmp := vip ;
16018: LD_ADDR_VAR 0 5
16022: PUSH
16023: LD_EXP 56
16027: ST_TO_ADDR
// tmp := tmp diff Powell ;
16028: LD_ADDR_VAR 0 5
16032: PUSH
16033: LD_VAR 0 5
16037: PUSH
16038: LD_EXP 55
16042: DIFF
16043: ST_TO_ADDR
// if tmp < amount then
16044: LD_VAR 0 5
16048: PUSH
16049: LD_VAR 0 8
16053: LESS
16054: IFFALSE 16066
// amount := tmp ;
16056: LD_ADDR_VAR 0 8
16060: PUSH
16061: LD_VAR 0 5
16065: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16066: LD_VAR 0 5
16070: PUSH
16071: LD_INT 1
16073: ARRAY
16074: PPUSH
16075: CALL_OW 257
16079: PUSH
16080: LD_INT 2
16082: NONEQUAL
16083: IFFALSE 16145
// begin if IsInUnit ( tmp [ 1 ] ) then
16085: LD_VAR 0 5
16089: PUSH
16090: LD_INT 1
16092: ARRAY
16093: PPUSH
16094: CALL_OW 310
16098: IFFALSE 16113
// ComExitBuilding ( tmp [ 1 ] ) ;
16100: LD_VAR 0 5
16104: PUSH
16105: LD_INT 1
16107: ARRAY
16108: PPUSH
16109: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16113: LD_VAR 0 5
16117: PUSH
16118: LD_INT 1
16120: ARRAY
16121: PPUSH
16122: LD_INT 387
16124: PPUSH
16125: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16129: LD_VAR 0 5
16133: PUSH
16134: LD_INT 1
16136: ARRAY
16137: PPUSH
16138: LD_INT 2
16140: PPUSH
16141: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16145: LD_EXP 36
16149: PPUSH
16150: LD_INT 82
16152: PPUSH
16153: LD_INT 129
16155: PPUSH
16156: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16160: LD_EXP 36
16164: PPUSH
16165: LD_EXP 55
16169: PPUSH
16170: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16174: LD_INT 22
16176: PUSH
16177: LD_INT 1
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: PPUSH
16184: CALL_OW 69
16188: PUSH
16189: LD_EXP 36
16193: DIFF
16194: PPUSH
16195: LD_INT 84
16197: PPUSH
16198: LD_INT 128
16200: PPUSH
16201: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16205: LD_INT 22
16207: PUSH
16208: LD_INT 1
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PPUSH
16215: CALL_OW 69
16219: PUSH
16220: LD_EXP 36
16224: DIFF
16225: PPUSH
16226: LD_EXP 36
16230: PPUSH
16231: CALL_OW 179
// for i = 1 to amount do
16235: LD_ADDR_VAR 0 2
16239: PUSH
16240: DOUBLE
16241: LD_INT 1
16243: DEC
16244: ST_TO_ADDR
16245: LD_VAR 0 8
16249: PUSH
16250: FOR_TO
16251: IFFALSE 16419
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16253: LD_ADDR_VAR 0 9
16257: PUSH
16258: LD_VAR 0 9
16262: PUSH
16263: LD_VAR 0 5
16267: PUSH
16268: LD_VAR 0 2
16272: ARRAY
16273: ADD
16274: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16275: LD_VAR 0 5
16279: PUSH
16280: LD_VAR 0 2
16284: ARRAY
16285: PPUSH
16286: CALL_OW 310
16290: IFFALSE 16307
// AddComExitBuilding ( tmp [ i ] ) ;
16292: LD_VAR 0 5
16296: PUSH
16297: LD_VAR 0 2
16301: ARRAY
16302: PPUSH
16303: CALL_OW 182
// if i = 2 and JMMNewVeh then
16307: LD_VAR 0 2
16311: PUSH
16312: LD_INT 2
16314: EQUAL
16315: PUSH
16316: LD_EXP 53
16320: AND
16321: IFFALSE 16379
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16323: LD_VAR 0 5
16327: PUSH
16328: LD_VAR 0 2
16332: ARRAY
16333: PPUSH
16334: LD_EXP 53
16338: PPUSH
16339: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16343: LD_VAR 0 5
16347: PUSH
16348: LD_VAR 0 2
16352: ARRAY
16353: PPUSH
16354: LD_INT 86
16356: PPUSH
16357: LD_INT 133
16359: PPUSH
16360: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16364: LD_VAR 0 5
16368: PUSH
16369: LD_VAR 0 2
16373: ARRAY
16374: PPUSH
16375: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16379: LD_VAR 0 5
16383: PUSH
16384: LD_VAR 0 2
16388: ARRAY
16389: PPUSH
16390: LD_INT 8
16392: PPUSH
16393: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16397: LD_VAR 0 5
16401: PUSH
16402: LD_VAR 0 2
16406: ARRAY
16407: PPUSH
16408: LD_EXP 36
16412: PPUSH
16413: CALL_OW 179
// end ;
16417: GO 16250
16419: POP
16420: POP
// if GirlNewVeh then
16421: LD_EXP 54
16425: IFFALSE 16439
// SetSide ( GirlNewVeh , 4 ) ;
16427: LD_EXP 54
16431: PPUSH
16432: LD_INT 4
16434: PPUSH
16435: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16439: LD_INT 35
16441: PPUSH
16442: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16446: LD_VAR 0 9
16450: PPUSH
16451: LD_INT 95
16453: PUSH
16454: LD_INT 9
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: PPUSH
16461: CALL_OW 72
16465: PUSH
16466: LD_INT 0
16468: EQUAL
16469: PUSH
16470: LD_EXP 36
16474: PPUSH
16475: LD_INT 9
16477: PPUSH
16478: CALL_OW 308
16482: NOT
16483: AND
16484: IFFALSE 16439
// wait ( 0 0$2 ) ;
16486: LD_INT 70
16488: PPUSH
16489: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16493: LD_VAR 0 9
16497: PPUSH
16498: LD_INT 1
16500: PPUSH
16501: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16505: LD_INT 21
16507: PUSH
16508: LD_INT 2
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: PUSH
16515: LD_INT 92
16517: PUSH
16518: LD_INT 83
16520: PUSH
16521: LD_INT 130
16523: PUSH
16524: LD_INT 10
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: LIST
16531: LIST
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: PPUSH
16537: CALL_OW 69
16541: PPUSH
16542: LD_INT 1
16544: PPUSH
16545: CALL_OW 235
// Video ( false ) ;
16549: LD_INT 0
16551: PPUSH
16552: CALL 103852 0 1
// ChangeMissionObjectives ( M1 ) ;
16556: LD_STRING M1
16558: PPUSH
16559: CALL_OW 337
// SaveForQuickRestart ;
16563: CALL_OW 22
// missionStart := true ;
16567: LD_ADDR_EXP 13
16571: PUSH
16572: LD_INT 1
16574: ST_TO_ADDR
// missionStage := 2 ;
16575: LD_ADDR_EXP 15
16579: PUSH
16580: LD_INT 2
16582: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16583: LD_INT 105
16585: PPUSH
16586: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
16590: LD_ADDR_VAR 0 5
16594: PUSH
16595: LD_VAR 0 5
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 1
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 21
16612: PUSH
16613: LD_INT 1
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 69
16628: DIFF
16629: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16630: LD_ADDR_EXP 99
16634: PUSH
16635: LD_EXP 99
16639: PPUSH
16640: LD_INT 4
16642: PPUSH
16643: LD_INT 22
16645: PUSH
16646: LD_INT 4
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: PUSH
16653: LD_INT 23
16655: PUSH
16656: LD_INT 1
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: PUSH
16663: LD_INT 3
16665: PUSH
16666: LD_INT 21
16668: PUSH
16669: LD_INT 2
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: LIST
16684: PPUSH
16685: CALL_OW 69
16689: PUSH
16690: LD_EXP 55
16694: DIFF
16695: PPUSH
16696: CALL_OW 1
16700: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16701: LD_ADDR_VAR 0 4
16705: PUSH
16706: LD_INT 22
16708: PUSH
16709: LD_INT 4
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: PUSH
16716: LD_INT 34
16718: PUSH
16719: LD_INT 12
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: EMPTY
16727: LIST
16728: LIST
16729: PPUSH
16730: CALL_OW 69
16734: PUSH
16735: LD_INT 1
16737: ARRAY
16738: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16739: LD_VAR 0 5
16743: PUSH
16744: LD_INT 1
16746: ARRAY
16747: PPUSH
16748: CALL_OW 310
16752: IFFALSE 16767
// ComExitBuilding ( tmp [ 1 ] ) ;
16754: LD_VAR 0 5
16758: PUSH
16759: LD_INT 1
16761: ARRAY
16762: PPUSH
16763: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16767: LD_VAR 0 5
16771: PUSH
16772: LD_INT 1
16774: ARRAY
16775: PPUSH
16776: LD_VAR 0 4
16780: PPUSH
16781: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16785: LD_VAR 0 5
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: PPUSH
16794: LD_INT 80
16796: PPUSH
16797: LD_INT 136
16799: PPUSH
16800: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16804: LD_VAR 0 5
16808: PUSH
16809: LD_INT 1
16811: ARRAY
16812: PPUSH
16813: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16817: LD_VAR 0 5
16821: PUSH
16822: LD_INT 1
16824: ARRAY
16825: PPUSH
16826: LD_INT 59
16828: PPUSH
16829: LD_INT 112
16831: PPUSH
16832: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16836: LD_VAR 0 5
16840: PUSH
16841: LD_INT 1
16843: ARRAY
16844: PPUSH
16845: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16849: LD_EXP 39
16853: PUSH
16854: LD_EXP 56
16858: IN
16859: PUSH
16860: LD_EXP 39
16864: PPUSH
16865: CALL_OW 255
16869: PUSH
16870: LD_INT 1
16872: EQUAL
16873: AND
16874: IFFALSE 16890
// Say ( Lisa , D3nW-Lisa-1 ) else
16876: LD_EXP 39
16880: PPUSH
16881: LD_STRING D3nW-Lisa-1
16883: PPUSH
16884: CALL_OW 88
16888: GO 17134
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
16890: LD_EXP 42
16894: PUSH
16895: LD_EXP 56
16899: IN
16900: PUSH
16901: LD_EXP 42
16905: PPUSH
16906: CALL_OW 255
16910: PUSH
16911: LD_INT 1
16913: EQUAL
16914: AND
16915: IFFALSE 16931
// Say ( Cyrus , D3nW-Cyrus-1 ) else
16917: LD_EXP 42
16921: PPUSH
16922: LD_STRING D3nW-Cyrus-1
16924: PPUSH
16925: CALL_OW 88
16929: GO 17134
// if Bobby in vip and GetSide ( Bobby ) = 1 then
16931: LD_EXP 41
16935: PUSH
16936: LD_EXP 56
16940: IN
16941: PUSH
16942: LD_EXP 41
16946: PPUSH
16947: CALL_OW 255
16951: PUSH
16952: LD_INT 1
16954: EQUAL
16955: AND
16956: IFFALSE 16972
// Say ( Bobby , D3nW-Bobby-1 ) else
16958: LD_EXP 41
16962: PPUSH
16963: LD_STRING D3nW-Bobby-1
16965: PPUSH
16966: CALL_OW 88
16970: GO 17134
// if Gary in vip and GetSide ( Gary ) = 1 then
16972: LD_EXP 48
16976: PUSH
16977: LD_EXP 56
16981: IN
16982: PUSH
16983: LD_EXP 48
16987: PPUSH
16988: CALL_OW 255
16992: PUSH
16993: LD_INT 1
16995: EQUAL
16996: AND
16997: IFFALSE 17013
// Say ( Gary , D3nW-Gary-1 ) else
16999: LD_EXP 48
17003: PPUSH
17004: LD_STRING D3nW-Gary-1
17006: PPUSH
17007: CALL_OW 88
17011: GO 17134
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17013: LD_EXP 40
17017: PUSH
17018: LD_EXP 56
17022: IN
17023: PUSH
17024: LD_EXP 40
17028: PPUSH
17029: CALL_OW 255
17033: PUSH
17034: LD_INT 1
17036: EQUAL
17037: AND
17038: IFFALSE 17054
// Say ( Donaldson , D3nW-Don-1 ) else
17040: LD_EXP 40
17044: PPUSH
17045: LD_STRING D3nW-Don-1
17047: PPUSH
17048: CALL_OW 88
17052: GO 17134
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17054: LD_EXP 47
17058: PUSH
17059: LD_EXP 56
17063: IN
17064: PUSH
17065: LD_EXP 47
17069: PPUSH
17070: CALL_OW 255
17074: PUSH
17075: LD_INT 1
17077: EQUAL
17078: AND
17079: IFFALSE 17095
// Say ( Cornel , D3nW-Corn-1 ) else
17081: LD_EXP 47
17085: PPUSH
17086: LD_STRING D3nW-Corn-1
17088: PPUSH
17089: CALL_OW 88
17093: GO 17134
// if Frank in vip and GetSide ( Frank ) = 1 then
17095: LD_EXP 49
17099: PUSH
17100: LD_EXP 56
17104: IN
17105: PUSH
17106: LD_EXP 49
17110: PPUSH
17111: CALL_OW 255
17115: PUSH
17116: LD_INT 1
17118: EQUAL
17119: AND
17120: IFFALSE 17134
// Say ( Frank , D3nW-Frank-1 ) ;
17122: LD_EXP 49
17126: PPUSH
17127: LD_STRING D3nW-Frank-1
17129: PPUSH
17130: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17134: LD_EXP 36
17138: PPUSH
17139: LD_STRING D3nW-JMM-1
17141: PPUSH
17142: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17146: LD_EXP 36
17150: PPUSH
17151: LD_STRING D3nW-JMM-1a
17153: PPUSH
17154: CALL_OW 88
// t := 0 0$00 ;
17158: LD_ADDR_VAR 0 3
17162: PUSH
17163: LD_INT 0
17165: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17166: LD_INT 35
17168: PPUSH
17169: CALL_OW 67
// t := t + 0 0$1 ;
17173: LD_ADDR_VAR 0 3
17177: PUSH
17178: LD_VAR 0 3
17182: PUSH
17183: LD_INT 35
17185: PLUS
17186: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17187: LD_INT 59
17189: PPUSH
17190: LD_INT 112
17192: PPUSH
17193: CALL_OW 428
17197: PUSH
17198: LD_VAR 0 3
17202: PUSH
17203: LD_INT 2100
17205: GREATER
17206: OR
17207: IFFALSE 17166
// activeAttacks := true ;
17209: LD_ADDR_EXP 16
17213: PUSH
17214: LD_INT 1
17216: ST_TO_ADDR
// end ;
17217: LD_VAR 0 1
17221: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17222: LD_INT 0
17224: PPUSH
// case question of 1 :
17225: LD_VAR 0 1
17229: PUSH
17230: LD_INT 1
17232: DOUBLE
17233: EQUAL
17234: IFTRUE 17238
17236: GO 17289
17238: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17239: LD_EXP 36
17243: PPUSH
17244: LD_STRING D2Mot-JMM-1
17246: PPUSH
17247: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17251: LD_EXP 55
17255: PPUSH
17256: LD_STRING D2Mot-Pow-1
17258: PPUSH
17259: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17263: LD_EXP 36
17267: PPUSH
17268: LD_STRING D2Mot-JMM-2
17270: PPUSH
17271: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17275: LD_EXP 55
17279: PPUSH
17280: LD_STRING D2Mot-Pow-2
17282: PPUSH
17283: CALL_OW 88
// end ; 2 :
17287: GO 17632
17289: LD_INT 2
17291: DOUBLE
17292: EQUAL
17293: IFTRUE 17297
17295: GO 17373
17297: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17298: LD_EXP 36
17302: PPUSH
17303: LD_STRING D2Rus-JMM-1
17305: PPUSH
17306: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17310: LD_EXP 55
17314: PPUSH
17315: LD_STRING D2Rus-Pow-1
17317: PPUSH
17318: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17322: LD_EXP 36
17326: PPUSH
17327: LD_STRING D2Rus-JMM-2
17329: PPUSH
17330: CALL_OW 88
// if not ( 3 in list_of_q ) then
17334: LD_INT 3
17336: PUSH
17337: LD_VAR 0 2
17341: IN
17342: NOT
17343: IFFALSE 17359
// Say ( Powell , D2Rus-Pow-2 ) else
17345: LD_EXP 55
17349: PPUSH
17350: LD_STRING D2Rus-Pow-2
17352: PPUSH
17353: CALL_OW 88
17357: GO 17371
// Say ( Powell , D2Rus-Pow-2a ) ;
17359: LD_EXP 55
17363: PPUSH
17364: LD_STRING D2Rus-Pow-2a
17366: PPUSH
17367: CALL_OW 88
// end ; 3 :
17371: GO 17632
17373: LD_INT 3
17375: DOUBLE
17376: EQUAL
17377: IFTRUE 17381
17379: GO 17466
17381: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17382: LD_EXP 36
17386: PPUSH
17387: LD_STRING D2Leg-JMM-1
17389: PPUSH
17390: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17394: LD_EXP 55
17398: PPUSH
17399: LD_STRING D2Leg-Pow-1
17401: PPUSH
17402: CALL_OW 88
// if 2 in list_of_q then
17406: LD_INT 2
17408: PUSH
17409: LD_VAR 0 2
17413: IN
17414: IFFALSE 17440
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17416: LD_EXP 36
17420: PPUSH
17421: LD_STRING D2Leg-JMM-2
17423: PPUSH
17424: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17428: LD_EXP 55
17432: PPUSH
17433: LD_STRING D2Leg-Pow-2
17435: PPUSH
17436: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17440: LD_EXP 36
17444: PPUSH
17445: LD_STRING D2Leg-JMM-3
17447: PPUSH
17448: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17452: LD_EXP 55
17456: PPUSH
17457: LD_STRING D2Leg-Pow-3
17459: PPUSH
17460: CALL_OW 88
// end ; 4 :
17464: GO 17632
17466: LD_INT 4
17468: DOUBLE
17469: EQUAL
17470: IFTRUE 17474
17472: GO 17549
17474: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17475: LD_EXP 36
17479: PPUSH
17480: LD_STRING D2Ar-JMM-1
17482: PPUSH
17483: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17487: LD_EXP 55
17491: PPUSH
17492: LD_STRING D2Ar-Pow-1
17494: PPUSH
17495: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17499: LD_EXP 36
17503: PPUSH
17504: LD_STRING D2Ar-JMM-2
17506: PPUSH
17507: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17511: LD_EXP 55
17515: PPUSH
17516: LD_STRING D2Ar-Pow-2
17518: PPUSH
17519: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17523: LD_EXP 36
17527: PPUSH
17528: LD_STRING D2Ar-JMM-3
17530: PPUSH
17531: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17535: LD_EXP 55
17539: PPUSH
17540: LD_STRING D2Ar-Pow-3
17542: PPUSH
17543: CALL_OW 88
// end ; 5 :
17547: GO 17632
17549: LD_INT 5
17551: DOUBLE
17552: EQUAL
17553: IFTRUE 17557
17555: GO 17572
17557: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17558: LD_EXP 36
17562: PPUSH
17563: LD_STRING D2Conf-JMM-1
17565: PPUSH
17566: CALL_OW 88
17570: GO 17632
17572: LD_INT 6
17574: DOUBLE
17575: EQUAL
17576: IFTRUE 17580
17578: GO 17631
17580: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17581: LD_EXP 36
17585: PPUSH
17586: LD_STRING D2Com-JMM-1
17588: PPUSH
17589: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17593: LD_EXP 55
17597: PPUSH
17598: LD_STRING D2Com-Pow-1
17600: PPUSH
17601: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17605: LD_EXP 36
17609: PPUSH
17610: LD_STRING D2Com-JMM-2
17612: PPUSH
17613: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17617: LD_EXP 55
17621: PPUSH
17622: LD_STRING D2Com-Pow-2
17624: PPUSH
17625: CALL_OW 88
// end ; end ;
17629: GO 17632
17631: POP
// end ;
17632: LD_VAR 0 3
17636: RET
// every 0 0$5 trigger missionStart do var tmp ;
17637: LD_EXP 13
17641: IFFALSE 17924
17643: GO 17645
17645: DISABLE
17646: LD_INT 0
17648: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17649: LD_INT 35
17651: PPUSH
17652: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17656: LD_INT 14
17658: PPUSH
17659: LD_INT 22
17661: PUSH
17662: LD_INT 1
17664: PUSH
17665: EMPTY
17666: LIST
17667: LIST
17668: PPUSH
17669: CALL_OW 70
17673: PUSH
17674: LD_EXP 15
17678: PUSH
17679: LD_INT 2
17681: PUSH
17682: LD_INT 3
17684: PUSH
17685: LD_INT 4
17687: PUSH
17688: LD_INT 5
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: LIST
17695: LIST
17696: IN
17697: AND
17698: IFFALSE 17914
// begin powellAnger := powellAnger + 1 ;
17700: LD_ADDR_EXP 17
17704: PUSH
17705: LD_EXP 17
17709: PUSH
17710: LD_INT 1
17712: PLUS
17713: ST_TO_ADDR
// Video ( true ) ;
17714: LD_INT 1
17716: PPUSH
17717: CALL 103852 0 1
// CenterNowOnUnits ( tmp ) ;
17721: LD_VAR 0 1
17725: PPUSH
17726: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17730: LD_INT 14
17732: PPUSH
17733: LD_INT 22
17735: PUSH
17736: LD_INT 1
17738: PUSH
17739: EMPTY
17740: LIST
17741: LIST
17742: PPUSH
17743: CALL_OW 70
17747: PPUSH
17748: LD_INT 86
17750: PPUSH
17751: LD_INT 133
17753: PPUSH
17754: CALL_OW 111
// async ;
17758: ASYNC
// case powellAnger of 1 :
17759: LD_EXP 17
17763: PUSH
17764: LD_INT 1
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17787
17772: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17773: LD_EXP 55
17777: PPUSH
17778: LD_STRING DBack1-Pow-1
17780: PPUSH
17781: CALL_OW 88
17785: GO 17834
17787: LD_INT 2
17789: DOUBLE
17790: EQUAL
17791: IFTRUE 17795
17793: GO 17810
17795: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17796: LD_EXP 55
17800: PPUSH
17801: LD_STRING DBack2-Pow-1
17803: PPUSH
17804: CALL_OW 88
17808: GO 17834
17810: LD_INT 3
17812: DOUBLE
17813: EQUAL
17814: IFTRUE 17818
17816: GO 17833
17818: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17819: LD_EXP 55
17823: PPUSH
17824: LD_STRING DBack3-Pow-1
17826: PPUSH
17827: CALL_OW 88
17831: GO 17834
17833: POP
// sync ;
17834: SYNC
// repeat wait ( 0 0$1 ) ;
17835: LD_INT 35
17837: PPUSH
17838: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17842: LD_INT 14
17844: PPUSH
17845: LD_INT 22
17847: PUSH
17848: LD_INT 1
17850: PUSH
17851: EMPTY
17852: LIST
17853: LIST
17854: PPUSH
17855: CALL_OW 70
17859: PPUSH
17860: LD_INT 86
17862: PPUSH
17863: LD_INT 133
17865: PPUSH
17866: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17870: LD_INT 14
17872: PPUSH
17873: LD_INT 22
17875: PUSH
17876: LD_INT 1
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: PPUSH
17883: CALL_OW 70
17887: NOT
17888: IFFALSE 17835
// if powellAnger >= 3 then
17890: LD_EXP 17
17894: PUSH
17895: LD_INT 3
17897: GREATEREQUAL
17898: IFFALSE 17907
// YouLost ( Dismissed ) ;
17900: LD_STRING Dismissed
17902: PPUSH
17903: CALL_OW 104
// Video ( false ) ;
17907: LD_INT 0
17909: PPUSH
17910: CALL 103852 0 1
// end ; until missionStage > 5 ;
17914: LD_EXP 15
17918: PUSH
17919: LD_INT 5
17921: GREATER
17922: IFFALSE 17649
// end ;
17924: PPOPN 1
17926: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , ru , un ;
17927: LD_EXP 13
17931: PUSH
17932: LD_INT 22
17934: PUSH
17935: LD_INT 4
17937: PUSH
17938: EMPTY
17939: LIST
17940: LIST
17941: PUSH
17942: LD_INT 21
17944: PUSH
17945: LD_INT 2
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: PPUSH
17956: CALL_OW 69
17960: PUSH
17961: LD_INT 4
17963: GREATEREQUAL
17964: AND
17965: PUSH
17966: LD_EXP 15
17970: PUSH
17971: LD_INT 2
17973: EQUAL
17974: AND
17975: IFFALSE 19596
17977: GO 17979
17979: DISABLE
17980: LD_INT 0
17982: PPUSH
17983: PPUSH
17984: PPUSH
17985: PPUSH
17986: PPUSH
17987: PPUSH
17988: PPUSH
// begin missionStage := 3 ;
17989: LD_ADDR_EXP 15
17993: PUSH
17994: LD_INT 3
17996: ST_TO_ADDR
// retreat := false ;
17997: LD_ADDR_VAR 0 4
18001: PUSH
18002: LD_INT 0
18004: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
18005: LD_ADDR_VAR 0 5
18009: PUSH
18010: LD_INT 22
18012: PUSH
18013: LD_INT 4
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: PUSH
18020: LD_INT 30
18022: PUSH
18023: LD_INT 4
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: PPUSH
18034: CALL_OW 69
18038: PUSH
18039: LD_INT 1
18041: ARRAY
18042: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18043: LD_INT 35
18045: PPUSH
18046: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18050: LD_EXP 118
18054: PUSH
18055: LD_INT 4
18057: ARRAY
18058: PUSH
18059: LD_INT 4
18061: GREATEREQUAL
18062: IFFALSE 18043
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_INT 22
18071: PUSH
18072: LD_INT 4
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: LD_INT 2
18081: PUSH
18082: LD_INT 25
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: EMPTY
18089: LIST
18090: LIST
18091: PUSH
18092: LD_INT 25
18094: PUSH
18095: LD_INT 2
18097: PUSH
18098: EMPTY
18099: LIST
18100: LIST
18101: PUSH
18102: LD_INT 25
18104: PUSH
18105: LD_INT 3
18107: PUSH
18108: EMPTY
18109: LIST
18110: LIST
18111: PUSH
18112: LD_INT 25
18114: PUSH
18115: LD_INT 4
18117: PUSH
18118: EMPTY
18119: LIST
18120: LIST
18121: PUSH
18122: LD_INT 25
18124: PUSH
18125: LD_INT 5
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: LIST
18136: LIST
18137: LIST
18138: LIST
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: PPUSH
18144: CALL_OW 69
18148: PUSH
18149: LD_EXP 55
18153: PUSH
18154: LD_EXP 56
18158: ADD
18159: DIFF
18160: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18161: LD_ADDR_VAR 0 3
18165: PUSH
18166: LD_VAR 0 2
18170: PPUSH
18171: LD_INT 26
18173: PUSH
18174: LD_INT 1
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: PPUSH
18181: CALL_OW 72
18185: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18186: LD_ADDR_VAR 0 2
18190: PUSH
18191: LD_VAR 0 2
18195: PUSH
18196: LD_VAR 0 3
18200: DIFF
18201: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18202: LD_ADDR_VAR 0 2
18206: PUSH
18207: LD_VAR 0 2
18211: PPUSH
18212: LD_INT 1
18214: PPUSH
18215: CALL 102504 0 2
18219: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18220: LD_ADDR_VAR 0 3
18224: PUSH
18225: LD_VAR 0 3
18229: PPUSH
18230: LD_INT 1
18232: PPUSH
18233: CALL 102504 0 2
18237: ST_TO_ADDR
// for i = 1 to 4 do
18238: LD_ADDR_VAR 0 1
18242: PUSH
18243: DOUBLE
18244: LD_INT 1
18246: DEC
18247: ST_TO_ADDR
18248: LD_INT 4
18250: PUSH
18251: FOR_TO
18252: IFFALSE 18418
// begin if tmp2 then
18254: LD_VAR 0 3
18258: IFFALSE 18339
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18260: LD_ADDR_EXP 18
18264: PUSH
18265: LD_EXP 18
18269: PPUSH
18270: LD_INT 1
18272: PPUSH
18273: LD_EXP 18
18277: PUSH
18278: LD_INT 1
18280: ARRAY
18281: PUSH
18282: LD_VAR 0 3
18286: PUSH
18287: LD_VAR 0 3
18291: ARRAY
18292: ADD
18293: PPUSH
18294: CALL_OW 1
18298: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18299: LD_VAR 0 3
18303: PUSH
18304: LD_VAR 0 3
18308: ARRAY
18309: PPUSH
18310: LD_INT 1
18312: PPUSH
18313: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18317: LD_ADDR_VAR 0 3
18321: PUSH
18322: LD_VAR 0 3
18326: PPUSH
18327: LD_VAR 0 3
18331: PPUSH
18332: CALL_OW 3
18336: ST_TO_ADDR
// end else
18337: GO 18416
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18339: LD_ADDR_EXP 18
18343: PUSH
18344: LD_EXP 18
18348: PPUSH
18349: LD_INT 1
18351: PPUSH
18352: LD_EXP 18
18356: PUSH
18357: LD_INT 1
18359: ARRAY
18360: PUSH
18361: LD_VAR 0 2
18365: PUSH
18366: LD_VAR 0 2
18370: ARRAY
18371: ADD
18372: PPUSH
18373: CALL_OW 1
18377: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18378: LD_VAR 0 2
18382: PUSH
18383: LD_VAR 0 2
18387: ARRAY
18388: PPUSH
18389: LD_INT 1
18391: PPUSH
18392: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18396: LD_ADDR_VAR 0 2
18400: PUSH
18401: LD_VAR 0 2
18405: PPUSH
18406: LD_VAR 0 2
18410: PPUSH
18411: CALL_OW 3
18415: ST_TO_ADDR
// end ; end ;
18416: GO 18251
18418: POP
18419: POP
// if tmp2 then
18420: LD_VAR 0 3
18424: IFFALSE 18442
// tmp := tmp union tmp2 ;
18426: LD_ADDR_VAR 0 2
18430: PUSH
18431: LD_VAR 0 2
18435: PUSH
18436: LD_VAR 0 3
18440: UNION
18441: ST_TO_ADDR
// for i = 1 to 4 do
18442: LD_ADDR_VAR 0 1
18446: PUSH
18447: DOUBLE
18448: LD_INT 1
18450: DEC
18451: ST_TO_ADDR
18452: LD_INT 4
18454: PUSH
18455: FOR_TO
18456: IFFALSE 18505
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18458: LD_ADDR_EXP 18
18462: PUSH
18463: LD_EXP 18
18467: PPUSH
18468: LD_INT 2
18470: PPUSH
18471: LD_EXP 18
18475: PUSH
18476: LD_INT 2
18478: ARRAY
18479: PUSH
18480: LD_VAR 0 2
18484: PUSH
18485: LD_VAR 0 2
18489: PUSH
18490: LD_VAR 0 1
18494: MINUS
18495: ARRAY
18496: ADD
18497: PPUSH
18498: CALL_OW 1
18502: ST_TO_ADDR
18503: GO 18455
18505: POP
18506: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18507: LD_ADDR_EXP 99
18511: PUSH
18512: LD_EXP 99
18516: PPUSH
18517: LD_INT 4
18519: PPUSH
18520: LD_EXP 99
18524: PUSH
18525: LD_INT 4
18527: ARRAY
18528: PUSH
18529: LD_EXP 18
18533: PUSH
18534: LD_INT 1
18536: ARRAY
18537: DIFF
18538: PPUSH
18539: CALL_OW 1
18543: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
18544: LD_ADDR_VAR 0 1
18548: PUSH
18549: LD_EXP 18
18553: PUSH
18554: LD_INT 1
18556: ARRAY
18557: PUSH
18558: FOR_IN
18559: IFFALSE 18662
// begin if IsInUnit ( i ) then
18561: LD_VAR 0 1
18565: PPUSH
18566: CALL_OW 310
18570: IFFALSE 18581
// ComExitBuilding ( i ) ;
18572: LD_VAR 0 1
18576: PPUSH
18577: CALL_OW 122
// if GetClass ( i ) <> 1 then
18581: LD_VAR 0 1
18585: PPUSH
18586: CALL_OW 257
18590: PUSH
18591: LD_INT 1
18593: NONEQUAL
18594: IFFALSE 18631
// begin AddComEnterUnit ( i , arm ) ;
18596: LD_VAR 0 1
18600: PPUSH
18601: LD_VAR 0 5
18605: PPUSH
18606: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18610: LD_VAR 0 1
18614: PPUSH
18615: LD_INT 1
18617: PPUSH
18618: CALL_OW 183
// AddComExitBuilding ( i ) ;
18622: LD_VAR 0 1
18626: PPUSH
18627: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18631: LD_VAR 0 1
18635: PPUSH
18636: LD_INT 60
18638: PPUSH
18639: LD_INT 94
18641: PPUSH
18642: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18646: LD_VAR 0 1
18650: PPUSH
18651: LD_EXP 55
18655: PPUSH
18656: CALL_OW 179
// end ;
18660: GO 18558
18662: POP
18663: POP
// wait ( 0 0$15 ) ;
18664: LD_INT 525
18666: PPUSH
18667: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
18671: LD_EXP 55
18675: PPUSH
18676: LD_STRING D4-Pow-1
18678: PPUSH
18679: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
18683: LD_ADDR_VAR 0 2
18687: PUSH
18688: LD_EXP 18
18692: PUSH
18693: LD_INT 1
18695: ARRAY
18696: PPUSH
18697: LD_INT 26
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: PPUSH
18707: CALL_OW 72
18711: ST_TO_ADDR
// if tmp then
18712: LD_VAR 0 2
18716: IFFALSE 18734
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
18718: LD_VAR 0 2
18722: PUSH
18723: LD_INT 1
18725: ARRAY
18726: PPUSH
18727: LD_STRING D4-Sol1-1
18729: PPUSH
18730: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
18734: LD_EXP 55
18738: PPUSH
18739: LD_STRING D4-Pow-2
18741: PPUSH
18742: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
18746: LD_ADDR_VAR 0 1
18750: PUSH
18751: DOUBLE
18752: LD_INT 1
18754: DEC
18755: ST_TO_ADDR
18756: LD_EXP 18
18760: PUSH
18761: LD_INT 1
18763: ARRAY
18764: PUSH
18765: FOR_TO
18766: IFFALSE 18859
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
18768: LD_EXP 18
18772: PUSH
18773: LD_INT 1
18775: ARRAY
18776: PUSH
18777: LD_VAR 0 1
18781: ARRAY
18782: PPUSH
18783: LD_EXP 118
18787: PUSH
18788: LD_INT 4
18790: ARRAY
18791: PUSH
18792: LD_INT 1
18794: ARRAY
18795: PPUSH
18796: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
18800: LD_ADDR_EXP 118
18804: PUSH
18805: LD_EXP 118
18809: PPUSH
18810: LD_INT 4
18812: PPUSH
18813: LD_EXP 118
18817: PUSH
18818: LD_INT 4
18820: ARRAY
18821: PPUSH
18822: LD_INT 1
18824: PPUSH
18825: CALL_OW 3
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
18835: LD_INT 8
18837: PPUSH
18838: LD_EXP 18
18842: PUSH
18843: LD_INT 1
18845: ARRAY
18846: PUSH
18847: LD_VAR 0 1
18851: ARRAY
18852: PPUSH
18853: CALL_OW 471
// end ;
18857: GO 18765
18859: POP
18860: POP
// repeat wait ( 0 0$1 ) ;
18861: LD_INT 35
18863: PPUSH
18864: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
18868: LD_EXP 18
18872: PUSH
18873: LD_INT 1
18875: ARRAY
18876: PPUSH
18877: LD_INT 55
18879: PUSH
18880: EMPTY
18881: LIST
18882: PPUSH
18883: CALL_OW 72
18887: PUSH
18888: LD_INT 4
18890: GREATEREQUAL
18891: IFFALSE 18861
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
18893: LD_EXP 18
18897: PUSH
18898: LD_INT 1
18900: ARRAY
18901: PPUSH
18902: LD_INT 69
18904: PPUSH
18905: LD_INT 94
18907: PPUSH
18908: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
18912: LD_EXP 18
18916: PUSH
18917: LD_INT 1
18919: ARRAY
18920: PPUSH
18921: LD_INT 82
18923: PPUSH
18924: LD_INT 83
18926: PPUSH
18927: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
18931: LD_EXP 18
18935: PUSH
18936: LD_INT 1
18938: ARRAY
18939: PPUSH
18940: LD_INT 77
18942: PPUSH
18943: LD_INT 69
18945: PPUSH
18946: CALL_OW 174
// repeat wait ( 3 ) ;
18950: LD_INT 3
18952: PPUSH
18953: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18957: LD_ADDR_VAR 0 1
18961: PUSH
18962: LD_EXP 18
18966: PUSH
18967: LD_INT 1
18969: ARRAY
18970: PUSH
18971: FOR_IN
18972: IFFALSE 19108
// begin if GetLives ( i ) < 990 then
18974: LD_VAR 0 1
18978: PPUSH
18979: CALL_OW 256
18983: PUSH
18984: LD_INT 990
18986: LESS
18987: IFFALSE 19001
// SetLives ( i , 1000 ) ;
18989: LD_VAR 0 1
18993: PPUSH
18994: LD_INT 1000
18996: PPUSH
18997: CALL_OW 234
// if not IsInUnit ( i ) then
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 310
19010: NOT
19011: IFFALSE 19106
// begin if not HasTask ( i ) then
19013: LD_VAR 0 1
19017: PPUSH
19018: CALL_OW 314
19022: NOT
19023: IFFALSE 19040
// ComMoveXY ( i , 64 , 93 ) ;
19025: LD_VAR 0 1
19029: PPUSH
19030: LD_INT 64
19032: PPUSH
19033: LD_INT 93
19035: PPUSH
19036: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19040: LD_VAR 0 4
19044: NOT
19045: PUSH
19046: LD_VAR 0 1
19050: PPUSH
19051: CALL_OW 258
19055: PUSH
19056: LD_INT 1
19058: EQUAL
19059: AND
19060: IFFALSE 19106
// begin retreat := true ;
19062: LD_ADDR_VAR 0 4
19066: PUSH
19067: LD_INT 1
19069: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19070: LD_VAR 0 1
19074: PPUSH
19075: LD_INT 2
19077: PPUSH
19078: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19082: LD_VAR 0 1
19086: PPUSH
19087: LD_STRING D4a-Sol1-1
19089: PPUSH
19090: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19094: LD_EXP 55
19098: PPUSH
19099: LD_STRING D4a-Pow-1
19101: PPUSH
19102: CALL_OW 88
// end ; end ; end ;
19106: GO 18971
19108: POP
19109: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19110: LD_EXP 18
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: LD_INT 95
19121: PUSH
19122: LD_INT 9
19124: PUSH
19125: EMPTY
19126: LIST
19127: LIST
19128: PUSH
19129: LD_INT 3
19131: PUSH
19132: LD_INT 55
19134: PUSH
19135: EMPTY
19136: LIST
19137: PUSH
19138: EMPTY
19139: LIST
19140: LIST
19141: PUSH
19142: EMPTY
19143: LIST
19144: LIST
19145: PPUSH
19146: CALL_OW 72
19150: PUSH
19151: LD_INT 4
19153: GREATEREQUAL
19154: IFFALSE 18950
// for i in powellSquadAttack [ 1 ] do
19156: LD_ADDR_VAR 0 1
19160: PUSH
19161: LD_EXP 18
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PUSH
19170: FOR_IN
19171: IFFALSE 19307
// begin if GetTag ( i ) = 2 then
19173: LD_VAR 0 1
19177: PPUSH
19178: CALL_OW 110
19182: PUSH
19183: LD_INT 2
19185: EQUAL
19186: IFFALSE 19248
// begin ComMoveXY ( i , 60 , 94 ) ;
19188: LD_VAR 0 1
19192: PPUSH
19193: LD_INT 60
19195: PPUSH
19196: LD_INT 94
19198: PPUSH
19199: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19203: LD_VAR 0 1
19207: PPUSH
19208: LD_EXP 55
19212: PPUSH
19213: CALL_OW 179
// wait ( 0 0$3 ) ;
19217: LD_INT 105
19219: PPUSH
19220: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19224: LD_VAR 0 1
19228: PPUSH
19229: LD_STRING D4a-Sol1-2
19231: PPUSH
19232: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19236: LD_EXP 55
19240: PPUSH
19241: LD_STRING D4a-Pow-2
19243: PPUSH
19244: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19248: LD_VAR 0 1
19252: PPUSH
19253: LD_INT 0
19255: PPUSH
19256: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19260: LD_ADDR_EXP 99
19264: PUSH
19265: LD_EXP 99
19269: PPUSH
19270: LD_INT 4
19272: PPUSH
19273: LD_EXP 99
19277: PUSH
19278: LD_INT 4
19280: ARRAY
19281: PUSH
19282: LD_VAR 0 1
19286: UNION
19287: PPUSH
19288: CALL_OW 1
19292: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19293: LD_INT 8
19295: PPUSH
19296: LD_VAR 0 1
19300: PPUSH
19301: CALL_OW 472
// end ;
19305: GO 19170
19307: POP
19308: POP
// wait ( 4 4$00 ) ;
19309: LD_INT 8400
19311: PPUSH
19312: CALL_OW 67
// uc_side := 6 ;
19316: LD_ADDR_OWVAR 20
19320: PUSH
19321: LD_INT 6
19323: ST_TO_ADDR
// uc_nation := 3 ;
19324: LD_ADDR_OWVAR 21
19328: PUSH
19329: LD_INT 3
19331: ST_TO_ADDR
// ru := [ ] ;
19332: LD_ADDR_VAR 0 6
19336: PUSH
19337: EMPTY
19338: ST_TO_ADDR
// for i = 1 to 4 do
19339: LD_ADDR_VAR 0 1
19343: PUSH
19344: DOUBLE
19345: LD_INT 1
19347: DEC
19348: ST_TO_ADDR
19349: LD_INT 4
19351: PUSH
19352: FOR_TO
19353: IFFALSE 19454
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19355: LD_INT 22
19357: PPUSH
19358: LD_INT 1
19360: PPUSH
19361: LD_INT 3
19363: PPUSH
19364: LD_INT 43
19366: PUSH
19367: LD_INT 44
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: PUSH
19374: LD_INT 1
19376: PPUSH
19377: LD_INT 2
19379: PPUSH
19380: CALL_OW 12
19384: ARRAY
19385: PPUSH
19386: LD_INT 89
19388: PPUSH
19389: CALL 68197 0 5
// un := CreateVehicle ;
19393: LD_ADDR_VAR 0 7
19397: PUSH
19398: CALL_OW 45
19402: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19403: LD_VAR 0 7
19407: PPUSH
19408: LD_INT 4
19410: PPUSH
19411: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19415: LD_VAR 0 7
19419: PPUSH
19420: LD_INT 136
19422: PPUSH
19423: LD_INT 90
19425: PPUSH
19426: LD_INT 8
19428: PPUSH
19429: LD_INT 0
19431: PPUSH
19432: CALL_OW 50
// ru := ru ^ un ;
19436: LD_ADDR_VAR 0 6
19440: PUSH
19441: LD_VAR 0 6
19445: PUSH
19446: LD_VAR 0 7
19450: ADD
19451: ST_TO_ADDR
// end ;
19452: GO 19352
19454: POP
19455: POP
// if ru then
19456: LD_VAR 0 6
19460: IFFALSE 19477
// ComAgressiveMove ( ru , 80 , 92 ) ;
19462: LD_VAR 0 6
19466: PPUSH
19467: LD_INT 80
19469: PPUSH
19470: LD_INT 92
19472: PPUSH
19473: CALL_OW 114
// wait ( 8 8$00 ) ;
19477: LD_INT 16800
19479: PPUSH
19480: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19484: LD_INT 4
19486: PPUSH
19487: LD_INT 3
19489: PUSH
19490: LD_INT 1
19492: PUSH
19493: LD_INT 1
19495: PUSH
19496: LD_INT 5
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: PUSH
19505: LD_INT 4
19507: PUSH
19508: LD_INT 1
19510: PUSH
19511: LD_INT 1
19513: PUSH
19514: LD_INT 6
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: PUSH
19523: LD_INT 4
19525: PUSH
19526: LD_INT 1
19528: PUSH
19529: LD_INT 1
19531: PUSH
19532: LD_INT 7
19534: PUSH
19535: EMPTY
19536: LIST
19537: LIST
19538: LIST
19539: LIST
19540: PUSH
19541: LD_INT 3
19543: PUSH
19544: LD_INT 1
19546: PUSH
19547: LD_INT 1
19549: PUSH
19550: LD_INT 7
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: LIST
19557: LIST
19558: PUSH
19559: LD_INT 3
19561: PUSH
19562: LD_INT 1
19564: PUSH
19565: LD_INT 1
19567: PUSH
19568: LD_INT 5
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: PPUSH
19584: CALL 55584 0 2
// missionStage := 4 ;
19588: LD_ADDR_EXP 15
19592: PUSH
19593: LD_INT 4
19595: ST_TO_ADDR
// end ;
19596: PPOPN 7
19598: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19599: LD_EXP 15
19603: PUSH
19604: LD_INT 4
19606: EQUAL
19607: PUSH
19608: LD_INT 22
19610: PUSH
19611: LD_INT 4
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: LD_INT 21
19620: PUSH
19621: LD_INT 2
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: EMPTY
19629: LIST
19630: LIST
19631: PPUSH
19632: CALL_OW 69
19636: PUSH
19637: LD_INT 5
19639: GREATEREQUAL
19640: AND
19641: IFFALSE 23702
19643: GO 19645
19645: DISABLE
19646: LD_INT 0
19648: PPUSH
19649: PPUSH
19650: PPUSH
19651: PPUSH
19652: PPUSH
19653: PPUSH
19654: PPUSH
19655: PPUSH
19656: PPUSH
19657: PPUSH
19658: PPUSH
19659: PPUSH
19660: PPUSH
// begin missionStage := 5 ;
19661: LD_ADDR_EXP 15
19665: PUSH
19666: LD_INT 5
19668: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19669: LD_ADDR_VAR 0 10
19673: PUSH
19674: LD_INT 22
19676: PUSH
19677: LD_INT 4
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: LD_INT 2
19686: PUSH
19687: LD_INT 30
19689: PUSH
19690: LD_INT 4
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: LD_INT 30
19699: PUSH
19700: LD_INT 5
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: LIST
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: PPUSH
19716: CALL_OW 69
19720: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
19721: LD_ADDR_VAR 0 6
19725: PUSH
19726: LD_INT 22
19728: PUSH
19729: LD_INT 4
19731: PUSH
19732: EMPTY
19733: LIST
19734: LIST
19735: PUSH
19736: LD_INT 21
19738: PUSH
19739: LD_INT 1
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 3
19748: PUSH
19749: LD_INT 25
19751: PUSH
19752: LD_INT 16
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 3
19765: PUSH
19766: LD_INT 25
19768: PUSH
19769: LD_INT 12
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: PUSH
19776: EMPTY
19777: LIST
19778: LIST
19779: PUSH
19780: EMPTY
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: PPUSH
19786: CALL_OW 69
19790: PUSH
19791: LD_EXP 55
19795: DIFF
19796: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
19797: LD_ADDR_VAR 0 9
19801: PUSH
19802: LD_INT 22
19804: PUSH
19805: LD_INT 4
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: LD_INT 30
19814: PUSH
19815: LD_INT 3
19817: PUSH
19818: EMPTY
19819: LIST
19820: LIST
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: PPUSH
19826: CALL_OW 69
19830: PUSH
19831: LD_INT 1
19833: ARRAY
19834: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19835: LD_INT 35
19837: PPUSH
19838: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
19842: LD_EXP 118
19846: PUSH
19847: LD_INT 4
19849: ARRAY
19850: PUSH
19851: LD_INT 5
19853: GREATEREQUAL
19854: IFFALSE 19835
// powellAllowRetreat := false ;
19856: LD_ADDR_EXP 19
19860: PUSH
19861: LD_INT 0
19863: ST_TO_ADDR
// wait ( 0 0$20 ) ;
19864: LD_INT 700
19866: PPUSH
19867: CALL_OW 67
// activeAttacks := false ;
19871: LD_ADDR_EXP 16
19875: PUSH
19876: LD_INT 0
19878: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19879: LD_INT 35
19881: PPUSH
19882: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
19886: LD_INT 22
19888: PUSH
19889: LD_INT 6
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: PPUSH
19896: CALL_OW 69
19900: PUSH
19901: LD_INT 0
19903: EQUAL
19904: IFFALSE 19879
// tmp := mc_vehicles [ 4 ] ;
19906: LD_ADDR_VAR 0 3
19910: PUSH
19911: LD_EXP 118
19915: PUSH
19916: LD_INT 4
19918: ARRAY
19919: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
19920: LD_ADDR_VAR 0 1
19924: PUSH
19925: DOUBLE
19926: LD_INT 1
19928: DEC
19929: ST_TO_ADDR
19930: LD_EXP 18
19934: PUSH
19935: FOR_TO
19936: IFFALSE 20197
// begin for j in powellSquadAttack [ i ] do
19938: LD_ADDR_VAR 0 2
19942: PUSH
19943: LD_EXP 18
19947: PUSH
19948: LD_VAR 0 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20193
// begin forces := forces diff j ;
19957: LD_ADDR_VAR 0 6
19961: PUSH
19962: LD_VAR 0 6
19966: PUSH
19967: LD_VAR 0 2
19971: DIFF
19972: ST_TO_ADDR
// SetTag ( j , 1 ) ;
19973: LD_VAR 0 2
19977: PPUSH
19978: LD_INT 1
19980: PPUSH
19981: CALL_OW 109
// wait ( 0 0$2 ) ;
19985: LD_INT 70
19987: PPUSH
19988: CALL_OW 67
// if IsInUnit ( j ) then
19992: LD_VAR 0 2
19996: PPUSH
19997: CALL_OW 310
20001: IFFALSE 20012
// ComExitBuilding ( j ) ;
20003: LD_VAR 0 2
20007: PPUSH
20008: CALL_OW 122
// if GetClass ( j ) <> 1 then
20012: LD_VAR 0 2
20016: PPUSH
20017: CALL_OW 257
20021: PUSH
20022: LD_INT 1
20024: NONEQUAL
20025: IFFALSE 20105
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20027: LD_VAR 0 10
20031: PUSH
20032: LD_INT 1
20034: ARRAY
20035: PPUSH
20036: CALL_OW 313
20040: PUSH
20041: LD_INT 5
20043: GREATEREQUAL
20044: IFFALSE 20066
// AddComEnterUnit ( j , arm [ 2 ] ) else
20046: LD_VAR 0 2
20050: PPUSH
20051: LD_VAR 0 10
20055: PUSH
20056: LD_INT 2
20058: ARRAY
20059: PPUSH
20060: CALL_OW 180
20064: GO 20084
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20066: LD_VAR 0 2
20070: PPUSH
20071: LD_VAR 0 10
20075: PUSH
20076: LD_INT 1
20078: ARRAY
20079: PPUSH
20080: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20084: LD_VAR 0 2
20088: PPUSH
20089: LD_INT 1
20091: PPUSH
20092: CALL_OW 183
// AddComExitBuilding ( j ) ;
20096: LD_VAR 0 2
20100: PPUSH
20101: CALL_OW 182
// end ; if i = 2 then
20105: LD_VAR 0 1
20109: PUSH
20110: LD_INT 2
20112: EQUAL
20113: IFFALSE 20130
// AddComMoveXY ( j , 61 , 93 ) ;
20115: LD_VAR 0 2
20119: PPUSH
20120: LD_INT 61
20122: PPUSH
20123: LD_INT 93
20125: PPUSH
20126: CALL_OW 171
// if i = 1 then
20130: LD_VAR 0 1
20134: PUSH
20135: LD_INT 1
20137: EQUAL
20138: IFFALSE 20191
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20140: LD_VAR 0 2
20144: PPUSH
20145: LD_VAR 0 3
20149: PUSH
20150: LD_INT 1
20152: ARRAY
20153: PPUSH
20154: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20158: LD_ADDR_VAR 0 3
20162: PUSH
20163: LD_VAR 0 3
20167: PPUSH
20168: LD_INT 1
20170: PPUSH
20171: CALL_OW 3
20175: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20176: LD_VAR 0 2
20180: PPUSH
20181: LD_INT 69
20183: PPUSH
20184: LD_INT 94
20186: PPUSH
20187: CALL_OW 171
// end ; end ;
20191: GO 19954
20193: POP
20194: POP
// end ;
20195: GO 19935
20197: POP
20198: POP
// wait ( 0 0$45 ) ;
20199: LD_INT 1575
20201: PPUSH
20202: CALL_OW 67
// MC_Kill ( 4 ) ;
20206: LD_INT 4
20208: PPUSH
20209: CALL 33553 0 1
// tmp := UnitsInside ( fac ) ;
20213: LD_ADDR_VAR 0 3
20217: PUSH
20218: LD_VAR 0 9
20222: PPUSH
20223: CALL_OW 313
20227: ST_TO_ADDR
// if tmp then
20228: LD_VAR 0 3
20232: IFFALSE 20353
// for i in tmp do
20234: LD_ADDR_VAR 0 1
20238: PUSH
20239: LD_VAR 0 3
20243: PUSH
20244: FOR_IN
20245: IFFALSE 20351
// begin ComExitBuilding ( i ) ;
20247: LD_VAR 0 1
20251: PPUSH
20252: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20256: LD_VAR 0 10
20260: PUSH
20261: LD_INT 2
20263: ARRAY
20264: PPUSH
20265: CALL_OW 313
20269: PUSH
20270: LD_INT 6
20272: LESS
20273: IFFALSE 20295
// AddComEnterUnit ( i , arm [ 2 ] ) else
20275: LD_VAR 0 1
20279: PPUSH
20280: LD_VAR 0 10
20284: PUSH
20285: LD_INT 2
20287: ARRAY
20288: PPUSH
20289: CALL_OW 180
20293: GO 20349
// if UnitsInside ( arm [ 1 ] ) < 6 then
20295: LD_VAR 0 10
20299: PUSH
20300: LD_INT 1
20302: ARRAY
20303: PPUSH
20304: CALL_OW 313
20308: PUSH
20309: LD_INT 6
20311: LESS
20312: IFFALSE 20334
// AddComEnterUnit ( i , arm [ 1 ] ) else
20314: LD_VAR 0 1
20318: PPUSH
20319: LD_VAR 0 10
20323: PUSH
20324: LD_INT 1
20326: ARRAY
20327: PPUSH
20328: CALL_OW 180
20332: GO 20349
// AddComMoveXY ( i , 37 , 68 ) ;
20334: LD_VAR 0 1
20338: PPUSH
20339: LD_INT 37
20341: PPUSH
20342: LD_INT 68
20344: PPUSH
20345: CALL_OW 171
// end ;
20349: GO 20244
20351: POP
20352: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20353: LD_ADDR_VAR 0 11
20357: PUSH
20358: LD_VAR 0 6
20362: PPUSH
20363: LD_INT 26
20365: PUSH
20366: LD_INT 1
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: PPUSH
20373: CALL_OW 72
20377: PUSH
20378: LD_EXP 56
20382: DIFF
20383: ST_TO_ADDR
// if not speaker then
20384: LD_VAR 0 11
20388: NOT
20389: IFFALSE 20416
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20391: LD_ADDR_VAR 0 11
20395: PUSH
20396: LD_VAR 0 6
20400: PPUSH
20401: LD_INT 26
20403: PUSH
20404: LD_INT 1
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: PPUSH
20411: CALL_OW 72
20415: ST_TO_ADDR
// if speaker then
20416: LD_VAR 0 11
20420: IFFALSE 20436
// speaker := speaker [ 1 ] ;
20422: LD_ADDR_VAR 0 11
20426: PUSH
20427: LD_VAR 0 11
20431: PUSH
20432: LD_INT 1
20434: ARRAY
20435: ST_TO_ADDR
// Video ( true ) ;
20436: LD_INT 1
20438: PPUSH
20439: CALL 103852 0 1
// CenterNowOnUnits ( Powell ) ;
20443: LD_EXP 55
20447: PPUSH
20448: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20452: LD_ADDR_VAR 0 3
20456: PUSH
20457: LD_VAR 0 6
20461: PPUSH
20462: LD_INT 3
20464: PUSH
20465: LD_INT 25
20467: PUSH
20468: LD_INT 1
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PUSH
20475: EMPTY
20476: LIST
20477: LIST
20478: PPUSH
20479: CALL_OW 72
20483: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20484: LD_ADDR_VAR 0 12
20488: PUSH
20489: LD_INT 22
20491: PUSH
20492: LD_INT 4
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 32
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: PUSH
20509: LD_INT 58
20511: PUSH
20512: EMPTY
20513: LIST
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: LIST
20519: PPUSH
20520: CALL_OW 69
20524: ST_TO_ADDR
// for i = 1 to 6 do
20525: LD_ADDR_VAR 0 1
20529: PUSH
20530: DOUBLE
20531: LD_INT 1
20533: DEC
20534: ST_TO_ADDR
20535: LD_INT 6
20537: PUSH
20538: FOR_TO
20539: IFFALSE 20680
// begin if IsInUnit ( tmp [ i ] ) then
20541: LD_VAR 0 3
20545: PUSH
20546: LD_VAR 0 1
20550: ARRAY
20551: PPUSH
20552: CALL_OW 310
20556: IFFALSE 20573
// ComExitBuilding ( tmp [ i ] ) ;
20558: LD_VAR 0 3
20562: PUSH
20563: LD_VAR 0 1
20567: ARRAY
20568: PPUSH
20569: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20573: LD_VAR 0 3
20577: PUSH
20578: LD_VAR 0 1
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 10
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: PPUSH
20593: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20597: LD_VAR 0 3
20601: PUSH
20602: LD_VAR 0 1
20606: ARRAY
20607: PPUSH
20608: LD_INT 1
20610: PPUSH
20611: CALL_OW 183
// if emp_towers then
20615: LD_VAR 0 12
20619: IFFALSE 20678
// begin AddComExitBuilding ( tmp [ i ] ) ;
20621: LD_VAR 0 3
20625: PUSH
20626: LD_VAR 0 1
20630: ARRAY
20631: PPUSH
20632: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20636: LD_VAR 0 3
20640: PUSH
20641: LD_VAR 0 1
20645: ARRAY
20646: PPUSH
20647: LD_VAR 0 12
20651: PUSH
20652: LD_INT 1
20654: ARRAY
20655: PPUSH
20656: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
20660: LD_ADDR_VAR 0 12
20664: PUSH
20665: LD_VAR 0 12
20669: PPUSH
20670: LD_INT 1
20672: PPUSH
20673: CALL_OW 3
20677: ST_TO_ADDR
// end ; end ;
20678: GO 20538
20680: POP
20681: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
20682: LD_ADDR_VAR 0 3
20686: PUSH
20687: LD_EXP 18
20691: PUSH
20692: LD_INT 1
20694: ARRAY
20695: PUSH
20696: LD_EXP 18
20700: PUSH
20701: LD_INT 2
20703: ARRAY
20704: ADD
20705: PPUSH
20706: LD_INT 26
20708: PUSH
20709: LD_INT 1
20711: PUSH
20712: EMPTY
20713: LIST
20714: LIST
20715: PPUSH
20716: CALL_OW 72
20720: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
20721: LD_ADDR_VAR 0 1
20725: PUSH
20726: LD_EXP 18
20730: PUSH
20731: LD_INT 2
20733: ARRAY
20734: PUSH
20735: FOR_IN
20736: IFFALSE 20754
// ComTurnUnit ( i , Powell ) ;
20738: LD_VAR 0 1
20742: PPUSH
20743: LD_EXP 55
20747: PPUSH
20748: CALL_OW 119
20752: GO 20735
20754: POP
20755: POP
// Say ( Powell , D5-Pow-1 ) ;
20756: LD_EXP 55
20760: PPUSH
20761: LD_STRING D5-Pow-1
20763: PPUSH
20764: CALL_OW 88
// if tmp then
20768: LD_VAR 0 3
20772: IFFALSE 20790
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
20774: LD_VAR 0 3
20778: PUSH
20779: LD_INT 1
20781: ARRAY
20782: PPUSH
20783: LD_STRING D5-Sol2-1
20785: PPUSH
20786: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
20790: LD_EXP 55
20794: PPUSH
20795: LD_STRING D5-Pow-2
20797: PPUSH
20798: CALL_OW 88
// if tmp > 1 then
20802: LD_VAR 0 3
20806: PUSH
20807: LD_INT 1
20809: GREATER
20810: IFFALSE 20828
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
20812: LD_VAR 0 3
20816: PUSH
20817: LD_INT 2
20819: ARRAY
20820: PPUSH
20821: LD_STRING D5-Sol2-2
20823: PPUSH
20824: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
20828: LD_EXP 55
20832: PPUSH
20833: LD_STRING D5-Pow-3
20835: PPUSH
20836: CALL_OW 88
// wait ( 0 0$1 ) ;
20840: LD_INT 35
20842: PPUSH
20843: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
20847: LD_ADDR_VAR 0 3
20851: PUSH
20852: LD_EXP 18
20856: PUSH
20857: LD_INT 1
20859: ARRAY
20860: PUSH
20861: LD_EXP 18
20865: PUSH
20866: LD_INT 2
20868: ARRAY
20869: UNION
20870: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
20871: LD_VAR 0 3
20875: PPUSH
20876: LD_INT 80
20878: PPUSH
20879: LD_INT 67
20881: PPUSH
20882: CALL_OW 114
// wait ( 0 0$2 ) ;
20886: LD_INT 70
20888: PPUSH
20889: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
20893: LD_INT 79
20895: PPUSH
20896: LD_INT 72
20898: PPUSH
20899: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
20903: LD_INT 35
20905: PPUSH
20906: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
20910: LD_VAR 0 3
20914: PPUSH
20915: LD_INT 3
20917: PUSH
20918: LD_INT 24
20920: PUSH
20921: LD_INT 1000
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: PPUSH
20932: CALL_OW 72
20936: IFFALSE 20903
// Say ( Powell , D5a-Pow-1 ) ;
20938: LD_EXP 55
20942: PPUSH
20943: LD_STRING D5a-Pow-1
20945: PPUSH
20946: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
20950: LD_EXP 55
20954: PPUSH
20955: LD_STRING D5a-Pow-1a
20957: PPUSH
20958: CALL_OW 88
// wait ( 0 0$0.3 ) ;
20962: LD_INT 10
20964: PPUSH
20965: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
20969: LD_EXP 55
20973: PPUSH
20974: LD_STRING D5a-Pow-1b
20976: PPUSH
20977: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
20981: LD_EXP 55
20985: PPUSH
20986: LD_STRING D5a-Pow-1c
20988: PPUSH
20989: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
20993: LD_EXP 55
20997: PPUSH
20998: LD_STRING D5a-Pow-1d
21000: PPUSH
21001: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21005: LD_INT 35
21007: PPUSH
21008: CALL_OW 67
// if not HasTask ( tmp ) then
21012: LD_VAR 0 3
21016: PPUSH
21017: CALL_OW 314
21021: NOT
21022: IFFALSE 21039
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21024: LD_VAR 0 3
21028: PPUSH
21029: LD_INT 80
21031: PPUSH
21032: LD_INT 67
21034: PPUSH
21035: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21039: LD_VAR 0 3
21043: PPUSH
21044: LD_INT 24
21046: PUSH
21047: LD_INT 1
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: PPUSH
21054: CALL_OW 72
21058: NOT
21059: IFFALSE 21005
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21061: LD_ADDR_VAR 0 3
21065: PUSH
21066: LD_INT 22
21068: PUSH
21069: LD_INT 4
21071: PUSH
21072: EMPTY
21073: LIST
21074: LIST
21075: PUSH
21076: LD_INT 92
21078: PUSH
21079: LD_INT 60
21081: PUSH
21082: LD_INT 93
21084: PUSH
21085: LD_INT 10
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: LIST
21092: LIST
21093: PUSH
21094: LD_INT 3
21096: PUSH
21097: LD_INT 54
21099: PUSH
21100: EMPTY
21101: LIST
21102: PUSH
21103: EMPTY
21104: LIST
21105: LIST
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: LIST
21111: PPUSH
21112: CALL_OW 69
21116: PUSH
21117: LD_EXP 55
21121: DIFF
21122: ST_TO_ADDR
// if tmp then
21123: LD_VAR 0 3
21127: IFFALSE 21161
// for i in tmp do
21129: LD_ADDR_VAR 0 1
21133: PUSH
21134: LD_VAR 0 3
21138: PUSH
21139: FOR_IN
21140: IFFALSE 21159
// ComMoveXY ( i , 36 , 67 ) ;
21142: LD_VAR 0 1
21146: PPUSH
21147: LD_INT 36
21149: PPUSH
21150: LD_INT 67
21152: PPUSH
21153: CALL_OW 111
21157: GO 21139
21159: POP
21160: POP
// wait ( 0 0$3 ) ;
21161: LD_INT 105
21163: PPUSH
21164: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21168: LD_VAR 0 11
21172: PPUSH
21173: LD_STRING D6-Sol3-1
21175: PPUSH
21176: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21180: LD_EXP 55
21184: PPUSH
21185: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21189: LD_EXP 55
21193: PPUSH
21194: LD_STRING D6-Pow-1
21196: PPUSH
21197: CALL_OW 88
// tmp := [ ] ;
21201: LD_ADDR_VAR 0 3
21205: PUSH
21206: EMPTY
21207: ST_TO_ADDR
// for i = 1 to 2 do
21208: LD_ADDR_VAR 0 1
21212: PUSH
21213: DOUBLE
21214: LD_INT 1
21216: DEC
21217: ST_TO_ADDR
21218: LD_INT 2
21220: PUSH
21221: FOR_TO
21222: IFFALSE 21329
// begin uc_side := 8 ;
21224: LD_ADDR_OWVAR 20
21228: PUSH
21229: LD_INT 8
21231: ST_TO_ADDR
// uc_nation := 2 ;
21232: LD_ADDR_OWVAR 21
21236: PUSH
21237: LD_INT 2
21239: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21240: LD_INT 14
21242: PPUSH
21243: LD_INT 3
21245: PPUSH
21246: LD_INT 2
21248: PPUSH
21249: LD_INT 29
21251: PPUSH
21252: LD_INT 100
21254: PPUSH
21255: CALL 68197 0 5
// veh := CreateVehicle ;
21259: LD_ADDR_VAR 0 13
21263: PUSH
21264: CALL_OW 45
21268: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21269: LD_VAR 0 13
21273: PPUSH
21274: LD_INT 4
21276: PPUSH
21277: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21281: LD_VAR 0 13
21285: PPUSH
21286: LD_INT 99
21288: PPUSH
21289: LD_INT 83
21291: PPUSH
21292: LD_INT 5
21294: PPUSH
21295: LD_INT 0
21297: PPUSH
21298: CALL_OW 50
// Connect ( veh ) ;
21302: LD_VAR 0 13
21306: PPUSH
21307: CALL 71252 0 1
// tmp := tmp ^ veh ;
21311: LD_ADDR_VAR 0 3
21315: PUSH
21316: LD_VAR 0 3
21320: PUSH
21321: LD_VAR 0 13
21325: ADD
21326: ST_TO_ADDR
// end ;
21327: GO 21221
21329: POP
21330: POP
// wait ( 0 0$1 ) ;
21331: LD_INT 35
21333: PPUSH
21334: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21338: LD_INT 99
21340: PPUSH
21341: LD_INT 83
21343: PPUSH
21344: LD_INT 1
21346: PPUSH
21347: LD_INT 10
21349: PPUSH
21350: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21354: LD_INT 99
21356: PPUSH
21357: LD_INT 83
21359: PPUSH
21360: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21364: LD_VAR 0 11
21368: PPUSH
21369: LD_STRING D6-Sol3-2
21371: PPUSH
21372: CALL_OW 88
// async ;
21376: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21377: LD_EXP 55
21381: PPUSH
21382: LD_STRING D6-Pow-2
21384: PPUSH
21385: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21389: LD_VAR 0 3
21393: PUSH
21394: LD_INT 1
21396: ARRAY
21397: PPUSH
21398: LD_VAR 0 9
21402: PPUSH
21403: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21407: LD_VAR 0 3
21411: PUSH
21412: LD_INT 2
21414: ARRAY
21415: PPUSH
21416: LD_INT 22
21418: PUSH
21419: LD_INT 4
21421: PUSH
21422: EMPTY
21423: LIST
21424: LIST
21425: PUSH
21426: LD_INT 21
21428: PUSH
21429: LD_INT 3
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: PUSH
21436: EMPTY
21437: LIST
21438: LIST
21439: PPUSH
21440: CALL_OW 69
21444: PPUSH
21445: LD_VAR 0 3
21449: PUSH
21450: LD_INT 2
21452: ARRAY
21453: PPUSH
21454: CALL_OW 74
21458: PPUSH
21459: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21463: LD_EXP 55
21467: PPUSH
21468: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21472: LD_INT 99
21474: PPUSH
21475: LD_INT 83
21477: PPUSH
21478: LD_INT 1
21480: PPUSH
21481: CALL_OW 331
// repeat wait ( 4 ) ;
21485: LD_INT 4
21487: PPUSH
21488: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21492: LD_VAR 0 3
21496: PUSH
21497: LD_INT 1
21499: ARRAY
21500: PPUSH
21501: CALL_OW 256
21505: PUSH
21506: LD_INT 1000
21508: LESS
21509: IFFALSE 21527
// SetLives ( tmp [ 1 ] , 1000 ) ;
21511: LD_VAR 0 3
21515: PUSH
21516: LD_INT 1
21518: ARRAY
21519: PPUSH
21520: LD_INT 1000
21522: PPUSH
21523: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21527: LD_INT 22
21529: PUSH
21530: LD_INT 4
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: PUSH
21537: LD_INT 30
21539: PUSH
21540: LD_INT 3
21542: PUSH
21543: EMPTY
21544: LIST
21545: LIST
21546: PUSH
21547: EMPTY
21548: LIST
21549: LIST
21550: PPUSH
21551: CALL_OW 69
21555: PUSH
21556: LD_INT 0
21558: EQUAL
21559: IFFALSE 21485
// sync ;
21561: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21562: LD_EXP 55
21566: PPUSH
21567: LD_STRING D6a-Pow-1
21569: PPUSH
21570: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21574: LD_VAR 0 11
21578: PPUSH
21579: LD_STRING D6a-Sol3-1
21581: PPUSH
21582: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21586: LD_EXP 55
21590: PPUSH
21591: LD_STRING D6a-Pow-2
21593: PPUSH
21594: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21598: LD_VAR 0 11
21602: PPUSH
21603: LD_STRING D6a-Sol3-2
21605: PPUSH
21606: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21610: LD_EXP 55
21614: PPUSH
21615: LD_STRING D6a-Pow-3
21617: PPUSH
21618: CALL_OW 88
// powellCenterCameraMode := true ;
21622: LD_ADDR_EXP 20
21626: PUSH
21627: LD_INT 1
21629: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21630: LD_ADDR_VAR 0 1
21634: PUSH
21635: LD_INT 22
21637: PUSH
21638: LD_INT 8
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PUSH
21645: LD_INT 25
21647: PUSH
21648: LD_INT 2
21650: PUSH
21651: EMPTY
21652: LIST
21653: LIST
21654: PUSH
21655: EMPTY
21656: LIST
21657: LIST
21658: PPUSH
21659: CALL_OW 69
21663: PUSH
21664: FOR_IN
21665: IFFALSE 21720
// begin SetTag ( i , 1 ) ;
21667: LD_VAR 0 1
21671: PPUSH
21672: LD_INT 1
21674: PPUSH
21675: CALL_OW 109
// ComExitBuilding ( i ) ;
21679: LD_VAR 0 1
21683: PPUSH
21684: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
21688: LD_VAR 0 1
21692: PPUSH
21693: LD_INT 35
21695: PPUSH
21696: LD_INT 6
21698: PPUSH
21699: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
21703: LD_VAR 0 1
21707: PPUSH
21708: LD_INT 53
21710: PPUSH
21711: LD_INT 4
21713: PPUSH
21714: CALL_OW 171
// end ;
21718: GO 21664
21720: POP
21721: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
21722: LD_ADDR_VAR 0 3
21726: PUSH
21727: LD_INT 22
21729: PUSH
21730: LD_INT 4
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: LD_INT 21
21739: PUSH
21740: LD_INT 2
21742: PUSH
21743: EMPTY
21744: LIST
21745: LIST
21746: PUSH
21747: LD_INT 3
21749: PUSH
21750: LD_INT 34
21752: PUSH
21753: LD_INT 12
21755: PUSH
21756: EMPTY
21757: LIST
21758: LIST
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PUSH
21764: EMPTY
21765: LIST
21766: LIST
21767: LIST
21768: PPUSH
21769: CALL_OW 69
21773: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
21774: LD_EXP 55
21778: PPUSH
21779: LD_VAR 0 3
21783: PPUSH
21784: LD_EXP 55
21788: PPUSH
21789: CALL_OW 74
21793: PPUSH
21794: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
21798: LD_EXP 55
21802: PPUSH
21803: LD_INT 100
21805: PPUSH
21806: LD_INT 88
21808: PPUSH
21809: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
21813: LD_EXP 55
21817: PPUSH
21818: LD_INT 100
21820: PPUSH
21821: LD_INT 75
21823: PPUSH
21824: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
21828: LD_EXP 55
21832: PPUSH
21833: LD_INT 88
21835: PPUSH
21836: LD_INT 53
21838: PPUSH
21839: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
21843: LD_INT 8
21845: PPUSH
21846: LD_EXP 55
21850: PPUSH
21851: CALL_OW 471
// repeat wait ( 3 ) ;
21855: LD_INT 3
21857: PPUSH
21858: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
21862: LD_INT 22
21864: PUSH
21865: LD_INT 4
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: LD_INT 92
21874: PUSH
21875: LD_INT 100
21877: PUSH
21878: LD_INT 75
21880: PUSH
21881: LD_INT 6
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: LIST
21888: LIST
21889: PUSH
21890: EMPTY
21891: LIST
21892: LIST
21893: PPUSH
21894: CALL_OW 69
21898: IFFALSE 21855
// async ;
21900: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
21901: LD_EXP 55
21905: PPUSH
21906: LD_STRING D6b-Pow-1
21908: PPUSH
21909: CALL_OW 88
// repeat wait ( 3 ) ;
21913: LD_INT 3
21915: PPUSH
21916: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
21920: LD_EXP 55
21924: PPUSH
21925: CALL_OW 310
21929: PPUSH
21930: CALL_OW 256
21934: PUSH
21935: LD_INT 1000
21937: LESS
21938: IFFALSE 21957
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
21940: LD_EXP 55
21944: PPUSH
21945: CALL_OW 310
21949: PPUSH
21950: LD_INT 1000
21952: PPUSH
21953: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
21957: LD_EXP 55
21961: PPUSH
21962: CALL_OW 256
21966: PUSH
21967: LD_INT 1000
21969: LESS
21970: IFFALSE 21984
// SetLives ( Powell , 1000 ) ;
21972: LD_EXP 55
21976: PPUSH
21977: LD_INT 1000
21979: PPUSH
21980: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
21984: LD_EXP 55
21988: PPUSH
21989: LD_EXP 60
21993: PPUSH
21994: CALL_OW 296
21998: PUSH
21999: LD_INT 5
22001: LESS
22002: PUSH
22003: LD_EXP 55
22007: PPUSH
22008: CALL_OW 310
22012: PPUSH
22013: LD_EXP 60
22017: PPUSH
22018: CALL_OW 296
22022: PUSH
22023: LD_INT 5
22025: LESS
22026: OR
22027: IFFALSE 22046
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22029: LD_EXP 55
22033: PPUSH
22034: CALL_OW 310
22038: PPUSH
22039: LD_INT 100
22041: PPUSH
22042: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22046: LD_EXP 55
22050: PPUSH
22051: CALL_OW 310
22055: NOT
22056: IFFALSE 21913
// game_speed := 4 ;
22058: LD_ADDR_OWVAR 65
22062: PUSH
22063: LD_INT 4
22065: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22066: LD_EXP 55
22070: PPUSH
22071: LD_STRING D6b-Pow-1a
22073: PPUSH
22074: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22078: LD_EXP 55
22082: PPUSH
22083: LD_EXP 60
22087: PPUSH
22088: CALL_OW 180
// sync ;
22092: SYNC
// repeat wait ( 0 0$1 ) ;
22093: LD_INT 35
22095: PPUSH
22096: CALL_OW 67
// until IsInUnit ( Powell ) ;
22100: LD_EXP 55
22104: PPUSH
22105: CALL_OW 310
22109: IFFALSE 22093
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22111: LD_INT 8
22113: PPUSH
22114: LD_EXP 55
22118: PPUSH
22119: CALL_OW 310
22123: PPUSH
22124: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22128: LD_EXP 55
22132: PPUSH
22133: LD_INT 91
22135: PPUSH
22136: LD_INT 44
22138: PPUSH
22139: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22143: LD_EXP 55
22147: PPUSH
22148: LD_INT 96
22150: PPUSH
22151: LD_INT 44
22153: PPUSH
22154: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22158: LD_EXP 55
22162: PPUSH
22163: LD_INT 96
22165: PPUSH
22166: LD_INT 41
22168: PPUSH
22169: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22173: LD_EXP 55
22177: PPUSH
22178: LD_INT 92
22180: PPUSH
22181: LD_INT 39
22183: PPUSH
22184: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22188: LD_EXP 55
22192: PPUSH
22193: LD_INT 88
22195: PPUSH
22196: LD_INT 41
22198: PPUSH
22199: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22203: LD_EXP 55
22207: PPUSH
22208: LD_INT 91
22210: PPUSH
22211: LD_INT 44
22213: PPUSH
22214: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22218: LD_EXP 55
22222: PPUSH
22223: LD_INT 96
22225: PPUSH
22226: LD_INT 44
22228: PPUSH
22229: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22233: LD_EXP 55
22237: PPUSH
22238: LD_INT 96
22240: PPUSH
22241: LD_INT 41
22243: PPUSH
22244: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22248: LD_EXP 55
22252: PPUSH
22253: LD_INT 92
22255: PPUSH
22256: LD_INT 39
22258: PPUSH
22259: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22263: LD_EXP 55
22267: PPUSH
22268: LD_INT 88
22270: PPUSH
22271: LD_INT 41
22273: PPUSH
22274: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22278: LD_EXP 55
22282: PPUSH
22283: LD_INT 91
22285: PPUSH
22286: LD_INT 44
22288: PPUSH
22289: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22293: LD_EXP 55
22297: PPUSH
22298: LD_INT 93
22300: PPUSH
22301: LD_INT 39
22303: PPUSH
22304: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22308: LD_EXP 55
22312: PPUSH
22313: LD_INT 93
22315: PPUSH
22316: LD_INT 36
22318: PPUSH
22319: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22323: LD_INT 122
22325: PPUSH
22326: CALL_OW 67
// game_speed := 4 ;
22330: LD_ADDR_OWVAR 65
22334: PUSH
22335: LD_INT 4
22337: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22338: LD_EXP 55
22342: PPUSH
22343: LD_STRING D6b-Pow-1b
22345: PPUSH
22346: CALL_OW 88
// tmp := [ ] ;
22350: LD_ADDR_VAR 0 3
22354: PUSH
22355: EMPTY
22356: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22357: LD_ADDR_VAR 0 5
22361: PUSH
22362: LD_INT 78
22364: PUSH
22365: LD_INT 47
22367: PUSH
22368: EMPTY
22369: LIST
22370: LIST
22371: PUSH
22372: LD_INT 106
22374: PUSH
22375: LD_INT 53
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: PUSH
22382: EMPTY
22383: LIST
22384: LIST
22385: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22386: LD_ADDR_VAR 0 1
22390: PUSH
22391: LD_INT 22
22393: PUSH
22394: LD_INT 8
22396: PUSH
22397: EMPTY
22398: LIST
22399: LIST
22400: PUSH
22401: LD_INT 21
22403: PUSH
22404: LD_INT 3
22406: PUSH
22407: EMPTY
22408: LIST
22409: LIST
22410: PUSH
22411: LD_INT 92
22413: PUSH
22414: LD_INT 90
22416: PUSH
22417: LD_INT 52
22419: PUSH
22420: LD_INT 12
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: LIST
22427: LIST
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: PPUSH
22434: CALL_OW 69
22438: PUSH
22439: FOR_IN
22440: IFFALSE 22465
// tmp := tmp ^ UnitsInside ( i ) ;
22442: LD_ADDR_VAR 0 3
22446: PUSH
22447: LD_VAR 0 3
22451: PUSH
22452: LD_VAR 0 1
22456: PPUSH
22457: CALL_OW 313
22461: ADD
22462: ST_TO_ADDR
22463: GO 22439
22465: POP
22466: POP
// for i in tmp do
22467: LD_ADDR_VAR 0 1
22471: PUSH
22472: LD_VAR 0 3
22476: PUSH
22477: FOR_IN
22478: IFFALSE 22640
// begin dist := 9999 ;
22480: LD_ADDR_VAR 0 8
22484: PUSH
22485: LD_INT 9999
22487: ST_TO_ADDR
// _xy := [ ] ;
22488: LD_ADDR_VAR 0 7
22492: PUSH
22493: EMPTY
22494: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: LD_INT 1
22502: PPUSH
22503: CALL_OW 109
// ComExitBuilding ( i ) ;
22507: LD_VAR 0 1
22511: PPUSH
22512: CALL_OW 122
// for j in xy do
22516: LD_ADDR_VAR 0 2
22520: PUSH
22521: LD_VAR 0 5
22525: PUSH
22526: FOR_IN
22527: IFFALSE 22609
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22529: LD_VAR 0 1
22533: PPUSH
22534: LD_VAR 0 2
22538: PUSH
22539: LD_INT 1
22541: ARRAY
22542: PPUSH
22543: LD_VAR 0 2
22547: PUSH
22548: LD_INT 2
22550: ARRAY
22551: PPUSH
22552: CALL_OW 297
22556: PUSH
22557: LD_VAR 0 8
22561: LESS
22562: IFFALSE 22607
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22564: LD_ADDR_VAR 0 8
22568: PUSH
22569: LD_VAR 0 1
22573: PPUSH
22574: LD_VAR 0 2
22578: PUSH
22579: LD_INT 1
22581: ARRAY
22582: PPUSH
22583: LD_VAR 0 2
22587: PUSH
22588: LD_INT 2
22590: ARRAY
22591: PPUSH
22592: CALL_OW 297
22596: ST_TO_ADDR
// _xy := j ;
22597: LD_ADDR_VAR 0 7
22601: PUSH
22602: LD_VAR 0 2
22606: ST_TO_ADDR
// end ;
22607: GO 22526
22609: POP
22610: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22611: LD_VAR 0 1
22615: PPUSH
22616: LD_VAR 0 7
22620: PUSH
22621: LD_INT 1
22623: ARRAY
22624: PPUSH
22625: LD_VAR 0 7
22629: PUSH
22630: LD_INT 2
22632: ARRAY
22633: PPUSH
22634: CALL_OW 171
// end ;
22638: GO 22477
22640: POP
22641: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22642: LD_ADDR_VAR 0 4
22646: PUSH
22647: LD_VAR 0 3
22651: PPUSH
22652: LD_INT 26
22654: PUSH
22655: LD_INT 1
22657: PUSH
22658: EMPTY
22659: LIST
22660: LIST
22661: PUSH
22662: LD_INT 25
22664: PUSH
22665: LD_INT 1
22667: PUSH
22668: EMPTY
22669: LIST
22670: LIST
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: PPUSH
22676: CALL_OW 72
22680: ST_TO_ADDR
// if tmp2 < 2 then
22681: LD_VAR 0 4
22685: PUSH
22686: LD_INT 2
22688: LESS
22689: IFFALSE 22758
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
22691: LD_ADDR_VAR 0 4
22695: PUSH
22696: LD_INT 22
22698: PUSH
22699: LD_INT 8
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: PUSH
22706: LD_INT 26
22708: PUSH
22709: LD_INT 1
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: PUSH
22716: LD_INT 3
22718: PUSH
22719: LD_INT 25
22721: PUSH
22722: LD_INT 15
22724: PUSH
22725: EMPTY
22726: LIST
22727: LIST
22728: PUSH
22729: EMPTY
22730: LIST
22731: LIST
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: LIST
22737: PPUSH
22738: CALL_OW 69
22742: PUSH
22743: LD_EXP 57
22747: PUSH
22748: LD_EXP 58
22752: PUSH
22753: EMPTY
22754: LIST
22755: LIST
22756: DIFF
22757: ST_TO_ADDR
// if tmp2 then
22758: LD_VAR 0 4
22762: IFFALSE 22780
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
22764: LD_VAR 0 4
22768: PUSH
22769: LD_INT 1
22771: ARRAY
22772: PPUSH
22773: LD_STRING D6b-ArSol1-1
22775: PPUSH
22776: CALL_OW 88
// async ;
22780: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
22781: LD_EXP 55
22785: PPUSH
22786: LD_STRING D6b-Pow-2
22788: PPUSH
22789: CALL_OW 88
// wait ( 0 0$1 ) ;
22793: LD_INT 35
22795: PPUSH
22796: CALL_OW 67
// if tmp2 > 1 then
22800: LD_VAR 0 4
22804: PUSH
22805: LD_INT 1
22807: GREATER
22808: IFFALSE 22826
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
22810: LD_VAR 0 4
22814: PUSH
22815: LD_INT 2
22817: ARRAY
22818: PPUSH
22819: LD_STRING D6b-ArSol2-1
22821: PPUSH
22822: CALL_OW 88
// sync ;
22826: SYNC
// repeat wait ( 5 ) ;
22827: LD_INT 5
22829: PPUSH
22830: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
22834: LD_INT 93
22836: PPUSH
22837: LD_INT 36
22839: PPUSH
22840: CALL_OW 428
22844: PPUSH
22845: CALL_OW 255
22849: PUSH
22850: LD_INT 4
22852: EQUAL
22853: IFFALSE 22827
// DialogueOn ;
22855: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
22859: LD_INT 10
22861: PPUSH
22862: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
22866: LD_EXP 55
22870: PPUSH
22871: LD_STRING D6b-Pow-2a
22873: PPUSH
22874: CALL_OW 88
// DialogueOff ;
22878: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
22882: LD_EXP 55
22886: PPUSH
22887: CALL_OW 310
22891: PPUSH
22892: LD_INT 332
22894: PPUSH
22895: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
22899: LD_INT 93
22901: PPUSH
22902: LD_INT 35
22904: PPUSH
22905: LD_INT 1
22907: PPUSH
22908: LD_INT 6
22910: NEG
22911: PPUSH
22912: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
22916: LD_INT 35
22918: PPUSH
22919: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
22923: LD_INT 332
22925: PPUSH
22926: CALL_OW 256
22930: PUSH
22931: LD_INT 1000
22933: LESS
22934: PUSH
22935: LD_INT 332
22937: PPUSH
22938: CALL_OW 300
22942: AND
22943: IFFALSE 22955
// SetLives ( kozlov_fac , 0 ) ;
22945: LD_INT 332
22947: PPUSH
22948: LD_INT 0
22950: PPUSH
22951: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
22955: LD_INT 332
22957: PPUSH
22958: CALL_OW 301
22962: PUSH
22963: LD_EXP 55
22967: PPUSH
22968: CALL_OW 301
22972: OR
22973: IFFALSE 22916
// game_speed := 4 ;
22975: LD_ADDR_OWVAR 65
22979: PUSH
22980: LD_INT 4
22982: ST_TO_ADDR
// powellCenterCameraMode := false ;
22983: LD_ADDR_EXP 20
22987: PUSH
22988: LD_INT 0
22990: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22991: LD_ADDR_VAR 0 1
22995: PUSH
22996: LD_VAR 0 3
23000: PUSH
23001: LD_INT 22
23003: PUSH
23004: LD_INT 8
23006: PUSH
23007: EMPTY
23008: LIST
23009: LIST
23010: PUSH
23011: LD_INT 25
23013: PUSH
23014: LD_INT 2
23016: PUSH
23017: EMPTY
23018: LIST
23019: LIST
23020: PUSH
23021: EMPTY
23022: LIST
23023: LIST
23024: PPUSH
23025: CALL_OW 69
23029: UNION
23030: PUSH
23031: FOR_IN
23032: IFFALSE 23048
// SetTag ( i , 0 ) ;
23034: LD_VAR 0 1
23038: PPUSH
23039: LD_INT 0
23041: PPUSH
23042: CALL_OW 109
23046: GO 23031
23048: POP
23049: POP
// wait ( 0 0$3 ) ;
23050: LD_INT 105
23052: PPUSH
23053: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23057: LD_INT 93
23059: PPUSH
23060: LD_INT 35
23062: PPUSH
23063: LD_INT 1
23065: PPUSH
23066: CALL_OW 331
// DialogueOn ;
23070: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23074: LD_VAR 0 11
23078: PPUSH
23079: LD_STRING D6c-Sol3-1
23081: PPUSH
23082: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23086: LD_INT 10
23088: PPUSH
23089: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23093: LD_EXP 36
23097: PPUSH
23098: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23102: LD_EXP 36
23106: PPUSH
23107: LD_STRING D6c-JMM-1
23109: PPUSH
23110: CALL_OW 88
// if Cyrus then
23114: LD_EXP 42
23118: IFFALSE 23132
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23120: LD_EXP 42
23124: PPUSH
23125: LD_STRING D6c-Cyrus-1
23127: PPUSH
23128: CALL_OW 88
// if Bobby then
23132: LD_EXP 41
23136: IFFALSE 23150
// Say ( Bobby , D6c-Bobby-1 ) ;
23138: LD_EXP 41
23142: PPUSH
23143: LD_STRING D6c-Bobby-1
23145: PPUSH
23146: CALL_OW 88
// if Cornel then
23150: LD_EXP 47
23154: IFFALSE 23168
// Say ( Cornel , D6c-Corn-1 ) ;
23156: LD_EXP 47
23160: PPUSH
23161: LD_STRING D6c-Corn-1
23163: PPUSH
23164: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23168: LD_ADDR_VAR 0 4
23172: PUSH
23173: LD_INT 2
23175: PUSH
23176: LD_INT 22
23178: PUSH
23179: LD_INT 1
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: LD_INT 22
23188: PUSH
23189: LD_INT 4
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: LIST
23200: PUSH
23201: LD_INT 26
23203: PUSH
23204: LD_INT 1
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PUSH
23211: LD_INT 3
23213: PUSH
23214: LD_INT 25
23216: PUSH
23217: LD_INT 16
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: LD_INT 25
23226: PUSH
23227: LD_INT 12
23229: PUSH
23230: EMPTY
23231: LIST
23232: LIST
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: LIST
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: LIST
23243: PPUSH
23244: CALL_OW 69
23248: PUSH
23249: LD_VAR 0 11
23253: PUSH
23254: LD_EXP 36
23258: UNION
23259: PUSH
23260: LD_EXP 56
23264: UNION
23265: PUSH
23266: EMPTY
23267: LIST
23268: DIFF
23269: ST_TO_ADDR
// if tmp2 then
23270: LD_VAR 0 4
23274: IFFALSE 23292
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23276: LD_VAR 0 4
23280: PUSH
23281: LD_INT 1
23283: ARRAY
23284: PPUSH
23285: LD_STRING D6c-Sol1-1
23287: PPUSH
23288: CALL_OW 88
// if Lisa then
23292: LD_EXP 39
23296: IFFALSE 23310
// Say ( Lisa , D6c-Lisa-1 ) ;
23298: LD_EXP 39
23302: PPUSH
23303: LD_STRING D6c-Lisa-1
23305: PPUSH
23306: CALL_OW 88
// if Gary then
23310: LD_EXP 48
23314: IFFALSE 23328
// Say ( Gary , D6c-Gary-1 ) ;
23316: LD_EXP 48
23320: PPUSH
23321: LD_STRING D6c-Gary-1
23323: PPUSH
23324: CALL_OW 88
// if Donaldson then
23328: LD_EXP 40
23332: IFFALSE 23346
// Say ( Donaldson , D6c-Don-1 ) ;
23334: LD_EXP 40
23338: PPUSH
23339: LD_STRING D6c-Don-1
23341: PPUSH
23342: CALL_OW 88
// if tmp2 > 1 then
23346: LD_VAR 0 4
23350: PUSH
23351: LD_INT 1
23353: GREATER
23354: IFFALSE 23372
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23356: LD_VAR 0 4
23360: PUSH
23361: LD_INT 2
23363: ARRAY
23364: PPUSH
23365: LD_STRING D6c-Sol2-1
23367: PPUSH
23368: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23372: LD_VAR 0 11
23376: PPUSH
23377: LD_STRING D6c-Sol3-2
23379: PPUSH
23380: CALL_OW 88
// dwait ( 0 0$1 ) ;
23384: LD_INT 35
23386: PPUSH
23387: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23391: LD_EXP 36
23395: PPUSH
23396: LD_STRING D6c-JMM-2
23398: PPUSH
23399: CALL_OW 88
// DialogueOff ;
23403: CALL_OW 7
// Video ( false ) ;
23407: LD_INT 0
23409: PPUSH
23410: CALL 103852 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23414: LD_INT 22
23416: PUSH
23417: LD_INT 4
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PPUSH
23424: CALL_OW 69
23428: PPUSH
23429: LD_INT 1
23431: PPUSH
23432: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23436: LD_INT 4
23438: PPUSH
23439: LD_INT 4
23441: PPUSH
23442: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23446: LD_ADDR_VAR 0 1
23450: PUSH
23451: LD_INT 4
23453: PPUSH
23454: LD_INT 1
23456: PPUSH
23457: LD_INT 2
23459: PPUSH
23460: CALL 61627 0 3
23464: PUSH
23465: FOR_IN
23466: IFFALSE 23503
// if GetTech ( i , 1 ) <> state_researched then
23468: LD_VAR 0 1
23472: PPUSH
23473: LD_INT 1
23475: PPUSH
23476: CALL_OW 321
23480: PUSH
23481: LD_INT 2
23483: NONEQUAL
23484: IFFALSE 23501
// SetTech ( i , 1 , state_researched ) ;
23486: LD_VAR 0 1
23490: PPUSH
23491: LD_INT 1
23493: PPUSH
23494: LD_INT 2
23496: PPUSH
23497: CALL_OW 322
23501: GO 23465
23503: POP
23504: POP
// missionStage := 6 ;
23505: LD_ADDR_EXP 15
23509: PUSH
23510: LD_INT 6
23512: ST_TO_ADDR
// activeAttacks := true ;
23513: LD_ADDR_EXP 16
23517: PUSH
23518: LD_INT 1
23520: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23521: LD_STRING M2
23523: PPUSH
23524: CALL_OW 337
// SaveForQuickRestart ;
23528: CALL_OW 22
// wait ( 0 0$40 ) ;
23532: LD_INT 1400
23534: PPUSH
23535: CALL_OW 67
// DialogueOn ;
23539: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23543: LD_EXP 59
23547: PPUSH
23548: LD_STRING D7-Friend-1
23550: PPUSH
23551: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23555: LD_EXP 36
23559: PPUSH
23560: LD_STRING D7-JMM-1
23562: PPUSH
23563: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23567: LD_EXP 59
23571: PPUSH
23572: LD_STRING D7-Friend-2
23574: PPUSH
23575: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23579: LD_EXP 36
23583: PPUSH
23584: LD_STRING D7-JMM-2
23586: PPUSH
23587: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23591: LD_EXP 59
23595: PPUSH
23596: LD_STRING D7-Friend-3
23598: PPUSH
23599: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23603: LD_EXP 36
23607: PPUSH
23608: LD_STRING D7-JMM-3
23610: PPUSH
23611: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23615: LD_EXP 59
23619: PPUSH
23620: LD_STRING D7-Friend-4
23622: PPUSH
23623: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23627: LD_EXP 36
23631: PPUSH
23632: LD_STRING D7-JMM-4
23634: PPUSH
23635: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23639: LD_EXP 59
23643: PPUSH
23644: LD_STRING D7-Friend-5
23646: PPUSH
23647: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
23651: LD_EXP 36
23655: PPUSH
23656: LD_STRING D7-JMM-5
23658: PPUSH
23659: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
23663: LD_EXP 59
23667: PPUSH
23668: LD_STRING D7-Friend-6
23670: PPUSH
23671: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
23675: LD_EXP 36
23679: PPUSH
23680: LD_STRING D7-JMM-6
23682: PPUSH
23683: CALL_OW 88
// DialogueOff ;
23687: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
23691: LD_STRING Mlegion
23693: PPUSH
23694: CALL_OW 337
// RebuildKozlovFactory ;
23698: CALL 4677 0 0
// end ;
23702: PPOPN 13
23704: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
23705: LD_EXP 20
23709: PUSH
23710: LD_EXP 55
23714: PPUSH
23715: CALL_OW 300
23719: AND
23720: IFFALSE 23762
23722: GO 23724
23724: DISABLE
// begin enable ;
23725: ENABLE
// if IsInUnit ( Powell ) then
23726: LD_EXP 55
23730: PPUSH
23731: CALL_OW 310
23735: IFFALSE 23753
// CenterOnUnits ( IsInUnit ( Powell ) ) else
23737: LD_EXP 55
23741: PPUSH
23742: CALL_OW 310
23746: PPUSH
23747: CALL_OW 85
23751: GO 23762
// CenterOnUnits ( Powell ) ;
23753: LD_EXP 55
23757: PPUSH
23758: CALL_OW 85
// end ;
23762: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
23763: LD_INT 22
23765: PUSH
23766: LD_INT 8
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: LD_INT 34
23775: PUSH
23776: LD_INT 48
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PPUSH
23787: CALL_OW 69
23791: IFFALSE 24054
23793: GO 23795
23795: DISABLE
23796: LD_INT 0
23798: PPUSH
23799: PPUSH
// begin if missionStage < 9 then
23800: LD_EXP 15
23804: PUSH
23805: LD_INT 9
23807: LESS
23808: IFFALSE 23818
// missionStage := 9 ;
23810: LD_ADDR_EXP 15
23814: PUSH
23815: LD_INT 9
23817: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
23818: LD_ADDR_VAR 0 1
23822: PUSH
23823: LD_INT 22
23825: PUSH
23826: LD_INT 8
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_INT 34
23835: PUSH
23836: LD_INT 48
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: PUSH
23843: EMPTY
23844: LIST
23845: LIST
23846: PPUSH
23847: CALL_OW 69
23851: PUSH
23852: LD_INT 1
23854: ARRAY
23855: ST_TO_ADDR
// wait ( 0 0$05 ) ;
23856: LD_INT 175
23858: PPUSH
23859: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
23863: LD_EXP 12
23867: PUSH
23868: LD_EXP 3
23872: PUSH
23873: LD_INT 0
23875: PUSH
23876: LD_INT 2
23878: PUSH
23879: EMPTY
23880: LIST
23881: LIST
23882: IN
23883: OR
23884: IFFALSE 23907
// target := [ 68 , 108 , 1 ] else
23886: LD_ADDR_VAR 0 2
23890: PUSH
23891: LD_INT 68
23893: PUSH
23894: LD_INT 108
23896: PUSH
23897: LD_INT 1
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: LIST
23904: ST_TO_ADDR
23905: GO 23926
// target := [ 181 , 88 , 2 ] ;
23907: LD_ADDR_VAR 0 2
23911: PUSH
23912: LD_INT 181
23914: PUSH
23915: LD_INT 88
23917: PUSH
23918: LD_INT 2
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: LIST
23925: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
23926: LD_VAR 0 1
23930: PPUSH
23931: LD_VAR 0 2
23935: PUSH
23936: LD_INT 1
23938: ARRAY
23939: PPUSH
23940: LD_VAR 0 2
23944: PUSH
23945: LD_INT 2
23947: ARRAY
23948: PPUSH
23949: CALL_OW 176
// if target [ 3 ] = 1 then
23953: LD_VAR 0 2
23957: PUSH
23958: LD_INT 3
23960: ARRAY
23961: PUSH
23962: LD_INT 1
23964: EQUAL
23965: IFFALSE 23981
// SayRadio ( Kurt , D12-Kurt-1 ) else
23967: LD_EXP 57
23971: PPUSH
23972: LD_STRING D12-Kurt-1
23974: PPUSH
23975: CALL_OW 94
23979: GO 24005
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
23981: LD_EXP 57
23985: PPUSH
23986: LD_STRING D12a-Kurt-1
23988: PPUSH
23989: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
23993: LD_EXP 71
23997: PPUSH
23998: LD_STRING D12a-Roth-1
24000: PPUSH
24001: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24005: LD_INT 350
24007: PPUSH
24008: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24012: LD_VAR 0 1
24016: PPUSH
24017: LD_INT 22
24019: PUSH
24020: LD_INT 8
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 30
24029: PUSH
24030: LD_INT 3
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: PPUSH
24041: CALL_OW 69
24045: PUSH
24046: LD_INT 1
24048: ARRAY
24049: PPUSH
24050: CALL_OW 228
// end ;
24054: PPOPN 2
24056: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24057: LD_INT 22
24059: PUSH
24060: LD_INT 8
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: PUSH
24067: LD_INT 21
24069: PUSH
24070: LD_INT 1
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: PUSH
24077: LD_INT 23
24079: PUSH
24080: LD_INT 2
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: PPUSH
24092: CALL_OW 69
24096: PUSH
24097: LD_INT 8
24099: PUSH
24100: LD_INT 7
24102: PUSH
24103: LD_INT 6
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: LIST
24110: PUSH
24111: LD_OWVAR 67
24115: ARRAY
24116: LESSEQUAL
24117: PUSH
24118: LD_INT 22
24120: PUSH
24121: LD_INT 8
24123: PUSH
24124: EMPTY
24125: LIST
24126: LIST
24127: PUSH
24128: LD_INT 34
24130: PUSH
24131: LD_INT 48
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PUSH
24138: EMPTY
24139: LIST
24140: LIST
24141: PPUSH
24142: CALL_OW 69
24146: NOT
24147: AND
24148: PUSH
24149: LD_EXP 57
24153: PPUSH
24154: CALL_OW 302
24158: AND
24159: IFFALSE 24476
24161: GO 24163
24163: DISABLE
// begin DialogueOn ;
24164: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24168: LD_EXP 36
24172: PPUSH
24173: LD_STRING D13-JMM-1
24175: PPUSH
24176: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24180: LD_EXP 57
24184: PPUSH
24185: LD_STRING D13-Kurt-1
24187: PPUSH
24188: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24192: LD_EXP 36
24196: PPUSH
24197: LD_STRING D13-JMM-2
24199: PPUSH
24200: CALL_OW 88
// if FakeInfo then
24204: LD_EXP 12
24208: IFFALSE 24228
// begin Say ( Kurt , D13-Kurt-2 ) ;
24210: LD_EXP 57
24214: PPUSH
24215: LD_STRING D13-Kurt-2
24217: PPUSH
24218: CALL_OW 88
// DialogueOff ;
24222: CALL_OW 7
// exit ;
24226: GO 24476
// end ; if not KurtStatus then
24228: LD_EXP 3
24232: NOT
24233: IFFALSE 24249
// Say ( Kurt , D13-Kurt-2b ) else
24235: LD_EXP 57
24239: PPUSH
24240: LD_STRING D13-Kurt-2b
24242: PPUSH
24243: CALL_OW 88
24247: GO 24261
// Say ( Kurt , D13-Kurt-2a ) ;
24249: LD_EXP 57
24253: PPUSH
24254: LD_STRING D13-Kurt-2a
24256: PPUSH
24257: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24261: LD_EXP 57
24265: PPUSH
24266: LD_STRING D13-Kurt-2a
24268: PPUSH
24269: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24273: LD_EXP 36
24277: PPUSH
24278: LD_STRING D13-JMM-3
24280: PPUSH
24281: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24285: LD_EXP 57
24289: PPUSH
24290: LD_STRING D13-Kurt-3
24292: PPUSH
24293: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24297: LD_EXP 36
24301: PPUSH
24302: LD_STRING D13-JMM-4
24304: PPUSH
24305: CALL_OW 88
// DialogueOff ;
24309: CALL_OW 7
// MC_Kill ( 3 ) ;
24313: LD_INT 3
24315: PPUSH
24316: CALL 33553 0 1
// KillUnit ( Kozlov ) ;
24320: LD_EXP 58
24324: PPUSH
24325: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24329: LD_INT 22
24331: PUSH
24332: LD_INT 8
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 21
24341: PUSH
24342: LD_INT 3
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 23
24351: PUSH
24352: LD_INT 3
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 30
24361: PUSH
24362: LD_INT 3
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: LIST
24373: LIST
24374: PPUSH
24375: CALL_OW 69
24379: PUSH
24380: LD_INT 1
24382: ARRAY
24383: PPUSH
24384: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24388: LD_INT 8
24390: PPUSH
24391: LD_INT 1
24393: PPUSH
24394: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24398: LD_INT 22
24400: PUSH
24401: LD_INT 8
24403: PUSH
24404: EMPTY
24405: LIST
24406: LIST
24407: PPUSH
24408: CALL_OW 69
24412: PPUSH
24413: LD_INT 1
24415: PPUSH
24416: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24420: LD_INT 8
24422: PPUSH
24423: LD_INT 1
24425: PPUSH
24426: LD_INT 1
24428: PPUSH
24429: LD_INT 1
24431: PPUSH
24432: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24436: LD_EXP 59
24440: PPUSH
24441: LD_INT 37
24443: PPUSH
24444: LD_INT 1
24446: PPUSH
24447: LD_INT 0
24449: PPUSH
24450: CALL_OW 48
// wait ( 0 0$1 ) ;
24454: LD_INT 35
24456: PPUSH
24457: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24461: LD_EXP 59
24465: PPUSH
24466: LD_INT 60
24468: PPUSH
24469: LD_INT 95
24471: PPUSH
24472: CALL_OW 111
// end ;
24476: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24477: LD_INT 22
24479: PUSH
24480: LD_INT 8
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: PUSH
24487: LD_INT 21
24489: PUSH
24490: LD_INT 1
24492: PUSH
24493: EMPTY
24494: LIST
24495: LIST
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: PPUSH
24501: CALL_OW 69
24505: PUSH
24506: LD_INT 0
24508: EQUAL
24509: IFFALSE 24529
24511: GO 24513
24513: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24514: LD_STRING MlegionOut
24516: PPUSH
24517: CALL_OW 337
// legionDestroyed := true ;
24521: LD_ADDR_EXP 22
24525: PUSH
24526: LD_INT 1
24528: ST_TO_ADDR
// end ;
24529: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24530: LD_INT 1
24532: PPUSH
24533: LD_EXP 59
24537: PPUSH
24538: CALL_OW 292
24542: IFFALSE 24842
24544: GO 24546
24546: DISABLE
24547: LD_INT 0
24549: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24550: LD_EXP 59
24554: PPUSH
24555: CALL_OW 87
// DialogueOn ;
24559: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24563: LD_EXP 36
24567: PPUSH
24568: LD_STRING D14-JMM-1
24570: PPUSH
24571: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24575: LD_EXP 59
24579: PPUSH
24580: LD_STRING D14-Friend-1
24582: PPUSH
24583: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24587: LD_EXP 36
24591: PPUSH
24592: LD_STRING D14-JMM-2
24594: PPUSH
24595: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24599: LD_EXP 59
24603: PPUSH
24604: LD_STRING D14-Friend-2
24606: PPUSH
24607: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24611: LD_EXP 36
24615: PPUSH
24616: LD_STRING D14-JMM-3
24618: PPUSH
24619: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24623: LD_EXP 59
24627: PPUSH
24628: LD_STRING D14-Friend-3
24630: PPUSH
24631: CALL_OW 88
// DialogueOff ;
24635: CALL_OW 7
// dec = Query ( Q14 ) ;
24639: LD_ADDR_VAR 0 1
24643: PUSH
24644: LD_STRING Q14
24646: PPUSH
24647: CALL_OW 97
24651: ST_TO_ADDR
// if dec = 1 then
24652: LD_VAR 0 1
24656: PUSH
24657: LD_INT 1
24659: EQUAL
24660: IFFALSE 24694
// begin DialogueOn ;
24662: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
24666: LD_EXP 36
24670: PPUSH
24671: LD_STRING D14a-JMM-1
24673: PPUSH
24674: CALL_OW 88
// DialogueOff ;
24678: CALL_OW 7
// SetSide ( Friend , 1 ) ;
24682: LD_EXP 59
24686: PPUSH
24687: LD_INT 1
24689: PPUSH
24690: CALL_OW 235
// end ; if dec = 2 then
24694: LD_VAR 0 1
24698: PUSH
24699: LD_INT 2
24701: EQUAL
24702: IFFALSE 24748
// begin DialogueOn ;
24704: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
24708: LD_EXP 36
24712: PPUSH
24713: LD_STRING D14b-JMM-1
24715: PPUSH
24716: CALL_OW 88
// DialogueOff ;
24720: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
24724: LD_EXP 59
24728: PPUSH
24729: LD_INT 9
24731: PPUSH
24732: LD_INT 2
24734: PPUSH
24735: CALL_OW 111
// AddComHold ( Friend ) ;
24739: LD_EXP 59
24743: PPUSH
24744: CALL_OW 200
// end ; if dec = 3 then
24748: LD_VAR 0 1
24752: PUSH
24753: LD_INT 3
24755: EQUAL
24756: IFFALSE 24842
// begin DialogueOn ;
24758: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
24762: LD_EXP 36
24766: PPUSH
24767: LD_STRING D14c-JMM-1
24769: PPUSH
24770: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
24774: LD_EXP 59
24778: PPUSH
24779: LD_STRING D14c-Friend-1
24781: PPUSH
24782: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
24786: LD_EXP 36
24790: PPUSH
24791: LD_STRING D14c-JMM-2
24793: PPUSH
24794: CALL_OW 88
// DialogueOff ;
24798: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
24802: LD_INT 8
24804: PPUSH
24805: LD_INT 1
24807: PPUSH
24808: LD_INT 2
24810: PPUSH
24811: LD_INT 1
24813: PPUSH
24814: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
24818: LD_EXP 59
24822: PPUSH
24823: LD_INT 9
24825: PPUSH
24826: LD_INT 2
24828: PPUSH
24829: CALL_OW 111
// AddComHold ( Friend ) ;
24833: LD_EXP 59
24837: PPUSH
24838: CALL_OW 200
// end ; end ;
24842: PPOPN 1
24844: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
24845: LD_INT 9
24847: PPUSH
24848: LD_INT 2
24850: PPUSH
24851: CALL_OW 428
24855: PUSH
24856: LD_EXP 59
24860: EQUAL
24861: PUSH
24862: LD_EXP 59
24866: PPUSH
24867: CALL_OW 255
24871: PUSH
24872: LD_INT 8
24874: EQUAL
24875: AND
24876: IFFALSE 24890
24878: GO 24880
24880: DISABLE
// RemoveUnit ( Friend ) ;
24881: LD_EXP 59
24885: PPUSH
24886: CALL_OW 64
24890: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
24891: LD_EXP 14
24895: PUSH
24896: LD_INT 31500
24898: GREATEREQUAL
24899: PUSH
24900: LD_EXP 7
24904: AND
24905: PUSH
24906: LD_EXP 2
24910: AND
24911: IFFALSE 25341
24913: GO 24915
24915: DISABLE
24916: LD_INT 0
24918: PPUSH
24919: PPUSH
24920: PPUSH
// begin missionStage := 7 ;
24921: LD_ADDR_EXP 15
24925: PUSH
24926: LD_INT 7
24928: ST_TO_ADDR
// uc_side = 1 ;
24929: LD_ADDR_OWVAR 20
24933: PUSH
24934: LD_INT 1
24936: ST_TO_ADDR
// uc_nation = 1 ;
24937: LD_ADDR_OWVAR 21
24941: PUSH
24942: LD_INT 1
24944: ST_TO_ADDR
// for i = 1 to 5 do
24945: LD_ADDR_VAR 0 1
24949: PUSH
24950: DOUBLE
24951: LD_INT 1
24953: DEC
24954: ST_TO_ADDR
24955: LD_INT 5
24957: PUSH
24958: FOR_TO
24959: IFFALSE 25055
// begin vc_engine = 3 ;
24961: LD_ADDR_OWVAR 39
24965: PUSH
24966: LD_INT 3
24968: ST_TO_ADDR
// vc_control = 3 ;
24969: LD_ADDR_OWVAR 38
24973: PUSH
24974: LD_INT 3
24976: ST_TO_ADDR
// vc_chassis = 3 ;
24977: LD_ADDR_OWVAR 37
24981: PUSH
24982: LD_INT 3
24984: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
24985: LD_ADDR_OWVAR 40
24989: PUSH
24990: LD_INT 5
24992: PUSH
24993: LD_INT 9
24995: PUSH
24996: LD_INT 7
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 1
25006: PPUSH
25007: LD_INT 3
25009: PPUSH
25010: CALL_OW 12
25014: ARRAY
25015: ST_TO_ADDR
// veh = CreateVehicle ;
25016: LD_ADDR_VAR 0 2
25020: PUSH
25021: CALL_OW 45
25025: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25026: LD_VAR 0 2
25030: PPUSH
25031: LD_INT 1
25033: PPUSH
25034: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25038: LD_VAR 0 2
25042: PPUSH
25043: LD_INT 19
25045: PPUSH
25046: LD_INT 0
25048: PPUSH
25049: CALL_OW 49
// end ;
25053: GO 24958
25055: POP
25056: POP
// vc_engine = 3 ;
25057: LD_ADDR_OWVAR 39
25061: PUSH
25062: LD_INT 3
25064: ST_TO_ADDR
// vc_control = 1 ;
25065: LD_ADDR_OWVAR 38
25069: PUSH
25070: LD_INT 1
25072: ST_TO_ADDR
// vc_chassis = 3 ;
25073: LD_ADDR_OWVAR 37
25077: PUSH
25078: LD_INT 3
25080: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25081: LD_ADDR_OWVAR 40
25085: PUSH
25086: LD_INT 5
25088: PUSH
25089: LD_INT 9
25091: PUSH
25092: LD_INT 7
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: LIST
25099: PUSH
25100: LD_INT 1
25102: PPUSH
25103: LD_INT 3
25105: PPUSH
25106: CALL_OW 12
25110: ARRAY
25111: ST_TO_ADDR
// vehG = CreateVehicle ;
25112: LD_ADDR_VAR 0 3
25116: PUSH
25117: CALL_OW 45
25121: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25122: LD_VAR 0 3
25126: PPUSH
25127: LD_INT 1
25129: PPUSH
25130: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25134: LD_VAR 0 3
25138: PPUSH
25139: LD_INT 19
25141: PPUSH
25142: LD_INT 0
25144: PPUSH
25145: CALL_OW 49
// if JMMGirl = 1 then
25149: LD_EXP 7
25153: PUSH
25154: LD_INT 1
25156: EQUAL
25157: IFFALSE 25213
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25159: LD_ADDR_EXP 37
25163: PUSH
25164: LD_STRING Joan
25166: PPUSH
25167: LD_INT 1
25169: PPUSH
25170: LD_STRING 14_
25172: PPUSH
25173: CALL 61564 0 3
25177: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25178: LD_EXP 37
25182: PPUSH
25183: LD_VAR 0 3
25187: PPUSH
25188: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25192: LD_VAR 0 3
25196: PPUSH
25197: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25201: LD_EXP 37
25205: PPUSH
25206: LD_STRING D10BW-Joan-1
25208: PPUSH
25209: CALL_OW 94
// end ; if JMMGirl = 2 then
25213: LD_EXP 7
25217: PUSH
25218: LD_INT 2
25220: EQUAL
25221: IFFALSE 25277
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25223: LD_ADDR_EXP 39
25227: PUSH
25228: LD_STRING Lisa
25230: PPUSH
25231: LD_INT 1
25233: PPUSH
25234: LD_STRING 14_
25236: PPUSH
25237: CALL 61564 0 3
25241: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25242: LD_EXP 39
25246: PPUSH
25247: LD_VAR 0 3
25251: PPUSH
25252: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25256: LD_VAR 0 3
25260: PPUSH
25261: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25265: LD_EXP 39
25269: PPUSH
25270: LD_STRING D10BW-Lisa-1
25272: PPUSH
25273: CALL_OW 94
// end ; if JMMGirl = 3 then
25277: LD_EXP 7
25281: PUSH
25282: LD_INT 3
25284: EQUAL
25285: IFFALSE 25341
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25287: LD_ADDR_EXP 51
25291: PUSH
25292: LD_STRING Connie
25294: PPUSH
25295: LD_INT 1
25297: PPUSH
25298: LD_STRING 14_
25300: PPUSH
25301: CALL 61564 0 3
25305: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25306: LD_EXP 51
25310: PPUSH
25311: LD_VAR 0 3
25315: PPUSH
25316: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25320: LD_VAR 0 3
25324: PPUSH
25325: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25329: LD_EXP 39
25333: PPUSH
25334: LD_STRING D10BW-Con-1
25336: PPUSH
25337: CALL_OW 94
// end ; end ;
25341: PPOPN 3
25343: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25344: LD_EXP 14
25348: PUSH
25349: LD_INT 94500
25351: GREATEREQUAL
25352: IFFALSE 25764
25354: GO 25356
25356: DISABLE
25357: LD_INT 0
25359: PPUSH
25360: PPUSH
25361: PPUSH
// begin tmp := PrepareStevensSquad ;
25362: LD_ADDR_VAR 0 3
25366: PUSH
25367: CALL 2051 0 0
25371: ST_TO_ADDR
// if not tmp then
25372: LD_VAR 0 3
25376: NOT
25377: IFFALSE 25381
// exit ;
25379: GO 25764
// uc_side := 1 ;
25381: LD_ADDR_OWVAR 20
25385: PUSH
25386: LD_INT 1
25388: ST_TO_ADDR
// uc_nation := 1 ;
25389: LD_ADDR_OWVAR 21
25393: PUSH
25394: LD_INT 1
25396: ST_TO_ADDR
// for i in tmp do
25397: LD_ADDR_VAR 0 1
25401: PUSH
25402: LD_VAR 0 3
25406: PUSH
25407: FOR_IN
25408: IFFALSE 25505
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25410: LD_INT 3
25412: PPUSH
25413: LD_INT 3
25415: PPUSH
25416: LD_INT 1
25418: PPUSH
25419: LD_INT 5
25421: PUSH
25422: LD_INT 9
25424: PUSH
25425: LD_INT 7
25427: PUSH
25428: EMPTY
25429: LIST
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 1
25435: PPUSH
25436: LD_INT 3
25438: PPUSH
25439: CALL_OW 12
25443: ARRAY
25444: PPUSH
25445: LD_INT 40
25447: PPUSH
25448: CALL 68197 0 5
// veh := CreateVehicle ;
25452: LD_ADDR_VAR 0 2
25456: PUSH
25457: CALL_OW 45
25461: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 1
25469: PPUSH
25470: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25474: LD_VAR 0 2
25478: PPUSH
25479: LD_INT 19
25481: PPUSH
25482: LD_INT 0
25484: PPUSH
25485: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25489: LD_VAR 0 1
25493: PPUSH
25494: LD_VAR 0 2
25498: PPUSH
25499: CALL_OW 52
// end ;
25503: GO 25407
25505: POP
25506: POP
// missionStage := 8 ;
25507: LD_ADDR_EXP 15
25511: PUSH
25512: LD_INT 8
25514: ST_TO_ADDR
// DialogueOn ;
25515: CALL_OW 6
// if Stevens then
25519: LD_EXP 38
25523: IFFALSE 25637
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25525: LD_EXP 38
25529: PPUSH
25530: CALL_OW 310
25534: PPUSH
25535: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25539: LD_EXP 38
25543: PPUSH
25544: LD_STRING D8-Huck-1
25546: PPUSH
25547: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25551: LD_EXP 36
25555: PPUSH
25556: LD_STRING D8-JMM-1
25558: PPUSH
25559: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25563: LD_EXP 38
25567: PPUSH
25568: LD_STRING D8-Huck-2
25570: PPUSH
25571: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25575: LD_EXP 36
25579: PPUSH
25580: LD_STRING D8-JMM-2
25582: PPUSH
25583: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25587: LD_EXP 38
25591: PPUSH
25592: LD_STRING D8-Huck-3
25594: PPUSH
25595: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25599: LD_EXP 36
25603: PPUSH
25604: LD_STRING D8-JMM-3
25606: PPUSH
25607: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25611: LD_EXP 38
25615: PPUSH
25616: LD_STRING D8-Huck-4
25618: PPUSH
25619: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25623: LD_EXP 36
25627: PPUSH
25628: LD_STRING D8-JMM-4
25630: PPUSH
25631: CALL_OW 88
// end else
25635: GO 25747
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25637: LD_EXP 52
25641: PPUSH
25642: CALL_OW 310
25646: PPUSH
25647: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
25651: LD_EXP 52
25655: PPUSH
25656: LD_STRING D8-Huck-1
25658: PPUSH
25659: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
25663: LD_EXP 36
25667: PPUSH
25668: LD_STRING D8-JMM-1a
25670: PPUSH
25671: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
25675: LD_EXP 52
25679: PPUSH
25680: LD_STRING D8-Huck-2
25682: PPUSH
25683: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25687: LD_EXP 36
25691: PPUSH
25692: LD_STRING D8-JMM-2
25694: PPUSH
25695: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
25699: LD_EXP 52
25703: PPUSH
25704: LD_STRING D8-Huck-3
25706: PPUSH
25707: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25711: LD_EXP 36
25715: PPUSH
25716: LD_STRING D8-JMM-3
25718: PPUSH
25719: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
25723: LD_EXP 52
25727: PPUSH
25728: LD_STRING D8-Huck-4
25730: PPUSH
25731: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25735: LD_EXP 36
25739: PPUSH
25740: LD_STRING D8-JMM-4
25742: PPUSH
25743: CALL_OW 88
// end ; DialogueOff ;
25747: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
25751: LD_INT 25
25753: PPUSH
25754: LD_INT 1
25756: PPUSH
25757: LD_INT 1
25759: PPUSH
25760: CALL_OW 322
// end ;
25764: PPOPN 3
25766: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
25767: LD_INT 1
25769: PPUSH
25770: LD_EXP 68
25774: PPUSH
25775: CALL_OW 292
25779: IFFALSE 26030
25781: GO 25783
25783: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
25784: LD_EXP 68
25788: PPUSH
25789: CALL_OW 87
// DialogueOn ;
25793: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
25797: LD_EXP 36
25801: PPUSH
25802: LD_STRING D10nB-JMM-1
25804: PPUSH
25805: CALL_OW 88
// if BurlakStatus = 1 then
25809: LD_EXP 9
25813: PUSH
25814: LD_INT 1
25816: EQUAL
25817: IFFALSE 25831
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
25819: LD_EXP 67
25823: PPUSH
25824: LD_STRING D10nB-Vse-1a
25826: PPUSH
25827: CALL_OW 94
// end ; if BurlakStatus = 0 then
25831: LD_EXP 9
25835: PUSH
25836: LD_INT 0
25838: EQUAL
25839: IFFALSE 25853
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
25841: LD_EXP 67
25845: PPUSH
25846: LD_STRING D10nB-Vse-1
25848: PPUSH
25849: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
25853: LD_EXP 36
25857: PPUSH
25858: LD_STRING D10nB-JMM-2
25860: PPUSH
25861: CALL_OW 88
// if KappaStatus then
25865: LD_EXP 2
25869: IFFALSE 25883
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
25871: LD_EXP 67
25875: PPUSH
25876: LD_STRING D10nB-Vse-5a
25878: PPUSH
25879: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
25883: LD_EXP 2
25887: NOT
25888: PUSH
25889: LD_EXP 6
25893: PUSH
25894: LD_INT 0
25896: EQUAL
25897: AND
25898: IFFALSE 26026
// begin if JMMGirl = 1 then
25900: LD_EXP 7
25904: PUSH
25905: LD_INT 1
25907: EQUAL
25908: IFFALSE 25958
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
25910: LD_EXP 67
25914: PPUSH
25915: LD_STRING D10nB-Vse-2
25917: PPUSH
25918: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
25922: LD_EXP 36
25926: PPUSH
25927: LD_STRING D10nB-JMM-3
25929: PPUSH
25930: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
25934: LD_EXP 67
25938: PPUSH
25939: LD_STRING D10nB-Vse-3
25941: PPUSH
25942: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
25946: LD_EXP 36
25950: PPUSH
25951: LD_STRING D10nB-JMM-4
25953: PPUSH
25954: CALL_OW 88
// end ; if JMMGirl = 2 then
25958: LD_EXP 7
25962: PUSH
25963: LD_INT 2
25965: EQUAL
25966: IFFALSE 25992
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
25968: LD_EXP 67
25972: PPUSH
25973: LD_STRING D10nB-Vse-4
25975: PPUSH
25976: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
25980: LD_EXP 36
25984: PPUSH
25985: LD_STRING D10nB-JMM-5
25987: PPUSH
25988: CALL_OW 88
// end ; if JMMGirl = 3 then
25992: LD_EXP 7
25996: PUSH
25997: LD_INT 3
25999: EQUAL
26000: IFFALSE 26026
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26002: LD_EXP 67
26006: PPUSH
26007: LD_STRING D10nB-Vse-5
26009: PPUSH
26010: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26014: LD_EXP 36
26018: PPUSH
26019: LD_STRING D10nB-JMM-6
26021: PPUSH
26022: CALL_OW 88
// end ; end ; DialogueOff ;
26026: CALL_OW 7
// end ;
26030: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26031: LD_EXP 14
26035: PUSH
26036: LD_INT 115500
26038: GREATEREQUAL
26039: IFFALSE 26398
26041: GO 26043
26043: DISABLE
26044: LD_INT 0
26046: PPUSH
// begin missionStage := 10 ;
26047: LD_ADDR_EXP 15
26051: PUSH
26052: LD_INT 10
26054: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26055: LD_ADDR_VAR 0 1
26059: PUSH
26060: LD_INT 22
26062: PUSH
26063: LD_INT 1
26065: PUSH
26066: EMPTY
26067: LIST
26068: LIST
26069: PUSH
26070: LD_INT 26
26072: PUSH
26073: LD_INT 1
26075: PUSH
26076: EMPTY
26077: LIST
26078: LIST
26079: PUSH
26080: LD_INT 3
26082: PUSH
26083: LD_INT 25
26085: PUSH
26086: LD_INT 12
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: PUSH
26097: LD_INT 3
26099: PUSH
26100: LD_INT 25
26102: PUSH
26103: LD_INT 16
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: LIST
26118: LIST
26119: PPUSH
26120: CALL_OW 69
26124: PUSH
26125: LD_EXP 36
26129: PUSH
26130: LD_EXP 38
26134: PUSH
26135: LD_EXP 52
26139: PUSH
26140: LD_EXP 39
26144: PUSH
26145: LD_EXP 40
26149: PUSH
26150: LD_EXP 41
26154: PUSH
26155: LD_EXP 42
26159: PUSH
26160: LD_EXP 43
26164: PUSH
26165: LD_EXP 44
26169: PUSH
26170: LD_EXP 45
26174: PUSH
26175: LD_EXP 46
26179: PUSH
26180: LD_EXP 47
26184: PUSH
26185: LD_EXP 48
26189: PUSH
26190: LD_EXP 49
26194: PUSH
26195: LD_EXP 50
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: DIFF
26217: ST_TO_ADDR
// if not tmp and Brown then
26218: LD_VAR 0 1
26222: NOT
26223: PUSH
26224: LD_EXP 44
26228: AND
26229: IFFALSE 26244
// tmp := [ Brown ] ;
26231: LD_ADDR_VAR 0 1
26235: PUSH
26236: LD_EXP 44
26240: PUSH
26241: EMPTY
26242: LIST
26243: ST_TO_ADDR
// DialogueOn ;
26244: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26248: LD_VAR 0 1
26252: PUSH
26253: LD_INT 1
26255: ARRAY
26256: PPUSH
26257: LD_STRING D11-Sol1-1
26259: PPUSH
26260: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26264: LD_EXP 61
26268: PPUSH
26269: LD_STRING D11-Pla-1
26271: PPUSH
26272: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26276: LD_EXP 62
26280: PPUSH
26281: LD_STRING D11-Kov-1
26283: PPUSH
26284: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26288: LD_EXP 61
26292: PPUSH
26293: LD_STRING D11-Pla-2
26295: PPUSH
26296: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26300: LD_VAR 0 1
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: PPUSH
26309: LD_STRING D11-Sol1-2
26311: PPUSH
26312: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26316: LD_EXP 36
26320: PPUSH
26321: LD_STRING D11-JMM-2
26323: PPUSH
26324: CALL_OW 88
// DialogueOff ;
26328: CALL_OW 7
// allowBehemothConstruct := true ;
26332: LD_ADDR_EXP 25
26336: PUSH
26337: LD_INT 1
26339: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26340: LD_STRING M4
26342: PPUSH
26343: CALL_OW 337
// BuildBehemoths ;
26347: CALL 7481 0 0
// repeat wait ( 15 15$00 ) ;
26351: LD_INT 31500
26353: PPUSH
26354: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26358: LD_EXP 27
26362: IFFALSE 26366
// break ;
26364: GO 26398
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26366: LD_INT 267
26368: PPUSH
26369: CALL_OW 274
26373: PPUSH
26374: LD_INT 1
26376: PPUSH
26377: CALL_OW 275
26381: PUSH
26382: LD_INT 1000
26384: GREATEREQUAL
26385: IFFALSE 26391
// BuildBehemoths ;
26387: CALL 7481 0 0
// until not behemothBuilders ;
26391: LD_EXP 70
26395: NOT
26396: IFFALSE 26351
// end ;
26398: PPOPN 1
26400: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26401: LD_EXP 70
26405: NOT
26406: PUSH
26407: LD_EXP 28
26411: NOT
26412: AND
26413: PUSH
26414: LD_EXP 25
26418: AND
26419: IFFALSE 26439
26421: GO 26423
26423: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26424: LD_STRING M4a
26426: PPUSH
26427: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26431: LD_ADDR_EXP 27
26435: PUSH
26436: LD_INT 1
26438: ST_TO_ADDR
// end ;
26439: END
// every 0 0$1 trigger behemothDone do
26440: LD_EXP 28
26444: IFFALSE 26456
26446: GO 26448
26448: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26449: LD_STRING M4b
26451: PPUSH
26452: CALL_OW 337
26456: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26457: LD_EXP 29
26461: NOT
26462: IFFALSE 26658
26464: GO 26466
26466: DISABLE
26467: LD_INT 0
26469: PPUSH
26470: PPUSH
// begin enable ;
26471: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26472: LD_ADDR_VAR 0 1
26476: PUSH
26477: LD_INT 3
26479: PPUSH
26480: CALL 103928 0 1
26484: ST_TO_ADDR
// if not tmp and not behemothDone then
26485: LD_VAR 0 1
26489: NOT
26490: PUSH
26491: LD_EXP 28
26495: NOT
26496: AND
26497: IFFALSE 26533
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26499: LD_ADDR_VAR 0 1
26503: PUSH
26504: LD_INT 22
26506: PUSH
26507: LD_INT 3
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: LD_INT 30
26516: PUSH
26517: LD_INT 37
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PPUSH
26528: CALL_OW 69
26532: ST_TO_ADDR
// if not tmp then
26533: LD_VAR 0 1
26537: NOT
26538: IFFALSE 26542
// exit ;
26540: GO 26658
// for i in tmp do
26542: LD_ADDR_VAR 0 2
26546: PUSH
26547: LD_VAR 0 1
26551: PUSH
26552: FOR_IN
26553: IFFALSE 26656
// if See ( 1 , i ) then
26555: LD_INT 1
26557: PPUSH
26558: LD_VAR 0 2
26562: PPUSH
26563: CALL_OW 292
26567: IFFALSE 26654
// begin if GetType ( i ) = unit_building then
26569: LD_VAR 0 2
26573: PPUSH
26574: CALL_OW 247
26578: PUSH
26579: LD_INT 3
26581: EQUAL
26582: IFFALSE 26620
// begin CenterNowOnUnits ( i ) ;
26584: LD_VAR 0 2
26588: PPUSH
26589: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26593: LD_EXP 36
26597: PPUSH
26598: LD_STRING D17a-JMM-1
26600: PPUSH
26601: CALL_OW 88
// seeBehemoth := true ;
26605: LD_ADDR_EXP 29
26609: PUSH
26610: LD_INT 1
26612: ST_TO_ADDR
// disable ;
26613: DISABLE
// exit ;
26614: POP
26615: POP
26616: GO 26658
// end else
26618: GO 26654
// begin CenterNowOnUnits ( i ) ;
26620: LD_VAR 0 2
26624: PPUSH
26625: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26629: LD_EXP 36
26633: PPUSH
26634: LD_STRING D17b-JMM-1
26636: PPUSH
26637: CALL_OW 88
// seeBehemoth := true ;
26641: LD_ADDR_EXP 29
26645: PUSH
26646: LD_INT 1
26648: ST_TO_ADDR
// disable ;
26649: DISABLE
// exit ;
26650: POP
26651: POP
26652: GO 26658
// end ; end ;
26654: GO 26552
26656: POP
26657: POP
// end ;
26658: PPOPN 2
26660: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
26661: LD_EXP 14
26665: PUSH
26666: LD_INT 116550
26668: GREATEREQUAL
26669: IFFALSE 27845
26671: GO 26673
26673: DISABLE
26674: LD_INT 0
26676: PPUSH
26677: PPUSH
26678: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
26679: LD_INT 2
26681: PPUSH
26682: LD_INT 23
26684: PUSH
26685: LD_INT 3
26687: PUSH
26688: LD_INT 3
26690: PUSH
26691: LD_INT 48
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: LIST
26698: LIST
26699: PUSH
26700: EMPTY
26701: LIST
26702: PPUSH
26703: CALL 55632 0 2
// repeat wait ( 0 0$1 ) ;
26707: LD_INT 35
26709: PPUSH
26710: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
26714: LD_INT 22
26716: PUSH
26717: LD_INT 3
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: PUSH
26724: LD_INT 34
26726: PUSH
26727: LD_INT 48
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PPUSH
26738: CALL_OW 69
26742: IFFALSE 26707
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26744: LD_ADDR_VAR 0 1
26748: PUSH
26749: LD_INT 22
26751: PUSH
26752: LD_INT 3
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: LD_INT 34
26761: PUSH
26762: LD_INT 48
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PUSH
26769: EMPTY
26770: LIST
26771: LIST
26772: PPUSH
26773: CALL_OW 69
26777: PUSH
26778: LD_INT 1
26780: ARRAY
26781: ST_TO_ADDR
// missionStage := 12 ;
26782: LD_ADDR_EXP 15
26786: PUSH
26787: LD_INT 12
26789: ST_TO_ADDR
// platonovHasBomb := true ;
26790: LD_ADDR_EXP 30
26794: PUSH
26795: LD_INT 1
26797: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
26798: LD_VAR 0 1
26802: PPUSH
26803: LD_INT 181
26805: PPUSH
26806: LD_INT 86
26808: PPUSH
26809: CALL_OW 171
// AddComHold ( bomb ) ;
26813: LD_VAR 0 1
26817: PPUSH
26818: CALL_OW 200
// wait ( 0 0$10 ) ;
26822: LD_INT 350
26824: PPUSH
26825: CALL_OW 67
// DialogueOn ;
26829: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
26833: LD_EXP 61
26837: PPUSH
26838: LD_STRING D15-Pla-1
26840: PPUSH
26841: CALL_OW 94
// dec = Query ( Q15a ) ;
26845: LD_ADDR_VAR 0 2
26849: PUSH
26850: LD_STRING Q15a
26852: PPUSH
26853: CALL_OW 97
26857: ST_TO_ADDR
// if dec = 1 then
26858: LD_VAR 0 2
26862: PUSH
26863: LD_INT 1
26865: EQUAL
26866: IFFALSE 26889
// begin Say ( JMM , D15a-JMM-1 ) ;
26868: LD_EXP 36
26872: PPUSH
26873: LD_STRING D15a-JMM-1
26875: PPUSH
26876: CALL_OW 88
// YouLost ( Surrender ) ;
26880: LD_STRING Surrender
26882: PPUSH
26883: CALL_OW 104
// exit ;
26887: GO 27845
// end ; if dec = 2 then
26889: LD_VAR 0 2
26893: PUSH
26894: LD_INT 2
26896: EQUAL
26897: IFFALSE 26966
// begin Say ( JMM , D15b-JMM-1 ) ;
26899: LD_EXP 36
26903: PPUSH
26904: LD_STRING D15b-JMM-1
26906: PPUSH
26907: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
26911: LD_EXP 61
26915: PPUSH
26916: LD_STRING D15b-Pla-1
26918: PPUSH
26919: CALL_OW 94
// DialogueOff ;
26923: CALL_OW 7
// wait ( 3 3$00 ) ;
26927: LD_INT 6300
26929: PPUSH
26930: CALL_OW 67
// DialogueOn ;
26934: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
26938: LD_EXP 36
26942: PPUSH
26943: LD_STRING D15d-JMM-1a
26945: PPUSH
26946: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
26950: LD_EXP 61
26954: PPUSH
26955: LD_STRING D15d-Pla-1
26957: PPUSH
26958: CALL_OW 94
// DialogueOff ;
26962: CALL_OW 7
// end ; if dec = 3 then
26966: LD_VAR 0 2
26970: PUSH
26971: LD_INT 3
26973: EQUAL
26974: IFFALSE 27028
// begin Say ( JMM , D15c-JMM-1 ) ;
26976: LD_EXP 36
26980: PPUSH
26981: LD_STRING D15c-JMM-1
26983: PPUSH
26984: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
26988: LD_EXP 61
26992: PPUSH
26993: LD_STRING D15c-Pla-1
26995: PPUSH
26996: CALL_OW 94
// DialogueOff ;
27000: CALL_OW 7
// wait ( 0 0$15 ) ;
27004: LD_INT 525
27006: PPUSH
27007: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27011: LD_VAR 0 1
27015: PPUSH
27016: LD_INT 60
27018: PPUSH
27019: LD_INT 95
27021: PPUSH
27022: CALL_OW 116
// exit ;
27026: GO 27845
// end ; if dec = 4 then
27028: LD_VAR 0 2
27032: PUSH
27033: LD_INT 4
27035: EQUAL
27036: IFFALSE 27066
// begin Say ( JMM , D15d-JMM-1 ) ;
27038: LD_EXP 36
27042: PPUSH
27043: LD_STRING D15d-JMM-1
27045: PPUSH
27046: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27050: LD_EXP 61
27054: PPUSH
27055: LD_STRING D15d-Pla-1
27057: PPUSH
27058: CALL_OW 94
// DialogueOff ;
27062: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27066: LD_EXP 59
27070: PPUSH
27071: CALL_OW 302
27075: PUSH
27076: LD_EXP 59
27080: PPUSH
27081: CALL_OW 255
27085: PUSH
27086: LD_INT 1
27088: EQUAL
27089: AND
27090: PUSH
27091: LD_INT 22
27093: PUSH
27094: LD_INT 1
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: PUSH
27101: LD_INT 34
27103: PUSH
27104: LD_INT 8
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PPUSH
27115: CALL_OW 69
27119: NOT
27120: AND
27121: IFFALSE 27746
// begin SetSide ( Friend , 8 ) ;
27123: LD_EXP 59
27127: PPUSH
27128: LD_INT 8
27130: PPUSH
27131: CALL_OW 235
// if IsInUnit ( Friend ) then
27135: LD_EXP 59
27139: PPUSH
27140: CALL_OW 310
27144: IFFALSE 27155
// ComExitBuilding ( Friend ) ;
27146: LD_EXP 59
27150: PPUSH
27151: CALL_OW 122
// if IsDriver ( Friend ) then
27155: LD_EXP 59
27159: PPUSH
27160: CALL 101604 0 1
27164: IFFALSE 27175
// ComExitVehicle ( Friend ) ;
27166: LD_EXP 59
27170: PPUSH
27171: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27175: LD_EXP 59
27179: PPUSH
27180: LD_INT 9
27182: PPUSH
27183: LD_INT 2
27185: PPUSH
27186: CALL_OW 171
// wait ( 0 0$05 ) ;
27190: LD_INT 175
27192: PPUSH
27193: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27197: LD_EXP 59
27201: PPUSH
27202: CALL_OW 87
// DialogueOn ;
27206: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27210: LD_EXP 36
27214: PPUSH
27215: LD_STRING D16-JMM-1
27217: PPUSH
27218: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27222: LD_EXP 59
27226: PPUSH
27227: LD_STRING D16-Friend-1
27229: PPUSH
27230: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27234: LD_EXP 36
27238: PPUSH
27239: LD_STRING D16-JMM-2
27241: PPUSH
27242: CALL_OW 88
// DialogueOff ;
27246: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27250: LD_EXP 59
27254: PPUSH
27255: LD_INT 1
27257: PPUSH
27258: CALL_OW 235
// ComHold ( Friend ) ;
27262: LD_EXP 59
27266: PPUSH
27267: CALL_OW 140
// wait ( 0 0$20 ) ;
27271: LD_INT 700
27273: PPUSH
27274: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27278: LD_EXP 59
27282: PPUSH
27283: LD_INT 9
27285: PPUSH
27286: LD_INT 2
27288: PPUSH
27289: CALL_OW 297
27293: PUSH
27294: LD_INT 30
27296: LESS
27297: IFFALSE 27366
// begin SetSide ( Friend , 8 ) ;
27299: LD_EXP 59
27303: PPUSH
27304: LD_INT 8
27306: PPUSH
27307: CALL_OW 235
// if IsInUnit ( Friend ) then
27311: LD_EXP 59
27315: PPUSH
27316: CALL_OW 310
27320: IFFALSE 27331
// ComExitBuilding ( Friend ) ;
27322: LD_EXP 59
27326: PPUSH
27327: CALL_OW 122
// if IsDriver ( Friend ) then
27331: LD_EXP 59
27335: PPUSH
27336: CALL 101604 0 1
27340: IFFALSE 27351
// ComExitVehicle ( Friend ) ;
27342: LD_EXP 59
27346: PPUSH
27347: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27351: LD_EXP 59
27355: PPUSH
27356: LD_INT 9
27358: PPUSH
27359: LD_INT 2
27361: PPUSH
27362: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27366: LD_INT 1050
27368: PPUSH
27369: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27373: LD_INT 22
27375: PUSH
27376: LD_INT 1
27378: PUSH
27379: EMPTY
27380: LIST
27381: LIST
27382: PUSH
27383: LD_INT 34
27385: PUSH
27386: LD_INT 8
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PPUSH
27397: CALL_OW 69
27401: NOT
27402: IFFALSE 27724
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27404: LD_ADDR_VAR 0 3
27408: PUSH
27409: LD_INT 22
27411: PUSH
27412: LD_INT 1
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 26
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 3
27431: PUSH
27432: LD_INT 25
27434: PUSH
27435: LD_INT 12
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 25
27444: PUSH
27445: LD_INT 16
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: LIST
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: LIST
27461: PPUSH
27462: CALL_OW 69
27466: PUSH
27467: LD_EXP 36
27471: PUSH
27472: LD_EXP 38
27476: PUSH
27477: LD_EXP 52
27481: PUSH
27482: LD_EXP 39
27486: PUSH
27487: LD_EXP 40
27491: PUSH
27492: LD_EXP 41
27496: PUSH
27497: LD_EXP 42
27501: PUSH
27502: LD_EXP 43
27506: PUSH
27507: LD_EXP 44
27511: PUSH
27512: LD_EXP 45
27516: PUSH
27517: LD_EXP 46
27521: PUSH
27522: LD_EXP 47
27526: PUSH
27527: LD_EXP 48
27531: PUSH
27532: LD_EXP 49
27536: PUSH
27537: LD_EXP 50
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: DIFF
27559: ST_TO_ADDR
// DialogueOn ;
27560: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27564: LD_EXP 61
27568: PPUSH
27569: LD_STRING D16a-Pla-1
27571: PPUSH
27572: CALL_OW 94
// if Stevens then
27576: LD_EXP 38
27580: IFFALSE 27596
// Say ( Stevens , D16a-Huck-1 ) else
27582: LD_EXP 38
27586: PPUSH
27587: LD_STRING D16a-Huck-1
27589: PPUSH
27590: CALL_OW 88
27594: GO 27638
// if Baker then
27596: LD_EXP 52
27600: IFFALSE 27616
// Say ( Baker , D16a-Huck-1 ) else
27602: LD_EXP 52
27606: PPUSH
27607: LD_STRING D16a-Huck-1
27609: PPUSH
27610: CALL_OW 88
27614: GO 27638
// if tmp then
27616: LD_VAR 0 3
27620: IFFALSE 27638
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27622: LD_VAR 0 3
27626: PUSH
27627: LD_INT 1
27629: ARRAY
27630: PPUSH
27631: LD_STRING D16a-Sol1-1
27633: PPUSH
27634: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27638: LD_EXP 59
27642: PPUSH
27643: CALL_OW 255
27647: PUSH
27648: LD_INT 8
27650: EQUAL
27651: IFFALSE 27667
// Say ( JMM , D16a-JMM-1 ) else
27653: LD_EXP 36
27657: PPUSH
27658: LD_STRING D16a-JMM-1
27660: PPUSH
27661: CALL_OW 88
27665: GO 27703
// begin Say ( JMM , D16a-JMM-1a ) ;
27667: LD_EXP 36
27671: PPUSH
27672: LD_STRING D16a-JMM-1a
27674: PPUSH
27675: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
27679: LD_EXP 59
27683: PPUSH
27684: LD_STRING D16a-Friend-1
27686: PPUSH
27687: CALL_OW 88
// SetSide ( Friend , 3 ) ;
27691: LD_EXP 59
27695: PPUSH
27696: LD_INT 3
27698: PPUSH
27699: CALL_OW 235
// end ; DialogueOff ;
27703: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
27707: LD_VAR 0 1
27711: PPUSH
27712: LD_INT 60
27714: PPUSH
27715: LD_INT 95
27717: PPUSH
27718: CALL_OW 116
// end else
27722: GO 27744
// begin DialogueOn ;
27724: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
27728: LD_EXP 61
27732: PPUSH
27733: LD_STRING D16c-Pla-
27735: PPUSH
27736: CALL_OW 94
// DialogueOff ;
27740: CALL_OW 7
// end ; end else
27744: GO 27845
// begin wait ( 3 3$00 ) ;
27746: LD_INT 6300
27748: PPUSH
27749: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27753: LD_INT 22
27755: PUSH
27756: LD_INT 1
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: LD_INT 34
27765: PUSH
27766: LD_INT 8
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PPUSH
27777: CALL_OW 69
27781: NOT
27782: IFFALSE 27825
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
27784: LD_EXP 61
27788: PPUSH
27789: LD_STRING D16b-Pla-1
27791: PPUSH
27792: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
27796: LD_EXP 36
27800: PPUSH
27801: LD_STRING D16b-JMM-
27803: PPUSH
27804: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
27808: LD_VAR 0 1
27812: PPUSH
27813: LD_INT 60
27815: PPUSH
27816: LD_INT 95
27818: PPUSH
27819: CALL_OW 116
// end else
27823: GO 27845
// begin DialogueOn ;
27825: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
27829: LD_EXP 61
27833: PPUSH
27834: LD_STRING D16c-Pla-
27836: PPUSH
27837: CALL_OW 94
// DialogueOff ;
27841: CALL_OW 7
// end ; end ; end ;
27845: PPOPN 3
27847: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
27848: LD_EXP 14
27852: PUSH
27853: LD_INT 126000
27855: GREATEREQUAL
27856: PUSH
27857: LD_EXP 23
27861: NOT
27862: AND
27863: PUSH
27864: LD_EXP 71
27868: PPUSH
27869: CALL_OW 302
27873: AND
27874: IFFALSE 28232
27876: GO 27878
27878: DISABLE
27879: LD_INT 0
27881: PPUSH
// begin missionStage = 11 ;
27882: LD_ADDR_EXP 15
27886: PUSH
27887: LD_INT 11
27889: ST_TO_ADDR
// DialogueOn ;
27890: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
27894: LD_EXP 71
27898: PPUSH
27899: LD_STRING D9-Roth-1
27901: PPUSH
27902: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
27906: LD_EXP 36
27910: PPUSH
27911: LD_STRING D9-JMM-1
27913: PPUSH
27914: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
27918: LD_EXP 71
27922: PPUSH
27923: LD_STRING D9-Roth-2
27925: PPUSH
27926: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
27930: LD_EXP 71
27934: PPUSH
27935: LD_STRING D9-Roth-2a
27937: PPUSH
27938: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
27942: LD_EXP 61
27946: PPUSH
27947: LD_STRING D9-Pla-2
27949: PPUSH
27950: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
27954: LD_EXP 71
27958: PPUSH
27959: LD_STRING D9-Roth-3
27961: PPUSH
27962: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
27966: LD_EXP 61
27970: PPUSH
27971: LD_STRING D9-Pla-3
27973: PPUSH
27974: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
27978: LD_EXP 71
27982: PPUSH
27983: LD_STRING D9-Roth-4
27985: PPUSH
27986: CALL_OW 94
// dec = Query ( Q9 ) ;
27990: LD_ADDR_VAR 0 1
27994: PUSH
27995: LD_STRING Q9
27997: PPUSH
27998: CALL_OW 97
28002: ST_TO_ADDR
// if dec = 1 then
28003: LD_VAR 0 1
28007: PUSH
28008: LD_INT 1
28010: EQUAL
28011: IFFALSE 28025
// SayRadio ( Roth , D9a-Roth-1 ) ;
28013: LD_EXP 71
28017: PPUSH
28018: LD_STRING D9a-Roth-1
28020: PPUSH
28021: CALL_OW 94
// if dec = 2 then
28025: LD_VAR 0 1
28029: PUSH
28030: LD_INT 2
28032: EQUAL
28033: IFFALSE 28059
// begin Say ( JMM , D9b-JMM-1 ) ;
28035: LD_EXP 36
28039: PPUSH
28040: LD_STRING D9b-JMM-1
28042: PPUSH
28043: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28047: LD_EXP 71
28051: PPUSH
28052: LD_STRING D9b-Roth-1
28054: PPUSH
28055: CALL_OW 94
// end ; if dec = 3 then
28059: LD_VAR 0 1
28063: PUSH
28064: LD_INT 3
28066: EQUAL
28067: IFFALSE 28129
// begin Say ( JMM , D9c-JMM-1 ) ;
28069: LD_EXP 36
28073: PPUSH
28074: LD_STRING D9c-JMM-1
28076: PPUSH
28077: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28081: LD_EXP 71
28085: PPUSH
28086: LD_STRING D9c-Roth-1
28088: PPUSH
28089: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28093: LD_EXP 36
28097: PPUSH
28098: LD_STRING D9c-JMM-2
28100: PPUSH
28101: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28105: LD_EXP 71
28109: PPUSH
28110: LD_STRING D9c-Roth-2
28112: PPUSH
28113: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28117: LD_EXP 36
28121: PPUSH
28122: LD_STRING D9c-JMM-3
28124: PPUSH
28125: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28129: LD_EXP 71
28133: PPUSH
28134: LD_STRING D9c-Roth-3
28136: PPUSH
28137: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28141: LD_EXP 71
28145: PPUSH
28146: LD_STRING D9cont-Roth-1
28148: PPUSH
28149: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28153: LD_EXP 36
28157: PPUSH
28158: LD_STRING D9cont-JMM-1
28160: PPUSH
28161: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28165: LD_EXP 71
28169: PPUSH
28170: LD_STRING D9cont-Roth-2
28172: PPUSH
28173: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28177: LD_EXP 36
28181: PPUSH
28182: LD_STRING D9cont-JMM-2
28184: PPUSH
28185: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28189: LD_EXP 71
28193: PPUSH
28194: LD_STRING D9cont-Roth-3
28196: PPUSH
28197: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28201: LD_EXP 36
28205: PPUSH
28206: LD_STRING D9cont-JMM-3
28208: PPUSH
28209: CALL_OW 88
// DialogueOff ;
28213: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28217: LD_STRING M3
28219: PPUSH
28220: CALL_OW 337
// allianceActive := true ;
28224: LD_ADDR_EXP 31
28228: PUSH
28229: LD_INT 1
28231: ST_TO_ADDR
// end ;
28232: PPOPN 1
28234: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28235: LD_EXP 61
28239: PPUSH
28240: CALL_OW 301
28244: PUSH
28245: LD_EXP 64
28249: PPUSH
28250: CALL_OW 301
28254: AND
28255: PUSH
28256: LD_INT 22
28258: PUSH
28259: LD_INT 3
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 21
28268: PUSH
28269: LD_INT 1
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 50
28278: PUSH
28279: EMPTY
28280: LIST
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: LIST
28286: PPUSH
28287: CALL_OW 69
28291: PUSH
28292: LD_INT 7
28294: PUSH
28295: LD_INT 8
28297: PUSH
28298: LD_INT 9
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: LIST
28305: PUSH
28306: LD_OWVAR 67
28310: ARRAY
28311: LESS
28312: AND
28313: IFFALSE 29084
28315: GO 28317
28317: DISABLE
28318: LD_INT 0
28320: PPUSH
28321: PPUSH
28322: PPUSH
28323: PPUSH
// begin MC_Kill ( 1 ) ;
28324: LD_INT 1
28326: PPUSH
28327: CALL 33553 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28331: LD_INT 1
28333: PPUSH
28334: LD_INT 3
28336: PPUSH
28337: LD_INT 1
28339: PPUSH
28340: LD_INT 1
28342: PPUSH
28343: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28347: LD_ADDR_VAR 0 1
28351: PUSH
28352: LD_INT 22
28354: PUSH
28355: LD_INT 3
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PUSH
28362: LD_INT 21
28364: PUSH
28365: LD_INT 1
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 24
28374: PUSH
28375: LD_INT 900
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: LIST
28386: PPUSH
28387: CALL_OW 69
28391: PUSH
28392: FOR_IN
28393: IFFALSE 28424
// if GetSex ( i ) = sex_male then
28395: LD_VAR 0 1
28399: PPUSH
28400: CALL_OW 258
28404: PUSH
28405: LD_INT 1
28407: EQUAL
28408: IFFALSE 28422
// begin tmp = i ;
28410: LD_ADDR_VAR 0 2
28414: PUSH
28415: LD_VAR 0 1
28419: ST_TO_ADDR
// break ;
28420: GO 28424
// end ;
28422: GO 28392
28424: POP
28425: POP
// if tmp = 0 then
28426: LD_VAR 0 2
28430: PUSH
28431: LD_INT 0
28433: EQUAL
28434: IFFALSE 28488
// begin uc_side = 3 ;
28436: LD_ADDR_OWVAR 20
28440: PUSH
28441: LD_INT 3
28443: ST_TO_ADDR
// uc_nation = 3 ;
28444: LD_ADDR_OWVAR 21
28448: PUSH
28449: LD_INT 3
28451: ST_TO_ADDR
// hc_name =  ;
28452: LD_ADDR_OWVAR 26
28456: PUSH
28457: LD_STRING 
28459: ST_TO_ADDR
// hc_gallery =  ;
28460: LD_ADDR_OWVAR 33
28464: PUSH
28465: LD_STRING 
28467: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28468: LD_INT 1
28470: PPUSH
28471: LD_INT 10
28473: PPUSH
28474: CALL_OW 381
// tmp = CreateHuman ;
28478: LD_ADDR_VAR 0 2
28482: PUSH
28483: CALL_OW 44
28487: ST_TO_ADDR
// end ; DialogueOn ;
28488: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28492: LD_VAR 0 2
28496: PPUSH
28497: LD_STRING DSurrenderRussians-RSol1-1a
28499: PPUSH
28500: CALL_OW 88
// DialogueOff ;
28504: CALL_OW 7
// russianDestroyed := true ;
28508: LD_ADDR_EXP 21
28512: PUSH
28513: LD_INT 1
28515: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28516: LD_INT 22
28518: PUSH
28519: LD_INT 3
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 21
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: PPUSH
28540: CALL_OW 69
28544: PPUSH
28545: CALL_OW 122
// wait ( 0 0$1 ) ;
28549: LD_INT 35
28551: PPUSH
28552: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28556: LD_INT 22
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: LD_INT 21
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PPUSH
28580: CALL_OW 69
28584: PPUSH
28585: LD_INT 25
28587: PPUSH
28588: CALL_OW 173
// wait ( 0 0$10 ) ;
28592: LD_INT 350
28594: PPUSH
28595: CALL_OW 67
// PrepareOmarInvasion ;
28599: CALL 13504 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28603: LD_ADDR_VAR 0 2
28607: PUSH
28608: LD_EXP 89
28612: PPUSH
28613: CALL_OW 250
28617: PUSH
28618: LD_EXP 89
28622: PPUSH
28623: CALL_OW 251
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28632: LD_VAR 0 2
28636: PUSH
28637: LD_INT 1
28639: ARRAY
28640: PPUSH
28641: LD_VAR 0 2
28645: PUSH
28646: LD_INT 2
28648: ARRAY
28649: PPUSH
28650: LD_INT 1
28652: PPUSH
28653: LD_INT 8
28655: NEG
28656: PPUSH
28657: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
28661: LD_EXP 89
28665: PPUSH
28666: CALL_OW 87
// DialogueOn ;
28670: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
28674: LD_EXP 36
28678: PPUSH
28679: LD_STRING D19-JMM-1
28681: PPUSH
28682: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
28686: LD_ADDR_VAR 0 3
28690: PUSH
28691: LD_INT 22
28693: PUSH
28694: LD_INT 1
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 26
28703: PUSH
28704: LD_INT 1
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 2
28713: PUSH
28714: LD_INT 25
28716: PUSH
28717: LD_INT 1
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 25
28726: PUSH
28727: LD_INT 2
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 25
28736: PUSH
28737: LD_INT 3
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 25
28746: PUSH
28747: LD_INT 4
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 25
28756: PUSH
28757: LD_INT 5
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 25
28766: PUSH
28767: LD_INT 8
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: LIST
28787: PPUSH
28788: CALL_OW 69
28792: PUSH
28793: LD_EXP 36
28797: PUSH
28798: LD_EXP 37
28802: PUSH
28803: LD_EXP 38
28807: PUSH
28808: LD_EXP 39
28812: PUSH
28813: LD_EXP 40
28817: PUSH
28818: LD_EXP 41
28822: PUSH
28823: LD_EXP 42
28827: PUSH
28828: LD_EXP 43
28832: PUSH
28833: LD_EXP 44
28837: PUSH
28838: LD_EXP 45
28842: PUSH
28843: LD_EXP 46
28847: PUSH
28848: LD_EXP 47
28852: PUSH
28853: LD_EXP 48
28857: PUSH
28858: LD_EXP 49
28862: PUSH
28863: LD_EXP 50
28867: PUSH
28868: LD_EXP 51
28872: PUSH
28873: LD_EXP 52
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: DIFF
28897: ST_TO_ADDR
// if tmp2 then
28898: LD_VAR 0 3
28902: IFFALSE 28920
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
28904: LD_VAR 0 3
28908: PUSH
28909: LD_INT 1
28911: ARRAY
28912: PPUSH
28913: LD_STRING D19-Sol1-1
28915: PPUSH
28916: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
28920: LD_EXP 36
28924: PPUSH
28925: LD_STRING D19-JMM-2
28927: PPUSH
28928: CALL_OW 88
// DialogueOff ;
28932: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
28936: LD_VAR 0 2
28940: PUSH
28941: LD_INT 1
28943: ARRAY
28944: PPUSH
28945: LD_VAR 0 2
28949: PUSH
28950: LD_INT 2
28952: ARRAY
28953: PPUSH
28954: LD_INT 1
28956: PPUSH
28957: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
28961: LD_STRING M5
28963: PPUSH
28964: CALL_OW 337
// omarOnMotherLode := false ;
28968: LD_ADDR_VAR 0 4
28972: PUSH
28973: LD_INT 0
28975: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28976: LD_INT 35
28978: PPUSH
28979: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
28983: LD_EXP 89
28987: PPUSH
28988: LD_INT 215
28990: PPUSH
28991: LD_INT 100
28993: PPUSH
28994: CALL_OW 297
28998: PUSH
28999: LD_INT 10
29001: LESS
29002: PUSH
29003: LD_VAR 0 4
29007: NOT
29008: AND
29009: IFFALSE 29043
// begin omarOnMotherLode := true ;
29011: LD_ADDR_VAR 0 4
29015: PUSH
29016: LD_INT 1
29018: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29019: LD_EXP 36
29023: PPUSH
29024: LD_STRING D19b-JMM-1
29026: PPUSH
29027: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29031: LD_EXP 89
29035: PPUSH
29036: LD_STRING DOmarContam-Omar-1
29038: PPUSH
29039: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29043: LD_EXP 89
29047: PPUSH
29048: CALL_OW 301
29052: IFFALSE 28976
// Say ( JMM , D19a-JMM-1 ) ;
29054: LD_EXP 36
29058: PPUSH
29059: LD_STRING D19a-JMM-1
29061: PPUSH
29062: CALL_OW 88
// if Heike then
29066: LD_EXP 90
29070: IFFALSE 29084
// Say ( Heike , D19a-Hke-1 ) ;
29072: LD_EXP 90
29076: PPUSH
29077: LD_STRING D19a-Hke-1
29079: PPUSH
29080: CALL_OW 88
// end ;
29084: PPOPN 4
29086: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29087: LD_INT 22
29089: PUSH
29090: LD_INT 3
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 21
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PPUSH
29111: CALL_OW 69
29115: PUSH
29116: LD_EXP 21
29120: AND
29121: IFFALSE 29189
29123: GO 29125
29125: DISABLE
29126: LD_INT 0
29128: PPUSH
29129: PPUSH
// begin enable ;
29130: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29131: LD_ADDR_VAR 0 2
29135: PUSH
29136: LD_INT 25
29138: PPUSH
29139: LD_INT 22
29141: PUSH
29142: LD_INT 3
29144: PUSH
29145: EMPTY
29146: LIST
29147: LIST
29148: PPUSH
29149: CALL_OW 70
29153: ST_TO_ADDR
// if not tmp then
29154: LD_VAR 0 2
29158: NOT
29159: IFFALSE 29163
// exit ;
29161: GO 29189
// for i in tmp do
29163: LD_ADDR_VAR 0 1
29167: PUSH
29168: LD_VAR 0 2
29172: PUSH
29173: FOR_IN
29174: IFFALSE 29187
// RemoveUnit ( i ) ;
29176: LD_VAR 0 1
29180: PPUSH
29181: CALL_OW 64
29185: GO 29173
29187: POP
29188: POP
// end ;
29189: PPOPN 2
29191: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29192: LD_INT 22
29194: PUSH
29195: LD_INT 7
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: LD_INT 21
29204: PUSH
29205: LD_INT 1
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PPUSH
29216: CALL_OW 69
29220: PUSH
29221: LD_INT 6
29223: LESS
29224: IFFALSE 29675
29226: GO 29228
29228: DISABLE
29229: LD_INT 0
29231: PPUSH
29232: PPUSH
// begin MC_Kill ( 1 ) ;
29233: LD_INT 1
29235: PPUSH
29236: CALL 33553 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29240: LD_INT 7
29242: PPUSH
29243: LD_INT 1
29245: PPUSH
29246: LD_INT 1
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29256: LD_ADDR_VAR 0 1
29260: PUSH
29261: LD_INT 22
29263: PUSH
29264: LD_INT 7
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 26
29273: PUSH
29274: LD_INT 1
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PPUSH
29285: CALL_OW 69
29289: PUSH
29290: LD_EXP 71
29294: DIFF
29295: ST_TO_ADDR
// if tmp then
29296: LD_VAR 0 1
29300: IFFALSE 29318
// tmp := tmp [ 1 ] else
29302: LD_ADDR_VAR 0 1
29306: PUSH
29307: LD_VAR 0 1
29311: PUSH
29312: LD_INT 1
29314: ARRAY
29315: ST_TO_ADDR
29316: GO 29354
// begin uc_side := 7 ;
29318: LD_ADDR_OWVAR 20
29322: PUSH
29323: LD_INT 7
29325: ST_TO_ADDR
// uc_nation := 1 ;
29326: LD_ADDR_OWVAR 21
29330: PUSH
29331: LD_INT 1
29333: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29334: LD_INT 1
29336: PPUSH
29337: LD_INT 8
29339: PPUSH
29340: CALL_OW 384
// tmp := CreateHuman ;
29344: LD_ADDR_VAR 0 1
29348: PUSH
29349: CALL_OW 44
29353: ST_TO_ADDR
// end ; DialogueOn ;
29354: CALL_OW 6
// if IsOK ( Roth ) then
29358: LD_EXP 71
29362: PPUSH
29363: CALL_OW 302
29367: IFFALSE 29381
// Say ( JMM , DAb-JMM-1 ) ;
29369: LD_EXP 36
29373: PPUSH
29374: LD_STRING DAb-JMM-1
29376: PPUSH
29377: CALL_OW 88
// if IsOK ( Roth ) then
29381: LD_EXP 71
29385: PPUSH
29386: CALL_OW 302
29390: IFFALSE 29414
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29392: LD_EXP 71
29396: PPUSH
29397: LD_STRING DSurrenderAlliance-Roth-1
29399: PPUSH
29400: CALL_OW 88
// RothCaptured := true ;
29404: LD_ADDR_EXP 33
29408: PUSH
29409: LD_INT 1
29411: ST_TO_ADDR
// end else
29412: GO 29426
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29414: LD_VAR 0 1
29418: PPUSH
29419: LD_STRING DSurrenderAlliance-Sci1-1
29421: PPUSH
29422: CALL_OW 88
// DialogueOff ;
29426: CALL_OW 7
// allianceDestroyed := true ;
29430: LD_ADDR_EXP 23
29434: PUSH
29435: LD_INT 1
29437: ST_TO_ADDR
// if trueAmericans then
29438: LD_EXP 35
29442: IFFALSE 29518
// begin if trueAmericans = 1 then
29444: LD_EXP 35
29448: PUSH
29449: LD_INT 1
29451: EQUAL
29452: IFFALSE 29468
// Say ( JMM , DAb-JMM-1a ) else
29454: LD_EXP 36
29458: PPUSH
29459: LD_STRING DAb-JMM-1a
29461: PPUSH
29462: CALL_OW 88
29466: GO 29480
// Say ( JMM , DAb-JMM-1b ) ;
29468: LD_EXP 36
29472: PPUSH
29473: LD_STRING DAb-JMM-1b
29475: PPUSH
29476: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29480: LD_EXP 35
29484: PPUSH
29485: CALL_OW 87
// for i in trueAmericans do
29489: LD_ADDR_VAR 0 2
29493: PUSH
29494: LD_EXP 35
29498: PUSH
29499: FOR_IN
29500: IFFALSE 29516
// SetSide ( i , 1 ) ;
29502: LD_VAR 0 2
29506: PPUSH
29507: LD_INT 1
29509: PPUSH
29510: CALL_OW 235
29514: GO 29499
29516: POP
29517: POP
// end ; repeat wait ( 0 0$1 ) ;
29518: LD_INT 35
29520: PPUSH
29521: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29525: LD_ADDR_VAR 0 2
29529: PUSH
29530: LD_INT 22
29532: PUSH
29533: LD_INT 7
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 21
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PPUSH
29554: CALL_OW 69
29558: PUSH
29559: FOR_IN
29560: IFFALSE 29642
// begin if IsInUnit ( i ) then
29562: LD_VAR 0 2
29566: PPUSH
29567: CALL_OW 310
29571: IFFALSE 29582
// ComExitBuilding ( i ) ;
29573: LD_VAR 0 2
29577: PPUSH
29578: CALL_OW 122
// if IsDriver ( i ) then
29582: LD_VAR 0 2
29586: PPUSH
29587: CALL 101604 0 1
29591: IFFALSE 29602
// ComExitVehicle ( i ) ;
29593: LD_VAR 0 2
29597: PPUSH
29598: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29602: LD_VAR 0 2
29606: PPUSH
29607: LD_INT 26
29609: PPUSH
29610: CALL_OW 308
29614: NOT
29615: IFFALSE 29631
// AddComMoveToArea ( i , allianceEscapeArea ) else
29617: LD_VAR 0 2
29621: PPUSH
29622: LD_INT 26
29624: PPUSH
29625: CALL_OW 173
29629: GO 29640
// RemoveUnit ( i ) ;
29631: LD_VAR 0 2
29635: PPUSH
29636: CALL_OW 64
// end ;
29640: GO 29559
29642: POP
29643: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29644: LD_INT 22
29646: PUSH
29647: LD_INT 7
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 21
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: PPUSH
29668: CALL_OW 69
29672: NOT
29673: IFFALSE 29518
// end ;
29675: PPOPN 2
29677: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
29678: LD_INT 0
29680: PPUSH
29681: PPUSH
// if not unit then
29682: LD_VAR 0 1
29686: NOT
29687: IFFALSE 29691
// exit ;
29689: GO 31189
// DoNotAttack ( 7 , unit ) ;
29691: LD_INT 7
29693: PPUSH
29694: LD_VAR 0 1
29698: PPUSH
29699: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
29703: LD_VAR 0 1
29707: PPUSH
29708: LD_INT 260
29710: PPUSH
29711: LD_INT 235
29713: PPUSH
29714: LD_INT 3
29716: PPUSH
29717: LD_INT 1
29719: PPUSH
29720: CALL_OW 483
// SetSide ( unit , 4 ) ;
29724: LD_VAR 0 1
29728: PPUSH
29729: LD_INT 4
29731: PPUSH
29732: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
29736: LD_ADDR_EXP 34
29740: PUSH
29741: LD_EXP 34
29745: PUSH
29746: LD_INT 1
29748: PLUS
29749: ST_TO_ADDR
// wait ( 0 0$2 ) ;
29750: LD_INT 70
29752: PPUSH
29753: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
29757: LD_INT 260
29759: PPUSH
29760: LD_INT 235
29762: PPUSH
29763: LD_INT 1
29765: PPUSH
29766: LD_INT 8
29768: NEG
29769: PPUSH
29770: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
29774: LD_VAR 0 1
29778: PPUSH
29779: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
29783: LD_VAR 0 1
29787: PPUSH
29788: LD_EXP 71
29792: PPUSH
29793: CALL_OW 119
// DialogueOn ;
29797: CALL_OW 6
// case unit of JMM :
29801: LD_VAR 0 1
29805: PUSH
29806: LD_EXP 36
29810: DOUBLE
29811: EQUAL
29812: IFTRUE 29816
29814: GO 29831
29816: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
29817: LD_EXP 36
29821: PPUSH
29822: LD_STRING DA1-JMM-1
29824: PPUSH
29825: CALL_OW 91
29829: GO 30273
29831: LD_EXP 37
29835: DOUBLE
29836: EQUAL
29837: IFTRUE 29841
29839: GO 29856
29841: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
29842: LD_EXP 37
29846: PPUSH
29847: LD_STRING DA1-Joan-1
29849: PPUSH
29850: CALL_OW 91
29854: GO 30273
29856: LD_EXP 39
29860: DOUBLE
29861: EQUAL
29862: IFTRUE 29866
29864: GO 29881
29866: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
29867: LD_EXP 39
29871: PPUSH
29872: LD_STRING DA1-Lisa-1
29874: PPUSH
29875: CALL_OW 91
29879: GO 30273
29881: LD_EXP 40
29885: DOUBLE
29886: EQUAL
29887: IFTRUE 29891
29889: GO 29906
29891: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
29892: LD_EXP 40
29896: PPUSH
29897: LD_STRING DA1-Don-1
29899: PPUSH
29900: CALL_OW 91
29904: GO 30273
29906: LD_EXP 47
29910: DOUBLE
29911: EQUAL
29912: IFTRUE 29916
29914: GO 29931
29916: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
29917: LD_EXP 47
29921: PPUSH
29922: LD_STRING DA1-Corn-1
29924: PPUSH
29925: CALL_OW 91
29929: GO 30273
29931: LD_EXP 43
29935: DOUBLE
29936: EQUAL
29937: IFTRUE 29941
29939: GO 29956
29941: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
29942: LD_EXP 43
29946: PPUSH
29947: LD_STRING DA1-Den-1
29949: PPUSH
29950: CALL_OW 91
29954: GO 30273
29956: LD_EXP 41
29960: DOUBLE
29961: EQUAL
29962: IFTRUE 29966
29964: GO 29981
29966: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
29967: LD_EXP 41
29971: PPUSH
29972: LD_STRING DA1-Bobby-1
29974: PPUSH
29975: CALL_OW 91
29979: GO 30273
29981: LD_EXP 45
29985: DOUBLE
29986: EQUAL
29987: IFTRUE 29991
29989: GO 30006
29991: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
29992: LD_EXP 45
29996: PPUSH
29997: LD_STRING DA1-Glad-1
29999: PPUSH
30000: CALL_OW 91
30004: GO 30273
30006: LD_EXP 42
30010: DOUBLE
30011: EQUAL
30012: IFTRUE 30016
30014: GO 30031
30016: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30017: LD_EXP 42
30021: PPUSH
30022: LD_STRING DA1-Cyrus-1
30024: PPUSH
30025: CALL_OW 91
30029: GO 30273
30031: LD_EXP 38
30035: DOUBLE
30036: EQUAL
30037: IFTRUE 30041
30039: GO 30056
30041: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30042: LD_EXP 38
30046: PPUSH
30047: LD_STRING DA1-Huck-1
30049: PPUSH
30050: CALL_OW 91
30054: GO 30273
30056: LD_EXP 52
30060: DOUBLE
30061: EQUAL
30062: IFTRUE 30066
30064: GO 30081
30066: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30067: LD_EXP 52
30071: PPUSH
30072: LD_STRING DA1-Huck-1
30074: PPUSH
30075: CALL_OW 91
30079: GO 30273
30081: LD_EXP 44
30085: DOUBLE
30086: EQUAL
30087: IFTRUE 30091
30089: GO 30106
30091: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30092: LD_EXP 44
30096: PPUSH
30097: LD_STRING DA1-Brown-1
30099: PPUSH
30100: CALL_OW 91
30104: GO 30273
30106: LD_EXP 48
30110: DOUBLE
30111: EQUAL
30112: IFTRUE 30116
30114: GO 30131
30116: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30117: LD_EXP 48
30121: PPUSH
30122: LD_STRING DA1-Gary-1
30124: PPUSH
30125: CALL_OW 91
30129: GO 30273
30131: LD_EXP 51
30135: DOUBLE
30136: EQUAL
30137: IFTRUE 30141
30139: GO 30156
30141: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30142: LD_EXP 51
30146: PPUSH
30147: LD_STRING DA1-Con-1
30149: PPUSH
30150: CALL_OW 91
30154: GO 30273
30156: LD_EXP 57
30160: DOUBLE
30161: EQUAL
30162: IFTRUE 30166
30164: GO 30181
30166: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30167: LD_EXP 57
30171: PPUSH
30172: LD_STRING DA1-Kurt-1
30174: PPUSH
30175: CALL_OW 91
30179: GO 30273
30181: LD_EXP 50
30185: DOUBLE
30186: EQUAL
30187: IFTRUE 30191
30189: GO 30206
30191: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30192: LD_EXP 50
30196: PPUSH
30197: LD_STRING DA1-Yam-1
30199: PPUSH
30200: CALL_OW 91
30204: GO 30273
30206: LD_EXP 49
30210: DOUBLE
30211: EQUAL
30212: IFTRUE 30216
30214: GO 30231
30216: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30217: LD_EXP 49
30221: PPUSH
30222: LD_STRING DA1-Frank-1
30224: PPUSH
30225: CALL_OW 91
30229: GO 30273
30231: POP
// begin if GetSex ( unit ) = sex_male then
30232: LD_VAR 0 1
30236: PPUSH
30237: CALL_OW 258
30241: PUSH
30242: LD_INT 1
30244: EQUAL
30245: IFFALSE 30261
// ForceSay ( unit , DA1-Sol1-1 ) else
30247: LD_VAR 0 1
30251: PPUSH
30252: LD_STRING DA1-Sol1-1
30254: PPUSH
30255: CALL_OW 91
30259: GO 30273
// ForceSay ( unit , DA1-FSol1-1 ) ;
30261: LD_VAR 0 1
30265: PPUSH
30266: LD_STRING DA1-FSol1-1
30268: PPUSH
30269: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30273: LD_EXP 71
30277: PPUSH
30278: LD_STRING DA-Roth-1
30280: PPUSH
30281: CALL_OW 88
// if capturedUnit = 1 then
30285: LD_EXP 34
30289: PUSH
30290: LD_INT 1
30292: EQUAL
30293: IFFALSE 30321
// begin Say ( Simms , DA-Sim-1 ) ;
30295: LD_EXP 72
30299: PPUSH
30300: LD_STRING DA-Sim-1
30302: PPUSH
30303: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30307: LD_EXP 71
30311: PPUSH
30312: LD_STRING DA-Roth-2
30314: PPUSH
30315: CALL_OW 88
// end else
30319: GO 30333
// Say ( Simms , DA-Sim-2 ) ;
30321: LD_EXP 72
30325: PPUSH
30326: LD_STRING DA-Sim-2
30328: PPUSH
30329: CALL_OW 88
// case unit of JMM :
30333: LD_VAR 0 1
30337: PUSH
30338: LD_EXP 36
30342: DOUBLE
30343: EQUAL
30344: IFTRUE 30348
30346: GO 30363
30348: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30349: LD_EXP 36
30353: PPUSH
30354: LD_STRING DA1-JMM-1a
30356: PPUSH
30357: CALL_OW 91
30361: GO 30870
30363: LD_EXP 37
30367: DOUBLE
30368: EQUAL
30369: IFTRUE 30373
30371: GO 30388
30373: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30374: LD_EXP 37
30378: PPUSH
30379: LD_STRING DA1-Joan-1a
30381: PPUSH
30382: CALL_OW 91
30386: GO 30870
30388: LD_EXP 39
30392: DOUBLE
30393: EQUAL
30394: IFTRUE 30398
30396: GO 30413
30398: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30399: LD_EXP 39
30403: PPUSH
30404: LD_STRING DA1-Lisa-1a
30406: PPUSH
30407: CALL_OW 91
30411: GO 30870
30413: LD_EXP 40
30417: DOUBLE
30418: EQUAL
30419: IFTRUE 30423
30421: GO 30438
30423: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30424: LD_EXP 40
30428: PPUSH
30429: LD_STRING DA1-Don-1a
30431: PPUSH
30432: CALL_OW 91
30436: GO 30870
30438: LD_EXP 47
30442: DOUBLE
30443: EQUAL
30444: IFTRUE 30448
30446: GO 30463
30448: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30449: LD_EXP 47
30453: PPUSH
30454: LD_STRING DA1-Corn-1a
30456: PPUSH
30457: CALL_OW 91
30461: GO 30870
30463: LD_EXP 43
30467: DOUBLE
30468: EQUAL
30469: IFTRUE 30473
30471: GO 30488
30473: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30474: LD_EXP 43
30478: PPUSH
30479: LD_STRING DA1-Den-1a
30481: PPUSH
30482: CALL_OW 91
30486: GO 30870
30488: LD_EXP 41
30492: DOUBLE
30493: EQUAL
30494: IFTRUE 30498
30496: GO 30513
30498: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30499: LD_EXP 41
30503: PPUSH
30504: LD_STRING DA1-Bobby-1a
30506: PPUSH
30507: CALL_OW 91
30511: GO 30870
30513: LD_EXP 45
30517: DOUBLE
30518: EQUAL
30519: IFTRUE 30523
30521: GO 30538
30523: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30524: LD_EXP 45
30528: PPUSH
30529: LD_STRING DA1-Glad-1a
30531: PPUSH
30532: CALL_OW 91
30536: GO 30870
30538: LD_EXP 42
30542: DOUBLE
30543: EQUAL
30544: IFTRUE 30548
30546: GO 30563
30548: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30549: LD_EXP 42
30553: PPUSH
30554: LD_STRING DA1-Cyrus-1a
30556: PPUSH
30557: CALL_OW 91
30561: GO 30870
30563: LD_EXP 38
30567: DOUBLE
30568: EQUAL
30569: IFTRUE 30573
30571: GO 30588
30573: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30574: LD_EXP 38
30578: PPUSH
30579: LD_STRING DA1-Huck-1a
30581: PPUSH
30582: CALL_OW 91
30586: GO 30870
30588: LD_EXP 52
30592: DOUBLE
30593: EQUAL
30594: IFTRUE 30598
30596: GO 30613
30598: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30599: LD_EXP 52
30603: PPUSH
30604: LD_STRING DA1-Huck-1a
30606: PPUSH
30607: CALL_OW 91
30611: GO 30870
30613: LD_EXP 44
30617: DOUBLE
30618: EQUAL
30619: IFTRUE 30623
30621: GO 30638
30623: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30624: LD_EXP 44
30628: PPUSH
30629: LD_STRING DA1-Brown-1a
30631: PPUSH
30632: CALL_OW 91
30636: GO 30870
30638: LD_EXP 48
30642: DOUBLE
30643: EQUAL
30644: IFTRUE 30648
30646: GO 30663
30648: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
30649: LD_EXP 48
30653: PPUSH
30654: LD_STRING DA1-Gary-1a
30656: PPUSH
30657: CALL_OW 91
30661: GO 30870
30663: LD_EXP 51
30667: DOUBLE
30668: EQUAL
30669: IFTRUE 30673
30671: GO 30688
30673: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
30674: LD_EXP 51
30678: PPUSH
30679: LD_STRING DA1-Con-1a
30681: PPUSH
30682: CALL_OW 91
30686: GO 30870
30688: LD_EXP 57
30692: DOUBLE
30693: EQUAL
30694: IFTRUE 30698
30696: GO 30713
30698: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
30699: LD_EXP 57
30703: PPUSH
30704: LD_STRING DA1-Kurt-1a
30706: PPUSH
30707: CALL_OW 91
30711: GO 30870
30713: LD_EXP 50
30717: DOUBLE
30718: EQUAL
30719: IFTRUE 30723
30721: GO 30738
30723: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
30724: LD_EXP 50
30728: PPUSH
30729: LD_STRING DA1-Yam-1a
30731: PPUSH
30732: CALL_OW 91
30736: GO 30870
30738: LD_EXP 49
30742: DOUBLE
30743: EQUAL
30744: IFTRUE 30748
30746: GO 30763
30748: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
30749: LD_EXP 49
30753: PPUSH
30754: LD_STRING DA1-Frank-1a
30756: PPUSH
30757: CALL_OW 91
30761: GO 30870
30763: POP
// begin join := rand ( 0 , 1 ) ;
30764: LD_ADDR_VAR 0 3
30768: PUSH
30769: LD_INT 0
30771: PPUSH
30772: LD_INT 1
30774: PPUSH
30775: CALL_OW 12
30779: ST_TO_ADDR
// if join then
30780: LD_VAR 0 3
30784: IFFALSE 30829
// begin if GetSex ( unit ) = sex_male then
30786: LD_VAR 0 1
30790: PPUSH
30791: CALL_OW 258
30795: PUSH
30796: LD_INT 1
30798: EQUAL
30799: IFFALSE 30815
// ForceSay ( unit , DA1-Sol1-1b ) else
30801: LD_VAR 0 1
30805: PPUSH
30806: LD_STRING DA1-Sol1-1b
30808: PPUSH
30809: CALL_OW 91
30813: GO 30827
// ForceSay ( unit , DA1-FSol1-1b ) ;
30815: LD_VAR 0 1
30819: PPUSH
30820: LD_STRING DA1-FSol1-1b
30822: PPUSH
30823: CALL_OW 91
// end else
30827: GO 30870
// begin if GetSex ( unit ) = sex_male then
30829: LD_VAR 0 1
30833: PPUSH
30834: CALL_OW 258
30838: PUSH
30839: LD_INT 1
30841: EQUAL
30842: IFFALSE 30858
// ForceSay ( unit , DA1-Sol1-1a ) else
30844: LD_VAR 0 1
30848: PPUSH
30849: LD_STRING DA1-Sol1-1a
30851: PPUSH
30852: CALL_OW 91
30856: GO 30870
// ForceSay ( unit , DA1-FSol1-1a ) ;
30858: LD_VAR 0 1
30862: PPUSH
30863: LD_STRING DA1-FSol1-1a
30865: PPUSH
30866: CALL_OW 91
// end ; end ; end ; if unit = JMM then
30870: LD_VAR 0 1
30874: PUSH
30875: LD_EXP 36
30879: EQUAL
30880: IFFALSE 30891
// begin YouLost ( JMMCaptured ) ;
30882: LD_STRING JMMCaptured
30884: PPUSH
30885: CALL_OW 104
// exit ;
30889: GO 31189
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
30891: LD_VAR 0 1
30895: PUSH
30896: LD_EXP 40
30900: PUSH
30901: LD_EXP 43
30905: PUSH
30906: LD_EXP 41
30910: PUSH
30911: LD_EXP 38
30915: PUSH
30916: LD_EXP 52
30920: PUSH
30921: LD_EXP 44
30925: PUSH
30926: LD_EXP 50
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: IN
30940: PUSH
30941: LD_VAR 0 3
30945: OR
30946: IFFALSE 31045
// begin Say ( Roth , DA-Roth-3 ) ;
30948: LD_EXP 71
30952: PPUSH
30953: LD_STRING DA-Roth-3
30955: PPUSH
30956: CALL_OW 88
// SetSide ( unit , 7 ) ;
30960: LD_VAR 0 1
30964: PPUSH
30965: LD_INT 7
30967: PPUSH
30968: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
30972: LD_ADDR_EXP 99
30976: PUSH
30977: LD_EXP 99
30981: PPUSH
30982: LD_INT 1
30984: PPUSH
30985: LD_EXP 99
30989: PUSH
30990: LD_INT 1
30992: ARRAY
30993: PUSH
30994: LD_VAR 0 1
30998: ADD
30999: PPUSH
31000: CALL_OW 1
31004: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31005: LD_INT 260
31007: PPUSH
31008: LD_INT 235
31010: PPUSH
31011: LD_INT 1
31013: PPUSH
31014: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31018: LD_VAR 0 1
31022: PPUSH
31023: LD_INT 1000
31025: PPUSH
31026: CALL_OW 234
// DialogueOff ;
31030: CALL_OW 7
// ComFree ( unit ) ;
31034: LD_VAR 0 1
31038: PPUSH
31039: CALL_OW 139
// end else
31043: GO 31126
// begin Say ( Roth , DA-Roth-3a ) ;
31045: LD_EXP 71
31049: PPUSH
31050: LD_STRING DA-Roth-3a
31052: PPUSH
31053: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31057: LD_ADDR_EXP 35
31061: PUSH
31062: LD_EXP 35
31066: PUSH
31067: LD_VAR 0 1
31071: ADD
31072: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31073: LD_INT 260
31075: PPUSH
31076: LD_INT 235
31078: PPUSH
31079: LD_INT 1
31081: PPUSH
31082: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31086: LD_VAR 0 1
31090: PPUSH
31091: LD_INT 1000
31093: PPUSH
31094: CALL_OW 234
// DialogueOff ;
31098: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31102: LD_VAR 0 1
31106: PPUSH
31107: LD_INT 272
31109: PPUSH
31110: LD_INT 254
31112: PPUSH
31113: CALL_OW 111
// AddComHold ( unit ) ;
31117: LD_VAR 0 1
31121: PPUSH
31122: CALL_OW 200
// end ; if capturedUnit = 1 then
31126: LD_EXP 34
31130: PUSH
31131: LD_INT 1
31133: EQUAL
31134: IFFALSE 31189
// begin DialogueOn ;
31136: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31140: LD_EXP 36
31144: PPUSH
31145: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31149: LD_EXP 36
31153: PPUSH
31154: LD_STRING DAa-JMM-1
31156: PPUSH
31157: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31161: LD_EXP 36
31165: PPUSH
31166: LD_STRING DAa-JMM-1a
31168: PPUSH
31169: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31173: LD_EXP 36
31177: PPUSH
31178: LD_STRING DAa-JMM-1b
31180: PPUSH
31181: CALL_OW 88
// DialogueOff ;
31185: CALL_OW 7
// end ; end ;
31189: LD_VAR 0 2
31193: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31194: LD_EXP 15
31198: PUSH
31199: LD_INT 13
31201: GREATEREQUAL
31202: PUSH
31203: LD_INT 22
31205: PUSH
31206: LD_INT 2
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 21
31215: PUSH
31216: LD_INT 1
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PPUSH
31227: CALL_OW 69
31231: PUSH
31232: LD_INT 0
31234: EQUAL
31235: AND
31236: PUSH
31237: LD_INT 22
31239: PUSH
31240: LD_INT 2
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 21
31249: PUSH
31250: LD_INT 2
31252: PUSH
31253: EMPTY
31254: LIST
31255: LIST
31256: PUSH
31257: LD_INT 50
31259: PUSH
31260: EMPTY
31261: LIST
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: LIST
31267: PPUSH
31268: CALL_OW 69
31272: PUSH
31273: LD_INT 0
31275: EQUAL
31276: AND
31277: PUSH
31278: LD_EXP 21
31282: AND
31283: PUSH
31284: LD_EXP 22
31288: AND
31289: PUSH
31290: LD_EXP 23
31294: AND
31295: IFFALSE 31776
31297: GO 31299
31299: DISABLE
// begin DialogueOn ;
31300: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31304: LD_EXP 36
31308: PPUSH
31309: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31313: LD_EXP 36
31317: PPUSH
31318: LD_STRING D20-JMM-1
31320: PPUSH
31321: CALL_OW 88
// if IsOK ( Joan ) then
31325: LD_EXP 37
31329: PPUSH
31330: CALL_OW 302
31334: IFFALSE 31348
// Say ( Joan , D20-Joan-1 ) ;
31336: LD_EXP 37
31340: PPUSH
31341: LD_STRING D20-Joan-1
31343: PPUSH
31344: CALL_OW 88
// if IsOk ( Lisa ) then
31348: LD_EXP 39
31352: PPUSH
31353: CALL_OW 302
31357: IFFALSE 31371
// Say ( Lisa , D20-Lisa-1 ) ;
31359: LD_EXP 39
31363: PPUSH
31364: LD_STRING D20-Lisa-1
31366: PPUSH
31367: CALL_OW 88
// if IsOk ( Donaldson ) then
31371: LD_EXP 40
31375: PPUSH
31376: CALL_OW 302
31380: IFFALSE 31394
// Say ( Donaldson , D20-Don-1 ) ;
31382: LD_EXP 40
31386: PPUSH
31387: LD_STRING D20-Don-1
31389: PPUSH
31390: CALL_OW 88
// if IsOK ( Cornel ) then
31394: LD_EXP 47
31398: PPUSH
31399: CALL_OW 302
31403: IFFALSE 31417
// Say ( Cornel , D20-Corn-1 ) ;
31405: LD_EXP 47
31409: PPUSH
31410: LD_STRING D20-Corn-1
31412: PPUSH
31413: CALL_OW 88
// if IsOk ( Denis ) then
31417: LD_EXP 43
31421: PPUSH
31422: CALL_OW 302
31426: IFFALSE 31440
// Say ( Denis , D20-Den-1 ) ;
31428: LD_EXP 43
31432: PPUSH
31433: LD_STRING D20-Den-1
31435: PPUSH
31436: CALL_OW 88
// if IsOk ( Bobby ) then
31440: LD_EXP 41
31444: PPUSH
31445: CALL_OW 302
31449: IFFALSE 31463
// Say ( Bobby , D20-Bobby-1 ) ;
31451: LD_EXP 41
31455: PPUSH
31456: LD_STRING D20-Bobby-1
31458: PPUSH
31459: CALL_OW 88
// if IsOk ( Gladstone ) then
31463: LD_EXP 45
31467: PPUSH
31468: CALL_OW 302
31472: IFFALSE 31486
// Say ( Gladstone , D20-Glad-1 ) ;
31474: LD_EXP 45
31478: PPUSH
31479: LD_STRING D20-Glad-1
31481: PPUSH
31482: CALL_OW 88
// if IsOk ( Cyrus ) then
31486: LD_EXP 42
31490: PPUSH
31491: CALL_OW 302
31495: IFFALSE 31509
// Say ( Cyrus , D20-Cyrus-1 ) ;
31497: LD_EXP 42
31501: PPUSH
31502: LD_STRING D20-Cyrus-1
31504: PPUSH
31505: CALL_OW 88
// if IsOk ( Stevens ) then
31509: LD_EXP 38
31513: PPUSH
31514: CALL_OW 302
31518: IFFALSE 31532
// Say ( Stevens , D20-Huck-1 ) ;
31520: LD_EXP 38
31524: PPUSH
31525: LD_STRING D20-Huck-1
31527: PPUSH
31528: CALL_OW 88
// if IsOk ( Brown ) then
31532: LD_EXP 44
31536: PPUSH
31537: CALL_OW 302
31541: IFFALSE 31555
// Say ( Brown , D20-Brown-1 ) ;
31543: LD_EXP 44
31547: PPUSH
31548: LD_STRING D20-Brown-1
31550: PPUSH
31551: CALL_OW 88
// if IsOk ( Gary ) then
31555: LD_EXP 48
31559: PPUSH
31560: CALL_OW 302
31564: IFFALSE 31578
// Say ( Gary , D20-Gary-1 ) ;
31566: LD_EXP 48
31570: PPUSH
31571: LD_STRING D20-Gary-1
31573: PPUSH
31574: CALL_OW 88
// if IsOk ( Connie ) then
31578: LD_EXP 51
31582: PPUSH
31583: CALL_OW 302
31587: IFFALSE 31601
// Say ( Connie , D20-Con-1 ) ;
31589: LD_EXP 51
31593: PPUSH
31594: LD_STRING D20-Con-1
31596: PPUSH
31597: CALL_OW 88
// if IsOk ( Kurt ) then
31601: LD_EXP 57
31605: PPUSH
31606: CALL_OW 302
31610: IFFALSE 31624
// Say ( Kurt , D20-Kurt-1 ) ;
31612: LD_EXP 57
31616: PPUSH
31617: LD_STRING D20-Kurt-1
31619: PPUSH
31620: CALL_OW 88
// if IsOk ( Kikuchi ) then
31624: LD_EXP 50
31628: PPUSH
31629: CALL_OW 302
31633: IFFALSE 31647
// Say ( Kikuchi , D20-Yam-1 ) ;
31635: LD_EXP 50
31639: PPUSH
31640: LD_STRING D20-Yam-1
31642: PPUSH
31643: CALL_OW 88
// if IsOk ( Frank ) then
31647: LD_EXP 49
31651: PPUSH
31652: CALL_OW 302
31656: IFFALSE 31670
// Say ( Frank , D20-Frank-1 ) ;
31658: LD_EXP 49
31662: PPUSH
31663: LD_STRING D20-Frank-1
31665: PPUSH
31666: CALL_OW 88
// DialogueOff ;
31670: CALL_OW 7
// if RothCaptured then
31674: LD_EXP 33
31678: IFFALSE 31692
// AddMedal ( Roth , 1 ) else
31680: LD_STRING Roth
31682: PPUSH
31683: LD_INT 1
31685: PPUSH
31686: CALL_OW 101
31690: GO 31703
// AddMedal ( Roth , - 1 ) ;
31692: LD_STRING Roth
31694: PPUSH
31695: LD_INT 1
31697: NEG
31698: PPUSH
31699: CALL_OW 101
// if behemothDestroyedBeforeFinish then
31703: LD_EXP 27
31707: IFFALSE 31721
// AddMedal ( Project , 1 ) else
31709: LD_STRING Project
31711: PPUSH
31712: LD_INT 1
31714: PPUSH
31715: CALL_OW 101
31719: GO 31732
// AddMedal ( Project , - 1 ) ;
31721: LD_STRING Project
31723: PPUSH
31724: LD_INT 1
31726: NEG
31727: PPUSH
31728: CALL_OW 101
// if lostCounter = 0 then
31732: LD_EXP 32
31736: PUSH
31737: LD_INT 0
31739: EQUAL
31740: IFFALSE 31754
// AddMedal ( NoLosses , 1 ) else
31742: LD_STRING NoLosses
31744: PPUSH
31745: LD_INT 1
31747: PPUSH
31748: CALL_OW 101
31752: GO 31765
// AddMedal ( NoLosses , - 1 ) ;
31754: LD_STRING NoLosses
31756: PPUSH
31757: LD_INT 1
31759: NEG
31760: PPUSH
31761: CALL_OW 101
// GiveMedals ( MAIN ) ;
31765: LD_STRING MAIN
31767: PPUSH
31768: CALL_OW 102
// YouWin ;
31772: CALL_OW 103
// end ; end_of_file
31776: END
// export function CustomEvent ( event ) ; begin
31777: LD_INT 0
31779: PPUSH
// end ;
31780: LD_VAR 0 2
31784: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
31785: LD_VAR 0 1
31789: PUSH
31790: LD_INT 1
31792: EQUAL
31793: PUSH
31794: LD_VAR 0 2
31798: PUSH
31799: LD_INT 4
31801: EQUAL
31802: AND
31803: PUSH
31804: LD_EXP 55
31808: PPUSH
31809: CALL_OW 300
31813: AND
31814: IFFALSE 31830
// begin wait ( 0 0$2 ) ;
31816: LD_INT 70
31818: PPUSH
31819: CALL_OW 67
// YouLost ( Dismissed ) ;
31823: LD_STRING Dismissed
31825: PPUSH
31826: CALL_OW 104
// end ; end ;
31830: PPOPN 2
31832: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
31833: LD_VAR 0 2
31837: PPUSH
31838: LD_VAR 0 3
31842: PPUSH
31843: LD_INT 18
31845: PPUSH
31846: CALL_OW 309
31850: IFFALSE 31859
// YouLost ( Motherlode3 ) ;
31852: LD_STRING Motherlode3
31854: PPUSH
31855: CALL_OW 104
// end ;
31859: PPOPN 3
31861: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
31862: LD_EXP 27
31866: NOT
31867: IFFALSE 31877
// behemothDone := true ;
31869: LD_ADDR_EXP 28
31873: PUSH
31874: LD_INT 1
31876: ST_TO_ADDR
// end ;
31877: PPOPN 1
31879: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31880: LD_VAR 0 1
31884: PPUSH
31885: CALL_OW 255
31889: PUSH
31890: LD_INT 1
31892: EQUAL
31893: PUSH
31894: LD_EXP 30
31898: AND
31899: PUSH
31900: LD_INT 22
31902: PUSH
31903: LD_INT 3
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 34
31912: PUSH
31913: LD_INT 48
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PPUSH
31924: CALL_OW 69
31928: AND
31929: PUSH
31930: LD_INT 22
31932: PUSH
31933: LD_INT 1
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 34
31942: PUSH
31943: LD_INT 8
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PPUSH
31954: CALL_OW 69
31958: NOT
31959: AND
31960: IFFALSE 32012
// begin wait ( 0 0$5 ) ;
31962: LD_INT 175
31964: PPUSH
31965: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
31969: LD_INT 22
31971: PUSH
31972: LD_INT 3
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 34
31981: PUSH
31982: LD_INT 48
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PPUSH
31993: CALL_OW 69
31997: PUSH
31998: LD_INT 1
32000: ARRAY
32001: PPUSH
32002: LD_INT 60
32004: PPUSH
32005: LD_INT 95
32007: PPUSH
32008: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32012: LD_VAR 0 2
32016: PPUSH
32017: LD_VAR 0 3
32021: PPUSH
32022: LD_INT 18
32024: PPUSH
32025: CALL_OW 309
32029: IFFALSE 32089
// begin if GetSide ( unit ) = 1 then
32031: LD_VAR 0 1
32035: PPUSH
32036: CALL_OW 255
32040: PUSH
32041: LD_INT 1
32043: EQUAL
32044: IFFALSE 32060
// begin wait ( 0 0$6 ) ;
32046: LD_INT 210
32048: PPUSH
32049: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32053: LD_STRING Motherlode2
32055: PPUSH
32056: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32060: LD_VAR 0 1
32064: PPUSH
32065: CALL_OW 255
32069: PUSH
32070: LD_INT 8
32072: EQUAL
32073: IFFALSE 32089
// begin wait ( 0 0$6 ) ;
32075: LD_INT 210
32077: PPUSH
32078: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32082: LD_STRING Motherlode1
32084: PPUSH
32085: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32089: LD_VAR 0 1
32093: PPUSH
32094: CALL_OW 255
32098: PUSH
32099: LD_INT 3
32101: EQUAL
32102: IFFALSE 32123
// begin wait ( 0 0$5 ) ;
32104: LD_INT 175
32106: PPUSH
32107: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32111: LD_EXP 61
32115: PPUSH
32116: LD_STRING D18-Pla-1
32118: PPUSH
32119: CALL_OW 94
// end ; end ;
32123: PPOPN 3
32125: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32126: LD_VAR 0 1
32130: PUSH
32131: LD_EXP 70
32135: IN
32136: IFFALSE 32156
// begin behemothBuilders := behemothBuilders diff un ;
32138: LD_ADDR_EXP 70
32142: PUSH
32143: LD_EXP 70
32147: PUSH
32148: LD_VAR 0 1
32152: DIFF
32153: ST_TO_ADDR
// exit ;
32154: GO 32254
// end ; if un = JMM then
32156: LD_VAR 0 1
32160: PUSH
32161: LD_EXP 36
32165: EQUAL
32166: IFFALSE 32177
// begin YouLost ( JMM ) ;
32168: LD_STRING JMM
32170: PPUSH
32171: CALL_OW 104
// exit ;
32175: GO 32254
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32177: LD_VAR 0 1
32181: PUSH
32182: LD_INT 22
32184: PUSH
32185: LD_INT 1
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 3
32194: PUSH
32195: LD_INT 25
32197: PUSH
32198: LD_INT 16
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 25
32207: PUSH
32208: LD_INT 12
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: LIST
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PPUSH
32224: CALL_OW 69
32228: IN
32229: IFFALSE 32245
// lostCounter := lostCounter + 1 ;
32231: LD_ADDR_EXP 32
32235: PUSH
32236: LD_EXP 32
32240: PUSH
32241: LD_INT 1
32243: PLUS
32244: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32245: LD_VAR 0 1
32249: PPUSH
32250: CALL 58967 0 1
// end ;
32254: PPOPN 1
32256: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32257: LD_VAR 0 1
32261: PPUSH
32262: LD_VAR 0 2
32266: PPUSH
32267: CALL 60946 0 2
// end ;
32271: PPOPN 2
32273: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL 60014 0 1
// end ;
32283: PPOPN 1
32285: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32286: LD_VAR 0 1
32290: PUSH
32291: LD_INT 22
32293: PUSH
32294: LD_INT 8
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 30
32303: PUSH
32304: LD_INT 2
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 23
32313: PUSH
32314: LD_INT 3
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: LIST
32325: PPUSH
32326: CALL_OW 69
32330: IN
32331: IFFALSE 32358
// begin ComUpgrade ( building ) ;
32333: LD_VAR 0 1
32337: PPUSH
32338: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32342: LD_EXP 58
32346: PPUSH
32347: LD_VAR 0 1
32351: PPUSH
32352: CALL 71170 0 2
// exit ;
32356: GO 32367
// end ; MCE_BuildingComplete ( building ) ;
32358: LD_VAR 0 1
32362: PPUSH
32363: CALL 60255 0 1
// end ;
32367: PPOPN 1
32369: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32370: LD_VAR 0 1
32374: PPUSH
32375: LD_VAR 0 2
32379: PPUSH
32380: CALL 58663 0 2
// end ;
32384: PPOPN 2
32386: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32387: LD_VAR 0 1
32391: PPUSH
32392: LD_VAR 0 2
32396: PPUSH
32397: LD_VAR 0 3
32401: PPUSH
32402: LD_VAR 0 4
32406: PPUSH
32407: LD_VAR 0 5
32411: PPUSH
32412: CALL 58283 0 5
// end ;
32416: PPOPN 5
32418: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32419: LD_VAR 0 1
32423: PPUSH
32424: LD_VAR 0 2
32428: PPUSH
32429: CALL 57873 0 2
// end ;
32433: PPOPN 2
32435: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32436: LD_VAR 0 1
32440: PPUSH
32441: LD_VAR 0 2
32445: PPUSH
32446: LD_VAR 0 3
32450: PPUSH
32451: LD_VAR 0 4
32455: PPUSH
32456: CALL 57711 0 4
// end ;
32460: PPOPN 4
32462: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32463: LD_VAR 0 1
32467: PPUSH
32468: LD_VAR 0 2
32472: PPUSH
32473: LD_VAR 0 3
32477: PPUSH
32478: CALL 57486 0 3
// end ;
32482: PPOPN 3
32484: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32485: LD_VAR 0 1
32489: PPUSH
32490: LD_VAR 0 2
32494: PPUSH
32495: CALL 57371 0 2
// end ;
32499: PPOPN 2
32501: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32502: LD_VAR 0 1
32506: PPUSH
32507: LD_VAR 0 2
32511: PPUSH
32512: CALL 61207 0 2
// end ;
32516: PPOPN 2
32518: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32519: LD_VAR 0 1
32523: PPUSH
32524: CALL_OW 255
32528: PUSH
32529: LD_INT 4
32531: EQUAL
32532: PUSH
32533: LD_VAR 0 1
32537: PUSH
32538: LD_EXP 18
32542: PUSH
32543: LD_INT 1
32545: ARRAY
32546: IN
32547: AND
32548: PUSH
32549: LD_EXP 19
32553: AND
32554: IFFALSE 32573
// begin ComMoveXY ( driver , 61 , 93 ) ;
32556: LD_VAR 0 1
32560: PPUSH
32561: LD_INT 61
32563: PPUSH
32564: LD_INT 93
32566: PPUSH
32567: CALL_OW 111
// exit ;
32571: GO 32597
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32573: LD_VAR 0 1
32577: PPUSH
32578: LD_VAR 0 2
32582: PPUSH
32583: LD_VAR 0 3
32587: PPUSH
32588: LD_VAR 0 4
32592: PPUSH
32593: CALL 61423 0 4
// end ;
32597: PPOPN 4
32599: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32600: LD_VAR 0 1
32604: PPUSH
32605: LD_VAR 0 2
32609: PPUSH
32610: CALL 57180 0 2
// end ; end_of_file
32614: PPOPN 2
32616: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32617: LD_EXP 15
32621: PUSH
32622: LD_INT 2
32624: EQUAL
32625: IFFALSE 33087
32627: GO 32629
32629: DISABLE
32630: LD_INT 0
32632: PPUSH
// begin time := 0 0$40 ;
32633: LD_ADDR_VAR 0 1
32637: PUSH
32638: LD_INT 1400
32640: ST_TO_ADDR
// repeat wait ( time ) ;
32641: LD_VAR 0 1
32645: PPUSH
32646: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
32650: LD_INT 1
32652: PPUSH
32653: LD_INT 5
32655: PPUSH
32656: CALL_OW 12
32660: PPUSH
32661: LD_INT 106
32663: PPUSH
32664: LD_INT 150
32666: PPUSH
32667: LD_INT 19
32669: PPUSH
32670: LD_INT 1
32672: PPUSH
32673: CALL_OW 56
// time := time + 0 0$9 ;
32677: LD_ADDR_VAR 0 1
32681: PUSH
32682: LD_VAR 0 1
32686: PUSH
32687: LD_INT 315
32689: PLUS
32690: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$21 ) ) ;
32691: LD_INT 455
32693: PPUSH
32694: LD_INT 735
32696: PPUSH
32697: CALL_OW 12
32701: PPUSH
32702: CALL_OW 67
// if Prob ( 50 ) then
32706: LD_INT 50
32708: PPUSH
32709: CALL_OW 13
32713: IFFALSE 32742
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
32715: LD_INT 1
32717: PPUSH
32718: LD_INT 5
32720: PPUSH
32721: CALL_OW 12
32725: PPUSH
32726: LD_INT 62
32728: PPUSH
32729: LD_INT 108
32731: PPUSH
32732: LD_INT 10
32734: PPUSH
32735: LD_INT 1
32737: PPUSH
32738: CALL_OW 56
// until missionStage > 4 ;
32742: LD_EXP 15
32746: PUSH
32747: LD_INT 4
32749: GREATER
32750: IFFALSE 32641
// repeat wait ( 0 0$1 ) ;
32752: LD_INT 35
32754: PPUSH
32755: CALL_OW 67
// until missionStage = 6 ;
32759: LD_EXP 15
32763: PUSH
32764: LD_INT 6
32766: EQUAL
32767: IFFALSE 32752
// time := 0 0$50 ;
32769: LD_ADDR_VAR 0 1
32773: PUSH
32774: LD_INT 1750
32776: ST_TO_ADDR
// repeat wait ( time ) ;
32777: LD_VAR 0 1
32781: PPUSH
32782: CALL_OW 67
// if Prob ( 50 ) then
32786: LD_INT 50
32788: PPUSH
32789: CALL_OW 13
32793: IFFALSE 32822
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
32795: LD_INT 1
32797: PPUSH
32798: LD_INT 5
32800: PPUSH
32801: CALL_OW 12
32805: PPUSH
32806: LD_INT 106
32808: PPUSH
32809: LD_INT 89
32811: PPUSH
32812: LD_INT 45
32814: PPUSH
32815: LD_INT 1
32817: PPUSH
32818: CALL_OW 56
// time := time + 0 0$3 ;
32822: LD_ADDR_VAR 0 1
32826: PUSH
32827: LD_VAR 0 1
32831: PUSH
32832: LD_INT 105
32834: PLUS
32835: ST_TO_ADDR
// if Prob ( 30 ) then
32836: LD_INT 30
32838: PPUSH
32839: CALL_OW 13
32843: IFFALSE 32889
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
32845: LD_INT 525
32847: PPUSH
32848: LD_INT 735
32850: PPUSH
32851: CALL_OW 12
32855: PPUSH
32856: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
32860: LD_INT 1
32862: PPUSH
32863: LD_INT 5
32865: PPUSH
32866: CALL_OW 12
32870: PPUSH
32871: LD_INT 21
32873: PPUSH
32874: LD_INT 26
32876: PPUSH
32877: LD_INT 12
32879: PPUSH
32880: LD_INT 1
32882: PPUSH
32883: CALL_OW 56
// end else
32887: GO 32925
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
32889: LD_INT 700
32891: PPUSH
32892: LD_INT 1225
32894: PPUSH
32895: CALL_OW 12
32899: PPUSH
32900: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
32904: LD_INT 1
32906: PPUSH
32907: LD_INT 5
32909: PPUSH
32910: CALL_OW 12
32914: PPUSH
32915: LD_INT 16
32917: PPUSH
32918: LD_INT 1
32920: PPUSH
32921: CALL_OW 55
// end ; if Prob ( 50 ) then
32925: LD_INT 50
32927: PPUSH
32928: CALL_OW 13
32932: IFFALSE 32978
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
32934: LD_INT 700
32936: PPUSH
32937: LD_INT 1050
32939: PPUSH
32940: CALL_OW 12
32944: PPUSH
32945: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
32949: LD_INT 1
32951: PPUSH
32952: LD_INT 5
32954: PPUSH
32955: CALL_OW 12
32959: PPUSH
32960: LD_INT 181
32962: PPUSH
32963: LD_INT 218
32965: PPUSH
32966: LD_INT 16
32968: PPUSH
32969: LD_INT 1
32971: PPUSH
32972: CALL_OW 56
// end else
32976: GO 33014
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
32978: LD_INT 350
32980: PPUSH
32981: LD_INT 525
32983: PPUSH
32984: CALL_OW 12
32988: PPUSH
32989: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
32993: LD_INT 1
32995: PPUSH
32996: LD_INT 5
32998: PPUSH
32999: CALL_OW 12
33003: PPUSH
33004: LD_INT 15
33006: PPUSH
33007: LD_INT 1
33009: PPUSH
33010: CALL_OW 55
// end ; if Prob ( 45 ) then
33014: LD_INT 45
33016: PPUSH
33017: CALL_OW 13
33021: IFFALSE 33065
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33023: LD_INT 525
33025: PPUSH
33026: LD_INT 875
33028: PPUSH
33029: CALL_OW 12
33033: PPUSH
33034: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33038: LD_INT 1
33040: PPUSH
33041: LD_INT 5
33043: PPUSH
33044: CALL_OW 12
33048: PPUSH
33049: LD_INT 103
33051: PPUSH
33052: LD_INT 140
33054: PPUSH
33055: LD_INT 20
33057: PPUSH
33058: LD_INT 1
33060: PPUSH
33061: CALL_OW 56
// end ; if time > 2 2$20 then
33065: LD_VAR 0 1
33069: PUSH
33070: LD_INT 4900
33072: GREATER
33073: IFFALSE 33083
// time := 0 0$50 ;
33075: LD_ADDR_VAR 0 1
33079: PUSH
33080: LD_INT 1750
33082: ST_TO_ADDR
// until false ;
33083: LD_INT 0
33085: IFFALSE 32777
// end ; end_of_file
33087: PPOPN 1
33089: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33090: LD_EXP 13
33094: PUSH
33095: LD_EXP 15
33099: PUSH
33100: LD_INT 6
33102: GREATEREQUAL
33103: AND
33104: IFFALSE 33141
33106: GO 33108
33108: DISABLE
// begin enable ;
33109: ENABLE
// missionTime := missionTime + 0 0$1 ;
33110: LD_ADDR_EXP 14
33114: PUSH
33115: LD_EXP 14
33119: PUSH
33120: LD_INT 35
33122: PLUS
33123: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33124: LD_ADDR_OWVAR 47
33128: PUSH
33129: LD_STRING #Am15-1
33131: PUSH
33132: LD_EXP 14
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: ST_TO_ADDR
// end ; end_of_file
33141: END
// export function InitNature ; begin
33142: LD_INT 0
33144: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33145: LD_INT 3
33147: PPUSH
33148: LD_INT 3
33150: PPUSH
33151: LD_INT 2
33153: PPUSH
33154: LD_INT 1
33156: PPUSH
33157: LD_INT 1
33159: PPUSH
33160: LD_INT 0
33162: PPUSH
33163: LD_INT 0
33165: PPUSH
33166: LD_INT 20
33168: PPUSH
33169: LD_INT 0
33171: PPUSH
33172: CALL 95987 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33176: LD_INT 2
33178: PPUSH
33179: LD_INT 1
33181: PPUSH
33182: LD_INT 1
33184: PPUSH
33185: LD_INT 1
33187: PPUSH
33188: LD_INT 1
33190: PPUSH
33191: LD_INT 0
33193: PPUSH
33194: LD_INT 0
33196: PPUSH
33197: LD_INT 21
33199: PPUSH
33200: LD_INT 0
33202: PPUSH
33203: CALL 95987 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33207: LD_INT 4
33209: PPUSH
33210: LD_INT 1
33212: PPUSH
33213: LD_INT 2
33215: PPUSH
33216: LD_INT 4
33218: PPUSH
33219: LD_INT 2
33221: PPUSH
33222: LD_INT 1
33224: PPUSH
33225: LD_INT 0
33227: PPUSH
33228: LD_INT 22
33230: PPUSH
33231: LD_INT 0
33233: PPUSH
33234: CALL 95987 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33238: LD_INT 0
33240: PPUSH
33241: LD_INT 0
33243: PPUSH
33244: LD_INT 0
33246: PPUSH
33247: LD_INT 0
33249: PPUSH
33250: LD_INT 0
33252: PPUSH
33253: LD_INT 0
33255: PPUSH
33256: LD_INT 9
33258: PPUSH
33259: LD_INT 0
33261: PPUSH
33262: LD_INT 23
33264: PPUSH
33265: CALL 95987 0 9
// end ; end_of_file
33269: LD_VAR 0 1
33273: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33274: GO 33276
33276: DISABLE
// begin ru_radar := 98 ;
33277: LD_ADDR_EXP 92
33281: PUSH
33282: LD_INT 98
33284: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33285: LD_ADDR_EXP 93
33289: PUSH
33290: LD_INT 89
33292: ST_TO_ADDR
// us_hack := 99 ;
33293: LD_ADDR_EXP 94
33297: PUSH
33298: LD_INT 99
33300: ST_TO_ADDR
// us_artillery := 97 ;
33301: LD_ADDR_EXP 95
33305: PUSH
33306: LD_INT 97
33308: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33309: LD_ADDR_EXP 96
33313: PUSH
33314: LD_INT 91
33316: ST_TO_ADDR
// end ; end_of_file
33317: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33318: LD_INT 0
33320: PPUSH
33321: PPUSH
// skirmish := false ;
33322: LD_ADDR_EXP 97
33326: PUSH
33327: LD_INT 0
33329: ST_TO_ADDR
// debug_mc := false ;
33330: LD_ADDR_EXP 98
33334: PUSH
33335: LD_INT 0
33337: ST_TO_ADDR
// mc_bases := [ ] ;
33338: LD_ADDR_EXP 99
33342: PUSH
33343: EMPTY
33344: ST_TO_ADDR
// mc_sides := [ ] ;
33345: LD_ADDR_EXP 125
33349: PUSH
33350: EMPTY
33351: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33352: LD_ADDR_EXP 100
33356: PUSH
33357: EMPTY
33358: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33359: LD_ADDR_EXP 101
33363: PUSH
33364: EMPTY
33365: ST_TO_ADDR
// mc_need_heal := [ ] ;
33366: LD_ADDR_EXP 102
33370: PUSH
33371: EMPTY
33372: ST_TO_ADDR
// mc_healers := [ ] ;
33373: LD_ADDR_EXP 103
33377: PUSH
33378: EMPTY
33379: ST_TO_ADDR
// mc_build_list := [ ] ;
33380: LD_ADDR_EXP 104
33384: PUSH
33385: EMPTY
33386: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33387: LD_ADDR_EXP 131
33391: PUSH
33392: EMPTY
33393: ST_TO_ADDR
// mc_builders := [ ] ;
33394: LD_ADDR_EXP 105
33398: PUSH
33399: EMPTY
33400: ST_TO_ADDR
// mc_construct_list := [ ] ;
33401: LD_ADDR_EXP 106
33405: PUSH
33406: EMPTY
33407: ST_TO_ADDR
// mc_turret_list := [ ] ;
33408: LD_ADDR_EXP 107
33412: PUSH
33413: EMPTY
33414: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33415: LD_ADDR_EXP 108
33419: PUSH
33420: EMPTY
33421: ST_TO_ADDR
// mc_miners := [ ] ;
33422: LD_ADDR_EXP 113
33426: PUSH
33427: EMPTY
33428: ST_TO_ADDR
// mc_mines := [ ] ;
33429: LD_ADDR_EXP 112
33433: PUSH
33434: EMPTY
33435: ST_TO_ADDR
// mc_minefields := [ ] ;
33436: LD_ADDR_EXP 114
33440: PUSH
33441: EMPTY
33442: ST_TO_ADDR
// mc_crates := [ ] ;
33443: LD_ADDR_EXP 115
33447: PUSH
33448: EMPTY
33449: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33450: LD_ADDR_EXP 116
33454: PUSH
33455: EMPTY
33456: ST_TO_ADDR
// mc_crates_area := [ ] ;
33457: LD_ADDR_EXP 117
33461: PUSH
33462: EMPTY
33463: ST_TO_ADDR
// mc_vehicles := [ ] ;
33464: LD_ADDR_EXP 118
33468: PUSH
33469: EMPTY
33470: ST_TO_ADDR
// mc_attack := [ ] ;
33471: LD_ADDR_EXP 119
33475: PUSH
33476: EMPTY
33477: ST_TO_ADDR
// mc_produce := [ ] ;
33478: LD_ADDR_EXP 120
33482: PUSH
33483: EMPTY
33484: ST_TO_ADDR
// mc_defender := [ ] ;
33485: LD_ADDR_EXP 121
33489: PUSH
33490: EMPTY
33491: ST_TO_ADDR
// mc_parking := [ ] ;
33492: LD_ADDR_EXP 123
33496: PUSH
33497: EMPTY
33498: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33499: LD_ADDR_EXP 109
33503: PUSH
33504: EMPTY
33505: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33506: LD_ADDR_EXP 111
33510: PUSH
33511: EMPTY
33512: ST_TO_ADDR
// mc_scan := [ ] ;
33513: LD_ADDR_EXP 122
33517: PUSH
33518: EMPTY
33519: ST_TO_ADDR
// mc_scan_area := [ ] ;
33520: LD_ADDR_EXP 124
33524: PUSH
33525: EMPTY
33526: ST_TO_ADDR
// mc_tech := [ ] ;
33527: LD_ADDR_EXP 126
33531: PUSH
33532: EMPTY
33533: ST_TO_ADDR
// mc_class := [ ] ;
33534: LD_ADDR_EXP 140
33538: PUSH
33539: EMPTY
33540: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33541: LD_ADDR_EXP 141
33545: PUSH
33546: EMPTY
33547: ST_TO_ADDR
// end ;
33548: LD_VAR 0 1
33552: RET
// export function MC_Kill ( base ) ; begin
33553: LD_INT 0
33555: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33556: LD_ADDR_EXP 99
33560: PUSH
33561: LD_EXP 99
33565: PPUSH
33566: LD_VAR 0 1
33570: PPUSH
33571: EMPTY
33572: PPUSH
33573: CALL_OW 1
33577: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33578: LD_ADDR_EXP 100
33582: PUSH
33583: LD_EXP 100
33587: PPUSH
33588: LD_VAR 0 1
33592: PPUSH
33593: EMPTY
33594: PPUSH
33595: CALL_OW 1
33599: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33600: LD_ADDR_EXP 101
33604: PUSH
33605: LD_EXP 101
33609: PPUSH
33610: LD_VAR 0 1
33614: PPUSH
33615: EMPTY
33616: PPUSH
33617: CALL_OW 1
33621: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
33622: LD_ADDR_EXP 102
33626: PUSH
33627: LD_EXP 102
33631: PPUSH
33632: LD_VAR 0 1
33636: PPUSH
33637: EMPTY
33638: PPUSH
33639: CALL_OW 1
33643: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
33644: LD_ADDR_EXP 103
33648: PUSH
33649: LD_EXP 103
33653: PPUSH
33654: LD_VAR 0 1
33658: PPUSH
33659: EMPTY
33660: PPUSH
33661: CALL_OW 1
33665: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
33666: LD_ADDR_EXP 104
33670: PUSH
33671: LD_EXP 104
33675: PPUSH
33676: LD_VAR 0 1
33680: PPUSH
33681: EMPTY
33682: PPUSH
33683: CALL_OW 1
33687: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
33688: LD_ADDR_EXP 105
33692: PUSH
33693: LD_EXP 105
33697: PPUSH
33698: LD_VAR 0 1
33702: PPUSH
33703: EMPTY
33704: PPUSH
33705: CALL_OW 1
33709: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
33710: LD_ADDR_EXP 106
33714: PUSH
33715: LD_EXP 106
33719: PPUSH
33720: LD_VAR 0 1
33724: PPUSH
33725: EMPTY
33726: PPUSH
33727: CALL_OW 1
33731: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
33732: LD_ADDR_EXP 107
33736: PUSH
33737: LD_EXP 107
33741: PPUSH
33742: LD_VAR 0 1
33746: PPUSH
33747: EMPTY
33748: PPUSH
33749: CALL_OW 1
33753: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
33754: LD_ADDR_EXP 108
33758: PUSH
33759: LD_EXP 108
33763: PPUSH
33764: LD_VAR 0 1
33768: PPUSH
33769: EMPTY
33770: PPUSH
33771: CALL_OW 1
33775: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
33776: LD_ADDR_EXP 109
33780: PUSH
33781: LD_EXP 109
33785: PPUSH
33786: LD_VAR 0 1
33790: PPUSH
33791: EMPTY
33792: PPUSH
33793: CALL_OW 1
33797: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
33798: LD_ADDR_EXP 110
33802: PUSH
33803: LD_EXP 110
33807: PPUSH
33808: LD_VAR 0 1
33812: PPUSH
33813: LD_INT 0
33815: PPUSH
33816: CALL_OW 1
33820: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
33821: LD_ADDR_EXP 111
33825: PUSH
33826: LD_EXP 111
33830: PPUSH
33831: LD_VAR 0 1
33835: PPUSH
33836: EMPTY
33837: PPUSH
33838: CALL_OW 1
33842: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
33843: LD_ADDR_EXP 112
33847: PUSH
33848: LD_EXP 112
33852: PPUSH
33853: LD_VAR 0 1
33857: PPUSH
33858: EMPTY
33859: PPUSH
33860: CALL_OW 1
33864: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
33865: LD_ADDR_EXP 113
33869: PUSH
33870: LD_EXP 113
33874: PPUSH
33875: LD_VAR 0 1
33879: PPUSH
33880: EMPTY
33881: PPUSH
33882: CALL_OW 1
33886: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
33887: LD_ADDR_EXP 114
33891: PUSH
33892: LD_EXP 114
33896: PPUSH
33897: LD_VAR 0 1
33901: PPUSH
33902: EMPTY
33903: PPUSH
33904: CALL_OW 1
33908: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
33909: LD_ADDR_EXP 115
33913: PUSH
33914: LD_EXP 115
33918: PPUSH
33919: LD_VAR 0 1
33923: PPUSH
33924: EMPTY
33925: PPUSH
33926: CALL_OW 1
33930: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
33931: LD_ADDR_EXP 116
33935: PUSH
33936: LD_EXP 116
33940: PPUSH
33941: LD_VAR 0 1
33945: PPUSH
33946: EMPTY
33947: PPUSH
33948: CALL_OW 1
33952: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
33953: LD_ADDR_EXP 117
33957: PUSH
33958: LD_EXP 117
33962: PPUSH
33963: LD_VAR 0 1
33967: PPUSH
33968: EMPTY
33969: PPUSH
33970: CALL_OW 1
33974: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
33975: LD_ADDR_EXP 118
33979: PUSH
33980: LD_EXP 118
33984: PPUSH
33985: LD_VAR 0 1
33989: PPUSH
33990: EMPTY
33991: PPUSH
33992: CALL_OW 1
33996: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
33997: LD_ADDR_EXP 119
34001: PUSH
34002: LD_EXP 119
34006: PPUSH
34007: LD_VAR 0 1
34011: PPUSH
34012: EMPTY
34013: PPUSH
34014: CALL_OW 1
34018: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34019: LD_ADDR_EXP 120
34023: PUSH
34024: LD_EXP 120
34028: PPUSH
34029: LD_VAR 0 1
34033: PPUSH
34034: EMPTY
34035: PPUSH
34036: CALL_OW 1
34040: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34041: LD_ADDR_EXP 121
34045: PUSH
34046: LD_EXP 121
34050: PPUSH
34051: LD_VAR 0 1
34055: PPUSH
34056: EMPTY
34057: PPUSH
34058: CALL_OW 1
34062: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34063: LD_ADDR_EXP 122
34067: PUSH
34068: LD_EXP 122
34072: PPUSH
34073: LD_VAR 0 1
34077: PPUSH
34078: EMPTY
34079: PPUSH
34080: CALL_OW 1
34084: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34085: LD_ADDR_EXP 123
34089: PUSH
34090: LD_EXP 123
34094: PPUSH
34095: LD_VAR 0 1
34099: PPUSH
34100: EMPTY
34101: PPUSH
34102: CALL_OW 1
34106: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34107: LD_ADDR_EXP 124
34111: PUSH
34112: LD_EXP 124
34116: PPUSH
34117: LD_VAR 0 1
34121: PPUSH
34122: EMPTY
34123: PPUSH
34124: CALL_OW 1
34128: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34129: LD_ADDR_EXP 126
34133: PUSH
34134: LD_EXP 126
34138: PPUSH
34139: LD_VAR 0 1
34143: PPUSH
34144: EMPTY
34145: PPUSH
34146: CALL_OW 1
34150: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34151: LD_ADDR_EXP 128
34155: PUSH
34156: LD_EXP 128
34160: PPUSH
34161: LD_VAR 0 1
34165: PPUSH
34166: EMPTY
34167: PPUSH
34168: CALL_OW 1
34172: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34173: LD_ADDR_EXP 129
34177: PUSH
34178: LD_EXP 129
34182: PPUSH
34183: LD_VAR 0 1
34187: PPUSH
34188: EMPTY
34189: PPUSH
34190: CALL_OW 1
34194: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34195: LD_ADDR_EXP 130
34199: PUSH
34200: LD_EXP 130
34204: PPUSH
34205: LD_VAR 0 1
34209: PPUSH
34210: EMPTY
34211: PPUSH
34212: CALL_OW 1
34216: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34217: LD_ADDR_EXP 131
34221: PUSH
34222: LD_EXP 131
34226: PPUSH
34227: LD_VAR 0 1
34231: PPUSH
34232: EMPTY
34233: PPUSH
34234: CALL_OW 1
34238: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34239: LD_ADDR_EXP 132
34243: PUSH
34244: LD_EXP 132
34248: PPUSH
34249: LD_VAR 0 1
34253: PPUSH
34254: EMPTY
34255: PPUSH
34256: CALL_OW 1
34260: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34261: LD_ADDR_EXP 133
34265: PUSH
34266: LD_EXP 133
34270: PPUSH
34271: LD_VAR 0 1
34275: PPUSH
34276: EMPTY
34277: PPUSH
34278: CALL_OW 1
34282: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34283: LD_ADDR_EXP 134
34287: PUSH
34288: LD_EXP 134
34292: PPUSH
34293: LD_VAR 0 1
34297: PPUSH
34298: EMPTY
34299: PPUSH
34300: CALL_OW 1
34304: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34305: LD_ADDR_EXP 135
34309: PUSH
34310: LD_EXP 135
34314: PPUSH
34315: LD_VAR 0 1
34319: PPUSH
34320: EMPTY
34321: PPUSH
34322: CALL_OW 1
34326: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34327: LD_ADDR_EXP 136
34331: PUSH
34332: LD_EXP 136
34336: PPUSH
34337: LD_VAR 0 1
34341: PPUSH
34342: EMPTY
34343: PPUSH
34344: CALL_OW 1
34348: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34349: LD_ADDR_EXP 137
34353: PUSH
34354: LD_EXP 137
34358: PPUSH
34359: LD_VAR 0 1
34363: PPUSH
34364: EMPTY
34365: PPUSH
34366: CALL_OW 1
34370: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34371: LD_ADDR_EXP 138
34375: PUSH
34376: LD_EXP 138
34380: PPUSH
34381: LD_VAR 0 1
34385: PPUSH
34386: EMPTY
34387: PPUSH
34388: CALL_OW 1
34392: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34393: LD_ADDR_EXP 139
34397: PUSH
34398: LD_EXP 139
34402: PPUSH
34403: LD_VAR 0 1
34407: PPUSH
34408: EMPTY
34409: PPUSH
34410: CALL_OW 1
34414: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34415: LD_ADDR_EXP 140
34419: PUSH
34420: LD_EXP 140
34424: PPUSH
34425: LD_VAR 0 1
34429: PPUSH
34430: EMPTY
34431: PPUSH
34432: CALL_OW 1
34436: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34437: LD_ADDR_EXP 141
34441: PUSH
34442: LD_EXP 141
34446: PPUSH
34447: LD_VAR 0 1
34451: PPUSH
34452: LD_INT 0
34454: PPUSH
34455: CALL_OW 1
34459: ST_TO_ADDR
// end ;
34460: LD_VAR 0 2
34464: RET
// export function MC_Start ( ) ; var i ; begin
34465: LD_INT 0
34467: PPUSH
34468: PPUSH
// for i = 1 to mc_bases do
34469: LD_ADDR_VAR 0 2
34473: PUSH
34474: DOUBLE
34475: LD_INT 1
34477: DEC
34478: ST_TO_ADDR
34479: LD_EXP 99
34483: PUSH
34484: FOR_TO
34485: IFFALSE 35562
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
34487: LD_ADDR_EXP 99
34491: PUSH
34492: LD_EXP 99
34496: PPUSH
34497: LD_VAR 0 2
34501: PPUSH
34502: LD_EXP 99
34506: PUSH
34507: LD_VAR 0 2
34511: ARRAY
34512: PUSH
34513: LD_INT 0
34515: DIFF
34516: PPUSH
34517: CALL_OW 1
34521: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
34522: LD_ADDR_EXP 100
34526: PUSH
34527: LD_EXP 100
34531: PPUSH
34532: LD_VAR 0 2
34536: PPUSH
34537: EMPTY
34538: PPUSH
34539: CALL_OW 1
34543: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
34544: LD_ADDR_EXP 101
34548: PUSH
34549: LD_EXP 101
34553: PPUSH
34554: LD_VAR 0 2
34558: PPUSH
34559: EMPTY
34560: PPUSH
34561: CALL_OW 1
34565: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
34566: LD_ADDR_EXP 102
34570: PUSH
34571: LD_EXP 102
34575: PPUSH
34576: LD_VAR 0 2
34580: PPUSH
34581: EMPTY
34582: PPUSH
34583: CALL_OW 1
34587: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
34588: LD_ADDR_EXP 103
34592: PUSH
34593: LD_EXP 103
34597: PPUSH
34598: LD_VAR 0 2
34602: PPUSH
34603: EMPTY
34604: PUSH
34605: EMPTY
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PPUSH
34611: CALL_OW 1
34615: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
34616: LD_ADDR_EXP 104
34620: PUSH
34621: LD_EXP 104
34625: PPUSH
34626: LD_VAR 0 2
34630: PPUSH
34631: EMPTY
34632: PPUSH
34633: CALL_OW 1
34637: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
34638: LD_ADDR_EXP 131
34642: PUSH
34643: LD_EXP 131
34647: PPUSH
34648: LD_VAR 0 2
34652: PPUSH
34653: EMPTY
34654: PPUSH
34655: CALL_OW 1
34659: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
34660: LD_ADDR_EXP 105
34664: PUSH
34665: LD_EXP 105
34669: PPUSH
34670: LD_VAR 0 2
34674: PPUSH
34675: EMPTY
34676: PPUSH
34677: CALL_OW 1
34681: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
34682: LD_ADDR_EXP 106
34686: PUSH
34687: LD_EXP 106
34691: PPUSH
34692: LD_VAR 0 2
34696: PPUSH
34697: EMPTY
34698: PPUSH
34699: CALL_OW 1
34703: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
34704: LD_ADDR_EXP 107
34708: PUSH
34709: LD_EXP 107
34713: PPUSH
34714: LD_VAR 0 2
34718: PPUSH
34719: LD_EXP 99
34723: PUSH
34724: LD_VAR 0 2
34728: ARRAY
34729: PPUSH
34730: LD_INT 2
34732: PUSH
34733: LD_INT 30
34735: PUSH
34736: LD_INT 32
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 30
34745: PUSH
34746: LD_INT 33
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: LIST
34757: PPUSH
34758: CALL_OW 72
34762: PPUSH
34763: CALL_OW 1
34767: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
34768: LD_ADDR_EXP 108
34772: PUSH
34773: LD_EXP 108
34777: PPUSH
34778: LD_VAR 0 2
34782: PPUSH
34783: LD_EXP 99
34787: PUSH
34788: LD_VAR 0 2
34792: ARRAY
34793: PPUSH
34794: LD_INT 2
34796: PUSH
34797: LD_INT 30
34799: PUSH
34800: LD_INT 32
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 30
34809: PUSH
34810: LD_INT 31
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 58
34824: PUSH
34825: EMPTY
34826: LIST
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: PPUSH
34832: CALL_OW 72
34836: PPUSH
34837: CALL_OW 1
34841: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
34842: LD_ADDR_EXP 109
34846: PUSH
34847: LD_EXP 109
34851: PPUSH
34852: LD_VAR 0 2
34856: PPUSH
34857: EMPTY
34858: PPUSH
34859: CALL_OW 1
34863: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
34864: LD_ADDR_EXP 113
34868: PUSH
34869: LD_EXP 113
34873: PPUSH
34874: LD_VAR 0 2
34878: PPUSH
34879: EMPTY
34880: PPUSH
34881: CALL_OW 1
34885: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
34886: LD_ADDR_EXP 112
34890: PUSH
34891: LD_EXP 112
34895: PPUSH
34896: LD_VAR 0 2
34900: PPUSH
34901: EMPTY
34902: PPUSH
34903: CALL_OW 1
34907: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
34908: LD_ADDR_EXP 114
34912: PUSH
34913: LD_EXP 114
34917: PPUSH
34918: LD_VAR 0 2
34922: PPUSH
34923: EMPTY
34924: PPUSH
34925: CALL_OW 1
34929: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
34930: LD_ADDR_EXP 115
34934: PUSH
34935: LD_EXP 115
34939: PPUSH
34940: LD_VAR 0 2
34944: PPUSH
34945: EMPTY
34946: PPUSH
34947: CALL_OW 1
34951: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34952: LD_ADDR_EXP 116
34956: PUSH
34957: LD_EXP 116
34961: PPUSH
34962: LD_VAR 0 2
34966: PPUSH
34967: EMPTY
34968: PPUSH
34969: CALL_OW 1
34973: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
34974: LD_ADDR_EXP 117
34978: PUSH
34979: LD_EXP 117
34983: PPUSH
34984: LD_VAR 0 2
34988: PPUSH
34989: EMPTY
34990: PPUSH
34991: CALL_OW 1
34995: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
34996: LD_ADDR_EXP 118
35000: PUSH
35001: LD_EXP 118
35005: PPUSH
35006: LD_VAR 0 2
35010: PPUSH
35011: EMPTY
35012: PPUSH
35013: CALL_OW 1
35017: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35018: LD_ADDR_EXP 119
35022: PUSH
35023: LD_EXP 119
35027: PPUSH
35028: LD_VAR 0 2
35032: PPUSH
35033: EMPTY
35034: PPUSH
35035: CALL_OW 1
35039: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
35040: LD_ADDR_EXP 120
35044: PUSH
35045: LD_EXP 120
35049: PPUSH
35050: LD_VAR 0 2
35054: PPUSH
35055: EMPTY
35056: PPUSH
35057: CALL_OW 1
35061: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35062: LD_ADDR_EXP 121
35066: PUSH
35067: LD_EXP 121
35071: PPUSH
35072: LD_VAR 0 2
35076: PPUSH
35077: EMPTY
35078: PPUSH
35079: CALL_OW 1
35083: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
35084: LD_ADDR_EXP 110
35088: PUSH
35089: LD_EXP 110
35093: PPUSH
35094: LD_VAR 0 2
35098: PPUSH
35099: LD_INT 0
35101: PPUSH
35102: CALL_OW 1
35106: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
35107: LD_ADDR_EXP 123
35111: PUSH
35112: LD_EXP 123
35116: PPUSH
35117: LD_VAR 0 2
35121: PPUSH
35122: LD_INT 0
35124: PPUSH
35125: CALL_OW 1
35129: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35130: LD_ADDR_EXP 111
35134: PUSH
35135: LD_EXP 111
35139: PPUSH
35140: LD_VAR 0 2
35144: PPUSH
35145: EMPTY
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
35152: LD_ADDR_EXP 122
35156: PUSH
35157: LD_EXP 122
35161: PPUSH
35162: LD_VAR 0 2
35166: PPUSH
35167: LD_INT 0
35169: PPUSH
35170: CALL_OW 1
35174: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
35175: LD_ADDR_EXP 124
35179: PUSH
35180: LD_EXP 124
35184: PPUSH
35185: LD_VAR 0 2
35189: PPUSH
35190: EMPTY
35191: PPUSH
35192: CALL_OW 1
35196: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
35197: LD_ADDR_EXP 127
35201: PUSH
35202: LD_EXP 127
35206: PPUSH
35207: LD_VAR 0 2
35211: PPUSH
35212: LD_INT 0
35214: PPUSH
35215: CALL_OW 1
35219: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
35220: LD_ADDR_EXP 128
35224: PUSH
35225: LD_EXP 128
35229: PPUSH
35230: LD_VAR 0 2
35234: PPUSH
35235: EMPTY
35236: PPUSH
35237: CALL_OW 1
35241: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
35242: LD_ADDR_EXP 129
35246: PUSH
35247: LD_EXP 129
35251: PPUSH
35252: LD_VAR 0 2
35256: PPUSH
35257: EMPTY
35258: PPUSH
35259: CALL_OW 1
35263: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35264: LD_ADDR_EXP 130
35268: PUSH
35269: LD_EXP 130
35273: PPUSH
35274: LD_VAR 0 2
35278: PPUSH
35279: EMPTY
35280: PPUSH
35281: CALL_OW 1
35285: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
35286: LD_ADDR_EXP 132
35290: PUSH
35291: LD_EXP 132
35295: PPUSH
35296: LD_VAR 0 2
35300: PPUSH
35301: LD_EXP 99
35305: PUSH
35306: LD_VAR 0 2
35310: ARRAY
35311: PPUSH
35312: LD_INT 2
35314: PUSH
35315: LD_INT 30
35317: PUSH
35318: LD_INT 6
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 30
35327: PUSH
35328: LD_INT 7
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 30
35337: PUSH
35338: LD_INT 8
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: PPUSH
35351: CALL_OW 72
35355: PPUSH
35356: CALL_OW 1
35360: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
35361: LD_ADDR_EXP 133
35365: PUSH
35366: LD_EXP 133
35370: PPUSH
35371: LD_VAR 0 2
35375: PPUSH
35376: EMPTY
35377: PPUSH
35378: CALL_OW 1
35382: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
35383: LD_ADDR_EXP 134
35387: PUSH
35388: LD_EXP 134
35392: PPUSH
35393: LD_VAR 0 2
35397: PPUSH
35398: EMPTY
35399: PPUSH
35400: CALL_OW 1
35404: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
35405: LD_ADDR_EXP 135
35409: PUSH
35410: LD_EXP 135
35414: PPUSH
35415: LD_VAR 0 2
35419: PPUSH
35420: EMPTY
35421: PPUSH
35422: CALL_OW 1
35426: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
35427: LD_ADDR_EXP 136
35431: PUSH
35432: LD_EXP 136
35436: PPUSH
35437: LD_VAR 0 2
35441: PPUSH
35442: EMPTY
35443: PPUSH
35444: CALL_OW 1
35448: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35449: LD_ADDR_EXP 137
35453: PUSH
35454: LD_EXP 137
35458: PPUSH
35459: LD_VAR 0 2
35463: PPUSH
35464: EMPTY
35465: PPUSH
35466: CALL_OW 1
35470: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
35471: LD_ADDR_EXP 138
35475: PUSH
35476: LD_EXP 138
35480: PPUSH
35481: LD_VAR 0 2
35485: PPUSH
35486: EMPTY
35487: PPUSH
35488: CALL_OW 1
35492: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
35493: LD_ADDR_EXP 139
35497: PUSH
35498: LD_EXP 139
35502: PPUSH
35503: LD_VAR 0 2
35507: PPUSH
35508: EMPTY
35509: PPUSH
35510: CALL_OW 1
35514: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
35515: LD_ADDR_EXP 140
35519: PUSH
35520: LD_EXP 140
35524: PPUSH
35525: LD_VAR 0 2
35529: PPUSH
35530: EMPTY
35531: PPUSH
35532: CALL_OW 1
35536: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
35537: LD_ADDR_EXP 141
35541: PUSH
35542: LD_EXP 141
35546: PPUSH
35547: LD_VAR 0 2
35551: PPUSH
35552: LD_INT 0
35554: PPUSH
35555: CALL_OW 1
35559: ST_TO_ADDR
// end ;
35560: GO 34484
35562: POP
35563: POP
// MC_InitSides ( ) ;
35564: CALL 35850 0 0
// MC_InitResearch ( ) ;
35568: CALL 35589 0 0
// CustomInitMacro ( ) ;
35572: CALL 437 0 0
// skirmish := true ;
35576: LD_ADDR_EXP 97
35580: PUSH
35581: LD_INT 1
35583: ST_TO_ADDR
// end ;
35584: LD_VAR 0 1
35588: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
35589: LD_INT 0
35591: PPUSH
35592: PPUSH
35593: PPUSH
35594: PPUSH
35595: PPUSH
35596: PPUSH
// if not mc_bases then
35597: LD_EXP 99
35601: NOT
35602: IFFALSE 35606
// exit ;
35604: GO 35845
// for i = 1 to 8 do
35606: LD_ADDR_VAR 0 2
35610: PUSH
35611: DOUBLE
35612: LD_INT 1
35614: DEC
35615: ST_TO_ADDR
35616: LD_INT 8
35618: PUSH
35619: FOR_TO
35620: IFFALSE 35646
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
35622: LD_ADDR_EXP 126
35626: PUSH
35627: LD_EXP 126
35631: PPUSH
35632: LD_VAR 0 2
35636: PPUSH
35637: EMPTY
35638: PPUSH
35639: CALL_OW 1
35643: ST_TO_ADDR
35644: GO 35619
35646: POP
35647: POP
// tmp := [ ] ;
35648: LD_ADDR_VAR 0 5
35652: PUSH
35653: EMPTY
35654: ST_TO_ADDR
// for i = 1 to mc_sides do
35655: LD_ADDR_VAR 0 2
35659: PUSH
35660: DOUBLE
35661: LD_INT 1
35663: DEC
35664: ST_TO_ADDR
35665: LD_EXP 125
35669: PUSH
35670: FOR_TO
35671: IFFALSE 35729
// if not mc_sides [ i ] in tmp then
35673: LD_EXP 125
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 5
35688: IN
35689: NOT
35690: IFFALSE 35727
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
35692: LD_ADDR_VAR 0 5
35696: PUSH
35697: LD_VAR 0 5
35701: PPUSH
35702: LD_VAR 0 5
35706: PUSH
35707: LD_INT 1
35709: PLUS
35710: PPUSH
35711: LD_EXP 125
35715: PUSH
35716: LD_VAR 0 2
35720: ARRAY
35721: PPUSH
35722: CALL_OW 2
35726: ST_TO_ADDR
35727: GO 35670
35729: POP
35730: POP
// if not tmp then
35731: LD_VAR 0 5
35735: NOT
35736: IFFALSE 35740
// exit ;
35738: GO 35845
// for j in tmp do
35740: LD_ADDR_VAR 0 3
35744: PUSH
35745: LD_VAR 0 5
35749: PUSH
35750: FOR_IN
35751: IFFALSE 35843
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
35753: LD_ADDR_VAR 0 6
35757: PUSH
35758: LD_INT 22
35760: PUSH
35761: LD_VAR 0 3
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PPUSH
35770: CALL_OW 69
35774: ST_TO_ADDR
// if not un then
35775: LD_VAR 0 6
35779: NOT
35780: IFFALSE 35784
// continue ;
35782: GO 35750
// nation := GetNation ( un [ 1 ] ) ;
35784: LD_ADDR_VAR 0 4
35788: PUSH
35789: LD_VAR 0 6
35793: PUSH
35794: LD_INT 1
35796: ARRAY
35797: PPUSH
35798: CALL_OW 248
35802: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
35803: LD_ADDR_EXP 126
35807: PUSH
35808: LD_EXP 126
35812: PPUSH
35813: LD_VAR 0 3
35817: PPUSH
35818: LD_VAR 0 3
35822: PPUSH
35823: LD_VAR 0 4
35827: PPUSH
35828: LD_INT 1
35830: PPUSH
35831: CALL 61627 0 3
35835: PPUSH
35836: CALL_OW 1
35840: ST_TO_ADDR
// end ;
35841: GO 35750
35843: POP
35844: POP
// end ;
35845: LD_VAR 0 1
35849: RET
// export function MC_InitSides ( ) ; var i ; begin
35850: LD_INT 0
35852: PPUSH
35853: PPUSH
// if not mc_bases then
35854: LD_EXP 99
35858: NOT
35859: IFFALSE 35863
// exit ;
35861: GO 35937
// for i = 1 to mc_bases do
35863: LD_ADDR_VAR 0 2
35867: PUSH
35868: DOUBLE
35869: LD_INT 1
35871: DEC
35872: ST_TO_ADDR
35873: LD_EXP 99
35877: PUSH
35878: FOR_TO
35879: IFFALSE 35935
// if mc_bases [ i ] then
35881: LD_EXP 99
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: IFFALSE 35933
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
35893: LD_ADDR_EXP 125
35897: PUSH
35898: LD_EXP 125
35902: PPUSH
35903: LD_VAR 0 2
35907: PPUSH
35908: LD_EXP 99
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: PUSH
35919: LD_INT 1
35921: ARRAY
35922: PPUSH
35923: CALL_OW 255
35927: PPUSH
35928: CALL_OW 1
35932: ST_TO_ADDR
35933: GO 35878
35935: POP
35936: POP
// end ;
35937: LD_VAR 0 1
35941: RET
// every 0 0$01 trigger skirmish do
35942: LD_EXP 97
35946: IFFALSE 36100
35948: GO 35950
35950: DISABLE
// begin enable ;
35951: ENABLE
// MC_CheckBuildings ( ) ;
35952: CALL 40589 0 0
// MC_CheckPeopleLife ( ) ;
35956: CALL 40714 0 0
// RaiseSailEvent ( 100 ) ;
35960: LD_INT 100
35962: PPUSH
35963: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
35967: LD_INT 103
35969: PPUSH
35970: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
35974: LD_INT 104
35976: PPUSH
35977: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
35981: LD_INT 105
35983: PPUSH
35984: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
35988: LD_INT 106
35990: PPUSH
35991: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
35995: LD_INT 107
35997: PPUSH
35998: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
36002: LD_INT 108
36004: PPUSH
36005: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
36009: LD_INT 109
36011: PPUSH
36012: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
36016: LD_INT 110
36018: PPUSH
36019: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
36023: LD_INT 111
36025: PPUSH
36026: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
36030: LD_INT 112
36032: PPUSH
36033: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
36037: LD_INT 113
36039: PPUSH
36040: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
36044: LD_INT 120
36046: PPUSH
36047: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
36051: LD_INT 121
36053: PPUSH
36054: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
36058: LD_INT 122
36060: PPUSH
36061: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
36065: LD_INT 123
36067: PPUSH
36068: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
36072: LD_INT 124
36074: PPUSH
36075: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
36079: LD_INT 125
36081: PPUSH
36082: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
36086: LD_INT 126
36088: PPUSH
36089: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
36093: LD_INT 200
36095: PPUSH
36096: CALL_OW 427
// end ;
36100: END
// on SailEvent ( event ) do begin if event < 100 then
36101: LD_VAR 0 1
36105: PUSH
36106: LD_INT 100
36108: LESS
36109: IFFALSE 36120
// CustomEvent ( event ) ;
36111: LD_VAR 0 1
36115: PPUSH
36116: CALL 31777 0 1
// if event = 100 then
36120: LD_VAR 0 1
36124: PUSH
36125: LD_INT 100
36127: EQUAL
36128: IFFALSE 36134
// MC_ClassManager ( ) ;
36130: CALL 36526 0 0
// if event = 101 then
36134: LD_VAR 0 1
36138: PUSH
36139: LD_INT 101
36141: EQUAL
36142: IFFALSE 36148
// MC_RepairBuildings ( ) ;
36144: CALL 41310 0 0
// if event = 102 then
36148: LD_VAR 0 1
36152: PUSH
36153: LD_INT 102
36155: EQUAL
36156: IFFALSE 36162
// MC_Heal ( ) ;
36158: CALL 41716 0 0
// if event = 103 then
36162: LD_VAR 0 1
36166: PUSH
36167: LD_INT 103
36169: EQUAL
36170: IFFALSE 36176
// MC_Build ( ) ;
36172: CALL 42138 0 0
// if event = 104 then
36176: LD_VAR 0 1
36180: PUSH
36181: LD_INT 104
36183: EQUAL
36184: IFFALSE 36190
// MC_TurretWeapon ( ) ;
36186: CALL 43751 0 0
// if event = 105 then
36190: LD_VAR 0 1
36194: PUSH
36195: LD_INT 105
36197: EQUAL
36198: IFFALSE 36204
// MC_BuildUpgrade ( ) ;
36200: CALL 43302 0 0
// if event = 106 then
36204: LD_VAR 0 1
36208: PUSH
36209: LD_INT 106
36211: EQUAL
36212: IFFALSE 36218
// MC_PlantMines ( ) ;
36214: CALL 44181 0 0
// if event = 107 then
36218: LD_VAR 0 1
36222: PUSH
36223: LD_INT 107
36225: EQUAL
36226: IFFALSE 36232
// MC_CollectCrates ( ) ;
36228: CALL 45215 0 0
// if event = 108 then
36232: LD_VAR 0 1
36236: PUSH
36237: LD_INT 108
36239: EQUAL
36240: IFFALSE 36246
// MC_LinkRemoteControl ( ) ;
36242: CALL 46972 0 0
// if event = 109 then
36246: LD_VAR 0 1
36250: PUSH
36251: LD_INT 109
36253: EQUAL
36254: IFFALSE 36260
// MC_ProduceVehicle ( ) ;
36256: CALL 47153 0 0
// if event = 110 then
36260: LD_VAR 0 1
36264: PUSH
36265: LD_INT 110
36267: EQUAL
36268: IFFALSE 36274
// MC_SendAttack ( ) ;
36270: CALL 47634 0 0
// if event = 111 then
36274: LD_VAR 0 1
36278: PUSH
36279: LD_INT 111
36281: EQUAL
36282: IFFALSE 36288
// MC_Defend ( ) ;
36284: CALL 47742 0 0
// if event = 112 then
36288: LD_VAR 0 1
36292: PUSH
36293: LD_INT 112
36295: EQUAL
36296: IFFALSE 36302
// MC_Research ( ) ;
36298: CALL 48369 0 0
// if event = 113 then
36302: LD_VAR 0 1
36306: PUSH
36307: LD_INT 113
36309: EQUAL
36310: IFFALSE 36316
// MC_MinesTrigger ( ) ;
36312: CALL 49483 0 0
// if event = 120 then
36316: LD_VAR 0 1
36320: PUSH
36321: LD_INT 120
36323: EQUAL
36324: IFFALSE 36330
// MC_RepairVehicle ( ) ;
36326: CALL 49582 0 0
// if event = 121 then
36330: LD_VAR 0 1
36334: PUSH
36335: LD_INT 121
36337: EQUAL
36338: IFFALSE 36344
// MC_TameApe ( ) ;
36340: CALL 50325 0 0
// if event = 122 then
36344: LD_VAR 0 1
36348: PUSH
36349: LD_INT 122
36351: EQUAL
36352: IFFALSE 36358
// MC_ChangeApeClass ( ) ;
36354: CALL 51154 0 0
// if event = 123 then
36358: LD_VAR 0 1
36362: PUSH
36363: LD_INT 123
36365: EQUAL
36366: IFFALSE 36372
// MC_Bazooka ( ) ;
36368: CALL 51804 0 0
// if event = 124 then
36372: LD_VAR 0 1
36376: PUSH
36377: LD_INT 124
36379: EQUAL
36380: IFFALSE 36386
// MC_TeleportExit ( ) ;
36382: CALL 52002 0 0
// if event = 125 then
36386: LD_VAR 0 1
36390: PUSH
36391: LD_INT 125
36393: EQUAL
36394: IFFALSE 36400
// MC_Deposits ( ) ;
36396: CALL 52649 0 0
// if event = 126 then
36400: LD_VAR 0 1
36404: PUSH
36405: LD_INT 126
36407: EQUAL
36408: IFFALSE 36414
// MC_RemoteDriver ( ) ;
36410: CALL 53274 0 0
// if event = 200 then
36414: LD_VAR 0 1
36418: PUSH
36419: LD_INT 200
36421: EQUAL
36422: IFFALSE 36428
// MC_Idle ( ) ;
36424: CALL 55007 0 0
// end ;
36428: PPOPN 1
36430: END
// export function MC_Reset ( base , tag ) ; var i ; begin
36431: LD_INT 0
36433: PPUSH
36434: PPUSH
// if not mc_bases [ base ] or not tag then
36435: LD_EXP 99
36439: PUSH
36440: LD_VAR 0 1
36444: ARRAY
36445: NOT
36446: PUSH
36447: LD_VAR 0 2
36451: NOT
36452: OR
36453: IFFALSE 36457
// exit ;
36455: GO 36521
// for i in mc_bases [ base ] union mc_ape [ base ] do
36457: LD_ADDR_VAR 0 4
36461: PUSH
36462: LD_EXP 99
36466: PUSH
36467: LD_VAR 0 1
36471: ARRAY
36472: PUSH
36473: LD_EXP 128
36477: PUSH
36478: LD_VAR 0 1
36482: ARRAY
36483: UNION
36484: PUSH
36485: FOR_IN
36486: IFFALSE 36519
// if GetTag ( i ) = tag then
36488: LD_VAR 0 4
36492: PPUSH
36493: CALL_OW 110
36497: PUSH
36498: LD_VAR 0 2
36502: EQUAL
36503: IFFALSE 36517
// SetTag ( i , 0 ) ;
36505: LD_VAR 0 4
36509: PPUSH
36510: LD_INT 0
36512: PPUSH
36513: CALL_OW 109
36517: GO 36485
36519: POP
36520: POP
// end ;
36521: LD_VAR 0 3
36525: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
36526: LD_INT 0
36528: PPUSH
36529: PPUSH
36530: PPUSH
36531: PPUSH
36532: PPUSH
36533: PPUSH
36534: PPUSH
36535: PPUSH
// if not mc_bases then
36536: LD_EXP 99
36540: NOT
36541: IFFALSE 36545
// exit ;
36543: GO 37003
// for i = 1 to mc_bases do
36545: LD_ADDR_VAR 0 2
36549: PUSH
36550: DOUBLE
36551: LD_INT 1
36553: DEC
36554: ST_TO_ADDR
36555: LD_EXP 99
36559: PUSH
36560: FOR_TO
36561: IFFALSE 37001
// begin tmp := MC_ClassCheckReq ( i ) ;
36563: LD_ADDR_VAR 0 4
36567: PUSH
36568: LD_VAR 0 2
36572: PPUSH
36573: CALL 37008 0 1
36577: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
36578: LD_ADDR_EXP 140
36582: PUSH
36583: LD_EXP 140
36587: PPUSH
36588: LD_VAR 0 2
36592: PPUSH
36593: LD_VAR 0 4
36597: PPUSH
36598: CALL_OW 1
36602: ST_TO_ADDR
// if not tmp then
36603: LD_VAR 0 4
36607: NOT
36608: IFFALSE 36612
// continue ;
36610: GO 36560
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
36612: LD_ADDR_VAR 0 6
36616: PUSH
36617: LD_EXP 99
36621: PUSH
36622: LD_VAR 0 2
36626: ARRAY
36627: PPUSH
36628: LD_INT 2
36630: PUSH
36631: LD_INT 30
36633: PUSH
36634: LD_INT 4
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 30
36643: PUSH
36644: LD_INT 5
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: LIST
36655: PPUSH
36656: CALL_OW 72
36660: PUSH
36661: LD_EXP 99
36665: PUSH
36666: LD_VAR 0 2
36670: ARRAY
36671: PPUSH
36672: LD_INT 2
36674: PUSH
36675: LD_INT 30
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 30
36687: PUSH
36688: LD_INT 1
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: LIST
36699: PPUSH
36700: CALL_OW 72
36704: PUSH
36705: LD_EXP 99
36709: PUSH
36710: LD_VAR 0 2
36714: ARRAY
36715: PPUSH
36716: LD_INT 30
36718: PUSH
36719: LD_INT 3
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PPUSH
36726: CALL_OW 72
36730: PUSH
36731: LD_EXP 99
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: PPUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 30
36747: PUSH
36748: LD_INT 6
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 30
36757: PUSH
36758: LD_INT 7
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 30
36767: PUSH
36768: LD_INT 8
36770: PUSH
36771: EMPTY
36772: LIST
36773: LIST
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: PPUSH
36781: CALL_OW 72
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: ST_TO_ADDR
// for j = 1 to 4 do
36792: LD_ADDR_VAR 0 3
36796: PUSH
36797: DOUBLE
36798: LD_INT 1
36800: DEC
36801: ST_TO_ADDR
36802: LD_INT 4
36804: PUSH
36805: FOR_TO
36806: IFFALSE 36997
// begin if not tmp [ j ] then
36808: LD_VAR 0 4
36812: PUSH
36813: LD_VAR 0 3
36817: ARRAY
36818: NOT
36819: IFFALSE 36823
// continue ;
36821: GO 36805
// for p in tmp [ j ] do
36823: LD_ADDR_VAR 0 5
36827: PUSH
36828: LD_VAR 0 4
36832: PUSH
36833: LD_VAR 0 3
36837: ARRAY
36838: PUSH
36839: FOR_IN
36840: IFFALSE 36993
// begin if not b [ j ] then
36842: LD_VAR 0 6
36846: PUSH
36847: LD_VAR 0 3
36851: ARRAY
36852: NOT
36853: IFFALSE 36857
// break ;
36855: GO 36993
// e := 0 ;
36857: LD_ADDR_VAR 0 7
36861: PUSH
36862: LD_INT 0
36864: ST_TO_ADDR
// for k in b [ j ] do
36865: LD_ADDR_VAR 0 8
36869: PUSH
36870: LD_VAR 0 6
36874: PUSH
36875: LD_VAR 0 3
36879: ARRAY
36880: PUSH
36881: FOR_IN
36882: IFFALSE 36909
// if IsNotFull ( k ) then
36884: LD_VAR 0 8
36888: PPUSH
36889: CALL 65653 0 1
36893: IFFALSE 36907
// begin e := k ;
36895: LD_ADDR_VAR 0 7
36899: PUSH
36900: LD_VAR 0 8
36904: ST_TO_ADDR
// break ;
36905: GO 36909
// end ;
36907: GO 36881
36909: POP
36910: POP
// if e and not UnitGoingToBuilding ( p , e ) then
36911: LD_VAR 0 7
36915: PUSH
36916: LD_VAR 0 5
36920: PPUSH
36921: LD_VAR 0 7
36925: PPUSH
36926: CALL 102641 0 2
36930: NOT
36931: AND
36932: IFFALSE 36991
// begin if IsInUnit ( p ) then
36934: LD_VAR 0 5
36938: PPUSH
36939: CALL_OW 310
36943: IFFALSE 36954
// ComExitBuilding ( p ) ;
36945: LD_VAR 0 5
36949: PPUSH
36950: CALL_OW 122
// ComEnterUnit ( p , e ) ;
36954: LD_VAR 0 5
36958: PPUSH
36959: LD_VAR 0 7
36963: PPUSH
36964: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
36968: LD_VAR 0 5
36972: PPUSH
36973: LD_VAR 0 3
36977: PPUSH
36978: CALL_OW 183
// AddComExitBuilding ( p ) ;
36982: LD_VAR 0 5
36986: PPUSH
36987: CALL_OW 182
// end ; end ;
36991: GO 36839
36993: POP
36994: POP
// end ;
36995: GO 36805
36997: POP
36998: POP
// end ;
36999: GO 36560
37001: POP
37002: POP
// end ;
37003: LD_VAR 0 1
37007: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
37008: LD_INT 0
37010: PPUSH
37011: PPUSH
37012: PPUSH
37013: PPUSH
37014: PPUSH
37015: PPUSH
37016: PPUSH
37017: PPUSH
37018: PPUSH
37019: PPUSH
37020: PPUSH
37021: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37022: LD_VAR 0 1
37026: NOT
37027: PUSH
37028: LD_EXP 99
37032: PUSH
37033: LD_VAR 0 1
37037: ARRAY
37038: NOT
37039: OR
37040: PUSH
37041: LD_EXP 99
37045: PUSH
37046: LD_VAR 0 1
37050: ARRAY
37051: PPUSH
37052: LD_INT 2
37054: PUSH
37055: LD_INT 30
37057: PUSH
37058: LD_INT 0
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: LD_INT 30
37067: PUSH
37068: LD_INT 1
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: LIST
37079: PPUSH
37080: CALL_OW 72
37084: NOT
37085: OR
37086: IFFALSE 37090
// exit ;
37088: GO 40584
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37090: LD_ADDR_VAR 0 4
37094: PUSH
37095: LD_EXP 99
37099: PUSH
37100: LD_VAR 0 1
37104: ARRAY
37105: PPUSH
37106: LD_INT 2
37108: PUSH
37109: LD_INT 25
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 25
37121: PUSH
37122: LD_INT 2
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 25
37131: PUSH
37132: LD_INT 3
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 25
37141: PUSH
37142: LD_INT 4
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 25
37151: PUSH
37152: LD_INT 5
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 25
37161: PUSH
37162: LD_INT 8
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 25
37171: PUSH
37172: LD_INT 9
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: PPUSH
37189: CALL_OW 72
37193: ST_TO_ADDR
// for i in tmp do
37194: LD_ADDR_VAR 0 3
37198: PUSH
37199: LD_VAR 0 4
37203: PUSH
37204: FOR_IN
37205: IFFALSE 37236
// if GetTag ( i ) then
37207: LD_VAR 0 3
37211: PPUSH
37212: CALL_OW 110
37216: IFFALSE 37234
// tmp := tmp diff i ;
37218: LD_ADDR_VAR 0 4
37222: PUSH
37223: LD_VAR 0 4
37227: PUSH
37228: LD_VAR 0 3
37232: DIFF
37233: ST_TO_ADDR
37234: GO 37204
37236: POP
37237: POP
// if not tmp then
37238: LD_VAR 0 4
37242: NOT
37243: IFFALSE 37247
// exit ;
37245: GO 40584
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37247: LD_ADDR_VAR 0 5
37251: PUSH
37252: LD_EXP 99
37256: PUSH
37257: LD_VAR 0 1
37261: ARRAY
37262: PPUSH
37263: LD_INT 2
37265: PUSH
37266: LD_INT 25
37268: PUSH
37269: LD_INT 1
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 25
37278: PUSH
37279: LD_INT 5
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 25
37288: PUSH
37289: LD_INT 8
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 25
37298: PUSH
37299: LD_INT 9
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: PPUSH
37313: CALL_OW 72
37317: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
37318: LD_ADDR_VAR 0 6
37322: PUSH
37323: LD_EXP 99
37327: PUSH
37328: LD_VAR 0 1
37332: ARRAY
37333: PPUSH
37334: LD_INT 25
37336: PUSH
37337: LD_INT 2
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PPUSH
37344: CALL_OW 72
37348: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
37349: LD_ADDR_VAR 0 7
37353: PUSH
37354: LD_EXP 99
37358: PUSH
37359: LD_VAR 0 1
37363: ARRAY
37364: PPUSH
37365: LD_INT 25
37367: PUSH
37368: LD_INT 3
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PPUSH
37375: CALL_OW 72
37379: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
37380: LD_ADDR_VAR 0 8
37384: PUSH
37385: LD_EXP 99
37389: PUSH
37390: LD_VAR 0 1
37394: ARRAY
37395: PPUSH
37396: LD_INT 25
37398: PUSH
37399: LD_INT 4
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 24
37408: PUSH
37409: LD_INT 251
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PPUSH
37420: CALL_OW 72
37424: ST_TO_ADDR
// if mc_scan [ base ] then
37425: LD_EXP 122
37429: PUSH
37430: LD_VAR 0 1
37434: ARRAY
37435: IFFALSE 37896
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
37437: LD_ADDR_EXP 141
37441: PUSH
37442: LD_EXP 141
37446: PPUSH
37447: LD_VAR 0 1
37451: PPUSH
37452: LD_INT 4
37454: PPUSH
37455: CALL_OW 1
37459: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37460: LD_ADDR_VAR 0 12
37464: PUSH
37465: LD_EXP 99
37469: PUSH
37470: LD_VAR 0 1
37474: ARRAY
37475: PPUSH
37476: LD_INT 2
37478: PUSH
37479: LD_INT 30
37481: PUSH
37482: LD_INT 4
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 30
37491: PUSH
37492: LD_INT 5
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: LIST
37503: PPUSH
37504: CALL_OW 72
37508: ST_TO_ADDR
// if not b then
37509: LD_VAR 0 12
37513: NOT
37514: IFFALSE 37518
// exit ;
37516: GO 40584
// p := [ ] ;
37518: LD_ADDR_VAR 0 11
37522: PUSH
37523: EMPTY
37524: ST_TO_ADDR
// if sci >= 2 then
37525: LD_VAR 0 8
37529: PUSH
37530: LD_INT 2
37532: GREATEREQUAL
37533: IFFALSE 37564
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
37535: LD_ADDR_VAR 0 8
37539: PUSH
37540: LD_VAR 0 8
37544: PUSH
37545: LD_INT 1
37547: ARRAY
37548: PUSH
37549: LD_VAR 0 8
37553: PUSH
37554: LD_INT 2
37556: ARRAY
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: ST_TO_ADDR
37562: GO 37625
// if sci = 1 then
37564: LD_VAR 0 8
37568: PUSH
37569: LD_INT 1
37571: EQUAL
37572: IFFALSE 37593
// sci := [ sci [ 1 ] ] else
37574: LD_ADDR_VAR 0 8
37578: PUSH
37579: LD_VAR 0 8
37583: PUSH
37584: LD_INT 1
37586: ARRAY
37587: PUSH
37588: EMPTY
37589: LIST
37590: ST_TO_ADDR
37591: GO 37625
// if sci = 0 then
37593: LD_VAR 0 8
37597: PUSH
37598: LD_INT 0
37600: EQUAL
37601: IFFALSE 37625
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
37603: LD_ADDR_VAR 0 11
37607: PUSH
37608: LD_VAR 0 4
37612: PPUSH
37613: LD_INT 4
37615: PPUSH
37616: CALL 102504 0 2
37620: PUSH
37621: LD_INT 1
37623: ARRAY
37624: ST_TO_ADDR
// if eng > 4 then
37625: LD_VAR 0 6
37629: PUSH
37630: LD_INT 4
37632: GREATER
37633: IFFALSE 37679
// for i = eng downto 4 do
37635: LD_ADDR_VAR 0 3
37639: PUSH
37640: DOUBLE
37641: LD_VAR 0 6
37645: INC
37646: ST_TO_ADDR
37647: LD_INT 4
37649: PUSH
37650: FOR_DOWNTO
37651: IFFALSE 37677
// eng := eng diff eng [ i ] ;
37653: LD_ADDR_VAR 0 6
37657: PUSH
37658: LD_VAR 0 6
37662: PUSH
37663: LD_VAR 0 6
37667: PUSH
37668: LD_VAR 0 3
37672: ARRAY
37673: DIFF
37674: ST_TO_ADDR
37675: GO 37650
37677: POP
37678: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
37679: LD_ADDR_VAR 0 4
37683: PUSH
37684: LD_VAR 0 4
37688: PUSH
37689: LD_VAR 0 5
37693: PUSH
37694: LD_VAR 0 6
37698: UNION
37699: PUSH
37700: LD_VAR 0 7
37704: UNION
37705: PUSH
37706: LD_VAR 0 8
37710: UNION
37711: DIFF
37712: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
37713: LD_ADDR_VAR 0 13
37717: PUSH
37718: LD_EXP 99
37722: PUSH
37723: LD_VAR 0 1
37727: ARRAY
37728: PPUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 30
37734: PUSH
37735: LD_INT 32
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 31
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: LIST
37756: PPUSH
37757: CALL_OW 72
37761: PUSH
37762: LD_EXP 99
37766: PUSH
37767: LD_VAR 0 1
37771: ARRAY
37772: PPUSH
37773: LD_INT 2
37775: PUSH
37776: LD_INT 30
37778: PUSH
37779: LD_INT 4
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 30
37788: PUSH
37789: LD_INT 5
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: LIST
37800: PPUSH
37801: CALL_OW 72
37805: PUSH
37806: LD_INT 6
37808: MUL
37809: PLUS
37810: ST_TO_ADDR
// if bcount < tmp then
37811: LD_VAR 0 13
37815: PUSH
37816: LD_VAR 0 4
37820: LESS
37821: IFFALSE 37867
// for i = tmp downto bcount do
37823: LD_ADDR_VAR 0 3
37827: PUSH
37828: DOUBLE
37829: LD_VAR 0 4
37833: INC
37834: ST_TO_ADDR
37835: LD_VAR 0 13
37839: PUSH
37840: FOR_DOWNTO
37841: IFFALSE 37865
// tmp := Delete ( tmp , tmp ) ;
37843: LD_ADDR_VAR 0 4
37847: PUSH
37848: LD_VAR 0 4
37852: PPUSH
37853: LD_VAR 0 4
37857: PPUSH
37858: CALL_OW 3
37862: ST_TO_ADDR
37863: GO 37840
37865: POP
37866: POP
// result := [ tmp , 0 , 0 , p ] ;
37867: LD_ADDR_VAR 0 2
37871: PUSH
37872: LD_VAR 0 4
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: LD_INT 0
37882: PUSH
37883: LD_VAR 0 11
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: ST_TO_ADDR
// exit ;
37894: GO 40584
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
37896: LD_EXP 99
37900: PUSH
37901: LD_VAR 0 1
37905: ARRAY
37906: PPUSH
37907: LD_INT 2
37909: PUSH
37910: LD_INT 30
37912: PUSH
37913: LD_INT 6
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 30
37922: PUSH
37923: LD_INT 7
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 30
37932: PUSH
37933: LD_INT 8
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: PPUSH
37946: CALL_OW 72
37950: NOT
37951: PUSH
37952: LD_EXP 99
37956: PUSH
37957: LD_VAR 0 1
37961: ARRAY
37962: PPUSH
37963: LD_INT 30
37965: PUSH
37966: LD_INT 3
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PPUSH
37973: CALL_OW 72
37977: NOT
37978: AND
37979: IFFALSE 38051
// begin if eng = tmp then
37981: LD_VAR 0 6
37985: PUSH
37986: LD_VAR 0 4
37990: EQUAL
37991: IFFALSE 37995
// exit ;
37993: GO 40584
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
37995: LD_ADDR_EXP 141
37999: PUSH
38000: LD_EXP 141
38004: PPUSH
38005: LD_VAR 0 1
38009: PPUSH
38010: LD_INT 1
38012: PPUSH
38013: CALL_OW 1
38017: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
38018: LD_ADDR_VAR 0 2
38022: PUSH
38023: LD_INT 0
38025: PUSH
38026: LD_VAR 0 4
38030: PUSH
38031: LD_VAR 0 6
38035: DIFF
38036: PUSH
38037: LD_INT 0
38039: PUSH
38040: LD_INT 0
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: ST_TO_ADDR
// exit ;
38049: GO 40584
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38051: LD_EXP 126
38055: PUSH
38056: LD_EXP 125
38060: PUSH
38061: LD_VAR 0 1
38065: ARRAY
38066: ARRAY
38067: PUSH
38068: LD_EXP 99
38072: PUSH
38073: LD_VAR 0 1
38077: ARRAY
38078: PPUSH
38079: LD_INT 2
38081: PUSH
38082: LD_INT 30
38084: PUSH
38085: LD_INT 6
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 30
38094: PUSH
38095: LD_INT 7
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 30
38104: PUSH
38105: LD_INT 8
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: PPUSH
38118: CALL_OW 72
38122: AND
38123: PUSH
38124: LD_EXP 99
38128: PUSH
38129: LD_VAR 0 1
38133: ARRAY
38134: PPUSH
38135: LD_INT 30
38137: PUSH
38138: LD_INT 3
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PPUSH
38145: CALL_OW 72
38149: NOT
38150: AND
38151: IFFALSE 38365
// begin if sci >= 6 then
38153: LD_VAR 0 8
38157: PUSH
38158: LD_INT 6
38160: GREATEREQUAL
38161: IFFALSE 38165
// exit ;
38163: GO 40584
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
38165: LD_ADDR_EXP 141
38169: PUSH
38170: LD_EXP 141
38174: PPUSH
38175: LD_VAR 0 1
38179: PPUSH
38180: LD_INT 2
38182: PPUSH
38183: CALL_OW 1
38187: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
38188: LD_ADDR_VAR 0 9
38192: PUSH
38193: LD_VAR 0 4
38197: PUSH
38198: LD_VAR 0 8
38202: DIFF
38203: PPUSH
38204: LD_INT 4
38206: PPUSH
38207: CALL 102504 0 2
38211: ST_TO_ADDR
// p := [ ] ;
38212: LD_ADDR_VAR 0 11
38216: PUSH
38217: EMPTY
38218: ST_TO_ADDR
// if sci < 6 and sort > 6 then
38219: LD_VAR 0 8
38223: PUSH
38224: LD_INT 6
38226: LESS
38227: PUSH
38228: LD_VAR 0 9
38232: PUSH
38233: LD_INT 6
38235: GREATER
38236: AND
38237: IFFALSE 38318
// begin for i = 1 to 6 - sci do
38239: LD_ADDR_VAR 0 3
38243: PUSH
38244: DOUBLE
38245: LD_INT 1
38247: DEC
38248: ST_TO_ADDR
38249: LD_INT 6
38251: PUSH
38252: LD_VAR 0 8
38256: MINUS
38257: PUSH
38258: FOR_TO
38259: IFFALSE 38314
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
38261: LD_ADDR_VAR 0 11
38265: PUSH
38266: LD_VAR 0 11
38270: PPUSH
38271: LD_VAR 0 11
38275: PUSH
38276: LD_INT 1
38278: PLUS
38279: PPUSH
38280: LD_VAR 0 9
38284: PUSH
38285: LD_INT 1
38287: ARRAY
38288: PPUSH
38289: CALL_OW 2
38293: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
38294: LD_ADDR_VAR 0 9
38298: PUSH
38299: LD_VAR 0 9
38303: PPUSH
38304: LD_INT 1
38306: PPUSH
38307: CALL_OW 3
38311: ST_TO_ADDR
// end ;
38312: GO 38258
38314: POP
38315: POP
// end else
38316: GO 38338
// if sort then
38318: LD_VAR 0 9
38322: IFFALSE 38338
// p := sort [ 1 ] ;
38324: LD_ADDR_VAR 0 11
38328: PUSH
38329: LD_VAR 0 9
38333: PUSH
38334: LD_INT 1
38336: ARRAY
38337: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
38338: LD_ADDR_VAR 0 2
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: LD_INT 0
38348: PUSH
38349: LD_INT 0
38351: PUSH
38352: LD_VAR 0 11
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: ST_TO_ADDR
// exit ;
38363: GO 40584
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38365: LD_EXP 126
38369: PUSH
38370: LD_EXP 125
38374: PUSH
38375: LD_VAR 0 1
38379: ARRAY
38380: ARRAY
38381: PUSH
38382: LD_EXP 99
38386: PUSH
38387: LD_VAR 0 1
38391: ARRAY
38392: PPUSH
38393: LD_INT 2
38395: PUSH
38396: LD_INT 30
38398: PUSH
38399: LD_INT 6
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 30
38408: PUSH
38409: LD_INT 7
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 30
38418: PUSH
38419: LD_INT 8
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: PPUSH
38432: CALL_OW 72
38436: AND
38437: PUSH
38438: LD_EXP 99
38442: PUSH
38443: LD_VAR 0 1
38447: ARRAY
38448: PPUSH
38449: LD_INT 30
38451: PUSH
38452: LD_INT 3
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PPUSH
38459: CALL_OW 72
38463: AND
38464: IFFALSE 39198
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
38466: LD_ADDR_EXP 141
38470: PUSH
38471: LD_EXP 141
38475: PPUSH
38476: LD_VAR 0 1
38480: PPUSH
38481: LD_INT 3
38483: PPUSH
38484: CALL_OW 1
38488: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
38489: LD_ADDR_VAR 0 2
38493: PUSH
38494: LD_INT 0
38496: PUSH
38497: LD_INT 0
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: ST_TO_ADDR
// if not eng then
38512: LD_VAR 0 6
38516: NOT
38517: IFFALSE 38580
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
38519: LD_ADDR_VAR 0 11
38523: PUSH
38524: LD_VAR 0 4
38528: PPUSH
38529: LD_INT 2
38531: PPUSH
38532: CALL 102504 0 2
38536: PUSH
38537: LD_INT 1
38539: ARRAY
38540: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
38541: LD_ADDR_VAR 0 2
38545: PUSH
38546: LD_VAR 0 2
38550: PPUSH
38551: LD_INT 2
38553: PPUSH
38554: LD_VAR 0 11
38558: PPUSH
38559: CALL_OW 1
38563: ST_TO_ADDR
// tmp := tmp diff p ;
38564: LD_ADDR_VAR 0 4
38568: PUSH
38569: LD_VAR 0 4
38573: PUSH
38574: LD_VAR 0 11
38578: DIFF
38579: ST_TO_ADDR
// end ; if tmp and sci < 6 then
38580: LD_VAR 0 4
38584: PUSH
38585: LD_VAR 0 8
38589: PUSH
38590: LD_INT 6
38592: LESS
38593: AND
38594: IFFALSE 38782
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
38596: LD_ADDR_VAR 0 9
38600: PUSH
38601: LD_VAR 0 4
38605: PUSH
38606: LD_VAR 0 8
38610: PUSH
38611: LD_VAR 0 7
38615: UNION
38616: DIFF
38617: PPUSH
38618: LD_INT 4
38620: PPUSH
38621: CALL 102504 0 2
38625: ST_TO_ADDR
// p := [ ] ;
38626: LD_ADDR_VAR 0 11
38630: PUSH
38631: EMPTY
38632: ST_TO_ADDR
// if sort then
38633: LD_VAR 0 9
38637: IFFALSE 38753
// for i = 1 to 6 - sci do
38639: LD_ADDR_VAR 0 3
38643: PUSH
38644: DOUBLE
38645: LD_INT 1
38647: DEC
38648: ST_TO_ADDR
38649: LD_INT 6
38651: PUSH
38652: LD_VAR 0 8
38656: MINUS
38657: PUSH
38658: FOR_TO
38659: IFFALSE 38751
// begin if i = sort then
38661: LD_VAR 0 3
38665: PUSH
38666: LD_VAR 0 9
38670: EQUAL
38671: IFFALSE 38675
// break ;
38673: GO 38751
// if GetClass ( i ) = 4 then
38675: LD_VAR 0 3
38679: PPUSH
38680: CALL_OW 257
38684: PUSH
38685: LD_INT 4
38687: EQUAL
38688: IFFALSE 38692
// continue ;
38690: GO 38658
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38692: LD_ADDR_VAR 0 11
38696: PUSH
38697: LD_VAR 0 11
38701: PPUSH
38702: LD_VAR 0 11
38706: PUSH
38707: LD_INT 1
38709: PLUS
38710: PPUSH
38711: LD_VAR 0 9
38715: PUSH
38716: LD_VAR 0 3
38720: ARRAY
38721: PPUSH
38722: CALL_OW 2
38726: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38727: LD_ADDR_VAR 0 4
38731: PUSH
38732: LD_VAR 0 4
38736: PUSH
38737: LD_VAR 0 9
38741: PUSH
38742: LD_VAR 0 3
38746: ARRAY
38747: DIFF
38748: ST_TO_ADDR
// end ;
38749: GO 38658
38751: POP
38752: POP
// if p then
38753: LD_VAR 0 11
38757: IFFALSE 38782
// result := Replace ( result , 4 , p ) ;
38759: LD_ADDR_VAR 0 2
38763: PUSH
38764: LD_VAR 0 2
38768: PPUSH
38769: LD_INT 4
38771: PPUSH
38772: LD_VAR 0 11
38776: PPUSH
38777: CALL_OW 1
38781: ST_TO_ADDR
// end ; if tmp and mech < 6 then
38782: LD_VAR 0 4
38786: PUSH
38787: LD_VAR 0 7
38791: PUSH
38792: LD_INT 6
38794: LESS
38795: AND
38796: IFFALSE 38984
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
38798: LD_ADDR_VAR 0 9
38802: PUSH
38803: LD_VAR 0 4
38807: PUSH
38808: LD_VAR 0 8
38812: PUSH
38813: LD_VAR 0 7
38817: UNION
38818: DIFF
38819: PPUSH
38820: LD_INT 3
38822: PPUSH
38823: CALL 102504 0 2
38827: ST_TO_ADDR
// p := [ ] ;
38828: LD_ADDR_VAR 0 11
38832: PUSH
38833: EMPTY
38834: ST_TO_ADDR
// if sort then
38835: LD_VAR 0 9
38839: IFFALSE 38955
// for i = 1 to 6 - mech do
38841: LD_ADDR_VAR 0 3
38845: PUSH
38846: DOUBLE
38847: LD_INT 1
38849: DEC
38850: ST_TO_ADDR
38851: LD_INT 6
38853: PUSH
38854: LD_VAR 0 7
38858: MINUS
38859: PUSH
38860: FOR_TO
38861: IFFALSE 38953
// begin if i = sort then
38863: LD_VAR 0 3
38867: PUSH
38868: LD_VAR 0 9
38872: EQUAL
38873: IFFALSE 38877
// break ;
38875: GO 38953
// if GetClass ( i ) = 3 then
38877: LD_VAR 0 3
38881: PPUSH
38882: CALL_OW 257
38886: PUSH
38887: LD_INT 3
38889: EQUAL
38890: IFFALSE 38894
// continue ;
38892: GO 38860
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38894: LD_ADDR_VAR 0 11
38898: PUSH
38899: LD_VAR 0 11
38903: PPUSH
38904: LD_VAR 0 11
38908: PUSH
38909: LD_INT 1
38911: PLUS
38912: PPUSH
38913: LD_VAR 0 9
38917: PUSH
38918: LD_VAR 0 3
38922: ARRAY
38923: PPUSH
38924: CALL_OW 2
38928: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38929: LD_ADDR_VAR 0 4
38933: PUSH
38934: LD_VAR 0 4
38938: PUSH
38939: LD_VAR 0 9
38943: PUSH
38944: LD_VAR 0 3
38948: ARRAY
38949: DIFF
38950: ST_TO_ADDR
// end ;
38951: GO 38860
38953: POP
38954: POP
// if p then
38955: LD_VAR 0 11
38959: IFFALSE 38984
// result := Replace ( result , 3 , p ) ;
38961: LD_ADDR_VAR 0 2
38965: PUSH
38966: LD_VAR 0 2
38970: PPUSH
38971: LD_INT 3
38973: PPUSH
38974: LD_VAR 0 11
38978: PPUSH
38979: CALL_OW 1
38983: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
38984: LD_VAR 0 4
38988: PUSH
38989: LD_INT 6
38991: GREATER
38992: PUSH
38993: LD_VAR 0 6
38997: PUSH
38998: LD_INT 6
39000: LESS
39001: AND
39002: IFFALSE 39196
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
39004: LD_ADDR_VAR 0 9
39008: PUSH
39009: LD_VAR 0 4
39013: PUSH
39014: LD_VAR 0 8
39018: PUSH
39019: LD_VAR 0 7
39023: UNION
39024: PUSH
39025: LD_VAR 0 6
39029: UNION
39030: DIFF
39031: PPUSH
39032: LD_INT 2
39034: PPUSH
39035: CALL 102504 0 2
39039: ST_TO_ADDR
// p := [ ] ;
39040: LD_ADDR_VAR 0 11
39044: PUSH
39045: EMPTY
39046: ST_TO_ADDR
// if sort then
39047: LD_VAR 0 9
39051: IFFALSE 39167
// for i = 1 to 6 - eng do
39053: LD_ADDR_VAR 0 3
39057: PUSH
39058: DOUBLE
39059: LD_INT 1
39061: DEC
39062: ST_TO_ADDR
39063: LD_INT 6
39065: PUSH
39066: LD_VAR 0 6
39070: MINUS
39071: PUSH
39072: FOR_TO
39073: IFFALSE 39165
// begin if i = sort then
39075: LD_VAR 0 3
39079: PUSH
39080: LD_VAR 0 9
39084: EQUAL
39085: IFFALSE 39089
// break ;
39087: GO 39165
// if GetClass ( i ) = 2 then
39089: LD_VAR 0 3
39093: PPUSH
39094: CALL_OW 257
39098: PUSH
39099: LD_INT 2
39101: EQUAL
39102: IFFALSE 39106
// continue ;
39104: GO 39072
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39106: LD_ADDR_VAR 0 11
39110: PUSH
39111: LD_VAR 0 11
39115: PPUSH
39116: LD_VAR 0 11
39120: PUSH
39121: LD_INT 1
39123: PLUS
39124: PPUSH
39125: LD_VAR 0 9
39129: PUSH
39130: LD_VAR 0 3
39134: ARRAY
39135: PPUSH
39136: CALL_OW 2
39140: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39141: LD_ADDR_VAR 0 4
39145: PUSH
39146: LD_VAR 0 4
39150: PUSH
39151: LD_VAR 0 9
39155: PUSH
39156: LD_VAR 0 3
39160: ARRAY
39161: DIFF
39162: ST_TO_ADDR
// end ;
39163: GO 39072
39165: POP
39166: POP
// if p then
39167: LD_VAR 0 11
39171: IFFALSE 39196
// result := Replace ( result , 2 , p ) ;
39173: LD_ADDR_VAR 0 2
39177: PUSH
39178: LD_VAR 0 2
39182: PPUSH
39183: LD_INT 2
39185: PPUSH
39186: LD_VAR 0 11
39190: PPUSH
39191: CALL_OW 1
39195: ST_TO_ADDR
// end ; exit ;
39196: GO 40584
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
39198: LD_EXP 126
39202: PUSH
39203: LD_EXP 125
39207: PUSH
39208: LD_VAR 0 1
39212: ARRAY
39213: ARRAY
39214: NOT
39215: PUSH
39216: LD_EXP 99
39220: PUSH
39221: LD_VAR 0 1
39225: ARRAY
39226: PPUSH
39227: LD_INT 30
39229: PUSH
39230: LD_INT 3
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PPUSH
39237: CALL_OW 72
39241: AND
39242: PUSH
39243: LD_EXP 104
39247: PUSH
39248: LD_VAR 0 1
39252: ARRAY
39253: AND
39254: IFFALSE 39862
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
39256: LD_ADDR_EXP 141
39260: PUSH
39261: LD_EXP 141
39265: PPUSH
39266: LD_VAR 0 1
39270: PPUSH
39271: LD_INT 5
39273: PPUSH
39274: CALL_OW 1
39278: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39279: LD_ADDR_VAR 0 2
39283: PUSH
39284: LD_INT 0
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: LD_INT 0
39292: PUSH
39293: LD_INT 0
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: ST_TO_ADDR
// if sci > 1 then
39302: LD_VAR 0 8
39306: PUSH
39307: LD_INT 1
39309: GREATER
39310: IFFALSE 39338
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
39312: LD_ADDR_VAR 0 4
39316: PUSH
39317: LD_VAR 0 4
39321: PUSH
39322: LD_VAR 0 8
39326: PUSH
39327: LD_VAR 0 8
39331: PUSH
39332: LD_INT 1
39334: ARRAY
39335: DIFF
39336: DIFF
39337: ST_TO_ADDR
// if tmp and not sci then
39338: LD_VAR 0 4
39342: PUSH
39343: LD_VAR 0 8
39347: NOT
39348: AND
39349: IFFALSE 39418
// begin sort := SortBySkill ( tmp , 4 ) ;
39351: LD_ADDR_VAR 0 9
39355: PUSH
39356: LD_VAR 0 4
39360: PPUSH
39361: LD_INT 4
39363: PPUSH
39364: CALL 102504 0 2
39368: ST_TO_ADDR
// if sort then
39369: LD_VAR 0 9
39373: IFFALSE 39389
// p := sort [ 1 ] ;
39375: LD_ADDR_VAR 0 11
39379: PUSH
39380: LD_VAR 0 9
39384: PUSH
39385: LD_INT 1
39387: ARRAY
39388: ST_TO_ADDR
// if p then
39389: LD_VAR 0 11
39393: IFFALSE 39418
// result := Replace ( result , 4 , p ) ;
39395: LD_ADDR_VAR 0 2
39399: PUSH
39400: LD_VAR 0 2
39404: PPUSH
39405: LD_INT 4
39407: PPUSH
39408: LD_VAR 0 11
39412: PPUSH
39413: CALL_OW 1
39417: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
39418: LD_ADDR_VAR 0 4
39422: PUSH
39423: LD_VAR 0 4
39427: PUSH
39428: LD_VAR 0 7
39432: DIFF
39433: ST_TO_ADDR
// if tmp and mech < 6 then
39434: LD_VAR 0 4
39438: PUSH
39439: LD_VAR 0 7
39443: PUSH
39444: LD_INT 6
39446: LESS
39447: AND
39448: IFFALSE 39636
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
39450: LD_ADDR_VAR 0 9
39454: PUSH
39455: LD_VAR 0 4
39459: PUSH
39460: LD_VAR 0 8
39464: PUSH
39465: LD_VAR 0 7
39469: UNION
39470: DIFF
39471: PPUSH
39472: LD_INT 3
39474: PPUSH
39475: CALL 102504 0 2
39479: ST_TO_ADDR
// p := [ ] ;
39480: LD_ADDR_VAR 0 11
39484: PUSH
39485: EMPTY
39486: ST_TO_ADDR
// if sort then
39487: LD_VAR 0 9
39491: IFFALSE 39607
// for i = 1 to 6 - mech do
39493: LD_ADDR_VAR 0 3
39497: PUSH
39498: DOUBLE
39499: LD_INT 1
39501: DEC
39502: ST_TO_ADDR
39503: LD_INT 6
39505: PUSH
39506: LD_VAR 0 7
39510: MINUS
39511: PUSH
39512: FOR_TO
39513: IFFALSE 39605
// begin if i = sort then
39515: LD_VAR 0 3
39519: PUSH
39520: LD_VAR 0 9
39524: EQUAL
39525: IFFALSE 39529
// break ;
39527: GO 39605
// if GetClass ( i ) = 3 then
39529: LD_VAR 0 3
39533: PPUSH
39534: CALL_OW 257
39538: PUSH
39539: LD_INT 3
39541: EQUAL
39542: IFFALSE 39546
// continue ;
39544: GO 39512
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39546: LD_ADDR_VAR 0 11
39550: PUSH
39551: LD_VAR 0 11
39555: PPUSH
39556: LD_VAR 0 11
39560: PUSH
39561: LD_INT 1
39563: PLUS
39564: PPUSH
39565: LD_VAR 0 9
39569: PUSH
39570: LD_VAR 0 3
39574: ARRAY
39575: PPUSH
39576: CALL_OW 2
39580: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39581: LD_ADDR_VAR 0 4
39585: PUSH
39586: LD_VAR 0 4
39590: PUSH
39591: LD_VAR 0 9
39595: PUSH
39596: LD_VAR 0 3
39600: ARRAY
39601: DIFF
39602: ST_TO_ADDR
// end ;
39603: GO 39512
39605: POP
39606: POP
// if p then
39607: LD_VAR 0 11
39611: IFFALSE 39636
// result := Replace ( result , 3 , p ) ;
39613: LD_ADDR_VAR 0 2
39617: PUSH
39618: LD_VAR 0 2
39622: PPUSH
39623: LD_INT 3
39625: PPUSH
39626: LD_VAR 0 11
39630: PPUSH
39631: CALL_OW 1
39635: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
39636: LD_ADDR_VAR 0 4
39640: PUSH
39641: LD_VAR 0 4
39645: PUSH
39646: LD_VAR 0 6
39650: DIFF
39651: ST_TO_ADDR
// if tmp and eng < 6 then
39652: LD_VAR 0 4
39656: PUSH
39657: LD_VAR 0 6
39661: PUSH
39662: LD_INT 6
39664: LESS
39665: AND
39666: IFFALSE 39860
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
39668: LD_ADDR_VAR 0 9
39672: PUSH
39673: LD_VAR 0 4
39677: PUSH
39678: LD_VAR 0 8
39682: PUSH
39683: LD_VAR 0 7
39687: UNION
39688: PUSH
39689: LD_VAR 0 6
39693: UNION
39694: DIFF
39695: PPUSH
39696: LD_INT 2
39698: PPUSH
39699: CALL 102504 0 2
39703: ST_TO_ADDR
// p := [ ] ;
39704: LD_ADDR_VAR 0 11
39708: PUSH
39709: EMPTY
39710: ST_TO_ADDR
// if sort then
39711: LD_VAR 0 9
39715: IFFALSE 39831
// for i = 1 to 6 - eng do
39717: LD_ADDR_VAR 0 3
39721: PUSH
39722: DOUBLE
39723: LD_INT 1
39725: DEC
39726: ST_TO_ADDR
39727: LD_INT 6
39729: PUSH
39730: LD_VAR 0 6
39734: MINUS
39735: PUSH
39736: FOR_TO
39737: IFFALSE 39829
// begin if i = sort then
39739: LD_VAR 0 3
39743: PUSH
39744: LD_VAR 0 9
39748: EQUAL
39749: IFFALSE 39753
// break ;
39751: GO 39829
// if GetClass ( i ) = 2 then
39753: LD_VAR 0 3
39757: PPUSH
39758: CALL_OW 257
39762: PUSH
39763: LD_INT 2
39765: EQUAL
39766: IFFALSE 39770
// continue ;
39768: GO 39736
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39770: LD_ADDR_VAR 0 11
39774: PUSH
39775: LD_VAR 0 11
39779: PPUSH
39780: LD_VAR 0 11
39784: PUSH
39785: LD_INT 1
39787: PLUS
39788: PPUSH
39789: LD_VAR 0 9
39793: PUSH
39794: LD_VAR 0 3
39798: ARRAY
39799: PPUSH
39800: CALL_OW 2
39804: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39805: LD_ADDR_VAR 0 4
39809: PUSH
39810: LD_VAR 0 4
39814: PUSH
39815: LD_VAR 0 9
39819: PUSH
39820: LD_VAR 0 3
39824: ARRAY
39825: DIFF
39826: ST_TO_ADDR
// end ;
39827: GO 39736
39829: POP
39830: POP
// if p then
39831: LD_VAR 0 11
39835: IFFALSE 39860
// result := Replace ( result , 2 , p ) ;
39837: LD_ADDR_VAR 0 2
39841: PUSH
39842: LD_VAR 0 2
39846: PPUSH
39847: LD_INT 2
39849: PPUSH
39850: LD_VAR 0 11
39854: PPUSH
39855: CALL_OW 1
39859: ST_TO_ADDR
// end ; exit ;
39860: GO 40584
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
39862: LD_EXP 126
39866: PUSH
39867: LD_EXP 125
39871: PUSH
39872: LD_VAR 0 1
39876: ARRAY
39877: ARRAY
39878: NOT
39879: PUSH
39880: LD_EXP 99
39884: PUSH
39885: LD_VAR 0 1
39889: ARRAY
39890: PPUSH
39891: LD_INT 30
39893: PUSH
39894: LD_INT 3
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PPUSH
39901: CALL_OW 72
39905: AND
39906: PUSH
39907: LD_EXP 104
39911: PUSH
39912: LD_VAR 0 1
39916: ARRAY
39917: NOT
39918: AND
39919: IFFALSE 40584
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
39921: LD_ADDR_EXP 141
39925: PUSH
39926: LD_EXP 141
39930: PPUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 6
39938: PPUSH
39939: CALL_OW 1
39943: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39944: LD_ADDR_VAR 0 2
39948: PUSH
39949: LD_INT 0
39951: PUSH
39952: LD_INT 0
39954: PUSH
39955: LD_INT 0
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: ST_TO_ADDR
// if sci >= 1 then
39967: LD_VAR 0 8
39971: PUSH
39972: LD_INT 1
39974: GREATEREQUAL
39975: IFFALSE 39997
// tmp := tmp diff sci [ 1 ] ;
39977: LD_ADDR_VAR 0 4
39981: PUSH
39982: LD_VAR 0 4
39986: PUSH
39987: LD_VAR 0 8
39991: PUSH
39992: LD_INT 1
39994: ARRAY
39995: DIFF
39996: ST_TO_ADDR
// if tmp and not sci then
39997: LD_VAR 0 4
40001: PUSH
40002: LD_VAR 0 8
40006: NOT
40007: AND
40008: IFFALSE 40077
// begin sort := SortBySkill ( tmp , 4 ) ;
40010: LD_ADDR_VAR 0 9
40014: PUSH
40015: LD_VAR 0 4
40019: PPUSH
40020: LD_INT 4
40022: PPUSH
40023: CALL 102504 0 2
40027: ST_TO_ADDR
// if sort then
40028: LD_VAR 0 9
40032: IFFALSE 40048
// p := sort [ 1 ] ;
40034: LD_ADDR_VAR 0 11
40038: PUSH
40039: LD_VAR 0 9
40043: PUSH
40044: LD_INT 1
40046: ARRAY
40047: ST_TO_ADDR
// if p then
40048: LD_VAR 0 11
40052: IFFALSE 40077
// result := Replace ( result , 4 , p ) ;
40054: LD_ADDR_VAR 0 2
40058: PUSH
40059: LD_VAR 0 2
40063: PPUSH
40064: LD_INT 4
40066: PPUSH
40067: LD_VAR 0 11
40071: PPUSH
40072: CALL_OW 1
40076: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40077: LD_ADDR_VAR 0 4
40081: PUSH
40082: LD_VAR 0 4
40086: PUSH
40087: LD_VAR 0 7
40091: DIFF
40092: ST_TO_ADDR
// if tmp and mech < 6 then
40093: LD_VAR 0 4
40097: PUSH
40098: LD_VAR 0 7
40102: PUSH
40103: LD_INT 6
40105: LESS
40106: AND
40107: IFFALSE 40289
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
40109: LD_ADDR_VAR 0 9
40113: PUSH
40114: LD_VAR 0 4
40118: PUSH
40119: LD_VAR 0 7
40123: DIFF
40124: PPUSH
40125: LD_INT 3
40127: PPUSH
40128: CALL 102504 0 2
40132: ST_TO_ADDR
// p := [ ] ;
40133: LD_ADDR_VAR 0 11
40137: PUSH
40138: EMPTY
40139: ST_TO_ADDR
// if sort then
40140: LD_VAR 0 9
40144: IFFALSE 40260
// for i = 1 to 6 - mech do
40146: LD_ADDR_VAR 0 3
40150: PUSH
40151: DOUBLE
40152: LD_INT 1
40154: DEC
40155: ST_TO_ADDR
40156: LD_INT 6
40158: PUSH
40159: LD_VAR 0 7
40163: MINUS
40164: PUSH
40165: FOR_TO
40166: IFFALSE 40258
// begin if i = sort then
40168: LD_VAR 0 3
40172: PUSH
40173: LD_VAR 0 9
40177: EQUAL
40178: IFFALSE 40182
// break ;
40180: GO 40258
// if GetClass ( i ) = 3 then
40182: LD_VAR 0 3
40186: PPUSH
40187: CALL_OW 257
40191: PUSH
40192: LD_INT 3
40194: EQUAL
40195: IFFALSE 40199
// continue ;
40197: GO 40165
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40199: LD_ADDR_VAR 0 11
40203: PUSH
40204: LD_VAR 0 11
40208: PPUSH
40209: LD_VAR 0 11
40213: PUSH
40214: LD_INT 1
40216: PLUS
40217: PPUSH
40218: LD_VAR 0 9
40222: PUSH
40223: LD_VAR 0 3
40227: ARRAY
40228: PPUSH
40229: CALL_OW 2
40233: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40234: LD_ADDR_VAR 0 4
40238: PUSH
40239: LD_VAR 0 4
40243: PUSH
40244: LD_VAR 0 9
40248: PUSH
40249: LD_VAR 0 3
40253: ARRAY
40254: DIFF
40255: ST_TO_ADDR
// end ;
40256: GO 40165
40258: POP
40259: POP
// if p then
40260: LD_VAR 0 11
40264: IFFALSE 40289
// result := Replace ( result , 3 , p ) ;
40266: LD_ADDR_VAR 0 2
40270: PUSH
40271: LD_VAR 0 2
40275: PPUSH
40276: LD_INT 3
40278: PPUSH
40279: LD_VAR 0 11
40283: PPUSH
40284: CALL_OW 1
40288: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40289: LD_ADDR_VAR 0 4
40293: PUSH
40294: LD_VAR 0 4
40298: PUSH
40299: LD_VAR 0 6
40303: DIFF
40304: ST_TO_ADDR
// if tmp and eng < 4 then
40305: LD_VAR 0 4
40309: PUSH
40310: LD_VAR 0 6
40314: PUSH
40315: LD_INT 4
40317: LESS
40318: AND
40319: IFFALSE 40509
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
40321: LD_ADDR_VAR 0 9
40325: PUSH
40326: LD_VAR 0 4
40330: PUSH
40331: LD_VAR 0 7
40335: PUSH
40336: LD_VAR 0 6
40340: UNION
40341: DIFF
40342: PPUSH
40343: LD_INT 2
40345: PPUSH
40346: CALL 102504 0 2
40350: ST_TO_ADDR
// p := [ ] ;
40351: LD_ADDR_VAR 0 11
40355: PUSH
40356: EMPTY
40357: ST_TO_ADDR
// if sort then
40358: LD_VAR 0 9
40362: IFFALSE 40478
// for i = 1 to 4 - eng do
40364: LD_ADDR_VAR 0 3
40368: PUSH
40369: DOUBLE
40370: LD_INT 1
40372: DEC
40373: ST_TO_ADDR
40374: LD_INT 4
40376: PUSH
40377: LD_VAR 0 6
40381: MINUS
40382: PUSH
40383: FOR_TO
40384: IFFALSE 40476
// begin if i = sort then
40386: LD_VAR 0 3
40390: PUSH
40391: LD_VAR 0 9
40395: EQUAL
40396: IFFALSE 40400
// break ;
40398: GO 40476
// if GetClass ( i ) = 2 then
40400: LD_VAR 0 3
40404: PPUSH
40405: CALL_OW 257
40409: PUSH
40410: LD_INT 2
40412: EQUAL
40413: IFFALSE 40417
// continue ;
40415: GO 40383
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40417: LD_ADDR_VAR 0 11
40421: PUSH
40422: LD_VAR 0 11
40426: PPUSH
40427: LD_VAR 0 11
40431: PUSH
40432: LD_INT 1
40434: PLUS
40435: PPUSH
40436: LD_VAR 0 9
40440: PUSH
40441: LD_VAR 0 3
40445: ARRAY
40446: PPUSH
40447: CALL_OW 2
40451: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40452: LD_ADDR_VAR 0 4
40456: PUSH
40457: LD_VAR 0 4
40461: PUSH
40462: LD_VAR 0 9
40466: PUSH
40467: LD_VAR 0 3
40471: ARRAY
40472: DIFF
40473: ST_TO_ADDR
// end ;
40474: GO 40383
40476: POP
40477: POP
// if p then
40478: LD_VAR 0 11
40482: IFFALSE 40507
// result := Replace ( result , 2 , p ) ;
40484: LD_ADDR_VAR 0 2
40488: PUSH
40489: LD_VAR 0 2
40493: PPUSH
40494: LD_INT 2
40496: PPUSH
40497: LD_VAR 0 11
40501: PPUSH
40502: CALL_OW 1
40506: ST_TO_ADDR
// end else
40507: GO 40553
// for i = eng downto 5 do
40509: LD_ADDR_VAR 0 3
40513: PUSH
40514: DOUBLE
40515: LD_VAR 0 6
40519: INC
40520: ST_TO_ADDR
40521: LD_INT 5
40523: PUSH
40524: FOR_DOWNTO
40525: IFFALSE 40551
// tmp := tmp union eng [ i ] ;
40527: LD_ADDR_VAR 0 4
40531: PUSH
40532: LD_VAR 0 4
40536: PUSH
40537: LD_VAR 0 6
40541: PUSH
40542: LD_VAR 0 3
40546: ARRAY
40547: UNION
40548: ST_TO_ADDR
40549: GO 40524
40551: POP
40552: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
40553: LD_ADDR_VAR 0 2
40557: PUSH
40558: LD_VAR 0 2
40562: PPUSH
40563: LD_INT 1
40565: PPUSH
40566: LD_VAR 0 4
40570: PUSH
40571: LD_VAR 0 5
40575: DIFF
40576: PPUSH
40577: CALL_OW 1
40581: ST_TO_ADDR
// exit ;
40582: GO 40584
// end ; end ;
40584: LD_VAR 0 2
40588: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
40589: LD_INT 0
40591: PPUSH
40592: PPUSH
40593: PPUSH
// if not mc_bases then
40594: LD_EXP 99
40598: NOT
40599: IFFALSE 40603
// exit ;
40601: GO 40709
// for i = 1 to mc_bases do
40603: LD_ADDR_VAR 0 2
40607: PUSH
40608: DOUBLE
40609: LD_INT 1
40611: DEC
40612: ST_TO_ADDR
40613: LD_EXP 99
40617: PUSH
40618: FOR_TO
40619: IFFALSE 40700
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40621: LD_ADDR_VAR 0 3
40625: PUSH
40626: LD_EXP 99
40630: PUSH
40631: LD_VAR 0 2
40635: ARRAY
40636: PPUSH
40637: LD_INT 21
40639: PUSH
40640: LD_INT 3
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 3
40649: PUSH
40650: LD_INT 24
40652: PUSH
40653: LD_INT 1000
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PPUSH
40668: CALL_OW 72
40672: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
40673: LD_ADDR_EXP 100
40677: PUSH
40678: LD_EXP 100
40682: PPUSH
40683: LD_VAR 0 2
40687: PPUSH
40688: LD_VAR 0 3
40692: PPUSH
40693: CALL_OW 1
40697: ST_TO_ADDR
// end ;
40698: GO 40618
40700: POP
40701: POP
// RaiseSailEvent ( 101 ) ;
40702: LD_INT 101
40704: PPUSH
40705: CALL_OW 427
// end ;
40709: LD_VAR 0 1
40713: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
40714: LD_INT 0
40716: PPUSH
40717: PPUSH
40718: PPUSH
40719: PPUSH
40720: PPUSH
40721: PPUSH
40722: PPUSH
// if not mc_bases then
40723: LD_EXP 99
40727: NOT
40728: IFFALSE 40732
// exit ;
40730: GO 41305
// for i = 1 to mc_bases do
40732: LD_ADDR_VAR 0 2
40736: PUSH
40737: DOUBLE
40738: LD_INT 1
40740: DEC
40741: ST_TO_ADDR
40742: LD_EXP 99
40746: PUSH
40747: FOR_TO
40748: IFFALSE 41296
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
40750: LD_ADDR_VAR 0 5
40754: PUSH
40755: LD_EXP 99
40759: PUSH
40760: LD_VAR 0 2
40764: ARRAY
40765: PUSH
40766: LD_EXP 128
40770: PUSH
40771: LD_VAR 0 2
40775: ARRAY
40776: UNION
40777: PPUSH
40778: LD_INT 21
40780: PUSH
40781: LD_INT 1
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: LD_INT 1
40790: PUSH
40791: LD_INT 3
40793: PUSH
40794: LD_INT 54
40796: PUSH
40797: EMPTY
40798: LIST
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: PUSH
40807: LD_INT 24
40809: PUSH
40810: LD_INT 750
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: LIST
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PPUSH
40830: CALL_OW 72
40834: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
40835: LD_ADDR_VAR 0 6
40839: PUSH
40840: LD_EXP 99
40844: PUSH
40845: LD_VAR 0 2
40849: ARRAY
40850: PPUSH
40851: LD_INT 21
40853: PUSH
40854: LD_INT 1
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: LD_INT 1
40863: PUSH
40864: LD_INT 3
40866: PUSH
40867: LD_INT 54
40869: PUSH
40870: EMPTY
40871: LIST
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 3
40879: PUSH
40880: LD_INT 24
40882: PUSH
40883: LD_INT 250
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: LIST
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PPUSH
40903: CALL_OW 72
40907: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
40908: LD_ADDR_VAR 0 7
40912: PUSH
40913: LD_VAR 0 5
40917: PUSH
40918: LD_VAR 0 6
40922: DIFF
40923: ST_TO_ADDR
// if not need_heal_1 then
40924: LD_VAR 0 6
40928: NOT
40929: IFFALSE 40962
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
40931: LD_ADDR_EXP 102
40935: PUSH
40936: LD_EXP 102
40940: PPUSH
40941: LD_VAR 0 2
40945: PUSH
40946: LD_INT 1
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PPUSH
40953: EMPTY
40954: PPUSH
40955: CALL 68319 0 3
40959: ST_TO_ADDR
40960: GO 41032
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
40962: LD_ADDR_EXP 102
40966: PUSH
40967: LD_EXP 102
40971: PPUSH
40972: LD_VAR 0 2
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PPUSH
40984: LD_EXP 102
40988: PUSH
40989: LD_VAR 0 2
40993: ARRAY
40994: PUSH
40995: LD_INT 1
40997: ARRAY
40998: PPUSH
40999: LD_INT 3
41001: PUSH
41002: LD_INT 24
41004: PUSH
41005: LD_INT 1000
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PPUSH
41016: CALL_OW 72
41020: PUSH
41021: LD_VAR 0 6
41025: UNION
41026: PPUSH
41027: CALL 68319 0 3
41031: ST_TO_ADDR
// if not need_heal_2 then
41032: LD_VAR 0 7
41036: NOT
41037: IFFALSE 41070
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
41039: LD_ADDR_EXP 102
41043: PUSH
41044: LD_EXP 102
41048: PPUSH
41049: LD_VAR 0 2
41053: PUSH
41054: LD_INT 2
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PPUSH
41061: EMPTY
41062: PPUSH
41063: CALL 68319 0 3
41067: ST_TO_ADDR
41068: GO 41102
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
41070: LD_ADDR_EXP 102
41074: PUSH
41075: LD_EXP 102
41079: PPUSH
41080: LD_VAR 0 2
41084: PUSH
41085: LD_INT 2
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PPUSH
41092: LD_VAR 0 7
41096: PPUSH
41097: CALL 68319 0 3
41101: ST_TO_ADDR
// if need_heal_2 then
41102: LD_VAR 0 7
41106: IFFALSE 41278
// for j in need_heal_2 do
41108: LD_ADDR_VAR 0 3
41112: PUSH
41113: LD_VAR 0 7
41117: PUSH
41118: FOR_IN
41119: IFFALSE 41276
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
41121: LD_ADDR_VAR 0 5
41125: PUSH
41126: LD_EXP 99
41130: PUSH
41131: LD_VAR 0 2
41135: ARRAY
41136: PPUSH
41137: LD_INT 2
41139: PUSH
41140: LD_INT 30
41142: PUSH
41143: LD_INT 6
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 30
41152: PUSH
41153: LD_INT 7
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 30
41162: PUSH
41163: LD_INT 8
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 30
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 30
41182: PUSH
41183: LD_INT 1
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 25
41192: PUSH
41193: LD_INT 4
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: PPUSH
41209: CALL_OW 72
41213: ST_TO_ADDR
// if tmp then
41214: LD_VAR 0 5
41218: IFFALSE 41274
// begin k := NearestUnitToUnit ( tmp , j ) ;
41220: LD_ADDR_VAR 0 4
41224: PUSH
41225: LD_VAR 0 5
41229: PPUSH
41230: LD_VAR 0 3
41234: PPUSH
41235: CALL_OW 74
41239: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
41240: LD_VAR 0 3
41244: PPUSH
41245: LD_VAR 0 4
41249: PPUSH
41250: CALL_OW 296
41254: PUSH
41255: LD_INT 7
41257: GREATER
41258: IFFALSE 41274
// ComMoveUnit ( j , k ) ;
41260: LD_VAR 0 3
41264: PPUSH
41265: LD_VAR 0 4
41269: PPUSH
41270: CALL_OW 112
// end ; end ;
41274: GO 41118
41276: POP
41277: POP
// if not need_heal_1 and not need_heal_2 then
41278: LD_VAR 0 6
41282: NOT
41283: PUSH
41284: LD_VAR 0 7
41288: NOT
41289: AND
41290: IFFALSE 41294
// continue ;
41292: GO 40747
// end ;
41294: GO 40747
41296: POP
41297: POP
// RaiseSailEvent ( 102 ) ;
41298: LD_INT 102
41300: PPUSH
41301: CALL_OW 427
// end ;
41305: LD_VAR 0 1
41309: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
41310: LD_INT 0
41312: PPUSH
41313: PPUSH
41314: PPUSH
41315: PPUSH
41316: PPUSH
// if not mc_bases then
41317: LD_EXP 99
41321: NOT
41322: IFFALSE 41326
// exit ;
41324: GO 41711
// for i = 1 to mc_bases do
41326: LD_ADDR_VAR 0 2
41330: PUSH
41331: DOUBLE
41332: LD_INT 1
41334: DEC
41335: ST_TO_ADDR
41336: LD_EXP 99
41340: PUSH
41341: FOR_TO
41342: IFFALSE 41709
// begin if not mc_building_need_repair [ i ] then
41344: LD_EXP 100
41348: PUSH
41349: LD_VAR 0 2
41353: ARRAY
41354: NOT
41355: IFFALSE 41393
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41357: LD_ADDR_EXP 101
41361: PUSH
41362: LD_EXP 101
41366: PPUSH
41367: LD_VAR 0 2
41371: PPUSH
41372: EMPTY
41373: PPUSH
41374: CALL_OW 1
41378: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
41379: LD_VAR 0 2
41383: PPUSH
41384: LD_INT 101
41386: PPUSH
41387: CALL 36431 0 2
// continue ;
41391: GO 41341
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
41393: LD_ADDR_EXP 105
41397: PUSH
41398: LD_EXP 105
41402: PPUSH
41403: LD_VAR 0 2
41407: PPUSH
41408: EMPTY
41409: PPUSH
41410: CALL_OW 1
41414: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
41415: LD_VAR 0 2
41419: PPUSH
41420: LD_INT 103
41422: PPUSH
41423: CALL 36431 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
41427: LD_ADDR_VAR 0 5
41431: PUSH
41432: LD_EXP 99
41436: PUSH
41437: LD_VAR 0 2
41441: ARRAY
41442: PUSH
41443: LD_EXP 128
41447: PUSH
41448: LD_VAR 0 2
41452: ARRAY
41453: UNION
41454: PPUSH
41455: LD_INT 2
41457: PUSH
41458: LD_INT 25
41460: PUSH
41461: LD_INT 2
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 25
41470: PUSH
41471: LD_INT 16
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: LIST
41482: PUSH
41483: EMPTY
41484: LIST
41485: PPUSH
41486: CALL_OW 72
41490: ST_TO_ADDR
// if not tmp then
41491: LD_VAR 0 5
41495: NOT
41496: IFFALSE 41500
// continue ;
41498: GO 41341
// for j in tmp do
41500: LD_ADDR_VAR 0 3
41504: PUSH
41505: LD_VAR 0 5
41509: PUSH
41510: FOR_IN
41511: IFFALSE 41705
// begin if mc_need_heal [ i ] then
41513: LD_EXP 102
41517: PUSH
41518: LD_VAR 0 2
41522: ARRAY
41523: IFFALSE 41571
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
41525: LD_VAR 0 3
41529: PUSH
41530: LD_EXP 102
41534: PUSH
41535: LD_VAR 0 2
41539: ARRAY
41540: PUSH
41541: LD_INT 1
41543: ARRAY
41544: IN
41545: PUSH
41546: LD_VAR 0 3
41550: PUSH
41551: LD_EXP 102
41555: PUSH
41556: LD_VAR 0 2
41560: ARRAY
41561: PUSH
41562: LD_INT 2
41564: ARRAY
41565: IN
41566: OR
41567: IFFALSE 41571
// continue ;
41569: GO 41510
// if IsInUnit ( j ) then
41571: LD_VAR 0 3
41575: PPUSH
41576: CALL_OW 310
41580: IFFALSE 41591
// ComExitBuilding ( j ) ;
41582: LD_VAR 0 3
41586: PPUSH
41587: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
41591: LD_VAR 0 3
41595: PUSH
41596: LD_EXP 101
41600: PUSH
41601: LD_VAR 0 2
41605: ARRAY
41606: IN
41607: NOT
41608: IFFALSE 41666
// begin SetTag ( j , 101 ) ;
41610: LD_VAR 0 3
41614: PPUSH
41615: LD_INT 101
41617: PPUSH
41618: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
41622: LD_ADDR_EXP 101
41626: PUSH
41627: LD_EXP 101
41631: PPUSH
41632: LD_VAR 0 2
41636: PUSH
41637: LD_EXP 101
41641: PUSH
41642: LD_VAR 0 2
41646: ARRAY
41647: PUSH
41648: LD_INT 1
41650: PLUS
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PPUSH
41656: LD_VAR 0 3
41660: PPUSH
41661: CALL 68319 0 3
41665: ST_TO_ADDR
// end ; wait ( 1 ) ;
41666: LD_INT 1
41668: PPUSH
41669: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
41673: LD_VAR 0 3
41677: PPUSH
41678: LD_EXP 100
41682: PUSH
41683: LD_VAR 0 2
41687: ARRAY
41688: PPUSH
41689: LD_VAR 0 3
41693: PPUSH
41694: CALL_OW 74
41698: PPUSH
41699: CALL_OW 130
// end ;
41703: GO 41510
41705: POP
41706: POP
// end ;
41707: GO 41341
41709: POP
41710: POP
// end ;
41711: LD_VAR 0 1
41715: RET
// export function MC_Heal ; var i , j , tmp ; begin
41716: LD_INT 0
41718: PPUSH
41719: PPUSH
41720: PPUSH
41721: PPUSH
// if not mc_bases then
41722: LD_EXP 99
41726: NOT
41727: IFFALSE 41731
// exit ;
41729: GO 42133
// for i = 1 to mc_bases do
41731: LD_ADDR_VAR 0 2
41735: PUSH
41736: DOUBLE
41737: LD_INT 1
41739: DEC
41740: ST_TO_ADDR
41741: LD_EXP 99
41745: PUSH
41746: FOR_TO
41747: IFFALSE 42131
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
41749: LD_EXP 102
41753: PUSH
41754: LD_VAR 0 2
41758: ARRAY
41759: PUSH
41760: LD_INT 1
41762: ARRAY
41763: NOT
41764: PUSH
41765: LD_EXP 102
41769: PUSH
41770: LD_VAR 0 2
41774: ARRAY
41775: PUSH
41776: LD_INT 2
41778: ARRAY
41779: NOT
41780: AND
41781: IFFALSE 41819
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
41783: LD_ADDR_EXP 103
41787: PUSH
41788: LD_EXP 103
41792: PPUSH
41793: LD_VAR 0 2
41797: PPUSH
41798: EMPTY
41799: PPUSH
41800: CALL_OW 1
41804: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
41805: LD_VAR 0 2
41809: PPUSH
41810: LD_INT 102
41812: PPUSH
41813: CALL 36431 0 2
// continue ;
41817: GO 41746
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41819: LD_ADDR_VAR 0 4
41823: PUSH
41824: LD_EXP 99
41828: PUSH
41829: LD_VAR 0 2
41833: ARRAY
41834: PPUSH
41835: LD_INT 25
41837: PUSH
41838: LD_INT 4
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PPUSH
41845: CALL_OW 72
41849: ST_TO_ADDR
// if not tmp then
41850: LD_VAR 0 4
41854: NOT
41855: IFFALSE 41859
// continue ;
41857: GO 41746
// if mc_taming [ i ] then
41859: LD_EXP 130
41863: PUSH
41864: LD_VAR 0 2
41868: ARRAY
41869: IFFALSE 41893
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41871: LD_ADDR_EXP 130
41875: PUSH
41876: LD_EXP 130
41880: PPUSH
41881: LD_VAR 0 2
41885: PPUSH
41886: EMPTY
41887: PPUSH
41888: CALL_OW 1
41892: ST_TO_ADDR
// for j in tmp do
41893: LD_ADDR_VAR 0 3
41897: PUSH
41898: LD_VAR 0 4
41902: PUSH
41903: FOR_IN
41904: IFFALSE 42127
// begin if IsInUnit ( j ) then
41906: LD_VAR 0 3
41910: PPUSH
41911: CALL_OW 310
41915: IFFALSE 41926
// ComExitBuilding ( j ) ;
41917: LD_VAR 0 3
41921: PPUSH
41922: CALL_OW 122
// if not j in mc_healers [ i ] then
41926: LD_VAR 0 3
41930: PUSH
41931: LD_EXP 103
41935: PUSH
41936: LD_VAR 0 2
41940: ARRAY
41941: IN
41942: NOT
41943: IFFALSE 41989
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
41945: LD_ADDR_EXP 103
41949: PUSH
41950: LD_EXP 103
41954: PPUSH
41955: LD_VAR 0 2
41959: PUSH
41960: LD_EXP 103
41964: PUSH
41965: LD_VAR 0 2
41969: ARRAY
41970: PUSH
41971: LD_INT 1
41973: PLUS
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PPUSH
41979: LD_VAR 0 3
41983: PPUSH
41984: CALL 68319 0 3
41988: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
41989: LD_VAR 0 3
41993: PPUSH
41994: CALL_OW 110
41998: PUSH
41999: LD_INT 102
42001: NONEQUAL
42002: IFFALSE 42016
// SetTag ( j , 102 ) ;
42004: LD_VAR 0 3
42008: PPUSH
42009: LD_INT 102
42011: PPUSH
42012: CALL_OW 109
// Wait ( 3 ) ;
42016: LD_INT 3
42018: PPUSH
42019: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
42023: LD_EXP 102
42027: PUSH
42028: LD_VAR 0 2
42032: ARRAY
42033: PUSH
42034: LD_INT 1
42036: ARRAY
42037: IFFALSE 42069
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
42039: LD_VAR 0 3
42043: PPUSH
42044: LD_EXP 102
42048: PUSH
42049: LD_VAR 0 2
42053: ARRAY
42054: PUSH
42055: LD_INT 1
42057: ARRAY
42058: PUSH
42059: LD_INT 1
42061: ARRAY
42062: PPUSH
42063: CALL_OW 128
42067: GO 42125
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
42069: LD_VAR 0 3
42073: PPUSH
42074: CALL_OW 314
42078: NOT
42079: PUSH
42080: LD_EXP 102
42084: PUSH
42085: LD_VAR 0 2
42089: ARRAY
42090: PUSH
42091: LD_INT 2
42093: ARRAY
42094: AND
42095: IFFALSE 42125
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
42097: LD_VAR 0 3
42101: PPUSH
42102: LD_EXP 102
42106: PUSH
42107: LD_VAR 0 2
42111: ARRAY
42112: PUSH
42113: LD_INT 2
42115: ARRAY
42116: PUSH
42117: LD_INT 1
42119: ARRAY
42120: PPUSH
42121: CALL_OW 128
// end ;
42125: GO 41903
42127: POP
42128: POP
// end ;
42129: GO 41746
42131: POP
42132: POP
// end ;
42133: LD_VAR 0 1
42137: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
42138: LD_INT 0
42140: PPUSH
42141: PPUSH
42142: PPUSH
42143: PPUSH
42144: PPUSH
// if not mc_bases then
42145: LD_EXP 99
42149: NOT
42150: IFFALSE 42154
// exit ;
42152: GO 43297
// for i = 1 to mc_bases do
42154: LD_ADDR_VAR 0 2
42158: PUSH
42159: DOUBLE
42160: LD_INT 1
42162: DEC
42163: ST_TO_ADDR
42164: LD_EXP 99
42168: PUSH
42169: FOR_TO
42170: IFFALSE 43295
// begin if mc_scan [ i ] then
42172: LD_EXP 122
42176: PUSH
42177: LD_VAR 0 2
42181: ARRAY
42182: IFFALSE 42186
// continue ;
42184: GO 42169
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
42186: LD_EXP 104
42190: PUSH
42191: LD_VAR 0 2
42195: ARRAY
42196: NOT
42197: PUSH
42198: LD_EXP 106
42202: PUSH
42203: LD_VAR 0 2
42207: ARRAY
42208: NOT
42209: AND
42210: PUSH
42211: LD_EXP 105
42215: PUSH
42216: LD_VAR 0 2
42220: ARRAY
42221: AND
42222: IFFALSE 42260
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
42224: LD_ADDR_EXP 105
42228: PUSH
42229: LD_EXP 105
42233: PPUSH
42234: LD_VAR 0 2
42238: PPUSH
42239: EMPTY
42240: PPUSH
42241: CALL_OW 1
42245: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42246: LD_VAR 0 2
42250: PPUSH
42251: LD_INT 103
42253: PPUSH
42254: CALL 36431 0 2
// continue ;
42258: GO 42169
// end ; if mc_construct_list [ i ] then
42260: LD_EXP 106
42264: PUSH
42265: LD_VAR 0 2
42269: ARRAY
42270: IFFALSE 42490
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
42272: LD_ADDR_VAR 0 4
42276: PUSH
42277: LD_EXP 99
42281: PUSH
42282: LD_VAR 0 2
42286: ARRAY
42287: PPUSH
42288: LD_INT 25
42290: PUSH
42291: LD_INT 2
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PPUSH
42298: CALL_OW 72
42302: PUSH
42303: LD_EXP 101
42307: PUSH
42308: LD_VAR 0 2
42312: ARRAY
42313: DIFF
42314: ST_TO_ADDR
// if not tmp then
42315: LD_VAR 0 4
42319: NOT
42320: IFFALSE 42324
// continue ;
42322: GO 42169
// for j in tmp do
42324: LD_ADDR_VAR 0 3
42328: PUSH
42329: LD_VAR 0 4
42333: PUSH
42334: FOR_IN
42335: IFFALSE 42486
// begin if not mc_builders [ i ] then
42337: LD_EXP 105
42341: PUSH
42342: LD_VAR 0 2
42346: ARRAY
42347: NOT
42348: IFFALSE 42406
// begin SetTag ( j , 103 ) ;
42350: LD_VAR 0 3
42354: PPUSH
42355: LD_INT 103
42357: PPUSH
42358: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
42362: LD_ADDR_EXP 105
42366: PUSH
42367: LD_EXP 105
42371: PPUSH
42372: LD_VAR 0 2
42376: PUSH
42377: LD_EXP 105
42381: PUSH
42382: LD_VAR 0 2
42386: ARRAY
42387: PUSH
42388: LD_INT 1
42390: PLUS
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PPUSH
42396: LD_VAR 0 3
42400: PPUSH
42401: CALL 68319 0 3
42405: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
42406: LD_VAR 0 3
42410: PPUSH
42411: CALL_OW 310
42415: IFFALSE 42426
// ComExitBuilding ( j ) ;
42417: LD_VAR 0 3
42421: PPUSH
42422: CALL_OW 122
// wait ( 3 ) ;
42426: LD_INT 3
42428: PPUSH
42429: CALL_OW 67
// if not mc_construct_list [ i ] then
42433: LD_EXP 106
42437: PUSH
42438: LD_VAR 0 2
42442: ARRAY
42443: NOT
42444: IFFALSE 42448
// break ;
42446: GO 42486
// if not HasTask ( j ) then
42448: LD_VAR 0 3
42452: PPUSH
42453: CALL_OW 314
42457: NOT
42458: IFFALSE 42484
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
42460: LD_VAR 0 3
42464: PPUSH
42465: LD_EXP 106
42469: PUSH
42470: LD_VAR 0 2
42474: ARRAY
42475: PUSH
42476: LD_INT 1
42478: ARRAY
42479: PPUSH
42480: CALL 71170 0 2
// end ;
42484: GO 42334
42486: POP
42487: POP
// end else
42488: GO 43293
// if mc_build_list [ i ] then
42490: LD_EXP 104
42494: PUSH
42495: LD_VAR 0 2
42499: ARRAY
42500: IFFALSE 43293
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42502: LD_ADDR_VAR 0 5
42506: PUSH
42507: LD_EXP 99
42511: PUSH
42512: LD_VAR 0 2
42516: ARRAY
42517: PPUSH
42518: LD_INT 2
42520: PUSH
42521: LD_INT 30
42523: PUSH
42524: LD_INT 0
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 30
42533: PUSH
42534: LD_INT 1
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: LIST
42545: PPUSH
42546: CALL_OW 72
42550: ST_TO_ADDR
// if depot then
42551: LD_VAR 0 5
42555: IFFALSE 42573
// depot := depot [ 1 ] else
42557: LD_ADDR_VAR 0 5
42561: PUSH
42562: LD_VAR 0 5
42566: PUSH
42567: LD_INT 1
42569: ARRAY
42570: ST_TO_ADDR
42571: GO 42581
// depot := 0 ;
42573: LD_ADDR_VAR 0 5
42577: PUSH
42578: LD_INT 0
42580: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
42581: LD_EXP 104
42585: PUSH
42586: LD_VAR 0 2
42590: ARRAY
42591: PUSH
42592: LD_INT 1
42594: ARRAY
42595: PUSH
42596: LD_INT 1
42598: ARRAY
42599: PPUSH
42600: CALL 71000 0 1
42604: PUSH
42605: LD_EXP 99
42609: PUSH
42610: LD_VAR 0 2
42614: ARRAY
42615: PPUSH
42616: LD_INT 2
42618: PUSH
42619: LD_INT 30
42621: PUSH
42622: LD_INT 2
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 30
42631: PUSH
42632: LD_INT 3
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: LIST
42643: PPUSH
42644: CALL_OW 72
42648: NOT
42649: AND
42650: IFFALSE 42755
// begin for j = 1 to mc_build_list [ i ] do
42652: LD_ADDR_VAR 0 3
42656: PUSH
42657: DOUBLE
42658: LD_INT 1
42660: DEC
42661: ST_TO_ADDR
42662: LD_EXP 104
42666: PUSH
42667: LD_VAR 0 2
42671: ARRAY
42672: PUSH
42673: FOR_TO
42674: IFFALSE 42753
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
42676: LD_EXP 104
42680: PUSH
42681: LD_VAR 0 2
42685: ARRAY
42686: PUSH
42687: LD_VAR 0 3
42691: ARRAY
42692: PUSH
42693: LD_INT 1
42695: ARRAY
42696: PUSH
42697: LD_INT 2
42699: EQUAL
42700: IFFALSE 42751
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
42702: LD_ADDR_EXP 104
42706: PUSH
42707: LD_EXP 104
42711: PPUSH
42712: LD_VAR 0 2
42716: PPUSH
42717: LD_EXP 104
42721: PUSH
42722: LD_VAR 0 2
42726: ARRAY
42727: PPUSH
42728: LD_VAR 0 3
42732: PPUSH
42733: LD_INT 1
42735: PPUSH
42736: LD_INT 0
42738: PPUSH
42739: CALL 67737 0 4
42743: PPUSH
42744: CALL_OW 1
42748: ST_TO_ADDR
// break ;
42749: GO 42753
// end ;
42751: GO 42673
42753: POP
42754: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
42755: LD_EXP 104
42759: PUSH
42760: LD_VAR 0 2
42764: ARRAY
42765: PUSH
42766: LD_INT 1
42768: ARRAY
42769: PUSH
42770: LD_INT 1
42772: ARRAY
42773: PUSH
42774: LD_INT 0
42776: EQUAL
42777: PUSH
42778: LD_VAR 0 5
42782: PUSH
42783: LD_VAR 0 5
42787: PPUSH
42788: LD_EXP 104
42792: PUSH
42793: LD_VAR 0 2
42797: ARRAY
42798: PUSH
42799: LD_INT 1
42801: ARRAY
42802: PUSH
42803: LD_INT 1
42805: ARRAY
42806: PPUSH
42807: LD_EXP 104
42811: PUSH
42812: LD_VAR 0 2
42816: ARRAY
42817: PUSH
42818: LD_INT 1
42820: ARRAY
42821: PUSH
42822: LD_INT 2
42824: ARRAY
42825: PPUSH
42826: LD_EXP 104
42830: PUSH
42831: LD_VAR 0 2
42835: ARRAY
42836: PUSH
42837: LD_INT 1
42839: ARRAY
42840: PUSH
42841: LD_INT 3
42843: ARRAY
42844: PPUSH
42845: LD_EXP 104
42849: PUSH
42850: LD_VAR 0 2
42854: ARRAY
42855: PUSH
42856: LD_INT 1
42858: ARRAY
42859: PUSH
42860: LD_INT 4
42862: ARRAY
42863: PPUSH
42864: CALL 75716 0 5
42868: AND
42869: OR
42870: IFFALSE 43151
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
42872: LD_ADDR_VAR 0 4
42876: PUSH
42877: LD_EXP 99
42881: PUSH
42882: LD_VAR 0 2
42886: ARRAY
42887: PPUSH
42888: LD_INT 25
42890: PUSH
42891: LD_INT 2
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PPUSH
42898: CALL_OW 72
42902: PUSH
42903: LD_EXP 101
42907: PUSH
42908: LD_VAR 0 2
42912: ARRAY
42913: DIFF
42914: ST_TO_ADDR
// if not tmp then
42915: LD_VAR 0 4
42919: NOT
42920: IFFALSE 42924
// continue ;
42922: GO 42169
// for j in tmp do
42924: LD_ADDR_VAR 0 3
42928: PUSH
42929: LD_VAR 0 4
42933: PUSH
42934: FOR_IN
42935: IFFALSE 43147
// begin if not mc_builders [ i ] then
42937: LD_EXP 105
42941: PUSH
42942: LD_VAR 0 2
42946: ARRAY
42947: NOT
42948: IFFALSE 43006
// begin SetTag ( j , 103 ) ;
42950: LD_VAR 0 3
42954: PPUSH
42955: LD_INT 103
42957: PPUSH
42958: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
42962: LD_ADDR_EXP 105
42966: PUSH
42967: LD_EXP 105
42971: PPUSH
42972: LD_VAR 0 2
42976: PUSH
42977: LD_EXP 105
42981: PUSH
42982: LD_VAR 0 2
42986: ARRAY
42987: PUSH
42988: LD_INT 1
42990: PLUS
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PPUSH
42996: LD_VAR 0 3
43000: PPUSH
43001: CALL 68319 0 3
43005: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43006: LD_VAR 0 3
43010: PPUSH
43011: CALL_OW 310
43015: IFFALSE 43026
// ComExitBuilding ( j ) ;
43017: LD_VAR 0 3
43021: PPUSH
43022: CALL_OW 122
// wait ( 3 ) ;
43026: LD_INT 3
43028: PPUSH
43029: CALL_OW 67
// if not mc_build_list [ i ] then
43033: LD_EXP 104
43037: PUSH
43038: LD_VAR 0 2
43042: ARRAY
43043: NOT
43044: IFFALSE 43048
// break ;
43046: GO 43147
// if not HasTask ( j ) then
43048: LD_VAR 0 3
43052: PPUSH
43053: CALL_OW 314
43057: NOT
43058: IFFALSE 43145
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
43060: LD_VAR 0 3
43064: PPUSH
43065: LD_EXP 104
43069: PUSH
43070: LD_VAR 0 2
43074: ARRAY
43075: PUSH
43076: LD_INT 1
43078: ARRAY
43079: PUSH
43080: LD_INT 1
43082: ARRAY
43083: PPUSH
43084: LD_EXP 104
43088: PUSH
43089: LD_VAR 0 2
43093: ARRAY
43094: PUSH
43095: LD_INT 1
43097: ARRAY
43098: PUSH
43099: LD_INT 2
43101: ARRAY
43102: PPUSH
43103: LD_EXP 104
43107: PUSH
43108: LD_VAR 0 2
43112: ARRAY
43113: PUSH
43114: LD_INT 1
43116: ARRAY
43117: PUSH
43118: LD_INT 3
43120: ARRAY
43121: PPUSH
43122: LD_EXP 104
43126: PUSH
43127: LD_VAR 0 2
43131: ARRAY
43132: PUSH
43133: LD_INT 1
43135: ARRAY
43136: PUSH
43137: LD_INT 4
43139: ARRAY
43140: PPUSH
43141: CALL_OW 145
// end ;
43145: GO 42934
43147: POP
43148: POP
// end else
43149: GO 43293
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
43151: LD_EXP 99
43155: PUSH
43156: LD_VAR 0 2
43160: ARRAY
43161: PPUSH
43162: LD_EXP 104
43166: PUSH
43167: LD_VAR 0 2
43171: ARRAY
43172: PUSH
43173: LD_INT 1
43175: ARRAY
43176: PUSH
43177: LD_INT 1
43179: ARRAY
43180: PPUSH
43181: LD_EXP 104
43185: PUSH
43186: LD_VAR 0 2
43190: ARRAY
43191: PUSH
43192: LD_INT 1
43194: ARRAY
43195: PUSH
43196: LD_INT 2
43198: ARRAY
43199: PPUSH
43200: LD_EXP 104
43204: PUSH
43205: LD_VAR 0 2
43209: ARRAY
43210: PUSH
43211: LD_INT 1
43213: ARRAY
43214: PUSH
43215: LD_INT 3
43217: ARRAY
43218: PPUSH
43219: LD_EXP 104
43223: PUSH
43224: LD_VAR 0 2
43228: ARRAY
43229: PUSH
43230: LD_INT 1
43232: ARRAY
43233: PUSH
43234: LD_INT 4
43236: ARRAY
43237: PPUSH
43238: CALL 75070 0 5
43242: NOT
43243: IFFALSE 43293
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
43245: LD_ADDR_EXP 104
43249: PUSH
43250: LD_EXP 104
43254: PPUSH
43255: LD_VAR 0 2
43259: PPUSH
43260: LD_EXP 104
43264: PUSH
43265: LD_VAR 0 2
43269: ARRAY
43270: PPUSH
43271: LD_INT 1
43273: PPUSH
43274: LD_INT 1
43276: NEG
43277: PPUSH
43278: LD_INT 0
43280: PPUSH
43281: CALL 67737 0 4
43285: PPUSH
43286: CALL_OW 1
43290: ST_TO_ADDR
// continue ;
43291: GO 42169
// end ; end ; end ;
43293: GO 42169
43295: POP
43296: POP
// end ;
43297: LD_VAR 0 1
43301: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
43302: LD_INT 0
43304: PPUSH
43305: PPUSH
43306: PPUSH
43307: PPUSH
43308: PPUSH
43309: PPUSH
// if not mc_bases then
43310: LD_EXP 99
43314: NOT
43315: IFFALSE 43319
// exit ;
43317: GO 43746
// for i = 1 to mc_bases do
43319: LD_ADDR_VAR 0 2
43323: PUSH
43324: DOUBLE
43325: LD_INT 1
43327: DEC
43328: ST_TO_ADDR
43329: LD_EXP 99
43333: PUSH
43334: FOR_TO
43335: IFFALSE 43744
// begin tmp := mc_build_upgrade [ i ] ;
43337: LD_ADDR_VAR 0 4
43341: PUSH
43342: LD_EXP 131
43346: PUSH
43347: LD_VAR 0 2
43351: ARRAY
43352: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
43353: LD_ADDR_VAR 0 6
43357: PUSH
43358: LD_EXP 132
43362: PUSH
43363: LD_VAR 0 2
43367: ARRAY
43368: PPUSH
43369: LD_INT 2
43371: PUSH
43372: LD_INT 30
43374: PUSH
43375: LD_INT 6
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: PUSH
43382: LD_INT 30
43384: PUSH
43385: LD_INT 7
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: LIST
43396: PPUSH
43397: CALL_OW 72
43401: ST_TO_ADDR
// if not tmp and not lab then
43402: LD_VAR 0 4
43406: NOT
43407: PUSH
43408: LD_VAR 0 6
43412: NOT
43413: AND
43414: IFFALSE 43418
// continue ;
43416: GO 43334
// if tmp then
43418: LD_VAR 0 4
43422: IFFALSE 43542
// for j in tmp do
43424: LD_ADDR_VAR 0 3
43428: PUSH
43429: LD_VAR 0 4
43433: PUSH
43434: FOR_IN
43435: IFFALSE 43540
// begin if UpgradeCost ( j ) then
43437: LD_VAR 0 3
43441: PPUSH
43442: CALL 74730 0 1
43446: IFFALSE 43538
// begin ComUpgrade ( j ) ;
43448: LD_VAR 0 3
43452: PPUSH
43453: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
43457: LD_ADDR_EXP 131
43461: PUSH
43462: LD_EXP 131
43466: PPUSH
43467: LD_VAR 0 2
43471: PPUSH
43472: LD_EXP 131
43476: PUSH
43477: LD_VAR 0 2
43481: ARRAY
43482: PUSH
43483: LD_VAR 0 3
43487: DIFF
43488: PPUSH
43489: CALL_OW 1
43493: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
43494: LD_ADDR_EXP 106
43498: PUSH
43499: LD_EXP 106
43503: PPUSH
43504: LD_VAR 0 2
43508: PUSH
43509: LD_EXP 106
43513: PUSH
43514: LD_VAR 0 2
43518: ARRAY
43519: PUSH
43520: LD_INT 1
43522: PLUS
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PPUSH
43528: LD_VAR 0 3
43532: PPUSH
43533: CALL 68319 0 3
43537: ST_TO_ADDR
// end ; end ;
43538: GO 43434
43540: POP
43541: POP
// if not lab or not mc_lab_upgrade [ i ] then
43542: LD_VAR 0 6
43546: NOT
43547: PUSH
43548: LD_EXP 133
43552: PUSH
43553: LD_VAR 0 2
43557: ARRAY
43558: NOT
43559: OR
43560: IFFALSE 43564
// continue ;
43562: GO 43334
// for j in lab do
43564: LD_ADDR_VAR 0 3
43568: PUSH
43569: LD_VAR 0 6
43573: PUSH
43574: FOR_IN
43575: IFFALSE 43740
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
43577: LD_VAR 0 3
43581: PPUSH
43582: CALL_OW 266
43586: PUSH
43587: LD_INT 6
43589: PUSH
43590: LD_INT 7
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: IN
43597: PUSH
43598: LD_VAR 0 3
43602: PPUSH
43603: CALL_OW 461
43607: PUSH
43608: LD_INT 1
43610: NONEQUAL
43611: AND
43612: IFFALSE 43738
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
43614: LD_VAR 0 3
43618: PPUSH
43619: LD_EXP 133
43623: PUSH
43624: LD_VAR 0 2
43628: ARRAY
43629: PUSH
43630: LD_INT 1
43632: ARRAY
43633: PPUSH
43634: CALL 74935 0 2
43638: IFFALSE 43738
// begin ComCancel ( j ) ;
43640: LD_VAR 0 3
43644: PPUSH
43645: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
43649: LD_VAR 0 3
43653: PPUSH
43654: LD_EXP 133
43658: PUSH
43659: LD_VAR 0 2
43663: ARRAY
43664: PUSH
43665: LD_INT 1
43667: ARRAY
43668: PPUSH
43669: CALL_OW 207
// if not j in mc_construct_list [ i ] then
43673: LD_VAR 0 3
43677: PUSH
43678: LD_EXP 106
43682: PUSH
43683: LD_VAR 0 2
43687: ARRAY
43688: IN
43689: NOT
43690: IFFALSE 43736
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
43692: LD_ADDR_EXP 106
43696: PUSH
43697: LD_EXP 106
43701: PPUSH
43702: LD_VAR 0 2
43706: PUSH
43707: LD_EXP 106
43711: PUSH
43712: LD_VAR 0 2
43716: ARRAY
43717: PUSH
43718: LD_INT 1
43720: PLUS
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PPUSH
43726: LD_VAR 0 3
43730: PPUSH
43731: CALL 68319 0 3
43735: ST_TO_ADDR
// break ;
43736: GO 43740
// end ; end ; end ;
43738: GO 43574
43740: POP
43741: POP
// end ;
43742: GO 43334
43744: POP
43745: POP
// end ;
43746: LD_VAR 0 1
43750: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
43751: LD_INT 0
43753: PPUSH
43754: PPUSH
43755: PPUSH
43756: PPUSH
43757: PPUSH
43758: PPUSH
43759: PPUSH
43760: PPUSH
43761: PPUSH
// if not mc_bases then
43762: LD_EXP 99
43766: NOT
43767: IFFALSE 43771
// exit ;
43769: GO 44176
// for i = 1 to mc_bases do
43771: LD_ADDR_VAR 0 2
43775: PUSH
43776: DOUBLE
43777: LD_INT 1
43779: DEC
43780: ST_TO_ADDR
43781: LD_EXP 99
43785: PUSH
43786: FOR_TO
43787: IFFALSE 44174
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
43789: LD_EXP 107
43793: PUSH
43794: LD_VAR 0 2
43798: ARRAY
43799: NOT
43800: PUSH
43801: LD_EXP 99
43805: PUSH
43806: LD_VAR 0 2
43810: ARRAY
43811: PPUSH
43812: LD_INT 30
43814: PUSH
43815: LD_INT 3
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PPUSH
43822: CALL_OW 72
43826: NOT
43827: OR
43828: IFFALSE 43832
// continue ;
43830: GO 43786
// busy := false ;
43832: LD_ADDR_VAR 0 8
43836: PUSH
43837: LD_INT 0
43839: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
43840: LD_ADDR_VAR 0 4
43844: PUSH
43845: LD_EXP 99
43849: PUSH
43850: LD_VAR 0 2
43854: ARRAY
43855: PPUSH
43856: LD_INT 30
43858: PUSH
43859: LD_INT 3
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PPUSH
43866: CALL_OW 72
43870: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
43871: LD_ADDR_VAR 0 6
43875: PUSH
43876: LD_EXP 107
43880: PUSH
43881: LD_VAR 0 2
43885: ARRAY
43886: PPUSH
43887: LD_INT 2
43889: PUSH
43890: LD_INT 30
43892: PUSH
43893: LD_INT 32
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: PUSH
43900: LD_INT 30
43902: PUSH
43903: LD_INT 33
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: LIST
43914: PPUSH
43915: CALL_OW 72
43919: ST_TO_ADDR
// if not t then
43920: LD_VAR 0 6
43924: NOT
43925: IFFALSE 43929
// continue ;
43927: GO 43786
// for j in tmp do
43929: LD_ADDR_VAR 0 3
43933: PUSH
43934: LD_VAR 0 4
43938: PUSH
43939: FOR_IN
43940: IFFALSE 43970
// if not BuildingStatus ( j ) = bs_idle then
43942: LD_VAR 0 3
43946: PPUSH
43947: CALL_OW 461
43951: PUSH
43952: LD_INT 2
43954: EQUAL
43955: NOT
43956: IFFALSE 43968
// begin busy := true ;
43958: LD_ADDR_VAR 0 8
43962: PUSH
43963: LD_INT 1
43965: ST_TO_ADDR
// break ;
43966: GO 43970
// end ;
43968: GO 43939
43970: POP
43971: POP
// if busy then
43972: LD_VAR 0 8
43976: IFFALSE 43980
// continue ;
43978: GO 43786
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
43980: LD_ADDR_VAR 0 7
43984: PUSH
43985: LD_VAR 0 6
43989: PPUSH
43990: LD_INT 35
43992: PUSH
43993: LD_INT 0
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PPUSH
44000: CALL_OW 72
44004: ST_TO_ADDR
// if tw then
44005: LD_VAR 0 7
44009: IFFALSE 44086
// begin tw := tw [ 1 ] ;
44011: LD_ADDR_VAR 0 7
44015: PUSH
44016: LD_VAR 0 7
44020: PUSH
44021: LD_INT 1
44023: ARRAY
44024: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
44025: LD_ADDR_VAR 0 9
44029: PUSH
44030: LD_VAR 0 7
44034: PPUSH
44035: LD_EXP 124
44039: PUSH
44040: LD_VAR 0 2
44044: ARRAY
44045: PPUSH
44046: CALL 73289 0 2
44050: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
44051: LD_EXP 138
44055: PUSH
44056: LD_VAR 0 2
44060: ARRAY
44061: IFFALSE 44084
// if not weapon in mc_allowed_tower_weapons [ i ] then
44063: LD_VAR 0 9
44067: PUSH
44068: LD_EXP 138
44072: PUSH
44073: LD_VAR 0 2
44077: ARRAY
44078: IN
44079: NOT
44080: IFFALSE 44084
// continue ;
44082: GO 43786
// end else
44084: GO 44149
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
44086: LD_ADDR_VAR 0 5
44090: PUSH
44091: LD_EXP 107
44095: PUSH
44096: LD_VAR 0 2
44100: ARRAY
44101: PPUSH
44102: LD_VAR 0 4
44106: PPUSH
44107: CALL 103428 0 2
44111: ST_TO_ADDR
// if not tmp2 then
44112: LD_VAR 0 5
44116: NOT
44117: IFFALSE 44121
// continue ;
44119: GO 43786
// tw := tmp2 [ 1 ] ;
44121: LD_ADDR_VAR 0 7
44125: PUSH
44126: LD_VAR 0 5
44130: PUSH
44131: LD_INT 1
44133: ARRAY
44134: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
44135: LD_ADDR_VAR 0 9
44139: PUSH
44140: LD_VAR 0 5
44144: PUSH
44145: LD_INT 2
44147: ARRAY
44148: ST_TO_ADDR
// end ; if not weapon then
44149: LD_VAR 0 9
44153: NOT
44154: IFFALSE 44158
// continue ;
44156: GO 43786
// ComPlaceWeapon ( tw , weapon ) ;
44158: LD_VAR 0 7
44162: PPUSH
44163: LD_VAR 0 9
44167: PPUSH
44168: CALL_OW 148
// end ;
44172: GO 43786
44174: POP
44175: POP
// end ;
44176: LD_VAR 0 1
44180: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
44181: LD_INT 0
44183: PPUSH
44184: PPUSH
44185: PPUSH
44186: PPUSH
44187: PPUSH
44188: PPUSH
// if not mc_bases then
44189: LD_EXP 99
44193: NOT
44194: IFFALSE 44198
// exit ;
44196: GO 45210
// for i = 1 to mc_bases do
44198: LD_ADDR_VAR 0 2
44202: PUSH
44203: DOUBLE
44204: LD_INT 1
44206: DEC
44207: ST_TO_ADDR
44208: LD_EXP 99
44212: PUSH
44213: FOR_TO
44214: IFFALSE 45208
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
44216: LD_EXP 112
44220: PUSH
44221: LD_VAR 0 2
44225: ARRAY
44226: NOT
44227: PUSH
44228: LD_EXP 112
44232: PUSH
44233: LD_VAR 0 2
44237: ARRAY
44238: PUSH
44239: LD_EXP 113
44243: PUSH
44244: LD_VAR 0 2
44248: ARRAY
44249: EQUAL
44250: OR
44251: IFFALSE 44255
// continue ;
44253: GO 44213
// if mc_miners [ i ] then
44255: LD_EXP 113
44259: PUSH
44260: LD_VAR 0 2
44264: ARRAY
44265: IFFALSE 44895
// begin k := 1 ;
44267: LD_ADDR_VAR 0 4
44271: PUSH
44272: LD_INT 1
44274: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
44275: LD_ADDR_VAR 0 3
44279: PUSH
44280: DOUBLE
44281: LD_EXP 113
44285: PUSH
44286: LD_VAR 0 2
44290: ARRAY
44291: INC
44292: ST_TO_ADDR
44293: LD_INT 1
44295: PUSH
44296: FOR_DOWNTO
44297: IFFALSE 44893
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
44299: LD_EXP 113
44303: PUSH
44304: LD_VAR 0 2
44308: ARRAY
44309: PUSH
44310: LD_VAR 0 3
44314: ARRAY
44315: PPUSH
44316: CALL_OW 301
44320: PUSH
44321: LD_EXP 113
44325: PUSH
44326: LD_VAR 0 2
44330: ARRAY
44331: PUSH
44332: LD_VAR 0 3
44336: ARRAY
44337: PPUSH
44338: CALL_OW 257
44342: PUSH
44343: LD_INT 1
44345: NONEQUAL
44346: OR
44347: IFFALSE 44410
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
44349: LD_ADDR_VAR 0 5
44353: PUSH
44354: LD_EXP 113
44358: PUSH
44359: LD_VAR 0 2
44363: ARRAY
44364: PUSH
44365: LD_EXP 113
44369: PUSH
44370: LD_VAR 0 2
44374: ARRAY
44375: PUSH
44376: LD_VAR 0 3
44380: ARRAY
44381: DIFF
44382: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
44383: LD_ADDR_EXP 113
44387: PUSH
44388: LD_EXP 113
44392: PPUSH
44393: LD_VAR 0 2
44397: PPUSH
44398: LD_VAR 0 5
44402: PPUSH
44403: CALL_OW 1
44407: ST_TO_ADDR
// continue ;
44408: GO 44296
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
44410: LD_EXP 113
44414: PUSH
44415: LD_VAR 0 2
44419: ARRAY
44420: PUSH
44421: LD_VAR 0 3
44425: ARRAY
44426: PPUSH
44427: CALL 68255 0 1
44431: PUSH
44432: LD_EXP 113
44436: PUSH
44437: LD_VAR 0 2
44441: ARRAY
44442: PUSH
44443: LD_VAR 0 3
44447: ARRAY
44448: PPUSH
44449: CALL_OW 255
44453: PPUSH
44454: LD_EXP 112
44458: PUSH
44459: LD_VAR 0 2
44463: ARRAY
44464: PUSH
44465: LD_VAR 0 4
44469: ARRAY
44470: PUSH
44471: LD_INT 1
44473: ARRAY
44474: PPUSH
44475: LD_EXP 112
44479: PUSH
44480: LD_VAR 0 2
44484: ARRAY
44485: PUSH
44486: LD_VAR 0 4
44490: ARRAY
44491: PUSH
44492: LD_INT 2
44494: ARRAY
44495: PPUSH
44496: LD_INT 15
44498: PPUSH
44499: CALL 69215 0 4
44503: PUSH
44504: LD_INT 4
44506: ARRAY
44507: PUSH
44508: LD_EXP 113
44512: PUSH
44513: LD_VAR 0 2
44517: ARRAY
44518: PUSH
44519: LD_VAR 0 3
44523: ARRAY
44524: PPUSH
44525: LD_INT 10
44527: PPUSH
44528: CALL 70912 0 2
44532: PUSH
44533: LD_INT 4
44535: ARRAY
44536: OR
44537: AND
44538: IFFALSE 44561
// ComStop ( mc_miners [ i ] [ j ] ) ;
44540: LD_EXP 113
44544: PUSH
44545: LD_VAR 0 2
44549: ARRAY
44550: PUSH
44551: LD_VAR 0 3
44555: ARRAY
44556: PPUSH
44557: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
44561: LD_EXP 113
44565: PUSH
44566: LD_VAR 0 2
44570: ARRAY
44571: PUSH
44572: LD_VAR 0 3
44576: ARRAY
44577: PPUSH
44578: CALL_OW 257
44582: PUSH
44583: LD_INT 1
44585: EQUAL
44586: PUSH
44587: LD_EXP 113
44591: PUSH
44592: LD_VAR 0 2
44596: ARRAY
44597: PUSH
44598: LD_VAR 0 3
44602: ARRAY
44603: PPUSH
44604: CALL_OW 459
44608: NOT
44609: AND
44610: PUSH
44611: LD_EXP 113
44615: PUSH
44616: LD_VAR 0 2
44620: ARRAY
44621: PUSH
44622: LD_VAR 0 3
44626: ARRAY
44627: PPUSH
44628: CALL_OW 255
44632: PPUSH
44633: LD_EXP 112
44637: PUSH
44638: LD_VAR 0 2
44642: ARRAY
44643: PUSH
44644: LD_VAR 0 4
44648: ARRAY
44649: PUSH
44650: LD_INT 1
44652: ARRAY
44653: PPUSH
44654: LD_EXP 112
44658: PUSH
44659: LD_VAR 0 2
44663: ARRAY
44664: PUSH
44665: LD_VAR 0 4
44669: ARRAY
44670: PUSH
44671: LD_INT 2
44673: ARRAY
44674: PPUSH
44675: LD_INT 15
44677: PPUSH
44678: CALL 69215 0 4
44682: PUSH
44683: LD_INT 4
44685: ARRAY
44686: PUSH
44687: LD_INT 0
44689: EQUAL
44690: AND
44691: PUSH
44692: LD_EXP 113
44696: PUSH
44697: LD_VAR 0 2
44701: ARRAY
44702: PUSH
44703: LD_VAR 0 3
44707: ARRAY
44708: PPUSH
44709: CALL_OW 314
44713: NOT
44714: AND
44715: IFFALSE 44891
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
44717: LD_EXP 113
44721: PUSH
44722: LD_VAR 0 2
44726: ARRAY
44727: PUSH
44728: LD_VAR 0 3
44732: ARRAY
44733: PPUSH
44734: CALL_OW 310
44738: IFFALSE 44761
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
44740: LD_EXP 113
44744: PUSH
44745: LD_VAR 0 2
44749: ARRAY
44750: PUSH
44751: LD_VAR 0 3
44755: ARRAY
44756: PPUSH
44757: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
44761: LD_EXP 113
44765: PUSH
44766: LD_VAR 0 2
44770: ARRAY
44771: PUSH
44772: LD_VAR 0 3
44776: ARRAY
44777: PPUSH
44778: CALL_OW 314
44782: NOT
44783: IFFALSE 44851
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
44785: LD_EXP 113
44789: PUSH
44790: LD_VAR 0 2
44794: ARRAY
44795: PUSH
44796: LD_VAR 0 3
44800: ARRAY
44801: PPUSH
44802: LD_EXP 112
44806: PUSH
44807: LD_VAR 0 2
44811: ARRAY
44812: PUSH
44813: LD_VAR 0 4
44817: ARRAY
44818: PUSH
44819: LD_INT 1
44821: ARRAY
44822: PPUSH
44823: LD_EXP 112
44827: PUSH
44828: LD_VAR 0 2
44832: ARRAY
44833: PUSH
44834: LD_VAR 0 4
44838: ARRAY
44839: PUSH
44840: LD_INT 2
44842: ARRAY
44843: PPUSH
44844: LD_INT 0
44846: PPUSH
44847: CALL_OW 193
// k := k + 1 ;
44851: LD_ADDR_VAR 0 4
44855: PUSH
44856: LD_VAR 0 4
44860: PUSH
44861: LD_INT 1
44863: PLUS
44864: ST_TO_ADDR
// if k > mc_mines [ i ] then
44865: LD_VAR 0 4
44869: PUSH
44870: LD_EXP 112
44874: PUSH
44875: LD_VAR 0 2
44879: ARRAY
44880: GREATER
44881: IFFALSE 44891
// k := 1 ;
44883: LD_ADDR_VAR 0 4
44887: PUSH
44888: LD_INT 1
44890: ST_TO_ADDR
// end ; end ;
44891: GO 44296
44893: POP
44894: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
44895: LD_ADDR_VAR 0 5
44899: PUSH
44900: LD_EXP 99
44904: PUSH
44905: LD_VAR 0 2
44909: ARRAY
44910: PPUSH
44911: LD_INT 2
44913: PUSH
44914: LD_INT 30
44916: PUSH
44917: LD_INT 4
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 30
44926: PUSH
44927: LD_INT 5
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 30
44936: PUSH
44937: LD_INT 32
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: PPUSH
44950: CALL_OW 72
44954: ST_TO_ADDR
// if not tmp then
44955: LD_VAR 0 5
44959: NOT
44960: IFFALSE 44964
// continue ;
44962: GO 44213
// list := [ ] ;
44964: LD_ADDR_VAR 0 6
44968: PUSH
44969: EMPTY
44970: ST_TO_ADDR
// for j in tmp do
44971: LD_ADDR_VAR 0 3
44975: PUSH
44976: LD_VAR 0 5
44980: PUSH
44981: FOR_IN
44982: IFFALSE 45051
// begin for k in UnitsInside ( j ) do
44984: LD_ADDR_VAR 0 4
44988: PUSH
44989: LD_VAR 0 3
44993: PPUSH
44994: CALL_OW 313
44998: PUSH
44999: FOR_IN
45000: IFFALSE 45047
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
45002: LD_VAR 0 4
45006: PPUSH
45007: CALL_OW 257
45011: PUSH
45012: LD_INT 1
45014: EQUAL
45015: PUSH
45016: LD_VAR 0 4
45020: PPUSH
45021: CALL_OW 459
45025: NOT
45026: AND
45027: IFFALSE 45045
// list := list ^ k ;
45029: LD_ADDR_VAR 0 6
45033: PUSH
45034: LD_VAR 0 6
45038: PUSH
45039: LD_VAR 0 4
45043: ADD
45044: ST_TO_ADDR
45045: GO 44999
45047: POP
45048: POP
// end ;
45049: GO 44981
45051: POP
45052: POP
// list := list diff mc_miners [ i ] ;
45053: LD_ADDR_VAR 0 6
45057: PUSH
45058: LD_VAR 0 6
45062: PUSH
45063: LD_EXP 113
45067: PUSH
45068: LD_VAR 0 2
45072: ARRAY
45073: DIFF
45074: ST_TO_ADDR
// if not list then
45075: LD_VAR 0 6
45079: NOT
45080: IFFALSE 45084
// continue ;
45082: GO 44213
// k := mc_mines [ i ] - mc_miners [ i ] ;
45084: LD_ADDR_VAR 0 4
45088: PUSH
45089: LD_EXP 112
45093: PUSH
45094: LD_VAR 0 2
45098: ARRAY
45099: PUSH
45100: LD_EXP 113
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: MINUS
45111: ST_TO_ADDR
// if k > list then
45112: LD_VAR 0 4
45116: PUSH
45117: LD_VAR 0 6
45121: GREATER
45122: IFFALSE 45134
// k := list ;
45124: LD_ADDR_VAR 0 4
45128: PUSH
45129: LD_VAR 0 6
45133: ST_TO_ADDR
// for j = 1 to k do
45134: LD_ADDR_VAR 0 3
45138: PUSH
45139: DOUBLE
45140: LD_INT 1
45142: DEC
45143: ST_TO_ADDR
45144: LD_VAR 0 4
45148: PUSH
45149: FOR_TO
45150: IFFALSE 45204
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
45152: LD_ADDR_EXP 113
45156: PUSH
45157: LD_EXP 113
45161: PPUSH
45162: LD_VAR 0 2
45166: PUSH
45167: LD_EXP 113
45171: PUSH
45172: LD_VAR 0 2
45176: ARRAY
45177: PUSH
45178: LD_INT 1
45180: PLUS
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PPUSH
45186: LD_VAR 0 6
45190: PUSH
45191: LD_VAR 0 3
45195: ARRAY
45196: PPUSH
45197: CALL 68319 0 3
45201: ST_TO_ADDR
45202: GO 45149
45204: POP
45205: POP
// end ;
45206: GO 44213
45208: POP
45209: POP
// end ;
45210: LD_VAR 0 1
45214: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
45215: LD_INT 0
45217: PPUSH
45218: PPUSH
45219: PPUSH
45220: PPUSH
45221: PPUSH
45222: PPUSH
45223: PPUSH
45224: PPUSH
45225: PPUSH
45226: PPUSH
// if not mc_bases then
45227: LD_EXP 99
45231: NOT
45232: IFFALSE 45236
// exit ;
45234: GO 46967
// for i = 1 to mc_bases do
45236: LD_ADDR_VAR 0 2
45240: PUSH
45241: DOUBLE
45242: LD_INT 1
45244: DEC
45245: ST_TO_ADDR
45246: LD_EXP 99
45250: PUSH
45251: FOR_TO
45252: IFFALSE 46965
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
45254: LD_EXP 99
45258: PUSH
45259: LD_VAR 0 2
45263: ARRAY
45264: NOT
45265: PUSH
45266: LD_EXP 106
45270: PUSH
45271: LD_VAR 0 2
45275: ARRAY
45276: OR
45277: IFFALSE 45281
// continue ;
45279: GO 45251
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
45281: LD_EXP 115
45285: PUSH
45286: LD_VAR 0 2
45290: ARRAY
45291: NOT
45292: PUSH
45293: LD_EXP 116
45297: PUSH
45298: LD_VAR 0 2
45302: ARRAY
45303: AND
45304: IFFALSE 45342
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
45306: LD_ADDR_EXP 116
45310: PUSH
45311: LD_EXP 116
45315: PPUSH
45316: LD_VAR 0 2
45320: PPUSH
45321: EMPTY
45322: PPUSH
45323: CALL_OW 1
45327: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
45328: LD_VAR 0 2
45332: PPUSH
45333: LD_INT 107
45335: PPUSH
45336: CALL 36431 0 2
// continue ;
45340: GO 45251
// end ; target := [ ] ;
45342: LD_ADDR_VAR 0 6
45346: PUSH
45347: EMPTY
45348: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
45349: LD_ADDR_VAR 0 3
45353: PUSH
45354: DOUBLE
45355: LD_EXP 115
45359: PUSH
45360: LD_VAR 0 2
45364: ARRAY
45365: INC
45366: ST_TO_ADDR
45367: LD_INT 1
45369: PUSH
45370: FOR_DOWNTO
45371: IFFALSE 45631
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
45373: LD_EXP 115
45377: PUSH
45378: LD_VAR 0 2
45382: ARRAY
45383: PUSH
45384: LD_VAR 0 3
45388: ARRAY
45389: PUSH
45390: LD_INT 2
45392: ARRAY
45393: PPUSH
45394: LD_EXP 115
45398: PUSH
45399: LD_VAR 0 2
45403: ARRAY
45404: PUSH
45405: LD_VAR 0 3
45409: ARRAY
45410: PUSH
45411: LD_INT 3
45413: ARRAY
45414: PPUSH
45415: CALL_OW 488
45419: PUSH
45420: LD_EXP 115
45424: PUSH
45425: LD_VAR 0 2
45429: ARRAY
45430: PUSH
45431: LD_VAR 0 3
45435: ARRAY
45436: PUSH
45437: LD_INT 2
45439: ARRAY
45440: PPUSH
45441: LD_EXP 115
45445: PUSH
45446: LD_VAR 0 2
45450: ARRAY
45451: PUSH
45452: LD_VAR 0 3
45456: ARRAY
45457: PUSH
45458: LD_INT 3
45460: ARRAY
45461: PPUSH
45462: CALL_OW 284
45466: PUSH
45467: LD_INT 0
45469: EQUAL
45470: AND
45471: IFFALSE 45526
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
45473: LD_ADDR_VAR 0 5
45477: PUSH
45478: LD_EXP 115
45482: PUSH
45483: LD_VAR 0 2
45487: ARRAY
45488: PPUSH
45489: LD_VAR 0 3
45493: PPUSH
45494: CALL_OW 3
45498: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
45499: LD_ADDR_EXP 115
45503: PUSH
45504: LD_EXP 115
45508: PPUSH
45509: LD_VAR 0 2
45513: PPUSH
45514: LD_VAR 0 5
45518: PPUSH
45519: CALL_OW 1
45523: ST_TO_ADDR
// continue ;
45524: GO 45370
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
45526: LD_EXP 99
45530: PUSH
45531: LD_VAR 0 2
45535: ARRAY
45536: PUSH
45537: LD_INT 1
45539: ARRAY
45540: PPUSH
45541: CALL_OW 255
45545: PPUSH
45546: LD_EXP 115
45550: PUSH
45551: LD_VAR 0 2
45555: ARRAY
45556: PUSH
45557: LD_VAR 0 3
45561: ARRAY
45562: PUSH
45563: LD_INT 2
45565: ARRAY
45566: PPUSH
45567: LD_EXP 115
45571: PUSH
45572: LD_VAR 0 2
45576: ARRAY
45577: PUSH
45578: LD_VAR 0 3
45582: ARRAY
45583: PUSH
45584: LD_INT 3
45586: ARRAY
45587: PPUSH
45588: LD_INT 30
45590: PPUSH
45591: CALL 69215 0 4
45595: PUSH
45596: LD_INT 4
45598: ARRAY
45599: PUSH
45600: LD_INT 0
45602: EQUAL
45603: IFFALSE 45629
// begin target := mc_crates [ i ] [ j ] ;
45605: LD_ADDR_VAR 0 6
45609: PUSH
45610: LD_EXP 115
45614: PUSH
45615: LD_VAR 0 2
45619: ARRAY
45620: PUSH
45621: LD_VAR 0 3
45625: ARRAY
45626: ST_TO_ADDR
// break ;
45627: GO 45631
// end ; end ;
45629: GO 45370
45631: POP
45632: POP
// if not target then
45633: LD_VAR 0 6
45637: NOT
45638: IFFALSE 45642
// continue ;
45640: GO 45251
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
45642: LD_ADDR_VAR 0 7
45646: PUSH
45647: LD_EXP 118
45651: PUSH
45652: LD_VAR 0 2
45656: ARRAY
45657: PPUSH
45658: LD_INT 2
45660: PUSH
45661: LD_INT 3
45663: PUSH
45664: LD_INT 58
45666: PUSH
45667: EMPTY
45668: LIST
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 61
45676: PUSH
45677: EMPTY
45678: LIST
45679: PUSH
45680: LD_INT 33
45682: PUSH
45683: LD_INT 5
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: LD_INT 33
45692: PUSH
45693: LD_INT 3
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 2
45709: PUSH
45710: LD_INT 34
45712: PUSH
45713: LD_INT 32
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 34
45722: PUSH
45723: LD_INT 51
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: PUSH
45730: LD_INT 34
45732: PUSH
45733: LD_INT 12
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: LIST
45744: LIST
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PPUSH
45750: CALL_OW 72
45754: ST_TO_ADDR
// if not cargo then
45755: LD_VAR 0 7
45759: NOT
45760: IFFALSE 46403
// begin if mc_crates_collector [ i ] < 5 then
45762: LD_EXP 116
45766: PUSH
45767: LD_VAR 0 2
45771: ARRAY
45772: PUSH
45773: LD_INT 5
45775: LESS
45776: IFFALSE 46142
// begin if mc_ape [ i ] then
45778: LD_EXP 128
45782: PUSH
45783: LD_VAR 0 2
45787: ARRAY
45788: IFFALSE 45835
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
45790: LD_ADDR_VAR 0 5
45794: PUSH
45795: LD_EXP 128
45799: PUSH
45800: LD_VAR 0 2
45804: ARRAY
45805: PPUSH
45806: LD_INT 25
45808: PUSH
45809: LD_INT 16
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 24
45818: PUSH
45819: LD_INT 750
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: PPUSH
45830: CALL_OW 72
45834: ST_TO_ADDR
// if not tmp then
45835: LD_VAR 0 5
45839: NOT
45840: IFFALSE 45887
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
45842: LD_ADDR_VAR 0 5
45846: PUSH
45847: LD_EXP 99
45851: PUSH
45852: LD_VAR 0 2
45856: ARRAY
45857: PPUSH
45858: LD_INT 25
45860: PUSH
45861: LD_INT 2
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 24
45870: PUSH
45871: LD_INT 750
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PPUSH
45882: CALL_OW 72
45886: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
45887: LD_EXP 128
45891: PUSH
45892: LD_VAR 0 2
45896: ARRAY
45897: PUSH
45898: LD_EXP 99
45902: PUSH
45903: LD_VAR 0 2
45907: ARRAY
45908: PPUSH
45909: LD_INT 25
45911: PUSH
45912: LD_INT 2
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 24
45921: PUSH
45922: LD_INT 750
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PPUSH
45933: CALL_OW 72
45937: AND
45938: PUSH
45939: LD_VAR 0 5
45943: PUSH
45944: LD_INT 5
45946: LESS
45947: AND
45948: IFFALSE 46030
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
45950: LD_ADDR_VAR 0 3
45954: PUSH
45955: LD_EXP 99
45959: PUSH
45960: LD_VAR 0 2
45964: ARRAY
45965: PPUSH
45966: LD_INT 25
45968: PUSH
45969: LD_INT 2
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 24
45978: PUSH
45979: LD_INT 750
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PPUSH
45990: CALL_OW 72
45994: PUSH
45995: FOR_IN
45996: IFFALSE 46028
// begin tmp := tmp union j ;
45998: LD_ADDR_VAR 0 5
46002: PUSH
46003: LD_VAR 0 5
46007: PUSH
46008: LD_VAR 0 3
46012: UNION
46013: ST_TO_ADDR
// if tmp >= 5 then
46014: LD_VAR 0 5
46018: PUSH
46019: LD_INT 5
46021: GREATEREQUAL
46022: IFFALSE 46026
// break ;
46024: GO 46028
// end ;
46026: GO 45995
46028: POP
46029: POP
// end ; if not tmp then
46030: LD_VAR 0 5
46034: NOT
46035: IFFALSE 46039
// continue ;
46037: GO 45251
// for j in tmp do
46039: LD_ADDR_VAR 0 3
46043: PUSH
46044: LD_VAR 0 5
46048: PUSH
46049: FOR_IN
46050: IFFALSE 46140
// if not GetTag ( j ) then
46052: LD_VAR 0 3
46056: PPUSH
46057: CALL_OW 110
46061: NOT
46062: IFFALSE 46138
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
46064: LD_ADDR_EXP 116
46068: PUSH
46069: LD_EXP 116
46073: PPUSH
46074: LD_VAR 0 2
46078: PUSH
46079: LD_EXP 116
46083: PUSH
46084: LD_VAR 0 2
46088: ARRAY
46089: PUSH
46090: LD_INT 1
46092: PLUS
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: PPUSH
46098: LD_VAR 0 3
46102: PPUSH
46103: CALL 68319 0 3
46107: ST_TO_ADDR
// SetTag ( j , 107 ) ;
46108: LD_VAR 0 3
46112: PPUSH
46113: LD_INT 107
46115: PPUSH
46116: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
46120: LD_EXP 116
46124: PUSH
46125: LD_VAR 0 2
46129: ARRAY
46130: PUSH
46131: LD_INT 5
46133: GREATEREQUAL
46134: IFFALSE 46138
// break ;
46136: GO 46140
// end ;
46138: GO 46049
46140: POP
46141: POP
// end ; if mc_crates_collector [ i ] and target then
46142: LD_EXP 116
46146: PUSH
46147: LD_VAR 0 2
46151: ARRAY
46152: PUSH
46153: LD_VAR 0 6
46157: AND
46158: IFFALSE 46401
// begin if mc_crates_collector [ i ] < target [ 1 ] then
46160: LD_EXP 116
46164: PUSH
46165: LD_VAR 0 2
46169: ARRAY
46170: PUSH
46171: LD_VAR 0 6
46175: PUSH
46176: LD_INT 1
46178: ARRAY
46179: LESS
46180: IFFALSE 46200
// tmp := mc_crates_collector [ i ] else
46182: LD_ADDR_VAR 0 5
46186: PUSH
46187: LD_EXP 116
46191: PUSH
46192: LD_VAR 0 2
46196: ARRAY
46197: ST_TO_ADDR
46198: GO 46214
// tmp := target [ 1 ] ;
46200: LD_ADDR_VAR 0 5
46204: PUSH
46205: LD_VAR 0 6
46209: PUSH
46210: LD_INT 1
46212: ARRAY
46213: ST_TO_ADDR
// k := 0 ;
46214: LD_ADDR_VAR 0 4
46218: PUSH
46219: LD_INT 0
46221: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
46222: LD_ADDR_VAR 0 3
46226: PUSH
46227: LD_EXP 116
46231: PUSH
46232: LD_VAR 0 2
46236: ARRAY
46237: PUSH
46238: FOR_IN
46239: IFFALSE 46399
// begin k := k + 1 ;
46241: LD_ADDR_VAR 0 4
46245: PUSH
46246: LD_VAR 0 4
46250: PUSH
46251: LD_INT 1
46253: PLUS
46254: ST_TO_ADDR
// if k > tmp then
46255: LD_VAR 0 4
46259: PUSH
46260: LD_VAR 0 5
46264: GREATER
46265: IFFALSE 46269
// break ;
46267: GO 46399
// if not GetClass ( j ) in [ 2 , 16 ] then
46269: LD_VAR 0 3
46273: PPUSH
46274: CALL_OW 257
46278: PUSH
46279: LD_INT 2
46281: PUSH
46282: LD_INT 16
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: IN
46289: NOT
46290: IFFALSE 46343
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
46292: LD_ADDR_EXP 116
46296: PUSH
46297: LD_EXP 116
46301: PPUSH
46302: LD_VAR 0 2
46306: PPUSH
46307: LD_EXP 116
46311: PUSH
46312: LD_VAR 0 2
46316: ARRAY
46317: PUSH
46318: LD_VAR 0 3
46322: DIFF
46323: PPUSH
46324: CALL_OW 1
46328: ST_TO_ADDR
// SetTag ( j , 0 ) ;
46329: LD_VAR 0 3
46333: PPUSH
46334: LD_INT 0
46336: PPUSH
46337: CALL_OW 109
// continue ;
46341: GO 46238
// end ; if IsInUnit ( j ) then
46343: LD_VAR 0 3
46347: PPUSH
46348: CALL_OW 310
46352: IFFALSE 46363
// ComExitBuilding ( j ) ;
46354: LD_VAR 0 3
46358: PPUSH
46359: CALL_OW 122
// wait ( 3 ) ;
46363: LD_INT 3
46365: PPUSH
46366: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
46370: LD_VAR 0 3
46374: PPUSH
46375: LD_VAR 0 6
46379: PUSH
46380: LD_INT 2
46382: ARRAY
46383: PPUSH
46384: LD_VAR 0 6
46388: PUSH
46389: LD_INT 3
46391: ARRAY
46392: PPUSH
46393: CALL_OW 117
// end ;
46397: GO 46238
46399: POP
46400: POP
// end ; end else
46401: GO 46963
// begin for j in cargo do
46403: LD_ADDR_VAR 0 3
46407: PUSH
46408: LD_VAR 0 7
46412: PUSH
46413: FOR_IN
46414: IFFALSE 46961
// begin if GetTag ( j ) <> 0 then
46416: LD_VAR 0 3
46420: PPUSH
46421: CALL_OW 110
46425: PUSH
46426: LD_INT 0
46428: NONEQUAL
46429: IFFALSE 46433
// continue ;
46431: GO 46413
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
46433: LD_VAR 0 3
46437: PPUSH
46438: CALL_OW 256
46442: PUSH
46443: LD_INT 1000
46445: LESS
46446: PUSH
46447: LD_VAR 0 3
46451: PPUSH
46452: LD_EXP 123
46456: PUSH
46457: LD_VAR 0 2
46461: ARRAY
46462: PPUSH
46463: CALL_OW 308
46467: NOT
46468: AND
46469: IFFALSE 46491
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46471: LD_VAR 0 3
46475: PPUSH
46476: LD_EXP 123
46480: PUSH
46481: LD_VAR 0 2
46485: ARRAY
46486: PPUSH
46487: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
46491: LD_VAR 0 3
46495: PPUSH
46496: CALL_OW 256
46500: PUSH
46501: LD_INT 1000
46503: LESS
46504: PUSH
46505: LD_VAR 0 3
46509: PPUSH
46510: LD_EXP 123
46514: PUSH
46515: LD_VAR 0 2
46519: ARRAY
46520: PPUSH
46521: CALL_OW 308
46525: AND
46526: IFFALSE 46530
// continue ;
46528: GO 46413
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
46530: LD_VAR 0 3
46534: PPUSH
46535: CALL_OW 262
46539: PUSH
46540: LD_INT 2
46542: EQUAL
46543: PUSH
46544: LD_VAR 0 3
46548: PPUSH
46549: CALL_OW 261
46553: PUSH
46554: LD_INT 15
46556: LESS
46557: AND
46558: IFFALSE 46562
// continue ;
46560: GO 46413
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
46562: LD_VAR 0 3
46566: PPUSH
46567: CALL_OW 262
46571: PUSH
46572: LD_INT 1
46574: EQUAL
46575: PUSH
46576: LD_VAR 0 3
46580: PPUSH
46581: CALL_OW 261
46585: PUSH
46586: LD_INT 10
46588: LESS
46589: AND
46590: IFFALSE 46900
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46592: LD_ADDR_VAR 0 8
46596: PUSH
46597: LD_EXP 99
46601: PUSH
46602: LD_VAR 0 2
46606: ARRAY
46607: PPUSH
46608: LD_INT 2
46610: PUSH
46611: LD_INT 30
46613: PUSH
46614: LD_INT 0
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: PUSH
46621: LD_INT 30
46623: PUSH
46624: LD_INT 1
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: LIST
46635: PPUSH
46636: CALL_OW 72
46640: ST_TO_ADDR
// if not depot then
46641: LD_VAR 0 8
46645: NOT
46646: IFFALSE 46650
// continue ;
46648: GO 46413
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
46650: LD_VAR 0 3
46654: PPUSH
46655: LD_VAR 0 8
46659: PPUSH
46660: LD_VAR 0 3
46664: PPUSH
46665: CALL_OW 74
46669: PPUSH
46670: CALL_OW 296
46674: PUSH
46675: LD_INT 6
46677: LESS
46678: IFFALSE 46694
// SetFuel ( j , 100 ) else
46680: LD_VAR 0 3
46684: PPUSH
46685: LD_INT 100
46687: PPUSH
46688: CALL_OW 240
46692: GO 46900
// if GetFuel ( j ) = 0 then
46694: LD_VAR 0 3
46698: PPUSH
46699: CALL_OW 261
46703: PUSH
46704: LD_INT 0
46706: EQUAL
46707: IFFALSE 46900
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
46709: LD_ADDR_EXP 118
46713: PUSH
46714: LD_EXP 118
46718: PPUSH
46719: LD_VAR 0 2
46723: PPUSH
46724: LD_EXP 118
46728: PUSH
46729: LD_VAR 0 2
46733: ARRAY
46734: PUSH
46735: LD_VAR 0 3
46739: DIFF
46740: PPUSH
46741: CALL_OW 1
46745: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
46746: LD_VAR 0 3
46750: PPUSH
46751: CALL_OW 263
46755: PUSH
46756: LD_INT 1
46758: EQUAL
46759: IFFALSE 46775
// ComExitVehicle ( IsInUnit ( j ) ) ;
46761: LD_VAR 0 3
46765: PPUSH
46766: CALL_OW 310
46770: PPUSH
46771: CALL_OW 121
// if GetControl ( j ) = control_remote then
46775: LD_VAR 0 3
46779: PPUSH
46780: CALL_OW 263
46784: PUSH
46785: LD_INT 2
46787: EQUAL
46788: IFFALSE 46799
// ComUnlink ( j ) ;
46790: LD_VAR 0 3
46794: PPUSH
46795: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
46799: LD_ADDR_VAR 0 9
46803: PUSH
46804: LD_VAR 0 2
46808: PPUSH
46809: LD_INT 3
46811: PPUSH
46812: CALL 56004 0 2
46816: ST_TO_ADDR
// if fac then
46817: LD_VAR 0 9
46821: IFFALSE 46898
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
46823: LD_ADDR_VAR 0 10
46827: PUSH
46828: LD_VAR 0 9
46832: PPUSH
46833: LD_VAR 0 3
46837: PPUSH
46838: CALL_OW 265
46842: PPUSH
46843: LD_VAR 0 3
46847: PPUSH
46848: CALL_OW 262
46852: PPUSH
46853: LD_VAR 0 3
46857: PPUSH
46858: CALL_OW 263
46862: PPUSH
46863: LD_VAR 0 3
46867: PPUSH
46868: CALL_OW 264
46872: PPUSH
46873: CALL 65919 0 5
46877: ST_TO_ADDR
// if components then
46878: LD_VAR 0 10
46882: IFFALSE 46898
// MC_InsertProduceList ( i , components ) ;
46884: LD_VAR 0 2
46888: PPUSH
46889: LD_VAR 0 10
46893: PPUSH
46894: CALL 55632 0 2
// end ; continue ;
46898: GO 46413
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
46900: LD_VAR 0 3
46904: PPUSH
46905: LD_INT 1
46907: PPUSH
46908: CALL_OW 289
46912: PUSH
46913: LD_INT 100
46915: LESS
46916: PUSH
46917: LD_VAR 0 3
46921: PPUSH
46922: CALL_OW 314
46926: NOT
46927: AND
46928: IFFALSE 46957
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
46930: LD_VAR 0 3
46934: PPUSH
46935: LD_VAR 0 6
46939: PUSH
46940: LD_INT 2
46942: ARRAY
46943: PPUSH
46944: LD_VAR 0 6
46948: PUSH
46949: LD_INT 3
46951: ARRAY
46952: PPUSH
46953: CALL_OW 117
// break ;
46957: GO 46961
// end ;
46959: GO 46413
46961: POP
46962: POP
// end ; end ;
46963: GO 45251
46965: POP
46966: POP
// end ;
46967: LD_VAR 0 1
46971: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
46972: LD_INT 0
46974: PPUSH
46975: PPUSH
46976: PPUSH
46977: PPUSH
// if not mc_bases then
46978: LD_EXP 99
46982: NOT
46983: IFFALSE 46987
// exit ;
46985: GO 47148
// for i = 1 to mc_bases do
46987: LD_ADDR_VAR 0 2
46991: PUSH
46992: DOUBLE
46993: LD_INT 1
46995: DEC
46996: ST_TO_ADDR
46997: LD_EXP 99
47001: PUSH
47002: FOR_TO
47003: IFFALSE 47146
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
47005: LD_ADDR_VAR 0 4
47009: PUSH
47010: LD_EXP 118
47014: PUSH
47015: LD_VAR 0 2
47019: ARRAY
47020: PUSH
47021: LD_EXP 121
47025: PUSH
47026: LD_VAR 0 2
47030: ARRAY
47031: UNION
47032: PPUSH
47033: LD_INT 33
47035: PUSH
47036: LD_INT 2
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PPUSH
47043: CALL_OW 72
47047: ST_TO_ADDR
// if tmp then
47048: LD_VAR 0 4
47052: IFFALSE 47144
// for j in tmp do
47054: LD_ADDR_VAR 0 3
47058: PUSH
47059: LD_VAR 0 4
47063: PUSH
47064: FOR_IN
47065: IFFALSE 47142
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
47067: LD_VAR 0 3
47071: PPUSH
47072: CALL_OW 312
47076: NOT
47077: PUSH
47078: LD_VAR 0 3
47082: PPUSH
47083: CALL_OW 256
47087: PUSH
47088: LD_INT 250
47090: GREATEREQUAL
47091: AND
47092: IFFALSE 47105
// Connect ( j ) else
47094: LD_VAR 0 3
47098: PPUSH
47099: CALL 71252 0 1
47103: GO 47140
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
47105: LD_VAR 0 3
47109: PPUSH
47110: CALL_OW 256
47114: PUSH
47115: LD_INT 250
47117: LESS
47118: PUSH
47119: LD_VAR 0 3
47123: PPUSH
47124: CALL_OW 312
47128: AND
47129: IFFALSE 47140
// ComUnlink ( j ) ;
47131: LD_VAR 0 3
47135: PPUSH
47136: CALL_OW 136
47140: GO 47064
47142: POP
47143: POP
// end ;
47144: GO 47002
47146: POP
47147: POP
// end ;
47148: LD_VAR 0 1
47152: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
47153: LD_INT 0
47155: PPUSH
47156: PPUSH
47157: PPUSH
47158: PPUSH
47159: PPUSH
// if not mc_bases then
47160: LD_EXP 99
47164: NOT
47165: IFFALSE 47169
// exit ;
47167: GO 47629
// for i = 1 to mc_bases do
47169: LD_ADDR_VAR 0 2
47173: PUSH
47174: DOUBLE
47175: LD_INT 1
47177: DEC
47178: ST_TO_ADDR
47179: LD_EXP 99
47183: PUSH
47184: FOR_TO
47185: IFFALSE 47627
// begin if not mc_produce [ i ] then
47187: LD_EXP 120
47191: PUSH
47192: LD_VAR 0 2
47196: ARRAY
47197: NOT
47198: IFFALSE 47202
// continue ;
47200: GO 47184
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47202: LD_ADDR_VAR 0 5
47206: PUSH
47207: LD_EXP 99
47211: PUSH
47212: LD_VAR 0 2
47216: ARRAY
47217: PPUSH
47218: LD_INT 30
47220: PUSH
47221: LD_INT 3
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PPUSH
47228: CALL_OW 72
47232: ST_TO_ADDR
// if not fac then
47233: LD_VAR 0 5
47237: NOT
47238: IFFALSE 47242
// continue ;
47240: GO 47184
// for j in fac do
47242: LD_ADDR_VAR 0 3
47246: PUSH
47247: LD_VAR 0 5
47251: PUSH
47252: FOR_IN
47253: IFFALSE 47623
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
47255: LD_VAR 0 3
47259: PPUSH
47260: CALL_OW 461
47264: PUSH
47265: LD_INT 2
47267: NONEQUAL
47268: PUSH
47269: LD_VAR 0 3
47273: PPUSH
47274: LD_INT 15
47276: PPUSH
47277: CALL 70912 0 2
47281: PUSH
47282: LD_INT 4
47284: ARRAY
47285: OR
47286: PUSH
47287: LD_VAR 0 3
47291: PPUSH
47292: CALL_OW 313
47296: PUSH
47297: LD_INT 0
47299: EQUAL
47300: OR
47301: IFFALSE 47305
// continue ;
47303: GO 47252
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
47305: LD_VAR 0 3
47309: PPUSH
47310: LD_EXP 120
47314: PUSH
47315: LD_VAR 0 2
47319: ARRAY
47320: PUSH
47321: LD_INT 1
47323: ARRAY
47324: PUSH
47325: LD_INT 1
47327: ARRAY
47328: PPUSH
47329: LD_EXP 120
47333: PUSH
47334: LD_VAR 0 2
47338: ARRAY
47339: PUSH
47340: LD_INT 1
47342: ARRAY
47343: PUSH
47344: LD_INT 2
47346: ARRAY
47347: PPUSH
47348: LD_EXP 120
47352: PUSH
47353: LD_VAR 0 2
47357: ARRAY
47358: PUSH
47359: LD_INT 1
47361: ARRAY
47362: PUSH
47363: LD_INT 3
47365: ARRAY
47366: PPUSH
47367: LD_EXP 120
47371: PUSH
47372: LD_VAR 0 2
47376: ARRAY
47377: PUSH
47378: LD_INT 1
47380: ARRAY
47381: PUSH
47382: LD_INT 4
47384: ARRAY
47385: PPUSH
47386: CALL_OW 448
47390: PUSH
47391: LD_VAR 0 3
47395: PPUSH
47396: LD_EXP 120
47400: PUSH
47401: LD_VAR 0 2
47405: ARRAY
47406: PUSH
47407: LD_INT 1
47409: ARRAY
47410: PUSH
47411: LD_INT 1
47413: ARRAY
47414: PUSH
47415: LD_EXP 120
47419: PUSH
47420: LD_VAR 0 2
47424: ARRAY
47425: PUSH
47426: LD_INT 1
47428: ARRAY
47429: PUSH
47430: LD_INT 2
47432: ARRAY
47433: PUSH
47434: LD_EXP 120
47438: PUSH
47439: LD_VAR 0 2
47443: ARRAY
47444: PUSH
47445: LD_INT 1
47447: ARRAY
47448: PUSH
47449: LD_INT 3
47451: ARRAY
47452: PUSH
47453: LD_EXP 120
47457: PUSH
47458: LD_VAR 0 2
47462: ARRAY
47463: PUSH
47464: LD_INT 1
47466: ARRAY
47467: PUSH
47468: LD_INT 4
47470: ARRAY
47471: PUSH
47472: EMPTY
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: PPUSH
47478: CALL 74583 0 2
47482: AND
47483: IFFALSE 47621
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
47485: LD_VAR 0 3
47489: PPUSH
47490: LD_EXP 120
47494: PUSH
47495: LD_VAR 0 2
47499: ARRAY
47500: PUSH
47501: LD_INT 1
47503: ARRAY
47504: PUSH
47505: LD_INT 1
47507: ARRAY
47508: PPUSH
47509: LD_EXP 120
47513: PUSH
47514: LD_VAR 0 2
47518: ARRAY
47519: PUSH
47520: LD_INT 1
47522: ARRAY
47523: PUSH
47524: LD_INT 2
47526: ARRAY
47527: PPUSH
47528: LD_EXP 120
47532: PUSH
47533: LD_VAR 0 2
47537: ARRAY
47538: PUSH
47539: LD_INT 1
47541: ARRAY
47542: PUSH
47543: LD_INT 3
47545: ARRAY
47546: PPUSH
47547: LD_EXP 120
47551: PUSH
47552: LD_VAR 0 2
47556: ARRAY
47557: PUSH
47558: LD_INT 1
47560: ARRAY
47561: PUSH
47562: LD_INT 4
47564: ARRAY
47565: PPUSH
47566: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
47570: LD_ADDR_VAR 0 4
47574: PUSH
47575: LD_EXP 120
47579: PUSH
47580: LD_VAR 0 2
47584: ARRAY
47585: PPUSH
47586: LD_INT 1
47588: PPUSH
47589: CALL_OW 3
47593: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47594: LD_ADDR_EXP 120
47598: PUSH
47599: LD_EXP 120
47603: PPUSH
47604: LD_VAR 0 2
47608: PPUSH
47609: LD_VAR 0 4
47613: PPUSH
47614: CALL_OW 1
47618: ST_TO_ADDR
// break ;
47619: GO 47623
// end ; end ;
47621: GO 47252
47623: POP
47624: POP
// end ;
47625: GO 47184
47627: POP
47628: POP
// end ;
47629: LD_VAR 0 1
47633: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
47634: LD_INT 0
47636: PPUSH
47637: PPUSH
47638: PPUSH
// if not mc_bases then
47639: LD_EXP 99
47643: NOT
47644: IFFALSE 47648
// exit ;
47646: GO 47737
// for i = 1 to mc_bases do
47648: LD_ADDR_VAR 0 2
47652: PUSH
47653: DOUBLE
47654: LD_INT 1
47656: DEC
47657: ST_TO_ADDR
47658: LD_EXP 99
47662: PUSH
47663: FOR_TO
47664: IFFALSE 47735
// begin if mc_attack [ i ] then
47666: LD_EXP 119
47670: PUSH
47671: LD_VAR 0 2
47675: ARRAY
47676: IFFALSE 47733
// begin tmp := mc_attack [ i ] [ 1 ] ;
47678: LD_ADDR_VAR 0 3
47682: PUSH
47683: LD_EXP 119
47687: PUSH
47688: LD_VAR 0 2
47692: ARRAY
47693: PUSH
47694: LD_INT 1
47696: ARRAY
47697: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
47698: LD_ADDR_EXP 119
47702: PUSH
47703: LD_EXP 119
47707: PPUSH
47708: LD_VAR 0 2
47712: PPUSH
47713: EMPTY
47714: PPUSH
47715: CALL_OW 1
47719: ST_TO_ADDR
// Attack ( tmp ) ;
47720: LD_VAR 0 3
47724: PPUSH
47725: CALL 96772 0 1
// exit ;
47729: POP
47730: POP
47731: GO 47737
// end ; end ;
47733: GO 47663
47735: POP
47736: POP
// end ;
47737: LD_VAR 0 1
47741: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
47742: LD_INT 0
47744: PPUSH
47745: PPUSH
47746: PPUSH
47747: PPUSH
47748: PPUSH
47749: PPUSH
47750: PPUSH
// if not mc_bases then
47751: LD_EXP 99
47755: NOT
47756: IFFALSE 47760
// exit ;
47758: GO 48364
// for i = 1 to mc_bases do
47760: LD_ADDR_VAR 0 2
47764: PUSH
47765: DOUBLE
47766: LD_INT 1
47768: DEC
47769: ST_TO_ADDR
47770: LD_EXP 99
47774: PUSH
47775: FOR_TO
47776: IFFALSE 48362
// begin if not mc_bases [ i ] then
47778: LD_EXP 99
47782: PUSH
47783: LD_VAR 0 2
47787: ARRAY
47788: NOT
47789: IFFALSE 47793
// continue ;
47791: GO 47775
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
47793: LD_ADDR_VAR 0 7
47797: PUSH
47798: LD_EXP 99
47802: PUSH
47803: LD_VAR 0 2
47807: ARRAY
47808: PUSH
47809: LD_INT 1
47811: ARRAY
47812: PPUSH
47813: CALL 65223 0 1
47817: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
47818: LD_ADDR_EXP 122
47822: PUSH
47823: LD_EXP 122
47827: PPUSH
47828: LD_VAR 0 2
47832: PPUSH
47833: LD_EXP 99
47837: PUSH
47838: LD_VAR 0 2
47842: ARRAY
47843: PUSH
47844: LD_INT 1
47846: ARRAY
47847: PPUSH
47848: CALL_OW 255
47852: PPUSH
47853: LD_EXP 124
47857: PUSH
47858: LD_VAR 0 2
47862: ARRAY
47863: PPUSH
47864: CALL 63183 0 2
47868: PPUSH
47869: CALL_OW 1
47873: ST_TO_ADDR
// if not mc_scan [ i ] then
47874: LD_EXP 122
47878: PUSH
47879: LD_VAR 0 2
47883: ARRAY
47884: NOT
47885: IFFALSE 48040
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47887: LD_ADDR_VAR 0 4
47891: PUSH
47892: LD_EXP 99
47896: PUSH
47897: LD_VAR 0 2
47901: ARRAY
47902: PPUSH
47903: LD_INT 2
47905: PUSH
47906: LD_INT 25
47908: PUSH
47909: LD_INT 5
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 25
47918: PUSH
47919: LD_INT 8
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 25
47928: PUSH
47929: LD_INT 9
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: PPUSH
47942: CALL_OW 72
47946: ST_TO_ADDR
// if not tmp then
47947: LD_VAR 0 4
47951: NOT
47952: IFFALSE 47956
// continue ;
47954: GO 47775
// for j in tmp do
47956: LD_ADDR_VAR 0 3
47960: PUSH
47961: LD_VAR 0 4
47965: PUSH
47966: FOR_IN
47967: IFFALSE 48038
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
47969: LD_VAR 0 3
47973: PPUSH
47974: CALL_OW 310
47978: PPUSH
47979: CALL_OW 266
47983: PUSH
47984: LD_INT 5
47986: EQUAL
47987: PUSH
47988: LD_VAR 0 3
47992: PPUSH
47993: CALL_OW 257
47997: PUSH
47998: LD_INT 1
48000: EQUAL
48001: AND
48002: PUSH
48003: LD_VAR 0 3
48007: PPUSH
48008: CALL_OW 459
48012: NOT
48013: AND
48014: PUSH
48015: LD_VAR 0 7
48019: AND
48020: IFFALSE 48036
// ComChangeProfession ( j , class ) ;
48022: LD_VAR 0 3
48026: PPUSH
48027: LD_VAR 0 7
48031: PPUSH
48032: CALL_OW 123
48036: GO 47966
48038: POP
48039: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
48040: LD_EXP 122
48044: PUSH
48045: LD_VAR 0 2
48049: ARRAY
48050: PUSH
48051: LD_EXP 121
48055: PUSH
48056: LD_VAR 0 2
48060: ARRAY
48061: NOT
48062: AND
48063: PUSH
48064: LD_EXP 99
48068: PUSH
48069: LD_VAR 0 2
48073: ARRAY
48074: PPUSH
48075: LD_INT 30
48077: PUSH
48078: LD_INT 32
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: PPUSH
48085: CALL_OW 72
48089: NOT
48090: AND
48091: PUSH
48092: LD_EXP 99
48096: PUSH
48097: LD_VAR 0 2
48101: ARRAY
48102: PPUSH
48103: LD_INT 2
48105: PUSH
48106: LD_INT 30
48108: PUSH
48109: LD_INT 4
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 30
48118: PUSH
48119: LD_INT 5
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: LIST
48130: PPUSH
48131: CALL_OW 72
48135: NOT
48136: AND
48137: IFFALSE 48269
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
48139: LD_ADDR_VAR 0 4
48143: PUSH
48144: LD_EXP 99
48148: PUSH
48149: LD_VAR 0 2
48153: ARRAY
48154: PPUSH
48155: LD_INT 2
48157: PUSH
48158: LD_INT 25
48160: PUSH
48161: LD_INT 1
48163: PUSH
48164: EMPTY
48165: LIST
48166: LIST
48167: PUSH
48168: LD_INT 25
48170: PUSH
48171: LD_INT 5
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 25
48180: PUSH
48181: LD_INT 8
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 25
48190: PUSH
48191: LD_INT 9
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: PPUSH
48205: CALL_OW 72
48209: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
48210: LD_ADDR_VAR 0 4
48214: PUSH
48215: LD_VAR 0 4
48219: PUSH
48220: LD_VAR 0 4
48224: PPUSH
48225: LD_INT 18
48227: PPUSH
48228: CALL 101516 0 2
48232: DIFF
48233: ST_TO_ADDR
// if tmp then
48234: LD_VAR 0 4
48238: IFFALSE 48269
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
48240: LD_VAR 0 2
48244: PPUSH
48245: LD_VAR 0 4
48249: PPUSH
48250: LD_EXP 124
48254: PUSH
48255: LD_VAR 0 2
48259: ARRAY
48260: PPUSH
48261: CALL 63218 0 3
// exit ;
48265: POP
48266: POP
48267: GO 48364
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
48269: LD_EXP 122
48273: PUSH
48274: LD_VAR 0 2
48278: ARRAY
48279: PUSH
48280: LD_EXP 121
48284: PUSH
48285: LD_VAR 0 2
48289: ARRAY
48290: AND
48291: IFFALSE 48360
// begin tmp := mc_defender [ i ] ;
48293: LD_ADDR_VAR 0 4
48297: PUSH
48298: LD_EXP 121
48302: PUSH
48303: LD_VAR 0 2
48307: ARRAY
48308: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
48309: LD_ADDR_EXP 121
48313: PUSH
48314: LD_EXP 121
48318: PPUSH
48319: LD_VAR 0 2
48323: PPUSH
48324: EMPTY
48325: PPUSH
48326: CALL_OW 1
48330: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
48331: LD_VAR 0 2
48335: PPUSH
48336: LD_VAR 0 4
48340: PPUSH
48341: LD_EXP 122
48345: PUSH
48346: LD_VAR 0 2
48350: ARRAY
48351: PPUSH
48352: CALL 63716 0 3
// exit ;
48356: POP
48357: POP
48358: GO 48364
// end ; end ;
48360: GO 47775
48362: POP
48363: POP
// end ;
48364: LD_VAR 0 1
48368: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
48369: LD_INT 0
48371: PPUSH
48372: PPUSH
48373: PPUSH
48374: PPUSH
48375: PPUSH
48376: PPUSH
48377: PPUSH
48378: PPUSH
48379: PPUSH
48380: PPUSH
48381: PPUSH
// if not mc_bases then
48382: LD_EXP 99
48386: NOT
48387: IFFALSE 48391
// exit ;
48389: GO 49478
// for i = 1 to mc_bases do
48391: LD_ADDR_VAR 0 2
48395: PUSH
48396: DOUBLE
48397: LD_INT 1
48399: DEC
48400: ST_TO_ADDR
48401: LD_EXP 99
48405: PUSH
48406: FOR_TO
48407: IFFALSE 49476
// begin tmp := mc_lab [ i ] ;
48409: LD_ADDR_VAR 0 6
48413: PUSH
48414: LD_EXP 132
48418: PUSH
48419: LD_VAR 0 2
48423: ARRAY
48424: ST_TO_ADDR
// if not tmp then
48425: LD_VAR 0 6
48429: NOT
48430: IFFALSE 48434
// continue ;
48432: GO 48406
// idle_lab := 0 ;
48434: LD_ADDR_VAR 0 11
48438: PUSH
48439: LD_INT 0
48441: ST_TO_ADDR
// for j in tmp do
48442: LD_ADDR_VAR 0 3
48446: PUSH
48447: LD_VAR 0 6
48451: PUSH
48452: FOR_IN
48453: IFFALSE 49472
// begin researching := false ;
48455: LD_ADDR_VAR 0 10
48459: PUSH
48460: LD_INT 0
48462: ST_TO_ADDR
// side := GetSide ( j ) ;
48463: LD_ADDR_VAR 0 4
48467: PUSH
48468: LD_VAR 0 3
48472: PPUSH
48473: CALL_OW 255
48477: ST_TO_ADDR
// if not mc_tech [ side ] then
48478: LD_EXP 126
48482: PUSH
48483: LD_VAR 0 4
48487: ARRAY
48488: NOT
48489: IFFALSE 48493
// continue ;
48491: GO 48452
// if BuildingStatus ( j ) = bs_idle then
48493: LD_VAR 0 3
48497: PPUSH
48498: CALL_OW 461
48502: PUSH
48503: LD_INT 2
48505: EQUAL
48506: IFFALSE 48694
// begin if idle_lab and UnitsInside ( j ) < 6 then
48508: LD_VAR 0 11
48512: PUSH
48513: LD_VAR 0 3
48517: PPUSH
48518: CALL_OW 313
48522: PUSH
48523: LD_INT 6
48525: LESS
48526: AND
48527: IFFALSE 48598
// begin tmp2 := UnitsInside ( idle_lab ) ;
48529: LD_ADDR_VAR 0 9
48533: PUSH
48534: LD_VAR 0 11
48538: PPUSH
48539: CALL_OW 313
48543: ST_TO_ADDR
// if tmp2 then
48544: LD_VAR 0 9
48548: IFFALSE 48590
// for x in tmp2 do
48550: LD_ADDR_VAR 0 7
48554: PUSH
48555: LD_VAR 0 9
48559: PUSH
48560: FOR_IN
48561: IFFALSE 48588
// begin ComExitBuilding ( x ) ;
48563: LD_VAR 0 7
48567: PPUSH
48568: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
48572: LD_VAR 0 7
48576: PPUSH
48577: LD_VAR 0 3
48581: PPUSH
48582: CALL_OW 180
// end ;
48586: GO 48560
48588: POP
48589: POP
// idle_lab := 0 ;
48590: LD_ADDR_VAR 0 11
48594: PUSH
48595: LD_INT 0
48597: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
48598: LD_ADDR_VAR 0 5
48602: PUSH
48603: LD_EXP 126
48607: PUSH
48608: LD_VAR 0 4
48612: ARRAY
48613: PUSH
48614: FOR_IN
48615: IFFALSE 48675
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
48617: LD_VAR 0 3
48621: PPUSH
48622: LD_VAR 0 5
48626: PPUSH
48627: CALL_OW 430
48631: PUSH
48632: LD_VAR 0 4
48636: PPUSH
48637: LD_VAR 0 5
48641: PPUSH
48642: CALL 62288 0 2
48646: AND
48647: IFFALSE 48673
// begin researching := true ;
48649: LD_ADDR_VAR 0 10
48653: PUSH
48654: LD_INT 1
48656: ST_TO_ADDR
// ComResearch ( j , t ) ;
48657: LD_VAR 0 3
48661: PPUSH
48662: LD_VAR 0 5
48666: PPUSH
48667: CALL_OW 124
// break ;
48671: GO 48675
// end ;
48673: GO 48614
48675: POP
48676: POP
// if not researching then
48677: LD_VAR 0 10
48681: NOT
48682: IFFALSE 48694
// idle_lab := j ;
48684: LD_ADDR_VAR 0 11
48688: PUSH
48689: LD_VAR 0 3
48693: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
48694: LD_VAR 0 3
48698: PPUSH
48699: CALL_OW 461
48703: PUSH
48704: LD_INT 10
48706: EQUAL
48707: IFFALSE 49295
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
48709: LD_EXP 128
48713: PUSH
48714: LD_VAR 0 2
48718: ARRAY
48719: NOT
48720: PUSH
48721: LD_EXP 129
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: NOT
48732: AND
48733: PUSH
48734: LD_EXP 126
48738: PUSH
48739: LD_VAR 0 4
48743: ARRAY
48744: PUSH
48745: LD_INT 1
48747: GREATER
48748: AND
48749: IFFALSE 48880
// begin ComCancel ( j ) ;
48751: LD_VAR 0 3
48755: PPUSH
48756: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
48760: LD_ADDR_EXP 126
48764: PUSH
48765: LD_EXP 126
48769: PPUSH
48770: LD_VAR 0 4
48774: PPUSH
48775: LD_EXP 126
48779: PUSH
48780: LD_VAR 0 4
48784: ARRAY
48785: PPUSH
48786: LD_EXP 126
48790: PUSH
48791: LD_VAR 0 4
48795: ARRAY
48796: PUSH
48797: LD_INT 1
48799: MINUS
48800: PPUSH
48801: LD_EXP 126
48805: PUSH
48806: LD_VAR 0 4
48810: ARRAY
48811: PPUSH
48812: LD_INT 0
48814: PPUSH
48815: CALL 67737 0 4
48819: PPUSH
48820: CALL_OW 1
48824: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
48825: LD_ADDR_EXP 126
48829: PUSH
48830: LD_EXP 126
48834: PPUSH
48835: LD_VAR 0 4
48839: PPUSH
48840: LD_EXP 126
48844: PUSH
48845: LD_VAR 0 4
48849: ARRAY
48850: PPUSH
48851: LD_EXP 126
48855: PUSH
48856: LD_VAR 0 4
48860: ARRAY
48861: PPUSH
48862: LD_INT 1
48864: PPUSH
48865: LD_INT 0
48867: PPUSH
48868: CALL 67737 0 4
48872: PPUSH
48873: CALL_OW 1
48877: ST_TO_ADDR
// continue ;
48878: GO 48452
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
48880: LD_EXP 128
48884: PUSH
48885: LD_VAR 0 2
48889: ARRAY
48890: PUSH
48891: LD_EXP 129
48895: PUSH
48896: LD_VAR 0 2
48900: ARRAY
48901: NOT
48902: AND
48903: IFFALSE 49030
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
48905: LD_ADDR_EXP 129
48909: PUSH
48910: LD_EXP 129
48914: PPUSH
48915: LD_VAR 0 2
48919: PUSH
48920: LD_EXP 129
48924: PUSH
48925: LD_VAR 0 2
48929: ARRAY
48930: PUSH
48931: LD_INT 1
48933: PLUS
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: PPUSH
48939: LD_EXP 128
48943: PUSH
48944: LD_VAR 0 2
48948: ARRAY
48949: PUSH
48950: LD_INT 1
48952: ARRAY
48953: PPUSH
48954: CALL 68319 0 3
48958: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
48959: LD_EXP 128
48963: PUSH
48964: LD_VAR 0 2
48968: ARRAY
48969: PUSH
48970: LD_INT 1
48972: ARRAY
48973: PPUSH
48974: LD_INT 112
48976: PPUSH
48977: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
48981: LD_ADDR_VAR 0 9
48985: PUSH
48986: LD_EXP 128
48990: PUSH
48991: LD_VAR 0 2
48995: ARRAY
48996: PPUSH
48997: LD_INT 1
48999: PPUSH
49000: CALL_OW 3
49004: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
49005: LD_ADDR_EXP 128
49009: PUSH
49010: LD_EXP 128
49014: PPUSH
49015: LD_VAR 0 2
49019: PPUSH
49020: LD_VAR 0 9
49024: PPUSH
49025: CALL_OW 1
49029: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
49030: LD_EXP 128
49034: PUSH
49035: LD_VAR 0 2
49039: ARRAY
49040: PUSH
49041: LD_EXP 129
49045: PUSH
49046: LD_VAR 0 2
49050: ARRAY
49051: AND
49052: PUSH
49053: LD_EXP 129
49057: PUSH
49058: LD_VAR 0 2
49062: ARRAY
49063: PUSH
49064: LD_INT 1
49066: ARRAY
49067: PPUSH
49068: CALL_OW 310
49072: NOT
49073: AND
49074: PUSH
49075: LD_VAR 0 3
49079: PPUSH
49080: CALL_OW 313
49084: PUSH
49085: LD_INT 6
49087: EQUAL
49088: AND
49089: IFFALSE 49145
// begin tmp2 := UnitsInside ( j ) ;
49091: LD_ADDR_VAR 0 9
49095: PUSH
49096: LD_VAR 0 3
49100: PPUSH
49101: CALL_OW 313
49105: ST_TO_ADDR
// if tmp2 = 6 then
49106: LD_VAR 0 9
49110: PUSH
49111: LD_INT 6
49113: EQUAL
49114: IFFALSE 49145
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
49116: LD_VAR 0 9
49120: PUSH
49121: LD_INT 1
49123: ARRAY
49124: PPUSH
49125: LD_INT 112
49127: PPUSH
49128: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
49132: LD_VAR 0 9
49136: PUSH
49137: LD_INT 1
49139: ARRAY
49140: PPUSH
49141: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
49145: LD_EXP 129
49149: PUSH
49150: LD_VAR 0 2
49154: ARRAY
49155: PUSH
49156: LD_EXP 129
49160: PUSH
49161: LD_VAR 0 2
49165: ARRAY
49166: PUSH
49167: LD_INT 1
49169: ARRAY
49170: PPUSH
49171: CALL_OW 314
49175: NOT
49176: AND
49177: PUSH
49178: LD_EXP 129
49182: PUSH
49183: LD_VAR 0 2
49187: ARRAY
49188: PUSH
49189: LD_INT 1
49191: ARRAY
49192: PPUSH
49193: CALL_OW 310
49197: NOT
49198: AND
49199: IFFALSE 49225
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
49201: LD_EXP 129
49205: PUSH
49206: LD_VAR 0 2
49210: ARRAY
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: PPUSH
49216: LD_VAR 0 3
49220: PPUSH
49221: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
49225: LD_EXP 129
49229: PUSH
49230: LD_VAR 0 2
49234: ARRAY
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PPUSH
49240: CALL_OW 310
49244: PUSH
49245: LD_EXP 129
49249: PUSH
49250: LD_VAR 0 2
49254: ARRAY
49255: PUSH
49256: LD_INT 1
49258: ARRAY
49259: PPUSH
49260: CALL_OW 310
49264: PPUSH
49265: CALL_OW 461
49269: PUSH
49270: LD_INT 3
49272: NONEQUAL
49273: AND
49274: IFFALSE 49295
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
49276: LD_EXP 129
49280: PUSH
49281: LD_VAR 0 2
49285: ARRAY
49286: PUSH
49287: LD_INT 1
49289: ARRAY
49290: PPUSH
49291: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
49295: LD_VAR 0 3
49299: PPUSH
49300: CALL_OW 461
49304: PUSH
49305: LD_INT 6
49307: EQUAL
49308: PUSH
49309: LD_VAR 0 6
49313: PUSH
49314: LD_INT 1
49316: GREATER
49317: AND
49318: IFFALSE 49470
// begin sci := [ ] ;
49320: LD_ADDR_VAR 0 8
49324: PUSH
49325: EMPTY
49326: ST_TO_ADDR
// for x in ( tmp diff j ) do
49327: LD_ADDR_VAR 0 7
49331: PUSH
49332: LD_VAR 0 6
49336: PUSH
49337: LD_VAR 0 3
49341: DIFF
49342: PUSH
49343: FOR_IN
49344: IFFALSE 49396
// begin if sci = 6 then
49346: LD_VAR 0 8
49350: PUSH
49351: LD_INT 6
49353: EQUAL
49354: IFFALSE 49358
// break ;
49356: GO 49396
// if BuildingStatus ( x ) = bs_idle then
49358: LD_VAR 0 7
49362: PPUSH
49363: CALL_OW 461
49367: PUSH
49368: LD_INT 2
49370: EQUAL
49371: IFFALSE 49394
// sci := sci ^ UnitsInside ( x ) ;
49373: LD_ADDR_VAR 0 8
49377: PUSH
49378: LD_VAR 0 8
49382: PUSH
49383: LD_VAR 0 7
49387: PPUSH
49388: CALL_OW 313
49392: ADD
49393: ST_TO_ADDR
// end ;
49394: GO 49343
49396: POP
49397: POP
// if not sci then
49398: LD_VAR 0 8
49402: NOT
49403: IFFALSE 49407
// continue ;
49405: GO 48452
// for x in sci do
49407: LD_ADDR_VAR 0 7
49411: PUSH
49412: LD_VAR 0 8
49416: PUSH
49417: FOR_IN
49418: IFFALSE 49468
// if IsInUnit ( x ) and not HasTask ( x ) then
49420: LD_VAR 0 7
49424: PPUSH
49425: CALL_OW 310
49429: PUSH
49430: LD_VAR 0 7
49434: PPUSH
49435: CALL_OW 314
49439: NOT
49440: AND
49441: IFFALSE 49466
// begin ComExitBuilding ( x ) ;
49443: LD_VAR 0 7
49447: PPUSH
49448: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49452: LD_VAR 0 7
49456: PPUSH
49457: LD_VAR 0 3
49461: PPUSH
49462: CALL_OW 180
// end ;
49466: GO 49417
49468: POP
49469: POP
// end ; end ;
49470: GO 48452
49472: POP
49473: POP
// end ;
49474: GO 48406
49476: POP
49477: POP
// end ;
49478: LD_VAR 0 1
49482: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
49483: LD_INT 0
49485: PPUSH
49486: PPUSH
// if not mc_bases then
49487: LD_EXP 99
49491: NOT
49492: IFFALSE 49496
// exit ;
49494: GO 49577
// for i = 1 to mc_bases do
49496: LD_ADDR_VAR 0 2
49500: PUSH
49501: DOUBLE
49502: LD_INT 1
49504: DEC
49505: ST_TO_ADDR
49506: LD_EXP 99
49510: PUSH
49511: FOR_TO
49512: IFFALSE 49575
// if mc_mines [ i ] and mc_miners [ i ] then
49514: LD_EXP 112
49518: PUSH
49519: LD_VAR 0 2
49523: ARRAY
49524: PUSH
49525: LD_EXP 113
49529: PUSH
49530: LD_VAR 0 2
49534: ARRAY
49535: AND
49536: IFFALSE 49573
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
49538: LD_EXP 113
49542: PUSH
49543: LD_VAR 0 2
49547: ARRAY
49548: PUSH
49549: LD_INT 1
49551: ARRAY
49552: PPUSH
49553: CALL_OW 255
49557: PPUSH
49558: LD_EXP 112
49562: PUSH
49563: LD_VAR 0 2
49567: ARRAY
49568: PPUSH
49569: CALL 65376 0 2
49573: GO 49511
49575: POP
49576: POP
// end ;
49577: LD_VAR 0 1
49581: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
49582: LD_INT 0
49584: PPUSH
49585: PPUSH
49586: PPUSH
49587: PPUSH
49588: PPUSH
49589: PPUSH
49590: PPUSH
49591: PPUSH
// if not mc_bases or not mc_parking then
49592: LD_EXP 99
49596: NOT
49597: PUSH
49598: LD_EXP 123
49602: NOT
49603: OR
49604: IFFALSE 49608
// exit ;
49606: GO 50320
// for i = 1 to mc_bases do
49608: LD_ADDR_VAR 0 2
49612: PUSH
49613: DOUBLE
49614: LD_INT 1
49616: DEC
49617: ST_TO_ADDR
49618: LD_EXP 99
49622: PUSH
49623: FOR_TO
49624: IFFALSE 50318
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
49626: LD_EXP 99
49630: PUSH
49631: LD_VAR 0 2
49635: ARRAY
49636: NOT
49637: PUSH
49638: LD_EXP 123
49642: PUSH
49643: LD_VAR 0 2
49647: ARRAY
49648: NOT
49649: OR
49650: IFFALSE 49654
// continue ;
49652: GO 49623
// if mc_scan [ i ] then
49654: LD_EXP 122
49658: PUSH
49659: LD_VAR 0 2
49663: ARRAY
49664: IFFALSE 49690
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49666: LD_ADDR_EXP 111
49670: PUSH
49671: LD_EXP 111
49675: PPUSH
49676: LD_VAR 0 2
49680: PPUSH
49681: EMPTY
49682: PPUSH
49683: CALL_OW 1
49687: ST_TO_ADDR
// continue ;
49688: GO 49623
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
49690: LD_ADDR_VAR 0 5
49694: PUSH
49695: LD_EXP 99
49699: PUSH
49700: LD_VAR 0 2
49704: ARRAY
49705: PUSH
49706: LD_INT 1
49708: ARRAY
49709: PPUSH
49710: CALL_OW 255
49714: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49715: LD_ADDR_VAR 0 6
49719: PUSH
49720: LD_EXP 99
49724: PUSH
49725: LD_VAR 0 2
49729: ARRAY
49730: PPUSH
49731: LD_INT 30
49733: PUSH
49734: LD_INT 3
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PPUSH
49741: CALL_OW 72
49745: ST_TO_ADDR
// if not fac then
49746: LD_VAR 0 6
49750: NOT
49751: IFFALSE 49802
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49753: LD_ADDR_VAR 0 6
49757: PUSH
49758: LD_EXP 99
49762: PUSH
49763: LD_VAR 0 2
49767: ARRAY
49768: PPUSH
49769: LD_INT 2
49771: PUSH
49772: LD_INT 30
49774: PUSH
49775: LD_INT 0
49777: PUSH
49778: EMPTY
49779: LIST
49780: LIST
49781: PUSH
49782: LD_INT 30
49784: PUSH
49785: LD_INT 1
49787: PUSH
49788: EMPTY
49789: LIST
49790: LIST
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: LIST
49796: PPUSH
49797: CALL_OW 72
49801: ST_TO_ADDR
// if not fac then
49802: LD_VAR 0 6
49806: NOT
49807: IFFALSE 49811
// continue ;
49809: GO 49623
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
49811: LD_ADDR_VAR 0 7
49815: PUSH
49816: LD_EXP 123
49820: PUSH
49821: LD_VAR 0 2
49825: ARRAY
49826: PPUSH
49827: LD_INT 22
49829: PUSH
49830: LD_VAR 0 5
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: LD_INT 21
49841: PUSH
49842: LD_INT 2
49844: PUSH
49845: EMPTY
49846: LIST
49847: LIST
49848: PUSH
49849: LD_INT 3
49851: PUSH
49852: LD_INT 24
49854: PUSH
49855: LD_INT 1000
49857: PUSH
49858: EMPTY
49859: LIST
49860: LIST
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: LIST
49870: PPUSH
49871: CALL_OW 70
49875: PUSH
49876: LD_INT 22
49878: PUSH
49879: LD_VAR 0 5
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: PUSH
49888: LD_INT 91
49890: PUSH
49891: LD_VAR 0 6
49895: PUSH
49896: LD_INT 1
49898: ARRAY
49899: PUSH
49900: LD_INT 25
49902: PUSH
49903: EMPTY
49904: LIST
49905: LIST
49906: LIST
49907: PUSH
49908: LD_INT 21
49910: PUSH
49911: LD_INT 2
49913: PUSH
49914: EMPTY
49915: LIST
49916: LIST
49917: PUSH
49918: LD_INT 3
49920: PUSH
49921: LD_INT 24
49923: PUSH
49924: LD_INT 1000
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: PUSH
49931: EMPTY
49932: LIST
49933: LIST
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: LIST
49939: LIST
49940: PPUSH
49941: CALL_OW 69
49945: UNION
49946: ST_TO_ADDR
// if not vehs then
49947: LD_VAR 0 7
49951: NOT
49952: IFFALSE 49978
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49954: LD_ADDR_EXP 111
49958: PUSH
49959: LD_EXP 111
49963: PPUSH
49964: LD_VAR 0 2
49968: PPUSH
49969: EMPTY
49970: PPUSH
49971: CALL_OW 1
49975: ST_TO_ADDR
// continue ;
49976: GO 49623
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49978: LD_ADDR_VAR 0 8
49982: PUSH
49983: LD_EXP 99
49987: PUSH
49988: LD_VAR 0 2
49992: ARRAY
49993: PPUSH
49994: LD_INT 30
49996: PUSH
49997: LD_INT 3
49999: PUSH
50000: EMPTY
50001: LIST
50002: LIST
50003: PPUSH
50004: CALL_OW 72
50008: ST_TO_ADDR
// if tmp then
50009: LD_VAR 0 8
50013: IFFALSE 50116
// begin for j in tmp do
50015: LD_ADDR_VAR 0 3
50019: PUSH
50020: LD_VAR 0 8
50024: PUSH
50025: FOR_IN
50026: IFFALSE 50114
// for k in UnitsInside ( j ) do
50028: LD_ADDR_VAR 0 4
50032: PUSH
50033: LD_VAR 0 3
50037: PPUSH
50038: CALL_OW 313
50042: PUSH
50043: FOR_IN
50044: IFFALSE 50110
// if k then
50046: LD_VAR 0 4
50050: IFFALSE 50108
// if not k in mc_repair_vehicle [ i ] then
50052: LD_VAR 0 4
50056: PUSH
50057: LD_EXP 111
50061: PUSH
50062: LD_VAR 0 2
50066: ARRAY
50067: IN
50068: NOT
50069: IFFALSE 50108
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
50071: LD_ADDR_EXP 111
50075: PUSH
50076: LD_EXP 111
50080: PPUSH
50081: LD_VAR 0 2
50085: PPUSH
50086: LD_EXP 111
50090: PUSH
50091: LD_VAR 0 2
50095: ARRAY
50096: PUSH
50097: LD_VAR 0 4
50101: UNION
50102: PPUSH
50103: CALL_OW 1
50107: ST_TO_ADDR
50108: GO 50043
50110: POP
50111: POP
50112: GO 50025
50114: POP
50115: POP
// end ; if not mc_repair_vehicle [ i ] then
50116: LD_EXP 111
50120: PUSH
50121: LD_VAR 0 2
50125: ARRAY
50126: NOT
50127: IFFALSE 50131
// continue ;
50129: GO 49623
// for j in mc_repair_vehicle [ i ] do
50131: LD_ADDR_VAR 0 3
50135: PUSH
50136: LD_EXP 111
50140: PUSH
50141: LD_VAR 0 2
50145: ARRAY
50146: PUSH
50147: FOR_IN
50148: IFFALSE 50314
// begin if GetClass ( j ) <> 3 then
50150: LD_VAR 0 3
50154: PPUSH
50155: CALL_OW 257
50159: PUSH
50160: LD_INT 3
50162: NONEQUAL
50163: IFFALSE 50204
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
50165: LD_ADDR_EXP 111
50169: PUSH
50170: LD_EXP 111
50174: PPUSH
50175: LD_VAR 0 2
50179: PPUSH
50180: LD_EXP 111
50184: PUSH
50185: LD_VAR 0 2
50189: ARRAY
50190: PUSH
50191: LD_VAR 0 3
50195: DIFF
50196: PPUSH
50197: CALL_OW 1
50201: ST_TO_ADDR
// continue ;
50202: GO 50147
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
50204: LD_VAR 0 3
50208: PPUSH
50209: CALL_OW 311
50213: NOT
50214: PUSH
50215: LD_VAR 0 3
50219: PUSH
50220: LD_EXP 102
50224: PUSH
50225: LD_VAR 0 2
50229: ARRAY
50230: PUSH
50231: LD_INT 1
50233: ARRAY
50234: IN
50235: NOT
50236: AND
50237: PUSH
50238: LD_VAR 0 3
50242: PUSH
50243: LD_EXP 102
50247: PUSH
50248: LD_VAR 0 2
50252: ARRAY
50253: PUSH
50254: LD_INT 2
50256: ARRAY
50257: IN
50258: NOT
50259: AND
50260: IFFALSE 50312
// begin if IsInUnit ( j ) then
50262: LD_VAR 0 3
50266: PPUSH
50267: CALL_OW 310
50271: IFFALSE 50282
// ComExitBuilding ( j ) ;
50273: LD_VAR 0 3
50277: PPUSH
50278: CALL_OW 122
// if not HasTask ( j ) then
50282: LD_VAR 0 3
50286: PPUSH
50287: CALL_OW 314
50291: NOT
50292: IFFALSE 50312
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
50294: LD_VAR 0 3
50298: PPUSH
50299: LD_VAR 0 7
50303: PUSH
50304: LD_INT 1
50306: ARRAY
50307: PPUSH
50308: CALL_OW 189
// end ; end ;
50312: GO 50147
50314: POP
50315: POP
// end ;
50316: GO 49623
50318: POP
50319: POP
// end ;
50320: LD_VAR 0 1
50324: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
50325: LD_INT 0
50327: PPUSH
50328: PPUSH
50329: PPUSH
50330: PPUSH
50331: PPUSH
50332: PPUSH
50333: PPUSH
50334: PPUSH
50335: PPUSH
50336: PPUSH
50337: PPUSH
// if not mc_bases then
50338: LD_EXP 99
50342: NOT
50343: IFFALSE 50347
// exit ;
50345: GO 51149
// for i = 1 to mc_bases do
50347: LD_ADDR_VAR 0 2
50351: PUSH
50352: DOUBLE
50353: LD_INT 1
50355: DEC
50356: ST_TO_ADDR
50357: LD_EXP 99
50361: PUSH
50362: FOR_TO
50363: IFFALSE 51147
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
50365: LD_EXP 127
50369: PUSH
50370: LD_VAR 0 2
50374: ARRAY
50375: NOT
50376: PUSH
50377: LD_EXP 102
50381: PUSH
50382: LD_VAR 0 2
50386: ARRAY
50387: PUSH
50388: LD_INT 1
50390: ARRAY
50391: OR
50392: PUSH
50393: LD_EXP 102
50397: PUSH
50398: LD_VAR 0 2
50402: ARRAY
50403: PUSH
50404: LD_INT 2
50406: ARRAY
50407: OR
50408: PUSH
50409: LD_EXP 125
50413: PUSH
50414: LD_VAR 0 2
50418: ARRAY
50419: PPUSH
50420: LD_INT 1
50422: PPUSH
50423: CALL_OW 325
50427: NOT
50428: OR
50429: PUSH
50430: LD_EXP 122
50434: PUSH
50435: LD_VAR 0 2
50439: ARRAY
50440: OR
50441: IFFALSE 50445
// continue ;
50443: GO 50362
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
50445: LD_ADDR_VAR 0 8
50449: PUSH
50450: LD_EXP 99
50454: PUSH
50455: LD_VAR 0 2
50459: ARRAY
50460: PPUSH
50461: LD_INT 25
50463: PUSH
50464: LD_INT 4
50466: PUSH
50467: EMPTY
50468: LIST
50469: LIST
50470: PUSH
50471: LD_INT 50
50473: PUSH
50474: EMPTY
50475: LIST
50476: PUSH
50477: LD_INT 3
50479: PUSH
50480: LD_INT 60
50482: PUSH
50483: EMPTY
50484: LIST
50485: PUSH
50486: EMPTY
50487: LIST
50488: LIST
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: LIST
50494: PPUSH
50495: CALL_OW 72
50499: PUSH
50500: LD_EXP 103
50504: PUSH
50505: LD_VAR 0 2
50509: ARRAY
50510: DIFF
50511: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50512: LD_ADDR_VAR 0 9
50516: PUSH
50517: LD_EXP 99
50521: PUSH
50522: LD_VAR 0 2
50526: ARRAY
50527: PPUSH
50528: LD_INT 2
50530: PUSH
50531: LD_INT 30
50533: PUSH
50534: LD_INT 0
50536: PUSH
50537: EMPTY
50538: LIST
50539: LIST
50540: PUSH
50541: LD_INT 30
50543: PUSH
50544: LD_INT 1
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: LIST
50555: PPUSH
50556: CALL_OW 72
50560: ST_TO_ADDR
// if not tmp or not dep then
50561: LD_VAR 0 8
50565: NOT
50566: PUSH
50567: LD_VAR 0 9
50571: NOT
50572: OR
50573: IFFALSE 50577
// continue ;
50575: GO 50362
// side := GetSide ( tmp [ 1 ] ) ;
50577: LD_ADDR_VAR 0 11
50581: PUSH
50582: LD_VAR 0 8
50586: PUSH
50587: LD_INT 1
50589: ARRAY
50590: PPUSH
50591: CALL_OW 255
50595: ST_TO_ADDR
// dep := dep [ 1 ] ;
50596: LD_ADDR_VAR 0 9
50600: PUSH
50601: LD_VAR 0 9
50605: PUSH
50606: LD_INT 1
50608: ARRAY
50609: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
50610: LD_ADDR_VAR 0 7
50614: PUSH
50615: LD_EXP 127
50619: PUSH
50620: LD_VAR 0 2
50624: ARRAY
50625: PPUSH
50626: LD_INT 22
50628: PUSH
50629: LD_INT 0
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: PUSH
50636: LD_INT 25
50638: PUSH
50639: LD_INT 12
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PPUSH
50650: CALL_OW 70
50654: PUSH
50655: LD_INT 22
50657: PUSH
50658: LD_INT 0
50660: PUSH
50661: EMPTY
50662: LIST
50663: LIST
50664: PUSH
50665: LD_INT 25
50667: PUSH
50668: LD_INT 12
50670: PUSH
50671: EMPTY
50672: LIST
50673: LIST
50674: PUSH
50675: LD_INT 91
50677: PUSH
50678: LD_VAR 0 9
50682: PUSH
50683: LD_INT 20
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: LIST
50690: PUSH
50691: EMPTY
50692: LIST
50693: LIST
50694: LIST
50695: PPUSH
50696: CALL_OW 69
50700: UNION
50701: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
50702: LD_ADDR_VAR 0 10
50706: PUSH
50707: LD_EXP 127
50711: PUSH
50712: LD_VAR 0 2
50716: ARRAY
50717: PPUSH
50718: LD_INT 81
50720: PUSH
50721: LD_VAR 0 11
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PPUSH
50730: CALL_OW 70
50734: ST_TO_ADDR
// if not apes or danger_at_area then
50735: LD_VAR 0 7
50739: NOT
50740: PUSH
50741: LD_VAR 0 10
50745: OR
50746: IFFALSE 50796
// begin if mc_taming [ i ] then
50748: LD_EXP 130
50752: PUSH
50753: LD_VAR 0 2
50757: ARRAY
50758: IFFALSE 50794
// begin MC_Reset ( i , 121 ) ;
50760: LD_VAR 0 2
50764: PPUSH
50765: LD_INT 121
50767: PPUSH
50768: CALL 36431 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50772: LD_ADDR_EXP 130
50776: PUSH
50777: LD_EXP 130
50781: PPUSH
50782: LD_VAR 0 2
50786: PPUSH
50787: EMPTY
50788: PPUSH
50789: CALL_OW 1
50793: ST_TO_ADDR
// end ; continue ;
50794: GO 50362
// end ; for j in tmp do
50796: LD_ADDR_VAR 0 3
50800: PUSH
50801: LD_VAR 0 8
50805: PUSH
50806: FOR_IN
50807: IFFALSE 51143
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
50809: LD_VAR 0 3
50813: PUSH
50814: LD_EXP 130
50818: PUSH
50819: LD_VAR 0 2
50823: ARRAY
50824: IN
50825: NOT
50826: PUSH
50827: LD_EXP 130
50831: PUSH
50832: LD_VAR 0 2
50836: ARRAY
50837: PUSH
50838: LD_INT 3
50840: LESS
50841: AND
50842: IFFALSE 50900
// begin SetTag ( j , 121 ) ;
50844: LD_VAR 0 3
50848: PPUSH
50849: LD_INT 121
50851: PPUSH
50852: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
50856: LD_ADDR_EXP 130
50860: PUSH
50861: LD_EXP 130
50865: PPUSH
50866: LD_VAR 0 2
50870: PUSH
50871: LD_EXP 130
50875: PUSH
50876: LD_VAR 0 2
50880: ARRAY
50881: PUSH
50882: LD_INT 1
50884: PLUS
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PPUSH
50890: LD_VAR 0 3
50894: PPUSH
50895: CALL 68319 0 3
50899: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
50900: LD_VAR 0 3
50904: PUSH
50905: LD_EXP 130
50909: PUSH
50910: LD_VAR 0 2
50914: ARRAY
50915: IN
50916: IFFALSE 51141
// begin if GetClass ( j ) <> 4 then
50918: LD_VAR 0 3
50922: PPUSH
50923: CALL_OW 257
50927: PUSH
50928: LD_INT 4
50930: NONEQUAL
50931: IFFALSE 50984
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
50933: LD_ADDR_EXP 130
50937: PUSH
50938: LD_EXP 130
50942: PPUSH
50943: LD_VAR 0 2
50947: PPUSH
50948: LD_EXP 130
50952: PUSH
50953: LD_VAR 0 2
50957: ARRAY
50958: PUSH
50959: LD_VAR 0 3
50963: DIFF
50964: PPUSH
50965: CALL_OW 1
50969: ST_TO_ADDR
// SetTag ( j , 0 ) ;
50970: LD_VAR 0 3
50974: PPUSH
50975: LD_INT 0
50977: PPUSH
50978: CALL_OW 109
// continue ;
50982: GO 50806
// end ; if IsInUnit ( j ) then
50984: LD_VAR 0 3
50988: PPUSH
50989: CALL_OW 310
50993: IFFALSE 51004
// ComExitBuilding ( j ) ;
50995: LD_VAR 0 3
50999: PPUSH
51000: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
51004: LD_ADDR_VAR 0 6
51008: PUSH
51009: LD_VAR 0 7
51013: PPUSH
51014: LD_VAR 0 3
51018: PPUSH
51019: CALL_OW 74
51023: ST_TO_ADDR
// if not ape then
51024: LD_VAR 0 6
51028: NOT
51029: IFFALSE 51033
// break ;
51031: GO 51143
// x := GetX ( ape ) ;
51033: LD_ADDR_VAR 0 4
51037: PUSH
51038: LD_VAR 0 6
51042: PPUSH
51043: CALL_OW 250
51047: ST_TO_ADDR
// y := GetY ( ape ) ;
51048: LD_ADDR_VAR 0 5
51052: PUSH
51053: LD_VAR 0 6
51057: PPUSH
51058: CALL_OW 251
51062: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
51063: LD_VAR 0 4
51067: PPUSH
51068: LD_VAR 0 5
51072: PPUSH
51073: CALL_OW 488
51077: NOT
51078: PUSH
51079: LD_VAR 0 11
51083: PPUSH
51084: LD_VAR 0 4
51088: PPUSH
51089: LD_VAR 0 5
51093: PPUSH
51094: LD_INT 20
51096: PPUSH
51097: CALL 69215 0 4
51101: PUSH
51102: LD_INT 4
51104: ARRAY
51105: OR
51106: IFFALSE 51110
// break ;
51108: GO 51143
// if not HasTask ( j ) then
51110: LD_VAR 0 3
51114: PPUSH
51115: CALL_OW 314
51119: NOT
51120: IFFALSE 51141
// ComTameXY ( j , x , y ) ;
51122: LD_VAR 0 3
51126: PPUSH
51127: LD_VAR 0 4
51131: PPUSH
51132: LD_VAR 0 5
51136: PPUSH
51137: CALL_OW 131
// end ; end ;
51141: GO 50806
51143: POP
51144: POP
// end ;
51145: GO 50362
51147: POP
51148: POP
// end ;
51149: LD_VAR 0 1
51153: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
51154: LD_INT 0
51156: PPUSH
51157: PPUSH
51158: PPUSH
51159: PPUSH
51160: PPUSH
51161: PPUSH
51162: PPUSH
51163: PPUSH
// if not mc_bases then
51164: LD_EXP 99
51168: NOT
51169: IFFALSE 51173
// exit ;
51171: GO 51799
// for i = 1 to mc_bases do
51173: LD_ADDR_VAR 0 2
51177: PUSH
51178: DOUBLE
51179: LD_INT 1
51181: DEC
51182: ST_TO_ADDR
51183: LD_EXP 99
51187: PUSH
51188: FOR_TO
51189: IFFALSE 51797
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
51191: LD_EXP 128
51195: PUSH
51196: LD_VAR 0 2
51200: ARRAY
51201: NOT
51202: PUSH
51203: LD_EXP 128
51207: PUSH
51208: LD_VAR 0 2
51212: ARRAY
51213: PPUSH
51214: LD_INT 25
51216: PUSH
51217: LD_INT 12
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PPUSH
51224: CALL_OW 72
51228: NOT
51229: OR
51230: IFFALSE 51234
// continue ;
51232: GO 51188
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
51234: LD_ADDR_VAR 0 5
51238: PUSH
51239: LD_EXP 128
51243: PUSH
51244: LD_VAR 0 2
51248: ARRAY
51249: PUSH
51250: LD_INT 1
51252: ARRAY
51253: PPUSH
51254: CALL_OW 255
51258: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
51259: LD_VAR 0 5
51263: PPUSH
51264: LD_INT 2
51266: PPUSH
51267: CALL_OW 325
51271: IFFALSE 51524
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
51273: LD_ADDR_VAR 0 4
51277: PUSH
51278: LD_EXP 128
51282: PUSH
51283: LD_VAR 0 2
51287: ARRAY
51288: PPUSH
51289: LD_INT 25
51291: PUSH
51292: LD_INT 16
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: PPUSH
51299: CALL_OW 72
51303: ST_TO_ADDR
// if tmp < 6 then
51304: LD_VAR 0 4
51308: PUSH
51309: LD_INT 6
51311: LESS
51312: IFFALSE 51524
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51314: LD_ADDR_VAR 0 6
51318: PUSH
51319: LD_EXP 99
51323: PUSH
51324: LD_VAR 0 2
51328: ARRAY
51329: PPUSH
51330: LD_INT 2
51332: PUSH
51333: LD_INT 30
51335: PUSH
51336: LD_INT 0
51338: PUSH
51339: EMPTY
51340: LIST
51341: LIST
51342: PUSH
51343: LD_INT 30
51345: PUSH
51346: LD_INT 1
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: LIST
51357: PPUSH
51358: CALL_OW 72
51362: ST_TO_ADDR
// if depot then
51363: LD_VAR 0 6
51367: IFFALSE 51524
// begin selected := 0 ;
51369: LD_ADDR_VAR 0 7
51373: PUSH
51374: LD_INT 0
51376: ST_TO_ADDR
// for j in depot do
51377: LD_ADDR_VAR 0 3
51381: PUSH
51382: LD_VAR 0 6
51386: PUSH
51387: FOR_IN
51388: IFFALSE 51419
// begin if UnitsInside ( j ) < 6 then
51390: LD_VAR 0 3
51394: PPUSH
51395: CALL_OW 313
51399: PUSH
51400: LD_INT 6
51402: LESS
51403: IFFALSE 51417
// begin selected := j ;
51405: LD_ADDR_VAR 0 7
51409: PUSH
51410: LD_VAR 0 3
51414: ST_TO_ADDR
// break ;
51415: GO 51419
// end ; end ;
51417: GO 51387
51419: POP
51420: POP
// if selected then
51421: LD_VAR 0 7
51425: IFFALSE 51524
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
51427: LD_ADDR_VAR 0 3
51431: PUSH
51432: LD_EXP 128
51436: PUSH
51437: LD_VAR 0 2
51441: ARRAY
51442: PPUSH
51443: LD_INT 25
51445: PUSH
51446: LD_INT 12
51448: PUSH
51449: EMPTY
51450: LIST
51451: LIST
51452: PPUSH
51453: CALL_OW 72
51457: PUSH
51458: FOR_IN
51459: IFFALSE 51522
// if not HasTask ( j ) then
51461: LD_VAR 0 3
51465: PPUSH
51466: CALL_OW 314
51470: NOT
51471: IFFALSE 51520
// begin if not IsInUnit ( j ) then
51473: LD_VAR 0 3
51477: PPUSH
51478: CALL_OW 310
51482: NOT
51483: IFFALSE 51499
// ComEnterUnit ( j , selected ) ;
51485: LD_VAR 0 3
51489: PPUSH
51490: LD_VAR 0 7
51494: PPUSH
51495: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
51499: LD_VAR 0 3
51503: PPUSH
51504: LD_INT 16
51506: PPUSH
51507: CALL_OW 183
// AddComExitBuilding ( j ) ;
51511: LD_VAR 0 3
51515: PPUSH
51516: CALL_OW 182
// end ;
51520: GO 51458
51522: POP
51523: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
51524: LD_VAR 0 5
51528: PPUSH
51529: LD_INT 11
51531: PPUSH
51532: CALL_OW 325
51536: IFFALSE 51795
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
51538: LD_ADDR_VAR 0 4
51542: PUSH
51543: LD_EXP 128
51547: PUSH
51548: LD_VAR 0 2
51552: ARRAY
51553: PPUSH
51554: LD_INT 25
51556: PUSH
51557: LD_INT 16
51559: PUSH
51560: EMPTY
51561: LIST
51562: LIST
51563: PPUSH
51564: CALL_OW 72
51568: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
51569: LD_VAR 0 4
51573: PUSH
51574: LD_INT 6
51576: GREATEREQUAL
51577: PUSH
51578: LD_VAR 0 5
51582: PPUSH
51583: LD_INT 2
51585: PPUSH
51586: CALL_OW 325
51590: NOT
51591: OR
51592: IFFALSE 51795
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51594: LD_ADDR_VAR 0 8
51598: PUSH
51599: LD_EXP 99
51603: PUSH
51604: LD_VAR 0 2
51608: ARRAY
51609: PPUSH
51610: LD_INT 2
51612: PUSH
51613: LD_INT 30
51615: PUSH
51616: LD_INT 4
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PUSH
51623: LD_INT 30
51625: PUSH
51626: LD_INT 5
51628: PUSH
51629: EMPTY
51630: LIST
51631: LIST
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: LIST
51637: PPUSH
51638: CALL_OW 72
51642: ST_TO_ADDR
// if barracks then
51643: LD_VAR 0 8
51647: IFFALSE 51795
// begin selected := 0 ;
51649: LD_ADDR_VAR 0 7
51653: PUSH
51654: LD_INT 0
51656: ST_TO_ADDR
// for j in barracks do
51657: LD_ADDR_VAR 0 3
51661: PUSH
51662: LD_VAR 0 8
51666: PUSH
51667: FOR_IN
51668: IFFALSE 51699
// begin if UnitsInside ( j ) < 6 then
51670: LD_VAR 0 3
51674: PPUSH
51675: CALL_OW 313
51679: PUSH
51680: LD_INT 6
51682: LESS
51683: IFFALSE 51697
// begin selected := j ;
51685: LD_ADDR_VAR 0 7
51689: PUSH
51690: LD_VAR 0 3
51694: ST_TO_ADDR
// break ;
51695: GO 51699
// end ; end ;
51697: GO 51667
51699: POP
51700: POP
// if selected then
51701: LD_VAR 0 7
51705: IFFALSE 51795
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
51707: LD_ADDR_VAR 0 3
51711: PUSH
51712: LD_EXP 128
51716: PUSH
51717: LD_VAR 0 2
51721: ARRAY
51722: PPUSH
51723: LD_INT 25
51725: PUSH
51726: LD_INT 12
51728: PUSH
51729: EMPTY
51730: LIST
51731: LIST
51732: PPUSH
51733: CALL_OW 72
51737: PUSH
51738: FOR_IN
51739: IFFALSE 51793
// if not IsInUnit ( j ) and not HasTask ( j ) then
51741: LD_VAR 0 3
51745: PPUSH
51746: CALL_OW 310
51750: NOT
51751: PUSH
51752: LD_VAR 0 3
51756: PPUSH
51757: CALL_OW 314
51761: NOT
51762: AND
51763: IFFALSE 51791
// begin ComEnterUnit ( j , selected ) ;
51765: LD_VAR 0 3
51769: PPUSH
51770: LD_VAR 0 7
51774: PPUSH
51775: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
51779: LD_VAR 0 3
51783: PPUSH
51784: LD_INT 15
51786: PPUSH
51787: CALL_OW 183
// end ;
51791: GO 51738
51793: POP
51794: POP
// end ; end ; end ; end ; end ;
51795: GO 51188
51797: POP
51798: POP
// end ;
51799: LD_VAR 0 1
51803: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
51804: LD_INT 0
51806: PPUSH
51807: PPUSH
51808: PPUSH
51809: PPUSH
// if not mc_bases then
51810: LD_EXP 99
51814: NOT
51815: IFFALSE 51819
// exit ;
51817: GO 51997
// for i = 1 to mc_bases do
51819: LD_ADDR_VAR 0 2
51823: PUSH
51824: DOUBLE
51825: LD_INT 1
51827: DEC
51828: ST_TO_ADDR
51829: LD_EXP 99
51833: PUSH
51834: FOR_TO
51835: IFFALSE 51995
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
51837: LD_ADDR_VAR 0 4
51841: PUSH
51842: LD_EXP 99
51846: PUSH
51847: LD_VAR 0 2
51851: ARRAY
51852: PPUSH
51853: LD_INT 25
51855: PUSH
51856: LD_INT 9
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PPUSH
51863: CALL_OW 72
51867: ST_TO_ADDR
// if not tmp then
51868: LD_VAR 0 4
51872: NOT
51873: IFFALSE 51877
// continue ;
51875: GO 51834
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
51877: LD_EXP 125
51881: PUSH
51882: LD_VAR 0 2
51886: ARRAY
51887: PPUSH
51888: LD_INT 29
51890: PPUSH
51891: CALL_OW 325
51895: NOT
51896: PUSH
51897: LD_EXP 125
51901: PUSH
51902: LD_VAR 0 2
51906: ARRAY
51907: PPUSH
51908: LD_INT 28
51910: PPUSH
51911: CALL_OW 325
51915: NOT
51916: AND
51917: IFFALSE 51921
// continue ;
51919: GO 51834
// for j in tmp do
51921: LD_ADDR_VAR 0 3
51925: PUSH
51926: LD_VAR 0 4
51930: PUSH
51931: FOR_IN
51932: IFFALSE 51991
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51934: LD_VAR 0 3
51938: PUSH
51939: LD_EXP 102
51943: PUSH
51944: LD_VAR 0 2
51948: ARRAY
51949: PUSH
51950: LD_INT 1
51952: ARRAY
51953: IN
51954: NOT
51955: PUSH
51956: LD_VAR 0 3
51960: PUSH
51961: LD_EXP 102
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: PUSH
51972: LD_INT 2
51974: ARRAY
51975: IN
51976: NOT
51977: AND
51978: IFFALSE 51989
// ComSpaceTimeShoot ( j ) ;
51980: LD_VAR 0 3
51984: PPUSH
51985: CALL 62379 0 1
51989: GO 51931
51991: POP
51992: POP
// end ;
51993: GO 51834
51995: POP
51996: POP
// end ;
51997: LD_VAR 0 1
52001: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
52002: LD_INT 0
52004: PPUSH
52005: PPUSH
52006: PPUSH
52007: PPUSH
52008: PPUSH
52009: PPUSH
52010: PPUSH
52011: PPUSH
52012: PPUSH
// if not mc_bases then
52013: LD_EXP 99
52017: NOT
52018: IFFALSE 52022
// exit ;
52020: GO 52644
// for i = 1 to mc_bases do
52022: LD_ADDR_VAR 0 2
52026: PUSH
52027: DOUBLE
52028: LD_INT 1
52030: DEC
52031: ST_TO_ADDR
52032: LD_EXP 99
52036: PUSH
52037: FOR_TO
52038: IFFALSE 52642
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
52040: LD_EXP 134
52044: PUSH
52045: LD_VAR 0 2
52049: ARRAY
52050: NOT
52051: PUSH
52052: LD_INT 38
52054: PPUSH
52055: LD_EXP 125
52059: PUSH
52060: LD_VAR 0 2
52064: ARRAY
52065: PPUSH
52066: CALL_OW 321
52070: PUSH
52071: LD_INT 2
52073: NONEQUAL
52074: OR
52075: IFFALSE 52079
// continue ;
52077: GO 52037
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
52079: LD_ADDR_VAR 0 8
52083: PUSH
52084: LD_EXP 99
52088: PUSH
52089: LD_VAR 0 2
52093: ARRAY
52094: PPUSH
52095: LD_INT 30
52097: PUSH
52098: LD_INT 34
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: PPUSH
52105: CALL_OW 72
52109: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
52110: LD_ADDR_VAR 0 9
52114: PUSH
52115: LD_EXP 99
52119: PUSH
52120: LD_VAR 0 2
52124: ARRAY
52125: PPUSH
52126: LD_INT 25
52128: PUSH
52129: LD_INT 4
52131: PUSH
52132: EMPTY
52133: LIST
52134: LIST
52135: PPUSH
52136: CALL_OW 72
52140: PPUSH
52141: LD_INT 0
52143: PPUSH
52144: CALL 101516 0 2
52148: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
52149: LD_VAR 0 9
52153: NOT
52154: PUSH
52155: LD_VAR 0 8
52159: NOT
52160: OR
52161: PUSH
52162: LD_EXP 99
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: PPUSH
52173: LD_INT 124
52175: PPUSH
52176: CALL 101516 0 2
52180: OR
52181: IFFALSE 52185
// continue ;
52183: GO 52037
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
52185: LD_EXP 135
52189: PUSH
52190: LD_VAR 0 2
52194: ARRAY
52195: PUSH
52196: LD_EXP 134
52200: PUSH
52201: LD_VAR 0 2
52205: ARRAY
52206: LESS
52207: PUSH
52208: LD_EXP 135
52212: PUSH
52213: LD_VAR 0 2
52217: ARRAY
52218: PUSH
52219: LD_VAR 0 8
52223: LESS
52224: AND
52225: IFFALSE 52640
// begin tmp := sci [ 1 ] ;
52227: LD_ADDR_VAR 0 7
52231: PUSH
52232: LD_VAR 0 9
52236: PUSH
52237: LD_INT 1
52239: ARRAY
52240: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
52241: LD_VAR 0 7
52245: PPUSH
52246: LD_INT 124
52248: PPUSH
52249: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
52253: LD_ADDR_VAR 0 3
52257: PUSH
52258: DOUBLE
52259: LD_EXP 134
52263: PUSH
52264: LD_VAR 0 2
52268: ARRAY
52269: INC
52270: ST_TO_ADDR
52271: LD_EXP 134
52275: PUSH
52276: LD_VAR 0 2
52280: ARRAY
52281: PUSH
52282: FOR_DOWNTO
52283: IFFALSE 52626
// begin if IsInUnit ( tmp ) then
52285: LD_VAR 0 7
52289: PPUSH
52290: CALL_OW 310
52294: IFFALSE 52305
// ComExitBuilding ( tmp ) ;
52296: LD_VAR 0 7
52300: PPUSH
52301: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
52305: LD_INT 35
52307: PPUSH
52308: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
52312: LD_VAR 0 7
52316: PPUSH
52317: CALL_OW 310
52321: NOT
52322: PUSH
52323: LD_VAR 0 7
52327: PPUSH
52328: CALL_OW 314
52332: NOT
52333: AND
52334: IFFALSE 52305
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
52336: LD_ADDR_VAR 0 6
52340: PUSH
52341: LD_VAR 0 7
52345: PPUSH
52346: CALL_OW 250
52350: PUSH
52351: LD_VAR 0 7
52355: PPUSH
52356: CALL_OW 251
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
52365: LD_INT 35
52367: PPUSH
52368: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
52372: LD_ADDR_VAR 0 4
52376: PUSH
52377: LD_EXP 134
52381: PUSH
52382: LD_VAR 0 2
52386: ARRAY
52387: PUSH
52388: LD_VAR 0 3
52392: ARRAY
52393: PUSH
52394: LD_INT 1
52396: ARRAY
52397: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
52398: LD_ADDR_VAR 0 5
52402: PUSH
52403: LD_EXP 134
52407: PUSH
52408: LD_VAR 0 2
52412: ARRAY
52413: PUSH
52414: LD_VAR 0 3
52418: ARRAY
52419: PUSH
52420: LD_INT 2
52422: ARRAY
52423: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
52424: LD_VAR 0 7
52428: PPUSH
52429: LD_INT 10
52431: PPUSH
52432: CALL 70912 0 2
52436: PUSH
52437: LD_INT 4
52439: ARRAY
52440: IFFALSE 52478
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
52442: LD_VAR 0 7
52446: PPUSH
52447: LD_VAR 0 6
52451: PUSH
52452: LD_INT 1
52454: ARRAY
52455: PPUSH
52456: LD_VAR 0 6
52460: PUSH
52461: LD_INT 2
52463: ARRAY
52464: PPUSH
52465: CALL_OW 111
// wait ( 0 0$10 ) ;
52469: LD_INT 350
52471: PPUSH
52472: CALL_OW 67
// end else
52476: GO 52504
// begin ComMoveXY ( tmp , x , y ) ;
52478: LD_VAR 0 7
52482: PPUSH
52483: LD_VAR 0 4
52487: PPUSH
52488: LD_VAR 0 5
52492: PPUSH
52493: CALL_OW 111
// wait ( 0 0$3 ) ;
52497: LD_INT 105
52499: PPUSH
52500: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
52504: LD_VAR 0 7
52508: PPUSH
52509: LD_VAR 0 4
52513: PPUSH
52514: LD_VAR 0 5
52518: PPUSH
52519: CALL_OW 307
52523: IFFALSE 52365
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
52525: LD_VAR 0 7
52529: PPUSH
52530: LD_VAR 0 4
52534: PPUSH
52535: LD_VAR 0 5
52539: PPUSH
52540: LD_VAR 0 8
52544: PUSH
52545: LD_VAR 0 3
52549: ARRAY
52550: PPUSH
52551: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
52555: LD_INT 35
52557: PPUSH
52558: CALL_OW 67
// until not HasTask ( tmp ) ;
52562: LD_VAR 0 7
52566: PPUSH
52567: CALL_OW 314
52571: NOT
52572: IFFALSE 52555
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
52574: LD_ADDR_EXP 135
52578: PUSH
52579: LD_EXP 135
52583: PPUSH
52584: LD_VAR 0 2
52588: PUSH
52589: LD_EXP 135
52593: PUSH
52594: LD_VAR 0 2
52598: ARRAY
52599: PUSH
52600: LD_INT 1
52602: PLUS
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: PPUSH
52608: LD_VAR 0 8
52612: PUSH
52613: LD_VAR 0 3
52617: ARRAY
52618: PPUSH
52619: CALL 68319 0 3
52623: ST_TO_ADDR
// end ;
52624: GO 52282
52626: POP
52627: POP
// MC_Reset ( i , 124 ) ;
52628: LD_VAR 0 2
52632: PPUSH
52633: LD_INT 124
52635: PPUSH
52636: CALL 36431 0 2
// end ; end ;
52640: GO 52037
52642: POP
52643: POP
// end ;
52644: LD_VAR 0 1
52648: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
52649: LD_INT 0
52651: PPUSH
52652: PPUSH
52653: PPUSH
// if not mc_bases then
52654: LD_EXP 99
52658: NOT
52659: IFFALSE 52663
// exit ;
52661: GO 53269
// for i = 1 to mc_bases do
52663: LD_ADDR_VAR 0 2
52667: PUSH
52668: DOUBLE
52669: LD_INT 1
52671: DEC
52672: ST_TO_ADDR
52673: LD_EXP 99
52677: PUSH
52678: FOR_TO
52679: IFFALSE 53267
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
52681: LD_ADDR_VAR 0 3
52685: PUSH
52686: LD_EXP 99
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PPUSH
52697: LD_INT 25
52699: PUSH
52700: LD_INT 4
52702: PUSH
52703: EMPTY
52704: LIST
52705: LIST
52706: PPUSH
52707: CALL_OW 72
52711: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52712: LD_VAR 0 3
52716: NOT
52717: PUSH
52718: LD_EXP 136
52722: PUSH
52723: LD_VAR 0 2
52727: ARRAY
52728: NOT
52729: OR
52730: PUSH
52731: LD_EXP 99
52735: PUSH
52736: LD_VAR 0 2
52740: ARRAY
52741: PPUSH
52742: LD_INT 2
52744: PUSH
52745: LD_INT 30
52747: PUSH
52748: LD_INT 0
52750: PUSH
52751: EMPTY
52752: LIST
52753: LIST
52754: PUSH
52755: LD_INT 30
52757: PUSH
52758: LD_INT 1
52760: PUSH
52761: EMPTY
52762: LIST
52763: LIST
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: LIST
52769: PPUSH
52770: CALL_OW 72
52774: NOT
52775: OR
52776: IFFALSE 52826
// begin if mc_deposits_finder [ i ] then
52778: LD_EXP 137
52782: PUSH
52783: LD_VAR 0 2
52787: ARRAY
52788: IFFALSE 52824
// begin MC_Reset ( i , 125 ) ;
52790: LD_VAR 0 2
52794: PPUSH
52795: LD_INT 125
52797: PPUSH
52798: CALL 36431 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52802: LD_ADDR_EXP 137
52806: PUSH
52807: LD_EXP 137
52811: PPUSH
52812: LD_VAR 0 2
52816: PPUSH
52817: EMPTY
52818: PPUSH
52819: CALL_OW 1
52823: ST_TO_ADDR
// end ; continue ;
52824: GO 52678
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
52826: LD_EXP 136
52830: PUSH
52831: LD_VAR 0 2
52835: ARRAY
52836: PUSH
52837: LD_INT 1
52839: ARRAY
52840: PUSH
52841: LD_INT 3
52843: ARRAY
52844: PUSH
52845: LD_INT 1
52847: EQUAL
52848: PUSH
52849: LD_INT 20
52851: PPUSH
52852: LD_EXP 125
52856: PUSH
52857: LD_VAR 0 2
52861: ARRAY
52862: PPUSH
52863: CALL_OW 321
52867: PUSH
52868: LD_INT 2
52870: NONEQUAL
52871: AND
52872: IFFALSE 52922
// begin if mc_deposits_finder [ i ] then
52874: LD_EXP 137
52878: PUSH
52879: LD_VAR 0 2
52883: ARRAY
52884: IFFALSE 52920
// begin MC_Reset ( i , 125 ) ;
52886: LD_VAR 0 2
52890: PPUSH
52891: LD_INT 125
52893: PPUSH
52894: CALL 36431 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52898: LD_ADDR_EXP 137
52902: PUSH
52903: LD_EXP 137
52907: PPUSH
52908: LD_VAR 0 2
52912: PPUSH
52913: EMPTY
52914: PPUSH
52915: CALL_OW 1
52919: ST_TO_ADDR
// end ; continue ;
52920: GO 52678
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
52922: LD_EXP 136
52926: PUSH
52927: LD_VAR 0 2
52931: ARRAY
52932: PUSH
52933: LD_INT 1
52935: ARRAY
52936: PUSH
52937: LD_INT 1
52939: ARRAY
52940: PPUSH
52941: LD_EXP 136
52945: PUSH
52946: LD_VAR 0 2
52950: ARRAY
52951: PUSH
52952: LD_INT 1
52954: ARRAY
52955: PUSH
52956: LD_INT 2
52958: ARRAY
52959: PPUSH
52960: LD_EXP 125
52964: PUSH
52965: LD_VAR 0 2
52969: ARRAY
52970: PPUSH
52971: CALL_OW 440
52975: IFFALSE 53018
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
52977: LD_ADDR_EXP 136
52981: PUSH
52982: LD_EXP 136
52986: PPUSH
52987: LD_VAR 0 2
52991: PPUSH
52992: LD_EXP 136
52996: PUSH
52997: LD_VAR 0 2
53001: ARRAY
53002: PPUSH
53003: LD_INT 1
53005: PPUSH
53006: CALL_OW 3
53010: PPUSH
53011: CALL_OW 1
53015: ST_TO_ADDR
53016: GO 53265
// begin if not mc_deposits_finder [ i ] then
53018: LD_EXP 137
53022: PUSH
53023: LD_VAR 0 2
53027: ARRAY
53028: NOT
53029: IFFALSE 53081
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
53031: LD_ADDR_EXP 137
53035: PUSH
53036: LD_EXP 137
53040: PPUSH
53041: LD_VAR 0 2
53045: PPUSH
53046: LD_VAR 0 3
53050: PUSH
53051: LD_INT 1
53053: ARRAY
53054: PUSH
53055: EMPTY
53056: LIST
53057: PPUSH
53058: CALL_OW 1
53062: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
53063: LD_VAR 0 3
53067: PUSH
53068: LD_INT 1
53070: ARRAY
53071: PPUSH
53072: LD_INT 125
53074: PPUSH
53075: CALL_OW 109
// end else
53079: GO 53265
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
53081: LD_EXP 137
53085: PUSH
53086: LD_VAR 0 2
53090: ARRAY
53091: PUSH
53092: LD_INT 1
53094: ARRAY
53095: PPUSH
53096: CALL_OW 310
53100: IFFALSE 53123
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
53102: LD_EXP 137
53106: PUSH
53107: LD_VAR 0 2
53111: ARRAY
53112: PUSH
53113: LD_INT 1
53115: ARRAY
53116: PPUSH
53117: CALL_OW 122
53121: GO 53265
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
53123: LD_EXP 137
53127: PUSH
53128: LD_VAR 0 2
53132: ARRAY
53133: PUSH
53134: LD_INT 1
53136: ARRAY
53137: PPUSH
53138: CALL_OW 314
53142: NOT
53143: PUSH
53144: LD_EXP 137
53148: PUSH
53149: LD_VAR 0 2
53153: ARRAY
53154: PUSH
53155: LD_INT 1
53157: ARRAY
53158: PPUSH
53159: LD_EXP 136
53163: PUSH
53164: LD_VAR 0 2
53168: ARRAY
53169: PUSH
53170: LD_INT 1
53172: ARRAY
53173: PUSH
53174: LD_INT 1
53176: ARRAY
53177: PPUSH
53178: LD_EXP 136
53182: PUSH
53183: LD_VAR 0 2
53187: ARRAY
53188: PUSH
53189: LD_INT 1
53191: ARRAY
53192: PUSH
53193: LD_INT 2
53195: ARRAY
53196: PPUSH
53197: CALL_OW 297
53201: PUSH
53202: LD_INT 6
53204: GREATER
53205: AND
53206: IFFALSE 53265
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
53208: LD_EXP 137
53212: PUSH
53213: LD_VAR 0 2
53217: ARRAY
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: PPUSH
53223: LD_EXP 136
53227: PUSH
53228: LD_VAR 0 2
53232: ARRAY
53233: PUSH
53234: LD_INT 1
53236: ARRAY
53237: PUSH
53238: LD_INT 1
53240: ARRAY
53241: PPUSH
53242: LD_EXP 136
53246: PUSH
53247: LD_VAR 0 2
53251: ARRAY
53252: PUSH
53253: LD_INT 1
53255: ARRAY
53256: PUSH
53257: LD_INT 2
53259: ARRAY
53260: PPUSH
53261: CALL_OW 111
// end ; end ; end ;
53265: GO 52678
53267: POP
53268: POP
// end ;
53269: LD_VAR 0 1
53273: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
53274: LD_INT 0
53276: PPUSH
53277: PPUSH
53278: PPUSH
53279: PPUSH
53280: PPUSH
53281: PPUSH
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
// if not mc_bases then
53287: LD_EXP 99
53291: NOT
53292: IFFALSE 53296
// exit ;
53294: GO 54020
// for i = 1 to mc_bases do
53296: LD_ADDR_VAR 0 2
53300: PUSH
53301: DOUBLE
53302: LD_INT 1
53304: DEC
53305: ST_TO_ADDR
53306: LD_EXP 99
53310: PUSH
53311: FOR_TO
53312: IFFALSE 54018
// begin if not mc_bases [ i ] then
53314: LD_EXP 99
53318: PUSH
53319: LD_VAR 0 2
53323: ARRAY
53324: NOT
53325: IFFALSE 53329
// continue ;
53327: GO 53311
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
53329: LD_ADDR_VAR 0 7
53333: PUSH
53334: LD_EXP 99
53338: PUSH
53339: LD_VAR 0 2
53343: ARRAY
53344: PUSH
53345: LD_INT 1
53347: ARRAY
53348: PPUSH
53349: CALL_OW 248
53353: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
53354: LD_VAR 0 7
53358: PUSH
53359: LD_INT 3
53361: EQUAL
53362: PUSH
53363: LD_EXP 118
53367: PUSH
53368: LD_VAR 0 2
53372: ARRAY
53373: PUSH
53374: LD_EXP 121
53378: PUSH
53379: LD_VAR 0 2
53383: ARRAY
53384: UNION
53385: PPUSH
53386: LD_INT 33
53388: PUSH
53389: LD_INT 2
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: PPUSH
53396: CALL_OW 72
53400: NOT
53401: OR
53402: IFFALSE 53406
// continue ;
53404: GO 53311
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
53406: LD_ADDR_VAR 0 9
53410: PUSH
53411: LD_EXP 99
53415: PUSH
53416: LD_VAR 0 2
53420: ARRAY
53421: PPUSH
53422: LD_INT 30
53424: PUSH
53425: LD_INT 36
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: PPUSH
53432: CALL_OW 72
53436: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
53437: LD_ADDR_VAR 0 10
53441: PUSH
53442: LD_EXP 118
53446: PUSH
53447: LD_VAR 0 2
53451: ARRAY
53452: PPUSH
53453: LD_INT 34
53455: PUSH
53456: LD_INT 31
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PPUSH
53463: CALL_OW 72
53467: ST_TO_ADDR
// if not cts and not mcts then
53468: LD_VAR 0 9
53472: NOT
53473: PUSH
53474: LD_VAR 0 10
53478: NOT
53479: AND
53480: IFFALSE 53484
// continue ;
53482: GO 53311
// x := cts ;
53484: LD_ADDR_VAR 0 11
53488: PUSH
53489: LD_VAR 0 9
53493: ST_TO_ADDR
// if not x then
53494: LD_VAR 0 11
53498: NOT
53499: IFFALSE 53511
// x := mcts ;
53501: LD_ADDR_VAR 0 11
53505: PUSH
53506: LD_VAR 0 10
53510: ST_TO_ADDR
// if mc_remote_driver [ i ] then
53511: LD_EXP 139
53515: PUSH
53516: LD_VAR 0 2
53520: ARRAY
53521: IFFALSE 53790
// for j in mc_remote_driver [ i ] do
53523: LD_ADDR_VAR 0 3
53527: PUSH
53528: LD_EXP 139
53532: PUSH
53533: LD_VAR 0 2
53537: ARRAY
53538: PUSH
53539: FOR_IN
53540: IFFALSE 53788
// begin if GetClass ( j ) <> 3 then
53542: LD_VAR 0 3
53546: PPUSH
53547: CALL_OW 257
53551: PUSH
53552: LD_INT 3
53554: NONEQUAL
53555: IFFALSE 53608
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
53557: LD_ADDR_EXP 139
53561: PUSH
53562: LD_EXP 139
53566: PPUSH
53567: LD_VAR 0 2
53571: PPUSH
53572: LD_EXP 139
53576: PUSH
53577: LD_VAR 0 2
53581: ARRAY
53582: PUSH
53583: LD_VAR 0 3
53587: DIFF
53588: PPUSH
53589: CALL_OW 1
53593: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53594: LD_VAR 0 3
53598: PPUSH
53599: LD_INT 0
53601: PPUSH
53602: CALL_OW 109
// continue ;
53606: GO 53539
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
53608: LD_VAR 0 3
53612: PPUSH
53613: CALL_OW 310
53617: NOT
53618: PUSH
53619: LD_VAR 0 3
53623: PPUSH
53624: CALL_OW 310
53628: PPUSH
53629: CALL_OW 266
53633: PUSH
53634: LD_INT 36
53636: NONEQUAL
53637: PUSH
53638: LD_VAR 0 3
53642: PPUSH
53643: CALL 101604 0 1
53647: NOT
53648: AND
53649: OR
53650: IFFALSE 53786
// begin if IsInUnit ( j ) then
53652: LD_VAR 0 3
53656: PPUSH
53657: CALL_OW 310
53661: IFFALSE 53672
// ComExitBuilding ( j ) ;
53663: LD_VAR 0 3
53667: PPUSH
53668: CALL_OW 122
// ct := 0 ;
53672: LD_ADDR_VAR 0 8
53676: PUSH
53677: LD_INT 0
53679: ST_TO_ADDR
// for k in x do
53680: LD_ADDR_VAR 0 4
53684: PUSH
53685: LD_VAR 0 11
53689: PUSH
53690: FOR_IN
53691: IFFALSE 53764
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
53693: LD_VAR 0 4
53697: PPUSH
53698: CALL_OW 264
53702: PUSH
53703: LD_INT 31
53705: EQUAL
53706: PUSH
53707: LD_VAR 0 4
53711: PPUSH
53712: CALL_OW 311
53716: NOT
53717: AND
53718: PUSH
53719: LD_VAR 0 4
53723: PPUSH
53724: CALL_OW 266
53728: PUSH
53729: LD_INT 36
53731: EQUAL
53732: PUSH
53733: LD_VAR 0 4
53737: PPUSH
53738: CALL_OW 313
53742: PUSH
53743: LD_INT 3
53745: LESS
53746: AND
53747: OR
53748: IFFALSE 53762
// begin ct := k ;
53750: LD_ADDR_VAR 0 8
53754: PUSH
53755: LD_VAR 0 4
53759: ST_TO_ADDR
// break ;
53760: GO 53764
// end ;
53762: GO 53690
53764: POP
53765: POP
// if ct then
53766: LD_VAR 0 8
53770: IFFALSE 53786
// ComEnterUnit ( j , ct ) ;
53772: LD_VAR 0 3
53776: PPUSH
53777: LD_VAR 0 8
53781: PPUSH
53782: CALL_OW 120
// end ; end ;
53786: GO 53539
53788: POP
53789: POP
// places := 0 ;
53790: LD_ADDR_VAR 0 5
53794: PUSH
53795: LD_INT 0
53797: ST_TO_ADDR
// for j = 1 to x do
53798: LD_ADDR_VAR 0 3
53802: PUSH
53803: DOUBLE
53804: LD_INT 1
53806: DEC
53807: ST_TO_ADDR
53808: LD_VAR 0 11
53812: PUSH
53813: FOR_TO
53814: IFFALSE 53869
// if GetWeapon ( x [ j ] ) = ar_control_tower then
53816: LD_VAR 0 11
53820: PUSH
53821: LD_VAR 0 3
53825: ARRAY
53826: PPUSH
53827: CALL_OW 264
53831: PUSH
53832: LD_INT 31
53834: EQUAL
53835: IFFALSE 53853
// places := places + 1 else
53837: LD_ADDR_VAR 0 5
53841: PUSH
53842: LD_VAR 0 5
53846: PUSH
53847: LD_INT 1
53849: PLUS
53850: ST_TO_ADDR
53851: GO 53867
// places := places + 3 ;
53853: LD_ADDR_VAR 0 5
53857: PUSH
53858: LD_VAR 0 5
53862: PUSH
53863: LD_INT 3
53865: PLUS
53866: ST_TO_ADDR
53867: GO 53813
53869: POP
53870: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
53871: LD_ADDR_VAR 0 6
53875: PUSH
53876: LD_EXP 99
53880: PUSH
53881: LD_VAR 0 2
53885: ARRAY
53886: PPUSH
53887: LD_INT 25
53889: PUSH
53890: LD_INT 3
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: PPUSH
53897: CALL_OW 72
53901: PUSH
53902: LD_EXP 139
53906: PUSH
53907: LD_VAR 0 2
53911: ARRAY
53912: DIFF
53913: PPUSH
53914: LD_INT 3
53916: PPUSH
53917: CALL 102504 0 2
53921: ST_TO_ADDR
// if not tmp then
53922: LD_VAR 0 6
53926: NOT
53927: IFFALSE 53931
// continue ;
53929: GO 53311
// places := places - mc_remote_driver [ i ] ;
53931: LD_ADDR_VAR 0 5
53935: PUSH
53936: LD_VAR 0 5
53940: PUSH
53941: LD_EXP 139
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: MINUS
53952: ST_TO_ADDR
// if places then
53953: LD_VAR 0 5
53957: IFFALSE 54016
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
53959: LD_ADDR_EXP 139
53963: PUSH
53964: LD_EXP 139
53968: PPUSH
53969: LD_VAR 0 2
53973: PPUSH
53974: LD_EXP 139
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PUSH
53985: LD_VAR 0 6
53989: PUSH
53990: LD_INT 1
53992: ARRAY
53993: UNION
53994: PPUSH
53995: CALL_OW 1
53999: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
54000: LD_VAR 0 6
54004: PUSH
54005: LD_INT 1
54007: ARRAY
54008: PPUSH
54009: LD_INT 126
54011: PPUSH
54012: CALL_OW 109
// end ; end ;
54016: GO 53311
54018: POP
54019: POP
// end ;
54020: LD_VAR 0 1
54024: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
54025: LD_INT 0
54027: PPUSH
54028: PPUSH
54029: PPUSH
54030: PPUSH
54031: PPUSH
54032: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
54033: LD_VAR 0 1
54037: NOT
54038: PUSH
54039: LD_VAR 0 2
54043: NOT
54044: OR
54045: PUSH
54046: LD_VAR 0 3
54050: NOT
54051: OR
54052: PUSH
54053: LD_VAR 0 4
54057: PUSH
54058: LD_INT 1
54060: PUSH
54061: LD_INT 2
54063: PUSH
54064: LD_INT 3
54066: PUSH
54067: LD_INT 4
54069: PUSH
54070: LD_INT 5
54072: PUSH
54073: LD_INT 8
54075: PUSH
54076: LD_INT 9
54078: PUSH
54079: LD_INT 15
54081: PUSH
54082: LD_INT 16
54084: PUSH
54085: EMPTY
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: IN
54096: NOT
54097: OR
54098: IFFALSE 54102
// exit ;
54100: GO 55002
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
54102: LD_ADDR_VAR 0 2
54106: PUSH
54107: LD_VAR 0 2
54111: PPUSH
54112: LD_INT 21
54114: PUSH
54115: LD_INT 3
54117: PUSH
54118: EMPTY
54119: LIST
54120: LIST
54121: PUSH
54122: LD_INT 24
54124: PUSH
54125: LD_INT 250
54127: PUSH
54128: EMPTY
54129: LIST
54130: LIST
54131: PUSH
54132: EMPTY
54133: LIST
54134: LIST
54135: PPUSH
54136: CALL_OW 72
54140: ST_TO_ADDR
// case class of 1 , 15 :
54141: LD_VAR 0 4
54145: PUSH
54146: LD_INT 1
54148: DOUBLE
54149: EQUAL
54150: IFTRUE 54160
54152: LD_INT 15
54154: DOUBLE
54155: EQUAL
54156: IFTRUE 54160
54158: GO 54245
54160: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
54161: LD_ADDR_VAR 0 8
54165: PUSH
54166: LD_VAR 0 2
54170: PPUSH
54171: LD_INT 2
54173: PUSH
54174: LD_INT 30
54176: PUSH
54177: LD_INT 32
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: PUSH
54184: LD_INT 30
54186: PUSH
54187: LD_INT 31
54189: PUSH
54190: EMPTY
54191: LIST
54192: LIST
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: LIST
54198: PPUSH
54199: CALL_OW 72
54203: PUSH
54204: LD_VAR 0 2
54208: PPUSH
54209: LD_INT 2
54211: PUSH
54212: LD_INT 30
54214: PUSH
54215: LD_INT 4
54217: PUSH
54218: EMPTY
54219: LIST
54220: LIST
54221: PUSH
54222: LD_INT 30
54224: PUSH
54225: LD_INT 5
54227: PUSH
54228: EMPTY
54229: LIST
54230: LIST
54231: PUSH
54232: EMPTY
54233: LIST
54234: LIST
54235: LIST
54236: PPUSH
54237: CALL_OW 72
54241: ADD
54242: ST_TO_ADDR
54243: GO 54491
54245: LD_INT 2
54247: DOUBLE
54248: EQUAL
54249: IFTRUE 54259
54251: LD_INT 16
54253: DOUBLE
54254: EQUAL
54255: IFTRUE 54259
54257: GO 54305
54259: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
54260: LD_ADDR_VAR 0 8
54264: PUSH
54265: LD_VAR 0 2
54269: PPUSH
54270: LD_INT 2
54272: PUSH
54273: LD_INT 30
54275: PUSH
54276: LD_INT 0
54278: PUSH
54279: EMPTY
54280: LIST
54281: LIST
54282: PUSH
54283: LD_INT 30
54285: PUSH
54286: LD_INT 1
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: PUSH
54293: EMPTY
54294: LIST
54295: LIST
54296: LIST
54297: PPUSH
54298: CALL_OW 72
54302: ST_TO_ADDR
54303: GO 54491
54305: LD_INT 3
54307: DOUBLE
54308: EQUAL
54309: IFTRUE 54313
54311: GO 54359
54313: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
54314: LD_ADDR_VAR 0 8
54318: PUSH
54319: LD_VAR 0 2
54323: PPUSH
54324: LD_INT 2
54326: PUSH
54327: LD_INT 30
54329: PUSH
54330: LD_INT 2
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: PUSH
54337: LD_INT 30
54339: PUSH
54340: LD_INT 3
54342: PUSH
54343: EMPTY
54344: LIST
54345: LIST
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: LIST
54351: PPUSH
54352: CALL_OW 72
54356: ST_TO_ADDR
54357: GO 54491
54359: LD_INT 4
54361: DOUBLE
54362: EQUAL
54363: IFTRUE 54367
54365: GO 54424
54367: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
54368: LD_ADDR_VAR 0 8
54372: PUSH
54373: LD_VAR 0 2
54377: PPUSH
54378: LD_INT 2
54380: PUSH
54381: LD_INT 30
54383: PUSH
54384: LD_INT 6
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: PUSH
54391: LD_INT 30
54393: PUSH
54394: LD_INT 7
54396: PUSH
54397: EMPTY
54398: LIST
54399: LIST
54400: PUSH
54401: LD_INT 30
54403: PUSH
54404: LD_INT 8
54406: PUSH
54407: EMPTY
54408: LIST
54409: LIST
54410: PUSH
54411: EMPTY
54412: LIST
54413: LIST
54414: LIST
54415: LIST
54416: PPUSH
54417: CALL_OW 72
54421: ST_TO_ADDR
54422: GO 54491
54424: LD_INT 5
54426: DOUBLE
54427: EQUAL
54428: IFTRUE 54444
54430: LD_INT 8
54432: DOUBLE
54433: EQUAL
54434: IFTRUE 54444
54436: LD_INT 9
54438: DOUBLE
54439: EQUAL
54440: IFTRUE 54444
54442: GO 54490
54444: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
54445: LD_ADDR_VAR 0 8
54449: PUSH
54450: LD_VAR 0 2
54454: PPUSH
54455: LD_INT 2
54457: PUSH
54458: LD_INT 30
54460: PUSH
54461: LD_INT 4
54463: PUSH
54464: EMPTY
54465: LIST
54466: LIST
54467: PUSH
54468: LD_INT 30
54470: PUSH
54471: LD_INT 5
54473: PUSH
54474: EMPTY
54475: LIST
54476: LIST
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: LIST
54482: PPUSH
54483: CALL_OW 72
54487: ST_TO_ADDR
54488: GO 54491
54490: POP
// if not tmp then
54491: LD_VAR 0 8
54495: NOT
54496: IFFALSE 54500
// exit ;
54498: GO 55002
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
54500: LD_VAR 0 4
54504: PUSH
54505: LD_INT 1
54507: PUSH
54508: LD_INT 15
54510: PUSH
54511: EMPTY
54512: LIST
54513: LIST
54514: IN
54515: PUSH
54516: LD_EXP 108
54520: PUSH
54521: LD_VAR 0 1
54525: ARRAY
54526: AND
54527: IFFALSE 54683
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
54529: LD_ADDR_VAR 0 9
54533: PUSH
54534: LD_EXP 108
54538: PUSH
54539: LD_VAR 0 1
54543: ARRAY
54544: PUSH
54545: LD_INT 1
54547: ARRAY
54548: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
54549: LD_VAR 0 9
54553: PUSH
54554: LD_EXP 109
54558: PUSH
54559: LD_VAR 0 1
54563: ARRAY
54564: IN
54565: NOT
54566: IFFALSE 54681
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
54568: LD_ADDR_EXP 109
54572: PUSH
54573: LD_EXP 109
54577: PPUSH
54578: LD_VAR 0 1
54582: PUSH
54583: LD_EXP 109
54587: PUSH
54588: LD_VAR 0 1
54592: ARRAY
54593: PUSH
54594: LD_INT 1
54596: PLUS
54597: PUSH
54598: EMPTY
54599: LIST
54600: LIST
54601: PPUSH
54602: LD_VAR 0 9
54606: PPUSH
54607: CALL 68319 0 3
54611: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
54612: LD_ADDR_EXP 108
54616: PUSH
54617: LD_EXP 108
54621: PPUSH
54622: LD_VAR 0 1
54626: PPUSH
54627: LD_EXP 108
54631: PUSH
54632: LD_VAR 0 1
54636: ARRAY
54637: PUSH
54638: LD_VAR 0 9
54642: DIFF
54643: PPUSH
54644: CALL_OW 1
54648: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
54649: LD_VAR 0 3
54653: PPUSH
54654: LD_EXP 109
54658: PUSH
54659: LD_VAR 0 1
54663: ARRAY
54664: PUSH
54665: LD_EXP 109
54669: PUSH
54670: LD_VAR 0 1
54674: ARRAY
54675: ARRAY
54676: PPUSH
54677: CALL_OW 120
// end ; exit ;
54681: GO 55002
// end ; if tmp > 1 then
54683: LD_VAR 0 8
54687: PUSH
54688: LD_INT 1
54690: GREATER
54691: IFFALSE 54795
// for i = 2 to tmp do
54693: LD_ADDR_VAR 0 6
54697: PUSH
54698: DOUBLE
54699: LD_INT 2
54701: DEC
54702: ST_TO_ADDR
54703: LD_VAR 0 8
54707: PUSH
54708: FOR_TO
54709: IFFALSE 54793
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
54711: LD_VAR 0 8
54715: PUSH
54716: LD_VAR 0 6
54720: ARRAY
54721: PPUSH
54722: CALL_OW 461
54726: PUSH
54727: LD_INT 6
54729: EQUAL
54730: IFFALSE 54791
// begin x := tmp [ i ] ;
54732: LD_ADDR_VAR 0 9
54736: PUSH
54737: LD_VAR 0 8
54741: PUSH
54742: LD_VAR 0 6
54746: ARRAY
54747: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
54748: LD_ADDR_VAR 0 8
54752: PUSH
54753: LD_VAR 0 8
54757: PPUSH
54758: LD_VAR 0 6
54762: PPUSH
54763: CALL_OW 3
54767: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
54768: LD_ADDR_VAR 0 8
54772: PUSH
54773: LD_VAR 0 8
54777: PPUSH
54778: LD_INT 1
54780: PPUSH
54781: LD_VAR 0 9
54785: PPUSH
54786: CALL_OW 2
54790: ST_TO_ADDR
// end ;
54791: GO 54708
54793: POP
54794: POP
// for i in tmp do
54795: LD_ADDR_VAR 0 6
54799: PUSH
54800: LD_VAR 0 8
54804: PUSH
54805: FOR_IN
54806: IFFALSE 54875
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
54808: LD_VAR 0 6
54812: PPUSH
54813: CALL_OW 313
54817: PUSH
54818: LD_INT 6
54820: LESS
54821: PUSH
54822: LD_VAR 0 6
54826: PPUSH
54827: CALL_OW 266
54831: PUSH
54832: LD_INT 31
54834: PUSH
54835: LD_INT 32
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: IN
54842: NOT
54843: AND
54844: PUSH
54845: LD_VAR 0 6
54849: PPUSH
54850: CALL_OW 313
54854: PUSH
54855: LD_INT 0
54857: EQUAL
54858: OR
54859: IFFALSE 54873
// begin j := i ;
54861: LD_ADDR_VAR 0 7
54865: PUSH
54866: LD_VAR 0 6
54870: ST_TO_ADDR
// break ;
54871: GO 54875
// end ; end ;
54873: GO 54805
54875: POP
54876: POP
// if j then
54877: LD_VAR 0 7
54881: IFFALSE 54899
// ComEnterUnit ( unit , j ) else
54883: LD_VAR 0 3
54887: PPUSH
54888: LD_VAR 0 7
54892: PPUSH
54893: CALL_OW 120
54897: GO 55002
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54899: LD_ADDR_VAR 0 10
54903: PUSH
54904: LD_VAR 0 2
54908: PPUSH
54909: LD_INT 2
54911: PUSH
54912: LD_INT 30
54914: PUSH
54915: LD_INT 0
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: PUSH
54922: LD_INT 30
54924: PUSH
54925: LD_INT 1
54927: PUSH
54928: EMPTY
54929: LIST
54930: LIST
54931: PUSH
54932: EMPTY
54933: LIST
54934: LIST
54935: LIST
54936: PPUSH
54937: CALL_OW 72
54941: ST_TO_ADDR
// if depot then
54942: LD_VAR 0 10
54946: IFFALSE 55002
// begin depot := NearestUnitToUnit ( depot , unit ) ;
54948: LD_ADDR_VAR 0 10
54952: PUSH
54953: LD_VAR 0 10
54957: PPUSH
54958: LD_VAR 0 3
54962: PPUSH
54963: CALL_OW 74
54967: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
54968: LD_VAR 0 3
54972: PPUSH
54973: LD_VAR 0 10
54977: PPUSH
54978: CALL_OW 296
54982: PUSH
54983: LD_INT 10
54985: GREATER
54986: IFFALSE 55002
// ComStandNearbyBuilding ( unit , depot ) ;
54988: LD_VAR 0 3
54992: PPUSH
54993: LD_VAR 0 10
54997: PPUSH
54998: CALL 62996 0 2
// end ; end ; end ;
55002: LD_VAR 0 5
55006: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
55007: LD_INT 0
55009: PPUSH
55010: PPUSH
55011: PPUSH
55012: PPUSH
// if not mc_bases then
55013: LD_EXP 99
55017: NOT
55018: IFFALSE 55022
// exit ;
55020: GO 55261
// for i = 1 to mc_bases do
55022: LD_ADDR_VAR 0 2
55026: PUSH
55027: DOUBLE
55028: LD_INT 1
55030: DEC
55031: ST_TO_ADDR
55032: LD_EXP 99
55036: PUSH
55037: FOR_TO
55038: IFFALSE 55259
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
55040: LD_ADDR_VAR 0 4
55044: PUSH
55045: LD_EXP 99
55049: PUSH
55050: LD_VAR 0 2
55054: ARRAY
55055: PPUSH
55056: LD_INT 21
55058: PUSH
55059: LD_INT 1
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: PPUSH
55066: CALL_OW 72
55070: PUSH
55071: LD_EXP 128
55075: PUSH
55076: LD_VAR 0 2
55080: ARRAY
55081: UNION
55082: ST_TO_ADDR
// if not tmp then
55083: LD_VAR 0 4
55087: NOT
55088: IFFALSE 55092
// continue ;
55090: GO 55037
// for j in tmp do
55092: LD_ADDR_VAR 0 3
55096: PUSH
55097: LD_VAR 0 4
55101: PUSH
55102: FOR_IN
55103: IFFALSE 55255
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
55105: LD_VAR 0 3
55109: PPUSH
55110: CALL_OW 110
55114: NOT
55115: PUSH
55116: LD_VAR 0 3
55120: PPUSH
55121: CALL_OW 314
55125: NOT
55126: AND
55127: PUSH
55128: LD_VAR 0 3
55132: PPUSH
55133: CALL_OW 311
55137: NOT
55138: AND
55139: PUSH
55140: LD_VAR 0 3
55144: PPUSH
55145: CALL_OW 310
55149: NOT
55150: AND
55151: PUSH
55152: LD_VAR 0 3
55156: PUSH
55157: LD_EXP 102
55161: PUSH
55162: LD_VAR 0 2
55166: ARRAY
55167: PUSH
55168: LD_INT 1
55170: ARRAY
55171: IN
55172: NOT
55173: AND
55174: PUSH
55175: LD_VAR 0 3
55179: PUSH
55180: LD_EXP 102
55184: PUSH
55185: LD_VAR 0 2
55189: ARRAY
55190: PUSH
55191: LD_INT 2
55193: ARRAY
55194: IN
55195: NOT
55196: AND
55197: PUSH
55198: LD_VAR 0 3
55202: PUSH
55203: LD_EXP 111
55207: PUSH
55208: LD_VAR 0 2
55212: ARRAY
55213: IN
55214: NOT
55215: AND
55216: IFFALSE 55253
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
55218: LD_VAR 0 2
55222: PPUSH
55223: LD_EXP 99
55227: PUSH
55228: LD_VAR 0 2
55232: ARRAY
55233: PPUSH
55234: LD_VAR 0 3
55238: PPUSH
55239: LD_VAR 0 3
55243: PPUSH
55244: CALL_OW 257
55248: PPUSH
55249: CALL 54025 0 4
// end ;
55253: GO 55102
55255: POP
55256: POP
// end ;
55257: GO 55037
55259: POP
55260: POP
// end ;
55261: LD_VAR 0 1
55265: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
55266: LD_INT 0
55268: PPUSH
55269: PPUSH
55270: PPUSH
55271: PPUSH
55272: PPUSH
55273: PPUSH
// if not mc_bases [ base ] then
55274: LD_EXP 99
55278: PUSH
55279: LD_VAR 0 1
55283: ARRAY
55284: NOT
55285: IFFALSE 55289
// exit ;
55287: GO 55471
// tmp := [ ] ;
55289: LD_ADDR_VAR 0 6
55293: PUSH
55294: EMPTY
55295: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
55296: LD_ADDR_VAR 0 7
55300: PUSH
55301: LD_VAR 0 3
55305: PPUSH
55306: LD_INT 0
55308: PPUSH
55309: CALL_OW 517
55313: ST_TO_ADDR
// if not list then
55314: LD_VAR 0 7
55318: NOT
55319: IFFALSE 55323
// exit ;
55321: GO 55471
// for i = 1 to amount do
55323: LD_ADDR_VAR 0 5
55327: PUSH
55328: DOUBLE
55329: LD_INT 1
55331: DEC
55332: ST_TO_ADDR
55333: LD_VAR 0 2
55337: PUSH
55338: FOR_TO
55339: IFFALSE 55419
// begin x := rand ( 1 , list [ 1 ] ) ;
55341: LD_ADDR_VAR 0 8
55345: PUSH
55346: LD_INT 1
55348: PPUSH
55349: LD_VAR 0 7
55353: PUSH
55354: LD_INT 1
55356: ARRAY
55357: PPUSH
55358: CALL_OW 12
55362: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
55363: LD_ADDR_VAR 0 6
55367: PUSH
55368: LD_VAR 0 6
55372: PPUSH
55373: LD_VAR 0 5
55377: PPUSH
55378: LD_VAR 0 7
55382: PUSH
55383: LD_INT 1
55385: ARRAY
55386: PUSH
55387: LD_VAR 0 8
55391: ARRAY
55392: PUSH
55393: LD_VAR 0 7
55397: PUSH
55398: LD_INT 2
55400: ARRAY
55401: PUSH
55402: LD_VAR 0 8
55406: ARRAY
55407: PUSH
55408: EMPTY
55409: LIST
55410: LIST
55411: PPUSH
55412: CALL_OW 1
55416: ST_TO_ADDR
// end ;
55417: GO 55338
55419: POP
55420: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
55421: LD_ADDR_EXP 112
55425: PUSH
55426: LD_EXP 112
55430: PPUSH
55431: LD_VAR 0 1
55435: PPUSH
55436: LD_VAR 0 6
55440: PPUSH
55441: CALL_OW 1
55445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
55446: LD_ADDR_EXP 114
55450: PUSH
55451: LD_EXP 114
55455: PPUSH
55456: LD_VAR 0 1
55460: PPUSH
55461: LD_VAR 0 3
55465: PPUSH
55466: CALL_OW 1
55470: ST_TO_ADDR
// end ;
55471: LD_VAR 0 4
55475: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
55476: LD_INT 0
55478: PPUSH
// if not mc_bases [ base ] then
55479: LD_EXP 99
55483: PUSH
55484: LD_VAR 0 1
55488: ARRAY
55489: NOT
55490: IFFALSE 55494
// exit ;
55492: GO 55519
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
55494: LD_ADDR_EXP 104
55498: PUSH
55499: LD_EXP 104
55503: PPUSH
55504: LD_VAR 0 1
55508: PPUSH
55509: LD_VAR 0 2
55513: PPUSH
55514: CALL_OW 1
55518: ST_TO_ADDR
// end ;
55519: LD_VAR 0 3
55523: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
55524: LD_INT 0
55526: PPUSH
// if not mc_bases [ base ] then
55527: LD_EXP 99
55531: PUSH
55532: LD_VAR 0 1
55536: ARRAY
55537: NOT
55538: IFFALSE 55542
// exit ;
55540: GO 55579
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
55542: LD_ADDR_EXP 104
55546: PUSH
55547: LD_EXP 104
55551: PPUSH
55552: LD_VAR 0 1
55556: PPUSH
55557: LD_EXP 104
55561: PUSH
55562: LD_VAR 0 1
55566: ARRAY
55567: PUSH
55568: LD_VAR 0 2
55572: UNION
55573: PPUSH
55574: CALL_OW 1
55578: ST_TO_ADDR
// end ;
55579: LD_VAR 0 3
55583: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
55584: LD_INT 0
55586: PPUSH
// if not mc_bases [ base ] then
55587: LD_EXP 99
55591: PUSH
55592: LD_VAR 0 1
55596: ARRAY
55597: NOT
55598: IFFALSE 55602
// exit ;
55600: GO 55627
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
55602: LD_ADDR_EXP 120
55606: PUSH
55607: LD_EXP 120
55611: PPUSH
55612: LD_VAR 0 1
55616: PPUSH
55617: LD_VAR 0 2
55621: PPUSH
55622: CALL_OW 1
55626: ST_TO_ADDR
// end ;
55627: LD_VAR 0 3
55631: RET
// export function MC_InsertProduceList ( base , components ) ; begin
55632: LD_INT 0
55634: PPUSH
// if not mc_bases [ base ] then
55635: LD_EXP 99
55639: PUSH
55640: LD_VAR 0 1
55644: ARRAY
55645: NOT
55646: IFFALSE 55650
// exit ;
55648: GO 55687
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
55650: LD_ADDR_EXP 120
55654: PUSH
55655: LD_EXP 120
55659: PPUSH
55660: LD_VAR 0 1
55664: PPUSH
55665: LD_EXP 120
55669: PUSH
55670: LD_VAR 0 1
55674: ARRAY
55675: PUSH
55676: LD_VAR 0 2
55680: ADD
55681: PPUSH
55682: CALL_OW 1
55686: ST_TO_ADDR
// end ;
55687: LD_VAR 0 3
55691: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
55692: LD_INT 0
55694: PPUSH
// if not mc_bases [ base ] then
55695: LD_EXP 99
55699: PUSH
55700: LD_VAR 0 1
55704: ARRAY
55705: NOT
55706: IFFALSE 55710
// exit ;
55708: GO 55764
// mc_defender := Replace ( mc_defender , base , deflist ) ;
55710: LD_ADDR_EXP 121
55714: PUSH
55715: LD_EXP 121
55719: PPUSH
55720: LD_VAR 0 1
55724: PPUSH
55725: LD_VAR 0 2
55729: PPUSH
55730: CALL_OW 1
55734: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
55735: LD_ADDR_EXP 110
55739: PUSH
55740: LD_EXP 110
55744: PPUSH
55745: LD_VAR 0 1
55749: PPUSH
55750: LD_VAR 0 2
55754: PUSH
55755: LD_INT 0
55757: PLUS
55758: PPUSH
55759: CALL_OW 1
55763: ST_TO_ADDR
// end ;
55764: LD_VAR 0 3
55768: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
55769: LD_INT 0
55771: PPUSH
// if not mc_bases [ base ] then
55772: LD_EXP 99
55776: PUSH
55777: LD_VAR 0 1
55781: ARRAY
55782: NOT
55783: IFFALSE 55787
// exit ;
55785: GO 55812
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
55787: LD_ADDR_EXP 110
55791: PUSH
55792: LD_EXP 110
55796: PPUSH
55797: LD_VAR 0 1
55801: PPUSH
55802: LD_VAR 0 2
55806: PPUSH
55807: CALL_OW 1
55811: ST_TO_ADDR
// end ;
55812: LD_VAR 0 3
55816: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
55817: LD_INT 0
55819: PPUSH
55820: PPUSH
55821: PPUSH
55822: PPUSH
// if not mc_bases [ base ] then
55823: LD_EXP 99
55827: PUSH
55828: LD_VAR 0 1
55832: ARRAY
55833: NOT
55834: IFFALSE 55838
// exit ;
55836: GO 55903
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
55838: LD_ADDR_EXP 119
55842: PUSH
55843: LD_EXP 119
55847: PPUSH
55848: LD_VAR 0 1
55852: PUSH
55853: LD_EXP 119
55857: PUSH
55858: LD_VAR 0 1
55862: ARRAY
55863: PUSH
55864: LD_INT 1
55866: PLUS
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: PPUSH
55872: LD_VAR 0 1
55876: PUSH
55877: LD_VAR 0 2
55881: PUSH
55882: LD_VAR 0 3
55886: PUSH
55887: LD_VAR 0 4
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: PPUSH
55898: CALL 68319 0 3
55902: ST_TO_ADDR
// end ;
55903: LD_VAR 0 5
55907: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
55908: LD_INT 0
55910: PPUSH
// if not mc_bases [ base ] then
55911: LD_EXP 99
55915: PUSH
55916: LD_VAR 0 1
55920: ARRAY
55921: NOT
55922: IFFALSE 55926
// exit ;
55924: GO 55951
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
55926: LD_ADDR_EXP 136
55930: PUSH
55931: LD_EXP 136
55935: PPUSH
55936: LD_VAR 0 1
55940: PPUSH
55941: LD_VAR 0 2
55945: PPUSH
55946: CALL_OW 1
55950: ST_TO_ADDR
// end ;
55951: LD_VAR 0 3
55955: RET
// export function MC_GetMinesField ( base ) ; begin
55956: LD_INT 0
55958: PPUSH
// result := mc_mines [ base ] ;
55959: LD_ADDR_VAR 0 2
55963: PUSH
55964: LD_EXP 112
55968: PUSH
55969: LD_VAR 0 1
55973: ARRAY
55974: ST_TO_ADDR
// end ;
55975: LD_VAR 0 2
55979: RET
// export function MC_GetProduceList ( base ) ; begin
55980: LD_INT 0
55982: PPUSH
// result := mc_produce [ base ] ;
55983: LD_ADDR_VAR 0 2
55987: PUSH
55988: LD_EXP 120
55992: PUSH
55993: LD_VAR 0 1
55997: ARRAY
55998: ST_TO_ADDR
// end ;
55999: LD_VAR 0 2
56003: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
56004: LD_INT 0
56006: PPUSH
56007: PPUSH
// if not mc_bases then
56008: LD_EXP 99
56012: NOT
56013: IFFALSE 56017
// exit ;
56015: GO 56082
// if mc_bases [ base ] then
56017: LD_EXP 99
56021: PUSH
56022: LD_VAR 0 1
56026: ARRAY
56027: IFFALSE 56082
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
56029: LD_ADDR_VAR 0 3
56033: PUSH
56034: LD_EXP 99
56038: PUSH
56039: LD_VAR 0 1
56043: ARRAY
56044: PPUSH
56045: LD_INT 30
56047: PUSH
56048: LD_VAR 0 2
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: PPUSH
56057: CALL_OW 72
56061: ST_TO_ADDR
// if result then
56062: LD_VAR 0 3
56066: IFFALSE 56082
// result := result [ 1 ] ;
56068: LD_ADDR_VAR 0 3
56072: PUSH
56073: LD_VAR 0 3
56077: PUSH
56078: LD_INT 1
56080: ARRAY
56081: ST_TO_ADDR
// end ; end ;
56082: LD_VAR 0 3
56086: RET
// export function MC_SetTame ( base , area ) ; begin
56087: LD_INT 0
56089: PPUSH
// if not mc_bases or not base then
56090: LD_EXP 99
56094: NOT
56095: PUSH
56096: LD_VAR 0 1
56100: NOT
56101: OR
56102: IFFALSE 56106
// exit ;
56104: GO 56131
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
56106: LD_ADDR_EXP 127
56110: PUSH
56111: LD_EXP 127
56115: PPUSH
56116: LD_VAR 0 1
56120: PPUSH
56121: LD_VAR 0 2
56125: PPUSH
56126: CALL_OW 1
56130: ST_TO_ADDR
// end ;
56131: LD_VAR 0 3
56135: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
56136: LD_INT 0
56138: PPUSH
56139: PPUSH
// if not mc_bases or not base then
56140: LD_EXP 99
56144: NOT
56145: PUSH
56146: LD_VAR 0 1
56150: NOT
56151: OR
56152: IFFALSE 56156
// exit ;
56154: GO 56258
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
56156: LD_ADDR_VAR 0 4
56160: PUSH
56161: LD_EXP 99
56165: PUSH
56166: LD_VAR 0 1
56170: ARRAY
56171: PPUSH
56172: LD_INT 30
56174: PUSH
56175: LD_VAR 0 2
56179: PUSH
56180: EMPTY
56181: LIST
56182: LIST
56183: PPUSH
56184: CALL_OW 72
56188: ST_TO_ADDR
// if not tmp then
56189: LD_VAR 0 4
56193: NOT
56194: IFFALSE 56198
// exit ;
56196: GO 56258
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
56198: LD_ADDR_EXP 131
56202: PUSH
56203: LD_EXP 131
56207: PPUSH
56208: LD_VAR 0 1
56212: PPUSH
56213: LD_EXP 131
56217: PUSH
56218: LD_VAR 0 1
56222: ARRAY
56223: PPUSH
56224: LD_EXP 131
56228: PUSH
56229: LD_VAR 0 1
56233: ARRAY
56234: PUSH
56235: LD_INT 1
56237: PLUS
56238: PPUSH
56239: LD_VAR 0 4
56243: PUSH
56244: LD_INT 1
56246: ARRAY
56247: PPUSH
56248: CALL_OW 2
56252: PPUSH
56253: CALL_OW 1
56257: ST_TO_ADDR
// end ;
56258: LD_VAR 0 3
56262: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
56263: LD_INT 0
56265: PPUSH
56266: PPUSH
// if not mc_bases or not base or not kinds then
56267: LD_EXP 99
56271: NOT
56272: PUSH
56273: LD_VAR 0 1
56277: NOT
56278: OR
56279: PUSH
56280: LD_VAR 0 2
56284: NOT
56285: OR
56286: IFFALSE 56290
// exit ;
56288: GO 56351
// for i in kinds do
56290: LD_ADDR_VAR 0 4
56294: PUSH
56295: LD_VAR 0 2
56299: PUSH
56300: FOR_IN
56301: IFFALSE 56349
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
56303: LD_ADDR_EXP 133
56307: PUSH
56308: LD_EXP 133
56312: PPUSH
56313: LD_VAR 0 1
56317: PUSH
56318: LD_EXP 133
56322: PUSH
56323: LD_VAR 0 1
56327: ARRAY
56328: PUSH
56329: LD_INT 1
56331: PLUS
56332: PUSH
56333: EMPTY
56334: LIST
56335: LIST
56336: PPUSH
56337: LD_VAR 0 4
56341: PPUSH
56342: CALL 68319 0 3
56346: ST_TO_ADDR
56347: GO 56300
56349: POP
56350: POP
// end ;
56351: LD_VAR 0 3
56355: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
56356: LD_INT 0
56358: PPUSH
// if not mc_bases or not base or not areas then
56359: LD_EXP 99
56363: NOT
56364: PUSH
56365: LD_VAR 0 1
56369: NOT
56370: OR
56371: PUSH
56372: LD_VAR 0 2
56376: NOT
56377: OR
56378: IFFALSE 56382
// exit ;
56380: GO 56407
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
56382: LD_ADDR_EXP 117
56386: PUSH
56387: LD_EXP 117
56391: PPUSH
56392: LD_VAR 0 1
56396: PPUSH
56397: LD_VAR 0 2
56401: PPUSH
56402: CALL_OW 1
56406: ST_TO_ADDR
// end ;
56407: LD_VAR 0 3
56411: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
56412: LD_INT 0
56414: PPUSH
// if not mc_bases or not base or not teleports_exit then
56415: LD_EXP 99
56419: NOT
56420: PUSH
56421: LD_VAR 0 1
56425: NOT
56426: OR
56427: PUSH
56428: LD_VAR 0 2
56432: NOT
56433: OR
56434: IFFALSE 56438
// exit ;
56436: GO 56463
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
56438: LD_ADDR_EXP 134
56442: PUSH
56443: LD_EXP 134
56447: PPUSH
56448: LD_VAR 0 1
56452: PPUSH
56453: LD_VAR 0 2
56457: PPUSH
56458: CALL_OW 1
56462: ST_TO_ADDR
// end ;
56463: LD_VAR 0 3
56467: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
56468: LD_INT 0
56470: PPUSH
56471: PPUSH
56472: PPUSH
// if not mc_bases or not base or not ext_list then
56473: LD_EXP 99
56477: NOT
56478: PUSH
56479: LD_VAR 0 1
56483: NOT
56484: OR
56485: PUSH
56486: LD_VAR 0 5
56490: NOT
56491: OR
56492: IFFALSE 56496
// exit ;
56494: GO 56669
// tmp := GetFacExtXYD ( x , y , d ) ;
56496: LD_ADDR_VAR 0 8
56500: PUSH
56501: LD_VAR 0 2
56505: PPUSH
56506: LD_VAR 0 3
56510: PPUSH
56511: LD_VAR 0 4
56515: PPUSH
56516: CALL 101634 0 3
56520: ST_TO_ADDR
// if not tmp then
56521: LD_VAR 0 8
56525: NOT
56526: IFFALSE 56530
// exit ;
56528: GO 56669
// for i in tmp do
56530: LD_ADDR_VAR 0 7
56534: PUSH
56535: LD_VAR 0 8
56539: PUSH
56540: FOR_IN
56541: IFFALSE 56667
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
56543: LD_ADDR_EXP 104
56547: PUSH
56548: LD_EXP 104
56552: PPUSH
56553: LD_VAR 0 1
56557: PPUSH
56558: LD_EXP 104
56562: PUSH
56563: LD_VAR 0 1
56567: ARRAY
56568: PPUSH
56569: LD_EXP 104
56573: PUSH
56574: LD_VAR 0 1
56578: ARRAY
56579: PUSH
56580: LD_INT 1
56582: PLUS
56583: PPUSH
56584: LD_VAR 0 5
56588: PUSH
56589: LD_INT 1
56591: ARRAY
56592: PUSH
56593: LD_VAR 0 7
56597: PUSH
56598: LD_INT 1
56600: ARRAY
56601: PUSH
56602: LD_VAR 0 7
56606: PUSH
56607: LD_INT 2
56609: ARRAY
56610: PUSH
56611: LD_VAR 0 7
56615: PUSH
56616: LD_INT 3
56618: ARRAY
56619: PUSH
56620: EMPTY
56621: LIST
56622: LIST
56623: LIST
56624: LIST
56625: PPUSH
56626: CALL_OW 2
56630: PPUSH
56631: CALL_OW 1
56635: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
56636: LD_ADDR_VAR 0 5
56640: PUSH
56641: LD_VAR 0 5
56645: PPUSH
56646: LD_INT 1
56648: PPUSH
56649: CALL_OW 3
56653: ST_TO_ADDR
// if not ext_list then
56654: LD_VAR 0 5
56658: NOT
56659: IFFALSE 56665
// exit ;
56661: POP
56662: POP
56663: GO 56669
// end ;
56665: GO 56540
56667: POP
56668: POP
// end ;
56669: LD_VAR 0 6
56673: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
56674: LD_INT 0
56676: PPUSH
// if not mc_bases or not base or not weapon_list then
56677: LD_EXP 99
56681: NOT
56682: PUSH
56683: LD_VAR 0 1
56687: NOT
56688: OR
56689: PUSH
56690: LD_VAR 0 2
56694: NOT
56695: OR
56696: IFFALSE 56700
// exit ;
56698: GO 56725
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
56700: LD_ADDR_EXP 138
56704: PUSH
56705: LD_EXP 138
56709: PPUSH
56710: LD_VAR 0 1
56714: PPUSH
56715: LD_VAR 0 2
56719: PPUSH
56720: CALL_OW 1
56724: ST_TO_ADDR
// end ;
56725: LD_VAR 0 3
56729: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
56730: LD_INT 0
56732: PPUSH
// if not mc_bases or not base or not tech_list then
56733: LD_EXP 99
56737: NOT
56738: PUSH
56739: LD_VAR 0 1
56743: NOT
56744: OR
56745: PUSH
56746: LD_VAR 0 2
56750: NOT
56751: OR
56752: IFFALSE 56756
// exit ;
56754: GO 56781
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
56756: LD_ADDR_EXP 126
56760: PUSH
56761: LD_EXP 126
56765: PPUSH
56766: LD_VAR 0 1
56770: PPUSH
56771: LD_VAR 0 2
56775: PPUSH
56776: CALL_OW 1
56780: ST_TO_ADDR
// end ;
56781: LD_VAR 0 3
56785: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
56786: LD_INT 0
56788: PPUSH
// if not mc_bases or not parking_area or not base then
56789: LD_EXP 99
56793: NOT
56794: PUSH
56795: LD_VAR 0 2
56799: NOT
56800: OR
56801: PUSH
56802: LD_VAR 0 1
56806: NOT
56807: OR
56808: IFFALSE 56812
// exit ;
56810: GO 56837
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
56812: LD_ADDR_EXP 123
56816: PUSH
56817: LD_EXP 123
56821: PPUSH
56822: LD_VAR 0 1
56826: PPUSH
56827: LD_VAR 0 2
56831: PPUSH
56832: CALL_OW 1
56836: ST_TO_ADDR
// end ;
56837: LD_VAR 0 3
56841: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
56842: LD_INT 0
56844: PPUSH
// if not mc_bases or not base or not scan_area then
56845: LD_EXP 99
56849: NOT
56850: PUSH
56851: LD_VAR 0 1
56855: NOT
56856: OR
56857: PUSH
56858: LD_VAR 0 2
56862: NOT
56863: OR
56864: IFFALSE 56868
// exit ;
56866: GO 56893
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
56868: LD_ADDR_EXP 124
56872: PUSH
56873: LD_EXP 124
56877: PPUSH
56878: LD_VAR 0 1
56882: PPUSH
56883: LD_VAR 0 2
56887: PPUSH
56888: CALL_OW 1
56892: ST_TO_ADDR
// end ;
56893: LD_VAR 0 3
56897: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
56898: LD_INT 0
56900: PPUSH
56901: PPUSH
// if not mc_bases or not base then
56902: LD_EXP 99
56906: NOT
56907: PUSH
56908: LD_VAR 0 1
56912: NOT
56913: OR
56914: IFFALSE 56918
// exit ;
56916: GO 56982
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
56918: LD_ADDR_VAR 0 3
56922: PUSH
56923: LD_INT 1
56925: PUSH
56926: LD_INT 2
56928: PUSH
56929: LD_INT 3
56931: PUSH
56932: LD_INT 4
56934: PUSH
56935: LD_INT 11
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: LIST
56942: LIST
56943: LIST
56944: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
56945: LD_ADDR_EXP 126
56949: PUSH
56950: LD_EXP 126
56954: PPUSH
56955: LD_VAR 0 1
56959: PPUSH
56960: LD_EXP 126
56964: PUSH
56965: LD_VAR 0 1
56969: ARRAY
56970: PUSH
56971: LD_VAR 0 3
56975: DIFF
56976: PPUSH
56977: CALL_OW 1
56981: ST_TO_ADDR
// end ;
56982: LD_VAR 0 2
56986: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
56987: LD_INT 0
56989: PPUSH
// result := mc_vehicles [ base ] ;
56990: LD_ADDR_VAR 0 3
56994: PUSH
56995: LD_EXP 118
56999: PUSH
57000: LD_VAR 0 1
57004: ARRAY
57005: ST_TO_ADDR
// if onlyCombat then
57006: LD_VAR 0 2
57010: IFFALSE 57175
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
57012: LD_ADDR_VAR 0 3
57016: PUSH
57017: LD_VAR 0 3
57021: PUSH
57022: LD_VAR 0 3
57026: PPUSH
57027: LD_INT 2
57029: PUSH
57030: LD_INT 34
57032: PUSH
57033: LD_INT 12
57035: PUSH
57036: EMPTY
57037: LIST
57038: LIST
57039: PUSH
57040: LD_INT 34
57042: PUSH
57043: LD_INT 51
57045: PUSH
57046: EMPTY
57047: LIST
57048: LIST
57049: PUSH
57050: LD_INT 34
57052: PUSH
57053: LD_EXP 93
57057: PUSH
57058: EMPTY
57059: LIST
57060: LIST
57061: PUSH
57062: LD_INT 34
57064: PUSH
57065: LD_INT 32
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: PUSH
57072: LD_INT 34
57074: PUSH
57075: LD_INT 13
57077: PUSH
57078: EMPTY
57079: LIST
57080: LIST
57081: PUSH
57082: LD_INT 34
57084: PUSH
57085: LD_INT 52
57087: PUSH
57088: EMPTY
57089: LIST
57090: LIST
57091: PUSH
57092: LD_INT 34
57094: PUSH
57095: LD_INT 14
57097: PUSH
57098: EMPTY
57099: LIST
57100: LIST
57101: PUSH
57102: LD_INT 34
57104: PUSH
57105: LD_INT 53
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: LD_INT 34
57114: PUSH
57115: LD_EXP 92
57119: PUSH
57120: EMPTY
57121: LIST
57122: LIST
57123: PUSH
57124: LD_INT 34
57126: PUSH
57127: LD_INT 31
57129: PUSH
57130: EMPTY
57131: LIST
57132: LIST
57133: PUSH
57134: LD_INT 34
57136: PUSH
57137: LD_INT 48
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: PUSH
57144: LD_INT 34
57146: PUSH
57147: LD_INT 8
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: PUSH
57154: EMPTY
57155: LIST
57156: LIST
57157: LIST
57158: LIST
57159: LIST
57160: LIST
57161: LIST
57162: LIST
57163: LIST
57164: LIST
57165: LIST
57166: LIST
57167: LIST
57168: PPUSH
57169: CALL_OW 72
57173: DIFF
57174: ST_TO_ADDR
// end ; end_of_file
57175: LD_VAR 0 3
57179: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
57180: LD_INT 0
57182: PPUSH
57183: PPUSH
57184: PPUSH
// if not mc_bases or not skirmish then
57185: LD_EXP 99
57189: NOT
57190: PUSH
57191: LD_EXP 97
57195: NOT
57196: OR
57197: IFFALSE 57201
// exit ;
57199: GO 57366
// for i = 1 to mc_bases do
57201: LD_ADDR_VAR 0 4
57205: PUSH
57206: DOUBLE
57207: LD_INT 1
57209: DEC
57210: ST_TO_ADDR
57211: LD_EXP 99
57215: PUSH
57216: FOR_TO
57217: IFFALSE 57364
// begin if sci in mc_bases [ i ] then
57219: LD_VAR 0 2
57223: PUSH
57224: LD_EXP 99
57228: PUSH
57229: LD_VAR 0 4
57233: ARRAY
57234: IN
57235: IFFALSE 57362
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
57237: LD_ADDR_EXP 128
57241: PUSH
57242: LD_EXP 128
57246: PPUSH
57247: LD_VAR 0 4
57251: PUSH
57252: LD_EXP 128
57256: PUSH
57257: LD_VAR 0 4
57261: ARRAY
57262: PUSH
57263: LD_INT 1
57265: PLUS
57266: PUSH
57267: EMPTY
57268: LIST
57269: LIST
57270: PPUSH
57271: LD_VAR 0 1
57275: PPUSH
57276: CALL 68319 0 3
57280: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
57281: LD_ADDR_VAR 0 5
57285: PUSH
57286: LD_EXP 99
57290: PUSH
57291: LD_VAR 0 4
57295: ARRAY
57296: PPUSH
57297: LD_INT 2
57299: PUSH
57300: LD_INT 30
57302: PUSH
57303: LD_INT 0
57305: PUSH
57306: EMPTY
57307: LIST
57308: LIST
57309: PUSH
57310: LD_INT 30
57312: PUSH
57313: LD_INT 1
57315: PUSH
57316: EMPTY
57317: LIST
57318: LIST
57319: PUSH
57320: EMPTY
57321: LIST
57322: LIST
57323: LIST
57324: PPUSH
57325: CALL_OW 72
57329: PPUSH
57330: LD_VAR 0 1
57334: PPUSH
57335: CALL_OW 74
57339: ST_TO_ADDR
// if tmp then
57340: LD_VAR 0 5
57344: IFFALSE 57360
// ComStandNearbyBuilding ( ape , tmp ) ;
57346: LD_VAR 0 1
57350: PPUSH
57351: LD_VAR 0 5
57355: PPUSH
57356: CALL 62996 0 2
// break ;
57360: GO 57364
// end ; end ;
57362: GO 57216
57364: POP
57365: POP
// end ;
57366: LD_VAR 0 3
57370: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
57371: LD_INT 0
57373: PPUSH
57374: PPUSH
57375: PPUSH
// if not mc_bases or not skirmish then
57376: LD_EXP 99
57380: NOT
57381: PUSH
57382: LD_EXP 97
57386: NOT
57387: OR
57388: IFFALSE 57392
// exit ;
57390: GO 57481
// for i = 1 to mc_bases do
57392: LD_ADDR_VAR 0 4
57396: PUSH
57397: DOUBLE
57398: LD_INT 1
57400: DEC
57401: ST_TO_ADDR
57402: LD_EXP 99
57406: PUSH
57407: FOR_TO
57408: IFFALSE 57479
// begin if building in mc_busy_turret_list [ i ] then
57410: LD_VAR 0 1
57414: PUSH
57415: LD_EXP 109
57419: PUSH
57420: LD_VAR 0 4
57424: ARRAY
57425: IN
57426: IFFALSE 57477
// begin tmp := mc_busy_turret_list [ i ] diff building ;
57428: LD_ADDR_VAR 0 5
57432: PUSH
57433: LD_EXP 109
57437: PUSH
57438: LD_VAR 0 4
57442: ARRAY
57443: PUSH
57444: LD_VAR 0 1
57448: DIFF
57449: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
57450: LD_ADDR_EXP 109
57454: PUSH
57455: LD_EXP 109
57459: PPUSH
57460: LD_VAR 0 4
57464: PPUSH
57465: LD_VAR 0 5
57469: PPUSH
57470: CALL_OW 1
57474: ST_TO_ADDR
// break ;
57475: GO 57479
// end ; end ;
57477: GO 57407
57479: POP
57480: POP
// end ;
57481: LD_VAR 0 3
57485: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
57486: LD_INT 0
57488: PPUSH
57489: PPUSH
57490: PPUSH
// if not mc_bases or not skirmish then
57491: LD_EXP 99
57495: NOT
57496: PUSH
57497: LD_EXP 97
57501: NOT
57502: OR
57503: IFFALSE 57507
// exit ;
57505: GO 57706
// for i = 1 to mc_bases do
57507: LD_ADDR_VAR 0 5
57511: PUSH
57512: DOUBLE
57513: LD_INT 1
57515: DEC
57516: ST_TO_ADDR
57517: LD_EXP 99
57521: PUSH
57522: FOR_TO
57523: IFFALSE 57704
// if building in mc_bases [ i ] then
57525: LD_VAR 0 1
57529: PUSH
57530: LD_EXP 99
57534: PUSH
57535: LD_VAR 0 5
57539: ARRAY
57540: IN
57541: IFFALSE 57702
// begin tmp := mc_bases [ i ] diff building ;
57543: LD_ADDR_VAR 0 6
57547: PUSH
57548: LD_EXP 99
57552: PUSH
57553: LD_VAR 0 5
57557: ARRAY
57558: PUSH
57559: LD_VAR 0 1
57563: DIFF
57564: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
57565: LD_ADDR_EXP 99
57569: PUSH
57570: LD_EXP 99
57574: PPUSH
57575: LD_VAR 0 5
57579: PPUSH
57580: LD_VAR 0 6
57584: PPUSH
57585: CALL_OW 1
57589: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
57590: LD_VAR 0 1
57594: PUSH
57595: LD_EXP 107
57599: PUSH
57600: LD_VAR 0 5
57604: ARRAY
57605: IN
57606: IFFALSE 57645
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
57608: LD_ADDR_EXP 107
57612: PUSH
57613: LD_EXP 107
57617: PPUSH
57618: LD_VAR 0 5
57622: PPUSH
57623: LD_EXP 107
57627: PUSH
57628: LD_VAR 0 5
57632: ARRAY
57633: PUSH
57634: LD_VAR 0 1
57638: DIFF
57639: PPUSH
57640: CALL_OW 1
57644: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
57645: LD_VAR 0 1
57649: PUSH
57650: LD_EXP 108
57654: PUSH
57655: LD_VAR 0 5
57659: ARRAY
57660: IN
57661: IFFALSE 57700
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
57663: LD_ADDR_EXP 108
57667: PUSH
57668: LD_EXP 108
57672: PPUSH
57673: LD_VAR 0 5
57677: PPUSH
57678: LD_EXP 108
57682: PUSH
57683: LD_VAR 0 5
57687: ARRAY
57688: PUSH
57689: LD_VAR 0 1
57693: DIFF
57694: PPUSH
57695: CALL_OW 1
57699: ST_TO_ADDR
// break ;
57700: GO 57704
// end ;
57702: GO 57522
57704: POP
57705: POP
// end ;
57706: LD_VAR 0 4
57710: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
57711: LD_INT 0
57713: PPUSH
57714: PPUSH
57715: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
57716: LD_EXP 99
57720: NOT
57721: PUSH
57722: LD_EXP 97
57726: NOT
57727: OR
57728: PUSH
57729: LD_VAR 0 3
57733: PUSH
57734: LD_EXP 125
57738: IN
57739: NOT
57740: OR
57741: IFFALSE 57745
// exit ;
57743: GO 57868
// for i = 1 to mc_vehicles do
57745: LD_ADDR_VAR 0 6
57749: PUSH
57750: DOUBLE
57751: LD_INT 1
57753: DEC
57754: ST_TO_ADDR
57755: LD_EXP 118
57759: PUSH
57760: FOR_TO
57761: IFFALSE 57866
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
57763: LD_VAR 0 2
57767: PUSH
57768: LD_EXP 118
57772: PUSH
57773: LD_VAR 0 6
57777: ARRAY
57778: IN
57779: PUSH
57780: LD_VAR 0 1
57784: PUSH
57785: LD_EXP 118
57789: PUSH
57790: LD_VAR 0 6
57794: ARRAY
57795: IN
57796: OR
57797: IFFALSE 57864
// begin tmp := mc_vehicles [ i ] diff old ;
57799: LD_ADDR_VAR 0 7
57803: PUSH
57804: LD_EXP 118
57808: PUSH
57809: LD_VAR 0 6
57813: ARRAY
57814: PUSH
57815: LD_VAR 0 2
57819: DIFF
57820: ST_TO_ADDR
// tmp := tmp diff new ;
57821: LD_ADDR_VAR 0 7
57825: PUSH
57826: LD_VAR 0 7
57830: PUSH
57831: LD_VAR 0 1
57835: DIFF
57836: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
57837: LD_ADDR_EXP 118
57841: PUSH
57842: LD_EXP 118
57846: PPUSH
57847: LD_VAR 0 6
57851: PPUSH
57852: LD_VAR 0 7
57856: PPUSH
57857: CALL_OW 1
57861: ST_TO_ADDR
// break ;
57862: GO 57866
// end ;
57864: GO 57760
57866: POP
57867: POP
// end ;
57868: LD_VAR 0 5
57872: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
57873: LD_INT 0
57875: PPUSH
57876: PPUSH
57877: PPUSH
57878: PPUSH
// if not mc_bases or not skirmish then
57879: LD_EXP 99
57883: NOT
57884: PUSH
57885: LD_EXP 97
57889: NOT
57890: OR
57891: IFFALSE 57895
// exit ;
57893: GO 58278
// side := GetSide ( vehicle ) ;
57895: LD_ADDR_VAR 0 5
57899: PUSH
57900: LD_VAR 0 1
57904: PPUSH
57905: CALL_OW 255
57909: ST_TO_ADDR
// for i = 1 to mc_bases do
57910: LD_ADDR_VAR 0 4
57914: PUSH
57915: DOUBLE
57916: LD_INT 1
57918: DEC
57919: ST_TO_ADDR
57920: LD_EXP 99
57924: PUSH
57925: FOR_TO
57926: IFFALSE 58276
// begin if factory in mc_bases [ i ] then
57928: LD_VAR 0 2
57932: PUSH
57933: LD_EXP 99
57937: PUSH
57938: LD_VAR 0 4
57942: ARRAY
57943: IN
57944: IFFALSE 58274
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
57946: LD_EXP 121
57950: PUSH
57951: LD_VAR 0 4
57955: ARRAY
57956: PUSH
57957: LD_EXP 110
57961: PUSH
57962: LD_VAR 0 4
57966: ARRAY
57967: LESS
57968: PUSH
57969: LD_VAR 0 1
57973: PPUSH
57974: CALL_OW 264
57978: PUSH
57979: LD_INT 31
57981: PUSH
57982: LD_INT 32
57984: PUSH
57985: LD_INT 51
57987: PUSH
57988: LD_EXP 93
57992: PUSH
57993: LD_INT 12
57995: PUSH
57996: LD_INT 30
57998: PUSH
57999: LD_EXP 92
58003: PUSH
58004: LD_INT 11
58006: PUSH
58007: LD_INT 53
58009: PUSH
58010: LD_INT 14
58012: PUSH
58013: LD_EXP 96
58017: PUSH
58018: LD_INT 29
58020: PUSH
58021: LD_EXP 94
58025: PUSH
58026: LD_INT 13
58028: PUSH
58029: LD_INT 52
58031: PUSH
58032: LD_INT 48
58034: PUSH
58035: LD_INT 8
58037: PUSH
58038: EMPTY
58039: LIST
58040: LIST
58041: LIST
58042: LIST
58043: LIST
58044: LIST
58045: LIST
58046: LIST
58047: LIST
58048: LIST
58049: LIST
58050: LIST
58051: LIST
58052: LIST
58053: LIST
58054: LIST
58055: LIST
58056: IN
58057: NOT
58058: AND
58059: IFFALSE 58100
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
58061: LD_ADDR_EXP 121
58065: PUSH
58066: LD_EXP 121
58070: PPUSH
58071: LD_VAR 0 4
58075: PPUSH
58076: LD_EXP 121
58080: PUSH
58081: LD_VAR 0 4
58085: ARRAY
58086: PUSH
58087: LD_VAR 0 1
58091: ADD
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
58098: GO 58144
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
58100: LD_ADDR_EXP 118
58104: PUSH
58105: LD_EXP 118
58109: PPUSH
58110: LD_VAR 0 4
58114: PUSH
58115: LD_EXP 118
58119: PUSH
58120: LD_VAR 0 4
58124: ARRAY
58125: PUSH
58126: LD_INT 1
58128: PLUS
58129: PUSH
58130: EMPTY
58131: LIST
58132: LIST
58133: PPUSH
58134: LD_VAR 0 1
58138: PPUSH
58139: CALL 68319 0 3
58143: ST_TO_ADDR
// if not mc_scan [ i ] then
58144: LD_EXP 122
58148: PUSH
58149: LD_VAR 0 4
58153: ARRAY
58154: NOT
58155: IFFALSE 58274
// begin if GetControl ( vehicle ) = control_remote then
58157: LD_VAR 0 1
58161: PPUSH
58162: CALL_OW 263
58166: PUSH
58167: LD_INT 2
58169: EQUAL
58170: IFFALSE 58190
// repeat wait ( 0 0$1 ) ;
58172: LD_INT 35
58174: PPUSH
58175: CALL_OW 67
// until IsControledBy ( vehicle ) ;
58179: LD_VAR 0 1
58183: PPUSH
58184: CALL_OW 312
58188: IFFALSE 58172
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
58190: LD_VAR 0 1
58194: PPUSH
58195: LD_EXP 123
58199: PUSH
58200: LD_VAR 0 4
58204: ARRAY
58205: PPUSH
58206: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
58210: LD_VAR 0 1
58214: PPUSH
58215: CALL_OW 263
58219: PUSH
58220: LD_INT 1
58222: NONEQUAL
58223: IFFALSE 58227
// break ;
58225: GO 58276
// repeat wait ( 0 0$1 ) ;
58227: LD_INT 35
58229: PPUSH
58230: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
58234: LD_VAR 0 1
58238: PPUSH
58239: LD_EXP 123
58243: PUSH
58244: LD_VAR 0 4
58248: ARRAY
58249: PPUSH
58250: CALL_OW 308
58254: IFFALSE 58227
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
58256: LD_VAR 0 1
58260: PPUSH
58261: CALL_OW 311
58265: PPUSH
58266: CALL_OW 121
// exit ;
58270: POP
58271: POP
58272: GO 58278
// end ; end ; end ;
58274: GO 57925
58276: POP
58277: POP
// end ;
58278: LD_VAR 0 3
58282: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
58283: LD_INT 0
58285: PPUSH
58286: PPUSH
58287: PPUSH
58288: PPUSH
// if not mc_bases or not skirmish then
58289: LD_EXP 99
58293: NOT
58294: PUSH
58295: LD_EXP 97
58299: NOT
58300: OR
58301: IFFALSE 58305
// exit ;
58303: GO 58658
// repeat wait ( 0 0$1 ) ;
58305: LD_INT 35
58307: PPUSH
58308: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
58312: LD_VAR 0 2
58316: PPUSH
58317: LD_VAR 0 3
58321: PPUSH
58322: CALL_OW 284
58326: IFFALSE 58305
// if GetResourceTypeXY ( x , y ) = mat_artefact then
58328: LD_VAR 0 2
58332: PPUSH
58333: LD_VAR 0 3
58337: PPUSH
58338: CALL_OW 283
58342: PUSH
58343: LD_INT 4
58345: EQUAL
58346: IFFALSE 58350
// exit ;
58348: GO 58658
// for i = 1 to mc_bases do
58350: LD_ADDR_VAR 0 7
58354: PUSH
58355: DOUBLE
58356: LD_INT 1
58358: DEC
58359: ST_TO_ADDR
58360: LD_EXP 99
58364: PUSH
58365: FOR_TO
58366: IFFALSE 58656
// begin if mc_crates_area [ i ] then
58368: LD_EXP 117
58372: PUSH
58373: LD_VAR 0 7
58377: ARRAY
58378: IFFALSE 58489
// for j in mc_crates_area [ i ] do
58380: LD_ADDR_VAR 0 8
58384: PUSH
58385: LD_EXP 117
58389: PUSH
58390: LD_VAR 0 7
58394: ARRAY
58395: PUSH
58396: FOR_IN
58397: IFFALSE 58487
// if InArea ( x , y , j ) then
58399: LD_VAR 0 2
58403: PPUSH
58404: LD_VAR 0 3
58408: PPUSH
58409: LD_VAR 0 8
58413: PPUSH
58414: CALL_OW 309
58418: IFFALSE 58485
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58420: LD_ADDR_EXP 115
58424: PUSH
58425: LD_EXP 115
58429: PPUSH
58430: LD_VAR 0 7
58434: PUSH
58435: LD_EXP 115
58439: PUSH
58440: LD_VAR 0 7
58444: ARRAY
58445: PUSH
58446: LD_INT 1
58448: PLUS
58449: PUSH
58450: EMPTY
58451: LIST
58452: LIST
58453: PPUSH
58454: LD_VAR 0 4
58458: PUSH
58459: LD_VAR 0 2
58463: PUSH
58464: LD_VAR 0 3
58468: PUSH
58469: EMPTY
58470: LIST
58471: LIST
58472: LIST
58473: PPUSH
58474: CALL 68319 0 3
58478: ST_TO_ADDR
// exit ;
58479: POP
58480: POP
58481: POP
58482: POP
58483: GO 58658
// end ;
58485: GO 58396
58487: POP
58488: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58489: LD_ADDR_VAR 0 9
58493: PUSH
58494: LD_EXP 99
58498: PUSH
58499: LD_VAR 0 7
58503: ARRAY
58504: PPUSH
58505: LD_INT 2
58507: PUSH
58508: LD_INT 30
58510: PUSH
58511: LD_INT 0
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: PUSH
58518: LD_INT 30
58520: PUSH
58521: LD_INT 1
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: LIST
58532: PPUSH
58533: CALL_OW 72
58537: ST_TO_ADDR
// if not depot then
58538: LD_VAR 0 9
58542: NOT
58543: IFFALSE 58547
// continue ;
58545: GO 58365
// for j in depot do
58547: LD_ADDR_VAR 0 8
58551: PUSH
58552: LD_VAR 0 9
58556: PUSH
58557: FOR_IN
58558: IFFALSE 58652
// if GetDistUnitXY ( j , x , y ) < 30 then
58560: LD_VAR 0 8
58564: PPUSH
58565: LD_VAR 0 2
58569: PPUSH
58570: LD_VAR 0 3
58574: PPUSH
58575: CALL_OW 297
58579: PUSH
58580: LD_INT 30
58582: LESS
58583: IFFALSE 58650
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58585: LD_ADDR_EXP 115
58589: PUSH
58590: LD_EXP 115
58594: PPUSH
58595: LD_VAR 0 7
58599: PUSH
58600: LD_EXP 115
58604: PUSH
58605: LD_VAR 0 7
58609: ARRAY
58610: PUSH
58611: LD_INT 1
58613: PLUS
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: PPUSH
58619: LD_VAR 0 4
58623: PUSH
58624: LD_VAR 0 2
58628: PUSH
58629: LD_VAR 0 3
58633: PUSH
58634: EMPTY
58635: LIST
58636: LIST
58637: LIST
58638: PPUSH
58639: CALL 68319 0 3
58643: ST_TO_ADDR
// exit ;
58644: POP
58645: POP
58646: POP
58647: POP
58648: GO 58658
// end ;
58650: GO 58557
58652: POP
58653: POP
// end ;
58654: GO 58365
58656: POP
58657: POP
// end ;
58658: LD_VAR 0 6
58662: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
58663: LD_INT 0
58665: PPUSH
58666: PPUSH
58667: PPUSH
58668: PPUSH
// if not mc_bases or not skirmish then
58669: LD_EXP 99
58673: NOT
58674: PUSH
58675: LD_EXP 97
58679: NOT
58680: OR
58681: IFFALSE 58685
// exit ;
58683: GO 58962
// side := GetSide ( lab ) ;
58685: LD_ADDR_VAR 0 4
58689: PUSH
58690: LD_VAR 0 2
58694: PPUSH
58695: CALL_OW 255
58699: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
58700: LD_VAR 0 4
58704: PUSH
58705: LD_EXP 125
58709: IN
58710: NOT
58711: PUSH
58712: LD_EXP 126
58716: NOT
58717: OR
58718: PUSH
58719: LD_EXP 99
58723: NOT
58724: OR
58725: IFFALSE 58729
// exit ;
58727: GO 58962
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
58729: LD_ADDR_EXP 126
58733: PUSH
58734: LD_EXP 126
58738: PPUSH
58739: LD_VAR 0 4
58743: PPUSH
58744: LD_EXP 126
58748: PUSH
58749: LD_VAR 0 4
58753: ARRAY
58754: PUSH
58755: LD_VAR 0 1
58759: DIFF
58760: PPUSH
58761: CALL_OW 1
58765: ST_TO_ADDR
// for i = 1 to mc_bases do
58766: LD_ADDR_VAR 0 5
58770: PUSH
58771: DOUBLE
58772: LD_INT 1
58774: DEC
58775: ST_TO_ADDR
58776: LD_EXP 99
58780: PUSH
58781: FOR_TO
58782: IFFALSE 58960
// begin if lab in mc_bases [ i ] then
58784: LD_VAR 0 2
58788: PUSH
58789: LD_EXP 99
58793: PUSH
58794: LD_VAR 0 5
58798: ARRAY
58799: IN
58800: IFFALSE 58958
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
58802: LD_VAR 0 1
58806: PUSH
58807: LD_INT 11
58809: PUSH
58810: LD_INT 4
58812: PUSH
58813: LD_INT 3
58815: PUSH
58816: LD_INT 2
58818: PUSH
58819: EMPTY
58820: LIST
58821: LIST
58822: LIST
58823: LIST
58824: IN
58825: PUSH
58826: LD_EXP 129
58830: PUSH
58831: LD_VAR 0 5
58835: ARRAY
58836: AND
58837: IFFALSE 58958
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
58839: LD_ADDR_VAR 0 6
58843: PUSH
58844: LD_EXP 129
58848: PUSH
58849: LD_VAR 0 5
58853: ARRAY
58854: PUSH
58855: LD_INT 1
58857: ARRAY
58858: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58859: LD_ADDR_EXP 129
58863: PUSH
58864: LD_EXP 129
58868: PPUSH
58869: LD_VAR 0 5
58873: PPUSH
58874: EMPTY
58875: PPUSH
58876: CALL_OW 1
58880: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
58881: LD_VAR 0 6
58885: PPUSH
58886: LD_INT 0
58888: PPUSH
58889: CALL_OW 109
// ComExitBuilding ( tmp ) ;
58893: LD_VAR 0 6
58897: PPUSH
58898: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
58902: LD_ADDR_EXP 128
58906: PUSH
58907: LD_EXP 128
58911: PPUSH
58912: LD_VAR 0 5
58916: PPUSH
58917: LD_EXP 128
58921: PUSH
58922: LD_VAR 0 5
58926: ARRAY
58927: PPUSH
58928: LD_INT 1
58930: PPUSH
58931: LD_VAR 0 6
58935: PPUSH
58936: CALL_OW 2
58940: PPUSH
58941: CALL_OW 1
58945: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
58946: LD_VAR 0 5
58950: PPUSH
58951: LD_INT 112
58953: PPUSH
58954: CALL 36431 0 2
// end ; end ; end ;
58958: GO 58781
58960: POP
58961: POP
// end ;
58962: LD_VAR 0 3
58966: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
58967: LD_INT 0
58969: PPUSH
58970: PPUSH
58971: PPUSH
58972: PPUSH
58973: PPUSH
58974: PPUSH
58975: PPUSH
58976: PPUSH
// if not mc_bases or not skirmish then
58977: LD_EXP 99
58981: NOT
58982: PUSH
58983: LD_EXP 97
58987: NOT
58988: OR
58989: IFFALSE 58993
// exit ;
58991: GO 60009
// for i = 1 to mc_bases do
58993: LD_ADDR_VAR 0 3
58997: PUSH
58998: DOUBLE
58999: LD_INT 1
59001: DEC
59002: ST_TO_ADDR
59003: LD_EXP 99
59007: PUSH
59008: FOR_TO
59009: IFFALSE 60007
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
59011: LD_VAR 0 1
59015: PUSH
59016: LD_EXP 99
59020: PUSH
59021: LD_VAR 0 3
59025: ARRAY
59026: IN
59027: PUSH
59028: LD_VAR 0 1
59032: PUSH
59033: LD_EXP 106
59037: PUSH
59038: LD_VAR 0 3
59042: ARRAY
59043: IN
59044: OR
59045: PUSH
59046: LD_VAR 0 1
59050: PUSH
59051: LD_EXP 118
59055: PUSH
59056: LD_VAR 0 3
59060: ARRAY
59061: IN
59062: OR
59063: PUSH
59064: LD_VAR 0 1
59068: PUSH
59069: LD_EXP 128
59073: PUSH
59074: LD_VAR 0 3
59078: ARRAY
59079: IN
59080: OR
59081: PUSH
59082: LD_VAR 0 1
59086: PUSH
59087: LD_EXP 129
59091: PUSH
59092: LD_VAR 0 3
59096: ARRAY
59097: IN
59098: OR
59099: IFFALSE 60005
// begin if un in mc_ape [ i ] then
59101: LD_VAR 0 1
59105: PUSH
59106: LD_EXP 128
59110: PUSH
59111: LD_VAR 0 3
59115: ARRAY
59116: IN
59117: IFFALSE 59156
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
59119: LD_ADDR_EXP 128
59123: PUSH
59124: LD_EXP 128
59128: PPUSH
59129: LD_VAR 0 3
59133: PPUSH
59134: LD_EXP 128
59138: PUSH
59139: LD_VAR 0 3
59143: ARRAY
59144: PUSH
59145: LD_VAR 0 1
59149: DIFF
59150: PPUSH
59151: CALL_OW 1
59155: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
59156: LD_VAR 0 1
59160: PUSH
59161: LD_EXP 129
59165: PUSH
59166: LD_VAR 0 3
59170: ARRAY
59171: IN
59172: IFFALSE 59196
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59174: LD_ADDR_EXP 129
59178: PUSH
59179: LD_EXP 129
59183: PPUSH
59184: LD_VAR 0 3
59188: PPUSH
59189: EMPTY
59190: PPUSH
59191: CALL_OW 1
59195: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
59196: LD_VAR 0 1
59200: PPUSH
59201: CALL_OW 247
59205: PUSH
59206: LD_INT 2
59208: EQUAL
59209: PUSH
59210: LD_VAR 0 1
59214: PPUSH
59215: CALL_OW 110
59219: PUSH
59220: LD_INT 20
59222: EQUAL
59223: PUSH
59224: LD_VAR 0 1
59228: PUSH
59229: LD_EXP 121
59233: PUSH
59234: LD_VAR 0 3
59238: ARRAY
59239: IN
59240: OR
59241: AND
59242: IFFALSE 59345
// begin fac := MC_GetBuilding ( i , b_factory ) ;
59244: LD_ADDR_VAR 0 8
59248: PUSH
59249: LD_VAR 0 3
59253: PPUSH
59254: LD_INT 3
59256: PPUSH
59257: CALL 56004 0 2
59261: ST_TO_ADDR
// if fac then
59262: LD_VAR 0 8
59266: IFFALSE 59345
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
59268: LD_ADDR_VAR 0 9
59272: PUSH
59273: LD_VAR 0 8
59277: PPUSH
59278: LD_VAR 0 1
59282: PPUSH
59283: CALL_OW 265
59287: PPUSH
59288: LD_VAR 0 1
59292: PPUSH
59293: CALL_OW 262
59297: PPUSH
59298: LD_VAR 0 1
59302: PPUSH
59303: CALL_OW 263
59307: PPUSH
59308: LD_VAR 0 1
59312: PPUSH
59313: CALL_OW 264
59317: PPUSH
59318: CALL 65919 0 5
59322: ST_TO_ADDR
// if components then
59323: LD_VAR 0 9
59327: IFFALSE 59343
// MC_InsertProduceList ( i , components ) ;
59329: LD_VAR 0 3
59333: PPUSH
59334: LD_VAR 0 9
59338: PPUSH
59339: CALL 55632 0 2
// break ;
59343: GO 60007
// end ; end ; if GetType ( un ) = unit_building then
59345: LD_VAR 0 1
59349: PPUSH
59350: CALL_OW 247
59354: PUSH
59355: LD_INT 3
59357: EQUAL
59358: IFFALSE 59673
// begin btype := GetBType ( un ) ;
59360: LD_ADDR_VAR 0 5
59364: PUSH
59365: LD_VAR 0 1
59369: PPUSH
59370: CALL_OW 266
59374: ST_TO_ADDR
// if btype = b_warehouse then
59375: LD_VAR 0 5
59379: PUSH
59380: LD_INT 1
59382: EQUAL
59383: IFFALSE 59401
// begin btype := b_depot ;
59385: LD_ADDR_VAR 0 5
59389: PUSH
59390: LD_INT 0
59392: ST_TO_ADDR
// pos := 1 ;
59393: LD_ADDR_VAR 0 6
59397: PUSH
59398: LD_INT 1
59400: ST_TO_ADDR
// end ; if btype = b_factory then
59401: LD_VAR 0 5
59405: PUSH
59406: LD_INT 3
59408: EQUAL
59409: IFFALSE 59427
// begin btype := b_workshop ;
59411: LD_ADDR_VAR 0 5
59415: PUSH
59416: LD_INT 2
59418: ST_TO_ADDR
// pos := 1 ;
59419: LD_ADDR_VAR 0 6
59423: PUSH
59424: LD_INT 1
59426: ST_TO_ADDR
// end ; if btype = b_barracks then
59427: LD_VAR 0 5
59431: PUSH
59432: LD_INT 5
59434: EQUAL
59435: IFFALSE 59445
// btype := b_armoury ;
59437: LD_ADDR_VAR 0 5
59441: PUSH
59442: LD_INT 4
59444: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
59445: LD_VAR 0 5
59449: PUSH
59450: LD_INT 7
59452: PUSH
59453: LD_INT 8
59455: PUSH
59456: EMPTY
59457: LIST
59458: LIST
59459: IN
59460: IFFALSE 59470
// btype := b_lab ;
59462: LD_ADDR_VAR 0 5
59466: PUSH
59467: LD_INT 6
59469: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
59470: LD_ADDR_EXP 104
59474: PUSH
59475: LD_EXP 104
59479: PPUSH
59480: LD_VAR 0 3
59484: PUSH
59485: LD_EXP 104
59489: PUSH
59490: LD_VAR 0 3
59494: ARRAY
59495: PUSH
59496: LD_INT 1
59498: PLUS
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: PPUSH
59504: LD_VAR 0 5
59508: PUSH
59509: LD_VAR 0 1
59513: PPUSH
59514: CALL_OW 250
59518: PUSH
59519: LD_VAR 0 1
59523: PPUSH
59524: CALL_OW 251
59528: PUSH
59529: LD_VAR 0 1
59533: PPUSH
59534: CALL_OW 254
59538: PUSH
59539: EMPTY
59540: LIST
59541: LIST
59542: LIST
59543: LIST
59544: PPUSH
59545: CALL 68319 0 3
59549: ST_TO_ADDR
// if pos = 1 then
59550: LD_VAR 0 6
59554: PUSH
59555: LD_INT 1
59557: EQUAL
59558: IFFALSE 59673
// begin tmp := mc_build_list [ i ] ;
59560: LD_ADDR_VAR 0 7
59564: PUSH
59565: LD_EXP 104
59569: PUSH
59570: LD_VAR 0 3
59574: ARRAY
59575: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59576: LD_VAR 0 7
59580: PPUSH
59581: LD_INT 2
59583: PUSH
59584: LD_INT 30
59586: PUSH
59587: LD_INT 0
59589: PUSH
59590: EMPTY
59591: LIST
59592: LIST
59593: PUSH
59594: LD_INT 30
59596: PUSH
59597: LD_INT 1
59599: PUSH
59600: EMPTY
59601: LIST
59602: LIST
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: LIST
59608: PPUSH
59609: CALL_OW 72
59613: IFFALSE 59623
// pos := 2 ;
59615: LD_ADDR_VAR 0 6
59619: PUSH
59620: LD_INT 2
59622: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
59623: LD_ADDR_VAR 0 7
59627: PUSH
59628: LD_VAR 0 7
59632: PPUSH
59633: LD_VAR 0 6
59637: PPUSH
59638: LD_VAR 0 7
59642: PPUSH
59643: CALL 68645 0 3
59647: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
59648: LD_ADDR_EXP 104
59652: PUSH
59653: LD_EXP 104
59657: PPUSH
59658: LD_VAR 0 3
59662: PPUSH
59663: LD_VAR 0 7
59667: PPUSH
59668: CALL_OW 1
59672: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
59673: LD_VAR 0 1
59677: PUSH
59678: LD_EXP 99
59682: PUSH
59683: LD_VAR 0 3
59687: ARRAY
59688: IN
59689: IFFALSE 59728
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
59691: LD_ADDR_EXP 99
59695: PUSH
59696: LD_EXP 99
59700: PPUSH
59701: LD_VAR 0 3
59705: PPUSH
59706: LD_EXP 99
59710: PUSH
59711: LD_VAR 0 3
59715: ARRAY
59716: PUSH
59717: LD_VAR 0 1
59721: DIFF
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
59728: LD_VAR 0 1
59732: PUSH
59733: LD_EXP 106
59737: PUSH
59738: LD_VAR 0 3
59742: ARRAY
59743: IN
59744: IFFALSE 59783
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
59746: LD_ADDR_EXP 106
59750: PUSH
59751: LD_EXP 106
59755: PPUSH
59756: LD_VAR 0 3
59760: PPUSH
59761: LD_EXP 106
59765: PUSH
59766: LD_VAR 0 3
59770: ARRAY
59771: PUSH
59772: LD_VAR 0 1
59776: DIFF
59777: PPUSH
59778: CALL_OW 1
59782: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
59783: LD_VAR 0 1
59787: PUSH
59788: LD_EXP 118
59792: PUSH
59793: LD_VAR 0 3
59797: ARRAY
59798: IN
59799: IFFALSE 59838
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
59801: LD_ADDR_EXP 118
59805: PUSH
59806: LD_EXP 118
59810: PPUSH
59811: LD_VAR 0 3
59815: PPUSH
59816: LD_EXP 118
59820: PUSH
59821: LD_VAR 0 3
59825: ARRAY
59826: PUSH
59827: LD_VAR 0 1
59831: DIFF
59832: PPUSH
59833: CALL_OW 1
59837: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
59838: LD_VAR 0 1
59842: PUSH
59843: LD_EXP 121
59847: PUSH
59848: LD_VAR 0 3
59852: ARRAY
59853: IN
59854: IFFALSE 59893
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
59856: LD_ADDR_EXP 121
59860: PUSH
59861: LD_EXP 121
59865: PPUSH
59866: LD_VAR 0 3
59870: PPUSH
59871: LD_EXP 121
59875: PUSH
59876: LD_VAR 0 3
59880: ARRAY
59881: PUSH
59882: LD_VAR 0 1
59886: DIFF
59887: PPUSH
59888: CALL_OW 1
59892: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
59893: LD_VAR 0 1
59897: PUSH
59898: LD_EXP 108
59902: PUSH
59903: LD_VAR 0 3
59907: ARRAY
59908: IN
59909: IFFALSE 59948
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
59911: LD_ADDR_EXP 108
59915: PUSH
59916: LD_EXP 108
59920: PPUSH
59921: LD_VAR 0 3
59925: PPUSH
59926: LD_EXP 108
59930: PUSH
59931: LD_VAR 0 3
59935: ARRAY
59936: PUSH
59937: LD_VAR 0 1
59941: DIFF
59942: PPUSH
59943: CALL_OW 1
59947: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
59948: LD_VAR 0 1
59952: PUSH
59953: LD_EXP 107
59957: PUSH
59958: LD_VAR 0 3
59962: ARRAY
59963: IN
59964: IFFALSE 60003
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
59966: LD_ADDR_EXP 107
59970: PUSH
59971: LD_EXP 107
59975: PPUSH
59976: LD_VAR 0 3
59980: PPUSH
59981: LD_EXP 107
59985: PUSH
59986: LD_VAR 0 3
59990: ARRAY
59991: PUSH
59992: LD_VAR 0 1
59996: DIFF
59997: PPUSH
59998: CALL_OW 1
60002: ST_TO_ADDR
// end ; break ;
60003: GO 60007
// end ;
60005: GO 59008
60007: POP
60008: POP
// end ;
60009: LD_VAR 0 2
60013: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
60014: LD_INT 0
60016: PPUSH
60017: PPUSH
60018: PPUSH
// if not mc_bases or not skirmish then
60019: LD_EXP 99
60023: NOT
60024: PUSH
60025: LD_EXP 97
60029: NOT
60030: OR
60031: IFFALSE 60035
// exit ;
60033: GO 60250
// for i = 1 to mc_bases do
60035: LD_ADDR_VAR 0 3
60039: PUSH
60040: DOUBLE
60041: LD_INT 1
60043: DEC
60044: ST_TO_ADDR
60045: LD_EXP 99
60049: PUSH
60050: FOR_TO
60051: IFFALSE 60248
// begin if building in mc_construct_list [ i ] then
60053: LD_VAR 0 1
60057: PUSH
60058: LD_EXP 106
60062: PUSH
60063: LD_VAR 0 3
60067: ARRAY
60068: IN
60069: IFFALSE 60246
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
60071: LD_ADDR_EXP 106
60075: PUSH
60076: LD_EXP 106
60080: PPUSH
60081: LD_VAR 0 3
60085: PPUSH
60086: LD_EXP 106
60090: PUSH
60091: LD_VAR 0 3
60095: ARRAY
60096: PUSH
60097: LD_VAR 0 1
60101: DIFF
60102: PPUSH
60103: CALL_OW 1
60107: ST_TO_ADDR
// if building in mc_lab [ i ] then
60108: LD_VAR 0 1
60112: PUSH
60113: LD_EXP 132
60117: PUSH
60118: LD_VAR 0 3
60122: ARRAY
60123: IN
60124: IFFALSE 60179
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
60126: LD_ADDR_EXP 133
60130: PUSH
60131: LD_EXP 133
60135: PPUSH
60136: LD_VAR 0 3
60140: PPUSH
60141: LD_EXP 133
60145: PUSH
60146: LD_VAR 0 3
60150: ARRAY
60151: PPUSH
60152: LD_INT 1
60154: PPUSH
60155: LD_EXP 133
60159: PUSH
60160: LD_VAR 0 3
60164: ARRAY
60165: PPUSH
60166: LD_INT 0
60168: PPUSH
60169: CALL 67737 0 4
60173: PPUSH
60174: CALL_OW 1
60178: ST_TO_ADDR
// if not building in mc_bases [ i ] then
60179: LD_VAR 0 1
60183: PUSH
60184: LD_EXP 99
60188: PUSH
60189: LD_VAR 0 3
60193: ARRAY
60194: IN
60195: NOT
60196: IFFALSE 60242
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
60198: LD_ADDR_EXP 99
60202: PUSH
60203: LD_EXP 99
60207: PPUSH
60208: LD_VAR 0 3
60212: PUSH
60213: LD_EXP 99
60217: PUSH
60218: LD_VAR 0 3
60222: ARRAY
60223: PUSH
60224: LD_INT 1
60226: PLUS
60227: PUSH
60228: EMPTY
60229: LIST
60230: LIST
60231: PPUSH
60232: LD_VAR 0 1
60236: PPUSH
60237: CALL 68319 0 3
60241: ST_TO_ADDR
// exit ;
60242: POP
60243: POP
60244: GO 60250
// end ; end ;
60246: GO 60050
60248: POP
60249: POP
// end ;
60250: LD_VAR 0 2
60254: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
60255: LD_INT 0
60257: PPUSH
60258: PPUSH
60259: PPUSH
60260: PPUSH
60261: PPUSH
60262: PPUSH
60263: PPUSH
// if not mc_bases or not skirmish then
60264: LD_EXP 99
60268: NOT
60269: PUSH
60270: LD_EXP 97
60274: NOT
60275: OR
60276: IFFALSE 60280
// exit ;
60278: GO 60941
// for i = 1 to mc_bases do
60280: LD_ADDR_VAR 0 3
60284: PUSH
60285: DOUBLE
60286: LD_INT 1
60288: DEC
60289: ST_TO_ADDR
60290: LD_EXP 99
60294: PUSH
60295: FOR_TO
60296: IFFALSE 60939
// begin if building in mc_construct_list [ i ] then
60298: LD_VAR 0 1
60302: PUSH
60303: LD_EXP 106
60307: PUSH
60308: LD_VAR 0 3
60312: ARRAY
60313: IN
60314: IFFALSE 60937
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
60316: LD_ADDR_EXP 106
60320: PUSH
60321: LD_EXP 106
60325: PPUSH
60326: LD_VAR 0 3
60330: PPUSH
60331: LD_EXP 106
60335: PUSH
60336: LD_VAR 0 3
60340: ARRAY
60341: PUSH
60342: LD_VAR 0 1
60346: DIFF
60347: PPUSH
60348: CALL_OW 1
60352: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
60353: LD_ADDR_EXP 99
60357: PUSH
60358: LD_EXP 99
60362: PPUSH
60363: LD_VAR 0 3
60367: PUSH
60368: LD_EXP 99
60372: PUSH
60373: LD_VAR 0 3
60377: ARRAY
60378: PUSH
60379: LD_INT 1
60381: PLUS
60382: PUSH
60383: EMPTY
60384: LIST
60385: LIST
60386: PPUSH
60387: LD_VAR 0 1
60391: PPUSH
60392: CALL 68319 0 3
60396: ST_TO_ADDR
// btype := GetBType ( building ) ;
60397: LD_ADDR_VAR 0 5
60401: PUSH
60402: LD_VAR 0 1
60406: PPUSH
60407: CALL_OW 266
60411: ST_TO_ADDR
// side := GetSide ( building ) ;
60412: LD_ADDR_VAR 0 8
60416: PUSH
60417: LD_VAR 0 1
60421: PPUSH
60422: CALL_OW 255
60426: ST_TO_ADDR
// if btype = b_lab then
60427: LD_VAR 0 5
60431: PUSH
60432: LD_INT 6
60434: EQUAL
60435: IFFALSE 60485
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
60437: LD_ADDR_EXP 132
60441: PUSH
60442: LD_EXP 132
60446: PPUSH
60447: LD_VAR 0 3
60451: PUSH
60452: LD_EXP 132
60456: PUSH
60457: LD_VAR 0 3
60461: ARRAY
60462: PUSH
60463: LD_INT 1
60465: PLUS
60466: PUSH
60467: EMPTY
60468: LIST
60469: LIST
60470: PPUSH
60471: LD_VAR 0 1
60475: PPUSH
60476: CALL 68319 0 3
60480: ST_TO_ADDR
// exit ;
60481: POP
60482: POP
60483: GO 60941
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
60485: LD_VAR 0 5
60489: PUSH
60490: LD_INT 0
60492: PUSH
60493: LD_INT 2
60495: PUSH
60496: LD_INT 4
60498: PUSH
60499: EMPTY
60500: LIST
60501: LIST
60502: LIST
60503: IN
60504: IFFALSE 60628
// begin if btype = b_armoury then
60506: LD_VAR 0 5
60510: PUSH
60511: LD_INT 4
60513: EQUAL
60514: IFFALSE 60524
// btype := b_barracks ;
60516: LD_ADDR_VAR 0 5
60520: PUSH
60521: LD_INT 5
60523: ST_TO_ADDR
// if btype = b_depot then
60524: LD_VAR 0 5
60528: PUSH
60529: LD_INT 0
60531: EQUAL
60532: IFFALSE 60542
// btype := b_warehouse ;
60534: LD_ADDR_VAR 0 5
60538: PUSH
60539: LD_INT 1
60541: ST_TO_ADDR
// if btype = b_workshop then
60542: LD_VAR 0 5
60546: PUSH
60547: LD_INT 2
60549: EQUAL
60550: IFFALSE 60560
// btype := b_factory ;
60552: LD_ADDR_VAR 0 5
60556: PUSH
60557: LD_INT 3
60559: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
60560: LD_VAR 0 5
60564: PPUSH
60565: LD_VAR 0 8
60569: PPUSH
60570: CALL_OW 323
60574: PUSH
60575: LD_INT 1
60577: EQUAL
60578: IFFALSE 60624
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
60580: LD_ADDR_EXP 131
60584: PUSH
60585: LD_EXP 131
60589: PPUSH
60590: LD_VAR 0 3
60594: PUSH
60595: LD_EXP 131
60599: PUSH
60600: LD_VAR 0 3
60604: ARRAY
60605: PUSH
60606: LD_INT 1
60608: PLUS
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PPUSH
60614: LD_VAR 0 1
60618: PPUSH
60619: CALL 68319 0 3
60623: ST_TO_ADDR
// exit ;
60624: POP
60625: POP
60626: GO 60941
// end ; if btype in [ b_bunker , b_turret ] then
60628: LD_VAR 0 5
60632: PUSH
60633: LD_INT 32
60635: PUSH
60636: LD_INT 33
60638: PUSH
60639: EMPTY
60640: LIST
60641: LIST
60642: IN
60643: IFFALSE 60933
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
60645: LD_ADDR_EXP 107
60649: PUSH
60650: LD_EXP 107
60654: PPUSH
60655: LD_VAR 0 3
60659: PUSH
60660: LD_EXP 107
60664: PUSH
60665: LD_VAR 0 3
60669: ARRAY
60670: PUSH
60671: LD_INT 1
60673: PLUS
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PPUSH
60679: LD_VAR 0 1
60683: PPUSH
60684: CALL 68319 0 3
60688: ST_TO_ADDR
// if btype = b_bunker then
60689: LD_VAR 0 5
60693: PUSH
60694: LD_INT 32
60696: EQUAL
60697: IFFALSE 60933
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
60699: LD_ADDR_EXP 108
60703: PUSH
60704: LD_EXP 108
60708: PPUSH
60709: LD_VAR 0 3
60713: PUSH
60714: LD_EXP 108
60718: PUSH
60719: LD_VAR 0 3
60723: ARRAY
60724: PUSH
60725: LD_INT 1
60727: PLUS
60728: PUSH
60729: EMPTY
60730: LIST
60731: LIST
60732: PPUSH
60733: LD_VAR 0 1
60737: PPUSH
60738: CALL 68319 0 3
60742: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
60743: LD_ADDR_VAR 0 6
60747: PUSH
60748: LD_EXP 99
60752: PUSH
60753: LD_VAR 0 3
60757: ARRAY
60758: PPUSH
60759: LD_INT 25
60761: PUSH
60762: LD_INT 1
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: LD_INT 3
60771: PUSH
60772: LD_INT 54
60774: PUSH
60775: EMPTY
60776: LIST
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PPUSH
60786: CALL_OW 72
60790: ST_TO_ADDR
// if tmp then
60791: LD_VAR 0 6
60795: IFFALSE 60801
// exit ;
60797: POP
60798: POP
60799: GO 60941
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60801: LD_ADDR_VAR 0 6
60805: PUSH
60806: LD_EXP 99
60810: PUSH
60811: LD_VAR 0 3
60815: ARRAY
60816: PPUSH
60817: LD_INT 2
60819: PUSH
60820: LD_INT 30
60822: PUSH
60823: LD_INT 4
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PUSH
60830: LD_INT 30
60832: PUSH
60833: LD_INT 5
60835: PUSH
60836: EMPTY
60837: LIST
60838: LIST
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: LIST
60844: PPUSH
60845: CALL_OW 72
60849: ST_TO_ADDR
// if not tmp then
60850: LD_VAR 0 6
60854: NOT
60855: IFFALSE 60861
// exit ;
60857: POP
60858: POP
60859: GO 60941
// for j in tmp do
60861: LD_ADDR_VAR 0 4
60865: PUSH
60866: LD_VAR 0 6
60870: PUSH
60871: FOR_IN
60872: IFFALSE 60931
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
60874: LD_ADDR_VAR 0 7
60878: PUSH
60879: LD_VAR 0 4
60883: PPUSH
60884: CALL_OW 313
60888: PPUSH
60889: LD_INT 25
60891: PUSH
60892: LD_INT 1
60894: PUSH
60895: EMPTY
60896: LIST
60897: LIST
60898: PPUSH
60899: CALL_OW 72
60903: ST_TO_ADDR
// if units then
60904: LD_VAR 0 7
60908: IFFALSE 60929
// begin ComExitBuilding ( units [ 1 ] ) ;
60910: LD_VAR 0 7
60914: PUSH
60915: LD_INT 1
60917: ARRAY
60918: PPUSH
60919: CALL_OW 122
// exit ;
60923: POP
60924: POP
60925: POP
60926: POP
60927: GO 60941
// end ; end ;
60929: GO 60871
60931: POP
60932: POP
// end ; end ; exit ;
60933: POP
60934: POP
60935: GO 60941
// end ; end ;
60937: GO 60295
60939: POP
60940: POP
// end ;
60941: LD_VAR 0 2
60945: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
60946: LD_INT 0
60948: PPUSH
60949: PPUSH
60950: PPUSH
60951: PPUSH
60952: PPUSH
60953: PPUSH
60954: PPUSH
// if not mc_bases or not skirmish then
60955: LD_EXP 99
60959: NOT
60960: PUSH
60961: LD_EXP 97
60965: NOT
60966: OR
60967: IFFALSE 60971
// exit ;
60969: GO 61202
// btype := GetBType ( building ) ;
60971: LD_ADDR_VAR 0 6
60975: PUSH
60976: LD_VAR 0 1
60980: PPUSH
60981: CALL_OW 266
60985: ST_TO_ADDR
// x := GetX ( building ) ;
60986: LD_ADDR_VAR 0 7
60990: PUSH
60991: LD_VAR 0 1
60995: PPUSH
60996: CALL_OW 250
61000: ST_TO_ADDR
// y := GetY ( building ) ;
61001: LD_ADDR_VAR 0 8
61005: PUSH
61006: LD_VAR 0 1
61010: PPUSH
61011: CALL_OW 251
61015: ST_TO_ADDR
// d := GetDir ( building ) ;
61016: LD_ADDR_VAR 0 9
61020: PUSH
61021: LD_VAR 0 1
61025: PPUSH
61026: CALL_OW 254
61030: ST_TO_ADDR
// for i = 1 to mc_bases do
61031: LD_ADDR_VAR 0 4
61035: PUSH
61036: DOUBLE
61037: LD_INT 1
61039: DEC
61040: ST_TO_ADDR
61041: LD_EXP 99
61045: PUSH
61046: FOR_TO
61047: IFFALSE 61200
// begin if not mc_build_list [ i ] then
61049: LD_EXP 104
61053: PUSH
61054: LD_VAR 0 4
61058: ARRAY
61059: NOT
61060: IFFALSE 61064
// continue ;
61062: GO 61046
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
61064: LD_VAR 0 6
61068: PUSH
61069: LD_VAR 0 7
61073: PUSH
61074: LD_VAR 0 8
61078: PUSH
61079: LD_VAR 0 9
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: LIST
61088: LIST
61089: PPUSH
61090: LD_EXP 104
61094: PUSH
61095: LD_VAR 0 4
61099: ARRAY
61100: PUSH
61101: LD_INT 1
61103: ARRAY
61104: PPUSH
61105: CALL 74488 0 2
61109: IFFALSE 61198
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
61111: LD_ADDR_EXP 104
61115: PUSH
61116: LD_EXP 104
61120: PPUSH
61121: LD_VAR 0 4
61125: PPUSH
61126: LD_EXP 104
61130: PUSH
61131: LD_VAR 0 4
61135: ARRAY
61136: PPUSH
61137: LD_INT 1
61139: PPUSH
61140: CALL_OW 3
61144: PPUSH
61145: CALL_OW 1
61149: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
61150: LD_ADDR_EXP 106
61154: PUSH
61155: LD_EXP 106
61159: PPUSH
61160: LD_VAR 0 4
61164: PUSH
61165: LD_EXP 106
61169: PUSH
61170: LD_VAR 0 4
61174: ARRAY
61175: PUSH
61176: LD_INT 1
61178: PLUS
61179: PUSH
61180: EMPTY
61181: LIST
61182: LIST
61183: PPUSH
61184: LD_VAR 0 1
61188: PPUSH
61189: CALL 68319 0 3
61193: ST_TO_ADDR
// exit ;
61194: POP
61195: POP
61196: GO 61202
// end ; end ;
61198: GO 61046
61200: POP
61201: POP
// end ;
61202: LD_VAR 0 3
61206: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
61207: LD_INT 0
61209: PPUSH
61210: PPUSH
61211: PPUSH
// if not mc_bases or not skirmish then
61212: LD_EXP 99
61216: NOT
61217: PUSH
61218: LD_EXP 97
61222: NOT
61223: OR
61224: IFFALSE 61228
// exit ;
61226: GO 61418
// for i = 1 to mc_bases do
61228: LD_ADDR_VAR 0 4
61232: PUSH
61233: DOUBLE
61234: LD_INT 1
61236: DEC
61237: ST_TO_ADDR
61238: LD_EXP 99
61242: PUSH
61243: FOR_TO
61244: IFFALSE 61331
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
61246: LD_VAR 0 1
61250: PUSH
61251: LD_EXP 107
61255: PUSH
61256: LD_VAR 0 4
61260: ARRAY
61261: IN
61262: PUSH
61263: LD_VAR 0 1
61267: PUSH
61268: LD_EXP 108
61272: PUSH
61273: LD_VAR 0 4
61277: ARRAY
61278: IN
61279: NOT
61280: AND
61281: IFFALSE 61329
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
61283: LD_ADDR_EXP 108
61287: PUSH
61288: LD_EXP 108
61292: PPUSH
61293: LD_VAR 0 4
61297: PUSH
61298: LD_EXP 108
61302: PUSH
61303: LD_VAR 0 4
61307: ARRAY
61308: PUSH
61309: LD_INT 1
61311: PLUS
61312: PUSH
61313: EMPTY
61314: LIST
61315: LIST
61316: PPUSH
61317: LD_VAR 0 1
61321: PPUSH
61322: CALL 68319 0 3
61326: ST_TO_ADDR
// break ;
61327: GO 61331
// end ; end ;
61329: GO 61243
61331: POP
61332: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
61333: LD_VAR 0 1
61337: PPUSH
61338: CALL_OW 257
61342: PUSH
61343: LD_EXP 125
61347: IN
61348: PUSH
61349: LD_VAR 0 1
61353: PPUSH
61354: CALL_OW 266
61358: PUSH
61359: LD_INT 5
61361: EQUAL
61362: AND
61363: PUSH
61364: LD_VAR 0 2
61368: PPUSH
61369: CALL_OW 110
61373: PUSH
61374: LD_INT 18
61376: NONEQUAL
61377: AND
61378: IFFALSE 61418
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
61380: LD_VAR 0 2
61384: PPUSH
61385: CALL_OW 257
61389: PUSH
61390: LD_INT 5
61392: PUSH
61393: LD_INT 8
61395: PUSH
61396: LD_INT 9
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: LIST
61403: IN
61404: IFFALSE 61418
// SetClass ( unit , 1 ) ;
61406: LD_VAR 0 2
61410: PPUSH
61411: LD_INT 1
61413: PPUSH
61414: CALL_OW 336
// end ;
61418: LD_VAR 0 3
61422: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
61423: LD_INT 0
61425: PPUSH
61426: PPUSH
// if not mc_bases or not skirmish then
61427: LD_EXP 99
61431: NOT
61432: PUSH
61433: LD_EXP 97
61437: NOT
61438: OR
61439: IFFALSE 61443
// exit ;
61441: GO 61559
// if GetLives ( abandoned_vehicle ) > 250 then
61443: LD_VAR 0 2
61447: PPUSH
61448: CALL_OW 256
61452: PUSH
61453: LD_INT 250
61455: GREATER
61456: IFFALSE 61460
// exit ;
61458: GO 61559
// for i = 1 to mc_bases do
61460: LD_ADDR_VAR 0 6
61464: PUSH
61465: DOUBLE
61466: LD_INT 1
61468: DEC
61469: ST_TO_ADDR
61470: LD_EXP 99
61474: PUSH
61475: FOR_TO
61476: IFFALSE 61557
// begin if driver in mc_bases [ i ] then
61478: LD_VAR 0 1
61482: PUSH
61483: LD_EXP 99
61487: PUSH
61488: LD_VAR 0 6
61492: ARRAY
61493: IN
61494: IFFALSE 61555
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
61496: LD_VAR 0 1
61500: PPUSH
61501: LD_EXP 99
61505: PUSH
61506: LD_VAR 0 6
61510: ARRAY
61511: PPUSH
61512: LD_INT 2
61514: PUSH
61515: LD_INT 30
61517: PUSH
61518: LD_INT 0
61520: PUSH
61521: EMPTY
61522: LIST
61523: LIST
61524: PUSH
61525: LD_INT 30
61527: PUSH
61528: LD_INT 1
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: PUSH
61535: EMPTY
61536: LIST
61537: LIST
61538: LIST
61539: PPUSH
61540: CALL_OW 72
61544: PUSH
61545: LD_INT 1
61547: ARRAY
61548: PPUSH
61549: CALL_OW 112
// break ;
61553: GO 61557
// end ; end ;
61555: GO 61475
61557: POP
61558: POP
// end ; end_of_file
61559: LD_VAR 0 5
61563: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
61564: LD_INT 0
61566: PPUSH
61567: PPUSH
// if exist_mode then
61568: LD_VAR 0 2
61572: IFFALSE 61597
// unit := CreateCharacter ( prefix & ident ) else
61574: LD_ADDR_VAR 0 5
61578: PUSH
61579: LD_VAR 0 3
61583: PUSH
61584: LD_VAR 0 1
61588: STR
61589: PPUSH
61590: CALL_OW 34
61594: ST_TO_ADDR
61595: GO 61612
// unit := NewCharacter ( ident ) ;
61597: LD_ADDR_VAR 0 5
61601: PUSH
61602: LD_VAR 0 1
61606: PPUSH
61607: CALL_OW 25
61611: ST_TO_ADDR
// result := unit ;
61612: LD_ADDR_VAR 0 4
61616: PUSH
61617: LD_VAR 0 5
61621: ST_TO_ADDR
// end ;
61622: LD_VAR 0 4
61626: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
61627: LD_INT 0
61629: PPUSH
61630: PPUSH
// if not side or not nation then
61631: LD_VAR 0 1
61635: NOT
61636: PUSH
61637: LD_VAR 0 2
61641: NOT
61642: OR
61643: IFFALSE 61647
// exit ;
61645: GO 62283
// case nation of nation_american :
61647: LD_VAR 0 2
61651: PUSH
61652: LD_INT 1
61654: DOUBLE
61655: EQUAL
61656: IFTRUE 61660
61658: GO 61830
61660: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
61661: LD_ADDR_VAR 0 4
61665: PUSH
61666: LD_INT 35
61668: PUSH
61669: LD_INT 45
61671: PUSH
61672: LD_INT 46
61674: PUSH
61675: LD_INT 47
61677: PUSH
61678: LD_INT 1
61680: PUSH
61681: LD_INT 2
61683: PUSH
61684: LD_INT 6
61686: PUSH
61687: LD_INT 15
61689: PUSH
61690: LD_INT 16
61692: PUSH
61693: LD_INT 7
61695: PUSH
61696: LD_INT 12
61698: PUSH
61699: LD_INT 13
61701: PUSH
61702: LD_INT 10
61704: PUSH
61705: LD_INT 14
61707: PUSH
61708: LD_INT 20
61710: PUSH
61711: LD_INT 21
61713: PUSH
61714: LD_INT 22
61716: PUSH
61717: LD_INT 25
61719: PUSH
61720: LD_INT 32
61722: PUSH
61723: LD_INT 27
61725: PUSH
61726: LD_INT 36
61728: PUSH
61729: LD_INT 69
61731: PUSH
61732: LD_INT 39
61734: PUSH
61735: LD_INT 34
61737: PUSH
61738: LD_INT 40
61740: PUSH
61741: LD_INT 48
61743: PUSH
61744: LD_INT 49
61746: PUSH
61747: LD_INT 50
61749: PUSH
61750: LD_INT 51
61752: PUSH
61753: LD_INT 52
61755: PUSH
61756: LD_INT 53
61758: PUSH
61759: LD_INT 54
61761: PUSH
61762: LD_INT 55
61764: PUSH
61765: LD_INT 56
61767: PUSH
61768: LD_INT 57
61770: PUSH
61771: LD_INT 58
61773: PUSH
61774: LD_INT 59
61776: PUSH
61777: LD_INT 60
61779: PUSH
61780: LD_INT 61
61782: PUSH
61783: LD_INT 62
61785: PUSH
61786: EMPTY
61787: LIST
61788: LIST
61789: LIST
61790: LIST
61791: LIST
61792: LIST
61793: LIST
61794: LIST
61795: LIST
61796: LIST
61797: LIST
61798: LIST
61799: LIST
61800: LIST
61801: LIST
61802: LIST
61803: LIST
61804: LIST
61805: LIST
61806: LIST
61807: LIST
61808: LIST
61809: LIST
61810: LIST
61811: LIST
61812: LIST
61813: LIST
61814: LIST
61815: LIST
61816: LIST
61817: LIST
61818: LIST
61819: LIST
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: LIST
61826: LIST
61827: ST_TO_ADDR
61828: GO 62207
61830: LD_INT 2
61832: DOUBLE
61833: EQUAL
61834: IFTRUE 61838
61836: GO 62016
61838: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
61839: LD_ADDR_VAR 0 4
61843: PUSH
61844: LD_INT 35
61846: PUSH
61847: LD_INT 45
61849: PUSH
61850: LD_INT 46
61852: PUSH
61853: LD_INT 47
61855: PUSH
61856: LD_INT 70
61858: PUSH
61859: LD_INT 1
61861: PUSH
61862: LD_INT 11
61864: PUSH
61865: LD_INT 3
61867: PUSH
61868: LD_INT 4
61870: PUSH
61871: LD_INT 5
61873: PUSH
61874: LD_INT 6
61876: PUSH
61877: LD_INT 15
61879: PUSH
61880: LD_INT 18
61882: PUSH
61883: LD_INT 7
61885: PUSH
61886: LD_INT 17
61888: PUSH
61889: LD_INT 8
61891: PUSH
61892: LD_INT 20
61894: PUSH
61895: LD_INT 21
61897: PUSH
61898: LD_INT 22
61900: PUSH
61901: LD_INT 72
61903: PUSH
61904: LD_INT 26
61906: PUSH
61907: LD_INT 69
61909: PUSH
61910: LD_INT 39
61912: PUSH
61913: LD_INT 40
61915: PUSH
61916: LD_INT 41
61918: PUSH
61919: LD_INT 42
61921: PUSH
61922: LD_INT 43
61924: PUSH
61925: LD_INT 48
61927: PUSH
61928: LD_INT 49
61930: PUSH
61931: LD_INT 50
61933: PUSH
61934: LD_INT 51
61936: PUSH
61937: LD_INT 52
61939: PUSH
61940: LD_INT 53
61942: PUSH
61943: LD_INT 54
61945: PUSH
61946: LD_INT 55
61948: PUSH
61949: LD_INT 56
61951: PUSH
61952: LD_INT 60
61954: PUSH
61955: LD_INT 61
61957: PUSH
61958: LD_INT 62
61960: PUSH
61961: LD_INT 66
61963: PUSH
61964: LD_INT 67
61966: PUSH
61967: LD_INT 68
61969: PUSH
61970: EMPTY
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: LIST
61986: LIST
61987: LIST
61988: LIST
61989: LIST
61990: LIST
61991: LIST
61992: LIST
61993: LIST
61994: LIST
61995: LIST
61996: LIST
61997: LIST
61998: LIST
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: LIST
62004: LIST
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: ST_TO_ADDR
62014: GO 62207
62016: LD_INT 3
62018: DOUBLE
62019: EQUAL
62020: IFTRUE 62024
62022: GO 62206
62024: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
62025: LD_ADDR_VAR 0 4
62029: PUSH
62030: LD_INT 46
62032: PUSH
62033: LD_INT 47
62035: PUSH
62036: LD_INT 1
62038: PUSH
62039: LD_INT 2
62041: PUSH
62042: LD_INT 11
62044: PUSH
62045: LD_INT 9
62047: PUSH
62048: LD_INT 20
62050: PUSH
62051: LD_INT 19
62053: PUSH
62054: LD_INT 21
62056: PUSH
62057: LD_INT 24
62059: PUSH
62060: LD_INT 22
62062: PUSH
62063: LD_INT 25
62065: PUSH
62066: LD_INT 28
62068: PUSH
62069: LD_INT 29
62071: PUSH
62072: LD_INT 30
62074: PUSH
62075: LD_INT 31
62077: PUSH
62078: LD_INT 37
62080: PUSH
62081: LD_INT 38
62083: PUSH
62084: LD_INT 32
62086: PUSH
62087: LD_INT 27
62089: PUSH
62090: LD_INT 33
62092: PUSH
62093: LD_INT 69
62095: PUSH
62096: LD_INT 39
62098: PUSH
62099: LD_INT 34
62101: PUSH
62102: LD_INT 40
62104: PUSH
62105: LD_INT 71
62107: PUSH
62108: LD_INT 23
62110: PUSH
62111: LD_INT 44
62113: PUSH
62114: LD_INT 48
62116: PUSH
62117: LD_INT 49
62119: PUSH
62120: LD_INT 50
62122: PUSH
62123: LD_INT 51
62125: PUSH
62126: LD_INT 52
62128: PUSH
62129: LD_INT 53
62131: PUSH
62132: LD_INT 54
62134: PUSH
62135: LD_INT 55
62137: PUSH
62138: LD_INT 56
62140: PUSH
62141: LD_INT 57
62143: PUSH
62144: LD_INT 58
62146: PUSH
62147: LD_INT 59
62149: PUSH
62150: LD_INT 63
62152: PUSH
62153: LD_INT 64
62155: PUSH
62156: LD_INT 65
62158: PUSH
62159: EMPTY
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: LIST
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: LIST
62184: LIST
62185: LIST
62186: LIST
62187: LIST
62188: LIST
62189: LIST
62190: LIST
62191: LIST
62192: LIST
62193: LIST
62194: LIST
62195: LIST
62196: LIST
62197: LIST
62198: LIST
62199: LIST
62200: LIST
62201: LIST
62202: LIST
62203: ST_TO_ADDR
62204: GO 62207
62206: POP
// if state > - 1 and state < 3 then
62207: LD_VAR 0 3
62211: PUSH
62212: LD_INT 1
62214: NEG
62215: GREATER
62216: PUSH
62217: LD_VAR 0 3
62221: PUSH
62222: LD_INT 3
62224: LESS
62225: AND
62226: IFFALSE 62283
// for i in result do
62228: LD_ADDR_VAR 0 5
62232: PUSH
62233: LD_VAR 0 4
62237: PUSH
62238: FOR_IN
62239: IFFALSE 62281
// if GetTech ( i , side ) <> state then
62241: LD_VAR 0 5
62245: PPUSH
62246: LD_VAR 0 1
62250: PPUSH
62251: CALL_OW 321
62255: PUSH
62256: LD_VAR 0 3
62260: NONEQUAL
62261: IFFALSE 62279
// result := result diff i ;
62263: LD_ADDR_VAR 0 4
62267: PUSH
62268: LD_VAR 0 4
62272: PUSH
62273: LD_VAR 0 5
62277: DIFF
62278: ST_TO_ADDR
62279: GO 62238
62281: POP
62282: POP
// end ;
62283: LD_VAR 0 4
62287: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
62288: LD_INT 0
62290: PPUSH
62291: PPUSH
62292: PPUSH
// result := true ;
62293: LD_ADDR_VAR 0 3
62297: PUSH
62298: LD_INT 1
62300: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
62301: LD_ADDR_VAR 0 5
62305: PUSH
62306: LD_VAR 0 2
62310: PPUSH
62311: CALL_OW 480
62315: ST_TO_ADDR
// if not tmp then
62316: LD_VAR 0 5
62320: NOT
62321: IFFALSE 62325
// exit ;
62323: GO 62374
// for i in tmp do
62325: LD_ADDR_VAR 0 4
62329: PUSH
62330: LD_VAR 0 5
62334: PUSH
62335: FOR_IN
62336: IFFALSE 62372
// if GetTech ( i , side ) <> state_researched then
62338: LD_VAR 0 4
62342: PPUSH
62343: LD_VAR 0 1
62347: PPUSH
62348: CALL_OW 321
62352: PUSH
62353: LD_INT 2
62355: NONEQUAL
62356: IFFALSE 62370
// begin result := false ;
62358: LD_ADDR_VAR 0 3
62362: PUSH
62363: LD_INT 0
62365: ST_TO_ADDR
// exit ;
62366: POP
62367: POP
62368: GO 62374
// end ;
62370: GO 62335
62372: POP
62373: POP
// end ;
62374: LD_VAR 0 3
62378: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
62379: LD_INT 0
62381: PPUSH
62382: PPUSH
62383: PPUSH
62384: PPUSH
62385: PPUSH
62386: PPUSH
62387: PPUSH
62388: PPUSH
62389: PPUSH
62390: PPUSH
62391: PPUSH
62392: PPUSH
62393: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
62394: LD_VAR 0 1
62398: NOT
62399: PUSH
62400: LD_VAR 0 1
62404: PPUSH
62405: CALL_OW 257
62409: PUSH
62410: LD_INT 9
62412: NONEQUAL
62413: OR
62414: IFFALSE 62418
// exit ;
62416: GO 62991
// side := GetSide ( unit ) ;
62418: LD_ADDR_VAR 0 9
62422: PUSH
62423: LD_VAR 0 1
62427: PPUSH
62428: CALL_OW 255
62432: ST_TO_ADDR
// tech_space := tech_spacanom ;
62433: LD_ADDR_VAR 0 12
62437: PUSH
62438: LD_INT 29
62440: ST_TO_ADDR
// tech_time := tech_taurad ;
62441: LD_ADDR_VAR 0 13
62445: PUSH
62446: LD_INT 28
62448: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
62449: LD_ADDR_VAR 0 11
62453: PUSH
62454: LD_VAR 0 1
62458: PPUSH
62459: CALL_OW 310
62463: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
62464: LD_VAR 0 11
62468: PPUSH
62469: CALL_OW 247
62473: PUSH
62474: LD_INT 2
62476: EQUAL
62477: IFFALSE 62481
// exit ;
62479: GO 62991
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62481: LD_ADDR_VAR 0 8
62485: PUSH
62486: LD_INT 81
62488: PUSH
62489: LD_VAR 0 9
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 3
62500: PUSH
62501: LD_INT 21
62503: PUSH
62504: LD_INT 3
62506: PUSH
62507: EMPTY
62508: LIST
62509: LIST
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PPUSH
62519: CALL_OW 69
62523: ST_TO_ADDR
// if not tmp then
62524: LD_VAR 0 8
62528: NOT
62529: IFFALSE 62533
// exit ;
62531: GO 62991
// if in_unit then
62533: LD_VAR 0 11
62537: IFFALSE 62561
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
62539: LD_ADDR_VAR 0 10
62543: PUSH
62544: LD_VAR 0 8
62548: PPUSH
62549: LD_VAR 0 11
62553: PPUSH
62554: CALL_OW 74
62558: ST_TO_ADDR
62559: GO 62581
// enemy := NearestUnitToUnit ( tmp , unit ) ;
62561: LD_ADDR_VAR 0 10
62565: PUSH
62566: LD_VAR 0 8
62570: PPUSH
62571: LD_VAR 0 1
62575: PPUSH
62576: CALL_OW 74
62580: ST_TO_ADDR
// if not enemy then
62581: LD_VAR 0 10
62585: NOT
62586: IFFALSE 62590
// exit ;
62588: GO 62991
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
62590: LD_VAR 0 11
62594: PUSH
62595: LD_VAR 0 11
62599: PPUSH
62600: LD_VAR 0 10
62604: PPUSH
62605: CALL_OW 296
62609: PUSH
62610: LD_INT 13
62612: GREATER
62613: AND
62614: PUSH
62615: LD_VAR 0 1
62619: PPUSH
62620: LD_VAR 0 10
62624: PPUSH
62625: CALL_OW 296
62629: PUSH
62630: LD_INT 12
62632: GREATER
62633: OR
62634: IFFALSE 62638
// exit ;
62636: GO 62991
// missile := [ 1 ] ;
62638: LD_ADDR_VAR 0 14
62642: PUSH
62643: LD_INT 1
62645: PUSH
62646: EMPTY
62647: LIST
62648: ST_TO_ADDR
// if Researched ( side , tech_space ) then
62649: LD_VAR 0 9
62653: PPUSH
62654: LD_VAR 0 12
62658: PPUSH
62659: CALL_OW 325
62663: IFFALSE 62692
// missile := Insert ( missile , missile + 1 , 2 ) ;
62665: LD_ADDR_VAR 0 14
62669: PUSH
62670: LD_VAR 0 14
62674: PPUSH
62675: LD_VAR 0 14
62679: PUSH
62680: LD_INT 1
62682: PLUS
62683: PPUSH
62684: LD_INT 2
62686: PPUSH
62687: CALL_OW 2
62691: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
62692: LD_VAR 0 9
62696: PPUSH
62697: LD_VAR 0 13
62701: PPUSH
62702: CALL_OW 325
62706: PUSH
62707: LD_VAR 0 10
62711: PPUSH
62712: CALL_OW 255
62716: PPUSH
62717: LD_VAR 0 13
62721: PPUSH
62722: CALL_OW 325
62726: NOT
62727: AND
62728: IFFALSE 62757
// missile := Insert ( missile , missile + 1 , 3 ) ;
62730: LD_ADDR_VAR 0 14
62734: PUSH
62735: LD_VAR 0 14
62739: PPUSH
62740: LD_VAR 0 14
62744: PUSH
62745: LD_INT 1
62747: PLUS
62748: PPUSH
62749: LD_INT 3
62751: PPUSH
62752: CALL_OW 2
62756: ST_TO_ADDR
// if missile < 2 then
62757: LD_VAR 0 14
62761: PUSH
62762: LD_INT 2
62764: LESS
62765: IFFALSE 62769
// exit ;
62767: GO 62991
// x := GetX ( enemy ) ;
62769: LD_ADDR_VAR 0 4
62773: PUSH
62774: LD_VAR 0 10
62778: PPUSH
62779: CALL_OW 250
62783: ST_TO_ADDR
// y := GetY ( enemy ) ;
62784: LD_ADDR_VAR 0 5
62788: PUSH
62789: LD_VAR 0 10
62793: PPUSH
62794: CALL_OW 251
62798: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
62799: LD_ADDR_VAR 0 6
62803: PUSH
62804: LD_VAR 0 4
62808: PUSH
62809: LD_INT 1
62811: NEG
62812: PPUSH
62813: LD_INT 1
62815: PPUSH
62816: CALL_OW 12
62820: PLUS
62821: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
62822: LD_ADDR_VAR 0 7
62826: PUSH
62827: LD_VAR 0 5
62831: PUSH
62832: LD_INT 1
62834: NEG
62835: PPUSH
62836: LD_INT 1
62838: PPUSH
62839: CALL_OW 12
62843: PLUS
62844: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62845: LD_VAR 0 6
62849: PPUSH
62850: LD_VAR 0 7
62854: PPUSH
62855: CALL_OW 488
62859: NOT
62860: IFFALSE 62882
// begin _x := x ;
62862: LD_ADDR_VAR 0 6
62866: PUSH
62867: LD_VAR 0 4
62871: ST_TO_ADDR
// _y := y ;
62872: LD_ADDR_VAR 0 7
62876: PUSH
62877: LD_VAR 0 5
62881: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
62882: LD_ADDR_VAR 0 3
62886: PUSH
62887: LD_INT 1
62889: PPUSH
62890: LD_VAR 0 14
62894: PPUSH
62895: CALL_OW 12
62899: ST_TO_ADDR
// case i of 1 :
62900: LD_VAR 0 3
62904: PUSH
62905: LD_INT 1
62907: DOUBLE
62908: EQUAL
62909: IFTRUE 62913
62911: GO 62930
62913: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
62914: LD_VAR 0 1
62918: PPUSH
62919: LD_VAR 0 10
62923: PPUSH
62924: CALL_OW 115
62928: GO 62991
62930: LD_INT 2
62932: DOUBLE
62933: EQUAL
62934: IFTRUE 62938
62936: GO 62960
62938: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62939: LD_VAR 0 1
62943: PPUSH
62944: LD_VAR 0 6
62948: PPUSH
62949: LD_VAR 0 7
62953: PPUSH
62954: CALL_OW 153
62958: GO 62991
62960: LD_INT 3
62962: DOUBLE
62963: EQUAL
62964: IFTRUE 62968
62966: GO 62990
62968: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62969: LD_VAR 0 1
62973: PPUSH
62974: LD_VAR 0 6
62978: PPUSH
62979: LD_VAR 0 7
62983: PPUSH
62984: CALL_OW 154
62988: GO 62991
62990: POP
// end ;
62991: LD_VAR 0 2
62995: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62996: LD_INT 0
62998: PPUSH
62999: PPUSH
63000: PPUSH
63001: PPUSH
63002: PPUSH
63003: PPUSH
// if not unit or not building then
63004: LD_VAR 0 1
63008: NOT
63009: PUSH
63010: LD_VAR 0 2
63014: NOT
63015: OR
63016: IFFALSE 63020
// exit ;
63018: GO 63178
// x := GetX ( building ) ;
63020: LD_ADDR_VAR 0 5
63024: PUSH
63025: LD_VAR 0 2
63029: PPUSH
63030: CALL_OW 250
63034: ST_TO_ADDR
// y := GetY ( building ) ;
63035: LD_ADDR_VAR 0 6
63039: PUSH
63040: LD_VAR 0 2
63044: PPUSH
63045: CALL_OW 251
63049: ST_TO_ADDR
// for i = 0 to 5 do
63050: LD_ADDR_VAR 0 4
63054: PUSH
63055: DOUBLE
63056: LD_INT 0
63058: DEC
63059: ST_TO_ADDR
63060: LD_INT 5
63062: PUSH
63063: FOR_TO
63064: IFFALSE 63176
// begin _x := ShiftX ( x , i , 3 ) ;
63066: LD_ADDR_VAR 0 7
63070: PUSH
63071: LD_VAR 0 5
63075: PPUSH
63076: LD_VAR 0 4
63080: PPUSH
63081: LD_INT 3
63083: PPUSH
63084: CALL_OW 272
63088: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
63089: LD_ADDR_VAR 0 8
63093: PUSH
63094: LD_VAR 0 6
63098: PPUSH
63099: LD_VAR 0 4
63103: PPUSH
63104: LD_INT 3
63106: PPUSH
63107: CALL_OW 273
63111: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63112: LD_VAR 0 7
63116: PPUSH
63117: LD_VAR 0 8
63121: PPUSH
63122: CALL_OW 488
63126: NOT
63127: IFFALSE 63131
// continue ;
63129: GO 63063
// if HexInfo ( _x , _y ) = 0 then
63131: LD_VAR 0 7
63135: PPUSH
63136: LD_VAR 0 8
63140: PPUSH
63141: CALL_OW 428
63145: PUSH
63146: LD_INT 0
63148: EQUAL
63149: IFFALSE 63174
// begin ComMoveXY ( unit , _x , _y ) ;
63151: LD_VAR 0 1
63155: PPUSH
63156: LD_VAR 0 7
63160: PPUSH
63161: LD_VAR 0 8
63165: PPUSH
63166: CALL_OW 111
// exit ;
63170: POP
63171: POP
63172: GO 63178
// end ; end ;
63174: GO 63063
63176: POP
63177: POP
// end ;
63178: LD_VAR 0 3
63182: RET
// export function ScanBase ( side , base_area ) ; begin
63183: LD_INT 0
63185: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
63186: LD_ADDR_VAR 0 3
63190: PUSH
63191: LD_VAR 0 2
63195: PPUSH
63196: LD_INT 81
63198: PUSH
63199: LD_VAR 0 1
63203: PUSH
63204: EMPTY
63205: LIST
63206: LIST
63207: PPUSH
63208: CALL_OW 70
63212: ST_TO_ADDR
// end ;
63213: LD_VAR 0 3
63217: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
63218: LD_INT 0
63220: PPUSH
63221: PPUSH
63222: PPUSH
63223: PPUSH
63224: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
63225: LD_VAR 0 1
63229: NOT
63230: PUSH
63231: LD_EXP 99
63235: PUSH
63236: LD_VAR 0 1
63240: ARRAY
63241: NOT
63242: OR
63243: PUSH
63244: LD_VAR 0 2
63248: NOT
63249: OR
63250: PUSH
63251: LD_VAR 0 3
63255: NOT
63256: OR
63257: IFFALSE 63261
// exit ;
63259: GO 63711
// side := mc_sides [ base ] ;
63261: LD_ADDR_VAR 0 6
63265: PUSH
63266: LD_EXP 125
63270: PUSH
63271: LD_VAR 0 1
63275: ARRAY
63276: ST_TO_ADDR
// if not side then
63277: LD_VAR 0 6
63281: NOT
63282: IFFALSE 63286
// exit ;
63284: GO 63711
// for i in solds do
63286: LD_ADDR_VAR 0 7
63290: PUSH
63291: LD_VAR 0 2
63295: PUSH
63296: FOR_IN
63297: IFFALSE 63358
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
63299: LD_VAR 0 7
63303: PPUSH
63304: CALL_OW 310
63308: PPUSH
63309: CALL_OW 266
63313: PUSH
63314: LD_INT 32
63316: PUSH
63317: LD_INT 31
63319: PUSH
63320: EMPTY
63321: LIST
63322: LIST
63323: IN
63324: IFFALSE 63344
// solds := solds diff i else
63326: LD_ADDR_VAR 0 2
63330: PUSH
63331: LD_VAR 0 2
63335: PUSH
63336: LD_VAR 0 7
63340: DIFF
63341: ST_TO_ADDR
63342: GO 63356
// SetTag ( i , 18 ) ;
63344: LD_VAR 0 7
63348: PPUSH
63349: LD_INT 18
63351: PPUSH
63352: CALL_OW 109
63356: GO 63296
63358: POP
63359: POP
// if not solds then
63360: LD_VAR 0 2
63364: NOT
63365: IFFALSE 63369
// exit ;
63367: GO 63711
// repeat wait ( 0 0$1 ) ;
63369: LD_INT 35
63371: PPUSH
63372: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
63376: LD_ADDR_VAR 0 5
63380: PUSH
63381: LD_VAR 0 6
63385: PPUSH
63386: LD_VAR 0 3
63390: PPUSH
63391: CALL 63183 0 2
63395: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
63396: LD_VAR 0 5
63400: NOT
63401: PUSH
63402: LD_VAR 0 5
63406: PUSH
63407: LD_INT 3
63409: GREATER
63410: OR
63411: PUSH
63412: LD_EXP 121
63416: PUSH
63417: LD_VAR 0 1
63421: ARRAY
63422: OR
63423: IFFALSE 63464
// begin for i in solds do
63425: LD_ADDR_VAR 0 7
63429: PUSH
63430: LD_VAR 0 2
63434: PUSH
63435: FOR_IN
63436: IFFALSE 63460
// if HasTask ( i ) then
63438: LD_VAR 0 7
63442: PPUSH
63443: CALL_OW 314
63447: IFFALSE 63458
// ComStop ( i ) ;
63449: LD_VAR 0 7
63453: PPUSH
63454: CALL_OW 141
63458: GO 63435
63460: POP
63461: POP
// break ;
63462: GO 63699
// end ; for i in solds do
63464: LD_ADDR_VAR 0 7
63468: PUSH
63469: LD_VAR 0 2
63473: PUSH
63474: FOR_IN
63475: IFFALSE 63691
// begin if IsInUnit ( i ) then
63477: LD_VAR 0 7
63481: PPUSH
63482: CALL_OW 310
63486: IFFALSE 63497
// ComExitBuilding ( i ) ;
63488: LD_VAR 0 7
63492: PPUSH
63493: CALL_OW 122
// if GetLives ( i ) > 333 then
63497: LD_VAR 0 7
63501: PPUSH
63502: CALL_OW 256
63506: PUSH
63507: LD_INT 333
63509: GREATER
63510: IFFALSE 63538
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
63512: LD_VAR 0 7
63516: PPUSH
63517: LD_VAR 0 5
63521: PPUSH
63522: LD_VAR 0 7
63526: PPUSH
63527: CALL_OW 74
63531: PPUSH
63532: CALL_OW 115
63536: GO 63689
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
63538: LD_ADDR_VAR 0 8
63542: PUSH
63543: LD_EXP 99
63547: PUSH
63548: LD_VAR 0 1
63552: ARRAY
63553: PPUSH
63554: LD_INT 2
63556: PUSH
63557: LD_INT 30
63559: PUSH
63560: LD_INT 0
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 30
63569: PUSH
63570: LD_INT 1
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 30
63579: PUSH
63580: LD_INT 6
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: PPUSH
63593: CALL_OW 72
63597: PPUSH
63598: LD_VAR 0 7
63602: PPUSH
63603: CALL_OW 74
63607: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
63608: LD_VAR 0 7
63612: PPUSH
63613: LD_VAR 0 8
63617: PPUSH
63618: CALL_OW 250
63622: PPUSH
63623: LD_INT 3
63625: PPUSH
63626: LD_INT 5
63628: PPUSH
63629: CALL_OW 272
63633: PPUSH
63634: LD_VAR 0 8
63638: PPUSH
63639: CALL_OW 251
63643: PPUSH
63644: LD_INT 3
63646: PPUSH
63647: LD_INT 5
63649: PPUSH
63650: CALL_OW 273
63654: PPUSH
63655: CALL_OW 111
// SetTag ( i , 0 ) ;
63659: LD_VAR 0 7
63663: PPUSH
63664: LD_INT 0
63666: PPUSH
63667: CALL_OW 109
// solds := solds diff i ;
63671: LD_ADDR_VAR 0 2
63675: PUSH
63676: LD_VAR 0 2
63680: PUSH
63681: LD_VAR 0 7
63685: DIFF
63686: ST_TO_ADDR
// continue ;
63687: GO 63474
// end ; end ;
63689: GO 63474
63691: POP
63692: POP
// until solds ;
63693: LD_VAR 0 2
63697: IFFALSE 63369
// MC_Reset ( base , 18 ) ;
63699: LD_VAR 0 1
63703: PPUSH
63704: LD_INT 18
63706: PPUSH
63707: CALL 36431 0 2
// end ;
63711: LD_VAR 0 4
63715: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
63716: LD_INT 0
63718: PPUSH
63719: PPUSH
63720: PPUSH
63721: PPUSH
63722: PPUSH
63723: PPUSH
63724: PPUSH
63725: PPUSH
63726: PPUSH
63727: PPUSH
63728: PPUSH
63729: PPUSH
63730: PPUSH
63731: PPUSH
63732: PPUSH
63733: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
63734: LD_ADDR_VAR 0 12
63738: PUSH
63739: LD_EXP 99
63743: PUSH
63744: LD_VAR 0 1
63748: ARRAY
63749: PPUSH
63750: LD_INT 25
63752: PUSH
63753: LD_INT 3
63755: PUSH
63756: EMPTY
63757: LIST
63758: LIST
63759: PPUSH
63760: CALL_OW 72
63764: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63765: LD_ADDR_VAR 0 8
63769: PUSH
63770: LD_EXP 99
63774: PUSH
63775: LD_VAR 0 1
63779: ARRAY
63780: PPUSH
63781: LD_INT 2
63783: PUSH
63784: LD_INT 25
63786: PUSH
63787: LD_INT 1
63789: PUSH
63790: EMPTY
63791: LIST
63792: LIST
63793: PUSH
63794: LD_INT 25
63796: PUSH
63797: LD_INT 5
63799: PUSH
63800: EMPTY
63801: LIST
63802: LIST
63803: PUSH
63804: LD_INT 25
63806: PUSH
63807: LD_INT 8
63809: PUSH
63810: EMPTY
63811: LIST
63812: LIST
63813: PUSH
63814: LD_INT 25
63816: PUSH
63817: LD_INT 9
63819: PUSH
63820: EMPTY
63821: LIST
63822: LIST
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: PPUSH
63831: CALL_OW 72
63835: ST_TO_ADDR
// if not defenders and not solds then
63836: LD_VAR 0 2
63840: NOT
63841: PUSH
63842: LD_VAR 0 8
63846: NOT
63847: AND
63848: IFFALSE 63852
// exit ;
63850: GO 65218
// depot_under_attack := false ;
63852: LD_ADDR_VAR 0 16
63856: PUSH
63857: LD_INT 0
63859: ST_TO_ADDR
// sold_defenders := [ ] ;
63860: LD_ADDR_VAR 0 17
63864: PUSH
63865: EMPTY
63866: ST_TO_ADDR
// if mechs then
63867: LD_VAR 0 12
63871: IFFALSE 64000
// for i in defenders do
63873: LD_ADDR_VAR 0 5
63877: PUSH
63878: LD_VAR 0 2
63882: PUSH
63883: FOR_IN
63884: IFFALSE 63998
// begin SetTag ( i , 20 ) ;
63886: LD_VAR 0 5
63890: PPUSH
63891: LD_INT 20
63893: PPUSH
63894: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
63898: LD_VAR 0 5
63902: PPUSH
63903: CALL_OW 263
63907: PUSH
63908: LD_INT 1
63910: EQUAL
63911: PUSH
63912: LD_VAR 0 5
63916: PPUSH
63917: CALL_OW 311
63921: NOT
63922: AND
63923: PUSH
63924: LD_VAR 0 12
63928: AND
63929: IFFALSE 63996
// begin un := mechs [ 1 ] ;
63931: LD_ADDR_VAR 0 10
63935: PUSH
63936: LD_VAR 0 12
63940: PUSH
63941: LD_INT 1
63943: ARRAY
63944: ST_TO_ADDR
// ComExitBuilding ( un ) ;
63945: LD_VAR 0 10
63949: PPUSH
63950: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
63954: LD_VAR 0 10
63958: PPUSH
63959: LD_VAR 0 5
63963: PPUSH
63964: CALL_OW 180
// SetTag ( un , 19 ) ;
63968: LD_VAR 0 10
63972: PPUSH
63973: LD_INT 19
63975: PPUSH
63976: CALL_OW 109
// mechs := mechs diff un ;
63980: LD_ADDR_VAR 0 12
63984: PUSH
63985: LD_VAR 0 12
63989: PUSH
63990: LD_VAR 0 10
63994: DIFF
63995: ST_TO_ADDR
// end ; end ;
63996: GO 63883
63998: POP
63999: POP
// if solds then
64000: LD_VAR 0 8
64004: IFFALSE 64063
// for i in solds do
64006: LD_ADDR_VAR 0 5
64010: PUSH
64011: LD_VAR 0 8
64015: PUSH
64016: FOR_IN
64017: IFFALSE 64061
// if not GetTag ( i ) then
64019: LD_VAR 0 5
64023: PPUSH
64024: CALL_OW 110
64028: NOT
64029: IFFALSE 64059
// begin defenders := defenders union i ;
64031: LD_ADDR_VAR 0 2
64035: PUSH
64036: LD_VAR 0 2
64040: PUSH
64041: LD_VAR 0 5
64045: UNION
64046: ST_TO_ADDR
// SetTag ( i , 18 ) ;
64047: LD_VAR 0 5
64051: PPUSH
64052: LD_INT 18
64054: PPUSH
64055: CALL_OW 109
// end ;
64059: GO 64016
64061: POP
64062: POP
// repeat wait ( 0 0$1 ) ;
64063: LD_INT 35
64065: PPUSH
64066: CALL_OW 67
// enemy := mc_scan [ base ] ;
64070: LD_ADDR_VAR 0 3
64074: PUSH
64075: LD_EXP 122
64079: PUSH
64080: LD_VAR 0 1
64084: ARRAY
64085: ST_TO_ADDR
// for i in defenders do
64086: LD_ADDR_VAR 0 5
64090: PUSH
64091: LD_VAR 0 2
64095: PUSH
64096: FOR_IN
64097: IFFALSE 64782
// begin e := NearestUnitToUnit ( enemy , i ) ;
64099: LD_ADDR_VAR 0 13
64103: PUSH
64104: LD_VAR 0 3
64108: PPUSH
64109: LD_VAR 0 5
64113: PPUSH
64114: CALL_OW 74
64118: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
64119: LD_ADDR_VAR 0 16
64123: PUSH
64124: LD_EXP 99
64128: PUSH
64129: LD_VAR 0 1
64133: ARRAY
64134: PPUSH
64135: LD_INT 2
64137: PUSH
64138: LD_INT 30
64140: PUSH
64141: LD_INT 0
64143: PUSH
64144: EMPTY
64145: LIST
64146: LIST
64147: PUSH
64148: LD_INT 30
64150: PUSH
64151: LD_INT 1
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: PUSH
64158: EMPTY
64159: LIST
64160: LIST
64161: LIST
64162: PPUSH
64163: CALL_OW 72
64167: NOT
64168: PUSH
64169: LD_EXP 99
64173: PUSH
64174: LD_VAR 0 1
64178: ARRAY
64179: PPUSH
64180: LD_INT 2
64182: PUSH
64183: LD_INT 30
64185: PUSH
64186: LD_INT 0
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 30
64195: PUSH
64196: LD_INT 1
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: LIST
64207: PPUSH
64208: CALL_OW 72
64212: PPUSH
64213: CALL_OW 256
64217: PUSH
64218: LD_INT 600
64220: LESS
64221: OR
64222: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
64223: LD_VAR 0 5
64227: PPUSH
64228: CALL_OW 247
64232: PUSH
64233: LD_INT 2
64235: DOUBLE
64236: EQUAL
64237: IFTRUE 64241
64239: GO 64488
64241: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
64242: LD_VAR 0 5
64246: PPUSH
64247: CALL_OW 256
64251: PUSH
64252: LD_INT 650
64254: GREATER
64255: PUSH
64256: LD_VAR 0 5
64260: PPUSH
64261: LD_VAR 0 13
64265: PPUSH
64266: CALL_OW 296
64270: PUSH
64271: LD_INT 40
64273: LESS
64274: AND
64275: IFFALSE 64293
// ComAttackUnit ( i , e ) else
64277: LD_VAR 0 5
64281: PPUSH
64282: LD_VAR 0 13
64286: PPUSH
64287: CALL_OW 115
64291: GO 64371
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
64293: LD_VAR 0 5
64297: PPUSH
64298: LD_VAR 0 13
64302: PPUSH
64303: CALL_OW 296
64307: PUSH
64308: LD_INT 30
64310: GREATEREQUAL
64311: PUSH
64312: LD_VAR 0 5
64316: PPUSH
64317: CALL_OW 256
64321: PUSH
64322: LD_INT 650
64324: LESSEQUAL
64325: OR
64326: PUSH
64327: LD_VAR 0 5
64331: PPUSH
64332: LD_EXP 123
64336: PUSH
64337: LD_VAR 0 1
64341: ARRAY
64342: PPUSH
64343: CALL_OW 308
64347: NOT
64348: AND
64349: IFFALSE 64371
// ComMoveToArea ( i , mc_parking [ base ] ) ;
64351: LD_VAR 0 5
64355: PPUSH
64356: LD_EXP 123
64360: PUSH
64361: LD_VAR 0 1
64365: ARRAY
64366: PPUSH
64367: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
64371: LD_VAR 0 5
64375: PPUSH
64376: CALL_OW 256
64380: PUSH
64381: LD_INT 998
64383: LESS
64384: PUSH
64385: LD_VAR 0 5
64389: PPUSH
64390: CALL_OW 263
64394: PUSH
64395: LD_INT 1
64397: EQUAL
64398: AND
64399: PUSH
64400: LD_VAR 0 5
64404: PPUSH
64405: CALL_OW 311
64409: AND
64410: PUSH
64411: LD_VAR 0 5
64415: PPUSH
64416: LD_EXP 123
64420: PUSH
64421: LD_VAR 0 1
64425: ARRAY
64426: PPUSH
64427: CALL_OW 308
64431: AND
64432: IFFALSE 64486
// begin mech := IsDrivenBy ( i ) ;
64434: LD_ADDR_VAR 0 9
64438: PUSH
64439: LD_VAR 0 5
64443: PPUSH
64444: CALL_OW 311
64448: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
64449: LD_VAR 0 9
64453: PPUSH
64454: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
64458: LD_VAR 0 9
64462: PPUSH
64463: LD_VAR 0 5
64467: PPUSH
64468: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
64472: LD_VAR 0 9
64476: PPUSH
64477: LD_VAR 0 5
64481: PPUSH
64482: CALL_OW 180
// end ; end ; unit_human :
64486: GO 64753
64488: LD_INT 1
64490: DOUBLE
64491: EQUAL
64492: IFTRUE 64496
64494: GO 64752
64496: POP
// begin b := IsInUnit ( i ) ;
64497: LD_ADDR_VAR 0 18
64501: PUSH
64502: LD_VAR 0 5
64506: PPUSH
64507: CALL_OW 310
64511: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
64512: LD_ADDR_VAR 0 19
64516: PUSH
64517: LD_VAR 0 18
64521: NOT
64522: PUSH
64523: LD_VAR 0 18
64527: PPUSH
64528: CALL_OW 266
64532: PUSH
64533: LD_INT 32
64535: PUSH
64536: LD_INT 31
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: IN
64543: OR
64544: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
64545: LD_VAR 0 16
64549: PUSH
64550: LD_VAR 0 2
64554: PPUSH
64555: LD_INT 21
64557: PUSH
64558: LD_INT 2
64560: PUSH
64561: EMPTY
64562: LIST
64563: LIST
64564: PPUSH
64565: CALL_OW 72
64569: PUSH
64570: LD_INT 1
64572: LESSEQUAL
64573: OR
64574: PUSH
64575: LD_VAR 0 19
64579: AND
64580: PUSH
64581: LD_VAR 0 5
64585: PUSH
64586: LD_VAR 0 17
64590: IN
64591: NOT
64592: AND
64593: IFFALSE 64686
// begin if b then
64595: LD_VAR 0 18
64599: IFFALSE 64648
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
64601: LD_VAR 0 18
64605: PPUSH
64606: LD_VAR 0 3
64610: PPUSH
64611: LD_VAR 0 18
64615: PPUSH
64616: CALL_OW 74
64620: PPUSH
64621: CALL_OW 296
64625: PUSH
64626: LD_INT 10
64628: LESS
64629: PUSH
64630: LD_VAR 0 18
64634: PPUSH
64635: CALL_OW 461
64639: PUSH
64640: LD_INT 7
64642: NONEQUAL
64643: AND
64644: IFFALSE 64648
// continue ;
64646: GO 64096
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
64648: LD_ADDR_VAR 0 17
64652: PUSH
64653: LD_VAR 0 17
64657: PPUSH
64658: LD_VAR 0 17
64662: PUSH
64663: LD_INT 1
64665: PLUS
64666: PPUSH
64667: LD_VAR 0 5
64671: PPUSH
64672: CALL_OW 1
64676: ST_TO_ADDR
// ComExitBuilding ( i ) ;
64677: LD_VAR 0 5
64681: PPUSH
64682: CALL_OW 122
// end ; if sold_defenders then
64686: LD_VAR 0 17
64690: IFFALSE 64750
// if i in sold_defenders then
64692: LD_VAR 0 5
64696: PUSH
64697: LD_VAR 0 17
64701: IN
64702: IFFALSE 64750
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
64704: LD_VAR 0 5
64708: PPUSH
64709: CALL_OW 314
64713: NOT
64714: PUSH
64715: LD_VAR 0 5
64719: PPUSH
64720: LD_VAR 0 13
64724: PPUSH
64725: CALL_OW 296
64729: PUSH
64730: LD_INT 30
64732: LESS
64733: AND
64734: IFFALSE 64750
// ComAttackUnit ( i , e ) ;
64736: LD_VAR 0 5
64740: PPUSH
64741: LD_VAR 0 13
64745: PPUSH
64746: CALL_OW 115
// end ; end ; end ;
64750: GO 64753
64752: POP
// if IsDead ( i ) then
64753: LD_VAR 0 5
64757: PPUSH
64758: CALL_OW 301
64762: IFFALSE 64780
// defenders := defenders diff i ;
64764: LD_ADDR_VAR 0 2
64768: PUSH
64769: LD_VAR 0 2
64773: PUSH
64774: LD_VAR 0 5
64778: DIFF
64779: ST_TO_ADDR
// end ;
64780: GO 64096
64782: POP
64783: POP
// until not enemy or not defenders ;
64784: LD_VAR 0 3
64788: NOT
64789: PUSH
64790: LD_VAR 0 2
64794: NOT
64795: OR
64796: IFFALSE 64063
// MC_Reset ( base , 18 ) ;
64798: LD_VAR 0 1
64802: PPUSH
64803: LD_INT 18
64805: PPUSH
64806: CALL 36431 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64810: LD_ADDR_VAR 0 2
64814: PUSH
64815: LD_VAR 0 2
64819: PUSH
64820: LD_VAR 0 2
64824: PPUSH
64825: LD_INT 2
64827: PUSH
64828: LD_INT 25
64830: PUSH
64831: LD_INT 1
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 25
64840: PUSH
64841: LD_INT 5
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PUSH
64848: LD_INT 25
64850: PUSH
64851: LD_INT 8
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PUSH
64858: LD_INT 25
64860: PUSH
64861: LD_INT 9
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: LIST
64874: PPUSH
64875: CALL_OW 72
64879: DIFF
64880: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
64881: LD_VAR 0 3
64885: NOT
64886: PUSH
64887: LD_VAR 0 2
64891: PPUSH
64892: LD_INT 21
64894: PUSH
64895: LD_INT 2
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PPUSH
64902: CALL_OW 72
64906: AND
64907: IFFALSE 65169
// begin tmp := FilterByTag ( defenders , 19 ) ;
64909: LD_ADDR_VAR 0 11
64913: PUSH
64914: LD_VAR 0 2
64918: PPUSH
64919: LD_INT 19
64921: PPUSH
64922: CALL 101516 0 2
64926: ST_TO_ADDR
// if tmp then
64927: LD_VAR 0 11
64931: IFFALSE 65001
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
64933: LD_ADDR_VAR 0 11
64937: PUSH
64938: LD_VAR 0 11
64942: PPUSH
64943: LD_INT 25
64945: PUSH
64946: LD_INT 3
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PPUSH
64953: CALL_OW 72
64957: ST_TO_ADDR
// if tmp then
64958: LD_VAR 0 11
64962: IFFALSE 65001
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
64964: LD_ADDR_EXP 111
64968: PUSH
64969: LD_EXP 111
64973: PPUSH
64974: LD_VAR 0 1
64978: PPUSH
64979: LD_EXP 111
64983: PUSH
64984: LD_VAR 0 1
64988: ARRAY
64989: PUSH
64990: LD_VAR 0 11
64994: UNION
64995: PPUSH
64996: CALL_OW 1
65000: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
65001: LD_VAR 0 1
65005: PPUSH
65006: LD_INT 19
65008: PPUSH
65009: CALL 36431 0 2
// repeat wait ( 0 0$1 ) ;
65013: LD_INT 35
65015: PPUSH
65016: CALL_OW 67
// for i in defenders do
65020: LD_ADDR_VAR 0 5
65024: PUSH
65025: LD_VAR 0 2
65029: PUSH
65030: FOR_IN
65031: IFFALSE 65120
// begin if not IsInArea ( i , mc_parking [ base ] ) then
65033: LD_VAR 0 5
65037: PPUSH
65038: LD_EXP 123
65042: PUSH
65043: LD_VAR 0 1
65047: ARRAY
65048: PPUSH
65049: CALL_OW 308
65053: NOT
65054: IFFALSE 65078
// ComMoveToArea ( i , mc_parking [ base ] ) else
65056: LD_VAR 0 5
65060: PPUSH
65061: LD_EXP 123
65065: PUSH
65066: LD_VAR 0 1
65070: ARRAY
65071: PPUSH
65072: CALL_OW 113
65076: GO 65118
// if GetControl ( i ) = control_manual then
65078: LD_VAR 0 5
65082: PPUSH
65083: CALL_OW 263
65087: PUSH
65088: LD_INT 1
65090: EQUAL
65091: IFFALSE 65118
// if IsDrivenBy ( i ) then
65093: LD_VAR 0 5
65097: PPUSH
65098: CALL_OW 311
65102: IFFALSE 65118
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
65104: LD_VAR 0 5
65108: PPUSH
65109: CALL_OW 311
65113: PPUSH
65114: CALL_OW 121
// end ;
65118: GO 65030
65120: POP
65121: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
65122: LD_VAR 0 2
65126: PPUSH
65127: LD_INT 95
65129: PUSH
65130: LD_EXP 123
65134: PUSH
65135: LD_VAR 0 1
65139: ARRAY
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PPUSH
65145: CALL_OW 72
65149: PUSH
65150: LD_VAR 0 2
65154: EQUAL
65155: PUSH
65156: LD_EXP 122
65160: PUSH
65161: LD_VAR 0 1
65165: ARRAY
65166: OR
65167: IFFALSE 65013
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
65169: LD_ADDR_EXP 121
65173: PUSH
65174: LD_EXP 121
65178: PPUSH
65179: LD_VAR 0 1
65183: PPUSH
65184: LD_EXP 121
65188: PUSH
65189: LD_VAR 0 1
65193: ARRAY
65194: PUSH
65195: LD_VAR 0 2
65199: UNION
65200: PPUSH
65201: CALL_OW 1
65205: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
65206: LD_VAR 0 1
65210: PPUSH
65211: LD_INT 20
65213: PPUSH
65214: CALL 36431 0 2
// end ;
65218: LD_VAR 0 4
65222: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65223: LD_INT 0
65225: PPUSH
65226: PPUSH
65227: PPUSH
65228: PPUSH
// result := false ;
65229: LD_ADDR_VAR 0 2
65233: PUSH
65234: LD_INT 0
65236: ST_TO_ADDR
// side := GetSide ( unit ) ;
65237: LD_ADDR_VAR 0 3
65241: PUSH
65242: LD_VAR 0 1
65246: PPUSH
65247: CALL_OW 255
65251: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65252: LD_ADDR_VAR 0 4
65256: PUSH
65257: LD_VAR 0 1
65261: PPUSH
65262: CALL_OW 248
65266: ST_TO_ADDR
// case nat of 1 :
65267: LD_VAR 0 4
65271: PUSH
65272: LD_INT 1
65274: DOUBLE
65275: EQUAL
65276: IFTRUE 65280
65278: GO 65291
65280: POP
// tech := tech_lassight ; 2 :
65281: LD_ADDR_VAR 0 5
65285: PUSH
65286: LD_INT 12
65288: ST_TO_ADDR
65289: GO 65330
65291: LD_INT 2
65293: DOUBLE
65294: EQUAL
65295: IFTRUE 65299
65297: GO 65310
65299: POP
// tech := tech_mortar ; 3 :
65300: LD_ADDR_VAR 0 5
65304: PUSH
65305: LD_INT 41
65307: ST_TO_ADDR
65308: GO 65330
65310: LD_INT 3
65312: DOUBLE
65313: EQUAL
65314: IFTRUE 65318
65316: GO 65329
65318: POP
// tech := tech_bazooka ; end ;
65319: LD_ADDR_VAR 0 5
65323: PUSH
65324: LD_INT 44
65326: ST_TO_ADDR
65327: GO 65330
65329: POP
// if Researched ( side , tech ) then
65330: LD_VAR 0 3
65334: PPUSH
65335: LD_VAR 0 5
65339: PPUSH
65340: CALL_OW 325
65344: IFFALSE 65371
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65346: LD_ADDR_VAR 0 2
65350: PUSH
65351: LD_INT 5
65353: PUSH
65354: LD_INT 8
65356: PUSH
65357: LD_INT 9
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: LIST
65364: PUSH
65365: LD_VAR 0 4
65369: ARRAY
65370: ST_TO_ADDR
// end ;
65371: LD_VAR 0 2
65375: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65376: LD_INT 0
65378: PPUSH
65379: PPUSH
65380: PPUSH
// if not mines then
65381: LD_VAR 0 2
65385: NOT
65386: IFFALSE 65390
// exit ;
65388: GO 65534
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65390: LD_ADDR_VAR 0 5
65394: PUSH
65395: LD_INT 81
65397: PUSH
65398: LD_VAR 0 1
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 3
65409: PUSH
65410: LD_INT 21
65412: PUSH
65413: LD_INT 3
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: EMPTY
65421: LIST
65422: LIST
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PPUSH
65428: CALL_OW 69
65432: ST_TO_ADDR
// for i in mines do
65433: LD_ADDR_VAR 0 4
65437: PUSH
65438: LD_VAR 0 2
65442: PUSH
65443: FOR_IN
65444: IFFALSE 65532
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65446: LD_VAR 0 4
65450: PUSH
65451: LD_INT 1
65453: ARRAY
65454: PPUSH
65455: LD_VAR 0 4
65459: PUSH
65460: LD_INT 2
65462: ARRAY
65463: PPUSH
65464: CALL_OW 458
65468: NOT
65469: IFFALSE 65473
// continue ;
65471: GO 65443
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65473: LD_VAR 0 4
65477: PUSH
65478: LD_INT 1
65480: ARRAY
65481: PPUSH
65482: LD_VAR 0 4
65486: PUSH
65487: LD_INT 2
65489: ARRAY
65490: PPUSH
65491: CALL_OW 428
65495: PUSH
65496: LD_VAR 0 5
65500: IN
65501: IFFALSE 65530
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65503: LD_VAR 0 4
65507: PUSH
65508: LD_INT 1
65510: ARRAY
65511: PPUSH
65512: LD_VAR 0 4
65516: PUSH
65517: LD_INT 2
65519: ARRAY
65520: PPUSH
65521: LD_VAR 0 1
65525: PPUSH
65526: CALL_OW 456
// end ;
65530: GO 65443
65532: POP
65533: POP
// end ;
65534: LD_VAR 0 3
65538: RET
// export function Count ( array ) ; var i ; begin
65539: LD_INT 0
65541: PPUSH
65542: PPUSH
// result := 0 ;
65543: LD_ADDR_VAR 0 2
65547: PUSH
65548: LD_INT 0
65550: ST_TO_ADDR
// for i in array do
65551: LD_ADDR_VAR 0 3
65555: PUSH
65556: LD_VAR 0 1
65560: PUSH
65561: FOR_IN
65562: IFFALSE 65586
// if i then
65564: LD_VAR 0 3
65568: IFFALSE 65584
// result := result + 1 ;
65570: LD_ADDR_VAR 0 2
65574: PUSH
65575: LD_VAR 0 2
65579: PUSH
65580: LD_INT 1
65582: PLUS
65583: ST_TO_ADDR
65584: GO 65561
65586: POP
65587: POP
// end ;
65588: LD_VAR 0 2
65592: RET
// export function IsEmpty ( building ) ; begin
65593: LD_INT 0
65595: PPUSH
// if not building then
65596: LD_VAR 0 1
65600: NOT
65601: IFFALSE 65605
// exit ;
65603: GO 65648
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65605: LD_ADDR_VAR 0 2
65609: PUSH
65610: LD_VAR 0 1
65614: PUSH
65615: LD_INT 22
65617: PUSH
65618: LD_VAR 0 1
65622: PPUSH
65623: CALL_OW 255
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: PUSH
65632: LD_INT 58
65634: PUSH
65635: EMPTY
65636: LIST
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PPUSH
65642: CALL_OW 69
65646: IN
65647: ST_TO_ADDR
// end ;
65648: LD_VAR 0 2
65652: RET
// export function IsNotFull ( building ) ; begin
65653: LD_INT 0
65655: PPUSH
// if not building then
65656: LD_VAR 0 1
65660: NOT
65661: IFFALSE 65665
// exit ;
65663: GO 65684
// result := UnitsInside ( building ) < 6 ;
65665: LD_ADDR_VAR 0 2
65669: PUSH
65670: LD_VAR 0 1
65674: PPUSH
65675: CALL_OW 313
65679: PUSH
65680: LD_INT 6
65682: LESS
65683: ST_TO_ADDR
// end ;
65684: LD_VAR 0 2
65688: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65689: LD_INT 0
65691: PPUSH
65692: PPUSH
65693: PPUSH
65694: PPUSH
// tmp := [ ] ;
65695: LD_ADDR_VAR 0 3
65699: PUSH
65700: EMPTY
65701: ST_TO_ADDR
// list := [ ] ;
65702: LD_ADDR_VAR 0 5
65706: PUSH
65707: EMPTY
65708: ST_TO_ADDR
// for i = 16 to 25 do
65709: LD_ADDR_VAR 0 4
65713: PUSH
65714: DOUBLE
65715: LD_INT 16
65717: DEC
65718: ST_TO_ADDR
65719: LD_INT 25
65721: PUSH
65722: FOR_TO
65723: IFFALSE 65796
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65725: LD_ADDR_VAR 0 3
65729: PUSH
65730: LD_VAR 0 3
65734: PUSH
65735: LD_INT 22
65737: PUSH
65738: LD_VAR 0 1
65742: PPUSH
65743: CALL_OW 255
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 91
65754: PUSH
65755: LD_VAR 0 1
65759: PUSH
65760: LD_INT 6
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 30
65770: PUSH
65771: LD_VAR 0 4
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: LIST
65784: PUSH
65785: EMPTY
65786: LIST
65787: PPUSH
65788: CALL_OW 69
65792: ADD
65793: ST_TO_ADDR
65794: GO 65722
65796: POP
65797: POP
// for i = 1 to tmp do
65798: LD_ADDR_VAR 0 4
65802: PUSH
65803: DOUBLE
65804: LD_INT 1
65806: DEC
65807: ST_TO_ADDR
65808: LD_VAR 0 3
65812: PUSH
65813: FOR_TO
65814: IFFALSE 65902
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65816: LD_ADDR_VAR 0 5
65820: PUSH
65821: LD_VAR 0 5
65825: PUSH
65826: LD_VAR 0 3
65830: PUSH
65831: LD_VAR 0 4
65835: ARRAY
65836: PPUSH
65837: CALL_OW 266
65841: PUSH
65842: LD_VAR 0 3
65846: PUSH
65847: LD_VAR 0 4
65851: ARRAY
65852: PPUSH
65853: CALL_OW 250
65857: PUSH
65858: LD_VAR 0 3
65862: PUSH
65863: LD_VAR 0 4
65867: ARRAY
65868: PPUSH
65869: CALL_OW 251
65873: PUSH
65874: LD_VAR 0 3
65878: PUSH
65879: LD_VAR 0 4
65883: ARRAY
65884: PPUSH
65885: CALL_OW 254
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: PUSH
65896: EMPTY
65897: LIST
65898: ADD
65899: ST_TO_ADDR
65900: GO 65813
65902: POP
65903: POP
// result := list ;
65904: LD_ADDR_VAR 0 2
65908: PUSH
65909: LD_VAR 0 5
65913: ST_TO_ADDR
// end ;
65914: LD_VAR 0 2
65918: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65919: LD_INT 0
65921: PPUSH
65922: PPUSH
65923: PPUSH
65924: PPUSH
65925: PPUSH
65926: PPUSH
65927: PPUSH
// if not factory then
65928: LD_VAR 0 1
65932: NOT
65933: IFFALSE 65937
// exit ;
65935: GO 66462
// if control = control_apeman then
65937: LD_VAR 0 4
65941: PUSH
65942: LD_INT 5
65944: EQUAL
65945: IFFALSE 66054
// begin tmp := UnitsInside ( factory ) ;
65947: LD_ADDR_VAR 0 8
65951: PUSH
65952: LD_VAR 0 1
65956: PPUSH
65957: CALL_OW 313
65961: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
65962: LD_VAR 0 8
65966: PPUSH
65967: LD_INT 25
65969: PUSH
65970: LD_INT 12
65972: PUSH
65973: EMPTY
65974: LIST
65975: LIST
65976: PPUSH
65977: CALL_OW 72
65981: NOT
65982: IFFALSE 65992
// control := control_manual ;
65984: LD_ADDR_VAR 0 4
65988: PUSH
65989: LD_INT 1
65991: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
65992: LD_ADDR_VAR 0 8
65996: PUSH
65997: LD_VAR 0 1
66001: PPUSH
66002: CALL 65689 0 1
66006: ST_TO_ADDR
// if tmp then
66007: LD_VAR 0 8
66011: IFFALSE 66054
// begin for i in tmp do
66013: LD_ADDR_VAR 0 7
66017: PUSH
66018: LD_VAR 0 8
66022: PUSH
66023: FOR_IN
66024: IFFALSE 66052
// if i [ 1 ] = b_ext_radar then
66026: LD_VAR 0 7
66030: PUSH
66031: LD_INT 1
66033: ARRAY
66034: PUSH
66035: LD_INT 20
66037: EQUAL
66038: IFFALSE 66050
// begin control := control_remote ;
66040: LD_ADDR_VAR 0 4
66044: PUSH
66045: LD_INT 2
66047: ST_TO_ADDR
// break ;
66048: GO 66052
// end ;
66050: GO 66023
66052: POP
66053: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66054: LD_VAR 0 1
66058: PPUSH
66059: LD_VAR 0 2
66063: PPUSH
66064: LD_VAR 0 3
66068: PPUSH
66069: LD_VAR 0 4
66073: PPUSH
66074: LD_VAR 0 5
66078: PPUSH
66079: CALL_OW 448
66083: IFFALSE 66118
// begin result := [ chassis , engine , control , weapon ] ;
66085: LD_ADDR_VAR 0 6
66089: PUSH
66090: LD_VAR 0 2
66094: PUSH
66095: LD_VAR 0 3
66099: PUSH
66100: LD_VAR 0 4
66104: PUSH
66105: LD_VAR 0 5
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: LIST
66114: LIST
66115: ST_TO_ADDR
// exit ;
66116: GO 66462
// end ; _chassis := AvailableChassisList ( factory ) ;
66118: LD_ADDR_VAR 0 9
66122: PUSH
66123: LD_VAR 0 1
66127: PPUSH
66128: CALL_OW 475
66132: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66133: LD_ADDR_VAR 0 11
66137: PUSH
66138: LD_VAR 0 1
66142: PPUSH
66143: CALL_OW 476
66147: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66148: LD_ADDR_VAR 0 12
66152: PUSH
66153: LD_VAR 0 1
66157: PPUSH
66158: CALL_OW 477
66162: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66163: LD_ADDR_VAR 0 10
66167: PUSH
66168: LD_VAR 0 1
66172: PPUSH
66173: CALL_OW 478
66177: ST_TO_ADDR
// if not chassis in _chassis then
66178: LD_VAR 0 2
66182: PUSH
66183: LD_VAR 0 9
66187: IN
66188: NOT
66189: IFFALSE 66215
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66191: LD_ADDR_VAR 0 2
66195: PUSH
66196: LD_VAR 0 9
66200: PUSH
66201: LD_INT 1
66203: PPUSH
66204: LD_VAR 0 9
66208: PPUSH
66209: CALL_OW 12
66213: ARRAY
66214: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66215: LD_VAR 0 2
66219: PPUSH
66220: LD_VAR 0 3
66224: PPUSH
66225: CALL 66467 0 2
66229: NOT
66230: IFFALSE 66289
// repeat engine := _engine [ 1 ] ;
66232: LD_ADDR_VAR 0 3
66236: PUSH
66237: LD_VAR 0 11
66241: PUSH
66242: LD_INT 1
66244: ARRAY
66245: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66246: LD_ADDR_VAR 0 11
66250: PUSH
66251: LD_VAR 0 11
66255: PPUSH
66256: LD_INT 1
66258: PPUSH
66259: CALL_OW 3
66263: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66264: LD_VAR 0 2
66268: PPUSH
66269: LD_VAR 0 3
66273: PPUSH
66274: CALL 66467 0 2
66278: PUSH
66279: LD_VAR 0 11
66283: PUSH
66284: EMPTY
66285: EQUAL
66286: OR
66287: IFFALSE 66232
// if not control in _control then
66289: LD_VAR 0 4
66293: PUSH
66294: LD_VAR 0 12
66298: IN
66299: NOT
66300: IFFALSE 66326
// control := _control [ rand ( 1 , _control ) ] ;
66302: LD_ADDR_VAR 0 4
66306: PUSH
66307: LD_VAR 0 12
66311: PUSH
66312: LD_INT 1
66314: PPUSH
66315: LD_VAR 0 12
66319: PPUSH
66320: CALL_OW 12
66324: ARRAY
66325: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66326: LD_VAR 0 2
66330: PPUSH
66331: LD_VAR 0 5
66335: PPUSH
66336: CALL 66687 0 2
66340: NOT
66341: IFFALSE 66400
// repeat weapon := _weapon [ 1 ] ;
66343: LD_ADDR_VAR 0 5
66347: PUSH
66348: LD_VAR 0 10
66352: PUSH
66353: LD_INT 1
66355: ARRAY
66356: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66357: LD_ADDR_VAR 0 10
66361: PUSH
66362: LD_VAR 0 10
66366: PPUSH
66367: LD_INT 1
66369: PPUSH
66370: CALL_OW 3
66374: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66375: LD_VAR 0 2
66379: PPUSH
66380: LD_VAR 0 5
66384: PPUSH
66385: CALL 66687 0 2
66389: PUSH
66390: LD_VAR 0 10
66394: PUSH
66395: EMPTY
66396: EQUAL
66397: OR
66398: IFFALSE 66343
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66400: LD_VAR 0 1
66404: PPUSH
66405: LD_VAR 0 2
66409: PPUSH
66410: LD_VAR 0 3
66414: PPUSH
66415: LD_VAR 0 4
66419: PPUSH
66420: LD_VAR 0 5
66424: PPUSH
66425: CALL_OW 448
66429: IFFALSE 66462
// result := [ chassis , engine , control , weapon ] ;
66431: LD_ADDR_VAR 0 6
66435: PUSH
66436: LD_VAR 0 2
66440: PUSH
66441: LD_VAR 0 3
66445: PUSH
66446: LD_VAR 0 4
66450: PUSH
66451: LD_VAR 0 5
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: ST_TO_ADDR
// end ;
66462: LD_VAR 0 6
66466: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66467: LD_INT 0
66469: PPUSH
// if not chassis or not engine then
66470: LD_VAR 0 1
66474: NOT
66475: PUSH
66476: LD_VAR 0 2
66480: NOT
66481: OR
66482: IFFALSE 66486
// exit ;
66484: GO 66682
// case engine of engine_solar :
66486: LD_VAR 0 2
66490: PUSH
66491: LD_INT 2
66493: DOUBLE
66494: EQUAL
66495: IFTRUE 66499
66497: GO 66537
66499: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66500: LD_ADDR_VAR 0 3
66504: PUSH
66505: LD_INT 11
66507: PUSH
66508: LD_INT 12
66510: PUSH
66511: LD_INT 13
66513: PUSH
66514: LD_INT 14
66516: PUSH
66517: LD_INT 1
66519: PUSH
66520: LD_INT 2
66522: PUSH
66523: LD_INT 3
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: ST_TO_ADDR
66535: GO 66666
66537: LD_INT 1
66539: DOUBLE
66540: EQUAL
66541: IFTRUE 66545
66543: GO 66607
66545: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66546: LD_ADDR_VAR 0 3
66550: PUSH
66551: LD_INT 11
66553: PUSH
66554: LD_INT 12
66556: PUSH
66557: LD_INT 13
66559: PUSH
66560: LD_INT 14
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: LD_INT 2
66568: PUSH
66569: LD_INT 3
66571: PUSH
66572: LD_INT 4
66574: PUSH
66575: LD_INT 5
66577: PUSH
66578: LD_INT 21
66580: PUSH
66581: LD_INT 23
66583: PUSH
66584: LD_INT 22
66586: PUSH
66587: LD_INT 24
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: ST_TO_ADDR
66605: GO 66666
66607: LD_INT 3
66609: DOUBLE
66610: EQUAL
66611: IFTRUE 66615
66613: GO 66665
66615: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66616: LD_ADDR_VAR 0 3
66620: PUSH
66621: LD_INT 13
66623: PUSH
66624: LD_INT 14
66626: PUSH
66627: LD_INT 2
66629: PUSH
66630: LD_INT 3
66632: PUSH
66633: LD_INT 4
66635: PUSH
66636: LD_INT 5
66638: PUSH
66639: LD_INT 21
66641: PUSH
66642: LD_INT 22
66644: PUSH
66645: LD_INT 23
66647: PUSH
66648: LD_INT 24
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: ST_TO_ADDR
66663: GO 66666
66665: POP
// result := ( chassis in result ) ;
66666: LD_ADDR_VAR 0 3
66670: PUSH
66671: LD_VAR 0 1
66675: PUSH
66676: LD_VAR 0 3
66680: IN
66681: ST_TO_ADDR
// end ;
66682: LD_VAR 0 3
66686: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66687: LD_INT 0
66689: PPUSH
// if not chassis or not weapon then
66690: LD_VAR 0 1
66694: NOT
66695: PUSH
66696: LD_VAR 0 2
66700: NOT
66701: OR
66702: IFFALSE 66706
// exit ;
66704: GO 67732
// case weapon of us_machine_gun :
66706: LD_VAR 0 2
66710: PUSH
66711: LD_INT 2
66713: DOUBLE
66714: EQUAL
66715: IFTRUE 66719
66717: GO 66749
66719: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66720: LD_ADDR_VAR 0 3
66724: PUSH
66725: LD_INT 1
66727: PUSH
66728: LD_INT 2
66730: PUSH
66731: LD_INT 3
66733: PUSH
66734: LD_INT 4
66736: PUSH
66737: LD_INT 5
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: ST_TO_ADDR
66747: GO 67716
66749: LD_INT 3
66751: DOUBLE
66752: EQUAL
66753: IFTRUE 66757
66755: GO 66787
66757: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66758: LD_ADDR_VAR 0 3
66762: PUSH
66763: LD_INT 1
66765: PUSH
66766: LD_INT 2
66768: PUSH
66769: LD_INT 3
66771: PUSH
66772: LD_INT 4
66774: PUSH
66775: LD_INT 5
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: ST_TO_ADDR
66785: GO 67716
66787: LD_INT 11
66789: DOUBLE
66790: EQUAL
66791: IFTRUE 66795
66793: GO 66825
66795: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66796: LD_ADDR_VAR 0 3
66800: PUSH
66801: LD_INT 1
66803: PUSH
66804: LD_INT 2
66806: PUSH
66807: LD_INT 3
66809: PUSH
66810: LD_INT 4
66812: PUSH
66813: LD_INT 5
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: ST_TO_ADDR
66823: GO 67716
66825: LD_INT 4
66827: DOUBLE
66828: EQUAL
66829: IFTRUE 66833
66831: GO 66859
66833: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66834: LD_ADDR_VAR 0 3
66838: PUSH
66839: LD_INT 2
66841: PUSH
66842: LD_INT 3
66844: PUSH
66845: LD_INT 4
66847: PUSH
66848: LD_INT 5
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: ST_TO_ADDR
66857: GO 67716
66859: LD_INT 5
66861: DOUBLE
66862: EQUAL
66863: IFTRUE 66867
66865: GO 66893
66867: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66868: LD_ADDR_VAR 0 3
66872: PUSH
66873: LD_INT 2
66875: PUSH
66876: LD_INT 3
66878: PUSH
66879: LD_INT 4
66881: PUSH
66882: LD_INT 5
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: ST_TO_ADDR
66891: GO 67716
66893: LD_INT 9
66895: DOUBLE
66896: EQUAL
66897: IFTRUE 66901
66899: GO 66927
66901: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
66902: LD_ADDR_VAR 0 3
66906: PUSH
66907: LD_INT 2
66909: PUSH
66910: LD_INT 3
66912: PUSH
66913: LD_INT 4
66915: PUSH
66916: LD_INT 5
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: ST_TO_ADDR
66925: GO 67716
66927: LD_INT 7
66929: DOUBLE
66930: EQUAL
66931: IFTRUE 66935
66933: GO 66961
66935: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
66936: LD_ADDR_VAR 0 3
66940: PUSH
66941: LD_INT 2
66943: PUSH
66944: LD_INT 3
66946: PUSH
66947: LD_INT 4
66949: PUSH
66950: LD_INT 5
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: ST_TO_ADDR
66959: GO 67716
66961: LD_INT 12
66963: DOUBLE
66964: EQUAL
66965: IFTRUE 66969
66967: GO 66995
66969: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66970: LD_ADDR_VAR 0 3
66974: PUSH
66975: LD_INT 2
66977: PUSH
66978: LD_INT 3
66980: PUSH
66981: LD_INT 4
66983: PUSH
66984: LD_INT 5
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: ST_TO_ADDR
66993: GO 67716
66995: LD_INT 13
66997: DOUBLE
66998: EQUAL
66999: IFTRUE 67003
67001: GO 67029
67003: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67004: LD_ADDR_VAR 0 3
67008: PUSH
67009: LD_INT 2
67011: PUSH
67012: LD_INT 3
67014: PUSH
67015: LD_INT 4
67017: PUSH
67018: LD_INT 5
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: ST_TO_ADDR
67027: GO 67716
67029: LD_INT 14
67031: DOUBLE
67032: EQUAL
67033: IFTRUE 67037
67035: GO 67055
67037: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67038: LD_ADDR_VAR 0 3
67042: PUSH
67043: LD_INT 4
67045: PUSH
67046: LD_INT 5
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: ST_TO_ADDR
67053: GO 67716
67055: LD_INT 6
67057: DOUBLE
67058: EQUAL
67059: IFTRUE 67063
67061: GO 67081
67063: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67064: LD_ADDR_VAR 0 3
67068: PUSH
67069: LD_INT 4
67071: PUSH
67072: LD_INT 5
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: ST_TO_ADDR
67079: GO 67716
67081: LD_INT 10
67083: DOUBLE
67084: EQUAL
67085: IFTRUE 67089
67087: GO 67107
67089: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67090: LD_ADDR_VAR 0 3
67094: PUSH
67095: LD_INT 4
67097: PUSH
67098: LD_INT 5
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: ST_TO_ADDR
67105: GO 67716
67107: LD_INT 22
67109: DOUBLE
67110: EQUAL
67111: IFTRUE 67115
67113: GO 67141
67115: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67116: LD_ADDR_VAR 0 3
67120: PUSH
67121: LD_INT 11
67123: PUSH
67124: LD_INT 12
67126: PUSH
67127: LD_INT 13
67129: PUSH
67130: LD_INT 14
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: ST_TO_ADDR
67139: GO 67716
67141: LD_INT 23
67143: DOUBLE
67144: EQUAL
67145: IFTRUE 67149
67147: GO 67175
67149: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67150: LD_ADDR_VAR 0 3
67154: PUSH
67155: LD_INT 11
67157: PUSH
67158: LD_INT 12
67160: PUSH
67161: LD_INT 13
67163: PUSH
67164: LD_INT 14
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: ST_TO_ADDR
67173: GO 67716
67175: LD_INT 24
67177: DOUBLE
67178: EQUAL
67179: IFTRUE 67183
67181: GO 67209
67183: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67184: LD_ADDR_VAR 0 3
67188: PUSH
67189: LD_INT 11
67191: PUSH
67192: LD_INT 12
67194: PUSH
67195: LD_INT 13
67197: PUSH
67198: LD_INT 14
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: ST_TO_ADDR
67207: GO 67716
67209: LD_INT 30
67211: DOUBLE
67212: EQUAL
67213: IFTRUE 67217
67215: GO 67243
67217: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67218: LD_ADDR_VAR 0 3
67222: PUSH
67223: LD_INT 11
67225: PUSH
67226: LD_INT 12
67228: PUSH
67229: LD_INT 13
67231: PUSH
67232: LD_INT 14
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: ST_TO_ADDR
67241: GO 67716
67243: LD_INT 25
67245: DOUBLE
67246: EQUAL
67247: IFTRUE 67251
67249: GO 67269
67251: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67252: LD_ADDR_VAR 0 3
67256: PUSH
67257: LD_INT 13
67259: PUSH
67260: LD_INT 14
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: ST_TO_ADDR
67267: GO 67716
67269: LD_INT 27
67271: DOUBLE
67272: EQUAL
67273: IFTRUE 67277
67275: GO 67295
67277: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67278: LD_ADDR_VAR 0 3
67282: PUSH
67283: LD_INT 13
67285: PUSH
67286: LD_INT 14
67288: PUSH
67289: EMPTY
67290: LIST
67291: LIST
67292: ST_TO_ADDR
67293: GO 67716
67295: LD_INT 28
67297: DOUBLE
67298: EQUAL
67299: IFTRUE 67303
67301: GO 67321
67303: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67304: LD_ADDR_VAR 0 3
67308: PUSH
67309: LD_INT 13
67311: PUSH
67312: LD_INT 14
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: ST_TO_ADDR
67319: GO 67716
67321: LD_INT 29
67323: DOUBLE
67324: EQUAL
67325: IFTRUE 67329
67327: GO 67347
67329: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67330: LD_ADDR_VAR 0 3
67334: PUSH
67335: LD_INT 13
67337: PUSH
67338: LD_INT 14
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: ST_TO_ADDR
67345: GO 67716
67347: LD_INT 31
67349: DOUBLE
67350: EQUAL
67351: IFTRUE 67355
67353: GO 67373
67355: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67356: LD_ADDR_VAR 0 3
67360: PUSH
67361: LD_INT 13
67363: PUSH
67364: LD_INT 14
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: ST_TO_ADDR
67371: GO 67716
67373: LD_INT 26
67375: DOUBLE
67376: EQUAL
67377: IFTRUE 67381
67379: GO 67399
67381: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67382: LD_ADDR_VAR 0 3
67386: PUSH
67387: LD_INT 13
67389: PUSH
67390: LD_INT 14
67392: PUSH
67393: EMPTY
67394: LIST
67395: LIST
67396: ST_TO_ADDR
67397: GO 67716
67399: LD_INT 42
67401: DOUBLE
67402: EQUAL
67403: IFTRUE 67407
67405: GO 67433
67407: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67408: LD_ADDR_VAR 0 3
67412: PUSH
67413: LD_INT 21
67415: PUSH
67416: LD_INT 22
67418: PUSH
67419: LD_INT 23
67421: PUSH
67422: LD_INT 24
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: ST_TO_ADDR
67431: GO 67716
67433: LD_INT 43
67435: DOUBLE
67436: EQUAL
67437: IFTRUE 67441
67439: GO 67467
67441: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67442: LD_ADDR_VAR 0 3
67446: PUSH
67447: LD_INT 21
67449: PUSH
67450: LD_INT 22
67452: PUSH
67453: LD_INT 23
67455: PUSH
67456: LD_INT 24
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: ST_TO_ADDR
67465: GO 67716
67467: LD_INT 44
67469: DOUBLE
67470: EQUAL
67471: IFTRUE 67475
67473: GO 67501
67475: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67476: LD_ADDR_VAR 0 3
67480: PUSH
67481: LD_INT 21
67483: PUSH
67484: LD_INT 22
67486: PUSH
67487: LD_INT 23
67489: PUSH
67490: LD_INT 24
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: ST_TO_ADDR
67499: GO 67716
67501: LD_INT 45
67503: DOUBLE
67504: EQUAL
67505: IFTRUE 67509
67507: GO 67535
67509: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67510: LD_ADDR_VAR 0 3
67514: PUSH
67515: LD_INT 21
67517: PUSH
67518: LD_INT 22
67520: PUSH
67521: LD_INT 23
67523: PUSH
67524: LD_INT 24
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: ST_TO_ADDR
67533: GO 67716
67535: LD_INT 49
67537: DOUBLE
67538: EQUAL
67539: IFTRUE 67543
67541: GO 67569
67543: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67544: LD_ADDR_VAR 0 3
67548: PUSH
67549: LD_INT 21
67551: PUSH
67552: LD_INT 22
67554: PUSH
67555: LD_INT 23
67557: PUSH
67558: LD_INT 24
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: ST_TO_ADDR
67567: GO 67716
67569: LD_INT 51
67571: DOUBLE
67572: EQUAL
67573: IFTRUE 67577
67575: GO 67603
67577: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67578: LD_ADDR_VAR 0 3
67582: PUSH
67583: LD_INT 21
67585: PUSH
67586: LD_INT 22
67588: PUSH
67589: LD_INT 23
67591: PUSH
67592: LD_INT 24
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: ST_TO_ADDR
67601: GO 67716
67603: LD_INT 52
67605: DOUBLE
67606: EQUAL
67607: IFTRUE 67611
67609: GO 67637
67611: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67612: LD_ADDR_VAR 0 3
67616: PUSH
67617: LD_INT 21
67619: PUSH
67620: LD_INT 22
67622: PUSH
67623: LD_INT 23
67625: PUSH
67626: LD_INT 24
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: ST_TO_ADDR
67635: GO 67716
67637: LD_INT 53
67639: DOUBLE
67640: EQUAL
67641: IFTRUE 67645
67643: GO 67663
67645: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67646: LD_ADDR_VAR 0 3
67650: PUSH
67651: LD_INT 23
67653: PUSH
67654: LD_INT 24
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: ST_TO_ADDR
67661: GO 67716
67663: LD_INT 46
67665: DOUBLE
67666: EQUAL
67667: IFTRUE 67671
67669: GO 67689
67671: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67672: LD_ADDR_VAR 0 3
67676: PUSH
67677: LD_INT 23
67679: PUSH
67680: LD_INT 24
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: ST_TO_ADDR
67687: GO 67716
67689: LD_INT 47
67691: DOUBLE
67692: EQUAL
67693: IFTRUE 67697
67695: GO 67715
67697: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67698: LD_ADDR_VAR 0 3
67702: PUSH
67703: LD_INT 23
67705: PUSH
67706: LD_INT 24
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: ST_TO_ADDR
67713: GO 67716
67715: POP
// result := ( chassis in result ) ;
67716: LD_ADDR_VAR 0 3
67720: PUSH
67721: LD_VAR 0 1
67725: PUSH
67726: LD_VAR 0 3
67730: IN
67731: ST_TO_ADDR
// end ;
67732: LD_VAR 0 3
67736: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67737: LD_INT 0
67739: PPUSH
67740: PPUSH
67741: PPUSH
67742: PPUSH
67743: PPUSH
67744: PPUSH
67745: PPUSH
// result := array ;
67746: LD_ADDR_VAR 0 5
67750: PUSH
67751: LD_VAR 0 1
67755: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67756: LD_VAR 0 1
67760: NOT
67761: PUSH
67762: LD_VAR 0 2
67766: NOT
67767: OR
67768: PUSH
67769: LD_VAR 0 3
67773: NOT
67774: OR
67775: PUSH
67776: LD_VAR 0 2
67780: PUSH
67781: LD_VAR 0 1
67785: GREATER
67786: OR
67787: PUSH
67788: LD_VAR 0 3
67792: PUSH
67793: LD_VAR 0 1
67797: GREATER
67798: OR
67799: IFFALSE 67803
// exit ;
67801: GO 68099
// if direction then
67803: LD_VAR 0 4
67807: IFFALSE 67871
// begin d := 1 ;
67809: LD_ADDR_VAR 0 9
67813: PUSH
67814: LD_INT 1
67816: ST_TO_ADDR
// if i_from > i_to then
67817: LD_VAR 0 2
67821: PUSH
67822: LD_VAR 0 3
67826: GREATER
67827: IFFALSE 67853
// length := ( array - i_from ) + i_to else
67829: LD_ADDR_VAR 0 11
67833: PUSH
67834: LD_VAR 0 1
67838: PUSH
67839: LD_VAR 0 2
67843: MINUS
67844: PUSH
67845: LD_VAR 0 3
67849: PLUS
67850: ST_TO_ADDR
67851: GO 67869
// length := i_to - i_from ;
67853: LD_ADDR_VAR 0 11
67857: PUSH
67858: LD_VAR 0 3
67862: PUSH
67863: LD_VAR 0 2
67867: MINUS
67868: ST_TO_ADDR
// end else
67869: GO 67932
// begin d := - 1 ;
67871: LD_ADDR_VAR 0 9
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: ST_TO_ADDR
// if i_from > i_to then
67880: LD_VAR 0 2
67884: PUSH
67885: LD_VAR 0 3
67889: GREATER
67890: IFFALSE 67910
// length := i_from - i_to else
67892: LD_ADDR_VAR 0 11
67896: PUSH
67897: LD_VAR 0 2
67901: PUSH
67902: LD_VAR 0 3
67906: MINUS
67907: ST_TO_ADDR
67908: GO 67932
// length := ( array - i_to ) + i_from ;
67910: LD_ADDR_VAR 0 11
67914: PUSH
67915: LD_VAR 0 1
67919: PUSH
67920: LD_VAR 0 3
67924: MINUS
67925: PUSH
67926: LD_VAR 0 2
67930: PLUS
67931: ST_TO_ADDR
// end ; if not length then
67932: LD_VAR 0 11
67936: NOT
67937: IFFALSE 67941
// exit ;
67939: GO 68099
// tmp := array ;
67941: LD_ADDR_VAR 0 10
67945: PUSH
67946: LD_VAR 0 1
67950: ST_TO_ADDR
// for i = 1 to length do
67951: LD_ADDR_VAR 0 6
67955: PUSH
67956: DOUBLE
67957: LD_INT 1
67959: DEC
67960: ST_TO_ADDR
67961: LD_VAR 0 11
67965: PUSH
67966: FOR_TO
67967: IFFALSE 68087
// begin for j = 1 to array do
67969: LD_ADDR_VAR 0 7
67973: PUSH
67974: DOUBLE
67975: LD_INT 1
67977: DEC
67978: ST_TO_ADDR
67979: LD_VAR 0 1
67983: PUSH
67984: FOR_TO
67985: IFFALSE 68073
// begin k := j + d ;
67987: LD_ADDR_VAR 0 8
67991: PUSH
67992: LD_VAR 0 7
67996: PUSH
67997: LD_VAR 0 9
68001: PLUS
68002: ST_TO_ADDR
// if k > array then
68003: LD_VAR 0 8
68007: PUSH
68008: LD_VAR 0 1
68012: GREATER
68013: IFFALSE 68023
// k := 1 ;
68015: LD_ADDR_VAR 0 8
68019: PUSH
68020: LD_INT 1
68022: ST_TO_ADDR
// if not k then
68023: LD_VAR 0 8
68027: NOT
68028: IFFALSE 68040
// k := array ;
68030: LD_ADDR_VAR 0 8
68034: PUSH
68035: LD_VAR 0 1
68039: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68040: LD_ADDR_VAR 0 10
68044: PUSH
68045: LD_VAR 0 10
68049: PPUSH
68050: LD_VAR 0 8
68054: PPUSH
68055: LD_VAR 0 1
68059: PUSH
68060: LD_VAR 0 7
68064: ARRAY
68065: PPUSH
68066: CALL_OW 1
68070: ST_TO_ADDR
// end ;
68071: GO 67984
68073: POP
68074: POP
// array := tmp ;
68075: LD_ADDR_VAR 0 1
68079: PUSH
68080: LD_VAR 0 10
68084: ST_TO_ADDR
// end ;
68085: GO 67966
68087: POP
68088: POP
// result := array ;
68089: LD_ADDR_VAR 0 5
68093: PUSH
68094: LD_VAR 0 1
68098: ST_TO_ADDR
// end ;
68099: LD_VAR 0 5
68103: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68104: LD_INT 0
68106: PPUSH
68107: PPUSH
// result := 0 ;
68108: LD_ADDR_VAR 0 3
68112: PUSH
68113: LD_INT 0
68115: ST_TO_ADDR
// if not array or not value in array then
68116: LD_VAR 0 1
68120: NOT
68121: PUSH
68122: LD_VAR 0 2
68126: PUSH
68127: LD_VAR 0 1
68131: IN
68132: NOT
68133: OR
68134: IFFALSE 68138
// exit ;
68136: GO 68192
// for i = 1 to array do
68138: LD_ADDR_VAR 0 4
68142: PUSH
68143: DOUBLE
68144: LD_INT 1
68146: DEC
68147: ST_TO_ADDR
68148: LD_VAR 0 1
68152: PUSH
68153: FOR_TO
68154: IFFALSE 68190
// if value = array [ i ] then
68156: LD_VAR 0 2
68160: PUSH
68161: LD_VAR 0 1
68165: PUSH
68166: LD_VAR 0 4
68170: ARRAY
68171: EQUAL
68172: IFFALSE 68188
// begin result := i ;
68174: LD_ADDR_VAR 0 3
68178: PUSH
68179: LD_VAR 0 4
68183: ST_TO_ADDR
// exit ;
68184: POP
68185: POP
68186: GO 68192
// end ;
68188: GO 68153
68190: POP
68191: POP
// end ;
68192: LD_VAR 0 3
68196: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68197: LD_INT 0
68199: PPUSH
// vc_chassis := chassis ;
68200: LD_ADDR_OWVAR 37
68204: PUSH
68205: LD_VAR 0 1
68209: ST_TO_ADDR
// vc_engine := engine ;
68210: LD_ADDR_OWVAR 39
68214: PUSH
68215: LD_VAR 0 2
68219: ST_TO_ADDR
// vc_control := control ;
68220: LD_ADDR_OWVAR 38
68224: PUSH
68225: LD_VAR 0 3
68229: ST_TO_ADDR
// vc_weapon := weapon ;
68230: LD_ADDR_OWVAR 40
68234: PUSH
68235: LD_VAR 0 4
68239: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68240: LD_ADDR_OWVAR 41
68244: PUSH
68245: LD_VAR 0 5
68249: ST_TO_ADDR
// end ;
68250: LD_VAR 0 6
68254: RET
// export function WantPlant ( unit ) ; var task ; begin
68255: LD_INT 0
68257: PPUSH
68258: PPUSH
// result := false ;
68259: LD_ADDR_VAR 0 2
68263: PUSH
68264: LD_INT 0
68266: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68267: LD_ADDR_VAR 0 3
68271: PUSH
68272: LD_VAR 0 1
68276: PPUSH
68277: CALL_OW 437
68281: ST_TO_ADDR
// if task then
68282: LD_VAR 0 3
68286: IFFALSE 68314
// if task [ 1 ] [ 1 ] = p then
68288: LD_VAR 0 3
68292: PUSH
68293: LD_INT 1
68295: ARRAY
68296: PUSH
68297: LD_INT 1
68299: ARRAY
68300: PUSH
68301: LD_STRING p
68303: EQUAL
68304: IFFALSE 68314
// result := true ;
68306: LD_ADDR_VAR 0 2
68310: PUSH
68311: LD_INT 1
68313: ST_TO_ADDR
// end ;
68314: LD_VAR 0 2
68318: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68319: LD_INT 0
68321: PPUSH
68322: PPUSH
68323: PPUSH
68324: PPUSH
// if pos < 1 then
68325: LD_VAR 0 2
68329: PUSH
68330: LD_INT 1
68332: LESS
68333: IFFALSE 68337
// exit ;
68335: GO 68640
// if pos = 1 then
68337: LD_VAR 0 2
68341: PUSH
68342: LD_INT 1
68344: EQUAL
68345: IFFALSE 68378
// result := Replace ( arr , pos [ 1 ] , value ) else
68347: LD_ADDR_VAR 0 4
68351: PUSH
68352: LD_VAR 0 1
68356: PPUSH
68357: LD_VAR 0 2
68361: PUSH
68362: LD_INT 1
68364: ARRAY
68365: PPUSH
68366: LD_VAR 0 3
68370: PPUSH
68371: CALL_OW 1
68375: ST_TO_ADDR
68376: GO 68640
// begin tmp := arr ;
68378: LD_ADDR_VAR 0 6
68382: PUSH
68383: LD_VAR 0 1
68387: ST_TO_ADDR
// s_arr := [ tmp ] ;
68388: LD_ADDR_VAR 0 7
68392: PUSH
68393: LD_VAR 0 6
68397: PUSH
68398: EMPTY
68399: LIST
68400: ST_TO_ADDR
// for i = 1 to pos - 1 do
68401: LD_ADDR_VAR 0 5
68405: PUSH
68406: DOUBLE
68407: LD_INT 1
68409: DEC
68410: ST_TO_ADDR
68411: LD_VAR 0 2
68415: PUSH
68416: LD_INT 1
68418: MINUS
68419: PUSH
68420: FOR_TO
68421: IFFALSE 68466
// begin tmp := tmp [ pos [ i ] ] ;
68423: LD_ADDR_VAR 0 6
68427: PUSH
68428: LD_VAR 0 6
68432: PUSH
68433: LD_VAR 0 2
68437: PUSH
68438: LD_VAR 0 5
68442: ARRAY
68443: ARRAY
68444: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68445: LD_ADDR_VAR 0 7
68449: PUSH
68450: LD_VAR 0 7
68454: PUSH
68455: LD_VAR 0 6
68459: PUSH
68460: EMPTY
68461: LIST
68462: ADD
68463: ST_TO_ADDR
// end ;
68464: GO 68420
68466: POP
68467: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68468: LD_ADDR_VAR 0 6
68472: PUSH
68473: LD_VAR 0 6
68477: PPUSH
68478: LD_VAR 0 2
68482: PUSH
68483: LD_VAR 0 2
68487: ARRAY
68488: PPUSH
68489: LD_VAR 0 3
68493: PPUSH
68494: CALL_OW 1
68498: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68499: LD_ADDR_VAR 0 7
68503: PUSH
68504: LD_VAR 0 7
68508: PPUSH
68509: LD_VAR 0 7
68513: PPUSH
68514: LD_VAR 0 6
68518: PPUSH
68519: CALL_OW 1
68523: ST_TO_ADDR
// for i = s_arr downto 2 do
68524: LD_ADDR_VAR 0 5
68528: PUSH
68529: DOUBLE
68530: LD_VAR 0 7
68534: INC
68535: ST_TO_ADDR
68536: LD_INT 2
68538: PUSH
68539: FOR_DOWNTO
68540: IFFALSE 68624
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68542: LD_ADDR_VAR 0 6
68546: PUSH
68547: LD_VAR 0 7
68551: PUSH
68552: LD_VAR 0 5
68556: PUSH
68557: LD_INT 1
68559: MINUS
68560: ARRAY
68561: PPUSH
68562: LD_VAR 0 2
68566: PUSH
68567: LD_VAR 0 5
68571: PUSH
68572: LD_INT 1
68574: MINUS
68575: ARRAY
68576: PPUSH
68577: LD_VAR 0 7
68581: PUSH
68582: LD_VAR 0 5
68586: ARRAY
68587: PPUSH
68588: CALL_OW 1
68592: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68593: LD_ADDR_VAR 0 7
68597: PUSH
68598: LD_VAR 0 7
68602: PPUSH
68603: LD_VAR 0 5
68607: PUSH
68608: LD_INT 1
68610: MINUS
68611: PPUSH
68612: LD_VAR 0 6
68616: PPUSH
68617: CALL_OW 1
68621: ST_TO_ADDR
// end ;
68622: GO 68539
68624: POP
68625: POP
// result := s_arr [ 1 ] ;
68626: LD_ADDR_VAR 0 4
68630: PUSH
68631: LD_VAR 0 7
68635: PUSH
68636: LD_INT 1
68638: ARRAY
68639: ST_TO_ADDR
// end ; end ;
68640: LD_VAR 0 4
68644: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68645: LD_INT 0
68647: PPUSH
68648: PPUSH
// if not list then
68649: LD_VAR 0 1
68653: NOT
68654: IFFALSE 68658
// exit ;
68656: GO 68749
// i := list [ pos1 ] ;
68658: LD_ADDR_VAR 0 5
68662: PUSH
68663: LD_VAR 0 1
68667: PUSH
68668: LD_VAR 0 2
68672: ARRAY
68673: ST_TO_ADDR
// if not i then
68674: LD_VAR 0 5
68678: NOT
68679: IFFALSE 68683
// exit ;
68681: GO 68749
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68683: LD_ADDR_VAR 0 1
68687: PUSH
68688: LD_VAR 0 1
68692: PPUSH
68693: LD_VAR 0 2
68697: PPUSH
68698: LD_VAR 0 1
68702: PUSH
68703: LD_VAR 0 3
68707: ARRAY
68708: PPUSH
68709: CALL_OW 1
68713: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68714: LD_ADDR_VAR 0 1
68718: PUSH
68719: LD_VAR 0 1
68723: PPUSH
68724: LD_VAR 0 3
68728: PPUSH
68729: LD_VAR 0 5
68733: PPUSH
68734: CALL_OW 1
68738: ST_TO_ADDR
// result := list ;
68739: LD_ADDR_VAR 0 4
68743: PUSH
68744: LD_VAR 0 1
68748: ST_TO_ADDR
// end ;
68749: LD_VAR 0 4
68753: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68754: LD_INT 0
68756: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68757: LD_ADDR_VAR 0 5
68761: PUSH
68762: LD_VAR 0 1
68766: PPUSH
68767: CALL_OW 250
68771: PPUSH
68772: LD_VAR 0 1
68776: PPUSH
68777: CALL_OW 251
68781: PPUSH
68782: LD_VAR 0 2
68786: PPUSH
68787: LD_VAR 0 3
68791: PPUSH
68792: LD_VAR 0 4
68796: PPUSH
68797: CALL 68807 0 5
68801: ST_TO_ADDR
// end ;
68802: LD_VAR 0 5
68806: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68807: LD_INT 0
68809: PPUSH
68810: PPUSH
68811: PPUSH
68812: PPUSH
// if not list then
68813: LD_VAR 0 3
68817: NOT
68818: IFFALSE 68822
// exit ;
68820: GO 69210
// result := [ ] ;
68822: LD_ADDR_VAR 0 6
68826: PUSH
68827: EMPTY
68828: ST_TO_ADDR
// for i in list do
68829: LD_ADDR_VAR 0 7
68833: PUSH
68834: LD_VAR 0 3
68838: PUSH
68839: FOR_IN
68840: IFFALSE 69042
// begin tmp := GetDistUnitXY ( i , x , y ) ;
68842: LD_ADDR_VAR 0 9
68846: PUSH
68847: LD_VAR 0 7
68851: PPUSH
68852: LD_VAR 0 1
68856: PPUSH
68857: LD_VAR 0 2
68861: PPUSH
68862: CALL_OW 297
68866: ST_TO_ADDR
// if not result then
68867: LD_VAR 0 6
68871: NOT
68872: IFFALSE 68898
// result := [ [ i , tmp ] ] else
68874: LD_ADDR_VAR 0 6
68878: PUSH
68879: LD_VAR 0 7
68883: PUSH
68884: LD_VAR 0 9
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: EMPTY
68894: LIST
68895: ST_TO_ADDR
68896: GO 69040
// begin if result [ result ] [ 2 ] < tmp then
68898: LD_VAR 0 6
68902: PUSH
68903: LD_VAR 0 6
68907: ARRAY
68908: PUSH
68909: LD_INT 2
68911: ARRAY
68912: PUSH
68913: LD_VAR 0 9
68917: LESS
68918: IFFALSE 68960
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
68920: LD_ADDR_VAR 0 6
68924: PUSH
68925: LD_VAR 0 6
68929: PPUSH
68930: LD_VAR 0 6
68934: PUSH
68935: LD_INT 1
68937: PLUS
68938: PPUSH
68939: LD_VAR 0 7
68943: PUSH
68944: LD_VAR 0 9
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PPUSH
68953: CALL_OW 2
68957: ST_TO_ADDR
68958: GO 69040
// for j = 1 to result do
68960: LD_ADDR_VAR 0 8
68964: PUSH
68965: DOUBLE
68966: LD_INT 1
68968: DEC
68969: ST_TO_ADDR
68970: LD_VAR 0 6
68974: PUSH
68975: FOR_TO
68976: IFFALSE 69038
// begin if tmp < result [ j ] [ 2 ] then
68978: LD_VAR 0 9
68982: PUSH
68983: LD_VAR 0 6
68987: PUSH
68988: LD_VAR 0 8
68992: ARRAY
68993: PUSH
68994: LD_INT 2
68996: ARRAY
68997: LESS
68998: IFFALSE 69036
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69000: LD_ADDR_VAR 0 6
69004: PUSH
69005: LD_VAR 0 6
69009: PPUSH
69010: LD_VAR 0 8
69014: PPUSH
69015: LD_VAR 0 7
69019: PUSH
69020: LD_VAR 0 9
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PPUSH
69029: CALL_OW 2
69033: ST_TO_ADDR
// break ;
69034: GO 69038
// end ; end ;
69036: GO 68975
69038: POP
69039: POP
// end ; end ;
69040: GO 68839
69042: POP
69043: POP
// if result and not asc then
69044: LD_VAR 0 6
69048: PUSH
69049: LD_VAR 0 4
69053: NOT
69054: AND
69055: IFFALSE 69130
// begin tmp := result ;
69057: LD_ADDR_VAR 0 9
69061: PUSH
69062: LD_VAR 0 6
69066: ST_TO_ADDR
// for i = tmp downto 1 do
69067: LD_ADDR_VAR 0 7
69071: PUSH
69072: DOUBLE
69073: LD_VAR 0 9
69077: INC
69078: ST_TO_ADDR
69079: LD_INT 1
69081: PUSH
69082: FOR_DOWNTO
69083: IFFALSE 69128
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69085: LD_ADDR_VAR 0 6
69089: PUSH
69090: LD_VAR 0 6
69094: PPUSH
69095: LD_VAR 0 9
69099: PUSH
69100: LD_VAR 0 7
69104: MINUS
69105: PUSH
69106: LD_INT 1
69108: PLUS
69109: PPUSH
69110: LD_VAR 0 9
69114: PUSH
69115: LD_VAR 0 7
69119: ARRAY
69120: PPUSH
69121: CALL_OW 1
69125: ST_TO_ADDR
69126: GO 69082
69128: POP
69129: POP
// end ; tmp := [ ] ;
69130: LD_ADDR_VAR 0 9
69134: PUSH
69135: EMPTY
69136: ST_TO_ADDR
// if mode then
69137: LD_VAR 0 5
69141: IFFALSE 69210
// begin for i = 1 to result do
69143: LD_ADDR_VAR 0 7
69147: PUSH
69148: DOUBLE
69149: LD_INT 1
69151: DEC
69152: ST_TO_ADDR
69153: LD_VAR 0 6
69157: PUSH
69158: FOR_TO
69159: IFFALSE 69198
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69161: LD_ADDR_VAR 0 9
69165: PUSH
69166: LD_VAR 0 9
69170: PPUSH
69171: LD_VAR 0 7
69175: PPUSH
69176: LD_VAR 0 6
69180: PUSH
69181: LD_VAR 0 7
69185: ARRAY
69186: PUSH
69187: LD_INT 1
69189: ARRAY
69190: PPUSH
69191: CALL_OW 1
69195: ST_TO_ADDR
69196: GO 69158
69198: POP
69199: POP
// result := tmp ;
69200: LD_ADDR_VAR 0 6
69204: PUSH
69205: LD_VAR 0 9
69209: ST_TO_ADDR
// end ; end ;
69210: LD_VAR 0 6
69214: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69215: LD_INT 0
69217: PPUSH
69218: PPUSH
69219: PPUSH
69220: PPUSH
69221: PPUSH
69222: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69223: LD_ADDR_VAR 0 5
69227: PUSH
69228: LD_INT 0
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: LD_INT 0
69236: PUSH
69237: EMPTY
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: ST_TO_ADDR
// if not x or not y then
69245: LD_VAR 0 2
69249: NOT
69250: PUSH
69251: LD_VAR 0 3
69255: NOT
69256: OR
69257: IFFALSE 69261
// exit ;
69259: GO 70907
// if not range then
69261: LD_VAR 0 4
69265: NOT
69266: IFFALSE 69276
// range := 10 ;
69268: LD_ADDR_VAR 0 4
69272: PUSH
69273: LD_INT 10
69275: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69276: LD_ADDR_VAR 0 8
69280: PUSH
69281: LD_INT 81
69283: PUSH
69284: LD_VAR 0 1
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 92
69295: PUSH
69296: LD_VAR 0 2
69300: PUSH
69301: LD_VAR 0 3
69305: PUSH
69306: LD_VAR 0 4
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 3
69319: PUSH
69320: LD_INT 21
69322: PUSH
69323: LD_INT 3
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: LIST
69338: PPUSH
69339: CALL_OW 69
69343: ST_TO_ADDR
// if not tmp then
69344: LD_VAR 0 8
69348: NOT
69349: IFFALSE 69353
// exit ;
69351: GO 70907
// for i in tmp do
69353: LD_ADDR_VAR 0 6
69357: PUSH
69358: LD_VAR 0 8
69362: PUSH
69363: FOR_IN
69364: IFFALSE 70882
// begin points := [ 0 , 0 , 0 ] ;
69366: LD_ADDR_VAR 0 9
69370: PUSH
69371: LD_INT 0
69373: PUSH
69374: LD_INT 0
69376: PUSH
69377: LD_INT 0
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: LIST
69384: ST_TO_ADDR
// bpoints := 1 ;
69385: LD_ADDR_VAR 0 10
69389: PUSH
69390: LD_INT 1
69392: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69393: LD_VAR 0 6
69397: PPUSH
69398: CALL_OW 247
69402: PUSH
69403: LD_INT 1
69405: DOUBLE
69406: EQUAL
69407: IFTRUE 69411
69409: GO 69989
69411: POP
// begin if GetClass ( i ) = 1 then
69412: LD_VAR 0 6
69416: PPUSH
69417: CALL_OW 257
69421: PUSH
69422: LD_INT 1
69424: EQUAL
69425: IFFALSE 69446
// points := [ 10 , 5 , 3 ] ;
69427: LD_ADDR_VAR 0 9
69431: PUSH
69432: LD_INT 10
69434: PUSH
69435: LD_INT 5
69437: PUSH
69438: LD_INT 3
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: LIST
69445: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69446: LD_VAR 0 6
69450: PPUSH
69451: CALL_OW 257
69455: PUSH
69456: LD_INT 2
69458: PUSH
69459: LD_INT 3
69461: PUSH
69462: LD_INT 4
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: LIST
69469: IN
69470: IFFALSE 69491
// points := [ 3 , 2 , 1 ] ;
69472: LD_ADDR_VAR 0 9
69476: PUSH
69477: LD_INT 3
69479: PUSH
69480: LD_INT 2
69482: PUSH
69483: LD_INT 1
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: LIST
69490: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69491: LD_VAR 0 6
69495: PPUSH
69496: CALL_OW 257
69500: PUSH
69501: LD_INT 5
69503: EQUAL
69504: IFFALSE 69525
// points := [ 130 , 5 , 2 ] ;
69506: LD_ADDR_VAR 0 9
69510: PUSH
69511: LD_INT 130
69513: PUSH
69514: LD_INT 5
69516: PUSH
69517: LD_INT 2
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: LIST
69524: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69525: LD_VAR 0 6
69529: PPUSH
69530: CALL_OW 257
69534: PUSH
69535: LD_INT 8
69537: EQUAL
69538: IFFALSE 69559
// points := [ 35 , 35 , 30 ] ;
69540: LD_ADDR_VAR 0 9
69544: PUSH
69545: LD_INT 35
69547: PUSH
69548: LD_INT 35
69550: PUSH
69551: LD_INT 30
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: LIST
69558: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69559: LD_VAR 0 6
69563: PPUSH
69564: CALL_OW 257
69568: PUSH
69569: LD_INT 9
69571: EQUAL
69572: IFFALSE 69593
// points := [ 20 , 55 , 40 ] ;
69574: LD_ADDR_VAR 0 9
69578: PUSH
69579: LD_INT 20
69581: PUSH
69582: LD_INT 55
69584: PUSH
69585: LD_INT 40
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: LIST
69592: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69593: LD_VAR 0 6
69597: PPUSH
69598: CALL_OW 257
69602: PUSH
69603: LD_INT 12
69605: PUSH
69606: LD_INT 16
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: IN
69613: IFFALSE 69634
// points := [ 5 , 3 , 2 ] ;
69615: LD_ADDR_VAR 0 9
69619: PUSH
69620: LD_INT 5
69622: PUSH
69623: LD_INT 3
69625: PUSH
69626: LD_INT 2
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: LIST
69633: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69634: LD_VAR 0 6
69638: PPUSH
69639: CALL_OW 257
69643: PUSH
69644: LD_INT 17
69646: EQUAL
69647: IFFALSE 69668
// points := [ 100 , 50 , 75 ] ;
69649: LD_ADDR_VAR 0 9
69653: PUSH
69654: LD_INT 100
69656: PUSH
69657: LD_INT 50
69659: PUSH
69660: LD_INT 75
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: LIST
69667: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69668: LD_VAR 0 6
69672: PPUSH
69673: CALL_OW 257
69677: PUSH
69678: LD_INT 15
69680: EQUAL
69681: IFFALSE 69702
// points := [ 10 , 5 , 3 ] ;
69683: LD_ADDR_VAR 0 9
69687: PUSH
69688: LD_INT 10
69690: PUSH
69691: LD_INT 5
69693: PUSH
69694: LD_INT 3
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: LIST
69701: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69702: LD_VAR 0 6
69706: PPUSH
69707: CALL_OW 257
69711: PUSH
69712: LD_INT 14
69714: EQUAL
69715: IFFALSE 69736
// points := [ 10 , 0 , 0 ] ;
69717: LD_ADDR_VAR 0 9
69721: PUSH
69722: LD_INT 10
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: LD_INT 0
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69736: LD_VAR 0 6
69740: PPUSH
69741: CALL_OW 257
69745: PUSH
69746: LD_INT 11
69748: EQUAL
69749: IFFALSE 69770
// points := [ 30 , 10 , 5 ] ;
69751: LD_ADDR_VAR 0 9
69755: PUSH
69756: LD_INT 30
69758: PUSH
69759: LD_INT 10
69761: PUSH
69762: LD_INT 5
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: LIST
69769: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69770: LD_VAR 0 1
69774: PPUSH
69775: LD_INT 5
69777: PPUSH
69778: CALL_OW 321
69782: PUSH
69783: LD_INT 2
69785: EQUAL
69786: IFFALSE 69803
// bpoints := bpoints * 1.8 ;
69788: LD_ADDR_VAR 0 10
69792: PUSH
69793: LD_VAR 0 10
69797: PUSH
69798: LD_REAL  1.80000000000000E+0000
69801: MUL
69802: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69803: LD_VAR 0 6
69807: PPUSH
69808: CALL_OW 257
69812: PUSH
69813: LD_INT 1
69815: PUSH
69816: LD_INT 2
69818: PUSH
69819: LD_INT 3
69821: PUSH
69822: LD_INT 4
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: IN
69831: PUSH
69832: LD_VAR 0 1
69836: PPUSH
69837: LD_INT 51
69839: PPUSH
69840: CALL_OW 321
69844: PUSH
69845: LD_INT 2
69847: EQUAL
69848: AND
69849: IFFALSE 69866
// bpoints := bpoints * 1.2 ;
69851: LD_ADDR_VAR 0 10
69855: PUSH
69856: LD_VAR 0 10
69860: PUSH
69861: LD_REAL  1.20000000000000E+0000
69864: MUL
69865: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
69866: LD_VAR 0 6
69870: PPUSH
69871: CALL_OW 257
69875: PUSH
69876: LD_INT 5
69878: PUSH
69879: LD_INT 7
69881: PUSH
69882: LD_INT 9
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: LIST
69889: IN
69890: PUSH
69891: LD_VAR 0 1
69895: PPUSH
69896: LD_INT 52
69898: PPUSH
69899: CALL_OW 321
69903: PUSH
69904: LD_INT 2
69906: EQUAL
69907: AND
69908: IFFALSE 69925
// bpoints := bpoints * 1.5 ;
69910: LD_ADDR_VAR 0 10
69914: PUSH
69915: LD_VAR 0 10
69919: PUSH
69920: LD_REAL  1.50000000000000E+0000
69923: MUL
69924: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
69925: LD_VAR 0 1
69929: PPUSH
69930: LD_INT 66
69932: PPUSH
69933: CALL_OW 321
69937: PUSH
69938: LD_INT 2
69940: EQUAL
69941: IFFALSE 69958
// bpoints := bpoints * 1.1 ;
69943: LD_ADDR_VAR 0 10
69947: PUSH
69948: LD_VAR 0 10
69952: PUSH
69953: LD_REAL  1.10000000000000E+0000
69956: MUL
69957: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69958: LD_ADDR_VAR 0 10
69962: PUSH
69963: LD_VAR 0 10
69967: PUSH
69968: LD_VAR 0 6
69972: PPUSH
69973: LD_INT 1
69975: PPUSH
69976: CALL_OW 259
69980: PUSH
69981: LD_REAL  1.15000000000000E+0000
69984: MUL
69985: MUL
69986: ST_TO_ADDR
// end ; unit_vehicle :
69987: GO 70811
69989: LD_INT 2
69991: DOUBLE
69992: EQUAL
69993: IFTRUE 69997
69995: GO 70799
69997: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
69998: LD_VAR 0 6
70002: PPUSH
70003: CALL_OW 264
70007: PUSH
70008: LD_INT 2
70010: PUSH
70011: LD_INT 42
70013: PUSH
70014: LD_INT 24
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: LIST
70021: IN
70022: IFFALSE 70043
// points := [ 25 , 5 , 3 ] ;
70024: LD_ADDR_VAR 0 9
70028: PUSH
70029: LD_INT 25
70031: PUSH
70032: LD_INT 5
70034: PUSH
70035: LD_INT 3
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: LIST
70042: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70043: LD_VAR 0 6
70047: PPUSH
70048: CALL_OW 264
70052: PUSH
70053: LD_INT 4
70055: PUSH
70056: LD_INT 43
70058: PUSH
70059: LD_INT 25
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: LIST
70066: IN
70067: IFFALSE 70088
// points := [ 40 , 15 , 5 ] ;
70069: LD_ADDR_VAR 0 9
70073: PUSH
70074: LD_INT 40
70076: PUSH
70077: LD_INT 15
70079: PUSH
70080: LD_INT 5
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: LIST
70087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70088: LD_VAR 0 6
70092: PPUSH
70093: CALL_OW 264
70097: PUSH
70098: LD_INT 3
70100: PUSH
70101: LD_INT 23
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: IN
70108: IFFALSE 70129
// points := [ 7 , 25 , 8 ] ;
70110: LD_ADDR_VAR 0 9
70114: PUSH
70115: LD_INT 7
70117: PUSH
70118: LD_INT 25
70120: PUSH
70121: LD_INT 8
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: LIST
70128: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70129: LD_VAR 0 6
70133: PPUSH
70134: CALL_OW 264
70138: PUSH
70139: LD_INT 5
70141: PUSH
70142: LD_INT 27
70144: PUSH
70145: LD_INT 44
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: LIST
70152: IN
70153: IFFALSE 70174
// points := [ 14 , 50 , 16 ] ;
70155: LD_ADDR_VAR 0 9
70159: PUSH
70160: LD_INT 14
70162: PUSH
70163: LD_INT 50
70165: PUSH
70166: LD_INT 16
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: LIST
70173: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70174: LD_VAR 0 6
70178: PPUSH
70179: CALL_OW 264
70183: PUSH
70184: LD_INT 6
70186: PUSH
70187: LD_INT 46
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: IN
70194: IFFALSE 70215
// points := [ 32 , 120 , 70 ] ;
70196: LD_ADDR_VAR 0 9
70200: PUSH
70201: LD_INT 32
70203: PUSH
70204: LD_INT 120
70206: PUSH
70207: LD_INT 70
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: LIST
70214: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
70215: LD_VAR 0 6
70219: PPUSH
70220: CALL_OW 264
70224: PUSH
70225: LD_INT 7
70227: PUSH
70228: LD_INT 28
70230: PUSH
70231: LD_INT 45
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: LIST
70238: IN
70239: IFFALSE 70260
// points := [ 35 , 20 , 45 ] ;
70241: LD_ADDR_VAR 0 9
70245: PUSH
70246: LD_INT 35
70248: PUSH
70249: LD_INT 20
70251: PUSH
70252: LD_INT 45
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: LIST
70259: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70260: LD_VAR 0 6
70264: PPUSH
70265: CALL_OW 264
70269: PUSH
70270: LD_INT 47
70272: PUSH
70273: EMPTY
70274: LIST
70275: IN
70276: IFFALSE 70297
// points := [ 67 , 45 , 75 ] ;
70278: LD_ADDR_VAR 0 9
70282: PUSH
70283: LD_INT 67
70285: PUSH
70286: LD_INT 45
70288: PUSH
70289: LD_INT 75
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: LIST
70296: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70297: LD_VAR 0 6
70301: PPUSH
70302: CALL_OW 264
70306: PUSH
70307: LD_INT 26
70309: PUSH
70310: EMPTY
70311: LIST
70312: IN
70313: IFFALSE 70334
// points := [ 120 , 30 , 80 ] ;
70315: LD_ADDR_VAR 0 9
70319: PUSH
70320: LD_INT 120
70322: PUSH
70323: LD_INT 30
70325: PUSH
70326: LD_INT 80
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: LIST
70333: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70334: LD_VAR 0 6
70338: PPUSH
70339: CALL_OW 264
70343: PUSH
70344: LD_INT 22
70346: PUSH
70347: EMPTY
70348: LIST
70349: IN
70350: IFFALSE 70371
// points := [ 40 , 1 , 1 ] ;
70352: LD_ADDR_VAR 0 9
70356: PUSH
70357: LD_INT 40
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: LIST
70370: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70371: LD_VAR 0 6
70375: PPUSH
70376: CALL_OW 264
70380: PUSH
70381: LD_INT 29
70383: PUSH
70384: EMPTY
70385: LIST
70386: IN
70387: IFFALSE 70408
// points := [ 70 , 200 , 400 ] ;
70389: LD_ADDR_VAR 0 9
70393: PUSH
70394: LD_INT 70
70396: PUSH
70397: LD_INT 200
70399: PUSH
70400: LD_INT 400
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: LIST
70407: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70408: LD_VAR 0 6
70412: PPUSH
70413: CALL_OW 264
70417: PUSH
70418: LD_INT 14
70420: PUSH
70421: LD_INT 53
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: IN
70428: IFFALSE 70449
// points := [ 40 , 10 , 20 ] ;
70430: LD_ADDR_VAR 0 9
70434: PUSH
70435: LD_INT 40
70437: PUSH
70438: LD_INT 10
70440: PUSH
70441: LD_INT 20
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: LIST
70448: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70449: LD_VAR 0 6
70453: PPUSH
70454: CALL_OW 264
70458: PUSH
70459: LD_INT 9
70461: PUSH
70462: EMPTY
70463: LIST
70464: IN
70465: IFFALSE 70486
// points := [ 5 , 70 , 20 ] ;
70467: LD_ADDR_VAR 0 9
70471: PUSH
70472: LD_INT 5
70474: PUSH
70475: LD_INT 70
70477: PUSH
70478: LD_INT 20
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: LIST
70485: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70486: LD_VAR 0 6
70490: PPUSH
70491: CALL_OW 264
70495: PUSH
70496: LD_INT 10
70498: PUSH
70499: EMPTY
70500: LIST
70501: IN
70502: IFFALSE 70523
// points := [ 35 , 110 , 70 ] ;
70504: LD_ADDR_VAR 0 9
70508: PUSH
70509: LD_INT 35
70511: PUSH
70512: LD_INT 110
70514: PUSH
70515: LD_INT 70
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: LIST
70522: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70523: LD_VAR 0 6
70527: PPUSH
70528: CALL_OW 265
70532: PUSH
70533: LD_INT 25
70535: EQUAL
70536: IFFALSE 70557
// points := [ 80 , 65 , 100 ] ;
70538: LD_ADDR_VAR 0 9
70542: PUSH
70543: LD_INT 80
70545: PUSH
70546: LD_INT 65
70548: PUSH
70549: LD_INT 100
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: LIST
70556: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70557: LD_VAR 0 6
70561: PPUSH
70562: CALL_OW 263
70566: PUSH
70567: LD_INT 1
70569: EQUAL
70570: IFFALSE 70605
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70572: LD_ADDR_VAR 0 10
70576: PUSH
70577: LD_VAR 0 10
70581: PUSH
70582: LD_VAR 0 6
70586: PPUSH
70587: CALL_OW 311
70591: PPUSH
70592: LD_INT 3
70594: PPUSH
70595: CALL_OW 259
70599: PUSH
70600: LD_INT 4
70602: MUL
70603: MUL
70604: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70605: LD_VAR 0 6
70609: PPUSH
70610: CALL_OW 263
70614: PUSH
70615: LD_INT 2
70617: EQUAL
70618: IFFALSE 70669
// begin j := IsControledBy ( i ) ;
70620: LD_ADDR_VAR 0 7
70624: PUSH
70625: LD_VAR 0 6
70629: PPUSH
70630: CALL_OW 312
70634: ST_TO_ADDR
// if j then
70635: LD_VAR 0 7
70639: IFFALSE 70669
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70641: LD_ADDR_VAR 0 10
70645: PUSH
70646: LD_VAR 0 10
70650: PUSH
70651: LD_VAR 0 7
70655: PPUSH
70656: LD_INT 3
70658: PPUSH
70659: CALL_OW 259
70663: PUSH
70664: LD_INT 3
70666: MUL
70667: MUL
70668: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70669: LD_VAR 0 6
70673: PPUSH
70674: CALL_OW 264
70678: PUSH
70679: LD_INT 5
70681: PUSH
70682: LD_INT 6
70684: PUSH
70685: LD_INT 46
70687: PUSH
70688: LD_INT 44
70690: PUSH
70691: LD_INT 47
70693: PUSH
70694: LD_INT 45
70696: PUSH
70697: LD_INT 28
70699: PUSH
70700: LD_INT 7
70702: PUSH
70703: LD_INT 27
70705: PUSH
70706: LD_INT 29
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: IN
70721: PUSH
70722: LD_VAR 0 1
70726: PPUSH
70727: LD_INT 52
70729: PPUSH
70730: CALL_OW 321
70734: PUSH
70735: LD_INT 2
70737: EQUAL
70738: AND
70739: IFFALSE 70756
// bpoints := bpoints * 1.2 ;
70741: LD_ADDR_VAR 0 10
70745: PUSH
70746: LD_VAR 0 10
70750: PUSH
70751: LD_REAL  1.20000000000000E+0000
70754: MUL
70755: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70756: LD_VAR 0 6
70760: PPUSH
70761: CALL_OW 264
70765: PUSH
70766: LD_INT 6
70768: PUSH
70769: LD_INT 46
70771: PUSH
70772: LD_INT 47
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: LIST
70779: IN
70780: IFFALSE 70797
// bpoints := bpoints * 1.2 ;
70782: LD_ADDR_VAR 0 10
70786: PUSH
70787: LD_VAR 0 10
70791: PUSH
70792: LD_REAL  1.20000000000000E+0000
70795: MUL
70796: ST_TO_ADDR
// end ; unit_building :
70797: GO 70811
70799: LD_INT 3
70801: DOUBLE
70802: EQUAL
70803: IFTRUE 70807
70805: GO 70810
70807: POP
// ; end ;
70808: GO 70811
70810: POP
// for j = 1 to 3 do
70811: LD_ADDR_VAR 0 7
70815: PUSH
70816: DOUBLE
70817: LD_INT 1
70819: DEC
70820: ST_TO_ADDR
70821: LD_INT 3
70823: PUSH
70824: FOR_TO
70825: IFFALSE 70878
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70827: LD_ADDR_VAR 0 5
70831: PUSH
70832: LD_VAR 0 5
70836: PPUSH
70837: LD_VAR 0 7
70841: PPUSH
70842: LD_VAR 0 5
70846: PUSH
70847: LD_VAR 0 7
70851: ARRAY
70852: PUSH
70853: LD_VAR 0 9
70857: PUSH
70858: LD_VAR 0 7
70862: ARRAY
70863: PUSH
70864: LD_VAR 0 10
70868: MUL
70869: PLUS
70870: PPUSH
70871: CALL_OW 1
70875: ST_TO_ADDR
70876: GO 70824
70878: POP
70879: POP
// end ;
70880: GO 69363
70882: POP
70883: POP
// result := Replace ( result , 4 , tmp ) ;
70884: LD_ADDR_VAR 0 5
70888: PUSH
70889: LD_VAR 0 5
70893: PPUSH
70894: LD_INT 4
70896: PPUSH
70897: LD_VAR 0 8
70901: PPUSH
70902: CALL_OW 1
70906: ST_TO_ADDR
// end ;
70907: LD_VAR 0 5
70911: RET
// export function DangerAtRange ( unit , range ) ; begin
70912: LD_INT 0
70914: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
70915: LD_ADDR_VAR 0 3
70919: PUSH
70920: LD_VAR 0 1
70924: PPUSH
70925: CALL_OW 255
70929: PPUSH
70930: LD_VAR 0 1
70934: PPUSH
70935: CALL_OW 250
70939: PPUSH
70940: LD_VAR 0 1
70944: PPUSH
70945: CALL_OW 251
70949: PPUSH
70950: LD_VAR 0 2
70954: PPUSH
70955: CALL 69215 0 4
70959: ST_TO_ADDR
// end ;
70960: LD_VAR 0 3
70964: RET
// export function DangerInArea ( side , area ) ; begin
70965: LD_INT 0
70967: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
70968: LD_ADDR_VAR 0 3
70972: PUSH
70973: LD_VAR 0 2
70977: PPUSH
70978: LD_INT 81
70980: PUSH
70981: LD_VAR 0 1
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PPUSH
70990: CALL_OW 70
70994: ST_TO_ADDR
// end ;
70995: LD_VAR 0 3
70999: RET
// export function IsExtension ( b ) ; begin
71000: LD_INT 0
71002: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71003: LD_ADDR_VAR 0 2
71007: PUSH
71008: LD_VAR 0 1
71012: PUSH
71013: LD_INT 23
71015: PUSH
71016: LD_INT 20
71018: PUSH
71019: LD_INT 22
71021: PUSH
71022: LD_INT 17
71024: PUSH
71025: LD_INT 24
71027: PUSH
71028: LD_INT 21
71030: PUSH
71031: LD_INT 19
71033: PUSH
71034: LD_INT 16
71036: PUSH
71037: LD_INT 25
71039: PUSH
71040: LD_INT 18
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: LIST
71053: LIST
71054: IN
71055: ST_TO_ADDR
// end ;
71056: LD_VAR 0 2
71060: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
71061: LD_INT 0
71063: PPUSH
71064: PPUSH
71065: PPUSH
// result := [ ] ;
71066: LD_ADDR_VAR 0 3
71070: PUSH
71071: EMPTY
71072: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71073: LD_ADDR_VAR 0 4
71077: PUSH
71078: LD_VAR 0 2
71082: PPUSH
71083: LD_INT 21
71085: PUSH
71086: LD_INT 3
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PPUSH
71093: CALL_OW 70
71097: ST_TO_ADDR
// if not tmp then
71098: LD_VAR 0 4
71102: NOT
71103: IFFALSE 71107
// exit ;
71105: GO 71165
// for i in tmp do
71107: LD_ADDR_VAR 0 5
71111: PUSH
71112: LD_VAR 0 4
71116: PUSH
71117: FOR_IN
71118: IFFALSE 71153
// if GetBase ( i ) <> base then
71120: LD_VAR 0 5
71124: PPUSH
71125: CALL_OW 274
71129: PUSH
71130: LD_VAR 0 1
71134: NONEQUAL
71135: IFFALSE 71151
// ComLinkToBase ( base , i ) ;
71137: LD_VAR 0 1
71141: PPUSH
71142: LD_VAR 0 5
71146: PPUSH
71147: CALL_OW 169
71151: GO 71117
71153: POP
71154: POP
// result := tmp ;
71155: LD_ADDR_VAR 0 3
71159: PUSH
71160: LD_VAR 0 4
71164: ST_TO_ADDR
// end ;
71165: LD_VAR 0 3
71169: RET
// export function ComComplete ( unit , b ) ; var i ; begin
71170: LD_INT 0
71172: PPUSH
71173: PPUSH
// if BuildingStatus ( b ) = bs_build then
71174: LD_VAR 0 2
71178: PPUSH
71179: CALL_OW 461
71183: PUSH
71184: LD_INT 1
71186: EQUAL
71187: IFFALSE 71247
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71189: LD_VAR 0 1
71193: PPUSH
71194: LD_STRING h
71196: PUSH
71197: LD_VAR 0 2
71201: PPUSH
71202: CALL_OW 250
71206: PUSH
71207: LD_VAR 0 2
71211: PPUSH
71212: CALL_OW 251
71216: PUSH
71217: LD_VAR 0 2
71221: PUSH
71222: LD_INT 0
71224: PUSH
71225: LD_INT 0
71227: PUSH
71228: LD_INT 0
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: LIST
71235: LIST
71236: LIST
71237: LIST
71238: LIST
71239: PUSH
71240: EMPTY
71241: LIST
71242: PPUSH
71243: CALL_OW 446
// end ;
71247: LD_VAR 0 3
71251: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71252: LD_INT 0
71254: PPUSH
71255: PPUSH
71256: PPUSH
71257: PPUSH
71258: PPUSH
71259: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
71260: LD_VAR 0 1
71264: NOT
71265: PUSH
71266: LD_VAR 0 1
71270: PPUSH
71271: CALL_OW 263
71275: PUSH
71276: LD_INT 2
71278: EQUAL
71279: NOT
71280: OR
71281: IFFALSE 71285
// exit ;
71283: GO 71601
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71285: LD_ADDR_VAR 0 6
71289: PUSH
71290: LD_INT 22
71292: PUSH
71293: LD_VAR 0 1
71297: PPUSH
71298: CALL_OW 255
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 2
71309: PUSH
71310: LD_INT 30
71312: PUSH
71313: LD_INT 36
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 34
71322: PUSH
71323: LD_INT 31
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: LIST
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PPUSH
71339: CALL_OW 69
71343: ST_TO_ADDR
// if not tmp then
71344: LD_VAR 0 6
71348: NOT
71349: IFFALSE 71353
// exit ;
71351: GO 71601
// result := [ ] ;
71353: LD_ADDR_VAR 0 2
71357: PUSH
71358: EMPTY
71359: ST_TO_ADDR
// for i in tmp do
71360: LD_ADDR_VAR 0 3
71364: PUSH
71365: LD_VAR 0 6
71369: PUSH
71370: FOR_IN
71371: IFFALSE 71442
// begin t := UnitsInside ( i ) ;
71373: LD_ADDR_VAR 0 4
71377: PUSH
71378: LD_VAR 0 3
71382: PPUSH
71383: CALL_OW 313
71387: ST_TO_ADDR
// if t then
71388: LD_VAR 0 4
71392: IFFALSE 71440
// for j in t do
71394: LD_ADDR_VAR 0 7
71398: PUSH
71399: LD_VAR 0 4
71403: PUSH
71404: FOR_IN
71405: IFFALSE 71438
// result := Insert ( result , result + 1 , j ) ;
71407: LD_ADDR_VAR 0 2
71411: PUSH
71412: LD_VAR 0 2
71416: PPUSH
71417: LD_VAR 0 2
71421: PUSH
71422: LD_INT 1
71424: PLUS
71425: PPUSH
71426: LD_VAR 0 7
71430: PPUSH
71431: CALL_OW 2
71435: ST_TO_ADDR
71436: GO 71404
71438: POP
71439: POP
// end ;
71440: GO 71370
71442: POP
71443: POP
// if not result then
71444: LD_VAR 0 2
71448: NOT
71449: IFFALSE 71453
// exit ;
71451: GO 71601
// mech := result [ 1 ] ;
71453: LD_ADDR_VAR 0 5
71457: PUSH
71458: LD_VAR 0 2
71462: PUSH
71463: LD_INT 1
71465: ARRAY
71466: ST_TO_ADDR
// if result > 1 then
71467: LD_VAR 0 2
71471: PUSH
71472: LD_INT 1
71474: GREATER
71475: IFFALSE 71587
// for i = 2 to result do
71477: LD_ADDR_VAR 0 3
71481: PUSH
71482: DOUBLE
71483: LD_INT 2
71485: DEC
71486: ST_TO_ADDR
71487: LD_VAR 0 2
71491: PUSH
71492: FOR_TO
71493: IFFALSE 71585
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71495: LD_ADDR_VAR 0 4
71499: PUSH
71500: LD_VAR 0 2
71504: PUSH
71505: LD_VAR 0 3
71509: ARRAY
71510: PPUSH
71511: LD_INT 3
71513: PPUSH
71514: CALL_OW 259
71518: PUSH
71519: LD_VAR 0 2
71523: PUSH
71524: LD_VAR 0 3
71528: ARRAY
71529: PPUSH
71530: CALL_OW 432
71534: MINUS
71535: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71536: LD_VAR 0 4
71540: PUSH
71541: LD_VAR 0 5
71545: PPUSH
71546: LD_INT 3
71548: PPUSH
71549: CALL_OW 259
71553: PUSH
71554: LD_VAR 0 5
71558: PPUSH
71559: CALL_OW 432
71563: MINUS
71564: GREATEREQUAL
71565: IFFALSE 71583
// mech := result [ i ] ;
71567: LD_ADDR_VAR 0 5
71571: PUSH
71572: LD_VAR 0 2
71576: PUSH
71577: LD_VAR 0 3
71581: ARRAY
71582: ST_TO_ADDR
// end ;
71583: GO 71492
71585: POP
71586: POP
// ComLinkTo ( vehicle , mech ) ;
71587: LD_VAR 0 1
71591: PPUSH
71592: LD_VAR 0 5
71596: PPUSH
71597: CALL_OW 135
// end ;
71601: LD_VAR 0 2
71605: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71606: LD_INT 0
71608: PPUSH
71609: PPUSH
71610: PPUSH
71611: PPUSH
71612: PPUSH
71613: PPUSH
71614: PPUSH
71615: PPUSH
71616: PPUSH
71617: PPUSH
71618: PPUSH
71619: PPUSH
71620: PPUSH
// result := [ ] ;
71621: LD_ADDR_VAR 0 7
71625: PUSH
71626: EMPTY
71627: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71628: LD_VAR 0 1
71632: PPUSH
71633: CALL_OW 266
71637: PUSH
71638: LD_INT 0
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: IN
71648: NOT
71649: IFFALSE 71653
// exit ;
71651: GO 73284
// if name then
71653: LD_VAR 0 3
71657: IFFALSE 71673
// SetBName ( base_dep , name ) ;
71659: LD_VAR 0 1
71663: PPUSH
71664: LD_VAR 0 3
71668: PPUSH
71669: CALL_OW 500
// base := GetBase ( base_dep ) ;
71673: LD_ADDR_VAR 0 15
71677: PUSH
71678: LD_VAR 0 1
71682: PPUSH
71683: CALL_OW 274
71687: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71688: LD_ADDR_VAR 0 16
71692: PUSH
71693: LD_VAR 0 1
71697: PPUSH
71698: CALL_OW 255
71702: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71703: LD_ADDR_VAR 0 17
71707: PUSH
71708: LD_VAR 0 1
71712: PPUSH
71713: CALL_OW 248
71717: ST_TO_ADDR
// if sources then
71718: LD_VAR 0 5
71722: IFFALSE 71769
// for i = 1 to 3 do
71724: LD_ADDR_VAR 0 8
71728: PUSH
71729: DOUBLE
71730: LD_INT 1
71732: DEC
71733: ST_TO_ADDR
71734: LD_INT 3
71736: PUSH
71737: FOR_TO
71738: IFFALSE 71767
// AddResourceType ( base , i , sources [ i ] ) ;
71740: LD_VAR 0 15
71744: PPUSH
71745: LD_VAR 0 8
71749: PPUSH
71750: LD_VAR 0 5
71754: PUSH
71755: LD_VAR 0 8
71759: ARRAY
71760: PPUSH
71761: CALL_OW 276
71765: GO 71737
71767: POP
71768: POP
// buildings := GetBaseBuildings ( base , area ) ;
71769: LD_ADDR_VAR 0 18
71773: PUSH
71774: LD_VAR 0 15
71778: PPUSH
71779: LD_VAR 0 2
71783: PPUSH
71784: CALL 71061 0 2
71788: ST_TO_ADDR
// InitHc ;
71789: CALL_OW 19
// InitUc ;
71793: CALL_OW 18
// uc_side := side ;
71797: LD_ADDR_OWVAR 20
71801: PUSH
71802: LD_VAR 0 16
71806: ST_TO_ADDR
// uc_nation := nation ;
71807: LD_ADDR_OWVAR 21
71811: PUSH
71812: LD_VAR 0 17
71816: ST_TO_ADDR
// if buildings then
71817: LD_VAR 0 18
71821: IFFALSE 73143
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
71823: LD_ADDR_VAR 0 19
71827: PUSH
71828: LD_VAR 0 18
71832: PPUSH
71833: LD_INT 2
71835: PUSH
71836: LD_INT 30
71838: PUSH
71839: LD_INT 29
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 30
71848: PUSH
71849: LD_INT 30
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: LIST
71860: PPUSH
71861: CALL_OW 72
71865: ST_TO_ADDR
// if tmp then
71866: LD_VAR 0 19
71870: IFFALSE 71918
// for i in tmp do
71872: LD_ADDR_VAR 0 8
71876: PUSH
71877: LD_VAR 0 19
71881: PUSH
71882: FOR_IN
71883: IFFALSE 71916
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71885: LD_VAR 0 8
71889: PPUSH
71890: CALL_OW 250
71894: PPUSH
71895: LD_VAR 0 8
71899: PPUSH
71900: CALL_OW 251
71904: PPUSH
71905: LD_VAR 0 16
71909: PPUSH
71910: CALL_OW 441
71914: GO 71882
71916: POP
71917: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71918: LD_VAR 0 18
71922: PPUSH
71923: LD_INT 2
71925: PUSH
71926: LD_INT 30
71928: PUSH
71929: LD_INT 32
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 30
71938: PUSH
71939: LD_INT 33
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: LIST
71950: PPUSH
71951: CALL_OW 72
71955: IFFALSE 72043
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
71957: LD_ADDR_VAR 0 8
71961: PUSH
71962: LD_VAR 0 18
71966: PPUSH
71967: LD_INT 2
71969: PUSH
71970: LD_INT 30
71972: PUSH
71973: LD_INT 32
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 30
71982: PUSH
71983: LD_INT 33
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: LIST
71994: PPUSH
71995: CALL_OW 72
71999: PUSH
72000: FOR_IN
72001: IFFALSE 72041
// begin if not GetBWeapon ( i ) then
72003: LD_VAR 0 8
72007: PPUSH
72008: CALL_OW 269
72012: NOT
72013: IFFALSE 72039
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72015: LD_VAR 0 8
72019: PPUSH
72020: LD_VAR 0 8
72024: PPUSH
72025: LD_VAR 0 2
72029: PPUSH
72030: CALL 73289 0 2
72034: PPUSH
72035: CALL_OW 431
// end ;
72039: GO 72000
72041: POP
72042: POP
// end ; for i = 1 to personel do
72043: LD_ADDR_VAR 0 8
72047: PUSH
72048: DOUBLE
72049: LD_INT 1
72051: DEC
72052: ST_TO_ADDR
72053: LD_VAR 0 6
72057: PUSH
72058: FOR_TO
72059: IFFALSE 73123
// begin if i > 4 then
72061: LD_VAR 0 8
72065: PUSH
72066: LD_INT 4
72068: GREATER
72069: IFFALSE 72073
// break ;
72071: GO 73123
// case i of 1 :
72073: LD_VAR 0 8
72077: PUSH
72078: LD_INT 1
72080: DOUBLE
72081: EQUAL
72082: IFTRUE 72086
72084: GO 72166
72086: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72087: LD_ADDR_VAR 0 12
72091: PUSH
72092: LD_VAR 0 18
72096: PPUSH
72097: LD_INT 22
72099: PUSH
72100: LD_VAR 0 16
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 58
72111: PUSH
72112: EMPTY
72113: LIST
72114: PUSH
72115: LD_INT 2
72117: PUSH
72118: LD_INT 30
72120: PUSH
72121: LD_INT 32
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 30
72130: PUSH
72131: LD_INT 4
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 30
72140: PUSH
72141: LD_INT 5
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: LIST
72158: PPUSH
72159: CALL_OW 72
72163: ST_TO_ADDR
72164: GO 72388
72166: LD_INT 2
72168: DOUBLE
72169: EQUAL
72170: IFTRUE 72174
72172: GO 72236
72174: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72175: LD_ADDR_VAR 0 12
72179: PUSH
72180: LD_VAR 0 18
72184: PPUSH
72185: LD_INT 22
72187: PUSH
72188: LD_VAR 0 16
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 2
72199: PUSH
72200: LD_INT 30
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 30
72212: PUSH
72213: LD_INT 1
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PPUSH
72229: CALL_OW 72
72233: ST_TO_ADDR
72234: GO 72388
72236: LD_INT 3
72238: DOUBLE
72239: EQUAL
72240: IFTRUE 72244
72242: GO 72306
72244: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72245: LD_ADDR_VAR 0 12
72249: PUSH
72250: LD_VAR 0 18
72254: PPUSH
72255: LD_INT 22
72257: PUSH
72258: LD_VAR 0 16
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 2
72269: PUSH
72270: LD_INT 30
72272: PUSH
72273: LD_INT 2
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: LD_INT 30
72282: PUSH
72283: LD_INT 3
72285: PUSH
72286: EMPTY
72287: LIST
72288: LIST
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: LIST
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: PPUSH
72299: CALL_OW 72
72303: ST_TO_ADDR
72304: GO 72388
72306: LD_INT 4
72308: DOUBLE
72309: EQUAL
72310: IFTRUE 72314
72312: GO 72387
72314: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72315: LD_ADDR_VAR 0 12
72319: PUSH
72320: LD_VAR 0 18
72324: PPUSH
72325: LD_INT 22
72327: PUSH
72328: LD_VAR 0 16
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: LD_INT 30
72342: PUSH
72343: LD_INT 6
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 30
72352: PUSH
72353: LD_INT 7
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 30
72362: PUSH
72363: LD_INT 8
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PPUSH
72380: CALL_OW 72
72384: ST_TO_ADDR
72385: GO 72388
72387: POP
// if i = 1 then
72388: LD_VAR 0 8
72392: PUSH
72393: LD_INT 1
72395: EQUAL
72396: IFFALSE 72507
// begin tmp := [ ] ;
72398: LD_ADDR_VAR 0 19
72402: PUSH
72403: EMPTY
72404: ST_TO_ADDR
// for j in f do
72405: LD_ADDR_VAR 0 9
72409: PUSH
72410: LD_VAR 0 12
72414: PUSH
72415: FOR_IN
72416: IFFALSE 72489
// if GetBType ( j ) = b_bunker then
72418: LD_VAR 0 9
72422: PPUSH
72423: CALL_OW 266
72427: PUSH
72428: LD_INT 32
72430: EQUAL
72431: IFFALSE 72458
// tmp := Insert ( tmp , 1 , j ) else
72433: LD_ADDR_VAR 0 19
72437: PUSH
72438: LD_VAR 0 19
72442: PPUSH
72443: LD_INT 1
72445: PPUSH
72446: LD_VAR 0 9
72450: PPUSH
72451: CALL_OW 2
72455: ST_TO_ADDR
72456: GO 72487
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72458: LD_ADDR_VAR 0 19
72462: PUSH
72463: LD_VAR 0 19
72467: PPUSH
72468: LD_VAR 0 19
72472: PUSH
72473: LD_INT 1
72475: PLUS
72476: PPUSH
72477: LD_VAR 0 9
72481: PPUSH
72482: CALL_OW 2
72486: ST_TO_ADDR
72487: GO 72415
72489: POP
72490: POP
// if tmp then
72491: LD_VAR 0 19
72495: IFFALSE 72507
// f := tmp ;
72497: LD_ADDR_VAR 0 12
72501: PUSH
72502: LD_VAR 0 19
72506: ST_TO_ADDR
// end ; x := personel [ i ] ;
72507: LD_ADDR_VAR 0 13
72511: PUSH
72512: LD_VAR 0 6
72516: PUSH
72517: LD_VAR 0 8
72521: ARRAY
72522: ST_TO_ADDR
// if x = - 1 then
72523: LD_VAR 0 13
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: EQUAL
72532: IFFALSE 72741
// begin for j in f do
72534: LD_ADDR_VAR 0 9
72538: PUSH
72539: LD_VAR 0 12
72543: PUSH
72544: FOR_IN
72545: IFFALSE 72737
// repeat InitHc ;
72547: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72551: LD_VAR 0 9
72555: PPUSH
72556: CALL_OW 266
72560: PUSH
72561: LD_INT 5
72563: EQUAL
72564: IFFALSE 72634
// begin if UnitsInside ( j ) < 3 then
72566: LD_VAR 0 9
72570: PPUSH
72571: CALL_OW 313
72575: PUSH
72576: LD_INT 3
72578: LESS
72579: IFFALSE 72615
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72581: LD_INT 0
72583: PPUSH
72584: LD_INT 5
72586: PUSH
72587: LD_INT 8
72589: PUSH
72590: LD_INT 9
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: LIST
72597: PUSH
72598: LD_VAR 0 17
72602: ARRAY
72603: PPUSH
72604: LD_VAR 0 4
72608: PPUSH
72609: CALL_OW 380
72613: GO 72632
// PrepareHuman ( false , i , skill ) ;
72615: LD_INT 0
72617: PPUSH
72618: LD_VAR 0 8
72622: PPUSH
72623: LD_VAR 0 4
72627: PPUSH
72628: CALL_OW 380
// end else
72632: GO 72651
// PrepareHuman ( false , i , skill ) ;
72634: LD_INT 0
72636: PPUSH
72637: LD_VAR 0 8
72641: PPUSH
72642: LD_VAR 0 4
72646: PPUSH
72647: CALL_OW 380
// un := CreateHuman ;
72651: LD_ADDR_VAR 0 14
72655: PUSH
72656: CALL_OW 44
72660: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72661: LD_ADDR_VAR 0 7
72665: PUSH
72666: LD_VAR 0 7
72670: PPUSH
72671: LD_INT 1
72673: PPUSH
72674: LD_VAR 0 14
72678: PPUSH
72679: CALL_OW 2
72683: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72684: LD_VAR 0 14
72688: PPUSH
72689: LD_VAR 0 9
72693: PPUSH
72694: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72698: LD_VAR 0 9
72702: PPUSH
72703: CALL_OW 313
72707: PUSH
72708: LD_INT 6
72710: EQUAL
72711: PUSH
72712: LD_VAR 0 9
72716: PPUSH
72717: CALL_OW 266
72721: PUSH
72722: LD_INT 32
72724: PUSH
72725: LD_INT 31
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: IN
72732: OR
72733: IFFALSE 72547
72735: GO 72544
72737: POP
72738: POP
// end else
72739: GO 73121
// for j = 1 to x do
72741: LD_ADDR_VAR 0 9
72745: PUSH
72746: DOUBLE
72747: LD_INT 1
72749: DEC
72750: ST_TO_ADDR
72751: LD_VAR 0 13
72755: PUSH
72756: FOR_TO
72757: IFFALSE 73119
// begin InitHc ;
72759: CALL_OW 19
// if not f then
72763: LD_VAR 0 12
72767: NOT
72768: IFFALSE 72857
// begin PrepareHuman ( false , i , skill ) ;
72770: LD_INT 0
72772: PPUSH
72773: LD_VAR 0 8
72777: PPUSH
72778: LD_VAR 0 4
72782: PPUSH
72783: CALL_OW 380
// un := CreateHuman ;
72787: LD_ADDR_VAR 0 14
72791: PUSH
72792: CALL_OW 44
72796: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72797: LD_ADDR_VAR 0 7
72801: PUSH
72802: LD_VAR 0 7
72806: PPUSH
72807: LD_INT 1
72809: PPUSH
72810: LD_VAR 0 14
72814: PPUSH
72815: CALL_OW 2
72819: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72820: LD_VAR 0 14
72824: PPUSH
72825: LD_VAR 0 1
72829: PPUSH
72830: CALL_OW 250
72834: PPUSH
72835: LD_VAR 0 1
72839: PPUSH
72840: CALL_OW 251
72844: PPUSH
72845: LD_INT 10
72847: PPUSH
72848: LD_INT 0
72850: PPUSH
72851: CALL_OW 50
// continue ;
72855: GO 72756
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
72857: LD_VAR 0 12
72861: PUSH
72862: LD_INT 1
72864: ARRAY
72865: PPUSH
72866: CALL_OW 313
72870: PUSH
72871: LD_VAR 0 12
72875: PUSH
72876: LD_INT 1
72878: ARRAY
72879: PPUSH
72880: CALL_OW 266
72884: PUSH
72885: LD_INT 32
72887: PUSH
72888: LD_INT 31
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: IN
72895: AND
72896: PUSH
72897: LD_VAR 0 12
72901: PUSH
72902: LD_INT 1
72904: ARRAY
72905: PPUSH
72906: CALL_OW 313
72910: PUSH
72911: LD_INT 6
72913: EQUAL
72914: OR
72915: IFFALSE 72935
// f := Delete ( f , 1 ) ;
72917: LD_ADDR_VAR 0 12
72921: PUSH
72922: LD_VAR 0 12
72926: PPUSH
72927: LD_INT 1
72929: PPUSH
72930: CALL_OW 3
72934: ST_TO_ADDR
// if not f then
72935: LD_VAR 0 12
72939: NOT
72940: IFFALSE 72958
// begin x := x + 2 ;
72942: LD_ADDR_VAR 0 13
72946: PUSH
72947: LD_VAR 0 13
72951: PUSH
72952: LD_INT 2
72954: PLUS
72955: ST_TO_ADDR
// continue ;
72956: GO 72756
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
72958: LD_VAR 0 12
72962: PUSH
72963: LD_INT 1
72965: ARRAY
72966: PPUSH
72967: CALL_OW 266
72971: PUSH
72972: LD_INT 5
72974: EQUAL
72975: IFFALSE 73049
// begin if UnitsInside ( f [ 1 ] ) < 3 then
72977: LD_VAR 0 12
72981: PUSH
72982: LD_INT 1
72984: ARRAY
72985: PPUSH
72986: CALL_OW 313
72990: PUSH
72991: LD_INT 3
72993: LESS
72994: IFFALSE 73030
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72996: LD_INT 0
72998: PPUSH
72999: LD_INT 5
73001: PUSH
73002: LD_INT 8
73004: PUSH
73005: LD_INT 9
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: LIST
73012: PUSH
73013: LD_VAR 0 17
73017: ARRAY
73018: PPUSH
73019: LD_VAR 0 4
73023: PPUSH
73024: CALL_OW 380
73028: GO 73047
// PrepareHuman ( false , i , skill ) ;
73030: LD_INT 0
73032: PPUSH
73033: LD_VAR 0 8
73037: PPUSH
73038: LD_VAR 0 4
73042: PPUSH
73043: CALL_OW 380
// end else
73047: GO 73066
// PrepareHuman ( false , i , skill ) ;
73049: LD_INT 0
73051: PPUSH
73052: LD_VAR 0 8
73056: PPUSH
73057: LD_VAR 0 4
73061: PPUSH
73062: CALL_OW 380
// un := CreateHuman ;
73066: LD_ADDR_VAR 0 14
73070: PUSH
73071: CALL_OW 44
73075: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73076: LD_ADDR_VAR 0 7
73080: PUSH
73081: LD_VAR 0 7
73085: PPUSH
73086: LD_INT 1
73088: PPUSH
73089: LD_VAR 0 14
73093: PPUSH
73094: CALL_OW 2
73098: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73099: LD_VAR 0 14
73103: PPUSH
73104: LD_VAR 0 12
73108: PUSH
73109: LD_INT 1
73111: ARRAY
73112: PPUSH
73113: CALL_OW 52
// end ;
73117: GO 72756
73119: POP
73120: POP
// end ;
73121: GO 72058
73123: POP
73124: POP
// result := result ^ buildings ;
73125: LD_ADDR_VAR 0 7
73129: PUSH
73130: LD_VAR 0 7
73134: PUSH
73135: LD_VAR 0 18
73139: ADD
73140: ST_TO_ADDR
// end else
73141: GO 73284
// begin for i = 1 to personel do
73143: LD_ADDR_VAR 0 8
73147: PUSH
73148: DOUBLE
73149: LD_INT 1
73151: DEC
73152: ST_TO_ADDR
73153: LD_VAR 0 6
73157: PUSH
73158: FOR_TO
73159: IFFALSE 73282
// begin if i > 4 then
73161: LD_VAR 0 8
73165: PUSH
73166: LD_INT 4
73168: GREATER
73169: IFFALSE 73173
// break ;
73171: GO 73282
// x := personel [ i ] ;
73173: LD_ADDR_VAR 0 13
73177: PUSH
73178: LD_VAR 0 6
73182: PUSH
73183: LD_VAR 0 8
73187: ARRAY
73188: ST_TO_ADDR
// if x = - 1 then
73189: LD_VAR 0 13
73193: PUSH
73194: LD_INT 1
73196: NEG
73197: EQUAL
73198: IFFALSE 73202
// continue ;
73200: GO 73158
// PrepareHuman ( false , i , skill ) ;
73202: LD_INT 0
73204: PPUSH
73205: LD_VAR 0 8
73209: PPUSH
73210: LD_VAR 0 4
73214: PPUSH
73215: CALL_OW 380
// un := CreateHuman ;
73219: LD_ADDR_VAR 0 14
73223: PUSH
73224: CALL_OW 44
73228: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73229: LD_VAR 0 14
73233: PPUSH
73234: LD_VAR 0 1
73238: PPUSH
73239: CALL_OW 250
73243: PPUSH
73244: LD_VAR 0 1
73248: PPUSH
73249: CALL_OW 251
73253: PPUSH
73254: LD_INT 10
73256: PPUSH
73257: LD_INT 0
73259: PPUSH
73260: CALL_OW 50
// result := result ^ un ;
73264: LD_ADDR_VAR 0 7
73268: PUSH
73269: LD_VAR 0 7
73273: PUSH
73274: LD_VAR 0 14
73278: ADD
73279: ST_TO_ADDR
// end ;
73280: GO 73158
73282: POP
73283: POP
// end ; end ;
73284: LD_VAR 0 7
73288: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73289: LD_INT 0
73291: PPUSH
73292: PPUSH
73293: PPUSH
73294: PPUSH
73295: PPUSH
73296: PPUSH
73297: PPUSH
73298: PPUSH
73299: PPUSH
73300: PPUSH
73301: PPUSH
73302: PPUSH
73303: PPUSH
73304: PPUSH
73305: PPUSH
73306: PPUSH
// result := false ;
73307: LD_ADDR_VAR 0 3
73311: PUSH
73312: LD_INT 0
73314: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73315: LD_VAR 0 1
73319: NOT
73320: PUSH
73321: LD_VAR 0 1
73325: PPUSH
73326: CALL_OW 266
73330: PUSH
73331: LD_INT 32
73333: PUSH
73334: LD_INT 33
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: IN
73341: NOT
73342: OR
73343: IFFALSE 73347
// exit ;
73345: GO 74483
// nat := GetNation ( tower ) ;
73347: LD_ADDR_VAR 0 12
73351: PUSH
73352: LD_VAR 0 1
73356: PPUSH
73357: CALL_OW 248
73361: ST_TO_ADDR
// side := GetSide ( tower ) ;
73362: LD_ADDR_VAR 0 16
73366: PUSH
73367: LD_VAR 0 1
73371: PPUSH
73372: CALL_OW 255
73376: ST_TO_ADDR
// x := GetX ( tower ) ;
73377: LD_ADDR_VAR 0 10
73381: PUSH
73382: LD_VAR 0 1
73386: PPUSH
73387: CALL_OW 250
73391: ST_TO_ADDR
// y := GetY ( tower ) ;
73392: LD_ADDR_VAR 0 11
73396: PUSH
73397: LD_VAR 0 1
73401: PPUSH
73402: CALL_OW 251
73406: ST_TO_ADDR
// if not x or not y then
73407: LD_VAR 0 10
73411: NOT
73412: PUSH
73413: LD_VAR 0 11
73417: NOT
73418: OR
73419: IFFALSE 73423
// exit ;
73421: GO 74483
// weapon := 0 ;
73423: LD_ADDR_VAR 0 18
73427: PUSH
73428: LD_INT 0
73430: ST_TO_ADDR
// fac_list := [ ] ;
73431: LD_ADDR_VAR 0 17
73435: PUSH
73436: EMPTY
73437: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
73438: LD_ADDR_VAR 0 6
73442: PUSH
73443: LD_VAR 0 1
73447: PPUSH
73448: CALL_OW 274
73452: PPUSH
73453: LD_VAR 0 2
73457: PPUSH
73458: CALL 71061 0 2
73462: PPUSH
73463: LD_INT 30
73465: PUSH
73466: LD_INT 3
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PPUSH
73473: CALL_OW 72
73477: ST_TO_ADDR
// if not factories then
73478: LD_VAR 0 6
73482: NOT
73483: IFFALSE 73487
// exit ;
73485: GO 74483
// for i in factories do
73487: LD_ADDR_VAR 0 8
73491: PUSH
73492: LD_VAR 0 6
73496: PUSH
73497: FOR_IN
73498: IFFALSE 73523
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73500: LD_ADDR_VAR 0 17
73504: PUSH
73505: LD_VAR 0 17
73509: PUSH
73510: LD_VAR 0 8
73514: PPUSH
73515: CALL_OW 478
73519: UNION
73520: ST_TO_ADDR
73521: GO 73497
73523: POP
73524: POP
// if not fac_list then
73525: LD_VAR 0 17
73529: NOT
73530: IFFALSE 73534
// exit ;
73532: GO 74483
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73534: LD_ADDR_VAR 0 5
73538: PUSH
73539: LD_INT 4
73541: PUSH
73542: LD_INT 5
73544: PUSH
73545: LD_INT 9
73547: PUSH
73548: LD_INT 10
73550: PUSH
73551: LD_INT 6
73553: PUSH
73554: LD_INT 7
73556: PUSH
73557: LD_INT 11
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 27
73571: PUSH
73572: LD_INT 28
73574: PUSH
73575: LD_INT 26
73577: PUSH
73578: LD_INT 30
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 43
73589: PUSH
73590: LD_INT 44
73592: PUSH
73593: LD_INT 46
73595: PUSH
73596: LD_INT 45
73598: PUSH
73599: LD_INT 47
73601: PUSH
73602: LD_INT 49
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: LIST
73617: PUSH
73618: LD_VAR 0 12
73622: ARRAY
73623: ST_TO_ADDR
// for i in list do
73624: LD_ADDR_VAR 0 8
73628: PUSH
73629: LD_VAR 0 5
73633: PUSH
73634: FOR_IN
73635: IFFALSE 73668
// if not i in fac_list then
73637: LD_VAR 0 8
73641: PUSH
73642: LD_VAR 0 17
73646: IN
73647: NOT
73648: IFFALSE 73666
// list := list diff i ;
73650: LD_ADDR_VAR 0 5
73654: PUSH
73655: LD_VAR 0 5
73659: PUSH
73660: LD_VAR 0 8
73664: DIFF
73665: ST_TO_ADDR
73666: GO 73634
73668: POP
73669: POP
// if not list then
73670: LD_VAR 0 5
73674: NOT
73675: IFFALSE 73679
// exit ;
73677: GO 74483
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73679: LD_VAR 0 12
73683: PUSH
73684: LD_INT 3
73686: EQUAL
73687: PUSH
73688: LD_INT 49
73690: PUSH
73691: LD_VAR 0 5
73695: IN
73696: AND
73697: PUSH
73698: LD_INT 31
73700: PPUSH
73701: LD_VAR 0 16
73705: PPUSH
73706: CALL_OW 321
73710: PUSH
73711: LD_INT 2
73713: EQUAL
73714: AND
73715: IFFALSE 73775
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73717: LD_INT 22
73719: PUSH
73720: LD_VAR 0 16
73724: PUSH
73725: EMPTY
73726: LIST
73727: LIST
73728: PUSH
73729: LD_INT 35
73731: PUSH
73732: LD_INT 49
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 91
73741: PUSH
73742: LD_VAR 0 1
73746: PUSH
73747: LD_INT 10
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: LIST
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: LIST
73759: PPUSH
73760: CALL_OW 69
73764: NOT
73765: IFFALSE 73775
// weapon := ru_time_lapser ;
73767: LD_ADDR_VAR 0 18
73771: PUSH
73772: LD_INT 49
73774: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73775: LD_VAR 0 12
73779: PUSH
73780: LD_INT 1
73782: PUSH
73783: LD_INT 2
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: IN
73790: PUSH
73791: LD_INT 11
73793: PUSH
73794: LD_VAR 0 5
73798: IN
73799: PUSH
73800: LD_INT 30
73802: PUSH
73803: LD_VAR 0 5
73807: IN
73808: OR
73809: AND
73810: PUSH
73811: LD_INT 6
73813: PPUSH
73814: LD_VAR 0 16
73818: PPUSH
73819: CALL_OW 321
73823: PUSH
73824: LD_INT 2
73826: EQUAL
73827: AND
73828: IFFALSE 73993
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
73830: LD_INT 22
73832: PUSH
73833: LD_VAR 0 16
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: LD_INT 2
73844: PUSH
73845: LD_INT 35
73847: PUSH
73848: LD_INT 11
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 35
73857: PUSH
73858: LD_INT 30
73860: PUSH
73861: EMPTY
73862: LIST
73863: LIST
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 91
73872: PUSH
73873: LD_VAR 0 1
73877: PUSH
73878: LD_INT 18
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: LIST
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: LIST
73890: PPUSH
73891: CALL_OW 69
73895: NOT
73896: PUSH
73897: LD_INT 22
73899: PUSH
73900: LD_VAR 0 16
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 2
73911: PUSH
73912: LD_INT 30
73914: PUSH
73915: LD_INT 32
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 30
73924: PUSH
73925: LD_INT 33
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: EMPTY
73933: LIST
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 91
73939: PUSH
73940: LD_VAR 0 1
73944: PUSH
73945: LD_INT 12
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: LIST
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: LIST
73957: PUSH
73958: EMPTY
73959: LIST
73960: PPUSH
73961: CALL_OW 69
73965: PUSH
73966: LD_INT 2
73968: GREATER
73969: AND
73970: IFFALSE 73993
// weapon := [ us_radar , ar_radar ] [ nat ] ;
73972: LD_ADDR_VAR 0 18
73976: PUSH
73977: LD_INT 11
73979: PUSH
73980: LD_INT 30
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_VAR 0 12
73991: ARRAY
73992: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
73993: LD_VAR 0 18
73997: NOT
73998: PUSH
73999: LD_INT 40
74001: PPUSH
74002: LD_VAR 0 16
74006: PPUSH
74007: CALL_OW 321
74011: PUSH
74012: LD_INT 2
74014: EQUAL
74015: AND
74016: PUSH
74017: LD_INT 7
74019: PUSH
74020: LD_VAR 0 5
74024: IN
74025: PUSH
74026: LD_INT 28
74028: PUSH
74029: LD_VAR 0 5
74033: IN
74034: OR
74035: PUSH
74036: LD_INT 45
74038: PUSH
74039: LD_VAR 0 5
74043: IN
74044: OR
74045: AND
74046: IFFALSE 74300
// begin hex := GetHexInfo ( x , y ) ;
74048: LD_ADDR_VAR 0 4
74052: PUSH
74053: LD_VAR 0 10
74057: PPUSH
74058: LD_VAR 0 11
74062: PPUSH
74063: CALL_OW 546
74067: ST_TO_ADDR
// if hex [ 1 ] then
74068: LD_VAR 0 4
74072: PUSH
74073: LD_INT 1
74075: ARRAY
74076: IFFALSE 74080
// exit ;
74078: GO 74483
// height := hex [ 2 ] ;
74080: LD_ADDR_VAR 0 15
74084: PUSH
74085: LD_VAR 0 4
74089: PUSH
74090: LD_INT 2
74092: ARRAY
74093: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74094: LD_ADDR_VAR 0 14
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: LD_INT 2
74104: PUSH
74105: LD_INT 3
74107: PUSH
74108: LD_INT 5
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: LIST
74115: LIST
74116: ST_TO_ADDR
// for i in tmp do
74117: LD_ADDR_VAR 0 8
74121: PUSH
74122: LD_VAR 0 14
74126: PUSH
74127: FOR_IN
74128: IFFALSE 74298
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74130: LD_ADDR_VAR 0 9
74134: PUSH
74135: LD_VAR 0 10
74139: PPUSH
74140: LD_VAR 0 8
74144: PPUSH
74145: LD_INT 5
74147: PPUSH
74148: CALL_OW 272
74152: PUSH
74153: LD_VAR 0 11
74157: PPUSH
74158: LD_VAR 0 8
74162: PPUSH
74163: LD_INT 5
74165: PPUSH
74166: CALL_OW 273
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74175: LD_VAR 0 9
74179: PUSH
74180: LD_INT 1
74182: ARRAY
74183: PPUSH
74184: LD_VAR 0 9
74188: PUSH
74189: LD_INT 2
74191: ARRAY
74192: PPUSH
74193: CALL_OW 488
74197: IFFALSE 74296
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74199: LD_ADDR_VAR 0 4
74203: PUSH
74204: LD_VAR 0 9
74208: PUSH
74209: LD_INT 1
74211: ARRAY
74212: PPUSH
74213: LD_VAR 0 9
74217: PUSH
74218: LD_INT 2
74220: ARRAY
74221: PPUSH
74222: CALL_OW 546
74226: ST_TO_ADDR
// if hex [ 1 ] then
74227: LD_VAR 0 4
74231: PUSH
74232: LD_INT 1
74234: ARRAY
74235: IFFALSE 74239
// continue ;
74237: GO 74127
// h := hex [ 2 ] ;
74239: LD_ADDR_VAR 0 13
74243: PUSH
74244: LD_VAR 0 4
74248: PUSH
74249: LD_INT 2
74251: ARRAY
74252: ST_TO_ADDR
// if h + 7 < height then
74253: LD_VAR 0 13
74257: PUSH
74258: LD_INT 7
74260: PLUS
74261: PUSH
74262: LD_VAR 0 15
74266: LESS
74267: IFFALSE 74296
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74269: LD_ADDR_VAR 0 18
74273: PUSH
74274: LD_INT 7
74276: PUSH
74277: LD_INT 28
74279: PUSH
74280: LD_INT 45
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: LIST
74287: PUSH
74288: LD_VAR 0 12
74292: ARRAY
74293: ST_TO_ADDR
// break ;
74294: GO 74298
// end ; end ; end ;
74296: GO 74127
74298: POP
74299: POP
// end ; if not weapon then
74300: LD_VAR 0 18
74304: NOT
74305: IFFALSE 74365
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74307: LD_ADDR_VAR 0 5
74311: PUSH
74312: LD_VAR 0 5
74316: PUSH
74317: LD_INT 11
74319: PUSH
74320: LD_INT 30
74322: PUSH
74323: LD_INT 49
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: LIST
74330: DIFF
74331: ST_TO_ADDR
// if not list then
74332: LD_VAR 0 5
74336: NOT
74337: IFFALSE 74341
// exit ;
74339: GO 74483
// weapon := list [ rand ( 1 , list ) ] ;
74341: LD_ADDR_VAR 0 18
74345: PUSH
74346: LD_VAR 0 5
74350: PUSH
74351: LD_INT 1
74353: PPUSH
74354: LD_VAR 0 5
74358: PPUSH
74359: CALL_OW 12
74363: ARRAY
74364: ST_TO_ADDR
// end ; if weapon then
74365: LD_VAR 0 18
74369: IFFALSE 74483
// begin tmp := CostOfWeapon ( weapon ) ;
74371: LD_ADDR_VAR 0 14
74375: PUSH
74376: LD_VAR 0 18
74380: PPUSH
74381: CALL_OW 451
74385: ST_TO_ADDR
// j := GetBase ( tower ) ;
74386: LD_ADDR_VAR 0 9
74390: PUSH
74391: LD_VAR 0 1
74395: PPUSH
74396: CALL_OW 274
74400: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74401: LD_VAR 0 9
74405: PPUSH
74406: LD_INT 1
74408: PPUSH
74409: CALL_OW 275
74413: PUSH
74414: LD_VAR 0 14
74418: PUSH
74419: LD_INT 1
74421: ARRAY
74422: GREATEREQUAL
74423: PUSH
74424: LD_VAR 0 9
74428: PPUSH
74429: LD_INT 2
74431: PPUSH
74432: CALL_OW 275
74436: PUSH
74437: LD_VAR 0 14
74441: PUSH
74442: LD_INT 2
74444: ARRAY
74445: GREATEREQUAL
74446: AND
74447: PUSH
74448: LD_VAR 0 9
74452: PPUSH
74453: LD_INT 3
74455: PPUSH
74456: CALL_OW 275
74460: PUSH
74461: LD_VAR 0 14
74465: PUSH
74466: LD_INT 3
74468: ARRAY
74469: GREATEREQUAL
74470: AND
74471: IFFALSE 74483
// result := weapon ;
74473: LD_ADDR_VAR 0 3
74477: PUSH
74478: LD_VAR 0 18
74482: ST_TO_ADDR
// end ; end ;
74483: LD_VAR 0 3
74487: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74488: LD_INT 0
74490: PPUSH
74491: PPUSH
// result := true ;
74492: LD_ADDR_VAR 0 3
74496: PUSH
74497: LD_INT 1
74499: ST_TO_ADDR
// if array1 = array2 then
74500: LD_VAR 0 1
74504: PUSH
74505: LD_VAR 0 2
74509: EQUAL
74510: IFFALSE 74570
// begin for i = 1 to array1 do
74512: LD_ADDR_VAR 0 4
74516: PUSH
74517: DOUBLE
74518: LD_INT 1
74520: DEC
74521: ST_TO_ADDR
74522: LD_VAR 0 1
74526: PUSH
74527: FOR_TO
74528: IFFALSE 74566
// if array1 [ i ] <> array2 [ i ] then
74530: LD_VAR 0 1
74534: PUSH
74535: LD_VAR 0 4
74539: ARRAY
74540: PUSH
74541: LD_VAR 0 2
74545: PUSH
74546: LD_VAR 0 4
74550: ARRAY
74551: NONEQUAL
74552: IFFALSE 74564
// begin result := false ;
74554: LD_ADDR_VAR 0 3
74558: PUSH
74559: LD_INT 0
74561: ST_TO_ADDR
// break ;
74562: GO 74566
// end ;
74564: GO 74527
74566: POP
74567: POP
// end else
74568: GO 74578
// result := false ;
74570: LD_ADDR_VAR 0 3
74574: PUSH
74575: LD_INT 0
74577: ST_TO_ADDR
// end ;
74578: LD_VAR 0 3
74582: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74583: LD_INT 0
74585: PPUSH
74586: PPUSH
74587: PPUSH
// pom := GetBase ( fac ) ;
74588: LD_ADDR_VAR 0 5
74592: PUSH
74593: LD_VAR 0 1
74597: PPUSH
74598: CALL_OW 274
74602: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74603: LD_ADDR_VAR 0 4
74607: PUSH
74608: LD_VAR 0 2
74612: PUSH
74613: LD_INT 1
74615: ARRAY
74616: PPUSH
74617: LD_VAR 0 2
74621: PUSH
74622: LD_INT 2
74624: ARRAY
74625: PPUSH
74626: LD_VAR 0 2
74630: PUSH
74631: LD_INT 3
74633: ARRAY
74634: PPUSH
74635: LD_VAR 0 2
74639: PUSH
74640: LD_INT 4
74642: ARRAY
74643: PPUSH
74644: CALL_OW 449
74648: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74649: LD_ADDR_VAR 0 3
74653: PUSH
74654: LD_VAR 0 5
74658: PPUSH
74659: LD_INT 1
74661: PPUSH
74662: CALL_OW 275
74666: PUSH
74667: LD_VAR 0 4
74671: PUSH
74672: LD_INT 1
74674: ARRAY
74675: GREATEREQUAL
74676: PUSH
74677: LD_VAR 0 5
74681: PPUSH
74682: LD_INT 2
74684: PPUSH
74685: CALL_OW 275
74689: PUSH
74690: LD_VAR 0 4
74694: PUSH
74695: LD_INT 2
74697: ARRAY
74698: GREATEREQUAL
74699: AND
74700: PUSH
74701: LD_VAR 0 5
74705: PPUSH
74706: LD_INT 3
74708: PPUSH
74709: CALL_OW 275
74713: PUSH
74714: LD_VAR 0 4
74718: PUSH
74719: LD_INT 3
74721: ARRAY
74722: GREATEREQUAL
74723: AND
74724: ST_TO_ADDR
// end ;
74725: LD_VAR 0 3
74729: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74730: LD_INT 0
74732: PPUSH
74733: PPUSH
74734: PPUSH
74735: PPUSH
// pom := GetBase ( building ) ;
74736: LD_ADDR_VAR 0 3
74740: PUSH
74741: LD_VAR 0 1
74745: PPUSH
74746: CALL_OW 274
74750: ST_TO_ADDR
// if not pom then
74751: LD_VAR 0 3
74755: NOT
74756: IFFALSE 74760
// exit ;
74758: GO 74930
// btype := GetBType ( building ) ;
74760: LD_ADDR_VAR 0 5
74764: PUSH
74765: LD_VAR 0 1
74769: PPUSH
74770: CALL_OW 266
74774: ST_TO_ADDR
// if btype = b_armoury then
74775: LD_VAR 0 5
74779: PUSH
74780: LD_INT 4
74782: EQUAL
74783: IFFALSE 74793
// btype := b_barracks ;
74785: LD_ADDR_VAR 0 5
74789: PUSH
74790: LD_INT 5
74792: ST_TO_ADDR
// if btype = b_depot then
74793: LD_VAR 0 5
74797: PUSH
74798: LD_INT 0
74800: EQUAL
74801: IFFALSE 74811
// btype := b_warehouse ;
74803: LD_ADDR_VAR 0 5
74807: PUSH
74808: LD_INT 1
74810: ST_TO_ADDR
// if btype = b_workshop then
74811: LD_VAR 0 5
74815: PUSH
74816: LD_INT 2
74818: EQUAL
74819: IFFALSE 74829
// btype := b_factory ;
74821: LD_ADDR_VAR 0 5
74825: PUSH
74826: LD_INT 3
74828: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74829: LD_ADDR_VAR 0 4
74833: PUSH
74834: LD_VAR 0 5
74838: PPUSH
74839: LD_VAR 0 1
74843: PPUSH
74844: CALL_OW 248
74848: PPUSH
74849: CALL_OW 450
74853: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74854: LD_ADDR_VAR 0 2
74858: PUSH
74859: LD_VAR 0 3
74863: PPUSH
74864: LD_INT 1
74866: PPUSH
74867: CALL_OW 275
74871: PUSH
74872: LD_VAR 0 4
74876: PUSH
74877: LD_INT 1
74879: ARRAY
74880: GREATEREQUAL
74881: PUSH
74882: LD_VAR 0 3
74886: PPUSH
74887: LD_INT 2
74889: PPUSH
74890: CALL_OW 275
74894: PUSH
74895: LD_VAR 0 4
74899: PUSH
74900: LD_INT 2
74902: ARRAY
74903: GREATEREQUAL
74904: AND
74905: PUSH
74906: LD_VAR 0 3
74910: PPUSH
74911: LD_INT 3
74913: PPUSH
74914: CALL_OW 275
74918: PUSH
74919: LD_VAR 0 4
74923: PUSH
74924: LD_INT 3
74926: ARRAY
74927: GREATEREQUAL
74928: AND
74929: ST_TO_ADDR
// end ;
74930: LD_VAR 0 2
74934: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
74935: LD_INT 0
74937: PPUSH
74938: PPUSH
74939: PPUSH
// pom := GetBase ( building ) ;
74940: LD_ADDR_VAR 0 4
74944: PUSH
74945: LD_VAR 0 1
74949: PPUSH
74950: CALL_OW 274
74954: ST_TO_ADDR
// if not pom then
74955: LD_VAR 0 4
74959: NOT
74960: IFFALSE 74964
// exit ;
74962: GO 75065
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74964: LD_ADDR_VAR 0 5
74968: PUSH
74969: LD_VAR 0 2
74973: PPUSH
74974: LD_VAR 0 1
74978: PPUSH
74979: CALL_OW 248
74983: PPUSH
74984: CALL_OW 450
74988: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74989: LD_ADDR_VAR 0 3
74993: PUSH
74994: LD_VAR 0 4
74998: PPUSH
74999: LD_INT 1
75001: PPUSH
75002: CALL_OW 275
75006: PUSH
75007: LD_VAR 0 5
75011: PUSH
75012: LD_INT 1
75014: ARRAY
75015: GREATEREQUAL
75016: PUSH
75017: LD_VAR 0 4
75021: PPUSH
75022: LD_INT 2
75024: PPUSH
75025: CALL_OW 275
75029: PUSH
75030: LD_VAR 0 5
75034: PUSH
75035: LD_INT 2
75037: ARRAY
75038: GREATEREQUAL
75039: AND
75040: PUSH
75041: LD_VAR 0 4
75045: PPUSH
75046: LD_INT 3
75048: PPUSH
75049: CALL_OW 275
75053: PUSH
75054: LD_VAR 0 5
75058: PUSH
75059: LD_INT 3
75061: ARRAY
75062: GREATEREQUAL
75063: AND
75064: ST_TO_ADDR
// end ;
75065: LD_VAR 0 3
75069: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
75070: LD_INT 0
75072: PPUSH
75073: PPUSH
75074: PPUSH
75075: PPUSH
75076: PPUSH
75077: PPUSH
75078: PPUSH
75079: PPUSH
75080: PPUSH
75081: PPUSH
// result := false ;
75082: LD_ADDR_VAR 0 6
75086: PUSH
75087: LD_INT 0
75089: ST_TO_ADDR
// if not base or not btype or not x or not y then
75090: LD_VAR 0 1
75094: NOT
75095: PUSH
75096: LD_VAR 0 2
75100: NOT
75101: OR
75102: PUSH
75103: LD_VAR 0 3
75107: NOT
75108: OR
75109: PUSH
75110: LD_VAR 0 4
75114: NOT
75115: OR
75116: IFFALSE 75120
// exit ;
75118: GO 75711
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
75120: LD_ADDR_VAR 0 12
75124: PUSH
75125: LD_VAR 0 2
75129: PPUSH
75130: LD_VAR 0 3
75134: PPUSH
75135: LD_VAR 0 4
75139: PPUSH
75140: LD_VAR 0 5
75144: PPUSH
75145: LD_VAR 0 1
75149: PUSH
75150: LD_INT 1
75152: ARRAY
75153: PPUSH
75154: CALL_OW 248
75158: PPUSH
75159: LD_INT 0
75161: PPUSH
75162: CALL 76548 0 6
75166: ST_TO_ADDR
// if not hexes then
75167: LD_VAR 0 12
75171: NOT
75172: IFFALSE 75176
// exit ;
75174: GO 75711
// for i = 1 to hexes do
75176: LD_ADDR_VAR 0 7
75180: PUSH
75181: DOUBLE
75182: LD_INT 1
75184: DEC
75185: ST_TO_ADDR
75186: LD_VAR 0 12
75190: PUSH
75191: FOR_TO
75192: IFFALSE 75709
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75194: LD_ADDR_VAR 0 11
75198: PUSH
75199: LD_VAR 0 12
75203: PUSH
75204: LD_VAR 0 7
75208: ARRAY
75209: PUSH
75210: LD_INT 1
75212: ARRAY
75213: PPUSH
75214: LD_VAR 0 12
75218: PUSH
75219: LD_VAR 0 7
75223: ARRAY
75224: PUSH
75225: LD_INT 2
75227: ARRAY
75228: PPUSH
75229: CALL_OW 428
75233: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75234: LD_VAR 0 12
75238: PUSH
75239: LD_VAR 0 7
75243: ARRAY
75244: PUSH
75245: LD_INT 1
75247: ARRAY
75248: PPUSH
75249: LD_VAR 0 12
75253: PUSH
75254: LD_VAR 0 7
75258: ARRAY
75259: PUSH
75260: LD_INT 2
75262: ARRAY
75263: PPUSH
75264: CALL_OW 351
75268: PUSH
75269: LD_VAR 0 12
75273: PUSH
75274: LD_VAR 0 7
75278: ARRAY
75279: PUSH
75280: LD_INT 1
75282: ARRAY
75283: PPUSH
75284: LD_VAR 0 12
75288: PUSH
75289: LD_VAR 0 7
75293: ARRAY
75294: PUSH
75295: LD_INT 2
75297: ARRAY
75298: PPUSH
75299: CALL_OW 488
75303: NOT
75304: OR
75305: PUSH
75306: LD_VAR 0 11
75310: PPUSH
75311: CALL_OW 247
75315: PUSH
75316: LD_INT 3
75318: EQUAL
75319: OR
75320: IFFALSE 75326
// exit ;
75322: POP
75323: POP
75324: GO 75711
// if not tmp then
75326: LD_VAR 0 11
75330: NOT
75331: IFFALSE 75335
// continue ;
75333: GO 75191
// result := true ;
75335: LD_ADDR_VAR 0 6
75339: PUSH
75340: LD_INT 1
75342: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75343: LD_ADDR_VAR 0 15
75347: PUSH
75348: LD_INT 22
75350: PUSH
75351: LD_VAR 0 11
75355: PPUSH
75356: CALL_OW 255
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 2
75367: PUSH
75368: LD_INT 30
75370: PUSH
75371: LD_INT 0
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 30
75380: PUSH
75381: LD_INT 1
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: LIST
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PPUSH
75397: CALL_OW 69
75401: ST_TO_ADDR
// if dep then
75402: LD_VAR 0 15
75406: IFFALSE 75542
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75408: LD_ADDR_VAR 0 14
75412: PUSH
75413: LD_VAR 0 15
75417: PUSH
75418: LD_INT 1
75420: ARRAY
75421: PPUSH
75422: CALL_OW 250
75426: PPUSH
75427: LD_VAR 0 15
75431: PUSH
75432: LD_INT 1
75434: ARRAY
75435: PPUSH
75436: CALL_OW 254
75440: PPUSH
75441: LD_INT 5
75443: PPUSH
75444: CALL_OW 272
75448: PUSH
75449: LD_VAR 0 15
75453: PUSH
75454: LD_INT 1
75456: ARRAY
75457: PPUSH
75458: CALL_OW 251
75462: PPUSH
75463: LD_VAR 0 15
75467: PUSH
75468: LD_INT 1
75470: ARRAY
75471: PPUSH
75472: CALL_OW 254
75476: PPUSH
75477: LD_INT 5
75479: PPUSH
75480: CALL_OW 273
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75489: LD_VAR 0 14
75493: PUSH
75494: LD_INT 1
75496: ARRAY
75497: PPUSH
75498: LD_VAR 0 14
75502: PUSH
75503: LD_INT 2
75505: ARRAY
75506: PPUSH
75507: CALL_OW 488
75511: IFFALSE 75542
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
75513: LD_VAR 0 11
75517: PPUSH
75518: LD_VAR 0 14
75522: PUSH
75523: LD_INT 1
75525: ARRAY
75526: PPUSH
75527: LD_VAR 0 14
75531: PUSH
75532: LD_INT 2
75534: ARRAY
75535: PPUSH
75536: CALL_OW 111
// continue ;
75540: GO 75191
// end ; end ; r := GetDir ( tmp ) ;
75542: LD_ADDR_VAR 0 13
75546: PUSH
75547: LD_VAR 0 11
75551: PPUSH
75552: CALL_OW 254
75556: ST_TO_ADDR
// if r = 5 then
75557: LD_VAR 0 13
75561: PUSH
75562: LD_INT 5
75564: EQUAL
75565: IFFALSE 75575
// r := 0 ;
75567: LD_ADDR_VAR 0 13
75571: PUSH
75572: LD_INT 0
75574: ST_TO_ADDR
// for j = r to 5 do
75575: LD_ADDR_VAR 0 8
75579: PUSH
75580: DOUBLE
75581: LD_VAR 0 13
75585: DEC
75586: ST_TO_ADDR
75587: LD_INT 5
75589: PUSH
75590: FOR_TO
75591: IFFALSE 75705
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75593: LD_ADDR_VAR 0 9
75597: PUSH
75598: LD_VAR 0 11
75602: PPUSH
75603: CALL_OW 250
75607: PPUSH
75608: LD_VAR 0 8
75612: PPUSH
75613: LD_INT 2
75615: PPUSH
75616: CALL_OW 272
75620: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75621: LD_ADDR_VAR 0 10
75625: PUSH
75626: LD_VAR 0 11
75630: PPUSH
75631: CALL_OW 251
75635: PPUSH
75636: LD_VAR 0 8
75640: PPUSH
75641: LD_INT 2
75643: PPUSH
75644: CALL_OW 273
75648: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75649: LD_VAR 0 9
75653: PPUSH
75654: LD_VAR 0 10
75658: PPUSH
75659: CALL_OW 488
75663: PUSH
75664: LD_VAR 0 9
75668: PPUSH
75669: LD_VAR 0 10
75673: PPUSH
75674: CALL_OW 428
75678: NOT
75679: AND
75680: IFFALSE 75703
// begin ComMoveXY ( tmp , _x , _y ) ;
75682: LD_VAR 0 11
75686: PPUSH
75687: LD_VAR 0 9
75691: PPUSH
75692: LD_VAR 0 10
75696: PPUSH
75697: CALL_OW 111
// break ;
75701: GO 75705
// end ; end ;
75703: GO 75590
75705: POP
75706: POP
// end ;
75707: GO 75191
75709: POP
75710: POP
// end ;
75711: LD_VAR 0 6
75715: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
75716: LD_INT 0
75718: PPUSH
75719: PPUSH
75720: PPUSH
75721: PPUSH
75722: PPUSH
75723: PPUSH
75724: PPUSH
75725: PPUSH
75726: PPUSH
75727: PPUSH
// result := false ;
75728: LD_ADDR_VAR 0 6
75732: PUSH
75733: LD_INT 0
75735: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
75736: LD_VAR 0 1
75740: NOT
75741: PUSH
75742: LD_VAR 0 1
75746: PPUSH
75747: CALL_OW 266
75751: PUSH
75752: LD_INT 0
75754: PUSH
75755: LD_INT 1
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: IN
75762: NOT
75763: OR
75764: PUSH
75765: LD_VAR 0 2
75769: NOT
75770: OR
75771: PUSH
75772: LD_VAR 0 5
75776: PUSH
75777: LD_INT 0
75779: PUSH
75780: LD_INT 1
75782: PUSH
75783: LD_INT 2
75785: PUSH
75786: LD_INT 3
75788: PUSH
75789: LD_INT 4
75791: PUSH
75792: LD_INT 5
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: IN
75803: NOT
75804: OR
75805: PUSH
75806: LD_VAR 0 3
75810: PPUSH
75811: LD_VAR 0 4
75815: PPUSH
75816: CALL_OW 488
75820: NOT
75821: OR
75822: IFFALSE 75826
// exit ;
75824: GO 76543
// pom := GetBase ( bdepot ) ;
75826: LD_ADDR_VAR 0 10
75830: PUSH
75831: LD_VAR 0 1
75835: PPUSH
75836: CALL_OW 274
75840: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
75841: LD_ADDR_VAR 0 11
75845: PUSH
75846: LD_VAR 0 2
75850: PPUSH
75851: LD_VAR 0 1
75855: PPUSH
75856: CALL_OW 248
75860: PPUSH
75861: CALL_OW 450
75865: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
75866: LD_VAR 0 10
75870: PPUSH
75871: LD_INT 1
75873: PPUSH
75874: CALL_OW 275
75878: PUSH
75879: LD_VAR 0 11
75883: PUSH
75884: LD_INT 1
75886: ARRAY
75887: GREATEREQUAL
75888: PUSH
75889: LD_VAR 0 10
75893: PPUSH
75894: LD_INT 2
75896: PPUSH
75897: CALL_OW 275
75901: PUSH
75902: LD_VAR 0 11
75906: PUSH
75907: LD_INT 2
75909: ARRAY
75910: GREATEREQUAL
75911: AND
75912: PUSH
75913: LD_VAR 0 10
75917: PPUSH
75918: LD_INT 3
75920: PPUSH
75921: CALL_OW 275
75925: PUSH
75926: LD_VAR 0 11
75930: PUSH
75931: LD_INT 3
75933: ARRAY
75934: GREATEREQUAL
75935: AND
75936: NOT
75937: IFFALSE 75941
// exit ;
75939: GO 76543
// if GetBType ( bdepot ) = b_depot then
75941: LD_VAR 0 1
75945: PPUSH
75946: CALL_OW 266
75950: PUSH
75951: LD_INT 0
75953: EQUAL
75954: IFFALSE 75966
// dist := 28 else
75956: LD_ADDR_VAR 0 14
75960: PUSH
75961: LD_INT 28
75963: ST_TO_ADDR
75964: GO 75974
// dist := 36 ;
75966: LD_ADDR_VAR 0 14
75970: PUSH
75971: LD_INT 36
75973: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
75974: LD_VAR 0 1
75978: PPUSH
75979: LD_VAR 0 3
75983: PPUSH
75984: LD_VAR 0 4
75988: PPUSH
75989: CALL_OW 297
75993: PUSH
75994: LD_VAR 0 14
75998: GREATER
75999: IFFALSE 76003
// exit ;
76001: GO 76543
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
76003: LD_ADDR_VAR 0 12
76007: PUSH
76008: LD_VAR 0 2
76012: PPUSH
76013: LD_VAR 0 3
76017: PPUSH
76018: LD_VAR 0 4
76022: PPUSH
76023: LD_VAR 0 5
76027: PPUSH
76028: LD_VAR 0 1
76032: PPUSH
76033: CALL_OW 248
76037: PPUSH
76038: LD_INT 0
76040: PPUSH
76041: CALL 76548 0 6
76045: ST_TO_ADDR
// if not hexes then
76046: LD_VAR 0 12
76050: NOT
76051: IFFALSE 76055
// exit ;
76053: GO 76543
// hex := GetHexInfo ( x , y ) ;
76055: LD_ADDR_VAR 0 15
76059: PUSH
76060: LD_VAR 0 3
76064: PPUSH
76065: LD_VAR 0 4
76069: PPUSH
76070: CALL_OW 546
76074: ST_TO_ADDR
// if hex [ 1 ] then
76075: LD_VAR 0 15
76079: PUSH
76080: LD_INT 1
76082: ARRAY
76083: IFFALSE 76087
// exit ;
76085: GO 76543
// height := hex [ 2 ] ;
76087: LD_ADDR_VAR 0 13
76091: PUSH
76092: LD_VAR 0 15
76096: PUSH
76097: LD_INT 2
76099: ARRAY
76100: ST_TO_ADDR
// for i = 1 to hexes do
76101: LD_ADDR_VAR 0 7
76105: PUSH
76106: DOUBLE
76107: LD_INT 1
76109: DEC
76110: ST_TO_ADDR
76111: LD_VAR 0 12
76115: PUSH
76116: FOR_TO
76117: IFFALSE 76447
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
76119: LD_VAR 0 12
76123: PUSH
76124: LD_VAR 0 7
76128: ARRAY
76129: PUSH
76130: LD_INT 1
76132: ARRAY
76133: PPUSH
76134: LD_VAR 0 12
76138: PUSH
76139: LD_VAR 0 7
76143: ARRAY
76144: PUSH
76145: LD_INT 2
76147: ARRAY
76148: PPUSH
76149: CALL_OW 488
76153: NOT
76154: PUSH
76155: LD_VAR 0 12
76159: PUSH
76160: LD_VAR 0 7
76164: ARRAY
76165: PUSH
76166: LD_INT 1
76168: ARRAY
76169: PPUSH
76170: LD_VAR 0 12
76174: PUSH
76175: LD_VAR 0 7
76179: ARRAY
76180: PUSH
76181: LD_INT 2
76183: ARRAY
76184: PPUSH
76185: CALL_OW 428
76189: PUSH
76190: LD_INT 0
76192: GREATER
76193: OR
76194: PUSH
76195: LD_VAR 0 12
76199: PUSH
76200: LD_VAR 0 7
76204: ARRAY
76205: PUSH
76206: LD_INT 1
76208: ARRAY
76209: PPUSH
76210: LD_VAR 0 12
76214: PUSH
76215: LD_VAR 0 7
76219: ARRAY
76220: PUSH
76221: LD_INT 2
76223: ARRAY
76224: PPUSH
76225: CALL_OW 351
76229: OR
76230: IFFALSE 76236
// exit ;
76232: POP
76233: POP
76234: GO 76543
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76236: LD_ADDR_VAR 0 8
76240: PUSH
76241: LD_VAR 0 12
76245: PUSH
76246: LD_VAR 0 7
76250: ARRAY
76251: PUSH
76252: LD_INT 1
76254: ARRAY
76255: PPUSH
76256: LD_VAR 0 12
76260: PUSH
76261: LD_VAR 0 7
76265: ARRAY
76266: PUSH
76267: LD_INT 2
76269: ARRAY
76270: PPUSH
76271: CALL_OW 546
76275: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
76276: LD_VAR 0 8
76280: PUSH
76281: LD_INT 1
76283: ARRAY
76284: PUSH
76285: LD_VAR 0 8
76289: PUSH
76290: LD_INT 2
76292: ARRAY
76293: PUSH
76294: LD_VAR 0 13
76298: PUSH
76299: LD_INT 2
76301: PLUS
76302: GREATER
76303: OR
76304: PUSH
76305: LD_VAR 0 8
76309: PUSH
76310: LD_INT 2
76312: ARRAY
76313: PUSH
76314: LD_VAR 0 13
76318: PUSH
76319: LD_INT 2
76321: MINUS
76322: LESS
76323: OR
76324: PUSH
76325: LD_VAR 0 8
76329: PUSH
76330: LD_INT 3
76332: ARRAY
76333: PUSH
76334: LD_INT 0
76336: PUSH
76337: LD_INT 8
76339: PUSH
76340: LD_INT 9
76342: PUSH
76343: LD_INT 10
76345: PUSH
76346: LD_INT 11
76348: PUSH
76349: LD_INT 12
76351: PUSH
76352: LD_INT 13
76354: PUSH
76355: LD_INT 16
76357: PUSH
76358: LD_INT 17
76360: PUSH
76361: LD_INT 18
76363: PUSH
76364: LD_INT 19
76366: PUSH
76367: LD_INT 20
76369: PUSH
76370: LD_INT 21
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: LIST
76377: LIST
76378: LIST
76379: LIST
76380: LIST
76381: LIST
76382: LIST
76383: LIST
76384: LIST
76385: LIST
76386: LIST
76387: IN
76388: NOT
76389: OR
76390: PUSH
76391: LD_VAR 0 8
76395: PUSH
76396: LD_INT 5
76398: ARRAY
76399: NOT
76400: OR
76401: PUSH
76402: LD_VAR 0 8
76406: PUSH
76407: LD_INT 6
76409: ARRAY
76410: PUSH
76411: LD_INT 1
76413: PUSH
76414: LD_INT 2
76416: PUSH
76417: LD_INT 7
76419: PUSH
76420: LD_INT 9
76422: PUSH
76423: LD_INT 10
76425: PUSH
76426: LD_INT 11
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: LIST
76433: LIST
76434: LIST
76435: LIST
76436: IN
76437: NOT
76438: OR
76439: IFFALSE 76445
// exit ;
76441: POP
76442: POP
76443: GO 76543
// end ;
76445: GO 76116
76447: POP
76448: POP
// side := GetSide ( bdepot ) ;
76449: LD_ADDR_VAR 0 9
76453: PUSH
76454: LD_VAR 0 1
76458: PPUSH
76459: CALL_OW 255
76463: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76464: LD_VAR 0 9
76468: PPUSH
76469: LD_VAR 0 3
76473: PPUSH
76474: LD_VAR 0 4
76478: PPUSH
76479: LD_INT 20
76481: PPUSH
76482: CALL 69215 0 4
76486: PUSH
76487: LD_INT 4
76489: ARRAY
76490: IFFALSE 76494
// exit ;
76492: GO 76543
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
76494: LD_VAR 0 2
76498: PUSH
76499: LD_INT 29
76501: PUSH
76502: LD_INT 30
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: IN
76509: PUSH
76510: LD_VAR 0 3
76514: PPUSH
76515: LD_VAR 0 4
76519: PPUSH
76520: LD_VAR 0 9
76524: PPUSH
76525: CALL_OW 440
76529: NOT
76530: AND
76531: IFFALSE 76535
// exit ;
76533: GO 76543
// result := true ;
76535: LD_ADDR_VAR 0 6
76539: PUSH
76540: LD_INT 1
76542: ST_TO_ADDR
// end ;
76543: LD_VAR 0 6
76547: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
76548: LD_INT 0
76550: PPUSH
76551: PPUSH
76552: PPUSH
76553: PPUSH
76554: PPUSH
76555: PPUSH
76556: PPUSH
76557: PPUSH
76558: PPUSH
76559: PPUSH
76560: PPUSH
76561: PPUSH
76562: PPUSH
76563: PPUSH
76564: PPUSH
76565: PPUSH
76566: PPUSH
76567: PPUSH
76568: PPUSH
76569: PPUSH
76570: PPUSH
76571: PPUSH
76572: PPUSH
76573: PPUSH
76574: PPUSH
76575: PPUSH
76576: PPUSH
76577: PPUSH
76578: PPUSH
76579: PPUSH
76580: PPUSH
76581: PPUSH
76582: PPUSH
76583: PPUSH
76584: PPUSH
76585: PPUSH
76586: PPUSH
76587: PPUSH
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
76592: PPUSH
76593: PPUSH
76594: PPUSH
76595: PPUSH
76596: PPUSH
76597: PPUSH
76598: PPUSH
76599: PPUSH
76600: PPUSH
76601: PPUSH
76602: PPUSH
76603: PPUSH
76604: PPUSH
76605: PPUSH
76606: PPUSH
76607: PPUSH
// result = [ ] ;
76608: LD_ADDR_VAR 0 7
76612: PUSH
76613: EMPTY
76614: ST_TO_ADDR
// temp_list = [ ] ;
76615: LD_ADDR_VAR 0 9
76619: PUSH
76620: EMPTY
76621: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
76622: LD_VAR 0 4
76626: PUSH
76627: LD_INT 0
76629: PUSH
76630: LD_INT 1
76632: PUSH
76633: LD_INT 2
76635: PUSH
76636: LD_INT 3
76638: PUSH
76639: LD_INT 4
76641: PUSH
76642: LD_INT 5
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: IN
76653: NOT
76654: PUSH
76655: LD_VAR 0 1
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: LD_INT 1
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: IN
76670: PUSH
76671: LD_VAR 0 5
76675: PUSH
76676: LD_INT 1
76678: PUSH
76679: LD_INT 2
76681: PUSH
76682: LD_INT 3
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: LIST
76689: IN
76690: NOT
76691: AND
76692: OR
76693: IFFALSE 76697
// exit ;
76695: GO 95082
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
76697: LD_VAR 0 1
76701: PUSH
76702: LD_INT 6
76704: PUSH
76705: LD_INT 7
76707: PUSH
76708: LD_INT 8
76710: PUSH
76711: LD_INT 13
76713: PUSH
76714: LD_INT 12
76716: PUSH
76717: LD_INT 15
76719: PUSH
76720: LD_INT 11
76722: PUSH
76723: LD_INT 14
76725: PUSH
76726: LD_INT 10
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: LIST
76733: LIST
76734: LIST
76735: LIST
76736: LIST
76737: LIST
76738: LIST
76739: IN
76740: IFFALSE 76750
// btype = b_lab ;
76742: LD_ADDR_VAR 0 1
76746: PUSH
76747: LD_INT 6
76749: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
76750: LD_VAR 0 6
76754: PUSH
76755: LD_INT 0
76757: PUSH
76758: LD_INT 1
76760: PUSH
76761: LD_INT 2
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: LIST
76768: IN
76769: NOT
76770: PUSH
76771: LD_VAR 0 1
76775: PUSH
76776: LD_INT 0
76778: PUSH
76779: LD_INT 1
76781: PUSH
76782: LD_INT 2
76784: PUSH
76785: LD_INT 3
76787: PUSH
76788: LD_INT 6
76790: PUSH
76791: LD_INT 36
76793: PUSH
76794: LD_INT 4
76796: PUSH
76797: LD_INT 5
76799: PUSH
76800: LD_INT 31
76802: PUSH
76803: LD_INT 32
76805: PUSH
76806: LD_INT 33
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: LIST
76816: LIST
76817: LIST
76818: LIST
76819: LIST
76820: LIST
76821: IN
76822: NOT
76823: PUSH
76824: LD_VAR 0 6
76828: PUSH
76829: LD_INT 1
76831: EQUAL
76832: AND
76833: OR
76834: PUSH
76835: LD_VAR 0 1
76839: PUSH
76840: LD_INT 2
76842: PUSH
76843: LD_INT 3
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: IN
76850: NOT
76851: PUSH
76852: LD_VAR 0 6
76856: PUSH
76857: LD_INT 2
76859: EQUAL
76860: AND
76861: OR
76862: IFFALSE 76872
// mode = 0 ;
76864: LD_ADDR_VAR 0 6
76868: PUSH
76869: LD_INT 0
76871: ST_TO_ADDR
// case mode of 0 :
76872: LD_VAR 0 6
76876: PUSH
76877: LD_INT 0
76879: DOUBLE
76880: EQUAL
76881: IFTRUE 76885
76883: GO 88338
76885: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76886: LD_ADDR_VAR 0 11
76890: PUSH
76891: LD_INT 0
76893: PUSH
76894: LD_INT 0
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 0
76903: PUSH
76904: LD_INT 1
76906: NEG
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: LD_INT 1
76914: PUSH
76915: LD_INT 0
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 1
76924: PUSH
76925: LD_INT 1
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 0
76934: PUSH
76935: LD_INT 1
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: LD_INT 1
76944: NEG
76945: PUSH
76946: LD_INT 0
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 1
76955: NEG
76956: PUSH
76957: LD_INT 1
76959: NEG
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PUSH
76965: LD_INT 1
76967: NEG
76968: PUSH
76969: LD_INT 2
76971: NEG
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 0
76979: PUSH
76980: LD_INT 2
76982: NEG
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 1
76990: PUSH
76991: LD_INT 1
76993: NEG
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 1
77001: PUSH
77002: LD_INT 2
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 0
77011: PUSH
77012: LD_INT 2
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 1
77032: PUSH
77033: LD_INT 3
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 0
77042: PUSH
77043: LD_INT 3
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: NEG
77053: PUSH
77054: LD_INT 2
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: LIST
77070: LIST
77071: LIST
77072: LIST
77073: LIST
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77079: LD_ADDR_VAR 0 12
77083: PUSH
77084: LD_INT 0
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 0
77096: PUSH
77097: LD_INT 1
77099: NEG
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 1
77107: PUSH
77108: LD_INT 0
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: PUSH
77115: LD_INT 1
77117: PUSH
77118: LD_INT 1
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 0
77127: PUSH
77128: LD_INT 1
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 1
77137: NEG
77138: PUSH
77139: LD_INT 0
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PUSH
77146: LD_INT 1
77148: NEG
77149: PUSH
77150: LD_INT 1
77152: NEG
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 1
77160: PUSH
77161: LD_INT 1
77163: NEG
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 2
77171: PUSH
77172: LD_INT 0
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 2
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 1
77191: NEG
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 2
77202: NEG
77203: PUSH
77204: LD_INT 0
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 2
77213: NEG
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 2
77225: NEG
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 3
77236: NEG
77237: PUSH
77238: LD_INT 0
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 3
77247: NEG
77248: PUSH
77249: LD_INT 1
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: LIST
77267: LIST
77268: LIST
77269: LIST
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77275: LD_ADDR_VAR 0 13
77279: PUSH
77280: LD_INT 0
77282: PUSH
77283: LD_INT 0
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: PUSH
77290: LD_INT 0
77292: PUSH
77293: LD_INT 1
77295: NEG
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: LD_INT 0
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 1
77313: PUSH
77314: LD_INT 1
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 0
77323: PUSH
77324: LD_INT 1
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 1
77333: NEG
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 1
77344: NEG
77345: PUSH
77346: LD_INT 1
77348: NEG
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 1
77356: NEG
77357: PUSH
77358: LD_INT 2
77360: NEG
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 2
77368: PUSH
77369: LD_INT 1
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 2
77378: PUSH
77379: LD_INT 2
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: LD_INT 2
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 2
77398: NEG
77399: PUSH
77400: LD_INT 1
77402: NEG
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 2
77410: NEG
77411: PUSH
77412: LD_INT 2
77414: NEG
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 2
77422: NEG
77423: PUSH
77424: LD_INT 3
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 3
77434: NEG
77435: PUSH
77436: LD_INT 2
77438: NEG
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 3
77446: NEG
77447: PUSH
77448: LD_INT 3
77450: NEG
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77474: LD_ADDR_VAR 0 14
77478: PUSH
77479: LD_INT 0
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 0
77491: PUSH
77492: LD_INT 1
77494: NEG
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 1
77502: PUSH
77503: LD_INT 0
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 1
77512: PUSH
77513: LD_INT 1
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: LD_INT 1
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 1
77532: NEG
77533: PUSH
77534: LD_INT 0
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 1
77543: NEG
77544: PUSH
77545: LD_INT 1
77547: NEG
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 1
77555: NEG
77556: PUSH
77557: LD_INT 2
77559: NEG
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: LD_INT 0
77567: PUSH
77568: LD_INT 2
77570: NEG
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: LD_INT 1
77578: PUSH
77579: LD_INT 1
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: LD_INT 2
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 0
77599: PUSH
77600: LD_INT 2
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 1
77609: NEG
77610: PUSH
77611: LD_INT 1
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 1
77620: NEG
77621: PUSH
77622: LD_INT 3
77624: NEG
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: LD_INT 3
77635: NEG
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 1
77643: PUSH
77644: LD_INT 2
77646: NEG
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77670: LD_ADDR_VAR 0 15
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: LD_INT 0
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 0
77687: PUSH
77688: LD_INT 1
77690: NEG
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 1
77698: PUSH
77699: LD_INT 0
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 1
77708: PUSH
77709: LD_INT 1
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 0
77718: PUSH
77719: LD_INT 1
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 1
77728: NEG
77729: PUSH
77730: LD_INT 0
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 1
77739: NEG
77740: PUSH
77741: LD_INT 1
77743: NEG
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 1
77751: PUSH
77752: LD_INT 1
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 2
77762: PUSH
77763: LD_INT 0
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 2
77772: PUSH
77773: LD_INT 1
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 1
77782: NEG
77783: PUSH
77784: LD_INT 1
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 2
77793: NEG
77794: PUSH
77795: LD_INT 0
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 2
77804: NEG
77805: PUSH
77806: LD_INT 1
77808: NEG
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: LD_INT 2
77816: PUSH
77817: LD_INT 1
77819: NEG
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: LD_INT 3
77827: PUSH
77828: LD_INT 0
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 3
77837: PUSH
77838: LD_INT 1
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: LIST
77860: LIST
77861: LIST
77862: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77863: LD_ADDR_VAR 0 16
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: LD_INT 0
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 0
77880: PUSH
77881: LD_INT 1
77883: NEG
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 1
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 1
77901: PUSH
77902: LD_INT 1
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: LD_INT 1
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: LD_INT 0
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 1
77932: NEG
77933: PUSH
77934: LD_INT 1
77936: NEG
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 1
77944: NEG
77945: PUSH
77946: LD_INT 2
77948: NEG
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: LD_INT 2
77956: PUSH
77957: LD_INT 1
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 2
77966: PUSH
77967: LD_INT 2
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 1
77976: PUSH
77977: LD_INT 2
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 2
77986: NEG
77987: PUSH
77988: LD_INT 1
77990: NEG
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 2
77998: NEG
77999: PUSH
78000: LD_INT 2
78002: NEG
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: PUSH
78011: LD_INT 2
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 3
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 2
78030: PUSH
78031: LD_INT 3
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: LIST
78042: LIST
78043: LIST
78044: LIST
78045: LIST
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78056: LD_ADDR_VAR 0 17
78060: PUSH
78061: LD_INT 0
78063: PUSH
78064: LD_INT 0
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 0
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 1
78084: PUSH
78085: LD_INT 0
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 1
78094: PUSH
78095: LD_INT 1
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 0
78104: PUSH
78105: LD_INT 1
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 1
78114: NEG
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 1
78125: NEG
78126: PUSH
78127: LD_INT 1
78129: NEG
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 1
78137: NEG
78138: PUSH
78139: LD_INT 2
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 0
78149: PUSH
78150: LD_INT 2
78152: NEG
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: LD_INT 1
78163: NEG
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 2
78171: PUSH
78172: LD_INT 0
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 2
78181: PUSH
78182: LD_INT 1
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 2
78191: PUSH
78192: LD_INT 2
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: LD_INT 1
78201: PUSH
78202: LD_INT 2
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: LD_INT 0
78211: PUSH
78212: LD_INT 2
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: LD_INT 1
78221: NEG
78222: PUSH
78223: LD_INT 1
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 2
78232: NEG
78233: PUSH
78234: LD_INT 0
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 2
78243: NEG
78244: PUSH
78245: LD_INT 1
78247: NEG
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 2
78255: NEG
78256: PUSH
78257: LD_INT 2
78259: NEG
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78286: LD_ADDR_VAR 0 18
78290: PUSH
78291: LD_INT 0
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 0
78303: PUSH
78304: LD_INT 1
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 1
78314: PUSH
78315: LD_INT 0
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 1
78324: PUSH
78325: LD_INT 1
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 1
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: NEG
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: NEG
78356: PUSH
78357: LD_INT 1
78359: NEG
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 1
78367: NEG
78368: PUSH
78369: LD_INT 2
78371: NEG
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 0
78379: PUSH
78380: LD_INT 2
78382: NEG
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 1
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 2
78401: PUSH
78402: LD_INT 0
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 2
78411: PUSH
78412: LD_INT 1
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 2
78421: PUSH
78422: LD_INT 2
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 1
78431: PUSH
78432: LD_INT 2
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: LD_INT 0
78441: PUSH
78442: LD_INT 2
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 1
78451: NEG
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 2
78462: NEG
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 2
78473: NEG
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 2
78485: NEG
78486: PUSH
78487: LD_INT 2
78489: NEG
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: LIST
78502: LIST
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: LIST
78509: LIST
78510: LIST
78511: LIST
78512: LIST
78513: LIST
78514: LIST
78515: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78516: LD_ADDR_VAR 0 19
78520: PUSH
78521: LD_INT 0
78523: PUSH
78524: LD_INT 0
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 0
78533: PUSH
78534: LD_INT 1
78536: NEG
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 1
78544: PUSH
78545: LD_INT 0
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: LD_INT 1
78554: PUSH
78555: LD_INT 1
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 0
78564: PUSH
78565: LD_INT 1
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 1
78574: NEG
78575: PUSH
78576: LD_INT 0
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 1
78585: NEG
78586: PUSH
78587: LD_INT 1
78589: NEG
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 1
78597: NEG
78598: PUSH
78599: LD_INT 2
78601: NEG
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 0
78609: PUSH
78610: LD_INT 2
78612: NEG
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 1
78620: PUSH
78621: LD_INT 1
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 2
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 2
78641: PUSH
78642: LD_INT 1
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 2
78651: PUSH
78652: LD_INT 2
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 2
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: LD_INT 2
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 1
78681: NEG
78682: PUSH
78683: LD_INT 1
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 2
78692: NEG
78693: PUSH
78694: LD_INT 0
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 2
78703: NEG
78704: PUSH
78705: LD_INT 1
78707: NEG
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 2
78715: NEG
78716: PUSH
78717: LD_INT 2
78719: NEG
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78746: LD_ADDR_VAR 0 20
78750: PUSH
78751: LD_INT 0
78753: PUSH
78754: LD_INT 0
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 0
78763: PUSH
78764: LD_INT 1
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 1
78774: PUSH
78775: LD_INT 0
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 1
78784: PUSH
78785: LD_INT 1
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 0
78794: PUSH
78795: LD_INT 1
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 1
78804: NEG
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 1
78815: NEG
78816: PUSH
78817: LD_INT 1
78819: NEG
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 1
78827: NEG
78828: PUSH
78829: LD_INT 2
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 0
78839: PUSH
78840: LD_INT 2
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 1
78853: NEG
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 2
78861: PUSH
78862: LD_INT 0
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 2
78871: PUSH
78872: LD_INT 1
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 2
78881: PUSH
78882: LD_INT 2
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 1
78891: PUSH
78892: LD_INT 2
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: LD_INT 2
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 1
78911: NEG
78912: PUSH
78913: LD_INT 1
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 2
78922: NEG
78923: PUSH
78924: LD_INT 0
78926: PUSH
78927: EMPTY
78928: LIST
78929: LIST
78930: PUSH
78931: LD_INT 2
78933: NEG
78934: PUSH
78935: LD_INT 1
78937: NEG
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 2
78945: NEG
78946: PUSH
78947: LD_INT 2
78949: NEG
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: LIST
78971: LIST
78972: LIST
78973: LIST
78974: LIST
78975: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78976: LD_ADDR_VAR 0 21
78980: PUSH
78981: LD_INT 0
78983: PUSH
78984: LD_INT 0
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 0
78993: PUSH
78994: LD_INT 1
78996: NEG
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 1
79004: PUSH
79005: LD_INT 0
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 1
79014: PUSH
79015: LD_INT 1
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 0
79024: PUSH
79025: LD_INT 1
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 1
79034: NEG
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 1
79045: NEG
79046: PUSH
79047: LD_INT 1
79049: NEG
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 1
79057: NEG
79058: PUSH
79059: LD_INT 2
79061: NEG
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 0
79069: PUSH
79070: LD_INT 2
79072: NEG
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 1
79080: PUSH
79081: LD_INT 1
79083: NEG
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 2
79091: PUSH
79092: LD_INT 0
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 2
79101: PUSH
79102: LD_INT 1
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 2
79111: PUSH
79112: LD_INT 2
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 1
79121: PUSH
79122: LD_INT 2
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 0
79131: PUSH
79132: LD_INT 2
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 1
79141: NEG
79142: PUSH
79143: LD_INT 1
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: NEG
79153: PUSH
79154: LD_INT 0
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 2
79163: NEG
79164: PUSH
79165: LD_INT 1
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 2
79175: NEG
79176: PUSH
79177: LD_INT 2
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79206: LD_ADDR_VAR 0 22
79210: PUSH
79211: LD_INT 0
79213: PUSH
79214: LD_INT 0
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 0
79223: PUSH
79224: LD_INT 1
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 1
79234: PUSH
79235: LD_INT 0
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 1
79244: PUSH
79245: LD_INT 1
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 0
79254: PUSH
79255: LD_INT 1
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 1
79264: NEG
79265: PUSH
79266: LD_INT 0
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 1
79275: NEG
79276: PUSH
79277: LD_INT 1
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 1
79287: NEG
79288: PUSH
79289: LD_INT 2
79291: NEG
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 0
79299: PUSH
79300: LD_INT 2
79302: NEG
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 1
79310: PUSH
79311: LD_INT 1
79313: NEG
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 2
79321: PUSH
79322: LD_INT 0
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 2
79331: PUSH
79332: LD_INT 1
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 2
79341: PUSH
79342: LD_INT 2
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 1
79351: PUSH
79352: LD_INT 2
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 0
79361: PUSH
79362: LD_INT 2
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 1
79371: NEG
79372: PUSH
79373: LD_INT 1
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 2
79382: NEG
79383: PUSH
79384: LD_INT 0
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 2
79393: NEG
79394: PUSH
79395: LD_INT 1
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 2
79405: NEG
79406: PUSH
79407: LD_INT 2
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79436: LD_ADDR_VAR 0 23
79440: PUSH
79441: LD_INT 0
79443: PUSH
79444: LD_INT 0
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 0
79453: PUSH
79454: LD_INT 1
79456: NEG
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: LD_INT 1
79464: PUSH
79465: LD_INT 0
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: LD_INT 1
79474: PUSH
79475: LD_INT 1
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PUSH
79482: LD_INT 0
79484: PUSH
79485: LD_INT 1
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 1
79494: NEG
79495: PUSH
79496: LD_INT 0
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 1
79505: NEG
79506: PUSH
79507: LD_INT 1
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 1
79517: NEG
79518: PUSH
79519: LD_INT 2
79521: NEG
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: LD_INT 2
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: LD_INT 1
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 2
79551: PUSH
79552: LD_INT 0
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 2
79561: PUSH
79562: LD_INT 1
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 2
79571: PUSH
79572: LD_INT 2
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 1
79581: PUSH
79582: LD_INT 2
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: LD_INT 2
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 1
79601: NEG
79602: PUSH
79603: LD_INT 1
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: LD_INT 2
79612: NEG
79613: PUSH
79614: LD_INT 0
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: LD_INT 1
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 2
79635: NEG
79636: PUSH
79637: LD_INT 2
79639: NEG
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 2
79647: NEG
79648: PUSH
79649: LD_INT 3
79651: NEG
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 1
79659: NEG
79660: PUSH
79661: LD_INT 3
79663: NEG
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 1
79671: PUSH
79672: LD_INT 2
79674: NEG
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 2
79682: PUSH
79683: LD_INT 1
79685: NEG
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: LIST
79695: LIST
79696: LIST
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
79716: LD_ADDR_VAR 0 24
79720: PUSH
79721: LD_INT 0
79723: PUSH
79724: LD_INT 0
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 0
79733: PUSH
79734: LD_INT 1
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: PUSH
79745: LD_INT 0
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 1
79754: PUSH
79755: LD_INT 1
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 0
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 1
79774: NEG
79775: PUSH
79776: LD_INT 0
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: LD_INT 1
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 1
79797: NEG
79798: PUSH
79799: LD_INT 2
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: LD_INT 2
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 1
79820: PUSH
79821: LD_INT 1
79823: NEG
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 2
79831: PUSH
79832: LD_INT 0
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 2
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 2
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: LD_INT 2
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: LD_INT 2
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: LD_INT 1
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 2
79892: NEG
79893: PUSH
79894: LD_INT 0
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 2
79903: NEG
79904: PUSH
79905: LD_INT 1
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 2
79915: NEG
79916: PUSH
79917: LD_INT 2
79919: NEG
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: LD_INT 2
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 2
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 3
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: PUSH
79960: LD_INT 2
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
79992: LD_ADDR_VAR 0 25
79996: PUSH
79997: LD_INT 0
79999: PUSH
80000: LD_INT 0
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 0
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 1
80020: PUSH
80021: LD_INT 0
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 1
80030: PUSH
80031: LD_INT 1
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 0
80040: PUSH
80041: LD_INT 1
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 1
80050: NEG
80051: PUSH
80052: LD_INT 0
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 1
80061: NEG
80062: PUSH
80063: LD_INT 1
80065: NEG
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 1
80073: NEG
80074: PUSH
80075: LD_INT 2
80077: NEG
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: LD_INT 2
80088: NEG
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: LD_INT 1
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 2
80107: PUSH
80108: LD_INT 0
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 2
80117: PUSH
80118: LD_INT 1
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 2
80127: PUSH
80128: LD_INT 2
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: LD_INT 1
80137: PUSH
80138: LD_INT 2
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 0
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 1
80157: NEG
80158: PUSH
80159: LD_INT 1
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: LD_INT 2
80168: NEG
80169: PUSH
80170: LD_INT 0
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 2
80179: NEG
80180: PUSH
80181: LD_INT 1
80183: NEG
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 2
80191: NEG
80192: PUSH
80193: LD_INT 2
80195: NEG
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: LD_INT 3
80203: PUSH
80204: LD_INT 1
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 3
80213: PUSH
80214: LD_INT 2
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 2
80223: PUSH
80224: LD_INT 3
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: PUSH
80234: LD_INT 3
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: LIST
80250: LIST
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80266: LD_ADDR_VAR 0 26
80270: PUSH
80271: LD_INT 0
80273: PUSH
80274: LD_INT 0
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 0
80283: PUSH
80284: LD_INT 1
80286: NEG
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 1
80294: PUSH
80295: LD_INT 0
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 0
80314: PUSH
80315: LD_INT 1
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 1
80324: NEG
80325: PUSH
80326: LD_INT 0
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: NEG
80336: PUSH
80337: LD_INT 1
80339: NEG
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 1
80347: NEG
80348: PUSH
80349: LD_INT 2
80351: NEG
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 0
80359: PUSH
80360: LD_INT 2
80362: NEG
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 1
80370: PUSH
80371: LD_INT 1
80373: NEG
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 2
80381: PUSH
80382: LD_INT 0
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 2
80391: PUSH
80392: LD_INT 1
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 2
80401: PUSH
80402: LD_INT 2
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 1
80411: PUSH
80412: LD_INT 2
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 0
80421: PUSH
80422: LD_INT 2
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: LD_INT 1
80431: NEG
80432: PUSH
80433: LD_INT 1
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 2
80442: NEG
80443: PUSH
80444: LD_INT 0
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 2
80453: NEG
80454: PUSH
80455: LD_INT 1
80457: NEG
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 2
80465: NEG
80466: PUSH
80467: LD_INT 2
80469: NEG
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 2
80477: PUSH
80478: LD_INT 3
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 1
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 1
80497: NEG
80498: PUSH
80499: LD_INT 2
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 2
80508: NEG
80509: PUSH
80510: LD_INT 1
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80542: LD_ADDR_VAR 0 27
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 1
80562: NEG
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 1
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 1
80600: NEG
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: LD_INT 1
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: NEG
80624: PUSH
80625: LD_INT 2
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 2
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 2
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 2
80677: PUSH
80678: LD_INT 2
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: PUSH
80688: LD_INT 2
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 0
80697: PUSH
80698: LD_INT 2
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 1
80707: NEG
80708: PUSH
80709: LD_INT 1
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 2
80718: NEG
80719: PUSH
80720: LD_INT 0
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: LD_INT 1
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: LD_INT 2
80745: NEG
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 1
80753: NEG
80754: PUSH
80755: LD_INT 2
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 2
80764: NEG
80765: PUSH
80766: LD_INT 1
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 3
80775: NEG
80776: PUSH
80777: LD_INT 1
80779: NEG
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 3
80787: NEG
80788: PUSH
80789: LD_INT 2
80791: NEG
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: LIST
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: LIST
80807: LIST
80808: LIST
80809: LIST
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80822: LD_ADDR_VAR 0 28
80826: PUSH
80827: LD_INT 0
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: LD_INT 1
80842: NEG
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 1
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 1
80860: PUSH
80861: LD_INT 1
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 0
80870: PUSH
80871: LD_INT 1
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 1
80880: NEG
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 1
80891: NEG
80892: PUSH
80893: LD_INT 1
80895: NEG
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 1
80903: NEG
80904: PUSH
80905: LD_INT 2
80907: NEG
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 0
80915: PUSH
80916: LD_INT 2
80918: NEG
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 1
80926: PUSH
80927: LD_INT 1
80929: NEG
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 2
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 2
80947: PUSH
80948: LD_INT 1
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 2
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 1
80967: PUSH
80968: LD_INT 2
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 0
80977: PUSH
80978: LD_INT 2
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 1
80987: NEG
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 2
80998: NEG
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 2
81009: NEG
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 2
81021: NEG
81022: PUSH
81023: LD_INT 2
81025: NEG
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 2
81033: NEG
81034: PUSH
81035: LD_INT 3
81037: NEG
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 1
81045: NEG
81046: PUSH
81047: LD_INT 3
81049: NEG
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 3
81057: NEG
81058: PUSH
81059: LD_INT 1
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 3
81069: NEG
81070: PUSH
81071: LD_INT 2
81073: NEG
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81104: LD_ADDR_VAR 0 29
81108: PUSH
81109: LD_INT 0
81111: PUSH
81112: LD_INT 0
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 0
81121: PUSH
81122: LD_INT 1
81124: NEG
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 1
81132: PUSH
81133: LD_INT 0
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 1
81142: PUSH
81143: LD_INT 1
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: LD_INT 1
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: PUSH
81160: LD_INT 1
81162: NEG
81163: PUSH
81164: LD_INT 0
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 1
81173: NEG
81174: PUSH
81175: LD_INT 1
81177: NEG
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: NEG
81186: PUSH
81187: LD_INT 2
81189: NEG
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 0
81197: PUSH
81198: LD_INT 2
81200: NEG
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 1
81208: PUSH
81209: LD_INT 1
81211: NEG
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 2
81219: PUSH
81220: LD_INT 0
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 2
81229: PUSH
81230: LD_INT 1
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 1
81239: PUSH
81240: LD_INT 2
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 0
81249: PUSH
81250: LD_INT 2
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: LD_INT 1
81259: NEG
81260: PUSH
81261: LD_INT 1
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: LD_INT 1
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 2
81282: NEG
81283: PUSH
81284: LD_INT 2
81286: NEG
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 2
81306: PUSH
81307: LD_INT 1
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 3
81317: PUSH
81318: LD_INT 1
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: LD_INT 3
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: PUSH
81339: LD_INT 2
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 3
81348: NEG
81349: PUSH
81350: LD_INT 2
81352: NEG
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: LIST
81364: LIST
81365: LIST
81366: LIST
81367: LIST
81368: LIST
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81383: LD_ADDR_VAR 0 30
81387: PUSH
81388: LD_INT 0
81390: PUSH
81391: LD_INT 0
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 0
81400: PUSH
81401: LD_INT 1
81403: NEG
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 1
81411: PUSH
81412: LD_INT 0
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 1
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 0
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 1
81441: NEG
81442: PUSH
81443: LD_INT 0
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 1
81452: NEG
81453: PUSH
81454: LD_INT 1
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 1
81464: NEG
81465: PUSH
81466: LD_INT 2
81468: NEG
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 0
81476: PUSH
81477: LD_INT 2
81479: NEG
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: LD_INT 1
81487: PUSH
81488: LD_INT 1
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 2
81498: PUSH
81499: LD_INT 0
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 2
81508: PUSH
81509: LD_INT 1
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 2
81518: PUSH
81519: LD_INT 2
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 1
81528: PUSH
81529: LD_INT 2
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: NEG
81539: PUSH
81540: LD_INT 1
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 2
81549: NEG
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 2
81560: NEG
81561: PUSH
81562: LD_INT 1
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 1
81572: NEG
81573: PUSH
81574: LD_INT 3
81576: NEG
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 1
81584: PUSH
81585: LD_INT 2
81587: NEG
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: LD_INT 3
81595: PUSH
81596: LD_INT 2
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 2
81605: PUSH
81606: LD_INT 3
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 2
81615: NEG
81616: PUSH
81617: LD_INT 1
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 3
81626: NEG
81627: PUSH
81628: LD_INT 1
81630: NEG
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: EMPTY
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81661: LD_ADDR_VAR 0 31
81665: PUSH
81666: LD_INT 0
81668: PUSH
81669: LD_INT 0
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 0
81678: PUSH
81679: LD_INT 1
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 1
81689: PUSH
81690: LD_INT 0
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 1
81699: PUSH
81700: LD_INT 1
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: LD_INT 1
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 1
81719: NEG
81720: PUSH
81721: LD_INT 0
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: NEG
81731: PUSH
81732: LD_INT 1
81734: NEG
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 1
81742: NEG
81743: PUSH
81744: LD_INT 2
81746: NEG
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 1
81754: PUSH
81755: LD_INT 1
81757: NEG
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 2
81765: PUSH
81766: LD_INT 0
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 2
81775: PUSH
81776: LD_INT 1
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 2
81785: PUSH
81786: LD_INT 2
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 1
81795: PUSH
81796: LD_INT 2
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 0
81805: PUSH
81806: LD_INT 2
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 1
81815: NEG
81816: PUSH
81817: LD_INT 1
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 2
81826: NEG
81827: PUSH
81828: LD_INT 1
81830: NEG
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 2
81838: NEG
81839: PUSH
81840: LD_INT 2
81842: NEG
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 2
81850: NEG
81851: PUSH
81852: LD_INT 3
81854: NEG
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 2
81862: PUSH
81863: LD_INT 1
81865: NEG
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 3
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 1
81883: PUSH
81884: LD_INT 3
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 1
81893: NEG
81894: PUSH
81895: LD_INT 2
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 3
81904: NEG
81905: PUSH
81906: LD_INT 2
81908: NEG
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: LIST
81924: LIST
81925: LIST
81926: LIST
81927: LIST
81928: LIST
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81939: LD_ADDR_VAR 0 32
81943: PUSH
81944: LD_INT 0
81946: PUSH
81947: LD_INT 0
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: PUSH
81954: LD_INT 0
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 1
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 1
81977: PUSH
81978: LD_INT 1
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 0
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 1
81997: NEG
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 1
82008: NEG
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 1
82020: NEG
82021: PUSH
82022: LD_INT 2
82024: NEG
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 0
82032: PUSH
82033: LD_INT 2
82035: NEG
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 1
82043: PUSH
82044: LD_INT 1
82046: NEG
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 2
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 2
82064: PUSH
82065: LD_INT 2
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 1
82074: PUSH
82075: LD_INT 2
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 0
82084: PUSH
82085: LD_INT 2
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: NEG
82095: PUSH
82096: LD_INT 1
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 2
82105: NEG
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 2
82116: NEG
82117: PUSH
82118: LD_INT 1
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: LD_INT 3
82132: NEG
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 1
82140: PUSH
82141: LD_INT 2
82143: NEG
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 3
82151: PUSH
82152: LD_INT 2
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: LD_INT 3
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: LD_INT 1
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 3
82182: NEG
82183: PUSH
82184: LD_INT 1
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82217: LD_ADDR_VAR 0 33
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: LD_INT 0
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 0
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 1
82245: PUSH
82246: LD_INT 0
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 1
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 0
82265: PUSH
82266: LD_INT 1
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 1
82275: NEG
82276: PUSH
82277: LD_INT 0
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 1
82286: NEG
82287: PUSH
82288: LD_INT 1
82290: NEG
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 1
82298: NEG
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 1
82310: PUSH
82311: LD_INT 1
82313: NEG
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 2
82321: PUSH
82322: LD_INT 0
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 2
82331: PUSH
82332: LD_INT 1
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 1
82341: PUSH
82342: LD_INT 2
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 0
82351: PUSH
82352: LD_INT 2
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: LD_INT 1
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 2
82372: NEG
82373: PUSH
82374: LD_INT 0
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 2
82383: NEG
82384: PUSH
82385: LD_INT 1
82387: NEG
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 2
82395: NEG
82396: PUSH
82397: LD_INT 2
82399: NEG
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 2
82407: NEG
82408: PUSH
82409: LD_INT 3
82411: NEG
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 2
82419: PUSH
82420: LD_INT 1
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 3
82430: PUSH
82431: LD_INT 1
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 1
82440: PUSH
82441: LD_INT 3
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 1
82450: NEG
82451: PUSH
82452: LD_INT 2
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 3
82461: NEG
82462: PUSH
82463: LD_INT 2
82465: NEG
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82496: LD_ADDR_VAR 0 34
82500: PUSH
82501: LD_INT 0
82503: PUSH
82504: LD_INT 0
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 0
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 1
82524: PUSH
82525: LD_INT 0
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 1
82534: PUSH
82535: LD_INT 1
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 0
82544: PUSH
82545: LD_INT 1
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 1
82554: NEG
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 1
82565: NEG
82566: PUSH
82567: LD_INT 1
82569: NEG
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 1
82577: NEG
82578: PUSH
82579: LD_INT 2
82581: NEG
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: LD_INT 0
82589: PUSH
82590: LD_INT 2
82592: NEG
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 1
82600: PUSH
82601: LD_INT 1
82603: NEG
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 2
82611: PUSH
82612: LD_INT 1
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 2
82621: PUSH
82622: LD_INT 2
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: LD_INT 1
82631: PUSH
82632: LD_INT 2
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: NEG
82642: PUSH
82643: LD_INT 1
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 2
82652: NEG
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: LD_INT 1
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 2
82675: NEG
82676: PUSH
82677: LD_INT 2
82679: NEG
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 1
82687: NEG
82688: PUSH
82689: LD_INT 3
82691: NEG
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: LD_INT 2
82702: NEG
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 3
82710: PUSH
82711: LD_INT 2
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 2
82720: PUSH
82721: LD_INT 3
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 2
82730: NEG
82731: PUSH
82732: LD_INT 1
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 3
82741: NEG
82742: PUSH
82743: LD_INT 1
82745: NEG
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82776: LD_ADDR_VAR 0 35
82780: PUSH
82781: LD_INT 0
82783: PUSH
82784: LD_INT 0
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 0
82793: PUSH
82794: LD_INT 1
82796: NEG
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 1
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 1
82814: PUSH
82815: LD_INT 1
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: LD_INT 1
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: NEG
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 1
82845: NEG
82846: PUSH
82847: LD_INT 1
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 2
82857: PUSH
82858: LD_INT 1
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: LD_INT 2
82867: NEG
82868: PUSH
82869: LD_INT 1
82871: NEG
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
82888: LD_ADDR_VAR 0 36
82892: PUSH
82893: LD_INT 0
82895: PUSH
82896: LD_INT 0
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 0
82905: PUSH
82906: LD_INT 1
82908: NEG
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 1
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 1
82926: PUSH
82927: LD_INT 1
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: LD_INT 1
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 2
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: PUSH
82982: LD_INT 2
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83000: LD_ADDR_VAR 0 37
83004: PUSH
83005: LD_INT 0
83007: PUSH
83008: LD_INT 0
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: LD_INT 1
83020: NEG
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 1
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 1
83038: PUSH
83039: LD_INT 1
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 0
83048: PUSH
83049: LD_INT 1
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: NEG
83059: PUSH
83060: LD_INT 0
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 1
83069: NEG
83070: PUSH
83071: LD_INT 1
83073: NEG
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: LD_INT 1
83084: NEG
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 1
83092: NEG
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83112: LD_ADDR_VAR 0 38
83116: PUSH
83117: LD_INT 0
83119: PUSH
83120: LD_INT 0
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 0
83129: PUSH
83130: LD_INT 1
83132: NEG
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: LD_INT 0
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 1
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: NEG
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 1
83181: NEG
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 2
83193: PUSH
83194: LD_INT 1
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 2
83203: NEG
83204: PUSH
83205: LD_INT 1
83207: NEG
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83224: LD_ADDR_VAR 0 39
83228: PUSH
83229: LD_INT 0
83231: PUSH
83232: LD_INT 0
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 0
83241: PUSH
83242: LD_INT 1
83244: NEG
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 1
83252: PUSH
83253: LD_INT 0
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 1
83262: PUSH
83263: LD_INT 1
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: LD_INT 1
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 0
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 1
83293: NEG
83294: PUSH
83295: LD_INT 1
83297: NEG
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 1
83305: NEG
83306: PUSH
83307: LD_INT 2
83309: NEG
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 1
83317: PUSH
83318: LD_INT 2
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83336: LD_ADDR_VAR 0 40
83340: PUSH
83341: LD_INT 0
83343: PUSH
83344: LD_INT 0
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 0
83353: PUSH
83354: LD_INT 1
83356: NEG
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 1
83364: PUSH
83365: LD_INT 0
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 1
83374: PUSH
83375: LD_INT 1
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 0
83384: PUSH
83385: LD_INT 1
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 1
83394: NEG
83395: PUSH
83396: LD_INT 0
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 1
83405: NEG
83406: PUSH
83407: LD_INT 1
83409: NEG
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 1
83417: PUSH
83418: LD_INT 1
83420: NEG
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 1
83428: NEG
83429: PUSH
83430: LD_INT 1
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83448: LD_ADDR_VAR 0 41
83452: PUSH
83453: LD_INT 0
83455: PUSH
83456: LD_INT 0
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 0
83465: PUSH
83466: LD_INT 1
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: LD_INT 0
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 1
83486: PUSH
83487: LD_INT 1
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: LD_INT 1
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 1
83506: NEG
83507: PUSH
83508: LD_INT 0
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: LD_INT 1
83521: NEG
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 1
83529: NEG
83530: PUSH
83531: LD_INT 2
83533: NEG
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 1
83541: PUSH
83542: LD_INT 1
83544: NEG
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 2
83552: PUSH
83553: LD_INT 0
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 2
83562: PUSH
83563: LD_INT 1
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 2
83572: PUSH
83573: LD_INT 2
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 1
83582: PUSH
83583: LD_INT 2
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 1
83592: NEG
83593: PUSH
83594: LD_INT 1
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 2
83603: NEG
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: NEG
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 2
83626: NEG
83627: PUSH
83628: LD_INT 2
83630: NEG
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 2
83638: NEG
83639: PUSH
83640: LD_INT 3
83642: NEG
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 2
83650: PUSH
83651: LD_INT 1
83653: NEG
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 3
83661: PUSH
83662: LD_INT 0
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 3
83671: PUSH
83672: LD_INT 1
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 3
83681: PUSH
83682: LD_INT 2
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 3
83691: PUSH
83692: LD_INT 3
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 2
83701: PUSH
83702: LD_INT 3
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 2
83711: NEG
83712: PUSH
83713: LD_INT 1
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 3
83722: NEG
83723: PUSH
83724: LD_INT 0
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PUSH
83731: LD_INT 3
83733: NEG
83734: PUSH
83735: LD_INT 1
83737: NEG
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 3
83745: NEG
83746: PUSH
83747: LD_INT 2
83749: NEG
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 3
83757: NEG
83758: PUSH
83759: LD_INT 3
83761: NEG
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83798: LD_ADDR_VAR 0 42
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: LD_INT 0
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 0
83815: PUSH
83816: LD_INT 1
83818: NEG
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 1
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 1
83836: PUSH
83837: LD_INT 1
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 0
83846: PUSH
83847: LD_INT 1
83849: PUSH
83850: EMPTY
83851: LIST
83852: LIST
83853: PUSH
83854: LD_INT 1
83856: NEG
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 1
83867: NEG
83868: PUSH
83869: LD_INT 1
83871: NEG
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PUSH
83877: LD_INT 1
83879: NEG
83880: PUSH
83881: LD_INT 2
83883: NEG
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 0
83891: PUSH
83892: LD_INT 2
83894: NEG
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 1
83902: PUSH
83903: LD_INT 1
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 2
83913: PUSH
83914: LD_INT 1
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 2
83923: PUSH
83924: LD_INT 2
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 1
83933: PUSH
83934: LD_INT 2
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 0
83943: PUSH
83944: LD_INT 2
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 1
83953: NEG
83954: PUSH
83955: LD_INT 1
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: PUSH
83962: LD_INT 2
83964: NEG
83965: PUSH
83966: LD_INT 1
83968: NEG
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 2
83976: NEG
83977: PUSH
83978: LD_INT 2
83980: NEG
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: LD_INT 3
83992: NEG
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: LD_INT 3
84004: NEG
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 0
84012: PUSH
84013: LD_INT 3
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 1
84023: PUSH
84024: LD_INT 2
84026: NEG
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PUSH
84032: LD_INT 3
84034: PUSH
84035: LD_INT 2
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 3
84044: PUSH
84045: LD_INT 3
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 2
84054: PUSH
84055: LD_INT 3
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: LD_INT 1
84064: PUSH
84065: LD_INT 3
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 0
84074: PUSH
84075: LD_INT 3
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 1
84084: NEG
84085: PUSH
84086: LD_INT 2
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 3
84095: NEG
84096: PUSH
84097: LD_INT 2
84099: NEG
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PUSH
84105: LD_INT 3
84107: NEG
84108: PUSH
84109: LD_INT 3
84111: NEG
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84148: LD_ADDR_VAR 0 43
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: LD_INT 0
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 0
84165: PUSH
84166: LD_INT 1
84168: NEG
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 1
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 0
84196: PUSH
84197: LD_INT 1
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 1
84206: NEG
84207: PUSH
84208: LD_INT 0
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 1
84217: NEG
84218: PUSH
84219: LD_INT 1
84221: NEG
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 1
84229: NEG
84230: PUSH
84231: LD_INT 2
84233: NEG
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 2
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 1
84255: NEG
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 2
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 2
84273: PUSH
84274: LD_INT 1
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 1
84283: PUSH
84284: LD_INT 2
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: LD_INT 2
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 1
84303: NEG
84304: PUSH
84305: LD_INT 1
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 2
84314: NEG
84315: PUSH
84316: LD_INT 0
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: PUSH
84323: LD_INT 2
84325: NEG
84326: PUSH
84327: LD_INT 1
84329: NEG
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 1
84337: NEG
84338: PUSH
84339: LD_INT 3
84341: NEG
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: LD_INT 3
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: LD_INT 2
84363: NEG
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 2
84371: PUSH
84372: LD_INT 1
84374: NEG
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 3
84382: PUSH
84383: LD_INT 0
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 3
84392: PUSH
84393: LD_INT 1
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: LD_INT 3
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 0
84412: PUSH
84413: LD_INT 3
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 1
84422: NEG
84423: PUSH
84424: LD_INT 2
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 2
84433: NEG
84434: PUSH
84435: LD_INT 1
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 3
84444: NEG
84445: PUSH
84446: LD_INT 0
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 3
84455: NEG
84456: PUSH
84457: LD_INT 1
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84496: LD_ADDR_VAR 0 44
84500: PUSH
84501: LD_INT 0
84503: PUSH
84504: LD_INT 0
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 0
84513: PUSH
84514: LD_INT 1
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 1
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 1
84534: PUSH
84535: LD_INT 1
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 0
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: LD_INT 1
84554: NEG
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: PUSH
84563: LD_INT 1
84565: NEG
84566: PUSH
84567: LD_INT 1
84569: NEG
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 1
84577: NEG
84578: PUSH
84579: LD_INT 2
84581: NEG
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 1
84589: PUSH
84590: LD_INT 1
84592: NEG
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 2
84600: PUSH
84601: LD_INT 0
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: LD_INT 2
84610: PUSH
84611: LD_INT 1
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 2
84620: PUSH
84621: LD_INT 2
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 1
84630: PUSH
84631: LD_INT 2
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 1
84640: NEG
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 2
84651: NEG
84652: PUSH
84653: LD_INT 0
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 2
84662: NEG
84663: PUSH
84664: LD_INT 1
84666: NEG
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 2
84674: NEG
84675: PUSH
84676: LD_INT 2
84678: NEG
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 2
84686: NEG
84687: PUSH
84688: LD_INT 3
84690: NEG
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 2
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 3
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 3
84719: PUSH
84720: LD_INT 1
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: PUSH
84727: LD_INT 3
84729: PUSH
84730: LD_INT 2
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 3
84739: PUSH
84740: LD_INT 3
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: PUSH
84747: LD_INT 2
84749: PUSH
84750: LD_INT 3
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 2
84759: NEG
84760: PUSH
84761: LD_INT 1
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 3
84770: NEG
84771: PUSH
84772: LD_INT 0
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 3
84781: NEG
84782: PUSH
84783: LD_INT 1
84785: NEG
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 3
84793: NEG
84794: PUSH
84795: LD_INT 2
84797: NEG
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 3
84805: NEG
84806: PUSH
84807: LD_INT 3
84809: NEG
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: EMPTY
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84846: LD_ADDR_VAR 0 45
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 0
84863: PUSH
84864: LD_INT 1
84866: NEG
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 1
84874: PUSH
84875: LD_INT 0
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 1
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 0
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 1
84904: NEG
84905: PUSH
84906: LD_INT 0
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: PUSH
84913: LD_INT 1
84915: NEG
84916: PUSH
84917: LD_INT 1
84919: NEG
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: NEG
84928: PUSH
84929: LD_INT 2
84931: NEG
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 0
84939: PUSH
84940: LD_INT 2
84942: NEG
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 1
84950: PUSH
84951: LD_INT 1
84953: NEG
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: LD_INT 2
84961: PUSH
84962: LD_INT 1
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 2
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 1
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PUSH
84989: LD_INT 0
84991: PUSH
84992: LD_INT 2
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 1
85001: NEG
85002: PUSH
85003: LD_INT 1
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 2
85012: NEG
85013: PUSH
85014: LD_INT 1
85016: NEG
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: LD_INT 2
85028: NEG
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: PUSH
85034: LD_INT 2
85036: NEG
85037: PUSH
85038: LD_INT 3
85040: NEG
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 1
85048: NEG
85049: PUSH
85050: LD_INT 3
85052: NEG
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 0
85060: PUSH
85061: LD_INT 3
85063: NEG
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 1
85071: PUSH
85072: LD_INT 2
85074: NEG
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 3
85082: PUSH
85083: LD_INT 2
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 3
85092: PUSH
85093: LD_INT 3
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 2
85102: PUSH
85103: LD_INT 3
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: PUSH
85110: LD_INT 1
85112: PUSH
85113: LD_INT 3
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 0
85122: PUSH
85123: LD_INT 3
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 1
85132: NEG
85133: PUSH
85134: LD_INT 2
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 3
85143: NEG
85144: PUSH
85145: LD_INT 2
85147: NEG
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: PUSH
85153: LD_INT 3
85155: NEG
85156: PUSH
85157: LD_INT 3
85159: NEG
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85196: LD_ADDR_VAR 0 46
85200: PUSH
85201: LD_INT 0
85203: PUSH
85204: LD_INT 0
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 0
85213: PUSH
85214: LD_INT 1
85216: NEG
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: PUSH
85222: LD_INT 1
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 1
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 0
85244: PUSH
85245: LD_INT 1
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: LD_INT 0
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 1
85265: NEG
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 1
85277: NEG
85278: PUSH
85279: LD_INT 2
85281: NEG
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 0
85289: PUSH
85290: LD_INT 2
85292: NEG
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 1
85300: PUSH
85301: LD_INT 1
85303: NEG
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 2
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 2
85321: PUSH
85322: LD_INT 1
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 1
85331: PUSH
85332: LD_INT 2
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 0
85341: PUSH
85342: LD_INT 2
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 1
85351: NEG
85352: PUSH
85353: LD_INT 1
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 2
85362: NEG
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 2
85373: NEG
85374: PUSH
85375: LD_INT 1
85377: NEG
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: PUSH
85383: LD_INT 1
85385: NEG
85386: PUSH
85387: LD_INT 3
85389: NEG
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PUSH
85395: LD_INT 0
85397: PUSH
85398: LD_INT 3
85400: NEG
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 1
85408: PUSH
85409: LD_INT 2
85411: NEG
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 2
85419: PUSH
85420: LD_INT 1
85422: NEG
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 3
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 3
85440: PUSH
85441: LD_INT 1
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: LD_INT 1
85450: PUSH
85451: LD_INT 3
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 0
85460: PUSH
85461: LD_INT 3
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: LD_INT 1
85470: NEG
85471: PUSH
85472: LD_INT 2
85474: PUSH
85475: EMPTY
85476: LIST
85477: LIST
85478: PUSH
85479: LD_INT 2
85481: NEG
85482: PUSH
85483: LD_INT 1
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: PUSH
85490: LD_INT 3
85492: NEG
85493: PUSH
85494: LD_INT 0
85496: PUSH
85497: EMPTY
85498: LIST
85499: LIST
85500: PUSH
85501: LD_INT 3
85503: NEG
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85544: LD_ADDR_VAR 0 47
85548: PUSH
85549: LD_INT 0
85551: PUSH
85552: LD_INT 0
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 0
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 1
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 1
85582: PUSH
85583: LD_INT 1
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 0
85592: PUSH
85593: LD_INT 1
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 1
85602: NEG
85603: PUSH
85604: LD_INT 0
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: LD_INT 1
85617: NEG
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 1
85625: NEG
85626: PUSH
85627: LD_INT 2
85629: NEG
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 0
85637: PUSH
85638: LD_INT 2
85640: NEG
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 1
85648: PUSH
85649: LD_INT 1
85651: NEG
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 2
85659: NEG
85660: PUSH
85661: LD_INT 1
85663: NEG
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 2
85671: NEG
85672: PUSH
85673: LD_INT 2
85675: NEG
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85695: LD_ADDR_VAR 0 48
85699: PUSH
85700: LD_INT 0
85702: PUSH
85703: LD_INT 0
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: LD_INT 1
85715: NEG
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 1
85723: PUSH
85724: LD_INT 0
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 1
85733: PUSH
85734: LD_INT 1
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: LD_INT 0
85743: PUSH
85744: LD_INT 1
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 1
85753: NEG
85754: PUSH
85755: LD_INT 0
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 1
85764: NEG
85765: PUSH
85766: LD_INT 1
85768: NEG
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: NEG
85777: PUSH
85778: LD_INT 2
85780: NEG
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 0
85788: PUSH
85789: LD_INT 2
85791: NEG
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 1
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: PUSH
85808: LD_INT 2
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 2
85820: PUSH
85821: LD_INT 1
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85842: LD_ADDR_VAR 0 49
85846: PUSH
85847: LD_INT 0
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 0
85859: PUSH
85860: LD_INT 1
85862: NEG
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: LD_INT 0
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 1
85880: PUSH
85881: LD_INT 1
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 0
85890: PUSH
85891: LD_INT 1
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 1
85900: NEG
85901: PUSH
85902: LD_INT 0
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: LD_INT 1
85915: NEG
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: LD_INT 1
85923: PUSH
85924: LD_INT 1
85926: NEG
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 2
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 2
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 2
85954: PUSH
85955: LD_INT 2
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: PUSH
85965: LD_INT 2
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
85986: LD_ADDR_VAR 0 50
85990: PUSH
85991: LD_INT 0
85993: PUSH
85994: LD_INT 0
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: LD_INT 1
86006: NEG
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 1
86014: PUSH
86015: LD_INT 0
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: LD_INT 1
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: LD_INT 1
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 1
86044: NEG
86045: PUSH
86046: LD_INT 0
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 1
86055: NEG
86056: PUSH
86057: LD_INT 1
86059: NEG
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 2
86067: PUSH
86068: LD_INT 1
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 2
86077: PUSH
86078: LD_INT 2
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: LIST
86128: LIST
86129: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
86130: LD_ADDR_VAR 0 51
86134: PUSH
86135: LD_INT 0
86137: PUSH
86138: LD_INT 0
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: PUSH
86145: LD_INT 0
86147: PUSH
86148: LD_INT 1
86150: NEG
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 1
86158: PUSH
86159: LD_INT 0
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: LD_INT 1
86168: PUSH
86169: LD_INT 1
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 0
86178: PUSH
86179: LD_INT 1
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 1
86188: NEG
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 1
86199: NEG
86200: PUSH
86201: LD_INT 1
86203: NEG
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 1
86211: PUSH
86212: LD_INT 2
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 0
86221: PUSH
86222: LD_INT 2
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 1
86231: NEG
86232: PUSH
86233: LD_INT 1
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 2
86242: NEG
86243: PUSH
86244: LD_INT 0
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: LD_INT 2
86253: NEG
86254: PUSH
86255: LD_INT 1
86257: NEG
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86277: LD_ADDR_VAR 0 52
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 0
86294: PUSH
86295: LD_INT 1
86297: NEG
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 1
86305: PUSH
86306: LD_INT 0
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 1
86315: PUSH
86316: LD_INT 1
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 0
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 1
86335: NEG
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 1
86346: NEG
86347: PUSH
86348: LD_INT 1
86350: NEG
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: PUSH
86356: LD_INT 1
86358: NEG
86359: PUSH
86360: LD_INT 2
86362: NEG
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 2
86381: NEG
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 2
86392: NEG
86393: PUSH
86394: LD_INT 1
86396: NEG
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 2
86404: NEG
86405: PUSH
86406: LD_INT 2
86408: NEG
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86428: LD_ADDR_VAR 0 53
86432: PUSH
86433: LD_INT 0
86435: PUSH
86436: LD_INT 0
86438: PUSH
86439: EMPTY
86440: LIST
86441: LIST
86442: PUSH
86443: LD_INT 0
86445: PUSH
86446: LD_INT 1
86448: NEG
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 1
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 1
86466: PUSH
86467: LD_INT 1
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 0
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 1
86486: NEG
86487: PUSH
86488: LD_INT 0
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 1
86497: NEG
86498: PUSH
86499: LD_INT 1
86501: NEG
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 1
86509: NEG
86510: PUSH
86511: LD_INT 2
86513: NEG
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 0
86521: PUSH
86522: LD_INT 2
86524: NEG
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 2
86543: PUSH
86544: LD_INT 0
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 2
86553: PUSH
86554: LD_INT 1
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 2
86563: PUSH
86564: LD_INT 2
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: LD_INT 2
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 0
86583: PUSH
86584: LD_INT 2
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 1
86593: NEG
86594: PUSH
86595: LD_INT 1
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 2
86604: NEG
86605: PUSH
86606: LD_INT 0
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 2
86615: NEG
86616: PUSH
86617: LD_INT 1
86619: NEG
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 2
86627: NEG
86628: PUSH
86629: LD_INT 2
86631: NEG
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86658: LD_ADDR_VAR 0 54
86662: PUSH
86663: LD_INT 0
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 0
86675: PUSH
86676: LD_INT 1
86678: NEG
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: LD_INT 1
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: LD_INT 1
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 0
86706: PUSH
86707: LD_INT 1
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: LD_INT 1
86716: NEG
86717: PUSH
86718: LD_INT 0
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PUSH
86725: LD_INT 1
86727: NEG
86728: PUSH
86729: LD_INT 1
86731: NEG
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: LD_INT 1
86739: NEG
86740: PUSH
86741: LD_INT 2
86743: NEG
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 0
86751: PUSH
86752: LD_INT 2
86754: NEG
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: LD_INT 1
86765: NEG
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 2
86773: PUSH
86774: LD_INT 0
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 2
86783: PUSH
86784: LD_INT 1
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 2
86793: PUSH
86794: LD_INT 2
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 1
86803: PUSH
86804: LD_INT 2
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 0
86813: PUSH
86814: LD_INT 2
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 1
86823: NEG
86824: PUSH
86825: LD_INT 1
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 2
86834: NEG
86835: PUSH
86836: LD_INT 0
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 2
86845: NEG
86846: PUSH
86847: LD_INT 1
86849: NEG
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 2
86857: NEG
86858: PUSH
86859: LD_INT 2
86861: NEG
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86888: LD_ADDR_VAR 0 55
86892: PUSH
86893: LD_INT 0
86895: PUSH
86896: LD_INT 0
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 0
86905: PUSH
86906: LD_INT 1
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 1
86916: PUSH
86917: LD_INT 0
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: PUSH
86924: LD_INT 1
86926: PUSH
86927: LD_INT 1
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 0
86936: PUSH
86937: LD_INT 1
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 1
86946: NEG
86947: PUSH
86948: LD_INT 0
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 1
86957: NEG
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: LD_INT 1
86969: NEG
86970: PUSH
86971: LD_INT 2
86973: NEG
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 0
86981: PUSH
86982: LD_INT 2
86984: NEG
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 1
86992: PUSH
86993: LD_INT 1
86995: NEG
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 2
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 2
87013: PUSH
87014: LD_INT 1
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 2
87023: PUSH
87024: LD_INT 2
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 1
87033: PUSH
87034: LD_INT 2
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: LD_INT 2
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 1
87053: NEG
87054: PUSH
87055: LD_INT 1
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 2
87064: NEG
87065: PUSH
87066: LD_INT 0
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PUSH
87073: LD_INT 2
87075: NEG
87076: PUSH
87077: LD_INT 1
87079: NEG
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: PUSH
87085: LD_INT 2
87087: NEG
87088: PUSH
87089: LD_INT 2
87091: NEG
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87118: LD_ADDR_VAR 0 56
87122: PUSH
87123: LD_INT 0
87125: PUSH
87126: LD_INT 0
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 0
87135: PUSH
87136: LD_INT 1
87138: NEG
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: LD_INT 0
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 1
87156: PUSH
87157: LD_INT 1
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: LD_INT 0
87166: PUSH
87167: LD_INT 1
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 1
87176: NEG
87177: PUSH
87178: LD_INT 0
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: NEG
87188: PUSH
87189: LD_INT 1
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 1
87199: NEG
87200: PUSH
87201: LD_INT 2
87203: NEG
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 0
87211: PUSH
87212: LD_INT 2
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: PUSH
87223: LD_INT 1
87225: NEG
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 2
87233: PUSH
87234: LD_INT 0
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 2
87243: PUSH
87244: LD_INT 1
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: LD_INT 2
87253: PUSH
87254: LD_INT 2
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 1
87263: PUSH
87264: LD_INT 2
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: LD_INT 2
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 1
87283: NEG
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 2
87294: NEG
87295: PUSH
87296: LD_INT 0
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PUSH
87303: LD_INT 2
87305: NEG
87306: PUSH
87307: LD_INT 1
87309: NEG
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 2
87317: NEG
87318: PUSH
87319: LD_INT 2
87321: NEG
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87348: LD_ADDR_VAR 0 57
87352: PUSH
87353: LD_INT 0
87355: PUSH
87356: LD_INT 0
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 0
87365: PUSH
87366: LD_INT 1
87368: NEG
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 1
87376: PUSH
87377: LD_INT 0
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: LD_INT 1
87386: PUSH
87387: LD_INT 1
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 0
87396: PUSH
87397: LD_INT 1
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: PUSH
87404: LD_INT 1
87406: NEG
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: NEG
87418: PUSH
87419: LD_INT 1
87421: NEG
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 1
87429: NEG
87430: PUSH
87431: LD_INT 2
87433: NEG
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 0
87441: PUSH
87442: LD_INT 2
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 1
87452: PUSH
87453: LD_INT 1
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 2
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 2
87473: PUSH
87474: LD_INT 1
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 2
87483: PUSH
87484: LD_INT 2
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: PUSH
87491: LD_INT 1
87493: PUSH
87494: LD_INT 2
87496: PUSH
87497: EMPTY
87498: LIST
87499: LIST
87500: PUSH
87501: LD_INT 0
87503: PUSH
87504: LD_INT 2
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: PUSH
87511: LD_INT 1
87513: NEG
87514: PUSH
87515: LD_INT 1
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 2
87524: NEG
87525: PUSH
87526: LD_INT 0
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 2
87535: NEG
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 2
87547: NEG
87548: PUSH
87549: LD_INT 2
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87578: LD_ADDR_VAR 0 58
87582: PUSH
87583: LD_INT 0
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 0
87595: PUSH
87596: LD_INT 1
87598: NEG
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 1
87606: PUSH
87607: LD_INT 0
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PUSH
87614: LD_INT 1
87616: PUSH
87617: LD_INT 1
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: LD_INT 0
87626: PUSH
87627: LD_INT 1
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 1
87636: NEG
87637: PUSH
87638: LD_INT 0
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 1
87647: NEG
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 1
87659: NEG
87660: PUSH
87661: LD_INT 2
87663: NEG
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 0
87671: PUSH
87672: LD_INT 2
87674: NEG
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: PUSH
87683: LD_INT 1
87685: NEG
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 2
87693: PUSH
87694: LD_INT 0
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 2
87703: PUSH
87704: LD_INT 1
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 2
87713: PUSH
87714: LD_INT 2
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 1
87723: PUSH
87724: LD_INT 2
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 0
87733: PUSH
87734: LD_INT 2
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 1
87743: NEG
87744: PUSH
87745: LD_INT 1
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PUSH
87752: LD_INT 2
87754: NEG
87755: PUSH
87756: LD_INT 0
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 2
87765: NEG
87766: PUSH
87767: LD_INT 1
87769: NEG
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 2
87777: NEG
87778: PUSH
87779: LD_INT 2
87781: NEG
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87808: LD_ADDR_VAR 0 59
87812: PUSH
87813: LD_INT 0
87815: PUSH
87816: LD_INT 0
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 0
87825: PUSH
87826: LD_INT 1
87828: NEG
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: PUSH
87837: LD_INT 0
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: LD_INT 1
87846: PUSH
87847: LD_INT 1
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 0
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 1
87866: NEG
87867: PUSH
87868: LD_INT 0
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 1
87877: NEG
87878: PUSH
87879: LD_INT 1
87881: NEG
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87896: LD_ADDR_VAR 0 60
87900: PUSH
87901: LD_INT 0
87903: PUSH
87904: LD_INT 0
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: LD_INT 1
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 1
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 1
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 0
87944: PUSH
87945: LD_INT 1
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 1
87954: NEG
87955: PUSH
87956: LD_INT 0
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 1
87965: NEG
87966: PUSH
87967: LD_INT 1
87969: NEG
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87984: LD_ADDR_VAR 0 61
87988: PUSH
87989: LD_INT 0
87991: PUSH
87992: LD_INT 0
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: LD_INT 1
88004: NEG
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 1
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 1
88022: PUSH
88023: LD_INT 1
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 0
88032: PUSH
88033: LD_INT 1
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 1
88042: NEG
88043: PUSH
88044: LD_INT 0
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: LD_INT 1
88053: NEG
88054: PUSH
88055: LD_INT 1
88057: NEG
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88072: LD_ADDR_VAR 0 62
88076: PUSH
88077: LD_INT 0
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 0
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 1
88100: PUSH
88101: LD_INT 0
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 1
88110: PUSH
88111: LD_INT 1
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: PUSH
88118: LD_INT 0
88120: PUSH
88121: LD_INT 1
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 1
88130: NEG
88131: PUSH
88132: LD_INT 0
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 1
88141: NEG
88142: PUSH
88143: LD_INT 1
88145: NEG
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88160: LD_ADDR_VAR 0 63
88164: PUSH
88165: LD_INT 0
88167: PUSH
88168: LD_INT 0
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 0
88177: PUSH
88178: LD_INT 1
88180: NEG
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 0
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 1
88229: NEG
88230: PUSH
88231: LD_INT 1
88233: NEG
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: LIST
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88248: LD_ADDR_VAR 0 64
88252: PUSH
88253: LD_INT 0
88255: PUSH
88256: LD_INT 0
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 0
88265: PUSH
88266: LD_INT 1
88268: NEG
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: LD_INT 1
88276: PUSH
88277: LD_INT 0
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: PUSH
88284: LD_INT 1
88286: PUSH
88287: LD_INT 1
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PUSH
88294: LD_INT 0
88296: PUSH
88297: LD_INT 1
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: LD_INT 1
88306: NEG
88307: PUSH
88308: LD_INT 0
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: LD_INT 1
88321: NEG
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: ST_TO_ADDR
// end ; 1 :
88336: GO 94233
88338: LD_INT 1
88340: DOUBLE
88341: EQUAL
88342: IFTRUE 88346
88344: GO 90969
88346: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88347: LD_ADDR_VAR 0 11
88351: PUSH
88352: LD_INT 1
88354: NEG
88355: PUSH
88356: LD_INT 3
88358: NEG
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 0
88366: PUSH
88367: LD_INT 3
88369: NEG
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: PUSH
88378: LD_INT 2
88380: NEG
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: LIST
88390: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88391: LD_ADDR_VAR 0 12
88395: PUSH
88396: LD_INT 2
88398: PUSH
88399: LD_INT 1
88401: NEG
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PUSH
88407: LD_INT 3
88409: PUSH
88410: LD_INT 0
88412: PUSH
88413: EMPTY
88414: LIST
88415: LIST
88416: PUSH
88417: LD_INT 3
88419: PUSH
88420: LD_INT 1
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: LIST
88431: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88432: LD_ADDR_VAR 0 13
88436: PUSH
88437: LD_INT 3
88439: PUSH
88440: LD_INT 2
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: LD_INT 3
88449: PUSH
88450: LD_INT 3
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 2
88459: PUSH
88460: LD_INT 3
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: LIST
88471: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88472: LD_ADDR_VAR 0 14
88476: PUSH
88477: LD_INT 1
88479: PUSH
88480: LD_INT 3
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 0
88489: PUSH
88490: LD_INT 3
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 1
88499: NEG
88500: PUSH
88501: LD_INT 2
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: LIST
88512: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88513: LD_ADDR_VAR 0 15
88517: PUSH
88518: LD_INT 2
88520: NEG
88521: PUSH
88522: LD_INT 1
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: LD_INT 3
88531: NEG
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 3
88542: NEG
88543: PUSH
88544: LD_INT 1
88546: NEG
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: LIST
88556: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88557: LD_ADDR_VAR 0 16
88561: PUSH
88562: LD_INT 2
88564: NEG
88565: PUSH
88566: LD_INT 3
88568: NEG
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 3
88576: NEG
88577: PUSH
88578: LD_INT 2
88580: NEG
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 3
88588: NEG
88589: PUSH
88590: LD_INT 3
88592: NEG
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: LIST
88602: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88603: LD_ADDR_VAR 0 17
88607: PUSH
88608: LD_INT 1
88610: NEG
88611: PUSH
88612: LD_INT 3
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: LD_INT 3
88625: NEG
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: LD_INT 2
88636: NEG
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: LIST
88646: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88647: LD_ADDR_VAR 0 18
88651: PUSH
88652: LD_INT 2
88654: PUSH
88655: LD_INT 1
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 3
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 3
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: EMPTY
88680: LIST
88681: LIST
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: LIST
88687: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88688: LD_ADDR_VAR 0 19
88692: PUSH
88693: LD_INT 3
88695: PUSH
88696: LD_INT 2
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 3
88705: PUSH
88706: LD_INT 3
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 2
88715: PUSH
88716: LD_INT 3
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: LIST
88727: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88728: LD_ADDR_VAR 0 20
88732: PUSH
88733: LD_INT 1
88735: PUSH
88736: LD_INT 3
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 0
88745: PUSH
88746: LD_INT 3
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 1
88755: NEG
88756: PUSH
88757: LD_INT 2
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: LIST
88768: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88769: LD_ADDR_VAR 0 21
88773: PUSH
88774: LD_INT 2
88776: NEG
88777: PUSH
88778: LD_INT 1
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 3
88787: NEG
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 3
88798: NEG
88799: PUSH
88800: LD_INT 1
88802: NEG
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: LIST
88812: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88813: LD_ADDR_VAR 0 22
88817: PUSH
88818: LD_INT 2
88820: NEG
88821: PUSH
88822: LD_INT 3
88824: NEG
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 3
88832: NEG
88833: PUSH
88834: LD_INT 2
88836: NEG
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: PUSH
88842: LD_INT 3
88844: NEG
88845: PUSH
88846: LD_INT 3
88848: NEG
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: LIST
88858: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
88859: LD_ADDR_VAR 0 23
88863: PUSH
88864: LD_INT 0
88866: PUSH
88867: LD_INT 3
88869: NEG
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 1
88877: NEG
88878: PUSH
88879: LD_INT 4
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 1
88889: PUSH
88890: LD_INT 3
88892: NEG
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: LIST
88902: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
88903: LD_ADDR_VAR 0 24
88907: PUSH
88908: LD_INT 3
88910: PUSH
88911: LD_INT 0
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 3
88920: PUSH
88921: LD_INT 1
88923: NEG
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 4
88931: PUSH
88932: LD_INT 1
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: LIST
88943: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
88944: LD_ADDR_VAR 0 25
88948: PUSH
88949: LD_INT 3
88951: PUSH
88952: LD_INT 3
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: LD_INT 4
88961: PUSH
88962: LD_INT 3
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 3
88971: PUSH
88972: LD_INT 4
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: LIST
88983: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
88984: LD_ADDR_VAR 0 26
88988: PUSH
88989: LD_INT 0
88991: PUSH
88992: LD_INT 3
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: PUSH
89002: LD_INT 4
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 1
89011: NEG
89012: PUSH
89013: LD_INT 3
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: LIST
89024: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89025: LD_ADDR_VAR 0 27
89029: PUSH
89030: LD_INT 3
89032: NEG
89033: PUSH
89034: LD_INT 0
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 3
89043: NEG
89044: PUSH
89045: LD_INT 1
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 4
89054: NEG
89055: PUSH
89056: LD_INT 1
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: LIST
89068: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89069: LD_ADDR_VAR 0 28
89073: PUSH
89074: LD_INT 3
89076: NEG
89077: PUSH
89078: LD_INT 3
89080: NEG
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: PUSH
89086: LD_INT 3
89088: NEG
89089: PUSH
89090: LD_INT 4
89092: NEG
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 4
89100: NEG
89101: PUSH
89102: LD_INT 3
89104: NEG
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: EMPTY
89111: LIST
89112: LIST
89113: LIST
89114: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
89115: LD_ADDR_VAR 0 29
89119: PUSH
89120: LD_INT 1
89122: NEG
89123: PUSH
89124: LD_INT 3
89126: NEG
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 0
89134: PUSH
89135: LD_INT 3
89137: NEG
89138: PUSH
89139: EMPTY
89140: LIST
89141: LIST
89142: PUSH
89143: LD_INT 1
89145: PUSH
89146: LD_INT 2
89148: NEG
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 1
89156: NEG
89157: PUSH
89158: LD_INT 4
89160: NEG
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: LD_INT 4
89171: NEG
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 1
89179: PUSH
89180: LD_INT 3
89182: NEG
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 1
89190: NEG
89191: PUSH
89192: LD_INT 5
89194: NEG
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 0
89202: PUSH
89203: LD_INT 5
89205: NEG
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: PUSH
89214: LD_INT 4
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: LD_INT 6
89228: NEG
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 6
89239: NEG
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 1
89247: PUSH
89248: LD_INT 5
89250: NEG
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
89270: LD_ADDR_VAR 0 30
89274: PUSH
89275: LD_INT 2
89277: PUSH
89278: LD_INT 1
89280: NEG
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: PUSH
89286: LD_INT 3
89288: PUSH
89289: LD_INT 0
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 3
89298: PUSH
89299: LD_INT 1
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: LD_INT 3
89308: PUSH
89309: LD_INT 1
89311: NEG
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 4
89319: PUSH
89320: LD_INT 0
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: PUSH
89327: LD_INT 4
89329: PUSH
89330: LD_INT 1
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 4
89339: PUSH
89340: LD_INT 1
89342: NEG
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 5
89350: PUSH
89351: LD_INT 0
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 5
89360: PUSH
89361: LD_INT 1
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: PUSH
89368: LD_INT 5
89370: PUSH
89371: LD_INT 1
89373: NEG
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 6
89381: PUSH
89382: LD_INT 0
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 6
89391: PUSH
89392: LD_INT 1
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
89413: LD_ADDR_VAR 0 31
89417: PUSH
89418: LD_INT 3
89420: PUSH
89421: LD_INT 2
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 3
89430: PUSH
89431: LD_INT 3
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 2
89440: PUSH
89441: LD_INT 3
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 4
89450: PUSH
89451: LD_INT 3
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 4
89460: PUSH
89461: LD_INT 4
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 3
89470: PUSH
89471: LD_INT 4
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 5
89480: PUSH
89481: LD_INT 4
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 5
89490: PUSH
89491: LD_INT 5
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 4
89500: PUSH
89501: LD_INT 5
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: PUSH
89508: LD_INT 6
89510: PUSH
89511: LD_INT 5
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 6
89520: PUSH
89521: LD_INT 6
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: LD_INT 5
89530: PUSH
89531: LD_INT 6
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
89552: LD_ADDR_VAR 0 32
89556: PUSH
89557: LD_INT 1
89559: PUSH
89560: LD_INT 3
89562: PUSH
89563: EMPTY
89564: LIST
89565: LIST
89566: PUSH
89567: LD_INT 0
89569: PUSH
89570: LD_INT 3
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 1
89579: NEG
89580: PUSH
89581: LD_INT 2
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 1
89590: PUSH
89591: LD_INT 4
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: LD_INT 4
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: LD_INT 1
89610: NEG
89611: PUSH
89612: LD_INT 3
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 1
89621: PUSH
89622: LD_INT 5
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: PUSH
89629: LD_INT 0
89631: PUSH
89632: LD_INT 5
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: LD_INT 1
89641: NEG
89642: PUSH
89643: LD_INT 4
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: PUSH
89650: LD_INT 1
89652: PUSH
89653: LD_INT 6
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 0
89662: PUSH
89663: LD_INT 6
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 1
89672: NEG
89673: PUSH
89674: LD_INT 5
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
89695: LD_ADDR_VAR 0 33
89699: PUSH
89700: LD_INT 2
89702: NEG
89703: PUSH
89704: LD_INT 1
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 3
89713: NEG
89714: PUSH
89715: LD_INT 0
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 3
89724: NEG
89725: PUSH
89726: LD_INT 1
89728: NEG
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 3
89736: NEG
89737: PUSH
89738: LD_INT 1
89740: PUSH
89741: EMPTY
89742: LIST
89743: LIST
89744: PUSH
89745: LD_INT 4
89747: NEG
89748: PUSH
89749: LD_INT 0
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 4
89758: NEG
89759: PUSH
89760: LD_INT 1
89762: NEG
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PUSH
89768: LD_INT 4
89770: NEG
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 5
89781: NEG
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 5
89792: NEG
89793: PUSH
89794: LD_INT 1
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 5
89804: NEG
89805: PUSH
89806: LD_INT 1
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 6
89815: NEG
89816: PUSH
89817: LD_INT 0
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 6
89826: NEG
89827: PUSH
89828: LD_INT 1
89830: NEG
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
89850: LD_ADDR_VAR 0 34
89854: PUSH
89855: LD_INT 2
89857: NEG
89858: PUSH
89859: LD_INT 3
89861: NEG
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 3
89869: NEG
89870: PUSH
89871: LD_INT 2
89873: NEG
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 3
89881: NEG
89882: PUSH
89883: LD_INT 3
89885: NEG
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 3
89893: NEG
89894: PUSH
89895: LD_INT 4
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 4
89905: NEG
89906: PUSH
89907: LD_INT 3
89909: NEG
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: LD_INT 4
89917: NEG
89918: PUSH
89919: LD_INT 4
89921: NEG
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: LD_INT 4
89929: NEG
89930: PUSH
89931: LD_INT 5
89933: NEG
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 5
89941: NEG
89942: PUSH
89943: LD_INT 4
89945: NEG
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 5
89953: NEG
89954: PUSH
89955: LD_INT 5
89957: NEG
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 5
89965: NEG
89966: PUSH
89967: LD_INT 6
89969: NEG
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: LD_INT 6
89977: NEG
89978: PUSH
89979: LD_INT 5
89981: NEG
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PUSH
89987: LD_INT 6
89989: NEG
89990: PUSH
89991: LD_INT 6
89993: NEG
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90013: LD_ADDR_VAR 0 41
90017: PUSH
90018: LD_INT 0
90020: PUSH
90021: LD_INT 2
90023: NEG
90024: PUSH
90025: EMPTY
90026: LIST
90027: LIST
90028: PUSH
90029: LD_INT 1
90031: NEG
90032: PUSH
90033: LD_INT 3
90035: NEG
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 1
90043: PUSH
90044: LD_INT 2
90046: NEG
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: LIST
90056: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90057: LD_ADDR_VAR 0 42
90061: PUSH
90062: LD_INT 2
90064: PUSH
90065: LD_INT 0
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 2
90074: PUSH
90075: LD_INT 1
90077: NEG
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 3
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: LIST
90097: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90098: LD_ADDR_VAR 0 43
90102: PUSH
90103: LD_INT 2
90105: PUSH
90106: LD_INT 2
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 3
90115: PUSH
90116: LD_INT 2
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: LD_INT 2
90125: PUSH
90126: LD_INT 3
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: LIST
90137: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
90138: LD_ADDR_VAR 0 44
90142: PUSH
90143: LD_INT 0
90145: PUSH
90146: LD_INT 2
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 1
90155: PUSH
90156: LD_INT 3
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: LD_INT 2
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: LIST
90178: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90179: LD_ADDR_VAR 0 45
90183: PUSH
90184: LD_INT 2
90186: NEG
90187: PUSH
90188: LD_INT 0
90190: PUSH
90191: EMPTY
90192: LIST
90193: LIST
90194: PUSH
90195: LD_INT 2
90197: NEG
90198: PUSH
90199: LD_INT 1
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: PUSH
90206: LD_INT 3
90208: NEG
90209: PUSH
90210: LD_INT 1
90212: NEG
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: LIST
90222: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90223: LD_ADDR_VAR 0 46
90227: PUSH
90228: LD_INT 2
90230: NEG
90231: PUSH
90232: LD_INT 2
90234: NEG
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 2
90242: NEG
90243: PUSH
90244: LD_INT 3
90246: NEG
90247: PUSH
90248: EMPTY
90249: LIST
90250: LIST
90251: PUSH
90252: LD_INT 3
90254: NEG
90255: PUSH
90256: LD_INT 2
90258: NEG
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: LIST
90268: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
90269: LD_ADDR_VAR 0 47
90273: PUSH
90274: LD_INT 2
90276: NEG
90277: PUSH
90278: LD_INT 3
90280: NEG
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: PUSH
90286: LD_INT 1
90288: NEG
90289: PUSH
90290: LD_INT 3
90292: NEG
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
90302: LD_ADDR_VAR 0 48
90306: PUSH
90307: LD_INT 1
90309: PUSH
90310: LD_INT 2
90312: NEG
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 2
90320: PUSH
90321: LD_INT 1
90323: NEG
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
90333: LD_ADDR_VAR 0 49
90337: PUSH
90338: LD_INT 3
90340: PUSH
90341: LD_INT 1
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 3
90350: PUSH
90351: LD_INT 2
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
90362: LD_ADDR_VAR 0 50
90366: PUSH
90367: LD_INT 2
90369: PUSH
90370: LD_INT 3
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 1
90379: PUSH
90380: LD_INT 3
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
90391: LD_ADDR_VAR 0 51
90395: PUSH
90396: LD_INT 1
90398: NEG
90399: PUSH
90400: LD_INT 2
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 2
90409: NEG
90410: PUSH
90411: LD_INT 1
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
90422: LD_ADDR_VAR 0 52
90426: PUSH
90427: LD_INT 3
90429: NEG
90430: PUSH
90431: LD_INT 1
90433: NEG
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PUSH
90439: LD_INT 3
90441: NEG
90442: PUSH
90443: LD_INT 2
90445: NEG
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90455: LD_ADDR_VAR 0 53
90459: PUSH
90460: LD_INT 1
90462: NEG
90463: PUSH
90464: LD_INT 3
90466: NEG
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: LD_INT 3
90477: NEG
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: LD_INT 2
90488: NEG
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: LIST
90498: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90499: LD_ADDR_VAR 0 54
90503: PUSH
90504: LD_INT 2
90506: PUSH
90507: LD_INT 1
90509: NEG
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 3
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 3
90527: PUSH
90528: LD_INT 1
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: LIST
90539: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90540: LD_ADDR_VAR 0 55
90544: PUSH
90545: LD_INT 3
90547: PUSH
90548: LD_INT 2
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 3
90557: PUSH
90558: LD_INT 3
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: LD_INT 2
90567: PUSH
90568: LD_INT 3
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: LIST
90579: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90580: LD_ADDR_VAR 0 56
90584: PUSH
90585: LD_INT 1
90587: PUSH
90588: LD_INT 3
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 0
90597: PUSH
90598: LD_INT 3
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 1
90607: NEG
90608: PUSH
90609: LD_INT 2
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: LIST
90620: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90621: LD_ADDR_VAR 0 57
90625: PUSH
90626: LD_INT 2
90628: NEG
90629: PUSH
90630: LD_INT 1
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: LD_INT 3
90639: NEG
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 3
90650: NEG
90651: PUSH
90652: LD_INT 1
90654: NEG
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: LIST
90664: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90665: LD_ADDR_VAR 0 58
90669: PUSH
90670: LD_INT 2
90672: NEG
90673: PUSH
90674: LD_INT 3
90676: NEG
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 3
90684: NEG
90685: PUSH
90686: LD_INT 2
90688: NEG
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 3
90696: NEG
90697: PUSH
90698: LD_INT 3
90700: NEG
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: LIST
90710: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
90711: LD_ADDR_VAR 0 59
90715: PUSH
90716: LD_INT 1
90718: NEG
90719: PUSH
90720: LD_INT 2
90722: NEG
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 0
90730: PUSH
90731: LD_INT 2
90733: NEG
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 1
90741: PUSH
90742: LD_INT 1
90744: NEG
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: LIST
90754: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90755: LD_ADDR_VAR 0 60
90759: PUSH
90760: LD_INT 1
90762: PUSH
90763: LD_INT 1
90765: NEG
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 2
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 2
90783: PUSH
90784: LD_INT 1
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: LIST
90795: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90796: LD_ADDR_VAR 0 61
90800: PUSH
90801: LD_INT 2
90803: PUSH
90804: LD_INT 1
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 2
90813: PUSH
90814: LD_INT 2
90816: PUSH
90817: EMPTY
90818: LIST
90819: LIST
90820: PUSH
90821: LD_INT 1
90823: PUSH
90824: LD_INT 2
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: LIST
90835: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90836: LD_ADDR_VAR 0 62
90840: PUSH
90841: LD_INT 1
90843: PUSH
90844: LD_INT 2
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 0
90853: PUSH
90854: LD_INT 2
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 1
90863: NEG
90864: PUSH
90865: LD_INT 1
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: LIST
90876: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90877: LD_ADDR_VAR 0 63
90881: PUSH
90882: LD_INT 1
90884: NEG
90885: PUSH
90886: LD_INT 1
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 2
90895: NEG
90896: PUSH
90897: LD_INT 0
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: LD_INT 2
90906: NEG
90907: PUSH
90908: LD_INT 1
90910: NEG
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: LIST
90920: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90921: LD_ADDR_VAR 0 64
90925: PUSH
90926: LD_INT 1
90928: NEG
90929: PUSH
90930: LD_INT 2
90932: NEG
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 2
90940: NEG
90941: PUSH
90942: LD_INT 1
90944: NEG
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 2
90952: NEG
90953: PUSH
90954: LD_INT 2
90956: NEG
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: LIST
90966: ST_TO_ADDR
// end ; 2 :
90967: GO 94233
90969: LD_INT 2
90971: DOUBLE
90972: EQUAL
90973: IFTRUE 90977
90975: GO 94232
90977: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
90978: LD_ADDR_VAR 0 29
90982: PUSH
90983: LD_INT 4
90985: PUSH
90986: LD_INT 0
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: PUSH
90993: LD_INT 4
90995: PUSH
90996: LD_INT 1
90998: NEG
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 5
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: PUSH
91014: LD_INT 5
91016: PUSH
91017: LD_INT 1
91019: PUSH
91020: EMPTY
91021: LIST
91022: LIST
91023: PUSH
91024: LD_INT 4
91026: PUSH
91027: LD_INT 1
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PUSH
91034: LD_INT 3
91036: PUSH
91037: LD_INT 0
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: PUSH
91044: LD_INT 3
91046: PUSH
91047: LD_INT 1
91049: NEG
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 3
91057: PUSH
91058: LD_INT 2
91060: NEG
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 5
91068: PUSH
91069: LD_INT 2
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 3
91078: PUSH
91079: LD_INT 3
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 3
91088: PUSH
91089: LD_INT 2
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 4
91098: PUSH
91099: LD_INT 3
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 4
91108: PUSH
91109: LD_INT 4
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 3
91118: PUSH
91119: LD_INT 4
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: LD_INT 3
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: PUSH
91136: LD_INT 2
91138: PUSH
91139: LD_INT 2
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: PUSH
91146: LD_INT 4
91148: PUSH
91149: LD_INT 2
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: LD_INT 2
91158: PUSH
91159: LD_INT 4
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 0
91168: PUSH
91169: LD_INT 4
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: LD_INT 3
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 1
91188: PUSH
91189: LD_INT 4
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 1
91198: PUSH
91199: LD_INT 5
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 0
91208: PUSH
91209: LD_INT 5
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 1
91218: NEG
91219: PUSH
91220: LD_INT 4
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 1
91229: NEG
91230: PUSH
91231: LD_INT 3
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 2
91240: PUSH
91241: LD_INT 5
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 2
91250: NEG
91251: PUSH
91252: LD_INT 3
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: PUSH
91259: LD_INT 3
91261: NEG
91262: PUSH
91263: LD_INT 0
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: PUSH
91270: LD_INT 3
91272: NEG
91273: PUSH
91274: LD_INT 1
91276: NEG
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 2
91284: NEG
91285: PUSH
91286: LD_INT 0
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: PUSH
91293: LD_INT 2
91295: NEG
91296: PUSH
91297: LD_INT 1
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 3
91306: NEG
91307: PUSH
91308: LD_INT 1
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 4
91317: NEG
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 4
91328: NEG
91329: PUSH
91330: LD_INT 1
91332: NEG
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PUSH
91338: LD_INT 4
91340: NEG
91341: PUSH
91342: LD_INT 2
91344: NEG
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: PUSH
91350: LD_INT 2
91352: NEG
91353: PUSH
91354: LD_INT 2
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 4
91363: NEG
91364: PUSH
91365: LD_INT 4
91367: NEG
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: LD_INT 4
91375: NEG
91376: PUSH
91377: LD_INT 5
91379: NEG
91380: PUSH
91381: EMPTY
91382: LIST
91383: LIST
91384: PUSH
91385: LD_INT 3
91387: NEG
91388: PUSH
91389: LD_INT 4
91391: NEG
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 3
91399: NEG
91400: PUSH
91401: LD_INT 3
91403: NEG
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 4
91411: NEG
91412: PUSH
91413: LD_INT 3
91415: NEG
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 5
91423: NEG
91424: PUSH
91425: LD_INT 4
91427: NEG
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 5
91435: NEG
91436: PUSH
91437: LD_INT 5
91439: NEG
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 3
91447: NEG
91448: PUSH
91449: LD_INT 5
91451: NEG
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 5
91459: NEG
91460: PUSH
91461: LD_INT 3
91463: NEG
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
91516: LD_ADDR_VAR 0 30
91520: PUSH
91521: LD_INT 4
91523: PUSH
91524: LD_INT 4
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 4
91533: PUSH
91534: LD_INT 3
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 5
91543: PUSH
91544: LD_INT 4
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 5
91553: PUSH
91554: LD_INT 5
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 4
91563: PUSH
91564: LD_INT 5
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 3
91573: PUSH
91574: LD_INT 4
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 3
91583: PUSH
91584: LD_INT 3
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 5
91593: PUSH
91594: LD_INT 3
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 3
91603: PUSH
91604: LD_INT 5
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: PUSH
91611: LD_INT 0
91613: PUSH
91614: LD_INT 3
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: LD_INT 0
91623: PUSH
91624: LD_INT 2
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PUSH
91631: LD_INT 1
91633: PUSH
91634: LD_INT 3
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 1
91643: PUSH
91644: LD_INT 4
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 0
91653: PUSH
91654: LD_INT 4
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 1
91663: NEG
91664: PUSH
91665: LD_INT 3
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 1
91674: NEG
91675: PUSH
91676: LD_INT 2
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 2
91685: PUSH
91686: LD_INT 4
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 2
91695: NEG
91696: PUSH
91697: LD_INT 2
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PUSH
91704: LD_INT 4
91706: NEG
91707: PUSH
91708: LD_INT 0
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: PUSH
91715: LD_INT 4
91717: NEG
91718: PUSH
91719: LD_INT 1
91721: NEG
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 3
91729: NEG
91730: PUSH
91731: LD_INT 0
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 3
91740: NEG
91741: PUSH
91742: LD_INT 1
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: LD_INT 4
91751: NEG
91752: PUSH
91753: LD_INT 1
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: LD_INT 5
91762: NEG
91763: PUSH
91764: LD_INT 0
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 5
91773: NEG
91774: PUSH
91775: LD_INT 1
91777: NEG
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 5
91785: NEG
91786: PUSH
91787: LD_INT 2
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 3
91797: NEG
91798: PUSH
91799: LD_INT 2
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 3
91808: NEG
91809: PUSH
91810: LD_INT 3
91812: NEG
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 3
91820: NEG
91821: PUSH
91822: LD_INT 4
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 2
91832: NEG
91833: PUSH
91834: LD_INT 3
91836: NEG
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 2
91844: NEG
91845: PUSH
91846: LD_INT 2
91848: NEG
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: PUSH
91854: LD_INT 3
91856: NEG
91857: PUSH
91858: LD_INT 2
91860: NEG
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 4
91868: NEG
91869: PUSH
91870: LD_INT 3
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 4
91880: NEG
91881: PUSH
91882: LD_INT 4
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 2
91892: NEG
91893: PUSH
91894: LD_INT 4
91896: NEG
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: LD_INT 4
91904: NEG
91905: PUSH
91906: LD_INT 2
91908: NEG
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: LD_INT 4
91919: NEG
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 0
91927: PUSH
91928: LD_INT 5
91930: NEG
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 1
91938: PUSH
91939: LD_INT 4
91941: NEG
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: PUSH
91947: LD_INT 1
91949: PUSH
91950: LD_INT 3
91952: NEG
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: PUSH
91958: LD_INT 0
91960: PUSH
91961: LD_INT 3
91963: NEG
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 1
91971: NEG
91972: PUSH
91973: LD_INT 4
91975: NEG
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 1
91983: NEG
91984: PUSH
91985: LD_INT 5
91987: NEG
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 2
91995: PUSH
91996: LD_INT 3
91998: NEG
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 2
92006: NEG
92007: PUSH
92008: LD_INT 5
92010: NEG
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92063: LD_ADDR_VAR 0 31
92067: PUSH
92068: LD_INT 0
92070: PUSH
92071: LD_INT 4
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: LD_INT 0
92080: PUSH
92081: LD_INT 3
92083: PUSH
92084: EMPTY
92085: LIST
92086: LIST
92087: PUSH
92088: LD_INT 1
92090: PUSH
92091: LD_INT 4
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 1
92100: PUSH
92101: LD_INT 5
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 0
92110: PUSH
92111: LD_INT 5
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: LD_INT 1
92120: NEG
92121: PUSH
92122: LD_INT 4
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 1
92131: NEG
92132: PUSH
92133: LD_INT 3
92135: PUSH
92136: EMPTY
92137: LIST
92138: LIST
92139: PUSH
92140: LD_INT 2
92142: PUSH
92143: LD_INT 5
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 2
92152: NEG
92153: PUSH
92154: LD_INT 3
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: LD_INT 3
92163: NEG
92164: PUSH
92165: LD_INT 0
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 3
92174: NEG
92175: PUSH
92176: LD_INT 1
92178: NEG
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: PUSH
92184: LD_INT 2
92186: NEG
92187: PUSH
92188: LD_INT 0
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 2
92197: NEG
92198: PUSH
92199: LD_INT 1
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 3
92208: NEG
92209: PUSH
92210: LD_INT 1
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: LD_INT 4
92219: NEG
92220: PUSH
92221: LD_INT 0
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 4
92230: NEG
92231: PUSH
92232: LD_INT 1
92234: NEG
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 4
92242: NEG
92243: PUSH
92244: LD_INT 2
92246: NEG
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: LD_INT 2
92254: NEG
92255: PUSH
92256: LD_INT 2
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 4
92265: NEG
92266: PUSH
92267: LD_INT 4
92269: NEG
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PUSH
92275: LD_INT 4
92277: NEG
92278: PUSH
92279: LD_INT 5
92281: NEG
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 3
92289: NEG
92290: PUSH
92291: LD_INT 4
92293: NEG
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 3
92301: NEG
92302: PUSH
92303: LD_INT 3
92305: NEG
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 4
92313: NEG
92314: PUSH
92315: LD_INT 3
92317: NEG
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: LD_INT 5
92325: NEG
92326: PUSH
92327: LD_INT 4
92329: NEG
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: LD_INT 5
92337: NEG
92338: PUSH
92339: LD_INT 5
92341: NEG
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 3
92349: NEG
92350: PUSH
92351: LD_INT 5
92353: NEG
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PUSH
92359: LD_INT 5
92361: NEG
92362: PUSH
92363: LD_INT 3
92365: NEG
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: LD_INT 0
92373: PUSH
92374: LD_INT 3
92376: NEG
92377: PUSH
92378: EMPTY
92379: LIST
92380: LIST
92381: PUSH
92382: LD_INT 0
92384: PUSH
92385: LD_INT 4
92387: NEG
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 1
92395: PUSH
92396: LD_INT 3
92398: NEG
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 1
92406: PUSH
92407: LD_INT 2
92409: NEG
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 0
92417: PUSH
92418: LD_INT 2
92420: NEG
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 1
92428: NEG
92429: PUSH
92430: LD_INT 3
92432: NEG
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: PUSH
92438: LD_INT 1
92440: NEG
92441: PUSH
92442: LD_INT 4
92444: NEG
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 2
92452: PUSH
92453: LD_INT 2
92455: NEG
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 2
92463: NEG
92464: PUSH
92465: LD_INT 4
92467: NEG
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 4
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 4
92485: PUSH
92486: LD_INT 1
92488: NEG
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 5
92496: PUSH
92497: LD_INT 0
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 5
92506: PUSH
92507: LD_INT 1
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 4
92516: PUSH
92517: LD_INT 1
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 3
92526: PUSH
92527: LD_INT 0
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: LD_INT 3
92536: PUSH
92537: LD_INT 1
92539: NEG
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 3
92547: PUSH
92548: LD_INT 2
92550: NEG
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 5
92558: PUSH
92559: LD_INT 2
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
92613: LD_ADDR_VAR 0 32
92617: PUSH
92618: LD_INT 4
92620: NEG
92621: PUSH
92622: LD_INT 0
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 4
92631: NEG
92632: PUSH
92633: LD_INT 1
92635: NEG
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 3
92643: NEG
92644: PUSH
92645: LD_INT 0
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 3
92654: NEG
92655: PUSH
92656: LD_INT 1
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 4
92665: NEG
92666: PUSH
92667: LD_INT 1
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 5
92676: NEG
92677: PUSH
92678: LD_INT 0
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 5
92687: NEG
92688: PUSH
92689: LD_INT 1
92691: NEG
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 5
92699: NEG
92700: PUSH
92701: LD_INT 2
92703: NEG
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 3
92711: NEG
92712: PUSH
92713: LD_INT 2
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 3
92722: NEG
92723: PUSH
92724: LD_INT 3
92726: NEG
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 3
92734: NEG
92735: PUSH
92736: LD_INT 4
92738: NEG
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 2
92746: NEG
92747: PUSH
92748: LD_INT 3
92750: NEG
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 2
92758: NEG
92759: PUSH
92760: LD_INT 2
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 3
92770: NEG
92771: PUSH
92772: LD_INT 2
92774: NEG
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 4
92782: NEG
92783: PUSH
92784: LD_INT 3
92786: NEG
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 4
92794: NEG
92795: PUSH
92796: LD_INT 4
92798: NEG
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: LD_INT 2
92806: NEG
92807: PUSH
92808: LD_INT 4
92810: NEG
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 4
92818: NEG
92819: PUSH
92820: LD_INT 2
92822: NEG
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 0
92830: PUSH
92831: LD_INT 4
92833: NEG
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 0
92841: PUSH
92842: LD_INT 5
92844: NEG
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 1
92852: PUSH
92853: LD_INT 4
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 1
92863: PUSH
92864: LD_INT 3
92866: NEG
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 0
92874: PUSH
92875: LD_INT 3
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 1
92885: NEG
92886: PUSH
92887: LD_INT 4
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 1
92897: NEG
92898: PUSH
92899: LD_INT 5
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 2
92909: PUSH
92910: LD_INT 3
92912: NEG
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 2
92920: NEG
92921: PUSH
92922: LD_INT 5
92924: NEG
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 3
92932: PUSH
92933: LD_INT 0
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 3
92942: PUSH
92943: LD_INT 1
92945: NEG
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 4
92953: PUSH
92954: LD_INT 0
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: LD_INT 4
92963: PUSH
92964: LD_INT 1
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 3
92973: PUSH
92974: LD_INT 1
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: LD_INT 2
92983: PUSH
92984: LD_INT 0
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 2
92993: PUSH
92994: LD_INT 1
92996: NEG
92997: PUSH
92998: EMPTY
92999: LIST
93000: LIST
93001: PUSH
93002: LD_INT 2
93004: PUSH
93005: LD_INT 2
93007: NEG
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: PUSH
93013: LD_INT 4
93015: PUSH
93016: LD_INT 2
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: LD_INT 4
93025: PUSH
93026: LD_INT 4
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 4
93035: PUSH
93036: LD_INT 3
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 5
93045: PUSH
93046: LD_INT 4
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 5
93055: PUSH
93056: LD_INT 5
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 4
93065: PUSH
93066: LD_INT 5
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 3
93075: PUSH
93076: LD_INT 4
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 3
93085: PUSH
93086: LD_INT 3
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 5
93095: PUSH
93096: LD_INT 3
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 3
93105: PUSH
93106: LD_INT 5
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: EMPTY
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
93160: LD_ADDR_VAR 0 33
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: LD_INT 4
93171: NEG
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: LD_INT 4
93179: NEG
93180: PUSH
93181: LD_INT 5
93183: NEG
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 3
93191: NEG
93192: PUSH
93193: LD_INT 4
93195: NEG
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: LD_INT 3
93203: NEG
93204: PUSH
93205: LD_INT 3
93207: NEG
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 4
93215: NEG
93216: PUSH
93217: LD_INT 3
93219: NEG
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PUSH
93225: LD_INT 5
93227: NEG
93228: PUSH
93229: LD_INT 4
93231: NEG
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_INT 5
93239: NEG
93240: PUSH
93241: LD_INT 5
93243: NEG
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 3
93251: NEG
93252: PUSH
93253: LD_INT 5
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 5
93263: NEG
93264: PUSH
93265: LD_INT 3
93267: NEG
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 0
93275: PUSH
93276: LD_INT 3
93278: NEG
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 0
93286: PUSH
93287: LD_INT 4
93289: NEG
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 1
93297: PUSH
93298: LD_INT 3
93300: NEG
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 1
93308: PUSH
93309: LD_INT 2
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 0
93319: PUSH
93320: LD_INT 2
93322: NEG
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 1
93330: NEG
93331: PUSH
93332: LD_INT 3
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 1
93342: NEG
93343: PUSH
93344: LD_INT 4
93346: NEG
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 2
93354: PUSH
93355: LD_INT 2
93357: NEG
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 2
93365: NEG
93366: PUSH
93367: LD_INT 4
93369: NEG
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: LD_INT 4
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 4
93387: PUSH
93388: LD_INT 1
93390: NEG
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 5
93398: PUSH
93399: LD_INT 0
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: PUSH
93406: LD_INT 5
93408: PUSH
93409: LD_INT 1
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: LD_INT 4
93418: PUSH
93419: LD_INT 1
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: LD_INT 3
93428: PUSH
93429: LD_INT 0
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 3
93438: PUSH
93439: LD_INT 1
93441: NEG
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: LD_INT 3
93449: PUSH
93450: LD_INT 2
93452: NEG
93453: PUSH
93454: EMPTY
93455: LIST
93456: LIST
93457: PUSH
93458: LD_INT 5
93460: PUSH
93461: LD_INT 2
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: PUSH
93468: LD_INT 3
93470: PUSH
93471: LD_INT 3
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 3
93480: PUSH
93481: LD_INT 2
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 4
93490: PUSH
93491: LD_INT 3
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 4
93500: PUSH
93501: LD_INT 4
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 3
93510: PUSH
93511: LD_INT 4
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 2
93520: PUSH
93521: LD_INT 3
93523: PUSH
93524: EMPTY
93525: LIST
93526: LIST
93527: PUSH
93528: LD_INT 2
93530: PUSH
93531: LD_INT 2
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: PUSH
93538: LD_INT 4
93540: PUSH
93541: LD_INT 2
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 2
93550: PUSH
93551: LD_INT 4
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: LD_INT 0
93560: PUSH
93561: LD_INT 4
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 0
93570: PUSH
93571: LD_INT 3
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: LD_INT 1
93580: PUSH
93581: LD_INT 4
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 1
93590: PUSH
93591: LD_INT 5
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 0
93600: PUSH
93601: LD_INT 5
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: NEG
93611: PUSH
93612: LD_INT 4
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 1
93621: NEG
93622: PUSH
93623: LD_INT 3
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: PUSH
93630: LD_INT 2
93632: PUSH
93633: LD_INT 5
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: LD_INT 2
93642: NEG
93643: PUSH
93644: LD_INT 3
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
93698: LD_ADDR_VAR 0 34
93702: PUSH
93703: LD_INT 0
93705: PUSH
93706: LD_INT 4
93708: NEG
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 0
93716: PUSH
93717: LD_INT 5
93719: NEG
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: PUSH
93725: LD_INT 1
93727: PUSH
93728: LD_INT 4
93730: NEG
93731: PUSH
93732: EMPTY
93733: LIST
93734: LIST
93735: PUSH
93736: LD_INT 1
93738: PUSH
93739: LD_INT 3
93741: NEG
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 0
93749: PUSH
93750: LD_INT 3
93752: NEG
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 1
93760: NEG
93761: PUSH
93762: LD_INT 4
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 1
93772: NEG
93773: PUSH
93774: LD_INT 5
93776: NEG
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: LD_INT 2
93784: PUSH
93785: LD_INT 3
93787: NEG
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 2
93795: NEG
93796: PUSH
93797: LD_INT 5
93799: NEG
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: LD_INT 3
93807: PUSH
93808: LD_INT 0
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 3
93817: PUSH
93818: LD_INT 1
93820: NEG
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 4
93828: PUSH
93829: LD_INT 0
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 4
93838: PUSH
93839: LD_INT 1
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 3
93848: PUSH
93849: LD_INT 1
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 2
93858: PUSH
93859: LD_INT 0
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 2
93868: PUSH
93869: LD_INT 1
93871: NEG
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 2
93879: PUSH
93880: LD_INT 2
93882: NEG
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 4
93890: PUSH
93891: LD_INT 2
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: LD_INT 4
93900: PUSH
93901: LD_INT 4
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 4
93910: PUSH
93911: LD_INT 3
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 5
93920: PUSH
93921: LD_INT 4
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: LD_INT 5
93930: PUSH
93931: LD_INT 5
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 4
93940: PUSH
93941: LD_INT 5
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 3
93950: PUSH
93951: LD_INT 4
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 3
93960: PUSH
93961: LD_INT 3
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 5
93970: PUSH
93971: LD_INT 3
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 3
93980: PUSH
93981: LD_INT 5
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 0
93990: PUSH
93991: LD_INT 3
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: LD_INT 0
94000: PUSH
94001: LD_INT 2
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 1
94010: PUSH
94011: LD_INT 3
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 1
94020: PUSH
94021: LD_INT 4
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: LD_INT 0
94030: PUSH
94031: LD_INT 4
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: PUSH
94038: LD_INT 1
94040: NEG
94041: PUSH
94042: LD_INT 3
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 1
94051: NEG
94052: PUSH
94053: LD_INT 2
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_INT 2
94062: PUSH
94063: LD_INT 4
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 2
94072: NEG
94073: PUSH
94074: LD_INT 2
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 4
94083: NEG
94084: PUSH
94085: LD_INT 0
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 4
94094: NEG
94095: PUSH
94096: LD_INT 1
94098: NEG
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 0
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 3
94117: NEG
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 4
94128: NEG
94129: PUSH
94130: LD_INT 1
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PUSH
94137: LD_INT 5
94139: NEG
94140: PUSH
94141: LD_INT 0
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 5
94150: NEG
94151: PUSH
94152: LD_INT 1
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 5
94162: NEG
94163: PUSH
94164: LD_INT 2
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 3
94174: NEG
94175: PUSH
94176: LD_INT 2
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: ST_TO_ADDR
// end ; end ;
94230: GO 94233
94232: POP
// case btype of b_depot , b_warehouse :
94233: LD_VAR 0 1
94237: PUSH
94238: LD_INT 0
94240: DOUBLE
94241: EQUAL
94242: IFTRUE 94252
94244: LD_INT 1
94246: DOUBLE
94247: EQUAL
94248: IFTRUE 94252
94250: GO 94453
94252: POP
// case nation of nation_american :
94253: LD_VAR 0 5
94257: PUSH
94258: LD_INT 1
94260: DOUBLE
94261: EQUAL
94262: IFTRUE 94266
94264: GO 94322
94266: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
94267: LD_ADDR_VAR 0 9
94271: PUSH
94272: LD_VAR 0 11
94276: PUSH
94277: LD_VAR 0 12
94281: PUSH
94282: LD_VAR 0 13
94286: PUSH
94287: LD_VAR 0 14
94291: PUSH
94292: LD_VAR 0 15
94296: PUSH
94297: LD_VAR 0 16
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: PUSH
94310: LD_VAR 0 4
94314: PUSH
94315: LD_INT 1
94317: PLUS
94318: ARRAY
94319: ST_TO_ADDR
94320: GO 94451
94322: LD_INT 2
94324: DOUBLE
94325: EQUAL
94326: IFTRUE 94330
94328: GO 94386
94330: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
94331: LD_ADDR_VAR 0 9
94335: PUSH
94336: LD_VAR 0 17
94340: PUSH
94341: LD_VAR 0 18
94345: PUSH
94346: LD_VAR 0 19
94350: PUSH
94351: LD_VAR 0 20
94355: PUSH
94356: LD_VAR 0 21
94360: PUSH
94361: LD_VAR 0 22
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: PUSH
94374: LD_VAR 0 4
94378: PUSH
94379: LD_INT 1
94381: PLUS
94382: ARRAY
94383: ST_TO_ADDR
94384: GO 94451
94386: LD_INT 3
94388: DOUBLE
94389: EQUAL
94390: IFTRUE 94394
94392: GO 94450
94394: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
94395: LD_ADDR_VAR 0 9
94399: PUSH
94400: LD_VAR 0 23
94404: PUSH
94405: LD_VAR 0 24
94409: PUSH
94410: LD_VAR 0 25
94414: PUSH
94415: LD_VAR 0 26
94419: PUSH
94420: LD_VAR 0 27
94424: PUSH
94425: LD_VAR 0 28
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: PUSH
94438: LD_VAR 0 4
94442: PUSH
94443: LD_INT 1
94445: PLUS
94446: ARRAY
94447: ST_TO_ADDR
94448: GO 94451
94450: POP
94451: GO 95000
94453: LD_INT 2
94455: DOUBLE
94456: EQUAL
94457: IFTRUE 94467
94459: LD_INT 3
94461: DOUBLE
94462: EQUAL
94463: IFTRUE 94467
94465: GO 94523
94467: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
94468: LD_ADDR_VAR 0 9
94472: PUSH
94473: LD_VAR 0 29
94477: PUSH
94478: LD_VAR 0 30
94482: PUSH
94483: LD_VAR 0 31
94487: PUSH
94488: LD_VAR 0 32
94492: PUSH
94493: LD_VAR 0 33
94497: PUSH
94498: LD_VAR 0 34
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: PUSH
94511: LD_VAR 0 4
94515: PUSH
94516: LD_INT 1
94518: PLUS
94519: ARRAY
94520: ST_TO_ADDR
94521: GO 95000
94523: LD_INT 16
94525: DOUBLE
94526: EQUAL
94527: IFTRUE 94579
94529: LD_INT 17
94531: DOUBLE
94532: EQUAL
94533: IFTRUE 94579
94535: LD_INT 18
94537: DOUBLE
94538: EQUAL
94539: IFTRUE 94579
94541: LD_INT 19
94543: DOUBLE
94544: EQUAL
94545: IFTRUE 94579
94547: LD_INT 20
94549: DOUBLE
94550: EQUAL
94551: IFTRUE 94579
94553: LD_INT 21
94555: DOUBLE
94556: EQUAL
94557: IFTRUE 94579
94559: LD_INT 23
94561: DOUBLE
94562: EQUAL
94563: IFTRUE 94579
94565: LD_INT 24
94567: DOUBLE
94568: EQUAL
94569: IFTRUE 94579
94571: LD_INT 25
94573: DOUBLE
94574: EQUAL
94575: IFTRUE 94579
94577: GO 94635
94579: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
94580: LD_ADDR_VAR 0 9
94584: PUSH
94585: LD_VAR 0 35
94589: PUSH
94590: LD_VAR 0 36
94594: PUSH
94595: LD_VAR 0 37
94599: PUSH
94600: LD_VAR 0 38
94604: PUSH
94605: LD_VAR 0 39
94609: PUSH
94610: LD_VAR 0 40
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: PUSH
94623: LD_VAR 0 4
94627: PUSH
94628: LD_INT 1
94630: PLUS
94631: ARRAY
94632: ST_TO_ADDR
94633: GO 95000
94635: LD_INT 6
94637: DOUBLE
94638: EQUAL
94639: IFTRUE 94691
94641: LD_INT 7
94643: DOUBLE
94644: EQUAL
94645: IFTRUE 94691
94647: LD_INT 8
94649: DOUBLE
94650: EQUAL
94651: IFTRUE 94691
94653: LD_INT 13
94655: DOUBLE
94656: EQUAL
94657: IFTRUE 94691
94659: LD_INT 12
94661: DOUBLE
94662: EQUAL
94663: IFTRUE 94691
94665: LD_INT 15
94667: DOUBLE
94668: EQUAL
94669: IFTRUE 94691
94671: LD_INT 11
94673: DOUBLE
94674: EQUAL
94675: IFTRUE 94691
94677: LD_INT 14
94679: DOUBLE
94680: EQUAL
94681: IFTRUE 94691
94683: LD_INT 10
94685: DOUBLE
94686: EQUAL
94687: IFTRUE 94691
94689: GO 94747
94691: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
94692: LD_ADDR_VAR 0 9
94696: PUSH
94697: LD_VAR 0 41
94701: PUSH
94702: LD_VAR 0 42
94706: PUSH
94707: LD_VAR 0 43
94711: PUSH
94712: LD_VAR 0 44
94716: PUSH
94717: LD_VAR 0 45
94721: PUSH
94722: LD_VAR 0 46
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: PUSH
94735: LD_VAR 0 4
94739: PUSH
94740: LD_INT 1
94742: PLUS
94743: ARRAY
94744: ST_TO_ADDR
94745: GO 95000
94747: LD_INT 36
94749: DOUBLE
94750: EQUAL
94751: IFTRUE 94755
94753: GO 94811
94755: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
94756: LD_ADDR_VAR 0 9
94760: PUSH
94761: LD_VAR 0 47
94765: PUSH
94766: LD_VAR 0 48
94770: PUSH
94771: LD_VAR 0 49
94775: PUSH
94776: LD_VAR 0 50
94780: PUSH
94781: LD_VAR 0 51
94785: PUSH
94786: LD_VAR 0 52
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: PUSH
94799: LD_VAR 0 4
94803: PUSH
94804: LD_INT 1
94806: PLUS
94807: ARRAY
94808: ST_TO_ADDR
94809: GO 95000
94811: LD_INT 4
94813: DOUBLE
94814: EQUAL
94815: IFTRUE 94837
94817: LD_INT 5
94819: DOUBLE
94820: EQUAL
94821: IFTRUE 94837
94823: LD_INT 34
94825: DOUBLE
94826: EQUAL
94827: IFTRUE 94837
94829: LD_INT 37
94831: DOUBLE
94832: EQUAL
94833: IFTRUE 94837
94835: GO 94893
94837: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
94838: LD_ADDR_VAR 0 9
94842: PUSH
94843: LD_VAR 0 53
94847: PUSH
94848: LD_VAR 0 54
94852: PUSH
94853: LD_VAR 0 55
94857: PUSH
94858: LD_VAR 0 56
94862: PUSH
94863: LD_VAR 0 57
94867: PUSH
94868: LD_VAR 0 58
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: PUSH
94881: LD_VAR 0 4
94885: PUSH
94886: LD_INT 1
94888: PLUS
94889: ARRAY
94890: ST_TO_ADDR
94891: GO 95000
94893: LD_INT 31
94895: DOUBLE
94896: EQUAL
94897: IFTRUE 94943
94899: LD_INT 32
94901: DOUBLE
94902: EQUAL
94903: IFTRUE 94943
94905: LD_INT 33
94907: DOUBLE
94908: EQUAL
94909: IFTRUE 94943
94911: LD_INT 27
94913: DOUBLE
94914: EQUAL
94915: IFTRUE 94943
94917: LD_INT 26
94919: DOUBLE
94920: EQUAL
94921: IFTRUE 94943
94923: LD_INT 28
94925: DOUBLE
94926: EQUAL
94927: IFTRUE 94943
94929: LD_INT 29
94931: DOUBLE
94932: EQUAL
94933: IFTRUE 94943
94935: LD_INT 30
94937: DOUBLE
94938: EQUAL
94939: IFTRUE 94943
94941: GO 94999
94943: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
94944: LD_ADDR_VAR 0 9
94948: PUSH
94949: LD_VAR 0 59
94953: PUSH
94954: LD_VAR 0 60
94958: PUSH
94959: LD_VAR 0 61
94963: PUSH
94964: LD_VAR 0 62
94968: PUSH
94969: LD_VAR 0 63
94973: PUSH
94974: LD_VAR 0 64
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: PUSH
94987: LD_VAR 0 4
94991: PUSH
94992: LD_INT 1
94994: PLUS
94995: ARRAY
94996: ST_TO_ADDR
94997: GO 95000
94999: POP
// temp_list2 = [ ] ;
95000: LD_ADDR_VAR 0 10
95004: PUSH
95005: EMPTY
95006: ST_TO_ADDR
// for i in temp_list do
95007: LD_ADDR_VAR 0 8
95011: PUSH
95012: LD_VAR 0 9
95016: PUSH
95017: FOR_IN
95018: IFFALSE 95070
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95020: LD_ADDR_VAR 0 10
95024: PUSH
95025: LD_VAR 0 10
95029: PUSH
95030: LD_VAR 0 8
95034: PUSH
95035: LD_INT 1
95037: ARRAY
95038: PUSH
95039: LD_VAR 0 2
95043: PLUS
95044: PUSH
95045: LD_VAR 0 8
95049: PUSH
95050: LD_INT 2
95052: ARRAY
95053: PUSH
95054: LD_VAR 0 3
95058: PLUS
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: EMPTY
95065: LIST
95066: ADD
95067: ST_TO_ADDR
95068: GO 95017
95070: POP
95071: POP
// result = temp_list2 ;
95072: LD_ADDR_VAR 0 7
95076: PUSH
95077: LD_VAR 0 10
95081: ST_TO_ADDR
// end ;
95082: LD_VAR 0 7
95086: RET
// export function EnemyInRange ( unit , dist ) ; begin
95087: LD_INT 0
95089: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95090: LD_ADDR_VAR 0 3
95094: PUSH
95095: LD_VAR 0 1
95099: PPUSH
95100: CALL_OW 255
95104: PPUSH
95105: LD_VAR 0 1
95109: PPUSH
95110: CALL_OW 250
95114: PPUSH
95115: LD_VAR 0 1
95119: PPUSH
95120: CALL_OW 251
95124: PPUSH
95125: LD_VAR 0 2
95129: PPUSH
95130: CALL 69215 0 4
95134: PUSH
95135: LD_INT 4
95137: ARRAY
95138: ST_TO_ADDR
// end ;
95139: LD_VAR 0 3
95143: RET
// export function PlayerSeeMe ( unit ) ; begin
95144: LD_INT 0
95146: PPUSH
// result := See ( your_side , unit ) ;
95147: LD_ADDR_VAR 0 2
95151: PUSH
95152: LD_OWVAR 2
95156: PPUSH
95157: LD_VAR 0 1
95161: PPUSH
95162: CALL_OW 292
95166: ST_TO_ADDR
// end ;
95167: LD_VAR 0 2
95171: RET
// export function ReverseDir ( unit ) ; begin
95172: LD_INT 0
95174: PPUSH
// if not unit then
95175: LD_VAR 0 1
95179: NOT
95180: IFFALSE 95184
// exit ;
95182: GO 95230
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
95184: LD_ADDR_VAR 0 2
95188: PUSH
95189: LD_INT 3
95191: PUSH
95192: LD_INT 4
95194: PUSH
95195: LD_INT 5
95197: PUSH
95198: LD_INT 0
95200: PUSH
95201: LD_INT 1
95203: PUSH
95204: LD_INT 2
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: PUSH
95215: LD_VAR 0 1
95219: PPUSH
95220: CALL_OW 254
95224: PUSH
95225: LD_INT 1
95227: PLUS
95228: ARRAY
95229: ST_TO_ADDR
// end ;
95230: LD_VAR 0 2
95234: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
95235: LD_INT 0
95237: PPUSH
95238: PPUSH
95239: PPUSH
95240: PPUSH
95241: PPUSH
// if not hexes then
95242: LD_VAR 0 2
95246: NOT
95247: IFFALSE 95251
// exit ;
95249: GO 95399
// dist := 9999 ;
95251: LD_ADDR_VAR 0 5
95255: PUSH
95256: LD_INT 9999
95258: ST_TO_ADDR
// for i = 1 to hexes do
95259: LD_ADDR_VAR 0 4
95263: PUSH
95264: DOUBLE
95265: LD_INT 1
95267: DEC
95268: ST_TO_ADDR
95269: LD_VAR 0 2
95273: PUSH
95274: FOR_TO
95275: IFFALSE 95387
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
95277: LD_VAR 0 1
95281: PPUSH
95282: LD_VAR 0 2
95286: PUSH
95287: LD_VAR 0 4
95291: ARRAY
95292: PUSH
95293: LD_INT 1
95295: ARRAY
95296: PPUSH
95297: LD_VAR 0 2
95301: PUSH
95302: LD_VAR 0 4
95306: ARRAY
95307: PUSH
95308: LD_INT 2
95310: ARRAY
95311: PPUSH
95312: CALL_OW 297
95316: PUSH
95317: LD_VAR 0 5
95321: LESS
95322: IFFALSE 95385
// begin hex := hexes [ i ] ;
95324: LD_ADDR_VAR 0 7
95328: PUSH
95329: LD_VAR 0 2
95333: PUSH
95334: LD_VAR 0 4
95338: ARRAY
95339: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
95340: LD_ADDR_VAR 0 5
95344: PUSH
95345: LD_VAR 0 1
95349: PPUSH
95350: LD_VAR 0 2
95354: PUSH
95355: LD_VAR 0 4
95359: ARRAY
95360: PUSH
95361: LD_INT 1
95363: ARRAY
95364: PPUSH
95365: LD_VAR 0 2
95369: PUSH
95370: LD_VAR 0 4
95374: ARRAY
95375: PUSH
95376: LD_INT 2
95378: ARRAY
95379: PPUSH
95380: CALL_OW 297
95384: ST_TO_ADDR
// end ; end ;
95385: GO 95274
95387: POP
95388: POP
// result := hex ;
95389: LD_ADDR_VAR 0 3
95393: PUSH
95394: LD_VAR 0 7
95398: ST_TO_ADDR
// end ;
95399: LD_VAR 0 3
95403: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
95404: LD_INT 0
95406: PPUSH
95407: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
95408: LD_VAR 0 1
95412: NOT
95413: PUSH
95414: LD_VAR 0 1
95418: PUSH
95419: LD_INT 21
95421: PUSH
95422: LD_INT 2
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 23
95431: PUSH
95432: LD_INT 2
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PPUSH
95443: CALL_OW 69
95447: IN
95448: NOT
95449: OR
95450: IFFALSE 95454
// exit ;
95452: GO 95501
// for i = 1 to 3 do
95454: LD_ADDR_VAR 0 3
95458: PUSH
95459: DOUBLE
95460: LD_INT 1
95462: DEC
95463: ST_TO_ADDR
95464: LD_INT 3
95466: PUSH
95467: FOR_TO
95468: IFFALSE 95499
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
95470: LD_VAR 0 1
95474: PPUSH
95475: CALL_OW 250
95479: PPUSH
95480: LD_VAR 0 1
95484: PPUSH
95485: CALL_OW 251
95489: PPUSH
95490: LD_INT 1
95492: PPUSH
95493: CALL_OW 453
95497: GO 95467
95499: POP
95500: POP
// end ;
95501: LD_VAR 0 2
95505: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
95506: LD_INT 0
95508: PPUSH
95509: PPUSH
95510: PPUSH
95511: PPUSH
95512: PPUSH
95513: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
95514: LD_VAR 0 1
95518: NOT
95519: PUSH
95520: LD_VAR 0 2
95524: NOT
95525: OR
95526: PUSH
95527: LD_VAR 0 1
95531: PPUSH
95532: CALL_OW 314
95536: OR
95537: IFFALSE 95541
// exit ;
95539: GO 95982
// x := GetX ( enemy_unit ) ;
95541: LD_ADDR_VAR 0 7
95545: PUSH
95546: LD_VAR 0 2
95550: PPUSH
95551: CALL_OW 250
95555: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
95556: LD_ADDR_VAR 0 8
95560: PUSH
95561: LD_VAR 0 2
95565: PPUSH
95566: CALL_OW 251
95570: ST_TO_ADDR
// if not x or not y then
95571: LD_VAR 0 7
95575: NOT
95576: PUSH
95577: LD_VAR 0 8
95581: NOT
95582: OR
95583: IFFALSE 95587
// exit ;
95585: GO 95982
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
95587: LD_ADDR_VAR 0 6
95591: PUSH
95592: LD_VAR 0 7
95596: PPUSH
95597: LD_INT 0
95599: PPUSH
95600: LD_INT 4
95602: PPUSH
95603: CALL_OW 272
95607: PUSH
95608: LD_VAR 0 8
95612: PPUSH
95613: LD_INT 0
95615: PPUSH
95616: LD_INT 4
95618: PPUSH
95619: CALL_OW 273
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: LD_VAR 0 7
95632: PPUSH
95633: LD_INT 1
95635: PPUSH
95636: LD_INT 4
95638: PPUSH
95639: CALL_OW 272
95643: PUSH
95644: LD_VAR 0 8
95648: PPUSH
95649: LD_INT 1
95651: PPUSH
95652: LD_INT 4
95654: PPUSH
95655: CALL_OW 273
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_VAR 0 7
95668: PPUSH
95669: LD_INT 2
95671: PPUSH
95672: LD_INT 4
95674: PPUSH
95675: CALL_OW 272
95679: PUSH
95680: LD_VAR 0 8
95684: PPUSH
95685: LD_INT 2
95687: PPUSH
95688: LD_INT 4
95690: PPUSH
95691: CALL_OW 273
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_VAR 0 7
95704: PPUSH
95705: LD_INT 3
95707: PPUSH
95708: LD_INT 4
95710: PPUSH
95711: CALL_OW 272
95715: PUSH
95716: LD_VAR 0 8
95720: PPUSH
95721: LD_INT 3
95723: PPUSH
95724: LD_INT 4
95726: PPUSH
95727: CALL_OW 273
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: LD_VAR 0 7
95740: PPUSH
95741: LD_INT 4
95743: PPUSH
95744: LD_INT 4
95746: PPUSH
95747: CALL_OW 272
95751: PUSH
95752: LD_VAR 0 8
95756: PPUSH
95757: LD_INT 4
95759: PPUSH
95760: LD_INT 4
95762: PPUSH
95763: CALL_OW 273
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: LD_VAR 0 7
95776: PPUSH
95777: LD_INT 5
95779: PPUSH
95780: LD_INT 4
95782: PPUSH
95783: CALL_OW 272
95787: PUSH
95788: LD_VAR 0 8
95792: PPUSH
95793: LD_INT 5
95795: PPUSH
95796: LD_INT 4
95798: PPUSH
95799: CALL_OW 273
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: ST_TO_ADDR
// for i = tmp downto 1 do
95816: LD_ADDR_VAR 0 4
95820: PUSH
95821: DOUBLE
95822: LD_VAR 0 6
95826: INC
95827: ST_TO_ADDR
95828: LD_INT 1
95830: PUSH
95831: FOR_DOWNTO
95832: IFFALSE 95933
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
95834: LD_VAR 0 6
95838: PUSH
95839: LD_VAR 0 4
95843: ARRAY
95844: PUSH
95845: LD_INT 1
95847: ARRAY
95848: PPUSH
95849: LD_VAR 0 6
95853: PUSH
95854: LD_VAR 0 4
95858: ARRAY
95859: PUSH
95860: LD_INT 2
95862: ARRAY
95863: PPUSH
95864: CALL_OW 488
95868: NOT
95869: PUSH
95870: LD_VAR 0 6
95874: PUSH
95875: LD_VAR 0 4
95879: ARRAY
95880: PUSH
95881: LD_INT 1
95883: ARRAY
95884: PPUSH
95885: LD_VAR 0 6
95889: PUSH
95890: LD_VAR 0 4
95894: ARRAY
95895: PUSH
95896: LD_INT 2
95898: ARRAY
95899: PPUSH
95900: CALL_OW 428
95904: PUSH
95905: LD_INT 0
95907: NONEQUAL
95908: OR
95909: IFFALSE 95931
// tmp := Delete ( tmp , i ) ;
95911: LD_ADDR_VAR 0 6
95915: PUSH
95916: LD_VAR 0 6
95920: PPUSH
95921: LD_VAR 0 4
95925: PPUSH
95926: CALL_OW 3
95930: ST_TO_ADDR
95931: GO 95831
95933: POP
95934: POP
// j := GetClosestHex ( unit , tmp ) ;
95935: LD_ADDR_VAR 0 5
95939: PUSH
95940: LD_VAR 0 1
95944: PPUSH
95945: LD_VAR 0 6
95949: PPUSH
95950: CALL 95235 0 2
95954: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
95955: LD_VAR 0 1
95959: PPUSH
95960: LD_VAR 0 5
95964: PUSH
95965: LD_INT 1
95967: ARRAY
95968: PPUSH
95969: LD_VAR 0 5
95973: PUSH
95974: LD_INT 2
95976: ARRAY
95977: PPUSH
95978: CALL_OW 111
// end ;
95982: LD_VAR 0 3
95986: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
95987: LD_INT 0
95989: PPUSH
95990: PPUSH
95991: PPUSH
// uc_side = 0 ;
95992: LD_ADDR_OWVAR 20
95996: PUSH
95997: LD_INT 0
95999: ST_TO_ADDR
// uc_nation = 0 ;
96000: LD_ADDR_OWVAR 21
96004: PUSH
96005: LD_INT 0
96007: ST_TO_ADDR
// InitHc ;
96008: CALL_OW 19
// InitVc ;
96012: CALL_OW 20
// if mastodonts then
96016: LD_VAR 0 6
96020: IFFALSE 96087
// for i = 1 to mastodonts do
96022: LD_ADDR_VAR 0 11
96026: PUSH
96027: DOUBLE
96028: LD_INT 1
96030: DEC
96031: ST_TO_ADDR
96032: LD_VAR 0 6
96036: PUSH
96037: FOR_TO
96038: IFFALSE 96085
// begin vc_chassis := 31 ;
96040: LD_ADDR_OWVAR 37
96044: PUSH
96045: LD_INT 31
96047: ST_TO_ADDR
// vc_control := control_rider ;
96048: LD_ADDR_OWVAR 38
96052: PUSH
96053: LD_INT 4
96055: ST_TO_ADDR
// animal := CreateVehicle ;
96056: LD_ADDR_VAR 0 12
96060: PUSH
96061: CALL_OW 45
96065: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96066: LD_VAR 0 12
96070: PPUSH
96071: LD_VAR 0 8
96075: PPUSH
96076: LD_INT 0
96078: PPUSH
96079: CALL 102793 0 3
// end ;
96083: GO 96037
96085: POP
96086: POP
// if horses then
96087: LD_VAR 0 5
96091: IFFALSE 96158
// for i = 1 to horses do
96093: LD_ADDR_VAR 0 11
96097: PUSH
96098: DOUBLE
96099: LD_INT 1
96101: DEC
96102: ST_TO_ADDR
96103: LD_VAR 0 5
96107: PUSH
96108: FOR_TO
96109: IFFALSE 96156
// begin hc_class := 21 ;
96111: LD_ADDR_OWVAR 28
96115: PUSH
96116: LD_INT 21
96118: ST_TO_ADDR
// hc_gallery :=  ;
96119: LD_ADDR_OWVAR 33
96123: PUSH
96124: LD_STRING 
96126: ST_TO_ADDR
// animal := CreateHuman ;
96127: LD_ADDR_VAR 0 12
96131: PUSH
96132: CALL_OW 44
96136: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96137: LD_VAR 0 12
96141: PPUSH
96142: LD_VAR 0 8
96146: PPUSH
96147: LD_INT 0
96149: PPUSH
96150: CALL 102793 0 3
// end ;
96154: GO 96108
96156: POP
96157: POP
// if birds then
96158: LD_VAR 0 1
96162: IFFALSE 96229
// for i = 1 to birds do
96164: LD_ADDR_VAR 0 11
96168: PUSH
96169: DOUBLE
96170: LD_INT 1
96172: DEC
96173: ST_TO_ADDR
96174: LD_VAR 0 1
96178: PUSH
96179: FOR_TO
96180: IFFALSE 96227
// begin hc_class = 18 ;
96182: LD_ADDR_OWVAR 28
96186: PUSH
96187: LD_INT 18
96189: ST_TO_ADDR
// hc_gallery =  ;
96190: LD_ADDR_OWVAR 33
96194: PUSH
96195: LD_STRING 
96197: ST_TO_ADDR
// animal := CreateHuman ;
96198: LD_ADDR_VAR 0 12
96202: PUSH
96203: CALL_OW 44
96207: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96208: LD_VAR 0 12
96212: PPUSH
96213: LD_VAR 0 8
96217: PPUSH
96218: LD_INT 0
96220: PPUSH
96221: CALL 102793 0 3
// end ;
96225: GO 96179
96227: POP
96228: POP
// if tigers then
96229: LD_VAR 0 2
96233: IFFALSE 96317
// for i = 1 to tigers do
96235: LD_ADDR_VAR 0 11
96239: PUSH
96240: DOUBLE
96241: LD_INT 1
96243: DEC
96244: ST_TO_ADDR
96245: LD_VAR 0 2
96249: PUSH
96250: FOR_TO
96251: IFFALSE 96315
// begin hc_class = class_tiger ;
96253: LD_ADDR_OWVAR 28
96257: PUSH
96258: LD_INT 14
96260: ST_TO_ADDR
// hc_gallery =  ;
96261: LD_ADDR_OWVAR 33
96265: PUSH
96266: LD_STRING 
96268: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
96269: LD_ADDR_OWVAR 35
96273: PUSH
96274: LD_INT 7
96276: NEG
96277: PPUSH
96278: LD_INT 7
96280: PPUSH
96281: CALL_OW 12
96285: ST_TO_ADDR
// animal := CreateHuman ;
96286: LD_ADDR_VAR 0 12
96290: PUSH
96291: CALL_OW 44
96295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96296: LD_VAR 0 12
96300: PPUSH
96301: LD_VAR 0 8
96305: PPUSH
96306: LD_INT 0
96308: PPUSH
96309: CALL 102793 0 3
// end ;
96313: GO 96250
96315: POP
96316: POP
// if apemans then
96317: LD_VAR 0 3
96321: IFFALSE 96444
// for i = 1 to apemans do
96323: LD_ADDR_VAR 0 11
96327: PUSH
96328: DOUBLE
96329: LD_INT 1
96331: DEC
96332: ST_TO_ADDR
96333: LD_VAR 0 3
96337: PUSH
96338: FOR_TO
96339: IFFALSE 96442
// begin hc_class = class_apeman ;
96341: LD_ADDR_OWVAR 28
96345: PUSH
96346: LD_INT 12
96348: ST_TO_ADDR
// hc_gallery =  ;
96349: LD_ADDR_OWVAR 33
96353: PUSH
96354: LD_STRING 
96356: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
96357: LD_ADDR_OWVAR 35
96361: PUSH
96362: LD_INT 5
96364: NEG
96365: PPUSH
96366: LD_INT 5
96368: PPUSH
96369: CALL_OW 12
96373: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
96374: LD_ADDR_OWVAR 31
96378: PUSH
96379: LD_INT 1
96381: PPUSH
96382: LD_INT 3
96384: PPUSH
96385: CALL_OW 12
96389: PUSH
96390: LD_INT 1
96392: PPUSH
96393: LD_INT 3
96395: PPUSH
96396: CALL_OW 12
96400: PUSH
96401: LD_INT 0
96403: PUSH
96404: LD_INT 0
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: ST_TO_ADDR
// animal := CreateHuman ;
96413: LD_ADDR_VAR 0 12
96417: PUSH
96418: CALL_OW 44
96422: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96423: LD_VAR 0 12
96427: PPUSH
96428: LD_VAR 0 8
96432: PPUSH
96433: LD_INT 0
96435: PPUSH
96436: CALL 102793 0 3
// end ;
96440: GO 96338
96442: POP
96443: POP
// if enchidnas then
96444: LD_VAR 0 4
96448: IFFALSE 96515
// for i = 1 to enchidnas do
96450: LD_ADDR_VAR 0 11
96454: PUSH
96455: DOUBLE
96456: LD_INT 1
96458: DEC
96459: ST_TO_ADDR
96460: LD_VAR 0 4
96464: PUSH
96465: FOR_TO
96466: IFFALSE 96513
// begin hc_class = 13 ;
96468: LD_ADDR_OWVAR 28
96472: PUSH
96473: LD_INT 13
96475: ST_TO_ADDR
// hc_gallery =  ;
96476: LD_ADDR_OWVAR 33
96480: PUSH
96481: LD_STRING 
96483: ST_TO_ADDR
// animal := CreateHuman ;
96484: LD_ADDR_VAR 0 12
96488: PUSH
96489: CALL_OW 44
96493: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96494: LD_VAR 0 12
96498: PPUSH
96499: LD_VAR 0 8
96503: PPUSH
96504: LD_INT 0
96506: PPUSH
96507: CALL 102793 0 3
// end ;
96511: GO 96465
96513: POP
96514: POP
// if fishes then
96515: LD_VAR 0 7
96519: IFFALSE 96586
// for i = 1 to fishes do
96521: LD_ADDR_VAR 0 11
96525: PUSH
96526: DOUBLE
96527: LD_INT 1
96529: DEC
96530: ST_TO_ADDR
96531: LD_VAR 0 7
96535: PUSH
96536: FOR_TO
96537: IFFALSE 96584
// begin hc_class = 20 ;
96539: LD_ADDR_OWVAR 28
96543: PUSH
96544: LD_INT 20
96546: ST_TO_ADDR
// hc_gallery =  ;
96547: LD_ADDR_OWVAR 33
96551: PUSH
96552: LD_STRING 
96554: ST_TO_ADDR
// animal := CreateHuman ;
96555: LD_ADDR_VAR 0 12
96559: PUSH
96560: CALL_OW 44
96564: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
96565: LD_VAR 0 12
96569: PPUSH
96570: LD_VAR 0 9
96574: PPUSH
96575: LD_INT 0
96577: PPUSH
96578: CALL 102793 0 3
// end ;
96582: GO 96536
96584: POP
96585: POP
// end ;
96586: LD_VAR 0 10
96590: RET
// export function WantHeal ( sci , unit ) ; begin
96591: LD_INT 0
96593: PPUSH
// if GetTaskList ( sci ) > 0 then
96594: LD_VAR 0 1
96598: PPUSH
96599: CALL_OW 437
96603: PUSH
96604: LD_INT 0
96606: GREATER
96607: IFFALSE 96677
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
96609: LD_VAR 0 1
96613: PPUSH
96614: CALL_OW 437
96618: PUSH
96619: LD_INT 1
96621: ARRAY
96622: PUSH
96623: LD_INT 1
96625: ARRAY
96626: PUSH
96627: LD_STRING l
96629: EQUAL
96630: PUSH
96631: LD_VAR 0 1
96635: PPUSH
96636: CALL_OW 437
96640: PUSH
96641: LD_INT 1
96643: ARRAY
96644: PUSH
96645: LD_INT 4
96647: ARRAY
96648: PUSH
96649: LD_VAR 0 2
96653: EQUAL
96654: AND
96655: IFFALSE 96667
// result := true else
96657: LD_ADDR_VAR 0 3
96661: PUSH
96662: LD_INT 1
96664: ST_TO_ADDR
96665: GO 96675
// result := false ;
96667: LD_ADDR_VAR 0 3
96671: PUSH
96672: LD_INT 0
96674: ST_TO_ADDR
// end else
96675: GO 96685
// result := false ;
96677: LD_ADDR_VAR 0 3
96681: PUSH
96682: LD_INT 0
96684: ST_TO_ADDR
// end ;
96685: LD_VAR 0 3
96689: RET
// export function HealTarget ( sci ) ; begin
96690: LD_INT 0
96692: PPUSH
// if not sci then
96693: LD_VAR 0 1
96697: NOT
96698: IFFALSE 96702
// exit ;
96700: GO 96767
// result := 0 ;
96702: LD_ADDR_VAR 0 2
96706: PUSH
96707: LD_INT 0
96709: ST_TO_ADDR
// if GetTaskList ( sci ) then
96710: LD_VAR 0 1
96714: PPUSH
96715: CALL_OW 437
96719: IFFALSE 96767
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
96721: LD_VAR 0 1
96725: PPUSH
96726: CALL_OW 437
96730: PUSH
96731: LD_INT 1
96733: ARRAY
96734: PUSH
96735: LD_INT 1
96737: ARRAY
96738: PUSH
96739: LD_STRING l
96741: EQUAL
96742: IFFALSE 96767
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
96744: LD_ADDR_VAR 0 2
96748: PUSH
96749: LD_VAR 0 1
96753: PPUSH
96754: CALL_OW 437
96758: PUSH
96759: LD_INT 1
96761: ARRAY
96762: PUSH
96763: LD_INT 4
96765: ARRAY
96766: ST_TO_ADDR
// end ;
96767: LD_VAR 0 2
96771: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
96772: LD_INT 0
96774: PPUSH
96775: PPUSH
96776: PPUSH
96777: PPUSH
96778: PPUSH
96779: PPUSH
96780: PPUSH
96781: PPUSH
96782: PPUSH
96783: PPUSH
96784: PPUSH
96785: PPUSH
96786: PPUSH
96787: PPUSH
96788: PPUSH
96789: PPUSH
96790: PPUSH
96791: PPUSH
96792: PPUSH
96793: PPUSH
96794: PPUSH
96795: PPUSH
96796: PPUSH
96797: PPUSH
96798: PPUSH
96799: PPUSH
96800: PPUSH
96801: PPUSH
96802: PPUSH
96803: PPUSH
96804: PPUSH
96805: PPUSH
96806: PPUSH
// if not list then
96807: LD_VAR 0 1
96811: NOT
96812: IFFALSE 96816
// exit ;
96814: GO 101404
// base := list [ 1 ] ;
96816: LD_ADDR_VAR 0 3
96820: PUSH
96821: LD_VAR 0 1
96825: PUSH
96826: LD_INT 1
96828: ARRAY
96829: ST_TO_ADDR
// group := list [ 2 ] ;
96830: LD_ADDR_VAR 0 4
96834: PUSH
96835: LD_VAR 0 1
96839: PUSH
96840: LD_INT 2
96842: ARRAY
96843: ST_TO_ADDR
// path := list [ 3 ] ;
96844: LD_ADDR_VAR 0 5
96848: PUSH
96849: LD_VAR 0 1
96853: PUSH
96854: LD_INT 3
96856: ARRAY
96857: ST_TO_ADDR
// flags := list [ 4 ] ;
96858: LD_ADDR_VAR 0 6
96862: PUSH
96863: LD_VAR 0 1
96867: PUSH
96868: LD_INT 4
96870: ARRAY
96871: ST_TO_ADDR
// mined := [ ] ;
96872: LD_ADDR_VAR 0 27
96876: PUSH
96877: EMPTY
96878: ST_TO_ADDR
// bombed := [ ] ;
96879: LD_ADDR_VAR 0 28
96883: PUSH
96884: EMPTY
96885: ST_TO_ADDR
// healers := [ ] ;
96886: LD_ADDR_VAR 0 31
96890: PUSH
96891: EMPTY
96892: ST_TO_ADDR
// to_heal := [ ] ;
96893: LD_ADDR_VAR 0 30
96897: PUSH
96898: EMPTY
96899: ST_TO_ADDR
// repairs := [ ] ;
96900: LD_ADDR_VAR 0 33
96904: PUSH
96905: EMPTY
96906: ST_TO_ADDR
// to_repair := [ ] ;
96907: LD_ADDR_VAR 0 32
96911: PUSH
96912: EMPTY
96913: ST_TO_ADDR
// if not group or not path then
96914: LD_VAR 0 4
96918: NOT
96919: PUSH
96920: LD_VAR 0 5
96924: NOT
96925: OR
96926: IFFALSE 96930
// exit ;
96928: GO 101404
// if flags then
96930: LD_VAR 0 6
96934: IFFALSE 97078
// begin f_ignore_area := flags [ 1 ] ;
96936: LD_ADDR_VAR 0 17
96940: PUSH
96941: LD_VAR 0 6
96945: PUSH
96946: LD_INT 1
96948: ARRAY
96949: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
96950: LD_ADDR_VAR 0 18
96954: PUSH
96955: LD_VAR 0 6
96959: PUSH
96960: LD_INT 2
96962: ARRAY
96963: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
96964: LD_ADDR_VAR 0 19
96968: PUSH
96969: LD_VAR 0 6
96973: PUSH
96974: LD_INT 3
96976: ARRAY
96977: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
96978: LD_ADDR_VAR 0 20
96982: PUSH
96983: LD_VAR 0 6
96987: PUSH
96988: LD_INT 4
96990: ARRAY
96991: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
96992: LD_ADDR_VAR 0 21
96996: PUSH
96997: LD_VAR 0 6
97001: PUSH
97002: LD_INT 5
97004: ARRAY
97005: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
97006: LD_ADDR_VAR 0 22
97010: PUSH
97011: LD_VAR 0 6
97015: PUSH
97016: LD_INT 6
97018: ARRAY
97019: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
97020: LD_ADDR_VAR 0 23
97024: PUSH
97025: LD_VAR 0 6
97029: PUSH
97030: LD_INT 7
97032: ARRAY
97033: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
97034: LD_ADDR_VAR 0 24
97038: PUSH
97039: LD_VAR 0 6
97043: PUSH
97044: LD_INT 8
97046: ARRAY
97047: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
97048: LD_ADDR_VAR 0 25
97052: PUSH
97053: LD_VAR 0 6
97057: PUSH
97058: LD_INT 9
97060: ARRAY
97061: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
97062: LD_ADDR_VAR 0 26
97066: PUSH
97067: LD_VAR 0 6
97071: PUSH
97072: LD_INT 10
97074: ARRAY
97075: ST_TO_ADDR
// end else
97076: GO 97158
// begin f_ignore_area := false ;
97078: LD_ADDR_VAR 0 17
97082: PUSH
97083: LD_INT 0
97085: ST_TO_ADDR
// f_capture := false ;
97086: LD_ADDR_VAR 0 18
97090: PUSH
97091: LD_INT 0
97093: ST_TO_ADDR
// f_ignore_civ := false ;
97094: LD_ADDR_VAR 0 19
97098: PUSH
97099: LD_INT 0
97101: ST_TO_ADDR
// f_murder := false ;
97102: LD_ADDR_VAR 0 20
97106: PUSH
97107: LD_INT 0
97109: ST_TO_ADDR
// f_mines := false ;
97110: LD_ADDR_VAR 0 21
97114: PUSH
97115: LD_INT 0
97117: ST_TO_ADDR
// f_repair := false ;
97118: LD_ADDR_VAR 0 22
97122: PUSH
97123: LD_INT 0
97125: ST_TO_ADDR
// f_heal := false ;
97126: LD_ADDR_VAR 0 23
97130: PUSH
97131: LD_INT 0
97133: ST_TO_ADDR
// f_spacetime := false ;
97134: LD_ADDR_VAR 0 24
97138: PUSH
97139: LD_INT 0
97141: ST_TO_ADDR
// f_attack_depot := false ;
97142: LD_ADDR_VAR 0 25
97146: PUSH
97147: LD_INT 0
97149: ST_TO_ADDR
// f_crawl := false ;
97150: LD_ADDR_VAR 0 26
97154: PUSH
97155: LD_INT 0
97157: ST_TO_ADDR
// end ; if f_heal then
97158: LD_VAR 0 23
97162: IFFALSE 97189
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
97164: LD_ADDR_VAR 0 31
97168: PUSH
97169: LD_VAR 0 4
97173: PPUSH
97174: LD_INT 25
97176: PUSH
97177: LD_INT 4
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PPUSH
97184: CALL_OW 72
97188: ST_TO_ADDR
// if f_repair then
97189: LD_VAR 0 22
97193: IFFALSE 97220
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
97195: LD_ADDR_VAR 0 33
97199: PUSH
97200: LD_VAR 0 4
97204: PPUSH
97205: LD_INT 25
97207: PUSH
97208: LD_INT 3
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PPUSH
97215: CALL_OW 72
97219: ST_TO_ADDR
// units_path := [ ] ;
97220: LD_ADDR_VAR 0 16
97224: PUSH
97225: EMPTY
97226: ST_TO_ADDR
// for i = 1 to group do
97227: LD_ADDR_VAR 0 7
97231: PUSH
97232: DOUBLE
97233: LD_INT 1
97235: DEC
97236: ST_TO_ADDR
97237: LD_VAR 0 4
97241: PUSH
97242: FOR_TO
97243: IFFALSE 97272
// units_path := Replace ( units_path , i , path ) ;
97245: LD_ADDR_VAR 0 16
97249: PUSH
97250: LD_VAR 0 16
97254: PPUSH
97255: LD_VAR 0 7
97259: PPUSH
97260: LD_VAR 0 5
97264: PPUSH
97265: CALL_OW 1
97269: ST_TO_ADDR
97270: GO 97242
97272: POP
97273: POP
// repeat for i = group downto 1 do
97274: LD_ADDR_VAR 0 7
97278: PUSH
97279: DOUBLE
97280: LD_VAR 0 4
97284: INC
97285: ST_TO_ADDR
97286: LD_INT 1
97288: PUSH
97289: FOR_DOWNTO
97290: IFFALSE 101386
// begin wait ( 5 ) ;
97292: LD_INT 5
97294: PPUSH
97295: CALL_OW 67
// tmp := [ ] ;
97299: LD_ADDR_VAR 0 14
97303: PUSH
97304: EMPTY
97305: ST_TO_ADDR
// attacking := false ;
97306: LD_ADDR_VAR 0 29
97310: PUSH
97311: LD_INT 0
97313: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
97314: LD_VAR 0 4
97318: PUSH
97319: LD_VAR 0 7
97323: ARRAY
97324: PPUSH
97325: CALL_OW 301
97329: PUSH
97330: LD_VAR 0 4
97334: PUSH
97335: LD_VAR 0 7
97339: ARRAY
97340: NOT
97341: OR
97342: IFFALSE 97451
// begin if GetType ( group [ i ] ) = unit_human then
97344: LD_VAR 0 4
97348: PUSH
97349: LD_VAR 0 7
97353: ARRAY
97354: PPUSH
97355: CALL_OW 247
97359: PUSH
97360: LD_INT 1
97362: EQUAL
97363: IFFALSE 97409
// begin to_heal := to_heal diff group [ i ] ;
97365: LD_ADDR_VAR 0 30
97369: PUSH
97370: LD_VAR 0 30
97374: PUSH
97375: LD_VAR 0 4
97379: PUSH
97380: LD_VAR 0 7
97384: ARRAY
97385: DIFF
97386: ST_TO_ADDR
// healers := healers diff group [ i ] ;
97387: LD_ADDR_VAR 0 31
97391: PUSH
97392: LD_VAR 0 31
97396: PUSH
97397: LD_VAR 0 4
97401: PUSH
97402: LD_VAR 0 7
97406: ARRAY
97407: DIFF
97408: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
97409: LD_ADDR_VAR 0 4
97413: PUSH
97414: LD_VAR 0 4
97418: PPUSH
97419: LD_VAR 0 7
97423: PPUSH
97424: CALL_OW 3
97428: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
97429: LD_ADDR_VAR 0 16
97433: PUSH
97434: LD_VAR 0 16
97438: PPUSH
97439: LD_VAR 0 7
97443: PPUSH
97444: CALL_OW 3
97448: ST_TO_ADDR
// continue ;
97449: GO 97289
// end ; if f_repair then
97451: LD_VAR 0 22
97455: IFFALSE 97944
// begin if GetType ( group [ i ] ) = unit_vehicle then
97457: LD_VAR 0 4
97461: PUSH
97462: LD_VAR 0 7
97466: ARRAY
97467: PPUSH
97468: CALL_OW 247
97472: PUSH
97473: LD_INT 2
97475: EQUAL
97476: IFFALSE 97666
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
97478: LD_VAR 0 4
97482: PUSH
97483: LD_VAR 0 7
97487: ARRAY
97488: PPUSH
97489: CALL_OW 256
97493: PUSH
97494: LD_INT 700
97496: LESS
97497: PUSH
97498: LD_VAR 0 4
97502: PUSH
97503: LD_VAR 0 7
97507: ARRAY
97508: PUSH
97509: LD_VAR 0 32
97513: IN
97514: NOT
97515: AND
97516: IFFALSE 97540
// to_repair := to_repair union group [ i ] ;
97518: LD_ADDR_VAR 0 32
97522: PUSH
97523: LD_VAR 0 32
97527: PUSH
97528: LD_VAR 0 4
97532: PUSH
97533: LD_VAR 0 7
97537: ARRAY
97538: UNION
97539: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
97540: LD_VAR 0 4
97544: PUSH
97545: LD_VAR 0 7
97549: ARRAY
97550: PPUSH
97551: CALL_OW 256
97555: PUSH
97556: LD_INT 1000
97558: EQUAL
97559: PUSH
97560: LD_VAR 0 4
97564: PUSH
97565: LD_VAR 0 7
97569: ARRAY
97570: PUSH
97571: LD_VAR 0 32
97575: IN
97576: AND
97577: IFFALSE 97601
// to_repair := to_repair diff group [ i ] ;
97579: LD_ADDR_VAR 0 32
97583: PUSH
97584: LD_VAR 0 32
97588: PUSH
97589: LD_VAR 0 4
97593: PUSH
97594: LD_VAR 0 7
97598: ARRAY
97599: DIFF
97600: ST_TO_ADDR
// if group [ i ] in to_repair then
97601: LD_VAR 0 4
97605: PUSH
97606: LD_VAR 0 7
97610: ARRAY
97611: PUSH
97612: LD_VAR 0 32
97616: IN
97617: IFFALSE 97664
// begin if not IsInArea ( group [ i ] , f_repair ) then
97619: LD_VAR 0 4
97623: PUSH
97624: LD_VAR 0 7
97628: ARRAY
97629: PPUSH
97630: LD_VAR 0 22
97634: PPUSH
97635: CALL_OW 308
97639: NOT
97640: IFFALSE 97662
// ComMoveToArea ( group [ i ] , f_repair ) ;
97642: LD_VAR 0 4
97646: PUSH
97647: LD_VAR 0 7
97651: ARRAY
97652: PPUSH
97653: LD_VAR 0 22
97657: PPUSH
97658: CALL_OW 113
// continue ;
97662: GO 97289
// end ; end else
97664: GO 97944
// if group [ i ] in repairs then
97666: LD_VAR 0 4
97670: PUSH
97671: LD_VAR 0 7
97675: ARRAY
97676: PUSH
97677: LD_VAR 0 33
97681: IN
97682: IFFALSE 97944
// begin if IsInUnit ( group [ i ] ) then
97684: LD_VAR 0 4
97688: PUSH
97689: LD_VAR 0 7
97693: ARRAY
97694: PPUSH
97695: CALL_OW 310
97699: IFFALSE 97767
// begin z := IsInUnit ( group [ i ] ) ;
97701: LD_ADDR_VAR 0 13
97705: PUSH
97706: LD_VAR 0 4
97710: PUSH
97711: LD_VAR 0 7
97715: ARRAY
97716: PPUSH
97717: CALL_OW 310
97721: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
97722: LD_VAR 0 13
97726: PUSH
97727: LD_VAR 0 32
97731: IN
97732: PUSH
97733: LD_VAR 0 13
97737: PPUSH
97738: LD_VAR 0 22
97742: PPUSH
97743: CALL_OW 308
97747: AND
97748: IFFALSE 97765
// ComExitVehicle ( group [ i ] ) ;
97750: LD_VAR 0 4
97754: PUSH
97755: LD_VAR 0 7
97759: ARRAY
97760: PPUSH
97761: CALL_OW 121
// end else
97765: GO 97944
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
97767: LD_ADDR_VAR 0 13
97771: PUSH
97772: LD_VAR 0 4
97776: PPUSH
97777: LD_INT 95
97779: PUSH
97780: LD_VAR 0 22
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: PUSH
97789: LD_INT 58
97791: PUSH
97792: EMPTY
97793: LIST
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: PPUSH
97799: CALL_OW 72
97803: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
97804: LD_VAR 0 4
97808: PUSH
97809: LD_VAR 0 7
97813: ARRAY
97814: PPUSH
97815: CALL_OW 314
97819: NOT
97820: IFFALSE 97942
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
97822: LD_ADDR_VAR 0 10
97826: PUSH
97827: LD_VAR 0 13
97831: PPUSH
97832: LD_VAR 0 4
97836: PUSH
97837: LD_VAR 0 7
97841: ARRAY
97842: PPUSH
97843: CALL_OW 74
97847: ST_TO_ADDR
// if not x then
97848: LD_VAR 0 10
97852: NOT
97853: IFFALSE 97857
// continue ;
97855: GO 97289
// if GetLives ( x ) < 1000 then
97857: LD_VAR 0 10
97861: PPUSH
97862: CALL_OW 256
97866: PUSH
97867: LD_INT 1000
97869: LESS
97870: IFFALSE 97894
// ComRepairVehicle ( group [ i ] , x ) else
97872: LD_VAR 0 4
97876: PUSH
97877: LD_VAR 0 7
97881: ARRAY
97882: PPUSH
97883: LD_VAR 0 10
97887: PPUSH
97888: CALL_OW 129
97892: GO 97942
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
97894: LD_VAR 0 23
97898: PUSH
97899: LD_VAR 0 4
97903: PUSH
97904: LD_VAR 0 7
97908: ARRAY
97909: PPUSH
97910: CALL_OW 256
97914: PUSH
97915: LD_INT 1000
97917: LESS
97918: AND
97919: NOT
97920: IFFALSE 97942
// ComEnterUnit ( group [ i ] , x ) ;
97922: LD_VAR 0 4
97926: PUSH
97927: LD_VAR 0 7
97931: ARRAY
97932: PPUSH
97933: LD_VAR 0 10
97937: PPUSH
97938: CALL_OW 120
// end ; continue ;
97942: GO 97289
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
97944: LD_VAR 0 23
97948: PUSH
97949: LD_VAR 0 4
97953: PUSH
97954: LD_VAR 0 7
97958: ARRAY
97959: PPUSH
97960: CALL_OW 247
97964: PUSH
97965: LD_INT 1
97967: EQUAL
97968: AND
97969: IFFALSE 98447
// begin if group [ i ] in healers then
97971: LD_VAR 0 4
97975: PUSH
97976: LD_VAR 0 7
97980: ARRAY
97981: PUSH
97982: LD_VAR 0 31
97986: IN
97987: IFFALSE 98260
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
97989: LD_VAR 0 4
97993: PUSH
97994: LD_VAR 0 7
97998: ARRAY
97999: PPUSH
98000: LD_VAR 0 23
98004: PPUSH
98005: CALL_OW 308
98009: NOT
98010: PUSH
98011: LD_VAR 0 4
98015: PUSH
98016: LD_VAR 0 7
98020: ARRAY
98021: PPUSH
98022: CALL_OW 314
98026: NOT
98027: AND
98028: IFFALSE 98052
// ComMoveToArea ( group [ i ] , f_heal ) else
98030: LD_VAR 0 4
98034: PUSH
98035: LD_VAR 0 7
98039: ARRAY
98040: PPUSH
98041: LD_VAR 0 23
98045: PPUSH
98046: CALL_OW 113
98050: GO 98258
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
98052: LD_VAR 0 4
98056: PUSH
98057: LD_VAR 0 7
98061: ARRAY
98062: PPUSH
98063: CALL 96690 0 1
98067: PPUSH
98068: CALL_OW 256
98072: PUSH
98073: LD_INT 1000
98075: EQUAL
98076: IFFALSE 98095
// ComStop ( group [ i ] ) else
98078: LD_VAR 0 4
98082: PUSH
98083: LD_VAR 0 7
98087: ARRAY
98088: PPUSH
98089: CALL_OW 141
98093: GO 98258
// if not HasTask ( group [ i ] ) and to_heal then
98095: LD_VAR 0 4
98099: PUSH
98100: LD_VAR 0 7
98104: ARRAY
98105: PPUSH
98106: CALL_OW 314
98110: NOT
98111: PUSH
98112: LD_VAR 0 30
98116: AND
98117: IFFALSE 98258
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
98119: LD_ADDR_VAR 0 13
98123: PUSH
98124: LD_VAR 0 30
98128: PPUSH
98129: LD_INT 3
98131: PUSH
98132: LD_INT 54
98134: PUSH
98135: EMPTY
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: PPUSH
98142: CALL_OW 72
98146: PPUSH
98147: LD_VAR 0 4
98151: PUSH
98152: LD_VAR 0 7
98156: ARRAY
98157: PPUSH
98158: CALL_OW 74
98162: ST_TO_ADDR
// if z then
98163: LD_VAR 0 13
98167: IFFALSE 98258
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
98169: LD_INT 91
98171: PUSH
98172: LD_VAR 0 13
98176: PUSH
98177: LD_INT 10
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: LIST
98184: PUSH
98185: LD_INT 81
98187: PUSH
98188: LD_VAR 0 13
98192: PPUSH
98193: CALL_OW 255
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PPUSH
98206: CALL_OW 69
98210: PUSH
98211: LD_INT 0
98213: EQUAL
98214: IFFALSE 98238
// ComHeal ( group [ i ] , z ) else
98216: LD_VAR 0 4
98220: PUSH
98221: LD_VAR 0 7
98225: ARRAY
98226: PPUSH
98227: LD_VAR 0 13
98231: PPUSH
98232: CALL_OW 128
98236: GO 98258
// ComMoveToArea ( group [ i ] , f_heal ) ;
98238: LD_VAR 0 4
98242: PUSH
98243: LD_VAR 0 7
98247: ARRAY
98248: PPUSH
98249: LD_VAR 0 23
98253: PPUSH
98254: CALL_OW 113
// end ; continue ;
98258: GO 97289
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
98260: LD_VAR 0 4
98264: PUSH
98265: LD_VAR 0 7
98269: ARRAY
98270: PPUSH
98271: CALL_OW 256
98275: PUSH
98276: LD_INT 700
98278: LESS
98279: PUSH
98280: LD_VAR 0 4
98284: PUSH
98285: LD_VAR 0 7
98289: ARRAY
98290: PUSH
98291: LD_VAR 0 30
98295: IN
98296: NOT
98297: AND
98298: IFFALSE 98322
// to_heal := to_heal union group [ i ] ;
98300: LD_ADDR_VAR 0 30
98304: PUSH
98305: LD_VAR 0 30
98309: PUSH
98310: LD_VAR 0 4
98314: PUSH
98315: LD_VAR 0 7
98319: ARRAY
98320: UNION
98321: ST_TO_ADDR
// if group [ i ] in to_heal then
98322: LD_VAR 0 4
98326: PUSH
98327: LD_VAR 0 7
98331: ARRAY
98332: PUSH
98333: LD_VAR 0 30
98337: IN
98338: IFFALSE 98447
// begin if GetLives ( group [ i ] ) = 1000 then
98340: LD_VAR 0 4
98344: PUSH
98345: LD_VAR 0 7
98349: ARRAY
98350: PPUSH
98351: CALL_OW 256
98355: PUSH
98356: LD_INT 1000
98358: EQUAL
98359: IFFALSE 98385
// to_heal := to_heal diff group [ i ] else
98361: LD_ADDR_VAR 0 30
98365: PUSH
98366: LD_VAR 0 30
98370: PUSH
98371: LD_VAR 0 4
98375: PUSH
98376: LD_VAR 0 7
98380: ARRAY
98381: DIFF
98382: ST_TO_ADDR
98383: GO 98447
// begin if not IsInArea ( group [ i ] , to_heal ) then
98385: LD_VAR 0 4
98389: PUSH
98390: LD_VAR 0 7
98394: ARRAY
98395: PPUSH
98396: LD_VAR 0 30
98400: PPUSH
98401: CALL_OW 308
98405: NOT
98406: IFFALSE 98430
// ComMoveToArea ( group [ i ] , f_heal ) else
98408: LD_VAR 0 4
98412: PUSH
98413: LD_VAR 0 7
98417: ARRAY
98418: PPUSH
98419: LD_VAR 0 23
98423: PPUSH
98424: CALL_OW 113
98428: GO 98445
// ComHold ( group [ i ] ) ;
98430: LD_VAR 0 4
98434: PUSH
98435: LD_VAR 0 7
98439: ARRAY
98440: PPUSH
98441: CALL_OW 140
// continue ;
98445: GO 97289
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
98447: LD_VAR 0 4
98451: PUSH
98452: LD_VAR 0 7
98456: ARRAY
98457: PPUSH
98458: LD_INT 10
98460: PPUSH
98461: CALL 95087 0 2
98465: NOT
98466: PUSH
98467: LD_VAR 0 16
98471: PUSH
98472: LD_VAR 0 7
98476: ARRAY
98477: PUSH
98478: EMPTY
98479: EQUAL
98480: NOT
98481: AND
98482: IFFALSE 98748
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
98484: LD_VAR 0 4
98488: PUSH
98489: LD_VAR 0 7
98493: ARRAY
98494: PPUSH
98495: CALL_OW 262
98499: PUSH
98500: LD_INT 1
98502: PUSH
98503: LD_INT 2
98505: PUSH
98506: EMPTY
98507: LIST
98508: LIST
98509: IN
98510: IFFALSE 98551
// if GetFuel ( group [ i ] ) < 10 then
98512: LD_VAR 0 4
98516: PUSH
98517: LD_VAR 0 7
98521: ARRAY
98522: PPUSH
98523: CALL_OW 261
98527: PUSH
98528: LD_INT 10
98530: LESS
98531: IFFALSE 98551
// SetFuel ( group [ i ] , 12 ) ;
98533: LD_VAR 0 4
98537: PUSH
98538: LD_VAR 0 7
98542: ARRAY
98543: PPUSH
98544: LD_INT 12
98546: PPUSH
98547: CALL_OW 240
// if units_path [ i ] then
98551: LD_VAR 0 16
98555: PUSH
98556: LD_VAR 0 7
98560: ARRAY
98561: IFFALSE 98746
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
98563: LD_VAR 0 4
98567: PUSH
98568: LD_VAR 0 7
98572: ARRAY
98573: PPUSH
98574: LD_VAR 0 16
98578: PUSH
98579: LD_VAR 0 7
98583: ARRAY
98584: PUSH
98585: LD_INT 1
98587: ARRAY
98588: PUSH
98589: LD_INT 1
98591: ARRAY
98592: PPUSH
98593: LD_VAR 0 16
98597: PUSH
98598: LD_VAR 0 7
98602: ARRAY
98603: PUSH
98604: LD_INT 1
98606: ARRAY
98607: PUSH
98608: LD_INT 2
98610: ARRAY
98611: PPUSH
98612: CALL_OW 297
98616: PUSH
98617: LD_INT 6
98619: GREATER
98620: IFFALSE 98695
// begin if not HasTask ( group [ i ] ) then
98622: LD_VAR 0 4
98626: PUSH
98627: LD_VAR 0 7
98631: ARRAY
98632: PPUSH
98633: CALL_OW 314
98637: NOT
98638: IFFALSE 98693
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
98640: LD_VAR 0 4
98644: PUSH
98645: LD_VAR 0 7
98649: ARRAY
98650: PPUSH
98651: LD_VAR 0 16
98655: PUSH
98656: LD_VAR 0 7
98660: ARRAY
98661: PUSH
98662: LD_INT 1
98664: ARRAY
98665: PUSH
98666: LD_INT 1
98668: ARRAY
98669: PPUSH
98670: LD_VAR 0 16
98674: PUSH
98675: LD_VAR 0 7
98679: ARRAY
98680: PUSH
98681: LD_INT 1
98683: ARRAY
98684: PUSH
98685: LD_INT 2
98687: ARRAY
98688: PPUSH
98689: CALL_OW 114
// end else
98693: GO 98746
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
98695: LD_ADDR_VAR 0 15
98699: PUSH
98700: LD_VAR 0 16
98704: PUSH
98705: LD_VAR 0 7
98709: ARRAY
98710: PPUSH
98711: LD_INT 1
98713: PPUSH
98714: CALL_OW 3
98718: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
98719: LD_ADDR_VAR 0 16
98723: PUSH
98724: LD_VAR 0 16
98728: PPUSH
98729: LD_VAR 0 7
98733: PPUSH
98734: LD_VAR 0 15
98738: PPUSH
98739: CALL_OW 1
98743: ST_TO_ADDR
// continue ;
98744: GO 97289
// end ; end ; end else
98746: GO 101384
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
98748: LD_ADDR_VAR 0 14
98752: PUSH
98753: LD_INT 81
98755: PUSH
98756: LD_VAR 0 4
98760: PUSH
98761: LD_VAR 0 7
98765: ARRAY
98766: PPUSH
98767: CALL_OW 255
98771: PUSH
98772: EMPTY
98773: LIST
98774: LIST
98775: PPUSH
98776: CALL_OW 69
98780: ST_TO_ADDR
// if not tmp then
98781: LD_VAR 0 14
98785: NOT
98786: IFFALSE 98790
// continue ;
98788: GO 97289
// if f_ignore_area then
98790: LD_VAR 0 17
98794: IFFALSE 98882
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
98796: LD_ADDR_VAR 0 15
98800: PUSH
98801: LD_VAR 0 14
98805: PPUSH
98806: LD_INT 3
98808: PUSH
98809: LD_INT 92
98811: PUSH
98812: LD_VAR 0 17
98816: PUSH
98817: LD_INT 1
98819: ARRAY
98820: PUSH
98821: LD_VAR 0 17
98825: PUSH
98826: LD_INT 2
98828: ARRAY
98829: PUSH
98830: LD_VAR 0 17
98834: PUSH
98835: LD_INT 3
98837: ARRAY
98838: PUSH
98839: EMPTY
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: PUSH
98845: EMPTY
98846: LIST
98847: LIST
98848: PPUSH
98849: CALL_OW 72
98853: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
98854: LD_VAR 0 14
98858: PUSH
98859: LD_VAR 0 15
98863: DIFF
98864: IFFALSE 98882
// tmp := tmp diff tmp2 ;
98866: LD_ADDR_VAR 0 14
98870: PUSH
98871: LD_VAR 0 14
98875: PUSH
98876: LD_VAR 0 15
98880: DIFF
98881: ST_TO_ADDR
// end ; if not f_murder then
98882: LD_VAR 0 20
98886: NOT
98887: IFFALSE 98945
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
98889: LD_ADDR_VAR 0 15
98893: PUSH
98894: LD_VAR 0 14
98898: PPUSH
98899: LD_INT 3
98901: PUSH
98902: LD_INT 50
98904: PUSH
98905: EMPTY
98906: LIST
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: PPUSH
98912: CALL_OW 72
98916: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
98917: LD_VAR 0 14
98921: PUSH
98922: LD_VAR 0 15
98926: DIFF
98927: IFFALSE 98945
// tmp := tmp diff tmp2 ;
98929: LD_ADDR_VAR 0 14
98933: PUSH
98934: LD_VAR 0 14
98938: PUSH
98939: LD_VAR 0 15
98943: DIFF
98944: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
98945: LD_ADDR_VAR 0 14
98949: PUSH
98950: LD_VAR 0 4
98954: PUSH
98955: LD_VAR 0 7
98959: ARRAY
98960: PPUSH
98961: LD_VAR 0 14
98965: PPUSH
98966: LD_INT 1
98968: PPUSH
98969: LD_INT 1
98971: PPUSH
98972: CALL 68754 0 4
98976: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
98977: LD_VAR 0 4
98981: PUSH
98982: LD_VAR 0 7
98986: ARRAY
98987: PPUSH
98988: CALL_OW 257
98992: PUSH
98993: LD_INT 1
98995: EQUAL
98996: IFFALSE 99444
// begin if WantPlant ( group [ i ] ) then
98998: LD_VAR 0 4
99002: PUSH
99003: LD_VAR 0 7
99007: ARRAY
99008: PPUSH
99009: CALL 68255 0 1
99013: IFFALSE 99017
// continue ;
99015: GO 97289
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
99017: LD_VAR 0 18
99021: PUSH
99022: LD_VAR 0 4
99026: PUSH
99027: LD_VAR 0 7
99031: ARRAY
99032: PPUSH
99033: CALL_OW 310
99037: NOT
99038: AND
99039: PUSH
99040: LD_VAR 0 14
99044: PUSH
99045: LD_INT 1
99047: ARRAY
99048: PUSH
99049: LD_VAR 0 14
99053: PPUSH
99054: LD_INT 21
99056: PUSH
99057: LD_INT 2
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: PUSH
99064: LD_INT 58
99066: PUSH
99067: EMPTY
99068: LIST
99069: PUSH
99070: EMPTY
99071: LIST
99072: LIST
99073: PPUSH
99074: CALL_OW 72
99078: IN
99079: AND
99080: IFFALSE 99116
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
99082: LD_VAR 0 4
99086: PUSH
99087: LD_VAR 0 7
99091: ARRAY
99092: PPUSH
99093: LD_VAR 0 14
99097: PUSH
99098: LD_INT 1
99100: ARRAY
99101: PPUSH
99102: CALL_OW 120
// attacking := true ;
99106: LD_ADDR_VAR 0 29
99110: PUSH
99111: LD_INT 1
99113: ST_TO_ADDR
// continue ;
99114: GO 97289
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
99116: LD_VAR 0 26
99120: PUSH
99121: LD_VAR 0 4
99125: PUSH
99126: LD_VAR 0 7
99130: ARRAY
99131: PPUSH
99132: CALL_OW 257
99136: PUSH
99137: LD_INT 1
99139: EQUAL
99140: AND
99141: PUSH
99142: LD_VAR 0 4
99146: PUSH
99147: LD_VAR 0 7
99151: ARRAY
99152: PPUSH
99153: CALL_OW 256
99157: PUSH
99158: LD_INT 800
99160: LESS
99161: AND
99162: PUSH
99163: LD_VAR 0 4
99167: PUSH
99168: LD_VAR 0 7
99172: ARRAY
99173: PPUSH
99174: CALL_OW 318
99178: NOT
99179: AND
99180: IFFALSE 99197
// ComCrawl ( group [ i ] ) ;
99182: LD_VAR 0 4
99186: PUSH
99187: LD_VAR 0 7
99191: ARRAY
99192: PPUSH
99193: CALL_OW 137
// if f_mines then
99197: LD_VAR 0 21
99201: IFFALSE 99444
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
99203: LD_VAR 0 14
99207: PUSH
99208: LD_INT 1
99210: ARRAY
99211: PPUSH
99212: CALL_OW 247
99216: PUSH
99217: LD_INT 3
99219: EQUAL
99220: PUSH
99221: LD_VAR 0 14
99225: PUSH
99226: LD_INT 1
99228: ARRAY
99229: PUSH
99230: LD_VAR 0 27
99234: IN
99235: NOT
99236: AND
99237: IFFALSE 99444
// begin x := GetX ( tmp [ 1 ] ) ;
99239: LD_ADDR_VAR 0 10
99243: PUSH
99244: LD_VAR 0 14
99248: PUSH
99249: LD_INT 1
99251: ARRAY
99252: PPUSH
99253: CALL_OW 250
99257: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
99258: LD_ADDR_VAR 0 11
99262: PUSH
99263: LD_VAR 0 14
99267: PUSH
99268: LD_INT 1
99270: ARRAY
99271: PPUSH
99272: CALL_OW 251
99276: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
99277: LD_ADDR_VAR 0 12
99281: PUSH
99282: LD_VAR 0 4
99286: PUSH
99287: LD_VAR 0 7
99291: ARRAY
99292: PPUSH
99293: CALL 95172 0 1
99297: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
99298: LD_VAR 0 4
99302: PUSH
99303: LD_VAR 0 7
99307: ARRAY
99308: PPUSH
99309: LD_VAR 0 10
99313: PPUSH
99314: LD_VAR 0 11
99318: PPUSH
99319: LD_VAR 0 14
99323: PUSH
99324: LD_INT 1
99326: ARRAY
99327: PPUSH
99328: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
99332: LD_VAR 0 4
99336: PUSH
99337: LD_VAR 0 7
99341: ARRAY
99342: PPUSH
99343: LD_VAR 0 10
99347: PPUSH
99348: LD_VAR 0 12
99352: PPUSH
99353: LD_INT 7
99355: PPUSH
99356: CALL_OW 272
99360: PPUSH
99361: LD_VAR 0 11
99365: PPUSH
99366: LD_VAR 0 12
99370: PPUSH
99371: LD_INT 7
99373: PPUSH
99374: CALL_OW 273
99378: PPUSH
99379: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
99383: LD_VAR 0 4
99387: PUSH
99388: LD_VAR 0 7
99392: ARRAY
99393: PPUSH
99394: LD_INT 71
99396: PPUSH
99397: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
99401: LD_ADDR_VAR 0 27
99405: PUSH
99406: LD_VAR 0 27
99410: PPUSH
99411: LD_VAR 0 27
99415: PUSH
99416: LD_INT 1
99418: PLUS
99419: PPUSH
99420: LD_VAR 0 14
99424: PUSH
99425: LD_INT 1
99427: ARRAY
99428: PPUSH
99429: CALL_OW 1
99433: ST_TO_ADDR
// attacking := true ;
99434: LD_ADDR_VAR 0 29
99438: PUSH
99439: LD_INT 1
99441: ST_TO_ADDR
// continue ;
99442: GO 97289
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
99444: LD_VAR 0 4
99448: PUSH
99449: LD_VAR 0 7
99453: ARRAY
99454: PPUSH
99455: CALL_OW 257
99459: PUSH
99460: LD_INT 17
99462: EQUAL
99463: PUSH
99464: LD_VAR 0 4
99468: PUSH
99469: LD_VAR 0 7
99473: ARRAY
99474: PPUSH
99475: CALL_OW 110
99479: PUSH
99480: LD_INT 71
99482: EQUAL
99483: NOT
99484: AND
99485: IFFALSE 99631
// begin attacking := false ;
99487: LD_ADDR_VAR 0 29
99491: PUSH
99492: LD_INT 0
99494: ST_TO_ADDR
// k := 5 ;
99495: LD_ADDR_VAR 0 9
99499: PUSH
99500: LD_INT 5
99502: ST_TO_ADDR
// if tmp < k then
99503: LD_VAR 0 14
99507: PUSH
99508: LD_VAR 0 9
99512: LESS
99513: IFFALSE 99525
// k := tmp ;
99515: LD_ADDR_VAR 0 9
99519: PUSH
99520: LD_VAR 0 14
99524: ST_TO_ADDR
// for j = 1 to k do
99525: LD_ADDR_VAR 0 8
99529: PUSH
99530: DOUBLE
99531: LD_INT 1
99533: DEC
99534: ST_TO_ADDR
99535: LD_VAR 0 9
99539: PUSH
99540: FOR_TO
99541: IFFALSE 99629
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
99543: LD_VAR 0 14
99547: PUSH
99548: LD_VAR 0 8
99552: ARRAY
99553: PUSH
99554: LD_VAR 0 14
99558: PPUSH
99559: LD_INT 58
99561: PUSH
99562: EMPTY
99563: LIST
99564: PPUSH
99565: CALL_OW 72
99569: IN
99570: NOT
99571: IFFALSE 99627
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99573: LD_VAR 0 4
99577: PUSH
99578: LD_VAR 0 7
99582: ARRAY
99583: PPUSH
99584: LD_VAR 0 14
99588: PUSH
99589: LD_VAR 0 8
99593: ARRAY
99594: PPUSH
99595: CALL_OW 115
// attacking := true ;
99599: LD_ADDR_VAR 0 29
99603: PUSH
99604: LD_INT 1
99606: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
99607: LD_VAR 0 4
99611: PUSH
99612: LD_VAR 0 7
99616: ARRAY
99617: PPUSH
99618: LD_INT 71
99620: PPUSH
99621: CALL_OW 109
// continue ;
99625: GO 99540
// end ; end ;
99627: GO 99540
99629: POP
99630: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
99631: LD_VAR 0 4
99635: PUSH
99636: LD_VAR 0 7
99640: ARRAY
99641: PPUSH
99642: CALL_OW 257
99646: PUSH
99647: LD_INT 8
99649: EQUAL
99650: PUSH
99651: LD_VAR 0 4
99655: PUSH
99656: LD_VAR 0 7
99660: ARRAY
99661: PPUSH
99662: CALL_OW 264
99666: PUSH
99667: LD_INT 28
99669: PUSH
99670: LD_INT 45
99672: PUSH
99673: LD_INT 7
99675: PUSH
99676: LD_INT 47
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: LIST
99683: LIST
99684: IN
99685: OR
99686: IFFALSE 99916
// begin attacking := false ;
99688: LD_ADDR_VAR 0 29
99692: PUSH
99693: LD_INT 0
99695: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
99696: LD_VAR 0 14
99700: PUSH
99701: LD_INT 1
99703: ARRAY
99704: PPUSH
99705: CALL_OW 266
99709: PUSH
99710: LD_INT 32
99712: PUSH
99713: LD_INT 31
99715: PUSH
99716: LD_INT 33
99718: PUSH
99719: LD_INT 4
99721: PUSH
99722: LD_INT 5
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: LIST
99729: LIST
99730: LIST
99731: IN
99732: IFFALSE 99916
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
99734: LD_ADDR_VAR 0 9
99738: PUSH
99739: LD_VAR 0 14
99743: PUSH
99744: LD_INT 1
99746: ARRAY
99747: PPUSH
99748: CALL_OW 266
99752: PPUSH
99753: LD_VAR 0 14
99757: PUSH
99758: LD_INT 1
99760: ARRAY
99761: PPUSH
99762: CALL_OW 250
99766: PPUSH
99767: LD_VAR 0 14
99771: PUSH
99772: LD_INT 1
99774: ARRAY
99775: PPUSH
99776: CALL_OW 251
99780: PPUSH
99781: LD_VAR 0 14
99785: PUSH
99786: LD_INT 1
99788: ARRAY
99789: PPUSH
99790: CALL_OW 254
99794: PPUSH
99795: LD_VAR 0 14
99799: PUSH
99800: LD_INT 1
99802: ARRAY
99803: PPUSH
99804: CALL_OW 248
99808: PPUSH
99809: LD_INT 0
99811: PPUSH
99812: CALL 76548 0 6
99816: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
99817: LD_ADDR_VAR 0 8
99821: PUSH
99822: LD_VAR 0 4
99826: PUSH
99827: LD_VAR 0 7
99831: ARRAY
99832: PPUSH
99833: LD_VAR 0 9
99837: PPUSH
99838: CALL 95235 0 2
99842: ST_TO_ADDR
// if j then
99843: LD_VAR 0 8
99847: IFFALSE 99916
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
99849: LD_VAR 0 8
99853: PUSH
99854: LD_INT 1
99856: ARRAY
99857: PPUSH
99858: LD_VAR 0 8
99862: PUSH
99863: LD_INT 2
99865: ARRAY
99866: PPUSH
99867: CALL_OW 488
99871: IFFALSE 99916
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
99873: LD_VAR 0 4
99877: PUSH
99878: LD_VAR 0 7
99882: ARRAY
99883: PPUSH
99884: LD_VAR 0 8
99888: PUSH
99889: LD_INT 1
99891: ARRAY
99892: PPUSH
99893: LD_VAR 0 8
99897: PUSH
99898: LD_INT 2
99900: ARRAY
99901: PPUSH
99902: CALL_OW 116
// attacking := true ;
99906: LD_ADDR_VAR 0 29
99910: PUSH
99911: LD_INT 1
99913: ST_TO_ADDR
// continue ;
99914: GO 97289
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
99916: LD_VAR 0 4
99920: PUSH
99921: LD_VAR 0 7
99925: ARRAY
99926: PPUSH
99927: CALL_OW 265
99931: PUSH
99932: LD_INT 11
99934: EQUAL
99935: IFFALSE 100213
// begin k := 10 ;
99937: LD_ADDR_VAR 0 9
99941: PUSH
99942: LD_INT 10
99944: ST_TO_ADDR
// x := 0 ;
99945: LD_ADDR_VAR 0 10
99949: PUSH
99950: LD_INT 0
99952: ST_TO_ADDR
// if tmp < k then
99953: LD_VAR 0 14
99957: PUSH
99958: LD_VAR 0 9
99962: LESS
99963: IFFALSE 99975
// k := tmp ;
99965: LD_ADDR_VAR 0 9
99969: PUSH
99970: LD_VAR 0 14
99974: ST_TO_ADDR
// for j = k downto 1 do
99975: LD_ADDR_VAR 0 8
99979: PUSH
99980: DOUBLE
99981: LD_VAR 0 9
99985: INC
99986: ST_TO_ADDR
99987: LD_INT 1
99989: PUSH
99990: FOR_DOWNTO
99991: IFFALSE 100066
// begin if GetType ( tmp [ j ] ) = unit_human then
99993: LD_VAR 0 14
99997: PUSH
99998: LD_VAR 0 8
100002: ARRAY
100003: PPUSH
100004: CALL_OW 247
100008: PUSH
100009: LD_INT 1
100011: EQUAL
100012: IFFALSE 100064
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
100014: LD_VAR 0 4
100018: PUSH
100019: LD_VAR 0 7
100023: ARRAY
100024: PPUSH
100025: LD_VAR 0 14
100029: PUSH
100030: LD_VAR 0 8
100034: ARRAY
100035: PPUSH
100036: CALL 95506 0 2
// x := tmp [ j ] ;
100040: LD_ADDR_VAR 0 10
100044: PUSH
100045: LD_VAR 0 14
100049: PUSH
100050: LD_VAR 0 8
100054: ARRAY
100055: ST_TO_ADDR
// attacking := true ;
100056: LD_ADDR_VAR 0 29
100060: PUSH
100061: LD_INT 1
100063: ST_TO_ADDR
// end ; end ;
100064: GO 99990
100066: POP
100067: POP
// if not x then
100068: LD_VAR 0 10
100072: NOT
100073: IFFALSE 100213
// begin attacking := true ;
100075: LD_ADDR_VAR 0 29
100079: PUSH
100080: LD_INT 1
100082: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
100083: LD_VAR 0 4
100087: PUSH
100088: LD_VAR 0 7
100092: ARRAY
100093: PPUSH
100094: CALL_OW 250
100098: PPUSH
100099: LD_VAR 0 4
100103: PUSH
100104: LD_VAR 0 7
100108: ARRAY
100109: PPUSH
100110: CALL_OW 251
100114: PPUSH
100115: CALL_OW 546
100119: PUSH
100120: LD_INT 2
100122: ARRAY
100123: PUSH
100124: LD_VAR 0 14
100128: PUSH
100129: LD_INT 1
100131: ARRAY
100132: PPUSH
100133: CALL_OW 250
100137: PPUSH
100138: LD_VAR 0 14
100142: PUSH
100143: LD_INT 1
100145: ARRAY
100146: PPUSH
100147: CALL_OW 251
100151: PPUSH
100152: CALL_OW 546
100156: PUSH
100157: LD_INT 2
100159: ARRAY
100160: EQUAL
100161: IFFALSE 100189
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
100163: LD_VAR 0 4
100167: PUSH
100168: LD_VAR 0 7
100172: ARRAY
100173: PPUSH
100174: LD_VAR 0 14
100178: PUSH
100179: LD_INT 1
100181: ARRAY
100182: PPUSH
100183: CALL 95506 0 2
100187: GO 100213
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100189: LD_VAR 0 4
100193: PUSH
100194: LD_VAR 0 7
100198: ARRAY
100199: PPUSH
100200: LD_VAR 0 14
100204: PUSH
100205: LD_INT 1
100207: ARRAY
100208: PPUSH
100209: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
100213: LD_VAR 0 4
100217: PUSH
100218: LD_VAR 0 7
100222: ARRAY
100223: PPUSH
100224: CALL_OW 264
100228: PUSH
100229: LD_INT 29
100231: EQUAL
100232: IFFALSE 100598
// begin if WantsToAttack ( group [ i ] ) in bombed then
100234: LD_VAR 0 4
100238: PUSH
100239: LD_VAR 0 7
100243: ARRAY
100244: PPUSH
100245: CALL_OW 319
100249: PUSH
100250: LD_VAR 0 28
100254: IN
100255: IFFALSE 100259
// continue ;
100257: GO 97289
// k := 8 ;
100259: LD_ADDR_VAR 0 9
100263: PUSH
100264: LD_INT 8
100266: ST_TO_ADDR
// x := 0 ;
100267: LD_ADDR_VAR 0 10
100271: PUSH
100272: LD_INT 0
100274: ST_TO_ADDR
// if tmp < k then
100275: LD_VAR 0 14
100279: PUSH
100280: LD_VAR 0 9
100284: LESS
100285: IFFALSE 100297
// k := tmp ;
100287: LD_ADDR_VAR 0 9
100291: PUSH
100292: LD_VAR 0 14
100296: ST_TO_ADDR
// for j = 1 to k do
100297: LD_ADDR_VAR 0 8
100301: PUSH
100302: DOUBLE
100303: LD_INT 1
100305: DEC
100306: ST_TO_ADDR
100307: LD_VAR 0 9
100311: PUSH
100312: FOR_TO
100313: IFFALSE 100445
// begin if GetType ( tmp [ j ] ) = unit_building then
100315: LD_VAR 0 14
100319: PUSH
100320: LD_VAR 0 8
100324: ARRAY
100325: PPUSH
100326: CALL_OW 247
100330: PUSH
100331: LD_INT 3
100333: EQUAL
100334: IFFALSE 100443
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
100336: LD_VAR 0 14
100340: PUSH
100341: LD_VAR 0 8
100345: ARRAY
100346: PUSH
100347: LD_VAR 0 28
100351: IN
100352: NOT
100353: PUSH
100354: LD_VAR 0 14
100358: PUSH
100359: LD_VAR 0 8
100363: ARRAY
100364: PPUSH
100365: CALL_OW 313
100369: AND
100370: IFFALSE 100443
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100372: LD_VAR 0 4
100376: PUSH
100377: LD_VAR 0 7
100381: ARRAY
100382: PPUSH
100383: LD_VAR 0 14
100387: PUSH
100388: LD_VAR 0 8
100392: ARRAY
100393: PPUSH
100394: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
100398: LD_ADDR_VAR 0 28
100402: PUSH
100403: LD_VAR 0 28
100407: PPUSH
100408: LD_VAR 0 28
100412: PUSH
100413: LD_INT 1
100415: PLUS
100416: PPUSH
100417: LD_VAR 0 14
100421: PUSH
100422: LD_VAR 0 8
100426: ARRAY
100427: PPUSH
100428: CALL_OW 1
100432: ST_TO_ADDR
// attacking := true ;
100433: LD_ADDR_VAR 0 29
100437: PUSH
100438: LD_INT 1
100440: ST_TO_ADDR
// break ;
100441: GO 100445
// end ; end ;
100443: GO 100312
100445: POP
100446: POP
// if not attacking and f_attack_depot then
100447: LD_VAR 0 29
100451: NOT
100452: PUSH
100453: LD_VAR 0 25
100457: AND
100458: IFFALSE 100553
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100460: LD_ADDR_VAR 0 13
100464: PUSH
100465: LD_VAR 0 14
100469: PPUSH
100470: LD_INT 2
100472: PUSH
100473: LD_INT 30
100475: PUSH
100476: LD_INT 0
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PUSH
100483: LD_INT 30
100485: PUSH
100486: LD_INT 1
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: LIST
100497: PPUSH
100498: CALL_OW 72
100502: ST_TO_ADDR
// if z then
100503: LD_VAR 0 13
100507: IFFALSE 100553
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
100509: LD_VAR 0 4
100513: PUSH
100514: LD_VAR 0 7
100518: ARRAY
100519: PPUSH
100520: LD_VAR 0 13
100524: PPUSH
100525: LD_VAR 0 4
100529: PUSH
100530: LD_VAR 0 7
100534: ARRAY
100535: PPUSH
100536: CALL_OW 74
100540: PPUSH
100541: CALL_OW 115
// attacking := true ;
100545: LD_ADDR_VAR 0 29
100549: PUSH
100550: LD_INT 1
100552: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
100553: LD_VAR 0 4
100557: PUSH
100558: LD_VAR 0 7
100562: ARRAY
100563: PPUSH
100564: CALL_OW 256
100568: PUSH
100569: LD_INT 500
100571: LESS
100572: IFFALSE 100598
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100574: LD_VAR 0 4
100578: PUSH
100579: LD_VAR 0 7
100583: ARRAY
100584: PPUSH
100585: LD_VAR 0 14
100589: PUSH
100590: LD_INT 1
100592: ARRAY
100593: PPUSH
100594: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
100598: LD_VAR 0 4
100602: PUSH
100603: LD_VAR 0 7
100607: ARRAY
100608: PPUSH
100609: CALL_OW 264
100613: PUSH
100614: LD_INT 49
100616: EQUAL
100617: IFFALSE 100738
// begin if not HasTask ( group [ i ] ) then
100619: LD_VAR 0 4
100623: PUSH
100624: LD_VAR 0 7
100628: ARRAY
100629: PPUSH
100630: CALL_OW 314
100634: NOT
100635: IFFALSE 100738
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
100637: LD_ADDR_VAR 0 9
100641: PUSH
100642: LD_INT 81
100644: PUSH
100645: LD_VAR 0 4
100649: PUSH
100650: LD_VAR 0 7
100654: ARRAY
100655: PPUSH
100656: CALL_OW 255
100660: PUSH
100661: EMPTY
100662: LIST
100663: LIST
100664: PPUSH
100665: CALL_OW 69
100669: PPUSH
100670: LD_VAR 0 4
100674: PUSH
100675: LD_VAR 0 7
100679: ARRAY
100680: PPUSH
100681: CALL_OW 74
100685: ST_TO_ADDR
// if k then
100686: LD_VAR 0 9
100690: IFFALSE 100738
// if GetDistUnits ( group [ i ] , k ) > 10 then
100692: LD_VAR 0 4
100696: PUSH
100697: LD_VAR 0 7
100701: ARRAY
100702: PPUSH
100703: LD_VAR 0 9
100707: PPUSH
100708: CALL_OW 296
100712: PUSH
100713: LD_INT 10
100715: GREATER
100716: IFFALSE 100738
// ComMoveUnit ( group [ i ] , k ) ;
100718: LD_VAR 0 4
100722: PUSH
100723: LD_VAR 0 7
100727: ARRAY
100728: PPUSH
100729: LD_VAR 0 9
100733: PPUSH
100734: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100738: LD_VAR 0 4
100742: PUSH
100743: LD_VAR 0 7
100747: ARRAY
100748: PPUSH
100749: CALL_OW 256
100753: PUSH
100754: LD_INT 250
100756: LESS
100757: PUSH
100758: LD_VAR 0 4
100762: PUSH
100763: LD_VAR 0 7
100767: ARRAY
100768: PUSH
100769: LD_INT 21
100771: PUSH
100772: LD_INT 2
100774: PUSH
100775: EMPTY
100776: LIST
100777: LIST
100778: PUSH
100779: LD_INT 23
100781: PUSH
100782: LD_INT 2
100784: PUSH
100785: EMPTY
100786: LIST
100787: LIST
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PPUSH
100793: CALL_OW 69
100797: IN
100798: AND
100799: IFFALSE 100924
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
100801: LD_ADDR_VAR 0 9
100805: PUSH
100806: LD_OWVAR 3
100810: PUSH
100811: LD_VAR 0 4
100815: PUSH
100816: LD_VAR 0 7
100820: ARRAY
100821: DIFF
100822: PPUSH
100823: LD_VAR 0 4
100827: PUSH
100828: LD_VAR 0 7
100832: ARRAY
100833: PPUSH
100834: CALL_OW 74
100838: ST_TO_ADDR
// if not k then
100839: LD_VAR 0 9
100843: NOT
100844: IFFALSE 100848
// continue ;
100846: GO 97289
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
100848: LD_VAR 0 9
100852: PUSH
100853: LD_INT 81
100855: PUSH
100856: LD_VAR 0 4
100860: PUSH
100861: LD_VAR 0 7
100865: ARRAY
100866: PPUSH
100867: CALL_OW 255
100871: PUSH
100872: EMPTY
100873: LIST
100874: LIST
100875: PPUSH
100876: CALL_OW 69
100880: IN
100881: PUSH
100882: LD_VAR 0 9
100886: PPUSH
100887: LD_VAR 0 4
100891: PUSH
100892: LD_VAR 0 7
100896: ARRAY
100897: PPUSH
100898: CALL_OW 296
100902: PUSH
100903: LD_INT 5
100905: LESS
100906: AND
100907: IFFALSE 100924
// ComAutodestruct ( group [ i ] ) ;
100909: LD_VAR 0 4
100913: PUSH
100914: LD_VAR 0 7
100918: ARRAY
100919: PPUSH
100920: CALL 95404 0 1
// end ; if f_attack_depot then
100924: LD_VAR 0 25
100928: IFFALSE 101040
// begin k := 6 ;
100930: LD_ADDR_VAR 0 9
100934: PUSH
100935: LD_INT 6
100937: ST_TO_ADDR
// if tmp < k then
100938: LD_VAR 0 14
100942: PUSH
100943: LD_VAR 0 9
100947: LESS
100948: IFFALSE 100960
// k := tmp ;
100950: LD_ADDR_VAR 0 9
100954: PUSH
100955: LD_VAR 0 14
100959: ST_TO_ADDR
// for j = 1 to k do
100960: LD_ADDR_VAR 0 8
100964: PUSH
100965: DOUBLE
100966: LD_INT 1
100968: DEC
100969: ST_TO_ADDR
100970: LD_VAR 0 9
100974: PUSH
100975: FOR_TO
100976: IFFALSE 101038
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
100978: LD_VAR 0 8
100982: PPUSH
100983: CALL_OW 266
100987: PUSH
100988: LD_INT 0
100990: PUSH
100991: LD_INT 1
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: IN
100998: IFFALSE 101036
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101000: LD_VAR 0 4
101004: PUSH
101005: LD_VAR 0 7
101009: ARRAY
101010: PPUSH
101011: LD_VAR 0 14
101015: PUSH
101016: LD_VAR 0 8
101020: ARRAY
101021: PPUSH
101022: CALL_OW 115
// attacking := true ;
101026: LD_ADDR_VAR 0 29
101030: PUSH
101031: LD_INT 1
101033: ST_TO_ADDR
// break ;
101034: GO 101038
// end ;
101036: GO 100975
101038: POP
101039: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
101040: LD_VAR 0 4
101044: PUSH
101045: LD_VAR 0 7
101049: ARRAY
101050: PPUSH
101051: CALL_OW 302
101055: PUSH
101056: LD_VAR 0 29
101060: NOT
101061: AND
101062: IFFALSE 101384
// begin if GetTag ( group [ i ] ) = 71 then
101064: LD_VAR 0 4
101068: PUSH
101069: LD_VAR 0 7
101073: ARRAY
101074: PPUSH
101075: CALL_OW 110
101079: PUSH
101080: LD_INT 71
101082: EQUAL
101083: IFFALSE 101124
// begin if HasTask ( group [ i ] ) then
101085: LD_VAR 0 4
101089: PUSH
101090: LD_VAR 0 7
101094: ARRAY
101095: PPUSH
101096: CALL_OW 314
101100: IFFALSE 101106
// continue else
101102: GO 97289
101104: GO 101124
// SetTag ( group [ i ] , 0 ) ;
101106: LD_VAR 0 4
101110: PUSH
101111: LD_VAR 0 7
101115: ARRAY
101116: PPUSH
101117: LD_INT 0
101119: PPUSH
101120: CALL_OW 109
// end ; k := 8 ;
101124: LD_ADDR_VAR 0 9
101128: PUSH
101129: LD_INT 8
101131: ST_TO_ADDR
// x := 0 ;
101132: LD_ADDR_VAR 0 10
101136: PUSH
101137: LD_INT 0
101139: ST_TO_ADDR
// if tmp < k then
101140: LD_VAR 0 14
101144: PUSH
101145: LD_VAR 0 9
101149: LESS
101150: IFFALSE 101162
// k := tmp ;
101152: LD_ADDR_VAR 0 9
101156: PUSH
101157: LD_VAR 0 14
101161: ST_TO_ADDR
// for j = 1 to k do
101162: LD_ADDR_VAR 0 8
101166: PUSH
101167: DOUBLE
101168: LD_INT 1
101170: DEC
101171: ST_TO_ADDR
101172: LD_VAR 0 9
101176: PUSH
101177: FOR_TO
101178: IFFALSE 101276
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
101180: LD_VAR 0 14
101184: PUSH
101185: LD_VAR 0 8
101189: ARRAY
101190: PPUSH
101191: CALL_OW 247
101195: PUSH
101196: LD_INT 1
101198: EQUAL
101199: PUSH
101200: LD_VAR 0 14
101204: PUSH
101205: LD_VAR 0 8
101209: ARRAY
101210: PPUSH
101211: CALL_OW 256
101215: PUSH
101216: LD_INT 250
101218: LESS
101219: PUSH
101220: LD_VAR 0 20
101224: AND
101225: PUSH
101226: LD_VAR 0 20
101230: NOT
101231: PUSH
101232: LD_VAR 0 14
101236: PUSH
101237: LD_VAR 0 8
101241: ARRAY
101242: PPUSH
101243: CALL_OW 256
101247: PUSH
101248: LD_INT 250
101250: GREATEREQUAL
101251: AND
101252: OR
101253: AND
101254: IFFALSE 101274
// begin x := tmp [ j ] ;
101256: LD_ADDR_VAR 0 10
101260: PUSH
101261: LD_VAR 0 14
101265: PUSH
101266: LD_VAR 0 8
101270: ARRAY
101271: ST_TO_ADDR
// break ;
101272: GO 101276
// end ;
101274: GO 101177
101276: POP
101277: POP
// if x then
101278: LD_VAR 0 10
101282: IFFALSE 101306
// ComAttackUnit ( group [ i ] , x ) else
101284: LD_VAR 0 4
101288: PUSH
101289: LD_VAR 0 7
101293: ARRAY
101294: PPUSH
101295: LD_VAR 0 10
101299: PPUSH
101300: CALL_OW 115
101304: GO 101330
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101306: LD_VAR 0 4
101310: PUSH
101311: LD_VAR 0 7
101315: ARRAY
101316: PPUSH
101317: LD_VAR 0 14
101321: PUSH
101322: LD_INT 1
101324: ARRAY
101325: PPUSH
101326: CALL_OW 115
// if not HasTask ( group [ i ] ) then
101330: LD_VAR 0 4
101334: PUSH
101335: LD_VAR 0 7
101339: ARRAY
101340: PPUSH
101341: CALL_OW 314
101345: NOT
101346: IFFALSE 101384
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
101348: LD_VAR 0 4
101352: PUSH
101353: LD_VAR 0 7
101357: ARRAY
101358: PPUSH
101359: LD_VAR 0 14
101363: PPUSH
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 7
101373: ARRAY
101374: PPUSH
101375: CALL_OW 74
101379: PPUSH
101380: CALL_OW 115
// end ; end ; end ;
101384: GO 97289
101386: POP
101387: POP
// wait ( 0 0$1 ) ;
101388: LD_INT 35
101390: PPUSH
101391: CALL_OW 67
// until group = [ ] ;
101395: LD_VAR 0 4
101399: PUSH
101400: EMPTY
101401: EQUAL
101402: IFFALSE 97274
// end ;
101404: LD_VAR 0 2
101408: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
101409: LD_INT 0
101411: PPUSH
101412: PPUSH
101413: PPUSH
101414: PPUSH
// if not base_units then
101415: LD_VAR 0 1
101419: NOT
101420: IFFALSE 101424
// exit ;
101422: GO 101511
// result := false ;
101424: LD_ADDR_VAR 0 2
101428: PUSH
101429: LD_INT 0
101431: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
101432: LD_ADDR_VAR 0 5
101436: PUSH
101437: LD_VAR 0 1
101441: PPUSH
101442: LD_INT 21
101444: PUSH
101445: LD_INT 3
101447: PUSH
101448: EMPTY
101449: LIST
101450: LIST
101451: PPUSH
101452: CALL_OW 72
101456: ST_TO_ADDR
// if not tmp then
101457: LD_VAR 0 5
101461: NOT
101462: IFFALSE 101466
// exit ;
101464: GO 101511
// for i in tmp do
101466: LD_ADDR_VAR 0 3
101470: PUSH
101471: LD_VAR 0 5
101475: PUSH
101476: FOR_IN
101477: IFFALSE 101509
// begin result := EnemyInRange ( i , 22 ) ;
101479: LD_ADDR_VAR 0 2
101483: PUSH
101484: LD_VAR 0 3
101488: PPUSH
101489: LD_INT 22
101491: PPUSH
101492: CALL 95087 0 2
101496: ST_TO_ADDR
// if result then
101497: LD_VAR 0 2
101501: IFFALSE 101507
// exit ;
101503: POP
101504: POP
101505: GO 101511
// end ;
101507: GO 101476
101509: POP
101510: POP
// end ;
101511: LD_VAR 0 2
101515: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
101516: LD_INT 0
101518: PPUSH
101519: PPUSH
// if not units then
101520: LD_VAR 0 1
101524: NOT
101525: IFFALSE 101529
// exit ;
101527: GO 101599
// result := [ ] ;
101529: LD_ADDR_VAR 0 3
101533: PUSH
101534: EMPTY
101535: ST_TO_ADDR
// for i in units do
101536: LD_ADDR_VAR 0 4
101540: PUSH
101541: LD_VAR 0 1
101545: PUSH
101546: FOR_IN
101547: IFFALSE 101597
// if GetTag ( i ) = tag then
101549: LD_VAR 0 4
101553: PPUSH
101554: CALL_OW 110
101558: PUSH
101559: LD_VAR 0 2
101563: EQUAL
101564: IFFALSE 101595
// result := Insert ( result , result + 1 , i ) ;
101566: LD_ADDR_VAR 0 3
101570: PUSH
101571: LD_VAR 0 3
101575: PPUSH
101576: LD_VAR 0 3
101580: PUSH
101581: LD_INT 1
101583: PLUS
101584: PPUSH
101585: LD_VAR 0 4
101589: PPUSH
101590: CALL_OW 2
101594: ST_TO_ADDR
101595: GO 101546
101597: POP
101598: POP
// end ;
101599: LD_VAR 0 3
101603: RET
// export function IsDriver ( un ) ; begin
101604: LD_INT 0
101606: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
101607: LD_ADDR_VAR 0 2
101611: PUSH
101612: LD_VAR 0 1
101616: PUSH
101617: LD_INT 55
101619: PUSH
101620: EMPTY
101621: LIST
101622: PPUSH
101623: CALL_OW 69
101627: IN
101628: ST_TO_ADDR
// end ;
101629: LD_VAR 0 2
101633: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
101634: LD_INT 0
101636: PPUSH
101637: PPUSH
// list := [ ] ;
101638: LD_ADDR_VAR 0 5
101642: PUSH
101643: EMPTY
101644: ST_TO_ADDR
// case d of 0 :
101645: LD_VAR 0 3
101649: PUSH
101650: LD_INT 0
101652: DOUBLE
101653: EQUAL
101654: IFTRUE 101658
101656: GO 101791
101658: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
101659: LD_ADDR_VAR 0 5
101663: PUSH
101664: LD_VAR 0 1
101668: PUSH
101669: LD_INT 4
101671: MINUS
101672: PUSH
101673: LD_VAR 0 2
101677: PUSH
101678: LD_INT 4
101680: MINUS
101681: PUSH
101682: LD_INT 2
101684: PUSH
101685: EMPTY
101686: LIST
101687: LIST
101688: LIST
101689: PUSH
101690: LD_VAR 0 1
101694: PUSH
101695: LD_INT 3
101697: MINUS
101698: PUSH
101699: LD_VAR 0 2
101703: PUSH
101704: LD_INT 1
101706: PUSH
101707: EMPTY
101708: LIST
101709: LIST
101710: LIST
101711: PUSH
101712: LD_VAR 0 1
101716: PUSH
101717: LD_INT 4
101719: PLUS
101720: PUSH
101721: LD_VAR 0 2
101725: PUSH
101726: LD_INT 4
101728: PUSH
101729: EMPTY
101730: LIST
101731: LIST
101732: LIST
101733: PUSH
101734: LD_VAR 0 1
101738: PUSH
101739: LD_INT 3
101741: PLUS
101742: PUSH
101743: LD_VAR 0 2
101747: PUSH
101748: LD_INT 3
101750: PLUS
101751: PUSH
101752: LD_INT 5
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: LIST
101759: PUSH
101760: LD_VAR 0 1
101764: PUSH
101765: LD_VAR 0 2
101769: PUSH
101770: LD_INT 4
101772: PLUS
101773: PUSH
101774: LD_INT 0
101776: PUSH
101777: EMPTY
101778: LIST
101779: LIST
101780: LIST
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: LIST
101786: LIST
101787: LIST
101788: ST_TO_ADDR
// end ; 1 :
101789: GO 102489
101791: LD_INT 1
101793: DOUBLE
101794: EQUAL
101795: IFTRUE 101799
101797: GO 101932
101799: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
101800: LD_ADDR_VAR 0 5
101804: PUSH
101805: LD_VAR 0 1
101809: PUSH
101810: LD_VAR 0 2
101814: PUSH
101815: LD_INT 4
101817: MINUS
101818: PUSH
101819: LD_INT 3
101821: PUSH
101822: EMPTY
101823: LIST
101824: LIST
101825: LIST
101826: PUSH
101827: LD_VAR 0 1
101831: PUSH
101832: LD_INT 3
101834: MINUS
101835: PUSH
101836: LD_VAR 0 2
101840: PUSH
101841: LD_INT 3
101843: MINUS
101844: PUSH
101845: LD_INT 2
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: LIST
101852: PUSH
101853: LD_VAR 0 1
101857: PUSH
101858: LD_INT 4
101860: MINUS
101861: PUSH
101862: LD_VAR 0 2
101866: PUSH
101867: LD_INT 1
101869: PUSH
101870: EMPTY
101871: LIST
101872: LIST
101873: LIST
101874: PUSH
101875: LD_VAR 0 1
101879: PUSH
101880: LD_VAR 0 2
101884: PUSH
101885: LD_INT 3
101887: PLUS
101888: PUSH
101889: LD_INT 0
101891: PUSH
101892: EMPTY
101893: LIST
101894: LIST
101895: LIST
101896: PUSH
101897: LD_VAR 0 1
101901: PUSH
101902: LD_INT 4
101904: PLUS
101905: PUSH
101906: LD_VAR 0 2
101910: PUSH
101911: LD_INT 4
101913: PLUS
101914: PUSH
101915: LD_INT 5
101917: PUSH
101918: EMPTY
101919: LIST
101920: LIST
101921: LIST
101922: PUSH
101923: EMPTY
101924: LIST
101925: LIST
101926: LIST
101927: LIST
101928: LIST
101929: ST_TO_ADDR
// end ; 2 :
101930: GO 102489
101932: LD_INT 2
101934: DOUBLE
101935: EQUAL
101936: IFTRUE 101940
101938: GO 102069
101940: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
101941: LD_ADDR_VAR 0 5
101945: PUSH
101946: LD_VAR 0 1
101950: PUSH
101951: LD_VAR 0 2
101955: PUSH
101956: LD_INT 3
101958: MINUS
101959: PUSH
101960: LD_INT 3
101962: PUSH
101963: EMPTY
101964: LIST
101965: LIST
101966: LIST
101967: PUSH
101968: LD_VAR 0 1
101972: PUSH
101973: LD_INT 4
101975: PLUS
101976: PUSH
101977: LD_VAR 0 2
101981: PUSH
101982: LD_INT 4
101984: PUSH
101985: EMPTY
101986: LIST
101987: LIST
101988: LIST
101989: PUSH
101990: LD_VAR 0 1
101994: PUSH
101995: LD_VAR 0 2
101999: PUSH
102000: LD_INT 4
102002: PLUS
102003: PUSH
102004: LD_INT 0
102006: PUSH
102007: EMPTY
102008: LIST
102009: LIST
102010: LIST
102011: PUSH
102012: LD_VAR 0 1
102016: PUSH
102017: LD_INT 3
102019: MINUS
102020: PUSH
102021: LD_VAR 0 2
102025: PUSH
102026: LD_INT 1
102028: PUSH
102029: EMPTY
102030: LIST
102031: LIST
102032: LIST
102033: PUSH
102034: LD_VAR 0 1
102038: PUSH
102039: LD_INT 4
102041: MINUS
102042: PUSH
102043: LD_VAR 0 2
102047: PUSH
102048: LD_INT 4
102050: MINUS
102051: PUSH
102052: LD_INT 2
102054: PUSH
102055: EMPTY
102056: LIST
102057: LIST
102058: LIST
102059: PUSH
102060: EMPTY
102061: LIST
102062: LIST
102063: LIST
102064: LIST
102065: LIST
102066: ST_TO_ADDR
// end ; 3 :
102067: GO 102489
102069: LD_INT 3
102071: DOUBLE
102072: EQUAL
102073: IFTRUE 102077
102075: GO 102210
102077: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102078: LD_ADDR_VAR 0 5
102082: PUSH
102083: LD_VAR 0 1
102087: PUSH
102088: LD_INT 3
102090: PLUS
102091: PUSH
102092: LD_VAR 0 2
102096: PUSH
102097: LD_INT 4
102099: PUSH
102100: EMPTY
102101: LIST
102102: LIST
102103: LIST
102104: PUSH
102105: LD_VAR 0 1
102109: PUSH
102110: LD_INT 4
102112: PLUS
102113: PUSH
102114: LD_VAR 0 2
102118: PUSH
102119: LD_INT 4
102121: PLUS
102122: PUSH
102123: LD_INT 5
102125: PUSH
102126: EMPTY
102127: LIST
102128: LIST
102129: LIST
102130: PUSH
102131: LD_VAR 0 1
102135: PUSH
102136: LD_INT 4
102138: MINUS
102139: PUSH
102140: LD_VAR 0 2
102144: PUSH
102145: LD_INT 1
102147: PUSH
102148: EMPTY
102149: LIST
102150: LIST
102151: LIST
102152: PUSH
102153: LD_VAR 0 1
102157: PUSH
102158: LD_VAR 0 2
102162: PUSH
102163: LD_INT 4
102165: MINUS
102166: PUSH
102167: LD_INT 3
102169: PUSH
102170: EMPTY
102171: LIST
102172: LIST
102173: LIST
102174: PUSH
102175: LD_VAR 0 1
102179: PUSH
102180: LD_INT 3
102182: MINUS
102183: PUSH
102184: LD_VAR 0 2
102188: PUSH
102189: LD_INT 3
102191: MINUS
102192: PUSH
102193: LD_INT 2
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: LIST
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: LIST
102207: ST_TO_ADDR
// end ; 4 :
102208: GO 102489
102210: LD_INT 4
102212: DOUBLE
102213: EQUAL
102214: IFTRUE 102218
102216: GO 102351
102218: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
102219: LD_ADDR_VAR 0 5
102223: PUSH
102224: LD_VAR 0 1
102228: PUSH
102229: LD_VAR 0 2
102233: PUSH
102234: LD_INT 4
102236: PLUS
102237: PUSH
102238: LD_INT 0
102240: PUSH
102241: EMPTY
102242: LIST
102243: LIST
102244: LIST
102245: PUSH
102246: LD_VAR 0 1
102250: PUSH
102251: LD_INT 3
102253: PLUS
102254: PUSH
102255: LD_VAR 0 2
102259: PUSH
102260: LD_INT 3
102262: PLUS
102263: PUSH
102264: LD_INT 5
102266: PUSH
102267: EMPTY
102268: LIST
102269: LIST
102270: LIST
102271: PUSH
102272: LD_VAR 0 1
102276: PUSH
102277: LD_INT 4
102279: PLUS
102280: PUSH
102281: LD_VAR 0 2
102285: PUSH
102286: LD_INT 4
102288: PUSH
102289: EMPTY
102290: LIST
102291: LIST
102292: LIST
102293: PUSH
102294: LD_VAR 0 1
102298: PUSH
102299: LD_VAR 0 2
102303: PUSH
102304: LD_INT 3
102306: MINUS
102307: PUSH
102308: LD_INT 3
102310: PUSH
102311: EMPTY
102312: LIST
102313: LIST
102314: LIST
102315: PUSH
102316: LD_VAR 0 1
102320: PUSH
102321: LD_INT 4
102323: MINUS
102324: PUSH
102325: LD_VAR 0 2
102329: PUSH
102330: LD_INT 4
102332: MINUS
102333: PUSH
102334: LD_INT 2
102336: PUSH
102337: EMPTY
102338: LIST
102339: LIST
102340: LIST
102341: PUSH
102342: EMPTY
102343: LIST
102344: LIST
102345: LIST
102346: LIST
102347: LIST
102348: ST_TO_ADDR
// end ; 5 :
102349: GO 102489
102351: LD_INT 5
102353: DOUBLE
102354: EQUAL
102355: IFTRUE 102359
102357: GO 102488
102359: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
102360: LD_ADDR_VAR 0 5
102364: PUSH
102365: LD_VAR 0 1
102369: PUSH
102370: LD_INT 4
102372: MINUS
102373: PUSH
102374: LD_VAR 0 2
102378: PUSH
102379: LD_INT 1
102381: PUSH
102382: EMPTY
102383: LIST
102384: LIST
102385: LIST
102386: PUSH
102387: LD_VAR 0 1
102391: PUSH
102392: LD_VAR 0 2
102396: PUSH
102397: LD_INT 4
102399: MINUS
102400: PUSH
102401: LD_INT 3
102403: PUSH
102404: EMPTY
102405: LIST
102406: LIST
102407: LIST
102408: PUSH
102409: LD_VAR 0 1
102413: PUSH
102414: LD_INT 4
102416: PLUS
102417: PUSH
102418: LD_VAR 0 2
102422: PUSH
102423: LD_INT 4
102425: PLUS
102426: PUSH
102427: LD_INT 5
102429: PUSH
102430: EMPTY
102431: LIST
102432: LIST
102433: LIST
102434: PUSH
102435: LD_VAR 0 1
102439: PUSH
102440: LD_INT 3
102442: PLUS
102443: PUSH
102444: LD_VAR 0 2
102448: PUSH
102449: LD_INT 4
102451: PUSH
102452: EMPTY
102453: LIST
102454: LIST
102455: LIST
102456: PUSH
102457: LD_VAR 0 1
102461: PUSH
102462: LD_VAR 0 2
102466: PUSH
102467: LD_INT 3
102469: PLUS
102470: PUSH
102471: LD_INT 0
102473: PUSH
102474: EMPTY
102475: LIST
102476: LIST
102477: LIST
102478: PUSH
102479: EMPTY
102480: LIST
102481: LIST
102482: LIST
102483: LIST
102484: LIST
102485: ST_TO_ADDR
// end ; end ;
102486: GO 102489
102488: POP
// result := list ;
102489: LD_ADDR_VAR 0 4
102493: PUSH
102494: LD_VAR 0 5
102498: ST_TO_ADDR
// end ;
102499: LD_VAR 0 4
102503: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
102504: LD_INT 0
102506: PPUSH
102507: PPUSH
102508: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
102509: LD_VAR 0 1
102513: NOT
102514: PUSH
102515: LD_VAR 0 2
102519: PUSH
102520: LD_INT 1
102522: PUSH
102523: LD_INT 2
102525: PUSH
102526: LD_INT 3
102528: PUSH
102529: LD_INT 4
102531: PUSH
102532: EMPTY
102533: LIST
102534: LIST
102535: LIST
102536: LIST
102537: IN
102538: NOT
102539: OR
102540: IFFALSE 102544
// exit ;
102542: GO 102636
// tmp := [ ] ;
102544: LD_ADDR_VAR 0 5
102548: PUSH
102549: EMPTY
102550: ST_TO_ADDR
// for i in units do
102551: LD_ADDR_VAR 0 4
102555: PUSH
102556: LD_VAR 0 1
102560: PUSH
102561: FOR_IN
102562: IFFALSE 102605
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
102564: LD_ADDR_VAR 0 5
102568: PUSH
102569: LD_VAR 0 5
102573: PPUSH
102574: LD_VAR 0 5
102578: PUSH
102579: LD_INT 1
102581: PLUS
102582: PPUSH
102583: LD_VAR 0 4
102587: PPUSH
102588: LD_VAR 0 2
102592: PPUSH
102593: CALL_OW 259
102597: PPUSH
102598: CALL_OW 2
102602: ST_TO_ADDR
102603: GO 102561
102605: POP
102606: POP
// if not tmp then
102607: LD_VAR 0 5
102611: NOT
102612: IFFALSE 102616
// exit ;
102614: GO 102636
// result := SortListByListDesc ( units , tmp ) ;
102616: LD_ADDR_VAR 0 3
102620: PUSH
102621: LD_VAR 0 1
102625: PPUSH
102626: LD_VAR 0 5
102630: PPUSH
102631: CALL_OW 77
102635: ST_TO_ADDR
// end ;
102636: LD_VAR 0 3
102640: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
102641: LD_INT 0
102643: PPUSH
102644: PPUSH
102645: PPUSH
// x := GetX ( building ) ;
102646: LD_ADDR_VAR 0 4
102650: PUSH
102651: LD_VAR 0 2
102655: PPUSH
102656: CALL_OW 250
102660: ST_TO_ADDR
// y := GetY ( building ) ;
102661: LD_ADDR_VAR 0 5
102665: PUSH
102666: LD_VAR 0 2
102670: PPUSH
102671: CALL_OW 251
102675: ST_TO_ADDR
// if GetTaskList ( unit ) then
102676: LD_VAR 0 1
102680: PPUSH
102681: CALL_OW 437
102685: IFFALSE 102780
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102687: LD_STRING e
102689: PUSH
102690: LD_VAR 0 1
102694: PPUSH
102695: CALL_OW 437
102699: PUSH
102700: LD_INT 1
102702: ARRAY
102703: PUSH
102704: LD_INT 1
102706: ARRAY
102707: EQUAL
102708: PUSH
102709: LD_VAR 0 4
102713: PUSH
102714: LD_VAR 0 1
102718: PPUSH
102719: CALL_OW 437
102723: PUSH
102724: LD_INT 1
102726: ARRAY
102727: PUSH
102728: LD_INT 2
102730: ARRAY
102731: EQUAL
102732: AND
102733: PUSH
102734: LD_VAR 0 5
102738: PUSH
102739: LD_VAR 0 1
102743: PPUSH
102744: CALL_OW 437
102748: PUSH
102749: LD_INT 1
102751: ARRAY
102752: PUSH
102753: LD_INT 3
102755: ARRAY
102756: EQUAL
102757: AND
102758: IFFALSE 102770
// result := true else
102760: LD_ADDR_VAR 0 3
102764: PUSH
102765: LD_INT 1
102767: ST_TO_ADDR
102768: GO 102778
// result := false ;
102770: LD_ADDR_VAR 0 3
102774: PUSH
102775: LD_INT 0
102777: ST_TO_ADDR
// end else
102778: GO 102788
// result := false ;
102780: LD_ADDR_VAR 0 3
102784: PUSH
102785: LD_INT 0
102787: ST_TO_ADDR
// end ;
102788: LD_VAR 0 3
102792: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
102793: LD_INT 0
102795: PPUSH
102796: PPUSH
102797: PPUSH
102798: PPUSH
// if not unit or not area then
102799: LD_VAR 0 1
102803: NOT
102804: PUSH
102805: LD_VAR 0 2
102809: NOT
102810: OR
102811: IFFALSE 102815
// exit ;
102813: GO 102980
// tmp := AreaToList ( area , i ) ;
102815: LD_ADDR_VAR 0 6
102819: PUSH
102820: LD_VAR 0 2
102824: PPUSH
102825: LD_VAR 0 5
102829: PPUSH
102830: CALL_OW 517
102834: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
102835: LD_ADDR_VAR 0 5
102839: PUSH
102840: DOUBLE
102841: LD_INT 1
102843: DEC
102844: ST_TO_ADDR
102845: LD_VAR 0 6
102849: PUSH
102850: LD_INT 1
102852: ARRAY
102853: PUSH
102854: FOR_TO
102855: IFFALSE 102970
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
102857: LD_ADDR_VAR 0 7
102861: PUSH
102862: LD_VAR 0 6
102866: PUSH
102867: LD_INT 1
102869: ARRAY
102870: PUSH
102871: LD_VAR 0 5
102875: ARRAY
102876: PUSH
102877: LD_VAR 0 6
102881: PUSH
102882: LD_INT 2
102884: ARRAY
102885: PUSH
102886: LD_VAR 0 5
102890: ARRAY
102891: PUSH
102892: EMPTY
102893: LIST
102894: LIST
102895: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
102896: LD_VAR 0 7
102900: PUSH
102901: LD_INT 1
102903: ARRAY
102904: PPUSH
102905: LD_VAR 0 7
102909: PUSH
102910: LD_INT 2
102912: ARRAY
102913: PPUSH
102914: CALL_OW 428
102918: PUSH
102919: LD_INT 0
102921: EQUAL
102922: IFFALSE 102968
// begin result := true ;
102924: LD_ADDR_VAR 0 4
102928: PUSH
102929: LD_INT 1
102931: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
102932: LD_VAR 0 1
102936: PPUSH
102937: LD_VAR 0 7
102941: PUSH
102942: LD_INT 1
102944: ARRAY
102945: PPUSH
102946: LD_VAR 0 7
102950: PUSH
102951: LD_INT 2
102953: ARRAY
102954: PPUSH
102955: LD_VAR 0 3
102959: PPUSH
102960: CALL_OW 48
// exit ;
102964: POP
102965: POP
102966: GO 102980
// end ; end ;
102968: GO 102854
102970: POP
102971: POP
// result := false ;
102972: LD_ADDR_VAR 0 4
102976: PUSH
102977: LD_INT 0
102979: ST_TO_ADDR
// end ;
102980: LD_VAR 0 4
102984: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
102985: LD_INT 0
102987: PPUSH
102988: PPUSH
102989: PPUSH
// if not side or side > 8 then
102990: LD_VAR 0 1
102994: NOT
102995: PUSH
102996: LD_VAR 0 1
103000: PUSH
103001: LD_INT 8
103003: GREATER
103004: OR
103005: IFFALSE 103009
// exit ;
103007: GO 103196
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103009: LD_ADDR_VAR 0 4
103013: PUSH
103014: LD_INT 22
103016: PUSH
103017: LD_VAR 0 1
103021: PUSH
103022: EMPTY
103023: LIST
103024: LIST
103025: PUSH
103026: LD_INT 21
103028: PUSH
103029: LD_INT 3
103031: PUSH
103032: EMPTY
103033: LIST
103034: LIST
103035: PUSH
103036: EMPTY
103037: LIST
103038: LIST
103039: PPUSH
103040: CALL_OW 69
103044: ST_TO_ADDR
// if not tmp then
103045: LD_VAR 0 4
103049: NOT
103050: IFFALSE 103054
// exit ;
103052: GO 103196
// enable_addtolog := true ;
103054: LD_ADDR_OWVAR 81
103058: PUSH
103059: LD_INT 1
103061: ST_TO_ADDR
// AddToLog ( [ ) ;
103062: LD_STRING [
103064: PPUSH
103065: CALL_OW 561
// for i in tmp do
103069: LD_ADDR_VAR 0 3
103073: PUSH
103074: LD_VAR 0 4
103078: PUSH
103079: FOR_IN
103080: IFFALSE 103187
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103082: LD_STRING [
103084: PUSH
103085: LD_VAR 0 3
103089: PPUSH
103090: CALL_OW 266
103094: STR
103095: PUSH
103096: LD_STRING , 
103098: STR
103099: PUSH
103100: LD_VAR 0 3
103104: PPUSH
103105: CALL_OW 250
103109: STR
103110: PUSH
103111: LD_STRING , 
103113: STR
103114: PUSH
103115: LD_VAR 0 3
103119: PPUSH
103120: CALL_OW 251
103124: STR
103125: PUSH
103126: LD_STRING , 
103128: STR
103129: PUSH
103130: LD_VAR 0 3
103134: PPUSH
103135: CALL_OW 254
103139: STR
103140: PUSH
103141: LD_STRING , 
103143: STR
103144: PUSH
103145: LD_VAR 0 3
103149: PPUSH
103150: LD_INT 1
103152: PPUSH
103153: CALL_OW 268
103157: STR
103158: PUSH
103159: LD_STRING , 
103161: STR
103162: PUSH
103163: LD_VAR 0 3
103167: PPUSH
103168: LD_INT 2
103170: PPUSH
103171: CALL_OW 268
103175: STR
103176: PUSH
103177: LD_STRING ],
103179: STR
103180: PPUSH
103181: CALL_OW 561
// end ;
103185: GO 103079
103187: POP
103188: POP
// AddToLog ( ]; ) ;
103189: LD_STRING ];
103191: PPUSH
103192: CALL_OW 561
// end ;
103196: LD_VAR 0 2
103200: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
103201: LD_INT 0
103203: PPUSH
103204: PPUSH
103205: PPUSH
103206: PPUSH
103207: PPUSH
// if not area or not rate or not max then
103208: LD_VAR 0 1
103212: NOT
103213: PUSH
103214: LD_VAR 0 2
103218: NOT
103219: OR
103220: PUSH
103221: LD_VAR 0 4
103225: NOT
103226: OR
103227: IFFALSE 103231
// exit ;
103229: GO 103423
// while 1 do
103231: LD_INT 1
103233: IFFALSE 103423
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
103235: LD_ADDR_VAR 0 9
103239: PUSH
103240: LD_VAR 0 1
103244: PPUSH
103245: LD_INT 1
103247: PPUSH
103248: CALL_OW 287
103252: PUSH
103253: LD_INT 10
103255: MUL
103256: ST_TO_ADDR
// r := rate / 10 ;
103257: LD_ADDR_VAR 0 7
103261: PUSH
103262: LD_VAR 0 2
103266: PUSH
103267: LD_INT 10
103269: DIVREAL
103270: ST_TO_ADDR
// time := 1 1$00 ;
103271: LD_ADDR_VAR 0 8
103275: PUSH
103276: LD_INT 2100
103278: ST_TO_ADDR
// if amount < min then
103279: LD_VAR 0 9
103283: PUSH
103284: LD_VAR 0 3
103288: LESS
103289: IFFALSE 103307
// r := r * 2 else
103291: LD_ADDR_VAR 0 7
103295: PUSH
103296: LD_VAR 0 7
103300: PUSH
103301: LD_INT 2
103303: MUL
103304: ST_TO_ADDR
103305: GO 103333
// if amount > max then
103307: LD_VAR 0 9
103311: PUSH
103312: LD_VAR 0 4
103316: GREATER
103317: IFFALSE 103333
// r := r / 2 ;
103319: LD_ADDR_VAR 0 7
103323: PUSH
103324: LD_VAR 0 7
103328: PUSH
103329: LD_INT 2
103331: DIVREAL
103332: ST_TO_ADDR
// time := time / r ;
103333: LD_ADDR_VAR 0 8
103337: PUSH
103338: LD_VAR 0 8
103342: PUSH
103343: LD_VAR 0 7
103347: DIVREAL
103348: ST_TO_ADDR
// if time < 0 then
103349: LD_VAR 0 8
103353: PUSH
103354: LD_INT 0
103356: LESS
103357: IFFALSE 103374
// time := time * - 1 ;
103359: LD_ADDR_VAR 0 8
103363: PUSH
103364: LD_VAR 0 8
103368: PUSH
103369: LD_INT 1
103371: NEG
103372: MUL
103373: ST_TO_ADDR
// wait ( time ) ;
103374: LD_VAR 0 8
103378: PPUSH
103379: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
103383: LD_INT 35
103385: PPUSH
103386: LD_INT 875
103388: PPUSH
103389: CALL_OW 12
103393: PPUSH
103394: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
103398: LD_INT 1
103400: PPUSH
103401: LD_INT 5
103403: PPUSH
103404: CALL_OW 12
103408: PPUSH
103409: LD_VAR 0 1
103413: PPUSH
103414: LD_INT 1
103416: PPUSH
103417: CALL_OW 55
// end ;
103421: GO 103231
// end ;
103423: LD_VAR 0 5
103427: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
103428: LD_INT 0
103430: PPUSH
103431: PPUSH
103432: PPUSH
103433: PPUSH
103434: PPUSH
103435: PPUSH
103436: PPUSH
103437: PPUSH
// if not turrets or not factories then
103438: LD_VAR 0 1
103442: NOT
103443: PUSH
103444: LD_VAR 0 2
103448: NOT
103449: OR
103450: IFFALSE 103454
// exit ;
103452: GO 103761
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
103454: LD_ADDR_VAR 0 10
103458: PUSH
103459: LD_INT 5
103461: PUSH
103462: LD_INT 6
103464: PUSH
103465: EMPTY
103466: LIST
103467: LIST
103468: PUSH
103469: LD_INT 2
103471: PUSH
103472: LD_INT 4
103474: PUSH
103475: EMPTY
103476: LIST
103477: LIST
103478: PUSH
103479: LD_INT 3
103481: PUSH
103482: LD_INT 5
103484: PUSH
103485: EMPTY
103486: LIST
103487: LIST
103488: PUSH
103489: EMPTY
103490: LIST
103491: LIST
103492: LIST
103493: PUSH
103494: LD_INT 24
103496: PUSH
103497: LD_INT 25
103499: PUSH
103500: EMPTY
103501: LIST
103502: LIST
103503: PUSH
103504: LD_INT 23
103506: PUSH
103507: LD_INT 27
103509: PUSH
103510: EMPTY
103511: LIST
103512: LIST
103513: PUSH
103514: EMPTY
103515: LIST
103516: LIST
103517: PUSH
103518: LD_INT 42
103520: PUSH
103521: LD_INT 43
103523: PUSH
103524: EMPTY
103525: LIST
103526: LIST
103527: PUSH
103528: LD_INT 44
103530: PUSH
103531: LD_INT 46
103533: PUSH
103534: EMPTY
103535: LIST
103536: LIST
103537: PUSH
103538: LD_INT 45
103540: PUSH
103541: LD_INT 47
103543: PUSH
103544: EMPTY
103545: LIST
103546: LIST
103547: PUSH
103548: EMPTY
103549: LIST
103550: LIST
103551: LIST
103552: PUSH
103553: EMPTY
103554: LIST
103555: LIST
103556: LIST
103557: ST_TO_ADDR
// result := [ ] ;
103558: LD_ADDR_VAR 0 3
103562: PUSH
103563: EMPTY
103564: ST_TO_ADDR
// for i in turrets do
103565: LD_ADDR_VAR 0 4
103569: PUSH
103570: LD_VAR 0 1
103574: PUSH
103575: FOR_IN
103576: IFFALSE 103759
// begin nat := GetNation ( i ) ;
103578: LD_ADDR_VAR 0 7
103582: PUSH
103583: LD_VAR 0 4
103587: PPUSH
103588: CALL_OW 248
103592: ST_TO_ADDR
// weapon := 0 ;
103593: LD_ADDR_VAR 0 8
103597: PUSH
103598: LD_INT 0
103600: ST_TO_ADDR
// if not nat then
103601: LD_VAR 0 7
103605: NOT
103606: IFFALSE 103610
// continue ;
103608: GO 103575
// for j in list [ nat ] do
103610: LD_ADDR_VAR 0 5
103614: PUSH
103615: LD_VAR 0 10
103619: PUSH
103620: LD_VAR 0 7
103624: ARRAY
103625: PUSH
103626: FOR_IN
103627: IFFALSE 103668
// if GetBWeapon ( i ) = j [ 1 ] then
103629: LD_VAR 0 4
103633: PPUSH
103634: CALL_OW 269
103638: PUSH
103639: LD_VAR 0 5
103643: PUSH
103644: LD_INT 1
103646: ARRAY
103647: EQUAL
103648: IFFALSE 103666
// begin weapon := j [ 2 ] ;
103650: LD_ADDR_VAR 0 8
103654: PUSH
103655: LD_VAR 0 5
103659: PUSH
103660: LD_INT 2
103662: ARRAY
103663: ST_TO_ADDR
// break ;
103664: GO 103668
// end ;
103666: GO 103626
103668: POP
103669: POP
// if not weapon then
103670: LD_VAR 0 8
103674: NOT
103675: IFFALSE 103679
// continue ;
103677: GO 103575
// for k in factories do
103679: LD_ADDR_VAR 0 6
103683: PUSH
103684: LD_VAR 0 2
103688: PUSH
103689: FOR_IN
103690: IFFALSE 103755
// begin weapons := AvailableWeaponList ( k ) ;
103692: LD_ADDR_VAR 0 9
103696: PUSH
103697: LD_VAR 0 6
103701: PPUSH
103702: CALL_OW 478
103706: ST_TO_ADDR
// if not weapons then
103707: LD_VAR 0 9
103711: NOT
103712: IFFALSE 103716
// continue ;
103714: GO 103689
// if weapon in weapons then
103716: LD_VAR 0 8
103720: PUSH
103721: LD_VAR 0 9
103725: IN
103726: IFFALSE 103753
// begin result := [ i , weapon ] ;
103728: LD_ADDR_VAR 0 3
103732: PUSH
103733: LD_VAR 0 4
103737: PUSH
103738: LD_VAR 0 8
103742: PUSH
103743: EMPTY
103744: LIST
103745: LIST
103746: ST_TO_ADDR
// exit ;
103747: POP
103748: POP
103749: POP
103750: POP
103751: GO 103761
// end ; end ;
103753: GO 103689
103755: POP
103756: POP
// end ;
103757: GO 103575
103759: POP
103760: POP
// end ;
103761: LD_VAR 0 3
103765: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
103766: LD_INT 0
103768: PPUSH
// if not side or side > 8 then
103769: LD_VAR 0 3
103773: NOT
103774: PUSH
103775: LD_VAR 0 3
103779: PUSH
103780: LD_INT 8
103782: GREATER
103783: OR
103784: IFFALSE 103788
// exit ;
103786: GO 103847
// if not range then
103788: LD_VAR 0 4
103792: NOT
103793: IFFALSE 103804
// range := - 12 ;
103795: LD_ADDR_VAR 0 4
103799: PUSH
103800: LD_INT 12
103802: NEG
103803: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
103804: LD_VAR 0 1
103808: PPUSH
103809: LD_VAR 0 2
103813: PPUSH
103814: LD_VAR 0 3
103818: PPUSH
103819: LD_VAR 0 4
103823: PPUSH
103824: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
103828: LD_VAR 0 1
103832: PPUSH
103833: LD_VAR 0 2
103837: PPUSH
103838: LD_VAR 0 3
103842: PPUSH
103843: CALL_OW 331
// end ;
103847: LD_VAR 0 5
103851: RET
// export function Video ( mode ) ; begin
103852: LD_INT 0
103854: PPUSH
// ingame_video = mode ;
103855: LD_ADDR_OWVAR 52
103859: PUSH
103860: LD_VAR 0 1
103864: ST_TO_ADDR
// interface_hidden = mode ;
103865: LD_ADDR_OWVAR 54
103869: PUSH
103870: LD_VAR 0 1
103874: ST_TO_ADDR
// end ;
103875: LD_VAR 0 2
103879: RET
// export function Join ( array , element ) ; begin
103880: LD_INT 0
103882: PPUSH
// result := array ^ element ;
103883: LD_ADDR_VAR 0 3
103887: PUSH
103888: LD_VAR 0 1
103892: PUSH
103893: LD_VAR 0 2
103897: ADD
103898: ST_TO_ADDR
// end ;
103899: LD_VAR 0 3
103903: RET
// export function JoinUnion ( array , element ) ; begin
103904: LD_INT 0
103906: PPUSH
// result := array union element ;
103907: LD_ADDR_VAR 0 3
103911: PUSH
103912: LD_VAR 0 1
103916: PUSH
103917: LD_VAR 0 2
103921: UNION
103922: ST_TO_ADDR
// end ;
103923: LD_VAR 0 3
103927: RET
// export function GetBehemoths ( side ) ; begin
103928: LD_INT 0
103930: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
103931: LD_ADDR_VAR 0 2
103935: PUSH
103936: LD_INT 22
103938: PUSH
103939: LD_VAR 0 1
103943: PUSH
103944: EMPTY
103945: LIST
103946: LIST
103947: PUSH
103948: LD_INT 31
103950: PUSH
103951: LD_INT 25
103953: PUSH
103954: EMPTY
103955: LIST
103956: LIST
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: PPUSH
103962: CALL_OW 69
103966: ST_TO_ADDR
// end ;
103967: LD_VAR 0 2
103971: RET
// export function Shuffle ( array ) ; var i , index ; begin
103972: LD_INT 0
103974: PPUSH
103975: PPUSH
103976: PPUSH
// result := [ ] ;
103977: LD_ADDR_VAR 0 2
103981: PUSH
103982: EMPTY
103983: ST_TO_ADDR
// if not array then
103984: LD_VAR 0 1
103988: NOT
103989: IFFALSE 103993
// exit ;
103991: GO 104092
// Randomize ;
103993: CALL_OW 10
// for i = array downto 1 do
103997: LD_ADDR_VAR 0 3
104001: PUSH
104002: DOUBLE
104003: LD_VAR 0 1
104007: INC
104008: ST_TO_ADDR
104009: LD_INT 1
104011: PUSH
104012: FOR_DOWNTO
104013: IFFALSE 104090
// begin index := rand ( 1 , array ) ;
104015: LD_ADDR_VAR 0 4
104019: PUSH
104020: LD_INT 1
104022: PPUSH
104023: LD_VAR 0 1
104027: PPUSH
104028: CALL_OW 12
104032: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104033: LD_ADDR_VAR 0 2
104037: PUSH
104038: LD_VAR 0 2
104042: PPUSH
104043: LD_VAR 0 2
104047: PUSH
104048: LD_INT 1
104050: PLUS
104051: PPUSH
104052: LD_VAR 0 1
104056: PUSH
104057: LD_VAR 0 4
104061: ARRAY
104062: PPUSH
104063: CALL_OW 2
104067: ST_TO_ADDR
// array := Delete ( array , index ) ;
104068: LD_ADDR_VAR 0 1
104072: PUSH
104073: LD_VAR 0 1
104077: PPUSH
104078: LD_VAR 0 4
104082: PPUSH
104083: CALL_OW 3
104087: ST_TO_ADDR
// end ;
104088: GO 104012
104090: POP
104091: POP
// end ;
104092: LD_VAR 0 2
104096: RET
