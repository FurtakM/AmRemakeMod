// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 58 0 0
// InitMacro ;
   8: CALL 33419 0 0
// InitNature ;
  12: CALL 33243 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// PrepareAlliance ;
  29: CALL 10769 0 0
// PrepareRussian ;
  33: CALL 6778 0 0
// PrepareLegion ;
  37: CALL 4018 0 0
// PreparePowell ;
  41: CALL 2772 0 0
// PrepareAmerican ;
  45: CALL 1595 0 0
// Action ;
  49: CALL 14676 0 0
// MC_Start ( ) ;
  53: CALL 34566 0 0
// end ;
  57: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  58: LD_INT 0
  60: PPUSH
// debug := false ;
  61: LD_ADDR_EXP 1
  65: PUSH
  66: LD_INT 0
  68: ST_TO_ADDR
// missionStart := false ;
  69: LD_ADDR_EXP 13
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// missionTime := 0 0$00 ;
  77: LD_ADDR_EXP 14
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// missionStage := 1 ;
  85: LD_ADDR_EXP 15
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// activeAttacks := false ;
  93: LD_ADDR_EXP 16
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// powellAnger := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// powellAllowRetreat := true ;
 109: LD_ADDR_EXP 19
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// powellCenterCameraMode := false ;
 117: LD_ADDR_EXP 20
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 125: LD_ADDR_EXP 18
 129: PUSH
 130: EMPTY
 131: PUSH
 132: EMPTY
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// russianDestroyed := false ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// legionDestroyed := false ;
 146: LD_ADDR_EXP 22
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// allianceDestroyed := false ;
 154: LD_ADDR_EXP 23
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 2
 166: PUSH
 167: LD_STRING 14_KappaStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 3
 182: PUSH
 183: LD_STRING 06_KurtStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 194: LD_ADDR_EXP 4
 198: PUSH
 199: LD_STRING 14_JMMVeh_1
 201: PPUSH
 202: LD_INT 0
 204: PPUSH
 205: CALL_OW 30
 209: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 210: LD_ADDR_EXP 5
 214: PUSH
 215: LD_STRING 14_JMMGirlVeh_1
 217: PPUSH
 218: LD_INT 0
 220: PPUSH
 221: CALL_OW 30
 225: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 226: LD_ADDR_EXP 7
 230: PUSH
 231: LD_STRING 14_JMMGirl_1
 233: PPUSH
 234: LD_INT 0
 236: PPUSH
 237: CALL_OW 30
 241: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 242: LD_ADDR_EXP 6
 246: PUSH
 247: LD_STRING 14_JMMGirlStatus_1
 249: PPUSH
 250: LD_INT 0
 252: PPUSH
 253: CALL_OW 30
 257: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 258: LD_ADDR_EXP 8
 262: PUSH
 263: LD_STRING 10_KhatamStatus_1
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 30
 273: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 274: LD_ADDR_EXP 9
 278: PUSH
 279: LD_STRING 13_BurlakStatus_1
 281: PPUSH
 282: LD_INT 0
 284: PPUSH
 285: CALL_OW 30
 289: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 290: LD_ADDR_EXP 10
 294: PUSH
 295: LD_STRING 13_StevensStatus_1
 297: PPUSH
 298: LD_INT 0
 300: PPUSH
 301: CALL_OW 30
 305: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 306: LD_ADDR_EXP 11
 310: PUSH
 311: LD_STRING 14_FastEnd_1
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: CALL_OW 30
 321: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 322: LD_ADDR_EXP 12
 326: PUSH
 327: LD_STRING 12_MainDepositFake_1
 329: PPUSH
 330: LD_INT 0
 332: PPUSH
 333: CALL_OW 30
 337: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 338: LD_ADDR_EXP 24
 342: PUSH
 343: LD_INT 1
 345: ST_TO_ADDR
// behemothUnderConstruct := false ;
 346: LD_ADDR_EXP 26
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 354: LD_ADDR_EXP 27
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// behemothDone := false ;
 362: LD_ADDR_EXP 28
 366: PUSH
 367: LD_INT 0
 369: ST_TO_ADDR
// allowBehemothConstruct := false ;
 370: LD_ADDR_EXP 25
 374: PUSH
 375: LD_INT 0
 377: ST_TO_ADDR
// seeBehemoth := false ;
 378: LD_ADDR_EXP 29
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// platonovHasBomb := false ;
 386: LD_ADDR_EXP 30
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// allianceActive := false ;
 394: LD_ADDR_EXP 31
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// rothCaptured := false ;
 402: LD_ADDR_EXP 33
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// lostCounter := 0 ;
 410: LD_ADDR_EXP 32
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// capturedUnit := [ ] ;
 418: LD_ADDR_EXP 34
 422: PUSH
 423: EMPTY
 424: ST_TO_ADDR
// trueAmericans := [ ] ;
 425: LD_ADDR_EXP 35
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// end ;
 432: LD_VAR 0 1
 436: RET
// export function CustomInitMacro ( ) ; begin
 437: LD_INT 0
 439: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 440: LD_ADDR_EXP 123
 444: PUSH
 445: LD_INT 2
 447: PUSH
 448: LD_INT 3
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 10
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 463: LD_ADDR_EXP 124
 467: PUSH
 468: LD_INT 1
 470: PUSH
 471: LD_INT 4
 473: PUSH
 474: LD_INT 5
 476: PUSH
 477: LD_INT 9
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 486: LD_INT 1
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: PPUSH
 503: CALL 56364 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 507: LD_INT 1
 509: PPUSH
 510: LD_INT 17
 512: PUSH
 513: EMPTY
 514: LIST
 515: PPUSH
 516: CALL 56457 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL 55870 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 24
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: LD_INT 3
 541: PUSH
 542: LD_INT 47
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: LD_INT 24
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 47
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 24
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 47
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 24
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 1
 595: PUSH
 596: LD_INT 47
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 1
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: CALL 55685 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 634: LD_INT 2
 636: PPUSH
 637: LD_INT 10
 639: PUSH
 640: LD_INT 11
 642: PUSH
 643: LD_INT 12
 645: PUSH
 646: LD_INT 14
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PPUSH
 655: CALL 56364 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 16
 664: PUSH
 665: EMPTY
 666: LIST
 667: PPUSH
 668: CALL 56457 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 672: LD_INT 2
 674: PPUSH
 675: LD_INT 21
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 3
 683: PUSH
 684: LD_INT 51
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: LD_INT 24
 695: PUSH
 696: LD_INT 3
 698: PUSH
 699: LD_INT 3
 701: PUSH
 702: LD_INT 47
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: LIST
 709: LIST
 710: PUSH
 711: LD_INT 24
 713: PUSH
 714: LD_INT 3
 716: PUSH
 717: LD_INT 3
 719: PUSH
 720: LD_INT 47
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: PUSH
 729: LD_INT 24
 731: PUSH
 732: LD_INT 3
 734: PUSH
 735: LD_INT 3
 737: PUSH
 738: LD_INT 47
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_INT 24
 749: PUSH
 750: LD_INT 3
 752: PUSH
 753: LD_INT 3
 755: PUSH
 756: LD_INT 47
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: PUSH
 765: LD_INT 24
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: LD_INT 3
 773: PUSH
 774: LD_INT 47
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: LIST
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL 55685 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 795: LD_INT 2
 797: PPUSH
 798: LD_INT 5
 800: PPUSH
 801: CALL 55870 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 805: LD_INT 2
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: CALL 56237 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 815: LD_INT 3
 817: PPUSH
 818: LD_INT 10
 820: PUSH
 821: LD_INT 12
 823: PUSH
 824: LD_INT 15
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_OWVAR 67
 836: ARRAY
 837: PPUSH
 838: LD_INT 27
 840: PPUSH
 841: CALL 55367 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 845: LD_INT 3
 847: PPUSH
 848: LD_INT 10
 850: PUSH
 851: LD_INT 11
 853: PUSH
 854: LD_INT 13
 856: PUSH
 857: LD_INT 15
 859: PUSH
 860: EMPTY
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: PPUSH
 866: CALL 56364 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 870: LD_INT 3
 872: PPUSH
 873: LD_INT 15
 875: PUSH
 876: EMPTY
 877: LIST
 878: PPUSH
 879: CALL 56457 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 883: LD_ADDR_EXP 128
 887: PUSH
 888: LD_EXP 128
 892: PPUSH
 893: LD_INT 3
 895: PPUSH
 896: LD_INT 22
 898: PUSH
 899: LD_INT 8
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: PUSH
 906: LD_INT 25
 908: PUSH
 909: LD_INT 15
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: PPUSH
 920: CALL_OW 69
 924: PPUSH
 925: CALL_OW 1
 929: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 930: LD_INT 3
 932: PPUSH
 933: LD_INT 13
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: LD_INT 1
 941: PUSH
 942: LD_INT 31
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 13
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 1
 959: PUSH
 960: LD_INT 31
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: LIST
 967: LIST
 968: PUSH
 969: LD_INT 13
 971: PUSH
 972: LD_INT 3
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 32
 980: PUSH
 981: EMPTY
 982: LIST
 983: LIST
 984: LIST
 985: LIST
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL 55685 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PPUSH
1009: CALL 56364 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1013: LD_INT 4
1015: PPUSH
1016: LD_INT 9
1018: PUSH
1019: EMPTY
1020: LIST
1021: PPUSH
1022: CALL 56457 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1026: LD_INT 4
1028: PPUSH
1029: LD_INT 26
1031: PUSH
1032: LD_INT 74
1034: PUSH
1035: LD_INT 107
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 77
1052: PUSH
1053: LD_INT 101
1055: PUSH
1056: LD_INT 4
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 69
1070: PUSH
1071: LD_INT 86
1073: PUSH
1074: LD_INT 4
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 27
1085: PUSH
1086: LD_INT 77
1088: PUSH
1089: LD_INT 110
1091: PUSH
1092: LD_INT 3
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 27
1103: PUSH
1104: LD_INT 42
1106: PUSH
1107: LD_INT 79
1109: PUSH
1110: LD_INT 5
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 29
1121: PUSH
1122: LD_INT 86
1124: PUSH
1125: LD_INT 105
1127: PUSH
1128: LD_INT 2
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 30
1139: PUSH
1140: LD_INT 40
1142: PUSH
1143: LD_INT 75
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 32
1157: PUSH
1158: LD_INT 80
1160: PUSH
1161: LD_INT 106
1163: PUSH
1164: LD_INT 4
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 32
1175: PUSH
1176: LD_INT 75
1178: PUSH
1179: LD_INT 114
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 32
1193: PUSH
1194: LD_INT 82
1196: PUSH
1197: LD_INT 110
1199: PUSH
1200: LD_INT 5
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 32
1211: PUSH
1212: LD_INT 62
1214: PUSH
1215: LD_INT 78
1217: PUSH
1218: LD_INT 4
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 4
1229: PUSH
1230: LD_INT 39
1232: PUSH
1233: LD_INT 61
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PPUSH
1259: CALL 55577 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1263: LD_INT 4
1265: PPUSH
1266: LD_INT 5
1268: PUSH
1269: LD_INT 6
1271: PUSH
1272: LD_INT 7
1274: PUSH
1275: LD_INT 9
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PPUSH
1284: CALL 56775 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1288: LD_INT 4
1290: PPUSH
1291: LD_INT 40
1293: PUSH
1294: LD_INT 75
1296: PUSH
1297: LD_INT 1
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 86
1307: PUSH
1308: LD_INT 105
1310: PUSH
1311: LD_INT 0
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PPUSH
1323: CALL 56009 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1327: LD_INT 4
1329: PPUSH
1330: LD_INT 2
1332: PPUSH
1333: CALL 56237 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1337: LD_INT 4
1339: PPUSH
1340: LD_INT 0
1342: PPUSH
1343: CALL 56237 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1347: LD_INT 4
1349: PPUSH
1350: LD_INT 54
1352: PPUSH
1353: LD_INT 85
1355: PPUSH
1356: LD_INT 2
1358: PPUSH
1359: LD_INT 19
1361: PUSH
1362: LD_INT 16
1364: PUSH
1365: LD_INT 17
1367: PUSH
1368: LD_INT 18
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 56569 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 3
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: EMPTY
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 4
1404: PUSH
1405: LD_INT 1
1407: PUSH
1408: LD_INT 1
1410: PUSH
1411: LD_INT 6
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: LD_INT 1
1425: PUSH
1426: LD_INT 1
1428: PUSH
1429: LD_INT 7
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PUSH
1438: LD_INT 4
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: LD_INT 1
1446: PUSH
1447: LD_INT 6
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: PUSH
1456: EMPTY
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL 55685 0 2
// MC_SetTame ( 4 , powellApe ) ;
1466: LD_INT 4
1468: PPUSH
1469: LD_INT 13
1471: PPUSH
1472: CALL 56188 0 2
// end ;
1476: LD_VAR 0 1
1480: RET
// every 0 0$1 trigger debug do var i , tmp ;
1481: LD_EXP 1
1485: IFFALSE 1592
1487: GO 1489
1489: DISABLE
1490: LD_INT 0
1492: PPUSH
1493: PPUSH
// begin enable ;
1494: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1495: LD_ADDR_VAR 0 2
1499: PUSH
1500: LD_INT 22
1502: PUSH
1503: LD_INT 1
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PUSH
1510: LD_INT 3
1512: PUSH
1513: LD_INT 21
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: PUSH
1527: LD_INT 3
1529: PUSH
1530: LD_INT 24
1532: PUSH
1533: LD_INT 999
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: LIST
1548: PPUSH
1549: CALL_OW 69
1553: ST_TO_ADDR
// if not tmp then
1554: LD_VAR 0 2
1558: NOT
1559: IFFALSE 1563
// exit ;
1561: GO 1592
// for i in tmp do
1563: LD_ADDR_VAR 0 1
1567: PUSH
1568: LD_VAR 0 2
1572: PUSH
1573: FOR_IN
1574: IFFALSE 1590
// SetLives ( i , 1000 ) ;
1576: LD_VAR 0 1
1580: PPUSH
1581: LD_INT 1000
1583: PPUSH
1584: CALL_OW 234
1588: GO 1573
1590: POP
1591: POP
// end ; end_of_file
1592: PPOPN 2
1594: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1595: LD_INT 0
1597: PPUSH
// uc_side := 1 ;
1598: LD_ADDR_OWVAR 20
1602: PUSH
1603: LD_INT 1
1605: ST_TO_ADDR
// uc_nation := 1 ;
1606: LD_ADDR_OWVAR 21
1610: PUSH
1611: LD_INT 1
1613: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1614: LD_ADDR_EXP 36
1618: PUSH
1619: LD_STRING JMM
1621: PPUSH
1622: LD_EXP 1
1626: NOT
1627: PPUSH
1628: LD_STRING 14_
1630: PPUSH
1631: CALL 61665 0 3
1635: ST_TO_ADDR
// if not JMMVeh then
1636: LD_EXP 4
1640: NOT
1641: IFFALSE 1664
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 3
1648: PPUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 5
1654: PPUSH
1655: LD_INT 100
1657: PPUSH
1658: CALL 68298 0 5
1662: GO 1723
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1664: LD_EXP 4
1668: PUSH
1669: LD_INT 1
1671: ARRAY
1672: PUSH
1673: LD_INT 1
1675: ARRAY
1676: PPUSH
1677: LD_EXP 4
1681: PUSH
1682: LD_INT 2
1684: ARRAY
1685: PUSH
1686: LD_INT 1
1688: ARRAY
1689: PPUSH
1690: LD_EXP 4
1694: PUSH
1695: LD_INT 3
1697: ARRAY
1698: PUSH
1699: LD_INT 1
1701: ARRAY
1702: PPUSH
1703: LD_EXP 4
1707: PUSH
1708: LD_INT 4
1710: ARRAY
1711: PUSH
1712: LD_INT 1
1714: ARRAY
1715: PPUSH
1716: LD_INT 30
1718: PPUSH
1719: CALL 68298 0 5
// JMMNewVeh := CreateVehicle ;
1723: LD_ADDR_EXP 53
1727: PUSH
1728: CALL_OW 45
1732: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1733: LD_EXP 53
1737: PPUSH
1738: LD_INT 4
1740: PPUSH
1741: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1745: LD_EXP 53
1749: PPUSH
1750: LD_INT 75
1752: PPUSH
1753: LD_INT 92
1755: PPUSH
1756: LD_INT 0
1758: PPUSH
1759: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1763: LD_EXP 36
1767: PPUSH
1768: LD_EXP 53
1772: PPUSH
1773: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1777: LD_EXP 6
1781: PUSH
1782: LD_EXP 2
1786: NOT
1787: AND
1788: IFFALSE 2046
// begin if not JMMGirlVeh then
1790: LD_EXP 5
1794: NOT
1795: IFFALSE 1818
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1797: LD_INT 3
1799: PPUSH
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 9
1808: PPUSH
1809: LD_INT 100
1811: PPUSH
1812: CALL 68298 0 5
1816: GO 1877
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1818: LD_EXP 5
1822: PUSH
1823: LD_INT 1
1825: ARRAY
1826: PUSH
1827: LD_INT 1
1829: ARRAY
1830: PPUSH
1831: LD_EXP 5
1835: PUSH
1836: LD_INT 2
1838: ARRAY
1839: PUSH
1840: LD_INT 1
1842: ARRAY
1843: PPUSH
1844: LD_EXP 5
1848: PUSH
1849: LD_INT 3
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_EXP 5
1861: PUSH
1862: LD_INT 4
1864: ARRAY
1865: PUSH
1866: LD_INT 1
1868: ARRAY
1869: PPUSH
1870: LD_INT 30
1872: PPUSH
1873: CALL 68298 0 5
// GirlNewVeh := CreateVehicle ;
1877: LD_ADDR_EXP 54
1881: PUSH
1882: CALL_OW 45
1886: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1887: LD_EXP 54
1891: PPUSH
1892: LD_INT 4
1894: PPUSH
1895: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1899: LD_EXP 54
1903: PPUSH
1904: LD_INT 82
1906: PPUSH
1907: LD_INT 96
1909: PPUSH
1910: LD_INT 0
1912: PPUSH
1913: CALL_OW 48
// if JMMGirl = 1 then
1917: LD_EXP 7
1921: PUSH
1922: LD_INT 1
1924: EQUAL
1925: IFFALSE 1960
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1927: LD_ADDR_EXP 37
1931: PUSH
1932: LD_STRING Joan
1934: PPUSH
1935: LD_INT 1
1937: PPUSH
1938: LD_STRING 14_
1940: PPUSH
1941: CALL 61665 0 3
1945: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1946: LD_EXP 37
1950: PPUSH
1951: LD_EXP 54
1955: PPUSH
1956: CALL_OW 52
// end ; if JMMGirl = 2 then
1960: LD_EXP 7
1964: PUSH
1965: LD_INT 2
1967: EQUAL
1968: IFFALSE 2003
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1970: LD_ADDR_EXP 39
1974: PUSH
1975: LD_STRING Lisa
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_STRING 14_
1983: PPUSH
1984: CALL 61665 0 3
1988: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1989: LD_EXP 39
1993: PPUSH
1994: LD_EXP 54
1998: PPUSH
1999: CALL_OW 52
// end ; if JMMGirl = 3 then
2003: LD_EXP 7
2007: PUSH
2008: LD_INT 3
2010: EQUAL
2011: IFFALSE 2046
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2013: LD_ADDR_EXP 51
2017: PUSH
2018: LD_STRING Connie
2020: PPUSH
2021: LD_INT 1
2023: PPUSH
2024: LD_STRING 14_
2026: PPUSH
2027: CALL 61665 0 3
2031: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2032: LD_EXP 51
2036: PPUSH
2037: LD_EXP 54
2041: PPUSH
2042: CALL_OW 52
// end ; end ; end ;
2046: LD_VAR 0 1
2050: RET
// export function PrepareStevensSquad ; var tmp ; begin
2051: LD_INT 0
2053: PPUSH
2054: PPUSH
// uc_side := 1 ;
2055: LD_ADDR_OWVAR 20
2059: PUSH
2060: LD_INT 1
2062: ST_TO_ADDR
// uc_nation := 1 ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 1
2070: ST_TO_ADDR
// tmp := [ ] ;
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: EMPTY
2077: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2078: LD_ADDR_EXP 38
2082: PUSH
2083: LD_STRING Stevens
2085: PPUSH
2086: LD_EXP 1
2090: NOT
2091: PPUSH
2092: LD_STRING 13f_
2094: PPUSH
2095: CALL 61665 0 3
2099: ST_TO_ADDR
// if not Stevens then
2100: LD_EXP 38
2104: NOT
2105: IFFALSE 2161
// begin hc_name = Baker Smith ;
2107: LD_ADDR_OWVAR 26
2111: PUSH
2112: LD_STRING Baker Smith
2114: ST_TO_ADDR
// hc_gallery =  ;
2115: LD_ADDR_OWVAR 33
2119: PUSH
2120: LD_STRING 
2122: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2123: LD_INT 1
2125: PPUSH
2126: LD_INT 10
2128: PPUSH
2129: CALL_OW 384
// Baker = CreateHuman ;
2133: LD_ADDR_EXP 52
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_EXP 52
2157: ADD
2158: ST_TO_ADDR
// end else
2159: GO 2177
// tmp := tmp ^ Stevens ;
2161: LD_ADDR_VAR 0 2
2165: PUSH
2166: LD_VAR 0 2
2170: PUSH
2171: LD_EXP 38
2175: ADD
2176: ST_TO_ADDR
// if not Lisa then
2177: LD_EXP 39
2181: NOT
2182: IFFALSE 2228
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2184: LD_ADDR_EXP 39
2188: PUSH
2189: LD_STRING Lisa
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13f_
2200: PPUSH
2201: CALL 61665 0 3
2205: ST_TO_ADDR
// if Lisa then
2206: LD_EXP 39
2210: IFFALSE 2228
// tmp := tmp ^ Lisa ;
2212: LD_ADDR_VAR 0 2
2216: PUSH
2217: LD_VAR 0 2
2221: PUSH
2222: LD_EXP 39
2226: ADD
2227: ST_TO_ADDR
// end ; if not Donaldson then
2228: LD_EXP 40
2232: NOT
2233: IFFALSE 2279
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2235: LD_ADDR_EXP 40
2239: PUSH
2240: LD_STRING Donaldson
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13f_
2251: PPUSH
2252: CALL 61665 0 3
2256: ST_TO_ADDR
// if Donaldson then
2257: LD_EXP 40
2261: IFFALSE 2279
// tmp := tmp ^ Donaldson ;
2263: LD_ADDR_VAR 0 2
2267: PUSH
2268: LD_VAR 0 2
2272: PUSH
2273: LD_EXP 40
2277: ADD
2278: ST_TO_ADDR
// end ; if not Bobby then
2279: LD_EXP 41
2283: NOT
2284: IFFALSE 2330
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2286: LD_ADDR_EXP 41
2290: PUSH
2291: LD_STRING Bobby
2293: PPUSH
2294: LD_EXP 1
2298: NOT
2299: PPUSH
2300: LD_STRING 13f_
2302: PPUSH
2303: CALL 61665 0 3
2307: ST_TO_ADDR
// if Bobby then
2308: LD_EXP 41
2312: IFFALSE 2330
// tmp := tmp ^ Bobby ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 41
2328: ADD
2329: ST_TO_ADDR
// end ; if not Cyrus then
2330: LD_EXP 42
2334: NOT
2335: IFFALSE 2381
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2337: LD_ADDR_EXP 42
2341: PUSH
2342: LD_STRING Cyrus
2344: PPUSH
2345: LD_EXP 1
2349: NOT
2350: PPUSH
2351: LD_STRING 13f_
2353: PPUSH
2354: CALL 61665 0 3
2358: ST_TO_ADDR
// if Cyrus then
2359: LD_EXP 42
2363: IFFALSE 2381
// tmp := tmp ^ Cyrus ;
2365: LD_ADDR_VAR 0 2
2369: PUSH
2370: LD_VAR 0 2
2374: PUSH
2375: LD_EXP 42
2379: ADD
2380: ST_TO_ADDR
// end ; if not Brown then
2381: LD_EXP 44
2385: NOT
2386: IFFALSE 2432
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2388: LD_ADDR_EXP 44
2392: PUSH
2393: LD_STRING Brown
2395: PPUSH
2396: LD_EXP 1
2400: NOT
2401: PPUSH
2402: LD_STRING 13f_
2404: PPUSH
2405: CALL 61665 0 3
2409: ST_TO_ADDR
// if Brown then
2410: LD_EXP 44
2414: IFFALSE 2432
// tmp := tmp ^ Brown ;
2416: LD_ADDR_VAR 0 2
2420: PUSH
2421: LD_VAR 0 2
2425: PUSH
2426: LD_EXP 44
2430: ADD
2431: ST_TO_ADDR
// end ; if not Gladstone then
2432: LD_EXP 45
2436: NOT
2437: IFFALSE 2483
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2439: LD_ADDR_EXP 45
2443: PUSH
2444: LD_STRING Gladstone
2446: PPUSH
2447: LD_EXP 1
2451: NOT
2452: PPUSH
2453: LD_STRING 13f_
2455: PPUSH
2456: CALL 61665 0 3
2460: ST_TO_ADDR
// if Gladstone then
2461: LD_EXP 45
2465: IFFALSE 2483
// tmp := tmp ^ Gladstone ;
2467: LD_ADDR_VAR 0 2
2471: PUSH
2472: LD_VAR 0 2
2476: PUSH
2477: LD_EXP 45
2481: ADD
2482: ST_TO_ADDR
// end ; if not Houten then
2483: LD_EXP 46
2487: NOT
2488: IFFALSE 2534
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2490: LD_ADDR_EXP 46
2494: PUSH
2495: LD_STRING Houten
2497: PPUSH
2498: LD_EXP 1
2502: NOT
2503: PPUSH
2504: LD_STRING 13f_
2506: PPUSH
2507: CALL 61665 0 3
2511: ST_TO_ADDR
// if Houten then
2512: LD_EXP 46
2516: IFFALSE 2534
// tmp := tmp ^ Houten ;
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: LD_VAR 0 2
2527: PUSH
2528: LD_EXP 46
2532: ADD
2533: ST_TO_ADDR
// end ; if not Cornel then
2534: LD_EXP 47
2538: NOT
2539: IFFALSE 2585
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2541: LD_ADDR_EXP 47
2545: PUSH
2546: LD_STRING Cornel
2548: PPUSH
2549: LD_EXP 1
2553: NOT
2554: PPUSH
2555: LD_STRING 13f_
2557: PPUSH
2558: CALL 61665 0 3
2562: ST_TO_ADDR
// if Cornel then
2563: LD_EXP 47
2567: IFFALSE 2585
// tmp := tmp ^ Cornel ;
2569: LD_ADDR_VAR 0 2
2573: PUSH
2574: LD_VAR 0 2
2578: PUSH
2579: LD_EXP 47
2583: ADD
2584: ST_TO_ADDR
// end ; if not Gary then
2585: LD_EXP 48
2589: NOT
2590: IFFALSE 2636
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2592: LD_ADDR_EXP 48
2596: PUSH
2597: LD_STRING Gary
2599: PPUSH
2600: LD_EXP 1
2604: NOT
2605: PPUSH
2606: LD_STRING 13f_
2608: PPUSH
2609: CALL 61665 0 3
2613: ST_TO_ADDR
// if Gary then
2614: LD_EXP 48
2618: IFFALSE 2636
// tmp := tmp ^ Gary ;
2620: LD_ADDR_VAR 0 2
2624: PUSH
2625: LD_VAR 0 2
2629: PUSH
2630: LD_EXP 48
2634: ADD
2635: ST_TO_ADDR
// end ; if not Frank then
2636: LD_EXP 49
2640: NOT
2641: IFFALSE 2687
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2643: LD_ADDR_EXP 49
2647: PUSH
2648: LD_STRING Frank
2650: PPUSH
2651: LD_EXP 1
2655: NOT
2656: PPUSH
2657: LD_STRING 13f_
2659: PPUSH
2660: CALL 61665 0 3
2664: ST_TO_ADDR
// if Frank then
2665: LD_EXP 49
2669: IFFALSE 2687
// tmp := tmp ^ Frank ;
2671: LD_ADDR_VAR 0 2
2675: PUSH
2676: LD_VAR 0 2
2680: PUSH
2681: LD_EXP 49
2685: ADD
2686: ST_TO_ADDR
// end ; if not Kikuchi then
2687: LD_EXP 50
2691: NOT
2692: IFFALSE 2738
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2694: LD_ADDR_EXP 50
2698: PUSH
2699: LD_STRING Kikuchi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_STRING 13f_
2710: PPUSH
2711: CALL 61665 0 3
2715: ST_TO_ADDR
// if Kikuchi then
2716: LD_EXP 50
2720: IFFALSE 2738
// tmp := tmp ^ Kikuchi ;
2722: LD_ADDR_VAR 0 2
2726: PUSH
2727: LD_VAR 0 2
2731: PUSH
2732: LD_EXP 50
2736: ADD
2737: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2738: LD_ADDR_VAR 0 2
2742: PUSH
2743: LD_VAR 0 2
2747: PUSH
2748: LD_STRING 13_other_survivors
2750: PPUSH
2751: CALL_OW 31
2755: UNION
2756: ST_TO_ADDR
// result := tmp ;
2757: LD_ADDR_VAR 0 1
2761: PUSH
2762: LD_VAR 0 2
2766: ST_TO_ADDR
// end ; end_of_file
2767: LD_VAR 0 1
2771: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2772: LD_INT 0
2774: PPUSH
2775: PPUSH
2776: PPUSH
2777: PPUSH
2778: PPUSH
2779: PPUSH
2780: PPUSH
2781: PPUSH
2782: PPUSH
2783: PPUSH
// uc_side := 4 ;
2784: LD_ADDR_OWVAR 20
2788: PUSH
2789: LD_INT 4
2791: ST_TO_ADDR
// uc_nation := 1 ;
2792: LD_ADDR_OWVAR 21
2796: PUSH
2797: LD_INT 1
2799: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2800: LD_INT 387
2802: PPUSH
2803: CALL_OW 274
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 2500
2813: PPUSH
2814: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2818: LD_INT 387
2820: PPUSH
2821: CALL_OW 274
2825: PPUSH
2826: LD_INT 2
2828: PPUSH
2829: LD_INT 400
2831: PPUSH
2832: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2836: LD_INT 387
2838: PPUSH
2839: CALL_OW 274
2843: PPUSH
2844: LD_INT 3
2846: PPUSH
2847: LD_INT 10
2849: PPUSH
2850: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2854: LD_ADDR_EXP 55
2858: PUSH
2859: LD_STRING Powell
2861: PPUSH
2862: CALL_OW 25
2866: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2867: LD_EXP 55
2871: PPUSH
2872: LD_INT 57
2874: PPUSH
2875: LD_INT 94
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2885: LD_EXP 55
2889: PPUSH
2890: LD_INT 58
2892: PPUSH
2893: LD_INT 94
2895: PPUSH
2896: CALL_OW 118
// vip := [ ] ;
2900: LD_ADDR_EXP 56
2904: PUSH
2905: EMPTY
2906: ST_TO_ADDR
// tmp := [ ] ;
2907: LD_ADDR_VAR 0 6
2911: PUSH
2912: EMPTY
2913: ST_TO_ADDR
// if JMMGirl <> 2 then
2914: LD_EXP 7
2918: PUSH
2919: LD_INT 2
2921: NONEQUAL
2922: IFFALSE 2946
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2924: LD_ADDR_EXP 39
2928: PUSH
2929: LD_STRING Lisa
2931: PPUSH
2932: LD_EXP 1
2936: NOT
2937: PPUSH
2938: LD_STRING 13s_
2940: PPUSH
2941: CALL 61665 0 3
2945: ST_TO_ADDR
// if Lisa then
2946: LD_EXP 39
2950: IFFALSE 2968
// tmp := tmp ^ Lisa ;
2952: LD_ADDR_VAR 0 6
2956: PUSH
2957: LD_VAR 0 6
2961: PUSH
2962: LD_EXP 39
2966: ADD
2967: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2968: LD_ADDR_EXP 40
2972: PUSH
2973: LD_STRING Donaldson
2975: PPUSH
2976: LD_EXP 1
2980: NOT
2981: PPUSH
2982: LD_STRING 13s_
2984: PPUSH
2985: CALL 61665 0 3
2989: ST_TO_ADDR
// if Donaldson then
2990: LD_EXP 40
2994: IFFALSE 3012
// tmp := tmp ^ Donaldson ;
2996: LD_ADDR_VAR 0 6
3000: PUSH
3001: LD_VAR 0 6
3005: PUSH
3006: LD_EXP 40
3010: ADD
3011: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3012: LD_ADDR_EXP 41
3016: PUSH
3017: LD_STRING Bobby
3019: PPUSH
3020: LD_EXP 1
3024: NOT
3025: PPUSH
3026: LD_STRING 13s_
3028: PPUSH
3029: CALL 61665 0 3
3033: ST_TO_ADDR
// if Bobby then
3034: LD_EXP 41
3038: IFFALSE 3056
// tmp := tmp ^ Bobby ;
3040: LD_ADDR_VAR 0 6
3044: PUSH
3045: LD_VAR 0 6
3049: PUSH
3050: LD_EXP 41
3054: ADD
3055: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3056: LD_ADDR_EXP 42
3060: PUSH
3061: LD_STRING Cyrus
3063: PPUSH
3064: LD_EXP 1
3068: NOT
3069: PPUSH
3070: LD_STRING 13s_
3072: PPUSH
3073: CALL 61665 0 3
3077: ST_TO_ADDR
// if Cyrus then
3078: LD_EXP 42
3082: IFFALSE 3100
// tmp := tmp ^ Cyrus ;
3084: LD_ADDR_VAR 0 6
3088: PUSH
3089: LD_VAR 0 6
3093: PUSH
3094: LD_EXP 42
3098: ADD
3099: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3100: LD_ADDR_EXP 43
3104: PUSH
3105: LD_STRING Denis
3107: PPUSH
3108: LD_EXP 1
3112: NOT
3113: PPUSH
3114: LD_STRING 13s_
3116: PPUSH
3117: CALL 61665 0 3
3121: ST_TO_ADDR
// if not Denis then
3122: LD_EXP 43
3126: NOT
3127: IFFALSE 3151
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3129: LD_ADDR_EXP 43
3133: PUSH
3134: LD_STRING Denis
3136: PPUSH
3137: LD_EXP 1
3141: NOT
3142: PPUSH
3143: LD_STRING 13f_
3145: PPUSH
3146: CALL 61665 0 3
3150: ST_TO_ADDR
// if Denis then
3151: LD_EXP 43
3155: IFFALSE 3173
// tmp := tmp ^ Denis ;
3157: LD_ADDR_VAR 0 6
3161: PUSH
3162: LD_VAR 0 6
3166: PUSH
3167: LD_EXP 43
3171: ADD
3172: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3173: LD_ADDR_EXP 44
3177: PUSH
3178: LD_STRING Brown
3180: PPUSH
3181: LD_EXP 1
3185: NOT
3186: PPUSH
3187: LD_STRING 13s_
3189: PPUSH
3190: CALL 61665 0 3
3194: ST_TO_ADDR
// if Brown then
3195: LD_EXP 44
3199: IFFALSE 3217
// tmp := tmp ^ Brown ;
3201: LD_ADDR_VAR 0 6
3205: PUSH
3206: LD_VAR 0 6
3210: PUSH
3211: LD_EXP 44
3215: ADD
3216: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 45
3221: PUSH
3222: LD_STRING Gladstone
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 61665 0 3
3238: ST_TO_ADDR
// if Gladstone then
3239: LD_EXP 45
3243: IFFALSE 3261
// tmp := tmp ^ Gladstone ;
3245: LD_ADDR_VAR 0 6
3249: PUSH
3250: LD_VAR 0 6
3254: PUSH
3255: LD_EXP 45
3259: ADD
3260: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 46
3265: PUSH
3266: LD_STRING Houten
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 61665 0 3
3282: ST_TO_ADDR
// if Houten then
3283: LD_EXP 46
3287: IFFALSE 3305
// tmp := tmp ^ Houten ;
3289: LD_ADDR_VAR 0 6
3293: PUSH
3294: LD_VAR 0 6
3298: PUSH
3299: LD_EXP 46
3303: ADD
3304: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 47
3309: PUSH
3310: LD_STRING Cornel
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 61665 0 3
3326: ST_TO_ADDR
// if Cornel then
3327: LD_EXP 47
3331: IFFALSE 3349
// tmp := tmp ^ Cornel ;
3333: LD_ADDR_VAR 0 6
3337: PUSH
3338: LD_VAR 0 6
3342: PUSH
3343: LD_EXP 47
3347: ADD
3348: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 48
3353: PUSH
3354: LD_STRING Gary
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 61665 0 3
3370: ST_TO_ADDR
// if Gary then
3371: LD_EXP 48
3375: IFFALSE 3393
// tmp := tmp ^ Gary ;
3377: LD_ADDR_VAR 0 6
3381: PUSH
3382: LD_VAR 0 6
3386: PUSH
3387: LD_EXP 48
3391: ADD
3392: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 49
3397: PUSH
3398: LD_STRING Frank
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 61665 0 3
3414: ST_TO_ADDR
// if Frank then
3415: LD_EXP 49
3419: IFFALSE 3437
// tmp := tmp ^ Frank ;
3421: LD_ADDR_VAR 0 6
3425: PUSH
3426: LD_VAR 0 6
3430: PUSH
3431: LD_EXP 49
3435: ADD
3436: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3437: LD_ADDR_EXP 50
3441: PUSH
3442: LD_STRING Kikuchi
3444: PPUSH
3445: LD_EXP 1
3449: NOT
3450: PPUSH
3451: LD_STRING 13s_
3453: PPUSH
3454: CALL 61665 0 3
3458: ST_TO_ADDR
// if Kikuchi then
3459: LD_EXP 50
3463: IFFALSE 3481
// tmp := tmp ^ Kikuchi ;
3465: LD_ADDR_VAR 0 6
3469: PUSH
3470: LD_VAR 0 6
3474: PUSH
3475: LD_EXP 50
3479: ADD
3480: ST_TO_ADDR
// vip := tmp ;
3481: LD_ADDR_EXP 56
3485: PUSH
3486: LD_VAR 0 6
3490: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3491: LD_ADDR_VAR 0 6
3495: PUSH
3496: LD_VAR 0 6
3500: PUSH
3501: LD_STRING 13s_others
3503: PPUSH
3504: CALL_OW 31
3508: UNION
3509: ST_TO_ADDR
// if tmp < 20 then
3510: LD_VAR 0 6
3514: PUSH
3515: LD_INT 20
3517: LESS
3518: IFFALSE 3585
// for i = 1 to 20 - tmp do
3520: LD_ADDR_VAR 0 2
3524: PUSH
3525: DOUBLE
3526: LD_INT 1
3528: DEC
3529: ST_TO_ADDR
3530: LD_INT 20
3532: PUSH
3533: LD_VAR 0 6
3537: MINUS
3538: PUSH
3539: FOR_TO
3540: IFFALSE 3583
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3542: LD_INT 1
3544: PPUSH
3545: LD_VAR 0 2
3549: PUSH
3550: LD_INT 4
3552: MOD
3553: PUSH
3554: LD_INT 1
3556: PLUS
3557: PPUSH
3558: LD_INT 5
3560: PPUSH
3561: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: CALL_OW 44
3579: ADD
3580: ST_TO_ADDR
// end ;
3581: GO 3539
3583: POP
3584: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3585: LD_ADDR_VAR 0 7
3589: PUSH
3590: LD_INT 22
3592: PUSH
3593: LD_INT 4
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PUSH
3600: LD_INT 30
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 69
3618: PUSH
3619: LD_INT 1
3621: ARRAY
3622: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3623: LD_ADDR_VAR 0 8
3627: PUSH
3628: LD_INT 22
3630: PUSH
3631: LD_INT 4
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: PUSH
3638: LD_INT 30
3640: PUSH
3641: LD_INT 6
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PPUSH
3652: CALL_OW 69
3656: PUSH
3657: LD_INT 1
3659: ARRAY
3660: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3661: LD_ADDR_VAR 0 9
3665: PUSH
3666: LD_INT 22
3668: PUSH
3669: LD_INT 4
3671: PUSH
3672: EMPTY
3673: LIST
3674: LIST
3675: PUSH
3676: LD_INT 30
3678: PUSH
3679: LD_INT 4
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PPUSH
3690: CALL_OW 69
3694: PUSH
3695: LD_INT 1
3697: ARRAY
3698: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3699: LD_ADDR_VAR 0 10
3703: PUSH
3704: LD_INT 22
3706: PUSH
3707: LD_INT 4
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 30
3716: PUSH
3717: LD_INT 2
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PPUSH
3728: CALL_OW 69
3732: PUSH
3733: LD_INT 1
3735: ARRAY
3736: ST_TO_ADDR
// for i in tmp do
3737: LD_ADDR_VAR 0 2
3741: PUSH
3742: LD_VAR 0 6
3746: PUSH
3747: FOR_IN
3748: IFFALSE 3874
// begin cl := GetClass ( i ) ;
3750: LD_ADDR_VAR 0 5
3754: PUSH
3755: LD_VAR 0 2
3759: PPUSH
3760: CALL_OW 257
3764: ST_TO_ADDR
// if cl > 4 then
3765: LD_VAR 0 5
3769: PUSH
3770: LD_INT 4
3772: GREATER
3773: IFFALSE 3783
// cl := 1 ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_INT 1
3782: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3783: LD_ADDR_VAR 0 3
3787: PUSH
3788: LD_VAR 0 9
3792: PUSH
3793: LD_VAR 0 7
3797: PUSH
3798: LD_VAR 0 10
3802: PUSH
3803: LD_VAR 0 8
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: PUSH
3814: LD_VAR 0 5
3818: ARRAY
3819: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3820: LD_VAR 0 3
3824: PPUSH
3825: CALL_OW 313
3829: PUSH
3830: LD_INT 5
3832: LESS
3833: IFFALSE 3851
// PlaceHumanInUnit ( i , b ) else
3835: LD_VAR 0 2
3839: PPUSH
3840: LD_VAR 0 3
3844: PPUSH
3845: CALL_OW 52
3849: GO 3872
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3851: LD_VAR 0 2
3855: PPUSH
3856: LD_INT 58
3858: PPUSH
3859: LD_INT 91
3861: PPUSH
3862: LD_INT 6
3864: PPUSH
3865: LD_INT 0
3867: PPUSH
3868: CALL_OW 50
// end ;
3872: GO 3747
3874: POP
3875: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3876: LD_INT 2
3878: PPUSH
3879: LD_INT 1
3881: PPUSH
3882: LD_INT 1
3884: PPUSH
3885: LD_INT 12
3887: PPUSH
3888: LD_INT 100
3890: PPUSH
3891: CALL 68298 0 5
// veh := CreateVehicle ;
3895: LD_ADDR_VAR 0 4
3899: PUSH
3900: CALL_OW 45
3904: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3905: LD_VAR 0 4
3909: PPUSH
3910: LD_INT 4
3912: PPUSH
3913: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3917: LD_VAR 0 4
3921: PPUSH
3922: LD_INT 49
3924: PPUSH
3925: LD_INT 88
3927: PPUSH
3928: LD_INT 0
3930: PPUSH
3931: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3935: LD_VAR 0 4
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_INT 100
3945: PPUSH
3946: CALL_OW 290
// uc_side := 0 ;
3950: LD_ADDR_OWVAR 20
3954: PUSH
3955: LD_INT 0
3957: ST_TO_ADDR
// uc_nation := 0 ;
3958: LD_ADDR_OWVAR 21
3962: PUSH
3963: LD_INT 0
3965: ST_TO_ADDR
// for i = 1 to 4 do
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 4
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4011
// begin InitHc ;
3982: CALL_OW 19
// hc_class := class_apeman ;
3986: LD_ADDR_OWVAR 28
3990: PUSH
3991: LD_INT 12
3993: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
3994: CALL_OW 44
3998: PPUSH
3999: LD_INT 13
4001: PPUSH
4002: LD_INT 0
4004: PPUSH
4005: CALL_OW 49
// end ;
4009: GO 3979
4011: POP
4012: POP
// end ; end_of_file
4013: LD_VAR 0 1
4017: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4018: LD_INT 0
4020: PPUSH
4021: PPUSH
4022: PPUSH
4023: PPUSH
4024: PPUSH
// side := 8 ;
4025: LD_ADDR_VAR 0 3
4029: PUSH
4030: LD_INT 8
4032: ST_TO_ADDR
// uc_side := side ;
4033: LD_ADDR_OWVAR 20
4037: PUSH
4038: LD_VAR 0 3
4042: ST_TO_ADDR
// uc_nation := 2 ;
4043: LD_ADDR_OWVAR 21
4047: PUSH
4048: LD_INT 2
4050: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4051: LD_ADDR_VAR 0 2
4055: PUSH
4056: LD_INT 22
4058: PUSH
4059: LD_VAR 0 3
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: PUSH
4068: LD_INT 21
4070: PUSH
4071: LD_INT 3
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: PPUSH
4082: CALL_OW 69
4086: PUSH
4087: FOR_IN
4088: IFFALSE 4104
// SetBLevel ( i , 10 ) ;
4090: LD_VAR 0 2
4094: PPUSH
4095: LD_INT 10
4097: PPUSH
4098: CALL_OW 241
4102: GO 4087
4104: POP
4105: POP
// if KurtStatus then
4106: LD_EXP 3
4110: IFFALSE 4133
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4112: LD_ADDR_EXP 57
4116: PUSH
4117: LD_STRING Kurt
4119: PPUSH
4120: LD_INT 0
4122: PPUSH
4123: LD_STRING 
4125: PPUSH
4126: CALL 61665 0 3
4130: ST_TO_ADDR
4131: GO 4155
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4133: LD_ADDR_EXP 57
4137: PUSH
4138: LD_STRING AltKurt
4140: PPUSH
4141: LD_EXP 1
4145: NOT
4146: PPUSH
4147: LD_STRING 
4149: PPUSH
4150: CALL 61665 0 3
4154: ST_TO_ADDR
// if not Kurt then
4155: LD_EXP 57
4159: NOT
4160: IFFALSE 4186
// begin InitHc ;
4162: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 10
4171: PPUSH
4172: CALL_OW 381
// Kurt := CreateHuman ;
4176: LD_ADDR_EXP 57
4180: PUSH
4181: CALL_OW 44
4185: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4186: LD_EXP 57
4190: PPUSH
4191: LD_INT 324
4193: PPUSH
4194: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4198: LD_ADDR_EXP 58
4202: PUSH
4203: LD_STRING Kozlov
4205: PPUSH
4206: LD_INT 0
4208: PPUSH
4209: LD_STRING 
4211: PPUSH
4212: CALL 61665 0 3
4216: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4217: LD_EXP 58
4221: PPUSH
4222: LD_INT 22
4224: PUSH
4225: LD_INT 8
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 23
4234: PUSH
4235: LD_INT 3
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 8
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: LIST
4256: PPUSH
4257: CALL_OW 69
4261: PUSH
4262: LD_INT 1
4264: ARRAY
4265: PPUSH
4266: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4270: LD_EXP 58
4274: PPUSH
4275: LD_INT 3
4277: PPUSH
4278: LD_INT 10
4280: PPUSH
4281: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4285: LD_ADDR_VAR 0 5
4289: PUSH
4290: LD_INT 22
4292: PUSH
4293: LD_VAR 0 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 30
4304: PUSH
4305: LD_INT 32
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 58
4314: PUSH
4315: EMPTY
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: LIST
4322: PPUSH
4323: CALL_OW 69
4327: ST_TO_ADDR
// for i = 1 to 10 do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: DOUBLE
4334: LD_INT 1
4336: DEC
4337: ST_TO_ADDR
4338: LD_INT 10
4340: PUSH
4341: FOR_TO
4342: IFFALSE 4414
// begin uc_nation := nation_nature ;
4344: LD_ADDR_OWVAR 21
4348: PUSH
4349: LD_INT 0
4351: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4352: LD_ADDR_OWVAR 28
4356: PUSH
4357: LD_INT 15
4359: ST_TO_ADDR
// hc_gallery :=  ;
4360: LD_ADDR_OWVAR 33
4364: PUSH
4365: LD_STRING 
4367: ST_TO_ADDR
// hc_name :=  ;
4368: LD_ADDR_OWVAR 26
4372: PUSH
4373: LD_STRING 
4375: ST_TO_ADDR
// un := CreateHuman ;
4376: LD_ADDR_VAR 0 4
4380: PUSH
4381: CALL_OW 44
4385: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_VAR 0 5
4395: PUSH
4396: LD_VAR 0 5
4400: PUSH
4401: LD_VAR 0 2
4405: MINUS
4406: ARRAY
4407: PPUSH
4408: CALL_OW 52
// end ;
4412: GO 4341
4414: POP
4415: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4416: LD_ADDR_VAR 0 5
4420: PUSH
4421: LD_STRING 12_kurt_squad
4423: PPUSH
4424: CALL_OW 31
4428: ST_TO_ADDR
// if tmp then
4429: LD_VAR 0 5
4433: IFFALSE 4467
// for i in tmp do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: LD_VAR 0 5
4444: PUSH
4445: FOR_IN
4446: IFFALSE 4465
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4448: LD_VAR 0 2
4452: PPUSH
4453: LD_INT 5
4455: PPUSH
4456: LD_INT 0
4458: PPUSH
4459: CALL_OW 49
4463: GO 4445
4465: POP
4466: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4467: LD_INT 324
4469: PPUSH
4470: LD_INT 5
4472: PPUSH
4473: LD_STRING 
4475: PPUSH
4476: LD_INT 8
4478: PUSH
4479: LD_INT 9
4481: PUSH
4482: LD_INT 10
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: LIST
4489: PUSH
4490: LD_OWVAR 67
4494: ARRAY
4495: PPUSH
4496: LD_INT 3000
4498: PUSH
4499: LD_INT 500
4501: PUSH
4502: LD_INT 150
4504: PUSH
4505: EMPTY
4506: LIST
4507: LIST
4508: LIST
4509: PPUSH
4510: LD_INT 16
4512: PUSH
4513: LD_INT 6
4515: PUSH
4516: LD_INT 6
4518: PUSH
4519: LD_INT 8
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: PPUSH
4528: CALL 71707 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4532: LD_ADDR_EXP 99
4536: PUSH
4537: LD_EXP 99
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: LD_INT 22
4547: PUSH
4548: LD_VAR 0 3
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 23
4559: PUSH
4560: LD_INT 2
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: LD_INT 3
4569: PUSH
4570: LD_INT 21
4572: PUSH
4573: LD_INT 2
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: LIST
4588: PPUSH
4589: CALL_OW 69
4593: PUSH
4594: LD_EXP 57
4598: DIFF
4599: PPUSH
4600: CALL_OW 1
4604: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4605: LD_INT 1
4607: PPUSH
4608: LD_INT 7
4610: PPUSH
4611: CALL_OW 383
// Friend := CreateHuman ;
4615: LD_ADDR_EXP 59
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4625: LD_INT 14
4627: PPUSH
4628: LD_INT 3
4630: PPUSH
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 29
4636: PPUSH
4637: LD_INT 100
4639: PPUSH
4640: CALL 68298 0 5
// powellBomb := CreateVehicle ;
4644: LD_ADDR_EXP 60
4648: PUSH
4649: CALL_OW 45
4653: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4654: LD_EXP 60
4658: PPUSH
4659: LD_INT 90
4661: PPUSH
4662: LD_INT 51
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 48
// end ;
4672: LD_VAR 0 1
4676: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if IsLive ( kozlov_fac ) then
4682: LD_INT 332
4684: PPUSH
4685: CALL_OW 300
4689: IFFALSE 4693
// exit ;
4691: GO 5260
// ComExitBuilding ( Kozlov ) ;
4693: LD_EXP 58
4697: PPUSH
4698: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4702: LD_EXP 58
4706: PPUSH
4707: CALL_OW 257
4711: PUSH
4712: LD_INT 2
4714: NONEQUAL
4715: IFFALSE 4750
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4717: LD_EXP 58
4721: PPUSH
4722: LD_INT 324
4724: PPUSH
4725: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4729: LD_EXP 58
4733: PPUSH
4734: LD_INT 2
4736: PPUSH
4737: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4741: LD_EXP 58
4745: PPUSH
4746: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4750: LD_EXP 58
4754: PPUSH
4755: LD_INT 2
4757: PPUSH
4758: LD_INT 93
4760: PPUSH
4761: LD_INT 32
4763: PPUSH
4764: LD_INT 3
4766: PPUSH
4767: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4771: LD_INT 35
4773: PPUSH
4774: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4778: LD_INT 22
4780: PUSH
4781: LD_INT 8
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PUSH
4788: LD_INT 30
4790: PUSH
4791: LD_INT 3
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 23
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 57
4810: PUSH
4811: EMPTY
4812: LIST
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: IFFALSE 4771
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4826: LD_ADDR_VAR 0 2
4830: PUSH
4831: LD_INT 22
4833: PUSH
4834: LD_INT 8
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PUSH
4841: LD_INT 30
4843: PUSH
4844: LD_INT 3
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PUSH
4851: LD_INT 23
4853: PUSH
4854: LD_INT 3
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: PUSH
4861: LD_INT 57
4863: PUSH
4864: EMPTY
4865: LIST
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: CALL_OW 69
4877: PUSH
4878: LD_INT 1
4880: ARRAY
4881: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 21
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: NOT
4922: IFFALSE 5000
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4924: LD_EXP 58
4928: PPUSH
4929: LD_INT 21
4931: PPUSH
4932: LD_INT 97
4934: PPUSH
4935: LD_INT 36
4937: PPUSH
4938: LD_INT 5
4940: PPUSH
4941: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4945: LD_INT 35
4947: PPUSH
4948: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4952: LD_INT 22
4954: PUSH
4955: LD_INT 8
4957: PUSH
4958: EMPTY
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 23
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PUSH
4972: LD_INT 30
4974: PUSH
4975: LD_INT 21
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: LD_INT 57
4984: PUSH
4985: EMPTY
4986: LIST
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: PPUSH
4994: CALL_OW 69
4998: IFFALSE 4945
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5000: LD_INT 22
5002: PUSH
5003: LD_INT 8
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: LD_INT 23
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 30
5022: PUSH
5023: LD_INT 18
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: NOT
5040: IFFALSE 5118
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5042: LD_EXP 58
5046: PPUSH
5047: LD_INT 18
5049: PPUSH
5050: LD_INT 89
5052: PPUSH
5053: LD_INT 32
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5063: LD_INT 35
5065: PPUSH
5066: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5070: LD_INT 22
5072: PUSH
5073: LD_INT 8
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 23
5082: PUSH
5083: LD_INT 3
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: LD_INT 30
5092: PUSH
5093: LD_INT 18
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: PUSH
5100: LD_INT 57
5102: PUSH
5103: EMPTY
5104: LIST
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: PPUSH
5112: CALL_OW 69
5116: IFFALSE 5063
// end ; lab := kozlov_lab ;
5118: LD_ADDR_VAR 0 3
5122: PUSH
5123: LD_INT 336
5125: ST_TO_ADDR
// if not lab then
5126: LD_VAR 0 3
5130: NOT
5131: IFFALSE 5135
// exit ;
5133: GO 5260
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5135: LD_EXP 58
5139: PPUSH
5140: LD_VAR 0 3
5144: PUSH
5145: LD_INT 1
5147: ARRAY
5148: PPUSH
5149: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5153: LD_EXP 58
5157: PPUSH
5158: LD_INT 4
5160: PPUSH
5161: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5165: LD_VAR 0 3
5169: PUSH
5170: LD_INT 1
5172: ARRAY
5173: PPUSH
5174: LD_INT 25
5176: PPUSH
5177: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5181: LD_INT 35
5183: PPUSH
5184: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5188: LD_INT 25
5190: PPUSH
5191: LD_INT 8
5193: PPUSH
5194: CALL_OW 321
5198: PUSH
5199: LD_INT 2
5201: EQUAL
5202: IFFALSE 5181
// ComExitBuilding ( Kozlov ) ;
5204: LD_EXP 58
5208: PPUSH
5209: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5213: LD_EXP 58
5217: PPUSH
5218: LD_VAR 0 2
5222: PPUSH
5223: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5227: LD_EXP 58
5231: PPUSH
5232: LD_INT 3
5234: PPUSH
5235: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5239: LD_VAR 0 2
5243: PPUSH
5244: LD_INT 23
5246: PPUSH
5247: LD_INT 3
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: LD_INT 48
5255: PPUSH
5256: CALL_OW 125
// end ;
5260: LD_VAR 0 1
5264: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5265: LD_EXP 22
5269: NOT
5270: PUSH
5271: LD_EXP 15
5275: PUSH
5276: LD_INT 6
5278: GREATEREQUAL
5279: AND
5280: IFFALSE 5361
5282: GO 5284
5284: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5285: LD_INT 3
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 55870 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 14
5300: PUSH
5301: LD_INT 1
5303: PUSH
5304: LD_INT 1
5306: PUSH
5307: LD_INT 28
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 14
5318: PUSH
5319: LD_INT 1
5321: PUSH
5322: LD_INT 1
5324: PUSH
5325: LD_INT 28
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: LIST
5332: LIST
5333: PUSH
5334: LD_INT 14
5336: PUSH
5337: LD_INT 1
5339: PUSH
5340: LD_INT 1
5342: PUSH
5343: LD_INT 28
5345: PUSH
5346: EMPTY
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL 55733 0 2
// end ;
5361: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5362: LD_EXP 22
5366: NOT
5367: PUSH
5368: LD_EXP 15
5372: PUSH
5373: LD_INT 6
5375: GREATEREQUAL
5376: AND
5377: PUSH
5378: LD_INT 3
5380: PPUSH
5381: LD_INT 1
5383: PPUSH
5384: CALL 57088 0 2
5388: NOT
5389: AND
5390: IFFALSE 6230
5392: GO 5394
5394: DISABLE
5395: LD_INT 0
5397: PPUSH
5398: PPUSH
5399: PPUSH
// begin enable ;
5400: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5401: LD_INT 22
5403: PUSH
5404: LD_INT 8
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: LD_INT 23
5413: PUSH
5414: LD_INT 2
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: LD_INT 30
5423: PUSH
5424: LD_INT 3
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: LIST
5435: PPUSH
5436: CALL_OW 69
5440: NOT
5441: IFFALSE 5445
// exit ;
5443: GO 6230
// if Prob ( 40 ) then
5445: LD_INT 40
5447: PPUSH
5448: CALL_OW 13
5452: IFFALSE 5579
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5454: LD_INT 3
5456: PPUSH
5457: LD_INT 14
5459: PUSH
5460: LD_INT 1
5462: PUSH
5463: LD_INT 2
5465: PUSH
5466: LD_INT 28
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: LIST
5473: LIST
5474: PUSH
5475: LD_INT 14
5477: PUSH
5478: LD_INT 1
5480: PUSH
5481: LD_INT 2
5483: PUSH
5484: LD_INT 28
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 14
5495: PUSH
5496: LD_INT 1
5498: PUSH
5499: LD_INT 2
5501: PUSH
5502: LD_INT 28
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 14
5513: PUSH
5514: LD_INT 1
5516: PUSH
5517: LD_INT 2
5519: PUSH
5520: LD_INT 28
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 14
5531: PUSH
5532: LD_INT 1
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: LD_INT 28
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: LIST
5546: PUSH
5547: LD_INT 14
5549: PUSH
5550: LD_INT 1
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: LD_INT 26
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: LIST
5563: LIST
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: LIST
5572: PPUSH
5573: CALL 55733 0 2
// end else
5577: GO 5770
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5579: LD_INT 3
5581: PPUSH
5582: LD_INT 14
5584: PUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 2
5590: PUSH
5591: LD_INT 27
5593: PUSH
5594: LD_INT 26
5596: PUSH
5597: LD_INT 26
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_OWVAR 67
5609: ARRAY
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 14
5619: PUSH
5620: LD_INT 1
5622: PUSH
5623: LD_INT 2
5625: PUSH
5626: LD_INT 27
5628: PUSH
5629: LD_INT 26
5631: PUSH
5632: LD_INT 26
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_OWVAR 67
5644: ARRAY
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 14
5654: PUSH
5655: LD_INT 1
5657: PUSH
5658: LD_INT 2
5660: PUSH
5661: LD_INT 26
5663: PUSH
5664: LD_INT 26
5666: PUSH
5667: LD_INT 29
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_OWVAR 67
5679: ARRAY
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: PUSH
5687: LD_INT 13
5689: PUSH
5690: LD_INT 1
5692: PUSH
5693: LD_INT 2
5695: PUSH
5696: LD_INT 26
5698: PUSH
5699: LD_INT 29
5701: PUSH
5702: LD_INT 29
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: LD_INT 13
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 29
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: PUSH
5740: LD_INT 14
5742: PUSH
5743: LD_INT 1
5745: PUSH
5746: LD_INT 2
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: LIST
5756: LIST
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: LIST
5765: PPUSH
5766: CALL 55733 0 2
// end ; repeat wait ( 0 0$1 ) ;
5770: LD_INT 35
5772: PPUSH
5773: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5777: LD_INT 3
5779: PPUSH
5780: LD_INT 1
5782: PPUSH
5783: CALL 57088 0 2
5787: PUSH
5788: LD_INT 6
5790: GREATEREQUAL
5791: IFFALSE 5770
// wait ( 0 0$30 ) ;
5793: LD_INT 1050
5795: PPUSH
5796: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 3
5807: PPUSH
5808: LD_INT 1
5810: PPUSH
5811: CALL 57088 0 2
5815: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5816: LD_ADDR_EXP 118
5820: PUSH
5821: LD_EXP 118
5825: PPUSH
5826: LD_INT 3
5828: PPUSH
5829: LD_EXP 118
5833: PUSH
5834: LD_INT 3
5836: ARRAY
5837: PUSH
5838: LD_VAR 0 2
5842: DIFF
5843: PPUSH
5844: CALL_OW 1
5848: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5849: LD_ADDR_VAR 0 3
5853: PUSH
5854: LD_INT 0
5856: PPUSH
5857: LD_INT 2
5859: PPUSH
5860: CALL_OW 12
5864: ST_TO_ADDR
// if target then
5865: LD_VAR 0 3
5869: IFFALSE 5997
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5871: LD_ADDR_VAR 0 2
5875: PUSH
5876: LD_VAR 0 2
5880: PPUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 250
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PPUSH
5891: CALL_OW 72
5895: ST_TO_ADDR
// for i in tmp do
5896: LD_ADDR_VAR 0 1
5900: PUSH
5901: LD_VAR 0 2
5905: PUSH
5906: FOR_IN
5907: IFFALSE 5947
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5909: LD_VAR 0 1
5913: PPUSH
5914: LD_INT 89
5916: PPUSH
5917: LD_INT 71
5919: PPUSH
5920: CALL_OW 297
5924: PUSH
5925: LD_INT 9
5927: GREATER
5928: IFFALSE 5945
// ComMoveXY ( i , 89 , 71 ) ;
5930: LD_VAR 0 1
5934: PPUSH
5935: LD_INT 89
5937: PPUSH
5938: LD_INT 71
5940: PPUSH
5941: CALL_OW 111
5945: GO 5906
5947: POP
5948: POP
// wait ( 0 0$1 ) ;
5949: LD_INT 35
5951: PPUSH
5952: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
5956: LD_VAR 0 2
5960: PPUSH
5961: LD_INT 92
5963: PUSH
5964: LD_INT 89
5966: PUSH
5967: LD_INT 71
5969: PUSH
5970: LD_INT 9
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PPUSH
5979: CALL_OW 72
5983: PUSH
5984: LD_VAR 0 2
5988: PUSH
5989: LD_INT 1
5991: MINUS
5992: GREATEREQUAL
5993: IFFALSE 5871
// end else
5995: GO 6121
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5997: LD_ADDR_VAR 0 2
6001: PUSH
6002: LD_VAR 0 2
6006: PPUSH
6007: LD_INT 24
6009: PUSH
6010: LD_INT 250
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: PPUSH
6017: CALL_OW 72
6021: ST_TO_ADDR
// for i in tmp do
6022: LD_ADDR_VAR 0 1
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: FOR_IN
6033: IFFALSE 6073
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6035: LD_VAR 0 1
6039: PPUSH
6040: LD_INT 125
6042: PPUSH
6043: LD_INT 129
6045: PPUSH
6046: CALL_OW 297
6050: PUSH
6051: LD_INT 9
6053: GREATER
6054: IFFALSE 6071
// ComMoveXY ( i , 125 , 129 ) ;
6056: LD_VAR 0 1
6060: PPUSH
6061: LD_INT 125
6063: PPUSH
6064: LD_INT 129
6066: PPUSH
6067: CALL_OW 111
6071: GO 6032
6073: POP
6074: POP
// wait ( 0 0$1 ) ;
6075: LD_INT 35
6077: PPUSH
6078: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6082: LD_VAR 0 2
6086: PPUSH
6087: LD_INT 92
6089: PUSH
6090: LD_INT 125
6092: PUSH
6093: LD_INT 129
6095: PUSH
6096: LD_INT 9
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 72
6109: PUSH
6110: LD_VAR 0 2
6114: PUSH
6115: LD_INT 1
6117: MINUS
6118: GREATEREQUAL
6119: IFFALSE 5997
// end ; repeat wait ( 0 0$1 ) ;
6121: LD_INT 35
6123: PPUSH
6124: CALL_OW 67
// for i in tmp do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: LD_VAR 0 2
6137: PUSH
6138: FOR_IN
6139: IFFALSE 6221
// begin if GetLives ( i ) > 251 then
6141: LD_VAR 0 1
6145: PPUSH
6146: CALL_OW 256
6150: PUSH
6151: LD_INT 251
6153: GREATER
6154: IFFALSE 6192
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6156: LD_VAR 0 1
6160: PPUSH
6161: LD_INT 81
6163: PUSH
6164: LD_INT 8
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PPUSH
6171: CALL_OW 69
6175: PPUSH
6176: LD_VAR 0 1
6180: PPUSH
6181: CALL_OW 74
6185: PPUSH
6186: CALL_OW 115
6190: GO 6219
// if IsDead ( i ) then
6192: LD_VAR 0 1
6196: PPUSH
6197: CALL_OW 301
6201: IFFALSE 6219
// tmp := tmp diff i ;
6203: LD_ADDR_VAR 0 2
6207: PUSH
6208: LD_VAR 0 2
6212: PUSH
6213: LD_VAR 0 1
6217: DIFF
6218: ST_TO_ADDR
// end ;
6219: GO 6138
6221: POP
6222: POP
// until not tmp ;
6223: LD_VAR 0 2
6227: NOT
6228: IFFALSE 6121
// end ;
6230: PPOPN 3
6232: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6233: LD_EXP 22
6237: NOT
6238: PUSH
6239: LD_EXP 15
6243: PUSH
6244: LD_INT 6
6246: GREATEREQUAL
6247: AND
6248: PUSH
6249: LD_OWVAR 67
6253: PUSH
6254: LD_INT 1
6256: GREATER
6257: AND
6258: IFFALSE 6775
6260: GO 6262
6262: DISABLE
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
// begin enable ;
6268: ENABLE
// tmp := [ ] ;
6269: LD_ADDR_VAR 0 3
6273: PUSH
6274: EMPTY
6275: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6276: LD_ADDR_VAR 0 1
6280: PUSH
6281: DOUBLE
6282: LD_INT 1
6284: DEC
6285: ST_TO_ADDR
6286: LD_INT 4
6288: PUSH
6289: LD_INT 6
6291: PUSH
6292: LD_INT 7
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PUSH
6306: FOR_TO
6307: IFFALSE 6467
// begin uc_side := 8 ;
6309: LD_ADDR_OWVAR 20
6313: PUSH
6314: LD_INT 8
6316: ST_TO_ADDR
// uc_nation := 2 ;
6317: LD_ADDR_OWVAR 21
6321: PUSH
6322: LD_INT 2
6324: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6325: LD_INT 13
6327: PUSH
6328: LD_INT 14
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 1
6337: PPUSH
6338: LD_INT 2
6340: PPUSH
6341: CALL_OW 12
6345: ARRAY
6346: PPUSH
6347: LD_INT 1
6349: PPUSH
6350: LD_INT 5
6352: PPUSH
6353: LD_INT 27
6355: PUSH
6356: LD_INT 28
6358: PUSH
6359: LD_INT 26
6361: PUSH
6362: LD_INT 25
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: PUSH
6371: LD_INT 1
6373: PPUSH
6374: LD_INT 4
6376: PPUSH
6377: CALL_OW 12
6381: ARRAY
6382: PPUSH
6383: LD_INT 88
6385: PPUSH
6386: CALL 68298 0 5
// un := CreateVehicle ;
6390: LD_ADDR_VAR 0 2
6394: PUSH
6395: CALL_OW 45
6399: ST_TO_ADDR
// tmp := tmp ^ un ;
6400: LD_ADDR_VAR 0 3
6404: PUSH
6405: LD_VAR 0 3
6409: PUSH
6410: LD_VAR 0 2
6414: ADD
6415: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6416: LD_VAR 0 2
6420: PPUSH
6421: LD_INT 3
6423: PPUSH
6424: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6428: LD_VAR 0 2
6432: PPUSH
6433: LD_INT 30
6435: PPUSH
6436: LD_INT 0
6438: PPUSH
6439: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6443: LD_VAR 0 2
6447: PPUSH
6448: LD_INT 16
6450: PPUSH
6451: LD_INT 11
6453: PPUSH
6454: CALL_OW 111
// wait ( 0 0$2 ) ;
6458: LD_INT 70
6460: PPUSH
6461: CALL_OW 67
// end ;
6465: GO 6306
6467: POP
6468: POP
// for i = 1 to Difficulty do
6469: LD_ADDR_VAR 0 1
6473: PUSH
6474: DOUBLE
6475: LD_INT 1
6477: DEC
6478: ST_TO_ADDR
6479: LD_OWVAR 67
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6610
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6503: LD_INT 0
6505: PPUSH
6506: LD_INT 8
6508: PPUSH
6509: LD_INT 8
6511: PUSH
6512: LD_INT 8
6514: PUSH
6515: LD_INT 9
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: PUSH
6523: LD_OWVAR 67
6527: ARRAY
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 2
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// tmp := tmp ^ un ;
6543: LD_ADDR_VAR 0 3
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_VAR 0 2
6557: ADD
6558: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6559: LD_VAR 0 2
6563: PPUSH
6564: LD_INT 3
6566: PPUSH
6567: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6571: LD_VAR 0 2
6575: PPUSH
6576: LD_INT 30
6578: PPUSH
6579: LD_INT 0
6581: PPUSH
6582: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6586: LD_VAR 0 2
6590: PPUSH
6591: LD_INT 16
6593: PPUSH
6594: LD_INT 11
6596: PPUSH
6597: CALL_OW 111
// wait ( 0 0$2 ) ;
6601: LD_INT 70
6603: PPUSH
6604: CALL_OW 67
// end ;
6608: GO 6484
6610: POP
6611: POP
// repeat wait ( 0 0$1 ) ;
6612: LD_INT 35
6614: PPUSH
6615: CALL_OW 67
// for i in tmp do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 3
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6766
// begin if GetLives ( i ) > 250 then
6632: LD_VAR 0 1
6636: PPUSH
6637: CALL_OW 256
6641: PUSH
6642: LD_INT 250
6644: GREATER
6645: IFFALSE 6737
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6647: LD_INT 81
6649: PUSH
6650: LD_INT 8
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 91
6659: PUSH
6660: LD_VAR 0 1
6664: PUSH
6665: LD_INT 10
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: LIST
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PPUSH
6677: CALL_OW 69
6681: NOT
6682: IFFALSE 6701
// ComAgressiveMove ( i , 67 , 110 ) else
6684: LD_VAR 0 1
6688: PPUSH
6689: LD_INT 67
6691: PPUSH
6692: LD_INT 110
6694: PPUSH
6695: CALL_OW 114
6699: GO 6735
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6701: LD_VAR 0 1
6705: PPUSH
6706: LD_INT 81
6708: PUSH
6709: LD_INT 8
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 69
6720: PPUSH
6721: LD_VAR 0 1
6725: PPUSH
6726: CALL_OW 74
6730: PPUSH
6731: CALL_OW 115
// end else
6735: GO 6764
// if IsDead ( i ) then
6737: LD_VAR 0 1
6741: PPUSH
6742: CALL_OW 301
6746: IFFALSE 6764
// tmp := tmp diff i ;
6748: LD_ADDR_VAR 0 3
6752: PUSH
6753: LD_VAR 0 3
6757: PUSH
6758: LD_VAR 0 1
6762: DIFF
6763: ST_TO_ADDR
// end ;
6764: GO 6629
6766: POP
6767: POP
// until not tmp ;
6768: LD_VAR 0 3
6772: NOT
6773: IFFALSE 6612
// end ; end_of_file
6775: PPOPN 3
6777: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6778: LD_INT 0
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
6787: PPUSH
6788: PPUSH
// side := 3 ;
6789: LD_ADDR_VAR 0 6
6793: PUSH
6794: LD_INT 3
6796: ST_TO_ADDR
// uc_side := side ;
6797: LD_ADDR_OWVAR 20
6801: PUSH
6802: LD_VAR 0 6
6806: ST_TO_ADDR
// uc_nation := 3 ;
6807: LD_ADDR_OWVAR 21
6811: PUSH
6812: LD_INT 3
6814: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6815: LD_ADDR_VAR 0 2
6819: PUSH
6820: LD_INT 22
6822: PUSH
6823: LD_VAR 0 6
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: LD_INT 21
6834: PUSH
6835: LD_INT 3
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: PPUSH
6846: CALL_OW 69
6850: PUSH
6851: FOR_IN
6852: IFFALSE 6868
// SetBLevel ( i , 10 ) ;
6854: LD_VAR 0 2
6858: PPUSH
6859: LD_INT 10
6861: PPUSH
6862: CALL_OW 241
6866: GO 6851
6868: POP
6869: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6870: LD_ADDR_VAR 0 9
6874: PUSH
6875: LD_INT 22
6877: PUSH
6878: LD_VAR 0 6
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 30
6889: PUSH
6890: LD_INT 34
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PPUSH
6901: CALL_OW 69
6905: ST_TO_ADDR
// if teleport then
6906: LD_VAR 0 9
6910: IFFALSE 6931
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6912: LD_VAR 0 9
6916: PUSH
6917: LD_INT 1
6919: ARRAY
6920: PPUSH
6921: LD_INT 123
6923: PPUSH
6924: LD_INT 122
6926: PPUSH
6927: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6931: LD_ADDR_EXP 61
6935: PUSH
6936: LD_STRING Platonov
6938: PPUSH
6939: CALL_OW 25
6943: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6944: LD_ADDR_EXP 62
6948: PUSH
6949: LD_STRING Kovalyuk
6951: PPUSH
6952: CALL_OW 25
6956: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6957: LD_ADDR_EXP 64
6961: PUSH
6962: LD_STRING Yakotich
6964: PPUSH
6965: CALL_OW 25
6969: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6970: LD_ADDR_EXP 63
6974: PUSH
6975: LD_STRING Bystrov
6977: PPUSH
6978: CALL_OW 25
6982: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6983: LD_ADDR_EXP 65
6987: PUSH
6988: LD_STRING Gleb
6990: PPUSH
6991: CALL_OW 25
6995: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
6996: LD_STRING 03_Cornel
6998: PPUSH
6999: CALL_OW 28
7003: IFFALSE 7051
// begin Bierezov := NewCharacter ( Mikhail ) ;
7005: LD_ADDR_EXP 66
7009: PUSH
7010: LD_STRING Mikhail
7012: PPUSH
7013: CALL_OW 25
7017: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7018: LD_EXP 66
7022: PPUSH
7023: LD_INT 197
7025: PPUSH
7026: LD_INT 111
7028: PPUSH
7029: LD_INT 9
7031: PPUSH
7032: LD_INT 0
7034: PPUSH
7035: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7039: LD_EXP 66
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7051: LD_EXP 61
7055: PPUSH
7056: LD_INT 126
7058: PPUSH
7059: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7063: LD_EXP 62
7067: PPUSH
7068: LD_INT 134
7070: PPUSH
7071: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7075: LD_EXP 64
7079: PPUSH
7080: LD_INT 197
7082: PPUSH
7083: LD_INT 111
7085: PPUSH
7086: LD_INT 9
7088: PPUSH
7089: LD_INT 0
7091: PPUSH
7092: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7096: LD_EXP 63
7100: PPUSH
7101: LD_INT 197
7103: PPUSH
7104: LD_INT 111
7106: PPUSH
7107: LD_INT 9
7109: PPUSH
7110: LD_INT 0
7112: PPUSH
7113: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7117: LD_EXP 65
7121: PPUSH
7122: LD_INT 197
7124: PPUSH
7125: LD_INT 111
7127: PPUSH
7128: LD_INT 9
7130: PPUSH
7131: LD_INT 0
7133: PPUSH
7134: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7138: LD_ADDR_VAR 0 5
7142: PUSH
7143: LD_INT 126
7145: PPUSH
7146: LD_INT 4
7148: PPUSH
7149: LD_STRING zhukov
7151: PPUSH
7152: LD_INT 9
7154: PUSH
7155: LD_INT 10
7157: PUSH
7158: LD_INT 10
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: LD_OWVAR 67
7170: ARRAY
7171: PPUSH
7172: LD_INT 99999
7174: PUSH
7175: LD_INT 1000
7177: PUSH
7178: LD_INT 300
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: LD_INT 12
7188: PUSH
7189: LD_INT 8
7191: PUSH
7192: LD_INT 13
7194: PUSH
7195: LD_INT 8
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: LIST
7202: LIST
7203: PPUSH
7204: CALL 71707 0 6
7208: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7209: LD_ADDR_VAR 0 4
7213: PUSH
7214: LD_INT 267
7216: PPUSH
7217: CALL_OW 274
7221: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7222: LD_VAR 0 4
7226: PPUSH
7227: LD_INT 1
7229: PPUSH
7230: LD_INT 5000
7232: PPUSH
7233: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7237: LD_VAR 0 4
7241: PPUSH
7242: LD_INT 2
7244: PPUSH
7245: LD_INT 200
7247: PPUSH
7248: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7252: LD_VAR 0 4
7256: PPUSH
7257: LD_INT 3
7259: PPUSH
7260: LD_INT 200
7262: PPUSH
7263: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7267: LD_ADDR_EXP 99
7271: PUSH
7272: LD_EXP 99
7276: PPUSH
7277: LD_INT 2
7279: PPUSH
7280: LD_VAR 0 5
7284: PUSH
7285: LD_INT 22
7287: PUSH
7288: LD_VAR 0 6
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 3
7299: PUSH
7300: LD_INT 21
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: CALL_OW 69
7322: UNION
7323: PUSH
7324: LD_EXP 61
7328: DIFF
7329: PPUSH
7330: CALL_OW 1
7334: ST_TO_ADDR
// behemoths := [ ] ;
7335: LD_ADDR_EXP 69
7339: PUSH
7340: EMPTY
7341: ST_TO_ADDR
// behemothBuilders := [ ] ;
7342: LD_ADDR_EXP 70
7346: PUSH
7347: EMPTY
7348: ST_TO_ADDR
// if Kovalyuk then
7349: LD_EXP 62
7353: IFFALSE 7375
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7355: LD_ADDR_EXP 70
7359: PUSH
7360: LD_EXP 70
7364: PPUSH
7365: LD_EXP 62
7369: PPUSH
7370: CALL 103981 0 2
7374: ST_TO_ADDR
// j := 3 ;
7375: LD_ADDR_VAR 0 3
7379: PUSH
7380: LD_INT 3
7382: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7383: LD_ADDR_VAR 0 2
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 25
7400: PUSH
7401: LD_INT 3
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PPUSH
7412: CALL_OW 69
7416: PUSH
7417: LD_EXP 62
7421: DIFF
7422: PUSH
7423: FOR_IN
7424: IFFALSE 7474
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7426: LD_ADDR_EXP 70
7430: PUSH
7431: LD_EXP 70
7435: PPUSH
7436: LD_VAR 0 2
7440: PPUSH
7441: CALL 103981 0 2
7445: ST_TO_ADDR
// j := j - 1 ;
7446: LD_ADDR_VAR 0 3
7450: PUSH
7451: LD_VAR 0 3
7455: PUSH
7456: LD_INT 1
7458: MINUS
7459: ST_TO_ADDR
// if j = 0 then
7460: LD_VAR 0 3
7464: PUSH
7465: LD_INT 0
7467: EQUAL
7468: IFFALSE 7472
// break ;
7470: GO 7474
// end ;
7472: GO 7423
7474: POP
7475: POP
// end ;
7476: LD_VAR 0 1
7480: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7481: LD_INT 0
7483: PPUSH
7484: PPUSH
7485: PPUSH
7486: PPUSH
7487: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7488: LD_ADDR_VAR 0 4
7492: PUSH
7493: LD_INT 209
7495: PUSH
7496: LD_INT 149
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: LD_INT 219
7505: PUSH
7506: LD_INT 154
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PUSH
7513: LD_INT 223
7515: PUSH
7516: LD_INT 149
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: LD_INT 232
7525: PUSH
7526: LD_INT 155
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: LIST
7537: LIST
7538: ST_TO_ADDR
// if not behemothBuilders then
7539: LD_EXP 70
7543: NOT
7544: IFFALSE 7548
// exit ;
7546: GO 7652
// j := 1 ;
7548: LD_ADDR_VAR 0 3
7552: PUSH
7553: LD_INT 1
7555: ST_TO_ADDR
// for i in behemothBuilders do
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_EXP 70
7565: PUSH
7566: FOR_IN
7567: IFFALSE 7650
// begin if IsInUnit ( i ) then
7569: LD_VAR 0 2
7573: PPUSH
7574: CALL_OW 310
7578: IFFALSE 7589
// ComExitBuilding ( i ) ;
7580: LD_VAR 0 2
7584: PPUSH
7585: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7589: LD_VAR 0 2
7593: PPUSH
7594: LD_INT 37
7596: PPUSH
7597: LD_VAR 0 4
7601: PUSH
7602: LD_VAR 0 3
7606: ARRAY
7607: PUSH
7608: LD_INT 1
7610: ARRAY
7611: PPUSH
7612: LD_VAR 0 4
7616: PUSH
7617: LD_VAR 0 3
7621: ARRAY
7622: PUSH
7623: LD_INT 2
7625: ARRAY
7626: PPUSH
7627: LD_INT 0
7629: PPUSH
7630: CALL_OW 230
// j := j + 1 ;
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: LD_VAR 0 3
7643: PUSH
7644: LD_INT 1
7646: PLUS
7647: ST_TO_ADDR
// end ;
7648: GO 7566
7650: POP
7651: POP
// end ;
7652: LD_VAR 0 1
7656: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7657: LD_INT 24
7659: PPUSH
7660: LD_INT 30
7662: PUSH
7663: LD_INT 37
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PPUSH
7670: CALL_OW 70
7674: IFFALSE 7687
7676: GO 7678
7678: DISABLE
// behemothUnderConstruct := true ;
7679: LD_ADDR_EXP 26
7683: PUSH
7684: LD_INT 1
7686: ST_TO_ADDR
7687: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7688: LD_INT 3
7690: PPUSH
7691: CALL 104029 0 1
7695: PUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 30
7708: PUSH
7709: LD_INT 37
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: NOT
7725: AND
7726: IFFALSE 7912
7728: GO 7730
7730: DISABLE
7731: LD_INT 0
7733: PPUSH
7734: PPUSH
// begin enable ;
7735: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7736: LD_ADDR_VAR 0 2
7740: PUSH
7741: LD_INT 3
7743: PPUSH
7744: CALL 104029 0 1
7748: ST_TO_ADDR
// for i in tmp do
7749: LD_ADDR_VAR 0 1
7753: PUSH
7754: LD_VAR 0 2
7758: PUSH
7759: FOR_IN
7760: IFFALSE 7910
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 9
7769: PPUSH
7770: CALL_OW 308
7774: PUSH
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 110
7784: PUSH
7785: LD_INT 2
7787: EQUAL
7788: NOT
7789: AND
7790: IFFALSE 7804
// SetTag ( i , 2 ) ;
7792: LD_VAR 0 1
7796: PPUSH
7797: LD_INT 2
7799: PPUSH
7800: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7804: LD_INT 81
7806: PUSH
7807: LD_INT 3
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 91
7816: PUSH
7817: LD_VAR 0 1
7821: PUSH
7822: LD_INT 12
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: NOT
7839: PUSH
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 110
7849: PUSH
7850: LD_INT 2
7852: EQUAL
7853: NOT
7854: AND
7855: IFFALSE 7874
// ComAgressiveMove ( i , 64 , 93 ) else
7857: LD_VAR 0 1
7861: PPUSH
7862: LD_INT 64
7864: PPUSH
7865: LD_INT 93
7867: PPUSH
7868: CALL_OW 114
7872: GO 7908
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 81
7881: PUSH
7882: LD_INT 3
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PPUSH
7889: CALL_OW 69
7893: PPUSH
7894: LD_VAR 0 1
7898: PPUSH
7899: CALL_OW 74
7903: PPUSH
7904: CALL_OW 115
// end ;
7908: GO 7759
7910: POP
7911: POP
// end ;
7912: PPOPN 2
7914: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7915: LD_INT 0
7917: PPUSH
7918: PPUSH
7919: PPUSH
// result := [ ] ;
7920: LD_ADDR_VAR 0 2
7924: PUSH
7925: EMPTY
7926: ST_TO_ADDR
// uc_side := 6 ;
7927: LD_ADDR_OWVAR 20
7931: PUSH
7932: LD_INT 6
7934: ST_TO_ADDR
// uc_nation := 3 ;
7935: LD_ADDR_OWVAR 21
7939: PUSH
7940: LD_INT 3
7942: ST_TO_ADDR
// case strength of 1 :
7943: LD_VAR 0 1
7947: PUSH
7948: LD_INT 1
7950: DOUBLE
7951: EQUAL
7952: IFTRUE 7956
7954: GO 8094
7956: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7957: LD_ADDR_VAR 0 3
7961: PUSH
7962: DOUBLE
7963: LD_INT 1
7965: DEC
7966: ST_TO_ADDR
7967: LD_INT 4
7969: PUSH
7970: LD_INT 5
7972: PUSH
7973: LD_INT 6
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: LD_OWVAR 67
7985: ARRAY
7986: PUSH
7987: FOR_TO
7988: IFFALSE 8090
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7990: LD_INT 22
7992: PUSH
7993: LD_INT 24
7995: PUSH
7996: EMPTY
7997: LIST
7998: LIST
7999: PUSH
8000: LD_VAR 0 3
8004: PUSH
8005: LD_INT 2
8007: MOD
8008: PUSH
8009: LD_INT 1
8011: PLUS
8012: ARRAY
8013: PPUSH
8014: LD_INT 1
8016: PUSH
8017: LD_INT 3
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PUSH
8024: LD_INT 1
8026: PPUSH
8027: LD_INT 2
8029: PPUSH
8030: CALL_OW 12
8034: ARRAY
8035: PPUSH
8036: LD_INT 3
8038: PPUSH
8039: LD_INT 43
8041: PUSH
8042: LD_INT 44
8044: PUSH
8045: LD_INT 45
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: LIST
8052: PUSH
8053: LD_INT 1
8055: PPUSH
8056: LD_INT 3
8058: PPUSH
8059: CALL_OW 12
8063: ARRAY
8064: PPUSH
8065: LD_INT 80
8067: PPUSH
8068: CALL 68298 0 5
// result := result union CreateVehicle ;
8072: LD_ADDR_VAR 0 2
8076: PUSH
8077: LD_VAR 0 2
8081: PUSH
8082: CALL_OW 45
8086: UNION
8087: ST_TO_ADDR
// end ;
8088: GO 7987
8090: POP
8091: POP
// end ; 2 :
8092: GO 9038
8094: LD_INT 2
8096: DOUBLE
8097: EQUAL
8098: IFTRUE 8102
8100: GO 8258
8102: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8103: LD_ADDR_VAR 0 3
8107: PUSH
8108: DOUBLE
8109: LD_INT 1
8111: DEC
8112: ST_TO_ADDR
8113: LD_INT 6
8115: PUSH
8116: LD_INT 6
8118: PUSH
8119: LD_INT 7
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: LIST
8126: PUSH
8127: LD_OWVAR 67
8131: ARRAY
8132: PUSH
8133: FOR_TO
8134: IFFALSE 8254
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8136: LD_INT 22
8138: PUSH
8139: LD_INT 24
8141: PUSH
8142: LD_INT 24
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: PUSH
8150: LD_VAR 0 3
8154: PUSH
8155: LD_INT 3
8157: MOD
8158: PUSH
8159: LD_INT 1
8161: PLUS
8162: ARRAY
8163: PPUSH
8164: LD_INT 1
8166: PUSH
8167: LD_INT 3
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PUSH
8174: LD_INT 1
8176: PPUSH
8177: LD_INT 2
8179: PPUSH
8180: CALL_OW 12
8184: ARRAY
8185: PPUSH
8186: LD_INT 3
8188: PPUSH
8189: LD_INT 43
8191: PUSH
8192: LD_INT 44
8194: PUSH
8195: LD_INT 45
8197: PUSH
8198: LD_INT 44
8200: PUSH
8201: LD_INT 46
8203: PUSH
8204: LD_INT 46
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: LIST
8214: PUSH
8215: LD_VAR 0 3
8219: PUSH
8220: LD_INT 6
8222: MOD
8223: PUSH
8224: LD_INT 1
8226: PLUS
8227: ARRAY
8228: PPUSH
8229: LD_INT 80
8231: PPUSH
8232: CALL 68298 0 5
// result := result union CreateVehicle ;
8236: LD_ADDR_VAR 0 2
8240: PUSH
8241: LD_VAR 0 2
8245: PUSH
8246: CALL_OW 45
8250: UNION
8251: ST_TO_ADDR
// end ;
8252: GO 8133
8254: POP
8255: POP
// end ; 3 :
8256: GO 9038
8258: LD_INT 3
8260: DOUBLE
8261: EQUAL
8262: IFTRUE 8266
8264: GO 8422
8266: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8267: LD_ADDR_VAR 0 3
8271: PUSH
8272: DOUBLE
8273: LD_INT 1
8275: DEC
8276: ST_TO_ADDR
8277: LD_INT 6
8279: PUSH
8280: LD_INT 7
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: LIST
8290: PUSH
8291: LD_OWVAR 67
8295: ARRAY
8296: PUSH
8297: FOR_TO
8298: IFFALSE 8418
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8300: LD_INT 22
8302: PUSH
8303: LD_INT 24
8305: PUSH
8306: LD_INT 24
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_VAR 0 3
8318: PUSH
8319: LD_INT 3
8321: MOD
8322: PUSH
8323: LD_INT 1
8325: PLUS
8326: ARRAY
8327: PPUSH
8328: LD_INT 1
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 1
8340: PPUSH
8341: LD_INT 2
8343: PPUSH
8344: CALL_OW 12
8348: ARRAY
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: LD_INT 43
8355: PUSH
8356: LD_INT 47
8358: PUSH
8359: LD_INT 45
8361: PUSH
8362: LD_INT 45
8364: PUSH
8365: LD_INT 46
8367: PUSH
8368: LD_INT 46
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: LIST
8378: PUSH
8379: LD_VAR 0 3
8383: PUSH
8384: LD_INT 6
8386: MOD
8387: PUSH
8388: LD_INT 1
8390: PLUS
8391: ARRAY
8392: PPUSH
8393: LD_INT 80
8395: PPUSH
8396: CALL 68298 0 5
// result := result union CreateVehicle ;
8400: LD_ADDR_VAR 0 2
8404: PUSH
8405: LD_VAR 0 2
8409: PUSH
8410: CALL_OW 45
8414: UNION
8415: ST_TO_ADDR
// end ;
8416: GO 8297
8418: POP
8419: POP
// end ; 4 :
8420: GO 9038
8422: LD_INT 4
8424: DOUBLE
8425: EQUAL
8426: IFTRUE 8430
8428: GO 9037
8430: POP
// begin uc_nation := 3 ;
8431: LD_ADDR_OWVAR 21
8435: PUSH
8436: LD_INT 3
8438: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 7
8451: PUSH
8452: LD_INT 8
8454: PUSH
8455: LD_INT 9
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 45
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 47
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 68298 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// if not KappaStatus then
8592: LD_EXP 2
8596: NOT
8597: IFFALSE 8832
// begin uc_nation := 1 ;
8599: LD_ADDR_OWVAR 21
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// for i = 1 to 3 do
8607: LD_ADDR_VAR 0 3
8611: PUSH
8612: DOUBLE
8613: LD_INT 1
8615: DEC
8616: ST_TO_ADDR
8617: LD_INT 3
8619: PUSH
8620: FOR_TO
8621: IFFALSE 8757
// begin j := rand ( 0 , 1 ) ;
8623: LD_ADDR_VAR 0 4
8627: PUSH
8628: LD_INT 0
8630: PPUSH
8631: LD_INT 1
8633: PPUSH
8634: CALL_OW 12
8638: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8639: LD_INT 3
8641: PUSH
8642: LD_INT 5
8644: PUSH
8645: LD_INT 5
8647: PUSH
8648: LD_INT 4
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: PUSH
8657: LD_VAR 0 4
8661: PUSH
8662: LD_INT 1
8664: PPUSH
8665: LD_INT 3
8667: PPUSH
8668: CALL_OW 12
8672: PLUS
8673: ARRAY
8674: PPUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: PUSH
8685: LD_INT 1
8687: PPUSH
8688: LD_INT 2
8690: PPUSH
8691: CALL_OW 12
8695: ARRAY
8696: PPUSH
8697: LD_INT 3
8699: PPUSH
8700: LD_INT 9
8702: PUSH
8703: LD_INT 7
8705: PUSH
8706: LD_INT 6
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_VAR 0 4
8718: PUSH
8719: LD_INT 1
8721: PPUSH
8722: LD_INT 2
8724: PPUSH
8725: CALL_OW 12
8729: PLUS
8730: ARRAY
8731: PPUSH
8732: LD_INT 85
8734: PPUSH
8735: CALL 68298 0 5
// result := result union CreateVehicle ;
8739: LD_ADDR_VAR 0 2
8743: PUSH
8744: LD_VAR 0 2
8748: PUSH
8749: CALL_OW 45
8753: UNION
8754: ST_TO_ADDR
// end ;
8755: GO 8620
8757: POP
8758: POP
// if vsevolodFirstAttack then
8759: LD_EXP 24
8763: IFFALSE 8830
// begin vsevolodFirstAttack := false ;
8765: LD_ADDR_EXP 24
8769: PUSH
8770: LD_INT 0
8772: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8773: LD_INT 5
8775: PPUSH
8776: LD_INT 3
8778: PPUSH
8779: LD_INT 1
8781: PPUSH
8782: LD_INT 6
8784: PPUSH
8785: LD_INT 100
8787: PPUSH
8788: CALL 68298 0 5
// sewiVeh := CreateVehicle ;
8792: LD_ADDR_EXP 68
8796: PUSH
8797: CALL_OW 45
8801: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8802: LD_EXP 68
8806: PPUSH
8807: LD_INT 1
8809: PPUSH
8810: CALL_OW 242
// result := result union sewiVeh ;
8814: LD_ADDR_VAR 0 2
8818: PUSH
8819: LD_VAR 0 2
8823: PUSH
8824: LD_EXP 68
8828: UNION
8829: ST_TO_ADDR
// end ; end else
8830: GO 9035
// if vsevolodFirstAttack then
8832: LD_EXP 24
8836: IFFALSE 9035
// begin vsevolodFirstAttack := false ;
8838: LD_ADDR_EXP 24
8842: PUSH
8843: LD_INT 0
8845: ST_TO_ADDR
// uc_nation := 3 ;
8846: LD_ADDR_OWVAR 21
8850: PUSH
8851: LD_INT 3
8853: ST_TO_ADDR
// for i = 1 to 3 do
8854: LD_ADDR_VAR 0 3
8858: PUSH
8859: DOUBLE
8860: LD_INT 1
8862: DEC
8863: ST_TO_ADDR
8864: LD_INT 3
8866: PUSH
8867: FOR_TO
8868: IFFALSE 8976
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8870: LD_INT 22
8872: PUSH
8873: LD_INT 24
8875: PUSH
8876: LD_INT 24
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: LIST
8883: PUSH
8884: LD_VAR 0 3
8888: PUSH
8889: LD_INT 3
8891: MOD
8892: PUSH
8893: LD_INT 1
8895: PLUS
8896: ARRAY
8897: PPUSH
8898: LD_INT 1
8900: PUSH
8901: LD_INT 3
8903: PUSH
8904: EMPTY
8905: LIST
8906: LIST
8907: PUSH
8908: LD_INT 1
8910: PPUSH
8911: LD_INT 2
8913: PPUSH
8914: CALL_OW 12
8918: ARRAY
8919: PPUSH
8920: LD_INT 3
8922: PPUSH
8923: LD_INT 45
8925: PUSH
8926: LD_INT 47
8928: PUSH
8929: LD_INT 47
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: LIST
8936: PUSH
8937: LD_VAR 0 3
8941: PUSH
8942: LD_INT 3
8944: MOD
8945: PUSH
8946: LD_INT 1
8948: PLUS
8949: ARRAY
8950: PPUSH
8951: LD_INT 80
8953: PPUSH
8954: CALL 68298 0 5
// result := result union CreateVehicle ;
8958: LD_ADDR_VAR 0 2
8962: PUSH
8963: LD_VAR 0 2
8967: PUSH
8968: CALL_OW 45
8972: UNION
8973: ST_TO_ADDR
// end ;
8974: GO 8867
8976: POP
8977: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8978: LD_INT 24
8980: PPUSH
8981: LD_INT 3
8983: PPUSH
8984: LD_INT 1
8986: PPUSH
8987: LD_INT 47
8989: PPUSH
8990: LD_INT 100
8992: PPUSH
8993: CALL 68298 0 5
// sewiVeh := CreateVehicle ;
8997: LD_ADDR_EXP 68
9001: PUSH
9002: CALL_OW 45
9006: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9007: LD_EXP 68
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 242
// result := result union sewiVeh ;
9019: LD_ADDR_VAR 0 2
9023: PUSH
9024: LD_VAR 0 2
9028: PUSH
9029: LD_EXP 68
9033: UNION
9034: ST_TO_ADDR
// end ; end ; end ;
9035: GO 9038
9037: POP
// end ;
9038: LD_VAR 0 2
9042: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9043: LD_EXP 16
9047: IFFALSE 9779
9049: GO 9051
9051: DISABLE
9052: LD_INT 0
9054: PPUSH
9055: PPUSH
9056: PPUSH
9057: PPUSH
9058: PPUSH
9059: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9060: LD_ADDR_VAR 0 4
9064: PUSH
9065: LD_INT 11
9067: PUSH
9068: LD_INT 12
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9075: LD_ADDR_VAR 0 3
9079: PUSH
9080: LD_INT 8400
9082: PUSH
9083: LD_INT 7350
9085: PUSH
9086: LD_INT 6650
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: LIST
9093: PUSH
9094: LD_OWVAR 67
9098: ARRAY
9099: ST_TO_ADDR
// xy := [ [ 60 , 96 ] , [ 78 , 31 ] ] ;
9100: LD_ADDR_VAR 0 6
9104: PUSH
9105: LD_INT 60
9107: PUSH
9108: LD_INT 96
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: LD_INT 78
9117: PUSH
9118: LD_INT 31
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: ST_TO_ADDR
// repeat if missionStage = 2 then
9129: LD_EXP 15
9133: PUSH
9134: LD_INT 2
9136: EQUAL
9137: IFFALSE 9148
// wait ( 1 1$30 ) else
9139: LD_INT 3150
9141: PPUSH
9142: CALL_OW 67
9146: GO 9157
// wait ( time ) ;
9148: LD_VAR 0 3
9152: PPUSH
9153: CALL_OW 67
// if missionStage = 6 then
9157: LD_EXP 15
9161: PUSH
9162: LD_INT 6
9164: EQUAL
9165: IFFALSE 9193
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9167: LD_INT 51
9169: PPUSH
9170: LD_INT 6
9172: PPUSH
9173: LD_INT 2
9175: PPUSH
9176: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9180: LD_INT 57
9182: PPUSH
9183: LD_INT 6
9185: PPUSH
9186: LD_INT 2
9188: PPUSH
9189: CALL_OW 322
// end ; if missionStage = 8 then
9193: LD_EXP 15
9197: PUSH
9198: LD_INT 8
9200: EQUAL
9201: IFFALSE 9229
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9203: LD_INT 52
9205: PPUSH
9206: LD_INT 6
9208: PPUSH
9209: LD_INT 2
9211: PPUSH
9212: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9216: LD_INT 58
9218: PPUSH
9219: LD_INT 6
9221: PPUSH
9222: LD_INT 2
9224: PPUSH
9225: CALL_OW 322
// end ; if missionStage = 10 then
9229: LD_EXP 15
9233: PUSH
9234: LD_INT 10
9236: EQUAL
9237: IFFALSE 9265
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9239: LD_INT 53
9241: PPUSH
9242: LD_INT 6
9244: PPUSH
9245: LD_INT 2
9247: PPUSH
9248: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9252: LD_INT 59
9254: PPUSH
9255: LD_INT 6
9257: PPUSH
9258: LD_INT 2
9260: PPUSH
9261: CALL_OW 322
// end ; if activeAttacks then
9265: LD_EXP 16
9269: IFFALSE 9773
// begin if missionStage = 2 then
9271: LD_EXP 15
9275: PUSH
9276: LD_INT 2
9278: EQUAL
9279: IFFALSE 9289
// strength := 1 ;
9281: LD_ADDR_VAR 0 5
9285: PUSH
9286: LD_INT 1
9288: ST_TO_ADDR
// if missionStage > 2 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 2
9296: GREATER
9297: IFFALSE 9307
// strength := 2 ;
9299: LD_ADDR_VAR 0 5
9303: PUSH
9304: LD_INT 2
9306: ST_TO_ADDR
// if missionStage > 6 then
9307: LD_EXP 15
9311: PUSH
9312: LD_INT 6
9314: GREATER
9315: IFFALSE 9325
// strength := 3 ;
9317: LD_ADDR_VAR 0 5
9321: PUSH
9322: LD_INT 3
9324: ST_TO_ADDR
// if missionStage > 10 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: GREATER
9333: IFFALSE 9343
// strength := 4 ;
9335: LD_ADDR_VAR 0 5
9339: PUSH
9340: LD_INT 4
9342: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9343: LD_ADDR_VAR 0 2
9347: PUSH
9348: LD_VAR 0 5
9352: PPUSH
9353: CALL 7915 0 1
9357: ST_TO_ADDR
// for i in tmp do
9358: LD_ADDR_VAR 0 1
9362: PUSH
9363: LD_VAR 0 2
9367: PUSH
9368: FOR_IN
9369: IFFALSE 9469
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9371: LD_VAR 0 1
9375: PPUSH
9376: LD_VAR 0 4
9380: PUSH
9381: LD_INT 1
9383: PPUSH
9384: LD_INT 2
9386: PPUSH
9387: CALL_OW 12
9391: ARRAY
9392: PPUSH
9393: LD_INT 0
9395: PPUSH
9396: CALL_OW 49
// if i = sewiVeh then
9400: LD_VAR 0 1
9404: PUSH
9405: LD_EXP 68
9409: EQUAL
9410: IFFALSE 9445
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9412: LD_ADDR_EXP 67
9416: PUSH
9417: LD_STRING Vsevolod
9419: PPUSH
9420: LD_INT 0
9422: PPUSH
9423: LD_STRING 
9425: PPUSH
9426: CALL 61665 0 3
9430: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9431: LD_EXP 67
9435: PPUSH
9436: LD_VAR 0 1
9440: PPUSH
9441: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_INT 111
9452: PPUSH
9453: LD_INT 197
9455: PPUSH
9456: CALL_OW 111
// wait ( 0 0$2 ) ;
9460: LD_INT 70
9462: PPUSH
9463: CALL_OW 67
// end ;
9467: GO 9368
9469: POP
9470: POP
// repeat wait ( 0 0$1 ) ;
9471: LD_INT 35
9473: PPUSH
9474: CALL_OW 67
// for i in tmp do
9478: LD_ADDR_VAR 0 1
9482: PUSH
9483: LD_VAR 0 2
9487: PUSH
9488: FOR_IN
9489: IFFALSE 9754
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9491: LD_INT 81
9493: PUSH
9494: LD_INT 6
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PUSH
9501: LD_INT 91
9503: PUSH
9504: LD_VAR 0 1
9508: PUSH
9509: LD_INT 12
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: PPUSH
9521: CALL_OW 69
9525: IFFALSE 9583
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , i , 12 ] ] ) , i ) ) else
9527: LD_VAR 0 1
9531: PPUSH
9532: LD_INT 81
9534: PUSH
9535: LD_INT 6
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PUSH
9542: LD_INT 92
9544: PUSH
9545: LD_VAR 0 1
9549: PUSH
9550: LD_INT 12
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: PPUSH
9562: CALL_OW 69
9566: PPUSH
9567: LD_VAR 0 1
9571: PPUSH
9572: CALL_OW 74
9576: PPUSH
9577: CALL_OW 115
9581: GO 9752
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9583: LD_INT 9
9585: PPUSH
9586: LD_INT 81
9588: PUSH
9589: LD_INT 6
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 70
9600: IFFALSE 9718
// begin if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9602: LD_VAR 0 1
9606: PPUSH
9607: LD_VAR 0 6
9611: PUSH
9612: LD_INT 1
9614: ARRAY
9615: PPUSH
9616: LD_VAR 0 6
9620: PUSH
9621: LD_INT 2
9623: ARRAY
9624: PPUSH
9625: CALL_OW 297
9629: PUSH
9630: LD_INT 10
9632: GREATER
9633: PUSH
9634: LD_VAR 0 1
9638: PPUSH
9639: LD_INT 9
9641: PPUSH
9642: CALL_OW 308
9646: NOT
9647: AND
9648: IFFALSE 9679
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) else
9650: LD_VAR 0 1
9654: PPUSH
9655: LD_VAR 0 6
9659: PUSH
9660: LD_INT 1
9662: ARRAY
9663: PPUSH
9664: LD_VAR 0 6
9668: PUSH
9669: LD_INT 2
9671: ARRAY
9672: PPUSH
9673: CALL_OW 114
9677: GO 9716
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9679: LD_VAR 0 1
9683: PPUSH
9684: LD_INT 9
9686: PPUSH
9687: LD_INT 81
9689: PUSH
9690: LD_INT 6
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: PPUSH
9697: CALL_OW 70
9701: PPUSH
9702: LD_VAR 0 1
9706: PPUSH
9707: CALL_OW 74
9711: PPUSH
9712: CALL_OW 115
// end else
9716: GO 9752
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9718: LD_VAR 0 1
9722: PPUSH
9723: LD_INT 81
9725: PUSH
9726: LD_INT 6
9728: PUSH
9729: EMPTY
9730: LIST
9731: LIST
9732: PPUSH
9733: CALL_OW 69
9737: PPUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: CALL_OW 74
9747: PPUSH
9748: CALL_OW 115
// end ;
9752: GO 9488
9754: POP
9755: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9756: LD_INT 22
9758: PUSH
9759: LD_INT 6
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 69
9770: NOT
9771: IFFALSE 9471
// end ; until russianDestroyed ;
9773: LD_EXP 21
9777: IFFALSE 9129
// end ;
9779: PPOPN 6
9781: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9782: LD_EXP 21
9786: NOT
9787: PUSH
9788: LD_EXP 15
9792: PUSH
9793: LD_INT 6
9795: GREATEREQUAL
9796: AND
9797: PUSH
9798: LD_INT 2
9800: PPUSH
9801: LD_INT 1
9803: PPUSH
9804: CALL 57088 0 2
9808: NOT
9809: AND
9810: IFFALSE 10766
9812: GO 9814
9814: DISABLE
9815: LD_INT 0
9817: PPUSH
9818: PPUSH
9819: PPUSH
9820: PPUSH
// begin enable ;
9821: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9822: LD_INT 22
9824: PUSH
9825: LD_INT 3
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: LD_INT 30
9834: PUSH
9835: LD_INT 3
9837: PUSH
9838: EMPTY
9839: LIST
9840: LIST
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: PPUSH
9846: CALL_OW 69
9850: NOT
9851: IFFALSE 9855
// exit ;
9853: GO 10766
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9855: LD_ADDR_VAR 0 4
9859: PUSH
9860: LD_INT 22
9862: PUSH
9863: LD_INT 3
9865: PUSH
9866: EMPTY
9867: LIST
9868: LIST
9869: PUSH
9870: LD_INT 30
9872: PUSH
9873: LD_INT 34
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PPUSH
9884: CALL_OW 69
9888: ST_TO_ADDR
// if Prob ( 40 ) then
9889: LD_INT 40
9891: PPUSH
9892: CALL_OW 13
9896: IFFALSE 10023
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9898: LD_INT 2
9900: PPUSH
9901: LD_INT 22
9903: PUSH
9904: LD_INT 3
9906: PUSH
9907: LD_INT 3
9909: PUSH
9910: LD_INT 49
9912: PUSH
9913: EMPTY
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 22
9921: PUSH
9922: LD_INT 3
9924: PUSH
9925: LD_INT 3
9927: PUSH
9928: LD_INT 49
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: LIST
9935: LIST
9936: PUSH
9937: LD_INT 22
9939: PUSH
9940: LD_INT 3
9942: PUSH
9943: LD_INT 3
9945: PUSH
9946: LD_INT 49
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_INT 24
9957: PUSH
9958: LD_INT 3
9960: PUSH
9961: LD_INT 3
9963: PUSH
9964: LD_INT 46
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: LIST
9971: LIST
9972: PUSH
9973: LD_INT 24
9975: PUSH
9976: LD_INT 3
9978: PUSH
9979: LD_INT 3
9981: PUSH
9982: LD_INT 46
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 24
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 3
9999: PUSH
10000: LD_INT 46
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: PUSH
10009: EMPTY
10010: LIST
10011: LIST
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: PPUSH
10017: CALL 55733 0 2
// end else
10021: GO 10146
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10023: LD_INT 2
10025: PPUSH
10026: LD_INT 24
10028: PUSH
10029: LD_INT 3
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: LD_INT 47
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: LIST
10042: LIST
10043: PUSH
10044: LD_INT 24
10046: PUSH
10047: LD_INT 3
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: LD_INT 47
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: LIST
10061: PUSH
10062: LD_INT 24
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 3
10070: PUSH
10071: LD_INT 47
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: PUSH
10080: LD_INT 24
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 3
10088: PUSH
10089: LD_INT 46
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_INT 24
10100: PUSH
10101: LD_INT 3
10103: PUSH
10104: LD_INT 3
10106: PUSH
10107: LD_INT 46
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: PUSH
10116: LD_INT 24
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 3
10124: PUSH
10125: LD_INT 46
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: PPUSH
10142: CALL 55733 0 2
// end ; if Difficulty > 1 then
10146: LD_OWVAR 67
10150: PUSH
10151: LD_INT 1
10153: GREATER
10154: IFFALSE 10184
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10156: LD_INT 2
10158: PPUSH
10159: LD_INT 24
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: LD_INT 47
10170: PUSH
10171: EMPTY
10172: LIST
10173: LIST
10174: LIST
10175: LIST
10176: PUSH
10177: EMPTY
10178: LIST
10179: PPUSH
10180: CALL 55733 0 2
// repeat wait ( 0 0$1 ) ;
10184: LD_INT 35
10186: PPUSH
10187: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10191: LD_INT 2
10193: PPUSH
10194: LD_INT 1
10196: PPUSH
10197: CALL 57088 0 2
10201: PUSH
10202: LD_INT 6
10204: PUSH
10205: LD_INT 7
10207: PUSH
10208: LD_INT 7
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: PUSH
10216: LD_OWVAR 67
10220: ARRAY
10221: GREATEREQUAL
10222: IFFALSE 10184
// wait ( 0 0$30 ) ;
10224: LD_INT 1050
10226: PPUSH
10227: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10231: LD_ADDR_VAR 0 2
10235: PUSH
10236: LD_INT 2
10238: PPUSH
10239: LD_INT 1
10241: PPUSH
10242: CALL 57088 0 2
10246: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10247: LD_ADDR_EXP 118
10251: PUSH
10252: LD_EXP 118
10256: PPUSH
10257: LD_INT 2
10259: PPUSH
10260: LD_EXP 118
10264: PUSH
10265: LD_INT 2
10267: ARRAY
10268: PUSH
10269: LD_VAR 0 2
10273: DIFF
10274: PPUSH
10275: CALL_OW 1
10279: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10280: LD_ADDR_VAR 0 3
10284: PUSH
10285: LD_INT 0
10287: PPUSH
10288: LD_INT 1
10290: PPUSH
10291: CALL_OW 12
10295: ST_TO_ADDR
// if target then
10296: LD_VAR 0 3
10300: IFFALSE 10428
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10302: LD_ADDR_VAR 0 2
10306: PUSH
10307: LD_VAR 0 2
10311: PPUSH
10312: LD_INT 24
10314: PUSH
10315: LD_INT 250
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: PPUSH
10322: CALL_OW 72
10326: ST_TO_ADDR
// for i in tmp do
10327: LD_ADDR_VAR 0 1
10331: PUSH
10332: LD_VAR 0 2
10336: PUSH
10337: FOR_IN
10338: IFFALSE 10378
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10340: LD_VAR 0 1
10344: PPUSH
10345: LD_INT 139
10347: PPUSH
10348: LD_INT 89
10350: PPUSH
10351: CALL_OW 297
10355: PUSH
10356: LD_INT 9
10358: GREATER
10359: IFFALSE 10376
// ComMoveXY ( i , 139 , 89 ) ;
10361: LD_VAR 0 1
10365: PPUSH
10366: LD_INT 139
10368: PPUSH
10369: LD_INT 89
10371: PPUSH
10372: CALL_OW 111
10376: GO 10337
10378: POP
10379: POP
// wait ( 0 0$1 ) ;
10380: LD_INT 35
10382: PPUSH
10383: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10387: LD_VAR 0 2
10391: PPUSH
10392: LD_INT 92
10394: PUSH
10395: LD_INT 139
10397: PUSH
10398: LD_INT 89
10400: PUSH
10401: LD_INT 9
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: PPUSH
10410: CALL_OW 72
10414: PUSH
10415: LD_VAR 0 2
10419: PUSH
10420: LD_INT 1
10422: MINUS
10423: GREATEREQUAL
10424: IFFALSE 10302
// end else
10426: GO 10570
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10428: LD_VAR 0 2
10432: PPUSH
10433: LD_VAR 0 4
10437: PUSH
10438: LD_INT 1
10440: ARRAY
10441: PPUSH
10442: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10446: LD_ADDR_VAR 0 2
10450: PUSH
10451: LD_VAR 0 2
10455: PPUSH
10456: LD_INT 24
10458: PUSH
10459: LD_INT 250
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: PPUSH
10466: CALL_OW 72
10470: ST_TO_ADDR
// for i in tmp do
10471: LD_ADDR_VAR 0 1
10475: PUSH
10476: LD_VAR 0 2
10480: PUSH
10481: FOR_IN
10482: IFFALSE 10522
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10484: LD_VAR 0 1
10488: PPUSH
10489: LD_INT 124
10491: PPUSH
10492: LD_INT 139
10494: PPUSH
10495: CALL_OW 297
10499: PUSH
10500: LD_INT 9
10502: GREATER
10503: IFFALSE 10520
// ComMoveXY ( i , 124 , 139 ) ;
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_INT 124
10512: PPUSH
10513: LD_INT 139
10515: PPUSH
10516: CALL_OW 111
10520: GO 10481
10522: POP
10523: POP
// wait ( 0 0$1 ) ;
10524: LD_INT 35
10526: PPUSH
10527: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10531: LD_VAR 0 2
10535: PPUSH
10536: LD_INT 92
10538: PUSH
10539: LD_INT 124
10541: PUSH
10542: LD_INT 139
10544: PUSH
10545: LD_INT 9
10547: PUSH
10548: EMPTY
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: PPUSH
10554: CALL_OW 72
10558: PUSH
10559: LD_VAR 0 2
10563: PUSH
10564: LD_INT 1
10566: MINUS
10567: GREATEREQUAL
10568: IFFALSE 10446
// end ; repeat wait ( 0 0$1 ) ;
10570: LD_INT 35
10572: PPUSH
10573: CALL_OW 67
// for i in tmp do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: LD_VAR 0 2
10586: PUSH
10587: FOR_IN
10588: IFFALSE 10757
// begin if GetLives ( i ) > 251 then
10590: LD_VAR 0 1
10594: PPUSH
10595: CALL_OW 256
10599: PUSH
10600: LD_INT 251
10602: GREATER
10603: IFFALSE 10728
// begin if GetWeapon ( i ) = ru_time_lapser then
10605: LD_VAR 0 1
10609: PPUSH
10610: CALL_OW 264
10614: PUSH
10615: LD_INT 49
10617: EQUAL
10618: IFFALSE 10674
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10620: LD_VAR 0 1
10624: PPUSH
10625: LD_INT 2
10627: PUSH
10628: LD_INT 22
10630: PUSH
10631: LD_INT 1
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PUSH
10638: LD_INT 22
10640: PUSH
10641: LD_INT 8
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: LIST
10652: PPUSH
10653: CALL_OW 69
10657: PPUSH
10658: LD_VAR 0 1
10662: PPUSH
10663: CALL_OW 74
10667: PPUSH
10668: CALL_OW 112
10672: GO 10726
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10674: LD_VAR 0 1
10678: PPUSH
10679: LD_INT 2
10681: PUSH
10682: LD_INT 22
10684: PUSH
10685: LD_INT 1
10687: PUSH
10688: EMPTY
10689: LIST
10690: LIST
10691: PUSH
10692: LD_INT 22
10694: PUSH
10695: LD_INT 8
10697: PUSH
10698: EMPTY
10699: LIST
10700: LIST
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: LIST
10706: PPUSH
10707: CALL_OW 69
10711: PPUSH
10712: LD_VAR 0 1
10716: PPUSH
10717: CALL_OW 74
10721: PPUSH
10722: CALL_OW 115
// end else
10726: GO 10755
// if IsDead ( i ) then
10728: LD_VAR 0 1
10732: PPUSH
10733: CALL_OW 301
10737: IFFALSE 10755
// tmp := tmp diff i ;
10739: LD_ADDR_VAR 0 2
10743: PUSH
10744: LD_VAR 0 2
10748: PUSH
10749: LD_VAR 0 1
10753: DIFF
10754: ST_TO_ADDR
// end ;
10755: GO 10587
10757: POP
10758: POP
// until not tmp ;
10759: LD_VAR 0 2
10763: NOT
10764: IFFALSE 10570
// end ; end_of_file
10766: PPOPN 4
10768: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10769: LD_INT 0
10771: PPUSH
10772: PPUSH
10773: PPUSH
10774: PPUSH
10775: PPUSH
10776: PPUSH
// side := 7 ;
10777: LD_ADDR_VAR 0 5
10781: PUSH
10782: LD_INT 7
10784: ST_TO_ADDR
// uc_side := side ;
10785: LD_ADDR_OWVAR 20
10789: PUSH
10790: LD_VAR 0 5
10794: ST_TO_ADDR
// uc_nation := 1 ;
10795: LD_ADDR_OWVAR 21
10799: PUSH
10800: LD_INT 1
10802: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10803: LD_ADDR_VAR 0 2
10807: PUSH
10808: LD_INT 22
10810: PUSH
10811: LD_VAR 0 5
10815: PUSH
10816: EMPTY
10817: LIST
10818: LIST
10819: PUSH
10820: LD_INT 21
10822: PUSH
10823: LD_INT 3
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: PPUSH
10834: CALL_OW 69
10838: PUSH
10839: FOR_IN
10840: IFFALSE 10856
// SetBLevel ( i , 10 ) ;
10842: LD_VAR 0 2
10846: PPUSH
10847: LD_INT 10
10849: PPUSH
10850: CALL_OW 241
10854: GO 10839
10856: POP
10857: POP
// base := GetBase ( al_depot ) ;
10858: LD_ADDR_VAR 0 4
10862: PUSH
10863: LD_INT 2
10865: PPUSH
10866: CALL_OW 274
10870: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10871: LD_ADDR_VAR 0 6
10875: PUSH
10876: LD_INT 22
10878: PUSH
10879: LD_VAR 0 5
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: PUSH
10888: LD_INT 30
10890: PUSH
10891: LD_INT 34
10893: PUSH
10894: EMPTY
10895: LIST
10896: LIST
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: PPUSH
10902: CALL_OW 69
10906: ST_TO_ADDR
// if teleport then
10907: LD_VAR 0 6
10911: IFFALSE 10932
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10913: LD_VAR 0 6
10917: PUSH
10918: LD_INT 1
10920: ARRAY
10921: PPUSH
10922: LD_INT 262
10924: PPUSH
10925: LD_INT 119
10927: PPUSH
10928: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
10932: LD_VAR 0 4
10936: PPUSH
10937: LD_INT 1
10939: PPUSH
10940: LD_INT 19500
10942: PPUSH
10943: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10947: LD_VAR 0 4
10951: PPUSH
10952: LD_INT 2
10954: PPUSH
10955: LD_INT 200
10957: PPUSH
10958: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10962: LD_VAR 0 4
10966: PPUSH
10967: LD_INT 3
10969: PPUSH
10970: LD_INT 650
10972: PPUSH
10973: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
10977: LD_ADDR_EXP 71
10981: PUSH
10982: LD_STRING Roth
10984: PPUSH
10985: CALL_OW 25
10989: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
10990: LD_ADDR_EXP 72
10994: PUSH
10995: LD_STRING Simms
10997: PPUSH
10998: LD_EXP 1
11002: NOT
11003: PPUSH
11004: LD_STRING 10c_
11006: PPUSH
11007: CALL 61665 0 3
11011: ST_TO_ADDR
// if not Simms then
11012: LD_EXP 72
11016: NOT
11017: IFFALSE 11047
// begin uc_nation := 1 ;
11019: LD_ADDR_OWVAR 21
11023: PUSH
11024: LD_INT 1
11026: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11027: LD_INT 2
11029: PPUSH
11030: LD_INT 10
11032: PPUSH
11033: CALL_OW 384
// Simms := CreateHuman ;
11037: LD_ADDR_EXP 72
11041: PUSH
11042: CALL_OW 44
11046: ST_TO_ADDR
// end ; uc_nation := 3 ;
11047: LD_ADDR_OWVAR 21
11051: PUSH
11052: LD_INT 3
11054: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11055: LD_ADDR_EXP 73
11059: PUSH
11060: LD_STRING Kirilenkova
11062: PPUSH
11063: CALL_OW 25
11067: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11068: LD_ADDR_EXP 87
11072: PUSH
11073: LD_STRING Oblukov
11075: PPUSH
11076: CALL_OW 25
11080: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11081: LD_ADDR_EXP 74
11085: PUSH
11086: LD_STRING Dolgov
11088: PPUSH
11089: CALL_OW 25
11093: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11094: LD_ADDR_EXP 75
11098: PUSH
11099: LD_STRING Petrosyan
11101: PPUSH
11102: CALL_OW 25
11106: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11107: LD_ADDR_EXP 86
11111: PUSH
11112: LD_STRING Scholtze
11114: PPUSH
11115: CALL_OW 25
11119: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11120: LD_ADDR_EXP 85
11124: PUSH
11125: LD_STRING Kapitsova
11127: PPUSH
11128: CALL_OW 25
11132: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11133: LD_ADDR_EXP 76
11137: PUSH
11138: LD_STRING Petrovova
11140: PPUSH
11141: CALL_OW 25
11145: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11146: LD_ADDR_EXP 77
11150: PUSH
11151: LD_STRING Kuzmov
11153: PPUSH
11154: CALL_OW 25
11158: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11159: LD_ADDR_EXP 84
11163: PUSH
11164: LD_STRING Karamazov
11166: PPUSH
11167: CALL_OW 25
11171: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11172: LD_STRING 13_Lipshchin_1
11174: PPUSH
11175: LD_INT 0
11177: PPUSH
11178: CALL_OW 30
11182: IFFALSE 11197
// Lipshchin := NewCharacter ( Lipshchin ) ;
11184: LD_ADDR_EXP 78
11188: PUSH
11189: LD_STRING Lipshchin
11191: PPUSH
11192: CALL_OW 25
11196: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11197: LD_STRING 13_Titov_1
11199: PPUSH
11200: LD_INT 0
11202: PPUSH
11203: CALL_OW 30
11207: IFFALSE 11222
// Titov := NewCharacter ( Titov ) ;
11209: LD_ADDR_EXP 80
11213: PUSH
11214: LD_STRING Titov
11216: PPUSH
11217: CALL_OW 25
11221: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11222: LD_STRING 13_Gnyevko_1
11224: PPUSH
11225: LD_INT 0
11227: PPUSH
11228: CALL_OW 30
11232: IFFALSE 11247
// Gnyevko := NewCharacter ( Gnyevko ) ;
11234: LD_ADDR_EXP 79
11238: PUSH
11239: LD_STRING Gnyevko
11241: PPUSH
11242: CALL_OW 25
11246: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11247: LD_STRING 13_Xavier_1
11249: PPUSH
11250: LD_INT 0
11252: PPUSH
11253: CALL_OW 30
11257: IFFALSE 11272
// Xavier := NewCharacter ( Xavier2 ) ;
11259: LD_ADDR_EXP 81
11263: PUSH
11264: LD_STRING Xavier2
11266: PPUSH
11267: CALL_OW 25
11271: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11272: LD_STRING 13_Belkov_1
11274: PPUSH
11275: LD_INT 0
11277: PPUSH
11278: CALL_OW 30
11282: IFFALSE 11297
// Belkov := NewCharacter ( Belkov ) ;
11284: LD_ADDR_EXP 82
11288: PUSH
11289: LD_STRING Belkov
11291: PPUSH
11292: CALL_OW 25
11296: ST_TO_ADDR
// if not BurlakStatus then
11297: LD_EXP 9
11301: NOT
11302: IFFALSE 11317
// Burlak = NewCharacter ( Burlak ) ;
11304: LD_ADDR_EXP 83
11308: PUSH
11309: LD_STRING Burlak
11311: PPUSH
11312: CALL_OW 25
11316: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11317: LD_ADDR_VAR 0 3
11321: PUSH
11322: LD_EXP 71
11326: PUSH
11327: LD_EXP 73
11331: PUSH
11332: LD_EXP 87
11336: PUSH
11337: LD_EXP 74
11341: PUSH
11342: LD_EXP 75
11346: PUSH
11347: LD_EXP 86
11351: PUSH
11352: LD_EXP 85
11356: PUSH
11357: LD_EXP 76
11361: PUSH
11362: LD_EXP 77
11366: PUSH
11367: LD_EXP 84
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: ST_TO_ADDR
// if Simms then
11384: LD_EXP 72
11388: IFFALSE 11406
// tmp := tmp ^ Simms ;
11390: LD_ADDR_VAR 0 3
11394: PUSH
11395: LD_VAR 0 3
11399: PUSH
11400: LD_EXP 72
11404: ADD
11405: ST_TO_ADDR
// if Titov then
11406: LD_EXP 80
11410: IFFALSE 11428
// tmp := tmp ^ Titov ;
11412: LD_ADDR_VAR 0 3
11416: PUSH
11417: LD_VAR 0 3
11421: PUSH
11422: LD_EXP 80
11426: ADD
11427: ST_TO_ADDR
// if Lipshchin then
11428: LD_EXP 78
11432: IFFALSE 11450
// tmp := tmp ^ Lipshchin ;
11434: LD_ADDR_VAR 0 3
11438: PUSH
11439: LD_VAR 0 3
11443: PUSH
11444: LD_EXP 78
11448: ADD
11449: ST_TO_ADDR
// if Gnyevko then
11450: LD_EXP 79
11454: IFFALSE 11472
// tmp := tmp ^ Gnyevko ;
11456: LD_ADDR_VAR 0 3
11460: PUSH
11461: LD_VAR 0 3
11465: PUSH
11466: LD_EXP 79
11470: ADD
11471: ST_TO_ADDR
// if Xavier then
11472: LD_EXP 81
11476: IFFALSE 11494
// tmp := tmp ^ Xavier ;
11478: LD_ADDR_VAR 0 3
11482: PUSH
11483: LD_VAR 0 3
11487: PUSH
11488: LD_EXP 81
11492: ADD
11493: ST_TO_ADDR
// if Belkov then
11494: LD_EXP 82
11498: IFFALSE 11516
// tmp := tmp ^ Belkov ;
11500: LD_ADDR_VAR 0 3
11504: PUSH
11505: LD_VAR 0 3
11509: PUSH
11510: LD_EXP 82
11514: ADD
11515: ST_TO_ADDR
// if Burlak then
11516: LD_EXP 83
11520: IFFALSE 11538
// tmp := tmp ^ Burlak ;
11522: LD_ADDR_VAR 0 3
11526: PUSH
11527: LD_VAR 0 3
11531: PUSH
11532: LD_EXP 83
11536: ADD
11537: ST_TO_ADDR
// for i = 1 to 8 do
11538: LD_ADDR_VAR 0 2
11542: PUSH
11543: DOUBLE
11544: LD_INT 1
11546: DEC
11547: ST_TO_ADDR
11548: LD_INT 8
11550: PUSH
11551: FOR_TO
11552: IFFALSE 11618
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11554: LD_ADDR_OWVAR 21
11558: PUSH
11559: LD_INT 1
11561: PUSH
11562: LD_INT 3
11564: PUSH
11565: EMPTY
11566: LIST
11567: LIST
11568: PUSH
11569: LD_INT 1
11571: PPUSH
11572: LD_INT 2
11574: PPUSH
11575: CALL_OW 12
11579: ARRAY
11580: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11581: LD_INT 0
11583: PPUSH
11584: LD_VAR 0 2
11588: PUSH
11589: LD_INT 2
11591: DIV
11592: PPUSH
11593: LD_INT 10
11595: PPUSH
11596: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11600: LD_ADDR_VAR 0 3
11604: PUSH
11605: LD_VAR 0 3
11609: PUSH
11610: CALL_OW 44
11614: ADD
11615: ST_TO_ADDR
// end ;
11616: GO 11551
11618: POP
11619: POP
// for i in tmp do
11620: LD_ADDR_VAR 0 2
11624: PUSH
11625: LD_VAR 0 3
11629: PUSH
11630: FOR_IN
11631: IFFALSE 11656
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11633: LD_VAR 0 2
11637: PPUSH
11638: LD_INT 260
11640: PPUSH
11641: LD_INT 235
11643: PPUSH
11644: LD_INT 8
11646: PPUSH
11647: LD_INT 0
11649: PPUSH
11650: CALL_OW 50
11654: GO 11630
11656: POP
11657: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11658: LD_ADDR_EXP 99
11662: PUSH
11663: LD_EXP 99
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: LD_INT 22
11673: PUSH
11674: LD_VAR 0 5
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: PUSH
11683: LD_INT 3
11685: PUSH
11686: LD_INT 21
11688: PUSH
11689: LD_INT 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PPUSH
11704: CALL_OW 69
11708: PUSH
11709: LD_EXP 71
11713: PUSH
11714: LD_EXP 72
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: DIFF
11723: PPUSH
11724: CALL_OW 1
11728: ST_TO_ADDR
// uc_side := 0 ;
11729: LD_ADDR_OWVAR 20
11733: PUSH
11734: LD_INT 0
11736: ST_TO_ADDR
// uc_nation := 0 ;
11737: LD_ADDR_OWVAR 21
11741: PUSH
11742: LD_INT 0
11744: ST_TO_ADDR
// for i = 1 to 5 do
11745: LD_ADDR_VAR 0 2
11749: PUSH
11750: DOUBLE
11751: LD_INT 1
11753: DEC
11754: ST_TO_ADDR
11755: LD_INT 5
11757: PUSH
11758: FOR_TO
11759: IFFALSE 11796
// begin InitHc ;
11761: CALL_OW 19
// hc_class := class_apeman ;
11765: LD_ADDR_OWVAR 28
11769: PUSH
11770: LD_INT 12
11772: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11773: CALL_OW 44
11777: PPUSH
11778: LD_INT 299
11780: PPUSH
11781: LD_INT 229
11783: PPUSH
11784: LD_INT 10
11786: PPUSH
11787: LD_INT 0
11789: PPUSH
11790: CALL_OW 50
// end ;
11794: GO 11758
11796: POP
11797: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11798: LD_EXP 71
11802: PPUSH
11803: LD_INT 259
11805: PPUSH
11806: LD_INT 235
11808: PPUSH
11809: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11813: LD_EXP 71
11817: PPUSH
11818: LD_INT 262
11820: PPUSH
11821: LD_INT 235
11823: PPUSH
11824: CALL_OW 178
// if Simms then
11828: LD_EXP 72
11832: IFFALSE 11863
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11834: LD_EXP 72
11838: PPUSH
11839: LD_INT 262
11841: PPUSH
11842: LD_INT 235
11844: PPUSH
11845: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11849: LD_EXP 72
11853: PPUSH
11854: LD_EXP 71
11858: PPUSH
11859: CALL_OW 179
// end ; end ;
11863: LD_VAR 0 1
11867: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11868: LD_EXP 31
11872: PUSH
11873: LD_EXP 23
11877: NOT
11878: AND
11879: IFFALSE 12055
11881: GO 11883
11883: DISABLE
11884: LD_INT 0
11886: PPUSH
11887: PPUSH
11888: PPUSH
// begin enable ;
11889: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11890: LD_ADDR_VAR 0 2
11894: PUSH
11895: LD_INT 81
11897: PUSH
11898: LD_INT 7
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: PUSH
11905: LD_INT 2
11907: PUSH
11908: LD_INT 32
11910: PUSH
11911: LD_INT 3
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 30
11920: PUSH
11921: LD_INT 30
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: LD_INT 30
11930: PUSH
11931: LD_INT 28
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_INT 34
11940: PUSH
11941: LD_INT 49
11943: PUSH
11944: EMPTY
11945: LIST
11946: LIST
11947: PUSH
11948: LD_INT 34
11950: PUSH
11951: LD_INT 10
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 34
11960: PUSH
11961: LD_INT 8
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PPUSH
11981: CALL_OW 69
11985: ST_TO_ADDR
// if not tmp then
11986: LD_VAR 0 2
11990: NOT
11991: IFFALSE 11995
// exit ;
11993: GO 12055
// target := tmp [ rand ( 1 , tmp ) ] ;
11995: LD_ADDR_VAR 0 3
11999: PUSH
12000: LD_VAR 0 2
12004: PUSH
12005: LD_INT 1
12007: PPUSH
12008: LD_VAR 0 2
12012: PPUSH
12013: CALL_OW 12
12017: ARRAY
12018: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12019: LD_VAR 0 3
12023: PPUSH
12024: CALL_OW 255
12028: PUSH
12029: LD_INT 1
12031: EQUAL
12032: IFFALSE 12043
// CenterNowOnUnits ( target ) ;
12034: LD_VAR 0 3
12038: PPUSH
12039: CALL_OW 87
// SetLives ( target , 0 ) ;
12043: LD_VAR 0 3
12047: PPUSH
12048: LD_INT 0
12050: PPUSH
12051: CALL_OW 234
// end ;
12055: PPOPN 3
12057: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12058: LD_EXP 23
12062: NOT
12063: PUSH
12064: LD_EXP 31
12068: AND
12069: IFFALSE 12591
12071: GO 12073
12073: DISABLE
12074: LD_INT 0
12076: PPUSH
12077: PPUSH
12078: PPUSH
// begin uc_side := 7 ;
12079: LD_ADDR_OWVAR 20
12083: PUSH
12084: LD_INT 7
12086: ST_TO_ADDR
// uc_nation := 1 ;
12087: LD_ADDR_OWVAR 21
12091: PUSH
12092: LD_INT 1
12094: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12095: LD_ADDR_VAR 0 3
12099: PUSH
12100: LD_INT 125
12102: PUSH
12103: LD_INT 163
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: LD_INT 185
12112: PUSH
12113: LD_INT 168
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: PUSH
12120: LD_INT 111
12122: PUSH
12123: LD_INT 97
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: LIST
12134: PPUSH
12135: CALL 104073 0 1
12139: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12140: LD_ADDR_EXP 88
12144: PUSH
12145: EMPTY
12146: ST_TO_ADDR
// for i = 1 to Difficulty do
12147: LD_ADDR_VAR 0 1
12151: PUSH
12152: DOUBLE
12153: LD_INT 1
12155: DEC
12156: ST_TO_ADDR
12157: LD_OWVAR 67
12161: PUSH
12162: FOR_TO
12163: IFFALSE 12321
// begin InitHc ;
12165: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12169: LD_INT 0
12171: PPUSH
12172: LD_INT 8
12174: PPUSH
12175: CALL_OW 381
// un := CreateHuman ;
12179: LD_ADDR_VAR 0 2
12183: PUSH
12184: CALL_OW 44
12188: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12189: LD_VAR 0 2
12193: PPUSH
12194: LD_INT 258
12196: PPUSH
12197: LD_INT 267
12199: PPUSH
12200: LD_INT 4
12202: PPUSH
12203: LD_INT 0
12205: PPUSH
12206: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12210: LD_ADDR_EXP 88
12214: PUSH
12215: LD_EXP 88
12219: PUSH
12220: LD_VAR 0 2
12224: UNION
12225: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12226: LD_VAR 0 2
12230: PPUSH
12231: LD_VAR 0 3
12235: PUSH
12236: LD_VAR 0 1
12240: ARRAY
12241: PUSH
12242: LD_INT 1
12244: ARRAY
12245: PPUSH
12246: LD_VAR 0 3
12250: PUSH
12251: LD_VAR 0 1
12255: ARRAY
12256: PUSH
12257: LD_INT 2
12259: ARRAY
12260: PPUSH
12261: LD_INT 4
12263: PPUSH
12264: LD_INT 1
12266: PPUSH
12267: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12271: LD_VAR 0 2
12275: PPUSH
12276: LD_VAR 0 3
12280: PUSH
12281: LD_VAR 0 1
12285: ARRAY
12286: PUSH
12287: LD_INT 1
12289: ARRAY
12290: PPUSH
12291: LD_VAR 0 3
12295: PUSH
12296: LD_VAR 0 1
12300: ARRAY
12301: PUSH
12302: LD_INT 2
12304: ARRAY
12305: PPUSH
12306: CALL_OW 171
// AddComInvisible ( un ) ;
12310: LD_VAR 0 2
12314: PPUSH
12315: CALL_OW 212
// end ;
12319: GO 12162
12321: POP
12322: POP
// repeat wait ( 0 0$20 ) ;
12323: LD_INT 700
12325: PPUSH
12326: CALL_OW 67
// for i in allianceSpecialForce do
12330: LD_ADDR_VAR 0 1
12334: PUSH
12335: LD_EXP 88
12339: PUSH
12340: FOR_IN
12341: IFFALSE 12576
// begin if IsInvisible ( i ) then
12343: LD_VAR 0 1
12347: PPUSH
12348: CALL_OW 571
12352: IFFALSE 12545
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12354: LD_ADDR_VAR 0 3
12358: PUSH
12359: LD_INT 22
12361: PUSH
12362: LD_INT 1
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PUSH
12369: LD_INT 50
12371: PUSH
12372: EMPTY
12373: LIST
12374: PUSH
12375: LD_INT 56
12377: PUSH
12378: EMPTY
12379: LIST
12380: PUSH
12381: LD_INT 91
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: LD_INT 25
12391: PUSH
12392: LD_INT 30
12394: PUSH
12395: LD_INT 35
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: PUSH
12403: LD_OWVAR 67
12407: ARRAY
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 2
12416: PUSH
12417: LD_INT 25
12419: PUSH
12420: LD_INT 1
12422: PUSH
12423: EMPTY
12424: LIST
12425: LIST
12426: PUSH
12427: LD_INT 25
12429: PUSH
12430: LD_INT 2
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 25
12439: PUSH
12440: LD_INT 3
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 25
12449: PUSH
12450: LD_INT 4
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PUSH
12457: LD_INT 25
12459: PUSH
12460: LD_INT 5
12462: PUSH
12463: EMPTY
12464: LIST
12465: LIST
12466: PUSH
12467: LD_INT 25
12469: PUSH
12470: LD_INT 8
12472: PUSH
12473: EMPTY
12474: LIST
12475: LIST
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: LIST
12481: LIST
12482: LIST
12483: LIST
12484: LIST
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: PPUSH
12493: CALL_OW 69
12497: ST_TO_ADDR
// if not tmp then
12498: LD_VAR 0 3
12502: NOT
12503: IFFALSE 12507
// continue ;
12505: GO 12340
// if Prob ( 30 * Difficulty ) then
12507: LD_INT 30
12509: PUSH
12510: LD_OWVAR 67
12514: MUL
12515: PPUSH
12516: CALL_OW 13
12520: IFFALSE 12545
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12522: LD_VAR 0 3
12526: PUSH
12527: LD_INT 1
12529: PPUSH
12530: LD_VAR 0 3
12534: PPUSH
12535: CALL_OW 12
12539: ARRAY
12540: PPUSH
12541: CALL 29762 0 1
// end ; if IsDead ( i ) then
12545: LD_VAR 0 1
12549: PPUSH
12550: CALL_OW 301
12554: IFFALSE 12574
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12556: LD_ADDR_EXP 88
12560: PUSH
12561: LD_EXP 88
12565: PUSH
12566: LD_VAR 0 1
12570: DIFF
12571: ST_TO_ADDR
// continue ;
12572: GO 12340
// end ; end ;
12574: GO 12340
12576: POP
12577: POP
// until allianceDestroyed or not allianceSpecialForce ;
12578: LD_EXP 23
12582: PUSH
12583: LD_EXP 88
12587: NOT
12588: OR
12589: IFFALSE 12323
// end ;
12591: PPOPN 3
12593: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12594: LD_EXP 23
12598: NOT
12599: PUSH
12600: LD_EXP 31
12604: AND
12605: PUSH
12606: LD_INT 1
12608: PPUSH
12609: LD_INT 1
12611: PPUSH
12612: CALL 57088 0 2
12616: NOT
12617: AND
12618: IFFALSE 13585
12620: GO 12622
12622: DISABLE
12623: LD_INT 0
12625: PPUSH
12626: PPUSH
12627: PPUSH
12628: PPUSH
// begin enable ;
12629: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12630: LD_INT 22
12632: PUSH
12633: LD_INT 7
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: PUSH
12640: LD_INT 30
12642: PUSH
12643: LD_INT 3
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PPUSH
12654: CALL_OW 69
12658: NOT
12659: IFFALSE 12663
// exit ;
12661: GO 13585
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12663: LD_ADDR_VAR 0 4
12667: PUSH
12668: LD_INT 22
12670: PUSH
12671: LD_INT 7
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: LD_INT 30
12680: PUSH
12681: LD_INT 34
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: EMPTY
12689: LIST
12690: LIST
12691: PPUSH
12692: CALL_OW 69
12696: ST_TO_ADDR
// if Prob ( 40 ) then
12697: LD_INT 40
12699: PPUSH
12700: CALL_OW 13
12704: IFFALSE 12831
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12706: LD_INT 1
12708: PPUSH
12709: LD_INT 5
12711: PUSH
12712: LD_INT 3
12714: PUSH
12715: LD_INT 2
12717: PUSH
12718: LD_INT 6
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 5
12729: PUSH
12730: LD_INT 3
12732: PUSH
12733: LD_INT 2
12735: PUSH
12736: LD_INT 6
12738: PUSH
12739: EMPTY
12740: LIST
12741: LIST
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 5
12747: PUSH
12748: LD_INT 3
12750: PUSH
12751: LD_INT 2
12753: PUSH
12754: LD_INT 6
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 24
12765: PUSH
12766: LD_INT 3
12768: PUSH
12769: LD_INT 3
12771: PUSH
12772: LD_INT 45
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PUSH
12781: LD_INT 24
12783: PUSH
12784: LD_INT 3
12786: PUSH
12787: LD_INT 3
12789: PUSH
12790: LD_INT 47
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: PUSH
12799: LD_INT 24
12801: PUSH
12802: LD_INT 3
12804: PUSH
12805: LD_INT 3
12807: PUSH
12808: LD_INT 45
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: PPUSH
12825: CALL 55733 0 2
// end else
12829: GO 12954
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12831: LD_INT 1
12833: PPUSH
12834: LD_INT 24
12836: PUSH
12837: LD_INT 3
12839: PUSH
12840: LD_INT 3
12842: PUSH
12843: LD_INT 47
12845: PUSH
12846: EMPTY
12847: LIST
12848: LIST
12849: LIST
12850: LIST
12851: PUSH
12852: LD_INT 24
12854: PUSH
12855: LD_INT 3
12857: PUSH
12858: LD_INT 3
12860: PUSH
12861: LD_INT 47
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: PUSH
12870: LD_INT 5
12872: PUSH
12873: LD_INT 3
12875: PUSH
12876: LD_INT 2
12878: PUSH
12879: LD_INT 9
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: PUSH
12888: LD_INT 5
12890: PUSH
12891: LD_INT 3
12893: PUSH
12894: LD_INT 2
12896: PUSH
12897: LD_INT 9
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: LIST
12904: LIST
12905: PUSH
12906: LD_INT 24
12908: PUSH
12909: LD_INT 1
12911: PUSH
12912: LD_INT 3
12914: PUSH
12915: LD_INT 45
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 24
12926: PUSH
12927: LD_INT 1
12929: PUSH
12930: LD_INT 3
12932: PUSH
12933: LD_INT 45
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: LIST
12940: LIST
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: PPUSH
12950: CALL 55733 0 2
// end ; if Difficulty > 1 then
12954: LD_OWVAR 67
12958: PUSH
12959: LD_INT 1
12961: GREATER
12962: IFFALSE 12992
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12964: LD_INT 1
12966: PPUSH
12967: LD_INT 24
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 3
12975: PUSH
12976: LD_INT 47
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: PUSH
12985: EMPTY
12986: LIST
12987: PPUSH
12988: CALL 55733 0 2
// repeat wait ( 0 0$1 ) ;
12992: LD_INT 35
12994: PPUSH
12995: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
12999: LD_INT 1
13001: PPUSH
13002: LD_INT 1
13004: PPUSH
13005: CALL 57088 0 2
13009: PUSH
13010: LD_INT 6
13012: PUSH
13013: LD_INT 7
13015: PUSH
13016: LD_INT 7
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: LIST
13023: PUSH
13024: LD_OWVAR 67
13028: ARRAY
13029: GREATEREQUAL
13030: IFFALSE 12992
// wait ( 0 0$40 ) ;
13032: LD_INT 1400
13034: PPUSH
13035: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13039: LD_ADDR_VAR 0 2
13043: PUSH
13044: LD_INT 1
13046: PPUSH
13047: LD_INT 1
13049: PPUSH
13050: CALL 57088 0 2
13054: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13055: LD_ADDR_EXP 118
13059: PUSH
13060: LD_EXP 118
13064: PPUSH
13065: LD_INT 1
13067: PPUSH
13068: LD_EXP 118
13072: PUSH
13073: LD_INT 1
13075: ARRAY
13076: PUSH
13077: LD_VAR 0 2
13081: DIFF
13082: PPUSH
13083: CALL_OW 1
13087: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13088: LD_ADDR_VAR 0 3
13092: PUSH
13093: LD_INT 0
13095: PPUSH
13096: LD_INT 1
13098: PPUSH
13099: CALL_OW 12
13103: ST_TO_ADDR
// if target then
13104: LD_VAR 0 3
13108: IFFALSE 13274
// begin for i in tmp do
13110: LD_ADDR_VAR 0 1
13114: PUSH
13115: LD_VAR 0 2
13119: PUSH
13120: FOR_IN
13121: IFFALSE 13146
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13123: LD_VAR 0 1
13127: PPUSH
13128: LD_INT 179
13130: PPUSH
13131: LD_INT 209
13133: PPUSH
13134: LD_INT 8
13136: PPUSH
13137: LD_INT 1
13139: PPUSH
13140: CALL_OW 483
13144: GO 13120
13146: POP
13147: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13148: LD_ADDR_VAR 0 2
13152: PUSH
13153: LD_VAR 0 2
13157: PPUSH
13158: LD_INT 24
13160: PUSH
13161: LD_INT 250
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PPUSH
13168: CALL_OW 72
13172: ST_TO_ADDR
// for i in tmp do
13173: LD_ADDR_VAR 0 1
13177: PUSH
13178: LD_VAR 0 2
13182: PUSH
13183: FOR_IN
13184: IFFALSE 13224
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13186: LD_VAR 0 1
13190: PPUSH
13191: LD_INT 179
13193: PPUSH
13194: LD_INT 209
13196: PPUSH
13197: CALL_OW 297
13201: PUSH
13202: LD_INT 9
13204: GREATER
13205: IFFALSE 13222
// ComMoveXY ( i , 179 , 209 ) ;
13207: LD_VAR 0 1
13211: PPUSH
13212: LD_INT 179
13214: PPUSH
13215: LD_INT 209
13217: PPUSH
13218: CALL_OW 111
13222: GO 13183
13224: POP
13225: POP
// wait ( 0 0$1 ) ;
13226: LD_INT 35
13228: PPUSH
13229: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13233: LD_VAR 0 2
13237: PPUSH
13238: LD_INT 92
13240: PUSH
13241: LD_INT 179
13243: PUSH
13244: LD_INT 209
13246: PUSH
13247: LD_INT 9
13249: PUSH
13250: EMPTY
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: PPUSH
13256: CALL_OW 72
13260: PUSH
13261: LD_VAR 0 2
13265: PUSH
13266: LD_INT 1
13268: MINUS
13269: GREATEREQUAL
13270: IFFALSE 13148
// end else
13272: GO 13436
// begin for i in tmp do
13274: LD_ADDR_VAR 0 1
13278: PUSH
13279: LD_VAR 0 2
13283: PUSH
13284: FOR_IN
13285: IFFALSE 13310
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13287: LD_VAR 0 1
13291: PPUSH
13292: LD_INT 285
13294: PPUSH
13295: LD_INT 163
13297: PPUSH
13298: LD_INT 8
13300: PPUSH
13301: LD_INT 1
13303: PPUSH
13304: CALL_OW 483
13308: GO 13284
13310: POP
13311: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_VAR 0 2
13321: PPUSH
13322: LD_INT 24
13324: PUSH
13325: LD_INT 250
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 72
13336: ST_TO_ADDR
// for i in tmp do
13337: LD_ADDR_VAR 0 1
13341: PUSH
13342: LD_VAR 0 2
13346: PUSH
13347: FOR_IN
13348: IFFALSE 13388
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13350: LD_VAR 0 1
13354: PPUSH
13355: LD_INT 285
13357: PPUSH
13358: LD_INT 163
13360: PPUSH
13361: CALL_OW 297
13365: PUSH
13366: LD_INT 9
13368: GREATER
13369: IFFALSE 13386
// ComMoveXY ( i , 285 , 163 ) ;
13371: LD_VAR 0 1
13375: PPUSH
13376: LD_INT 285
13378: PPUSH
13379: LD_INT 163
13381: PPUSH
13382: CALL_OW 111
13386: GO 13347
13388: POP
13389: POP
// wait ( 0 0$1 ) ;
13390: LD_INT 35
13392: PPUSH
13393: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13397: LD_VAR 0 2
13401: PPUSH
13402: LD_INT 92
13404: PUSH
13405: LD_INT 285
13407: PUSH
13408: LD_INT 163
13410: PUSH
13411: LD_INT 9
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: PPUSH
13420: CALL_OW 72
13424: PUSH
13425: LD_VAR 0 2
13429: PUSH
13430: LD_INT 1
13432: MINUS
13433: GREATEREQUAL
13434: IFFALSE 13312
// end ; repeat wait ( 0 0$1 ) ;
13436: LD_INT 35
13438: PPUSH
13439: CALL_OW 67
// for i in tmp do
13443: LD_ADDR_VAR 0 1
13447: PUSH
13448: LD_VAR 0 2
13452: PUSH
13453: FOR_IN
13454: IFFALSE 13576
// if GetLives ( i ) > 251 then
13456: LD_VAR 0 1
13460: PPUSH
13461: CALL_OW 256
13465: PUSH
13466: LD_INT 251
13468: GREATER
13469: IFFALSE 13558
// begin if GetWeapon ( i ) = ru_time_lapser then
13471: LD_VAR 0 1
13475: PPUSH
13476: CALL_OW 264
13480: PUSH
13481: LD_INT 49
13483: EQUAL
13484: IFFALSE 13522
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13486: LD_VAR 0 1
13490: PPUSH
13491: LD_INT 81
13493: PUSH
13494: LD_INT 7
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PPUSH
13501: CALL_OW 69
13505: PPUSH
13506: LD_VAR 0 1
13510: PPUSH
13511: CALL_OW 74
13515: PPUSH
13516: CALL_OW 112
13520: GO 13556
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 81
13529: PUSH
13530: LD_INT 7
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PPUSH
13537: CALL_OW 69
13541: PPUSH
13542: LD_VAR 0 1
13546: PPUSH
13547: CALL_OW 74
13551: PPUSH
13552: CALL_OW 115
// end else
13556: GO 13574
// tmp := tmp diff i ;
13558: LD_ADDR_VAR 0 2
13562: PUSH
13563: LD_VAR 0 2
13567: PUSH
13568: LD_VAR 0 1
13572: DIFF
13573: ST_TO_ADDR
13574: GO 13453
13576: POP
13577: POP
// until not tmp ;
13578: LD_VAR 0 2
13582: NOT
13583: IFFALSE 13436
// end ; end_of_file
13585: PPOPN 4
13587: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13588: LD_INT 0
13590: PPUSH
13591: PPUSH
13592: PPUSH
13593: PPUSH
// missionStage := 13 ;
13594: LD_ADDR_EXP 15
13598: PUSH
13599: LD_INT 13
13601: ST_TO_ADDR
// uc_side := 2 ;
13602: LD_ADDR_OWVAR 20
13606: PUSH
13607: LD_INT 2
13609: ST_TO_ADDR
// uc_nation := 2 ;
13610: LD_ADDR_OWVAR 21
13614: PUSH
13615: LD_INT 2
13617: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13618: LD_ADDR_EXP 89
13622: PUSH
13623: LD_STRING Omar
13625: PPUSH
13626: CALL_OW 25
13630: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13631: LD_EXP 89
13635: PPUSH
13636: LD_INT 4
13638: PPUSH
13639: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13643: LD_EXP 89
13647: PPUSH
13648: LD_INT 242
13650: PPUSH
13651: LD_INT 75
13653: PPUSH
13654: LD_INT 0
13656: PPUSH
13657: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13661: LD_ADDR_EXP 90
13665: PUSH
13666: LD_STRING Heike
13668: PPUSH
13669: CALL_OW 25
13673: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13674: LD_INT 14
13676: PPUSH
13677: LD_INT 3
13679: PPUSH
13680: LD_INT 1
13682: PPUSH
13683: LD_INT 27
13685: PPUSH
13686: LD_INT 100
13688: PPUSH
13689: CALL 68298 0 5
// veh := CreateVehicle ;
13693: LD_ADDR_VAR 0 3
13697: PUSH
13698: CALL_OW 45
13702: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13703: LD_VAR 0 3
13707: PPUSH
13708: LD_INT 1
13710: PPUSH
13711: CALL_OW 242
// SetDir ( veh , 4 ) ;
13715: LD_VAR 0 3
13719: PPUSH
13720: LD_INT 4
13722: PPUSH
13723: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13727: LD_VAR 0 3
13731: PPUSH
13732: LD_INT 241
13734: PPUSH
13735: LD_INT 72
13737: PPUSH
13738: LD_INT 0
13740: PPUSH
13741: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13745: LD_EXP 90
13749: PPUSH
13750: LD_VAR 0 3
13754: PPUSH
13755: CALL_OW 52
// if KhatamStatus then
13759: LD_EXP 8
13763: IFFALSE 13814
// begin Khatam := NewCharacter ( Khatam ) ;
13765: LD_ADDR_EXP 91
13769: PUSH
13770: LD_STRING Khatam
13772: PPUSH
13773: CALL_OW 25
13777: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13778: LD_EXP 91
13782: PPUSH
13783: LD_INT 245
13785: PPUSH
13786: LD_INT 78
13788: PPUSH
13789: LD_INT 3
13791: PPUSH
13792: LD_INT 0
13794: PPUSH
13795: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13799: LD_EXP 91
13803: PPUSH
13804: LD_INT 4
13806: PPUSH
13807: LD_INT 10
13809: PPUSH
13810: CALL_OW 237
// end ; for i = 1 to Difficulty do
13814: LD_ADDR_VAR 0 2
13818: PUSH
13819: DOUBLE
13820: LD_INT 1
13822: DEC
13823: ST_TO_ADDR
13824: LD_OWVAR 67
13828: PUSH
13829: FOR_TO
13830: IFFALSE 13896
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13832: LD_INT 0
13834: PPUSH
13835: LD_INT 7
13837: PUSH
13838: LD_OWVAR 67
13842: PLUS
13843: PPUSH
13844: CALL_OW 384
// un := CreateHuman ;
13848: LD_ADDR_VAR 0 4
13852: PUSH
13853: CALL_OW 44
13857: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13858: LD_VAR 0 4
13862: PPUSH
13863: LD_INT 28
13865: PUSH
13866: LD_INT 29
13868: PUSH
13869: EMPTY
13870: LIST
13871: LIST
13872: PUSH
13873: LD_VAR 0 2
13877: PUSH
13878: LD_INT 2
13880: MOD
13881: PUSH
13882: LD_INT 1
13884: PLUS
13885: ARRAY
13886: PPUSH
13887: LD_INT 0
13889: PPUSH
13890: CALL_OW 49
// end ;
13894: GO 13829
13896: POP
13897: POP
// for i = 1 to 6 do
13898: LD_ADDR_VAR 0 2
13902: PUSH
13903: DOUBLE
13904: LD_INT 1
13906: DEC
13907: ST_TO_ADDR
13908: LD_INT 6
13910: PUSH
13911: FOR_TO
13912: IFFALSE 13957
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13914: LD_INT 0
13916: PPUSH
13917: LD_INT 7
13919: PUSH
13920: LD_OWVAR 67
13924: PLUS
13925: PPUSH
13926: CALL_OW 381
// un := CreateHuman ;
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: CALL_OW 44
13939: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13940: LD_VAR 0 4
13944: PPUSH
13945: LD_INT 28
13947: PPUSH
13948: LD_INT 0
13950: PPUSH
13951: CALL_OW 49
// end ;
13955: GO 13911
13957: POP
13958: POP
// for i = 1 to 3 do
13959: LD_ADDR_VAR 0 2
13963: PUSH
13964: DOUBLE
13965: LD_INT 1
13967: DEC
13968: ST_TO_ADDR
13969: LD_INT 3
13971: PUSH
13972: FOR_TO
13973: IFFALSE 14021
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13975: LD_INT 0
13977: PPUSH
13978: LD_INT 8
13980: PPUSH
13981: LD_INT 7
13983: PUSH
13984: LD_OWVAR 67
13988: PLUS
13989: PPUSH
13990: CALL_OW 380
// un := CreateHuman ;
13994: LD_ADDR_VAR 0 4
13998: PUSH
13999: CALL_OW 44
14003: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14004: LD_VAR 0 4
14008: PPUSH
14009: LD_INT 28
14011: PPUSH
14012: LD_INT 0
14014: PPUSH
14015: CALL_OW 49
// end ;
14019: GO 13972
14021: POP
14022: POP
// for i = 1 to 3 do
14023: LD_ADDR_VAR 0 2
14027: PUSH
14028: DOUBLE
14029: LD_INT 1
14031: DEC
14032: ST_TO_ADDR
14033: LD_INT 3
14035: PUSH
14036: FOR_TO
14037: IFFALSE 14127
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14039: LD_INT 14
14041: PPUSH
14042: LD_INT 2
14044: PPUSH
14045: LD_INT 1
14047: PPUSH
14048: LD_INT 28
14050: PPUSH
14051: LD_INT 80
14053: PPUSH
14054: CALL 68298 0 5
// veh := CreateVehicle ;
14058: LD_ADDR_VAR 0 3
14062: PUSH
14063: CALL_OW 45
14067: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14068: LD_VAR 0 3
14072: PPUSH
14073: LD_INT 3
14075: PPUSH
14076: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14080: LD_VAR 0 3
14084: PPUSH
14085: LD_INT 29
14087: PPUSH
14088: LD_INT 0
14090: PPUSH
14091: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14095: LD_INT 0
14097: PPUSH
14098: LD_INT 7
14100: PUSH
14101: LD_OWVAR 67
14105: PLUS
14106: PPUSH
14107: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14111: CALL_OW 44
14115: PPUSH
14116: LD_VAR 0 3
14120: PPUSH
14121: CALL_OW 52
// end ;
14125: GO 14036
14127: POP
14128: POP
// for i = 1 to 5 + Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_INT 5
14141: PUSH
14142: LD_OWVAR 67
14146: PLUS
14147: PUSH
14148: FOR_TO
14149: IFFALSE 14276
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14151: LD_INT 14
14153: PPUSH
14154: LD_INT 1
14156: PPUSH
14157: LD_INT 3
14159: PPUSH
14160: CALL_OW 12
14164: PPUSH
14165: LD_INT 1
14167: PPUSH
14168: LD_INT 28
14170: PUSH
14171: LD_INT 26
14173: PUSH
14174: LD_INT 27
14176: PUSH
14177: LD_INT 25
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: PUSH
14186: LD_VAR 0 2
14190: PUSH
14191: LD_INT 4
14193: MOD
14194: PUSH
14195: LD_INT 1
14197: PLUS
14198: ARRAY
14199: PPUSH
14200: LD_INT 80
14202: PPUSH
14203: CALL 68298 0 5
// veh := CreateVehicle ;
14207: LD_ADDR_VAR 0 3
14211: PUSH
14212: CALL_OW 45
14216: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14217: LD_VAR 0 3
14221: PPUSH
14222: LD_INT 4
14224: PPUSH
14225: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14229: LD_VAR 0 3
14233: PPUSH
14234: LD_INT 28
14236: PPUSH
14237: LD_INT 0
14239: PPUSH
14240: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14244: LD_INT 0
14246: PPUSH
14247: LD_INT 7
14249: PUSH
14250: LD_OWVAR 67
14254: PLUS
14255: PPUSH
14256: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14260: CALL_OW 44
14264: PPUSH
14265: LD_VAR 0 3
14269: PPUSH
14270: CALL_OW 52
// end ;
14274: GO 14148
14276: POP
14277: POP
// for i = 1 to 3 do
14278: LD_ADDR_VAR 0 2
14282: PUSH
14283: DOUBLE
14284: LD_INT 1
14286: DEC
14287: ST_TO_ADDR
14288: LD_INT 3
14290: PUSH
14291: FOR_TO
14292: IFFALSE 14352
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14294: LD_INT 14
14296: PPUSH
14297: LD_INT 3
14299: PPUSH
14300: LD_INT 5
14302: PPUSH
14303: LD_INT 29
14305: PPUSH
14306: LD_INT 80
14308: PPUSH
14309: CALL 68298 0 5
// veh := CreateVehicle ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: CALL_OW 45
14322: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14323: LD_VAR 0 3
14327: PPUSH
14328: LD_INT 4
14330: PPUSH
14331: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14335: LD_VAR 0 3
14339: PPUSH
14340: LD_INT 28
14342: PPUSH
14343: LD_INT 0
14345: PPUSH
14346: CALL_OW 49
// end ;
14350: GO 14291
14352: POP
14353: POP
// end ;
14354: LD_VAR 0 1
14358: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14359: LD_INT 22
14361: PUSH
14362: LD_INT 2
14364: PUSH
14365: EMPTY
14366: LIST
14367: LIST
14368: PPUSH
14369: CALL_OW 69
14373: IFFALSE 14673
14375: GO 14377
14377: DISABLE
14378: LD_INT 0
14380: PPUSH
14381: PPUSH
14382: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14383: LD_ADDR_VAR 0 3
14387: PUSH
14388: LD_INT 22
14390: PUSH
14391: LD_INT 2
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: PUSH
14398: LD_INT 25
14400: PUSH
14401: LD_INT 4
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: PPUSH
14412: CALL_OW 69
14416: PUSH
14417: LD_EXP 91
14421: DIFF
14422: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14423: LD_ADDR_VAR 0 2
14427: PUSH
14428: LD_INT 22
14430: PUSH
14431: LD_INT 2
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PPUSH
14438: CALL_OW 69
14442: PUSH
14443: LD_EXP 91
14447: PUSH
14448: LD_VAR 0 3
14452: UNION
14453: DIFF
14454: ST_TO_ADDR
// if Khatam then
14455: LD_EXP 91
14459: IFFALSE 14476
// ComMoveXY ( Khatam , 211 , 92 ) ;
14461: LD_EXP 91
14465: PPUSH
14466: LD_INT 211
14468: PPUSH
14469: LD_INT 92
14471: PPUSH
14472: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14476: LD_INT 197
14478: PPUSH
14479: LD_INT 80
14481: PPUSH
14482: LD_INT 2
14484: PPUSH
14485: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14489: LD_INT 213
14491: PPUSH
14492: LD_INT 90
14494: PPUSH
14495: LD_INT 2
14497: PPUSH
14498: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14502: LD_INT 215
14504: PPUSH
14505: LD_INT 129
14507: PPUSH
14508: LD_INT 2
14510: PPUSH
14511: CALL_OW 441
// if sci then
14515: LD_VAR 0 3
14519: IFFALSE 14540
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14521: LD_VAR 0 3
14525: PUSH
14526: LD_INT 1
14528: ARRAY
14529: PPUSH
14530: LD_INT 197
14532: PPUSH
14533: LD_INT 80
14535: PPUSH
14536: CALL_OW 158
// if sci > 1 then
14540: LD_VAR 0 3
14544: PUSH
14545: LD_INT 1
14547: GREATER
14548: IFFALSE 14569
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14550: LD_VAR 0 3
14554: PUSH
14555: LD_INT 2
14557: ARRAY
14558: PPUSH
14559: LD_INT 213
14561: PPUSH
14562: LD_INT 90
14564: PPUSH
14565: CALL_OW 158
// if sci > 2 then
14569: LD_VAR 0 3
14573: PUSH
14574: LD_INT 2
14576: GREATER
14577: IFFALSE 14598
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14579: LD_VAR 0 3
14583: PUSH
14584: LD_INT 3
14586: ARRAY
14587: PPUSH
14588: LD_INT 215
14590: PPUSH
14591: LD_INT 129
14593: PPUSH
14594: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14598: LD_INT 35
14600: PPUSH
14601: CALL_OW 67
// for i in tmp do
14605: LD_ADDR_VAR 0 1
14609: PUSH
14610: LD_VAR 0 2
14614: PUSH
14615: FOR_IN
14616: IFFALSE 14654
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14618: LD_VAR 0 1
14622: PPUSH
14623: LD_INT 81
14625: PUSH
14626: LD_INT 2
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PPUSH
14633: CALL_OW 69
14637: PPUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 74
14647: PPUSH
14648: CALL_OW 115
14652: GO 14615
14654: POP
14655: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14656: LD_INT 22
14658: PUSH
14659: LD_INT 2
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14598
// end ; end_of_file
14673: PPOPN 3
14675: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14676: LD_INT 0
14678: PPUSH
14679: PPUSH
14680: PPUSH
14681: PPUSH
14682: PPUSH
14683: PPUSH
14684: PPUSH
14685: PPUSH
14686: PPUSH
// Video ( true ) ;
14687: LD_INT 1
14689: PPUSH
14690: CALL 103953 0 1
// if debug then
14694: LD_EXP 1
14698: IFFALSE 14708
// dialogue_skipped := true ;
14700: LD_ADDR_OWVAR 59
14704: PUSH
14705: LD_INT 1
14707: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14708: LD_ADDR_VAR 0 5
14712: PUSH
14713: LD_INT 7
14715: PPUSH
14716: LD_INT 0
14718: PPUSH
14719: CALL_OW 517
14723: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14724: LD_ADDR_VAR 0 2
14728: PUSH
14729: DOUBLE
14730: LD_INT 1
14732: DEC
14733: ST_TO_ADDR
14734: LD_VAR 0 5
14738: PUSH
14739: LD_INT 1
14741: ARRAY
14742: PUSH
14743: FOR_TO
14744: IFFALSE 14789
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14746: LD_VAR 0 5
14750: PUSH
14751: LD_INT 1
14753: ARRAY
14754: PUSH
14755: LD_VAR 0 2
14759: ARRAY
14760: PPUSH
14761: LD_VAR 0 5
14765: PUSH
14766: LD_INT 2
14768: ARRAY
14769: PUSH
14770: LD_VAR 0 2
14774: ARRAY
14775: PPUSH
14776: LD_INT 1
14778: PPUSH
14779: LD_INT 15
14781: NEG
14782: PPUSH
14783: CALL 103867 0 4
14787: GO 14743
14789: POP
14790: POP
// CenterNowOnUnits ( Powell ) ;
14791: LD_EXP 55
14795: PPUSH
14796: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14800: LD_ADDR_VAR 0 5
14804: PUSH
14805: LD_EXP 53
14809: PUSH
14810: EMPTY
14811: LIST
14812: ST_TO_ADDR
// if GirlNewVeh then
14813: LD_EXP 54
14817: IFFALSE 14835
// tmp := tmp ^ GirlNewVeh ;
14819: LD_ADDR_VAR 0 5
14823: PUSH
14824: LD_VAR 0 5
14828: PUSH
14829: LD_EXP 54
14833: ADD
14834: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14835: LD_VAR 0 5
14839: PPUSH
14840: LD_INT 60
14842: PPUSH
14843: LD_INT 109
14845: PPUSH
14846: CALL_OW 111
// if KappaStatus then
14850: LD_EXP 2
14854: IFFALSE 14906
// begin Say ( JMM , D1nT-JMM-1 ) ;
14856: LD_EXP 36
14860: PPUSH
14861: LD_STRING D1nT-JMM-1
14863: PPUSH
14864: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14868: LD_EXP 55
14872: PPUSH
14873: LD_STRING D1T-Pow-1
14875: PPUSH
14876: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14880: LD_EXP 36
14884: PPUSH
14885: LD_STRING D1T-JMM-2
14887: PPUSH
14888: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14892: LD_EXP 55
14896: PPUSH
14897: LD_STRING D1T-Pow-2
14899: PPUSH
14900: CALL_OW 88
// end else
14904: GO 15112
// if JMMGirlStatus then
14906: LD_EXP 6
14910: IFFALSE 15055
// begin Say ( JMM , D1T-JMM-1 ) ;
14912: LD_EXP 36
14916: PPUSH
14917: LD_STRING D1T-JMM-1
14919: PPUSH
14920: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14924: LD_EXP 55
14928: PPUSH
14929: LD_STRING D1T-Pow-1
14931: PPUSH
14932: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14936: LD_EXP 36
14940: PPUSH
14941: LD_STRING D1T-JMM-3
14943: PPUSH
14944: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14948: LD_EXP 55
14952: PPUSH
14953: LD_STRING D1T-Pow-3
14955: PPUSH
14956: CALL_OW 88
// if JMMGirl then
14960: LD_EXP 7
14964: IFFALSE 15053
// begin case JMMGirl of 1 :
14966: LD_EXP 7
14970: PUSH
14971: LD_INT 1
14973: DOUBLE
14974: EQUAL
14975: IFTRUE 14979
14977: GO 14994
14979: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
14980: LD_EXP 37
14984: PPUSH
14985: LD_STRING D1T-Joan-3
14987: PPUSH
14988: CALL_OW 88
14992: GO 15041
14994: LD_INT 2
14996: DOUBLE
14997: EQUAL
14998: IFTRUE 15002
15000: GO 15017
15002: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15003: LD_EXP 39
15007: PPUSH
15008: LD_STRING D1T-Lisa-3
15010: PPUSH
15011: CALL_OW 88
15015: GO 15041
15017: LD_INT 3
15019: DOUBLE
15020: EQUAL
15021: IFTRUE 15025
15023: GO 15040
15025: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15026: LD_EXP 51
15030: PPUSH
15031: LD_STRING D1T-Con-3
15033: PPUSH
15034: CALL_OW 88
15038: GO 15041
15040: POP
// Say ( Powell , D1T-Pow-4 ) ;
15041: LD_EXP 55
15045: PPUSH
15046: LD_STRING D1T-Pow-4
15048: PPUSH
15049: CALL_OW 88
// end ; end else
15053: GO 15112
// if not FastEnd then
15055: LD_EXP 11
15059: NOT
15060: IFFALSE 15088
// begin Say ( JMM , D1T-JMM-4 ) ;
15062: LD_EXP 36
15066: PPUSH
15067: LD_STRING D1T-JMM-4
15069: PPUSH
15070: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15074: LD_EXP 55
15078: PPUSH
15079: LD_STRING D1T-Pow-5
15081: PPUSH
15082: CALL_OW 88
// end else
15086: GO 15112
// begin Say ( JMM , D1nT-JMM-1 ) ;
15088: LD_EXP 36
15092: PPUSH
15093: LD_STRING D1nT-JMM-1
15095: PPUSH
15096: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15100: LD_EXP 55
15104: PPUSH
15105: LD_STRING D1nT-Pow-1
15107: PPUSH
15108: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15112: LD_INT 35
15114: PPUSH
15115: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15119: LD_EXP 53
15123: PPUSH
15124: CALL_OW 314
15128: NOT
15129: IFFALSE 15112
// ComExitVehicle ( JMM ) ;
15131: LD_EXP 36
15135: PPUSH
15136: CALL_OW 121
// wait ( 3 ) ;
15140: LD_INT 3
15142: PPUSH
15143: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15147: LD_EXP 36
15151: PPUSH
15152: LD_INT 60
15154: PPUSH
15155: LD_INT 94
15157: PPUSH
15158: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15162: LD_EXP 36
15166: PPUSH
15167: LD_EXP 55
15171: PPUSH
15172: CALL_OW 179
// if Joan then
15176: LD_EXP 37
15180: IFFALSE 15234
// begin ComExitVehicle ( Joan ) ;
15182: LD_EXP 37
15186: PPUSH
15187: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15191: LD_EXP 37
15195: PPUSH
15196: LD_INT 35
15198: PPUSH
15199: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15203: LD_EXP 37
15207: PPUSH
15208: LD_INT 65
15210: PPUSH
15211: LD_INT 104
15213: PPUSH
15214: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15218: LD_EXP 37
15222: PPUSH
15223: LD_EXP 36
15227: PPUSH
15228: CALL_OW 179
// end else
15232: GO 15368
// if Lisa and JMMGirl = 2 then
15234: LD_EXP 39
15238: PUSH
15239: LD_EXP 7
15243: PUSH
15244: LD_INT 2
15246: EQUAL
15247: AND
15248: IFFALSE 15302
// begin ComExitVehicle ( Lisa ) ;
15250: LD_EXP 39
15254: PPUSH
15255: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15259: LD_EXP 39
15263: PPUSH
15264: LD_INT 35
15266: PPUSH
15267: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15271: LD_EXP 39
15275: PPUSH
15276: LD_INT 65
15278: PPUSH
15279: LD_INT 104
15281: PPUSH
15282: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15286: LD_EXP 39
15290: PPUSH
15291: LD_EXP 36
15295: PPUSH
15296: CALL_OW 179
// end else
15300: GO 15368
// if Connie and JMMGirl = 3 then
15302: LD_EXP 51
15306: PUSH
15307: LD_EXP 7
15311: PUSH
15312: LD_INT 3
15314: EQUAL
15315: AND
15316: IFFALSE 15368
// begin ComExitVehicle ( Connie ) ;
15318: LD_EXP 51
15322: PPUSH
15323: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15327: LD_EXP 51
15331: PPUSH
15332: LD_INT 35
15334: PPUSH
15335: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15339: LD_EXP 51
15343: PPUSH
15344: LD_INT 65
15346: PPUSH
15347: LD_INT 104
15349: PPUSH
15350: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15354: LD_EXP 51
15358: PPUSH
15359: LD_EXP 36
15363: PPUSH
15364: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15368: LD_INT 35
15370: PPUSH
15371: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15375: LD_EXP 36
15379: PPUSH
15380: LD_EXP 55
15384: PPUSH
15385: CALL_OW 296
15389: PUSH
15390: LD_INT 6
15392: LESS
15393: IFFALSE 15368
// wait ( 0 0$0.5 ) ;
15395: LD_INT 18
15397: PPUSH
15398: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15402: LD_EXP 36
15406: PPUSH
15407: LD_STRING D1-JMM-1
15409: PPUSH
15410: CALL_OW 88
// async ;
15414: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15415: LD_EXP 55
15419: PPUSH
15420: LD_STRING D1-Pow-1
15422: PPUSH
15423: CALL_OW 88
// if not dialogue_skipped then
15427: LD_OWVAR 59
15431: NOT
15432: IFFALSE 15441
// wait ( 0 0$2 ) ;
15434: LD_INT 70
15436: PPUSH
15437: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15441: LD_INT 170
15443: PPUSH
15444: LD_INT 99
15446: PPUSH
15447: LD_INT 1
15449: PPUSH
15450: LD_INT 6
15452: NEG
15453: PPUSH
15454: CALL 103867 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15458: LD_INT 174
15460: PPUSH
15461: LD_INT 115
15463: PPUSH
15464: LD_INT 1
15466: PPUSH
15467: LD_INT 6
15469: NEG
15470: PPUSH
15471: CALL 103867 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15475: LD_INT 169
15477: PPUSH
15478: LD_INT 71
15480: PPUSH
15481: LD_INT 1
15483: PPUSH
15484: LD_INT 6
15486: NEG
15487: PPUSH
15488: CALL 103867 0 4
// if not dialogue_skipped then
15492: LD_OWVAR 59
15496: NOT
15497: IFFALSE 15516
// begin CenterOnXY ( 170 , 99 ) ;
15499: LD_INT 170
15501: PPUSH
15502: LD_INT 99
15504: PPUSH
15505: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15509: LD_INT 80
15511: PPUSH
15512: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15516: LD_INT 75
15518: PPUSH
15519: LD_INT 53
15521: PPUSH
15522: LD_INT 1
15524: PPUSH
15525: LD_INT 9
15527: NEG
15528: PPUSH
15529: CALL 103867 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15533: LD_INT 54
15535: PPUSH
15536: LD_INT 42
15538: PPUSH
15539: LD_INT 1
15541: PPUSH
15542: LD_INT 9
15544: NEG
15545: PPUSH
15546: CALL 103867 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15550: LD_INT 62
15552: PPUSH
15553: LD_INT 51
15555: PPUSH
15556: LD_INT 1
15558: PPUSH
15559: LD_INT 9
15561: NEG
15562: PPUSH
15563: CALL 103867 0 4
// if not dialogue_skipped then
15567: LD_OWVAR 59
15571: NOT
15572: IFFALSE 15591
// begin CenterOnXY ( 75 , 53 ) ;
15574: LD_INT 75
15576: PPUSH
15577: LD_INT 53
15579: PPUSH
15580: CALL_OW 84
// wait ( 0 0$4 ) ;
15584: LD_INT 140
15586: PPUSH
15587: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15591: LD_EXP 55
15595: PPUSH
15596: CALL_OW 87
// if not dialogue_skipped then
15600: LD_OWVAR 59
15604: NOT
15605: IFFALSE 15614
// wait ( 0 0$2 ) ;
15607: LD_INT 70
15609: PPUSH
15610: CALL_OW 67
// sync ;
15614: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15615: LD_EXP 36
15619: PPUSH
15620: LD_STRING D1-JMM-2
15622: PPUSH
15623: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15627: LD_EXP 55
15631: PPUSH
15632: LD_STRING D1-Pow-2
15634: PPUSH
15635: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15639: LD_EXP 36
15643: PPUSH
15644: LD_STRING D1-JMM-3
15646: PPUSH
15647: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15651: LD_EXP 55
15655: PPUSH
15656: LD_STRING D1-Pow-3
15658: PPUSH
15659: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15663: LD_EXP 36
15667: PPUSH
15668: LD_STRING D1-JMM-4
15670: PPUSH
15671: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15675: LD_EXP 55
15679: PPUSH
15680: LD_STRING D1-Pow-4
15682: PPUSH
15683: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15687: LD_EXP 36
15691: PPUSH
15692: LD_STRING D1-JMM-5
15694: PPUSH
15695: CALL_OW 88
// async ;
15699: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15700: LD_EXP 55
15704: PPUSH
15705: LD_STRING D1-Pow-5
15707: PPUSH
15708: CALL_OW 88
// if not dialogue_skipped then
15712: LD_OWVAR 59
15716: NOT
15717: IFFALSE 15726
// wait ( 0 0$3.6 ) ;
15719: LD_INT 126
15721: PPUSH
15722: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15726: LD_INT 134
15728: PPUSH
15729: LD_INT 210
15731: PPUSH
15732: LD_INT 1
15734: PPUSH
15735: LD_INT 11
15737: NEG
15738: PPUSH
15739: CALL 103867 0 4
// if not dialogue_skipped then
15743: LD_OWVAR 59
15747: NOT
15748: IFFALSE 15767
// begin CenterOnXY ( 134 , 210 ) ;
15750: LD_INT 134
15752: PPUSH
15753: LD_INT 210
15755: PPUSH
15756: CALL_OW 84
// wait ( 0 0$2 ) ;
15760: LD_INT 70
15762: PPUSH
15763: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15767: LD_INT 101
15769: PPUSH
15770: LD_INT 159
15772: PPUSH
15773: LD_INT 1
15775: PPUSH
15776: LD_INT 10
15778: NEG
15779: PPUSH
15780: CALL 103867 0 4
// if not dialogue_skipped then
15784: LD_OWVAR 59
15788: NOT
15789: IFFALSE 15808
// begin CenterOnXY ( 101 , 159 ) ;
15791: LD_INT 101
15793: PPUSH
15794: LD_INT 159
15796: PPUSH
15797: CALL_OW 84
// wait ( 0 0$2 ) ;
15801: LD_INT 70
15803: PPUSH
15804: CALL_OW 67
// end ; sync ;
15808: SYNC
// CenterNowOnUnits ( Powell ) ;
15809: LD_EXP 55
15813: PPUSH
15814: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15818: LD_ADDR_VAR 0 6
15822: PUSH
15823: LD_INT 1
15825: PUSH
15826: LD_INT 2
15828: PUSH
15829: LD_INT 3
15831: PUSH
15832: LD_INT 4
15834: PUSH
15835: LD_INT 5
15837: PUSH
15838: LD_INT 6
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: LIST
15845: LIST
15846: LIST
15847: LIST
15848: ST_TO_ADDR
// if not dialogue_skipped then
15849: LD_OWVAR 59
15853: NOT
15854: IFFALSE 16023
// begin game_speed := 4 ;
15856: LD_ADDR_OWVAR 65
15860: PUSH
15861: LD_INT 4
15863: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15864: LD_INT 210
15866: PPUSH
15867: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15871: LD_ADDR_VAR 0 7
15875: PUSH
15876: LD_STRING Q1
15878: PPUSH
15879: LD_VAR 0 6
15883: PPUSH
15884: CALL_OW 98
15888: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15889: LD_ADDR_VAR 0 7
15893: PUSH
15894: LD_STRING Q1
15896: PPUSH
15897: LD_VAR 0 6
15901: PPUSH
15902: CALL_OW 98
15906: ST_TO_ADDR
// options = options diff dec ;
15907: LD_ADDR_VAR 0 6
15911: PUSH
15912: LD_VAR 0 6
15916: PUSH
15917: LD_VAR 0 7
15921: DIFF
15922: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15923: LD_VAR 0 7
15927: PPUSH
15928: LD_VAR 0 6
15932: PPUSH
15933: CALL 17306 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15937: LD_VAR 0 7
15941: PUSH
15942: LD_INT 5
15944: PUSH
15945: LD_INT 6
15947: PUSH
15948: EMPTY
15949: LIST
15950: LIST
15951: IN
15952: PUSH
15953: LD_VAR 0 6
15957: PUSH
15958: LD_INT 2
15960: EQUAL
15961: OR
15962: IFFALSE 15889
// if not ( dec in [ 5 , 6 ] ) then
15964: LD_VAR 0 7
15968: PUSH
15969: LD_INT 5
15971: PUSH
15972: LD_INT 6
15974: PUSH
15975: EMPTY
15976: LIST
15977: LIST
15978: IN
15979: NOT
15980: IFFALSE 16023
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
15982: LD_ADDR_VAR 0 7
15986: PUSH
15987: LD_STRING Q1a
15989: PPUSH
15990: LD_INT 1
15992: PUSH
15993: LD_INT 2
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: PPUSH
16000: CALL_OW 98
16004: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16005: LD_VAR 0 7
16009: PUSH
16010: LD_INT 4
16012: PLUS
16013: PPUSH
16014: LD_VAR 0 6
16018: PPUSH
16019: CALL 17306 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16023: LD_INT 81
16025: PPUSH
16026: LD_INT 127
16028: PPUSH
16029: CALL_OW 84
// amount := 5 ;
16033: LD_ADDR_VAR 0 8
16037: PUSH
16038: LD_INT 5
16040: ST_TO_ADDR
// macmilan_squad := [ ] ;
16041: LD_ADDR_VAR 0 9
16045: PUSH
16046: EMPTY
16047: ST_TO_ADDR
// if vip < amount then
16048: LD_EXP 56
16052: PUSH
16053: LD_VAR 0 8
16057: LESS
16058: IFFALSE 16102
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16060: LD_ADDR_VAR 0 5
16064: PUSH
16065: LD_EXP 56
16069: PUSH
16070: LD_INT 22
16072: PUSH
16073: LD_INT 4
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: PUSH
16080: LD_INT 21
16082: PUSH
16083: LD_INT 1
16085: PUSH
16086: EMPTY
16087: LIST
16088: LIST
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: PPUSH
16094: CALL_OW 69
16098: UNION
16099: ST_TO_ADDR
16100: GO 16112
// tmp := vip ;
16102: LD_ADDR_VAR 0 5
16106: PUSH
16107: LD_EXP 56
16111: ST_TO_ADDR
// tmp := tmp diff Powell ;
16112: LD_ADDR_VAR 0 5
16116: PUSH
16117: LD_VAR 0 5
16121: PUSH
16122: LD_EXP 55
16126: DIFF
16127: ST_TO_ADDR
// if tmp < amount then
16128: LD_VAR 0 5
16132: PUSH
16133: LD_VAR 0 8
16137: LESS
16138: IFFALSE 16150
// amount := tmp ;
16140: LD_ADDR_VAR 0 8
16144: PUSH
16145: LD_VAR 0 5
16149: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16150: LD_VAR 0 5
16154: PUSH
16155: LD_INT 1
16157: ARRAY
16158: PPUSH
16159: CALL_OW 257
16163: PUSH
16164: LD_INT 2
16166: NONEQUAL
16167: IFFALSE 16229
// begin if IsInUnit ( tmp [ 1 ] ) then
16169: LD_VAR 0 5
16173: PUSH
16174: LD_INT 1
16176: ARRAY
16177: PPUSH
16178: CALL_OW 310
16182: IFFALSE 16197
// ComExitBuilding ( tmp [ 1 ] ) ;
16184: LD_VAR 0 5
16188: PUSH
16189: LD_INT 1
16191: ARRAY
16192: PPUSH
16193: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16197: LD_VAR 0 5
16201: PUSH
16202: LD_INT 1
16204: ARRAY
16205: PPUSH
16206: LD_INT 387
16208: PPUSH
16209: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16213: LD_VAR 0 5
16217: PUSH
16218: LD_INT 1
16220: ARRAY
16221: PPUSH
16222: LD_INT 2
16224: PPUSH
16225: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16229: LD_EXP 36
16233: PPUSH
16234: LD_INT 82
16236: PPUSH
16237: LD_INT 129
16239: PPUSH
16240: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16244: LD_EXP 36
16248: PPUSH
16249: LD_EXP 55
16253: PPUSH
16254: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16258: LD_INT 22
16260: PUSH
16261: LD_INT 1
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: PPUSH
16268: CALL_OW 69
16272: PUSH
16273: LD_EXP 36
16277: DIFF
16278: PPUSH
16279: LD_INT 84
16281: PPUSH
16282: LD_INT 128
16284: PPUSH
16285: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16289: LD_INT 22
16291: PUSH
16292: LD_INT 1
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: PPUSH
16299: CALL_OW 69
16303: PUSH
16304: LD_EXP 36
16308: DIFF
16309: PPUSH
16310: LD_EXP 36
16314: PPUSH
16315: CALL_OW 179
// for i = 1 to amount do
16319: LD_ADDR_VAR 0 2
16323: PUSH
16324: DOUBLE
16325: LD_INT 1
16327: DEC
16328: ST_TO_ADDR
16329: LD_VAR 0 8
16333: PUSH
16334: FOR_TO
16335: IFFALSE 16503
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16337: LD_ADDR_VAR 0 9
16341: PUSH
16342: LD_VAR 0 9
16346: PUSH
16347: LD_VAR 0 5
16351: PUSH
16352: LD_VAR 0 2
16356: ARRAY
16357: ADD
16358: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16359: LD_VAR 0 5
16363: PUSH
16364: LD_VAR 0 2
16368: ARRAY
16369: PPUSH
16370: CALL_OW 310
16374: IFFALSE 16391
// AddComExitBuilding ( tmp [ i ] ) ;
16376: LD_VAR 0 5
16380: PUSH
16381: LD_VAR 0 2
16385: ARRAY
16386: PPUSH
16387: CALL_OW 182
// if i = 2 and JMMNewVeh then
16391: LD_VAR 0 2
16395: PUSH
16396: LD_INT 2
16398: EQUAL
16399: PUSH
16400: LD_EXP 53
16404: AND
16405: IFFALSE 16463
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16407: LD_VAR 0 5
16411: PUSH
16412: LD_VAR 0 2
16416: ARRAY
16417: PPUSH
16418: LD_EXP 53
16422: PPUSH
16423: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16427: LD_VAR 0 5
16431: PUSH
16432: LD_VAR 0 2
16436: ARRAY
16437: PPUSH
16438: LD_INT 86
16440: PPUSH
16441: LD_INT 133
16443: PPUSH
16444: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16448: LD_VAR 0 5
16452: PUSH
16453: LD_VAR 0 2
16457: ARRAY
16458: PPUSH
16459: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16463: LD_VAR 0 5
16467: PUSH
16468: LD_VAR 0 2
16472: ARRAY
16473: PPUSH
16474: LD_INT 8
16476: PPUSH
16477: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16481: LD_VAR 0 5
16485: PUSH
16486: LD_VAR 0 2
16490: ARRAY
16491: PPUSH
16492: LD_EXP 36
16496: PPUSH
16497: CALL_OW 179
// end ;
16501: GO 16334
16503: POP
16504: POP
// if GirlNewVeh then
16505: LD_EXP 54
16509: IFFALSE 16523
// SetSide ( GirlNewVeh , 4 ) ;
16511: LD_EXP 54
16515: PPUSH
16516: LD_INT 4
16518: PPUSH
16519: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16523: LD_INT 35
16525: PPUSH
16526: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16530: LD_VAR 0 9
16534: PPUSH
16535: LD_INT 95
16537: PUSH
16538: LD_INT 9
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PPUSH
16545: CALL_OW 72
16549: PUSH
16550: LD_INT 0
16552: EQUAL
16553: PUSH
16554: LD_EXP 36
16558: PPUSH
16559: LD_INT 9
16561: PPUSH
16562: CALL_OW 308
16566: NOT
16567: AND
16568: IFFALSE 16523
// wait ( 0 0$2 ) ;
16570: LD_INT 70
16572: PPUSH
16573: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16577: LD_VAR 0 9
16581: PPUSH
16582: LD_INT 1
16584: PPUSH
16585: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16589: LD_INT 21
16591: PUSH
16592: LD_INT 2
16594: PUSH
16595: EMPTY
16596: LIST
16597: LIST
16598: PUSH
16599: LD_INT 92
16601: PUSH
16602: LD_INT 83
16604: PUSH
16605: LD_INT 130
16607: PUSH
16608: LD_INT 10
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: PPUSH
16621: CALL_OW 69
16625: PPUSH
16626: LD_INT 1
16628: PPUSH
16629: CALL_OW 235
// Video ( false ) ;
16633: LD_INT 0
16635: PPUSH
16636: CALL 103953 0 1
// ChangeMissionObjectives ( M1 ) ;
16640: LD_STRING M1
16642: PPUSH
16643: CALL_OW 337
// SaveForQuickRestart ;
16647: CALL_OW 22
// missionStart := true ;
16651: LD_ADDR_EXP 13
16655: PUSH
16656: LD_INT 1
16658: ST_TO_ADDR
// missionStage := 2 ;
16659: LD_ADDR_EXP 15
16663: PUSH
16664: LD_INT 2
16666: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16667: LD_INT 105
16669: PPUSH
16670: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
16674: LD_ADDR_VAR 0 5
16678: PUSH
16679: LD_VAR 0 5
16683: PUSH
16684: LD_INT 22
16686: PUSH
16687: LD_INT 1
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: PUSH
16694: LD_INT 21
16696: PUSH
16697: LD_INT 1
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: PUSH
16704: EMPTY
16705: LIST
16706: LIST
16707: PPUSH
16708: CALL_OW 69
16712: DIFF
16713: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16714: LD_ADDR_EXP 99
16718: PUSH
16719: LD_EXP 99
16723: PPUSH
16724: LD_INT 4
16726: PPUSH
16727: LD_INT 22
16729: PUSH
16730: LD_INT 4
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PUSH
16737: LD_INT 23
16739: PUSH
16740: LD_INT 1
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: LD_INT 3
16749: PUSH
16750: LD_INT 21
16752: PUSH
16753: LD_INT 2
16755: PUSH
16756: EMPTY
16757: LIST
16758: LIST
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL_OW 69
16773: PUSH
16774: LD_EXP 55
16778: DIFF
16779: PPUSH
16780: CALL_OW 1
16784: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16785: LD_ADDR_VAR 0 4
16789: PUSH
16790: LD_INT 22
16792: PUSH
16793: LD_INT 4
16795: PUSH
16796: EMPTY
16797: LIST
16798: LIST
16799: PUSH
16800: LD_INT 34
16802: PUSH
16803: LD_INT 12
16805: PUSH
16806: EMPTY
16807: LIST
16808: LIST
16809: PUSH
16810: EMPTY
16811: LIST
16812: LIST
16813: PPUSH
16814: CALL_OW 69
16818: PUSH
16819: LD_INT 1
16821: ARRAY
16822: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16823: LD_VAR 0 5
16827: PUSH
16828: LD_INT 1
16830: ARRAY
16831: PPUSH
16832: CALL_OW 310
16836: IFFALSE 16851
// ComExitBuilding ( tmp [ 1 ] ) ;
16838: LD_VAR 0 5
16842: PUSH
16843: LD_INT 1
16845: ARRAY
16846: PPUSH
16847: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16851: LD_VAR 0 5
16855: PUSH
16856: LD_INT 1
16858: ARRAY
16859: PPUSH
16860: LD_VAR 0 4
16864: PPUSH
16865: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16869: LD_VAR 0 5
16873: PUSH
16874: LD_INT 1
16876: ARRAY
16877: PPUSH
16878: LD_INT 80
16880: PPUSH
16881: LD_INT 136
16883: PPUSH
16884: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16888: LD_VAR 0 5
16892: PUSH
16893: LD_INT 1
16895: ARRAY
16896: PPUSH
16897: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16901: LD_VAR 0 5
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: PPUSH
16910: LD_INT 59
16912: PPUSH
16913: LD_INT 112
16915: PPUSH
16916: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16920: LD_VAR 0 5
16924: PUSH
16925: LD_INT 1
16927: ARRAY
16928: PPUSH
16929: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16933: LD_EXP 39
16937: PUSH
16938: LD_EXP 56
16942: IN
16943: PUSH
16944: LD_EXP 39
16948: PPUSH
16949: CALL_OW 255
16953: PUSH
16954: LD_INT 1
16956: EQUAL
16957: AND
16958: IFFALSE 16974
// Say ( Lisa , D3nW-Lisa-1 ) else
16960: LD_EXP 39
16964: PPUSH
16965: LD_STRING D3nW-Lisa-1
16967: PPUSH
16968: CALL_OW 88
16972: GO 17218
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
16974: LD_EXP 42
16978: PUSH
16979: LD_EXP 56
16983: IN
16984: PUSH
16985: LD_EXP 42
16989: PPUSH
16990: CALL_OW 255
16994: PUSH
16995: LD_INT 1
16997: EQUAL
16998: AND
16999: IFFALSE 17015
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17001: LD_EXP 42
17005: PPUSH
17006: LD_STRING D3nW-Cyrus-1
17008: PPUSH
17009: CALL_OW 88
17013: GO 17218
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17015: LD_EXP 41
17019: PUSH
17020: LD_EXP 56
17024: IN
17025: PUSH
17026: LD_EXP 41
17030: PPUSH
17031: CALL_OW 255
17035: PUSH
17036: LD_INT 1
17038: EQUAL
17039: AND
17040: IFFALSE 17056
// Say ( Bobby , D3nW-Bobby-1 ) else
17042: LD_EXP 41
17046: PPUSH
17047: LD_STRING D3nW-Bobby-1
17049: PPUSH
17050: CALL_OW 88
17054: GO 17218
// if Gary in vip and GetSide ( Gary ) = 1 then
17056: LD_EXP 48
17060: PUSH
17061: LD_EXP 56
17065: IN
17066: PUSH
17067: LD_EXP 48
17071: PPUSH
17072: CALL_OW 255
17076: PUSH
17077: LD_INT 1
17079: EQUAL
17080: AND
17081: IFFALSE 17097
// Say ( Gary , D3nW-Gary-1 ) else
17083: LD_EXP 48
17087: PPUSH
17088: LD_STRING D3nW-Gary-1
17090: PPUSH
17091: CALL_OW 88
17095: GO 17218
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17097: LD_EXP 40
17101: PUSH
17102: LD_EXP 56
17106: IN
17107: PUSH
17108: LD_EXP 40
17112: PPUSH
17113: CALL_OW 255
17117: PUSH
17118: LD_INT 1
17120: EQUAL
17121: AND
17122: IFFALSE 17138
// Say ( Donaldson , D3nW-Don-1 ) else
17124: LD_EXP 40
17128: PPUSH
17129: LD_STRING D3nW-Don-1
17131: PPUSH
17132: CALL_OW 88
17136: GO 17218
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17138: LD_EXP 47
17142: PUSH
17143: LD_EXP 56
17147: IN
17148: PUSH
17149: LD_EXP 47
17153: PPUSH
17154: CALL_OW 255
17158: PUSH
17159: LD_INT 1
17161: EQUAL
17162: AND
17163: IFFALSE 17179
// Say ( Cornel , D3nW-Corn-1 ) else
17165: LD_EXP 47
17169: PPUSH
17170: LD_STRING D3nW-Corn-1
17172: PPUSH
17173: CALL_OW 88
17177: GO 17218
// if Frank in vip and GetSide ( Frank ) = 1 then
17179: LD_EXP 49
17183: PUSH
17184: LD_EXP 56
17188: IN
17189: PUSH
17190: LD_EXP 49
17194: PPUSH
17195: CALL_OW 255
17199: PUSH
17200: LD_INT 1
17202: EQUAL
17203: AND
17204: IFFALSE 17218
// Say ( Frank , D3nW-Frank-1 ) ;
17206: LD_EXP 49
17210: PPUSH
17211: LD_STRING D3nW-Frank-1
17213: PPUSH
17214: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17218: LD_EXP 36
17222: PPUSH
17223: LD_STRING D3nW-JMM-1
17225: PPUSH
17226: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17230: LD_EXP 36
17234: PPUSH
17235: LD_STRING D3nW-JMM-1a
17237: PPUSH
17238: CALL_OW 88
// t := 0 0$00 ;
17242: LD_ADDR_VAR 0 3
17246: PUSH
17247: LD_INT 0
17249: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17250: LD_INT 35
17252: PPUSH
17253: CALL_OW 67
// t := t + 0 0$1 ;
17257: LD_ADDR_VAR 0 3
17261: PUSH
17262: LD_VAR 0 3
17266: PUSH
17267: LD_INT 35
17269: PLUS
17270: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17271: LD_INT 59
17273: PPUSH
17274: LD_INT 112
17276: PPUSH
17277: CALL_OW 428
17281: PUSH
17282: LD_VAR 0 3
17286: PUSH
17287: LD_INT 2100
17289: GREATER
17290: OR
17291: IFFALSE 17250
// activeAttacks := true ;
17293: LD_ADDR_EXP 16
17297: PUSH
17298: LD_INT 1
17300: ST_TO_ADDR
// end ;
17301: LD_VAR 0 1
17305: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17306: LD_INT 0
17308: PPUSH
// case question of 1 :
17309: LD_VAR 0 1
17313: PUSH
17314: LD_INT 1
17316: DOUBLE
17317: EQUAL
17318: IFTRUE 17322
17320: GO 17373
17322: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17323: LD_EXP 36
17327: PPUSH
17328: LD_STRING D2Mot-JMM-1
17330: PPUSH
17331: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17335: LD_EXP 55
17339: PPUSH
17340: LD_STRING D2Mot-Pow-1
17342: PPUSH
17343: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17347: LD_EXP 36
17351: PPUSH
17352: LD_STRING D2Mot-JMM-2
17354: PPUSH
17355: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17359: LD_EXP 55
17363: PPUSH
17364: LD_STRING D2Mot-Pow-2
17366: PPUSH
17367: CALL_OW 88
// end ; 2 :
17371: GO 17716
17373: LD_INT 2
17375: DOUBLE
17376: EQUAL
17377: IFTRUE 17381
17379: GO 17457
17381: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17382: LD_EXP 36
17386: PPUSH
17387: LD_STRING D2Rus-JMM-1
17389: PPUSH
17390: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17394: LD_EXP 55
17398: PPUSH
17399: LD_STRING D2Rus-Pow-1
17401: PPUSH
17402: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17406: LD_EXP 36
17410: PPUSH
17411: LD_STRING D2Rus-JMM-2
17413: PPUSH
17414: CALL_OW 88
// if not ( 3 in list_of_q ) then
17418: LD_INT 3
17420: PUSH
17421: LD_VAR 0 2
17425: IN
17426: NOT
17427: IFFALSE 17443
// Say ( Powell , D2Rus-Pow-2 ) else
17429: LD_EXP 55
17433: PPUSH
17434: LD_STRING D2Rus-Pow-2
17436: PPUSH
17437: CALL_OW 88
17441: GO 17455
// Say ( Powell , D2Rus-Pow-2a ) ;
17443: LD_EXP 55
17447: PPUSH
17448: LD_STRING D2Rus-Pow-2a
17450: PPUSH
17451: CALL_OW 88
// end ; 3 :
17455: GO 17716
17457: LD_INT 3
17459: DOUBLE
17460: EQUAL
17461: IFTRUE 17465
17463: GO 17550
17465: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17466: LD_EXP 36
17470: PPUSH
17471: LD_STRING D2Leg-JMM-1
17473: PPUSH
17474: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17478: LD_EXP 55
17482: PPUSH
17483: LD_STRING D2Leg-Pow-1
17485: PPUSH
17486: CALL_OW 88
// if 2 in list_of_q then
17490: LD_INT 2
17492: PUSH
17493: LD_VAR 0 2
17497: IN
17498: IFFALSE 17524
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17500: LD_EXP 36
17504: PPUSH
17505: LD_STRING D2Leg-JMM-2
17507: PPUSH
17508: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17512: LD_EXP 55
17516: PPUSH
17517: LD_STRING D2Leg-Pow-2
17519: PPUSH
17520: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17524: LD_EXP 36
17528: PPUSH
17529: LD_STRING D2Leg-JMM-3
17531: PPUSH
17532: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17536: LD_EXP 55
17540: PPUSH
17541: LD_STRING D2Leg-Pow-3
17543: PPUSH
17544: CALL_OW 88
// end ; 4 :
17548: GO 17716
17550: LD_INT 4
17552: DOUBLE
17553: EQUAL
17554: IFTRUE 17558
17556: GO 17633
17558: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17559: LD_EXP 36
17563: PPUSH
17564: LD_STRING D2Ar-JMM-1
17566: PPUSH
17567: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17571: LD_EXP 55
17575: PPUSH
17576: LD_STRING D2Ar-Pow-1
17578: PPUSH
17579: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17583: LD_EXP 36
17587: PPUSH
17588: LD_STRING D2Ar-JMM-2
17590: PPUSH
17591: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17595: LD_EXP 55
17599: PPUSH
17600: LD_STRING D2Ar-Pow-2
17602: PPUSH
17603: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17607: LD_EXP 36
17611: PPUSH
17612: LD_STRING D2Ar-JMM-3
17614: PPUSH
17615: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17619: LD_EXP 55
17623: PPUSH
17624: LD_STRING D2Ar-Pow-3
17626: PPUSH
17627: CALL_OW 88
// end ; 5 :
17631: GO 17716
17633: LD_INT 5
17635: DOUBLE
17636: EQUAL
17637: IFTRUE 17641
17639: GO 17656
17641: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17642: LD_EXP 36
17646: PPUSH
17647: LD_STRING D2Conf-JMM-1
17649: PPUSH
17650: CALL_OW 88
17654: GO 17716
17656: LD_INT 6
17658: DOUBLE
17659: EQUAL
17660: IFTRUE 17664
17662: GO 17715
17664: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17665: LD_EXP 36
17669: PPUSH
17670: LD_STRING D2Com-JMM-1
17672: PPUSH
17673: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17677: LD_EXP 55
17681: PPUSH
17682: LD_STRING D2Com-Pow-1
17684: PPUSH
17685: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17689: LD_EXP 36
17693: PPUSH
17694: LD_STRING D2Com-JMM-2
17696: PPUSH
17697: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17701: LD_EXP 55
17705: PPUSH
17706: LD_STRING D2Com-Pow-2
17708: PPUSH
17709: CALL_OW 88
// end ; end ;
17713: GO 17716
17715: POP
// end ;
17716: LD_VAR 0 3
17720: RET
// every 0 0$5 trigger missionStart do var tmp ;
17721: LD_EXP 13
17725: IFFALSE 18008
17727: GO 17729
17729: DISABLE
17730: LD_INT 0
17732: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17733: LD_INT 35
17735: PPUSH
17736: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17740: LD_INT 14
17742: PPUSH
17743: LD_INT 22
17745: PUSH
17746: LD_INT 1
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: PPUSH
17753: CALL_OW 70
17757: PUSH
17758: LD_EXP 15
17762: PUSH
17763: LD_INT 2
17765: PUSH
17766: LD_INT 3
17768: PUSH
17769: LD_INT 4
17771: PUSH
17772: LD_INT 5
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: IN
17781: AND
17782: IFFALSE 17998
// begin powellAnger := powellAnger + 1 ;
17784: LD_ADDR_EXP 17
17788: PUSH
17789: LD_EXP 17
17793: PUSH
17794: LD_INT 1
17796: PLUS
17797: ST_TO_ADDR
// Video ( true ) ;
17798: LD_INT 1
17800: PPUSH
17801: CALL 103953 0 1
// CenterNowOnUnits ( tmp ) ;
17805: LD_VAR 0 1
17809: PPUSH
17810: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17814: LD_INT 14
17816: PPUSH
17817: LD_INT 22
17819: PUSH
17820: LD_INT 1
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 70
17831: PPUSH
17832: LD_INT 86
17834: PPUSH
17835: LD_INT 133
17837: PPUSH
17838: CALL_OW 111
// async ;
17842: ASYNC
// case powellAnger of 1 :
17843: LD_EXP 17
17847: PUSH
17848: LD_INT 1
17850: DOUBLE
17851: EQUAL
17852: IFTRUE 17856
17854: GO 17871
17856: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17857: LD_EXP 55
17861: PPUSH
17862: LD_STRING DBack1-Pow-1
17864: PPUSH
17865: CALL_OW 88
17869: GO 17918
17871: LD_INT 2
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17894
17879: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17880: LD_EXP 55
17884: PPUSH
17885: LD_STRING DBack2-Pow-1
17887: PPUSH
17888: CALL_OW 88
17892: GO 17918
17894: LD_INT 3
17896: DOUBLE
17897: EQUAL
17898: IFTRUE 17902
17900: GO 17917
17902: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17903: LD_EXP 55
17907: PPUSH
17908: LD_STRING DBack3-Pow-1
17910: PPUSH
17911: CALL_OW 88
17915: GO 17918
17917: POP
// sync ;
17918: SYNC
// repeat wait ( 0 0$1 ) ;
17919: LD_INT 35
17921: PPUSH
17922: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17926: LD_INT 14
17928: PPUSH
17929: LD_INT 22
17931: PUSH
17932: LD_INT 1
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: PPUSH
17939: CALL_OW 70
17943: PPUSH
17944: LD_INT 86
17946: PPUSH
17947: LD_INT 133
17949: PPUSH
17950: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17954: LD_INT 14
17956: PPUSH
17957: LD_INT 22
17959: PUSH
17960: LD_INT 1
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: PPUSH
17967: CALL_OW 70
17971: NOT
17972: IFFALSE 17919
// if powellAnger >= 3 then
17974: LD_EXP 17
17978: PUSH
17979: LD_INT 3
17981: GREATEREQUAL
17982: IFFALSE 17991
// YouLost ( Dismissed ) ;
17984: LD_STRING Dismissed
17986: PPUSH
17987: CALL_OW 104
// Video ( false ) ;
17991: LD_INT 0
17993: PPUSH
17994: CALL 103953 0 1
// end ; until missionStage > 5 ;
17998: LD_EXP 15
18002: PUSH
18003: LD_INT 5
18005: GREATER
18006: IFFALSE 17733
// end ;
18008: PPOPN 1
18010: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , ru , un ;
18011: LD_EXP 13
18015: PUSH
18016: LD_INT 22
18018: PUSH
18019: LD_INT 4
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: PUSH
18026: LD_INT 21
18028: PUSH
18029: LD_INT 2
18031: PUSH
18032: EMPTY
18033: LIST
18034: LIST
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: PPUSH
18040: CALL_OW 69
18044: PUSH
18045: LD_INT 4
18047: GREATEREQUAL
18048: AND
18049: PUSH
18050: LD_EXP 15
18054: PUSH
18055: LD_INT 2
18057: EQUAL
18058: AND
18059: IFFALSE 19680
18061: GO 18063
18063: DISABLE
18064: LD_INT 0
18066: PPUSH
18067: PPUSH
18068: PPUSH
18069: PPUSH
18070: PPUSH
18071: PPUSH
18072: PPUSH
// begin missionStage := 3 ;
18073: LD_ADDR_EXP 15
18077: PUSH
18078: LD_INT 3
18080: ST_TO_ADDR
// retreat := false ;
18081: LD_ADDR_VAR 0 4
18085: PUSH
18086: LD_INT 0
18088: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
18089: LD_ADDR_VAR 0 5
18093: PUSH
18094: LD_INT 22
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PUSH
18104: LD_INT 30
18106: PUSH
18107: LD_INT 4
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: PUSH
18114: EMPTY
18115: LIST
18116: LIST
18117: PPUSH
18118: CALL_OW 69
18122: PUSH
18123: LD_INT 1
18125: ARRAY
18126: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18127: LD_INT 35
18129: PPUSH
18130: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18134: LD_EXP 118
18138: PUSH
18139: LD_INT 4
18141: ARRAY
18142: PUSH
18143: LD_INT 4
18145: GREATEREQUAL
18146: IFFALSE 18127
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18148: LD_ADDR_VAR 0 2
18152: PUSH
18153: LD_INT 22
18155: PUSH
18156: LD_INT 4
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: PUSH
18163: LD_INT 2
18165: PUSH
18166: LD_INT 25
18168: PUSH
18169: LD_INT 1
18171: PUSH
18172: EMPTY
18173: LIST
18174: LIST
18175: PUSH
18176: LD_INT 25
18178: PUSH
18179: LD_INT 2
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: PUSH
18186: LD_INT 25
18188: PUSH
18189: LD_INT 3
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PUSH
18196: LD_INT 25
18198: PUSH
18199: LD_INT 4
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: PUSH
18206: LD_INT 25
18208: PUSH
18209: LD_INT 5
18211: PUSH
18212: EMPTY
18213: LIST
18214: LIST
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: PPUSH
18228: CALL_OW 69
18232: PUSH
18233: LD_EXP 55
18237: PUSH
18238: LD_EXP 56
18242: ADD
18243: DIFF
18244: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18245: LD_ADDR_VAR 0 3
18249: PUSH
18250: LD_VAR 0 2
18254: PPUSH
18255: LD_INT 26
18257: PUSH
18258: LD_INT 1
18260: PUSH
18261: EMPTY
18262: LIST
18263: LIST
18264: PPUSH
18265: CALL_OW 72
18269: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18270: LD_ADDR_VAR 0 2
18274: PUSH
18275: LD_VAR 0 2
18279: PUSH
18280: LD_VAR 0 3
18284: DIFF
18285: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18286: LD_ADDR_VAR 0 2
18290: PUSH
18291: LD_VAR 0 2
18295: PPUSH
18296: LD_INT 1
18298: PPUSH
18299: CALL 102605 0 2
18303: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18304: LD_ADDR_VAR 0 3
18308: PUSH
18309: LD_VAR 0 3
18313: PPUSH
18314: LD_INT 1
18316: PPUSH
18317: CALL 102605 0 2
18321: ST_TO_ADDR
// for i = 1 to 4 do
18322: LD_ADDR_VAR 0 1
18326: PUSH
18327: DOUBLE
18328: LD_INT 1
18330: DEC
18331: ST_TO_ADDR
18332: LD_INT 4
18334: PUSH
18335: FOR_TO
18336: IFFALSE 18502
// begin if tmp2 then
18338: LD_VAR 0 3
18342: IFFALSE 18423
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18344: LD_ADDR_EXP 18
18348: PUSH
18349: LD_EXP 18
18353: PPUSH
18354: LD_INT 1
18356: PPUSH
18357: LD_EXP 18
18361: PUSH
18362: LD_INT 1
18364: ARRAY
18365: PUSH
18366: LD_VAR 0 3
18370: PUSH
18371: LD_VAR 0 3
18375: ARRAY
18376: ADD
18377: PPUSH
18378: CALL_OW 1
18382: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18383: LD_VAR 0 3
18387: PUSH
18388: LD_VAR 0 3
18392: ARRAY
18393: PPUSH
18394: LD_INT 1
18396: PPUSH
18397: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18401: LD_ADDR_VAR 0 3
18405: PUSH
18406: LD_VAR 0 3
18410: PPUSH
18411: LD_VAR 0 3
18415: PPUSH
18416: CALL_OW 3
18420: ST_TO_ADDR
// end else
18421: GO 18500
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18423: LD_ADDR_EXP 18
18427: PUSH
18428: LD_EXP 18
18432: PPUSH
18433: LD_INT 1
18435: PPUSH
18436: LD_EXP 18
18440: PUSH
18441: LD_INT 1
18443: ARRAY
18444: PUSH
18445: LD_VAR 0 2
18449: PUSH
18450: LD_VAR 0 2
18454: ARRAY
18455: ADD
18456: PPUSH
18457: CALL_OW 1
18461: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18462: LD_VAR 0 2
18466: PUSH
18467: LD_VAR 0 2
18471: ARRAY
18472: PPUSH
18473: LD_INT 1
18475: PPUSH
18476: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18480: LD_ADDR_VAR 0 2
18484: PUSH
18485: LD_VAR 0 2
18489: PPUSH
18490: LD_VAR 0 2
18494: PPUSH
18495: CALL_OW 3
18499: ST_TO_ADDR
// end ; end ;
18500: GO 18335
18502: POP
18503: POP
// if tmp2 then
18504: LD_VAR 0 3
18508: IFFALSE 18526
// tmp := tmp union tmp2 ;
18510: LD_ADDR_VAR 0 2
18514: PUSH
18515: LD_VAR 0 2
18519: PUSH
18520: LD_VAR 0 3
18524: UNION
18525: ST_TO_ADDR
// for i = 1 to 4 do
18526: LD_ADDR_VAR 0 1
18530: PUSH
18531: DOUBLE
18532: LD_INT 1
18534: DEC
18535: ST_TO_ADDR
18536: LD_INT 4
18538: PUSH
18539: FOR_TO
18540: IFFALSE 18589
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18542: LD_ADDR_EXP 18
18546: PUSH
18547: LD_EXP 18
18551: PPUSH
18552: LD_INT 2
18554: PPUSH
18555: LD_EXP 18
18559: PUSH
18560: LD_INT 2
18562: ARRAY
18563: PUSH
18564: LD_VAR 0 2
18568: PUSH
18569: LD_VAR 0 2
18573: PUSH
18574: LD_VAR 0 1
18578: MINUS
18579: ARRAY
18580: ADD
18581: PPUSH
18582: CALL_OW 1
18586: ST_TO_ADDR
18587: GO 18539
18589: POP
18590: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18591: LD_ADDR_EXP 99
18595: PUSH
18596: LD_EXP 99
18600: PPUSH
18601: LD_INT 4
18603: PPUSH
18604: LD_EXP 99
18608: PUSH
18609: LD_INT 4
18611: ARRAY
18612: PUSH
18613: LD_EXP 18
18617: PUSH
18618: LD_INT 1
18620: ARRAY
18621: DIFF
18622: PPUSH
18623: CALL_OW 1
18627: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
18628: LD_ADDR_VAR 0 1
18632: PUSH
18633: LD_EXP 18
18637: PUSH
18638: LD_INT 1
18640: ARRAY
18641: PUSH
18642: FOR_IN
18643: IFFALSE 18746
// begin if IsInUnit ( i ) then
18645: LD_VAR 0 1
18649: PPUSH
18650: CALL_OW 310
18654: IFFALSE 18665
// ComExitBuilding ( i ) ;
18656: LD_VAR 0 1
18660: PPUSH
18661: CALL_OW 122
// if GetClass ( i ) <> 1 then
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 257
18674: PUSH
18675: LD_INT 1
18677: NONEQUAL
18678: IFFALSE 18715
// begin AddComEnterUnit ( i , arm ) ;
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_VAR 0 5
18689: PPUSH
18690: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18694: LD_VAR 0 1
18698: PPUSH
18699: LD_INT 1
18701: PPUSH
18702: CALL_OW 183
// AddComExitBuilding ( i ) ;
18706: LD_VAR 0 1
18710: PPUSH
18711: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18715: LD_VAR 0 1
18719: PPUSH
18720: LD_INT 60
18722: PPUSH
18723: LD_INT 94
18725: PPUSH
18726: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18730: LD_VAR 0 1
18734: PPUSH
18735: LD_EXP 55
18739: PPUSH
18740: CALL_OW 179
// end ;
18744: GO 18642
18746: POP
18747: POP
// wait ( 0 0$15 ) ;
18748: LD_INT 525
18750: PPUSH
18751: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
18755: LD_EXP 55
18759: PPUSH
18760: LD_STRING D4-Pow-1
18762: PPUSH
18763: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
18767: LD_ADDR_VAR 0 2
18771: PUSH
18772: LD_EXP 18
18776: PUSH
18777: LD_INT 1
18779: ARRAY
18780: PPUSH
18781: LD_INT 26
18783: PUSH
18784: LD_INT 1
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PPUSH
18791: CALL_OW 72
18795: ST_TO_ADDR
// if tmp then
18796: LD_VAR 0 2
18800: IFFALSE 18818
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
18802: LD_VAR 0 2
18806: PUSH
18807: LD_INT 1
18809: ARRAY
18810: PPUSH
18811: LD_STRING D4-Sol1-1
18813: PPUSH
18814: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
18818: LD_EXP 55
18822: PPUSH
18823: LD_STRING D4-Pow-2
18825: PPUSH
18826: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
18830: LD_ADDR_VAR 0 1
18834: PUSH
18835: DOUBLE
18836: LD_INT 1
18838: DEC
18839: ST_TO_ADDR
18840: LD_EXP 18
18844: PUSH
18845: LD_INT 1
18847: ARRAY
18848: PUSH
18849: FOR_TO
18850: IFFALSE 18943
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
18852: LD_EXP 18
18856: PUSH
18857: LD_INT 1
18859: ARRAY
18860: PUSH
18861: LD_VAR 0 1
18865: ARRAY
18866: PPUSH
18867: LD_EXP 118
18871: PUSH
18872: LD_INT 4
18874: ARRAY
18875: PUSH
18876: LD_INT 1
18878: ARRAY
18879: PPUSH
18880: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
18884: LD_ADDR_EXP 118
18888: PUSH
18889: LD_EXP 118
18893: PPUSH
18894: LD_INT 4
18896: PPUSH
18897: LD_EXP 118
18901: PUSH
18902: LD_INT 4
18904: ARRAY
18905: PPUSH
18906: LD_INT 1
18908: PPUSH
18909: CALL_OW 3
18913: PPUSH
18914: CALL_OW 1
18918: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
18919: LD_INT 8
18921: PPUSH
18922: LD_EXP 18
18926: PUSH
18927: LD_INT 1
18929: ARRAY
18930: PUSH
18931: LD_VAR 0 1
18935: ARRAY
18936: PPUSH
18937: CALL_OW 471
// end ;
18941: GO 18849
18943: POP
18944: POP
// repeat wait ( 0 0$1 ) ;
18945: LD_INT 35
18947: PPUSH
18948: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
18952: LD_EXP 18
18956: PUSH
18957: LD_INT 1
18959: ARRAY
18960: PPUSH
18961: LD_INT 55
18963: PUSH
18964: EMPTY
18965: LIST
18966: PPUSH
18967: CALL_OW 72
18971: PUSH
18972: LD_INT 4
18974: GREATEREQUAL
18975: IFFALSE 18945
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
18977: LD_EXP 18
18981: PUSH
18982: LD_INT 1
18984: ARRAY
18985: PPUSH
18986: LD_INT 69
18988: PPUSH
18989: LD_INT 94
18991: PPUSH
18992: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
18996: LD_EXP 18
19000: PUSH
19001: LD_INT 1
19003: ARRAY
19004: PPUSH
19005: LD_INT 82
19007: PPUSH
19008: LD_INT 83
19010: PPUSH
19011: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19015: LD_EXP 18
19019: PUSH
19020: LD_INT 1
19022: ARRAY
19023: PPUSH
19024: LD_INT 77
19026: PPUSH
19027: LD_INT 69
19029: PPUSH
19030: CALL_OW 174
// repeat wait ( 3 ) ;
19034: LD_INT 3
19036: PPUSH
19037: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19041: LD_ADDR_VAR 0 1
19045: PUSH
19046: LD_EXP 18
19050: PUSH
19051: LD_INT 1
19053: ARRAY
19054: PUSH
19055: FOR_IN
19056: IFFALSE 19192
// begin if GetLives ( i ) < 990 then
19058: LD_VAR 0 1
19062: PPUSH
19063: CALL_OW 256
19067: PUSH
19068: LD_INT 990
19070: LESS
19071: IFFALSE 19085
// SetLives ( i , 1000 ) ;
19073: LD_VAR 0 1
19077: PPUSH
19078: LD_INT 1000
19080: PPUSH
19081: CALL_OW 234
// if not IsInUnit ( i ) then
19085: LD_VAR 0 1
19089: PPUSH
19090: CALL_OW 310
19094: NOT
19095: IFFALSE 19190
// begin if not HasTask ( i ) then
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 314
19106: NOT
19107: IFFALSE 19124
// ComMoveXY ( i , 64 , 93 ) ;
19109: LD_VAR 0 1
19113: PPUSH
19114: LD_INT 64
19116: PPUSH
19117: LD_INT 93
19119: PPUSH
19120: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19124: LD_VAR 0 4
19128: NOT
19129: PUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: CALL_OW 258
19139: PUSH
19140: LD_INT 1
19142: EQUAL
19143: AND
19144: IFFALSE 19190
// begin retreat := true ;
19146: LD_ADDR_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19154: LD_VAR 0 1
19158: PPUSH
19159: LD_INT 2
19161: PPUSH
19162: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19166: LD_VAR 0 1
19170: PPUSH
19171: LD_STRING D4a-Sol1-1
19173: PPUSH
19174: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19178: LD_EXP 55
19182: PPUSH
19183: LD_STRING D4a-Pow-1
19185: PPUSH
19186: CALL_OW 88
// end ; end ; end ;
19190: GO 19055
19192: POP
19193: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19194: LD_EXP 18
19198: PUSH
19199: LD_INT 1
19201: ARRAY
19202: PPUSH
19203: LD_INT 95
19205: PUSH
19206: LD_INT 9
19208: PUSH
19209: EMPTY
19210: LIST
19211: LIST
19212: PUSH
19213: LD_INT 3
19215: PUSH
19216: LD_INT 55
19218: PUSH
19219: EMPTY
19220: LIST
19221: PUSH
19222: EMPTY
19223: LIST
19224: LIST
19225: PUSH
19226: EMPTY
19227: LIST
19228: LIST
19229: PPUSH
19230: CALL_OW 72
19234: PUSH
19235: LD_INT 4
19237: GREATEREQUAL
19238: IFFALSE 19034
// for i in powellSquadAttack [ 1 ] do
19240: LD_ADDR_VAR 0 1
19244: PUSH
19245: LD_EXP 18
19249: PUSH
19250: LD_INT 1
19252: ARRAY
19253: PUSH
19254: FOR_IN
19255: IFFALSE 19391
// begin if GetTag ( i ) = 2 then
19257: LD_VAR 0 1
19261: PPUSH
19262: CALL_OW 110
19266: PUSH
19267: LD_INT 2
19269: EQUAL
19270: IFFALSE 19332
// begin ComMoveXY ( i , 60 , 94 ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_INT 60
19279: PPUSH
19280: LD_INT 94
19282: PPUSH
19283: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19287: LD_VAR 0 1
19291: PPUSH
19292: LD_EXP 55
19296: PPUSH
19297: CALL_OW 179
// wait ( 0 0$3 ) ;
19301: LD_INT 105
19303: PPUSH
19304: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19308: LD_VAR 0 1
19312: PPUSH
19313: LD_STRING D4a-Sol1-2
19315: PPUSH
19316: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19320: LD_EXP 55
19324: PPUSH
19325: LD_STRING D4a-Pow-2
19327: PPUSH
19328: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19332: LD_VAR 0 1
19336: PPUSH
19337: LD_INT 0
19339: PPUSH
19340: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19344: LD_ADDR_EXP 99
19348: PUSH
19349: LD_EXP 99
19353: PPUSH
19354: LD_INT 4
19356: PPUSH
19357: LD_EXP 99
19361: PUSH
19362: LD_INT 4
19364: ARRAY
19365: PUSH
19366: LD_VAR 0 1
19370: UNION
19371: PPUSH
19372: CALL_OW 1
19376: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19377: LD_INT 8
19379: PPUSH
19380: LD_VAR 0 1
19384: PPUSH
19385: CALL_OW 472
// end ;
19389: GO 19254
19391: POP
19392: POP
// wait ( 4 4$00 ) ;
19393: LD_INT 8400
19395: PPUSH
19396: CALL_OW 67
// uc_side := 6 ;
19400: LD_ADDR_OWVAR 20
19404: PUSH
19405: LD_INT 6
19407: ST_TO_ADDR
// uc_nation := 3 ;
19408: LD_ADDR_OWVAR 21
19412: PUSH
19413: LD_INT 3
19415: ST_TO_ADDR
// ru := [ ] ;
19416: LD_ADDR_VAR 0 6
19420: PUSH
19421: EMPTY
19422: ST_TO_ADDR
// for i = 1 to 4 do
19423: LD_ADDR_VAR 0 1
19427: PUSH
19428: DOUBLE
19429: LD_INT 1
19431: DEC
19432: ST_TO_ADDR
19433: LD_INT 4
19435: PUSH
19436: FOR_TO
19437: IFFALSE 19538
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19439: LD_INT 22
19441: PPUSH
19442: LD_INT 1
19444: PPUSH
19445: LD_INT 3
19447: PPUSH
19448: LD_INT 43
19450: PUSH
19451: LD_INT 44
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 1
19460: PPUSH
19461: LD_INT 2
19463: PPUSH
19464: CALL_OW 12
19468: ARRAY
19469: PPUSH
19470: LD_INT 89
19472: PPUSH
19473: CALL 68298 0 5
// un := CreateVehicle ;
19477: LD_ADDR_VAR 0 7
19481: PUSH
19482: CALL_OW 45
19486: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19487: LD_VAR 0 7
19491: PPUSH
19492: LD_INT 4
19494: PPUSH
19495: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19499: LD_VAR 0 7
19503: PPUSH
19504: LD_INT 136
19506: PPUSH
19507: LD_INT 90
19509: PPUSH
19510: LD_INT 8
19512: PPUSH
19513: LD_INT 0
19515: PPUSH
19516: CALL_OW 50
// ru := ru ^ un ;
19520: LD_ADDR_VAR 0 6
19524: PUSH
19525: LD_VAR 0 6
19529: PUSH
19530: LD_VAR 0 7
19534: ADD
19535: ST_TO_ADDR
// end ;
19536: GO 19436
19538: POP
19539: POP
// if ru then
19540: LD_VAR 0 6
19544: IFFALSE 19561
// ComAgressiveMove ( ru , 80 , 92 ) ;
19546: LD_VAR 0 6
19550: PPUSH
19551: LD_INT 80
19553: PPUSH
19554: LD_INT 92
19556: PPUSH
19557: CALL_OW 114
// wait ( 8 8$00 ) ;
19561: LD_INT 16800
19563: PPUSH
19564: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19568: LD_INT 4
19570: PPUSH
19571: LD_INT 3
19573: PUSH
19574: LD_INT 1
19576: PUSH
19577: LD_INT 1
19579: PUSH
19580: LD_INT 5
19582: PUSH
19583: EMPTY
19584: LIST
19585: LIST
19586: LIST
19587: LIST
19588: PUSH
19589: LD_INT 4
19591: PUSH
19592: LD_INT 1
19594: PUSH
19595: LD_INT 1
19597: PUSH
19598: LD_INT 6
19600: PUSH
19601: EMPTY
19602: LIST
19603: LIST
19604: LIST
19605: LIST
19606: PUSH
19607: LD_INT 4
19609: PUSH
19610: LD_INT 1
19612: PUSH
19613: LD_INT 1
19615: PUSH
19616: LD_INT 7
19618: PUSH
19619: EMPTY
19620: LIST
19621: LIST
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 3
19627: PUSH
19628: LD_INT 1
19630: PUSH
19631: LD_INT 1
19633: PUSH
19634: LD_INT 7
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: PUSH
19643: LD_INT 3
19645: PUSH
19646: LD_INT 1
19648: PUSH
19649: LD_INT 1
19651: PUSH
19652: LD_INT 5
19654: PUSH
19655: EMPTY
19656: LIST
19657: LIST
19658: LIST
19659: LIST
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: LIST
19667: PPUSH
19668: CALL 55685 0 2
// missionStage := 4 ;
19672: LD_ADDR_EXP 15
19676: PUSH
19677: LD_INT 4
19679: ST_TO_ADDR
// end ;
19680: PPOPN 7
19682: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19683: LD_EXP 15
19687: PUSH
19688: LD_INT 4
19690: EQUAL
19691: PUSH
19692: LD_INT 22
19694: PUSH
19695: LD_INT 4
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: PUSH
19702: LD_INT 21
19704: PUSH
19705: LD_INT 2
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: PPUSH
19716: CALL_OW 69
19720: PUSH
19721: LD_INT 5
19723: GREATEREQUAL
19724: AND
19725: IFFALSE 23786
19727: GO 19729
19729: DISABLE
19730: LD_INT 0
19732: PPUSH
19733: PPUSH
19734: PPUSH
19735: PPUSH
19736: PPUSH
19737: PPUSH
19738: PPUSH
19739: PPUSH
19740: PPUSH
19741: PPUSH
19742: PPUSH
19743: PPUSH
19744: PPUSH
// begin missionStage := 5 ;
19745: LD_ADDR_EXP 15
19749: PUSH
19750: LD_INT 5
19752: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19753: LD_ADDR_VAR 0 10
19757: PUSH
19758: LD_INT 22
19760: PUSH
19761: LD_INT 4
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: PUSH
19768: LD_INT 2
19770: PUSH
19771: LD_INT 30
19773: PUSH
19774: LD_INT 4
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: PUSH
19781: LD_INT 30
19783: PUSH
19784: LD_INT 5
19786: PUSH
19787: EMPTY
19788: LIST
19789: LIST
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: LIST
19795: PUSH
19796: EMPTY
19797: LIST
19798: LIST
19799: PPUSH
19800: CALL_OW 69
19804: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
19805: LD_ADDR_VAR 0 6
19809: PUSH
19810: LD_INT 22
19812: PUSH
19813: LD_INT 4
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 21
19822: PUSH
19823: LD_INT 1
19825: PUSH
19826: EMPTY
19827: LIST
19828: LIST
19829: PUSH
19830: LD_INT 3
19832: PUSH
19833: LD_INT 25
19835: PUSH
19836: LD_INT 16
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: PUSH
19843: EMPTY
19844: LIST
19845: LIST
19846: PUSH
19847: LD_INT 3
19849: PUSH
19850: LD_INT 25
19852: PUSH
19853: LD_INT 12
19855: PUSH
19856: EMPTY
19857: LIST
19858: LIST
19859: PUSH
19860: EMPTY
19861: LIST
19862: LIST
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 69
19874: PUSH
19875: LD_EXP 55
19879: DIFF
19880: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
19881: LD_ADDR_VAR 0 9
19885: PUSH
19886: LD_INT 22
19888: PUSH
19889: LD_INT 4
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: PUSH
19896: LD_INT 30
19898: PUSH
19899: LD_INT 3
19901: PUSH
19902: EMPTY
19903: LIST
19904: LIST
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: PPUSH
19910: CALL_OW 69
19914: PUSH
19915: LD_INT 1
19917: ARRAY
19918: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19919: LD_INT 35
19921: PPUSH
19922: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
19926: LD_EXP 118
19930: PUSH
19931: LD_INT 4
19933: ARRAY
19934: PUSH
19935: LD_INT 5
19937: GREATEREQUAL
19938: IFFALSE 19919
// powellAllowRetreat := false ;
19940: LD_ADDR_EXP 19
19944: PUSH
19945: LD_INT 0
19947: ST_TO_ADDR
// wait ( 0 0$20 ) ;
19948: LD_INT 700
19950: PPUSH
19951: CALL_OW 67
// activeAttacks := false ;
19955: LD_ADDR_EXP 16
19959: PUSH
19960: LD_INT 0
19962: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19963: LD_INT 35
19965: PPUSH
19966: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
19970: LD_INT 22
19972: PUSH
19973: LD_INT 6
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: PPUSH
19980: CALL_OW 69
19984: PUSH
19985: LD_INT 0
19987: EQUAL
19988: IFFALSE 19963
// tmp := mc_vehicles [ 4 ] ;
19990: LD_ADDR_VAR 0 3
19994: PUSH
19995: LD_EXP 118
19999: PUSH
20000: LD_INT 4
20002: ARRAY
20003: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20004: LD_ADDR_VAR 0 1
20008: PUSH
20009: DOUBLE
20010: LD_INT 1
20012: DEC
20013: ST_TO_ADDR
20014: LD_EXP 18
20018: PUSH
20019: FOR_TO
20020: IFFALSE 20281
// begin for j in powellSquadAttack [ i ] do
20022: LD_ADDR_VAR 0 2
20026: PUSH
20027: LD_EXP 18
20031: PUSH
20032: LD_VAR 0 1
20036: ARRAY
20037: PUSH
20038: FOR_IN
20039: IFFALSE 20277
// begin forces := forces diff j ;
20041: LD_ADDR_VAR 0 6
20045: PUSH
20046: LD_VAR 0 6
20050: PUSH
20051: LD_VAR 0 2
20055: DIFF
20056: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20057: LD_VAR 0 2
20061: PPUSH
20062: LD_INT 1
20064: PPUSH
20065: CALL_OW 109
// wait ( 0 0$2 ) ;
20069: LD_INT 70
20071: PPUSH
20072: CALL_OW 67
// if IsInUnit ( j ) then
20076: LD_VAR 0 2
20080: PPUSH
20081: CALL_OW 310
20085: IFFALSE 20096
// ComExitBuilding ( j ) ;
20087: LD_VAR 0 2
20091: PPUSH
20092: CALL_OW 122
// if GetClass ( j ) <> 1 then
20096: LD_VAR 0 2
20100: PPUSH
20101: CALL_OW 257
20105: PUSH
20106: LD_INT 1
20108: NONEQUAL
20109: IFFALSE 20189
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20111: LD_VAR 0 10
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: CALL_OW 313
20124: PUSH
20125: LD_INT 5
20127: GREATEREQUAL
20128: IFFALSE 20150
// AddComEnterUnit ( j , arm [ 2 ] ) else
20130: LD_VAR 0 2
20134: PPUSH
20135: LD_VAR 0 10
20139: PUSH
20140: LD_INT 2
20142: ARRAY
20143: PPUSH
20144: CALL_OW 180
20148: GO 20168
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20150: LD_VAR 0 2
20154: PPUSH
20155: LD_VAR 0 10
20159: PUSH
20160: LD_INT 1
20162: ARRAY
20163: PPUSH
20164: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20168: LD_VAR 0 2
20172: PPUSH
20173: LD_INT 1
20175: PPUSH
20176: CALL_OW 183
// AddComExitBuilding ( j ) ;
20180: LD_VAR 0 2
20184: PPUSH
20185: CALL_OW 182
// end ; if i = 2 then
20189: LD_VAR 0 1
20193: PUSH
20194: LD_INT 2
20196: EQUAL
20197: IFFALSE 20214
// AddComMoveXY ( j , 61 , 93 ) ;
20199: LD_VAR 0 2
20203: PPUSH
20204: LD_INT 61
20206: PPUSH
20207: LD_INT 93
20209: PPUSH
20210: CALL_OW 171
// if i = 1 then
20214: LD_VAR 0 1
20218: PUSH
20219: LD_INT 1
20221: EQUAL
20222: IFFALSE 20275
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20224: LD_VAR 0 2
20228: PPUSH
20229: LD_VAR 0 3
20233: PUSH
20234: LD_INT 1
20236: ARRAY
20237: PPUSH
20238: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20242: LD_ADDR_VAR 0 3
20246: PUSH
20247: LD_VAR 0 3
20251: PPUSH
20252: LD_INT 1
20254: PPUSH
20255: CALL_OW 3
20259: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20260: LD_VAR 0 2
20264: PPUSH
20265: LD_INT 69
20267: PPUSH
20268: LD_INT 94
20270: PPUSH
20271: CALL_OW 171
// end ; end ;
20275: GO 20038
20277: POP
20278: POP
// end ;
20279: GO 20019
20281: POP
20282: POP
// wait ( 0 0$45 ) ;
20283: LD_INT 1575
20285: PPUSH
20286: CALL_OW 67
// MC_Kill ( 4 ) ;
20290: LD_INT 4
20292: PPUSH
20293: CALL 33654 0 1
// tmp := UnitsInside ( fac ) ;
20297: LD_ADDR_VAR 0 3
20301: PUSH
20302: LD_VAR 0 9
20306: PPUSH
20307: CALL_OW 313
20311: ST_TO_ADDR
// if tmp then
20312: LD_VAR 0 3
20316: IFFALSE 20437
// for i in tmp do
20318: LD_ADDR_VAR 0 1
20322: PUSH
20323: LD_VAR 0 3
20327: PUSH
20328: FOR_IN
20329: IFFALSE 20435
// begin ComExitBuilding ( i ) ;
20331: LD_VAR 0 1
20335: PPUSH
20336: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20340: LD_VAR 0 10
20344: PUSH
20345: LD_INT 2
20347: ARRAY
20348: PPUSH
20349: CALL_OW 313
20353: PUSH
20354: LD_INT 6
20356: LESS
20357: IFFALSE 20379
// AddComEnterUnit ( i , arm [ 2 ] ) else
20359: LD_VAR 0 1
20363: PPUSH
20364: LD_VAR 0 10
20368: PUSH
20369: LD_INT 2
20371: ARRAY
20372: PPUSH
20373: CALL_OW 180
20377: GO 20433
// if UnitsInside ( arm [ 1 ] ) < 6 then
20379: LD_VAR 0 10
20383: PUSH
20384: LD_INT 1
20386: ARRAY
20387: PPUSH
20388: CALL_OW 313
20392: PUSH
20393: LD_INT 6
20395: LESS
20396: IFFALSE 20418
// AddComEnterUnit ( i , arm [ 1 ] ) else
20398: LD_VAR 0 1
20402: PPUSH
20403: LD_VAR 0 10
20407: PUSH
20408: LD_INT 1
20410: ARRAY
20411: PPUSH
20412: CALL_OW 180
20416: GO 20433
// AddComMoveXY ( i , 37 , 68 ) ;
20418: LD_VAR 0 1
20422: PPUSH
20423: LD_INT 37
20425: PPUSH
20426: LD_INT 68
20428: PPUSH
20429: CALL_OW 171
// end ;
20433: GO 20328
20435: POP
20436: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20437: LD_ADDR_VAR 0 11
20441: PUSH
20442: LD_VAR 0 6
20446: PPUSH
20447: LD_INT 26
20449: PUSH
20450: LD_INT 1
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: PPUSH
20457: CALL_OW 72
20461: PUSH
20462: LD_EXP 56
20466: DIFF
20467: ST_TO_ADDR
// if not speaker then
20468: LD_VAR 0 11
20472: NOT
20473: IFFALSE 20500
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20475: LD_ADDR_VAR 0 11
20479: PUSH
20480: LD_VAR 0 6
20484: PPUSH
20485: LD_INT 26
20487: PUSH
20488: LD_INT 1
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PPUSH
20495: CALL_OW 72
20499: ST_TO_ADDR
// if speaker then
20500: LD_VAR 0 11
20504: IFFALSE 20520
// speaker := speaker [ 1 ] ;
20506: LD_ADDR_VAR 0 11
20510: PUSH
20511: LD_VAR 0 11
20515: PUSH
20516: LD_INT 1
20518: ARRAY
20519: ST_TO_ADDR
// Video ( true ) ;
20520: LD_INT 1
20522: PPUSH
20523: CALL 103953 0 1
// CenterNowOnUnits ( Powell ) ;
20527: LD_EXP 55
20531: PPUSH
20532: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20536: LD_ADDR_VAR 0 3
20540: PUSH
20541: LD_VAR 0 6
20545: PPUSH
20546: LD_INT 3
20548: PUSH
20549: LD_INT 25
20551: PUSH
20552: LD_INT 1
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PPUSH
20563: CALL_OW 72
20567: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20568: LD_ADDR_VAR 0 12
20572: PUSH
20573: LD_INT 22
20575: PUSH
20576: LD_INT 4
20578: PUSH
20579: EMPTY
20580: LIST
20581: LIST
20582: PUSH
20583: LD_INT 30
20585: PUSH
20586: LD_INT 32
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: PUSH
20593: LD_INT 58
20595: PUSH
20596: EMPTY
20597: LIST
20598: PUSH
20599: EMPTY
20600: LIST
20601: LIST
20602: LIST
20603: PPUSH
20604: CALL_OW 69
20608: ST_TO_ADDR
// for i = 1 to 6 do
20609: LD_ADDR_VAR 0 1
20613: PUSH
20614: DOUBLE
20615: LD_INT 1
20617: DEC
20618: ST_TO_ADDR
20619: LD_INT 6
20621: PUSH
20622: FOR_TO
20623: IFFALSE 20764
// begin if IsInUnit ( tmp [ i ] ) then
20625: LD_VAR 0 3
20629: PUSH
20630: LD_VAR 0 1
20634: ARRAY
20635: PPUSH
20636: CALL_OW 310
20640: IFFALSE 20657
// ComExitBuilding ( tmp [ i ] ) ;
20642: LD_VAR 0 3
20646: PUSH
20647: LD_VAR 0 1
20651: ARRAY
20652: PPUSH
20653: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20657: LD_VAR 0 3
20661: PUSH
20662: LD_VAR 0 1
20666: ARRAY
20667: PPUSH
20668: LD_VAR 0 10
20672: PUSH
20673: LD_INT 1
20675: ARRAY
20676: PPUSH
20677: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20681: LD_VAR 0 3
20685: PUSH
20686: LD_VAR 0 1
20690: ARRAY
20691: PPUSH
20692: LD_INT 1
20694: PPUSH
20695: CALL_OW 183
// if emp_towers then
20699: LD_VAR 0 12
20703: IFFALSE 20762
// begin AddComExitBuilding ( tmp [ i ] ) ;
20705: LD_VAR 0 3
20709: PUSH
20710: LD_VAR 0 1
20714: ARRAY
20715: PPUSH
20716: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20720: LD_VAR 0 3
20724: PUSH
20725: LD_VAR 0 1
20729: ARRAY
20730: PPUSH
20731: LD_VAR 0 12
20735: PUSH
20736: LD_INT 1
20738: ARRAY
20739: PPUSH
20740: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
20744: LD_ADDR_VAR 0 12
20748: PUSH
20749: LD_VAR 0 12
20753: PPUSH
20754: LD_INT 1
20756: PPUSH
20757: CALL_OW 3
20761: ST_TO_ADDR
// end ; end ;
20762: GO 20622
20764: POP
20765: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
20766: LD_ADDR_VAR 0 3
20770: PUSH
20771: LD_EXP 18
20775: PUSH
20776: LD_INT 1
20778: ARRAY
20779: PUSH
20780: LD_EXP 18
20784: PUSH
20785: LD_INT 2
20787: ARRAY
20788: ADD
20789: PPUSH
20790: LD_INT 26
20792: PUSH
20793: LD_INT 1
20795: PUSH
20796: EMPTY
20797: LIST
20798: LIST
20799: PPUSH
20800: CALL_OW 72
20804: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
20805: LD_ADDR_VAR 0 1
20809: PUSH
20810: LD_EXP 18
20814: PUSH
20815: LD_INT 2
20817: ARRAY
20818: PUSH
20819: FOR_IN
20820: IFFALSE 20838
// ComTurnUnit ( i , Powell ) ;
20822: LD_VAR 0 1
20826: PPUSH
20827: LD_EXP 55
20831: PPUSH
20832: CALL_OW 119
20836: GO 20819
20838: POP
20839: POP
// Say ( Powell , D5-Pow-1 ) ;
20840: LD_EXP 55
20844: PPUSH
20845: LD_STRING D5-Pow-1
20847: PPUSH
20848: CALL_OW 88
// if tmp then
20852: LD_VAR 0 3
20856: IFFALSE 20874
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
20858: LD_VAR 0 3
20862: PUSH
20863: LD_INT 1
20865: ARRAY
20866: PPUSH
20867: LD_STRING D5-Sol2-1
20869: PPUSH
20870: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
20874: LD_EXP 55
20878: PPUSH
20879: LD_STRING D5-Pow-2
20881: PPUSH
20882: CALL_OW 88
// if tmp > 1 then
20886: LD_VAR 0 3
20890: PUSH
20891: LD_INT 1
20893: GREATER
20894: IFFALSE 20912
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
20896: LD_VAR 0 3
20900: PUSH
20901: LD_INT 2
20903: ARRAY
20904: PPUSH
20905: LD_STRING D5-Sol2-2
20907: PPUSH
20908: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
20912: LD_EXP 55
20916: PPUSH
20917: LD_STRING D5-Pow-3
20919: PPUSH
20920: CALL_OW 88
// wait ( 0 0$1 ) ;
20924: LD_INT 35
20926: PPUSH
20927: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
20931: LD_ADDR_VAR 0 3
20935: PUSH
20936: LD_EXP 18
20940: PUSH
20941: LD_INT 1
20943: ARRAY
20944: PUSH
20945: LD_EXP 18
20949: PUSH
20950: LD_INT 2
20952: ARRAY
20953: UNION
20954: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
20955: LD_VAR 0 3
20959: PPUSH
20960: LD_INT 80
20962: PPUSH
20963: LD_INT 67
20965: PPUSH
20966: CALL_OW 114
// wait ( 0 0$2 ) ;
20970: LD_INT 70
20972: PPUSH
20973: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
20977: LD_INT 79
20979: PPUSH
20980: LD_INT 72
20982: PPUSH
20983: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
20987: LD_INT 35
20989: PPUSH
20990: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
20994: LD_VAR 0 3
20998: PPUSH
20999: LD_INT 3
21001: PUSH
21002: LD_INT 24
21004: PUSH
21005: LD_INT 1000
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: PUSH
21012: EMPTY
21013: LIST
21014: LIST
21015: PPUSH
21016: CALL_OW 72
21020: IFFALSE 20987
// Say ( Powell , D5a-Pow-1 ) ;
21022: LD_EXP 55
21026: PPUSH
21027: LD_STRING D5a-Pow-1
21029: PPUSH
21030: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21034: LD_EXP 55
21038: PPUSH
21039: LD_STRING D5a-Pow-1a
21041: PPUSH
21042: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21046: LD_INT 10
21048: PPUSH
21049: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21053: LD_EXP 55
21057: PPUSH
21058: LD_STRING D5a-Pow-1b
21060: PPUSH
21061: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21065: LD_EXP 55
21069: PPUSH
21070: LD_STRING D5a-Pow-1c
21072: PPUSH
21073: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21077: LD_EXP 55
21081: PPUSH
21082: LD_STRING D5a-Pow-1d
21084: PPUSH
21085: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21089: LD_INT 35
21091: PPUSH
21092: CALL_OW 67
// if not HasTask ( tmp ) then
21096: LD_VAR 0 3
21100: PPUSH
21101: CALL_OW 314
21105: NOT
21106: IFFALSE 21123
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21108: LD_VAR 0 3
21112: PPUSH
21113: LD_INT 80
21115: PPUSH
21116: LD_INT 67
21118: PPUSH
21119: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21123: LD_VAR 0 3
21127: PPUSH
21128: LD_INT 24
21130: PUSH
21131: LD_INT 1
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PPUSH
21138: CALL_OW 72
21142: NOT
21143: IFFALSE 21089
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21145: LD_ADDR_VAR 0 3
21149: PUSH
21150: LD_INT 22
21152: PUSH
21153: LD_INT 4
21155: PUSH
21156: EMPTY
21157: LIST
21158: LIST
21159: PUSH
21160: LD_INT 92
21162: PUSH
21163: LD_INT 60
21165: PUSH
21166: LD_INT 93
21168: PUSH
21169: LD_INT 10
21171: PUSH
21172: EMPTY
21173: LIST
21174: LIST
21175: LIST
21176: LIST
21177: PUSH
21178: LD_INT 3
21180: PUSH
21181: LD_INT 54
21183: PUSH
21184: EMPTY
21185: LIST
21186: PUSH
21187: EMPTY
21188: LIST
21189: LIST
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: LIST
21195: PPUSH
21196: CALL_OW 69
21200: PUSH
21201: LD_EXP 55
21205: DIFF
21206: ST_TO_ADDR
// if tmp then
21207: LD_VAR 0 3
21211: IFFALSE 21245
// for i in tmp do
21213: LD_ADDR_VAR 0 1
21217: PUSH
21218: LD_VAR 0 3
21222: PUSH
21223: FOR_IN
21224: IFFALSE 21243
// ComMoveXY ( i , 36 , 67 ) ;
21226: LD_VAR 0 1
21230: PPUSH
21231: LD_INT 36
21233: PPUSH
21234: LD_INT 67
21236: PPUSH
21237: CALL_OW 111
21241: GO 21223
21243: POP
21244: POP
// wait ( 0 0$3 ) ;
21245: LD_INT 105
21247: PPUSH
21248: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21252: LD_VAR 0 11
21256: PPUSH
21257: LD_STRING D6-Sol3-1
21259: PPUSH
21260: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21264: LD_EXP 55
21268: PPUSH
21269: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21273: LD_EXP 55
21277: PPUSH
21278: LD_STRING D6-Pow-1
21280: PPUSH
21281: CALL_OW 88
// tmp := [ ] ;
21285: LD_ADDR_VAR 0 3
21289: PUSH
21290: EMPTY
21291: ST_TO_ADDR
// for i = 1 to 2 do
21292: LD_ADDR_VAR 0 1
21296: PUSH
21297: DOUBLE
21298: LD_INT 1
21300: DEC
21301: ST_TO_ADDR
21302: LD_INT 2
21304: PUSH
21305: FOR_TO
21306: IFFALSE 21413
// begin uc_side := 8 ;
21308: LD_ADDR_OWVAR 20
21312: PUSH
21313: LD_INT 8
21315: ST_TO_ADDR
// uc_nation := 2 ;
21316: LD_ADDR_OWVAR 21
21320: PUSH
21321: LD_INT 2
21323: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21324: LD_INT 14
21326: PPUSH
21327: LD_INT 3
21329: PPUSH
21330: LD_INT 2
21332: PPUSH
21333: LD_INT 29
21335: PPUSH
21336: LD_INT 100
21338: PPUSH
21339: CALL 68298 0 5
// veh := CreateVehicle ;
21343: LD_ADDR_VAR 0 13
21347: PUSH
21348: CALL_OW 45
21352: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21353: LD_VAR 0 13
21357: PPUSH
21358: LD_INT 4
21360: PPUSH
21361: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21365: LD_VAR 0 13
21369: PPUSH
21370: LD_INT 99
21372: PPUSH
21373: LD_INT 83
21375: PPUSH
21376: LD_INT 5
21378: PPUSH
21379: LD_INT 0
21381: PPUSH
21382: CALL_OW 50
// Connect ( veh ) ;
21386: LD_VAR 0 13
21390: PPUSH
21391: CALL 71353 0 1
// tmp := tmp ^ veh ;
21395: LD_ADDR_VAR 0 3
21399: PUSH
21400: LD_VAR 0 3
21404: PUSH
21405: LD_VAR 0 13
21409: ADD
21410: ST_TO_ADDR
// end ;
21411: GO 21305
21413: POP
21414: POP
// wait ( 0 0$1 ) ;
21415: LD_INT 35
21417: PPUSH
21418: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21422: LD_INT 99
21424: PPUSH
21425: LD_INT 83
21427: PPUSH
21428: LD_INT 1
21430: PPUSH
21431: LD_INT 10
21433: PPUSH
21434: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21438: LD_INT 99
21440: PPUSH
21441: LD_INT 83
21443: PPUSH
21444: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21448: LD_VAR 0 11
21452: PPUSH
21453: LD_STRING D6-Sol3-2
21455: PPUSH
21456: CALL_OW 88
// async ;
21460: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21461: LD_EXP 55
21465: PPUSH
21466: LD_STRING D6-Pow-2
21468: PPUSH
21469: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21473: LD_VAR 0 3
21477: PUSH
21478: LD_INT 1
21480: ARRAY
21481: PPUSH
21482: LD_VAR 0 9
21486: PPUSH
21487: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21491: LD_VAR 0 3
21495: PUSH
21496: LD_INT 2
21498: ARRAY
21499: PPUSH
21500: LD_INT 22
21502: PUSH
21503: LD_INT 4
21505: PUSH
21506: EMPTY
21507: LIST
21508: LIST
21509: PUSH
21510: LD_INT 21
21512: PUSH
21513: LD_INT 3
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: PUSH
21520: EMPTY
21521: LIST
21522: LIST
21523: PPUSH
21524: CALL_OW 69
21528: PPUSH
21529: LD_VAR 0 3
21533: PUSH
21534: LD_INT 2
21536: ARRAY
21537: PPUSH
21538: CALL_OW 74
21542: PPUSH
21543: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21547: LD_EXP 55
21551: PPUSH
21552: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21556: LD_INT 99
21558: PPUSH
21559: LD_INT 83
21561: PPUSH
21562: LD_INT 1
21564: PPUSH
21565: CALL_OW 331
// repeat wait ( 4 ) ;
21569: LD_INT 4
21571: PPUSH
21572: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21576: LD_VAR 0 3
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: PPUSH
21585: CALL_OW 256
21589: PUSH
21590: LD_INT 1000
21592: LESS
21593: IFFALSE 21611
// SetLives ( tmp [ 1 ] , 1000 ) ;
21595: LD_VAR 0 3
21599: PUSH
21600: LD_INT 1
21602: ARRAY
21603: PPUSH
21604: LD_INT 1000
21606: PPUSH
21607: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21611: LD_INT 22
21613: PUSH
21614: LD_INT 4
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 30
21623: PUSH
21624: LD_INT 3
21626: PUSH
21627: EMPTY
21628: LIST
21629: LIST
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: PPUSH
21635: CALL_OW 69
21639: PUSH
21640: LD_INT 0
21642: EQUAL
21643: IFFALSE 21569
// sync ;
21645: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21646: LD_EXP 55
21650: PPUSH
21651: LD_STRING D6a-Pow-1
21653: PPUSH
21654: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21658: LD_VAR 0 11
21662: PPUSH
21663: LD_STRING D6a-Sol3-1
21665: PPUSH
21666: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21670: LD_EXP 55
21674: PPUSH
21675: LD_STRING D6a-Pow-2
21677: PPUSH
21678: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21682: LD_VAR 0 11
21686: PPUSH
21687: LD_STRING D6a-Sol3-2
21689: PPUSH
21690: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21694: LD_EXP 55
21698: PPUSH
21699: LD_STRING D6a-Pow-3
21701: PPUSH
21702: CALL_OW 88
// powellCenterCameraMode := true ;
21706: LD_ADDR_EXP 20
21710: PUSH
21711: LD_INT 1
21713: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21714: LD_ADDR_VAR 0 1
21718: PUSH
21719: LD_INT 22
21721: PUSH
21722: LD_INT 8
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: PUSH
21729: LD_INT 25
21731: PUSH
21732: LD_INT 2
21734: PUSH
21735: EMPTY
21736: LIST
21737: LIST
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: PPUSH
21743: CALL_OW 69
21747: PUSH
21748: FOR_IN
21749: IFFALSE 21804
// begin SetTag ( i , 1 ) ;
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: CALL_OW 109
// ComExitBuilding ( i ) ;
21763: LD_VAR 0 1
21767: PPUSH
21768: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
21772: LD_VAR 0 1
21776: PPUSH
21777: LD_INT 35
21779: PPUSH
21780: LD_INT 6
21782: PPUSH
21783: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
21787: LD_VAR 0 1
21791: PPUSH
21792: LD_INT 53
21794: PPUSH
21795: LD_INT 4
21797: PPUSH
21798: CALL_OW 171
// end ;
21802: GO 21748
21804: POP
21805: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
21806: LD_ADDR_VAR 0 3
21810: PUSH
21811: LD_INT 22
21813: PUSH
21814: LD_INT 4
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PUSH
21821: LD_INT 21
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_INT 3
21833: PUSH
21834: LD_INT 34
21836: PUSH
21837: LD_INT 12
21839: PUSH
21840: EMPTY
21841: LIST
21842: LIST
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: LIST
21852: PPUSH
21853: CALL_OW 69
21857: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
21858: LD_EXP 55
21862: PPUSH
21863: LD_VAR 0 3
21867: PPUSH
21868: LD_EXP 55
21872: PPUSH
21873: CALL_OW 74
21877: PPUSH
21878: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
21882: LD_EXP 55
21886: PPUSH
21887: LD_INT 100
21889: PPUSH
21890: LD_INT 88
21892: PPUSH
21893: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
21897: LD_EXP 55
21901: PPUSH
21902: LD_INT 100
21904: PPUSH
21905: LD_INT 75
21907: PPUSH
21908: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
21912: LD_EXP 55
21916: PPUSH
21917: LD_INT 88
21919: PPUSH
21920: LD_INT 53
21922: PPUSH
21923: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
21927: LD_INT 8
21929: PPUSH
21930: LD_EXP 55
21934: PPUSH
21935: CALL_OW 471
// repeat wait ( 3 ) ;
21939: LD_INT 3
21941: PPUSH
21942: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
21946: LD_INT 22
21948: PUSH
21949: LD_INT 4
21951: PUSH
21952: EMPTY
21953: LIST
21954: LIST
21955: PUSH
21956: LD_INT 92
21958: PUSH
21959: LD_INT 100
21961: PUSH
21962: LD_INT 75
21964: PUSH
21965: LD_INT 6
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: PPUSH
21978: CALL_OW 69
21982: IFFALSE 21939
// async ;
21984: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
21985: LD_EXP 55
21989: PPUSH
21990: LD_STRING D6b-Pow-1
21992: PPUSH
21993: CALL_OW 88
// repeat wait ( 3 ) ;
21997: LD_INT 3
21999: PPUSH
22000: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22004: LD_EXP 55
22008: PPUSH
22009: CALL_OW 310
22013: PPUSH
22014: CALL_OW 256
22018: PUSH
22019: LD_INT 1000
22021: LESS
22022: IFFALSE 22041
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22024: LD_EXP 55
22028: PPUSH
22029: CALL_OW 310
22033: PPUSH
22034: LD_INT 1000
22036: PPUSH
22037: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22041: LD_EXP 55
22045: PPUSH
22046: CALL_OW 256
22050: PUSH
22051: LD_INT 1000
22053: LESS
22054: IFFALSE 22068
// SetLives ( Powell , 1000 ) ;
22056: LD_EXP 55
22060: PPUSH
22061: LD_INT 1000
22063: PPUSH
22064: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22068: LD_EXP 55
22072: PPUSH
22073: LD_EXP 60
22077: PPUSH
22078: CALL_OW 296
22082: PUSH
22083: LD_INT 5
22085: LESS
22086: PUSH
22087: LD_EXP 55
22091: PPUSH
22092: CALL_OW 310
22096: PPUSH
22097: LD_EXP 60
22101: PPUSH
22102: CALL_OW 296
22106: PUSH
22107: LD_INT 5
22109: LESS
22110: OR
22111: IFFALSE 22130
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22113: LD_EXP 55
22117: PPUSH
22118: CALL_OW 310
22122: PPUSH
22123: LD_INT 100
22125: PPUSH
22126: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22130: LD_EXP 55
22134: PPUSH
22135: CALL_OW 310
22139: NOT
22140: IFFALSE 21997
// game_speed := 4 ;
22142: LD_ADDR_OWVAR 65
22146: PUSH
22147: LD_INT 4
22149: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22150: LD_EXP 55
22154: PPUSH
22155: LD_STRING D6b-Pow-1a
22157: PPUSH
22158: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22162: LD_EXP 55
22166: PPUSH
22167: LD_EXP 60
22171: PPUSH
22172: CALL_OW 180
// sync ;
22176: SYNC
// repeat wait ( 0 0$1 ) ;
22177: LD_INT 35
22179: PPUSH
22180: CALL_OW 67
// until IsInUnit ( Powell ) ;
22184: LD_EXP 55
22188: PPUSH
22189: CALL_OW 310
22193: IFFALSE 22177
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22195: LD_INT 8
22197: PPUSH
22198: LD_EXP 55
22202: PPUSH
22203: CALL_OW 310
22207: PPUSH
22208: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22212: LD_EXP 55
22216: PPUSH
22217: LD_INT 91
22219: PPUSH
22220: LD_INT 44
22222: PPUSH
22223: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22227: LD_EXP 55
22231: PPUSH
22232: LD_INT 96
22234: PPUSH
22235: LD_INT 44
22237: PPUSH
22238: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22242: LD_EXP 55
22246: PPUSH
22247: LD_INT 96
22249: PPUSH
22250: LD_INT 41
22252: PPUSH
22253: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22257: LD_EXP 55
22261: PPUSH
22262: LD_INT 92
22264: PPUSH
22265: LD_INT 39
22267: PPUSH
22268: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22272: LD_EXP 55
22276: PPUSH
22277: LD_INT 88
22279: PPUSH
22280: LD_INT 41
22282: PPUSH
22283: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22287: LD_EXP 55
22291: PPUSH
22292: LD_INT 91
22294: PPUSH
22295: LD_INT 44
22297: PPUSH
22298: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22302: LD_EXP 55
22306: PPUSH
22307: LD_INT 96
22309: PPUSH
22310: LD_INT 44
22312: PPUSH
22313: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22317: LD_EXP 55
22321: PPUSH
22322: LD_INT 96
22324: PPUSH
22325: LD_INT 41
22327: PPUSH
22328: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22332: LD_EXP 55
22336: PPUSH
22337: LD_INT 92
22339: PPUSH
22340: LD_INT 39
22342: PPUSH
22343: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22347: LD_EXP 55
22351: PPUSH
22352: LD_INT 88
22354: PPUSH
22355: LD_INT 41
22357: PPUSH
22358: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22362: LD_EXP 55
22366: PPUSH
22367: LD_INT 91
22369: PPUSH
22370: LD_INT 44
22372: PPUSH
22373: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22377: LD_EXP 55
22381: PPUSH
22382: LD_INT 93
22384: PPUSH
22385: LD_INT 39
22387: PPUSH
22388: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22392: LD_EXP 55
22396: PPUSH
22397: LD_INT 93
22399: PPUSH
22400: LD_INT 36
22402: PPUSH
22403: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22407: LD_INT 122
22409: PPUSH
22410: CALL_OW 67
// game_speed := 4 ;
22414: LD_ADDR_OWVAR 65
22418: PUSH
22419: LD_INT 4
22421: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22422: LD_EXP 55
22426: PPUSH
22427: LD_STRING D6b-Pow-1b
22429: PPUSH
22430: CALL_OW 88
// tmp := [ ] ;
22434: LD_ADDR_VAR 0 3
22438: PUSH
22439: EMPTY
22440: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22441: LD_ADDR_VAR 0 5
22445: PUSH
22446: LD_INT 78
22448: PUSH
22449: LD_INT 47
22451: PUSH
22452: EMPTY
22453: LIST
22454: LIST
22455: PUSH
22456: LD_INT 106
22458: PUSH
22459: LD_INT 53
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: PUSH
22466: EMPTY
22467: LIST
22468: LIST
22469: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22470: LD_ADDR_VAR 0 1
22474: PUSH
22475: LD_INT 22
22477: PUSH
22478: LD_INT 8
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: PUSH
22485: LD_INT 21
22487: PUSH
22488: LD_INT 3
22490: PUSH
22491: EMPTY
22492: LIST
22493: LIST
22494: PUSH
22495: LD_INT 92
22497: PUSH
22498: LD_INT 90
22500: PUSH
22501: LD_INT 52
22503: PUSH
22504: LD_INT 12
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: LIST
22517: PPUSH
22518: CALL_OW 69
22522: PUSH
22523: FOR_IN
22524: IFFALSE 22549
// tmp := tmp ^ UnitsInside ( i ) ;
22526: LD_ADDR_VAR 0 3
22530: PUSH
22531: LD_VAR 0 3
22535: PUSH
22536: LD_VAR 0 1
22540: PPUSH
22541: CALL_OW 313
22545: ADD
22546: ST_TO_ADDR
22547: GO 22523
22549: POP
22550: POP
// for i in tmp do
22551: LD_ADDR_VAR 0 1
22555: PUSH
22556: LD_VAR 0 3
22560: PUSH
22561: FOR_IN
22562: IFFALSE 22724
// begin dist := 9999 ;
22564: LD_ADDR_VAR 0 8
22568: PUSH
22569: LD_INT 9999
22571: ST_TO_ADDR
// _xy := [ ] ;
22572: LD_ADDR_VAR 0 7
22576: PUSH
22577: EMPTY
22578: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22579: LD_VAR 0 1
22583: PPUSH
22584: LD_INT 1
22586: PPUSH
22587: CALL_OW 109
// ComExitBuilding ( i ) ;
22591: LD_VAR 0 1
22595: PPUSH
22596: CALL_OW 122
// for j in xy do
22600: LD_ADDR_VAR 0 2
22604: PUSH
22605: LD_VAR 0 5
22609: PUSH
22610: FOR_IN
22611: IFFALSE 22693
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22613: LD_VAR 0 1
22617: PPUSH
22618: LD_VAR 0 2
22622: PUSH
22623: LD_INT 1
22625: ARRAY
22626: PPUSH
22627: LD_VAR 0 2
22631: PUSH
22632: LD_INT 2
22634: ARRAY
22635: PPUSH
22636: CALL_OW 297
22640: PUSH
22641: LD_VAR 0 8
22645: LESS
22646: IFFALSE 22691
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22648: LD_ADDR_VAR 0 8
22652: PUSH
22653: LD_VAR 0 1
22657: PPUSH
22658: LD_VAR 0 2
22662: PUSH
22663: LD_INT 1
22665: ARRAY
22666: PPUSH
22667: LD_VAR 0 2
22671: PUSH
22672: LD_INT 2
22674: ARRAY
22675: PPUSH
22676: CALL_OW 297
22680: ST_TO_ADDR
// _xy := j ;
22681: LD_ADDR_VAR 0 7
22685: PUSH
22686: LD_VAR 0 2
22690: ST_TO_ADDR
// end ;
22691: GO 22610
22693: POP
22694: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22695: LD_VAR 0 1
22699: PPUSH
22700: LD_VAR 0 7
22704: PUSH
22705: LD_INT 1
22707: ARRAY
22708: PPUSH
22709: LD_VAR 0 7
22713: PUSH
22714: LD_INT 2
22716: ARRAY
22717: PPUSH
22718: CALL_OW 171
// end ;
22722: GO 22561
22724: POP
22725: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22726: LD_ADDR_VAR 0 4
22730: PUSH
22731: LD_VAR 0 3
22735: PPUSH
22736: LD_INT 26
22738: PUSH
22739: LD_INT 1
22741: PUSH
22742: EMPTY
22743: LIST
22744: LIST
22745: PUSH
22746: LD_INT 25
22748: PUSH
22749: LD_INT 1
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: PPUSH
22760: CALL_OW 72
22764: ST_TO_ADDR
// if tmp2 < 2 then
22765: LD_VAR 0 4
22769: PUSH
22770: LD_INT 2
22772: LESS
22773: IFFALSE 22842
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
22775: LD_ADDR_VAR 0 4
22779: PUSH
22780: LD_INT 22
22782: PUSH
22783: LD_INT 8
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: LD_INT 26
22792: PUSH
22793: LD_INT 1
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: PUSH
22800: LD_INT 3
22802: PUSH
22803: LD_INT 25
22805: PUSH
22806: LD_INT 15
22808: PUSH
22809: EMPTY
22810: LIST
22811: LIST
22812: PUSH
22813: EMPTY
22814: LIST
22815: LIST
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: LIST
22821: PPUSH
22822: CALL_OW 69
22826: PUSH
22827: LD_EXP 57
22831: PUSH
22832: LD_EXP 58
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: DIFF
22841: ST_TO_ADDR
// if tmp2 then
22842: LD_VAR 0 4
22846: IFFALSE 22864
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
22848: LD_VAR 0 4
22852: PUSH
22853: LD_INT 1
22855: ARRAY
22856: PPUSH
22857: LD_STRING D6b-ArSol1-1
22859: PPUSH
22860: CALL_OW 88
// async ;
22864: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
22865: LD_EXP 55
22869: PPUSH
22870: LD_STRING D6b-Pow-2
22872: PPUSH
22873: CALL_OW 88
// wait ( 0 0$1 ) ;
22877: LD_INT 35
22879: PPUSH
22880: CALL_OW 67
// if tmp2 > 1 then
22884: LD_VAR 0 4
22888: PUSH
22889: LD_INT 1
22891: GREATER
22892: IFFALSE 22910
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
22894: LD_VAR 0 4
22898: PUSH
22899: LD_INT 2
22901: ARRAY
22902: PPUSH
22903: LD_STRING D6b-ArSol2-1
22905: PPUSH
22906: CALL_OW 88
// sync ;
22910: SYNC
// repeat wait ( 5 ) ;
22911: LD_INT 5
22913: PPUSH
22914: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
22918: LD_INT 93
22920: PPUSH
22921: LD_INT 36
22923: PPUSH
22924: CALL_OW 428
22928: PPUSH
22929: CALL_OW 255
22933: PUSH
22934: LD_INT 4
22936: EQUAL
22937: IFFALSE 22911
// DialogueOn ;
22939: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
22943: LD_INT 10
22945: PPUSH
22946: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
22950: LD_EXP 55
22954: PPUSH
22955: LD_STRING D6b-Pow-2a
22957: PPUSH
22958: CALL_OW 88
// DialogueOff ;
22962: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
22966: LD_EXP 55
22970: PPUSH
22971: CALL_OW 310
22975: PPUSH
22976: LD_INT 332
22978: PPUSH
22979: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
22983: LD_INT 93
22985: PPUSH
22986: LD_INT 35
22988: PPUSH
22989: LD_INT 1
22991: PPUSH
22992: LD_INT 6
22994: NEG
22995: PPUSH
22996: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23000: LD_INT 35
23002: PPUSH
23003: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23007: LD_INT 332
23009: PPUSH
23010: CALL_OW 256
23014: PUSH
23015: LD_INT 1000
23017: LESS
23018: PUSH
23019: LD_INT 332
23021: PPUSH
23022: CALL_OW 300
23026: AND
23027: IFFALSE 23039
// SetLives ( kozlov_fac , 0 ) ;
23029: LD_INT 332
23031: PPUSH
23032: LD_INT 0
23034: PPUSH
23035: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23039: LD_INT 332
23041: PPUSH
23042: CALL_OW 301
23046: PUSH
23047: LD_EXP 55
23051: PPUSH
23052: CALL_OW 301
23056: OR
23057: IFFALSE 23000
// game_speed := 4 ;
23059: LD_ADDR_OWVAR 65
23063: PUSH
23064: LD_INT 4
23066: ST_TO_ADDR
// powellCenterCameraMode := false ;
23067: LD_ADDR_EXP 20
23071: PUSH
23072: LD_INT 0
23074: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23075: LD_ADDR_VAR 0 1
23079: PUSH
23080: LD_VAR 0 3
23084: PUSH
23085: LD_INT 22
23087: PUSH
23088: LD_INT 8
23090: PUSH
23091: EMPTY
23092: LIST
23093: LIST
23094: PUSH
23095: LD_INT 25
23097: PUSH
23098: LD_INT 2
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: PUSH
23105: EMPTY
23106: LIST
23107: LIST
23108: PPUSH
23109: CALL_OW 69
23113: UNION
23114: PUSH
23115: FOR_IN
23116: IFFALSE 23132
// SetTag ( i , 0 ) ;
23118: LD_VAR 0 1
23122: PPUSH
23123: LD_INT 0
23125: PPUSH
23126: CALL_OW 109
23130: GO 23115
23132: POP
23133: POP
// wait ( 0 0$3 ) ;
23134: LD_INT 105
23136: PPUSH
23137: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 35
23146: PPUSH
23147: LD_INT 1
23149: PPUSH
23150: CALL_OW 331
// DialogueOn ;
23154: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23158: LD_VAR 0 11
23162: PPUSH
23163: LD_STRING D6c-Sol3-1
23165: PPUSH
23166: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23170: LD_INT 10
23172: PPUSH
23173: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23177: LD_EXP 36
23181: PPUSH
23182: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23186: LD_EXP 36
23190: PPUSH
23191: LD_STRING D6c-JMM-1
23193: PPUSH
23194: CALL_OW 88
// if Cyrus then
23198: LD_EXP 42
23202: IFFALSE 23216
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23204: LD_EXP 42
23208: PPUSH
23209: LD_STRING D6c-Cyrus-1
23211: PPUSH
23212: CALL_OW 88
// if Bobby then
23216: LD_EXP 41
23220: IFFALSE 23234
// Say ( Bobby , D6c-Bobby-1 ) ;
23222: LD_EXP 41
23226: PPUSH
23227: LD_STRING D6c-Bobby-1
23229: PPUSH
23230: CALL_OW 88
// if Cornel then
23234: LD_EXP 47
23238: IFFALSE 23252
// Say ( Cornel , D6c-Corn-1 ) ;
23240: LD_EXP 47
23244: PPUSH
23245: LD_STRING D6c-Corn-1
23247: PPUSH
23248: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23252: LD_ADDR_VAR 0 4
23256: PUSH
23257: LD_INT 2
23259: PUSH
23260: LD_INT 22
23262: PUSH
23263: LD_INT 1
23265: PUSH
23266: EMPTY
23267: LIST
23268: LIST
23269: PUSH
23270: LD_INT 22
23272: PUSH
23273: LD_INT 4
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: PUSH
23280: EMPTY
23281: LIST
23282: LIST
23283: LIST
23284: PUSH
23285: LD_INT 26
23287: PUSH
23288: LD_INT 1
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: LD_INT 3
23297: PUSH
23298: LD_INT 25
23300: PUSH
23301: LD_INT 16
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 25
23310: PUSH
23311: LD_INT 12
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: LIST
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: LIST
23327: PPUSH
23328: CALL_OW 69
23332: PUSH
23333: LD_VAR 0 11
23337: PUSH
23338: LD_EXP 36
23342: UNION
23343: PUSH
23344: LD_EXP 56
23348: UNION
23349: PUSH
23350: EMPTY
23351: LIST
23352: DIFF
23353: ST_TO_ADDR
// if tmp2 then
23354: LD_VAR 0 4
23358: IFFALSE 23376
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23360: LD_VAR 0 4
23364: PUSH
23365: LD_INT 1
23367: ARRAY
23368: PPUSH
23369: LD_STRING D6c-Sol1-1
23371: PPUSH
23372: CALL_OW 88
// if Lisa then
23376: LD_EXP 39
23380: IFFALSE 23394
// Say ( Lisa , D6c-Lisa-1 ) ;
23382: LD_EXP 39
23386: PPUSH
23387: LD_STRING D6c-Lisa-1
23389: PPUSH
23390: CALL_OW 88
// if Gary then
23394: LD_EXP 48
23398: IFFALSE 23412
// Say ( Gary , D6c-Gary-1 ) ;
23400: LD_EXP 48
23404: PPUSH
23405: LD_STRING D6c-Gary-1
23407: PPUSH
23408: CALL_OW 88
// if Donaldson then
23412: LD_EXP 40
23416: IFFALSE 23430
// Say ( Donaldson , D6c-Don-1 ) ;
23418: LD_EXP 40
23422: PPUSH
23423: LD_STRING D6c-Don-1
23425: PPUSH
23426: CALL_OW 88
// if tmp2 > 1 then
23430: LD_VAR 0 4
23434: PUSH
23435: LD_INT 1
23437: GREATER
23438: IFFALSE 23456
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23440: LD_VAR 0 4
23444: PUSH
23445: LD_INT 2
23447: ARRAY
23448: PPUSH
23449: LD_STRING D6c-Sol2-1
23451: PPUSH
23452: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23456: LD_VAR 0 11
23460: PPUSH
23461: LD_STRING D6c-Sol3-2
23463: PPUSH
23464: CALL_OW 88
// dwait ( 0 0$1 ) ;
23468: LD_INT 35
23470: PPUSH
23471: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23475: LD_EXP 36
23479: PPUSH
23480: LD_STRING D6c-JMM-2
23482: PPUSH
23483: CALL_OW 88
// DialogueOff ;
23487: CALL_OW 7
// Video ( false ) ;
23491: LD_INT 0
23493: PPUSH
23494: CALL 103953 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23498: LD_INT 22
23500: PUSH
23501: LD_INT 4
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PPUSH
23508: CALL_OW 69
23512: PPUSH
23513: LD_INT 1
23515: PPUSH
23516: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23520: LD_INT 4
23522: PPUSH
23523: LD_INT 4
23525: PPUSH
23526: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23530: LD_ADDR_VAR 0 1
23534: PUSH
23535: LD_INT 4
23537: PPUSH
23538: LD_INT 1
23540: PPUSH
23541: LD_INT 2
23543: PPUSH
23544: CALL 61728 0 3
23548: PUSH
23549: FOR_IN
23550: IFFALSE 23587
// if GetTech ( i , 1 ) <> state_researched then
23552: LD_VAR 0 1
23556: PPUSH
23557: LD_INT 1
23559: PPUSH
23560: CALL_OW 321
23564: PUSH
23565: LD_INT 2
23567: NONEQUAL
23568: IFFALSE 23585
// SetTech ( i , 1 , state_researched ) ;
23570: LD_VAR 0 1
23574: PPUSH
23575: LD_INT 1
23577: PPUSH
23578: LD_INT 2
23580: PPUSH
23581: CALL_OW 322
23585: GO 23549
23587: POP
23588: POP
// missionStage := 6 ;
23589: LD_ADDR_EXP 15
23593: PUSH
23594: LD_INT 6
23596: ST_TO_ADDR
// activeAttacks := true ;
23597: LD_ADDR_EXP 16
23601: PUSH
23602: LD_INT 1
23604: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23605: LD_STRING M2
23607: PPUSH
23608: CALL_OW 337
// SaveForQuickRestart ;
23612: CALL_OW 22
// wait ( 0 0$40 ) ;
23616: LD_INT 1400
23618: PPUSH
23619: CALL_OW 67
// DialogueOn ;
23623: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23627: LD_EXP 59
23631: PPUSH
23632: LD_STRING D7-Friend-1
23634: PPUSH
23635: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23639: LD_EXP 36
23643: PPUSH
23644: LD_STRING D7-JMM-1
23646: PPUSH
23647: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23651: LD_EXP 59
23655: PPUSH
23656: LD_STRING D7-Friend-2
23658: PPUSH
23659: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23663: LD_EXP 36
23667: PPUSH
23668: LD_STRING D7-JMM-2
23670: PPUSH
23671: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23675: LD_EXP 59
23679: PPUSH
23680: LD_STRING D7-Friend-3
23682: PPUSH
23683: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23687: LD_EXP 36
23691: PPUSH
23692: LD_STRING D7-JMM-3
23694: PPUSH
23695: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23699: LD_EXP 59
23703: PPUSH
23704: LD_STRING D7-Friend-4
23706: PPUSH
23707: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23711: LD_EXP 36
23715: PPUSH
23716: LD_STRING D7-JMM-4
23718: PPUSH
23719: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23723: LD_EXP 59
23727: PPUSH
23728: LD_STRING D7-Friend-5
23730: PPUSH
23731: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
23735: LD_EXP 36
23739: PPUSH
23740: LD_STRING D7-JMM-5
23742: PPUSH
23743: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
23747: LD_EXP 59
23751: PPUSH
23752: LD_STRING D7-Friend-6
23754: PPUSH
23755: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
23759: LD_EXP 36
23763: PPUSH
23764: LD_STRING D7-JMM-6
23766: PPUSH
23767: CALL_OW 88
// DialogueOff ;
23771: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
23775: LD_STRING Mlegion
23777: PPUSH
23778: CALL_OW 337
// RebuildKozlovFactory ;
23782: CALL 4677 0 0
// end ;
23786: PPOPN 13
23788: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
23789: LD_EXP 20
23793: PUSH
23794: LD_EXP 55
23798: PPUSH
23799: CALL_OW 300
23803: AND
23804: IFFALSE 23846
23806: GO 23808
23808: DISABLE
// begin enable ;
23809: ENABLE
// if IsInUnit ( Powell ) then
23810: LD_EXP 55
23814: PPUSH
23815: CALL_OW 310
23819: IFFALSE 23837
// CenterOnUnits ( IsInUnit ( Powell ) ) else
23821: LD_EXP 55
23825: PPUSH
23826: CALL_OW 310
23830: PPUSH
23831: CALL_OW 85
23835: GO 23846
// CenterOnUnits ( Powell ) ;
23837: LD_EXP 55
23841: PPUSH
23842: CALL_OW 85
// end ;
23846: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
23847: LD_INT 22
23849: PUSH
23850: LD_INT 8
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: PUSH
23857: LD_INT 34
23859: PUSH
23860: LD_INT 48
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PPUSH
23871: CALL_OW 69
23875: IFFALSE 24138
23877: GO 23879
23879: DISABLE
23880: LD_INT 0
23882: PPUSH
23883: PPUSH
// begin if missionStage < 9 then
23884: LD_EXP 15
23888: PUSH
23889: LD_INT 9
23891: LESS
23892: IFFALSE 23902
// missionStage := 9 ;
23894: LD_ADDR_EXP 15
23898: PUSH
23899: LD_INT 9
23901: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
23902: LD_ADDR_VAR 0 1
23906: PUSH
23907: LD_INT 22
23909: PUSH
23910: LD_INT 8
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: LD_INT 34
23919: PUSH
23920: LD_INT 48
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PPUSH
23931: CALL_OW 69
23935: PUSH
23936: LD_INT 1
23938: ARRAY
23939: ST_TO_ADDR
// wait ( 0 0$05 ) ;
23940: LD_INT 175
23942: PPUSH
23943: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
23947: LD_EXP 12
23951: PUSH
23952: LD_EXP 3
23956: PUSH
23957: LD_INT 0
23959: PUSH
23960: LD_INT 2
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: IN
23967: OR
23968: IFFALSE 23991
// target := [ 68 , 108 , 1 ] else
23970: LD_ADDR_VAR 0 2
23974: PUSH
23975: LD_INT 68
23977: PUSH
23978: LD_INT 108
23980: PUSH
23981: LD_INT 1
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: ST_TO_ADDR
23989: GO 24010
// target := [ 181 , 88 , 2 ] ;
23991: LD_ADDR_VAR 0 2
23995: PUSH
23996: LD_INT 181
23998: PUSH
23999: LD_INT 88
24001: PUSH
24002: LD_INT 2
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: LIST
24009: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24010: LD_VAR 0 1
24014: PPUSH
24015: LD_VAR 0 2
24019: PUSH
24020: LD_INT 1
24022: ARRAY
24023: PPUSH
24024: LD_VAR 0 2
24028: PUSH
24029: LD_INT 2
24031: ARRAY
24032: PPUSH
24033: CALL_OW 176
// if target [ 3 ] = 1 then
24037: LD_VAR 0 2
24041: PUSH
24042: LD_INT 3
24044: ARRAY
24045: PUSH
24046: LD_INT 1
24048: EQUAL
24049: IFFALSE 24065
// SayRadio ( Kurt , D12-Kurt-1 ) else
24051: LD_EXP 57
24055: PPUSH
24056: LD_STRING D12-Kurt-1
24058: PPUSH
24059: CALL_OW 94
24063: GO 24089
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24065: LD_EXP 57
24069: PPUSH
24070: LD_STRING D12a-Kurt-1
24072: PPUSH
24073: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24077: LD_EXP 71
24081: PPUSH
24082: LD_STRING D12a-Roth-1
24084: PPUSH
24085: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24089: LD_INT 350
24091: PPUSH
24092: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_INT 22
24103: PUSH
24104: LD_INT 8
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PUSH
24111: LD_INT 30
24113: PUSH
24114: LD_INT 3
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: EMPTY
24122: LIST
24123: LIST
24124: PPUSH
24125: CALL_OW 69
24129: PUSH
24130: LD_INT 1
24132: ARRAY
24133: PPUSH
24134: CALL_OW 228
// end ;
24138: PPOPN 2
24140: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24141: LD_INT 22
24143: PUSH
24144: LD_INT 8
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 21
24153: PUSH
24154: LD_INT 1
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: LD_INT 23
24163: PUSH
24164: LD_INT 2
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: EMPTY
24172: LIST
24173: LIST
24174: LIST
24175: PPUSH
24176: CALL_OW 69
24180: PUSH
24181: LD_INT 8
24183: PUSH
24184: LD_INT 7
24186: PUSH
24187: LD_INT 6
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: LIST
24194: PUSH
24195: LD_OWVAR 67
24199: ARRAY
24200: LESSEQUAL
24201: PUSH
24202: LD_INT 22
24204: PUSH
24205: LD_INT 8
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PUSH
24212: LD_INT 34
24214: PUSH
24215: LD_INT 48
24217: PUSH
24218: EMPTY
24219: LIST
24220: LIST
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: PPUSH
24226: CALL_OW 69
24230: NOT
24231: AND
24232: PUSH
24233: LD_EXP 57
24237: PPUSH
24238: CALL_OW 302
24242: AND
24243: IFFALSE 24560
24245: GO 24247
24247: DISABLE
// begin DialogueOn ;
24248: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24252: LD_EXP 36
24256: PPUSH
24257: LD_STRING D13-JMM-1
24259: PPUSH
24260: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24264: LD_EXP 57
24268: PPUSH
24269: LD_STRING D13-Kurt-1
24271: PPUSH
24272: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24276: LD_EXP 36
24280: PPUSH
24281: LD_STRING D13-JMM-2
24283: PPUSH
24284: CALL_OW 88
// if FakeInfo then
24288: LD_EXP 12
24292: IFFALSE 24312
// begin Say ( Kurt , D13-Kurt-2 ) ;
24294: LD_EXP 57
24298: PPUSH
24299: LD_STRING D13-Kurt-2
24301: PPUSH
24302: CALL_OW 88
// DialogueOff ;
24306: CALL_OW 7
// exit ;
24310: GO 24560
// end ; if not KurtStatus then
24312: LD_EXP 3
24316: NOT
24317: IFFALSE 24333
// Say ( Kurt , D13-Kurt-2b ) else
24319: LD_EXP 57
24323: PPUSH
24324: LD_STRING D13-Kurt-2b
24326: PPUSH
24327: CALL_OW 88
24331: GO 24345
// Say ( Kurt , D13-Kurt-2a ) ;
24333: LD_EXP 57
24337: PPUSH
24338: LD_STRING D13-Kurt-2a
24340: PPUSH
24341: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24345: LD_EXP 57
24349: PPUSH
24350: LD_STRING D13-Kurt-2a
24352: PPUSH
24353: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24357: LD_EXP 36
24361: PPUSH
24362: LD_STRING D13-JMM-3
24364: PPUSH
24365: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24369: LD_EXP 57
24373: PPUSH
24374: LD_STRING D13-Kurt-3
24376: PPUSH
24377: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24381: LD_EXP 36
24385: PPUSH
24386: LD_STRING D13-JMM-4
24388: PPUSH
24389: CALL_OW 88
// DialogueOff ;
24393: CALL_OW 7
// MC_Kill ( 3 ) ;
24397: LD_INT 3
24399: PPUSH
24400: CALL 33654 0 1
// KillUnit ( Kozlov ) ;
24404: LD_EXP 58
24408: PPUSH
24409: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24413: LD_INT 22
24415: PUSH
24416: LD_INT 8
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PUSH
24423: LD_INT 21
24425: PUSH
24426: LD_INT 3
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 23
24435: PUSH
24436: LD_INT 3
24438: PUSH
24439: EMPTY
24440: LIST
24441: LIST
24442: PUSH
24443: LD_INT 30
24445: PUSH
24446: LD_INT 3
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: PPUSH
24459: CALL_OW 69
24463: PUSH
24464: LD_INT 1
24466: ARRAY
24467: PPUSH
24468: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24472: LD_INT 8
24474: PPUSH
24475: LD_INT 1
24477: PPUSH
24478: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24482: LD_INT 22
24484: PUSH
24485: LD_INT 8
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PPUSH
24492: CALL_OW 69
24496: PPUSH
24497: LD_INT 1
24499: PPUSH
24500: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24504: LD_INT 8
24506: PPUSH
24507: LD_INT 1
24509: PPUSH
24510: LD_INT 1
24512: PPUSH
24513: LD_INT 1
24515: PPUSH
24516: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24520: LD_EXP 59
24524: PPUSH
24525: LD_INT 37
24527: PPUSH
24528: LD_INT 1
24530: PPUSH
24531: LD_INT 0
24533: PPUSH
24534: CALL_OW 48
// wait ( 0 0$1 ) ;
24538: LD_INT 35
24540: PPUSH
24541: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24545: LD_EXP 59
24549: PPUSH
24550: LD_INT 60
24552: PPUSH
24553: LD_INT 95
24555: PPUSH
24556: CALL_OW 111
// end ;
24560: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24561: LD_INT 22
24563: PUSH
24564: LD_INT 8
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: LD_INT 21
24573: PUSH
24574: LD_INT 1
24576: PUSH
24577: EMPTY
24578: LIST
24579: LIST
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: PPUSH
24585: CALL_OW 69
24589: PUSH
24590: LD_INT 0
24592: EQUAL
24593: IFFALSE 24613
24595: GO 24597
24597: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24598: LD_STRING MlegionOut
24600: PPUSH
24601: CALL_OW 337
// legionDestroyed := true ;
24605: LD_ADDR_EXP 22
24609: PUSH
24610: LD_INT 1
24612: ST_TO_ADDR
// end ;
24613: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24614: LD_INT 1
24616: PPUSH
24617: LD_EXP 59
24621: PPUSH
24622: CALL_OW 292
24626: IFFALSE 24926
24628: GO 24630
24630: DISABLE
24631: LD_INT 0
24633: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24634: LD_EXP 59
24638: PPUSH
24639: CALL_OW 87
// DialogueOn ;
24643: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24647: LD_EXP 36
24651: PPUSH
24652: LD_STRING D14-JMM-1
24654: PPUSH
24655: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24659: LD_EXP 59
24663: PPUSH
24664: LD_STRING D14-Friend-1
24666: PPUSH
24667: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24671: LD_EXP 36
24675: PPUSH
24676: LD_STRING D14-JMM-2
24678: PPUSH
24679: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24683: LD_EXP 59
24687: PPUSH
24688: LD_STRING D14-Friend-2
24690: PPUSH
24691: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24695: LD_EXP 36
24699: PPUSH
24700: LD_STRING D14-JMM-3
24702: PPUSH
24703: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24707: LD_EXP 59
24711: PPUSH
24712: LD_STRING D14-Friend-3
24714: PPUSH
24715: CALL_OW 88
// DialogueOff ;
24719: CALL_OW 7
// dec = Query ( Q14 ) ;
24723: LD_ADDR_VAR 0 1
24727: PUSH
24728: LD_STRING Q14
24730: PPUSH
24731: CALL_OW 97
24735: ST_TO_ADDR
// if dec = 1 then
24736: LD_VAR 0 1
24740: PUSH
24741: LD_INT 1
24743: EQUAL
24744: IFFALSE 24778
// begin DialogueOn ;
24746: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
24750: LD_EXP 36
24754: PPUSH
24755: LD_STRING D14a-JMM-1
24757: PPUSH
24758: CALL_OW 88
// DialogueOff ;
24762: CALL_OW 7
// SetSide ( Friend , 1 ) ;
24766: LD_EXP 59
24770: PPUSH
24771: LD_INT 1
24773: PPUSH
24774: CALL_OW 235
// end ; if dec = 2 then
24778: LD_VAR 0 1
24782: PUSH
24783: LD_INT 2
24785: EQUAL
24786: IFFALSE 24832
// begin DialogueOn ;
24788: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
24792: LD_EXP 36
24796: PPUSH
24797: LD_STRING D14b-JMM-1
24799: PPUSH
24800: CALL_OW 88
// DialogueOff ;
24804: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
24808: LD_EXP 59
24812: PPUSH
24813: LD_INT 9
24815: PPUSH
24816: LD_INT 2
24818: PPUSH
24819: CALL_OW 111
// AddComHold ( Friend ) ;
24823: LD_EXP 59
24827: PPUSH
24828: CALL_OW 200
// end ; if dec = 3 then
24832: LD_VAR 0 1
24836: PUSH
24837: LD_INT 3
24839: EQUAL
24840: IFFALSE 24926
// begin DialogueOn ;
24842: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
24846: LD_EXP 36
24850: PPUSH
24851: LD_STRING D14c-JMM-1
24853: PPUSH
24854: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
24858: LD_EXP 59
24862: PPUSH
24863: LD_STRING D14c-Friend-1
24865: PPUSH
24866: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
24870: LD_EXP 36
24874: PPUSH
24875: LD_STRING D14c-JMM-2
24877: PPUSH
24878: CALL_OW 88
// DialogueOff ;
24882: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
24886: LD_INT 8
24888: PPUSH
24889: LD_INT 1
24891: PPUSH
24892: LD_INT 2
24894: PPUSH
24895: LD_INT 1
24897: PPUSH
24898: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
24902: LD_EXP 59
24906: PPUSH
24907: LD_INT 9
24909: PPUSH
24910: LD_INT 2
24912: PPUSH
24913: CALL_OW 111
// AddComHold ( Friend ) ;
24917: LD_EXP 59
24921: PPUSH
24922: CALL_OW 200
// end ; end ;
24926: PPOPN 1
24928: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
24929: LD_INT 9
24931: PPUSH
24932: LD_INT 2
24934: PPUSH
24935: CALL_OW 428
24939: PUSH
24940: LD_EXP 59
24944: EQUAL
24945: PUSH
24946: LD_EXP 59
24950: PPUSH
24951: CALL_OW 255
24955: PUSH
24956: LD_INT 8
24958: EQUAL
24959: AND
24960: IFFALSE 24974
24962: GO 24964
24964: DISABLE
// RemoveUnit ( Friend ) ;
24965: LD_EXP 59
24969: PPUSH
24970: CALL_OW 64
24974: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
24975: LD_EXP 14
24979: PUSH
24980: LD_INT 31500
24982: GREATEREQUAL
24983: PUSH
24984: LD_EXP 7
24988: AND
24989: PUSH
24990: LD_EXP 2
24994: AND
24995: IFFALSE 25425
24997: GO 24999
24999: DISABLE
25000: LD_INT 0
25002: PPUSH
25003: PPUSH
25004: PPUSH
// begin missionStage := 7 ;
25005: LD_ADDR_EXP 15
25009: PUSH
25010: LD_INT 7
25012: ST_TO_ADDR
// uc_side = 1 ;
25013: LD_ADDR_OWVAR 20
25017: PUSH
25018: LD_INT 1
25020: ST_TO_ADDR
// uc_nation = 1 ;
25021: LD_ADDR_OWVAR 21
25025: PUSH
25026: LD_INT 1
25028: ST_TO_ADDR
// for i = 1 to 5 do
25029: LD_ADDR_VAR 0 1
25033: PUSH
25034: DOUBLE
25035: LD_INT 1
25037: DEC
25038: ST_TO_ADDR
25039: LD_INT 5
25041: PUSH
25042: FOR_TO
25043: IFFALSE 25139
// begin vc_engine = 3 ;
25045: LD_ADDR_OWVAR 39
25049: PUSH
25050: LD_INT 3
25052: ST_TO_ADDR
// vc_control = 3 ;
25053: LD_ADDR_OWVAR 38
25057: PUSH
25058: LD_INT 3
25060: ST_TO_ADDR
// vc_chassis = 3 ;
25061: LD_ADDR_OWVAR 37
25065: PUSH
25066: LD_INT 3
25068: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25069: LD_ADDR_OWVAR 40
25073: PUSH
25074: LD_INT 5
25076: PUSH
25077: LD_INT 9
25079: PUSH
25080: LD_INT 7
25082: PUSH
25083: EMPTY
25084: LIST
25085: LIST
25086: LIST
25087: PUSH
25088: LD_INT 1
25090: PPUSH
25091: LD_INT 3
25093: PPUSH
25094: CALL_OW 12
25098: ARRAY
25099: ST_TO_ADDR
// veh = CreateVehicle ;
25100: LD_ADDR_VAR 0 2
25104: PUSH
25105: CALL_OW 45
25109: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25110: LD_VAR 0 2
25114: PPUSH
25115: LD_INT 1
25117: PPUSH
25118: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25122: LD_VAR 0 2
25126: PPUSH
25127: LD_INT 19
25129: PPUSH
25130: LD_INT 0
25132: PPUSH
25133: CALL_OW 49
// end ;
25137: GO 25042
25139: POP
25140: POP
// vc_engine = 3 ;
25141: LD_ADDR_OWVAR 39
25145: PUSH
25146: LD_INT 3
25148: ST_TO_ADDR
// vc_control = 1 ;
25149: LD_ADDR_OWVAR 38
25153: PUSH
25154: LD_INT 1
25156: ST_TO_ADDR
// vc_chassis = 3 ;
25157: LD_ADDR_OWVAR 37
25161: PUSH
25162: LD_INT 3
25164: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25165: LD_ADDR_OWVAR 40
25169: PUSH
25170: LD_INT 5
25172: PUSH
25173: LD_INT 9
25175: PUSH
25176: LD_INT 7
25178: PUSH
25179: EMPTY
25180: LIST
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 1
25186: PPUSH
25187: LD_INT 3
25189: PPUSH
25190: CALL_OW 12
25194: ARRAY
25195: ST_TO_ADDR
// vehG = CreateVehicle ;
25196: LD_ADDR_VAR 0 3
25200: PUSH
25201: CALL_OW 45
25205: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25206: LD_VAR 0 3
25210: PPUSH
25211: LD_INT 1
25213: PPUSH
25214: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25218: LD_VAR 0 3
25222: PPUSH
25223: LD_INT 19
25225: PPUSH
25226: LD_INT 0
25228: PPUSH
25229: CALL_OW 49
// if JMMGirl = 1 then
25233: LD_EXP 7
25237: PUSH
25238: LD_INT 1
25240: EQUAL
25241: IFFALSE 25297
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25243: LD_ADDR_EXP 37
25247: PUSH
25248: LD_STRING Joan
25250: PPUSH
25251: LD_INT 1
25253: PPUSH
25254: LD_STRING 14_
25256: PPUSH
25257: CALL 61665 0 3
25261: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25262: LD_EXP 37
25266: PPUSH
25267: LD_VAR 0 3
25271: PPUSH
25272: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25276: LD_VAR 0 3
25280: PPUSH
25281: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25285: LD_EXP 37
25289: PPUSH
25290: LD_STRING D10BW-Joan-1
25292: PPUSH
25293: CALL_OW 94
// end ; if JMMGirl = 2 then
25297: LD_EXP 7
25301: PUSH
25302: LD_INT 2
25304: EQUAL
25305: IFFALSE 25361
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25307: LD_ADDR_EXP 39
25311: PUSH
25312: LD_STRING Lisa
25314: PPUSH
25315: LD_INT 1
25317: PPUSH
25318: LD_STRING 14_
25320: PPUSH
25321: CALL 61665 0 3
25325: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25326: LD_EXP 39
25330: PPUSH
25331: LD_VAR 0 3
25335: PPUSH
25336: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25340: LD_VAR 0 3
25344: PPUSH
25345: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25349: LD_EXP 39
25353: PPUSH
25354: LD_STRING D10BW-Lisa-1
25356: PPUSH
25357: CALL_OW 94
// end ; if JMMGirl = 3 then
25361: LD_EXP 7
25365: PUSH
25366: LD_INT 3
25368: EQUAL
25369: IFFALSE 25425
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25371: LD_ADDR_EXP 51
25375: PUSH
25376: LD_STRING Connie
25378: PPUSH
25379: LD_INT 1
25381: PPUSH
25382: LD_STRING 14_
25384: PPUSH
25385: CALL 61665 0 3
25389: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25390: LD_EXP 51
25394: PPUSH
25395: LD_VAR 0 3
25399: PPUSH
25400: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25404: LD_VAR 0 3
25408: PPUSH
25409: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25413: LD_EXP 39
25417: PPUSH
25418: LD_STRING D10BW-Con-1
25420: PPUSH
25421: CALL_OW 94
// end ; end ;
25425: PPOPN 3
25427: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25428: LD_EXP 14
25432: PUSH
25433: LD_INT 94500
25435: GREATEREQUAL
25436: IFFALSE 25848
25438: GO 25440
25440: DISABLE
25441: LD_INT 0
25443: PPUSH
25444: PPUSH
25445: PPUSH
// begin tmp := PrepareStevensSquad ;
25446: LD_ADDR_VAR 0 3
25450: PUSH
25451: CALL 2051 0 0
25455: ST_TO_ADDR
// if not tmp then
25456: LD_VAR 0 3
25460: NOT
25461: IFFALSE 25465
// exit ;
25463: GO 25848
// uc_side := 1 ;
25465: LD_ADDR_OWVAR 20
25469: PUSH
25470: LD_INT 1
25472: ST_TO_ADDR
// uc_nation := 1 ;
25473: LD_ADDR_OWVAR 21
25477: PUSH
25478: LD_INT 1
25480: ST_TO_ADDR
// for i in tmp do
25481: LD_ADDR_VAR 0 1
25485: PUSH
25486: LD_VAR 0 3
25490: PUSH
25491: FOR_IN
25492: IFFALSE 25589
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25494: LD_INT 3
25496: PPUSH
25497: LD_INT 3
25499: PPUSH
25500: LD_INT 1
25502: PPUSH
25503: LD_INT 5
25505: PUSH
25506: LD_INT 9
25508: PUSH
25509: LD_INT 7
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: LIST
25516: PUSH
25517: LD_INT 1
25519: PPUSH
25520: LD_INT 3
25522: PPUSH
25523: CALL_OW 12
25527: ARRAY
25528: PPUSH
25529: LD_INT 40
25531: PPUSH
25532: CALL 68298 0 5
// veh := CreateVehicle ;
25536: LD_ADDR_VAR 0 2
25540: PUSH
25541: CALL_OW 45
25545: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25546: LD_VAR 0 2
25550: PPUSH
25551: LD_INT 1
25553: PPUSH
25554: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25558: LD_VAR 0 2
25562: PPUSH
25563: LD_INT 19
25565: PPUSH
25566: LD_INT 0
25568: PPUSH
25569: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25573: LD_VAR 0 1
25577: PPUSH
25578: LD_VAR 0 2
25582: PPUSH
25583: CALL_OW 52
// end ;
25587: GO 25491
25589: POP
25590: POP
// missionStage := 8 ;
25591: LD_ADDR_EXP 15
25595: PUSH
25596: LD_INT 8
25598: ST_TO_ADDR
// DialogueOn ;
25599: CALL_OW 6
// if Stevens then
25603: LD_EXP 38
25607: IFFALSE 25721
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25609: LD_EXP 38
25613: PPUSH
25614: CALL_OW 310
25618: PPUSH
25619: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25623: LD_EXP 38
25627: PPUSH
25628: LD_STRING D8-Huck-1
25630: PPUSH
25631: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25635: LD_EXP 36
25639: PPUSH
25640: LD_STRING D8-JMM-1
25642: PPUSH
25643: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25647: LD_EXP 38
25651: PPUSH
25652: LD_STRING D8-Huck-2
25654: PPUSH
25655: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25659: LD_EXP 36
25663: PPUSH
25664: LD_STRING D8-JMM-2
25666: PPUSH
25667: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25671: LD_EXP 38
25675: PPUSH
25676: LD_STRING D8-Huck-3
25678: PPUSH
25679: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25683: LD_EXP 36
25687: PPUSH
25688: LD_STRING D8-JMM-3
25690: PPUSH
25691: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25695: LD_EXP 38
25699: PPUSH
25700: LD_STRING D8-Huck-4
25702: PPUSH
25703: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25707: LD_EXP 36
25711: PPUSH
25712: LD_STRING D8-JMM-4
25714: PPUSH
25715: CALL_OW 88
// end else
25719: GO 25831
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25721: LD_EXP 52
25725: PPUSH
25726: CALL_OW 310
25730: PPUSH
25731: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
25735: LD_EXP 52
25739: PPUSH
25740: LD_STRING D8-Huck-1
25742: PPUSH
25743: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
25747: LD_EXP 36
25751: PPUSH
25752: LD_STRING D8-JMM-1a
25754: PPUSH
25755: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
25759: LD_EXP 52
25763: PPUSH
25764: LD_STRING D8-Huck-2
25766: PPUSH
25767: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25771: LD_EXP 36
25775: PPUSH
25776: LD_STRING D8-JMM-2
25778: PPUSH
25779: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
25783: LD_EXP 52
25787: PPUSH
25788: LD_STRING D8-Huck-3
25790: PPUSH
25791: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25795: LD_EXP 36
25799: PPUSH
25800: LD_STRING D8-JMM-3
25802: PPUSH
25803: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
25807: LD_EXP 52
25811: PPUSH
25812: LD_STRING D8-Huck-4
25814: PPUSH
25815: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25819: LD_EXP 36
25823: PPUSH
25824: LD_STRING D8-JMM-4
25826: PPUSH
25827: CALL_OW 88
// end ; DialogueOff ;
25831: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
25835: LD_INT 25
25837: PPUSH
25838: LD_INT 1
25840: PPUSH
25841: LD_INT 1
25843: PPUSH
25844: CALL_OW 322
// end ;
25848: PPOPN 3
25850: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
25851: LD_INT 1
25853: PPUSH
25854: LD_EXP 68
25858: PPUSH
25859: CALL_OW 292
25863: IFFALSE 26114
25865: GO 25867
25867: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
25868: LD_EXP 68
25872: PPUSH
25873: CALL_OW 87
// DialogueOn ;
25877: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
25881: LD_EXP 36
25885: PPUSH
25886: LD_STRING D10nB-JMM-1
25888: PPUSH
25889: CALL_OW 88
// if BurlakStatus = 1 then
25893: LD_EXP 9
25897: PUSH
25898: LD_INT 1
25900: EQUAL
25901: IFFALSE 25915
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
25903: LD_EXP 67
25907: PPUSH
25908: LD_STRING D10nB-Vse-1a
25910: PPUSH
25911: CALL_OW 94
// end ; if BurlakStatus = 0 then
25915: LD_EXP 9
25919: PUSH
25920: LD_INT 0
25922: EQUAL
25923: IFFALSE 25937
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
25925: LD_EXP 67
25929: PPUSH
25930: LD_STRING D10nB-Vse-1
25932: PPUSH
25933: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
25937: LD_EXP 36
25941: PPUSH
25942: LD_STRING D10nB-JMM-2
25944: PPUSH
25945: CALL_OW 88
// if KappaStatus then
25949: LD_EXP 2
25953: IFFALSE 25967
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
25955: LD_EXP 67
25959: PPUSH
25960: LD_STRING D10nB-Vse-5a
25962: PPUSH
25963: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
25967: LD_EXP 2
25971: NOT
25972: PUSH
25973: LD_EXP 6
25977: PUSH
25978: LD_INT 0
25980: EQUAL
25981: AND
25982: IFFALSE 26110
// begin if JMMGirl = 1 then
25984: LD_EXP 7
25988: PUSH
25989: LD_INT 1
25991: EQUAL
25992: IFFALSE 26042
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
25994: LD_EXP 67
25998: PPUSH
25999: LD_STRING D10nB-Vse-2
26001: PPUSH
26002: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26006: LD_EXP 36
26010: PPUSH
26011: LD_STRING D10nB-JMM-3
26013: PPUSH
26014: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26018: LD_EXP 67
26022: PPUSH
26023: LD_STRING D10nB-Vse-3
26025: PPUSH
26026: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26030: LD_EXP 36
26034: PPUSH
26035: LD_STRING D10nB-JMM-4
26037: PPUSH
26038: CALL_OW 88
// end ; if JMMGirl = 2 then
26042: LD_EXP 7
26046: PUSH
26047: LD_INT 2
26049: EQUAL
26050: IFFALSE 26076
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26052: LD_EXP 67
26056: PPUSH
26057: LD_STRING D10nB-Vse-4
26059: PPUSH
26060: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26064: LD_EXP 36
26068: PPUSH
26069: LD_STRING D10nB-JMM-5
26071: PPUSH
26072: CALL_OW 88
// end ; if JMMGirl = 3 then
26076: LD_EXP 7
26080: PUSH
26081: LD_INT 3
26083: EQUAL
26084: IFFALSE 26110
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26086: LD_EXP 67
26090: PPUSH
26091: LD_STRING D10nB-Vse-5
26093: PPUSH
26094: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26098: LD_EXP 36
26102: PPUSH
26103: LD_STRING D10nB-JMM-6
26105: PPUSH
26106: CALL_OW 88
// end ; end ; DialogueOff ;
26110: CALL_OW 7
// end ;
26114: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26115: LD_EXP 14
26119: PUSH
26120: LD_INT 115500
26122: GREATEREQUAL
26123: IFFALSE 26482
26125: GO 26127
26127: DISABLE
26128: LD_INT 0
26130: PPUSH
// begin missionStage := 10 ;
26131: LD_ADDR_EXP 15
26135: PUSH
26136: LD_INT 10
26138: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26139: LD_ADDR_VAR 0 1
26143: PUSH
26144: LD_INT 22
26146: PUSH
26147: LD_INT 1
26149: PUSH
26150: EMPTY
26151: LIST
26152: LIST
26153: PUSH
26154: LD_INT 26
26156: PUSH
26157: LD_INT 1
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: LD_INT 3
26166: PUSH
26167: LD_INT 25
26169: PUSH
26170: LD_INT 12
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: EMPTY
26178: LIST
26179: LIST
26180: PUSH
26181: LD_INT 3
26183: PUSH
26184: LD_INT 25
26186: PUSH
26187: LD_INT 16
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: LIST
26202: LIST
26203: PPUSH
26204: CALL_OW 69
26208: PUSH
26209: LD_EXP 36
26213: PUSH
26214: LD_EXP 38
26218: PUSH
26219: LD_EXP 52
26223: PUSH
26224: LD_EXP 39
26228: PUSH
26229: LD_EXP 40
26233: PUSH
26234: LD_EXP 41
26238: PUSH
26239: LD_EXP 42
26243: PUSH
26244: LD_EXP 43
26248: PUSH
26249: LD_EXP 44
26253: PUSH
26254: LD_EXP 45
26258: PUSH
26259: LD_EXP 46
26263: PUSH
26264: LD_EXP 47
26268: PUSH
26269: LD_EXP 48
26273: PUSH
26274: LD_EXP 49
26278: PUSH
26279: LD_EXP 50
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: DIFF
26301: ST_TO_ADDR
// if not tmp and Brown then
26302: LD_VAR 0 1
26306: NOT
26307: PUSH
26308: LD_EXP 44
26312: AND
26313: IFFALSE 26328
// tmp := [ Brown ] ;
26315: LD_ADDR_VAR 0 1
26319: PUSH
26320: LD_EXP 44
26324: PUSH
26325: EMPTY
26326: LIST
26327: ST_TO_ADDR
// DialogueOn ;
26328: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26332: LD_VAR 0 1
26336: PUSH
26337: LD_INT 1
26339: ARRAY
26340: PPUSH
26341: LD_STRING D11-Sol1-1
26343: PPUSH
26344: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26348: LD_EXP 61
26352: PPUSH
26353: LD_STRING D11-Pla-1
26355: PPUSH
26356: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26360: LD_EXP 62
26364: PPUSH
26365: LD_STRING D11-Kov-1
26367: PPUSH
26368: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26372: LD_EXP 61
26376: PPUSH
26377: LD_STRING D11-Pla-2
26379: PPUSH
26380: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26384: LD_VAR 0 1
26388: PUSH
26389: LD_INT 1
26391: ARRAY
26392: PPUSH
26393: LD_STRING D11-Sol1-2
26395: PPUSH
26396: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26400: LD_EXP 36
26404: PPUSH
26405: LD_STRING D11-JMM-2
26407: PPUSH
26408: CALL_OW 88
// DialogueOff ;
26412: CALL_OW 7
// allowBehemothConstruct := true ;
26416: LD_ADDR_EXP 25
26420: PUSH
26421: LD_INT 1
26423: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26424: LD_STRING M4
26426: PPUSH
26427: CALL_OW 337
// BuildBehemoths ;
26431: CALL 7481 0 0
// repeat wait ( 15 15$00 ) ;
26435: LD_INT 31500
26437: PPUSH
26438: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26442: LD_EXP 27
26446: IFFALSE 26450
// break ;
26448: GO 26482
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26450: LD_INT 267
26452: PPUSH
26453: CALL_OW 274
26457: PPUSH
26458: LD_INT 1
26460: PPUSH
26461: CALL_OW 275
26465: PUSH
26466: LD_INT 1000
26468: GREATEREQUAL
26469: IFFALSE 26475
// BuildBehemoths ;
26471: CALL 7481 0 0
// until not behemothBuilders ;
26475: LD_EXP 70
26479: NOT
26480: IFFALSE 26435
// end ;
26482: PPOPN 1
26484: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26485: LD_EXP 70
26489: NOT
26490: PUSH
26491: LD_EXP 28
26495: NOT
26496: AND
26497: PUSH
26498: LD_EXP 25
26502: AND
26503: IFFALSE 26523
26505: GO 26507
26507: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26508: LD_STRING M4a
26510: PPUSH
26511: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26515: LD_ADDR_EXP 27
26519: PUSH
26520: LD_INT 1
26522: ST_TO_ADDR
// end ;
26523: END
// every 0 0$1 trigger behemothDone do
26524: LD_EXP 28
26528: IFFALSE 26540
26530: GO 26532
26532: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26533: LD_STRING M4b
26535: PPUSH
26536: CALL_OW 337
26540: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26541: LD_EXP 29
26545: NOT
26546: IFFALSE 26742
26548: GO 26550
26550: DISABLE
26551: LD_INT 0
26553: PPUSH
26554: PPUSH
// begin enable ;
26555: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26556: LD_ADDR_VAR 0 1
26560: PUSH
26561: LD_INT 3
26563: PPUSH
26564: CALL 104029 0 1
26568: ST_TO_ADDR
// if not tmp and not behemothDone then
26569: LD_VAR 0 1
26573: NOT
26574: PUSH
26575: LD_EXP 28
26579: NOT
26580: AND
26581: IFFALSE 26617
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26583: LD_ADDR_VAR 0 1
26587: PUSH
26588: LD_INT 22
26590: PUSH
26591: LD_INT 3
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: LD_INT 30
26600: PUSH
26601: LD_INT 37
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PPUSH
26612: CALL_OW 69
26616: ST_TO_ADDR
// if not tmp then
26617: LD_VAR 0 1
26621: NOT
26622: IFFALSE 26626
// exit ;
26624: GO 26742
// for i in tmp do
26626: LD_ADDR_VAR 0 2
26630: PUSH
26631: LD_VAR 0 1
26635: PUSH
26636: FOR_IN
26637: IFFALSE 26740
// if See ( 1 , i ) then
26639: LD_INT 1
26641: PPUSH
26642: LD_VAR 0 2
26646: PPUSH
26647: CALL_OW 292
26651: IFFALSE 26738
// begin if GetType ( i ) = unit_building then
26653: LD_VAR 0 2
26657: PPUSH
26658: CALL_OW 247
26662: PUSH
26663: LD_INT 3
26665: EQUAL
26666: IFFALSE 26704
// begin CenterNowOnUnits ( i ) ;
26668: LD_VAR 0 2
26672: PPUSH
26673: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26677: LD_EXP 36
26681: PPUSH
26682: LD_STRING D17a-JMM-1
26684: PPUSH
26685: CALL_OW 88
// seeBehemoth := true ;
26689: LD_ADDR_EXP 29
26693: PUSH
26694: LD_INT 1
26696: ST_TO_ADDR
// disable ;
26697: DISABLE
// exit ;
26698: POP
26699: POP
26700: GO 26742
// end else
26702: GO 26738
// begin CenterNowOnUnits ( i ) ;
26704: LD_VAR 0 2
26708: PPUSH
26709: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26713: LD_EXP 36
26717: PPUSH
26718: LD_STRING D17b-JMM-1
26720: PPUSH
26721: CALL_OW 88
// seeBehemoth := true ;
26725: LD_ADDR_EXP 29
26729: PUSH
26730: LD_INT 1
26732: ST_TO_ADDR
// disable ;
26733: DISABLE
// exit ;
26734: POP
26735: POP
26736: GO 26742
// end ; end ;
26738: GO 26636
26740: POP
26741: POP
// end ;
26742: PPOPN 2
26744: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
26745: LD_EXP 14
26749: PUSH
26750: LD_INT 116550
26752: GREATEREQUAL
26753: IFFALSE 27929
26755: GO 26757
26757: DISABLE
26758: LD_INT 0
26760: PPUSH
26761: PPUSH
26762: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
26763: LD_INT 2
26765: PPUSH
26766: LD_INT 23
26768: PUSH
26769: LD_INT 3
26771: PUSH
26772: LD_INT 3
26774: PUSH
26775: LD_INT 48
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: PUSH
26784: EMPTY
26785: LIST
26786: PPUSH
26787: CALL 55733 0 2
// repeat wait ( 0 0$1 ) ;
26791: LD_INT 35
26793: PPUSH
26794: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
26798: LD_INT 22
26800: PUSH
26801: LD_INT 3
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 34
26810: PUSH
26811: LD_INT 48
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PPUSH
26822: CALL_OW 69
26826: IFFALSE 26791
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26828: LD_ADDR_VAR 0 1
26832: PUSH
26833: LD_INT 22
26835: PUSH
26836: LD_INT 3
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 34
26845: PUSH
26846: LD_INT 48
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PPUSH
26857: CALL_OW 69
26861: PUSH
26862: LD_INT 1
26864: ARRAY
26865: ST_TO_ADDR
// missionStage := 12 ;
26866: LD_ADDR_EXP 15
26870: PUSH
26871: LD_INT 12
26873: ST_TO_ADDR
// platonovHasBomb := true ;
26874: LD_ADDR_EXP 30
26878: PUSH
26879: LD_INT 1
26881: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
26882: LD_VAR 0 1
26886: PPUSH
26887: LD_INT 181
26889: PPUSH
26890: LD_INT 86
26892: PPUSH
26893: CALL_OW 171
// AddComHold ( bomb ) ;
26897: LD_VAR 0 1
26901: PPUSH
26902: CALL_OW 200
// wait ( 0 0$10 ) ;
26906: LD_INT 350
26908: PPUSH
26909: CALL_OW 67
// DialogueOn ;
26913: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
26917: LD_EXP 61
26921: PPUSH
26922: LD_STRING D15-Pla-1
26924: PPUSH
26925: CALL_OW 94
// dec = Query ( Q15a ) ;
26929: LD_ADDR_VAR 0 2
26933: PUSH
26934: LD_STRING Q15a
26936: PPUSH
26937: CALL_OW 97
26941: ST_TO_ADDR
// if dec = 1 then
26942: LD_VAR 0 2
26946: PUSH
26947: LD_INT 1
26949: EQUAL
26950: IFFALSE 26973
// begin Say ( JMM , D15a-JMM-1 ) ;
26952: LD_EXP 36
26956: PPUSH
26957: LD_STRING D15a-JMM-1
26959: PPUSH
26960: CALL_OW 88
// YouLost ( Surrender ) ;
26964: LD_STRING Surrender
26966: PPUSH
26967: CALL_OW 104
// exit ;
26971: GO 27929
// end ; if dec = 2 then
26973: LD_VAR 0 2
26977: PUSH
26978: LD_INT 2
26980: EQUAL
26981: IFFALSE 27050
// begin Say ( JMM , D15b-JMM-1 ) ;
26983: LD_EXP 36
26987: PPUSH
26988: LD_STRING D15b-JMM-1
26990: PPUSH
26991: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
26995: LD_EXP 61
26999: PPUSH
27000: LD_STRING D15b-Pla-1
27002: PPUSH
27003: CALL_OW 94
// DialogueOff ;
27007: CALL_OW 7
// wait ( 3 3$00 ) ;
27011: LD_INT 6300
27013: PPUSH
27014: CALL_OW 67
// DialogueOn ;
27018: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27022: LD_EXP 36
27026: PPUSH
27027: LD_STRING D15d-JMM-1a
27029: PPUSH
27030: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27034: LD_EXP 61
27038: PPUSH
27039: LD_STRING D15d-Pla-1
27041: PPUSH
27042: CALL_OW 94
// DialogueOff ;
27046: CALL_OW 7
// end ; if dec = 3 then
27050: LD_VAR 0 2
27054: PUSH
27055: LD_INT 3
27057: EQUAL
27058: IFFALSE 27112
// begin Say ( JMM , D15c-JMM-1 ) ;
27060: LD_EXP 36
27064: PPUSH
27065: LD_STRING D15c-JMM-1
27067: PPUSH
27068: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27072: LD_EXP 61
27076: PPUSH
27077: LD_STRING D15c-Pla-1
27079: PPUSH
27080: CALL_OW 94
// DialogueOff ;
27084: CALL_OW 7
// wait ( 0 0$15 ) ;
27088: LD_INT 525
27090: PPUSH
27091: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27095: LD_VAR 0 1
27099: PPUSH
27100: LD_INT 60
27102: PPUSH
27103: LD_INT 95
27105: PPUSH
27106: CALL_OW 116
// exit ;
27110: GO 27929
// end ; if dec = 4 then
27112: LD_VAR 0 2
27116: PUSH
27117: LD_INT 4
27119: EQUAL
27120: IFFALSE 27150
// begin Say ( JMM , D15d-JMM-1 ) ;
27122: LD_EXP 36
27126: PPUSH
27127: LD_STRING D15d-JMM-1
27129: PPUSH
27130: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27134: LD_EXP 61
27138: PPUSH
27139: LD_STRING D15d-Pla-1
27141: PPUSH
27142: CALL_OW 94
// DialogueOff ;
27146: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27150: LD_EXP 59
27154: PPUSH
27155: CALL_OW 302
27159: PUSH
27160: LD_EXP 59
27164: PPUSH
27165: CALL_OW 255
27169: PUSH
27170: LD_INT 1
27172: EQUAL
27173: AND
27174: PUSH
27175: LD_INT 22
27177: PUSH
27178: LD_INT 1
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PUSH
27185: LD_INT 34
27187: PUSH
27188: LD_INT 8
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PPUSH
27199: CALL_OW 69
27203: NOT
27204: AND
27205: IFFALSE 27830
// begin SetSide ( Friend , 8 ) ;
27207: LD_EXP 59
27211: PPUSH
27212: LD_INT 8
27214: PPUSH
27215: CALL_OW 235
// if IsInUnit ( Friend ) then
27219: LD_EXP 59
27223: PPUSH
27224: CALL_OW 310
27228: IFFALSE 27239
// ComExitBuilding ( Friend ) ;
27230: LD_EXP 59
27234: PPUSH
27235: CALL_OW 122
// if IsDriver ( Friend ) then
27239: LD_EXP 59
27243: PPUSH
27244: CALL 101705 0 1
27248: IFFALSE 27259
// ComExitVehicle ( Friend ) ;
27250: LD_EXP 59
27254: PPUSH
27255: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27259: LD_EXP 59
27263: PPUSH
27264: LD_INT 9
27266: PPUSH
27267: LD_INT 2
27269: PPUSH
27270: CALL_OW 171
// wait ( 0 0$05 ) ;
27274: LD_INT 175
27276: PPUSH
27277: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27281: LD_EXP 59
27285: PPUSH
27286: CALL_OW 87
// DialogueOn ;
27290: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27294: LD_EXP 36
27298: PPUSH
27299: LD_STRING D16-JMM-1
27301: PPUSH
27302: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27306: LD_EXP 59
27310: PPUSH
27311: LD_STRING D16-Friend-1
27313: PPUSH
27314: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27318: LD_EXP 36
27322: PPUSH
27323: LD_STRING D16-JMM-2
27325: PPUSH
27326: CALL_OW 88
// DialogueOff ;
27330: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27334: LD_EXP 59
27338: PPUSH
27339: LD_INT 1
27341: PPUSH
27342: CALL_OW 235
// ComHold ( Friend ) ;
27346: LD_EXP 59
27350: PPUSH
27351: CALL_OW 140
// wait ( 0 0$20 ) ;
27355: LD_INT 700
27357: PPUSH
27358: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27362: LD_EXP 59
27366: PPUSH
27367: LD_INT 9
27369: PPUSH
27370: LD_INT 2
27372: PPUSH
27373: CALL_OW 297
27377: PUSH
27378: LD_INT 30
27380: LESS
27381: IFFALSE 27450
// begin SetSide ( Friend , 8 ) ;
27383: LD_EXP 59
27387: PPUSH
27388: LD_INT 8
27390: PPUSH
27391: CALL_OW 235
// if IsInUnit ( Friend ) then
27395: LD_EXP 59
27399: PPUSH
27400: CALL_OW 310
27404: IFFALSE 27415
// ComExitBuilding ( Friend ) ;
27406: LD_EXP 59
27410: PPUSH
27411: CALL_OW 122
// if IsDriver ( Friend ) then
27415: LD_EXP 59
27419: PPUSH
27420: CALL 101705 0 1
27424: IFFALSE 27435
// ComExitVehicle ( Friend ) ;
27426: LD_EXP 59
27430: PPUSH
27431: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27435: LD_EXP 59
27439: PPUSH
27440: LD_INT 9
27442: PPUSH
27443: LD_INT 2
27445: PPUSH
27446: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27450: LD_INT 1050
27452: PPUSH
27453: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27457: LD_INT 22
27459: PUSH
27460: LD_INT 1
27462: PUSH
27463: EMPTY
27464: LIST
27465: LIST
27466: PUSH
27467: LD_INT 34
27469: PUSH
27470: LD_INT 8
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: NOT
27486: IFFALSE 27808
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27488: LD_ADDR_VAR 0 3
27492: PUSH
27493: LD_INT 22
27495: PUSH
27496: LD_INT 1
27498: PUSH
27499: EMPTY
27500: LIST
27501: LIST
27502: PUSH
27503: LD_INT 26
27505: PUSH
27506: LD_INT 1
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: PUSH
27513: LD_INT 3
27515: PUSH
27516: LD_INT 25
27518: PUSH
27519: LD_INT 12
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 25
27528: PUSH
27529: LD_INT 16
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: LIST
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: LIST
27545: PPUSH
27546: CALL_OW 69
27550: PUSH
27551: LD_EXP 36
27555: PUSH
27556: LD_EXP 38
27560: PUSH
27561: LD_EXP 52
27565: PUSH
27566: LD_EXP 39
27570: PUSH
27571: LD_EXP 40
27575: PUSH
27576: LD_EXP 41
27580: PUSH
27581: LD_EXP 42
27585: PUSH
27586: LD_EXP 43
27590: PUSH
27591: LD_EXP 44
27595: PUSH
27596: LD_EXP 45
27600: PUSH
27601: LD_EXP 46
27605: PUSH
27606: LD_EXP 47
27610: PUSH
27611: LD_EXP 48
27615: PUSH
27616: LD_EXP 49
27620: PUSH
27621: LD_EXP 50
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: LIST
27630: LIST
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: LIST
27636: LIST
27637: LIST
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: DIFF
27643: ST_TO_ADDR
// DialogueOn ;
27644: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27648: LD_EXP 61
27652: PPUSH
27653: LD_STRING D16a-Pla-1
27655: PPUSH
27656: CALL_OW 94
// if Stevens then
27660: LD_EXP 38
27664: IFFALSE 27680
// Say ( Stevens , D16a-Huck-1 ) else
27666: LD_EXP 38
27670: PPUSH
27671: LD_STRING D16a-Huck-1
27673: PPUSH
27674: CALL_OW 88
27678: GO 27722
// if Baker then
27680: LD_EXP 52
27684: IFFALSE 27700
// Say ( Baker , D16a-Huck-1 ) else
27686: LD_EXP 52
27690: PPUSH
27691: LD_STRING D16a-Huck-1
27693: PPUSH
27694: CALL_OW 88
27698: GO 27722
// if tmp then
27700: LD_VAR 0 3
27704: IFFALSE 27722
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27706: LD_VAR 0 3
27710: PUSH
27711: LD_INT 1
27713: ARRAY
27714: PPUSH
27715: LD_STRING D16a-Sol1-1
27717: PPUSH
27718: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27722: LD_EXP 59
27726: PPUSH
27727: CALL_OW 255
27731: PUSH
27732: LD_INT 8
27734: EQUAL
27735: IFFALSE 27751
// Say ( JMM , D16a-JMM-1 ) else
27737: LD_EXP 36
27741: PPUSH
27742: LD_STRING D16a-JMM-1
27744: PPUSH
27745: CALL_OW 88
27749: GO 27787
// begin Say ( JMM , D16a-JMM-1a ) ;
27751: LD_EXP 36
27755: PPUSH
27756: LD_STRING D16a-JMM-1a
27758: PPUSH
27759: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
27763: LD_EXP 59
27767: PPUSH
27768: LD_STRING D16a-Friend-1
27770: PPUSH
27771: CALL_OW 88
// SetSide ( Friend , 3 ) ;
27775: LD_EXP 59
27779: PPUSH
27780: LD_INT 3
27782: PPUSH
27783: CALL_OW 235
// end ; DialogueOff ;
27787: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
27791: LD_VAR 0 1
27795: PPUSH
27796: LD_INT 60
27798: PPUSH
27799: LD_INT 95
27801: PPUSH
27802: CALL_OW 116
// end else
27806: GO 27828
// begin DialogueOn ;
27808: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
27812: LD_EXP 61
27816: PPUSH
27817: LD_STRING D16c-Pla-
27819: PPUSH
27820: CALL_OW 94
// DialogueOff ;
27824: CALL_OW 7
// end ; end else
27828: GO 27929
// begin wait ( 3 3$00 ) ;
27830: LD_INT 6300
27832: PPUSH
27833: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27837: LD_INT 22
27839: PUSH
27840: LD_INT 1
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: LD_INT 34
27849: PUSH
27850: LD_INT 8
27852: PUSH
27853: EMPTY
27854: LIST
27855: LIST
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PPUSH
27861: CALL_OW 69
27865: NOT
27866: IFFALSE 27909
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
27868: LD_EXP 61
27872: PPUSH
27873: LD_STRING D16b-Pla-1
27875: PPUSH
27876: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
27880: LD_EXP 36
27884: PPUSH
27885: LD_STRING D16b-JMM-
27887: PPUSH
27888: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
27892: LD_VAR 0 1
27896: PPUSH
27897: LD_INT 60
27899: PPUSH
27900: LD_INT 95
27902: PPUSH
27903: CALL_OW 116
// end else
27907: GO 27929
// begin DialogueOn ;
27909: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
27913: LD_EXP 61
27917: PPUSH
27918: LD_STRING D16c-Pla-
27920: PPUSH
27921: CALL_OW 94
// DialogueOff ;
27925: CALL_OW 7
// end ; end ; end ;
27929: PPOPN 3
27931: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
27932: LD_EXP 14
27936: PUSH
27937: LD_INT 126000
27939: GREATEREQUAL
27940: PUSH
27941: LD_EXP 23
27945: NOT
27946: AND
27947: PUSH
27948: LD_EXP 71
27952: PPUSH
27953: CALL_OW 302
27957: AND
27958: IFFALSE 28316
27960: GO 27962
27962: DISABLE
27963: LD_INT 0
27965: PPUSH
// begin missionStage = 11 ;
27966: LD_ADDR_EXP 15
27970: PUSH
27971: LD_INT 11
27973: ST_TO_ADDR
// DialogueOn ;
27974: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
27978: LD_EXP 71
27982: PPUSH
27983: LD_STRING D9-Roth-1
27985: PPUSH
27986: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
27990: LD_EXP 36
27994: PPUSH
27995: LD_STRING D9-JMM-1
27997: PPUSH
27998: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28002: LD_EXP 71
28006: PPUSH
28007: LD_STRING D9-Roth-2
28009: PPUSH
28010: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28014: LD_EXP 71
28018: PPUSH
28019: LD_STRING D9-Roth-2a
28021: PPUSH
28022: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28026: LD_EXP 61
28030: PPUSH
28031: LD_STRING D9-Pla-2
28033: PPUSH
28034: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28038: LD_EXP 71
28042: PPUSH
28043: LD_STRING D9-Roth-3
28045: PPUSH
28046: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28050: LD_EXP 61
28054: PPUSH
28055: LD_STRING D9-Pla-3
28057: PPUSH
28058: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28062: LD_EXP 71
28066: PPUSH
28067: LD_STRING D9-Roth-4
28069: PPUSH
28070: CALL_OW 94
// dec = Query ( Q9 ) ;
28074: LD_ADDR_VAR 0 1
28078: PUSH
28079: LD_STRING Q9
28081: PPUSH
28082: CALL_OW 97
28086: ST_TO_ADDR
// if dec = 1 then
28087: LD_VAR 0 1
28091: PUSH
28092: LD_INT 1
28094: EQUAL
28095: IFFALSE 28109
// SayRadio ( Roth , D9a-Roth-1 ) ;
28097: LD_EXP 71
28101: PPUSH
28102: LD_STRING D9a-Roth-1
28104: PPUSH
28105: CALL_OW 94
// if dec = 2 then
28109: LD_VAR 0 1
28113: PUSH
28114: LD_INT 2
28116: EQUAL
28117: IFFALSE 28143
// begin Say ( JMM , D9b-JMM-1 ) ;
28119: LD_EXP 36
28123: PPUSH
28124: LD_STRING D9b-JMM-1
28126: PPUSH
28127: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28131: LD_EXP 71
28135: PPUSH
28136: LD_STRING D9b-Roth-1
28138: PPUSH
28139: CALL_OW 94
// end ; if dec = 3 then
28143: LD_VAR 0 1
28147: PUSH
28148: LD_INT 3
28150: EQUAL
28151: IFFALSE 28213
// begin Say ( JMM , D9c-JMM-1 ) ;
28153: LD_EXP 36
28157: PPUSH
28158: LD_STRING D9c-JMM-1
28160: PPUSH
28161: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28165: LD_EXP 71
28169: PPUSH
28170: LD_STRING D9c-Roth-1
28172: PPUSH
28173: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28177: LD_EXP 36
28181: PPUSH
28182: LD_STRING D9c-JMM-2
28184: PPUSH
28185: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28189: LD_EXP 71
28193: PPUSH
28194: LD_STRING D9c-Roth-2
28196: PPUSH
28197: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28201: LD_EXP 36
28205: PPUSH
28206: LD_STRING D9c-JMM-3
28208: PPUSH
28209: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28213: LD_EXP 71
28217: PPUSH
28218: LD_STRING D9c-Roth-3
28220: PPUSH
28221: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28225: LD_EXP 71
28229: PPUSH
28230: LD_STRING D9cont-Roth-1
28232: PPUSH
28233: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28237: LD_EXP 36
28241: PPUSH
28242: LD_STRING D9cont-JMM-1
28244: PPUSH
28245: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28249: LD_EXP 71
28253: PPUSH
28254: LD_STRING D9cont-Roth-2
28256: PPUSH
28257: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28261: LD_EXP 36
28265: PPUSH
28266: LD_STRING D9cont-JMM-2
28268: PPUSH
28269: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28273: LD_EXP 71
28277: PPUSH
28278: LD_STRING D9cont-Roth-3
28280: PPUSH
28281: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28285: LD_EXP 36
28289: PPUSH
28290: LD_STRING D9cont-JMM-3
28292: PPUSH
28293: CALL_OW 88
// DialogueOff ;
28297: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28301: LD_STRING M3
28303: PPUSH
28304: CALL_OW 337
// allianceActive := true ;
28308: LD_ADDR_EXP 31
28312: PUSH
28313: LD_INT 1
28315: ST_TO_ADDR
// end ;
28316: PPOPN 1
28318: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28319: LD_EXP 61
28323: PPUSH
28324: CALL_OW 301
28328: PUSH
28329: LD_EXP 64
28333: PPUSH
28334: CALL_OW 301
28338: AND
28339: PUSH
28340: LD_INT 22
28342: PUSH
28343: LD_INT 3
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 21
28352: PUSH
28353: LD_INT 1
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 50
28362: PUSH
28363: EMPTY
28364: LIST
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: LIST
28370: PPUSH
28371: CALL_OW 69
28375: PUSH
28376: LD_INT 7
28378: PUSH
28379: LD_INT 8
28381: PUSH
28382: LD_INT 9
28384: PUSH
28385: EMPTY
28386: LIST
28387: LIST
28388: LIST
28389: PUSH
28390: LD_OWVAR 67
28394: ARRAY
28395: LESS
28396: AND
28397: IFFALSE 29168
28399: GO 28401
28401: DISABLE
28402: LD_INT 0
28404: PPUSH
28405: PPUSH
28406: PPUSH
28407: PPUSH
// begin MC_Kill ( 1 ) ;
28408: LD_INT 1
28410: PPUSH
28411: CALL 33654 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28415: LD_INT 1
28417: PPUSH
28418: LD_INT 3
28420: PPUSH
28421: LD_INT 1
28423: PPUSH
28424: LD_INT 1
28426: PPUSH
28427: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28431: LD_ADDR_VAR 0 1
28435: PUSH
28436: LD_INT 22
28438: PUSH
28439: LD_INT 3
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: LD_INT 21
28448: PUSH
28449: LD_INT 1
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 24
28458: PUSH
28459: LD_INT 900
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: LIST
28470: PPUSH
28471: CALL_OW 69
28475: PUSH
28476: FOR_IN
28477: IFFALSE 28508
// if GetSex ( i ) = sex_male then
28479: LD_VAR 0 1
28483: PPUSH
28484: CALL_OW 258
28488: PUSH
28489: LD_INT 1
28491: EQUAL
28492: IFFALSE 28506
// begin tmp = i ;
28494: LD_ADDR_VAR 0 2
28498: PUSH
28499: LD_VAR 0 1
28503: ST_TO_ADDR
// break ;
28504: GO 28508
// end ;
28506: GO 28476
28508: POP
28509: POP
// if tmp = 0 then
28510: LD_VAR 0 2
28514: PUSH
28515: LD_INT 0
28517: EQUAL
28518: IFFALSE 28572
// begin uc_side = 3 ;
28520: LD_ADDR_OWVAR 20
28524: PUSH
28525: LD_INT 3
28527: ST_TO_ADDR
// uc_nation = 3 ;
28528: LD_ADDR_OWVAR 21
28532: PUSH
28533: LD_INT 3
28535: ST_TO_ADDR
// hc_name =  ;
28536: LD_ADDR_OWVAR 26
28540: PUSH
28541: LD_STRING 
28543: ST_TO_ADDR
// hc_gallery =  ;
28544: LD_ADDR_OWVAR 33
28548: PUSH
28549: LD_STRING 
28551: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28552: LD_INT 1
28554: PPUSH
28555: LD_INT 10
28557: PPUSH
28558: CALL_OW 381
// tmp = CreateHuman ;
28562: LD_ADDR_VAR 0 2
28566: PUSH
28567: CALL_OW 44
28571: ST_TO_ADDR
// end ; DialogueOn ;
28572: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28576: LD_VAR 0 2
28580: PPUSH
28581: LD_STRING DSurrenderRussians-RSol1-1a
28583: PPUSH
28584: CALL_OW 88
// DialogueOff ;
28588: CALL_OW 7
// russianDestroyed := true ;
28592: LD_ADDR_EXP 21
28596: PUSH
28597: LD_INT 1
28599: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28600: LD_INT 22
28602: PUSH
28603: LD_INT 3
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 21
28612: PUSH
28613: LD_INT 1
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PPUSH
28624: CALL_OW 69
28628: PPUSH
28629: CALL_OW 122
// wait ( 0 0$1 ) ;
28633: LD_INT 35
28635: PPUSH
28636: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28640: LD_INT 22
28642: PUSH
28643: LD_INT 3
28645: PUSH
28646: EMPTY
28647: LIST
28648: LIST
28649: PUSH
28650: LD_INT 21
28652: PUSH
28653: LD_INT 1
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: EMPTY
28661: LIST
28662: LIST
28663: PPUSH
28664: CALL_OW 69
28668: PPUSH
28669: LD_INT 25
28671: PPUSH
28672: CALL_OW 173
// wait ( 0 0$10 ) ;
28676: LD_INT 350
28678: PPUSH
28679: CALL_OW 67
// PrepareOmarInvasion ;
28683: CALL 13588 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28687: LD_ADDR_VAR 0 2
28691: PUSH
28692: LD_EXP 89
28696: PPUSH
28697: CALL_OW 250
28701: PUSH
28702: LD_EXP 89
28706: PPUSH
28707: CALL_OW 251
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28716: LD_VAR 0 2
28720: PUSH
28721: LD_INT 1
28723: ARRAY
28724: PPUSH
28725: LD_VAR 0 2
28729: PUSH
28730: LD_INT 2
28732: ARRAY
28733: PPUSH
28734: LD_INT 1
28736: PPUSH
28737: LD_INT 8
28739: NEG
28740: PPUSH
28741: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
28745: LD_EXP 89
28749: PPUSH
28750: CALL_OW 87
// DialogueOn ;
28754: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
28758: LD_EXP 36
28762: PPUSH
28763: LD_STRING D19-JMM-1
28765: PPUSH
28766: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
28770: LD_ADDR_VAR 0 3
28774: PUSH
28775: LD_INT 22
28777: PUSH
28778: LD_INT 1
28780: PUSH
28781: EMPTY
28782: LIST
28783: LIST
28784: PUSH
28785: LD_INT 26
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 2
28797: PUSH
28798: LD_INT 25
28800: PUSH
28801: LD_INT 1
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 25
28810: PUSH
28811: LD_INT 2
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: LD_INT 25
28820: PUSH
28821: LD_INT 3
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 25
28830: PUSH
28831: LD_INT 4
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: LD_INT 25
28840: PUSH
28841: LD_INT 5
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PUSH
28848: LD_INT 25
28850: PUSH
28851: LD_INT 8
28853: PUSH
28854: EMPTY
28855: LIST
28856: LIST
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: LIST
28871: PPUSH
28872: CALL_OW 69
28876: PUSH
28877: LD_EXP 36
28881: PUSH
28882: LD_EXP 37
28886: PUSH
28887: LD_EXP 38
28891: PUSH
28892: LD_EXP 39
28896: PUSH
28897: LD_EXP 40
28901: PUSH
28902: LD_EXP 41
28906: PUSH
28907: LD_EXP 42
28911: PUSH
28912: LD_EXP 43
28916: PUSH
28917: LD_EXP 44
28921: PUSH
28922: LD_EXP 45
28926: PUSH
28927: LD_EXP 46
28931: PUSH
28932: LD_EXP 47
28936: PUSH
28937: LD_EXP 48
28941: PUSH
28942: LD_EXP 49
28946: PUSH
28947: LD_EXP 50
28951: PUSH
28952: LD_EXP 51
28956: PUSH
28957: LD_EXP 52
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: DIFF
28981: ST_TO_ADDR
// if tmp2 then
28982: LD_VAR 0 3
28986: IFFALSE 29004
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
28988: LD_VAR 0 3
28992: PUSH
28993: LD_INT 1
28995: ARRAY
28996: PPUSH
28997: LD_STRING D19-Sol1-1
28999: PPUSH
29000: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29004: LD_EXP 36
29008: PPUSH
29009: LD_STRING D19-JMM-2
29011: PPUSH
29012: CALL_OW 88
// DialogueOff ;
29016: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29020: LD_VAR 0 2
29024: PUSH
29025: LD_INT 1
29027: ARRAY
29028: PPUSH
29029: LD_VAR 0 2
29033: PUSH
29034: LD_INT 2
29036: ARRAY
29037: PPUSH
29038: LD_INT 1
29040: PPUSH
29041: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29045: LD_STRING M5
29047: PPUSH
29048: CALL_OW 337
// omarOnMotherLode := false ;
29052: LD_ADDR_VAR 0 4
29056: PUSH
29057: LD_INT 0
29059: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29060: LD_INT 35
29062: PPUSH
29063: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29067: LD_EXP 89
29071: PPUSH
29072: LD_INT 215
29074: PPUSH
29075: LD_INT 100
29077: PPUSH
29078: CALL_OW 297
29082: PUSH
29083: LD_INT 10
29085: LESS
29086: PUSH
29087: LD_VAR 0 4
29091: NOT
29092: AND
29093: IFFALSE 29127
// begin omarOnMotherLode := true ;
29095: LD_ADDR_VAR 0 4
29099: PUSH
29100: LD_INT 1
29102: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29103: LD_EXP 36
29107: PPUSH
29108: LD_STRING D19b-JMM-1
29110: PPUSH
29111: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29115: LD_EXP 89
29119: PPUSH
29120: LD_STRING DOmarContam-Omar-1
29122: PPUSH
29123: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29127: LD_EXP 89
29131: PPUSH
29132: CALL_OW 301
29136: IFFALSE 29060
// Say ( JMM , D19a-JMM-1 ) ;
29138: LD_EXP 36
29142: PPUSH
29143: LD_STRING D19a-JMM-1
29145: PPUSH
29146: CALL_OW 88
// if Heike then
29150: LD_EXP 90
29154: IFFALSE 29168
// Say ( Heike , D19a-Hke-1 ) ;
29156: LD_EXP 90
29160: PPUSH
29161: LD_STRING D19a-Hke-1
29163: PPUSH
29164: CALL_OW 88
// end ;
29168: PPOPN 4
29170: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29171: LD_INT 22
29173: PUSH
29174: LD_INT 3
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 21
29183: PUSH
29184: LD_INT 1
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PPUSH
29195: CALL_OW 69
29199: PUSH
29200: LD_EXP 21
29204: AND
29205: IFFALSE 29273
29207: GO 29209
29209: DISABLE
29210: LD_INT 0
29212: PPUSH
29213: PPUSH
// begin enable ;
29214: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29215: LD_ADDR_VAR 0 2
29219: PUSH
29220: LD_INT 25
29222: PPUSH
29223: LD_INT 22
29225: PUSH
29226: LD_INT 3
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PPUSH
29233: CALL_OW 70
29237: ST_TO_ADDR
// if not tmp then
29238: LD_VAR 0 2
29242: NOT
29243: IFFALSE 29247
// exit ;
29245: GO 29273
// for i in tmp do
29247: LD_ADDR_VAR 0 1
29251: PUSH
29252: LD_VAR 0 2
29256: PUSH
29257: FOR_IN
29258: IFFALSE 29271
// RemoveUnit ( i ) ;
29260: LD_VAR 0 1
29264: PPUSH
29265: CALL_OW 64
29269: GO 29257
29271: POP
29272: POP
// end ;
29273: PPOPN 2
29275: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29276: LD_INT 22
29278: PUSH
29279: LD_INT 7
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 21
29288: PUSH
29289: LD_INT 1
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PPUSH
29300: CALL_OW 69
29304: PUSH
29305: LD_INT 6
29307: LESS
29308: IFFALSE 29759
29310: GO 29312
29312: DISABLE
29313: LD_INT 0
29315: PPUSH
29316: PPUSH
// begin MC_Kill ( 1 ) ;
29317: LD_INT 1
29319: PPUSH
29320: CALL 33654 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29324: LD_INT 7
29326: PPUSH
29327: LD_INT 1
29329: PPUSH
29330: LD_INT 1
29332: PPUSH
29333: LD_INT 1
29335: PPUSH
29336: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29340: LD_ADDR_VAR 0 1
29344: PUSH
29345: LD_INT 22
29347: PUSH
29348: LD_INT 7
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 26
29357: PUSH
29358: LD_INT 1
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PPUSH
29369: CALL_OW 69
29373: PUSH
29374: LD_EXP 71
29378: DIFF
29379: ST_TO_ADDR
// if tmp then
29380: LD_VAR 0 1
29384: IFFALSE 29402
// tmp := tmp [ 1 ] else
29386: LD_ADDR_VAR 0 1
29390: PUSH
29391: LD_VAR 0 1
29395: PUSH
29396: LD_INT 1
29398: ARRAY
29399: ST_TO_ADDR
29400: GO 29438
// begin uc_side := 7 ;
29402: LD_ADDR_OWVAR 20
29406: PUSH
29407: LD_INT 7
29409: ST_TO_ADDR
// uc_nation := 1 ;
29410: LD_ADDR_OWVAR 21
29414: PUSH
29415: LD_INT 1
29417: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29418: LD_INT 1
29420: PPUSH
29421: LD_INT 8
29423: PPUSH
29424: CALL_OW 384
// tmp := CreateHuman ;
29428: LD_ADDR_VAR 0 1
29432: PUSH
29433: CALL_OW 44
29437: ST_TO_ADDR
// end ; DialogueOn ;
29438: CALL_OW 6
// if IsOK ( Roth ) then
29442: LD_EXP 71
29446: PPUSH
29447: CALL_OW 302
29451: IFFALSE 29465
// Say ( JMM , DAb-JMM-1 ) ;
29453: LD_EXP 36
29457: PPUSH
29458: LD_STRING DAb-JMM-1
29460: PPUSH
29461: CALL_OW 88
// if IsOK ( Roth ) then
29465: LD_EXP 71
29469: PPUSH
29470: CALL_OW 302
29474: IFFALSE 29498
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29476: LD_EXP 71
29480: PPUSH
29481: LD_STRING DSurrenderAlliance-Roth-1
29483: PPUSH
29484: CALL_OW 88
// RothCaptured := true ;
29488: LD_ADDR_EXP 33
29492: PUSH
29493: LD_INT 1
29495: ST_TO_ADDR
// end else
29496: GO 29510
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29498: LD_VAR 0 1
29502: PPUSH
29503: LD_STRING DSurrenderAlliance-Sci1-1
29505: PPUSH
29506: CALL_OW 88
// DialogueOff ;
29510: CALL_OW 7
// allianceDestroyed := true ;
29514: LD_ADDR_EXP 23
29518: PUSH
29519: LD_INT 1
29521: ST_TO_ADDR
// if trueAmericans then
29522: LD_EXP 35
29526: IFFALSE 29602
// begin if trueAmericans = 1 then
29528: LD_EXP 35
29532: PUSH
29533: LD_INT 1
29535: EQUAL
29536: IFFALSE 29552
// Say ( JMM , DAb-JMM-1a ) else
29538: LD_EXP 36
29542: PPUSH
29543: LD_STRING DAb-JMM-1a
29545: PPUSH
29546: CALL_OW 88
29550: GO 29564
// Say ( JMM , DAb-JMM-1b ) ;
29552: LD_EXP 36
29556: PPUSH
29557: LD_STRING DAb-JMM-1b
29559: PPUSH
29560: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29564: LD_EXP 35
29568: PPUSH
29569: CALL_OW 87
// for i in trueAmericans do
29573: LD_ADDR_VAR 0 2
29577: PUSH
29578: LD_EXP 35
29582: PUSH
29583: FOR_IN
29584: IFFALSE 29600
// SetSide ( i , 1 ) ;
29586: LD_VAR 0 2
29590: PPUSH
29591: LD_INT 1
29593: PPUSH
29594: CALL_OW 235
29598: GO 29583
29600: POP
29601: POP
// end ; repeat wait ( 0 0$1 ) ;
29602: LD_INT 35
29604: PPUSH
29605: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29609: LD_ADDR_VAR 0 2
29613: PUSH
29614: LD_INT 22
29616: PUSH
29617: LD_INT 7
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 21
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PPUSH
29638: CALL_OW 69
29642: PUSH
29643: FOR_IN
29644: IFFALSE 29726
// begin if IsInUnit ( i ) then
29646: LD_VAR 0 2
29650: PPUSH
29651: CALL_OW 310
29655: IFFALSE 29666
// ComExitBuilding ( i ) ;
29657: LD_VAR 0 2
29661: PPUSH
29662: CALL_OW 122
// if IsDriver ( i ) then
29666: LD_VAR 0 2
29670: PPUSH
29671: CALL 101705 0 1
29675: IFFALSE 29686
// ComExitVehicle ( i ) ;
29677: LD_VAR 0 2
29681: PPUSH
29682: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29686: LD_VAR 0 2
29690: PPUSH
29691: LD_INT 26
29693: PPUSH
29694: CALL_OW 308
29698: NOT
29699: IFFALSE 29715
// AddComMoveToArea ( i , allianceEscapeArea ) else
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 26
29708: PPUSH
29709: CALL_OW 173
29713: GO 29724
// RemoveUnit ( i ) ;
29715: LD_VAR 0 2
29719: PPUSH
29720: CALL_OW 64
// end ;
29724: GO 29643
29726: POP
29727: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29728: LD_INT 22
29730: PUSH
29731: LD_INT 7
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 21
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PPUSH
29752: CALL_OW 69
29756: NOT
29757: IFFALSE 29602
// end ;
29759: PPOPN 2
29761: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
29762: LD_INT 0
29764: PPUSH
29765: PPUSH
// if not unit then
29766: LD_VAR 0 1
29770: NOT
29771: IFFALSE 29775
// exit ;
29773: GO 31273
// DoNotAttack ( 7 , unit ) ;
29775: LD_INT 7
29777: PPUSH
29778: LD_VAR 0 1
29782: PPUSH
29783: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
29787: LD_VAR 0 1
29791: PPUSH
29792: LD_INT 260
29794: PPUSH
29795: LD_INT 235
29797: PPUSH
29798: LD_INT 3
29800: PPUSH
29801: LD_INT 1
29803: PPUSH
29804: CALL_OW 483
// SetSide ( unit , 4 ) ;
29808: LD_VAR 0 1
29812: PPUSH
29813: LD_INT 4
29815: PPUSH
29816: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
29820: LD_ADDR_EXP 34
29824: PUSH
29825: LD_EXP 34
29829: PUSH
29830: LD_INT 1
29832: PLUS
29833: ST_TO_ADDR
// wait ( 0 0$2 ) ;
29834: LD_INT 70
29836: PPUSH
29837: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
29841: LD_INT 260
29843: PPUSH
29844: LD_INT 235
29846: PPUSH
29847: LD_INT 1
29849: PPUSH
29850: LD_INT 8
29852: NEG
29853: PPUSH
29854: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
29858: LD_VAR 0 1
29862: PPUSH
29863: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
29867: LD_VAR 0 1
29871: PPUSH
29872: LD_EXP 71
29876: PPUSH
29877: CALL_OW 119
// DialogueOn ;
29881: CALL_OW 6
// case unit of JMM :
29885: LD_VAR 0 1
29889: PUSH
29890: LD_EXP 36
29894: DOUBLE
29895: EQUAL
29896: IFTRUE 29900
29898: GO 29915
29900: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
29901: LD_EXP 36
29905: PPUSH
29906: LD_STRING DA1-JMM-1
29908: PPUSH
29909: CALL_OW 91
29913: GO 30357
29915: LD_EXP 37
29919: DOUBLE
29920: EQUAL
29921: IFTRUE 29925
29923: GO 29940
29925: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
29926: LD_EXP 37
29930: PPUSH
29931: LD_STRING DA1-Joan-1
29933: PPUSH
29934: CALL_OW 91
29938: GO 30357
29940: LD_EXP 39
29944: DOUBLE
29945: EQUAL
29946: IFTRUE 29950
29948: GO 29965
29950: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
29951: LD_EXP 39
29955: PPUSH
29956: LD_STRING DA1-Lisa-1
29958: PPUSH
29959: CALL_OW 91
29963: GO 30357
29965: LD_EXP 40
29969: DOUBLE
29970: EQUAL
29971: IFTRUE 29975
29973: GO 29990
29975: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
29976: LD_EXP 40
29980: PPUSH
29981: LD_STRING DA1-Don-1
29983: PPUSH
29984: CALL_OW 91
29988: GO 30357
29990: LD_EXP 47
29994: DOUBLE
29995: EQUAL
29996: IFTRUE 30000
29998: GO 30015
30000: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30001: LD_EXP 47
30005: PPUSH
30006: LD_STRING DA1-Corn-1
30008: PPUSH
30009: CALL_OW 91
30013: GO 30357
30015: LD_EXP 43
30019: DOUBLE
30020: EQUAL
30021: IFTRUE 30025
30023: GO 30040
30025: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30026: LD_EXP 43
30030: PPUSH
30031: LD_STRING DA1-Den-1
30033: PPUSH
30034: CALL_OW 91
30038: GO 30357
30040: LD_EXP 41
30044: DOUBLE
30045: EQUAL
30046: IFTRUE 30050
30048: GO 30065
30050: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30051: LD_EXP 41
30055: PPUSH
30056: LD_STRING DA1-Bobby-1
30058: PPUSH
30059: CALL_OW 91
30063: GO 30357
30065: LD_EXP 45
30069: DOUBLE
30070: EQUAL
30071: IFTRUE 30075
30073: GO 30090
30075: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30076: LD_EXP 45
30080: PPUSH
30081: LD_STRING DA1-Glad-1
30083: PPUSH
30084: CALL_OW 91
30088: GO 30357
30090: LD_EXP 42
30094: DOUBLE
30095: EQUAL
30096: IFTRUE 30100
30098: GO 30115
30100: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30101: LD_EXP 42
30105: PPUSH
30106: LD_STRING DA1-Cyrus-1
30108: PPUSH
30109: CALL_OW 91
30113: GO 30357
30115: LD_EXP 38
30119: DOUBLE
30120: EQUAL
30121: IFTRUE 30125
30123: GO 30140
30125: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30126: LD_EXP 38
30130: PPUSH
30131: LD_STRING DA1-Huck-1
30133: PPUSH
30134: CALL_OW 91
30138: GO 30357
30140: LD_EXP 52
30144: DOUBLE
30145: EQUAL
30146: IFTRUE 30150
30148: GO 30165
30150: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30151: LD_EXP 52
30155: PPUSH
30156: LD_STRING DA1-Huck-1
30158: PPUSH
30159: CALL_OW 91
30163: GO 30357
30165: LD_EXP 44
30169: DOUBLE
30170: EQUAL
30171: IFTRUE 30175
30173: GO 30190
30175: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30176: LD_EXP 44
30180: PPUSH
30181: LD_STRING DA1-Brown-1
30183: PPUSH
30184: CALL_OW 91
30188: GO 30357
30190: LD_EXP 48
30194: DOUBLE
30195: EQUAL
30196: IFTRUE 30200
30198: GO 30215
30200: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30201: LD_EXP 48
30205: PPUSH
30206: LD_STRING DA1-Gary-1
30208: PPUSH
30209: CALL_OW 91
30213: GO 30357
30215: LD_EXP 51
30219: DOUBLE
30220: EQUAL
30221: IFTRUE 30225
30223: GO 30240
30225: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30226: LD_EXP 51
30230: PPUSH
30231: LD_STRING DA1-Con-1
30233: PPUSH
30234: CALL_OW 91
30238: GO 30357
30240: LD_EXP 57
30244: DOUBLE
30245: EQUAL
30246: IFTRUE 30250
30248: GO 30265
30250: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30251: LD_EXP 57
30255: PPUSH
30256: LD_STRING DA1-Kurt-1
30258: PPUSH
30259: CALL_OW 91
30263: GO 30357
30265: LD_EXP 50
30269: DOUBLE
30270: EQUAL
30271: IFTRUE 30275
30273: GO 30290
30275: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30276: LD_EXP 50
30280: PPUSH
30281: LD_STRING DA1-Yam-1
30283: PPUSH
30284: CALL_OW 91
30288: GO 30357
30290: LD_EXP 49
30294: DOUBLE
30295: EQUAL
30296: IFTRUE 30300
30298: GO 30315
30300: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30301: LD_EXP 49
30305: PPUSH
30306: LD_STRING DA1-Frank-1
30308: PPUSH
30309: CALL_OW 91
30313: GO 30357
30315: POP
// begin if GetSex ( unit ) = sex_male then
30316: LD_VAR 0 1
30320: PPUSH
30321: CALL_OW 258
30325: PUSH
30326: LD_INT 1
30328: EQUAL
30329: IFFALSE 30345
// ForceSay ( unit , DA1-Sol1-1 ) else
30331: LD_VAR 0 1
30335: PPUSH
30336: LD_STRING DA1-Sol1-1
30338: PPUSH
30339: CALL_OW 91
30343: GO 30357
// ForceSay ( unit , DA1-FSol1-1 ) ;
30345: LD_VAR 0 1
30349: PPUSH
30350: LD_STRING DA1-FSol1-1
30352: PPUSH
30353: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30357: LD_EXP 71
30361: PPUSH
30362: LD_STRING DA-Roth-1
30364: PPUSH
30365: CALL_OW 88
// if capturedUnit = 1 then
30369: LD_EXP 34
30373: PUSH
30374: LD_INT 1
30376: EQUAL
30377: IFFALSE 30405
// begin Say ( Simms , DA-Sim-1 ) ;
30379: LD_EXP 72
30383: PPUSH
30384: LD_STRING DA-Sim-1
30386: PPUSH
30387: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30391: LD_EXP 71
30395: PPUSH
30396: LD_STRING DA-Roth-2
30398: PPUSH
30399: CALL_OW 88
// end else
30403: GO 30417
// Say ( Simms , DA-Sim-2 ) ;
30405: LD_EXP 72
30409: PPUSH
30410: LD_STRING DA-Sim-2
30412: PPUSH
30413: CALL_OW 88
// case unit of JMM :
30417: LD_VAR 0 1
30421: PUSH
30422: LD_EXP 36
30426: DOUBLE
30427: EQUAL
30428: IFTRUE 30432
30430: GO 30447
30432: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30433: LD_EXP 36
30437: PPUSH
30438: LD_STRING DA1-JMM-1a
30440: PPUSH
30441: CALL_OW 91
30445: GO 30954
30447: LD_EXP 37
30451: DOUBLE
30452: EQUAL
30453: IFTRUE 30457
30455: GO 30472
30457: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30458: LD_EXP 37
30462: PPUSH
30463: LD_STRING DA1-Joan-1a
30465: PPUSH
30466: CALL_OW 91
30470: GO 30954
30472: LD_EXP 39
30476: DOUBLE
30477: EQUAL
30478: IFTRUE 30482
30480: GO 30497
30482: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30483: LD_EXP 39
30487: PPUSH
30488: LD_STRING DA1-Lisa-1a
30490: PPUSH
30491: CALL_OW 91
30495: GO 30954
30497: LD_EXP 40
30501: DOUBLE
30502: EQUAL
30503: IFTRUE 30507
30505: GO 30522
30507: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30508: LD_EXP 40
30512: PPUSH
30513: LD_STRING DA1-Don-1a
30515: PPUSH
30516: CALL_OW 91
30520: GO 30954
30522: LD_EXP 47
30526: DOUBLE
30527: EQUAL
30528: IFTRUE 30532
30530: GO 30547
30532: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30533: LD_EXP 47
30537: PPUSH
30538: LD_STRING DA1-Corn-1a
30540: PPUSH
30541: CALL_OW 91
30545: GO 30954
30547: LD_EXP 43
30551: DOUBLE
30552: EQUAL
30553: IFTRUE 30557
30555: GO 30572
30557: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30558: LD_EXP 43
30562: PPUSH
30563: LD_STRING DA1-Den-1a
30565: PPUSH
30566: CALL_OW 91
30570: GO 30954
30572: LD_EXP 41
30576: DOUBLE
30577: EQUAL
30578: IFTRUE 30582
30580: GO 30597
30582: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30583: LD_EXP 41
30587: PPUSH
30588: LD_STRING DA1-Bobby-1a
30590: PPUSH
30591: CALL_OW 91
30595: GO 30954
30597: LD_EXP 45
30601: DOUBLE
30602: EQUAL
30603: IFTRUE 30607
30605: GO 30622
30607: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30608: LD_EXP 45
30612: PPUSH
30613: LD_STRING DA1-Glad-1a
30615: PPUSH
30616: CALL_OW 91
30620: GO 30954
30622: LD_EXP 42
30626: DOUBLE
30627: EQUAL
30628: IFTRUE 30632
30630: GO 30647
30632: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30633: LD_EXP 42
30637: PPUSH
30638: LD_STRING DA1-Cyrus-1a
30640: PPUSH
30641: CALL_OW 91
30645: GO 30954
30647: LD_EXP 38
30651: DOUBLE
30652: EQUAL
30653: IFTRUE 30657
30655: GO 30672
30657: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30658: LD_EXP 38
30662: PPUSH
30663: LD_STRING DA1-Huck-1a
30665: PPUSH
30666: CALL_OW 91
30670: GO 30954
30672: LD_EXP 52
30676: DOUBLE
30677: EQUAL
30678: IFTRUE 30682
30680: GO 30697
30682: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30683: LD_EXP 52
30687: PPUSH
30688: LD_STRING DA1-Huck-1a
30690: PPUSH
30691: CALL_OW 91
30695: GO 30954
30697: LD_EXP 44
30701: DOUBLE
30702: EQUAL
30703: IFTRUE 30707
30705: GO 30722
30707: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30708: LD_EXP 44
30712: PPUSH
30713: LD_STRING DA1-Brown-1a
30715: PPUSH
30716: CALL_OW 91
30720: GO 30954
30722: LD_EXP 48
30726: DOUBLE
30727: EQUAL
30728: IFTRUE 30732
30730: GO 30747
30732: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
30733: LD_EXP 48
30737: PPUSH
30738: LD_STRING DA1-Gary-1a
30740: PPUSH
30741: CALL_OW 91
30745: GO 30954
30747: LD_EXP 51
30751: DOUBLE
30752: EQUAL
30753: IFTRUE 30757
30755: GO 30772
30757: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
30758: LD_EXP 51
30762: PPUSH
30763: LD_STRING DA1-Con-1a
30765: PPUSH
30766: CALL_OW 91
30770: GO 30954
30772: LD_EXP 57
30776: DOUBLE
30777: EQUAL
30778: IFTRUE 30782
30780: GO 30797
30782: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
30783: LD_EXP 57
30787: PPUSH
30788: LD_STRING DA1-Kurt-1a
30790: PPUSH
30791: CALL_OW 91
30795: GO 30954
30797: LD_EXP 50
30801: DOUBLE
30802: EQUAL
30803: IFTRUE 30807
30805: GO 30822
30807: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
30808: LD_EXP 50
30812: PPUSH
30813: LD_STRING DA1-Yam-1a
30815: PPUSH
30816: CALL_OW 91
30820: GO 30954
30822: LD_EXP 49
30826: DOUBLE
30827: EQUAL
30828: IFTRUE 30832
30830: GO 30847
30832: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
30833: LD_EXP 49
30837: PPUSH
30838: LD_STRING DA1-Frank-1a
30840: PPUSH
30841: CALL_OW 91
30845: GO 30954
30847: POP
// begin join := rand ( 0 , 1 ) ;
30848: LD_ADDR_VAR 0 3
30852: PUSH
30853: LD_INT 0
30855: PPUSH
30856: LD_INT 1
30858: PPUSH
30859: CALL_OW 12
30863: ST_TO_ADDR
// if join then
30864: LD_VAR 0 3
30868: IFFALSE 30913
// begin if GetSex ( unit ) = sex_male then
30870: LD_VAR 0 1
30874: PPUSH
30875: CALL_OW 258
30879: PUSH
30880: LD_INT 1
30882: EQUAL
30883: IFFALSE 30899
// ForceSay ( unit , DA1-Sol1-1b ) else
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DA1-Sol1-1b
30892: PPUSH
30893: CALL_OW 91
30897: GO 30911
// ForceSay ( unit , DA1-FSol1-1b ) ;
30899: LD_VAR 0 1
30903: PPUSH
30904: LD_STRING DA1-FSol1-1b
30906: PPUSH
30907: CALL_OW 91
// end else
30911: GO 30954
// begin if GetSex ( unit ) = sex_male then
30913: LD_VAR 0 1
30917: PPUSH
30918: CALL_OW 258
30922: PUSH
30923: LD_INT 1
30925: EQUAL
30926: IFFALSE 30942
// ForceSay ( unit , DA1-Sol1-1a ) else
30928: LD_VAR 0 1
30932: PPUSH
30933: LD_STRING DA1-Sol1-1a
30935: PPUSH
30936: CALL_OW 91
30940: GO 30954
// ForceSay ( unit , DA1-FSol1-1a ) ;
30942: LD_VAR 0 1
30946: PPUSH
30947: LD_STRING DA1-FSol1-1a
30949: PPUSH
30950: CALL_OW 91
// end ; end ; end ; if unit = JMM then
30954: LD_VAR 0 1
30958: PUSH
30959: LD_EXP 36
30963: EQUAL
30964: IFFALSE 30975
// begin YouLost ( JMMCaptured ) ;
30966: LD_STRING JMMCaptured
30968: PPUSH
30969: CALL_OW 104
// exit ;
30973: GO 31273
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
30975: LD_VAR 0 1
30979: PUSH
30980: LD_EXP 40
30984: PUSH
30985: LD_EXP 43
30989: PUSH
30990: LD_EXP 41
30994: PUSH
30995: LD_EXP 38
30999: PUSH
31000: LD_EXP 52
31004: PUSH
31005: LD_EXP 44
31009: PUSH
31010: LD_EXP 50
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: IN
31024: PUSH
31025: LD_VAR 0 3
31029: OR
31030: IFFALSE 31129
// begin Say ( Roth , DA-Roth-3 ) ;
31032: LD_EXP 71
31036: PPUSH
31037: LD_STRING DA-Roth-3
31039: PPUSH
31040: CALL_OW 88
// SetSide ( unit , 7 ) ;
31044: LD_VAR 0 1
31048: PPUSH
31049: LD_INT 7
31051: PPUSH
31052: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31056: LD_ADDR_EXP 99
31060: PUSH
31061: LD_EXP 99
31065: PPUSH
31066: LD_INT 1
31068: PPUSH
31069: LD_EXP 99
31073: PUSH
31074: LD_INT 1
31076: ARRAY
31077: PUSH
31078: LD_VAR 0 1
31082: ADD
31083: PPUSH
31084: CALL_OW 1
31088: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31089: LD_INT 260
31091: PPUSH
31092: LD_INT 235
31094: PPUSH
31095: LD_INT 1
31097: PPUSH
31098: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31102: LD_VAR 0 1
31106: PPUSH
31107: LD_INT 1000
31109: PPUSH
31110: CALL_OW 234
// DialogueOff ;
31114: CALL_OW 7
// ComFree ( unit ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL_OW 139
// end else
31127: GO 31210
// begin Say ( Roth , DA-Roth-3a ) ;
31129: LD_EXP 71
31133: PPUSH
31134: LD_STRING DA-Roth-3a
31136: PPUSH
31137: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31141: LD_ADDR_EXP 35
31145: PUSH
31146: LD_EXP 35
31150: PUSH
31151: LD_VAR 0 1
31155: ADD
31156: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31157: LD_INT 260
31159: PPUSH
31160: LD_INT 235
31162: PPUSH
31163: LD_INT 1
31165: PPUSH
31166: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31170: LD_VAR 0 1
31174: PPUSH
31175: LD_INT 1000
31177: PPUSH
31178: CALL_OW 234
// DialogueOff ;
31182: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31186: LD_VAR 0 1
31190: PPUSH
31191: LD_INT 272
31193: PPUSH
31194: LD_INT 254
31196: PPUSH
31197: CALL_OW 111
// AddComHold ( unit ) ;
31201: LD_VAR 0 1
31205: PPUSH
31206: CALL_OW 200
// end ; if capturedUnit = 1 then
31210: LD_EXP 34
31214: PUSH
31215: LD_INT 1
31217: EQUAL
31218: IFFALSE 31273
// begin DialogueOn ;
31220: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31224: LD_EXP 36
31228: PPUSH
31229: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31233: LD_EXP 36
31237: PPUSH
31238: LD_STRING DAa-JMM-1
31240: PPUSH
31241: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31245: LD_EXP 36
31249: PPUSH
31250: LD_STRING DAa-JMM-1a
31252: PPUSH
31253: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31257: LD_EXP 36
31261: PPUSH
31262: LD_STRING DAa-JMM-1b
31264: PPUSH
31265: CALL_OW 88
// DialogueOff ;
31269: CALL_OW 7
// end ; end ;
31273: LD_VAR 0 2
31277: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31278: LD_EXP 15
31282: PUSH
31283: LD_INT 13
31285: GREATEREQUAL
31286: PUSH
31287: LD_INT 22
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 21
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PPUSH
31311: CALL_OW 69
31315: PUSH
31316: LD_INT 0
31318: EQUAL
31319: AND
31320: PUSH
31321: LD_INT 22
31323: PUSH
31324: LD_INT 2
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 21
31333: PUSH
31334: LD_INT 2
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 50
31343: PUSH
31344: EMPTY
31345: LIST
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: LIST
31351: PPUSH
31352: CALL_OW 69
31356: PUSH
31357: LD_INT 0
31359: EQUAL
31360: AND
31361: PUSH
31362: LD_EXP 21
31366: AND
31367: PUSH
31368: LD_EXP 22
31372: AND
31373: PUSH
31374: LD_EXP 23
31378: AND
31379: IFFALSE 31860
31381: GO 31383
31383: DISABLE
// begin DialogueOn ;
31384: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31388: LD_EXP 36
31392: PPUSH
31393: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31397: LD_EXP 36
31401: PPUSH
31402: LD_STRING D20-JMM-1
31404: PPUSH
31405: CALL_OW 88
// if IsOK ( Joan ) then
31409: LD_EXP 37
31413: PPUSH
31414: CALL_OW 302
31418: IFFALSE 31432
// Say ( Joan , D20-Joan-1 ) ;
31420: LD_EXP 37
31424: PPUSH
31425: LD_STRING D20-Joan-1
31427: PPUSH
31428: CALL_OW 88
// if IsOk ( Lisa ) then
31432: LD_EXP 39
31436: PPUSH
31437: CALL_OW 302
31441: IFFALSE 31455
// Say ( Lisa , D20-Lisa-1 ) ;
31443: LD_EXP 39
31447: PPUSH
31448: LD_STRING D20-Lisa-1
31450: PPUSH
31451: CALL_OW 88
// if IsOk ( Donaldson ) then
31455: LD_EXP 40
31459: PPUSH
31460: CALL_OW 302
31464: IFFALSE 31478
// Say ( Donaldson , D20-Don-1 ) ;
31466: LD_EXP 40
31470: PPUSH
31471: LD_STRING D20-Don-1
31473: PPUSH
31474: CALL_OW 88
// if IsOK ( Cornel ) then
31478: LD_EXP 47
31482: PPUSH
31483: CALL_OW 302
31487: IFFALSE 31501
// Say ( Cornel , D20-Corn-1 ) ;
31489: LD_EXP 47
31493: PPUSH
31494: LD_STRING D20-Corn-1
31496: PPUSH
31497: CALL_OW 88
// if IsOk ( Denis ) then
31501: LD_EXP 43
31505: PPUSH
31506: CALL_OW 302
31510: IFFALSE 31524
// Say ( Denis , D20-Den-1 ) ;
31512: LD_EXP 43
31516: PPUSH
31517: LD_STRING D20-Den-1
31519: PPUSH
31520: CALL_OW 88
// if IsOk ( Bobby ) then
31524: LD_EXP 41
31528: PPUSH
31529: CALL_OW 302
31533: IFFALSE 31547
// Say ( Bobby , D20-Bobby-1 ) ;
31535: LD_EXP 41
31539: PPUSH
31540: LD_STRING D20-Bobby-1
31542: PPUSH
31543: CALL_OW 88
// if IsOk ( Gladstone ) then
31547: LD_EXP 45
31551: PPUSH
31552: CALL_OW 302
31556: IFFALSE 31570
// Say ( Gladstone , D20-Glad-1 ) ;
31558: LD_EXP 45
31562: PPUSH
31563: LD_STRING D20-Glad-1
31565: PPUSH
31566: CALL_OW 88
// if IsOk ( Cyrus ) then
31570: LD_EXP 42
31574: PPUSH
31575: CALL_OW 302
31579: IFFALSE 31593
// Say ( Cyrus , D20-Cyrus-1 ) ;
31581: LD_EXP 42
31585: PPUSH
31586: LD_STRING D20-Cyrus-1
31588: PPUSH
31589: CALL_OW 88
// if IsOk ( Stevens ) then
31593: LD_EXP 38
31597: PPUSH
31598: CALL_OW 302
31602: IFFALSE 31616
// Say ( Stevens , D20-Huck-1 ) ;
31604: LD_EXP 38
31608: PPUSH
31609: LD_STRING D20-Huck-1
31611: PPUSH
31612: CALL_OW 88
// if IsOk ( Brown ) then
31616: LD_EXP 44
31620: PPUSH
31621: CALL_OW 302
31625: IFFALSE 31639
// Say ( Brown , D20-Brown-1 ) ;
31627: LD_EXP 44
31631: PPUSH
31632: LD_STRING D20-Brown-1
31634: PPUSH
31635: CALL_OW 88
// if IsOk ( Gary ) then
31639: LD_EXP 48
31643: PPUSH
31644: CALL_OW 302
31648: IFFALSE 31662
// Say ( Gary , D20-Gary-1 ) ;
31650: LD_EXP 48
31654: PPUSH
31655: LD_STRING D20-Gary-1
31657: PPUSH
31658: CALL_OW 88
// if IsOk ( Connie ) then
31662: LD_EXP 51
31666: PPUSH
31667: CALL_OW 302
31671: IFFALSE 31685
// Say ( Connie , D20-Con-1 ) ;
31673: LD_EXP 51
31677: PPUSH
31678: LD_STRING D20-Con-1
31680: PPUSH
31681: CALL_OW 88
// if IsOk ( Kurt ) then
31685: LD_EXP 57
31689: PPUSH
31690: CALL_OW 302
31694: IFFALSE 31708
// Say ( Kurt , D20-Kurt-1 ) ;
31696: LD_EXP 57
31700: PPUSH
31701: LD_STRING D20-Kurt-1
31703: PPUSH
31704: CALL_OW 88
// if IsOk ( Kikuchi ) then
31708: LD_EXP 50
31712: PPUSH
31713: CALL_OW 302
31717: IFFALSE 31731
// Say ( Kikuchi , D20-Yam-1 ) ;
31719: LD_EXP 50
31723: PPUSH
31724: LD_STRING D20-Yam-1
31726: PPUSH
31727: CALL_OW 88
// if IsOk ( Frank ) then
31731: LD_EXP 49
31735: PPUSH
31736: CALL_OW 302
31740: IFFALSE 31754
// Say ( Frank , D20-Frank-1 ) ;
31742: LD_EXP 49
31746: PPUSH
31747: LD_STRING D20-Frank-1
31749: PPUSH
31750: CALL_OW 88
// DialogueOff ;
31754: CALL_OW 7
// if RothCaptured then
31758: LD_EXP 33
31762: IFFALSE 31776
// AddMedal ( Roth , 1 ) else
31764: LD_STRING Roth
31766: PPUSH
31767: LD_INT 1
31769: PPUSH
31770: CALL_OW 101
31774: GO 31787
// AddMedal ( Roth , - 1 ) ;
31776: LD_STRING Roth
31778: PPUSH
31779: LD_INT 1
31781: NEG
31782: PPUSH
31783: CALL_OW 101
// if behemothDestroyedBeforeFinish then
31787: LD_EXP 27
31791: IFFALSE 31805
// AddMedal ( Project , 1 ) else
31793: LD_STRING Project
31795: PPUSH
31796: LD_INT 1
31798: PPUSH
31799: CALL_OW 101
31803: GO 31816
// AddMedal ( Project , - 1 ) ;
31805: LD_STRING Project
31807: PPUSH
31808: LD_INT 1
31810: NEG
31811: PPUSH
31812: CALL_OW 101
// if lostCounter = 0 then
31816: LD_EXP 32
31820: PUSH
31821: LD_INT 0
31823: EQUAL
31824: IFFALSE 31838
// AddMedal ( NoLosses , 1 ) else
31826: LD_STRING NoLosses
31828: PPUSH
31829: LD_INT 1
31831: PPUSH
31832: CALL_OW 101
31836: GO 31849
// AddMedal ( NoLosses , - 1 ) ;
31838: LD_STRING NoLosses
31840: PPUSH
31841: LD_INT 1
31843: NEG
31844: PPUSH
31845: CALL_OW 101
// GiveMedals ( MAIN ) ;
31849: LD_STRING MAIN
31851: PPUSH
31852: CALL_OW 102
// YouWin ;
31856: CALL_OW 103
// end ; end_of_file
31860: END
// export function CustomEvent ( event ) ; begin
31861: LD_INT 0
31863: PPUSH
// end ;
31864: LD_VAR 0 2
31868: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
31869: LD_VAR 0 1
31873: PUSH
31874: LD_INT 1
31876: EQUAL
31877: PUSH
31878: LD_VAR 0 2
31882: PUSH
31883: LD_INT 4
31885: EQUAL
31886: AND
31887: PUSH
31888: LD_EXP 55
31892: PPUSH
31893: CALL_OW 300
31897: AND
31898: IFFALSE 31914
// begin wait ( 0 0$2 ) ;
31900: LD_INT 70
31902: PPUSH
31903: CALL_OW 67
// YouLost ( Dismissed ) ;
31907: LD_STRING Dismissed
31909: PPUSH
31910: CALL_OW 104
// end ; end ;
31914: PPOPN 2
31916: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
31917: LD_VAR 0 2
31921: PPUSH
31922: LD_VAR 0 3
31926: PPUSH
31927: LD_INT 18
31929: PPUSH
31930: CALL_OW 309
31934: IFFALSE 31943
// YouLost ( Motherlode3 ) ;
31936: LD_STRING Motherlode3
31938: PPUSH
31939: CALL_OW 104
// end ;
31943: PPOPN 3
31945: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
31946: LD_EXP 27
31950: NOT
31951: IFFALSE 31961
// behemothDone := true ;
31953: LD_ADDR_EXP 28
31957: PUSH
31958: LD_INT 1
31960: ST_TO_ADDR
// end ;
31961: PPOPN 1
31963: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31964: LD_VAR 0 1
31968: PPUSH
31969: CALL_OW 255
31973: PUSH
31974: LD_INT 1
31976: EQUAL
31977: PUSH
31978: LD_EXP 30
31982: AND
31983: PUSH
31984: LD_INT 22
31986: PUSH
31987: LD_INT 3
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: LD_INT 34
31996: PUSH
31997: LD_INT 48
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PPUSH
32008: CALL_OW 69
32012: AND
32013: PUSH
32014: LD_INT 22
32016: PUSH
32017: LD_INT 1
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 34
32026: PUSH
32027: LD_INT 8
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PPUSH
32038: CALL_OW 69
32042: NOT
32043: AND
32044: IFFALSE 32096
// begin wait ( 0 0$5 ) ;
32046: LD_INT 175
32048: PPUSH
32049: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32053: LD_INT 22
32055: PUSH
32056: LD_INT 3
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 34
32065: PUSH
32066: LD_INT 48
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PPUSH
32077: CALL_OW 69
32081: PUSH
32082: LD_INT 1
32084: ARRAY
32085: PPUSH
32086: LD_INT 60
32088: PPUSH
32089: LD_INT 95
32091: PPUSH
32092: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32096: LD_VAR 0 2
32100: PPUSH
32101: LD_VAR 0 3
32105: PPUSH
32106: LD_INT 18
32108: PPUSH
32109: CALL_OW 309
32113: IFFALSE 32173
// begin if GetSide ( unit ) = 1 then
32115: LD_VAR 0 1
32119: PPUSH
32120: CALL_OW 255
32124: PUSH
32125: LD_INT 1
32127: EQUAL
32128: IFFALSE 32144
// begin wait ( 0 0$6 ) ;
32130: LD_INT 210
32132: PPUSH
32133: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32137: LD_STRING Motherlode2
32139: PPUSH
32140: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32144: LD_VAR 0 1
32148: PPUSH
32149: CALL_OW 255
32153: PUSH
32154: LD_INT 8
32156: EQUAL
32157: IFFALSE 32173
// begin wait ( 0 0$6 ) ;
32159: LD_INT 210
32161: PPUSH
32162: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32166: LD_STRING Motherlode1
32168: PPUSH
32169: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 255
32182: PUSH
32183: LD_INT 3
32185: EQUAL
32186: IFFALSE 32207
// begin wait ( 0 0$5 ) ;
32188: LD_INT 175
32190: PPUSH
32191: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32195: LD_EXP 61
32199: PPUSH
32200: LD_STRING D18-Pla-1
32202: PPUSH
32203: CALL_OW 94
// end ; end ;
32207: PPOPN 3
32209: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32210: LD_VAR 0 1
32214: PUSH
32215: LD_EXP 70
32219: IN
32220: IFFALSE 32240
// begin behemothBuilders := behemothBuilders diff un ;
32222: LD_ADDR_EXP 70
32226: PUSH
32227: LD_EXP 70
32231: PUSH
32232: LD_VAR 0 1
32236: DIFF
32237: ST_TO_ADDR
// exit ;
32238: GO 32338
// end ; if un = JMM then
32240: LD_VAR 0 1
32244: PUSH
32245: LD_EXP 36
32249: EQUAL
32250: IFFALSE 32261
// begin YouLost ( JMM ) ;
32252: LD_STRING JMM
32254: PPUSH
32255: CALL_OW 104
// exit ;
32259: GO 32338
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32261: LD_VAR 0 1
32265: PUSH
32266: LD_INT 22
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 3
32278: PUSH
32279: LD_INT 25
32281: PUSH
32282: LD_INT 16
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 25
32291: PUSH
32292: LD_INT 12
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: LIST
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PPUSH
32308: CALL_OW 69
32312: IN
32313: IFFALSE 32329
// lostCounter := lostCounter + 1 ;
32315: LD_ADDR_EXP 32
32319: PUSH
32320: LD_EXP 32
32324: PUSH
32325: LD_INT 1
32327: PLUS
32328: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32329: LD_VAR 0 1
32333: PPUSH
32334: CALL 59068 0 1
// end ;
32338: PPOPN 1
32340: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32341: LD_VAR 0 1
32345: PPUSH
32346: LD_VAR 0 2
32350: PPUSH
32351: CALL 61047 0 2
// end ;
32355: PPOPN 2
32357: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32358: LD_VAR 0 1
32362: PPUSH
32363: CALL 60115 0 1
// end ;
32367: PPOPN 1
32369: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32370: LD_VAR 0 1
32374: PUSH
32375: LD_INT 22
32377: PUSH
32378: LD_INT 8
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 30
32387: PUSH
32388: LD_INT 2
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 23
32397: PUSH
32398: LD_INT 3
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: LIST
32409: PPUSH
32410: CALL_OW 69
32414: IN
32415: IFFALSE 32442
// begin ComUpgrade ( building ) ;
32417: LD_VAR 0 1
32421: PPUSH
32422: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32426: LD_EXP 58
32430: PPUSH
32431: LD_VAR 0 1
32435: PPUSH
32436: CALL 71271 0 2
// exit ;
32440: GO 32451
// end ; MCE_BuildingComplete ( building ) ;
32442: LD_VAR 0 1
32446: PPUSH
32447: CALL 60356 0 1
// end ;
32451: PPOPN 1
32453: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32454: LD_VAR 0 1
32458: PPUSH
32459: LD_VAR 0 2
32463: PPUSH
32464: CALL 58764 0 2
// end ;
32468: PPOPN 2
32470: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32471: LD_VAR 0 1
32475: PPUSH
32476: LD_VAR 0 2
32480: PPUSH
32481: LD_VAR 0 3
32485: PPUSH
32486: LD_VAR 0 4
32490: PPUSH
32491: LD_VAR 0 5
32495: PPUSH
32496: CALL 58384 0 5
// end ;
32500: PPOPN 5
32502: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32503: LD_VAR 0 1
32507: PPUSH
32508: LD_VAR 0 2
32512: PPUSH
32513: CALL 57974 0 2
// end ;
32517: PPOPN 2
32519: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32520: LD_VAR 0 1
32524: PPUSH
32525: LD_VAR 0 2
32529: PPUSH
32530: LD_VAR 0 3
32534: PPUSH
32535: LD_VAR 0 4
32539: PPUSH
32540: CALL 57812 0 4
// end ;
32544: PPOPN 4
32546: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32547: LD_VAR 0 1
32551: PPUSH
32552: LD_VAR 0 2
32556: PPUSH
32557: LD_VAR 0 3
32561: PPUSH
32562: CALL 57587 0 3
// end ;
32566: PPOPN 3
32568: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32569: LD_VAR 0 1
32573: PPUSH
32574: LD_VAR 0 2
32578: PPUSH
32579: CALL 57472 0 2
// end ;
32583: PPOPN 2
32585: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32586: LD_VAR 0 1
32590: PPUSH
32591: LD_VAR 0 2
32595: PPUSH
32596: CALL 61308 0 2
// end ;
32600: PPOPN 2
32602: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32603: LD_VAR 0 1
32607: PPUSH
32608: CALL_OW 255
32612: PUSH
32613: LD_INT 4
32615: EQUAL
32616: PUSH
32617: LD_VAR 0 1
32621: PUSH
32622: LD_EXP 18
32626: PUSH
32627: LD_INT 1
32629: ARRAY
32630: IN
32631: AND
32632: PUSH
32633: LD_EXP 19
32637: AND
32638: IFFALSE 32657
// begin ComMoveXY ( driver , 61 , 93 ) ;
32640: LD_VAR 0 1
32644: PPUSH
32645: LD_INT 61
32647: PPUSH
32648: LD_INT 93
32650: PPUSH
32651: CALL_OW 111
// exit ;
32655: GO 32681
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32657: LD_VAR 0 1
32661: PPUSH
32662: LD_VAR 0 2
32666: PPUSH
32667: LD_VAR 0 3
32671: PPUSH
32672: LD_VAR 0 4
32676: PPUSH
32677: CALL 61524 0 4
// end ;
32681: PPOPN 4
32683: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32684: LD_VAR 0 1
32688: PPUSH
32689: LD_VAR 0 2
32693: PPUSH
32694: CALL 57281 0 2
// end ; end_of_file
32698: PPOPN 2
32700: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32701: LD_EXP 15
32705: PUSH
32706: LD_INT 2
32708: EQUAL
32709: IFFALSE 33188
32711: GO 32713
32713: DISABLE
32714: LD_INT 0
32716: PPUSH
// begin time := 0 0$40 ;
32717: LD_ADDR_VAR 0 1
32721: PUSH
32722: LD_INT 1400
32724: ST_TO_ADDR
// repeat wait ( time ) ;
32725: LD_VAR 0 1
32729: PPUSH
32730: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
32734: LD_INT 1
32736: PPUSH
32737: LD_INT 5
32739: PPUSH
32740: CALL_OW 12
32744: PPUSH
32745: LD_INT 106
32747: PPUSH
32748: LD_INT 150
32750: PPUSH
32751: LD_INT 19
32753: PPUSH
32754: LD_INT 1
32756: PPUSH
32757: CALL_OW 56
// time := time + 0 0$9 ;
32761: LD_ADDR_VAR 0 1
32765: PUSH
32766: LD_VAR 0 1
32770: PUSH
32771: LD_INT 315
32773: PLUS
32774: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
32775: LD_INT 455
32777: PPUSH
32778: LD_INT 840
32780: PPUSH
32781: CALL_OW 12
32785: PPUSH
32786: CALL_OW 67
// if Prob ( 50 ) then
32790: LD_INT 50
32792: PPUSH
32793: CALL_OW 13
32797: IFFALSE 32826
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
32799: LD_INT 1
32801: PPUSH
32802: LD_INT 5
32804: PPUSH
32805: CALL_OW 12
32809: PPUSH
32810: LD_INT 62
32812: PPUSH
32813: LD_INT 108
32815: PPUSH
32816: LD_INT 10
32818: PPUSH
32819: LD_INT 1
32821: PPUSH
32822: CALL_OW 56
// until missionStage > 4 ;
32826: LD_EXP 15
32830: PUSH
32831: LD_INT 4
32833: GREATER
32834: IFFALSE 32725
// repeat wait ( 0 0$1 ) ;
32836: LD_INT 35
32838: PPUSH
32839: CALL_OW 67
// until missionStage = 6 ;
32843: LD_EXP 15
32847: PUSH
32848: LD_INT 6
32850: EQUAL
32851: IFFALSE 32836
// time := 0 0$50 ;
32853: LD_ADDR_VAR 0 1
32857: PUSH
32858: LD_INT 1750
32860: ST_TO_ADDR
// repeat wait ( time ) ;
32861: LD_VAR 0 1
32865: PPUSH
32866: CALL_OW 67
// if Prob ( 50 ) then
32870: LD_INT 50
32872: PPUSH
32873: CALL_OW 13
32877: IFFALSE 32906
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
32879: LD_INT 1
32881: PPUSH
32882: LD_INT 5
32884: PPUSH
32885: CALL_OW 12
32889: PPUSH
32890: LD_INT 106
32892: PPUSH
32893: LD_INT 89
32895: PPUSH
32896: LD_INT 45
32898: PPUSH
32899: LD_INT 1
32901: PPUSH
32902: CALL_OW 56
// time := time + 0 0$3 ;
32906: LD_ADDR_VAR 0 1
32910: PUSH
32911: LD_VAR 0 1
32915: PUSH
32916: LD_INT 105
32918: PLUS
32919: ST_TO_ADDR
// if Prob ( 30 ) then
32920: LD_INT 30
32922: PPUSH
32923: CALL_OW 13
32927: IFFALSE 32973
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
32929: LD_INT 525
32931: PPUSH
32932: LD_INT 735
32934: PPUSH
32935: CALL_OW 12
32939: PPUSH
32940: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
32944: LD_INT 1
32946: PPUSH
32947: LD_INT 5
32949: PPUSH
32950: CALL_OW 12
32954: PPUSH
32955: LD_INT 21
32957: PPUSH
32958: LD_INT 26
32960: PPUSH
32961: LD_INT 12
32963: PPUSH
32964: LD_INT 1
32966: PPUSH
32967: CALL_OW 56
// end else
32971: GO 33009
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
32973: LD_INT 700
32975: PPUSH
32976: LD_INT 1225
32978: PPUSH
32979: CALL_OW 12
32983: PPUSH
32984: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
32988: LD_INT 1
32990: PPUSH
32991: LD_INT 5
32993: PPUSH
32994: CALL_OW 12
32998: PPUSH
32999: LD_INT 16
33001: PPUSH
33002: LD_INT 1
33004: PPUSH
33005: CALL_OW 55
// end ; if Prob ( 50 ) then
33009: LD_INT 50
33011: PPUSH
33012: CALL_OW 13
33016: IFFALSE 33062
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33018: LD_INT 700
33020: PPUSH
33021: LD_INT 1050
33023: PPUSH
33024: CALL_OW 12
33028: PPUSH
33029: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33033: LD_INT 1
33035: PPUSH
33036: LD_INT 5
33038: PPUSH
33039: CALL_OW 12
33043: PPUSH
33044: LD_INT 181
33046: PPUSH
33047: LD_INT 218
33049: PPUSH
33050: LD_INT 16
33052: PPUSH
33053: LD_INT 1
33055: PPUSH
33056: CALL_OW 56
// end else
33060: GO 33098
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33062: LD_INT 350
33064: PPUSH
33065: LD_INT 525
33067: PPUSH
33068: CALL_OW 12
33072: PPUSH
33073: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33077: LD_INT 1
33079: PPUSH
33080: LD_INT 5
33082: PPUSH
33083: CALL_OW 12
33087: PPUSH
33088: LD_INT 15
33090: PPUSH
33091: LD_INT 1
33093: PPUSH
33094: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33098: LD_INT 45
33100: PUSH
33101: LD_INT 32
33103: PUSH
33104: LD_INT 25
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: LIST
33111: PUSH
33112: LD_OWVAR 67
33116: ARRAY
33117: PPUSH
33118: CALL_OW 13
33122: IFFALSE 33166
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33124: LD_INT 525
33126: PPUSH
33127: LD_INT 875
33129: PPUSH
33130: CALL_OW 12
33134: PPUSH
33135: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33139: LD_INT 1
33141: PPUSH
33142: LD_INT 5
33144: PPUSH
33145: CALL_OW 12
33149: PPUSH
33150: LD_INT 103
33152: PPUSH
33153: LD_INT 140
33155: PPUSH
33156: LD_INT 20
33158: PPUSH
33159: LD_INT 1
33161: PPUSH
33162: CALL_OW 56
// end ; if time > 2 2$20 then
33166: LD_VAR 0 1
33170: PUSH
33171: LD_INT 4900
33173: GREATER
33174: IFFALSE 33184
// time := 0 0$50 ;
33176: LD_ADDR_VAR 0 1
33180: PUSH
33181: LD_INT 1750
33183: ST_TO_ADDR
// until false ;
33184: LD_INT 0
33186: IFFALSE 32861
// end ; end_of_file
33188: PPOPN 1
33190: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33191: LD_EXP 13
33195: PUSH
33196: LD_EXP 15
33200: PUSH
33201: LD_INT 6
33203: GREATEREQUAL
33204: AND
33205: IFFALSE 33242
33207: GO 33209
33209: DISABLE
// begin enable ;
33210: ENABLE
// missionTime := missionTime + 0 0$1 ;
33211: LD_ADDR_EXP 14
33215: PUSH
33216: LD_EXP 14
33220: PUSH
33221: LD_INT 35
33223: PLUS
33224: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33225: LD_ADDR_OWVAR 47
33229: PUSH
33230: LD_STRING #Am15-1
33232: PUSH
33233: LD_EXP 14
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: ST_TO_ADDR
// end ; end_of_file
33242: END
// export function InitNature ; begin
33243: LD_INT 0
33245: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33246: LD_INT 3
33248: PPUSH
33249: LD_INT 3
33251: PPUSH
33252: LD_INT 2
33254: PPUSH
33255: LD_INT 1
33257: PPUSH
33258: LD_INT 1
33260: PPUSH
33261: LD_INT 0
33263: PPUSH
33264: LD_INT 0
33266: PPUSH
33267: LD_INT 20
33269: PPUSH
33270: LD_INT 0
33272: PPUSH
33273: CALL 96088 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33277: LD_INT 2
33279: PPUSH
33280: LD_INT 1
33282: PPUSH
33283: LD_INT 1
33285: PPUSH
33286: LD_INT 1
33288: PPUSH
33289: LD_INT 1
33291: PPUSH
33292: LD_INT 0
33294: PPUSH
33295: LD_INT 0
33297: PPUSH
33298: LD_INT 21
33300: PPUSH
33301: LD_INT 0
33303: PPUSH
33304: CALL 96088 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33308: LD_INT 4
33310: PPUSH
33311: LD_INT 1
33313: PPUSH
33314: LD_INT 2
33316: PPUSH
33317: LD_INT 4
33319: PPUSH
33320: LD_INT 2
33322: PPUSH
33323: LD_INT 1
33325: PPUSH
33326: LD_INT 0
33328: PPUSH
33329: LD_INT 22
33331: PPUSH
33332: LD_INT 0
33334: PPUSH
33335: CALL 96088 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33339: LD_INT 0
33341: PPUSH
33342: LD_INT 0
33344: PPUSH
33345: LD_INT 0
33347: PPUSH
33348: LD_INT 0
33350: PPUSH
33351: LD_INT 0
33353: PPUSH
33354: LD_INT 0
33356: PPUSH
33357: LD_INT 9
33359: PPUSH
33360: LD_INT 0
33362: PPUSH
33363: LD_INT 23
33365: PPUSH
33366: CALL 96088 0 9
// end ; end_of_file
33370: LD_VAR 0 1
33374: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33375: GO 33377
33377: DISABLE
// begin ru_radar := 98 ;
33378: LD_ADDR_EXP 92
33382: PUSH
33383: LD_INT 98
33385: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33386: LD_ADDR_EXP 93
33390: PUSH
33391: LD_INT 89
33393: ST_TO_ADDR
// us_hack := 99 ;
33394: LD_ADDR_EXP 94
33398: PUSH
33399: LD_INT 99
33401: ST_TO_ADDR
// us_artillery := 97 ;
33402: LD_ADDR_EXP 95
33406: PUSH
33407: LD_INT 97
33409: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33410: LD_ADDR_EXP 96
33414: PUSH
33415: LD_INT 91
33417: ST_TO_ADDR
// end ; end_of_file
33418: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33419: LD_INT 0
33421: PPUSH
33422: PPUSH
// skirmish := false ;
33423: LD_ADDR_EXP 97
33427: PUSH
33428: LD_INT 0
33430: ST_TO_ADDR
// debug_mc := false ;
33431: LD_ADDR_EXP 98
33435: PUSH
33436: LD_INT 0
33438: ST_TO_ADDR
// mc_bases := [ ] ;
33439: LD_ADDR_EXP 99
33443: PUSH
33444: EMPTY
33445: ST_TO_ADDR
// mc_sides := [ ] ;
33446: LD_ADDR_EXP 125
33450: PUSH
33451: EMPTY
33452: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33453: LD_ADDR_EXP 100
33457: PUSH
33458: EMPTY
33459: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33460: LD_ADDR_EXP 101
33464: PUSH
33465: EMPTY
33466: ST_TO_ADDR
// mc_need_heal := [ ] ;
33467: LD_ADDR_EXP 102
33471: PUSH
33472: EMPTY
33473: ST_TO_ADDR
// mc_healers := [ ] ;
33474: LD_ADDR_EXP 103
33478: PUSH
33479: EMPTY
33480: ST_TO_ADDR
// mc_build_list := [ ] ;
33481: LD_ADDR_EXP 104
33485: PUSH
33486: EMPTY
33487: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33488: LD_ADDR_EXP 131
33492: PUSH
33493: EMPTY
33494: ST_TO_ADDR
// mc_builders := [ ] ;
33495: LD_ADDR_EXP 105
33499: PUSH
33500: EMPTY
33501: ST_TO_ADDR
// mc_construct_list := [ ] ;
33502: LD_ADDR_EXP 106
33506: PUSH
33507: EMPTY
33508: ST_TO_ADDR
// mc_turret_list := [ ] ;
33509: LD_ADDR_EXP 107
33513: PUSH
33514: EMPTY
33515: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33516: LD_ADDR_EXP 108
33520: PUSH
33521: EMPTY
33522: ST_TO_ADDR
// mc_miners := [ ] ;
33523: LD_ADDR_EXP 113
33527: PUSH
33528: EMPTY
33529: ST_TO_ADDR
// mc_mines := [ ] ;
33530: LD_ADDR_EXP 112
33534: PUSH
33535: EMPTY
33536: ST_TO_ADDR
// mc_minefields := [ ] ;
33537: LD_ADDR_EXP 114
33541: PUSH
33542: EMPTY
33543: ST_TO_ADDR
// mc_crates := [ ] ;
33544: LD_ADDR_EXP 115
33548: PUSH
33549: EMPTY
33550: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33551: LD_ADDR_EXP 116
33555: PUSH
33556: EMPTY
33557: ST_TO_ADDR
// mc_crates_area := [ ] ;
33558: LD_ADDR_EXP 117
33562: PUSH
33563: EMPTY
33564: ST_TO_ADDR
// mc_vehicles := [ ] ;
33565: LD_ADDR_EXP 118
33569: PUSH
33570: EMPTY
33571: ST_TO_ADDR
// mc_attack := [ ] ;
33572: LD_ADDR_EXP 119
33576: PUSH
33577: EMPTY
33578: ST_TO_ADDR
// mc_produce := [ ] ;
33579: LD_ADDR_EXP 120
33583: PUSH
33584: EMPTY
33585: ST_TO_ADDR
// mc_defender := [ ] ;
33586: LD_ADDR_EXP 121
33590: PUSH
33591: EMPTY
33592: ST_TO_ADDR
// mc_parking := [ ] ;
33593: LD_ADDR_EXP 123
33597: PUSH
33598: EMPTY
33599: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33600: LD_ADDR_EXP 109
33604: PUSH
33605: EMPTY
33606: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33607: LD_ADDR_EXP 111
33611: PUSH
33612: EMPTY
33613: ST_TO_ADDR
// mc_scan := [ ] ;
33614: LD_ADDR_EXP 122
33618: PUSH
33619: EMPTY
33620: ST_TO_ADDR
// mc_scan_area := [ ] ;
33621: LD_ADDR_EXP 124
33625: PUSH
33626: EMPTY
33627: ST_TO_ADDR
// mc_tech := [ ] ;
33628: LD_ADDR_EXP 126
33632: PUSH
33633: EMPTY
33634: ST_TO_ADDR
// mc_class := [ ] ;
33635: LD_ADDR_EXP 140
33639: PUSH
33640: EMPTY
33641: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33642: LD_ADDR_EXP 141
33646: PUSH
33647: EMPTY
33648: ST_TO_ADDR
// end ;
33649: LD_VAR 0 1
33653: RET
// export function MC_Kill ( base ) ; begin
33654: LD_INT 0
33656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33657: LD_ADDR_EXP 99
33661: PUSH
33662: LD_EXP 99
33666: PPUSH
33667: LD_VAR 0 1
33671: PPUSH
33672: EMPTY
33673: PPUSH
33674: CALL_OW 1
33678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33679: LD_ADDR_EXP 100
33683: PUSH
33684: LD_EXP 100
33688: PPUSH
33689: LD_VAR 0 1
33693: PPUSH
33694: EMPTY
33695: PPUSH
33696: CALL_OW 1
33700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33701: LD_ADDR_EXP 101
33705: PUSH
33706: LD_EXP 101
33710: PPUSH
33711: LD_VAR 0 1
33715: PPUSH
33716: EMPTY
33717: PPUSH
33718: CALL_OW 1
33722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
33723: LD_ADDR_EXP 102
33727: PUSH
33728: LD_EXP 102
33732: PPUSH
33733: LD_VAR 0 1
33737: PPUSH
33738: EMPTY
33739: PPUSH
33740: CALL_OW 1
33744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
33745: LD_ADDR_EXP 103
33749: PUSH
33750: LD_EXP 103
33754: PPUSH
33755: LD_VAR 0 1
33759: PPUSH
33760: EMPTY
33761: PPUSH
33762: CALL_OW 1
33766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
33767: LD_ADDR_EXP 104
33771: PUSH
33772: LD_EXP 104
33776: PPUSH
33777: LD_VAR 0 1
33781: PPUSH
33782: EMPTY
33783: PPUSH
33784: CALL_OW 1
33788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
33789: LD_ADDR_EXP 105
33793: PUSH
33794: LD_EXP 105
33798: PPUSH
33799: LD_VAR 0 1
33803: PPUSH
33804: EMPTY
33805: PPUSH
33806: CALL_OW 1
33810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
33811: LD_ADDR_EXP 106
33815: PUSH
33816: LD_EXP 106
33820: PPUSH
33821: LD_VAR 0 1
33825: PPUSH
33826: EMPTY
33827: PPUSH
33828: CALL_OW 1
33832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
33833: LD_ADDR_EXP 107
33837: PUSH
33838: LD_EXP 107
33842: PPUSH
33843: LD_VAR 0 1
33847: PPUSH
33848: EMPTY
33849: PPUSH
33850: CALL_OW 1
33854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
33855: LD_ADDR_EXP 108
33859: PUSH
33860: LD_EXP 108
33864: PPUSH
33865: LD_VAR 0 1
33869: PPUSH
33870: EMPTY
33871: PPUSH
33872: CALL_OW 1
33876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
33877: LD_ADDR_EXP 109
33881: PUSH
33882: LD_EXP 109
33886: PPUSH
33887: LD_VAR 0 1
33891: PPUSH
33892: EMPTY
33893: PPUSH
33894: CALL_OW 1
33898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
33899: LD_ADDR_EXP 110
33903: PUSH
33904: LD_EXP 110
33908: PPUSH
33909: LD_VAR 0 1
33913: PPUSH
33914: LD_INT 0
33916: PPUSH
33917: CALL_OW 1
33921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
33922: LD_ADDR_EXP 111
33926: PUSH
33927: LD_EXP 111
33931: PPUSH
33932: LD_VAR 0 1
33936: PPUSH
33937: EMPTY
33938: PPUSH
33939: CALL_OW 1
33943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
33944: LD_ADDR_EXP 112
33948: PUSH
33949: LD_EXP 112
33953: PPUSH
33954: LD_VAR 0 1
33958: PPUSH
33959: EMPTY
33960: PPUSH
33961: CALL_OW 1
33965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
33966: LD_ADDR_EXP 113
33970: PUSH
33971: LD_EXP 113
33975: PPUSH
33976: LD_VAR 0 1
33980: PPUSH
33981: EMPTY
33982: PPUSH
33983: CALL_OW 1
33987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
33988: LD_ADDR_EXP 114
33992: PUSH
33993: LD_EXP 114
33997: PPUSH
33998: LD_VAR 0 1
34002: PPUSH
34003: EMPTY
34004: PPUSH
34005: CALL_OW 1
34009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34010: LD_ADDR_EXP 115
34014: PUSH
34015: LD_EXP 115
34019: PPUSH
34020: LD_VAR 0 1
34024: PPUSH
34025: EMPTY
34026: PPUSH
34027: CALL_OW 1
34031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34032: LD_ADDR_EXP 116
34036: PUSH
34037: LD_EXP 116
34041: PPUSH
34042: LD_VAR 0 1
34046: PPUSH
34047: EMPTY
34048: PPUSH
34049: CALL_OW 1
34053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34054: LD_ADDR_EXP 117
34058: PUSH
34059: LD_EXP 117
34063: PPUSH
34064: LD_VAR 0 1
34068: PPUSH
34069: EMPTY
34070: PPUSH
34071: CALL_OW 1
34075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34076: LD_ADDR_EXP 118
34080: PUSH
34081: LD_EXP 118
34085: PPUSH
34086: LD_VAR 0 1
34090: PPUSH
34091: EMPTY
34092: PPUSH
34093: CALL_OW 1
34097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34098: LD_ADDR_EXP 119
34102: PUSH
34103: LD_EXP 119
34107: PPUSH
34108: LD_VAR 0 1
34112: PPUSH
34113: EMPTY
34114: PPUSH
34115: CALL_OW 1
34119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34120: LD_ADDR_EXP 120
34124: PUSH
34125: LD_EXP 120
34129: PPUSH
34130: LD_VAR 0 1
34134: PPUSH
34135: EMPTY
34136: PPUSH
34137: CALL_OW 1
34141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34142: LD_ADDR_EXP 121
34146: PUSH
34147: LD_EXP 121
34151: PPUSH
34152: LD_VAR 0 1
34156: PPUSH
34157: EMPTY
34158: PPUSH
34159: CALL_OW 1
34163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34164: LD_ADDR_EXP 122
34168: PUSH
34169: LD_EXP 122
34173: PPUSH
34174: LD_VAR 0 1
34178: PPUSH
34179: EMPTY
34180: PPUSH
34181: CALL_OW 1
34185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34186: LD_ADDR_EXP 123
34190: PUSH
34191: LD_EXP 123
34195: PPUSH
34196: LD_VAR 0 1
34200: PPUSH
34201: EMPTY
34202: PPUSH
34203: CALL_OW 1
34207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34208: LD_ADDR_EXP 124
34212: PUSH
34213: LD_EXP 124
34217: PPUSH
34218: LD_VAR 0 1
34222: PPUSH
34223: EMPTY
34224: PPUSH
34225: CALL_OW 1
34229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34230: LD_ADDR_EXP 126
34234: PUSH
34235: LD_EXP 126
34239: PPUSH
34240: LD_VAR 0 1
34244: PPUSH
34245: EMPTY
34246: PPUSH
34247: CALL_OW 1
34251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34252: LD_ADDR_EXP 128
34256: PUSH
34257: LD_EXP 128
34261: PPUSH
34262: LD_VAR 0 1
34266: PPUSH
34267: EMPTY
34268: PPUSH
34269: CALL_OW 1
34273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34274: LD_ADDR_EXP 129
34278: PUSH
34279: LD_EXP 129
34283: PPUSH
34284: LD_VAR 0 1
34288: PPUSH
34289: EMPTY
34290: PPUSH
34291: CALL_OW 1
34295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34296: LD_ADDR_EXP 130
34300: PUSH
34301: LD_EXP 130
34305: PPUSH
34306: LD_VAR 0 1
34310: PPUSH
34311: EMPTY
34312: PPUSH
34313: CALL_OW 1
34317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34318: LD_ADDR_EXP 131
34322: PUSH
34323: LD_EXP 131
34327: PPUSH
34328: LD_VAR 0 1
34332: PPUSH
34333: EMPTY
34334: PPUSH
34335: CALL_OW 1
34339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34340: LD_ADDR_EXP 132
34344: PUSH
34345: LD_EXP 132
34349: PPUSH
34350: LD_VAR 0 1
34354: PPUSH
34355: EMPTY
34356: PPUSH
34357: CALL_OW 1
34361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34362: LD_ADDR_EXP 133
34366: PUSH
34367: LD_EXP 133
34371: PPUSH
34372: LD_VAR 0 1
34376: PPUSH
34377: EMPTY
34378: PPUSH
34379: CALL_OW 1
34383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34384: LD_ADDR_EXP 134
34388: PUSH
34389: LD_EXP 134
34393: PPUSH
34394: LD_VAR 0 1
34398: PPUSH
34399: EMPTY
34400: PPUSH
34401: CALL_OW 1
34405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34406: LD_ADDR_EXP 135
34410: PUSH
34411: LD_EXP 135
34415: PPUSH
34416: LD_VAR 0 1
34420: PPUSH
34421: EMPTY
34422: PPUSH
34423: CALL_OW 1
34427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34428: LD_ADDR_EXP 136
34432: PUSH
34433: LD_EXP 136
34437: PPUSH
34438: LD_VAR 0 1
34442: PPUSH
34443: EMPTY
34444: PPUSH
34445: CALL_OW 1
34449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34450: LD_ADDR_EXP 137
34454: PUSH
34455: LD_EXP 137
34459: PPUSH
34460: LD_VAR 0 1
34464: PPUSH
34465: EMPTY
34466: PPUSH
34467: CALL_OW 1
34471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34472: LD_ADDR_EXP 138
34476: PUSH
34477: LD_EXP 138
34481: PPUSH
34482: LD_VAR 0 1
34486: PPUSH
34487: EMPTY
34488: PPUSH
34489: CALL_OW 1
34493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34494: LD_ADDR_EXP 139
34498: PUSH
34499: LD_EXP 139
34503: PPUSH
34504: LD_VAR 0 1
34508: PPUSH
34509: EMPTY
34510: PPUSH
34511: CALL_OW 1
34515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34516: LD_ADDR_EXP 140
34520: PUSH
34521: LD_EXP 140
34525: PPUSH
34526: LD_VAR 0 1
34530: PPUSH
34531: EMPTY
34532: PPUSH
34533: CALL_OW 1
34537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34538: LD_ADDR_EXP 141
34542: PUSH
34543: LD_EXP 141
34547: PPUSH
34548: LD_VAR 0 1
34552: PPUSH
34553: LD_INT 0
34555: PPUSH
34556: CALL_OW 1
34560: ST_TO_ADDR
// end ;
34561: LD_VAR 0 2
34565: RET
// export function MC_Start ( ) ; var i ; begin
34566: LD_INT 0
34568: PPUSH
34569: PPUSH
// for i = 1 to mc_bases do
34570: LD_ADDR_VAR 0 2
34574: PUSH
34575: DOUBLE
34576: LD_INT 1
34578: DEC
34579: ST_TO_ADDR
34580: LD_EXP 99
34584: PUSH
34585: FOR_TO
34586: IFFALSE 35663
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
34588: LD_ADDR_EXP 99
34592: PUSH
34593: LD_EXP 99
34597: PPUSH
34598: LD_VAR 0 2
34602: PPUSH
34603: LD_EXP 99
34607: PUSH
34608: LD_VAR 0 2
34612: ARRAY
34613: PUSH
34614: LD_INT 0
34616: DIFF
34617: PPUSH
34618: CALL_OW 1
34622: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
34623: LD_ADDR_EXP 100
34627: PUSH
34628: LD_EXP 100
34632: PPUSH
34633: LD_VAR 0 2
34637: PPUSH
34638: EMPTY
34639: PPUSH
34640: CALL_OW 1
34644: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
34645: LD_ADDR_EXP 101
34649: PUSH
34650: LD_EXP 101
34654: PPUSH
34655: LD_VAR 0 2
34659: PPUSH
34660: EMPTY
34661: PPUSH
34662: CALL_OW 1
34666: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
34667: LD_ADDR_EXP 102
34671: PUSH
34672: LD_EXP 102
34676: PPUSH
34677: LD_VAR 0 2
34681: PPUSH
34682: EMPTY
34683: PPUSH
34684: CALL_OW 1
34688: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
34689: LD_ADDR_EXP 103
34693: PUSH
34694: LD_EXP 103
34698: PPUSH
34699: LD_VAR 0 2
34703: PPUSH
34704: EMPTY
34705: PUSH
34706: EMPTY
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PPUSH
34712: CALL_OW 1
34716: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
34717: LD_ADDR_EXP 104
34721: PUSH
34722: LD_EXP 104
34726: PPUSH
34727: LD_VAR 0 2
34731: PPUSH
34732: EMPTY
34733: PPUSH
34734: CALL_OW 1
34738: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
34739: LD_ADDR_EXP 131
34743: PUSH
34744: LD_EXP 131
34748: PPUSH
34749: LD_VAR 0 2
34753: PPUSH
34754: EMPTY
34755: PPUSH
34756: CALL_OW 1
34760: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
34761: LD_ADDR_EXP 105
34765: PUSH
34766: LD_EXP 105
34770: PPUSH
34771: LD_VAR 0 2
34775: PPUSH
34776: EMPTY
34777: PPUSH
34778: CALL_OW 1
34782: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
34783: LD_ADDR_EXP 106
34787: PUSH
34788: LD_EXP 106
34792: PPUSH
34793: LD_VAR 0 2
34797: PPUSH
34798: EMPTY
34799: PPUSH
34800: CALL_OW 1
34804: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
34805: LD_ADDR_EXP 107
34809: PUSH
34810: LD_EXP 107
34814: PPUSH
34815: LD_VAR 0 2
34819: PPUSH
34820: LD_EXP 99
34824: PUSH
34825: LD_VAR 0 2
34829: ARRAY
34830: PPUSH
34831: LD_INT 2
34833: PUSH
34834: LD_INT 30
34836: PUSH
34837: LD_INT 32
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 30
34846: PUSH
34847: LD_INT 33
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: LIST
34858: PPUSH
34859: CALL_OW 72
34863: PPUSH
34864: CALL_OW 1
34868: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
34869: LD_ADDR_EXP 108
34873: PUSH
34874: LD_EXP 108
34878: PPUSH
34879: LD_VAR 0 2
34883: PPUSH
34884: LD_EXP 99
34888: PUSH
34889: LD_VAR 0 2
34893: ARRAY
34894: PPUSH
34895: LD_INT 2
34897: PUSH
34898: LD_INT 30
34900: PUSH
34901: LD_INT 32
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 30
34910: PUSH
34911: LD_INT 31
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 58
34925: PUSH
34926: EMPTY
34927: LIST
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PPUSH
34933: CALL_OW 72
34937: PPUSH
34938: CALL_OW 1
34942: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
34943: LD_ADDR_EXP 109
34947: PUSH
34948: LD_EXP 109
34952: PPUSH
34953: LD_VAR 0 2
34957: PPUSH
34958: EMPTY
34959: PPUSH
34960: CALL_OW 1
34964: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
34965: LD_ADDR_EXP 113
34969: PUSH
34970: LD_EXP 113
34974: PPUSH
34975: LD_VAR 0 2
34979: PPUSH
34980: EMPTY
34981: PPUSH
34982: CALL_OW 1
34986: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
34987: LD_ADDR_EXP 112
34991: PUSH
34992: LD_EXP 112
34996: PPUSH
34997: LD_VAR 0 2
35001: PPUSH
35002: EMPTY
35003: PPUSH
35004: CALL_OW 1
35008: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
35009: LD_ADDR_EXP 114
35013: PUSH
35014: LD_EXP 114
35018: PPUSH
35019: LD_VAR 0 2
35023: PPUSH
35024: EMPTY
35025: PPUSH
35026: CALL_OW 1
35030: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
35031: LD_ADDR_EXP 115
35035: PUSH
35036: LD_EXP 115
35040: PPUSH
35041: LD_VAR 0 2
35045: PPUSH
35046: EMPTY
35047: PPUSH
35048: CALL_OW 1
35052: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35053: LD_ADDR_EXP 116
35057: PUSH
35058: LD_EXP 116
35062: PPUSH
35063: LD_VAR 0 2
35067: PPUSH
35068: EMPTY
35069: PPUSH
35070: CALL_OW 1
35074: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
35075: LD_ADDR_EXP 117
35079: PUSH
35080: LD_EXP 117
35084: PPUSH
35085: LD_VAR 0 2
35089: PPUSH
35090: EMPTY
35091: PPUSH
35092: CALL_OW 1
35096: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
35097: LD_ADDR_EXP 118
35101: PUSH
35102: LD_EXP 118
35106: PPUSH
35107: LD_VAR 0 2
35111: PPUSH
35112: EMPTY
35113: PPUSH
35114: CALL_OW 1
35118: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35119: LD_ADDR_EXP 119
35123: PUSH
35124: LD_EXP 119
35128: PPUSH
35129: LD_VAR 0 2
35133: PPUSH
35134: EMPTY
35135: PPUSH
35136: CALL_OW 1
35140: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
35141: LD_ADDR_EXP 120
35145: PUSH
35146: LD_EXP 120
35150: PPUSH
35151: LD_VAR 0 2
35155: PPUSH
35156: EMPTY
35157: PPUSH
35158: CALL_OW 1
35162: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35163: LD_ADDR_EXP 121
35167: PUSH
35168: LD_EXP 121
35172: PPUSH
35173: LD_VAR 0 2
35177: PPUSH
35178: EMPTY
35179: PPUSH
35180: CALL_OW 1
35184: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
35185: LD_ADDR_EXP 110
35189: PUSH
35190: LD_EXP 110
35194: PPUSH
35195: LD_VAR 0 2
35199: PPUSH
35200: LD_INT 0
35202: PPUSH
35203: CALL_OW 1
35207: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
35208: LD_ADDR_EXP 123
35212: PUSH
35213: LD_EXP 123
35217: PPUSH
35218: LD_VAR 0 2
35222: PPUSH
35223: LD_INT 0
35225: PPUSH
35226: CALL_OW 1
35230: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35231: LD_ADDR_EXP 111
35235: PUSH
35236: LD_EXP 111
35240: PPUSH
35241: LD_VAR 0 2
35245: PPUSH
35246: EMPTY
35247: PPUSH
35248: CALL_OW 1
35252: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
35253: LD_ADDR_EXP 122
35257: PUSH
35258: LD_EXP 122
35262: PPUSH
35263: LD_VAR 0 2
35267: PPUSH
35268: LD_INT 0
35270: PPUSH
35271: CALL_OW 1
35275: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
35276: LD_ADDR_EXP 124
35280: PUSH
35281: LD_EXP 124
35285: PPUSH
35286: LD_VAR 0 2
35290: PPUSH
35291: EMPTY
35292: PPUSH
35293: CALL_OW 1
35297: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
35298: LD_ADDR_EXP 127
35302: PUSH
35303: LD_EXP 127
35307: PPUSH
35308: LD_VAR 0 2
35312: PPUSH
35313: LD_INT 0
35315: PPUSH
35316: CALL_OW 1
35320: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
35321: LD_ADDR_EXP 128
35325: PUSH
35326: LD_EXP 128
35330: PPUSH
35331: LD_VAR 0 2
35335: PPUSH
35336: EMPTY
35337: PPUSH
35338: CALL_OW 1
35342: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
35343: LD_ADDR_EXP 129
35347: PUSH
35348: LD_EXP 129
35352: PPUSH
35353: LD_VAR 0 2
35357: PPUSH
35358: EMPTY
35359: PPUSH
35360: CALL_OW 1
35364: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35365: LD_ADDR_EXP 130
35369: PUSH
35370: LD_EXP 130
35374: PPUSH
35375: LD_VAR 0 2
35379: PPUSH
35380: EMPTY
35381: PPUSH
35382: CALL_OW 1
35386: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
35387: LD_ADDR_EXP 132
35391: PUSH
35392: LD_EXP 132
35396: PPUSH
35397: LD_VAR 0 2
35401: PPUSH
35402: LD_EXP 99
35406: PUSH
35407: LD_VAR 0 2
35411: ARRAY
35412: PPUSH
35413: LD_INT 2
35415: PUSH
35416: LD_INT 30
35418: PUSH
35419: LD_INT 6
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 30
35428: PUSH
35429: LD_INT 7
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 30
35438: PUSH
35439: LD_INT 8
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: PPUSH
35452: CALL_OW 72
35456: PPUSH
35457: CALL_OW 1
35461: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
35462: LD_ADDR_EXP 133
35466: PUSH
35467: LD_EXP 133
35471: PPUSH
35472: LD_VAR 0 2
35476: PPUSH
35477: EMPTY
35478: PPUSH
35479: CALL_OW 1
35483: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
35484: LD_ADDR_EXP 134
35488: PUSH
35489: LD_EXP 134
35493: PPUSH
35494: LD_VAR 0 2
35498: PPUSH
35499: EMPTY
35500: PPUSH
35501: CALL_OW 1
35505: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
35506: LD_ADDR_EXP 135
35510: PUSH
35511: LD_EXP 135
35515: PPUSH
35516: LD_VAR 0 2
35520: PPUSH
35521: EMPTY
35522: PPUSH
35523: CALL_OW 1
35527: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
35528: LD_ADDR_EXP 136
35532: PUSH
35533: LD_EXP 136
35537: PPUSH
35538: LD_VAR 0 2
35542: PPUSH
35543: EMPTY
35544: PPUSH
35545: CALL_OW 1
35549: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35550: LD_ADDR_EXP 137
35554: PUSH
35555: LD_EXP 137
35559: PPUSH
35560: LD_VAR 0 2
35564: PPUSH
35565: EMPTY
35566: PPUSH
35567: CALL_OW 1
35571: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
35572: LD_ADDR_EXP 138
35576: PUSH
35577: LD_EXP 138
35581: PPUSH
35582: LD_VAR 0 2
35586: PPUSH
35587: EMPTY
35588: PPUSH
35589: CALL_OW 1
35593: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
35594: LD_ADDR_EXP 139
35598: PUSH
35599: LD_EXP 139
35603: PPUSH
35604: LD_VAR 0 2
35608: PPUSH
35609: EMPTY
35610: PPUSH
35611: CALL_OW 1
35615: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
35616: LD_ADDR_EXP 140
35620: PUSH
35621: LD_EXP 140
35625: PPUSH
35626: LD_VAR 0 2
35630: PPUSH
35631: EMPTY
35632: PPUSH
35633: CALL_OW 1
35637: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
35638: LD_ADDR_EXP 141
35642: PUSH
35643: LD_EXP 141
35647: PPUSH
35648: LD_VAR 0 2
35652: PPUSH
35653: LD_INT 0
35655: PPUSH
35656: CALL_OW 1
35660: ST_TO_ADDR
// end ;
35661: GO 34585
35663: POP
35664: POP
// MC_InitSides ( ) ;
35665: CALL 35951 0 0
// MC_InitResearch ( ) ;
35669: CALL 35690 0 0
// CustomInitMacro ( ) ;
35673: CALL 437 0 0
// skirmish := true ;
35677: LD_ADDR_EXP 97
35681: PUSH
35682: LD_INT 1
35684: ST_TO_ADDR
// end ;
35685: LD_VAR 0 1
35689: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
35690: LD_INT 0
35692: PPUSH
35693: PPUSH
35694: PPUSH
35695: PPUSH
35696: PPUSH
35697: PPUSH
// if not mc_bases then
35698: LD_EXP 99
35702: NOT
35703: IFFALSE 35707
// exit ;
35705: GO 35946
// for i = 1 to 8 do
35707: LD_ADDR_VAR 0 2
35711: PUSH
35712: DOUBLE
35713: LD_INT 1
35715: DEC
35716: ST_TO_ADDR
35717: LD_INT 8
35719: PUSH
35720: FOR_TO
35721: IFFALSE 35747
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
35723: LD_ADDR_EXP 126
35727: PUSH
35728: LD_EXP 126
35732: PPUSH
35733: LD_VAR 0 2
35737: PPUSH
35738: EMPTY
35739: PPUSH
35740: CALL_OW 1
35744: ST_TO_ADDR
35745: GO 35720
35747: POP
35748: POP
// tmp := [ ] ;
35749: LD_ADDR_VAR 0 5
35753: PUSH
35754: EMPTY
35755: ST_TO_ADDR
// for i = 1 to mc_sides do
35756: LD_ADDR_VAR 0 2
35760: PUSH
35761: DOUBLE
35762: LD_INT 1
35764: DEC
35765: ST_TO_ADDR
35766: LD_EXP 125
35770: PUSH
35771: FOR_TO
35772: IFFALSE 35830
// if not mc_sides [ i ] in tmp then
35774: LD_EXP 125
35778: PUSH
35779: LD_VAR 0 2
35783: ARRAY
35784: PUSH
35785: LD_VAR 0 5
35789: IN
35790: NOT
35791: IFFALSE 35828
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
35793: LD_ADDR_VAR 0 5
35797: PUSH
35798: LD_VAR 0 5
35802: PPUSH
35803: LD_VAR 0 5
35807: PUSH
35808: LD_INT 1
35810: PLUS
35811: PPUSH
35812: LD_EXP 125
35816: PUSH
35817: LD_VAR 0 2
35821: ARRAY
35822: PPUSH
35823: CALL_OW 2
35827: ST_TO_ADDR
35828: GO 35771
35830: POP
35831: POP
// if not tmp then
35832: LD_VAR 0 5
35836: NOT
35837: IFFALSE 35841
// exit ;
35839: GO 35946
// for j in tmp do
35841: LD_ADDR_VAR 0 3
35845: PUSH
35846: LD_VAR 0 5
35850: PUSH
35851: FOR_IN
35852: IFFALSE 35944
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
35854: LD_ADDR_VAR 0 6
35858: PUSH
35859: LD_INT 22
35861: PUSH
35862: LD_VAR 0 3
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PPUSH
35871: CALL_OW 69
35875: ST_TO_ADDR
// if not un then
35876: LD_VAR 0 6
35880: NOT
35881: IFFALSE 35885
// continue ;
35883: GO 35851
// nation := GetNation ( un [ 1 ] ) ;
35885: LD_ADDR_VAR 0 4
35889: PUSH
35890: LD_VAR 0 6
35894: PUSH
35895: LD_INT 1
35897: ARRAY
35898: PPUSH
35899: CALL_OW 248
35903: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
35904: LD_ADDR_EXP 126
35908: PUSH
35909: LD_EXP 126
35913: PPUSH
35914: LD_VAR 0 3
35918: PPUSH
35919: LD_VAR 0 3
35923: PPUSH
35924: LD_VAR 0 4
35928: PPUSH
35929: LD_INT 1
35931: PPUSH
35932: CALL 61728 0 3
35936: PPUSH
35937: CALL_OW 1
35941: ST_TO_ADDR
// end ;
35942: GO 35851
35944: POP
35945: POP
// end ;
35946: LD_VAR 0 1
35950: RET
// export function MC_InitSides ( ) ; var i ; begin
35951: LD_INT 0
35953: PPUSH
35954: PPUSH
// if not mc_bases then
35955: LD_EXP 99
35959: NOT
35960: IFFALSE 35964
// exit ;
35962: GO 36038
// for i = 1 to mc_bases do
35964: LD_ADDR_VAR 0 2
35968: PUSH
35969: DOUBLE
35970: LD_INT 1
35972: DEC
35973: ST_TO_ADDR
35974: LD_EXP 99
35978: PUSH
35979: FOR_TO
35980: IFFALSE 36036
// if mc_bases [ i ] then
35982: LD_EXP 99
35986: PUSH
35987: LD_VAR 0 2
35991: ARRAY
35992: IFFALSE 36034
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
35994: LD_ADDR_EXP 125
35998: PUSH
35999: LD_EXP 125
36003: PPUSH
36004: LD_VAR 0 2
36008: PPUSH
36009: LD_EXP 99
36013: PUSH
36014: LD_VAR 0 2
36018: ARRAY
36019: PUSH
36020: LD_INT 1
36022: ARRAY
36023: PPUSH
36024: CALL_OW 255
36028: PPUSH
36029: CALL_OW 1
36033: ST_TO_ADDR
36034: GO 35979
36036: POP
36037: POP
// end ;
36038: LD_VAR 0 1
36042: RET
// every 0 0$01 trigger skirmish do
36043: LD_EXP 97
36047: IFFALSE 36201
36049: GO 36051
36051: DISABLE
// begin enable ;
36052: ENABLE
// MC_CheckBuildings ( ) ;
36053: CALL 40690 0 0
// MC_CheckPeopleLife ( ) ;
36057: CALL 40815 0 0
// RaiseSailEvent ( 100 ) ;
36061: LD_INT 100
36063: PPUSH
36064: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
36068: LD_INT 103
36070: PPUSH
36071: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
36075: LD_INT 104
36077: PPUSH
36078: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
36082: LD_INT 105
36084: PPUSH
36085: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
36089: LD_INT 106
36091: PPUSH
36092: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
36096: LD_INT 107
36098: PPUSH
36099: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
36103: LD_INT 108
36105: PPUSH
36106: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
36110: LD_INT 109
36112: PPUSH
36113: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
36117: LD_INT 110
36119: PPUSH
36120: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
36124: LD_INT 111
36126: PPUSH
36127: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
36131: LD_INT 112
36133: PPUSH
36134: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
36138: LD_INT 113
36140: PPUSH
36141: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
36145: LD_INT 120
36147: PPUSH
36148: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
36152: LD_INT 121
36154: PPUSH
36155: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
36159: LD_INT 122
36161: PPUSH
36162: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
36166: LD_INT 123
36168: PPUSH
36169: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
36173: LD_INT 124
36175: PPUSH
36176: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
36180: LD_INT 125
36182: PPUSH
36183: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
36187: LD_INT 126
36189: PPUSH
36190: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
36194: LD_INT 200
36196: PPUSH
36197: CALL_OW 427
// end ;
36201: END
// on SailEvent ( event ) do begin if event < 100 then
36202: LD_VAR 0 1
36206: PUSH
36207: LD_INT 100
36209: LESS
36210: IFFALSE 36221
// CustomEvent ( event ) ;
36212: LD_VAR 0 1
36216: PPUSH
36217: CALL 31861 0 1
// if event = 100 then
36221: LD_VAR 0 1
36225: PUSH
36226: LD_INT 100
36228: EQUAL
36229: IFFALSE 36235
// MC_ClassManager ( ) ;
36231: CALL 36627 0 0
// if event = 101 then
36235: LD_VAR 0 1
36239: PUSH
36240: LD_INT 101
36242: EQUAL
36243: IFFALSE 36249
// MC_RepairBuildings ( ) ;
36245: CALL 41411 0 0
// if event = 102 then
36249: LD_VAR 0 1
36253: PUSH
36254: LD_INT 102
36256: EQUAL
36257: IFFALSE 36263
// MC_Heal ( ) ;
36259: CALL 41817 0 0
// if event = 103 then
36263: LD_VAR 0 1
36267: PUSH
36268: LD_INT 103
36270: EQUAL
36271: IFFALSE 36277
// MC_Build ( ) ;
36273: CALL 42239 0 0
// if event = 104 then
36277: LD_VAR 0 1
36281: PUSH
36282: LD_INT 104
36284: EQUAL
36285: IFFALSE 36291
// MC_TurretWeapon ( ) ;
36287: CALL 43852 0 0
// if event = 105 then
36291: LD_VAR 0 1
36295: PUSH
36296: LD_INT 105
36298: EQUAL
36299: IFFALSE 36305
// MC_BuildUpgrade ( ) ;
36301: CALL 43403 0 0
// if event = 106 then
36305: LD_VAR 0 1
36309: PUSH
36310: LD_INT 106
36312: EQUAL
36313: IFFALSE 36319
// MC_PlantMines ( ) ;
36315: CALL 44282 0 0
// if event = 107 then
36319: LD_VAR 0 1
36323: PUSH
36324: LD_INT 107
36326: EQUAL
36327: IFFALSE 36333
// MC_CollectCrates ( ) ;
36329: CALL 45316 0 0
// if event = 108 then
36333: LD_VAR 0 1
36337: PUSH
36338: LD_INT 108
36340: EQUAL
36341: IFFALSE 36347
// MC_LinkRemoteControl ( ) ;
36343: CALL 47073 0 0
// if event = 109 then
36347: LD_VAR 0 1
36351: PUSH
36352: LD_INT 109
36354: EQUAL
36355: IFFALSE 36361
// MC_ProduceVehicle ( ) ;
36357: CALL 47254 0 0
// if event = 110 then
36361: LD_VAR 0 1
36365: PUSH
36366: LD_INT 110
36368: EQUAL
36369: IFFALSE 36375
// MC_SendAttack ( ) ;
36371: CALL 47735 0 0
// if event = 111 then
36375: LD_VAR 0 1
36379: PUSH
36380: LD_INT 111
36382: EQUAL
36383: IFFALSE 36389
// MC_Defend ( ) ;
36385: CALL 47843 0 0
// if event = 112 then
36389: LD_VAR 0 1
36393: PUSH
36394: LD_INT 112
36396: EQUAL
36397: IFFALSE 36403
// MC_Research ( ) ;
36399: CALL 48470 0 0
// if event = 113 then
36403: LD_VAR 0 1
36407: PUSH
36408: LD_INT 113
36410: EQUAL
36411: IFFALSE 36417
// MC_MinesTrigger ( ) ;
36413: CALL 49584 0 0
// if event = 120 then
36417: LD_VAR 0 1
36421: PUSH
36422: LD_INT 120
36424: EQUAL
36425: IFFALSE 36431
// MC_RepairVehicle ( ) ;
36427: CALL 49683 0 0
// if event = 121 then
36431: LD_VAR 0 1
36435: PUSH
36436: LD_INT 121
36438: EQUAL
36439: IFFALSE 36445
// MC_TameApe ( ) ;
36441: CALL 50426 0 0
// if event = 122 then
36445: LD_VAR 0 1
36449: PUSH
36450: LD_INT 122
36452: EQUAL
36453: IFFALSE 36459
// MC_ChangeApeClass ( ) ;
36455: CALL 51255 0 0
// if event = 123 then
36459: LD_VAR 0 1
36463: PUSH
36464: LD_INT 123
36466: EQUAL
36467: IFFALSE 36473
// MC_Bazooka ( ) ;
36469: CALL 51905 0 0
// if event = 124 then
36473: LD_VAR 0 1
36477: PUSH
36478: LD_INT 124
36480: EQUAL
36481: IFFALSE 36487
// MC_TeleportExit ( ) ;
36483: CALL 52103 0 0
// if event = 125 then
36487: LD_VAR 0 1
36491: PUSH
36492: LD_INT 125
36494: EQUAL
36495: IFFALSE 36501
// MC_Deposits ( ) ;
36497: CALL 52750 0 0
// if event = 126 then
36501: LD_VAR 0 1
36505: PUSH
36506: LD_INT 126
36508: EQUAL
36509: IFFALSE 36515
// MC_RemoteDriver ( ) ;
36511: CALL 53375 0 0
// if event = 200 then
36515: LD_VAR 0 1
36519: PUSH
36520: LD_INT 200
36522: EQUAL
36523: IFFALSE 36529
// MC_Idle ( ) ;
36525: CALL 55108 0 0
// end ;
36529: PPOPN 1
36531: END
// export function MC_Reset ( base , tag ) ; var i ; begin
36532: LD_INT 0
36534: PPUSH
36535: PPUSH
// if not mc_bases [ base ] or not tag then
36536: LD_EXP 99
36540: PUSH
36541: LD_VAR 0 1
36545: ARRAY
36546: NOT
36547: PUSH
36548: LD_VAR 0 2
36552: NOT
36553: OR
36554: IFFALSE 36558
// exit ;
36556: GO 36622
// for i in mc_bases [ base ] union mc_ape [ base ] do
36558: LD_ADDR_VAR 0 4
36562: PUSH
36563: LD_EXP 99
36567: PUSH
36568: LD_VAR 0 1
36572: ARRAY
36573: PUSH
36574: LD_EXP 128
36578: PUSH
36579: LD_VAR 0 1
36583: ARRAY
36584: UNION
36585: PUSH
36586: FOR_IN
36587: IFFALSE 36620
// if GetTag ( i ) = tag then
36589: LD_VAR 0 4
36593: PPUSH
36594: CALL_OW 110
36598: PUSH
36599: LD_VAR 0 2
36603: EQUAL
36604: IFFALSE 36618
// SetTag ( i , 0 ) ;
36606: LD_VAR 0 4
36610: PPUSH
36611: LD_INT 0
36613: PPUSH
36614: CALL_OW 109
36618: GO 36586
36620: POP
36621: POP
// end ;
36622: LD_VAR 0 3
36626: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
36627: LD_INT 0
36629: PPUSH
36630: PPUSH
36631: PPUSH
36632: PPUSH
36633: PPUSH
36634: PPUSH
36635: PPUSH
36636: PPUSH
// if not mc_bases then
36637: LD_EXP 99
36641: NOT
36642: IFFALSE 36646
// exit ;
36644: GO 37104
// for i = 1 to mc_bases do
36646: LD_ADDR_VAR 0 2
36650: PUSH
36651: DOUBLE
36652: LD_INT 1
36654: DEC
36655: ST_TO_ADDR
36656: LD_EXP 99
36660: PUSH
36661: FOR_TO
36662: IFFALSE 37102
// begin tmp := MC_ClassCheckReq ( i ) ;
36664: LD_ADDR_VAR 0 4
36668: PUSH
36669: LD_VAR 0 2
36673: PPUSH
36674: CALL 37109 0 1
36678: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
36679: LD_ADDR_EXP 140
36683: PUSH
36684: LD_EXP 140
36688: PPUSH
36689: LD_VAR 0 2
36693: PPUSH
36694: LD_VAR 0 4
36698: PPUSH
36699: CALL_OW 1
36703: ST_TO_ADDR
// if not tmp then
36704: LD_VAR 0 4
36708: NOT
36709: IFFALSE 36713
// continue ;
36711: GO 36661
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
36713: LD_ADDR_VAR 0 6
36717: PUSH
36718: LD_EXP 99
36722: PUSH
36723: LD_VAR 0 2
36727: ARRAY
36728: PPUSH
36729: LD_INT 2
36731: PUSH
36732: LD_INT 30
36734: PUSH
36735: LD_INT 4
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 30
36744: PUSH
36745: LD_INT 5
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: LIST
36756: PPUSH
36757: CALL_OW 72
36761: PUSH
36762: LD_EXP 99
36766: PUSH
36767: LD_VAR 0 2
36771: ARRAY
36772: PPUSH
36773: LD_INT 2
36775: PUSH
36776: LD_INT 30
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 30
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: PPUSH
36801: CALL_OW 72
36805: PUSH
36806: LD_EXP 99
36810: PUSH
36811: LD_VAR 0 2
36815: ARRAY
36816: PPUSH
36817: LD_INT 30
36819: PUSH
36820: LD_INT 3
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PPUSH
36827: CALL_OW 72
36831: PUSH
36832: LD_EXP 99
36836: PUSH
36837: LD_VAR 0 2
36841: ARRAY
36842: PPUSH
36843: LD_INT 2
36845: PUSH
36846: LD_INT 30
36848: PUSH
36849: LD_INT 6
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 30
36858: PUSH
36859: LD_INT 7
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: LD_INT 30
36868: PUSH
36869: LD_INT 8
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: PPUSH
36882: CALL_OW 72
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: ST_TO_ADDR
// for j = 1 to 4 do
36893: LD_ADDR_VAR 0 3
36897: PUSH
36898: DOUBLE
36899: LD_INT 1
36901: DEC
36902: ST_TO_ADDR
36903: LD_INT 4
36905: PUSH
36906: FOR_TO
36907: IFFALSE 37098
// begin if not tmp [ j ] then
36909: LD_VAR 0 4
36913: PUSH
36914: LD_VAR 0 3
36918: ARRAY
36919: NOT
36920: IFFALSE 36924
// continue ;
36922: GO 36906
// for p in tmp [ j ] do
36924: LD_ADDR_VAR 0 5
36928: PUSH
36929: LD_VAR 0 4
36933: PUSH
36934: LD_VAR 0 3
36938: ARRAY
36939: PUSH
36940: FOR_IN
36941: IFFALSE 37094
// begin if not b [ j ] then
36943: LD_VAR 0 6
36947: PUSH
36948: LD_VAR 0 3
36952: ARRAY
36953: NOT
36954: IFFALSE 36958
// break ;
36956: GO 37094
// e := 0 ;
36958: LD_ADDR_VAR 0 7
36962: PUSH
36963: LD_INT 0
36965: ST_TO_ADDR
// for k in b [ j ] do
36966: LD_ADDR_VAR 0 8
36970: PUSH
36971: LD_VAR 0 6
36975: PUSH
36976: LD_VAR 0 3
36980: ARRAY
36981: PUSH
36982: FOR_IN
36983: IFFALSE 37010
// if IsNotFull ( k ) then
36985: LD_VAR 0 8
36989: PPUSH
36990: CALL 65754 0 1
36994: IFFALSE 37008
// begin e := k ;
36996: LD_ADDR_VAR 0 7
37000: PUSH
37001: LD_VAR 0 8
37005: ST_TO_ADDR
// break ;
37006: GO 37010
// end ;
37008: GO 36982
37010: POP
37011: POP
// if e and not UnitGoingToBuilding ( p , e ) then
37012: LD_VAR 0 7
37016: PUSH
37017: LD_VAR 0 5
37021: PPUSH
37022: LD_VAR 0 7
37026: PPUSH
37027: CALL 102742 0 2
37031: NOT
37032: AND
37033: IFFALSE 37092
// begin if IsInUnit ( p ) then
37035: LD_VAR 0 5
37039: PPUSH
37040: CALL_OW 310
37044: IFFALSE 37055
// ComExitBuilding ( p ) ;
37046: LD_VAR 0 5
37050: PPUSH
37051: CALL_OW 122
// ComEnterUnit ( p , e ) ;
37055: LD_VAR 0 5
37059: PPUSH
37060: LD_VAR 0 7
37064: PPUSH
37065: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
37069: LD_VAR 0 5
37073: PPUSH
37074: LD_VAR 0 3
37078: PPUSH
37079: CALL_OW 183
// AddComExitBuilding ( p ) ;
37083: LD_VAR 0 5
37087: PPUSH
37088: CALL_OW 182
// end ; end ;
37092: GO 36940
37094: POP
37095: POP
// end ;
37096: GO 36906
37098: POP
37099: POP
// end ;
37100: GO 36661
37102: POP
37103: POP
// end ;
37104: LD_VAR 0 1
37108: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
37109: LD_INT 0
37111: PPUSH
37112: PPUSH
37113: PPUSH
37114: PPUSH
37115: PPUSH
37116: PPUSH
37117: PPUSH
37118: PPUSH
37119: PPUSH
37120: PPUSH
37121: PPUSH
37122: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37123: LD_VAR 0 1
37127: NOT
37128: PUSH
37129: LD_EXP 99
37133: PUSH
37134: LD_VAR 0 1
37138: ARRAY
37139: NOT
37140: OR
37141: PUSH
37142: LD_EXP 99
37146: PUSH
37147: LD_VAR 0 1
37151: ARRAY
37152: PPUSH
37153: LD_INT 2
37155: PUSH
37156: LD_INT 30
37158: PUSH
37159: LD_INT 0
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 30
37168: PUSH
37169: LD_INT 1
37171: PUSH
37172: EMPTY
37173: LIST
37174: LIST
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: LIST
37180: PPUSH
37181: CALL_OW 72
37185: NOT
37186: OR
37187: IFFALSE 37191
// exit ;
37189: GO 40685
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37191: LD_ADDR_VAR 0 4
37195: PUSH
37196: LD_EXP 99
37200: PUSH
37201: LD_VAR 0 1
37205: ARRAY
37206: PPUSH
37207: LD_INT 2
37209: PUSH
37210: LD_INT 25
37212: PUSH
37213: LD_INT 1
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 25
37222: PUSH
37223: LD_INT 2
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 25
37232: PUSH
37233: LD_INT 3
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 25
37242: PUSH
37243: LD_INT 4
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 25
37252: PUSH
37253: LD_INT 5
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 25
37262: PUSH
37263: LD_INT 8
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 25
37272: PUSH
37273: LD_INT 9
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: LIST
37287: LIST
37288: LIST
37289: PPUSH
37290: CALL_OW 72
37294: ST_TO_ADDR
// for i in tmp do
37295: LD_ADDR_VAR 0 3
37299: PUSH
37300: LD_VAR 0 4
37304: PUSH
37305: FOR_IN
37306: IFFALSE 37337
// if GetTag ( i ) then
37308: LD_VAR 0 3
37312: PPUSH
37313: CALL_OW 110
37317: IFFALSE 37335
// tmp := tmp diff i ;
37319: LD_ADDR_VAR 0 4
37323: PUSH
37324: LD_VAR 0 4
37328: PUSH
37329: LD_VAR 0 3
37333: DIFF
37334: ST_TO_ADDR
37335: GO 37305
37337: POP
37338: POP
// if not tmp then
37339: LD_VAR 0 4
37343: NOT
37344: IFFALSE 37348
// exit ;
37346: GO 40685
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37348: LD_ADDR_VAR 0 5
37352: PUSH
37353: LD_EXP 99
37357: PUSH
37358: LD_VAR 0 1
37362: ARRAY
37363: PPUSH
37364: LD_INT 2
37366: PUSH
37367: LD_INT 25
37369: PUSH
37370: LD_INT 1
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 25
37379: PUSH
37380: LD_INT 5
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 25
37389: PUSH
37390: LD_INT 8
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 25
37399: PUSH
37400: LD_INT 9
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: PPUSH
37414: CALL_OW 72
37418: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
37419: LD_ADDR_VAR 0 6
37423: PUSH
37424: LD_EXP 99
37428: PUSH
37429: LD_VAR 0 1
37433: ARRAY
37434: PPUSH
37435: LD_INT 25
37437: PUSH
37438: LD_INT 2
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PPUSH
37445: CALL_OW 72
37449: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
37450: LD_ADDR_VAR 0 7
37454: PUSH
37455: LD_EXP 99
37459: PUSH
37460: LD_VAR 0 1
37464: ARRAY
37465: PPUSH
37466: LD_INT 25
37468: PUSH
37469: LD_INT 3
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PPUSH
37476: CALL_OW 72
37480: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
37481: LD_ADDR_VAR 0 8
37485: PUSH
37486: LD_EXP 99
37490: PUSH
37491: LD_VAR 0 1
37495: ARRAY
37496: PPUSH
37497: LD_INT 25
37499: PUSH
37500: LD_INT 4
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 24
37509: PUSH
37510: LD_INT 251
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PPUSH
37521: CALL_OW 72
37525: ST_TO_ADDR
// if mc_scan [ base ] then
37526: LD_EXP 122
37530: PUSH
37531: LD_VAR 0 1
37535: ARRAY
37536: IFFALSE 37997
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
37538: LD_ADDR_EXP 141
37542: PUSH
37543: LD_EXP 141
37547: PPUSH
37548: LD_VAR 0 1
37552: PPUSH
37553: LD_INT 4
37555: PPUSH
37556: CALL_OW 1
37560: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37561: LD_ADDR_VAR 0 12
37565: PUSH
37566: LD_EXP 99
37570: PUSH
37571: LD_VAR 0 1
37575: ARRAY
37576: PPUSH
37577: LD_INT 2
37579: PUSH
37580: LD_INT 30
37582: PUSH
37583: LD_INT 4
37585: PUSH
37586: EMPTY
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 30
37592: PUSH
37593: LD_INT 5
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: LIST
37604: PPUSH
37605: CALL_OW 72
37609: ST_TO_ADDR
// if not b then
37610: LD_VAR 0 12
37614: NOT
37615: IFFALSE 37619
// exit ;
37617: GO 40685
// p := [ ] ;
37619: LD_ADDR_VAR 0 11
37623: PUSH
37624: EMPTY
37625: ST_TO_ADDR
// if sci >= 2 then
37626: LD_VAR 0 8
37630: PUSH
37631: LD_INT 2
37633: GREATEREQUAL
37634: IFFALSE 37665
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
37636: LD_ADDR_VAR 0 8
37640: PUSH
37641: LD_VAR 0 8
37645: PUSH
37646: LD_INT 1
37648: ARRAY
37649: PUSH
37650: LD_VAR 0 8
37654: PUSH
37655: LD_INT 2
37657: ARRAY
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: ST_TO_ADDR
37663: GO 37726
// if sci = 1 then
37665: LD_VAR 0 8
37669: PUSH
37670: LD_INT 1
37672: EQUAL
37673: IFFALSE 37694
// sci := [ sci [ 1 ] ] else
37675: LD_ADDR_VAR 0 8
37679: PUSH
37680: LD_VAR 0 8
37684: PUSH
37685: LD_INT 1
37687: ARRAY
37688: PUSH
37689: EMPTY
37690: LIST
37691: ST_TO_ADDR
37692: GO 37726
// if sci = 0 then
37694: LD_VAR 0 8
37698: PUSH
37699: LD_INT 0
37701: EQUAL
37702: IFFALSE 37726
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
37704: LD_ADDR_VAR 0 11
37708: PUSH
37709: LD_VAR 0 4
37713: PPUSH
37714: LD_INT 4
37716: PPUSH
37717: CALL 102605 0 2
37721: PUSH
37722: LD_INT 1
37724: ARRAY
37725: ST_TO_ADDR
// if eng > 4 then
37726: LD_VAR 0 6
37730: PUSH
37731: LD_INT 4
37733: GREATER
37734: IFFALSE 37780
// for i = eng downto 4 do
37736: LD_ADDR_VAR 0 3
37740: PUSH
37741: DOUBLE
37742: LD_VAR 0 6
37746: INC
37747: ST_TO_ADDR
37748: LD_INT 4
37750: PUSH
37751: FOR_DOWNTO
37752: IFFALSE 37778
// eng := eng diff eng [ i ] ;
37754: LD_ADDR_VAR 0 6
37758: PUSH
37759: LD_VAR 0 6
37763: PUSH
37764: LD_VAR 0 6
37768: PUSH
37769: LD_VAR 0 3
37773: ARRAY
37774: DIFF
37775: ST_TO_ADDR
37776: GO 37751
37778: POP
37779: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
37780: LD_ADDR_VAR 0 4
37784: PUSH
37785: LD_VAR 0 4
37789: PUSH
37790: LD_VAR 0 5
37794: PUSH
37795: LD_VAR 0 6
37799: UNION
37800: PUSH
37801: LD_VAR 0 7
37805: UNION
37806: PUSH
37807: LD_VAR 0 8
37811: UNION
37812: DIFF
37813: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
37814: LD_ADDR_VAR 0 13
37818: PUSH
37819: LD_EXP 99
37823: PUSH
37824: LD_VAR 0 1
37828: ARRAY
37829: PPUSH
37830: LD_INT 2
37832: PUSH
37833: LD_INT 30
37835: PUSH
37836: LD_INT 32
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 30
37845: PUSH
37846: LD_INT 31
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: LIST
37857: PPUSH
37858: CALL_OW 72
37862: PUSH
37863: LD_EXP 99
37867: PUSH
37868: LD_VAR 0 1
37872: ARRAY
37873: PPUSH
37874: LD_INT 2
37876: PUSH
37877: LD_INT 30
37879: PUSH
37880: LD_INT 4
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: PUSH
37887: LD_INT 30
37889: PUSH
37890: LD_INT 5
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: LIST
37901: PPUSH
37902: CALL_OW 72
37906: PUSH
37907: LD_INT 6
37909: MUL
37910: PLUS
37911: ST_TO_ADDR
// if bcount < tmp then
37912: LD_VAR 0 13
37916: PUSH
37917: LD_VAR 0 4
37921: LESS
37922: IFFALSE 37968
// for i = tmp downto bcount do
37924: LD_ADDR_VAR 0 3
37928: PUSH
37929: DOUBLE
37930: LD_VAR 0 4
37934: INC
37935: ST_TO_ADDR
37936: LD_VAR 0 13
37940: PUSH
37941: FOR_DOWNTO
37942: IFFALSE 37966
// tmp := Delete ( tmp , tmp ) ;
37944: LD_ADDR_VAR 0 4
37948: PUSH
37949: LD_VAR 0 4
37953: PPUSH
37954: LD_VAR 0 4
37958: PPUSH
37959: CALL_OW 3
37963: ST_TO_ADDR
37964: GO 37941
37966: POP
37967: POP
// result := [ tmp , 0 , 0 , p ] ;
37968: LD_ADDR_VAR 0 2
37972: PUSH
37973: LD_VAR 0 4
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: LD_VAR 0 11
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: ST_TO_ADDR
// exit ;
37995: GO 40685
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
37997: LD_EXP 99
38001: PUSH
38002: LD_VAR 0 1
38006: ARRAY
38007: PPUSH
38008: LD_INT 2
38010: PUSH
38011: LD_INT 30
38013: PUSH
38014: LD_INT 6
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 30
38023: PUSH
38024: LD_INT 7
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 30
38033: PUSH
38034: LD_INT 8
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: PPUSH
38047: CALL_OW 72
38051: NOT
38052: PUSH
38053: LD_EXP 99
38057: PUSH
38058: LD_VAR 0 1
38062: ARRAY
38063: PPUSH
38064: LD_INT 30
38066: PUSH
38067: LD_INT 3
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PPUSH
38074: CALL_OW 72
38078: NOT
38079: AND
38080: IFFALSE 38152
// begin if eng = tmp then
38082: LD_VAR 0 6
38086: PUSH
38087: LD_VAR 0 4
38091: EQUAL
38092: IFFALSE 38096
// exit ;
38094: GO 40685
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
38096: LD_ADDR_EXP 141
38100: PUSH
38101: LD_EXP 141
38105: PPUSH
38106: LD_VAR 0 1
38110: PPUSH
38111: LD_INT 1
38113: PPUSH
38114: CALL_OW 1
38118: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
38119: LD_ADDR_VAR 0 2
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: LD_VAR 0 4
38131: PUSH
38132: LD_VAR 0 6
38136: DIFF
38137: PUSH
38138: LD_INT 0
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: ST_TO_ADDR
// exit ;
38150: GO 40685
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38152: LD_EXP 126
38156: PUSH
38157: LD_EXP 125
38161: PUSH
38162: LD_VAR 0 1
38166: ARRAY
38167: ARRAY
38168: PUSH
38169: LD_EXP 99
38173: PUSH
38174: LD_VAR 0 1
38178: ARRAY
38179: PPUSH
38180: LD_INT 2
38182: PUSH
38183: LD_INT 30
38185: PUSH
38186: LD_INT 6
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 30
38195: PUSH
38196: LD_INT 7
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 30
38205: PUSH
38206: LD_INT 8
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: LIST
38217: LIST
38218: PPUSH
38219: CALL_OW 72
38223: AND
38224: PUSH
38225: LD_EXP 99
38229: PUSH
38230: LD_VAR 0 1
38234: ARRAY
38235: PPUSH
38236: LD_INT 30
38238: PUSH
38239: LD_INT 3
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PPUSH
38246: CALL_OW 72
38250: NOT
38251: AND
38252: IFFALSE 38466
// begin if sci >= 6 then
38254: LD_VAR 0 8
38258: PUSH
38259: LD_INT 6
38261: GREATEREQUAL
38262: IFFALSE 38266
// exit ;
38264: GO 40685
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
38266: LD_ADDR_EXP 141
38270: PUSH
38271: LD_EXP 141
38275: PPUSH
38276: LD_VAR 0 1
38280: PPUSH
38281: LD_INT 2
38283: PPUSH
38284: CALL_OW 1
38288: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
38289: LD_ADDR_VAR 0 9
38293: PUSH
38294: LD_VAR 0 4
38298: PUSH
38299: LD_VAR 0 8
38303: DIFF
38304: PPUSH
38305: LD_INT 4
38307: PPUSH
38308: CALL 102605 0 2
38312: ST_TO_ADDR
// p := [ ] ;
38313: LD_ADDR_VAR 0 11
38317: PUSH
38318: EMPTY
38319: ST_TO_ADDR
// if sci < 6 and sort > 6 then
38320: LD_VAR 0 8
38324: PUSH
38325: LD_INT 6
38327: LESS
38328: PUSH
38329: LD_VAR 0 9
38333: PUSH
38334: LD_INT 6
38336: GREATER
38337: AND
38338: IFFALSE 38419
// begin for i = 1 to 6 - sci do
38340: LD_ADDR_VAR 0 3
38344: PUSH
38345: DOUBLE
38346: LD_INT 1
38348: DEC
38349: ST_TO_ADDR
38350: LD_INT 6
38352: PUSH
38353: LD_VAR 0 8
38357: MINUS
38358: PUSH
38359: FOR_TO
38360: IFFALSE 38415
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
38362: LD_ADDR_VAR 0 11
38366: PUSH
38367: LD_VAR 0 11
38371: PPUSH
38372: LD_VAR 0 11
38376: PUSH
38377: LD_INT 1
38379: PLUS
38380: PPUSH
38381: LD_VAR 0 9
38385: PUSH
38386: LD_INT 1
38388: ARRAY
38389: PPUSH
38390: CALL_OW 2
38394: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
38395: LD_ADDR_VAR 0 9
38399: PUSH
38400: LD_VAR 0 9
38404: PPUSH
38405: LD_INT 1
38407: PPUSH
38408: CALL_OW 3
38412: ST_TO_ADDR
// end ;
38413: GO 38359
38415: POP
38416: POP
// end else
38417: GO 38439
// if sort then
38419: LD_VAR 0 9
38423: IFFALSE 38439
// p := sort [ 1 ] ;
38425: LD_ADDR_VAR 0 11
38429: PUSH
38430: LD_VAR 0 9
38434: PUSH
38435: LD_INT 1
38437: ARRAY
38438: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
38439: LD_ADDR_VAR 0 2
38443: PUSH
38444: LD_INT 0
38446: PUSH
38447: LD_INT 0
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_VAR 0 11
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: LIST
38462: LIST
38463: ST_TO_ADDR
// exit ;
38464: GO 40685
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38466: LD_EXP 126
38470: PUSH
38471: LD_EXP 125
38475: PUSH
38476: LD_VAR 0 1
38480: ARRAY
38481: ARRAY
38482: PUSH
38483: LD_EXP 99
38487: PUSH
38488: LD_VAR 0 1
38492: ARRAY
38493: PPUSH
38494: LD_INT 2
38496: PUSH
38497: LD_INT 30
38499: PUSH
38500: LD_INT 6
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 30
38509: PUSH
38510: LD_INT 7
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 30
38519: PUSH
38520: LD_INT 8
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: PPUSH
38533: CALL_OW 72
38537: AND
38538: PUSH
38539: LD_EXP 99
38543: PUSH
38544: LD_VAR 0 1
38548: ARRAY
38549: PPUSH
38550: LD_INT 30
38552: PUSH
38553: LD_INT 3
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PPUSH
38560: CALL_OW 72
38564: AND
38565: IFFALSE 39299
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
38567: LD_ADDR_EXP 141
38571: PUSH
38572: LD_EXP 141
38576: PPUSH
38577: LD_VAR 0 1
38581: PPUSH
38582: LD_INT 3
38584: PPUSH
38585: CALL_OW 1
38589: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
38590: LD_ADDR_VAR 0 2
38594: PUSH
38595: LD_INT 0
38597: PUSH
38598: LD_INT 0
38600: PUSH
38601: LD_INT 0
38603: PUSH
38604: LD_INT 0
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: ST_TO_ADDR
// if not eng then
38613: LD_VAR 0 6
38617: NOT
38618: IFFALSE 38681
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
38620: LD_ADDR_VAR 0 11
38624: PUSH
38625: LD_VAR 0 4
38629: PPUSH
38630: LD_INT 2
38632: PPUSH
38633: CALL 102605 0 2
38637: PUSH
38638: LD_INT 1
38640: ARRAY
38641: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
38642: LD_ADDR_VAR 0 2
38646: PUSH
38647: LD_VAR 0 2
38651: PPUSH
38652: LD_INT 2
38654: PPUSH
38655: LD_VAR 0 11
38659: PPUSH
38660: CALL_OW 1
38664: ST_TO_ADDR
// tmp := tmp diff p ;
38665: LD_ADDR_VAR 0 4
38669: PUSH
38670: LD_VAR 0 4
38674: PUSH
38675: LD_VAR 0 11
38679: DIFF
38680: ST_TO_ADDR
// end ; if tmp and sci < 6 then
38681: LD_VAR 0 4
38685: PUSH
38686: LD_VAR 0 8
38690: PUSH
38691: LD_INT 6
38693: LESS
38694: AND
38695: IFFALSE 38883
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
38697: LD_ADDR_VAR 0 9
38701: PUSH
38702: LD_VAR 0 4
38706: PUSH
38707: LD_VAR 0 8
38711: PUSH
38712: LD_VAR 0 7
38716: UNION
38717: DIFF
38718: PPUSH
38719: LD_INT 4
38721: PPUSH
38722: CALL 102605 0 2
38726: ST_TO_ADDR
// p := [ ] ;
38727: LD_ADDR_VAR 0 11
38731: PUSH
38732: EMPTY
38733: ST_TO_ADDR
// if sort then
38734: LD_VAR 0 9
38738: IFFALSE 38854
// for i = 1 to 6 - sci do
38740: LD_ADDR_VAR 0 3
38744: PUSH
38745: DOUBLE
38746: LD_INT 1
38748: DEC
38749: ST_TO_ADDR
38750: LD_INT 6
38752: PUSH
38753: LD_VAR 0 8
38757: MINUS
38758: PUSH
38759: FOR_TO
38760: IFFALSE 38852
// begin if i = sort then
38762: LD_VAR 0 3
38766: PUSH
38767: LD_VAR 0 9
38771: EQUAL
38772: IFFALSE 38776
// break ;
38774: GO 38852
// if GetClass ( i ) = 4 then
38776: LD_VAR 0 3
38780: PPUSH
38781: CALL_OW 257
38785: PUSH
38786: LD_INT 4
38788: EQUAL
38789: IFFALSE 38793
// continue ;
38791: GO 38759
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38793: LD_ADDR_VAR 0 11
38797: PUSH
38798: LD_VAR 0 11
38802: PPUSH
38803: LD_VAR 0 11
38807: PUSH
38808: LD_INT 1
38810: PLUS
38811: PPUSH
38812: LD_VAR 0 9
38816: PUSH
38817: LD_VAR 0 3
38821: ARRAY
38822: PPUSH
38823: CALL_OW 2
38827: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38828: LD_ADDR_VAR 0 4
38832: PUSH
38833: LD_VAR 0 4
38837: PUSH
38838: LD_VAR 0 9
38842: PUSH
38843: LD_VAR 0 3
38847: ARRAY
38848: DIFF
38849: ST_TO_ADDR
// end ;
38850: GO 38759
38852: POP
38853: POP
// if p then
38854: LD_VAR 0 11
38858: IFFALSE 38883
// result := Replace ( result , 4 , p ) ;
38860: LD_ADDR_VAR 0 2
38864: PUSH
38865: LD_VAR 0 2
38869: PPUSH
38870: LD_INT 4
38872: PPUSH
38873: LD_VAR 0 11
38877: PPUSH
38878: CALL_OW 1
38882: ST_TO_ADDR
// end ; if tmp and mech < 6 then
38883: LD_VAR 0 4
38887: PUSH
38888: LD_VAR 0 7
38892: PUSH
38893: LD_INT 6
38895: LESS
38896: AND
38897: IFFALSE 39085
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
38899: LD_ADDR_VAR 0 9
38903: PUSH
38904: LD_VAR 0 4
38908: PUSH
38909: LD_VAR 0 8
38913: PUSH
38914: LD_VAR 0 7
38918: UNION
38919: DIFF
38920: PPUSH
38921: LD_INT 3
38923: PPUSH
38924: CALL 102605 0 2
38928: ST_TO_ADDR
// p := [ ] ;
38929: LD_ADDR_VAR 0 11
38933: PUSH
38934: EMPTY
38935: ST_TO_ADDR
// if sort then
38936: LD_VAR 0 9
38940: IFFALSE 39056
// for i = 1 to 6 - mech do
38942: LD_ADDR_VAR 0 3
38946: PUSH
38947: DOUBLE
38948: LD_INT 1
38950: DEC
38951: ST_TO_ADDR
38952: LD_INT 6
38954: PUSH
38955: LD_VAR 0 7
38959: MINUS
38960: PUSH
38961: FOR_TO
38962: IFFALSE 39054
// begin if i = sort then
38964: LD_VAR 0 3
38968: PUSH
38969: LD_VAR 0 9
38973: EQUAL
38974: IFFALSE 38978
// break ;
38976: GO 39054
// if GetClass ( i ) = 3 then
38978: LD_VAR 0 3
38982: PPUSH
38983: CALL_OW 257
38987: PUSH
38988: LD_INT 3
38990: EQUAL
38991: IFFALSE 38995
// continue ;
38993: GO 38961
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38995: LD_ADDR_VAR 0 11
38999: PUSH
39000: LD_VAR 0 11
39004: PPUSH
39005: LD_VAR 0 11
39009: PUSH
39010: LD_INT 1
39012: PLUS
39013: PPUSH
39014: LD_VAR 0 9
39018: PUSH
39019: LD_VAR 0 3
39023: ARRAY
39024: PPUSH
39025: CALL_OW 2
39029: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39030: LD_ADDR_VAR 0 4
39034: PUSH
39035: LD_VAR 0 4
39039: PUSH
39040: LD_VAR 0 9
39044: PUSH
39045: LD_VAR 0 3
39049: ARRAY
39050: DIFF
39051: ST_TO_ADDR
// end ;
39052: GO 38961
39054: POP
39055: POP
// if p then
39056: LD_VAR 0 11
39060: IFFALSE 39085
// result := Replace ( result , 3 , p ) ;
39062: LD_ADDR_VAR 0 2
39066: PUSH
39067: LD_VAR 0 2
39071: PPUSH
39072: LD_INT 3
39074: PPUSH
39075: LD_VAR 0 11
39079: PPUSH
39080: CALL_OW 1
39084: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
39085: LD_VAR 0 4
39089: PUSH
39090: LD_INT 6
39092: GREATER
39093: PUSH
39094: LD_VAR 0 6
39098: PUSH
39099: LD_INT 6
39101: LESS
39102: AND
39103: IFFALSE 39297
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
39105: LD_ADDR_VAR 0 9
39109: PUSH
39110: LD_VAR 0 4
39114: PUSH
39115: LD_VAR 0 8
39119: PUSH
39120: LD_VAR 0 7
39124: UNION
39125: PUSH
39126: LD_VAR 0 6
39130: UNION
39131: DIFF
39132: PPUSH
39133: LD_INT 2
39135: PPUSH
39136: CALL 102605 0 2
39140: ST_TO_ADDR
// p := [ ] ;
39141: LD_ADDR_VAR 0 11
39145: PUSH
39146: EMPTY
39147: ST_TO_ADDR
// if sort then
39148: LD_VAR 0 9
39152: IFFALSE 39268
// for i = 1 to 6 - eng do
39154: LD_ADDR_VAR 0 3
39158: PUSH
39159: DOUBLE
39160: LD_INT 1
39162: DEC
39163: ST_TO_ADDR
39164: LD_INT 6
39166: PUSH
39167: LD_VAR 0 6
39171: MINUS
39172: PUSH
39173: FOR_TO
39174: IFFALSE 39266
// begin if i = sort then
39176: LD_VAR 0 3
39180: PUSH
39181: LD_VAR 0 9
39185: EQUAL
39186: IFFALSE 39190
// break ;
39188: GO 39266
// if GetClass ( i ) = 2 then
39190: LD_VAR 0 3
39194: PPUSH
39195: CALL_OW 257
39199: PUSH
39200: LD_INT 2
39202: EQUAL
39203: IFFALSE 39207
// continue ;
39205: GO 39173
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39207: LD_ADDR_VAR 0 11
39211: PUSH
39212: LD_VAR 0 11
39216: PPUSH
39217: LD_VAR 0 11
39221: PUSH
39222: LD_INT 1
39224: PLUS
39225: PPUSH
39226: LD_VAR 0 9
39230: PUSH
39231: LD_VAR 0 3
39235: ARRAY
39236: PPUSH
39237: CALL_OW 2
39241: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39242: LD_ADDR_VAR 0 4
39246: PUSH
39247: LD_VAR 0 4
39251: PUSH
39252: LD_VAR 0 9
39256: PUSH
39257: LD_VAR 0 3
39261: ARRAY
39262: DIFF
39263: ST_TO_ADDR
// end ;
39264: GO 39173
39266: POP
39267: POP
// if p then
39268: LD_VAR 0 11
39272: IFFALSE 39297
// result := Replace ( result , 2 , p ) ;
39274: LD_ADDR_VAR 0 2
39278: PUSH
39279: LD_VAR 0 2
39283: PPUSH
39284: LD_INT 2
39286: PPUSH
39287: LD_VAR 0 11
39291: PPUSH
39292: CALL_OW 1
39296: ST_TO_ADDR
// end ; exit ;
39297: GO 40685
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
39299: LD_EXP 126
39303: PUSH
39304: LD_EXP 125
39308: PUSH
39309: LD_VAR 0 1
39313: ARRAY
39314: ARRAY
39315: NOT
39316: PUSH
39317: LD_EXP 99
39321: PUSH
39322: LD_VAR 0 1
39326: ARRAY
39327: PPUSH
39328: LD_INT 30
39330: PUSH
39331: LD_INT 3
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PPUSH
39338: CALL_OW 72
39342: AND
39343: PUSH
39344: LD_EXP 104
39348: PUSH
39349: LD_VAR 0 1
39353: ARRAY
39354: AND
39355: IFFALSE 39963
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
39357: LD_ADDR_EXP 141
39361: PUSH
39362: LD_EXP 141
39366: PPUSH
39367: LD_VAR 0 1
39371: PPUSH
39372: LD_INT 5
39374: PPUSH
39375: CALL_OW 1
39379: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39380: LD_ADDR_VAR 0 2
39384: PUSH
39385: LD_INT 0
39387: PUSH
39388: LD_INT 0
39390: PUSH
39391: LD_INT 0
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: ST_TO_ADDR
// if sci > 1 then
39403: LD_VAR 0 8
39407: PUSH
39408: LD_INT 1
39410: GREATER
39411: IFFALSE 39439
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
39413: LD_ADDR_VAR 0 4
39417: PUSH
39418: LD_VAR 0 4
39422: PUSH
39423: LD_VAR 0 8
39427: PUSH
39428: LD_VAR 0 8
39432: PUSH
39433: LD_INT 1
39435: ARRAY
39436: DIFF
39437: DIFF
39438: ST_TO_ADDR
// if tmp and not sci then
39439: LD_VAR 0 4
39443: PUSH
39444: LD_VAR 0 8
39448: NOT
39449: AND
39450: IFFALSE 39519
// begin sort := SortBySkill ( tmp , 4 ) ;
39452: LD_ADDR_VAR 0 9
39456: PUSH
39457: LD_VAR 0 4
39461: PPUSH
39462: LD_INT 4
39464: PPUSH
39465: CALL 102605 0 2
39469: ST_TO_ADDR
// if sort then
39470: LD_VAR 0 9
39474: IFFALSE 39490
// p := sort [ 1 ] ;
39476: LD_ADDR_VAR 0 11
39480: PUSH
39481: LD_VAR 0 9
39485: PUSH
39486: LD_INT 1
39488: ARRAY
39489: ST_TO_ADDR
// if p then
39490: LD_VAR 0 11
39494: IFFALSE 39519
// result := Replace ( result , 4 , p ) ;
39496: LD_ADDR_VAR 0 2
39500: PUSH
39501: LD_VAR 0 2
39505: PPUSH
39506: LD_INT 4
39508: PPUSH
39509: LD_VAR 0 11
39513: PPUSH
39514: CALL_OW 1
39518: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
39519: LD_ADDR_VAR 0 4
39523: PUSH
39524: LD_VAR 0 4
39528: PUSH
39529: LD_VAR 0 7
39533: DIFF
39534: ST_TO_ADDR
// if tmp and mech < 6 then
39535: LD_VAR 0 4
39539: PUSH
39540: LD_VAR 0 7
39544: PUSH
39545: LD_INT 6
39547: LESS
39548: AND
39549: IFFALSE 39737
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
39551: LD_ADDR_VAR 0 9
39555: PUSH
39556: LD_VAR 0 4
39560: PUSH
39561: LD_VAR 0 8
39565: PUSH
39566: LD_VAR 0 7
39570: UNION
39571: DIFF
39572: PPUSH
39573: LD_INT 3
39575: PPUSH
39576: CALL 102605 0 2
39580: ST_TO_ADDR
// p := [ ] ;
39581: LD_ADDR_VAR 0 11
39585: PUSH
39586: EMPTY
39587: ST_TO_ADDR
// if sort then
39588: LD_VAR 0 9
39592: IFFALSE 39708
// for i = 1 to 6 - mech do
39594: LD_ADDR_VAR 0 3
39598: PUSH
39599: DOUBLE
39600: LD_INT 1
39602: DEC
39603: ST_TO_ADDR
39604: LD_INT 6
39606: PUSH
39607: LD_VAR 0 7
39611: MINUS
39612: PUSH
39613: FOR_TO
39614: IFFALSE 39706
// begin if i = sort then
39616: LD_VAR 0 3
39620: PUSH
39621: LD_VAR 0 9
39625: EQUAL
39626: IFFALSE 39630
// break ;
39628: GO 39706
// if GetClass ( i ) = 3 then
39630: LD_VAR 0 3
39634: PPUSH
39635: CALL_OW 257
39639: PUSH
39640: LD_INT 3
39642: EQUAL
39643: IFFALSE 39647
// continue ;
39645: GO 39613
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39647: LD_ADDR_VAR 0 11
39651: PUSH
39652: LD_VAR 0 11
39656: PPUSH
39657: LD_VAR 0 11
39661: PUSH
39662: LD_INT 1
39664: PLUS
39665: PPUSH
39666: LD_VAR 0 9
39670: PUSH
39671: LD_VAR 0 3
39675: ARRAY
39676: PPUSH
39677: CALL_OW 2
39681: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39682: LD_ADDR_VAR 0 4
39686: PUSH
39687: LD_VAR 0 4
39691: PUSH
39692: LD_VAR 0 9
39696: PUSH
39697: LD_VAR 0 3
39701: ARRAY
39702: DIFF
39703: ST_TO_ADDR
// end ;
39704: GO 39613
39706: POP
39707: POP
// if p then
39708: LD_VAR 0 11
39712: IFFALSE 39737
// result := Replace ( result , 3 , p ) ;
39714: LD_ADDR_VAR 0 2
39718: PUSH
39719: LD_VAR 0 2
39723: PPUSH
39724: LD_INT 3
39726: PPUSH
39727: LD_VAR 0 11
39731: PPUSH
39732: CALL_OW 1
39736: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
39737: LD_ADDR_VAR 0 4
39741: PUSH
39742: LD_VAR 0 4
39746: PUSH
39747: LD_VAR 0 6
39751: DIFF
39752: ST_TO_ADDR
// if tmp and eng < 6 then
39753: LD_VAR 0 4
39757: PUSH
39758: LD_VAR 0 6
39762: PUSH
39763: LD_INT 6
39765: LESS
39766: AND
39767: IFFALSE 39961
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
39769: LD_ADDR_VAR 0 9
39773: PUSH
39774: LD_VAR 0 4
39778: PUSH
39779: LD_VAR 0 8
39783: PUSH
39784: LD_VAR 0 7
39788: UNION
39789: PUSH
39790: LD_VAR 0 6
39794: UNION
39795: DIFF
39796: PPUSH
39797: LD_INT 2
39799: PPUSH
39800: CALL 102605 0 2
39804: ST_TO_ADDR
// p := [ ] ;
39805: LD_ADDR_VAR 0 11
39809: PUSH
39810: EMPTY
39811: ST_TO_ADDR
// if sort then
39812: LD_VAR 0 9
39816: IFFALSE 39932
// for i = 1 to 6 - eng do
39818: LD_ADDR_VAR 0 3
39822: PUSH
39823: DOUBLE
39824: LD_INT 1
39826: DEC
39827: ST_TO_ADDR
39828: LD_INT 6
39830: PUSH
39831: LD_VAR 0 6
39835: MINUS
39836: PUSH
39837: FOR_TO
39838: IFFALSE 39930
// begin if i = sort then
39840: LD_VAR 0 3
39844: PUSH
39845: LD_VAR 0 9
39849: EQUAL
39850: IFFALSE 39854
// break ;
39852: GO 39930
// if GetClass ( i ) = 2 then
39854: LD_VAR 0 3
39858: PPUSH
39859: CALL_OW 257
39863: PUSH
39864: LD_INT 2
39866: EQUAL
39867: IFFALSE 39871
// continue ;
39869: GO 39837
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39871: LD_ADDR_VAR 0 11
39875: PUSH
39876: LD_VAR 0 11
39880: PPUSH
39881: LD_VAR 0 11
39885: PUSH
39886: LD_INT 1
39888: PLUS
39889: PPUSH
39890: LD_VAR 0 9
39894: PUSH
39895: LD_VAR 0 3
39899: ARRAY
39900: PPUSH
39901: CALL_OW 2
39905: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39906: LD_ADDR_VAR 0 4
39910: PUSH
39911: LD_VAR 0 4
39915: PUSH
39916: LD_VAR 0 9
39920: PUSH
39921: LD_VAR 0 3
39925: ARRAY
39926: DIFF
39927: ST_TO_ADDR
// end ;
39928: GO 39837
39930: POP
39931: POP
// if p then
39932: LD_VAR 0 11
39936: IFFALSE 39961
// result := Replace ( result , 2 , p ) ;
39938: LD_ADDR_VAR 0 2
39942: PUSH
39943: LD_VAR 0 2
39947: PPUSH
39948: LD_INT 2
39950: PPUSH
39951: LD_VAR 0 11
39955: PPUSH
39956: CALL_OW 1
39960: ST_TO_ADDR
// end ; exit ;
39961: GO 40685
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
39963: LD_EXP 126
39967: PUSH
39968: LD_EXP 125
39972: PUSH
39973: LD_VAR 0 1
39977: ARRAY
39978: ARRAY
39979: NOT
39980: PUSH
39981: LD_EXP 99
39985: PUSH
39986: LD_VAR 0 1
39990: ARRAY
39991: PPUSH
39992: LD_INT 30
39994: PUSH
39995: LD_INT 3
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PPUSH
40002: CALL_OW 72
40006: AND
40007: PUSH
40008: LD_EXP 104
40012: PUSH
40013: LD_VAR 0 1
40017: ARRAY
40018: NOT
40019: AND
40020: IFFALSE 40685
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
40022: LD_ADDR_EXP 141
40026: PUSH
40027: LD_EXP 141
40031: PPUSH
40032: LD_VAR 0 1
40036: PPUSH
40037: LD_INT 6
40039: PPUSH
40040: CALL_OW 1
40044: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40045: LD_ADDR_VAR 0 2
40049: PUSH
40050: LD_INT 0
40052: PUSH
40053: LD_INT 0
40055: PUSH
40056: LD_INT 0
40058: PUSH
40059: LD_INT 0
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: LIST
40066: LIST
40067: ST_TO_ADDR
// if sci >= 1 then
40068: LD_VAR 0 8
40072: PUSH
40073: LD_INT 1
40075: GREATEREQUAL
40076: IFFALSE 40098
// tmp := tmp diff sci [ 1 ] ;
40078: LD_ADDR_VAR 0 4
40082: PUSH
40083: LD_VAR 0 4
40087: PUSH
40088: LD_VAR 0 8
40092: PUSH
40093: LD_INT 1
40095: ARRAY
40096: DIFF
40097: ST_TO_ADDR
// if tmp and not sci then
40098: LD_VAR 0 4
40102: PUSH
40103: LD_VAR 0 8
40107: NOT
40108: AND
40109: IFFALSE 40178
// begin sort := SortBySkill ( tmp , 4 ) ;
40111: LD_ADDR_VAR 0 9
40115: PUSH
40116: LD_VAR 0 4
40120: PPUSH
40121: LD_INT 4
40123: PPUSH
40124: CALL 102605 0 2
40128: ST_TO_ADDR
// if sort then
40129: LD_VAR 0 9
40133: IFFALSE 40149
// p := sort [ 1 ] ;
40135: LD_ADDR_VAR 0 11
40139: PUSH
40140: LD_VAR 0 9
40144: PUSH
40145: LD_INT 1
40147: ARRAY
40148: ST_TO_ADDR
// if p then
40149: LD_VAR 0 11
40153: IFFALSE 40178
// result := Replace ( result , 4 , p ) ;
40155: LD_ADDR_VAR 0 2
40159: PUSH
40160: LD_VAR 0 2
40164: PPUSH
40165: LD_INT 4
40167: PPUSH
40168: LD_VAR 0 11
40172: PPUSH
40173: CALL_OW 1
40177: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40178: LD_ADDR_VAR 0 4
40182: PUSH
40183: LD_VAR 0 4
40187: PUSH
40188: LD_VAR 0 7
40192: DIFF
40193: ST_TO_ADDR
// if tmp and mech < 6 then
40194: LD_VAR 0 4
40198: PUSH
40199: LD_VAR 0 7
40203: PUSH
40204: LD_INT 6
40206: LESS
40207: AND
40208: IFFALSE 40390
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
40210: LD_ADDR_VAR 0 9
40214: PUSH
40215: LD_VAR 0 4
40219: PUSH
40220: LD_VAR 0 7
40224: DIFF
40225: PPUSH
40226: LD_INT 3
40228: PPUSH
40229: CALL 102605 0 2
40233: ST_TO_ADDR
// p := [ ] ;
40234: LD_ADDR_VAR 0 11
40238: PUSH
40239: EMPTY
40240: ST_TO_ADDR
// if sort then
40241: LD_VAR 0 9
40245: IFFALSE 40361
// for i = 1 to 6 - mech do
40247: LD_ADDR_VAR 0 3
40251: PUSH
40252: DOUBLE
40253: LD_INT 1
40255: DEC
40256: ST_TO_ADDR
40257: LD_INT 6
40259: PUSH
40260: LD_VAR 0 7
40264: MINUS
40265: PUSH
40266: FOR_TO
40267: IFFALSE 40359
// begin if i = sort then
40269: LD_VAR 0 3
40273: PUSH
40274: LD_VAR 0 9
40278: EQUAL
40279: IFFALSE 40283
// break ;
40281: GO 40359
// if GetClass ( i ) = 3 then
40283: LD_VAR 0 3
40287: PPUSH
40288: CALL_OW 257
40292: PUSH
40293: LD_INT 3
40295: EQUAL
40296: IFFALSE 40300
// continue ;
40298: GO 40266
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40300: LD_ADDR_VAR 0 11
40304: PUSH
40305: LD_VAR 0 11
40309: PPUSH
40310: LD_VAR 0 11
40314: PUSH
40315: LD_INT 1
40317: PLUS
40318: PPUSH
40319: LD_VAR 0 9
40323: PUSH
40324: LD_VAR 0 3
40328: ARRAY
40329: PPUSH
40330: CALL_OW 2
40334: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40335: LD_ADDR_VAR 0 4
40339: PUSH
40340: LD_VAR 0 4
40344: PUSH
40345: LD_VAR 0 9
40349: PUSH
40350: LD_VAR 0 3
40354: ARRAY
40355: DIFF
40356: ST_TO_ADDR
// end ;
40357: GO 40266
40359: POP
40360: POP
// if p then
40361: LD_VAR 0 11
40365: IFFALSE 40390
// result := Replace ( result , 3 , p ) ;
40367: LD_ADDR_VAR 0 2
40371: PUSH
40372: LD_VAR 0 2
40376: PPUSH
40377: LD_INT 3
40379: PPUSH
40380: LD_VAR 0 11
40384: PPUSH
40385: CALL_OW 1
40389: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40390: LD_ADDR_VAR 0 4
40394: PUSH
40395: LD_VAR 0 4
40399: PUSH
40400: LD_VAR 0 6
40404: DIFF
40405: ST_TO_ADDR
// if tmp and eng < 4 then
40406: LD_VAR 0 4
40410: PUSH
40411: LD_VAR 0 6
40415: PUSH
40416: LD_INT 4
40418: LESS
40419: AND
40420: IFFALSE 40610
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
40422: LD_ADDR_VAR 0 9
40426: PUSH
40427: LD_VAR 0 4
40431: PUSH
40432: LD_VAR 0 7
40436: PUSH
40437: LD_VAR 0 6
40441: UNION
40442: DIFF
40443: PPUSH
40444: LD_INT 2
40446: PPUSH
40447: CALL 102605 0 2
40451: ST_TO_ADDR
// p := [ ] ;
40452: LD_ADDR_VAR 0 11
40456: PUSH
40457: EMPTY
40458: ST_TO_ADDR
// if sort then
40459: LD_VAR 0 9
40463: IFFALSE 40579
// for i = 1 to 4 - eng do
40465: LD_ADDR_VAR 0 3
40469: PUSH
40470: DOUBLE
40471: LD_INT 1
40473: DEC
40474: ST_TO_ADDR
40475: LD_INT 4
40477: PUSH
40478: LD_VAR 0 6
40482: MINUS
40483: PUSH
40484: FOR_TO
40485: IFFALSE 40577
// begin if i = sort then
40487: LD_VAR 0 3
40491: PUSH
40492: LD_VAR 0 9
40496: EQUAL
40497: IFFALSE 40501
// break ;
40499: GO 40577
// if GetClass ( i ) = 2 then
40501: LD_VAR 0 3
40505: PPUSH
40506: CALL_OW 257
40510: PUSH
40511: LD_INT 2
40513: EQUAL
40514: IFFALSE 40518
// continue ;
40516: GO 40484
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40518: LD_ADDR_VAR 0 11
40522: PUSH
40523: LD_VAR 0 11
40527: PPUSH
40528: LD_VAR 0 11
40532: PUSH
40533: LD_INT 1
40535: PLUS
40536: PPUSH
40537: LD_VAR 0 9
40541: PUSH
40542: LD_VAR 0 3
40546: ARRAY
40547: PPUSH
40548: CALL_OW 2
40552: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40553: LD_ADDR_VAR 0 4
40557: PUSH
40558: LD_VAR 0 4
40562: PUSH
40563: LD_VAR 0 9
40567: PUSH
40568: LD_VAR 0 3
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// end ;
40575: GO 40484
40577: POP
40578: POP
// if p then
40579: LD_VAR 0 11
40583: IFFALSE 40608
// result := Replace ( result , 2 , p ) ;
40585: LD_ADDR_VAR 0 2
40589: PUSH
40590: LD_VAR 0 2
40594: PPUSH
40595: LD_INT 2
40597: PPUSH
40598: LD_VAR 0 11
40602: PPUSH
40603: CALL_OW 1
40607: ST_TO_ADDR
// end else
40608: GO 40654
// for i = eng downto 5 do
40610: LD_ADDR_VAR 0 3
40614: PUSH
40615: DOUBLE
40616: LD_VAR 0 6
40620: INC
40621: ST_TO_ADDR
40622: LD_INT 5
40624: PUSH
40625: FOR_DOWNTO
40626: IFFALSE 40652
// tmp := tmp union eng [ i ] ;
40628: LD_ADDR_VAR 0 4
40632: PUSH
40633: LD_VAR 0 4
40637: PUSH
40638: LD_VAR 0 6
40642: PUSH
40643: LD_VAR 0 3
40647: ARRAY
40648: UNION
40649: ST_TO_ADDR
40650: GO 40625
40652: POP
40653: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
40654: LD_ADDR_VAR 0 2
40658: PUSH
40659: LD_VAR 0 2
40663: PPUSH
40664: LD_INT 1
40666: PPUSH
40667: LD_VAR 0 4
40671: PUSH
40672: LD_VAR 0 5
40676: DIFF
40677: PPUSH
40678: CALL_OW 1
40682: ST_TO_ADDR
// exit ;
40683: GO 40685
// end ; end ;
40685: LD_VAR 0 2
40689: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
40690: LD_INT 0
40692: PPUSH
40693: PPUSH
40694: PPUSH
// if not mc_bases then
40695: LD_EXP 99
40699: NOT
40700: IFFALSE 40704
// exit ;
40702: GO 40810
// for i = 1 to mc_bases do
40704: LD_ADDR_VAR 0 2
40708: PUSH
40709: DOUBLE
40710: LD_INT 1
40712: DEC
40713: ST_TO_ADDR
40714: LD_EXP 99
40718: PUSH
40719: FOR_TO
40720: IFFALSE 40801
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40722: LD_ADDR_VAR 0 3
40726: PUSH
40727: LD_EXP 99
40731: PUSH
40732: LD_VAR 0 2
40736: ARRAY
40737: PPUSH
40738: LD_INT 21
40740: PUSH
40741: LD_INT 3
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 3
40750: PUSH
40751: LD_INT 24
40753: PUSH
40754: LD_INT 1000
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PPUSH
40769: CALL_OW 72
40773: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
40774: LD_ADDR_EXP 100
40778: PUSH
40779: LD_EXP 100
40783: PPUSH
40784: LD_VAR 0 2
40788: PPUSH
40789: LD_VAR 0 3
40793: PPUSH
40794: CALL_OW 1
40798: ST_TO_ADDR
// end ;
40799: GO 40719
40801: POP
40802: POP
// RaiseSailEvent ( 101 ) ;
40803: LD_INT 101
40805: PPUSH
40806: CALL_OW 427
// end ;
40810: LD_VAR 0 1
40814: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
40815: LD_INT 0
40817: PPUSH
40818: PPUSH
40819: PPUSH
40820: PPUSH
40821: PPUSH
40822: PPUSH
40823: PPUSH
// if not mc_bases then
40824: LD_EXP 99
40828: NOT
40829: IFFALSE 40833
// exit ;
40831: GO 41406
// for i = 1 to mc_bases do
40833: LD_ADDR_VAR 0 2
40837: PUSH
40838: DOUBLE
40839: LD_INT 1
40841: DEC
40842: ST_TO_ADDR
40843: LD_EXP 99
40847: PUSH
40848: FOR_TO
40849: IFFALSE 41397
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
40851: LD_ADDR_VAR 0 5
40855: PUSH
40856: LD_EXP 99
40860: PUSH
40861: LD_VAR 0 2
40865: ARRAY
40866: PUSH
40867: LD_EXP 128
40871: PUSH
40872: LD_VAR 0 2
40876: ARRAY
40877: UNION
40878: PPUSH
40879: LD_INT 21
40881: PUSH
40882: LD_INT 1
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 1
40891: PUSH
40892: LD_INT 3
40894: PUSH
40895: LD_INT 54
40897: PUSH
40898: EMPTY
40899: LIST
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 3
40907: PUSH
40908: LD_INT 24
40910: PUSH
40911: LD_INT 750
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: LIST
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PPUSH
40931: CALL_OW 72
40935: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
40936: LD_ADDR_VAR 0 6
40940: PUSH
40941: LD_EXP 99
40945: PUSH
40946: LD_VAR 0 2
40950: ARRAY
40951: PPUSH
40952: LD_INT 21
40954: PUSH
40955: LD_INT 1
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 1
40964: PUSH
40965: LD_INT 3
40967: PUSH
40968: LD_INT 54
40970: PUSH
40971: EMPTY
40972: LIST
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 3
40980: PUSH
40981: LD_INT 24
40983: PUSH
40984: LD_INT 250
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PPUSH
41004: CALL_OW 72
41008: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
41009: LD_ADDR_VAR 0 7
41013: PUSH
41014: LD_VAR 0 5
41018: PUSH
41019: LD_VAR 0 6
41023: DIFF
41024: ST_TO_ADDR
// if not need_heal_1 then
41025: LD_VAR 0 6
41029: NOT
41030: IFFALSE 41063
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
41032: LD_ADDR_EXP 102
41036: PUSH
41037: LD_EXP 102
41041: PPUSH
41042: LD_VAR 0 2
41046: PUSH
41047: LD_INT 1
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PPUSH
41054: EMPTY
41055: PPUSH
41056: CALL 68420 0 3
41060: ST_TO_ADDR
41061: GO 41133
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
41063: LD_ADDR_EXP 102
41067: PUSH
41068: LD_EXP 102
41072: PPUSH
41073: LD_VAR 0 2
41077: PUSH
41078: LD_INT 1
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PPUSH
41085: LD_EXP 102
41089: PUSH
41090: LD_VAR 0 2
41094: ARRAY
41095: PUSH
41096: LD_INT 1
41098: ARRAY
41099: PPUSH
41100: LD_INT 3
41102: PUSH
41103: LD_INT 24
41105: PUSH
41106: LD_INT 1000
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PPUSH
41117: CALL_OW 72
41121: PUSH
41122: LD_VAR 0 6
41126: UNION
41127: PPUSH
41128: CALL 68420 0 3
41132: ST_TO_ADDR
// if not need_heal_2 then
41133: LD_VAR 0 7
41137: NOT
41138: IFFALSE 41171
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
41140: LD_ADDR_EXP 102
41144: PUSH
41145: LD_EXP 102
41149: PPUSH
41150: LD_VAR 0 2
41154: PUSH
41155: LD_INT 2
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PPUSH
41162: EMPTY
41163: PPUSH
41164: CALL 68420 0 3
41168: ST_TO_ADDR
41169: GO 41203
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
41171: LD_ADDR_EXP 102
41175: PUSH
41176: LD_EXP 102
41180: PPUSH
41181: LD_VAR 0 2
41185: PUSH
41186: LD_INT 2
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PPUSH
41193: LD_VAR 0 7
41197: PPUSH
41198: CALL 68420 0 3
41202: ST_TO_ADDR
// if need_heal_2 then
41203: LD_VAR 0 7
41207: IFFALSE 41379
// for j in need_heal_2 do
41209: LD_ADDR_VAR 0 3
41213: PUSH
41214: LD_VAR 0 7
41218: PUSH
41219: FOR_IN
41220: IFFALSE 41377
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
41222: LD_ADDR_VAR 0 5
41226: PUSH
41227: LD_EXP 99
41231: PUSH
41232: LD_VAR 0 2
41236: ARRAY
41237: PPUSH
41238: LD_INT 2
41240: PUSH
41241: LD_INT 30
41243: PUSH
41244: LD_INT 6
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 30
41253: PUSH
41254: LD_INT 7
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 30
41263: PUSH
41264: LD_INT 8
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 30
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 30
41283: PUSH
41284: LD_INT 1
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 25
41293: PUSH
41294: LD_INT 4
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: PPUSH
41310: CALL_OW 72
41314: ST_TO_ADDR
// if tmp then
41315: LD_VAR 0 5
41319: IFFALSE 41375
// begin k := NearestUnitToUnit ( tmp , j ) ;
41321: LD_ADDR_VAR 0 4
41325: PUSH
41326: LD_VAR 0 5
41330: PPUSH
41331: LD_VAR 0 3
41335: PPUSH
41336: CALL_OW 74
41340: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
41341: LD_VAR 0 3
41345: PPUSH
41346: LD_VAR 0 4
41350: PPUSH
41351: CALL_OW 296
41355: PUSH
41356: LD_INT 7
41358: GREATER
41359: IFFALSE 41375
// ComMoveUnit ( j , k ) ;
41361: LD_VAR 0 3
41365: PPUSH
41366: LD_VAR 0 4
41370: PPUSH
41371: CALL_OW 112
// end ; end ;
41375: GO 41219
41377: POP
41378: POP
// if not need_heal_1 and not need_heal_2 then
41379: LD_VAR 0 6
41383: NOT
41384: PUSH
41385: LD_VAR 0 7
41389: NOT
41390: AND
41391: IFFALSE 41395
// continue ;
41393: GO 40848
// end ;
41395: GO 40848
41397: POP
41398: POP
// RaiseSailEvent ( 102 ) ;
41399: LD_INT 102
41401: PPUSH
41402: CALL_OW 427
// end ;
41406: LD_VAR 0 1
41410: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
41411: LD_INT 0
41413: PPUSH
41414: PPUSH
41415: PPUSH
41416: PPUSH
41417: PPUSH
// if not mc_bases then
41418: LD_EXP 99
41422: NOT
41423: IFFALSE 41427
// exit ;
41425: GO 41812
// for i = 1 to mc_bases do
41427: LD_ADDR_VAR 0 2
41431: PUSH
41432: DOUBLE
41433: LD_INT 1
41435: DEC
41436: ST_TO_ADDR
41437: LD_EXP 99
41441: PUSH
41442: FOR_TO
41443: IFFALSE 41810
// begin if not mc_building_need_repair [ i ] then
41445: LD_EXP 100
41449: PUSH
41450: LD_VAR 0 2
41454: ARRAY
41455: NOT
41456: IFFALSE 41494
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41458: LD_ADDR_EXP 101
41462: PUSH
41463: LD_EXP 101
41467: PPUSH
41468: LD_VAR 0 2
41472: PPUSH
41473: EMPTY
41474: PPUSH
41475: CALL_OW 1
41479: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
41480: LD_VAR 0 2
41484: PPUSH
41485: LD_INT 101
41487: PPUSH
41488: CALL 36532 0 2
// continue ;
41492: GO 41442
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
41494: LD_ADDR_EXP 105
41498: PUSH
41499: LD_EXP 105
41503: PPUSH
41504: LD_VAR 0 2
41508: PPUSH
41509: EMPTY
41510: PPUSH
41511: CALL_OW 1
41515: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
41516: LD_VAR 0 2
41520: PPUSH
41521: LD_INT 103
41523: PPUSH
41524: CALL 36532 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
41528: LD_ADDR_VAR 0 5
41532: PUSH
41533: LD_EXP 99
41537: PUSH
41538: LD_VAR 0 2
41542: ARRAY
41543: PUSH
41544: LD_EXP 128
41548: PUSH
41549: LD_VAR 0 2
41553: ARRAY
41554: UNION
41555: PPUSH
41556: LD_INT 2
41558: PUSH
41559: LD_INT 25
41561: PUSH
41562: LD_INT 2
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 25
41571: PUSH
41572: LD_INT 16
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: LIST
41583: PUSH
41584: EMPTY
41585: LIST
41586: PPUSH
41587: CALL_OW 72
41591: ST_TO_ADDR
// if not tmp then
41592: LD_VAR 0 5
41596: NOT
41597: IFFALSE 41601
// continue ;
41599: GO 41442
// for j in tmp do
41601: LD_ADDR_VAR 0 3
41605: PUSH
41606: LD_VAR 0 5
41610: PUSH
41611: FOR_IN
41612: IFFALSE 41806
// begin if mc_need_heal [ i ] then
41614: LD_EXP 102
41618: PUSH
41619: LD_VAR 0 2
41623: ARRAY
41624: IFFALSE 41672
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
41626: LD_VAR 0 3
41630: PUSH
41631: LD_EXP 102
41635: PUSH
41636: LD_VAR 0 2
41640: ARRAY
41641: PUSH
41642: LD_INT 1
41644: ARRAY
41645: IN
41646: PUSH
41647: LD_VAR 0 3
41651: PUSH
41652: LD_EXP 102
41656: PUSH
41657: LD_VAR 0 2
41661: ARRAY
41662: PUSH
41663: LD_INT 2
41665: ARRAY
41666: IN
41667: OR
41668: IFFALSE 41672
// continue ;
41670: GO 41611
// if IsInUnit ( j ) then
41672: LD_VAR 0 3
41676: PPUSH
41677: CALL_OW 310
41681: IFFALSE 41692
// ComExitBuilding ( j ) ;
41683: LD_VAR 0 3
41687: PPUSH
41688: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
41692: LD_VAR 0 3
41696: PUSH
41697: LD_EXP 101
41701: PUSH
41702: LD_VAR 0 2
41706: ARRAY
41707: IN
41708: NOT
41709: IFFALSE 41767
// begin SetTag ( j , 101 ) ;
41711: LD_VAR 0 3
41715: PPUSH
41716: LD_INT 101
41718: PPUSH
41719: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
41723: LD_ADDR_EXP 101
41727: PUSH
41728: LD_EXP 101
41732: PPUSH
41733: LD_VAR 0 2
41737: PUSH
41738: LD_EXP 101
41742: PUSH
41743: LD_VAR 0 2
41747: ARRAY
41748: PUSH
41749: LD_INT 1
41751: PLUS
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PPUSH
41757: LD_VAR 0 3
41761: PPUSH
41762: CALL 68420 0 3
41766: ST_TO_ADDR
// end ; wait ( 1 ) ;
41767: LD_INT 1
41769: PPUSH
41770: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
41774: LD_VAR 0 3
41778: PPUSH
41779: LD_EXP 100
41783: PUSH
41784: LD_VAR 0 2
41788: ARRAY
41789: PPUSH
41790: LD_VAR 0 3
41794: PPUSH
41795: CALL_OW 74
41799: PPUSH
41800: CALL_OW 130
// end ;
41804: GO 41611
41806: POP
41807: POP
// end ;
41808: GO 41442
41810: POP
41811: POP
// end ;
41812: LD_VAR 0 1
41816: RET
// export function MC_Heal ; var i , j , tmp ; begin
41817: LD_INT 0
41819: PPUSH
41820: PPUSH
41821: PPUSH
41822: PPUSH
// if not mc_bases then
41823: LD_EXP 99
41827: NOT
41828: IFFALSE 41832
// exit ;
41830: GO 42234
// for i = 1 to mc_bases do
41832: LD_ADDR_VAR 0 2
41836: PUSH
41837: DOUBLE
41838: LD_INT 1
41840: DEC
41841: ST_TO_ADDR
41842: LD_EXP 99
41846: PUSH
41847: FOR_TO
41848: IFFALSE 42232
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
41850: LD_EXP 102
41854: PUSH
41855: LD_VAR 0 2
41859: ARRAY
41860: PUSH
41861: LD_INT 1
41863: ARRAY
41864: NOT
41865: PUSH
41866: LD_EXP 102
41870: PUSH
41871: LD_VAR 0 2
41875: ARRAY
41876: PUSH
41877: LD_INT 2
41879: ARRAY
41880: NOT
41881: AND
41882: IFFALSE 41920
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
41884: LD_ADDR_EXP 103
41888: PUSH
41889: LD_EXP 103
41893: PPUSH
41894: LD_VAR 0 2
41898: PPUSH
41899: EMPTY
41900: PPUSH
41901: CALL_OW 1
41905: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
41906: LD_VAR 0 2
41910: PPUSH
41911: LD_INT 102
41913: PPUSH
41914: CALL 36532 0 2
// continue ;
41918: GO 41847
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41920: LD_ADDR_VAR 0 4
41924: PUSH
41925: LD_EXP 99
41929: PUSH
41930: LD_VAR 0 2
41934: ARRAY
41935: PPUSH
41936: LD_INT 25
41938: PUSH
41939: LD_INT 4
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PPUSH
41946: CALL_OW 72
41950: ST_TO_ADDR
// if not tmp then
41951: LD_VAR 0 4
41955: NOT
41956: IFFALSE 41960
// continue ;
41958: GO 41847
// if mc_taming [ i ] then
41960: LD_EXP 130
41964: PUSH
41965: LD_VAR 0 2
41969: ARRAY
41970: IFFALSE 41994
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41972: LD_ADDR_EXP 130
41976: PUSH
41977: LD_EXP 130
41981: PPUSH
41982: LD_VAR 0 2
41986: PPUSH
41987: EMPTY
41988: PPUSH
41989: CALL_OW 1
41993: ST_TO_ADDR
// for j in tmp do
41994: LD_ADDR_VAR 0 3
41998: PUSH
41999: LD_VAR 0 4
42003: PUSH
42004: FOR_IN
42005: IFFALSE 42228
// begin if IsInUnit ( j ) then
42007: LD_VAR 0 3
42011: PPUSH
42012: CALL_OW 310
42016: IFFALSE 42027
// ComExitBuilding ( j ) ;
42018: LD_VAR 0 3
42022: PPUSH
42023: CALL_OW 122
// if not j in mc_healers [ i ] then
42027: LD_VAR 0 3
42031: PUSH
42032: LD_EXP 103
42036: PUSH
42037: LD_VAR 0 2
42041: ARRAY
42042: IN
42043: NOT
42044: IFFALSE 42090
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
42046: LD_ADDR_EXP 103
42050: PUSH
42051: LD_EXP 103
42055: PPUSH
42056: LD_VAR 0 2
42060: PUSH
42061: LD_EXP 103
42065: PUSH
42066: LD_VAR 0 2
42070: ARRAY
42071: PUSH
42072: LD_INT 1
42074: PLUS
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PPUSH
42080: LD_VAR 0 3
42084: PPUSH
42085: CALL 68420 0 3
42089: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
42090: LD_VAR 0 3
42094: PPUSH
42095: CALL_OW 110
42099: PUSH
42100: LD_INT 102
42102: NONEQUAL
42103: IFFALSE 42117
// SetTag ( j , 102 ) ;
42105: LD_VAR 0 3
42109: PPUSH
42110: LD_INT 102
42112: PPUSH
42113: CALL_OW 109
// Wait ( 3 ) ;
42117: LD_INT 3
42119: PPUSH
42120: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
42124: LD_EXP 102
42128: PUSH
42129: LD_VAR 0 2
42133: ARRAY
42134: PUSH
42135: LD_INT 1
42137: ARRAY
42138: IFFALSE 42170
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
42140: LD_VAR 0 3
42144: PPUSH
42145: LD_EXP 102
42149: PUSH
42150: LD_VAR 0 2
42154: ARRAY
42155: PUSH
42156: LD_INT 1
42158: ARRAY
42159: PUSH
42160: LD_INT 1
42162: ARRAY
42163: PPUSH
42164: CALL_OW 128
42168: GO 42226
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
42170: LD_VAR 0 3
42174: PPUSH
42175: CALL_OW 314
42179: NOT
42180: PUSH
42181: LD_EXP 102
42185: PUSH
42186: LD_VAR 0 2
42190: ARRAY
42191: PUSH
42192: LD_INT 2
42194: ARRAY
42195: AND
42196: IFFALSE 42226
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
42198: LD_VAR 0 3
42202: PPUSH
42203: LD_EXP 102
42207: PUSH
42208: LD_VAR 0 2
42212: ARRAY
42213: PUSH
42214: LD_INT 2
42216: ARRAY
42217: PUSH
42218: LD_INT 1
42220: ARRAY
42221: PPUSH
42222: CALL_OW 128
// end ;
42226: GO 42004
42228: POP
42229: POP
// end ;
42230: GO 41847
42232: POP
42233: POP
// end ;
42234: LD_VAR 0 1
42238: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
42239: LD_INT 0
42241: PPUSH
42242: PPUSH
42243: PPUSH
42244: PPUSH
42245: PPUSH
// if not mc_bases then
42246: LD_EXP 99
42250: NOT
42251: IFFALSE 42255
// exit ;
42253: GO 43398
// for i = 1 to mc_bases do
42255: LD_ADDR_VAR 0 2
42259: PUSH
42260: DOUBLE
42261: LD_INT 1
42263: DEC
42264: ST_TO_ADDR
42265: LD_EXP 99
42269: PUSH
42270: FOR_TO
42271: IFFALSE 43396
// begin if mc_scan [ i ] then
42273: LD_EXP 122
42277: PUSH
42278: LD_VAR 0 2
42282: ARRAY
42283: IFFALSE 42287
// continue ;
42285: GO 42270
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
42287: LD_EXP 104
42291: PUSH
42292: LD_VAR 0 2
42296: ARRAY
42297: NOT
42298: PUSH
42299: LD_EXP 106
42303: PUSH
42304: LD_VAR 0 2
42308: ARRAY
42309: NOT
42310: AND
42311: PUSH
42312: LD_EXP 105
42316: PUSH
42317: LD_VAR 0 2
42321: ARRAY
42322: AND
42323: IFFALSE 42361
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
42325: LD_ADDR_EXP 105
42329: PUSH
42330: LD_EXP 105
42334: PPUSH
42335: LD_VAR 0 2
42339: PPUSH
42340: EMPTY
42341: PPUSH
42342: CALL_OW 1
42346: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42347: LD_VAR 0 2
42351: PPUSH
42352: LD_INT 103
42354: PPUSH
42355: CALL 36532 0 2
// continue ;
42359: GO 42270
// end ; if mc_construct_list [ i ] then
42361: LD_EXP 106
42365: PUSH
42366: LD_VAR 0 2
42370: ARRAY
42371: IFFALSE 42591
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
42373: LD_ADDR_VAR 0 4
42377: PUSH
42378: LD_EXP 99
42382: PUSH
42383: LD_VAR 0 2
42387: ARRAY
42388: PPUSH
42389: LD_INT 25
42391: PUSH
42392: LD_INT 2
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PPUSH
42399: CALL_OW 72
42403: PUSH
42404: LD_EXP 101
42408: PUSH
42409: LD_VAR 0 2
42413: ARRAY
42414: DIFF
42415: ST_TO_ADDR
// if not tmp then
42416: LD_VAR 0 4
42420: NOT
42421: IFFALSE 42425
// continue ;
42423: GO 42270
// for j in tmp do
42425: LD_ADDR_VAR 0 3
42429: PUSH
42430: LD_VAR 0 4
42434: PUSH
42435: FOR_IN
42436: IFFALSE 42587
// begin if not mc_builders [ i ] then
42438: LD_EXP 105
42442: PUSH
42443: LD_VAR 0 2
42447: ARRAY
42448: NOT
42449: IFFALSE 42507
// begin SetTag ( j , 103 ) ;
42451: LD_VAR 0 3
42455: PPUSH
42456: LD_INT 103
42458: PPUSH
42459: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
42463: LD_ADDR_EXP 105
42467: PUSH
42468: LD_EXP 105
42472: PPUSH
42473: LD_VAR 0 2
42477: PUSH
42478: LD_EXP 105
42482: PUSH
42483: LD_VAR 0 2
42487: ARRAY
42488: PUSH
42489: LD_INT 1
42491: PLUS
42492: PUSH
42493: EMPTY
42494: LIST
42495: LIST
42496: PPUSH
42497: LD_VAR 0 3
42501: PPUSH
42502: CALL 68420 0 3
42506: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
42507: LD_VAR 0 3
42511: PPUSH
42512: CALL_OW 310
42516: IFFALSE 42527
// ComExitBuilding ( j ) ;
42518: LD_VAR 0 3
42522: PPUSH
42523: CALL_OW 122
// wait ( 3 ) ;
42527: LD_INT 3
42529: PPUSH
42530: CALL_OW 67
// if not mc_construct_list [ i ] then
42534: LD_EXP 106
42538: PUSH
42539: LD_VAR 0 2
42543: ARRAY
42544: NOT
42545: IFFALSE 42549
// break ;
42547: GO 42587
// if not HasTask ( j ) then
42549: LD_VAR 0 3
42553: PPUSH
42554: CALL_OW 314
42558: NOT
42559: IFFALSE 42585
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
42561: LD_VAR 0 3
42565: PPUSH
42566: LD_EXP 106
42570: PUSH
42571: LD_VAR 0 2
42575: ARRAY
42576: PUSH
42577: LD_INT 1
42579: ARRAY
42580: PPUSH
42581: CALL 71271 0 2
// end ;
42585: GO 42435
42587: POP
42588: POP
// end else
42589: GO 43394
// if mc_build_list [ i ] then
42591: LD_EXP 104
42595: PUSH
42596: LD_VAR 0 2
42600: ARRAY
42601: IFFALSE 43394
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42603: LD_ADDR_VAR 0 5
42607: PUSH
42608: LD_EXP 99
42612: PUSH
42613: LD_VAR 0 2
42617: ARRAY
42618: PPUSH
42619: LD_INT 2
42621: PUSH
42622: LD_INT 30
42624: PUSH
42625: LD_INT 0
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 30
42634: PUSH
42635: LD_INT 1
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: LIST
42646: PPUSH
42647: CALL_OW 72
42651: ST_TO_ADDR
// if depot then
42652: LD_VAR 0 5
42656: IFFALSE 42674
// depot := depot [ 1 ] else
42658: LD_ADDR_VAR 0 5
42662: PUSH
42663: LD_VAR 0 5
42667: PUSH
42668: LD_INT 1
42670: ARRAY
42671: ST_TO_ADDR
42672: GO 42682
// depot := 0 ;
42674: LD_ADDR_VAR 0 5
42678: PUSH
42679: LD_INT 0
42681: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
42682: LD_EXP 104
42686: PUSH
42687: LD_VAR 0 2
42691: ARRAY
42692: PUSH
42693: LD_INT 1
42695: ARRAY
42696: PUSH
42697: LD_INT 1
42699: ARRAY
42700: PPUSH
42701: CALL 71101 0 1
42705: PUSH
42706: LD_EXP 99
42710: PUSH
42711: LD_VAR 0 2
42715: ARRAY
42716: PPUSH
42717: LD_INT 2
42719: PUSH
42720: LD_INT 30
42722: PUSH
42723: LD_INT 2
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 30
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: LIST
42744: PPUSH
42745: CALL_OW 72
42749: NOT
42750: AND
42751: IFFALSE 42856
// begin for j = 1 to mc_build_list [ i ] do
42753: LD_ADDR_VAR 0 3
42757: PUSH
42758: DOUBLE
42759: LD_INT 1
42761: DEC
42762: ST_TO_ADDR
42763: LD_EXP 104
42767: PUSH
42768: LD_VAR 0 2
42772: ARRAY
42773: PUSH
42774: FOR_TO
42775: IFFALSE 42854
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
42777: LD_EXP 104
42781: PUSH
42782: LD_VAR 0 2
42786: ARRAY
42787: PUSH
42788: LD_VAR 0 3
42792: ARRAY
42793: PUSH
42794: LD_INT 1
42796: ARRAY
42797: PUSH
42798: LD_INT 2
42800: EQUAL
42801: IFFALSE 42852
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
42803: LD_ADDR_EXP 104
42807: PUSH
42808: LD_EXP 104
42812: PPUSH
42813: LD_VAR 0 2
42817: PPUSH
42818: LD_EXP 104
42822: PUSH
42823: LD_VAR 0 2
42827: ARRAY
42828: PPUSH
42829: LD_VAR 0 3
42833: PPUSH
42834: LD_INT 1
42836: PPUSH
42837: LD_INT 0
42839: PPUSH
42840: CALL 67838 0 4
42844: PPUSH
42845: CALL_OW 1
42849: ST_TO_ADDR
// break ;
42850: GO 42854
// end ;
42852: GO 42774
42854: POP
42855: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
42856: LD_EXP 104
42860: PUSH
42861: LD_VAR 0 2
42865: ARRAY
42866: PUSH
42867: LD_INT 1
42869: ARRAY
42870: PUSH
42871: LD_INT 1
42873: ARRAY
42874: PUSH
42875: LD_INT 0
42877: EQUAL
42878: PUSH
42879: LD_VAR 0 5
42883: PUSH
42884: LD_VAR 0 5
42888: PPUSH
42889: LD_EXP 104
42893: PUSH
42894: LD_VAR 0 2
42898: ARRAY
42899: PUSH
42900: LD_INT 1
42902: ARRAY
42903: PUSH
42904: LD_INT 1
42906: ARRAY
42907: PPUSH
42908: LD_EXP 104
42912: PUSH
42913: LD_VAR 0 2
42917: ARRAY
42918: PUSH
42919: LD_INT 1
42921: ARRAY
42922: PUSH
42923: LD_INT 2
42925: ARRAY
42926: PPUSH
42927: LD_EXP 104
42931: PUSH
42932: LD_VAR 0 2
42936: ARRAY
42937: PUSH
42938: LD_INT 1
42940: ARRAY
42941: PUSH
42942: LD_INT 3
42944: ARRAY
42945: PPUSH
42946: LD_EXP 104
42950: PUSH
42951: LD_VAR 0 2
42955: ARRAY
42956: PUSH
42957: LD_INT 1
42959: ARRAY
42960: PUSH
42961: LD_INT 4
42963: ARRAY
42964: PPUSH
42965: CALL 75817 0 5
42969: AND
42970: OR
42971: IFFALSE 43252
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
42973: LD_ADDR_VAR 0 4
42977: PUSH
42978: LD_EXP 99
42982: PUSH
42983: LD_VAR 0 2
42987: ARRAY
42988: PPUSH
42989: LD_INT 25
42991: PUSH
42992: LD_INT 2
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PPUSH
42999: CALL_OW 72
43003: PUSH
43004: LD_EXP 101
43008: PUSH
43009: LD_VAR 0 2
43013: ARRAY
43014: DIFF
43015: ST_TO_ADDR
// if not tmp then
43016: LD_VAR 0 4
43020: NOT
43021: IFFALSE 43025
// continue ;
43023: GO 42270
// for j in tmp do
43025: LD_ADDR_VAR 0 3
43029: PUSH
43030: LD_VAR 0 4
43034: PUSH
43035: FOR_IN
43036: IFFALSE 43248
// begin if not mc_builders [ i ] then
43038: LD_EXP 105
43042: PUSH
43043: LD_VAR 0 2
43047: ARRAY
43048: NOT
43049: IFFALSE 43107
// begin SetTag ( j , 103 ) ;
43051: LD_VAR 0 3
43055: PPUSH
43056: LD_INT 103
43058: PPUSH
43059: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43063: LD_ADDR_EXP 105
43067: PUSH
43068: LD_EXP 105
43072: PPUSH
43073: LD_VAR 0 2
43077: PUSH
43078: LD_EXP 105
43082: PUSH
43083: LD_VAR 0 2
43087: ARRAY
43088: PUSH
43089: LD_INT 1
43091: PLUS
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PPUSH
43097: LD_VAR 0 3
43101: PPUSH
43102: CALL 68420 0 3
43106: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43107: LD_VAR 0 3
43111: PPUSH
43112: CALL_OW 310
43116: IFFALSE 43127
// ComExitBuilding ( j ) ;
43118: LD_VAR 0 3
43122: PPUSH
43123: CALL_OW 122
// wait ( 3 ) ;
43127: LD_INT 3
43129: PPUSH
43130: CALL_OW 67
// if not mc_build_list [ i ] then
43134: LD_EXP 104
43138: PUSH
43139: LD_VAR 0 2
43143: ARRAY
43144: NOT
43145: IFFALSE 43149
// break ;
43147: GO 43248
// if not HasTask ( j ) then
43149: LD_VAR 0 3
43153: PPUSH
43154: CALL_OW 314
43158: NOT
43159: IFFALSE 43246
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
43161: LD_VAR 0 3
43165: PPUSH
43166: LD_EXP 104
43170: PUSH
43171: LD_VAR 0 2
43175: ARRAY
43176: PUSH
43177: LD_INT 1
43179: ARRAY
43180: PUSH
43181: LD_INT 1
43183: ARRAY
43184: PPUSH
43185: LD_EXP 104
43189: PUSH
43190: LD_VAR 0 2
43194: ARRAY
43195: PUSH
43196: LD_INT 1
43198: ARRAY
43199: PUSH
43200: LD_INT 2
43202: ARRAY
43203: PPUSH
43204: LD_EXP 104
43208: PUSH
43209: LD_VAR 0 2
43213: ARRAY
43214: PUSH
43215: LD_INT 1
43217: ARRAY
43218: PUSH
43219: LD_INT 3
43221: ARRAY
43222: PPUSH
43223: LD_EXP 104
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PUSH
43234: LD_INT 1
43236: ARRAY
43237: PUSH
43238: LD_INT 4
43240: ARRAY
43241: PPUSH
43242: CALL_OW 145
// end ;
43246: GO 43035
43248: POP
43249: POP
// end else
43250: GO 43394
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
43252: LD_EXP 99
43256: PUSH
43257: LD_VAR 0 2
43261: ARRAY
43262: PPUSH
43263: LD_EXP 104
43267: PUSH
43268: LD_VAR 0 2
43272: ARRAY
43273: PUSH
43274: LD_INT 1
43276: ARRAY
43277: PUSH
43278: LD_INT 1
43280: ARRAY
43281: PPUSH
43282: LD_EXP 104
43286: PUSH
43287: LD_VAR 0 2
43291: ARRAY
43292: PUSH
43293: LD_INT 1
43295: ARRAY
43296: PUSH
43297: LD_INT 2
43299: ARRAY
43300: PPUSH
43301: LD_EXP 104
43305: PUSH
43306: LD_VAR 0 2
43310: ARRAY
43311: PUSH
43312: LD_INT 1
43314: ARRAY
43315: PUSH
43316: LD_INT 3
43318: ARRAY
43319: PPUSH
43320: LD_EXP 104
43324: PUSH
43325: LD_VAR 0 2
43329: ARRAY
43330: PUSH
43331: LD_INT 1
43333: ARRAY
43334: PUSH
43335: LD_INT 4
43337: ARRAY
43338: PPUSH
43339: CALL 75171 0 5
43343: NOT
43344: IFFALSE 43394
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
43346: LD_ADDR_EXP 104
43350: PUSH
43351: LD_EXP 104
43355: PPUSH
43356: LD_VAR 0 2
43360: PPUSH
43361: LD_EXP 104
43365: PUSH
43366: LD_VAR 0 2
43370: ARRAY
43371: PPUSH
43372: LD_INT 1
43374: PPUSH
43375: LD_INT 1
43377: NEG
43378: PPUSH
43379: LD_INT 0
43381: PPUSH
43382: CALL 67838 0 4
43386: PPUSH
43387: CALL_OW 1
43391: ST_TO_ADDR
// continue ;
43392: GO 42270
// end ; end ; end ;
43394: GO 42270
43396: POP
43397: POP
// end ;
43398: LD_VAR 0 1
43402: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
43403: LD_INT 0
43405: PPUSH
43406: PPUSH
43407: PPUSH
43408: PPUSH
43409: PPUSH
43410: PPUSH
// if not mc_bases then
43411: LD_EXP 99
43415: NOT
43416: IFFALSE 43420
// exit ;
43418: GO 43847
// for i = 1 to mc_bases do
43420: LD_ADDR_VAR 0 2
43424: PUSH
43425: DOUBLE
43426: LD_INT 1
43428: DEC
43429: ST_TO_ADDR
43430: LD_EXP 99
43434: PUSH
43435: FOR_TO
43436: IFFALSE 43845
// begin tmp := mc_build_upgrade [ i ] ;
43438: LD_ADDR_VAR 0 4
43442: PUSH
43443: LD_EXP 131
43447: PUSH
43448: LD_VAR 0 2
43452: ARRAY
43453: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
43454: LD_ADDR_VAR 0 6
43458: PUSH
43459: LD_EXP 132
43463: PUSH
43464: LD_VAR 0 2
43468: ARRAY
43469: PPUSH
43470: LD_INT 2
43472: PUSH
43473: LD_INT 30
43475: PUSH
43476: LD_INT 6
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 30
43485: PUSH
43486: LD_INT 7
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: LIST
43497: PPUSH
43498: CALL_OW 72
43502: ST_TO_ADDR
// if not tmp and not lab then
43503: LD_VAR 0 4
43507: NOT
43508: PUSH
43509: LD_VAR 0 6
43513: NOT
43514: AND
43515: IFFALSE 43519
// continue ;
43517: GO 43435
// if tmp then
43519: LD_VAR 0 4
43523: IFFALSE 43643
// for j in tmp do
43525: LD_ADDR_VAR 0 3
43529: PUSH
43530: LD_VAR 0 4
43534: PUSH
43535: FOR_IN
43536: IFFALSE 43641
// begin if UpgradeCost ( j ) then
43538: LD_VAR 0 3
43542: PPUSH
43543: CALL 74831 0 1
43547: IFFALSE 43639
// begin ComUpgrade ( j ) ;
43549: LD_VAR 0 3
43553: PPUSH
43554: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
43558: LD_ADDR_EXP 131
43562: PUSH
43563: LD_EXP 131
43567: PPUSH
43568: LD_VAR 0 2
43572: PPUSH
43573: LD_EXP 131
43577: PUSH
43578: LD_VAR 0 2
43582: ARRAY
43583: PUSH
43584: LD_VAR 0 3
43588: DIFF
43589: PPUSH
43590: CALL_OW 1
43594: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
43595: LD_ADDR_EXP 106
43599: PUSH
43600: LD_EXP 106
43604: PPUSH
43605: LD_VAR 0 2
43609: PUSH
43610: LD_EXP 106
43614: PUSH
43615: LD_VAR 0 2
43619: ARRAY
43620: PUSH
43621: LD_INT 1
43623: PLUS
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PPUSH
43629: LD_VAR 0 3
43633: PPUSH
43634: CALL 68420 0 3
43638: ST_TO_ADDR
// end ; end ;
43639: GO 43535
43641: POP
43642: POP
// if not lab or not mc_lab_upgrade [ i ] then
43643: LD_VAR 0 6
43647: NOT
43648: PUSH
43649: LD_EXP 133
43653: PUSH
43654: LD_VAR 0 2
43658: ARRAY
43659: NOT
43660: OR
43661: IFFALSE 43665
// continue ;
43663: GO 43435
// for j in lab do
43665: LD_ADDR_VAR 0 3
43669: PUSH
43670: LD_VAR 0 6
43674: PUSH
43675: FOR_IN
43676: IFFALSE 43841
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
43678: LD_VAR 0 3
43682: PPUSH
43683: CALL_OW 266
43687: PUSH
43688: LD_INT 6
43690: PUSH
43691: LD_INT 7
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: IN
43698: PUSH
43699: LD_VAR 0 3
43703: PPUSH
43704: CALL_OW 461
43708: PUSH
43709: LD_INT 1
43711: NONEQUAL
43712: AND
43713: IFFALSE 43839
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
43715: LD_VAR 0 3
43719: PPUSH
43720: LD_EXP 133
43724: PUSH
43725: LD_VAR 0 2
43729: ARRAY
43730: PUSH
43731: LD_INT 1
43733: ARRAY
43734: PPUSH
43735: CALL 75036 0 2
43739: IFFALSE 43839
// begin ComCancel ( j ) ;
43741: LD_VAR 0 3
43745: PPUSH
43746: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
43750: LD_VAR 0 3
43754: PPUSH
43755: LD_EXP 133
43759: PUSH
43760: LD_VAR 0 2
43764: ARRAY
43765: PUSH
43766: LD_INT 1
43768: ARRAY
43769: PPUSH
43770: CALL_OW 207
// if not j in mc_construct_list [ i ] then
43774: LD_VAR 0 3
43778: PUSH
43779: LD_EXP 106
43783: PUSH
43784: LD_VAR 0 2
43788: ARRAY
43789: IN
43790: NOT
43791: IFFALSE 43837
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
43793: LD_ADDR_EXP 106
43797: PUSH
43798: LD_EXP 106
43802: PPUSH
43803: LD_VAR 0 2
43807: PUSH
43808: LD_EXP 106
43812: PUSH
43813: LD_VAR 0 2
43817: ARRAY
43818: PUSH
43819: LD_INT 1
43821: PLUS
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PPUSH
43827: LD_VAR 0 3
43831: PPUSH
43832: CALL 68420 0 3
43836: ST_TO_ADDR
// break ;
43837: GO 43841
// end ; end ; end ;
43839: GO 43675
43841: POP
43842: POP
// end ;
43843: GO 43435
43845: POP
43846: POP
// end ;
43847: LD_VAR 0 1
43851: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
43852: LD_INT 0
43854: PPUSH
43855: PPUSH
43856: PPUSH
43857: PPUSH
43858: PPUSH
43859: PPUSH
43860: PPUSH
43861: PPUSH
43862: PPUSH
// if not mc_bases then
43863: LD_EXP 99
43867: NOT
43868: IFFALSE 43872
// exit ;
43870: GO 44277
// for i = 1 to mc_bases do
43872: LD_ADDR_VAR 0 2
43876: PUSH
43877: DOUBLE
43878: LD_INT 1
43880: DEC
43881: ST_TO_ADDR
43882: LD_EXP 99
43886: PUSH
43887: FOR_TO
43888: IFFALSE 44275
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
43890: LD_EXP 107
43894: PUSH
43895: LD_VAR 0 2
43899: ARRAY
43900: NOT
43901: PUSH
43902: LD_EXP 99
43906: PUSH
43907: LD_VAR 0 2
43911: ARRAY
43912: PPUSH
43913: LD_INT 30
43915: PUSH
43916: LD_INT 3
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PPUSH
43923: CALL_OW 72
43927: NOT
43928: OR
43929: IFFALSE 43933
// continue ;
43931: GO 43887
// busy := false ;
43933: LD_ADDR_VAR 0 8
43937: PUSH
43938: LD_INT 0
43940: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
43941: LD_ADDR_VAR 0 4
43945: PUSH
43946: LD_EXP 99
43950: PUSH
43951: LD_VAR 0 2
43955: ARRAY
43956: PPUSH
43957: LD_INT 30
43959: PUSH
43960: LD_INT 3
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PPUSH
43967: CALL_OW 72
43971: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
43972: LD_ADDR_VAR 0 6
43976: PUSH
43977: LD_EXP 107
43981: PUSH
43982: LD_VAR 0 2
43986: ARRAY
43987: PPUSH
43988: LD_INT 2
43990: PUSH
43991: LD_INT 30
43993: PUSH
43994: LD_INT 32
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 30
44003: PUSH
44004: LD_INT 33
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: LIST
44015: PPUSH
44016: CALL_OW 72
44020: ST_TO_ADDR
// if not t then
44021: LD_VAR 0 6
44025: NOT
44026: IFFALSE 44030
// continue ;
44028: GO 43887
// for j in tmp do
44030: LD_ADDR_VAR 0 3
44034: PUSH
44035: LD_VAR 0 4
44039: PUSH
44040: FOR_IN
44041: IFFALSE 44071
// if not BuildingStatus ( j ) = bs_idle then
44043: LD_VAR 0 3
44047: PPUSH
44048: CALL_OW 461
44052: PUSH
44053: LD_INT 2
44055: EQUAL
44056: NOT
44057: IFFALSE 44069
// begin busy := true ;
44059: LD_ADDR_VAR 0 8
44063: PUSH
44064: LD_INT 1
44066: ST_TO_ADDR
// break ;
44067: GO 44071
// end ;
44069: GO 44040
44071: POP
44072: POP
// if busy then
44073: LD_VAR 0 8
44077: IFFALSE 44081
// continue ;
44079: GO 43887
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
44081: LD_ADDR_VAR 0 7
44085: PUSH
44086: LD_VAR 0 6
44090: PPUSH
44091: LD_INT 35
44093: PUSH
44094: LD_INT 0
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PPUSH
44101: CALL_OW 72
44105: ST_TO_ADDR
// if tw then
44106: LD_VAR 0 7
44110: IFFALSE 44187
// begin tw := tw [ 1 ] ;
44112: LD_ADDR_VAR 0 7
44116: PUSH
44117: LD_VAR 0 7
44121: PUSH
44122: LD_INT 1
44124: ARRAY
44125: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
44126: LD_ADDR_VAR 0 9
44130: PUSH
44131: LD_VAR 0 7
44135: PPUSH
44136: LD_EXP 124
44140: PUSH
44141: LD_VAR 0 2
44145: ARRAY
44146: PPUSH
44147: CALL 73390 0 2
44151: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
44152: LD_EXP 138
44156: PUSH
44157: LD_VAR 0 2
44161: ARRAY
44162: IFFALSE 44185
// if not weapon in mc_allowed_tower_weapons [ i ] then
44164: LD_VAR 0 9
44168: PUSH
44169: LD_EXP 138
44173: PUSH
44174: LD_VAR 0 2
44178: ARRAY
44179: IN
44180: NOT
44181: IFFALSE 44185
// continue ;
44183: GO 43887
// end else
44185: GO 44250
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
44187: LD_ADDR_VAR 0 5
44191: PUSH
44192: LD_EXP 107
44196: PUSH
44197: LD_VAR 0 2
44201: ARRAY
44202: PPUSH
44203: LD_VAR 0 4
44207: PPUSH
44208: CALL 103529 0 2
44212: ST_TO_ADDR
// if not tmp2 then
44213: LD_VAR 0 5
44217: NOT
44218: IFFALSE 44222
// continue ;
44220: GO 43887
// tw := tmp2 [ 1 ] ;
44222: LD_ADDR_VAR 0 7
44226: PUSH
44227: LD_VAR 0 5
44231: PUSH
44232: LD_INT 1
44234: ARRAY
44235: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
44236: LD_ADDR_VAR 0 9
44240: PUSH
44241: LD_VAR 0 5
44245: PUSH
44246: LD_INT 2
44248: ARRAY
44249: ST_TO_ADDR
// end ; if not weapon then
44250: LD_VAR 0 9
44254: NOT
44255: IFFALSE 44259
// continue ;
44257: GO 43887
// ComPlaceWeapon ( tw , weapon ) ;
44259: LD_VAR 0 7
44263: PPUSH
44264: LD_VAR 0 9
44268: PPUSH
44269: CALL_OW 148
// end ;
44273: GO 43887
44275: POP
44276: POP
// end ;
44277: LD_VAR 0 1
44281: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
44282: LD_INT 0
44284: PPUSH
44285: PPUSH
44286: PPUSH
44287: PPUSH
44288: PPUSH
44289: PPUSH
// if not mc_bases then
44290: LD_EXP 99
44294: NOT
44295: IFFALSE 44299
// exit ;
44297: GO 45311
// for i = 1 to mc_bases do
44299: LD_ADDR_VAR 0 2
44303: PUSH
44304: DOUBLE
44305: LD_INT 1
44307: DEC
44308: ST_TO_ADDR
44309: LD_EXP 99
44313: PUSH
44314: FOR_TO
44315: IFFALSE 45309
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
44317: LD_EXP 112
44321: PUSH
44322: LD_VAR 0 2
44326: ARRAY
44327: NOT
44328: PUSH
44329: LD_EXP 112
44333: PUSH
44334: LD_VAR 0 2
44338: ARRAY
44339: PUSH
44340: LD_EXP 113
44344: PUSH
44345: LD_VAR 0 2
44349: ARRAY
44350: EQUAL
44351: OR
44352: IFFALSE 44356
// continue ;
44354: GO 44314
// if mc_miners [ i ] then
44356: LD_EXP 113
44360: PUSH
44361: LD_VAR 0 2
44365: ARRAY
44366: IFFALSE 44996
// begin k := 1 ;
44368: LD_ADDR_VAR 0 4
44372: PUSH
44373: LD_INT 1
44375: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
44376: LD_ADDR_VAR 0 3
44380: PUSH
44381: DOUBLE
44382: LD_EXP 113
44386: PUSH
44387: LD_VAR 0 2
44391: ARRAY
44392: INC
44393: ST_TO_ADDR
44394: LD_INT 1
44396: PUSH
44397: FOR_DOWNTO
44398: IFFALSE 44994
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
44400: LD_EXP 113
44404: PUSH
44405: LD_VAR 0 2
44409: ARRAY
44410: PUSH
44411: LD_VAR 0 3
44415: ARRAY
44416: PPUSH
44417: CALL_OW 301
44421: PUSH
44422: LD_EXP 113
44426: PUSH
44427: LD_VAR 0 2
44431: ARRAY
44432: PUSH
44433: LD_VAR 0 3
44437: ARRAY
44438: PPUSH
44439: CALL_OW 257
44443: PUSH
44444: LD_INT 1
44446: NONEQUAL
44447: OR
44448: IFFALSE 44511
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
44450: LD_ADDR_VAR 0 5
44454: PUSH
44455: LD_EXP 113
44459: PUSH
44460: LD_VAR 0 2
44464: ARRAY
44465: PUSH
44466: LD_EXP 113
44470: PUSH
44471: LD_VAR 0 2
44475: ARRAY
44476: PUSH
44477: LD_VAR 0 3
44481: ARRAY
44482: DIFF
44483: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
44484: LD_ADDR_EXP 113
44488: PUSH
44489: LD_EXP 113
44493: PPUSH
44494: LD_VAR 0 2
44498: PPUSH
44499: LD_VAR 0 5
44503: PPUSH
44504: CALL_OW 1
44508: ST_TO_ADDR
// continue ;
44509: GO 44397
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
44511: LD_EXP 113
44515: PUSH
44516: LD_VAR 0 2
44520: ARRAY
44521: PUSH
44522: LD_VAR 0 3
44526: ARRAY
44527: PPUSH
44528: CALL 68356 0 1
44532: PUSH
44533: LD_EXP 113
44537: PUSH
44538: LD_VAR 0 2
44542: ARRAY
44543: PUSH
44544: LD_VAR 0 3
44548: ARRAY
44549: PPUSH
44550: CALL_OW 255
44554: PPUSH
44555: LD_EXP 112
44559: PUSH
44560: LD_VAR 0 2
44564: ARRAY
44565: PUSH
44566: LD_VAR 0 4
44570: ARRAY
44571: PUSH
44572: LD_INT 1
44574: ARRAY
44575: PPUSH
44576: LD_EXP 112
44580: PUSH
44581: LD_VAR 0 2
44585: ARRAY
44586: PUSH
44587: LD_VAR 0 4
44591: ARRAY
44592: PUSH
44593: LD_INT 2
44595: ARRAY
44596: PPUSH
44597: LD_INT 15
44599: PPUSH
44600: CALL 69316 0 4
44604: PUSH
44605: LD_INT 4
44607: ARRAY
44608: PUSH
44609: LD_EXP 113
44613: PUSH
44614: LD_VAR 0 2
44618: ARRAY
44619: PUSH
44620: LD_VAR 0 3
44624: ARRAY
44625: PPUSH
44626: LD_INT 10
44628: PPUSH
44629: CALL 71013 0 2
44633: PUSH
44634: LD_INT 4
44636: ARRAY
44637: OR
44638: AND
44639: IFFALSE 44662
// ComStop ( mc_miners [ i ] [ j ] ) ;
44641: LD_EXP 113
44645: PUSH
44646: LD_VAR 0 2
44650: ARRAY
44651: PUSH
44652: LD_VAR 0 3
44656: ARRAY
44657: PPUSH
44658: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
44662: LD_EXP 113
44666: PUSH
44667: LD_VAR 0 2
44671: ARRAY
44672: PUSH
44673: LD_VAR 0 3
44677: ARRAY
44678: PPUSH
44679: CALL_OW 257
44683: PUSH
44684: LD_INT 1
44686: EQUAL
44687: PUSH
44688: LD_EXP 113
44692: PUSH
44693: LD_VAR 0 2
44697: ARRAY
44698: PUSH
44699: LD_VAR 0 3
44703: ARRAY
44704: PPUSH
44705: CALL_OW 459
44709: NOT
44710: AND
44711: PUSH
44712: LD_EXP 113
44716: PUSH
44717: LD_VAR 0 2
44721: ARRAY
44722: PUSH
44723: LD_VAR 0 3
44727: ARRAY
44728: PPUSH
44729: CALL_OW 255
44733: PPUSH
44734: LD_EXP 112
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: PUSH
44745: LD_VAR 0 4
44749: ARRAY
44750: PUSH
44751: LD_INT 1
44753: ARRAY
44754: PPUSH
44755: LD_EXP 112
44759: PUSH
44760: LD_VAR 0 2
44764: ARRAY
44765: PUSH
44766: LD_VAR 0 4
44770: ARRAY
44771: PUSH
44772: LD_INT 2
44774: ARRAY
44775: PPUSH
44776: LD_INT 15
44778: PPUSH
44779: CALL 69316 0 4
44783: PUSH
44784: LD_INT 4
44786: ARRAY
44787: PUSH
44788: LD_INT 0
44790: EQUAL
44791: AND
44792: PUSH
44793: LD_EXP 113
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: PUSH
44804: LD_VAR 0 3
44808: ARRAY
44809: PPUSH
44810: CALL_OW 314
44814: NOT
44815: AND
44816: IFFALSE 44992
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
44818: LD_EXP 113
44822: PUSH
44823: LD_VAR 0 2
44827: ARRAY
44828: PUSH
44829: LD_VAR 0 3
44833: ARRAY
44834: PPUSH
44835: CALL_OW 310
44839: IFFALSE 44862
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
44841: LD_EXP 113
44845: PUSH
44846: LD_VAR 0 2
44850: ARRAY
44851: PUSH
44852: LD_VAR 0 3
44856: ARRAY
44857: PPUSH
44858: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
44862: LD_EXP 113
44866: PUSH
44867: LD_VAR 0 2
44871: ARRAY
44872: PUSH
44873: LD_VAR 0 3
44877: ARRAY
44878: PPUSH
44879: CALL_OW 314
44883: NOT
44884: IFFALSE 44952
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
44886: LD_EXP 113
44890: PUSH
44891: LD_VAR 0 2
44895: ARRAY
44896: PUSH
44897: LD_VAR 0 3
44901: ARRAY
44902: PPUSH
44903: LD_EXP 112
44907: PUSH
44908: LD_VAR 0 2
44912: ARRAY
44913: PUSH
44914: LD_VAR 0 4
44918: ARRAY
44919: PUSH
44920: LD_INT 1
44922: ARRAY
44923: PPUSH
44924: LD_EXP 112
44928: PUSH
44929: LD_VAR 0 2
44933: ARRAY
44934: PUSH
44935: LD_VAR 0 4
44939: ARRAY
44940: PUSH
44941: LD_INT 2
44943: ARRAY
44944: PPUSH
44945: LD_INT 0
44947: PPUSH
44948: CALL_OW 193
// k := k + 1 ;
44952: LD_ADDR_VAR 0 4
44956: PUSH
44957: LD_VAR 0 4
44961: PUSH
44962: LD_INT 1
44964: PLUS
44965: ST_TO_ADDR
// if k > mc_mines [ i ] then
44966: LD_VAR 0 4
44970: PUSH
44971: LD_EXP 112
44975: PUSH
44976: LD_VAR 0 2
44980: ARRAY
44981: GREATER
44982: IFFALSE 44992
// k := 1 ;
44984: LD_ADDR_VAR 0 4
44988: PUSH
44989: LD_INT 1
44991: ST_TO_ADDR
// end ; end ;
44992: GO 44397
44994: POP
44995: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
44996: LD_ADDR_VAR 0 5
45000: PUSH
45001: LD_EXP 99
45005: PUSH
45006: LD_VAR 0 2
45010: ARRAY
45011: PPUSH
45012: LD_INT 2
45014: PUSH
45015: LD_INT 30
45017: PUSH
45018: LD_INT 4
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PUSH
45025: LD_INT 30
45027: PUSH
45028: LD_INT 5
45030: PUSH
45031: EMPTY
45032: LIST
45033: LIST
45034: PUSH
45035: LD_INT 30
45037: PUSH
45038: LD_INT 32
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: PPUSH
45051: CALL_OW 72
45055: ST_TO_ADDR
// if not tmp then
45056: LD_VAR 0 5
45060: NOT
45061: IFFALSE 45065
// continue ;
45063: GO 44314
// list := [ ] ;
45065: LD_ADDR_VAR 0 6
45069: PUSH
45070: EMPTY
45071: ST_TO_ADDR
// for j in tmp do
45072: LD_ADDR_VAR 0 3
45076: PUSH
45077: LD_VAR 0 5
45081: PUSH
45082: FOR_IN
45083: IFFALSE 45152
// begin for k in UnitsInside ( j ) do
45085: LD_ADDR_VAR 0 4
45089: PUSH
45090: LD_VAR 0 3
45094: PPUSH
45095: CALL_OW 313
45099: PUSH
45100: FOR_IN
45101: IFFALSE 45148
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
45103: LD_VAR 0 4
45107: PPUSH
45108: CALL_OW 257
45112: PUSH
45113: LD_INT 1
45115: EQUAL
45116: PUSH
45117: LD_VAR 0 4
45121: PPUSH
45122: CALL_OW 459
45126: NOT
45127: AND
45128: IFFALSE 45146
// list := list ^ k ;
45130: LD_ADDR_VAR 0 6
45134: PUSH
45135: LD_VAR 0 6
45139: PUSH
45140: LD_VAR 0 4
45144: ADD
45145: ST_TO_ADDR
45146: GO 45100
45148: POP
45149: POP
// end ;
45150: GO 45082
45152: POP
45153: POP
// list := list diff mc_miners [ i ] ;
45154: LD_ADDR_VAR 0 6
45158: PUSH
45159: LD_VAR 0 6
45163: PUSH
45164: LD_EXP 113
45168: PUSH
45169: LD_VAR 0 2
45173: ARRAY
45174: DIFF
45175: ST_TO_ADDR
// if not list then
45176: LD_VAR 0 6
45180: NOT
45181: IFFALSE 45185
// continue ;
45183: GO 44314
// k := mc_mines [ i ] - mc_miners [ i ] ;
45185: LD_ADDR_VAR 0 4
45189: PUSH
45190: LD_EXP 112
45194: PUSH
45195: LD_VAR 0 2
45199: ARRAY
45200: PUSH
45201: LD_EXP 113
45205: PUSH
45206: LD_VAR 0 2
45210: ARRAY
45211: MINUS
45212: ST_TO_ADDR
// if k > list then
45213: LD_VAR 0 4
45217: PUSH
45218: LD_VAR 0 6
45222: GREATER
45223: IFFALSE 45235
// k := list ;
45225: LD_ADDR_VAR 0 4
45229: PUSH
45230: LD_VAR 0 6
45234: ST_TO_ADDR
// for j = 1 to k do
45235: LD_ADDR_VAR 0 3
45239: PUSH
45240: DOUBLE
45241: LD_INT 1
45243: DEC
45244: ST_TO_ADDR
45245: LD_VAR 0 4
45249: PUSH
45250: FOR_TO
45251: IFFALSE 45305
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
45253: LD_ADDR_EXP 113
45257: PUSH
45258: LD_EXP 113
45262: PPUSH
45263: LD_VAR 0 2
45267: PUSH
45268: LD_EXP 113
45272: PUSH
45273: LD_VAR 0 2
45277: ARRAY
45278: PUSH
45279: LD_INT 1
45281: PLUS
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PPUSH
45287: LD_VAR 0 6
45291: PUSH
45292: LD_VAR 0 3
45296: ARRAY
45297: PPUSH
45298: CALL 68420 0 3
45302: ST_TO_ADDR
45303: GO 45250
45305: POP
45306: POP
// end ;
45307: GO 44314
45309: POP
45310: POP
// end ;
45311: LD_VAR 0 1
45315: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
45316: LD_INT 0
45318: PPUSH
45319: PPUSH
45320: PPUSH
45321: PPUSH
45322: PPUSH
45323: PPUSH
45324: PPUSH
45325: PPUSH
45326: PPUSH
45327: PPUSH
// if not mc_bases then
45328: LD_EXP 99
45332: NOT
45333: IFFALSE 45337
// exit ;
45335: GO 47068
// for i = 1 to mc_bases do
45337: LD_ADDR_VAR 0 2
45341: PUSH
45342: DOUBLE
45343: LD_INT 1
45345: DEC
45346: ST_TO_ADDR
45347: LD_EXP 99
45351: PUSH
45352: FOR_TO
45353: IFFALSE 47066
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
45355: LD_EXP 99
45359: PUSH
45360: LD_VAR 0 2
45364: ARRAY
45365: NOT
45366: PUSH
45367: LD_EXP 106
45371: PUSH
45372: LD_VAR 0 2
45376: ARRAY
45377: OR
45378: IFFALSE 45382
// continue ;
45380: GO 45352
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
45382: LD_EXP 115
45386: PUSH
45387: LD_VAR 0 2
45391: ARRAY
45392: NOT
45393: PUSH
45394: LD_EXP 116
45398: PUSH
45399: LD_VAR 0 2
45403: ARRAY
45404: AND
45405: IFFALSE 45443
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
45407: LD_ADDR_EXP 116
45411: PUSH
45412: LD_EXP 116
45416: PPUSH
45417: LD_VAR 0 2
45421: PPUSH
45422: EMPTY
45423: PPUSH
45424: CALL_OW 1
45428: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
45429: LD_VAR 0 2
45433: PPUSH
45434: LD_INT 107
45436: PPUSH
45437: CALL 36532 0 2
// continue ;
45441: GO 45352
// end ; target := [ ] ;
45443: LD_ADDR_VAR 0 6
45447: PUSH
45448: EMPTY
45449: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
45450: LD_ADDR_VAR 0 3
45454: PUSH
45455: DOUBLE
45456: LD_EXP 115
45460: PUSH
45461: LD_VAR 0 2
45465: ARRAY
45466: INC
45467: ST_TO_ADDR
45468: LD_INT 1
45470: PUSH
45471: FOR_DOWNTO
45472: IFFALSE 45732
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
45474: LD_EXP 115
45478: PUSH
45479: LD_VAR 0 2
45483: ARRAY
45484: PUSH
45485: LD_VAR 0 3
45489: ARRAY
45490: PUSH
45491: LD_INT 2
45493: ARRAY
45494: PPUSH
45495: LD_EXP 115
45499: PUSH
45500: LD_VAR 0 2
45504: ARRAY
45505: PUSH
45506: LD_VAR 0 3
45510: ARRAY
45511: PUSH
45512: LD_INT 3
45514: ARRAY
45515: PPUSH
45516: CALL_OW 488
45520: PUSH
45521: LD_EXP 115
45525: PUSH
45526: LD_VAR 0 2
45530: ARRAY
45531: PUSH
45532: LD_VAR 0 3
45536: ARRAY
45537: PUSH
45538: LD_INT 2
45540: ARRAY
45541: PPUSH
45542: LD_EXP 115
45546: PUSH
45547: LD_VAR 0 2
45551: ARRAY
45552: PUSH
45553: LD_VAR 0 3
45557: ARRAY
45558: PUSH
45559: LD_INT 3
45561: ARRAY
45562: PPUSH
45563: CALL_OW 284
45567: PUSH
45568: LD_INT 0
45570: EQUAL
45571: AND
45572: IFFALSE 45627
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
45574: LD_ADDR_VAR 0 5
45578: PUSH
45579: LD_EXP 115
45583: PUSH
45584: LD_VAR 0 2
45588: ARRAY
45589: PPUSH
45590: LD_VAR 0 3
45594: PPUSH
45595: CALL_OW 3
45599: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
45600: LD_ADDR_EXP 115
45604: PUSH
45605: LD_EXP 115
45609: PPUSH
45610: LD_VAR 0 2
45614: PPUSH
45615: LD_VAR 0 5
45619: PPUSH
45620: CALL_OW 1
45624: ST_TO_ADDR
// continue ;
45625: GO 45471
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
45627: LD_EXP 99
45631: PUSH
45632: LD_VAR 0 2
45636: ARRAY
45637: PUSH
45638: LD_INT 1
45640: ARRAY
45641: PPUSH
45642: CALL_OW 255
45646: PPUSH
45647: LD_EXP 115
45651: PUSH
45652: LD_VAR 0 2
45656: ARRAY
45657: PUSH
45658: LD_VAR 0 3
45662: ARRAY
45663: PUSH
45664: LD_INT 2
45666: ARRAY
45667: PPUSH
45668: LD_EXP 115
45672: PUSH
45673: LD_VAR 0 2
45677: ARRAY
45678: PUSH
45679: LD_VAR 0 3
45683: ARRAY
45684: PUSH
45685: LD_INT 3
45687: ARRAY
45688: PPUSH
45689: LD_INT 30
45691: PPUSH
45692: CALL 69316 0 4
45696: PUSH
45697: LD_INT 4
45699: ARRAY
45700: PUSH
45701: LD_INT 0
45703: EQUAL
45704: IFFALSE 45730
// begin target := mc_crates [ i ] [ j ] ;
45706: LD_ADDR_VAR 0 6
45710: PUSH
45711: LD_EXP 115
45715: PUSH
45716: LD_VAR 0 2
45720: ARRAY
45721: PUSH
45722: LD_VAR 0 3
45726: ARRAY
45727: ST_TO_ADDR
// break ;
45728: GO 45732
// end ; end ;
45730: GO 45471
45732: POP
45733: POP
// if not target then
45734: LD_VAR 0 6
45738: NOT
45739: IFFALSE 45743
// continue ;
45741: GO 45352
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
45743: LD_ADDR_VAR 0 7
45747: PUSH
45748: LD_EXP 118
45752: PUSH
45753: LD_VAR 0 2
45757: ARRAY
45758: PPUSH
45759: LD_INT 2
45761: PUSH
45762: LD_INT 3
45764: PUSH
45765: LD_INT 58
45767: PUSH
45768: EMPTY
45769: LIST
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: LD_INT 61
45777: PUSH
45778: EMPTY
45779: LIST
45780: PUSH
45781: LD_INT 33
45783: PUSH
45784: LD_INT 5
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: PUSH
45791: LD_INT 33
45793: PUSH
45794: LD_INT 3
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: PUSH
45808: LD_INT 2
45810: PUSH
45811: LD_INT 34
45813: PUSH
45814: LD_INT 32
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 34
45823: PUSH
45824: LD_INT 51
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 34
45833: PUSH
45834: LD_INT 12
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PPUSH
45851: CALL_OW 72
45855: ST_TO_ADDR
// if not cargo then
45856: LD_VAR 0 7
45860: NOT
45861: IFFALSE 46504
// begin if mc_crates_collector [ i ] < 5 then
45863: LD_EXP 116
45867: PUSH
45868: LD_VAR 0 2
45872: ARRAY
45873: PUSH
45874: LD_INT 5
45876: LESS
45877: IFFALSE 46243
// begin if mc_ape [ i ] then
45879: LD_EXP 128
45883: PUSH
45884: LD_VAR 0 2
45888: ARRAY
45889: IFFALSE 45936
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
45891: LD_ADDR_VAR 0 5
45895: PUSH
45896: LD_EXP 128
45900: PUSH
45901: LD_VAR 0 2
45905: ARRAY
45906: PPUSH
45907: LD_INT 25
45909: PUSH
45910: LD_INT 16
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: PUSH
45917: LD_INT 24
45919: PUSH
45920: LD_INT 750
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: PUSH
45927: EMPTY
45928: LIST
45929: LIST
45930: PPUSH
45931: CALL_OW 72
45935: ST_TO_ADDR
// if not tmp then
45936: LD_VAR 0 5
45940: NOT
45941: IFFALSE 45988
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
45943: LD_ADDR_VAR 0 5
45947: PUSH
45948: LD_EXP 99
45952: PUSH
45953: LD_VAR 0 2
45957: ARRAY
45958: PPUSH
45959: LD_INT 25
45961: PUSH
45962: LD_INT 2
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 24
45971: PUSH
45972: LD_INT 750
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PPUSH
45983: CALL_OW 72
45987: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
45988: LD_EXP 128
45992: PUSH
45993: LD_VAR 0 2
45997: ARRAY
45998: PUSH
45999: LD_EXP 99
46003: PUSH
46004: LD_VAR 0 2
46008: ARRAY
46009: PPUSH
46010: LD_INT 25
46012: PUSH
46013: LD_INT 2
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: LD_INT 24
46022: PUSH
46023: LD_INT 750
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PPUSH
46034: CALL_OW 72
46038: AND
46039: PUSH
46040: LD_VAR 0 5
46044: PUSH
46045: LD_INT 5
46047: LESS
46048: AND
46049: IFFALSE 46131
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
46051: LD_ADDR_VAR 0 3
46055: PUSH
46056: LD_EXP 99
46060: PUSH
46061: LD_VAR 0 2
46065: ARRAY
46066: PPUSH
46067: LD_INT 25
46069: PUSH
46070: LD_INT 2
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 24
46079: PUSH
46080: LD_INT 750
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PPUSH
46091: CALL_OW 72
46095: PUSH
46096: FOR_IN
46097: IFFALSE 46129
// begin tmp := tmp union j ;
46099: LD_ADDR_VAR 0 5
46103: PUSH
46104: LD_VAR 0 5
46108: PUSH
46109: LD_VAR 0 3
46113: UNION
46114: ST_TO_ADDR
// if tmp >= 5 then
46115: LD_VAR 0 5
46119: PUSH
46120: LD_INT 5
46122: GREATEREQUAL
46123: IFFALSE 46127
// break ;
46125: GO 46129
// end ;
46127: GO 46096
46129: POP
46130: POP
// end ; if not tmp then
46131: LD_VAR 0 5
46135: NOT
46136: IFFALSE 46140
// continue ;
46138: GO 45352
// for j in tmp do
46140: LD_ADDR_VAR 0 3
46144: PUSH
46145: LD_VAR 0 5
46149: PUSH
46150: FOR_IN
46151: IFFALSE 46241
// if not GetTag ( j ) then
46153: LD_VAR 0 3
46157: PPUSH
46158: CALL_OW 110
46162: NOT
46163: IFFALSE 46239
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
46165: LD_ADDR_EXP 116
46169: PUSH
46170: LD_EXP 116
46174: PPUSH
46175: LD_VAR 0 2
46179: PUSH
46180: LD_EXP 116
46184: PUSH
46185: LD_VAR 0 2
46189: ARRAY
46190: PUSH
46191: LD_INT 1
46193: PLUS
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PPUSH
46199: LD_VAR 0 3
46203: PPUSH
46204: CALL 68420 0 3
46208: ST_TO_ADDR
// SetTag ( j , 107 ) ;
46209: LD_VAR 0 3
46213: PPUSH
46214: LD_INT 107
46216: PPUSH
46217: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
46221: LD_EXP 116
46225: PUSH
46226: LD_VAR 0 2
46230: ARRAY
46231: PUSH
46232: LD_INT 5
46234: GREATEREQUAL
46235: IFFALSE 46239
// break ;
46237: GO 46241
// end ;
46239: GO 46150
46241: POP
46242: POP
// end ; if mc_crates_collector [ i ] and target then
46243: LD_EXP 116
46247: PUSH
46248: LD_VAR 0 2
46252: ARRAY
46253: PUSH
46254: LD_VAR 0 6
46258: AND
46259: IFFALSE 46502
// begin if mc_crates_collector [ i ] < target [ 1 ] then
46261: LD_EXP 116
46265: PUSH
46266: LD_VAR 0 2
46270: ARRAY
46271: PUSH
46272: LD_VAR 0 6
46276: PUSH
46277: LD_INT 1
46279: ARRAY
46280: LESS
46281: IFFALSE 46301
// tmp := mc_crates_collector [ i ] else
46283: LD_ADDR_VAR 0 5
46287: PUSH
46288: LD_EXP 116
46292: PUSH
46293: LD_VAR 0 2
46297: ARRAY
46298: ST_TO_ADDR
46299: GO 46315
// tmp := target [ 1 ] ;
46301: LD_ADDR_VAR 0 5
46305: PUSH
46306: LD_VAR 0 6
46310: PUSH
46311: LD_INT 1
46313: ARRAY
46314: ST_TO_ADDR
// k := 0 ;
46315: LD_ADDR_VAR 0 4
46319: PUSH
46320: LD_INT 0
46322: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
46323: LD_ADDR_VAR 0 3
46327: PUSH
46328: LD_EXP 116
46332: PUSH
46333: LD_VAR 0 2
46337: ARRAY
46338: PUSH
46339: FOR_IN
46340: IFFALSE 46500
// begin k := k + 1 ;
46342: LD_ADDR_VAR 0 4
46346: PUSH
46347: LD_VAR 0 4
46351: PUSH
46352: LD_INT 1
46354: PLUS
46355: ST_TO_ADDR
// if k > tmp then
46356: LD_VAR 0 4
46360: PUSH
46361: LD_VAR 0 5
46365: GREATER
46366: IFFALSE 46370
// break ;
46368: GO 46500
// if not GetClass ( j ) in [ 2 , 16 ] then
46370: LD_VAR 0 3
46374: PPUSH
46375: CALL_OW 257
46379: PUSH
46380: LD_INT 2
46382: PUSH
46383: LD_INT 16
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: IN
46390: NOT
46391: IFFALSE 46444
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
46393: LD_ADDR_EXP 116
46397: PUSH
46398: LD_EXP 116
46402: PPUSH
46403: LD_VAR 0 2
46407: PPUSH
46408: LD_EXP 116
46412: PUSH
46413: LD_VAR 0 2
46417: ARRAY
46418: PUSH
46419: LD_VAR 0 3
46423: DIFF
46424: PPUSH
46425: CALL_OW 1
46429: ST_TO_ADDR
// SetTag ( j , 0 ) ;
46430: LD_VAR 0 3
46434: PPUSH
46435: LD_INT 0
46437: PPUSH
46438: CALL_OW 109
// continue ;
46442: GO 46339
// end ; if IsInUnit ( j ) then
46444: LD_VAR 0 3
46448: PPUSH
46449: CALL_OW 310
46453: IFFALSE 46464
// ComExitBuilding ( j ) ;
46455: LD_VAR 0 3
46459: PPUSH
46460: CALL_OW 122
// wait ( 3 ) ;
46464: LD_INT 3
46466: PPUSH
46467: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
46471: LD_VAR 0 3
46475: PPUSH
46476: LD_VAR 0 6
46480: PUSH
46481: LD_INT 2
46483: ARRAY
46484: PPUSH
46485: LD_VAR 0 6
46489: PUSH
46490: LD_INT 3
46492: ARRAY
46493: PPUSH
46494: CALL_OW 117
// end ;
46498: GO 46339
46500: POP
46501: POP
// end ; end else
46502: GO 47064
// begin for j in cargo do
46504: LD_ADDR_VAR 0 3
46508: PUSH
46509: LD_VAR 0 7
46513: PUSH
46514: FOR_IN
46515: IFFALSE 47062
// begin if GetTag ( j ) <> 0 then
46517: LD_VAR 0 3
46521: PPUSH
46522: CALL_OW 110
46526: PUSH
46527: LD_INT 0
46529: NONEQUAL
46530: IFFALSE 46534
// continue ;
46532: GO 46514
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
46534: LD_VAR 0 3
46538: PPUSH
46539: CALL_OW 256
46543: PUSH
46544: LD_INT 1000
46546: LESS
46547: PUSH
46548: LD_VAR 0 3
46552: PPUSH
46553: LD_EXP 123
46557: PUSH
46558: LD_VAR 0 2
46562: ARRAY
46563: PPUSH
46564: CALL_OW 308
46568: NOT
46569: AND
46570: IFFALSE 46592
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46572: LD_VAR 0 3
46576: PPUSH
46577: LD_EXP 123
46581: PUSH
46582: LD_VAR 0 2
46586: ARRAY
46587: PPUSH
46588: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
46592: LD_VAR 0 3
46596: PPUSH
46597: CALL_OW 256
46601: PUSH
46602: LD_INT 1000
46604: LESS
46605: PUSH
46606: LD_VAR 0 3
46610: PPUSH
46611: LD_EXP 123
46615: PUSH
46616: LD_VAR 0 2
46620: ARRAY
46621: PPUSH
46622: CALL_OW 308
46626: AND
46627: IFFALSE 46631
// continue ;
46629: GO 46514
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
46631: LD_VAR 0 3
46635: PPUSH
46636: CALL_OW 262
46640: PUSH
46641: LD_INT 2
46643: EQUAL
46644: PUSH
46645: LD_VAR 0 3
46649: PPUSH
46650: CALL_OW 261
46654: PUSH
46655: LD_INT 15
46657: LESS
46658: AND
46659: IFFALSE 46663
// continue ;
46661: GO 46514
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
46663: LD_VAR 0 3
46667: PPUSH
46668: CALL_OW 262
46672: PUSH
46673: LD_INT 1
46675: EQUAL
46676: PUSH
46677: LD_VAR 0 3
46681: PPUSH
46682: CALL_OW 261
46686: PUSH
46687: LD_INT 10
46689: LESS
46690: AND
46691: IFFALSE 47001
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46693: LD_ADDR_VAR 0 8
46697: PUSH
46698: LD_EXP 99
46702: PUSH
46703: LD_VAR 0 2
46707: ARRAY
46708: PPUSH
46709: LD_INT 2
46711: PUSH
46712: LD_INT 30
46714: PUSH
46715: LD_INT 0
46717: PUSH
46718: EMPTY
46719: LIST
46720: LIST
46721: PUSH
46722: LD_INT 30
46724: PUSH
46725: LD_INT 1
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: LIST
46736: PPUSH
46737: CALL_OW 72
46741: ST_TO_ADDR
// if not depot then
46742: LD_VAR 0 8
46746: NOT
46747: IFFALSE 46751
// continue ;
46749: GO 46514
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
46751: LD_VAR 0 3
46755: PPUSH
46756: LD_VAR 0 8
46760: PPUSH
46761: LD_VAR 0 3
46765: PPUSH
46766: CALL_OW 74
46770: PPUSH
46771: CALL_OW 296
46775: PUSH
46776: LD_INT 6
46778: LESS
46779: IFFALSE 46795
// SetFuel ( j , 100 ) else
46781: LD_VAR 0 3
46785: PPUSH
46786: LD_INT 100
46788: PPUSH
46789: CALL_OW 240
46793: GO 47001
// if GetFuel ( j ) = 0 then
46795: LD_VAR 0 3
46799: PPUSH
46800: CALL_OW 261
46804: PUSH
46805: LD_INT 0
46807: EQUAL
46808: IFFALSE 47001
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
46810: LD_ADDR_EXP 118
46814: PUSH
46815: LD_EXP 118
46819: PPUSH
46820: LD_VAR 0 2
46824: PPUSH
46825: LD_EXP 118
46829: PUSH
46830: LD_VAR 0 2
46834: ARRAY
46835: PUSH
46836: LD_VAR 0 3
46840: DIFF
46841: PPUSH
46842: CALL_OW 1
46846: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
46847: LD_VAR 0 3
46851: PPUSH
46852: CALL_OW 263
46856: PUSH
46857: LD_INT 1
46859: EQUAL
46860: IFFALSE 46876
// ComExitVehicle ( IsInUnit ( j ) ) ;
46862: LD_VAR 0 3
46866: PPUSH
46867: CALL_OW 310
46871: PPUSH
46872: CALL_OW 121
// if GetControl ( j ) = control_remote then
46876: LD_VAR 0 3
46880: PPUSH
46881: CALL_OW 263
46885: PUSH
46886: LD_INT 2
46888: EQUAL
46889: IFFALSE 46900
// ComUnlink ( j ) ;
46891: LD_VAR 0 3
46895: PPUSH
46896: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
46900: LD_ADDR_VAR 0 9
46904: PUSH
46905: LD_VAR 0 2
46909: PPUSH
46910: LD_INT 3
46912: PPUSH
46913: CALL 56105 0 2
46917: ST_TO_ADDR
// if fac then
46918: LD_VAR 0 9
46922: IFFALSE 46999
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
46924: LD_ADDR_VAR 0 10
46928: PUSH
46929: LD_VAR 0 9
46933: PPUSH
46934: LD_VAR 0 3
46938: PPUSH
46939: CALL_OW 265
46943: PPUSH
46944: LD_VAR 0 3
46948: PPUSH
46949: CALL_OW 262
46953: PPUSH
46954: LD_VAR 0 3
46958: PPUSH
46959: CALL_OW 263
46963: PPUSH
46964: LD_VAR 0 3
46968: PPUSH
46969: CALL_OW 264
46973: PPUSH
46974: CALL 66020 0 5
46978: ST_TO_ADDR
// if components then
46979: LD_VAR 0 10
46983: IFFALSE 46999
// MC_InsertProduceList ( i , components ) ;
46985: LD_VAR 0 2
46989: PPUSH
46990: LD_VAR 0 10
46994: PPUSH
46995: CALL 55733 0 2
// end ; continue ;
46999: GO 46514
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
47001: LD_VAR 0 3
47005: PPUSH
47006: LD_INT 1
47008: PPUSH
47009: CALL_OW 289
47013: PUSH
47014: LD_INT 100
47016: LESS
47017: PUSH
47018: LD_VAR 0 3
47022: PPUSH
47023: CALL_OW 314
47027: NOT
47028: AND
47029: IFFALSE 47058
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47031: LD_VAR 0 3
47035: PPUSH
47036: LD_VAR 0 6
47040: PUSH
47041: LD_INT 2
47043: ARRAY
47044: PPUSH
47045: LD_VAR 0 6
47049: PUSH
47050: LD_INT 3
47052: ARRAY
47053: PPUSH
47054: CALL_OW 117
// break ;
47058: GO 47062
// end ;
47060: GO 46514
47062: POP
47063: POP
// end ; end ;
47064: GO 45352
47066: POP
47067: POP
// end ;
47068: LD_VAR 0 1
47072: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
47073: LD_INT 0
47075: PPUSH
47076: PPUSH
47077: PPUSH
47078: PPUSH
// if not mc_bases then
47079: LD_EXP 99
47083: NOT
47084: IFFALSE 47088
// exit ;
47086: GO 47249
// for i = 1 to mc_bases do
47088: LD_ADDR_VAR 0 2
47092: PUSH
47093: DOUBLE
47094: LD_INT 1
47096: DEC
47097: ST_TO_ADDR
47098: LD_EXP 99
47102: PUSH
47103: FOR_TO
47104: IFFALSE 47247
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
47106: LD_ADDR_VAR 0 4
47110: PUSH
47111: LD_EXP 118
47115: PUSH
47116: LD_VAR 0 2
47120: ARRAY
47121: PUSH
47122: LD_EXP 121
47126: PUSH
47127: LD_VAR 0 2
47131: ARRAY
47132: UNION
47133: PPUSH
47134: LD_INT 33
47136: PUSH
47137: LD_INT 2
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PPUSH
47144: CALL_OW 72
47148: ST_TO_ADDR
// if tmp then
47149: LD_VAR 0 4
47153: IFFALSE 47245
// for j in tmp do
47155: LD_ADDR_VAR 0 3
47159: PUSH
47160: LD_VAR 0 4
47164: PUSH
47165: FOR_IN
47166: IFFALSE 47243
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
47168: LD_VAR 0 3
47172: PPUSH
47173: CALL_OW 312
47177: NOT
47178: PUSH
47179: LD_VAR 0 3
47183: PPUSH
47184: CALL_OW 256
47188: PUSH
47189: LD_INT 250
47191: GREATEREQUAL
47192: AND
47193: IFFALSE 47206
// Connect ( j ) else
47195: LD_VAR 0 3
47199: PPUSH
47200: CALL 71353 0 1
47204: GO 47241
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
47206: LD_VAR 0 3
47210: PPUSH
47211: CALL_OW 256
47215: PUSH
47216: LD_INT 250
47218: LESS
47219: PUSH
47220: LD_VAR 0 3
47224: PPUSH
47225: CALL_OW 312
47229: AND
47230: IFFALSE 47241
// ComUnlink ( j ) ;
47232: LD_VAR 0 3
47236: PPUSH
47237: CALL_OW 136
47241: GO 47165
47243: POP
47244: POP
// end ;
47245: GO 47103
47247: POP
47248: POP
// end ;
47249: LD_VAR 0 1
47253: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
47254: LD_INT 0
47256: PPUSH
47257: PPUSH
47258: PPUSH
47259: PPUSH
47260: PPUSH
// if not mc_bases then
47261: LD_EXP 99
47265: NOT
47266: IFFALSE 47270
// exit ;
47268: GO 47730
// for i = 1 to mc_bases do
47270: LD_ADDR_VAR 0 2
47274: PUSH
47275: DOUBLE
47276: LD_INT 1
47278: DEC
47279: ST_TO_ADDR
47280: LD_EXP 99
47284: PUSH
47285: FOR_TO
47286: IFFALSE 47728
// begin if not mc_produce [ i ] then
47288: LD_EXP 120
47292: PUSH
47293: LD_VAR 0 2
47297: ARRAY
47298: NOT
47299: IFFALSE 47303
// continue ;
47301: GO 47285
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47303: LD_ADDR_VAR 0 5
47307: PUSH
47308: LD_EXP 99
47312: PUSH
47313: LD_VAR 0 2
47317: ARRAY
47318: PPUSH
47319: LD_INT 30
47321: PUSH
47322: LD_INT 3
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: PPUSH
47329: CALL_OW 72
47333: ST_TO_ADDR
// if not fac then
47334: LD_VAR 0 5
47338: NOT
47339: IFFALSE 47343
// continue ;
47341: GO 47285
// for j in fac do
47343: LD_ADDR_VAR 0 3
47347: PUSH
47348: LD_VAR 0 5
47352: PUSH
47353: FOR_IN
47354: IFFALSE 47724
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
47356: LD_VAR 0 3
47360: PPUSH
47361: CALL_OW 461
47365: PUSH
47366: LD_INT 2
47368: NONEQUAL
47369: PUSH
47370: LD_VAR 0 3
47374: PPUSH
47375: LD_INT 15
47377: PPUSH
47378: CALL 71013 0 2
47382: PUSH
47383: LD_INT 4
47385: ARRAY
47386: OR
47387: PUSH
47388: LD_VAR 0 3
47392: PPUSH
47393: CALL_OW 313
47397: PUSH
47398: LD_INT 0
47400: EQUAL
47401: OR
47402: IFFALSE 47406
// continue ;
47404: GO 47353
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
47406: LD_VAR 0 3
47410: PPUSH
47411: LD_EXP 120
47415: PUSH
47416: LD_VAR 0 2
47420: ARRAY
47421: PUSH
47422: LD_INT 1
47424: ARRAY
47425: PUSH
47426: LD_INT 1
47428: ARRAY
47429: PPUSH
47430: LD_EXP 120
47434: PUSH
47435: LD_VAR 0 2
47439: ARRAY
47440: PUSH
47441: LD_INT 1
47443: ARRAY
47444: PUSH
47445: LD_INT 2
47447: ARRAY
47448: PPUSH
47449: LD_EXP 120
47453: PUSH
47454: LD_VAR 0 2
47458: ARRAY
47459: PUSH
47460: LD_INT 1
47462: ARRAY
47463: PUSH
47464: LD_INT 3
47466: ARRAY
47467: PPUSH
47468: LD_EXP 120
47472: PUSH
47473: LD_VAR 0 2
47477: ARRAY
47478: PUSH
47479: LD_INT 1
47481: ARRAY
47482: PUSH
47483: LD_INT 4
47485: ARRAY
47486: PPUSH
47487: CALL_OW 448
47491: PUSH
47492: LD_VAR 0 3
47496: PPUSH
47497: LD_EXP 120
47501: PUSH
47502: LD_VAR 0 2
47506: ARRAY
47507: PUSH
47508: LD_INT 1
47510: ARRAY
47511: PUSH
47512: LD_INT 1
47514: ARRAY
47515: PUSH
47516: LD_EXP 120
47520: PUSH
47521: LD_VAR 0 2
47525: ARRAY
47526: PUSH
47527: LD_INT 1
47529: ARRAY
47530: PUSH
47531: LD_INT 2
47533: ARRAY
47534: PUSH
47535: LD_EXP 120
47539: PUSH
47540: LD_VAR 0 2
47544: ARRAY
47545: PUSH
47546: LD_INT 1
47548: ARRAY
47549: PUSH
47550: LD_INT 3
47552: ARRAY
47553: PUSH
47554: LD_EXP 120
47558: PUSH
47559: LD_VAR 0 2
47563: ARRAY
47564: PUSH
47565: LD_INT 1
47567: ARRAY
47568: PUSH
47569: LD_INT 4
47571: ARRAY
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: PPUSH
47579: CALL 74684 0 2
47583: AND
47584: IFFALSE 47722
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
47586: LD_VAR 0 3
47590: PPUSH
47591: LD_EXP 120
47595: PUSH
47596: LD_VAR 0 2
47600: ARRAY
47601: PUSH
47602: LD_INT 1
47604: ARRAY
47605: PUSH
47606: LD_INT 1
47608: ARRAY
47609: PPUSH
47610: LD_EXP 120
47614: PUSH
47615: LD_VAR 0 2
47619: ARRAY
47620: PUSH
47621: LD_INT 1
47623: ARRAY
47624: PUSH
47625: LD_INT 2
47627: ARRAY
47628: PPUSH
47629: LD_EXP 120
47633: PUSH
47634: LD_VAR 0 2
47638: ARRAY
47639: PUSH
47640: LD_INT 1
47642: ARRAY
47643: PUSH
47644: LD_INT 3
47646: ARRAY
47647: PPUSH
47648: LD_EXP 120
47652: PUSH
47653: LD_VAR 0 2
47657: ARRAY
47658: PUSH
47659: LD_INT 1
47661: ARRAY
47662: PUSH
47663: LD_INT 4
47665: ARRAY
47666: PPUSH
47667: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
47671: LD_ADDR_VAR 0 4
47675: PUSH
47676: LD_EXP 120
47680: PUSH
47681: LD_VAR 0 2
47685: ARRAY
47686: PPUSH
47687: LD_INT 1
47689: PPUSH
47690: CALL_OW 3
47694: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47695: LD_ADDR_EXP 120
47699: PUSH
47700: LD_EXP 120
47704: PPUSH
47705: LD_VAR 0 2
47709: PPUSH
47710: LD_VAR 0 4
47714: PPUSH
47715: CALL_OW 1
47719: ST_TO_ADDR
// break ;
47720: GO 47724
// end ; end ;
47722: GO 47353
47724: POP
47725: POP
// end ;
47726: GO 47285
47728: POP
47729: POP
// end ;
47730: LD_VAR 0 1
47734: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
47735: LD_INT 0
47737: PPUSH
47738: PPUSH
47739: PPUSH
// if not mc_bases then
47740: LD_EXP 99
47744: NOT
47745: IFFALSE 47749
// exit ;
47747: GO 47838
// for i = 1 to mc_bases do
47749: LD_ADDR_VAR 0 2
47753: PUSH
47754: DOUBLE
47755: LD_INT 1
47757: DEC
47758: ST_TO_ADDR
47759: LD_EXP 99
47763: PUSH
47764: FOR_TO
47765: IFFALSE 47836
// begin if mc_attack [ i ] then
47767: LD_EXP 119
47771: PUSH
47772: LD_VAR 0 2
47776: ARRAY
47777: IFFALSE 47834
// begin tmp := mc_attack [ i ] [ 1 ] ;
47779: LD_ADDR_VAR 0 3
47783: PUSH
47784: LD_EXP 119
47788: PUSH
47789: LD_VAR 0 2
47793: ARRAY
47794: PUSH
47795: LD_INT 1
47797: ARRAY
47798: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
47799: LD_ADDR_EXP 119
47803: PUSH
47804: LD_EXP 119
47808: PPUSH
47809: LD_VAR 0 2
47813: PPUSH
47814: EMPTY
47815: PPUSH
47816: CALL_OW 1
47820: ST_TO_ADDR
// Attack ( tmp ) ;
47821: LD_VAR 0 3
47825: PPUSH
47826: CALL 96873 0 1
// exit ;
47830: POP
47831: POP
47832: GO 47838
// end ; end ;
47834: GO 47764
47836: POP
47837: POP
// end ;
47838: LD_VAR 0 1
47842: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
47843: LD_INT 0
47845: PPUSH
47846: PPUSH
47847: PPUSH
47848: PPUSH
47849: PPUSH
47850: PPUSH
47851: PPUSH
// if not mc_bases then
47852: LD_EXP 99
47856: NOT
47857: IFFALSE 47861
// exit ;
47859: GO 48465
// for i = 1 to mc_bases do
47861: LD_ADDR_VAR 0 2
47865: PUSH
47866: DOUBLE
47867: LD_INT 1
47869: DEC
47870: ST_TO_ADDR
47871: LD_EXP 99
47875: PUSH
47876: FOR_TO
47877: IFFALSE 48463
// begin if not mc_bases [ i ] then
47879: LD_EXP 99
47883: PUSH
47884: LD_VAR 0 2
47888: ARRAY
47889: NOT
47890: IFFALSE 47894
// continue ;
47892: GO 47876
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
47894: LD_ADDR_VAR 0 7
47898: PUSH
47899: LD_EXP 99
47903: PUSH
47904: LD_VAR 0 2
47908: ARRAY
47909: PUSH
47910: LD_INT 1
47912: ARRAY
47913: PPUSH
47914: CALL 65324 0 1
47918: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
47919: LD_ADDR_EXP 122
47923: PUSH
47924: LD_EXP 122
47928: PPUSH
47929: LD_VAR 0 2
47933: PPUSH
47934: LD_EXP 99
47938: PUSH
47939: LD_VAR 0 2
47943: ARRAY
47944: PUSH
47945: LD_INT 1
47947: ARRAY
47948: PPUSH
47949: CALL_OW 255
47953: PPUSH
47954: LD_EXP 124
47958: PUSH
47959: LD_VAR 0 2
47963: ARRAY
47964: PPUSH
47965: CALL 63284 0 2
47969: PPUSH
47970: CALL_OW 1
47974: ST_TO_ADDR
// if not mc_scan [ i ] then
47975: LD_EXP 122
47979: PUSH
47980: LD_VAR 0 2
47984: ARRAY
47985: NOT
47986: IFFALSE 48141
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47988: LD_ADDR_VAR 0 4
47992: PUSH
47993: LD_EXP 99
47997: PUSH
47998: LD_VAR 0 2
48002: ARRAY
48003: PPUSH
48004: LD_INT 2
48006: PUSH
48007: LD_INT 25
48009: PUSH
48010: LD_INT 5
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 25
48019: PUSH
48020: LD_INT 8
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 25
48029: PUSH
48030: LD_INT 9
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: PPUSH
48043: CALL_OW 72
48047: ST_TO_ADDR
// if not tmp then
48048: LD_VAR 0 4
48052: NOT
48053: IFFALSE 48057
// continue ;
48055: GO 47876
// for j in tmp do
48057: LD_ADDR_VAR 0 3
48061: PUSH
48062: LD_VAR 0 4
48066: PUSH
48067: FOR_IN
48068: IFFALSE 48139
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
48070: LD_VAR 0 3
48074: PPUSH
48075: CALL_OW 310
48079: PPUSH
48080: CALL_OW 266
48084: PUSH
48085: LD_INT 5
48087: EQUAL
48088: PUSH
48089: LD_VAR 0 3
48093: PPUSH
48094: CALL_OW 257
48098: PUSH
48099: LD_INT 1
48101: EQUAL
48102: AND
48103: PUSH
48104: LD_VAR 0 3
48108: PPUSH
48109: CALL_OW 459
48113: NOT
48114: AND
48115: PUSH
48116: LD_VAR 0 7
48120: AND
48121: IFFALSE 48137
// ComChangeProfession ( j , class ) ;
48123: LD_VAR 0 3
48127: PPUSH
48128: LD_VAR 0 7
48132: PPUSH
48133: CALL_OW 123
48137: GO 48067
48139: POP
48140: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
48141: LD_EXP 122
48145: PUSH
48146: LD_VAR 0 2
48150: ARRAY
48151: PUSH
48152: LD_EXP 121
48156: PUSH
48157: LD_VAR 0 2
48161: ARRAY
48162: NOT
48163: AND
48164: PUSH
48165: LD_EXP 99
48169: PUSH
48170: LD_VAR 0 2
48174: ARRAY
48175: PPUSH
48176: LD_INT 30
48178: PUSH
48179: LD_INT 32
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: CALL_OW 72
48190: NOT
48191: AND
48192: PUSH
48193: LD_EXP 99
48197: PUSH
48198: LD_VAR 0 2
48202: ARRAY
48203: PPUSH
48204: LD_INT 2
48206: PUSH
48207: LD_INT 30
48209: PUSH
48210: LD_INT 4
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: PUSH
48217: LD_INT 30
48219: PUSH
48220: LD_INT 5
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: LIST
48231: PPUSH
48232: CALL_OW 72
48236: NOT
48237: AND
48238: IFFALSE 48370
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
48240: LD_ADDR_VAR 0 4
48244: PUSH
48245: LD_EXP 99
48249: PUSH
48250: LD_VAR 0 2
48254: ARRAY
48255: PPUSH
48256: LD_INT 2
48258: PUSH
48259: LD_INT 25
48261: PUSH
48262: LD_INT 1
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PUSH
48269: LD_INT 25
48271: PUSH
48272: LD_INT 5
48274: PUSH
48275: EMPTY
48276: LIST
48277: LIST
48278: PUSH
48279: LD_INT 25
48281: PUSH
48282: LD_INT 8
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 25
48291: PUSH
48292: LD_INT 9
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: PPUSH
48306: CALL_OW 72
48310: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
48311: LD_ADDR_VAR 0 4
48315: PUSH
48316: LD_VAR 0 4
48320: PUSH
48321: LD_VAR 0 4
48325: PPUSH
48326: LD_INT 18
48328: PPUSH
48329: CALL 101617 0 2
48333: DIFF
48334: ST_TO_ADDR
// if tmp then
48335: LD_VAR 0 4
48339: IFFALSE 48370
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
48341: LD_VAR 0 2
48345: PPUSH
48346: LD_VAR 0 4
48350: PPUSH
48351: LD_EXP 124
48355: PUSH
48356: LD_VAR 0 2
48360: ARRAY
48361: PPUSH
48362: CALL 63319 0 3
// exit ;
48366: POP
48367: POP
48368: GO 48465
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
48370: LD_EXP 122
48374: PUSH
48375: LD_VAR 0 2
48379: ARRAY
48380: PUSH
48381: LD_EXP 121
48385: PUSH
48386: LD_VAR 0 2
48390: ARRAY
48391: AND
48392: IFFALSE 48461
// begin tmp := mc_defender [ i ] ;
48394: LD_ADDR_VAR 0 4
48398: PUSH
48399: LD_EXP 121
48403: PUSH
48404: LD_VAR 0 2
48408: ARRAY
48409: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
48410: LD_ADDR_EXP 121
48414: PUSH
48415: LD_EXP 121
48419: PPUSH
48420: LD_VAR 0 2
48424: PPUSH
48425: EMPTY
48426: PPUSH
48427: CALL_OW 1
48431: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
48432: LD_VAR 0 2
48436: PPUSH
48437: LD_VAR 0 4
48441: PPUSH
48442: LD_EXP 122
48446: PUSH
48447: LD_VAR 0 2
48451: ARRAY
48452: PPUSH
48453: CALL 63817 0 3
// exit ;
48457: POP
48458: POP
48459: GO 48465
// end ; end ;
48461: GO 47876
48463: POP
48464: POP
// end ;
48465: LD_VAR 0 1
48469: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
48470: LD_INT 0
48472: PPUSH
48473: PPUSH
48474: PPUSH
48475: PPUSH
48476: PPUSH
48477: PPUSH
48478: PPUSH
48479: PPUSH
48480: PPUSH
48481: PPUSH
48482: PPUSH
// if not mc_bases then
48483: LD_EXP 99
48487: NOT
48488: IFFALSE 48492
// exit ;
48490: GO 49579
// for i = 1 to mc_bases do
48492: LD_ADDR_VAR 0 2
48496: PUSH
48497: DOUBLE
48498: LD_INT 1
48500: DEC
48501: ST_TO_ADDR
48502: LD_EXP 99
48506: PUSH
48507: FOR_TO
48508: IFFALSE 49577
// begin tmp := mc_lab [ i ] ;
48510: LD_ADDR_VAR 0 6
48514: PUSH
48515: LD_EXP 132
48519: PUSH
48520: LD_VAR 0 2
48524: ARRAY
48525: ST_TO_ADDR
// if not tmp then
48526: LD_VAR 0 6
48530: NOT
48531: IFFALSE 48535
// continue ;
48533: GO 48507
// idle_lab := 0 ;
48535: LD_ADDR_VAR 0 11
48539: PUSH
48540: LD_INT 0
48542: ST_TO_ADDR
// for j in tmp do
48543: LD_ADDR_VAR 0 3
48547: PUSH
48548: LD_VAR 0 6
48552: PUSH
48553: FOR_IN
48554: IFFALSE 49573
// begin researching := false ;
48556: LD_ADDR_VAR 0 10
48560: PUSH
48561: LD_INT 0
48563: ST_TO_ADDR
// side := GetSide ( j ) ;
48564: LD_ADDR_VAR 0 4
48568: PUSH
48569: LD_VAR 0 3
48573: PPUSH
48574: CALL_OW 255
48578: ST_TO_ADDR
// if not mc_tech [ side ] then
48579: LD_EXP 126
48583: PUSH
48584: LD_VAR 0 4
48588: ARRAY
48589: NOT
48590: IFFALSE 48594
// continue ;
48592: GO 48553
// if BuildingStatus ( j ) = bs_idle then
48594: LD_VAR 0 3
48598: PPUSH
48599: CALL_OW 461
48603: PUSH
48604: LD_INT 2
48606: EQUAL
48607: IFFALSE 48795
// begin if idle_lab and UnitsInside ( j ) < 6 then
48609: LD_VAR 0 11
48613: PUSH
48614: LD_VAR 0 3
48618: PPUSH
48619: CALL_OW 313
48623: PUSH
48624: LD_INT 6
48626: LESS
48627: AND
48628: IFFALSE 48699
// begin tmp2 := UnitsInside ( idle_lab ) ;
48630: LD_ADDR_VAR 0 9
48634: PUSH
48635: LD_VAR 0 11
48639: PPUSH
48640: CALL_OW 313
48644: ST_TO_ADDR
// if tmp2 then
48645: LD_VAR 0 9
48649: IFFALSE 48691
// for x in tmp2 do
48651: LD_ADDR_VAR 0 7
48655: PUSH
48656: LD_VAR 0 9
48660: PUSH
48661: FOR_IN
48662: IFFALSE 48689
// begin ComExitBuilding ( x ) ;
48664: LD_VAR 0 7
48668: PPUSH
48669: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
48673: LD_VAR 0 7
48677: PPUSH
48678: LD_VAR 0 3
48682: PPUSH
48683: CALL_OW 180
// end ;
48687: GO 48661
48689: POP
48690: POP
// idle_lab := 0 ;
48691: LD_ADDR_VAR 0 11
48695: PUSH
48696: LD_INT 0
48698: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
48699: LD_ADDR_VAR 0 5
48703: PUSH
48704: LD_EXP 126
48708: PUSH
48709: LD_VAR 0 4
48713: ARRAY
48714: PUSH
48715: FOR_IN
48716: IFFALSE 48776
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
48718: LD_VAR 0 3
48722: PPUSH
48723: LD_VAR 0 5
48727: PPUSH
48728: CALL_OW 430
48732: PUSH
48733: LD_VAR 0 4
48737: PPUSH
48738: LD_VAR 0 5
48742: PPUSH
48743: CALL 62389 0 2
48747: AND
48748: IFFALSE 48774
// begin researching := true ;
48750: LD_ADDR_VAR 0 10
48754: PUSH
48755: LD_INT 1
48757: ST_TO_ADDR
// ComResearch ( j , t ) ;
48758: LD_VAR 0 3
48762: PPUSH
48763: LD_VAR 0 5
48767: PPUSH
48768: CALL_OW 124
// break ;
48772: GO 48776
// end ;
48774: GO 48715
48776: POP
48777: POP
// if not researching then
48778: LD_VAR 0 10
48782: NOT
48783: IFFALSE 48795
// idle_lab := j ;
48785: LD_ADDR_VAR 0 11
48789: PUSH
48790: LD_VAR 0 3
48794: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
48795: LD_VAR 0 3
48799: PPUSH
48800: CALL_OW 461
48804: PUSH
48805: LD_INT 10
48807: EQUAL
48808: IFFALSE 49396
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
48810: LD_EXP 128
48814: PUSH
48815: LD_VAR 0 2
48819: ARRAY
48820: NOT
48821: PUSH
48822: LD_EXP 129
48826: PUSH
48827: LD_VAR 0 2
48831: ARRAY
48832: NOT
48833: AND
48834: PUSH
48835: LD_EXP 126
48839: PUSH
48840: LD_VAR 0 4
48844: ARRAY
48845: PUSH
48846: LD_INT 1
48848: GREATER
48849: AND
48850: IFFALSE 48981
// begin ComCancel ( j ) ;
48852: LD_VAR 0 3
48856: PPUSH
48857: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
48861: LD_ADDR_EXP 126
48865: PUSH
48866: LD_EXP 126
48870: PPUSH
48871: LD_VAR 0 4
48875: PPUSH
48876: LD_EXP 126
48880: PUSH
48881: LD_VAR 0 4
48885: ARRAY
48886: PPUSH
48887: LD_EXP 126
48891: PUSH
48892: LD_VAR 0 4
48896: ARRAY
48897: PUSH
48898: LD_INT 1
48900: MINUS
48901: PPUSH
48902: LD_EXP 126
48906: PUSH
48907: LD_VAR 0 4
48911: ARRAY
48912: PPUSH
48913: LD_INT 0
48915: PPUSH
48916: CALL 67838 0 4
48920: PPUSH
48921: CALL_OW 1
48925: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
48926: LD_ADDR_EXP 126
48930: PUSH
48931: LD_EXP 126
48935: PPUSH
48936: LD_VAR 0 4
48940: PPUSH
48941: LD_EXP 126
48945: PUSH
48946: LD_VAR 0 4
48950: ARRAY
48951: PPUSH
48952: LD_EXP 126
48956: PUSH
48957: LD_VAR 0 4
48961: ARRAY
48962: PPUSH
48963: LD_INT 1
48965: PPUSH
48966: LD_INT 0
48968: PPUSH
48969: CALL 67838 0 4
48973: PPUSH
48974: CALL_OW 1
48978: ST_TO_ADDR
// continue ;
48979: GO 48553
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
48981: LD_EXP 128
48985: PUSH
48986: LD_VAR 0 2
48990: ARRAY
48991: PUSH
48992: LD_EXP 129
48996: PUSH
48997: LD_VAR 0 2
49001: ARRAY
49002: NOT
49003: AND
49004: IFFALSE 49131
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
49006: LD_ADDR_EXP 129
49010: PUSH
49011: LD_EXP 129
49015: PPUSH
49016: LD_VAR 0 2
49020: PUSH
49021: LD_EXP 129
49025: PUSH
49026: LD_VAR 0 2
49030: ARRAY
49031: PUSH
49032: LD_INT 1
49034: PLUS
49035: PUSH
49036: EMPTY
49037: LIST
49038: LIST
49039: PPUSH
49040: LD_EXP 128
49044: PUSH
49045: LD_VAR 0 2
49049: ARRAY
49050: PUSH
49051: LD_INT 1
49053: ARRAY
49054: PPUSH
49055: CALL 68420 0 3
49059: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
49060: LD_EXP 128
49064: PUSH
49065: LD_VAR 0 2
49069: ARRAY
49070: PUSH
49071: LD_INT 1
49073: ARRAY
49074: PPUSH
49075: LD_INT 112
49077: PPUSH
49078: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
49082: LD_ADDR_VAR 0 9
49086: PUSH
49087: LD_EXP 128
49091: PUSH
49092: LD_VAR 0 2
49096: ARRAY
49097: PPUSH
49098: LD_INT 1
49100: PPUSH
49101: CALL_OW 3
49105: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
49106: LD_ADDR_EXP 128
49110: PUSH
49111: LD_EXP 128
49115: PPUSH
49116: LD_VAR 0 2
49120: PPUSH
49121: LD_VAR 0 9
49125: PPUSH
49126: CALL_OW 1
49130: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
49131: LD_EXP 128
49135: PUSH
49136: LD_VAR 0 2
49140: ARRAY
49141: PUSH
49142: LD_EXP 129
49146: PUSH
49147: LD_VAR 0 2
49151: ARRAY
49152: AND
49153: PUSH
49154: LD_EXP 129
49158: PUSH
49159: LD_VAR 0 2
49163: ARRAY
49164: PUSH
49165: LD_INT 1
49167: ARRAY
49168: PPUSH
49169: CALL_OW 310
49173: NOT
49174: AND
49175: PUSH
49176: LD_VAR 0 3
49180: PPUSH
49181: CALL_OW 313
49185: PUSH
49186: LD_INT 6
49188: EQUAL
49189: AND
49190: IFFALSE 49246
// begin tmp2 := UnitsInside ( j ) ;
49192: LD_ADDR_VAR 0 9
49196: PUSH
49197: LD_VAR 0 3
49201: PPUSH
49202: CALL_OW 313
49206: ST_TO_ADDR
// if tmp2 = 6 then
49207: LD_VAR 0 9
49211: PUSH
49212: LD_INT 6
49214: EQUAL
49215: IFFALSE 49246
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
49217: LD_VAR 0 9
49221: PUSH
49222: LD_INT 1
49224: ARRAY
49225: PPUSH
49226: LD_INT 112
49228: PPUSH
49229: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
49233: LD_VAR 0 9
49237: PUSH
49238: LD_INT 1
49240: ARRAY
49241: PPUSH
49242: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
49246: LD_EXP 129
49250: PUSH
49251: LD_VAR 0 2
49255: ARRAY
49256: PUSH
49257: LD_EXP 129
49261: PUSH
49262: LD_VAR 0 2
49266: ARRAY
49267: PUSH
49268: LD_INT 1
49270: ARRAY
49271: PPUSH
49272: CALL_OW 314
49276: NOT
49277: AND
49278: PUSH
49279: LD_EXP 129
49283: PUSH
49284: LD_VAR 0 2
49288: ARRAY
49289: PUSH
49290: LD_INT 1
49292: ARRAY
49293: PPUSH
49294: CALL_OW 310
49298: NOT
49299: AND
49300: IFFALSE 49326
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
49302: LD_EXP 129
49306: PUSH
49307: LD_VAR 0 2
49311: ARRAY
49312: PUSH
49313: LD_INT 1
49315: ARRAY
49316: PPUSH
49317: LD_VAR 0 3
49321: PPUSH
49322: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
49326: LD_EXP 129
49330: PUSH
49331: LD_VAR 0 2
49335: ARRAY
49336: PUSH
49337: LD_INT 1
49339: ARRAY
49340: PPUSH
49341: CALL_OW 310
49345: PUSH
49346: LD_EXP 129
49350: PUSH
49351: LD_VAR 0 2
49355: ARRAY
49356: PUSH
49357: LD_INT 1
49359: ARRAY
49360: PPUSH
49361: CALL_OW 310
49365: PPUSH
49366: CALL_OW 461
49370: PUSH
49371: LD_INT 3
49373: NONEQUAL
49374: AND
49375: IFFALSE 49396
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
49377: LD_EXP 129
49381: PUSH
49382: LD_VAR 0 2
49386: ARRAY
49387: PUSH
49388: LD_INT 1
49390: ARRAY
49391: PPUSH
49392: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
49396: LD_VAR 0 3
49400: PPUSH
49401: CALL_OW 461
49405: PUSH
49406: LD_INT 6
49408: EQUAL
49409: PUSH
49410: LD_VAR 0 6
49414: PUSH
49415: LD_INT 1
49417: GREATER
49418: AND
49419: IFFALSE 49571
// begin sci := [ ] ;
49421: LD_ADDR_VAR 0 8
49425: PUSH
49426: EMPTY
49427: ST_TO_ADDR
// for x in ( tmp diff j ) do
49428: LD_ADDR_VAR 0 7
49432: PUSH
49433: LD_VAR 0 6
49437: PUSH
49438: LD_VAR 0 3
49442: DIFF
49443: PUSH
49444: FOR_IN
49445: IFFALSE 49497
// begin if sci = 6 then
49447: LD_VAR 0 8
49451: PUSH
49452: LD_INT 6
49454: EQUAL
49455: IFFALSE 49459
// break ;
49457: GO 49497
// if BuildingStatus ( x ) = bs_idle then
49459: LD_VAR 0 7
49463: PPUSH
49464: CALL_OW 461
49468: PUSH
49469: LD_INT 2
49471: EQUAL
49472: IFFALSE 49495
// sci := sci ^ UnitsInside ( x ) ;
49474: LD_ADDR_VAR 0 8
49478: PUSH
49479: LD_VAR 0 8
49483: PUSH
49484: LD_VAR 0 7
49488: PPUSH
49489: CALL_OW 313
49493: ADD
49494: ST_TO_ADDR
// end ;
49495: GO 49444
49497: POP
49498: POP
// if not sci then
49499: LD_VAR 0 8
49503: NOT
49504: IFFALSE 49508
// continue ;
49506: GO 48553
// for x in sci do
49508: LD_ADDR_VAR 0 7
49512: PUSH
49513: LD_VAR 0 8
49517: PUSH
49518: FOR_IN
49519: IFFALSE 49569
// if IsInUnit ( x ) and not HasTask ( x ) then
49521: LD_VAR 0 7
49525: PPUSH
49526: CALL_OW 310
49530: PUSH
49531: LD_VAR 0 7
49535: PPUSH
49536: CALL_OW 314
49540: NOT
49541: AND
49542: IFFALSE 49567
// begin ComExitBuilding ( x ) ;
49544: LD_VAR 0 7
49548: PPUSH
49549: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49553: LD_VAR 0 7
49557: PPUSH
49558: LD_VAR 0 3
49562: PPUSH
49563: CALL_OW 180
// end ;
49567: GO 49518
49569: POP
49570: POP
// end ; end ;
49571: GO 48553
49573: POP
49574: POP
// end ;
49575: GO 48507
49577: POP
49578: POP
// end ;
49579: LD_VAR 0 1
49583: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
49584: LD_INT 0
49586: PPUSH
49587: PPUSH
// if not mc_bases then
49588: LD_EXP 99
49592: NOT
49593: IFFALSE 49597
// exit ;
49595: GO 49678
// for i = 1 to mc_bases do
49597: LD_ADDR_VAR 0 2
49601: PUSH
49602: DOUBLE
49603: LD_INT 1
49605: DEC
49606: ST_TO_ADDR
49607: LD_EXP 99
49611: PUSH
49612: FOR_TO
49613: IFFALSE 49676
// if mc_mines [ i ] and mc_miners [ i ] then
49615: LD_EXP 112
49619: PUSH
49620: LD_VAR 0 2
49624: ARRAY
49625: PUSH
49626: LD_EXP 113
49630: PUSH
49631: LD_VAR 0 2
49635: ARRAY
49636: AND
49637: IFFALSE 49674
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
49639: LD_EXP 113
49643: PUSH
49644: LD_VAR 0 2
49648: ARRAY
49649: PUSH
49650: LD_INT 1
49652: ARRAY
49653: PPUSH
49654: CALL_OW 255
49658: PPUSH
49659: LD_EXP 112
49663: PUSH
49664: LD_VAR 0 2
49668: ARRAY
49669: PPUSH
49670: CALL 65477 0 2
49674: GO 49612
49676: POP
49677: POP
// end ;
49678: LD_VAR 0 1
49682: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
49683: LD_INT 0
49685: PPUSH
49686: PPUSH
49687: PPUSH
49688: PPUSH
49689: PPUSH
49690: PPUSH
49691: PPUSH
49692: PPUSH
// if not mc_bases or not mc_parking then
49693: LD_EXP 99
49697: NOT
49698: PUSH
49699: LD_EXP 123
49703: NOT
49704: OR
49705: IFFALSE 49709
// exit ;
49707: GO 50421
// for i = 1 to mc_bases do
49709: LD_ADDR_VAR 0 2
49713: PUSH
49714: DOUBLE
49715: LD_INT 1
49717: DEC
49718: ST_TO_ADDR
49719: LD_EXP 99
49723: PUSH
49724: FOR_TO
49725: IFFALSE 50419
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
49727: LD_EXP 99
49731: PUSH
49732: LD_VAR 0 2
49736: ARRAY
49737: NOT
49738: PUSH
49739: LD_EXP 123
49743: PUSH
49744: LD_VAR 0 2
49748: ARRAY
49749: NOT
49750: OR
49751: IFFALSE 49755
// continue ;
49753: GO 49724
// if mc_scan [ i ] then
49755: LD_EXP 122
49759: PUSH
49760: LD_VAR 0 2
49764: ARRAY
49765: IFFALSE 49791
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49767: LD_ADDR_EXP 111
49771: PUSH
49772: LD_EXP 111
49776: PPUSH
49777: LD_VAR 0 2
49781: PPUSH
49782: EMPTY
49783: PPUSH
49784: CALL_OW 1
49788: ST_TO_ADDR
// continue ;
49789: GO 49724
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
49791: LD_ADDR_VAR 0 5
49795: PUSH
49796: LD_EXP 99
49800: PUSH
49801: LD_VAR 0 2
49805: ARRAY
49806: PUSH
49807: LD_INT 1
49809: ARRAY
49810: PPUSH
49811: CALL_OW 255
49815: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49816: LD_ADDR_VAR 0 6
49820: PUSH
49821: LD_EXP 99
49825: PUSH
49826: LD_VAR 0 2
49830: ARRAY
49831: PPUSH
49832: LD_INT 30
49834: PUSH
49835: LD_INT 3
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PPUSH
49842: CALL_OW 72
49846: ST_TO_ADDR
// if not fac then
49847: LD_VAR 0 6
49851: NOT
49852: IFFALSE 49903
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49854: LD_ADDR_VAR 0 6
49858: PUSH
49859: LD_EXP 99
49863: PUSH
49864: LD_VAR 0 2
49868: ARRAY
49869: PPUSH
49870: LD_INT 2
49872: PUSH
49873: LD_INT 30
49875: PUSH
49876: LD_INT 0
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: LD_INT 30
49885: PUSH
49886: LD_INT 1
49888: PUSH
49889: EMPTY
49890: LIST
49891: LIST
49892: PUSH
49893: EMPTY
49894: LIST
49895: LIST
49896: LIST
49897: PPUSH
49898: CALL_OW 72
49902: ST_TO_ADDR
// if not fac then
49903: LD_VAR 0 6
49907: NOT
49908: IFFALSE 49912
// continue ;
49910: GO 49724
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
49912: LD_ADDR_VAR 0 7
49916: PUSH
49917: LD_EXP 123
49921: PUSH
49922: LD_VAR 0 2
49926: ARRAY
49927: PPUSH
49928: LD_INT 22
49930: PUSH
49931: LD_VAR 0 5
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: PUSH
49940: LD_INT 21
49942: PUSH
49943: LD_INT 2
49945: PUSH
49946: EMPTY
49947: LIST
49948: LIST
49949: PUSH
49950: LD_INT 3
49952: PUSH
49953: LD_INT 24
49955: PUSH
49956: LD_INT 1000
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: LIST
49971: PPUSH
49972: CALL_OW 70
49976: PUSH
49977: LD_INT 22
49979: PUSH
49980: LD_VAR 0 5
49984: PUSH
49985: EMPTY
49986: LIST
49987: LIST
49988: PUSH
49989: LD_INT 91
49991: PUSH
49992: LD_VAR 0 6
49996: PUSH
49997: LD_INT 1
49999: ARRAY
50000: PUSH
50001: LD_INT 25
50003: PUSH
50004: EMPTY
50005: LIST
50006: LIST
50007: LIST
50008: PUSH
50009: LD_INT 21
50011: PUSH
50012: LD_INT 2
50014: PUSH
50015: EMPTY
50016: LIST
50017: LIST
50018: PUSH
50019: LD_INT 3
50021: PUSH
50022: LD_INT 24
50024: PUSH
50025: LD_INT 1000
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: PUSH
50036: EMPTY
50037: LIST
50038: LIST
50039: LIST
50040: LIST
50041: PPUSH
50042: CALL_OW 69
50046: UNION
50047: ST_TO_ADDR
// if not vehs then
50048: LD_VAR 0 7
50052: NOT
50053: IFFALSE 50079
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
50055: LD_ADDR_EXP 111
50059: PUSH
50060: LD_EXP 111
50064: PPUSH
50065: LD_VAR 0 2
50069: PPUSH
50070: EMPTY
50071: PPUSH
50072: CALL_OW 1
50076: ST_TO_ADDR
// continue ;
50077: GO 49724
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50079: LD_ADDR_VAR 0 8
50083: PUSH
50084: LD_EXP 99
50088: PUSH
50089: LD_VAR 0 2
50093: ARRAY
50094: PPUSH
50095: LD_INT 30
50097: PUSH
50098: LD_INT 3
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PPUSH
50105: CALL_OW 72
50109: ST_TO_ADDR
// if tmp then
50110: LD_VAR 0 8
50114: IFFALSE 50217
// begin for j in tmp do
50116: LD_ADDR_VAR 0 3
50120: PUSH
50121: LD_VAR 0 8
50125: PUSH
50126: FOR_IN
50127: IFFALSE 50215
// for k in UnitsInside ( j ) do
50129: LD_ADDR_VAR 0 4
50133: PUSH
50134: LD_VAR 0 3
50138: PPUSH
50139: CALL_OW 313
50143: PUSH
50144: FOR_IN
50145: IFFALSE 50211
// if k then
50147: LD_VAR 0 4
50151: IFFALSE 50209
// if not k in mc_repair_vehicle [ i ] then
50153: LD_VAR 0 4
50157: PUSH
50158: LD_EXP 111
50162: PUSH
50163: LD_VAR 0 2
50167: ARRAY
50168: IN
50169: NOT
50170: IFFALSE 50209
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
50172: LD_ADDR_EXP 111
50176: PUSH
50177: LD_EXP 111
50181: PPUSH
50182: LD_VAR 0 2
50186: PPUSH
50187: LD_EXP 111
50191: PUSH
50192: LD_VAR 0 2
50196: ARRAY
50197: PUSH
50198: LD_VAR 0 4
50202: UNION
50203: PPUSH
50204: CALL_OW 1
50208: ST_TO_ADDR
50209: GO 50144
50211: POP
50212: POP
50213: GO 50126
50215: POP
50216: POP
// end ; if not mc_repair_vehicle [ i ] then
50217: LD_EXP 111
50221: PUSH
50222: LD_VAR 0 2
50226: ARRAY
50227: NOT
50228: IFFALSE 50232
// continue ;
50230: GO 49724
// for j in mc_repair_vehicle [ i ] do
50232: LD_ADDR_VAR 0 3
50236: PUSH
50237: LD_EXP 111
50241: PUSH
50242: LD_VAR 0 2
50246: ARRAY
50247: PUSH
50248: FOR_IN
50249: IFFALSE 50415
// begin if GetClass ( j ) <> 3 then
50251: LD_VAR 0 3
50255: PPUSH
50256: CALL_OW 257
50260: PUSH
50261: LD_INT 3
50263: NONEQUAL
50264: IFFALSE 50305
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
50266: LD_ADDR_EXP 111
50270: PUSH
50271: LD_EXP 111
50275: PPUSH
50276: LD_VAR 0 2
50280: PPUSH
50281: LD_EXP 111
50285: PUSH
50286: LD_VAR 0 2
50290: ARRAY
50291: PUSH
50292: LD_VAR 0 3
50296: DIFF
50297: PPUSH
50298: CALL_OW 1
50302: ST_TO_ADDR
// continue ;
50303: GO 50248
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
50305: LD_VAR 0 3
50309: PPUSH
50310: CALL_OW 311
50314: NOT
50315: PUSH
50316: LD_VAR 0 3
50320: PUSH
50321: LD_EXP 102
50325: PUSH
50326: LD_VAR 0 2
50330: ARRAY
50331: PUSH
50332: LD_INT 1
50334: ARRAY
50335: IN
50336: NOT
50337: AND
50338: PUSH
50339: LD_VAR 0 3
50343: PUSH
50344: LD_EXP 102
50348: PUSH
50349: LD_VAR 0 2
50353: ARRAY
50354: PUSH
50355: LD_INT 2
50357: ARRAY
50358: IN
50359: NOT
50360: AND
50361: IFFALSE 50413
// begin if IsInUnit ( j ) then
50363: LD_VAR 0 3
50367: PPUSH
50368: CALL_OW 310
50372: IFFALSE 50383
// ComExitBuilding ( j ) ;
50374: LD_VAR 0 3
50378: PPUSH
50379: CALL_OW 122
// if not HasTask ( j ) then
50383: LD_VAR 0 3
50387: PPUSH
50388: CALL_OW 314
50392: NOT
50393: IFFALSE 50413
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
50395: LD_VAR 0 3
50399: PPUSH
50400: LD_VAR 0 7
50404: PUSH
50405: LD_INT 1
50407: ARRAY
50408: PPUSH
50409: CALL_OW 189
// end ; end ;
50413: GO 50248
50415: POP
50416: POP
// end ;
50417: GO 49724
50419: POP
50420: POP
// end ;
50421: LD_VAR 0 1
50425: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
50426: LD_INT 0
50428: PPUSH
50429: PPUSH
50430: PPUSH
50431: PPUSH
50432: PPUSH
50433: PPUSH
50434: PPUSH
50435: PPUSH
50436: PPUSH
50437: PPUSH
50438: PPUSH
// if not mc_bases then
50439: LD_EXP 99
50443: NOT
50444: IFFALSE 50448
// exit ;
50446: GO 51250
// for i = 1 to mc_bases do
50448: LD_ADDR_VAR 0 2
50452: PUSH
50453: DOUBLE
50454: LD_INT 1
50456: DEC
50457: ST_TO_ADDR
50458: LD_EXP 99
50462: PUSH
50463: FOR_TO
50464: IFFALSE 51248
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
50466: LD_EXP 127
50470: PUSH
50471: LD_VAR 0 2
50475: ARRAY
50476: NOT
50477: PUSH
50478: LD_EXP 102
50482: PUSH
50483: LD_VAR 0 2
50487: ARRAY
50488: PUSH
50489: LD_INT 1
50491: ARRAY
50492: OR
50493: PUSH
50494: LD_EXP 102
50498: PUSH
50499: LD_VAR 0 2
50503: ARRAY
50504: PUSH
50505: LD_INT 2
50507: ARRAY
50508: OR
50509: PUSH
50510: LD_EXP 125
50514: PUSH
50515: LD_VAR 0 2
50519: ARRAY
50520: PPUSH
50521: LD_INT 1
50523: PPUSH
50524: CALL_OW 325
50528: NOT
50529: OR
50530: PUSH
50531: LD_EXP 122
50535: PUSH
50536: LD_VAR 0 2
50540: ARRAY
50541: OR
50542: IFFALSE 50546
// continue ;
50544: GO 50463
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
50546: LD_ADDR_VAR 0 8
50550: PUSH
50551: LD_EXP 99
50555: PUSH
50556: LD_VAR 0 2
50560: ARRAY
50561: PPUSH
50562: LD_INT 25
50564: PUSH
50565: LD_INT 4
50567: PUSH
50568: EMPTY
50569: LIST
50570: LIST
50571: PUSH
50572: LD_INT 50
50574: PUSH
50575: EMPTY
50576: LIST
50577: PUSH
50578: LD_INT 3
50580: PUSH
50581: LD_INT 60
50583: PUSH
50584: EMPTY
50585: LIST
50586: PUSH
50587: EMPTY
50588: LIST
50589: LIST
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: LIST
50595: PPUSH
50596: CALL_OW 72
50600: PUSH
50601: LD_EXP 103
50605: PUSH
50606: LD_VAR 0 2
50610: ARRAY
50611: DIFF
50612: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50613: LD_ADDR_VAR 0 9
50617: PUSH
50618: LD_EXP 99
50622: PUSH
50623: LD_VAR 0 2
50627: ARRAY
50628: PPUSH
50629: LD_INT 2
50631: PUSH
50632: LD_INT 30
50634: PUSH
50635: LD_INT 0
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PUSH
50642: LD_INT 30
50644: PUSH
50645: LD_INT 1
50647: PUSH
50648: EMPTY
50649: LIST
50650: LIST
50651: PUSH
50652: EMPTY
50653: LIST
50654: LIST
50655: LIST
50656: PPUSH
50657: CALL_OW 72
50661: ST_TO_ADDR
// if not tmp or not dep then
50662: LD_VAR 0 8
50666: NOT
50667: PUSH
50668: LD_VAR 0 9
50672: NOT
50673: OR
50674: IFFALSE 50678
// continue ;
50676: GO 50463
// side := GetSide ( tmp [ 1 ] ) ;
50678: LD_ADDR_VAR 0 11
50682: PUSH
50683: LD_VAR 0 8
50687: PUSH
50688: LD_INT 1
50690: ARRAY
50691: PPUSH
50692: CALL_OW 255
50696: ST_TO_ADDR
// dep := dep [ 1 ] ;
50697: LD_ADDR_VAR 0 9
50701: PUSH
50702: LD_VAR 0 9
50706: PUSH
50707: LD_INT 1
50709: ARRAY
50710: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
50711: LD_ADDR_VAR 0 7
50715: PUSH
50716: LD_EXP 127
50720: PUSH
50721: LD_VAR 0 2
50725: ARRAY
50726: PPUSH
50727: LD_INT 22
50729: PUSH
50730: LD_INT 0
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PUSH
50737: LD_INT 25
50739: PUSH
50740: LD_INT 12
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PPUSH
50751: CALL_OW 70
50755: PUSH
50756: LD_INT 22
50758: PUSH
50759: LD_INT 0
50761: PUSH
50762: EMPTY
50763: LIST
50764: LIST
50765: PUSH
50766: LD_INT 25
50768: PUSH
50769: LD_INT 12
50771: PUSH
50772: EMPTY
50773: LIST
50774: LIST
50775: PUSH
50776: LD_INT 91
50778: PUSH
50779: LD_VAR 0 9
50783: PUSH
50784: LD_INT 20
50786: PUSH
50787: EMPTY
50788: LIST
50789: LIST
50790: LIST
50791: PUSH
50792: EMPTY
50793: LIST
50794: LIST
50795: LIST
50796: PPUSH
50797: CALL_OW 69
50801: UNION
50802: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
50803: LD_ADDR_VAR 0 10
50807: PUSH
50808: LD_EXP 127
50812: PUSH
50813: LD_VAR 0 2
50817: ARRAY
50818: PPUSH
50819: LD_INT 81
50821: PUSH
50822: LD_VAR 0 11
50826: PUSH
50827: EMPTY
50828: LIST
50829: LIST
50830: PPUSH
50831: CALL_OW 70
50835: ST_TO_ADDR
// if not apes or danger_at_area then
50836: LD_VAR 0 7
50840: NOT
50841: PUSH
50842: LD_VAR 0 10
50846: OR
50847: IFFALSE 50897
// begin if mc_taming [ i ] then
50849: LD_EXP 130
50853: PUSH
50854: LD_VAR 0 2
50858: ARRAY
50859: IFFALSE 50895
// begin MC_Reset ( i , 121 ) ;
50861: LD_VAR 0 2
50865: PPUSH
50866: LD_INT 121
50868: PPUSH
50869: CALL 36532 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50873: LD_ADDR_EXP 130
50877: PUSH
50878: LD_EXP 130
50882: PPUSH
50883: LD_VAR 0 2
50887: PPUSH
50888: EMPTY
50889: PPUSH
50890: CALL_OW 1
50894: ST_TO_ADDR
// end ; continue ;
50895: GO 50463
// end ; for j in tmp do
50897: LD_ADDR_VAR 0 3
50901: PUSH
50902: LD_VAR 0 8
50906: PUSH
50907: FOR_IN
50908: IFFALSE 51244
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
50910: LD_VAR 0 3
50914: PUSH
50915: LD_EXP 130
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: IN
50926: NOT
50927: PUSH
50928: LD_EXP 130
50932: PUSH
50933: LD_VAR 0 2
50937: ARRAY
50938: PUSH
50939: LD_INT 3
50941: LESS
50942: AND
50943: IFFALSE 51001
// begin SetTag ( j , 121 ) ;
50945: LD_VAR 0 3
50949: PPUSH
50950: LD_INT 121
50952: PPUSH
50953: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
50957: LD_ADDR_EXP 130
50961: PUSH
50962: LD_EXP 130
50966: PPUSH
50967: LD_VAR 0 2
50971: PUSH
50972: LD_EXP 130
50976: PUSH
50977: LD_VAR 0 2
50981: ARRAY
50982: PUSH
50983: LD_INT 1
50985: PLUS
50986: PUSH
50987: EMPTY
50988: LIST
50989: LIST
50990: PPUSH
50991: LD_VAR 0 3
50995: PPUSH
50996: CALL 68420 0 3
51000: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
51001: LD_VAR 0 3
51005: PUSH
51006: LD_EXP 130
51010: PUSH
51011: LD_VAR 0 2
51015: ARRAY
51016: IN
51017: IFFALSE 51242
// begin if GetClass ( j ) <> 4 then
51019: LD_VAR 0 3
51023: PPUSH
51024: CALL_OW 257
51028: PUSH
51029: LD_INT 4
51031: NONEQUAL
51032: IFFALSE 51085
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
51034: LD_ADDR_EXP 130
51038: PUSH
51039: LD_EXP 130
51043: PPUSH
51044: LD_VAR 0 2
51048: PPUSH
51049: LD_EXP 130
51053: PUSH
51054: LD_VAR 0 2
51058: ARRAY
51059: PUSH
51060: LD_VAR 0 3
51064: DIFF
51065: PPUSH
51066: CALL_OW 1
51070: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51071: LD_VAR 0 3
51075: PPUSH
51076: LD_INT 0
51078: PPUSH
51079: CALL_OW 109
// continue ;
51083: GO 50907
// end ; if IsInUnit ( j ) then
51085: LD_VAR 0 3
51089: PPUSH
51090: CALL_OW 310
51094: IFFALSE 51105
// ComExitBuilding ( j ) ;
51096: LD_VAR 0 3
51100: PPUSH
51101: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
51105: LD_ADDR_VAR 0 6
51109: PUSH
51110: LD_VAR 0 7
51114: PPUSH
51115: LD_VAR 0 3
51119: PPUSH
51120: CALL_OW 74
51124: ST_TO_ADDR
// if not ape then
51125: LD_VAR 0 6
51129: NOT
51130: IFFALSE 51134
// break ;
51132: GO 51244
// x := GetX ( ape ) ;
51134: LD_ADDR_VAR 0 4
51138: PUSH
51139: LD_VAR 0 6
51143: PPUSH
51144: CALL_OW 250
51148: ST_TO_ADDR
// y := GetY ( ape ) ;
51149: LD_ADDR_VAR 0 5
51153: PUSH
51154: LD_VAR 0 6
51158: PPUSH
51159: CALL_OW 251
51163: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
51164: LD_VAR 0 4
51168: PPUSH
51169: LD_VAR 0 5
51173: PPUSH
51174: CALL_OW 488
51178: NOT
51179: PUSH
51180: LD_VAR 0 11
51184: PPUSH
51185: LD_VAR 0 4
51189: PPUSH
51190: LD_VAR 0 5
51194: PPUSH
51195: LD_INT 20
51197: PPUSH
51198: CALL 69316 0 4
51202: PUSH
51203: LD_INT 4
51205: ARRAY
51206: OR
51207: IFFALSE 51211
// break ;
51209: GO 51244
// if not HasTask ( j ) then
51211: LD_VAR 0 3
51215: PPUSH
51216: CALL_OW 314
51220: NOT
51221: IFFALSE 51242
// ComTameXY ( j , x , y ) ;
51223: LD_VAR 0 3
51227: PPUSH
51228: LD_VAR 0 4
51232: PPUSH
51233: LD_VAR 0 5
51237: PPUSH
51238: CALL_OW 131
// end ; end ;
51242: GO 50907
51244: POP
51245: POP
// end ;
51246: GO 50463
51248: POP
51249: POP
// end ;
51250: LD_VAR 0 1
51254: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
51255: LD_INT 0
51257: PPUSH
51258: PPUSH
51259: PPUSH
51260: PPUSH
51261: PPUSH
51262: PPUSH
51263: PPUSH
51264: PPUSH
// if not mc_bases then
51265: LD_EXP 99
51269: NOT
51270: IFFALSE 51274
// exit ;
51272: GO 51900
// for i = 1 to mc_bases do
51274: LD_ADDR_VAR 0 2
51278: PUSH
51279: DOUBLE
51280: LD_INT 1
51282: DEC
51283: ST_TO_ADDR
51284: LD_EXP 99
51288: PUSH
51289: FOR_TO
51290: IFFALSE 51898
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
51292: LD_EXP 128
51296: PUSH
51297: LD_VAR 0 2
51301: ARRAY
51302: NOT
51303: PUSH
51304: LD_EXP 128
51308: PUSH
51309: LD_VAR 0 2
51313: ARRAY
51314: PPUSH
51315: LD_INT 25
51317: PUSH
51318: LD_INT 12
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: NOT
51330: OR
51331: IFFALSE 51335
// continue ;
51333: GO 51289
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
51335: LD_ADDR_VAR 0 5
51339: PUSH
51340: LD_EXP 128
51344: PUSH
51345: LD_VAR 0 2
51349: ARRAY
51350: PUSH
51351: LD_INT 1
51353: ARRAY
51354: PPUSH
51355: CALL_OW 255
51359: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
51360: LD_VAR 0 5
51364: PPUSH
51365: LD_INT 2
51367: PPUSH
51368: CALL_OW 325
51372: IFFALSE 51625
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
51374: LD_ADDR_VAR 0 4
51378: PUSH
51379: LD_EXP 128
51383: PUSH
51384: LD_VAR 0 2
51388: ARRAY
51389: PPUSH
51390: LD_INT 25
51392: PUSH
51393: LD_INT 16
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PPUSH
51400: CALL_OW 72
51404: ST_TO_ADDR
// if tmp < 6 then
51405: LD_VAR 0 4
51409: PUSH
51410: LD_INT 6
51412: LESS
51413: IFFALSE 51625
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51415: LD_ADDR_VAR 0 6
51419: PUSH
51420: LD_EXP 99
51424: PUSH
51425: LD_VAR 0 2
51429: ARRAY
51430: PPUSH
51431: LD_INT 2
51433: PUSH
51434: LD_INT 30
51436: PUSH
51437: LD_INT 0
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: PUSH
51444: LD_INT 30
51446: PUSH
51447: LD_INT 1
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: PUSH
51454: EMPTY
51455: LIST
51456: LIST
51457: LIST
51458: PPUSH
51459: CALL_OW 72
51463: ST_TO_ADDR
// if depot then
51464: LD_VAR 0 6
51468: IFFALSE 51625
// begin selected := 0 ;
51470: LD_ADDR_VAR 0 7
51474: PUSH
51475: LD_INT 0
51477: ST_TO_ADDR
// for j in depot do
51478: LD_ADDR_VAR 0 3
51482: PUSH
51483: LD_VAR 0 6
51487: PUSH
51488: FOR_IN
51489: IFFALSE 51520
// begin if UnitsInside ( j ) < 6 then
51491: LD_VAR 0 3
51495: PPUSH
51496: CALL_OW 313
51500: PUSH
51501: LD_INT 6
51503: LESS
51504: IFFALSE 51518
// begin selected := j ;
51506: LD_ADDR_VAR 0 7
51510: PUSH
51511: LD_VAR 0 3
51515: ST_TO_ADDR
// break ;
51516: GO 51520
// end ; end ;
51518: GO 51488
51520: POP
51521: POP
// if selected then
51522: LD_VAR 0 7
51526: IFFALSE 51625
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
51528: LD_ADDR_VAR 0 3
51532: PUSH
51533: LD_EXP 128
51537: PUSH
51538: LD_VAR 0 2
51542: ARRAY
51543: PPUSH
51544: LD_INT 25
51546: PUSH
51547: LD_INT 12
51549: PUSH
51550: EMPTY
51551: LIST
51552: LIST
51553: PPUSH
51554: CALL_OW 72
51558: PUSH
51559: FOR_IN
51560: IFFALSE 51623
// if not HasTask ( j ) then
51562: LD_VAR 0 3
51566: PPUSH
51567: CALL_OW 314
51571: NOT
51572: IFFALSE 51621
// begin if not IsInUnit ( j ) then
51574: LD_VAR 0 3
51578: PPUSH
51579: CALL_OW 310
51583: NOT
51584: IFFALSE 51600
// ComEnterUnit ( j , selected ) ;
51586: LD_VAR 0 3
51590: PPUSH
51591: LD_VAR 0 7
51595: PPUSH
51596: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
51600: LD_VAR 0 3
51604: PPUSH
51605: LD_INT 16
51607: PPUSH
51608: CALL_OW 183
// AddComExitBuilding ( j ) ;
51612: LD_VAR 0 3
51616: PPUSH
51617: CALL_OW 182
// end ;
51621: GO 51559
51623: POP
51624: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
51625: LD_VAR 0 5
51629: PPUSH
51630: LD_INT 11
51632: PPUSH
51633: CALL_OW 325
51637: IFFALSE 51896
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
51639: LD_ADDR_VAR 0 4
51643: PUSH
51644: LD_EXP 128
51648: PUSH
51649: LD_VAR 0 2
51653: ARRAY
51654: PPUSH
51655: LD_INT 25
51657: PUSH
51658: LD_INT 16
51660: PUSH
51661: EMPTY
51662: LIST
51663: LIST
51664: PPUSH
51665: CALL_OW 72
51669: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
51670: LD_VAR 0 4
51674: PUSH
51675: LD_INT 6
51677: GREATEREQUAL
51678: PUSH
51679: LD_VAR 0 5
51683: PPUSH
51684: LD_INT 2
51686: PPUSH
51687: CALL_OW 325
51691: NOT
51692: OR
51693: IFFALSE 51896
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51695: LD_ADDR_VAR 0 8
51699: PUSH
51700: LD_EXP 99
51704: PUSH
51705: LD_VAR 0 2
51709: ARRAY
51710: PPUSH
51711: LD_INT 2
51713: PUSH
51714: LD_INT 30
51716: PUSH
51717: LD_INT 4
51719: PUSH
51720: EMPTY
51721: LIST
51722: LIST
51723: PUSH
51724: LD_INT 30
51726: PUSH
51727: LD_INT 5
51729: PUSH
51730: EMPTY
51731: LIST
51732: LIST
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: LIST
51738: PPUSH
51739: CALL_OW 72
51743: ST_TO_ADDR
// if barracks then
51744: LD_VAR 0 8
51748: IFFALSE 51896
// begin selected := 0 ;
51750: LD_ADDR_VAR 0 7
51754: PUSH
51755: LD_INT 0
51757: ST_TO_ADDR
// for j in barracks do
51758: LD_ADDR_VAR 0 3
51762: PUSH
51763: LD_VAR 0 8
51767: PUSH
51768: FOR_IN
51769: IFFALSE 51800
// begin if UnitsInside ( j ) < 6 then
51771: LD_VAR 0 3
51775: PPUSH
51776: CALL_OW 313
51780: PUSH
51781: LD_INT 6
51783: LESS
51784: IFFALSE 51798
// begin selected := j ;
51786: LD_ADDR_VAR 0 7
51790: PUSH
51791: LD_VAR 0 3
51795: ST_TO_ADDR
// break ;
51796: GO 51800
// end ; end ;
51798: GO 51768
51800: POP
51801: POP
// if selected then
51802: LD_VAR 0 7
51806: IFFALSE 51896
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
51808: LD_ADDR_VAR 0 3
51812: PUSH
51813: LD_EXP 128
51817: PUSH
51818: LD_VAR 0 2
51822: ARRAY
51823: PPUSH
51824: LD_INT 25
51826: PUSH
51827: LD_INT 12
51829: PUSH
51830: EMPTY
51831: LIST
51832: LIST
51833: PPUSH
51834: CALL_OW 72
51838: PUSH
51839: FOR_IN
51840: IFFALSE 51894
// if not IsInUnit ( j ) and not HasTask ( j ) then
51842: LD_VAR 0 3
51846: PPUSH
51847: CALL_OW 310
51851: NOT
51852: PUSH
51853: LD_VAR 0 3
51857: PPUSH
51858: CALL_OW 314
51862: NOT
51863: AND
51864: IFFALSE 51892
// begin ComEnterUnit ( j , selected ) ;
51866: LD_VAR 0 3
51870: PPUSH
51871: LD_VAR 0 7
51875: PPUSH
51876: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
51880: LD_VAR 0 3
51884: PPUSH
51885: LD_INT 15
51887: PPUSH
51888: CALL_OW 183
// end ;
51892: GO 51839
51894: POP
51895: POP
// end ; end ; end ; end ; end ;
51896: GO 51289
51898: POP
51899: POP
// end ;
51900: LD_VAR 0 1
51904: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
51905: LD_INT 0
51907: PPUSH
51908: PPUSH
51909: PPUSH
51910: PPUSH
// if not mc_bases then
51911: LD_EXP 99
51915: NOT
51916: IFFALSE 51920
// exit ;
51918: GO 52098
// for i = 1 to mc_bases do
51920: LD_ADDR_VAR 0 2
51924: PUSH
51925: DOUBLE
51926: LD_INT 1
51928: DEC
51929: ST_TO_ADDR
51930: LD_EXP 99
51934: PUSH
51935: FOR_TO
51936: IFFALSE 52096
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
51938: LD_ADDR_VAR 0 4
51942: PUSH
51943: LD_EXP 99
51947: PUSH
51948: LD_VAR 0 2
51952: ARRAY
51953: PPUSH
51954: LD_INT 25
51956: PUSH
51957: LD_INT 9
51959: PUSH
51960: EMPTY
51961: LIST
51962: LIST
51963: PPUSH
51964: CALL_OW 72
51968: ST_TO_ADDR
// if not tmp then
51969: LD_VAR 0 4
51973: NOT
51974: IFFALSE 51978
// continue ;
51976: GO 51935
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
51978: LD_EXP 125
51982: PUSH
51983: LD_VAR 0 2
51987: ARRAY
51988: PPUSH
51989: LD_INT 29
51991: PPUSH
51992: CALL_OW 325
51996: NOT
51997: PUSH
51998: LD_EXP 125
52002: PUSH
52003: LD_VAR 0 2
52007: ARRAY
52008: PPUSH
52009: LD_INT 28
52011: PPUSH
52012: CALL_OW 325
52016: NOT
52017: AND
52018: IFFALSE 52022
// continue ;
52020: GO 51935
// for j in tmp do
52022: LD_ADDR_VAR 0 3
52026: PUSH
52027: LD_VAR 0 4
52031: PUSH
52032: FOR_IN
52033: IFFALSE 52092
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52035: LD_VAR 0 3
52039: PUSH
52040: LD_EXP 102
52044: PUSH
52045: LD_VAR 0 2
52049: ARRAY
52050: PUSH
52051: LD_INT 1
52053: ARRAY
52054: IN
52055: NOT
52056: PUSH
52057: LD_VAR 0 3
52061: PUSH
52062: LD_EXP 102
52066: PUSH
52067: LD_VAR 0 2
52071: ARRAY
52072: PUSH
52073: LD_INT 2
52075: ARRAY
52076: IN
52077: NOT
52078: AND
52079: IFFALSE 52090
// ComSpaceTimeShoot ( j ) ;
52081: LD_VAR 0 3
52085: PPUSH
52086: CALL 62480 0 1
52090: GO 52032
52092: POP
52093: POP
// end ;
52094: GO 51935
52096: POP
52097: POP
// end ;
52098: LD_VAR 0 1
52102: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
52103: LD_INT 0
52105: PPUSH
52106: PPUSH
52107: PPUSH
52108: PPUSH
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not mc_bases then
52114: LD_EXP 99
52118: NOT
52119: IFFALSE 52123
// exit ;
52121: GO 52745
// for i = 1 to mc_bases do
52123: LD_ADDR_VAR 0 2
52127: PUSH
52128: DOUBLE
52129: LD_INT 1
52131: DEC
52132: ST_TO_ADDR
52133: LD_EXP 99
52137: PUSH
52138: FOR_TO
52139: IFFALSE 52743
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
52141: LD_EXP 134
52145: PUSH
52146: LD_VAR 0 2
52150: ARRAY
52151: NOT
52152: PUSH
52153: LD_INT 38
52155: PPUSH
52156: LD_EXP 125
52160: PUSH
52161: LD_VAR 0 2
52165: ARRAY
52166: PPUSH
52167: CALL_OW 321
52171: PUSH
52172: LD_INT 2
52174: NONEQUAL
52175: OR
52176: IFFALSE 52180
// continue ;
52178: GO 52138
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
52180: LD_ADDR_VAR 0 8
52184: PUSH
52185: LD_EXP 99
52189: PUSH
52190: LD_VAR 0 2
52194: ARRAY
52195: PPUSH
52196: LD_INT 30
52198: PUSH
52199: LD_INT 34
52201: PUSH
52202: EMPTY
52203: LIST
52204: LIST
52205: PPUSH
52206: CALL_OW 72
52210: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
52211: LD_ADDR_VAR 0 9
52215: PUSH
52216: LD_EXP 99
52220: PUSH
52221: LD_VAR 0 2
52225: ARRAY
52226: PPUSH
52227: LD_INT 25
52229: PUSH
52230: LD_INT 4
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: PPUSH
52237: CALL_OW 72
52241: PPUSH
52242: LD_INT 0
52244: PPUSH
52245: CALL 101617 0 2
52249: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
52250: LD_VAR 0 9
52254: NOT
52255: PUSH
52256: LD_VAR 0 8
52260: NOT
52261: OR
52262: PUSH
52263: LD_EXP 99
52267: PUSH
52268: LD_VAR 0 2
52272: ARRAY
52273: PPUSH
52274: LD_INT 124
52276: PPUSH
52277: CALL 101617 0 2
52281: OR
52282: IFFALSE 52286
// continue ;
52284: GO 52138
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
52286: LD_EXP 135
52290: PUSH
52291: LD_VAR 0 2
52295: ARRAY
52296: PUSH
52297: LD_EXP 134
52301: PUSH
52302: LD_VAR 0 2
52306: ARRAY
52307: LESS
52308: PUSH
52309: LD_EXP 135
52313: PUSH
52314: LD_VAR 0 2
52318: ARRAY
52319: PUSH
52320: LD_VAR 0 8
52324: LESS
52325: AND
52326: IFFALSE 52741
// begin tmp := sci [ 1 ] ;
52328: LD_ADDR_VAR 0 7
52332: PUSH
52333: LD_VAR 0 9
52337: PUSH
52338: LD_INT 1
52340: ARRAY
52341: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
52342: LD_VAR 0 7
52346: PPUSH
52347: LD_INT 124
52349: PPUSH
52350: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
52354: LD_ADDR_VAR 0 3
52358: PUSH
52359: DOUBLE
52360: LD_EXP 134
52364: PUSH
52365: LD_VAR 0 2
52369: ARRAY
52370: INC
52371: ST_TO_ADDR
52372: LD_EXP 134
52376: PUSH
52377: LD_VAR 0 2
52381: ARRAY
52382: PUSH
52383: FOR_DOWNTO
52384: IFFALSE 52727
// begin if IsInUnit ( tmp ) then
52386: LD_VAR 0 7
52390: PPUSH
52391: CALL_OW 310
52395: IFFALSE 52406
// ComExitBuilding ( tmp ) ;
52397: LD_VAR 0 7
52401: PPUSH
52402: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
52406: LD_INT 35
52408: PPUSH
52409: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
52413: LD_VAR 0 7
52417: PPUSH
52418: CALL_OW 310
52422: NOT
52423: PUSH
52424: LD_VAR 0 7
52428: PPUSH
52429: CALL_OW 314
52433: NOT
52434: AND
52435: IFFALSE 52406
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
52437: LD_ADDR_VAR 0 6
52441: PUSH
52442: LD_VAR 0 7
52446: PPUSH
52447: CALL_OW 250
52451: PUSH
52452: LD_VAR 0 7
52456: PPUSH
52457: CALL_OW 251
52461: PUSH
52462: EMPTY
52463: LIST
52464: LIST
52465: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
52466: LD_INT 35
52468: PPUSH
52469: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
52473: LD_ADDR_VAR 0 4
52477: PUSH
52478: LD_EXP 134
52482: PUSH
52483: LD_VAR 0 2
52487: ARRAY
52488: PUSH
52489: LD_VAR 0 3
52493: ARRAY
52494: PUSH
52495: LD_INT 1
52497: ARRAY
52498: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
52499: LD_ADDR_VAR 0 5
52503: PUSH
52504: LD_EXP 134
52508: PUSH
52509: LD_VAR 0 2
52513: ARRAY
52514: PUSH
52515: LD_VAR 0 3
52519: ARRAY
52520: PUSH
52521: LD_INT 2
52523: ARRAY
52524: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
52525: LD_VAR 0 7
52529: PPUSH
52530: LD_INT 10
52532: PPUSH
52533: CALL 71013 0 2
52537: PUSH
52538: LD_INT 4
52540: ARRAY
52541: IFFALSE 52579
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
52543: LD_VAR 0 7
52547: PPUSH
52548: LD_VAR 0 6
52552: PUSH
52553: LD_INT 1
52555: ARRAY
52556: PPUSH
52557: LD_VAR 0 6
52561: PUSH
52562: LD_INT 2
52564: ARRAY
52565: PPUSH
52566: CALL_OW 111
// wait ( 0 0$10 ) ;
52570: LD_INT 350
52572: PPUSH
52573: CALL_OW 67
// end else
52577: GO 52605
// begin ComMoveXY ( tmp , x , y ) ;
52579: LD_VAR 0 7
52583: PPUSH
52584: LD_VAR 0 4
52588: PPUSH
52589: LD_VAR 0 5
52593: PPUSH
52594: CALL_OW 111
// wait ( 0 0$3 ) ;
52598: LD_INT 105
52600: PPUSH
52601: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
52605: LD_VAR 0 7
52609: PPUSH
52610: LD_VAR 0 4
52614: PPUSH
52615: LD_VAR 0 5
52619: PPUSH
52620: CALL_OW 307
52624: IFFALSE 52466
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
52626: LD_VAR 0 7
52630: PPUSH
52631: LD_VAR 0 4
52635: PPUSH
52636: LD_VAR 0 5
52640: PPUSH
52641: LD_VAR 0 8
52645: PUSH
52646: LD_VAR 0 3
52650: ARRAY
52651: PPUSH
52652: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
52656: LD_INT 35
52658: PPUSH
52659: CALL_OW 67
// until not HasTask ( tmp ) ;
52663: LD_VAR 0 7
52667: PPUSH
52668: CALL_OW 314
52672: NOT
52673: IFFALSE 52656
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
52675: LD_ADDR_EXP 135
52679: PUSH
52680: LD_EXP 135
52684: PPUSH
52685: LD_VAR 0 2
52689: PUSH
52690: LD_EXP 135
52694: PUSH
52695: LD_VAR 0 2
52699: ARRAY
52700: PUSH
52701: LD_INT 1
52703: PLUS
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PPUSH
52709: LD_VAR 0 8
52713: PUSH
52714: LD_VAR 0 3
52718: ARRAY
52719: PPUSH
52720: CALL 68420 0 3
52724: ST_TO_ADDR
// end ;
52725: GO 52383
52727: POP
52728: POP
// MC_Reset ( i , 124 ) ;
52729: LD_VAR 0 2
52733: PPUSH
52734: LD_INT 124
52736: PPUSH
52737: CALL 36532 0 2
// end ; end ;
52741: GO 52138
52743: POP
52744: POP
// end ;
52745: LD_VAR 0 1
52749: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
52750: LD_INT 0
52752: PPUSH
52753: PPUSH
52754: PPUSH
// if not mc_bases then
52755: LD_EXP 99
52759: NOT
52760: IFFALSE 52764
// exit ;
52762: GO 53370
// for i = 1 to mc_bases do
52764: LD_ADDR_VAR 0 2
52768: PUSH
52769: DOUBLE
52770: LD_INT 1
52772: DEC
52773: ST_TO_ADDR
52774: LD_EXP 99
52778: PUSH
52779: FOR_TO
52780: IFFALSE 53368
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
52782: LD_ADDR_VAR 0 3
52786: PUSH
52787: LD_EXP 99
52791: PUSH
52792: LD_VAR 0 2
52796: ARRAY
52797: PPUSH
52798: LD_INT 25
52800: PUSH
52801: LD_INT 4
52803: PUSH
52804: EMPTY
52805: LIST
52806: LIST
52807: PPUSH
52808: CALL_OW 72
52812: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52813: LD_VAR 0 3
52817: NOT
52818: PUSH
52819: LD_EXP 136
52823: PUSH
52824: LD_VAR 0 2
52828: ARRAY
52829: NOT
52830: OR
52831: PUSH
52832: LD_EXP 99
52836: PUSH
52837: LD_VAR 0 2
52841: ARRAY
52842: PPUSH
52843: LD_INT 2
52845: PUSH
52846: LD_INT 30
52848: PUSH
52849: LD_INT 0
52851: PUSH
52852: EMPTY
52853: LIST
52854: LIST
52855: PUSH
52856: LD_INT 30
52858: PUSH
52859: LD_INT 1
52861: PUSH
52862: EMPTY
52863: LIST
52864: LIST
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: LIST
52870: PPUSH
52871: CALL_OW 72
52875: NOT
52876: OR
52877: IFFALSE 52927
// begin if mc_deposits_finder [ i ] then
52879: LD_EXP 137
52883: PUSH
52884: LD_VAR 0 2
52888: ARRAY
52889: IFFALSE 52925
// begin MC_Reset ( i , 125 ) ;
52891: LD_VAR 0 2
52895: PPUSH
52896: LD_INT 125
52898: PPUSH
52899: CALL 36532 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52903: LD_ADDR_EXP 137
52907: PUSH
52908: LD_EXP 137
52912: PPUSH
52913: LD_VAR 0 2
52917: PPUSH
52918: EMPTY
52919: PPUSH
52920: CALL_OW 1
52924: ST_TO_ADDR
// end ; continue ;
52925: GO 52779
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
52927: LD_EXP 136
52931: PUSH
52932: LD_VAR 0 2
52936: ARRAY
52937: PUSH
52938: LD_INT 1
52940: ARRAY
52941: PUSH
52942: LD_INT 3
52944: ARRAY
52945: PUSH
52946: LD_INT 1
52948: EQUAL
52949: PUSH
52950: LD_INT 20
52952: PPUSH
52953: LD_EXP 125
52957: PUSH
52958: LD_VAR 0 2
52962: ARRAY
52963: PPUSH
52964: CALL_OW 321
52968: PUSH
52969: LD_INT 2
52971: NONEQUAL
52972: AND
52973: IFFALSE 53023
// begin if mc_deposits_finder [ i ] then
52975: LD_EXP 137
52979: PUSH
52980: LD_VAR 0 2
52984: ARRAY
52985: IFFALSE 53021
// begin MC_Reset ( i , 125 ) ;
52987: LD_VAR 0 2
52991: PPUSH
52992: LD_INT 125
52994: PPUSH
52995: CALL 36532 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52999: LD_ADDR_EXP 137
53003: PUSH
53004: LD_EXP 137
53008: PPUSH
53009: LD_VAR 0 2
53013: PPUSH
53014: EMPTY
53015: PPUSH
53016: CALL_OW 1
53020: ST_TO_ADDR
// end ; continue ;
53021: GO 52779
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
53023: LD_EXP 136
53027: PUSH
53028: LD_VAR 0 2
53032: ARRAY
53033: PUSH
53034: LD_INT 1
53036: ARRAY
53037: PUSH
53038: LD_INT 1
53040: ARRAY
53041: PPUSH
53042: LD_EXP 136
53046: PUSH
53047: LD_VAR 0 2
53051: ARRAY
53052: PUSH
53053: LD_INT 1
53055: ARRAY
53056: PUSH
53057: LD_INT 2
53059: ARRAY
53060: PPUSH
53061: LD_EXP 125
53065: PUSH
53066: LD_VAR 0 2
53070: ARRAY
53071: PPUSH
53072: CALL_OW 440
53076: IFFALSE 53119
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
53078: LD_ADDR_EXP 136
53082: PUSH
53083: LD_EXP 136
53087: PPUSH
53088: LD_VAR 0 2
53092: PPUSH
53093: LD_EXP 136
53097: PUSH
53098: LD_VAR 0 2
53102: ARRAY
53103: PPUSH
53104: LD_INT 1
53106: PPUSH
53107: CALL_OW 3
53111: PPUSH
53112: CALL_OW 1
53116: ST_TO_ADDR
53117: GO 53366
// begin if not mc_deposits_finder [ i ] then
53119: LD_EXP 137
53123: PUSH
53124: LD_VAR 0 2
53128: ARRAY
53129: NOT
53130: IFFALSE 53182
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
53132: LD_ADDR_EXP 137
53136: PUSH
53137: LD_EXP 137
53141: PPUSH
53142: LD_VAR 0 2
53146: PPUSH
53147: LD_VAR 0 3
53151: PUSH
53152: LD_INT 1
53154: ARRAY
53155: PUSH
53156: EMPTY
53157: LIST
53158: PPUSH
53159: CALL_OW 1
53163: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
53164: LD_VAR 0 3
53168: PUSH
53169: LD_INT 1
53171: ARRAY
53172: PPUSH
53173: LD_INT 125
53175: PPUSH
53176: CALL_OW 109
// end else
53180: GO 53366
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
53182: LD_EXP 137
53186: PUSH
53187: LD_VAR 0 2
53191: ARRAY
53192: PUSH
53193: LD_INT 1
53195: ARRAY
53196: PPUSH
53197: CALL_OW 310
53201: IFFALSE 53224
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
53203: LD_EXP 137
53207: PUSH
53208: LD_VAR 0 2
53212: ARRAY
53213: PUSH
53214: LD_INT 1
53216: ARRAY
53217: PPUSH
53218: CALL_OW 122
53222: GO 53366
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
53224: LD_EXP 137
53228: PUSH
53229: LD_VAR 0 2
53233: ARRAY
53234: PUSH
53235: LD_INT 1
53237: ARRAY
53238: PPUSH
53239: CALL_OW 314
53243: NOT
53244: PUSH
53245: LD_EXP 137
53249: PUSH
53250: LD_VAR 0 2
53254: ARRAY
53255: PUSH
53256: LD_INT 1
53258: ARRAY
53259: PPUSH
53260: LD_EXP 136
53264: PUSH
53265: LD_VAR 0 2
53269: ARRAY
53270: PUSH
53271: LD_INT 1
53273: ARRAY
53274: PUSH
53275: LD_INT 1
53277: ARRAY
53278: PPUSH
53279: LD_EXP 136
53283: PUSH
53284: LD_VAR 0 2
53288: ARRAY
53289: PUSH
53290: LD_INT 1
53292: ARRAY
53293: PUSH
53294: LD_INT 2
53296: ARRAY
53297: PPUSH
53298: CALL_OW 297
53302: PUSH
53303: LD_INT 6
53305: GREATER
53306: AND
53307: IFFALSE 53366
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
53309: LD_EXP 137
53313: PUSH
53314: LD_VAR 0 2
53318: ARRAY
53319: PUSH
53320: LD_INT 1
53322: ARRAY
53323: PPUSH
53324: LD_EXP 136
53328: PUSH
53329: LD_VAR 0 2
53333: ARRAY
53334: PUSH
53335: LD_INT 1
53337: ARRAY
53338: PUSH
53339: LD_INT 1
53341: ARRAY
53342: PPUSH
53343: LD_EXP 136
53347: PUSH
53348: LD_VAR 0 2
53352: ARRAY
53353: PUSH
53354: LD_INT 1
53356: ARRAY
53357: PUSH
53358: LD_INT 2
53360: ARRAY
53361: PPUSH
53362: CALL_OW 111
// end ; end ; end ;
53366: GO 52779
53368: POP
53369: POP
// end ;
53370: LD_VAR 0 1
53374: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
53375: LD_INT 0
53377: PPUSH
53378: PPUSH
53379: PPUSH
53380: PPUSH
53381: PPUSH
53382: PPUSH
53383: PPUSH
53384: PPUSH
53385: PPUSH
53386: PPUSH
53387: PPUSH
// if not mc_bases then
53388: LD_EXP 99
53392: NOT
53393: IFFALSE 53397
// exit ;
53395: GO 54121
// for i = 1 to mc_bases do
53397: LD_ADDR_VAR 0 2
53401: PUSH
53402: DOUBLE
53403: LD_INT 1
53405: DEC
53406: ST_TO_ADDR
53407: LD_EXP 99
53411: PUSH
53412: FOR_TO
53413: IFFALSE 54119
// begin if not mc_bases [ i ] then
53415: LD_EXP 99
53419: PUSH
53420: LD_VAR 0 2
53424: ARRAY
53425: NOT
53426: IFFALSE 53430
// continue ;
53428: GO 53412
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
53430: LD_ADDR_VAR 0 7
53434: PUSH
53435: LD_EXP 99
53439: PUSH
53440: LD_VAR 0 2
53444: ARRAY
53445: PUSH
53446: LD_INT 1
53448: ARRAY
53449: PPUSH
53450: CALL_OW 248
53454: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
53455: LD_VAR 0 7
53459: PUSH
53460: LD_INT 3
53462: EQUAL
53463: PUSH
53464: LD_EXP 118
53468: PUSH
53469: LD_VAR 0 2
53473: ARRAY
53474: PUSH
53475: LD_EXP 121
53479: PUSH
53480: LD_VAR 0 2
53484: ARRAY
53485: UNION
53486: PPUSH
53487: LD_INT 33
53489: PUSH
53490: LD_INT 2
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: PPUSH
53497: CALL_OW 72
53501: NOT
53502: OR
53503: IFFALSE 53507
// continue ;
53505: GO 53412
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
53507: LD_ADDR_VAR 0 9
53511: PUSH
53512: LD_EXP 99
53516: PUSH
53517: LD_VAR 0 2
53521: ARRAY
53522: PPUSH
53523: LD_INT 30
53525: PUSH
53526: LD_INT 36
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: PPUSH
53533: CALL_OW 72
53537: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
53538: LD_ADDR_VAR 0 10
53542: PUSH
53543: LD_EXP 118
53547: PUSH
53548: LD_VAR 0 2
53552: ARRAY
53553: PPUSH
53554: LD_INT 34
53556: PUSH
53557: LD_INT 31
53559: PUSH
53560: EMPTY
53561: LIST
53562: LIST
53563: PPUSH
53564: CALL_OW 72
53568: ST_TO_ADDR
// if not cts and not mcts then
53569: LD_VAR 0 9
53573: NOT
53574: PUSH
53575: LD_VAR 0 10
53579: NOT
53580: AND
53581: IFFALSE 53585
// continue ;
53583: GO 53412
// x := cts ;
53585: LD_ADDR_VAR 0 11
53589: PUSH
53590: LD_VAR 0 9
53594: ST_TO_ADDR
// if not x then
53595: LD_VAR 0 11
53599: NOT
53600: IFFALSE 53612
// x := mcts ;
53602: LD_ADDR_VAR 0 11
53606: PUSH
53607: LD_VAR 0 10
53611: ST_TO_ADDR
// if mc_remote_driver [ i ] then
53612: LD_EXP 139
53616: PUSH
53617: LD_VAR 0 2
53621: ARRAY
53622: IFFALSE 53891
// for j in mc_remote_driver [ i ] do
53624: LD_ADDR_VAR 0 3
53628: PUSH
53629: LD_EXP 139
53633: PUSH
53634: LD_VAR 0 2
53638: ARRAY
53639: PUSH
53640: FOR_IN
53641: IFFALSE 53889
// begin if GetClass ( j ) <> 3 then
53643: LD_VAR 0 3
53647: PPUSH
53648: CALL_OW 257
53652: PUSH
53653: LD_INT 3
53655: NONEQUAL
53656: IFFALSE 53709
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
53658: LD_ADDR_EXP 139
53662: PUSH
53663: LD_EXP 139
53667: PPUSH
53668: LD_VAR 0 2
53672: PPUSH
53673: LD_EXP 139
53677: PUSH
53678: LD_VAR 0 2
53682: ARRAY
53683: PUSH
53684: LD_VAR 0 3
53688: DIFF
53689: PPUSH
53690: CALL_OW 1
53694: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53695: LD_VAR 0 3
53699: PPUSH
53700: LD_INT 0
53702: PPUSH
53703: CALL_OW 109
// continue ;
53707: GO 53640
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
53709: LD_VAR 0 3
53713: PPUSH
53714: CALL_OW 310
53718: NOT
53719: PUSH
53720: LD_VAR 0 3
53724: PPUSH
53725: CALL_OW 310
53729: PPUSH
53730: CALL_OW 266
53734: PUSH
53735: LD_INT 36
53737: NONEQUAL
53738: PUSH
53739: LD_VAR 0 3
53743: PPUSH
53744: CALL 101705 0 1
53748: NOT
53749: AND
53750: OR
53751: IFFALSE 53887
// begin if IsInUnit ( j ) then
53753: LD_VAR 0 3
53757: PPUSH
53758: CALL_OW 310
53762: IFFALSE 53773
// ComExitBuilding ( j ) ;
53764: LD_VAR 0 3
53768: PPUSH
53769: CALL_OW 122
// ct := 0 ;
53773: LD_ADDR_VAR 0 8
53777: PUSH
53778: LD_INT 0
53780: ST_TO_ADDR
// for k in x do
53781: LD_ADDR_VAR 0 4
53785: PUSH
53786: LD_VAR 0 11
53790: PUSH
53791: FOR_IN
53792: IFFALSE 53865
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
53794: LD_VAR 0 4
53798: PPUSH
53799: CALL_OW 264
53803: PUSH
53804: LD_INT 31
53806: EQUAL
53807: PUSH
53808: LD_VAR 0 4
53812: PPUSH
53813: CALL_OW 311
53817: NOT
53818: AND
53819: PUSH
53820: LD_VAR 0 4
53824: PPUSH
53825: CALL_OW 266
53829: PUSH
53830: LD_INT 36
53832: EQUAL
53833: PUSH
53834: LD_VAR 0 4
53838: PPUSH
53839: CALL_OW 313
53843: PUSH
53844: LD_INT 3
53846: LESS
53847: AND
53848: OR
53849: IFFALSE 53863
// begin ct := k ;
53851: LD_ADDR_VAR 0 8
53855: PUSH
53856: LD_VAR 0 4
53860: ST_TO_ADDR
// break ;
53861: GO 53865
// end ;
53863: GO 53791
53865: POP
53866: POP
// if ct then
53867: LD_VAR 0 8
53871: IFFALSE 53887
// ComEnterUnit ( j , ct ) ;
53873: LD_VAR 0 3
53877: PPUSH
53878: LD_VAR 0 8
53882: PPUSH
53883: CALL_OW 120
// end ; end ;
53887: GO 53640
53889: POP
53890: POP
// places := 0 ;
53891: LD_ADDR_VAR 0 5
53895: PUSH
53896: LD_INT 0
53898: ST_TO_ADDR
// for j = 1 to x do
53899: LD_ADDR_VAR 0 3
53903: PUSH
53904: DOUBLE
53905: LD_INT 1
53907: DEC
53908: ST_TO_ADDR
53909: LD_VAR 0 11
53913: PUSH
53914: FOR_TO
53915: IFFALSE 53970
// if GetWeapon ( x [ j ] ) = ar_control_tower then
53917: LD_VAR 0 11
53921: PUSH
53922: LD_VAR 0 3
53926: ARRAY
53927: PPUSH
53928: CALL_OW 264
53932: PUSH
53933: LD_INT 31
53935: EQUAL
53936: IFFALSE 53954
// places := places + 1 else
53938: LD_ADDR_VAR 0 5
53942: PUSH
53943: LD_VAR 0 5
53947: PUSH
53948: LD_INT 1
53950: PLUS
53951: ST_TO_ADDR
53952: GO 53968
// places := places + 3 ;
53954: LD_ADDR_VAR 0 5
53958: PUSH
53959: LD_VAR 0 5
53963: PUSH
53964: LD_INT 3
53966: PLUS
53967: ST_TO_ADDR
53968: GO 53914
53970: POP
53971: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
53972: LD_ADDR_VAR 0 6
53976: PUSH
53977: LD_EXP 99
53981: PUSH
53982: LD_VAR 0 2
53986: ARRAY
53987: PPUSH
53988: LD_INT 25
53990: PUSH
53991: LD_INT 3
53993: PUSH
53994: EMPTY
53995: LIST
53996: LIST
53997: PPUSH
53998: CALL_OW 72
54002: PUSH
54003: LD_EXP 139
54007: PUSH
54008: LD_VAR 0 2
54012: ARRAY
54013: DIFF
54014: PPUSH
54015: LD_INT 3
54017: PPUSH
54018: CALL 102605 0 2
54022: ST_TO_ADDR
// if not tmp then
54023: LD_VAR 0 6
54027: NOT
54028: IFFALSE 54032
// continue ;
54030: GO 53412
// places := places - mc_remote_driver [ i ] ;
54032: LD_ADDR_VAR 0 5
54036: PUSH
54037: LD_VAR 0 5
54041: PUSH
54042: LD_EXP 139
54046: PUSH
54047: LD_VAR 0 2
54051: ARRAY
54052: MINUS
54053: ST_TO_ADDR
// if places then
54054: LD_VAR 0 5
54058: IFFALSE 54117
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
54060: LD_ADDR_EXP 139
54064: PUSH
54065: LD_EXP 139
54069: PPUSH
54070: LD_VAR 0 2
54074: PPUSH
54075: LD_EXP 139
54079: PUSH
54080: LD_VAR 0 2
54084: ARRAY
54085: PUSH
54086: LD_VAR 0 6
54090: PUSH
54091: LD_INT 1
54093: ARRAY
54094: UNION
54095: PPUSH
54096: CALL_OW 1
54100: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
54101: LD_VAR 0 6
54105: PUSH
54106: LD_INT 1
54108: ARRAY
54109: PPUSH
54110: LD_INT 126
54112: PPUSH
54113: CALL_OW 109
// end ; end ;
54117: GO 53412
54119: POP
54120: POP
// end ;
54121: LD_VAR 0 1
54125: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
54126: LD_INT 0
54128: PPUSH
54129: PPUSH
54130: PPUSH
54131: PPUSH
54132: PPUSH
54133: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
54134: LD_VAR 0 1
54138: NOT
54139: PUSH
54140: LD_VAR 0 2
54144: NOT
54145: OR
54146: PUSH
54147: LD_VAR 0 3
54151: NOT
54152: OR
54153: PUSH
54154: LD_VAR 0 4
54158: PUSH
54159: LD_INT 1
54161: PUSH
54162: LD_INT 2
54164: PUSH
54165: LD_INT 3
54167: PUSH
54168: LD_INT 4
54170: PUSH
54171: LD_INT 5
54173: PUSH
54174: LD_INT 8
54176: PUSH
54177: LD_INT 9
54179: PUSH
54180: LD_INT 15
54182: PUSH
54183: LD_INT 16
54185: PUSH
54186: EMPTY
54187: LIST
54188: LIST
54189: LIST
54190: LIST
54191: LIST
54192: LIST
54193: LIST
54194: LIST
54195: LIST
54196: IN
54197: NOT
54198: OR
54199: IFFALSE 54203
// exit ;
54201: GO 55103
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
54203: LD_ADDR_VAR 0 2
54207: PUSH
54208: LD_VAR 0 2
54212: PPUSH
54213: LD_INT 21
54215: PUSH
54216: LD_INT 3
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: PUSH
54223: LD_INT 24
54225: PUSH
54226: LD_INT 250
54228: PUSH
54229: EMPTY
54230: LIST
54231: LIST
54232: PUSH
54233: EMPTY
54234: LIST
54235: LIST
54236: PPUSH
54237: CALL_OW 72
54241: ST_TO_ADDR
// case class of 1 , 15 :
54242: LD_VAR 0 4
54246: PUSH
54247: LD_INT 1
54249: DOUBLE
54250: EQUAL
54251: IFTRUE 54261
54253: LD_INT 15
54255: DOUBLE
54256: EQUAL
54257: IFTRUE 54261
54259: GO 54346
54261: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
54262: LD_ADDR_VAR 0 8
54266: PUSH
54267: LD_VAR 0 2
54271: PPUSH
54272: LD_INT 2
54274: PUSH
54275: LD_INT 30
54277: PUSH
54278: LD_INT 32
54280: PUSH
54281: EMPTY
54282: LIST
54283: LIST
54284: PUSH
54285: LD_INT 30
54287: PUSH
54288: LD_INT 31
54290: PUSH
54291: EMPTY
54292: LIST
54293: LIST
54294: PUSH
54295: EMPTY
54296: LIST
54297: LIST
54298: LIST
54299: PPUSH
54300: CALL_OW 72
54304: PUSH
54305: LD_VAR 0 2
54309: PPUSH
54310: LD_INT 2
54312: PUSH
54313: LD_INT 30
54315: PUSH
54316: LD_INT 4
54318: PUSH
54319: EMPTY
54320: LIST
54321: LIST
54322: PUSH
54323: LD_INT 30
54325: PUSH
54326: LD_INT 5
54328: PUSH
54329: EMPTY
54330: LIST
54331: LIST
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: LIST
54337: PPUSH
54338: CALL_OW 72
54342: ADD
54343: ST_TO_ADDR
54344: GO 54592
54346: LD_INT 2
54348: DOUBLE
54349: EQUAL
54350: IFTRUE 54360
54352: LD_INT 16
54354: DOUBLE
54355: EQUAL
54356: IFTRUE 54360
54358: GO 54406
54360: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
54361: LD_ADDR_VAR 0 8
54365: PUSH
54366: LD_VAR 0 2
54370: PPUSH
54371: LD_INT 2
54373: PUSH
54374: LD_INT 30
54376: PUSH
54377: LD_INT 0
54379: PUSH
54380: EMPTY
54381: LIST
54382: LIST
54383: PUSH
54384: LD_INT 30
54386: PUSH
54387: LD_INT 1
54389: PUSH
54390: EMPTY
54391: LIST
54392: LIST
54393: PUSH
54394: EMPTY
54395: LIST
54396: LIST
54397: LIST
54398: PPUSH
54399: CALL_OW 72
54403: ST_TO_ADDR
54404: GO 54592
54406: LD_INT 3
54408: DOUBLE
54409: EQUAL
54410: IFTRUE 54414
54412: GO 54460
54414: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
54415: LD_ADDR_VAR 0 8
54419: PUSH
54420: LD_VAR 0 2
54424: PPUSH
54425: LD_INT 2
54427: PUSH
54428: LD_INT 30
54430: PUSH
54431: LD_INT 2
54433: PUSH
54434: EMPTY
54435: LIST
54436: LIST
54437: PUSH
54438: LD_INT 30
54440: PUSH
54441: LD_INT 3
54443: PUSH
54444: EMPTY
54445: LIST
54446: LIST
54447: PUSH
54448: EMPTY
54449: LIST
54450: LIST
54451: LIST
54452: PPUSH
54453: CALL_OW 72
54457: ST_TO_ADDR
54458: GO 54592
54460: LD_INT 4
54462: DOUBLE
54463: EQUAL
54464: IFTRUE 54468
54466: GO 54525
54468: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
54469: LD_ADDR_VAR 0 8
54473: PUSH
54474: LD_VAR 0 2
54478: PPUSH
54479: LD_INT 2
54481: PUSH
54482: LD_INT 30
54484: PUSH
54485: LD_INT 6
54487: PUSH
54488: EMPTY
54489: LIST
54490: LIST
54491: PUSH
54492: LD_INT 30
54494: PUSH
54495: LD_INT 7
54497: PUSH
54498: EMPTY
54499: LIST
54500: LIST
54501: PUSH
54502: LD_INT 30
54504: PUSH
54505: LD_INT 8
54507: PUSH
54508: EMPTY
54509: LIST
54510: LIST
54511: PUSH
54512: EMPTY
54513: LIST
54514: LIST
54515: LIST
54516: LIST
54517: PPUSH
54518: CALL_OW 72
54522: ST_TO_ADDR
54523: GO 54592
54525: LD_INT 5
54527: DOUBLE
54528: EQUAL
54529: IFTRUE 54545
54531: LD_INT 8
54533: DOUBLE
54534: EQUAL
54535: IFTRUE 54545
54537: LD_INT 9
54539: DOUBLE
54540: EQUAL
54541: IFTRUE 54545
54543: GO 54591
54545: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
54546: LD_ADDR_VAR 0 8
54550: PUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: LD_INT 2
54558: PUSH
54559: LD_INT 30
54561: PUSH
54562: LD_INT 4
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: PUSH
54569: LD_INT 30
54571: PUSH
54572: LD_INT 5
54574: PUSH
54575: EMPTY
54576: LIST
54577: LIST
54578: PUSH
54579: EMPTY
54580: LIST
54581: LIST
54582: LIST
54583: PPUSH
54584: CALL_OW 72
54588: ST_TO_ADDR
54589: GO 54592
54591: POP
// if not tmp then
54592: LD_VAR 0 8
54596: NOT
54597: IFFALSE 54601
// exit ;
54599: GO 55103
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
54601: LD_VAR 0 4
54605: PUSH
54606: LD_INT 1
54608: PUSH
54609: LD_INT 15
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: IN
54616: PUSH
54617: LD_EXP 108
54621: PUSH
54622: LD_VAR 0 1
54626: ARRAY
54627: AND
54628: IFFALSE 54784
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
54630: LD_ADDR_VAR 0 9
54634: PUSH
54635: LD_EXP 108
54639: PUSH
54640: LD_VAR 0 1
54644: ARRAY
54645: PUSH
54646: LD_INT 1
54648: ARRAY
54649: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
54650: LD_VAR 0 9
54654: PUSH
54655: LD_EXP 109
54659: PUSH
54660: LD_VAR 0 1
54664: ARRAY
54665: IN
54666: NOT
54667: IFFALSE 54782
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
54669: LD_ADDR_EXP 109
54673: PUSH
54674: LD_EXP 109
54678: PPUSH
54679: LD_VAR 0 1
54683: PUSH
54684: LD_EXP 109
54688: PUSH
54689: LD_VAR 0 1
54693: ARRAY
54694: PUSH
54695: LD_INT 1
54697: PLUS
54698: PUSH
54699: EMPTY
54700: LIST
54701: LIST
54702: PPUSH
54703: LD_VAR 0 9
54707: PPUSH
54708: CALL 68420 0 3
54712: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
54713: LD_ADDR_EXP 108
54717: PUSH
54718: LD_EXP 108
54722: PPUSH
54723: LD_VAR 0 1
54727: PPUSH
54728: LD_EXP 108
54732: PUSH
54733: LD_VAR 0 1
54737: ARRAY
54738: PUSH
54739: LD_VAR 0 9
54743: DIFF
54744: PPUSH
54745: CALL_OW 1
54749: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
54750: LD_VAR 0 3
54754: PPUSH
54755: LD_EXP 109
54759: PUSH
54760: LD_VAR 0 1
54764: ARRAY
54765: PUSH
54766: LD_EXP 109
54770: PUSH
54771: LD_VAR 0 1
54775: ARRAY
54776: ARRAY
54777: PPUSH
54778: CALL_OW 120
// end ; exit ;
54782: GO 55103
// end ; if tmp > 1 then
54784: LD_VAR 0 8
54788: PUSH
54789: LD_INT 1
54791: GREATER
54792: IFFALSE 54896
// for i = 2 to tmp do
54794: LD_ADDR_VAR 0 6
54798: PUSH
54799: DOUBLE
54800: LD_INT 2
54802: DEC
54803: ST_TO_ADDR
54804: LD_VAR 0 8
54808: PUSH
54809: FOR_TO
54810: IFFALSE 54894
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
54812: LD_VAR 0 8
54816: PUSH
54817: LD_VAR 0 6
54821: ARRAY
54822: PPUSH
54823: CALL_OW 461
54827: PUSH
54828: LD_INT 6
54830: EQUAL
54831: IFFALSE 54892
// begin x := tmp [ i ] ;
54833: LD_ADDR_VAR 0 9
54837: PUSH
54838: LD_VAR 0 8
54842: PUSH
54843: LD_VAR 0 6
54847: ARRAY
54848: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
54849: LD_ADDR_VAR 0 8
54853: PUSH
54854: LD_VAR 0 8
54858: PPUSH
54859: LD_VAR 0 6
54863: PPUSH
54864: CALL_OW 3
54868: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
54869: LD_ADDR_VAR 0 8
54873: PUSH
54874: LD_VAR 0 8
54878: PPUSH
54879: LD_INT 1
54881: PPUSH
54882: LD_VAR 0 9
54886: PPUSH
54887: CALL_OW 2
54891: ST_TO_ADDR
// end ;
54892: GO 54809
54894: POP
54895: POP
// for i in tmp do
54896: LD_ADDR_VAR 0 6
54900: PUSH
54901: LD_VAR 0 8
54905: PUSH
54906: FOR_IN
54907: IFFALSE 54976
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
54909: LD_VAR 0 6
54913: PPUSH
54914: CALL_OW 313
54918: PUSH
54919: LD_INT 6
54921: LESS
54922: PUSH
54923: LD_VAR 0 6
54927: PPUSH
54928: CALL_OW 266
54932: PUSH
54933: LD_INT 31
54935: PUSH
54936: LD_INT 32
54938: PUSH
54939: EMPTY
54940: LIST
54941: LIST
54942: IN
54943: NOT
54944: AND
54945: PUSH
54946: LD_VAR 0 6
54950: PPUSH
54951: CALL_OW 313
54955: PUSH
54956: LD_INT 0
54958: EQUAL
54959: OR
54960: IFFALSE 54974
// begin j := i ;
54962: LD_ADDR_VAR 0 7
54966: PUSH
54967: LD_VAR 0 6
54971: ST_TO_ADDR
// break ;
54972: GO 54976
// end ; end ;
54974: GO 54906
54976: POP
54977: POP
// if j then
54978: LD_VAR 0 7
54982: IFFALSE 55000
// ComEnterUnit ( unit , j ) else
54984: LD_VAR 0 3
54988: PPUSH
54989: LD_VAR 0 7
54993: PPUSH
54994: CALL_OW 120
54998: GO 55103
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55000: LD_ADDR_VAR 0 10
55004: PUSH
55005: LD_VAR 0 2
55009: PPUSH
55010: LD_INT 2
55012: PUSH
55013: LD_INT 30
55015: PUSH
55016: LD_INT 0
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: PUSH
55023: LD_INT 30
55025: PUSH
55026: LD_INT 1
55028: PUSH
55029: EMPTY
55030: LIST
55031: LIST
55032: PUSH
55033: EMPTY
55034: LIST
55035: LIST
55036: LIST
55037: PPUSH
55038: CALL_OW 72
55042: ST_TO_ADDR
// if depot then
55043: LD_VAR 0 10
55047: IFFALSE 55103
// begin depot := NearestUnitToUnit ( depot , unit ) ;
55049: LD_ADDR_VAR 0 10
55053: PUSH
55054: LD_VAR 0 10
55058: PPUSH
55059: LD_VAR 0 3
55063: PPUSH
55064: CALL_OW 74
55068: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
55069: LD_VAR 0 3
55073: PPUSH
55074: LD_VAR 0 10
55078: PPUSH
55079: CALL_OW 296
55083: PUSH
55084: LD_INT 10
55086: GREATER
55087: IFFALSE 55103
// ComStandNearbyBuilding ( unit , depot ) ;
55089: LD_VAR 0 3
55093: PPUSH
55094: LD_VAR 0 10
55098: PPUSH
55099: CALL 63097 0 2
// end ; end ; end ;
55103: LD_VAR 0 5
55107: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
55108: LD_INT 0
55110: PPUSH
55111: PPUSH
55112: PPUSH
55113: PPUSH
// if not mc_bases then
55114: LD_EXP 99
55118: NOT
55119: IFFALSE 55123
// exit ;
55121: GO 55362
// for i = 1 to mc_bases do
55123: LD_ADDR_VAR 0 2
55127: PUSH
55128: DOUBLE
55129: LD_INT 1
55131: DEC
55132: ST_TO_ADDR
55133: LD_EXP 99
55137: PUSH
55138: FOR_TO
55139: IFFALSE 55360
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
55141: LD_ADDR_VAR 0 4
55145: PUSH
55146: LD_EXP 99
55150: PUSH
55151: LD_VAR 0 2
55155: ARRAY
55156: PPUSH
55157: LD_INT 21
55159: PUSH
55160: LD_INT 1
55162: PUSH
55163: EMPTY
55164: LIST
55165: LIST
55166: PPUSH
55167: CALL_OW 72
55171: PUSH
55172: LD_EXP 128
55176: PUSH
55177: LD_VAR 0 2
55181: ARRAY
55182: UNION
55183: ST_TO_ADDR
// if not tmp then
55184: LD_VAR 0 4
55188: NOT
55189: IFFALSE 55193
// continue ;
55191: GO 55138
// for j in tmp do
55193: LD_ADDR_VAR 0 3
55197: PUSH
55198: LD_VAR 0 4
55202: PUSH
55203: FOR_IN
55204: IFFALSE 55356
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
55206: LD_VAR 0 3
55210: PPUSH
55211: CALL_OW 110
55215: NOT
55216: PUSH
55217: LD_VAR 0 3
55221: PPUSH
55222: CALL_OW 314
55226: NOT
55227: AND
55228: PUSH
55229: LD_VAR 0 3
55233: PPUSH
55234: CALL_OW 311
55238: NOT
55239: AND
55240: PUSH
55241: LD_VAR 0 3
55245: PPUSH
55246: CALL_OW 310
55250: NOT
55251: AND
55252: PUSH
55253: LD_VAR 0 3
55257: PUSH
55258: LD_EXP 102
55262: PUSH
55263: LD_VAR 0 2
55267: ARRAY
55268: PUSH
55269: LD_INT 1
55271: ARRAY
55272: IN
55273: NOT
55274: AND
55275: PUSH
55276: LD_VAR 0 3
55280: PUSH
55281: LD_EXP 102
55285: PUSH
55286: LD_VAR 0 2
55290: ARRAY
55291: PUSH
55292: LD_INT 2
55294: ARRAY
55295: IN
55296: NOT
55297: AND
55298: PUSH
55299: LD_VAR 0 3
55303: PUSH
55304: LD_EXP 111
55308: PUSH
55309: LD_VAR 0 2
55313: ARRAY
55314: IN
55315: NOT
55316: AND
55317: IFFALSE 55354
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
55319: LD_VAR 0 2
55323: PPUSH
55324: LD_EXP 99
55328: PUSH
55329: LD_VAR 0 2
55333: ARRAY
55334: PPUSH
55335: LD_VAR 0 3
55339: PPUSH
55340: LD_VAR 0 3
55344: PPUSH
55345: CALL_OW 257
55349: PPUSH
55350: CALL 54126 0 4
// end ;
55354: GO 55203
55356: POP
55357: POP
// end ;
55358: GO 55138
55360: POP
55361: POP
// end ;
55362: LD_VAR 0 1
55366: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
55367: LD_INT 0
55369: PPUSH
55370: PPUSH
55371: PPUSH
55372: PPUSH
55373: PPUSH
55374: PPUSH
// if not mc_bases [ base ] then
55375: LD_EXP 99
55379: PUSH
55380: LD_VAR 0 1
55384: ARRAY
55385: NOT
55386: IFFALSE 55390
// exit ;
55388: GO 55572
// tmp := [ ] ;
55390: LD_ADDR_VAR 0 6
55394: PUSH
55395: EMPTY
55396: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
55397: LD_ADDR_VAR 0 7
55401: PUSH
55402: LD_VAR 0 3
55406: PPUSH
55407: LD_INT 0
55409: PPUSH
55410: CALL_OW 517
55414: ST_TO_ADDR
// if not list then
55415: LD_VAR 0 7
55419: NOT
55420: IFFALSE 55424
// exit ;
55422: GO 55572
// for i = 1 to amount do
55424: LD_ADDR_VAR 0 5
55428: PUSH
55429: DOUBLE
55430: LD_INT 1
55432: DEC
55433: ST_TO_ADDR
55434: LD_VAR 0 2
55438: PUSH
55439: FOR_TO
55440: IFFALSE 55520
// begin x := rand ( 1 , list [ 1 ] ) ;
55442: LD_ADDR_VAR 0 8
55446: PUSH
55447: LD_INT 1
55449: PPUSH
55450: LD_VAR 0 7
55454: PUSH
55455: LD_INT 1
55457: ARRAY
55458: PPUSH
55459: CALL_OW 12
55463: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
55464: LD_ADDR_VAR 0 6
55468: PUSH
55469: LD_VAR 0 6
55473: PPUSH
55474: LD_VAR 0 5
55478: PPUSH
55479: LD_VAR 0 7
55483: PUSH
55484: LD_INT 1
55486: ARRAY
55487: PUSH
55488: LD_VAR 0 8
55492: ARRAY
55493: PUSH
55494: LD_VAR 0 7
55498: PUSH
55499: LD_INT 2
55501: ARRAY
55502: PUSH
55503: LD_VAR 0 8
55507: ARRAY
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: PPUSH
55513: CALL_OW 1
55517: ST_TO_ADDR
// end ;
55518: GO 55439
55520: POP
55521: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
55522: LD_ADDR_EXP 112
55526: PUSH
55527: LD_EXP 112
55531: PPUSH
55532: LD_VAR 0 1
55536: PPUSH
55537: LD_VAR 0 6
55541: PPUSH
55542: CALL_OW 1
55546: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
55547: LD_ADDR_EXP 114
55551: PUSH
55552: LD_EXP 114
55556: PPUSH
55557: LD_VAR 0 1
55561: PPUSH
55562: LD_VAR 0 3
55566: PPUSH
55567: CALL_OW 1
55571: ST_TO_ADDR
// end ;
55572: LD_VAR 0 4
55576: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
55577: LD_INT 0
55579: PPUSH
// if not mc_bases [ base ] then
55580: LD_EXP 99
55584: PUSH
55585: LD_VAR 0 1
55589: ARRAY
55590: NOT
55591: IFFALSE 55595
// exit ;
55593: GO 55620
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
55595: LD_ADDR_EXP 104
55599: PUSH
55600: LD_EXP 104
55604: PPUSH
55605: LD_VAR 0 1
55609: PPUSH
55610: LD_VAR 0 2
55614: PPUSH
55615: CALL_OW 1
55619: ST_TO_ADDR
// end ;
55620: LD_VAR 0 3
55624: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
55625: LD_INT 0
55627: PPUSH
// if not mc_bases [ base ] then
55628: LD_EXP 99
55632: PUSH
55633: LD_VAR 0 1
55637: ARRAY
55638: NOT
55639: IFFALSE 55643
// exit ;
55641: GO 55680
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
55643: LD_ADDR_EXP 104
55647: PUSH
55648: LD_EXP 104
55652: PPUSH
55653: LD_VAR 0 1
55657: PPUSH
55658: LD_EXP 104
55662: PUSH
55663: LD_VAR 0 1
55667: ARRAY
55668: PUSH
55669: LD_VAR 0 2
55673: UNION
55674: PPUSH
55675: CALL_OW 1
55679: ST_TO_ADDR
// end ;
55680: LD_VAR 0 3
55684: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
55685: LD_INT 0
55687: PPUSH
// if not mc_bases [ base ] then
55688: LD_EXP 99
55692: PUSH
55693: LD_VAR 0 1
55697: ARRAY
55698: NOT
55699: IFFALSE 55703
// exit ;
55701: GO 55728
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
55703: LD_ADDR_EXP 120
55707: PUSH
55708: LD_EXP 120
55712: PPUSH
55713: LD_VAR 0 1
55717: PPUSH
55718: LD_VAR 0 2
55722: PPUSH
55723: CALL_OW 1
55727: ST_TO_ADDR
// end ;
55728: LD_VAR 0 3
55732: RET
// export function MC_InsertProduceList ( base , components ) ; begin
55733: LD_INT 0
55735: PPUSH
// if not mc_bases [ base ] then
55736: LD_EXP 99
55740: PUSH
55741: LD_VAR 0 1
55745: ARRAY
55746: NOT
55747: IFFALSE 55751
// exit ;
55749: GO 55788
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
55751: LD_ADDR_EXP 120
55755: PUSH
55756: LD_EXP 120
55760: PPUSH
55761: LD_VAR 0 1
55765: PPUSH
55766: LD_EXP 120
55770: PUSH
55771: LD_VAR 0 1
55775: ARRAY
55776: PUSH
55777: LD_VAR 0 2
55781: ADD
55782: PPUSH
55783: CALL_OW 1
55787: ST_TO_ADDR
// end ;
55788: LD_VAR 0 3
55792: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
55793: LD_INT 0
55795: PPUSH
// if not mc_bases [ base ] then
55796: LD_EXP 99
55800: PUSH
55801: LD_VAR 0 1
55805: ARRAY
55806: NOT
55807: IFFALSE 55811
// exit ;
55809: GO 55865
// mc_defender := Replace ( mc_defender , base , deflist ) ;
55811: LD_ADDR_EXP 121
55815: PUSH
55816: LD_EXP 121
55820: PPUSH
55821: LD_VAR 0 1
55825: PPUSH
55826: LD_VAR 0 2
55830: PPUSH
55831: CALL_OW 1
55835: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
55836: LD_ADDR_EXP 110
55840: PUSH
55841: LD_EXP 110
55845: PPUSH
55846: LD_VAR 0 1
55850: PPUSH
55851: LD_VAR 0 2
55855: PUSH
55856: LD_INT 0
55858: PLUS
55859: PPUSH
55860: CALL_OW 1
55864: ST_TO_ADDR
// end ;
55865: LD_VAR 0 3
55869: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
55870: LD_INT 0
55872: PPUSH
// if not mc_bases [ base ] then
55873: LD_EXP 99
55877: PUSH
55878: LD_VAR 0 1
55882: ARRAY
55883: NOT
55884: IFFALSE 55888
// exit ;
55886: GO 55913
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
55888: LD_ADDR_EXP 110
55892: PUSH
55893: LD_EXP 110
55897: PPUSH
55898: LD_VAR 0 1
55902: PPUSH
55903: LD_VAR 0 2
55907: PPUSH
55908: CALL_OW 1
55912: ST_TO_ADDR
// end ;
55913: LD_VAR 0 3
55917: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
55918: LD_INT 0
55920: PPUSH
55921: PPUSH
55922: PPUSH
55923: PPUSH
// if not mc_bases [ base ] then
55924: LD_EXP 99
55928: PUSH
55929: LD_VAR 0 1
55933: ARRAY
55934: NOT
55935: IFFALSE 55939
// exit ;
55937: GO 56004
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
55939: LD_ADDR_EXP 119
55943: PUSH
55944: LD_EXP 119
55948: PPUSH
55949: LD_VAR 0 1
55953: PUSH
55954: LD_EXP 119
55958: PUSH
55959: LD_VAR 0 1
55963: ARRAY
55964: PUSH
55965: LD_INT 1
55967: PLUS
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: PPUSH
55973: LD_VAR 0 1
55977: PUSH
55978: LD_VAR 0 2
55982: PUSH
55983: LD_VAR 0 3
55987: PUSH
55988: LD_VAR 0 4
55992: PUSH
55993: EMPTY
55994: LIST
55995: LIST
55996: LIST
55997: LIST
55998: PPUSH
55999: CALL 68420 0 3
56003: ST_TO_ADDR
// end ;
56004: LD_VAR 0 5
56008: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
56009: LD_INT 0
56011: PPUSH
// if not mc_bases [ base ] then
56012: LD_EXP 99
56016: PUSH
56017: LD_VAR 0 1
56021: ARRAY
56022: NOT
56023: IFFALSE 56027
// exit ;
56025: GO 56052
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
56027: LD_ADDR_EXP 136
56031: PUSH
56032: LD_EXP 136
56036: PPUSH
56037: LD_VAR 0 1
56041: PPUSH
56042: LD_VAR 0 2
56046: PPUSH
56047: CALL_OW 1
56051: ST_TO_ADDR
// end ;
56052: LD_VAR 0 3
56056: RET
// export function MC_GetMinesField ( base ) ; begin
56057: LD_INT 0
56059: PPUSH
// result := mc_mines [ base ] ;
56060: LD_ADDR_VAR 0 2
56064: PUSH
56065: LD_EXP 112
56069: PUSH
56070: LD_VAR 0 1
56074: ARRAY
56075: ST_TO_ADDR
// end ;
56076: LD_VAR 0 2
56080: RET
// export function MC_GetProduceList ( base ) ; begin
56081: LD_INT 0
56083: PPUSH
// result := mc_produce [ base ] ;
56084: LD_ADDR_VAR 0 2
56088: PUSH
56089: LD_EXP 120
56093: PUSH
56094: LD_VAR 0 1
56098: ARRAY
56099: ST_TO_ADDR
// end ;
56100: LD_VAR 0 2
56104: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
56105: LD_INT 0
56107: PPUSH
56108: PPUSH
// if not mc_bases then
56109: LD_EXP 99
56113: NOT
56114: IFFALSE 56118
// exit ;
56116: GO 56183
// if mc_bases [ base ] then
56118: LD_EXP 99
56122: PUSH
56123: LD_VAR 0 1
56127: ARRAY
56128: IFFALSE 56183
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
56130: LD_ADDR_VAR 0 3
56134: PUSH
56135: LD_EXP 99
56139: PUSH
56140: LD_VAR 0 1
56144: ARRAY
56145: PPUSH
56146: LD_INT 30
56148: PUSH
56149: LD_VAR 0 2
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: PPUSH
56158: CALL_OW 72
56162: ST_TO_ADDR
// if result then
56163: LD_VAR 0 3
56167: IFFALSE 56183
// result := result [ 1 ] ;
56169: LD_ADDR_VAR 0 3
56173: PUSH
56174: LD_VAR 0 3
56178: PUSH
56179: LD_INT 1
56181: ARRAY
56182: ST_TO_ADDR
// end ; end ;
56183: LD_VAR 0 3
56187: RET
// export function MC_SetTame ( base , area ) ; begin
56188: LD_INT 0
56190: PPUSH
// if not mc_bases or not base then
56191: LD_EXP 99
56195: NOT
56196: PUSH
56197: LD_VAR 0 1
56201: NOT
56202: OR
56203: IFFALSE 56207
// exit ;
56205: GO 56232
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
56207: LD_ADDR_EXP 127
56211: PUSH
56212: LD_EXP 127
56216: PPUSH
56217: LD_VAR 0 1
56221: PPUSH
56222: LD_VAR 0 2
56226: PPUSH
56227: CALL_OW 1
56231: ST_TO_ADDR
// end ;
56232: LD_VAR 0 3
56236: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
56237: LD_INT 0
56239: PPUSH
56240: PPUSH
// if not mc_bases or not base then
56241: LD_EXP 99
56245: NOT
56246: PUSH
56247: LD_VAR 0 1
56251: NOT
56252: OR
56253: IFFALSE 56257
// exit ;
56255: GO 56359
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
56257: LD_ADDR_VAR 0 4
56261: PUSH
56262: LD_EXP 99
56266: PUSH
56267: LD_VAR 0 1
56271: ARRAY
56272: PPUSH
56273: LD_INT 30
56275: PUSH
56276: LD_VAR 0 2
56280: PUSH
56281: EMPTY
56282: LIST
56283: LIST
56284: PPUSH
56285: CALL_OW 72
56289: ST_TO_ADDR
// if not tmp then
56290: LD_VAR 0 4
56294: NOT
56295: IFFALSE 56299
// exit ;
56297: GO 56359
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
56299: LD_ADDR_EXP 131
56303: PUSH
56304: LD_EXP 131
56308: PPUSH
56309: LD_VAR 0 1
56313: PPUSH
56314: LD_EXP 131
56318: PUSH
56319: LD_VAR 0 1
56323: ARRAY
56324: PPUSH
56325: LD_EXP 131
56329: PUSH
56330: LD_VAR 0 1
56334: ARRAY
56335: PUSH
56336: LD_INT 1
56338: PLUS
56339: PPUSH
56340: LD_VAR 0 4
56344: PUSH
56345: LD_INT 1
56347: ARRAY
56348: PPUSH
56349: CALL_OW 2
56353: PPUSH
56354: CALL_OW 1
56358: ST_TO_ADDR
// end ;
56359: LD_VAR 0 3
56363: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
56364: LD_INT 0
56366: PPUSH
56367: PPUSH
// if not mc_bases or not base or not kinds then
56368: LD_EXP 99
56372: NOT
56373: PUSH
56374: LD_VAR 0 1
56378: NOT
56379: OR
56380: PUSH
56381: LD_VAR 0 2
56385: NOT
56386: OR
56387: IFFALSE 56391
// exit ;
56389: GO 56452
// for i in kinds do
56391: LD_ADDR_VAR 0 4
56395: PUSH
56396: LD_VAR 0 2
56400: PUSH
56401: FOR_IN
56402: IFFALSE 56450
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
56404: LD_ADDR_EXP 133
56408: PUSH
56409: LD_EXP 133
56413: PPUSH
56414: LD_VAR 0 1
56418: PUSH
56419: LD_EXP 133
56423: PUSH
56424: LD_VAR 0 1
56428: ARRAY
56429: PUSH
56430: LD_INT 1
56432: PLUS
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: PPUSH
56438: LD_VAR 0 4
56442: PPUSH
56443: CALL 68420 0 3
56447: ST_TO_ADDR
56448: GO 56401
56450: POP
56451: POP
// end ;
56452: LD_VAR 0 3
56456: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
56457: LD_INT 0
56459: PPUSH
// if not mc_bases or not base or not areas then
56460: LD_EXP 99
56464: NOT
56465: PUSH
56466: LD_VAR 0 1
56470: NOT
56471: OR
56472: PUSH
56473: LD_VAR 0 2
56477: NOT
56478: OR
56479: IFFALSE 56483
// exit ;
56481: GO 56508
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
56483: LD_ADDR_EXP 117
56487: PUSH
56488: LD_EXP 117
56492: PPUSH
56493: LD_VAR 0 1
56497: PPUSH
56498: LD_VAR 0 2
56502: PPUSH
56503: CALL_OW 1
56507: ST_TO_ADDR
// end ;
56508: LD_VAR 0 3
56512: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
56513: LD_INT 0
56515: PPUSH
// if not mc_bases or not base or not teleports_exit then
56516: LD_EXP 99
56520: NOT
56521: PUSH
56522: LD_VAR 0 1
56526: NOT
56527: OR
56528: PUSH
56529: LD_VAR 0 2
56533: NOT
56534: OR
56535: IFFALSE 56539
// exit ;
56537: GO 56564
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
56539: LD_ADDR_EXP 134
56543: PUSH
56544: LD_EXP 134
56548: PPUSH
56549: LD_VAR 0 1
56553: PPUSH
56554: LD_VAR 0 2
56558: PPUSH
56559: CALL_OW 1
56563: ST_TO_ADDR
// end ;
56564: LD_VAR 0 3
56568: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
56569: LD_INT 0
56571: PPUSH
56572: PPUSH
56573: PPUSH
// if not mc_bases or not base or not ext_list then
56574: LD_EXP 99
56578: NOT
56579: PUSH
56580: LD_VAR 0 1
56584: NOT
56585: OR
56586: PUSH
56587: LD_VAR 0 5
56591: NOT
56592: OR
56593: IFFALSE 56597
// exit ;
56595: GO 56770
// tmp := GetFacExtXYD ( x , y , d ) ;
56597: LD_ADDR_VAR 0 8
56601: PUSH
56602: LD_VAR 0 2
56606: PPUSH
56607: LD_VAR 0 3
56611: PPUSH
56612: LD_VAR 0 4
56616: PPUSH
56617: CALL 101735 0 3
56621: ST_TO_ADDR
// if not tmp then
56622: LD_VAR 0 8
56626: NOT
56627: IFFALSE 56631
// exit ;
56629: GO 56770
// for i in tmp do
56631: LD_ADDR_VAR 0 7
56635: PUSH
56636: LD_VAR 0 8
56640: PUSH
56641: FOR_IN
56642: IFFALSE 56768
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
56644: LD_ADDR_EXP 104
56648: PUSH
56649: LD_EXP 104
56653: PPUSH
56654: LD_VAR 0 1
56658: PPUSH
56659: LD_EXP 104
56663: PUSH
56664: LD_VAR 0 1
56668: ARRAY
56669: PPUSH
56670: LD_EXP 104
56674: PUSH
56675: LD_VAR 0 1
56679: ARRAY
56680: PUSH
56681: LD_INT 1
56683: PLUS
56684: PPUSH
56685: LD_VAR 0 5
56689: PUSH
56690: LD_INT 1
56692: ARRAY
56693: PUSH
56694: LD_VAR 0 7
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PUSH
56703: LD_VAR 0 7
56707: PUSH
56708: LD_INT 2
56710: ARRAY
56711: PUSH
56712: LD_VAR 0 7
56716: PUSH
56717: LD_INT 3
56719: ARRAY
56720: PUSH
56721: EMPTY
56722: LIST
56723: LIST
56724: LIST
56725: LIST
56726: PPUSH
56727: CALL_OW 2
56731: PPUSH
56732: CALL_OW 1
56736: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
56737: LD_ADDR_VAR 0 5
56741: PUSH
56742: LD_VAR 0 5
56746: PPUSH
56747: LD_INT 1
56749: PPUSH
56750: CALL_OW 3
56754: ST_TO_ADDR
// if not ext_list then
56755: LD_VAR 0 5
56759: NOT
56760: IFFALSE 56766
// exit ;
56762: POP
56763: POP
56764: GO 56770
// end ;
56766: GO 56641
56768: POP
56769: POP
// end ;
56770: LD_VAR 0 6
56774: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
56775: LD_INT 0
56777: PPUSH
// if not mc_bases or not base or not weapon_list then
56778: LD_EXP 99
56782: NOT
56783: PUSH
56784: LD_VAR 0 1
56788: NOT
56789: OR
56790: PUSH
56791: LD_VAR 0 2
56795: NOT
56796: OR
56797: IFFALSE 56801
// exit ;
56799: GO 56826
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
56801: LD_ADDR_EXP 138
56805: PUSH
56806: LD_EXP 138
56810: PPUSH
56811: LD_VAR 0 1
56815: PPUSH
56816: LD_VAR 0 2
56820: PPUSH
56821: CALL_OW 1
56825: ST_TO_ADDR
// end ;
56826: LD_VAR 0 3
56830: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
56831: LD_INT 0
56833: PPUSH
// if not mc_bases or not base or not tech_list then
56834: LD_EXP 99
56838: NOT
56839: PUSH
56840: LD_VAR 0 1
56844: NOT
56845: OR
56846: PUSH
56847: LD_VAR 0 2
56851: NOT
56852: OR
56853: IFFALSE 56857
// exit ;
56855: GO 56882
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
56857: LD_ADDR_EXP 126
56861: PUSH
56862: LD_EXP 126
56866: PPUSH
56867: LD_VAR 0 1
56871: PPUSH
56872: LD_VAR 0 2
56876: PPUSH
56877: CALL_OW 1
56881: ST_TO_ADDR
// end ;
56882: LD_VAR 0 3
56886: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
56887: LD_INT 0
56889: PPUSH
// if not mc_bases or not parking_area or not base then
56890: LD_EXP 99
56894: NOT
56895: PUSH
56896: LD_VAR 0 2
56900: NOT
56901: OR
56902: PUSH
56903: LD_VAR 0 1
56907: NOT
56908: OR
56909: IFFALSE 56913
// exit ;
56911: GO 56938
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
56913: LD_ADDR_EXP 123
56917: PUSH
56918: LD_EXP 123
56922: PPUSH
56923: LD_VAR 0 1
56927: PPUSH
56928: LD_VAR 0 2
56932: PPUSH
56933: CALL_OW 1
56937: ST_TO_ADDR
// end ;
56938: LD_VAR 0 3
56942: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
56943: LD_INT 0
56945: PPUSH
// if not mc_bases or not base or not scan_area then
56946: LD_EXP 99
56950: NOT
56951: PUSH
56952: LD_VAR 0 1
56956: NOT
56957: OR
56958: PUSH
56959: LD_VAR 0 2
56963: NOT
56964: OR
56965: IFFALSE 56969
// exit ;
56967: GO 56994
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
56969: LD_ADDR_EXP 124
56973: PUSH
56974: LD_EXP 124
56978: PPUSH
56979: LD_VAR 0 1
56983: PPUSH
56984: LD_VAR 0 2
56988: PPUSH
56989: CALL_OW 1
56993: ST_TO_ADDR
// end ;
56994: LD_VAR 0 3
56998: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
56999: LD_INT 0
57001: PPUSH
57002: PPUSH
// if not mc_bases or not base then
57003: LD_EXP 99
57007: NOT
57008: PUSH
57009: LD_VAR 0 1
57013: NOT
57014: OR
57015: IFFALSE 57019
// exit ;
57017: GO 57083
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
57019: LD_ADDR_VAR 0 3
57023: PUSH
57024: LD_INT 1
57026: PUSH
57027: LD_INT 2
57029: PUSH
57030: LD_INT 3
57032: PUSH
57033: LD_INT 4
57035: PUSH
57036: LD_INT 11
57038: PUSH
57039: EMPTY
57040: LIST
57041: LIST
57042: LIST
57043: LIST
57044: LIST
57045: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
57046: LD_ADDR_EXP 126
57050: PUSH
57051: LD_EXP 126
57055: PPUSH
57056: LD_VAR 0 1
57060: PPUSH
57061: LD_EXP 126
57065: PUSH
57066: LD_VAR 0 1
57070: ARRAY
57071: PUSH
57072: LD_VAR 0 3
57076: DIFF
57077: PPUSH
57078: CALL_OW 1
57082: ST_TO_ADDR
// end ;
57083: LD_VAR 0 2
57087: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
57088: LD_INT 0
57090: PPUSH
// result := mc_vehicles [ base ] ;
57091: LD_ADDR_VAR 0 3
57095: PUSH
57096: LD_EXP 118
57100: PUSH
57101: LD_VAR 0 1
57105: ARRAY
57106: ST_TO_ADDR
// if onlyCombat then
57107: LD_VAR 0 2
57111: IFFALSE 57276
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
57113: LD_ADDR_VAR 0 3
57117: PUSH
57118: LD_VAR 0 3
57122: PUSH
57123: LD_VAR 0 3
57127: PPUSH
57128: LD_INT 2
57130: PUSH
57131: LD_INT 34
57133: PUSH
57134: LD_INT 12
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PUSH
57141: LD_INT 34
57143: PUSH
57144: LD_INT 51
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: PUSH
57151: LD_INT 34
57153: PUSH
57154: LD_EXP 93
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: PUSH
57163: LD_INT 34
57165: PUSH
57166: LD_INT 32
57168: PUSH
57169: EMPTY
57170: LIST
57171: LIST
57172: PUSH
57173: LD_INT 34
57175: PUSH
57176: LD_INT 13
57178: PUSH
57179: EMPTY
57180: LIST
57181: LIST
57182: PUSH
57183: LD_INT 34
57185: PUSH
57186: LD_INT 52
57188: PUSH
57189: EMPTY
57190: LIST
57191: LIST
57192: PUSH
57193: LD_INT 34
57195: PUSH
57196: LD_INT 14
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: PUSH
57203: LD_INT 34
57205: PUSH
57206: LD_INT 53
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: PUSH
57213: LD_INT 34
57215: PUSH
57216: LD_EXP 92
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: LD_INT 34
57227: PUSH
57228: LD_INT 31
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: PUSH
57235: LD_INT 34
57237: PUSH
57238: LD_INT 48
57240: PUSH
57241: EMPTY
57242: LIST
57243: LIST
57244: PUSH
57245: LD_INT 34
57247: PUSH
57248: LD_INT 8
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: EMPTY
57256: LIST
57257: LIST
57258: LIST
57259: LIST
57260: LIST
57261: LIST
57262: LIST
57263: LIST
57264: LIST
57265: LIST
57266: LIST
57267: LIST
57268: LIST
57269: PPUSH
57270: CALL_OW 72
57274: DIFF
57275: ST_TO_ADDR
// end ; end_of_file
57276: LD_VAR 0 3
57280: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
57281: LD_INT 0
57283: PPUSH
57284: PPUSH
57285: PPUSH
// if not mc_bases or not skirmish then
57286: LD_EXP 99
57290: NOT
57291: PUSH
57292: LD_EXP 97
57296: NOT
57297: OR
57298: IFFALSE 57302
// exit ;
57300: GO 57467
// for i = 1 to mc_bases do
57302: LD_ADDR_VAR 0 4
57306: PUSH
57307: DOUBLE
57308: LD_INT 1
57310: DEC
57311: ST_TO_ADDR
57312: LD_EXP 99
57316: PUSH
57317: FOR_TO
57318: IFFALSE 57465
// begin if sci in mc_bases [ i ] then
57320: LD_VAR 0 2
57324: PUSH
57325: LD_EXP 99
57329: PUSH
57330: LD_VAR 0 4
57334: ARRAY
57335: IN
57336: IFFALSE 57463
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
57338: LD_ADDR_EXP 128
57342: PUSH
57343: LD_EXP 128
57347: PPUSH
57348: LD_VAR 0 4
57352: PUSH
57353: LD_EXP 128
57357: PUSH
57358: LD_VAR 0 4
57362: ARRAY
57363: PUSH
57364: LD_INT 1
57366: PLUS
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: PPUSH
57372: LD_VAR 0 1
57376: PPUSH
57377: CALL 68420 0 3
57381: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
57382: LD_ADDR_VAR 0 5
57386: PUSH
57387: LD_EXP 99
57391: PUSH
57392: LD_VAR 0 4
57396: ARRAY
57397: PPUSH
57398: LD_INT 2
57400: PUSH
57401: LD_INT 30
57403: PUSH
57404: LD_INT 0
57406: PUSH
57407: EMPTY
57408: LIST
57409: LIST
57410: PUSH
57411: LD_INT 30
57413: PUSH
57414: LD_INT 1
57416: PUSH
57417: EMPTY
57418: LIST
57419: LIST
57420: PUSH
57421: EMPTY
57422: LIST
57423: LIST
57424: LIST
57425: PPUSH
57426: CALL_OW 72
57430: PPUSH
57431: LD_VAR 0 1
57435: PPUSH
57436: CALL_OW 74
57440: ST_TO_ADDR
// if tmp then
57441: LD_VAR 0 5
57445: IFFALSE 57461
// ComStandNearbyBuilding ( ape , tmp ) ;
57447: LD_VAR 0 1
57451: PPUSH
57452: LD_VAR 0 5
57456: PPUSH
57457: CALL 63097 0 2
// break ;
57461: GO 57465
// end ; end ;
57463: GO 57317
57465: POP
57466: POP
// end ;
57467: LD_VAR 0 3
57471: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
57472: LD_INT 0
57474: PPUSH
57475: PPUSH
57476: PPUSH
// if not mc_bases or not skirmish then
57477: LD_EXP 99
57481: NOT
57482: PUSH
57483: LD_EXP 97
57487: NOT
57488: OR
57489: IFFALSE 57493
// exit ;
57491: GO 57582
// for i = 1 to mc_bases do
57493: LD_ADDR_VAR 0 4
57497: PUSH
57498: DOUBLE
57499: LD_INT 1
57501: DEC
57502: ST_TO_ADDR
57503: LD_EXP 99
57507: PUSH
57508: FOR_TO
57509: IFFALSE 57580
// begin if building in mc_busy_turret_list [ i ] then
57511: LD_VAR 0 1
57515: PUSH
57516: LD_EXP 109
57520: PUSH
57521: LD_VAR 0 4
57525: ARRAY
57526: IN
57527: IFFALSE 57578
// begin tmp := mc_busy_turret_list [ i ] diff building ;
57529: LD_ADDR_VAR 0 5
57533: PUSH
57534: LD_EXP 109
57538: PUSH
57539: LD_VAR 0 4
57543: ARRAY
57544: PUSH
57545: LD_VAR 0 1
57549: DIFF
57550: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
57551: LD_ADDR_EXP 109
57555: PUSH
57556: LD_EXP 109
57560: PPUSH
57561: LD_VAR 0 4
57565: PPUSH
57566: LD_VAR 0 5
57570: PPUSH
57571: CALL_OW 1
57575: ST_TO_ADDR
// break ;
57576: GO 57580
// end ; end ;
57578: GO 57508
57580: POP
57581: POP
// end ;
57582: LD_VAR 0 3
57586: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
57587: LD_INT 0
57589: PPUSH
57590: PPUSH
57591: PPUSH
// if not mc_bases or not skirmish then
57592: LD_EXP 99
57596: NOT
57597: PUSH
57598: LD_EXP 97
57602: NOT
57603: OR
57604: IFFALSE 57608
// exit ;
57606: GO 57807
// for i = 1 to mc_bases do
57608: LD_ADDR_VAR 0 5
57612: PUSH
57613: DOUBLE
57614: LD_INT 1
57616: DEC
57617: ST_TO_ADDR
57618: LD_EXP 99
57622: PUSH
57623: FOR_TO
57624: IFFALSE 57805
// if building in mc_bases [ i ] then
57626: LD_VAR 0 1
57630: PUSH
57631: LD_EXP 99
57635: PUSH
57636: LD_VAR 0 5
57640: ARRAY
57641: IN
57642: IFFALSE 57803
// begin tmp := mc_bases [ i ] diff building ;
57644: LD_ADDR_VAR 0 6
57648: PUSH
57649: LD_EXP 99
57653: PUSH
57654: LD_VAR 0 5
57658: ARRAY
57659: PUSH
57660: LD_VAR 0 1
57664: DIFF
57665: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
57666: LD_ADDR_EXP 99
57670: PUSH
57671: LD_EXP 99
57675: PPUSH
57676: LD_VAR 0 5
57680: PPUSH
57681: LD_VAR 0 6
57685: PPUSH
57686: CALL_OW 1
57690: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
57691: LD_VAR 0 1
57695: PUSH
57696: LD_EXP 107
57700: PUSH
57701: LD_VAR 0 5
57705: ARRAY
57706: IN
57707: IFFALSE 57746
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
57709: LD_ADDR_EXP 107
57713: PUSH
57714: LD_EXP 107
57718: PPUSH
57719: LD_VAR 0 5
57723: PPUSH
57724: LD_EXP 107
57728: PUSH
57729: LD_VAR 0 5
57733: ARRAY
57734: PUSH
57735: LD_VAR 0 1
57739: DIFF
57740: PPUSH
57741: CALL_OW 1
57745: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
57746: LD_VAR 0 1
57750: PUSH
57751: LD_EXP 108
57755: PUSH
57756: LD_VAR 0 5
57760: ARRAY
57761: IN
57762: IFFALSE 57801
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
57764: LD_ADDR_EXP 108
57768: PUSH
57769: LD_EXP 108
57773: PPUSH
57774: LD_VAR 0 5
57778: PPUSH
57779: LD_EXP 108
57783: PUSH
57784: LD_VAR 0 5
57788: ARRAY
57789: PUSH
57790: LD_VAR 0 1
57794: DIFF
57795: PPUSH
57796: CALL_OW 1
57800: ST_TO_ADDR
// break ;
57801: GO 57805
// end ;
57803: GO 57623
57805: POP
57806: POP
// end ;
57807: LD_VAR 0 4
57811: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
57812: LD_INT 0
57814: PPUSH
57815: PPUSH
57816: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
57817: LD_EXP 99
57821: NOT
57822: PUSH
57823: LD_EXP 97
57827: NOT
57828: OR
57829: PUSH
57830: LD_VAR 0 3
57834: PUSH
57835: LD_EXP 125
57839: IN
57840: NOT
57841: OR
57842: IFFALSE 57846
// exit ;
57844: GO 57969
// for i = 1 to mc_vehicles do
57846: LD_ADDR_VAR 0 6
57850: PUSH
57851: DOUBLE
57852: LD_INT 1
57854: DEC
57855: ST_TO_ADDR
57856: LD_EXP 118
57860: PUSH
57861: FOR_TO
57862: IFFALSE 57967
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
57864: LD_VAR 0 2
57868: PUSH
57869: LD_EXP 118
57873: PUSH
57874: LD_VAR 0 6
57878: ARRAY
57879: IN
57880: PUSH
57881: LD_VAR 0 1
57885: PUSH
57886: LD_EXP 118
57890: PUSH
57891: LD_VAR 0 6
57895: ARRAY
57896: IN
57897: OR
57898: IFFALSE 57965
// begin tmp := mc_vehicles [ i ] diff old ;
57900: LD_ADDR_VAR 0 7
57904: PUSH
57905: LD_EXP 118
57909: PUSH
57910: LD_VAR 0 6
57914: ARRAY
57915: PUSH
57916: LD_VAR 0 2
57920: DIFF
57921: ST_TO_ADDR
// tmp := tmp diff new ;
57922: LD_ADDR_VAR 0 7
57926: PUSH
57927: LD_VAR 0 7
57931: PUSH
57932: LD_VAR 0 1
57936: DIFF
57937: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
57938: LD_ADDR_EXP 118
57942: PUSH
57943: LD_EXP 118
57947: PPUSH
57948: LD_VAR 0 6
57952: PPUSH
57953: LD_VAR 0 7
57957: PPUSH
57958: CALL_OW 1
57962: ST_TO_ADDR
// break ;
57963: GO 57967
// end ;
57965: GO 57861
57967: POP
57968: POP
// end ;
57969: LD_VAR 0 5
57973: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
57974: LD_INT 0
57976: PPUSH
57977: PPUSH
57978: PPUSH
57979: PPUSH
// if not mc_bases or not skirmish then
57980: LD_EXP 99
57984: NOT
57985: PUSH
57986: LD_EXP 97
57990: NOT
57991: OR
57992: IFFALSE 57996
// exit ;
57994: GO 58379
// side := GetSide ( vehicle ) ;
57996: LD_ADDR_VAR 0 5
58000: PUSH
58001: LD_VAR 0 1
58005: PPUSH
58006: CALL_OW 255
58010: ST_TO_ADDR
// for i = 1 to mc_bases do
58011: LD_ADDR_VAR 0 4
58015: PUSH
58016: DOUBLE
58017: LD_INT 1
58019: DEC
58020: ST_TO_ADDR
58021: LD_EXP 99
58025: PUSH
58026: FOR_TO
58027: IFFALSE 58377
// begin if factory in mc_bases [ i ] then
58029: LD_VAR 0 2
58033: PUSH
58034: LD_EXP 99
58038: PUSH
58039: LD_VAR 0 4
58043: ARRAY
58044: IN
58045: IFFALSE 58375
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
58047: LD_EXP 121
58051: PUSH
58052: LD_VAR 0 4
58056: ARRAY
58057: PUSH
58058: LD_EXP 110
58062: PUSH
58063: LD_VAR 0 4
58067: ARRAY
58068: LESS
58069: PUSH
58070: LD_VAR 0 1
58074: PPUSH
58075: CALL_OW 264
58079: PUSH
58080: LD_INT 31
58082: PUSH
58083: LD_INT 32
58085: PUSH
58086: LD_INT 51
58088: PUSH
58089: LD_EXP 93
58093: PUSH
58094: LD_INT 12
58096: PUSH
58097: LD_INT 30
58099: PUSH
58100: LD_EXP 92
58104: PUSH
58105: LD_INT 11
58107: PUSH
58108: LD_INT 53
58110: PUSH
58111: LD_INT 14
58113: PUSH
58114: LD_EXP 96
58118: PUSH
58119: LD_INT 29
58121: PUSH
58122: LD_EXP 94
58126: PUSH
58127: LD_INT 13
58129: PUSH
58130: LD_INT 52
58132: PUSH
58133: LD_INT 48
58135: PUSH
58136: LD_INT 8
58138: PUSH
58139: EMPTY
58140: LIST
58141: LIST
58142: LIST
58143: LIST
58144: LIST
58145: LIST
58146: LIST
58147: LIST
58148: LIST
58149: LIST
58150: LIST
58151: LIST
58152: LIST
58153: LIST
58154: LIST
58155: LIST
58156: LIST
58157: IN
58158: NOT
58159: AND
58160: IFFALSE 58201
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
58162: LD_ADDR_EXP 121
58166: PUSH
58167: LD_EXP 121
58171: PPUSH
58172: LD_VAR 0 4
58176: PPUSH
58177: LD_EXP 121
58181: PUSH
58182: LD_VAR 0 4
58186: ARRAY
58187: PUSH
58188: LD_VAR 0 1
58192: ADD
58193: PPUSH
58194: CALL_OW 1
58198: ST_TO_ADDR
58199: GO 58245
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
58201: LD_ADDR_EXP 118
58205: PUSH
58206: LD_EXP 118
58210: PPUSH
58211: LD_VAR 0 4
58215: PUSH
58216: LD_EXP 118
58220: PUSH
58221: LD_VAR 0 4
58225: ARRAY
58226: PUSH
58227: LD_INT 1
58229: PLUS
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PPUSH
58235: LD_VAR 0 1
58239: PPUSH
58240: CALL 68420 0 3
58244: ST_TO_ADDR
// if not mc_scan [ i ] then
58245: LD_EXP 122
58249: PUSH
58250: LD_VAR 0 4
58254: ARRAY
58255: NOT
58256: IFFALSE 58375
// begin if GetControl ( vehicle ) = control_remote then
58258: LD_VAR 0 1
58262: PPUSH
58263: CALL_OW 263
58267: PUSH
58268: LD_INT 2
58270: EQUAL
58271: IFFALSE 58291
// repeat wait ( 0 0$1 ) ;
58273: LD_INT 35
58275: PPUSH
58276: CALL_OW 67
// until IsControledBy ( vehicle ) ;
58280: LD_VAR 0 1
58284: PPUSH
58285: CALL_OW 312
58289: IFFALSE 58273
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
58291: LD_VAR 0 1
58295: PPUSH
58296: LD_EXP 123
58300: PUSH
58301: LD_VAR 0 4
58305: ARRAY
58306: PPUSH
58307: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
58311: LD_VAR 0 1
58315: PPUSH
58316: CALL_OW 263
58320: PUSH
58321: LD_INT 1
58323: NONEQUAL
58324: IFFALSE 58328
// break ;
58326: GO 58377
// repeat wait ( 0 0$1 ) ;
58328: LD_INT 35
58330: PPUSH
58331: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
58335: LD_VAR 0 1
58339: PPUSH
58340: LD_EXP 123
58344: PUSH
58345: LD_VAR 0 4
58349: ARRAY
58350: PPUSH
58351: CALL_OW 308
58355: IFFALSE 58328
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
58357: LD_VAR 0 1
58361: PPUSH
58362: CALL_OW 311
58366: PPUSH
58367: CALL_OW 121
// exit ;
58371: POP
58372: POP
58373: GO 58379
// end ; end ; end ;
58375: GO 58026
58377: POP
58378: POP
// end ;
58379: LD_VAR 0 3
58383: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
58384: LD_INT 0
58386: PPUSH
58387: PPUSH
58388: PPUSH
58389: PPUSH
// if not mc_bases or not skirmish then
58390: LD_EXP 99
58394: NOT
58395: PUSH
58396: LD_EXP 97
58400: NOT
58401: OR
58402: IFFALSE 58406
// exit ;
58404: GO 58759
// repeat wait ( 0 0$1 ) ;
58406: LD_INT 35
58408: PPUSH
58409: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
58413: LD_VAR 0 2
58417: PPUSH
58418: LD_VAR 0 3
58422: PPUSH
58423: CALL_OW 284
58427: IFFALSE 58406
// if GetResourceTypeXY ( x , y ) = mat_artefact then
58429: LD_VAR 0 2
58433: PPUSH
58434: LD_VAR 0 3
58438: PPUSH
58439: CALL_OW 283
58443: PUSH
58444: LD_INT 4
58446: EQUAL
58447: IFFALSE 58451
// exit ;
58449: GO 58759
// for i = 1 to mc_bases do
58451: LD_ADDR_VAR 0 7
58455: PUSH
58456: DOUBLE
58457: LD_INT 1
58459: DEC
58460: ST_TO_ADDR
58461: LD_EXP 99
58465: PUSH
58466: FOR_TO
58467: IFFALSE 58757
// begin if mc_crates_area [ i ] then
58469: LD_EXP 117
58473: PUSH
58474: LD_VAR 0 7
58478: ARRAY
58479: IFFALSE 58590
// for j in mc_crates_area [ i ] do
58481: LD_ADDR_VAR 0 8
58485: PUSH
58486: LD_EXP 117
58490: PUSH
58491: LD_VAR 0 7
58495: ARRAY
58496: PUSH
58497: FOR_IN
58498: IFFALSE 58588
// if InArea ( x , y , j ) then
58500: LD_VAR 0 2
58504: PPUSH
58505: LD_VAR 0 3
58509: PPUSH
58510: LD_VAR 0 8
58514: PPUSH
58515: CALL_OW 309
58519: IFFALSE 58586
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58521: LD_ADDR_EXP 115
58525: PUSH
58526: LD_EXP 115
58530: PPUSH
58531: LD_VAR 0 7
58535: PUSH
58536: LD_EXP 115
58540: PUSH
58541: LD_VAR 0 7
58545: ARRAY
58546: PUSH
58547: LD_INT 1
58549: PLUS
58550: PUSH
58551: EMPTY
58552: LIST
58553: LIST
58554: PPUSH
58555: LD_VAR 0 4
58559: PUSH
58560: LD_VAR 0 2
58564: PUSH
58565: LD_VAR 0 3
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: LIST
58574: PPUSH
58575: CALL 68420 0 3
58579: ST_TO_ADDR
// exit ;
58580: POP
58581: POP
58582: POP
58583: POP
58584: GO 58759
// end ;
58586: GO 58497
58588: POP
58589: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58590: LD_ADDR_VAR 0 9
58594: PUSH
58595: LD_EXP 99
58599: PUSH
58600: LD_VAR 0 7
58604: ARRAY
58605: PPUSH
58606: LD_INT 2
58608: PUSH
58609: LD_INT 30
58611: PUSH
58612: LD_INT 0
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: PUSH
58619: LD_INT 30
58621: PUSH
58622: LD_INT 1
58624: PUSH
58625: EMPTY
58626: LIST
58627: LIST
58628: PUSH
58629: EMPTY
58630: LIST
58631: LIST
58632: LIST
58633: PPUSH
58634: CALL_OW 72
58638: ST_TO_ADDR
// if not depot then
58639: LD_VAR 0 9
58643: NOT
58644: IFFALSE 58648
// continue ;
58646: GO 58466
// for j in depot do
58648: LD_ADDR_VAR 0 8
58652: PUSH
58653: LD_VAR 0 9
58657: PUSH
58658: FOR_IN
58659: IFFALSE 58753
// if GetDistUnitXY ( j , x , y ) < 30 then
58661: LD_VAR 0 8
58665: PPUSH
58666: LD_VAR 0 2
58670: PPUSH
58671: LD_VAR 0 3
58675: PPUSH
58676: CALL_OW 297
58680: PUSH
58681: LD_INT 30
58683: LESS
58684: IFFALSE 58751
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58686: LD_ADDR_EXP 115
58690: PUSH
58691: LD_EXP 115
58695: PPUSH
58696: LD_VAR 0 7
58700: PUSH
58701: LD_EXP 115
58705: PUSH
58706: LD_VAR 0 7
58710: ARRAY
58711: PUSH
58712: LD_INT 1
58714: PLUS
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: PPUSH
58720: LD_VAR 0 4
58724: PUSH
58725: LD_VAR 0 2
58729: PUSH
58730: LD_VAR 0 3
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: LIST
58739: PPUSH
58740: CALL 68420 0 3
58744: ST_TO_ADDR
// exit ;
58745: POP
58746: POP
58747: POP
58748: POP
58749: GO 58759
// end ;
58751: GO 58658
58753: POP
58754: POP
// end ;
58755: GO 58466
58757: POP
58758: POP
// end ;
58759: LD_VAR 0 6
58763: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
58764: LD_INT 0
58766: PPUSH
58767: PPUSH
58768: PPUSH
58769: PPUSH
// if not mc_bases or not skirmish then
58770: LD_EXP 99
58774: NOT
58775: PUSH
58776: LD_EXP 97
58780: NOT
58781: OR
58782: IFFALSE 58786
// exit ;
58784: GO 59063
// side := GetSide ( lab ) ;
58786: LD_ADDR_VAR 0 4
58790: PUSH
58791: LD_VAR 0 2
58795: PPUSH
58796: CALL_OW 255
58800: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
58801: LD_VAR 0 4
58805: PUSH
58806: LD_EXP 125
58810: IN
58811: NOT
58812: PUSH
58813: LD_EXP 126
58817: NOT
58818: OR
58819: PUSH
58820: LD_EXP 99
58824: NOT
58825: OR
58826: IFFALSE 58830
// exit ;
58828: GO 59063
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
58830: LD_ADDR_EXP 126
58834: PUSH
58835: LD_EXP 126
58839: PPUSH
58840: LD_VAR 0 4
58844: PPUSH
58845: LD_EXP 126
58849: PUSH
58850: LD_VAR 0 4
58854: ARRAY
58855: PUSH
58856: LD_VAR 0 1
58860: DIFF
58861: PPUSH
58862: CALL_OW 1
58866: ST_TO_ADDR
// for i = 1 to mc_bases do
58867: LD_ADDR_VAR 0 5
58871: PUSH
58872: DOUBLE
58873: LD_INT 1
58875: DEC
58876: ST_TO_ADDR
58877: LD_EXP 99
58881: PUSH
58882: FOR_TO
58883: IFFALSE 59061
// begin if lab in mc_bases [ i ] then
58885: LD_VAR 0 2
58889: PUSH
58890: LD_EXP 99
58894: PUSH
58895: LD_VAR 0 5
58899: ARRAY
58900: IN
58901: IFFALSE 59059
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
58903: LD_VAR 0 1
58907: PUSH
58908: LD_INT 11
58910: PUSH
58911: LD_INT 4
58913: PUSH
58914: LD_INT 3
58916: PUSH
58917: LD_INT 2
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: LIST
58924: LIST
58925: IN
58926: PUSH
58927: LD_EXP 129
58931: PUSH
58932: LD_VAR 0 5
58936: ARRAY
58937: AND
58938: IFFALSE 59059
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
58940: LD_ADDR_VAR 0 6
58944: PUSH
58945: LD_EXP 129
58949: PUSH
58950: LD_VAR 0 5
58954: ARRAY
58955: PUSH
58956: LD_INT 1
58958: ARRAY
58959: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58960: LD_ADDR_EXP 129
58964: PUSH
58965: LD_EXP 129
58969: PPUSH
58970: LD_VAR 0 5
58974: PPUSH
58975: EMPTY
58976: PPUSH
58977: CALL_OW 1
58981: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
58982: LD_VAR 0 6
58986: PPUSH
58987: LD_INT 0
58989: PPUSH
58990: CALL_OW 109
// ComExitBuilding ( tmp ) ;
58994: LD_VAR 0 6
58998: PPUSH
58999: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
59003: LD_ADDR_EXP 128
59007: PUSH
59008: LD_EXP 128
59012: PPUSH
59013: LD_VAR 0 5
59017: PPUSH
59018: LD_EXP 128
59022: PUSH
59023: LD_VAR 0 5
59027: ARRAY
59028: PPUSH
59029: LD_INT 1
59031: PPUSH
59032: LD_VAR 0 6
59036: PPUSH
59037: CALL_OW 2
59041: PPUSH
59042: CALL_OW 1
59046: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
59047: LD_VAR 0 5
59051: PPUSH
59052: LD_INT 112
59054: PPUSH
59055: CALL 36532 0 2
// end ; end ; end ;
59059: GO 58882
59061: POP
59062: POP
// end ;
59063: LD_VAR 0 3
59067: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
59068: LD_INT 0
59070: PPUSH
59071: PPUSH
59072: PPUSH
59073: PPUSH
59074: PPUSH
59075: PPUSH
59076: PPUSH
59077: PPUSH
// if not mc_bases or not skirmish then
59078: LD_EXP 99
59082: NOT
59083: PUSH
59084: LD_EXP 97
59088: NOT
59089: OR
59090: IFFALSE 59094
// exit ;
59092: GO 60110
// for i = 1 to mc_bases do
59094: LD_ADDR_VAR 0 3
59098: PUSH
59099: DOUBLE
59100: LD_INT 1
59102: DEC
59103: ST_TO_ADDR
59104: LD_EXP 99
59108: PUSH
59109: FOR_TO
59110: IFFALSE 60108
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
59112: LD_VAR 0 1
59116: PUSH
59117: LD_EXP 99
59121: PUSH
59122: LD_VAR 0 3
59126: ARRAY
59127: IN
59128: PUSH
59129: LD_VAR 0 1
59133: PUSH
59134: LD_EXP 106
59138: PUSH
59139: LD_VAR 0 3
59143: ARRAY
59144: IN
59145: OR
59146: PUSH
59147: LD_VAR 0 1
59151: PUSH
59152: LD_EXP 118
59156: PUSH
59157: LD_VAR 0 3
59161: ARRAY
59162: IN
59163: OR
59164: PUSH
59165: LD_VAR 0 1
59169: PUSH
59170: LD_EXP 128
59174: PUSH
59175: LD_VAR 0 3
59179: ARRAY
59180: IN
59181: OR
59182: PUSH
59183: LD_VAR 0 1
59187: PUSH
59188: LD_EXP 129
59192: PUSH
59193: LD_VAR 0 3
59197: ARRAY
59198: IN
59199: OR
59200: IFFALSE 60106
// begin if un in mc_ape [ i ] then
59202: LD_VAR 0 1
59206: PUSH
59207: LD_EXP 128
59211: PUSH
59212: LD_VAR 0 3
59216: ARRAY
59217: IN
59218: IFFALSE 59257
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
59220: LD_ADDR_EXP 128
59224: PUSH
59225: LD_EXP 128
59229: PPUSH
59230: LD_VAR 0 3
59234: PPUSH
59235: LD_EXP 128
59239: PUSH
59240: LD_VAR 0 3
59244: ARRAY
59245: PUSH
59246: LD_VAR 0 1
59250: DIFF
59251: PPUSH
59252: CALL_OW 1
59256: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
59257: LD_VAR 0 1
59261: PUSH
59262: LD_EXP 129
59266: PUSH
59267: LD_VAR 0 3
59271: ARRAY
59272: IN
59273: IFFALSE 59297
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59275: LD_ADDR_EXP 129
59279: PUSH
59280: LD_EXP 129
59284: PPUSH
59285: LD_VAR 0 3
59289: PPUSH
59290: EMPTY
59291: PPUSH
59292: CALL_OW 1
59296: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
59297: LD_VAR 0 1
59301: PPUSH
59302: CALL_OW 247
59306: PUSH
59307: LD_INT 2
59309: EQUAL
59310: PUSH
59311: LD_VAR 0 1
59315: PPUSH
59316: CALL_OW 110
59320: PUSH
59321: LD_INT 20
59323: EQUAL
59324: PUSH
59325: LD_VAR 0 1
59329: PUSH
59330: LD_EXP 121
59334: PUSH
59335: LD_VAR 0 3
59339: ARRAY
59340: IN
59341: OR
59342: AND
59343: IFFALSE 59446
// begin fac := MC_GetBuilding ( i , b_factory ) ;
59345: LD_ADDR_VAR 0 8
59349: PUSH
59350: LD_VAR 0 3
59354: PPUSH
59355: LD_INT 3
59357: PPUSH
59358: CALL 56105 0 2
59362: ST_TO_ADDR
// if fac then
59363: LD_VAR 0 8
59367: IFFALSE 59446
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
59369: LD_ADDR_VAR 0 9
59373: PUSH
59374: LD_VAR 0 8
59378: PPUSH
59379: LD_VAR 0 1
59383: PPUSH
59384: CALL_OW 265
59388: PPUSH
59389: LD_VAR 0 1
59393: PPUSH
59394: CALL_OW 262
59398: PPUSH
59399: LD_VAR 0 1
59403: PPUSH
59404: CALL_OW 263
59408: PPUSH
59409: LD_VAR 0 1
59413: PPUSH
59414: CALL_OW 264
59418: PPUSH
59419: CALL 66020 0 5
59423: ST_TO_ADDR
// if components then
59424: LD_VAR 0 9
59428: IFFALSE 59444
// MC_InsertProduceList ( i , components ) ;
59430: LD_VAR 0 3
59434: PPUSH
59435: LD_VAR 0 9
59439: PPUSH
59440: CALL 55733 0 2
// break ;
59444: GO 60108
// end ; end ; if GetType ( un ) = unit_building then
59446: LD_VAR 0 1
59450: PPUSH
59451: CALL_OW 247
59455: PUSH
59456: LD_INT 3
59458: EQUAL
59459: IFFALSE 59774
// begin btype := GetBType ( un ) ;
59461: LD_ADDR_VAR 0 5
59465: PUSH
59466: LD_VAR 0 1
59470: PPUSH
59471: CALL_OW 266
59475: ST_TO_ADDR
// if btype = b_warehouse then
59476: LD_VAR 0 5
59480: PUSH
59481: LD_INT 1
59483: EQUAL
59484: IFFALSE 59502
// begin btype := b_depot ;
59486: LD_ADDR_VAR 0 5
59490: PUSH
59491: LD_INT 0
59493: ST_TO_ADDR
// pos := 1 ;
59494: LD_ADDR_VAR 0 6
59498: PUSH
59499: LD_INT 1
59501: ST_TO_ADDR
// end ; if btype = b_factory then
59502: LD_VAR 0 5
59506: PUSH
59507: LD_INT 3
59509: EQUAL
59510: IFFALSE 59528
// begin btype := b_workshop ;
59512: LD_ADDR_VAR 0 5
59516: PUSH
59517: LD_INT 2
59519: ST_TO_ADDR
// pos := 1 ;
59520: LD_ADDR_VAR 0 6
59524: PUSH
59525: LD_INT 1
59527: ST_TO_ADDR
// end ; if btype = b_barracks then
59528: LD_VAR 0 5
59532: PUSH
59533: LD_INT 5
59535: EQUAL
59536: IFFALSE 59546
// btype := b_armoury ;
59538: LD_ADDR_VAR 0 5
59542: PUSH
59543: LD_INT 4
59545: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
59546: LD_VAR 0 5
59550: PUSH
59551: LD_INT 7
59553: PUSH
59554: LD_INT 8
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: IN
59561: IFFALSE 59571
// btype := b_lab ;
59563: LD_ADDR_VAR 0 5
59567: PUSH
59568: LD_INT 6
59570: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
59571: LD_ADDR_EXP 104
59575: PUSH
59576: LD_EXP 104
59580: PPUSH
59581: LD_VAR 0 3
59585: PUSH
59586: LD_EXP 104
59590: PUSH
59591: LD_VAR 0 3
59595: ARRAY
59596: PUSH
59597: LD_INT 1
59599: PLUS
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: PPUSH
59605: LD_VAR 0 5
59609: PUSH
59610: LD_VAR 0 1
59614: PPUSH
59615: CALL_OW 250
59619: PUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: CALL_OW 251
59629: PUSH
59630: LD_VAR 0 1
59634: PPUSH
59635: CALL_OW 254
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: LIST
59644: LIST
59645: PPUSH
59646: CALL 68420 0 3
59650: ST_TO_ADDR
// if pos = 1 then
59651: LD_VAR 0 6
59655: PUSH
59656: LD_INT 1
59658: EQUAL
59659: IFFALSE 59774
// begin tmp := mc_build_list [ i ] ;
59661: LD_ADDR_VAR 0 7
59665: PUSH
59666: LD_EXP 104
59670: PUSH
59671: LD_VAR 0 3
59675: ARRAY
59676: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59677: LD_VAR 0 7
59681: PPUSH
59682: LD_INT 2
59684: PUSH
59685: LD_INT 30
59687: PUSH
59688: LD_INT 0
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PUSH
59695: LD_INT 30
59697: PUSH
59698: LD_INT 1
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: LIST
59709: PPUSH
59710: CALL_OW 72
59714: IFFALSE 59724
// pos := 2 ;
59716: LD_ADDR_VAR 0 6
59720: PUSH
59721: LD_INT 2
59723: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
59724: LD_ADDR_VAR 0 7
59728: PUSH
59729: LD_VAR 0 7
59733: PPUSH
59734: LD_VAR 0 6
59738: PPUSH
59739: LD_VAR 0 7
59743: PPUSH
59744: CALL 68746 0 3
59748: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
59749: LD_ADDR_EXP 104
59753: PUSH
59754: LD_EXP 104
59758: PPUSH
59759: LD_VAR 0 3
59763: PPUSH
59764: LD_VAR 0 7
59768: PPUSH
59769: CALL_OW 1
59773: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
59774: LD_VAR 0 1
59778: PUSH
59779: LD_EXP 99
59783: PUSH
59784: LD_VAR 0 3
59788: ARRAY
59789: IN
59790: IFFALSE 59829
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
59792: LD_ADDR_EXP 99
59796: PUSH
59797: LD_EXP 99
59801: PPUSH
59802: LD_VAR 0 3
59806: PPUSH
59807: LD_EXP 99
59811: PUSH
59812: LD_VAR 0 3
59816: ARRAY
59817: PUSH
59818: LD_VAR 0 1
59822: DIFF
59823: PPUSH
59824: CALL_OW 1
59828: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
59829: LD_VAR 0 1
59833: PUSH
59834: LD_EXP 106
59838: PUSH
59839: LD_VAR 0 3
59843: ARRAY
59844: IN
59845: IFFALSE 59884
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
59847: LD_ADDR_EXP 106
59851: PUSH
59852: LD_EXP 106
59856: PPUSH
59857: LD_VAR 0 3
59861: PPUSH
59862: LD_EXP 106
59866: PUSH
59867: LD_VAR 0 3
59871: ARRAY
59872: PUSH
59873: LD_VAR 0 1
59877: DIFF
59878: PPUSH
59879: CALL_OW 1
59883: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
59884: LD_VAR 0 1
59888: PUSH
59889: LD_EXP 118
59893: PUSH
59894: LD_VAR 0 3
59898: ARRAY
59899: IN
59900: IFFALSE 59939
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
59902: LD_ADDR_EXP 118
59906: PUSH
59907: LD_EXP 118
59911: PPUSH
59912: LD_VAR 0 3
59916: PPUSH
59917: LD_EXP 118
59921: PUSH
59922: LD_VAR 0 3
59926: ARRAY
59927: PUSH
59928: LD_VAR 0 1
59932: DIFF
59933: PPUSH
59934: CALL_OW 1
59938: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
59939: LD_VAR 0 1
59943: PUSH
59944: LD_EXP 121
59948: PUSH
59949: LD_VAR 0 3
59953: ARRAY
59954: IN
59955: IFFALSE 59994
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
59957: LD_ADDR_EXP 121
59961: PUSH
59962: LD_EXP 121
59966: PPUSH
59967: LD_VAR 0 3
59971: PPUSH
59972: LD_EXP 121
59976: PUSH
59977: LD_VAR 0 3
59981: ARRAY
59982: PUSH
59983: LD_VAR 0 1
59987: DIFF
59988: PPUSH
59989: CALL_OW 1
59993: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
59994: LD_VAR 0 1
59998: PUSH
59999: LD_EXP 108
60003: PUSH
60004: LD_VAR 0 3
60008: ARRAY
60009: IN
60010: IFFALSE 60049
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
60012: LD_ADDR_EXP 108
60016: PUSH
60017: LD_EXP 108
60021: PPUSH
60022: LD_VAR 0 3
60026: PPUSH
60027: LD_EXP 108
60031: PUSH
60032: LD_VAR 0 3
60036: ARRAY
60037: PUSH
60038: LD_VAR 0 1
60042: DIFF
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
60049: LD_VAR 0 1
60053: PUSH
60054: LD_EXP 107
60058: PUSH
60059: LD_VAR 0 3
60063: ARRAY
60064: IN
60065: IFFALSE 60104
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
60067: LD_ADDR_EXP 107
60071: PUSH
60072: LD_EXP 107
60076: PPUSH
60077: LD_VAR 0 3
60081: PPUSH
60082: LD_EXP 107
60086: PUSH
60087: LD_VAR 0 3
60091: ARRAY
60092: PUSH
60093: LD_VAR 0 1
60097: DIFF
60098: PPUSH
60099: CALL_OW 1
60103: ST_TO_ADDR
// end ; break ;
60104: GO 60108
// end ;
60106: GO 59109
60108: POP
60109: POP
// end ;
60110: LD_VAR 0 2
60114: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
60115: LD_INT 0
60117: PPUSH
60118: PPUSH
60119: PPUSH
// if not mc_bases or not skirmish then
60120: LD_EXP 99
60124: NOT
60125: PUSH
60126: LD_EXP 97
60130: NOT
60131: OR
60132: IFFALSE 60136
// exit ;
60134: GO 60351
// for i = 1 to mc_bases do
60136: LD_ADDR_VAR 0 3
60140: PUSH
60141: DOUBLE
60142: LD_INT 1
60144: DEC
60145: ST_TO_ADDR
60146: LD_EXP 99
60150: PUSH
60151: FOR_TO
60152: IFFALSE 60349
// begin if building in mc_construct_list [ i ] then
60154: LD_VAR 0 1
60158: PUSH
60159: LD_EXP 106
60163: PUSH
60164: LD_VAR 0 3
60168: ARRAY
60169: IN
60170: IFFALSE 60347
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
60172: LD_ADDR_EXP 106
60176: PUSH
60177: LD_EXP 106
60181: PPUSH
60182: LD_VAR 0 3
60186: PPUSH
60187: LD_EXP 106
60191: PUSH
60192: LD_VAR 0 3
60196: ARRAY
60197: PUSH
60198: LD_VAR 0 1
60202: DIFF
60203: PPUSH
60204: CALL_OW 1
60208: ST_TO_ADDR
// if building in mc_lab [ i ] then
60209: LD_VAR 0 1
60213: PUSH
60214: LD_EXP 132
60218: PUSH
60219: LD_VAR 0 3
60223: ARRAY
60224: IN
60225: IFFALSE 60280
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
60227: LD_ADDR_EXP 133
60231: PUSH
60232: LD_EXP 133
60236: PPUSH
60237: LD_VAR 0 3
60241: PPUSH
60242: LD_EXP 133
60246: PUSH
60247: LD_VAR 0 3
60251: ARRAY
60252: PPUSH
60253: LD_INT 1
60255: PPUSH
60256: LD_EXP 133
60260: PUSH
60261: LD_VAR 0 3
60265: ARRAY
60266: PPUSH
60267: LD_INT 0
60269: PPUSH
60270: CALL 67838 0 4
60274: PPUSH
60275: CALL_OW 1
60279: ST_TO_ADDR
// if not building in mc_bases [ i ] then
60280: LD_VAR 0 1
60284: PUSH
60285: LD_EXP 99
60289: PUSH
60290: LD_VAR 0 3
60294: ARRAY
60295: IN
60296: NOT
60297: IFFALSE 60343
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
60299: LD_ADDR_EXP 99
60303: PUSH
60304: LD_EXP 99
60308: PPUSH
60309: LD_VAR 0 3
60313: PUSH
60314: LD_EXP 99
60318: PUSH
60319: LD_VAR 0 3
60323: ARRAY
60324: PUSH
60325: LD_INT 1
60327: PLUS
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: PPUSH
60333: LD_VAR 0 1
60337: PPUSH
60338: CALL 68420 0 3
60342: ST_TO_ADDR
// exit ;
60343: POP
60344: POP
60345: GO 60351
// end ; end ;
60347: GO 60151
60349: POP
60350: POP
// end ;
60351: LD_VAR 0 2
60355: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
60356: LD_INT 0
60358: PPUSH
60359: PPUSH
60360: PPUSH
60361: PPUSH
60362: PPUSH
60363: PPUSH
60364: PPUSH
// if not mc_bases or not skirmish then
60365: LD_EXP 99
60369: NOT
60370: PUSH
60371: LD_EXP 97
60375: NOT
60376: OR
60377: IFFALSE 60381
// exit ;
60379: GO 61042
// for i = 1 to mc_bases do
60381: LD_ADDR_VAR 0 3
60385: PUSH
60386: DOUBLE
60387: LD_INT 1
60389: DEC
60390: ST_TO_ADDR
60391: LD_EXP 99
60395: PUSH
60396: FOR_TO
60397: IFFALSE 61040
// begin if building in mc_construct_list [ i ] then
60399: LD_VAR 0 1
60403: PUSH
60404: LD_EXP 106
60408: PUSH
60409: LD_VAR 0 3
60413: ARRAY
60414: IN
60415: IFFALSE 61038
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
60417: LD_ADDR_EXP 106
60421: PUSH
60422: LD_EXP 106
60426: PPUSH
60427: LD_VAR 0 3
60431: PPUSH
60432: LD_EXP 106
60436: PUSH
60437: LD_VAR 0 3
60441: ARRAY
60442: PUSH
60443: LD_VAR 0 1
60447: DIFF
60448: PPUSH
60449: CALL_OW 1
60453: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
60454: LD_ADDR_EXP 99
60458: PUSH
60459: LD_EXP 99
60463: PPUSH
60464: LD_VAR 0 3
60468: PUSH
60469: LD_EXP 99
60473: PUSH
60474: LD_VAR 0 3
60478: ARRAY
60479: PUSH
60480: LD_INT 1
60482: PLUS
60483: PUSH
60484: EMPTY
60485: LIST
60486: LIST
60487: PPUSH
60488: LD_VAR 0 1
60492: PPUSH
60493: CALL 68420 0 3
60497: ST_TO_ADDR
// btype := GetBType ( building ) ;
60498: LD_ADDR_VAR 0 5
60502: PUSH
60503: LD_VAR 0 1
60507: PPUSH
60508: CALL_OW 266
60512: ST_TO_ADDR
// side := GetSide ( building ) ;
60513: LD_ADDR_VAR 0 8
60517: PUSH
60518: LD_VAR 0 1
60522: PPUSH
60523: CALL_OW 255
60527: ST_TO_ADDR
// if btype = b_lab then
60528: LD_VAR 0 5
60532: PUSH
60533: LD_INT 6
60535: EQUAL
60536: IFFALSE 60586
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
60538: LD_ADDR_EXP 132
60542: PUSH
60543: LD_EXP 132
60547: PPUSH
60548: LD_VAR 0 3
60552: PUSH
60553: LD_EXP 132
60557: PUSH
60558: LD_VAR 0 3
60562: ARRAY
60563: PUSH
60564: LD_INT 1
60566: PLUS
60567: PUSH
60568: EMPTY
60569: LIST
60570: LIST
60571: PPUSH
60572: LD_VAR 0 1
60576: PPUSH
60577: CALL 68420 0 3
60581: ST_TO_ADDR
// exit ;
60582: POP
60583: POP
60584: GO 61042
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
60586: LD_VAR 0 5
60590: PUSH
60591: LD_INT 0
60593: PUSH
60594: LD_INT 2
60596: PUSH
60597: LD_INT 4
60599: PUSH
60600: EMPTY
60601: LIST
60602: LIST
60603: LIST
60604: IN
60605: IFFALSE 60729
// begin if btype = b_armoury then
60607: LD_VAR 0 5
60611: PUSH
60612: LD_INT 4
60614: EQUAL
60615: IFFALSE 60625
// btype := b_barracks ;
60617: LD_ADDR_VAR 0 5
60621: PUSH
60622: LD_INT 5
60624: ST_TO_ADDR
// if btype = b_depot then
60625: LD_VAR 0 5
60629: PUSH
60630: LD_INT 0
60632: EQUAL
60633: IFFALSE 60643
// btype := b_warehouse ;
60635: LD_ADDR_VAR 0 5
60639: PUSH
60640: LD_INT 1
60642: ST_TO_ADDR
// if btype = b_workshop then
60643: LD_VAR 0 5
60647: PUSH
60648: LD_INT 2
60650: EQUAL
60651: IFFALSE 60661
// btype := b_factory ;
60653: LD_ADDR_VAR 0 5
60657: PUSH
60658: LD_INT 3
60660: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
60661: LD_VAR 0 5
60665: PPUSH
60666: LD_VAR 0 8
60670: PPUSH
60671: CALL_OW 323
60675: PUSH
60676: LD_INT 1
60678: EQUAL
60679: IFFALSE 60725
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
60681: LD_ADDR_EXP 131
60685: PUSH
60686: LD_EXP 131
60690: PPUSH
60691: LD_VAR 0 3
60695: PUSH
60696: LD_EXP 131
60700: PUSH
60701: LD_VAR 0 3
60705: ARRAY
60706: PUSH
60707: LD_INT 1
60709: PLUS
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: PPUSH
60715: LD_VAR 0 1
60719: PPUSH
60720: CALL 68420 0 3
60724: ST_TO_ADDR
// exit ;
60725: POP
60726: POP
60727: GO 61042
// end ; if btype in [ b_bunker , b_turret ] then
60729: LD_VAR 0 5
60733: PUSH
60734: LD_INT 32
60736: PUSH
60737: LD_INT 33
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: IN
60744: IFFALSE 61034
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
60746: LD_ADDR_EXP 107
60750: PUSH
60751: LD_EXP 107
60755: PPUSH
60756: LD_VAR 0 3
60760: PUSH
60761: LD_EXP 107
60765: PUSH
60766: LD_VAR 0 3
60770: ARRAY
60771: PUSH
60772: LD_INT 1
60774: PLUS
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PPUSH
60780: LD_VAR 0 1
60784: PPUSH
60785: CALL 68420 0 3
60789: ST_TO_ADDR
// if btype = b_bunker then
60790: LD_VAR 0 5
60794: PUSH
60795: LD_INT 32
60797: EQUAL
60798: IFFALSE 61034
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
60800: LD_ADDR_EXP 108
60804: PUSH
60805: LD_EXP 108
60809: PPUSH
60810: LD_VAR 0 3
60814: PUSH
60815: LD_EXP 108
60819: PUSH
60820: LD_VAR 0 3
60824: ARRAY
60825: PUSH
60826: LD_INT 1
60828: PLUS
60829: PUSH
60830: EMPTY
60831: LIST
60832: LIST
60833: PPUSH
60834: LD_VAR 0 1
60838: PPUSH
60839: CALL 68420 0 3
60843: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
60844: LD_ADDR_VAR 0 6
60848: PUSH
60849: LD_EXP 99
60853: PUSH
60854: LD_VAR 0 3
60858: ARRAY
60859: PPUSH
60860: LD_INT 25
60862: PUSH
60863: LD_INT 1
60865: PUSH
60866: EMPTY
60867: LIST
60868: LIST
60869: PUSH
60870: LD_INT 3
60872: PUSH
60873: LD_INT 54
60875: PUSH
60876: EMPTY
60877: LIST
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: PPUSH
60887: CALL_OW 72
60891: ST_TO_ADDR
// if tmp then
60892: LD_VAR 0 6
60896: IFFALSE 60902
// exit ;
60898: POP
60899: POP
60900: GO 61042
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60902: LD_ADDR_VAR 0 6
60906: PUSH
60907: LD_EXP 99
60911: PUSH
60912: LD_VAR 0 3
60916: ARRAY
60917: PPUSH
60918: LD_INT 2
60920: PUSH
60921: LD_INT 30
60923: PUSH
60924: LD_INT 4
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: PUSH
60931: LD_INT 30
60933: PUSH
60934: LD_INT 5
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: LIST
60945: PPUSH
60946: CALL_OW 72
60950: ST_TO_ADDR
// if not tmp then
60951: LD_VAR 0 6
60955: NOT
60956: IFFALSE 60962
// exit ;
60958: POP
60959: POP
60960: GO 61042
// for j in tmp do
60962: LD_ADDR_VAR 0 4
60966: PUSH
60967: LD_VAR 0 6
60971: PUSH
60972: FOR_IN
60973: IFFALSE 61032
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
60975: LD_ADDR_VAR 0 7
60979: PUSH
60980: LD_VAR 0 4
60984: PPUSH
60985: CALL_OW 313
60989: PPUSH
60990: LD_INT 25
60992: PUSH
60993: LD_INT 1
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: PPUSH
61000: CALL_OW 72
61004: ST_TO_ADDR
// if units then
61005: LD_VAR 0 7
61009: IFFALSE 61030
// begin ComExitBuilding ( units [ 1 ] ) ;
61011: LD_VAR 0 7
61015: PUSH
61016: LD_INT 1
61018: ARRAY
61019: PPUSH
61020: CALL_OW 122
// exit ;
61024: POP
61025: POP
61026: POP
61027: POP
61028: GO 61042
// end ; end ;
61030: GO 60972
61032: POP
61033: POP
// end ; end ; exit ;
61034: POP
61035: POP
61036: GO 61042
// end ; end ;
61038: GO 60396
61040: POP
61041: POP
// end ;
61042: LD_VAR 0 2
61046: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
61047: LD_INT 0
61049: PPUSH
61050: PPUSH
61051: PPUSH
61052: PPUSH
61053: PPUSH
61054: PPUSH
61055: PPUSH
// if not mc_bases or not skirmish then
61056: LD_EXP 99
61060: NOT
61061: PUSH
61062: LD_EXP 97
61066: NOT
61067: OR
61068: IFFALSE 61072
// exit ;
61070: GO 61303
// btype := GetBType ( building ) ;
61072: LD_ADDR_VAR 0 6
61076: PUSH
61077: LD_VAR 0 1
61081: PPUSH
61082: CALL_OW 266
61086: ST_TO_ADDR
// x := GetX ( building ) ;
61087: LD_ADDR_VAR 0 7
61091: PUSH
61092: LD_VAR 0 1
61096: PPUSH
61097: CALL_OW 250
61101: ST_TO_ADDR
// y := GetY ( building ) ;
61102: LD_ADDR_VAR 0 8
61106: PUSH
61107: LD_VAR 0 1
61111: PPUSH
61112: CALL_OW 251
61116: ST_TO_ADDR
// d := GetDir ( building ) ;
61117: LD_ADDR_VAR 0 9
61121: PUSH
61122: LD_VAR 0 1
61126: PPUSH
61127: CALL_OW 254
61131: ST_TO_ADDR
// for i = 1 to mc_bases do
61132: LD_ADDR_VAR 0 4
61136: PUSH
61137: DOUBLE
61138: LD_INT 1
61140: DEC
61141: ST_TO_ADDR
61142: LD_EXP 99
61146: PUSH
61147: FOR_TO
61148: IFFALSE 61301
// begin if not mc_build_list [ i ] then
61150: LD_EXP 104
61154: PUSH
61155: LD_VAR 0 4
61159: ARRAY
61160: NOT
61161: IFFALSE 61165
// continue ;
61163: GO 61147
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
61165: LD_VAR 0 6
61169: PUSH
61170: LD_VAR 0 7
61174: PUSH
61175: LD_VAR 0 8
61179: PUSH
61180: LD_VAR 0 9
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: LIST
61189: LIST
61190: PPUSH
61191: LD_EXP 104
61195: PUSH
61196: LD_VAR 0 4
61200: ARRAY
61201: PUSH
61202: LD_INT 1
61204: ARRAY
61205: PPUSH
61206: CALL 74589 0 2
61210: IFFALSE 61299
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
61212: LD_ADDR_EXP 104
61216: PUSH
61217: LD_EXP 104
61221: PPUSH
61222: LD_VAR 0 4
61226: PPUSH
61227: LD_EXP 104
61231: PUSH
61232: LD_VAR 0 4
61236: ARRAY
61237: PPUSH
61238: LD_INT 1
61240: PPUSH
61241: CALL_OW 3
61245: PPUSH
61246: CALL_OW 1
61250: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
61251: LD_ADDR_EXP 106
61255: PUSH
61256: LD_EXP 106
61260: PPUSH
61261: LD_VAR 0 4
61265: PUSH
61266: LD_EXP 106
61270: PUSH
61271: LD_VAR 0 4
61275: ARRAY
61276: PUSH
61277: LD_INT 1
61279: PLUS
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: PPUSH
61285: LD_VAR 0 1
61289: PPUSH
61290: CALL 68420 0 3
61294: ST_TO_ADDR
// exit ;
61295: POP
61296: POP
61297: GO 61303
// end ; end ;
61299: GO 61147
61301: POP
61302: POP
// end ;
61303: LD_VAR 0 3
61307: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
61308: LD_INT 0
61310: PPUSH
61311: PPUSH
61312: PPUSH
// if not mc_bases or not skirmish then
61313: LD_EXP 99
61317: NOT
61318: PUSH
61319: LD_EXP 97
61323: NOT
61324: OR
61325: IFFALSE 61329
// exit ;
61327: GO 61519
// for i = 1 to mc_bases do
61329: LD_ADDR_VAR 0 4
61333: PUSH
61334: DOUBLE
61335: LD_INT 1
61337: DEC
61338: ST_TO_ADDR
61339: LD_EXP 99
61343: PUSH
61344: FOR_TO
61345: IFFALSE 61432
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
61347: LD_VAR 0 1
61351: PUSH
61352: LD_EXP 107
61356: PUSH
61357: LD_VAR 0 4
61361: ARRAY
61362: IN
61363: PUSH
61364: LD_VAR 0 1
61368: PUSH
61369: LD_EXP 108
61373: PUSH
61374: LD_VAR 0 4
61378: ARRAY
61379: IN
61380: NOT
61381: AND
61382: IFFALSE 61430
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
61384: LD_ADDR_EXP 108
61388: PUSH
61389: LD_EXP 108
61393: PPUSH
61394: LD_VAR 0 4
61398: PUSH
61399: LD_EXP 108
61403: PUSH
61404: LD_VAR 0 4
61408: ARRAY
61409: PUSH
61410: LD_INT 1
61412: PLUS
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PPUSH
61418: LD_VAR 0 1
61422: PPUSH
61423: CALL 68420 0 3
61427: ST_TO_ADDR
// break ;
61428: GO 61432
// end ; end ;
61430: GO 61344
61432: POP
61433: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
61434: LD_VAR 0 1
61438: PPUSH
61439: CALL_OW 257
61443: PUSH
61444: LD_EXP 125
61448: IN
61449: PUSH
61450: LD_VAR 0 1
61454: PPUSH
61455: CALL_OW 266
61459: PUSH
61460: LD_INT 5
61462: EQUAL
61463: AND
61464: PUSH
61465: LD_VAR 0 2
61469: PPUSH
61470: CALL_OW 110
61474: PUSH
61475: LD_INT 18
61477: NONEQUAL
61478: AND
61479: IFFALSE 61519
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
61481: LD_VAR 0 2
61485: PPUSH
61486: CALL_OW 257
61490: PUSH
61491: LD_INT 5
61493: PUSH
61494: LD_INT 8
61496: PUSH
61497: LD_INT 9
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: LIST
61504: IN
61505: IFFALSE 61519
// SetClass ( unit , 1 ) ;
61507: LD_VAR 0 2
61511: PPUSH
61512: LD_INT 1
61514: PPUSH
61515: CALL_OW 336
// end ;
61519: LD_VAR 0 3
61523: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
61524: LD_INT 0
61526: PPUSH
61527: PPUSH
// if not mc_bases or not skirmish then
61528: LD_EXP 99
61532: NOT
61533: PUSH
61534: LD_EXP 97
61538: NOT
61539: OR
61540: IFFALSE 61544
// exit ;
61542: GO 61660
// if GetLives ( abandoned_vehicle ) > 250 then
61544: LD_VAR 0 2
61548: PPUSH
61549: CALL_OW 256
61553: PUSH
61554: LD_INT 250
61556: GREATER
61557: IFFALSE 61561
// exit ;
61559: GO 61660
// for i = 1 to mc_bases do
61561: LD_ADDR_VAR 0 6
61565: PUSH
61566: DOUBLE
61567: LD_INT 1
61569: DEC
61570: ST_TO_ADDR
61571: LD_EXP 99
61575: PUSH
61576: FOR_TO
61577: IFFALSE 61658
// begin if driver in mc_bases [ i ] then
61579: LD_VAR 0 1
61583: PUSH
61584: LD_EXP 99
61588: PUSH
61589: LD_VAR 0 6
61593: ARRAY
61594: IN
61595: IFFALSE 61656
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
61597: LD_VAR 0 1
61601: PPUSH
61602: LD_EXP 99
61606: PUSH
61607: LD_VAR 0 6
61611: ARRAY
61612: PPUSH
61613: LD_INT 2
61615: PUSH
61616: LD_INT 30
61618: PUSH
61619: LD_INT 0
61621: PUSH
61622: EMPTY
61623: LIST
61624: LIST
61625: PUSH
61626: LD_INT 30
61628: PUSH
61629: LD_INT 1
61631: PUSH
61632: EMPTY
61633: LIST
61634: LIST
61635: PUSH
61636: EMPTY
61637: LIST
61638: LIST
61639: LIST
61640: PPUSH
61641: CALL_OW 72
61645: PUSH
61646: LD_INT 1
61648: ARRAY
61649: PPUSH
61650: CALL_OW 112
// break ;
61654: GO 61658
// end ; end ;
61656: GO 61576
61658: POP
61659: POP
// end ; end_of_file
61660: LD_VAR 0 5
61664: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
61665: LD_INT 0
61667: PPUSH
61668: PPUSH
// if exist_mode then
61669: LD_VAR 0 2
61673: IFFALSE 61698
// unit := CreateCharacter ( prefix & ident ) else
61675: LD_ADDR_VAR 0 5
61679: PUSH
61680: LD_VAR 0 3
61684: PUSH
61685: LD_VAR 0 1
61689: STR
61690: PPUSH
61691: CALL_OW 34
61695: ST_TO_ADDR
61696: GO 61713
// unit := NewCharacter ( ident ) ;
61698: LD_ADDR_VAR 0 5
61702: PUSH
61703: LD_VAR 0 1
61707: PPUSH
61708: CALL_OW 25
61712: ST_TO_ADDR
// result := unit ;
61713: LD_ADDR_VAR 0 4
61717: PUSH
61718: LD_VAR 0 5
61722: ST_TO_ADDR
// end ;
61723: LD_VAR 0 4
61727: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
61728: LD_INT 0
61730: PPUSH
61731: PPUSH
// if not side or not nation then
61732: LD_VAR 0 1
61736: NOT
61737: PUSH
61738: LD_VAR 0 2
61742: NOT
61743: OR
61744: IFFALSE 61748
// exit ;
61746: GO 62384
// case nation of nation_american :
61748: LD_VAR 0 2
61752: PUSH
61753: LD_INT 1
61755: DOUBLE
61756: EQUAL
61757: IFTRUE 61761
61759: GO 61931
61761: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
61762: LD_ADDR_VAR 0 4
61766: PUSH
61767: LD_INT 35
61769: PUSH
61770: LD_INT 45
61772: PUSH
61773: LD_INT 46
61775: PUSH
61776: LD_INT 47
61778: PUSH
61779: LD_INT 1
61781: PUSH
61782: LD_INT 2
61784: PUSH
61785: LD_INT 6
61787: PUSH
61788: LD_INT 15
61790: PUSH
61791: LD_INT 16
61793: PUSH
61794: LD_INT 7
61796: PUSH
61797: LD_INT 12
61799: PUSH
61800: LD_INT 13
61802: PUSH
61803: LD_INT 10
61805: PUSH
61806: LD_INT 14
61808: PUSH
61809: LD_INT 20
61811: PUSH
61812: LD_INT 21
61814: PUSH
61815: LD_INT 22
61817: PUSH
61818: LD_INT 25
61820: PUSH
61821: LD_INT 32
61823: PUSH
61824: LD_INT 27
61826: PUSH
61827: LD_INT 36
61829: PUSH
61830: LD_INT 69
61832: PUSH
61833: LD_INT 39
61835: PUSH
61836: LD_INT 34
61838: PUSH
61839: LD_INT 40
61841: PUSH
61842: LD_INT 48
61844: PUSH
61845: LD_INT 49
61847: PUSH
61848: LD_INT 50
61850: PUSH
61851: LD_INT 51
61853: PUSH
61854: LD_INT 52
61856: PUSH
61857: LD_INT 53
61859: PUSH
61860: LD_INT 54
61862: PUSH
61863: LD_INT 55
61865: PUSH
61866: LD_INT 56
61868: PUSH
61869: LD_INT 57
61871: PUSH
61872: LD_INT 58
61874: PUSH
61875: LD_INT 59
61877: PUSH
61878: LD_INT 60
61880: PUSH
61881: LD_INT 61
61883: PUSH
61884: LD_INT 62
61886: PUSH
61887: EMPTY
61888: LIST
61889: LIST
61890: LIST
61891: LIST
61892: LIST
61893: LIST
61894: LIST
61895: LIST
61896: LIST
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: LIST
61908: LIST
61909: LIST
61910: LIST
61911: LIST
61912: LIST
61913: LIST
61914: LIST
61915: LIST
61916: LIST
61917: LIST
61918: LIST
61919: LIST
61920: LIST
61921: LIST
61922: LIST
61923: LIST
61924: LIST
61925: LIST
61926: LIST
61927: LIST
61928: ST_TO_ADDR
61929: GO 62308
61931: LD_INT 2
61933: DOUBLE
61934: EQUAL
61935: IFTRUE 61939
61937: GO 62117
61939: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
61940: LD_ADDR_VAR 0 4
61944: PUSH
61945: LD_INT 35
61947: PUSH
61948: LD_INT 45
61950: PUSH
61951: LD_INT 46
61953: PUSH
61954: LD_INT 47
61956: PUSH
61957: LD_INT 70
61959: PUSH
61960: LD_INT 1
61962: PUSH
61963: LD_INT 11
61965: PUSH
61966: LD_INT 3
61968: PUSH
61969: LD_INT 4
61971: PUSH
61972: LD_INT 5
61974: PUSH
61975: LD_INT 6
61977: PUSH
61978: LD_INT 15
61980: PUSH
61981: LD_INT 18
61983: PUSH
61984: LD_INT 7
61986: PUSH
61987: LD_INT 17
61989: PUSH
61990: LD_INT 8
61992: PUSH
61993: LD_INT 20
61995: PUSH
61996: LD_INT 21
61998: PUSH
61999: LD_INT 22
62001: PUSH
62002: LD_INT 72
62004: PUSH
62005: LD_INT 26
62007: PUSH
62008: LD_INT 69
62010: PUSH
62011: LD_INT 39
62013: PUSH
62014: LD_INT 40
62016: PUSH
62017: LD_INT 41
62019: PUSH
62020: LD_INT 42
62022: PUSH
62023: LD_INT 43
62025: PUSH
62026: LD_INT 48
62028: PUSH
62029: LD_INT 49
62031: PUSH
62032: LD_INT 50
62034: PUSH
62035: LD_INT 51
62037: PUSH
62038: LD_INT 52
62040: PUSH
62041: LD_INT 53
62043: PUSH
62044: LD_INT 54
62046: PUSH
62047: LD_INT 55
62049: PUSH
62050: LD_INT 56
62052: PUSH
62053: LD_INT 60
62055: PUSH
62056: LD_INT 61
62058: PUSH
62059: LD_INT 62
62061: PUSH
62062: LD_INT 66
62064: PUSH
62065: LD_INT 67
62067: PUSH
62068: LD_INT 68
62070: PUSH
62071: EMPTY
62072: LIST
62073: LIST
62074: LIST
62075: LIST
62076: LIST
62077: LIST
62078: LIST
62079: LIST
62080: LIST
62081: LIST
62082: LIST
62083: LIST
62084: LIST
62085: LIST
62086: LIST
62087: LIST
62088: LIST
62089: LIST
62090: LIST
62091: LIST
62092: LIST
62093: LIST
62094: LIST
62095: LIST
62096: LIST
62097: LIST
62098: LIST
62099: LIST
62100: LIST
62101: LIST
62102: LIST
62103: LIST
62104: LIST
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: LIST
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: ST_TO_ADDR
62115: GO 62308
62117: LD_INT 3
62119: DOUBLE
62120: EQUAL
62121: IFTRUE 62125
62123: GO 62307
62125: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
62126: LD_ADDR_VAR 0 4
62130: PUSH
62131: LD_INT 46
62133: PUSH
62134: LD_INT 47
62136: PUSH
62137: LD_INT 1
62139: PUSH
62140: LD_INT 2
62142: PUSH
62143: LD_INT 11
62145: PUSH
62146: LD_INT 9
62148: PUSH
62149: LD_INT 20
62151: PUSH
62152: LD_INT 19
62154: PUSH
62155: LD_INT 21
62157: PUSH
62158: LD_INT 24
62160: PUSH
62161: LD_INT 22
62163: PUSH
62164: LD_INT 25
62166: PUSH
62167: LD_INT 28
62169: PUSH
62170: LD_INT 29
62172: PUSH
62173: LD_INT 30
62175: PUSH
62176: LD_INT 31
62178: PUSH
62179: LD_INT 37
62181: PUSH
62182: LD_INT 38
62184: PUSH
62185: LD_INT 32
62187: PUSH
62188: LD_INT 27
62190: PUSH
62191: LD_INT 33
62193: PUSH
62194: LD_INT 69
62196: PUSH
62197: LD_INT 39
62199: PUSH
62200: LD_INT 34
62202: PUSH
62203: LD_INT 40
62205: PUSH
62206: LD_INT 71
62208: PUSH
62209: LD_INT 23
62211: PUSH
62212: LD_INT 44
62214: PUSH
62215: LD_INT 48
62217: PUSH
62218: LD_INT 49
62220: PUSH
62221: LD_INT 50
62223: PUSH
62224: LD_INT 51
62226: PUSH
62227: LD_INT 52
62229: PUSH
62230: LD_INT 53
62232: PUSH
62233: LD_INT 54
62235: PUSH
62236: LD_INT 55
62238: PUSH
62239: LD_INT 56
62241: PUSH
62242: LD_INT 57
62244: PUSH
62245: LD_INT 58
62247: PUSH
62248: LD_INT 59
62250: PUSH
62251: LD_INT 63
62253: PUSH
62254: LD_INT 64
62256: PUSH
62257: LD_INT 65
62259: PUSH
62260: EMPTY
62261: LIST
62262: LIST
62263: LIST
62264: LIST
62265: LIST
62266: LIST
62267: LIST
62268: LIST
62269: LIST
62270: LIST
62271: LIST
62272: LIST
62273: LIST
62274: LIST
62275: LIST
62276: LIST
62277: LIST
62278: LIST
62279: LIST
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: LIST
62285: LIST
62286: LIST
62287: LIST
62288: LIST
62289: LIST
62290: LIST
62291: LIST
62292: LIST
62293: LIST
62294: LIST
62295: LIST
62296: LIST
62297: LIST
62298: LIST
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: ST_TO_ADDR
62305: GO 62308
62307: POP
// if state > - 1 and state < 3 then
62308: LD_VAR 0 3
62312: PUSH
62313: LD_INT 1
62315: NEG
62316: GREATER
62317: PUSH
62318: LD_VAR 0 3
62322: PUSH
62323: LD_INT 3
62325: LESS
62326: AND
62327: IFFALSE 62384
// for i in result do
62329: LD_ADDR_VAR 0 5
62333: PUSH
62334: LD_VAR 0 4
62338: PUSH
62339: FOR_IN
62340: IFFALSE 62382
// if GetTech ( i , side ) <> state then
62342: LD_VAR 0 5
62346: PPUSH
62347: LD_VAR 0 1
62351: PPUSH
62352: CALL_OW 321
62356: PUSH
62357: LD_VAR 0 3
62361: NONEQUAL
62362: IFFALSE 62380
// result := result diff i ;
62364: LD_ADDR_VAR 0 4
62368: PUSH
62369: LD_VAR 0 4
62373: PUSH
62374: LD_VAR 0 5
62378: DIFF
62379: ST_TO_ADDR
62380: GO 62339
62382: POP
62383: POP
// end ;
62384: LD_VAR 0 4
62388: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
62389: LD_INT 0
62391: PPUSH
62392: PPUSH
62393: PPUSH
// result := true ;
62394: LD_ADDR_VAR 0 3
62398: PUSH
62399: LD_INT 1
62401: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
62402: LD_ADDR_VAR 0 5
62406: PUSH
62407: LD_VAR 0 2
62411: PPUSH
62412: CALL_OW 480
62416: ST_TO_ADDR
// if not tmp then
62417: LD_VAR 0 5
62421: NOT
62422: IFFALSE 62426
// exit ;
62424: GO 62475
// for i in tmp do
62426: LD_ADDR_VAR 0 4
62430: PUSH
62431: LD_VAR 0 5
62435: PUSH
62436: FOR_IN
62437: IFFALSE 62473
// if GetTech ( i , side ) <> state_researched then
62439: LD_VAR 0 4
62443: PPUSH
62444: LD_VAR 0 1
62448: PPUSH
62449: CALL_OW 321
62453: PUSH
62454: LD_INT 2
62456: NONEQUAL
62457: IFFALSE 62471
// begin result := false ;
62459: LD_ADDR_VAR 0 3
62463: PUSH
62464: LD_INT 0
62466: ST_TO_ADDR
// exit ;
62467: POP
62468: POP
62469: GO 62475
// end ;
62471: GO 62436
62473: POP
62474: POP
// end ;
62475: LD_VAR 0 3
62479: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
62480: LD_INT 0
62482: PPUSH
62483: PPUSH
62484: PPUSH
62485: PPUSH
62486: PPUSH
62487: PPUSH
62488: PPUSH
62489: PPUSH
62490: PPUSH
62491: PPUSH
62492: PPUSH
62493: PPUSH
62494: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
62495: LD_VAR 0 1
62499: NOT
62500: PUSH
62501: LD_VAR 0 1
62505: PPUSH
62506: CALL_OW 257
62510: PUSH
62511: LD_INT 9
62513: NONEQUAL
62514: OR
62515: IFFALSE 62519
// exit ;
62517: GO 63092
// side := GetSide ( unit ) ;
62519: LD_ADDR_VAR 0 9
62523: PUSH
62524: LD_VAR 0 1
62528: PPUSH
62529: CALL_OW 255
62533: ST_TO_ADDR
// tech_space := tech_spacanom ;
62534: LD_ADDR_VAR 0 12
62538: PUSH
62539: LD_INT 29
62541: ST_TO_ADDR
// tech_time := tech_taurad ;
62542: LD_ADDR_VAR 0 13
62546: PUSH
62547: LD_INT 28
62549: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
62550: LD_ADDR_VAR 0 11
62554: PUSH
62555: LD_VAR 0 1
62559: PPUSH
62560: CALL_OW 310
62564: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
62565: LD_VAR 0 11
62569: PPUSH
62570: CALL_OW 247
62574: PUSH
62575: LD_INT 2
62577: EQUAL
62578: IFFALSE 62582
// exit ;
62580: GO 63092
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62582: LD_ADDR_VAR 0 8
62586: PUSH
62587: LD_INT 81
62589: PUSH
62590: LD_VAR 0 9
62594: PUSH
62595: EMPTY
62596: LIST
62597: LIST
62598: PUSH
62599: LD_INT 3
62601: PUSH
62602: LD_INT 21
62604: PUSH
62605: LD_INT 3
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PPUSH
62620: CALL_OW 69
62624: ST_TO_ADDR
// if not tmp then
62625: LD_VAR 0 8
62629: NOT
62630: IFFALSE 62634
// exit ;
62632: GO 63092
// if in_unit then
62634: LD_VAR 0 11
62638: IFFALSE 62662
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
62640: LD_ADDR_VAR 0 10
62644: PUSH
62645: LD_VAR 0 8
62649: PPUSH
62650: LD_VAR 0 11
62654: PPUSH
62655: CALL_OW 74
62659: ST_TO_ADDR
62660: GO 62682
// enemy := NearestUnitToUnit ( tmp , unit ) ;
62662: LD_ADDR_VAR 0 10
62666: PUSH
62667: LD_VAR 0 8
62671: PPUSH
62672: LD_VAR 0 1
62676: PPUSH
62677: CALL_OW 74
62681: ST_TO_ADDR
// if not enemy then
62682: LD_VAR 0 10
62686: NOT
62687: IFFALSE 62691
// exit ;
62689: GO 63092
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
62691: LD_VAR 0 11
62695: PUSH
62696: LD_VAR 0 11
62700: PPUSH
62701: LD_VAR 0 10
62705: PPUSH
62706: CALL_OW 296
62710: PUSH
62711: LD_INT 13
62713: GREATER
62714: AND
62715: PUSH
62716: LD_VAR 0 1
62720: PPUSH
62721: LD_VAR 0 10
62725: PPUSH
62726: CALL_OW 296
62730: PUSH
62731: LD_INT 12
62733: GREATER
62734: OR
62735: IFFALSE 62739
// exit ;
62737: GO 63092
// missile := [ 1 ] ;
62739: LD_ADDR_VAR 0 14
62743: PUSH
62744: LD_INT 1
62746: PUSH
62747: EMPTY
62748: LIST
62749: ST_TO_ADDR
// if Researched ( side , tech_space ) then
62750: LD_VAR 0 9
62754: PPUSH
62755: LD_VAR 0 12
62759: PPUSH
62760: CALL_OW 325
62764: IFFALSE 62793
// missile := Insert ( missile , missile + 1 , 2 ) ;
62766: LD_ADDR_VAR 0 14
62770: PUSH
62771: LD_VAR 0 14
62775: PPUSH
62776: LD_VAR 0 14
62780: PUSH
62781: LD_INT 1
62783: PLUS
62784: PPUSH
62785: LD_INT 2
62787: PPUSH
62788: CALL_OW 2
62792: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
62793: LD_VAR 0 9
62797: PPUSH
62798: LD_VAR 0 13
62802: PPUSH
62803: CALL_OW 325
62807: PUSH
62808: LD_VAR 0 10
62812: PPUSH
62813: CALL_OW 255
62817: PPUSH
62818: LD_VAR 0 13
62822: PPUSH
62823: CALL_OW 325
62827: NOT
62828: AND
62829: IFFALSE 62858
// missile := Insert ( missile , missile + 1 , 3 ) ;
62831: LD_ADDR_VAR 0 14
62835: PUSH
62836: LD_VAR 0 14
62840: PPUSH
62841: LD_VAR 0 14
62845: PUSH
62846: LD_INT 1
62848: PLUS
62849: PPUSH
62850: LD_INT 3
62852: PPUSH
62853: CALL_OW 2
62857: ST_TO_ADDR
// if missile < 2 then
62858: LD_VAR 0 14
62862: PUSH
62863: LD_INT 2
62865: LESS
62866: IFFALSE 62870
// exit ;
62868: GO 63092
// x := GetX ( enemy ) ;
62870: LD_ADDR_VAR 0 4
62874: PUSH
62875: LD_VAR 0 10
62879: PPUSH
62880: CALL_OW 250
62884: ST_TO_ADDR
// y := GetY ( enemy ) ;
62885: LD_ADDR_VAR 0 5
62889: PUSH
62890: LD_VAR 0 10
62894: PPUSH
62895: CALL_OW 251
62899: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
62900: LD_ADDR_VAR 0 6
62904: PUSH
62905: LD_VAR 0 4
62909: PUSH
62910: LD_INT 1
62912: NEG
62913: PPUSH
62914: LD_INT 1
62916: PPUSH
62917: CALL_OW 12
62921: PLUS
62922: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
62923: LD_ADDR_VAR 0 7
62927: PUSH
62928: LD_VAR 0 5
62932: PUSH
62933: LD_INT 1
62935: NEG
62936: PPUSH
62937: LD_INT 1
62939: PPUSH
62940: CALL_OW 12
62944: PLUS
62945: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62946: LD_VAR 0 6
62950: PPUSH
62951: LD_VAR 0 7
62955: PPUSH
62956: CALL_OW 488
62960: NOT
62961: IFFALSE 62983
// begin _x := x ;
62963: LD_ADDR_VAR 0 6
62967: PUSH
62968: LD_VAR 0 4
62972: ST_TO_ADDR
// _y := y ;
62973: LD_ADDR_VAR 0 7
62977: PUSH
62978: LD_VAR 0 5
62982: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
62983: LD_ADDR_VAR 0 3
62987: PUSH
62988: LD_INT 1
62990: PPUSH
62991: LD_VAR 0 14
62995: PPUSH
62996: CALL_OW 12
63000: ST_TO_ADDR
// case i of 1 :
63001: LD_VAR 0 3
63005: PUSH
63006: LD_INT 1
63008: DOUBLE
63009: EQUAL
63010: IFTRUE 63014
63012: GO 63031
63014: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
63015: LD_VAR 0 1
63019: PPUSH
63020: LD_VAR 0 10
63024: PPUSH
63025: CALL_OW 115
63029: GO 63092
63031: LD_INT 2
63033: DOUBLE
63034: EQUAL
63035: IFTRUE 63039
63037: GO 63061
63039: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
63040: LD_VAR 0 1
63044: PPUSH
63045: LD_VAR 0 6
63049: PPUSH
63050: LD_VAR 0 7
63054: PPUSH
63055: CALL_OW 153
63059: GO 63092
63061: LD_INT 3
63063: DOUBLE
63064: EQUAL
63065: IFTRUE 63069
63067: GO 63091
63069: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
63070: LD_VAR 0 1
63074: PPUSH
63075: LD_VAR 0 6
63079: PPUSH
63080: LD_VAR 0 7
63084: PPUSH
63085: CALL_OW 154
63089: GO 63092
63091: POP
// end ;
63092: LD_VAR 0 2
63096: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
63097: LD_INT 0
63099: PPUSH
63100: PPUSH
63101: PPUSH
63102: PPUSH
63103: PPUSH
63104: PPUSH
// if not unit or not building then
63105: LD_VAR 0 1
63109: NOT
63110: PUSH
63111: LD_VAR 0 2
63115: NOT
63116: OR
63117: IFFALSE 63121
// exit ;
63119: GO 63279
// x := GetX ( building ) ;
63121: LD_ADDR_VAR 0 5
63125: PUSH
63126: LD_VAR 0 2
63130: PPUSH
63131: CALL_OW 250
63135: ST_TO_ADDR
// y := GetY ( building ) ;
63136: LD_ADDR_VAR 0 6
63140: PUSH
63141: LD_VAR 0 2
63145: PPUSH
63146: CALL_OW 251
63150: ST_TO_ADDR
// for i = 0 to 5 do
63151: LD_ADDR_VAR 0 4
63155: PUSH
63156: DOUBLE
63157: LD_INT 0
63159: DEC
63160: ST_TO_ADDR
63161: LD_INT 5
63163: PUSH
63164: FOR_TO
63165: IFFALSE 63277
// begin _x := ShiftX ( x , i , 3 ) ;
63167: LD_ADDR_VAR 0 7
63171: PUSH
63172: LD_VAR 0 5
63176: PPUSH
63177: LD_VAR 0 4
63181: PPUSH
63182: LD_INT 3
63184: PPUSH
63185: CALL_OW 272
63189: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
63190: LD_ADDR_VAR 0 8
63194: PUSH
63195: LD_VAR 0 6
63199: PPUSH
63200: LD_VAR 0 4
63204: PPUSH
63205: LD_INT 3
63207: PPUSH
63208: CALL_OW 273
63212: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63213: LD_VAR 0 7
63217: PPUSH
63218: LD_VAR 0 8
63222: PPUSH
63223: CALL_OW 488
63227: NOT
63228: IFFALSE 63232
// continue ;
63230: GO 63164
// if HexInfo ( _x , _y ) = 0 then
63232: LD_VAR 0 7
63236: PPUSH
63237: LD_VAR 0 8
63241: PPUSH
63242: CALL_OW 428
63246: PUSH
63247: LD_INT 0
63249: EQUAL
63250: IFFALSE 63275
// begin ComMoveXY ( unit , _x , _y ) ;
63252: LD_VAR 0 1
63256: PPUSH
63257: LD_VAR 0 7
63261: PPUSH
63262: LD_VAR 0 8
63266: PPUSH
63267: CALL_OW 111
// exit ;
63271: POP
63272: POP
63273: GO 63279
// end ; end ;
63275: GO 63164
63277: POP
63278: POP
// end ;
63279: LD_VAR 0 3
63283: RET
// export function ScanBase ( side , base_area ) ; begin
63284: LD_INT 0
63286: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
63287: LD_ADDR_VAR 0 3
63291: PUSH
63292: LD_VAR 0 2
63296: PPUSH
63297: LD_INT 81
63299: PUSH
63300: LD_VAR 0 1
63304: PUSH
63305: EMPTY
63306: LIST
63307: LIST
63308: PPUSH
63309: CALL_OW 70
63313: ST_TO_ADDR
// end ;
63314: LD_VAR 0 3
63318: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
63319: LD_INT 0
63321: PPUSH
63322: PPUSH
63323: PPUSH
63324: PPUSH
63325: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
63326: LD_VAR 0 1
63330: NOT
63331: PUSH
63332: LD_EXP 99
63336: PUSH
63337: LD_VAR 0 1
63341: ARRAY
63342: NOT
63343: OR
63344: PUSH
63345: LD_VAR 0 2
63349: NOT
63350: OR
63351: PUSH
63352: LD_VAR 0 3
63356: NOT
63357: OR
63358: IFFALSE 63362
// exit ;
63360: GO 63812
// side := mc_sides [ base ] ;
63362: LD_ADDR_VAR 0 6
63366: PUSH
63367: LD_EXP 125
63371: PUSH
63372: LD_VAR 0 1
63376: ARRAY
63377: ST_TO_ADDR
// if not side then
63378: LD_VAR 0 6
63382: NOT
63383: IFFALSE 63387
// exit ;
63385: GO 63812
// for i in solds do
63387: LD_ADDR_VAR 0 7
63391: PUSH
63392: LD_VAR 0 2
63396: PUSH
63397: FOR_IN
63398: IFFALSE 63459
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
63400: LD_VAR 0 7
63404: PPUSH
63405: CALL_OW 310
63409: PPUSH
63410: CALL_OW 266
63414: PUSH
63415: LD_INT 32
63417: PUSH
63418: LD_INT 31
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: IN
63425: IFFALSE 63445
// solds := solds diff i else
63427: LD_ADDR_VAR 0 2
63431: PUSH
63432: LD_VAR 0 2
63436: PUSH
63437: LD_VAR 0 7
63441: DIFF
63442: ST_TO_ADDR
63443: GO 63457
// SetTag ( i , 18 ) ;
63445: LD_VAR 0 7
63449: PPUSH
63450: LD_INT 18
63452: PPUSH
63453: CALL_OW 109
63457: GO 63397
63459: POP
63460: POP
// if not solds then
63461: LD_VAR 0 2
63465: NOT
63466: IFFALSE 63470
// exit ;
63468: GO 63812
// repeat wait ( 0 0$1 ) ;
63470: LD_INT 35
63472: PPUSH
63473: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
63477: LD_ADDR_VAR 0 5
63481: PUSH
63482: LD_VAR 0 6
63486: PPUSH
63487: LD_VAR 0 3
63491: PPUSH
63492: CALL 63284 0 2
63496: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
63497: LD_VAR 0 5
63501: NOT
63502: PUSH
63503: LD_VAR 0 5
63507: PUSH
63508: LD_INT 3
63510: GREATER
63511: OR
63512: PUSH
63513: LD_EXP 121
63517: PUSH
63518: LD_VAR 0 1
63522: ARRAY
63523: OR
63524: IFFALSE 63565
// begin for i in solds do
63526: LD_ADDR_VAR 0 7
63530: PUSH
63531: LD_VAR 0 2
63535: PUSH
63536: FOR_IN
63537: IFFALSE 63561
// if HasTask ( i ) then
63539: LD_VAR 0 7
63543: PPUSH
63544: CALL_OW 314
63548: IFFALSE 63559
// ComStop ( i ) ;
63550: LD_VAR 0 7
63554: PPUSH
63555: CALL_OW 141
63559: GO 63536
63561: POP
63562: POP
// break ;
63563: GO 63800
// end ; for i in solds do
63565: LD_ADDR_VAR 0 7
63569: PUSH
63570: LD_VAR 0 2
63574: PUSH
63575: FOR_IN
63576: IFFALSE 63792
// begin if IsInUnit ( i ) then
63578: LD_VAR 0 7
63582: PPUSH
63583: CALL_OW 310
63587: IFFALSE 63598
// ComExitBuilding ( i ) ;
63589: LD_VAR 0 7
63593: PPUSH
63594: CALL_OW 122
// if GetLives ( i ) > 333 then
63598: LD_VAR 0 7
63602: PPUSH
63603: CALL_OW 256
63607: PUSH
63608: LD_INT 333
63610: GREATER
63611: IFFALSE 63639
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
63613: LD_VAR 0 7
63617: PPUSH
63618: LD_VAR 0 5
63622: PPUSH
63623: LD_VAR 0 7
63627: PPUSH
63628: CALL_OW 74
63632: PPUSH
63633: CALL_OW 115
63637: GO 63790
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
63639: LD_ADDR_VAR 0 8
63643: PUSH
63644: LD_EXP 99
63648: PUSH
63649: LD_VAR 0 1
63653: ARRAY
63654: PPUSH
63655: LD_INT 2
63657: PUSH
63658: LD_INT 30
63660: PUSH
63661: LD_INT 0
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: PUSH
63668: LD_INT 30
63670: PUSH
63671: LD_INT 1
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: PUSH
63678: LD_INT 30
63680: PUSH
63681: LD_INT 6
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: PPUSH
63694: CALL_OW 72
63698: PPUSH
63699: LD_VAR 0 7
63703: PPUSH
63704: CALL_OW 74
63708: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
63709: LD_VAR 0 7
63713: PPUSH
63714: LD_VAR 0 8
63718: PPUSH
63719: CALL_OW 250
63723: PPUSH
63724: LD_INT 3
63726: PPUSH
63727: LD_INT 5
63729: PPUSH
63730: CALL_OW 272
63734: PPUSH
63735: LD_VAR 0 8
63739: PPUSH
63740: CALL_OW 251
63744: PPUSH
63745: LD_INT 3
63747: PPUSH
63748: LD_INT 5
63750: PPUSH
63751: CALL_OW 273
63755: PPUSH
63756: CALL_OW 111
// SetTag ( i , 0 ) ;
63760: LD_VAR 0 7
63764: PPUSH
63765: LD_INT 0
63767: PPUSH
63768: CALL_OW 109
// solds := solds diff i ;
63772: LD_ADDR_VAR 0 2
63776: PUSH
63777: LD_VAR 0 2
63781: PUSH
63782: LD_VAR 0 7
63786: DIFF
63787: ST_TO_ADDR
// continue ;
63788: GO 63575
// end ; end ;
63790: GO 63575
63792: POP
63793: POP
// until solds ;
63794: LD_VAR 0 2
63798: IFFALSE 63470
// MC_Reset ( base , 18 ) ;
63800: LD_VAR 0 1
63804: PPUSH
63805: LD_INT 18
63807: PPUSH
63808: CALL 36532 0 2
// end ;
63812: LD_VAR 0 4
63816: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
63817: LD_INT 0
63819: PPUSH
63820: PPUSH
63821: PPUSH
63822: PPUSH
63823: PPUSH
63824: PPUSH
63825: PPUSH
63826: PPUSH
63827: PPUSH
63828: PPUSH
63829: PPUSH
63830: PPUSH
63831: PPUSH
63832: PPUSH
63833: PPUSH
63834: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
63835: LD_ADDR_VAR 0 12
63839: PUSH
63840: LD_EXP 99
63844: PUSH
63845: LD_VAR 0 1
63849: ARRAY
63850: PPUSH
63851: LD_INT 25
63853: PUSH
63854: LD_INT 3
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PPUSH
63861: CALL_OW 72
63865: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63866: LD_ADDR_VAR 0 8
63870: PUSH
63871: LD_EXP 99
63875: PUSH
63876: LD_VAR 0 1
63880: ARRAY
63881: PPUSH
63882: LD_INT 2
63884: PUSH
63885: LD_INT 25
63887: PUSH
63888: LD_INT 1
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 25
63897: PUSH
63898: LD_INT 5
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 25
63907: PUSH
63908: LD_INT 8
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: LD_INT 25
63917: PUSH
63918: LD_INT 9
63920: PUSH
63921: EMPTY
63922: LIST
63923: LIST
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: PPUSH
63932: CALL_OW 72
63936: ST_TO_ADDR
// if not defenders and not solds then
63937: LD_VAR 0 2
63941: NOT
63942: PUSH
63943: LD_VAR 0 8
63947: NOT
63948: AND
63949: IFFALSE 63953
// exit ;
63951: GO 65319
// depot_under_attack := false ;
63953: LD_ADDR_VAR 0 16
63957: PUSH
63958: LD_INT 0
63960: ST_TO_ADDR
// sold_defenders := [ ] ;
63961: LD_ADDR_VAR 0 17
63965: PUSH
63966: EMPTY
63967: ST_TO_ADDR
// if mechs then
63968: LD_VAR 0 12
63972: IFFALSE 64101
// for i in defenders do
63974: LD_ADDR_VAR 0 5
63978: PUSH
63979: LD_VAR 0 2
63983: PUSH
63984: FOR_IN
63985: IFFALSE 64099
// begin SetTag ( i , 20 ) ;
63987: LD_VAR 0 5
63991: PPUSH
63992: LD_INT 20
63994: PPUSH
63995: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
63999: LD_VAR 0 5
64003: PPUSH
64004: CALL_OW 263
64008: PUSH
64009: LD_INT 1
64011: EQUAL
64012: PUSH
64013: LD_VAR 0 5
64017: PPUSH
64018: CALL_OW 311
64022: NOT
64023: AND
64024: PUSH
64025: LD_VAR 0 12
64029: AND
64030: IFFALSE 64097
// begin un := mechs [ 1 ] ;
64032: LD_ADDR_VAR 0 10
64036: PUSH
64037: LD_VAR 0 12
64041: PUSH
64042: LD_INT 1
64044: ARRAY
64045: ST_TO_ADDR
// ComExitBuilding ( un ) ;
64046: LD_VAR 0 10
64050: PPUSH
64051: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
64055: LD_VAR 0 10
64059: PPUSH
64060: LD_VAR 0 5
64064: PPUSH
64065: CALL_OW 180
// SetTag ( un , 19 ) ;
64069: LD_VAR 0 10
64073: PPUSH
64074: LD_INT 19
64076: PPUSH
64077: CALL_OW 109
// mechs := mechs diff un ;
64081: LD_ADDR_VAR 0 12
64085: PUSH
64086: LD_VAR 0 12
64090: PUSH
64091: LD_VAR 0 10
64095: DIFF
64096: ST_TO_ADDR
// end ; end ;
64097: GO 63984
64099: POP
64100: POP
// if solds then
64101: LD_VAR 0 8
64105: IFFALSE 64164
// for i in solds do
64107: LD_ADDR_VAR 0 5
64111: PUSH
64112: LD_VAR 0 8
64116: PUSH
64117: FOR_IN
64118: IFFALSE 64162
// if not GetTag ( i ) then
64120: LD_VAR 0 5
64124: PPUSH
64125: CALL_OW 110
64129: NOT
64130: IFFALSE 64160
// begin defenders := defenders union i ;
64132: LD_ADDR_VAR 0 2
64136: PUSH
64137: LD_VAR 0 2
64141: PUSH
64142: LD_VAR 0 5
64146: UNION
64147: ST_TO_ADDR
// SetTag ( i , 18 ) ;
64148: LD_VAR 0 5
64152: PPUSH
64153: LD_INT 18
64155: PPUSH
64156: CALL_OW 109
// end ;
64160: GO 64117
64162: POP
64163: POP
// repeat wait ( 0 0$1 ) ;
64164: LD_INT 35
64166: PPUSH
64167: CALL_OW 67
// enemy := mc_scan [ base ] ;
64171: LD_ADDR_VAR 0 3
64175: PUSH
64176: LD_EXP 122
64180: PUSH
64181: LD_VAR 0 1
64185: ARRAY
64186: ST_TO_ADDR
// for i in defenders do
64187: LD_ADDR_VAR 0 5
64191: PUSH
64192: LD_VAR 0 2
64196: PUSH
64197: FOR_IN
64198: IFFALSE 64883
// begin e := NearestUnitToUnit ( enemy , i ) ;
64200: LD_ADDR_VAR 0 13
64204: PUSH
64205: LD_VAR 0 3
64209: PPUSH
64210: LD_VAR 0 5
64214: PPUSH
64215: CALL_OW 74
64219: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
64220: LD_ADDR_VAR 0 16
64224: PUSH
64225: LD_EXP 99
64229: PUSH
64230: LD_VAR 0 1
64234: ARRAY
64235: PPUSH
64236: LD_INT 2
64238: PUSH
64239: LD_INT 30
64241: PUSH
64242: LD_INT 0
64244: PUSH
64245: EMPTY
64246: LIST
64247: LIST
64248: PUSH
64249: LD_INT 30
64251: PUSH
64252: LD_INT 1
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: PUSH
64259: EMPTY
64260: LIST
64261: LIST
64262: LIST
64263: PPUSH
64264: CALL_OW 72
64268: NOT
64269: PUSH
64270: LD_EXP 99
64274: PUSH
64275: LD_VAR 0 1
64279: ARRAY
64280: PPUSH
64281: LD_INT 2
64283: PUSH
64284: LD_INT 30
64286: PUSH
64287: LD_INT 0
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 30
64296: PUSH
64297: LD_INT 1
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: LIST
64308: PPUSH
64309: CALL_OW 72
64313: PPUSH
64314: CALL_OW 256
64318: PUSH
64319: LD_INT 600
64321: LESS
64322: OR
64323: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
64324: LD_VAR 0 5
64328: PPUSH
64329: CALL_OW 247
64333: PUSH
64334: LD_INT 2
64336: DOUBLE
64337: EQUAL
64338: IFTRUE 64342
64340: GO 64589
64342: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
64343: LD_VAR 0 5
64347: PPUSH
64348: CALL_OW 256
64352: PUSH
64353: LD_INT 650
64355: GREATER
64356: PUSH
64357: LD_VAR 0 5
64361: PPUSH
64362: LD_VAR 0 13
64366: PPUSH
64367: CALL_OW 296
64371: PUSH
64372: LD_INT 40
64374: LESS
64375: AND
64376: IFFALSE 64394
// ComAttackUnit ( i , e ) else
64378: LD_VAR 0 5
64382: PPUSH
64383: LD_VAR 0 13
64387: PPUSH
64388: CALL_OW 115
64392: GO 64472
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
64394: LD_VAR 0 5
64398: PPUSH
64399: LD_VAR 0 13
64403: PPUSH
64404: CALL_OW 296
64408: PUSH
64409: LD_INT 30
64411: GREATEREQUAL
64412: PUSH
64413: LD_VAR 0 5
64417: PPUSH
64418: CALL_OW 256
64422: PUSH
64423: LD_INT 650
64425: LESSEQUAL
64426: OR
64427: PUSH
64428: LD_VAR 0 5
64432: PPUSH
64433: LD_EXP 123
64437: PUSH
64438: LD_VAR 0 1
64442: ARRAY
64443: PPUSH
64444: CALL_OW 308
64448: NOT
64449: AND
64450: IFFALSE 64472
// ComMoveToArea ( i , mc_parking [ base ] ) ;
64452: LD_VAR 0 5
64456: PPUSH
64457: LD_EXP 123
64461: PUSH
64462: LD_VAR 0 1
64466: ARRAY
64467: PPUSH
64468: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
64472: LD_VAR 0 5
64476: PPUSH
64477: CALL_OW 256
64481: PUSH
64482: LD_INT 998
64484: LESS
64485: PUSH
64486: LD_VAR 0 5
64490: PPUSH
64491: CALL_OW 263
64495: PUSH
64496: LD_INT 1
64498: EQUAL
64499: AND
64500: PUSH
64501: LD_VAR 0 5
64505: PPUSH
64506: CALL_OW 311
64510: AND
64511: PUSH
64512: LD_VAR 0 5
64516: PPUSH
64517: LD_EXP 123
64521: PUSH
64522: LD_VAR 0 1
64526: ARRAY
64527: PPUSH
64528: CALL_OW 308
64532: AND
64533: IFFALSE 64587
// begin mech := IsDrivenBy ( i ) ;
64535: LD_ADDR_VAR 0 9
64539: PUSH
64540: LD_VAR 0 5
64544: PPUSH
64545: CALL_OW 311
64549: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
64550: LD_VAR 0 9
64554: PPUSH
64555: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
64559: LD_VAR 0 9
64563: PPUSH
64564: LD_VAR 0 5
64568: PPUSH
64569: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
64573: LD_VAR 0 9
64577: PPUSH
64578: LD_VAR 0 5
64582: PPUSH
64583: CALL_OW 180
// end ; end ; unit_human :
64587: GO 64854
64589: LD_INT 1
64591: DOUBLE
64592: EQUAL
64593: IFTRUE 64597
64595: GO 64853
64597: POP
// begin b := IsInUnit ( i ) ;
64598: LD_ADDR_VAR 0 18
64602: PUSH
64603: LD_VAR 0 5
64607: PPUSH
64608: CALL_OW 310
64612: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
64613: LD_ADDR_VAR 0 19
64617: PUSH
64618: LD_VAR 0 18
64622: NOT
64623: PUSH
64624: LD_VAR 0 18
64628: PPUSH
64629: CALL_OW 266
64633: PUSH
64634: LD_INT 32
64636: PUSH
64637: LD_INT 31
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: IN
64644: OR
64645: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
64646: LD_VAR 0 16
64650: PUSH
64651: LD_VAR 0 2
64655: PPUSH
64656: LD_INT 21
64658: PUSH
64659: LD_INT 2
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PPUSH
64666: CALL_OW 72
64670: PUSH
64671: LD_INT 1
64673: LESSEQUAL
64674: OR
64675: PUSH
64676: LD_VAR 0 19
64680: AND
64681: PUSH
64682: LD_VAR 0 5
64686: PUSH
64687: LD_VAR 0 17
64691: IN
64692: NOT
64693: AND
64694: IFFALSE 64787
// begin if b then
64696: LD_VAR 0 18
64700: IFFALSE 64749
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
64702: LD_VAR 0 18
64706: PPUSH
64707: LD_VAR 0 3
64711: PPUSH
64712: LD_VAR 0 18
64716: PPUSH
64717: CALL_OW 74
64721: PPUSH
64722: CALL_OW 296
64726: PUSH
64727: LD_INT 10
64729: LESS
64730: PUSH
64731: LD_VAR 0 18
64735: PPUSH
64736: CALL_OW 461
64740: PUSH
64741: LD_INT 7
64743: NONEQUAL
64744: AND
64745: IFFALSE 64749
// continue ;
64747: GO 64197
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
64749: LD_ADDR_VAR 0 17
64753: PUSH
64754: LD_VAR 0 17
64758: PPUSH
64759: LD_VAR 0 17
64763: PUSH
64764: LD_INT 1
64766: PLUS
64767: PPUSH
64768: LD_VAR 0 5
64772: PPUSH
64773: CALL_OW 1
64777: ST_TO_ADDR
// ComExitBuilding ( i ) ;
64778: LD_VAR 0 5
64782: PPUSH
64783: CALL_OW 122
// end ; if sold_defenders then
64787: LD_VAR 0 17
64791: IFFALSE 64851
// if i in sold_defenders then
64793: LD_VAR 0 5
64797: PUSH
64798: LD_VAR 0 17
64802: IN
64803: IFFALSE 64851
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
64805: LD_VAR 0 5
64809: PPUSH
64810: CALL_OW 314
64814: NOT
64815: PUSH
64816: LD_VAR 0 5
64820: PPUSH
64821: LD_VAR 0 13
64825: PPUSH
64826: CALL_OW 296
64830: PUSH
64831: LD_INT 30
64833: LESS
64834: AND
64835: IFFALSE 64851
// ComAttackUnit ( i , e ) ;
64837: LD_VAR 0 5
64841: PPUSH
64842: LD_VAR 0 13
64846: PPUSH
64847: CALL_OW 115
// end ; end ; end ;
64851: GO 64854
64853: POP
// if IsDead ( i ) then
64854: LD_VAR 0 5
64858: PPUSH
64859: CALL_OW 301
64863: IFFALSE 64881
// defenders := defenders diff i ;
64865: LD_ADDR_VAR 0 2
64869: PUSH
64870: LD_VAR 0 2
64874: PUSH
64875: LD_VAR 0 5
64879: DIFF
64880: ST_TO_ADDR
// end ;
64881: GO 64197
64883: POP
64884: POP
// until not enemy or not defenders ;
64885: LD_VAR 0 3
64889: NOT
64890: PUSH
64891: LD_VAR 0 2
64895: NOT
64896: OR
64897: IFFALSE 64164
// MC_Reset ( base , 18 ) ;
64899: LD_VAR 0 1
64903: PPUSH
64904: LD_INT 18
64906: PPUSH
64907: CALL 36532 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64911: LD_ADDR_VAR 0 2
64915: PUSH
64916: LD_VAR 0 2
64920: PUSH
64921: LD_VAR 0 2
64925: PPUSH
64926: LD_INT 2
64928: PUSH
64929: LD_INT 25
64931: PUSH
64932: LD_INT 1
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 25
64941: PUSH
64942: LD_INT 5
64944: PUSH
64945: EMPTY
64946: LIST
64947: LIST
64948: PUSH
64949: LD_INT 25
64951: PUSH
64952: LD_INT 8
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: PUSH
64959: LD_INT 25
64961: PUSH
64962: LD_INT 9
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: PPUSH
64976: CALL_OW 72
64980: DIFF
64981: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
64982: LD_VAR 0 3
64986: NOT
64987: PUSH
64988: LD_VAR 0 2
64992: PPUSH
64993: LD_INT 21
64995: PUSH
64996: LD_INT 2
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PPUSH
65003: CALL_OW 72
65007: AND
65008: IFFALSE 65270
// begin tmp := FilterByTag ( defenders , 19 ) ;
65010: LD_ADDR_VAR 0 11
65014: PUSH
65015: LD_VAR 0 2
65019: PPUSH
65020: LD_INT 19
65022: PPUSH
65023: CALL 101617 0 2
65027: ST_TO_ADDR
// if tmp then
65028: LD_VAR 0 11
65032: IFFALSE 65102
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
65034: LD_ADDR_VAR 0 11
65038: PUSH
65039: LD_VAR 0 11
65043: PPUSH
65044: LD_INT 25
65046: PUSH
65047: LD_INT 3
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PPUSH
65054: CALL_OW 72
65058: ST_TO_ADDR
// if tmp then
65059: LD_VAR 0 11
65063: IFFALSE 65102
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
65065: LD_ADDR_EXP 111
65069: PUSH
65070: LD_EXP 111
65074: PPUSH
65075: LD_VAR 0 1
65079: PPUSH
65080: LD_EXP 111
65084: PUSH
65085: LD_VAR 0 1
65089: ARRAY
65090: PUSH
65091: LD_VAR 0 11
65095: UNION
65096: PPUSH
65097: CALL_OW 1
65101: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
65102: LD_VAR 0 1
65106: PPUSH
65107: LD_INT 19
65109: PPUSH
65110: CALL 36532 0 2
// repeat wait ( 0 0$1 ) ;
65114: LD_INT 35
65116: PPUSH
65117: CALL_OW 67
// for i in defenders do
65121: LD_ADDR_VAR 0 5
65125: PUSH
65126: LD_VAR 0 2
65130: PUSH
65131: FOR_IN
65132: IFFALSE 65221
// begin if not IsInArea ( i , mc_parking [ base ] ) then
65134: LD_VAR 0 5
65138: PPUSH
65139: LD_EXP 123
65143: PUSH
65144: LD_VAR 0 1
65148: ARRAY
65149: PPUSH
65150: CALL_OW 308
65154: NOT
65155: IFFALSE 65179
// ComMoveToArea ( i , mc_parking [ base ] ) else
65157: LD_VAR 0 5
65161: PPUSH
65162: LD_EXP 123
65166: PUSH
65167: LD_VAR 0 1
65171: ARRAY
65172: PPUSH
65173: CALL_OW 113
65177: GO 65219
// if GetControl ( i ) = control_manual then
65179: LD_VAR 0 5
65183: PPUSH
65184: CALL_OW 263
65188: PUSH
65189: LD_INT 1
65191: EQUAL
65192: IFFALSE 65219
// if IsDrivenBy ( i ) then
65194: LD_VAR 0 5
65198: PPUSH
65199: CALL_OW 311
65203: IFFALSE 65219
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
65205: LD_VAR 0 5
65209: PPUSH
65210: CALL_OW 311
65214: PPUSH
65215: CALL_OW 121
// end ;
65219: GO 65131
65221: POP
65222: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
65223: LD_VAR 0 2
65227: PPUSH
65228: LD_INT 95
65230: PUSH
65231: LD_EXP 123
65235: PUSH
65236: LD_VAR 0 1
65240: ARRAY
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PPUSH
65246: CALL_OW 72
65250: PUSH
65251: LD_VAR 0 2
65255: EQUAL
65256: PUSH
65257: LD_EXP 122
65261: PUSH
65262: LD_VAR 0 1
65266: ARRAY
65267: OR
65268: IFFALSE 65114
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
65270: LD_ADDR_EXP 121
65274: PUSH
65275: LD_EXP 121
65279: PPUSH
65280: LD_VAR 0 1
65284: PPUSH
65285: LD_EXP 121
65289: PUSH
65290: LD_VAR 0 1
65294: ARRAY
65295: PUSH
65296: LD_VAR 0 2
65300: UNION
65301: PPUSH
65302: CALL_OW 1
65306: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
65307: LD_VAR 0 1
65311: PPUSH
65312: LD_INT 20
65314: PPUSH
65315: CALL 36532 0 2
// end ;
65319: LD_VAR 0 4
65323: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65324: LD_INT 0
65326: PPUSH
65327: PPUSH
65328: PPUSH
65329: PPUSH
// result := false ;
65330: LD_ADDR_VAR 0 2
65334: PUSH
65335: LD_INT 0
65337: ST_TO_ADDR
// side := GetSide ( unit ) ;
65338: LD_ADDR_VAR 0 3
65342: PUSH
65343: LD_VAR 0 1
65347: PPUSH
65348: CALL_OW 255
65352: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65353: LD_ADDR_VAR 0 4
65357: PUSH
65358: LD_VAR 0 1
65362: PPUSH
65363: CALL_OW 248
65367: ST_TO_ADDR
// case nat of 1 :
65368: LD_VAR 0 4
65372: PUSH
65373: LD_INT 1
65375: DOUBLE
65376: EQUAL
65377: IFTRUE 65381
65379: GO 65392
65381: POP
// tech := tech_lassight ; 2 :
65382: LD_ADDR_VAR 0 5
65386: PUSH
65387: LD_INT 12
65389: ST_TO_ADDR
65390: GO 65431
65392: LD_INT 2
65394: DOUBLE
65395: EQUAL
65396: IFTRUE 65400
65398: GO 65411
65400: POP
// tech := tech_mortar ; 3 :
65401: LD_ADDR_VAR 0 5
65405: PUSH
65406: LD_INT 41
65408: ST_TO_ADDR
65409: GO 65431
65411: LD_INT 3
65413: DOUBLE
65414: EQUAL
65415: IFTRUE 65419
65417: GO 65430
65419: POP
// tech := tech_bazooka ; end ;
65420: LD_ADDR_VAR 0 5
65424: PUSH
65425: LD_INT 44
65427: ST_TO_ADDR
65428: GO 65431
65430: POP
// if Researched ( side , tech ) then
65431: LD_VAR 0 3
65435: PPUSH
65436: LD_VAR 0 5
65440: PPUSH
65441: CALL_OW 325
65445: IFFALSE 65472
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65447: LD_ADDR_VAR 0 2
65451: PUSH
65452: LD_INT 5
65454: PUSH
65455: LD_INT 8
65457: PUSH
65458: LD_INT 9
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: LIST
65465: PUSH
65466: LD_VAR 0 4
65470: ARRAY
65471: ST_TO_ADDR
// end ;
65472: LD_VAR 0 2
65476: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65477: LD_INT 0
65479: PPUSH
65480: PPUSH
65481: PPUSH
// if not mines then
65482: LD_VAR 0 2
65486: NOT
65487: IFFALSE 65491
// exit ;
65489: GO 65635
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65491: LD_ADDR_VAR 0 5
65495: PUSH
65496: LD_INT 81
65498: PUSH
65499: LD_VAR 0 1
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PUSH
65508: LD_INT 3
65510: PUSH
65511: LD_INT 21
65513: PUSH
65514: LD_INT 3
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PPUSH
65529: CALL_OW 69
65533: ST_TO_ADDR
// for i in mines do
65534: LD_ADDR_VAR 0 4
65538: PUSH
65539: LD_VAR 0 2
65543: PUSH
65544: FOR_IN
65545: IFFALSE 65633
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65547: LD_VAR 0 4
65551: PUSH
65552: LD_INT 1
65554: ARRAY
65555: PPUSH
65556: LD_VAR 0 4
65560: PUSH
65561: LD_INT 2
65563: ARRAY
65564: PPUSH
65565: CALL_OW 458
65569: NOT
65570: IFFALSE 65574
// continue ;
65572: GO 65544
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65574: LD_VAR 0 4
65578: PUSH
65579: LD_INT 1
65581: ARRAY
65582: PPUSH
65583: LD_VAR 0 4
65587: PUSH
65588: LD_INT 2
65590: ARRAY
65591: PPUSH
65592: CALL_OW 428
65596: PUSH
65597: LD_VAR 0 5
65601: IN
65602: IFFALSE 65631
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65604: LD_VAR 0 4
65608: PUSH
65609: LD_INT 1
65611: ARRAY
65612: PPUSH
65613: LD_VAR 0 4
65617: PUSH
65618: LD_INT 2
65620: ARRAY
65621: PPUSH
65622: LD_VAR 0 1
65626: PPUSH
65627: CALL_OW 456
// end ;
65631: GO 65544
65633: POP
65634: POP
// end ;
65635: LD_VAR 0 3
65639: RET
// export function Count ( array ) ; var i ; begin
65640: LD_INT 0
65642: PPUSH
65643: PPUSH
// result := 0 ;
65644: LD_ADDR_VAR 0 2
65648: PUSH
65649: LD_INT 0
65651: ST_TO_ADDR
// for i in array do
65652: LD_ADDR_VAR 0 3
65656: PUSH
65657: LD_VAR 0 1
65661: PUSH
65662: FOR_IN
65663: IFFALSE 65687
// if i then
65665: LD_VAR 0 3
65669: IFFALSE 65685
// result := result + 1 ;
65671: LD_ADDR_VAR 0 2
65675: PUSH
65676: LD_VAR 0 2
65680: PUSH
65681: LD_INT 1
65683: PLUS
65684: ST_TO_ADDR
65685: GO 65662
65687: POP
65688: POP
// end ;
65689: LD_VAR 0 2
65693: RET
// export function IsEmpty ( building ) ; begin
65694: LD_INT 0
65696: PPUSH
// if not building then
65697: LD_VAR 0 1
65701: NOT
65702: IFFALSE 65706
// exit ;
65704: GO 65749
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65706: LD_ADDR_VAR 0 2
65710: PUSH
65711: LD_VAR 0 1
65715: PUSH
65716: LD_INT 22
65718: PUSH
65719: LD_VAR 0 1
65723: PPUSH
65724: CALL_OW 255
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: PUSH
65733: LD_INT 58
65735: PUSH
65736: EMPTY
65737: LIST
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PPUSH
65743: CALL_OW 69
65747: IN
65748: ST_TO_ADDR
// end ;
65749: LD_VAR 0 2
65753: RET
// export function IsNotFull ( building ) ; begin
65754: LD_INT 0
65756: PPUSH
// if not building then
65757: LD_VAR 0 1
65761: NOT
65762: IFFALSE 65766
// exit ;
65764: GO 65785
// result := UnitsInside ( building ) < 6 ;
65766: LD_ADDR_VAR 0 2
65770: PUSH
65771: LD_VAR 0 1
65775: PPUSH
65776: CALL_OW 313
65780: PUSH
65781: LD_INT 6
65783: LESS
65784: ST_TO_ADDR
// end ;
65785: LD_VAR 0 2
65789: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65790: LD_INT 0
65792: PPUSH
65793: PPUSH
65794: PPUSH
65795: PPUSH
// tmp := [ ] ;
65796: LD_ADDR_VAR 0 3
65800: PUSH
65801: EMPTY
65802: ST_TO_ADDR
// list := [ ] ;
65803: LD_ADDR_VAR 0 5
65807: PUSH
65808: EMPTY
65809: ST_TO_ADDR
// for i = 16 to 25 do
65810: LD_ADDR_VAR 0 4
65814: PUSH
65815: DOUBLE
65816: LD_INT 16
65818: DEC
65819: ST_TO_ADDR
65820: LD_INT 25
65822: PUSH
65823: FOR_TO
65824: IFFALSE 65897
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65826: LD_ADDR_VAR 0 3
65830: PUSH
65831: LD_VAR 0 3
65835: PUSH
65836: LD_INT 22
65838: PUSH
65839: LD_VAR 0 1
65843: PPUSH
65844: CALL_OW 255
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 91
65855: PUSH
65856: LD_VAR 0 1
65860: PUSH
65861: LD_INT 6
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 30
65871: PUSH
65872: LD_VAR 0 4
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: LIST
65885: PUSH
65886: EMPTY
65887: LIST
65888: PPUSH
65889: CALL_OW 69
65893: ADD
65894: ST_TO_ADDR
65895: GO 65823
65897: POP
65898: POP
// for i = 1 to tmp do
65899: LD_ADDR_VAR 0 4
65903: PUSH
65904: DOUBLE
65905: LD_INT 1
65907: DEC
65908: ST_TO_ADDR
65909: LD_VAR 0 3
65913: PUSH
65914: FOR_TO
65915: IFFALSE 66003
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65917: LD_ADDR_VAR 0 5
65921: PUSH
65922: LD_VAR 0 5
65926: PUSH
65927: LD_VAR 0 3
65931: PUSH
65932: LD_VAR 0 4
65936: ARRAY
65937: PPUSH
65938: CALL_OW 266
65942: PUSH
65943: LD_VAR 0 3
65947: PUSH
65948: LD_VAR 0 4
65952: ARRAY
65953: PPUSH
65954: CALL_OW 250
65958: PUSH
65959: LD_VAR 0 3
65963: PUSH
65964: LD_VAR 0 4
65968: ARRAY
65969: PPUSH
65970: CALL_OW 251
65974: PUSH
65975: LD_VAR 0 3
65979: PUSH
65980: LD_VAR 0 4
65984: ARRAY
65985: PPUSH
65986: CALL_OW 254
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: PUSH
65997: EMPTY
65998: LIST
65999: ADD
66000: ST_TO_ADDR
66001: GO 65914
66003: POP
66004: POP
// result := list ;
66005: LD_ADDR_VAR 0 2
66009: PUSH
66010: LD_VAR 0 5
66014: ST_TO_ADDR
// end ;
66015: LD_VAR 0 2
66019: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
66020: LD_INT 0
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
66027: PPUSH
66028: PPUSH
// if not factory then
66029: LD_VAR 0 1
66033: NOT
66034: IFFALSE 66038
// exit ;
66036: GO 66563
// if control = control_apeman then
66038: LD_VAR 0 4
66042: PUSH
66043: LD_INT 5
66045: EQUAL
66046: IFFALSE 66155
// begin tmp := UnitsInside ( factory ) ;
66048: LD_ADDR_VAR 0 8
66052: PUSH
66053: LD_VAR 0 1
66057: PPUSH
66058: CALL_OW 313
66062: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66063: LD_VAR 0 8
66067: PPUSH
66068: LD_INT 25
66070: PUSH
66071: LD_INT 12
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PPUSH
66078: CALL_OW 72
66082: NOT
66083: IFFALSE 66093
// control := control_manual ;
66085: LD_ADDR_VAR 0 4
66089: PUSH
66090: LD_INT 1
66092: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66093: LD_ADDR_VAR 0 8
66097: PUSH
66098: LD_VAR 0 1
66102: PPUSH
66103: CALL 65790 0 1
66107: ST_TO_ADDR
// if tmp then
66108: LD_VAR 0 8
66112: IFFALSE 66155
// begin for i in tmp do
66114: LD_ADDR_VAR 0 7
66118: PUSH
66119: LD_VAR 0 8
66123: PUSH
66124: FOR_IN
66125: IFFALSE 66153
// if i [ 1 ] = b_ext_radar then
66127: LD_VAR 0 7
66131: PUSH
66132: LD_INT 1
66134: ARRAY
66135: PUSH
66136: LD_INT 20
66138: EQUAL
66139: IFFALSE 66151
// begin control := control_remote ;
66141: LD_ADDR_VAR 0 4
66145: PUSH
66146: LD_INT 2
66148: ST_TO_ADDR
// break ;
66149: GO 66153
// end ;
66151: GO 66124
66153: POP
66154: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66155: LD_VAR 0 1
66159: PPUSH
66160: LD_VAR 0 2
66164: PPUSH
66165: LD_VAR 0 3
66169: PPUSH
66170: LD_VAR 0 4
66174: PPUSH
66175: LD_VAR 0 5
66179: PPUSH
66180: CALL_OW 448
66184: IFFALSE 66219
// begin result := [ chassis , engine , control , weapon ] ;
66186: LD_ADDR_VAR 0 6
66190: PUSH
66191: LD_VAR 0 2
66195: PUSH
66196: LD_VAR 0 3
66200: PUSH
66201: LD_VAR 0 4
66205: PUSH
66206: LD_VAR 0 5
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: ST_TO_ADDR
// exit ;
66217: GO 66563
// end ; _chassis := AvailableChassisList ( factory ) ;
66219: LD_ADDR_VAR 0 9
66223: PUSH
66224: LD_VAR 0 1
66228: PPUSH
66229: CALL_OW 475
66233: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66234: LD_ADDR_VAR 0 11
66238: PUSH
66239: LD_VAR 0 1
66243: PPUSH
66244: CALL_OW 476
66248: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66249: LD_ADDR_VAR 0 12
66253: PUSH
66254: LD_VAR 0 1
66258: PPUSH
66259: CALL_OW 477
66263: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66264: LD_ADDR_VAR 0 10
66268: PUSH
66269: LD_VAR 0 1
66273: PPUSH
66274: CALL_OW 478
66278: ST_TO_ADDR
// if not chassis in _chassis then
66279: LD_VAR 0 2
66283: PUSH
66284: LD_VAR 0 9
66288: IN
66289: NOT
66290: IFFALSE 66316
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66292: LD_ADDR_VAR 0 2
66296: PUSH
66297: LD_VAR 0 9
66301: PUSH
66302: LD_INT 1
66304: PPUSH
66305: LD_VAR 0 9
66309: PPUSH
66310: CALL_OW 12
66314: ARRAY
66315: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66316: LD_VAR 0 2
66320: PPUSH
66321: LD_VAR 0 3
66325: PPUSH
66326: CALL 66568 0 2
66330: NOT
66331: IFFALSE 66390
// repeat engine := _engine [ 1 ] ;
66333: LD_ADDR_VAR 0 3
66337: PUSH
66338: LD_VAR 0 11
66342: PUSH
66343: LD_INT 1
66345: ARRAY
66346: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66347: LD_ADDR_VAR 0 11
66351: PUSH
66352: LD_VAR 0 11
66356: PPUSH
66357: LD_INT 1
66359: PPUSH
66360: CALL_OW 3
66364: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66365: LD_VAR 0 2
66369: PPUSH
66370: LD_VAR 0 3
66374: PPUSH
66375: CALL 66568 0 2
66379: PUSH
66380: LD_VAR 0 11
66384: PUSH
66385: EMPTY
66386: EQUAL
66387: OR
66388: IFFALSE 66333
// if not control in _control then
66390: LD_VAR 0 4
66394: PUSH
66395: LD_VAR 0 12
66399: IN
66400: NOT
66401: IFFALSE 66427
// control := _control [ rand ( 1 , _control ) ] ;
66403: LD_ADDR_VAR 0 4
66407: PUSH
66408: LD_VAR 0 12
66412: PUSH
66413: LD_INT 1
66415: PPUSH
66416: LD_VAR 0 12
66420: PPUSH
66421: CALL_OW 12
66425: ARRAY
66426: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66427: LD_VAR 0 2
66431: PPUSH
66432: LD_VAR 0 5
66436: PPUSH
66437: CALL 66788 0 2
66441: NOT
66442: IFFALSE 66501
// repeat weapon := _weapon [ 1 ] ;
66444: LD_ADDR_VAR 0 5
66448: PUSH
66449: LD_VAR 0 10
66453: PUSH
66454: LD_INT 1
66456: ARRAY
66457: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66458: LD_ADDR_VAR 0 10
66462: PUSH
66463: LD_VAR 0 10
66467: PPUSH
66468: LD_INT 1
66470: PPUSH
66471: CALL_OW 3
66475: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66476: LD_VAR 0 2
66480: PPUSH
66481: LD_VAR 0 5
66485: PPUSH
66486: CALL 66788 0 2
66490: PUSH
66491: LD_VAR 0 10
66495: PUSH
66496: EMPTY
66497: EQUAL
66498: OR
66499: IFFALSE 66444
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66501: LD_VAR 0 1
66505: PPUSH
66506: LD_VAR 0 2
66510: PPUSH
66511: LD_VAR 0 3
66515: PPUSH
66516: LD_VAR 0 4
66520: PPUSH
66521: LD_VAR 0 5
66525: PPUSH
66526: CALL_OW 448
66530: IFFALSE 66563
// result := [ chassis , engine , control , weapon ] ;
66532: LD_ADDR_VAR 0 6
66536: PUSH
66537: LD_VAR 0 2
66541: PUSH
66542: LD_VAR 0 3
66546: PUSH
66547: LD_VAR 0 4
66551: PUSH
66552: LD_VAR 0 5
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: ST_TO_ADDR
// end ;
66563: LD_VAR 0 6
66567: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66568: LD_INT 0
66570: PPUSH
// if not chassis or not engine then
66571: LD_VAR 0 1
66575: NOT
66576: PUSH
66577: LD_VAR 0 2
66581: NOT
66582: OR
66583: IFFALSE 66587
// exit ;
66585: GO 66783
// case engine of engine_solar :
66587: LD_VAR 0 2
66591: PUSH
66592: LD_INT 2
66594: DOUBLE
66595: EQUAL
66596: IFTRUE 66600
66598: GO 66638
66600: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66601: LD_ADDR_VAR 0 3
66605: PUSH
66606: LD_INT 11
66608: PUSH
66609: LD_INT 12
66611: PUSH
66612: LD_INT 13
66614: PUSH
66615: LD_INT 14
66617: PUSH
66618: LD_INT 1
66620: PUSH
66621: LD_INT 2
66623: PUSH
66624: LD_INT 3
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: LIST
66631: LIST
66632: LIST
66633: LIST
66634: LIST
66635: ST_TO_ADDR
66636: GO 66767
66638: LD_INT 1
66640: DOUBLE
66641: EQUAL
66642: IFTRUE 66646
66644: GO 66708
66646: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66647: LD_ADDR_VAR 0 3
66651: PUSH
66652: LD_INT 11
66654: PUSH
66655: LD_INT 12
66657: PUSH
66658: LD_INT 13
66660: PUSH
66661: LD_INT 14
66663: PUSH
66664: LD_INT 1
66666: PUSH
66667: LD_INT 2
66669: PUSH
66670: LD_INT 3
66672: PUSH
66673: LD_INT 4
66675: PUSH
66676: LD_INT 5
66678: PUSH
66679: LD_INT 21
66681: PUSH
66682: LD_INT 23
66684: PUSH
66685: LD_INT 22
66687: PUSH
66688: LD_INT 24
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: ST_TO_ADDR
66706: GO 66767
66708: LD_INT 3
66710: DOUBLE
66711: EQUAL
66712: IFTRUE 66716
66714: GO 66766
66716: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66717: LD_ADDR_VAR 0 3
66721: PUSH
66722: LD_INT 13
66724: PUSH
66725: LD_INT 14
66727: PUSH
66728: LD_INT 2
66730: PUSH
66731: LD_INT 3
66733: PUSH
66734: LD_INT 4
66736: PUSH
66737: LD_INT 5
66739: PUSH
66740: LD_INT 21
66742: PUSH
66743: LD_INT 22
66745: PUSH
66746: LD_INT 23
66748: PUSH
66749: LD_INT 24
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: ST_TO_ADDR
66764: GO 66767
66766: POP
// result := ( chassis in result ) ;
66767: LD_ADDR_VAR 0 3
66771: PUSH
66772: LD_VAR 0 1
66776: PUSH
66777: LD_VAR 0 3
66781: IN
66782: ST_TO_ADDR
// end ;
66783: LD_VAR 0 3
66787: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66788: LD_INT 0
66790: PPUSH
// if not chassis or not weapon then
66791: LD_VAR 0 1
66795: NOT
66796: PUSH
66797: LD_VAR 0 2
66801: NOT
66802: OR
66803: IFFALSE 66807
// exit ;
66805: GO 67833
// case weapon of us_machine_gun :
66807: LD_VAR 0 2
66811: PUSH
66812: LD_INT 2
66814: DOUBLE
66815: EQUAL
66816: IFTRUE 66820
66818: GO 66850
66820: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66821: LD_ADDR_VAR 0 3
66825: PUSH
66826: LD_INT 1
66828: PUSH
66829: LD_INT 2
66831: PUSH
66832: LD_INT 3
66834: PUSH
66835: LD_INT 4
66837: PUSH
66838: LD_INT 5
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: ST_TO_ADDR
66848: GO 67817
66850: LD_INT 3
66852: DOUBLE
66853: EQUAL
66854: IFTRUE 66858
66856: GO 66888
66858: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66859: LD_ADDR_VAR 0 3
66863: PUSH
66864: LD_INT 1
66866: PUSH
66867: LD_INT 2
66869: PUSH
66870: LD_INT 3
66872: PUSH
66873: LD_INT 4
66875: PUSH
66876: LD_INT 5
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: ST_TO_ADDR
66886: GO 67817
66888: LD_INT 11
66890: DOUBLE
66891: EQUAL
66892: IFTRUE 66896
66894: GO 66926
66896: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66897: LD_ADDR_VAR 0 3
66901: PUSH
66902: LD_INT 1
66904: PUSH
66905: LD_INT 2
66907: PUSH
66908: LD_INT 3
66910: PUSH
66911: LD_INT 4
66913: PUSH
66914: LD_INT 5
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: ST_TO_ADDR
66924: GO 67817
66926: LD_INT 4
66928: DOUBLE
66929: EQUAL
66930: IFTRUE 66934
66932: GO 66960
66934: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66935: LD_ADDR_VAR 0 3
66939: PUSH
66940: LD_INT 2
66942: PUSH
66943: LD_INT 3
66945: PUSH
66946: LD_INT 4
66948: PUSH
66949: LD_INT 5
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: ST_TO_ADDR
66958: GO 67817
66960: LD_INT 5
66962: DOUBLE
66963: EQUAL
66964: IFTRUE 66968
66966: GO 66994
66968: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66969: LD_ADDR_VAR 0 3
66973: PUSH
66974: LD_INT 2
66976: PUSH
66977: LD_INT 3
66979: PUSH
66980: LD_INT 4
66982: PUSH
66983: LD_INT 5
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: ST_TO_ADDR
66992: GO 67817
66994: LD_INT 9
66996: DOUBLE
66997: EQUAL
66998: IFTRUE 67002
67000: GO 67028
67002: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67003: LD_ADDR_VAR 0 3
67007: PUSH
67008: LD_INT 2
67010: PUSH
67011: LD_INT 3
67013: PUSH
67014: LD_INT 4
67016: PUSH
67017: LD_INT 5
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: ST_TO_ADDR
67026: GO 67817
67028: LD_INT 7
67030: DOUBLE
67031: EQUAL
67032: IFTRUE 67036
67034: GO 67062
67036: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67037: LD_ADDR_VAR 0 3
67041: PUSH
67042: LD_INT 2
67044: PUSH
67045: LD_INT 3
67047: PUSH
67048: LD_INT 4
67050: PUSH
67051: LD_INT 5
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: ST_TO_ADDR
67060: GO 67817
67062: LD_INT 12
67064: DOUBLE
67065: EQUAL
67066: IFTRUE 67070
67068: GO 67096
67070: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67071: LD_ADDR_VAR 0 3
67075: PUSH
67076: LD_INT 2
67078: PUSH
67079: LD_INT 3
67081: PUSH
67082: LD_INT 4
67084: PUSH
67085: LD_INT 5
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: ST_TO_ADDR
67094: GO 67817
67096: LD_INT 13
67098: DOUBLE
67099: EQUAL
67100: IFTRUE 67104
67102: GO 67130
67104: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67105: LD_ADDR_VAR 0 3
67109: PUSH
67110: LD_INT 2
67112: PUSH
67113: LD_INT 3
67115: PUSH
67116: LD_INT 4
67118: PUSH
67119: LD_INT 5
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: ST_TO_ADDR
67128: GO 67817
67130: LD_INT 14
67132: DOUBLE
67133: EQUAL
67134: IFTRUE 67138
67136: GO 67156
67138: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67139: LD_ADDR_VAR 0 3
67143: PUSH
67144: LD_INT 4
67146: PUSH
67147: LD_INT 5
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: ST_TO_ADDR
67154: GO 67817
67156: LD_INT 6
67158: DOUBLE
67159: EQUAL
67160: IFTRUE 67164
67162: GO 67182
67164: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67165: LD_ADDR_VAR 0 3
67169: PUSH
67170: LD_INT 4
67172: PUSH
67173: LD_INT 5
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: ST_TO_ADDR
67180: GO 67817
67182: LD_INT 10
67184: DOUBLE
67185: EQUAL
67186: IFTRUE 67190
67188: GO 67208
67190: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67191: LD_ADDR_VAR 0 3
67195: PUSH
67196: LD_INT 4
67198: PUSH
67199: LD_INT 5
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: ST_TO_ADDR
67206: GO 67817
67208: LD_INT 22
67210: DOUBLE
67211: EQUAL
67212: IFTRUE 67216
67214: GO 67242
67216: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67217: LD_ADDR_VAR 0 3
67221: PUSH
67222: LD_INT 11
67224: PUSH
67225: LD_INT 12
67227: PUSH
67228: LD_INT 13
67230: PUSH
67231: LD_INT 14
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: ST_TO_ADDR
67240: GO 67817
67242: LD_INT 23
67244: DOUBLE
67245: EQUAL
67246: IFTRUE 67250
67248: GO 67276
67250: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67251: LD_ADDR_VAR 0 3
67255: PUSH
67256: LD_INT 11
67258: PUSH
67259: LD_INT 12
67261: PUSH
67262: LD_INT 13
67264: PUSH
67265: LD_INT 14
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: ST_TO_ADDR
67274: GO 67817
67276: LD_INT 24
67278: DOUBLE
67279: EQUAL
67280: IFTRUE 67284
67282: GO 67310
67284: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67285: LD_ADDR_VAR 0 3
67289: PUSH
67290: LD_INT 11
67292: PUSH
67293: LD_INT 12
67295: PUSH
67296: LD_INT 13
67298: PUSH
67299: LD_INT 14
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: ST_TO_ADDR
67308: GO 67817
67310: LD_INT 30
67312: DOUBLE
67313: EQUAL
67314: IFTRUE 67318
67316: GO 67344
67318: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67319: LD_ADDR_VAR 0 3
67323: PUSH
67324: LD_INT 11
67326: PUSH
67327: LD_INT 12
67329: PUSH
67330: LD_INT 13
67332: PUSH
67333: LD_INT 14
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: ST_TO_ADDR
67342: GO 67817
67344: LD_INT 25
67346: DOUBLE
67347: EQUAL
67348: IFTRUE 67352
67350: GO 67370
67352: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67353: LD_ADDR_VAR 0 3
67357: PUSH
67358: LD_INT 13
67360: PUSH
67361: LD_INT 14
67363: PUSH
67364: EMPTY
67365: LIST
67366: LIST
67367: ST_TO_ADDR
67368: GO 67817
67370: LD_INT 27
67372: DOUBLE
67373: EQUAL
67374: IFTRUE 67378
67376: GO 67396
67378: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67379: LD_ADDR_VAR 0 3
67383: PUSH
67384: LD_INT 13
67386: PUSH
67387: LD_INT 14
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: ST_TO_ADDR
67394: GO 67817
67396: LD_INT 28
67398: DOUBLE
67399: EQUAL
67400: IFTRUE 67404
67402: GO 67422
67404: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67405: LD_ADDR_VAR 0 3
67409: PUSH
67410: LD_INT 13
67412: PUSH
67413: LD_INT 14
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: ST_TO_ADDR
67420: GO 67817
67422: LD_INT 29
67424: DOUBLE
67425: EQUAL
67426: IFTRUE 67430
67428: GO 67448
67430: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67431: LD_ADDR_VAR 0 3
67435: PUSH
67436: LD_INT 13
67438: PUSH
67439: LD_INT 14
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: ST_TO_ADDR
67446: GO 67817
67448: LD_INT 31
67450: DOUBLE
67451: EQUAL
67452: IFTRUE 67456
67454: GO 67474
67456: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67457: LD_ADDR_VAR 0 3
67461: PUSH
67462: LD_INT 13
67464: PUSH
67465: LD_INT 14
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: ST_TO_ADDR
67472: GO 67817
67474: LD_INT 26
67476: DOUBLE
67477: EQUAL
67478: IFTRUE 67482
67480: GO 67500
67482: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67483: LD_ADDR_VAR 0 3
67487: PUSH
67488: LD_INT 13
67490: PUSH
67491: LD_INT 14
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: ST_TO_ADDR
67498: GO 67817
67500: LD_INT 42
67502: DOUBLE
67503: EQUAL
67504: IFTRUE 67508
67506: GO 67534
67508: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67509: LD_ADDR_VAR 0 3
67513: PUSH
67514: LD_INT 21
67516: PUSH
67517: LD_INT 22
67519: PUSH
67520: LD_INT 23
67522: PUSH
67523: LD_INT 24
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: ST_TO_ADDR
67532: GO 67817
67534: LD_INT 43
67536: DOUBLE
67537: EQUAL
67538: IFTRUE 67542
67540: GO 67568
67542: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67543: LD_ADDR_VAR 0 3
67547: PUSH
67548: LD_INT 21
67550: PUSH
67551: LD_INT 22
67553: PUSH
67554: LD_INT 23
67556: PUSH
67557: LD_INT 24
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: ST_TO_ADDR
67566: GO 67817
67568: LD_INT 44
67570: DOUBLE
67571: EQUAL
67572: IFTRUE 67576
67574: GO 67602
67576: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67577: LD_ADDR_VAR 0 3
67581: PUSH
67582: LD_INT 21
67584: PUSH
67585: LD_INT 22
67587: PUSH
67588: LD_INT 23
67590: PUSH
67591: LD_INT 24
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: ST_TO_ADDR
67600: GO 67817
67602: LD_INT 45
67604: DOUBLE
67605: EQUAL
67606: IFTRUE 67610
67608: GO 67636
67610: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67611: LD_ADDR_VAR 0 3
67615: PUSH
67616: LD_INT 21
67618: PUSH
67619: LD_INT 22
67621: PUSH
67622: LD_INT 23
67624: PUSH
67625: LD_INT 24
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: ST_TO_ADDR
67634: GO 67817
67636: LD_INT 49
67638: DOUBLE
67639: EQUAL
67640: IFTRUE 67644
67642: GO 67670
67644: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67645: LD_ADDR_VAR 0 3
67649: PUSH
67650: LD_INT 21
67652: PUSH
67653: LD_INT 22
67655: PUSH
67656: LD_INT 23
67658: PUSH
67659: LD_INT 24
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: ST_TO_ADDR
67668: GO 67817
67670: LD_INT 51
67672: DOUBLE
67673: EQUAL
67674: IFTRUE 67678
67676: GO 67704
67678: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67679: LD_ADDR_VAR 0 3
67683: PUSH
67684: LD_INT 21
67686: PUSH
67687: LD_INT 22
67689: PUSH
67690: LD_INT 23
67692: PUSH
67693: LD_INT 24
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: ST_TO_ADDR
67702: GO 67817
67704: LD_INT 52
67706: DOUBLE
67707: EQUAL
67708: IFTRUE 67712
67710: GO 67738
67712: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67713: LD_ADDR_VAR 0 3
67717: PUSH
67718: LD_INT 21
67720: PUSH
67721: LD_INT 22
67723: PUSH
67724: LD_INT 23
67726: PUSH
67727: LD_INT 24
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: ST_TO_ADDR
67736: GO 67817
67738: LD_INT 53
67740: DOUBLE
67741: EQUAL
67742: IFTRUE 67746
67744: GO 67764
67746: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67747: LD_ADDR_VAR 0 3
67751: PUSH
67752: LD_INT 23
67754: PUSH
67755: LD_INT 24
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: ST_TO_ADDR
67762: GO 67817
67764: LD_INT 46
67766: DOUBLE
67767: EQUAL
67768: IFTRUE 67772
67770: GO 67790
67772: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67773: LD_ADDR_VAR 0 3
67777: PUSH
67778: LD_INT 23
67780: PUSH
67781: LD_INT 24
67783: PUSH
67784: EMPTY
67785: LIST
67786: LIST
67787: ST_TO_ADDR
67788: GO 67817
67790: LD_INT 47
67792: DOUBLE
67793: EQUAL
67794: IFTRUE 67798
67796: GO 67816
67798: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67799: LD_ADDR_VAR 0 3
67803: PUSH
67804: LD_INT 23
67806: PUSH
67807: LD_INT 24
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: ST_TO_ADDR
67814: GO 67817
67816: POP
// result := ( chassis in result ) ;
67817: LD_ADDR_VAR 0 3
67821: PUSH
67822: LD_VAR 0 1
67826: PUSH
67827: LD_VAR 0 3
67831: IN
67832: ST_TO_ADDR
// end ;
67833: LD_VAR 0 3
67837: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67838: LD_INT 0
67840: PPUSH
67841: PPUSH
67842: PPUSH
67843: PPUSH
67844: PPUSH
67845: PPUSH
67846: PPUSH
// result := array ;
67847: LD_ADDR_VAR 0 5
67851: PUSH
67852: LD_VAR 0 1
67856: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67857: LD_VAR 0 1
67861: NOT
67862: PUSH
67863: LD_VAR 0 2
67867: NOT
67868: OR
67869: PUSH
67870: LD_VAR 0 3
67874: NOT
67875: OR
67876: PUSH
67877: LD_VAR 0 2
67881: PUSH
67882: LD_VAR 0 1
67886: GREATER
67887: OR
67888: PUSH
67889: LD_VAR 0 3
67893: PUSH
67894: LD_VAR 0 1
67898: GREATER
67899: OR
67900: IFFALSE 67904
// exit ;
67902: GO 68200
// if direction then
67904: LD_VAR 0 4
67908: IFFALSE 67972
// begin d := 1 ;
67910: LD_ADDR_VAR 0 9
67914: PUSH
67915: LD_INT 1
67917: ST_TO_ADDR
// if i_from > i_to then
67918: LD_VAR 0 2
67922: PUSH
67923: LD_VAR 0 3
67927: GREATER
67928: IFFALSE 67954
// length := ( array - i_from ) + i_to else
67930: LD_ADDR_VAR 0 11
67934: PUSH
67935: LD_VAR 0 1
67939: PUSH
67940: LD_VAR 0 2
67944: MINUS
67945: PUSH
67946: LD_VAR 0 3
67950: PLUS
67951: ST_TO_ADDR
67952: GO 67970
// length := i_to - i_from ;
67954: LD_ADDR_VAR 0 11
67958: PUSH
67959: LD_VAR 0 3
67963: PUSH
67964: LD_VAR 0 2
67968: MINUS
67969: ST_TO_ADDR
// end else
67970: GO 68033
// begin d := - 1 ;
67972: LD_ADDR_VAR 0 9
67976: PUSH
67977: LD_INT 1
67979: NEG
67980: ST_TO_ADDR
// if i_from > i_to then
67981: LD_VAR 0 2
67985: PUSH
67986: LD_VAR 0 3
67990: GREATER
67991: IFFALSE 68011
// length := i_from - i_to else
67993: LD_ADDR_VAR 0 11
67997: PUSH
67998: LD_VAR 0 2
68002: PUSH
68003: LD_VAR 0 3
68007: MINUS
68008: ST_TO_ADDR
68009: GO 68033
// length := ( array - i_to ) + i_from ;
68011: LD_ADDR_VAR 0 11
68015: PUSH
68016: LD_VAR 0 1
68020: PUSH
68021: LD_VAR 0 3
68025: MINUS
68026: PUSH
68027: LD_VAR 0 2
68031: PLUS
68032: ST_TO_ADDR
// end ; if not length then
68033: LD_VAR 0 11
68037: NOT
68038: IFFALSE 68042
// exit ;
68040: GO 68200
// tmp := array ;
68042: LD_ADDR_VAR 0 10
68046: PUSH
68047: LD_VAR 0 1
68051: ST_TO_ADDR
// for i = 1 to length do
68052: LD_ADDR_VAR 0 6
68056: PUSH
68057: DOUBLE
68058: LD_INT 1
68060: DEC
68061: ST_TO_ADDR
68062: LD_VAR 0 11
68066: PUSH
68067: FOR_TO
68068: IFFALSE 68188
// begin for j = 1 to array do
68070: LD_ADDR_VAR 0 7
68074: PUSH
68075: DOUBLE
68076: LD_INT 1
68078: DEC
68079: ST_TO_ADDR
68080: LD_VAR 0 1
68084: PUSH
68085: FOR_TO
68086: IFFALSE 68174
// begin k := j + d ;
68088: LD_ADDR_VAR 0 8
68092: PUSH
68093: LD_VAR 0 7
68097: PUSH
68098: LD_VAR 0 9
68102: PLUS
68103: ST_TO_ADDR
// if k > array then
68104: LD_VAR 0 8
68108: PUSH
68109: LD_VAR 0 1
68113: GREATER
68114: IFFALSE 68124
// k := 1 ;
68116: LD_ADDR_VAR 0 8
68120: PUSH
68121: LD_INT 1
68123: ST_TO_ADDR
// if not k then
68124: LD_VAR 0 8
68128: NOT
68129: IFFALSE 68141
// k := array ;
68131: LD_ADDR_VAR 0 8
68135: PUSH
68136: LD_VAR 0 1
68140: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68141: LD_ADDR_VAR 0 10
68145: PUSH
68146: LD_VAR 0 10
68150: PPUSH
68151: LD_VAR 0 8
68155: PPUSH
68156: LD_VAR 0 1
68160: PUSH
68161: LD_VAR 0 7
68165: ARRAY
68166: PPUSH
68167: CALL_OW 1
68171: ST_TO_ADDR
// end ;
68172: GO 68085
68174: POP
68175: POP
// array := tmp ;
68176: LD_ADDR_VAR 0 1
68180: PUSH
68181: LD_VAR 0 10
68185: ST_TO_ADDR
// end ;
68186: GO 68067
68188: POP
68189: POP
// result := array ;
68190: LD_ADDR_VAR 0 5
68194: PUSH
68195: LD_VAR 0 1
68199: ST_TO_ADDR
// end ;
68200: LD_VAR 0 5
68204: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68205: LD_INT 0
68207: PPUSH
68208: PPUSH
// result := 0 ;
68209: LD_ADDR_VAR 0 3
68213: PUSH
68214: LD_INT 0
68216: ST_TO_ADDR
// if not array or not value in array then
68217: LD_VAR 0 1
68221: NOT
68222: PUSH
68223: LD_VAR 0 2
68227: PUSH
68228: LD_VAR 0 1
68232: IN
68233: NOT
68234: OR
68235: IFFALSE 68239
// exit ;
68237: GO 68293
// for i = 1 to array do
68239: LD_ADDR_VAR 0 4
68243: PUSH
68244: DOUBLE
68245: LD_INT 1
68247: DEC
68248: ST_TO_ADDR
68249: LD_VAR 0 1
68253: PUSH
68254: FOR_TO
68255: IFFALSE 68291
// if value = array [ i ] then
68257: LD_VAR 0 2
68261: PUSH
68262: LD_VAR 0 1
68266: PUSH
68267: LD_VAR 0 4
68271: ARRAY
68272: EQUAL
68273: IFFALSE 68289
// begin result := i ;
68275: LD_ADDR_VAR 0 3
68279: PUSH
68280: LD_VAR 0 4
68284: ST_TO_ADDR
// exit ;
68285: POP
68286: POP
68287: GO 68293
// end ;
68289: GO 68254
68291: POP
68292: POP
// end ;
68293: LD_VAR 0 3
68297: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68298: LD_INT 0
68300: PPUSH
// vc_chassis := chassis ;
68301: LD_ADDR_OWVAR 37
68305: PUSH
68306: LD_VAR 0 1
68310: ST_TO_ADDR
// vc_engine := engine ;
68311: LD_ADDR_OWVAR 39
68315: PUSH
68316: LD_VAR 0 2
68320: ST_TO_ADDR
// vc_control := control ;
68321: LD_ADDR_OWVAR 38
68325: PUSH
68326: LD_VAR 0 3
68330: ST_TO_ADDR
// vc_weapon := weapon ;
68331: LD_ADDR_OWVAR 40
68335: PUSH
68336: LD_VAR 0 4
68340: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68341: LD_ADDR_OWVAR 41
68345: PUSH
68346: LD_VAR 0 5
68350: ST_TO_ADDR
// end ;
68351: LD_VAR 0 6
68355: RET
// export function WantPlant ( unit ) ; var task ; begin
68356: LD_INT 0
68358: PPUSH
68359: PPUSH
// result := false ;
68360: LD_ADDR_VAR 0 2
68364: PUSH
68365: LD_INT 0
68367: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68368: LD_ADDR_VAR 0 3
68372: PUSH
68373: LD_VAR 0 1
68377: PPUSH
68378: CALL_OW 437
68382: ST_TO_ADDR
// if task then
68383: LD_VAR 0 3
68387: IFFALSE 68415
// if task [ 1 ] [ 1 ] = p then
68389: LD_VAR 0 3
68393: PUSH
68394: LD_INT 1
68396: ARRAY
68397: PUSH
68398: LD_INT 1
68400: ARRAY
68401: PUSH
68402: LD_STRING p
68404: EQUAL
68405: IFFALSE 68415
// result := true ;
68407: LD_ADDR_VAR 0 2
68411: PUSH
68412: LD_INT 1
68414: ST_TO_ADDR
// end ;
68415: LD_VAR 0 2
68419: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68420: LD_INT 0
68422: PPUSH
68423: PPUSH
68424: PPUSH
68425: PPUSH
// if pos < 1 then
68426: LD_VAR 0 2
68430: PUSH
68431: LD_INT 1
68433: LESS
68434: IFFALSE 68438
// exit ;
68436: GO 68741
// if pos = 1 then
68438: LD_VAR 0 2
68442: PUSH
68443: LD_INT 1
68445: EQUAL
68446: IFFALSE 68479
// result := Replace ( arr , pos [ 1 ] , value ) else
68448: LD_ADDR_VAR 0 4
68452: PUSH
68453: LD_VAR 0 1
68457: PPUSH
68458: LD_VAR 0 2
68462: PUSH
68463: LD_INT 1
68465: ARRAY
68466: PPUSH
68467: LD_VAR 0 3
68471: PPUSH
68472: CALL_OW 1
68476: ST_TO_ADDR
68477: GO 68741
// begin tmp := arr ;
68479: LD_ADDR_VAR 0 6
68483: PUSH
68484: LD_VAR 0 1
68488: ST_TO_ADDR
// s_arr := [ tmp ] ;
68489: LD_ADDR_VAR 0 7
68493: PUSH
68494: LD_VAR 0 6
68498: PUSH
68499: EMPTY
68500: LIST
68501: ST_TO_ADDR
// for i = 1 to pos - 1 do
68502: LD_ADDR_VAR 0 5
68506: PUSH
68507: DOUBLE
68508: LD_INT 1
68510: DEC
68511: ST_TO_ADDR
68512: LD_VAR 0 2
68516: PUSH
68517: LD_INT 1
68519: MINUS
68520: PUSH
68521: FOR_TO
68522: IFFALSE 68567
// begin tmp := tmp [ pos [ i ] ] ;
68524: LD_ADDR_VAR 0 6
68528: PUSH
68529: LD_VAR 0 6
68533: PUSH
68534: LD_VAR 0 2
68538: PUSH
68539: LD_VAR 0 5
68543: ARRAY
68544: ARRAY
68545: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68546: LD_ADDR_VAR 0 7
68550: PUSH
68551: LD_VAR 0 7
68555: PUSH
68556: LD_VAR 0 6
68560: PUSH
68561: EMPTY
68562: LIST
68563: ADD
68564: ST_TO_ADDR
// end ;
68565: GO 68521
68567: POP
68568: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68569: LD_ADDR_VAR 0 6
68573: PUSH
68574: LD_VAR 0 6
68578: PPUSH
68579: LD_VAR 0 2
68583: PUSH
68584: LD_VAR 0 2
68588: ARRAY
68589: PPUSH
68590: LD_VAR 0 3
68594: PPUSH
68595: CALL_OW 1
68599: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68600: LD_ADDR_VAR 0 7
68604: PUSH
68605: LD_VAR 0 7
68609: PPUSH
68610: LD_VAR 0 7
68614: PPUSH
68615: LD_VAR 0 6
68619: PPUSH
68620: CALL_OW 1
68624: ST_TO_ADDR
// for i = s_arr downto 2 do
68625: LD_ADDR_VAR 0 5
68629: PUSH
68630: DOUBLE
68631: LD_VAR 0 7
68635: INC
68636: ST_TO_ADDR
68637: LD_INT 2
68639: PUSH
68640: FOR_DOWNTO
68641: IFFALSE 68725
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68643: LD_ADDR_VAR 0 6
68647: PUSH
68648: LD_VAR 0 7
68652: PUSH
68653: LD_VAR 0 5
68657: PUSH
68658: LD_INT 1
68660: MINUS
68661: ARRAY
68662: PPUSH
68663: LD_VAR 0 2
68667: PUSH
68668: LD_VAR 0 5
68672: PUSH
68673: LD_INT 1
68675: MINUS
68676: ARRAY
68677: PPUSH
68678: LD_VAR 0 7
68682: PUSH
68683: LD_VAR 0 5
68687: ARRAY
68688: PPUSH
68689: CALL_OW 1
68693: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68694: LD_ADDR_VAR 0 7
68698: PUSH
68699: LD_VAR 0 7
68703: PPUSH
68704: LD_VAR 0 5
68708: PUSH
68709: LD_INT 1
68711: MINUS
68712: PPUSH
68713: LD_VAR 0 6
68717: PPUSH
68718: CALL_OW 1
68722: ST_TO_ADDR
// end ;
68723: GO 68640
68725: POP
68726: POP
// result := s_arr [ 1 ] ;
68727: LD_ADDR_VAR 0 4
68731: PUSH
68732: LD_VAR 0 7
68736: PUSH
68737: LD_INT 1
68739: ARRAY
68740: ST_TO_ADDR
// end ; end ;
68741: LD_VAR 0 4
68745: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68746: LD_INT 0
68748: PPUSH
68749: PPUSH
// if not list then
68750: LD_VAR 0 1
68754: NOT
68755: IFFALSE 68759
// exit ;
68757: GO 68850
// i := list [ pos1 ] ;
68759: LD_ADDR_VAR 0 5
68763: PUSH
68764: LD_VAR 0 1
68768: PUSH
68769: LD_VAR 0 2
68773: ARRAY
68774: ST_TO_ADDR
// if not i then
68775: LD_VAR 0 5
68779: NOT
68780: IFFALSE 68784
// exit ;
68782: GO 68850
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68784: LD_ADDR_VAR 0 1
68788: PUSH
68789: LD_VAR 0 1
68793: PPUSH
68794: LD_VAR 0 2
68798: PPUSH
68799: LD_VAR 0 1
68803: PUSH
68804: LD_VAR 0 3
68808: ARRAY
68809: PPUSH
68810: CALL_OW 1
68814: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68815: LD_ADDR_VAR 0 1
68819: PUSH
68820: LD_VAR 0 1
68824: PPUSH
68825: LD_VAR 0 3
68829: PPUSH
68830: LD_VAR 0 5
68834: PPUSH
68835: CALL_OW 1
68839: ST_TO_ADDR
// result := list ;
68840: LD_ADDR_VAR 0 4
68844: PUSH
68845: LD_VAR 0 1
68849: ST_TO_ADDR
// end ;
68850: LD_VAR 0 4
68854: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68855: LD_INT 0
68857: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68858: LD_ADDR_VAR 0 5
68862: PUSH
68863: LD_VAR 0 1
68867: PPUSH
68868: CALL_OW 250
68872: PPUSH
68873: LD_VAR 0 1
68877: PPUSH
68878: CALL_OW 251
68882: PPUSH
68883: LD_VAR 0 2
68887: PPUSH
68888: LD_VAR 0 3
68892: PPUSH
68893: LD_VAR 0 4
68897: PPUSH
68898: CALL 68908 0 5
68902: ST_TO_ADDR
// end ;
68903: LD_VAR 0 5
68907: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68908: LD_INT 0
68910: PPUSH
68911: PPUSH
68912: PPUSH
68913: PPUSH
// if not list then
68914: LD_VAR 0 3
68918: NOT
68919: IFFALSE 68923
// exit ;
68921: GO 69311
// result := [ ] ;
68923: LD_ADDR_VAR 0 6
68927: PUSH
68928: EMPTY
68929: ST_TO_ADDR
// for i in list do
68930: LD_ADDR_VAR 0 7
68934: PUSH
68935: LD_VAR 0 3
68939: PUSH
68940: FOR_IN
68941: IFFALSE 69143
// begin tmp := GetDistUnitXY ( i , x , y ) ;
68943: LD_ADDR_VAR 0 9
68947: PUSH
68948: LD_VAR 0 7
68952: PPUSH
68953: LD_VAR 0 1
68957: PPUSH
68958: LD_VAR 0 2
68962: PPUSH
68963: CALL_OW 297
68967: ST_TO_ADDR
// if not result then
68968: LD_VAR 0 6
68972: NOT
68973: IFFALSE 68999
// result := [ [ i , tmp ] ] else
68975: LD_ADDR_VAR 0 6
68979: PUSH
68980: LD_VAR 0 7
68984: PUSH
68985: LD_VAR 0 9
68989: PUSH
68990: EMPTY
68991: LIST
68992: LIST
68993: PUSH
68994: EMPTY
68995: LIST
68996: ST_TO_ADDR
68997: GO 69141
// begin if result [ result ] [ 2 ] < tmp then
68999: LD_VAR 0 6
69003: PUSH
69004: LD_VAR 0 6
69008: ARRAY
69009: PUSH
69010: LD_INT 2
69012: ARRAY
69013: PUSH
69014: LD_VAR 0 9
69018: LESS
69019: IFFALSE 69061
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69021: LD_ADDR_VAR 0 6
69025: PUSH
69026: LD_VAR 0 6
69030: PPUSH
69031: LD_VAR 0 6
69035: PUSH
69036: LD_INT 1
69038: PLUS
69039: PPUSH
69040: LD_VAR 0 7
69044: PUSH
69045: LD_VAR 0 9
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PPUSH
69054: CALL_OW 2
69058: ST_TO_ADDR
69059: GO 69141
// for j = 1 to result do
69061: LD_ADDR_VAR 0 8
69065: PUSH
69066: DOUBLE
69067: LD_INT 1
69069: DEC
69070: ST_TO_ADDR
69071: LD_VAR 0 6
69075: PUSH
69076: FOR_TO
69077: IFFALSE 69139
// begin if tmp < result [ j ] [ 2 ] then
69079: LD_VAR 0 9
69083: PUSH
69084: LD_VAR 0 6
69088: PUSH
69089: LD_VAR 0 8
69093: ARRAY
69094: PUSH
69095: LD_INT 2
69097: ARRAY
69098: LESS
69099: IFFALSE 69137
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69101: LD_ADDR_VAR 0 6
69105: PUSH
69106: LD_VAR 0 6
69110: PPUSH
69111: LD_VAR 0 8
69115: PPUSH
69116: LD_VAR 0 7
69120: PUSH
69121: LD_VAR 0 9
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PPUSH
69130: CALL_OW 2
69134: ST_TO_ADDR
// break ;
69135: GO 69139
// end ; end ;
69137: GO 69076
69139: POP
69140: POP
// end ; end ;
69141: GO 68940
69143: POP
69144: POP
// if result and not asc then
69145: LD_VAR 0 6
69149: PUSH
69150: LD_VAR 0 4
69154: NOT
69155: AND
69156: IFFALSE 69231
// begin tmp := result ;
69158: LD_ADDR_VAR 0 9
69162: PUSH
69163: LD_VAR 0 6
69167: ST_TO_ADDR
// for i = tmp downto 1 do
69168: LD_ADDR_VAR 0 7
69172: PUSH
69173: DOUBLE
69174: LD_VAR 0 9
69178: INC
69179: ST_TO_ADDR
69180: LD_INT 1
69182: PUSH
69183: FOR_DOWNTO
69184: IFFALSE 69229
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69186: LD_ADDR_VAR 0 6
69190: PUSH
69191: LD_VAR 0 6
69195: PPUSH
69196: LD_VAR 0 9
69200: PUSH
69201: LD_VAR 0 7
69205: MINUS
69206: PUSH
69207: LD_INT 1
69209: PLUS
69210: PPUSH
69211: LD_VAR 0 9
69215: PUSH
69216: LD_VAR 0 7
69220: ARRAY
69221: PPUSH
69222: CALL_OW 1
69226: ST_TO_ADDR
69227: GO 69183
69229: POP
69230: POP
// end ; tmp := [ ] ;
69231: LD_ADDR_VAR 0 9
69235: PUSH
69236: EMPTY
69237: ST_TO_ADDR
// if mode then
69238: LD_VAR 0 5
69242: IFFALSE 69311
// begin for i = 1 to result do
69244: LD_ADDR_VAR 0 7
69248: PUSH
69249: DOUBLE
69250: LD_INT 1
69252: DEC
69253: ST_TO_ADDR
69254: LD_VAR 0 6
69258: PUSH
69259: FOR_TO
69260: IFFALSE 69299
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69262: LD_ADDR_VAR 0 9
69266: PUSH
69267: LD_VAR 0 9
69271: PPUSH
69272: LD_VAR 0 7
69276: PPUSH
69277: LD_VAR 0 6
69281: PUSH
69282: LD_VAR 0 7
69286: ARRAY
69287: PUSH
69288: LD_INT 1
69290: ARRAY
69291: PPUSH
69292: CALL_OW 1
69296: ST_TO_ADDR
69297: GO 69259
69299: POP
69300: POP
// result := tmp ;
69301: LD_ADDR_VAR 0 6
69305: PUSH
69306: LD_VAR 0 9
69310: ST_TO_ADDR
// end ; end ;
69311: LD_VAR 0 6
69315: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69316: LD_INT 0
69318: PPUSH
69319: PPUSH
69320: PPUSH
69321: PPUSH
69322: PPUSH
69323: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69324: LD_ADDR_VAR 0 5
69328: PUSH
69329: LD_INT 0
69331: PUSH
69332: LD_INT 0
69334: PUSH
69335: LD_INT 0
69337: PUSH
69338: EMPTY
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: ST_TO_ADDR
// if not x or not y then
69346: LD_VAR 0 2
69350: NOT
69351: PUSH
69352: LD_VAR 0 3
69356: NOT
69357: OR
69358: IFFALSE 69362
// exit ;
69360: GO 71008
// if not range then
69362: LD_VAR 0 4
69366: NOT
69367: IFFALSE 69377
// range := 10 ;
69369: LD_ADDR_VAR 0 4
69373: PUSH
69374: LD_INT 10
69376: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69377: LD_ADDR_VAR 0 8
69381: PUSH
69382: LD_INT 81
69384: PUSH
69385: LD_VAR 0 1
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 92
69396: PUSH
69397: LD_VAR 0 2
69401: PUSH
69402: LD_VAR 0 3
69406: PUSH
69407: LD_VAR 0 4
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 3
69420: PUSH
69421: LD_INT 21
69423: PUSH
69424: LD_INT 3
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: LIST
69439: PPUSH
69440: CALL_OW 69
69444: ST_TO_ADDR
// if not tmp then
69445: LD_VAR 0 8
69449: NOT
69450: IFFALSE 69454
// exit ;
69452: GO 71008
// for i in tmp do
69454: LD_ADDR_VAR 0 6
69458: PUSH
69459: LD_VAR 0 8
69463: PUSH
69464: FOR_IN
69465: IFFALSE 70983
// begin points := [ 0 , 0 , 0 ] ;
69467: LD_ADDR_VAR 0 9
69471: PUSH
69472: LD_INT 0
69474: PUSH
69475: LD_INT 0
69477: PUSH
69478: LD_INT 0
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: LIST
69485: ST_TO_ADDR
// bpoints := 1 ;
69486: LD_ADDR_VAR 0 10
69490: PUSH
69491: LD_INT 1
69493: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69494: LD_VAR 0 6
69498: PPUSH
69499: CALL_OW 247
69503: PUSH
69504: LD_INT 1
69506: DOUBLE
69507: EQUAL
69508: IFTRUE 69512
69510: GO 70090
69512: POP
// begin if GetClass ( i ) = 1 then
69513: LD_VAR 0 6
69517: PPUSH
69518: CALL_OW 257
69522: PUSH
69523: LD_INT 1
69525: EQUAL
69526: IFFALSE 69547
// points := [ 10 , 5 , 3 ] ;
69528: LD_ADDR_VAR 0 9
69532: PUSH
69533: LD_INT 10
69535: PUSH
69536: LD_INT 5
69538: PUSH
69539: LD_INT 3
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: LIST
69546: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69547: LD_VAR 0 6
69551: PPUSH
69552: CALL_OW 257
69556: PUSH
69557: LD_INT 2
69559: PUSH
69560: LD_INT 3
69562: PUSH
69563: LD_INT 4
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: LIST
69570: IN
69571: IFFALSE 69592
// points := [ 3 , 2 , 1 ] ;
69573: LD_ADDR_VAR 0 9
69577: PUSH
69578: LD_INT 3
69580: PUSH
69581: LD_INT 2
69583: PUSH
69584: LD_INT 1
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: LIST
69591: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69592: LD_VAR 0 6
69596: PPUSH
69597: CALL_OW 257
69601: PUSH
69602: LD_INT 5
69604: EQUAL
69605: IFFALSE 69626
// points := [ 130 , 5 , 2 ] ;
69607: LD_ADDR_VAR 0 9
69611: PUSH
69612: LD_INT 130
69614: PUSH
69615: LD_INT 5
69617: PUSH
69618: LD_INT 2
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: LIST
69625: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69626: LD_VAR 0 6
69630: PPUSH
69631: CALL_OW 257
69635: PUSH
69636: LD_INT 8
69638: EQUAL
69639: IFFALSE 69660
// points := [ 35 , 35 , 30 ] ;
69641: LD_ADDR_VAR 0 9
69645: PUSH
69646: LD_INT 35
69648: PUSH
69649: LD_INT 35
69651: PUSH
69652: LD_INT 30
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: LIST
69659: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69660: LD_VAR 0 6
69664: PPUSH
69665: CALL_OW 257
69669: PUSH
69670: LD_INT 9
69672: EQUAL
69673: IFFALSE 69694
// points := [ 20 , 55 , 40 ] ;
69675: LD_ADDR_VAR 0 9
69679: PUSH
69680: LD_INT 20
69682: PUSH
69683: LD_INT 55
69685: PUSH
69686: LD_INT 40
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: LIST
69693: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69694: LD_VAR 0 6
69698: PPUSH
69699: CALL_OW 257
69703: PUSH
69704: LD_INT 12
69706: PUSH
69707: LD_INT 16
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: IN
69714: IFFALSE 69735
// points := [ 5 , 3 , 2 ] ;
69716: LD_ADDR_VAR 0 9
69720: PUSH
69721: LD_INT 5
69723: PUSH
69724: LD_INT 3
69726: PUSH
69727: LD_INT 2
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: LIST
69734: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69735: LD_VAR 0 6
69739: PPUSH
69740: CALL_OW 257
69744: PUSH
69745: LD_INT 17
69747: EQUAL
69748: IFFALSE 69769
// points := [ 100 , 50 , 75 ] ;
69750: LD_ADDR_VAR 0 9
69754: PUSH
69755: LD_INT 100
69757: PUSH
69758: LD_INT 50
69760: PUSH
69761: LD_INT 75
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: LIST
69768: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69769: LD_VAR 0 6
69773: PPUSH
69774: CALL_OW 257
69778: PUSH
69779: LD_INT 15
69781: EQUAL
69782: IFFALSE 69803
// points := [ 10 , 5 , 3 ] ;
69784: LD_ADDR_VAR 0 9
69788: PUSH
69789: LD_INT 10
69791: PUSH
69792: LD_INT 5
69794: PUSH
69795: LD_INT 3
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: LIST
69802: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69803: LD_VAR 0 6
69807: PPUSH
69808: CALL_OW 257
69812: PUSH
69813: LD_INT 14
69815: EQUAL
69816: IFFALSE 69837
// points := [ 10 , 0 , 0 ] ;
69818: LD_ADDR_VAR 0 9
69822: PUSH
69823: LD_INT 10
69825: PUSH
69826: LD_INT 0
69828: PUSH
69829: LD_INT 0
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: LIST
69836: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69837: LD_VAR 0 6
69841: PPUSH
69842: CALL_OW 257
69846: PUSH
69847: LD_INT 11
69849: EQUAL
69850: IFFALSE 69871
// points := [ 30 , 10 , 5 ] ;
69852: LD_ADDR_VAR 0 9
69856: PUSH
69857: LD_INT 30
69859: PUSH
69860: LD_INT 10
69862: PUSH
69863: LD_INT 5
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: LIST
69870: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69871: LD_VAR 0 1
69875: PPUSH
69876: LD_INT 5
69878: PPUSH
69879: CALL_OW 321
69883: PUSH
69884: LD_INT 2
69886: EQUAL
69887: IFFALSE 69904
// bpoints := bpoints * 1.8 ;
69889: LD_ADDR_VAR 0 10
69893: PUSH
69894: LD_VAR 0 10
69898: PUSH
69899: LD_REAL  1.80000000000000E+0000
69902: MUL
69903: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69904: LD_VAR 0 6
69908: PPUSH
69909: CALL_OW 257
69913: PUSH
69914: LD_INT 1
69916: PUSH
69917: LD_INT 2
69919: PUSH
69920: LD_INT 3
69922: PUSH
69923: LD_INT 4
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: LIST
69930: LIST
69931: IN
69932: PUSH
69933: LD_VAR 0 1
69937: PPUSH
69938: LD_INT 51
69940: PPUSH
69941: CALL_OW 321
69945: PUSH
69946: LD_INT 2
69948: EQUAL
69949: AND
69950: IFFALSE 69967
// bpoints := bpoints * 1.2 ;
69952: LD_ADDR_VAR 0 10
69956: PUSH
69957: LD_VAR 0 10
69961: PUSH
69962: LD_REAL  1.20000000000000E+0000
69965: MUL
69966: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
69967: LD_VAR 0 6
69971: PPUSH
69972: CALL_OW 257
69976: PUSH
69977: LD_INT 5
69979: PUSH
69980: LD_INT 7
69982: PUSH
69983: LD_INT 9
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: LIST
69990: IN
69991: PUSH
69992: LD_VAR 0 1
69996: PPUSH
69997: LD_INT 52
69999: PPUSH
70000: CALL_OW 321
70004: PUSH
70005: LD_INT 2
70007: EQUAL
70008: AND
70009: IFFALSE 70026
// bpoints := bpoints * 1.5 ;
70011: LD_ADDR_VAR 0 10
70015: PUSH
70016: LD_VAR 0 10
70020: PUSH
70021: LD_REAL  1.50000000000000E+0000
70024: MUL
70025: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70026: LD_VAR 0 1
70030: PPUSH
70031: LD_INT 66
70033: PPUSH
70034: CALL_OW 321
70038: PUSH
70039: LD_INT 2
70041: EQUAL
70042: IFFALSE 70059
// bpoints := bpoints * 1.1 ;
70044: LD_ADDR_VAR 0 10
70048: PUSH
70049: LD_VAR 0 10
70053: PUSH
70054: LD_REAL  1.10000000000000E+0000
70057: MUL
70058: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70059: LD_ADDR_VAR 0 10
70063: PUSH
70064: LD_VAR 0 10
70068: PUSH
70069: LD_VAR 0 6
70073: PPUSH
70074: LD_INT 1
70076: PPUSH
70077: CALL_OW 259
70081: PUSH
70082: LD_REAL  1.15000000000000E+0000
70085: MUL
70086: MUL
70087: ST_TO_ADDR
// end ; unit_vehicle :
70088: GO 70912
70090: LD_INT 2
70092: DOUBLE
70093: EQUAL
70094: IFTRUE 70098
70096: GO 70900
70098: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70099: LD_VAR 0 6
70103: PPUSH
70104: CALL_OW 264
70108: PUSH
70109: LD_INT 2
70111: PUSH
70112: LD_INT 42
70114: PUSH
70115: LD_INT 24
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: LIST
70122: IN
70123: IFFALSE 70144
// points := [ 25 , 5 , 3 ] ;
70125: LD_ADDR_VAR 0 9
70129: PUSH
70130: LD_INT 25
70132: PUSH
70133: LD_INT 5
70135: PUSH
70136: LD_INT 3
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: LIST
70143: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70144: LD_VAR 0 6
70148: PPUSH
70149: CALL_OW 264
70153: PUSH
70154: LD_INT 4
70156: PUSH
70157: LD_INT 43
70159: PUSH
70160: LD_INT 25
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: LIST
70167: IN
70168: IFFALSE 70189
// points := [ 40 , 15 , 5 ] ;
70170: LD_ADDR_VAR 0 9
70174: PUSH
70175: LD_INT 40
70177: PUSH
70178: LD_INT 15
70180: PUSH
70181: LD_INT 5
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: LIST
70188: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70189: LD_VAR 0 6
70193: PPUSH
70194: CALL_OW 264
70198: PUSH
70199: LD_INT 3
70201: PUSH
70202: LD_INT 23
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: IN
70209: IFFALSE 70230
// points := [ 7 , 25 , 8 ] ;
70211: LD_ADDR_VAR 0 9
70215: PUSH
70216: LD_INT 7
70218: PUSH
70219: LD_INT 25
70221: PUSH
70222: LD_INT 8
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: LIST
70229: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70230: LD_VAR 0 6
70234: PPUSH
70235: CALL_OW 264
70239: PUSH
70240: LD_INT 5
70242: PUSH
70243: LD_INT 27
70245: PUSH
70246: LD_INT 44
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: LIST
70253: IN
70254: IFFALSE 70275
// points := [ 14 , 50 , 16 ] ;
70256: LD_ADDR_VAR 0 9
70260: PUSH
70261: LD_INT 14
70263: PUSH
70264: LD_INT 50
70266: PUSH
70267: LD_INT 16
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: LIST
70274: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70275: LD_VAR 0 6
70279: PPUSH
70280: CALL_OW 264
70284: PUSH
70285: LD_INT 6
70287: PUSH
70288: LD_INT 46
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: IN
70295: IFFALSE 70316
// points := [ 32 , 120 , 70 ] ;
70297: LD_ADDR_VAR 0 9
70301: PUSH
70302: LD_INT 32
70304: PUSH
70305: LD_INT 120
70307: PUSH
70308: LD_INT 70
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: LIST
70315: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
70316: LD_VAR 0 6
70320: PPUSH
70321: CALL_OW 264
70325: PUSH
70326: LD_INT 7
70328: PUSH
70329: LD_INT 28
70331: PUSH
70332: LD_INT 45
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: LIST
70339: IN
70340: IFFALSE 70361
// points := [ 35 , 20 , 45 ] ;
70342: LD_ADDR_VAR 0 9
70346: PUSH
70347: LD_INT 35
70349: PUSH
70350: LD_INT 20
70352: PUSH
70353: LD_INT 45
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: LIST
70360: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70361: LD_VAR 0 6
70365: PPUSH
70366: CALL_OW 264
70370: PUSH
70371: LD_INT 47
70373: PUSH
70374: EMPTY
70375: LIST
70376: IN
70377: IFFALSE 70398
// points := [ 67 , 45 , 75 ] ;
70379: LD_ADDR_VAR 0 9
70383: PUSH
70384: LD_INT 67
70386: PUSH
70387: LD_INT 45
70389: PUSH
70390: LD_INT 75
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: LIST
70397: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70398: LD_VAR 0 6
70402: PPUSH
70403: CALL_OW 264
70407: PUSH
70408: LD_INT 26
70410: PUSH
70411: EMPTY
70412: LIST
70413: IN
70414: IFFALSE 70435
// points := [ 120 , 30 , 80 ] ;
70416: LD_ADDR_VAR 0 9
70420: PUSH
70421: LD_INT 120
70423: PUSH
70424: LD_INT 30
70426: PUSH
70427: LD_INT 80
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: LIST
70434: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70435: LD_VAR 0 6
70439: PPUSH
70440: CALL_OW 264
70444: PUSH
70445: LD_INT 22
70447: PUSH
70448: EMPTY
70449: LIST
70450: IN
70451: IFFALSE 70472
// points := [ 40 , 1 , 1 ] ;
70453: LD_ADDR_VAR 0 9
70457: PUSH
70458: LD_INT 40
70460: PUSH
70461: LD_INT 1
70463: PUSH
70464: LD_INT 1
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: LIST
70471: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70472: LD_VAR 0 6
70476: PPUSH
70477: CALL_OW 264
70481: PUSH
70482: LD_INT 29
70484: PUSH
70485: EMPTY
70486: LIST
70487: IN
70488: IFFALSE 70509
// points := [ 70 , 200 , 400 ] ;
70490: LD_ADDR_VAR 0 9
70494: PUSH
70495: LD_INT 70
70497: PUSH
70498: LD_INT 200
70500: PUSH
70501: LD_INT 400
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: LIST
70508: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70509: LD_VAR 0 6
70513: PPUSH
70514: CALL_OW 264
70518: PUSH
70519: LD_INT 14
70521: PUSH
70522: LD_INT 53
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: IN
70529: IFFALSE 70550
// points := [ 40 , 10 , 20 ] ;
70531: LD_ADDR_VAR 0 9
70535: PUSH
70536: LD_INT 40
70538: PUSH
70539: LD_INT 10
70541: PUSH
70542: LD_INT 20
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: LIST
70549: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70550: LD_VAR 0 6
70554: PPUSH
70555: CALL_OW 264
70559: PUSH
70560: LD_INT 9
70562: PUSH
70563: EMPTY
70564: LIST
70565: IN
70566: IFFALSE 70587
// points := [ 5 , 70 , 20 ] ;
70568: LD_ADDR_VAR 0 9
70572: PUSH
70573: LD_INT 5
70575: PUSH
70576: LD_INT 70
70578: PUSH
70579: LD_INT 20
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: LIST
70586: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70587: LD_VAR 0 6
70591: PPUSH
70592: CALL_OW 264
70596: PUSH
70597: LD_INT 10
70599: PUSH
70600: EMPTY
70601: LIST
70602: IN
70603: IFFALSE 70624
// points := [ 35 , 110 , 70 ] ;
70605: LD_ADDR_VAR 0 9
70609: PUSH
70610: LD_INT 35
70612: PUSH
70613: LD_INT 110
70615: PUSH
70616: LD_INT 70
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: LIST
70623: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70624: LD_VAR 0 6
70628: PPUSH
70629: CALL_OW 265
70633: PUSH
70634: LD_INT 25
70636: EQUAL
70637: IFFALSE 70658
// points := [ 80 , 65 , 100 ] ;
70639: LD_ADDR_VAR 0 9
70643: PUSH
70644: LD_INT 80
70646: PUSH
70647: LD_INT 65
70649: PUSH
70650: LD_INT 100
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: LIST
70657: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70658: LD_VAR 0 6
70662: PPUSH
70663: CALL_OW 263
70667: PUSH
70668: LD_INT 1
70670: EQUAL
70671: IFFALSE 70706
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70673: LD_ADDR_VAR 0 10
70677: PUSH
70678: LD_VAR 0 10
70682: PUSH
70683: LD_VAR 0 6
70687: PPUSH
70688: CALL_OW 311
70692: PPUSH
70693: LD_INT 3
70695: PPUSH
70696: CALL_OW 259
70700: PUSH
70701: LD_INT 4
70703: MUL
70704: MUL
70705: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70706: LD_VAR 0 6
70710: PPUSH
70711: CALL_OW 263
70715: PUSH
70716: LD_INT 2
70718: EQUAL
70719: IFFALSE 70770
// begin j := IsControledBy ( i ) ;
70721: LD_ADDR_VAR 0 7
70725: PUSH
70726: LD_VAR 0 6
70730: PPUSH
70731: CALL_OW 312
70735: ST_TO_ADDR
// if j then
70736: LD_VAR 0 7
70740: IFFALSE 70770
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70742: LD_ADDR_VAR 0 10
70746: PUSH
70747: LD_VAR 0 10
70751: PUSH
70752: LD_VAR 0 7
70756: PPUSH
70757: LD_INT 3
70759: PPUSH
70760: CALL_OW 259
70764: PUSH
70765: LD_INT 3
70767: MUL
70768: MUL
70769: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70770: LD_VAR 0 6
70774: PPUSH
70775: CALL_OW 264
70779: PUSH
70780: LD_INT 5
70782: PUSH
70783: LD_INT 6
70785: PUSH
70786: LD_INT 46
70788: PUSH
70789: LD_INT 44
70791: PUSH
70792: LD_INT 47
70794: PUSH
70795: LD_INT 45
70797: PUSH
70798: LD_INT 28
70800: PUSH
70801: LD_INT 7
70803: PUSH
70804: LD_INT 27
70806: PUSH
70807: LD_INT 29
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: IN
70822: PUSH
70823: LD_VAR 0 1
70827: PPUSH
70828: LD_INT 52
70830: PPUSH
70831: CALL_OW 321
70835: PUSH
70836: LD_INT 2
70838: EQUAL
70839: AND
70840: IFFALSE 70857
// bpoints := bpoints * 1.2 ;
70842: LD_ADDR_VAR 0 10
70846: PUSH
70847: LD_VAR 0 10
70851: PUSH
70852: LD_REAL  1.20000000000000E+0000
70855: MUL
70856: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70857: LD_VAR 0 6
70861: PPUSH
70862: CALL_OW 264
70866: PUSH
70867: LD_INT 6
70869: PUSH
70870: LD_INT 46
70872: PUSH
70873: LD_INT 47
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: LIST
70880: IN
70881: IFFALSE 70898
// bpoints := bpoints * 1.2 ;
70883: LD_ADDR_VAR 0 10
70887: PUSH
70888: LD_VAR 0 10
70892: PUSH
70893: LD_REAL  1.20000000000000E+0000
70896: MUL
70897: ST_TO_ADDR
// end ; unit_building :
70898: GO 70912
70900: LD_INT 3
70902: DOUBLE
70903: EQUAL
70904: IFTRUE 70908
70906: GO 70911
70908: POP
// ; end ;
70909: GO 70912
70911: POP
// for j = 1 to 3 do
70912: LD_ADDR_VAR 0 7
70916: PUSH
70917: DOUBLE
70918: LD_INT 1
70920: DEC
70921: ST_TO_ADDR
70922: LD_INT 3
70924: PUSH
70925: FOR_TO
70926: IFFALSE 70979
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70928: LD_ADDR_VAR 0 5
70932: PUSH
70933: LD_VAR 0 5
70937: PPUSH
70938: LD_VAR 0 7
70942: PPUSH
70943: LD_VAR 0 5
70947: PUSH
70948: LD_VAR 0 7
70952: ARRAY
70953: PUSH
70954: LD_VAR 0 9
70958: PUSH
70959: LD_VAR 0 7
70963: ARRAY
70964: PUSH
70965: LD_VAR 0 10
70969: MUL
70970: PLUS
70971: PPUSH
70972: CALL_OW 1
70976: ST_TO_ADDR
70977: GO 70925
70979: POP
70980: POP
// end ;
70981: GO 69464
70983: POP
70984: POP
// result := Replace ( result , 4 , tmp ) ;
70985: LD_ADDR_VAR 0 5
70989: PUSH
70990: LD_VAR 0 5
70994: PPUSH
70995: LD_INT 4
70997: PPUSH
70998: LD_VAR 0 8
71002: PPUSH
71003: CALL_OW 1
71007: ST_TO_ADDR
// end ;
71008: LD_VAR 0 5
71012: RET
// export function DangerAtRange ( unit , range ) ; begin
71013: LD_INT 0
71015: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71016: LD_ADDR_VAR 0 3
71020: PUSH
71021: LD_VAR 0 1
71025: PPUSH
71026: CALL_OW 255
71030: PPUSH
71031: LD_VAR 0 1
71035: PPUSH
71036: CALL_OW 250
71040: PPUSH
71041: LD_VAR 0 1
71045: PPUSH
71046: CALL_OW 251
71050: PPUSH
71051: LD_VAR 0 2
71055: PPUSH
71056: CALL 69316 0 4
71060: ST_TO_ADDR
// end ;
71061: LD_VAR 0 3
71065: RET
// export function DangerInArea ( side , area ) ; begin
71066: LD_INT 0
71068: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71069: LD_ADDR_VAR 0 3
71073: PUSH
71074: LD_VAR 0 2
71078: PPUSH
71079: LD_INT 81
71081: PUSH
71082: LD_VAR 0 1
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PPUSH
71091: CALL_OW 70
71095: ST_TO_ADDR
// end ;
71096: LD_VAR 0 3
71100: RET
// export function IsExtension ( b ) ; begin
71101: LD_INT 0
71103: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71104: LD_ADDR_VAR 0 2
71108: PUSH
71109: LD_VAR 0 1
71113: PUSH
71114: LD_INT 23
71116: PUSH
71117: LD_INT 20
71119: PUSH
71120: LD_INT 22
71122: PUSH
71123: LD_INT 17
71125: PUSH
71126: LD_INT 24
71128: PUSH
71129: LD_INT 21
71131: PUSH
71132: LD_INT 19
71134: PUSH
71135: LD_INT 16
71137: PUSH
71138: LD_INT 25
71140: PUSH
71141: LD_INT 18
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: IN
71156: ST_TO_ADDR
// end ;
71157: LD_VAR 0 2
71161: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
71162: LD_INT 0
71164: PPUSH
71165: PPUSH
71166: PPUSH
// result := [ ] ;
71167: LD_ADDR_VAR 0 3
71171: PUSH
71172: EMPTY
71173: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71174: LD_ADDR_VAR 0 4
71178: PUSH
71179: LD_VAR 0 2
71183: PPUSH
71184: LD_INT 21
71186: PUSH
71187: LD_INT 3
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PPUSH
71194: CALL_OW 70
71198: ST_TO_ADDR
// if not tmp then
71199: LD_VAR 0 4
71203: NOT
71204: IFFALSE 71208
// exit ;
71206: GO 71266
// for i in tmp do
71208: LD_ADDR_VAR 0 5
71212: PUSH
71213: LD_VAR 0 4
71217: PUSH
71218: FOR_IN
71219: IFFALSE 71254
// if GetBase ( i ) <> base then
71221: LD_VAR 0 5
71225: PPUSH
71226: CALL_OW 274
71230: PUSH
71231: LD_VAR 0 1
71235: NONEQUAL
71236: IFFALSE 71252
// ComLinkToBase ( base , i ) ;
71238: LD_VAR 0 1
71242: PPUSH
71243: LD_VAR 0 5
71247: PPUSH
71248: CALL_OW 169
71252: GO 71218
71254: POP
71255: POP
// result := tmp ;
71256: LD_ADDR_VAR 0 3
71260: PUSH
71261: LD_VAR 0 4
71265: ST_TO_ADDR
// end ;
71266: LD_VAR 0 3
71270: RET
// export function ComComplete ( unit , b ) ; var i ; begin
71271: LD_INT 0
71273: PPUSH
71274: PPUSH
// if BuildingStatus ( b ) = bs_build then
71275: LD_VAR 0 2
71279: PPUSH
71280: CALL_OW 461
71284: PUSH
71285: LD_INT 1
71287: EQUAL
71288: IFFALSE 71348
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71290: LD_VAR 0 1
71294: PPUSH
71295: LD_STRING h
71297: PUSH
71298: LD_VAR 0 2
71302: PPUSH
71303: CALL_OW 250
71307: PUSH
71308: LD_VAR 0 2
71312: PPUSH
71313: CALL_OW 251
71317: PUSH
71318: LD_VAR 0 2
71322: PUSH
71323: LD_INT 0
71325: PUSH
71326: LD_INT 0
71328: PUSH
71329: LD_INT 0
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: PUSH
71341: EMPTY
71342: LIST
71343: PPUSH
71344: CALL_OW 446
// end ;
71348: LD_VAR 0 3
71352: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71353: LD_INT 0
71355: PPUSH
71356: PPUSH
71357: PPUSH
71358: PPUSH
71359: PPUSH
71360: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
71361: LD_VAR 0 1
71365: NOT
71366: PUSH
71367: LD_VAR 0 1
71371: PPUSH
71372: CALL_OW 263
71376: PUSH
71377: LD_INT 2
71379: EQUAL
71380: NOT
71381: OR
71382: IFFALSE 71386
// exit ;
71384: GO 71702
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71386: LD_ADDR_VAR 0 6
71390: PUSH
71391: LD_INT 22
71393: PUSH
71394: LD_VAR 0 1
71398: PPUSH
71399: CALL_OW 255
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 2
71410: PUSH
71411: LD_INT 30
71413: PUSH
71414: LD_INT 36
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 34
71423: PUSH
71424: LD_INT 31
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: LIST
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PPUSH
71440: CALL_OW 69
71444: ST_TO_ADDR
// if not tmp then
71445: LD_VAR 0 6
71449: NOT
71450: IFFALSE 71454
// exit ;
71452: GO 71702
// result := [ ] ;
71454: LD_ADDR_VAR 0 2
71458: PUSH
71459: EMPTY
71460: ST_TO_ADDR
// for i in tmp do
71461: LD_ADDR_VAR 0 3
71465: PUSH
71466: LD_VAR 0 6
71470: PUSH
71471: FOR_IN
71472: IFFALSE 71543
// begin t := UnitsInside ( i ) ;
71474: LD_ADDR_VAR 0 4
71478: PUSH
71479: LD_VAR 0 3
71483: PPUSH
71484: CALL_OW 313
71488: ST_TO_ADDR
// if t then
71489: LD_VAR 0 4
71493: IFFALSE 71541
// for j in t do
71495: LD_ADDR_VAR 0 7
71499: PUSH
71500: LD_VAR 0 4
71504: PUSH
71505: FOR_IN
71506: IFFALSE 71539
// result := Insert ( result , result + 1 , j ) ;
71508: LD_ADDR_VAR 0 2
71512: PUSH
71513: LD_VAR 0 2
71517: PPUSH
71518: LD_VAR 0 2
71522: PUSH
71523: LD_INT 1
71525: PLUS
71526: PPUSH
71527: LD_VAR 0 7
71531: PPUSH
71532: CALL_OW 2
71536: ST_TO_ADDR
71537: GO 71505
71539: POP
71540: POP
// end ;
71541: GO 71471
71543: POP
71544: POP
// if not result then
71545: LD_VAR 0 2
71549: NOT
71550: IFFALSE 71554
// exit ;
71552: GO 71702
// mech := result [ 1 ] ;
71554: LD_ADDR_VAR 0 5
71558: PUSH
71559: LD_VAR 0 2
71563: PUSH
71564: LD_INT 1
71566: ARRAY
71567: ST_TO_ADDR
// if result > 1 then
71568: LD_VAR 0 2
71572: PUSH
71573: LD_INT 1
71575: GREATER
71576: IFFALSE 71688
// for i = 2 to result do
71578: LD_ADDR_VAR 0 3
71582: PUSH
71583: DOUBLE
71584: LD_INT 2
71586: DEC
71587: ST_TO_ADDR
71588: LD_VAR 0 2
71592: PUSH
71593: FOR_TO
71594: IFFALSE 71686
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71596: LD_ADDR_VAR 0 4
71600: PUSH
71601: LD_VAR 0 2
71605: PUSH
71606: LD_VAR 0 3
71610: ARRAY
71611: PPUSH
71612: LD_INT 3
71614: PPUSH
71615: CALL_OW 259
71619: PUSH
71620: LD_VAR 0 2
71624: PUSH
71625: LD_VAR 0 3
71629: ARRAY
71630: PPUSH
71631: CALL_OW 432
71635: MINUS
71636: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71637: LD_VAR 0 4
71641: PUSH
71642: LD_VAR 0 5
71646: PPUSH
71647: LD_INT 3
71649: PPUSH
71650: CALL_OW 259
71654: PUSH
71655: LD_VAR 0 5
71659: PPUSH
71660: CALL_OW 432
71664: MINUS
71665: GREATEREQUAL
71666: IFFALSE 71684
// mech := result [ i ] ;
71668: LD_ADDR_VAR 0 5
71672: PUSH
71673: LD_VAR 0 2
71677: PUSH
71678: LD_VAR 0 3
71682: ARRAY
71683: ST_TO_ADDR
// end ;
71684: GO 71593
71686: POP
71687: POP
// ComLinkTo ( vehicle , mech ) ;
71688: LD_VAR 0 1
71692: PPUSH
71693: LD_VAR 0 5
71697: PPUSH
71698: CALL_OW 135
// end ;
71702: LD_VAR 0 2
71706: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71707: LD_INT 0
71709: PPUSH
71710: PPUSH
71711: PPUSH
71712: PPUSH
71713: PPUSH
71714: PPUSH
71715: PPUSH
71716: PPUSH
71717: PPUSH
71718: PPUSH
71719: PPUSH
71720: PPUSH
71721: PPUSH
// result := [ ] ;
71722: LD_ADDR_VAR 0 7
71726: PUSH
71727: EMPTY
71728: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71729: LD_VAR 0 1
71733: PPUSH
71734: CALL_OW 266
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 1
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: IN
71749: NOT
71750: IFFALSE 71754
// exit ;
71752: GO 73385
// if name then
71754: LD_VAR 0 3
71758: IFFALSE 71774
// SetBName ( base_dep , name ) ;
71760: LD_VAR 0 1
71764: PPUSH
71765: LD_VAR 0 3
71769: PPUSH
71770: CALL_OW 500
// base := GetBase ( base_dep ) ;
71774: LD_ADDR_VAR 0 15
71778: PUSH
71779: LD_VAR 0 1
71783: PPUSH
71784: CALL_OW 274
71788: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71789: LD_ADDR_VAR 0 16
71793: PUSH
71794: LD_VAR 0 1
71798: PPUSH
71799: CALL_OW 255
71803: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71804: LD_ADDR_VAR 0 17
71808: PUSH
71809: LD_VAR 0 1
71813: PPUSH
71814: CALL_OW 248
71818: ST_TO_ADDR
// if sources then
71819: LD_VAR 0 5
71823: IFFALSE 71870
// for i = 1 to 3 do
71825: LD_ADDR_VAR 0 8
71829: PUSH
71830: DOUBLE
71831: LD_INT 1
71833: DEC
71834: ST_TO_ADDR
71835: LD_INT 3
71837: PUSH
71838: FOR_TO
71839: IFFALSE 71868
// AddResourceType ( base , i , sources [ i ] ) ;
71841: LD_VAR 0 15
71845: PPUSH
71846: LD_VAR 0 8
71850: PPUSH
71851: LD_VAR 0 5
71855: PUSH
71856: LD_VAR 0 8
71860: ARRAY
71861: PPUSH
71862: CALL_OW 276
71866: GO 71838
71868: POP
71869: POP
// buildings := GetBaseBuildings ( base , area ) ;
71870: LD_ADDR_VAR 0 18
71874: PUSH
71875: LD_VAR 0 15
71879: PPUSH
71880: LD_VAR 0 2
71884: PPUSH
71885: CALL 71162 0 2
71889: ST_TO_ADDR
// InitHc ;
71890: CALL_OW 19
// InitUc ;
71894: CALL_OW 18
// uc_side := side ;
71898: LD_ADDR_OWVAR 20
71902: PUSH
71903: LD_VAR 0 16
71907: ST_TO_ADDR
// uc_nation := nation ;
71908: LD_ADDR_OWVAR 21
71912: PUSH
71913: LD_VAR 0 17
71917: ST_TO_ADDR
// if buildings then
71918: LD_VAR 0 18
71922: IFFALSE 73244
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
71924: LD_ADDR_VAR 0 19
71928: PUSH
71929: LD_VAR 0 18
71933: PPUSH
71934: LD_INT 2
71936: PUSH
71937: LD_INT 30
71939: PUSH
71940: LD_INT 29
71942: PUSH
71943: EMPTY
71944: LIST
71945: LIST
71946: PUSH
71947: LD_INT 30
71949: PUSH
71950: LD_INT 30
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: LIST
71961: PPUSH
71962: CALL_OW 72
71966: ST_TO_ADDR
// if tmp then
71967: LD_VAR 0 19
71971: IFFALSE 72019
// for i in tmp do
71973: LD_ADDR_VAR 0 8
71977: PUSH
71978: LD_VAR 0 19
71982: PUSH
71983: FOR_IN
71984: IFFALSE 72017
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71986: LD_VAR 0 8
71990: PPUSH
71991: CALL_OW 250
71995: PPUSH
71996: LD_VAR 0 8
72000: PPUSH
72001: CALL_OW 251
72005: PPUSH
72006: LD_VAR 0 16
72010: PPUSH
72011: CALL_OW 441
72015: GO 71983
72017: POP
72018: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72019: LD_VAR 0 18
72023: PPUSH
72024: LD_INT 2
72026: PUSH
72027: LD_INT 30
72029: PUSH
72030: LD_INT 32
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 30
72039: PUSH
72040: LD_INT 33
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: LIST
72051: PPUSH
72052: CALL_OW 72
72056: IFFALSE 72144
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72058: LD_ADDR_VAR 0 8
72062: PUSH
72063: LD_VAR 0 18
72067: PPUSH
72068: LD_INT 2
72070: PUSH
72071: LD_INT 30
72073: PUSH
72074: LD_INT 32
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 30
72083: PUSH
72084: LD_INT 33
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: LIST
72095: PPUSH
72096: CALL_OW 72
72100: PUSH
72101: FOR_IN
72102: IFFALSE 72142
// begin if not GetBWeapon ( i ) then
72104: LD_VAR 0 8
72108: PPUSH
72109: CALL_OW 269
72113: NOT
72114: IFFALSE 72140
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72116: LD_VAR 0 8
72120: PPUSH
72121: LD_VAR 0 8
72125: PPUSH
72126: LD_VAR 0 2
72130: PPUSH
72131: CALL 73390 0 2
72135: PPUSH
72136: CALL_OW 431
// end ;
72140: GO 72101
72142: POP
72143: POP
// end ; for i = 1 to personel do
72144: LD_ADDR_VAR 0 8
72148: PUSH
72149: DOUBLE
72150: LD_INT 1
72152: DEC
72153: ST_TO_ADDR
72154: LD_VAR 0 6
72158: PUSH
72159: FOR_TO
72160: IFFALSE 73224
// begin if i > 4 then
72162: LD_VAR 0 8
72166: PUSH
72167: LD_INT 4
72169: GREATER
72170: IFFALSE 72174
// break ;
72172: GO 73224
// case i of 1 :
72174: LD_VAR 0 8
72178: PUSH
72179: LD_INT 1
72181: DOUBLE
72182: EQUAL
72183: IFTRUE 72187
72185: GO 72267
72187: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72188: LD_ADDR_VAR 0 12
72192: PUSH
72193: LD_VAR 0 18
72197: PPUSH
72198: LD_INT 22
72200: PUSH
72201: LD_VAR 0 16
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 58
72212: PUSH
72213: EMPTY
72214: LIST
72215: PUSH
72216: LD_INT 2
72218: PUSH
72219: LD_INT 30
72221: PUSH
72222: LD_INT 32
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 30
72231: PUSH
72232: LD_INT 4
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 30
72241: PUSH
72242: LD_INT 5
72244: PUSH
72245: EMPTY
72246: LIST
72247: LIST
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: LIST
72259: PPUSH
72260: CALL_OW 72
72264: ST_TO_ADDR
72265: GO 72489
72267: LD_INT 2
72269: DOUBLE
72270: EQUAL
72271: IFTRUE 72275
72273: GO 72337
72275: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72276: LD_ADDR_VAR 0 12
72280: PUSH
72281: LD_VAR 0 18
72285: PPUSH
72286: LD_INT 22
72288: PUSH
72289: LD_VAR 0 16
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 2
72300: PUSH
72301: LD_INT 30
72303: PUSH
72304: LD_INT 0
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 30
72313: PUSH
72314: LD_INT 1
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: LIST
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PPUSH
72330: CALL_OW 72
72334: ST_TO_ADDR
72335: GO 72489
72337: LD_INT 3
72339: DOUBLE
72340: EQUAL
72341: IFTRUE 72345
72343: GO 72407
72345: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72346: LD_ADDR_VAR 0 12
72350: PUSH
72351: LD_VAR 0 18
72355: PPUSH
72356: LD_INT 22
72358: PUSH
72359: LD_VAR 0 16
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 2
72370: PUSH
72371: LD_INT 30
72373: PUSH
72374: LD_INT 2
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 30
72383: PUSH
72384: LD_INT 3
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: LIST
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PPUSH
72400: CALL_OW 72
72404: ST_TO_ADDR
72405: GO 72489
72407: LD_INT 4
72409: DOUBLE
72410: EQUAL
72411: IFTRUE 72415
72413: GO 72488
72415: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72416: LD_ADDR_VAR 0 12
72420: PUSH
72421: LD_VAR 0 18
72425: PPUSH
72426: LD_INT 22
72428: PUSH
72429: LD_VAR 0 16
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 2
72440: PUSH
72441: LD_INT 30
72443: PUSH
72444: LD_INT 6
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 30
72453: PUSH
72454: LD_INT 7
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 30
72463: PUSH
72464: LD_INT 8
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PPUSH
72481: CALL_OW 72
72485: ST_TO_ADDR
72486: GO 72489
72488: POP
// if i = 1 then
72489: LD_VAR 0 8
72493: PUSH
72494: LD_INT 1
72496: EQUAL
72497: IFFALSE 72608
// begin tmp := [ ] ;
72499: LD_ADDR_VAR 0 19
72503: PUSH
72504: EMPTY
72505: ST_TO_ADDR
// for j in f do
72506: LD_ADDR_VAR 0 9
72510: PUSH
72511: LD_VAR 0 12
72515: PUSH
72516: FOR_IN
72517: IFFALSE 72590
// if GetBType ( j ) = b_bunker then
72519: LD_VAR 0 9
72523: PPUSH
72524: CALL_OW 266
72528: PUSH
72529: LD_INT 32
72531: EQUAL
72532: IFFALSE 72559
// tmp := Insert ( tmp , 1 , j ) else
72534: LD_ADDR_VAR 0 19
72538: PUSH
72539: LD_VAR 0 19
72543: PPUSH
72544: LD_INT 1
72546: PPUSH
72547: LD_VAR 0 9
72551: PPUSH
72552: CALL_OW 2
72556: ST_TO_ADDR
72557: GO 72588
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72559: LD_ADDR_VAR 0 19
72563: PUSH
72564: LD_VAR 0 19
72568: PPUSH
72569: LD_VAR 0 19
72573: PUSH
72574: LD_INT 1
72576: PLUS
72577: PPUSH
72578: LD_VAR 0 9
72582: PPUSH
72583: CALL_OW 2
72587: ST_TO_ADDR
72588: GO 72516
72590: POP
72591: POP
// if tmp then
72592: LD_VAR 0 19
72596: IFFALSE 72608
// f := tmp ;
72598: LD_ADDR_VAR 0 12
72602: PUSH
72603: LD_VAR 0 19
72607: ST_TO_ADDR
// end ; x := personel [ i ] ;
72608: LD_ADDR_VAR 0 13
72612: PUSH
72613: LD_VAR 0 6
72617: PUSH
72618: LD_VAR 0 8
72622: ARRAY
72623: ST_TO_ADDR
// if x = - 1 then
72624: LD_VAR 0 13
72628: PUSH
72629: LD_INT 1
72631: NEG
72632: EQUAL
72633: IFFALSE 72842
// begin for j in f do
72635: LD_ADDR_VAR 0 9
72639: PUSH
72640: LD_VAR 0 12
72644: PUSH
72645: FOR_IN
72646: IFFALSE 72838
// repeat InitHc ;
72648: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72652: LD_VAR 0 9
72656: PPUSH
72657: CALL_OW 266
72661: PUSH
72662: LD_INT 5
72664: EQUAL
72665: IFFALSE 72735
// begin if UnitsInside ( j ) < 3 then
72667: LD_VAR 0 9
72671: PPUSH
72672: CALL_OW 313
72676: PUSH
72677: LD_INT 3
72679: LESS
72680: IFFALSE 72716
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72682: LD_INT 0
72684: PPUSH
72685: LD_INT 5
72687: PUSH
72688: LD_INT 8
72690: PUSH
72691: LD_INT 9
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: LIST
72698: PUSH
72699: LD_VAR 0 17
72703: ARRAY
72704: PPUSH
72705: LD_VAR 0 4
72709: PPUSH
72710: CALL_OW 380
72714: GO 72733
// PrepareHuman ( false , i , skill ) ;
72716: LD_INT 0
72718: PPUSH
72719: LD_VAR 0 8
72723: PPUSH
72724: LD_VAR 0 4
72728: PPUSH
72729: CALL_OW 380
// end else
72733: GO 72752
// PrepareHuman ( false , i , skill ) ;
72735: LD_INT 0
72737: PPUSH
72738: LD_VAR 0 8
72742: PPUSH
72743: LD_VAR 0 4
72747: PPUSH
72748: CALL_OW 380
// un := CreateHuman ;
72752: LD_ADDR_VAR 0 14
72756: PUSH
72757: CALL_OW 44
72761: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72762: LD_ADDR_VAR 0 7
72766: PUSH
72767: LD_VAR 0 7
72771: PPUSH
72772: LD_INT 1
72774: PPUSH
72775: LD_VAR 0 14
72779: PPUSH
72780: CALL_OW 2
72784: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72785: LD_VAR 0 14
72789: PPUSH
72790: LD_VAR 0 9
72794: PPUSH
72795: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72799: LD_VAR 0 9
72803: PPUSH
72804: CALL_OW 313
72808: PUSH
72809: LD_INT 6
72811: EQUAL
72812: PUSH
72813: LD_VAR 0 9
72817: PPUSH
72818: CALL_OW 266
72822: PUSH
72823: LD_INT 32
72825: PUSH
72826: LD_INT 31
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: IN
72833: OR
72834: IFFALSE 72648
72836: GO 72645
72838: POP
72839: POP
// end else
72840: GO 73222
// for j = 1 to x do
72842: LD_ADDR_VAR 0 9
72846: PUSH
72847: DOUBLE
72848: LD_INT 1
72850: DEC
72851: ST_TO_ADDR
72852: LD_VAR 0 13
72856: PUSH
72857: FOR_TO
72858: IFFALSE 73220
// begin InitHc ;
72860: CALL_OW 19
// if not f then
72864: LD_VAR 0 12
72868: NOT
72869: IFFALSE 72958
// begin PrepareHuman ( false , i , skill ) ;
72871: LD_INT 0
72873: PPUSH
72874: LD_VAR 0 8
72878: PPUSH
72879: LD_VAR 0 4
72883: PPUSH
72884: CALL_OW 380
// un := CreateHuman ;
72888: LD_ADDR_VAR 0 14
72892: PUSH
72893: CALL_OW 44
72897: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72898: LD_ADDR_VAR 0 7
72902: PUSH
72903: LD_VAR 0 7
72907: PPUSH
72908: LD_INT 1
72910: PPUSH
72911: LD_VAR 0 14
72915: PPUSH
72916: CALL_OW 2
72920: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72921: LD_VAR 0 14
72925: PPUSH
72926: LD_VAR 0 1
72930: PPUSH
72931: CALL_OW 250
72935: PPUSH
72936: LD_VAR 0 1
72940: PPUSH
72941: CALL_OW 251
72945: PPUSH
72946: LD_INT 10
72948: PPUSH
72949: LD_INT 0
72951: PPUSH
72952: CALL_OW 50
// continue ;
72956: GO 72857
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
72958: LD_VAR 0 12
72962: PUSH
72963: LD_INT 1
72965: ARRAY
72966: PPUSH
72967: CALL_OW 313
72971: PUSH
72972: LD_VAR 0 12
72976: PUSH
72977: LD_INT 1
72979: ARRAY
72980: PPUSH
72981: CALL_OW 266
72985: PUSH
72986: LD_INT 32
72988: PUSH
72989: LD_INT 31
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: IN
72996: AND
72997: PUSH
72998: LD_VAR 0 12
73002: PUSH
73003: LD_INT 1
73005: ARRAY
73006: PPUSH
73007: CALL_OW 313
73011: PUSH
73012: LD_INT 6
73014: EQUAL
73015: OR
73016: IFFALSE 73036
// f := Delete ( f , 1 ) ;
73018: LD_ADDR_VAR 0 12
73022: PUSH
73023: LD_VAR 0 12
73027: PPUSH
73028: LD_INT 1
73030: PPUSH
73031: CALL_OW 3
73035: ST_TO_ADDR
// if not f then
73036: LD_VAR 0 12
73040: NOT
73041: IFFALSE 73059
// begin x := x + 2 ;
73043: LD_ADDR_VAR 0 13
73047: PUSH
73048: LD_VAR 0 13
73052: PUSH
73053: LD_INT 2
73055: PLUS
73056: ST_TO_ADDR
// continue ;
73057: GO 72857
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73059: LD_VAR 0 12
73063: PUSH
73064: LD_INT 1
73066: ARRAY
73067: PPUSH
73068: CALL_OW 266
73072: PUSH
73073: LD_INT 5
73075: EQUAL
73076: IFFALSE 73150
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73078: LD_VAR 0 12
73082: PUSH
73083: LD_INT 1
73085: ARRAY
73086: PPUSH
73087: CALL_OW 313
73091: PUSH
73092: LD_INT 3
73094: LESS
73095: IFFALSE 73131
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73097: LD_INT 0
73099: PPUSH
73100: LD_INT 5
73102: PUSH
73103: LD_INT 8
73105: PUSH
73106: LD_INT 9
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: LIST
73113: PUSH
73114: LD_VAR 0 17
73118: ARRAY
73119: PPUSH
73120: LD_VAR 0 4
73124: PPUSH
73125: CALL_OW 380
73129: GO 73148
// PrepareHuman ( false , i , skill ) ;
73131: LD_INT 0
73133: PPUSH
73134: LD_VAR 0 8
73138: PPUSH
73139: LD_VAR 0 4
73143: PPUSH
73144: CALL_OW 380
// end else
73148: GO 73167
// PrepareHuman ( false , i , skill ) ;
73150: LD_INT 0
73152: PPUSH
73153: LD_VAR 0 8
73157: PPUSH
73158: LD_VAR 0 4
73162: PPUSH
73163: CALL_OW 380
// un := CreateHuman ;
73167: LD_ADDR_VAR 0 14
73171: PUSH
73172: CALL_OW 44
73176: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73177: LD_ADDR_VAR 0 7
73181: PUSH
73182: LD_VAR 0 7
73186: PPUSH
73187: LD_INT 1
73189: PPUSH
73190: LD_VAR 0 14
73194: PPUSH
73195: CALL_OW 2
73199: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73200: LD_VAR 0 14
73204: PPUSH
73205: LD_VAR 0 12
73209: PUSH
73210: LD_INT 1
73212: ARRAY
73213: PPUSH
73214: CALL_OW 52
// end ;
73218: GO 72857
73220: POP
73221: POP
// end ;
73222: GO 72159
73224: POP
73225: POP
// result := result ^ buildings ;
73226: LD_ADDR_VAR 0 7
73230: PUSH
73231: LD_VAR 0 7
73235: PUSH
73236: LD_VAR 0 18
73240: ADD
73241: ST_TO_ADDR
// end else
73242: GO 73385
// begin for i = 1 to personel do
73244: LD_ADDR_VAR 0 8
73248: PUSH
73249: DOUBLE
73250: LD_INT 1
73252: DEC
73253: ST_TO_ADDR
73254: LD_VAR 0 6
73258: PUSH
73259: FOR_TO
73260: IFFALSE 73383
// begin if i > 4 then
73262: LD_VAR 0 8
73266: PUSH
73267: LD_INT 4
73269: GREATER
73270: IFFALSE 73274
// break ;
73272: GO 73383
// x := personel [ i ] ;
73274: LD_ADDR_VAR 0 13
73278: PUSH
73279: LD_VAR 0 6
73283: PUSH
73284: LD_VAR 0 8
73288: ARRAY
73289: ST_TO_ADDR
// if x = - 1 then
73290: LD_VAR 0 13
73294: PUSH
73295: LD_INT 1
73297: NEG
73298: EQUAL
73299: IFFALSE 73303
// continue ;
73301: GO 73259
// PrepareHuman ( false , i , skill ) ;
73303: LD_INT 0
73305: PPUSH
73306: LD_VAR 0 8
73310: PPUSH
73311: LD_VAR 0 4
73315: PPUSH
73316: CALL_OW 380
// un := CreateHuman ;
73320: LD_ADDR_VAR 0 14
73324: PUSH
73325: CALL_OW 44
73329: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73330: LD_VAR 0 14
73334: PPUSH
73335: LD_VAR 0 1
73339: PPUSH
73340: CALL_OW 250
73344: PPUSH
73345: LD_VAR 0 1
73349: PPUSH
73350: CALL_OW 251
73354: PPUSH
73355: LD_INT 10
73357: PPUSH
73358: LD_INT 0
73360: PPUSH
73361: CALL_OW 50
// result := result ^ un ;
73365: LD_ADDR_VAR 0 7
73369: PUSH
73370: LD_VAR 0 7
73374: PUSH
73375: LD_VAR 0 14
73379: ADD
73380: ST_TO_ADDR
// end ;
73381: GO 73259
73383: POP
73384: POP
// end ; end ;
73385: LD_VAR 0 7
73389: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73390: LD_INT 0
73392: PPUSH
73393: PPUSH
73394: PPUSH
73395: PPUSH
73396: PPUSH
73397: PPUSH
73398: PPUSH
73399: PPUSH
73400: PPUSH
73401: PPUSH
73402: PPUSH
73403: PPUSH
73404: PPUSH
73405: PPUSH
73406: PPUSH
73407: PPUSH
// result := false ;
73408: LD_ADDR_VAR 0 3
73412: PUSH
73413: LD_INT 0
73415: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73416: LD_VAR 0 1
73420: NOT
73421: PUSH
73422: LD_VAR 0 1
73426: PPUSH
73427: CALL_OW 266
73431: PUSH
73432: LD_INT 32
73434: PUSH
73435: LD_INT 33
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: IN
73442: NOT
73443: OR
73444: IFFALSE 73448
// exit ;
73446: GO 74584
// nat := GetNation ( tower ) ;
73448: LD_ADDR_VAR 0 12
73452: PUSH
73453: LD_VAR 0 1
73457: PPUSH
73458: CALL_OW 248
73462: ST_TO_ADDR
// side := GetSide ( tower ) ;
73463: LD_ADDR_VAR 0 16
73467: PUSH
73468: LD_VAR 0 1
73472: PPUSH
73473: CALL_OW 255
73477: ST_TO_ADDR
// x := GetX ( tower ) ;
73478: LD_ADDR_VAR 0 10
73482: PUSH
73483: LD_VAR 0 1
73487: PPUSH
73488: CALL_OW 250
73492: ST_TO_ADDR
// y := GetY ( tower ) ;
73493: LD_ADDR_VAR 0 11
73497: PUSH
73498: LD_VAR 0 1
73502: PPUSH
73503: CALL_OW 251
73507: ST_TO_ADDR
// if not x or not y then
73508: LD_VAR 0 10
73512: NOT
73513: PUSH
73514: LD_VAR 0 11
73518: NOT
73519: OR
73520: IFFALSE 73524
// exit ;
73522: GO 74584
// weapon := 0 ;
73524: LD_ADDR_VAR 0 18
73528: PUSH
73529: LD_INT 0
73531: ST_TO_ADDR
// fac_list := [ ] ;
73532: LD_ADDR_VAR 0 17
73536: PUSH
73537: EMPTY
73538: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
73539: LD_ADDR_VAR 0 6
73543: PUSH
73544: LD_VAR 0 1
73548: PPUSH
73549: CALL_OW 274
73553: PPUSH
73554: LD_VAR 0 2
73558: PPUSH
73559: CALL 71162 0 2
73563: PPUSH
73564: LD_INT 30
73566: PUSH
73567: LD_INT 3
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PPUSH
73574: CALL_OW 72
73578: ST_TO_ADDR
// if not factories then
73579: LD_VAR 0 6
73583: NOT
73584: IFFALSE 73588
// exit ;
73586: GO 74584
// for i in factories do
73588: LD_ADDR_VAR 0 8
73592: PUSH
73593: LD_VAR 0 6
73597: PUSH
73598: FOR_IN
73599: IFFALSE 73624
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73601: LD_ADDR_VAR 0 17
73605: PUSH
73606: LD_VAR 0 17
73610: PUSH
73611: LD_VAR 0 8
73615: PPUSH
73616: CALL_OW 478
73620: UNION
73621: ST_TO_ADDR
73622: GO 73598
73624: POP
73625: POP
// if not fac_list then
73626: LD_VAR 0 17
73630: NOT
73631: IFFALSE 73635
// exit ;
73633: GO 74584
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73635: LD_ADDR_VAR 0 5
73639: PUSH
73640: LD_INT 4
73642: PUSH
73643: LD_INT 5
73645: PUSH
73646: LD_INT 9
73648: PUSH
73649: LD_INT 10
73651: PUSH
73652: LD_INT 6
73654: PUSH
73655: LD_INT 7
73657: PUSH
73658: LD_INT 11
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 27
73672: PUSH
73673: LD_INT 28
73675: PUSH
73676: LD_INT 26
73678: PUSH
73679: LD_INT 30
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 43
73690: PUSH
73691: LD_INT 44
73693: PUSH
73694: LD_INT 46
73696: PUSH
73697: LD_INT 45
73699: PUSH
73700: LD_INT 47
73702: PUSH
73703: LD_INT 49
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: LIST
73710: LIST
73711: LIST
73712: LIST
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: LIST
73718: PUSH
73719: LD_VAR 0 12
73723: ARRAY
73724: ST_TO_ADDR
// for i in list do
73725: LD_ADDR_VAR 0 8
73729: PUSH
73730: LD_VAR 0 5
73734: PUSH
73735: FOR_IN
73736: IFFALSE 73769
// if not i in fac_list then
73738: LD_VAR 0 8
73742: PUSH
73743: LD_VAR 0 17
73747: IN
73748: NOT
73749: IFFALSE 73767
// list := list diff i ;
73751: LD_ADDR_VAR 0 5
73755: PUSH
73756: LD_VAR 0 5
73760: PUSH
73761: LD_VAR 0 8
73765: DIFF
73766: ST_TO_ADDR
73767: GO 73735
73769: POP
73770: POP
// if not list then
73771: LD_VAR 0 5
73775: NOT
73776: IFFALSE 73780
// exit ;
73778: GO 74584
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73780: LD_VAR 0 12
73784: PUSH
73785: LD_INT 3
73787: EQUAL
73788: PUSH
73789: LD_INT 49
73791: PUSH
73792: LD_VAR 0 5
73796: IN
73797: AND
73798: PUSH
73799: LD_INT 31
73801: PPUSH
73802: LD_VAR 0 16
73806: PPUSH
73807: CALL_OW 321
73811: PUSH
73812: LD_INT 2
73814: EQUAL
73815: AND
73816: IFFALSE 73876
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73818: LD_INT 22
73820: PUSH
73821: LD_VAR 0 16
73825: PUSH
73826: EMPTY
73827: LIST
73828: LIST
73829: PUSH
73830: LD_INT 35
73832: PUSH
73833: LD_INT 49
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 91
73842: PUSH
73843: LD_VAR 0 1
73847: PUSH
73848: LD_INT 10
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: LIST
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: LIST
73860: PPUSH
73861: CALL_OW 69
73865: NOT
73866: IFFALSE 73876
// weapon := ru_time_lapser ;
73868: LD_ADDR_VAR 0 18
73872: PUSH
73873: LD_INT 49
73875: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73876: LD_VAR 0 12
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: LD_INT 2
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: IN
73891: PUSH
73892: LD_INT 11
73894: PUSH
73895: LD_VAR 0 5
73899: IN
73900: PUSH
73901: LD_INT 30
73903: PUSH
73904: LD_VAR 0 5
73908: IN
73909: OR
73910: AND
73911: PUSH
73912: LD_INT 6
73914: PPUSH
73915: LD_VAR 0 16
73919: PPUSH
73920: CALL_OW 321
73924: PUSH
73925: LD_INT 2
73927: EQUAL
73928: AND
73929: IFFALSE 74094
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
73931: LD_INT 22
73933: PUSH
73934: LD_VAR 0 16
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 2
73945: PUSH
73946: LD_INT 35
73948: PUSH
73949: LD_INT 11
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 35
73958: PUSH
73959: LD_INT 30
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 91
73973: PUSH
73974: LD_VAR 0 1
73978: PUSH
73979: LD_INT 18
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: LIST
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: LIST
73991: PPUSH
73992: CALL_OW 69
73996: NOT
73997: PUSH
73998: LD_INT 22
74000: PUSH
74001: LD_VAR 0 16
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 2
74012: PUSH
74013: LD_INT 30
74015: PUSH
74016: LD_INT 32
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 30
74025: PUSH
74026: LD_INT 33
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: LIST
74037: PUSH
74038: LD_INT 91
74040: PUSH
74041: LD_VAR 0 1
74045: PUSH
74046: LD_INT 12
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: LIST
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: PUSH
74059: EMPTY
74060: LIST
74061: PPUSH
74062: CALL_OW 69
74066: PUSH
74067: LD_INT 2
74069: GREATER
74070: AND
74071: IFFALSE 74094
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74073: LD_ADDR_VAR 0 18
74077: PUSH
74078: LD_INT 11
74080: PUSH
74081: LD_INT 30
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_VAR 0 12
74092: ARRAY
74093: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74094: LD_VAR 0 18
74098: NOT
74099: PUSH
74100: LD_INT 40
74102: PPUSH
74103: LD_VAR 0 16
74107: PPUSH
74108: CALL_OW 321
74112: PUSH
74113: LD_INT 2
74115: EQUAL
74116: AND
74117: PUSH
74118: LD_INT 7
74120: PUSH
74121: LD_VAR 0 5
74125: IN
74126: PUSH
74127: LD_INT 28
74129: PUSH
74130: LD_VAR 0 5
74134: IN
74135: OR
74136: PUSH
74137: LD_INT 45
74139: PUSH
74140: LD_VAR 0 5
74144: IN
74145: OR
74146: AND
74147: IFFALSE 74401
// begin hex := GetHexInfo ( x , y ) ;
74149: LD_ADDR_VAR 0 4
74153: PUSH
74154: LD_VAR 0 10
74158: PPUSH
74159: LD_VAR 0 11
74163: PPUSH
74164: CALL_OW 546
74168: ST_TO_ADDR
// if hex [ 1 ] then
74169: LD_VAR 0 4
74173: PUSH
74174: LD_INT 1
74176: ARRAY
74177: IFFALSE 74181
// exit ;
74179: GO 74584
// height := hex [ 2 ] ;
74181: LD_ADDR_VAR 0 15
74185: PUSH
74186: LD_VAR 0 4
74190: PUSH
74191: LD_INT 2
74193: ARRAY
74194: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74195: LD_ADDR_VAR 0 14
74199: PUSH
74200: LD_INT 0
74202: PUSH
74203: LD_INT 2
74205: PUSH
74206: LD_INT 3
74208: PUSH
74209: LD_INT 5
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: ST_TO_ADDR
// for i in tmp do
74218: LD_ADDR_VAR 0 8
74222: PUSH
74223: LD_VAR 0 14
74227: PUSH
74228: FOR_IN
74229: IFFALSE 74399
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74231: LD_ADDR_VAR 0 9
74235: PUSH
74236: LD_VAR 0 10
74240: PPUSH
74241: LD_VAR 0 8
74245: PPUSH
74246: LD_INT 5
74248: PPUSH
74249: CALL_OW 272
74253: PUSH
74254: LD_VAR 0 11
74258: PPUSH
74259: LD_VAR 0 8
74263: PPUSH
74264: LD_INT 5
74266: PPUSH
74267: CALL_OW 273
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74276: LD_VAR 0 9
74280: PUSH
74281: LD_INT 1
74283: ARRAY
74284: PPUSH
74285: LD_VAR 0 9
74289: PUSH
74290: LD_INT 2
74292: ARRAY
74293: PPUSH
74294: CALL_OW 488
74298: IFFALSE 74397
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74300: LD_ADDR_VAR 0 4
74304: PUSH
74305: LD_VAR 0 9
74309: PUSH
74310: LD_INT 1
74312: ARRAY
74313: PPUSH
74314: LD_VAR 0 9
74318: PUSH
74319: LD_INT 2
74321: ARRAY
74322: PPUSH
74323: CALL_OW 546
74327: ST_TO_ADDR
// if hex [ 1 ] then
74328: LD_VAR 0 4
74332: PUSH
74333: LD_INT 1
74335: ARRAY
74336: IFFALSE 74340
// continue ;
74338: GO 74228
// h := hex [ 2 ] ;
74340: LD_ADDR_VAR 0 13
74344: PUSH
74345: LD_VAR 0 4
74349: PUSH
74350: LD_INT 2
74352: ARRAY
74353: ST_TO_ADDR
// if h + 7 < height then
74354: LD_VAR 0 13
74358: PUSH
74359: LD_INT 7
74361: PLUS
74362: PUSH
74363: LD_VAR 0 15
74367: LESS
74368: IFFALSE 74397
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74370: LD_ADDR_VAR 0 18
74374: PUSH
74375: LD_INT 7
74377: PUSH
74378: LD_INT 28
74380: PUSH
74381: LD_INT 45
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: LIST
74388: PUSH
74389: LD_VAR 0 12
74393: ARRAY
74394: ST_TO_ADDR
// break ;
74395: GO 74399
// end ; end ; end ;
74397: GO 74228
74399: POP
74400: POP
// end ; if not weapon then
74401: LD_VAR 0 18
74405: NOT
74406: IFFALSE 74466
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74408: LD_ADDR_VAR 0 5
74412: PUSH
74413: LD_VAR 0 5
74417: PUSH
74418: LD_INT 11
74420: PUSH
74421: LD_INT 30
74423: PUSH
74424: LD_INT 49
74426: PUSH
74427: EMPTY
74428: LIST
74429: LIST
74430: LIST
74431: DIFF
74432: ST_TO_ADDR
// if not list then
74433: LD_VAR 0 5
74437: NOT
74438: IFFALSE 74442
// exit ;
74440: GO 74584
// weapon := list [ rand ( 1 , list ) ] ;
74442: LD_ADDR_VAR 0 18
74446: PUSH
74447: LD_VAR 0 5
74451: PUSH
74452: LD_INT 1
74454: PPUSH
74455: LD_VAR 0 5
74459: PPUSH
74460: CALL_OW 12
74464: ARRAY
74465: ST_TO_ADDR
// end ; if weapon then
74466: LD_VAR 0 18
74470: IFFALSE 74584
// begin tmp := CostOfWeapon ( weapon ) ;
74472: LD_ADDR_VAR 0 14
74476: PUSH
74477: LD_VAR 0 18
74481: PPUSH
74482: CALL_OW 451
74486: ST_TO_ADDR
// j := GetBase ( tower ) ;
74487: LD_ADDR_VAR 0 9
74491: PUSH
74492: LD_VAR 0 1
74496: PPUSH
74497: CALL_OW 274
74501: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74502: LD_VAR 0 9
74506: PPUSH
74507: LD_INT 1
74509: PPUSH
74510: CALL_OW 275
74514: PUSH
74515: LD_VAR 0 14
74519: PUSH
74520: LD_INT 1
74522: ARRAY
74523: GREATEREQUAL
74524: PUSH
74525: LD_VAR 0 9
74529: PPUSH
74530: LD_INT 2
74532: PPUSH
74533: CALL_OW 275
74537: PUSH
74538: LD_VAR 0 14
74542: PUSH
74543: LD_INT 2
74545: ARRAY
74546: GREATEREQUAL
74547: AND
74548: PUSH
74549: LD_VAR 0 9
74553: PPUSH
74554: LD_INT 3
74556: PPUSH
74557: CALL_OW 275
74561: PUSH
74562: LD_VAR 0 14
74566: PUSH
74567: LD_INT 3
74569: ARRAY
74570: GREATEREQUAL
74571: AND
74572: IFFALSE 74584
// result := weapon ;
74574: LD_ADDR_VAR 0 3
74578: PUSH
74579: LD_VAR 0 18
74583: ST_TO_ADDR
// end ; end ;
74584: LD_VAR 0 3
74588: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74589: LD_INT 0
74591: PPUSH
74592: PPUSH
// result := true ;
74593: LD_ADDR_VAR 0 3
74597: PUSH
74598: LD_INT 1
74600: ST_TO_ADDR
// if array1 = array2 then
74601: LD_VAR 0 1
74605: PUSH
74606: LD_VAR 0 2
74610: EQUAL
74611: IFFALSE 74671
// begin for i = 1 to array1 do
74613: LD_ADDR_VAR 0 4
74617: PUSH
74618: DOUBLE
74619: LD_INT 1
74621: DEC
74622: ST_TO_ADDR
74623: LD_VAR 0 1
74627: PUSH
74628: FOR_TO
74629: IFFALSE 74667
// if array1 [ i ] <> array2 [ i ] then
74631: LD_VAR 0 1
74635: PUSH
74636: LD_VAR 0 4
74640: ARRAY
74641: PUSH
74642: LD_VAR 0 2
74646: PUSH
74647: LD_VAR 0 4
74651: ARRAY
74652: NONEQUAL
74653: IFFALSE 74665
// begin result := false ;
74655: LD_ADDR_VAR 0 3
74659: PUSH
74660: LD_INT 0
74662: ST_TO_ADDR
// break ;
74663: GO 74667
// end ;
74665: GO 74628
74667: POP
74668: POP
// end else
74669: GO 74679
// result := false ;
74671: LD_ADDR_VAR 0 3
74675: PUSH
74676: LD_INT 0
74678: ST_TO_ADDR
// end ;
74679: LD_VAR 0 3
74683: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74684: LD_INT 0
74686: PPUSH
74687: PPUSH
74688: PPUSH
// pom := GetBase ( fac ) ;
74689: LD_ADDR_VAR 0 5
74693: PUSH
74694: LD_VAR 0 1
74698: PPUSH
74699: CALL_OW 274
74703: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74704: LD_ADDR_VAR 0 4
74708: PUSH
74709: LD_VAR 0 2
74713: PUSH
74714: LD_INT 1
74716: ARRAY
74717: PPUSH
74718: LD_VAR 0 2
74722: PUSH
74723: LD_INT 2
74725: ARRAY
74726: PPUSH
74727: LD_VAR 0 2
74731: PUSH
74732: LD_INT 3
74734: ARRAY
74735: PPUSH
74736: LD_VAR 0 2
74740: PUSH
74741: LD_INT 4
74743: ARRAY
74744: PPUSH
74745: CALL_OW 449
74749: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74750: LD_ADDR_VAR 0 3
74754: PUSH
74755: LD_VAR 0 5
74759: PPUSH
74760: LD_INT 1
74762: PPUSH
74763: CALL_OW 275
74767: PUSH
74768: LD_VAR 0 4
74772: PUSH
74773: LD_INT 1
74775: ARRAY
74776: GREATEREQUAL
74777: PUSH
74778: LD_VAR 0 5
74782: PPUSH
74783: LD_INT 2
74785: PPUSH
74786: CALL_OW 275
74790: PUSH
74791: LD_VAR 0 4
74795: PUSH
74796: LD_INT 2
74798: ARRAY
74799: GREATEREQUAL
74800: AND
74801: PUSH
74802: LD_VAR 0 5
74806: PPUSH
74807: LD_INT 3
74809: PPUSH
74810: CALL_OW 275
74814: PUSH
74815: LD_VAR 0 4
74819: PUSH
74820: LD_INT 3
74822: ARRAY
74823: GREATEREQUAL
74824: AND
74825: ST_TO_ADDR
// end ;
74826: LD_VAR 0 3
74830: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74831: LD_INT 0
74833: PPUSH
74834: PPUSH
74835: PPUSH
74836: PPUSH
// pom := GetBase ( building ) ;
74837: LD_ADDR_VAR 0 3
74841: PUSH
74842: LD_VAR 0 1
74846: PPUSH
74847: CALL_OW 274
74851: ST_TO_ADDR
// if not pom then
74852: LD_VAR 0 3
74856: NOT
74857: IFFALSE 74861
// exit ;
74859: GO 75031
// btype := GetBType ( building ) ;
74861: LD_ADDR_VAR 0 5
74865: PUSH
74866: LD_VAR 0 1
74870: PPUSH
74871: CALL_OW 266
74875: ST_TO_ADDR
// if btype = b_armoury then
74876: LD_VAR 0 5
74880: PUSH
74881: LD_INT 4
74883: EQUAL
74884: IFFALSE 74894
// btype := b_barracks ;
74886: LD_ADDR_VAR 0 5
74890: PUSH
74891: LD_INT 5
74893: ST_TO_ADDR
// if btype = b_depot then
74894: LD_VAR 0 5
74898: PUSH
74899: LD_INT 0
74901: EQUAL
74902: IFFALSE 74912
// btype := b_warehouse ;
74904: LD_ADDR_VAR 0 5
74908: PUSH
74909: LD_INT 1
74911: ST_TO_ADDR
// if btype = b_workshop then
74912: LD_VAR 0 5
74916: PUSH
74917: LD_INT 2
74919: EQUAL
74920: IFFALSE 74930
// btype := b_factory ;
74922: LD_ADDR_VAR 0 5
74926: PUSH
74927: LD_INT 3
74929: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74930: LD_ADDR_VAR 0 4
74934: PUSH
74935: LD_VAR 0 5
74939: PPUSH
74940: LD_VAR 0 1
74944: PPUSH
74945: CALL_OW 248
74949: PPUSH
74950: CALL_OW 450
74954: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74955: LD_ADDR_VAR 0 2
74959: PUSH
74960: LD_VAR 0 3
74964: PPUSH
74965: LD_INT 1
74967: PPUSH
74968: CALL_OW 275
74972: PUSH
74973: LD_VAR 0 4
74977: PUSH
74978: LD_INT 1
74980: ARRAY
74981: GREATEREQUAL
74982: PUSH
74983: LD_VAR 0 3
74987: PPUSH
74988: LD_INT 2
74990: PPUSH
74991: CALL_OW 275
74995: PUSH
74996: LD_VAR 0 4
75000: PUSH
75001: LD_INT 2
75003: ARRAY
75004: GREATEREQUAL
75005: AND
75006: PUSH
75007: LD_VAR 0 3
75011: PPUSH
75012: LD_INT 3
75014: PPUSH
75015: CALL_OW 275
75019: PUSH
75020: LD_VAR 0 4
75024: PUSH
75025: LD_INT 3
75027: ARRAY
75028: GREATEREQUAL
75029: AND
75030: ST_TO_ADDR
// end ;
75031: LD_VAR 0 2
75035: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75036: LD_INT 0
75038: PPUSH
75039: PPUSH
75040: PPUSH
// pom := GetBase ( building ) ;
75041: LD_ADDR_VAR 0 4
75045: PUSH
75046: LD_VAR 0 1
75050: PPUSH
75051: CALL_OW 274
75055: ST_TO_ADDR
// if not pom then
75056: LD_VAR 0 4
75060: NOT
75061: IFFALSE 75065
// exit ;
75063: GO 75166
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75065: LD_ADDR_VAR 0 5
75069: PUSH
75070: LD_VAR 0 2
75074: PPUSH
75075: LD_VAR 0 1
75079: PPUSH
75080: CALL_OW 248
75084: PPUSH
75085: CALL_OW 450
75089: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75090: LD_ADDR_VAR 0 3
75094: PUSH
75095: LD_VAR 0 4
75099: PPUSH
75100: LD_INT 1
75102: PPUSH
75103: CALL_OW 275
75107: PUSH
75108: LD_VAR 0 5
75112: PUSH
75113: LD_INT 1
75115: ARRAY
75116: GREATEREQUAL
75117: PUSH
75118: LD_VAR 0 4
75122: PPUSH
75123: LD_INT 2
75125: PPUSH
75126: CALL_OW 275
75130: PUSH
75131: LD_VAR 0 5
75135: PUSH
75136: LD_INT 2
75138: ARRAY
75139: GREATEREQUAL
75140: AND
75141: PUSH
75142: LD_VAR 0 4
75146: PPUSH
75147: LD_INT 3
75149: PPUSH
75150: CALL_OW 275
75154: PUSH
75155: LD_VAR 0 5
75159: PUSH
75160: LD_INT 3
75162: ARRAY
75163: GREATEREQUAL
75164: AND
75165: ST_TO_ADDR
// end ;
75166: LD_VAR 0 3
75170: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
75171: LD_INT 0
75173: PPUSH
75174: PPUSH
75175: PPUSH
75176: PPUSH
75177: PPUSH
75178: PPUSH
75179: PPUSH
75180: PPUSH
75181: PPUSH
75182: PPUSH
// result := false ;
75183: LD_ADDR_VAR 0 6
75187: PUSH
75188: LD_INT 0
75190: ST_TO_ADDR
// if not base or not btype or not x or not y then
75191: LD_VAR 0 1
75195: NOT
75196: PUSH
75197: LD_VAR 0 2
75201: NOT
75202: OR
75203: PUSH
75204: LD_VAR 0 3
75208: NOT
75209: OR
75210: PUSH
75211: LD_VAR 0 4
75215: NOT
75216: OR
75217: IFFALSE 75221
// exit ;
75219: GO 75812
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
75221: LD_ADDR_VAR 0 12
75225: PUSH
75226: LD_VAR 0 2
75230: PPUSH
75231: LD_VAR 0 3
75235: PPUSH
75236: LD_VAR 0 4
75240: PPUSH
75241: LD_VAR 0 5
75245: PPUSH
75246: LD_VAR 0 1
75250: PUSH
75251: LD_INT 1
75253: ARRAY
75254: PPUSH
75255: CALL_OW 248
75259: PPUSH
75260: LD_INT 0
75262: PPUSH
75263: CALL 76649 0 6
75267: ST_TO_ADDR
// if not hexes then
75268: LD_VAR 0 12
75272: NOT
75273: IFFALSE 75277
// exit ;
75275: GO 75812
// for i = 1 to hexes do
75277: LD_ADDR_VAR 0 7
75281: PUSH
75282: DOUBLE
75283: LD_INT 1
75285: DEC
75286: ST_TO_ADDR
75287: LD_VAR 0 12
75291: PUSH
75292: FOR_TO
75293: IFFALSE 75810
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75295: LD_ADDR_VAR 0 11
75299: PUSH
75300: LD_VAR 0 12
75304: PUSH
75305: LD_VAR 0 7
75309: ARRAY
75310: PUSH
75311: LD_INT 1
75313: ARRAY
75314: PPUSH
75315: LD_VAR 0 12
75319: PUSH
75320: LD_VAR 0 7
75324: ARRAY
75325: PUSH
75326: LD_INT 2
75328: ARRAY
75329: PPUSH
75330: CALL_OW 428
75334: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75335: LD_VAR 0 12
75339: PUSH
75340: LD_VAR 0 7
75344: ARRAY
75345: PUSH
75346: LD_INT 1
75348: ARRAY
75349: PPUSH
75350: LD_VAR 0 12
75354: PUSH
75355: LD_VAR 0 7
75359: ARRAY
75360: PUSH
75361: LD_INT 2
75363: ARRAY
75364: PPUSH
75365: CALL_OW 351
75369: PUSH
75370: LD_VAR 0 12
75374: PUSH
75375: LD_VAR 0 7
75379: ARRAY
75380: PUSH
75381: LD_INT 1
75383: ARRAY
75384: PPUSH
75385: LD_VAR 0 12
75389: PUSH
75390: LD_VAR 0 7
75394: ARRAY
75395: PUSH
75396: LD_INT 2
75398: ARRAY
75399: PPUSH
75400: CALL_OW 488
75404: NOT
75405: OR
75406: PUSH
75407: LD_VAR 0 11
75411: PPUSH
75412: CALL_OW 247
75416: PUSH
75417: LD_INT 3
75419: EQUAL
75420: OR
75421: IFFALSE 75427
// exit ;
75423: POP
75424: POP
75425: GO 75812
// if not tmp then
75427: LD_VAR 0 11
75431: NOT
75432: IFFALSE 75436
// continue ;
75434: GO 75292
// result := true ;
75436: LD_ADDR_VAR 0 6
75440: PUSH
75441: LD_INT 1
75443: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75444: LD_ADDR_VAR 0 15
75448: PUSH
75449: LD_INT 22
75451: PUSH
75452: LD_VAR 0 11
75456: PPUSH
75457: CALL_OW 255
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 2
75468: PUSH
75469: LD_INT 30
75471: PUSH
75472: LD_INT 0
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 30
75481: PUSH
75482: LD_INT 1
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: LIST
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PPUSH
75498: CALL_OW 69
75502: ST_TO_ADDR
// if dep then
75503: LD_VAR 0 15
75507: IFFALSE 75643
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75509: LD_ADDR_VAR 0 14
75513: PUSH
75514: LD_VAR 0 15
75518: PUSH
75519: LD_INT 1
75521: ARRAY
75522: PPUSH
75523: CALL_OW 250
75527: PPUSH
75528: LD_VAR 0 15
75532: PUSH
75533: LD_INT 1
75535: ARRAY
75536: PPUSH
75537: CALL_OW 254
75541: PPUSH
75542: LD_INT 5
75544: PPUSH
75545: CALL_OW 272
75549: PUSH
75550: LD_VAR 0 15
75554: PUSH
75555: LD_INT 1
75557: ARRAY
75558: PPUSH
75559: CALL_OW 251
75563: PPUSH
75564: LD_VAR 0 15
75568: PUSH
75569: LD_INT 1
75571: ARRAY
75572: PPUSH
75573: CALL_OW 254
75577: PPUSH
75578: LD_INT 5
75580: PPUSH
75581: CALL_OW 273
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75590: LD_VAR 0 14
75594: PUSH
75595: LD_INT 1
75597: ARRAY
75598: PPUSH
75599: LD_VAR 0 14
75603: PUSH
75604: LD_INT 2
75606: ARRAY
75607: PPUSH
75608: CALL_OW 488
75612: IFFALSE 75643
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
75614: LD_VAR 0 11
75618: PPUSH
75619: LD_VAR 0 14
75623: PUSH
75624: LD_INT 1
75626: ARRAY
75627: PPUSH
75628: LD_VAR 0 14
75632: PUSH
75633: LD_INT 2
75635: ARRAY
75636: PPUSH
75637: CALL_OW 111
// continue ;
75641: GO 75292
// end ; end ; r := GetDir ( tmp ) ;
75643: LD_ADDR_VAR 0 13
75647: PUSH
75648: LD_VAR 0 11
75652: PPUSH
75653: CALL_OW 254
75657: ST_TO_ADDR
// if r = 5 then
75658: LD_VAR 0 13
75662: PUSH
75663: LD_INT 5
75665: EQUAL
75666: IFFALSE 75676
// r := 0 ;
75668: LD_ADDR_VAR 0 13
75672: PUSH
75673: LD_INT 0
75675: ST_TO_ADDR
// for j = r to 5 do
75676: LD_ADDR_VAR 0 8
75680: PUSH
75681: DOUBLE
75682: LD_VAR 0 13
75686: DEC
75687: ST_TO_ADDR
75688: LD_INT 5
75690: PUSH
75691: FOR_TO
75692: IFFALSE 75806
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75694: LD_ADDR_VAR 0 9
75698: PUSH
75699: LD_VAR 0 11
75703: PPUSH
75704: CALL_OW 250
75708: PPUSH
75709: LD_VAR 0 8
75713: PPUSH
75714: LD_INT 2
75716: PPUSH
75717: CALL_OW 272
75721: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75722: LD_ADDR_VAR 0 10
75726: PUSH
75727: LD_VAR 0 11
75731: PPUSH
75732: CALL_OW 251
75736: PPUSH
75737: LD_VAR 0 8
75741: PPUSH
75742: LD_INT 2
75744: PPUSH
75745: CALL_OW 273
75749: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75750: LD_VAR 0 9
75754: PPUSH
75755: LD_VAR 0 10
75759: PPUSH
75760: CALL_OW 488
75764: PUSH
75765: LD_VAR 0 9
75769: PPUSH
75770: LD_VAR 0 10
75774: PPUSH
75775: CALL_OW 428
75779: NOT
75780: AND
75781: IFFALSE 75804
// begin ComMoveXY ( tmp , _x , _y ) ;
75783: LD_VAR 0 11
75787: PPUSH
75788: LD_VAR 0 9
75792: PPUSH
75793: LD_VAR 0 10
75797: PPUSH
75798: CALL_OW 111
// break ;
75802: GO 75806
// end ; end ;
75804: GO 75691
75806: POP
75807: POP
// end ;
75808: GO 75292
75810: POP
75811: POP
// end ;
75812: LD_VAR 0 6
75816: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
75817: LD_INT 0
75819: PPUSH
75820: PPUSH
75821: PPUSH
75822: PPUSH
75823: PPUSH
75824: PPUSH
75825: PPUSH
75826: PPUSH
75827: PPUSH
75828: PPUSH
// result := false ;
75829: LD_ADDR_VAR 0 6
75833: PUSH
75834: LD_INT 0
75836: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
75837: LD_VAR 0 1
75841: NOT
75842: PUSH
75843: LD_VAR 0 1
75847: PPUSH
75848: CALL_OW 266
75852: PUSH
75853: LD_INT 0
75855: PUSH
75856: LD_INT 1
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: IN
75863: NOT
75864: OR
75865: PUSH
75866: LD_VAR 0 2
75870: NOT
75871: OR
75872: PUSH
75873: LD_VAR 0 5
75877: PUSH
75878: LD_INT 0
75880: PUSH
75881: LD_INT 1
75883: PUSH
75884: LD_INT 2
75886: PUSH
75887: LD_INT 3
75889: PUSH
75890: LD_INT 4
75892: PUSH
75893: LD_INT 5
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: IN
75904: NOT
75905: OR
75906: PUSH
75907: LD_VAR 0 3
75911: PPUSH
75912: LD_VAR 0 4
75916: PPUSH
75917: CALL_OW 488
75921: NOT
75922: OR
75923: IFFALSE 75927
// exit ;
75925: GO 76644
// pom := GetBase ( bdepot ) ;
75927: LD_ADDR_VAR 0 10
75931: PUSH
75932: LD_VAR 0 1
75936: PPUSH
75937: CALL_OW 274
75941: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
75942: LD_ADDR_VAR 0 11
75946: PUSH
75947: LD_VAR 0 2
75951: PPUSH
75952: LD_VAR 0 1
75956: PPUSH
75957: CALL_OW 248
75961: PPUSH
75962: CALL_OW 450
75966: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
75967: LD_VAR 0 10
75971: PPUSH
75972: LD_INT 1
75974: PPUSH
75975: CALL_OW 275
75979: PUSH
75980: LD_VAR 0 11
75984: PUSH
75985: LD_INT 1
75987: ARRAY
75988: GREATEREQUAL
75989: PUSH
75990: LD_VAR 0 10
75994: PPUSH
75995: LD_INT 2
75997: PPUSH
75998: CALL_OW 275
76002: PUSH
76003: LD_VAR 0 11
76007: PUSH
76008: LD_INT 2
76010: ARRAY
76011: GREATEREQUAL
76012: AND
76013: PUSH
76014: LD_VAR 0 10
76018: PPUSH
76019: LD_INT 3
76021: PPUSH
76022: CALL_OW 275
76026: PUSH
76027: LD_VAR 0 11
76031: PUSH
76032: LD_INT 3
76034: ARRAY
76035: GREATEREQUAL
76036: AND
76037: NOT
76038: IFFALSE 76042
// exit ;
76040: GO 76644
// if GetBType ( bdepot ) = b_depot then
76042: LD_VAR 0 1
76046: PPUSH
76047: CALL_OW 266
76051: PUSH
76052: LD_INT 0
76054: EQUAL
76055: IFFALSE 76067
// dist := 28 else
76057: LD_ADDR_VAR 0 14
76061: PUSH
76062: LD_INT 28
76064: ST_TO_ADDR
76065: GO 76075
// dist := 36 ;
76067: LD_ADDR_VAR 0 14
76071: PUSH
76072: LD_INT 36
76074: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
76075: LD_VAR 0 1
76079: PPUSH
76080: LD_VAR 0 3
76084: PPUSH
76085: LD_VAR 0 4
76089: PPUSH
76090: CALL_OW 297
76094: PUSH
76095: LD_VAR 0 14
76099: GREATER
76100: IFFALSE 76104
// exit ;
76102: GO 76644
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
76104: LD_ADDR_VAR 0 12
76108: PUSH
76109: LD_VAR 0 2
76113: PPUSH
76114: LD_VAR 0 3
76118: PPUSH
76119: LD_VAR 0 4
76123: PPUSH
76124: LD_VAR 0 5
76128: PPUSH
76129: LD_VAR 0 1
76133: PPUSH
76134: CALL_OW 248
76138: PPUSH
76139: LD_INT 0
76141: PPUSH
76142: CALL 76649 0 6
76146: ST_TO_ADDR
// if not hexes then
76147: LD_VAR 0 12
76151: NOT
76152: IFFALSE 76156
// exit ;
76154: GO 76644
// hex := GetHexInfo ( x , y ) ;
76156: LD_ADDR_VAR 0 15
76160: PUSH
76161: LD_VAR 0 3
76165: PPUSH
76166: LD_VAR 0 4
76170: PPUSH
76171: CALL_OW 546
76175: ST_TO_ADDR
// if hex [ 1 ] then
76176: LD_VAR 0 15
76180: PUSH
76181: LD_INT 1
76183: ARRAY
76184: IFFALSE 76188
// exit ;
76186: GO 76644
// height := hex [ 2 ] ;
76188: LD_ADDR_VAR 0 13
76192: PUSH
76193: LD_VAR 0 15
76197: PUSH
76198: LD_INT 2
76200: ARRAY
76201: ST_TO_ADDR
// for i = 1 to hexes do
76202: LD_ADDR_VAR 0 7
76206: PUSH
76207: DOUBLE
76208: LD_INT 1
76210: DEC
76211: ST_TO_ADDR
76212: LD_VAR 0 12
76216: PUSH
76217: FOR_TO
76218: IFFALSE 76548
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
76220: LD_VAR 0 12
76224: PUSH
76225: LD_VAR 0 7
76229: ARRAY
76230: PUSH
76231: LD_INT 1
76233: ARRAY
76234: PPUSH
76235: LD_VAR 0 12
76239: PUSH
76240: LD_VAR 0 7
76244: ARRAY
76245: PUSH
76246: LD_INT 2
76248: ARRAY
76249: PPUSH
76250: CALL_OW 488
76254: NOT
76255: PUSH
76256: LD_VAR 0 12
76260: PUSH
76261: LD_VAR 0 7
76265: ARRAY
76266: PUSH
76267: LD_INT 1
76269: ARRAY
76270: PPUSH
76271: LD_VAR 0 12
76275: PUSH
76276: LD_VAR 0 7
76280: ARRAY
76281: PUSH
76282: LD_INT 2
76284: ARRAY
76285: PPUSH
76286: CALL_OW 428
76290: PUSH
76291: LD_INT 0
76293: GREATER
76294: OR
76295: PUSH
76296: LD_VAR 0 12
76300: PUSH
76301: LD_VAR 0 7
76305: ARRAY
76306: PUSH
76307: LD_INT 1
76309: ARRAY
76310: PPUSH
76311: LD_VAR 0 12
76315: PUSH
76316: LD_VAR 0 7
76320: ARRAY
76321: PUSH
76322: LD_INT 2
76324: ARRAY
76325: PPUSH
76326: CALL_OW 351
76330: OR
76331: IFFALSE 76337
// exit ;
76333: POP
76334: POP
76335: GO 76644
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76337: LD_ADDR_VAR 0 8
76341: PUSH
76342: LD_VAR 0 12
76346: PUSH
76347: LD_VAR 0 7
76351: ARRAY
76352: PUSH
76353: LD_INT 1
76355: ARRAY
76356: PPUSH
76357: LD_VAR 0 12
76361: PUSH
76362: LD_VAR 0 7
76366: ARRAY
76367: PUSH
76368: LD_INT 2
76370: ARRAY
76371: PPUSH
76372: CALL_OW 546
76376: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
76377: LD_VAR 0 8
76381: PUSH
76382: LD_INT 1
76384: ARRAY
76385: PUSH
76386: LD_VAR 0 8
76390: PUSH
76391: LD_INT 2
76393: ARRAY
76394: PUSH
76395: LD_VAR 0 13
76399: PUSH
76400: LD_INT 2
76402: PLUS
76403: GREATER
76404: OR
76405: PUSH
76406: LD_VAR 0 8
76410: PUSH
76411: LD_INT 2
76413: ARRAY
76414: PUSH
76415: LD_VAR 0 13
76419: PUSH
76420: LD_INT 2
76422: MINUS
76423: LESS
76424: OR
76425: PUSH
76426: LD_VAR 0 8
76430: PUSH
76431: LD_INT 3
76433: ARRAY
76434: PUSH
76435: LD_INT 0
76437: PUSH
76438: LD_INT 8
76440: PUSH
76441: LD_INT 9
76443: PUSH
76444: LD_INT 10
76446: PUSH
76447: LD_INT 11
76449: PUSH
76450: LD_INT 12
76452: PUSH
76453: LD_INT 13
76455: PUSH
76456: LD_INT 16
76458: PUSH
76459: LD_INT 17
76461: PUSH
76462: LD_INT 18
76464: PUSH
76465: LD_INT 19
76467: PUSH
76468: LD_INT 20
76470: PUSH
76471: LD_INT 21
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: IN
76489: NOT
76490: OR
76491: PUSH
76492: LD_VAR 0 8
76496: PUSH
76497: LD_INT 5
76499: ARRAY
76500: NOT
76501: OR
76502: PUSH
76503: LD_VAR 0 8
76507: PUSH
76508: LD_INT 6
76510: ARRAY
76511: PUSH
76512: LD_INT 1
76514: PUSH
76515: LD_INT 2
76517: PUSH
76518: LD_INT 7
76520: PUSH
76521: LD_INT 9
76523: PUSH
76524: LD_INT 10
76526: PUSH
76527: LD_INT 11
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: IN
76538: NOT
76539: OR
76540: IFFALSE 76546
// exit ;
76542: POP
76543: POP
76544: GO 76644
// end ;
76546: GO 76217
76548: POP
76549: POP
// side := GetSide ( bdepot ) ;
76550: LD_ADDR_VAR 0 9
76554: PUSH
76555: LD_VAR 0 1
76559: PPUSH
76560: CALL_OW 255
76564: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76565: LD_VAR 0 9
76569: PPUSH
76570: LD_VAR 0 3
76574: PPUSH
76575: LD_VAR 0 4
76579: PPUSH
76580: LD_INT 20
76582: PPUSH
76583: CALL 69316 0 4
76587: PUSH
76588: LD_INT 4
76590: ARRAY
76591: IFFALSE 76595
// exit ;
76593: GO 76644
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
76595: LD_VAR 0 2
76599: PUSH
76600: LD_INT 29
76602: PUSH
76603: LD_INT 30
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: IN
76610: PUSH
76611: LD_VAR 0 3
76615: PPUSH
76616: LD_VAR 0 4
76620: PPUSH
76621: LD_VAR 0 9
76625: PPUSH
76626: CALL_OW 440
76630: NOT
76631: AND
76632: IFFALSE 76636
// exit ;
76634: GO 76644
// result := true ;
76636: LD_ADDR_VAR 0 6
76640: PUSH
76641: LD_INT 1
76643: ST_TO_ADDR
// end ;
76644: LD_VAR 0 6
76648: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
76649: LD_INT 0
76651: PPUSH
76652: PPUSH
76653: PPUSH
76654: PPUSH
76655: PPUSH
76656: PPUSH
76657: PPUSH
76658: PPUSH
76659: PPUSH
76660: PPUSH
76661: PPUSH
76662: PPUSH
76663: PPUSH
76664: PPUSH
76665: PPUSH
76666: PPUSH
76667: PPUSH
76668: PPUSH
76669: PPUSH
76670: PPUSH
76671: PPUSH
76672: PPUSH
76673: PPUSH
76674: PPUSH
76675: PPUSH
76676: PPUSH
76677: PPUSH
76678: PPUSH
76679: PPUSH
76680: PPUSH
76681: PPUSH
76682: PPUSH
76683: PPUSH
76684: PPUSH
76685: PPUSH
76686: PPUSH
76687: PPUSH
76688: PPUSH
76689: PPUSH
76690: PPUSH
76691: PPUSH
76692: PPUSH
76693: PPUSH
76694: PPUSH
76695: PPUSH
76696: PPUSH
76697: PPUSH
76698: PPUSH
76699: PPUSH
76700: PPUSH
76701: PPUSH
76702: PPUSH
76703: PPUSH
76704: PPUSH
76705: PPUSH
76706: PPUSH
76707: PPUSH
76708: PPUSH
// result = [ ] ;
76709: LD_ADDR_VAR 0 7
76713: PUSH
76714: EMPTY
76715: ST_TO_ADDR
// temp_list = [ ] ;
76716: LD_ADDR_VAR 0 9
76720: PUSH
76721: EMPTY
76722: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
76723: LD_VAR 0 4
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: LD_INT 2
76736: PUSH
76737: LD_INT 3
76739: PUSH
76740: LD_INT 4
76742: PUSH
76743: LD_INT 5
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: IN
76754: NOT
76755: PUSH
76756: LD_VAR 0 1
76760: PUSH
76761: LD_INT 0
76763: PUSH
76764: LD_INT 1
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: IN
76771: PUSH
76772: LD_VAR 0 5
76776: PUSH
76777: LD_INT 1
76779: PUSH
76780: LD_INT 2
76782: PUSH
76783: LD_INT 3
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: LIST
76790: IN
76791: NOT
76792: AND
76793: OR
76794: IFFALSE 76798
// exit ;
76796: GO 95183
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
76798: LD_VAR 0 1
76802: PUSH
76803: LD_INT 6
76805: PUSH
76806: LD_INT 7
76808: PUSH
76809: LD_INT 8
76811: PUSH
76812: LD_INT 13
76814: PUSH
76815: LD_INT 12
76817: PUSH
76818: LD_INT 15
76820: PUSH
76821: LD_INT 11
76823: PUSH
76824: LD_INT 14
76826: PUSH
76827: LD_INT 10
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: LIST
76834: LIST
76835: LIST
76836: LIST
76837: LIST
76838: LIST
76839: LIST
76840: IN
76841: IFFALSE 76851
// btype = b_lab ;
76843: LD_ADDR_VAR 0 1
76847: PUSH
76848: LD_INT 6
76850: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
76851: LD_VAR 0 6
76855: PUSH
76856: LD_INT 0
76858: PUSH
76859: LD_INT 1
76861: PUSH
76862: LD_INT 2
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: LIST
76869: IN
76870: NOT
76871: PUSH
76872: LD_VAR 0 1
76876: PUSH
76877: LD_INT 0
76879: PUSH
76880: LD_INT 1
76882: PUSH
76883: LD_INT 2
76885: PUSH
76886: LD_INT 3
76888: PUSH
76889: LD_INT 6
76891: PUSH
76892: LD_INT 36
76894: PUSH
76895: LD_INT 4
76897: PUSH
76898: LD_INT 5
76900: PUSH
76901: LD_INT 31
76903: PUSH
76904: LD_INT 32
76906: PUSH
76907: LD_INT 33
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: IN
76923: NOT
76924: PUSH
76925: LD_VAR 0 6
76929: PUSH
76930: LD_INT 1
76932: EQUAL
76933: AND
76934: OR
76935: PUSH
76936: LD_VAR 0 1
76940: PUSH
76941: LD_INT 2
76943: PUSH
76944: LD_INT 3
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: IN
76951: NOT
76952: PUSH
76953: LD_VAR 0 6
76957: PUSH
76958: LD_INT 2
76960: EQUAL
76961: AND
76962: OR
76963: IFFALSE 76973
// mode = 0 ;
76965: LD_ADDR_VAR 0 6
76969: PUSH
76970: LD_INT 0
76972: ST_TO_ADDR
// case mode of 0 :
76973: LD_VAR 0 6
76977: PUSH
76978: LD_INT 0
76980: DOUBLE
76981: EQUAL
76982: IFTRUE 76986
76984: GO 88439
76986: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76987: LD_ADDR_VAR 0 11
76991: PUSH
76992: LD_INT 0
76994: PUSH
76995: LD_INT 0
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 0
77004: PUSH
77005: LD_INT 1
77007: NEG
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 1
77015: PUSH
77016: LD_INT 0
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: LD_INT 1
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 0
77035: PUSH
77036: LD_INT 1
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 1
77045: NEG
77046: PUSH
77047: LD_INT 0
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 1
77056: NEG
77057: PUSH
77058: LD_INT 1
77060: NEG
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 1
77068: NEG
77069: PUSH
77070: LD_INT 2
77072: NEG
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 0
77080: PUSH
77081: LD_INT 2
77083: NEG
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 1
77091: PUSH
77092: LD_INT 1
77094: NEG
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 1
77102: PUSH
77103: LD_INT 2
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 0
77112: PUSH
77113: LD_INT 2
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 1
77122: NEG
77123: PUSH
77124: LD_INT 1
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: LD_INT 1
77133: PUSH
77134: LD_INT 3
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 0
77143: PUSH
77144: LD_INT 3
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: LD_INT 2
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77180: LD_ADDR_VAR 0 12
77184: PUSH
77185: LD_INT 0
77187: PUSH
77188: LD_INT 0
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 0
77197: PUSH
77198: LD_INT 1
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 1
77208: PUSH
77209: LD_INT 0
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 1
77218: PUSH
77219: LD_INT 1
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 0
77228: PUSH
77229: LD_INT 1
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 1
77238: NEG
77239: PUSH
77240: LD_INT 0
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 1
77249: NEG
77250: PUSH
77251: LD_INT 1
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 1
77261: PUSH
77262: LD_INT 1
77264: NEG
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 2
77272: PUSH
77273: LD_INT 0
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 2
77282: PUSH
77283: LD_INT 1
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: PUSH
77290: LD_INT 1
77292: NEG
77293: PUSH
77294: LD_INT 1
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: LD_INT 2
77303: NEG
77304: PUSH
77305: LD_INT 0
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: LD_INT 2
77314: NEG
77315: PUSH
77316: LD_INT 1
77318: NEG
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 2
77326: NEG
77327: PUSH
77328: LD_INT 1
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 3
77337: NEG
77338: PUSH
77339: LD_INT 0
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 3
77348: NEG
77349: PUSH
77350: LD_INT 1
77352: NEG
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: LIST
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: LIST
77375: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77376: LD_ADDR_VAR 0 13
77380: PUSH
77381: LD_INT 0
77383: PUSH
77384: LD_INT 0
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 0
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 1
77404: PUSH
77405: LD_INT 0
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 1
77414: PUSH
77415: LD_INT 1
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 0
77424: PUSH
77425: LD_INT 1
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 1
77434: NEG
77435: PUSH
77436: LD_INT 0
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 1
77445: NEG
77446: PUSH
77447: LD_INT 1
77449: NEG
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 1
77457: NEG
77458: PUSH
77459: LD_INT 2
77461: NEG
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 2
77469: PUSH
77470: LD_INT 1
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 2
77479: PUSH
77480: LD_INT 2
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: PUSH
77490: LD_INT 2
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 2
77499: NEG
77500: PUSH
77501: LD_INT 1
77503: NEG
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 2
77511: NEG
77512: PUSH
77513: LD_INT 2
77515: NEG
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 2
77523: NEG
77524: PUSH
77525: LD_INT 3
77527: NEG
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 3
77535: NEG
77536: PUSH
77537: LD_INT 2
77539: NEG
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 3
77547: NEG
77548: PUSH
77549: LD_INT 3
77551: NEG
77552: PUSH
77553: EMPTY
77554: LIST
77555: LIST
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: LIST
77568: LIST
77569: LIST
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77575: LD_ADDR_VAR 0 14
77579: PUSH
77580: LD_INT 0
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 0
77592: PUSH
77593: LD_INT 1
77595: NEG
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 1
77603: PUSH
77604: LD_INT 0
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 1
77613: PUSH
77614: LD_INT 1
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 0
77623: PUSH
77624: LD_INT 1
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 1
77633: NEG
77634: PUSH
77635: LD_INT 0
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 1
77644: NEG
77645: PUSH
77646: LD_INT 1
77648: NEG
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: LD_INT 1
77656: NEG
77657: PUSH
77658: LD_INT 2
77660: NEG
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 0
77668: PUSH
77669: LD_INT 2
77671: NEG
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 1
77679: PUSH
77680: LD_INT 1
77682: NEG
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 1
77690: PUSH
77691: LD_INT 2
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 0
77700: PUSH
77701: LD_INT 2
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 1
77710: NEG
77711: PUSH
77712: LD_INT 1
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 1
77721: NEG
77722: PUSH
77723: LD_INT 3
77725: NEG
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 0
77733: PUSH
77734: LD_INT 3
77736: NEG
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 1
77744: PUSH
77745: LD_INT 2
77747: NEG
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77771: LD_ADDR_VAR 0 15
77775: PUSH
77776: LD_INT 0
77778: PUSH
77779: LD_INT 0
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 0
77788: PUSH
77789: LD_INT 1
77791: NEG
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 1
77799: PUSH
77800: LD_INT 0
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 1
77809: PUSH
77810: LD_INT 1
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 0
77819: PUSH
77820: LD_INT 1
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 1
77840: NEG
77841: PUSH
77842: LD_INT 1
77844: NEG
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 1
77852: PUSH
77853: LD_INT 1
77855: NEG
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 2
77863: PUSH
77864: LD_INT 0
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 2
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 1
77883: NEG
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: EMPTY
77889: LIST
77890: LIST
77891: PUSH
77892: LD_INT 2
77894: NEG
77895: PUSH
77896: LD_INT 0
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 2
77905: NEG
77906: PUSH
77907: LD_INT 1
77909: NEG
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 2
77917: PUSH
77918: LD_INT 1
77920: NEG
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PUSH
77926: LD_INT 3
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 3
77938: PUSH
77939: LD_INT 1
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: LIST
77950: LIST
77951: LIST
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77964: LD_ADDR_VAR 0 16
77968: PUSH
77969: LD_INT 0
77971: PUSH
77972: LD_INT 0
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 0
77981: PUSH
77982: LD_INT 1
77984: NEG
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 1
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: LD_INT 1
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: LD_INT 1
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 1
78022: NEG
78023: PUSH
78024: LD_INT 0
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 1
78033: NEG
78034: PUSH
78035: LD_INT 1
78037: NEG
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: PUSH
78043: LD_INT 1
78045: NEG
78046: PUSH
78047: LD_INT 2
78049: NEG
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 2
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: PUSH
78065: LD_INT 2
78067: PUSH
78068: LD_INT 2
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PUSH
78075: LD_INT 1
78077: PUSH
78078: LD_INT 2
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: LD_INT 2
78087: NEG
78088: PUSH
78089: LD_INT 1
78091: NEG
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 2
78099: NEG
78100: PUSH
78101: LD_INT 2
78103: NEG
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 3
78111: PUSH
78112: LD_INT 2
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 3
78121: PUSH
78122: LD_INT 3
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 2
78131: PUSH
78132: LD_INT 3
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78157: LD_ADDR_VAR 0 17
78161: PUSH
78162: LD_INT 0
78164: PUSH
78165: LD_INT 0
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 0
78174: PUSH
78175: LD_INT 1
78177: NEG
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 1
78185: PUSH
78186: LD_INT 0
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 1
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 0
78205: PUSH
78206: LD_INT 1
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 1
78215: NEG
78216: PUSH
78217: LD_INT 0
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 1
78226: NEG
78227: PUSH
78228: LD_INT 1
78230: NEG
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 1
78238: NEG
78239: PUSH
78240: LD_INT 2
78242: NEG
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 0
78250: PUSH
78251: LD_INT 2
78253: NEG
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 1
78261: PUSH
78262: LD_INT 1
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 2
78272: PUSH
78273: LD_INT 0
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 2
78282: PUSH
78283: LD_INT 1
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 2
78292: PUSH
78293: LD_INT 2
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 1
78302: PUSH
78303: LD_INT 2
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 0
78312: PUSH
78313: LD_INT 2
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 1
78322: NEG
78323: PUSH
78324: LD_INT 1
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 2
78333: NEG
78334: PUSH
78335: LD_INT 0
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 2
78344: NEG
78345: PUSH
78346: LD_INT 1
78348: NEG
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 2
78356: NEG
78357: PUSH
78358: LD_INT 2
78360: NEG
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78387: LD_ADDR_VAR 0 18
78391: PUSH
78392: LD_INT 0
78394: PUSH
78395: LD_INT 0
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 0
78404: PUSH
78405: LD_INT 1
78407: NEG
78408: PUSH
78409: EMPTY
78410: LIST
78411: LIST
78412: PUSH
78413: LD_INT 1
78415: PUSH
78416: LD_INT 0
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 1
78425: PUSH
78426: LD_INT 1
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 0
78435: PUSH
78436: LD_INT 1
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PUSH
78443: LD_INT 1
78445: NEG
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 1
78456: NEG
78457: PUSH
78458: LD_INT 1
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: LD_INT 2
78472: NEG
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 0
78480: PUSH
78481: LD_INT 2
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: PUSH
78492: LD_INT 1
78494: NEG
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 2
78502: PUSH
78503: LD_INT 0
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 2
78512: PUSH
78513: LD_INT 1
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 2
78522: PUSH
78523: LD_INT 2
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 1
78532: PUSH
78533: LD_INT 2
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: LD_INT 2
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 1
78552: NEG
78553: PUSH
78554: LD_INT 1
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 2
78563: NEG
78564: PUSH
78565: LD_INT 0
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 2
78574: NEG
78575: PUSH
78576: LD_INT 1
78578: NEG
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 2
78586: NEG
78587: PUSH
78588: LD_INT 2
78590: NEG
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78617: LD_ADDR_VAR 0 19
78621: PUSH
78622: LD_INT 0
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: LD_INT 1
78637: NEG
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: LD_INT 1
78645: PUSH
78646: LD_INT 0
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 1
78655: PUSH
78656: LD_INT 1
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 0
78665: PUSH
78666: LD_INT 1
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 1
78675: NEG
78676: PUSH
78677: LD_INT 0
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 1
78686: NEG
78687: PUSH
78688: LD_INT 1
78690: NEG
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 1
78698: NEG
78699: PUSH
78700: LD_INT 2
78702: NEG
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: LD_INT 2
78713: NEG
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 1
78721: PUSH
78722: LD_INT 1
78724: NEG
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 2
78732: PUSH
78733: LD_INT 0
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 2
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 2
78752: PUSH
78753: LD_INT 2
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 1
78762: PUSH
78763: LD_INT 2
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: LD_INT 0
78772: PUSH
78773: LD_INT 2
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 1
78782: NEG
78783: PUSH
78784: LD_INT 1
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 2
78793: NEG
78794: PUSH
78795: LD_INT 0
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 2
78804: NEG
78805: PUSH
78806: LD_INT 1
78808: NEG
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 2
78816: NEG
78817: PUSH
78818: LD_INT 2
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78847: LD_ADDR_VAR 0 20
78851: PUSH
78852: LD_INT 0
78854: PUSH
78855: LD_INT 0
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 0
78864: PUSH
78865: LD_INT 1
78867: NEG
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: PUSH
78873: LD_INT 1
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 1
78885: PUSH
78886: LD_INT 1
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 0
78895: PUSH
78896: LD_INT 1
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 1
78905: NEG
78906: PUSH
78907: LD_INT 0
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 1
78916: NEG
78917: PUSH
78918: LD_INT 1
78920: NEG
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 1
78928: NEG
78929: PUSH
78930: LD_INT 2
78932: NEG
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 0
78940: PUSH
78941: LD_INT 2
78943: NEG
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 1
78951: PUSH
78952: LD_INT 1
78954: NEG
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 2
78962: PUSH
78963: LD_INT 0
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 2
78972: PUSH
78973: LD_INT 1
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 2
78982: PUSH
78983: LD_INT 2
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 1
78992: PUSH
78993: LD_INT 2
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 0
79002: PUSH
79003: LD_INT 2
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 1
79012: NEG
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 2
79023: NEG
79024: PUSH
79025: LD_INT 0
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 2
79034: NEG
79035: PUSH
79036: LD_INT 1
79038: NEG
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 2
79046: NEG
79047: PUSH
79048: LD_INT 2
79050: NEG
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79077: LD_ADDR_VAR 0 21
79081: PUSH
79082: LD_INT 0
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 0
79094: PUSH
79095: LD_INT 1
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 1
79105: PUSH
79106: LD_INT 0
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 1
79115: PUSH
79116: LD_INT 1
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 0
79125: PUSH
79126: LD_INT 1
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 1
79135: NEG
79136: PUSH
79137: LD_INT 0
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 1
79146: NEG
79147: PUSH
79148: LD_INT 1
79150: NEG
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 1
79158: NEG
79159: PUSH
79160: LD_INT 2
79162: NEG
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 0
79170: PUSH
79171: LD_INT 2
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 1
79181: PUSH
79182: LD_INT 1
79184: NEG
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 2
79192: PUSH
79193: LD_INT 0
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 2
79202: PUSH
79203: LD_INT 1
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 2
79212: PUSH
79213: LD_INT 2
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: LD_INT 2
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 0
79232: PUSH
79233: LD_INT 2
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 1
79242: NEG
79243: PUSH
79244: LD_INT 1
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 2
79253: NEG
79254: PUSH
79255: LD_INT 0
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 2
79264: NEG
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 2
79276: NEG
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79307: LD_ADDR_VAR 0 22
79311: PUSH
79312: LD_INT 0
79314: PUSH
79315: LD_INT 0
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 0
79324: PUSH
79325: LD_INT 1
79327: NEG
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 1
79335: PUSH
79336: LD_INT 0
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 1
79345: PUSH
79346: LD_INT 1
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 0
79355: PUSH
79356: LD_INT 1
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 1
79365: NEG
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 1
79376: NEG
79377: PUSH
79378: LD_INT 1
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 1
79388: NEG
79389: PUSH
79390: LD_INT 2
79392: NEG
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 0
79400: PUSH
79401: LD_INT 2
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 1
79411: PUSH
79412: LD_INT 1
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 2
79422: PUSH
79423: LD_INT 0
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 2
79432: PUSH
79433: LD_INT 1
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 2
79442: PUSH
79443: LD_INT 2
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 1
79452: PUSH
79453: LD_INT 2
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 0
79462: PUSH
79463: LD_INT 2
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 1
79472: NEG
79473: PUSH
79474: LD_INT 1
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 2
79483: NEG
79484: PUSH
79485: LD_INT 0
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 2
79494: NEG
79495: PUSH
79496: LD_INT 1
79498: NEG
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 2
79506: NEG
79507: PUSH
79508: LD_INT 2
79510: NEG
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: LIST
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79537: LD_ADDR_VAR 0 23
79541: PUSH
79542: LD_INT 0
79544: PUSH
79545: LD_INT 0
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 0
79554: PUSH
79555: LD_INT 1
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 1
79565: PUSH
79566: LD_INT 0
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PUSH
79573: LD_INT 1
79575: PUSH
79576: LD_INT 1
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 0
79585: PUSH
79586: LD_INT 1
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 1
79595: NEG
79596: PUSH
79597: LD_INT 0
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 1
79606: NEG
79607: PUSH
79608: LD_INT 1
79610: NEG
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 1
79618: NEG
79619: PUSH
79620: LD_INT 2
79622: NEG
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 0
79630: PUSH
79631: LD_INT 2
79633: NEG
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 1
79641: PUSH
79642: LD_INT 1
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 2
79652: PUSH
79653: LD_INT 0
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 2
79662: PUSH
79663: LD_INT 1
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 2
79672: PUSH
79673: LD_INT 2
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 1
79682: PUSH
79683: LD_INT 2
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 0
79692: PUSH
79693: LD_INT 2
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: LD_INT 1
79702: NEG
79703: PUSH
79704: LD_INT 1
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 2
79713: NEG
79714: PUSH
79715: LD_INT 0
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 2
79724: NEG
79725: PUSH
79726: LD_INT 1
79728: NEG
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 2
79736: NEG
79737: PUSH
79738: LD_INT 2
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 2
79748: NEG
79749: PUSH
79750: LD_INT 3
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 1
79760: NEG
79761: PUSH
79762: LD_INT 3
79764: NEG
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 1
79772: PUSH
79773: LD_INT 2
79775: NEG
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 2
79783: PUSH
79784: LD_INT 1
79786: NEG
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: LIST
79811: LIST
79812: LIST
79813: LIST
79814: LIST
79815: LIST
79816: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
79817: LD_ADDR_VAR 0 24
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: LD_INT 0
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 0
79834: PUSH
79835: LD_INT 1
79837: NEG
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: LD_INT 1
79845: PUSH
79846: LD_INT 0
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 1
79855: PUSH
79856: LD_INT 1
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 0
79865: PUSH
79866: LD_INT 1
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: LD_INT 0
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 1
79886: NEG
79887: PUSH
79888: LD_INT 1
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 1
79898: NEG
79899: PUSH
79900: LD_INT 2
79902: NEG
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 0
79910: PUSH
79911: LD_INT 2
79913: NEG
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: LD_INT 1
79924: NEG
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 2
79932: PUSH
79933: LD_INT 0
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 2
79942: PUSH
79943: LD_INT 1
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 2
79952: PUSH
79953: LD_INT 2
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 1
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 0
79972: PUSH
79973: LD_INT 2
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: LD_INT 1
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 2
79993: NEG
79994: PUSH
79995: LD_INT 0
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 2
80004: NEG
80005: PUSH
80006: LD_INT 1
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 2
80016: NEG
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 2
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: LD_INT 1
80042: NEG
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 3
80050: PUSH
80051: LD_INT 1
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 3
80060: PUSH
80061: LD_INT 2
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80093: LD_ADDR_VAR 0 25
80097: PUSH
80098: LD_INT 0
80100: PUSH
80101: LD_INT 0
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 0
80110: PUSH
80111: LD_INT 1
80113: NEG
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: LD_INT 0
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: LD_INT 1
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 0
80141: PUSH
80142: LD_INT 1
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 0
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 1
80162: NEG
80163: PUSH
80164: LD_INT 1
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 1
80174: NEG
80175: PUSH
80176: LD_INT 2
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 0
80186: PUSH
80187: LD_INT 2
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 1
80197: PUSH
80198: LD_INT 1
80200: NEG
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 2
80208: PUSH
80209: LD_INT 0
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 2
80218: PUSH
80219: LD_INT 1
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: PUSH
80229: LD_INT 2
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 1
80238: PUSH
80239: LD_INT 2
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 0
80248: PUSH
80249: LD_INT 2
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 1
80258: NEG
80259: PUSH
80260: LD_INT 1
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 2
80269: NEG
80270: PUSH
80271: LD_INT 0
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 2
80280: NEG
80281: PUSH
80282: LD_INT 1
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: NEG
80293: PUSH
80294: LD_INT 2
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 3
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 3
80314: PUSH
80315: LD_INT 2
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 2
80324: PUSH
80325: LD_INT 3
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: LD_INT 3
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80367: LD_ADDR_VAR 0 26
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: LD_INT 0
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 0
80384: PUSH
80385: LD_INT 1
80387: NEG
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 1
80395: PUSH
80396: LD_INT 0
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 1
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 0
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 1
80425: NEG
80426: PUSH
80427: LD_INT 0
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 1
80436: NEG
80437: PUSH
80438: LD_INT 1
80440: NEG
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 1
80448: NEG
80449: PUSH
80450: LD_INT 2
80452: NEG
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 0
80460: PUSH
80461: LD_INT 2
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: LD_INT 1
80474: NEG
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 2
80482: PUSH
80483: LD_INT 0
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 2
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: LD_INT 2
80502: PUSH
80503: LD_INT 2
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 1
80512: PUSH
80513: LD_INT 2
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 0
80522: PUSH
80523: LD_INT 2
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 1
80532: NEG
80533: PUSH
80534: LD_INT 1
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 2
80543: NEG
80544: PUSH
80545: LD_INT 0
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 2
80554: NEG
80555: PUSH
80556: LD_INT 1
80558: NEG
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 2
80566: NEG
80567: PUSH
80568: LD_INT 2
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 2
80578: PUSH
80579: LD_INT 3
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 1
80588: PUSH
80589: LD_INT 3
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 1
80598: NEG
80599: PUSH
80600: LD_INT 2
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 2
80609: NEG
80610: PUSH
80611: LD_INT 1
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80643: LD_ADDR_VAR 0 27
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 0
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: LD_INT 1
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: PUSH
80672: LD_INT 0
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 1
80681: PUSH
80682: LD_INT 1
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 0
80691: PUSH
80692: LD_INT 1
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 1
80701: NEG
80702: PUSH
80703: LD_INT 0
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 1
80712: NEG
80713: PUSH
80714: LD_INT 1
80716: NEG
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 1
80724: NEG
80725: PUSH
80726: LD_INT 2
80728: NEG
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 0
80736: PUSH
80737: LD_INT 2
80739: NEG
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 1
80747: PUSH
80748: LD_INT 1
80750: NEG
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 2
80758: PUSH
80759: LD_INT 0
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 2
80768: PUSH
80769: LD_INT 1
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 2
80778: PUSH
80779: LD_INT 2
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 1
80788: PUSH
80789: LD_INT 2
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 0
80798: PUSH
80799: LD_INT 2
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 1
80808: NEG
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 2
80819: NEG
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 2
80830: NEG
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 2
80842: NEG
80843: PUSH
80844: LD_INT 2
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 1
80854: NEG
80855: PUSH
80856: LD_INT 2
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 2
80865: NEG
80866: PUSH
80867: LD_INT 1
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 3
80876: NEG
80877: PUSH
80878: LD_INT 1
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 3
80888: NEG
80889: PUSH
80890: LD_INT 2
80892: NEG
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80923: LD_ADDR_VAR 0 28
80927: PUSH
80928: LD_INT 0
80930: PUSH
80931: LD_INT 0
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: LD_INT 1
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 1
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 1
80961: PUSH
80962: LD_INT 1
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: LD_INT 1
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: NEG
80982: PUSH
80983: LD_INT 0
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 1
80992: NEG
80993: PUSH
80994: LD_INT 1
80996: NEG
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 1
81004: NEG
81005: PUSH
81006: LD_INT 2
81008: NEG
81009: PUSH
81010: EMPTY
81011: LIST
81012: LIST
81013: PUSH
81014: LD_INT 0
81016: PUSH
81017: LD_INT 2
81019: NEG
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 1
81027: PUSH
81028: LD_INT 1
81030: NEG
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 2
81038: PUSH
81039: LD_INT 0
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: PUSH
81046: LD_INT 2
81048: PUSH
81049: LD_INT 1
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 2
81058: PUSH
81059: LD_INT 2
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 1
81068: PUSH
81069: LD_INT 2
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 0
81078: PUSH
81079: LD_INT 2
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 1
81088: NEG
81089: PUSH
81090: LD_INT 1
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 2
81099: NEG
81100: PUSH
81101: LD_INT 0
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 2
81110: NEG
81111: PUSH
81112: LD_INT 1
81114: NEG
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: LD_INT 2
81122: NEG
81123: PUSH
81124: LD_INT 2
81126: NEG
81127: PUSH
81128: EMPTY
81129: LIST
81130: LIST
81131: PUSH
81132: LD_INT 2
81134: NEG
81135: PUSH
81136: LD_INT 3
81138: NEG
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 1
81146: NEG
81147: PUSH
81148: LD_INT 3
81150: NEG
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 3
81158: NEG
81159: PUSH
81160: LD_INT 1
81162: NEG
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 3
81170: NEG
81171: PUSH
81172: LD_INT 2
81174: NEG
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81205: LD_ADDR_VAR 0 29
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: LD_INT 0
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 0
81222: PUSH
81223: LD_INT 1
81225: NEG
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: LD_INT 0
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: LD_INT 1
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 0
81253: PUSH
81254: LD_INT 1
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: LD_INT 0
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 1
81274: NEG
81275: PUSH
81276: LD_INT 1
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 1
81286: NEG
81287: PUSH
81288: LD_INT 2
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: LD_INT 2
81301: NEG
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 1
81309: PUSH
81310: LD_INT 1
81312: NEG
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 2
81320: PUSH
81321: LD_INT 0
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: LD_INT 1
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 1
81340: PUSH
81341: LD_INT 2
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: LD_INT 2
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 1
81360: NEG
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: LD_INT 2
81371: NEG
81372: PUSH
81373: LD_INT 1
81375: NEG
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: LD_INT 2
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 2
81395: NEG
81396: PUSH
81397: LD_INT 3
81399: NEG
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: LD_INT 1
81410: NEG
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: PUSH
81416: LD_INT 3
81418: PUSH
81419: LD_INT 1
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 1
81428: PUSH
81429: LD_INT 3
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 1
81438: NEG
81439: PUSH
81440: LD_INT 2
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 3
81449: NEG
81450: PUSH
81451: LD_INT 2
81453: NEG
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81484: LD_ADDR_VAR 0 30
81488: PUSH
81489: LD_INT 0
81491: PUSH
81492: LD_INT 0
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 0
81501: PUSH
81502: LD_INT 1
81504: NEG
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 1
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 1
81522: PUSH
81523: LD_INT 1
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 0
81532: PUSH
81533: LD_INT 1
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 1
81542: NEG
81543: PUSH
81544: LD_INT 0
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 1
81553: NEG
81554: PUSH
81555: LD_INT 1
81557: NEG
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 1
81565: NEG
81566: PUSH
81567: LD_INT 2
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 0
81577: PUSH
81578: LD_INT 2
81580: NEG
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 1
81588: PUSH
81589: LD_INT 1
81591: NEG
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 2
81599: PUSH
81600: LD_INT 0
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 2
81609: PUSH
81610: LD_INT 1
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 2
81619: PUSH
81620: LD_INT 2
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 1
81629: PUSH
81630: LD_INT 2
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 1
81639: NEG
81640: PUSH
81641: LD_INT 1
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 2
81650: NEG
81651: PUSH
81652: LD_INT 0
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 2
81661: NEG
81662: PUSH
81663: LD_INT 1
81665: NEG
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: LD_INT 1
81673: NEG
81674: PUSH
81675: LD_INT 3
81677: NEG
81678: PUSH
81679: EMPTY
81680: LIST
81681: LIST
81682: PUSH
81683: LD_INT 1
81685: PUSH
81686: LD_INT 2
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 3
81696: PUSH
81697: LD_INT 2
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 2
81706: PUSH
81707: LD_INT 3
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 2
81716: NEG
81717: PUSH
81718: LD_INT 1
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 3
81727: NEG
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81762: LD_ADDR_VAR 0 31
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: LD_INT 0
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 0
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 1
81790: PUSH
81791: LD_INT 0
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PUSH
81798: LD_INT 1
81800: PUSH
81801: LD_INT 1
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 0
81810: PUSH
81811: LD_INT 1
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: LD_INT 0
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 1
81831: NEG
81832: PUSH
81833: LD_INT 1
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 1
81843: NEG
81844: PUSH
81845: LD_INT 2
81847: NEG
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 1
81855: PUSH
81856: LD_INT 1
81858: NEG
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 2
81866: PUSH
81867: LD_INT 0
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: LD_INT 1
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 2
81886: PUSH
81887: LD_INT 2
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 1
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: LD_INT 2
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 1
81916: NEG
81917: PUSH
81918: LD_INT 1
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_INT 2
81927: NEG
81928: PUSH
81929: LD_INT 1
81931: NEG
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 2
81939: NEG
81940: PUSH
81941: LD_INT 2
81943: NEG
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 2
81951: NEG
81952: PUSH
81953: LD_INT 3
81955: NEG
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 2
81963: PUSH
81964: LD_INT 1
81966: NEG
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 3
81974: PUSH
81975: LD_INT 1
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 1
81984: PUSH
81985: LD_INT 3
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 1
81994: NEG
81995: PUSH
81996: LD_INT 2
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 3
82005: NEG
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82040: LD_ADDR_VAR 0 32
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: LD_INT 0
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 0
82057: PUSH
82058: LD_INT 1
82060: NEG
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: PUSH
82066: LD_INT 1
82068: PUSH
82069: LD_INT 0
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 1
82078: PUSH
82079: LD_INT 1
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 0
82088: PUSH
82089: LD_INT 1
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 1
82098: NEG
82099: PUSH
82100: LD_INT 0
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 1
82109: NEG
82110: PUSH
82111: LD_INT 1
82113: NEG
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: NEG
82122: PUSH
82123: LD_INT 2
82125: NEG
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 0
82133: PUSH
82134: LD_INT 2
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: LD_INT 1
82147: NEG
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: PUSH
82156: LD_INT 1
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 2
82165: PUSH
82166: LD_INT 2
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 1
82175: PUSH
82176: LD_INT 2
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 0
82185: PUSH
82186: LD_INT 2
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PUSH
82193: LD_INT 1
82195: NEG
82196: PUSH
82197: LD_INT 1
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 2
82206: NEG
82207: PUSH
82208: LD_INT 0
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 2
82217: NEG
82218: PUSH
82219: LD_INT 1
82221: NEG
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 1
82229: NEG
82230: PUSH
82231: LD_INT 3
82233: NEG
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 1
82241: PUSH
82242: LD_INT 2
82244: NEG
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 3
82252: PUSH
82253: LD_INT 2
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 2
82262: PUSH
82263: LD_INT 3
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 2
82272: NEG
82273: PUSH
82274: LD_INT 1
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 3
82283: NEG
82284: PUSH
82285: LD_INT 1
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82318: LD_ADDR_VAR 0 33
82322: PUSH
82323: LD_INT 0
82325: PUSH
82326: LD_INT 0
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 0
82335: PUSH
82336: LD_INT 1
82338: NEG
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 1
82346: PUSH
82347: LD_INT 0
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 1
82356: PUSH
82357: LD_INT 1
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 0
82366: PUSH
82367: LD_INT 1
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: LD_INT 0
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 1
82387: NEG
82388: PUSH
82389: LD_INT 1
82391: NEG
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 1
82399: NEG
82400: PUSH
82401: LD_INT 2
82403: NEG
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 1
82411: PUSH
82412: LD_INT 1
82414: NEG
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 2
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 2
82432: PUSH
82433: LD_INT 1
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 1
82442: PUSH
82443: LD_INT 2
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 0
82452: PUSH
82453: LD_INT 2
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 1
82462: NEG
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: LD_INT 2
82473: NEG
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 2
82484: NEG
82485: PUSH
82486: LD_INT 1
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 2
82496: NEG
82497: PUSH
82498: LD_INT 2
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 2
82508: NEG
82509: PUSH
82510: LD_INT 3
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 2
82520: PUSH
82521: LD_INT 1
82523: NEG
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 3
82531: PUSH
82532: LD_INT 1
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 1
82541: PUSH
82542: LD_INT 3
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 1
82551: NEG
82552: PUSH
82553: LD_INT 2
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 3
82562: NEG
82563: PUSH
82564: LD_INT 2
82566: NEG
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82597: LD_ADDR_VAR 0 34
82601: PUSH
82602: LD_INT 0
82604: PUSH
82605: LD_INT 0
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 0
82614: PUSH
82615: LD_INT 1
82617: NEG
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 1
82625: PUSH
82626: LD_INT 0
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 1
82635: PUSH
82636: LD_INT 1
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 0
82645: PUSH
82646: LD_INT 1
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: LD_INT 0
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 1
82666: NEG
82667: PUSH
82668: LD_INT 1
82670: NEG
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: LD_INT 2
82682: NEG
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 0
82690: PUSH
82691: LD_INT 2
82693: NEG
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 1
82701: PUSH
82702: LD_INT 1
82704: NEG
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 2
82712: PUSH
82713: LD_INT 1
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 2
82722: PUSH
82723: LD_INT 2
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: PUSH
82733: LD_INT 2
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 1
82742: NEG
82743: PUSH
82744: LD_INT 1
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 2
82753: NEG
82754: PUSH
82755: LD_INT 0
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 2
82764: NEG
82765: PUSH
82766: LD_INT 1
82768: NEG
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 2
82776: NEG
82777: PUSH
82778: LD_INT 2
82780: NEG
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 3
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: PUSH
82801: LD_INT 2
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 3
82811: PUSH
82812: LD_INT 2
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 2
82821: PUSH
82822: LD_INT 3
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 2
82831: NEG
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 3
82842: NEG
82843: PUSH
82844: LD_INT 1
82846: NEG
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82877: LD_ADDR_VAR 0 35
82881: PUSH
82882: LD_INT 0
82884: PUSH
82885: LD_INT 0
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 0
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 1
82905: PUSH
82906: LD_INT 0
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 1
82915: PUSH
82916: LD_INT 1
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 0
82925: PUSH
82926: LD_INT 1
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 1
82935: NEG
82936: PUSH
82937: LD_INT 0
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: LD_INT 1
82950: NEG
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 2
82958: PUSH
82959: LD_INT 1
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 2
82968: NEG
82969: PUSH
82970: LD_INT 1
82972: NEG
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
82989: LD_ADDR_VAR 0 36
82993: PUSH
82994: LD_INT 0
82996: PUSH
82997: LD_INT 0
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 1
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 1
83017: PUSH
83018: LD_INT 0
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: LD_INT 1
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 0
83037: PUSH
83038: LD_INT 1
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 1
83047: NEG
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: NEG
83059: PUSH
83060: LD_INT 1
83062: NEG
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 1
83070: NEG
83071: PUSH
83072: LD_INT 2
83074: NEG
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 1
83082: PUSH
83083: LD_INT 2
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83101: LD_ADDR_VAR 0 37
83105: PUSH
83106: LD_INT 0
83108: PUSH
83109: LD_INT 0
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 0
83118: PUSH
83119: LD_INT 1
83121: NEG
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 1
83129: PUSH
83130: LD_INT 0
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 1
83139: PUSH
83140: LD_INT 1
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: LD_INT 1
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: NEG
83160: PUSH
83161: LD_INT 0
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: NEG
83171: PUSH
83172: LD_INT 1
83174: NEG
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 1
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 1
83193: NEG
83194: PUSH
83195: LD_INT 1
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83213: LD_ADDR_VAR 0 38
83217: PUSH
83218: LD_INT 0
83220: PUSH
83221: LD_INT 0
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 0
83230: PUSH
83231: LD_INT 1
83233: NEG
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: LD_INT 0
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: PUSH
83252: LD_INT 1
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 0
83261: PUSH
83262: LD_INT 1
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 1
83271: NEG
83272: PUSH
83273: LD_INT 0
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 1
83286: NEG
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 2
83294: PUSH
83295: LD_INT 1
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 2
83304: NEG
83305: PUSH
83306: LD_INT 1
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83325: LD_ADDR_VAR 0 39
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: LD_INT 0
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 0
83342: PUSH
83343: LD_INT 1
83345: NEG
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: LD_INT 0
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 1
83363: PUSH
83364: LD_INT 1
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 0
83373: PUSH
83374: LD_INT 1
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: LD_INT 1
83383: NEG
83384: PUSH
83385: LD_INT 0
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 1
83394: NEG
83395: PUSH
83396: LD_INT 1
83398: NEG
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 1
83406: NEG
83407: PUSH
83408: LD_INT 2
83410: NEG
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 1
83418: PUSH
83419: LD_INT 2
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83437: LD_ADDR_VAR 0 40
83441: PUSH
83442: LD_INT 0
83444: PUSH
83445: LD_INT 0
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 0
83454: PUSH
83455: LD_INT 1
83457: NEG
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 1
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: PUSH
83476: LD_INT 1
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 0
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PUSH
83493: LD_INT 1
83495: NEG
83496: PUSH
83497: LD_INT 0
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 1
83506: NEG
83507: PUSH
83508: LD_INT 1
83510: NEG
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 1
83518: PUSH
83519: LD_INT 1
83521: NEG
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 1
83529: NEG
83530: PUSH
83531: LD_INT 1
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83549: LD_ADDR_VAR 0 41
83553: PUSH
83554: LD_INT 0
83556: PUSH
83557: LD_INT 0
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 0
83566: PUSH
83567: LD_INT 1
83569: NEG
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 1
83577: PUSH
83578: LD_INT 0
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: LD_INT 1
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: LD_INT 1
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 1
83607: NEG
83608: PUSH
83609: LD_INT 0
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 1
83630: NEG
83631: PUSH
83632: LD_INT 2
83634: NEG
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 1
83642: PUSH
83643: LD_INT 1
83645: NEG
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 2
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 2
83663: PUSH
83664: LD_INT 1
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 2
83673: PUSH
83674: LD_INT 2
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 1
83683: PUSH
83684: LD_INT 2
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 1
83693: NEG
83694: PUSH
83695: LD_INT 1
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 2
83704: NEG
83705: PUSH
83706: LD_INT 0
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: LD_INT 2
83715: NEG
83716: PUSH
83717: LD_INT 1
83719: NEG
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 2
83727: NEG
83728: PUSH
83729: LD_INT 2
83731: NEG
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 2
83739: NEG
83740: PUSH
83741: LD_INT 3
83743: NEG
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 2
83751: PUSH
83752: LD_INT 1
83754: NEG
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 3
83762: PUSH
83763: LD_INT 0
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 3
83772: PUSH
83773: LD_INT 1
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: PUSH
83780: LD_INT 3
83782: PUSH
83783: LD_INT 2
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PUSH
83790: LD_INT 3
83792: PUSH
83793: LD_INT 3
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 2
83802: PUSH
83803: LD_INT 3
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 2
83812: NEG
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 3
83823: NEG
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: LD_INT 3
83834: NEG
83835: PUSH
83836: LD_INT 1
83838: NEG
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 3
83846: NEG
83847: PUSH
83848: LD_INT 2
83850: NEG
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 3
83858: NEG
83859: PUSH
83860: LD_INT 3
83862: NEG
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83899: LD_ADDR_VAR 0 42
83903: PUSH
83904: LD_INT 0
83906: PUSH
83907: LD_INT 0
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 0
83916: PUSH
83917: LD_INT 1
83919: NEG
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 1
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 1
83937: PUSH
83938: LD_INT 1
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 0
83947: PUSH
83948: LD_INT 1
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 1
83957: NEG
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 1
83968: NEG
83969: PUSH
83970: LD_INT 1
83972: NEG
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 1
83980: NEG
83981: PUSH
83982: LD_INT 2
83984: NEG
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: LD_INT 2
83995: NEG
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: PUSH
84001: LD_INT 1
84003: PUSH
84004: LD_INT 1
84006: NEG
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 2
84014: PUSH
84015: LD_INT 1
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 2
84024: PUSH
84025: LD_INT 2
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PUSH
84032: LD_INT 1
84034: PUSH
84035: LD_INT 2
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 0
84044: PUSH
84045: LD_INT 2
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 1
84054: NEG
84055: PUSH
84056: LD_INT 1
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 2
84065: NEG
84066: PUSH
84067: LD_INT 1
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 2
84077: NEG
84078: PUSH
84079: LD_INT 2
84081: NEG
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 2
84089: NEG
84090: PUSH
84091: LD_INT 3
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 1
84101: NEG
84102: PUSH
84103: LD_INT 3
84105: NEG
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: LD_INT 3
84116: NEG
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: LD_INT 2
84127: NEG
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 3
84135: PUSH
84136: LD_INT 2
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 3
84145: PUSH
84146: LD_INT 3
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: PUSH
84153: LD_INT 2
84155: PUSH
84156: LD_INT 3
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 1
84165: PUSH
84166: LD_INT 3
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 0
84175: PUSH
84176: LD_INT 3
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 1
84185: NEG
84186: PUSH
84187: LD_INT 2
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 3
84196: NEG
84197: PUSH
84198: LD_INT 2
84200: NEG
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: LD_INT 3
84208: NEG
84209: PUSH
84210: LD_INT 3
84212: NEG
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84249: LD_ADDR_VAR 0 43
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: LD_INT 0
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 1
84277: PUSH
84278: LD_INT 0
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 1
84287: PUSH
84288: LD_INT 1
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 0
84297: PUSH
84298: LD_INT 1
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 1
84307: NEG
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: NEG
84331: PUSH
84332: LD_INT 2
84334: NEG
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: LD_INT 2
84345: NEG
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: PUSH
84354: LD_INT 1
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 2
84364: PUSH
84365: LD_INT 0
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 2
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: PUSH
84385: LD_INT 2
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 0
84394: PUSH
84395: LD_INT 2
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 1
84404: NEG
84405: PUSH
84406: LD_INT 1
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: NEG
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 2
84426: NEG
84427: PUSH
84428: LD_INT 1
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 1
84438: NEG
84439: PUSH
84440: LD_INT 3
84442: NEG
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 0
84450: PUSH
84451: LD_INT 3
84453: NEG
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 1
84461: PUSH
84462: LD_INT 2
84464: NEG
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 2
84472: PUSH
84473: LD_INT 1
84475: NEG
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: PUSH
84481: LD_INT 3
84483: PUSH
84484: LD_INT 0
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 3
84493: PUSH
84494: LD_INT 1
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 1
84503: PUSH
84504: LD_INT 3
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 0
84513: PUSH
84514: LD_INT 3
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 1
84523: NEG
84524: PUSH
84525: LD_INT 2
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 2
84534: NEG
84535: PUSH
84536: LD_INT 1
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PUSH
84543: LD_INT 3
84545: NEG
84546: PUSH
84547: LD_INT 0
84549: PUSH
84550: EMPTY
84551: LIST
84552: LIST
84553: PUSH
84554: LD_INT 3
84556: NEG
84557: PUSH
84558: LD_INT 1
84560: NEG
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84597: LD_ADDR_VAR 0 44
84601: PUSH
84602: LD_INT 0
84604: PUSH
84605: LD_INT 0
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 0
84614: PUSH
84615: LD_INT 1
84617: NEG
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 1
84625: PUSH
84626: LD_INT 0
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 1
84635: PUSH
84636: LD_INT 1
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: LD_INT 1
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 1
84655: NEG
84656: PUSH
84657: LD_INT 0
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 1
84666: NEG
84667: PUSH
84668: LD_INT 1
84670: NEG
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 1
84678: NEG
84679: PUSH
84680: LD_INT 2
84682: NEG
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 1
84690: PUSH
84691: LD_INT 1
84693: NEG
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 2
84701: PUSH
84702: LD_INT 0
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 2
84711: PUSH
84712: LD_INT 1
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 2
84721: PUSH
84722: LD_INT 2
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 1
84731: PUSH
84732: LD_INT 2
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: LD_INT 1
84741: NEG
84742: PUSH
84743: LD_INT 1
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: PUSH
84750: LD_INT 2
84752: NEG
84753: PUSH
84754: LD_INT 0
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 2
84763: NEG
84764: PUSH
84765: LD_INT 1
84767: NEG
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 2
84775: NEG
84776: PUSH
84777: LD_INT 2
84779: NEG
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 2
84787: NEG
84788: PUSH
84789: LD_INT 3
84791: NEG
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: LD_INT 2
84799: PUSH
84800: LD_INT 1
84802: NEG
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 3
84810: PUSH
84811: LD_INT 0
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 3
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 3
84830: PUSH
84831: LD_INT 2
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: LD_INT 3
84840: PUSH
84841: LD_INT 3
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 2
84850: PUSH
84851: LD_INT 3
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 2
84860: NEG
84861: PUSH
84862: LD_INT 1
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 3
84871: NEG
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: PUSH
84880: LD_INT 3
84882: NEG
84883: PUSH
84884: LD_INT 1
84886: NEG
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 3
84894: NEG
84895: PUSH
84896: LD_INT 2
84898: NEG
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 3
84906: NEG
84907: PUSH
84908: LD_INT 3
84910: NEG
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84947: LD_ADDR_VAR 0 45
84951: PUSH
84952: LD_INT 0
84954: PUSH
84955: LD_INT 0
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 0
84964: PUSH
84965: LD_INT 1
84967: NEG
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: PUSH
84973: LD_INT 1
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: LD_INT 1
84988: PUSH
84989: EMPTY
84990: LIST
84991: LIST
84992: PUSH
84993: LD_INT 0
84995: PUSH
84996: LD_INT 1
84998: PUSH
84999: EMPTY
85000: LIST
85001: LIST
85002: PUSH
85003: LD_INT 1
85005: NEG
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: EMPTY
85011: LIST
85012: LIST
85013: PUSH
85014: LD_INT 1
85016: NEG
85017: PUSH
85018: LD_INT 1
85020: NEG
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PUSH
85026: LD_INT 1
85028: NEG
85029: PUSH
85030: LD_INT 2
85032: NEG
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 0
85040: PUSH
85041: LD_INT 2
85043: NEG
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 1
85051: PUSH
85052: LD_INT 1
85054: NEG
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 2
85062: PUSH
85063: LD_INT 1
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: PUSH
85070: LD_INT 2
85072: PUSH
85073: LD_INT 2
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 1
85082: PUSH
85083: LD_INT 2
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 0
85092: PUSH
85093: LD_INT 2
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 1
85102: NEG
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 2
85113: NEG
85114: PUSH
85115: LD_INT 1
85117: NEG
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: PUSH
85123: LD_INT 2
85125: NEG
85126: PUSH
85127: LD_INT 2
85129: NEG
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: PUSH
85135: LD_INT 2
85137: NEG
85138: PUSH
85139: LD_INT 3
85141: NEG
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: LD_INT 3
85153: NEG
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 0
85161: PUSH
85162: LD_INT 3
85164: NEG
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: LD_INT 2
85175: NEG
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 3
85183: PUSH
85184: LD_INT 2
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 3
85193: PUSH
85194: LD_INT 3
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 2
85203: PUSH
85204: LD_INT 3
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 3
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: LD_INT 3
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: LD_INT 2
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 3
85244: NEG
85245: PUSH
85246: LD_INT 2
85248: NEG
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: LD_INT 3
85256: NEG
85257: PUSH
85258: LD_INT 3
85260: NEG
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: LIST
85273: LIST
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85297: LD_ADDR_VAR 0 46
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: LD_INT 0
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: LD_INT 0
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: LD_INT 1
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 1
85355: NEG
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: NEG
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: NEG
85379: PUSH
85380: LD_INT 2
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 0
85390: PUSH
85391: LD_INT 2
85393: NEG
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 1
85401: PUSH
85402: LD_INT 1
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 2
85412: PUSH
85413: LD_INT 0
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 2
85422: PUSH
85423: LD_INT 1
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 1
85432: PUSH
85433: LD_INT 2
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 0
85442: PUSH
85443: LD_INT 2
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 1
85452: NEG
85453: PUSH
85454: LD_INT 1
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 2
85463: NEG
85464: PUSH
85465: LD_INT 0
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 2
85474: NEG
85475: PUSH
85476: LD_INT 1
85478: NEG
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 1
85486: NEG
85487: PUSH
85488: LD_INT 3
85490: NEG
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: LD_INT 3
85501: NEG
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: LD_INT 2
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 2
85520: PUSH
85521: LD_INT 1
85523: NEG
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: PUSH
85529: LD_INT 3
85531: PUSH
85532: LD_INT 0
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 3
85541: PUSH
85542: LD_INT 1
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 1
85551: PUSH
85552: LD_INT 3
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 0
85561: PUSH
85562: LD_INT 3
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 1
85571: NEG
85572: PUSH
85573: LD_INT 2
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 2
85582: NEG
85583: PUSH
85584: LD_INT 1
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: LD_INT 3
85593: NEG
85594: PUSH
85595: LD_INT 0
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 3
85604: NEG
85605: PUSH
85606: LD_INT 1
85608: NEG
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85645: LD_ADDR_VAR 0 47
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: LD_INT 0
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 0
85662: PUSH
85663: LD_INT 1
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 1
85673: PUSH
85674: LD_INT 0
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 1
85683: PUSH
85684: LD_INT 1
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: PUSH
85691: LD_INT 0
85693: PUSH
85694: LD_INT 1
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 1
85703: NEG
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 1
85714: NEG
85715: PUSH
85716: LD_INT 1
85718: NEG
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 1
85726: NEG
85727: PUSH
85728: LD_INT 2
85730: NEG
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 0
85738: PUSH
85739: LD_INT 2
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 1
85749: PUSH
85750: LD_INT 1
85752: NEG
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 2
85760: NEG
85761: PUSH
85762: LD_INT 1
85764: NEG
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 2
85772: NEG
85773: PUSH
85774: LD_INT 2
85776: NEG
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85796: LD_ADDR_VAR 0 48
85800: PUSH
85801: LD_INT 0
85803: PUSH
85804: LD_INT 0
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: LD_INT 1
85816: NEG
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: PUSH
85825: LD_INT 0
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 1
85834: PUSH
85835: LD_INT 1
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 0
85844: PUSH
85845: LD_INT 1
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 1
85854: NEG
85855: PUSH
85856: LD_INT 0
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 1
85865: NEG
85866: PUSH
85867: LD_INT 1
85869: NEG
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 1
85877: NEG
85878: PUSH
85879: LD_INT 2
85881: NEG
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 0
85889: PUSH
85890: LD_INT 2
85892: NEG
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 1
85900: PUSH
85901: LD_INT 1
85903: NEG
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 2
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: LD_INT 2
85921: PUSH
85922: LD_INT 1
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85943: LD_ADDR_VAR 0 49
85947: PUSH
85948: LD_INT 0
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 0
85960: PUSH
85961: LD_INT 1
85963: NEG
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: PUSH
85969: LD_INT 1
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 1
85981: PUSH
85982: LD_INT 1
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 0
85991: PUSH
85992: LD_INT 1
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 1
86001: NEG
86002: PUSH
86003: LD_INT 0
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: NEG
86013: PUSH
86014: LD_INT 1
86016: NEG
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: LD_INT 1
86027: NEG
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 2
86035: PUSH
86036: LD_INT 0
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 2
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 2
86055: PUSH
86056: LD_INT 2
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86087: LD_ADDR_VAR 0 50
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: LD_INT 0
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: LD_INT 0
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: LD_INT 1
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 0
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 1
86145: NEG
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: LD_INT 1
86160: NEG
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: LD_INT 2
86168: PUSH
86169: LD_INT 1
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 2
86178: PUSH
86179: LD_INT 2
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 1
86188: PUSH
86189: LD_INT 2
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 0
86198: PUSH
86199: LD_INT 2
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 1
86208: NEG
86209: PUSH
86210: LD_INT 1
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
86231: LD_ADDR_VAR 0 51
86235: PUSH
86236: LD_INT 0
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 0
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: PUSH
86260: LD_INT 0
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: LD_INT 1
86269: PUSH
86270: LD_INT 1
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 0
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 1
86289: NEG
86290: PUSH
86291: LD_INT 0
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 1
86300: NEG
86301: PUSH
86302: LD_INT 1
86304: NEG
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 1
86312: PUSH
86313: LD_INT 2
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 0
86322: PUSH
86323: LD_INT 2
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 1
86332: NEG
86333: PUSH
86334: LD_INT 1
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 2
86343: NEG
86344: PUSH
86345: LD_INT 0
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 2
86354: NEG
86355: PUSH
86356: LD_INT 1
86358: NEG
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86378: LD_ADDR_VAR 0 52
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: LD_INT 0
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 0
86395: PUSH
86396: LD_INT 1
86398: NEG
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 1
86406: PUSH
86407: LD_INT 0
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: LD_INT 1
86416: PUSH
86417: LD_INT 1
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 0
86426: PUSH
86427: LD_INT 1
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 1
86436: NEG
86437: PUSH
86438: LD_INT 0
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 1
86447: NEG
86448: PUSH
86449: LD_INT 1
86451: NEG
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 1
86459: NEG
86460: PUSH
86461: LD_INT 2
86463: NEG
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: NEG
86472: PUSH
86473: LD_INT 1
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 2
86482: NEG
86483: PUSH
86484: LD_INT 0
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 2
86493: NEG
86494: PUSH
86495: LD_INT 1
86497: NEG
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 2
86505: NEG
86506: PUSH
86507: LD_INT 2
86509: NEG
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86529: LD_ADDR_VAR 0 53
86533: PUSH
86534: LD_INT 0
86536: PUSH
86537: LD_INT 0
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 0
86546: PUSH
86547: LD_INT 1
86549: NEG
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 1
86557: PUSH
86558: LD_INT 0
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 1
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 0
86577: PUSH
86578: LD_INT 1
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 1
86587: NEG
86588: PUSH
86589: LD_INT 0
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 1
86598: NEG
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 1
86610: NEG
86611: PUSH
86612: LD_INT 2
86614: NEG
86615: PUSH
86616: EMPTY
86617: LIST
86618: LIST
86619: PUSH
86620: LD_INT 0
86622: PUSH
86623: LD_INT 2
86625: NEG
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 1
86633: PUSH
86634: LD_INT 1
86636: NEG
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 2
86644: PUSH
86645: LD_INT 0
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 2
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 2
86664: PUSH
86665: LD_INT 2
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 1
86674: PUSH
86675: LD_INT 2
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 0
86684: PUSH
86685: LD_INT 2
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 1
86694: NEG
86695: PUSH
86696: LD_INT 1
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 2
86705: NEG
86706: PUSH
86707: LD_INT 0
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: LD_INT 2
86716: NEG
86717: PUSH
86718: LD_INT 1
86720: NEG
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 2
86728: NEG
86729: PUSH
86730: LD_INT 2
86732: NEG
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86759: LD_ADDR_VAR 0 54
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 0
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 0
86776: PUSH
86777: LD_INT 1
86779: NEG
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: PUSH
86788: LD_INT 0
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 1
86797: PUSH
86798: LD_INT 1
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 0
86807: PUSH
86808: LD_INT 1
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 1
86817: NEG
86818: PUSH
86819: LD_INT 0
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: NEG
86829: PUSH
86830: LD_INT 1
86832: NEG
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 1
86840: NEG
86841: PUSH
86842: LD_INT 2
86844: NEG
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: LD_INT 0
86852: PUSH
86853: LD_INT 2
86855: NEG
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 1
86863: PUSH
86864: LD_INT 1
86866: NEG
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: PUSH
86872: LD_INT 2
86874: PUSH
86875: LD_INT 0
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 2
86884: PUSH
86885: LD_INT 1
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 2
86894: PUSH
86895: LD_INT 2
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 1
86904: PUSH
86905: LD_INT 2
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 0
86914: PUSH
86915: LD_INT 2
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 1
86924: NEG
86925: PUSH
86926: LD_INT 1
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 2
86935: NEG
86936: PUSH
86937: LD_INT 0
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 2
86946: NEG
86947: PUSH
86948: LD_INT 1
86950: NEG
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 2
86958: NEG
86959: PUSH
86960: LD_INT 2
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86989: LD_ADDR_VAR 0 55
86993: PUSH
86994: LD_INT 0
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: LD_INT 1
87009: NEG
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: PUSH
87015: LD_INT 1
87017: PUSH
87018: LD_INT 0
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 1
87027: PUSH
87028: LD_INT 1
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 1
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 1
87047: NEG
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: LD_INT 1
87062: NEG
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 1
87070: NEG
87071: PUSH
87072: LD_INT 2
87074: NEG
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 0
87082: PUSH
87083: LD_INT 2
87085: NEG
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 1
87093: PUSH
87094: LD_INT 1
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 2
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 2
87114: PUSH
87115: LD_INT 1
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 2
87124: PUSH
87125: LD_INT 2
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 1
87134: PUSH
87135: LD_INT 2
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 0
87144: PUSH
87145: LD_INT 2
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 1
87154: NEG
87155: PUSH
87156: LD_INT 1
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 2
87165: NEG
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 2
87176: NEG
87177: PUSH
87178: LD_INT 1
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 2
87188: NEG
87189: PUSH
87190: LD_INT 2
87192: NEG
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87219: LD_ADDR_VAR 0 56
87223: PUSH
87224: LD_INT 0
87226: PUSH
87227: LD_INT 0
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 0
87236: PUSH
87237: LD_INT 1
87239: NEG
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 1
87247: PUSH
87248: LD_INT 0
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: LD_INT 1
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 0
87267: PUSH
87268: LD_INT 1
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 1
87277: NEG
87278: PUSH
87279: LD_INT 0
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 1
87288: NEG
87289: PUSH
87290: LD_INT 1
87292: NEG
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: NEG
87301: PUSH
87302: LD_INT 2
87304: NEG
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 0
87312: PUSH
87313: LD_INT 2
87315: NEG
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 1
87323: PUSH
87324: LD_INT 1
87326: NEG
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 2
87334: PUSH
87335: LD_INT 0
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 2
87344: PUSH
87345: LD_INT 1
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 2
87354: PUSH
87355: LD_INT 2
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 1
87364: PUSH
87365: LD_INT 2
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: LD_INT 2
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 1
87384: NEG
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 2
87395: NEG
87396: PUSH
87397: LD_INT 0
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: PUSH
87404: LD_INT 2
87406: NEG
87407: PUSH
87408: LD_INT 1
87410: NEG
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 2
87418: NEG
87419: PUSH
87420: LD_INT 2
87422: NEG
87423: PUSH
87424: EMPTY
87425: LIST
87426: LIST
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87449: LD_ADDR_VAR 0 57
87453: PUSH
87454: LD_INT 0
87456: PUSH
87457: LD_INT 0
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: LD_INT 1
87469: NEG
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: LD_INT 1
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: LD_INT 1
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 1
87518: NEG
87519: PUSH
87520: LD_INT 1
87522: NEG
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 1
87530: NEG
87531: PUSH
87532: LD_INT 2
87534: NEG
87535: PUSH
87536: EMPTY
87537: LIST
87538: LIST
87539: PUSH
87540: LD_INT 0
87542: PUSH
87543: LD_INT 2
87545: NEG
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 1
87553: PUSH
87554: LD_INT 1
87556: NEG
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: LD_INT 0
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: LD_INT 1
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 2
87584: PUSH
87585: LD_INT 2
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 1
87594: PUSH
87595: LD_INT 2
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 0
87604: PUSH
87605: LD_INT 2
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 1
87614: NEG
87615: PUSH
87616: LD_INT 1
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 2
87625: NEG
87626: PUSH
87627: LD_INT 0
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 2
87636: NEG
87637: PUSH
87638: LD_INT 1
87640: NEG
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 2
87648: NEG
87649: PUSH
87650: LD_INT 2
87652: NEG
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87679: LD_ADDR_VAR 0 58
87683: PUSH
87684: LD_INT 0
87686: PUSH
87687: LD_INT 0
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 0
87696: PUSH
87697: LD_INT 1
87699: NEG
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 1
87707: PUSH
87708: LD_INT 0
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 1
87717: PUSH
87718: LD_INT 1
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 0
87727: PUSH
87728: LD_INT 1
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 1
87737: NEG
87738: PUSH
87739: LD_INT 0
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: LD_INT 1
87748: NEG
87749: PUSH
87750: LD_INT 1
87752: NEG
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 1
87760: NEG
87761: PUSH
87762: LD_INT 2
87764: NEG
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 0
87772: PUSH
87773: LD_INT 2
87775: NEG
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 1
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 2
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: PUSH
87805: LD_INT 1
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 2
87814: PUSH
87815: LD_INT 2
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: PUSH
87825: LD_INT 2
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 0
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: PUSH
87842: LD_INT 1
87844: NEG
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: LD_INT 2
87855: NEG
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 2
87866: NEG
87867: PUSH
87868: LD_INT 1
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 2
87878: NEG
87879: PUSH
87880: LD_INT 2
87882: NEG
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87909: LD_ADDR_VAR 0 59
87913: PUSH
87914: LD_INT 0
87916: PUSH
87917: LD_INT 0
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 0
87926: PUSH
87927: LD_INT 1
87929: NEG
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: LD_INT 0
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PUSH
87945: LD_INT 1
87947: PUSH
87948: LD_INT 1
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: PUSH
87955: LD_INT 0
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: LD_INT 1
87967: NEG
87968: PUSH
87969: LD_INT 0
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 1
87978: NEG
87979: PUSH
87980: LD_INT 1
87982: NEG
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87997: LD_ADDR_VAR 0 60
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_INT 0
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 0
88014: PUSH
88015: LD_INT 1
88017: NEG
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 1
88025: PUSH
88026: LD_INT 0
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: PUSH
88033: LD_INT 1
88035: PUSH
88036: LD_INT 1
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: PUSH
88043: LD_INT 0
88045: PUSH
88046: LD_INT 1
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 1
88055: NEG
88056: PUSH
88057: LD_INT 0
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 1
88066: NEG
88067: PUSH
88068: LD_INT 1
88070: NEG
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88085: LD_ADDR_VAR 0 61
88089: PUSH
88090: LD_INT 0
88092: PUSH
88093: LD_INT 0
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 0
88102: PUSH
88103: LD_INT 1
88105: NEG
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 1
88113: PUSH
88114: LD_INT 0
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: PUSH
88121: LD_INT 1
88123: PUSH
88124: LD_INT 1
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: LD_INT 1
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 1
88143: NEG
88144: PUSH
88145: LD_INT 0
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: NEG
88155: PUSH
88156: LD_INT 1
88158: NEG
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88173: LD_ADDR_VAR 0 62
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: LD_INT 0
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: LD_INT 0
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: NEG
88243: PUSH
88244: LD_INT 1
88246: NEG
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: LIST
88256: LIST
88257: LIST
88258: LIST
88259: LIST
88260: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88261: LD_ADDR_VAR 0 63
88265: PUSH
88266: LD_INT 0
88268: PUSH
88269: LD_INT 0
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 0
88278: PUSH
88279: LD_INT 1
88281: NEG
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 1
88289: PUSH
88290: LD_INT 0
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: LD_INT 1
88299: PUSH
88300: LD_INT 1
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 0
88309: PUSH
88310: LD_INT 1
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 1
88319: NEG
88320: PUSH
88321: LD_INT 0
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: PUSH
88332: LD_INT 1
88334: NEG
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88349: LD_ADDR_VAR 0 64
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: LD_INT 0
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 0
88366: PUSH
88367: LD_INT 1
88369: NEG
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: PUSH
88378: LD_INT 0
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 1
88387: PUSH
88388: LD_INT 1
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 0
88397: PUSH
88398: LD_INT 1
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 1
88407: NEG
88408: PUSH
88409: LD_INT 0
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 1
88418: NEG
88419: PUSH
88420: LD_INT 1
88422: NEG
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: ST_TO_ADDR
// end ; 1 :
88437: GO 94334
88439: LD_INT 1
88441: DOUBLE
88442: EQUAL
88443: IFTRUE 88447
88445: GO 91070
88447: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88448: LD_ADDR_VAR 0 11
88452: PUSH
88453: LD_INT 1
88455: NEG
88456: PUSH
88457: LD_INT 3
88459: NEG
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 0
88467: PUSH
88468: LD_INT 3
88470: NEG
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: PUSH
88476: LD_INT 1
88478: PUSH
88479: LD_INT 2
88481: NEG
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: LIST
88491: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88492: LD_ADDR_VAR 0 12
88496: PUSH
88497: LD_INT 2
88499: PUSH
88500: LD_INT 1
88502: NEG
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 3
88510: PUSH
88511: LD_INT 0
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 3
88520: PUSH
88521: LD_INT 1
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: LIST
88532: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88533: LD_ADDR_VAR 0 13
88537: PUSH
88538: LD_INT 3
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 3
88550: PUSH
88551: LD_INT 3
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 2
88560: PUSH
88561: LD_INT 3
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: LIST
88572: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88573: LD_ADDR_VAR 0 14
88577: PUSH
88578: LD_INT 1
88580: PUSH
88581: LD_INT 3
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: LD_INT 3
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 1
88600: NEG
88601: PUSH
88602: LD_INT 2
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: EMPTY
88610: LIST
88611: LIST
88612: LIST
88613: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88614: LD_ADDR_VAR 0 15
88618: PUSH
88619: LD_INT 2
88621: NEG
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 3
88632: NEG
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 3
88643: NEG
88644: PUSH
88645: LD_INT 1
88647: NEG
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: LIST
88657: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88658: LD_ADDR_VAR 0 16
88662: PUSH
88663: LD_INT 2
88665: NEG
88666: PUSH
88667: LD_INT 3
88669: NEG
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: LD_INT 3
88677: NEG
88678: PUSH
88679: LD_INT 2
88681: NEG
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 3
88689: NEG
88690: PUSH
88691: LD_INT 3
88693: NEG
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: LIST
88703: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88704: LD_ADDR_VAR 0 17
88708: PUSH
88709: LD_INT 1
88711: NEG
88712: PUSH
88713: LD_INT 3
88715: NEG
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 0
88723: PUSH
88724: LD_INT 3
88726: NEG
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: LD_INT 2
88737: NEG
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: LIST
88747: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88748: LD_ADDR_VAR 0 18
88752: PUSH
88753: LD_INT 2
88755: PUSH
88756: LD_INT 1
88758: NEG
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 3
88766: PUSH
88767: LD_INT 0
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 3
88776: PUSH
88777: LD_INT 1
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: LIST
88788: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88789: LD_ADDR_VAR 0 19
88793: PUSH
88794: LD_INT 3
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 3
88806: PUSH
88807: LD_INT 3
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 2
88816: PUSH
88817: LD_INT 3
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: LIST
88828: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88829: LD_ADDR_VAR 0 20
88833: PUSH
88834: LD_INT 1
88836: PUSH
88837: LD_INT 3
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 0
88846: PUSH
88847: LD_INT 3
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 1
88856: NEG
88857: PUSH
88858: LD_INT 2
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: LIST
88869: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88870: LD_ADDR_VAR 0 21
88874: PUSH
88875: LD_INT 2
88877: NEG
88878: PUSH
88879: LD_INT 1
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: PUSH
88886: LD_INT 3
88888: NEG
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: PUSH
88897: LD_INT 3
88899: NEG
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: LIST
88913: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88914: LD_ADDR_VAR 0 22
88918: PUSH
88919: LD_INT 2
88921: NEG
88922: PUSH
88923: LD_INT 3
88925: NEG
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 3
88933: NEG
88934: PUSH
88935: LD_INT 2
88937: NEG
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 3
88945: NEG
88946: PUSH
88947: LD_INT 3
88949: NEG
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: LIST
88959: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
88960: LD_ADDR_VAR 0 23
88964: PUSH
88965: LD_INT 0
88967: PUSH
88968: LD_INT 3
88970: NEG
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 1
88978: NEG
88979: PUSH
88980: LD_INT 4
88982: NEG
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: LD_INT 3
88993: NEG
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: LIST
89003: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89004: LD_ADDR_VAR 0 24
89008: PUSH
89009: LD_INT 3
89011: PUSH
89012: LD_INT 0
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 3
89021: PUSH
89022: LD_INT 1
89024: NEG
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 4
89032: PUSH
89033: LD_INT 1
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: LIST
89044: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89045: LD_ADDR_VAR 0 25
89049: PUSH
89050: LD_INT 3
89052: PUSH
89053: LD_INT 3
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 4
89062: PUSH
89063: LD_INT 3
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: PUSH
89070: LD_INT 3
89072: PUSH
89073: LD_INT 4
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: LIST
89084: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89085: LD_ADDR_VAR 0 26
89089: PUSH
89090: LD_INT 0
89092: PUSH
89093: LD_INT 3
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 1
89102: PUSH
89103: LD_INT 4
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 1
89112: NEG
89113: PUSH
89114: LD_INT 3
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: LIST
89125: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89126: LD_ADDR_VAR 0 27
89130: PUSH
89131: LD_INT 3
89133: NEG
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 3
89144: NEG
89145: PUSH
89146: LD_INT 1
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 4
89155: NEG
89156: PUSH
89157: LD_INT 1
89159: NEG
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: LIST
89169: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89170: LD_ADDR_VAR 0 28
89174: PUSH
89175: LD_INT 3
89177: NEG
89178: PUSH
89179: LD_INT 3
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 3
89189: NEG
89190: PUSH
89191: LD_INT 4
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 4
89201: NEG
89202: PUSH
89203: LD_INT 3
89205: NEG
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: LIST
89215: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
89216: LD_ADDR_VAR 0 29
89220: PUSH
89221: LD_INT 1
89223: NEG
89224: PUSH
89225: LD_INT 3
89227: NEG
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: LD_INT 0
89235: PUSH
89236: LD_INT 3
89238: NEG
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: PUSH
89247: LD_INT 2
89249: NEG
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 1
89257: NEG
89258: PUSH
89259: LD_INT 4
89261: NEG
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PUSH
89267: LD_INT 0
89269: PUSH
89270: LD_INT 4
89272: NEG
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 1
89280: PUSH
89281: LD_INT 3
89283: NEG
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: LD_INT 5
89295: NEG
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: PUSH
89301: LD_INT 0
89303: PUSH
89304: LD_INT 5
89306: NEG
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 1
89314: PUSH
89315: LD_INT 4
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 6
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: LD_INT 6
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: LD_INT 5
89351: NEG
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
89371: LD_ADDR_VAR 0 30
89375: PUSH
89376: LD_INT 2
89378: PUSH
89379: LD_INT 1
89381: NEG
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 3
89389: PUSH
89390: LD_INT 0
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 3
89399: PUSH
89400: LD_INT 1
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: PUSH
89407: LD_INT 3
89409: PUSH
89410: LD_INT 1
89412: NEG
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 4
89420: PUSH
89421: LD_INT 0
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 4
89430: PUSH
89431: LD_INT 1
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 4
89440: PUSH
89441: LD_INT 1
89443: NEG
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 5
89451: PUSH
89452: LD_INT 0
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 5
89461: PUSH
89462: LD_INT 1
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 5
89471: PUSH
89472: LD_INT 1
89474: NEG
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 6
89482: PUSH
89483: LD_INT 0
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 6
89492: PUSH
89493: LD_INT 1
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
89514: LD_ADDR_VAR 0 31
89518: PUSH
89519: LD_INT 3
89521: PUSH
89522: LD_INT 2
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 3
89531: PUSH
89532: LD_INT 3
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 2
89541: PUSH
89542: LD_INT 3
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 4
89551: PUSH
89552: LD_INT 3
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 4
89561: PUSH
89562: LD_INT 4
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 3
89571: PUSH
89572: LD_INT 4
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 5
89581: PUSH
89582: LD_INT 4
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 5
89591: PUSH
89592: LD_INT 5
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 4
89601: PUSH
89602: LD_INT 5
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 6
89611: PUSH
89612: LD_INT 5
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 6
89621: PUSH
89622: LD_INT 6
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: PUSH
89629: LD_INT 5
89631: PUSH
89632: LD_INT 6
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
89653: LD_ADDR_VAR 0 32
89657: PUSH
89658: LD_INT 1
89660: PUSH
89661: LD_INT 3
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 0
89670: PUSH
89671: LD_INT 3
89673: PUSH
89674: EMPTY
89675: LIST
89676: LIST
89677: PUSH
89678: LD_INT 1
89680: NEG
89681: PUSH
89682: LD_INT 2
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: LD_INT 4
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 0
89701: PUSH
89702: LD_INT 4
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 1
89711: NEG
89712: PUSH
89713: LD_INT 3
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 1
89722: PUSH
89723: LD_INT 5
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 0
89732: PUSH
89733: LD_INT 5
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: NEG
89743: PUSH
89744: LD_INT 4
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 1
89753: PUSH
89754: LD_INT 6
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: LD_INT 0
89763: PUSH
89764: LD_INT 6
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 1
89773: NEG
89774: PUSH
89775: LD_INT 5
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
89796: LD_ADDR_VAR 0 33
89800: PUSH
89801: LD_INT 2
89803: NEG
89804: PUSH
89805: LD_INT 1
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 3
89814: NEG
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 3
89825: NEG
89826: PUSH
89827: LD_INT 1
89829: NEG
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 3
89837: NEG
89838: PUSH
89839: LD_INT 1
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 4
89848: NEG
89849: PUSH
89850: LD_INT 0
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 4
89859: NEG
89860: PUSH
89861: LD_INT 1
89863: NEG
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 4
89871: NEG
89872: PUSH
89873: LD_INT 1
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 5
89882: NEG
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 5
89893: NEG
89894: PUSH
89895: LD_INT 1
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 5
89905: NEG
89906: PUSH
89907: LD_INT 1
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 6
89916: NEG
89917: PUSH
89918: LD_INT 0
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 6
89927: NEG
89928: PUSH
89929: LD_INT 1
89931: NEG
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
89951: LD_ADDR_VAR 0 34
89955: PUSH
89956: LD_INT 2
89958: NEG
89959: PUSH
89960: LD_INT 3
89962: NEG
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: LD_INT 3
89970: NEG
89971: PUSH
89972: LD_INT 2
89974: NEG
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: PUSH
89980: LD_INT 3
89982: NEG
89983: PUSH
89984: LD_INT 3
89986: NEG
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 3
89994: NEG
89995: PUSH
89996: LD_INT 4
89998: NEG
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 4
90006: NEG
90007: PUSH
90008: LD_INT 3
90010: NEG
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: PUSH
90016: LD_INT 4
90018: NEG
90019: PUSH
90020: LD_INT 4
90022: NEG
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: LD_INT 4
90030: NEG
90031: PUSH
90032: LD_INT 5
90034: NEG
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 5
90042: NEG
90043: PUSH
90044: LD_INT 4
90046: NEG
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 5
90054: NEG
90055: PUSH
90056: LD_INT 5
90058: NEG
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 5
90066: NEG
90067: PUSH
90068: LD_INT 6
90070: NEG
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 6
90078: NEG
90079: PUSH
90080: LD_INT 5
90082: NEG
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: LD_INT 6
90090: NEG
90091: PUSH
90092: LD_INT 6
90094: NEG
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90114: LD_ADDR_VAR 0 41
90118: PUSH
90119: LD_INT 0
90121: PUSH
90122: LD_INT 2
90124: NEG
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 1
90132: NEG
90133: PUSH
90134: LD_INT 3
90136: NEG
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 1
90144: PUSH
90145: LD_INT 2
90147: NEG
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: LIST
90157: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90158: LD_ADDR_VAR 0 42
90162: PUSH
90163: LD_INT 2
90165: PUSH
90166: LD_INT 0
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 2
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 3
90186: PUSH
90187: LD_INT 1
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: LIST
90198: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90199: LD_ADDR_VAR 0 43
90203: PUSH
90204: LD_INT 2
90206: PUSH
90207: LD_INT 2
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 3
90216: PUSH
90217: LD_INT 2
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 2
90226: PUSH
90227: LD_INT 3
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: LIST
90238: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
90239: LD_ADDR_VAR 0 44
90243: PUSH
90244: LD_INT 0
90246: PUSH
90247: LD_INT 2
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 1
90256: PUSH
90257: LD_INT 3
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 1
90266: NEG
90267: PUSH
90268: LD_INT 2
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: LIST
90279: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90280: LD_ADDR_VAR 0 45
90284: PUSH
90285: LD_INT 2
90287: NEG
90288: PUSH
90289: LD_INT 0
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 2
90298: NEG
90299: PUSH
90300: LD_INT 1
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 3
90309: NEG
90310: PUSH
90311: LD_INT 1
90313: NEG
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: LIST
90323: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90324: LD_ADDR_VAR 0 46
90328: PUSH
90329: LD_INT 2
90331: NEG
90332: PUSH
90333: LD_INT 2
90335: NEG
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 2
90343: NEG
90344: PUSH
90345: LD_INT 3
90347: NEG
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PUSH
90353: LD_INT 3
90355: NEG
90356: PUSH
90357: LD_INT 2
90359: NEG
90360: PUSH
90361: EMPTY
90362: LIST
90363: LIST
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: LIST
90369: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
90370: LD_ADDR_VAR 0 47
90374: PUSH
90375: LD_INT 2
90377: NEG
90378: PUSH
90379: LD_INT 3
90381: NEG
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: LD_INT 1
90389: NEG
90390: PUSH
90391: LD_INT 3
90393: NEG
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
90403: LD_ADDR_VAR 0 48
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: LD_INT 2
90413: NEG
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 2
90421: PUSH
90422: LD_INT 1
90424: NEG
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
90434: LD_ADDR_VAR 0 49
90438: PUSH
90439: LD_INT 3
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 3
90451: PUSH
90452: LD_INT 2
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
90463: LD_ADDR_VAR 0 50
90467: PUSH
90468: LD_INT 2
90470: PUSH
90471: LD_INT 3
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 1
90480: PUSH
90481: LD_INT 3
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
90492: LD_ADDR_VAR 0 51
90496: PUSH
90497: LD_INT 1
90499: NEG
90500: PUSH
90501: LD_INT 2
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: PUSH
90508: LD_INT 2
90510: NEG
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
90523: LD_ADDR_VAR 0 52
90527: PUSH
90528: LD_INT 3
90530: NEG
90531: PUSH
90532: LD_INT 1
90534: NEG
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 3
90542: NEG
90543: PUSH
90544: LD_INT 2
90546: NEG
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: EMPTY
90553: LIST
90554: LIST
90555: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90556: LD_ADDR_VAR 0 53
90560: PUSH
90561: LD_INT 1
90563: NEG
90564: PUSH
90565: LD_INT 3
90567: NEG
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: LD_INT 3
90578: NEG
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: LD_INT 2
90589: NEG
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: LIST
90599: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90600: LD_ADDR_VAR 0 54
90604: PUSH
90605: LD_INT 2
90607: PUSH
90608: LD_INT 1
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 3
90618: PUSH
90619: LD_INT 0
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 3
90628: PUSH
90629: LD_INT 1
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: LIST
90640: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90641: LD_ADDR_VAR 0 55
90645: PUSH
90646: LD_INT 3
90648: PUSH
90649: LD_INT 2
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 3
90658: PUSH
90659: LD_INT 3
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 2
90668: PUSH
90669: LD_INT 3
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: LIST
90680: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90681: LD_ADDR_VAR 0 56
90685: PUSH
90686: LD_INT 1
90688: PUSH
90689: LD_INT 3
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 0
90698: PUSH
90699: LD_INT 3
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 1
90708: NEG
90709: PUSH
90710: LD_INT 2
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: LIST
90721: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90722: LD_ADDR_VAR 0 57
90726: PUSH
90727: LD_INT 2
90729: NEG
90730: PUSH
90731: LD_INT 1
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PUSH
90738: LD_INT 3
90740: NEG
90741: PUSH
90742: LD_INT 0
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 3
90751: NEG
90752: PUSH
90753: LD_INT 1
90755: NEG
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: LIST
90765: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90766: LD_ADDR_VAR 0 58
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: LD_INT 3
90777: NEG
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: PUSH
90783: LD_INT 3
90785: NEG
90786: PUSH
90787: LD_INT 2
90789: NEG
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 3
90797: NEG
90798: PUSH
90799: LD_INT 3
90801: NEG
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: LIST
90811: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
90812: LD_ADDR_VAR 0 59
90816: PUSH
90817: LD_INT 1
90819: NEG
90820: PUSH
90821: LD_INT 2
90823: NEG
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: LD_INT 2
90834: NEG
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 1
90842: PUSH
90843: LD_INT 1
90845: NEG
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: LIST
90855: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90856: LD_ADDR_VAR 0 60
90860: PUSH
90861: LD_INT 1
90863: PUSH
90864: LD_INT 1
90866: NEG
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 2
90874: PUSH
90875: LD_INT 0
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 2
90884: PUSH
90885: LD_INT 1
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: LIST
90896: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90897: LD_ADDR_VAR 0 61
90901: PUSH
90902: LD_INT 2
90904: PUSH
90905: LD_INT 1
90907: PUSH
90908: EMPTY
90909: LIST
90910: LIST
90911: PUSH
90912: LD_INT 2
90914: PUSH
90915: LD_INT 2
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: LD_INT 1
90924: PUSH
90925: LD_INT 2
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: LIST
90936: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90937: LD_ADDR_VAR 0 62
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: LD_INT 2
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 0
90954: PUSH
90955: LD_INT 2
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 1
90964: NEG
90965: PUSH
90966: LD_INT 1
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: LIST
90977: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90978: LD_ADDR_VAR 0 63
90982: PUSH
90983: LD_INT 1
90985: NEG
90986: PUSH
90987: LD_INT 1
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: LD_INT 2
90996: NEG
90997: PUSH
90998: LD_INT 0
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 2
91007: NEG
91008: PUSH
91009: LD_INT 1
91011: NEG
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: LIST
91021: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91022: LD_ADDR_VAR 0 64
91026: PUSH
91027: LD_INT 1
91029: NEG
91030: PUSH
91031: LD_INT 2
91033: NEG
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 2
91041: NEG
91042: PUSH
91043: LD_INT 1
91045: NEG
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: LD_INT 2
91053: NEG
91054: PUSH
91055: LD_INT 2
91057: NEG
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: LIST
91067: ST_TO_ADDR
// end ; 2 :
91068: GO 94334
91070: LD_INT 2
91072: DOUBLE
91073: EQUAL
91074: IFTRUE 91078
91076: GO 94333
91078: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91079: LD_ADDR_VAR 0 29
91083: PUSH
91084: LD_INT 4
91086: PUSH
91087: LD_INT 0
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 4
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 5
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PUSH
91115: LD_INT 5
91117: PUSH
91118: LD_INT 1
91120: PUSH
91121: EMPTY
91122: LIST
91123: LIST
91124: PUSH
91125: LD_INT 4
91127: PUSH
91128: LD_INT 1
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 3
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 3
91147: PUSH
91148: LD_INT 1
91150: NEG
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: LD_INT 3
91158: PUSH
91159: LD_INT 2
91161: NEG
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 5
91169: PUSH
91170: LD_INT 2
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: PUSH
91177: LD_INT 3
91179: PUSH
91180: LD_INT 3
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 3
91189: PUSH
91190: LD_INT 2
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 4
91199: PUSH
91200: LD_INT 3
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 4
91209: PUSH
91210: LD_INT 4
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 3
91219: PUSH
91220: LD_INT 4
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 2
91229: PUSH
91230: LD_INT 3
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 2
91239: PUSH
91240: LD_INT 2
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 4
91249: PUSH
91250: LD_INT 2
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 2
91259: PUSH
91260: LD_INT 4
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: LD_INT 4
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: LD_INT 3
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 1
91289: PUSH
91290: LD_INT 4
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 1
91299: PUSH
91300: LD_INT 5
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: LD_INT 5
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 1
91319: NEG
91320: PUSH
91321: LD_INT 4
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: PUSH
91328: LD_INT 1
91330: NEG
91331: PUSH
91332: LD_INT 3
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 2
91341: PUSH
91342: LD_INT 5
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 2
91351: NEG
91352: PUSH
91353: LD_INT 3
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 3
91362: NEG
91363: PUSH
91364: LD_INT 0
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 3
91373: NEG
91374: PUSH
91375: LD_INT 1
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 2
91385: NEG
91386: PUSH
91387: LD_INT 0
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 2
91396: NEG
91397: PUSH
91398: LD_INT 1
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 3
91407: NEG
91408: PUSH
91409: LD_INT 1
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 4
91418: NEG
91419: PUSH
91420: LD_INT 0
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 4
91429: NEG
91430: PUSH
91431: LD_INT 1
91433: NEG
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 4
91441: NEG
91442: PUSH
91443: LD_INT 2
91445: NEG
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 2
91453: NEG
91454: PUSH
91455: LD_INT 2
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 4
91464: NEG
91465: PUSH
91466: LD_INT 4
91468: NEG
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: PUSH
91474: LD_INT 4
91476: NEG
91477: PUSH
91478: LD_INT 5
91480: NEG
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 3
91488: NEG
91489: PUSH
91490: LD_INT 4
91492: NEG
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 3
91500: NEG
91501: PUSH
91502: LD_INT 3
91504: NEG
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 4
91512: NEG
91513: PUSH
91514: LD_INT 3
91516: NEG
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: LD_INT 5
91524: NEG
91525: PUSH
91526: LD_INT 4
91528: NEG
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 5
91536: NEG
91537: PUSH
91538: LD_INT 5
91540: NEG
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 3
91548: NEG
91549: PUSH
91550: LD_INT 5
91552: NEG
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 5
91560: NEG
91561: PUSH
91562: LD_INT 3
91564: NEG
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: LIST
91582: LIST
91583: LIST
91584: LIST
91585: LIST
91586: LIST
91587: LIST
91588: LIST
91589: LIST
91590: LIST
91591: LIST
91592: LIST
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
91617: LD_ADDR_VAR 0 30
91621: PUSH
91622: LD_INT 4
91624: PUSH
91625: LD_INT 4
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: LD_INT 4
91634: PUSH
91635: LD_INT 3
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 5
91644: PUSH
91645: LD_INT 4
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 5
91654: PUSH
91655: LD_INT 5
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 4
91664: PUSH
91665: LD_INT 5
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 3
91674: PUSH
91675: LD_INT 4
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 3
91684: PUSH
91685: LD_INT 3
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 5
91694: PUSH
91695: LD_INT 3
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 3
91704: PUSH
91705: LD_INT 5
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 0
91714: PUSH
91715: LD_INT 3
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 0
91724: PUSH
91725: LD_INT 2
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 1
91734: PUSH
91735: LD_INT 3
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 1
91744: PUSH
91745: LD_INT 4
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 0
91754: PUSH
91755: LD_INT 4
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 1
91764: NEG
91765: PUSH
91766: LD_INT 3
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: LD_INT 2
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 2
91786: PUSH
91787: LD_INT 4
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 2
91796: NEG
91797: PUSH
91798: LD_INT 2
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 4
91807: NEG
91808: PUSH
91809: LD_INT 0
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 4
91818: NEG
91819: PUSH
91820: LD_INT 1
91822: NEG
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 3
91830: NEG
91831: PUSH
91832: LD_INT 0
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: LD_INT 3
91841: NEG
91842: PUSH
91843: LD_INT 1
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 4
91852: NEG
91853: PUSH
91854: LD_INT 1
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 5
91863: NEG
91864: PUSH
91865: LD_INT 0
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 5
91874: NEG
91875: PUSH
91876: LD_INT 1
91878: NEG
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 5
91886: NEG
91887: PUSH
91888: LD_INT 2
91890: NEG
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: LD_INT 3
91898: NEG
91899: PUSH
91900: LD_INT 2
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 3
91909: NEG
91910: PUSH
91911: LD_INT 3
91913: NEG
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: PUSH
91919: LD_INT 3
91921: NEG
91922: PUSH
91923: LD_INT 4
91925: NEG
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 2
91933: NEG
91934: PUSH
91935: LD_INT 3
91937: NEG
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 2
91945: NEG
91946: PUSH
91947: LD_INT 2
91949: NEG
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: LD_INT 3
91957: NEG
91958: PUSH
91959: LD_INT 2
91961: NEG
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: PUSH
91967: LD_INT 4
91969: NEG
91970: PUSH
91971: LD_INT 3
91973: NEG
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: PUSH
91979: LD_INT 4
91981: NEG
91982: PUSH
91983: LD_INT 4
91985: NEG
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 2
91993: NEG
91994: PUSH
91995: LD_INT 4
91997: NEG
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 4
92005: NEG
92006: PUSH
92007: LD_INT 2
92009: NEG
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 0
92017: PUSH
92018: LD_INT 4
92020: NEG
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 0
92028: PUSH
92029: LD_INT 5
92031: NEG
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 1
92039: PUSH
92040: LD_INT 4
92042: NEG
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: LD_INT 3
92053: NEG
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: PUSH
92059: LD_INT 0
92061: PUSH
92062: LD_INT 3
92064: NEG
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: LD_INT 4
92076: NEG
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: PUSH
92082: LD_INT 1
92084: NEG
92085: PUSH
92086: LD_INT 5
92088: NEG
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 2
92096: PUSH
92097: LD_INT 3
92099: NEG
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 2
92107: NEG
92108: PUSH
92109: LD_INT 5
92111: NEG
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92164: LD_ADDR_VAR 0 31
92168: PUSH
92169: LD_INT 0
92171: PUSH
92172: LD_INT 4
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: PUSH
92179: LD_INT 0
92181: PUSH
92182: LD_INT 3
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: PUSH
92189: LD_INT 1
92191: PUSH
92192: LD_INT 4
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 1
92201: PUSH
92202: LD_INT 5
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: LD_INT 5
92214: PUSH
92215: EMPTY
92216: LIST
92217: LIST
92218: PUSH
92219: LD_INT 1
92221: NEG
92222: PUSH
92223: LD_INT 4
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 1
92232: NEG
92233: PUSH
92234: LD_INT 3
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: LD_INT 2
92243: PUSH
92244: LD_INT 5
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 2
92253: NEG
92254: PUSH
92255: LD_INT 3
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: PUSH
92262: LD_INT 3
92264: NEG
92265: PUSH
92266: LD_INT 0
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: LD_INT 3
92275: NEG
92276: PUSH
92277: LD_INT 1
92279: NEG
92280: PUSH
92281: EMPTY
92282: LIST
92283: LIST
92284: PUSH
92285: LD_INT 2
92287: NEG
92288: PUSH
92289: LD_INT 0
92291: PUSH
92292: EMPTY
92293: LIST
92294: LIST
92295: PUSH
92296: LD_INT 2
92298: NEG
92299: PUSH
92300: LD_INT 1
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 3
92309: NEG
92310: PUSH
92311: LD_INT 1
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 4
92320: NEG
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 4
92331: NEG
92332: PUSH
92333: LD_INT 1
92335: NEG
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 4
92343: NEG
92344: PUSH
92345: LD_INT 2
92347: NEG
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 2
92355: NEG
92356: PUSH
92357: LD_INT 2
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 4
92366: NEG
92367: PUSH
92368: LD_INT 4
92370: NEG
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 4
92378: NEG
92379: PUSH
92380: LD_INT 5
92382: NEG
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 3
92390: NEG
92391: PUSH
92392: LD_INT 4
92394: NEG
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: LD_INT 3
92402: NEG
92403: PUSH
92404: LD_INT 3
92406: NEG
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 4
92414: NEG
92415: PUSH
92416: LD_INT 3
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 5
92426: NEG
92427: PUSH
92428: LD_INT 4
92430: NEG
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 5
92438: NEG
92439: PUSH
92440: LD_INT 5
92442: NEG
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PUSH
92448: LD_INT 3
92450: NEG
92451: PUSH
92452: LD_INT 5
92454: NEG
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: LD_INT 5
92462: NEG
92463: PUSH
92464: LD_INT 3
92466: NEG
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: LD_INT 0
92474: PUSH
92475: LD_INT 3
92477: NEG
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 0
92485: PUSH
92486: LD_INT 4
92488: NEG
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 1
92496: PUSH
92497: LD_INT 3
92499: NEG
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 1
92507: PUSH
92508: LD_INT 2
92510: NEG
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 0
92518: PUSH
92519: LD_INT 2
92521: NEG
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 1
92529: NEG
92530: PUSH
92531: LD_INT 3
92533: NEG
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 1
92541: NEG
92542: PUSH
92543: LD_INT 4
92545: NEG
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 2
92553: PUSH
92554: LD_INT 2
92556: NEG
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 2
92564: NEG
92565: PUSH
92566: LD_INT 4
92568: NEG
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 4
92576: PUSH
92577: LD_INT 0
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 4
92586: PUSH
92587: LD_INT 1
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 5
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 5
92607: PUSH
92608: LD_INT 1
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 4
92617: PUSH
92618: LD_INT 1
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 3
92627: PUSH
92628: LD_INT 0
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 3
92637: PUSH
92638: LD_INT 1
92640: NEG
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 3
92648: PUSH
92649: LD_INT 2
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 5
92659: PUSH
92660: LD_INT 2
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
92714: LD_ADDR_VAR 0 32
92718: PUSH
92719: LD_INT 4
92721: NEG
92722: PUSH
92723: LD_INT 0
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 4
92732: NEG
92733: PUSH
92734: LD_INT 1
92736: NEG
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 3
92744: NEG
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 3
92755: NEG
92756: PUSH
92757: LD_INT 1
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: PUSH
92764: LD_INT 4
92766: NEG
92767: PUSH
92768: LD_INT 1
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 5
92777: NEG
92778: PUSH
92779: LD_INT 0
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 5
92788: NEG
92789: PUSH
92790: LD_INT 1
92792: NEG
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PUSH
92798: LD_INT 5
92800: NEG
92801: PUSH
92802: LD_INT 2
92804: NEG
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: LD_INT 3
92812: NEG
92813: PUSH
92814: LD_INT 2
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 3
92823: NEG
92824: PUSH
92825: LD_INT 3
92827: NEG
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 3
92835: NEG
92836: PUSH
92837: LD_INT 4
92839: NEG
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 2
92847: NEG
92848: PUSH
92849: LD_INT 3
92851: NEG
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 2
92859: NEG
92860: PUSH
92861: LD_INT 2
92863: NEG
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: LD_INT 3
92871: NEG
92872: PUSH
92873: LD_INT 2
92875: NEG
92876: PUSH
92877: EMPTY
92878: LIST
92879: LIST
92880: PUSH
92881: LD_INT 4
92883: NEG
92884: PUSH
92885: LD_INT 3
92887: NEG
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 4
92895: NEG
92896: PUSH
92897: LD_INT 4
92899: NEG
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: LD_INT 2
92907: NEG
92908: PUSH
92909: LD_INT 4
92911: NEG
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 4
92919: NEG
92920: PUSH
92921: LD_INT 2
92923: NEG
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 0
92931: PUSH
92932: LD_INT 4
92934: NEG
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 0
92942: PUSH
92943: LD_INT 5
92945: NEG
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 1
92953: PUSH
92954: LD_INT 4
92956: NEG
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 1
92964: PUSH
92965: LD_INT 3
92967: NEG
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 0
92975: PUSH
92976: LD_INT 3
92978: NEG
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 1
92986: NEG
92987: PUSH
92988: LD_INT 4
92990: NEG
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 1
92998: NEG
92999: PUSH
93000: LD_INT 5
93002: NEG
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 2
93010: PUSH
93011: LD_INT 3
93013: NEG
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 2
93021: NEG
93022: PUSH
93023: LD_INT 5
93025: NEG
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 3
93033: PUSH
93034: LD_INT 0
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 3
93043: PUSH
93044: LD_INT 1
93046: NEG
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 4
93054: PUSH
93055: LD_INT 0
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 4
93064: PUSH
93065: LD_INT 1
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 3
93074: PUSH
93075: LD_INT 1
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 2
93084: PUSH
93085: LD_INT 0
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 2
93094: PUSH
93095: LD_INT 1
93097: NEG
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 2
93105: PUSH
93106: LD_INT 2
93108: NEG
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 4
93116: PUSH
93117: LD_INT 2
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 4
93126: PUSH
93127: LD_INT 4
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 4
93136: PUSH
93137: LD_INT 3
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: LD_INT 5
93146: PUSH
93147: LD_INT 4
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 5
93156: PUSH
93157: LD_INT 5
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 4
93166: PUSH
93167: LD_INT 5
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: LD_INT 3
93176: PUSH
93177: LD_INT 4
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 3
93186: PUSH
93187: LD_INT 3
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 5
93196: PUSH
93197: LD_INT 3
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: PUSH
93204: LD_INT 3
93206: PUSH
93207: LD_INT 5
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
93261: LD_ADDR_VAR 0 33
93265: PUSH
93266: LD_INT 4
93268: NEG
93269: PUSH
93270: LD_INT 4
93272: NEG
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 4
93280: NEG
93281: PUSH
93282: LD_INT 5
93284: NEG
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 3
93292: NEG
93293: PUSH
93294: LD_INT 4
93296: NEG
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 3
93304: NEG
93305: PUSH
93306: LD_INT 3
93308: NEG
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 4
93316: NEG
93317: PUSH
93318: LD_INT 3
93320: NEG
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: PUSH
93326: LD_INT 5
93328: NEG
93329: PUSH
93330: LD_INT 4
93332: NEG
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 5
93340: NEG
93341: PUSH
93342: LD_INT 5
93344: NEG
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 3
93352: NEG
93353: PUSH
93354: LD_INT 5
93356: NEG
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 5
93364: NEG
93365: PUSH
93366: LD_INT 3
93368: NEG
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 0
93376: PUSH
93377: LD_INT 3
93379: NEG
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 0
93387: PUSH
93388: LD_INT 4
93390: NEG
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 1
93398: PUSH
93399: LD_INT 3
93401: NEG
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: LD_INT 1
93409: PUSH
93410: LD_INT 2
93412: NEG
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 0
93420: PUSH
93421: LD_INT 2
93423: NEG
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: PUSH
93429: LD_INT 1
93431: NEG
93432: PUSH
93433: LD_INT 3
93435: NEG
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 1
93443: NEG
93444: PUSH
93445: LD_INT 4
93447: NEG
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 2
93455: PUSH
93456: LD_INT 2
93458: NEG
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: PUSH
93464: LD_INT 2
93466: NEG
93467: PUSH
93468: LD_INT 4
93470: NEG
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 4
93478: PUSH
93479: LD_INT 0
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 4
93488: PUSH
93489: LD_INT 1
93491: NEG
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: LD_INT 5
93499: PUSH
93500: LD_INT 0
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: LD_INT 5
93509: PUSH
93510: LD_INT 1
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PUSH
93517: LD_INT 4
93519: PUSH
93520: LD_INT 1
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 3
93529: PUSH
93530: LD_INT 0
93532: PUSH
93533: EMPTY
93534: LIST
93535: LIST
93536: PUSH
93537: LD_INT 3
93539: PUSH
93540: LD_INT 1
93542: NEG
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 3
93550: PUSH
93551: LD_INT 2
93553: NEG
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: PUSH
93559: LD_INT 5
93561: PUSH
93562: LD_INT 2
93564: PUSH
93565: EMPTY
93566: LIST
93567: LIST
93568: PUSH
93569: LD_INT 3
93571: PUSH
93572: LD_INT 3
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 3
93581: PUSH
93582: LD_INT 2
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 4
93591: PUSH
93592: LD_INT 3
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 4
93601: PUSH
93602: LD_INT 4
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 3
93611: PUSH
93612: LD_INT 4
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: PUSH
93622: LD_INT 3
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 2
93631: PUSH
93632: LD_INT 2
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 4
93641: PUSH
93642: LD_INT 2
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_INT 2
93651: PUSH
93652: LD_INT 4
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 0
93661: PUSH
93662: LD_INT 4
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 0
93671: PUSH
93672: LD_INT 3
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 1
93681: PUSH
93682: LD_INT 4
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 1
93691: PUSH
93692: LD_INT 5
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: LD_INT 0
93701: PUSH
93702: LD_INT 5
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 1
93711: NEG
93712: PUSH
93713: LD_INT 4
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: PUSH
93720: LD_INT 1
93722: NEG
93723: PUSH
93724: LD_INT 3
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: LD_INT 2
93733: PUSH
93734: LD_INT 5
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 2
93743: NEG
93744: PUSH
93745: LD_INT 3
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: EMPTY
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
93799: LD_ADDR_VAR 0 34
93803: PUSH
93804: LD_INT 0
93806: PUSH
93807: LD_INT 4
93809: NEG
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 0
93817: PUSH
93818: LD_INT 5
93820: NEG
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 1
93828: PUSH
93829: LD_INT 4
93831: NEG
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 1
93839: PUSH
93840: LD_INT 3
93842: NEG
93843: PUSH
93844: EMPTY
93845: LIST
93846: LIST
93847: PUSH
93848: LD_INT 0
93850: PUSH
93851: LD_INT 3
93853: NEG
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 1
93861: NEG
93862: PUSH
93863: LD_INT 4
93865: NEG
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 1
93873: NEG
93874: PUSH
93875: LD_INT 5
93877: NEG
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 2
93885: PUSH
93886: LD_INT 3
93888: NEG
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 2
93896: NEG
93897: PUSH
93898: LD_INT 5
93900: NEG
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: PUSH
93906: LD_INT 3
93908: PUSH
93909: LD_INT 0
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 3
93918: PUSH
93919: LD_INT 1
93921: NEG
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 4
93929: PUSH
93930: LD_INT 0
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: LD_INT 4
93939: PUSH
93940: LD_INT 1
93942: PUSH
93943: EMPTY
93944: LIST
93945: LIST
93946: PUSH
93947: LD_INT 3
93949: PUSH
93950: LD_INT 1
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 2
93959: PUSH
93960: LD_INT 0
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 2
93969: PUSH
93970: LD_INT 1
93972: NEG
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 2
93980: PUSH
93981: LD_INT 2
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 4
93991: PUSH
93992: LD_INT 2
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 4
94001: PUSH
94002: LD_INT 4
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: PUSH
94009: LD_INT 4
94011: PUSH
94012: LD_INT 3
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 5
94021: PUSH
94022: LD_INT 4
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 5
94031: PUSH
94032: LD_INT 5
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: LD_INT 4
94041: PUSH
94042: LD_INT 5
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 3
94051: PUSH
94052: LD_INT 4
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 3
94061: PUSH
94062: LD_INT 3
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 5
94071: PUSH
94072: LD_INT 3
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 3
94081: PUSH
94082: LD_INT 5
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 0
94091: PUSH
94092: LD_INT 3
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 0
94101: PUSH
94102: LD_INT 2
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: LD_INT 1
94111: PUSH
94112: LD_INT 3
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: LD_INT 4
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 0
94131: PUSH
94132: LD_INT 4
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 1
94141: NEG
94142: PUSH
94143: LD_INT 3
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: PUSH
94150: LD_INT 1
94152: NEG
94153: PUSH
94154: LD_INT 2
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 2
94163: PUSH
94164: LD_INT 4
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: NEG
94174: PUSH
94175: LD_INT 2
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 4
94184: NEG
94185: PUSH
94186: LD_INT 0
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PUSH
94193: LD_INT 4
94195: NEG
94196: PUSH
94197: LD_INT 1
94199: NEG
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 3
94207: NEG
94208: PUSH
94209: LD_INT 0
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: LD_INT 3
94218: NEG
94219: PUSH
94220: LD_INT 1
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 4
94229: NEG
94230: PUSH
94231: LD_INT 1
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 5
94240: NEG
94241: PUSH
94242: LD_INT 0
94244: PUSH
94245: EMPTY
94246: LIST
94247: LIST
94248: PUSH
94249: LD_INT 5
94251: NEG
94252: PUSH
94253: LD_INT 1
94255: NEG
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 5
94263: NEG
94264: PUSH
94265: LD_INT 2
94267: NEG
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 3
94275: NEG
94276: PUSH
94277: LD_INT 2
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: ST_TO_ADDR
// end ; end ;
94331: GO 94334
94333: POP
// case btype of b_depot , b_warehouse :
94334: LD_VAR 0 1
94338: PUSH
94339: LD_INT 0
94341: DOUBLE
94342: EQUAL
94343: IFTRUE 94353
94345: LD_INT 1
94347: DOUBLE
94348: EQUAL
94349: IFTRUE 94353
94351: GO 94554
94353: POP
// case nation of nation_american :
94354: LD_VAR 0 5
94358: PUSH
94359: LD_INT 1
94361: DOUBLE
94362: EQUAL
94363: IFTRUE 94367
94365: GO 94423
94367: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
94368: LD_ADDR_VAR 0 9
94372: PUSH
94373: LD_VAR 0 11
94377: PUSH
94378: LD_VAR 0 12
94382: PUSH
94383: LD_VAR 0 13
94387: PUSH
94388: LD_VAR 0 14
94392: PUSH
94393: LD_VAR 0 15
94397: PUSH
94398: LD_VAR 0 16
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: PUSH
94411: LD_VAR 0 4
94415: PUSH
94416: LD_INT 1
94418: PLUS
94419: ARRAY
94420: ST_TO_ADDR
94421: GO 94552
94423: LD_INT 2
94425: DOUBLE
94426: EQUAL
94427: IFTRUE 94431
94429: GO 94487
94431: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
94432: LD_ADDR_VAR 0 9
94436: PUSH
94437: LD_VAR 0 17
94441: PUSH
94442: LD_VAR 0 18
94446: PUSH
94447: LD_VAR 0 19
94451: PUSH
94452: LD_VAR 0 20
94456: PUSH
94457: LD_VAR 0 21
94461: PUSH
94462: LD_VAR 0 22
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: PUSH
94475: LD_VAR 0 4
94479: PUSH
94480: LD_INT 1
94482: PLUS
94483: ARRAY
94484: ST_TO_ADDR
94485: GO 94552
94487: LD_INT 3
94489: DOUBLE
94490: EQUAL
94491: IFTRUE 94495
94493: GO 94551
94495: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
94496: LD_ADDR_VAR 0 9
94500: PUSH
94501: LD_VAR 0 23
94505: PUSH
94506: LD_VAR 0 24
94510: PUSH
94511: LD_VAR 0 25
94515: PUSH
94516: LD_VAR 0 26
94520: PUSH
94521: LD_VAR 0 27
94525: PUSH
94526: LD_VAR 0 28
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: PUSH
94539: LD_VAR 0 4
94543: PUSH
94544: LD_INT 1
94546: PLUS
94547: ARRAY
94548: ST_TO_ADDR
94549: GO 94552
94551: POP
94552: GO 95101
94554: LD_INT 2
94556: DOUBLE
94557: EQUAL
94558: IFTRUE 94568
94560: LD_INT 3
94562: DOUBLE
94563: EQUAL
94564: IFTRUE 94568
94566: GO 94624
94568: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
94569: LD_ADDR_VAR 0 9
94573: PUSH
94574: LD_VAR 0 29
94578: PUSH
94579: LD_VAR 0 30
94583: PUSH
94584: LD_VAR 0 31
94588: PUSH
94589: LD_VAR 0 32
94593: PUSH
94594: LD_VAR 0 33
94598: PUSH
94599: LD_VAR 0 34
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: PUSH
94612: LD_VAR 0 4
94616: PUSH
94617: LD_INT 1
94619: PLUS
94620: ARRAY
94621: ST_TO_ADDR
94622: GO 95101
94624: LD_INT 16
94626: DOUBLE
94627: EQUAL
94628: IFTRUE 94680
94630: LD_INT 17
94632: DOUBLE
94633: EQUAL
94634: IFTRUE 94680
94636: LD_INT 18
94638: DOUBLE
94639: EQUAL
94640: IFTRUE 94680
94642: LD_INT 19
94644: DOUBLE
94645: EQUAL
94646: IFTRUE 94680
94648: LD_INT 20
94650: DOUBLE
94651: EQUAL
94652: IFTRUE 94680
94654: LD_INT 21
94656: DOUBLE
94657: EQUAL
94658: IFTRUE 94680
94660: LD_INT 23
94662: DOUBLE
94663: EQUAL
94664: IFTRUE 94680
94666: LD_INT 24
94668: DOUBLE
94669: EQUAL
94670: IFTRUE 94680
94672: LD_INT 25
94674: DOUBLE
94675: EQUAL
94676: IFTRUE 94680
94678: GO 94736
94680: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
94681: LD_ADDR_VAR 0 9
94685: PUSH
94686: LD_VAR 0 35
94690: PUSH
94691: LD_VAR 0 36
94695: PUSH
94696: LD_VAR 0 37
94700: PUSH
94701: LD_VAR 0 38
94705: PUSH
94706: LD_VAR 0 39
94710: PUSH
94711: LD_VAR 0 40
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: PUSH
94724: LD_VAR 0 4
94728: PUSH
94729: LD_INT 1
94731: PLUS
94732: ARRAY
94733: ST_TO_ADDR
94734: GO 95101
94736: LD_INT 6
94738: DOUBLE
94739: EQUAL
94740: IFTRUE 94792
94742: LD_INT 7
94744: DOUBLE
94745: EQUAL
94746: IFTRUE 94792
94748: LD_INT 8
94750: DOUBLE
94751: EQUAL
94752: IFTRUE 94792
94754: LD_INT 13
94756: DOUBLE
94757: EQUAL
94758: IFTRUE 94792
94760: LD_INT 12
94762: DOUBLE
94763: EQUAL
94764: IFTRUE 94792
94766: LD_INT 15
94768: DOUBLE
94769: EQUAL
94770: IFTRUE 94792
94772: LD_INT 11
94774: DOUBLE
94775: EQUAL
94776: IFTRUE 94792
94778: LD_INT 14
94780: DOUBLE
94781: EQUAL
94782: IFTRUE 94792
94784: LD_INT 10
94786: DOUBLE
94787: EQUAL
94788: IFTRUE 94792
94790: GO 94848
94792: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
94793: LD_ADDR_VAR 0 9
94797: PUSH
94798: LD_VAR 0 41
94802: PUSH
94803: LD_VAR 0 42
94807: PUSH
94808: LD_VAR 0 43
94812: PUSH
94813: LD_VAR 0 44
94817: PUSH
94818: LD_VAR 0 45
94822: PUSH
94823: LD_VAR 0 46
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: PUSH
94836: LD_VAR 0 4
94840: PUSH
94841: LD_INT 1
94843: PLUS
94844: ARRAY
94845: ST_TO_ADDR
94846: GO 95101
94848: LD_INT 36
94850: DOUBLE
94851: EQUAL
94852: IFTRUE 94856
94854: GO 94912
94856: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
94857: LD_ADDR_VAR 0 9
94861: PUSH
94862: LD_VAR 0 47
94866: PUSH
94867: LD_VAR 0 48
94871: PUSH
94872: LD_VAR 0 49
94876: PUSH
94877: LD_VAR 0 50
94881: PUSH
94882: LD_VAR 0 51
94886: PUSH
94887: LD_VAR 0 52
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: PUSH
94900: LD_VAR 0 4
94904: PUSH
94905: LD_INT 1
94907: PLUS
94908: ARRAY
94909: ST_TO_ADDR
94910: GO 95101
94912: LD_INT 4
94914: DOUBLE
94915: EQUAL
94916: IFTRUE 94938
94918: LD_INT 5
94920: DOUBLE
94921: EQUAL
94922: IFTRUE 94938
94924: LD_INT 34
94926: DOUBLE
94927: EQUAL
94928: IFTRUE 94938
94930: LD_INT 37
94932: DOUBLE
94933: EQUAL
94934: IFTRUE 94938
94936: GO 94994
94938: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
94939: LD_ADDR_VAR 0 9
94943: PUSH
94944: LD_VAR 0 53
94948: PUSH
94949: LD_VAR 0 54
94953: PUSH
94954: LD_VAR 0 55
94958: PUSH
94959: LD_VAR 0 56
94963: PUSH
94964: LD_VAR 0 57
94968: PUSH
94969: LD_VAR 0 58
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: PUSH
94982: LD_VAR 0 4
94986: PUSH
94987: LD_INT 1
94989: PLUS
94990: ARRAY
94991: ST_TO_ADDR
94992: GO 95101
94994: LD_INT 31
94996: DOUBLE
94997: EQUAL
94998: IFTRUE 95044
95000: LD_INT 32
95002: DOUBLE
95003: EQUAL
95004: IFTRUE 95044
95006: LD_INT 33
95008: DOUBLE
95009: EQUAL
95010: IFTRUE 95044
95012: LD_INT 27
95014: DOUBLE
95015: EQUAL
95016: IFTRUE 95044
95018: LD_INT 26
95020: DOUBLE
95021: EQUAL
95022: IFTRUE 95044
95024: LD_INT 28
95026: DOUBLE
95027: EQUAL
95028: IFTRUE 95044
95030: LD_INT 29
95032: DOUBLE
95033: EQUAL
95034: IFTRUE 95044
95036: LD_INT 30
95038: DOUBLE
95039: EQUAL
95040: IFTRUE 95044
95042: GO 95100
95044: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
95045: LD_ADDR_VAR 0 9
95049: PUSH
95050: LD_VAR 0 59
95054: PUSH
95055: LD_VAR 0 60
95059: PUSH
95060: LD_VAR 0 61
95064: PUSH
95065: LD_VAR 0 62
95069: PUSH
95070: LD_VAR 0 63
95074: PUSH
95075: LD_VAR 0 64
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: PUSH
95088: LD_VAR 0 4
95092: PUSH
95093: LD_INT 1
95095: PLUS
95096: ARRAY
95097: ST_TO_ADDR
95098: GO 95101
95100: POP
// temp_list2 = [ ] ;
95101: LD_ADDR_VAR 0 10
95105: PUSH
95106: EMPTY
95107: ST_TO_ADDR
// for i in temp_list do
95108: LD_ADDR_VAR 0 8
95112: PUSH
95113: LD_VAR 0 9
95117: PUSH
95118: FOR_IN
95119: IFFALSE 95171
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95121: LD_ADDR_VAR 0 10
95125: PUSH
95126: LD_VAR 0 10
95130: PUSH
95131: LD_VAR 0 8
95135: PUSH
95136: LD_INT 1
95138: ARRAY
95139: PUSH
95140: LD_VAR 0 2
95144: PLUS
95145: PUSH
95146: LD_VAR 0 8
95150: PUSH
95151: LD_INT 2
95153: ARRAY
95154: PUSH
95155: LD_VAR 0 3
95159: PLUS
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: EMPTY
95166: LIST
95167: ADD
95168: ST_TO_ADDR
95169: GO 95118
95171: POP
95172: POP
// result = temp_list2 ;
95173: LD_ADDR_VAR 0 7
95177: PUSH
95178: LD_VAR 0 10
95182: ST_TO_ADDR
// end ;
95183: LD_VAR 0 7
95187: RET
// export function EnemyInRange ( unit , dist ) ; begin
95188: LD_INT 0
95190: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95191: LD_ADDR_VAR 0 3
95195: PUSH
95196: LD_VAR 0 1
95200: PPUSH
95201: CALL_OW 255
95205: PPUSH
95206: LD_VAR 0 1
95210: PPUSH
95211: CALL_OW 250
95215: PPUSH
95216: LD_VAR 0 1
95220: PPUSH
95221: CALL_OW 251
95225: PPUSH
95226: LD_VAR 0 2
95230: PPUSH
95231: CALL 69316 0 4
95235: PUSH
95236: LD_INT 4
95238: ARRAY
95239: ST_TO_ADDR
// end ;
95240: LD_VAR 0 3
95244: RET
// export function PlayerSeeMe ( unit ) ; begin
95245: LD_INT 0
95247: PPUSH
// result := See ( your_side , unit ) ;
95248: LD_ADDR_VAR 0 2
95252: PUSH
95253: LD_OWVAR 2
95257: PPUSH
95258: LD_VAR 0 1
95262: PPUSH
95263: CALL_OW 292
95267: ST_TO_ADDR
// end ;
95268: LD_VAR 0 2
95272: RET
// export function ReverseDir ( unit ) ; begin
95273: LD_INT 0
95275: PPUSH
// if not unit then
95276: LD_VAR 0 1
95280: NOT
95281: IFFALSE 95285
// exit ;
95283: GO 95331
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
95285: LD_ADDR_VAR 0 2
95289: PUSH
95290: LD_INT 3
95292: PUSH
95293: LD_INT 4
95295: PUSH
95296: LD_INT 5
95298: PUSH
95299: LD_INT 0
95301: PUSH
95302: LD_INT 1
95304: PUSH
95305: LD_INT 2
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: PUSH
95316: LD_VAR 0 1
95320: PPUSH
95321: CALL_OW 254
95325: PUSH
95326: LD_INT 1
95328: PLUS
95329: ARRAY
95330: ST_TO_ADDR
// end ;
95331: LD_VAR 0 2
95335: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
95336: LD_INT 0
95338: PPUSH
95339: PPUSH
95340: PPUSH
95341: PPUSH
95342: PPUSH
// if not hexes then
95343: LD_VAR 0 2
95347: NOT
95348: IFFALSE 95352
// exit ;
95350: GO 95500
// dist := 9999 ;
95352: LD_ADDR_VAR 0 5
95356: PUSH
95357: LD_INT 9999
95359: ST_TO_ADDR
// for i = 1 to hexes do
95360: LD_ADDR_VAR 0 4
95364: PUSH
95365: DOUBLE
95366: LD_INT 1
95368: DEC
95369: ST_TO_ADDR
95370: LD_VAR 0 2
95374: PUSH
95375: FOR_TO
95376: IFFALSE 95488
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
95378: LD_VAR 0 1
95382: PPUSH
95383: LD_VAR 0 2
95387: PUSH
95388: LD_VAR 0 4
95392: ARRAY
95393: PUSH
95394: LD_INT 1
95396: ARRAY
95397: PPUSH
95398: LD_VAR 0 2
95402: PUSH
95403: LD_VAR 0 4
95407: ARRAY
95408: PUSH
95409: LD_INT 2
95411: ARRAY
95412: PPUSH
95413: CALL_OW 297
95417: PUSH
95418: LD_VAR 0 5
95422: LESS
95423: IFFALSE 95486
// begin hex := hexes [ i ] ;
95425: LD_ADDR_VAR 0 7
95429: PUSH
95430: LD_VAR 0 2
95434: PUSH
95435: LD_VAR 0 4
95439: ARRAY
95440: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
95441: LD_ADDR_VAR 0 5
95445: PUSH
95446: LD_VAR 0 1
95450: PPUSH
95451: LD_VAR 0 2
95455: PUSH
95456: LD_VAR 0 4
95460: ARRAY
95461: PUSH
95462: LD_INT 1
95464: ARRAY
95465: PPUSH
95466: LD_VAR 0 2
95470: PUSH
95471: LD_VAR 0 4
95475: ARRAY
95476: PUSH
95477: LD_INT 2
95479: ARRAY
95480: PPUSH
95481: CALL_OW 297
95485: ST_TO_ADDR
// end ; end ;
95486: GO 95375
95488: POP
95489: POP
// result := hex ;
95490: LD_ADDR_VAR 0 3
95494: PUSH
95495: LD_VAR 0 7
95499: ST_TO_ADDR
// end ;
95500: LD_VAR 0 3
95504: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
95505: LD_INT 0
95507: PPUSH
95508: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
95509: LD_VAR 0 1
95513: NOT
95514: PUSH
95515: LD_VAR 0 1
95519: PUSH
95520: LD_INT 21
95522: PUSH
95523: LD_INT 2
95525: PUSH
95526: EMPTY
95527: LIST
95528: LIST
95529: PUSH
95530: LD_INT 23
95532: PUSH
95533: LD_INT 2
95535: PUSH
95536: EMPTY
95537: LIST
95538: LIST
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PPUSH
95544: CALL_OW 69
95548: IN
95549: NOT
95550: OR
95551: IFFALSE 95555
// exit ;
95553: GO 95602
// for i = 1 to 3 do
95555: LD_ADDR_VAR 0 3
95559: PUSH
95560: DOUBLE
95561: LD_INT 1
95563: DEC
95564: ST_TO_ADDR
95565: LD_INT 3
95567: PUSH
95568: FOR_TO
95569: IFFALSE 95600
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
95571: LD_VAR 0 1
95575: PPUSH
95576: CALL_OW 250
95580: PPUSH
95581: LD_VAR 0 1
95585: PPUSH
95586: CALL_OW 251
95590: PPUSH
95591: LD_INT 1
95593: PPUSH
95594: CALL_OW 453
95598: GO 95568
95600: POP
95601: POP
// end ;
95602: LD_VAR 0 2
95606: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
95607: LD_INT 0
95609: PPUSH
95610: PPUSH
95611: PPUSH
95612: PPUSH
95613: PPUSH
95614: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
95615: LD_VAR 0 1
95619: NOT
95620: PUSH
95621: LD_VAR 0 2
95625: NOT
95626: OR
95627: PUSH
95628: LD_VAR 0 1
95632: PPUSH
95633: CALL_OW 314
95637: OR
95638: IFFALSE 95642
// exit ;
95640: GO 96083
// x := GetX ( enemy_unit ) ;
95642: LD_ADDR_VAR 0 7
95646: PUSH
95647: LD_VAR 0 2
95651: PPUSH
95652: CALL_OW 250
95656: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
95657: LD_ADDR_VAR 0 8
95661: PUSH
95662: LD_VAR 0 2
95666: PPUSH
95667: CALL_OW 251
95671: ST_TO_ADDR
// if not x or not y then
95672: LD_VAR 0 7
95676: NOT
95677: PUSH
95678: LD_VAR 0 8
95682: NOT
95683: OR
95684: IFFALSE 95688
// exit ;
95686: GO 96083
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
95688: LD_ADDR_VAR 0 6
95692: PUSH
95693: LD_VAR 0 7
95697: PPUSH
95698: LD_INT 0
95700: PPUSH
95701: LD_INT 4
95703: PPUSH
95704: CALL_OW 272
95708: PUSH
95709: LD_VAR 0 8
95713: PPUSH
95714: LD_INT 0
95716: PPUSH
95717: LD_INT 4
95719: PPUSH
95720: CALL_OW 273
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PUSH
95729: LD_VAR 0 7
95733: PPUSH
95734: LD_INT 1
95736: PPUSH
95737: LD_INT 4
95739: PPUSH
95740: CALL_OW 272
95744: PUSH
95745: LD_VAR 0 8
95749: PPUSH
95750: LD_INT 1
95752: PPUSH
95753: LD_INT 4
95755: PPUSH
95756: CALL_OW 273
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_VAR 0 7
95769: PPUSH
95770: LD_INT 2
95772: PPUSH
95773: LD_INT 4
95775: PPUSH
95776: CALL_OW 272
95780: PUSH
95781: LD_VAR 0 8
95785: PPUSH
95786: LD_INT 2
95788: PPUSH
95789: LD_INT 4
95791: PPUSH
95792: CALL_OW 273
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: PUSH
95801: LD_VAR 0 7
95805: PPUSH
95806: LD_INT 3
95808: PPUSH
95809: LD_INT 4
95811: PPUSH
95812: CALL_OW 272
95816: PUSH
95817: LD_VAR 0 8
95821: PPUSH
95822: LD_INT 3
95824: PPUSH
95825: LD_INT 4
95827: PPUSH
95828: CALL_OW 273
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_VAR 0 7
95841: PPUSH
95842: LD_INT 4
95844: PPUSH
95845: LD_INT 4
95847: PPUSH
95848: CALL_OW 272
95852: PUSH
95853: LD_VAR 0 8
95857: PPUSH
95858: LD_INT 4
95860: PPUSH
95861: LD_INT 4
95863: PPUSH
95864: CALL_OW 273
95868: PUSH
95869: EMPTY
95870: LIST
95871: LIST
95872: PUSH
95873: LD_VAR 0 7
95877: PPUSH
95878: LD_INT 5
95880: PPUSH
95881: LD_INT 4
95883: PPUSH
95884: CALL_OW 272
95888: PUSH
95889: LD_VAR 0 8
95893: PPUSH
95894: LD_INT 5
95896: PPUSH
95897: LD_INT 4
95899: PPUSH
95900: CALL_OW 273
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: EMPTY
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: ST_TO_ADDR
// for i = tmp downto 1 do
95917: LD_ADDR_VAR 0 4
95921: PUSH
95922: DOUBLE
95923: LD_VAR 0 6
95927: INC
95928: ST_TO_ADDR
95929: LD_INT 1
95931: PUSH
95932: FOR_DOWNTO
95933: IFFALSE 96034
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
95935: LD_VAR 0 6
95939: PUSH
95940: LD_VAR 0 4
95944: ARRAY
95945: PUSH
95946: LD_INT 1
95948: ARRAY
95949: PPUSH
95950: LD_VAR 0 6
95954: PUSH
95955: LD_VAR 0 4
95959: ARRAY
95960: PUSH
95961: LD_INT 2
95963: ARRAY
95964: PPUSH
95965: CALL_OW 488
95969: NOT
95970: PUSH
95971: LD_VAR 0 6
95975: PUSH
95976: LD_VAR 0 4
95980: ARRAY
95981: PUSH
95982: LD_INT 1
95984: ARRAY
95985: PPUSH
95986: LD_VAR 0 6
95990: PUSH
95991: LD_VAR 0 4
95995: ARRAY
95996: PUSH
95997: LD_INT 2
95999: ARRAY
96000: PPUSH
96001: CALL_OW 428
96005: PUSH
96006: LD_INT 0
96008: NONEQUAL
96009: OR
96010: IFFALSE 96032
// tmp := Delete ( tmp , i ) ;
96012: LD_ADDR_VAR 0 6
96016: PUSH
96017: LD_VAR 0 6
96021: PPUSH
96022: LD_VAR 0 4
96026: PPUSH
96027: CALL_OW 3
96031: ST_TO_ADDR
96032: GO 95932
96034: POP
96035: POP
// j := GetClosestHex ( unit , tmp ) ;
96036: LD_ADDR_VAR 0 5
96040: PUSH
96041: LD_VAR 0 1
96045: PPUSH
96046: LD_VAR 0 6
96050: PPUSH
96051: CALL 95336 0 2
96055: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96056: LD_VAR 0 1
96060: PPUSH
96061: LD_VAR 0 5
96065: PUSH
96066: LD_INT 1
96068: ARRAY
96069: PPUSH
96070: LD_VAR 0 5
96074: PUSH
96075: LD_INT 2
96077: ARRAY
96078: PPUSH
96079: CALL_OW 111
// end ;
96083: LD_VAR 0 3
96087: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
96088: LD_INT 0
96090: PPUSH
96091: PPUSH
96092: PPUSH
// uc_side = 0 ;
96093: LD_ADDR_OWVAR 20
96097: PUSH
96098: LD_INT 0
96100: ST_TO_ADDR
// uc_nation = 0 ;
96101: LD_ADDR_OWVAR 21
96105: PUSH
96106: LD_INT 0
96108: ST_TO_ADDR
// InitHc ;
96109: CALL_OW 19
// InitVc ;
96113: CALL_OW 20
// if mastodonts then
96117: LD_VAR 0 6
96121: IFFALSE 96188
// for i = 1 to mastodonts do
96123: LD_ADDR_VAR 0 11
96127: PUSH
96128: DOUBLE
96129: LD_INT 1
96131: DEC
96132: ST_TO_ADDR
96133: LD_VAR 0 6
96137: PUSH
96138: FOR_TO
96139: IFFALSE 96186
// begin vc_chassis := 31 ;
96141: LD_ADDR_OWVAR 37
96145: PUSH
96146: LD_INT 31
96148: ST_TO_ADDR
// vc_control := control_rider ;
96149: LD_ADDR_OWVAR 38
96153: PUSH
96154: LD_INT 4
96156: ST_TO_ADDR
// animal := CreateVehicle ;
96157: LD_ADDR_VAR 0 12
96161: PUSH
96162: CALL_OW 45
96166: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96167: LD_VAR 0 12
96171: PPUSH
96172: LD_VAR 0 8
96176: PPUSH
96177: LD_INT 0
96179: PPUSH
96180: CALL 102894 0 3
// end ;
96184: GO 96138
96186: POP
96187: POP
// if horses then
96188: LD_VAR 0 5
96192: IFFALSE 96259
// for i = 1 to horses do
96194: LD_ADDR_VAR 0 11
96198: PUSH
96199: DOUBLE
96200: LD_INT 1
96202: DEC
96203: ST_TO_ADDR
96204: LD_VAR 0 5
96208: PUSH
96209: FOR_TO
96210: IFFALSE 96257
// begin hc_class := 21 ;
96212: LD_ADDR_OWVAR 28
96216: PUSH
96217: LD_INT 21
96219: ST_TO_ADDR
// hc_gallery :=  ;
96220: LD_ADDR_OWVAR 33
96224: PUSH
96225: LD_STRING 
96227: ST_TO_ADDR
// animal := CreateHuman ;
96228: LD_ADDR_VAR 0 12
96232: PUSH
96233: CALL_OW 44
96237: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96238: LD_VAR 0 12
96242: PPUSH
96243: LD_VAR 0 8
96247: PPUSH
96248: LD_INT 0
96250: PPUSH
96251: CALL 102894 0 3
// end ;
96255: GO 96209
96257: POP
96258: POP
// if birds then
96259: LD_VAR 0 1
96263: IFFALSE 96330
// for i = 1 to birds do
96265: LD_ADDR_VAR 0 11
96269: PUSH
96270: DOUBLE
96271: LD_INT 1
96273: DEC
96274: ST_TO_ADDR
96275: LD_VAR 0 1
96279: PUSH
96280: FOR_TO
96281: IFFALSE 96328
// begin hc_class = 18 ;
96283: LD_ADDR_OWVAR 28
96287: PUSH
96288: LD_INT 18
96290: ST_TO_ADDR
// hc_gallery =  ;
96291: LD_ADDR_OWVAR 33
96295: PUSH
96296: LD_STRING 
96298: ST_TO_ADDR
// animal := CreateHuman ;
96299: LD_ADDR_VAR 0 12
96303: PUSH
96304: CALL_OW 44
96308: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96309: LD_VAR 0 12
96313: PPUSH
96314: LD_VAR 0 8
96318: PPUSH
96319: LD_INT 0
96321: PPUSH
96322: CALL 102894 0 3
// end ;
96326: GO 96280
96328: POP
96329: POP
// if tigers then
96330: LD_VAR 0 2
96334: IFFALSE 96418
// for i = 1 to tigers do
96336: LD_ADDR_VAR 0 11
96340: PUSH
96341: DOUBLE
96342: LD_INT 1
96344: DEC
96345: ST_TO_ADDR
96346: LD_VAR 0 2
96350: PUSH
96351: FOR_TO
96352: IFFALSE 96416
// begin hc_class = class_tiger ;
96354: LD_ADDR_OWVAR 28
96358: PUSH
96359: LD_INT 14
96361: ST_TO_ADDR
// hc_gallery =  ;
96362: LD_ADDR_OWVAR 33
96366: PUSH
96367: LD_STRING 
96369: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
96370: LD_ADDR_OWVAR 35
96374: PUSH
96375: LD_INT 7
96377: NEG
96378: PPUSH
96379: LD_INT 7
96381: PPUSH
96382: CALL_OW 12
96386: ST_TO_ADDR
// animal := CreateHuman ;
96387: LD_ADDR_VAR 0 12
96391: PUSH
96392: CALL_OW 44
96396: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96397: LD_VAR 0 12
96401: PPUSH
96402: LD_VAR 0 8
96406: PPUSH
96407: LD_INT 0
96409: PPUSH
96410: CALL 102894 0 3
// end ;
96414: GO 96351
96416: POP
96417: POP
// if apemans then
96418: LD_VAR 0 3
96422: IFFALSE 96545
// for i = 1 to apemans do
96424: LD_ADDR_VAR 0 11
96428: PUSH
96429: DOUBLE
96430: LD_INT 1
96432: DEC
96433: ST_TO_ADDR
96434: LD_VAR 0 3
96438: PUSH
96439: FOR_TO
96440: IFFALSE 96543
// begin hc_class = class_apeman ;
96442: LD_ADDR_OWVAR 28
96446: PUSH
96447: LD_INT 12
96449: ST_TO_ADDR
// hc_gallery =  ;
96450: LD_ADDR_OWVAR 33
96454: PUSH
96455: LD_STRING 
96457: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
96458: LD_ADDR_OWVAR 35
96462: PUSH
96463: LD_INT 5
96465: NEG
96466: PPUSH
96467: LD_INT 5
96469: PPUSH
96470: CALL_OW 12
96474: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
96475: LD_ADDR_OWVAR 31
96479: PUSH
96480: LD_INT 1
96482: PPUSH
96483: LD_INT 3
96485: PPUSH
96486: CALL_OW 12
96490: PUSH
96491: LD_INT 1
96493: PPUSH
96494: LD_INT 3
96496: PPUSH
96497: CALL_OW 12
96501: PUSH
96502: LD_INT 0
96504: PUSH
96505: LD_INT 0
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: ST_TO_ADDR
// animal := CreateHuman ;
96514: LD_ADDR_VAR 0 12
96518: PUSH
96519: CALL_OW 44
96523: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96524: LD_VAR 0 12
96528: PPUSH
96529: LD_VAR 0 8
96533: PPUSH
96534: LD_INT 0
96536: PPUSH
96537: CALL 102894 0 3
// end ;
96541: GO 96439
96543: POP
96544: POP
// if enchidnas then
96545: LD_VAR 0 4
96549: IFFALSE 96616
// for i = 1 to enchidnas do
96551: LD_ADDR_VAR 0 11
96555: PUSH
96556: DOUBLE
96557: LD_INT 1
96559: DEC
96560: ST_TO_ADDR
96561: LD_VAR 0 4
96565: PUSH
96566: FOR_TO
96567: IFFALSE 96614
// begin hc_class = 13 ;
96569: LD_ADDR_OWVAR 28
96573: PUSH
96574: LD_INT 13
96576: ST_TO_ADDR
// hc_gallery =  ;
96577: LD_ADDR_OWVAR 33
96581: PUSH
96582: LD_STRING 
96584: ST_TO_ADDR
// animal := CreateHuman ;
96585: LD_ADDR_VAR 0 12
96589: PUSH
96590: CALL_OW 44
96594: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96595: LD_VAR 0 12
96599: PPUSH
96600: LD_VAR 0 8
96604: PPUSH
96605: LD_INT 0
96607: PPUSH
96608: CALL 102894 0 3
// end ;
96612: GO 96566
96614: POP
96615: POP
// if fishes then
96616: LD_VAR 0 7
96620: IFFALSE 96687
// for i = 1 to fishes do
96622: LD_ADDR_VAR 0 11
96626: PUSH
96627: DOUBLE
96628: LD_INT 1
96630: DEC
96631: ST_TO_ADDR
96632: LD_VAR 0 7
96636: PUSH
96637: FOR_TO
96638: IFFALSE 96685
// begin hc_class = 20 ;
96640: LD_ADDR_OWVAR 28
96644: PUSH
96645: LD_INT 20
96647: ST_TO_ADDR
// hc_gallery =  ;
96648: LD_ADDR_OWVAR 33
96652: PUSH
96653: LD_STRING 
96655: ST_TO_ADDR
// animal := CreateHuman ;
96656: LD_ADDR_VAR 0 12
96660: PUSH
96661: CALL_OW 44
96665: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
96666: LD_VAR 0 12
96670: PPUSH
96671: LD_VAR 0 9
96675: PPUSH
96676: LD_INT 0
96678: PPUSH
96679: CALL 102894 0 3
// end ;
96683: GO 96637
96685: POP
96686: POP
// end ;
96687: LD_VAR 0 10
96691: RET
// export function WantHeal ( sci , unit ) ; begin
96692: LD_INT 0
96694: PPUSH
// if GetTaskList ( sci ) > 0 then
96695: LD_VAR 0 1
96699: PPUSH
96700: CALL_OW 437
96704: PUSH
96705: LD_INT 0
96707: GREATER
96708: IFFALSE 96778
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
96710: LD_VAR 0 1
96714: PPUSH
96715: CALL_OW 437
96719: PUSH
96720: LD_INT 1
96722: ARRAY
96723: PUSH
96724: LD_INT 1
96726: ARRAY
96727: PUSH
96728: LD_STRING l
96730: EQUAL
96731: PUSH
96732: LD_VAR 0 1
96736: PPUSH
96737: CALL_OW 437
96741: PUSH
96742: LD_INT 1
96744: ARRAY
96745: PUSH
96746: LD_INT 4
96748: ARRAY
96749: PUSH
96750: LD_VAR 0 2
96754: EQUAL
96755: AND
96756: IFFALSE 96768
// result := true else
96758: LD_ADDR_VAR 0 3
96762: PUSH
96763: LD_INT 1
96765: ST_TO_ADDR
96766: GO 96776
// result := false ;
96768: LD_ADDR_VAR 0 3
96772: PUSH
96773: LD_INT 0
96775: ST_TO_ADDR
// end else
96776: GO 96786
// result := false ;
96778: LD_ADDR_VAR 0 3
96782: PUSH
96783: LD_INT 0
96785: ST_TO_ADDR
// end ;
96786: LD_VAR 0 3
96790: RET
// export function HealTarget ( sci ) ; begin
96791: LD_INT 0
96793: PPUSH
// if not sci then
96794: LD_VAR 0 1
96798: NOT
96799: IFFALSE 96803
// exit ;
96801: GO 96868
// result := 0 ;
96803: LD_ADDR_VAR 0 2
96807: PUSH
96808: LD_INT 0
96810: ST_TO_ADDR
// if GetTaskList ( sci ) then
96811: LD_VAR 0 1
96815: PPUSH
96816: CALL_OW 437
96820: IFFALSE 96868
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
96822: LD_VAR 0 1
96826: PPUSH
96827: CALL_OW 437
96831: PUSH
96832: LD_INT 1
96834: ARRAY
96835: PUSH
96836: LD_INT 1
96838: ARRAY
96839: PUSH
96840: LD_STRING l
96842: EQUAL
96843: IFFALSE 96868
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
96845: LD_ADDR_VAR 0 2
96849: PUSH
96850: LD_VAR 0 1
96854: PPUSH
96855: CALL_OW 437
96859: PUSH
96860: LD_INT 1
96862: ARRAY
96863: PUSH
96864: LD_INT 4
96866: ARRAY
96867: ST_TO_ADDR
// end ;
96868: LD_VAR 0 2
96872: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
96873: LD_INT 0
96875: PPUSH
96876: PPUSH
96877: PPUSH
96878: PPUSH
96879: PPUSH
96880: PPUSH
96881: PPUSH
96882: PPUSH
96883: PPUSH
96884: PPUSH
96885: PPUSH
96886: PPUSH
96887: PPUSH
96888: PPUSH
96889: PPUSH
96890: PPUSH
96891: PPUSH
96892: PPUSH
96893: PPUSH
96894: PPUSH
96895: PPUSH
96896: PPUSH
96897: PPUSH
96898: PPUSH
96899: PPUSH
96900: PPUSH
96901: PPUSH
96902: PPUSH
96903: PPUSH
96904: PPUSH
96905: PPUSH
96906: PPUSH
96907: PPUSH
// if not list then
96908: LD_VAR 0 1
96912: NOT
96913: IFFALSE 96917
// exit ;
96915: GO 101505
// base := list [ 1 ] ;
96917: LD_ADDR_VAR 0 3
96921: PUSH
96922: LD_VAR 0 1
96926: PUSH
96927: LD_INT 1
96929: ARRAY
96930: ST_TO_ADDR
// group := list [ 2 ] ;
96931: LD_ADDR_VAR 0 4
96935: PUSH
96936: LD_VAR 0 1
96940: PUSH
96941: LD_INT 2
96943: ARRAY
96944: ST_TO_ADDR
// path := list [ 3 ] ;
96945: LD_ADDR_VAR 0 5
96949: PUSH
96950: LD_VAR 0 1
96954: PUSH
96955: LD_INT 3
96957: ARRAY
96958: ST_TO_ADDR
// flags := list [ 4 ] ;
96959: LD_ADDR_VAR 0 6
96963: PUSH
96964: LD_VAR 0 1
96968: PUSH
96969: LD_INT 4
96971: ARRAY
96972: ST_TO_ADDR
// mined := [ ] ;
96973: LD_ADDR_VAR 0 27
96977: PUSH
96978: EMPTY
96979: ST_TO_ADDR
// bombed := [ ] ;
96980: LD_ADDR_VAR 0 28
96984: PUSH
96985: EMPTY
96986: ST_TO_ADDR
// healers := [ ] ;
96987: LD_ADDR_VAR 0 31
96991: PUSH
96992: EMPTY
96993: ST_TO_ADDR
// to_heal := [ ] ;
96994: LD_ADDR_VAR 0 30
96998: PUSH
96999: EMPTY
97000: ST_TO_ADDR
// repairs := [ ] ;
97001: LD_ADDR_VAR 0 33
97005: PUSH
97006: EMPTY
97007: ST_TO_ADDR
// to_repair := [ ] ;
97008: LD_ADDR_VAR 0 32
97012: PUSH
97013: EMPTY
97014: ST_TO_ADDR
// if not group or not path then
97015: LD_VAR 0 4
97019: NOT
97020: PUSH
97021: LD_VAR 0 5
97025: NOT
97026: OR
97027: IFFALSE 97031
// exit ;
97029: GO 101505
// if flags then
97031: LD_VAR 0 6
97035: IFFALSE 97179
// begin f_ignore_area := flags [ 1 ] ;
97037: LD_ADDR_VAR 0 17
97041: PUSH
97042: LD_VAR 0 6
97046: PUSH
97047: LD_INT 1
97049: ARRAY
97050: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
97051: LD_ADDR_VAR 0 18
97055: PUSH
97056: LD_VAR 0 6
97060: PUSH
97061: LD_INT 2
97063: ARRAY
97064: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
97065: LD_ADDR_VAR 0 19
97069: PUSH
97070: LD_VAR 0 6
97074: PUSH
97075: LD_INT 3
97077: ARRAY
97078: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
97079: LD_ADDR_VAR 0 20
97083: PUSH
97084: LD_VAR 0 6
97088: PUSH
97089: LD_INT 4
97091: ARRAY
97092: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
97093: LD_ADDR_VAR 0 21
97097: PUSH
97098: LD_VAR 0 6
97102: PUSH
97103: LD_INT 5
97105: ARRAY
97106: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
97107: LD_ADDR_VAR 0 22
97111: PUSH
97112: LD_VAR 0 6
97116: PUSH
97117: LD_INT 6
97119: ARRAY
97120: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
97121: LD_ADDR_VAR 0 23
97125: PUSH
97126: LD_VAR 0 6
97130: PUSH
97131: LD_INT 7
97133: ARRAY
97134: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
97135: LD_ADDR_VAR 0 24
97139: PUSH
97140: LD_VAR 0 6
97144: PUSH
97145: LD_INT 8
97147: ARRAY
97148: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
97149: LD_ADDR_VAR 0 25
97153: PUSH
97154: LD_VAR 0 6
97158: PUSH
97159: LD_INT 9
97161: ARRAY
97162: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
97163: LD_ADDR_VAR 0 26
97167: PUSH
97168: LD_VAR 0 6
97172: PUSH
97173: LD_INT 10
97175: ARRAY
97176: ST_TO_ADDR
// end else
97177: GO 97259
// begin f_ignore_area := false ;
97179: LD_ADDR_VAR 0 17
97183: PUSH
97184: LD_INT 0
97186: ST_TO_ADDR
// f_capture := false ;
97187: LD_ADDR_VAR 0 18
97191: PUSH
97192: LD_INT 0
97194: ST_TO_ADDR
// f_ignore_civ := false ;
97195: LD_ADDR_VAR 0 19
97199: PUSH
97200: LD_INT 0
97202: ST_TO_ADDR
// f_murder := false ;
97203: LD_ADDR_VAR 0 20
97207: PUSH
97208: LD_INT 0
97210: ST_TO_ADDR
// f_mines := false ;
97211: LD_ADDR_VAR 0 21
97215: PUSH
97216: LD_INT 0
97218: ST_TO_ADDR
// f_repair := false ;
97219: LD_ADDR_VAR 0 22
97223: PUSH
97224: LD_INT 0
97226: ST_TO_ADDR
// f_heal := false ;
97227: LD_ADDR_VAR 0 23
97231: PUSH
97232: LD_INT 0
97234: ST_TO_ADDR
// f_spacetime := false ;
97235: LD_ADDR_VAR 0 24
97239: PUSH
97240: LD_INT 0
97242: ST_TO_ADDR
// f_attack_depot := false ;
97243: LD_ADDR_VAR 0 25
97247: PUSH
97248: LD_INT 0
97250: ST_TO_ADDR
// f_crawl := false ;
97251: LD_ADDR_VAR 0 26
97255: PUSH
97256: LD_INT 0
97258: ST_TO_ADDR
// end ; if f_heal then
97259: LD_VAR 0 23
97263: IFFALSE 97290
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
97265: LD_ADDR_VAR 0 31
97269: PUSH
97270: LD_VAR 0 4
97274: PPUSH
97275: LD_INT 25
97277: PUSH
97278: LD_INT 4
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PPUSH
97285: CALL_OW 72
97289: ST_TO_ADDR
// if f_repair then
97290: LD_VAR 0 22
97294: IFFALSE 97321
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
97296: LD_ADDR_VAR 0 33
97300: PUSH
97301: LD_VAR 0 4
97305: PPUSH
97306: LD_INT 25
97308: PUSH
97309: LD_INT 3
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PPUSH
97316: CALL_OW 72
97320: ST_TO_ADDR
// units_path := [ ] ;
97321: LD_ADDR_VAR 0 16
97325: PUSH
97326: EMPTY
97327: ST_TO_ADDR
// for i = 1 to group do
97328: LD_ADDR_VAR 0 7
97332: PUSH
97333: DOUBLE
97334: LD_INT 1
97336: DEC
97337: ST_TO_ADDR
97338: LD_VAR 0 4
97342: PUSH
97343: FOR_TO
97344: IFFALSE 97373
// units_path := Replace ( units_path , i , path ) ;
97346: LD_ADDR_VAR 0 16
97350: PUSH
97351: LD_VAR 0 16
97355: PPUSH
97356: LD_VAR 0 7
97360: PPUSH
97361: LD_VAR 0 5
97365: PPUSH
97366: CALL_OW 1
97370: ST_TO_ADDR
97371: GO 97343
97373: POP
97374: POP
// repeat for i = group downto 1 do
97375: LD_ADDR_VAR 0 7
97379: PUSH
97380: DOUBLE
97381: LD_VAR 0 4
97385: INC
97386: ST_TO_ADDR
97387: LD_INT 1
97389: PUSH
97390: FOR_DOWNTO
97391: IFFALSE 101487
// begin wait ( 5 ) ;
97393: LD_INT 5
97395: PPUSH
97396: CALL_OW 67
// tmp := [ ] ;
97400: LD_ADDR_VAR 0 14
97404: PUSH
97405: EMPTY
97406: ST_TO_ADDR
// attacking := false ;
97407: LD_ADDR_VAR 0 29
97411: PUSH
97412: LD_INT 0
97414: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
97415: LD_VAR 0 4
97419: PUSH
97420: LD_VAR 0 7
97424: ARRAY
97425: PPUSH
97426: CALL_OW 301
97430: PUSH
97431: LD_VAR 0 4
97435: PUSH
97436: LD_VAR 0 7
97440: ARRAY
97441: NOT
97442: OR
97443: IFFALSE 97552
// begin if GetType ( group [ i ] ) = unit_human then
97445: LD_VAR 0 4
97449: PUSH
97450: LD_VAR 0 7
97454: ARRAY
97455: PPUSH
97456: CALL_OW 247
97460: PUSH
97461: LD_INT 1
97463: EQUAL
97464: IFFALSE 97510
// begin to_heal := to_heal diff group [ i ] ;
97466: LD_ADDR_VAR 0 30
97470: PUSH
97471: LD_VAR 0 30
97475: PUSH
97476: LD_VAR 0 4
97480: PUSH
97481: LD_VAR 0 7
97485: ARRAY
97486: DIFF
97487: ST_TO_ADDR
// healers := healers diff group [ i ] ;
97488: LD_ADDR_VAR 0 31
97492: PUSH
97493: LD_VAR 0 31
97497: PUSH
97498: LD_VAR 0 4
97502: PUSH
97503: LD_VAR 0 7
97507: ARRAY
97508: DIFF
97509: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
97510: LD_ADDR_VAR 0 4
97514: PUSH
97515: LD_VAR 0 4
97519: PPUSH
97520: LD_VAR 0 7
97524: PPUSH
97525: CALL_OW 3
97529: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
97530: LD_ADDR_VAR 0 16
97534: PUSH
97535: LD_VAR 0 16
97539: PPUSH
97540: LD_VAR 0 7
97544: PPUSH
97545: CALL_OW 3
97549: ST_TO_ADDR
// continue ;
97550: GO 97390
// end ; if f_repair then
97552: LD_VAR 0 22
97556: IFFALSE 98045
// begin if GetType ( group [ i ] ) = unit_vehicle then
97558: LD_VAR 0 4
97562: PUSH
97563: LD_VAR 0 7
97567: ARRAY
97568: PPUSH
97569: CALL_OW 247
97573: PUSH
97574: LD_INT 2
97576: EQUAL
97577: IFFALSE 97767
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
97579: LD_VAR 0 4
97583: PUSH
97584: LD_VAR 0 7
97588: ARRAY
97589: PPUSH
97590: CALL_OW 256
97594: PUSH
97595: LD_INT 700
97597: LESS
97598: PUSH
97599: LD_VAR 0 4
97603: PUSH
97604: LD_VAR 0 7
97608: ARRAY
97609: PUSH
97610: LD_VAR 0 32
97614: IN
97615: NOT
97616: AND
97617: IFFALSE 97641
// to_repair := to_repair union group [ i ] ;
97619: LD_ADDR_VAR 0 32
97623: PUSH
97624: LD_VAR 0 32
97628: PUSH
97629: LD_VAR 0 4
97633: PUSH
97634: LD_VAR 0 7
97638: ARRAY
97639: UNION
97640: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
97641: LD_VAR 0 4
97645: PUSH
97646: LD_VAR 0 7
97650: ARRAY
97651: PPUSH
97652: CALL_OW 256
97656: PUSH
97657: LD_INT 1000
97659: EQUAL
97660: PUSH
97661: LD_VAR 0 4
97665: PUSH
97666: LD_VAR 0 7
97670: ARRAY
97671: PUSH
97672: LD_VAR 0 32
97676: IN
97677: AND
97678: IFFALSE 97702
// to_repair := to_repair diff group [ i ] ;
97680: LD_ADDR_VAR 0 32
97684: PUSH
97685: LD_VAR 0 32
97689: PUSH
97690: LD_VAR 0 4
97694: PUSH
97695: LD_VAR 0 7
97699: ARRAY
97700: DIFF
97701: ST_TO_ADDR
// if group [ i ] in to_repair then
97702: LD_VAR 0 4
97706: PUSH
97707: LD_VAR 0 7
97711: ARRAY
97712: PUSH
97713: LD_VAR 0 32
97717: IN
97718: IFFALSE 97765
// begin if not IsInArea ( group [ i ] , f_repair ) then
97720: LD_VAR 0 4
97724: PUSH
97725: LD_VAR 0 7
97729: ARRAY
97730: PPUSH
97731: LD_VAR 0 22
97735: PPUSH
97736: CALL_OW 308
97740: NOT
97741: IFFALSE 97763
// ComMoveToArea ( group [ i ] , f_repair ) ;
97743: LD_VAR 0 4
97747: PUSH
97748: LD_VAR 0 7
97752: ARRAY
97753: PPUSH
97754: LD_VAR 0 22
97758: PPUSH
97759: CALL_OW 113
// continue ;
97763: GO 97390
// end ; end else
97765: GO 98045
// if group [ i ] in repairs then
97767: LD_VAR 0 4
97771: PUSH
97772: LD_VAR 0 7
97776: ARRAY
97777: PUSH
97778: LD_VAR 0 33
97782: IN
97783: IFFALSE 98045
// begin if IsInUnit ( group [ i ] ) then
97785: LD_VAR 0 4
97789: PUSH
97790: LD_VAR 0 7
97794: ARRAY
97795: PPUSH
97796: CALL_OW 310
97800: IFFALSE 97868
// begin z := IsInUnit ( group [ i ] ) ;
97802: LD_ADDR_VAR 0 13
97806: PUSH
97807: LD_VAR 0 4
97811: PUSH
97812: LD_VAR 0 7
97816: ARRAY
97817: PPUSH
97818: CALL_OW 310
97822: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
97823: LD_VAR 0 13
97827: PUSH
97828: LD_VAR 0 32
97832: IN
97833: PUSH
97834: LD_VAR 0 13
97838: PPUSH
97839: LD_VAR 0 22
97843: PPUSH
97844: CALL_OW 308
97848: AND
97849: IFFALSE 97866
// ComExitVehicle ( group [ i ] ) ;
97851: LD_VAR 0 4
97855: PUSH
97856: LD_VAR 0 7
97860: ARRAY
97861: PPUSH
97862: CALL_OW 121
// end else
97866: GO 98045
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
97868: LD_ADDR_VAR 0 13
97872: PUSH
97873: LD_VAR 0 4
97877: PPUSH
97878: LD_INT 95
97880: PUSH
97881: LD_VAR 0 22
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 58
97892: PUSH
97893: EMPTY
97894: LIST
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: PPUSH
97900: CALL_OW 72
97904: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
97905: LD_VAR 0 4
97909: PUSH
97910: LD_VAR 0 7
97914: ARRAY
97915: PPUSH
97916: CALL_OW 314
97920: NOT
97921: IFFALSE 98043
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
97923: LD_ADDR_VAR 0 10
97927: PUSH
97928: LD_VAR 0 13
97932: PPUSH
97933: LD_VAR 0 4
97937: PUSH
97938: LD_VAR 0 7
97942: ARRAY
97943: PPUSH
97944: CALL_OW 74
97948: ST_TO_ADDR
// if not x then
97949: LD_VAR 0 10
97953: NOT
97954: IFFALSE 97958
// continue ;
97956: GO 97390
// if GetLives ( x ) < 1000 then
97958: LD_VAR 0 10
97962: PPUSH
97963: CALL_OW 256
97967: PUSH
97968: LD_INT 1000
97970: LESS
97971: IFFALSE 97995
// ComRepairVehicle ( group [ i ] , x ) else
97973: LD_VAR 0 4
97977: PUSH
97978: LD_VAR 0 7
97982: ARRAY
97983: PPUSH
97984: LD_VAR 0 10
97988: PPUSH
97989: CALL_OW 129
97993: GO 98043
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
97995: LD_VAR 0 23
97999: PUSH
98000: LD_VAR 0 4
98004: PUSH
98005: LD_VAR 0 7
98009: ARRAY
98010: PPUSH
98011: CALL_OW 256
98015: PUSH
98016: LD_INT 1000
98018: LESS
98019: AND
98020: NOT
98021: IFFALSE 98043
// ComEnterUnit ( group [ i ] , x ) ;
98023: LD_VAR 0 4
98027: PUSH
98028: LD_VAR 0 7
98032: ARRAY
98033: PPUSH
98034: LD_VAR 0 10
98038: PPUSH
98039: CALL_OW 120
// end ; continue ;
98043: GO 97390
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
98045: LD_VAR 0 23
98049: PUSH
98050: LD_VAR 0 4
98054: PUSH
98055: LD_VAR 0 7
98059: ARRAY
98060: PPUSH
98061: CALL_OW 247
98065: PUSH
98066: LD_INT 1
98068: EQUAL
98069: AND
98070: IFFALSE 98548
// begin if group [ i ] in healers then
98072: LD_VAR 0 4
98076: PUSH
98077: LD_VAR 0 7
98081: ARRAY
98082: PUSH
98083: LD_VAR 0 31
98087: IN
98088: IFFALSE 98361
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
98090: LD_VAR 0 4
98094: PUSH
98095: LD_VAR 0 7
98099: ARRAY
98100: PPUSH
98101: LD_VAR 0 23
98105: PPUSH
98106: CALL_OW 308
98110: NOT
98111: PUSH
98112: LD_VAR 0 4
98116: PUSH
98117: LD_VAR 0 7
98121: ARRAY
98122: PPUSH
98123: CALL_OW 314
98127: NOT
98128: AND
98129: IFFALSE 98153
// ComMoveToArea ( group [ i ] , f_heal ) else
98131: LD_VAR 0 4
98135: PUSH
98136: LD_VAR 0 7
98140: ARRAY
98141: PPUSH
98142: LD_VAR 0 23
98146: PPUSH
98147: CALL_OW 113
98151: GO 98359
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
98153: LD_VAR 0 4
98157: PUSH
98158: LD_VAR 0 7
98162: ARRAY
98163: PPUSH
98164: CALL 96791 0 1
98168: PPUSH
98169: CALL_OW 256
98173: PUSH
98174: LD_INT 1000
98176: EQUAL
98177: IFFALSE 98196
// ComStop ( group [ i ] ) else
98179: LD_VAR 0 4
98183: PUSH
98184: LD_VAR 0 7
98188: ARRAY
98189: PPUSH
98190: CALL_OW 141
98194: GO 98359
// if not HasTask ( group [ i ] ) and to_heal then
98196: LD_VAR 0 4
98200: PUSH
98201: LD_VAR 0 7
98205: ARRAY
98206: PPUSH
98207: CALL_OW 314
98211: NOT
98212: PUSH
98213: LD_VAR 0 30
98217: AND
98218: IFFALSE 98359
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
98220: LD_ADDR_VAR 0 13
98224: PUSH
98225: LD_VAR 0 30
98229: PPUSH
98230: LD_INT 3
98232: PUSH
98233: LD_INT 54
98235: PUSH
98236: EMPTY
98237: LIST
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: PPUSH
98243: CALL_OW 72
98247: PPUSH
98248: LD_VAR 0 4
98252: PUSH
98253: LD_VAR 0 7
98257: ARRAY
98258: PPUSH
98259: CALL_OW 74
98263: ST_TO_ADDR
// if z then
98264: LD_VAR 0 13
98268: IFFALSE 98359
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
98270: LD_INT 91
98272: PUSH
98273: LD_VAR 0 13
98277: PUSH
98278: LD_INT 10
98280: PUSH
98281: EMPTY
98282: LIST
98283: LIST
98284: LIST
98285: PUSH
98286: LD_INT 81
98288: PUSH
98289: LD_VAR 0 13
98293: PPUSH
98294: CALL_OW 255
98298: PUSH
98299: EMPTY
98300: LIST
98301: LIST
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: PPUSH
98307: CALL_OW 69
98311: PUSH
98312: LD_INT 0
98314: EQUAL
98315: IFFALSE 98339
// ComHeal ( group [ i ] , z ) else
98317: LD_VAR 0 4
98321: PUSH
98322: LD_VAR 0 7
98326: ARRAY
98327: PPUSH
98328: LD_VAR 0 13
98332: PPUSH
98333: CALL_OW 128
98337: GO 98359
// ComMoveToArea ( group [ i ] , f_heal ) ;
98339: LD_VAR 0 4
98343: PUSH
98344: LD_VAR 0 7
98348: ARRAY
98349: PPUSH
98350: LD_VAR 0 23
98354: PPUSH
98355: CALL_OW 113
// end ; continue ;
98359: GO 97390
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
98361: LD_VAR 0 4
98365: PUSH
98366: LD_VAR 0 7
98370: ARRAY
98371: PPUSH
98372: CALL_OW 256
98376: PUSH
98377: LD_INT 700
98379: LESS
98380: PUSH
98381: LD_VAR 0 4
98385: PUSH
98386: LD_VAR 0 7
98390: ARRAY
98391: PUSH
98392: LD_VAR 0 30
98396: IN
98397: NOT
98398: AND
98399: IFFALSE 98423
// to_heal := to_heal union group [ i ] ;
98401: LD_ADDR_VAR 0 30
98405: PUSH
98406: LD_VAR 0 30
98410: PUSH
98411: LD_VAR 0 4
98415: PUSH
98416: LD_VAR 0 7
98420: ARRAY
98421: UNION
98422: ST_TO_ADDR
// if group [ i ] in to_heal then
98423: LD_VAR 0 4
98427: PUSH
98428: LD_VAR 0 7
98432: ARRAY
98433: PUSH
98434: LD_VAR 0 30
98438: IN
98439: IFFALSE 98548
// begin if GetLives ( group [ i ] ) = 1000 then
98441: LD_VAR 0 4
98445: PUSH
98446: LD_VAR 0 7
98450: ARRAY
98451: PPUSH
98452: CALL_OW 256
98456: PUSH
98457: LD_INT 1000
98459: EQUAL
98460: IFFALSE 98486
// to_heal := to_heal diff group [ i ] else
98462: LD_ADDR_VAR 0 30
98466: PUSH
98467: LD_VAR 0 30
98471: PUSH
98472: LD_VAR 0 4
98476: PUSH
98477: LD_VAR 0 7
98481: ARRAY
98482: DIFF
98483: ST_TO_ADDR
98484: GO 98548
// begin if not IsInArea ( group [ i ] , to_heal ) then
98486: LD_VAR 0 4
98490: PUSH
98491: LD_VAR 0 7
98495: ARRAY
98496: PPUSH
98497: LD_VAR 0 30
98501: PPUSH
98502: CALL_OW 308
98506: NOT
98507: IFFALSE 98531
// ComMoveToArea ( group [ i ] , f_heal ) else
98509: LD_VAR 0 4
98513: PUSH
98514: LD_VAR 0 7
98518: ARRAY
98519: PPUSH
98520: LD_VAR 0 23
98524: PPUSH
98525: CALL_OW 113
98529: GO 98546
// ComHold ( group [ i ] ) ;
98531: LD_VAR 0 4
98535: PUSH
98536: LD_VAR 0 7
98540: ARRAY
98541: PPUSH
98542: CALL_OW 140
// continue ;
98546: GO 97390
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
98548: LD_VAR 0 4
98552: PUSH
98553: LD_VAR 0 7
98557: ARRAY
98558: PPUSH
98559: LD_INT 10
98561: PPUSH
98562: CALL 95188 0 2
98566: NOT
98567: PUSH
98568: LD_VAR 0 16
98572: PUSH
98573: LD_VAR 0 7
98577: ARRAY
98578: PUSH
98579: EMPTY
98580: EQUAL
98581: NOT
98582: AND
98583: IFFALSE 98849
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
98585: LD_VAR 0 4
98589: PUSH
98590: LD_VAR 0 7
98594: ARRAY
98595: PPUSH
98596: CALL_OW 262
98600: PUSH
98601: LD_INT 1
98603: PUSH
98604: LD_INT 2
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: IN
98611: IFFALSE 98652
// if GetFuel ( group [ i ] ) < 10 then
98613: LD_VAR 0 4
98617: PUSH
98618: LD_VAR 0 7
98622: ARRAY
98623: PPUSH
98624: CALL_OW 261
98628: PUSH
98629: LD_INT 10
98631: LESS
98632: IFFALSE 98652
// SetFuel ( group [ i ] , 12 ) ;
98634: LD_VAR 0 4
98638: PUSH
98639: LD_VAR 0 7
98643: ARRAY
98644: PPUSH
98645: LD_INT 12
98647: PPUSH
98648: CALL_OW 240
// if units_path [ i ] then
98652: LD_VAR 0 16
98656: PUSH
98657: LD_VAR 0 7
98661: ARRAY
98662: IFFALSE 98847
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
98664: LD_VAR 0 4
98668: PUSH
98669: LD_VAR 0 7
98673: ARRAY
98674: PPUSH
98675: LD_VAR 0 16
98679: PUSH
98680: LD_VAR 0 7
98684: ARRAY
98685: PUSH
98686: LD_INT 1
98688: ARRAY
98689: PUSH
98690: LD_INT 1
98692: ARRAY
98693: PPUSH
98694: LD_VAR 0 16
98698: PUSH
98699: LD_VAR 0 7
98703: ARRAY
98704: PUSH
98705: LD_INT 1
98707: ARRAY
98708: PUSH
98709: LD_INT 2
98711: ARRAY
98712: PPUSH
98713: CALL_OW 297
98717: PUSH
98718: LD_INT 6
98720: GREATER
98721: IFFALSE 98796
// begin if not HasTask ( group [ i ] ) then
98723: LD_VAR 0 4
98727: PUSH
98728: LD_VAR 0 7
98732: ARRAY
98733: PPUSH
98734: CALL_OW 314
98738: NOT
98739: IFFALSE 98794
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
98741: LD_VAR 0 4
98745: PUSH
98746: LD_VAR 0 7
98750: ARRAY
98751: PPUSH
98752: LD_VAR 0 16
98756: PUSH
98757: LD_VAR 0 7
98761: ARRAY
98762: PUSH
98763: LD_INT 1
98765: ARRAY
98766: PUSH
98767: LD_INT 1
98769: ARRAY
98770: PPUSH
98771: LD_VAR 0 16
98775: PUSH
98776: LD_VAR 0 7
98780: ARRAY
98781: PUSH
98782: LD_INT 1
98784: ARRAY
98785: PUSH
98786: LD_INT 2
98788: ARRAY
98789: PPUSH
98790: CALL_OW 114
// end else
98794: GO 98847
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
98796: LD_ADDR_VAR 0 15
98800: PUSH
98801: LD_VAR 0 16
98805: PUSH
98806: LD_VAR 0 7
98810: ARRAY
98811: PPUSH
98812: LD_INT 1
98814: PPUSH
98815: CALL_OW 3
98819: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
98820: LD_ADDR_VAR 0 16
98824: PUSH
98825: LD_VAR 0 16
98829: PPUSH
98830: LD_VAR 0 7
98834: PPUSH
98835: LD_VAR 0 15
98839: PPUSH
98840: CALL_OW 1
98844: ST_TO_ADDR
// continue ;
98845: GO 97390
// end ; end ; end else
98847: GO 101485
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
98849: LD_ADDR_VAR 0 14
98853: PUSH
98854: LD_INT 81
98856: PUSH
98857: LD_VAR 0 4
98861: PUSH
98862: LD_VAR 0 7
98866: ARRAY
98867: PPUSH
98868: CALL_OW 255
98872: PUSH
98873: EMPTY
98874: LIST
98875: LIST
98876: PPUSH
98877: CALL_OW 69
98881: ST_TO_ADDR
// if not tmp then
98882: LD_VAR 0 14
98886: NOT
98887: IFFALSE 98891
// continue ;
98889: GO 97390
// if f_ignore_area then
98891: LD_VAR 0 17
98895: IFFALSE 98983
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
98897: LD_ADDR_VAR 0 15
98901: PUSH
98902: LD_VAR 0 14
98906: PPUSH
98907: LD_INT 3
98909: PUSH
98910: LD_INT 92
98912: PUSH
98913: LD_VAR 0 17
98917: PUSH
98918: LD_INT 1
98920: ARRAY
98921: PUSH
98922: LD_VAR 0 17
98926: PUSH
98927: LD_INT 2
98929: ARRAY
98930: PUSH
98931: LD_VAR 0 17
98935: PUSH
98936: LD_INT 3
98938: ARRAY
98939: PUSH
98940: EMPTY
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: PUSH
98946: EMPTY
98947: LIST
98948: LIST
98949: PPUSH
98950: CALL_OW 72
98954: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
98955: LD_VAR 0 14
98959: PUSH
98960: LD_VAR 0 15
98964: DIFF
98965: IFFALSE 98983
// tmp := tmp diff tmp2 ;
98967: LD_ADDR_VAR 0 14
98971: PUSH
98972: LD_VAR 0 14
98976: PUSH
98977: LD_VAR 0 15
98981: DIFF
98982: ST_TO_ADDR
// end ; if not f_murder then
98983: LD_VAR 0 20
98987: NOT
98988: IFFALSE 99046
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
98990: LD_ADDR_VAR 0 15
98994: PUSH
98995: LD_VAR 0 14
98999: PPUSH
99000: LD_INT 3
99002: PUSH
99003: LD_INT 50
99005: PUSH
99006: EMPTY
99007: LIST
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PPUSH
99013: CALL_OW 72
99017: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
99018: LD_VAR 0 14
99022: PUSH
99023: LD_VAR 0 15
99027: DIFF
99028: IFFALSE 99046
// tmp := tmp diff tmp2 ;
99030: LD_ADDR_VAR 0 14
99034: PUSH
99035: LD_VAR 0 14
99039: PUSH
99040: LD_VAR 0 15
99044: DIFF
99045: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
99046: LD_ADDR_VAR 0 14
99050: PUSH
99051: LD_VAR 0 4
99055: PUSH
99056: LD_VAR 0 7
99060: ARRAY
99061: PPUSH
99062: LD_VAR 0 14
99066: PPUSH
99067: LD_INT 1
99069: PPUSH
99070: LD_INT 1
99072: PPUSH
99073: CALL 68855 0 4
99077: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
99078: LD_VAR 0 4
99082: PUSH
99083: LD_VAR 0 7
99087: ARRAY
99088: PPUSH
99089: CALL_OW 257
99093: PUSH
99094: LD_INT 1
99096: EQUAL
99097: IFFALSE 99545
// begin if WantPlant ( group [ i ] ) then
99099: LD_VAR 0 4
99103: PUSH
99104: LD_VAR 0 7
99108: ARRAY
99109: PPUSH
99110: CALL 68356 0 1
99114: IFFALSE 99118
// continue ;
99116: GO 97390
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
99118: LD_VAR 0 18
99122: PUSH
99123: LD_VAR 0 4
99127: PUSH
99128: LD_VAR 0 7
99132: ARRAY
99133: PPUSH
99134: CALL_OW 310
99138: NOT
99139: AND
99140: PUSH
99141: LD_VAR 0 14
99145: PUSH
99146: LD_INT 1
99148: ARRAY
99149: PUSH
99150: LD_VAR 0 14
99154: PPUSH
99155: LD_INT 21
99157: PUSH
99158: LD_INT 2
99160: PUSH
99161: EMPTY
99162: LIST
99163: LIST
99164: PUSH
99165: LD_INT 58
99167: PUSH
99168: EMPTY
99169: LIST
99170: PUSH
99171: EMPTY
99172: LIST
99173: LIST
99174: PPUSH
99175: CALL_OW 72
99179: IN
99180: AND
99181: IFFALSE 99217
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
99183: LD_VAR 0 4
99187: PUSH
99188: LD_VAR 0 7
99192: ARRAY
99193: PPUSH
99194: LD_VAR 0 14
99198: PUSH
99199: LD_INT 1
99201: ARRAY
99202: PPUSH
99203: CALL_OW 120
// attacking := true ;
99207: LD_ADDR_VAR 0 29
99211: PUSH
99212: LD_INT 1
99214: ST_TO_ADDR
// continue ;
99215: GO 97390
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
99217: LD_VAR 0 26
99221: PUSH
99222: LD_VAR 0 4
99226: PUSH
99227: LD_VAR 0 7
99231: ARRAY
99232: PPUSH
99233: CALL_OW 257
99237: PUSH
99238: LD_INT 1
99240: EQUAL
99241: AND
99242: PUSH
99243: LD_VAR 0 4
99247: PUSH
99248: LD_VAR 0 7
99252: ARRAY
99253: PPUSH
99254: CALL_OW 256
99258: PUSH
99259: LD_INT 800
99261: LESS
99262: AND
99263: PUSH
99264: LD_VAR 0 4
99268: PUSH
99269: LD_VAR 0 7
99273: ARRAY
99274: PPUSH
99275: CALL_OW 318
99279: NOT
99280: AND
99281: IFFALSE 99298
// ComCrawl ( group [ i ] ) ;
99283: LD_VAR 0 4
99287: PUSH
99288: LD_VAR 0 7
99292: ARRAY
99293: PPUSH
99294: CALL_OW 137
// if f_mines then
99298: LD_VAR 0 21
99302: IFFALSE 99545
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
99304: LD_VAR 0 14
99308: PUSH
99309: LD_INT 1
99311: ARRAY
99312: PPUSH
99313: CALL_OW 247
99317: PUSH
99318: LD_INT 3
99320: EQUAL
99321: PUSH
99322: LD_VAR 0 14
99326: PUSH
99327: LD_INT 1
99329: ARRAY
99330: PUSH
99331: LD_VAR 0 27
99335: IN
99336: NOT
99337: AND
99338: IFFALSE 99545
// begin x := GetX ( tmp [ 1 ] ) ;
99340: LD_ADDR_VAR 0 10
99344: PUSH
99345: LD_VAR 0 14
99349: PUSH
99350: LD_INT 1
99352: ARRAY
99353: PPUSH
99354: CALL_OW 250
99358: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
99359: LD_ADDR_VAR 0 11
99363: PUSH
99364: LD_VAR 0 14
99368: PUSH
99369: LD_INT 1
99371: ARRAY
99372: PPUSH
99373: CALL_OW 251
99377: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
99378: LD_ADDR_VAR 0 12
99382: PUSH
99383: LD_VAR 0 4
99387: PUSH
99388: LD_VAR 0 7
99392: ARRAY
99393: PPUSH
99394: CALL 95273 0 1
99398: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
99399: LD_VAR 0 4
99403: PUSH
99404: LD_VAR 0 7
99408: ARRAY
99409: PPUSH
99410: LD_VAR 0 10
99414: PPUSH
99415: LD_VAR 0 11
99419: PPUSH
99420: LD_VAR 0 14
99424: PUSH
99425: LD_INT 1
99427: ARRAY
99428: PPUSH
99429: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
99433: LD_VAR 0 4
99437: PUSH
99438: LD_VAR 0 7
99442: ARRAY
99443: PPUSH
99444: LD_VAR 0 10
99448: PPUSH
99449: LD_VAR 0 12
99453: PPUSH
99454: LD_INT 7
99456: PPUSH
99457: CALL_OW 272
99461: PPUSH
99462: LD_VAR 0 11
99466: PPUSH
99467: LD_VAR 0 12
99471: PPUSH
99472: LD_INT 7
99474: PPUSH
99475: CALL_OW 273
99479: PPUSH
99480: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
99484: LD_VAR 0 4
99488: PUSH
99489: LD_VAR 0 7
99493: ARRAY
99494: PPUSH
99495: LD_INT 71
99497: PPUSH
99498: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
99502: LD_ADDR_VAR 0 27
99506: PUSH
99507: LD_VAR 0 27
99511: PPUSH
99512: LD_VAR 0 27
99516: PUSH
99517: LD_INT 1
99519: PLUS
99520: PPUSH
99521: LD_VAR 0 14
99525: PUSH
99526: LD_INT 1
99528: ARRAY
99529: PPUSH
99530: CALL_OW 1
99534: ST_TO_ADDR
// attacking := true ;
99535: LD_ADDR_VAR 0 29
99539: PUSH
99540: LD_INT 1
99542: ST_TO_ADDR
// continue ;
99543: GO 97390
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
99545: LD_VAR 0 4
99549: PUSH
99550: LD_VAR 0 7
99554: ARRAY
99555: PPUSH
99556: CALL_OW 257
99560: PUSH
99561: LD_INT 17
99563: EQUAL
99564: PUSH
99565: LD_VAR 0 4
99569: PUSH
99570: LD_VAR 0 7
99574: ARRAY
99575: PPUSH
99576: CALL_OW 110
99580: PUSH
99581: LD_INT 71
99583: EQUAL
99584: NOT
99585: AND
99586: IFFALSE 99732
// begin attacking := false ;
99588: LD_ADDR_VAR 0 29
99592: PUSH
99593: LD_INT 0
99595: ST_TO_ADDR
// k := 5 ;
99596: LD_ADDR_VAR 0 9
99600: PUSH
99601: LD_INT 5
99603: ST_TO_ADDR
// if tmp < k then
99604: LD_VAR 0 14
99608: PUSH
99609: LD_VAR 0 9
99613: LESS
99614: IFFALSE 99626
// k := tmp ;
99616: LD_ADDR_VAR 0 9
99620: PUSH
99621: LD_VAR 0 14
99625: ST_TO_ADDR
// for j = 1 to k do
99626: LD_ADDR_VAR 0 8
99630: PUSH
99631: DOUBLE
99632: LD_INT 1
99634: DEC
99635: ST_TO_ADDR
99636: LD_VAR 0 9
99640: PUSH
99641: FOR_TO
99642: IFFALSE 99730
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
99644: LD_VAR 0 14
99648: PUSH
99649: LD_VAR 0 8
99653: ARRAY
99654: PUSH
99655: LD_VAR 0 14
99659: PPUSH
99660: LD_INT 58
99662: PUSH
99663: EMPTY
99664: LIST
99665: PPUSH
99666: CALL_OW 72
99670: IN
99671: NOT
99672: IFFALSE 99728
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99674: LD_VAR 0 4
99678: PUSH
99679: LD_VAR 0 7
99683: ARRAY
99684: PPUSH
99685: LD_VAR 0 14
99689: PUSH
99690: LD_VAR 0 8
99694: ARRAY
99695: PPUSH
99696: CALL_OW 115
// attacking := true ;
99700: LD_ADDR_VAR 0 29
99704: PUSH
99705: LD_INT 1
99707: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
99708: LD_VAR 0 4
99712: PUSH
99713: LD_VAR 0 7
99717: ARRAY
99718: PPUSH
99719: LD_INT 71
99721: PPUSH
99722: CALL_OW 109
// continue ;
99726: GO 99641
// end ; end ;
99728: GO 99641
99730: POP
99731: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
99732: LD_VAR 0 4
99736: PUSH
99737: LD_VAR 0 7
99741: ARRAY
99742: PPUSH
99743: CALL_OW 257
99747: PUSH
99748: LD_INT 8
99750: EQUAL
99751: PUSH
99752: LD_VAR 0 4
99756: PUSH
99757: LD_VAR 0 7
99761: ARRAY
99762: PPUSH
99763: CALL_OW 264
99767: PUSH
99768: LD_INT 28
99770: PUSH
99771: LD_INT 45
99773: PUSH
99774: LD_INT 7
99776: PUSH
99777: LD_INT 47
99779: PUSH
99780: EMPTY
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: IN
99786: OR
99787: IFFALSE 100017
// begin attacking := false ;
99789: LD_ADDR_VAR 0 29
99793: PUSH
99794: LD_INT 0
99796: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
99797: LD_VAR 0 14
99801: PUSH
99802: LD_INT 1
99804: ARRAY
99805: PPUSH
99806: CALL_OW 266
99810: PUSH
99811: LD_INT 32
99813: PUSH
99814: LD_INT 31
99816: PUSH
99817: LD_INT 33
99819: PUSH
99820: LD_INT 4
99822: PUSH
99823: LD_INT 5
99825: PUSH
99826: EMPTY
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: IN
99833: IFFALSE 100017
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
99835: LD_ADDR_VAR 0 9
99839: PUSH
99840: LD_VAR 0 14
99844: PUSH
99845: LD_INT 1
99847: ARRAY
99848: PPUSH
99849: CALL_OW 266
99853: PPUSH
99854: LD_VAR 0 14
99858: PUSH
99859: LD_INT 1
99861: ARRAY
99862: PPUSH
99863: CALL_OW 250
99867: PPUSH
99868: LD_VAR 0 14
99872: PUSH
99873: LD_INT 1
99875: ARRAY
99876: PPUSH
99877: CALL_OW 251
99881: PPUSH
99882: LD_VAR 0 14
99886: PUSH
99887: LD_INT 1
99889: ARRAY
99890: PPUSH
99891: CALL_OW 254
99895: PPUSH
99896: LD_VAR 0 14
99900: PUSH
99901: LD_INT 1
99903: ARRAY
99904: PPUSH
99905: CALL_OW 248
99909: PPUSH
99910: LD_INT 0
99912: PPUSH
99913: CALL 76649 0 6
99917: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
99918: LD_ADDR_VAR 0 8
99922: PUSH
99923: LD_VAR 0 4
99927: PUSH
99928: LD_VAR 0 7
99932: ARRAY
99933: PPUSH
99934: LD_VAR 0 9
99938: PPUSH
99939: CALL 95336 0 2
99943: ST_TO_ADDR
// if j then
99944: LD_VAR 0 8
99948: IFFALSE 100017
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
99950: LD_VAR 0 8
99954: PUSH
99955: LD_INT 1
99957: ARRAY
99958: PPUSH
99959: LD_VAR 0 8
99963: PUSH
99964: LD_INT 2
99966: ARRAY
99967: PPUSH
99968: CALL_OW 488
99972: IFFALSE 100017
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
99974: LD_VAR 0 4
99978: PUSH
99979: LD_VAR 0 7
99983: ARRAY
99984: PPUSH
99985: LD_VAR 0 8
99989: PUSH
99990: LD_INT 1
99992: ARRAY
99993: PPUSH
99994: LD_VAR 0 8
99998: PUSH
99999: LD_INT 2
100001: ARRAY
100002: PPUSH
100003: CALL_OW 116
// attacking := true ;
100007: LD_ADDR_VAR 0 29
100011: PUSH
100012: LD_INT 1
100014: ST_TO_ADDR
// continue ;
100015: GO 97390
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
100017: LD_VAR 0 4
100021: PUSH
100022: LD_VAR 0 7
100026: ARRAY
100027: PPUSH
100028: CALL_OW 265
100032: PUSH
100033: LD_INT 11
100035: EQUAL
100036: IFFALSE 100314
// begin k := 10 ;
100038: LD_ADDR_VAR 0 9
100042: PUSH
100043: LD_INT 10
100045: ST_TO_ADDR
// x := 0 ;
100046: LD_ADDR_VAR 0 10
100050: PUSH
100051: LD_INT 0
100053: ST_TO_ADDR
// if tmp < k then
100054: LD_VAR 0 14
100058: PUSH
100059: LD_VAR 0 9
100063: LESS
100064: IFFALSE 100076
// k := tmp ;
100066: LD_ADDR_VAR 0 9
100070: PUSH
100071: LD_VAR 0 14
100075: ST_TO_ADDR
// for j = k downto 1 do
100076: LD_ADDR_VAR 0 8
100080: PUSH
100081: DOUBLE
100082: LD_VAR 0 9
100086: INC
100087: ST_TO_ADDR
100088: LD_INT 1
100090: PUSH
100091: FOR_DOWNTO
100092: IFFALSE 100167
// begin if GetType ( tmp [ j ] ) = unit_human then
100094: LD_VAR 0 14
100098: PUSH
100099: LD_VAR 0 8
100103: ARRAY
100104: PPUSH
100105: CALL_OW 247
100109: PUSH
100110: LD_INT 1
100112: EQUAL
100113: IFFALSE 100165
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
100115: LD_VAR 0 4
100119: PUSH
100120: LD_VAR 0 7
100124: ARRAY
100125: PPUSH
100126: LD_VAR 0 14
100130: PUSH
100131: LD_VAR 0 8
100135: ARRAY
100136: PPUSH
100137: CALL 95607 0 2
// x := tmp [ j ] ;
100141: LD_ADDR_VAR 0 10
100145: PUSH
100146: LD_VAR 0 14
100150: PUSH
100151: LD_VAR 0 8
100155: ARRAY
100156: ST_TO_ADDR
// attacking := true ;
100157: LD_ADDR_VAR 0 29
100161: PUSH
100162: LD_INT 1
100164: ST_TO_ADDR
// end ; end ;
100165: GO 100091
100167: POP
100168: POP
// if not x then
100169: LD_VAR 0 10
100173: NOT
100174: IFFALSE 100314
// begin attacking := true ;
100176: LD_ADDR_VAR 0 29
100180: PUSH
100181: LD_INT 1
100183: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
100184: LD_VAR 0 4
100188: PUSH
100189: LD_VAR 0 7
100193: ARRAY
100194: PPUSH
100195: CALL_OW 250
100199: PPUSH
100200: LD_VAR 0 4
100204: PUSH
100205: LD_VAR 0 7
100209: ARRAY
100210: PPUSH
100211: CALL_OW 251
100215: PPUSH
100216: CALL_OW 546
100220: PUSH
100221: LD_INT 2
100223: ARRAY
100224: PUSH
100225: LD_VAR 0 14
100229: PUSH
100230: LD_INT 1
100232: ARRAY
100233: PPUSH
100234: CALL_OW 250
100238: PPUSH
100239: LD_VAR 0 14
100243: PUSH
100244: LD_INT 1
100246: ARRAY
100247: PPUSH
100248: CALL_OW 251
100252: PPUSH
100253: CALL_OW 546
100257: PUSH
100258: LD_INT 2
100260: ARRAY
100261: EQUAL
100262: IFFALSE 100290
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
100264: LD_VAR 0 4
100268: PUSH
100269: LD_VAR 0 7
100273: ARRAY
100274: PPUSH
100275: LD_VAR 0 14
100279: PUSH
100280: LD_INT 1
100282: ARRAY
100283: PPUSH
100284: CALL 95607 0 2
100288: GO 100314
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100290: LD_VAR 0 4
100294: PUSH
100295: LD_VAR 0 7
100299: ARRAY
100300: PPUSH
100301: LD_VAR 0 14
100305: PUSH
100306: LD_INT 1
100308: ARRAY
100309: PPUSH
100310: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
100314: LD_VAR 0 4
100318: PUSH
100319: LD_VAR 0 7
100323: ARRAY
100324: PPUSH
100325: CALL_OW 264
100329: PUSH
100330: LD_INT 29
100332: EQUAL
100333: IFFALSE 100699
// begin if WantsToAttack ( group [ i ] ) in bombed then
100335: LD_VAR 0 4
100339: PUSH
100340: LD_VAR 0 7
100344: ARRAY
100345: PPUSH
100346: CALL_OW 319
100350: PUSH
100351: LD_VAR 0 28
100355: IN
100356: IFFALSE 100360
// continue ;
100358: GO 97390
// k := 8 ;
100360: LD_ADDR_VAR 0 9
100364: PUSH
100365: LD_INT 8
100367: ST_TO_ADDR
// x := 0 ;
100368: LD_ADDR_VAR 0 10
100372: PUSH
100373: LD_INT 0
100375: ST_TO_ADDR
// if tmp < k then
100376: LD_VAR 0 14
100380: PUSH
100381: LD_VAR 0 9
100385: LESS
100386: IFFALSE 100398
// k := tmp ;
100388: LD_ADDR_VAR 0 9
100392: PUSH
100393: LD_VAR 0 14
100397: ST_TO_ADDR
// for j = 1 to k do
100398: LD_ADDR_VAR 0 8
100402: PUSH
100403: DOUBLE
100404: LD_INT 1
100406: DEC
100407: ST_TO_ADDR
100408: LD_VAR 0 9
100412: PUSH
100413: FOR_TO
100414: IFFALSE 100546
// begin if GetType ( tmp [ j ] ) = unit_building then
100416: LD_VAR 0 14
100420: PUSH
100421: LD_VAR 0 8
100425: ARRAY
100426: PPUSH
100427: CALL_OW 247
100431: PUSH
100432: LD_INT 3
100434: EQUAL
100435: IFFALSE 100544
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
100437: LD_VAR 0 14
100441: PUSH
100442: LD_VAR 0 8
100446: ARRAY
100447: PUSH
100448: LD_VAR 0 28
100452: IN
100453: NOT
100454: PUSH
100455: LD_VAR 0 14
100459: PUSH
100460: LD_VAR 0 8
100464: ARRAY
100465: PPUSH
100466: CALL_OW 313
100470: AND
100471: IFFALSE 100544
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100473: LD_VAR 0 4
100477: PUSH
100478: LD_VAR 0 7
100482: ARRAY
100483: PPUSH
100484: LD_VAR 0 14
100488: PUSH
100489: LD_VAR 0 8
100493: ARRAY
100494: PPUSH
100495: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
100499: LD_ADDR_VAR 0 28
100503: PUSH
100504: LD_VAR 0 28
100508: PPUSH
100509: LD_VAR 0 28
100513: PUSH
100514: LD_INT 1
100516: PLUS
100517: PPUSH
100518: LD_VAR 0 14
100522: PUSH
100523: LD_VAR 0 8
100527: ARRAY
100528: PPUSH
100529: CALL_OW 1
100533: ST_TO_ADDR
// attacking := true ;
100534: LD_ADDR_VAR 0 29
100538: PUSH
100539: LD_INT 1
100541: ST_TO_ADDR
// break ;
100542: GO 100546
// end ; end ;
100544: GO 100413
100546: POP
100547: POP
// if not attacking and f_attack_depot then
100548: LD_VAR 0 29
100552: NOT
100553: PUSH
100554: LD_VAR 0 25
100558: AND
100559: IFFALSE 100654
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100561: LD_ADDR_VAR 0 13
100565: PUSH
100566: LD_VAR 0 14
100570: PPUSH
100571: LD_INT 2
100573: PUSH
100574: LD_INT 30
100576: PUSH
100577: LD_INT 0
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: PUSH
100584: LD_INT 30
100586: PUSH
100587: LD_INT 1
100589: PUSH
100590: EMPTY
100591: LIST
100592: LIST
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: LIST
100598: PPUSH
100599: CALL_OW 72
100603: ST_TO_ADDR
// if z then
100604: LD_VAR 0 13
100608: IFFALSE 100654
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
100610: LD_VAR 0 4
100614: PUSH
100615: LD_VAR 0 7
100619: ARRAY
100620: PPUSH
100621: LD_VAR 0 13
100625: PPUSH
100626: LD_VAR 0 4
100630: PUSH
100631: LD_VAR 0 7
100635: ARRAY
100636: PPUSH
100637: CALL_OW 74
100641: PPUSH
100642: CALL_OW 115
// attacking := true ;
100646: LD_ADDR_VAR 0 29
100650: PUSH
100651: LD_INT 1
100653: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
100654: LD_VAR 0 4
100658: PUSH
100659: LD_VAR 0 7
100663: ARRAY
100664: PPUSH
100665: CALL_OW 256
100669: PUSH
100670: LD_INT 500
100672: LESS
100673: IFFALSE 100699
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100675: LD_VAR 0 4
100679: PUSH
100680: LD_VAR 0 7
100684: ARRAY
100685: PPUSH
100686: LD_VAR 0 14
100690: PUSH
100691: LD_INT 1
100693: ARRAY
100694: PPUSH
100695: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
100699: LD_VAR 0 4
100703: PUSH
100704: LD_VAR 0 7
100708: ARRAY
100709: PPUSH
100710: CALL_OW 264
100714: PUSH
100715: LD_INT 49
100717: EQUAL
100718: IFFALSE 100839
// begin if not HasTask ( group [ i ] ) then
100720: LD_VAR 0 4
100724: PUSH
100725: LD_VAR 0 7
100729: ARRAY
100730: PPUSH
100731: CALL_OW 314
100735: NOT
100736: IFFALSE 100839
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
100738: LD_ADDR_VAR 0 9
100742: PUSH
100743: LD_INT 81
100745: PUSH
100746: LD_VAR 0 4
100750: PUSH
100751: LD_VAR 0 7
100755: ARRAY
100756: PPUSH
100757: CALL_OW 255
100761: PUSH
100762: EMPTY
100763: LIST
100764: LIST
100765: PPUSH
100766: CALL_OW 69
100770: PPUSH
100771: LD_VAR 0 4
100775: PUSH
100776: LD_VAR 0 7
100780: ARRAY
100781: PPUSH
100782: CALL_OW 74
100786: ST_TO_ADDR
// if k then
100787: LD_VAR 0 9
100791: IFFALSE 100839
// if GetDistUnits ( group [ i ] , k ) > 10 then
100793: LD_VAR 0 4
100797: PUSH
100798: LD_VAR 0 7
100802: ARRAY
100803: PPUSH
100804: LD_VAR 0 9
100808: PPUSH
100809: CALL_OW 296
100813: PUSH
100814: LD_INT 10
100816: GREATER
100817: IFFALSE 100839
// ComMoveUnit ( group [ i ] , k ) ;
100819: LD_VAR 0 4
100823: PUSH
100824: LD_VAR 0 7
100828: ARRAY
100829: PPUSH
100830: LD_VAR 0 9
100834: PPUSH
100835: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100839: LD_VAR 0 4
100843: PUSH
100844: LD_VAR 0 7
100848: ARRAY
100849: PPUSH
100850: CALL_OW 256
100854: PUSH
100855: LD_INT 250
100857: LESS
100858: PUSH
100859: LD_VAR 0 4
100863: PUSH
100864: LD_VAR 0 7
100868: ARRAY
100869: PUSH
100870: LD_INT 21
100872: PUSH
100873: LD_INT 2
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PUSH
100880: LD_INT 23
100882: PUSH
100883: LD_INT 2
100885: PUSH
100886: EMPTY
100887: LIST
100888: LIST
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PPUSH
100894: CALL_OW 69
100898: IN
100899: AND
100900: IFFALSE 101025
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
100902: LD_ADDR_VAR 0 9
100906: PUSH
100907: LD_OWVAR 3
100911: PUSH
100912: LD_VAR 0 4
100916: PUSH
100917: LD_VAR 0 7
100921: ARRAY
100922: DIFF
100923: PPUSH
100924: LD_VAR 0 4
100928: PUSH
100929: LD_VAR 0 7
100933: ARRAY
100934: PPUSH
100935: CALL_OW 74
100939: ST_TO_ADDR
// if not k then
100940: LD_VAR 0 9
100944: NOT
100945: IFFALSE 100949
// continue ;
100947: GO 97390
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
100949: LD_VAR 0 9
100953: PUSH
100954: LD_INT 81
100956: PUSH
100957: LD_VAR 0 4
100961: PUSH
100962: LD_VAR 0 7
100966: ARRAY
100967: PPUSH
100968: CALL_OW 255
100972: PUSH
100973: EMPTY
100974: LIST
100975: LIST
100976: PPUSH
100977: CALL_OW 69
100981: IN
100982: PUSH
100983: LD_VAR 0 9
100987: PPUSH
100988: LD_VAR 0 4
100992: PUSH
100993: LD_VAR 0 7
100997: ARRAY
100998: PPUSH
100999: CALL_OW 296
101003: PUSH
101004: LD_INT 5
101006: LESS
101007: AND
101008: IFFALSE 101025
// ComAutodestruct ( group [ i ] ) ;
101010: LD_VAR 0 4
101014: PUSH
101015: LD_VAR 0 7
101019: ARRAY
101020: PPUSH
101021: CALL 95505 0 1
// end ; if f_attack_depot then
101025: LD_VAR 0 25
101029: IFFALSE 101141
// begin k := 6 ;
101031: LD_ADDR_VAR 0 9
101035: PUSH
101036: LD_INT 6
101038: ST_TO_ADDR
// if tmp < k then
101039: LD_VAR 0 14
101043: PUSH
101044: LD_VAR 0 9
101048: LESS
101049: IFFALSE 101061
// k := tmp ;
101051: LD_ADDR_VAR 0 9
101055: PUSH
101056: LD_VAR 0 14
101060: ST_TO_ADDR
// for j = 1 to k do
101061: LD_ADDR_VAR 0 8
101065: PUSH
101066: DOUBLE
101067: LD_INT 1
101069: DEC
101070: ST_TO_ADDR
101071: LD_VAR 0 9
101075: PUSH
101076: FOR_TO
101077: IFFALSE 101139
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
101079: LD_VAR 0 8
101083: PPUSH
101084: CALL_OW 266
101088: PUSH
101089: LD_INT 0
101091: PUSH
101092: LD_INT 1
101094: PUSH
101095: EMPTY
101096: LIST
101097: LIST
101098: IN
101099: IFFALSE 101137
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101101: LD_VAR 0 4
101105: PUSH
101106: LD_VAR 0 7
101110: ARRAY
101111: PPUSH
101112: LD_VAR 0 14
101116: PUSH
101117: LD_VAR 0 8
101121: ARRAY
101122: PPUSH
101123: CALL_OW 115
// attacking := true ;
101127: LD_ADDR_VAR 0 29
101131: PUSH
101132: LD_INT 1
101134: ST_TO_ADDR
// break ;
101135: GO 101139
// end ;
101137: GO 101076
101139: POP
101140: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
101141: LD_VAR 0 4
101145: PUSH
101146: LD_VAR 0 7
101150: ARRAY
101151: PPUSH
101152: CALL_OW 302
101156: PUSH
101157: LD_VAR 0 29
101161: NOT
101162: AND
101163: IFFALSE 101485
// begin if GetTag ( group [ i ] ) = 71 then
101165: LD_VAR 0 4
101169: PUSH
101170: LD_VAR 0 7
101174: ARRAY
101175: PPUSH
101176: CALL_OW 110
101180: PUSH
101181: LD_INT 71
101183: EQUAL
101184: IFFALSE 101225
// begin if HasTask ( group [ i ] ) then
101186: LD_VAR 0 4
101190: PUSH
101191: LD_VAR 0 7
101195: ARRAY
101196: PPUSH
101197: CALL_OW 314
101201: IFFALSE 101207
// continue else
101203: GO 97390
101205: GO 101225
// SetTag ( group [ i ] , 0 ) ;
101207: LD_VAR 0 4
101211: PUSH
101212: LD_VAR 0 7
101216: ARRAY
101217: PPUSH
101218: LD_INT 0
101220: PPUSH
101221: CALL_OW 109
// end ; k := 8 ;
101225: LD_ADDR_VAR 0 9
101229: PUSH
101230: LD_INT 8
101232: ST_TO_ADDR
// x := 0 ;
101233: LD_ADDR_VAR 0 10
101237: PUSH
101238: LD_INT 0
101240: ST_TO_ADDR
// if tmp < k then
101241: LD_VAR 0 14
101245: PUSH
101246: LD_VAR 0 9
101250: LESS
101251: IFFALSE 101263
// k := tmp ;
101253: LD_ADDR_VAR 0 9
101257: PUSH
101258: LD_VAR 0 14
101262: ST_TO_ADDR
// for j = 1 to k do
101263: LD_ADDR_VAR 0 8
101267: PUSH
101268: DOUBLE
101269: LD_INT 1
101271: DEC
101272: ST_TO_ADDR
101273: LD_VAR 0 9
101277: PUSH
101278: FOR_TO
101279: IFFALSE 101377
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
101281: LD_VAR 0 14
101285: PUSH
101286: LD_VAR 0 8
101290: ARRAY
101291: PPUSH
101292: CALL_OW 247
101296: PUSH
101297: LD_INT 1
101299: EQUAL
101300: PUSH
101301: LD_VAR 0 14
101305: PUSH
101306: LD_VAR 0 8
101310: ARRAY
101311: PPUSH
101312: CALL_OW 256
101316: PUSH
101317: LD_INT 250
101319: LESS
101320: PUSH
101321: LD_VAR 0 20
101325: AND
101326: PUSH
101327: LD_VAR 0 20
101331: NOT
101332: PUSH
101333: LD_VAR 0 14
101337: PUSH
101338: LD_VAR 0 8
101342: ARRAY
101343: PPUSH
101344: CALL_OW 256
101348: PUSH
101349: LD_INT 250
101351: GREATEREQUAL
101352: AND
101353: OR
101354: AND
101355: IFFALSE 101375
// begin x := tmp [ j ] ;
101357: LD_ADDR_VAR 0 10
101361: PUSH
101362: LD_VAR 0 14
101366: PUSH
101367: LD_VAR 0 8
101371: ARRAY
101372: ST_TO_ADDR
// break ;
101373: GO 101377
// end ;
101375: GO 101278
101377: POP
101378: POP
// if x then
101379: LD_VAR 0 10
101383: IFFALSE 101407
// ComAttackUnit ( group [ i ] , x ) else
101385: LD_VAR 0 4
101389: PUSH
101390: LD_VAR 0 7
101394: ARRAY
101395: PPUSH
101396: LD_VAR 0 10
101400: PPUSH
101401: CALL_OW 115
101405: GO 101431
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101407: LD_VAR 0 4
101411: PUSH
101412: LD_VAR 0 7
101416: ARRAY
101417: PPUSH
101418: LD_VAR 0 14
101422: PUSH
101423: LD_INT 1
101425: ARRAY
101426: PPUSH
101427: CALL_OW 115
// if not HasTask ( group [ i ] ) then
101431: LD_VAR 0 4
101435: PUSH
101436: LD_VAR 0 7
101440: ARRAY
101441: PPUSH
101442: CALL_OW 314
101446: NOT
101447: IFFALSE 101485
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
101449: LD_VAR 0 4
101453: PUSH
101454: LD_VAR 0 7
101458: ARRAY
101459: PPUSH
101460: LD_VAR 0 14
101464: PPUSH
101465: LD_VAR 0 4
101469: PUSH
101470: LD_VAR 0 7
101474: ARRAY
101475: PPUSH
101476: CALL_OW 74
101480: PPUSH
101481: CALL_OW 115
// end ; end ; end ;
101485: GO 97390
101487: POP
101488: POP
// wait ( 0 0$1 ) ;
101489: LD_INT 35
101491: PPUSH
101492: CALL_OW 67
// until group = [ ] ;
101496: LD_VAR 0 4
101500: PUSH
101501: EMPTY
101502: EQUAL
101503: IFFALSE 97375
// end ;
101505: LD_VAR 0 2
101509: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
101510: LD_INT 0
101512: PPUSH
101513: PPUSH
101514: PPUSH
101515: PPUSH
// if not base_units then
101516: LD_VAR 0 1
101520: NOT
101521: IFFALSE 101525
// exit ;
101523: GO 101612
// result := false ;
101525: LD_ADDR_VAR 0 2
101529: PUSH
101530: LD_INT 0
101532: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
101533: LD_ADDR_VAR 0 5
101537: PUSH
101538: LD_VAR 0 1
101542: PPUSH
101543: LD_INT 21
101545: PUSH
101546: LD_INT 3
101548: PUSH
101549: EMPTY
101550: LIST
101551: LIST
101552: PPUSH
101553: CALL_OW 72
101557: ST_TO_ADDR
// if not tmp then
101558: LD_VAR 0 5
101562: NOT
101563: IFFALSE 101567
// exit ;
101565: GO 101612
// for i in tmp do
101567: LD_ADDR_VAR 0 3
101571: PUSH
101572: LD_VAR 0 5
101576: PUSH
101577: FOR_IN
101578: IFFALSE 101610
// begin result := EnemyInRange ( i , 22 ) ;
101580: LD_ADDR_VAR 0 2
101584: PUSH
101585: LD_VAR 0 3
101589: PPUSH
101590: LD_INT 22
101592: PPUSH
101593: CALL 95188 0 2
101597: ST_TO_ADDR
// if result then
101598: LD_VAR 0 2
101602: IFFALSE 101608
// exit ;
101604: POP
101605: POP
101606: GO 101612
// end ;
101608: GO 101577
101610: POP
101611: POP
// end ;
101612: LD_VAR 0 2
101616: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
101617: LD_INT 0
101619: PPUSH
101620: PPUSH
// if not units then
101621: LD_VAR 0 1
101625: NOT
101626: IFFALSE 101630
// exit ;
101628: GO 101700
// result := [ ] ;
101630: LD_ADDR_VAR 0 3
101634: PUSH
101635: EMPTY
101636: ST_TO_ADDR
// for i in units do
101637: LD_ADDR_VAR 0 4
101641: PUSH
101642: LD_VAR 0 1
101646: PUSH
101647: FOR_IN
101648: IFFALSE 101698
// if GetTag ( i ) = tag then
101650: LD_VAR 0 4
101654: PPUSH
101655: CALL_OW 110
101659: PUSH
101660: LD_VAR 0 2
101664: EQUAL
101665: IFFALSE 101696
// result := Insert ( result , result + 1 , i ) ;
101667: LD_ADDR_VAR 0 3
101671: PUSH
101672: LD_VAR 0 3
101676: PPUSH
101677: LD_VAR 0 3
101681: PUSH
101682: LD_INT 1
101684: PLUS
101685: PPUSH
101686: LD_VAR 0 4
101690: PPUSH
101691: CALL_OW 2
101695: ST_TO_ADDR
101696: GO 101647
101698: POP
101699: POP
// end ;
101700: LD_VAR 0 3
101704: RET
// export function IsDriver ( un ) ; begin
101705: LD_INT 0
101707: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
101708: LD_ADDR_VAR 0 2
101712: PUSH
101713: LD_VAR 0 1
101717: PUSH
101718: LD_INT 55
101720: PUSH
101721: EMPTY
101722: LIST
101723: PPUSH
101724: CALL_OW 69
101728: IN
101729: ST_TO_ADDR
// end ;
101730: LD_VAR 0 2
101734: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
101735: LD_INT 0
101737: PPUSH
101738: PPUSH
// list := [ ] ;
101739: LD_ADDR_VAR 0 5
101743: PUSH
101744: EMPTY
101745: ST_TO_ADDR
// case d of 0 :
101746: LD_VAR 0 3
101750: PUSH
101751: LD_INT 0
101753: DOUBLE
101754: EQUAL
101755: IFTRUE 101759
101757: GO 101892
101759: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
101760: LD_ADDR_VAR 0 5
101764: PUSH
101765: LD_VAR 0 1
101769: PUSH
101770: LD_INT 4
101772: MINUS
101773: PUSH
101774: LD_VAR 0 2
101778: PUSH
101779: LD_INT 4
101781: MINUS
101782: PUSH
101783: LD_INT 2
101785: PUSH
101786: EMPTY
101787: LIST
101788: LIST
101789: LIST
101790: PUSH
101791: LD_VAR 0 1
101795: PUSH
101796: LD_INT 3
101798: MINUS
101799: PUSH
101800: LD_VAR 0 2
101804: PUSH
101805: LD_INT 1
101807: PUSH
101808: EMPTY
101809: LIST
101810: LIST
101811: LIST
101812: PUSH
101813: LD_VAR 0 1
101817: PUSH
101818: LD_INT 4
101820: PLUS
101821: PUSH
101822: LD_VAR 0 2
101826: PUSH
101827: LD_INT 4
101829: PUSH
101830: EMPTY
101831: LIST
101832: LIST
101833: LIST
101834: PUSH
101835: LD_VAR 0 1
101839: PUSH
101840: LD_INT 3
101842: PLUS
101843: PUSH
101844: LD_VAR 0 2
101848: PUSH
101849: LD_INT 3
101851: PLUS
101852: PUSH
101853: LD_INT 5
101855: PUSH
101856: EMPTY
101857: LIST
101858: LIST
101859: LIST
101860: PUSH
101861: LD_VAR 0 1
101865: PUSH
101866: LD_VAR 0 2
101870: PUSH
101871: LD_INT 4
101873: PLUS
101874: PUSH
101875: LD_INT 0
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: LIST
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: LIST
101887: LIST
101888: LIST
101889: ST_TO_ADDR
// end ; 1 :
101890: GO 102590
101892: LD_INT 1
101894: DOUBLE
101895: EQUAL
101896: IFTRUE 101900
101898: GO 102033
101900: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
101901: LD_ADDR_VAR 0 5
101905: PUSH
101906: LD_VAR 0 1
101910: PUSH
101911: LD_VAR 0 2
101915: PUSH
101916: LD_INT 4
101918: MINUS
101919: PUSH
101920: LD_INT 3
101922: PUSH
101923: EMPTY
101924: LIST
101925: LIST
101926: LIST
101927: PUSH
101928: LD_VAR 0 1
101932: PUSH
101933: LD_INT 3
101935: MINUS
101936: PUSH
101937: LD_VAR 0 2
101941: PUSH
101942: LD_INT 3
101944: MINUS
101945: PUSH
101946: LD_INT 2
101948: PUSH
101949: EMPTY
101950: LIST
101951: LIST
101952: LIST
101953: PUSH
101954: LD_VAR 0 1
101958: PUSH
101959: LD_INT 4
101961: MINUS
101962: PUSH
101963: LD_VAR 0 2
101967: PUSH
101968: LD_INT 1
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: LIST
101975: PUSH
101976: LD_VAR 0 1
101980: PUSH
101981: LD_VAR 0 2
101985: PUSH
101986: LD_INT 3
101988: PLUS
101989: PUSH
101990: LD_INT 0
101992: PUSH
101993: EMPTY
101994: LIST
101995: LIST
101996: LIST
101997: PUSH
101998: LD_VAR 0 1
102002: PUSH
102003: LD_INT 4
102005: PLUS
102006: PUSH
102007: LD_VAR 0 2
102011: PUSH
102012: LD_INT 4
102014: PLUS
102015: PUSH
102016: LD_INT 5
102018: PUSH
102019: EMPTY
102020: LIST
102021: LIST
102022: LIST
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: LIST
102028: LIST
102029: LIST
102030: ST_TO_ADDR
// end ; 2 :
102031: GO 102590
102033: LD_INT 2
102035: DOUBLE
102036: EQUAL
102037: IFTRUE 102041
102039: GO 102170
102041: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102042: LD_ADDR_VAR 0 5
102046: PUSH
102047: LD_VAR 0 1
102051: PUSH
102052: LD_VAR 0 2
102056: PUSH
102057: LD_INT 3
102059: MINUS
102060: PUSH
102061: LD_INT 3
102063: PUSH
102064: EMPTY
102065: LIST
102066: LIST
102067: LIST
102068: PUSH
102069: LD_VAR 0 1
102073: PUSH
102074: LD_INT 4
102076: PLUS
102077: PUSH
102078: LD_VAR 0 2
102082: PUSH
102083: LD_INT 4
102085: PUSH
102086: EMPTY
102087: LIST
102088: LIST
102089: LIST
102090: PUSH
102091: LD_VAR 0 1
102095: PUSH
102096: LD_VAR 0 2
102100: PUSH
102101: LD_INT 4
102103: PLUS
102104: PUSH
102105: LD_INT 0
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: LIST
102112: PUSH
102113: LD_VAR 0 1
102117: PUSH
102118: LD_INT 3
102120: MINUS
102121: PUSH
102122: LD_VAR 0 2
102126: PUSH
102127: LD_INT 1
102129: PUSH
102130: EMPTY
102131: LIST
102132: LIST
102133: LIST
102134: PUSH
102135: LD_VAR 0 1
102139: PUSH
102140: LD_INT 4
102142: MINUS
102143: PUSH
102144: LD_VAR 0 2
102148: PUSH
102149: LD_INT 4
102151: MINUS
102152: PUSH
102153: LD_INT 2
102155: PUSH
102156: EMPTY
102157: LIST
102158: LIST
102159: LIST
102160: PUSH
102161: EMPTY
102162: LIST
102163: LIST
102164: LIST
102165: LIST
102166: LIST
102167: ST_TO_ADDR
// end ; 3 :
102168: GO 102590
102170: LD_INT 3
102172: DOUBLE
102173: EQUAL
102174: IFTRUE 102178
102176: GO 102311
102178: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102179: LD_ADDR_VAR 0 5
102183: PUSH
102184: LD_VAR 0 1
102188: PUSH
102189: LD_INT 3
102191: PLUS
102192: PUSH
102193: LD_VAR 0 2
102197: PUSH
102198: LD_INT 4
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: LIST
102205: PUSH
102206: LD_VAR 0 1
102210: PUSH
102211: LD_INT 4
102213: PLUS
102214: PUSH
102215: LD_VAR 0 2
102219: PUSH
102220: LD_INT 4
102222: PLUS
102223: PUSH
102224: LD_INT 5
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: LIST
102231: PUSH
102232: LD_VAR 0 1
102236: PUSH
102237: LD_INT 4
102239: MINUS
102240: PUSH
102241: LD_VAR 0 2
102245: PUSH
102246: LD_INT 1
102248: PUSH
102249: EMPTY
102250: LIST
102251: LIST
102252: LIST
102253: PUSH
102254: LD_VAR 0 1
102258: PUSH
102259: LD_VAR 0 2
102263: PUSH
102264: LD_INT 4
102266: MINUS
102267: PUSH
102268: LD_INT 3
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: LIST
102275: PUSH
102276: LD_VAR 0 1
102280: PUSH
102281: LD_INT 3
102283: MINUS
102284: PUSH
102285: LD_VAR 0 2
102289: PUSH
102290: LD_INT 3
102292: MINUS
102293: PUSH
102294: LD_INT 2
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: LIST
102301: PUSH
102302: EMPTY
102303: LIST
102304: LIST
102305: LIST
102306: LIST
102307: LIST
102308: ST_TO_ADDR
// end ; 4 :
102309: GO 102590
102311: LD_INT 4
102313: DOUBLE
102314: EQUAL
102315: IFTRUE 102319
102317: GO 102452
102319: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
102320: LD_ADDR_VAR 0 5
102324: PUSH
102325: LD_VAR 0 1
102329: PUSH
102330: LD_VAR 0 2
102334: PUSH
102335: LD_INT 4
102337: PLUS
102338: PUSH
102339: LD_INT 0
102341: PUSH
102342: EMPTY
102343: LIST
102344: LIST
102345: LIST
102346: PUSH
102347: LD_VAR 0 1
102351: PUSH
102352: LD_INT 3
102354: PLUS
102355: PUSH
102356: LD_VAR 0 2
102360: PUSH
102361: LD_INT 3
102363: PLUS
102364: PUSH
102365: LD_INT 5
102367: PUSH
102368: EMPTY
102369: LIST
102370: LIST
102371: LIST
102372: PUSH
102373: LD_VAR 0 1
102377: PUSH
102378: LD_INT 4
102380: PLUS
102381: PUSH
102382: LD_VAR 0 2
102386: PUSH
102387: LD_INT 4
102389: PUSH
102390: EMPTY
102391: LIST
102392: LIST
102393: LIST
102394: PUSH
102395: LD_VAR 0 1
102399: PUSH
102400: LD_VAR 0 2
102404: PUSH
102405: LD_INT 3
102407: MINUS
102408: PUSH
102409: LD_INT 3
102411: PUSH
102412: EMPTY
102413: LIST
102414: LIST
102415: LIST
102416: PUSH
102417: LD_VAR 0 1
102421: PUSH
102422: LD_INT 4
102424: MINUS
102425: PUSH
102426: LD_VAR 0 2
102430: PUSH
102431: LD_INT 4
102433: MINUS
102434: PUSH
102435: LD_INT 2
102437: PUSH
102438: EMPTY
102439: LIST
102440: LIST
102441: LIST
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: LIST
102449: ST_TO_ADDR
// end ; 5 :
102450: GO 102590
102452: LD_INT 5
102454: DOUBLE
102455: EQUAL
102456: IFTRUE 102460
102458: GO 102589
102460: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
102461: LD_ADDR_VAR 0 5
102465: PUSH
102466: LD_VAR 0 1
102470: PUSH
102471: LD_INT 4
102473: MINUS
102474: PUSH
102475: LD_VAR 0 2
102479: PUSH
102480: LD_INT 1
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: LIST
102487: PUSH
102488: LD_VAR 0 1
102492: PUSH
102493: LD_VAR 0 2
102497: PUSH
102498: LD_INT 4
102500: MINUS
102501: PUSH
102502: LD_INT 3
102504: PUSH
102505: EMPTY
102506: LIST
102507: LIST
102508: LIST
102509: PUSH
102510: LD_VAR 0 1
102514: PUSH
102515: LD_INT 4
102517: PLUS
102518: PUSH
102519: LD_VAR 0 2
102523: PUSH
102524: LD_INT 4
102526: PLUS
102527: PUSH
102528: LD_INT 5
102530: PUSH
102531: EMPTY
102532: LIST
102533: LIST
102534: LIST
102535: PUSH
102536: LD_VAR 0 1
102540: PUSH
102541: LD_INT 3
102543: PLUS
102544: PUSH
102545: LD_VAR 0 2
102549: PUSH
102550: LD_INT 4
102552: PUSH
102553: EMPTY
102554: LIST
102555: LIST
102556: LIST
102557: PUSH
102558: LD_VAR 0 1
102562: PUSH
102563: LD_VAR 0 2
102567: PUSH
102568: LD_INT 3
102570: PLUS
102571: PUSH
102572: LD_INT 0
102574: PUSH
102575: EMPTY
102576: LIST
102577: LIST
102578: LIST
102579: PUSH
102580: EMPTY
102581: LIST
102582: LIST
102583: LIST
102584: LIST
102585: LIST
102586: ST_TO_ADDR
// end ; end ;
102587: GO 102590
102589: POP
// result := list ;
102590: LD_ADDR_VAR 0 4
102594: PUSH
102595: LD_VAR 0 5
102599: ST_TO_ADDR
// end ;
102600: LD_VAR 0 4
102604: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
102605: LD_INT 0
102607: PPUSH
102608: PPUSH
102609: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
102610: LD_VAR 0 1
102614: NOT
102615: PUSH
102616: LD_VAR 0 2
102620: PUSH
102621: LD_INT 1
102623: PUSH
102624: LD_INT 2
102626: PUSH
102627: LD_INT 3
102629: PUSH
102630: LD_INT 4
102632: PUSH
102633: EMPTY
102634: LIST
102635: LIST
102636: LIST
102637: LIST
102638: IN
102639: NOT
102640: OR
102641: IFFALSE 102645
// exit ;
102643: GO 102737
// tmp := [ ] ;
102645: LD_ADDR_VAR 0 5
102649: PUSH
102650: EMPTY
102651: ST_TO_ADDR
// for i in units do
102652: LD_ADDR_VAR 0 4
102656: PUSH
102657: LD_VAR 0 1
102661: PUSH
102662: FOR_IN
102663: IFFALSE 102706
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
102665: LD_ADDR_VAR 0 5
102669: PUSH
102670: LD_VAR 0 5
102674: PPUSH
102675: LD_VAR 0 5
102679: PUSH
102680: LD_INT 1
102682: PLUS
102683: PPUSH
102684: LD_VAR 0 4
102688: PPUSH
102689: LD_VAR 0 2
102693: PPUSH
102694: CALL_OW 259
102698: PPUSH
102699: CALL_OW 2
102703: ST_TO_ADDR
102704: GO 102662
102706: POP
102707: POP
// if not tmp then
102708: LD_VAR 0 5
102712: NOT
102713: IFFALSE 102717
// exit ;
102715: GO 102737
// result := SortListByListDesc ( units , tmp ) ;
102717: LD_ADDR_VAR 0 3
102721: PUSH
102722: LD_VAR 0 1
102726: PPUSH
102727: LD_VAR 0 5
102731: PPUSH
102732: CALL_OW 77
102736: ST_TO_ADDR
// end ;
102737: LD_VAR 0 3
102741: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
102742: LD_INT 0
102744: PPUSH
102745: PPUSH
102746: PPUSH
// x := GetX ( building ) ;
102747: LD_ADDR_VAR 0 4
102751: PUSH
102752: LD_VAR 0 2
102756: PPUSH
102757: CALL_OW 250
102761: ST_TO_ADDR
// y := GetY ( building ) ;
102762: LD_ADDR_VAR 0 5
102766: PUSH
102767: LD_VAR 0 2
102771: PPUSH
102772: CALL_OW 251
102776: ST_TO_ADDR
// if GetTaskList ( unit ) then
102777: LD_VAR 0 1
102781: PPUSH
102782: CALL_OW 437
102786: IFFALSE 102881
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102788: LD_STRING e
102790: PUSH
102791: LD_VAR 0 1
102795: PPUSH
102796: CALL_OW 437
102800: PUSH
102801: LD_INT 1
102803: ARRAY
102804: PUSH
102805: LD_INT 1
102807: ARRAY
102808: EQUAL
102809: PUSH
102810: LD_VAR 0 4
102814: PUSH
102815: LD_VAR 0 1
102819: PPUSH
102820: CALL_OW 437
102824: PUSH
102825: LD_INT 1
102827: ARRAY
102828: PUSH
102829: LD_INT 2
102831: ARRAY
102832: EQUAL
102833: AND
102834: PUSH
102835: LD_VAR 0 5
102839: PUSH
102840: LD_VAR 0 1
102844: PPUSH
102845: CALL_OW 437
102849: PUSH
102850: LD_INT 1
102852: ARRAY
102853: PUSH
102854: LD_INT 3
102856: ARRAY
102857: EQUAL
102858: AND
102859: IFFALSE 102871
// result := true else
102861: LD_ADDR_VAR 0 3
102865: PUSH
102866: LD_INT 1
102868: ST_TO_ADDR
102869: GO 102879
// result := false ;
102871: LD_ADDR_VAR 0 3
102875: PUSH
102876: LD_INT 0
102878: ST_TO_ADDR
// end else
102879: GO 102889
// result := false ;
102881: LD_ADDR_VAR 0 3
102885: PUSH
102886: LD_INT 0
102888: ST_TO_ADDR
// end ;
102889: LD_VAR 0 3
102893: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
102894: LD_INT 0
102896: PPUSH
102897: PPUSH
102898: PPUSH
102899: PPUSH
// if not unit or not area then
102900: LD_VAR 0 1
102904: NOT
102905: PUSH
102906: LD_VAR 0 2
102910: NOT
102911: OR
102912: IFFALSE 102916
// exit ;
102914: GO 103081
// tmp := AreaToList ( area , i ) ;
102916: LD_ADDR_VAR 0 6
102920: PUSH
102921: LD_VAR 0 2
102925: PPUSH
102926: LD_VAR 0 5
102930: PPUSH
102931: CALL_OW 517
102935: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
102936: LD_ADDR_VAR 0 5
102940: PUSH
102941: DOUBLE
102942: LD_INT 1
102944: DEC
102945: ST_TO_ADDR
102946: LD_VAR 0 6
102950: PUSH
102951: LD_INT 1
102953: ARRAY
102954: PUSH
102955: FOR_TO
102956: IFFALSE 103071
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
102958: LD_ADDR_VAR 0 7
102962: PUSH
102963: LD_VAR 0 6
102967: PUSH
102968: LD_INT 1
102970: ARRAY
102971: PUSH
102972: LD_VAR 0 5
102976: ARRAY
102977: PUSH
102978: LD_VAR 0 6
102982: PUSH
102983: LD_INT 2
102985: ARRAY
102986: PUSH
102987: LD_VAR 0 5
102991: ARRAY
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
102997: LD_VAR 0 7
103001: PUSH
103002: LD_INT 1
103004: ARRAY
103005: PPUSH
103006: LD_VAR 0 7
103010: PUSH
103011: LD_INT 2
103013: ARRAY
103014: PPUSH
103015: CALL_OW 428
103019: PUSH
103020: LD_INT 0
103022: EQUAL
103023: IFFALSE 103069
// begin result := true ;
103025: LD_ADDR_VAR 0 4
103029: PUSH
103030: LD_INT 1
103032: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103033: LD_VAR 0 1
103037: PPUSH
103038: LD_VAR 0 7
103042: PUSH
103043: LD_INT 1
103045: ARRAY
103046: PPUSH
103047: LD_VAR 0 7
103051: PUSH
103052: LD_INT 2
103054: ARRAY
103055: PPUSH
103056: LD_VAR 0 3
103060: PPUSH
103061: CALL_OW 48
// exit ;
103065: POP
103066: POP
103067: GO 103081
// end ; end ;
103069: GO 102955
103071: POP
103072: POP
// result := false ;
103073: LD_ADDR_VAR 0 4
103077: PUSH
103078: LD_INT 0
103080: ST_TO_ADDR
// end ;
103081: LD_VAR 0 4
103085: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103086: LD_INT 0
103088: PPUSH
103089: PPUSH
103090: PPUSH
// if not side or side > 8 then
103091: LD_VAR 0 1
103095: NOT
103096: PUSH
103097: LD_VAR 0 1
103101: PUSH
103102: LD_INT 8
103104: GREATER
103105: OR
103106: IFFALSE 103110
// exit ;
103108: GO 103297
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103110: LD_ADDR_VAR 0 4
103114: PUSH
103115: LD_INT 22
103117: PUSH
103118: LD_VAR 0 1
103122: PUSH
103123: EMPTY
103124: LIST
103125: LIST
103126: PUSH
103127: LD_INT 21
103129: PUSH
103130: LD_INT 3
103132: PUSH
103133: EMPTY
103134: LIST
103135: LIST
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: PPUSH
103141: CALL_OW 69
103145: ST_TO_ADDR
// if not tmp then
103146: LD_VAR 0 4
103150: NOT
103151: IFFALSE 103155
// exit ;
103153: GO 103297
// enable_addtolog := true ;
103155: LD_ADDR_OWVAR 81
103159: PUSH
103160: LD_INT 1
103162: ST_TO_ADDR
// AddToLog ( [ ) ;
103163: LD_STRING [
103165: PPUSH
103166: CALL_OW 561
// for i in tmp do
103170: LD_ADDR_VAR 0 3
103174: PUSH
103175: LD_VAR 0 4
103179: PUSH
103180: FOR_IN
103181: IFFALSE 103288
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103183: LD_STRING [
103185: PUSH
103186: LD_VAR 0 3
103190: PPUSH
103191: CALL_OW 266
103195: STR
103196: PUSH
103197: LD_STRING , 
103199: STR
103200: PUSH
103201: LD_VAR 0 3
103205: PPUSH
103206: CALL_OW 250
103210: STR
103211: PUSH
103212: LD_STRING , 
103214: STR
103215: PUSH
103216: LD_VAR 0 3
103220: PPUSH
103221: CALL_OW 251
103225: STR
103226: PUSH
103227: LD_STRING , 
103229: STR
103230: PUSH
103231: LD_VAR 0 3
103235: PPUSH
103236: CALL_OW 254
103240: STR
103241: PUSH
103242: LD_STRING , 
103244: STR
103245: PUSH
103246: LD_VAR 0 3
103250: PPUSH
103251: LD_INT 1
103253: PPUSH
103254: CALL_OW 268
103258: STR
103259: PUSH
103260: LD_STRING , 
103262: STR
103263: PUSH
103264: LD_VAR 0 3
103268: PPUSH
103269: LD_INT 2
103271: PPUSH
103272: CALL_OW 268
103276: STR
103277: PUSH
103278: LD_STRING ],
103280: STR
103281: PPUSH
103282: CALL_OW 561
// end ;
103286: GO 103180
103288: POP
103289: POP
// AddToLog ( ]; ) ;
103290: LD_STRING ];
103292: PPUSH
103293: CALL_OW 561
// end ;
103297: LD_VAR 0 2
103301: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
103302: LD_INT 0
103304: PPUSH
103305: PPUSH
103306: PPUSH
103307: PPUSH
103308: PPUSH
// if not area or not rate or not max then
103309: LD_VAR 0 1
103313: NOT
103314: PUSH
103315: LD_VAR 0 2
103319: NOT
103320: OR
103321: PUSH
103322: LD_VAR 0 4
103326: NOT
103327: OR
103328: IFFALSE 103332
// exit ;
103330: GO 103524
// while 1 do
103332: LD_INT 1
103334: IFFALSE 103524
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
103336: LD_ADDR_VAR 0 9
103340: PUSH
103341: LD_VAR 0 1
103345: PPUSH
103346: LD_INT 1
103348: PPUSH
103349: CALL_OW 287
103353: PUSH
103354: LD_INT 10
103356: MUL
103357: ST_TO_ADDR
// r := rate / 10 ;
103358: LD_ADDR_VAR 0 7
103362: PUSH
103363: LD_VAR 0 2
103367: PUSH
103368: LD_INT 10
103370: DIVREAL
103371: ST_TO_ADDR
// time := 1 1$00 ;
103372: LD_ADDR_VAR 0 8
103376: PUSH
103377: LD_INT 2100
103379: ST_TO_ADDR
// if amount < min then
103380: LD_VAR 0 9
103384: PUSH
103385: LD_VAR 0 3
103389: LESS
103390: IFFALSE 103408
// r := r * 2 else
103392: LD_ADDR_VAR 0 7
103396: PUSH
103397: LD_VAR 0 7
103401: PUSH
103402: LD_INT 2
103404: MUL
103405: ST_TO_ADDR
103406: GO 103434
// if amount > max then
103408: LD_VAR 0 9
103412: PUSH
103413: LD_VAR 0 4
103417: GREATER
103418: IFFALSE 103434
// r := r / 2 ;
103420: LD_ADDR_VAR 0 7
103424: PUSH
103425: LD_VAR 0 7
103429: PUSH
103430: LD_INT 2
103432: DIVREAL
103433: ST_TO_ADDR
// time := time / r ;
103434: LD_ADDR_VAR 0 8
103438: PUSH
103439: LD_VAR 0 8
103443: PUSH
103444: LD_VAR 0 7
103448: DIVREAL
103449: ST_TO_ADDR
// if time < 0 then
103450: LD_VAR 0 8
103454: PUSH
103455: LD_INT 0
103457: LESS
103458: IFFALSE 103475
// time := time * - 1 ;
103460: LD_ADDR_VAR 0 8
103464: PUSH
103465: LD_VAR 0 8
103469: PUSH
103470: LD_INT 1
103472: NEG
103473: MUL
103474: ST_TO_ADDR
// wait ( time ) ;
103475: LD_VAR 0 8
103479: PPUSH
103480: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
103484: LD_INT 35
103486: PPUSH
103487: LD_INT 875
103489: PPUSH
103490: CALL_OW 12
103494: PPUSH
103495: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
103499: LD_INT 1
103501: PPUSH
103502: LD_INT 5
103504: PPUSH
103505: CALL_OW 12
103509: PPUSH
103510: LD_VAR 0 1
103514: PPUSH
103515: LD_INT 1
103517: PPUSH
103518: CALL_OW 55
// end ;
103522: GO 103332
// end ;
103524: LD_VAR 0 5
103528: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
103529: LD_INT 0
103531: PPUSH
103532: PPUSH
103533: PPUSH
103534: PPUSH
103535: PPUSH
103536: PPUSH
103537: PPUSH
103538: PPUSH
// if not turrets or not factories then
103539: LD_VAR 0 1
103543: NOT
103544: PUSH
103545: LD_VAR 0 2
103549: NOT
103550: OR
103551: IFFALSE 103555
// exit ;
103553: GO 103862
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
103555: LD_ADDR_VAR 0 10
103559: PUSH
103560: LD_INT 5
103562: PUSH
103563: LD_INT 6
103565: PUSH
103566: EMPTY
103567: LIST
103568: LIST
103569: PUSH
103570: LD_INT 2
103572: PUSH
103573: LD_INT 4
103575: PUSH
103576: EMPTY
103577: LIST
103578: LIST
103579: PUSH
103580: LD_INT 3
103582: PUSH
103583: LD_INT 5
103585: PUSH
103586: EMPTY
103587: LIST
103588: LIST
103589: PUSH
103590: EMPTY
103591: LIST
103592: LIST
103593: LIST
103594: PUSH
103595: LD_INT 24
103597: PUSH
103598: LD_INT 25
103600: PUSH
103601: EMPTY
103602: LIST
103603: LIST
103604: PUSH
103605: LD_INT 23
103607: PUSH
103608: LD_INT 27
103610: PUSH
103611: EMPTY
103612: LIST
103613: LIST
103614: PUSH
103615: EMPTY
103616: LIST
103617: LIST
103618: PUSH
103619: LD_INT 42
103621: PUSH
103622: LD_INT 43
103624: PUSH
103625: EMPTY
103626: LIST
103627: LIST
103628: PUSH
103629: LD_INT 44
103631: PUSH
103632: LD_INT 46
103634: PUSH
103635: EMPTY
103636: LIST
103637: LIST
103638: PUSH
103639: LD_INT 45
103641: PUSH
103642: LD_INT 47
103644: PUSH
103645: EMPTY
103646: LIST
103647: LIST
103648: PUSH
103649: EMPTY
103650: LIST
103651: LIST
103652: LIST
103653: PUSH
103654: EMPTY
103655: LIST
103656: LIST
103657: LIST
103658: ST_TO_ADDR
// result := [ ] ;
103659: LD_ADDR_VAR 0 3
103663: PUSH
103664: EMPTY
103665: ST_TO_ADDR
// for i in turrets do
103666: LD_ADDR_VAR 0 4
103670: PUSH
103671: LD_VAR 0 1
103675: PUSH
103676: FOR_IN
103677: IFFALSE 103860
// begin nat := GetNation ( i ) ;
103679: LD_ADDR_VAR 0 7
103683: PUSH
103684: LD_VAR 0 4
103688: PPUSH
103689: CALL_OW 248
103693: ST_TO_ADDR
// weapon := 0 ;
103694: LD_ADDR_VAR 0 8
103698: PUSH
103699: LD_INT 0
103701: ST_TO_ADDR
// if not nat then
103702: LD_VAR 0 7
103706: NOT
103707: IFFALSE 103711
// continue ;
103709: GO 103676
// for j in list [ nat ] do
103711: LD_ADDR_VAR 0 5
103715: PUSH
103716: LD_VAR 0 10
103720: PUSH
103721: LD_VAR 0 7
103725: ARRAY
103726: PUSH
103727: FOR_IN
103728: IFFALSE 103769
// if GetBWeapon ( i ) = j [ 1 ] then
103730: LD_VAR 0 4
103734: PPUSH
103735: CALL_OW 269
103739: PUSH
103740: LD_VAR 0 5
103744: PUSH
103745: LD_INT 1
103747: ARRAY
103748: EQUAL
103749: IFFALSE 103767
// begin weapon := j [ 2 ] ;
103751: LD_ADDR_VAR 0 8
103755: PUSH
103756: LD_VAR 0 5
103760: PUSH
103761: LD_INT 2
103763: ARRAY
103764: ST_TO_ADDR
// break ;
103765: GO 103769
// end ;
103767: GO 103727
103769: POP
103770: POP
// if not weapon then
103771: LD_VAR 0 8
103775: NOT
103776: IFFALSE 103780
// continue ;
103778: GO 103676
// for k in factories do
103780: LD_ADDR_VAR 0 6
103784: PUSH
103785: LD_VAR 0 2
103789: PUSH
103790: FOR_IN
103791: IFFALSE 103856
// begin weapons := AvailableWeaponList ( k ) ;
103793: LD_ADDR_VAR 0 9
103797: PUSH
103798: LD_VAR 0 6
103802: PPUSH
103803: CALL_OW 478
103807: ST_TO_ADDR
// if not weapons then
103808: LD_VAR 0 9
103812: NOT
103813: IFFALSE 103817
// continue ;
103815: GO 103790
// if weapon in weapons then
103817: LD_VAR 0 8
103821: PUSH
103822: LD_VAR 0 9
103826: IN
103827: IFFALSE 103854
// begin result := [ i , weapon ] ;
103829: LD_ADDR_VAR 0 3
103833: PUSH
103834: LD_VAR 0 4
103838: PUSH
103839: LD_VAR 0 8
103843: PUSH
103844: EMPTY
103845: LIST
103846: LIST
103847: ST_TO_ADDR
// exit ;
103848: POP
103849: POP
103850: POP
103851: POP
103852: GO 103862
// end ; end ;
103854: GO 103790
103856: POP
103857: POP
// end ;
103858: GO 103676
103860: POP
103861: POP
// end ;
103862: LD_VAR 0 3
103866: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
103867: LD_INT 0
103869: PPUSH
// if not side or side > 8 then
103870: LD_VAR 0 3
103874: NOT
103875: PUSH
103876: LD_VAR 0 3
103880: PUSH
103881: LD_INT 8
103883: GREATER
103884: OR
103885: IFFALSE 103889
// exit ;
103887: GO 103948
// if not range then
103889: LD_VAR 0 4
103893: NOT
103894: IFFALSE 103905
// range := - 12 ;
103896: LD_ADDR_VAR 0 4
103900: PUSH
103901: LD_INT 12
103903: NEG
103904: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
103905: LD_VAR 0 1
103909: PPUSH
103910: LD_VAR 0 2
103914: PPUSH
103915: LD_VAR 0 3
103919: PPUSH
103920: LD_VAR 0 4
103924: PPUSH
103925: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
103929: LD_VAR 0 1
103933: PPUSH
103934: LD_VAR 0 2
103938: PPUSH
103939: LD_VAR 0 3
103943: PPUSH
103944: CALL_OW 331
// end ;
103948: LD_VAR 0 5
103952: RET
// export function Video ( mode ) ; begin
103953: LD_INT 0
103955: PPUSH
// ingame_video = mode ;
103956: LD_ADDR_OWVAR 52
103960: PUSH
103961: LD_VAR 0 1
103965: ST_TO_ADDR
// interface_hidden = mode ;
103966: LD_ADDR_OWVAR 54
103970: PUSH
103971: LD_VAR 0 1
103975: ST_TO_ADDR
// end ;
103976: LD_VAR 0 2
103980: RET
// export function Join ( array , element ) ; begin
103981: LD_INT 0
103983: PPUSH
// result := array ^ element ;
103984: LD_ADDR_VAR 0 3
103988: PUSH
103989: LD_VAR 0 1
103993: PUSH
103994: LD_VAR 0 2
103998: ADD
103999: ST_TO_ADDR
// end ;
104000: LD_VAR 0 3
104004: RET
// export function JoinUnion ( array , element ) ; begin
104005: LD_INT 0
104007: PPUSH
// result := array union element ;
104008: LD_ADDR_VAR 0 3
104012: PUSH
104013: LD_VAR 0 1
104017: PUSH
104018: LD_VAR 0 2
104022: UNION
104023: ST_TO_ADDR
// end ;
104024: LD_VAR 0 3
104028: RET
// export function GetBehemoths ( side ) ; begin
104029: LD_INT 0
104031: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
104032: LD_ADDR_VAR 0 2
104036: PUSH
104037: LD_INT 22
104039: PUSH
104040: LD_VAR 0 1
104044: PUSH
104045: EMPTY
104046: LIST
104047: LIST
104048: PUSH
104049: LD_INT 31
104051: PUSH
104052: LD_INT 25
104054: PUSH
104055: EMPTY
104056: LIST
104057: LIST
104058: PUSH
104059: EMPTY
104060: LIST
104061: LIST
104062: PPUSH
104063: CALL_OW 69
104067: ST_TO_ADDR
// end ;
104068: LD_VAR 0 2
104072: RET
// export function Shuffle ( array ) ; var i , index ; begin
104073: LD_INT 0
104075: PPUSH
104076: PPUSH
104077: PPUSH
// result := [ ] ;
104078: LD_ADDR_VAR 0 2
104082: PUSH
104083: EMPTY
104084: ST_TO_ADDR
// if not array then
104085: LD_VAR 0 1
104089: NOT
104090: IFFALSE 104094
// exit ;
104092: GO 104193
// Randomize ;
104094: CALL_OW 10
// for i = array downto 1 do
104098: LD_ADDR_VAR 0 3
104102: PUSH
104103: DOUBLE
104104: LD_VAR 0 1
104108: INC
104109: ST_TO_ADDR
104110: LD_INT 1
104112: PUSH
104113: FOR_DOWNTO
104114: IFFALSE 104191
// begin index := rand ( 1 , array ) ;
104116: LD_ADDR_VAR 0 4
104120: PUSH
104121: LD_INT 1
104123: PPUSH
104124: LD_VAR 0 1
104128: PPUSH
104129: CALL_OW 12
104133: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104134: LD_ADDR_VAR 0 2
104138: PUSH
104139: LD_VAR 0 2
104143: PPUSH
104144: LD_VAR 0 2
104148: PUSH
104149: LD_INT 1
104151: PLUS
104152: PPUSH
104153: LD_VAR 0 1
104157: PUSH
104158: LD_VAR 0 4
104162: ARRAY
104163: PPUSH
104164: CALL_OW 2
104168: ST_TO_ADDR
// array := Delete ( array , index ) ;
104169: LD_ADDR_VAR 0 1
104173: PUSH
104174: LD_VAR 0 1
104178: PPUSH
104179: LD_VAR 0 4
104183: PPUSH
104184: CALL_OW 3
104188: ST_TO_ADDR
// end ;
104189: GO 104113
104191: POP
104192: POP
// end ;
104193: LD_VAR 0 2
104197: RET
