// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 58 0 0
// InitMacro ;
   8: CALL 32762 0 0
// InitNature ;
  12: CALL 32586 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// PrepareAlliance ;
  29: CALL 10280 0 0
// PrepareRussian ;
  33: CALL 6462 0 0
// PrepareLegion ;
  37: CALL 3914 0 0
// PreparePowell ;
  41: CALL 2668 0 0
// PrepareAmerican ;
  45: CALL 1491 0 0
// Action ;
  49: CALL 14077 0 0
// MC_Start ( ) ;
  53: CALL 33909 0 0
// end ;
  57: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  58: LD_INT 0
  60: PPUSH
// debug := false ;
  61: LD_ADDR_EXP 1
  65: PUSH
  66: LD_INT 0
  68: ST_TO_ADDR
// missionStart := false ;
  69: LD_ADDR_EXP 13
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// missionTime := 0 0$00 ;
  77: LD_ADDR_EXP 14
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// missionStage := 1 ;
  85: LD_ADDR_EXP 15
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// activeAttacks := false ;
  93: LD_ADDR_EXP 16
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// powellAnger := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// powellAllowRetreat := true ;
 109: LD_ADDR_EXP 19
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// powellCenterCameraMode := false ;
 117: LD_ADDR_EXP 20
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 125: LD_ADDR_EXP 18
 129: PUSH
 130: EMPTY
 131: PUSH
 132: EMPTY
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// russianDestroyed := false ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// legionDestroyed := false ;
 146: LD_ADDR_EXP 22
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// allianceDestroyed := false ;
 154: LD_ADDR_EXP 23
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 2
 166: PUSH
 167: LD_STRING 14_KappaStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 3
 182: PUSH
 183: LD_STRING 06_KurtStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 194: LD_ADDR_EXP 4
 198: PUSH
 199: LD_STRING 14_JMMVeh_1
 201: PPUSH
 202: LD_INT 0
 204: PPUSH
 205: CALL_OW 30
 209: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 210: LD_ADDR_EXP 5
 214: PUSH
 215: LD_STRING 14_JMMGirlVeh_1
 217: PPUSH
 218: LD_INT 0
 220: PPUSH
 221: CALL_OW 30
 225: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 226: LD_ADDR_EXP 7
 230: PUSH
 231: LD_STRING 14_JMMGirl_1
 233: PPUSH
 234: LD_INT 0
 236: PPUSH
 237: CALL_OW 30
 241: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 242: LD_ADDR_EXP 6
 246: PUSH
 247: LD_STRING 14_JMMGirlStatus_1
 249: PPUSH
 250: LD_INT 0
 252: PPUSH
 253: CALL_OW 30
 257: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 258: LD_ADDR_EXP 8
 262: PUSH
 263: LD_STRING 10_KhatamStatus_1
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 30
 273: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 274: LD_ADDR_EXP 9
 278: PUSH
 279: LD_STRING 13_BurlakStatus_1
 281: PPUSH
 282: LD_INT 0
 284: PPUSH
 285: CALL_OW 30
 289: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 290: LD_ADDR_EXP 10
 294: PUSH
 295: LD_STRING 13_StevensStatus_1
 297: PPUSH
 298: LD_INT 0
 300: PPUSH
 301: CALL_OW 30
 305: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 306: LD_ADDR_EXP 11
 310: PUSH
 311: LD_STRING 14_FastEnd_1
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: CALL_OW 30
 321: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 322: LD_ADDR_EXP 12
 326: PUSH
 327: LD_STRING 12_MainDepositFake_1
 329: PPUSH
 330: LD_INT 0
 332: PPUSH
 333: CALL_OW 30
 337: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 338: LD_ADDR_EXP 24
 342: PUSH
 343: LD_INT 1
 345: ST_TO_ADDR
// behemothUnderConstruct := false ;
 346: LD_ADDR_EXP 26
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 354: LD_ADDR_EXP 27
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// behemothDone := false ;
 362: LD_ADDR_EXP 28
 366: PUSH
 367: LD_INT 0
 369: ST_TO_ADDR
// allowBehemothConstruct := false ;
 370: LD_ADDR_EXP 25
 374: PUSH
 375: LD_INT 0
 377: ST_TO_ADDR
// seeBehemoth := false ;
 378: LD_ADDR_EXP 29
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// platonovHasBomb := false ;
 386: LD_ADDR_EXP 30
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// allianceActive := false ;
 394: LD_ADDR_EXP 31
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// rothCaptured := false ;
 402: LD_ADDR_EXP 33
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// lostCounter := 0 ;
 410: LD_ADDR_EXP 32
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// capturedUnit := [ ] ;
 418: LD_ADDR_EXP 34
 422: PUSH
 423: EMPTY
 424: ST_TO_ADDR
// trueAmericans := [ ] ;
 425: LD_ADDR_EXP 35
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// end ;
 432: LD_VAR 0 1
 436: RET
// export function CustomInitMacro ( ) ; begin
 437: LD_INT 0
 439: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 440: LD_ADDR_EXP 123
 444: PUSH
 445: LD_INT 2
 447: PUSH
 448: LD_INT 3
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 10
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 463: LD_ADDR_EXP 124
 467: PUSH
 468: LD_INT 1
 470: PUSH
 471: LD_INT 4
 473: PUSH
 474: LD_INT 5
 476: PUSH
 477: LD_INT 9
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 486: LD_INT 1
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: PPUSH
 503: CALL 55765 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 507: LD_INT 1
 509: PPUSH
 510: LD_INT 17
 512: PUSH
 513: EMPTY
 514: LIST
 515: PPUSH
 516: CALL 55858 0 2
// MC_SetTame ( 1 , allianceCratesArea ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 17
 525: PPUSH
 526: CALL 55589 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 530: LD_INT 2
 532: PPUSH
 533: LD_INT 10
 535: PUSH
 536: LD_INT 11
 538: PUSH
 539: LD_INT 12
 541: PUSH
 542: LD_INT 14
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL 55765 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 555: LD_INT 2
 557: PPUSH
 558: LD_INT 16
 560: PUSH
 561: EMPTY
 562: LIST
 563: PPUSH
 564: CALL 55858 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 568: LD_INT 2
 570: PPUSH
 571: LD_INT 21
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 51
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: PUSH
 589: LD_INT 24
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 47
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 24
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 47
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 24
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: LIST
 686: PPUSH
 687: CALL 55028 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 691: LD_INT 2
 693: PPUSH
 694: LD_INT 5
 696: PPUSH
 697: CALL 55271 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 0
 706: PPUSH
 707: CALL 55638 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 711: LD_INT 3
 713: PPUSH
 714: LD_INT 10
 716: PUSH
 717: LD_INT 12
 719: PUSH
 720: LD_INT 15
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: PUSH
 728: LD_OWVAR 67
 732: ARRAY
 733: PPUSH
 734: LD_INT 27
 736: PPUSH
 737: CALL 54710 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 741: LD_INT 3
 743: PPUSH
 744: LD_INT 10
 746: PUSH
 747: LD_INT 11
 749: PUSH
 750: LD_INT 13
 752: PUSH
 753: LD_INT 15
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: LIST
 761: PPUSH
 762: CALL 55765 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 766: LD_INT 3
 768: PPUSH
 769: LD_INT 15
 771: PUSH
 772: EMPTY
 773: LIST
 774: PPUSH
 775: CALL 55858 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 779: LD_ADDR_EXP 128
 783: PUSH
 784: LD_EXP 128
 788: PPUSH
 789: LD_INT 3
 791: PPUSH
 792: LD_INT 22
 794: PUSH
 795: LD_INT 8
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: PUSH
 802: LD_INT 25
 804: PUSH
 805: LD_INT 15
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: PUSH
 812: EMPTY
 813: LIST
 814: LIST
 815: PPUSH
 816: CALL_OW 69
 820: PPUSH
 821: CALL_OW 1
 825: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: LD_INT 2
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: LD_INT 31
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: LIST
 845: LIST
 846: PUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 3
 870: PUSH
 871: LD_INT 2
 873: PUSH
 874: LD_INT 32
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: LIST
 887: PPUSH
 888: CALL 55028 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 892: LD_INT 4
 894: PPUSH
 895: LD_INT 10
 897: PUSH
 898: LD_INT 12
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PPUSH
 905: CALL 55765 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 909: LD_INT 4
 911: PPUSH
 912: LD_INT 9
 914: PUSH
 915: EMPTY
 916: LIST
 917: PPUSH
 918: CALL 55858 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
 922: LD_INT 4
 924: PPUSH
 925: LD_INT 26
 927: PUSH
 928: LD_INT 74
 930: PUSH
 931: LD_INT 107
 933: PUSH
 934: LD_INT 0
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 32
 945: PUSH
 946: LD_INT 77
 948: PUSH
 949: LD_INT 101
 951: PUSH
 952: LD_INT 4
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 32
 963: PUSH
 964: LD_INT 69
 966: PUSH
 967: LD_INT 86
 969: PUSH
 970: LD_INT 4
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 27
 981: PUSH
 982: LD_INT 77
 984: PUSH
 985: LD_INT 110
 987: PUSH
 988: LD_INT 3
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 27
 999: PUSH
1000: LD_INT 42
1002: PUSH
1003: LD_INT 79
1005: PUSH
1006: LD_INT 5
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 29
1017: PUSH
1018: LD_INT 86
1020: PUSH
1021: LD_INT 105
1023: PUSH
1024: LD_INT 2
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_INT 30
1035: PUSH
1036: LD_INT 40
1038: PUSH
1039: LD_INT 75
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PUSH
1051: LD_INT 32
1053: PUSH
1054: LD_INT 80
1056: PUSH
1057: LD_INT 106
1059: PUSH
1060: LD_INT 4
1062: PUSH
1063: EMPTY
1064: LIST
1065: LIST
1066: LIST
1067: LIST
1068: PUSH
1069: LD_INT 32
1071: PUSH
1072: LD_INT 75
1074: PUSH
1075: LD_INT 114
1077: PUSH
1078: LD_INT 5
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: PUSH
1087: LD_INT 32
1089: PUSH
1090: LD_INT 82
1092: PUSH
1093: LD_INT 110
1095: PUSH
1096: LD_INT 5
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PUSH
1105: LD_INT 32
1107: PUSH
1108: LD_INT 62
1110: PUSH
1111: LD_INT 78
1113: PUSH
1114: LD_INT 4
1116: PUSH
1117: EMPTY
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: PUSH
1123: LD_INT 4
1125: PUSH
1126: LD_INT 39
1128: PUSH
1129: LD_INT 61
1131: PUSH
1132: LD_INT 3
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: EMPTY
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PPUSH
1155: CALL 54920 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1159: LD_INT 4
1161: PPUSH
1162: LD_INT 5
1164: PUSH
1165: LD_INT 6
1167: PUSH
1168: LD_INT 7
1170: PUSH
1171: LD_INT 9
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 56176 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 40
1189: PUSH
1190: LD_INT 75
1192: PUSH
1193: LD_INT 1
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 86
1203: PUSH
1204: LD_INT 105
1206: PUSH
1207: LD_INT 0
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL 55410 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1223: LD_INT 4
1225: PPUSH
1226: LD_INT 2
1228: PPUSH
1229: CALL 55638 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1233: LD_INT 4
1235: PPUSH
1236: LD_INT 0
1238: PPUSH
1239: CALL 55638 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1243: LD_INT 4
1245: PPUSH
1246: LD_INT 54
1248: PPUSH
1249: LD_INT 85
1251: PPUSH
1252: LD_INT 2
1254: PPUSH
1255: LD_INT 19
1257: PUSH
1258: LD_INT 16
1260: PUSH
1261: LD_INT 17
1263: PUSH
1264: LD_INT 18
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PPUSH
1273: CALL 55970 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1277: LD_INT 4
1279: PPUSH
1280: LD_INT 3
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: LD_INT 1
1288: PUSH
1289: LD_INT 5
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: PUSH
1298: LD_INT 4
1300: PUSH
1301: LD_INT 1
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 6
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: PUSH
1316: LD_INT 4
1318: PUSH
1319: LD_INT 1
1321: PUSH
1322: LD_INT 1
1324: PUSH
1325: LD_INT 7
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: PUSH
1334: LD_INT 4
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: LD_INT 1
1342: PUSH
1343: LD_INT 6
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: PPUSH
1358: CALL 55028 0 2
// MC_SetTame ( 4 , powellApe ) ;
1362: LD_INT 4
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: CALL 55589 0 2
// end ;
1372: LD_VAR 0 1
1376: RET
// every 0 0$1 trigger debug do var i , tmp ;
1377: LD_EXP 1
1381: IFFALSE 1488
1383: GO 1385
1385: DISABLE
1386: LD_INT 0
1388: PPUSH
1389: PPUSH
// begin enable ;
1390: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1391: LD_ADDR_VAR 0 2
1395: PUSH
1396: LD_INT 22
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: PUSH
1406: LD_INT 3
1408: PUSH
1409: LD_INT 21
1411: PUSH
1412: LD_INT 3
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: PUSH
1423: LD_INT 3
1425: PUSH
1426: LD_INT 24
1428: PUSH
1429: LD_INT 999
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: PUSH
1440: EMPTY
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL_OW 69
1449: ST_TO_ADDR
// if not tmp then
1450: LD_VAR 0 2
1454: NOT
1455: IFFALSE 1459
// exit ;
1457: GO 1488
// for i in tmp do
1459: LD_ADDR_VAR 0 1
1463: PUSH
1464: LD_VAR 0 2
1468: PUSH
1469: FOR_IN
1470: IFFALSE 1486
// SetLives ( i , 1000 ) ;
1472: LD_VAR 0 1
1476: PPUSH
1477: LD_INT 1000
1479: PPUSH
1480: CALL_OW 234
1484: GO 1469
1486: POP
1487: POP
// end ; end_of_file
1488: PPOPN 2
1490: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1491: LD_INT 0
1493: PPUSH
// uc_side := 1 ;
1494: LD_ADDR_OWVAR 20
1498: PUSH
1499: LD_INT 1
1501: ST_TO_ADDR
// uc_nation := 1 ;
1502: LD_ADDR_OWVAR 21
1506: PUSH
1507: LD_INT 1
1509: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1510: LD_ADDR_EXP 36
1514: PUSH
1515: LD_STRING JMM
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 14_
1526: PPUSH
1527: CALL 60971 0 3
1531: ST_TO_ADDR
// if not JMMVeh then
1532: LD_EXP 4
1536: NOT
1537: IFFALSE 1560
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1539: LD_INT 3
1541: PPUSH
1542: LD_INT 3
1544: PPUSH
1545: LD_INT 1
1547: PPUSH
1548: LD_INT 5
1550: PPUSH
1551: LD_INT 100
1553: PPUSH
1554: CALL 67604 0 5
1558: GO 1619
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1560: LD_EXP 4
1564: PUSH
1565: LD_INT 1
1567: ARRAY
1568: PUSH
1569: LD_INT 1
1571: ARRAY
1572: PPUSH
1573: LD_EXP 4
1577: PUSH
1578: LD_INT 2
1580: ARRAY
1581: PUSH
1582: LD_INT 1
1584: ARRAY
1585: PPUSH
1586: LD_EXP 4
1590: PUSH
1591: LD_INT 3
1593: ARRAY
1594: PUSH
1595: LD_INT 1
1597: ARRAY
1598: PPUSH
1599: LD_EXP 4
1603: PUSH
1604: LD_INT 4
1606: ARRAY
1607: PUSH
1608: LD_INT 1
1610: ARRAY
1611: PPUSH
1612: LD_INT 30
1614: PPUSH
1615: CALL 67604 0 5
// JMMNewVeh := CreateVehicle ;
1619: LD_ADDR_EXP 53
1623: PUSH
1624: CALL_OW 45
1628: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1629: LD_EXP 53
1633: PPUSH
1634: LD_INT 4
1636: PPUSH
1637: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1641: LD_EXP 53
1645: PPUSH
1646: LD_INT 75
1648: PPUSH
1649: LD_INT 92
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1659: LD_EXP 36
1663: PPUSH
1664: LD_EXP 53
1668: PPUSH
1669: CALL_OW 52
// if JMMGirl and not KappaStatus then
1673: LD_EXP 7
1677: PUSH
1678: LD_EXP 2
1682: NOT
1683: AND
1684: IFFALSE 1942
// begin if not JMMGirlVeh then
1686: LD_EXP 5
1690: NOT
1691: IFFALSE 1714
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1693: LD_INT 3
1695: PPUSH
1696: LD_INT 3
1698: PPUSH
1699: LD_INT 1
1701: PPUSH
1702: LD_INT 9
1704: PPUSH
1705: LD_INT 100
1707: PPUSH
1708: CALL 67604 0 5
1712: GO 1773
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1714: LD_EXP 5
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: PUSH
1723: LD_INT 1
1725: ARRAY
1726: PPUSH
1727: LD_EXP 5
1731: PUSH
1732: LD_INT 2
1734: ARRAY
1735: PUSH
1736: LD_INT 1
1738: ARRAY
1739: PPUSH
1740: LD_EXP 5
1744: PUSH
1745: LD_INT 3
1747: ARRAY
1748: PUSH
1749: LD_INT 1
1751: ARRAY
1752: PPUSH
1753: LD_EXP 5
1757: PUSH
1758: LD_INT 4
1760: ARRAY
1761: PUSH
1762: LD_INT 1
1764: ARRAY
1765: PPUSH
1766: LD_INT 30
1768: PPUSH
1769: CALL 67604 0 5
// GirlNewVeh := CreateVehicle ;
1773: LD_ADDR_EXP 54
1777: PUSH
1778: CALL_OW 45
1782: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1783: LD_EXP 54
1787: PPUSH
1788: LD_INT 4
1790: PPUSH
1791: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1795: LD_EXP 54
1799: PPUSH
1800: LD_INT 82
1802: PPUSH
1803: LD_INT 96
1805: PPUSH
1806: LD_INT 0
1808: PPUSH
1809: CALL_OW 48
// if JMMGirl = 1 then
1813: LD_EXP 7
1817: PUSH
1818: LD_INT 1
1820: EQUAL
1821: IFFALSE 1856
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1823: LD_ADDR_EXP 37
1827: PUSH
1828: LD_STRING Joan
1830: PPUSH
1831: LD_INT 1
1833: PPUSH
1834: LD_STRING 14_
1836: PPUSH
1837: CALL 60971 0 3
1841: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1842: LD_EXP 37
1846: PPUSH
1847: LD_EXP 54
1851: PPUSH
1852: CALL_OW 52
// end ; if JMMGirl = 2 then
1856: LD_EXP 7
1860: PUSH
1861: LD_INT 2
1863: EQUAL
1864: IFFALSE 1899
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1866: LD_ADDR_EXP 39
1870: PUSH
1871: LD_STRING Lisa
1873: PPUSH
1874: LD_INT 1
1876: PPUSH
1877: LD_STRING 14_
1879: PPUSH
1880: CALL 60971 0 3
1884: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1885: LD_EXP 39
1889: PPUSH
1890: LD_EXP 54
1894: PPUSH
1895: CALL_OW 52
// end ; if JMMGirl = 3 then
1899: LD_EXP 7
1903: PUSH
1904: LD_INT 3
1906: EQUAL
1907: IFFALSE 1942
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
1909: LD_ADDR_EXP 51
1913: PUSH
1914: LD_STRING Connie
1916: PPUSH
1917: LD_INT 1
1919: PPUSH
1920: LD_STRING 14_
1922: PPUSH
1923: CALL 60971 0 3
1927: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
1928: LD_EXP 51
1932: PPUSH
1933: LD_EXP 54
1937: PPUSH
1938: CALL_OW 52
// end ; end ; end ;
1942: LD_VAR 0 1
1946: RET
// export function PrepareStevensSquad ; var tmp ; begin
1947: LD_INT 0
1949: PPUSH
1950: PPUSH
// uc_side := 1 ;
1951: LD_ADDR_OWVAR 20
1955: PUSH
1956: LD_INT 1
1958: ST_TO_ADDR
// uc_nation := 1 ;
1959: LD_ADDR_OWVAR 21
1963: PUSH
1964: LD_INT 1
1966: ST_TO_ADDR
// tmp := [ ] ;
1967: LD_ADDR_VAR 0 2
1971: PUSH
1972: EMPTY
1973: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
1974: LD_ADDR_EXP 38
1978: PUSH
1979: LD_STRING Stevens
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13f_
1990: PPUSH
1991: CALL 60971 0 3
1995: ST_TO_ADDR
// if not Stevens then
1996: LD_EXP 38
2000: NOT
2001: IFFALSE 2057
// begin hc_name = Baker Smith ;
2003: LD_ADDR_OWVAR 26
2007: PUSH
2008: LD_STRING Baker Smith
2010: ST_TO_ADDR
// hc_gallery =  ;
2011: LD_ADDR_OWVAR 33
2015: PUSH
2016: LD_STRING 
2018: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2019: LD_INT 1
2021: PPUSH
2022: LD_INT 10
2024: PPUSH
2025: CALL_OW 384
// Baker = CreateHuman ;
2029: LD_ADDR_EXP 52
2033: PUSH
2034: CALL_OW 44
2038: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2039: LD_ADDR_VAR 0 2
2043: PUSH
2044: LD_VAR 0 2
2048: PUSH
2049: LD_EXP 52
2053: ADD
2054: ST_TO_ADDR
// end else
2055: GO 2073
// tmp := tmp ^ Stevens ;
2057: LD_ADDR_VAR 0 2
2061: PUSH
2062: LD_VAR 0 2
2066: PUSH
2067: LD_EXP 38
2071: ADD
2072: ST_TO_ADDR
// if not Lisa then
2073: LD_EXP 39
2077: NOT
2078: IFFALSE 2124
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2080: LD_ADDR_EXP 39
2084: PUSH
2085: LD_STRING Lisa
2087: PPUSH
2088: LD_EXP 1
2092: NOT
2093: PPUSH
2094: LD_STRING 13f_
2096: PPUSH
2097: CALL 60971 0 3
2101: ST_TO_ADDR
// if Lisa then
2102: LD_EXP 39
2106: IFFALSE 2124
// tmp := tmp ^ Lisa ;
2108: LD_ADDR_VAR 0 2
2112: PUSH
2113: LD_VAR 0 2
2117: PUSH
2118: LD_EXP 39
2122: ADD
2123: ST_TO_ADDR
// end ; if not Donaldson then
2124: LD_EXP 40
2128: NOT
2129: IFFALSE 2175
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2131: LD_ADDR_EXP 40
2135: PUSH
2136: LD_STRING Donaldson
2138: PPUSH
2139: LD_EXP 1
2143: NOT
2144: PPUSH
2145: LD_STRING 13f_
2147: PPUSH
2148: CALL 60971 0 3
2152: ST_TO_ADDR
// if Donaldson then
2153: LD_EXP 40
2157: IFFALSE 2175
// tmp := tmp ^ Donaldson ;
2159: LD_ADDR_VAR 0 2
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: LD_EXP 40
2173: ADD
2174: ST_TO_ADDR
// end ; if not Bobby then
2175: LD_EXP 41
2179: NOT
2180: IFFALSE 2226
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2182: LD_ADDR_EXP 41
2186: PUSH
2187: LD_STRING Bobby
2189: PPUSH
2190: LD_EXP 1
2194: NOT
2195: PPUSH
2196: LD_STRING 13f_
2198: PPUSH
2199: CALL 60971 0 3
2203: ST_TO_ADDR
// if Bobby then
2204: LD_EXP 41
2208: IFFALSE 2226
// tmp := tmp ^ Bobby ;
2210: LD_ADDR_VAR 0 2
2214: PUSH
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 41
2224: ADD
2225: ST_TO_ADDR
// end ; if not Cyrus then
2226: LD_EXP 42
2230: NOT
2231: IFFALSE 2277
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2233: LD_ADDR_EXP 42
2237: PUSH
2238: LD_STRING Cyrus
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13f_
2249: PPUSH
2250: CALL 60971 0 3
2254: ST_TO_ADDR
// if Cyrus then
2255: LD_EXP 42
2259: IFFALSE 2277
// tmp := tmp ^ Cyrus ;
2261: LD_ADDR_VAR 0 2
2265: PUSH
2266: LD_VAR 0 2
2270: PUSH
2271: LD_EXP 42
2275: ADD
2276: ST_TO_ADDR
// end ; if not Brown then
2277: LD_EXP 44
2281: NOT
2282: IFFALSE 2328
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2284: LD_ADDR_EXP 44
2288: PUSH
2289: LD_STRING Brown
2291: PPUSH
2292: LD_EXP 1
2296: NOT
2297: PPUSH
2298: LD_STRING 13f_
2300: PPUSH
2301: CALL 60971 0 3
2305: ST_TO_ADDR
// if Brown then
2306: LD_EXP 44
2310: IFFALSE 2328
// tmp := tmp ^ Brown ;
2312: LD_ADDR_VAR 0 2
2316: PUSH
2317: LD_VAR 0 2
2321: PUSH
2322: LD_EXP 44
2326: ADD
2327: ST_TO_ADDR
// end ; if not Gladstone then
2328: LD_EXP 45
2332: NOT
2333: IFFALSE 2379
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2335: LD_ADDR_EXP 45
2339: PUSH
2340: LD_STRING Gladstone
2342: PPUSH
2343: LD_EXP 1
2347: NOT
2348: PPUSH
2349: LD_STRING 13f_
2351: PPUSH
2352: CALL 60971 0 3
2356: ST_TO_ADDR
// if Gladstone then
2357: LD_EXP 45
2361: IFFALSE 2379
// tmp := tmp ^ Gladstone ;
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_VAR 0 2
2372: PUSH
2373: LD_EXP 45
2377: ADD
2378: ST_TO_ADDR
// end ; if not Houten then
2379: LD_EXP 46
2383: NOT
2384: IFFALSE 2430
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2386: LD_ADDR_EXP 46
2390: PUSH
2391: LD_STRING Houten
2393: PPUSH
2394: LD_EXP 1
2398: NOT
2399: PPUSH
2400: LD_STRING 13f_
2402: PPUSH
2403: CALL 60971 0 3
2407: ST_TO_ADDR
// if Houten then
2408: LD_EXP 46
2412: IFFALSE 2430
// tmp := tmp ^ Houten ;
2414: LD_ADDR_VAR 0 2
2418: PUSH
2419: LD_VAR 0 2
2423: PUSH
2424: LD_EXP 46
2428: ADD
2429: ST_TO_ADDR
// end ; if not Cornel then
2430: LD_EXP 47
2434: NOT
2435: IFFALSE 2481
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2437: LD_ADDR_EXP 47
2441: PUSH
2442: LD_STRING Cornel
2444: PPUSH
2445: LD_EXP 1
2449: NOT
2450: PPUSH
2451: LD_STRING 13f_
2453: PPUSH
2454: CALL 60971 0 3
2458: ST_TO_ADDR
// if Cornel then
2459: LD_EXP 47
2463: IFFALSE 2481
// tmp := tmp ^ Cornel ;
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: LD_EXP 47
2479: ADD
2480: ST_TO_ADDR
// end ; if not Gary then
2481: LD_EXP 48
2485: NOT
2486: IFFALSE 2532
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2488: LD_ADDR_EXP 48
2492: PUSH
2493: LD_STRING Gary
2495: PPUSH
2496: LD_EXP 1
2500: NOT
2501: PPUSH
2502: LD_STRING 13f_
2504: PPUSH
2505: CALL 60971 0 3
2509: ST_TO_ADDR
// if Gary then
2510: LD_EXP 48
2514: IFFALSE 2532
// tmp := tmp ^ Gary ;
2516: LD_ADDR_VAR 0 2
2520: PUSH
2521: LD_VAR 0 2
2525: PUSH
2526: LD_EXP 48
2530: ADD
2531: ST_TO_ADDR
// end ; if not Frank then
2532: LD_EXP 49
2536: NOT
2537: IFFALSE 2583
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2539: LD_ADDR_EXP 49
2543: PUSH
2544: LD_STRING Frank
2546: PPUSH
2547: LD_EXP 1
2551: NOT
2552: PPUSH
2553: LD_STRING 13f_
2555: PPUSH
2556: CALL 60971 0 3
2560: ST_TO_ADDR
// if Frank then
2561: LD_EXP 49
2565: IFFALSE 2583
// tmp := tmp ^ Frank ;
2567: LD_ADDR_VAR 0 2
2571: PUSH
2572: LD_VAR 0 2
2576: PUSH
2577: LD_EXP 49
2581: ADD
2582: ST_TO_ADDR
// end ; if not Kikuchi then
2583: LD_EXP 50
2587: NOT
2588: IFFALSE 2634
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2590: LD_ADDR_EXP 50
2594: PUSH
2595: LD_STRING Kikuchi
2597: PPUSH
2598: LD_EXP 1
2602: NOT
2603: PPUSH
2604: LD_STRING 13f_
2606: PPUSH
2607: CALL 60971 0 3
2611: ST_TO_ADDR
// if Kikuchi then
2612: LD_EXP 50
2616: IFFALSE 2634
// tmp := tmp ^ Kikuchi ;
2618: LD_ADDR_VAR 0 2
2622: PUSH
2623: LD_VAR 0 2
2627: PUSH
2628: LD_EXP 50
2632: ADD
2633: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2634: LD_ADDR_VAR 0 2
2638: PUSH
2639: LD_VAR 0 2
2643: PUSH
2644: LD_STRING 13_other_survivors
2646: PPUSH
2647: CALL_OW 31
2651: UNION
2652: ST_TO_ADDR
// result := tmp ;
2653: LD_ADDR_VAR 0 1
2657: PUSH
2658: LD_VAR 0 2
2662: ST_TO_ADDR
// end ; end_of_file
2663: LD_VAR 0 1
2667: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2668: LD_INT 0
2670: PPUSH
2671: PPUSH
2672: PPUSH
2673: PPUSH
2674: PPUSH
2675: PPUSH
2676: PPUSH
2677: PPUSH
2678: PPUSH
2679: PPUSH
// uc_side := 4 ;
2680: LD_ADDR_OWVAR 20
2684: PUSH
2685: LD_INT 4
2687: ST_TO_ADDR
// uc_nation := 1 ;
2688: LD_ADDR_OWVAR 21
2692: PUSH
2693: LD_INT 1
2695: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2696: LD_INT 387
2698: PPUSH
2699: CALL_OW 274
2703: PPUSH
2704: LD_INT 1
2706: PPUSH
2707: LD_INT 2500
2709: PPUSH
2710: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2714: LD_INT 387
2716: PPUSH
2717: CALL_OW 274
2721: PPUSH
2722: LD_INT 2
2724: PPUSH
2725: LD_INT 400
2727: PPUSH
2728: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2732: LD_INT 387
2734: PPUSH
2735: CALL_OW 274
2739: PPUSH
2740: LD_INT 3
2742: PPUSH
2743: LD_INT 10
2745: PPUSH
2746: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2750: LD_ADDR_EXP 55
2754: PUSH
2755: LD_STRING Powell
2757: PPUSH
2758: CALL_OW 25
2762: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2763: LD_EXP 55
2767: PPUSH
2768: LD_INT 57
2770: PPUSH
2771: LD_INT 94
2773: PPUSH
2774: LD_INT 0
2776: PPUSH
2777: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2781: LD_EXP 55
2785: PPUSH
2786: LD_INT 58
2788: PPUSH
2789: LD_INT 94
2791: PPUSH
2792: CALL_OW 118
// vip := [ ] ;
2796: LD_ADDR_EXP 56
2800: PUSH
2801: EMPTY
2802: ST_TO_ADDR
// tmp := [ ] ;
2803: LD_ADDR_VAR 0 6
2807: PUSH
2808: EMPTY
2809: ST_TO_ADDR
// if JMMGirl <> 2 then
2810: LD_EXP 7
2814: PUSH
2815: LD_INT 2
2817: NONEQUAL
2818: IFFALSE 2842
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2820: LD_ADDR_EXP 39
2824: PUSH
2825: LD_STRING Lisa
2827: PPUSH
2828: LD_EXP 1
2832: NOT
2833: PPUSH
2834: LD_STRING 13s_
2836: PPUSH
2837: CALL 60971 0 3
2841: ST_TO_ADDR
// if Lisa then
2842: LD_EXP 39
2846: IFFALSE 2864
// tmp := tmp ^ Lisa ;
2848: LD_ADDR_VAR 0 6
2852: PUSH
2853: LD_VAR 0 6
2857: PUSH
2858: LD_EXP 39
2862: ADD
2863: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2864: LD_ADDR_EXP 40
2868: PUSH
2869: LD_STRING Donaldson
2871: PPUSH
2872: LD_EXP 1
2876: NOT
2877: PPUSH
2878: LD_STRING 13s_
2880: PPUSH
2881: CALL 60971 0 3
2885: ST_TO_ADDR
// if Donaldson then
2886: LD_EXP 40
2890: IFFALSE 2908
// tmp := tmp ^ Donaldson ;
2892: LD_ADDR_VAR 0 6
2896: PUSH
2897: LD_VAR 0 6
2901: PUSH
2902: LD_EXP 40
2906: ADD
2907: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
2908: LD_ADDR_EXP 41
2912: PUSH
2913: LD_STRING Bobby
2915: PPUSH
2916: LD_EXP 1
2920: NOT
2921: PPUSH
2922: LD_STRING 13s_
2924: PPUSH
2925: CALL 60971 0 3
2929: ST_TO_ADDR
// if Bobby then
2930: LD_EXP 41
2934: IFFALSE 2952
// tmp := tmp ^ Bobby ;
2936: LD_ADDR_VAR 0 6
2940: PUSH
2941: LD_VAR 0 6
2945: PUSH
2946: LD_EXP 41
2950: ADD
2951: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
2952: LD_ADDR_EXP 42
2956: PUSH
2957: LD_STRING Cyrus
2959: PPUSH
2960: LD_EXP 1
2964: NOT
2965: PPUSH
2966: LD_STRING 13s_
2968: PPUSH
2969: CALL 60971 0 3
2973: ST_TO_ADDR
// if Cyrus then
2974: LD_EXP 42
2978: IFFALSE 2996
// tmp := tmp ^ Cyrus ;
2980: LD_ADDR_VAR 0 6
2984: PUSH
2985: LD_VAR 0 6
2989: PUSH
2990: LD_EXP 42
2994: ADD
2995: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
2996: LD_ADDR_EXP 43
3000: PUSH
3001: LD_STRING Denis
3003: PPUSH
3004: LD_EXP 1
3008: NOT
3009: PPUSH
3010: LD_STRING 13s_
3012: PPUSH
3013: CALL 60971 0 3
3017: ST_TO_ADDR
// if not Denis then
3018: LD_EXP 43
3022: NOT
3023: IFFALSE 3047
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3025: LD_ADDR_EXP 43
3029: PUSH
3030: LD_STRING Denis
3032: PPUSH
3033: LD_EXP 1
3037: NOT
3038: PPUSH
3039: LD_STRING 13f_
3041: PPUSH
3042: CALL 60971 0 3
3046: ST_TO_ADDR
// if Denis then
3047: LD_EXP 43
3051: IFFALSE 3069
// tmp := tmp ^ Denis ;
3053: LD_ADDR_VAR 0 6
3057: PUSH
3058: LD_VAR 0 6
3062: PUSH
3063: LD_EXP 43
3067: ADD
3068: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3069: LD_ADDR_EXP 44
3073: PUSH
3074: LD_STRING Brown
3076: PPUSH
3077: LD_EXP 1
3081: NOT
3082: PPUSH
3083: LD_STRING 13s_
3085: PPUSH
3086: CALL 60971 0 3
3090: ST_TO_ADDR
// if Brown then
3091: LD_EXP 44
3095: IFFALSE 3113
// tmp := tmp ^ Brown ;
3097: LD_ADDR_VAR 0 6
3101: PUSH
3102: LD_VAR 0 6
3106: PUSH
3107: LD_EXP 44
3111: ADD
3112: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3113: LD_ADDR_EXP 45
3117: PUSH
3118: LD_STRING Gladstone
3120: PPUSH
3121: LD_EXP 1
3125: NOT
3126: PPUSH
3127: LD_STRING 13s_
3129: PPUSH
3130: CALL 60971 0 3
3134: ST_TO_ADDR
// if Gladstone then
3135: LD_EXP 45
3139: IFFALSE 3157
// tmp := tmp ^ Gladstone ;
3141: LD_ADDR_VAR 0 6
3145: PUSH
3146: LD_VAR 0 6
3150: PUSH
3151: LD_EXP 45
3155: ADD
3156: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3157: LD_ADDR_EXP 46
3161: PUSH
3162: LD_STRING Houten
3164: PPUSH
3165: LD_EXP 1
3169: NOT
3170: PPUSH
3171: LD_STRING 13s_
3173: PPUSH
3174: CALL 60971 0 3
3178: ST_TO_ADDR
// if Houten then
3179: LD_EXP 46
3183: IFFALSE 3201
// tmp := tmp ^ Houten ;
3185: LD_ADDR_VAR 0 6
3189: PUSH
3190: LD_VAR 0 6
3194: PUSH
3195: LD_EXP 46
3199: ADD
3200: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3201: LD_ADDR_EXP 47
3205: PUSH
3206: LD_STRING Cornel
3208: PPUSH
3209: LD_EXP 1
3213: NOT
3214: PPUSH
3215: LD_STRING 13s_
3217: PPUSH
3218: CALL 60971 0 3
3222: ST_TO_ADDR
// if Cornel then
3223: LD_EXP 47
3227: IFFALSE 3245
// tmp := tmp ^ Cornel ;
3229: LD_ADDR_VAR 0 6
3233: PUSH
3234: LD_VAR 0 6
3238: PUSH
3239: LD_EXP 47
3243: ADD
3244: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3245: LD_ADDR_EXP 48
3249: PUSH
3250: LD_STRING Gary
3252: PPUSH
3253: LD_EXP 1
3257: NOT
3258: PPUSH
3259: LD_STRING 13s_
3261: PPUSH
3262: CALL 60971 0 3
3266: ST_TO_ADDR
// if Gary then
3267: LD_EXP 48
3271: IFFALSE 3289
// tmp := tmp ^ Gary ;
3273: LD_ADDR_VAR 0 6
3277: PUSH
3278: LD_VAR 0 6
3282: PUSH
3283: LD_EXP 48
3287: ADD
3288: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3289: LD_ADDR_EXP 49
3293: PUSH
3294: LD_STRING Frank
3296: PPUSH
3297: LD_EXP 1
3301: NOT
3302: PPUSH
3303: LD_STRING 13s_
3305: PPUSH
3306: CALL 60971 0 3
3310: ST_TO_ADDR
// if Frank then
3311: LD_EXP 49
3315: IFFALSE 3333
// tmp := tmp ^ Frank ;
3317: LD_ADDR_VAR 0 6
3321: PUSH
3322: LD_VAR 0 6
3326: PUSH
3327: LD_EXP 49
3331: ADD
3332: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3333: LD_ADDR_EXP 50
3337: PUSH
3338: LD_STRING Kikuchi
3340: PPUSH
3341: LD_EXP 1
3345: NOT
3346: PPUSH
3347: LD_STRING 13s_
3349: PPUSH
3350: CALL 60971 0 3
3354: ST_TO_ADDR
// if Kikuchi then
3355: LD_EXP 50
3359: IFFALSE 3377
// tmp := tmp ^ Kikuchi ;
3361: LD_ADDR_VAR 0 6
3365: PUSH
3366: LD_VAR 0 6
3370: PUSH
3371: LD_EXP 50
3375: ADD
3376: ST_TO_ADDR
// vip := tmp ;
3377: LD_ADDR_EXP 56
3381: PUSH
3382: LD_VAR 0 6
3386: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3387: LD_ADDR_VAR 0 6
3391: PUSH
3392: LD_VAR 0 6
3396: PUSH
3397: LD_STRING 13s_others
3399: PPUSH
3400: CALL_OW 31
3404: UNION
3405: ST_TO_ADDR
// if tmp < 20 then
3406: LD_VAR 0 6
3410: PUSH
3411: LD_INT 20
3413: LESS
3414: IFFALSE 3481
// for i = 1 to 20 - tmp do
3416: LD_ADDR_VAR 0 2
3420: PUSH
3421: DOUBLE
3422: LD_INT 1
3424: DEC
3425: ST_TO_ADDR
3426: LD_INT 20
3428: PUSH
3429: LD_VAR 0 6
3433: MINUS
3434: PUSH
3435: FOR_TO
3436: IFFALSE 3479
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3438: LD_INT 1
3440: PPUSH
3441: LD_VAR 0 2
3445: PUSH
3446: LD_INT 4
3448: MOD
3449: PUSH
3450: LD_INT 1
3452: PLUS
3453: PPUSH
3454: LD_INT 5
3456: PPUSH
3457: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3461: LD_ADDR_VAR 0 6
3465: PUSH
3466: LD_VAR 0 6
3470: PUSH
3471: CALL_OW 44
3475: ADD
3476: ST_TO_ADDR
// end ;
3477: GO 3435
3479: POP
3480: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3481: LD_ADDR_VAR 0 7
3485: PUSH
3486: LD_INT 22
3488: PUSH
3489: LD_INT 4
3491: PUSH
3492: EMPTY
3493: LIST
3494: LIST
3495: PUSH
3496: LD_INT 30
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: PUSH
3506: EMPTY
3507: LIST
3508: LIST
3509: PPUSH
3510: CALL_OW 69
3514: PUSH
3515: LD_INT 1
3517: ARRAY
3518: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3519: LD_ADDR_VAR 0 8
3523: PUSH
3524: LD_INT 22
3526: PUSH
3527: LD_INT 4
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 30
3536: PUSH
3537: LD_INT 6
3539: PUSH
3540: EMPTY
3541: LIST
3542: LIST
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: PPUSH
3548: CALL_OW 69
3552: PUSH
3553: LD_INT 1
3555: ARRAY
3556: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3557: LD_ADDR_VAR 0 9
3561: PUSH
3562: LD_INT 22
3564: PUSH
3565: LD_INT 4
3567: PUSH
3568: EMPTY
3569: LIST
3570: LIST
3571: PUSH
3572: LD_INT 30
3574: PUSH
3575: LD_INT 4
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: PPUSH
3586: CALL_OW 69
3590: PUSH
3591: LD_INT 1
3593: ARRAY
3594: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3595: LD_ADDR_VAR 0 10
3599: PUSH
3600: LD_INT 22
3602: PUSH
3603: LD_INT 4
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: PUSH
3610: LD_INT 30
3612: PUSH
3613: LD_INT 2
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PPUSH
3624: CALL_OW 69
3628: PUSH
3629: LD_INT 1
3631: ARRAY
3632: ST_TO_ADDR
// for i in tmp do
3633: LD_ADDR_VAR 0 2
3637: PUSH
3638: LD_VAR 0 6
3642: PUSH
3643: FOR_IN
3644: IFFALSE 3770
// begin cl := GetClass ( i ) ;
3646: LD_ADDR_VAR 0 5
3650: PUSH
3651: LD_VAR 0 2
3655: PPUSH
3656: CALL_OW 257
3660: ST_TO_ADDR
// if cl > 4 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 4
3668: GREATER
3669: IFFALSE 3679
// cl := 1 ;
3671: LD_ADDR_VAR 0 5
3675: PUSH
3676: LD_INT 1
3678: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3679: LD_ADDR_VAR 0 3
3683: PUSH
3684: LD_VAR 0 9
3688: PUSH
3689: LD_VAR 0 7
3693: PUSH
3694: LD_VAR 0 10
3698: PUSH
3699: LD_VAR 0 8
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: LIST
3709: PUSH
3710: LD_VAR 0 5
3714: ARRAY
3715: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3716: LD_VAR 0 3
3720: PPUSH
3721: CALL_OW 313
3725: PUSH
3726: LD_INT 5
3728: LESS
3729: IFFALSE 3747
// PlaceHumanInUnit ( i , b ) else
3731: LD_VAR 0 2
3735: PPUSH
3736: LD_VAR 0 3
3740: PPUSH
3741: CALL_OW 52
3745: GO 3768
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3747: LD_VAR 0 2
3751: PPUSH
3752: LD_INT 58
3754: PPUSH
3755: LD_INT 91
3757: PPUSH
3758: LD_INT 6
3760: PPUSH
3761: LD_INT 0
3763: PPUSH
3764: CALL_OW 50
// end ;
3768: GO 3643
3770: POP
3771: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3772: LD_INT 2
3774: PPUSH
3775: LD_INT 1
3777: PPUSH
3778: LD_INT 1
3780: PPUSH
3781: LD_INT 12
3783: PPUSH
3784: LD_INT 100
3786: PPUSH
3787: CALL 67604 0 5
// veh := CreateVehicle ;
3791: LD_ADDR_VAR 0 4
3795: PUSH
3796: CALL_OW 45
3800: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 4
3808: PPUSH
3809: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3813: LD_VAR 0 4
3817: PPUSH
3818: LD_INT 49
3820: PPUSH
3821: LD_INT 88
3823: PPUSH
3824: LD_INT 0
3826: PPUSH
3827: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3831: LD_VAR 0 4
3835: PPUSH
3836: LD_INT 1
3838: PPUSH
3839: LD_INT 100
3841: PPUSH
3842: CALL_OW 290
// uc_side := 0 ;
3846: LD_ADDR_OWVAR 20
3850: PUSH
3851: LD_INT 0
3853: ST_TO_ADDR
// uc_nation := 0 ;
3854: LD_ADDR_OWVAR 21
3858: PUSH
3859: LD_INT 0
3861: ST_TO_ADDR
// for i = 1 to 4 do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: DOUBLE
3868: LD_INT 1
3870: DEC
3871: ST_TO_ADDR
3872: LD_INT 4
3874: PUSH
3875: FOR_TO
3876: IFFALSE 3907
// begin InitHc ;
3878: CALL_OW 19
// hc_class := class_apeman ;
3882: LD_ADDR_OWVAR 28
3886: PUSH
3887: LD_INT 12
3889: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
3890: CALL_OW 44
3894: PPUSH
3895: LD_INT 13
3897: PPUSH
3898: LD_INT 0
3900: PPUSH
3901: CALL_OW 49
// end ;
3905: GO 3875
3907: POP
3908: POP
// end ; end_of_file
3909: LD_VAR 0 1
3913: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
3914: LD_INT 0
3916: PPUSH
3917: PPUSH
3918: PPUSH
3919: PPUSH
3920: PPUSH
// side := 8 ;
3921: LD_ADDR_VAR 0 3
3925: PUSH
3926: LD_INT 8
3928: ST_TO_ADDR
// uc_side := side ;
3929: LD_ADDR_OWVAR 20
3933: PUSH
3934: LD_VAR 0 3
3938: ST_TO_ADDR
// uc_nation := 2 ;
3939: LD_ADDR_OWVAR 21
3943: PUSH
3944: LD_INT 2
3946: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: LD_INT 22
3954: PUSH
3955: LD_VAR 0 3
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 21
3966: PUSH
3967: LD_INT 3
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: CALL_OW 69
3982: PUSH
3983: FOR_IN
3984: IFFALSE 4000
// SetBLevel ( i , 10 ) ;
3986: LD_VAR 0 2
3990: PPUSH
3991: LD_INT 10
3993: PPUSH
3994: CALL_OW 241
3998: GO 3983
4000: POP
4001: POP
// if KurtStatus then
4002: LD_EXP 3
4006: IFFALSE 4029
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4008: LD_ADDR_EXP 57
4012: PUSH
4013: LD_STRING Kurt
4015: PPUSH
4016: LD_INT 0
4018: PPUSH
4019: LD_STRING 
4021: PPUSH
4022: CALL 60971 0 3
4026: ST_TO_ADDR
4027: GO 4051
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4029: LD_ADDR_EXP 57
4033: PUSH
4034: LD_STRING AltKurt
4036: PPUSH
4037: LD_EXP 1
4041: NOT
4042: PPUSH
4043: LD_STRING 
4045: PPUSH
4046: CALL 60971 0 3
4050: ST_TO_ADDR
// if not Kurt then
4051: LD_EXP 57
4055: NOT
4056: IFFALSE 4082
// begin InitHc ;
4058: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4062: LD_INT 1
4064: PPUSH
4065: LD_INT 10
4067: PPUSH
4068: CALL_OW 381
// Kurt := CreateHuman ;
4072: LD_ADDR_EXP 57
4076: PUSH
4077: CALL_OW 44
4081: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4082: LD_EXP 57
4086: PPUSH
4087: LD_INT 324
4089: PPUSH
4090: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4094: LD_ADDR_EXP 58
4098: PUSH
4099: LD_STRING Kozlov
4101: PPUSH
4102: LD_INT 0
4104: PPUSH
4105: LD_STRING 
4107: PPUSH
4108: CALL 60971 0 3
4112: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4113: LD_EXP 58
4117: PPUSH
4118: LD_INT 22
4120: PUSH
4121: LD_INT 8
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PUSH
4128: LD_INT 23
4130: PUSH
4131: LD_INT 3
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: LD_INT 30
4140: PUSH
4141: LD_INT 8
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PPUSH
4153: CALL_OW 69
4157: PUSH
4158: LD_INT 1
4160: ARRAY
4161: PPUSH
4162: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4166: LD_ADDR_VAR 0 5
4170: PUSH
4171: LD_INT 22
4173: PUSH
4174: LD_VAR 0 3
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PUSH
4183: LD_INT 30
4185: PUSH
4186: LD_INT 32
4188: PUSH
4189: EMPTY
4190: LIST
4191: LIST
4192: PUSH
4193: LD_INT 58
4195: PUSH
4196: EMPTY
4197: LIST
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PPUSH
4204: CALL_OW 69
4208: ST_TO_ADDR
// for i = 1 to 10 do
4209: LD_ADDR_VAR 0 2
4213: PUSH
4214: DOUBLE
4215: LD_INT 1
4217: DEC
4218: ST_TO_ADDR
4219: LD_INT 10
4221: PUSH
4222: FOR_TO
4223: IFFALSE 4295
// begin uc_nation := nation_nature ;
4225: LD_ADDR_OWVAR 21
4229: PUSH
4230: LD_INT 0
4232: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4233: LD_ADDR_OWVAR 28
4237: PUSH
4238: LD_INT 15
4240: ST_TO_ADDR
// hc_gallery :=  ;
4241: LD_ADDR_OWVAR 33
4245: PUSH
4246: LD_STRING 
4248: ST_TO_ADDR
// hc_name :=  ;
4249: LD_ADDR_OWVAR 26
4253: PUSH
4254: LD_STRING 
4256: ST_TO_ADDR
// un := CreateHuman ;
4257: LD_ADDR_VAR 0 4
4261: PUSH
4262: CALL_OW 44
4266: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4267: LD_VAR 0 4
4271: PPUSH
4272: LD_VAR 0 5
4276: PUSH
4277: LD_VAR 0 5
4281: PUSH
4282: LD_VAR 0 2
4286: MINUS
4287: ARRAY
4288: PPUSH
4289: CALL_OW 52
// end ;
4293: GO 4222
4295: POP
4296: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4297: LD_ADDR_VAR 0 5
4301: PUSH
4302: LD_STRING 12_kurt_squad
4304: PPUSH
4305: CALL_OW 31
4309: ST_TO_ADDR
// if tmp then
4310: LD_VAR 0 5
4314: IFFALSE 4348
// for i in tmp do
4316: LD_ADDR_VAR 0 2
4320: PUSH
4321: LD_VAR 0 5
4325: PUSH
4326: FOR_IN
4327: IFFALSE 4346
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_INT 5
4336: PPUSH
4337: LD_INT 0
4339: PPUSH
4340: CALL_OW 49
4344: GO 4326
4346: POP
4347: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4348: LD_INT 324
4350: PPUSH
4351: LD_INT 5
4353: PPUSH
4354: LD_STRING 
4356: PPUSH
4357: LD_INT 8
4359: PUSH
4360: LD_INT 9
4362: PUSH
4363: LD_INT 10
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_OWVAR 67
4375: ARRAY
4376: PPUSH
4377: LD_INT 3000
4379: PUSH
4380: LD_INT 500
4382: PUSH
4383: LD_INT 150
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: LIST
4390: PPUSH
4391: LD_INT 16
4393: PUSH
4394: LD_INT 6
4396: PUSH
4397: LD_INT 6
4399: PUSH
4400: LD_INT 8
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: LIST
4408: PPUSH
4409: CALL 71013 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4413: LD_ADDR_EXP 99
4417: PUSH
4418: LD_EXP 99
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 22
4428: PUSH
4429: LD_VAR 0 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 23
4440: PUSH
4441: LD_INT 2
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: LD_INT 3
4450: PUSH
4451: LD_INT 21
4453: PUSH
4454: LD_INT 2
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: EMPTY
4466: LIST
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: PUSH
4475: LD_EXP 57
4479: DIFF
4480: PPUSH
4481: CALL_OW 1
4485: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4486: LD_INT 1
4488: PPUSH
4489: LD_INT 7
4491: PPUSH
4492: CALL_OW 383
// Friend := CreateHuman ;
4496: LD_ADDR_EXP 59
4500: PUSH
4501: CALL_OW 44
4505: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4506: LD_INT 14
4508: PPUSH
4509: LD_INT 3
4511: PPUSH
4512: LD_INT 1
4514: PPUSH
4515: LD_INT 29
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 67604 0 5
// powellBomb := CreateVehicle ;
4525: LD_ADDR_EXP 60
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4535: LD_EXP 60
4539: PPUSH
4540: LD_INT 90
4542: PPUSH
4543: LD_INT 51
4545: PPUSH
4546: LD_INT 0
4548: PPUSH
4549: CALL_OW 48
// end ;
4553: LD_VAR 0 1
4557: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4558: LD_INT 0
4560: PPUSH
4561: PPUSH
4562: PPUSH
// if IsLive ( kozlov_fac ) then
4563: LD_INT 332
4565: PPUSH
4566: CALL_OW 300
4570: IFFALSE 4574
// exit ;
4572: GO 5141
// ComExitBuilding ( Kozlov ) ;
4574: LD_EXP 58
4578: PPUSH
4579: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4583: LD_EXP 58
4587: PPUSH
4588: CALL_OW 257
4592: PUSH
4593: LD_INT 2
4595: NONEQUAL
4596: IFFALSE 4631
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4598: LD_EXP 58
4602: PPUSH
4603: LD_INT 324
4605: PPUSH
4606: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4610: LD_EXP 58
4614: PPUSH
4615: LD_INT 2
4617: PPUSH
4618: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4622: LD_EXP 58
4626: PPUSH
4627: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4631: LD_EXP 58
4635: PPUSH
4636: LD_INT 2
4638: PPUSH
4639: LD_INT 93
4641: PPUSH
4642: LD_INT 32
4644: PPUSH
4645: LD_INT 3
4647: PPUSH
4648: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4652: LD_INT 35
4654: PPUSH
4655: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4659: LD_INT 22
4661: PUSH
4662: LD_INT 8
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 30
4671: PUSH
4672: LD_INT 3
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: PUSH
4679: LD_INT 23
4681: PUSH
4682: LD_INT 3
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: PUSH
4689: LD_INT 57
4691: PUSH
4692: EMPTY
4693: LIST
4694: PUSH
4695: EMPTY
4696: LIST
4697: LIST
4698: LIST
4699: LIST
4700: PPUSH
4701: CALL_OW 69
4705: IFFALSE 4652
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4707: LD_ADDR_VAR 0 2
4711: PUSH
4712: LD_INT 22
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: LD_INT 30
4724: PUSH
4725: LD_INT 3
4727: PUSH
4728: EMPTY
4729: LIST
4730: LIST
4731: PUSH
4732: LD_INT 23
4734: PUSH
4735: LD_INT 3
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PUSH
4742: LD_INT 57
4744: PUSH
4745: EMPTY
4746: LIST
4747: PUSH
4748: EMPTY
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: PPUSH
4754: CALL_OW 69
4758: PUSH
4759: LD_INT 1
4761: ARRAY
4762: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4763: LD_INT 22
4765: PUSH
4766: LD_INT 8
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 23
4775: PUSH
4776: LD_INT 3
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 30
4785: PUSH
4786: LD_INT 21
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: NOT
4803: IFFALSE 4881
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4805: LD_EXP 58
4809: PPUSH
4810: LD_INT 21
4812: PPUSH
4813: LD_INT 97
4815: PPUSH
4816: LD_INT 36
4818: PPUSH
4819: LD_INT 5
4821: PPUSH
4822: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4826: LD_INT 35
4828: PPUSH
4829: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4833: LD_INT 22
4835: PUSH
4836: LD_INT 8
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_INT 23
4845: PUSH
4846: LD_INT 3
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: PUSH
4853: LD_INT 30
4855: PUSH
4856: LD_INT 21
4858: PUSH
4859: EMPTY
4860: LIST
4861: LIST
4862: PUSH
4863: LD_INT 57
4865: PUSH
4866: EMPTY
4867: LIST
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: PPUSH
4875: CALL_OW 69
4879: IFFALSE 4826
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
4881: LD_INT 22
4883: PUSH
4884: LD_INT 8
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: LD_INT 23
4893: PUSH
4894: LD_INT 3
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 30
4903: PUSH
4904: LD_INT 18
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: NOT
4921: IFFALSE 4999
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
4923: LD_EXP 58
4927: PPUSH
4928: LD_INT 18
4930: PPUSH
4931: LD_INT 89
4933: PPUSH
4934: LD_INT 32
4936: PPUSH
4937: LD_INT 1
4939: PPUSH
4940: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4944: LD_INT 35
4946: PPUSH
4947: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
4951: LD_INT 22
4953: PUSH
4954: LD_INT 8
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 30
4973: PUSH
4974: LD_INT 18
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: PUSH
4981: LD_INT 57
4983: PUSH
4984: EMPTY
4985: LIST
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: PPUSH
4993: CALL_OW 69
4997: IFFALSE 4944
// end ; lab := kozlov_lab ;
4999: LD_ADDR_VAR 0 3
5003: PUSH
5004: LD_INT 336
5006: ST_TO_ADDR
// if not lab then
5007: LD_VAR 0 3
5011: NOT
5012: IFFALSE 5016
// exit ;
5014: GO 5141
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5016: LD_EXP 58
5020: PPUSH
5021: LD_VAR 0 3
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PPUSH
5030: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5034: LD_EXP 58
5038: PPUSH
5039: LD_INT 4
5041: PPUSH
5042: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5046: LD_VAR 0 3
5050: PUSH
5051: LD_INT 1
5053: ARRAY
5054: PPUSH
5055: LD_INT 25
5057: PPUSH
5058: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5062: LD_INT 35
5064: PPUSH
5065: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5069: LD_INT 25
5071: PPUSH
5072: LD_INT 8
5074: PPUSH
5075: CALL_OW 321
5079: PUSH
5080: LD_INT 2
5082: EQUAL
5083: IFFALSE 5062
// ComExitBuilding ( Kozlov ) ;
5085: LD_EXP 58
5089: PPUSH
5090: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5094: LD_EXP 58
5098: PPUSH
5099: LD_VAR 0 2
5103: PPUSH
5104: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5108: LD_EXP 58
5112: PPUSH
5113: LD_INT 3
5115: PPUSH
5116: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5120: LD_VAR 0 2
5124: PPUSH
5125: LD_INT 23
5127: PPUSH
5128: LD_INT 3
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_INT 48
5136: PPUSH
5137: CALL_OW 125
// end ;
5141: LD_VAR 0 1
5145: RET
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 do var i , tmp , target ;
5146: LD_EXP 22
5150: NOT
5151: PUSH
5152: LD_EXP 15
5156: PUSH
5157: LD_INT 6
5159: GREATEREQUAL
5160: AND
5161: IFFALSE 5925
5163: GO 5165
5165: DISABLE
5166: LD_INT 0
5168: PPUSH
5169: PPUSH
5170: PPUSH
// begin enable ;
5171: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5172: LD_INT 22
5174: PUSH
5175: LD_INT 8
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: LD_INT 23
5184: PUSH
5185: LD_INT 2
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: PUSH
5192: LD_INT 30
5194: PUSH
5195: LD_INT 3
5197: PUSH
5198: EMPTY
5199: LIST
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL_OW 69
5211: NOT
5212: IFFALSE 5216
// exit ;
5214: GO 5925
// if Prob ( 40 ) then
5216: LD_INT 40
5218: PPUSH
5219: CALL_OW 13
5223: IFFALSE 5350
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5225: LD_INT 3
5227: PPUSH
5228: LD_INT 14
5230: PUSH
5231: LD_INT 1
5233: PUSH
5234: LD_INT 2
5236: PUSH
5237: LD_INT 28
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 14
5248: PUSH
5249: LD_INT 1
5251: PUSH
5252: LD_INT 2
5254: PUSH
5255: LD_INT 28
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: PUSH
5264: LD_INT 14
5266: PUSH
5267: LD_INT 1
5269: PUSH
5270: LD_INT 2
5272: PUSH
5273: LD_INT 28
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: LIST
5280: LIST
5281: PUSH
5282: LD_INT 14
5284: PUSH
5285: LD_INT 1
5287: PUSH
5288: LD_INT 2
5290: PUSH
5291: LD_INT 28
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 14
5302: PUSH
5303: LD_INT 1
5305: PUSH
5306: LD_INT 2
5308: PUSH
5309: LD_INT 28
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: PUSH
5318: LD_INT 14
5320: PUSH
5321: LD_INT 1
5323: PUSH
5324: LD_INT 2
5326: PUSH
5327: LD_INT 26
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: LIST
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: LIST
5343: PPUSH
5344: CALL 55076 0 2
// end else
5348: GO 5541
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5350: LD_INT 3
5352: PPUSH
5353: LD_INT 14
5355: PUSH
5356: LD_INT 1
5358: PUSH
5359: LD_INT 2
5361: PUSH
5362: LD_INT 27
5364: PUSH
5365: LD_INT 26
5367: PUSH
5368: LD_INT 26
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: LIST
5375: PUSH
5376: LD_OWVAR 67
5380: ARRAY
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 14
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: LD_INT 2
5396: PUSH
5397: LD_INT 27
5399: PUSH
5400: LD_INT 26
5402: PUSH
5403: LD_INT 26
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: PUSH
5411: LD_OWVAR 67
5415: ARRAY
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: PUSH
5423: LD_INT 14
5425: PUSH
5426: LD_INT 1
5428: PUSH
5429: LD_INT 2
5431: PUSH
5432: LD_INT 26
5434: PUSH
5435: LD_INT 26
5437: PUSH
5438: LD_INT 29
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: LIST
5445: PUSH
5446: LD_OWVAR 67
5450: ARRAY
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: LIST
5456: LIST
5457: PUSH
5458: LD_INT 13
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 2
5466: PUSH
5467: LD_INT 26
5469: PUSH
5470: LD_INT 29
5472: PUSH
5473: LD_INT 29
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: PUSH
5481: LD_OWVAR 67
5485: ARRAY
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 13
5495: PUSH
5496: LD_INT 1
5498: PUSH
5499: LD_INT 2
5501: PUSH
5502: LD_INT 29
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 14
5513: PUSH
5514: LD_INT 1
5516: PUSH
5517: LD_INT 2
5519: PUSH
5520: LD_INT 26
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PPUSH
5537: CALL 55076 0 2
// end ; repeat wait ( 0 0$1 ) ;
5541: LD_INT 35
5543: PPUSH
5544: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5548: LD_INT 3
5550: PPUSH
5551: LD_INT 1
5553: PPUSH
5554: CALL 56489 0 2
5558: PUSH
5559: LD_INT 6
5561: GREATEREQUAL
5562: IFFALSE 5541
// wait ( 0 0$30 ) ;
5564: LD_INT 1050
5566: PPUSH
5567: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5571: LD_ADDR_VAR 0 2
5575: PUSH
5576: LD_INT 3
5578: PPUSH
5579: LD_INT 1
5581: PPUSH
5582: CALL 56489 0 2
5586: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5587: LD_ADDR_EXP 118
5591: PUSH
5592: LD_EXP 118
5596: PPUSH
5597: LD_INT 3
5599: PPUSH
5600: LD_EXP 118
5604: PUSH
5605: LD_INT 3
5607: ARRAY
5608: PUSH
5609: LD_VAR 0 2
5613: DIFF
5614: PPUSH
5615: CALL_OW 1
5619: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5620: LD_ADDR_VAR 0 3
5624: PUSH
5625: LD_INT 0
5627: PPUSH
5628: LD_INT 2
5630: PPUSH
5631: CALL_OW 12
5635: ST_TO_ADDR
// if target then
5636: LD_VAR 0 3
5640: IFFALSE 5730
// begin repeat ComMoveXY ( tmp , 89 , 71 ) ;
5642: LD_VAR 0 2
5646: PPUSH
5647: LD_INT 89
5649: PPUSH
5650: LD_INT 71
5652: PPUSH
5653: CALL_OW 111
// wait ( 0 0$1 ) ;
5657: LD_INT 35
5659: PPUSH
5660: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5664: LD_ADDR_VAR 0 2
5668: PUSH
5669: LD_VAR 0 2
5673: PPUSH
5674: LD_INT 24
5676: PUSH
5677: LD_INT 250
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL_OW 72
5688: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 8 ] ) >= ( tmp - 1 ) ;
5689: LD_VAR 0 2
5693: PPUSH
5694: LD_INT 92
5696: PUSH
5697: LD_INT 89
5699: PUSH
5700: LD_INT 71
5702: PUSH
5703: LD_INT 8
5705: PUSH
5706: EMPTY
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL_OW 72
5716: PUSH
5717: LD_VAR 0 2
5721: PUSH
5722: LD_INT 1
5724: MINUS
5725: GREATEREQUAL
5726: IFFALSE 5642
// end else
5728: GO 5816
// begin repeat ComMoveXY ( tmp , 125 , 129 ) ;
5730: LD_VAR 0 2
5734: PPUSH
5735: LD_INT 125
5737: PPUSH
5738: LD_INT 129
5740: PPUSH
5741: CALL_OW 111
// wait ( 0 0$1 ) ;
5745: LD_INT 35
5747: PPUSH
5748: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5752: LD_ADDR_VAR 0 2
5756: PUSH
5757: LD_VAR 0 2
5761: PPUSH
5762: LD_INT 24
5764: PUSH
5765: LD_INT 250
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PPUSH
5772: CALL_OW 72
5776: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 8 ] ) >= ( tmp - 1 ) ;
5777: LD_VAR 0 2
5781: PPUSH
5782: LD_INT 92
5784: PUSH
5785: LD_INT 125
5787: PUSH
5788: LD_INT 129
5790: PUSH
5791: LD_INT 8
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: LIST
5798: LIST
5799: PPUSH
5800: CALL_OW 72
5804: PUSH
5805: LD_VAR 0 2
5809: PUSH
5810: LD_INT 1
5812: MINUS
5813: GREATEREQUAL
5814: IFFALSE 5730
// end ; repeat wait ( 0 0$1 ) ;
5816: LD_INT 35
5818: PPUSH
5819: CALL_OW 67
// for i in tmp do
5823: LD_ADDR_VAR 0 1
5827: PUSH
5828: LD_VAR 0 2
5832: PUSH
5833: FOR_IN
5834: IFFALSE 5916
// if GetLives ( i ) > 251 then
5836: LD_VAR 0 1
5840: PPUSH
5841: CALL_OW 256
5845: PUSH
5846: LD_INT 251
5848: GREATER
5849: IFFALSE 5887
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
5851: LD_VAR 0 1
5855: PPUSH
5856: LD_INT 81
5858: PUSH
5859: LD_INT 8
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PPUSH
5866: CALL_OW 69
5870: PPUSH
5871: LD_VAR 0 1
5875: PPUSH
5876: CALL_OW 74
5880: PPUSH
5881: CALL_OW 115
5885: GO 5914
// if IsDead ( i ) then
5887: LD_VAR 0 1
5891: PPUSH
5892: CALL_OW 301
5896: IFFALSE 5914
// tmp := tmp diff i ;
5898: LD_ADDR_VAR 0 2
5902: PUSH
5903: LD_VAR 0 2
5907: PUSH
5908: LD_VAR 0 1
5912: DIFF
5913: ST_TO_ADDR
5914: GO 5833
5916: POP
5917: POP
// until not tmp ;
5918: LD_VAR 0 2
5922: NOT
5923: IFFALSE 5816
// end ;
5925: PPOPN 3
5927: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
5928: LD_EXP 22
5932: NOT
5933: PUSH
5934: LD_EXP 15
5938: PUSH
5939: LD_INT 6
5941: GREATEREQUAL
5942: AND
5943: PUSH
5944: LD_OWVAR 67
5948: PUSH
5949: LD_INT 1
5951: GREATER
5952: AND
5953: IFFALSE 6459
5955: GO 5957
5957: DISABLE
5958: LD_INT 0
5960: PPUSH
5961: PPUSH
5962: PPUSH
// begin enable ;
5963: ENABLE
// tmp := [ ] ;
5964: LD_ADDR_VAR 0 3
5968: PUSH
5969: EMPTY
5970: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
5971: LD_ADDR_VAR 0 1
5975: PUSH
5976: DOUBLE
5977: LD_INT 1
5979: DEC
5980: ST_TO_ADDR
5981: LD_INT 4
5983: PUSH
5984: LD_INT 6
5986: PUSH
5987: LD_INT 7
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_OWVAR 67
5999: ARRAY
6000: PUSH
6001: FOR_TO
6002: IFFALSE 6162
// begin uc_side := 8 ;
6004: LD_ADDR_OWVAR 20
6008: PUSH
6009: LD_INT 8
6011: ST_TO_ADDR
// uc_nation := 2 ;
6012: LD_ADDR_OWVAR 21
6016: PUSH
6017: LD_INT 2
6019: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6020: LD_INT 13
6022: PUSH
6023: LD_INT 14
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: LD_INT 1
6032: PPUSH
6033: LD_INT 2
6035: PPUSH
6036: CALL_OW 12
6040: ARRAY
6041: PPUSH
6042: LD_INT 1
6044: PPUSH
6045: LD_INT 5
6047: PPUSH
6048: LD_INT 27
6050: PUSH
6051: LD_INT 28
6053: PUSH
6054: LD_INT 26
6056: PUSH
6057: LD_INT 25
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 1
6068: PPUSH
6069: LD_INT 4
6071: PPUSH
6072: CALL_OW 12
6076: ARRAY
6077: PPUSH
6078: LD_INT 88
6080: PPUSH
6081: CALL 67604 0 5
// un := CreateVehicle ;
6085: LD_ADDR_VAR 0 2
6089: PUSH
6090: CALL_OW 45
6094: ST_TO_ADDR
// tmp := tmp ^ un ;
6095: LD_ADDR_VAR 0 3
6099: PUSH
6100: LD_VAR 0 3
6104: PUSH
6105: LD_VAR 0 2
6109: ADD
6110: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6111: LD_VAR 0 2
6115: PPUSH
6116: LD_INT 3
6118: PPUSH
6119: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6123: LD_VAR 0 2
6127: PPUSH
6128: LD_INT 30
6130: PPUSH
6131: LD_INT 0
6133: PPUSH
6134: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6138: LD_VAR 0 2
6142: PPUSH
6143: LD_INT 16
6145: PPUSH
6146: LD_INT 11
6148: PPUSH
6149: CALL_OW 111
// wait ( 0 0$2 ) ;
6153: LD_INT 70
6155: PPUSH
6156: CALL_OW 67
// end ;
6160: GO 6001
6162: POP
6163: POP
// for i = 1 to Difficulty do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: DOUBLE
6170: LD_INT 1
6172: DEC
6173: ST_TO_ADDR
6174: LD_OWVAR 67
6178: PUSH
6179: FOR_TO
6180: IFFALSE 6305
// begin uc_side := 8 ;
6182: LD_ADDR_OWVAR 20
6186: PUSH
6187: LD_INT 8
6189: ST_TO_ADDR
// uc_nation := 2 ;
6190: LD_ADDR_OWVAR 21
6194: PUSH
6195: LD_INT 2
6197: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6198: LD_INT 0
6200: PPUSH
6201: LD_INT 8
6203: PPUSH
6204: LD_INT 8
6206: PUSH
6207: LD_INT 8
6209: PUSH
6210: LD_INT 9
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: LIST
6217: PUSH
6218: LD_OWVAR 67
6222: ARRAY
6223: PPUSH
6224: CALL_OW 380
// un := CreateHuman ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: CALL_OW 44
6237: ST_TO_ADDR
// tmp := tmp ^ un ;
6238: LD_ADDR_VAR 0 3
6242: PUSH
6243: LD_VAR 0 3
6247: PUSH
6248: LD_VAR 0 2
6252: ADD
6253: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6254: LD_VAR 0 2
6258: PPUSH
6259: LD_INT 3
6261: PPUSH
6262: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6266: LD_VAR 0 2
6270: PPUSH
6271: LD_INT 30
6273: PPUSH
6274: LD_INT 0
6276: PPUSH
6277: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6281: LD_VAR 0 2
6285: PPUSH
6286: LD_INT 16
6288: PPUSH
6289: LD_INT 11
6291: PPUSH
6292: CALL_OW 111
// wait ( 0 0$2 ) ;
6296: LD_INT 70
6298: PPUSH
6299: CALL_OW 67
// end ;
6303: GO 6179
6305: POP
6306: POP
// repeat wait ( 0 0$1 ) ;
6307: LD_INT 35
6309: PPUSH
6310: CALL_OW 67
// for i in tmp do
6314: LD_ADDR_VAR 0 1
6318: PUSH
6319: LD_VAR 0 3
6323: PUSH
6324: FOR_IN
6325: IFFALSE 6450
// if GetLives ( i ) > 250 then
6327: LD_VAR 0 1
6331: PPUSH
6332: CALL_OW 256
6336: PUSH
6337: LD_INT 250
6339: GREATER
6340: IFFALSE 6432
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6342: LD_INT 81
6344: PUSH
6345: LD_INT 8
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 91
6354: PUSH
6355: LD_VAR 0 1
6359: PUSH
6360: LD_INT 10
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: EMPTY
6369: LIST
6370: LIST
6371: PPUSH
6372: CALL_OW 69
6376: NOT
6377: IFFALSE 6396
// ComAgressiveMove ( i , 67 , 110 ) else
6379: LD_VAR 0 1
6383: PPUSH
6384: LD_INT 67
6386: PPUSH
6387: LD_INT 110
6389: PPUSH
6390: CALL_OW 114
6394: GO 6430
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6396: LD_VAR 0 1
6400: PPUSH
6401: LD_INT 81
6403: PUSH
6404: LD_INT 8
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PPUSH
6411: CALL_OW 69
6415: PPUSH
6416: LD_VAR 0 1
6420: PPUSH
6421: CALL_OW 74
6425: PPUSH
6426: CALL_OW 115
// end else
6430: GO 6448
// tmp := tmp diff i ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: LD_VAR 0 3
6441: PUSH
6442: LD_VAR 0 1
6446: DIFF
6447: ST_TO_ADDR
6448: GO 6324
6450: POP
6451: POP
// until not tmp ;
6452: LD_VAR 0 3
6456: NOT
6457: IFFALSE 6307
// end ; end_of_file
6459: PPOPN 3
6461: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6462: LD_INT 0
6464: PPUSH
6465: PPUSH
6466: PPUSH
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
// side := 3 ;
6473: LD_ADDR_VAR 0 6
6477: PUSH
6478: LD_INT 3
6480: ST_TO_ADDR
// uc_side := side ;
6481: LD_ADDR_OWVAR 20
6485: PUSH
6486: LD_VAR 0 6
6490: ST_TO_ADDR
// uc_nation := 3 ;
6491: LD_ADDR_OWVAR 21
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6499: LD_ADDR_VAR 0 2
6503: PUSH
6504: LD_INT 22
6506: PUSH
6507: LD_VAR 0 6
6511: PUSH
6512: EMPTY
6513: LIST
6514: LIST
6515: PUSH
6516: LD_INT 21
6518: PUSH
6519: LD_INT 3
6521: PUSH
6522: EMPTY
6523: LIST
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PPUSH
6530: CALL_OW 69
6534: PUSH
6535: FOR_IN
6536: IFFALSE 6552
// SetBLevel ( i , 10 ) ;
6538: LD_VAR 0 2
6542: PPUSH
6543: LD_INT 10
6545: PPUSH
6546: CALL_OW 241
6550: GO 6535
6552: POP
6553: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6554: LD_ADDR_VAR 0 9
6558: PUSH
6559: LD_INT 22
6561: PUSH
6562: LD_VAR 0 6
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PUSH
6571: LD_INT 30
6573: PUSH
6574: LD_INT 34
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PPUSH
6585: CALL_OW 69
6589: ST_TO_ADDR
// if teleport then
6590: LD_VAR 0 9
6594: IFFALSE 6615
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6596: LD_VAR 0 9
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: LD_INT 123
6607: PPUSH
6608: LD_INT 122
6610: PPUSH
6611: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6615: LD_ADDR_EXP 61
6619: PUSH
6620: LD_STRING Platonov
6622: PPUSH
6623: CALL_OW 25
6627: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6628: LD_ADDR_EXP 62
6632: PUSH
6633: LD_STRING Kovalyuk
6635: PPUSH
6636: CALL_OW 25
6640: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6641: LD_ADDR_EXP 64
6645: PUSH
6646: LD_STRING Yakotich
6648: PPUSH
6649: CALL_OW 25
6653: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6654: LD_ADDR_EXP 63
6658: PUSH
6659: LD_STRING Bystrov
6661: PPUSH
6662: CALL_OW 25
6666: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6667: LD_ADDR_EXP 65
6671: PUSH
6672: LD_STRING Gleb
6674: PPUSH
6675: CALL_OW 25
6679: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
6680: LD_STRING 03_Cornel
6682: PPUSH
6683: CALL_OW 28
6687: IFFALSE 6735
// begin Bierezov := NewCharacter ( Mikhail ) ;
6689: LD_ADDR_EXP 66
6693: PUSH
6694: LD_STRING Mikhail
6696: PPUSH
6697: CALL_OW 25
6701: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
6702: LD_EXP 66
6706: PPUSH
6707: LD_INT 197
6709: PPUSH
6710: LD_INT 111
6712: PPUSH
6713: LD_INT 9
6715: PPUSH
6716: LD_INT 0
6718: PPUSH
6719: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
6723: LD_EXP 66
6727: PPUSH
6728: LD_INT 3
6730: PPUSH
6731: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
6735: LD_EXP 61
6739: PPUSH
6740: LD_INT 126
6742: PPUSH
6743: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
6747: LD_EXP 62
6751: PPUSH
6752: LD_INT 134
6754: PPUSH
6755: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
6759: LD_EXP 64
6763: PPUSH
6764: LD_INT 197
6766: PPUSH
6767: LD_INT 111
6769: PPUSH
6770: LD_INT 9
6772: PPUSH
6773: LD_INT 0
6775: PPUSH
6776: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
6780: LD_EXP 63
6784: PPUSH
6785: LD_INT 197
6787: PPUSH
6788: LD_INT 111
6790: PPUSH
6791: LD_INT 9
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
6801: LD_EXP 65
6805: PPUSH
6806: LD_INT 197
6808: PPUSH
6809: LD_INT 111
6811: PPUSH
6812: LD_INT 9
6814: PPUSH
6815: LD_INT 0
6817: PPUSH
6818: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
6822: LD_ADDR_VAR 0 5
6826: PUSH
6827: LD_INT 126
6829: PPUSH
6830: LD_INT 4
6832: PPUSH
6833: LD_STRING zhukov
6835: PPUSH
6836: LD_INT 9
6838: PUSH
6839: LD_INT 10
6841: PUSH
6842: LD_INT 10
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: PUSH
6850: LD_OWVAR 67
6854: ARRAY
6855: PPUSH
6856: LD_INT 99999
6858: PUSH
6859: LD_INT 1000
6861: PUSH
6862: LD_INT 300
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: LIST
6869: PPUSH
6870: LD_INT 12
6872: PUSH
6873: LD_INT 8
6875: PUSH
6876: LD_INT 13
6878: PUSH
6879: LD_INT 8
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: LIST
6886: LIST
6887: PPUSH
6888: CALL 71013 0 6
6892: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
6893: LD_ADDR_VAR 0 4
6897: PUSH
6898: LD_INT 267
6900: PPUSH
6901: CALL_OW 274
6905: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
6906: LD_VAR 0 4
6910: PPUSH
6911: LD_INT 1
6913: PPUSH
6914: LD_INT 5000
6916: PPUSH
6917: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
6921: LD_VAR 0 4
6925: PPUSH
6926: LD_INT 2
6928: PPUSH
6929: LD_INT 200
6931: PPUSH
6932: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
6936: LD_VAR 0 4
6940: PPUSH
6941: LD_INT 3
6943: PPUSH
6944: LD_INT 200
6946: PPUSH
6947: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
6951: LD_ADDR_EXP 99
6955: PUSH
6956: LD_EXP 99
6960: PPUSH
6961: LD_INT 2
6963: PPUSH
6964: LD_VAR 0 5
6968: PUSH
6969: LD_INT 22
6971: PUSH
6972: LD_VAR 0 6
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: LD_INT 21
6986: PUSH
6987: LD_INT 2
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: PPUSH
7002: CALL_OW 69
7006: UNION
7007: PUSH
7008: LD_EXP 61
7012: DIFF
7013: PPUSH
7014: CALL_OW 1
7018: ST_TO_ADDR
// behemoths := [ ] ;
7019: LD_ADDR_EXP 69
7023: PUSH
7024: EMPTY
7025: ST_TO_ADDR
// behemothBuilders := [ ] ;
7026: LD_ADDR_EXP 70
7030: PUSH
7031: EMPTY
7032: ST_TO_ADDR
// if Kovalyuk then
7033: LD_EXP 62
7037: IFFALSE 7059
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7039: LD_ADDR_EXP 70
7043: PUSH
7044: LD_EXP 70
7048: PPUSH
7049: LD_EXP 62
7053: PPUSH
7054: CALL 103287 0 2
7058: ST_TO_ADDR
// j := 3 ;
7059: LD_ADDR_VAR 0 3
7063: PUSH
7064: LD_INT 3
7066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7067: LD_ADDR_VAR 0 2
7071: PUSH
7072: LD_INT 22
7074: PUSH
7075: LD_INT 3
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 25
7084: PUSH
7085: LD_INT 3
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL_OW 69
7100: PUSH
7101: LD_EXP 62
7105: DIFF
7106: PUSH
7107: FOR_IN
7108: IFFALSE 7158
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7110: LD_ADDR_EXP 70
7114: PUSH
7115: LD_EXP 70
7119: PPUSH
7120: LD_VAR 0 2
7124: PPUSH
7125: CALL 103287 0 2
7129: ST_TO_ADDR
// j := j - 1 ;
7130: LD_ADDR_VAR 0 3
7134: PUSH
7135: LD_VAR 0 3
7139: PUSH
7140: LD_INT 1
7142: MINUS
7143: ST_TO_ADDR
// if j = 0 then
7144: LD_VAR 0 3
7148: PUSH
7149: LD_INT 0
7151: EQUAL
7152: IFFALSE 7156
// break ;
7154: GO 7158
// end ;
7156: GO 7107
7158: POP
7159: POP
// end ;
7160: LD_VAR 0 1
7164: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7165: LD_INT 0
7167: PPUSH
7168: PPUSH
7169: PPUSH
7170: PPUSH
7171: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 209
7179: PUSH
7180: LD_INT 149
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: LD_INT 219
7189: PUSH
7190: LD_INT 154
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: PUSH
7197: LD_INT 223
7199: PUSH
7200: LD_INT 149
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 232
7209: PUSH
7210: LD_INT 155
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: LIST
7221: LIST
7222: ST_TO_ADDR
// if not behemothBuilders then
7223: LD_EXP 70
7227: NOT
7228: IFFALSE 7232
// exit ;
7230: GO 7336
// j := 1 ;
7232: LD_ADDR_VAR 0 3
7236: PUSH
7237: LD_INT 1
7239: ST_TO_ADDR
// for i in behemothBuilders do
7240: LD_ADDR_VAR 0 2
7244: PUSH
7245: LD_EXP 70
7249: PUSH
7250: FOR_IN
7251: IFFALSE 7334
// begin if IsInUnit ( i ) then
7253: LD_VAR 0 2
7257: PPUSH
7258: CALL_OW 310
7262: IFFALSE 7273
// ComExitBuilding ( i ) ;
7264: LD_VAR 0 2
7268: PPUSH
7269: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7273: LD_VAR 0 2
7277: PPUSH
7278: LD_INT 37
7280: PPUSH
7281: LD_VAR 0 4
7285: PUSH
7286: LD_VAR 0 3
7290: ARRAY
7291: PUSH
7292: LD_INT 1
7294: ARRAY
7295: PPUSH
7296: LD_VAR 0 4
7300: PUSH
7301: LD_VAR 0 3
7305: ARRAY
7306: PUSH
7307: LD_INT 2
7309: ARRAY
7310: PPUSH
7311: LD_INT 0
7313: PPUSH
7314: CALL_OW 230
// j := j + 1 ;
7318: LD_ADDR_VAR 0 3
7322: PUSH
7323: LD_VAR 0 3
7327: PUSH
7328: LD_INT 1
7330: PLUS
7331: ST_TO_ADDR
// end ;
7332: GO 7250
7334: POP
7335: POP
// end ;
7336: LD_VAR 0 1
7340: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7341: LD_INT 24
7343: PPUSH
7344: LD_INT 30
7346: PUSH
7347: LD_INT 37
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PPUSH
7354: CALL_OW 70
7358: IFFALSE 7371
7360: GO 7362
7362: DISABLE
// behemothUnderConstruct := true ;
7363: LD_ADDR_EXP 26
7367: PUSH
7368: LD_INT 1
7370: ST_TO_ADDR
7371: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7372: LD_INT 3
7374: PPUSH
7375: CALL 103335 0 1
7379: PUSH
7380: LD_INT 22
7382: PUSH
7383: LD_INT 3
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: PUSH
7390: LD_INT 30
7392: PUSH
7393: LD_INT 37
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PPUSH
7404: CALL_OW 69
7408: NOT
7409: AND
7410: IFFALSE 7596
7412: GO 7414
7414: DISABLE
7415: LD_INT 0
7417: PPUSH
7418: PPUSH
// begin enable ;
7419: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7420: LD_ADDR_VAR 0 2
7424: PUSH
7425: LD_INT 3
7427: PPUSH
7428: CALL 103335 0 1
7432: ST_TO_ADDR
// for i in tmp do
7433: LD_ADDR_VAR 0 1
7437: PUSH
7438: LD_VAR 0 2
7442: PUSH
7443: FOR_IN
7444: IFFALSE 7594
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7446: LD_VAR 0 1
7450: PPUSH
7451: LD_INT 9
7453: PPUSH
7454: CALL_OW 308
7458: PUSH
7459: LD_VAR 0 1
7463: PPUSH
7464: CALL_OW 110
7468: PUSH
7469: LD_INT 2
7471: EQUAL
7472: NOT
7473: AND
7474: IFFALSE 7488
// SetTag ( i , 2 ) ;
7476: LD_VAR 0 1
7480: PPUSH
7481: LD_INT 2
7483: PPUSH
7484: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7488: LD_INT 81
7490: PUSH
7491: LD_INT 3
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PUSH
7498: LD_INT 91
7500: PUSH
7501: LD_VAR 0 1
7505: PUSH
7506: LD_INT 12
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: LIST
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PPUSH
7518: CALL_OW 69
7522: NOT
7523: PUSH
7524: LD_VAR 0 1
7528: PPUSH
7529: CALL_OW 110
7533: PUSH
7534: LD_INT 2
7536: EQUAL
7537: NOT
7538: AND
7539: IFFALSE 7558
// ComAgressiveMove ( i , 64 , 93 ) else
7541: LD_VAR 0 1
7545: PPUSH
7546: LD_INT 64
7548: PPUSH
7549: LD_INT 93
7551: PPUSH
7552: CALL_OW 114
7556: GO 7592
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: LD_INT 81
7565: PUSH
7566: LD_INT 3
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: PPUSH
7573: CALL_OW 69
7577: PPUSH
7578: LD_VAR 0 1
7582: PPUSH
7583: CALL_OW 74
7587: PPUSH
7588: CALL_OW 115
// end ;
7592: GO 7443
7594: POP
7595: POP
// end ;
7596: PPOPN 2
7598: END
// export function PrepareRussianAttack ( strength ) ; var i ; begin
7599: LD_INT 0
7601: PPUSH
7602: PPUSH
// result := [ ] ;
7603: LD_ADDR_VAR 0 2
7607: PUSH
7608: EMPTY
7609: ST_TO_ADDR
// uc_side := 6 ;
7610: LD_ADDR_OWVAR 20
7614: PUSH
7615: LD_INT 6
7617: ST_TO_ADDR
// uc_nation := 3 ;
7618: LD_ADDR_OWVAR 21
7622: PUSH
7623: LD_INT 3
7625: ST_TO_ADDR
// case strength of 1 :
7626: LD_VAR 0 1
7630: PUSH
7631: LD_INT 1
7633: DOUBLE
7634: EQUAL
7635: IFTRUE 7639
7637: GO 7777
7639: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7640: LD_ADDR_VAR 0 3
7644: PUSH
7645: DOUBLE
7646: LD_INT 1
7648: DEC
7649: ST_TO_ADDR
7650: LD_INT 4
7652: PUSH
7653: LD_INT 5
7655: PUSH
7656: LD_INT 6
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: LIST
7663: PUSH
7664: LD_OWVAR 67
7668: ARRAY
7669: PUSH
7670: FOR_TO
7671: IFFALSE 7773
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7673: LD_INT 22
7675: PUSH
7676: LD_INT 24
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PUSH
7683: LD_VAR 0 3
7687: PUSH
7688: LD_INT 2
7690: MOD
7691: PUSH
7692: LD_INT 1
7694: PLUS
7695: ARRAY
7696: PPUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 3
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 1
7709: PPUSH
7710: LD_INT 2
7712: PPUSH
7713: CALL_OW 12
7717: ARRAY
7718: PPUSH
7719: LD_INT 3
7721: PPUSH
7722: LD_INT 43
7724: PUSH
7725: LD_INT 44
7727: PUSH
7728: LD_INT 45
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 1
7738: PPUSH
7739: LD_INT 3
7741: PPUSH
7742: CALL_OW 12
7746: ARRAY
7747: PPUSH
7748: LD_INT 80
7750: PPUSH
7751: CALL 67604 0 5
// result := result union CreateVehicle ;
7755: LD_ADDR_VAR 0 2
7759: PUSH
7760: LD_VAR 0 2
7764: PUSH
7765: CALL_OW 45
7769: UNION
7770: ST_TO_ADDR
// end ;
7771: GO 7670
7773: POP
7774: POP
// end ; 2 :
7775: GO 8681
7777: LD_INT 2
7779: DOUBLE
7780: EQUAL
7781: IFTRUE 7785
7783: GO 7941
7785: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
7786: LD_ADDR_VAR 0 3
7790: PUSH
7791: DOUBLE
7792: LD_INT 1
7794: DEC
7795: ST_TO_ADDR
7796: LD_INT 6
7798: PUSH
7799: LD_INT 6
7801: PUSH
7802: LD_INT 7
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: LIST
7809: PUSH
7810: LD_OWVAR 67
7814: ARRAY
7815: PUSH
7816: FOR_TO
7817: IFFALSE 7937
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
7819: LD_INT 22
7821: PUSH
7822: LD_INT 24
7824: PUSH
7825: LD_INT 24
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PUSH
7833: LD_VAR 0 3
7837: PUSH
7838: LD_INT 3
7840: MOD
7841: PUSH
7842: LD_INT 1
7844: PLUS
7845: ARRAY
7846: PPUSH
7847: LD_INT 1
7849: PUSH
7850: LD_INT 3
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: LD_INT 1
7859: PPUSH
7860: LD_INT 2
7862: PPUSH
7863: CALL_OW 12
7867: ARRAY
7868: PPUSH
7869: LD_INT 3
7871: PPUSH
7872: LD_INT 43
7874: PUSH
7875: LD_INT 44
7877: PUSH
7878: LD_INT 45
7880: PUSH
7881: LD_INT 44
7883: PUSH
7884: LD_INT 46
7886: PUSH
7887: LD_INT 46
7889: PUSH
7890: EMPTY
7891: LIST
7892: LIST
7893: LIST
7894: LIST
7895: LIST
7896: LIST
7897: PUSH
7898: LD_VAR 0 3
7902: PUSH
7903: LD_INT 6
7905: MOD
7906: PUSH
7907: LD_INT 1
7909: PLUS
7910: ARRAY
7911: PPUSH
7912: LD_INT 80
7914: PPUSH
7915: CALL 67604 0 5
// result := result union CreateVehicle ;
7919: LD_ADDR_VAR 0 2
7923: PUSH
7924: LD_VAR 0 2
7928: PUSH
7929: CALL_OW 45
7933: UNION
7934: ST_TO_ADDR
// end ;
7935: GO 7816
7937: POP
7938: POP
// end ; 3 :
7939: GO 8681
7941: LD_INT 3
7943: DOUBLE
7944: EQUAL
7945: IFTRUE 7949
7947: GO 8105
7949: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
7950: LD_ADDR_VAR 0 3
7954: PUSH
7955: DOUBLE
7956: LD_INT 1
7958: DEC
7959: ST_TO_ADDR
7960: LD_INT 6
7962: PUSH
7963: LD_INT 7
7965: PUSH
7966: LD_INT 8
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: PUSH
7974: LD_OWVAR 67
7978: ARRAY
7979: PUSH
7980: FOR_TO
7981: IFFALSE 8101
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
7983: LD_INT 22
7985: PUSH
7986: LD_INT 24
7988: PUSH
7989: LD_INT 24
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: LIST
7996: PUSH
7997: LD_VAR 0 3
8001: PUSH
8002: LD_INT 3
8004: MOD
8005: PUSH
8006: LD_INT 1
8008: PLUS
8009: ARRAY
8010: PPUSH
8011: LD_INT 1
8013: PUSH
8014: LD_INT 3
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 1
8023: PPUSH
8024: LD_INT 2
8026: PPUSH
8027: CALL_OW 12
8031: ARRAY
8032: PPUSH
8033: LD_INT 3
8035: PPUSH
8036: LD_INT 43
8038: PUSH
8039: LD_INT 47
8041: PUSH
8042: LD_INT 45
8044: PUSH
8045: LD_INT 45
8047: PUSH
8048: LD_INT 46
8050: PUSH
8051: LD_INT 46
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: LIST
8061: PUSH
8062: LD_VAR 0 3
8066: PUSH
8067: LD_INT 6
8069: MOD
8070: PUSH
8071: LD_INT 1
8073: PLUS
8074: ARRAY
8075: PPUSH
8076: LD_INT 80
8078: PPUSH
8079: CALL 67604 0 5
// result := result union CreateVehicle ;
8083: LD_ADDR_VAR 0 2
8087: PUSH
8088: LD_VAR 0 2
8092: PUSH
8093: CALL_OW 45
8097: UNION
8098: ST_TO_ADDR
// end ;
8099: GO 7980
8101: POP
8102: POP
// end ; 4 :
8103: GO 8681
8105: LD_INT 4
8107: DOUBLE
8108: EQUAL
8109: IFTRUE 8113
8111: GO 8680
8113: POP
// begin uc_nation := 3 ;
8114: LD_ADDR_OWVAR 21
8118: PUSH
8119: LD_INT 3
8121: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8122: LD_ADDR_VAR 0 3
8126: PUSH
8127: DOUBLE
8128: LD_INT 1
8130: DEC
8131: ST_TO_ADDR
8132: LD_INT 7
8134: PUSH
8135: LD_INT 8
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: PUSH
8146: LD_OWVAR 67
8150: ARRAY
8151: PUSH
8152: FOR_TO
8153: IFFALSE 8273
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8155: LD_INT 22
8157: PUSH
8158: LD_INT 24
8160: PUSH
8161: LD_INT 24
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: LD_VAR 0 3
8173: PUSH
8174: LD_INT 3
8176: MOD
8177: PUSH
8178: LD_INT 1
8180: PLUS
8181: ARRAY
8182: PPUSH
8183: LD_INT 1
8185: PUSH
8186: LD_INT 3
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PUSH
8193: LD_INT 1
8195: PPUSH
8196: LD_INT 2
8198: PPUSH
8199: CALL_OW 12
8203: ARRAY
8204: PPUSH
8205: LD_INT 3
8207: PPUSH
8208: LD_INT 45
8210: PUSH
8211: LD_INT 47
8213: PUSH
8214: LD_INT 47
8216: PUSH
8217: LD_INT 45
8219: PUSH
8220: LD_INT 46
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_VAR 0 3
8238: PUSH
8239: LD_INT 6
8241: MOD
8242: PUSH
8243: LD_INT 1
8245: PLUS
8246: ARRAY
8247: PPUSH
8248: LD_INT 80
8250: PPUSH
8251: CALL 67604 0 5
// result := result union CreateVehicle ;
8255: LD_ADDR_VAR 0 2
8259: PUSH
8260: LD_VAR 0 2
8264: PUSH
8265: CALL_OW 45
8269: UNION
8270: ST_TO_ADDR
// end ;
8271: GO 8152
8273: POP
8274: POP
// if not KappaStatus then
8275: LD_EXP 2
8279: NOT
8280: IFFALSE 8475
// begin uc_nation := 1 ;
8282: LD_ADDR_OWVAR 21
8286: PUSH
8287: LD_INT 1
8289: ST_TO_ADDR
// for i = 1 to 3 do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 3
8302: PUSH
8303: FOR_TO
8304: IFFALSE 8400
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 85 ) ;
8306: LD_INT 3
8308: PUSH
8309: LD_INT 5
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: PUSH
8316: LD_INT 1
8318: PPUSH
8319: LD_INT 2
8321: PPUSH
8322: CALL_OW 12
8326: ARRAY
8327: PPUSH
8328: LD_INT 1
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 1
8340: PPUSH
8341: LD_INT 2
8343: PPUSH
8344: CALL_OW 12
8348: ARRAY
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: LD_INT 9
8355: PUSH
8356: LD_INT 7
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: PUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 2
8368: PPUSH
8369: CALL_OW 12
8373: ARRAY
8374: PPUSH
8375: LD_INT 85
8377: PPUSH
8378: CALL 67604 0 5
// result := result union CreateVehicle ;
8382: LD_ADDR_VAR 0 2
8386: PUSH
8387: LD_VAR 0 2
8391: PUSH
8392: CALL_OW 45
8396: UNION
8397: ST_TO_ADDR
// end ;
8398: GO 8303
8400: POP
8401: POP
// if vsevolodFirstAttack then
8402: LD_EXP 24
8406: IFFALSE 8473
// begin vsevolodFirstAttack := false ;
8408: LD_ADDR_EXP 24
8412: PUSH
8413: LD_INT 0
8415: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8416: LD_INT 5
8418: PPUSH
8419: LD_INT 3
8421: PPUSH
8422: LD_INT 1
8424: PPUSH
8425: LD_INT 6
8427: PPUSH
8428: LD_INT 100
8430: PPUSH
8431: CALL 67604 0 5
// sewiVeh := CreateVehicle ;
8435: LD_ADDR_EXP 68
8439: PUSH
8440: CALL_OW 45
8444: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8445: LD_EXP 68
8449: PPUSH
8450: LD_INT 1
8452: PPUSH
8453: CALL_OW 242
// result := result union sewiVeh ;
8457: LD_ADDR_VAR 0 2
8461: PUSH
8462: LD_VAR 0 2
8466: PUSH
8467: LD_EXP 68
8471: UNION
8472: ST_TO_ADDR
// end ; end else
8473: GO 8678
// if vsevolodFirstAttack then
8475: LD_EXP 24
8479: IFFALSE 8678
// begin vsevolodFirstAttack := false ;
8481: LD_ADDR_EXP 24
8485: PUSH
8486: LD_INT 0
8488: ST_TO_ADDR
// uc_nation := 3 ;
8489: LD_ADDR_OWVAR 21
8493: PUSH
8494: LD_INT 3
8496: ST_TO_ADDR
// for i = 1 to 3 do
8497: LD_ADDR_VAR 0 3
8501: PUSH
8502: DOUBLE
8503: LD_INT 1
8505: DEC
8506: ST_TO_ADDR
8507: LD_INT 3
8509: PUSH
8510: FOR_TO
8511: IFFALSE 8619
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8513: LD_INT 22
8515: PUSH
8516: LD_INT 24
8518: PUSH
8519: LD_INT 24
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: LIST
8526: PUSH
8527: LD_VAR 0 3
8531: PUSH
8532: LD_INT 3
8534: MOD
8535: PUSH
8536: LD_INT 1
8538: PLUS
8539: ARRAY
8540: PPUSH
8541: LD_INT 1
8543: PUSH
8544: LD_INT 3
8546: PUSH
8547: EMPTY
8548: LIST
8549: LIST
8550: PUSH
8551: LD_INT 1
8553: PPUSH
8554: LD_INT 2
8556: PPUSH
8557: CALL_OW 12
8561: ARRAY
8562: PPUSH
8563: LD_INT 3
8565: PPUSH
8566: LD_INT 45
8568: PUSH
8569: LD_INT 47
8571: PUSH
8572: LD_INT 47
8574: PUSH
8575: EMPTY
8576: LIST
8577: LIST
8578: LIST
8579: PUSH
8580: LD_VAR 0 3
8584: PUSH
8585: LD_INT 3
8587: MOD
8588: PUSH
8589: LD_INT 1
8591: PLUS
8592: ARRAY
8593: PPUSH
8594: LD_INT 80
8596: PPUSH
8597: CALL 67604 0 5
// result := result union CreateVehicle ;
8601: LD_ADDR_VAR 0 2
8605: PUSH
8606: LD_VAR 0 2
8610: PUSH
8611: CALL_OW 45
8615: UNION
8616: ST_TO_ADDR
// end ;
8617: GO 8510
8619: POP
8620: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8621: LD_INT 24
8623: PPUSH
8624: LD_INT 3
8626: PPUSH
8627: LD_INT 1
8629: PPUSH
8630: LD_INT 47
8632: PPUSH
8633: LD_INT 100
8635: PPUSH
8636: CALL 67604 0 5
// sewiVeh := CreateVehicle ;
8640: LD_ADDR_EXP 68
8644: PUSH
8645: CALL_OW 45
8649: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8650: LD_EXP 68
8654: PPUSH
8655: LD_INT 1
8657: PPUSH
8658: CALL_OW 242
// result := result union sewiVeh ;
8662: LD_ADDR_VAR 0 2
8666: PUSH
8667: LD_VAR 0 2
8671: PUSH
8672: LD_EXP 68
8676: UNION
8677: ST_TO_ADDR
// end ; end ; end ;
8678: GO 8681
8680: POP
// end ;
8681: LD_VAR 0 2
8685: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy , x , y ;
8686: LD_EXP 16
8690: IFFALSE 9379
8692: GO 8694
8694: DISABLE
8695: LD_INT 0
8697: PPUSH
8698: PPUSH
8699: PPUSH
8700: PPUSH
8701: PPUSH
8702: PPUSH
8703: PPUSH
8704: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
8705: LD_ADDR_VAR 0 4
8709: PUSH
8710: LD_INT 11
8712: PUSH
8713: LD_INT 12
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
8720: LD_ADDR_VAR 0 3
8724: PUSH
8725: LD_INT 8400
8727: PUSH
8728: LD_INT 7350
8730: PUSH
8731: LD_INT 6650
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PUSH
8739: LD_OWVAR 67
8743: ARRAY
8744: ST_TO_ADDR
// xy := [ 60 , 96 ] ;
8745: LD_ADDR_VAR 0 6
8749: PUSH
8750: LD_INT 60
8752: PUSH
8753: LD_INT 96
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: ST_TO_ADDR
// repeat if missionStage = 2 then
8760: LD_EXP 15
8764: PUSH
8765: LD_INT 2
8767: EQUAL
8768: IFFALSE 8779
// wait ( 1 1$30 ) else
8770: LD_INT 3150
8772: PPUSH
8773: CALL_OW 67
8777: GO 8788
// wait ( time ) ;
8779: LD_VAR 0 3
8783: PPUSH
8784: CALL_OW 67
// if missionStage = 6 then
8788: LD_EXP 15
8792: PUSH
8793: LD_INT 6
8795: EQUAL
8796: IFFALSE 8824
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
8798: LD_INT 51
8800: PPUSH
8801: LD_INT 6
8803: PPUSH
8804: LD_INT 2
8806: PPUSH
8807: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
8811: LD_INT 57
8813: PPUSH
8814: LD_INT 6
8816: PPUSH
8817: LD_INT 2
8819: PPUSH
8820: CALL_OW 322
// end ; if missionStage = 8 then
8824: LD_EXP 15
8828: PUSH
8829: LD_INT 8
8831: EQUAL
8832: IFFALSE 8860
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
8834: LD_INT 52
8836: PPUSH
8837: LD_INT 6
8839: PPUSH
8840: LD_INT 2
8842: PPUSH
8843: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
8847: LD_INT 58
8849: PPUSH
8850: LD_INT 6
8852: PPUSH
8853: LD_INT 2
8855: PPUSH
8856: CALL_OW 322
// end ; if missionStage = 10 then
8860: LD_EXP 15
8864: PUSH
8865: LD_INT 10
8867: EQUAL
8868: IFFALSE 8896
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
8870: LD_INT 53
8872: PPUSH
8873: LD_INT 6
8875: PPUSH
8876: LD_INT 2
8878: PPUSH
8879: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
8883: LD_INT 59
8885: PPUSH
8886: LD_INT 6
8888: PPUSH
8889: LD_INT 2
8891: PPUSH
8892: CALL_OW 322
// end ; if activeAttacks then
8896: LD_EXP 16
8900: IFFALSE 9373
// begin if missionStage = 2 then
8902: LD_EXP 15
8906: PUSH
8907: LD_INT 2
8909: EQUAL
8910: IFFALSE 8920
// strength := 1 ;
8912: LD_ADDR_VAR 0 5
8916: PUSH
8917: LD_INT 1
8919: ST_TO_ADDR
// if missionStage > 2 then
8920: LD_EXP 15
8924: PUSH
8925: LD_INT 2
8927: GREATER
8928: IFFALSE 8938
// strength := 2 ;
8930: LD_ADDR_VAR 0 5
8934: PUSH
8935: LD_INT 2
8937: ST_TO_ADDR
// if missionStage > 6 then
8938: LD_EXP 15
8942: PUSH
8943: LD_INT 6
8945: GREATER
8946: IFFALSE 8956
// strength := 3 ;
8948: LD_ADDR_VAR 0 5
8952: PUSH
8953: LD_INT 3
8955: ST_TO_ADDR
// if missionStage > 10 then
8956: LD_EXP 15
8960: PUSH
8961: LD_INT 10
8963: GREATER
8964: IFFALSE 8974
// strength := 4 ;
8966: LD_ADDR_VAR 0 5
8970: PUSH
8971: LD_INT 4
8973: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
8974: LD_ADDR_VAR 0 2
8978: PUSH
8979: LD_VAR 0 5
8983: PPUSH
8984: CALL 7599 0 1
8988: ST_TO_ADDR
// for i in tmp do
8989: LD_ADDR_VAR 0 1
8993: PUSH
8994: LD_VAR 0 2
8998: PUSH
8999: FOR_IN
9000: IFFALSE 9100
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: LD_VAR 0 4
9011: PUSH
9012: LD_INT 1
9014: PPUSH
9015: LD_INT 2
9017: PPUSH
9018: CALL_OW 12
9022: ARRAY
9023: PPUSH
9024: LD_INT 0
9026: PPUSH
9027: CALL_OW 49
// if i = sewiVeh then
9031: LD_VAR 0 1
9035: PUSH
9036: LD_EXP 68
9040: EQUAL
9041: IFFALSE 9076
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9043: LD_ADDR_EXP 67
9047: PUSH
9048: LD_STRING Vsevolod
9050: PPUSH
9051: LD_INT 0
9053: PPUSH
9054: LD_STRING 
9056: PPUSH
9057: CALL 60971 0 3
9061: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9062: LD_EXP 67
9066: PPUSH
9067: LD_VAR 0 1
9071: PPUSH
9072: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9076: LD_VAR 0 1
9080: PPUSH
9081: LD_INT 111
9083: PPUSH
9084: LD_INT 197
9086: PPUSH
9087: CALL_OW 111
// wait ( 0 0$2 ) ;
9091: LD_INT 70
9093: PPUSH
9094: CALL_OW 67
// end ;
9098: GO 8999
9100: POP
9101: POP
// repeat wait ( 0 0$1 ) ;
9102: LD_INT 35
9104: PPUSH
9105: CALL_OW 67
// for i in tmp do
9109: LD_ADDR_VAR 0 1
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: FOR_IN
9120: IFFALSE 9354
// begin x := GetX ( i ) ;
9122: LD_ADDR_VAR 0 7
9126: PUSH
9127: LD_VAR 0 1
9131: PPUSH
9132: CALL_OW 250
9136: ST_TO_ADDR
// y := GetY ( i ) ;
9137: LD_ADDR_VAR 0 8
9141: PUSH
9142: LD_VAR 0 1
9146: PPUSH
9147: CALL_OW 251
9151: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) then
9152: LD_INT 81
9154: PUSH
9155: LD_INT 6
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: PUSH
9162: LD_INT 92
9164: PUSH
9165: LD_VAR 0 7
9169: PUSH
9170: LD_VAR 0 8
9174: PUSH
9175: LD_INT 12
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: LIST
9182: LIST
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: PPUSH
9188: CALL_OW 69
9192: IFFALSE 9256
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) , i ) ) else
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 81
9201: PUSH
9202: LD_INT 6
9204: PUSH
9205: EMPTY
9206: LIST
9207: LIST
9208: PUSH
9209: LD_INT 92
9211: PUSH
9212: LD_VAR 0 7
9216: PUSH
9217: LD_VAR 0 8
9221: PUSH
9222: LD_INT 12
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PPUSH
9235: CALL_OW 69
9239: PPUSH
9240: LD_VAR 0 1
9244: PPUSH
9245: CALL_OW 74
9249: PPUSH
9250: CALL_OW 115
9254: GO 9352
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 10 then
9256: LD_VAR 0 1
9260: PPUSH
9261: LD_VAR 0 6
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: PPUSH
9270: LD_VAR 0 6
9274: PUSH
9275: LD_INT 2
9277: ARRAY
9278: PPUSH
9279: CALL_OW 297
9283: PUSH
9284: LD_INT 10
9286: GREATER
9287: IFFALSE 9318
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) else
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_VAR 0 6
9298: PUSH
9299: LD_INT 1
9301: ARRAY
9302: PPUSH
9303: LD_VAR 0 6
9307: PUSH
9308: LD_INT 2
9310: ARRAY
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 6
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9119
9354: POP
9355: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9356: LD_INT 22
9358: PUSH
9359: LD_INT 6
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PPUSH
9366: CALL_OW 69
9370: NOT
9371: IFFALSE 9102
// end ; until russianDestroyed ;
9373: LD_EXP 21
9377: IFFALSE 8760
// end ;
9379: PPOPN 8
9381: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport ;
9382: LD_EXP 21
9386: NOT
9387: PUSH
9388: LD_EXP 15
9392: PUSH
9393: LD_INT 6
9395: GREATEREQUAL
9396: AND
9397: IFFALSE 10277
9399: GO 9401
9401: DISABLE
9402: LD_INT 0
9404: PPUSH
9405: PPUSH
9406: PPUSH
9407: PPUSH
// begin enable ;
9408: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) then
9409: LD_INT 22
9411: PUSH
9412: LD_INT 3
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: PUSH
9419: LD_INT 23
9421: PUSH
9422: LD_INT 3
9424: PUSH
9425: EMPTY
9426: LIST
9427: LIST
9428: PUSH
9429: LD_INT 30
9431: PUSH
9432: LD_INT 3
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PPUSH
9444: CALL_OW 69
9448: NOT
9449: IFFALSE 9453
// exit ;
9451: GO 10277
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9453: LD_ADDR_VAR 0 4
9457: PUSH
9458: LD_INT 22
9460: PUSH
9461: LD_INT 3
9463: PUSH
9464: EMPTY
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 30
9470: PUSH
9471: LD_INT 34
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: PPUSH
9482: CALL_OW 69
9486: ST_TO_ADDR
// if Prob ( 40 ) then
9487: LD_INT 40
9489: PPUSH
9490: CALL_OW 13
9494: IFFALSE 9621
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9496: LD_INT 2
9498: PPUSH
9499: LD_INT 22
9501: PUSH
9502: LD_INT 3
9504: PUSH
9505: LD_INT 3
9507: PUSH
9508: LD_INT 49
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: PUSH
9517: LD_INT 22
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 3
9525: PUSH
9526: LD_INT 49
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: LIST
9533: LIST
9534: PUSH
9535: LD_INT 22
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 3
9543: PUSH
9544: LD_INT 49
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: PUSH
9553: LD_INT 24
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 3
9561: PUSH
9562: LD_INT 46
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 24
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 3
9579: PUSH
9580: LD_INT 46
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: PUSH
9589: LD_INT 24
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 3
9597: PUSH
9598: LD_INT 46
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: PPUSH
9615: CALL 55076 0 2
// end else
9619: GO 9744
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9621: LD_INT 2
9623: PPUSH
9624: LD_INT 24
9626: PUSH
9627: LD_INT 3
9629: PUSH
9630: LD_INT 3
9632: PUSH
9633: LD_INT 47
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_INT 24
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 3
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: PUSH
9660: LD_INT 24
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 3
9668: PUSH
9669: LD_INT 47
9671: PUSH
9672: EMPTY
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: PUSH
9678: LD_INT 24
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 3
9686: PUSH
9687: LD_INT 46
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: PUSH
9696: LD_INT 24
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 3
9704: PUSH
9705: LD_INT 46
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 24
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 3
9722: PUSH
9723: LD_INT 46
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: PUSH
9732: EMPTY
9733: LIST
9734: LIST
9735: LIST
9736: LIST
9737: LIST
9738: LIST
9739: PPUSH
9740: CALL 55076 0 2
// end ; if Difficulty > 1 then
9744: LD_OWVAR 67
9748: PUSH
9749: LD_INT 1
9751: GREATER
9752: IFFALSE 9782
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9754: LD_INT 2
9756: PPUSH
9757: LD_INT 24
9759: PUSH
9760: LD_INT 3
9762: PUSH
9763: LD_INT 3
9765: PUSH
9766: LD_INT 47
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: LIST
9773: LIST
9774: PUSH
9775: EMPTY
9776: LIST
9777: PPUSH
9778: CALL 55076 0 2
// repeat wait ( 0 0$1 ) ;
9782: LD_INT 35
9784: PPUSH
9785: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9789: LD_INT 2
9791: PPUSH
9792: LD_INT 1
9794: PPUSH
9795: CALL 56489 0 2
9799: PUSH
9800: LD_INT 6
9802: PUSH
9803: LD_INT 7
9805: PUSH
9806: LD_INT 7
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: LIST
9813: PUSH
9814: LD_OWVAR 67
9818: ARRAY
9819: GREATEREQUAL
9820: IFFALSE 9782
// wait ( 0 0$30 ) ;
9822: LD_INT 1050
9824: PPUSH
9825: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9829: LD_ADDR_VAR 0 2
9833: PUSH
9834: LD_INT 2
9836: PPUSH
9837: LD_INT 1
9839: PPUSH
9840: CALL 56489 0 2
9844: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9845: LD_ADDR_EXP 118
9849: PUSH
9850: LD_EXP 118
9854: PPUSH
9855: LD_INT 2
9857: PPUSH
9858: LD_EXP 118
9862: PUSH
9863: LD_INT 2
9865: ARRAY
9866: PUSH
9867: LD_VAR 0 2
9871: DIFF
9872: PPUSH
9873: CALL_OW 1
9877: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9878: LD_ADDR_VAR 0 3
9882: PUSH
9883: LD_INT 0
9885: PPUSH
9886: LD_INT 1
9888: PPUSH
9889: CALL_OW 12
9893: ST_TO_ADDR
// if target then
9894: LD_VAR 0 3
9898: IFFALSE 9988
// begin repeat ComMoveXY ( tmp , 139 , 89 ) ;
9900: LD_VAR 0 2
9904: PPUSH
9905: LD_INT 139
9907: PPUSH
9908: LD_INT 89
9910: PPUSH
9911: CALL_OW 111
// wait ( 0 0$1 ) ;
9915: LD_INT 35
9917: PPUSH
9918: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9922: LD_ADDR_VAR 0 2
9926: PUSH
9927: LD_VAR 0 2
9931: PPUSH
9932: LD_INT 24
9934: PUSH
9935: LD_INT 250
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PPUSH
9942: CALL_OW 72
9946: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 6 ] ) >= ( tmp - 1 ) ;
9947: LD_VAR 0 2
9951: PPUSH
9952: LD_INT 92
9954: PUSH
9955: LD_INT 139
9957: PUSH
9958: LD_INT 89
9960: PUSH
9961: LD_INT 6
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: LIST
9968: LIST
9969: PPUSH
9970: CALL_OW 72
9974: PUSH
9975: LD_VAR 0 2
9979: PUSH
9980: LD_INT 1
9982: MINUS
9983: GREATEREQUAL
9984: IFFALSE 9900
// end else
9986: GO 10092
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9988: LD_VAR 0 2
9992: PPUSH
9993: LD_VAR 0 4
9997: PUSH
9998: LD_INT 1
10000: ARRAY
10001: PPUSH
10002: CALL_OW 120
// repeat AddComMoveXY ( tmp , 124 , 139 ) ;
10006: LD_VAR 0 2
10010: PPUSH
10011: LD_INT 124
10013: PPUSH
10014: LD_INT 139
10016: PPUSH
10017: CALL_OW 171
// wait ( 0 0$1 ) ;
10021: LD_INT 35
10023: PPUSH
10024: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10028: LD_ADDR_VAR 0 2
10032: PUSH
10033: LD_VAR 0 2
10037: PPUSH
10038: LD_INT 24
10040: PUSH
10041: LD_INT 250
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PPUSH
10048: CALL_OW 72
10052: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 6 ] ) >= ( tmp - 1 ) ;
10053: LD_VAR 0 2
10057: PPUSH
10058: LD_INT 92
10060: PUSH
10061: LD_INT 124
10063: PUSH
10064: LD_INT 139
10066: PUSH
10067: LD_INT 6
10069: PUSH
10070: EMPTY
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: PPUSH
10076: CALL_OW 72
10080: PUSH
10081: LD_VAR 0 2
10085: PUSH
10086: LD_INT 1
10088: MINUS
10089: GREATEREQUAL
10090: IFFALSE 10006
// end ; repeat wait ( 0 0$1 ) ;
10092: LD_INT 35
10094: PPUSH
10095: CALL_OW 67
// for i in tmp do
10099: LD_ADDR_VAR 0 1
10103: PUSH
10104: LD_VAR 0 2
10108: PUSH
10109: FOR_IN
10110: IFFALSE 10268
// if GetLives ( i ) > 251 then
10112: LD_VAR 0 1
10116: PPUSH
10117: CALL_OW 256
10121: PUSH
10122: LD_INT 251
10124: GREATER
10125: IFFALSE 10250
// begin if GetWeapon ( i ) = ru_time_lapser then
10127: LD_VAR 0 1
10131: PPUSH
10132: CALL_OW 264
10136: PUSH
10137: LD_INT 49
10139: EQUAL
10140: IFFALSE 10196
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10142: LD_VAR 0 1
10146: PPUSH
10147: LD_INT 2
10149: PUSH
10150: LD_INT 22
10152: PUSH
10153: LD_INT 1
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 22
10162: PUSH
10163: LD_INT 8
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: LIST
10174: PPUSH
10175: CALL_OW 69
10179: PPUSH
10180: LD_VAR 0 1
10184: PPUSH
10185: CALL_OW 74
10189: PPUSH
10190: CALL_OW 112
10194: GO 10248
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10196: LD_VAR 0 1
10200: PPUSH
10201: LD_INT 2
10203: PUSH
10204: LD_INT 22
10206: PUSH
10207: LD_INT 1
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PUSH
10214: LD_INT 22
10216: PUSH
10217: LD_INT 8
10219: PUSH
10220: EMPTY
10221: LIST
10222: LIST
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: LIST
10228: PPUSH
10229: CALL_OW 69
10233: PPUSH
10234: LD_VAR 0 1
10238: PPUSH
10239: CALL_OW 74
10243: PPUSH
10244: CALL_OW 115
// end else
10248: GO 10266
// tmp := tmp diff i ;
10250: LD_ADDR_VAR 0 2
10254: PUSH
10255: LD_VAR 0 2
10259: PUSH
10260: LD_VAR 0 1
10264: DIFF
10265: ST_TO_ADDR
10266: GO 10109
10268: POP
10269: POP
// until not tmp ;
10270: LD_VAR 0 2
10274: NOT
10275: IFFALSE 10092
// end ; end_of_file
10277: PPOPN 4
10279: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10280: LD_INT 0
10282: PPUSH
10283: PPUSH
10284: PPUSH
10285: PPUSH
10286: PPUSH
10287: PPUSH
// side := 7 ;
10288: LD_ADDR_VAR 0 5
10292: PUSH
10293: LD_INT 7
10295: ST_TO_ADDR
// uc_side := side ;
10296: LD_ADDR_OWVAR 20
10300: PUSH
10301: LD_VAR 0 5
10305: ST_TO_ADDR
// uc_nation := 1 ;
10306: LD_ADDR_OWVAR 21
10310: PUSH
10311: LD_INT 1
10313: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10314: LD_ADDR_VAR 0 2
10318: PUSH
10319: LD_INT 22
10321: PUSH
10322: LD_VAR 0 5
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: PUSH
10331: LD_INT 21
10333: PUSH
10334: LD_INT 3
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL_OW 69
10349: PUSH
10350: FOR_IN
10351: IFFALSE 10367
// SetBLevel ( i , 10 ) ;
10353: LD_VAR 0 2
10357: PPUSH
10358: LD_INT 10
10360: PPUSH
10361: CALL_OW 241
10365: GO 10350
10367: POP
10368: POP
// base := GetBase ( al_depot ) ;
10369: LD_ADDR_VAR 0 4
10373: PUSH
10374: LD_INT 2
10376: PPUSH
10377: CALL_OW 274
10381: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10382: LD_ADDR_VAR 0 6
10386: PUSH
10387: LD_INT 22
10389: PUSH
10390: LD_VAR 0 5
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PUSH
10399: LD_INT 30
10401: PUSH
10402: LD_INT 34
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 69
10417: ST_TO_ADDR
// if teleport then
10418: LD_VAR 0 6
10422: IFFALSE 10443
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10424: LD_VAR 0 6
10428: PUSH
10429: LD_INT 1
10431: ARRAY
10432: PPUSH
10433: LD_INT 262
10435: PPUSH
10436: LD_INT 119
10438: PPUSH
10439: CALL_OW 243
// SetResourceType ( base , mat_cans , 8500 ) ;
10443: LD_VAR 0 4
10447: PPUSH
10448: LD_INT 1
10450: PPUSH
10451: LD_INT 8500
10453: PPUSH
10454: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10458: LD_VAR 0 4
10462: PPUSH
10463: LD_INT 2
10465: PPUSH
10466: LD_INT 200
10468: PPUSH
10469: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10473: LD_VAR 0 4
10477: PPUSH
10478: LD_INT 3
10480: PPUSH
10481: LD_INT 650
10483: PPUSH
10484: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
10488: LD_ADDR_EXP 71
10492: PUSH
10493: LD_STRING Roth
10495: PPUSH
10496: CALL_OW 25
10500: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
10501: LD_ADDR_EXP 72
10505: PUSH
10506: LD_STRING Simms
10508: PPUSH
10509: LD_EXP 1
10513: NOT
10514: PPUSH
10515: LD_STRING 10c_
10517: PPUSH
10518: CALL 60971 0 3
10522: ST_TO_ADDR
// if not Simms then
10523: LD_EXP 72
10527: NOT
10528: IFFALSE 10558
// begin uc_nation := 1 ;
10530: LD_ADDR_OWVAR 21
10534: PUSH
10535: LD_INT 1
10537: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
10538: LD_INT 2
10540: PPUSH
10541: LD_INT 10
10543: PPUSH
10544: CALL_OW 384
// Simms := CreateHuman ;
10548: LD_ADDR_EXP 72
10552: PUSH
10553: CALL_OW 44
10557: ST_TO_ADDR
// end ; uc_nation := 3 ;
10558: LD_ADDR_OWVAR 21
10562: PUSH
10563: LD_INT 3
10565: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
10566: LD_ADDR_EXP 73
10570: PUSH
10571: LD_STRING Kirilenkova
10573: PPUSH
10574: CALL_OW 25
10578: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
10579: LD_ADDR_EXP 87
10583: PUSH
10584: LD_STRING Oblukov
10586: PPUSH
10587: CALL_OW 25
10591: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
10592: LD_ADDR_EXP 74
10596: PUSH
10597: LD_STRING Dolgov
10599: PPUSH
10600: CALL_OW 25
10604: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
10605: LD_ADDR_EXP 75
10609: PUSH
10610: LD_STRING Petrosyan
10612: PPUSH
10613: CALL_OW 25
10617: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
10618: LD_ADDR_EXP 86
10622: PUSH
10623: LD_STRING Scholtze
10625: PPUSH
10626: CALL_OW 25
10630: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
10631: LD_ADDR_EXP 85
10635: PUSH
10636: LD_STRING Kapitsova
10638: PPUSH
10639: CALL_OW 25
10643: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
10644: LD_ADDR_EXP 76
10648: PUSH
10649: LD_STRING Petrovova
10651: PPUSH
10652: CALL_OW 25
10656: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
10657: LD_ADDR_EXP 77
10661: PUSH
10662: LD_STRING Kuzmov
10664: PPUSH
10665: CALL_OW 25
10669: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
10670: LD_ADDR_EXP 84
10674: PUSH
10675: LD_STRING Karamazov
10677: PPUSH
10678: CALL_OW 25
10682: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
10683: LD_STRING 13_Lipshchin_1
10685: PPUSH
10686: LD_INT 0
10688: PPUSH
10689: CALL_OW 30
10693: IFFALSE 10708
// Lipshchin := NewCharacter ( Lipshchin ) ;
10695: LD_ADDR_EXP 78
10699: PUSH
10700: LD_STRING Lipshchin
10702: PPUSH
10703: CALL_OW 25
10707: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
10708: LD_STRING 13_Titov_1
10710: PPUSH
10711: LD_INT 0
10713: PPUSH
10714: CALL_OW 30
10718: IFFALSE 10733
// Titov := NewCharacter ( Titov ) ;
10720: LD_ADDR_EXP 80
10724: PUSH
10725: LD_STRING Titov
10727: PPUSH
10728: CALL_OW 25
10732: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
10733: LD_STRING 13_Gnyevko_1
10735: PPUSH
10736: LD_INT 0
10738: PPUSH
10739: CALL_OW 30
10743: IFFALSE 10758
// Gnyevko := NewCharacter ( Gnyevko ) ;
10745: LD_ADDR_EXP 79
10749: PUSH
10750: LD_STRING Gnyevko
10752: PPUSH
10753: CALL_OW 25
10757: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
10758: LD_STRING 13_Xavier_1
10760: PPUSH
10761: LD_INT 0
10763: PPUSH
10764: CALL_OW 30
10768: IFFALSE 10783
// Xavier := NewCharacter ( Xavier2 ) ;
10770: LD_ADDR_EXP 81
10774: PUSH
10775: LD_STRING Xavier2
10777: PPUSH
10778: CALL_OW 25
10782: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
10783: LD_STRING 13_Belkov_1
10785: PPUSH
10786: LD_INT 0
10788: PPUSH
10789: CALL_OW 30
10793: IFFALSE 10808
// Belkov := NewCharacter ( Belkov ) ;
10795: LD_ADDR_EXP 82
10799: PUSH
10800: LD_STRING Belkov
10802: PPUSH
10803: CALL_OW 25
10807: ST_TO_ADDR
// if not BurlakStatus then
10808: LD_EXP 9
10812: NOT
10813: IFFALSE 10828
// Burlak = NewCharacter ( Burlak ) ;
10815: LD_ADDR_EXP 83
10819: PUSH
10820: LD_STRING Burlak
10822: PPUSH
10823: CALL_OW 25
10827: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
10828: LD_ADDR_VAR 0 3
10832: PUSH
10833: LD_EXP 71
10837: PUSH
10838: LD_EXP 73
10842: PUSH
10843: LD_EXP 87
10847: PUSH
10848: LD_EXP 74
10852: PUSH
10853: LD_EXP 75
10857: PUSH
10858: LD_EXP 86
10862: PUSH
10863: LD_EXP 85
10867: PUSH
10868: LD_EXP 76
10872: PUSH
10873: LD_EXP 77
10877: PUSH
10878: LD_EXP 84
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: LIST
10891: LIST
10892: LIST
10893: LIST
10894: ST_TO_ADDR
// if Simms then
10895: LD_EXP 72
10899: IFFALSE 10917
// tmp := tmp ^ Simms ;
10901: LD_ADDR_VAR 0 3
10905: PUSH
10906: LD_VAR 0 3
10910: PUSH
10911: LD_EXP 72
10915: ADD
10916: ST_TO_ADDR
// if Titov then
10917: LD_EXP 80
10921: IFFALSE 10939
// tmp := tmp ^ Titov ;
10923: LD_ADDR_VAR 0 3
10927: PUSH
10928: LD_VAR 0 3
10932: PUSH
10933: LD_EXP 80
10937: ADD
10938: ST_TO_ADDR
// if Lipshchin then
10939: LD_EXP 78
10943: IFFALSE 10961
// tmp := tmp ^ Lipshchin ;
10945: LD_ADDR_VAR 0 3
10949: PUSH
10950: LD_VAR 0 3
10954: PUSH
10955: LD_EXP 78
10959: ADD
10960: ST_TO_ADDR
// if Gnyevko then
10961: LD_EXP 79
10965: IFFALSE 10983
// tmp := tmp ^ Gnyevko ;
10967: LD_ADDR_VAR 0 3
10971: PUSH
10972: LD_VAR 0 3
10976: PUSH
10977: LD_EXP 79
10981: ADD
10982: ST_TO_ADDR
// if Xavier then
10983: LD_EXP 81
10987: IFFALSE 11005
// tmp := tmp ^ Xavier ;
10989: LD_ADDR_VAR 0 3
10993: PUSH
10994: LD_VAR 0 3
10998: PUSH
10999: LD_EXP 81
11003: ADD
11004: ST_TO_ADDR
// if Belkov then
11005: LD_EXP 82
11009: IFFALSE 11027
// tmp := tmp ^ Belkov ;
11011: LD_ADDR_VAR 0 3
11015: PUSH
11016: LD_VAR 0 3
11020: PUSH
11021: LD_EXP 82
11025: ADD
11026: ST_TO_ADDR
// if Burlak then
11027: LD_EXP 83
11031: IFFALSE 11049
// tmp := tmp ^ Burlak ;
11033: LD_ADDR_VAR 0 3
11037: PUSH
11038: LD_VAR 0 3
11042: PUSH
11043: LD_EXP 83
11047: ADD
11048: ST_TO_ADDR
// for i = 1 to 8 do
11049: LD_ADDR_VAR 0 2
11053: PUSH
11054: DOUBLE
11055: LD_INT 1
11057: DEC
11058: ST_TO_ADDR
11059: LD_INT 8
11061: PUSH
11062: FOR_TO
11063: IFFALSE 11129
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11065: LD_ADDR_OWVAR 21
11069: PUSH
11070: LD_INT 1
11072: PUSH
11073: LD_INT 3
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: PUSH
11080: LD_INT 1
11082: PPUSH
11083: LD_INT 2
11085: PPUSH
11086: CALL_OW 12
11090: ARRAY
11091: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11092: LD_INT 0
11094: PPUSH
11095: LD_VAR 0 2
11099: PUSH
11100: LD_INT 2
11102: DIV
11103: PPUSH
11104: LD_INT 10
11106: PPUSH
11107: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11111: LD_ADDR_VAR 0 3
11115: PUSH
11116: LD_VAR 0 3
11120: PUSH
11121: CALL_OW 44
11125: ADD
11126: ST_TO_ADDR
// end ;
11127: GO 11062
11129: POP
11130: POP
// for i in tmp do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_VAR 0 3
11140: PUSH
11141: FOR_IN
11142: IFFALSE 11167
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11144: LD_VAR 0 2
11148: PPUSH
11149: LD_INT 260
11151: PPUSH
11152: LD_INT 235
11154: PPUSH
11155: LD_INT 8
11157: PPUSH
11158: LD_INT 0
11160: PPUSH
11161: CALL_OW 50
11165: GO 11141
11167: POP
11168: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11169: LD_ADDR_EXP 99
11173: PUSH
11174: LD_EXP 99
11178: PPUSH
11179: LD_INT 1
11181: PPUSH
11182: LD_INT 22
11184: PUSH
11185: LD_VAR 0 5
11189: PUSH
11190: EMPTY
11191: LIST
11192: LIST
11193: PUSH
11194: LD_INT 3
11196: PUSH
11197: LD_INT 21
11199: PUSH
11200: LD_INT 2
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: PUSH
11207: EMPTY
11208: LIST
11209: LIST
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PPUSH
11215: CALL_OW 69
11219: PUSH
11220: LD_EXP 71
11224: PUSH
11225: LD_EXP 72
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: DIFF
11234: PPUSH
11235: CALL_OW 1
11239: ST_TO_ADDR
// uc_side := 0 ;
11240: LD_ADDR_OWVAR 20
11244: PUSH
11245: LD_INT 0
11247: ST_TO_ADDR
// uc_nation := 0 ;
11248: LD_ADDR_OWVAR 21
11252: PUSH
11253: LD_INT 0
11255: ST_TO_ADDR
// for i = 1 to 5 do
11256: LD_ADDR_VAR 0 2
11260: PUSH
11261: DOUBLE
11262: LD_INT 1
11264: DEC
11265: ST_TO_ADDR
11266: LD_INT 5
11268: PUSH
11269: FOR_TO
11270: IFFALSE 11307
// begin InitHc ;
11272: CALL_OW 19
// hc_class := class_apeman ;
11276: LD_ADDR_OWVAR 28
11280: PUSH
11281: LD_INT 12
11283: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11284: CALL_OW 44
11288: PPUSH
11289: LD_INT 299
11291: PPUSH
11292: LD_INT 229
11294: PPUSH
11295: LD_INT 10
11297: PPUSH
11298: LD_INT 0
11300: PPUSH
11301: CALL_OW 50
// end ;
11305: GO 11269
11307: POP
11308: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11309: LD_EXP 71
11313: PPUSH
11314: LD_INT 259
11316: PPUSH
11317: LD_INT 235
11319: PPUSH
11320: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11324: LD_EXP 71
11328: PPUSH
11329: LD_INT 262
11331: PPUSH
11332: LD_INT 235
11334: PPUSH
11335: CALL_OW 178
// if Simms then
11339: LD_EXP 72
11343: IFFALSE 11374
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11345: LD_EXP 72
11349: PPUSH
11350: LD_INT 262
11352: PPUSH
11353: LD_INT 235
11355: PPUSH
11356: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11360: LD_EXP 72
11364: PPUSH
11365: LD_EXP 71
11369: PPUSH
11370: CALL_OW 179
// end ; end ;
11374: LD_VAR 0 1
11378: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp ;
11379: LD_EXP 31
11383: PUSH
11384: LD_EXP 23
11388: NOT
11389: AND
11390: IFFALSE 11531
11392: GO 11394
11394: DISABLE
11395: LD_INT 0
11397: PPUSH
11398: PPUSH
// begin enable ;
11399: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11400: LD_ADDR_VAR 0 2
11404: PUSH
11405: LD_INT 81
11407: PUSH
11408: LD_INT 7
11410: PUSH
11411: EMPTY
11412: LIST
11413: LIST
11414: PUSH
11415: LD_INT 2
11417: PUSH
11418: LD_INT 32
11420: PUSH
11421: LD_INT 3
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PUSH
11428: LD_INT 30
11430: PUSH
11431: LD_INT 30
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PUSH
11438: LD_INT 30
11440: PUSH
11441: LD_INT 28
11443: PUSH
11444: EMPTY
11445: LIST
11446: LIST
11447: PUSH
11448: LD_INT 34
11450: PUSH
11451: LD_INT 49
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: PUSH
11458: LD_INT 34
11460: PUSH
11461: LD_INT 10
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_INT 34
11470: PUSH
11471: LD_INT 8
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: LIST
11482: LIST
11483: LIST
11484: LIST
11485: LIST
11486: PUSH
11487: EMPTY
11488: LIST
11489: LIST
11490: PPUSH
11491: CALL_OW 69
11495: ST_TO_ADDR
// if not tmp then
11496: LD_VAR 0 2
11500: NOT
11501: IFFALSE 11505
// exit ;
11503: GO 11531
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 0 ) ;
11505: LD_VAR 0 2
11509: PUSH
11510: LD_INT 1
11512: PPUSH
11513: LD_VAR 0 2
11517: PPUSH
11518: CALL_OW 12
11522: ARRAY
11523: PPUSH
11524: LD_INT 0
11526: PPUSH
11527: CALL_OW 234
// end ;
11531: PPOPN 2
11533: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
11534: LD_EXP 23
11538: NOT
11539: PUSH
11540: LD_EXP 31
11544: AND
11545: IFFALSE 12088
11547: GO 11549
11549: DISABLE
11550: LD_INT 0
11552: PPUSH
11553: PPUSH
11554: PPUSH
// begin uc_side := 7 ;
11555: LD_ADDR_OWVAR 20
11559: PUSH
11560: LD_INT 7
11562: ST_TO_ADDR
// uc_nation := 1 ;
11563: LD_ADDR_OWVAR 21
11567: PUSH
11568: LD_INT 1
11570: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
11571: LD_ADDR_VAR 0 3
11575: PUSH
11576: LD_INT 125
11578: PUSH
11579: LD_INT 163
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: PUSH
11586: LD_INT 185
11588: PUSH
11589: LD_INT 168
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: PUSH
11596: LD_INT 111
11598: PUSH
11599: LD_INT 97
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: PUSH
11606: EMPTY
11607: LIST
11608: LIST
11609: LIST
11610: PPUSH
11611: CALL 103379 0 1
11615: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
11616: LD_ADDR_EXP 88
11620: PUSH
11621: EMPTY
11622: ST_TO_ADDR
// for i = 1 to Difficulty do
11623: LD_ADDR_VAR 0 1
11627: PUSH
11628: DOUBLE
11629: LD_INT 1
11631: DEC
11632: ST_TO_ADDR
11633: LD_OWVAR 67
11637: PUSH
11638: FOR_TO
11639: IFFALSE 11797
// begin InitHc ;
11641: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
11645: LD_INT 0
11647: PPUSH
11648: LD_INT 8
11650: PPUSH
11651: CALL_OW 381
// un := CreateHuman ;
11655: LD_ADDR_VAR 0 2
11659: PUSH
11660: CALL_OW 44
11664: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
11665: LD_VAR 0 2
11669: PPUSH
11670: LD_INT 258
11672: PPUSH
11673: LD_INT 267
11675: PPUSH
11676: LD_INT 4
11678: PPUSH
11679: LD_INT 0
11681: PPUSH
11682: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
11686: LD_ADDR_EXP 88
11690: PUSH
11691: LD_EXP 88
11695: PUSH
11696: LD_VAR 0 2
11700: UNION
11701: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
11702: LD_VAR 0 2
11706: PPUSH
11707: LD_VAR 0 3
11711: PUSH
11712: LD_VAR 0 1
11716: ARRAY
11717: PUSH
11718: LD_INT 1
11720: ARRAY
11721: PPUSH
11722: LD_VAR 0 3
11726: PUSH
11727: LD_VAR 0 1
11731: ARRAY
11732: PUSH
11733: LD_INT 2
11735: ARRAY
11736: PPUSH
11737: LD_INT 4
11739: PPUSH
11740: LD_INT 1
11742: PPUSH
11743: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
11747: LD_VAR 0 2
11751: PPUSH
11752: LD_VAR 0 3
11756: PUSH
11757: LD_VAR 0 1
11761: ARRAY
11762: PUSH
11763: LD_INT 1
11765: ARRAY
11766: PPUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_VAR 0 1
11776: ARRAY
11777: PUSH
11778: LD_INT 2
11780: ARRAY
11781: PPUSH
11782: CALL_OW 171
// AddComInvisible ( un ) ;
11786: LD_VAR 0 2
11790: PPUSH
11791: CALL_OW 212
// end ;
11795: GO 11638
11797: POP
11798: POP
// repeat wait ( 0 0$20 ) ;
11799: LD_INT 700
11801: PPUSH
11802: CALL_OW 67
// for i in allianceSpecialForce do
11806: LD_ADDR_VAR 0 1
11810: PUSH
11811: LD_EXP 88
11815: PUSH
11816: FOR_IN
11817: IFFALSE 12073
// begin if IsInvisible ( i ) then
11819: LD_VAR 0 1
11823: PPUSH
11824: CALL_OW 571
11828: IFFALSE 12042
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_driving ] ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
11830: LD_ADDR_VAR 0 3
11834: PUSH
11835: LD_INT 22
11837: PUSH
11838: LD_INT 1
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 50
11847: PUSH
11848: EMPTY
11849: LIST
11850: PUSH
11851: LD_INT 3
11853: PUSH
11854: LD_INT 54
11856: PUSH
11857: EMPTY
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 3
11866: PUSH
11867: LD_INT 55
11869: PUSH
11870: EMPTY
11871: LIST
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 91
11879: PUSH
11880: LD_VAR 0 1
11884: PUSH
11885: LD_INT 25
11887: PUSH
11888: LD_INT 30
11890: PUSH
11891: LD_INT 35
11893: PUSH
11894: EMPTY
11895: LIST
11896: LIST
11897: LIST
11898: PUSH
11899: LD_OWVAR 67
11903: ARRAY
11904: PUSH
11905: EMPTY
11906: LIST
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 2
11912: PUSH
11913: LD_INT 25
11915: PUSH
11916: LD_INT 1
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PUSH
11923: LD_INT 25
11925: PUSH
11926: LD_INT 2
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PUSH
11933: LD_INT 25
11935: PUSH
11936: LD_INT 3
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: PUSH
11943: LD_INT 25
11945: PUSH
11946: LD_INT 4
11948: PUSH
11949: EMPTY
11950: LIST
11951: LIST
11952: PUSH
11953: LD_INT 25
11955: PUSH
11956: LD_INT 5
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: PUSH
11963: LD_INT 25
11965: PUSH
11966: LD_INT 8
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL_OW 69
11994: ST_TO_ADDR
// if not tmp then
11995: LD_VAR 0 3
11999: NOT
12000: IFFALSE 12004
// continue ;
12002: GO 11816
// if Prob ( 30 * Difficulty ) then
12004: LD_INT 30
12006: PUSH
12007: LD_OWVAR 67
12011: MUL
12012: PPUSH
12013: CALL_OW 13
12017: IFFALSE 12042
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12019: LD_VAR 0 3
12023: PUSH
12024: LD_INT 1
12026: PPUSH
12027: LD_VAR 0 3
12031: PPUSH
12032: CALL_OW 12
12036: ARRAY
12037: PPUSH
12038: CALL 29131 0 1
// end ; if IsDead ( i ) then
12042: LD_VAR 0 1
12046: PPUSH
12047: CALL_OW 301
12051: IFFALSE 12071
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12053: LD_ADDR_EXP 88
12057: PUSH
12058: LD_EXP 88
12062: PUSH
12063: LD_VAR 0 1
12067: DIFF
12068: ST_TO_ADDR
// continue ;
12069: GO 11816
// end ; end ;
12071: GO 11816
12073: POP
12074: POP
// until allianceDestroyed or not allianceSpecialForce ;
12075: LD_EXP 23
12079: PUSH
12080: LD_EXP 88
12084: NOT
12085: OR
12086: IFFALSE 11799
// end ;
12088: PPOPN 3
12090: END
// every 11 11$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12091: LD_EXP 23
12095: NOT
12096: PUSH
12097: LD_EXP 31
12101: AND
12102: IFFALSE 12986
12104: GO 12106
12106: DISABLE
12107: LD_INT 0
12109: PPUSH
12110: PPUSH
12111: PPUSH
12112: PPUSH
// begin enable ;
12113: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12114: LD_INT 22
12116: PUSH
12117: LD_INT 7
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PUSH
12124: LD_INT 30
12126: PUSH
12127: LD_INT 3
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: NOT
12143: IFFALSE 12147
// exit ;
12145: GO 12986
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12147: LD_ADDR_VAR 0 4
12151: PUSH
12152: LD_INT 22
12154: PUSH
12155: LD_INT 7
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 30
12164: PUSH
12165: LD_INT 34
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: PPUSH
12176: CALL_OW 69
12180: ST_TO_ADDR
// if Prob ( 40 ) then
12181: LD_INT 40
12183: PPUSH
12184: CALL_OW 13
12188: IFFALSE 12315
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12190: LD_INT 1
12192: PPUSH
12193: LD_INT 5
12195: PUSH
12196: LD_INT 3
12198: PUSH
12199: LD_INT 2
12201: PUSH
12202: LD_INT 6
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: LIST
12209: LIST
12210: PUSH
12211: LD_INT 5
12213: PUSH
12214: LD_INT 3
12216: PUSH
12217: LD_INT 2
12219: PUSH
12220: LD_INT 6
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: LIST
12227: LIST
12228: PUSH
12229: LD_INT 5
12231: PUSH
12232: LD_INT 3
12234: PUSH
12235: LD_INT 2
12237: PUSH
12238: LD_INT 6
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: LIST
12245: LIST
12246: PUSH
12247: LD_INT 24
12249: PUSH
12250: LD_INT 3
12252: PUSH
12253: LD_INT 3
12255: PUSH
12256: LD_INT 45
12258: PUSH
12259: EMPTY
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 24
12267: PUSH
12268: LD_INT 3
12270: PUSH
12271: LD_INT 3
12273: PUSH
12274: LD_INT 47
12276: PUSH
12277: EMPTY
12278: LIST
12279: LIST
12280: LIST
12281: LIST
12282: PUSH
12283: LD_INT 24
12285: PUSH
12286: LD_INT 3
12288: PUSH
12289: LD_INT 3
12291: PUSH
12292: LD_INT 45
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL 55076 0 2
// end else
12313: GO 12438
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12315: LD_INT 1
12317: PPUSH
12318: LD_INT 24
12320: PUSH
12321: LD_INT 3
12323: PUSH
12324: LD_INT 3
12326: PUSH
12327: LD_INT 47
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: PUSH
12336: LD_INT 24
12338: PUSH
12339: LD_INT 3
12341: PUSH
12342: LD_INT 3
12344: PUSH
12345: LD_INT 47
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 24
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 45
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: LIST
12370: LIST
12371: PUSH
12372: LD_INT 24
12374: PUSH
12375: LD_INT 1
12377: PUSH
12378: LD_INT 3
12380: PUSH
12381: LD_INT 45
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: PUSH
12390: LD_INT 24
12392: PUSH
12393: LD_INT 1
12395: PUSH
12396: LD_INT 3
12398: PUSH
12399: LD_INT 45
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 24
12410: PUSH
12411: LD_INT 1
12413: PUSH
12414: LD_INT 3
12416: PUSH
12417: LD_INT 45
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: PPUSH
12434: CALL 55076 0 2
// end ; if Difficulty > 1 then
12438: LD_OWVAR 67
12442: PUSH
12443: LD_INT 1
12445: GREATER
12446: IFFALSE 12476
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12448: LD_INT 1
12450: PPUSH
12451: LD_INT 24
12453: PUSH
12454: LD_INT 3
12456: PUSH
12457: LD_INT 3
12459: PUSH
12460: LD_INT 47
12462: PUSH
12463: EMPTY
12464: LIST
12465: LIST
12466: LIST
12467: LIST
12468: PUSH
12469: EMPTY
12470: LIST
12471: PPUSH
12472: CALL 55076 0 2
// repeat wait ( 0 0$1 ) ;
12476: LD_INT 35
12478: PPUSH
12479: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
12483: LD_INT 1
12485: PPUSH
12486: LD_INT 1
12488: PPUSH
12489: CALL 56489 0 2
12493: PUSH
12494: LD_INT 6
12496: PUSH
12497: LD_INT 7
12499: PUSH
12500: LD_INT 7
12502: PUSH
12503: EMPTY
12504: LIST
12505: LIST
12506: LIST
12507: PUSH
12508: LD_OWVAR 67
12512: ARRAY
12513: GREATEREQUAL
12514: IFFALSE 12476
// tmp := MC_GetVehicles ( 1 , true ) ;
12516: LD_ADDR_VAR 0 2
12520: PUSH
12521: LD_INT 1
12523: PPUSH
12524: LD_INT 1
12526: PPUSH
12527: CALL 56489 0 2
12531: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
12532: LD_ADDR_EXP 118
12536: PUSH
12537: LD_EXP 118
12541: PPUSH
12542: LD_INT 1
12544: PPUSH
12545: LD_EXP 118
12549: PUSH
12550: LD_INT 1
12552: ARRAY
12553: PUSH
12554: LD_VAR 0 2
12558: DIFF
12559: PPUSH
12560: CALL_OW 1
12564: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_INT 0
12572: PPUSH
12573: LD_INT 1
12575: PPUSH
12576: CALL_OW 12
12580: ST_TO_ADDR
// if target then
12581: LD_VAR 0 3
12585: IFFALSE 12713
// begin for i in tmp do
12587: LD_ADDR_VAR 0 1
12591: PUSH
12592: LD_VAR 0 2
12596: PUSH
12597: FOR_IN
12598: IFFALSE 12623
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
12600: LD_VAR 0 1
12604: PPUSH
12605: LD_INT 179
12607: PPUSH
12608: LD_INT 209
12610: PPUSH
12611: LD_INT 8
12613: PPUSH
12614: LD_INT 1
12616: PPUSH
12617: CALL_OW 483
12621: GO 12597
12623: POP
12624: POP
// repeat AddComMoveXY ( tmp , 179 , 209 ) ;
12625: LD_VAR 0 2
12629: PPUSH
12630: LD_INT 179
12632: PPUSH
12633: LD_INT 209
12635: PPUSH
12636: CALL_OW 171
// wait ( 0 0$1 ) ;
12640: LD_INT 35
12642: PPUSH
12643: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
12647: LD_ADDR_VAR 0 2
12651: PUSH
12652: LD_VAR 0 2
12656: PPUSH
12657: LD_INT 24
12659: PUSH
12660: LD_INT 250
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: PPUSH
12667: CALL_OW 72
12671: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 6 ] ) >= ( tmp - 1 ) ;
12672: LD_VAR 0 2
12676: PPUSH
12677: LD_INT 92
12679: PUSH
12680: LD_INT 179
12682: PUSH
12683: LD_INT 209
12685: PUSH
12686: LD_INT 6
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: PPUSH
12695: CALL_OW 72
12699: PUSH
12700: LD_VAR 0 2
12704: PUSH
12705: LD_INT 1
12707: MINUS
12708: GREATEREQUAL
12709: IFFALSE 12625
// end else
12711: GO 12837
// begin for i in tmp do
12713: LD_ADDR_VAR 0 1
12717: PUSH
12718: LD_VAR 0 2
12722: PUSH
12723: FOR_IN
12724: IFFALSE 12749
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
12726: LD_VAR 0 1
12730: PPUSH
12731: LD_INT 285
12733: PPUSH
12734: LD_INT 163
12736: PPUSH
12737: LD_INT 8
12739: PPUSH
12740: LD_INT 1
12742: PPUSH
12743: CALL_OW 483
12747: GO 12723
12749: POP
12750: POP
// repeat AddComMoveXY ( tmp , 285 , 163 ) ;
12751: LD_VAR 0 2
12755: PPUSH
12756: LD_INT 285
12758: PPUSH
12759: LD_INT 163
12761: PPUSH
12762: CALL_OW 171
// wait ( 0 0$1 ) ;
12766: LD_INT 35
12768: PPUSH
12769: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
12773: LD_ADDR_VAR 0 2
12777: PUSH
12778: LD_VAR 0 2
12782: PPUSH
12783: LD_INT 24
12785: PUSH
12786: LD_INT 250
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PPUSH
12793: CALL_OW 72
12797: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 6 ] ) >= ( tmp - 1 ) ;
12798: LD_VAR 0 2
12802: PPUSH
12803: LD_INT 92
12805: PUSH
12806: LD_INT 285
12808: PUSH
12809: LD_INT 163
12811: PUSH
12812: LD_INT 6
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 72
12825: PUSH
12826: LD_VAR 0 2
12830: PUSH
12831: LD_INT 1
12833: MINUS
12834: GREATEREQUAL
12835: IFFALSE 12751
// end ; repeat wait ( 0 0$1 ) ;
12837: LD_INT 35
12839: PPUSH
12840: CALL_OW 67
// for i in tmp do
12844: LD_ADDR_VAR 0 1
12848: PUSH
12849: LD_VAR 0 2
12853: PUSH
12854: FOR_IN
12855: IFFALSE 12977
// if GetLives ( i ) > 251 then
12857: LD_VAR 0 1
12861: PPUSH
12862: CALL_OW 256
12866: PUSH
12867: LD_INT 251
12869: GREATER
12870: IFFALSE 12959
// begin if GetWeapon ( i ) = ru_time_lapser then
12872: LD_VAR 0 1
12876: PPUSH
12877: CALL_OW 264
12881: PUSH
12882: LD_INT 49
12884: EQUAL
12885: IFFALSE 12923
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
12887: LD_VAR 0 1
12891: PPUSH
12892: LD_INT 81
12894: PUSH
12895: LD_INT 7
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PPUSH
12902: CALL_OW 69
12906: PPUSH
12907: LD_VAR 0 1
12911: PPUSH
12912: CALL_OW 74
12916: PPUSH
12917: CALL_OW 112
12921: GO 12957
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
12923: LD_VAR 0 1
12927: PPUSH
12928: LD_INT 81
12930: PUSH
12931: LD_INT 7
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PPUSH
12938: CALL_OW 69
12942: PPUSH
12943: LD_VAR 0 1
12947: PPUSH
12948: CALL_OW 74
12952: PPUSH
12953: CALL_OW 115
// end else
12957: GO 12975
// tmp := tmp diff i ;
12959: LD_ADDR_VAR 0 2
12963: PUSH
12964: LD_VAR 0 2
12968: PUSH
12969: LD_VAR 0 1
12973: DIFF
12974: ST_TO_ADDR
12975: GO 12854
12977: POP
12978: POP
// until not tmp ;
12979: LD_VAR 0 2
12983: NOT
12984: IFFALSE 12837
// end ; end_of_file
12986: PPOPN 4
12988: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
12989: LD_INT 0
12991: PPUSH
12992: PPUSH
12993: PPUSH
12994: PPUSH
// missionStage := 13 ;
12995: LD_ADDR_EXP 15
12999: PUSH
13000: LD_INT 13
13002: ST_TO_ADDR
// uc_side := 2 ;
13003: LD_ADDR_OWVAR 20
13007: PUSH
13008: LD_INT 2
13010: ST_TO_ADDR
// uc_nation := 2 ;
13011: LD_ADDR_OWVAR 21
13015: PUSH
13016: LD_INT 2
13018: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13019: LD_ADDR_EXP 89
13023: PUSH
13024: LD_STRING Omar
13026: PPUSH
13027: CALL_OW 25
13031: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13032: LD_EXP 89
13036: PPUSH
13037: LD_INT 4
13039: PPUSH
13040: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13044: LD_EXP 89
13048: PPUSH
13049: LD_INT 242
13051: PPUSH
13052: LD_INT 75
13054: PPUSH
13055: LD_INT 0
13057: PPUSH
13058: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13062: LD_ADDR_EXP 90
13066: PUSH
13067: LD_STRING Heike
13069: PPUSH
13070: CALL_OW 25
13074: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13075: LD_INT 14
13077: PPUSH
13078: LD_INT 3
13080: PPUSH
13081: LD_INT 1
13083: PPUSH
13084: LD_INT 27
13086: PPUSH
13087: LD_INT 100
13089: PPUSH
13090: CALL 67604 0 5
// veh := CreateVehicle ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: CALL_OW 45
13103: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13104: LD_VAR 0 3
13108: PPUSH
13109: LD_INT 1
13111: PPUSH
13112: CALL_OW 242
// SetDir ( veh , 4 ) ;
13116: LD_VAR 0 3
13120: PPUSH
13121: LD_INT 4
13123: PPUSH
13124: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13128: LD_VAR 0 3
13132: PPUSH
13133: LD_INT 241
13135: PPUSH
13136: LD_INT 72
13138: PPUSH
13139: LD_INT 0
13141: PPUSH
13142: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13146: LD_EXP 90
13150: PPUSH
13151: LD_VAR 0 3
13155: PPUSH
13156: CALL_OW 52
// if KhatamStatus then
13160: LD_EXP 8
13164: IFFALSE 13215
// begin Khatam := NewCharacter ( Khatam ) ;
13166: LD_ADDR_EXP 91
13170: PUSH
13171: LD_STRING Khatam
13173: PPUSH
13174: CALL_OW 25
13178: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13179: LD_EXP 91
13183: PPUSH
13184: LD_INT 245
13186: PPUSH
13187: LD_INT 78
13189: PPUSH
13190: LD_INT 3
13192: PPUSH
13193: LD_INT 0
13195: PPUSH
13196: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13200: LD_EXP 91
13204: PPUSH
13205: LD_INT 4
13207: PPUSH
13208: LD_INT 10
13210: PPUSH
13211: CALL_OW 237
// end ; for i = 1 to Difficulty do
13215: LD_ADDR_VAR 0 2
13219: PUSH
13220: DOUBLE
13221: LD_INT 1
13223: DEC
13224: ST_TO_ADDR
13225: LD_OWVAR 67
13229: PUSH
13230: FOR_TO
13231: IFFALSE 13297
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13233: LD_INT 0
13235: PPUSH
13236: LD_INT 7
13238: PUSH
13239: LD_OWVAR 67
13243: PLUS
13244: PPUSH
13245: CALL_OW 384
// un := CreateHuman ;
13249: LD_ADDR_VAR 0 4
13253: PUSH
13254: CALL_OW 44
13258: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13259: LD_VAR 0 4
13263: PPUSH
13264: LD_INT 28
13266: PUSH
13267: LD_INT 29
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PUSH
13274: LD_VAR 0 2
13278: PUSH
13279: LD_INT 2
13281: MOD
13282: PUSH
13283: LD_INT 1
13285: PLUS
13286: ARRAY
13287: PPUSH
13288: LD_INT 0
13290: PPUSH
13291: CALL_OW 49
// end ;
13295: GO 13230
13297: POP
13298: POP
// for i = 1 to 6 do
13299: LD_ADDR_VAR 0 2
13303: PUSH
13304: DOUBLE
13305: LD_INT 1
13307: DEC
13308: ST_TO_ADDR
13309: LD_INT 6
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13358
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13315: LD_INT 0
13317: PPUSH
13318: LD_INT 7
13320: PUSH
13321: LD_OWVAR 67
13325: PLUS
13326: PPUSH
13327: CALL_OW 381
// un := CreateHuman ;
13331: LD_ADDR_VAR 0 4
13335: PUSH
13336: CALL_OW 44
13340: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13341: LD_VAR 0 4
13345: PPUSH
13346: LD_INT 28
13348: PPUSH
13349: LD_INT 0
13351: PPUSH
13352: CALL_OW 49
// end ;
13356: GO 13312
13358: POP
13359: POP
// for i = 1 to 3 do
13360: LD_ADDR_VAR 0 2
13364: PUSH
13365: DOUBLE
13366: LD_INT 1
13368: DEC
13369: ST_TO_ADDR
13370: LD_INT 3
13372: PUSH
13373: FOR_TO
13374: IFFALSE 13422
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13376: LD_INT 0
13378: PPUSH
13379: LD_INT 8
13381: PPUSH
13382: LD_INT 7
13384: PUSH
13385: LD_OWVAR 67
13389: PLUS
13390: PPUSH
13391: CALL_OW 380
// un := CreateHuman ;
13395: LD_ADDR_VAR 0 4
13399: PUSH
13400: CALL_OW 44
13404: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13405: LD_VAR 0 4
13409: PPUSH
13410: LD_INT 28
13412: PPUSH
13413: LD_INT 0
13415: PPUSH
13416: CALL_OW 49
// end ;
13420: GO 13373
13422: POP
13423: POP
// for i = 1 to 3 do
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: DOUBLE
13430: LD_INT 1
13432: DEC
13433: ST_TO_ADDR
13434: LD_INT 3
13436: PUSH
13437: FOR_TO
13438: IFFALSE 13528
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
13440: LD_INT 14
13442: PPUSH
13443: LD_INT 2
13445: PPUSH
13446: LD_INT 1
13448: PPUSH
13449: LD_INT 28
13451: PPUSH
13452: LD_INT 80
13454: PPUSH
13455: CALL 67604 0 5
// veh := CreateVehicle ;
13459: LD_ADDR_VAR 0 3
13463: PUSH
13464: CALL_OW 45
13468: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
13469: LD_VAR 0 3
13473: PPUSH
13474: LD_INT 3
13476: PPUSH
13477: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
13481: LD_VAR 0 3
13485: PPUSH
13486: LD_INT 29
13488: PPUSH
13489: LD_INT 0
13491: PPUSH
13492: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
13496: LD_INT 0
13498: PPUSH
13499: LD_INT 7
13501: PUSH
13502: LD_OWVAR 67
13506: PLUS
13507: PPUSH
13508: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
13512: CALL_OW 44
13516: PPUSH
13517: LD_VAR 0 3
13521: PPUSH
13522: CALL_OW 52
// end ;
13526: GO 13437
13528: POP
13529: POP
// for i = 1 to 5 + Difficulty do
13530: LD_ADDR_VAR 0 2
13534: PUSH
13535: DOUBLE
13536: LD_INT 1
13538: DEC
13539: ST_TO_ADDR
13540: LD_INT 5
13542: PUSH
13543: LD_OWVAR 67
13547: PLUS
13548: PUSH
13549: FOR_TO
13550: IFFALSE 13677
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
13552: LD_INT 14
13554: PPUSH
13555: LD_INT 1
13557: PPUSH
13558: LD_INT 3
13560: PPUSH
13561: CALL_OW 12
13565: PPUSH
13566: LD_INT 1
13568: PPUSH
13569: LD_INT 28
13571: PUSH
13572: LD_INT 26
13574: PUSH
13575: LD_INT 27
13577: PUSH
13578: LD_INT 25
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: PUSH
13587: LD_VAR 0 2
13591: PUSH
13592: LD_INT 4
13594: MOD
13595: PUSH
13596: LD_INT 1
13598: PLUS
13599: ARRAY
13600: PPUSH
13601: LD_INT 80
13603: PPUSH
13604: CALL 67604 0 5
// veh := CreateVehicle ;
13608: LD_ADDR_VAR 0 3
13612: PUSH
13613: CALL_OW 45
13617: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
13618: LD_VAR 0 3
13622: PPUSH
13623: LD_INT 4
13625: PPUSH
13626: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
13630: LD_VAR 0 3
13634: PPUSH
13635: LD_INT 28
13637: PPUSH
13638: LD_INT 0
13640: PPUSH
13641: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
13645: LD_INT 0
13647: PPUSH
13648: LD_INT 7
13650: PUSH
13651: LD_OWVAR 67
13655: PLUS
13656: PPUSH
13657: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
13661: CALL_OW 44
13665: PPUSH
13666: LD_VAR 0 3
13670: PPUSH
13671: CALL_OW 52
// end ;
13675: GO 13549
13677: POP
13678: POP
// for i = 1 to 3 do
13679: LD_ADDR_VAR 0 2
13683: PUSH
13684: DOUBLE
13685: LD_INT 1
13687: DEC
13688: ST_TO_ADDR
13689: LD_INT 3
13691: PUSH
13692: FOR_TO
13693: IFFALSE 13753
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
13695: LD_INT 14
13697: PPUSH
13698: LD_INT 3
13700: PPUSH
13701: LD_INT 5
13703: PPUSH
13704: LD_INT 29
13706: PPUSH
13707: LD_INT 80
13709: PPUSH
13710: CALL 67604 0 5
// veh := CreateVehicle ;
13714: LD_ADDR_VAR 0 3
13718: PUSH
13719: CALL_OW 45
13723: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
13724: LD_VAR 0 3
13728: PPUSH
13729: LD_INT 4
13731: PPUSH
13732: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
13736: LD_VAR 0 3
13740: PPUSH
13741: LD_INT 28
13743: PPUSH
13744: LD_INT 0
13746: PPUSH
13747: CALL_OW 49
// end ;
13751: GO 13692
13753: POP
13754: POP
// end ;
13755: LD_VAR 0 1
13759: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
13760: LD_INT 22
13762: PUSH
13763: LD_INT 2
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: PPUSH
13770: CALL_OW 69
13774: IFFALSE 14074
13776: GO 13778
13778: DISABLE
13779: LD_INT 0
13781: PPUSH
13782: PPUSH
13783: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
13784: LD_ADDR_VAR 0 3
13788: PUSH
13789: LD_INT 22
13791: PUSH
13792: LD_INT 2
13794: PUSH
13795: EMPTY
13796: LIST
13797: LIST
13798: PUSH
13799: LD_INT 25
13801: PUSH
13802: LD_INT 4
13804: PUSH
13805: EMPTY
13806: LIST
13807: LIST
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: PPUSH
13813: CALL_OW 69
13817: PUSH
13818: LD_EXP 91
13822: DIFF
13823: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
13824: LD_ADDR_VAR 0 2
13828: PUSH
13829: LD_INT 22
13831: PUSH
13832: LD_INT 2
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PPUSH
13839: CALL_OW 69
13843: PUSH
13844: LD_EXP 91
13848: PUSH
13849: LD_VAR 0 3
13853: UNION
13854: DIFF
13855: ST_TO_ADDR
// if Khatam then
13856: LD_EXP 91
13860: IFFALSE 13877
// ComMoveXY ( Khatam , 211 , 92 ) ;
13862: LD_EXP 91
13866: PPUSH
13867: LD_INT 211
13869: PPUSH
13870: LD_INT 92
13872: PPUSH
13873: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
13877: LD_INT 197
13879: PPUSH
13880: LD_INT 80
13882: PPUSH
13883: LD_INT 2
13885: PPUSH
13886: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
13890: LD_INT 213
13892: PPUSH
13893: LD_INT 90
13895: PPUSH
13896: LD_INT 2
13898: PPUSH
13899: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
13903: LD_INT 215
13905: PPUSH
13906: LD_INT 129
13908: PPUSH
13909: LD_INT 2
13911: PPUSH
13912: CALL_OW 441
// if sci then
13916: LD_VAR 0 3
13920: IFFALSE 13941
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
13922: LD_VAR 0 3
13926: PUSH
13927: LD_INT 1
13929: ARRAY
13930: PPUSH
13931: LD_INT 197
13933: PPUSH
13934: LD_INT 80
13936: PPUSH
13937: CALL_OW 158
// if sci > 1 then
13941: LD_VAR 0 3
13945: PUSH
13946: LD_INT 1
13948: GREATER
13949: IFFALSE 13970
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
13951: LD_VAR 0 3
13955: PUSH
13956: LD_INT 2
13958: ARRAY
13959: PPUSH
13960: LD_INT 213
13962: PPUSH
13963: LD_INT 90
13965: PPUSH
13966: CALL_OW 158
// if sci > 2 then
13970: LD_VAR 0 3
13974: PUSH
13975: LD_INT 2
13977: GREATER
13978: IFFALSE 13999
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
13980: LD_VAR 0 3
13984: PUSH
13985: LD_INT 3
13987: ARRAY
13988: PPUSH
13989: LD_INT 215
13991: PPUSH
13992: LD_INT 129
13994: PPUSH
13995: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
13999: LD_INT 35
14001: PPUSH
14002: CALL_OW 67
// for i in tmp do
14006: LD_ADDR_VAR 0 1
14010: PUSH
14011: LD_VAR 0 2
14015: PUSH
14016: FOR_IN
14017: IFFALSE 14055
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14019: LD_VAR 0 1
14023: PPUSH
14024: LD_INT 81
14026: PUSH
14027: LD_INT 2
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: PPUSH
14034: CALL_OW 69
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: CALL_OW 74
14048: PPUSH
14049: CALL_OW 115
14053: GO 14016
14055: POP
14056: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14057: LD_INT 22
14059: PUSH
14060: LD_INT 2
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: PPUSH
14067: CALL_OW 69
14071: NOT
14072: IFFALSE 13999
// end ; end_of_file
14074: PPOPN 3
14076: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14077: LD_INT 0
14079: PPUSH
14080: PPUSH
14081: PPUSH
14082: PPUSH
14083: PPUSH
14084: PPUSH
14085: PPUSH
14086: PPUSH
14087: PPUSH
// Video ( true ) ;
14088: LD_INT 1
14090: PPUSH
14091: CALL 103259 0 1
// if debug then
14095: LD_EXP 1
14099: IFFALSE 14109
// dialogue_skipped := true ;
14101: LD_ADDR_OWVAR 59
14105: PUSH
14106: LD_INT 1
14108: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14109: LD_ADDR_VAR 0 5
14113: PUSH
14114: LD_INT 7
14116: PPUSH
14117: LD_INT 0
14119: PPUSH
14120: CALL_OW 517
14124: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14125: LD_ADDR_VAR 0 2
14129: PUSH
14130: DOUBLE
14131: LD_INT 1
14133: DEC
14134: ST_TO_ADDR
14135: LD_VAR 0 5
14139: PUSH
14140: LD_INT 1
14142: ARRAY
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14190
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14147: LD_VAR 0 5
14151: PUSH
14152: LD_INT 1
14154: ARRAY
14155: PUSH
14156: LD_VAR 0 2
14160: ARRAY
14161: PPUSH
14162: LD_VAR 0 5
14166: PUSH
14167: LD_INT 2
14169: ARRAY
14170: PUSH
14171: LD_VAR 0 2
14175: ARRAY
14176: PPUSH
14177: LD_INT 1
14179: PPUSH
14180: LD_INT 15
14182: NEG
14183: PPUSH
14184: CALL 103173 0 4
14188: GO 14144
14190: POP
14191: POP
// CenterNowOnUnits ( Powell ) ;
14192: LD_EXP 55
14196: PPUSH
14197: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14201: LD_ADDR_VAR 0 5
14205: PUSH
14206: LD_EXP 53
14210: PUSH
14211: EMPTY
14212: LIST
14213: ST_TO_ADDR
// if GirlNewVeh then
14214: LD_EXP 54
14218: IFFALSE 14236
// tmp := tmp ^ GirlNewVeh ;
14220: LD_ADDR_VAR 0 5
14224: PUSH
14225: LD_VAR 0 5
14229: PUSH
14230: LD_EXP 54
14234: ADD
14235: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14236: LD_VAR 0 5
14240: PPUSH
14241: LD_INT 60
14243: PPUSH
14244: LD_INT 109
14246: PPUSH
14247: CALL_OW 111
// if KappaStatus then
14251: LD_EXP 2
14255: IFFALSE 14307
// begin Say ( JMM , D1nT-JMM-1 ) ;
14257: LD_EXP 36
14261: PPUSH
14262: LD_STRING D1nT-JMM-1
14264: PPUSH
14265: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14269: LD_EXP 55
14273: PPUSH
14274: LD_STRING D1T-Pow-1
14276: PPUSH
14277: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14281: LD_EXP 36
14285: PPUSH
14286: LD_STRING D1T-JMM-2
14288: PPUSH
14289: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14293: LD_EXP 55
14297: PPUSH
14298: LD_STRING D1T-Pow-2
14300: PPUSH
14301: CALL_OW 88
// end else
14305: GO 14513
// if JMMGirlStatus then
14307: LD_EXP 6
14311: IFFALSE 14456
// begin Say ( JMM , D1T-JMM-1 ) ;
14313: LD_EXP 36
14317: PPUSH
14318: LD_STRING D1T-JMM-1
14320: PPUSH
14321: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14325: LD_EXP 55
14329: PPUSH
14330: LD_STRING D1T-Pow-1
14332: PPUSH
14333: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14337: LD_EXP 36
14341: PPUSH
14342: LD_STRING D1T-JMM-3
14344: PPUSH
14345: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14349: LD_EXP 55
14353: PPUSH
14354: LD_STRING D1T-Pow-3
14356: PPUSH
14357: CALL_OW 88
// if JMMGirl then
14361: LD_EXP 7
14365: IFFALSE 14454
// begin case JMMGirl of 1 :
14367: LD_EXP 7
14371: PUSH
14372: LD_INT 1
14374: DOUBLE
14375: EQUAL
14376: IFTRUE 14380
14378: GO 14395
14380: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
14381: LD_EXP 37
14385: PPUSH
14386: LD_STRING D1T-Joan-3
14388: PPUSH
14389: CALL_OW 88
14393: GO 14442
14395: LD_INT 2
14397: DOUBLE
14398: EQUAL
14399: IFTRUE 14403
14401: GO 14418
14403: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
14404: LD_EXP 39
14408: PPUSH
14409: LD_STRING D1T-Lisa-3
14411: PPUSH
14412: CALL_OW 88
14416: GO 14442
14418: LD_INT 3
14420: DOUBLE
14421: EQUAL
14422: IFTRUE 14426
14424: GO 14441
14426: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
14427: LD_EXP 51
14431: PPUSH
14432: LD_STRING D1T-Con-3
14434: PPUSH
14435: CALL_OW 88
14439: GO 14442
14441: POP
// Say ( Powell , D1T-Pow-4 ) ;
14442: LD_EXP 55
14446: PPUSH
14447: LD_STRING D1T-Pow-4
14449: PPUSH
14450: CALL_OW 88
// end ; end else
14454: GO 14513
// if not FastEnd then
14456: LD_EXP 11
14460: NOT
14461: IFFALSE 14489
// begin Say ( JMM , D1T-JMM-4 ) ;
14463: LD_EXP 36
14467: PPUSH
14468: LD_STRING D1T-JMM-4
14470: PPUSH
14471: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
14475: LD_EXP 55
14479: PPUSH
14480: LD_STRING D1T-Pow-5
14482: PPUSH
14483: CALL_OW 88
// end else
14487: GO 14513
// begin Say ( JMM , D1nT-JMM-1 ) ;
14489: LD_EXP 36
14493: PPUSH
14494: LD_STRING D1nT-JMM-1
14496: PPUSH
14497: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
14501: LD_EXP 55
14505: PPUSH
14506: LD_STRING D1nT-Pow-1
14508: PPUSH
14509: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
14513: LD_INT 35
14515: PPUSH
14516: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
14520: LD_EXP 53
14524: PPUSH
14525: CALL_OW 314
14529: NOT
14530: IFFALSE 14513
// ComExitVehicle ( JMM ) ;
14532: LD_EXP 36
14536: PPUSH
14537: CALL_OW 121
// wait ( 3 ) ;
14541: LD_INT 3
14543: PPUSH
14544: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
14548: LD_EXP 36
14552: PPUSH
14553: LD_INT 60
14555: PPUSH
14556: LD_INT 94
14558: PPUSH
14559: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
14563: LD_EXP 36
14567: PPUSH
14568: LD_EXP 55
14572: PPUSH
14573: CALL_OW 179
// if Joan then
14577: LD_EXP 37
14581: IFFALSE 14635
// begin ComExitVehicle ( Joan ) ;
14583: LD_EXP 37
14587: PPUSH
14588: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
14592: LD_EXP 37
14596: PPUSH
14597: LD_INT 35
14599: PPUSH
14600: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
14604: LD_EXP 37
14608: PPUSH
14609: LD_INT 65
14611: PPUSH
14612: LD_INT 104
14614: PPUSH
14615: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
14619: LD_EXP 37
14623: PPUSH
14624: LD_EXP 36
14628: PPUSH
14629: CALL_OW 179
// end else
14633: GO 14769
// if Lisa and JMMGirl = 2 then
14635: LD_EXP 39
14639: PUSH
14640: LD_EXP 7
14644: PUSH
14645: LD_INT 2
14647: EQUAL
14648: AND
14649: IFFALSE 14703
// begin ComExitVehicle ( Lisa ) ;
14651: LD_EXP 39
14655: PPUSH
14656: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
14660: LD_EXP 39
14664: PPUSH
14665: LD_INT 35
14667: PPUSH
14668: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
14672: LD_EXP 39
14676: PPUSH
14677: LD_INT 65
14679: PPUSH
14680: LD_INT 104
14682: PPUSH
14683: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
14687: LD_EXP 39
14691: PPUSH
14692: LD_EXP 36
14696: PPUSH
14697: CALL_OW 179
// end else
14701: GO 14769
// if Connie and JMMGirl = 3 then
14703: LD_EXP 51
14707: PUSH
14708: LD_EXP 7
14712: PUSH
14713: LD_INT 3
14715: EQUAL
14716: AND
14717: IFFALSE 14769
// begin ComExitVehicle ( Connie ) ;
14719: LD_EXP 51
14723: PPUSH
14724: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
14728: LD_EXP 51
14732: PPUSH
14733: LD_INT 35
14735: PPUSH
14736: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
14740: LD_EXP 51
14744: PPUSH
14745: LD_INT 65
14747: PPUSH
14748: LD_INT 104
14750: PPUSH
14751: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
14755: LD_EXP 51
14759: PPUSH
14760: LD_EXP 36
14764: PPUSH
14765: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
14769: LD_INT 35
14771: PPUSH
14772: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
14776: LD_EXP 36
14780: PPUSH
14781: LD_EXP 55
14785: PPUSH
14786: CALL_OW 296
14790: PUSH
14791: LD_INT 6
14793: LESS
14794: IFFALSE 14769
// wait ( 0 0$0.5 ) ;
14796: LD_INT 18
14798: PPUSH
14799: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
14803: LD_EXP 36
14807: PPUSH
14808: LD_STRING D1-JMM-1
14810: PPUSH
14811: CALL_OW 88
// async ;
14815: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
14816: LD_EXP 55
14820: PPUSH
14821: LD_STRING D1-Pow-1
14823: PPUSH
14824: CALL_OW 88
// if not dialogue_skipped then
14828: LD_OWVAR 59
14832: NOT
14833: IFFALSE 14842
// wait ( 0 0$2 ) ;
14835: LD_INT 70
14837: PPUSH
14838: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
14842: LD_INT 170
14844: PPUSH
14845: LD_INT 99
14847: PPUSH
14848: LD_INT 1
14850: PPUSH
14851: LD_INT 6
14853: NEG
14854: PPUSH
14855: CALL 103173 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
14859: LD_INT 174
14861: PPUSH
14862: LD_INT 115
14864: PPUSH
14865: LD_INT 1
14867: PPUSH
14868: LD_INT 6
14870: NEG
14871: PPUSH
14872: CALL 103173 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
14876: LD_INT 169
14878: PPUSH
14879: LD_INT 71
14881: PPUSH
14882: LD_INT 1
14884: PPUSH
14885: LD_INT 6
14887: NEG
14888: PPUSH
14889: CALL 103173 0 4
// if not dialogue_skipped then
14893: LD_OWVAR 59
14897: NOT
14898: IFFALSE 14917
// begin CenterOnXY ( 170 , 99 ) ;
14900: LD_INT 170
14902: PPUSH
14903: LD_INT 99
14905: PPUSH
14906: CALL_OW 84
// wait ( 0 0$2.3 ) ;
14910: LD_INT 80
14912: PPUSH
14913: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
14917: LD_INT 75
14919: PPUSH
14920: LD_INT 53
14922: PPUSH
14923: LD_INT 1
14925: PPUSH
14926: LD_INT 9
14928: NEG
14929: PPUSH
14930: CALL 103173 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
14934: LD_INT 54
14936: PPUSH
14937: LD_INT 42
14939: PPUSH
14940: LD_INT 1
14942: PPUSH
14943: LD_INT 9
14945: NEG
14946: PPUSH
14947: CALL 103173 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
14951: LD_INT 62
14953: PPUSH
14954: LD_INT 51
14956: PPUSH
14957: LD_INT 1
14959: PPUSH
14960: LD_INT 9
14962: NEG
14963: PPUSH
14964: CALL 103173 0 4
// if not dialogue_skipped then
14968: LD_OWVAR 59
14972: NOT
14973: IFFALSE 14992
// begin CenterOnXY ( 75 , 53 ) ;
14975: LD_INT 75
14977: PPUSH
14978: LD_INT 53
14980: PPUSH
14981: CALL_OW 84
// wait ( 0 0$4 ) ;
14985: LD_INT 140
14987: PPUSH
14988: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
14992: LD_EXP 55
14996: PPUSH
14997: CALL_OW 87
// if not dialogue_skipped then
15001: LD_OWVAR 59
15005: NOT
15006: IFFALSE 15015
// wait ( 0 0$2 ) ;
15008: LD_INT 70
15010: PPUSH
15011: CALL_OW 67
// sync ;
15015: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15016: LD_EXP 36
15020: PPUSH
15021: LD_STRING D1-JMM-2
15023: PPUSH
15024: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15028: LD_EXP 55
15032: PPUSH
15033: LD_STRING D1-Pow-2
15035: PPUSH
15036: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15040: LD_EXP 36
15044: PPUSH
15045: LD_STRING D1-JMM-3
15047: PPUSH
15048: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15052: LD_EXP 55
15056: PPUSH
15057: LD_STRING D1-Pow-3
15059: PPUSH
15060: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15064: LD_EXP 36
15068: PPUSH
15069: LD_STRING D1-JMM-4
15071: PPUSH
15072: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15076: LD_EXP 55
15080: PPUSH
15081: LD_STRING D1-Pow-4
15083: PPUSH
15084: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15088: LD_EXP 36
15092: PPUSH
15093: LD_STRING D1-JMM-5
15095: PPUSH
15096: CALL_OW 88
// async ;
15100: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15101: LD_EXP 55
15105: PPUSH
15106: LD_STRING D1-Pow-5
15108: PPUSH
15109: CALL_OW 88
// if not dialogue_skipped then
15113: LD_OWVAR 59
15117: NOT
15118: IFFALSE 15127
// wait ( 0 0$3.6 ) ;
15120: LD_INT 126
15122: PPUSH
15123: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15127: LD_INT 134
15129: PPUSH
15130: LD_INT 210
15132: PPUSH
15133: LD_INT 1
15135: PPUSH
15136: LD_INT 11
15138: NEG
15139: PPUSH
15140: CALL 103173 0 4
// if not dialogue_skipped then
15144: LD_OWVAR 59
15148: NOT
15149: IFFALSE 15168
// begin CenterOnXY ( 134 , 210 ) ;
15151: LD_INT 134
15153: PPUSH
15154: LD_INT 210
15156: PPUSH
15157: CALL_OW 84
// wait ( 0 0$2 ) ;
15161: LD_INT 70
15163: PPUSH
15164: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15168: LD_INT 101
15170: PPUSH
15171: LD_INT 159
15173: PPUSH
15174: LD_INT 1
15176: PPUSH
15177: LD_INT 10
15179: NEG
15180: PPUSH
15181: CALL 103173 0 4
// if not dialogue_skipped then
15185: LD_OWVAR 59
15189: NOT
15190: IFFALSE 15209
// begin CenterOnXY ( 101 , 159 ) ;
15192: LD_INT 101
15194: PPUSH
15195: LD_INT 159
15197: PPUSH
15198: CALL_OW 84
// wait ( 0 0$2 ) ;
15202: LD_INT 70
15204: PPUSH
15205: CALL_OW 67
// end ; sync ;
15209: SYNC
// CenterNowOnUnits ( Powell ) ;
15210: LD_EXP 55
15214: PPUSH
15215: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15219: LD_ADDR_VAR 0 6
15223: PUSH
15224: LD_INT 1
15226: PUSH
15227: LD_INT 2
15229: PUSH
15230: LD_INT 3
15232: PUSH
15233: LD_INT 4
15235: PUSH
15236: LD_INT 5
15238: PUSH
15239: LD_INT 6
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: ST_TO_ADDR
// if not dialogue_skipped then
15250: LD_OWVAR 59
15254: NOT
15255: IFFALSE 15424
// begin game_speed := 4 ;
15257: LD_ADDR_OWVAR 65
15261: PUSH
15262: LD_INT 4
15264: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15265: LD_INT 210
15267: PPUSH
15268: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15272: LD_ADDR_VAR 0 7
15276: PUSH
15277: LD_STRING Q1
15279: PPUSH
15280: LD_VAR 0 6
15284: PPUSH
15285: CALL_OW 98
15289: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15290: LD_ADDR_VAR 0 7
15294: PUSH
15295: LD_STRING Q1
15297: PPUSH
15298: LD_VAR 0 6
15302: PPUSH
15303: CALL_OW 98
15307: ST_TO_ADDR
// options = options diff dec ;
15308: LD_ADDR_VAR 0 6
15312: PUSH
15313: LD_VAR 0 6
15317: PUSH
15318: LD_VAR 0 7
15322: DIFF
15323: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15324: LD_VAR 0 7
15328: PPUSH
15329: LD_VAR 0 6
15333: PPUSH
15334: CALL 16707 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15338: LD_VAR 0 7
15342: PUSH
15343: LD_INT 5
15345: PUSH
15346: LD_INT 6
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: IN
15353: PUSH
15354: LD_VAR 0 6
15358: PUSH
15359: LD_INT 2
15361: EQUAL
15362: OR
15363: IFFALSE 15290
// if not ( dec in [ 5 , 6 ] ) then
15365: LD_VAR 0 7
15369: PUSH
15370: LD_INT 5
15372: PUSH
15373: LD_INT 6
15375: PUSH
15376: EMPTY
15377: LIST
15378: LIST
15379: IN
15380: NOT
15381: IFFALSE 15424
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
15383: LD_ADDR_VAR 0 7
15387: PUSH
15388: LD_STRING Q1a
15390: PPUSH
15391: LD_INT 1
15393: PUSH
15394: LD_INT 2
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PPUSH
15401: CALL_OW 98
15405: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
15406: LD_VAR 0 7
15410: PUSH
15411: LD_INT 4
15413: PLUS
15414: PPUSH
15415: LD_VAR 0 6
15419: PPUSH
15420: CALL 16707 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
15424: LD_INT 81
15426: PPUSH
15427: LD_INT 127
15429: PPUSH
15430: CALL_OW 84
// amount := 5 ;
15434: LD_ADDR_VAR 0 8
15438: PUSH
15439: LD_INT 5
15441: ST_TO_ADDR
// macmilan_squad := [ ] ;
15442: LD_ADDR_VAR 0 9
15446: PUSH
15447: EMPTY
15448: ST_TO_ADDR
// if vip < amount then
15449: LD_EXP 56
15453: PUSH
15454: LD_VAR 0 8
15458: LESS
15459: IFFALSE 15503
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
15461: LD_ADDR_VAR 0 5
15465: PUSH
15466: LD_EXP 56
15470: PUSH
15471: LD_INT 22
15473: PUSH
15474: LD_INT 4
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: LD_INT 21
15483: PUSH
15484: LD_INT 1
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: LIST
15494: PPUSH
15495: CALL_OW 69
15499: UNION
15500: ST_TO_ADDR
15501: GO 15513
// tmp := vip ;
15503: LD_ADDR_VAR 0 5
15507: PUSH
15508: LD_EXP 56
15512: ST_TO_ADDR
// tmp := tmp diff Powell ;
15513: LD_ADDR_VAR 0 5
15517: PUSH
15518: LD_VAR 0 5
15522: PUSH
15523: LD_EXP 55
15527: DIFF
15528: ST_TO_ADDR
// if tmp < amount then
15529: LD_VAR 0 5
15533: PUSH
15534: LD_VAR 0 8
15538: LESS
15539: IFFALSE 15551
// amount := tmp ;
15541: LD_ADDR_VAR 0 8
15545: PUSH
15546: LD_VAR 0 5
15550: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
15551: LD_VAR 0 5
15555: PUSH
15556: LD_INT 1
15558: ARRAY
15559: PPUSH
15560: CALL_OW 257
15564: PUSH
15565: LD_INT 2
15567: NONEQUAL
15568: IFFALSE 15630
// begin if IsInUnit ( tmp [ 1 ] ) then
15570: LD_VAR 0 5
15574: PUSH
15575: LD_INT 1
15577: ARRAY
15578: PPUSH
15579: CALL_OW 310
15583: IFFALSE 15598
// ComExitBuilding ( tmp [ 1 ] ) ;
15585: LD_VAR 0 5
15589: PUSH
15590: LD_INT 1
15592: ARRAY
15593: PPUSH
15594: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
15598: LD_VAR 0 5
15602: PUSH
15603: LD_INT 1
15605: ARRAY
15606: PPUSH
15607: LD_INT 387
15609: PPUSH
15610: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
15614: LD_VAR 0 5
15618: PUSH
15619: LD_INT 1
15621: ARRAY
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
15630: LD_EXP 36
15634: PPUSH
15635: LD_INT 82
15637: PPUSH
15638: LD_INT 129
15640: PPUSH
15641: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15645: LD_EXP 36
15649: PPUSH
15650: LD_EXP 55
15654: PPUSH
15655: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
15659: LD_INT 22
15661: PUSH
15662: LD_INT 1
15664: PUSH
15665: EMPTY
15666: LIST
15667: LIST
15668: PPUSH
15669: CALL_OW 69
15673: PUSH
15674: LD_EXP 36
15678: DIFF
15679: PPUSH
15680: LD_INT 84
15682: PPUSH
15683: LD_INT 128
15685: PPUSH
15686: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
15690: LD_INT 22
15692: PUSH
15693: LD_INT 1
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 69
15704: PUSH
15705: LD_EXP 36
15709: DIFF
15710: PPUSH
15711: LD_EXP 36
15715: PPUSH
15716: CALL_OW 179
// for i = 1 to amount do
15720: LD_ADDR_VAR 0 2
15724: PUSH
15725: DOUBLE
15726: LD_INT 1
15728: DEC
15729: ST_TO_ADDR
15730: LD_VAR 0 8
15734: PUSH
15735: FOR_TO
15736: IFFALSE 15904
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
15738: LD_ADDR_VAR 0 9
15742: PUSH
15743: LD_VAR 0 9
15747: PUSH
15748: LD_VAR 0 5
15752: PUSH
15753: LD_VAR 0 2
15757: ARRAY
15758: ADD
15759: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
15760: LD_VAR 0 5
15764: PUSH
15765: LD_VAR 0 2
15769: ARRAY
15770: PPUSH
15771: CALL_OW 310
15775: IFFALSE 15792
// AddComExitBuilding ( tmp [ i ] ) ;
15777: LD_VAR 0 5
15781: PUSH
15782: LD_VAR 0 2
15786: ARRAY
15787: PPUSH
15788: CALL_OW 182
// if i = 2 and JMMNewVeh then
15792: LD_VAR 0 2
15796: PUSH
15797: LD_INT 2
15799: EQUAL
15800: PUSH
15801: LD_EXP 53
15805: AND
15806: IFFALSE 15864
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
15808: LD_VAR 0 5
15812: PUSH
15813: LD_VAR 0 2
15817: ARRAY
15818: PPUSH
15819: LD_EXP 53
15823: PPUSH
15824: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
15828: LD_VAR 0 5
15832: PUSH
15833: LD_VAR 0 2
15837: ARRAY
15838: PPUSH
15839: LD_INT 86
15841: PPUSH
15842: LD_INT 133
15844: PPUSH
15845: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
15849: LD_VAR 0 5
15853: PUSH
15854: LD_VAR 0 2
15858: ARRAY
15859: PPUSH
15860: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
15864: LD_VAR 0 5
15868: PUSH
15869: LD_VAR 0 2
15873: ARRAY
15874: PPUSH
15875: LD_INT 8
15877: PPUSH
15878: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
15882: LD_VAR 0 5
15886: PUSH
15887: LD_VAR 0 2
15891: ARRAY
15892: PPUSH
15893: LD_EXP 36
15897: PPUSH
15898: CALL_OW 179
// end ;
15902: GO 15735
15904: POP
15905: POP
// if GirlNewVeh then
15906: LD_EXP 54
15910: IFFALSE 15924
// SetSide ( GirlNewVeh , 4 ) ;
15912: LD_EXP 54
15916: PPUSH
15917: LD_INT 4
15919: PPUSH
15920: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
15924: LD_INT 35
15926: PPUSH
15927: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
15931: LD_VAR 0 9
15935: PPUSH
15936: LD_INT 95
15938: PUSH
15939: LD_INT 9
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PPUSH
15946: CALL_OW 72
15950: PUSH
15951: LD_INT 0
15953: EQUAL
15954: PUSH
15955: LD_EXP 36
15959: PPUSH
15960: LD_INT 9
15962: PPUSH
15963: CALL_OW 308
15967: NOT
15968: AND
15969: IFFALSE 15924
// wait ( 0 0$2 ) ;
15971: LD_INT 70
15973: PPUSH
15974: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
15978: LD_VAR 0 9
15982: PPUSH
15983: LD_INT 1
15985: PPUSH
15986: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
15990: LD_INT 21
15992: PUSH
15993: LD_INT 2
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: PUSH
16000: LD_INT 92
16002: PUSH
16003: LD_INT 83
16005: PUSH
16006: LD_INT 130
16008: PUSH
16009: LD_INT 10
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: LIST
16016: LIST
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PPUSH
16022: CALL_OW 69
16026: PPUSH
16027: LD_INT 1
16029: PPUSH
16030: CALL_OW 235
// Video ( false ) ;
16034: LD_INT 0
16036: PPUSH
16037: CALL 103259 0 1
// ChangeMissionObjectives ( M1 ) ;
16041: LD_STRING M1
16043: PPUSH
16044: CALL_OW 337
// SaveForQuickRestart ;
16048: CALL_OW 22
// missionStart := true ;
16052: LD_ADDR_EXP 13
16056: PUSH
16057: LD_INT 1
16059: ST_TO_ADDR
// missionStage := 2 ;
16060: LD_ADDR_EXP 15
16064: PUSH
16065: LD_INT 2
16067: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16068: LD_INT 105
16070: PPUSH
16071: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
16075: LD_ADDR_VAR 0 5
16079: PUSH
16080: LD_VAR 0 5
16084: PUSH
16085: LD_INT 22
16087: PUSH
16088: LD_INT 1
16090: PUSH
16091: EMPTY
16092: LIST
16093: LIST
16094: PUSH
16095: LD_INT 21
16097: PUSH
16098: LD_INT 1
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PPUSH
16109: CALL_OW 69
16113: DIFF
16114: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16115: LD_ADDR_EXP 99
16119: PUSH
16120: LD_EXP 99
16124: PPUSH
16125: LD_INT 4
16127: PPUSH
16128: LD_INT 22
16130: PUSH
16131: LD_INT 4
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PUSH
16138: LD_INT 23
16140: PUSH
16141: LD_INT 1
16143: PUSH
16144: EMPTY
16145: LIST
16146: LIST
16147: PUSH
16148: LD_INT 3
16150: PUSH
16151: LD_INT 21
16153: PUSH
16154: LD_INT 2
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL_OW 69
16174: PUSH
16175: LD_EXP 55
16179: DIFF
16180: PPUSH
16181: CALL_OW 1
16185: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16186: LD_ADDR_VAR 0 4
16190: PUSH
16191: LD_INT 22
16193: PUSH
16194: LD_INT 4
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: PUSH
16201: LD_INT 34
16203: PUSH
16204: LD_INT 12
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PPUSH
16215: CALL_OW 69
16219: PUSH
16220: LD_INT 1
16222: ARRAY
16223: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16224: LD_VAR 0 5
16228: PUSH
16229: LD_INT 1
16231: ARRAY
16232: PPUSH
16233: CALL_OW 310
16237: IFFALSE 16252
// ComExitBuilding ( tmp [ 1 ] ) ;
16239: LD_VAR 0 5
16243: PUSH
16244: LD_INT 1
16246: ARRAY
16247: PPUSH
16248: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16252: LD_VAR 0 5
16256: PUSH
16257: LD_INT 1
16259: ARRAY
16260: PPUSH
16261: LD_VAR 0 4
16265: PPUSH
16266: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16270: LD_VAR 0 5
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: LD_INT 80
16281: PPUSH
16282: LD_INT 136
16284: PPUSH
16285: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16289: LD_VAR 0 5
16293: PUSH
16294: LD_INT 1
16296: ARRAY
16297: PPUSH
16298: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16302: LD_VAR 0 5
16306: PUSH
16307: LD_INT 1
16309: ARRAY
16310: PPUSH
16311: LD_INT 59
16313: PPUSH
16314: LD_INT 112
16316: PPUSH
16317: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16321: LD_VAR 0 5
16325: PUSH
16326: LD_INT 1
16328: ARRAY
16329: PPUSH
16330: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16334: LD_EXP 39
16338: PUSH
16339: LD_EXP 56
16343: IN
16344: PUSH
16345: LD_EXP 39
16349: PPUSH
16350: CALL_OW 255
16354: PUSH
16355: LD_INT 1
16357: EQUAL
16358: AND
16359: IFFALSE 16375
// Say ( Lisa , D3nW-Lisa-1 ) else
16361: LD_EXP 39
16365: PPUSH
16366: LD_STRING D3nW-Lisa-1
16368: PPUSH
16369: CALL_OW 88
16373: GO 16619
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
16375: LD_EXP 42
16379: PUSH
16380: LD_EXP 56
16384: IN
16385: PUSH
16386: LD_EXP 42
16390: PPUSH
16391: CALL_OW 255
16395: PUSH
16396: LD_INT 1
16398: EQUAL
16399: AND
16400: IFFALSE 16416
// Say ( Cyrus , D3nW-Cyrus-1 ) else
16402: LD_EXP 42
16406: PPUSH
16407: LD_STRING D3nW-Cyrus-1
16409: PPUSH
16410: CALL_OW 88
16414: GO 16619
// if Bobby in vip and GetSide ( Bobby ) = 1 then
16416: LD_EXP 41
16420: PUSH
16421: LD_EXP 56
16425: IN
16426: PUSH
16427: LD_EXP 41
16431: PPUSH
16432: CALL_OW 255
16436: PUSH
16437: LD_INT 1
16439: EQUAL
16440: AND
16441: IFFALSE 16457
// Say ( Bobby , D3nW-Bobby-1 ) else
16443: LD_EXP 41
16447: PPUSH
16448: LD_STRING D3nW-Bobby-1
16450: PPUSH
16451: CALL_OW 88
16455: GO 16619
// if Gary in vip and GetSide ( Gary ) = 1 then
16457: LD_EXP 48
16461: PUSH
16462: LD_EXP 56
16466: IN
16467: PUSH
16468: LD_EXP 48
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 1
16480: EQUAL
16481: AND
16482: IFFALSE 16498
// Say ( Gary , D3nW-Gary-1 ) else
16484: LD_EXP 48
16488: PPUSH
16489: LD_STRING D3nW-Gary-1
16491: PPUSH
16492: CALL_OW 88
16496: GO 16619
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
16498: LD_EXP 40
16502: PUSH
16503: LD_EXP 56
16507: IN
16508: PUSH
16509: LD_EXP 40
16513: PPUSH
16514: CALL_OW 255
16518: PUSH
16519: LD_INT 1
16521: EQUAL
16522: AND
16523: IFFALSE 16539
// Say ( Donaldson , D3nW-Don-1 ) else
16525: LD_EXP 40
16529: PPUSH
16530: LD_STRING D3nW-Don-1
16532: PPUSH
16533: CALL_OW 88
16537: GO 16619
// if Cornel in vip and GetSide ( Cornel ) = 1 then
16539: LD_EXP 47
16543: PUSH
16544: LD_EXP 56
16548: IN
16549: PUSH
16550: LD_EXP 47
16554: PPUSH
16555: CALL_OW 255
16559: PUSH
16560: LD_INT 1
16562: EQUAL
16563: AND
16564: IFFALSE 16580
// Say ( Cornel , D3nW-Corn-1 ) else
16566: LD_EXP 47
16570: PPUSH
16571: LD_STRING D3nW-Corn-1
16573: PPUSH
16574: CALL_OW 88
16578: GO 16619
// if Frank in vip and GetSide ( Frank ) = 1 then
16580: LD_EXP 49
16584: PUSH
16585: LD_EXP 56
16589: IN
16590: PUSH
16591: LD_EXP 49
16595: PPUSH
16596: CALL_OW 255
16600: PUSH
16601: LD_INT 1
16603: EQUAL
16604: AND
16605: IFFALSE 16619
// Say ( Frank , D3nW-Frank-1 ) ;
16607: LD_EXP 49
16611: PPUSH
16612: LD_STRING D3nW-Frank-1
16614: PPUSH
16615: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
16619: LD_EXP 36
16623: PPUSH
16624: LD_STRING D3nW-JMM-1
16626: PPUSH
16627: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
16631: LD_EXP 36
16635: PPUSH
16636: LD_STRING D3nW-JMM-1a
16638: PPUSH
16639: CALL_OW 88
// t := 0 0$00 ;
16643: LD_ADDR_VAR 0 3
16647: PUSH
16648: LD_INT 0
16650: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
16651: LD_INT 35
16653: PPUSH
16654: CALL_OW 67
// t := t + 0 0$1 ;
16658: LD_ADDR_VAR 0 3
16662: PUSH
16663: LD_VAR 0 3
16667: PUSH
16668: LD_INT 35
16670: PLUS
16671: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
16672: LD_INT 59
16674: PPUSH
16675: LD_INT 112
16677: PPUSH
16678: CALL_OW 428
16682: PUSH
16683: LD_VAR 0 3
16687: PUSH
16688: LD_INT 2100
16690: GREATER
16691: OR
16692: IFFALSE 16651
// activeAttacks := true ;
16694: LD_ADDR_EXP 16
16698: PUSH
16699: LD_INT 1
16701: ST_TO_ADDR
// end ;
16702: LD_VAR 0 1
16706: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
16707: LD_INT 0
16709: PPUSH
// case question of 1 :
16710: LD_VAR 0 1
16714: PUSH
16715: LD_INT 1
16717: DOUBLE
16718: EQUAL
16719: IFTRUE 16723
16721: GO 16774
16723: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
16724: LD_EXP 36
16728: PPUSH
16729: LD_STRING D2Mot-JMM-1
16731: PPUSH
16732: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
16736: LD_EXP 55
16740: PPUSH
16741: LD_STRING D2Mot-Pow-1
16743: PPUSH
16744: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
16748: LD_EXP 36
16752: PPUSH
16753: LD_STRING D2Mot-JMM-2
16755: PPUSH
16756: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
16760: LD_EXP 55
16764: PPUSH
16765: LD_STRING D2Mot-Pow-2
16767: PPUSH
16768: CALL_OW 88
// end ; 2 :
16772: GO 17117
16774: LD_INT 2
16776: DOUBLE
16777: EQUAL
16778: IFTRUE 16782
16780: GO 16858
16782: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
16783: LD_EXP 36
16787: PPUSH
16788: LD_STRING D2Rus-JMM-1
16790: PPUSH
16791: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
16795: LD_EXP 55
16799: PPUSH
16800: LD_STRING D2Rus-Pow-1
16802: PPUSH
16803: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
16807: LD_EXP 36
16811: PPUSH
16812: LD_STRING D2Rus-JMM-2
16814: PPUSH
16815: CALL_OW 88
// if not ( 3 in list_of_q ) then
16819: LD_INT 3
16821: PUSH
16822: LD_VAR 0 2
16826: IN
16827: NOT
16828: IFFALSE 16844
// Say ( Powell , D2Rus-Pow-2 ) else
16830: LD_EXP 55
16834: PPUSH
16835: LD_STRING D2Rus-Pow-2
16837: PPUSH
16838: CALL_OW 88
16842: GO 16856
// Say ( Powell , D2Rus-Pow-2a ) ;
16844: LD_EXP 55
16848: PPUSH
16849: LD_STRING D2Rus-Pow-2a
16851: PPUSH
16852: CALL_OW 88
// end ; 3 :
16856: GO 17117
16858: LD_INT 3
16860: DOUBLE
16861: EQUAL
16862: IFTRUE 16866
16864: GO 16951
16866: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
16867: LD_EXP 36
16871: PPUSH
16872: LD_STRING D2Leg-JMM-1
16874: PPUSH
16875: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
16879: LD_EXP 55
16883: PPUSH
16884: LD_STRING D2Leg-Pow-1
16886: PPUSH
16887: CALL_OW 88
// if 2 in list_of_q then
16891: LD_INT 2
16893: PUSH
16894: LD_VAR 0 2
16898: IN
16899: IFFALSE 16925
// begin Say ( JMM , D2Leg-JMM-2 ) ;
16901: LD_EXP 36
16905: PPUSH
16906: LD_STRING D2Leg-JMM-2
16908: PPUSH
16909: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
16913: LD_EXP 55
16917: PPUSH
16918: LD_STRING D2Leg-Pow-2
16920: PPUSH
16921: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
16925: LD_EXP 36
16929: PPUSH
16930: LD_STRING D2Leg-JMM-3
16932: PPUSH
16933: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
16937: LD_EXP 55
16941: PPUSH
16942: LD_STRING D2Leg-Pow-3
16944: PPUSH
16945: CALL_OW 88
// end ; 4 :
16949: GO 17117
16951: LD_INT 4
16953: DOUBLE
16954: EQUAL
16955: IFTRUE 16959
16957: GO 17034
16959: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
16960: LD_EXP 36
16964: PPUSH
16965: LD_STRING D2Ar-JMM-1
16967: PPUSH
16968: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
16972: LD_EXP 55
16976: PPUSH
16977: LD_STRING D2Ar-Pow-1
16979: PPUSH
16980: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
16984: LD_EXP 36
16988: PPUSH
16989: LD_STRING D2Ar-JMM-2
16991: PPUSH
16992: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
16996: LD_EXP 55
17000: PPUSH
17001: LD_STRING D2Ar-Pow-2
17003: PPUSH
17004: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17008: LD_EXP 36
17012: PPUSH
17013: LD_STRING D2Ar-JMM-3
17015: PPUSH
17016: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17020: LD_EXP 55
17024: PPUSH
17025: LD_STRING D2Ar-Pow-3
17027: PPUSH
17028: CALL_OW 88
// end ; 5 :
17032: GO 17117
17034: LD_INT 5
17036: DOUBLE
17037: EQUAL
17038: IFTRUE 17042
17040: GO 17057
17042: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17043: LD_EXP 36
17047: PPUSH
17048: LD_STRING D2Conf-JMM-1
17050: PPUSH
17051: CALL_OW 88
17055: GO 17117
17057: LD_INT 6
17059: DOUBLE
17060: EQUAL
17061: IFTRUE 17065
17063: GO 17116
17065: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17066: LD_EXP 36
17070: PPUSH
17071: LD_STRING D2Com-JMM-1
17073: PPUSH
17074: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17078: LD_EXP 55
17082: PPUSH
17083: LD_STRING D2Com-Pow-1
17085: PPUSH
17086: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17090: LD_EXP 36
17094: PPUSH
17095: LD_STRING D2Com-JMM-2
17097: PPUSH
17098: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17102: LD_EXP 55
17106: PPUSH
17107: LD_STRING D2Com-Pow-2
17109: PPUSH
17110: CALL_OW 88
// end ; end ;
17114: GO 17117
17116: POP
// end ;
17117: LD_VAR 0 3
17121: RET
// every 0 0$5 trigger missionStart do var tmp ;
17122: LD_EXP 13
17126: IFFALSE 17409
17128: GO 17130
17130: DISABLE
17131: LD_INT 0
17133: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17134: LD_INT 35
17136: PPUSH
17137: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17141: LD_INT 14
17143: PPUSH
17144: LD_INT 22
17146: PUSH
17147: LD_INT 1
17149: PUSH
17150: EMPTY
17151: LIST
17152: LIST
17153: PPUSH
17154: CALL_OW 70
17158: PUSH
17159: LD_EXP 15
17163: PUSH
17164: LD_INT 2
17166: PUSH
17167: LD_INT 3
17169: PUSH
17170: LD_INT 4
17172: PUSH
17173: LD_INT 5
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: LIST
17180: LIST
17181: IN
17182: AND
17183: IFFALSE 17399
// begin powellAnger := powellAnger + 1 ;
17185: LD_ADDR_EXP 17
17189: PUSH
17190: LD_EXP 17
17194: PUSH
17195: LD_INT 1
17197: PLUS
17198: ST_TO_ADDR
// Video ( true ) ;
17199: LD_INT 1
17201: PPUSH
17202: CALL 103259 0 1
// CenterNowOnUnits ( tmp ) ;
17206: LD_VAR 0 1
17210: PPUSH
17211: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17215: LD_INT 14
17217: PPUSH
17218: LD_INT 22
17220: PUSH
17221: LD_INT 1
17223: PUSH
17224: EMPTY
17225: LIST
17226: LIST
17227: PPUSH
17228: CALL_OW 70
17232: PPUSH
17233: LD_INT 86
17235: PPUSH
17236: LD_INT 133
17238: PPUSH
17239: CALL_OW 111
// async ;
17243: ASYNC
// case powellAnger of 1 :
17244: LD_EXP 17
17248: PUSH
17249: LD_INT 1
17251: DOUBLE
17252: EQUAL
17253: IFTRUE 17257
17255: GO 17272
17257: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17258: LD_EXP 55
17262: PPUSH
17263: LD_STRING DBack1-Pow-1
17265: PPUSH
17266: CALL_OW 88
17270: GO 17319
17272: LD_INT 2
17274: DOUBLE
17275: EQUAL
17276: IFTRUE 17280
17278: GO 17295
17280: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17281: LD_EXP 55
17285: PPUSH
17286: LD_STRING DBack2-Pow-1
17288: PPUSH
17289: CALL_OW 88
17293: GO 17319
17295: LD_INT 3
17297: DOUBLE
17298: EQUAL
17299: IFTRUE 17303
17301: GO 17318
17303: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17304: LD_EXP 55
17308: PPUSH
17309: LD_STRING DBack3-Pow-1
17311: PPUSH
17312: CALL_OW 88
17316: GO 17319
17318: POP
// sync ;
17319: SYNC
// repeat wait ( 0 0$1 ) ;
17320: LD_INT 35
17322: PPUSH
17323: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17327: LD_INT 14
17329: PPUSH
17330: LD_INT 22
17332: PUSH
17333: LD_INT 1
17335: PUSH
17336: EMPTY
17337: LIST
17338: LIST
17339: PPUSH
17340: CALL_OW 70
17344: PPUSH
17345: LD_INT 86
17347: PPUSH
17348: LD_INT 133
17350: PPUSH
17351: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17355: LD_INT 14
17357: PPUSH
17358: LD_INT 22
17360: PUSH
17361: LD_INT 1
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: PPUSH
17368: CALL_OW 70
17372: NOT
17373: IFFALSE 17320
// if powellAnger >= 3 then
17375: LD_EXP 17
17379: PUSH
17380: LD_INT 3
17382: GREATEREQUAL
17383: IFFALSE 17392
// YouLost ( Dismissed ) ;
17385: LD_STRING Dismissed
17387: PPUSH
17388: CALL_OW 104
// Video ( false ) ;
17392: LD_INT 0
17394: PPUSH
17395: CALL 103259 0 1
// end ; until missionStage > 5 ;
17399: LD_EXP 15
17403: PUSH
17404: LD_INT 5
17406: GREATER
17407: IFFALSE 17134
// end ;
17409: PPOPN 1
17411: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , ru , un ;
17412: LD_EXP 13
17416: PUSH
17417: LD_INT 22
17419: PUSH
17420: LD_INT 4
17422: PUSH
17423: EMPTY
17424: LIST
17425: LIST
17426: PUSH
17427: LD_INT 21
17429: PUSH
17430: LD_INT 2
17432: PUSH
17433: EMPTY
17434: LIST
17435: LIST
17436: PUSH
17437: EMPTY
17438: LIST
17439: LIST
17440: PPUSH
17441: CALL_OW 69
17445: PUSH
17446: LD_INT 4
17448: GREATEREQUAL
17449: AND
17450: PUSH
17451: LD_EXP 15
17455: PUSH
17456: LD_INT 2
17458: EQUAL
17459: AND
17460: IFFALSE 19054
17462: GO 17464
17464: DISABLE
17465: LD_INT 0
17467: PPUSH
17468: PPUSH
17469: PPUSH
17470: PPUSH
17471: PPUSH
17472: PPUSH
17473: PPUSH
// begin missionStage := 3 ;
17474: LD_ADDR_EXP 15
17478: PUSH
17479: LD_INT 3
17481: ST_TO_ADDR
// retreat := false ;
17482: LD_ADDR_VAR 0 4
17486: PUSH
17487: LD_INT 0
17489: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
17490: LD_ADDR_VAR 0 5
17494: PUSH
17495: LD_INT 22
17497: PUSH
17498: LD_INT 4
17500: PUSH
17501: EMPTY
17502: LIST
17503: LIST
17504: PUSH
17505: LD_INT 30
17507: PUSH
17508: LD_INT 4
17510: PUSH
17511: EMPTY
17512: LIST
17513: LIST
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: PPUSH
17519: CALL_OW 69
17523: PUSH
17524: LD_INT 1
17526: ARRAY
17527: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17528: LD_INT 35
17530: PPUSH
17531: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
17535: LD_EXP 118
17539: PUSH
17540: LD_INT 4
17542: ARRAY
17543: PUSH
17544: LD_INT 4
17546: GREATEREQUAL
17547: IFFALSE 17528
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
17549: LD_ADDR_VAR 0 2
17553: PUSH
17554: LD_INT 22
17556: PUSH
17557: LD_INT 4
17559: PUSH
17560: EMPTY
17561: LIST
17562: LIST
17563: PUSH
17564: LD_INT 2
17566: PUSH
17567: LD_INT 25
17569: PUSH
17570: LD_INT 1
17572: PUSH
17573: EMPTY
17574: LIST
17575: LIST
17576: PUSH
17577: LD_INT 25
17579: PUSH
17580: LD_INT 2
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: PUSH
17587: LD_INT 25
17589: PUSH
17590: LD_INT 3
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: PUSH
17597: LD_INT 25
17599: PUSH
17600: LD_INT 4
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 25
17609: PUSH
17610: LD_INT 5
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: LIST
17621: LIST
17622: LIST
17623: LIST
17624: PUSH
17625: EMPTY
17626: LIST
17627: LIST
17628: PPUSH
17629: CALL_OW 69
17633: PUSH
17634: LD_EXP 55
17638: PUSH
17639: LD_EXP 56
17643: ADD
17644: DIFF
17645: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_VAR 0 2
17655: PPUSH
17656: LD_INT 26
17658: PUSH
17659: LD_INT 1
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: PPUSH
17666: CALL_OW 72
17670: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
17671: LD_ADDR_VAR 0 2
17675: PUSH
17676: LD_VAR 0 2
17680: PUSH
17681: LD_VAR 0 3
17685: DIFF
17686: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
17687: LD_ADDR_VAR 0 2
17691: PUSH
17692: LD_VAR 0 2
17696: PPUSH
17697: LD_INT 1
17699: PPUSH
17700: CALL 101911 0 2
17704: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
17705: LD_ADDR_VAR 0 3
17709: PUSH
17710: LD_VAR 0 3
17714: PPUSH
17715: LD_INT 1
17717: PPUSH
17718: CALL 101911 0 2
17722: ST_TO_ADDR
// for i = 1 to 4 do
17723: LD_ADDR_VAR 0 1
17727: PUSH
17728: DOUBLE
17729: LD_INT 1
17731: DEC
17732: ST_TO_ADDR
17733: LD_INT 4
17735: PUSH
17736: FOR_TO
17737: IFFALSE 17903
// begin if tmp2 then
17739: LD_VAR 0 3
17743: IFFALSE 17824
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
17745: LD_ADDR_EXP 18
17749: PUSH
17750: LD_EXP 18
17754: PPUSH
17755: LD_INT 1
17757: PPUSH
17758: LD_EXP 18
17762: PUSH
17763: LD_INT 1
17765: ARRAY
17766: PUSH
17767: LD_VAR 0 3
17771: PUSH
17772: LD_VAR 0 3
17776: ARRAY
17777: ADD
17778: PPUSH
17779: CALL_OW 1
17783: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
17784: LD_VAR 0 3
17788: PUSH
17789: LD_VAR 0 3
17793: ARRAY
17794: PPUSH
17795: LD_INT 1
17797: PPUSH
17798: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
17802: LD_ADDR_VAR 0 3
17806: PUSH
17807: LD_VAR 0 3
17811: PPUSH
17812: LD_VAR 0 3
17816: PPUSH
17817: CALL_OW 3
17821: ST_TO_ADDR
// end else
17822: GO 17901
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
17824: LD_ADDR_EXP 18
17828: PUSH
17829: LD_EXP 18
17833: PPUSH
17834: LD_INT 1
17836: PPUSH
17837: LD_EXP 18
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PUSH
17846: LD_VAR 0 2
17850: PUSH
17851: LD_VAR 0 2
17855: ARRAY
17856: ADD
17857: PPUSH
17858: CALL_OW 1
17862: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
17863: LD_VAR 0 2
17867: PUSH
17868: LD_VAR 0 2
17872: ARRAY
17873: PPUSH
17874: LD_INT 1
17876: PPUSH
17877: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
17881: LD_ADDR_VAR 0 2
17885: PUSH
17886: LD_VAR 0 2
17890: PPUSH
17891: LD_VAR 0 2
17895: PPUSH
17896: CALL_OW 3
17900: ST_TO_ADDR
// end ; end ;
17901: GO 17736
17903: POP
17904: POP
// if tmp2 then
17905: LD_VAR 0 3
17909: IFFALSE 17927
// tmp := tmp union tmp2 ;
17911: LD_ADDR_VAR 0 2
17915: PUSH
17916: LD_VAR 0 2
17920: PUSH
17921: LD_VAR 0 3
17925: UNION
17926: ST_TO_ADDR
// for i = 1 to 4 do
17927: LD_ADDR_VAR 0 1
17931: PUSH
17932: DOUBLE
17933: LD_INT 1
17935: DEC
17936: ST_TO_ADDR
17937: LD_INT 4
17939: PUSH
17940: FOR_TO
17941: IFFALSE 17990
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
17943: LD_ADDR_EXP 18
17947: PUSH
17948: LD_EXP 18
17952: PPUSH
17953: LD_INT 2
17955: PPUSH
17956: LD_EXP 18
17960: PUSH
17961: LD_INT 2
17963: ARRAY
17964: PUSH
17965: LD_VAR 0 2
17969: PUSH
17970: LD_VAR 0 2
17974: PUSH
17975: LD_VAR 0 1
17979: MINUS
17980: ARRAY
17981: ADD
17982: PPUSH
17983: CALL_OW 1
17987: ST_TO_ADDR
17988: GO 17940
17990: POP
17991: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
17992: LD_ADDR_EXP 99
17996: PUSH
17997: LD_EXP 99
18001: PPUSH
18002: LD_INT 4
18004: PPUSH
18005: LD_EXP 99
18009: PUSH
18010: LD_INT 4
18012: ARRAY
18013: PUSH
18014: LD_EXP 18
18018: PUSH
18019: LD_INT 1
18021: ARRAY
18022: DIFF
18023: PPUSH
18024: CALL_OW 1
18028: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
18029: LD_ADDR_VAR 0 1
18033: PUSH
18034: LD_EXP 18
18038: PUSH
18039: LD_INT 1
18041: ARRAY
18042: PUSH
18043: FOR_IN
18044: IFFALSE 18147
// begin if IsInUnit ( i ) then
18046: LD_VAR 0 1
18050: PPUSH
18051: CALL_OW 310
18055: IFFALSE 18066
// ComExitBuilding ( i ) ;
18057: LD_VAR 0 1
18061: PPUSH
18062: CALL_OW 122
// if GetClass ( i ) <> 1 then
18066: LD_VAR 0 1
18070: PPUSH
18071: CALL_OW 257
18075: PUSH
18076: LD_INT 1
18078: NONEQUAL
18079: IFFALSE 18116
// begin AddComEnterUnit ( i , arm ) ;
18081: LD_VAR 0 1
18085: PPUSH
18086: LD_VAR 0 5
18090: PPUSH
18091: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18095: LD_VAR 0 1
18099: PPUSH
18100: LD_INT 1
18102: PPUSH
18103: CALL_OW 183
// AddComExitBuilding ( i ) ;
18107: LD_VAR 0 1
18111: PPUSH
18112: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18116: LD_VAR 0 1
18120: PPUSH
18121: LD_INT 60
18123: PPUSH
18124: LD_INT 94
18126: PPUSH
18127: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18131: LD_VAR 0 1
18135: PPUSH
18136: LD_EXP 55
18140: PPUSH
18141: CALL_OW 179
// end ;
18145: GO 18043
18147: POP
18148: POP
// wait ( 0 0$15 ) ;
18149: LD_INT 525
18151: PPUSH
18152: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
18156: LD_EXP 55
18160: PPUSH
18161: LD_STRING D4-Pow-1
18163: PPUSH
18164: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
18168: LD_ADDR_VAR 0 2
18172: PUSH
18173: LD_EXP 18
18177: PUSH
18178: LD_INT 1
18180: ARRAY
18181: PPUSH
18182: LD_INT 26
18184: PUSH
18185: LD_INT 1
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PPUSH
18192: CALL_OW 72
18196: ST_TO_ADDR
// if tmp then
18197: LD_VAR 0 2
18201: IFFALSE 18219
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
18203: LD_VAR 0 2
18207: PUSH
18208: LD_INT 1
18210: ARRAY
18211: PPUSH
18212: LD_STRING D4-Sol1-1
18214: PPUSH
18215: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
18219: LD_EXP 55
18223: PPUSH
18224: LD_STRING D4-Pow-2
18226: PPUSH
18227: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
18231: LD_ADDR_VAR 0 1
18235: PUSH
18236: DOUBLE
18237: LD_INT 1
18239: DEC
18240: ST_TO_ADDR
18241: LD_EXP 18
18245: PUSH
18246: LD_INT 1
18248: ARRAY
18249: PUSH
18250: FOR_TO
18251: IFFALSE 18344
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
18253: LD_EXP 18
18257: PUSH
18258: LD_INT 1
18260: ARRAY
18261: PUSH
18262: LD_VAR 0 1
18266: ARRAY
18267: PPUSH
18268: LD_EXP 118
18272: PUSH
18273: LD_INT 4
18275: ARRAY
18276: PUSH
18277: LD_INT 1
18279: ARRAY
18280: PPUSH
18281: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
18285: LD_ADDR_EXP 118
18289: PUSH
18290: LD_EXP 118
18294: PPUSH
18295: LD_INT 4
18297: PPUSH
18298: LD_EXP 118
18302: PUSH
18303: LD_INT 4
18305: ARRAY
18306: PPUSH
18307: LD_INT 1
18309: PPUSH
18310: CALL_OW 3
18314: PPUSH
18315: CALL_OW 1
18319: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
18320: LD_INT 8
18322: PPUSH
18323: LD_EXP 18
18327: PUSH
18328: LD_INT 1
18330: ARRAY
18331: PUSH
18332: LD_VAR 0 1
18336: ARRAY
18337: PPUSH
18338: CALL_OW 471
// end ;
18342: GO 18250
18344: POP
18345: POP
// repeat wait ( 0 0$1 ) ;
18346: LD_INT 35
18348: PPUSH
18349: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
18353: LD_EXP 18
18357: PUSH
18358: LD_INT 1
18360: ARRAY
18361: PPUSH
18362: LD_INT 55
18364: PUSH
18365: EMPTY
18366: LIST
18367: PPUSH
18368: CALL_OW 72
18372: PUSH
18373: LD_INT 4
18375: GREATEREQUAL
18376: IFFALSE 18346
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
18378: LD_EXP 18
18382: PUSH
18383: LD_INT 1
18385: ARRAY
18386: PPUSH
18387: LD_INT 69
18389: PPUSH
18390: LD_INT 94
18392: PPUSH
18393: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
18397: LD_EXP 18
18401: PUSH
18402: LD_INT 1
18404: ARRAY
18405: PPUSH
18406: LD_INT 82
18408: PPUSH
18409: LD_INT 83
18411: PPUSH
18412: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
18416: LD_EXP 18
18420: PUSH
18421: LD_INT 1
18423: ARRAY
18424: PPUSH
18425: LD_INT 77
18427: PPUSH
18428: LD_INT 69
18430: PPUSH
18431: CALL_OW 174
// repeat wait ( 3 ) ;
18435: LD_INT 3
18437: PPUSH
18438: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18442: LD_ADDR_VAR 0 1
18446: PUSH
18447: LD_EXP 18
18451: PUSH
18452: LD_INT 1
18454: ARRAY
18455: PUSH
18456: FOR_IN
18457: IFFALSE 18566
// begin if GetLives ( i ) < 990 then
18459: LD_VAR 0 1
18463: PPUSH
18464: CALL_OW 256
18468: PUSH
18469: LD_INT 990
18471: LESS
18472: IFFALSE 18486
// SetLives ( i , 1000 ) ;
18474: LD_VAR 0 1
18478: PPUSH
18479: LD_INT 1000
18481: PPUSH
18482: CALL_OW 234
// if not IsInUnit ( i ) then
18486: LD_VAR 0 1
18490: PPUSH
18491: CALL_OW 310
18495: NOT
18496: IFFALSE 18564
// begin if not retreat and GetSex ( i ) = sex_male then
18498: LD_VAR 0 4
18502: NOT
18503: PUSH
18504: LD_VAR 0 1
18508: PPUSH
18509: CALL_OW 258
18513: PUSH
18514: LD_INT 1
18516: EQUAL
18517: AND
18518: IFFALSE 18564
// begin retreat := true ;
18520: LD_ADDR_VAR 0 4
18524: PUSH
18525: LD_INT 1
18527: ST_TO_ADDR
// SetTag ( i , 2 ) ;
18528: LD_VAR 0 1
18532: PPUSH
18533: LD_INT 2
18535: PPUSH
18536: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
18540: LD_VAR 0 1
18544: PPUSH
18545: LD_STRING D4a-Sol1-1
18547: PPUSH
18548: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
18552: LD_EXP 55
18556: PPUSH
18557: LD_STRING D4a-Pow-1
18559: PPUSH
18560: CALL_OW 88
// end ; end ; end ;
18564: GO 18456
18566: POP
18567: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
18568: LD_EXP 18
18572: PUSH
18573: LD_INT 1
18575: ARRAY
18576: PPUSH
18577: LD_INT 95
18579: PUSH
18580: LD_INT 9
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: PUSH
18587: LD_INT 3
18589: PUSH
18590: LD_INT 55
18592: PUSH
18593: EMPTY
18594: LIST
18595: PUSH
18596: EMPTY
18597: LIST
18598: LIST
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PPUSH
18604: CALL_OW 72
18608: PUSH
18609: LD_INT 4
18611: GREATEREQUAL
18612: IFFALSE 18435
// for i in powellSquadAttack [ 1 ] do
18614: LD_ADDR_VAR 0 1
18618: PUSH
18619: LD_EXP 18
18623: PUSH
18624: LD_INT 1
18626: ARRAY
18627: PUSH
18628: FOR_IN
18629: IFFALSE 18765
// begin if GetTag ( i ) = 2 then
18631: LD_VAR 0 1
18635: PPUSH
18636: CALL_OW 110
18640: PUSH
18641: LD_INT 2
18643: EQUAL
18644: IFFALSE 18706
// begin ComMoveXY ( i , 60 , 94 ) ;
18646: LD_VAR 0 1
18650: PPUSH
18651: LD_INT 60
18653: PPUSH
18654: LD_INT 94
18656: PPUSH
18657: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
18661: LD_VAR 0 1
18665: PPUSH
18666: LD_EXP 55
18670: PPUSH
18671: CALL_OW 179
// wait ( 0 0$3 ) ;
18675: LD_INT 105
18677: PPUSH
18678: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
18682: LD_VAR 0 1
18686: PPUSH
18687: LD_STRING D4a-Sol1-2
18689: PPUSH
18690: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
18694: LD_EXP 55
18698: PPUSH
18699: LD_STRING D4a-Pow-2
18701: PPUSH
18702: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
18706: LD_VAR 0 1
18710: PPUSH
18711: LD_INT 0
18713: PPUSH
18714: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
18718: LD_ADDR_EXP 99
18722: PUSH
18723: LD_EXP 99
18727: PPUSH
18728: LD_INT 4
18730: PPUSH
18731: LD_EXP 99
18735: PUSH
18736: LD_INT 4
18738: ARRAY
18739: PUSH
18740: LD_VAR 0 1
18744: UNION
18745: PPUSH
18746: CALL_OW 1
18750: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
18751: LD_INT 8
18753: PPUSH
18754: LD_VAR 0 1
18758: PPUSH
18759: CALL_OW 472
// end ;
18763: GO 18628
18765: POP
18766: POP
// wait ( 4 4$00 ) ;
18767: LD_INT 8400
18769: PPUSH
18770: CALL_OW 67
// uc_side := 6 ;
18774: LD_ADDR_OWVAR 20
18778: PUSH
18779: LD_INT 6
18781: ST_TO_ADDR
// uc_nation := 3 ;
18782: LD_ADDR_OWVAR 21
18786: PUSH
18787: LD_INT 3
18789: ST_TO_ADDR
// ru := [ ] ;
18790: LD_ADDR_VAR 0 6
18794: PUSH
18795: EMPTY
18796: ST_TO_ADDR
// for i = 1 to 4 do
18797: LD_ADDR_VAR 0 1
18801: PUSH
18802: DOUBLE
18803: LD_INT 1
18805: DEC
18806: ST_TO_ADDR
18807: LD_INT 4
18809: PUSH
18810: FOR_TO
18811: IFFALSE 18912
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
18813: LD_INT 22
18815: PPUSH
18816: LD_INT 1
18818: PPUSH
18819: LD_INT 3
18821: PPUSH
18822: LD_INT 43
18824: PUSH
18825: LD_INT 44
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: PUSH
18832: LD_INT 1
18834: PPUSH
18835: LD_INT 2
18837: PPUSH
18838: CALL_OW 12
18842: ARRAY
18843: PPUSH
18844: LD_INT 89
18846: PPUSH
18847: CALL 67604 0 5
// un := CreateVehicle ;
18851: LD_ADDR_VAR 0 7
18855: PUSH
18856: CALL_OW 45
18860: ST_TO_ADDR
// SetDir ( un , 4 ) ;
18861: LD_VAR 0 7
18865: PPUSH
18866: LD_INT 4
18868: PPUSH
18869: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
18873: LD_VAR 0 7
18877: PPUSH
18878: LD_INT 136
18880: PPUSH
18881: LD_INT 90
18883: PPUSH
18884: LD_INT 8
18886: PPUSH
18887: LD_INT 0
18889: PPUSH
18890: CALL_OW 50
// ru := ru ^ un ;
18894: LD_ADDR_VAR 0 6
18898: PUSH
18899: LD_VAR 0 6
18903: PUSH
18904: LD_VAR 0 7
18908: ADD
18909: ST_TO_ADDR
// end ;
18910: GO 18810
18912: POP
18913: POP
// if ru then
18914: LD_VAR 0 6
18918: IFFALSE 18935
// ComAgressiveMove ( ru , 80 , 93 ) ;
18920: LD_VAR 0 6
18924: PPUSH
18925: LD_INT 80
18927: PPUSH
18928: LD_INT 93
18930: PPUSH
18931: CALL_OW 114
// wait ( 8 8$00 ) ;
18935: LD_INT 16800
18937: PPUSH
18938: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
18942: LD_INT 4
18944: PPUSH
18945: LD_INT 3
18947: PUSH
18948: LD_INT 1
18950: PUSH
18951: LD_INT 1
18953: PUSH
18954: LD_INT 5
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: PUSH
18963: LD_INT 4
18965: PUSH
18966: LD_INT 1
18968: PUSH
18969: LD_INT 1
18971: PUSH
18972: LD_INT 6
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: PUSH
18981: LD_INT 4
18983: PUSH
18984: LD_INT 1
18986: PUSH
18987: LD_INT 1
18989: PUSH
18990: LD_INT 7
18992: PUSH
18993: EMPTY
18994: LIST
18995: LIST
18996: LIST
18997: LIST
18998: PUSH
18999: LD_INT 3
19001: PUSH
19002: LD_INT 1
19004: PUSH
19005: LD_INT 1
19007: PUSH
19008: LD_INT 7
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: LIST
19015: LIST
19016: PUSH
19017: LD_INT 3
19019: PUSH
19020: LD_INT 1
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: LD_INT 5
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: PUSH
19035: EMPTY
19036: LIST
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: PPUSH
19042: CALL 55028 0 2
// missionStage := 4 ;
19046: LD_ADDR_EXP 15
19050: PUSH
19051: LD_INT 4
19053: ST_TO_ADDR
// end ;
19054: PPOPN 7
19056: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19057: LD_EXP 15
19061: PUSH
19062: LD_INT 4
19064: EQUAL
19065: PUSH
19066: LD_INT 22
19068: PUSH
19069: LD_INT 4
19071: PUSH
19072: EMPTY
19073: LIST
19074: LIST
19075: PUSH
19076: LD_INT 21
19078: PUSH
19079: LD_INT 2
19081: PUSH
19082: EMPTY
19083: LIST
19084: LIST
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: PPUSH
19090: CALL_OW 69
19094: PUSH
19095: LD_INT 5
19097: GREATEREQUAL
19098: AND
19099: IFFALSE 23160
19101: GO 19103
19103: DISABLE
19104: LD_INT 0
19106: PPUSH
19107: PPUSH
19108: PPUSH
19109: PPUSH
19110: PPUSH
19111: PPUSH
19112: PPUSH
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
19118: PPUSH
// begin missionStage := 5 ;
19119: LD_ADDR_EXP 15
19123: PUSH
19124: LD_INT 5
19126: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19127: LD_ADDR_VAR 0 10
19131: PUSH
19132: LD_INT 22
19134: PUSH
19135: LD_INT 4
19137: PUSH
19138: EMPTY
19139: LIST
19140: LIST
19141: PUSH
19142: LD_INT 2
19144: PUSH
19145: LD_INT 30
19147: PUSH
19148: LD_INT 4
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: PUSH
19155: LD_INT 30
19157: PUSH
19158: LD_INT 5
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: LIST
19169: PUSH
19170: EMPTY
19171: LIST
19172: LIST
19173: PPUSH
19174: CALL_OW 69
19178: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
19179: LD_ADDR_VAR 0 6
19183: PUSH
19184: LD_INT 22
19186: PUSH
19187: LD_INT 4
19189: PUSH
19190: EMPTY
19191: LIST
19192: LIST
19193: PUSH
19194: LD_INT 21
19196: PUSH
19197: LD_INT 1
19199: PUSH
19200: EMPTY
19201: LIST
19202: LIST
19203: PUSH
19204: LD_INT 3
19206: PUSH
19207: LD_INT 25
19209: PUSH
19210: LD_INT 16
19212: PUSH
19213: EMPTY
19214: LIST
19215: LIST
19216: PUSH
19217: EMPTY
19218: LIST
19219: LIST
19220: PUSH
19221: LD_INT 3
19223: PUSH
19224: LD_INT 25
19226: PUSH
19227: LD_INT 12
19229: PUSH
19230: EMPTY
19231: LIST
19232: LIST
19233: PUSH
19234: EMPTY
19235: LIST
19236: LIST
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: PPUSH
19244: CALL_OW 69
19248: PUSH
19249: LD_EXP 55
19253: DIFF
19254: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
19255: LD_ADDR_VAR 0 9
19259: PUSH
19260: LD_INT 22
19262: PUSH
19263: LD_INT 4
19265: PUSH
19266: EMPTY
19267: LIST
19268: LIST
19269: PUSH
19270: LD_INT 30
19272: PUSH
19273: LD_INT 3
19275: PUSH
19276: EMPTY
19277: LIST
19278: LIST
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PPUSH
19284: CALL_OW 69
19288: PUSH
19289: LD_INT 1
19291: ARRAY
19292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19293: LD_INT 35
19295: PPUSH
19296: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
19300: LD_EXP 118
19304: PUSH
19305: LD_INT 4
19307: ARRAY
19308: PUSH
19309: LD_INT 5
19311: GREATEREQUAL
19312: IFFALSE 19293
// powellAllowRetreat := false ;
19314: LD_ADDR_EXP 19
19318: PUSH
19319: LD_INT 0
19321: ST_TO_ADDR
// wait ( 0 0$20 ) ;
19322: LD_INT 700
19324: PPUSH
19325: CALL_OW 67
// activeAttacks := false ;
19329: LD_ADDR_EXP 16
19333: PUSH
19334: LD_INT 0
19336: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19337: LD_INT 35
19339: PPUSH
19340: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
19344: LD_INT 22
19346: PUSH
19347: LD_INT 6
19349: PUSH
19350: EMPTY
19351: LIST
19352: LIST
19353: PPUSH
19354: CALL_OW 69
19358: PUSH
19359: LD_INT 0
19361: EQUAL
19362: IFFALSE 19337
// tmp := mc_vehicles [ 4 ] ;
19364: LD_ADDR_VAR 0 3
19368: PUSH
19369: LD_EXP 118
19373: PUSH
19374: LD_INT 4
19376: ARRAY
19377: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
19378: LD_ADDR_VAR 0 1
19382: PUSH
19383: DOUBLE
19384: LD_INT 1
19386: DEC
19387: ST_TO_ADDR
19388: LD_EXP 18
19392: PUSH
19393: FOR_TO
19394: IFFALSE 19655
// begin for j in powellSquadAttack [ i ] do
19396: LD_ADDR_VAR 0 2
19400: PUSH
19401: LD_EXP 18
19405: PUSH
19406: LD_VAR 0 1
19410: ARRAY
19411: PUSH
19412: FOR_IN
19413: IFFALSE 19651
// begin forces := forces diff j ;
19415: LD_ADDR_VAR 0 6
19419: PUSH
19420: LD_VAR 0 6
19424: PUSH
19425: LD_VAR 0 2
19429: DIFF
19430: ST_TO_ADDR
// SetTag ( j , 1 ) ;
19431: LD_VAR 0 2
19435: PPUSH
19436: LD_INT 1
19438: PPUSH
19439: CALL_OW 109
// wait ( 0 0$2 ) ;
19443: LD_INT 70
19445: PPUSH
19446: CALL_OW 67
// if IsInUnit ( j ) then
19450: LD_VAR 0 2
19454: PPUSH
19455: CALL_OW 310
19459: IFFALSE 19470
// ComExitBuilding ( j ) ;
19461: LD_VAR 0 2
19465: PPUSH
19466: CALL_OW 122
// if GetClass ( j ) <> 1 then
19470: LD_VAR 0 2
19474: PPUSH
19475: CALL_OW 257
19479: PUSH
19480: LD_INT 1
19482: NONEQUAL
19483: IFFALSE 19563
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
19485: LD_VAR 0 10
19489: PUSH
19490: LD_INT 1
19492: ARRAY
19493: PPUSH
19494: CALL_OW 313
19498: PUSH
19499: LD_INT 5
19501: GREATEREQUAL
19502: IFFALSE 19524
// AddComEnterUnit ( j , arm [ 2 ] ) else
19504: LD_VAR 0 2
19508: PPUSH
19509: LD_VAR 0 10
19513: PUSH
19514: LD_INT 2
19516: ARRAY
19517: PPUSH
19518: CALL_OW 180
19522: GO 19542
// AddComEnterUnit ( j , arm [ 1 ] ) ;
19524: LD_VAR 0 2
19528: PPUSH
19529: LD_VAR 0 10
19533: PUSH
19534: LD_INT 1
19536: ARRAY
19537: PPUSH
19538: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
19542: LD_VAR 0 2
19546: PPUSH
19547: LD_INT 1
19549: PPUSH
19550: CALL_OW 183
// AddComExitBuilding ( j ) ;
19554: LD_VAR 0 2
19558: PPUSH
19559: CALL_OW 182
// end ; if i = 2 then
19563: LD_VAR 0 1
19567: PUSH
19568: LD_INT 2
19570: EQUAL
19571: IFFALSE 19588
// AddComMoveXY ( j , 61 , 93 ) ;
19573: LD_VAR 0 2
19577: PPUSH
19578: LD_INT 61
19580: PPUSH
19581: LD_INT 93
19583: PPUSH
19584: CALL_OW 171
// if i = 1 then
19588: LD_VAR 0 1
19592: PUSH
19593: LD_INT 1
19595: EQUAL
19596: IFFALSE 19649
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
19598: LD_VAR 0 2
19602: PPUSH
19603: LD_VAR 0 3
19607: PUSH
19608: LD_INT 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
19616: LD_ADDR_VAR 0 3
19620: PUSH
19621: LD_VAR 0 3
19625: PPUSH
19626: LD_INT 1
19628: PPUSH
19629: CALL_OW 3
19633: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
19634: LD_VAR 0 2
19638: PPUSH
19639: LD_INT 69
19641: PPUSH
19642: LD_INT 94
19644: PPUSH
19645: CALL_OW 171
// end ; end ;
19649: GO 19412
19651: POP
19652: POP
// end ;
19653: GO 19393
19655: POP
19656: POP
// wait ( 0 0$45 ) ;
19657: LD_INT 1575
19659: PPUSH
19660: CALL_OW 67
// MC_Kill ( 4 ) ;
19664: LD_INT 4
19666: PPUSH
19667: CALL 32997 0 1
// tmp := UnitsInside ( fac ) ;
19671: LD_ADDR_VAR 0 3
19675: PUSH
19676: LD_VAR 0 9
19680: PPUSH
19681: CALL_OW 313
19685: ST_TO_ADDR
// if tmp then
19686: LD_VAR 0 3
19690: IFFALSE 19811
// for i in tmp do
19692: LD_ADDR_VAR 0 1
19696: PUSH
19697: LD_VAR 0 3
19701: PUSH
19702: FOR_IN
19703: IFFALSE 19809
// begin ComExitBuilding ( i ) ;
19705: LD_VAR 0 1
19709: PPUSH
19710: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
19714: LD_VAR 0 10
19718: PUSH
19719: LD_INT 2
19721: ARRAY
19722: PPUSH
19723: CALL_OW 313
19727: PUSH
19728: LD_INT 6
19730: LESS
19731: IFFALSE 19753
// AddComEnterUnit ( i , arm [ 2 ] ) else
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_VAR 0 10
19742: PUSH
19743: LD_INT 2
19745: ARRAY
19746: PPUSH
19747: CALL_OW 180
19751: GO 19807
// if UnitsInside ( arm [ 1 ] ) < 6 then
19753: LD_VAR 0 10
19757: PUSH
19758: LD_INT 1
19760: ARRAY
19761: PPUSH
19762: CALL_OW 313
19766: PUSH
19767: LD_INT 6
19769: LESS
19770: IFFALSE 19792
// AddComEnterUnit ( i , arm [ 1 ] ) else
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 10
19781: PUSH
19782: LD_INT 1
19784: ARRAY
19785: PPUSH
19786: CALL_OW 180
19790: GO 19807
// AddComMoveXY ( i , 37 , 68 ) ;
19792: LD_VAR 0 1
19796: PPUSH
19797: LD_INT 37
19799: PPUSH
19800: LD_INT 68
19802: PPUSH
19803: CALL_OW 171
// end ;
19807: GO 19702
19809: POP
19810: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
19811: LD_ADDR_VAR 0 11
19815: PUSH
19816: LD_VAR 0 6
19820: PPUSH
19821: LD_INT 26
19823: PUSH
19824: LD_INT 1
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: PPUSH
19831: CALL_OW 72
19835: PUSH
19836: LD_EXP 56
19840: DIFF
19841: ST_TO_ADDR
// if not speaker then
19842: LD_VAR 0 11
19846: NOT
19847: IFFALSE 19874
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
19849: LD_ADDR_VAR 0 11
19853: PUSH
19854: LD_VAR 0 6
19858: PPUSH
19859: LD_INT 26
19861: PUSH
19862: LD_INT 1
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PPUSH
19869: CALL_OW 72
19873: ST_TO_ADDR
// if speaker then
19874: LD_VAR 0 11
19878: IFFALSE 19894
// speaker := speaker [ 1 ] ;
19880: LD_ADDR_VAR 0 11
19884: PUSH
19885: LD_VAR 0 11
19889: PUSH
19890: LD_INT 1
19892: ARRAY
19893: ST_TO_ADDR
// Video ( true ) ;
19894: LD_INT 1
19896: PPUSH
19897: CALL 103259 0 1
// CenterNowOnUnits ( Powell ) ;
19901: LD_EXP 55
19905: PPUSH
19906: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
19910: LD_ADDR_VAR 0 3
19914: PUSH
19915: LD_VAR 0 6
19919: PPUSH
19920: LD_INT 3
19922: PUSH
19923: LD_INT 25
19925: PUSH
19926: LD_INT 1
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: PUSH
19933: EMPTY
19934: LIST
19935: LIST
19936: PPUSH
19937: CALL_OW 72
19941: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
19942: LD_ADDR_VAR 0 12
19946: PUSH
19947: LD_INT 22
19949: PUSH
19950: LD_INT 4
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: LD_INT 30
19959: PUSH
19960: LD_INT 32
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: PUSH
19967: LD_INT 58
19969: PUSH
19970: EMPTY
19971: LIST
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: LIST
19977: PPUSH
19978: CALL_OW 69
19982: ST_TO_ADDR
// for i = 1 to 6 do
19983: LD_ADDR_VAR 0 1
19987: PUSH
19988: DOUBLE
19989: LD_INT 1
19991: DEC
19992: ST_TO_ADDR
19993: LD_INT 6
19995: PUSH
19996: FOR_TO
19997: IFFALSE 20138
// begin if IsInUnit ( tmp [ i ] ) then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_VAR 0 1
20008: ARRAY
20009: PPUSH
20010: CALL_OW 310
20014: IFFALSE 20031
// ComExitBuilding ( tmp [ i ] ) ;
20016: LD_VAR 0 3
20020: PUSH
20021: LD_VAR 0 1
20025: ARRAY
20026: PPUSH
20027: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20031: LD_VAR 0 3
20035: PUSH
20036: LD_VAR 0 1
20040: ARRAY
20041: PPUSH
20042: LD_VAR 0 10
20046: PUSH
20047: LD_INT 1
20049: ARRAY
20050: PPUSH
20051: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20055: LD_VAR 0 3
20059: PUSH
20060: LD_VAR 0 1
20064: ARRAY
20065: PPUSH
20066: LD_INT 1
20068: PPUSH
20069: CALL_OW 183
// if emp_towers then
20073: LD_VAR 0 12
20077: IFFALSE 20136
// begin AddComExitBuilding ( tmp [ i ] ) ;
20079: LD_VAR 0 3
20083: PUSH
20084: LD_VAR 0 1
20088: ARRAY
20089: PPUSH
20090: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20094: LD_VAR 0 3
20098: PUSH
20099: LD_VAR 0 1
20103: ARRAY
20104: PPUSH
20105: LD_VAR 0 12
20109: PUSH
20110: LD_INT 1
20112: ARRAY
20113: PPUSH
20114: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
20118: LD_ADDR_VAR 0 12
20122: PUSH
20123: LD_VAR 0 12
20127: PPUSH
20128: LD_INT 1
20130: PPUSH
20131: CALL_OW 3
20135: ST_TO_ADDR
// end ; end ;
20136: GO 19996
20138: POP
20139: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
20140: LD_ADDR_VAR 0 3
20144: PUSH
20145: LD_EXP 18
20149: PUSH
20150: LD_INT 1
20152: ARRAY
20153: PUSH
20154: LD_EXP 18
20158: PUSH
20159: LD_INT 2
20161: ARRAY
20162: ADD
20163: PPUSH
20164: LD_INT 26
20166: PUSH
20167: LD_INT 1
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PPUSH
20174: CALL_OW 72
20178: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
20179: LD_ADDR_VAR 0 1
20183: PUSH
20184: LD_EXP 18
20188: PUSH
20189: LD_INT 2
20191: ARRAY
20192: PUSH
20193: FOR_IN
20194: IFFALSE 20212
// ComTurnUnit ( i , Powell ) ;
20196: LD_VAR 0 1
20200: PPUSH
20201: LD_EXP 55
20205: PPUSH
20206: CALL_OW 119
20210: GO 20193
20212: POP
20213: POP
// Say ( Powell , D5-Pow-1 ) ;
20214: LD_EXP 55
20218: PPUSH
20219: LD_STRING D5-Pow-1
20221: PPUSH
20222: CALL_OW 88
// if tmp then
20226: LD_VAR 0 3
20230: IFFALSE 20248
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
20232: LD_VAR 0 3
20236: PUSH
20237: LD_INT 1
20239: ARRAY
20240: PPUSH
20241: LD_STRING D5-Sol2-1
20243: PPUSH
20244: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
20248: LD_EXP 55
20252: PPUSH
20253: LD_STRING D5-Pow-2
20255: PPUSH
20256: CALL_OW 88
// if tmp > 1 then
20260: LD_VAR 0 3
20264: PUSH
20265: LD_INT 1
20267: GREATER
20268: IFFALSE 20286
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
20270: LD_VAR 0 3
20274: PUSH
20275: LD_INT 2
20277: ARRAY
20278: PPUSH
20279: LD_STRING D5-Sol2-2
20281: PPUSH
20282: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
20286: LD_EXP 55
20290: PPUSH
20291: LD_STRING D5-Pow-3
20293: PPUSH
20294: CALL_OW 88
// wait ( 0 0$1 ) ;
20298: LD_INT 35
20300: PPUSH
20301: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
20305: LD_ADDR_VAR 0 3
20309: PUSH
20310: LD_EXP 18
20314: PUSH
20315: LD_INT 1
20317: ARRAY
20318: PUSH
20319: LD_EXP 18
20323: PUSH
20324: LD_INT 2
20326: ARRAY
20327: UNION
20328: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
20329: LD_VAR 0 3
20333: PPUSH
20334: LD_INT 80
20336: PPUSH
20337: LD_INT 67
20339: PPUSH
20340: CALL_OW 114
// wait ( 0 0$2 ) ;
20344: LD_INT 70
20346: PPUSH
20347: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
20351: LD_INT 79
20353: PPUSH
20354: LD_INT 72
20356: PPUSH
20357: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
20361: LD_INT 35
20363: PPUSH
20364: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
20368: LD_VAR 0 3
20372: PPUSH
20373: LD_INT 3
20375: PUSH
20376: LD_INT 24
20378: PUSH
20379: LD_INT 1000
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: PUSH
20386: EMPTY
20387: LIST
20388: LIST
20389: PPUSH
20390: CALL_OW 72
20394: IFFALSE 20361
// Say ( Powell , D5a-Pow-1 ) ;
20396: LD_EXP 55
20400: PPUSH
20401: LD_STRING D5a-Pow-1
20403: PPUSH
20404: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
20408: LD_EXP 55
20412: PPUSH
20413: LD_STRING D5a-Pow-1a
20415: PPUSH
20416: CALL_OW 88
// wait ( 0 0$0.3 ) ;
20420: LD_INT 10
20422: PPUSH
20423: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
20427: LD_EXP 55
20431: PPUSH
20432: LD_STRING D5a-Pow-1b
20434: PPUSH
20435: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
20439: LD_EXP 55
20443: PPUSH
20444: LD_STRING D5a-Pow-1c
20446: PPUSH
20447: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
20451: LD_EXP 55
20455: PPUSH
20456: LD_STRING D5a-Pow-1d
20458: PPUSH
20459: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
20463: LD_INT 35
20465: PPUSH
20466: CALL_OW 67
// if not HasTask ( tmp ) then
20470: LD_VAR 0 3
20474: PPUSH
20475: CALL_OW 314
20479: NOT
20480: IFFALSE 20497
// ComAgressiveMove ( tmp , 80 , 67 ) ;
20482: LD_VAR 0 3
20486: PPUSH
20487: LD_INT 80
20489: PPUSH
20490: LD_INT 67
20492: PPUSH
20493: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
20497: LD_VAR 0 3
20501: PPUSH
20502: LD_INT 24
20504: PUSH
20505: LD_INT 1
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: PPUSH
20512: CALL_OW 72
20516: NOT
20517: IFFALSE 20463
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
20519: LD_ADDR_VAR 0 3
20523: PUSH
20524: LD_INT 22
20526: PUSH
20527: LD_INT 4
20529: PUSH
20530: EMPTY
20531: LIST
20532: LIST
20533: PUSH
20534: LD_INT 92
20536: PUSH
20537: LD_INT 60
20539: PUSH
20540: LD_INT 93
20542: PUSH
20543: LD_INT 10
20545: PUSH
20546: EMPTY
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: PUSH
20552: LD_INT 3
20554: PUSH
20555: LD_INT 54
20557: PUSH
20558: EMPTY
20559: LIST
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: PUSH
20565: EMPTY
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 55
20579: DIFF
20580: ST_TO_ADDR
// if tmp then
20581: LD_VAR 0 3
20585: IFFALSE 20619
// for i in tmp do
20587: LD_ADDR_VAR 0 1
20591: PUSH
20592: LD_VAR 0 3
20596: PUSH
20597: FOR_IN
20598: IFFALSE 20617
// ComMoveXY ( i , 36 , 67 ) ;
20600: LD_VAR 0 1
20604: PPUSH
20605: LD_INT 36
20607: PPUSH
20608: LD_INT 67
20610: PPUSH
20611: CALL_OW 111
20615: GO 20597
20617: POP
20618: POP
// wait ( 0 0$3 ) ;
20619: LD_INT 105
20621: PPUSH
20622: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
20626: LD_VAR 0 11
20630: PPUSH
20631: LD_STRING D6-Sol3-1
20633: PPUSH
20634: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
20638: LD_EXP 55
20642: PPUSH
20643: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
20647: LD_EXP 55
20651: PPUSH
20652: LD_STRING D6-Pow-1
20654: PPUSH
20655: CALL_OW 88
// tmp := [ ] ;
20659: LD_ADDR_VAR 0 3
20663: PUSH
20664: EMPTY
20665: ST_TO_ADDR
// for i = 1 to 2 do
20666: LD_ADDR_VAR 0 1
20670: PUSH
20671: DOUBLE
20672: LD_INT 1
20674: DEC
20675: ST_TO_ADDR
20676: LD_INT 2
20678: PUSH
20679: FOR_TO
20680: IFFALSE 20787
// begin uc_side := 8 ;
20682: LD_ADDR_OWVAR 20
20686: PUSH
20687: LD_INT 8
20689: ST_TO_ADDR
// uc_nation := 2 ;
20690: LD_ADDR_OWVAR 21
20694: PUSH
20695: LD_INT 2
20697: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
20698: LD_INT 14
20700: PPUSH
20701: LD_INT 3
20703: PPUSH
20704: LD_INT 2
20706: PPUSH
20707: LD_INT 29
20709: PPUSH
20710: LD_INT 100
20712: PPUSH
20713: CALL 67604 0 5
// veh := CreateVehicle ;
20717: LD_ADDR_VAR 0 13
20721: PUSH
20722: CALL_OW 45
20726: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
20727: LD_VAR 0 13
20731: PPUSH
20732: LD_INT 4
20734: PPUSH
20735: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
20739: LD_VAR 0 13
20743: PPUSH
20744: LD_INT 99
20746: PPUSH
20747: LD_INT 83
20749: PPUSH
20750: LD_INT 5
20752: PPUSH
20753: LD_INT 0
20755: PPUSH
20756: CALL_OW 50
// Connect ( veh ) ;
20760: LD_VAR 0 13
20764: PPUSH
20765: CALL 70659 0 1
// tmp := tmp ^ veh ;
20769: LD_ADDR_VAR 0 3
20773: PUSH
20774: LD_VAR 0 3
20778: PUSH
20779: LD_VAR 0 13
20783: ADD
20784: ST_TO_ADDR
// end ;
20785: GO 20679
20787: POP
20788: POP
// wait ( 0 0$1 ) ;
20789: LD_INT 35
20791: PPUSH
20792: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
20796: LD_INT 99
20798: PPUSH
20799: LD_INT 83
20801: PPUSH
20802: LD_INT 1
20804: PPUSH
20805: LD_INT 10
20807: PPUSH
20808: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
20812: LD_INT 99
20814: PPUSH
20815: LD_INT 83
20817: PPUSH
20818: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
20822: LD_VAR 0 11
20826: PPUSH
20827: LD_STRING D6-Sol3-2
20829: PPUSH
20830: CALL_OW 88
// async ;
20834: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
20835: LD_EXP 55
20839: PPUSH
20840: LD_STRING D6-Pow-2
20842: PPUSH
20843: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
20847: LD_VAR 0 3
20851: PUSH
20852: LD_INT 1
20854: ARRAY
20855: PPUSH
20856: LD_VAR 0 9
20860: PPUSH
20861: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
20865: LD_VAR 0 3
20869: PUSH
20870: LD_INT 2
20872: ARRAY
20873: PPUSH
20874: LD_INT 22
20876: PUSH
20877: LD_INT 4
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: LD_INT 21
20886: PUSH
20887: LD_INT 3
20889: PUSH
20890: EMPTY
20891: LIST
20892: LIST
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: PPUSH
20898: CALL_OW 69
20902: PPUSH
20903: LD_VAR 0 3
20907: PUSH
20908: LD_INT 2
20910: ARRAY
20911: PPUSH
20912: CALL_OW 74
20916: PPUSH
20917: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
20921: LD_EXP 55
20925: PPUSH
20926: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
20930: LD_INT 99
20932: PPUSH
20933: LD_INT 83
20935: PPUSH
20936: LD_INT 1
20938: PPUSH
20939: CALL_OW 331
// repeat wait ( 4 ) ;
20943: LD_INT 4
20945: PPUSH
20946: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
20950: LD_VAR 0 3
20954: PUSH
20955: LD_INT 1
20957: ARRAY
20958: PPUSH
20959: CALL_OW 256
20963: PUSH
20964: LD_INT 1000
20966: LESS
20967: IFFALSE 20985
// SetLives ( tmp [ 1 ] , 1000 ) ;
20969: LD_VAR 0 3
20973: PUSH
20974: LD_INT 1
20976: ARRAY
20977: PPUSH
20978: LD_INT 1000
20980: PPUSH
20981: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
20985: LD_INT 22
20987: PUSH
20988: LD_INT 4
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: PUSH
20995: LD_INT 30
20997: PUSH
20998: LD_INT 3
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PUSH
21005: EMPTY
21006: LIST
21007: LIST
21008: PPUSH
21009: CALL_OW 69
21013: PUSH
21014: LD_INT 0
21016: EQUAL
21017: IFFALSE 20943
// sync ;
21019: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21020: LD_EXP 55
21024: PPUSH
21025: LD_STRING D6a-Pow-1
21027: PPUSH
21028: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21032: LD_VAR 0 11
21036: PPUSH
21037: LD_STRING D6a-Sol3-1
21039: PPUSH
21040: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21044: LD_EXP 55
21048: PPUSH
21049: LD_STRING D6a-Pow-2
21051: PPUSH
21052: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21056: LD_VAR 0 11
21060: PPUSH
21061: LD_STRING D6a-Sol3-2
21063: PPUSH
21064: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21068: LD_EXP 55
21072: PPUSH
21073: LD_STRING D6a-Pow-3
21075: PPUSH
21076: CALL_OW 88
// powellCenterCameraMode := true ;
21080: LD_ADDR_EXP 20
21084: PUSH
21085: LD_INT 1
21087: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21088: LD_ADDR_VAR 0 1
21092: PUSH
21093: LD_INT 22
21095: PUSH
21096: LD_INT 8
21098: PUSH
21099: EMPTY
21100: LIST
21101: LIST
21102: PUSH
21103: LD_INT 25
21105: PUSH
21106: LD_INT 2
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: PPUSH
21117: CALL_OW 69
21121: PUSH
21122: FOR_IN
21123: IFFALSE 21178
// begin SetTag ( i , 1 ) ;
21125: LD_VAR 0 1
21129: PPUSH
21130: LD_INT 1
21132: PPUSH
21133: CALL_OW 109
// ComExitBuilding ( i ) ;
21137: LD_VAR 0 1
21141: PPUSH
21142: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
21146: LD_VAR 0 1
21150: PPUSH
21151: LD_INT 35
21153: PPUSH
21154: LD_INT 6
21156: PPUSH
21157: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
21161: LD_VAR 0 1
21165: PPUSH
21166: LD_INT 53
21168: PPUSH
21169: LD_INT 4
21171: PPUSH
21172: CALL_OW 171
// end ;
21176: GO 21122
21178: POP
21179: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
21180: LD_ADDR_VAR 0 3
21184: PUSH
21185: LD_INT 22
21187: PUSH
21188: LD_INT 4
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PUSH
21195: LD_INT 21
21197: PUSH
21198: LD_INT 2
21200: PUSH
21201: EMPTY
21202: LIST
21203: LIST
21204: PUSH
21205: LD_INT 3
21207: PUSH
21208: LD_INT 34
21210: PUSH
21211: LD_INT 12
21213: PUSH
21214: EMPTY
21215: LIST
21216: LIST
21217: PUSH
21218: EMPTY
21219: LIST
21220: LIST
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: LIST
21226: PPUSH
21227: CALL_OW 69
21231: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
21232: LD_EXP 55
21236: PPUSH
21237: LD_VAR 0 3
21241: PPUSH
21242: LD_EXP 55
21246: PPUSH
21247: CALL_OW 74
21251: PPUSH
21252: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
21256: LD_EXP 55
21260: PPUSH
21261: LD_INT 100
21263: PPUSH
21264: LD_INT 88
21266: PPUSH
21267: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
21271: LD_EXP 55
21275: PPUSH
21276: LD_INT 100
21278: PPUSH
21279: LD_INT 75
21281: PPUSH
21282: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
21286: LD_EXP 55
21290: PPUSH
21291: LD_INT 88
21293: PPUSH
21294: LD_INT 53
21296: PPUSH
21297: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
21301: LD_INT 8
21303: PPUSH
21304: LD_EXP 55
21308: PPUSH
21309: CALL_OW 471
// repeat wait ( 3 ) ;
21313: LD_INT 3
21315: PPUSH
21316: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
21320: LD_INT 22
21322: PUSH
21323: LD_INT 4
21325: PUSH
21326: EMPTY
21327: LIST
21328: LIST
21329: PUSH
21330: LD_INT 92
21332: PUSH
21333: LD_INT 100
21335: PUSH
21336: LD_INT 75
21338: PUSH
21339: LD_INT 6
21341: PUSH
21342: EMPTY
21343: LIST
21344: LIST
21345: LIST
21346: LIST
21347: PUSH
21348: EMPTY
21349: LIST
21350: LIST
21351: PPUSH
21352: CALL_OW 69
21356: IFFALSE 21313
// async ;
21358: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
21359: LD_EXP 55
21363: PPUSH
21364: LD_STRING D6b-Pow-1
21366: PPUSH
21367: CALL_OW 88
// repeat wait ( 3 ) ;
21371: LD_INT 3
21373: PPUSH
21374: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
21378: LD_EXP 55
21382: PPUSH
21383: CALL_OW 310
21387: PPUSH
21388: CALL_OW 256
21392: PUSH
21393: LD_INT 1000
21395: LESS
21396: IFFALSE 21415
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
21398: LD_EXP 55
21402: PPUSH
21403: CALL_OW 310
21407: PPUSH
21408: LD_INT 1000
21410: PPUSH
21411: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
21415: LD_EXP 55
21419: PPUSH
21420: CALL_OW 256
21424: PUSH
21425: LD_INT 1000
21427: LESS
21428: IFFALSE 21442
// SetLives ( Powell , 1000 ) ;
21430: LD_EXP 55
21434: PPUSH
21435: LD_INT 1000
21437: PPUSH
21438: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
21442: LD_EXP 55
21446: PPUSH
21447: LD_EXP 60
21451: PPUSH
21452: CALL_OW 296
21456: PUSH
21457: LD_INT 5
21459: LESS
21460: PUSH
21461: LD_EXP 55
21465: PPUSH
21466: CALL_OW 310
21470: PPUSH
21471: LD_EXP 60
21475: PPUSH
21476: CALL_OW 296
21480: PUSH
21481: LD_INT 5
21483: LESS
21484: OR
21485: IFFALSE 21504
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
21487: LD_EXP 55
21491: PPUSH
21492: CALL_OW 310
21496: PPUSH
21497: LD_INT 100
21499: PPUSH
21500: CALL_OW 234
// until not IsInUnit ( Powell ) ;
21504: LD_EXP 55
21508: PPUSH
21509: CALL_OW 310
21513: NOT
21514: IFFALSE 21371
// game_speed := 4 ;
21516: LD_ADDR_OWVAR 65
21520: PUSH
21521: LD_INT 4
21523: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
21524: LD_EXP 55
21528: PPUSH
21529: LD_STRING D6b-Pow-1a
21531: PPUSH
21532: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
21536: LD_EXP 55
21540: PPUSH
21541: LD_EXP 60
21545: PPUSH
21546: CALL_OW 180
// sync ;
21550: SYNC
// repeat wait ( 0 0$1 ) ;
21551: LD_INT 35
21553: PPUSH
21554: CALL_OW 67
// until IsInUnit ( Powell ) ;
21558: LD_EXP 55
21562: PPUSH
21563: CALL_OW 310
21567: IFFALSE 21551
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
21569: LD_INT 8
21571: PPUSH
21572: LD_EXP 55
21576: PPUSH
21577: CALL_OW 310
21581: PPUSH
21582: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
21586: LD_EXP 55
21590: PPUSH
21591: LD_INT 91
21593: PPUSH
21594: LD_INT 44
21596: PPUSH
21597: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
21601: LD_EXP 55
21605: PPUSH
21606: LD_INT 96
21608: PPUSH
21609: LD_INT 44
21611: PPUSH
21612: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
21616: LD_EXP 55
21620: PPUSH
21621: LD_INT 96
21623: PPUSH
21624: LD_INT 41
21626: PPUSH
21627: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
21631: LD_EXP 55
21635: PPUSH
21636: LD_INT 92
21638: PPUSH
21639: LD_INT 39
21641: PPUSH
21642: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
21646: LD_EXP 55
21650: PPUSH
21651: LD_INT 88
21653: PPUSH
21654: LD_INT 41
21656: PPUSH
21657: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
21661: LD_EXP 55
21665: PPUSH
21666: LD_INT 91
21668: PPUSH
21669: LD_INT 44
21671: PPUSH
21672: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
21676: LD_EXP 55
21680: PPUSH
21681: LD_INT 96
21683: PPUSH
21684: LD_INT 44
21686: PPUSH
21687: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
21691: LD_EXP 55
21695: PPUSH
21696: LD_INT 96
21698: PPUSH
21699: LD_INT 41
21701: PPUSH
21702: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
21706: LD_EXP 55
21710: PPUSH
21711: LD_INT 92
21713: PPUSH
21714: LD_INT 39
21716: PPUSH
21717: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
21721: LD_EXP 55
21725: PPUSH
21726: LD_INT 88
21728: PPUSH
21729: LD_INT 41
21731: PPUSH
21732: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
21736: LD_EXP 55
21740: PPUSH
21741: LD_INT 91
21743: PPUSH
21744: LD_INT 44
21746: PPUSH
21747: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
21751: LD_EXP 55
21755: PPUSH
21756: LD_INT 93
21758: PPUSH
21759: LD_INT 39
21761: PPUSH
21762: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
21766: LD_EXP 55
21770: PPUSH
21771: LD_INT 93
21773: PPUSH
21774: LD_INT 36
21776: PPUSH
21777: CALL_OW 171
// wait ( 0 0$3.5 ) ;
21781: LD_INT 122
21783: PPUSH
21784: CALL_OW 67
// game_speed := 4 ;
21788: LD_ADDR_OWVAR 65
21792: PUSH
21793: LD_INT 4
21795: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
21796: LD_EXP 55
21800: PPUSH
21801: LD_STRING D6b-Pow-1b
21803: PPUSH
21804: CALL_OW 88
// tmp := [ ] ;
21808: LD_ADDR_VAR 0 3
21812: PUSH
21813: EMPTY
21814: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
21815: LD_ADDR_VAR 0 5
21819: PUSH
21820: LD_INT 78
21822: PUSH
21823: LD_INT 47
21825: PUSH
21826: EMPTY
21827: LIST
21828: LIST
21829: PUSH
21830: LD_INT 106
21832: PUSH
21833: LD_INT 53
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: PUSH
21840: EMPTY
21841: LIST
21842: LIST
21843: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
21844: LD_ADDR_VAR 0 1
21848: PUSH
21849: LD_INT 22
21851: PUSH
21852: LD_INT 8
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: PUSH
21859: LD_INT 21
21861: PUSH
21862: LD_INT 3
21864: PUSH
21865: EMPTY
21866: LIST
21867: LIST
21868: PUSH
21869: LD_INT 92
21871: PUSH
21872: LD_INT 90
21874: PUSH
21875: LD_INT 52
21877: PUSH
21878: LD_INT 12
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: LIST
21885: LIST
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: LIST
21891: PPUSH
21892: CALL_OW 69
21896: PUSH
21897: FOR_IN
21898: IFFALSE 21923
// tmp := tmp ^ UnitsInside ( i ) ;
21900: LD_ADDR_VAR 0 3
21904: PUSH
21905: LD_VAR 0 3
21909: PUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: CALL_OW 313
21919: ADD
21920: ST_TO_ADDR
21921: GO 21897
21923: POP
21924: POP
// for i in tmp do
21925: LD_ADDR_VAR 0 1
21929: PUSH
21930: LD_VAR 0 3
21934: PUSH
21935: FOR_IN
21936: IFFALSE 22098
// begin dist := 9999 ;
21938: LD_ADDR_VAR 0 8
21942: PUSH
21943: LD_INT 9999
21945: ST_TO_ADDR
// _xy := [ ] ;
21946: LD_ADDR_VAR 0 7
21950: PUSH
21951: EMPTY
21952: ST_TO_ADDR
// SetTag ( i , 1 ) ;
21953: LD_VAR 0 1
21957: PPUSH
21958: LD_INT 1
21960: PPUSH
21961: CALL_OW 109
// ComExitBuilding ( i ) ;
21965: LD_VAR 0 1
21969: PPUSH
21970: CALL_OW 122
// for j in xy do
21974: LD_ADDR_VAR 0 2
21978: PUSH
21979: LD_VAR 0 5
21983: PUSH
21984: FOR_IN
21985: IFFALSE 22067
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_VAR 0 2
21996: PUSH
21997: LD_INT 1
21999: ARRAY
22000: PPUSH
22001: LD_VAR 0 2
22005: PUSH
22006: LD_INT 2
22008: ARRAY
22009: PPUSH
22010: CALL_OW 297
22014: PUSH
22015: LD_VAR 0 8
22019: LESS
22020: IFFALSE 22065
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22022: LD_ADDR_VAR 0 8
22026: PUSH
22027: LD_VAR 0 1
22031: PPUSH
22032: LD_VAR 0 2
22036: PUSH
22037: LD_INT 1
22039: ARRAY
22040: PPUSH
22041: LD_VAR 0 2
22045: PUSH
22046: LD_INT 2
22048: ARRAY
22049: PPUSH
22050: CALL_OW 297
22054: ST_TO_ADDR
// _xy := j ;
22055: LD_ADDR_VAR 0 7
22059: PUSH
22060: LD_VAR 0 2
22064: ST_TO_ADDR
// end ;
22065: GO 21984
22067: POP
22068: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22069: LD_VAR 0 1
22073: PPUSH
22074: LD_VAR 0 7
22078: PUSH
22079: LD_INT 1
22081: ARRAY
22082: PPUSH
22083: LD_VAR 0 7
22087: PUSH
22088: LD_INT 2
22090: ARRAY
22091: PPUSH
22092: CALL_OW 171
// end ;
22096: GO 21935
22098: POP
22099: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22100: LD_ADDR_VAR 0 4
22104: PUSH
22105: LD_VAR 0 3
22109: PPUSH
22110: LD_INT 26
22112: PUSH
22113: LD_INT 1
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: PUSH
22120: LD_INT 25
22122: PUSH
22123: LD_INT 1
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: PUSH
22130: EMPTY
22131: LIST
22132: LIST
22133: PPUSH
22134: CALL_OW 72
22138: ST_TO_ADDR
// if tmp2 < 2 then
22139: LD_VAR 0 4
22143: PUSH
22144: LD_INT 2
22146: LESS
22147: IFFALSE 22216
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
22149: LD_ADDR_VAR 0 4
22153: PUSH
22154: LD_INT 22
22156: PUSH
22157: LD_INT 8
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: PUSH
22164: LD_INT 26
22166: PUSH
22167: LD_INT 1
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: PUSH
22174: LD_INT 3
22176: PUSH
22177: LD_INT 25
22179: PUSH
22180: LD_INT 15
22182: PUSH
22183: EMPTY
22184: LIST
22185: LIST
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PUSH
22191: EMPTY
22192: LIST
22193: LIST
22194: LIST
22195: PPUSH
22196: CALL_OW 69
22200: PUSH
22201: LD_EXP 57
22205: PUSH
22206: LD_EXP 58
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: DIFF
22215: ST_TO_ADDR
// if tmp2 then
22216: LD_VAR 0 4
22220: IFFALSE 22238
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
22222: LD_VAR 0 4
22226: PUSH
22227: LD_INT 1
22229: ARRAY
22230: PPUSH
22231: LD_STRING D6b-ArSol1-1
22233: PPUSH
22234: CALL_OW 88
// async ;
22238: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
22239: LD_EXP 55
22243: PPUSH
22244: LD_STRING D6b-Pow-2
22246: PPUSH
22247: CALL_OW 88
// wait ( 0 0$1 ) ;
22251: LD_INT 35
22253: PPUSH
22254: CALL_OW 67
// if tmp2 > 1 then
22258: LD_VAR 0 4
22262: PUSH
22263: LD_INT 1
22265: GREATER
22266: IFFALSE 22284
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
22268: LD_VAR 0 4
22272: PUSH
22273: LD_INT 2
22275: ARRAY
22276: PPUSH
22277: LD_STRING D6b-ArSol2-1
22279: PPUSH
22280: CALL_OW 88
// sync ;
22284: SYNC
// repeat wait ( 5 ) ;
22285: LD_INT 5
22287: PPUSH
22288: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
22292: LD_INT 93
22294: PPUSH
22295: LD_INT 36
22297: PPUSH
22298: CALL_OW 428
22302: PPUSH
22303: CALL_OW 255
22307: PUSH
22308: LD_INT 4
22310: EQUAL
22311: IFFALSE 22285
// DialogueOn ;
22313: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
22317: LD_INT 10
22319: PPUSH
22320: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
22324: LD_EXP 55
22328: PPUSH
22329: LD_STRING D6b-Pow-2a
22331: PPUSH
22332: CALL_OW 88
// DialogueOff ;
22336: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
22340: LD_EXP 55
22344: PPUSH
22345: CALL_OW 310
22349: PPUSH
22350: LD_INT 332
22352: PPUSH
22353: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
22357: LD_INT 93
22359: PPUSH
22360: LD_INT 35
22362: PPUSH
22363: LD_INT 1
22365: PPUSH
22366: LD_INT 6
22368: NEG
22369: PPUSH
22370: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
22374: LD_INT 35
22376: PPUSH
22377: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
22381: LD_INT 332
22383: PPUSH
22384: CALL_OW 256
22388: PUSH
22389: LD_INT 1000
22391: LESS
22392: PUSH
22393: LD_INT 332
22395: PPUSH
22396: CALL_OW 300
22400: AND
22401: IFFALSE 22413
// SetLives ( kozlov_fac , 0 ) ;
22403: LD_INT 332
22405: PPUSH
22406: LD_INT 0
22408: PPUSH
22409: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
22413: LD_INT 332
22415: PPUSH
22416: CALL_OW 301
22420: PUSH
22421: LD_EXP 55
22425: PPUSH
22426: CALL_OW 301
22430: OR
22431: IFFALSE 22374
// game_speed := 4 ;
22433: LD_ADDR_OWVAR 65
22437: PUSH
22438: LD_INT 4
22440: ST_TO_ADDR
// powellCenterCameraMode := false ;
22441: LD_ADDR_EXP 20
22445: PUSH
22446: LD_INT 0
22448: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22449: LD_ADDR_VAR 0 1
22453: PUSH
22454: LD_VAR 0 3
22458: PUSH
22459: LD_INT 22
22461: PUSH
22462: LD_INT 8
22464: PUSH
22465: EMPTY
22466: LIST
22467: LIST
22468: PUSH
22469: LD_INT 25
22471: PUSH
22472: LD_INT 2
22474: PUSH
22475: EMPTY
22476: LIST
22477: LIST
22478: PUSH
22479: EMPTY
22480: LIST
22481: LIST
22482: PPUSH
22483: CALL_OW 69
22487: UNION
22488: PUSH
22489: FOR_IN
22490: IFFALSE 22506
// SetTag ( i , 0 ) ;
22492: LD_VAR 0 1
22496: PPUSH
22497: LD_INT 0
22499: PPUSH
22500: CALL_OW 109
22504: GO 22489
22506: POP
22507: POP
// wait ( 0 0$3 ) ;
22508: LD_INT 105
22510: PPUSH
22511: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
22515: LD_INT 93
22517: PPUSH
22518: LD_INT 35
22520: PPUSH
22521: LD_INT 1
22523: PPUSH
22524: CALL_OW 331
// DialogueOn ;
22528: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
22532: LD_VAR 0 11
22536: PPUSH
22537: LD_STRING D6c-Sol3-1
22539: PPUSH
22540: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
22544: LD_INT 10
22546: PPUSH
22547: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
22551: LD_EXP 36
22555: PPUSH
22556: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
22560: LD_EXP 36
22564: PPUSH
22565: LD_STRING D6c-JMM-1
22567: PPUSH
22568: CALL_OW 88
// if Cyrus then
22572: LD_EXP 42
22576: IFFALSE 22590
// Say ( Cyrus , D6c-Cyrus-1 ) ;
22578: LD_EXP 42
22582: PPUSH
22583: LD_STRING D6c-Cyrus-1
22585: PPUSH
22586: CALL_OW 88
// if Bobby then
22590: LD_EXP 41
22594: IFFALSE 22608
// Say ( Bobby , D6c-Bobby-1 ) ;
22596: LD_EXP 41
22600: PPUSH
22601: LD_STRING D6c-Bobby-1
22603: PPUSH
22604: CALL_OW 88
// if Cornel then
22608: LD_EXP 47
22612: IFFALSE 22626
// Say ( Cornel , D6c-Corn-1 ) ;
22614: LD_EXP 47
22618: PPUSH
22619: LD_STRING D6c-Corn-1
22621: PPUSH
22622: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
22626: LD_ADDR_VAR 0 4
22630: PUSH
22631: LD_INT 2
22633: PUSH
22634: LD_INT 22
22636: PUSH
22637: LD_INT 1
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: PUSH
22644: LD_INT 22
22646: PUSH
22647: LD_INT 4
22649: PUSH
22650: EMPTY
22651: LIST
22652: LIST
22653: PUSH
22654: EMPTY
22655: LIST
22656: LIST
22657: LIST
22658: PUSH
22659: LD_INT 26
22661: PUSH
22662: LD_INT 1
22664: PUSH
22665: EMPTY
22666: LIST
22667: LIST
22668: PUSH
22669: LD_INT 3
22671: PUSH
22672: LD_INT 25
22674: PUSH
22675: LD_INT 16
22677: PUSH
22678: EMPTY
22679: LIST
22680: LIST
22681: PUSH
22682: LD_INT 25
22684: PUSH
22685: LD_INT 12
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: LIST
22696: PUSH
22697: EMPTY
22698: LIST
22699: LIST
22700: LIST
22701: PPUSH
22702: CALL_OW 69
22706: PUSH
22707: LD_VAR 0 11
22711: PUSH
22712: LD_EXP 36
22716: UNION
22717: PUSH
22718: LD_EXP 56
22722: UNION
22723: PUSH
22724: EMPTY
22725: LIST
22726: DIFF
22727: ST_TO_ADDR
// if tmp2 then
22728: LD_VAR 0 4
22732: IFFALSE 22750
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
22734: LD_VAR 0 4
22738: PUSH
22739: LD_INT 1
22741: ARRAY
22742: PPUSH
22743: LD_STRING D6c-Sol1-1
22745: PPUSH
22746: CALL_OW 88
// if Lisa then
22750: LD_EXP 39
22754: IFFALSE 22768
// Say ( Lisa , D6c-Lisa-1 ) ;
22756: LD_EXP 39
22760: PPUSH
22761: LD_STRING D6c-Lisa-1
22763: PPUSH
22764: CALL_OW 88
// if Gary then
22768: LD_EXP 48
22772: IFFALSE 22786
// Say ( Gary , D6c-Gary-1 ) ;
22774: LD_EXP 48
22778: PPUSH
22779: LD_STRING D6c-Gary-1
22781: PPUSH
22782: CALL_OW 88
// if Donaldson then
22786: LD_EXP 40
22790: IFFALSE 22804
// Say ( Donaldson , D6c-Don-1 ) ;
22792: LD_EXP 40
22796: PPUSH
22797: LD_STRING D6c-Don-1
22799: PPUSH
22800: CALL_OW 88
// if tmp2 > 1 then
22804: LD_VAR 0 4
22808: PUSH
22809: LD_INT 1
22811: GREATER
22812: IFFALSE 22830
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
22814: LD_VAR 0 4
22818: PUSH
22819: LD_INT 2
22821: ARRAY
22822: PPUSH
22823: LD_STRING D6c-Sol2-1
22825: PPUSH
22826: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
22830: LD_VAR 0 11
22834: PPUSH
22835: LD_STRING D6c-Sol3-2
22837: PPUSH
22838: CALL_OW 88
// dwait ( 0 0$1 ) ;
22842: LD_INT 35
22844: PPUSH
22845: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
22849: LD_EXP 36
22853: PPUSH
22854: LD_STRING D6c-JMM-2
22856: PPUSH
22857: CALL_OW 88
// DialogueOff ;
22861: CALL_OW 7
// Video ( false ) ;
22865: LD_INT 0
22867: PPUSH
22868: CALL 103259 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
22872: LD_INT 22
22874: PUSH
22875: LD_INT 4
22877: PUSH
22878: EMPTY
22879: LIST
22880: LIST
22881: PPUSH
22882: CALL_OW 69
22886: PPUSH
22887: LD_INT 1
22889: PPUSH
22890: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
22894: LD_INT 4
22896: PPUSH
22897: LD_INT 4
22899: PPUSH
22900: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
22904: LD_ADDR_VAR 0 1
22908: PUSH
22909: LD_INT 4
22911: PPUSH
22912: LD_INT 1
22914: PPUSH
22915: LD_INT 2
22917: PPUSH
22918: CALL 61034 0 3
22922: PUSH
22923: FOR_IN
22924: IFFALSE 22961
// if GetTech ( i , 1 ) <> state_researched then
22926: LD_VAR 0 1
22930: PPUSH
22931: LD_INT 1
22933: PPUSH
22934: CALL_OW 321
22938: PUSH
22939: LD_INT 2
22941: NONEQUAL
22942: IFFALSE 22959
// SetTech ( i , 1 , state_researched ) ;
22944: LD_VAR 0 1
22948: PPUSH
22949: LD_INT 1
22951: PPUSH
22952: LD_INT 2
22954: PPUSH
22955: CALL_OW 322
22959: GO 22923
22961: POP
22962: POP
// missionStage := 6 ;
22963: LD_ADDR_EXP 15
22967: PUSH
22968: LD_INT 6
22970: ST_TO_ADDR
// activeAttacks := true ;
22971: LD_ADDR_EXP 16
22975: PUSH
22976: LD_INT 1
22978: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
22979: LD_STRING M2
22981: PPUSH
22982: CALL_OW 337
// SaveForQuickRestart ;
22986: CALL_OW 22
// wait ( 0 0$40 ) ;
22990: LD_INT 1400
22992: PPUSH
22993: CALL_OW 67
// DialogueOn ;
22997: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23001: LD_EXP 59
23005: PPUSH
23006: LD_STRING D7-Friend-1
23008: PPUSH
23009: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23013: LD_EXP 36
23017: PPUSH
23018: LD_STRING D7-JMM-1
23020: PPUSH
23021: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23025: LD_EXP 59
23029: PPUSH
23030: LD_STRING D7-Friend-2
23032: PPUSH
23033: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23037: LD_EXP 36
23041: PPUSH
23042: LD_STRING D7-JMM-2
23044: PPUSH
23045: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23049: LD_EXP 59
23053: PPUSH
23054: LD_STRING D7-Friend-3
23056: PPUSH
23057: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23061: LD_EXP 36
23065: PPUSH
23066: LD_STRING D7-JMM-3
23068: PPUSH
23069: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23073: LD_EXP 59
23077: PPUSH
23078: LD_STRING D7-Friend-4
23080: PPUSH
23081: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23085: LD_EXP 36
23089: PPUSH
23090: LD_STRING D7-JMM-4
23092: PPUSH
23093: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23097: LD_EXP 59
23101: PPUSH
23102: LD_STRING D7-Friend-5
23104: PPUSH
23105: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
23109: LD_EXP 36
23113: PPUSH
23114: LD_STRING D7-JMM-5
23116: PPUSH
23117: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
23121: LD_EXP 59
23125: PPUSH
23126: LD_STRING D7-Friend-6
23128: PPUSH
23129: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
23133: LD_EXP 36
23137: PPUSH
23138: LD_STRING D7-JMM-6
23140: PPUSH
23141: CALL_OW 88
// DialogueOff ;
23145: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
23149: LD_STRING Mlegion
23151: PPUSH
23152: CALL_OW 337
// RebuildKozlovFactory ;
23156: CALL 4558 0 0
// end ;
23160: PPOPN 13
23162: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
23163: LD_EXP 20
23167: PUSH
23168: LD_EXP 55
23172: PPUSH
23173: CALL_OW 300
23177: AND
23178: IFFALSE 23220
23180: GO 23182
23182: DISABLE
// begin enable ;
23183: ENABLE
// if IsInUnit ( Powell ) then
23184: LD_EXP 55
23188: PPUSH
23189: CALL_OW 310
23193: IFFALSE 23211
// CenterOnUnits ( IsInUnit ( Powell ) ) else
23195: LD_EXP 55
23199: PPUSH
23200: CALL_OW 310
23204: PPUSH
23205: CALL_OW 85
23209: GO 23220
// CenterOnUnits ( Powell ) ;
23211: LD_EXP 55
23215: PPUSH
23216: CALL_OW 85
// end ;
23220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
23221: LD_INT 22
23223: PUSH
23224: LD_INT 8
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 34
23233: PUSH
23234: LD_INT 48
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: PPUSH
23245: CALL_OW 69
23249: IFFALSE 23512
23251: GO 23253
23253: DISABLE
23254: LD_INT 0
23256: PPUSH
23257: PPUSH
// begin if missionStage < 9 then
23258: LD_EXP 15
23262: PUSH
23263: LD_INT 9
23265: LESS
23266: IFFALSE 23276
// missionStage := 9 ;
23268: LD_ADDR_EXP 15
23272: PUSH
23273: LD_INT 9
23275: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
23276: LD_ADDR_VAR 0 1
23280: PUSH
23281: LD_INT 22
23283: PUSH
23284: LD_INT 8
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: PUSH
23291: LD_INT 34
23293: PUSH
23294: LD_INT 48
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: PPUSH
23305: CALL_OW 69
23309: PUSH
23310: LD_INT 1
23312: ARRAY
23313: ST_TO_ADDR
// wait ( 0 0$05 ) ;
23314: LD_INT 175
23316: PPUSH
23317: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
23321: LD_EXP 12
23325: PUSH
23326: LD_EXP 3
23330: PUSH
23331: LD_INT 0
23333: PUSH
23334: LD_INT 2
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: IN
23341: OR
23342: IFFALSE 23365
// target := [ 68 , 108 , 1 ] else
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_INT 68
23351: PUSH
23352: LD_INT 108
23354: PUSH
23355: LD_INT 1
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: LIST
23362: ST_TO_ADDR
23363: GO 23384
// target := [ 181 , 88 , 2 ] ;
23365: LD_ADDR_VAR 0 2
23369: PUSH
23370: LD_INT 181
23372: PUSH
23373: LD_INT 88
23375: PUSH
23376: LD_INT 2
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
23384: LD_VAR 0 1
23388: PPUSH
23389: LD_VAR 0 2
23393: PUSH
23394: LD_INT 1
23396: ARRAY
23397: PPUSH
23398: LD_VAR 0 2
23402: PUSH
23403: LD_INT 2
23405: ARRAY
23406: PPUSH
23407: CALL_OW 176
// if target [ 3 ] = 1 then
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 3
23418: ARRAY
23419: PUSH
23420: LD_INT 1
23422: EQUAL
23423: IFFALSE 23439
// SayRadio ( Kurt , D12-Kurt-1 ) else
23425: LD_EXP 57
23429: PPUSH
23430: LD_STRING D12-Kurt-1
23432: PPUSH
23433: CALL_OW 94
23437: GO 23463
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
23439: LD_EXP 57
23443: PPUSH
23444: LD_STRING D12a-Kurt-1
23446: PPUSH
23447: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
23451: LD_EXP 71
23455: PPUSH
23456: LD_STRING D12a-Roth-1
23458: PPUSH
23459: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
23463: LD_INT 350
23465: PPUSH
23466: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
23470: LD_VAR 0 1
23474: PPUSH
23475: LD_INT 22
23477: PUSH
23478: LD_INT 8
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: PUSH
23485: LD_INT 30
23487: PUSH
23488: LD_INT 3
23490: PUSH
23491: EMPTY
23492: LIST
23493: LIST
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: PPUSH
23499: CALL_OW 69
23503: PUSH
23504: LD_INT 1
23506: ARRAY
23507: PPUSH
23508: CALL_OW 228
// end ;
23512: PPOPN 2
23514: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
23515: LD_INT 22
23517: PUSH
23518: LD_INT 8
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: PUSH
23525: LD_INT 21
23527: PUSH
23528: LD_INT 1
23530: PUSH
23531: EMPTY
23532: LIST
23533: LIST
23534: PUSH
23535: LD_INT 23
23537: PUSH
23538: LD_INT 2
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: PUSH
23545: EMPTY
23546: LIST
23547: LIST
23548: LIST
23549: PPUSH
23550: CALL_OW 69
23554: PUSH
23555: LD_INT 8
23557: PUSH
23558: LD_INT 7
23560: PUSH
23561: LD_INT 6
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: LIST
23568: PUSH
23569: LD_OWVAR 67
23573: ARRAY
23574: LESSEQUAL
23575: PUSH
23576: LD_INT 22
23578: PUSH
23579: LD_INT 8
23581: PUSH
23582: EMPTY
23583: LIST
23584: LIST
23585: PUSH
23586: LD_INT 34
23588: PUSH
23589: LD_INT 48
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: PUSH
23596: EMPTY
23597: LIST
23598: LIST
23599: PPUSH
23600: CALL_OW 69
23604: NOT
23605: AND
23606: PUSH
23607: LD_EXP 57
23611: PPUSH
23612: CALL_OW 302
23616: AND
23617: IFFALSE 23934
23619: GO 23621
23621: DISABLE
// begin DialogueOn ;
23622: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
23626: LD_EXP 36
23630: PPUSH
23631: LD_STRING D13-JMM-1
23633: PPUSH
23634: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
23638: LD_EXP 57
23642: PPUSH
23643: LD_STRING D13-Kurt-1
23645: PPUSH
23646: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
23650: LD_EXP 36
23654: PPUSH
23655: LD_STRING D13-JMM-2
23657: PPUSH
23658: CALL_OW 88
// if FakeInfo then
23662: LD_EXP 12
23666: IFFALSE 23686
// begin Say ( Kurt , D13-Kurt-2 ) ;
23668: LD_EXP 57
23672: PPUSH
23673: LD_STRING D13-Kurt-2
23675: PPUSH
23676: CALL_OW 88
// DialogueOff ;
23680: CALL_OW 7
// exit ;
23684: GO 23934
// end ; if not KurtStatus then
23686: LD_EXP 3
23690: NOT
23691: IFFALSE 23707
// Say ( Kurt , D13-Kurt-2b ) else
23693: LD_EXP 57
23697: PPUSH
23698: LD_STRING D13-Kurt-2b
23700: PPUSH
23701: CALL_OW 88
23705: GO 23719
// Say ( Kurt , D13-Kurt-2a ) ;
23707: LD_EXP 57
23711: PPUSH
23712: LD_STRING D13-Kurt-2a
23714: PPUSH
23715: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
23719: LD_EXP 57
23723: PPUSH
23724: LD_STRING D13-Kurt-2a
23726: PPUSH
23727: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
23731: LD_EXP 36
23735: PPUSH
23736: LD_STRING D13-JMM-3
23738: PPUSH
23739: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
23743: LD_EXP 57
23747: PPUSH
23748: LD_STRING D13-Kurt-3
23750: PPUSH
23751: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
23755: LD_EXP 36
23759: PPUSH
23760: LD_STRING D13-JMM-4
23762: PPUSH
23763: CALL_OW 88
// DialogueOff ;
23767: CALL_OW 7
// MC_Kill ( 3 ) ;
23771: LD_INT 3
23773: PPUSH
23774: CALL 32997 0 1
// KillUnit ( Kozlov ) ;
23778: LD_EXP 58
23782: PPUSH
23783: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
23787: LD_INT 22
23789: PUSH
23790: LD_INT 8
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 21
23799: PUSH
23800: LD_INT 3
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: LD_INT 23
23809: PUSH
23810: LD_INT 3
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 30
23819: PUSH
23820: LD_INT 3
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: PPUSH
23833: CALL_OW 69
23837: PUSH
23838: LD_INT 1
23840: ARRAY
23841: PPUSH
23842: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
23846: LD_INT 8
23848: PPUSH
23849: LD_INT 1
23851: PPUSH
23852: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
23856: LD_INT 22
23858: PUSH
23859: LD_INT 8
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: PPUSH
23866: CALL_OW 69
23870: PPUSH
23871: LD_INT 1
23873: PPUSH
23874: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
23878: LD_INT 8
23880: PPUSH
23881: LD_INT 1
23883: PPUSH
23884: LD_INT 1
23886: PPUSH
23887: LD_INT 1
23889: PPUSH
23890: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
23894: LD_EXP 59
23898: PPUSH
23899: LD_INT 37
23901: PPUSH
23902: LD_INT 1
23904: PPUSH
23905: LD_INT 0
23907: PPUSH
23908: CALL_OW 48
// wait ( 0 0$1 ) ;
23912: LD_INT 35
23914: PPUSH
23915: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
23919: LD_EXP 59
23923: PPUSH
23924: LD_INT 60
23926: PPUSH
23927: LD_INT 95
23929: PPUSH
23930: CALL_OW 111
// end ;
23934: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
23935: LD_INT 22
23937: PUSH
23938: LD_INT 8
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PUSH
23945: LD_INT 21
23947: PUSH
23948: LD_INT 1
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: PUSH
23955: EMPTY
23956: LIST
23957: LIST
23958: PPUSH
23959: CALL_OW 69
23963: PUSH
23964: LD_INT 0
23966: EQUAL
23967: IFFALSE 23987
23969: GO 23971
23971: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
23972: LD_STRING MlegionOut
23974: PPUSH
23975: CALL_OW 337
// legionDestroyed := true ;
23979: LD_ADDR_EXP 22
23983: PUSH
23984: LD_INT 1
23986: ST_TO_ADDR
// end ;
23987: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
23988: LD_INT 1
23990: PPUSH
23991: LD_EXP 59
23995: PPUSH
23996: CALL_OW 292
24000: IFFALSE 24300
24002: GO 24004
24004: DISABLE
24005: LD_INT 0
24007: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24008: LD_EXP 59
24012: PPUSH
24013: CALL_OW 87
// DialogueOn ;
24017: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24021: LD_EXP 36
24025: PPUSH
24026: LD_STRING D14-JMM-1
24028: PPUSH
24029: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24033: LD_EXP 59
24037: PPUSH
24038: LD_STRING D14-Friend-1
24040: PPUSH
24041: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24045: LD_EXP 36
24049: PPUSH
24050: LD_STRING D14-JMM-2
24052: PPUSH
24053: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24057: LD_EXP 59
24061: PPUSH
24062: LD_STRING D14-Friend-2
24064: PPUSH
24065: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24069: LD_EXP 36
24073: PPUSH
24074: LD_STRING D14-JMM-3
24076: PPUSH
24077: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24081: LD_EXP 59
24085: PPUSH
24086: LD_STRING D14-Friend-3
24088: PPUSH
24089: CALL_OW 88
// DialogueOff ;
24093: CALL_OW 7
// dec = Query ( Q14 ) ;
24097: LD_ADDR_VAR 0 1
24101: PUSH
24102: LD_STRING Q14
24104: PPUSH
24105: CALL_OW 97
24109: ST_TO_ADDR
// if dec = 1 then
24110: LD_VAR 0 1
24114: PUSH
24115: LD_INT 1
24117: EQUAL
24118: IFFALSE 24152
// begin DialogueOn ;
24120: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
24124: LD_EXP 36
24128: PPUSH
24129: LD_STRING D14a-JMM-1
24131: PPUSH
24132: CALL_OW 88
// DialogueOff ;
24136: CALL_OW 7
// SetSide ( Friend , 1 ) ;
24140: LD_EXP 59
24144: PPUSH
24145: LD_INT 1
24147: PPUSH
24148: CALL_OW 235
// end ; if dec = 2 then
24152: LD_VAR 0 1
24156: PUSH
24157: LD_INT 2
24159: EQUAL
24160: IFFALSE 24206
// begin DialogueOn ;
24162: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
24166: LD_EXP 36
24170: PPUSH
24171: LD_STRING D14b-JMM-1
24173: PPUSH
24174: CALL_OW 88
// DialogueOff ;
24178: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
24182: LD_EXP 59
24186: PPUSH
24187: LD_INT 9
24189: PPUSH
24190: LD_INT 2
24192: PPUSH
24193: CALL_OW 111
// AddComHold ( Friend ) ;
24197: LD_EXP 59
24201: PPUSH
24202: CALL_OW 200
// end ; if dec = 3 then
24206: LD_VAR 0 1
24210: PUSH
24211: LD_INT 3
24213: EQUAL
24214: IFFALSE 24300
// begin DialogueOn ;
24216: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
24220: LD_EXP 36
24224: PPUSH
24225: LD_STRING D14c-JMM-1
24227: PPUSH
24228: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
24232: LD_EXP 59
24236: PPUSH
24237: LD_STRING D14c-Friend-1
24239: PPUSH
24240: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
24244: LD_EXP 36
24248: PPUSH
24249: LD_STRING D14c-JMM-2
24251: PPUSH
24252: CALL_OW 88
// DialogueOff ;
24256: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
24260: LD_INT 8
24262: PPUSH
24263: LD_INT 1
24265: PPUSH
24266: LD_INT 2
24268: PPUSH
24269: LD_INT 1
24271: PPUSH
24272: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
24276: LD_EXP 59
24280: PPUSH
24281: LD_INT 9
24283: PPUSH
24284: LD_INT 2
24286: PPUSH
24287: CALL_OW 111
// AddComHold ( Friend ) ;
24291: LD_EXP 59
24295: PPUSH
24296: CALL_OW 200
// end ; end ;
24300: PPOPN 1
24302: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
24303: LD_INT 9
24305: PPUSH
24306: LD_INT 2
24308: PPUSH
24309: CALL_OW 428
24313: PUSH
24314: LD_EXP 59
24318: EQUAL
24319: PUSH
24320: LD_EXP 59
24324: PPUSH
24325: CALL_OW 255
24329: PUSH
24330: LD_INT 8
24332: EQUAL
24333: AND
24334: IFFALSE 24348
24336: GO 24338
24338: DISABLE
// RemoveUnit ( Friend ) ;
24339: LD_EXP 59
24343: PPUSH
24344: CALL_OW 64
24348: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
24349: LD_EXP 14
24353: PUSH
24354: LD_INT 31500
24356: GREATEREQUAL
24357: PUSH
24358: LD_EXP 7
24362: AND
24363: PUSH
24364: LD_EXP 2
24368: AND
24369: IFFALSE 24799
24371: GO 24373
24373: DISABLE
24374: LD_INT 0
24376: PPUSH
24377: PPUSH
24378: PPUSH
// begin missionStage := 7 ;
24379: LD_ADDR_EXP 15
24383: PUSH
24384: LD_INT 7
24386: ST_TO_ADDR
// uc_side = 1 ;
24387: LD_ADDR_OWVAR 20
24391: PUSH
24392: LD_INT 1
24394: ST_TO_ADDR
// uc_nation = 1 ;
24395: LD_ADDR_OWVAR 21
24399: PUSH
24400: LD_INT 1
24402: ST_TO_ADDR
// for i = 1 to 5 do
24403: LD_ADDR_VAR 0 1
24407: PUSH
24408: DOUBLE
24409: LD_INT 1
24411: DEC
24412: ST_TO_ADDR
24413: LD_INT 5
24415: PUSH
24416: FOR_TO
24417: IFFALSE 24513
// begin vc_engine = 3 ;
24419: LD_ADDR_OWVAR 39
24423: PUSH
24424: LD_INT 3
24426: ST_TO_ADDR
// vc_control = 3 ;
24427: LD_ADDR_OWVAR 38
24431: PUSH
24432: LD_INT 3
24434: ST_TO_ADDR
// vc_chassis = 3 ;
24435: LD_ADDR_OWVAR 37
24439: PUSH
24440: LD_INT 3
24442: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
24443: LD_ADDR_OWVAR 40
24447: PUSH
24448: LD_INT 5
24450: PUSH
24451: LD_INT 9
24453: PUSH
24454: LD_INT 7
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: LIST
24461: PUSH
24462: LD_INT 1
24464: PPUSH
24465: LD_INT 3
24467: PPUSH
24468: CALL_OW 12
24472: ARRAY
24473: ST_TO_ADDR
// veh = CreateVehicle ;
24474: LD_ADDR_VAR 0 2
24478: PUSH
24479: CALL_OW 45
24483: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
24484: LD_VAR 0 2
24488: PPUSH
24489: LD_INT 1
24491: PPUSH
24492: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
24496: LD_VAR 0 2
24500: PPUSH
24501: LD_INT 19
24503: PPUSH
24504: LD_INT 0
24506: PPUSH
24507: CALL_OW 49
// end ;
24511: GO 24416
24513: POP
24514: POP
// vc_engine = 3 ;
24515: LD_ADDR_OWVAR 39
24519: PUSH
24520: LD_INT 3
24522: ST_TO_ADDR
// vc_control = 1 ;
24523: LD_ADDR_OWVAR 38
24527: PUSH
24528: LD_INT 1
24530: ST_TO_ADDR
// vc_chassis = 3 ;
24531: LD_ADDR_OWVAR 37
24535: PUSH
24536: LD_INT 3
24538: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
24539: LD_ADDR_OWVAR 40
24543: PUSH
24544: LD_INT 5
24546: PUSH
24547: LD_INT 9
24549: PUSH
24550: LD_INT 7
24552: PUSH
24553: EMPTY
24554: LIST
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 1
24560: PPUSH
24561: LD_INT 3
24563: PPUSH
24564: CALL_OW 12
24568: ARRAY
24569: ST_TO_ADDR
// vehG = CreateVehicle ;
24570: LD_ADDR_VAR 0 3
24574: PUSH
24575: CALL_OW 45
24579: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
24580: LD_VAR 0 3
24584: PPUSH
24585: LD_INT 1
24587: PPUSH
24588: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
24592: LD_VAR 0 3
24596: PPUSH
24597: LD_INT 19
24599: PPUSH
24600: LD_INT 0
24602: PPUSH
24603: CALL_OW 49
// if JMMGirl = 1 then
24607: LD_EXP 7
24611: PUSH
24612: LD_INT 1
24614: EQUAL
24615: IFFALSE 24671
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
24617: LD_ADDR_EXP 37
24621: PUSH
24622: LD_STRING Joan
24624: PPUSH
24625: LD_INT 1
24627: PPUSH
24628: LD_STRING 14_
24630: PPUSH
24631: CALL 60971 0 3
24635: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
24636: LD_EXP 37
24640: PPUSH
24641: LD_VAR 0 3
24645: PPUSH
24646: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
24650: LD_VAR 0 3
24654: PPUSH
24655: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
24659: LD_EXP 37
24663: PPUSH
24664: LD_STRING D10BW-Joan-1
24666: PPUSH
24667: CALL_OW 94
// end ; if JMMGirl = 2 then
24671: LD_EXP 7
24675: PUSH
24676: LD_INT 2
24678: EQUAL
24679: IFFALSE 24735
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
24681: LD_ADDR_EXP 39
24685: PUSH
24686: LD_STRING Lisa
24688: PPUSH
24689: LD_INT 1
24691: PPUSH
24692: LD_STRING 14_
24694: PPUSH
24695: CALL 60971 0 3
24699: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
24700: LD_EXP 39
24704: PPUSH
24705: LD_VAR 0 3
24709: PPUSH
24710: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
24714: LD_VAR 0 3
24718: PPUSH
24719: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
24723: LD_EXP 39
24727: PPUSH
24728: LD_STRING D10BW-Lisa-1
24730: PPUSH
24731: CALL_OW 94
// end ; if JMMGirl = 3 then
24735: LD_EXP 7
24739: PUSH
24740: LD_INT 3
24742: EQUAL
24743: IFFALSE 24799
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
24745: LD_ADDR_EXP 51
24749: PUSH
24750: LD_STRING Connie
24752: PPUSH
24753: LD_INT 1
24755: PPUSH
24756: LD_STRING 14_
24758: PPUSH
24759: CALL 60971 0 3
24763: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
24764: LD_EXP 51
24768: PPUSH
24769: LD_VAR 0 3
24773: PPUSH
24774: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
24778: LD_VAR 0 3
24782: PPUSH
24783: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
24787: LD_EXP 39
24791: PPUSH
24792: LD_STRING D10BW-Con-1
24794: PPUSH
24795: CALL_OW 94
// end ; end ;
24799: PPOPN 3
24801: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
24802: LD_EXP 14
24806: PUSH
24807: LD_INT 94500
24809: GREATEREQUAL
24810: IFFALSE 25232
24812: GO 24814
24814: DISABLE
24815: LD_INT 0
24817: PPUSH
24818: PPUSH
24819: PPUSH
// begin tmp := PrepareStevensSquad ;
24820: LD_ADDR_VAR 0 3
24824: PUSH
24825: CALL 1947 0 0
24829: ST_TO_ADDR
// display_strings := tmp ;
24830: LD_ADDR_OWVAR 47
24834: PUSH
24835: LD_VAR 0 3
24839: ST_TO_ADDR
// if not tmp then
24840: LD_VAR 0 3
24844: NOT
24845: IFFALSE 24849
// exit ;
24847: GO 25232
// uc_side := 1 ;
24849: LD_ADDR_OWVAR 20
24853: PUSH
24854: LD_INT 1
24856: ST_TO_ADDR
// uc_nation := 1 ;
24857: LD_ADDR_OWVAR 21
24861: PUSH
24862: LD_INT 1
24864: ST_TO_ADDR
// for i in tmp do
24865: LD_ADDR_VAR 0 1
24869: PUSH
24870: LD_VAR 0 3
24874: PUSH
24875: FOR_IN
24876: IFFALSE 24973
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
24878: LD_INT 3
24880: PPUSH
24881: LD_INT 3
24883: PPUSH
24884: LD_INT 1
24886: PPUSH
24887: LD_INT 5
24889: PUSH
24890: LD_INT 9
24892: PUSH
24893: LD_INT 7
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: PUSH
24901: LD_INT 1
24903: PPUSH
24904: LD_INT 3
24906: PPUSH
24907: CALL_OW 12
24911: ARRAY
24912: PPUSH
24913: LD_INT 40
24915: PPUSH
24916: CALL 67604 0 5
// veh := CreateVehicle ;
24920: LD_ADDR_VAR 0 2
24924: PUSH
24925: CALL_OW 45
24929: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
24930: LD_VAR 0 2
24934: PPUSH
24935: LD_INT 1
24937: PPUSH
24938: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
24942: LD_VAR 0 2
24946: PPUSH
24947: LD_INT 19
24949: PPUSH
24950: LD_INT 0
24952: PPUSH
24953: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
24957: LD_VAR 0 1
24961: PPUSH
24962: LD_VAR 0 2
24966: PPUSH
24967: CALL_OW 52
// end ;
24971: GO 24875
24973: POP
24974: POP
// missionStage := 8 ;
24975: LD_ADDR_EXP 15
24979: PUSH
24980: LD_INT 8
24982: ST_TO_ADDR
// DialogueOn ;
24983: CALL_OW 6
// if Stevens then
24987: LD_EXP 38
24991: IFFALSE 25105
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
24993: LD_EXP 38
24997: PPUSH
24998: CALL_OW 310
25002: PPUSH
25003: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25007: LD_EXP 38
25011: PPUSH
25012: LD_STRING D8-Huck-1
25014: PPUSH
25015: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25019: LD_EXP 36
25023: PPUSH
25024: LD_STRING D8-JMM-1
25026: PPUSH
25027: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25031: LD_EXP 38
25035: PPUSH
25036: LD_STRING D8-Huck-2
25038: PPUSH
25039: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25043: LD_EXP 36
25047: PPUSH
25048: LD_STRING D8-JMM-2
25050: PPUSH
25051: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25055: LD_EXP 38
25059: PPUSH
25060: LD_STRING D8-Huck-3
25062: PPUSH
25063: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25067: LD_EXP 36
25071: PPUSH
25072: LD_STRING D8-JMM-3
25074: PPUSH
25075: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25079: LD_EXP 38
25083: PPUSH
25084: LD_STRING D8-Huck-4
25086: PPUSH
25087: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25091: LD_EXP 36
25095: PPUSH
25096: LD_STRING D8-JMM-4
25098: PPUSH
25099: CALL_OW 88
// end else
25103: GO 25215
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25105: LD_EXP 52
25109: PPUSH
25110: CALL_OW 310
25114: PPUSH
25115: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
25119: LD_EXP 52
25123: PPUSH
25124: LD_STRING D8-Huck-1
25126: PPUSH
25127: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
25131: LD_EXP 36
25135: PPUSH
25136: LD_STRING D8-JMM-1a
25138: PPUSH
25139: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
25143: LD_EXP 52
25147: PPUSH
25148: LD_STRING D8-Huck-2
25150: PPUSH
25151: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25155: LD_EXP 36
25159: PPUSH
25160: LD_STRING D8-JMM-2
25162: PPUSH
25163: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
25167: LD_EXP 52
25171: PPUSH
25172: LD_STRING D8-Huck-3
25174: PPUSH
25175: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25179: LD_EXP 36
25183: PPUSH
25184: LD_STRING D8-JMM-3
25186: PPUSH
25187: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
25191: LD_EXP 52
25195: PPUSH
25196: LD_STRING D8-Huck-4
25198: PPUSH
25199: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25203: LD_EXP 36
25207: PPUSH
25208: LD_STRING D8-JMM-4
25210: PPUSH
25211: CALL_OW 88
// end ; DialogueOff ;
25215: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
25219: LD_INT 25
25221: PPUSH
25222: LD_INT 1
25224: PPUSH
25225: LD_INT 1
25227: PPUSH
25228: CALL_OW 322
// end ;
25232: PPOPN 3
25234: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
25235: LD_INT 1
25237: PPUSH
25238: LD_EXP 68
25242: PPUSH
25243: CALL_OW 292
25247: IFFALSE 25498
25249: GO 25251
25251: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
25252: LD_EXP 68
25256: PPUSH
25257: CALL_OW 87
// DialogueOn ;
25261: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
25265: LD_EXP 36
25269: PPUSH
25270: LD_STRING D10nB-JMM-1
25272: PPUSH
25273: CALL_OW 88
// if BurlakStatus = 1 then
25277: LD_EXP 9
25281: PUSH
25282: LD_INT 1
25284: EQUAL
25285: IFFALSE 25299
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
25287: LD_EXP 67
25291: PPUSH
25292: LD_STRING D10nB-Vse-1a
25294: PPUSH
25295: CALL_OW 94
// end ; if BurlakStatus = 0 then
25299: LD_EXP 9
25303: PUSH
25304: LD_INT 0
25306: EQUAL
25307: IFFALSE 25321
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
25309: LD_EXP 67
25313: PPUSH
25314: LD_STRING D10nB-Vse-1
25316: PPUSH
25317: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
25321: LD_EXP 36
25325: PPUSH
25326: LD_STRING D10nB-JMM-2
25328: PPUSH
25329: CALL_OW 88
// if KappaStatus then
25333: LD_EXP 2
25337: IFFALSE 25351
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
25339: LD_EXP 67
25343: PPUSH
25344: LD_STRING D10nB-Vse-5a
25346: PPUSH
25347: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
25351: LD_EXP 2
25355: NOT
25356: PUSH
25357: LD_EXP 6
25361: PUSH
25362: LD_INT 0
25364: EQUAL
25365: AND
25366: IFFALSE 25494
// begin if JMMGirl = 1 then
25368: LD_EXP 7
25372: PUSH
25373: LD_INT 1
25375: EQUAL
25376: IFFALSE 25426
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
25378: LD_EXP 67
25382: PPUSH
25383: LD_STRING D10nB-Vse-2
25385: PPUSH
25386: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
25390: LD_EXP 36
25394: PPUSH
25395: LD_STRING D10nB-JMM-3
25397: PPUSH
25398: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
25402: LD_EXP 67
25406: PPUSH
25407: LD_STRING D10nB-Vse-3
25409: PPUSH
25410: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
25414: LD_EXP 36
25418: PPUSH
25419: LD_STRING D10nB-JMM-4
25421: PPUSH
25422: CALL_OW 88
// end ; if JMMGirl = 2 then
25426: LD_EXP 7
25430: PUSH
25431: LD_INT 2
25433: EQUAL
25434: IFFALSE 25460
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
25436: LD_EXP 67
25440: PPUSH
25441: LD_STRING D10nB-Vse-4
25443: PPUSH
25444: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
25448: LD_EXP 36
25452: PPUSH
25453: LD_STRING D10nB-JMM-5
25455: PPUSH
25456: CALL_OW 88
// end ; if JMMGirl = 3 then
25460: LD_EXP 7
25464: PUSH
25465: LD_INT 3
25467: EQUAL
25468: IFFALSE 25494
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
25470: LD_EXP 67
25474: PPUSH
25475: LD_STRING D10nB-Vse-5
25477: PPUSH
25478: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
25482: LD_EXP 36
25486: PPUSH
25487: LD_STRING D10nB-JMM-6
25489: PPUSH
25490: CALL_OW 88
// end ; end ; DialogueOff ;
25494: CALL_OW 7
// end ;
25498: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
25499: LD_EXP 14
25503: PUSH
25504: LD_INT 115500
25506: GREATEREQUAL
25507: IFFALSE 25866
25509: GO 25511
25511: DISABLE
25512: LD_INT 0
25514: PPUSH
// begin missionStage := 10 ;
25515: LD_ADDR_EXP 15
25519: PUSH
25520: LD_INT 10
25522: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
25523: LD_ADDR_VAR 0 1
25527: PUSH
25528: LD_INT 22
25530: PUSH
25531: LD_INT 1
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 26
25540: PUSH
25541: LD_INT 1
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: LD_INT 3
25550: PUSH
25551: LD_INT 25
25553: PUSH
25554: LD_INT 12
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: PUSH
25561: EMPTY
25562: LIST
25563: LIST
25564: PUSH
25565: LD_INT 3
25567: PUSH
25568: LD_INT 25
25570: PUSH
25571: LD_INT 16
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: PPUSH
25588: CALL_OW 69
25592: PUSH
25593: LD_EXP 36
25597: PUSH
25598: LD_EXP 38
25602: PUSH
25603: LD_EXP 52
25607: PUSH
25608: LD_EXP 39
25612: PUSH
25613: LD_EXP 40
25617: PUSH
25618: LD_EXP 41
25622: PUSH
25623: LD_EXP 42
25627: PUSH
25628: LD_EXP 43
25632: PUSH
25633: LD_EXP 44
25637: PUSH
25638: LD_EXP 45
25642: PUSH
25643: LD_EXP 46
25647: PUSH
25648: LD_EXP 47
25652: PUSH
25653: LD_EXP 48
25657: PUSH
25658: LD_EXP 49
25662: PUSH
25663: LD_EXP 50
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: LIST
25682: LIST
25683: LIST
25684: DIFF
25685: ST_TO_ADDR
// if not tmp and Brown then
25686: LD_VAR 0 1
25690: NOT
25691: PUSH
25692: LD_EXP 44
25696: AND
25697: IFFALSE 25712
// tmp := [ Brown ] ;
25699: LD_ADDR_VAR 0 1
25703: PUSH
25704: LD_EXP 44
25708: PUSH
25709: EMPTY
25710: LIST
25711: ST_TO_ADDR
// DialogueOn ;
25712: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
25716: LD_VAR 0 1
25720: PUSH
25721: LD_INT 1
25723: ARRAY
25724: PPUSH
25725: LD_STRING D11-Sol1-1
25727: PPUSH
25728: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
25732: LD_EXP 61
25736: PPUSH
25737: LD_STRING D11-Pla-1
25739: PPUSH
25740: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
25744: LD_EXP 62
25748: PPUSH
25749: LD_STRING D11-Kov-1
25751: PPUSH
25752: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
25756: LD_EXP 61
25760: PPUSH
25761: LD_STRING D11-Pla-2
25763: PPUSH
25764: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
25768: LD_VAR 0 1
25772: PUSH
25773: LD_INT 1
25775: ARRAY
25776: PPUSH
25777: LD_STRING D11-Sol1-2
25779: PPUSH
25780: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
25784: LD_EXP 36
25788: PPUSH
25789: LD_STRING D11-JMM-2
25791: PPUSH
25792: CALL_OW 88
// DialogueOff ;
25796: CALL_OW 7
// allowBehemothConstruct := true ;
25800: LD_ADDR_EXP 25
25804: PUSH
25805: LD_INT 1
25807: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
25808: LD_STRING M4
25810: PPUSH
25811: CALL_OW 337
// BuildBehemoths ;
25815: CALL 7165 0 0
// repeat wait ( 15 15$00 ) ;
25819: LD_INT 31500
25821: PPUSH
25822: CALL_OW 67
// if behemothDestroyedBeforeFinish then
25826: LD_EXP 27
25830: IFFALSE 25834
// break ;
25832: GO 25866
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
25834: LD_INT 267
25836: PPUSH
25837: CALL_OW 274
25841: PPUSH
25842: LD_INT 1
25844: PPUSH
25845: CALL_OW 275
25849: PUSH
25850: LD_INT 1000
25852: GREATEREQUAL
25853: IFFALSE 25859
// BuildBehemoths ;
25855: CALL 7165 0 0
// until not behemothBuilders ;
25859: LD_EXP 70
25863: NOT
25864: IFFALSE 25819
// end ;
25866: PPOPN 1
25868: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
25869: LD_EXP 70
25873: NOT
25874: PUSH
25875: LD_EXP 28
25879: NOT
25880: AND
25881: PUSH
25882: LD_EXP 25
25886: AND
25887: IFFALSE 25907
25889: GO 25891
25891: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
25892: LD_STRING M4a
25894: PPUSH
25895: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
25899: LD_ADDR_EXP 27
25903: PUSH
25904: LD_INT 1
25906: ST_TO_ADDR
// end ;
25907: END
// every 0 0$1 trigger behemothDone do
25908: LD_EXP 28
25912: IFFALSE 25924
25914: GO 25916
25916: DISABLE
// ChangeMissionObjectives ( M4b ) ;
25917: LD_STRING M4b
25919: PPUSH
25920: CALL_OW 337
25924: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
25925: LD_EXP 29
25929: NOT
25930: IFFALSE 26126
25932: GO 25934
25934: DISABLE
25935: LD_INT 0
25937: PPUSH
25938: PPUSH
// begin enable ;
25939: ENABLE
// tmp := GetBehemoths ( 3 ) ;
25940: LD_ADDR_VAR 0 1
25944: PUSH
25945: LD_INT 3
25947: PPUSH
25948: CALL 103335 0 1
25952: ST_TO_ADDR
// if not tmp and not behemothDone then
25953: LD_VAR 0 1
25957: NOT
25958: PUSH
25959: LD_EXP 28
25963: NOT
25964: AND
25965: IFFALSE 26001
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
25967: LD_ADDR_VAR 0 1
25971: PUSH
25972: LD_INT 22
25974: PUSH
25975: LD_INT 3
25977: PUSH
25978: EMPTY
25979: LIST
25980: LIST
25981: PUSH
25982: LD_INT 30
25984: PUSH
25985: LD_INT 37
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PPUSH
25996: CALL_OW 69
26000: ST_TO_ADDR
// if not tmp then
26001: LD_VAR 0 1
26005: NOT
26006: IFFALSE 26010
// exit ;
26008: GO 26126
// for i in tmp do
26010: LD_ADDR_VAR 0 2
26014: PUSH
26015: LD_VAR 0 1
26019: PUSH
26020: FOR_IN
26021: IFFALSE 26124
// if See ( 1 , i ) then
26023: LD_INT 1
26025: PPUSH
26026: LD_VAR 0 2
26030: PPUSH
26031: CALL_OW 292
26035: IFFALSE 26122
// begin if GetType ( i ) = unit_building then
26037: LD_VAR 0 2
26041: PPUSH
26042: CALL_OW 247
26046: PUSH
26047: LD_INT 3
26049: EQUAL
26050: IFFALSE 26088
// begin CenterNowOnUnits ( i ) ;
26052: LD_VAR 0 2
26056: PPUSH
26057: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26061: LD_EXP 36
26065: PPUSH
26066: LD_STRING D17a-JMM-1
26068: PPUSH
26069: CALL_OW 88
// seeBehemoth := true ;
26073: LD_ADDR_EXP 29
26077: PUSH
26078: LD_INT 1
26080: ST_TO_ADDR
// disable ;
26081: DISABLE
// exit ;
26082: POP
26083: POP
26084: GO 26126
// end else
26086: GO 26122
// begin CenterNowOnUnits ( i ) ;
26088: LD_VAR 0 2
26092: PPUSH
26093: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26097: LD_EXP 36
26101: PPUSH
26102: LD_STRING D17b-JMM-1
26104: PPUSH
26105: CALL_OW 88
// seeBehemoth := true ;
26109: LD_ADDR_EXP 29
26113: PUSH
26114: LD_INT 1
26116: ST_TO_ADDR
// disable ;
26117: DISABLE
// exit ;
26118: POP
26119: POP
26120: GO 26126
// end ; end ;
26122: GO 26020
26124: POP
26125: POP
// end ;
26126: PPOPN 2
26128: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var bomb , dec , tmp ;
26129: LD_EXP 14
26133: PUSH
26134: LD_INT 115500
26136: GREATEREQUAL
26137: IFFALSE 27310
26139: GO 26141
26141: DISABLE
26142: LD_INT 0
26144: PPUSH
26145: PPUSH
26146: PPUSH
// begin MC_InsertProduceList ( 2 , [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ) ;
26147: LD_INT 2
26149: PPUSH
26150: LD_INT 23
26152: PUSH
26153: LD_INT 3
26155: PUSH
26156: LD_INT 3
26158: PUSH
26159: LD_INT 48
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: LIST
26166: LIST
26167: PPUSH
26168: CALL 55076 0 2
// repeat wait ( 0 0$1 ) ;
26172: LD_INT 35
26174: PPUSH
26175: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
26179: LD_INT 22
26181: PUSH
26182: LD_INT 3
26184: PUSH
26185: EMPTY
26186: LIST
26187: LIST
26188: PUSH
26189: LD_INT 34
26191: PUSH
26192: LD_INT 48
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: PPUSH
26203: CALL_OW 69
26207: IFFALSE 26172
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26209: LD_ADDR_VAR 0 1
26213: PUSH
26214: LD_INT 22
26216: PUSH
26217: LD_INT 3
26219: PUSH
26220: EMPTY
26221: LIST
26222: LIST
26223: PUSH
26224: LD_INT 34
26226: PUSH
26227: LD_INT 48
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PPUSH
26238: CALL_OW 69
26242: PUSH
26243: LD_INT 1
26245: ARRAY
26246: ST_TO_ADDR
// missionStage := 12 ;
26247: LD_ADDR_EXP 15
26251: PUSH
26252: LD_INT 12
26254: ST_TO_ADDR
// platonovHasBomb := true ;
26255: LD_ADDR_EXP 30
26259: PUSH
26260: LD_INT 1
26262: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
26263: LD_VAR 0 1
26267: PPUSH
26268: LD_INT 181
26270: PPUSH
26271: LD_INT 86
26273: PPUSH
26274: CALL_OW 171
// AddComHold ( bomb ) ;
26278: LD_VAR 0 1
26282: PPUSH
26283: CALL_OW 200
// wait ( 0 0$10 ) ;
26287: LD_INT 350
26289: PPUSH
26290: CALL_OW 67
// DialogueOn ;
26294: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
26298: LD_EXP 61
26302: PPUSH
26303: LD_STRING D15-Pla-1
26305: PPUSH
26306: CALL_OW 94
// dec = Query ( Q15a ) ;
26310: LD_ADDR_VAR 0 2
26314: PUSH
26315: LD_STRING Q15a
26317: PPUSH
26318: CALL_OW 97
26322: ST_TO_ADDR
// if dec = 1 then
26323: LD_VAR 0 2
26327: PUSH
26328: LD_INT 1
26330: EQUAL
26331: IFFALSE 26354
// begin Say ( JMM , D15a-JMM-1 ) ;
26333: LD_EXP 36
26337: PPUSH
26338: LD_STRING D15a-JMM-1
26340: PPUSH
26341: CALL_OW 88
// YouLost ( Surrender ) ;
26345: LD_STRING Surrender
26347: PPUSH
26348: CALL_OW 104
// exit ;
26352: GO 27310
// end ; if dec = 2 then
26354: LD_VAR 0 2
26358: PUSH
26359: LD_INT 2
26361: EQUAL
26362: IFFALSE 26431
// begin Say ( JMM , D15b-JMM-1 ) ;
26364: LD_EXP 36
26368: PPUSH
26369: LD_STRING D15b-JMM-1
26371: PPUSH
26372: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
26376: LD_EXP 61
26380: PPUSH
26381: LD_STRING D15b-Pla-1
26383: PPUSH
26384: CALL_OW 94
// DialogueOff ;
26388: CALL_OW 7
// wait ( 3 3$00 ) ;
26392: LD_INT 6300
26394: PPUSH
26395: CALL_OW 67
// DialogueOn ;
26399: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
26403: LD_EXP 36
26407: PPUSH
26408: LD_STRING D15d-JMM-1a
26410: PPUSH
26411: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
26415: LD_EXP 61
26419: PPUSH
26420: LD_STRING D15d-Pla-1
26422: PPUSH
26423: CALL_OW 94
// DialogueOff ;
26427: CALL_OW 7
// end ; if dec = 3 then
26431: LD_VAR 0 2
26435: PUSH
26436: LD_INT 3
26438: EQUAL
26439: IFFALSE 26493
// begin Say ( JMM , D15c-JMM-1 ) ;
26441: LD_EXP 36
26445: PPUSH
26446: LD_STRING D15c-JMM-1
26448: PPUSH
26449: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
26453: LD_EXP 61
26457: PPUSH
26458: LD_STRING D15c-Pla-1
26460: PPUSH
26461: CALL_OW 94
// DialogueOff ;
26465: CALL_OW 7
// wait ( 0 0$15 ) ;
26469: LD_INT 525
26471: PPUSH
26472: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
26476: LD_VAR 0 1
26480: PPUSH
26481: LD_INT 60
26483: PPUSH
26484: LD_INT 95
26486: PPUSH
26487: CALL_OW 116
// exit ;
26491: GO 27310
// end ; if dec = 4 then
26493: LD_VAR 0 2
26497: PUSH
26498: LD_INT 4
26500: EQUAL
26501: IFFALSE 26531
// begin Say ( JMM , D15d-JMM-1 ) ;
26503: LD_EXP 36
26507: PPUSH
26508: LD_STRING D15d-JMM-1
26510: PPUSH
26511: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
26515: LD_EXP 61
26519: PPUSH
26520: LD_STRING D15d-Pla-1
26522: PPUSH
26523: CALL_OW 94
// DialogueOff ;
26527: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
26531: LD_EXP 59
26535: PPUSH
26536: CALL_OW 302
26540: PUSH
26541: LD_EXP 59
26545: PPUSH
26546: CALL_OW 255
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: AND
26555: PUSH
26556: LD_INT 22
26558: PUSH
26559: LD_INT 1
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 34
26568: PUSH
26569: LD_INT 8
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PPUSH
26580: CALL_OW 69
26584: NOT
26585: AND
26586: IFFALSE 27211
// begin SetSide ( Friend , 8 ) ;
26588: LD_EXP 59
26592: PPUSH
26593: LD_INT 8
26595: PPUSH
26596: CALL_OW 235
// if IsInUnit ( Friend ) then
26600: LD_EXP 59
26604: PPUSH
26605: CALL_OW 310
26609: IFFALSE 26620
// ComExitBuilding ( Friend ) ;
26611: LD_EXP 59
26615: PPUSH
26616: CALL_OW 122
// if IsDriver ( Friend ) then
26620: LD_EXP 59
26624: PPUSH
26625: CALL 101011 0 1
26629: IFFALSE 26640
// ComExitVehicle ( Friend ) ;
26631: LD_EXP 59
26635: PPUSH
26636: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
26640: LD_EXP 59
26644: PPUSH
26645: LD_INT 9
26647: PPUSH
26648: LD_INT 2
26650: PPUSH
26651: CALL_OW 171
// wait ( 0 0$05 ) ;
26655: LD_INT 175
26657: PPUSH
26658: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26662: LD_EXP 59
26666: PPUSH
26667: CALL_OW 87
// DialogueOn ;
26671: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
26675: LD_EXP 36
26679: PPUSH
26680: LD_STRING D16-JMM-1
26682: PPUSH
26683: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
26687: LD_EXP 59
26691: PPUSH
26692: LD_STRING D16-Friend-1
26694: PPUSH
26695: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
26699: LD_EXP 36
26703: PPUSH
26704: LD_STRING D16-JMM-2
26706: PPUSH
26707: CALL_OW 88
// DialogueOff ;
26711: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26715: LD_EXP 59
26719: PPUSH
26720: LD_INT 1
26722: PPUSH
26723: CALL_OW 235
// ComHold ( Friend ) ;
26727: LD_EXP 59
26731: PPUSH
26732: CALL_OW 140
// wait ( 0 0$20 ) ;
26736: LD_INT 700
26738: PPUSH
26739: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
26743: LD_EXP 59
26747: PPUSH
26748: LD_INT 9
26750: PPUSH
26751: LD_INT 2
26753: PPUSH
26754: CALL_OW 297
26758: PUSH
26759: LD_INT 30
26761: LESS
26762: IFFALSE 26831
// begin SetSide ( Friend , 8 ) ;
26764: LD_EXP 59
26768: PPUSH
26769: LD_INT 8
26771: PPUSH
26772: CALL_OW 235
// if IsInUnit ( Friend ) then
26776: LD_EXP 59
26780: PPUSH
26781: CALL_OW 310
26785: IFFALSE 26796
// ComExitBuilding ( Friend ) ;
26787: LD_EXP 59
26791: PPUSH
26792: CALL_OW 122
// if IsDriver ( Friend ) then
26796: LD_EXP 59
26800: PPUSH
26801: CALL 101011 0 1
26805: IFFALSE 26816
// ComExitVehicle ( Friend ) ;
26807: LD_EXP 59
26811: PPUSH
26812: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
26816: LD_EXP 59
26820: PPUSH
26821: LD_INT 9
26823: PPUSH
26824: LD_INT 2
26826: PPUSH
26827: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
26831: LD_INT 1050
26833: PPUSH
26834: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
26838: LD_INT 22
26840: PUSH
26841: LD_INT 1
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: PUSH
26848: LD_INT 34
26850: PUSH
26851: LD_INT 8
26853: PUSH
26854: EMPTY
26855: LIST
26856: LIST
26857: PUSH
26858: EMPTY
26859: LIST
26860: LIST
26861: PPUSH
26862: CALL_OW 69
26866: NOT
26867: IFFALSE 27189
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26869: LD_ADDR_VAR 0 3
26873: PUSH
26874: LD_INT 22
26876: PUSH
26877: LD_INT 1
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: LD_INT 26
26886: PUSH
26887: LD_INT 1
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: PUSH
26894: LD_INT 3
26896: PUSH
26897: LD_INT 25
26899: PUSH
26900: LD_INT 12
26902: PUSH
26903: EMPTY
26904: LIST
26905: LIST
26906: PUSH
26907: LD_INT 25
26909: PUSH
26910: LD_INT 16
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: EMPTY
26918: LIST
26919: LIST
26920: LIST
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: LIST
26926: PPUSH
26927: CALL_OW 69
26931: PUSH
26932: LD_EXP 36
26936: PUSH
26937: LD_EXP 38
26941: PUSH
26942: LD_EXP 52
26946: PUSH
26947: LD_EXP 39
26951: PUSH
26952: LD_EXP 40
26956: PUSH
26957: LD_EXP 41
26961: PUSH
26962: LD_EXP 42
26966: PUSH
26967: LD_EXP 43
26971: PUSH
26972: LD_EXP 44
26976: PUSH
26977: LD_EXP 45
26981: PUSH
26982: LD_EXP 46
26986: PUSH
26987: LD_EXP 47
26991: PUSH
26992: LD_EXP 48
26996: PUSH
26997: LD_EXP 49
27001: PUSH
27002: LD_EXP 50
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: DIFF
27024: ST_TO_ADDR
// DialogueOn ;
27025: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27029: LD_EXP 61
27033: PPUSH
27034: LD_STRING D16a-Pla-1
27036: PPUSH
27037: CALL_OW 94
// if Stevens then
27041: LD_EXP 38
27045: IFFALSE 27061
// Say ( Stevens , D16a-Huck-1 ) else
27047: LD_EXP 38
27051: PPUSH
27052: LD_STRING D16a-Huck-1
27054: PPUSH
27055: CALL_OW 88
27059: GO 27103
// if Baker then
27061: LD_EXP 52
27065: IFFALSE 27081
// Say ( Baker , D16a-Huck-1 ) else
27067: LD_EXP 52
27071: PPUSH
27072: LD_STRING D16a-Huck-1
27074: PPUSH
27075: CALL_OW 88
27079: GO 27103
// if tmp then
27081: LD_VAR 0 3
27085: IFFALSE 27103
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27087: LD_VAR 0 3
27091: PUSH
27092: LD_INT 1
27094: ARRAY
27095: PPUSH
27096: LD_STRING D16a-Sol1-1
27098: PPUSH
27099: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27103: LD_EXP 59
27107: PPUSH
27108: CALL_OW 255
27112: PUSH
27113: LD_INT 8
27115: EQUAL
27116: IFFALSE 27132
// Say ( JMM , D16a-JMM-1 ) else
27118: LD_EXP 36
27122: PPUSH
27123: LD_STRING D16a-JMM-1
27125: PPUSH
27126: CALL_OW 88
27130: GO 27168
// begin Say ( JMM , D16a-JMM-1a ) ;
27132: LD_EXP 36
27136: PPUSH
27137: LD_STRING D16a-JMM-1a
27139: PPUSH
27140: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
27144: LD_EXP 59
27148: PPUSH
27149: LD_STRING D16a-Friend-1
27151: PPUSH
27152: CALL_OW 88
// SetSide ( Friend , 3 ) ;
27156: LD_EXP 59
27160: PPUSH
27161: LD_INT 3
27163: PPUSH
27164: CALL_OW 235
// end ; DialogueOff ;
27168: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
27172: LD_VAR 0 1
27176: PPUSH
27177: LD_INT 60
27179: PPUSH
27180: LD_INT 95
27182: PPUSH
27183: CALL_OW 116
// end else
27187: GO 27209
// begin DialogueOn ;
27189: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
27193: LD_EXP 61
27197: PPUSH
27198: LD_STRING D16c-Pla-
27200: PPUSH
27201: CALL_OW 94
// DialogueOff ;
27205: CALL_OW 7
// end ; end else
27209: GO 27310
// begin wait ( 3 3$00 ) ;
27211: LD_INT 6300
27213: PPUSH
27214: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27218: LD_INT 22
27220: PUSH
27221: LD_INT 1
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 34
27230: PUSH
27231: LD_INT 8
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PPUSH
27242: CALL_OW 69
27246: NOT
27247: IFFALSE 27290
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
27249: LD_EXP 61
27253: PPUSH
27254: LD_STRING D16b-Pla-1
27256: PPUSH
27257: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
27261: LD_EXP 36
27265: PPUSH
27266: LD_STRING D16b-JMM-
27268: PPUSH
27269: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
27273: LD_VAR 0 1
27277: PPUSH
27278: LD_INT 60
27280: PPUSH
27281: LD_INT 95
27283: PPUSH
27284: CALL_OW 116
// end else
27288: GO 27310
// begin DialogueOn ;
27290: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
27294: LD_EXP 61
27298: PPUSH
27299: LD_STRING D16c-Pla-
27301: PPUSH
27302: CALL_OW 94
// DialogueOff ;
27306: CALL_OW 7
// end ; end ; end ;
27310: PPOPN 3
27312: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
27313: LD_EXP 14
27317: PUSH
27318: LD_INT 126000
27320: GREATEREQUAL
27321: PUSH
27322: LD_EXP 23
27326: NOT
27327: AND
27328: PUSH
27329: LD_EXP 71
27333: PPUSH
27334: CALL_OW 302
27338: AND
27339: IFFALSE 27697
27341: GO 27343
27343: DISABLE
27344: LD_INT 0
27346: PPUSH
// begin missionStage = 11 ;
27347: LD_ADDR_EXP 15
27351: PUSH
27352: LD_INT 11
27354: ST_TO_ADDR
// DialogueOn ;
27355: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
27359: LD_EXP 71
27363: PPUSH
27364: LD_STRING D9-Roth-1
27366: PPUSH
27367: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
27371: LD_EXP 36
27375: PPUSH
27376: LD_STRING D9-JMM-1
27378: PPUSH
27379: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
27383: LD_EXP 71
27387: PPUSH
27388: LD_STRING D9-Roth-2
27390: PPUSH
27391: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
27395: LD_EXP 71
27399: PPUSH
27400: LD_STRING D9-Roth-2a
27402: PPUSH
27403: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
27407: LD_EXP 61
27411: PPUSH
27412: LD_STRING D9-Pla-2
27414: PPUSH
27415: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
27419: LD_EXP 71
27423: PPUSH
27424: LD_STRING D9-Roth-3
27426: PPUSH
27427: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
27431: LD_EXP 61
27435: PPUSH
27436: LD_STRING D9-Pla-3
27438: PPUSH
27439: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
27443: LD_EXP 71
27447: PPUSH
27448: LD_STRING D9-Roth-4
27450: PPUSH
27451: CALL_OW 94
// dec = Query ( Q9 ) ;
27455: LD_ADDR_VAR 0 1
27459: PUSH
27460: LD_STRING Q9
27462: PPUSH
27463: CALL_OW 97
27467: ST_TO_ADDR
// if dec = 1 then
27468: LD_VAR 0 1
27472: PUSH
27473: LD_INT 1
27475: EQUAL
27476: IFFALSE 27490
// SayRadio ( Roth , D9a-Roth-1 ) ;
27478: LD_EXP 71
27482: PPUSH
27483: LD_STRING D9a-Roth-1
27485: PPUSH
27486: CALL_OW 94
// if dec = 2 then
27490: LD_VAR 0 1
27494: PUSH
27495: LD_INT 2
27497: EQUAL
27498: IFFALSE 27524
// begin Say ( JMM , D9b-JMM-1 ) ;
27500: LD_EXP 36
27504: PPUSH
27505: LD_STRING D9b-JMM-1
27507: PPUSH
27508: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
27512: LD_EXP 71
27516: PPUSH
27517: LD_STRING D9b-Roth-1
27519: PPUSH
27520: CALL_OW 94
// end ; if dec = 3 then
27524: LD_VAR 0 1
27528: PUSH
27529: LD_INT 3
27531: EQUAL
27532: IFFALSE 27594
// begin Say ( JMM , D9c-JMM-1 ) ;
27534: LD_EXP 36
27538: PPUSH
27539: LD_STRING D9c-JMM-1
27541: PPUSH
27542: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
27546: LD_EXP 71
27550: PPUSH
27551: LD_STRING D9c-Roth-1
27553: PPUSH
27554: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
27558: LD_EXP 36
27562: PPUSH
27563: LD_STRING D9c-JMM-2
27565: PPUSH
27566: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
27570: LD_EXP 71
27574: PPUSH
27575: LD_STRING D9c-Roth-2
27577: PPUSH
27578: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
27582: LD_EXP 36
27586: PPUSH
27587: LD_STRING D9c-JMM-3
27589: PPUSH
27590: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
27594: LD_EXP 71
27598: PPUSH
27599: LD_STRING D9c-Roth-3
27601: PPUSH
27602: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
27606: LD_EXP 71
27610: PPUSH
27611: LD_STRING D9cont-Roth-1
27613: PPUSH
27614: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
27618: LD_EXP 36
27622: PPUSH
27623: LD_STRING D9cont-JMM-1
27625: PPUSH
27626: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
27630: LD_EXP 71
27634: PPUSH
27635: LD_STRING D9cont-Roth-2
27637: PPUSH
27638: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
27642: LD_EXP 36
27646: PPUSH
27647: LD_STRING D9cont-JMM-2
27649: PPUSH
27650: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
27654: LD_EXP 71
27658: PPUSH
27659: LD_STRING D9cont-Roth-3
27661: PPUSH
27662: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
27666: LD_EXP 36
27670: PPUSH
27671: LD_STRING D9cont-JMM-3
27673: PPUSH
27674: CALL_OW 88
// DialogueOff ;
27678: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
27682: LD_STRING M3
27684: PPUSH
27685: CALL_OW 337
// allianceActive := true ;
27689: LD_ADDR_EXP 31
27693: PUSH
27694: LD_INT 1
27696: ST_TO_ADDR
// end ;
27697: PPOPN 1
27699: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
27700: LD_EXP 61
27704: PPUSH
27705: CALL_OW 301
27709: PUSH
27710: LD_EXP 64
27714: PPUSH
27715: CALL_OW 301
27719: AND
27720: PUSH
27721: LD_INT 22
27723: PUSH
27724: LD_INT 3
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PUSH
27731: LD_INT 21
27733: PUSH
27734: LD_INT 1
27736: PUSH
27737: EMPTY
27738: LIST
27739: LIST
27740: PUSH
27741: LD_INT 50
27743: PUSH
27744: EMPTY
27745: LIST
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: LIST
27751: PPUSH
27752: CALL_OW 69
27756: PUSH
27757: LD_INT 7
27759: PUSH
27760: LD_INT 8
27762: PUSH
27763: LD_INT 9
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: LIST
27770: PUSH
27771: LD_OWVAR 67
27775: ARRAY
27776: LESS
27777: AND
27778: IFFALSE 28537
27780: GO 27782
27782: DISABLE
27783: LD_INT 0
27785: PPUSH
27786: PPUSH
27787: PPUSH
27788: PPUSH
// begin MC_Kill ( 1 ) ;
27789: LD_INT 1
27791: PPUSH
27792: CALL 32997 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
27796: LD_INT 1
27798: PPUSH
27799: LD_INT 3
27801: PPUSH
27802: LD_INT 1
27804: PPUSH
27805: LD_INT 1
27807: PPUSH
27808: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
27812: LD_ADDR_VAR 0 1
27816: PUSH
27817: LD_INT 22
27819: PUSH
27820: LD_INT 3
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 1
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: LD_INT 24
27839: PUSH
27840: LD_INT 900
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: LIST
27851: PPUSH
27852: CALL_OW 69
27856: PUSH
27857: FOR_IN
27858: IFFALSE 27889
// if GetSex ( i ) = sex_male then
27860: LD_VAR 0 1
27864: PPUSH
27865: CALL_OW 258
27869: PUSH
27870: LD_INT 1
27872: EQUAL
27873: IFFALSE 27887
// begin tmp = i ;
27875: LD_ADDR_VAR 0 2
27879: PUSH
27880: LD_VAR 0 1
27884: ST_TO_ADDR
// break ;
27885: GO 27889
// end ;
27887: GO 27857
27889: POP
27890: POP
// if tmp = 0 then
27891: LD_VAR 0 2
27895: PUSH
27896: LD_INT 0
27898: EQUAL
27899: IFFALSE 27953
// begin uc_side = 3 ;
27901: LD_ADDR_OWVAR 20
27905: PUSH
27906: LD_INT 3
27908: ST_TO_ADDR
// uc_nation = 3 ;
27909: LD_ADDR_OWVAR 21
27913: PUSH
27914: LD_INT 3
27916: ST_TO_ADDR
// hc_name =  ;
27917: LD_ADDR_OWVAR 26
27921: PUSH
27922: LD_STRING 
27924: ST_TO_ADDR
// hc_gallery =  ;
27925: LD_ADDR_OWVAR 33
27929: PUSH
27930: LD_STRING 
27932: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
27933: LD_INT 1
27935: PPUSH
27936: LD_INT 10
27938: PPUSH
27939: CALL_OW 381
// tmp = CreateHuman ;
27943: LD_ADDR_VAR 0 2
27947: PUSH
27948: CALL_OW 44
27952: ST_TO_ADDR
// end ; DialogueOn ;
27953: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
27957: LD_VAR 0 2
27961: PPUSH
27962: LD_STRING DSurrenderRussians-RSol1-1a
27964: PPUSH
27965: CALL_OW 88
// DialogueOff ;
27969: CALL_OW 7
// russianDestroyed := true ;
27973: LD_ADDR_EXP 21
27977: PUSH
27978: LD_INT 1
27980: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
27981: LD_INT 22
27983: PUSH
27984: LD_INT 3
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: LD_INT 21
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PPUSH
28005: CALL_OW 69
28009: PPUSH
28010: CALL_OW 122
// wait ( 0 0$1 ) ;
28014: LD_INT 35
28016: PPUSH
28017: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28021: LD_INT 22
28023: PUSH
28024: LD_INT 3
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 21
28033: PUSH
28034: LD_INT 1
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PPUSH
28045: CALL_OW 69
28049: PPUSH
28050: LD_INT 25
28052: PPUSH
28053: CALL_OW 173
// wait ( 0 0$10 ) ;
28057: LD_INT 350
28059: PPUSH
28060: CALL_OW 67
// PrepareOmarInvasion ;
28064: CALL 12989 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28068: LD_ADDR_VAR 0 2
28072: PUSH
28073: LD_EXP 89
28077: PPUSH
28078: CALL_OW 250
28082: PUSH
28083: LD_EXP 89
28087: PPUSH
28088: CALL_OW 251
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28097: LD_VAR 0 2
28101: PUSH
28102: LD_INT 1
28104: ARRAY
28105: PPUSH
28106: LD_VAR 0 2
28110: PUSH
28111: LD_INT 2
28113: ARRAY
28114: PPUSH
28115: LD_INT 1
28117: PPUSH
28118: LD_INT 8
28120: NEG
28121: PPUSH
28122: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
28126: LD_EXP 89
28130: PPUSH
28131: CALL_OW 87
// DialogueOn ;
28135: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
28139: LD_EXP 36
28143: PPUSH
28144: LD_STRING D19-JMM-1
28146: PPUSH
28147: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
28151: LD_ADDR_VAR 0 3
28155: PUSH
28156: LD_INT 22
28158: PUSH
28159: LD_INT 1
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 26
28168: PUSH
28169: LD_INT 1
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 2
28178: PUSH
28179: LD_INT 25
28181: PUSH
28182: LD_INT 1
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 25
28191: PUSH
28192: LD_INT 2
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 25
28201: PUSH
28202: LD_INT 3
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: LD_INT 25
28211: PUSH
28212: LD_INT 4
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 25
28221: PUSH
28222: LD_INT 5
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 25
28231: PUSH
28232: LD_INT 8
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: LIST
28252: PPUSH
28253: CALL_OW 69
28257: PUSH
28258: LD_EXP 36
28262: PUSH
28263: LD_EXP 37
28267: PUSH
28268: LD_EXP 38
28272: PUSH
28273: LD_EXP 39
28277: PUSH
28278: LD_EXP 40
28282: PUSH
28283: LD_EXP 41
28287: PUSH
28288: LD_EXP 42
28292: PUSH
28293: LD_EXP 43
28297: PUSH
28298: LD_EXP 44
28302: PUSH
28303: LD_EXP 45
28307: PUSH
28308: LD_EXP 46
28312: PUSH
28313: LD_EXP 47
28317: PUSH
28318: LD_EXP 48
28322: PUSH
28323: LD_EXP 49
28327: PUSH
28328: LD_EXP 50
28332: PUSH
28333: LD_EXP 51
28337: PUSH
28338: LD_EXP 52
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: LIST
28347: LIST
28348: LIST
28349: LIST
28350: LIST
28351: LIST
28352: LIST
28353: LIST
28354: LIST
28355: LIST
28356: LIST
28357: LIST
28358: LIST
28359: LIST
28360: LIST
28361: DIFF
28362: ST_TO_ADDR
// if tmp2 then
28363: LD_VAR 0 3
28367: IFFALSE 28385
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
28369: LD_VAR 0 3
28373: PUSH
28374: LD_INT 1
28376: ARRAY
28377: PPUSH
28378: LD_STRING D19-Sol1-1
28380: PPUSH
28381: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
28385: LD_EXP 36
28389: PPUSH
28390: LD_STRING D19-JMM-2
28392: PPUSH
28393: CALL_OW 88
// DialogueOff ;
28397: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
28401: LD_VAR 0 2
28405: PUSH
28406: LD_INT 1
28408: ARRAY
28409: PPUSH
28410: LD_VAR 0 2
28414: PUSH
28415: LD_INT 2
28417: ARRAY
28418: PPUSH
28419: LD_INT 1
28421: PPUSH
28422: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
28426: LD_STRING M5
28428: PPUSH
28429: CALL_OW 337
// omarOnMotherLode := false ;
28433: LD_ADDR_VAR 0 4
28437: PUSH
28438: LD_INT 0
28440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28441: LD_INT 35
28443: PPUSH
28444: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
28448: LD_EXP 89
28452: PPUSH
28453: LD_INT 215
28455: PPUSH
28456: LD_INT 100
28458: PPUSH
28459: CALL_OW 297
28463: PUSH
28464: LD_INT 10
28466: LESS
28467: PUSH
28468: LD_VAR 0 4
28472: NOT
28473: AND
28474: IFFALSE 28496
// begin omarOnMotherLode := true ;
28476: LD_ADDR_VAR 0 4
28480: PUSH
28481: LD_INT 1
28483: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
28484: LD_EXP 36
28488: PPUSH
28489: LD_STRING D19b-JMM-1
28491: PPUSH
28492: CALL_OW 88
// end ; until IsDead ( Omar ) ;
28496: LD_EXP 89
28500: PPUSH
28501: CALL_OW 301
28505: IFFALSE 28441
// Say ( JMM , D19a-JMM-1 ) ;
28507: LD_EXP 36
28511: PPUSH
28512: LD_STRING D19a-JMM-1
28514: PPUSH
28515: CALL_OW 88
// if Heike then
28519: LD_EXP 90
28523: IFFALSE 28537
// Say ( Heike , D19a-Hke-1 ) ;
28525: LD_EXP 90
28529: PPUSH
28530: LD_STRING D19a-Hke-1
28532: PPUSH
28533: CALL_OW 88
// end ;
28537: PPOPN 4
28539: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
28540: LD_INT 22
28542: PUSH
28543: LD_INT 3
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 21
28552: PUSH
28553: LD_INT 1
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: EMPTY
28561: LIST
28562: LIST
28563: PPUSH
28564: CALL_OW 69
28568: PUSH
28569: LD_EXP 21
28573: AND
28574: IFFALSE 28642
28576: GO 28578
28578: DISABLE
28579: LD_INT 0
28581: PPUSH
28582: PPUSH
// begin enable ;
28583: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
28584: LD_ADDR_VAR 0 2
28588: PUSH
28589: LD_INT 25
28591: PPUSH
28592: LD_INT 22
28594: PUSH
28595: LD_INT 3
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PPUSH
28602: CALL_OW 70
28606: ST_TO_ADDR
// if not tmp then
28607: LD_VAR 0 2
28611: NOT
28612: IFFALSE 28616
// exit ;
28614: GO 28642
// for i in tmp do
28616: LD_ADDR_VAR 0 1
28620: PUSH
28621: LD_VAR 0 2
28625: PUSH
28626: FOR_IN
28627: IFFALSE 28640
// RemoveUnit ( i ) ;
28629: LD_VAR 0 1
28633: PPUSH
28634: CALL_OW 64
28638: GO 28626
28640: POP
28641: POP
// end ;
28642: PPOPN 2
28644: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
28645: LD_INT 22
28647: PUSH
28648: LD_INT 7
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PUSH
28655: LD_INT 21
28657: PUSH
28658: LD_INT 1
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PPUSH
28669: CALL_OW 69
28673: PUSH
28674: LD_INT 6
28676: LESS
28677: IFFALSE 29128
28679: GO 28681
28681: DISABLE
28682: LD_INT 0
28684: PPUSH
28685: PPUSH
// begin MC_Kill ( 1 ) ;
28686: LD_INT 1
28688: PPUSH
28689: CALL 32997 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
28693: LD_INT 7
28695: PPUSH
28696: LD_INT 1
28698: PPUSH
28699: LD_INT 1
28701: PPUSH
28702: LD_INT 1
28704: PPUSH
28705: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
28709: LD_ADDR_VAR 0 1
28713: PUSH
28714: LD_INT 22
28716: PUSH
28717: LD_INT 7
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 26
28726: PUSH
28727: LD_INT 1
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: PPUSH
28738: CALL_OW 69
28742: PUSH
28743: LD_EXP 71
28747: DIFF
28748: ST_TO_ADDR
// if tmp then
28749: LD_VAR 0 1
28753: IFFALSE 28771
// tmp := tmp [ 1 ] else
28755: LD_ADDR_VAR 0 1
28759: PUSH
28760: LD_VAR 0 1
28764: PUSH
28765: LD_INT 1
28767: ARRAY
28768: ST_TO_ADDR
28769: GO 28807
// begin uc_side := 7 ;
28771: LD_ADDR_OWVAR 20
28775: PUSH
28776: LD_INT 7
28778: ST_TO_ADDR
// uc_nation := 1 ;
28779: LD_ADDR_OWVAR 21
28783: PUSH
28784: LD_INT 1
28786: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
28787: LD_INT 1
28789: PPUSH
28790: LD_INT 8
28792: PPUSH
28793: CALL_OW 384
// tmp := CreateHuman ;
28797: LD_ADDR_VAR 0 1
28801: PUSH
28802: CALL_OW 44
28806: ST_TO_ADDR
// end ; DialogueOn ;
28807: CALL_OW 6
// if IsOK ( Roth ) then
28811: LD_EXP 71
28815: PPUSH
28816: CALL_OW 302
28820: IFFALSE 28834
// Say ( JMM , DAb-JMM-1 ) ;
28822: LD_EXP 36
28826: PPUSH
28827: LD_STRING DAb-JMM-1
28829: PPUSH
28830: CALL_OW 88
// if IsOK ( Roth ) then
28834: LD_EXP 71
28838: PPUSH
28839: CALL_OW 302
28843: IFFALSE 28867
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
28845: LD_EXP 71
28849: PPUSH
28850: LD_STRING DSurrenderAlliance-Roth-1
28852: PPUSH
28853: CALL_OW 88
// RothCaptured := true ;
28857: LD_ADDR_EXP 33
28861: PUSH
28862: LD_INT 1
28864: ST_TO_ADDR
// end else
28865: GO 28879
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
28867: LD_VAR 0 1
28871: PPUSH
28872: LD_STRING DSurrenderAlliance-Sci1-1
28874: PPUSH
28875: CALL_OW 88
// DialogueOff ;
28879: CALL_OW 7
// allianceDestroyed := true ;
28883: LD_ADDR_EXP 23
28887: PUSH
28888: LD_INT 1
28890: ST_TO_ADDR
// if trueAmericans then
28891: LD_EXP 35
28895: IFFALSE 28971
// begin if trueAmericans = 1 then
28897: LD_EXP 35
28901: PUSH
28902: LD_INT 1
28904: EQUAL
28905: IFFALSE 28921
// Say ( JMM , DAb-JMM-1a ) else
28907: LD_EXP 36
28911: PPUSH
28912: LD_STRING DAb-JMM-1a
28914: PPUSH
28915: CALL_OW 88
28919: GO 28933
// Say ( JMM , DAb-JMM-1b ) ;
28921: LD_EXP 36
28925: PPUSH
28926: LD_STRING DAb-JMM-1b
28928: PPUSH
28929: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
28933: LD_EXP 35
28937: PPUSH
28938: CALL_OW 87
// for i in trueAmericans do
28942: LD_ADDR_VAR 0 2
28946: PUSH
28947: LD_EXP 35
28951: PUSH
28952: FOR_IN
28953: IFFALSE 28969
// SetSide ( i , 1 ) ;
28955: LD_VAR 0 2
28959: PPUSH
28960: LD_INT 1
28962: PPUSH
28963: CALL_OW 235
28967: GO 28952
28969: POP
28970: POP
// end ; repeat wait ( 0 0$1 ) ;
28971: LD_INT 35
28973: PPUSH
28974: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
28978: LD_ADDR_VAR 0 2
28982: PUSH
28983: LD_INT 22
28985: PUSH
28986: LD_INT 7
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: LD_INT 21
28995: PUSH
28996: LD_INT 1
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PPUSH
29007: CALL_OW 69
29011: PUSH
29012: FOR_IN
29013: IFFALSE 29095
// begin if IsInUnit ( i ) then
29015: LD_VAR 0 2
29019: PPUSH
29020: CALL_OW 310
29024: IFFALSE 29035
// ComExitBuilding ( i ) ;
29026: LD_VAR 0 2
29030: PPUSH
29031: CALL_OW 122
// if IsDriver ( i ) then
29035: LD_VAR 0 2
29039: PPUSH
29040: CALL 101011 0 1
29044: IFFALSE 29055
// ComExitVehicle ( i ) ;
29046: LD_VAR 0 2
29050: PPUSH
29051: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29055: LD_VAR 0 2
29059: PPUSH
29060: LD_INT 26
29062: PPUSH
29063: CALL_OW 308
29067: NOT
29068: IFFALSE 29084
// AddComMoveToArea ( i , allianceEscapeArea ) else
29070: LD_VAR 0 2
29074: PPUSH
29075: LD_INT 26
29077: PPUSH
29078: CALL_OW 173
29082: GO 29093
// RemoveUnit ( i ) ;
29084: LD_VAR 0 2
29088: PPUSH
29089: CALL_OW 64
// end ;
29093: GO 29012
29095: POP
29096: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29097: LD_INT 22
29099: PUSH
29100: LD_INT 7
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 21
29109: PUSH
29110: LD_INT 1
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PPUSH
29121: CALL_OW 69
29125: NOT
29126: IFFALSE 28971
// end ;
29128: PPOPN 2
29130: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
29131: LD_INT 0
29133: PPUSH
29134: PPUSH
// if not unit then
29135: LD_VAR 0 1
29139: NOT
29140: IFFALSE 29144
// exit ;
29142: GO 30633
// DoNotAttack ( 8 , unit ) ;
29144: LD_INT 8
29146: PPUSH
29147: LD_VAR 0 1
29151: PPUSH
29152: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
29156: LD_VAR 0 1
29160: PPUSH
29161: LD_INT 260
29163: PPUSH
29164: LD_INT 235
29166: PPUSH
29167: LD_INT 3
29169: PPUSH
29170: LD_INT 1
29172: PPUSH
29173: CALL_OW 483
// SetSide ( unit , 4 ) ;
29177: LD_VAR 0 1
29181: PPUSH
29182: LD_INT 4
29184: PPUSH
29185: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
29189: LD_ADDR_EXP 34
29193: PUSH
29194: LD_EXP 34
29198: PUSH
29199: LD_INT 1
29201: PLUS
29202: ST_TO_ADDR
// wait ( 0 0$2 ) ;
29203: LD_INT 70
29205: PPUSH
29206: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
29210: LD_INT 260
29212: PPUSH
29213: LD_INT 235
29215: PPUSH
29216: LD_INT 1
29218: PPUSH
29219: LD_INT 8
29221: NEG
29222: PPUSH
29223: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
29227: LD_VAR 0 1
29231: PPUSH
29232: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
29236: LD_VAR 0 1
29240: PPUSH
29241: LD_EXP 71
29245: PPUSH
29246: CALL_OW 119
// DialogueOn ;
29250: CALL_OW 6
// case unit of JMM :
29254: LD_VAR 0 1
29258: PUSH
29259: LD_EXP 36
29263: DOUBLE
29264: EQUAL
29265: IFTRUE 29269
29267: GO 29284
29269: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
29270: LD_EXP 36
29274: PPUSH
29275: LD_STRING DA1-JMM-1
29277: PPUSH
29278: CALL_OW 91
29282: GO 29726
29284: LD_EXP 37
29288: DOUBLE
29289: EQUAL
29290: IFTRUE 29294
29292: GO 29309
29294: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
29295: LD_EXP 37
29299: PPUSH
29300: LD_STRING DA1-Joan-1
29302: PPUSH
29303: CALL_OW 91
29307: GO 29726
29309: LD_EXP 39
29313: DOUBLE
29314: EQUAL
29315: IFTRUE 29319
29317: GO 29334
29319: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
29320: LD_EXP 39
29324: PPUSH
29325: LD_STRING DA1-Lisa-1
29327: PPUSH
29328: CALL_OW 91
29332: GO 29726
29334: LD_EXP 40
29338: DOUBLE
29339: EQUAL
29340: IFTRUE 29344
29342: GO 29359
29344: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
29345: LD_EXP 40
29349: PPUSH
29350: LD_STRING DA1-Don-1
29352: PPUSH
29353: CALL_OW 91
29357: GO 29726
29359: LD_EXP 47
29363: DOUBLE
29364: EQUAL
29365: IFTRUE 29369
29367: GO 29384
29369: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
29370: LD_EXP 47
29374: PPUSH
29375: LD_STRING DA1-Corn-1
29377: PPUSH
29378: CALL_OW 91
29382: GO 29726
29384: LD_EXP 43
29388: DOUBLE
29389: EQUAL
29390: IFTRUE 29394
29392: GO 29409
29394: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
29395: LD_EXP 43
29399: PPUSH
29400: LD_STRING DA1-Den-1
29402: PPUSH
29403: CALL_OW 91
29407: GO 29726
29409: LD_EXP 41
29413: DOUBLE
29414: EQUAL
29415: IFTRUE 29419
29417: GO 29434
29419: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
29420: LD_EXP 41
29424: PPUSH
29425: LD_STRING DA1-Bobby-1
29427: PPUSH
29428: CALL_OW 91
29432: GO 29726
29434: LD_EXP 45
29438: DOUBLE
29439: EQUAL
29440: IFTRUE 29444
29442: GO 29459
29444: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
29445: LD_EXP 45
29449: PPUSH
29450: LD_STRING DA1-Glad-1
29452: PPUSH
29453: CALL_OW 91
29457: GO 29726
29459: LD_EXP 42
29463: DOUBLE
29464: EQUAL
29465: IFTRUE 29469
29467: GO 29484
29469: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
29470: LD_EXP 42
29474: PPUSH
29475: LD_STRING DA1-Cyrus-1
29477: PPUSH
29478: CALL_OW 91
29482: GO 29726
29484: LD_EXP 38
29488: DOUBLE
29489: EQUAL
29490: IFTRUE 29494
29492: GO 29509
29494: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
29495: LD_EXP 38
29499: PPUSH
29500: LD_STRING DA1-Huck-1
29502: PPUSH
29503: CALL_OW 91
29507: GO 29726
29509: LD_EXP 52
29513: DOUBLE
29514: EQUAL
29515: IFTRUE 29519
29517: GO 29534
29519: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
29520: LD_EXP 52
29524: PPUSH
29525: LD_STRING DA1-Huck-1
29527: PPUSH
29528: CALL_OW 91
29532: GO 29726
29534: LD_EXP 44
29538: DOUBLE
29539: EQUAL
29540: IFTRUE 29544
29542: GO 29559
29544: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
29545: LD_EXP 44
29549: PPUSH
29550: LD_STRING DA1-Brown-1
29552: PPUSH
29553: CALL_OW 91
29557: GO 29726
29559: LD_EXP 48
29563: DOUBLE
29564: EQUAL
29565: IFTRUE 29569
29567: GO 29584
29569: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
29570: LD_EXP 48
29574: PPUSH
29575: LD_STRING DA1-Gary-1
29577: PPUSH
29578: CALL_OW 91
29582: GO 29726
29584: LD_EXP 51
29588: DOUBLE
29589: EQUAL
29590: IFTRUE 29594
29592: GO 29609
29594: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
29595: LD_EXP 51
29599: PPUSH
29600: LD_STRING DA1-Con-1
29602: PPUSH
29603: CALL_OW 91
29607: GO 29726
29609: LD_EXP 57
29613: DOUBLE
29614: EQUAL
29615: IFTRUE 29619
29617: GO 29634
29619: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
29620: LD_EXP 57
29624: PPUSH
29625: LD_STRING DA1-Kurt-1
29627: PPUSH
29628: CALL_OW 91
29632: GO 29726
29634: LD_EXP 50
29638: DOUBLE
29639: EQUAL
29640: IFTRUE 29644
29642: GO 29659
29644: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
29645: LD_EXP 50
29649: PPUSH
29650: LD_STRING DA1-Yam-1
29652: PPUSH
29653: CALL_OW 91
29657: GO 29726
29659: LD_EXP 49
29663: DOUBLE
29664: EQUAL
29665: IFTRUE 29669
29667: GO 29684
29669: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
29670: LD_EXP 49
29674: PPUSH
29675: LD_STRING DA1-Frank-1
29677: PPUSH
29678: CALL_OW 91
29682: GO 29726
29684: POP
// begin if GetSex ( unit ) = sex_male then
29685: LD_VAR 0 1
29689: PPUSH
29690: CALL_OW 258
29694: PUSH
29695: LD_INT 1
29697: EQUAL
29698: IFFALSE 29714
// ForceSay ( unit , DA1-Sol1-1 ) else
29700: LD_VAR 0 1
29704: PPUSH
29705: LD_STRING DA1-Sol1-1
29707: PPUSH
29708: CALL_OW 91
29712: GO 29726
// ForceSay ( unit , DA1-FSol1-1 ) ;
29714: LD_VAR 0 1
29718: PPUSH
29719: LD_STRING DA1-FSol1-1
29721: PPUSH
29722: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
29726: LD_EXP 71
29730: PPUSH
29731: LD_STRING DA-Roth-1
29733: PPUSH
29734: CALL_OW 88
// if capturedUnit = 1 then
29738: LD_EXP 34
29742: PUSH
29743: LD_INT 1
29745: EQUAL
29746: IFFALSE 29774
// begin Say ( Simms , DA-Sim-1 ) ;
29748: LD_EXP 72
29752: PPUSH
29753: LD_STRING DA-Sim-1
29755: PPUSH
29756: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
29760: LD_EXP 71
29764: PPUSH
29765: LD_STRING DA-Roth-2
29767: PPUSH
29768: CALL_OW 88
// end else
29772: GO 29786
// Say ( Simms , DA-Sim-2 ) ;
29774: LD_EXP 72
29778: PPUSH
29779: LD_STRING DA-Sim-2
29781: PPUSH
29782: CALL_OW 88
// case unit of JMM :
29786: LD_VAR 0 1
29790: PUSH
29791: LD_EXP 36
29795: DOUBLE
29796: EQUAL
29797: IFTRUE 29801
29799: GO 29816
29801: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
29802: LD_EXP 36
29806: PPUSH
29807: LD_STRING DA1-JMM-1a
29809: PPUSH
29810: CALL_OW 91
29814: GO 30323
29816: LD_EXP 37
29820: DOUBLE
29821: EQUAL
29822: IFTRUE 29826
29824: GO 29841
29826: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
29827: LD_EXP 37
29831: PPUSH
29832: LD_STRING DA1-Joan-1a
29834: PPUSH
29835: CALL_OW 91
29839: GO 30323
29841: LD_EXP 39
29845: DOUBLE
29846: EQUAL
29847: IFTRUE 29851
29849: GO 29866
29851: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
29852: LD_EXP 39
29856: PPUSH
29857: LD_STRING DA1-Lisa-1a
29859: PPUSH
29860: CALL_OW 91
29864: GO 30323
29866: LD_EXP 40
29870: DOUBLE
29871: EQUAL
29872: IFTRUE 29876
29874: GO 29891
29876: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
29877: LD_EXP 40
29881: PPUSH
29882: LD_STRING DA1-Don-1a
29884: PPUSH
29885: CALL_OW 91
29889: GO 30323
29891: LD_EXP 47
29895: DOUBLE
29896: EQUAL
29897: IFTRUE 29901
29899: GO 29916
29901: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
29902: LD_EXP 47
29906: PPUSH
29907: LD_STRING DA1-Corn-1a
29909: PPUSH
29910: CALL_OW 91
29914: GO 30323
29916: LD_EXP 43
29920: DOUBLE
29921: EQUAL
29922: IFTRUE 29926
29924: GO 29941
29926: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
29927: LD_EXP 43
29931: PPUSH
29932: LD_STRING DA1-Den-1a
29934: PPUSH
29935: CALL_OW 91
29939: GO 30323
29941: LD_EXP 41
29945: DOUBLE
29946: EQUAL
29947: IFTRUE 29951
29949: GO 29966
29951: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
29952: LD_EXP 41
29956: PPUSH
29957: LD_STRING DA1-Bobby-1a
29959: PPUSH
29960: CALL_OW 91
29964: GO 30323
29966: LD_EXP 45
29970: DOUBLE
29971: EQUAL
29972: IFTRUE 29976
29974: GO 29991
29976: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
29977: LD_EXP 45
29981: PPUSH
29982: LD_STRING DA1-Glad-1a
29984: PPUSH
29985: CALL_OW 91
29989: GO 30323
29991: LD_EXP 42
29995: DOUBLE
29996: EQUAL
29997: IFTRUE 30001
29999: GO 30016
30001: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30002: LD_EXP 42
30006: PPUSH
30007: LD_STRING DA1-Cyrus-1a
30009: PPUSH
30010: CALL_OW 91
30014: GO 30323
30016: LD_EXP 38
30020: DOUBLE
30021: EQUAL
30022: IFTRUE 30026
30024: GO 30041
30026: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30027: LD_EXP 38
30031: PPUSH
30032: LD_STRING DA1-Huck-1a
30034: PPUSH
30035: CALL_OW 91
30039: GO 30323
30041: LD_EXP 52
30045: DOUBLE
30046: EQUAL
30047: IFTRUE 30051
30049: GO 30066
30051: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30052: LD_EXP 52
30056: PPUSH
30057: LD_STRING DA1-Huck-1a
30059: PPUSH
30060: CALL_OW 91
30064: GO 30323
30066: LD_EXP 44
30070: DOUBLE
30071: EQUAL
30072: IFTRUE 30076
30074: GO 30091
30076: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30077: LD_EXP 44
30081: PPUSH
30082: LD_STRING DA1-Brown-1a
30084: PPUSH
30085: CALL_OW 91
30089: GO 30323
30091: LD_EXP 48
30095: DOUBLE
30096: EQUAL
30097: IFTRUE 30101
30099: GO 30116
30101: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
30102: LD_EXP 48
30106: PPUSH
30107: LD_STRING DA1-Gary-1a
30109: PPUSH
30110: CALL_OW 91
30114: GO 30323
30116: LD_EXP 51
30120: DOUBLE
30121: EQUAL
30122: IFTRUE 30126
30124: GO 30141
30126: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
30127: LD_EXP 51
30131: PPUSH
30132: LD_STRING DA1-Con-1a
30134: PPUSH
30135: CALL_OW 91
30139: GO 30323
30141: LD_EXP 57
30145: DOUBLE
30146: EQUAL
30147: IFTRUE 30151
30149: GO 30166
30151: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
30152: LD_EXP 57
30156: PPUSH
30157: LD_STRING DA1-Kurt-1a
30159: PPUSH
30160: CALL_OW 91
30164: GO 30323
30166: LD_EXP 50
30170: DOUBLE
30171: EQUAL
30172: IFTRUE 30176
30174: GO 30191
30176: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
30177: LD_EXP 50
30181: PPUSH
30182: LD_STRING DA1-Yam-1a
30184: PPUSH
30185: CALL_OW 91
30189: GO 30323
30191: LD_EXP 49
30195: DOUBLE
30196: EQUAL
30197: IFTRUE 30201
30199: GO 30216
30201: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
30202: LD_EXP 49
30206: PPUSH
30207: LD_STRING DA1-Frank-1a
30209: PPUSH
30210: CALL_OW 91
30214: GO 30323
30216: POP
// begin join := rand ( 0 , 1 ) ;
30217: LD_ADDR_VAR 0 3
30221: PUSH
30222: LD_INT 0
30224: PPUSH
30225: LD_INT 1
30227: PPUSH
30228: CALL_OW 12
30232: ST_TO_ADDR
// if join then
30233: LD_VAR 0 3
30237: IFFALSE 30282
// begin if GetSex ( unit ) = sex_male then
30239: LD_VAR 0 1
30243: PPUSH
30244: CALL_OW 258
30248: PUSH
30249: LD_INT 1
30251: EQUAL
30252: IFFALSE 30268
// ForceSay ( unit , DA1-Sol1-1b ) else
30254: LD_VAR 0 1
30258: PPUSH
30259: LD_STRING DA1-Sol1-1b
30261: PPUSH
30262: CALL_OW 91
30266: GO 30280
// ForceSay ( unit , DA1-FSol1-1b ) ;
30268: LD_VAR 0 1
30272: PPUSH
30273: LD_STRING DA1-FSol1-1b
30275: PPUSH
30276: CALL_OW 91
// end else
30280: GO 30323
// begin if GetSex ( unit ) = sex_male then
30282: LD_VAR 0 1
30286: PPUSH
30287: CALL_OW 258
30291: PUSH
30292: LD_INT 1
30294: EQUAL
30295: IFFALSE 30311
// ForceSay ( unit , DA1-Sol1-1a ) else
30297: LD_VAR 0 1
30301: PPUSH
30302: LD_STRING DA1-Sol1-1a
30304: PPUSH
30305: CALL_OW 91
30309: GO 30323
// ForceSay ( unit , DA1-FSol1-1a ) ;
30311: LD_VAR 0 1
30315: PPUSH
30316: LD_STRING DA1-FSol1-1a
30318: PPUSH
30319: CALL_OW 91
// end ; end ; end ; if unit = JMM then
30323: LD_VAR 0 1
30327: PUSH
30328: LD_EXP 36
30332: EQUAL
30333: IFFALSE 30344
// begin YouLost ( JMMCaptured ) ;
30335: LD_STRING JMMCaptured
30337: PPUSH
30338: CALL_OW 104
// exit ;
30342: GO 30633
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
30344: LD_VAR 0 1
30348: PUSH
30349: LD_EXP 40
30353: PUSH
30354: LD_EXP 43
30358: PUSH
30359: LD_EXP 41
30363: PUSH
30364: LD_EXP 38
30368: PUSH
30369: LD_EXP 52
30373: PUSH
30374: LD_EXP 44
30378: PUSH
30379: LD_EXP 50
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: IN
30393: PUSH
30394: LD_VAR 0 3
30398: OR
30399: IFFALSE 30489
// begin Say ( Roth , DA-Roth-3 ) ;
30401: LD_EXP 71
30405: PPUSH
30406: LD_STRING DA-Roth-3
30408: PPUSH
30409: CALL_OW 88
// SetSide ( unit , 7 ) ;
30413: LD_VAR 0 1
30417: PPUSH
30418: LD_INT 7
30420: PPUSH
30421: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] union unit ) ;
30425: LD_ADDR_EXP 99
30429: PUSH
30430: LD_EXP 99
30434: PPUSH
30435: LD_INT 1
30437: PPUSH
30438: LD_EXP 99
30442: PUSH
30443: LD_INT 1
30445: ARRAY
30446: PUSH
30447: LD_VAR 0 1
30451: UNION
30452: PPUSH
30453: CALL_OW 1
30457: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
30458: LD_INT 260
30460: PPUSH
30461: LD_INT 235
30463: PPUSH
30464: LD_INT 1
30466: PPUSH
30467: CALL_OW 331
// SetLives ( unit , 1000 ) ;
30471: LD_VAR 0 1
30475: PPUSH
30476: LD_INT 1000
30478: PPUSH
30479: CALL_OW 234
// DialogueOff ;
30483: CALL_OW 7
// end else
30487: GO 30570
// begin Say ( Roth , DA-Roth-3a ) ;
30489: LD_EXP 71
30493: PPUSH
30494: LD_STRING DA-Roth-3a
30496: PPUSH
30497: CALL_OW 88
// trueAmericans := trueAmericans union unit ;
30501: LD_ADDR_EXP 35
30505: PUSH
30506: LD_EXP 35
30510: PUSH
30511: LD_VAR 0 1
30515: UNION
30516: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
30517: LD_INT 260
30519: PPUSH
30520: LD_INT 235
30522: PPUSH
30523: LD_INT 1
30525: PPUSH
30526: CALL_OW 331
// SetLives ( unit , 1000 ) ;
30530: LD_VAR 0 1
30534: PPUSH
30535: LD_INT 1000
30537: PPUSH
30538: CALL_OW 234
// DialogueOff ;
30542: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
30546: LD_VAR 0 1
30550: PPUSH
30551: LD_INT 272
30553: PPUSH
30554: LD_INT 254
30556: PPUSH
30557: CALL_OW 111
// AddComHold ( unit ) ;
30561: LD_VAR 0 1
30565: PPUSH
30566: CALL_OW 200
// end ; if capturedUnit = 1 then
30570: LD_EXP 34
30574: PUSH
30575: LD_INT 1
30577: EQUAL
30578: IFFALSE 30633
// begin DialogueOn ;
30580: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
30584: LD_EXP 36
30588: PPUSH
30589: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
30593: LD_EXP 36
30597: PPUSH
30598: LD_STRING DAa-JMM-1
30600: PPUSH
30601: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
30605: LD_EXP 36
30609: PPUSH
30610: LD_STRING DAa-JMM-1a
30612: PPUSH
30613: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
30617: LD_EXP 36
30621: PPUSH
30622: LD_STRING DAa-JMM-1b
30624: PPUSH
30625: CALL_OW 88
// DialogueOff ;
30629: CALL_OW 7
// end ; end ;
30633: LD_VAR 0 2
30637: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
30638: LD_EXP 15
30642: PUSH
30643: LD_INT 13
30645: GREATEREQUAL
30646: PUSH
30647: LD_INT 22
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 21
30659: PUSH
30660: LD_INT 1
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PPUSH
30671: CALL_OW 69
30675: PUSH
30676: LD_INT 0
30678: EQUAL
30679: AND
30680: PUSH
30681: LD_INT 22
30683: PUSH
30684: LD_INT 2
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 21
30693: PUSH
30694: LD_INT 2
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 50
30703: PUSH
30704: EMPTY
30705: LIST
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: LIST
30711: PPUSH
30712: CALL_OW 69
30716: PUSH
30717: LD_INT 0
30719: EQUAL
30720: AND
30721: PUSH
30722: LD_EXP 21
30726: AND
30727: PUSH
30728: LD_EXP 22
30732: AND
30733: PUSH
30734: LD_EXP 23
30738: AND
30739: IFFALSE 31220
30741: GO 30743
30743: DISABLE
// begin DialogueOn ;
30744: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
30748: LD_EXP 36
30752: PPUSH
30753: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
30757: LD_EXP 36
30761: PPUSH
30762: LD_STRING D20-JMM-1
30764: PPUSH
30765: CALL_OW 88
// if IsOK ( Joan ) then
30769: LD_EXP 37
30773: PPUSH
30774: CALL_OW 302
30778: IFFALSE 30792
// Say ( Joan , D20-Joan-1 ) ;
30780: LD_EXP 37
30784: PPUSH
30785: LD_STRING D20-Joan-1
30787: PPUSH
30788: CALL_OW 88
// if IsOk ( Lisa ) then
30792: LD_EXP 39
30796: PPUSH
30797: CALL_OW 302
30801: IFFALSE 30815
// Say ( Lisa , D20-Lisa-1 ) ;
30803: LD_EXP 39
30807: PPUSH
30808: LD_STRING D20-Lisa-1
30810: PPUSH
30811: CALL_OW 88
// if IsOk ( Donaldson ) then
30815: LD_EXP 40
30819: PPUSH
30820: CALL_OW 302
30824: IFFALSE 30838
// Say ( Donaldson , D20-Don-1 ) ;
30826: LD_EXP 40
30830: PPUSH
30831: LD_STRING D20-Don-1
30833: PPUSH
30834: CALL_OW 88
// if IsOK ( Cornel ) then
30838: LD_EXP 47
30842: PPUSH
30843: CALL_OW 302
30847: IFFALSE 30861
// Say ( Cornel , D20-Corn-1 ) ;
30849: LD_EXP 47
30853: PPUSH
30854: LD_STRING D20-Corn-1
30856: PPUSH
30857: CALL_OW 88
// if IsOk ( Denis ) then
30861: LD_EXP 43
30865: PPUSH
30866: CALL_OW 302
30870: IFFALSE 30884
// Say ( Denis , D20-Den-1 ) ;
30872: LD_EXP 43
30876: PPUSH
30877: LD_STRING D20-Den-1
30879: PPUSH
30880: CALL_OW 88
// if IsOk ( Bobby ) then
30884: LD_EXP 41
30888: PPUSH
30889: CALL_OW 302
30893: IFFALSE 30907
// Say ( Bobby , D20-Bobby-1 ) ;
30895: LD_EXP 41
30899: PPUSH
30900: LD_STRING D20-Bobby-1
30902: PPUSH
30903: CALL_OW 88
// if IsOk ( Gladstone ) then
30907: LD_EXP 45
30911: PPUSH
30912: CALL_OW 302
30916: IFFALSE 30930
// Say ( Gladstone , D20-Glad-1 ) ;
30918: LD_EXP 45
30922: PPUSH
30923: LD_STRING D20-Glad-1
30925: PPUSH
30926: CALL_OW 88
// if IsOk ( Cyrus ) then
30930: LD_EXP 42
30934: PPUSH
30935: CALL_OW 302
30939: IFFALSE 30953
// Say ( Cyrus , D20-Cyrus-1 ) ;
30941: LD_EXP 42
30945: PPUSH
30946: LD_STRING D20-Cyrus-1
30948: PPUSH
30949: CALL_OW 88
// if IsOk ( Stevens ) then
30953: LD_EXP 38
30957: PPUSH
30958: CALL_OW 302
30962: IFFALSE 30976
// Say ( Stevens , D20-Huck-1 ) ;
30964: LD_EXP 38
30968: PPUSH
30969: LD_STRING D20-Huck-1
30971: PPUSH
30972: CALL_OW 88
// if IsOk ( Brown ) then
30976: LD_EXP 44
30980: PPUSH
30981: CALL_OW 302
30985: IFFALSE 30999
// Say ( Brown , D20-Brown-1 ) ;
30987: LD_EXP 44
30991: PPUSH
30992: LD_STRING D20-Brown-1
30994: PPUSH
30995: CALL_OW 88
// if IsOk ( Gary ) then
30999: LD_EXP 48
31003: PPUSH
31004: CALL_OW 302
31008: IFFALSE 31022
// Say ( Gary , D20-Gary-1 ) ;
31010: LD_EXP 48
31014: PPUSH
31015: LD_STRING D20-Gary-1
31017: PPUSH
31018: CALL_OW 88
// if IsOk ( Connie ) then
31022: LD_EXP 51
31026: PPUSH
31027: CALL_OW 302
31031: IFFALSE 31045
// Say ( Connie , D20-Con-1 ) ;
31033: LD_EXP 51
31037: PPUSH
31038: LD_STRING D20-Con-1
31040: PPUSH
31041: CALL_OW 88
// if IsOk ( Kurt ) then
31045: LD_EXP 57
31049: PPUSH
31050: CALL_OW 302
31054: IFFALSE 31068
// Say ( Kurt , D20-Kurt-1 ) ;
31056: LD_EXP 57
31060: PPUSH
31061: LD_STRING D20-Kurt-1
31063: PPUSH
31064: CALL_OW 88
// if IsOk ( Kikuchi ) then
31068: LD_EXP 50
31072: PPUSH
31073: CALL_OW 302
31077: IFFALSE 31091
// Say ( Kikuchi , D20-Yam-1 ) ;
31079: LD_EXP 50
31083: PPUSH
31084: LD_STRING D20-Yam-1
31086: PPUSH
31087: CALL_OW 88
// if IsOk ( Frank ) then
31091: LD_EXP 49
31095: PPUSH
31096: CALL_OW 302
31100: IFFALSE 31114
// Say ( Frank , D20-Frank-1 ) ;
31102: LD_EXP 49
31106: PPUSH
31107: LD_STRING D20-Frank-1
31109: PPUSH
31110: CALL_OW 88
// DialogueOff ;
31114: CALL_OW 7
// if RothCaptured then
31118: LD_EXP 33
31122: IFFALSE 31136
// AddMedal ( Roth , 1 ) else
31124: LD_STRING Roth
31126: PPUSH
31127: LD_INT 1
31129: PPUSH
31130: CALL_OW 101
31134: GO 31147
// AddMedal ( Roth , - 1 ) ;
31136: LD_STRING Roth
31138: PPUSH
31139: LD_INT 1
31141: NEG
31142: PPUSH
31143: CALL_OW 101
// if behemothDestroyedBeforeFinish then
31147: LD_EXP 27
31151: IFFALSE 31165
// AddMedal ( Project , 1 ) else
31153: LD_STRING Project
31155: PPUSH
31156: LD_INT 1
31158: PPUSH
31159: CALL_OW 101
31163: GO 31176
// AddMedal ( Project , - 1 ) ;
31165: LD_STRING Project
31167: PPUSH
31168: LD_INT 1
31170: NEG
31171: PPUSH
31172: CALL_OW 101
// if lostCounter = 0 then
31176: LD_EXP 32
31180: PUSH
31181: LD_INT 0
31183: EQUAL
31184: IFFALSE 31198
// AddMedal ( NoLosses , 1 ) else
31186: LD_STRING NoLosses
31188: PPUSH
31189: LD_INT 1
31191: PPUSH
31192: CALL_OW 101
31196: GO 31209
// AddMedal ( NoLosses , - 1 ) ;
31198: LD_STRING NoLosses
31200: PPUSH
31201: LD_INT 1
31203: NEG
31204: PPUSH
31205: CALL_OW 101
// GiveMedals ( MAIN ) ;
31209: LD_STRING MAIN
31211: PPUSH
31212: CALL_OW 102
// YouWin ;
31216: CALL_OW 103
// end ; end_of_file
31220: END
// export function CustomEvent ( event ) ; begin
31221: LD_INT 0
31223: PPUSH
// end ;
31224: LD_VAR 0 2
31228: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
31229: LD_VAR 0 1
31233: PUSH
31234: LD_INT 1
31236: EQUAL
31237: PUSH
31238: LD_VAR 0 2
31242: PUSH
31243: LD_INT 4
31245: EQUAL
31246: AND
31247: PUSH
31248: LD_EXP 55
31252: PPUSH
31253: CALL_OW 300
31257: AND
31258: IFFALSE 31274
// begin wait ( 0 0$2 ) ;
31260: LD_INT 70
31262: PPUSH
31263: CALL_OW 67
// YouLost ( Dismissed ) ;
31267: LD_STRING Dismissed
31269: PPUSH
31270: CALL_OW 104
// end ; end ;
31274: PPOPN 2
31276: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
31277: LD_VAR 0 2
31281: PPUSH
31282: LD_VAR 0 3
31286: PPUSH
31287: LD_INT 18
31289: PPUSH
31290: CALL_OW 309
31294: IFFALSE 31303
// YouLost ( Motherlode3 ) ;
31296: LD_STRING Motherlode3
31298: PPUSH
31299: CALL_OW 104
// end ;
31303: PPOPN 3
31305: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
31306: LD_EXP 27
31310: NOT
31311: IFFALSE 31321
// behemothDone := true ;
31313: LD_ADDR_EXP 28
31317: PUSH
31318: LD_INT 1
31320: ST_TO_ADDR
// end ;
31321: PPOPN 1
31323: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31324: LD_VAR 0 1
31328: PPUSH
31329: CALL_OW 255
31333: PUSH
31334: LD_INT 1
31336: EQUAL
31337: PUSH
31338: LD_EXP 30
31342: AND
31343: PUSH
31344: LD_INT 22
31346: PUSH
31347: LD_INT 3
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 34
31356: PUSH
31357: LD_INT 48
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PPUSH
31368: CALL_OW 69
31372: AND
31373: PUSH
31374: LD_INT 22
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 34
31386: PUSH
31387: LD_INT 8
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PPUSH
31398: CALL_OW 69
31402: NOT
31403: AND
31404: IFFALSE 31456
// begin wait ( 0 0$5 ) ;
31406: LD_INT 175
31408: PPUSH
31409: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
31413: LD_INT 22
31415: PUSH
31416: LD_INT 3
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 34
31425: PUSH
31426: LD_INT 48
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PPUSH
31437: CALL_OW 69
31441: PUSH
31442: LD_INT 1
31444: ARRAY
31445: PPUSH
31446: LD_INT 60
31448: PPUSH
31449: LD_INT 95
31451: PPUSH
31452: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
31456: LD_VAR 0 2
31460: PPUSH
31461: LD_VAR 0 3
31465: PPUSH
31466: LD_INT 18
31468: PPUSH
31469: CALL_OW 309
31473: IFFALSE 31533
// begin if GetSide ( unit ) = 1 then
31475: LD_VAR 0 1
31479: PPUSH
31480: CALL_OW 255
31484: PUSH
31485: LD_INT 1
31487: EQUAL
31488: IFFALSE 31504
// begin wait ( 0 0$6 ) ;
31490: LD_INT 210
31492: PPUSH
31493: CALL_OW 67
// YouLost ( Motherlode2 ) ;
31497: LD_STRING Motherlode2
31499: PPUSH
31500: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
31504: LD_VAR 0 1
31508: PPUSH
31509: CALL_OW 255
31513: PUSH
31514: LD_INT 8
31516: EQUAL
31517: IFFALSE 31533
// begin wait ( 0 0$6 ) ;
31519: LD_INT 210
31521: PPUSH
31522: CALL_OW 67
// YouLost ( Motherlode1 ) ;
31526: LD_STRING Motherlode1
31528: PPUSH
31529: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
31533: LD_VAR 0 1
31537: PPUSH
31538: CALL_OW 255
31542: PUSH
31543: LD_INT 3
31545: EQUAL
31546: IFFALSE 31567
// begin wait ( 0 0$5 ) ;
31548: LD_INT 175
31550: PPUSH
31551: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
31555: LD_EXP 61
31559: PPUSH
31560: LD_STRING D18-Pla-1
31562: PPUSH
31563: CALL_OW 94
// end ; end ;
31567: PPOPN 3
31569: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
31570: LD_VAR 0 1
31574: PUSH
31575: LD_EXP 70
31579: IN
31580: IFFALSE 31600
// begin behemothBuilders := behemothBuilders diff un ;
31582: LD_ADDR_EXP 70
31586: PUSH
31587: LD_EXP 70
31591: PUSH
31592: LD_VAR 0 1
31596: DIFF
31597: ST_TO_ADDR
// exit ;
31598: GO 31698
// end ; if un = JMM then
31600: LD_VAR 0 1
31604: PUSH
31605: LD_EXP 36
31609: EQUAL
31610: IFFALSE 31621
// begin YouLost ( JMM ) ;
31612: LD_STRING JMM
31614: PPUSH
31615: CALL_OW 104
// exit ;
31619: GO 31698
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
31621: LD_VAR 0 1
31625: PUSH
31626: LD_INT 22
31628: PUSH
31629: LD_INT 1
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 3
31638: PUSH
31639: LD_INT 25
31641: PUSH
31642: LD_INT 16
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 25
31651: PUSH
31652: LD_INT 12
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: LIST
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PPUSH
31668: CALL_OW 69
31672: IN
31673: IFFALSE 31689
// lostCounter := lostCounter + 1 ;
31675: LD_ADDR_EXP 32
31679: PUSH
31680: LD_EXP 32
31684: PUSH
31685: LD_INT 1
31687: PLUS
31688: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
31689: LD_VAR 0 1
31693: PPUSH
31694: CALL 58447 0 1
// end ;
31698: PPOPN 1
31700: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
31701: LD_VAR 0 1
31705: PPUSH
31706: LD_VAR 0 2
31710: PPUSH
31711: CALL 60353 0 2
// end ;
31715: PPOPN 2
31717: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
31718: LD_VAR 0 1
31722: PPUSH
31723: CALL 59421 0 1
// end ;
31727: PPOPN 1
31729: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
31730: LD_VAR 0 1
31734: PUSH
31735: LD_INT 22
31737: PUSH
31738: LD_INT 8
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 30
31747: PUSH
31748: LD_INT 2
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 23
31757: PUSH
31758: LD_INT 3
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: LIST
31769: PPUSH
31770: CALL_OW 69
31774: IN
31775: IFFALSE 31802
// begin ComUpgrade ( building ) ;
31777: LD_VAR 0 1
31781: PPUSH
31782: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
31786: LD_EXP 58
31790: PPUSH
31791: LD_VAR 0 1
31795: PPUSH
31796: CALL 70577 0 2
// exit ;
31800: GO 31811
// end ; MCE_BuildingComplete ( building ) ;
31802: LD_VAR 0 1
31806: PPUSH
31807: CALL 59662 0 1
// end ;
31811: PPOPN 1
31813: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
31814: LD_VAR 0 1
31818: PPUSH
31819: LD_VAR 0 2
31823: PPUSH
31824: CALL 58143 0 2
// end ;
31828: PPOPN 2
31830: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
31831: LD_VAR 0 1
31835: PPUSH
31836: LD_VAR 0 2
31840: PPUSH
31841: LD_VAR 0 3
31845: PPUSH
31846: LD_VAR 0 4
31850: PPUSH
31851: LD_VAR 0 5
31855: PPUSH
31856: CALL 57763 0 5
// end ;
31860: PPOPN 5
31862: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
31863: LD_VAR 0 1
31867: PPUSH
31868: LD_VAR 0 2
31872: PPUSH
31873: CALL 57353 0 2
// end ;
31877: PPOPN 2
31879: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
31880: LD_VAR 0 1
31884: PPUSH
31885: LD_VAR 0 2
31889: PPUSH
31890: LD_VAR 0 3
31894: PPUSH
31895: LD_VAR 0 4
31899: PPUSH
31900: CALL 57191 0 4
// end ;
31904: PPOPN 4
31906: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
31907: LD_VAR 0 1
31911: PPUSH
31912: LD_VAR 0 2
31916: PPUSH
31917: LD_VAR 0 3
31921: PPUSH
31922: CALL 56966 0 3
// end ;
31926: PPOPN 3
31928: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
31929: LD_VAR 0 1
31933: PPUSH
31934: LD_VAR 0 2
31938: PPUSH
31939: CALL 56851 0 2
// end ;
31943: PPOPN 2
31945: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
31946: LD_VAR 0 1
31950: PPUSH
31951: LD_VAR 0 2
31955: PPUSH
31956: CALL 60614 0 2
// end ;
31960: PPOPN 2
31962: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
31963: LD_VAR 0 1
31967: PPUSH
31968: CALL_OW 255
31972: PUSH
31973: LD_INT 4
31975: EQUAL
31976: PUSH
31977: LD_VAR 0 1
31981: PUSH
31982: LD_EXP 18
31986: PUSH
31987: LD_INT 1
31989: ARRAY
31990: IN
31991: AND
31992: PUSH
31993: LD_EXP 19
31997: AND
31998: IFFALSE 32017
// begin ComMoveXY ( driver , 61 , 93 ) ;
32000: LD_VAR 0 1
32004: PPUSH
32005: LD_INT 61
32007: PPUSH
32008: LD_INT 93
32010: PPUSH
32011: CALL_OW 111
// exit ;
32015: GO 32041
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32017: LD_VAR 0 1
32021: PPUSH
32022: LD_VAR 0 2
32026: PPUSH
32027: LD_VAR 0 3
32031: PPUSH
32032: LD_VAR 0 4
32036: PPUSH
32037: CALL 60830 0 4
// end ;
32041: PPOPN 4
32043: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32044: LD_VAR 0 1
32048: PPUSH
32049: LD_VAR 0 2
32053: PPUSH
32054: CALL 56660 0 2
// end ; end_of_file
32058: PPOPN 2
32060: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32061: LD_EXP 15
32065: PUSH
32066: LD_INT 2
32068: EQUAL
32069: IFFALSE 32531
32071: GO 32073
32073: DISABLE
32074: LD_INT 0
32076: PPUSH
// begin time := 0 0$40 ;
32077: LD_ADDR_VAR 0 1
32081: PUSH
32082: LD_INT 1400
32084: ST_TO_ADDR
// repeat wait ( time ) ;
32085: LD_VAR 0 1
32089: PPUSH
32090: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
32094: LD_INT 1
32096: PPUSH
32097: LD_INT 5
32099: PPUSH
32100: CALL_OW 12
32104: PPUSH
32105: LD_INT 106
32107: PPUSH
32108: LD_INT 150
32110: PPUSH
32111: LD_INT 19
32113: PPUSH
32114: LD_INT 1
32116: PPUSH
32117: CALL_OW 56
// time := time + 0 0$9 ;
32121: LD_ADDR_VAR 0 1
32125: PUSH
32126: LD_VAR 0 1
32130: PUSH
32131: LD_INT 315
32133: PLUS
32134: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$21 ) ) ;
32135: LD_INT 455
32137: PPUSH
32138: LD_INT 735
32140: PPUSH
32141: CALL_OW 12
32145: PPUSH
32146: CALL_OW 67
// if Prob ( 50 ) then
32150: LD_INT 50
32152: PPUSH
32153: CALL_OW 13
32157: IFFALSE 32186
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
32159: LD_INT 1
32161: PPUSH
32162: LD_INT 5
32164: PPUSH
32165: CALL_OW 12
32169: PPUSH
32170: LD_INT 62
32172: PPUSH
32173: LD_INT 108
32175: PPUSH
32176: LD_INT 10
32178: PPUSH
32179: LD_INT 1
32181: PPUSH
32182: CALL_OW 56
// until missionStage > 4 ;
32186: LD_EXP 15
32190: PUSH
32191: LD_INT 4
32193: GREATER
32194: IFFALSE 32085
// repeat wait ( 0 0$1 ) ;
32196: LD_INT 35
32198: PPUSH
32199: CALL_OW 67
// until missionStage = 6 ;
32203: LD_EXP 15
32207: PUSH
32208: LD_INT 6
32210: EQUAL
32211: IFFALSE 32196
// time := 0 0$50 ;
32213: LD_ADDR_VAR 0 1
32217: PUSH
32218: LD_INT 1750
32220: ST_TO_ADDR
// repeat wait ( time ) ;
32221: LD_VAR 0 1
32225: PPUSH
32226: CALL_OW 67
// if Prob ( 50 ) then
32230: LD_INT 50
32232: PPUSH
32233: CALL_OW 13
32237: IFFALSE 32266
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
32239: LD_INT 1
32241: PPUSH
32242: LD_INT 5
32244: PPUSH
32245: CALL_OW 12
32249: PPUSH
32250: LD_INT 106
32252: PPUSH
32253: LD_INT 89
32255: PPUSH
32256: LD_INT 45
32258: PPUSH
32259: LD_INT 1
32261: PPUSH
32262: CALL_OW 56
// time := time + 0 0$3 ;
32266: LD_ADDR_VAR 0 1
32270: PUSH
32271: LD_VAR 0 1
32275: PUSH
32276: LD_INT 105
32278: PLUS
32279: ST_TO_ADDR
// if Prob ( 30 ) then
32280: LD_INT 30
32282: PPUSH
32283: CALL_OW 13
32287: IFFALSE 32333
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
32289: LD_INT 525
32291: PPUSH
32292: LD_INT 735
32294: PPUSH
32295: CALL_OW 12
32299: PPUSH
32300: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
32304: LD_INT 1
32306: PPUSH
32307: LD_INT 5
32309: PPUSH
32310: CALL_OW 12
32314: PPUSH
32315: LD_INT 21
32317: PPUSH
32318: LD_INT 26
32320: PPUSH
32321: LD_INT 12
32323: PPUSH
32324: LD_INT 1
32326: PPUSH
32327: CALL_OW 56
// end else
32331: GO 32369
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
32333: LD_INT 700
32335: PPUSH
32336: LD_INT 1225
32338: PPUSH
32339: CALL_OW 12
32343: PPUSH
32344: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
32348: LD_INT 1
32350: PPUSH
32351: LD_INT 5
32353: PPUSH
32354: CALL_OW 12
32358: PPUSH
32359: LD_INT 16
32361: PPUSH
32362: LD_INT 1
32364: PPUSH
32365: CALL_OW 55
// end ; if Prob ( 50 ) then
32369: LD_INT 50
32371: PPUSH
32372: CALL_OW 13
32376: IFFALSE 32422
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
32378: LD_INT 700
32380: PPUSH
32381: LD_INT 1050
32383: PPUSH
32384: CALL_OW 12
32388: PPUSH
32389: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
32393: LD_INT 1
32395: PPUSH
32396: LD_INT 5
32398: PPUSH
32399: CALL_OW 12
32403: PPUSH
32404: LD_INT 181
32406: PPUSH
32407: LD_INT 218
32409: PPUSH
32410: LD_INT 16
32412: PPUSH
32413: LD_INT 1
32415: PPUSH
32416: CALL_OW 56
// end else
32420: GO 32458
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
32422: LD_INT 350
32424: PPUSH
32425: LD_INT 525
32427: PPUSH
32428: CALL_OW 12
32432: PPUSH
32433: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
32437: LD_INT 1
32439: PPUSH
32440: LD_INT 5
32442: PPUSH
32443: CALL_OW 12
32447: PPUSH
32448: LD_INT 15
32450: PPUSH
32451: LD_INT 1
32453: PPUSH
32454: CALL_OW 55
// end ; if Prob ( 45 ) then
32458: LD_INT 45
32460: PPUSH
32461: CALL_OW 13
32465: IFFALSE 32509
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
32467: LD_INT 525
32469: PPUSH
32470: LD_INT 875
32472: PPUSH
32473: CALL_OW 12
32477: PPUSH
32478: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
32482: LD_INT 1
32484: PPUSH
32485: LD_INT 5
32487: PPUSH
32488: CALL_OW 12
32492: PPUSH
32493: LD_INT 103
32495: PPUSH
32496: LD_INT 140
32498: PPUSH
32499: LD_INT 20
32501: PPUSH
32502: LD_INT 1
32504: PPUSH
32505: CALL_OW 56
// end ; if time > 2 2$20 then
32509: LD_VAR 0 1
32513: PUSH
32514: LD_INT 4900
32516: GREATER
32517: IFFALSE 32527
// time := 0 0$50 ;
32519: LD_ADDR_VAR 0 1
32523: PUSH
32524: LD_INT 1750
32526: ST_TO_ADDR
// until false ;
32527: LD_INT 0
32529: IFFALSE 32221
// end ; end_of_file
32531: PPOPN 1
32533: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
32534: LD_EXP 13
32538: PUSH
32539: LD_EXP 15
32543: PUSH
32544: LD_INT 6
32546: GREATEREQUAL
32547: AND
32548: IFFALSE 32585
32550: GO 32552
32552: DISABLE
// begin enable ;
32553: ENABLE
// missionTime := missionTime + 0 0$1 ;
32554: LD_ADDR_EXP 14
32558: PUSH
32559: LD_EXP 14
32563: PUSH
32564: LD_INT 35
32566: PLUS
32567: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
32568: LD_ADDR_OWVAR 47
32572: PUSH
32573: LD_STRING #Am15-1
32575: PUSH
32576: LD_EXP 14
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: ST_TO_ADDR
// end ; end_of_file
32585: END
// export function InitNature ; begin
32586: LD_INT 0
32588: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
32589: LD_INT 3
32591: PPUSH
32592: LD_INT 3
32594: PPUSH
32595: LD_INT 2
32597: PPUSH
32598: LD_INT 1
32600: PPUSH
32601: LD_INT 1
32603: PPUSH
32604: LD_INT 0
32606: PPUSH
32607: LD_INT 0
32609: PPUSH
32610: LD_INT 20
32612: PPUSH
32613: LD_INT 0
32615: PPUSH
32616: CALL 95394 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
32620: LD_INT 2
32622: PPUSH
32623: LD_INT 1
32625: PPUSH
32626: LD_INT 1
32628: PPUSH
32629: LD_INT 1
32631: PPUSH
32632: LD_INT 1
32634: PPUSH
32635: LD_INT 0
32637: PPUSH
32638: LD_INT 0
32640: PPUSH
32641: LD_INT 21
32643: PPUSH
32644: LD_INT 0
32646: PPUSH
32647: CALL 95394 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
32651: LD_INT 4
32653: PPUSH
32654: LD_INT 1
32656: PPUSH
32657: LD_INT 2
32659: PPUSH
32660: LD_INT 4
32662: PPUSH
32663: LD_INT 2
32665: PPUSH
32666: LD_INT 1
32668: PPUSH
32669: LD_INT 0
32671: PPUSH
32672: LD_INT 22
32674: PPUSH
32675: LD_INT 0
32677: PPUSH
32678: CALL 95394 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
32682: LD_INT 0
32684: PPUSH
32685: LD_INT 0
32687: PPUSH
32688: LD_INT 0
32690: PPUSH
32691: LD_INT 0
32693: PPUSH
32694: LD_INT 0
32696: PPUSH
32697: LD_INT 0
32699: PPUSH
32700: LD_INT 9
32702: PPUSH
32703: LD_INT 0
32705: PPUSH
32706: LD_INT 23
32708: PPUSH
32709: CALL 95394 0 9
// end ; end_of_file
32713: LD_VAR 0 1
32717: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
32718: GO 32720
32720: DISABLE
// begin ru_radar := 98 ;
32721: LD_ADDR_EXP 92
32725: PUSH
32726: LD_INT 98
32728: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
32729: LD_ADDR_EXP 93
32733: PUSH
32734: LD_INT 89
32736: ST_TO_ADDR
// us_hack := 99 ;
32737: LD_ADDR_EXP 94
32741: PUSH
32742: LD_INT 99
32744: ST_TO_ADDR
// us_artillery := 97 ;
32745: LD_ADDR_EXP 95
32749: PUSH
32750: LD_INT 97
32752: ST_TO_ADDR
// ar_bio_bomb := 91 ;
32753: LD_ADDR_EXP 96
32757: PUSH
32758: LD_INT 91
32760: ST_TO_ADDR
// end ; end_of_file
32761: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
32762: LD_INT 0
32764: PPUSH
32765: PPUSH
// skirmish := false ;
32766: LD_ADDR_EXP 97
32770: PUSH
32771: LD_INT 0
32773: ST_TO_ADDR
// debug_mc := false ;
32774: LD_ADDR_EXP 98
32778: PUSH
32779: LD_INT 0
32781: ST_TO_ADDR
// mc_bases := [ ] ;
32782: LD_ADDR_EXP 99
32786: PUSH
32787: EMPTY
32788: ST_TO_ADDR
// mc_sides := [ ] ;
32789: LD_ADDR_EXP 125
32793: PUSH
32794: EMPTY
32795: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
32796: LD_ADDR_EXP 100
32800: PUSH
32801: EMPTY
32802: ST_TO_ADDR
// mc_building_repairs := [ ] ;
32803: LD_ADDR_EXP 101
32807: PUSH
32808: EMPTY
32809: ST_TO_ADDR
// mc_need_heal := [ ] ;
32810: LD_ADDR_EXP 102
32814: PUSH
32815: EMPTY
32816: ST_TO_ADDR
// mc_healers := [ ] ;
32817: LD_ADDR_EXP 103
32821: PUSH
32822: EMPTY
32823: ST_TO_ADDR
// mc_build_list := [ ] ;
32824: LD_ADDR_EXP 104
32828: PUSH
32829: EMPTY
32830: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
32831: LD_ADDR_EXP 131
32835: PUSH
32836: EMPTY
32837: ST_TO_ADDR
// mc_builders := [ ] ;
32838: LD_ADDR_EXP 105
32842: PUSH
32843: EMPTY
32844: ST_TO_ADDR
// mc_construct_list := [ ] ;
32845: LD_ADDR_EXP 106
32849: PUSH
32850: EMPTY
32851: ST_TO_ADDR
// mc_turret_list := [ ] ;
32852: LD_ADDR_EXP 107
32856: PUSH
32857: EMPTY
32858: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
32859: LD_ADDR_EXP 108
32863: PUSH
32864: EMPTY
32865: ST_TO_ADDR
// mc_miners := [ ] ;
32866: LD_ADDR_EXP 113
32870: PUSH
32871: EMPTY
32872: ST_TO_ADDR
// mc_mines := [ ] ;
32873: LD_ADDR_EXP 112
32877: PUSH
32878: EMPTY
32879: ST_TO_ADDR
// mc_minefields := [ ] ;
32880: LD_ADDR_EXP 114
32884: PUSH
32885: EMPTY
32886: ST_TO_ADDR
// mc_crates := [ ] ;
32887: LD_ADDR_EXP 115
32891: PUSH
32892: EMPTY
32893: ST_TO_ADDR
// mc_crates_collector := [ ] ;
32894: LD_ADDR_EXP 116
32898: PUSH
32899: EMPTY
32900: ST_TO_ADDR
// mc_crates_area := [ ] ;
32901: LD_ADDR_EXP 117
32905: PUSH
32906: EMPTY
32907: ST_TO_ADDR
// mc_vehicles := [ ] ;
32908: LD_ADDR_EXP 118
32912: PUSH
32913: EMPTY
32914: ST_TO_ADDR
// mc_attack := [ ] ;
32915: LD_ADDR_EXP 119
32919: PUSH
32920: EMPTY
32921: ST_TO_ADDR
// mc_produce := [ ] ;
32922: LD_ADDR_EXP 120
32926: PUSH
32927: EMPTY
32928: ST_TO_ADDR
// mc_defender := [ ] ;
32929: LD_ADDR_EXP 121
32933: PUSH
32934: EMPTY
32935: ST_TO_ADDR
// mc_parking := [ ] ;
32936: LD_ADDR_EXP 123
32940: PUSH
32941: EMPTY
32942: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
32943: LD_ADDR_EXP 109
32947: PUSH
32948: EMPTY
32949: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
32950: LD_ADDR_EXP 111
32954: PUSH
32955: EMPTY
32956: ST_TO_ADDR
// mc_scan := [ ] ;
32957: LD_ADDR_EXP 122
32961: PUSH
32962: EMPTY
32963: ST_TO_ADDR
// mc_scan_area := [ ] ;
32964: LD_ADDR_EXP 124
32968: PUSH
32969: EMPTY
32970: ST_TO_ADDR
// mc_tech := [ ] ;
32971: LD_ADDR_EXP 126
32975: PUSH
32976: EMPTY
32977: ST_TO_ADDR
// mc_class := [ ] ;
32978: LD_ADDR_EXP 140
32982: PUSH
32983: EMPTY
32984: ST_TO_ADDR
// mc_class_case_use := [ ] ;
32985: LD_ADDR_EXP 141
32989: PUSH
32990: EMPTY
32991: ST_TO_ADDR
// end ;
32992: LD_VAR 0 1
32996: RET
// export function MC_Kill ( base ) ; begin
32997: LD_INT 0
32999: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33000: LD_ADDR_EXP 99
33004: PUSH
33005: LD_EXP 99
33009: PPUSH
33010: LD_VAR 0 1
33014: PPUSH
33015: EMPTY
33016: PPUSH
33017: CALL_OW 1
33021: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33022: LD_ADDR_EXP 100
33026: PUSH
33027: LD_EXP 100
33031: PPUSH
33032: LD_VAR 0 1
33036: PPUSH
33037: EMPTY
33038: PPUSH
33039: CALL_OW 1
33043: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33044: LD_ADDR_EXP 101
33048: PUSH
33049: LD_EXP 101
33053: PPUSH
33054: LD_VAR 0 1
33058: PPUSH
33059: EMPTY
33060: PPUSH
33061: CALL_OW 1
33065: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
33066: LD_ADDR_EXP 102
33070: PUSH
33071: LD_EXP 102
33075: PPUSH
33076: LD_VAR 0 1
33080: PPUSH
33081: EMPTY
33082: PPUSH
33083: CALL_OW 1
33087: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
33088: LD_ADDR_EXP 103
33092: PUSH
33093: LD_EXP 103
33097: PPUSH
33098: LD_VAR 0 1
33102: PPUSH
33103: EMPTY
33104: PPUSH
33105: CALL_OW 1
33109: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
33110: LD_ADDR_EXP 104
33114: PUSH
33115: LD_EXP 104
33119: PPUSH
33120: LD_VAR 0 1
33124: PPUSH
33125: EMPTY
33126: PPUSH
33127: CALL_OW 1
33131: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
33132: LD_ADDR_EXP 105
33136: PUSH
33137: LD_EXP 105
33141: PPUSH
33142: LD_VAR 0 1
33146: PPUSH
33147: EMPTY
33148: PPUSH
33149: CALL_OW 1
33153: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
33154: LD_ADDR_EXP 106
33158: PUSH
33159: LD_EXP 106
33163: PPUSH
33164: LD_VAR 0 1
33168: PPUSH
33169: EMPTY
33170: PPUSH
33171: CALL_OW 1
33175: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
33176: LD_ADDR_EXP 107
33180: PUSH
33181: LD_EXP 107
33185: PPUSH
33186: LD_VAR 0 1
33190: PPUSH
33191: EMPTY
33192: PPUSH
33193: CALL_OW 1
33197: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
33198: LD_ADDR_EXP 108
33202: PUSH
33203: LD_EXP 108
33207: PPUSH
33208: LD_VAR 0 1
33212: PPUSH
33213: EMPTY
33214: PPUSH
33215: CALL_OW 1
33219: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
33220: LD_ADDR_EXP 109
33224: PUSH
33225: LD_EXP 109
33229: PPUSH
33230: LD_VAR 0 1
33234: PPUSH
33235: EMPTY
33236: PPUSH
33237: CALL_OW 1
33241: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
33242: LD_ADDR_EXP 110
33246: PUSH
33247: LD_EXP 110
33251: PPUSH
33252: LD_VAR 0 1
33256: PPUSH
33257: LD_INT 0
33259: PPUSH
33260: CALL_OW 1
33264: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
33265: LD_ADDR_EXP 111
33269: PUSH
33270: LD_EXP 111
33274: PPUSH
33275: LD_VAR 0 1
33279: PPUSH
33280: EMPTY
33281: PPUSH
33282: CALL_OW 1
33286: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
33287: LD_ADDR_EXP 112
33291: PUSH
33292: LD_EXP 112
33296: PPUSH
33297: LD_VAR 0 1
33301: PPUSH
33302: EMPTY
33303: PPUSH
33304: CALL_OW 1
33308: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
33309: LD_ADDR_EXP 113
33313: PUSH
33314: LD_EXP 113
33318: PPUSH
33319: LD_VAR 0 1
33323: PPUSH
33324: EMPTY
33325: PPUSH
33326: CALL_OW 1
33330: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
33331: LD_ADDR_EXP 114
33335: PUSH
33336: LD_EXP 114
33340: PPUSH
33341: LD_VAR 0 1
33345: PPUSH
33346: EMPTY
33347: PPUSH
33348: CALL_OW 1
33352: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
33353: LD_ADDR_EXP 115
33357: PUSH
33358: LD_EXP 115
33362: PPUSH
33363: LD_VAR 0 1
33367: PPUSH
33368: EMPTY
33369: PPUSH
33370: CALL_OW 1
33374: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
33375: LD_ADDR_EXP 116
33379: PUSH
33380: LD_EXP 116
33384: PPUSH
33385: LD_VAR 0 1
33389: PPUSH
33390: EMPTY
33391: PPUSH
33392: CALL_OW 1
33396: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
33397: LD_ADDR_EXP 117
33401: PUSH
33402: LD_EXP 117
33406: PPUSH
33407: LD_VAR 0 1
33411: PPUSH
33412: EMPTY
33413: PPUSH
33414: CALL_OW 1
33418: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
33419: LD_ADDR_EXP 118
33423: PUSH
33424: LD_EXP 118
33428: PPUSH
33429: LD_VAR 0 1
33433: PPUSH
33434: EMPTY
33435: PPUSH
33436: CALL_OW 1
33440: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
33441: LD_ADDR_EXP 119
33445: PUSH
33446: LD_EXP 119
33450: PPUSH
33451: LD_VAR 0 1
33455: PPUSH
33456: EMPTY
33457: PPUSH
33458: CALL_OW 1
33462: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
33463: LD_ADDR_EXP 120
33467: PUSH
33468: LD_EXP 120
33472: PPUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: EMPTY
33479: PPUSH
33480: CALL_OW 1
33484: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
33485: LD_ADDR_EXP 121
33489: PUSH
33490: LD_EXP 121
33494: PPUSH
33495: LD_VAR 0 1
33499: PPUSH
33500: EMPTY
33501: PPUSH
33502: CALL_OW 1
33506: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
33507: LD_ADDR_EXP 122
33511: PUSH
33512: LD_EXP 122
33516: PPUSH
33517: LD_VAR 0 1
33521: PPUSH
33522: EMPTY
33523: PPUSH
33524: CALL_OW 1
33528: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
33529: LD_ADDR_EXP 123
33533: PUSH
33534: LD_EXP 123
33538: PPUSH
33539: LD_VAR 0 1
33543: PPUSH
33544: EMPTY
33545: PPUSH
33546: CALL_OW 1
33550: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
33551: LD_ADDR_EXP 124
33555: PUSH
33556: LD_EXP 124
33560: PPUSH
33561: LD_VAR 0 1
33565: PPUSH
33566: EMPTY
33567: PPUSH
33568: CALL_OW 1
33572: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
33573: LD_ADDR_EXP 126
33577: PUSH
33578: LD_EXP 126
33582: PPUSH
33583: LD_VAR 0 1
33587: PPUSH
33588: EMPTY
33589: PPUSH
33590: CALL_OW 1
33594: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
33595: LD_ADDR_EXP 128
33599: PUSH
33600: LD_EXP 128
33604: PPUSH
33605: LD_VAR 0 1
33609: PPUSH
33610: EMPTY
33611: PPUSH
33612: CALL_OW 1
33616: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
33617: LD_ADDR_EXP 129
33621: PUSH
33622: LD_EXP 129
33626: PPUSH
33627: LD_VAR 0 1
33631: PPUSH
33632: EMPTY
33633: PPUSH
33634: CALL_OW 1
33638: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
33639: LD_ADDR_EXP 130
33643: PUSH
33644: LD_EXP 130
33648: PPUSH
33649: LD_VAR 0 1
33653: PPUSH
33654: EMPTY
33655: PPUSH
33656: CALL_OW 1
33660: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
33661: LD_ADDR_EXP 131
33665: PUSH
33666: LD_EXP 131
33670: PPUSH
33671: LD_VAR 0 1
33675: PPUSH
33676: EMPTY
33677: PPUSH
33678: CALL_OW 1
33682: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
33683: LD_ADDR_EXP 132
33687: PUSH
33688: LD_EXP 132
33692: PPUSH
33693: LD_VAR 0 1
33697: PPUSH
33698: EMPTY
33699: PPUSH
33700: CALL_OW 1
33704: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
33705: LD_ADDR_EXP 133
33709: PUSH
33710: LD_EXP 133
33714: PPUSH
33715: LD_VAR 0 1
33719: PPUSH
33720: EMPTY
33721: PPUSH
33722: CALL_OW 1
33726: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
33727: LD_ADDR_EXP 134
33731: PUSH
33732: LD_EXP 134
33736: PPUSH
33737: LD_VAR 0 1
33741: PPUSH
33742: EMPTY
33743: PPUSH
33744: CALL_OW 1
33748: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
33749: LD_ADDR_EXP 135
33753: PUSH
33754: LD_EXP 135
33758: PPUSH
33759: LD_VAR 0 1
33763: PPUSH
33764: EMPTY
33765: PPUSH
33766: CALL_OW 1
33770: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
33771: LD_ADDR_EXP 136
33775: PUSH
33776: LD_EXP 136
33780: PPUSH
33781: LD_VAR 0 1
33785: PPUSH
33786: EMPTY
33787: PPUSH
33788: CALL_OW 1
33792: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
33793: LD_ADDR_EXP 137
33797: PUSH
33798: LD_EXP 137
33802: PPUSH
33803: LD_VAR 0 1
33807: PPUSH
33808: EMPTY
33809: PPUSH
33810: CALL_OW 1
33814: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
33815: LD_ADDR_EXP 138
33819: PUSH
33820: LD_EXP 138
33824: PPUSH
33825: LD_VAR 0 1
33829: PPUSH
33830: EMPTY
33831: PPUSH
33832: CALL_OW 1
33836: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
33837: LD_ADDR_EXP 139
33841: PUSH
33842: LD_EXP 139
33846: PPUSH
33847: LD_VAR 0 1
33851: PPUSH
33852: EMPTY
33853: PPUSH
33854: CALL_OW 1
33858: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
33859: LD_ADDR_EXP 140
33863: PUSH
33864: LD_EXP 140
33868: PPUSH
33869: LD_VAR 0 1
33873: PPUSH
33874: EMPTY
33875: PPUSH
33876: CALL_OW 1
33880: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
33881: LD_ADDR_EXP 141
33885: PUSH
33886: LD_EXP 141
33890: PPUSH
33891: LD_VAR 0 1
33895: PPUSH
33896: LD_INT 0
33898: PPUSH
33899: CALL_OW 1
33903: ST_TO_ADDR
// end ;
33904: LD_VAR 0 2
33908: RET
// export function MC_Start ( ) ; var i ; begin
33909: LD_INT 0
33911: PPUSH
33912: PPUSH
// for i = 1 to mc_bases do
33913: LD_ADDR_VAR 0 2
33917: PUSH
33918: DOUBLE
33919: LD_INT 1
33921: DEC
33922: ST_TO_ADDR
33923: LD_EXP 99
33927: PUSH
33928: FOR_TO
33929: IFFALSE 35006
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
33931: LD_ADDR_EXP 99
33935: PUSH
33936: LD_EXP 99
33940: PPUSH
33941: LD_VAR 0 2
33945: PPUSH
33946: LD_EXP 99
33950: PUSH
33951: LD_VAR 0 2
33955: ARRAY
33956: PUSH
33957: LD_INT 0
33959: DIFF
33960: PPUSH
33961: CALL_OW 1
33965: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
33966: LD_ADDR_EXP 100
33970: PUSH
33971: LD_EXP 100
33975: PPUSH
33976: LD_VAR 0 2
33980: PPUSH
33981: EMPTY
33982: PPUSH
33983: CALL_OW 1
33987: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
33988: LD_ADDR_EXP 101
33992: PUSH
33993: LD_EXP 101
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: EMPTY
34004: PPUSH
34005: CALL_OW 1
34009: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
34010: LD_ADDR_EXP 102
34014: PUSH
34015: LD_EXP 102
34019: PPUSH
34020: LD_VAR 0 2
34024: PPUSH
34025: EMPTY
34026: PPUSH
34027: CALL_OW 1
34031: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
34032: LD_ADDR_EXP 103
34036: PUSH
34037: LD_EXP 103
34041: PPUSH
34042: LD_VAR 0 2
34046: PPUSH
34047: EMPTY
34048: PUSH
34049: EMPTY
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PPUSH
34055: CALL_OW 1
34059: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
34060: LD_ADDR_EXP 104
34064: PUSH
34065: LD_EXP 104
34069: PPUSH
34070: LD_VAR 0 2
34074: PPUSH
34075: EMPTY
34076: PPUSH
34077: CALL_OW 1
34081: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
34082: LD_ADDR_EXP 131
34086: PUSH
34087: LD_EXP 131
34091: PPUSH
34092: LD_VAR 0 2
34096: PPUSH
34097: EMPTY
34098: PPUSH
34099: CALL_OW 1
34103: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
34104: LD_ADDR_EXP 105
34108: PUSH
34109: LD_EXP 105
34113: PPUSH
34114: LD_VAR 0 2
34118: PPUSH
34119: EMPTY
34120: PPUSH
34121: CALL_OW 1
34125: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
34126: LD_ADDR_EXP 106
34130: PUSH
34131: LD_EXP 106
34135: PPUSH
34136: LD_VAR 0 2
34140: PPUSH
34141: EMPTY
34142: PPUSH
34143: CALL_OW 1
34147: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
34148: LD_ADDR_EXP 107
34152: PUSH
34153: LD_EXP 107
34157: PPUSH
34158: LD_VAR 0 2
34162: PPUSH
34163: LD_EXP 99
34167: PUSH
34168: LD_VAR 0 2
34172: ARRAY
34173: PPUSH
34174: LD_INT 2
34176: PUSH
34177: LD_INT 30
34179: PUSH
34180: LD_INT 32
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 30
34189: PUSH
34190: LD_INT 33
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: LIST
34201: PPUSH
34202: CALL_OW 72
34206: PPUSH
34207: CALL_OW 1
34211: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
34212: LD_ADDR_EXP 108
34216: PUSH
34217: LD_EXP 108
34221: PPUSH
34222: LD_VAR 0 2
34226: PPUSH
34227: LD_EXP 99
34231: PUSH
34232: LD_VAR 0 2
34236: ARRAY
34237: PPUSH
34238: LD_INT 2
34240: PUSH
34241: LD_INT 30
34243: PUSH
34244: LD_INT 32
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 30
34253: PUSH
34254: LD_INT 31
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 58
34268: PUSH
34269: EMPTY
34270: LIST
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PPUSH
34276: CALL_OW 72
34280: PPUSH
34281: CALL_OW 1
34285: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
34286: LD_ADDR_EXP 109
34290: PUSH
34291: LD_EXP 109
34295: PPUSH
34296: LD_VAR 0 2
34300: PPUSH
34301: EMPTY
34302: PPUSH
34303: CALL_OW 1
34307: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
34308: LD_ADDR_EXP 113
34312: PUSH
34313: LD_EXP 113
34317: PPUSH
34318: LD_VAR 0 2
34322: PPUSH
34323: EMPTY
34324: PPUSH
34325: CALL_OW 1
34329: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
34330: LD_ADDR_EXP 112
34334: PUSH
34335: LD_EXP 112
34339: PPUSH
34340: LD_VAR 0 2
34344: PPUSH
34345: EMPTY
34346: PPUSH
34347: CALL_OW 1
34351: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
34352: LD_ADDR_EXP 114
34356: PUSH
34357: LD_EXP 114
34361: PPUSH
34362: LD_VAR 0 2
34366: PPUSH
34367: EMPTY
34368: PPUSH
34369: CALL_OW 1
34373: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
34374: LD_ADDR_EXP 115
34378: PUSH
34379: LD_EXP 115
34383: PPUSH
34384: LD_VAR 0 2
34388: PPUSH
34389: EMPTY
34390: PPUSH
34391: CALL_OW 1
34395: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34396: LD_ADDR_EXP 116
34400: PUSH
34401: LD_EXP 116
34405: PPUSH
34406: LD_VAR 0 2
34410: PPUSH
34411: EMPTY
34412: PPUSH
34413: CALL_OW 1
34417: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
34418: LD_ADDR_EXP 117
34422: PUSH
34423: LD_EXP 117
34427: PPUSH
34428: LD_VAR 0 2
34432: PPUSH
34433: EMPTY
34434: PPUSH
34435: CALL_OW 1
34439: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
34440: LD_ADDR_EXP 118
34444: PUSH
34445: LD_EXP 118
34449: PPUSH
34450: LD_VAR 0 2
34454: PPUSH
34455: EMPTY
34456: PPUSH
34457: CALL_OW 1
34461: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34462: LD_ADDR_EXP 119
34466: PUSH
34467: LD_EXP 119
34471: PPUSH
34472: LD_VAR 0 2
34476: PPUSH
34477: EMPTY
34478: PPUSH
34479: CALL_OW 1
34483: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
34484: LD_ADDR_EXP 120
34488: PUSH
34489: LD_EXP 120
34493: PPUSH
34494: LD_VAR 0 2
34498: PPUSH
34499: EMPTY
34500: PPUSH
34501: CALL_OW 1
34505: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34506: LD_ADDR_EXP 121
34510: PUSH
34511: LD_EXP 121
34515: PPUSH
34516: LD_VAR 0 2
34520: PPUSH
34521: EMPTY
34522: PPUSH
34523: CALL_OW 1
34527: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
34528: LD_ADDR_EXP 110
34532: PUSH
34533: LD_EXP 110
34537: PPUSH
34538: LD_VAR 0 2
34542: PPUSH
34543: LD_INT 0
34545: PPUSH
34546: CALL_OW 1
34550: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
34551: LD_ADDR_EXP 123
34555: PUSH
34556: LD_EXP 123
34560: PPUSH
34561: LD_VAR 0 2
34565: PPUSH
34566: LD_INT 0
34568: PPUSH
34569: CALL_OW 1
34573: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
34574: LD_ADDR_EXP 111
34578: PUSH
34579: LD_EXP 111
34583: PPUSH
34584: LD_VAR 0 2
34588: PPUSH
34589: EMPTY
34590: PPUSH
34591: CALL_OW 1
34595: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
34596: LD_ADDR_EXP 122
34600: PUSH
34601: LD_EXP 122
34605: PPUSH
34606: LD_VAR 0 2
34610: PPUSH
34611: LD_INT 0
34613: PPUSH
34614: CALL_OW 1
34618: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
34619: LD_ADDR_EXP 124
34623: PUSH
34624: LD_EXP 124
34628: PPUSH
34629: LD_VAR 0 2
34633: PPUSH
34634: EMPTY
34635: PPUSH
34636: CALL_OW 1
34640: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
34641: LD_ADDR_EXP 127
34645: PUSH
34646: LD_EXP 127
34650: PPUSH
34651: LD_VAR 0 2
34655: PPUSH
34656: LD_INT 0
34658: PPUSH
34659: CALL_OW 1
34663: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
34664: LD_ADDR_EXP 128
34668: PUSH
34669: LD_EXP 128
34673: PPUSH
34674: LD_VAR 0 2
34678: PPUSH
34679: EMPTY
34680: PPUSH
34681: CALL_OW 1
34685: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
34686: LD_ADDR_EXP 129
34690: PUSH
34691: LD_EXP 129
34695: PPUSH
34696: LD_VAR 0 2
34700: PPUSH
34701: EMPTY
34702: PPUSH
34703: CALL_OW 1
34707: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
34708: LD_ADDR_EXP 130
34712: PUSH
34713: LD_EXP 130
34717: PPUSH
34718: LD_VAR 0 2
34722: PPUSH
34723: EMPTY
34724: PPUSH
34725: CALL_OW 1
34729: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
34730: LD_ADDR_EXP 132
34734: PUSH
34735: LD_EXP 132
34739: PPUSH
34740: LD_VAR 0 2
34744: PPUSH
34745: LD_EXP 99
34749: PUSH
34750: LD_VAR 0 2
34754: ARRAY
34755: PPUSH
34756: LD_INT 2
34758: PUSH
34759: LD_INT 30
34761: PUSH
34762: LD_INT 6
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 30
34771: PUSH
34772: LD_INT 7
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 8
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: PPUSH
34795: CALL_OW 72
34799: PPUSH
34800: CALL_OW 1
34804: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
34805: LD_ADDR_EXP 133
34809: PUSH
34810: LD_EXP 133
34814: PPUSH
34815: LD_VAR 0 2
34819: PPUSH
34820: EMPTY
34821: PPUSH
34822: CALL_OW 1
34826: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
34827: LD_ADDR_EXP 134
34831: PUSH
34832: LD_EXP 134
34836: PPUSH
34837: LD_VAR 0 2
34841: PPUSH
34842: EMPTY
34843: PPUSH
34844: CALL_OW 1
34848: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
34849: LD_ADDR_EXP 135
34853: PUSH
34854: LD_EXP 135
34858: PPUSH
34859: LD_VAR 0 2
34863: PPUSH
34864: EMPTY
34865: PPUSH
34866: CALL_OW 1
34870: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
34871: LD_ADDR_EXP 136
34875: PUSH
34876: LD_EXP 136
34880: PPUSH
34881: LD_VAR 0 2
34885: PPUSH
34886: EMPTY
34887: PPUSH
34888: CALL_OW 1
34892: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
34893: LD_ADDR_EXP 137
34897: PUSH
34898: LD_EXP 137
34902: PPUSH
34903: LD_VAR 0 2
34907: PPUSH
34908: EMPTY
34909: PPUSH
34910: CALL_OW 1
34914: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
34915: LD_ADDR_EXP 138
34919: PUSH
34920: LD_EXP 138
34924: PPUSH
34925: LD_VAR 0 2
34929: PPUSH
34930: EMPTY
34931: PPUSH
34932: CALL_OW 1
34936: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
34937: LD_ADDR_EXP 139
34941: PUSH
34942: LD_EXP 139
34946: PPUSH
34947: LD_VAR 0 2
34951: PPUSH
34952: EMPTY
34953: PPUSH
34954: CALL_OW 1
34958: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
34959: LD_ADDR_EXP 140
34963: PUSH
34964: LD_EXP 140
34968: PPUSH
34969: LD_VAR 0 2
34973: PPUSH
34974: EMPTY
34975: PPUSH
34976: CALL_OW 1
34980: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
34981: LD_ADDR_EXP 141
34985: PUSH
34986: LD_EXP 141
34990: PPUSH
34991: LD_VAR 0 2
34995: PPUSH
34996: LD_INT 0
34998: PPUSH
34999: CALL_OW 1
35003: ST_TO_ADDR
// end ;
35004: GO 33928
35006: POP
35007: POP
// MC_InitSides ( ) ;
35008: CALL 35294 0 0
// MC_InitResearch ( ) ;
35012: CALL 35033 0 0
// CustomInitMacro ( ) ;
35016: CALL 437 0 0
// skirmish := true ;
35020: LD_ADDR_EXP 97
35024: PUSH
35025: LD_INT 1
35027: ST_TO_ADDR
// end ;
35028: LD_VAR 0 1
35032: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
35033: LD_INT 0
35035: PPUSH
35036: PPUSH
35037: PPUSH
35038: PPUSH
35039: PPUSH
35040: PPUSH
// if not mc_bases then
35041: LD_EXP 99
35045: NOT
35046: IFFALSE 35050
// exit ;
35048: GO 35289
// for i = 1 to 8 do
35050: LD_ADDR_VAR 0 2
35054: PUSH
35055: DOUBLE
35056: LD_INT 1
35058: DEC
35059: ST_TO_ADDR
35060: LD_INT 8
35062: PUSH
35063: FOR_TO
35064: IFFALSE 35090
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
35066: LD_ADDR_EXP 126
35070: PUSH
35071: LD_EXP 126
35075: PPUSH
35076: LD_VAR 0 2
35080: PPUSH
35081: EMPTY
35082: PPUSH
35083: CALL_OW 1
35087: ST_TO_ADDR
35088: GO 35063
35090: POP
35091: POP
// tmp := [ ] ;
35092: LD_ADDR_VAR 0 5
35096: PUSH
35097: EMPTY
35098: ST_TO_ADDR
// for i = 1 to mc_sides do
35099: LD_ADDR_VAR 0 2
35103: PUSH
35104: DOUBLE
35105: LD_INT 1
35107: DEC
35108: ST_TO_ADDR
35109: LD_EXP 125
35113: PUSH
35114: FOR_TO
35115: IFFALSE 35173
// if not mc_sides [ i ] in tmp then
35117: LD_EXP 125
35121: PUSH
35122: LD_VAR 0 2
35126: ARRAY
35127: PUSH
35128: LD_VAR 0 5
35132: IN
35133: NOT
35134: IFFALSE 35171
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
35136: LD_ADDR_VAR 0 5
35140: PUSH
35141: LD_VAR 0 5
35145: PPUSH
35146: LD_VAR 0 5
35150: PUSH
35151: LD_INT 1
35153: PLUS
35154: PPUSH
35155: LD_EXP 125
35159: PUSH
35160: LD_VAR 0 2
35164: ARRAY
35165: PPUSH
35166: CALL_OW 2
35170: ST_TO_ADDR
35171: GO 35114
35173: POP
35174: POP
// if not tmp then
35175: LD_VAR 0 5
35179: NOT
35180: IFFALSE 35184
// exit ;
35182: GO 35289
// for j in tmp do
35184: LD_ADDR_VAR 0 3
35188: PUSH
35189: LD_VAR 0 5
35193: PUSH
35194: FOR_IN
35195: IFFALSE 35287
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
35197: LD_ADDR_VAR 0 6
35201: PUSH
35202: LD_INT 22
35204: PUSH
35205: LD_VAR 0 3
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PPUSH
35214: CALL_OW 69
35218: ST_TO_ADDR
// if not un then
35219: LD_VAR 0 6
35223: NOT
35224: IFFALSE 35228
// continue ;
35226: GO 35194
// nation := GetNation ( un [ 1 ] ) ;
35228: LD_ADDR_VAR 0 4
35232: PUSH
35233: LD_VAR 0 6
35237: PUSH
35238: LD_INT 1
35240: ARRAY
35241: PPUSH
35242: CALL_OW 248
35246: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
35247: LD_ADDR_EXP 126
35251: PUSH
35252: LD_EXP 126
35256: PPUSH
35257: LD_VAR 0 3
35261: PPUSH
35262: LD_VAR 0 3
35266: PPUSH
35267: LD_VAR 0 4
35271: PPUSH
35272: LD_INT 1
35274: PPUSH
35275: CALL 61034 0 3
35279: PPUSH
35280: CALL_OW 1
35284: ST_TO_ADDR
// end ;
35285: GO 35194
35287: POP
35288: POP
// end ;
35289: LD_VAR 0 1
35293: RET
// export function MC_InitSides ( ) ; var i ; begin
35294: LD_INT 0
35296: PPUSH
35297: PPUSH
// if not mc_bases then
35298: LD_EXP 99
35302: NOT
35303: IFFALSE 35307
// exit ;
35305: GO 35381
// for i = 1 to mc_bases do
35307: LD_ADDR_VAR 0 2
35311: PUSH
35312: DOUBLE
35313: LD_INT 1
35315: DEC
35316: ST_TO_ADDR
35317: LD_EXP 99
35321: PUSH
35322: FOR_TO
35323: IFFALSE 35379
// if mc_bases [ i ] then
35325: LD_EXP 99
35329: PUSH
35330: LD_VAR 0 2
35334: ARRAY
35335: IFFALSE 35377
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
35337: LD_ADDR_EXP 125
35341: PUSH
35342: LD_EXP 125
35346: PPUSH
35347: LD_VAR 0 2
35351: PPUSH
35352: LD_EXP 99
35356: PUSH
35357: LD_VAR 0 2
35361: ARRAY
35362: PUSH
35363: LD_INT 1
35365: ARRAY
35366: PPUSH
35367: CALL_OW 255
35371: PPUSH
35372: CALL_OW 1
35376: ST_TO_ADDR
35377: GO 35322
35379: POP
35380: POP
// end ;
35381: LD_VAR 0 1
35385: RET
// every 0 0$01 trigger skirmish do
35386: LD_EXP 97
35390: IFFALSE 35544
35392: GO 35394
35394: DISABLE
// begin enable ;
35395: ENABLE
// MC_CheckBuildings ( ) ;
35396: CALL 40033 0 0
// MC_CheckPeopleLife ( ) ;
35400: CALL 40158 0 0
// RaiseSailEvent ( 100 ) ;
35404: LD_INT 100
35406: PPUSH
35407: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
35411: LD_INT 103
35413: PPUSH
35414: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
35418: LD_INT 104
35420: PPUSH
35421: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
35425: LD_INT 105
35427: PPUSH
35428: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
35432: LD_INT 106
35434: PPUSH
35435: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
35439: LD_INT 107
35441: PPUSH
35442: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
35446: LD_INT 108
35448: PPUSH
35449: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
35453: LD_INT 109
35455: PPUSH
35456: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
35460: LD_INT 110
35462: PPUSH
35463: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
35467: LD_INT 111
35469: PPUSH
35470: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
35474: LD_INT 112
35476: PPUSH
35477: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
35481: LD_INT 113
35483: PPUSH
35484: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
35488: LD_INT 120
35490: PPUSH
35491: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
35495: LD_INT 121
35497: PPUSH
35498: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
35502: LD_INT 122
35504: PPUSH
35505: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
35509: LD_INT 123
35511: PPUSH
35512: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
35516: LD_INT 124
35518: PPUSH
35519: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
35523: LD_INT 125
35525: PPUSH
35526: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
35530: LD_INT 126
35532: PPUSH
35533: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
35537: LD_INT 200
35539: PPUSH
35540: CALL_OW 427
// end ;
35544: END
// on SailEvent ( event ) do begin if event < 100 then
35545: LD_VAR 0 1
35549: PUSH
35550: LD_INT 100
35552: LESS
35553: IFFALSE 35564
// CustomEvent ( event ) ;
35555: LD_VAR 0 1
35559: PPUSH
35560: CALL 31221 0 1
// if event = 100 then
35564: LD_VAR 0 1
35568: PUSH
35569: LD_INT 100
35571: EQUAL
35572: IFFALSE 35578
// MC_ClassManager ( ) ;
35574: CALL 35970 0 0
// if event = 101 then
35578: LD_VAR 0 1
35582: PUSH
35583: LD_INT 101
35585: EQUAL
35586: IFFALSE 35592
// MC_RepairBuildings ( ) ;
35588: CALL 40754 0 0
// if event = 102 then
35592: LD_VAR 0 1
35596: PUSH
35597: LD_INT 102
35599: EQUAL
35600: IFFALSE 35606
// MC_Heal ( ) ;
35602: CALL 41160 0 0
// if event = 103 then
35606: LD_VAR 0 1
35610: PUSH
35611: LD_INT 103
35613: EQUAL
35614: IFFALSE 35620
// MC_Build ( ) ;
35616: CALL 41582 0 0
// if event = 104 then
35620: LD_VAR 0 1
35624: PUSH
35625: LD_INT 104
35627: EQUAL
35628: IFFALSE 35634
// MC_TurretWeapon ( ) ;
35630: CALL 43195 0 0
// if event = 105 then
35634: LD_VAR 0 1
35638: PUSH
35639: LD_INT 105
35641: EQUAL
35642: IFFALSE 35648
// MC_BuildUpgrade ( ) ;
35644: CALL 42746 0 0
// if event = 106 then
35648: LD_VAR 0 1
35652: PUSH
35653: LD_INT 106
35655: EQUAL
35656: IFFALSE 35662
// MC_PlantMines ( ) ;
35658: CALL 43625 0 0
// if event = 107 then
35662: LD_VAR 0 1
35666: PUSH
35667: LD_INT 107
35669: EQUAL
35670: IFFALSE 35676
// MC_CollectCrates ( ) ;
35672: CALL 44659 0 0
// if event = 108 then
35676: LD_VAR 0 1
35680: PUSH
35681: LD_INT 108
35683: EQUAL
35684: IFFALSE 35690
// MC_LinkRemoteControl ( ) ;
35686: CALL 46416 0 0
// if event = 109 then
35690: LD_VAR 0 1
35694: PUSH
35695: LD_INT 109
35697: EQUAL
35698: IFFALSE 35704
// MC_ProduceVehicle ( ) ;
35700: CALL 46597 0 0
// if event = 110 then
35704: LD_VAR 0 1
35708: PUSH
35709: LD_INT 110
35711: EQUAL
35712: IFFALSE 35718
// MC_SendAttack ( ) ;
35714: CALL 47078 0 0
// if event = 111 then
35718: LD_VAR 0 1
35722: PUSH
35723: LD_INT 111
35725: EQUAL
35726: IFFALSE 35732
// MC_Defend ( ) ;
35728: CALL 47186 0 0
// if event = 112 then
35732: LD_VAR 0 1
35736: PUSH
35737: LD_INT 112
35739: EQUAL
35740: IFFALSE 35746
// MC_Research ( ) ;
35742: CALL 47813 0 0
// if event = 113 then
35746: LD_VAR 0 1
35750: PUSH
35751: LD_INT 113
35753: EQUAL
35754: IFFALSE 35760
// MC_MinesTrigger ( ) ;
35756: CALL 48927 0 0
// if event = 120 then
35760: LD_VAR 0 1
35764: PUSH
35765: LD_INT 120
35767: EQUAL
35768: IFFALSE 35774
// MC_RepairVehicle ( ) ;
35770: CALL 49026 0 0
// if event = 121 then
35774: LD_VAR 0 1
35778: PUSH
35779: LD_INT 121
35781: EQUAL
35782: IFFALSE 35788
// MC_TameApe ( ) ;
35784: CALL 49769 0 0
// if event = 122 then
35788: LD_VAR 0 1
35792: PUSH
35793: LD_INT 122
35795: EQUAL
35796: IFFALSE 35802
// MC_ChangeApeClass ( ) ;
35798: CALL 50598 0 0
// if event = 123 then
35802: LD_VAR 0 1
35806: PUSH
35807: LD_INT 123
35809: EQUAL
35810: IFFALSE 35816
// MC_Bazooka ( ) ;
35812: CALL 51248 0 0
// if event = 124 then
35816: LD_VAR 0 1
35820: PUSH
35821: LD_INT 124
35823: EQUAL
35824: IFFALSE 35830
// MC_TeleportExit ( ) ;
35826: CALL 51446 0 0
// if event = 125 then
35830: LD_VAR 0 1
35834: PUSH
35835: LD_INT 125
35837: EQUAL
35838: IFFALSE 35844
// MC_Deposits ( ) ;
35840: CALL 52093 0 0
// if event = 126 then
35844: LD_VAR 0 1
35848: PUSH
35849: LD_INT 126
35851: EQUAL
35852: IFFALSE 35858
// MC_RemoteDriver ( ) ;
35854: CALL 52718 0 0
// if event = 200 then
35858: LD_VAR 0 1
35862: PUSH
35863: LD_INT 200
35865: EQUAL
35866: IFFALSE 35872
// MC_Idle ( ) ;
35868: CALL 54451 0 0
// end ;
35872: PPOPN 1
35874: END
// export function MC_Reset ( base , tag ) ; var i ; begin
35875: LD_INT 0
35877: PPUSH
35878: PPUSH
// if not mc_bases [ base ] or not tag then
35879: LD_EXP 99
35883: PUSH
35884: LD_VAR 0 1
35888: ARRAY
35889: NOT
35890: PUSH
35891: LD_VAR 0 2
35895: NOT
35896: OR
35897: IFFALSE 35901
// exit ;
35899: GO 35965
// for i in mc_bases [ base ] union mc_ape [ base ] do
35901: LD_ADDR_VAR 0 4
35905: PUSH
35906: LD_EXP 99
35910: PUSH
35911: LD_VAR 0 1
35915: ARRAY
35916: PUSH
35917: LD_EXP 128
35921: PUSH
35922: LD_VAR 0 1
35926: ARRAY
35927: UNION
35928: PUSH
35929: FOR_IN
35930: IFFALSE 35963
// if GetTag ( i ) = tag then
35932: LD_VAR 0 4
35936: PPUSH
35937: CALL_OW 110
35941: PUSH
35942: LD_VAR 0 2
35946: EQUAL
35947: IFFALSE 35961
// SetTag ( i , 0 ) ;
35949: LD_VAR 0 4
35953: PPUSH
35954: LD_INT 0
35956: PPUSH
35957: CALL_OW 109
35961: GO 35929
35963: POP
35964: POP
// end ;
35965: LD_VAR 0 3
35969: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
35970: LD_INT 0
35972: PPUSH
35973: PPUSH
35974: PPUSH
35975: PPUSH
35976: PPUSH
35977: PPUSH
35978: PPUSH
35979: PPUSH
// if not mc_bases then
35980: LD_EXP 99
35984: NOT
35985: IFFALSE 35989
// exit ;
35987: GO 36447
// for i = 1 to mc_bases do
35989: LD_ADDR_VAR 0 2
35993: PUSH
35994: DOUBLE
35995: LD_INT 1
35997: DEC
35998: ST_TO_ADDR
35999: LD_EXP 99
36003: PUSH
36004: FOR_TO
36005: IFFALSE 36445
// begin tmp := MC_ClassCheckReq ( i ) ;
36007: LD_ADDR_VAR 0 4
36011: PUSH
36012: LD_VAR 0 2
36016: PPUSH
36017: CALL 36452 0 1
36021: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
36022: LD_ADDR_EXP 140
36026: PUSH
36027: LD_EXP 140
36031: PPUSH
36032: LD_VAR 0 2
36036: PPUSH
36037: LD_VAR 0 4
36041: PPUSH
36042: CALL_OW 1
36046: ST_TO_ADDR
// if not tmp then
36047: LD_VAR 0 4
36051: NOT
36052: IFFALSE 36056
// continue ;
36054: GO 36004
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
36056: LD_ADDR_VAR 0 6
36060: PUSH
36061: LD_EXP 99
36065: PUSH
36066: LD_VAR 0 2
36070: ARRAY
36071: PPUSH
36072: LD_INT 2
36074: PUSH
36075: LD_INT 30
36077: PUSH
36078: LD_INT 4
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 30
36087: PUSH
36088: LD_INT 5
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: LIST
36099: PPUSH
36100: CALL_OW 72
36104: PUSH
36105: LD_EXP 99
36109: PUSH
36110: LD_VAR 0 2
36114: ARRAY
36115: PPUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 30
36121: PUSH
36122: LD_INT 0
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 30
36131: PUSH
36132: LD_INT 1
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: LIST
36143: PPUSH
36144: CALL_OW 72
36148: PUSH
36149: LD_EXP 99
36153: PUSH
36154: LD_VAR 0 2
36158: ARRAY
36159: PPUSH
36160: LD_INT 30
36162: PUSH
36163: LD_INT 3
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PPUSH
36170: CALL_OW 72
36174: PUSH
36175: LD_EXP 99
36179: PUSH
36180: LD_VAR 0 2
36184: ARRAY
36185: PPUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 30
36191: PUSH
36192: LD_INT 6
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 30
36201: PUSH
36202: LD_INT 7
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 30
36211: PUSH
36212: LD_INT 8
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: PPUSH
36225: CALL_OW 72
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: ST_TO_ADDR
// for j = 1 to 4 do
36236: LD_ADDR_VAR 0 3
36240: PUSH
36241: DOUBLE
36242: LD_INT 1
36244: DEC
36245: ST_TO_ADDR
36246: LD_INT 4
36248: PUSH
36249: FOR_TO
36250: IFFALSE 36441
// begin if not tmp [ j ] then
36252: LD_VAR 0 4
36256: PUSH
36257: LD_VAR 0 3
36261: ARRAY
36262: NOT
36263: IFFALSE 36267
// continue ;
36265: GO 36249
// for p in tmp [ j ] do
36267: LD_ADDR_VAR 0 5
36271: PUSH
36272: LD_VAR 0 4
36276: PUSH
36277: LD_VAR 0 3
36281: ARRAY
36282: PUSH
36283: FOR_IN
36284: IFFALSE 36437
// begin if not b [ j ] then
36286: LD_VAR 0 6
36290: PUSH
36291: LD_VAR 0 3
36295: ARRAY
36296: NOT
36297: IFFALSE 36301
// break ;
36299: GO 36437
// e := 0 ;
36301: LD_ADDR_VAR 0 7
36305: PUSH
36306: LD_INT 0
36308: ST_TO_ADDR
// for k in b [ j ] do
36309: LD_ADDR_VAR 0 8
36313: PUSH
36314: LD_VAR 0 6
36318: PUSH
36319: LD_VAR 0 3
36323: ARRAY
36324: PUSH
36325: FOR_IN
36326: IFFALSE 36353
// if IsNotFull ( k ) then
36328: LD_VAR 0 8
36332: PPUSH
36333: CALL 65060 0 1
36337: IFFALSE 36351
// begin e := k ;
36339: LD_ADDR_VAR 0 7
36343: PUSH
36344: LD_VAR 0 8
36348: ST_TO_ADDR
// break ;
36349: GO 36353
// end ;
36351: GO 36325
36353: POP
36354: POP
// if e and not UnitGoingToBuilding ( p , e ) then
36355: LD_VAR 0 7
36359: PUSH
36360: LD_VAR 0 5
36364: PPUSH
36365: LD_VAR 0 7
36369: PPUSH
36370: CALL 102048 0 2
36374: NOT
36375: AND
36376: IFFALSE 36435
// begin if IsInUnit ( p ) then
36378: LD_VAR 0 5
36382: PPUSH
36383: CALL_OW 310
36387: IFFALSE 36398
// ComExitBuilding ( p ) ;
36389: LD_VAR 0 5
36393: PPUSH
36394: CALL_OW 122
// ComEnterUnit ( p , e ) ;
36398: LD_VAR 0 5
36402: PPUSH
36403: LD_VAR 0 7
36407: PPUSH
36408: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
36412: LD_VAR 0 5
36416: PPUSH
36417: LD_VAR 0 3
36421: PPUSH
36422: CALL_OW 183
// AddComExitBuilding ( p ) ;
36426: LD_VAR 0 5
36430: PPUSH
36431: CALL_OW 182
// end ; end ;
36435: GO 36283
36437: POP
36438: POP
// end ;
36439: GO 36249
36441: POP
36442: POP
// end ;
36443: GO 36004
36445: POP
36446: POP
// end ;
36447: LD_VAR 0 1
36451: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
36452: LD_INT 0
36454: PPUSH
36455: PPUSH
36456: PPUSH
36457: PPUSH
36458: PPUSH
36459: PPUSH
36460: PPUSH
36461: PPUSH
36462: PPUSH
36463: PPUSH
36464: PPUSH
36465: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
36466: LD_VAR 0 1
36470: NOT
36471: PUSH
36472: LD_EXP 99
36476: PUSH
36477: LD_VAR 0 1
36481: ARRAY
36482: NOT
36483: OR
36484: PUSH
36485: LD_EXP 99
36489: PUSH
36490: LD_VAR 0 1
36494: ARRAY
36495: PPUSH
36496: LD_INT 2
36498: PUSH
36499: LD_INT 30
36501: PUSH
36502: LD_INT 0
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 30
36511: PUSH
36512: LD_INT 1
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: LIST
36523: PPUSH
36524: CALL_OW 72
36528: NOT
36529: OR
36530: IFFALSE 36534
// exit ;
36532: GO 40028
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36534: LD_ADDR_VAR 0 4
36538: PUSH
36539: LD_EXP 99
36543: PUSH
36544: LD_VAR 0 1
36548: ARRAY
36549: PPUSH
36550: LD_INT 2
36552: PUSH
36553: LD_INT 25
36555: PUSH
36556: LD_INT 1
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 25
36565: PUSH
36566: LD_INT 2
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 25
36575: PUSH
36576: LD_INT 3
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 25
36585: PUSH
36586: LD_INT 4
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 25
36595: PUSH
36596: LD_INT 5
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 25
36605: PUSH
36606: LD_INT 8
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 25
36615: PUSH
36616: LD_INT 9
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: PPUSH
36633: CALL_OW 72
36637: ST_TO_ADDR
// for i in tmp do
36638: LD_ADDR_VAR 0 3
36642: PUSH
36643: LD_VAR 0 4
36647: PUSH
36648: FOR_IN
36649: IFFALSE 36680
// if GetTag ( i ) then
36651: LD_VAR 0 3
36655: PPUSH
36656: CALL_OW 110
36660: IFFALSE 36678
// tmp := tmp diff i ;
36662: LD_ADDR_VAR 0 4
36666: PUSH
36667: LD_VAR 0 4
36671: PUSH
36672: LD_VAR 0 3
36676: DIFF
36677: ST_TO_ADDR
36678: GO 36648
36680: POP
36681: POP
// if not tmp then
36682: LD_VAR 0 4
36686: NOT
36687: IFFALSE 36691
// exit ;
36689: GO 40028
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36691: LD_ADDR_VAR 0 5
36695: PUSH
36696: LD_EXP 99
36700: PUSH
36701: LD_VAR 0 1
36705: ARRAY
36706: PPUSH
36707: LD_INT 2
36709: PUSH
36710: LD_INT 25
36712: PUSH
36713: LD_INT 1
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 25
36722: PUSH
36723: LD_INT 5
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 25
36732: PUSH
36733: LD_INT 8
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 25
36742: PUSH
36743: LD_INT 9
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: PPUSH
36757: CALL_OW 72
36761: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
36762: LD_ADDR_VAR 0 6
36766: PUSH
36767: LD_EXP 99
36771: PUSH
36772: LD_VAR 0 1
36776: ARRAY
36777: PPUSH
36778: LD_INT 25
36780: PUSH
36781: LD_INT 2
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PPUSH
36788: CALL_OW 72
36792: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
36793: LD_ADDR_VAR 0 7
36797: PUSH
36798: LD_EXP 99
36802: PUSH
36803: LD_VAR 0 1
36807: ARRAY
36808: PPUSH
36809: LD_INT 25
36811: PUSH
36812: LD_INT 3
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PPUSH
36819: CALL_OW 72
36823: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
36824: LD_ADDR_VAR 0 8
36828: PUSH
36829: LD_EXP 99
36833: PUSH
36834: LD_VAR 0 1
36838: ARRAY
36839: PPUSH
36840: LD_INT 25
36842: PUSH
36843: LD_INT 4
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 24
36852: PUSH
36853: LD_INT 251
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PPUSH
36864: CALL_OW 72
36868: ST_TO_ADDR
// if mc_scan [ base ] then
36869: LD_EXP 122
36873: PUSH
36874: LD_VAR 0 1
36878: ARRAY
36879: IFFALSE 37340
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
36881: LD_ADDR_EXP 141
36885: PUSH
36886: LD_EXP 141
36890: PPUSH
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_INT 4
36898: PPUSH
36899: CALL_OW 1
36903: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36904: LD_ADDR_VAR 0 12
36908: PUSH
36909: LD_EXP 99
36913: PUSH
36914: LD_VAR 0 1
36918: ARRAY
36919: PPUSH
36920: LD_INT 2
36922: PUSH
36923: LD_INT 30
36925: PUSH
36926: LD_INT 4
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 30
36935: PUSH
36936: LD_INT 5
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: LIST
36947: PPUSH
36948: CALL_OW 72
36952: ST_TO_ADDR
// if not b then
36953: LD_VAR 0 12
36957: NOT
36958: IFFALSE 36962
// exit ;
36960: GO 40028
// p := [ ] ;
36962: LD_ADDR_VAR 0 11
36966: PUSH
36967: EMPTY
36968: ST_TO_ADDR
// if sci >= 2 then
36969: LD_VAR 0 8
36973: PUSH
36974: LD_INT 2
36976: GREATEREQUAL
36977: IFFALSE 37008
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
36979: LD_ADDR_VAR 0 8
36983: PUSH
36984: LD_VAR 0 8
36988: PUSH
36989: LD_INT 1
36991: ARRAY
36992: PUSH
36993: LD_VAR 0 8
36997: PUSH
36998: LD_INT 2
37000: ARRAY
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: ST_TO_ADDR
37006: GO 37069
// if sci = 1 then
37008: LD_VAR 0 8
37012: PUSH
37013: LD_INT 1
37015: EQUAL
37016: IFFALSE 37037
// sci := [ sci [ 1 ] ] else
37018: LD_ADDR_VAR 0 8
37022: PUSH
37023: LD_VAR 0 8
37027: PUSH
37028: LD_INT 1
37030: ARRAY
37031: PUSH
37032: EMPTY
37033: LIST
37034: ST_TO_ADDR
37035: GO 37069
// if sci = 0 then
37037: LD_VAR 0 8
37041: PUSH
37042: LD_INT 0
37044: EQUAL
37045: IFFALSE 37069
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
37047: LD_ADDR_VAR 0 11
37051: PUSH
37052: LD_VAR 0 4
37056: PPUSH
37057: LD_INT 4
37059: PPUSH
37060: CALL 101911 0 2
37064: PUSH
37065: LD_INT 1
37067: ARRAY
37068: ST_TO_ADDR
// if eng > 4 then
37069: LD_VAR 0 6
37073: PUSH
37074: LD_INT 4
37076: GREATER
37077: IFFALSE 37123
// for i = eng downto 4 do
37079: LD_ADDR_VAR 0 3
37083: PUSH
37084: DOUBLE
37085: LD_VAR 0 6
37089: INC
37090: ST_TO_ADDR
37091: LD_INT 4
37093: PUSH
37094: FOR_DOWNTO
37095: IFFALSE 37121
// eng := eng diff eng [ i ] ;
37097: LD_ADDR_VAR 0 6
37101: PUSH
37102: LD_VAR 0 6
37106: PUSH
37107: LD_VAR 0 6
37111: PUSH
37112: LD_VAR 0 3
37116: ARRAY
37117: DIFF
37118: ST_TO_ADDR
37119: GO 37094
37121: POP
37122: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
37123: LD_ADDR_VAR 0 4
37127: PUSH
37128: LD_VAR 0 4
37132: PUSH
37133: LD_VAR 0 5
37137: PUSH
37138: LD_VAR 0 6
37142: UNION
37143: PUSH
37144: LD_VAR 0 7
37148: UNION
37149: PUSH
37150: LD_VAR 0 8
37154: UNION
37155: DIFF
37156: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
37157: LD_ADDR_VAR 0 13
37161: PUSH
37162: LD_EXP 99
37166: PUSH
37167: LD_VAR 0 1
37171: ARRAY
37172: PPUSH
37173: LD_INT 2
37175: PUSH
37176: LD_INT 30
37178: PUSH
37179: LD_INT 32
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: PUSH
37186: LD_INT 30
37188: PUSH
37189: LD_INT 31
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: LIST
37200: PPUSH
37201: CALL_OW 72
37205: PUSH
37206: LD_EXP 99
37210: PUSH
37211: LD_VAR 0 1
37215: ARRAY
37216: PPUSH
37217: LD_INT 2
37219: PUSH
37220: LD_INT 30
37222: PUSH
37223: LD_INT 4
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 30
37232: PUSH
37233: LD_INT 5
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: LIST
37244: PPUSH
37245: CALL_OW 72
37249: PUSH
37250: LD_INT 6
37252: MUL
37253: PLUS
37254: ST_TO_ADDR
// if bcount < tmp then
37255: LD_VAR 0 13
37259: PUSH
37260: LD_VAR 0 4
37264: LESS
37265: IFFALSE 37311
// for i = tmp downto bcount do
37267: LD_ADDR_VAR 0 3
37271: PUSH
37272: DOUBLE
37273: LD_VAR 0 4
37277: INC
37278: ST_TO_ADDR
37279: LD_VAR 0 13
37283: PUSH
37284: FOR_DOWNTO
37285: IFFALSE 37309
// tmp := Delete ( tmp , tmp ) ;
37287: LD_ADDR_VAR 0 4
37291: PUSH
37292: LD_VAR 0 4
37296: PPUSH
37297: LD_VAR 0 4
37301: PPUSH
37302: CALL_OW 3
37306: ST_TO_ADDR
37307: GO 37284
37309: POP
37310: POP
// result := [ tmp , 0 , 0 , p ] ;
37311: LD_ADDR_VAR 0 2
37315: PUSH
37316: LD_VAR 0 4
37320: PUSH
37321: LD_INT 0
37323: PUSH
37324: LD_INT 0
37326: PUSH
37327: LD_VAR 0 11
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: LIST
37336: LIST
37337: ST_TO_ADDR
// exit ;
37338: GO 40028
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
37340: LD_EXP 99
37344: PUSH
37345: LD_VAR 0 1
37349: ARRAY
37350: PPUSH
37351: LD_INT 2
37353: PUSH
37354: LD_INT 30
37356: PUSH
37357: LD_INT 6
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 30
37366: PUSH
37367: LD_INT 7
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 30
37376: PUSH
37377: LD_INT 8
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: PPUSH
37390: CALL_OW 72
37394: NOT
37395: PUSH
37396: LD_EXP 99
37400: PUSH
37401: LD_VAR 0 1
37405: ARRAY
37406: PPUSH
37407: LD_INT 30
37409: PUSH
37410: LD_INT 3
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PPUSH
37417: CALL_OW 72
37421: NOT
37422: AND
37423: IFFALSE 37495
// begin if eng = tmp then
37425: LD_VAR 0 6
37429: PUSH
37430: LD_VAR 0 4
37434: EQUAL
37435: IFFALSE 37439
// exit ;
37437: GO 40028
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
37439: LD_ADDR_EXP 141
37443: PUSH
37444: LD_EXP 141
37448: PPUSH
37449: LD_VAR 0 1
37453: PPUSH
37454: LD_INT 1
37456: PPUSH
37457: CALL_OW 1
37461: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
37462: LD_ADDR_VAR 0 2
37466: PUSH
37467: LD_INT 0
37469: PUSH
37470: LD_VAR 0 4
37474: PUSH
37475: LD_VAR 0 6
37479: DIFF
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: ST_TO_ADDR
// exit ;
37493: GO 40028
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
37495: LD_EXP 126
37499: PUSH
37500: LD_EXP 125
37504: PUSH
37505: LD_VAR 0 1
37509: ARRAY
37510: ARRAY
37511: PUSH
37512: LD_EXP 99
37516: PUSH
37517: LD_VAR 0 1
37521: ARRAY
37522: PPUSH
37523: LD_INT 2
37525: PUSH
37526: LD_INT 30
37528: PUSH
37529: LD_INT 6
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 30
37538: PUSH
37539: LD_INT 7
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 30
37548: PUSH
37549: LD_INT 8
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: LIST
37560: LIST
37561: PPUSH
37562: CALL_OW 72
37566: AND
37567: PUSH
37568: LD_EXP 99
37572: PUSH
37573: LD_VAR 0 1
37577: ARRAY
37578: PPUSH
37579: LD_INT 30
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PPUSH
37589: CALL_OW 72
37593: NOT
37594: AND
37595: IFFALSE 37809
// begin if sci >= 6 then
37597: LD_VAR 0 8
37601: PUSH
37602: LD_INT 6
37604: GREATEREQUAL
37605: IFFALSE 37609
// exit ;
37607: GO 40028
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
37609: LD_ADDR_EXP 141
37613: PUSH
37614: LD_EXP 141
37618: PPUSH
37619: LD_VAR 0 1
37623: PPUSH
37624: LD_INT 2
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
37632: LD_ADDR_VAR 0 9
37636: PUSH
37637: LD_VAR 0 4
37641: PUSH
37642: LD_VAR 0 8
37646: DIFF
37647: PPUSH
37648: LD_INT 4
37650: PPUSH
37651: CALL 101911 0 2
37655: ST_TO_ADDR
// p := [ ] ;
37656: LD_ADDR_VAR 0 11
37660: PUSH
37661: EMPTY
37662: ST_TO_ADDR
// if sci < 6 and sort > 6 then
37663: LD_VAR 0 8
37667: PUSH
37668: LD_INT 6
37670: LESS
37671: PUSH
37672: LD_VAR 0 9
37676: PUSH
37677: LD_INT 6
37679: GREATER
37680: AND
37681: IFFALSE 37762
// begin for i = 1 to 6 - sci do
37683: LD_ADDR_VAR 0 3
37687: PUSH
37688: DOUBLE
37689: LD_INT 1
37691: DEC
37692: ST_TO_ADDR
37693: LD_INT 6
37695: PUSH
37696: LD_VAR 0 8
37700: MINUS
37701: PUSH
37702: FOR_TO
37703: IFFALSE 37758
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
37705: LD_ADDR_VAR 0 11
37709: PUSH
37710: LD_VAR 0 11
37714: PPUSH
37715: LD_VAR 0 11
37719: PUSH
37720: LD_INT 1
37722: PLUS
37723: PPUSH
37724: LD_VAR 0 9
37728: PUSH
37729: LD_INT 1
37731: ARRAY
37732: PPUSH
37733: CALL_OW 2
37737: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
37738: LD_ADDR_VAR 0 9
37742: PUSH
37743: LD_VAR 0 9
37747: PPUSH
37748: LD_INT 1
37750: PPUSH
37751: CALL_OW 3
37755: ST_TO_ADDR
// end ;
37756: GO 37702
37758: POP
37759: POP
// end else
37760: GO 37782
// if sort then
37762: LD_VAR 0 9
37766: IFFALSE 37782
// p := sort [ 1 ] ;
37768: LD_ADDR_VAR 0 11
37772: PUSH
37773: LD_VAR 0 9
37777: PUSH
37778: LD_INT 1
37780: ARRAY
37781: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
37782: LD_ADDR_VAR 0 2
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 0
37792: PUSH
37793: LD_INT 0
37795: PUSH
37796: LD_VAR 0 11
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: ST_TO_ADDR
// exit ;
37807: GO 40028
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
37809: LD_EXP 126
37813: PUSH
37814: LD_EXP 125
37818: PUSH
37819: LD_VAR 0 1
37823: ARRAY
37824: ARRAY
37825: PUSH
37826: LD_EXP 99
37830: PUSH
37831: LD_VAR 0 1
37835: ARRAY
37836: PPUSH
37837: LD_INT 2
37839: PUSH
37840: LD_INT 30
37842: PUSH
37843: LD_INT 6
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 30
37852: PUSH
37853: LD_INT 7
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 30
37862: PUSH
37863: LD_INT 8
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: PPUSH
37876: CALL_OW 72
37880: AND
37881: PUSH
37882: LD_EXP 99
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: PPUSH
37893: LD_INT 30
37895: PUSH
37896: LD_INT 3
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PPUSH
37903: CALL_OW 72
37907: AND
37908: IFFALSE 38642
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
37910: LD_ADDR_EXP 141
37914: PUSH
37915: LD_EXP 141
37919: PPUSH
37920: LD_VAR 0 1
37924: PPUSH
37925: LD_INT 3
37927: PPUSH
37928: CALL_OW 1
37932: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
37933: LD_ADDR_VAR 0 2
37937: PUSH
37938: LD_INT 0
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 0
37946: PUSH
37947: LD_INT 0
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: ST_TO_ADDR
// if not eng then
37956: LD_VAR 0 6
37960: NOT
37961: IFFALSE 38024
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
37963: LD_ADDR_VAR 0 11
37967: PUSH
37968: LD_VAR 0 4
37972: PPUSH
37973: LD_INT 2
37975: PPUSH
37976: CALL 101911 0 2
37980: PUSH
37981: LD_INT 1
37983: ARRAY
37984: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
37985: LD_ADDR_VAR 0 2
37989: PUSH
37990: LD_VAR 0 2
37994: PPUSH
37995: LD_INT 2
37997: PPUSH
37998: LD_VAR 0 11
38002: PPUSH
38003: CALL_OW 1
38007: ST_TO_ADDR
// tmp := tmp diff p ;
38008: LD_ADDR_VAR 0 4
38012: PUSH
38013: LD_VAR 0 4
38017: PUSH
38018: LD_VAR 0 11
38022: DIFF
38023: ST_TO_ADDR
// end ; if tmp and sci < 6 then
38024: LD_VAR 0 4
38028: PUSH
38029: LD_VAR 0 8
38033: PUSH
38034: LD_INT 6
38036: LESS
38037: AND
38038: IFFALSE 38226
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
38040: LD_ADDR_VAR 0 9
38044: PUSH
38045: LD_VAR 0 4
38049: PUSH
38050: LD_VAR 0 8
38054: PUSH
38055: LD_VAR 0 7
38059: UNION
38060: DIFF
38061: PPUSH
38062: LD_INT 4
38064: PPUSH
38065: CALL 101911 0 2
38069: ST_TO_ADDR
// p := [ ] ;
38070: LD_ADDR_VAR 0 11
38074: PUSH
38075: EMPTY
38076: ST_TO_ADDR
// if sort then
38077: LD_VAR 0 9
38081: IFFALSE 38197
// for i = 1 to 6 - sci do
38083: LD_ADDR_VAR 0 3
38087: PUSH
38088: DOUBLE
38089: LD_INT 1
38091: DEC
38092: ST_TO_ADDR
38093: LD_INT 6
38095: PUSH
38096: LD_VAR 0 8
38100: MINUS
38101: PUSH
38102: FOR_TO
38103: IFFALSE 38195
// begin if i = sort then
38105: LD_VAR 0 3
38109: PUSH
38110: LD_VAR 0 9
38114: EQUAL
38115: IFFALSE 38119
// break ;
38117: GO 38195
// if GetClass ( i ) = 4 then
38119: LD_VAR 0 3
38123: PPUSH
38124: CALL_OW 257
38128: PUSH
38129: LD_INT 4
38131: EQUAL
38132: IFFALSE 38136
// continue ;
38134: GO 38102
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38136: LD_ADDR_VAR 0 11
38140: PUSH
38141: LD_VAR 0 11
38145: PPUSH
38146: LD_VAR 0 11
38150: PUSH
38151: LD_INT 1
38153: PLUS
38154: PPUSH
38155: LD_VAR 0 9
38159: PUSH
38160: LD_VAR 0 3
38164: ARRAY
38165: PPUSH
38166: CALL_OW 2
38170: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38171: LD_ADDR_VAR 0 4
38175: PUSH
38176: LD_VAR 0 4
38180: PUSH
38181: LD_VAR 0 9
38185: PUSH
38186: LD_VAR 0 3
38190: ARRAY
38191: DIFF
38192: ST_TO_ADDR
// end ;
38193: GO 38102
38195: POP
38196: POP
// if p then
38197: LD_VAR 0 11
38201: IFFALSE 38226
// result := Replace ( result , 4 , p ) ;
38203: LD_ADDR_VAR 0 2
38207: PUSH
38208: LD_VAR 0 2
38212: PPUSH
38213: LD_INT 4
38215: PPUSH
38216: LD_VAR 0 11
38220: PPUSH
38221: CALL_OW 1
38225: ST_TO_ADDR
// end ; if tmp and mech < 6 then
38226: LD_VAR 0 4
38230: PUSH
38231: LD_VAR 0 7
38235: PUSH
38236: LD_INT 6
38238: LESS
38239: AND
38240: IFFALSE 38428
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
38242: LD_ADDR_VAR 0 9
38246: PUSH
38247: LD_VAR 0 4
38251: PUSH
38252: LD_VAR 0 8
38256: PUSH
38257: LD_VAR 0 7
38261: UNION
38262: DIFF
38263: PPUSH
38264: LD_INT 3
38266: PPUSH
38267: CALL 101911 0 2
38271: ST_TO_ADDR
// p := [ ] ;
38272: LD_ADDR_VAR 0 11
38276: PUSH
38277: EMPTY
38278: ST_TO_ADDR
// if sort then
38279: LD_VAR 0 9
38283: IFFALSE 38399
// for i = 1 to 6 - mech do
38285: LD_ADDR_VAR 0 3
38289: PUSH
38290: DOUBLE
38291: LD_INT 1
38293: DEC
38294: ST_TO_ADDR
38295: LD_INT 6
38297: PUSH
38298: LD_VAR 0 7
38302: MINUS
38303: PUSH
38304: FOR_TO
38305: IFFALSE 38397
// begin if i = sort then
38307: LD_VAR 0 3
38311: PUSH
38312: LD_VAR 0 9
38316: EQUAL
38317: IFFALSE 38321
// break ;
38319: GO 38397
// if GetClass ( i ) = 3 then
38321: LD_VAR 0 3
38325: PPUSH
38326: CALL_OW 257
38330: PUSH
38331: LD_INT 3
38333: EQUAL
38334: IFFALSE 38338
// continue ;
38336: GO 38304
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38338: LD_ADDR_VAR 0 11
38342: PUSH
38343: LD_VAR 0 11
38347: PPUSH
38348: LD_VAR 0 11
38352: PUSH
38353: LD_INT 1
38355: PLUS
38356: PPUSH
38357: LD_VAR 0 9
38361: PUSH
38362: LD_VAR 0 3
38366: ARRAY
38367: PPUSH
38368: CALL_OW 2
38372: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38373: LD_ADDR_VAR 0 4
38377: PUSH
38378: LD_VAR 0 4
38382: PUSH
38383: LD_VAR 0 9
38387: PUSH
38388: LD_VAR 0 3
38392: ARRAY
38393: DIFF
38394: ST_TO_ADDR
// end ;
38395: GO 38304
38397: POP
38398: POP
// if p then
38399: LD_VAR 0 11
38403: IFFALSE 38428
// result := Replace ( result , 3 , p ) ;
38405: LD_ADDR_VAR 0 2
38409: PUSH
38410: LD_VAR 0 2
38414: PPUSH
38415: LD_INT 3
38417: PPUSH
38418: LD_VAR 0 11
38422: PPUSH
38423: CALL_OW 1
38427: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
38428: LD_VAR 0 4
38432: PUSH
38433: LD_INT 6
38435: GREATER
38436: PUSH
38437: LD_VAR 0 6
38441: PUSH
38442: LD_INT 6
38444: LESS
38445: AND
38446: IFFALSE 38640
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
38448: LD_ADDR_VAR 0 9
38452: PUSH
38453: LD_VAR 0 4
38457: PUSH
38458: LD_VAR 0 8
38462: PUSH
38463: LD_VAR 0 7
38467: UNION
38468: PUSH
38469: LD_VAR 0 6
38473: UNION
38474: DIFF
38475: PPUSH
38476: LD_INT 2
38478: PPUSH
38479: CALL 101911 0 2
38483: ST_TO_ADDR
// p := [ ] ;
38484: LD_ADDR_VAR 0 11
38488: PUSH
38489: EMPTY
38490: ST_TO_ADDR
// if sort then
38491: LD_VAR 0 9
38495: IFFALSE 38611
// for i = 1 to 6 - eng do
38497: LD_ADDR_VAR 0 3
38501: PUSH
38502: DOUBLE
38503: LD_INT 1
38505: DEC
38506: ST_TO_ADDR
38507: LD_INT 6
38509: PUSH
38510: LD_VAR 0 6
38514: MINUS
38515: PUSH
38516: FOR_TO
38517: IFFALSE 38609
// begin if i = sort then
38519: LD_VAR 0 3
38523: PUSH
38524: LD_VAR 0 9
38528: EQUAL
38529: IFFALSE 38533
// break ;
38531: GO 38609
// if GetClass ( i ) = 2 then
38533: LD_VAR 0 3
38537: PPUSH
38538: CALL_OW 257
38542: PUSH
38543: LD_INT 2
38545: EQUAL
38546: IFFALSE 38550
// continue ;
38548: GO 38516
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38550: LD_ADDR_VAR 0 11
38554: PUSH
38555: LD_VAR 0 11
38559: PPUSH
38560: LD_VAR 0 11
38564: PUSH
38565: LD_INT 1
38567: PLUS
38568: PPUSH
38569: LD_VAR 0 9
38573: PUSH
38574: LD_VAR 0 3
38578: ARRAY
38579: PPUSH
38580: CALL_OW 2
38584: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38585: LD_ADDR_VAR 0 4
38589: PUSH
38590: LD_VAR 0 4
38594: PUSH
38595: LD_VAR 0 9
38599: PUSH
38600: LD_VAR 0 3
38604: ARRAY
38605: DIFF
38606: ST_TO_ADDR
// end ;
38607: GO 38516
38609: POP
38610: POP
// if p then
38611: LD_VAR 0 11
38615: IFFALSE 38640
// result := Replace ( result , 2 , p ) ;
38617: LD_ADDR_VAR 0 2
38621: PUSH
38622: LD_VAR 0 2
38626: PPUSH
38627: LD_INT 2
38629: PPUSH
38630: LD_VAR 0 11
38634: PPUSH
38635: CALL_OW 1
38639: ST_TO_ADDR
// end ; exit ;
38640: GO 40028
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
38642: LD_EXP 126
38646: PUSH
38647: LD_EXP 125
38651: PUSH
38652: LD_VAR 0 1
38656: ARRAY
38657: ARRAY
38658: NOT
38659: PUSH
38660: LD_EXP 99
38664: PUSH
38665: LD_VAR 0 1
38669: ARRAY
38670: PPUSH
38671: LD_INT 30
38673: PUSH
38674: LD_INT 3
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PPUSH
38681: CALL_OW 72
38685: AND
38686: PUSH
38687: LD_EXP 104
38691: PUSH
38692: LD_VAR 0 1
38696: ARRAY
38697: AND
38698: IFFALSE 39306
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
38700: LD_ADDR_EXP 141
38704: PUSH
38705: LD_EXP 141
38709: PPUSH
38710: LD_VAR 0 1
38714: PPUSH
38715: LD_INT 5
38717: PPUSH
38718: CALL_OW 1
38722: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
38723: LD_ADDR_VAR 0 2
38727: PUSH
38728: LD_INT 0
38730: PUSH
38731: LD_INT 0
38733: PUSH
38734: LD_INT 0
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: ST_TO_ADDR
// if sci > 1 then
38746: LD_VAR 0 8
38750: PUSH
38751: LD_INT 1
38753: GREATER
38754: IFFALSE 38782
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
38756: LD_ADDR_VAR 0 4
38760: PUSH
38761: LD_VAR 0 4
38765: PUSH
38766: LD_VAR 0 8
38770: PUSH
38771: LD_VAR 0 8
38775: PUSH
38776: LD_INT 1
38778: ARRAY
38779: DIFF
38780: DIFF
38781: ST_TO_ADDR
// if tmp and not sci then
38782: LD_VAR 0 4
38786: PUSH
38787: LD_VAR 0 8
38791: NOT
38792: AND
38793: IFFALSE 38862
// begin sort := SortBySkill ( tmp , 4 ) ;
38795: LD_ADDR_VAR 0 9
38799: PUSH
38800: LD_VAR 0 4
38804: PPUSH
38805: LD_INT 4
38807: PPUSH
38808: CALL 101911 0 2
38812: ST_TO_ADDR
// if sort then
38813: LD_VAR 0 9
38817: IFFALSE 38833
// p := sort [ 1 ] ;
38819: LD_ADDR_VAR 0 11
38823: PUSH
38824: LD_VAR 0 9
38828: PUSH
38829: LD_INT 1
38831: ARRAY
38832: ST_TO_ADDR
// if p then
38833: LD_VAR 0 11
38837: IFFALSE 38862
// result := Replace ( result , 4 , p ) ;
38839: LD_ADDR_VAR 0 2
38843: PUSH
38844: LD_VAR 0 2
38848: PPUSH
38849: LD_INT 4
38851: PPUSH
38852: LD_VAR 0 11
38856: PPUSH
38857: CALL_OW 1
38861: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
38862: LD_ADDR_VAR 0 4
38866: PUSH
38867: LD_VAR 0 4
38871: PUSH
38872: LD_VAR 0 7
38876: DIFF
38877: ST_TO_ADDR
// if tmp and mech < 6 then
38878: LD_VAR 0 4
38882: PUSH
38883: LD_VAR 0 7
38887: PUSH
38888: LD_INT 6
38890: LESS
38891: AND
38892: IFFALSE 39080
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
38894: LD_ADDR_VAR 0 9
38898: PUSH
38899: LD_VAR 0 4
38903: PUSH
38904: LD_VAR 0 8
38908: PUSH
38909: LD_VAR 0 7
38913: UNION
38914: DIFF
38915: PPUSH
38916: LD_INT 3
38918: PPUSH
38919: CALL 101911 0 2
38923: ST_TO_ADDR
// p := [ ] ;
38924: LD_ADDR_VAR 0 11
38928: PUSH
38929: EMPTY
38930: ST_TO_ADDR
// if sort then
38931: LD_VAR 0 9
38935: IFFALSE 39051
// for i = 1 to 6 - mech do
38937: LD_ADDR_VAR 0 3
38941: PUSH
38942: DOUBLE
38943: LD_INT 1
38945: DEC
38946: ST_TO_ADDR
38947: LD_INT 6
38949: PUSH
38950: LD_VAR 0 7
38954: MINUS
38955: PUSH
38956: FOR_TO
38957: IFFALSE 39049
// begin if i = sort then
38959: LD_VAR 0 3
38963: PUSH
38964: LD_VAR 0 9
38968: EQUAL
38969: IFFALSE 38973
// break ;
38971: GO 39049
// if GetClass ( i ) = 3 then
38973: LD_VAR 0 3
38977: PPUSH
38978: CALL_OW 257
38982: PUSH
38983: LD_INT 3
38985: EQUAL
38986: IFFALSE 38990
// continue ;
38988: GO 38956
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38990: LD_ADDR_VAR 0 11
38994: PUSH
38995: LD_VAR 0 11
38999: PPUSH
39000: LD_VAR 0 11
39004: PUSH
39005: LD_INT 1
39007: PLUS
39008: PPUSH
39009: LD_VAR 0 9
39013: PUSH
39014: LD_VAR 0 3
39018: ARRAY
39019: PPUSH
39020: CALL_OW 2
39024: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39025: LD_ADDR_VAR 0 4
39029: PUSH
39030: LD_VAR 0 4
39034: PUSH
39035: LD_VAR 0 9
39039: PUSH
39040: LD_VAR 0 3
39044: ARRAY
39045: DIFF
39046: ST_TO_ADDR
// end ;
39047: GO 38956
39049: POP
39050: POP
// if p then
39051: LD_VAR 0 11
39055: IFFALSE 39080
// result := Replace ( result , 3 , p ) ;
39057: LD_ADDR_VAR 0 2
39061: PUSH
39062: LD_VAR 0 2
39066: PPUSH
39067: LD_INT 3
39069: PPUSH
39070: LD_VAR 0 11
39074: PPUSH
39075: CALL_OW 1
39079: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
39080: LD_ADDR_VAR 0 4
39084: PUSH
39085: LD_VAR 0 4
39089: PUSH
39090: LD_VAR 0 6
39094: DIFF
39095: ST_TO_ADDR
// if tmp and eng < 6 then
39096: LD_VAR 0 4
39100: PUSH
39101: LD_VAR 0 6
39105: PUSH
39106: LD_INT 6
39108: LESS
39109: AND
39110: IFFALSE 39304
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
39112: LD_ADDR_VAR 0 9
39116: PUSH
39117: LD_VAR 0 4
39121: PUSH
39122: LD_VAR 0 8
39126: PUSH
39127: LD_VAR 0 7
39131: UNION
39132: PUSH
39133: LD_VAR 0 6
39137: UNION
39138: DIFF
39139: PPUSH
39140: LD_INT 2
39142: PPUSH
39143: CALL 101911 0 2
39147: ST_TO_ADDR
// p := [ ] ;
39148: LD_ADDR_VAR 0 11
39152: PUSH
39153: EMPTY
39154: ST_TO_ADDR
// if sort then
39155: LD_VAR 0 9
39159: IFFALSE 39275
// for i = 1 to 6 - eng do
39161: LD_ADDR_VAR 0 3
39165: PUSH
39166: DOUBLE
39167: LD_INT 1
39169: DEC
39170: ST_TO_ADDR
39171: LD_INT 6
39173: PUSH
39174: LD_VAR 0 6
39178: MINUS
39179: PUSH
39180: FOR_TO
39181: IFFALSE 39273
// begin if i = sort then
39183: LD_VAR 0 3
39187: PUSH
39188: LD_VAR 0 9
39192: EQUAL
39193: IFFALSE 39197
// break ;
39195: GO 39273
// if GetClass ( i ) = 2 then
39197: LD_VAR 0 3
39201: PPUSH
39202: CALL_OW 257
39206: PUSH
39207: LD_INT 2
39209: EQUAL
39210: IFFALSE 39214
// continue ;
39212: GO 39180
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39214: LD_ADDR_VAR 0 11
39218: PUSH
39219: LD_VAR 0 11
39223: PPUSH
39224: LD_VAR 0 11
39228: PUSH
39229: LD_INT 1
39231: PLUS
39232: PPUSH
39233: LD_VAR 0 9
39237: PUSH
39238: LD_VAR 0 3
39242: ARRAY
39243: PPUSH
39244: CALL_OW 2
39248: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39249: LD_ADDR_VAR 0 4
39253: PUSH
39254: LD_VAR 0 4
39258: PUSH
39259: LD_VAR 0 9
39263: PUSH
39264: LD_VAR 0 3
39268: ARRAY
39269: DIFF
39270: ST_TO_ADDR
// end ;
39271: GO 39180
39273: POP
39274: POP
// if p then
39275: LD_VAR 0 11
39279: IFFALSE 39304
// result := Replace ( result , 2 , p ) ;
39281: LD_ADDR_VAR 0 2
39285: PUSH
39286: LD_VAR 0 2
39290: PPUSH
39291: LD_INT 2
39293: PPUSH
39294: LD_VAR 0 11
39298: PPUSH
39299: CALL_OW 1
39303: ST_TO_ADDR
// end ; exit ;
39304: GO 40028
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
39306: LD_EXP 126
39310: PUSH
39311: LD_EXP 125
39315: PUSH
39316: LD_VAR 0 1
39320: ARRAY
39321: ARRAY
39322: NOT
39323: PUSH
39324: LD_EXP 99
39328: PUSH
39329: LD_VAR 0 1
39333: ARRAY
39334: PPUSH
39335: LD_INT 30
39337: PUSH
39338: LD_INT 3
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PPUSH
39345: CALL_OW 72
39349: AND
39350: PUSH
39351: LD_EXP 104
39355: PUSH
39356: LD_VAR 0 1
39360: ARRAY
39361: NOT
39362: AND
39363: IFFALSE 40028
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
39365: LD_ADDR_EXP 141
39369: PUSH
39370: LD_EXP 141
39374: PPUSH
39375: LD_VAR 0 1
39379: PPUSH
39380: LD_INT 6
39382: PPUSH
39383: CALL_OW 1
39387: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39388: LD_ADDR_VAR 0 2
39392: PUSH
39393: LD_INT 0
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: LD_INT 0
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: ST_TO_ADDR
// if sci >= 1 then
39411: LD_VAR 0 8
39415: PUSH
39416: LD_INT 1
39418: GREATEREQUAL
39419: IFFALSE 39441
// tmp := tmp diff sci [ 1 ] ;
39421: LD_ADDR_VAR 0 4
39425: PUSH
39426: LD_VAR 0 4
39430: PUSH
39431: LD_VAR 0 8
39435: PUSH
39436: LD_INT 1
39438: ARRAY
39439: DIFF
39440: ST_TO_ADDR
// if tmp and not sci then
39441: LD_VAR 0 4
39445: PUSH
39446: LD_VAR 0 8
39450: NOT
39451: AND
39452: IFFALSE 39521
// begin sort := SortBySkill ( tmp , 4 ) ;
39454: LD_ADDR_VAR 0 9
39458: PUSH
39459: LD_VAR 0 4
39463: PPUSH
39464: LD_INT 4
39466: PPUSH
39467: CALL 101911 0 2
39471: ST_TO_ADDR
// if sort then
39472: LD_VAR 0 9
39476: IFFALSE 39492
// p := sort [ 1 ] ;
39478: LD_ADDR_VAR 0 11
39482: PUSH
39483: LD_VAR 0 9
39487: PUSH
39488: LD_INT 1
39490: ARRAY
39491: ST_TO_ADDR
// if p then
39492: LD_VAR 0 11
39496: IFFALSE 39521
// result := Replace ( result , 4 , p ) ;
39498: LD_ADDR_VAR 0 2
39502: PUSH
39503: LD_VAR 0 2
39507: PPUSH
39508: LD_INT 4
39510: PPUSH
39511: LD_VAR 0 11
39515: PPUSH
39516: CALL_OW 1
39520: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
39521: LD_ADDR_VAR 0 4
39525: PUSH
39526: LD_VAR 0 4
39530: PUSH
39531: LD_VAR 0 7
39535: DIFF
39536: ST_TO_ADDR
// if tmp and mech < 6 then
39537: LD_VAR 0 4
39541: PUSH
39542: LD_VAR 0 7
39546: PUSH
39547: LD_INT 6
39549: LESS
39550: AND
39551: IFFALSE 39733
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
39553: LD_ADDR_VAR 0 9
39557: PUSH
39558: LD_VAR 0 4
39562: PUSH
39563: LD_VAR 0 7
39567: DIFF
39568: PPUSH
39569: LD_INT 3
39571: PPUSH
39572: CALL 101911 0 2
39576: ST_TO_ADDR
// p := [ ] ;
39577: LD_ADDR_VAR 0 11
39581: PUSH
39582: EMPTY
39583: ST_TO_ADDR
// if sort then
39584: LD_VAR 0 9
39588: IFFALSE 39704
// for i = 1 to 6 - mech do
39590: LD_ADDR_VAR 0 3
39594: PUSH
39595: DOUBLE
39596: LD_INT 1
39598: DEC
39599: ST_TO_ADDR
39600: LD_INT 6
39602: PUSH
39603: LD_VAR 0 7
39607: MINUS
39608: PUSH
39609: FOR_TO
39610: IFFALSE 39702
// begin if i = sort then
39612: LD_VAR 0 3
39616: PUSH
39617: LD_VAR 0 9
39621: EQUAL
39622: IFFALSE 39626
// break ;
39624: GO 39702
// if GetClass ( i ) = 3 then
39626: LD_VAR 0 3
39630: PPUSH
39631: CALL_OW 257
39635: PUSH
39636: LD_INT 3
39638: EQUAL
39639: IFFALSE 39643
// continue ;
39641: GO 39609
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39643: LD_ADDR_VAR 0 11
39647: PUSH
39648: LD_VAR 0 11
39652: PPUSH
39653: LD_VAR 0 11
39657: PUSH
39658: LD_INT 1
39660: PLUS
39661: PPUSH
39662: LD_VAR 0 9
39666: PUSH
39667: LD_VAR 0 3
39671: ARRAY
39672: PPUSH
39673: CALL_OW 2
39677: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39678: LD_ADDR_VAR 0 4
39682: PUSH
39683: LD_VAR 0 4
39687: PUSH
39688: LD_VAR 0 9
39692: PUSH
39693: LD_VAR 0 3
39697: ARRAY
39698: DIFF
39699: ST_TO_ADDR
// end ;
39700: GO 39609
39702: POP
39703: POP
// if p then
39704: LD_VAR 0 11
39708: IFFALSE 39733
// result := Replace ( result , 3 , p ) ;
39710: LD_ADDR_VAR 0 2
39714: PUSH
39715: LD_VAR 0 2
39719: PPUSH
39720: LD_INT 3
39722: PPUSH
39723: LD_VAR 0 11
39727: PPUSH
39728: CALL_OW 1
39732: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
39733: LD_ADDR_VAR 0 4
39737: PUSH
39738: LD_VAR 0 4
39742: PUSH
39743: LD_VAR 0 6
39747: DIFF
39748: ST_TO_ADDR
// if tmp and eng < 4 then
39749: LD_VAR 0 4
39753: PUSH
39754: LD_VAR 0 6
39758: PUSH
39759: LD_INT 4
39761: LESS
39762: AND
39763: IFFALSE 39953
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
39765: LD_ADDR_VAR 0 9
39769: PUSH
39770: LD_VAR 0 4
39774: PUSH
39775: LD_VAR 0 7
39779: PUSH
39780: LD_VAR 0 6
39784: UNION
39785: DIFF
39786: PPUSH
39787: LD_INT 2
39789: PPUSH
39790: CALL 101911 0 2
39794: ST_TO_ADDR
// p := [ ] ;
39795: LD_ADDR_VAR 0 11
39799: PUSH
39800: EMPTY
39801: ST_TO_ADDR
// if sort then
39802: LD_VAR 0 9
39806: IFFALSE 39922
// for i = 1 to 4 - eng do
39808: LD_ADDR_VAR 0 3
39812: PUSH
39813: DOUBLE
39814: LD_INT 1
39816: DEC
39817: ST_TO_ADDR
39818: LD_INT 4
39820: PUSH
39821: LD_VAR 0 6
39825: MINUS
39826: PUSH
39827: FOR_TO
39828: IFFALSE 39920
// begin if i = sort then
39830: LD_VAR 0 3
39834: PUSH
39835: LD_VAR 0 9
39839: EQUAL
39840: IFFALSE 39844
// break ;
39842: GO 39920
// if GetClass ( i ) = 2 then
39844: LD_VAR 0 3
39848: PPUSH
39849: CALL_OW 257
39853: PUSH
39854: LD_INT 2
39856: EQUAL
39857: IFFALSE 39861
// continue ;
39859: GO 39827
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39861: LD_ADDR_VAR 0 11
39865: PUSH
39866: LD_VAR 0 11
39870: PPUSH
39871: LD_VAR 0 11
39875: PUSH
39876: LD_INT 1
39878: PLUS
39879: PPUSH
39880: LD_VAR 0 9
39884: PUSH
39885: LD_VAR 0 3
39889: ARRAY
39890: PPUSH
39891: CALL_OW 2
39895: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39896: LD_ADDR_VAR 0 4
39900: PUSH
39901: LD_VAR 0 4
39905: PUSH
39906: LD_VAR 0 9
39910: PUSH
39911: LD_VAR 0 3
39915: ARRAY
39916: DIFF
39917: ST_TO_ADDR
// end ;
39918: GO 39827
39920: POP
39921: POP
// if p then
39922: LD_VAR 0 11
39926: IFFALSE 39951
// result := Replace ( result , 2 , p ) ;
39928: LD_ADDR_VAR 0 2
39932: PUSH
39933: LD_VAR 0 2
39937: PPUSH
39938: LD_INT 2
39940: PPUSH
39941: LD_VAR 0 11
39945: PPUSH
39946: CALL_OW 1
39950: ST_TO_ADDR
// end else
39951: GO 39997
// for i = eng downto 5 do
39953: LD_ADDR_VAR 0 3
39957: PUSH
39958: DOUBLE
39959: LD_VAR 0 6
39963: INC
39964: ST_TO_ADDR
39965: LD_INT 5
39967: PUSH
39968: FOR_DOWNTO
39969: IFFALSE 39995
// tmp := tmp union eng [ i ] ;
39971: LD_ADDR_VAR 0 4
39975: PUSH
39976: LD_VAR 0 4
39980: PUSH
39981: LD_VAR 0 6
39985: PUSH
39986: LD_VAR 0 3
39990: ARRAY
39991: UNION
39992: ST_TO_ADDR
39993: GO 39968
39995: POP
39996: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
39997: LD_ADDR_VAR 0 2
40001: PUSH
40002: LD_VAR 0 2
40006: PPUSH
40007: LD_INT 1
40009: PPUSH
40010: LD_VAR 0 4
40014: PUSH
40015: LD_VAR 0 5
40019: DIFF
40020: PPUSH
40021: CALL_OW 1
40025: ST_TO_ADDR
// exit ;
40026: GO 40028
// end ; end ;
40028: LD_VAR 0 2
40032: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
40033: LD_INT 0
40035: PPUSH
40036: PPUSH
40037: PPUSH
// if not mc_bases then
40038: LD_EXP 99
40042: NOT
40043: IFFALSE 40047
// exit ;
40045: GO 40153
// for i = 1 to mc_bases do
40047: LD_ADDR_VAR 0 2
40051: PUSH
40052: DOUBLE
40053: LD_INT 1
40055: DEC
40056: ST_TO_ADDR
40057: LD_EXP 99
40061: PUSH
40062: FOR_TO
40063: IFFALSE 40144
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40065: LD_ADDR_VAR 0 3
40069: PUSH
40070: LD_EXP 99
40074: PUSH
40075: LD_VAR 0 2
40079: ARRAY
40080: PPUSH
40081: LD_INT 21
40083: PUSH
40084: LD_INT 3
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 3
40093: PUSH
40094: LD_INT 24
40096: PUSH
40097: LD_INT 1000
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PPUSH
40112: CALL_OW 72
40116: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
40117: LD_ADDR_EXP 100
40121: PUSH
40122: LD_EXP 100
40126: PPUSH
40127: LD_VAR 0 2
40131: PPUSH
40132: LD_VAR 0 3
40136: PPUSH
40137: CALL_OW 1
40141: ST_TO_ADDR
// end ;
40142: GO 40062
40144: POP
40145: POP
// RaiseSailEvent ( 101 ) ;
40146: LD_INT 101
40148: PPUSH
40149: CALL_OW 427
// end ;
40153: LD_VAR 0 1
40157: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
40158: LD_INT 0
40160: PPUSH
40161: PPUSH
40162: PPUSH
40163: PPUSH
40164: PPUSH
40165: PPUSH
40166: PPUSH
// if not mc_bases then
40167: LD_EXP 99
40171: NOT
40172: IFFALSE 40176
// exit ;
40174: GO 40749
// for i = 1 to mc_bases do
40176: LD_ADDR_VAR 0 2
40180: PUSH
40181: DOUBLE
40182: LD_INT 1
40184: DEC
40185: ST_TO_ADDR
40186: LD_EXP 99
40190: PUSH
40191: FOR_TO
40192: IFFALSE 40740
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
40194: LD_ADDR_VAR 0 5
40198: PUSH
40199: LD_EXP 99
40203: PUSH
40204: LD_VAR 0 2
40208: ARRAY
40209: PUSH
40210: LD_EXP 128
40214: PUSH
40215: LD_VAR 0 2
40219: ARRAY
40220: UNION
40221: PPUSH
40222: LD_INT 21
40224: PUSH
40225: LD_INT 1
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 1
40234: PUSH
40235: LD_INT 3
40237: PUSH
40238: LD_INT 54
40240: PUSH
40241: EMPTY
40242: LIST
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 3
40250: PUSH
40251: LD_INT 24
40253: PUSH
40254: LD_INT 750
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: LIST
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PPUSH
40274: CALL_OW 72
40278: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
40279: LD_ADDR_VAR 0 6
40283: PUSH
40284: LD_EXP 99
40288: PUSH
40289: LD_VAR 0 2
40293: ARRAY
40294: PPUSH
40295: LD_INT 21
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 1
40307: PUSH
40308: LD_INT 3
40310: PUSH
40311: LD_INT 54
40313: PUSH
40314: EMPTY
40315: LIST
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 3
40323: PUSH
40324: LD_INT 24
40326: PUSH
40327: LD_INT 250
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: EMPTY
40335: LIST
40336: LIST
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: LIST
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PPUSH
40347: CALL_OW 72
40351: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
40352: LD_ADDR_VAR 0 7
40356: PUSH
40357: LD_VAR 0 5
40361: PUSH
40362: LD_VAR 0 6
40366: DIFF
40367: ST_TO_ADDR
// if not need_heal_1 then
40368: LD_VAR 0 6
40372: NOT
40373: IFFALSE 40406
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
40375: LD_ADDR_EXP 102
40379: PUSH
40380: LD_EXP 102
40384: PPUSH
40385: LD_VAR 0 2
40389: PUSH
40390: LD_INT 1
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PPUSH
40397: EMPTY
40398: PPUSH
40399: CALL 67726 0 3
40403: ST_TO_ADDR
40404: GO 40476
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
40406: LD_ADDR_EXP 102
40410: PUSH
40411: LD_EXP 102
40415: PPUSH
40416: LD_VAR 0 2
40420: PUSH
40421: LD_INT 1
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PPUSH
40428: LD_EXP 102
40432: PUSH
40433: LD_VAR 0 2
40437: ARRAY
40438: PUSH
40439: LD_INT 1
40441: ARRAY
40442: PPUSH
40443: LD_INT 3
40445: PUSH
40446: LD_INT 24
40448: PUSH
40449: LD_INT 1000
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PPUSH
40460: CALL_OW 72
40464: PUSH
40465: LD_VAR 0 6
40469: UNION
40470: PPUSH
40471: CALL 67726 0 3
40475: ST_TO_ADDR
// if not need_heal_2 then
40476: LD_VAR 0 7
40480: NOT
40481: IFFALSE 40514
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
40483: LD_ADDR_EXP 102
40487: PUSH
40488: LD_EXP 102
40492: PPUSH
40493: LD_VAR 0 2
40497: PUSH
40498: LD_INT 2
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PPUSH
40505: EMPTY
40506: PPUSH
40507: CALL 67726 0 3
40511: ST_TO_ADDR
40512: GO 40546
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
40514: LD_ADDR_EXP 102
40518: PUSH
40519: LD_EXP 102
40523: PPUSH
40524: LD_VAR 0 2
40528: PUSH
40529: LD_INT 2
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PPUSH
40536: LD_VAR 0 7
40540: PPUSH
40541: CALL 67726 0 3
40545: ST_TO_ADDR
// if need_heal_2 then
40546: LD_VAR 0 7
40550: IFFALSE 40722
// for j in need_heal_2 do
40552: LD_ADDR_VAR 0 3
40556: PUSH
40557: LD_VAR 0 7
40561: PUSH
40562: FOR_IN
40563: IFFALSE 40720
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
40565: LD_ADDR_VAR 0 5
40569: PUSH
40570: LD_EXP 99
40574: PUSH
40575: LD_VAR 0 2
40579: ARRAY
40580: PPUSH
40581: LD_INT 2
40583: PUSH
40584: LD_INT 30
40586: PUSH
40587: LD_INT 6
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 30
40596: PUSH
40597: LD_INT 7
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 30
40606: PUSH
40607: LD_INT 8
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 30
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 30
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 25
40636: PUSH
40637: LD_INT 4
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: PPUSH
40653: CALL_OW 72
40657: ST_TO_ADDR
// if tmp then
40658: LD_VAR 0 5
40662: IFFALSE 40718
// begin k := NearestUnitToUnit ( tmp , j ) ;
40664: LD_ADDR_VAR 0 4
40668: PUSH
40669: LD_VAR 0 5
40673: PPUSH
40674: LD_VAR 0 3
40678: PPUSH
40679: CALL_OW 74
40683: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
40684: LD_VAR 0 3
40688: PPUSH
40689: LD_VAR 0 4
40693: PPUSH
40694: CALL_OW 296
40698: PUSH
40699: LD_INT 7
40701: GREATER
40702: IFFALSE 40718
// ComMoveUnit ( j , k ) ;
40704: LD_VAR 0 3
40708: PPUSH
40709: LD_VAR 0 4
40713: PPUSH
40714: CALL_OW 112
// end ; end ;
40718: GO 40562
40720: POP
40721: POP
// if not need_heal_1 and not need_heal_2 then
40722: LD_VAR 0 6
40726: NOT
40727: PUSH
40728: LD_VAR 0 7
40732: NOT
40733: AND
40734: IFFALSE 40738
// continue ;
40736: GO 40191
// end ;
40738: GO 40191
40740: POP
40741: POP
// RaiseSailEvent ( 102 ) ;
40742: LD_INT 102
40744: PPUSH
40745: CALL_OW 427
// end ;
40749: LD_VAR 0 1
40753: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
40754: LD_INT 0
40756: PPUSH
40757: PPUSH
40758: PPUSH
40759: PPUSH
40760: PPUSH
// if not mc_bases then
40761: LD_EXP 99
40765: NOT
40766: IFFALSE 40770
// exit ;
40768: GO 41155
// for i = 1 to mc_bases do
40770: LD_ADDR_VAR 0 2
40774: PUSH
40775: DOUBLE
40776: LD_INT 1
40778: DEC
40779: ST_TO_ADDR
40780: LD_EXP 99
40784: PUSH
40785: FOR_TO
40786: IFFALSE 41153
// begin if not mc_building_need_repair [ i ] then
40788: LD_EXP 100
40792: PUSH
40793: LD_VAR 0 2
40797: ARRAY
40798: NOT
40799: IFFALSE 40837
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40801: LD_ADDR_EXP 101
40805: PUSH
40806: LD_EXP 101
40810: PPUSH
40811: LD_VAR 0 2
40815: PPUSH
40816: EMPTY
40817: PPUSH
40818: CALL_OW 1
40822: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
40823: LD_VAR 0 2
40827: PPUSH
40828: LD_INT 101
40830: PPUSH
40831: CALL 35875 0 2
// continue ;
40835: GO 40785
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
40837: LD_ADDR_EXP 105
40841: PUSH
40842: LD_EXP 105
40846: PPUSH
40847: LD_VAR 0 2
40851: PPUSH
40852: EMPTY
40853: PPUSH
40854: CALL_OW 1
40858: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
40859: LD_VAR 0 2
40863: PPUSH
40864: LD_INT 103
40866: PPUSH
40867: CALL 35875 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
40871: LD_ADDR_VAR 0 5
40875: PUSH
40876: LD_EXP 99
40880: PUSH
40881: LD_VAR 0 2
40885: ARRAY
40886: PUSH
40887: LD_EXP 128
40891: PUSH
40892: LD_VAR 0 2
40896: ARRAY
40897: UNION
40898: PPUSH
40899: LD_INT 2
40901: PUSH
40902: LD_INT 25
40904: PUSH
40905: LD_INT 2
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 25
40914: PUSH
40915: LD_INT 16
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: LIST
40926: PUSH
40927: EMPTY
40928: LIST
40929: PPUSH
40930: CALL_OW 72
40934: ST_TO_ADDR
// if not tmp then
40935: LD_VAR 0 5
40939: NOT
40940: IFFALSE 40944
// continue ;
40942: GO 40785
// for j in tmp do
40944: LD_ADDR_VAR 0 3
40948: PUSH
40949: LD_VAR 0 5
40953: PUSH
40954: FOR_IN
40955: IFFALSE 41149
// begin if mc_need_heal [ i ] then
40957: LD_EXP 102
40961: PUSH
40962: LD_VAR 0 2
40966: ARRAY
40967: IFFALSE 41015
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
40969: LD_VAR 0 3
40973: PUSH
40974: LD_EXP 102
40978: PUSH
40979: LD_VAR 0 2
40983: ARRAY
40984: PUSH
40985: LD_INT 1
40987: ARRAY
40988: IN
40989: PUSH
40990: LD_VAR 0 3
40994: PUSH
40995: LD_EXP 102
40999: PUSH
41000: LD_VAR 0 2
41004: ARRAY
41005: PUSH
41006: LD_INT 2
41008: ARRAY
41009: IN
41010: OR
41011: IFFALSE 41015
// continue ;
41013: GO 40954
// if IsInUnit ( j ) then
41015: LD_VAR 0 3
41019: PPUSH
41020: CALL_OW 310
41024: IFFALSE 41035
// ComExitBuilding ( j ) ;
41026: LD_VAR 0 3
41030: PPUSH
41031: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
41035: LD_VAR 0 3
41039: PUSH
41040: LD_EXP 101
41044: PUSH
41045: LD_VAR 0 2
41049: ARRAY
41050: IN
41051: NOT
41052: IFFALSE 41110
// begin SetTag ( j , 101 ) ;
41054: LD_VAR 0 3
41058: PPUSH
41059: LD_INT 101
41061: PPUSH
41062: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
41066: LD_ADDR_EXP 101
41070: PUSH
41071: LD_EXP 101
41075: PPUSH
41076: LD_VAR 0 2
41080: PUSH
41081: LD_EXP 101
41085: PUSH
41086: LD_VAR 0 2
41090: ARRAY
41091: PUSH
41092: LD_INT 1
41094: PLUS
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PPUSH
41100: LD_VAR 0 3
41104: PPUSH
41105: CALL 67726 0 3
41109: ST_TO_ADDR
// end ; wait ( 1 ) ;
41110: LD_INT 1
41112: PPUSH
41113: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
41117: LD_VAR 0 3
41121: PPUSH
41122: LD_EXP 100
41126: PUSH
41127: LD_VAR 0 2
41131: ARRAY
41132: PPUSH
41133: LD_VAR 0 3
41137: PPUSH
41138: CALL_OW 74
41142: PPUSH
41143: CALL_OW 130
// end ;
41147: GO 40954
41149: POP
41150: POP
// end ;
41151: GO 40785
41153: POP
41154: POP
// end ;
41155: LD_VAR 0 1
41159: RET
// export function MC_Heal ; var i , j , tmp ; begin
41160: LD_INT 0
41162: PPUSH
41163: PPUSH
41164: PPUSH
41165: PPUSH
// if not mc_bases then
41166: LD_EXP 99
41170: NOT
41171: IFFALSE 41175
// exit ;
41173: GO 41577
// for i = 1 to mc_bases do
41175: LD_ADDR_VAR 0 2
41179: PUSH
41180: DOUBLE
41181: LD_INT 1
41183: DEC
41184: ST_TO_ADDR
41185: LD_EXP 99
41189: PUSH
41190: FOR_TO
41191: IFFALSE 41575
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
41193: LD_EXP 102
41197: PUSH
41198: LD_VAR 0 2
41202: ARRAY
41203: PUSH
41204: LD_INT 1
41206: ARRAY
41207: NOT
41208: PUSH
41209: LD_EXP 102
41213: PUSH
41214: LD_VAR 0 2
41218: ARRAY
41219: PUSH
41220: LD_INT 2
41222: ARRAY
41223: NOT
41224: AND
41225: IFFALSE 41263
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
41227: LD_ADDR_EXP 103
41231: PUSH
41232: LD_EXP 103
41236: PPUSH
41237: LD_VAR 0 2
41241: PPUSH
41242: EMPTY
41243: PPUSH
41244: CALL_OW 1
41248: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
41249: LD_VAR 0 2
41253: PPUSH
41254: LD_INT 102
41256: PPUSH
41257: CALL 35875 0 2
// continue ;
41261: GO 41190
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41263: LD_ADDR_VAR 0 4
41267: PUSH
41268: LD_EXP 99
41272: PUSH
41273: LD_VAR 0 2
41277: ARRAY
41278: PPUSH
41279: LD_INT 25
41281: PUSH
41282: LD_INT 4
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PPUSH
41289: CALL_OW 72
41293: ST_TO_ADDR
// if not tmp then
41294: LD_VAR 0 4
41298: NOT
41299: IFFALSE 41303
// continue ;
41301: GO 41190
// if mc_taming [ i ] then
41303: LD_EXP 130
41307: PUSH
41308: LD_VAR 0 2
41312: ARRAY
41313: IFFALSE 41337
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41315: LD_ADDR_EXP 130
41319: PUSH
41320: LD_EXP 130
41324: PPUSH
41325: LD_VAR 0 2
41329: PPUSH
41330: EMPTY
41331: PPUSH
41332: CALL_OW 1
41336: ST_TO_ADDR
// for j in tmp do
41337: LD_ADDR_VAR 0 3
41341: PUSH
41342: LD_VAR 0 4
41346: PUSH
41347: FOR_IN
41348: IFFALSE 41571
// begin if IsInUnit ( j ) then
41350: LD_VAR 0 3
41354: PPUSH
41355: CALL_OW 310
41359: IFFALSE 41370
// ComExitBuilding ( j ) ;
41361: LD_VAR 0 3
41365: PPUSH
41366: CALL_OW 122
// if not j in mc_healers [ i ] then
41370: LD_VAR 0 3
41374: PUSH
41375: LD_EXP 103
41379: PUSH
41380: LD_VAR 0 2
41384: ARRAY
41385: IN
41386: NOT
41387: IFFALSE 41433
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
41389: LD_ADDR_EXP 103
41393: PUSH
41394: LD_EXP 103
41398: PPUSH
41399: LD_VAR 0 2
41403: PUSH
41404: LD_EXP 103
41408: PUSH
41409: LD_VAR 0 2
41413: ARRAY
41414: PUSH
41415: LD_INT 1
41417: PLUS
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PPUSH
41423: LD_VAR 0 3
41427: PPUSH
41428: CALL 67726 0 3
41432: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
41433: LD_VAR 0 3
41437: PPUSH
41438: CALL_OW 110
41442: PUSH
41443: LD_INT 102
41445: NONEQUAL
41446: IFFALSE 41460
// SetTag ( j , 102 ) ;
41448: LD_VAR 0 3
41452: PPUSH
41453: LD_INT 102
41455: PPUSH
41456: CALL_OW 109
// Wait ( 3 ) ;
41460: LD_INT 3
41462: PPUSH
41463: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
41467: LD_EXP 102
41471: PUSH
41472: LD_VAR 0 2
41476: ARRAY
41477: PUSH
41478: LD_INT 1
41480: ARRAY
41481: IFFALSE 41513
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
41483: LD_VAR 0 3
41487: PPUSH
41488: LD_EXP 102
41492: PUSH
41493: LD_VAR 0 2
41497: ARRAY
41498: PUSH
41499: LD_INT 1
41501: ARRAY
41502: PUSH
41503: LD_INT 1
41505: ARRAY
41506: PPUSH
41507: CALL_OW 128
41511: GO 41569
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
41513: LD_VAR 0 3
41517: PPUSH
41518: CALL_OW 314
41522: NOT
41523: PUSH
41524: LD_EXP 102
41528: PUSH
41529: LD_VAR 0 2
41533: ARRAY
41534: PUSH
41535: LD_INT 2
41537: ARRAY
41538: AND
41539: IFFALSE 41569
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
41541: LD_VAR 0 3
41545: PPUSH
41546: LD_EXP 102
41550: PUSH
41551: LD_VAR 0 2
41555: ARRAY
41556: PUSH
41557: LD_INT 2
41559: ARRAY
41560: PUSH
41561: LD_INT 1
41563: ARRAY
41564: PPUSH
41565: CALL_OW 128
// end ;
41569: GO 41347
41571: POP
41572: POP
// end ;
41573: GO 41190
41575: POP
41576: POP
// end ;
41577: LD_VAR 0 1
41581: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
41582: LD_INT 0
41584: PPUSH
41585: PPUSH
41586: PPUSH
41587: PPUSH
41588: PPUSH
// if not mc_bases then
41589: LD_EXP 99
41593: NOT
41594: IFFALSE 41598
// exit ;
41596: GO 42741
// for i = 1 to mc_bases do
41598: LD_ADDR_VAR 0 2
41602: PUSH
41603: DOUBLE
41604: LD_INT 1
41606: DEC
41607: ST_TO_ADDR
41608: LD_EXP 99
41612: PUSH
41613: FOR_TO
41614: IFFALSE 42739
// begin if mc_scan [ i ] then
41616: LD_EXP 122
41620: PUSH
41621: LD_VAR 0 2
41625: ARRAY
41626: IFFALSE 41630
// continue ;
41628: GO 41613
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
41630: LD_EXP 104
41634: PUSH
41635: LD_VAR 0 2
41639: ARRAY
41640: NOT
41641: PUSH
41642: LD_EXP 106
41646: PUSH
41647: LD_VAR 0 2
41651: ARRAY
41652: NOT
41653: AND
41654: PUSH
41655: LD_EXP 105
41659: PUSH
41660: LD_VAR 0 2
41664: ARRAY
41665: AND
41666: IFFALSE 41704
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
41668: LD_ADDR_EXP 105
41672: PUSH
41673: LD_EXP 105
41677: PPUSH
41678: LD_VAR 0 2
41682: PPUSH
41683: EMPTY
41684: PPUSH
41685: CALL_OW 1
41689: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
41690: LD_VAR 0 2
41694: PPUSH
41695: LD_INT 103
41697: PPUSH
41698: CALL 35875 0 2
// continue ;
41702: GO 41613
// end ; if mc_construct_list [ i ] then
41704: LD_EXP 106
41708: PUSH
41709: LD_VAR 0 2
41713: ARRAY
41714: IFFALSE 41934
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
41716: LD_ADDR_VAR 0 4
41720: PUSH
41721: LD_EXP 99
41725: PUSH
41726: LD_VAR 0 2
41730: ARRAY
41731: PPUSH
41732: LD_INT 25
41734: PUSH
41735: LD_INT 2
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PPUSH
41742: CALL_OW 72
41746: PUSH
41747: LD_EXP 101
41751: PUSH
41752: LD_VAR 0 2
41756: ARRAY
41757: DIFF
41758: ST_TO_ADDR
// if not tmp then
41759: LD_VAR 0 4
41763: NOT
41764: IFFALSE 41768
// continue ;
41766: GO 41613
// for j in tmp do
41768: LD_ADDR_VAR 0 3
41772: PUSH
41773: LD_VAR 0 4
41777: PUSH
41778: FOR_IN
41779: IFFALSE 41930
// begin if not mc_builders [ i ] then
41781: LD_EXP 105
41785: PUSH
41786: LD_VAR 0 2
41790: ARRAY
41791: NOT
41792: IFFALSE 41850
// begin SetTag ( j , 103 ) ;
41794: LD_VAR 0 3
41798: PPUSH
41799: LD_INT 103
41801: PPUSH
41802: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
41806: LD_ADDR_EXP 105
41810: PUSH
41811: LD_EXP 105
41815: PPUSH
41816: LD_VAR 0 2
41820: PUSH
41821: LD_EXP 105
41825: PUSH
41826: LD_VAR 0 2
41830: ARRAY
41831: PUSH
41832: LD_INT 1
41834: PLUS
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PPUSH
41840: LD_VAR 0 3
41844: PPUSH
41845: CALL 67726 0 3
41849: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
41850: LD_VAR 0 3
41854: PPUSH
41855: CALL_OW 310
41859: IFFALSE 41870
// ComExitBuilding ( j ) ;
41861: LD_VAR 0 3
41865: PPUSH
41866: CALL_OW 122
// wait ( 3 ) ;
41870: LD_INT 3
41872: PPUSH
41873: CALL_OW 67
// if not mc_construct_list [ i ] then
41877: LD_EXP 106
41881: PUSH
41882: LD_VAR 0 2
41886: ARRAY
41887: NOT
41888: IFFALSE 41892
// break ;
41890: GO 41930
// if not HasTask ( j ) then
41892: LD_VAR 0 3
41896: PPUSH
41897: CALL_OW 314
41901: NOT
41902: IFFALSE 41928
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
41904: LD_VAR 0 3
41908: PPUSH
41909: LD_EXP 106
41913: PUSH
41914: LD_VAR 0 2
41918: ARRAY
41919: PUSH
41920: LD_INT 1
41922: ARRAY
41923: PPUSH
41924: CALL 70577 0 2
// end ;
41928: GO 41778
41930: POP
41931: POP
// end else
41932: GO 42737
// if mc_build_list [ i ] then
41934: LD_EXP 104
41938: PUSH
41939: LD_VAR 0 2
41943: ARRAY
41944: IFFALSE 42737
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41946: LD_ADDR_VAR 0 5
41950: PUSH
41951: LD_EXP 99
41955: PUSH
41956: LD_VAR 0 2
41960: ARRAY
41961: PPUSH
41962: LD_INT 2
41964: PUSH
41965: LD_INT 30
41967: PUSH
41968: LD_INT 0
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 30
41977: PUSH
41978: LD_INT 1
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: LIST
41989: PPUSH
41990: CALL_OW 72
41994: ST_TO_ADDR
// if depot then
41995: LD_VAR 0 5
41999: IFFALSE 42017
// depot := depot [ 1 ] else
42001: LD_ADDR_VAR 0 5
42005: PUSH
42006: LD_VAR 0 5
42010: PUSH
42011: LD_INT 1
42013: ARRAY
42014: ST_TO_ADDR
42015: GO 42025
// depot := 0 ;
42017: LD_ADDR_VAR 0 5
42021: PUSH
42022: LD_INT 0
42024: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
42025: LD_EXP 104
42029: PUSH
42030: LD_VAR 0 2
42034: ARRAY
42035: PUSH
42036: LD_INT 1
42038: ARRAY
42039: PUSH
42040: LD_INT 1
42042: ARRAY
42043: PPUSH
42044: CALL 70407 0 1
42048: PUSH
42049: LD_EXP 99
42053: PUSH
42054: LD_VAR 0 2
42058: ARRAY
42059: PPUSH
42060: LD_INT 2
42062: PUSH
42063: LD_INT 30
42065: PUSH
42066: LD_INT 2
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 30
42075: PUSH
42076: LD_INT 3
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: LIST
42087: PPUSH
42088: CALL_OW 72
42092: NOT
42093: AND
42094: IFFALSE 42199
// begin for j = 1 to mc_build_list [ i ] do
42096: LD_ADDR_VAR 0 3
42100: PUSH
42101: DOUBLE
42102: LD_INT 1
42104: DEC
42105: ST_TO_ADDR
42106: LD_EXP 104
42110: PUSH
42111: LD_VAR 0 2
42115: ARRAY
42116: PUSH
42117: FOR_TO
42118: IFFALSE 42197
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
42120: LD_EXP 104
42124: PUSH
42125: LD_VAR 0 2
42129: ARRAY
42130: PUSH
42131: LD_VAR 0 3
42135: ARRAY
42136: PUSH
42137: LD_INT 1
42139: ARRAY
42140: PUSH
42141: LD_INT 2
42143: EQUAL
42144: IFFALSE 42195
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
42146: LD_ADDR_EXP 104
42150: PUSH
42151: LD_EXP 104
42155: PPUSH
42156: LD_VAR 0 2
42160: PPUSH
42161: LD_EXP 104
42165: PUSH
42166: LD_VAR 0 2
42170: ARRAY
42171: PPUSH
42172: LD_VAR 0 3
42176: PPUSH
42177: LD_INT 1
42179: PPUSH
42180: LD_INT 0
42182: PPUSH
42183: CALL 67144 0 4
42187: PPUSH
42188: CALL_OW 1
42192: ST_TO_ADDR
// break ;
42193: GO 42197
// end ;
42195: GO 42117
42197: POP
42198: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
42199: LD_EXP 104
42203: PUSH
42204: LD_VAR 0 2
42208: ARRAY
42209: PUSH
42210: LD_INT 1
42212: ARRAY
42213: PUSH
42214: LD_INT 1
42216: ARRAY
42217: PUSH
42218: LD_INT 0
42220: EQUAL
42221: PUSH
42222: LD_VAR 0 5
42226: PUSH
42227: LD_VAR 0 5
42231: PPUSH
42232: LD_EXP 104
42236: PUSH
42237: LD_VAR 0 2
42241: ARRAY
42242: PUSH
42243: LD_INT 1
42245: ARRAY
42246: PUSH
42247: LD_INT 1
42249: ARRAY
42250: PPUSH
42251: LD_EXP 104
42255: PUSH
42256: LD_VAR 0 2
42260: ARRAY
42261: PUSH
42262: LD_INT 1
42264: ARRAY
42265: PUSH
42266: LD_INT 2
42268: ARRAY
42269: PPUSH
42270: LD_EXP 104
42274: PUSH
42275: LD_VAR 0 2
42279: ARRAY
42280: PUSH
42281: LD_INT 1
42283: ARRAY
42284: PUSH
42285: LD_INT 3
42287: ARRAY
42288: PPUSH
42289: LD_EXP 104
42293: PUSH
42294: LD_VAR 0 2
42298: ARRAY
42299: PUSH
42300: LD_INT 1
42302: ARRAY
42303: PUSH
42304: LD_INT 4
42306: ARRAY
42307: PPUSH
42308: CALL 75123 0 5
42312: AND
42313: OR
42314: IFFALSE 42595
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
42316: LD_ADDR_VAR 0 4
42320: PUSH
42321: LD_EXP 99
42325: PUSH
42326: LD_VAR 0 2
42330: ARRAY
42331: PPUSH
42332: LD_INT 25
42334: PUSH
42335: LD_INT 2
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PPUSH
42342: CALL_OW 72
42346: PUSH
42347: LD_EXP 101
42351: PUSH
42352: LD_VAR 0 2
42356: ARRAY
42357: DIFF
42358: ST_TO_ADDR
// if not tmp then
42359: LD_VAR 0 4
42363: NOT
42364: IFFALSE 42368
// continue ;
42366: GO 41613
// for j in tmp do
42368: LD_ADDR_VAR 0 3
42372: PUSH
42373: LD_VAR 0 4
42377: PUSH
42378: FOR_IN
42379: IFFALSE 42591
// begin if not mc_builders [ i ] then
42381: LD_EXP 105
42385: PUSH
42386: LD_VAR 0 2
42390: ARRAY
42391: NOT
42392: IFFALSE 42450
// begin SetTag ( j , 103 ) ;
42394: LD_VAR 0 3
42398: PPUSH
42399: LD_INT 103
42401: PPUSH
42402: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
42406: LD_ADDR_EXP 105
42410: PUSH
42411: LD_EXP 105
42415: PPUSH
42416: LD_VAR 0 2
42420: PUSH
42421: LD_EXP 105
42425: PUSH
42426: LD_VAR 0 2
42430: ARRAY
42431: PUSH
42432: LD_INT 1
42434: PLUS
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PPUSH
42440: LD_VAR 0 3
42444: PPUSH
42445: CALL 67726 0 3
42449: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
42450: LD_VAR 0 3
42454: PPUSH
42455: CALL_OW 310
42459: IFFALSE 42470
// ComExitBuilding ( j ) ;
42461: LD_VAR 0 3
42465: PPUSH
42466: CALL_OW 122
// wait ( 3 ) ;
42470: LD_INT 3
42472: PPUSH
42473: CALL_OW 67
// if not mc_build_list [ i ] then
42477: LD_EXP 104
42481: PUSH
42482: LD_VAR 0 2
42486: ARRAY
42487: NOT
42488: IFFALSE 42492
// break ;
42490: GO 42591
// if not HasTask ( j ) then
42492: LD_VAR 0 3
42496: PPUSH
42497: CALL_OW 314
42501: NOT
42502: IFFALSE 42589
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
42504: LD_VAR 0 3
42508: PPUSH
42509: LD_EXP 104
42513: PUSH
42514: LD_VAR 0 2
42518: ARRAY
42519: PUSH
42520: LD_INT 1
42522: ARRAY
42523: PUSH
42524: LD_INT 1
42526: ARRAY
42527: PPUSH
42528: LD_EXP 104
42532: PUSH
42533: LD_VAR 0 2
42537: ARRAY
42538: PUSH
42539: LD_INT 1
42541: ARRAY
42542: PUSH
42543: LD_INT 2
42545: ARRAY
42546: PPUSH
42547: LD_EXP 104
42551: PUSH
42552: LD_VAR 0 2
42556: ARRAY
42557: PUSH
42558: LD_INT 1
42560: ARRAY
42561: PUSH
42562: LD_INT 3
42564: ARRAY
42565: PPUSH
42566: LD_EXP 104
42570: PUSH
42571: LD_VAR 0 2
42575: ARRAY
42576: PUSH
42577: LD_INT 1
42579: ARRAY
42580: PUSH
42581: LD_INT 4
42583: ARRAY
42584: PPUSH
42585: CALL_OW 145
// end ;
42589: GO 42378
42591: POP
42592: POP
// end else
42593: GO 42737
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
42595: LD_EXP 99
42599: PUSH
42600: LD_VAR 0 2
42604: ARRAY
42605: PPUSH
42606: LD_EXP 104
42610: PUSH
42611: LD_VAR 0 2
42615: ARRAY
42616: PUSH
42617: LD_INT 1
42619: ARRAY
42620: PUSH
42621: LD_INT 1
42623: ARRAY
42624: PPUSH
42625: LD_EXP 104
42629: PUSH
42630: LD_VAR 0 2
42634: ARRAY
42635: PUSH
42636: LD_INT 1
42638: ARRAY
42639: PUSH
42640: LD_INT 2
42642: ARRAY
42643: PPUSH
42644: LD_EXP 104
42648: PUSH
42649: LD_VAR 0 2
42653: ARRAY
42654: PUSH
42655: LD_INT 1
42657: ARRAY
42658: PUSH
42659: LD_INT 3
42661: ARRAY
42662: PPUSH
42663: LD_EXP 104
42667: PUSH
42668: LD_VAR 0 2
42672: ARRAY
42673: PUSH
42674: LD_INT 1
42676: ARRAY
42677: PUSH
42678: LD_INT 4
42680: ARRAY
42681: PPUSH
42682: CALL 74477 0 5
42686: NOT
42687: IFFALSE 42737
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
42689: LD_ADDR_EXP 104
42693: PUSH
42694: LD_EXP 104
42698: PPUSH
42699: LD_VAR 0 2
42703: PPUSH
42704: LD_EXP 104
42708: PUSH
42709: LD_VAR 0 2
42713: ARRAY
42714: PPUSH
42715: LD_INT 1
42717: PPUSH
42718: LD_INT 1
42720: NEG
42721: PPUSH
42722: LD_INT 0
42724: PPUSH
42725: CALL 67144 0 4
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// continue ;
42735: GO 41613
// end ; end ; end ;
42737: GO 41613
42739: POP
42740: POP
// end ;
42741: LD_VAR 0 1
42745: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
42746: LD_INT 0
42748: PPUSH
42749: PPUSH
42750: PPUSH
42751: PPUSH
42752: PPUSH
42753: PPUSH
// if not mc_bases then
42754: LD_EXP 99
42758: NOT
42759: IFFALSE 42763
// exit ;
42761: GO 43190
// for i = 1 to mc_bases do
42763: LD_ADDR_VAR 0 2
42767: PUSH
42768: DOUBLE
42769: LD_INT 1
42771: DEC
42772: ST_TO_ADDR
42773: LD_EXP 99
42777: PUSH
42778: FOR_TO
42779: IFFALSE 43188
// begin tmp := mc_build_upgrade [ i ] ;
42781: LD_ADDR_VAR 0 4
42785: PUSH
42786: LD_EXP 131
42790: PUSH
42791: LD_VAR 0 2
42795: ARRAY
42796: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
42797: LD_ADDR_VAR 0 6
42801: PUSH
42802: LD_EXP 132
42806: PUSH
42807: LD_VAR 0 2
42811: ARRAY
42812: PPUSH
42813: LD_INT 2
42815: PUSH
42816: LD_INT 30
42818: PUSH
42819: LD_INT 6
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 30
42828: PUSH
42829: LD_INT 7
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: LIST
42840: PPUSH
42841: CALL_OW 72
42845: ST_TO_ADDR
// if not tmp and not lab then
42846: LD_VAR 0 4
42850: NOT
42851: PUSH
42852: LD_VAR 0 6
42856: NOT
42857: AND
42858: IFFALSE 42862
// continue ;
42860: GO 42778
// if tmp then
42862: LD_VAR 0 4
42866: IFFALSE 42986
// for j in tmp do
42868: LD_ADDR_VAR 0 3
42872: PUSH
42873: LD_VAR 0 4
42877: PUSH
42878: FOR_IN
42879: IFFALSE 42984
// begin if UpgradeCost ( j ) then
42881: LD_VAR 0 3
42885: PPUSH
42886: CALL 74137 0 1
42890: IFFALSE 42982
// begin ComUpgrade ( j ) ;
42892: LD_VAR 0 3
42896: PPUSH
42897: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
42901: LD_ADDR_EXP 131
42905: PUSH
42906: LD_EXP 131
42910: PPUSH
42911: LD_VAR 0 2
42915: PPUSH
42916: LD_EXP 131
42920: PUSH
42921: LD_VAR 0 2
42925: ARRAY
42926: PUSH
42927: LD_VAR 0 3
42931: DIFF
42932: PPUSH
42933: CALL_OW 1
42937: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
42938: LD_ADDR_EXP 106
42942: PUSH
42943: LD_EXP 106
42947: PPUSH
42948: LD_VAR 0 2
42952: PUSH
42953: LD_EXP 106
42957: PUSH
42958: LD_VAR 0 2
42962: ARRAY
42963: PUSH
42964: LD_INT 1
42966: PLUS
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PPUSH
42972: LD_VAR 0 3
42976: PPUSH
42977: CALL 67726 0 3
42981: ST_TO_ADDR
// end ; end ;
42982: GO 42878
42984: POP
42985: POP
// if not lab or not mc_lab_upgrade [ i ] then
42986: LD_VAR 0 6
42990: NOT
42991: PUSH
42992: LD_EXP 133
42996: PUSH
42997: LD_VAR 0 2
43001: ARRAY
43002: NOT
43003: OR
43004: IFFALSE 43008
// continue ;
43006: GO 42778
// for j in lab do
43008: LD_ADDR_VAR 0 3
43012: PUSH
43013: LD_VAR 0 6
43017: PUSH
43018: FOR_IN
43019: IFFALSE 43184
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
43021: LD_VAR 0 3
43025: PPUSH
43026: CALL_OW 266
43030: PUSH
43031: LD_INT 6
43033: PUSH
43034: LD_INT 7
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: IN
43041: PUSH
43042: LD_VAR 0 3
43046: PPUSH
43047: CALL_OW 461
43051: PUSH
43052: LD_INT 1
43054: NONEQUAL
43055: AND
43056: IFFALSE 43182
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
43058: LD_VAR 0 3
43062: PPUSH
43063: LD_EXP 133
43067: PUSH
43068: LD_VAR 0 2
43072: ARRAY
43073: PUSH
43074: LD_INT 1
43076: ARRAY
43077: PPUSH
43078: CALL 74342 0 2
43082: IFFALSE 43182
// begin ComCancel ( j ) ;
43084: LD_VAR 0 3
43088: PPUSH
43089: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
43093: LD_VAR 0 3
43097: PPUSH
43098: LD_EXP 133
43102: PUSH
43103: LD_VAR 0 2
43107: ARRAY
43108: PUSH
43109: LD_INT 1
43111: ARRAY
43112: PPUSH
43113: CALL_OW 207
// if not j in mc_construct_list [ i ] then
43117: LD_VAR 0 3
43121: PUSH
43122: LD_EXP 106
43126: PUSH
43127: LD_VAR 0 2
43131: ARRAY
43132: IN
43133: NOT
43134: IFFALSE 43180
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
43136: LD_ADDR_EXP 106
43140: PUSH
43141: LD_EXP 106
43145: PPUSH
43146: LD_VAR 0 2
43150: PUSH
43151: LD_EXP 106
43155: PUSH
43156: LD_VAR 0 2
43160: ARRAY
43161: PUSH
43162: LD_INT 1
43164: PLUS
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PPUSH
43170: LD_VAR 0 3
43174: PPUSH
43175: CALL 67726 0 3
43179: ST_TO_ADDR
// break ;
43180: GO 43184
// end ; end ; end ;
43182: GO 43018
43184: POP
43185: POP
// end ;
43186: GO 42778
43188: POP
43189: POP
// end ;
43190: LD_VAR 0 1
43194: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
43195: LD_INT 0
43197: PPUSH
43198: PPUSH
43199: PPUSH
43200: PPUSH
43201: PPUSH
43202: PPUSH
43203: PPUSH
43204: PPUSH
43205: PPUSH
// if not mc_bases then
43206: LD_EXP 99
43210: NOT
43211: IFFALSE 43215
// exit ;
43213: GO 43620
// for i = 1 to mc_bases do
43215: LD_ADDR_VAR 0 2
43219: PUSH
43220: DOUBLE
43221: LD_INT 1
43223: DEC
43224: ST_TO_ADDR
43225: LD_EXP 99
43229: PUSH
43230: FOR_TO
43231: IFFALSE 43618
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
43233: LD_EXP 107
43237: PUSH
43238: LD_VAR 0 2
43242: ARRAY
43243: NOT
43244: PUSH
43245: LD_EXP 99
43249: PUSH
43250: LD_VAR 0 2
43254: ARRAY
43255: PPUSH
43256: LD_INT 30
43258: PUSH
43259: LD_INT 3
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PPUSH
43266: CALL_OW 72
43270: NOT
43271: OR
43272: IFFALSE 43276
// continue ;
43274: GO 43230
// busy := false ;
43276: LD_ADDR_VAR 0 8
43280: PUSH
43281: LD_INT 0
43283: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
43284: LD_ADDR_VAR 0 4
43288: PUSH
43289: LD_EXP 99
43293: PUSH
43294: LD_VAR 0 2
43298: ARRAY
43299: PPUSH
43300: LD_INT 30
43302: PUSH
43303: LD_INT 3
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PPUSH
43310: CALL_OW 72
43314: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
43315: LD_ADDR_VAR 0 6
43319: PUSH
43320: LD_EXP 107
43324: PUSH
43325: LD_VAR 0 2
43329: ARRAY
43330: PPUSH
43331: LD_INT 2
43333: PUSH
43334: LD_INT 30
43336: PUSH
43337: LD_INT 32
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 30
43346: PUSH
43347: LD_INT 33
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: LIST
43358: PPUSH
43359: CALL_OW 72
43363: ST_TO_ADDR
// if not t then
43364: LD_VAR 0 6
43368: NOT
43369: IFFALSE 43373
// continue ;
43371: GO 43230
// for j in tmp do
43373: LD_ADDR_VAR 0 3
43377: PUSH
43378: LD_VAR 0 4
43382: PUSH
43383: FOR_IN
43384: IFFALSE 43414
// if not BuildingStatus ( j ) = bs_idle then
43386: LD_VAR 0 3
43390: PPUSH
43391: CALL_OW 461
43395: PUSH
43396: LD_INT 2
43398: EQUAL
43399: NOT
43400: IFFALSE 43412
// begin busy := true ;
43402: LD_ADDR_VAR 0 8
43406: PUSH
43407: LD_INT 1
43409: ST_TO_ADDR
// break ;
43410: GO 43414
// end ;
43412: GO 43383
43414: POP
43415: POP
// if busy then
43416: LD_VAR 0 8
43420: IFFALSE 43424
// continue ;
43422: GO 43230
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
43424: LD_ADDR_VAR 0 7
43428: PUSH
43429: LD_VAR 0 6
43433: PPUSH
43434: LD_INT 35
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PPUSH
43444: CALL_OW 72
43448: ST_TO_ADDR
// if tw then
43449: LD_VAR 0 7
43453: IFFALSE 43530
// begin tw := tw [ 1 ] ;
43455: LD_ADDR_VAR 0 7
43459: PUSH
43460: LD_VAR 0 7
43464: PUSH
43465: LD_INT 1
43467: ARRAY
43468: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
43469: LD_ADDR_VAR 0 9
43473: PUSH
43474: LD_VAR 0 7
43478: PPUSH
43479: LD_EXP 124
43483: PUSH
43484: LD_VAR 0 2
43488: ARRAY
43489: PPUSH
43490: CALL 72696 0 2
43494: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
43495: LD_EXP 138
43499: PUSH
43500: LD_VAR 0 2
43504: ARRAY
43505: IFFALSE 43528
// if not weapon in mc_allowed_tower_weapons [ i ] then
43507: LD_VAR 0 9
43511: PUSH
43512: LD_EXP 138
43516: PUSH
43517: LD_VAR 0 2
43521: ARRAY
43522: IN
43523: NOT
43524: IFFALSE 43528
// continue ;
43526: GO 43230
// end else
43528: GO 43593
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
43530: LD_ADDR_VAR 0 5
43534: PUSH
43535: LD_EXP 107
43539: PUSH
43540: LD_VAR 0 2
43544: ARRAY
43545: PPUSH
43546: LD_VAR 0 4
43550: PPUSH
43551: CALL 102835 0 2
43555: ST_TO_ADDR
// if not tmp2 then
43556: LD_VAR 0 5
43560: NOT
43561: IFFALSE 43565
// continue ;
43563: GO 43230
// tw := tmp2 [ 1 ] ;
43565: LD_ADDR_VAR 0 7
43569: PUSH
43570: LD_VAR 0 5
43574: PUSH
43575: LD_INT 1
43577: ARRAY
43578: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
43579: LD_ADDR_VAR 0 9
43583: PUSH
43584: LD_VAR 0 5
43588: PUSH
43589: LD_INT 2
43591: ARRAY
43592: ST_TO_ADDR
// end ; if not weapon then
43593: LD_VAR 0 9
43597: NOT
43598: IFFALSE 43602
// continue ;
43600: GO 43230
// ComPlaceWeapon ( tw , weapon ) ;
43602: LD_VAR 0 7
43606: PPUSH
43607: LD_VAR 0 9
43611: PPUSH
43612: CALL_OW 148
// end ;
43616: GO 43230
43618: POP
43619: POP
// end ;
43620: LD_VAR 0 1
43624: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
43625: LD_INT 0
43627: PPUSH
43628: PPUSH
43629: PPUSH
43630: PPUSH
43631: PPUSH
43632: PPUSH
// if not mc_bases then
43633: LD_EXP 99
43637: NOT
43638: IFFALSE 43642
// exit ;
43640: GO 44654
// for i = 1 to mc_bases do
43642: LD_ADDR_VAR 0 2
43646: PUSH
43647: DOUBLE
43648: LD_INT 1
43650: DEC
43651: ST_TO_ADDR
43652: LD_EXP 99
43656: PUSH
43657: FOR_TO
43658: IFFALSE 44652
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
43660: LD_EXP 112
43664: PUSH
43665: LD_VAR 0 2
43669: ARRAY
43670: NOT
43671: PUSH
43672: LD_EXP 112
43676: PUSH
43677: LD_VAR 0 2
43681: ARRAY
43682: PUSH
43683: LD_EXP 113
43687: PUSH
43688: LD_VAR 0 2
43692: ARRAY
43693: EQUAL
43694: OR
43695: IFFALSE 43699
// continue ;
43697: GO 43657
// if mc_miners [ i ] then
43699: LD_EXP 113
43703: PUSH
43704: LD_VAR 0 2
43708: ARRAY
43709: IFFALSE 44339
// begin k := 1 ;
43711: LD_ADDR_VAR 0 4
43715: PUSH
43716: LD_INT 1
43718: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
43719: LD_ADDR_VAR 0 3
43723: PUSH
43724: DOUBLE
43725: LD_EXP 113
43729: PUSH
43730: LD_VAR 0 2
43734: ARRAY
43735: INC
43736: ST_TO_ADDR
43737: LD_INT 1
43739: PUSH
43740: FOR_DOWNTO
43741: IFFALSE 44337
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
43743: LD_EXP 113
43747: PUSH
43748: LD_VAR 0 2
43752: ARRAY
43753: PUSH
43754: LD_VAR 0 3
43758: ARRAY
43759: PPUSH
43760: CALL_OW 301
43764: PUSH
43765: LD_EXP 113
43769: PUSH
43770: LD_VAR 0 2
43774: ARRAY
43775: PUSH
43776: LD_VAR 0 3
43780: ARRAY
43781: PPUSH
43782: CALL_OW 257
43786: PUSH
43787: LD_INT 1
43789: NONEQUAL
43790: OR
43791: IFFALSE 43854
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
43793: LD_ADDR_VAR 0 5
43797: PUSH
43798: LD_EXP 113
43802: PUSH
43803: LD_VAR 0 2
43807: ARRAY
43808: PUSH
43809: LD_EXP 113
43813: PUSH
43814: LD_VAR 0 2
43818: ARRAY
43819: PUSH
43820: LD_VAR 0 3
43824: ARRAY
43825: DIFF
43826: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
43827: LD_ADDR_EXP 113
43831: PUSH
43832: LD_EXP 113
43836: PPUSH
43837: LD_VAR 0 2
43841: PPUSH
43842: LD_VAR 0 5
43846: PPUSH
43847: CALL_OW 1
43851: ST_TO_ADDR
// continue ;
43852: GO 43740
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
43854: LD_EXP 113
43858: PUSH
43859: LD_VAR 0 2
43863: ARRAY
43864: PUSH
43865: LD_VAR 0 3
43869: ARRAY
43870: PPUSH
43871: CALL 67662 0 1
43875: PUSH
43876: LD_EXP 113
43880: PUSH
43881: LD_VAR 0 2
43885: ARRAY
43886: PUSH
43887: LD_VAR 0 3
43891: ARRAY
43892: PPUSH
43893: CALL_OW 255
43897: PPUSH
43898: LD_EXP 112
43902: PUSH
43903: LD_VAR 0 2
43907: ARRAY
43908: PUSH
43909: LD_VAR 0 4
43913: ARRAY
43914: PUSH
43915: LD_INT 1
43917: ARRAY
43918: PPUSH
43919: LD_EXP 112
43923: PUSH
43924: LD_VAR 0 2
43928: ARRAY
43929: PUSH
43930: LD_VAR 0 4
43934: ARRAY
43935: PUSH
43936: LD_INT 2
43938: ARRAY
43939: PPUSH
43940: LD_INT 15
43942: PPUSH
43943: CALL 68622 0 4
43947: PUSH
43948: LD_INT 4
43950: ARRAY
43951: PUSH
43952: LD_EXP 113
43956: PUSH
43957: LD_VAR 0 2
43961: ARRAY
43962: PUSH
43963: LD_VAR 0 3
43967: ARRAY
43968: PPUSH
43969: LD_INT 10
43971: PPUSH
43972: CALL 70319 0 2
43976: PUSH
43977: LD_INT 4
43979: ARRAY
43980: OR
43981: AND
43982: IFFALSE 44005
// ComStop ( mc_miners [ i ] [ j ] ) ;
43984: LD_EXP 113
43988: PUSH
43989: LD_VAR 0 2
43993: ARRAY
43994: PUSH
43995: LD_VAR 0 3
43999: ARRAY
44000: PPUSH
44001: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
44005: LD_EXP 113
44009: PUSH
44010: LD_VAR 0 2
44014: ARRAY
44015: PUSH
44016: LD_VAR 0 3
44020: ARRAY
44021: PPUSH
44022: CALL_OW 257
44026: PUSH
44027: LD_INT 1
44029: EQUAL
44030: PUSH
44031: LD_EXP 113
44035: PUSH
44036: LD_VAR 0 2
44040: ARRAY
44041: PUSH
44042: LD_VAR 0 3
44046: ARRAY
44047: PPUSH
44048: CALL_OW 459
44052: NOT
44053: AND
44054: PUSH
44055: LD_EXP 113
44059: PUSH
44060: LD_VAR 0 2
44064: ARRAY
44065: PUSH
44066: LD_VAR 0 3
44070: ARRAY
44071: PPUSH
44072: CALL_OW 255
44076: PPUSH
44077: LD_EXP 112
44081: PUSH
44082: LD_VAR 0 2
44086: ARRAY
44087: PUSH
44088: LD_VAR 0 4
44092: ARRAY
44093: PUSH
44094: LD_INT 1
44096: ARRAY
44097: PPUSH
44098: LD_EXP 112
44102: PUSH
44103: LD_VAR 0 2
44107: ARRAY
44108: PUSH
44109: LD_VAR 0 4
44113: ARRAY
44114: PUSH
44115: LD_INT 2
44117: ARRAY
44118: PPUSH
44119: LD_INT 15
44121: PPUSH
44122: CALL 68622 0 4
44126: PUSH
44127: LD_INT 4
44129: ARRAY
44130: PUSH
44131: LD_INT 0
44133: EQUAL
44134: AND
44135: PUSH
44136: LD_EXP 113
44140: PUSH
44141: LD_VAR 0 2
44145: ARRAY
44146: PUSH
44147: LD_VAR 0 3
44151: ARRAY
44152: PPUSH
44153: CALL_OW 314
44157: NOT
44158: AND
44159: IFFALSE 44335
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
44161: LD_EXP 113
44165: PUSH
44166: LD_VAR 0 2
44170: ARRAY
44171: PUSH
44172: LD_VAR 0 3
44176: ARRAY
44177: PPUSH
44178: CALL_OW 310
44182: IFFALSE 44205
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
44184: LD_EXP 113
44188: PUSH
44189: LD_VAR 0 2
44193: ARRAY
44194: PUSH
44195: LD_VAR 0 3
44199: ARRAY
44200: PPUSH
44201: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
44205: LD_EXP 113
44209: PUSH
44210: LD_VAR 0 2
44214: ARRAY
44215: PUSH
44216: LD_VAR 0 3
44220: ARRAY
44221: PPUSH
44222: CALL_OW 314
44226: NOT
44227: IFFALSE 44295
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
44229: LD_EXP 113
44233: PUSH
44234: LD_VAR 0 2
44238: ARRAY
44239: PUSH
44240: LD_VAR 0 3
44244: ARRAY
44245: PPUSH
44246: LD_EXP 112
44250: PUSH
44251: LD_VAR 0 2
44255: ARRAY
44256: PUSH
44257: LD_VAR 0 4
44261: ARRAY
44262: PUSH
44263: LD_INT 1
44265: ARRAY
44266: PPUSH
44267: LD_EXP 112
44271: PUSH
44272: LD_VAR 0 2
44276: ARRAY
44277: PUSH
44278: LD_VAR 0 4
44282: ARRAY
44283: PUSH
44284: LD_INT 2
44286: ARRAY
44287: PPUSH
44288: LD_INT 0
44290: PPUSH
44291: CALL_OW 193
// k := k + 1 ;
44295: LD_ADDR_VAR 0 4
44299: PUSH
44300: LD_VAR 0 4
44304: PUSH
44305: LD_INT 1
44307: PLUS
44308: ST_TO_ADDR
// if k > mc_mines [ i ] then
44309: LD_VAR 0 4
44313: PUSH
44314: LD_EXP 112
44318: PUSH
44319: LD_VAR 0 2
44323: ARRAY
44324: GREATER
44325: IFFALSE 44335
// k := 1 ;
44327: LD_ADDR_VAR 0 4
44331: PUSH
44332: LD_INT 1
44334: ST_TO_ADDR
// end ; end ;
44335: GO 43740
44337: POP
44338: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
44339: LD_ADDR_VAR 0 5
44343: PUSH
44344: LD_EXP 99
44348: PUSH
44349: LD_VAR 0 2
44353: ARRAY
44354: PPUSH
44355: LD_INT 2
44357: PUSH
44358: LD_INT 30
44360: PUSH
44361: LD_INT 4
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 30
44370: PUSH
44371: LD_INT 5
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 30
44380: PUSH
44381: LD_INT 32
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: PPUSH
44394: CALL_OW 72
44398: ST_TO_ADDR
// if not tmp then
44399: LD_VAR 0 5
44403: NOT
44404: IFFALSE 44408
// continue ;
44406: GO 43657
// list := [ ] ;
44408: LD_ADDR_VAR 0 6
44412: PUSH
44413: EMPTY
44414: ST_TO_ADDR
// for j in tmp do
44415: LD_ADDR_VAR 0 3
44419: PUSH
44420: LD_VAR 0 5
44424: PUSH
44425: FOR_IN
44426: IFFALSE 44495
// begin for k in UnitsInside ( j ) do
44428: LD_ADDR_VAR 0 4
44432: PUSH
44433: LD_VAR 0 3
44437: PPUSH
44438: CALL_OW 313
44442: PUSH
44443: FOR_IN
44444: IFFALSE 44491
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
44446: LD_VAR 0 4
44450: PPUSH
44451: CALL_OW 257
44455: PUSH
44456: LD_INT 1
44458: EQUAL
44459: PUSH
44460: LD_VAR 0 4
44464: PPUSH
44465: CALL_OW 459
44469: NOT
44470: AND
44471: IFFALSE 44489
// list := list ^ k ;
44473: LD_ADDR_VAR 0 6
44477: PUSH
44478: LD_VAR 0 6
44482: PUSH
44483: LD_VAR 0 4
44487: ADD
44488: ST_TO_ADDR
44489: GO 44443
44491: POP
44492: POP
// end ;
44493: GO 44425
44495: POP
44496: POP
// list := list diff mc_miners [ i ] ;
44497: LD_ADDR_VAR 0 6
44501: PUSH
44502: LD_VAR 0 6
44506: PUSH
44507: LD_EXP 113
44511: PUSH
44512: LD_VAR 0 2
44516: ARRAY
44517: DIFF
44518: ST_TO_ADDR
// if not list then
44519: LD_VAR 0 6
44523: NOT
44524: IFFALSE 44528
// continue ;
44526: GO 43657
// k := mc_mines [ i ] - mc_miners [ i ] ;
44528: LD_ADDR_VAR 0 4
44532: PUSH
44533: LD_EXP 112
44537: PUSH
44538: LD_VAR 0 2
44542: ARRAY
44543: PUSH
44544: LD_EXP 113
44548: PUSH
44549: LD_VAR 0 2
44553: ARRAY
44554: MINUS
44555: ST_TO_ADDR
// if k > list then
44556: LD_VAR 0 4
44560: PUSH
44561: LD_VAR 0 6
44565: GREATER
44566: IFFALSE 44578
// k := list ;
44568: LD_ADDR_VAR 0 4
44572: PUSH
44573: LD_VAR 0 6
44577: ST_TO_ADDR
// for j = 1 to k do
44578: LD_ADDR_VAR 0 3
44582: PUSH
44583: DOUBLE
44584: LD_INT 1
44586: DEC
44587: ST_TO_ADDR
44588: LD_VAR 0 4
44592: PUSH
44593: FOR_TO
44594: IFFALSE 44648
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
44596: LD_ADDR_EXP 113
44600: PUSH
44601: LD_EXP 113
44605: PPUSH
44606: LD_VAR 0 2
44610: PUSH
44611: LD_EXP 113
44615: PUSH
44616: LD_VAR 0 2
44620: ARRAY
44621: PUSH
44622: LD_INT 1
44624: PLUS
44625: PUSH
44626: EMPTY
44627: LIST
44628: LIST
44629: PPUSH
44630: LD_VAR 0 6
44634: PUSH
44635: LD_VAR 0 3
44639: ARRAY
44640: PPUSH
44641: CALL 67726 0 3
44645: ST_TO_ADDR
44646: GO 44593
44648: POP
44649: POP
// end ;
44650: GO 43657
44652: POP
44653: POP
// end ;
44654: LD_VAR 0 1
44658: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
44659: LD_INT 0
44661: PPUSH
44662: PPUSH
44663: PPUSH
44664: PPUSH
44665: PPUSH
44666: PPUSH
44667: PPUSH
44668: PPUSH
44669: PPUSH
44670: PPUSH
// if not mc_bases then
44671: LD_EXP 99
44675: NOT
44676: IFFALSE 44680
// exit ;
44678: GO 46411
// for i = 1 to mc_bases do
44680: LD_ADDR_VAR 0 2
44684: PUSH
44685: DOUBLE
44686: LD_INT 1
44688: DEC
44689: ST_TO_ADDR
44690: LD_EXP 99
44694: PUSH
44695: FOR_TO
44696: IFFALSE 46409
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
44698: LD_EXP 99
44702: PUSH
44703: LD_VAR 0 2
44707: ARRAY
44708: NOT
44709: PUSH
44710: LD_EXP 106
44714: PUSH
44715: LD_VAR 0 2
44719: ARRAY
44720: OR
44721: IFFALSE 44725
// continue ;
44723: GO 44695
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
44725: LD_EXP 115
44729: PUSH
44730: LD_VAR 0 2
44734: ARRAY
44735: NOT
44736: PUSH
44737: LD_EXP 116
44741: PUSH
44742: LD_VAR 0 2
44746: ARRAY
44747: AND
44748: IFFALSE 44786
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
44750: LD_ADDR_EXP 116
44754: PUSH
44755: LD_EXP 116
44759: PPUSH
44760: LD_VAR 0 2
44764: PPUSH
44765: EMPTY
44766: PPUSH
44767: CALL_OW 1
44771: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
44772: LD_VAR 0 2
44776: PPUSH
44777: LD_INT 107
44779: PPUSH
44780: CALL 35875 0 2
// continue ;
44784: GO 44695
// end ; target := [ ] ;
44786: LD_ADDR_VAR 0 6
44790: PUSH
44791: EMPTY
44792: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
44793: LD_ADDR_VAR 0 3
44797: PUSH
44798: DOUBLE
44799: LD_EXP 115
44803: PUSH
44804: LD_VAR 0 2
44808: ARRAY
44809: INC
44810: ST_TO_ADDR
44811: LD_INT 1
44813: PUSH
44814: FOR_DOWNTO
44815: IFFALSE 45075
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
44817: LD_EXP 115
44821: PUSH
44822: LD_VAR 0 2
44826: ARRAY
44827: PUSH
44828: LD_VAR 0 3
44832: ARRAY
44833: PUSH
44834: LD_INT 2
44836: ARRAY
44837: PPUSH
44838: LD_EXP 115
44842: PUSH
44843: LD_VAR 0 2
44847: ARRAY
44848: PUSH
44849: LD_VAR 0 3
44853: ARRAY
44854: PUSH
44855: LD_INT 3
44857: ARRAY
44858: PPUSH
44859: CALL_OW 488
44863: PUSH
44864: LD_EXP 115
44868: PUSH
44869: LD_VAR 0 2
44873: ARRAY
44874: PUSH
44875: LD_VAR 0 3
44879: ARRAY
44880: PUSH
44881: LD_INT 2
44883: ARRAY
44884: PPUSH
44885: LD_EXP 115
44889: PUSH
44890: LD_VAR 0 2
44894: ARRAY
44895: PUSH
44896: LD_VAR 0 3
44900: ARRAY
44901: PUSH
44902: LD_INT 3
44904: ARRAY
44905: PPUSH
44906: CALL_OW 284
44910: PUSH
44911: LD_INT 0
44913: EQUAL
44914: AND
44915: IFFALSE 44970
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
44917: LD_ADDR_VAR 0 5
44921: PUSH
44922: LD_EXP 115
44926: PUSH
44927: LD_VAR 0 2
44931: ARRAY
44932: PPUSH
44933: LD_VAR 0 3
44937: PPUSH
44938: CALL_OW 3
44942: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
44943: LD_ADDR_EXP 115
44947: PUSH
44948: LD_EXP 115
44952: PPUSH
44953: LD_VAR 0 2
44957: PPUSH
44958: LD_VAR 0 5
44962: PPUSH
44963: CALL_OW 1
44967: ST_TO_ADDR
// continue ;
44968: GO 44814
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
44970: LD_EXP 99
44974: PUSH
44975: LD_VAR 0 2
44979: ARRAY
44980: PUSH
44981: LD_INT 1
44983: ARRAY
44984: PPUSH
44985: CALL_OW 255
44989: PPUSH
44990: LD_EXP 115
44994: PUSH
44995: LD_VAR 0 2
44999: ARRAY
45000: PUSH
45001: LD_VAR 0 3
45005: ARRAY
45006: PUSH
45007: LD_INT 2
45009: ARRAY
45010: PPUSH
45011: LD_EXP 115
45015: PUSH
45016: LD_VAR 0 2
45020: ARRAY
45021: PUSH
45022: LD_VAR 0 3
45026: ARRAY
45027: PUSH
45028: LD_INT 3
45030: ARRAY
45031: PPUSH
45032: LD_INT 30
45034: PPUSH
45035: CALL 68622 0 4
45039: PUSH
45040: LD_INT 4
45042: ARRAY
45043: PUSH
45044: LD_INT 0
45046: EQUAL
45047: IFFALSE 45073
// begin target := mc_crates [ i ] [ j ] ;
45049: LD_ADDR_VAR 0 6
45053: PUSH
45054: LD_EXP 115
45058: PUSH
45059: LD_VAR 0 2
45063: ARRAY
45064: PUSH
45065: LD_VAR 0 3
45069: ARRAY
45070: ST_TO_ADDR
// break ;
45071: GO 45075
// end ; end ;
45073: GO 44814
45075: POP
45076: POP
// if not target then
45077: LD_VAR 0 6
45081: NOT
45082: IFFALSE 45086
// continue ;
45084: GO 44695
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
45086: LD_ADDR_VAR 0 7
45090: PUSH
45091: LD_EXP 118
45095: PUSH
45096: LD_VAR 0 2
45100: ARRAY
45101: PPUSH
45102: LD_INT 2
45104: PUSH
45105: LD_INT 3
45107: PUSH
45108: LD_INT 58
45110: PUSH
45111: EMPTY
45112: LIST
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 61
45120: PUSH
45121: EMPTY
45122: LIST
45123: PUSH
45124: LD_INT 33
45126: PUSH
45127: LD_INT 5
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 33
45136: PUSH
45137: LD_INT 3
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 2
45153: PUSH
45154: LD_INT 34
45156: PUSH
45157: LD_INT 32
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 34
45166: PUSH
45167: LD_INT 51
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 34
45176: PUSH
45177: LD_INT 12
45179: PUSH
45180: EMPTY
45181: LIST
45182: LIST
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: PPUSH
45194: CALL_OW 72
45198: ST_TO_ADDR
// if not cargo then
45199: LD_VAR 0 7
45203: NOT
45204: IFFALSE 45847
// begin if mc_crates_collector [ i ] < 5 then
45206: LD_EXP 116
45210: PUSH
45211: LD_VAR 0 2
45215: ARRAY
45216: PUSH
45217: LD_INT 5
45219: LESS
45220: IFFALSE 45586
// begin if mc_ape [ i ] then
45222: LD_EXP 128
45226: PUSH
45227: LD_VAR 0 2
45231: ARRAY
45232: IFFALSE 45279
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
45234: LD_ADDR_VAR 0 5
45238: PUSH
45239: LD_EXP 128
45243: PUSH
45244: LD_VAR 0 2
45248: ARRAY
45249: PPUSH
45250: LD_INT 25
45252: PUSH
45253: LD_INT 16
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 24
45262: PUSH
45263: LD_INT 750
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PPUSH
45274: CALL_OW 72
45278: ST_TO_ADDR
// if not tmp then
45279: LD_VAR 0 5
45283: NOT
45284: IFFALSE 45331
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
45286: LD_ADDR_VAR 0 5
45290: PUSH
45291: LD_EXP 99
45295: PUSH
45296: LD_VAR 0 2
45300: ARRAY
45301: PPUSH
45302: LD_INT 25
45304: PUSH
45305: LD_INT 2
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 24
45314: PUSH
45315: LD_INT 750
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PPUSH
45326: CALL_OW 72
45330: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
45331: LD_EXP 128
45335: PUSH
45336: LD_VAR 0 2
45340: ARRAY
45341: PUSH
45342: LD_EXP 99
45346: PUSH
45347: LD_VAR 0 2
45351: ARRAY
45352: PPUSH
45353: LD_INT 25
45355: PUSH
45356: LD_INT 2
45358: PUSH
45359: EMPTY
45360: LIST
45361: LIST
45362: PUSH
45363: LD_INT 24
45365: PUSH
45366: LD_INT 750
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PPUSH
45377: CALL_OW 72
45381: AND
45382: PUSH
45383: LD_VAR 0 5
45387: PUSH
45388: LD_INT 5
45390: LESS
45391: AND
45392: IFFALSE 45474
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
45394: LD_ADDR_VAR 0 3
45398: PUSH
45399: LD_EXP 99
45403: PUSH
45404: LD_VAR 0 2
45408: ARRAY
45409: PPUSH
45410: LD_INT 25
45412: PUSH
45413: LD_INT 2
45415: PUSH
45416: EMPTY
45417: LIST
45418: LIST
45419: PUSH
45420: LD_INT 24
45422: PUSH
45423: LD_INT 750
45425: PUSH
45426: EMPTY
45427: LIST
45428: LIST
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PPUSH
45434: CALL_OW 72
45438: PUSH
45439: FOR_IN
45440: IFFALSE 45472
// begin tmp := tmp union j ;
45442: LD_ADDR_VAR 0 5
45446: PUSH
45447: LD_VAR 0 5
45451: PUSH
45452: LD_VAR 0 3
45456: UNION
45457: ST_TO_ADDR
// if tmp >= 5 then
45458: LD_VAR 0 5
45462: PUSH
45463: LD_INT 5
45465: GREATEREQUAL
45466: IFFALSE 45470
// break ;
45468: GO 45472
// end ;
45470: GO 45439
45472: POP
45473: POP
// end ; if not tmp then
45474: LD_VAR 0 5
45478: NOT
45479: IFFALSE 45483
// continue ;
45481: GO 44695
// for j in tmp do
45483: LD_ADDR_VAR 0 3
45487: PUSH
45488: LD_VAR 0 5
45492: PUSH
45493: FOR_IN
45494: IFFALSE 45584
// if not GetTag ( j ) then
45496: LD_VAR 0 3
45500: PPUSH
45501: CALL_OW 110
45505: NOT
45506: IFFALSE 45582
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
45508: LD_ADDR_EXP 116
45512: PUSH
45513: LD_EXP 116
45517: PPUSH
45518: LD_VAR 0 2
45522: PUSH
45523: LD_EXP 116
45527: PUSH
45528: LD_VAR 0 2
45532: ARRAY
45533: PUSH
45534: LD_INT 1
45536: PLUS
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PPUSH
45542: LD_VAR 0 3
45546: PPUSH
45547: CALL 67726 0 3
45551: ST_TO_ADDR
// SetTag ( j , 107 ) ;
45552: LD_VAR 0 3
45556: PPUSH
45557: LD_INT 107
45559: PPUSH
45560: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
45564: LD_EXP 116
45568: PUSH
45569: LD_VAR 0 2
45573: ARRAY
45574: PUSH
45575: LD_INT 5
45577: GREATEREQUAL
45578: IFFALSE 45582
// break ;
45580: GO 45584
// end ;
45582: GO 45493
45584: POP
45585: POP
// end ; if mc_crates_collector [ i ] and target then
45586: LD_EXP 116
45590: PUSH
45591: LD_VAR 0 2
45595: ARRAY
45596: PUSH
45597: LD_VAR 0 6
45601: AND
45602: IFFALSE 45845
// begin if mc_crates_collector [ i ] < target [ 1 ] then
45604: LD_EXP 116
45608: PUSH
45609: LD_VAR 0 2
45613: ARRAY
45614: PUSH
45615: LD_VAR 0 6
45619: PUSH
45620: LD_INT 1
45622: ARRAY
45623: LESS
45624: IFFALSE 45644
// tmp := mc_crates_collector [ i ] else
45626: LD_ADDR_VAR 0 5
45630: PUSH
45631: LD_EXP 116
45635: PUSH
45636: LD_VAR 0 2
45640: ARRAY
45641: ST_TO_ADDR
45642: GO 45658
// tmp := target [ 1 ] ;
45644: LD_ADDR_VAR 0 5
45648: PUSH
45649: LD_VAR 0 6
45653: PUSH
45654: LD_INT 1
45656: ARRAY
45657: ST_TO_ADDR
// k := 0 ;
45658: LD_ADDR_VAR 0 4
45662: PUSH
45663: LD_INT 0
45665: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
45666: LD_ADDR_VAR 0 3
45670: PUSH
45671: LD_EXP 116
45675: PUSH
45676: LD_VAR 0 2
45680: ARRAY
45681: PUSH
45682: FOR_IN
45683: IFFALSE 45843
// begin k := k + 1 ;
45685: LD_ADDR_VAR 0 4
45689: PUSH
45690: LD_VAR 0 4
45694: PUSH
45695: LD_INT 1
45697: PLUS
45698: ST_TO_ADDR
// if k > tmp then
45699: LD_VAR 0 4
45703: PUSH
45704: LD_VAR 0 5
45708: GREATER
45709: IFFALSE 45713
// break ;
45711: GO 45843
// if not GetClass ( j ) in [ 2 , 16 ] then
45713: LD_VAR 0 3
45717: PPUSH
45718: CALL_OW 257
45722: PUSH
45723: LD_INT 2
45725: PUSH
45726: LD_INT 16
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: IN
45733: NOT
45734: IFFALSE 45787
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
45736: LD_ADDR_EXP 116
45740: PUSH
45741: LD_EXP 116
45745: PPUSH
45746: LD_VAR 0 2
45750: PPUSH
45751: LD_EXP 116
45755: PUSH
45756: LD_VAR 0 2
45760: ARRAY
45761: PUSH
45762: LD_VAR 0 3
45766: DIFF
45767: PPUSH
45768: CALL_OW 1
45772: ST_TO_ADDR
// SetTag ( j , 0 ) ;
45773: LD_VAR 0 3
45777: PPUSH
45778: LD_INT 0
45780: PPUSH
45781: CALL_OW 109
// continue ;
45785: GO 45682
// end ; if IsInUnit ( j ) then
45787: LD_VAR 0 3
45791: PPUSH
45792: CALL_OW 310
45796: IFFALSE 45807
// ComExitBuilding ( j ) ;
45798: LD_VAR 0 3
45802: PPUSH
45803: CALL_OW 122
// wait ( 3 ) ;
45807: LD_INT 3
45809: PPUSH
45810: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
45814: LD_VAR 0 3
45818: PPUSH
45819: LD_VAR 0 6
45823: PUSH
45824: LD_INT 2
45826: ARRAY
45827: PPUSH
45828: LD_VAR 0 6
45832: PUSH
45833: LD_INT 3
45835: ARRAY
45836: PPUSH
45837: CALL_OW 117
// end ;
45841: GO 45682
45843: POP
45844: POP
// end ; end else
45845: GO 46407
// begin for j in cargo do
45847: LD_ADDR_VAR 0 3
45851: PUSH
45852: LD_VAR 0 7
45856: PUSH
45857: FOR_IN
45858: IFFALSE 46405
// begin if GetTag ( j ) <> 0 then
45860: LD_VAR 0 3
45864: PPUSH
45865: CALL_OW 110
45869: PUSH
45870: LD_INT 0
45872: NONEQUAL
45873: IFFALSE 45877
// continue ;
45875: GO 45857
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
45877: LD_VAR 0 3
45881: PPUSH
45882: CALL_OW 256
45886: PUSH
45887: LD_INT 1000
45889: LESS
45890: PUSH
45891: LD_VAR 0 3
45895: PPUSH
45896: LD_EXP 123
45900: PUSH
45901: LD_VAR 0 2
45905: ARRAY
45906: PPUSH
45907: CALL_OW 308
45911: NOT
45912: AND
45913: IFFALSE 45935
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45915: LD_VAR 0 3
45919: PPUSH
45920: LD_EXP 123
45924: PUSH
45925: LD_VAR 0 2
45929: ARRAY
45930: PPUSH
45931: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
45935: LD_VAR 0 3
45939: PPUSH
45940: CALL_OW 256
45944: PUSH
45945: LD_INT 1000
45947: LESS
45948: PUSH
45949: LD_VAR 0 3
45953: PPUSH
45954: LD_EXP 123
45958: PUSH
45959: LD_VAR 0 2
45963: ARRAY
45964: PPUSH
45965: CALL_OW 308
45969: AND
45970: IFFALSE 45974
// continue ;
45972: GO 45857
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
45974: LD_VAR 0 3
45978: PPUSH
45979: CALL_OW 262
45983: PUSH
45984: LD_INT 2
45986: EQUAL
45987: PUSH
45988: LD_VAR 0 3
45992: PPUSH
45993: CALL_OW 261
45997: PUSH
45998: LD_INT 15
46000: LESS
46001: AND
46002: IFFALSE 46006
// continue ;
46004: GO 45857
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
46006: LD_VAR 0 3
46010: PPUSH
46011: CALL_OW 262
46015: PUSH
46016: LD_INT 1
46018: EQUAL
46019: PUSH
46020: LD_VAR 0 3
46024: PPUSH
46025: CALL_OW 261
46029: PUSH
46030: LD_INT 10
46032: LESS
46033: AND
46034: IFFALSE 46344
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46036: LD_ADDR_VAR 0 8
46040: PUSH
46041: LD_EXP 99
46045: PUSH
46046: LD_VAR 0 2
46050: ARRAY
46051: PPUSH
46052: LD_INT 2
46054: PUSH
46055: LD_INT 30
46057: PUSH
46058: LD_INT 0
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: LD_INT 30
46067: PUSH
46068: LD_INT 1
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: LIST
46079: PPUSH
46080: CALL_OW 72
46084: ST_TO_ADDR
// if not depot then
46085: LD_VAR 0 8
46089: NOT
46090: IFFALSE 46094
// continue ;
46092: GO 45857
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
46094: LD_VAR 0 3
46098: PPUSH
46099: LD_VAR 0 8
46103: PPUSH
46104: LD_VAR 0 3
46108: PPUSH
46109: CALL_OW 74
46113: PPUSH
46114: CALL_OW 296
46118: PUSH
46119: LD_INT 6
46121: LESS
46122: IFFALSE 46138
// SetFuel ( j , 100 ) else
46124: LD_VAR 0 3
46128: PPUSH
46129: LD_INT 100
46131: PPUSH
46132: CALL_OW 240
46136: GO 46344
// if GetFuel ( j ) = 0 then
46138: LD_VAR 0 3
46142: PPUSH
46143: CALL_OW 261
46147: PUSH
46148: LD_INT 0
46150: EQUAL
46151: IFFALSE 46344
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
46153: LD_ADDR_EXP 118
46157: PUSH
46158: LD_EXP 118
46162: PPUSH
46163: LD_VAR 0 2
46167: PPUSH
46168: LD_EXP 118
46172: PUSH
46173: LD_VAR 0 2
46177: ARRAY
46178: PUSH
46179: LD_VAR 0 3
46183: DIFF
46184: PPUSH
46185: CALL_OW 1
46189: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
46190: LD_VAR 0 3
46194: PPUSH
46195: CALL_OW 263
46199: PUSH
46200: LD_INT 1
46202: EQUAL
46203: IFFALSE 46219
// ComExitVehicle ( IsInUnit ( j ) ) ;
46205: LD_VAR 0 3
46209: PPUSH
46210: CALL_OW 310
46214: PPUSH
46215: CALL_OW 121
// if GetControl ( j ) = control_remote then
46219: LD_VAR 0 3
46223: PPUSH
46224: CALL_OW 263
46228: PUSH
46229: LD_INT 2
46231: EQUAL
46232: IFFALSE 46243
// ComUnlink ( j ) ;
46234: LD_VAR 0 3
46238: PPUSH
46239: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
46243: LD_ADDR_VAR 0 9
46247: PUSH
46248: LD_VAR 0 2
46252: PPUSH
46253: LD_INT 3
46255: PPUSH
46256: CALL 55506 0 2
46260: ST_TO_ADDR
// if fac then
46261: LD_VAR 0 9
46265: IFFALSE 46342
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
46267: LD_ADDR_VAR 0 10
46271: PUSH
46272: LD_VAR 0 9
46276: PPUSH
46277: LD_VAR 0 3
46281: PPUSH
46282: CALL_OW 265
46286: PPUSH
46287: LD_VAR 0 3
46291: PPUSH
46292: CALL_OW 262
46296: PPUSH
46297: LD_VAR 0 3
46301: PPUSH
46302: CALL_OW 263
46306: PPUSH
46307: LD_VAR 0 3
46311: PPUSH
46312: CALL_OW 264
46316: PPUSH
46317: CALL 65326 0 5
46321: ST_TO_ADDR
// if components then
46322: LD_VAR 0 10
46326: IFFALSE 46342
// MC_InsertProduceList ( i , components ) ;
46328: LD_VAR 0 2
46332: PPUSH
46333: LD_VAR 0 10
46337: PPUSH
46338: CALL 55076 0 2
// end ; continue ;
46342: GO 45857
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
46344: LD_VAR 0 3
46348: PPUSH
46349: LD_INT 1
46351: PPUSH
46352: CALL_OW 289
46356: PUSH
46357: LD_INT 100
46359: LESS
46360: PUSH
46361: LD_VAR 0 3
46365: PPUSH
46366: CALL_OW 314
46370: NOT
46371: AND
46372: IFFALSE 46401
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
46374: LD_VAR 0 3
46378: PPUSH
46379: LD_VAR 0 6
46383: PUSH
46384: LD_INT 2
46386: ARRAY
46387: PPUSH
46388: LD_VAR 0 6
46392: PUSH
46393: LD_INT 3
46395: ARRAY
46396: PPUSH
46397: CALL_OW 117
// break ;
46401: GO 46405
// end ;
46403: GO 45857
46405: POP
46406: POP
// end ; end ;
46407: GO 44695
46409: POP
46410: POP
// end ;
46411: LD_VAR 0 1
46415: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
46416: LD_INT 0
46418: PPUSH
46419: PPUSH
46420: PPUSH
46421: PPUSH
// if not mc_bases then
46422: LD_EXP 99
46426: NOT
46427: IFFALSE 46431
// exit ;
46429: GO 46592
// for i = 1 to mc_bases do
46431: LD_ADDR_VAR 0 2
46435: PUSH
46436: DOUBLE
46437: LD_INT 1
46439: DEC
46440: ST_TO_ADDR
46441: LD_EXP 99
46445: PUSH
46446: FOR_TO
46447: IFFALSE 46590
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
46449: LD_ADDR_VAR 0 4
46453: PUSH
46454: LD_EXP 118
46458: PUSH
46459: LD_VAR 0 2
46463: ARRAY
46464: PUSH
46465: LD_EXP 121
46469: PUSH
46470: LD_VAR 0 2
46474: ARRAY
46475: UNION
46476: PPUSH
46477: LD_INT 33
46479: PUSH
46480: LD_INT 2
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PPUSH
46487: CALL_OW 72
46491: ST_TO_ADDR
// if tmp then
46492: LD_VAR 0 4
46496: IFFALSE 46588
// for j in tmp do
46498: LD_ADDR_VAR 0 3
46502: PUSH
46503: LD_VAR 0 4
46507: PUSH
46508: FOR_IN
46509: IFFALSE 46586
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
46511: LD_VAR 0 3
46515: PPUSH
46516: CALL_OW 312
46520: NOT
46521: PUSH
46522: LD_VAR 0 3
46526: PPUSH
46527: CALL_OW 256
46531: PUSH
46532: LD_INT 250
46534: GREATEREQUAL
46535: AND
46536: IFFALSE 46549
// Connect ( j ) else
46538: LD_VAR 0 3
46542: PPUSH
46543: CALL 70659 0 1
46547: GO 46584
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
46549: LD_VAR 0 3
46553: PPUSH
46554: CALL_OW 256
46558: PUSH
46559: LD_INT 250
46561: LESS
46562: PUSH
46563: LD_VAR 0 3
46567: PPUSH
46568: CALL_OW 312
46572: AND
46573: IFFALSE 46584
// ComUnlink ( j ) ;
46575: LD_VAR 0 3
46579: PPUSH
46580: CALL_OW 136
46584: GO 46508
46586: POP
46587: POP
// end ;
46588: GO 46446
46590: POP
46591: POP
// end ;
46592: LD_VAR 0 1
46596: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
46597: LD_INT 0
46599: PPUSH
46600: PPUSH
46601: PPUSH
46602: PPUSH
46603: PPUSH
// if not mc_bases then
46604: LD_EXP 99
46608: NOT
46609: IFFALSE 46613
// exit ;
46611: GO 47073
// for i = 1 to mc_bases do
46613: LD_ADDR_VAR 0 2
46617: PUSH
46618: DOUBLE
46619: LD_INT 1
46621: DEC
46622: ST_TO_ADDR
46623: LD_EXP 99
46627: PUSH
46628: FOR_TO
46629: IFFALSE 47071
// begin if not mc_produce [ i ] then
46631: LD_EXP 120
46635: PUSH
46636: LD_VAR 0 2
46640: ARRAY
46641: NOT
46642: IFFALSE 46646
// continue ;
46644: GO 46628
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46646: LD_ADDR_VAR 0 5
46650: PUSH
46651: LD_EXP 99
46655: PUSH
46656: LD_VAR 0 2
46660: ARRAY
46661: PPUSH
46662: LD_INT 30
46664: PUSH
46665: LD_INT 3
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: PPUSH
46672: CALL_OW 72
46676: ST_TO_ADDR
// if not fac then
46677: LD_VAR 0 5
46681: NOT
46682: IFFALSE 46686
// continue ;
46684: GO 46628
// for j in fac do
46686: LD_ADDR_VAR 0 3
46690: PUSH
46691: LD_VAR 0 5
46695: PUSH
46696: FOR_IN
46697: IFFALSE 47067
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
46699: LD_VAR 0 3
46703: PPUSH
46704: CALL_OW 461
46708: PUSH
46709: LD_INT 2
46711: NONEQUAL
46712: PUSH
46713: LD_VAR 0 3
46717: PPUSH
46718: LD_INT 15
46720: PPUSH
46721: CALL 70319 0 2
46725: PUSH
46726: LD_INT 4
46728: ARRAY
46729: OR
46730: PUSH
46731: LD_VAR 0 3
46735: PPUSH
46736: CALL_OW 313
46740: PUSH
46741: LD_INT 0
46743: EQUAL
46744: OR
46745: IFFALSE 46749
// continue ;
46747: GO 46696
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
46749: LD_VAR 0 3
46753: PPUSH
46754: LD_EXP 120
46758: PUSH
46759: LD_VAR 0 2
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: ARRAY
46768: PUSH
46769: LD_INT 1
46771: ARRAY
46772: PPUSH
46773: LD_EXP 120
46777: PUSH
46778: LD_VAR 0 2
46782: ARRAY
46783: PUSH
46784: LD_INT 1
46786: ARRAY
46787: PUSH
46788: LD_INT 2
46790: ARRAY
46791: PPUSH
46792: LD_EXP 120
46796: PUSH
46797: LD_VAR 0 2
46801: ARRAY
46802: PUSH
46803: LD_INT 1
46805: ARRAY
46806: PUSH
46807: LD_INT 3
46809: ARRAY
46810: PPUSH
46811: LD_EXP 120
46815: PUSH
46816: LD_VAR 0 2
46820: ARRAY
46821: PUSH
46822: LD_INT 1
46824: ARRAY
46825: PUSH
46826: LD_INT 4
46828: ARRAY
46829: PPUSH
46830: CALL_OW 448
46834: PUSH
46835: LD_VAR 0 3
46839: PPUSH
46840: LD_EXP 120
46844: PUSH
46845: LD_VAR 0 2
46849: ARRAY
46850: PUSH
46851: LD_INT 1
46853: ARRAY
46854: PUSH
46855: LD_INT 1
46857: ARRAY
46858: PUSH
46859: LD_EXP 120
46863: PUSH
46864: LD_VAR 0 2
46868: ARRAY
46869: PUSH
46870: LD_INT 1
46872: ARRAY
46873: PUSH
46874: LD_INT 2
46876: ARRAY
46877: PUSH
46878: LD_EXP 120
46882: PUSH
46883: LD_VAR 0 2
46887: ARRAY
46888: PUSH
46889: LD_INT 1
46891: ARRAY
46892: PUSH
46893: LD_INT 3
46895: ARRAY
46896: PUSH
46897: LD_EXP 120
46901: PUSH
46902: LD_VAR 0 2
46906: ARRAY
46907: PUSH
46908: LD_INT 1
46910: ARRAY
46911: PUSH
46912: LD_INT 4
46914: ARRAY
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: PPUSH
46922: CALL 73990 0 2
46926: AND
46927: IFFALSE 47065
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
46929: LD_VAR 0 3
46933: PPUSH
46934: LD_EXP 120
46938: PUSH
46939: LD_VAR 0 2
46943: ARRAY
46944: PUSH
46945: LD_INT 1
46947: ARRAY
46948: PUSH
46949: LD_INT 1
46951: ARRAY
46952: PPUSH
46953: LD_EXP 120
46957: PUSH
46958: LD_VAR 0 2
46962: ARRAY
46963: PUSH
46964: LD_INT 1
46966: ARRAY
46967: PUSH
46968: LD_INT 2
46970: ARRAY
46971: PPUSH
46972: LD_EXP 120
46976: PUSH
46977: LD_VAR 0 2
46981: ARRAY
46982: PUSH
46983: LD_INT 1
46985: ARRAY
46986: PUSH
46987: LD_INT 3
46989: ARRAY
46990: PPUSH
46991: LD_EXP 120
46995: PUSH
46996: LD_VAR 0 2
47000: ARRAY
47001: PUSH
47002: LD_INT 1
47004: ARRAY
47005: PUSH
47006: LD_INT 4
47008: ARRAY
47009: PPUSH
47010: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
47014: LD_ADDR_VAR 0 4
47018: PUSH
47019: LD_EXP 120
47023: PUSH
47024: LD_VAR 0 2
47028: ARRAY
47029: PPUSH
47030: LD_INT 1
47032: PPUSH
47033: CALL_OW 3
47037: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47038: LD_ADDR_EXP 120
47042: PUSH
47043: LD_EXP 120
47047: PPUSH
47048: LD_VAR 0 2
47052: PPUSH
47053: LD_VAR 0 4
47057: PPUSH
47058: CALL_OW 1
47062: ST_TO_ADDR
// break ;
47063: GO 47067
// end ; end ;
47065: GO 46696
47067: POP
47068: POP
// end ;
47069: GO 46628
47071: POP
47072: POP
// end ;
47073: LD_VAR 0 1
47077: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
47078: LD_INT 0
47080: PPUSH
47081: PPUSH
47082: PPUSH
// if not mc_bases then
47083: LD_EXP 99
47087: NOT
47088: IFFALSE 47092
// exit ;
47090: GO 47181
// for i = 1 to mc_bases do
47092: LD_ADDR_VAR 0 2
47096: PUSH
47097: DOUBLE
47098: LD_INT 1
47100: DEC
47101: ST_TO_ADDR
47102: LD_EXP 99
47106: PUSH
47107: FOR_TO
47108: IFFALSE 47179
// begin if mc_attack [ i ] then
47110: LD_EXP 119
47114: PUSH
47115: LD_VAR 0 2
47119: ARRAY
47120: IFFALSE 47177
// begin tmp := mc_attack [ i ] [ 1 ] ;
47122: LD_ADDR_VAR 0 3
47126: PUSH
47127: LD_EXP 119
47131: PUSH
47132: LD_VAR 0 2
47136: ARRAY
47137: PUSH
47138: LD_INT 1
47140: ARRAY
47141: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
47142: LD_ADDR_EXP 119
47146: PUSH
47147: LD_EXP 119
47151: PPUSH
47152: LD_VAR 0 2
47156: PPUSH
47157: EMPTY
47158: PPUSH
47159: CALL_OW 1
47163: ST_TO_ADDR
// Attack ( tmp ) ;
47164: LD_VAR 0 3
47168: PPUSH
47169: CALL 96179 0 1
// exit ;
47173: POP
47174: POP
47175: GO 47181
// end ; end ;
47177: GO 47107
47179: POP
47180: POP
// end ;
47181: LD_VAR 0 1
47185: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
47186: LD_INT 0
47188: PPUSH
47189: PPUSH
47190: PPUSH
47191: PPUSH
47192: PPUSH
47193: PPUSH
47194: PPUSH
// if not mc_bases then
47195: LD_EXP 99
47199: NOT
47200: IFFALSE 47204
// exit ;
47202: GO 47808
// for i = 1 to mc_bases do
47204: LD_ADDR_VAR 0 2
47208: PUSH
47209: DOUBLE
47210: LD_INT 1
47212: DEC
47213: ST_TO_ADDR
47214: LD_EXP 99
47218: PUSH
47219: FOR_TO
47220: IFFALSE 47806
// begin if not mc_bases [ i ] then
47222: LD_EXP 99
47226: PUSH
47227: LD_VAR 0 2
47231: ARRAY
47232: NOT
47233: IFFALSE 47237
// continue ;
47235: GO 47219
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
47237: LD_ADDR_VAR 0 7
47241: PUSH
47242: LD_EXP 99
47246: PUSH
47247: LD_VAR 0 2
47251: ARRAY
47252: PUSH
47253: LD_INT 1
47255: ARRAY
47256: PPUSH
47257: CALL 64630 0 1
47261: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
47262: LD_ADDR_EXP 122
47266: PUSH
47267: LD_EXP 122
47271: PPUSH
47272: LD_VAR 0 2
47276: PPUSH
47277: LD_EXP 99
47281: PUSH
47282: LD_VAR 0 2
47286: ARRAY
47287: PUSH
47288: LD_INT 1
47290: ARRAY
47291: PPUSH
47292: CALL_OW 255
47296: PPUSH
47297: LD_EXP 124
47301: PUSH
47302: LD_VAR 0 2
47306: ARRAY
47307: PPUSH
47308: CALL 62590 0 2
47312: PPUSH
47313: CALL_OW 1
47317: ST_TO_ADDR
// if not mc_scan [ i ] then
47318: LD_EXP 122
47322: PUSH
47323: LD_VAR 0 2
47327: ARRAY
47328: NOT
47329: IFFALSE 47484
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47331: LD_ADDR_VAR 0 4
47335: PUSH
47336: LD_EXP 99
47340: PUSH
47341: LD_VAR 0 2
47345: ARRAY
47346: PPUSH
47347: LD_INT 2
47349: PUSH
47350: LD_INT 25
47352: PUSH
47353: LD_INT 5
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: PUSH
47360: LD_INT 25
47362: PUSH
47363: LD_INT 8
47365: PUSH
47366: EMPTY
47367: LIST
47368: LIST
47369: PUSH
47370: LD_INT 25
47372: PUSH
47373: LD_INT 9
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: PPUSH
47386: CALL_OW 72
47390: ST_TO_ADDR
// if not tmp then
47391: LD_VAR 0 4
47395: NOT
47396: IFFALSE 47400
// continue ;
47398: GO 47219
// for j in tmp do
47400: LD_ADDR_VAR 0 3
47404: PUSH
47405: LD_VAR 0 4
47409: PUSH
47410: FOR_IN
47411: IFFALSE 47482
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
47413: LD_VAR 0 3
47417: PPUSH
47418: CALL_OW 310
47422: PPUSH
47423: CALL_OW 266
47427: PUSH
47428: LD_INT 5
47430: EQUAL
47431: PUSH
47432: LD_VAR 0 3
47436: PPUSH
47437: CALL_OW 257
47441: PUSH
47442: LD_INT 1
47444: EQUAL
47445: AND
47446: PUSH
47447: LD_VAR 0 3
47451: PPUSH
47452: CALL_OW 459
47456: NOT
47457: AND
47458: PUSH
47459: LD_VAR 0 7
47463: AND
47464: IFFALSE 47480
// ComChangeProfession ( j , class ) ;
47466: LD_VAR 0 3
47470: PPUSH
47471: LD_VAR 0 7
47475: PPUSH
47476: CALL_OW 123
47480: GO 47410
47482: POP
47483: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
47484: LD_EXP 122
47488: PUSH
47489: LD_VAR 0 2
47493: ARRAY
47494: PUSH
47495: LD_EXP 121
47499: PUSH
47500: LD_VAR 0 2
47504: ARRAY
47505: NOT
47506: AND
47507: PUSH
47508: LD_EXP 99
47512: PUSH
47513: LD_VAR 0 2
47517: ARRAY
47518: PPUSH
47519: LD_INT 30
47521: PUSH
47522: LD_INT 32
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: PPUSH
47529: CALL_OW 72
47533: NOT
47534: AND
47535: PUSH
47536: LD_EXP 99
47540: PUSH
47541: LD_VAR 0 2
47545: ARRAY
47546: PPUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 30
47552: PUSH
47553: LD_INT 4
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PUSH
47560: LD_INT 30
47562: PUSH
47563: LD_INT 5
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: LIST
47574: PPUSH
47575: CALL_OW 72
47579: NOT
47580: AND
47581: IFFALSE 47713
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47583: LD_ADDR_VAR 0 4
47587: PUSH
47588: LD_EXP 99
47592: PUSH
47593: LD_VAR 0 2
47597: ARRAY
47598: PPUSH
47599: LD_INT 2
47601: PUSH
47602: LD_INT 25
47604: PUSH
47605: LD_INT 1
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: PUSH
47612: LD_INT 25
47614: PUSH
47615: LD_INT 5
47617: PUSH
47618: EMPTY
47619: LIST
47620: LIST
47621: PUSH
47622: LD_INT 25
47624: PUSH
47625: LD_INT 8
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: PUSH
47632: LD_INT 25
47634: PUSH
47635: LD_INT 9
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: PPUSH
47649: CALL_OW 72
47653: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
47654: LD_ADDR_VAR 0 4
47658: PUSH
47659: LD_VAR 0 4
47663: PUSH
47664: LD_VAR 0 4
47668: PPUSH
47669: LD_INT 18
47671: PPUSH
47672: CALL 100923 0 2
47676: DIFF
47677: ST_TO_ADDR
// if tmp then
47678: LD_VAR 0 4
47682: IFFALSE 47713
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
47684: LD_VAR 0 2
47688: PPUSH
47689: LD_VAR 0 4
47693: PPUSH
47694: LD_EXP 124
47698: PUSH
47699: LD_VAR 0 2
47703: ARRAY
47704: PPUSH
47705: CALL 62625 0 3
// exit ;
47709: POP
47710: POP
47711: GO 47808
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
47713: LD_EXP 122
47717: PUSH
47718: LD_VAR 0 2
47722: ARRAY
47723: PUSH
47724: LD_EXP 121
47728: PUSH
47729: LD_VAR 0 2
47733: ARRAY
47734: AND
47735: IFFALSE 47804
// begin tmp := mc_defender [ i ] ;
47737: LD_ADDR_VAR 0 4
47741: PUSH
47742: LD_EXP 121
47746: PUSH
47747: LD_VAR 0 2
47751: ARRAY
47752: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
47753: LD_ADDR_EXP 121
47757: PUSH
47758: LD_EXP 121
47762: PPUSH
47763: LD_VAR 0 2
47767: PPUSH
47768: EMPTY
47769: PPUSH
47770: CALL_OW 1
47774: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
47775: LD_VAR 0 2
47779: PPUSH
47780: LD_VAR 0 4
47784: PPUSH
47785: LD_EXP 122
47789: PUSH
47790: LD_VAR 0 2
47794: ARRAY
47795: PPUSH
47796: CALL 63123 0 3
// exit ;
47800: POP
47801: POP
47802: GO 47808
// end ; end ;
47804: GO 47219
47806: POP
47807: POP
// end ;
47808: LD_VAR 0 1
47812: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
47813: LD_INT 0
47815: PPUSH
47816: PPUSH
47817: PPUSH
47818: PPUSH
47819: PPUSH
47820: PPUSH
47821: PPUSH
47822: PPUSH
47823: PPUSH
47824: PPUSH
47825: PPUSH
// if not mc_bases then
47826: LD_EXP 99
47830: NOT
47831: IFFALSE 47835
// exit ;
47833: GO 48922
// for i = 1 to mc_bases do
47835: LD_ADDR_VAR 0 2
47839: PUSH
47840: DOUBLE
47841: LD_INT 1
47843: DEC
47844: ST_TO_ADDR
47845: LD_EXP 99
47849: PUSH
47850: FOR_TO
47851: IFFALSE 48920
// begin tmp := mc_lab [ i ] ;
47853: LD_ADDR_VAR 0 6
47857: PUSH
47858: LD_EXP 132
47862: PUSH
47863: LD_VAR 0 2
47867: ARRAY
47868: ST_TO_ADDR
// if not tmp then
47869: LD_VAR 0 6
47873: NOT
47874: IFFALSE 47878
// continue ;
47876: GO 47850
// idle_lab := 0 ;
47878: LD_ADDR_VAR 0 11
47882: PUSH
47883: LD_INT 0
47885: ST_TO_ADDR
// for j in tmp do
47886: LD_ADDR_VAR 0 3
47890: PUSH
47891: LD_VAR 0 6
47895: PUSH
47896: FOR_IN
47897: IFFALSE 48916
// begin researching := false ;
47899: LD_ADDR_VAR 0 10
47903: PUSH
47904: LD_INT 0
47906: ST_TO_ADDR
// side := GetSide ( j ) ;
47907: LD_ADDR_VAR 0 4
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: CALL_OW 255
47921: ST_TO_ADDR
// if not mc_tech [ side ] then
47922: LD_EXP 126
47926: PUSH
47927: LD_VAR 0 4
47931: ARRAY
47932: NOT
47933: IFFALSE 47937
// continue ;
47935: GO 47896
// if BuildingStatus ( j ) = bs_idle then
47937: LD_VAR 0 3
47941: PPUSH
47942: CALL_OW 461
47946: PUSH
47947: LD_INT 2
47949: EQUAL
47950: IFFALSE 48138
// begin if idle_lab and UnitsInside ( j ) < 6 then
47952: LD_VAR 0 11
47956: PUSH
47957: LD_VAR 0 3
47961: PPUSH
47962: CALL_OW 313
47966: PUSH
47967: LD_INT 6
47969: LESS
47970: AND
47971: IFFALSE 48042
// begin tmp2 := UnitsInside ( idle_lab ) ;
47973: LD_ADDR_VAR 0 9
47977: PUSH
47978: LD_VAR 0 11
47982: PPUSH
47983: CALL_OW 313
47987: ST_TO_ADDR
// if tmp2 then
47988: LD_VAR 0 9
47992: IFFALSE 48034
// for x in tmp2 do
47994: LD_ADDR_VAR 0 7
47998: PUSH
47999: LD_VAR 0 9
48003: PUSH
48004: FOR_IN
48005: IFFALSE 48032
// begin ComExitBuilding ( x ) ;
48007: LD_VAR 0 7
48011: PPUSH
48012: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
48016: LD_VAR 0 7
48020: PPUSH
48021: LD_VAR 0 3
48025: PPUSH
48026: CALL_OW 180
// end ;
48030: GO 48004
48032: POP
48033: POP
// idle_lab := 0 ;
48034: LD_ADDR_VAR 0 11
48038: PUSH
48039: LD_INT 0
48041: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
48042: LD_ADDR_VAR 0 5
48046: PUSH
48047: LD_EXP 126
48051: PUSH
48052: LD_VAR 0 4
48056: ARRAY
48057: PUSH
48058: FOR_IN
48059: IFFALSE 48119
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
48061: LD_VAR 0 3
48065: PPUSH
48066: LD_VAR 0 5
48070: PPUSH
48071: CALL_OW 430
48075: PUSH
48076: LD_VAR 0 4
48080: PPUSH
48081: LD_VAR 0 5
48085: PPUSH
48086: CALL 61695 0 2
48090: AND
48091: IFFALSE 48117
// begin researching := true ;
48093: LD_ADDR_VAR 0 10
48097: PUSH
48098: LD_INT 1
48100: ST_TO_ADDR
// ComResearch ( j , t ) ;
48101: LD_VAR 0 3
48105: PPUSH
48106: LD_VAR 0 5
48110: PPUSH
48111: CALL_OW 124
// break ;
48115: GO 48119
// end ;
48117: GO 48058
48119: POP
48120: POP
// if not researching then
48121: LD_VAR 0 10
48125: NOT
48126: IFFALSE 48138
// idle_lab := j ;
48128: LD_ADDR_VAR 0 11
48132: PUSH
48133: LD_VAR 0 3
48137: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
48138: LD_VAR 0 3
48142: PPUSH
48143: CALL_OW 461
48147: PUSH
48148: LD_INT 10
48150: EQUAL
48151: IFFALSE 48739
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
48153: LD_EXP 128
48157: PUSH
48158: LD_VAR 0 2
48162: ARRAY
48163: NOT
48164: PUSH
48165: LD_EXP 129
48169: PUSH
48170: LD_VAR 0 2
48174: ARRAY
48175: NOT
48176: AND
48177: PUSH
48178: LD_EXP 126
48182: PUSH
48183: LD_VAR 0 4
48187: ARRAY
48188: PUSH
48189: LD_INT 1
48191: GREATER
48192: AND
48193: IFFALSE 48324
// begin ComCancel ( j ) ;
48195: LD_VAR 0 3
48199: PPUSH
48200: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
48204: LD_ADDR_EXP 126
48208: PUSH
48209: LD_EXP 126
48213: PPUSH
48214: LD_VAR 0 4
48218: PPUSH
48219: LD_EXP 126
48223: PUSH
48224: LD_VAR 0 4
48228: ARRAY
48229: PPUSH
48230: LD_EXP 126
48234: PUSH
48235: LD_VAR 0 4
48239: ARRAY
48240: PUSH
48241: LD_INT 1
48243: MINUS
48244: PPUSH
48245: LD_EXP 126
48249: PUSH
48250: LD_VAR 0 4
48254: ARRAY
48255: PPUSH
48256: LD_INT 0
48258: PPUSH
48259: CALL 67144 0 4
48263: PPUSH
48264: CALL_OW 1
48268: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
48269: LD_ADDR_EXP 126
48273: PUSH
48274: LD_EXP 126
48278: PPUSH
48279: LD_VAR 0 4
48283: PPUSH
48284: LD_EXP 126
48288: PUSH
48289: LD_VAR 0 4
48293: ARRAY
48294: PPUSH
48295: LD_EXP 126
48299: PUSH
48300: LD_VAR 0 4
48304: ARRAY
48305: PPUSH
48306: LD_INT 1
48308: PPUSH
48309: LD_INT 0
48311: PPUSH
48312: CALL 67144 0 4
48316: PPUSH
48317: CALL_OW 1
48321: ST_TO_ADDR
// continue ;
48322: GO 47896
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
48324: LD_EXP 128
48328: PUSH
48329: LD_VAR 0 2
48333: ARRAY
48334: PUSH
48335: LD_EXP 129
48339: PUSH
48340: LD_VAR 0 2
48344: ARRAY
48345: NOT
48346: AND
48347: IFFALSE 48474
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
48349: LD_ADDR_EXP 129
48353: PUSH
48354: LD_EXP 129
48358: PPUSH
48359: LD_VAR 0 2
48363: PUSH
48364: LD_EXP 129
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: PUSH
48375: LD_INT 1
48377: PLUS
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PPUSH
48383: LD_EXP 128
48387: PUSH
48388: LD_VAR 0 2
48392: ARRAY
48393: PUSH
48394: LD_INT 1
48396: ARRAY
48397: PPUSH
48398: CALL 67726 0 3
48402: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
48403: LD_EXP 128
48407: PUSH
48408: LD_VAR 0 2
48412: ARRAY
48413: PUSH
48414: LD_INT 1
48416: ARRAY
48417: PPUSH
48418: LD_INT 112
48420: PPUSH
48421: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
48425: LD_ADDR_VAR 0 9
48429: PUSH
48430: LD_EXP 128
48434: PUSH
48435: LD_VAR 0 2
48439: ARRAY
48440: PPUSH
48441: LD_INT 1
48443: PPUSH
48444: CALL_OW 3
48448: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
48449: LD_ADDR_EXP 128
48453: PUSH
48454: LD_EXP 128
48458: PPUSH
48459: LD_VAR 0 2
48463: PPUSH
48464: LD_VAR 0 9
48468: PPUSH
48469: CALL_OW 1
48473: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
48474: LD_EXP 128
48478: PUSH
48479: LD_VAR 0 2
48483: ARRAY
48484: PUSH
48485: LD_EXP 129
48489: PUSH
48490: LD_VAR 0 2
48494: ARRAY
48495: AND
48496: PUSH
48497: LD_EXP 129
48501: PUSH
48502: LD_VAR 0 2
48506: ARRAY
48507: PUSH
48508: LD_INT 1
48510: ARRAY
48511: PPUSH
48512: CALL_OW 310
48516: NOT
48517: AND
48518: PUSH
48519: LD_VAR 0 3
48523: PPUSH
48524: CALL_OW 313
48528: PUSH
48529: LD_INT 6
48531: EQUAL
48532: AND
48533: IFFALSE 48589
// begin tmp2 := UnitsInside ( j ) ;
48535: LD_ADDR_VAR 0 9
48539: PUSH
48540: LD_VAR 0 3
48544: PPUSH
48545: CALL_OW 313
48549: ST_TO_ADDR
// if tmp2 = 6 then
48550: LD_VAR 0 9
48554: PUSH
48555: LD_INT 6
48557: EQUAL
48558: IFFALSE 48589
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
48560: LD_VAR 0 9
48564: PUSH
48565: LD_INT 1
48567: ARRAY
48568: PPUSH
48569: LD_INT 112
48571: PPUSH
48572: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
48576: LD_VAR 0 9
48580: PUSH
48581: LD_INT 1
48583: ARRAY
48584: PPUSH
48585: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
48589: LD_EXP 129
48593: PUSH
48594: LD_VAR 0 2
48598: ARRAY
48599: PUSH
48600: LD_EXP 129
48604: PUSH
48605: LD_VAR 0 2
48609: ARRAY
48610: PUSH
48611: LD_INT 1
48613: ARRAY
48614: PPUSH
48615: CALL_OW 314
48619: NOT
48620: AND
48621: PUSH
48622: LD_EXP 129
48626: PUSH
48627: LD_VAR 0 2
48631: ARRAY
48632: PUSH
48633: LD_INT 1
48635: ARRAY
48636: PPUSH
48637: CALL_OW 310
48641: NOT
48642: AND
48643: IFFALSE 48669
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
48645: LD_EXP 129
48649: PUSH
48650: LD_VAR 0 2
48654: ARRAY
48655: PUSH
48656: LD_INT 1
48658: ARRAY
48659: PPUSH
48660: LD_VAR 0 3
48664: PPUSH
48665: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
48669: LD_EXP 129
48673: PUSH
48674: LD_VAR 0 2
48678: ARRAY
48679: PUSH
48680: LD_INT 1
48682: ARRAY
48683: PPUSH
48684: CALL_OW 310
48688: PUSH
48689: LD_EXP 129
48693: PUSH
48694: LD_VAR 0 2
48698: ARRAY
48699: PUSH
48700: LD_INT 1
48702: ARRAY
48703: PPUSH
48704: CALL_OW 310
48708: PPUSH
48709: CALL_OW 461
48713: PUSH
48714: LD_INT 3
48716: NONEQUAL
48717: AND
48718: IFFALSE 48739
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
48720: LD_EXP 129
48724: PUSH
48725: LD_VAR 0 2
48729: ARRAY
48730: PUSH
48731: LD_INT 1
48733: ARRAY
48734: PPUSH
48735: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
48739: LD_VAR 0 3
48743: PPUSH
48744: CALL_OW 461
48748: PUSH
48749: LD_INT 6
48751: EQUAL
48752: PUSH
48753: LD_VAR 0 6
48757: PUSH
48758: LD_INT 1
48760: GREATER
48761: AND
48762: IFFALSE 48914
// begin sci := [ ] ;
48764: LD_ADDR_VAR 0 8
48768: PUSH
48769: EMPTY
48770: ST_TO_ADDR
// for x in ( tmp diff j ) do
48771: LD_ADDR_VAR 0 7
48775: PUSH
48776: LD_VAR 0 6
48780: PUSH
48781: LD_VAR 0 3
48785: DIFF
48786: PUSH
48787: FOR_IN
48788: IFFALSE 48840
// begin if sci = 6 then
48790: LD_VAR 0 8
48794: PUSH
48795: LD_INT 6
48797: EQUAL
48798: IFFALSE 48802
// break ;
48800: GO 48840
// if BuildingStatus ( x ) = bs_idle then
48802: LD_VAR 0 7
48806: PPUSH
48807: CALL_OW 461
48811: PUSH
48812: LD_INT 2
48814: EQUAL
48815: IFFALSE 48838
// sci := sci ^ UnitsInside ( x ) ;
48817: LD_ADDR_VAR 0 8
48821: PUSH
48822: LD_VAR 0 8
48826: PUSH
48827: LD_VAR 0 7
48831: PPUSH
48832: CALL_OW 313
48836: ADD
48837: ST_TO_ADDR
// end ;
48838: GO 48787
48840: POP
48841: POP
// if not sci then
48842: LD_VAR 0 8
48846: NOT
48847: IFFALSE 48851
// continue ;
48849: GO 47896
// for x in sci do
48851: LD_ADDR_VAR 0 7
48855: PUSH
48856: LD_VAR 0 8
48860: PUSH
48861: FOR_IN
48862: IFFALSE 48912
// if IsInUnit ( x ) and not HasTask ( x ) then
48864: LD_VAR 0 7
48868: PPUSH
48869: CALL_OW 310
48873: PUSH
48874: LD_VAR 0 7
48878: PPUSH
48879: CALL_OW 314
48883: NOT
48884: AND
48885: IFFALSE 48910
// begin ComExitBuilding ( x ) ;
48887: LD_VAR 0 7
48891: PPUSH
48892: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
48896: LD_VAR 0 7
48900: PPUSH
48901: LD_VAR 0 3
48905: PPUSH
48906: CALL_OW 180
// end ;
48910: GO 48861
48912: POP
48913: POP
// end ; end ;
48914: GO 47896
48916: POP
48917: POP
// end ;
48918: GO 47850
48920: POP
48921: POP
// end ;
48922: LD_VAR 0 1
48926: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
48927: LD_INT 0
48929: PPUSH
48930: PPUSH
// if not mc_bases then
48931: LD_EXP 99
48935: NOT
48936: IFFALSE 48940
// exit ;
48938: GO 49021
// for i = 1 to mc_bases do
48940: LD_ADDR_VAR 0 2
48944: PUSH
48945: DOUBLE
48946: LD_INT 1
48948: DEC
48949: ST_TO_ADDR
48950: LD_EXP 99
48954: PUSH
48955: FOR_TO
48956: IFFALSE 49019
// if mc_mines [ i ] and mc_miners [ i ] then
48958: LD_EXP 112
48962: PUSH
48963: LD_VAR 0 2
48967: ARRAY
48968: PUSH
48969: LD_EXP 113
48973: PUSH
48974: LD_VAR 0 2
48978: ARRAY
48979: AND
48980: IFFALSE 49017
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
48982: LD_EXP 113
48986: PUSH
48987: LD_VAR 0 2
48991: ARRAY
48992: PUSH
48993: LD_INT 1
48995: ARRAY
48996: PPUSH
48997: CALL_OW 255
49001: PPUSH
49002: LD_EXP 112
49006: PUSH
49007: LD_VAR 0 2
49011: ARRAY
49012: PPUSH
49013: CALL 64783 0 2
49017: GO 48955
49019: POP
49020: POP
// end ;
49021: LD_VAR 0 1
49025: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
49026: LD_INT 0
49028: PPUSH
49029: PPUSH
49030: PPUSH
49031: PPUSH
49032: PPUSH
49033: PPUSH
49034: PPUSH
49035: PPUSH
// if not mc_bases or not mc_parking then
49036: LD_EXP 99
49040: NOT
49041: PUSH
49042: LD_EXP 123
49046: NOT
49047: OR
49048: IFFALSE 49052
// exit ;
49050: GO 49764
// for i = 1 to mc_bases do
49052: LD_ADDR_VAR 0 2
49056: PUSH
49057: DOUBLE
49058: LD_INT 1
49060: DEC
49061: ST_TO_ADDR
49062: LD_EXP 99
49066: PUSH
49067: FOR_TO
49068: IFFALSE 49762
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
49070: LD_EXP 99
49074: PUSH
49075: LD_VAR 0 2
49079: ARRAY
49080: NOT
49081: PUSH
49082: LD_EXP 123
49086: PUSH
49087: LD_VAR 0 2
49091: ARRAY
49092: NOT
49093: OR
49094: IFFALSE 49098
// continue ;
49096: GO 49067
// if mc_scan [ i ] then
49098: LD_EXP 122
49102: PUSH
49103: LD_VAR 0 2
49107: ARRAY
49108: IFFALSE 49134
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49110: LD_ADDR_EXP 111
49114: PUSH
49115: LD_EXP 111
49119: PPUSH
49120: LD_VAR 0 2
49124: PPUSH
49125: EMPTY
49126: PPUSH
49127: CALL_OW 1
49131: ST_TO_ADDR
// continue ;
49132: GO 49067
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
49134: LD_ADDR_VAR 0 5
49138: PUSH
49139: LD_EXP 99
49143: PUSH
49144: LD_VAR 0 2
49148: ARRAY
49149: PUSH
49150: LD_INT 1
49152: ARRAY
49153: PPUSH
49154: CALL_OW 255
49158: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49159: LD_ADDR_VAR 0 6
49163: PUSH
49164: LD_EXP 99
49168: PUSH
49169: LD_VAR 0 2
49173: ARRAY
49174: PPUSH
49175: LD_INT 30
49177: PUSH
49178: LD_INT 3
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: PPUSH
49185: CALL_OW 72
49189: ST_TO_ADDR
// if not fac then
49190: LD_VAR 0 6
49194: NOT
49195: IFFALSE 49246
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49197: LD_ADDR_VAR 0 6
49201: PUSH
49202: LD_EXP 99
49206: PUSH
49207: LD_VAR 0 2
49211: ARRAY
49212: PPUSH
49213: LD_INT 2
49215: PUSH
49216: LD_INT 30
49218: PUSH
49219: LD_INT 0
49221: PUSH
49222: EMPTY
49223: LIST
49224: LIST
49225: PUSH
49226: LD_INT 30
49228: PUSH
49229: LD_INT 1
49231: PUSH
49232: EMPTY
49233: LIST
49234: LIST
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: LIST
49240: PPUSH
49241: CALL_OW 72
49245: ST_TO_ADDR
// if not fac then
49246: LD_VAR 0 6
49250: NOT
49251: IFFALSE 49255
// continue ;
49253: GO 49067
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
49255: LD_ADDR_VAR 0 7
49259: PUSH
49260: LD_EXP 123
49264: PUSH
49265: LD_VAR 0 2
49269: ARRAY
49270: PPUSH
49271: LD_INT 22
49273: PUSH
49274: LD_VAR 0 5
49278: PUSH
49279: EMPTY
49280: LIST
49281: LIST
49282: PUSH
49283: LD_INT 21
49285: PUSH
49286: LD_INT 2
49288: PUSH
49289: EMPTY
49290: LIST
49291: LIST
49292: PUSH
49293: LD_INT 3
49295: PUSH
49296: LD_INT 24
49298: PUSH
49299: LD_INT 1000
49301: PUSH
49302: EMPTY
49303: LIST
49304: LIST
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: LIST
49314: PPUSH
49315: CALL_OW 70
49319: PUSH
49320: LD_INT 22
49322: PUSH
49323: LD_VAR 0 5
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: PUSH
49332: LD_INT 91
49334: PUSH
49335: LD_VAR 0 6
49339: PUSH
49340: LD_INT 1
49342: ARRAY
49343: PUSH
49344: LD_INT 25
49346: PUSH
49347: EMPTY
49348: LIST
49349: LIST
49350: LIST
49351: PUSH
49352: LD_INT 21
49354: PUSH
49355: LD_INT 2
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: PUSH
49362: LD_INT 3
49364: PUSH
49365: LD_INT 24
49367: PUSH
49368: LD_INT 1000
49370: PUSH
49371: EMPTY
49372: LIST
49373: LIST
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: PUSH
49379: EMPTY
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: PPUSH
49385: CALL_OW 69
49389: UNION
49390: ST_TO_ADDR
// if not vehs then
49391: LD_VAR 0 7
49395: NOT
49396: IFFALSE 49422
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49398: LD_ADDR_EXP 111
49402: PUSH
49403: LD_EXP 111
49407: PPUSH
49408: LD_VAR 0 2
49412: PPUSH
49413: EMPTY
49414: PPUSH
49415: CALL_OW 1
49419: ST_TO_ADDR
// continue ;
49420: GO 49067
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49422: LD_ADDR_VAR 0 8
49426: PUSH
49427: LD_EXP 99
49431: PUSH
49432: LD_VAR 0 2
49436: ARRAY
49437: PPUSH
49438: LD_INT 30
49440: PUSH
49441: LD_INT 3
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: PPUSH
49448: CALL_OW 72
49452: ST_TO_ADDR
// if tmp then
49453: LD_VAR 0 8
49457: IFFALSE 49560
// begin for j in tmp do
49459: LD_ADDR_VAR 0 3
49463: PUSH
49464: LD_VAR 0 8
49468: PUSH
49469: FOR_IN
49470: IFFALSE 49558
// for k in UnitsInside ( j ) do
49472: LD_ADDR_VAR 0 4
49476: PUSH
49477: LD_VAR 0 3
49481: PPUSH
49482: CALL_OW 313
49486: PUSH
49487: FOR_IN
49488: IFFALSE 49554
// if k then
49490: LD_VAR 0 4
49494: IFFALSE 49552
// if not k in mc_repair_vehicle [ i ] then
49496: LD_VAR 0 4
49500: PUSH
49501: LD_EXP 111
49505: PUSH
49506: LD_VAR 0 2
49510: ARRAY
49511: IN
49512: NOT
49513: IFFALSE 49552
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
49515: LD_ADDR_EXP 111
49519: PUSH
49520: LD_EXP 111
49524: PPUSH
49525: LD_VAR 0 2
49529: PPUSH
49530: LD_EXP 111
49534: PUSH
49535: LD_VAR 0 2
49539: ARRAY
49540: PUSH
49541: LD_VAR 0 4
49545: UNION
49546: PPUSH
49547: CALL_OW 1
49551: ST_TO_ADDR
49552: GO 49487
49554: POP
49555: POP
49556: GO 49469
49558: POP
49559: POP
// end ; if not mc_repair_vehicle [ i ] then
49560: LD_EXP 111
49564: PUSH
49565: LD_VAR 0 2
49569: ARRAY
49570: NOT
49571: IFFALSE 49575
// continue ;
49573: GO 49067
// for j in mc_repair_vehicle [ i ] do
49575: LD_ADDR_VAR 0 3
49579: PUSH
49580: LD_EXP 111
49584: PUSH
49585: LD_VAR 0 2
49589: ARRAY
49590: PUSH
49591: FOR_IN
49592: IFFALSE 49758
// begin if GetClass ( j ) <> 3 then
49594: LD_VAR 0 3
49598: PPUSH
49599: CALL_OW 257
49603: PUSH
49604: LD_INT 3
49606: NONEQUAL
49607: IFFALSE 49648
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
49609: LD_ADDR_EXP 111
49613: PUSH
49614: LD_EXP 111
49618: PPUSH
49619: LD_VAR 0 2
49623: PPUSH
49624: LD_EXP 111
49628: PUSH
49629: LD_VAR 0 2
49633: ARRAY
49634: PUSH
49635: LD_VAR 0 3
49639: DIFF
49640: PPUSH
49641: CALL_OW 1
49645: ST_TO_ADDR
// continue ;
49646: GO 49591
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
49648: LD_VAR 0 3
49652: PPUSH
49653: CALL_OW 311
49657: NOT
49658: PUSH
49659: LD_VAR 0 3
49663: PUSH
49664: LD_EXP 102
49668: PUSH
49669: LD_VAR 0 2
49673: ARRAY
49674: PUSH
49675: LD_INT 1
49677: ARRAY
49678: IN
49679: NOT
49680: AND
49681: PUSH
49682: LD_VAR 0 3
49686: PUSH
49687: LD_EXP 102
49691: PUSH
49692: LD_VAR 0 2
49696: ARRAY
49697: PUSH
49698: LD_INT 2
49700: ARRAY
49701: IN
49702: NOT
49703: AND
49704: IFFALSE 49756
// begin if IsInUnit ( j ) then
49706: LD_VAR 0 3
49710: PPUSH
49711: CALL_OW 310
49715: IFFALSE 49726
// ComExitBuilding ( j ) ;
49717: LD_VAR 0 3
49721: PPUSH
49722: CALL_OW 122
// if not HasTask ( j ) then
49726: LD_VAR 0 3
49730: PPUSH
49731: CALL_OW 314
49735: NOT
49736: IFFALSE 49756
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
49738: LD_VAR 0 3
49742: PPUSH
49743: LD_VAR 0 7
49747: PUSH
49748: LD_INT 1
49750: ARRAY
49751: PPUSH
49752: CALL_OW 189
// end ; end ;
49756: GO 49591
49758: POP
49759: POP
// end ;
49760: GO 49067
49762: POP
49763: POP
// end ;
49764: LD_VAR 0 1
49768: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
49769: LD_INT 0
49771: PPUSH
49772: PPUSH
49773: PPUSH
49774: PPUSH
49775: PPUSH
49776: PPUSH
49777: PPUSH
49778: PPUSH
49779: PPUSH
49780: PPUSH
49781: PPUSH
// if not mc_bases then
49782: LD_EXP 99
49786: NOT
49787: IFFALSE 49791
// exit ;
49789: GO 50593
// for i = 1 to mc_bases do
49791: LD_ADDR_VAR 0 2
49795: PUSH
49796: DOUBLE
49797: LD_INT 1
49799: DEC
49800: ST_TO_ADDR
49801: LD_EXP 99
49805: PUSH
49806: FOR_TO
49807: IFFALSE 50591
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
49809: LD_EXP 127
49813: PUSH
49814: LD_VAR 0 2
49818: ARRAY
49819: NOT
49820: PUSH
49821: LD_EXP 102
49825: PUSH
49826: LD_VAR 0 2
49830: ARRAY
49831: PUSH
49832: LD_INT 1
49834: ARRAY
49835: OR
49836: PUSH
49837: LD_EXP 102
49841: PUSH
49842: LD_VAR 0 2
49846: ARRAY
49847: PUSH
49848: LD_INT 2
49850: ARRAY
49851: OR
49852: PUSH
49853: LD_EXP 125
49857: PUSH
49858: LD_VAR 0 2
49862: ARRAY
49863: PPUSH
49864: LD_INT 1
49866: PPUSH
49867: CALL_OW 325
49871: NOT
49872: OR
49873: PUSH
49874: LD_EXP 122
49878: PUSH
49879: LD_VAR 0 2
49883: ARRAY
49884: OR
49885: IFFALSE 49889
// continue ;
49887: GO 49806
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
49889: LD_ADDR_VAR 0 8
49893: PUSH
49894: LD_EXP 99
49898: PUSH
49899: LD_VAR 0 2
49903: ARRAY
49904: PPUSH
49905: LD_INT 25
49907: PUSH
49908: LD_INT 4
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PUSH
49915: LD_INT 50
49917: PUSH
49918: EMPTY
49919: LIST
49920: PUSH
49921: LD_INT 3
49923: PUSH
49924: LD_INT 60
49926: PUSH
49927: EMPTY
49928: LIST
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PUSH
49934: EMPTY
49935: LIST
49936: LIST
49937: LIST
49938: PPUSH
49939: CALL_OW 72
49943: PUSH
49944: LD_EXP 103
49948: PUSH
49949: LD_VAR 0 2
49953: ARRAY
49954: DIFF
49955: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49956: LD_ADDR_VAR 0 9
49960: PUSH
49961: LD_EXP 99
49965: PUSH
49966: LD_VAR 0 2
49970: ARRAY
49971: PPUSH
49972: LD_INT 2
49974: PUSH
49975: LD_INT 30
49977: PUSH
49978: LD_INT 0
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: LD_INT 30
49987: PUSH
49988: LD_INT 1
49990: PUSH
49991: EMPTY
49992: LIST
49993: LIST
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: LIST
49999: PPUSH
50000: CALL_OW 72
50004: ST_TO_ADDR
// if not tmp or not dep then
50005: LD_VAR 0 8
50009: NOT
50010: PUSH
50011: LD_VAR 0 9
50015: NOT
50016: OR
50017: IFFALSE 50021
// continue ;
50019: GO 49806
// side := GetSide ( tmp [ 1 ] ) ;
50021: LD_ADDR_VAR 0 11
50025: PUSH
50026: LD_VAR 0 8
50030: PUSH
50031: LD_INT 1
50033: ARRAY
50034: PPUSH
50035: CALL_OW 255
50039: ST_TO_ADDR
// dep := dep [ 1 ] ;
50040: LD_ADDR_VAR 0 9
50044: PUSH
50045: LD_VAR 0 9
50049: PUSH
50050: LD_INT 1
50052: ARRAY
50053: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
50054: LD_ADDR_VAR 0 7
50058: PUSH
50059: LD_EXP 127
50063: PUSH
50064: LD_VAR 0 2
50068: ARRAY
50069: PPUSH
50070: LD_INT 22
50072: PUSH
50073: LD_INT 0
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PUSH
50080: LD_INT 25
50082: PUSH
50083: LD_INT 12
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PPUSH
50094: CALL_OW 70
50098: PUSH
50099: LD_INT 22
50101: PUSH
50102: LD_INT 0
50104: PUSH
50105: EMPTY
50106: LIST
50107: LIST
50108: PUSH
50109: LD_INT 25
50111: PUSH
50112: LD_INT 12
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 91
50121: PUSH
50122: LD_VAR 0 9
50126: PUSH
50127: LD_INT 20
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: LIST
50134: PUSH
50135: EMPTY
50136: LIST
50137: LIST
50138: LIST
50139: PPUSH
50140: CALL_OW 69
50144: UNION
50145: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
50146: LD_ADDR_VAR 0 10
50150: PUSH
50151: LD_EXP 127
50155: PUSH
50156: LD_VAR 0 2
50160: ARRAY
50161: PPUSH
50162: LD_INT 81
50164: PUSH
50165: LD_VAR 0 11
50169: PUSH
50170: EMPTY
50171: LIST
50172: LIST
50173: PPUSH
50174: CALL_OW 70
50178: ST_TO_ADDR
// if not apes or danger_at_area then
50179: LD_VAR 0 7
50183: NOT
50184: PUSH
50185: LD_VAR 0 10
50189: OR
50190: IFFALSE 50240
// begin if mc_taming [ i ] then
50192: LD_EXP 130
50196: PUSH
50197: LD_VAR 0 2
50201: ARRAY
50202: IFFALSE 50238
// begin MC_Reset ( i , 121 ) ;
50204: LD_VAR 0 2
50208: PPUSH
50209: LD_INT 121
50211: PPUSH
50212: CALL 35875 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50216: LD_ADDR_EXP 130
50220: PUSH
50221: LD_EXP 130
50225: PPUSH
50226: LD_VAR 0 2
50230: PPUSH
50231: EMPTY
50232: PPUSH
50233: CALL_OW 1
50237: ST_TO_ADDR
// end ; continue ;
50238: GO 49806
// end ; for j in tmp do
50240: LD_ADDR_VAR 0 3
50244: PUSH
50245: LD_VAR 0 8
50249: PUSH
50250: FOR_IN
50251: IFFALSE 50587
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
50253: LD_VAR 0 3
50257: PUSH
50258: LD_EXP 130
50262: PUSH
50263: LD_VAR 0 2
50267: ARRAY
50268: IN
50269: NOT
50270: PUSH
50271: LD_EXP 130
50275: PUSH
50276: LD_VAR 0 2
50280: ARRAY
50281: PUSH
50282: LD_INT 3
50284: LESS
50285: AND
50286: IFFALSE 50344
// begin SetTag ( j , 121 ) ;
50288: LD_VAR 0 3
50292: PPUSH
50293: LD_INT 121
50295: PPUSH
50296: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
50300: LD_ADDR_EXP 130
50304: PUSH
50305: LD_EXP 130
50309: PPUSH
50310: LD_VAR 0 2
50314: PUSH
50315: LD_EXP 130
50319: PUSH
50320: LD_VAR 0 2
50324: ARRAY
50325: PUSH
50326: LD_INT 1
50328: PLUS
50329: PUSH
50330: EMPTY
50331: LIST
50332: LIST
50333: PPUSH
50334: LD_VAR 0 3
50338: PPUSH
50339: CALL 67726 0 3
50343: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
50344: LD_VAR 0 3
50348: PUSH
50349: LD_EXP 130
50353: PUSH
50354: LD_VAR 0 2
50358: ARRAY
50359: IN
50360: IFFALSE 50585
// begin if GetClass ( j ) <> 4 then
50362: LD_VAR 0 3
50366: PPUSH
50367: CALL_OW 257
50371: PUSH
50372: LD_INT 4
50374: NONEQUAL
50375: IFFALSE 50428
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
50377: LD_ADDR_EXP 130
50381: PUSH
50382: LD_EXP 130
50386: PPUSH
50387: LD_VAR 0 2
50391: PPUSH
50392: LD_EXP 130
50396: PUSH
50397: LD_VAR 0 2
50401: ARRAY
50402: PUSH
50403: LD_VAR 0 3
50407: DIFF
50408: PPUSH
50409: CALL_OW 1
50413: ST_TO_ADDR
// SetTag ( j , 0 ) ;
50414: LD_VAR 0 3
50418: PPUSH
50419: LD_INT 0
50421: PPUSH
50422: CALL_OW 109
// continue ;
50426: GO 50250
// end ; if IsInUnit ( j ) then
50428: LD_VAR 0 3
50432: PPUSH
50433: CALL_OW 310
50437: IFFALSE 50448
// ComExitBuilding ( j ) ;
50439: LD_VAR 0 3
50443: PPUSH
50444: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
50448: LD_ADDR_VAR 0 6
50452: PUSH
50453: LD_VAR 0 7
50457: PPUSH
50458: LD_VAR 0 3
50462: PPUSH
50463: CALL_OW 74
50467: ST_TO_ADDR
// if not ape then
50468: LD_VAR 0 6
50472: NOT
50473: IFFALSE 50477
// break ;
50475: GO 50587
// x := GetX ( ape ) ;
50477: LD_ADDR_VAR 0 4
50481: PUSH
50482: LD_VAR 0 6
50486: PPUSH
50487: CALL_OW 250
50491: ST_TO_ADDR
// y := GetY ( ape ) ;
50492: LD_ADDR_VAR 0 5
50496: PUSH
50497: LD_VAR 0 6
50501: PPUSH
50502: CALL_OW 251
50506: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
50507: LD_VAR 0 4
50511: PPUSH
50512: LD_VAR 0 5
50516: PPUSH
50517: CALL_OW 488
50521: NOT
50522: PUSH
50523: LD_VAR 0 11
50527: PPUSH
50528: LD_VAR 0 4
50532: PPUSH
50533: LD_VAR 0 5
50537: PPUSH
50538: LD_INT 20
50540: PPUSH
50541: CALL 68622 0 4
50545: PUSH
50546: LD_INT 4
50548: ARRAY
50549: OR
50550: IFFALSE 50554
// break ;
50552: GO 50587
// if not HasTask ( j ) then
50554: LD_VAR 0 3
50558: PPUSH
50559: CALL_OW 314
50563: NOT
50564: IFFALSE 50585
// ComTameXY ( j , x , y ) ;
50566: LD_VAR 0 3
50570: PPUSH
50571: LD_VAR 0 4
50575: PPUSH
50576: LD_VAR 0 5
50580: PPUSH
50581: CALL_OW 131
// end ; end ;
50585: GO 50250
50587: POP
50588: POP
// end ;
50589: GO 49806
50591: POP
50592: POP
// end ;
50593: LD_VAR 0 1
50597: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
50598: LD_INT 0
50600: PPUSH
50601: PPUSH
50602: PPUSH
50603: PPUSH
50604: PPUSH
50605: PPUSH
50606: PPUSH
50607: PPUSH
// if not mc_bases then
50608: LD_EXP 99
50612: NOT
50613: IFFALSE 50617
// exit ;
50615: GO 51243
// for i = 1 to mc_bases do
50617: LD_ADDR_VAR 0 2
50621: PUSH
50622: DOUBLE
50623: LD_INT 1
50625: DEC
50626: ST_TO_ADDR
50627: LD_EXP 99
50631: PUSH
50632: FOR_TO
50633: IFFALSE 51241
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
50635: LD_EXP 128
50639: PUSH
50640: LD_VAR 0 2
50644: ARRAY
50645: NOT
50646: PUSH
50647: LD_EXP 128
50651: PUSH
50652: LD_VAR 0 2
50656: ARRAY
50657: PPUSH
50658: LD_INT 25
50660: PUSH
50661: LD_INT 12
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PPUSH
50668: CALL_OW 72
50672: NOT
50673: OR
50674: IFFALSE 50678
// continue ;
50676: GO 50632
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
50678: LD_ADDR_VAR 0 5
50682: PUSH
50683: LD_EXP 128
50687: PUSH
50688: LD_VAR 0 2
50692: ARRAY
50693: PUSH
50694: LD_INT 1
50696: ARRAY
50697: PPUSH
50698: CALL_OW 255
50702: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
50703: LD_VAR 0 5
50707: PPUSH
50708: LD_INT 2
50710: PPUSH
50711: CALL_OW 325
50715: IFFALSE 50968
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
50717: LD_ADDR_VAR 0 4
50721: PUSH
50722: LD_EXP 128
50726: PUSH
50727: LD_VAR 0 2
50731: ARRAY
50732: PPUSH
50733: LD_INT 25
50735: PUSH
50736: LD_INT 16
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PPUSH
50743: CALL_OW 72
50747: ST_TO_ADDR
// if tmp < 6 then
50748: LD_VAR 0 4
50752: PUSH
50753: LD_INT 6
50755: LESS
50756: IFFALSE 50968
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50758: LD_ADDR_VAR 0 6
50762: PUSH
50763: LD_EXP 99
50767: PUSH
50768: LD_VAR 0 2
50772: ARRAY
50773: PPUSH
50774: LD_INT 2
50776: PUSH
50777: LD_INT 30
50779: PUSH
50780: LD_INT 0
50782: PUSH
50783: EMPTY
50784: LIST
50785: LIST
50786: PUSH
50787: LD_INT 30
50789: PUSH
50790: LD_INT 1
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: EMPTY
50798: LIST
50799: LIST
50800: LIST
50801: PPUSH
50802: CALL_OW 72
50806: ST_TO_ADDR
// if depot then
50807: LD_VAR 0 6
50811: IFFALSE 50968
// begin selected := 0 ;
50813: LD_ADDR_VAR 0 7
50817: PUSH
50818: LD_INT 0
50820: ST_TO_ADDR
// for j in depot do
50821: LD_ADDR_VAR 0 3
50825: PUSH
50826: LD_VAR 0 6
50830: PUSH
50831: FOR_IN
50832: IFFALSE 50863
// begin if UnitsInside ( j ) < 6 then
50834: LD_VAR 0 3
50838: PPUSH
50839: CALL_OW 313
50843: PUSH
50844: LD_INT 6
50846: LESS
50847: IFFALSE 50861
// begin selected := j ;
50849: LD_ADDR_VAR 0 7
50853: PUSH
50854: LD_VAR 0 3
50858: ST_TO_ADDR
// break ;
50859: GO 50863
// end ; end ;
50861: GO 50831
50863: POP
50864: POP
// if selected then
50865: LD_VAR 0 7
50869: IFFALSE 50968
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
50871: LD_ADDR_VAR 0 3
50875: PUSH
50876: LD_EXP 128
50880: PUSH
50881: LD_VAR 0 2
50885: ARRAY
50886: PPUSH
50887: LD_INT 25
50889: PUSH
50890: LD_INT 12
50892: PUSH
50893: EMPTY
50894: LIST
50895: LIST
50896: PPUSH
50897: CALL_OW 72
50901: PUSH
50902: FOR_IN
50903: IFFALSE 50966
// if not HasTask ( j ) then
50905: LD_VAR 0 3
50909: PPUSH
50910: CALL_OW 314
50914: NOT
50915: IFFALSE 50964
// begin if not IsInUnit ( j ) then
50917: LD_VAR 0 3
50921: PPUSH
50922: CALL_OW 310
50926: NOT
50927: IFFALSE 50943
// ComEnterUnit ( j , selected ) ;
50929: LD_VAR 0 3
50933: PPUSH
50934: LD_VAR 0 7
50938: PPUSH
50939: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
50943: LD_VAR 0 3
50947: PPUSH
50948: LD_INT 16
50950: PPUSH
50951: CALL_OW 183
// AddComExitBuilding ( j ) ;
50955: LD_VAR 0 3
50959: PPUSH
50960: CALL_OW 182
// end ;
50964: GO 50902
50966: POP
50967: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
50968: LD_VAR 0 5
50972: PPUSH
50973: LD_INT 11
50975: PPUSH
50976: CALL_OW 325
50980: IFFALSE 51239
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
50982: LD_ADDR_VAR 0 4
50986: PUSH
50987: LD_EXP 128
50991: PUSH
50992: LD_VAR 0 2
50996: ARRAY
50997: PPUSH
50998: LD_INT 25
51000: PUSH
51001: LD_INT 16
51003: PUSH
51004: EMPTY
51005: LIST
51006: LIST
51007: PPUSH
51008: CALL_OW 72
51012: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
51013: LD_VAR 0 4
51017: PUSH
51018: LD_INT 6
51020: GREATEREQUAL
51021: PUSH
51022: LD_VAR 0 5
51026: PPUSH
51027: LD_INT 2
51029: PPUSH
51030: CALL_OW 325
51034: NOT
51035: OR
51036: IFFALSE 51239
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51038: LD_ADDR_VAR 0 8
51042: PUSH
51043: LD_EXP 99
51047: PUSH
51048: LD_VAR 0 2
51052: ARRAY
51053: PPUSH
51054: LD_INT 2
51056: PUSH
51057: LD_INT 30
51059: PUSH
51060: LD_INT 4
51062: PUSH
51063: EMPTY
51064: LIST
51065: LIST
51066: PUSH
51067: LD_INT 30
51069: PUSH
51070: LD_INT 5
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: PUSH
51077: EMPTY
51078: LIST
51079: LIST
51080: LIST
51081: PPUSH
51082: CALL_OW 72
51086: ST_TO_ADDR
// if barracks then
51087: LD_VAR 0 8
51091: IFFALSE 51239
// begin selected := 0 ;
51093: LD_ADDR_VAR 0 7
51097: PUSH
51098: LD_INT 0
51100: ST_TO_ADDR
// for j in barracks do
51101: LD_ADDR_VAR 0 3
51105: PUSH
51106: LD_VAR 0 8
51110: PUSH
51111: FOR_IN
51112: IFFALSE 51143
// begin if UnitsInside ( j ) < 6 then
51114: LD_VAR 0 3
51118: PPUSH
51119: CALL_OW 313
51123: PUSH
51124: LD_INT 6
51126: LESS
51127: IFFALSE 51141
// begin selected := j ;
51129: LD_ADDR_VAR 0 7
51133: PUSH
51134: LD_VAR 0 3
51138: ST_TO_ADDR
// break ;
51139: GO 51143
// end ; end ;
51141: GO 51111
51143: POP
51144: POP
// if selected then
51145: LD_VAR 0 7
51149: IFFALSE 51239
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
51151: LD_ADDR_VAR 0 3
51155: PUSH
51156: LD_EXP 128
51160: PUSH
51161: LD_VAR 0 2
51165: ARRAY
51166: PPUSH
51167: LD_INT 25
51169: PUSH
51170: LD_INT 12
51172: PUSH
51173: EMPTY
51174: LIST
51175: LIST
51176: PPUSH
51177: CALL_OW 72
51181: PUSH
51182: FOR_IN
51183: IFFALSE 51237
// if not IsInUnit ( j ) and not HasTask ( j ) then
51185: LD_VAR 0 3
51189: PPUSH
51190: CALL_OW 310
51194: NOT
51195: PUSH
51196: LD_VAR 0 3
51200: PPUSH
51201: CALL_OW 314
51205: NOT
51206: AND
51207: IFFALSE 51235
// begin ComEnterUnit ( j , selected ) ;
51209: LD_VAR 0 3
51213: PPUSH
51214: LD_VAR 0 7
51218: PPUSH
51219: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
51223: LD_VAR 0 3
51227: PPUSH
51228: LD_INT 15
51230: PPUSH
51231: CALL_OW 183
// end ;
51235: GO 51182
51237: POP
51238: POP
// end ; end ; end ; end ; end ;
51239: GO 50632
51241: POP
51242: POP
// end ;
51243: LD_VAR 0 1
51247: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
51248: LD_INT 0
51250: PPUSH
51251: PPUSH
51252: PPUSH
51253: PPUSH
// if not mc_bases then
51254: LD_EXP 99
51258: NOT
51259: IFFALSE 51263
// exit ;
51261: GO 51441
// for i = 1 to mc_bases do
51263: LD_ADDR_VAR 0 2
51267: PUSH
51268: DOUBLE
51269: LD_INT 1
51271: DEC
51272: ST_TO_ADDR
51273: LD_EXP 99
51277: PUSH
51278: FOR_TO
51279: IFFALSE 51439
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
51281: LD_ADDR_VAR 0 4
51285: PUSH
51286: LD_EXP 99
51290: PUSH
51291: LD_VAR 0 2
51295: ARRAY
51296: PPUSH
51297: LD_INT 25
51299: PUSH
51300: LD_INT 9
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: PPUSH
51307: CALL_OW 72
51311: ST_TO_ADDR
// if not tmp then
51312: LD_VAR 0 4
51316: NOT
51317: IFFALSE 51321
// continue ;
51319: GO 51278
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
51321: LD_EXP 125
51325: PUSH
51326: LD_VAR 0 2
51330: ARRAY
51331: PPUSH
51332: LD_INT 29
51334: PPUSH
51335: CALL_OW 325
51339: NOT
51340: PUSH
51341: LD_EXP 125
51345: PUSH
51346: LD_VAR 0 2
51350: ARRAY
51351: PPUSH
51352: LD_INT 28
51354: PPUSH
51355: CALL_OW 325
51359: NOT
51360: AND
51361: IFFALSE 51365
// continue ;
51363: GO 51278
// for j in tmp do
51365: LD_ADDR_VAR 0 3
51369: PUSH
51370: LD_VAR 0 4
51374: PUSH
51375: FOR_IN
51376: IFFALSE 51435
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51378: LD_VAR 0 3
51382: PUSH
51383: LD_EXP 102
51387: PUSH
51388: LD_VAR 0 2
51392: ARRAY
51393: PUSH
51394: LD_INT 1
51396: ARRAY
51397: IN
51398: NOT
51399: PUSH
51400: LD_VAR 0 3
51404: PUSH
51405: LD_EXP 102
51409: PUSH
51410: LD_VAR 0 2
51414: ARRAY
51415: PUSH
51416: LD_INT 2
51418: ARRAY
51419: IN
51420: NOT
51421: AND
51422: IFFALSE 51433
// ComSpaceTimeShoot ( j ) ;
51424: LD_VAR 0 3
51428: PPUSH
51429: CALL 61786 0 1
51433: GO 51375
51435: POP
51436: POP
// end ;
51437: GO 51278
51439: POP
51440: POP
// end ;
51441: LD_VAR 0 1
51445: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
51446: LD_INT 0
51448: PPUSH
51449: PPUSH
51450: PPUSH
51451: PPUSH
51452: PPUSH
51453: PPUSH
51454: PPUSH
51455: PPUSH
51456: PPUSH
// if not mc_bases then
51457: LD_EXP 99
51461: NOT
51462: IFFALSE 51466
// exit ;
51464: GO 52088
// for i = 1 to mc_bases do
51466: LD_ADDR_VAR 0 2
51470: PUSH
51471: DOUBLE
51472: LD_INT 1
51474: DEC
51475: ST_TO_ADDR
51476: LD_EXP 99
51480: PUSH
51481: FOR_TO
51482: IFFALSE 52086
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
51484: LD_EXP 134
51488: PUSH
51489: LD_VAR 0 2
51493: ARRAY
51494: NOT
51495: PUSH
51496: LD_INT 38
51498: PPUSH
51499: LD_EXP 125
51503: PUSH
51504: LD_VAR 0 2
51508: ARRAY
51509: PPUSH
51510: CALL_OW 321
51514: PUSH
51515: LD_INT 2
51517: NONEQUAL
51518: OR
51519: IFFALSE 51523
// continue ;
51521: GO 51481
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
51523: LD_ADDR_VAR 0 8
51527: PUSH
51528: LD_EXP 99
51532: PUSH
51533: LD_VAR 0 2
51537: ARRAY
51538: PPUSH
51539: LD_INT 30
51541: PUSH
51542: LD_INT 34
51544: PUSH
51545: EMPTY
51546: LIST
51547: LIST
51548: PPUSH
51549: CALL_OW 72
51553: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
51554: LD_ADDR_VAR 0 9
51558: PUSH
51559: LD_EXP 99
51563: PUSH
51564: LD_VAR 0 2
51568: ARRAY
51569: PPUSH
51570: LD_INT 25
51572: PUSH
51573: LD_INT 4
51575: PUSH
51576: EMPTY
51577: LIST
51578: LIST
51579: PPUSH
51580: CALL_OW 72
51584: PPUSH
51585: LD_INT 0
51587: PPUSH
51588: CALL 100923 0 2
51592: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
51593: LD_VAR 0 9
51597: NOT
51598: PUSH
51599: LD_VAR 0 8
51603: NOT
51604: OR
51605: PUSH
51606: LD_EXP 99
51610: PUSH
51611: LD_VAR 0 2
51615: ARRAY
51616: PPUSH
51617: LD_INT 124
51619: PPUSH
51620: CALL 100923 0 2
51624: OR
51625: IFFALSE 51629
// continue ;
51627: GO 51481
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
51629: LD_EXP 135
51633: PUSH
51634: LD_VAR 0 2
51638: ARRAY
51639: PUSH
51640: LD_EXP 134
51644: PUSH
51645: LD_VAR 0 2
51649: ARRAY
51650: LESS
51651: PUSH
51652: LD_EXP 135
51656: PUSH
51657: LD_VAR 0 2
51661: ARRAY
51662: PUSH
51663: LD_VAR 0 8
51667: LESS
51668: AND
51669: IFFALSE 52084
// begin tmp := sci [ 1 ] ;
51671: LD_ADDR_VAR 0 7
51675: PUSH
51676: LD_VAR 0 9
51680: PUSH
51681: LD_INT 1
51683: ARRAY
51684: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
51685: LD_VAR 0 7
51689: PPUSH
51690: LD_INT 124
51692: PPUSH
51693: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
51697: LD_ADDR_VAR 0 3
51701: PUSH
51702: DOUBLE
51703: LD_EXP 134
51707: PUSH
51708: LD_VAR 0 2
51712: ARRAY
51713: INC
51714: ST_TO_ADDR
51715: LD_EXP 134
51719: PUSH
51720: LD_VAR 0 2
51724: ARRAY
51725: PUSH
51726: FOR_DOWNTO
51727: IFFALSE 52070
// begin if IsInUnit ( tmp ) then
51729: LD_VAR 0 7
51733: PPUSH
51734: CALL_OW 310
51738: IFFALSE 51749
// ComExitBuilding ( tmp ) ;
51740: LD_VAR 0 7
51744: PPUSH
51745: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
51749: LD_INT 35
51751: PPUSH
51752: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
51756: LD_VAR 0 7
51760: PPUSH
51761: CALL_OW 310
51765: NOT
51766: PUSH
51767: LD_VAR 0 7
51771: PPUSH
51772: CALL_OW 314
51776: NOT
51777: AND
51778: IFFALSE 51749
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
51780: LD_ADDR_VAR 0 6
51784: PUSH
51785: LD_VAR 0 7
51789: PPUSH
51790: CALL_OW 250
51794: PUSH
51795: LD_VAR 0 7
51799: PPUSH
51800: CALL_OW 251
51804: PUSH
51805: EMPTY
51806: LIST
51807: LIST
51808: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
51809: LD_INT 35
51811: PPUSH
51812: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
51816: LD_ADDR_VAR 0 4
51820: PUSH
51821: LD_EXP 134
51825: PUSH
51826: LD_VAR 0 2
51830: ARRAY
51831: PUSH
51832: LD_VAR 0 3
51836: ARRAY
51837: PUSH
51838: LD_INT 1
51840: ARRAY
51841: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
51842: LD_ADDR_VAR 0 5
51846: PUSH
51847: LD_EXP 134
51851: PUSH
51852: LD_VAR 0 2
51856: ARRAY
51857: PUSH
51858: LD_VAR 0 3
51862: ARRAY
51863: PUSH
51864: LD_INT 2
51866: ARRAY
51867: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
51868: LD_VAR 0 7
51872: PPUSH
51873: LD_INT 10
51875: PPUSH
51876: CALL 70319 0 2
51880: PUSH
51881: LD_INT 4
51883: ARRAY
51884: IFFALSE 51922
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
51886: LD_VAR 0 7
51890: PPUSH
51891: LD_VAR 0 6
51895: PUSH
51896: LD_INT 1
51898: ARRAY
51899: PPUSH
51900: LD_VAR 0 6
51904: PUSH
51905: LD_INT 2
51907: ARRAY
51908: PPUSH
51909: CALL_OW 111
// wait ( 0 0$10 ) ;
51913: LD_INT 350
51915: PPUSH
51916: CALL_OW 67
// end else
51920: GO 51948
// begin ComMoveXY ( tmp , x , y ) ;
51922: LD_VAR 0 7
51926: PPUSH
51927: LD_VAR 0 4
51931: PPUSH
51932: LD_VAR 0 5
51936: PPUSH
51937: CALL_OW 111
// wait ( 0 0$3 ) ;
51941: LD_INT 105
51943: PPUSH
51944: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
51948: LD_VAR 0 7
51952: PPUSH
51953: LD_VAR 0 4
51957: PPUSH
51958: LD_VAR 0 5
51962: PPUSH
51963: CALL_OW 307
51967: IFFALSE 51809
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
51969: LD_VAR 0 7
51973: PPUSH
51974: LD_VAR 0 4
51978: PPUSH
51979: LD_VAR 0 5
51983: PPUSH
51984: LD_VAR 0 8
51988: PUSH
51989: LD_VAR 0 3
51993: ARRAY
51994: PPUSH
51995: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
51999: LD_INT 35
52001: PPUSH
52002: CALL_OW 67
// until not HasTask ( tmp ) ;
52006: LD_VAR 0 7
52010: PPUSH
52011: CALL_OW 314
52015: NOT
52016: IFFALSE 51999
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
52018: LD_ADDR_EXP 135
52022: PUSH
52023: LD_EXP 135
52027: PPUSH
52028: LD_VAR 0 2
52032: PUSH
52033: LD_EXP 135
52037: PUSH
52038: LD_VAR 0 2
52042: ARRAY
52043: PUSH
52044: LD_INT 1
52046: PLUS
52047: PUSH
52048: EMPTY
52049: LIST
52050: LIST
52051: PPUSH
52052: LD_VAR 0 8
52056: PUSH
52057: LD_VAR 0 3
52061: ARRAY
52062: PPUSH
52063: CALL 67726 0 3
52067: ST_TO_ADDR
// end ;
52068: GO 51726
52070: POP
52071: POP
// MC_Reset ( i , 124 ) ;
52072: LD_VAR 0 2
52076: PPUSH
52077: LD_INT 124
52079: PPUSH
52080: CALL 35875 0 2
// end ; end ;
52084: GO 51481
52086: POP
52087: POP
// end ;
52088: LD_VAR 0 1
52092: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
52093: LD_INT 0
52095: PPUSH
52096: PPUSH
52097: PPUSH
// if not mc_bases then
52098: LD_EXP 99
52102: NOT
52103: IFFALSE 52107
// exit ;
52105: GO 52713
// for i = 1 to mc_bases do
52107: LD_ADDR_VAR 0 2
52111: PUSH
52112: DOUBLE
52113: LD_INT 1
52115: DEC
52116: ST_TO_ADDR
52117: LD_EXP 99
52121: PUSH
52122: FOR_TO
52123: IFFALSE 52711
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
52125: LD_ADDR_VAR 0 3
52129: PUSH
52130: LD_EXP 99
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: PPUSH
52141: LD_INT 25
52143: PUSH
52144: LD_INT 4
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: PPUSH
52151: CALL_OW 72
52155: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52156: LD_VAR 0 3
52160: NOT
52161: PUSH
52162: LD_EXP 136
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: NOT
52173: OR
52174: PUSH
52175: LD_EXP 99
52179: PUSH
52180: LD_VAR 0 2
52184: ARRAY
52185: PPUSH
52186: LD_INT 2
52188: PUSH
52189: LD_INT 30
52191: PUSH
52192: LD_INT 0
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: PUSH
52199: LD_INT 30
52201: PUSH
52202: LD_INT 1
52204: PUSH
52205: EMPTY
52206: LIST
52207: LIST
52208: PUSH
52209: EMPTY
52210: LIST
52211: LIST
52212: LIST
52213: PPUSH
52214: CALL_OW 72
52218: NOT
52219: OR
52220: IFFALSE 52270
// begin if mc_deposits_finder [ i ] then
52222: LD_EXP 137
52226: PUSH
52227: LD_VAR 0 2
52231: ARRAY
52232: IFFALSE 52268
// begin MC_Reset ( i , 125 ) ;
52234: LD_VAR 0 2
52238: PPUSH
52239: LD_INT 125
52241: PPUSH
52242: CALL 35875 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52246: LD_ADDR_EXP 137
52250: PUSH
52251: LD_EXP 137
52255: PPUSH
52256: LD_VAR 0 2
52260: PPUSH
52261: EMPTY
52262: PPUSH
52263: CALL_OW 1
52267: ST_TO_ADDR
// end ; continue ;
52268: GO 52122
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
52270: LD_EXP 136
52274: PUSH
52275: LD_VAR 0 2
52279: ARRAY
52280: PUSH
52281: LD_INT 1
52283: ARRAY
52284: PUSH
52285: LD_INT 3
52287: ARRAY
52288: PUSH
52289: LD_INT 1
52291: EQUAL
52292: PUSH
52293: LD_INT 20
52295: PPUSH
52296: LD_EXP 125
52300: PUSH
52301: LD_VAR 0 2
52305: ARRAY
52306: PPUSH
52307: CALL_OW 321
52311: PUSH
52312: LD_INT 2
52314: NONEQUAL
52315: AND
52316: IFFALSE 52366
// begin if mc_deposits_finder [ i ] then
52318: LD_EXP 137
52322: PUSH
52323: LD_VAR 0 2
52327: ARRAY
52328: IFFALSE 52364
// begin MC_Reset ( i , 125 ) ;
52330: LD_VAR 0 2
52334: PPUSH
52335: LD_INT 125
52337: PPUSH
52338: CALL 35875 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52342: LD_ADDR_EXP 137
52346: PUSH
52347: LD_EXP 137
52351: PPUSH
52352: LD_VAR 0 2
52356: PPUSH
52357: EMPTY
52358: PPUSH
52359: CALL_OW 1
52363: ST_TO_ADDR
// end ; continue ;
52364: GO 52122
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
52366: LD_EXP 136
52370: PUSH
52371: LD_VAR 0 2
52375: ARRAY
52376: PUSH
52377: LD_INT 1
52379: ARRAY
52380: PUSH
52381: LD_INT 1
52383: ARRAY
52384: PPUSH
52385: LD_EXP 136
52389: PUSH
52390: LD_VAR 0 2
52394: ARRAY
52395: PUSH
52396: LD_INT 1
52398: ARRAY
52399: PUSH
52400: LD_INT 2
52402: ARRAY
52403: PPUSH
52404: LD_EXP 125
52408: PUSH
52409: LD_VAR 0 2
52413: ARRAY
52414: PPUSH
52415: CALL_OW 440
52419: IFFALSE 52462
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
52421: LD_ADDR_EXP 136
52425: PUSH
52426: LD_EXP 136
52430: PPUSH
52431: LD_VAR 0 2
52435: PPUSH
52436: LD_EXP 136
52440: PUSH
52441: LD_VAR 0 2
52445: ARRAY
52446: PPUSH
52447: LD_INT 1
52449: PPUSH
52450: CALL_OW 3
52454: PPUSH
52455: CALL_OW 1
52459: ST_TO_ADDR
52460: GO 52709
// begin if not mc_deposits_finder [ i ] then
52462: LD_EXP 137
52466: PUSH
52467: LD_VAR 0 2
52471: ARRAY
52472: NOT
52473: IFFALSE 52525
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
52475: LD_ADDR_EXP 137
52479: PUSH
52480: LD_EXP 137
52484: PPUSH
52485: LD_VAR 0 2
52489: PPUSH
52490: LD_VAR 0 3
52494: PUSH
52495: LD_INT 1
52497: ARRAY
52498: PUSH
52499: EMPTY
52500: LIST
52501: PPUSH
52502: CALL_OW 1
52506: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
52507: LD_VAR 0 3
52511: PUSH
52512: LD_INT 1
52514: ARRAY
52515: PPUSH
52516: LD_INT 125
52518: PPUSH
52519: CALL_OW 109
// end else
52523: GO 52709
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
52525: LD_EXP 137
52529: PUSH
52530: LD_VAR 0 2
52534: ARRAY
52535: PUSH
52536: LD_INT 1
52538: ARRAY
52539: PPUSH
52540: CALL_OW 310
52544: IFFALSE 52567
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
52546: LD_EXP 137
52550: PUSH
52551: LD_VAR 0 2
52555: ARRAY
52556: PUSH
52557: LD_INT 1
52559: ARRAY
52560: PPUSH
52561: CALL_OW 122
52565: GO 52709
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
52567: LD_EXP 137
52571: PUSH
52572: LD_VAR 0 2
52576: ARRAY
52577: PUSH
52578: LD_INT 1
52580: ARRAY
52581: PPUSH
52582: CALL_OW 314
52586: NOT
52587: PUSH
52588: LD_EXP 137
52592: PUSH
52593: LD_VAR 0 2
52597: ARRAY
52598: PUSH
52599: LD_INT 1
52601: ARRAY
52602: PPUSH
52603: LD_EXP 136
52607: PUSH
52608: LD_VAR 0 2
52612: ARRAY
52613: PUSH
52614: LD_INT 1
52616: ARRAY
52617: PUSH
52618: LD_INT 1
52620: ARRAY
52621: PPUSH
52622: LD_EXP 136
52626: PUSH
52627: LD_VAR 0 2
52631: ARRAY
52632: PUSH
52633: LD_INT 1
52635: ARRAY
52636: PUSH
52637: LD_INT 2
52639: ARRAY
52640: PPUSH
52641: CALL_OW 297
52645: PUSH
52646: LD_INT 6
52648: GREATER
52649: AND
52650: IFFALSE 52709
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
52652: LD_EXP 137
52656: PUSH
52657: LD_VAR 0 2
52661: ARRAY
52662: PUSH
52663: LD_INT 1
52665: ARRAY
52666: PPUSH
52667: LD_EXP 136
52671: PUSH
52672: LD_VAR 0 2
52676: ARRAY
52677: PUSH
52678: LD_INT 1
52680: ARRAY
52681: PUSH
52682: LD_INT 1
52684: ARRAY
52685: PPUSH
52686: LD_EXP 136
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PUSH
52697: LD_INT 1
52699: ARRAY
52700: PUSH
52701: LD_INT 2
52703: ARRAY
52704: PPUSH
52705: CALL_OW 111
// end ; end ; end ;
52709: GO 52122
52711: POP
52712: POP
// end ;
52713: LD_VAR 0 1
52717: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
52718: LD_INT 0
52720: PPUSH
52721: PPUSH
52722: PPUSH
52723: PPUSH
52724: PPUSH
52725: PPUSH
52726: PPUSH
52727: PPUSH
52728: PPUSH
52729: PPUSH
52730: PPUSH
// if not mc_bases then
52731: LD_EXP 99
52735: NOT
52736: IFFALSE 52740
// exit ;
52738: GO 53464
// for i = 1 to mc_bases do
52740: LD_ADDR_VAR 0 2
52744: PUSH
52745: DOUBLE
52746: LD_INT 1
52748: DEC
52749: ST_TO_ADDR
52750: LD_EXP 99
52754: PUSH
52755: FOR_TO
52756: IFFALSE 53462
// begin if not mc_bases [ i ] then
52758: LD_EXP 99
52762: PUSH
52763: LD_VAR 0 2
52767: ARRAY
52768: NOT
52769: IFFALSE 52773
// continue ;
52771: GO 52755
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
52773: LD_ADDR_VAR 0 7
52777: PUSH
52778: LD_EXP 99
52782: PUSH
52783: LD_VAR 0 2
52787: ARRAY
52788: PUSH
52789: LD_INT 1
52791: ARRAY
52792: PPUSH
52793: CALL_OW 248
52797: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
52798: LD_VAR 0 7
52802: PUSH
52803: LD_INT 3
52805: EQUAL
52806: PUSH
52807: LD_EXP 118
52811: PUSH
52812: LD_VAR 0 2
52816: ARRAY
52817: PUSH
52818: LD_EXP 121
52822: PUSH
52823: LD_VAR 0 2
52827: ARRAY
52828: UNION
52829: PPUSH
52830: LD_INT 33
52832: PUSH
52833: LD_INT 2
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: PPUSH
52840: CALL_OW 72
52844: NOT
52845: OR
52846: IFFALSE 52850
// continue ;
52848: GO 52755
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
52850: LD_ADDR_VAR 0 9
52854: PUSH
52855: LD_EXP 99
52859: PUSH
52860: LD_VAR 0 2
52864: ARRAY
52865: PPUSH
52866: LD_INT 30
52868: PUSH
52869: LD_INT 36
52871: PUSH
52872: EMPTY
52873: LIST
52874: LIST
52875: PPUSH
52876: CALL_OW 72
52880: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
52881: LD_ADDR_VAR 0 10
52885: PUSH
52886: LD_EXP 118
52890: PUSH
52891: LD_VAR 0 2
52895: ARRAY
52896: PPUSH
52897: LD_INT 34
52899: PUSH
52900: LD_INT 31
52902: PUSH
52903: EMPTY
52904: LIST
52905: LIST
52906: PPUSH
52907: CALL_OW 72
52911: ST_TO_ADDR
// if not cts and not mcts then
52912: LD_VAR 0 9
52916: NOT
52917: PUSH
52918: LD_VAR 0 10
52922: NOT
52923: AND
52924: IFFALSE 52928
// continue ;
52926: GO 52755
// x := cts ;
52928: LD_ADDR_VAR 0 11
52932: PUSH
52933: LD_VAR 0 9
52937: ST_TO_ADDR
// if not x then
52938: LD_VAR 0 11
52942: NOT
52943: IFFALSE 52955
// x := mcts ;
52945: LD_ADDR_VAR 0 11
52949: PUSH
52950: LD_VAR 0 10
52954: ST_TO_ADDR
// if mc_remote_driver [ i ] then
52955: LD_EXP 139
52959: PUSH
52960: LD_VAR 0 2
52964: ARRAY
52965: IFFALSE 53234
// for j in mc_remote_driver [ i ] do
52967: LD_ADDR_VAR 0 3
52971: PUSH
52972: LD_EXP 139
52976: PUSH
52977: LD_VAR 0 2
52981: ARRAY
52982: PUSH
52983: FOR_IN
52984: IFFALSE 53232
// begin if GetClass ( j ) <> 3 then
52986: LD_VAR 0 3
52990: PPUSH
52991: CALL_OW 257
52995: PUSH
52996: LD_INT 3
52998: NONEQUAL
52999: IFFALSE 53052
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
53001: LD_ADDR_EXP 139
53005: PUSH
53006: LD_EXP 139
53010: PPUSH
53011: LD_VAR 0 2
53015: PPUSH
53016: LD_EXP 139
53020: PUSH
53021: LD_VAR 0 2
53025: ARRAY
53026: PUSH
53027: LD_VAR 0 3
53031: DIFF
53032: PPUSH
53033: CALL_OW 1
53037: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53038: LD_VAR 0 3
53042: PPUSH
53043: LD_INT 0
53045: PPUSH
53046: CALL_OW 109
// continue ;
53050: GO 52983
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
53052: LD_VAR 0 3
53056: PPUSH
53057: CALL_OW 310
53061: NOT
53062: PUSH
53063: LD_VAR 0 3
53067: PPUSH
53068: CALL_OW 310
53072: PPUSH
53073: CALL_OW 266
53077: PUSH
53078: LD_INT 36
53080: NONEQUAL
53081: PUSH
53082: LD_VAR 0 3
53086: PPUSH
53087: CALL 101011 0 1
53091: NOT
53092: AND
53093: OR
53094: IFFALSE 53230
// begin if IsInUnit ( j ) then
53096: LD_VAR 0 3
53100: PPUSH
53101: CALL_OW 310
53105: IFFALSE 53116
// ComExitBuilding ( j ) ;
53107: LD_VAR 0 3
53111: PPUSH
53112: CALL_OW 122
// ct := 0 ;
53116: LD_ADDR_VAR 0 8
53120: PUSH
53121: LD_INT 0
53123: ST_TO_ADDR
// for k in x do
53124: LD_ADDR_VAR 0 4
53128: PUSH
53129: LD_VAR 0 11
53133: PUSH
53134: FOR_IN
53135: IFFALSE 53208
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
53137: LD_VAR 0 4
53141: PPUSH
53142: CALL_OW 264
53146: PUSH
53147: LD_INT 31
53149: EQUAL
53150: PUSH
53151: LD_VAR 0 4
53155: PPUSH
53156: CALL_OW 311
53160: NOT
53161: AND
53162: PUSH
53163: LD_VAR 0 4
53167: PPUSH
53168: CALL_OW 266
53172: PUSH
53173: LD_INT 36
53175: EQUAL
53176: PUSH
53177: LD_VAR 0 4
53181: PPUSH
53182: CALL_OW 313
53186: PUSH
53187: LD_INT 3
53189: LESS
53190: AND
53191: OR
53192: IFFALSE 53206
// begin ct := k ;
53194: LD_ADDR_VAR 0 8
53198: PUSH
53199: LD_VAR 0 4
53203: ST_TO_ADDR
// break ;
53204: GO 53208
// end ;
53206: GO 53134
53208: POP
53209: POP
// if ct then
53210: LD_VAR 0 8
53214: IFFALSE 53230
// ComEnterUnit ( j , ct ) ;
53216: LD_VAR 0 3
53220: PPUSH
53221: LD_VAR 0 8
53225: PPUSH
53226: CALL_OW 120
// end ; end ;
53230: GO 52983
53232: POP
53233: POP
// places := 0 ;
53234: LD_ADDR_VAR 0 5
53238: PUSH
53239: LD_INT 0
53241: ST_TO_ADDR
// for j = 1 to x do
53242: LD_ADDR_VAR 0 3
53246: PUSH
53247: DOUBLE
53248: LD_INT 1
53250: DEC
53251: ST_TO_ADDR
53252: LD_VAR 0 11
53256: PUSH
53257: FOR_TO
53258: IFFALSE 53313
// if GetWeapon ( x [ j ] ) = ar_control_tower then
53260: LD_VAR 0 11
53264: PUSH
53265: LD_VAR 0 3
53269: ARRAY
53270: PPUSH
53271: CALL_OW 264
53275: PUSH
53276: LD_INT 31
53278: EQUAL
53279: IFFALSE 53297
// places := places + 1 else
53281: LD_ADDR_VAR 0 5
53285: PUSH
53286: LD_VAR 0 5
53290: PUSH
53291: LD_INT 1
53293: PLUS
53294: ST_TO_ADDR
53295: GO 53311
// places := places + 3 ;
53297: LD_ADDR_VAR 0 5
53301: PUSH
53302: LD_VAR 0 5
53306: PUSH
53307: LD_INT 3
53309: PLUS
53310: ST_TO_ADDR
53311: GO 53257
53313: POP
53314: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
53315: LD_ADDR_VAR 0 6
53319: PUSH
53320: LD_EXP 99
53324: PUSH
53325: LD_VAR 0 2
53329: ARRAY
53330: PPUSH
53331: LD_INT 25
53333: PUSH
53334: LD_INT 3
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: PPUSH
53341: CALL_OW 72
53345: PUSH
53346: LD_EXP 139
53350: PUSH
53351: LD_VAR 0 2
53355: ARRAY
53356: DIFF
53357: PPUSH
53358: LD_INT 3
53360: PPUSH
53361: CALL 101911 0 2
53365: ST_TO_ADDR
// if not tmp then
53366: LD_VAR 0 6
53370: NOT
53371: IFFALSE 53375
// continue ;
53373: GO 52755
// places := places - mc_remote_driver [ i ] ;
53375: LD_ADDR_VAR 0 5
53379: PUSH
53380: LD_VAR 0 5
53384: PUSH
53385: LD_EXP 139
53389: PUSH
53390: LD_VAR 0 2
53394: ARRAY
53395: MINUS
53396: ST_TO_ADDR
// if places then
53397: LD_VAR 0 5
53401: IFFALSE 53460
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
53403: LD_ADDR_EXP 139
53407: PUSH
53408: LD_EXP 139
53412: PPUSH
53413: LD_VAR 0 2
53417: PPUSH
53418: LD_EXP 139
53422: PUSH
53423: LD_VAR 0 2
53427: ARRAY
53428: PUSH
53429: LD_VAR 0 6
53433: PUSH
53434: LD_INT 1
53436: ARRAY
53437: UNION
53438: PPUSH
53439: CALL_OW 1
53443: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
53444: LD_VAR 0 6
53448: PUSH
53449: LD_INT 1
53451: ARRAY
53452: PPUSH
53453: LD_INT 126
53455: PPUSH
53456: CALL_OW 109
// end ; end ;
53460: GO 52755
53462: POP
53463: POP
// end ;
53464: LD_VAR 0 1
53468: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
53469: LD_INT 0
53471: PPUSH
53472: PPUSH
53473: PPUSH
53474: PPUSH
53475: PPUSH
53476: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
53477: LD_VAR 0 1
53481: NOT
53482: PUSH
53483: LD_VAR 0 2
53487: NOT
53488: OR
53489: PUSH
53490: LD_VAR 0 3
53494: NOT
53495: OR
53496: PUSH
53497: LD_VAR 0 4
53501: PUSH
53502: LD_INT 1
53504: PUSH
53505: LD_INT 2
53507: PUSH
53508: LD_INT 3
53510: PUSH
53511: LD_INT 4
53513: PUSH
53514: LD_INT 5
53516: PUSH
53517: LD_INT 8
53519: PUSH
53520: LD_INT 9
53522: PUSH
53523: LD_INT 15
53525: PUSH
53526: LD_INT 16
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: LIST
53533: LIST
53534: LIST
53535: LIST
53536: LIST
53537: LIST
53538: LIST
53539: IN
53540: NOT
53541: OR
53542: IFFALSE 53546
// exit ;
53544: GO 54446
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
53546: LD_ADDR_VAR 0 2
53550: PUSH
53551: LD_VAR 0 2
53555: PPUSH
53556: LD_INT 21
53558: PUSH
53559: LD_INT 3
53561: PUSH
53562: EMPTY
53563: LIST
53564: LIST
53565: PUSH
53566: LD_INT 24
53568: PUSH
53569: LD_INT 250
53571: PUSH
53572: EMPTY
53573: LIST
53574: LIST
53575: PUSH
53576: EMPTY
53577: LIST
53578: LIST
53579: PPUSH
53580: CALL_OW 72
53584: ST_TO_ADDR
// case class of 1 , 15 :
53585: LD_VAR 0 4
53589: PUSH
53590: LD_INT 1
53592: DOUBLE
53593: EQUAL
53594: IFTRUE 53604
53596: LD_INT 15
53598: DOUBLE
53599: EQUAL
53600: IFTRUE 53604
53602: GO 53689
53604: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
53605: LD_ADDR_VAR 0 8
53609: PUSH
53610: LD_VAR 0 2
53614: PPUSH
53615: LD_INT 2
53617: PUSH
53618: LD_INT 30
53620: PUSH
53621: LD_INT 32
53623: PUSH
53624: EMPTY
53625: LIST
53626: LIST
53627: PUSH
53628: LD_INT 30
53630: PUSH
53631: LD_INT 31
53633: PUSH
53634: EMPTY
53635: LIST
53636: LIST
53637: PUSH
53638: EMPTY
53639: LIST
53640: LIST
53641: LIST
53642: PPUSH
53643: CALL_OW 72
53647: PUSH
53648: LD_VAR 0 2
53652: PPUSH
53653: LD_INT 2
53655: PUSH
53656: LD_INT 30
53658: PUSH
53659: LD_INT 4
53661: PUSH
53662: EMPTY
53663: LIST
53664: LIST
53665: PUSH
53666: LD_INT 30
53668: PUSH
53669: LD_INT 5
53671: PUSH
53672: EMPTY
53673: LIST
53674: LIST
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: LIST
53680: PPUSH
53681: CALL_OW 72
53685: ADD
53686: ST_TO_ADDR
53687: GO 53935
53689: LD_INT 2
53691: DOUBLE
53692: EQUAL
53693: IFTRUE 53703
53695: LD_INT 16
53697: DOUBLE
53698: EQUAL
53699: IFTRUE 53703
53701: GO 53749
53703: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
53704: LD_ADDR_VAR 0 8
53708: PUSH
53709: LD_VAR 0 2
53713: PPUSH
53714: LD_INT 2
53716: PUSH
53717: LD_INT 30
53719: PUSH
53720: LD_INT 0
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: PUSH
53727: LD_INT 30
53729: PUSH
53730: LD_INT 1
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: PUSH
53737: EMPTY
53738: LIST
53739: LIST
53740: LIST
53741: PPUSH
53742: CALL_OW 72
53746: ST_TO_ADDR
53747: GO 53935
53749: LD_INT 3
53751: DOUBLE
53752: EQUAL
53753: IFTRUE 53757
53755: GO 53803
53757: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
53758: LD_ADDR_VAR 0 8
53762: PUSH
53763: LD_VAR 0 2
53767: PPUSH
53768: LD_INT 2
53770: PUSH
53771: LD_INT 30
53773: PUSH
53774: LD_INT 2
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: LD_INT 30
53783: PUSH
53784: LD_INT 3
53786: PUSH
53787: EMPTY
53788: LIST
53789: LIST
53790: PUSH
53791: EMPTY
53792: LIST
53793: LIST
53794: LIST
53795: PPUSH
53796: CALL_OW 72
53800: ST_TO_ADDR
53801: GO 53935
53803: LD_INT 4
53805: DOUBLE
53806: EQUAL
53807: IFTRUE 53811
53809: GO 53868
53811: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
53812: LD_ADDR_VAR 0 8
53816: PUSH
53817: LD_VAR 0 2
53821: PPUSH
53822: LD_INT 2
53824: PUSH
53825: LD_INT 30
53827: PUSH
53828: LD_INT 6
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: PUSH
53835: LD_INT 30
53837: PUSH
53838: LD_INT 7
53840: PUSH
53841: EMPTY
53842: LIST
53843: LIST
53844: PUSH
53845: LD_INT 30
53847: PUSH
53848: LD_INT 8
53850: PUSH
53851: EMPTY
53852: LIST
53853: LIST
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: LIST
53860: PPUSH
53861: CALL_OW 72
53865: ST_TO_ADDR
53866: GO 53935
53868: LD_INT 5
53870: DOUBLE
53871: EQUAL
53872: IFTRUE 53888
53874: LD_INT 8
53876: DOUBLE
53877: EQUAL
53878: IFTRUE 53888
53880: LD_INT 9
53882: DOUBLE
53883: EQUAL
53884: IFTRUE 53888
53886: GO 53934
53888: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
53889: LD_ADDR_VAR 0 8
53893: PUSH
53894: LD_VAR 0 2
53898: PPUSH
53899: LD_INT 2
53901: PUSH
53902: LD_INT 30
53904: PUSH
53905: LD_INT 4
53907: PUSH
53908: EMPTY
53909: LIST
53910: LIST
53911: PUSH
53912: LD_INT 30
53914: PUSH
53915: LD_INT 5
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: LIST
53926: PPUSH
53927: CALL_OW 72
53931: ST_TO_ADDR
53932: GO 53935
53934: POP
// if not tmp then
53935: LD_VAR 0 8
53939: NOT
53940: IFFALSE 53944
// exit ;
53942: GO 54446
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
53944: LD_VAR 0 4
53948: PUSH
53949: LD_INT 1
53951: PUSH
53952: LD_INT 15
53954: PUSH
53955: EMPTY
53956: LIST
53957: LIST
53958: IN
53959: PUSH
53960: LD_EXP 108
53964: PUSH
53965: LD_VAR 0 1
53969: ARRAY
53970: AND
53971: IFFALSE 54127
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
53973: LD_ADDR_VAR 0 9
53977: PUSH
53978: LD_EXP 108
53982: PUSH
53983: LD_VAR 0 1
53987: ARRAY
53988: PUSH
53989: LD_INT 1
53991: ARRAY
53992: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
53993: LD_VAR 0 9
53997: PUSH
53998: LD_EXP 109
54002: PUSH
54003: LD_VAR 0 1
54007: ARRAY
54008: IN
54009: NOT
54010: IFFALSE 54125
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
54012: LD_ADDR_EXP 109
54016: PUSH
54017: LD_EXP 109
54021: PPUSH
54022: LD_VAR 0 1
54026: PUSH
54027: LD_EXP 109
54031: PUSH
54032: LD_VAR 0 1
54036: ARRAY
54037: PUSH
54038: LD_INT 1
54040: PLUS
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: PPUSH
54046: LD_VAR 0 9
54050: PPUSH
54051: CALL 67726 0 3
54055: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
54056: LD_ADDR_EXP 108
54060: PUSH
54061: LD_EXP 108
54065: PPUSH
54066: LD_VAR 0 1
54070: PPUSH
54071: LD_EXP 108
54075: PUSH
54076: LD_VAR 0 1
54080: ARRAY
54081: PUSH
54082: LD_VAR 0 9
54086: DIFF
54087: PPUSH
54088: CALL_OW 1
54092: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
54093: LD_VAR 0 3
54097: PPUSH
54098: LD_EXP 109
54102: PUSH
54103: LD_VAR 0 1
54107: ARRAY
54108: PUSH
54109: LD_EXP 109
54113: PUSH
54114: LD_VAR 0 1
54118: ARRAY
54119: ARRAY
54120: PPUSH
54121: CALL_OW 120
// end ; exit ;
54125: GO 54446
// end ; if tmp > 1 then
54127: LD_VAR 0 8
54131: PUSH
54132: LD_INT 1
54134: GREATER
54135: IFFALSE 54239
// for i = 2 to tmp do
54137: LD_ADDR_VAR 0 6
54141: PUSH
54142: DOUBLE
54143: LD_INT 2
54145: DEC
54146: ST_TO_ADDR
54147: LD_VAR 0 8
54151: PUSH
54152: FOR_TO
54153: IFFALSE 54237
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
54155: LD_VAR 0 8
54159: PUSH
54160: LD_VAR 0 6
54164: ARRAY
54165: PPUSH
54166: CALL_OW 461
54170: PUSH
54171: LD_INT 6
54173: EQUAL
54174: IFFALSE 54235
// begin x := tmp [ i ] ;
54176: LD_ADDR_VAR 0 9
54180: PUSH
54181: LD_VAR 0 8
54185: PUSH
54186: LD_VAR 0 6
54190: ARRAY
54191: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
54192: LD_ADDR_VAR 0 8
54196: PUSH
54197: LD_VAR 0 8
54201: PPUSH
54202: LD_VAR 0 6
54206: PPUSH
54207: CALL_OW 3
54211: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
54212: LD_ADDR_VAR 0 8
54216: PUSH
54217: LD_VAR 0 8
54221: PPUSH
54222: LD_INT 1
54224: PPUSH
54225: LD_VAR 0 9
54229: PPUSH
54230: CALL_OW 2
54234: ST_TO_ADDR
// end ;
54235: GO 54152
54237: POP
54238: POP
// for i in tmp do
54239: LD_ADDR_VAR 0 6
54243: PUSH
54244: LD_VAR 0 8
54248: PUSH
54249: FOR_IN
54250: IFFALSE 54319
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
54252: LD_VAR 0 6
54256: PPUSH
54257: CALL_OW 313
54261: PUSH
54262: LD_INT 6
54264: LESS
54265: PUSH
54266: LD_VAR 0 6
54270: PPUSH
54271: CALL_OW 266
54275: PUSH
54276: LD_INT 31
54278: PUSH
54279: LD_INT 32
54281: PUSH
54282: EMPTY
54283: LIST
54284: LIST
54285: IN
54286: NOT
54287: AND
54288: PUSH
54289: LD_VAR 0 6
54293: PPUSH
54294: CALL_OW 313
54298: PUSH
54299: LD_INT 0
54301: EQUAL
54302: OR
54303: IFFALSE 54317
// begin j := i ;
54305: LD_ADDR_VAR 0 7
54309: PUSH
54310: LD_VAR 0 6
54314: ST_TO_ADDR
// break ;
54315: GO 54319
// end ; end ;
54317: GO 54249
54319: POP
54320: POP
// if j then
54321: LD_VAR 0 7
54325: IFFALSE 54343
// ComEnterUnit ( unit , j ) else
54327: LD_VAR 0 3
54331: PPUSH
54332: LD_VAR 0 7
54336: PPUSH
54337: CALL_OW 120
54341: GO 54446
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54343: LD_ADDR_VAR 0 10
54347: PUSH
54348: LD_VAR 0 2
54352: PPUSH
54353: LD_INT 2
54355: PUSH
54356: LD_INT 30
54358: PUSH
54359: LD_INT 0
54361: PUSH
54362: EMPTY
54363: LIST
54364: LIST
54365: PUSH
54366: LD_INT 30
54368: PUSH
54369: LD_INT 1
54371: PUSH
54372: EMPTY
54373: LIST
54374: LIST
54375: PUSH
54376: EMPTY
54377: LIST
54378: LIST
54379: LIST
54380: PPUSH
54381: CALL_OW 72
54385: ST_TO_ADDR
// if depot then
54386: LD_VAR 0 10
54390: IFFALSE 54446
// begin depot := NearestUnitToUnit ( depot , unit ) ;
54392: LD_ADDR_VAR 0 10
54396: PUSH
54397: LD_VAR 0 10
54401: PPUSH
54402: LD_VAR 0 3
54406: PPUSH
54407: CALL_OW 74
54411: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
54412: LD_VAR 0 3
54416: PPUSH
54417: LD_VAR 0 10
54421: PPUSH
54422: CALL_OW 296
54426: PUSH
54427: LD_INT 10
54429: GREATER
54430: IFFALSE 54446
// ComStandNearbyBuilding ( unit , depot ) ;
54432: LD_VAR 0 3
54436: PPUSH
54437: LD_VAR 0 10
54441: PPUSH
54442: CALL 62403 0 2
// end ; end ; end ;
54446: LD_VAR 0 5
54450: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
54451: LD_INT 0
54453: PPUSH
54454: PPUSH
54455: PPUSH
54456: PPUSH
// if not mc_bases then
54457: LD_EXP 99
54461: NOT
54462: IFFALSE 54466
// exit ;
54464: GO 54705
// for i = 1 to mc_bases do
54466: LD_ADDR_VAR 0 2
54470: PUSH
54471: DOUBLE
54472: LD_INT 1
54474: DEC
54475: ST_TO_ADDR
54476: LD_EXP 99
54480: PUSH
54481: FOR_TO
54482: IFFALSE 54703
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
54484: LD_ADDR_VAR 0 4
54488: PUSH
54489: LD_EXP 99
54493: PUSH
54494: LD_VAR 0 2
54498: ARRAY
54499: PPUSH
54500: LD_INT 21
54502: PUSH
54503: LD_INT 1
54505: PUSH
54506: EMPTY
54507: LIST
54508: LIST
54509: PPUSH
54510: CALL_OW 72
54514: PUSH
54515: LD_EXP 128
54519: PUSH
54520: LD_VAR 0 2
54524: ARRAY
54525: UNION
54526: ST_TO_ADDR
// if not tmp then
54527: LD_VAR 0 4
54531: NOT
54532: IFFALSE 54536
// continue ;
54534: GO 54481
// for j in tmp do
54536: LD_ADDR_VAR 0 3
54540: PUSH
54541: LD_VAR 0 4
54545: PUSH
54546: FOR_IN
54547: IFFALSE 54699
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
54549: LD_VAR 0 3
54553: PPUSH
54554: CALL_OW 110
54558: NOT
54559: PUSH
54560: LD_VAR 0 3
54564: PPUSH
54565: CALL_OW 314
54569: NOT
54570: AND
54571: PUSH
54572: LD_VAR 0 3
54576: PPUSH
54577: CALL_OW 311
54581: NOT
54582: AND
54583: PUSH
54584: LD_VAR 0 3
54588: PPUSH
54589: CALL_OW 310
54593: NOT
54594: AND
54595: PUSH
54596: LD_VAR 0 3
54600: PUSH
54601: LD_EXP 102
54605: PUSH
54606: LD_VAR 0 2
54610: ARRAY
54611: PUSH
54612: LD_INT 1
54614: ARRAY
54615: IN
54616: NOT
54617: AND
54618: PUSH
54619: LD_VAR 0 3
54623: PUSH
54624: LD_EXP 102
54628: PUSH
54629: LD_VAR 0 2
54633: ARRAY
54634: PUSH
54635: LD_INT 2
54637: ARRAY
54638: IN
54639: NOT
54640: AND
54641: PUSH
54642: LD_VAR 0 3
54646: PUSH
54647: LD_EXP 111
54651: PUSH
54652: LD_VAR 0 2
54656: ARRAY
54657: IN
54658: NOT
54659: AND
54660: IFFALSE 54697
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
54662: LD_VAR 0 2
54666: PPUSH
54667: LD_EXP 99
54671: PUSH
54672: LD_VAR 0 2
54676: ARRAY
54677: PPUSH
54678: LD_VAR 0 3
54682: PPUSH
54683: LD_VAR 0 3
54687: PPUSH
54688: CALL_OW 257
54692: PPUSH
54693: CALL 53469 0 4
// end ;
54697: GO 54546
54699: POP
54700: POP
// end ;
54701: GO 54481
54703: POP
54704: POP
// end ;
54705: LD_VAR 0 1
54709: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
54710: LD_INT 0
54712: PPUSH
54713: PPUSH
54714: PPUSH
54715: PPUSH
54716: PPUSH
54717: PPUSH
// if not mc_bases [ base ] then
54718: LD_EXP 99
54722: PUSH
54723: LD_VAR 0 1
54727: ARRAY
54728: NOT
54729: IFFALSE 54733
// exit ;
54731: GO 54915
// tmp := [ ] ;
54733: LD_ADDR_VAR 0 6
54737: PUSH
54738: EMPTY
54739: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
54740: LD_ADDR_VAR 0 7
54744: PUSH
54745: LD_VAR 0 3
54749: PPUSH
54750: LD_INT 0
54752: PPUSH
54753: CALL_OW 517
54757: ST_TO_ADDR
// if not list then
54758: LD_VAR 0 7
54762: NOT
54763: IFFALSE 54767
// exit ;
54765: GO 54915
// for i = 1 to amount do
54767: LD_ADDR_VAR 0 5
54771: PUSH
54772: DOUBLE
54773: LD_INT 1
54775: DEC
54776: ST_TO_ADDR
54777: LD_VAR 0 2
54781: PUSH
54782: FOR_TO
54783: IFFALSE 54863
// begin x := rand ( 1 , list [ 1 ] ) ;
54785: LD_ADDR_VAR 0 8
54789: PUSH
54790: LD_INT 1
54792: PPUSH
54793: LD_VAR 0 7
54797: PUSH
54798: LD_INT 1
54800: ARRAY
54801: PPUSH
54802: CALL_OW 12
54806: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
54807: LD_ADDR_VAR 0 6
54811: PUSH
54812: LD_VAR 0 6
54816: PPUSH
54817: LD_VAR 0 5
54821: PPUSH
54822: LD_VAR 0 7
54826: PUSH
54827: LD_INT 1
54829: ARRAY
54830: PUSH
54831: LD_VAR 0 8
54835: ARRAY
54836: PUSH
54837: LD_VAR 0 7
54841: PUSH
54842: LD_INT 2
54844: ARRAY
54845: PUSH
54846: LD_VAR 0 8
54850: ARRAY
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: PPUSH
54856: CALL_OW 1
54860: ST_TO_ADDR
// end ;
54861: GO 54782
54863: POP
54864: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
54865: LD_ADDR_EXP 112
54869: PUSH
54870: LD_EXP 112
54874: PPUSH
54875: LD_VAR 0 1
54879: PPUSH
54880: LD_VAR 0 6
54884: PPUSH
54885: CALL_OW 1
54889: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
54890: LD_ADDR_EXP 114
54894: PUSH
54895: LD_EXP 114
54899: PPUSH
54900: LD_VAR 0 1
54904: PPUSH
54905: LD_VAR 0 3
54909: PPUSH
54910: CALL_OW 1
54914: ST_TO_ADDR
// end ;
54915: LD_VAR 0 4
54919: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
54920: LD_INT 0
54922: PPUSH
// if not mc_bases [ base ] then
54923: LD_EXP 99
54927: PUSH
54928: LD_VAR 0 1
54932: ARRAY
54933: NOT
54934: IFFALSE 54938
// exit ;
54936: GO 54963
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
54938: LD_ADDR_EXP 104
54942: PUSH
54943: LD_EXP 104
54947: PPUSH
54948: LD_VAR 0 1
54952: PPUSH
54953: LD_VAR 0 2
54957: PPUSH
54958: CALL_OW 1
54962: ST_TO_ADDR
// end ;
54963: LD_VAR 0 3
54967: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
54968: LD_INT 0
54970: PPUSH
// if not mc_bases [ base ] then
54971: LD_EXP 99
54975: PUSH
54976: LD_VAR 0 1
54980: ARRAY
54981: NOT
54982: IFFALSE 54986
// exit ;
54984: GO 55023
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
54986: LD_ADDR_EXP 104
54990: PUSH
54991: LD_EXP 104
54995: PPUSH
54996: LD_VAR 0 1
55000: PPUSH
55001: LD_EXP 104
55005: PUSH
55006: LD_VAR 0 1
55010: ARRAY
55011: PUSH
55012: LD_VAR 0 2
55016: UNION
55017: PPUSH
55018: CALL_OW 1
55022: ST_TO_ADDR
// end ;
55023: LD_VAR 0 3
55027: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
55028: LD_INT 0
55030: PPUSH
// if not mc_bases [ base ] then
55031: LD_EXP 99
55035: PUSH
55036: LD_VAR 0 1
55040: ARRAY
55041: NOT
55042: IFFALSE 55046
// exit ;
55044: GO 55071
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
55046: LD_ADDR_EXP 120
55050: PUSH
55051: LD_EXP 120
55055: PPUSH
55056: LD_VAR 0 1
55060: PPUSH
55061: LD_VAR 0 2
55065: PPUSH
55066: CALL_OW 1
55070: ST_TO_ADDR
// end ;
55071: LD_VAR 0 3
55075: RET
// export function MC_InsertProduceList ( base , components ) ; begin
55076: LD_INT 0
55078: PPUSH
// if not mc_bases [ base ] then
55079: LD_EXP 99
55083: PUSH
55084: LD_VAR 0 1
55088: ARRAY
55089: NOT
55090: IFFALSE 55094
// exit ;
55092: GO 55131
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
55094: LD_ADDR_EXP 120
55098: PUSH
55099: LD_EXP 120
55103: PPUSH
55104: LD_VAR 0 1
55108: PPUSH
55109: LD_EXP 120
55113: PUSH
55114: LD_VAR 0 1
55118: ARRAY
55119: PUSH
55120: LD_VAR 0 2
55124: ADD
55125: PPUSH
55126: CALL_OW 1
55130: ST_TO_ADDR
// end ;
55131: LD_VAR 0 3
55135: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
55136: LD_INT 0
55138: PPUSH
// if not mc_bases [ base ] then
55139: LD_EXP 99
55143: PUSH
55144: LD_VAR 0 1
55148: ARRAY
55149: NOT
55150: IFFALSE 55154
// exit ;
55152: GO 55266
// mc_defender := Replace ( mc_defender , base , deflist ) ;
55154: LD_ADDR_EXP 121
55158: PUSH
55159: LD_EXP 121
55163: PPUSH
55164: LD_VAR 0 1
55168: PPUSH
55169: LD_VAR 0 2
55173: PPUSH
55174: CALL_OW 1
55178: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
55179: LD_ADDR_EXP 110
55183: PUSH
55184: LD_EXP 110
55188: PPUSH
55189: LD_VAR 0 1
55193: PPUSH
55194: LD_VAR 0 2
55198: PUSH
55199: LD_INT 0
55201: PLUS
55202: PPUSH
55203: CALL_OW 1
55207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
55208: LD_ADDR_EXP 118
55212: PUSH
55213: LD_EXP 118
55217: PPUSH
55218: LD_VAR 0 1
55222: PPUSH
55223: LD_EXP 118
55227: PUSH
55228: LD_VAR 0 1
55232: ARRAY
55233: PUSH
55234: LD_EXP 121
55238: PUSH
55239: LD_VAR 0 1
55243: ARRAY
55244: PPUSH
55245: LD_INT 21
55247: PUSH
55248: LD_INT 2
55250: PUSH
55251: EMPTY
55252: LIST
55253: LIST
55254: PPUSH
55255: CALL_OW 72
55259: UNION
55260: PPUSH
55261: CALL_OW 1
55265: ST_TO_ADDR
// end ;
55266: LD_VAR 0 3
55270: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
55271: LD_INT 0
55273: PPUSH
// if not mc_bases [ base ] then
55274: LD_EXP 99
55278: PUSH
55279: LD_VAR 0 1
55283: ARRAY
55284: NOT
55285: IFFALSE 55289
// exit ;
55287: GO 55314
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
55289: LD_ADDR_EXP 110
55293: PUSH
55294: LD_EXP 110
55298: PPUSH
55299: LD_VAR 0 1
55303: PPUSH
55304: LD_VAR 0 2
55308: PPUSH
55309: CALL_OW 1
55313: ST_TO_ADDR
// end ;
55314: LD_VAR 0 3
55318: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
55319: LD_INT 0
55321: PPUSH
55322: PPUSH
55323: PPUSH
55324: PPUSH
// if not mc_bases [ base ] then
55325: LD_EXP 99
55329: PUSH
55330: LD_VAR 0 1
55334: ARRAY
55335: NOT
55336: IFFALSE 55340
// exit ;
55338: GO 55405
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
55340: LD_ADDR_EXP 119
55344: PUSH
55345: LD_EXP 119
55349: PPUSH
55350: LD_VAR 0 1
55354: PUSH
55355: LD_EXP 119
55359: PUSH
55360: LD_VAR 0 1
55364: ARRAY
55365: PUSH
55366: LD_INT 1
55368: PLUS
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: PPUSH
55374: LD_VAR 0 1
55378: PUSH
55379: LD_VAR 0 2
55383: PUSH
55384: LD_VAR 0 3
55388: PUSH
55389: LD_VAR 0 4
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: LIST
55398: LIST
55399: PPUSH
55400: CALL 67726 0 3
55404: ST_TO_ADDR
// end ;
55405: LD_VAR 0 5
55409: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
55410: LD_INT 0
55412: PPUSH
// if not mc_bases [ base ] then
55413: LD_EXP 99
55417: PUSH
55418: LD_VAR 0 1
55422: ARRAY
55423: NOT
55424: IFFALSE 55428
// exit ;
55426: GO 55453
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
55428: LD_ADDR_EXP 136
55432: PUSH
55433: LD_EXP 136
55437: PPUSH
55438: LD_VAR 0 1
55442: PPUSH
55443: LD_VAR 0 2
55447: PPUSH
55448: CALL_OW 1
55452: ST_TO_ADDR
// end ;
55453: LD_VAR 0 3
55457: RET
// export function MC_GetMinesField ( base ) ; begin
55458: LD_INT 0
55460: PPUSH
// result := mc_mines [ base ] ;
55461: LD_ADDR_VAR 0 2
55465: PUSH
55466: LD_EXP 112
55470: PUSH
55471: LD_VAR 0 1
55475: ARRAY
55476: ST_TO_ADDR
// end ;
55477: LD_VAR 0 2
55481: RET
// export function MC_GetProduceList ( base ) ; begin
55482: LD_INT 0
55484: PPUSH
// result := mc_produce [ base ] ;
55485: LD_ADDR_VAR 0 2
55489: PUSH
55490: LD_EXP 120
55494: PUSH
55495: LD_VAR 0 1
55499: ARRAY
55500: ST_TO_ADDR
// end ;
55501: LD_VAR 0 2
55505: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
55506: LD_INT 0
55508: PPUSH
55509: PPUSH
// if not mc_bases then
55510: LD_EXP 99
55514: NOT
55515: IFFALSE 55519
// exit ;
55517: GO 55584
// if mc_bases [ base ] then
55519: LD_EXP 99
55523: PUSH
55524: LD_VAR 0 1
55528: ARRAY
55529: IFFALSE 55584
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
55531: LD_ADDR_VAR 0 3
55535: PUSH
55536: LD_EXP 99
55540: PUSH
55541: LD_VAR 0 1
55545: ARRAY
55546: PPUSH
55547: LD_INT 30
55549: PUSH
55550: LD_VAR 0 2
55554: PUSH
55555: EMPTY
55556: LIST
55557: LIST
55558: PPUSH
55559: CALL_OW 72
55563: ST_TO_ADDR
// if result then
55564: LD_VAR 0 3
55568: IFFALSE 55584
// result := result [ 1 ] ;
55570: LD_ADDR_VAR 0 3
55574: PUSH
55575: LD_VAR 0 3
55579: PUSH
55580: LD_INT 1
55582: ARRAY
55583: ST_TO_ADDR
// end ; end ;
55584: LD_VAR 0 3
55588: RET
// export function MC_SetTame ( base , area ) ; begin
55589: LD_INT 0
55591: PPUSH
// if not mc_bases or not base then
55592: LD_EXP 99
55596: NOT
55597: PUSH
55598: LD_VAR 0 1
55602: NOT
55603: OR
55604: IFFALSE 55608
// exit ;
55606: GO 55633
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
55608: LD_ADDR_EXP 127
55612: PUSH
55613: LD_EXP 127
55617: PPUSH
55618: LD_VAR 0 1
55622: PPUSH
55623: LD_VAR 0 2
55627: PPUSH
55628: CALL_OW 1
55632: ST_TO_ADDR
// end ;
55633: LD_VAR 0 3
55637: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
55638: LD_INT 0
55640: PPUSH
55641: PPUSH
// if not mc_bases or not base then
55642: LD_EXP 99
55646: NOT
55647: PUSH
55648: LD_VAR 0 1
55652: NOT
55653: OR
55654: IFFALSE 55658
// exit ;
55656: GO 55760
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
55658: LD_ADDR_VAR 0 4
55662: PUSH
55663: LD_EXP 99
55667: PUSH
55668: LD_VAR 0 1
55672: ARRAY
55673: PPUSH
55674: LD_INT 30
55676: PUSH
55677: LD_VAR 0 2
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: PPUSH
55686: CALL_OW 72
55690: ST_TO_ADDR
// if not tmp then
55691: LD_VAR 0 4
55695: NOT
55696: IFFALSE 55700
// exit ;
55698: GO 55760
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
55700: LD_ADDR_EXP 131
55704: PUSH
55705: LD_EXP 131
55709: PPUSH
55710: LD_VAR 0 1
55714: PPUSH
55715: LD_EXP 131
55719: PUSH
55720: LD_VAR 0 1
55724: ARRAY
55725: PPUSH
55726: LD_EXP 131
55730: PUSH
55731: LD_VAR 0 1
55735: ARRAY
55736: PUSH
55737: LD_INT 1
55739: PLUS
55740: PPUSH
55741: LD_VAR 0 4
55745: PUSH
55746: LD_INT 1
55748: ARRAY
55749: PPUSH
55750: CALL_OW 2
55754: PPUSH
55755: CALL_OW 1
55759: ST_TO_ADDR
// end ;
55760: LD_VAR 0 3
55764: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
55765: LD_INT 0
55767: PPUSH
55768: PPUSH
// if not mc_bases or not base or not kinds then
55769: LD_EXP 99
55773: NOT
55774: PUSH
55775: LD_VAR 0 1
55779: NOT
55780: OR
55781: PUSH
55782: LD_VAR 0 2
55786: NOT
55787: OR
55788: IFFALSE 55792
// exit ;
55790: GO 55853
// for i in kinds do
55792: LD_ADDR_VAR 0 4
55796: PUSH
55797: LD_VAR 0 2
55801: PUSH
55802: FOR_IN
55803: IFFALSE 55851
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
55805: LD_ADDR_EXP 133
55809: PUSH
55810: LD_EXP 133
55814: PPUSH
55815: LD_VAR 0 1
55819: PUSH
55820: LD_EXP 133
55824: PUSH
55825: LD_VAR 0 1
55829: ARRAY
55830: PUSH
55831: LD_INT 1
55833: PLUS
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: PPUSH
55839: LD_VAR 0 4
55843: PPUSH
55844: CALL 67726 0 3
55848: ST_TO_ADDR
55849: GO 55802
55851: POP
55852: POP
// end ;
55853: LD_VAR 0 3
55857: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
55858: LD_INT 0
55860: PPUSH
// if not mc_bases or not base or not areas then
55861: LD_EXP 99
55865: NOT
55866: PUSH
55867: LD_VAR 0 1
55871: NOT
55872: OR
55873: PUSH
55874: LD_VAR 0 2
55878: NOT
55879: OR
55880: IFFALSE 55884
// exit ;
55882: GO 55909
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
55884: LD_ADDR_EXP 117
55888: PUSH
55889: LD_EXP 117
55893: PPUSH
55894: LD_VAR 0 1
55898: PPUSH
55899: LD_VAR 0 2
55903: PPUSH
55904: CALL_OW 1
55908: ST_TO_ADDR
// end ;
55909: LD_VAR 0 3
55913: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
55914: LD_INT 0
55916: PPUSH
// if not mc_bases or not base or not teleports_exit then
55917: LD_EXP 99
55921: NOT
55922: PUSH
55923: LD_VAR 0 1
55927: NOT
55928: OR
55929: PUSH
55930: LD_VAR 0 2
55934: NOT
55935: OR
55936: IFFALSE 55940
// exit ;
55938: GO 55965
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
55940: LD_ADDR_EXP 134
55944: PUSH
55945: LD_EXP 134
55949: PPUSH
55950: LD_VAR 0 1
55954: PPUSH
55955: LD_VAR 0 2
55959: PPUSH
55960: CALL_OW 1
55964: ST_TO_ADDR
// end ;
55965: LD_VAR 0 3
55969: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
55970: LD_INT 0
55972: PPUSH
55973: PPUSH
55974: PPUSH
// if not mc_bases or not base or not ext_list then
55975: LD_EXP 99
55979: NOT
55980: PUSH
55981: LD_VAR 0 1
55985: NOT
55986: OR
55987: PUSH
55988: LD_VAR 0 5
55992: NOT
55993: OR
55994: IFFALSE 55998
// exit ;
55996: GO 56171
// tmp := GetFacExtXYD ( x , y , d ) ;
55998: LD_ADDR_VAR 0 8
56002: PUSH
56003: LD_VAR 0 2
56007: PPUSH
56008: LD_VAR 0 3
56012: PPUSH
56013: LD_VAR 0 4
56017: PPUSH
56018: CALL 101041 0 3
56022: ST_TO_ADDR
// if not tmp then
56023: LD_VAR 0 8
56027: NOT
56028: IFFALSE 56032
// exit ;
56030: GO 56171
// for i in tmp do
56032: LD_ADDR_VAR 0 7
56036: PUSH
56037: LD_VAR 0 8
56041: PUSH
56042: FOR_IN
56043: IFFALSE 56169
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
56045: LD_ADDR_EXP 104
56049: PUSH
56050: LD_EXP 104
56054: PPUSH
56055: LD_VAR 0 1
56059: PPUSH
56060: LD_EXP 104
56064: PUSH
56065: LD_VAR 0 1
56069: ARRAY
56070: PPUSH
56071: LD_EXP 104
56075: PUSH
56076: LD_VAR 0 1
56080: ARRAY
56081: PUSH
56082: LD_INT 1
56084: PLUS
56085: PPUSH
56086: LD_VAR 0 5
56090: PUSH
56091: LD_INT 1
56093: ARRAY
56094: PUSH
56095: LD_VAR 0 7
56099: PUSH
56100: LD_INT 1
56102: ARRAY
56103: PUSH
56104: LD_VAR 0 7
56108: PUSH
56109: LD_INT 2
56111: ARRAY
56112: PUSH
56113: LD_VAR 0 7
56117: PUSH
56118: LD_INT 3
56120: ARRAY
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: LIST
56126: LIST
56127: PPUSH
56128: CALL_OW 2
56132: PPUSH
56133: CALL_OW 1
56137: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
56138: LD_ADDR_VAR 0 5
56142: PUSH
56143: LD_VAR 0 5
56147: PPUSH
56148: LD_INT 1
56150: PPUSH
56151: CALL_OW 3
56155: ST_TO_ADDR
// if not ext_list then
56156: LD_VAR 0 5
56160: NOT
56161: IFFALSE 56167
// exit ;
56163: POP
56164: POP
56165: GO 56171
// end ;
56167: GO 56042
56169: POP
56170: POP
// end ;
56171: LD_VAR 0 6
56175: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
56176: LD_INT 0
56178: PPUSH
// if not mc_bases or not base or not weapon_list then
56179: LD_EXP 99
56183: NOT
56184: PUSH
56185: LD_VAR 0 1
56189: NOT
56190: OR
56191: PUSH
56192: LD_VAR 0 2
56196: NOT
56197: OR
56198: IFFALSE 56202
// exit ;
56200: GO 56227
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
56202: LD_ADDR_EXP 138
56206: PUSH
56207: LD_EXP 138
56211: PPUSH
56212: LD_VAR 0 1
56216: PPUSH
56217: LD_VAR 0 2
56221: PPUSH
56222: CALL_OW 1
56226: ST_TO_ADDR
// end ;
56227: LD_VAR 0 3
56231: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
56232: LD_INT 0
56234: PPUSH
// if not mc_bases or not base or not tech_list then
56235: LD_EXP 99
56239: NOT
56240: PUSH
56241: LD_VAR 0 1
56245: NOT
56246: OR
56247: PUSH
56248: LD_VAR 0 2
56252: NOT
56253: OR
56254: IFFALSE 56258
// exit ;
56256: GO 56283
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
56258: LD_ADDR_EXP 126
56262: PUSH
56263: LD_EXP 126
56267: PPUSH
56268: LD_VAR 0 1
56272: PPUSH
56273: LD_VAR 0 2
56277: PPUSH
56278: CALL_OW 1
56282: ST_TO_ADDR
// end ;
56283: LD_VAR 0 3
56287: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
56288: LD_INT 0
56290: PPUSH
// if not mc_bases or not parking_area or not base then
56291: LD_EXP 99
56295: NOT
56296: PUSH
56297: LD_VAR 0 2
56301: NOT
56302: OR
56303: PUSH
56304: LD_VAR 0 1
56308: NOT
56309: OR
56310: IFFALSE 56314
// exit ;
56312: GO 56339
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
56314: LD_ADDR_EXP 123
56318: PUSH
56319: LD_EXP 123
56323: PPUSH
56324: LD_VAR 0 1
56328: PPUSH
56329: LD_VAR 0 2
56333: PPUSH
56334: CALL_OW 1
56338: ST_TO_ADDR
// end ;
56339: LD_VAR 0 3
56343: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
56344: LD_INT 0
56346: PPUSH
// if not mc_bases or not base or not scan_area then
56347: LD_EXP 99
56351: NOT
56352: PUSH
56353: LD_VAR 0 1
56357: NOT
56358: OR
56359: PUSH
56360: LD_VAR 0 2
56364: NOT
56365: OR
56366: IFFALSE 56370
// exit ;
56368: GO 56395
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
56370: LD_ADDR_EXP 124
56374: PUSH
56375: LD_EXP 124
56379: PPUSH
56380: LD_VAR 0 1
56384: PPUSH
56385: LD_VAR 0 2
56389: PPUSH
56390: CALL_OW 1
56394: ST_TO_ADDR
// end ;
56395: LD_VAR 0 3
56399: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
56400: LD_INT 0
56402: PPUSH
56403: PPUSH
// if not mc_bases or not base then
56404: LD_EXP 99
56408: NOT
56409: PUSH
56410: LD_VAR 0 1
56414: NOT
56415: OR
56416: IFFALSE 56420
// exit ;
56418: GO 56484
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
56420: LD_ADDR_VAR 0 3
56424: PUSH
56425: LD_INT 1
56427: PUSH
56428: LD_INT 2
56430: PUSH
56431: LD_INT 3
56433: PUSH
56434: LD_INT 4
56436: PUSH
56437: LD_INT 11
56439: PUSH
56440: EMPTY
56441: LIST
56442: LIST
56443: LIST
56444: LIST
56445: LIST
56446: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
56447: LD_ADDR_EXP 126
56451: PUSH
56452: LD_EXP 126
56456: PPUSH
56457: LD_VAR 0 1
56461: PPUSH
56462: LD_EXP 126
56466: PUSH
56467: LD_VAR 0 1
56471: ARRAY
56472: PUSH
56473: LD_VAR 0 3
56477: DIFF
56478: PPUSH
56479: CALL_OW 1
56483: ST_TO_ADDR
// end ;
56484: LD_VAR 0 2
56488: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
56489: LD_INT 0
56491: PPUSH
// result := mc_vehicles [ base ] ;
56492: LD_ADDR_VAR 0 3
56496: PUSH
56497: LD_EXP 118
56501: PUSH
56502: LD_VAR 0 1
56506: ARRAY
56507: ST_TO_ADDR
// if onlyCombat then
56508: LD_VAR 0 2
56512: IFFALSE 56655
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] ] ) ;
56514: LD_ADDR_VAR 0 3
56518: PUSH
56519: LD_VAR 0 3
56523: PUSH
56524: LD_VAR 0 3
56528: PPUSH
56529: LD_INT 2
56531: PUSH
56532: LD_INT 34
56534: PUSH
56535: LD_INT 12
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: PUSH
56542: LD_INT 34
56544: PUSH
56545: LD_INT 51
56547: PUSH
56548: EMPTY
56549: LIST
56550: LIST
56551: PUSH
56552: LD_INT 34
56554: PUSH
56555: LD_EXP 93
56559: PUSH
56560: EMPTY
56561: LIST
56562: LIST
56563: PUSH
56564: LD_INT 34
56566: PUSH
56567: LD_INT 32
56569: PUSH
56570: EMPTY
56571: LIST
56572: LIST
56573: PUSH
56574: LD_INT 34
56576: PUSH
56577: LD_INT 13
56579: PUSH
56580: EMPTY
56581: LIST
56582: LIST
56583: PUSH
56584: LD_INT 34
56586: PUSH
56587: LD_INT 52
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: PUSH
56594: LD_INT 34
56596: PUSH
56597: LD_INT 14
56599: PUSH
56600: EMPTY
56601: LIST
56602: LIST
56603: PUSH
56604: LD_INT 34
56606: PUSH
56607: LD_INT 53
56609: PUSH
56610: EMPTY
56611: LIST
56612: LIST
56613: PUSH
56614: LD_INT 34
56616: PUSH
56617: LD_EXP 92
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: PUSH
56626: LD_INT 34
56628: PUSH
56629: LD_INT 31
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: PUSH
56636: EMPTY
56637: LIST
56638: LIST
56639: LIST
56640: LIST
56641: LIST
56642: LIST
56643: LIST
56644: LIST
56645: LIST
56646: LIST
56647: LIST
56648: PPUSH
56649: CALL_OW 72
56653: DIFF
56654: ST_TO_ADDR
// end ; end_of_file
56655: LD_VAR 0 3
56659: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
56660: LD_INT 0
56662: PPUSH
56663: PPUSH
56664: PPUSH
// if not mc_bases or not skirmish then
56665: LD_EXP 99
56669: NOT
56670: PUSH
56671: LD_EXP 97
56675: NOT
56676: OR
56677: IFFALSE 56681
// exit ;
56679: GO 56846
// for i = 1 to mc_bases do
56681: LD_ADDR_VAR 0 4
56685: PUSH
56686: DOUBLE
56687: LD_INT 1
56689: DEC
56690: ST_TO_ADDR
56691: LD_EXP 99
56695: PUSH
56696: FOR_TO
56697: IFFALSE 56844
// begin if sci in mc_bases [ i ] then
56699: LD_VAR 0 2
56703: PUSH
56704: LD_EXP 99
56708: PUSH
56709: LD_VAR 0 4
56713: ARRAY
56714: IN
56715: IFFALSE 56842
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
56717: LD_ADDR_EXP 128
56721: PUSH
56722: LD_EXP 128
56726: PPUSH
56727: LD_VAR 0 4
56731: PUSH
56732: LD_EXP 128
56736: PUSH
56737: LD_VAR 0 4
56741: ARRAY
56742: PUSH
56743: LD_INT 1
56745: PLUS
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PPUSH
56751: LD_VAR 0 1
56755: PPUSH
56756: CALL 67726 0 3
56760: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
56761: LD_ADDR_VAR 0 5
56765: PUSH
56766: LD_EXP 99
56770: PUSH
56771: LD_VAR 0 4
56775: ARRAY
56776: PPUSH
56777: LD_INT 2
56779: PUSH
56780: LD_INT 30
56782: PUSH
56783: LD_INT 0
56785: PUSH
56786: EMPTY
56787: LIST
56788: LIST
56789: PUSH
56790: LD_INT 30
56792: PUSH
56793: LD_INT 1
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: LIST
56804: PPUSH
56805: CALL_OW 72
56809: PPUSH
56810: LD_VAR 0 1
56814: PPUSH
56815: CALL_OW 74
56819: ST_TO_ADDR
// if tmp then
56820: LD_VAR 0 5
56824: IFFALSE 56840
// ComStandNearbyBuilding ( ape , tmp ) ;
56826: LD_VAR 0 1
56830: PPUSH
56831: LD_VAR 0 5
56835: PPUSH
56836: CALL 62403 0 2
// break ;
56840: GO 56844
// end ; end ;
56842: GO 56696
56844: POP
56845: POP
// end ;
56846: LD_VAR 0 3
56850: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
56851: LD_INT 0
56853: PPUSH
56854: PPUSH
56855: PPUSH
// if not mc_bases or not skirmish then
56856: LD_EXP 99
56860: NOT
56861: PUSH
56862: LD_EXP 97
56866: NOT
56867: OR
56868: IFFALSE 56872
// exit ;
56870: GO 56961
// for i = 1 to mc_bases do
56872: LD_ADDR_VAR 0 4
56876: PUSH
56877: DOUBLE
56878: LD_INT 1
56880: DEC
56881: ST_TO_ADDR
56882: LD_EXP 99
56886: PUSH
56887: FOR_TO
56888: IFFALSE 56959
// begin if building in mc_busy_turret_list [ i ] then
56890: LD_VAR 0 1
56894: PUSH
56895: LD_EXP 109
56899: PUSH
56900: LD_VAR 0 4
56904: ARRAY
56905: IN
56906: IFFALSE 56957
// begin tmp := mc_busy_turret_list [ i ] diff building ;
56908: LD_ADDR_VAR 0 5
56912: PUSH
56913: LD_EXP 109
56917: PUSH
56918: LD_VAR 0 4
56922: ARRAY
56923: PUSH
56924: LD_VAR 0 1
56928: DIFF
56929: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
56930: LD_ADDR_EXP 109
56934: PUSH
56935: LD_EXP 109
56939: PPUSH
56940: LD_VAR 0 4
56944: PPUSH
56945: LD_VAR 0 5
56949: PPUSH
56950: CALL_OW 1
56954: ST_TO_ADDR
// break ;
56955: GO 56959
// end ; end ;
56957: GO 56887
56959: POP
56960: POP
// end ;
56961: LD_VAR 0 3
56965: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
56966: LD_INT 0
56968: PPUSH
56969: PPUSH
56970: PPUSH
// if not mc_bases or not skirmish then
56971: LD_EXP 99
56975: NOT
56976: PUSH
56977: LD_EXP 97
56981: NOT
56982: OR
56983: IFFALSE 56987
// exit ;
56985: GO 57186
// for i = 1 to mc_bases do
56987: LD_ADDR_VAR 0 5
56991: PUSH
56992: DOUBLE
56993: LD_INT 1
56995: DEC
56996: ST_TO_ADDR
56997: LD_EXP 99
57001: PUSH
57002: FOR_TO
57003: IFFALSE 57184
// if building in mc_bases [ i ] then
57005: LD_VAR 0 1
57009: PUSH
57010: LD_EXP 99
57014: PUSH
57015: LD_VAR 0 5
57019: ARRAY
57020: IN
57021: IFFALSE 57182
// begin tmp := mc_bases [ i ] diff building ;
57023: LD_ADDR_VAR 0 6
57027: PUSH
57028: LD_EXP 99
57032: PUSH
57033: LD_VAR 0 5
57037: ARRAY
57038: PUSH
57039: LD_VAR 0 1
57043: DIFF
57044: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
57045: LD_ADDR_EXP 99
57049: PUSH
57050: LD_EXP 99
57054: PPUSH
57055: LD_VAR 0 5
57059: PPUSH
57060: LD_VAR 0 6
57064: PPUSH
57065: CALL_OW 1
57069: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
57070: LD_VAR 0 1
57074: PUSH
57075: LD_EXP 107
57079: PUSH
57080: LD_VAR 0 5
57084: ARRAY
57085: IN
57086: IFFALSE 57125
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
57088: LD_ADDR_EXP 107
57092: PUSH
57093: LD_EXP 107
57097: PPUSH
57098: LD_VAR 0 5
57102: PPUSH
57103: LD_EXP 107
57107: PUSH
57108: LD_VAR 0 5
57112: ARRAY
57113: PUSH
57114: LD_VAR 0 1
57118: DIFF
57119: PPUSH
57120: CALL_OW 1
57124: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
57125: LD_VAR 0 1
57129: PUSH
57130: LD_EXP 108
57134: PUSH
57135: LD_VAR 0 5
57139: ARRAY
57140: IN
57141: IFFALSE 57180
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
57143: LD_ADDR_EXP 108
57147: PUSH
57148: LD_EXP 108
57152: PPUSH
57153: LD_VAR 0 5
57157: PPUSH
57158: LD_EXP 108
57162: PUSH
57163: LD_VAR 0 5
57167: ARRAY
57168: PUSH
57169: LD_VAR 0 1
57173: DIFF
57174: PPUSH
57175: CALL_OW 1
57179: ST_TO_ADDR
// break ;
57180: GO 57184
// end ;
57182: GO 57002
57184: POP
57185: POP
// end ;
57186: LD_VAR 0 4
57190: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
57191: LD_INT 0
57193: PPUSH
57194: PPUSH
57195: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
57196: LD_EXP 99
57200: NOT
57201: PUSH
57202: LD_EXP 97
57206: NOT
57207: OR
57208: PUSH
57209: LD_VAR 0 3
57213: PUSH
57214: LD_EXP 125
57218: IN
57219: NOT
57220: OR
57221: IFFALSE 57225
// exit ;
57223: GO 57348
// for i = 1 to mc_vehicles do
57225: LD_ADDR_VAR 0 6
57229: PUSH
57230: DOUBLE
57231: LD_INT 1
57233: DEC
57234: ST_TO_ADDR
57235: LD_EXP 118
57239: PUSH
57240: FOR_TO
57241: IFFALSE 57346
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
57243: LD_VAR 0 2
57247: PUSH
57248: LD_EXP 118
57252: PUSH
57253: LD_VAR 0 6
57257: ARRAY
57258: IN
57259: PUSH
57260: LD_VAR 0 1
57264: PUSH
57265: LD_EXP 118
57269: PUSH
57270: LD_VAR 0 6
57274: ARRAY
57275: IN
57276: OR
57277: IFFALSE 57344
// begin tmp := mc_vehicles [ i ] diff old ;
57279: LD_ADDR_VAR 0 7
57283: PUSH
57284: LD_EXP 118
57288: PUSH
57289: LD_VAR 0 6
57293: ARRAY
57294: PUSH
57295: LD_VAR 0 2
57299: DIFF
57300: ST_TO_ADDR
// tmp := tmp diff new ;
57301: LD_ADDR_VAR 0 7
57305: PUSH
57306: LD_VAR 0 7
57310: PUSH
57311: LD_VAR 0 1
57315: DIFF
57316: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
57317: LD_ADDR_EXP 118
57321: PUSH
57322: LD_EXP 118
57326: PPUSH
57327: LD_VAR 0 6
57331: PPUSH
57332: LD_VAR 0 7
57336: PPUSH
57337: CALL_OW 1
57341: ST_TO_ADDR
// break ;
57342: GO 57346
// end ;
57344: GO 57240
57346: POP
57347: POP
// end ;
57348: LD_VAR 0 5
57352: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
57353: LD_INT 0
57355: PPUSH
57356: PPUSH
57357: PPUSH
57358: PPUSH
// if not mc_bases or not skirmish then
57359: LD_EXP 99
57363: NOT
57364: PUSH
57365: LD_EXP 97
57369: NOT
57370: OR
57371: IFFALSE 57375
// exit ;
57373: GO 57758
// side := GetSide ( vehicle ) ;
57375: LD_ADDR_VAR 0 5
57379: PUSH
57380: LD_VAR 0 1
57384: PPUSH
57385: CALL_OW 255
57389: ST_TO_ADDR
// for i = 1 to mc_bases do
57390: LD_ADDR_VAR 0 4
57394: PUSH
57395: DOUBLE
57396: LD_INT 1
57398: DEC
57399: ST_TO_ADDR
57400: LD_EXP 99
57404: PUSH
57405: FOR_TO
57406: IFFALSE 57756
// begin if factory in mc_bases [ i ] then
57408: LD_VAR 0 2
57412: PUSH
57413: LD_EXP 99
57417: PUSH
57418: LD_VAR 0 4
57422: ARRAY
57423: IN
57424: IFFALSE 57754
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
57426: LD_EXP 121
57430: PUSH
57431: LD_VAR 0 4
57435: ARRAY
57436: PUSH
57437: LD_EXP 110
57441: PUSH
57442: LD_VAR 0 4
57446: ARRAY
57447: LESS
57448: PUSH
57449: LD_VAR 0 1
57453: PPUSH
57454: CALL_OW 264
57458: PUSH
57459: LD_INT 31
57461: PUSH
57462: LD_INT 32
57464: PUSH
57465: LD_INT 51
57467: PUSH
57468: LD_EXP 93
57472: PUSH
57473: LD_INT 12
57475: PUSH
57476: LD_INT 30
57478: PUSH
57479: LD_EXP 92
57483: PUSH
57484: LD_INT 11
57486: PUSH
57487: LD_INT 53
57489: PUSH
57490: LD_INT 14
57492: PUSH
57493: LD_EXP 96
57497: PUSH
57498: LD_INT 29
57500: PUSH
57501: LD_EXP 94
57505: PUSH
57506: LD_INT 13
57508: PUSH
57509: LD_INT 52
57511: PUSH
57512: LD_INT 48
57514: PUSH
57515: LD_INT 8
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: LIST
57522: LIST
57523: LIST
57524: LIST
57525: LIST
57526: LIST
57527: LIST
57528: LIST
57529: LIST
57530: LIST
57531: LIST
57532: LIST
57533: LIST
57534: LIST
57535: LIST
57536: IN
57537: NOT
57538: AND
57539: IFFALSE 57580
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
57541: LD_ADDR_EXP 121
57545: PUSH
57546: LD_EXP 121
57550: PPUSH
57551: LD_VAR 0 4
57555: PPUSH
57556: LD_EXP 121
57560: PUSH
57561: LD_VAR 0 4
57565: ARRAY
57566: PUSH
57567: LD_VAR 0 1
57571: ADD
57572: PPUSH
57573: CALL_OW 1
57577: ST_TO_ADDR
57578: GO 57624
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
57580: LD_ADDR_EXP 118
57584: PUSH
57585: LD_EXP 118
57589: PPUSH
57590: LD_VAR 0 4
57594: PUSH
57595: LD_EXP 118
57599: PUSH
57600: LD_VAR 0 4
57604: ARRAY
57605: PUSH
57606: LD_INT 1
57608: PLUS
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: PPUSH
57614: LD_VAR 0 1
57618: PPUSH
57619: CALL 67726 0 3
57623: ST_TO_ADDR
// if not mc_scan [ i ] then
57624: LD_EXP 122
57628: PUSH
57629: LD_VAR 0 4
57633: ARRAY
57634: NOT
57635: IFFALSE 57754
// begin if GetControl ( vehicle ) = control_remote then
57637: LD_VAR 0 1
57641: PPUSH
57642: CALL_OW 263
57646: PUSH
57647: LD_INT 2
57649: EQUAL
57650: IFFALSE 57670
// repeat wait ( 0 0$1 ) ;
57652: LD_INT 35
57654: PPUSH
57655: CALL_OW 67
// until IsControledBy ( vehicle ) ;
57659: LD_VAR 0 1
57663: PPUSH
57664: CALL_OW 312
57668: IFFALSE 57652
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
57670: LD_VAR 0 1
57674: PPUSH
57675: LD_EXP 123
57679: PUSH
57680: LD_VAR 0 4
57684: ARRAY
57685: PPUSH
57686: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
57690: LD_VAR 0 1
57694: PPUSH
57695: CALL_OW 263
57699: PUSH
57700: LD_INT 1
57702: NONEQUAL
57703: IFFALSE 57707
// break ;
57705: GO 57756
// repeat wait ( 0 0$1 ) ;
57707: LD_INT 35
57709: PPUSH
57710: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
57714: LD_VAR 0 1
57718: PPUSH
57719: LD_EXP 123
57723: PUSH
57724: LD_VAR 0 4
57728: ARRAY
57729: PPUSH
57730: CALL_OW 308
57734: IFFALSE 57707
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
57736: LD_VAR 0 1
57740: PPUSH
57741: CALL_OW 311
57745: PPUSH
57746: CALL_OW 121
// exit ;
57750: POP
57751: POP
57752: GO 57758
// end ; end ; end ;
57754: GO 57405
57756: POP
57757: POP
// end ;
57758: LD_VAR 0 3
57762: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
57763: LD_INT 0
57765: PPUSH
57766: PPUSH
57767: PPUSH
57768: PPUSH
// if not mc_bases or not skirmish then
57769: LD_EXP 99
57773: NOT
57774: PUSH
57775: LD_EXP 97
57779: NOT
57780: OR
57781: IFFALSE 57785
// exit ;
57783: GO 58138
// repeat wait ( 0 0$1 ) ;
57785: LD_INT 35
57787: PPUSH
57788: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
57792: LD_VAR 0 2
57796: PPUSH
57797: LD_VAR 0 3
57801: PPUSH
57802: CALL_OW 284
57806: IFFALSE 57785
// if GetResourceTypeXY ( x , y ) = mat_artefact then
57808: LD_VAR 0 2
57812: PPUSH
57813: LD_VAR 0 3
57817: PPUSH
57818: CALL_OW 283
57822: PUSH
57823: LD_INT 4
57825: EQUAL
57826: IFFALSE 57830
// exit ;
57828: GO 58138
// for i = 1 to mc_bases do
57830: LD_ADDR_VAR 0 7
57834: PUSH
57835: DOUBLE
57836: LD_INT 1
57838: DEC
57839: ST_TO_ADDR
57840: LD_EXP 99
57844: PUSH
57845: FOR_TO
57846: IFFALSE 58136
// begin if mc_crates_area [ i ] then
57848: LD_EXP 117
57852: PUSH
57853: LD_VAR 0 7
57857: ARRAY
57858: IFFALSE 57969
// for j in mc_crates_area [ i ] do
57860: LD_ADDR_VAR 0 8
57864: PUSH
57865: LD_EXP 117
57869: PUSH
57870: LD_VAR 0 7
57874: ARRAY
57875: PUSH
57876: FOR_IN
57877: IFFALSE 57967
// if InArea ( x , y , j ) then
57879: LD_VAR 0 2
57883: PPUSH
57884: LD_VAR 0 3
57888: PPUSH
57889: LD_VAR 0 8
57893: PPUSH
57894: CALL_OW 309
57898: IFFALSE 57965
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
57900: LD_ADDR_EXP 115
57904: PUSH
57905: LD_EXP 115
57909: PPUSH
57910: LD_VAR 0 7
57914: PUSH
57915: LD_EXP 115
57919: PUSH
57920: LD_VAR 0 7
57924: ARRAY
57925: PUSH
57926: LD_INT 1
57928: PLUS
57929: PUSH
57930: EMPTY
57931: LIST
57932: LIST
57933: PPUSH
57934: LD_VAR 0 4
57938: PUSH
57939: LD_VAR 0 2
57943: PUSH
57944: LD_VAR 0 3
57948: PUSH
57949: EMPTY
57950: LIST
57951: LIST
57952: LIST
57953: PPUSH
57954: CALL 67726 0 3
57958: ST_TO_ADDR
// exit ;
57959: POP
57960: POP
57961: POP
57962: POP
57963: GO 58138
// end ;
57965: GO 57876
57967: POP
57968: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57969: LD_ADDR_VAR 0 9
57973: PUSH
57974: LD_EXP 99
57978: PUSH
57979: LD_VAR 0 7
57983: ARRAY
57984: PPUSH
57985: LD_INT 2
57987: PUSH
57988: LD_INT 30
57990: PUSH
57991: LD_INT 0
57993: PUSH
57994: EMPTY
57995: LIST
57996: LIST
57997: PUSH
57998: LD_INT 30
58000: PUSH
58001: LD_INT 1
58003: PUSH
58004: EMPTY
58005: LIST
58006: LIST
58007: PUSH
58008: EMPTY
58009: LIST
58010: LIST
58011: LIST
58012: PPUSH
58013: CALL_OW 72
58017: ST_TO_ADDR
// if not depot then
58018: LD_VAR 0 9
58022: NOT
58023: IFFALSE 58027
// continue ;
58025: GO 57845
// for j in depot do
58027: LD_ADDR_VAR 0 8
58031: PUSH
58032: LD_VAR 0 9
58036: PUSH
58037: FOR_IN
58038: IFFALSE 58132
// if GetDistUnitXY ( j , x , y ) < 30 then
58040: LD_VAR 0 8
58044: PPUSH
58045: LD_VAR 0 2
58049: PPUSH
58050: LD_VAR 0 3
58054: PPUSH
58055: CALL_OW 297
58059: PUSH
58060: LD_INT 30
58062: LESS
58063: IFFALSE 58130
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58065: LD_ADDR_EXP 115
58069: PUSH
58070: LD_EXP 115
58074: PPUSH
58075: LD_VAR 0 7
58079: PUSH
58080: LD_EXP 115
58084: PUSH
58085: LD_VAR 0 7
58089: ARRAY
58090: PUSH
58091: LD_INT 1
58093: PLUS
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PPUSH
58099: LD_VAR 0 4
58103: PUSH
58104: LD_VAR 0 2
58108: PUSH
58109: LD_VAR 0 3
58113: PUSH
58114: EMPTY
58115: LIST
58116: LIST
58117: LIST
58118: PPUSH
58119: CALL 67726 0 3
58123: ST_TO_ADDR
// exit ;
58124: POP
58125: POP
58126: POP
58127: POP
58128: GO 58138
// end ;
58130: GO 58037
58132: POP
58133: POP
// end ;
58134: GO 57845
58136: POP
58137: POP
// end ;
58138: LD_VAR 0 6
58142: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
58143: LD_INT 0
58145: PPUSH
58146: PPUSH
58147: PPUSH
58148: PPUSH
// if not mc_bases or not skirmish then
58149: LD_EXP 99
58153: NOT
58154: PUSH
58155: LD_EXP 97
58159: NOT
58160: OR
58161: IFFALSE 58165
// exit ;
58163: GO 58442
// side := GetSide ( lab ) ;
58165: LD_ADDR_VAR 0 4
58169: PUSH
58170: LD_VAR 0 2
58174: PPUSH
58175: CALL_OW 255
58179: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
58180: LD_VAR 0 4
58184: PUSH
58185: LD_EXP 125
58189: IN
58190: NOT
58191: PUSH
58192: LD_EXP 126
58196: NOT
58197: OR
58198: PUSH
58199: LD_EXP 99
58203: NOT
58204: OR
58205: IFFALSE 58209
// exit ;
58207: GO 58442
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
58209: LD_ADDR_EXP 126
58213: PUSH
58214: LD_EXP 126
58218: PPUSH
58219: LD_VAR 0 4
58223: PPUSH
58224: LD_EXP 126
58228: PUSH
58229: LD_VAR 0 4
58233: ARRAY
58234: PUSH
58235: LD_VAR 0 1
58239: DIFF
58240: PPUSH
58241: CALL_OW 1
58245: ST_TO_ADDR
// for i = 1 to mc_bases do
58246: LD_ADDR_VAR 0 5
58250: PUSH
58251: DOUBLE
58252: LD_INT 1
58254: DEC
58255: ST_TO_ADDR
58256: LD_EXP 99
58260: PUSH
58261: FOR_TO
58262: IFFALSE 58440
// begin if lab in mc_bases [ i ] then
58264: LD_VAR 0 2
58268: PUSH
58269: LD_EXP 99
58273: PUSH
58274: LD_VAR 0 5
58278: ARRAY
58279: IN
58280: IFFALSE 58438
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
58282: LD_VAR 0 1
58286: PUSH
58287: LD_INT 11
58289: PUSH
58290: LD_INT 4
58292: PUSH
58293: LD_INT 3
58295: PUSH
58296: LD_INT 2
58298: PUSH
58299: EMPTY
58300: LIST
58301: LIST
58302: LIST
58303: LIST
58304: IN
58305: PUSH
58306: LD_EXP 129
58310: PUSH
58311: LD_VAR 0 5
58315: ARRAY
58316: AND
58317: IFFALSE 58438
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
58319: LD_ADDR_VAR 0 6
58323: PUSH
58324: LD_EXP 129
58328: PUSH
58329: LD_VAR 0 5
58333: ARRAY
58334: PUSH
58335: LD_INT 1
58337: ARRAY
58338: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58339: LD_ADDR_EXP 129
58343: PUSH
58344: LD_EXP 129
58348: PPUSH
58349: LD_VAR 0 5
58353: PPUSH
58354: EMPTY
58355: PPUSH
58356: CALL_OW 1
58360: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
58361: LD_VAR 0 6
58365: PPUSH
58366: LD_INT 0
58368: PPUSH
58369: CALL_OW 109
// ComExitBuilding ( tmp ) ;
58373: LD_VAR 0 6
58377: PPUSH
58378: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
58382: LD_ADDR_EXP 128
58386: PUSH
58387: LD_EXP 128
58391: PPUSH
58392: LD_VAR 0 5
58396: PPUSH
58397: LD_EXP 128
58401: PUSH
58402: LD_VAR 0 5
58406: ARRAY
58407: PPUSH
58408: LD_INT 1
58410: PPUSH
58411: LD_VAR 0 6
58415: PPUSH
58416: CALL_OW 2
58420: PPUSH
58421: CALL_OW 1
58425: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
58426: LD_VAR 0 5
58430: PPUSH
58431: LD_INT 112
58433: PPUSH
58434: CALL 35875 0 2
// end ; end ; end ;
58438: GO 58261
58440: POP
58441: POP
// end ;
58442: LD_VAR 0 3
58446: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
58447: LD_INT 0
58449: PPUSH
58450: PPUSH
58451: PPUSH
58452: PPUSH
58453: PPUSH
58454: PPUSH
58455: PPUSH
58456: PPUSH
// if not mc_bases or not skirmish then
58457: LD_EXP 99
58461: NOT
58462: PUSH
58463: LD_EXP 97
58467: NOT
58468: OR
58469: IFFALSE 58473
// exit ;
58471: GO 59416
// for i = 1 to mc_bases do
58473: LD_ADDR_VAR 0 3
58477: PUSH
58478: DOUBLE
58479: LD_INT 1
58481: DEC
58482: ST_TO_ADDR
58483: LD_EXP 99
58487: PUSH
58488: FOR_TO
58489: IFFALSE 59414
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
58491: LD_VAR 0 1
58495: PUSH
58496: LD_EXP 99
58500: PUSH
58501: LD_VAR 0 3
58505: ARRAY
58506: IN
58507: PUSH
58508: LD_VAR 0 1
58512: PUSH
58513: LD_EXP 106
58517: PUSH
58518: LD_VAR 0 3
58522: ARRAY
58523: IN
58524: OR
58525: PUSH
58526: LD_VAR 0 1
58530: PUSH
58531: LD_EXP 118
58535: PUSH
58536: LD_VAR 0 3
58540: ARRAY
58541: IN
58542: OR
58543: PUSH
58544: LD_VAR 0 1
58548: PUSH
58549: LD_EXP 128
58553: PUSH
58554: LD_VAR 0 3
58558: ARRAY
58559: IN
58560: OR
58561: PUSH
58562: LD_VAR 0 1
58566: PUSH
58567: LD_EXP 129
58571: PUSH
58572: LD_VAR 0 3
58576: ARRAY
58577: IN
58578: OR
58579: IFFALSE 59412
// begin if un in mc_ape [ i ] then
58581: LD_VAR 0 1
58585: PUSH
58586: LD_EXP 128
58590: PUSH
58591: LD_VAR 0 3
58595: ARRAY
58596: IN
58597: IFFALSE 58636
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
58599: LD_ADDR_EXP 128
58603: PUSH
58604: LD_EXP 128
58608: PPUSH
58609: LD_VAR 0 3
58613: PPUSH
58614: LD_EXP 128
58618: PUSH
58619: LD_VAR 0 3
58623: ARRAY
58624: PUSH
58625: LD_VAR 0 1
58629: DIFF
58630: PPUSH
58631: CALL_OW 1
58635: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
58636: LD_VAR 0 1
58640: PUSH
58641: LD_EXP 129
58645: PUSH
58646: LD_VAR 0 3
58650: ARRAY
58651: IN
58652: IFFALSE 58676
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58654: LD_ADDR_EXP 129
58658: PUSH
58659: LD_EXP 129
58663: PPUSH
58664: LD_VAR 0 3
58668: PPUSH
58669: EMPTY
58670: PPUSH
58671: CALL_OW 1
58675: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
58676: LD_VAR 0 1
58680: PPUSH
58681: CALL_OW 247
58685: PUSH
58686: LD_INT 2
58688: EQUAL
58689: PUSH
58690: LD_VAR 0 1
58694: PPUSH
58695: CALL_OW 110
58699: PUSH
58700: LD_INT 20
58702: EQUAL
58703: AND
58704: IFFALSE 58807
// begin fac := MC_GetBuilding ( i , b_factory ) ;
58706: LD_ADDR_VAR 0 8
58710: PUSH
58711: LD_VAR 0 3
58715: PPUSH
58716: LD_INT 3
58718: PPUSH
58719: CALL 55506 0 2
58723: ST_TO_ADDR
// if fac then
58724: LD_VAR 0 8
58728: IFFALSE 58807
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
58730: LD_ADDR_VAR 0 9
58734: PUSH
58735: LD_VAR 0 8
58739: PPUSH
58740: LD_VAR 0 1
58744: PPUSH
58745: CALL_OW 265
58749: PPUSH
58750: LD_VAR 0 1
58754: PPUSH
58755: CALL_OW 262
58759: PPUSH
58760: LD_VAR 0 1
58764: PPUSH
58765: CALL_OW 263
58769: PPUSH
58770: LD_VAR 0 1
58774: PPUSH
58775: CALL_OW 264
58779: PPUSH
58780: CALL 65326 0 5
58784: ST_TO_ADDR
// if components then
58785: LD_VAR 0 9
58789: IFFALSE 58805
// MC_InsertProduceList ( i , components ) ;
58791: LD_VAR 0 3
58795: PPUSH
58796: LD_VAR 0 9
58800: PPUSH
58801: CALL 55076 0 2
// break ;
58805: GO 59414
// end ; end ; if GetType ( un ) = unit_building then
58807: LD_VAR 0 1
58811: PPUSH
58812: CALL_OW 247
58816: PUSH
58817: LD_INT 3
58819: EQUAL
58820: IFFALSE 59135
// begin btype := GetBType ( un ) ;
58822: LD_ADDR_VAR 0 5
58826: PUSH
58827: LD_VAR 0 1
58831: PPUSH
58832: CALL_OW 266
58836: ST_TO_ADDR
// if btype = b_warehouse then
58837: LD_VAR 0 5
58841: PUSH
58842: LD_INT 1
58844: EQUAL
58845: IFFALSE 58863
// begin btype := b_depot ;
58847: LD_ADDR_VAR 0 5
58851: PUSH
58852: LD_INT 0
58854: ST_TO_ADDR
// pos := 1 ;
58855: LD_ADDR_VAR 0 6
58859: PUSH
58860: LD_INT 1
58862: ST_TO_ADDR
// end ; if btype = b_factory then
58863: LD_VAR 0 5
58867: PUSH
58868: LD_INT 3
58870: EQUAL
58871: IFFALSE 58889
// begin btype := b_workshop ;
58873: LD_ADDR_VAR 0 5
58877: PUSH
58878: LD_INT 2
58880: ST_TO_ADDR
// pos := 1 ;
58881: LD_ADDR_VAR 0 6
58885: PUSH
58886: LD_INT 1
58888: ST_TO_ADDR
// end ; if btype = b_barracks then
58889: LD_VAR 0 5
58893: PUSH
58894: LD_INT 5
58896: EQUAL
58897: IFFALSE 58907
// btype := b_armoury ;
58899: LD_ADDR_VAR 0 5
58903: PUSH
58904: LD_INT 4
58906: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
58907: LD_VAR 0 5
58911: PUSH
58912: LD_INT 7
58914: PUSH
58915: LD_INT 8
58917: PUSH
58918: EMPTY
58919: LIST
58920: LIST
58921: IN
58922: IFFALSE 58932
// btype := b_lab ;
58924: LD_ADDR_VAR 0 5
58928: PUSH
58929: LD_INT 6
58931: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
58932: LD_ADDR_EXP 104
58936: PUSH
58937: LD_EXP 104
58941: PPUSH
58942: LD_VAR 0 3
58946: PUSH
58947: LD_EXP 104
58951: PUSH
58952: LD_VAR 0 3
58956: ARRAY
58957: PUSH
58958: LD_INT 1
58960: PLUS
58961: PUSH
58962: EMPTY
58963: LIST
58964: LIST
58965: PPUSH
58966: LD_VAR 0 5
58970: PUSH
58971: LD_VAR 0 1
58975: PPUSH
58976: CALL_OW 250
58980: PUSH
58981: LD_VAR 0 1
58985: PPUSH
58986: CALL_OW 251
58990: PUSH
58991: LD_VAR 0 1
58995: PPUSH
58996: CALL_OW 254
59000: PUSH
59001: EMPTY
59002: LIST
59003: LIST
59004: LIST
59005: LIST
59006: PPUSH
59007: CALL 67726 0 3
59011: ST_TO_ADDR
// if pos = 1 then
59012: LD_VAR 0 6
59016: PUSH
59017: LD_INT 1
59019: EQUAL
59020: IFFALSE 59135
// begin tmp := mc_build_list [ i ] ;
59022: LD_ADDR_VAR 0 7
59026: PUSH
59027: LD_EXP 104
59031: PUSH
59032: LD_VAR 0 3
59036: ARRAY
59037: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59038: LD_VAR 0 7
59042: PPUSH
59043: LD_INT 2
59045: PUSH
59046: LD_INT 30
59048: PUSH
59049: LD_INT 0
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: PUSH
59056: LD_INT 30
59058: PUSH
59059: LD_INT 1
59061: PUSH
59062: EMPTY
59063: LIST
59064: LIST
59065: PUSH
59066: EMPTY
59067: LIST
59068: LIST
59069: LIST
59070: PPUSH
59071: CALL_OW 72
59075: IFFALSE 59085
// pos := 2 ;
59077: LD_ADDR_VAR 0 6
59081: PUSH
59082: LD_INT 2
59084: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
59085: LD_ADDR_VAR 0 7
59089: PUSH
59090: LD_VAR 0 7
59094: PPUSH
59095: LD_VAR 0 6
59099: PPUSH
59100: LD_VAR 0 7
59104: PPUSH
59105: CALL 68052 0 3
59109: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
59110: LD_ADDR_EXP 104
59114: PUSH
59115: LD_EXP 104
59119: PPUSH
59120: LD_VAR 0 3
59124: PPUSH
59125: LD_VAR 0 7
59129: PPUSH
59130: CALL_OW 1
59134: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
59135: LD_VAR 0 1
59139: PUSH
59140: LD_EXP 99
59144: PUSH
59145: LD_VAR 0 3
59149: ARRAY
59150: IN
59151: IFFALSE 59190
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
59153: LD_ADDR_EXP 99
59157: PUSH
59158: LD_EXP 99
59162: PPUSH
59163: LD_VAR 0 3
59167: PPUSH
59168: LD_EXP 99
59172: PUSH
59173: LD_VAR 0 3
59177: ARRAY
59178: PUSH
59179: LD_VAR 0 1
59183: DIFF
59184: PPUSH
59185: CALL_OW 1
59189: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
59190: LD_VAR 0 1
59194: PUSH
59195: LD_EXP 106
59199: PUSH
59200: LD_VAR 0 3
59204: ARRAY
59205: IN
59206: IFFALSE 59245
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
59208: LD_ADDR_EXP 106
59212: PUSH
59213: LD_EXP 106
59217: PPUSH
59218: LD_VAR 0 3
59222: PPUSH
59223: LD_EXP 106
59227: PUSH
59228: LD_VAR 0 3
59232: ARRAY
59233: PUSH
59234: LD_VAR 0 1
59238: DIFF
59239: PPUSH
59240: CALL_OW 1
59244: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
59245: LD_VAR 0 1
59249: PUSH
59250: LD_EXP 118
59254: PUSH
59255: LD_VAR 0 3
59259: ARRAY
59260: IN
59261: IFFALSE 59300
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
59263: LD_ADDR_EXP 118
59267: PUSH
59268: LD_EXP 118
59272: PPUSH
59273: LD_VAR 0 3
59277: PPUSH
59278: LD_EXP 118
59282: PUSH
59283: LD_VAR 0 3
59287: ARRAY
59288: PUSH
59289: LD_VAR 0 1
59293: DIFF
59294: PPUSH
59295: CALL_OW 1
59299: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
59300: LD_VAR 0 1
59304: PUSH
59305: LD_EXP 108
59309: PUSH
59310: LD_VAR 0 3
59314: ARRAY
59315: IN
59316: IFFALSE 59355
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
59318: LD_ADDR_EXP 108
59322: PUSH
59323: LD_EXP 108
59327: PPUSH
59328: LD_VAR 0 3
59332: PPUSH
59333: LD_EXP 108
59337: PUSH
59338: LD_VAR 0 3
59342: ARRAY
59343: PUSH
59344: LD_VAR 0 1
59348: DIFF
59349: PPUSH
59350: CALL_OW 1
59354: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
59355: LD_VAR 0 1
59359: PUSH
59360: LD_EXP 107
59364: PUSH
59365: LD_VAR 0 3
59369: ARRAY
59370: IN
59371: IFFALSE 59410
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
59373: LD_ADDR_EXP 107
59377: PUSH
59378: LD_EXP 107
59382: PPUSH
59383: LD_VAR 0 3
59387: PPUSH
59388: LD_EXP 107
59392: PUSH
59393: LD_VAR 0 3
59397: ARRAY
59398: PUSH
59399: LD_VAR 0 1
59403: DIFF
59404: PPUSH
59405: CALL_OW 1
59409: ST_TO_ADDR
// end ; break ;
59410: GO 59414
// end ;
59412: GO 58488
59414: POP
59415: POP
// end ;
59416: LD_VAR 0 2
59420: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
59421: LD_INT 0
59423: PPUSH
59424: PPUSH
59425: PPUSH
// if not mc_bases or not skirmish then
59426: LD_EXP 99
59430: NOT
59431: PUSH
59432: LD_EXP 97
59436: NOT
59437: OR
59438: IFFALSE 59442
// exit ;
59440: GO 59657
// for i = 1 to mc_bases do
59442: LD_ADDR_VAR 0 3
59446: PUSH
59447: DOUBLE
59448: LD_INT 1
59450: DEC
59451: ST_TO_ADDR
59452: LD_EXP 99
59456: PUSH
59457: FOR_TO
59458: IFFALSE 59655
// begin if building in mc_construct_list [ i ] then
59460: LD_VAR 0 1
59464: PUSH
59465: LD_EXP 106
59469: PUSH
59470: LD_VAR 0 3
59474: ARRAY
59475: IN
59476: IFFALSE 59653
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
59478: LD_ADDR_EXP 106
59482: PUSH
59483: LD_EXP 106
59487: PPUSH
59488: LD_VAR 0 3
59492: PPUSH
59493: LD_EXP 106
59497: PUSH
59498: LD_VAR 0 3
59502: ARRAY
59503: PUSH
59504: LD_VAR 0 1
59508: DIFF
59509: PPUSH
59510: CALL_OW 1
59514: ST_TO_ADDR
// if building in mc_lab [ i ] then
59515: LD_VAR 0 1
59519: PUSH
59520: LD_EXP 132
59524: PUSH
59525: LD_VAR 0 3
59529: ARRAY
59530: IN
59531: IFFALSE 59586
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
59533: LD_ADDR_EXP 133
59537: PUSH
59538: LD_EXP 133
59542: PPUSH
59543: LD_VAR 0 3
59547: PPUSH
59548: LD_EXP 133
59552: PUSH
59553: LD_VAR 0 3
59557: ARRAY
59558: PPUSH
59559: LD_INT 1
59561: PPUSH
59562: LD_EXP 133
59566: PUSH
59567: LD_VAR 0 3
59571: ARRAY
59572: PPUSH
59573: LD_INT 0
59575: PPUSH
59576: CALL 67144 0 4
59580: PPUSH
59581: CALL_OW 1
59585: ST_TO_ADDR
// if not building in mc_bases [ i ] then
59586: LD_VAR 0 1
59590: PUSH
59591: LD_EXP 99
59595: PUSH
59596: LD_VAR 0 3
59600: ARRAY
59601: IN
59602: NOT
59603: IFFALSE 59649
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
59605: LD_ADDR_EXP 99
59609: PUSH
59610: LD_EXP 99
59614: PPUSH
59615: LD_VAR 0 3
59619: PUSH
59620: LD_EXP 99
59624: PUSH
59625: LD_VAR 0 3
59629: ARRAY
59630: PUSH
59631: LD_INT 1
59633: PLUS
59634: PUSH
59635: EMPTY
59636: LIST
59637: LIST
59638: PPUSH
59639: LD_VAR 0 1
59643: PPUSH
59644: CALL 67726 0 3
59648: ST_TO_ADDR
// exit ;
59649: POP
59650: POP
59651: GO 59657
// end ; end ;
59653: GO 59457
59655: POP
59656: POP
// end ;
59657: LD_VAR 0 2
59661: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
59662: LD_INT 0
59664: PPUSH
59665: PPUSH
59666: PPUSH
59667: PPUSH
59668: PPUSH
59669: PPUSH
59670: PPUSH
// if not mc_bases or not skirmish then
59671: LD_EXP 99
59675: NOT
59676: PUSH
59677: LD_EXP 97
59681: NOT
59682: OR
59683: IFFALSE 59687
// exit ;
59685: GO 60348
// for i = 1 to mc_bases do
59687: LD_ADDR_VAR 0 3
59691: PUSH
59692: DOUBLE
59693: LD_INT 1
59695: DEC
59696: ST_TO_ADDR
59697: LD_EXP 99
59701: PUSH
59702: FOR_TO
59703: IFFALSE 60346
// begin if building in mc_construct_list [ i ] then
59705: LD_VAR 0 1
59709: PUSH
59710: LD_EXP 106
59714: PUSH
59715: LD_VAR 0 3
59719: ARRAY
59720: IN
59721: IFFALSE 60344
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
59723: LD_ADDR_EXP 106
59727: PUSH
59728: LD_EXP 106
59732: PPUSH
59733: LD_VAR 0 3
59737: PPUSH
59738: LD_EXP 106
59742: PUSH
59743: LD_VAR 0 3
59747: ARRAY
59748: PUSH
59749: LD_VAR 0 1
59753: DIFF
59754: PPUSH
59755: CALL_OW 1
59759: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
59760: LD_ADDR_EXP 99
59764: PUSH
59765: LD_EXP 99
59769: PPUSH
59770: LD_VAR 0 3
59774: PUSH
59775: LD_EXP 99
59779: PUSH
59780: LD_VAR 0 3
59784: ARRAY
59785: PUSH
59786: LD_INT 1
59788: PLUS
59789: PUSH
59790: EMPTY
59791: LIST
59792: LIST
59793: PPUSH
59794: LD_VAR 0 1
59798: PPUSH
59799: CALL 67726 0 3
59803: ST_TO_ADDR
// btype := GetBType ( building ) ;
59804: LD_ADDR_VAR 0 5
59808: PUSH
59809: LD_VAR 0 1
59813: PPUSH
59814: CALL_OW 266
59818: ST_TO_ADDR
// side := GetSide ( building ) ;
59819: LD_ADDR_VAR 0 8
59823: PUSH
59824: LD_VAR 0 1
59828: PPUSH
59829: CALL_OW 255
59833: ST_TO_ADDR
// if btype = b_lab then
59834: LD_VAR 0 5
59838: PUSH
59839: LD_INT 6
59841: EQUAL
59842: IFFALSE 59892
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
59844: LD_ADDR_EXP 132
59848: PUSH
59849: LD_EXP 132
59853: PPUSH
59854: LD_VAR 0 3
59858: PUSH
59859: LD_EXP 132
59863: PUSH
59864: LD_VAR 0 3
59868: ARRAY
59869: PUSH
59870: LD_INT 1
59872: PLUS
59873: PUSH
59874: EMPTY
59875: LIST
59876: LIST
59877: PPUSH
59878: LD_VAR 0 1
59882: PPUSH
59883: CALL 67726 0 3
59887: ST_TO_ADDR
// exit ;
59888: POP
59889: POP
59890: GO 60348
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
59892: LD_VAR 0 5
59896: PUSH
59897: LD_INT 0
59899: PUSH
59900: LD_INT 2
59902: PUSH
59903: LD_INT 4
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: LIST
59910: IN
59911: IFFALSE 60035
// begin if btype = b_armoury then
59913: LD_VAR 0 5
59917: PUSH
59918: LD_INT 4
59920: EQUAL
59921: IFFALSE 59931
// btype := b_barracks ;
59923: LD_ADDR_VAR 0 5
59927: PUSH
59928: LD_INT 5
59930: ST_TO_ADDR
// if btype = b_depot then
59931: LD_VAR 0 5
59935: PUSH
59936: LD_INT 0
59938: EQUAL
59939: IFFALSE 59949
// btype := b_warehouse ;
59941: LD_ADDR_VAR 0 5
59945: PUSH
59946: LD_INT 1
59948: ST_TO_ADDR
// if btype = b_workshop then
59949: LD_VAR 0 5
59953: PUSH
59954: LD_INT 2
59956: EQUAL
59957: IFFALSE 59967
// btype := b_factory ;
59959: LD_ADDR_VAR 0 5
59963: PUSH
59964: LD_INT 3
59966: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
59967: LD_VAR 0 5
59971: PPUSH
59972: LD_VAR 0 8
59976: PPUSH
59977: CALL_OW 323
59981: PUSH
59982: LD_INT 1
59984: EQUAL
59985: IFFALSE 60031
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
59987: LD_ADDR_EXP 131
59991: PUSH
59992: LD_EXP 131
59996: PPUSH
59997: LD_VAR 0 3
60001: PUSH
60002: LD_EXP 131
60006: PUSH
60007: LD_VAR 0 3
60011: ARRAY
60012: PUSH
60013: LD_INT 1
60015: PLUS
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PPUSH
60021: LD_VAR 0 1
60025: PPUSH
60026: CALL 67726 0 3
60030: ST_TO_ADDR
// exit ;
60031: POP
60032: POP
60033: GO 60348
// end ; if btype in [ b_bunker , b_turret ] then
60035: LD_VAR 0 5
60039: PUSH
60040: LD_INT 32
60042: PUSH
60043: LD_INT 33
60045: PUSH
60046: EMPTY
60047: LIST
60048: LIST
60049: IN
60050: IFFALSE 60340
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
60052: LD_ADDR_EXP 107
60056: PUSH
60057: LD_EXP 107
60061: PPUSH
60062: LD_VAR 0 3
60066: PUSH
60067: LD_EXP 107
60071: PUSH
60072: LD_VAR 0 3
60076: ARRAY
60077: PUSH
60078: LD_INT 1
60080: PLUS
60081: PUSH
60082: EMPTY
60083: LIST
60084: LIST
60085: PPUSH
60086: LD_VAR 0 1
60090: PPUSH
60091: CALL 67726 0 3
60095: ST_TO_ADDR
// if btype = b_bunker then
60096: LD_VAR 0 5
60100: PUSH
60101: LD_INT 32
60103: EQUAL
60104: IFFALSE 60340
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
60106: LD_ADDR_EXP 108
60110: PUSH
60111: LD_EXP 108
60115: PPUSH
60116: LD_VAR 0 3
60120: PUSH
60121: LD_EXP 108
60125: PUSH
60126: LD_VAR 0 3
60130: ARRAY
60131: PUSH
60132: LD_INT 1
60134: PLUS
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: PPUSH
60140: LD_VAR 0 1
60144: PPUSH
60145: CALL 67726 0 3
60149: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
60150: LD_ADDR_VAR 0 6
60154: PUSH
60155: LD_EXP 99
60159: PUSH
60160: LD_VAR 0 3
60164: ARRAY
60165: PPUSH
60166: LD_INT 25
60168: PUSH
60169: LD_INT 1
60171: PUSH
60172: EMPTY
60173: LIST
60174: LIST
60175: PUSH
60176: LD_INT 3
60178: PUSH
60179: LD_INT 54
60181: PUSH
60182: EMPTY
60183: LIST
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: PPUSH
60193: CALL_OW 72
60197: ST_TO_ADDR
// if tmp then
60198: LD_VAR 0 6
60202: IFFALSE 60208
// exit ;
60204: POP
60205: POP
60206: GO 60348
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60208: LD_ADDR_VAR 0 6
60212: PUSH
60213: LD_EXP 99
60217: PUSH
60218: LD_VAR 0 3
60222: ARRAY
60223: PPUSH
60224: LD_INT 2
60226: PUSH
60227: LD_INT 30
60229: PUSH
60230: LD_INT 4
60232: PUSH
60233: EMPTY
60234: LIST
60235: LIST
60236: PUSH
60237: LD_INT 30
60239: PUSH
60240: LD_INT 5
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: LIST
60251: PPUSH
60252: CALL_OW 72
60256: ST_TO_ADDR
// if not tmp then
60257: LD_VAR 0 6
60261: NOT
60262: IFFALSE 60268
// exit ;
60264: POP
60265: POP
60266: GO 60348
// for j in tmp do
60268: LD_ADDR_VAR 0 4
60272: PUSH
60273: LD_VAR 0 6
60277: PUSH
60278: FOR_IN
60279: IFFALSE 60338
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
60281: LD_ADDR_VAR 0 7
60285: PUSH
60286: LD_VAR 0 4
60290: PPUSH
60291: CALL_OW 313
60295: PPUSH
60296: LD_INT 25
60298: PUSH
60299: LD_INT 1
60301: PUSH
60302: EMPTY
60303: LIST
60304: LIST
60305: PPUSH
60306: CALL_OW 72
60310: ST_TO_ADDR
// if units then
60311: LD_VAR 0 7
60315: IFFALSE 60336
// begin ComExitBuilding ( units [ 1 ] ) ;
60317: LD_VAR 0 7
60321: PUSH
60322: LD_INT 1
60324: ARRAY
60325: PPUSH
60326: CALL_OW 122
// exit ;
60330: POP
60331: POP
60332: POP
60333: POP
60334: GO 60348
// end ; end ;
60336: GO 60278
60338: POP
60339: POP
// end ; end ; exit ;
60340: POP
60341: POP
60342: GO 60348
// end ; end ;
60344: GO 59702
60346: POP
60347: POP
// end ;
60348: LD_VAR 0 2
60352: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
60353: LD_INT 0
60355: PPUSH
60356: PPUSH
60357: PPUSH
60358: PPUSH
60359: PPUSH
60360: PPUSH
60361: PPUSH
// if not mc_bases or not skirmish then
60362: LD_EXP 99
60366: NOT
60367: PUSH
60368: LD_EXP 97
60372: NOT
60373: OR
60374: IFFALSE 60378
// exit ;
60376: GO 60609
// btype := GetBType ( building ) ;
60378: LD_ADDR_VAR 0 6
60382: PUSH
60383: LD_VAR 0 1
60387: PPUSH
60388: CALL_OW 266
60392: ST_TO_ADDR
// x := GetX ( building ) ;
60393: LD_ADDR_VAR 0 7
60397: PUSH
60398: LD_VAR 0 1
60402: PPUSH
60403: CALL_OW 250
60407: ST_TO_ADDR
// y := GetY ( building ) ;
60408: LD_ADDR_VAR 0 8
60412: PUSH
60413: LD_VAR 0 1
60417: PPUSH
60418: CALL_OW 251
60422: ST_TO_ADDR
// d := GetDir ( building ) ;
60423: LD_ADDR_VAR 0 9
60427: PUSH
60428: LD_VAR 0 1
60432: PPUSH
60433: CALL_OW 254
60437: ST_TO_ADDR
// for i = 1 to mc_bases do
60438: LD_ADDR_VAR 0 4
60442: PUSH
60443: DOUBLE
60444: LD_INT 1
60446: DEC
60447: ST_TO_ADDR
60448: LD_EXP 99
60452: PUSH
60453: FOR_TO
60454: IFFALSE 60607
// begin if not mc_build_list [ i ] then
60456: LD_EXP 104
60460: PUSH
60461: LD_VAR 0 4
60465: ARRAY
60466: NOT
60467: IFFALSE 60471
// continue ;
60469: GO 60453
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
60471: LD_VAR 0 6
60475: PUSH
60476: LD_VAR 0 7
60480: PUSH
60481: LD_VAR 0 8
60485: PUSH
60486: LD_VAR 0 9
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: LIST
60495: LIST
60496: PPUSH
60497: LD_EXP 104
60501: PUSH
60502: LD_VAR 0 4
60506: ARRAY
60507: PUSH
60508: LD_INT 1
60510: ARRAY
60511: PPUSH
60512: CALL 73895 0 2
60516: IFFALSE 60605
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
60518: LD_ADDR_EXP 104
60522: PUSH
60523: LD_EXP 104
60527: PPUSH
60528: LD_VAR 0 4
60532: PPUSH
60533: LD_EXP 104
60537: PUSH
60538: LD_VAR 0 4
60542: ARRAY
60543: PPUSH
60544: LD_INT 1
60546: PPUSH
60547: CALL_OW 3
60551: PPUSH
60552: CALL_OW 1
60556: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
60557: LD_ADDR_EXP 106
60561: PUSH
60562: LD_EXP 106
60566: PPUSH
60567: LD_VAR 0 4
60571: PUSH
60572: LD_EXP 106
60576: PUSH
60577: LD_VAR 0 4
60581: ARRAY
60582: PUSH
60583: LD_INT 1
60585: PLUS
60586: PUSH
60587: EMPTY
60588: LIST
60589: LIST
60590: PPUSH
60591: LD_VAR 0 1
60595: PPUSH
60596: CALL 67726 0 3
60600: ST_TO_ADDR
// exit ;
60601: POP
60602: POP
60603: GO 60609
// end ; end ;
60605: GO 60453
60607: POP
60608: POP
// end ;
60609: LD_VAR 0 3
60613: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
60614: LD_INT 0
60616: PPUSH
60617: PPUSH
60618: PPUSH
// if not mc_bases or not skirmish then
60619: LD_EXP 99
60623: NOT
60624: PUSH
60625: LD_EXP 97
60629: NOT
60630: OR
60631: IFFALSE 60635
// exit ;
60633: GO 60825
// for i = 1 to mc_bases do
60635: LD_ADDR_VAR 0 4
60639: PUSH
60640: DOUBLE
60641: LD_INT 1
60643: DEC
60644: ST_TO_ADDR
60645: LD_EXP 99
60649: PUSH
60650: FOR_TO
60651: IFFALSE 60738
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
60653: LD_VAR 0 1
60657: PUSH
60658: LD_EXP 107
60662: PUSH
60663: LD_VAR 0 4
60667: ARRAY
60668: IN
60669: PUSH
60670: LD_VAR 0 1
60674: PUSH
60675: LD_EXP 108
60679: PUSH
60680: LD_VAR 0 4
60684: ARRAY
60685: IN
60686: NOT
60687: AND
60688: IFFALSE 60736
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
60690: LD_ADDR_EXP 108
60694: PUSH
60695: LD_EXP 108
60699: PPUSH
60700: LD_VAR 0 4
60704: PUSH
60705: LD_EXP 108
60709: PUSH
60710: LD_VAR 0 4
60714: ARRAY
60715: PUSH
60716: LD_INT 1
60718: PLUS
60719: PUSH
60720: EMPTY
60721: LIST
60722: LIST
60723: PPUSH
60724: LD_VAR 0 1
60728: PPUSH
60729: CALL 67726 0 3
60733: ST_TO_ADDR
// break ;
60734: GO 60738
// end ; end ;
60736: GO 60650
60738: POP
60739: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
60740: LD_VAR 0 1
60744: PPUSH
60745: CALL_OW 257
60749: PUSH
60750: LD_EXP 125
60754: IN
60755: PUSH
60756: LD_VAR 0 1
60760: PPUSH
60761: CALL_OW 266
60765: PUSH
60766: LD_INT 5
60768: EQUAL
60769: AND
60770: PUSH
60771: LD_VAR 0 2
60775: PPUSH
60776: CALL_OW 110
60780: PUSH
60781: LD_INT 18
60783: NONEQUAL
60784: AND
60785: IFFALSE 60825
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
60787: LD_VAR 0 2
60791: PPUSH
60792: CALL_OW 257
60796: PUSH
60797: LD_INT 5
60799: PUSH
60800: LD_INT 8
60802: PUSH
60803: LD_INT 9
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: LIST
60810: IN
60811: IFFALSE 60825
// SetClass ( unit , 1 ) ;
60813: LD_VAR 0 2
60817: PPUSH
60818: LD_INT 1
60820: PPUSH
60821: CALL_OW 336
// end ;
60825: LD_VAR 0 3
60829: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
60830: LD_INT 0
60832: PPUSH
60833: PPUSH
// if not mc_bases or not skirmish then
60834: LD_EXP 99
60838: NOT
60839: PUSH
60840: LD_EXP 97
60844: NOT
60845: OR
60846: IFFALSE 60850
// exit ;
60848: GO 60966
// if GetLives ( abandoned_vehicle ) > 250 then
60850: LD_VAR 0 2
60854: PPUSH
60855: CALL_OW 256
60859: PUSH
60860: LD_INT 250
60862: GREATER
60863: IFFALSE 60867
// exit ;
60865: GO 60966
// for i = 1 to mc_bases do
60867: LD_ADDR_VAR 0 6
60871: PUSH
60872: DOUBLE
60873: LD_INT 1
60875: DEC
60876: ST_TO_ADDR
60877: LD_EXP 99
60881: PUSH
60882: FOR_TO
60883: IFFALSE 60964
// begin if driver in mc_bases [ i ] then
60885: LD_VAR 0 1
60889: PUSH
60890: LD_EXP 99
60894: PUSH
60895: LD_VAR 0 6
60899: ARRAY
60900: IN
60901: IFFALSE 60962
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
60903: LD_VAR 0 1
60907: PPUSH
60908: LD_EXP 99
60912: PUSH
60913: LD_VAR 0 6
60917: ARRAY
60918: PPUSH
60919: LD_INT 2
60921: PUSH
60922: LD_INT 30
60924: PUSH
60925: LD_INT 0
60927: PUSH
60928: EMPTY
60929: LIST
60930: LIST
60931: PUSH
60932: LD_INT 30
60934: PUSH
60935: LD_INT 1
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: LIST
60946: PPUSH
60947: CALL_OW 72
60951: PUSH
60952: LD_INT 1
60954: ARRAY
60955: PPUSH
60956: CALL_OW 112
// break ;
60960: GO 60964
// end ; end ;
60962: GO 60882
60964: POP
60965: POP
// end ; end_of_file
60966: LD_VAR 0 5
60970: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
60971: LD_INT 0
60973: PPUSH
60974: PPUSH
// if exist_mode then
60975: LD_VAR 0 2
60979: IFFALSE 61004
// unit := CreateCharacter ( prefix & ident ) else
60981: LD_ADDR_VAR 0 5
60985: PUSH
60986: LD_VAR 0 3
60990: PUSH
60991: LD_VAR 0 1
60995: STR
60996: PPUSH
60997: CALL_OW 34
61001: ST_TO_ADDR
61002: GO 61019
// unit := NewCharacter ( ident ) ;
61004: LD_ADDR_VAR 0 5
61008: PUSH
61009: LD_VAR 0 1
61013: PPUSH
61014: CALL_OW 25
61018: ST_TO_ADDR
// result := unit ;
61019: LD_ADDR_VAR 0 4
61023: PUSH
61024: LD_VAR 0 5
61028: ST_TO_ADDR
// end ;
61029: LD_VAR 0 4
61033: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
61034: LD_INT 0
61036: PPUSH
61037: PPUSH
// if not side or not nation then
61038: LD_VAR 0 1
61042: NOT
61043: PUSH
61044: LD_VAR 0 2
61048: NOT
61049: OR
61050: IFFALSE 61054
// exit ;
61052: GO 61690
// case nation of nation_american :
61054: LD_VAR 0 2
61058: PUSH
61059: LD_INT 1
61061: DOUBLE
61062: EQUAL
61063: IFTRUE 61067
61065: GO 61237
61067: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
61068: LD_ADDR_VAR 0 4
61072: PUSH
61073: LD_INT 35
61075: PUSH
61076: LD_INT 45
61078: PUSH
61079: LD_INT 46
61081: PUSH
61082: LD_INT 47
61084: PUSH
61085: LD_INT 1
61087: PUSH
61088: LD_INT 2
61090: PUSH
61091: LD_INT 6
61093: PUSH
61094: LD_INT 15
61096: PUSH
61097: LD_INT 16
61099: PUSH
61100: LD_INT 7
61102: PUSH
61103: LD_INT 12
61105: PUSH
61106: LD_INT 13
61108: PUSH
61109: LD_INT 10
61111: PUSH
61112: LD_INT 14
61114: PUSH
61115: LD_INT 20
61117: PUSH
61118: LD_INT 21
61120: PUSH
61121: LD_INT 22
61123: PUSH
61124: LD_INT 25
61126: PUSH
61127: LD_INT 32
61129: PUSH
61130: LD_INT 27
61132: PUSH
61133: LD_INT 36
61135: PUSH
61136: LD_INT 69
61138: PUSH
61139: LD_INT 39
61141: PUSH
61142: LD_INT 34
61144: PUSH
61145: LD_INT 40
61147: PUSH
61148: LD_INT 48
61150: PUSH
61151: LD_INT 49
61153: PUSH
61154: LD_INT 50
61156: PUSH
61157: LD_INT 51
61159: PUSH
61160: LD_INT 52
61162: PUSH
61163: LD_INT 53
61165: PUSH
61166: LD_INT 54
61168: PUSH
61169: LD_INT 55
61171: PUSH
61172: LD_INT 56
61174: PUSH
61175: LD_INT 57
61177: PUSH
61178: LD_INT 58
61180: PUSH
61181: LD_INT 59
61183: PUSH
61184: LD_INT 60
61186: PUSH
61187: LD_INT 61
61189: PUSH
61190: LD_INT 62
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: LIST
61197: LIST
61198: LIST
61199: LIST
61200: LIST
61201: LIST
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: LIST
61214: LIST
61215: LIST
61216: LIST
61217: LIST
61218: LIST
61219: LIST
61220: LIST
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: ST_TO_ADDR
61235: GO 61614
61237: LD_INT 2
61239: DOUBLE
61240: EQUAL
61241: IFTRUE 61245
61243: GO 61423
61245: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
61246: LD_ADDR_VAR 0 4
61250: PUSH
61251: LD_INT 35
61253: PUSH
61254: LD_INT 45
61256: PUSH
61257: LD_INT 46
61259: PUSH
61260: LD_INT 47
61262: PUSH
61263: LD_INT 70
61265: PUSH
61266: LD_INT 1
61268: PUSH
61269: LD_INT 11
61271: PUSH
61272: LD_INT 3
61274: PUSH
61275: LD_INT 4
61277: PUSH
61278: LD_INT 5
61280: PUSH
61281: LD_INT 6
61283: PUSH
61284: LD_INT 15
61286: PUSH
61287: LD_INT 18
61289: PUSH
61290: LD_INT 7
61292: PUSH
61293: LD_INT 17
61295: PUSH
61296: LD_INT 8
61298: PUSH
61299: LD_INT 20
61301: PUSH
61302: LD_INT 21
61304: PUSH
61305: LD_INT 22
61307: PUSH
61308: LD_INT 72
61310: PUSH
61311: LD_INT 26
61313: PUSH
61314: LD_INT 69
61316: PUSH
61317: LD_INT 39
61319: PUSH
61320: LD_INT 40
61322: PUSH
61323: LD_INT 41
61325: PUSH
61326: LD_INT 42
61328: PUSH
61329: LD_INT 43
61331: PUSH
61332: LD_INT 48
61334: PUSH
61335: LD_INT 49
61337: PUSH
61338: LD_INT 50
61340: PUSH
61341: LD_INT 51
61343: PUSH
61344: LD_INT 52
61346: PUSH
61347: LD_INT 53
61349: PUSH
61350: LD_INT 54
61352: PUSH
61353: LD_INT 55
61355: PUSH
61356: LD_INT 56
61358: PUSH
61359: LD_INT 60
61361: PUSH
61362: LD_INT 61
61364: PUSH
61365: LD_INT 62
61367: PUSH
61368: LD_INT 66
61370: PUSH
61371: LD_INT 67
61373: PUSH
61374: LD_INT 68
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: LIST
61381: LIST
61382: LIST
61383: LIST
61384: LIST
61385: LIST
61386: LIST
61387: LIST
61388: LIST
61389: LIST
61390: LIST
61391: LIST
61392: LIST
61393: LIST
61394: LIST
61395: LIST
61396: LIST
61397: LIST
61398: LIST
61399: LIST
61400: LIST
61401: LIST
61402: LIST
61403: LIST
61404: LIST
61405: LIST
61406: LIST
61407: LIST
61408: LIST
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: LIST
61414: LIST
61415: LIST
61416: LIST
61417: LIST
61418: LIST
61419: LIST
61420: ST_TO_ADDR
61421: GO 61614
61423: LD_INT 3
61425: DOUBLE
61426: EQUAL
61427: IFTRUE 61431
61429: GO 61613
61431: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
61432: LD_ADDR_VAR 0 4
61436: PUSH
61437: LD_INT 46
61439: PUSH
61440: LD_INT 47
61442: PUSH
61443: LD_INT 1
61445: PUSH
61446: LD_INT 2
61448: PUSH
61449: LD_INT 11
61451: PUSH
61452: LD_INT 9
61454: PUSH
61455: LD_INT 20
61457: PUSH
61458: LD_INT 19
61460: PUSH
61461: LD_INT 21
61463: PUSH
61464: LD_INT 24
61466: PUSH
61467: LD_INT 22
61469: PUSH
61470: LD_INT 25
61472: PUSH
61473: LD_INT 28
61475: PUSH
61476: LD_INT 29
61478: PUSH
61479: LD_INT 30
61481: PUSH
61482: LD_INT 31
61484: PUSH
61485: LD_INT 37
61487: PUSH
61488: LD_INT 38
61490: PUSH
61491: LD_INT 32
61493: PUSH
61494: LD_INT 27
61496: PUSH
61497: LD_INT 33
61499: PUSH
61500: LD_INT 69
61502: PUSH
61503: LD_INT 39
61505: PUSH
61506: LD_INT 34
61508: PUSH
61509: LD_INT 40
61511: PUSH
61512: LD_INT 71
61514: PUSH
61515: LD_INT 23
61517: PUSH
61518: LD_INT 44
61520: PUSH
61521: LD_INT 48
61523: PUSH
61524: LD_INT 49
61526: PUSH
61527: LD_INT 50
61529: PUSH
61530: LD_INT 51
61532: PUSH
61533: LD_INT 52
61535: PUSH
61536: LD_INT 53
61538: PUSH
61539: LD_INT 54
61541: PUSH
61542: LD_INT 55
61544: PUSH
61545: LD_INT 56
61547: PUSH
61548: LD_INT 57
61550: PUSH
61551: LD_INT 58
61553: PUSH
61554: LD_INT 59
61556: PUSH
61557: LD_INT 63
61559: PUSH
61560: LD_INT 64
61562: PUSH
61563: LD_INT 65
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: LIST
61570: LIST
61571: LIST
61572: LIST
61573: LIST
61574: LIST
61575: LIST
61576: LIST
61577: LIST
61578: LIST
61579: LIST
61580: LIST
61581: LIST
61582: LIST
61583: LIST
61584: LIST
61585: LIST
61586: LIST
61587: LIST
61588: LIST
61589: LIST
61590: LIST
61591: LIST
61592: LIST
61593: LIST
61594: LIST
61595: LIST
61596: LIST
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: LIST
61603: LIST
61604: LIST
61605: LIST
61606: LIST
61607: LIST
61608: LIST
61609: LIST
61610: ST_TO_ADDR
61611: GO 61614
61613: POP
// if state > - 1 and state < 3 then
61614: LD_VAR 0 3
61618: PUSH
61619: LD_INT 1
61621: NEG
61622: GREATER
61623: PUSH
61624: LD_VAR 0 3
61628: PUSH
61629: LD_INT 3
61631: LESS
61632: AND
61633: IFFALSE 61690
// for i in result do
61635: LD_ADDR_VAR 0 5
61639: PUSH
61640: LD_VAR 0 4
61644: PUSH
61645: FOR_IN
61646: IFFALSE 61688
// if GetTech ( i , side ) <> state then
61648: LD_VAR 0 5
61652: PPUSH
61653: LD_VAR 0 1
61657: PPUSH
61658: CALL_OW 321
61662: PUSH
61663: LD_VAR 0 3
61667: NONEQUAL
61668: IFFALSE 61686
// result := result diff i ;
61670: LD_ADDR_VAR 0 4
61674: PUSH
61675: LD_VAR 0 4
61679: PUSH
61680: LD_VAR 0 5
61684: DIFF
61685: ST_TO_ADDR
61686: GO 61645
61688: POP
61689: POP
// end ;
61690: LD_VAR 0 4
61694: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
61695: LD_INT 0
61697: PPUSH
61698: PPUSH
61699: PPUSH
// result := true ;
61700: LD_ADDR_VAR 0 3
61704: PUSH
61705: LD_INT 1
61707: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
61708: LD_ADDR_VAR 0 5
61712: PUSH
61713: LD_VAR 0 2
61717: PPUSH
61718: CALL_OW 480
61722: ST_TO_ADDR
// if not tmp then
61723: LD_VAR 0 5
61727: NOT
61728: IFFALSE 61732
// exit ;
61730: GO 61781
// for i in tmp do
61732: LD_ADDR_VAR 0 4
61736: PUSH
61737: LD_VAR 0 5
61741: PUSH
61742: FOR_IN
61743: IFFALSE 61779
// if GetTech ( i , side ) <> state_researched then
61745: LD_VAR 0 4
61749: PPUSH
61750: LD_VAR 0 1
61754: PPUSH
61755: CALL_OW 321
61759: PUSH
61760: LD_INT 2
61762: NONEQUAL
61763: IFFALSE 61777
// begin result := false ;
61765: LD_ADDR_VAR 0 3
61769: PUSH
61770: LD_INT 0
61772: ST_TO_ADDR
// exit ;
61773: POP
61774: POP
61775: GO 61781
// end ;
61777: GO 61742
61779: POP
61780: POP
// end ;
61781: LD_VAR 0 3
61785: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
61786: LD_INT 0
61788: PPUSH
61789: PPUSH
61790: PPUSH
61791: PPUSH
61792: PPUSH
61793: PPUSH
61794: PPUSH
61795: PPUSH
61796: PPUSH
61797: PPUSH
61798: PPUSH
61799: PPUSH
61800: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
61801: LD_VAR 0 1
61805: NOT
61806: PUSH
61807: LD_VAR 0 1
61811: PPUSH
61812: CALL_OW 257
61816: PUSH
61817: LD_INT 9
61819: NONEQUAL
61820: OR
61821: IFFALSE 61825
// exit ;
61823: GO 62398
// side := GetSide ( unit ) ;
61825: LD_ADDR_VAR 0 9
61829: PUSH
61830: LD_VAR 0 1
61834: PPUSH
61835: CALL_OW 255
61839: ST_TO_ADDR
// tech_space := tech_spacanom ;
61840: LD_ADDR_VAR 0 12
61844: PUSH
61845: LD_INT 29
61847: ST_TO_ADDR
// tech_time := tech_taurad ;
61848: LD_ADDR_VAR 0 13
61852: PUSH
61853: LD_INT 28
61855: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
61856: LD_ADDR_VAR 0 11
61860: PUSH
61861: LD_VAR 0 1
61865: PPUSH
61866: CALL_OW 310
61870: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
61871: LD_VAR 0 11
61875: PPUSH
61876: CALL_OW 247
61880: PUSH
61881: LD_INT 2
61883: EQUAL
61884: IFFALSE 61888
// exit ;
61886: GO 62398
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61888: LD_ADDR_VAR 0 8
61892: PUSH
61893: LD_INT 81
61895: PUSH
61896: LD_VAR 0 9
61900: PUSH
61901: EMPTY
61902: LIST
61903: LIST
61904: PUSH
61905: LD_INT 3
61907: PUSH
61908: LD_INT 21
61910: PUSH
61911: LD_INT 3
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: PPUSH
61926: CALL_OW 69
61930: ST_TO_ADDR
// if not tmp then
61931: LD_VAR 0 8
61935: NOT
61936: IFFALSE 61940
// exit ;
61938: GO 62398
// if in_unit then
61940: LD_VAR 0 11
61944: IFFALSE 61968
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
61946: LD_ADDR_VAR 0 10
61950: PUSH
61951: LD_VAR 0 8
61955: PPUSH
61956: LD_VAR 0 11
61960: PPUSH
61961: CALL_OW 74
61965: ST_TO_ADDR
61966: GO 61988
// enemy := NearestUnitToUnit ( tmp , unit ) ;
61968: LD_ADDR_VAR 0 10
61972: PUSH
61973: LD_VAR 0 8
61977: PPUSH
61978: LD_VAR 0 1
61982: PPUSH
61983: CALL_OW 74
61987: ST_TO_ADDR
// if not enemy then
61988: LD_VAR 0 10
61992: NOT
61993: IFFALSE 61997
// exit ;
61995: GO 62398
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
61997: LD_VAR 0 11
62001: PUSH
62002: LD_VAR 0 11
62006: PPUSH
62007: LD_VAR 0 10
62011: PPUSH
62012: CALL_OW 296
62016: PUSH
62017: LD_INT 13
62019: GREATER
62020: AND
62021: PUSH
62022: LD_VAR 0 1
62026: PPUSH
62027: LD_VAR 0 10
62031: PPUSH
62032: CALL_OW 296
62036: PUSH
62037: LD_INT 12
62039: GREATER
62040: OR
62041: IFFALSE 62045
// exit ;
62043: GO 62398
// missile := [ 1 ] ;
62045: LD_ADDR_VAR 0 14
62049: PUSH
62050: LD_INT 1
62052: PUSH
62053: EMPTY
62054: LIST
62055: ST_TO_ADDR
// if Researched ( side , tech_space ) then
62056: LD_VAR 0 9
62060: PPUSH
62061: LD_VAR 0 12
62065: PPUSH
62066: CALL_OW 325
62070: IFFALSE 62099
// missile := Insert ( missile , missile + 1 , 2 ) ;
62072: LD_ADDR_VAR 0 14
62076: PUSH
62077: LD_VAR 0 14
62081: PPUSH
62082: LD_VAR 0 14
62086: PUSH
62087: LD_INT 1
62089: PLUS
62090: PPUSH
62091: LD_INT 2
62093: PPUSH
62094: CALL_OW 2
62098: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
62099: LD_VAR 0 9
62103: PPUSH
62104: LD_VAR 0 13
62108: PPUSH
62109: CALL_OW 325
62113: PUSH
62114: LD_VAR 0 10
62118: PPUSH
62119: CALL_OW 255
62123: PPUSH
62124: LD_VAR 0 13
62128: PPUSH
62129: CALL_OW 325
62133: NOT
62134: AND
62135: IFFALSE 62164
// missile := Insert ( missile , missile + 1 , 3 ) ;
62137: LD_ADDR_VAR 0 14
62141: PUSH
62142: LD_VAR 0 14
62146: PPUSH
62147: LD_VAR 0 14
62151: PUSH
62152: LD_INT 1
62154: PLUS
62155: PPUSH
62156: LD_INT 3
62158: PPUSH
62159: CALL_OW 2
62163: ST_TO_ADDR
// if missile < 2 then
62164: LD_VAR 0 14
62168: PUSH
62169: LD_INT 2
62171: LESS
62172: IFFALSE 62176
// exit ;
62174: GO 62398
// x := GetX ( enemy ) ;
62176: LD_ADDR_VAR 0 4
62180: PUSH
62181: LD_VAR 0 10
62185: PPUSH
62186: CALL_OW 250
62190: ST_TO_ADDR
// y := GetY ( enemy ) ;
62191: LD_ADDR_VAR 0 5
62195: PUSH
62196: LD_VAR 0 10
62200: PPUSH
62201: CALL_OW 251
62205: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
62206: LD_ADDR_VAR 0 6
62210: PUSH
62211: LD_VAR 0 4
62215: PUSH
62216: LD_INT 1
62218: NEG
62219: PPUSH
62220: LD_INT 1
62222: PPUSH
62223: CALL_OW 12
62227: PLUS
62228: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
62229: LD_ADDR_VAR 0 7
62233: PUSH
62234: LD_VAR 0 5
62238: PUSH
62239: LD_INT 1
62241: NEG
62242: PPUSH
62243: LD_INT 1
62245: PPUSH
62246: CALL_OW 12
62250: PLUS
62251: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62252: LD_VAR 0 6
62256: PPUSH
62257: LD_VAR 0 7
62261: PPUSH
62262: CALL_OW 488
62266: NOT
62267: IFFALSE 62289
// begin _x := x ;
62269: LD_ADDR_VAR 0 6
62273: PUSH
62274: LD_VAR 0 4
62278: ST_TO_ADDR
// _y := y ;
62279: LD_ADDR_VAR 0 7
62283: PUSH
62284: LD_VAR 0 5
62288: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
62289: LD_ADDR_VAR 0 3
62293: PUSH
62294: LD_INT 1
62296: PPUSH
62297: LD_VAR 0 14
62301: PPUSH
62302: CALL_OW 12
62306: ST_TO_ADDR
// case i of 1 :
62307: LD_VAR 0 3
62311: PUSH
62312: LD_INT 1
62314: DOUBLE
62315: EQUAL
62316: IFTRUE 62320
62318: GO 62337
62320: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
62321: LD_VAR 0 1
62325: PPUSH
62326: LD_VAR 0 10
62330: PPUSH
62331: CALL_OW 115
62335: GO 62398
62337: LD_INT 2
62339: DOUBLE
62340: EQUAL
62341: IFTRUE 62345
62343: GO 62367
62345: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62346: LD_VAR 0 1
62350: PPUSH
62351: LD_VAR 0 6
62355: PPUSH
62356: LD_VAR 0 7
62360: PPUSH
62361: CALL_OW 153
62365: GO 62398
62367: LD_INT 3
62369: DOUBLE
62370: EQUAL
62371: IFTRUE 62375
62373: GO 62397
62375: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62376: LD_VAR 0 1
62380: PPUSH
62381: LD_VAR 0 6
62385: PPUSH
62386: LD_VAR 0 7
62390: PPUSH
62391: CALL_OW 154
62395: GO 62398
62397: POP
// end ;
62398: LD_VAR 0 2
62402: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62403: LD_INT 0
62405: PPUSH
62406: PPUSH
62407: PPUSH
62408: PPUSH
62409: PPUSH
62410: PPUSH
// if not unit or not building then
62411: LD_VAR 0 1
62415: NOT
62416: PUSH
62417: LD_VAR 0 2
62421: NOT
62422: OR
62423: IFFALSE 62427
// exit ;
62425: GO 62585
// x := GetX ( building ) ;
62427: LD_ADDR_VAR 0 5
62431: PUSH
62432: LD_VAR 0 2
62436: PPUSH
62437: CALL_OW 250
62441: ST_TO_ADDR
// y := GetY ( building ) ;
62442: LD_ADDR_VAR 0 6
62446: PUSH
62447: LD_VAR 0 2
62451: PPUSH
62452: CALL_OW 251
62456: ST_TO_ADDR
// for i = 0 to 5 do
62457: LD_ADDR_VAR 0 4
62461: PUSH
62462: DOUBLE
62463: LD_INT 0
62465: DEC
62466: ST_TO_ADDR
62467: LD_INT 5
62469: PUSH
62470: FOR_TO
62471: IFFALSE 62583
// begin _x := ShiftX ( x , i , 3 ) ;
62473: LD_ADDR_VAR 0 7
62477: PUSH
62478: LD_VAR 0 5
62482: PPUSH
62483: LD_VAR 0 4
62487: PPUSH
62488: LD_INT 3
62490: PPUSH
62491: CALL_OW 272
62495: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62496: LD_ADDR_VAR 0 8
62500: PUSH
62501: LD_VAR 0 6
62505: PPUSH
62506: LD_VAR 0 4
62510: PPUSH
62511: LD_INT 3
62513: PPUSH
62514: CALL_OW 273
62518: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62519: LD_VAR 0 7
62523: PPUSH
62524: LD_VAR 0 8
62528: PPUSH
62529: CALL_OW 488
62533: NOT
62534: IFFALSE 62538
// continue ;
62536: GO 62470
// if HexInfo ( _x , _y ) = 0 then
62538: LD_VAR 0 7
62542: PPUSH
62543: LD_VAR 0 8
62547: PPUSH
62548: CALL_OW 428
62552: PUSH
62553: LD_INT 0
62555: EQUAL
62556: IFFALSE 62581
// begin ComMoveXY ( unit , _x , _y ) ;
62558: LD_VAR 0 1
62562: PPUSH
62563: LD_VAR 0 7
62567: PPUSH
62568: LD_VAR 0 8
62572: PPUSH
62573: CALL_OW 111
// exit ;
62577: POP
62578: POP
62579: GO 62585
// end ; end ;
62581: GO 62470
62583: POP
62584: POP
// end ;
62585: LD_VAR 0 3
62589: RET
// export function ScanBase ( side , base_area ) ; begin
62590: LD_INT 0
62592: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62593: LD_ADDR_VAR 0 3
62597: PUSH
62598: LD_VAR 0 2
62602: PPUSH
62603: LD_INT 81
62605: PUSH
62606: LD_VAR 0 1
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PPUSH
62615: CALL_OW 70
62619: ST_TO_ADDR
// end ;
62620: LD_VAR 0 3
62624: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
62625: LD_INT 0
62627: PPUSH
62628: PPUSH
62629: PPUSH
62630: PPUSH
62631: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
62632: LD_VAR 0 1
62636: NOT
62637: PUSH
62638: LD_EXP 99
62642: PUSH
62643: LD_VAR 0 1
62647: ARRAY
62648: NOT
62649: OR
62650: PUSH
62651: LD_VAR 0 2
62655: NOT
62656: OR
62657: PUSH
62658: LD_VAR 0 3
62662: NOT
62663: OR
62664: IFFALSE 62668
// exit ;
62666: GO 63118
// side := mc_sides [ base ] ;
62668: LD_ADDR_VAR 0 6
62672: PUSH
62673: LD_EXP 125
62677: PUSH
62678: LD_VAR 0 1
62682: ARRAY
62683: ST_TO_ADDR
// if not side then
62684: LD_VAR 0 6
62688: NOT
62689: IFFALSE 62693
// exit ;
62691: GO 63118
// for i in solds do
62693: LD_ADDR_VAR 0 7
62697: PUSH
62698: LD_VAR 0 2
62702: PUSH
62703: FOR_IN
62704: IFFALSE 62765
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
62706: LD_VAR 0 7
62710: PPUSH
62711: CALL_OW 310
62715: PPUSH
62716: CALL_OW 266
62720: PUSH
62721: LD_INT 32
62723: PUSH
62724: LD_INT 31
62726: PUSH
62727: EMPTY
62728: LIST
62729: LIST
62730: IN
62731: IFFALSE 62751
// solds := solds diff i else
62733: LD_ADDR_VAR 0 2
62737: PUSH
62738: LD_VAR 0 2
62742: PUSH
62743: LD_VAR 0 7
62747: DIFF
62748: ST_TO_ADDR
62749: GO 62763
// SetTag ( i , 18 ) ;
62751: LD_VAR 0 7
62755: PPUSH
62756: LD_INT 18
62758: PPUSH
62759: CALL_OW 109
62763: GO 62703
62765: POP
62766: POP
// if not solds then
62767: LD_VAR 0 2
62771: NOT
62772: IFFALSE 62776
// exit ;
62774: GO 63118
// repeat wait ( 0 0$1 ) ;
62776: LD_INT 35
62778: PPUSH
62779: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
62783: LD_ADDR_VAR 0 5
62787: PUSH
62788: LD_VAR 0 6
62792: PPUSH
62793: LD_VAR 0 3
62797: PPUSH
62798: CALL 62590 0 2
62802: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
62803: LD_VAR 0 5
62807: NOT
62808: PUSH
62809: LD_VAR 0 5
62813: PUSH
62814: LD_INT 3
62816: GREATER
62817: OR
62818: PUSH
62819: LD_EXP 121
62823: PUSH
62824: LD_VAR 0 1
62828: ARRAY
62829: OR
62830: IFFALSE 62871
// begin for i in solds do
62832: LD_ADDR_VAR 0 7
62836: PUSH
62837: LD_VAR 0 2
62841: PUSH
62842: FOR_IN
62843: IFFALSE 62867
// if HasTask ( i ) then
62845: LD_VAR 0 7
62849: PPUSH
62850: CALL_OW 314
62854: IFFALSE 62865
// ComStop ( i ) ;
62856: LD_VAR 0 7
62860: PPUSH
62861: CALL_OW 141
62865: GO 62842
62867: POP
62868: POP
// break ;
62869: GO 63106
// end ; for i in solds do
62871: LD_ADDR_VAR 0 7
62875: PUSH
62876: LD_VAR 0 2
62880: PUSH
62881: FOR_IN
62882: IFFALSE 63098
// begin if IsInUnit ( i ) then
62884: LD_VAR 0 7
62888: PPUSH
62889: CALL_OW 310
62893: IFFALSE 62904
// ComExitBuilding ( i ) ;
62895: LD_VAR 0 7
62899: PPUSH
62900: CALL_OW 122
// if GetLives ( i ) > 333 then
62904: LD_VAR 0 7
62908: PPUSH
62909: CALL_OW 256
62913: PUSH
62914: LD_INT 333
62916: GREATER
62917: IFFALSE 62945
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
62919: LD_VAR 0 7
62923: PPUSH
62924: LD_VAR 0 5
62928: PPUSH
62929: LD_VAR 0 7
62933: PPUSH
62934: CALL_OW 74
62938: PPUSH
62939: CALL_OW 115
62943: GO 63096
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
62945: LD_ADDR_VAR 0 8
62949: PUSH
62950: LD_EXP 99
62954: PUSH
62955: LD_VAR 0 1
62959: ARRAY
62960: PPUSH
62961: LD_INT 2
62963: PUSH
62964: LD_INT 30
62966: PUSH
62967: LD_INT 0
62969: PUSH
62970: EMPTY
62971: LIST
62972: LIST
62973: PUSH
62974: LD_INT 30
62976: PUSH
62977: LD_INT 1
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PUSH
62984: LD_INT 30
62986: PUSH
62987: LD_INT 6
62989: PUSH
62990: EMPTY
62991: LIST
62992: LIST
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: LIST
62998: LIST
62999: PPUSH
63000: CALL_OW 72
63004: PPUSH
63005: LD_VAR 0 7
63009: PPUSH
63010: CALL_OW 74
63014: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
63015: LD_VAR 0 7
63019: PPUSH
63020: LD_VAR 0 8
63024: PPUSH
63025: CALL_OW 250
63029: PPUSH
63030: LD_INT 3
63032: PPUSH
63033: LD_INT 5
63035: PPUSH
63036: CALL_OW 272
63040: PPUSH
63041: LD_VAR 0 8
63045: PPUSH
63046: CALL_OW 251
63050: PPUSH
63051: LD_INT 3
63053: PPUSH
63054: LD_INT 5
63056: PPUSH
63057: CALL_OW 273
63061: PPUSH
63062: CALL_OW 111
// SetTag ( i , 0 ) ;
63066: LD_VAR 0 7
63070: PPUSH
63071: LD_INT 0
63073: PPUSH
63074: CALL_OW 109
// solds := solds diff i ;
63078: LD_ADDR_VAR 0 2
63082: PUSH
63083: LD_VAR 0 2
63087: PUSH
63088: LD_VAR 0 7
63092: DIFF
63093: ST_TO_ADDR
// continue ;
63094: GO 62881
// end ; end ;
63096: GO 62881
63098: POP
63099: POP
// until solds ;
63100: LD_VAR 0 2
63104: IFFALSE 62776
// MC_Reset ( base , 18 ) ;
63106: LD_VAR 0 1
63110: PPUSH
63111: LD_INT 18
63113: PPUSH
63114: CALL 35875 0 2
// end ;
63118: LD_VAR 0 4
63122: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
63123: LD_INT 0
63125: PPUSH
63126: PPUSH
63127: PPUSH
63128: PPUSH
63129: PPUSH
63130: PPUSH
63131: PPUSH
63132: PPUSH
63133: PPUSH
63134: PPUSH
63135: PPUSH
63136: PPUSH
63137: PPUSH
63138: PPUSH
63139: PPUSH
63140: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
63141: LD_ADDR_VAR 0 12
63145: PUSH
63146: LD_EXP 99
63150: PUSH
63151: LD_VAR 0 1
63155: ARRAY
63156: PPUSH
63157: LD_INT 25
63159: PUSH
63160: LD_INT 3
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PPUSH
63167: CALL_OW 72
63171: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63172: LD_ADDR_VAR 0 8
63176: PUSH
63177: LD_EXP 99
63181: PUSH
63182: LD_VAR 0 1
63186: ARRAY
63187: PPUSH
63188: LD_INT 2
63190: PUSH
63191: LD_INT 25
63193: PUSH
63194: LD_INT 1
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: PUSH
63201: LD_INT 25
63203: PUSH
63204: LD_INT 5
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 25
63213: PUSH
63214: LD_INT 8
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 25
63223: PUSH
63224: LD_INT 9
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: EMPTY
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: PPUSH
63238: CALL_OW 72
63242: ST_TO_ADDR
// if not defenders and not solds then
63243: LD_VAR 0 2
63247: NOT
63248: PUSH
63249: LD_VAR 0 8
63253: NOT
63254: AND
63255: IFFALSE 63259
// exit ;
63257: GO 64625
// depot_under_attack := false ;
63259: LD_ADDR_VAR 0 16
63263: PUSH
63264: LD_INT 0
63266: ST_TO_ADDR
// sold_defenders := [ ] ;
63267: LD_ADDR_VAR 0 17
63271: PUSH
63272: EMPTY
63273: ST_TO_ADDR
// if mechs then
63274: LD_VAR 0 12
63278: IFFALSE 63407
// for i in defenders do
63280: LD_ADDR_VAR 0 5
63284: PUSH
63285: LD_VAR 0 2
63289: PUSH
63290: FOR_IN
63291: IFFALSE 63405
// begin SetTag ( i , 20 ) ;
63293: LD_VAR 0 5
63297: PPUSH
63298: LD_INT 20
63300: PPUSH
63301: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
63305: LD_VAR 0 5
63309: PPUSH
63310: CALL_OW 263
63314: PUSH
63315: LD_INT 1
63317: EQUAL
63318: PUSH
63319: LD_VAR 0 5
63323: PPUSH
63324: CALL_OW 311
63328: NOT
63329: AND
63330: PUSH
63331: LD_VAR 0 12
63335: AND
63336: IFFALSE 63403
// begin un := mechs [ 1 ] ;
63338: LD_ADDR_VAR 0 10
63342: PUSH
63343: LD_VAR 0 12
63347: PUSH
63348: LD_INT 1
63350: ARRAY
63351: ST_TO_ADDR
// ComExitBuilding ( un ) ;
63352: LD_VAR 0 10
63356: PPUSH
63357: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
63361: LD_VAR 0 10
63365: PPUSH
63366: LD_VAR 0 5
63370: PPUSH
63371: CALL_OW 180
// SetTag ( un , 19 ) ;
63375: LD_VAR 0 10
63379: PPUSH
63380: LD_INT 19
63382: PPUSH
63383: CALL_OW 109
// mechs := mechs diff un ;
63387: LD_ADDR_VAR 0 12
63391: PUSH
63392: LD_VAR 0 12
63396: PUSH
63397: LD_VAR 0 10
63401: DIFF
63402: ST_TO_ADDR
// end ; end ;
63403: GO 63290
63405: POP
63406: POP
// if solds then
63407: LD_VAR 0 8
63411: IFFALSE 63470
// for i in solds do
63413: LD_ADDR_VAR 0 5
63417: PUSH
63418: LD_VAR 0 8
63422: PUSH
63423: FOR_IN
63424: IFFALSE 63468
// if not GetTag ( i ) then
63426: LD_VAR 0 5
63430: PPUSH
63431: CALL_OW 110
63435: NOT
63436: IFFALSE 63466
// begin defenders := defenders union i ;
63438: LD_ADDR_VAR 0 2
63442: PUSH
63443: LD_VAR 0 2
63447: PUSH
63448: LD_VAR 0 5
63452: UNION
63453: ST_TO_ADDR
// SetTag ( i , 18 ) ;
63454: LD_VAR 0 5
63458: PPUSH
63459: LD_INT 18
63461: PPUSH
63462: CALL_OW 109
// end ;
63466: GO 63423
63468: POP
63469: POP
// repeat wait ( 0 0$1 ) ;
63470: LD_INT 35
63472: PPUSH
63473: CALL_OW 67
// enemy := mc_scan [ base ] ;
63477: LD_ADDR_VAR 0 3
63481: PUSH
63482: LD_EXP 122
63486: PUSH
63487: LD_VAR 0 1
63491: ARRAY
63492: ST_TO_ADDR
// for i in defenders do
63493: LD_ADDR_VAR 0 5
63497: PUSH
63498: LD_VAR 0 2
63502: PUSH
63503: FOR_IN
63504: IFFALSE 64189
// begin e := NearestUnitToUnit ( enemy , i ) ;
63506: LD_ADDR_VAR 0 13
63510: PUSH
63511: LD_VAR 0 3
63515: PPUSH
63516: LD_VAR 0 5
63520: PPUSH
63521: CALL_OW 74
63525: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
63526: LD_ADDR_VAR 0 16
63530: PUSH
63531: LD_EXP 99
63535: PUSH
63536: LD_VAR 0 1
63540: ARRAY
63541: PPUSH
63542: LD_INT 2
63544: PUSH
63545: LD_INT 30
63547: PUSH
63548: LD_INT 0
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 30
63557: PUSH
63558: LD_INT 1
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: LIST
63569: PPUSH
63570: CALL_OW 72
63574: NOT
63575: PUSH
63576: LD_EXP 99
63580: PUSH
63581: LD_VAR 0 1
63585: ARRAY
63586: PPUSH
63587: LD_INT 2
63589: PUSH
63590: LD_INT 30
63592: PUSH
63593: LD_INT 0
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: PUSH
63600: LD_INT 30
63602: PUSH
63603: LD_INT 1
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: LIST
63614: PPUSH
63615: CALL_OW 72
63619: PPUSH
63620: CALL_OW 256
63624: PUSH
63625: LD_INT 600
63627: LESS
63628: OR
63629: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
63630: LD_VAR 0 5
63634: PPUSH
63635: CALL_OW 247
63639: PUSH
63640: LD_INT 2
63642: DOUBLE
63643: EQUAL
63644: IFTRUE 63648
63646: GO 63895
63648: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
63649: LD_VAR 0 5
63653: PPUSH
63654: CALL_OW 256
63658: PUSH
63659: LD_INT 650
63661: GREATER
63662: PUSH
63663: LD_VAR 0 5
63667: PPUSH
63668: LD_VAR 0 13
63672: PPUSH
63673: CALL_OW 296
63677: PUSH
63678: LD_INT 40
63680: LESS
63681: AND
63682: IFFALSE 63700
// ComAttackUnit ( i , e ) else
63684: LD_VAR 0 5
63688: PPUSH
63689: LD_VAR 0 13
63693: PPUSH
63694: CALL_OW 115
63698: GO 63778
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
63700: LD_VAR 0 5
63704: PPUSH
63705: LD_VAR 0 13
63709: PPUSH
63710: CALL_OW 296
63714: PUSH
63715: LD_INT 30
63717: GREATEREQUAL
63718: PUSH
63719: LD_VAR 0 5
63723: PPUSH
63724: CALL_OW 256
63728: PUSH
63729: LD_INT 650
63731: LESSEQUAL
63732: OR
63733: PUSH
63734: LD_VAR 0 5
63738: PPUSH
63739: LD_EXP 123
63743: PUSH
63744: LD_VAR 0 1
63748: ARRAY
63749: PPUSH
63750: CALL_OW 308
63754: NOT
63755: AND
63756: IFFALSE 63778
// ComMoveToArea ( i , mc_parking [ base ] ) ;
63758: LD_VAR 0 5
63762: PPUSH
63763: LD_EXP 123
63767: PUSH
63768: LD_VAR 0 1
63772: ARRAY
63773: PPUSH
63774: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
63778: LD_VAR 0 5
63782: PPUSH
63783: CALL_OW 256
63787: PUSH
63788: LD_INT 998
63790: LESS
63791: PUSH
63792: LD_VAR 0 5
63796: PPUSH
63797: CALL_OW 263
63801: PUSH
63802: LD_INT 1
63804: EQUAL
63805: AND
63806: PUSH
63807: LD_VAR 0 5
63811: PPUSH
63812: CALL_OW 311
63816: AND
63817: PUSH
63818: LD_VAR 0 5
63822: PPUSH
63823: LD_EXP 123
63827: PUSH
63828: LD_VAR 0 1
63832: ARRAY
63833: PPUSH
63834: CALL_OW 308
63838: AND
63839: IFFALSE 63893
// begin mech := IsDrivenBy ( i ) ;
63841: LD_ADDR_VAR 0 9
63845: PUSH
63846: LD_VAR 0 5
63850: PPUSH
63851: CALL_OW 311
63855: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
63856: LD_VAR 0 9
63860: PPUSH
63861: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
63865: LD_VAR 0 9
63869: PPUSH
63870: LD_VAR 0 5
63874: PPUSH
63875: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
63879: LD_VAR 0 9
63883: PPUSH
63884: LD_VAR 0 5
63888: PPUSH
63889: CALL_OW 180
// end ; end ; unit_human :
63893: GO 64160
63895: LD_INT 1
63897: DOUBLE
63898: EQUAL
63899: IFTRUE 63903
63901: GO 64159
63903: POP
// begin b := IsInUnit ( i ) ;
63904: LD_ADDR_VAR 0 18
63908: PUSH
63909: LD_VAR 0 5
63913: PPUSH
63914: CALL_OW 310
63918: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
63919: LD_ADDR_VAR 0 19
63923: PUSH
63924: LD_VAR 0 18
63928: NOT
63929: PUSH
63930: LD_VAR 0 18
63934: PPUSH
63935: CALL_OW 266
63939: PUSH
63940: LD_INT 32
63942: PUSH
63943: LD_INT 31
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: IN
63950: OR
63951: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
63952: LD_VAR 0 16
63956: PUSH
63957: LD_VAR 0 2
63961: PPUSH
63962: LD_INT 21
63964: PUSH
63965: LD_INT 2
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: PPUSH
63972: CALL_OW 72
63976: PUSH
63977: LD_INT 1
63979: LESSEQUAL
63980: OR
63981: PUSH
63982: LD_VAR 0 19
63986: AND
63987: PUSH
63988: LD_VAR 0 5
63992: PUSH
63993: LD_VAR 0 17
63997: IN
63998: NOT
63999: AND
64000: IFFALSE 64093
// begin if b then
64002: LD_VAR 0 18
64006: IFFALSE 64055
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
64008: LD_VAR 0 18
64012: PPUSH
64013: LD_VAR 0 3
64017: PPUSH
64018: LD_VAR 0 18
64022: PPUSH
64023: CALL_OW 74
64027: PPUSH
64028: CALL_OW 296
64032: PUSH
64033: LD_INT 10
64035: LESS
64036: PUSH
64037: LD_VAR 0 18
64041: PPUSH
64042: CALL_OW 461
64046: PUSH
64047: LD_INT 7
64049: NONEQUAL
64050: AND
64051: IFFALSE 64055
// continue ;
64053: GO 63503
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
64055: LD_ADDR_VAR 0 17
64059: PUSH
64060: LD_VAR 0 17
64064: PPUSH
64065: LD_VAR 0 17
64069: PUSH
64070: LD_INT 1
64072: PLUS
64073: PPUSH
64074: LD_VAR 0 5
64078: PPUSH
64079: CALL_OW 1
64083: ST_TO_ADDR
// ComExitBuilding ( i ) ;
64084: LD_VAR 0 5
64088: PPUSH
64089: CALL_OW 122
// end ; if sold_defenders then
64093: LD_VAR 0 17
64097: IFFALSE 64157
// if i in sold_defenders then
64099: LD_VAR 0 5
64103: PUSH
64104: LD_VAR 0 17
64108: IN
64109: IFFALSE 64157
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
64111: LD_VAR 0 5
64115: PPUSH
64116: CALL_OW 314
64120: NOT
64121: PUSH
64122: LD_VAR 0 5
64126: PPUSH
64127: LD_VAR 0 13
64131: PPUSH
64132: CALL_OW 296
64136: PUSH
64137: LD_INT 30
64139: LESS
64140: AND
64141: IFFALSE 64157
// ComAttackUnit ( i , e ) ;
64143: LD_VAR 0 5
64147: PPUSH
64148: LD_VAR 0 13
64152: PPUSH
64153: CALL_OW 115
// end ; end ; end ;
64157: GO 64160
64159: POP
// if IsDead ( i ) then
64160: LD_VAR 0 5
64164: PPUSH
64165: CALL_OW 301
64169: IFFALSE 64187
// defenders := defenders diff i ;
64171: LD_ADDR_VAR 0 2
64175: PUSH
64176: LD_VAR 0 2
64180: PUSH
64181: LD_VAR 0 5
64185: DIFF
64186: ST_TO_ADDR
// end ;
64187: GO 63503
64189: POP
64190: POP
// until not enemy or not defenders ;
64191: LD_VAR 0 3
64195: NOT
64196: PUSH
64197: LD_VAR 0 2
64201: NOT
64202: OR
64203: IFFALSE 63470
// MC_Reset ( base , 18 ) ;
64205: LD_VAR 0 1
64209: PPUSH
64210: LD_INT 18
64212: PPUSH
64213: CALL 35875 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64217: LD_ADDR_VAR 0 2
64221: PUSH
64222: LD_VAR 0 2
64226: PUSH
64227: LD_VAR 0 2
64231: PPUSH
64232: LD_INT 2
64234: PUSH
64235: LD_INT 25
64237: PUSH
64238: LD_INT 1
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 25
64247: PUSH
64248: LD_INT 5
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 25
64257: PUSH
64258: LD_INT 8
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: PUSH
64265: LD_INT 25
64267: PUSH
64268: LD_INT 9
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: EMPTY
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: PPUSH
64282: CALL_OW 72
64286: DIFF
64287: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
64288: LD_VAR 0 3
64292: NOT
64293: PUSH
64294: LD_VAR 0 2
64298: PPUSH
64299: LD_INT 21
64301: PUSH
64302: LD_INT 2
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PPUSH
64309: CALL_OW 72
64313: AND
64314: IFFALSE 64576
// begin tmp := FilterByTag ( defenders , 19 ) ;
64316: LD_ADDR_VAR 0 11
64320: PUSH
64321: LD_VAR 0 2
64325: PPUSH
64326: LD_INT 19
64328: PPUSH
64329: CALL 100923 0 2
64333: ST_TO_ADDR
// if tmp then
64334: LD_VAR 0 11
64338: IFFALSE 64408
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
64340: LD_ADDR_VAR 0 11
64344: PUSH
64345: LD_VAR 0 11
64349: PPUSH
64350: LD_INT 25
64352: PUSH
64353: LD_INT 3
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PPUSH
64360: CALL_OW 72
64364: ST_TO_ADDR
// if tmp then
64365: LD_VAR 0 11
64369: IFFALSE 64408
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
64371: LD_ADDR_EXP 111
64375: PUSH
64376: LD_EXP 111
64380: PPUSH
64381: LD_VAR 0 1
64385: PPUSH
64386: LD_EXP 111
64390: PUSH
64391: LD_VAR 0 1
64395: ARRAY
64396: PUSH
64397: LD_VAR 0 11
64401: UNION
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
64408: LD_VAR 0 1
64412: PPUSH
64413: LD_INT 19
64415: PPUSH
64416: CALL 35875 0 2
// repeat wait ( 0 0$1 ) ;
64420: LD_INT 35
64422: PPUSH
64423: CALL_OW 67
// for i in defenders do
64427: LD_ADDR_VAR 0 5
64431: PUSH
64432: LD_VAR 0 2
64436: PUSH
64437: FOR_IN
64438: IFFALSE 64527
// begin if not IsInArea ( i , mc_parking [ base ] ) then
64440: LD_VAR 0 5
64444: PPUSH
64445: LD_EXP 123
64449: PUSH
64450: LD_VAR 0 1
64454: ARRAY
64455: PPUSH
64456: CALL_OW 308
64460: NOT
64461: IFFALSE 64485
// ComMoveToArea ( i , mc_parking [ base ] ) else
64463: LD_VAR 0 5
64467: PPUSH
64468: LD_EXP 123
64472: PUSH
64473: LD_VAR 0 1
64477: ARRAY
64478: PPUSH
64479: CALL_OW 113
64483: GO 64525
// if GetControl ( i ) = control_manual then
64485: LD_VAR 0 5
64489: PPUSH
64490: CALL_OW 263
64494: PUSH
64495: LD_INT 1
64497: EQUAL
64498: IFFALSE 64525
// if IsDrivenBy ( i ) then
64500: LD_VAR 0 5
64504: PPUSH
64505: CALL_OW 311
64509: IFFALSE 64525
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
64511: LD_VAR 0 5
64515: PPUSH
64516: CALL_OW 311
64520: PPUSH
64521: CALL_OW 121
// end ;
64525: GO 64437
64527: POP
64528: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
64529: LD_VAR 0 2
64533: PPUSH
64534: LD_INT 95
64536: PUSH
64537: LD_EXP 123
64541: PUSH
64542: LD_VAR 0 1
64546: ARRAY
64547: PUSH
64548: EMPTY
64549: LIST
64550: LIST
64551: PPUSH
64552: CALL_OW 72
64556: PUSH
64557: LD_VAR 0 2
64561: EQUAL
64562: PUSH
64563: LD_EXP 122
64567: PUSH
64568: LD_VAR 0 1
64572: ARRAY
64573: OR
64574: IFFALSE 64420
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
64576: LD_ADDR_EXP 121
64580: PUSH
64581: LD_EXP 121
64585: PPUSH
64586: LD_VAR 0 1
64590: PPUSH
64591: LD_EXP 121
64595: PUSH
64596: LD_VAR 0 1
64600: ARRAY
64601: PUSH
64602: LD_VAR 0 2
64606: UNION
64607: PPUSH
64608: CALL_OW 1
64612: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
64613: LD_VAR 0 1
64617: PPUSH
64618: LD_INT 20
64620: PPUSH
64621: CALL 35875 0 2
// end ;
64625: LD_VAR 0 4
64629: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
64630: LD_INT 0
64632: PPUSH
64633: PPUSH
64634: PPUSH
64635: PPUSH
// result := false ;
64636: LD_ADDR_VAR 0 2
64640: PUSH
64641: LD_INT 0
64643: ST_TO_ADDR
// side := GetSide ( unit ) ;
64644: LD_ADDR_VAR 0 3
64648: PUSH
64649: LD_VAR 0 1
64653: PPUSH
64654: CALL_OW 255
64658: ST_TO_ADDR
// nat := GetNation ( unit ) ;
64659: LD_ADDR_VAR 0 4
64663: PUSH
64664: LD_VAR 0 1
64668: PPUSH
64669: CALL_OW 248
64673: ST_TO_ADDR
// case nat of 1 :
64674: LD_VAR 0 4
64678: PUSH
64679: LD_INT 1
64681: DOUBLE
64682: EQUAL
64683: IFTRUE 64687
64685: GO 64698
64687: POP
// tech := tech_lassight ; 2 :
64688: LD_ADDR_VAR 0 5
64692: PUSH
64693: LD_INT 12
64695: ST_TO_ADDR
64696: GO 64737
64698: LD_INT 2
64700: DOUBLE
64701: EQUAL
64702: IFTRUE 64706
64704: GO 64717
64706: POP
// tech := tech_mortar ; 3 :
64707: LD_ADDR_VAR 0 5
64711: PUSH
64712: LD_INT 41
64714: ST_TO_ADDR
64715: GO 64737
64717: LD_INT 3
64719: DOUBLE
64720: EQUAL
64721: IFTRUE 64725
64723: GO 64736
64725: POP
// tech := tech_bazooka ; end ;
64726: LD_ADDR_VAR 0 5
64730: PUSH
64731: LD_INT 44
64733: ST_TO_ADDR
64734: GO 64737
64736: POP
// if Researched ( side , tech ) then
64737: LD_VAR 0 3
64741: PPUSH
64742: LD_VAR 0 5
64746: PPUSH
64747: CALL_OW 325
64751: IFFALSE 64778
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
64753: LD_ADDR_VAR 0 2
64757: PUSH
64758: LD_INT 5
64760: PUSH
64761: LD_INT 8
64763: PUSH
64764: LD_INT 9
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: LIST
64771: PUSH
64772: LD_VAR 0 4
64776: ARRAY
64777: ST_TO_ADDR
// end ;
64778: LD_VAR 0 2
64782: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
64783: LD_INT 0
64785: PPUSH
64786: PPUSH
64787: PPUSH
// if not mines then
64788: LD_VAR 0 2
64792: NOT
64793: IFFALSE 64797
// exit ;
64795: GO 64941
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64797: LD_ADDR_VAR 0 5
64801: PUSH
64802: LD_INT 81
64804: PUSH
64805: LD_VAR 0 1
64809: PUSH
64810: EMPTY
64811: LIST
64812: LIST
64813: PUSH
64814: LD_INT 3
64816: PUSH
64817: LD_INT 21
64819: PUSH
64820: LD_INT 3
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PPUSH
64835: CALL_OW 69
64839: ST_TO_ADDR
// for i in mines do
64840: LD_ADDR_VAR 0 4
64844: PUSH
64845: LD_VAR 0 2
64849: PUSH
64850: FOR_IN
64851: IFFALSE 64939
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
64853: LD_VAR 0 4
64857: PUSH
64858: LD_INT 1
64860: ARRAY
64861: PPUSH
64862: LD_VAR 0 4
64866: PUSH
64867: LD_INT 2
64869: ARRAY
64870: PPUSH
64871: CALL_OW 458
64875: NOT
64876: IFFALSE 64880
// continue ;
64878: GO 64850
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
64880: LD_VAR 0 4
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: PPUSH
64889: LD_VAR 0 4
64893: PUSH
64894: LD_INT 2
64896: ARRAY
64897: PPUSH
64898: CALL_OW 428
64902: PUSH
64903: LD_VAR 0 5
64907: IN
64908: IFFALSE 64937
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
64910: LD_VAR 0 4
64914: PUSH
64915: LD_INT 1
64917: ARRAY
64918: PPUSH
64919: LD_VAR 0 4
64923: PUSH
64924: LD_INT 2
64926: ARRAY
64927: PPUSH
64928: LD_VAR 0 1
64932: PPUSH
64933: CALL_OW 456
// end ;
64937: GO 64850
64939: POP
64940: POP
// end ;
64941: LD_VAR 0 3
64945: RET
// export function Count ( array ) ; var i ; begin
64946: LD_INT 0
64948: PPUSH
64949: PPUSH
// result := 0 ;
64950: LD_ADDR_VAR 0 2
64954: PUSH
64955: LD_INT 0
64957: ST_TO_ADDR
// for i in array do
64958: LD_ADDR_VAR 0 3
64962: PUSH
64963: LD_VAR 0 1
64967: PUSH
64968: FOR_IN
64969: IFFALSE 64993
// if i then
64971: LD_VAR 0 3
64975: IFFALSE 64991
// result := result + 1 ;
64977: LD_ADDR_VAR 0 2
64981: PUSH
64982: LD_VAR 0 2
64986: PUSH
64987: LD_INT 1
64989: PLUS
64990: ST_TO_ADDR
64991: GO 64968
64993: POP
64994: POP
// end ;
64995: LD_VAR 0 2
64999: RET
// export function IsEmpty ( building ) ; begin
65000: LD_INT 0
65002: PPUSH
// if not building then
65003: LD_VAR 0 1
65007: NOT
65008: IFFALSE 65012
// exit ;
65010: GO 65055
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65012: LD_ADDR_VAR 0 2
65016: PUSH
65017: LD_VAR 0 1
65021: PUSH
65022: LD_INT 22
65024: PUSH
65025: LD_VAR 0 1
65029: PPUSH
65030: CALL_OW 255
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 58
65041: PUSH
65042: EMPTY
65043: LIST
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PPUSH
65049: CALL_OW 69
65053: IN
65054: ST_TO_ADDR
// end ;
65055: LD_VAR 0 2
65059: RET
// export function IsNotFull ( building ) ; begin
65060: LD_INT 0
65062: PPUSH
// if not building then
65063: LD_VAR 0 1
65067: NOT
65068: IFFALSE 65072
// exit ;
65070: GO 65091
// result := UnitsInside ( building ) < 6 ;
65072: LD_ADDR_VAR 0 2
65076: PUSH
65077: LD_VAR 0 1
65081: PPUSH
65082: CALL_OW 313
65086: PUSH
65087: LD_INT 6
65089: LESS
65090: ST_TO_ADDR
// end ;
65091: LD_VAR 0 2
65095: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65096: LD_INT 0
65098: PPUSH
65099: PPUSH
65100: PPUSH
65101: PPUSH
// tmp := [ ] ;
65102: LD_ADDR_VAR 0 3
65106: PUSH
65107: EMPTY
65108: ST_TO_ADDR
// list := [ ] ;
65109: LD_ADDR_VAR 0 5
65113: PUSH
65114: EMPTY
65115: ST_TO_ADDR
// for i = 16 to 25 do
65116: LD_ADDR_VAR 0 4
65120: PUSH
65121: DOUBLE
65122: LD_INT 16
65124: DEC
65125: ST_TO_ADDR
65126: LD_INT 25
65128: PUSH
65129: FOR_TO
65130: IFFALSE 65203
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65132: LD_ADDR_VAR 0 3
65136: PUSH
65137: LD_VAR 0 3
65141: PUSH
65142: LD_INT 22
65144: PUSH
65145: LD_VAR 0 1
65149: PPUSH
65150: CALL_OW 255
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 91
65161: PUSH
65162: LD_VAR 0 1
65166: PUSH
65167: LD_INT 6
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 30
65177: PUSH
65178: LD_VAR 0 4
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: LIST
65191: PUSH
65192: EMPTY
65193: LIST
65194: PPUSH
65195: CALL_OW 69
65199: ADD
65200: ST_TO_ADDR
65201: GO 65129
65203: POP
65204: POP
// for i = 1 to tmp do
65205: LD_ADDR_VAR 0 4
65209: PUSH
65210: DOUBLE
65211: LD_INT 1
65213: DEC
65214: ST_TO_ADDR
65215: LD_VAR 0 3
65219: PUSH
65220: FOR_TO
65221: IFFALSE 65309
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65223: LD_ADDR_VAR 0 5
65227: PUSH
65228: LD_VAR 0 5
65232: PUSH
65233: LD_VAR 0 3
65237: PUSH
65238: LD_VAR 0 4
65242: ARRAY
65243: PPUSH
65244: CALL_OW 266
65248: PUSH
65249: LD_VAR 0 3
65253: PUSH
65254: LD_VAR 0 4
65258: ARRAY
65259: PPUSH
65260: CALL_OW 250
65264: PUSH
65265: LD_VAR 0 3
65269: PUSH
65270: LD_VAR 0 4
65274: ARRAY
65275: PPUSH
65276: CALL_OW 251
65280: PUSH
65281: LD_VAR 0 3
65285: PUSH
65286: LD_VAR 0 4
65290: ARRAY
65291: PPUSH
65292: CALL_OW 254
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: PUSH
65303: EMPTY
65304: LIST
65305: ADD
65306: ST_TO_ADDR
65307: GO 65220
65309: POP
65310: POP
// result := list ;
65311: LD_ADDR_VAR 0 2
65315: PUSH
65316: LD_VAR 0 5
65320: ST_TO_ADDR
// end ;
65321: LD_VAR 0 2
65325: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65326: LD_INT 0
65328: PPUSH
65329: PPUSH
65330: PPUSH
65331: PPUSH
65332: PPUSH
65333: PPUSH
65334: PPUSH
// if not factory then
65335: LD_VAR 0 1
65339: NOT
65340: IFFALSE 65344
// exit ;
65342: GO 65869
// if control = control_apeman then
65344: LD_VAR 0 4
65348: PUSH
65349: LD_INT 5
65351: EQUAL
65352: IFFALSE 65461
// begin tmp := UnitsInside ( factory ) ;
65354: LD_ADDR_VAR 0 8
65358: PUSH
65359: LD_VAR 0 1
65363: PPUSH
65364: CALL_OW 313
65368: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
65369: LD_VAR 0 8
65373: PPUSH
65374: LD_INT 25
65376: PUSH
65377: LD_INT 12
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PPUSH
65384: CALL_OW 72
65388: NOT
65389: IFFALSE 65399
// control := control_manual ;
65391: LD_ADDR_VAR 0 4
65395: PUSH
65396: LD_INT 1
65398: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
65399: LD_ADDR_VAR 0 8
65403: PUSH
65404: LD_VAR 0 1
65408: PPUSH
65409: CALL 65096 0 1
65413: ST_TO_ADDR
// if tmp then
65414: LD_VAR 0 8
65418: IFFALSE 65461
// begin for i in tmp do
65420: LD_ADDR_VAR 0 7
65424: PUSH
65425: LD_VAR 0 8
65429: PUSH
65430: FOR_IN
65431: IFFALSE 65459
// if i [ 1 ] = b_ext_radar then
65433: LD_VAR 0 7
65437: PUSH
65438: LD_INT 1
65440: ARRAY
65441: PUSH
65442: LD_INT 20
65444: EQUAL
65445: IFFALSE 65457
// begin control := control_remote ;
65447: LD_ADDR_VAR 0 4
65451: PUSH
65452: LD_INT 2
65454: ST_TO_ADDR
// break ;
65455: GO 65459
// end ;
65457: GO 65430
65459: POP
65460: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65461: LD_VAR 0 1
65465: PPUSH
65466: LD_VAR 0 2
65470: PPUSH
65471: LD_VAR 0 3
65475: PPUSH
65476: LD_VAR 0 4
65480: PPUSH
65481: LD_VAR 0 5
65485: PPUSH
65486: CALL_OW 448
65490: IFFALSE 65525
// begin result := [ chassis , engine , control , weapon ] ;
65492: LD_ADDR_VAR 0 6
65496: PUSH
65497: LD_VAR 0 2
65501: PUSH
65502: LD_VAR 0 3
65506: PUSH
65507: LD_VAR 0 4
65511: PUSH
65512: LD_VAR 0 5
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: ST_TO_ADDR
// exit ;
65523: GO 65869
// end ; _chassis := AvailableChassisList ( factory ) ;
65525: LD_ADDR_VAR 0 9
65529: PUSH
65530: LD_VAR 0 1
65534: PPUSH
65535: CALL_OW 475
65539: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
65540: LD_ADDR_VAR 0 11
65544: PUSH
65545: LD_VAR 0 1
65549: PPUSH
65550: CALL_OW 476
65554: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
65555: LD_ADDR_VAR 0 12
65559: PUSH
65560: LD_VAR 0 1
65564: PPUSH
65565: CALL_OW 477
65569: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
65570: LD_ADDR_VAR 0 10
65574: PUSH
65575: LD_VAR 0 1
65579: PPUSH
65580: CALL_OW 478
65584: ST_TO_ADDR
// if not chassis in _chassis then
65585: LD_VAR 0 2
65589: PUSH
65590: LD_VAR 0 9
65594: IN
65595: NOT
65596: IFFALSE 65622
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
65598: LD_ADDR_VAR 0 2
65602: PUSH
65603: LD_VAR 0 9
65607: PUSH
65608: LD_INT 1
65610: PPUSH
65611: LD_VAR 0 9
65615: PPUSH
65616: CALL_OW 12
65620: ARRAY
65621: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
65622: LD_VAR 0 2
65626: PPUSH
65627: LD_VAR 0 3
65631: PPUSH
65632: CALL 65874 0 2
65636: NOT
65637: IFFALSE 65696
// repeat engine := _engine [ 1 ] ;
65639: LD_ADDR_VAR 0 3
65643: PUSH
65644: LD_VAR 0 11
65648: PUSH
65649: LD_INT 1
65651: ARRAY
65652: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
65653: LD_ADDR_VAR 0 11
65657: PUSH
65658: LD_VAR 0 11
65662: PPUSH
65663: LD_INT 1
65665: PPUSH
65666: CALL_OW 3
65670: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
65671: LD_VAR 0 2
65675: PPUSH
65676: LD_VAR 0 3
65680: PPUSH
65681: CALL 65874 0 2
65685: PUSH
65686: LD_VAR 0 11
65690: PUSH
65691: EMPTY
65692: EQUAL
65693: OR
65694: IFFALSE 65639
// if not control in _control then
65696: LD_VAR 0 4
65700: PUSH
65701: LD_VAR 0 12
65705: IN
65706: NOT
65707: IFFALSE 65733
// control := _control [ rand ( 1 , _control ) ] ;
65709: LD_ADDR_VAR 0 4
65713: PUSH
65714: LD_VAR 0 12
65718: PUSH
65719: LD_INT 1
65721: PPUSH
65722: LD_VAR 0 12
65726: PPUSH
65727: CALL_OW 12
65731: ARRAY
65732: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
65733: LD_VAR 0 2
65737: PPUSH
65738: LD_VAR 0 5
65742: PPUSH
65743: CALL 66094 0 2
65747: NOT
65748: IFFALSE 65807
// repeat weapon := _weapon [ 1 ] ;
65750: LD_ADDR_VAR 0 5
65754: PUSH
65755: LD_VAR 0 10
65759: PUSH
65760: LD_INT 1
65762: ARRAY
65763: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
65764: LD_ADDR_VAR 0 10
65768: PUSH
65769: LD_VAR 0 10
65773: PPUSH
65774: LD_INT 1
65776: PPUSH
65777: CALL_OW 3
65781: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
65782: LD_VAR 0 2
65786: PPUSH
65787: LD_VAR 0 5
65791: PPUSH
65792: CALL 66094 0 2
65796: PUSH
65797: LD_VAR 0 10
65801: PUSH
65802: EMPTY
65803: EQUAL
65804: OR
65805: IFFALSE 65750
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65807: LD_VAR 0 1
65811: PPUSH
65812: LD_VAR 0 2
65816: PPUSH
65817: LD_VAR 0 3
65821: PPUSH
65822: LD_VAR 0 4
65826: PPUSH
65827: LD_VAR 0 5
65831: PPUSH
65832: CALL_OW 448
65836: IFFALSE 65869
// result := [ chassis , engine , control , weapon ] ;
65838: LD_ADDR_VAR 0 6
65842: PUSH
65843: LD_VAR 0 2
65847: PUSH
65848: LD_VAR 0 3
65852: PUSH
65853: LD_VAR 0 4
65857: PUSH
65858: LD_VAR 0 5
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: ST_TO_ADDR
// end ;
65869: LD_VAR 0 6
65873: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
65874: LD_INT 0
65876: PPUSH
// if not chassis or not engine then
65877: LD_VAR 0 1
65881: NOT
65882: PUSH
65883: LD_VAR 0 2
65887: NOT
65888: OR
65889: IFFALSE 65893
// exit ;
65891: GO 66089
// case engine of engine_solar :
65893: LD_VAR 0 2
65897: PUSH
65898: LD_INT 2
65900: DOUBLE
65901: EQUAL
65902: IFTRUE 65906
65904: GO 65944
65906: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
65907: LD_ADDR_VAR 0 3
65911: PUSH
65912: LD_INT 11
65914: PUSH
65915: LD_INT 12
65917: PUSH
65918: LD_INT 13
65920: PUSH
65921: LD_INT 14
65923: PUSH
65924: LD_INT 1
65926: PUSH
65927: LD_INT 2
65929: PUSH
65930: LD_INT 3
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: ST_TO_ADDR
65942: GO 66073
65944: LD_INT 1
65946: DOUBLE
65947: EQUAL
65948: IFTRUE 65952
65950: GO 66014
65952: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
65953: LD_ADDR_VAR 0 3
65957: PUSH
65958: LD_INT 11
65960: PUSH
65961: LD_INT 12
65963: PUSH
65964: LD_INT 13
65966: PUSH
65967: LD_INT 14
65969: PUSH
65970: LD_INT 1
65972: PUSH
65973: LD_INT 2
65975: PUSH
65976: LD_INT 3
65978: PUSH
65979: LD_INT 4
65981: PUSH
65982: LD_INT 5
65984: PUSH
65985: LD_INT 21
65987: PUSH
65988: LD_INT 23
65990: PUSH
65991: LD_INT 22
65993: PUSH
65994: LD_INT 24
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: ST_TO_ADDR
66012: GO 66073
66014: LD_INT 3
66016: DOUBLE
66017: EQUAL
66018: IFTRUE 66022
66020: GO 66072
66022: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66023: LD_ADDR_VAR 0 3
66027: PUSH
66028: LD_INT 13
66030: PUSH
66031: LD_INT 14
66033: PUSH
66034: LD_INT 2
66036: PUSH
66037: LD_INT 3
66039: PUSH
66040: LD_INT 4
66042: PUSH
66043: LD_INT 5
66045: PUSH
66046: LD_INT 21
66048: PUSH
66049: LD_INT 22
66051: PUSH
66052: LD_INT 23
66054: PUSH
66055: LD_INT 24
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: ST_TO_ADDR
66070: GO 66073
66072: POP
// result := ( chassis in result ) ;
66073: LD_ADDR_VAR 0 3
66077: PUSH
66078: LD_VAR 0 1
66082: PUSH
66083: LD_VAR 0 3
66087: IN
66088: ST_TO_ADDR
// end ;
66089: LD_VAR 0 3
66093: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66094: LD_INT 0
66096: PPUSH
// if not chassis or not weapon then
66097: LD_VAR 0 1
66101: NOT
66102: PUSH
66103: LD_VAR 0 2
66107: NOT
66108: OR
66109: IFFALSE 66113
// exit ;
66111: GO 67139
// case weapon of us_machine_gun :
66113: LD_VAR 0 2
66117: PUSH
66118: LD_INT 2
66120: DOUBLE
66121: EQUAL
66122: IFTRUE 66126
66124: GO 66156
66126: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66127: LD_ADDR_VAR 0 3
66131: PUSH
66132: LD_INT 1
66134: PUSH
66135: LD_INT 2
66137: PUSH
66138: LD_INT 3
66140: PUSH
66141: LD_INT 4
66143: PUSH
66144: LD_INT 5
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: ST_TO_ADDR
66154: GO 67123
66156: LD_INT 3
66158: DOUBLE
66159: EQUAL
66160: IFTRUE 66164
66162: GO 66194
66164: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66165: LD_ADDR_VAR 0 3
66169: PUSH
66170: LD_INT 1
66172: PUSH
66173: LD_INT 2
66175: PUSH
66176: LD_INT 3
66178: PUSH
66179: LD_INT 4
66181: PUSH
66182: LD_INT 5
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: ST_TO_ADDR
66192: GO 67123
66194: LD_INT 11
66196: DOUBLE
66197: EQUAL
66198: IFTRUE 66202
66200: GO 66232
66202: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66203: LD_ADDR_VAR 0 3
66207: PUSH
66208: LD_INT 1
66210: PUSH
66211: LD_INT 2
66213: PUSH
66214: LD_INT 3
66216: PUSH
66217: LD_INT 4
66219: PUSH
66220: LD_INT 5
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: ST_TO_ADDR
66230: GO 67123
66232: LD_INT 4
66234: DOUBLE
66235: EQUAL
66236: IFTRUE 66240
66238: GO 66266
66240: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66241: LD_ADDR_VAR 0 3
66245: PUSH
66246: LD_INT 2
66248: PUSH
66249: LD_INT 3
66251: PUSH
66252: LD_INT 4
66254: PUSH
66255: LD_INT 5
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: ST_TO_ADDR
66264: GO 67123
66266: LD_INT 5
66268: DOUBLE
66269: EQUAL
66270: IFTRUE 66274
66272: GO 66300
66274: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66275: LD_ADDR_VAR 0 3
66279: PUSH
66280: LD_INT 2
66282: PUSH
66283: LD_INT 3
66285: PUSH
66286: LD_INT 4
66288: PUSH
66289: LD_INT 5
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: ST_TO_ADDR
66298: GO 67123
66300: LD_INT 9
66302: DOUBLE
66303: EQUAL
66304: IFTRUE 66308
66306: GO 66334
66308: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
66309: LD_ADDR_VAR 0 3
66313: PUSH
66314: LD_INT 2
66316: PUSH
66317: LD_INT 3
66319: PUSH
66320: LD_INT 4
66322: PUSH
66323: LD_INT 5
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: LIST
66330: LIST
66331: ST_TO_ADDR
66332: GO 67123
66334: LD_INT 7
66336: DOUBLE
66337: EQUAL
66338: IFTRUE 66342
66340: GO 66368
66342: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
66343: LD_ADDR_VAR 0 3
66347: PUSH
66348: LD_INT 2
66350: PUSH
66351: LD_INT 3
66353: PUSH
66354: LD_INT 4
66356: PUSH
66357: LD_INT 5
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: ST_TO_ADDR
66366: GO 67123
66368: LD_INT 12
66370: DOUBLE
66371: EQUAL
66372: IFTRUE 66376
66374: GO 66402
66376: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66377: LD_ADDR_VAR 0 3
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 3
66387: PUSH
66388: LD_INT 4
66390: PUSH
66391: LD_INT 5
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: ST_TO_ADDR
66400: GO 67123
66402: LD_INT 13
66404: DOUBLE
66405: EQUAL
66406: IFTRUE 66410
66408: GO 66436
66410: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
66411: LD_ADDR_VAR 0 3
66415: PUSH
66416: LD_INT 2
66418: PUSH
66419: LD_INT 3
66421: PUSH
66422: LD_INT 4
66424: PUSH
66425: LD_INT 5
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: ST_TO_ADDR
66434: GO 67123
66436: LD_INT 14
66438: DOUBLE
66439: EQUAL
66440: IFTRUE 66444
66442: GO 66462
66444: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
66445: LD_ADDR_VAR 0 3
66449: PUSH
66450: LD_INT 4
66452: PUSH
66453: LD_INT 5
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: ST_TO_ADDR
66460: GO 67123
66462: LD_INT 6
66464: DOUBLE
66465: EQUAL
66466: IFTRUE 66470
66468: GO 66488
66470: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
66471: LD_ADDR_VAR 0 3
66475: PUSH
66476: LD_INT 4
66478: PUSH
66479: LD_INT 5
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: ST_TO_ADDR
66486: GO 67123
66488: LD_INT 10
66490: DOUBLE
66491: EQUAL
66492: IFTRUE 66496
66494: GO 66514
66496: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
66497: LD_ADDR_VAR 0 3
66501: PUSH
66502: LD_INT 4
66504: PUSH
66505: LD_INT 5
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: ST_TO_ADDR
66512: GO 67123
66514: LD_INT 22
66516: DOUBLE
66517: EQUAL
66518: IFTRUE 66522
66520: GO 66548
66522: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
66523: LD_ADDR_VAR 0 3
66527: PUSH
66528: LD_INT 11
66530: PUSH
66531: LD_INT 12
66533: PUSH
66534: LD_INT 13
66536: PUSH
66537: LD_INT 14
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: ST_TO_ADDR
66546: GO 67123
66548: LD_INT 23
66550: DOUBLE
66551: EQUAL
66552: IFTRUE 66556
66554: GO 66582
66556: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
66557: LD_ADDR_VAR 0 3
66561: PUSH
66562: LD_INT 11
66564: PUSH
66565: LD_INT 12
66567: PUSH
66568: LD_INT 13
66570: PUSH
66571: LD_INT 14
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: ST_TO_ADDR
66580: GO 67123
66582: LD_INT 24
66584: DOUBLE
66585: EQUAL
66586: IFTRUE 66590
66588: GO 66616
66590: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
66591: LD_ADDR_VAR 0 3
66595: PUSH
66596: LD_INT 11
66598: PUSH
66599: LD_INT 12
66601: PUSH
66602: LD_INT 13
66604: PUSH
66605: LD_INT 14
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: ST_TO_ADDR
66614: GO 67123
66616: LD_INT 30
66618: DOUBLE
66619: EQUAL
66620: IFTRUE 66624
66622: GO 66650
66624: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
66625: LD_ADDR_VAR 0 3
66629: PUSH
66630: LD_INT 11
66632: PUSH
66633: LD_INT 12
66635: PUSH
66636: LD_INT 13
66638: PUSH
66639: LD_INT 14
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: ST_TO_ADDR
66648: GO 67123
66650: LD_INT 25
66652: DOUBLE
66653: EQUAL
66654: IFTRUE 66658
66656: GO 66676
66658: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
66659: LD_ADDR_VAR 0 3
66663: PUSH
66664: LD_INT 13
66666: PUSH
66667: LD_INT 14
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: ST_TO_ADDR
66674: GO 67123
66676: LD_INT 27
66678: DOUBLE
66679: EQUAL
66680: IFTRUE 66684
66682: GO 66702
66684: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
66685: LD_ADDR_VAR 0 3
66689: PUSH
66690: LD_INT 13
66692: PUSH
66693: LD_INT 14
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: ST_TO_ADDR
66700: GO 67123
66702: LD_INT 28
66704: DOUBLE
66705: EQUAL
66706: IFTRUE 66710
66708: GO 66728
66710: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
66711: LD_ADDR_VAR 0 3
66715: PUSH
66716: LD_INT 13
66718: PUSH
66719: LD_INT 14
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: ST_TO_ADDR
66726: GO 67123
66728: LD_INT 29
66730: DOUBLE
66731: EQUAL
66732: IFTRUE 66736
66734: GO 66754
66736: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
66737: LD_ADDR_VAR 0 3
66741: PUSH
66742: LD_INT 13
66744: PUSH
66745: LD_INT 14
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: ST_TO_ADDR
66752: GO 67123
66754: LD_INT 31
66756: DOUBLE
66757: EQUAL
66758: IFTRUE 66762
66760: GO 66780
66762: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
66763: LD_ADDR_VAR 0 3
66767: PUSH
66768: LD_INT 13
66770: PUSH
66771: LD_INT 14
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: ST_TO_ADDR
66778: GO 67123
66780: LD_INT 26
66782: DOUBLE
66783: EQUAL
66784: IFTRUE 66788
66786: GO 66806
66788: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
66789: LD_ADDR_VAR 0 3
66793: PUSH
66794: LD_INT 13
66796: PUSH
66797: LD_INT 14
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: ST_TO_ADDR
66804: GO 67123
66806: LD_INT 42
66808: DOUBLE
66809: EQUAL
66810: IFTRUE 66814
66812: GO 66840
66814: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
66815: LD_ADDR_VAR 0 3
66819: PUSH
66820: LD_INT 21
66822: PUSH
66823: LD_INT 22
66825: PUSH
66826: LD_INT 23
66828: PUSH
66829: LD_INT 24
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: ST_TO_ADDR
66838: GO 67123
66840: LD_INT 43
66842: DOUBLE
66843: EQUAL
66844: IFTRUE 66848
66846: GO 66874
66848: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
66849: LD_ADDR_VAR 0 3
66853: PUSH
66854: LD_INT 21
66856: PUSH
66857: LD_INT 22
66859: PUSH
66860: LD_INT 23
66862: PUSH
66863: LD_INT 24
66865: PUSH
66866: EMPTY
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: ST_TO_ADDR
66872: GO 67123
66874: LD_INT 44
66876: DOUBLE
66877: EQUAL
66878: IFTRUE 66882
66880: GO 66908
66882: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
66883: LD_ADDR_VAR 0 3
66887: PUSH
66888: LD_INT 21
66890: PUSH
66891: LD_INT 22
66893: PUSH
66894: LD_INT 23
66896: PUSH
66897: LD_INT 24
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: ST_TO_ADDR
66906: GO 67123
66908: LD_INT 45
66910: DOUBLE
66911: EQUAL
66912: IFTRUE 66916
66914: GO 66942
66916: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
66917: LD_ADDR_VAR 0 3
66921: PUSH
66922: LD_INT 21
66924: PUSH
66925: LD_INT 22
66927: PUSH
66928: LD_INT 23
66930: PUSH
66931: LD_INT 24
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: ST_TO_ADDR
66940: GO 67123
66942: LD_INT 49
66944: DOUBLE
66945: EQUAL
66946: IFTRUE 66950
66948: GO 66976
66950: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
66951: LD_ADDR_VAR 0 3
66955: PUSH
66956: LD_INT 21
66958: PUSH
66959: LD_INT 22
66961: PUSH
66962: LD_INT 23
66964: PUSH
66965: LD_INT 24
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: ST_TO_ADDR
66974: GO 67123
66976: LD_INT 51
66978: DOUBLE
66979: EQUAL
66980: IFTRUE 66984
66982: GO 67010
66984: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
66985: LD_ADDR_VAR 0 3
66989: PUSH
66990: LD_INT 21
66992: PUSH
66993: LD_INT 22
66995: PUSH
66996: LD_INT 23
66998: PUSH
66999: LD_INT 24
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: ST_TO_ADDR
67008: GO 67123
67010: LD_INT 52
67012: DOUBLE
67013: EQUAL
67014: IFTRUE 67018
67016: GO 67044
67018: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67019: LD_ADDR_VAR 0 3
67023: PUSH
67024: LD_INT 21
67026: PUSH
67027: LD_INT 22
67029: PUSH
67030: LD_INT 23
67032: PUSH
67033: LD_INT 24
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: ST_TO_ADDR
67042: GO 67123
67044: LD_INT 53
67046: DOUBLE
67047: EQUAL
67048: IFTRUE 67052
67050: GO 67070
67052: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67053: LD_ADDR_VAR 0 3
67057: PUSH
67058: LD_INT 23
67060: PUSH
67061: LD_INT 24
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: ST_TO_ADDR
67068: GO 67123
67070: LD_INT 46
67072: DOUBLE
67073: EQUAL
67074: IFTRUE 67078
67076: GO 67096
67078: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67079: LD_ADDR_VAR 0 3
67083: PUSH
67084: LD_INT 23
67086: PUSH
67087: LD_INT 24
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: ST_TO_ADDR
67094: GO 67123
67096: LD_INT 47
67098: DOUBLE
67099: EQUAL
67100: IFTRUE 67104
67102: GO 67122
67104: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67105: LD_ADDR_VAR 0 3
67109: PUSH
67110: LD_INT 23
67112: PUSH
67113: LD_INT 24
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: ST_TO_ADDR
67120: GO 67123
67122: POP
// result := ( chassis in result ) ;
67123: LD_ADDR_VAR 0 3
67127: PUSH
67128: LD_VAR 0 1
67132: PUSH
67133: LD_VAR 0 3
67137: IN
67138: ST_TO_ADDR
// end ;
67139: LD_VAR 0 3
67143: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67144: LD_INT 0
67146: PPUSH
67147: PPUSH
67148: PPUSH
67149: PPUSH
67150: PPUSH
67151: PPUSH
67152: PPUSH
// result := array ;
67153: LD_ADDR_VAR 0 5
67157: PUSH
67158: LD_VAR 0 1
67162: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67163: LD_VAR 0 1
67167: NOT
67168: PUSH
67169: LD_VAR 0 2
67173: NOT
67174: OR
67175: PUSH
67176: LD_VAR 0 3
67180: NOT
67181: OR
67182: PUSH
67183: LD_VAR 0 2
67187: PUSH
67188: LD_VAR 0 1
67192: GREATER
67193: OR
67194: PUSH
67195: LD_VAR 0 3
67199: PUSH
67200: LD_VAR 0 1
67204: GREATER
67205: OR
67206: IFFALSE 67210
// exit ;
67208: GO 67506
// if direction then
67210: LD_VAR 0 4
67214: IFFALSE 67278
// begin d := 1 ;
67216: LD_ADDR_VAR 0 9
67220: PUSH
67221: LD_INT 1
67223: ST_TO_ADDR
// if i_from > i_to then
67224: LD_VAR 0 2
67228: PUSH
67229: LD_VAR 0 3
67233: GREATER
67234: IFFALSE 67260
// length := ( array - i_from ) + i_to else
67236: LD_ADDR_VAR 0 11
67240: PUSH
67241: LD_VAR 0 1
67245: PUSH
67246: LD_VAR 0 2
67250: MINUS
67251: PUSH
67252: LD_VAR 0 3
67256: PLUS
67257: ST_TO_ADDR
67258: GO 67276
// length := i_to - i_from ;
67260: LD_ADDR_VAR 0 11
67264: PUSH
67265: LD_VAR 0 3
67269: PUSH
67270: LD_VAR 0 2
67274: MINUS
67275: ST_TO_ADDR
// end else
67276: GO 67339
// begin d := - 1 ;
67278: LD_ADDR_VAR 0 9
67282: PUSH
67283: LD_INT 1
67285: NEG
67286: ST_TO_ADDR
// if i_from > i_to then
67287: LD_VAR 0 2
67291: PUSH
67292: LD_VAR 0 3
67296: GREATER
67297: IFFALSE 67317
// length := i_from - i_to else
67299: LD_ADDR_VAR 0 11
67303: PUSH
67304: LD_VAR 0 2
67308: PUSH
67309: LD_VAR 0 3
67313: MINUS
67314: ST_TO_ADDR
67315: GO 67339
// length := ( array - i_to ) + i_from ;
67317: LD_ADDR_VAR 0 11
67321: PUSH
67322: LD_VAR 0 1
67326: PUSH
67327: LD_VAR 0 3
67331: MINUS
67332: PUSH
67333: LD_VAR 0 2
67337: PLUS
67338: ST_TO_ADDR
// end ; if not length then
67339: LD_VAR 0 11
67343: NOT
67344: IFFALSE 67348
// exit ;
67346: GO 67506
// tmp := array ;
67348: LD_ADDR_VAR 0 10
67352: PUSH
67353: LD_VAR 0 1
67357: ST_TO_ADDR
// for i = 1 to length do
67358: LD_ADDR_VAR 0 6
67362: PUSH
67363: DOUBLE
67364: LD_INT 1
67366: DEC
67367: ST_TO_ADDR
67368: LD_VAR 0 11
67372: PUSH
67373: FOR_TO
67374: IFFALSE 67494
// begin for j = 1 to array do
67376: LD_ADDR_VAR 0 7
67380: PUSH
67381: DOUBLE
67382: LD_INT 1
67384: DEC
67385: ST_TO_ADDR
67386: LD_VAR 0 1
67390: PUSH
67391: FOR_TO
67392: IFFALSE 67480
// begin k := j + d ;
67394: LD_ADDR_VAR 0 8
67398: PUSH
67399: LD_VAR 0 7
67403: PUSH
67404: LD_VAR 0 9
67408: PLUS
67409: ST_TO_ADDR
// if k > array then
67410: LD_VAR 0 8
67414: PUSH
67415: LD_VAR 0 1
67419: GREATER
67420: IFFALSE 67430
// k := 1 ;
67422: LD_ADDR_VAR 0 8
67426: PUSH
67427: LD_INT 1
67429: ST_TO_ADDR
// if not k then
67430: LD_VAR 0 8
67434: NOT
67435: IFFALSE 67447
// k := array ;
67437: LD_ADDR_VAR 0 8
67441: PUSH
67442: LD_VAR 0 1
67446: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
67447: LD_ADDR_VAR 0 10
67451: PUSH
67452: LD_VAR 0 10
67456: PPUSH
67457: LD_VAR 0 8
67461: PPUSH
67462: LD_VAR 0 1
67466: PUSH
67467: LD_VAR 0 7
67471: ARRAY
67472: PPUSH
67473: CALL_OW 1
67477: ST_TO_ADDR
// end ;
67478: GO 67391
67480: POP
67481: POP
// array := tmp ;
67482: LD_ADDR_VAR 0 1
67486: PUSH
67487: LD_VAR 0 10
67491: ST_TO_ADDR
// end ;
67492: GO 67373
67494: POP
67495: POP
// result := array ;
67496: LD_ADDR_VAR 0 5
67500: PUSH
67501: LD_VAR 0 1
67505: ST_TO_ADDR
// end ;
67506: LD_VAR 0 5
67510: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
67511: LD_INT 0
67513: PPUSH
67514: PPUSH
// result := 0 ;
67515: LD_ADDR_VAR 0 3
67519: PUSH
67520: LD_INT 0
67522: ST_TO_ADDR
// if not array or not value in array then
67523: LD_VAR 0 1
67527: NOT
67528: PUSH
67529: LD_VAR 0 2
67533: PUSH
67534: LD_VAR 0 1
67538: IN
67539: NOT
67540: OR
67541: IFFALSE 67545
// exit ;
67543: GO 67599
// for i = 1 to array do
67545: LD_ADDR_VAR 0 4
67549: PUSH
67550: DOUBLE
67551: LD_INT 1
67553: DEC
67554: ST_TO_ADDR
67555: LD_VAR 0 1
67559: PUSH
67560: FOR_TO
67561: IFFALSE 67597
// if value = array [ i ] then
67563: LD_VAR 0 2
67567: PUSH
67568: LD_VAR 0 1
67572: PUSH
67573: LD_VAR 0 4
67577: ARRAY
67578: EQUAL
67579: IFFALSE 67595
// begin result := i ;
67581: LD_ADDR_VAR 0 3
67585: PUSH
67586: LD_VAR 0 4
67590: ST_TO_ADDR
// exit ;
67591: POP
67592: POP
67593: GO 67599
// end ;
67595: GO 67560
67597: POP
67598: POP
// end ;
67599: LD_VAR 0 3
67603: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
67604: LD_INT 0
67606: PPUSH
// vc_chassis := chassis ;
67607: LD_ADDR_OWVAR 37
67611: PUSH
67612: LD_VAR 0 1
67616: ST_TO_ADDR
// vc_engine := engine ;
67617: LD_ADDR_OWVAR 39
67621: PUSH
67622: LD_VAR 0 2
67626: ST_TO_ADDR
// vc_control := control ;
67627: LD_ADDR_OWVAR 38
67631: PUSH
67632: LD_VAR 0 3
67636: ST_TO_ADDR
// vc_weapon := weapon ;
67637: LD_ADDR_OWVAR 40
67641: PUSH
67642: LD_VAR 0 4
67646: ST_TO_ADDR
// vc_fuel_battery := fuel ;
67647: LD_ADDR_OWVAR 41
67651: PUSH
67652: LD_VAR 0 5
67656: ST_TO_ADDR
// end ;
67657: LD_VAR 0 6
67661: RET
// export function WantPlant ( unit ) ; var task ; begin
67662: LD_INT 0
67664: PPUSH
67665: PPUSH
// result := false ;
67666: LD_ADDR_VAR 0 2
67670: PUSH
67671: LD_INT 0
67673: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
67674: LD_ADDR_VAR 0 3
67678: PUSH
67679: LD_VAR 0 1
67683: PPUSH
67684: CALL_OW 437
67688: ST_TO_ADDR
// if task then
67689: LD_VAR 0 3
67693: IFFALSE 67721
// if task [ 1 ] [ 1 ] = p then
67695: LD_VAR 0 3
67699: PUSH
67700: LD_INT 1
67702: ARRAY
67703: PUSH
67704: LD_INT 1
67706: ARRAY
67707: PUSH
67708: LD_STRING p
67710: EQUAL
67711: IFFALSE 67721
// result := true ;
67713: LD_ADDR_VAR 0 2
67717: PUSH
67718: LD_INT 1
67720: ST_TO_ADDR
// end ;
67721: LD_VAR 0 2
67725: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
67726: LD_INT 0
67728: PPUSH
67729: PPUSH
67730: PPUSH
67731: PPUSH
// if pos < 1 then
67732: LD_VAR 0 2
67736: PUSH
67737: LD_INT 1
67739: LESS
67740: IFFALSE 67744
// exit ;
67742: GO 68047
// if pos = 1 then
67744: LD_VAR 0 2
67748: PUSH
67749: LD_INT 1
67751: EQUAL
67752: IFFALSE 67785
// result := Replace ( arr , pos [ 1 ] , value ) else
67754: LD_ADDR_VAR 0 4
67758: PUSH
67759: LD_VAR 0 1
67763: PPUSH
67764: LD_VAR 0 2
67768: PUSH
67769: LD_INT 1
67771: ARRAY
67772: PPUSH
67773: LD_VAR 0 3
67777: PPUSH
67778: CALL_OW 1
67782: ST_TO_ADDR
67783: GO 68047
// begin tmp := arr ;
67785: LD_ADDR_VAR 0 6
67789: PUSH
67790: LD_VAR 0 1
67794: ST_TO_ADDR
// s_arr := [ tmp ] ;
67795: LD_ADDR_VAR 0 7
67799: PUSH
67800: LD_VAR 0 6
67804: PUSH
67805: EMPTY
67806: LIST
67807: ST_TO_ADDR
// for i = 1 to pos - 1 do
67808: LD_ADDR_VAR 0 5
67812: PUSH
67813: DOUBLE
67814: LD_INT 1
67816: DEC
67817: ST_TO_ADDR
67818: LD_VAR 0 2
67822: PUSH
67823: LD_INT 1
67825: MINUS
67826: PUSH
67827: FOR_TO
67828: IFFALSE 67873
// begin tmp := tmp [ pos [ i ] ] ;
67830: LD_ADDR_VAR 0 6
67834: PUSH
67835: LD_VAR 0 6
67839: PUSH
67840: LD_VAR 0 2
67844: PUSH
67845: LD_VAR 0 5
67849: ARRAY
67850: ARRAY
67851: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
67852: LD_ADDR_VAR 0 7
67856: PUSH
67857: LD_VAR 0 7
67861: PUSH
67862: LD_VAR 0 6
67866: PUSH
67867: EMPTY
67868: LIST
67869: ADD
67870: ST_TO_ADDR
// end ;
67871: GO 67827
67873: POP
67874: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
67875: LD_ADDR_VAR 0 6
67879: PUSH
67880: LD_VAR 0 6
67884: PPUSH
67885: LD_VAR 0 2
67889: PUSH
67890: LD_VAR 0 2
67894: ARRAY
67895: PPUSH
67896: LD_VAR 0 3
67900: PPUSH
67901: CALL_OW 1
67905: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
67906: LD_ADDR_VAR 0 7
67910: PUSH
67911: LD_VAR 0 7
67915: PPUSH
67916: LD_VAR 0 7
67920: PPUSH
67921: LD_VAR 0 6
67925: PPUSH
67926: CALL_OW 1
67930: ST_TO_ADDR
// for i = s_arr downto 2 do
67931: LD_ADDR_VAR 0 5
67935: PUSH
67936: DOUBLE
67937: LD_VAR 0 7
67941: INC
67942: ST_TO_ADDR
67943: LD_INT 2
67945: PUSH
67946: FOR_DOWNTO
67947: IFFALSE 68031
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
67949: LD_ADDR_VAR 0 6
67953: PUSH
67954: LD_VAR 0 7
67958: PUSH
67959: LD_VAR 0 5
67963: PUSH
67964: LD_INT 1
67966: MINUS
67967: ARRAY
67968: PPUSH
67969: LD_VAR 0 2
67973: PUSH
67974: LD_VAR 0 5
67978: PUSH
67979: LD_INT 1
67981: MINUS
67982: ARRAY
67983: PPUSH
67984: LD_VAR 0 7
67988: PUSH
67989: LD_VAR 0 5
67993: ARRAY
67994: PPUSH
67995: CALL_OW 1
67999: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68000: LD_ADDR_VAR 0 7
68004: PUSH
68005: LD_VAR 0 7
68009: PPUSH
68010: LD_VAR 0 5
68014: PUSH
68015: LD_INT 1
68017: MINUS
68018: PPUSH
68019: LD_VAR 0 6
68023: PPUSH
68024: CALL_OW 1
68028: ST_TO_ADDR
// end ;
68029: GO 67946
68031: POP
68032: POP
// result := s_arr [ 1 ] ;
68033: LD_ADDR_VAR 0 4
68037: PUSH
68038: LD_VAR 0 7
68042: PUSH
68043: LD_INT 1
68045: ARRAY
68046: ST_TO_ADDR
// end ; end ;
68047: LD_VAR 0 4
68051: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68052: LD_INT 0
68054: PPUSH
68055: PPUSH
// if not list then
68056: LD_VAR 0 1
68060: NOT
68061: IFFALSE 68065
// exit ;
68063: GO 68156
// i := list [ pos1 ] ;
68065: LD_ADDR_VAR 0 5
68069: PUSH
68070: LD_VAR 0 1
68074: PUSH
68075: LD_VAR 0 2
68079: ARRAY
68080: ST_TO_ADDR
// if not i then
68081: LD_VAR 0 5
68085: NOT
68086: IFFALSE 68090
// exit ;
68088: GO 68156
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68090: LD_ADDR_VAR 0 1
68094: PUSH
68095: LD_VAR 0 1
68099: PPUSH
68100: LD_VAR 0 2
68104: PPUSH
68105: LD_VAR 0 1
68109: PUSH
68110: LD_VAR 0 3
68114: ARRAY
68115: PPUSH
68116: CALL_OW 1
68120: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68121: LD_ADDR_VAR 0 1
68125: PUSH
68126: LD_VAR 0 1
68130: PPUSH
68131: LD_VAR 0 3
68135: PPUSH
68136: LD_VAR 0 5
68140: PPUSH
68141: CALL_OW 1
68145: ST_TO_ADDR
// result := list ;
68146: LD_ADDR_VAR 0 4
68150: PUSH
68151: LD_VAR 0 1
68155: ST_TO_ADDR
// end ;
68156: LD_VAR 0 4
68160: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68161: LD_INT 0
68163: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68164: LD_ADDR_VAR 0 5
68168: PUSH
68169: LD_VAR 0 1
68173: PPUSH
68174: CALL_OW 250
68178: PPUSH
68179: LD_VAR 0 1
68183: PPUSH
68184: CALL_OW 251
68188: PPUSH
68189: LD_VAR 0 2
68193: PPUSH
68194: LD_VAR 0 3
68198: PPUSH
68199: LD_VAR 0 4
68203: PPUSH
68204: CALL 68214 0 5
68208: ST_TO_ADDR
// end ;
68209: LD_VAR 0 5
68213: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68214: LD_INT 0
68216: PPUSH
68217: PPUSH
68218: PPUSH
68219: PPUSH
// if not list then
68220: LD_VAR 0 3
68224: NOT
68225: IFFALSE 68229
// exit ;
68227: GO 68617
// result := [ ] ;
68229: LD_ADDR_VAR 0 6
68233: PUSH
68234: EMPTY
68235: ST_TO_ADDR
// for i in list do
68236: LD_ADDR_VAR 0 7
68240: PUSH
68241: LD_VAR 0 3
68245: PUSH
68246: FOR_IN
68247: IFFALSE 68449
// begin tmp := GetDistUnitXY ( i , x , y ) ;
68249: LD_ADDR_VAR 0 9
68253: PUSH
68254: LD_VAR 0 7
68258: PPUSH
68259: LD_VAR 0 1
68263: PPUSH
68264: LD_VAR 0 2
68268: PPUSH
68269: CALL_OW 297
68273: ST_TO_ADDR
// if not result then
68274: LD_VAR 0 6
68278: NOT
68279: IFFALSE 68305
// result := [ [ i , tmp ] ] else
68281: LD_ADDR_VAR 0 6
68285: PUSH
68286: LD_VAR 0 7
68290: PUSH
68291: LD_VAR 0 9
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: EMPTY
68301: LIST
68302: ST_TO_ADDR
68303: GO 68447
// begin if result [ result ] [ 2 ] < tmp then
68305: LD_VAR 0 6
68309: PUSH
68310: LD_VAR 0 6
68314: ARRAY
68315: PUSH
68316: LD_INT 2
68318: ARRAY
68319: PUSH
68320: LD_VAR 0 9
68324: LESS
68325: IFFALSE 68367
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
68327: LD_ADDR_VAR 0 6
68331: PUSH
68332: LD_VAR 0 6
68336: PPUSH
68337: LD_VAR 0 6
68341: PUSH
68342: LD_INT 1
68344: PLUS
68345: PPUSH
68346: LD_VAR 0 7
68350: PUSH
68351: LD_VAR 0 9
68355: PUSH
68356: EMPTY
68357: LIST
68358: LIST
68359: PPUSH
68360: CALL_OW 2
68364: ST_TO_ADDR
68365: GO 68447
// for j = 1 to result do
68367: LD_ADDR_VAR 0 8
68371: PUSH
68372: DOUBLE
68373: LD_INT 1
68375: DEC
68376: ST_TO_ADDR
68377: LD_VAR 0 6
68381: PUSH
68382: FOR_TO
68383: IFFALSE 68445
// begin if tmp < result [ j ] [ 2 ] then
68385: LD_VAR 0 9
68389: PUSH
68390: LD_VAR 0 6
68394: PUSH
68395: LD_VAR 0 8
68399: ARRAY
68400: PUSH
68401: LD_INT 2
68403: ARRAY
68404: LESS
68405: IFFALSE 68443
// begin result := Insert ( result , j , [ i , tmp ] ) ;
68407: LD_ADDR_VAR 0 6
68411: PUSH
68412: LD_VAR 0 6
68416: PPUSH
68417: LD_VAR 0 8
68421: PPUSH
68422: LD_VAR 0 7
68426: PUSH
68427: LD_VAR 0 9
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PPUSH
68436: CALL_OW 2
68440: ST_TO_ADDR
// break ;
68441: GO 68445
// end ; end ;
68443: GO 68382
68445: POP
68446: POP
// end ; end ;
68447: GO 68246
68449: POP
68450: POP
// if result and not asc then
68451: LD_VAR 0 6
68455: PUSH
68456: LD_VAR 0 4
68460: NOT
68461: AND
68462: IFFALSE 68537
// begin tmp := result ;
68464: LD_ADDR_VAR 0 9
68468: PUSH
68469: LD_VAR 0 6
68473: ST_TO_ADDR
// for i = tmp downto 1 do
68474: LD_ADDR_VAR 0 7
68478: PUSH
68479: DOUBLE
68480: LD_VAR 0 9
68484: INC
68485: ST_TO_ADDR
68486: LD_INT 1
68488: PUSH
68489: FOR_DOWNTO
68490: IFFALSE 68535
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
68492: LD_ADDR_VAR 0 6
68496: PUSH
68497: LD_VAR 0 6
68501: PPUSH
68502: LD_VAR 0 9
68506: PUSH
68507: LD_VAR 0 7
68511: MINUS
68512: PUSH
68513: LD_INT 1
68515: PLUS
68516: PPUSH
68517: LD_VAR 0 9
68521: PUSH
68522: LD_VAR 0 7
68526: ARRAY
68527: PPUSH
68528: CALL_OW 1
68532: ST_TO_ADDR
68533: GO 68489
68535: POP
68536: POP
// end ; tmp := [ ] ;
68537: LD_ADDR_VAR 0 9
68541: PUSH
68542: EMPTY
68543: ST_TO_ADDR
// if mode then
68544: LD_VAR 0 5
68548: IFFALSE 68617
// begin for i = 1 to result do
68550: LD_ADDR_VAR 0 7
68554: PUSH
68555: DOUBLE
68556: LD_INT 1
68558: DEC
68559: ST_TO_ADDR
68560: LD_VAR 0 6
68564: PUSH
68565: FOR_TO
68566: IFFALSE 68605
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
68568: LD_ADDR_VAR 0 9
68572: PUSH
68573: LD_VAR 0 9
68577: PPUSH
68578: LD_VAR 0 7
68582: PPUSH
68583: LD_VAR 0 6
68587: PUSH
68588: LD_VAR 0 7
68592: ARRAY
68593: PUSH
68594: LD_INT 1
68596: ARRAY
68597: PPUSH
68598: CALL_OW 1
68602: ST_TO_ADDR
68603: GO 68565
68605: POP
68606: POP
// result := tmp ;
68607: LD_ADDR_VAR 0 6
68611: PUSH
68612: LD_VAR 0 9
68616: ST_TO_ADDR
// end ; end ;
68617: LD_VAR 0 6
68621: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
68622: LD_INT 0
68624: PPUSH
68625: PPUSH
68626: PPUSH
68627: PPUSH
68628: PPUSH
68629: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
68630: LD_ADDR_VAR 0 5
68634: PUSH
68635: LD_INT 0
68637: PUSH
68638: LD_INT 0
68640: PUSH
68641: LD_INT 0
68643: PUSH
68644: EMPTY
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: ST_TO_ADDR
// if not x or not y then
68652: LD_VAR 0 2
68656: NOT
68657: PUSH
68658: LD_VAR 0 3
68662: NOT
68663: OR
68664: IFFALSE 68668
// exit ;
68666: GO 70314
// if not range then
68668: LD_VAR 0 4
68672: NOT
68673: IFFALSE 68683
// range := 10 ;
68675: LD_ADDR_VAR 0 4
68679: PUSH
68680: LD_INT 10
68682: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68683: LD_ADDR_VAR 0 8
68687: PUSH
68688: LD_INT 81
68690: PUSH
68691: LD_VAR 0 1
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 92
68702: PUSH
68703: LD_VAR 0 2
68707: PUSH
68708: LD_VAR 0 3
68712: PUSH
68713: LD_VAR 0 4
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 3
68726: PUSH
68727: LD_INT 21
68729: PUSH
68730: LD_INT 3
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: LIST
68745: PPUSH
68746: CALL_OW 69
68750: ST_TO_ADDR
// if not tmp then
68751: LD_VAR 0 8
68755: NOT
68756: IFFALSE 68760
// exit ;
68758: GO 70314
// for i in tmp do
68760: LD_ADDR_VAR 0 6
68764: PUSH
68765: LD_VAR 0 8
68769: PUSH
68770: FOR_IN
68771: IFFALSE 70289
// begin points := [ 0 , 0 , 0 ] ;
68773: LD_ADDR_VAR 0 9
68777: PUSH
68778: LD_INT 0
68780: PUSH
68781: LD_INT 0
68783: PUSH
68784: LD_INT 0
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: LIST
68791: ST_TO_ADDR
// bpoints := 1 ;
68792: LD_ADDR_VAR 0 10
68796: PUSH
68797: LD_INT 1
68799: ST_TO_ADDR
// case GetType ( i ) of unit_human :
68800: LD_VAR 0 6
68804: PPUSH
68805: CALL_OW 247
68809: PUSH
68810: LD_INT 1
68812: DOUBLE
68813: EQUAL
68814: IFTRUE 68818
68816: GO 69396
68818: POP
// begin if GetClass ( i ) = 1 then
68819: LD_VAR 0 6
68823: PPUSH
68824: CALL_OW 257
68828: PUSH
68829: LD_INT 1
68831: EQUAL
68832: IFFALSE 68853
// points := [ 10 , 5 , 3 ] ;
68834: LD_ADDR_VAR 0 9
68838: PUSH
68839: LD_INT 10
68841: PUSH
68842: LD_INT 5
68844: PUSH
68845: LD_INT 3
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: LIST
68852: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
68853: LD_VAR 0 6
68857: PPUSH
68858: CALL_OW 257
68862: PUSH
68863: LD_INT 2
68865: PUSH
68866: LD_INT 3
68868: PUSH
68869: LD_INT 4
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: LIST
68876: IN
68877: IFFALSE 68898
// points := [ 3 , 2 , 1 ] ;
68879: LD_ADDR_VAR 0 9
68883: PUSH
68884: LD_INT 3
68886: PUSH
68887: LD_INT 2
68889: PUSH
68890: LD_INT 1
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: LIST
68897: ST_TO_ADDR
// if GetClass ( i ) = 5 then
68898: LD_VAR 0 6
68902: PPUSH
68903: CALL_OW 257
68907: PUSH
68908: LD_INT 5
68910: EQUAL
68911: IFFALSE 68932
// points := [ 130 , 5 , 2 ] ;
68913: LD_ADDR_VAR 0 9
68917: PUSH
68918: LD_INT 130
68920: PUSH
68921: LD_INT 5
68923: PUSH
68924: LD_INT 2
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: LIST
68931: ST_TO_ADDR
// if GetClass ( i ) = 8 then
68932: LD_VAR 0 6
68936: PPUSH
68937: CALL_OW 257
68941: PUSH
68942: LD_INT 8
68944: EQUAL
68945: IFFALSE 68966
// points := [ 35 , 35 , 30 ] ;
68947: LD_ADDR_VAR 0 9
68951: PUSH
68952: LD_INT 35
68954: PUSH
68955: LD_INT 35
68957: PUSH
68958: LD_INT 30
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: LIST
68965: ST_TO_ADDR
// if GetClass ( i ) = 9 then
68966: LD_VAR 0 6
68970: PPUSH
68971: CALL_OW 257
68975: PUSH
68976: LD_INT 9
68978: EQUAL
68979: IFFALSE 69000
// points := [ 20 , 55 , 40 ] ;
68981: LD_ADDR_VAR 0 9
68985: PUSH
68986: LD_INT 20
68988: PUSH
68989: LD_INT 55
68991: PUSH
68992: LD_INT 40
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: LIST
68999: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69000: LD_VAR 0 6
69004: PPUSH
69005: CALL_OW 257
69009: PUSH
69010: LD_INT 12
69012: PUSH
69013: LD_INT 16
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: IN
69020: IFFALSE 69041
// points := [ 5 , 3 , 2 ] ;
69022: LD_ADDR_VAR 0 9
69026: PUSH
69027: LD_INT 5
69029: PUSH
69030: LD_INT 3
69032: PUSH
69033: LD_INT 2
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: LIST
69040: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69041: LD_VAR 0 6
69045: PPUSH
69046: CALL_OW 257
69050: PUSH
69051: LD_INT 17
69053: EQUAL
69054: IFFALSE 69075
// points := [ 100 , 50 , 75 ] ;
69056: LD_ADDR_VAR 0 9
69060: PUSH
69061: LD_INT 100
69063: PUSH
69064: LD_INT 50
69066: PUSH
69067: LD_INT 75
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: LIST
69074: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69075: LD_VAR 0 6
69079: PPUSH
69080: CALL_OW 257
69084: PUSH
69085: LD_INT 15
69087: EQUAL
69088: IFFALSE 69109
// points := [ 10 , 5 , 3 ] ;
69090: LD_ADDR_VAR 0 9
69094: PUSH
69095: LD_INT 10
69097: PUSH
69098: LD_INT 5
69100: PUSH
69101: LD_INT 3
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: LIST
69108: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69109: LD_VAR 0 6
69113: PPUSH
69114: CALL_OW 257
69118: PUSH
69119: LD_INT 14
69121: EQUAL
69122: IFFALSE 69143
// points := [ 10 , 0 , 0 ] ;
69124: LD_ADDR_VAR 0 9
69128: PUSH
69129: LD_INT 10
69131: PUSH
69132: LD_INT 0
69134: PUSH
69135: LD_INT 0
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: LIST
69142: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69143: LD_VAR 0 6
69147: PPUSH
69148: CALL_OW 257
69152: PUSH
69153: LD_INT 11
69155: EQUAL
69156: IFFALSE 69177
// points := [ 30 , 10 , 5 ] ;
69158: LD_ADDR_VAR 0 9
69162: PUSH
69163: LD_INT 30
69165: PUSH
69166: LD_INT 10
69168: PUSH
69169: LD_INT 5
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: LIST
69176: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69177: LD_VAR 0 1
69181: PPUSH
69182: LD_INT 5
69184: PPUSH
69185: CALL_OW 321
69189: PUSH
69190: LD_INT 2
69192: EQUAL
69193: IFFALSE 69210
// bpoints := bpoints * 1.8 ;
69195: LD_ADDR_VAR 0 10
69199: PUSH
69200: LD_VAR 0 10
69204: PUSH
69205: LD_REAL  1.80000000000000E+0000
69208: MUL
69209: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69210: LD_VAR 0 6
69214: PPUSH
69215: CALL_OW 257
69219: PUSH
69220: LD_INT 1
69222: PUSH
69223: LD_INT 2
69225: PUSH
69226: LD_INT 3
69228: PUSH
69229: LD_INT 4
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: IN
69238: PUSH
69239: LD_VAR 0 1
69243: PPUSH
69244: LD_INT 51
69246: PPUSH
69247: CALL_OW 321
69251: PUSH
69252: LD_INT 2
69254: EQUAL
69255: AND
69256: IFFALSE 69273
// bpoints := bpoints * 1.2 ;
69258: LD_ADDR_VAR 0 10
69262: PUSH
69263: LD_VAR 0 10
69267: PUSH
69268: LD_REAL  1.20000000000000E+0000
69271: MUL
69272: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
69273: LD_VAR 0 6
69277: PPUSH
69278: CALL_OW 257
69282: PUSH
69283: LD_INT 5
69285: PUSH
69286: LD_INT 7
69288: PUSH
69289: LD_INT 9
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: LIST
69296: IN
69297: PUSH
69298: LD_VAR 0 1
69302: PPUSH
69303: LD_INT 52
69305: PPUSH
69306: CALL_OW 321
69310: PUSH
69311: LD_INT 2
69313: EQUAL
69314: AND
69315: IFFALSE 69332
// bpoints := bpoints * 1.5 ;
69317: LD_ADDR_VAR 0 10
69321: PUSH
69322: LD_VAR 0 10
69326: PUSH
69327: LD_REAL  1.50000000000000E+0000
69330: MUL
69331: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
69332: LD_VAR 0 1
69336: PPUSH
69337: LD_INT 66
69339: PPUSH
69340: CALL_OW 321
69344: PUSH
69345: LD_INT 2
69347: EQUAL
69348: IFFALSE 69365
// bpoints := bpoints * 1.1 ;
69350: LD_ADDR_VAR 0 10
69354: PUSH
69355: LD_VAR 0 10
69359: PUSH
69360: LD_REAL  1.10000000000000E+0000
69363: MUL
69364: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69365: LD_ADDR_VAR 0 10
69369: PUSH
69370: LD_VAR 0 10
69374: PUSH
69375: LD_VAR 0 6
69379: PPUSH
69380: LD_INT 1
69382: PPUSH
69383: CALL_OW 259
69387: PUSH
69388: LD_REAL  1.15000000000000E+0000
69391: MUL
69392: MUL
69393: ST_TO_ADDR
// end ; unit_vehicle :
69394: GO 70218
69396: LD_INT 2
69398: DOUBLE
69399: EQUAL
69400: IFTRUE 69404
69402: GO 70206
69404: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
69405: LD_VAR 0 6
69409: PPUSH
69410: CALL_OW 264
69414: PUSH
69415: LD_INT 2
69417: PUSH
69418: LD_INT 42
69420: PUSH
69421: LD_INT 24
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: LIST
69428: IN
69429: IFFALSE 69450
// points := [ 25 , 5 , 3 ] ;
69431: LD_ADDR_VAR 0 9
69435: PUSH
69436: LD_INT 25
69438: PUSH
69439: LD_INT 5
69441: PUSH
69442: LD_INT 3
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: LIST
69449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
69450: LD_VAR 0 6
69454: PPUSH
69455: CALL_OW 264
69459: PUSH
69460: LD_INT 4
69462: PUSH
69463: LD_INT 43
69465: PUSH
69466: LD_INT 25
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: LIST
69473: IN
69474: IFFALSE 69495
// points := [ 40 , 15 , 5 ] ;
69476: LD_ADDR_VAR 0 9
69480: PUSH
69481: LD_INT 40
69483: PUSH
69484: LD_INT 15
69486: PUSH
69487: LD_INT 5
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: LIST
69494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
69495: LD_VAR 0 6
69499: PPUSH
69500: CALL_OW 264
69504: PUSH
69505: LD_INT 3
69507: PUSH
69508: LD_INT 23
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: IN
69515: IFFALSE 69536
// points := [ 7 , 25 , 8 ] ;
69517: LD_ADDR_VAR 0 9
69521: PUSH
69522: LD_INT 7
69524: PUSH
69525: LD_INT 25
69527: PUSH
69528: LD_INT 8
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: LIST
69535: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
69536: LD_VAR 0 6
69540: PPUSH
69541: CALL_OW 264
69545: PUSH
69546: LD_INT 5
69548: PUSH
69549: LD_INT 27
69551: PUSH
69552: LD_INT 44
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: LIST
69559: IN
69560: IFFALSE 69581
// points := [ 14 , 50 , 16 ] ;
69562: LD_ADDR_VAR 0 9
69566: PUSH
69567: LD_INT 14
69569: PUSH
69570: LD_INT 50
69572: PUSH
69573: LD_INT 16
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: LIST
69580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
69581: LD_VAR 0 6
69585: PPUSH
69586: CALL_OW 264
69590: PUSH
69591: LD_INT 6
69593: PUSH
69594: LD_INT 46
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: IN
69601: IFFALSE 69622
// points := [ 32 , 120 , 70 ] ;
69603: LD_ADDR_VAR 0 9
69607: PUSH
69608: LD_INT 32
69610: PUSH
69611: LD_INT 120
69613: PUSH
69614: LD_INT 70
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: LIST
69621: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
69622: LD_VAR 0 6
69626: PPUSH
69627: CALL_OW 264
69631: PUSH
69632: LD_INT 7
69634: PUSH
69635: LD_INT 28
69637: PUSH
69638: LD_INT 45
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: LIST
69645: IN
69646: IFFALSE 69667
// points := [ 35 , 20 , 45 ] ;
69648: LD_ADDR_VAR 0 9
69652: PUSH
69653: LD_INT 35
69655: PUSH
69656: LD_INT 20
69658: PUSH
69659: LD_INT 45
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: LIST
69666: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
69667: LD_VAR 0 6
69671: PPUSH
69672: CALL_OW 264
69676: PUSH
69677: LD_INT 47
69679: PUSH
69680: EMPTY
69681: LIST
69682: IN
69683: IFFALSE 69704
// points := [ 67 , 45 , 75 ] ;
69685: LD_ADDR_VAR 0 9
69689: PUSH
69690: LD_INT 67
69692: PUSH
69693: LD_INT 45
69695: PUSH
69696: LD_INT 75
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: LIST
69703: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
69704: LD_VAR 0 6
69708: PPUSH
69709: CALL_OW 264
69713: PUSH
69714: LD_INT 26
69716: PUSH
69717: EMPTY
69718: LIST
69719: IN
69720: IFFALSE 69741
// points := [ 120 , 30 , 80 ] ;
69722: LD_ADDR_VAR 0 9
69726: PUSH
69727: LD_INT 120
69729: PUSH
69730: LD_INT 30
69732: PUSH
69733: LD_INT 80
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: LIST
69740: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
69741: LD_VAR 0 6
69745: PPUSH
69746: CALL_OW 264
69750: PUSH
69751: LD_INT 22
69753: PUSH
69754: EMPTY
69755: LIST
69756: IN
69757: IFFALSE 69778
// points := [ 40 , 1 , 1 ] ;
69759: LD_ADDR_VAR 0 9
69763: PUSH
69764: LD_INT 40
69766: PUSH
69767: LD_INT 1
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: LIST
69777: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
69778: LD_VAR 0 6
69782: PPUSH
69783: CALL_OW 264
69787: PUSH
69788: LD_INT 29
69790: PUSH
69791: EMPTY
69792: LIST
69793: IN
69794: IFFALSE 69815
// points := [ 70 , 200 , 400 ] ;
69796: LD_ADDR_VAR 0 9
69800: PUSH
69801: LD_INT 70
69803: PUSH
69804: LD_INT 200
69806: PUSH
69807: LD_INT 400
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: LIST
69814: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
69815: LD_VAR 0 6
69819: PPUSH
69820: CALL_OW 264
69824: PUSH
69825: LD_INT 14
69827: PUSH
69828: LD_INT 53
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: IN
69835: IFFALSE 69856
// points := [ 40 , 10 , 20 ] ;
69837: LD_ADDR_VAR 0 9
69841: PUSH
69842: LD_INT 40
69844: PUSH
69845: LD_INT 10
69847: PUSH
69848: LD_INT 20
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: LIST
69855: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
69856: LD_VAR 0 6
69860: PPUSH
69861: CALL_OW 264
69865: PUSH
69866: LD_INT 9
69868: PUSH
69869: EMPTY
69870: LIST
69871: IN
69872: IFFALSE 69893
// points := [ 5 , 70 , 20 ] ;
69874: LD_ADDR_VAR 0 9
69878: PUSH
69879: LD_INT 5
69881: PUSH
69882: LD_INT 70
69884: PUSH
69885: LD_INT 20
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: LIST
69892: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
69893: LD_VAR 0 6
69897: PPUSH
69898: CALL_OW 264
69902: PUSH
69903: LD_INT 10
69905: PUSH
69906: EMPTY
69907: LIST
69908: IN
69909: IFFALSE 69930
// points := [ 35 , 110 , 70 ] ;
69911: LD_ADDR_VAR 0 9
69915: PUSH
69916: LD_INT 35
69918: PUSH
69919: LD_INT 110
69921: PUSH
69922: LD_INT 70
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: LIST
69929: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
69930: LD_VAR 0 6
69934: PPUSH
69935: CALL_OW 265
69939: PUSH
69940: LD_INT 25
69942: EQUAL
69943: IFFALSE 69964
// points := [ 80 , 65 , 100 ] ;
69945: LD_ADDR_VAR 0 9
69949: PUSH
69950: LD_INT 80
69952: PUSH
69953: LD_INT 65
69955: PUSH
69956: LD_INT 100
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: LIST
69963: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
69964: LD_VAR 0 6
69968: PPUSH
69969: CALL_OW 263
69973: PUSH
69974: LD_INT 1
69976: EQUAL
69977: IFFALSE 70012
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
69979: LD_ADDR_VAR 0 10
69983: PUSH
69984: LD_VAR 0 10
69988: PUSH
69989: LD_VAR 0 6
69993: PPUSH
69994: CALL_OW 311
69998: PPUSH
69999: LD_INT 3
70001: PPUSH
70002: CALL_OW 259
70006: PUSH
70007: LD_INT 4
70009: MUL
70010: MUL
70011: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70012: LD_VAR 0 6
70016: PPUSH
70017: CALL_OW 263
70021: PUSH
70022: LD_INT 2
70024: EQUAL
70025: IFFALSE 70076
// begin j := IsControledBy ( i ) ;
70027: LD_ADDR_VAR 0 7
70031: PUSH
70032: LD_VAR 0 6
70036: PPUSH
70037: CALL_OW 312
70041: ST_TO_ADDR
// if j then
70042: LD_VAR 0 7
70046: IFFALSE 70076
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70048: LD_ADDR_VAR 0 10
70052: PUSH
70053: LD_VAR 0 10
70057: PUSH
70058: LD_VAR 0 7
70062: PPUSH
70063: LD_INT 3
70065: PPUSH
70066: CALL_OW 259
70070: PUSH
70071: LD_INT 3
70073: MUL
70074: MUL
70075: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70076: LD_VAR 0 6
70080: PPUSH
70081: CALL_OW 264
70085: PUSH
70086: LD_INT 5
70088: PUSH
70089: LD_INT 6
70091: PUSH
70092: LD_INT 46
70094: PUSH
70095: LD_INT 44
70097: PUSH
70098: LD_INT 47
70100: PUSH
70101: LD_INT 45
70103: PUSH
70104: LD_INT 28
70106: PUSH
70107: LD_INT 7
70109: PUSH
70110: LD_INT 27
70112: PUSH
70113: LD_INT 29
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: IN
70128: PUSH
70129: LD_VAR 0 1
70133: PPUSH
70134: LD_INT 52
70136: PPUSH
70137: CALL_OW 321
70141: PUSH
70142: LD_INT 2
70144: EQUAL
70145: AND
70146: IFFALSE 70163
// bpoints := bpoints * 1.2 ;
70148: LD_ADDR_VAR 0 10
70152: PUSH
70153: LD_VAR 0 10
70157: PUSH
70158: LD_REAL  1.20000000000000E+0000
70161: MUL
70162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70163: LD_VAR 0 6
70167: PPUSH
70168: CALL_OW 264
70172: PUSH
70173: LD_INT 6
70175: PUSH
70176: LD_INT 46
70178: PUSH
70179: LD_INT 47
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: LIST
70186: IN
70187: IFFALSE 70204
// bpoints := bpoints * 1.2 ;
70189: LD_ADDR_VAR 0 10
70193: PUSH
70194: LD_VAR 0 10
70198: PUSH
70199: LD_REAL  1.20000000000000E+0000
70202: MUL
70203: ST_TO_ADDR
// end ; unit_building :
70204: GO 70218
70206: LD_INT 3
70208: DOUBLE
70209: EQUAL
70210: IFTRUE 70214
70212: GO 70217
70214: POP
// ; end ;
70215: GO 70218
70217: POP
// for j = 1 to 3 do
70218: LD_ADDR_VAR 0 7
70222: PUSH
70223: DOUBLE
70224: LD_INT 1
70226: DEC
70227: ST_TO_ADDR
70228: LD_INT 3
70230: PUSH
70231: FOR_TO
70232: IFFALSE 70285
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70234: LD_ADDR_VAR 0 5
70238: PUSH
70239: LD_VAR 0 5
70243: PPUSH
70244: LD_VAR 0 7
70248: PPUSH
70249: LD_VAR 0 5
70253: PUSH
70254: LD_VAR 0 7
70258: ARRAY
70259: PUSH
70260: LD_VAR 0 9
70264: PUSH
70265: LD_VAR 0 7
70269: ARRAY
70270: PUSH
70271: LD_VAR 0 10
70275: MUL
70276: PLUS
70277: PPUSH
70278: CALL_OW 1
70282: ST_TO_ADDR
70283: GO 70231
70285: POP
70286: POP
// end ;
70287: GO 68770
70289: POP
70290: POP
// result := Replace ( result , 4 , tmp ) ;
70291: LD_ADDR_VAR 0 5
70295: PUSH
70296: LD_VAR 0 5
70300: PPUSH
70301: LD_INT 4
70303: PPUSH
70304: LD_VAR 0 8
70308: PPUSH
70309: CALL_OW 1
70313: ST_TO_ADDR
// end ;
70314: LD_VAR 0 5
70318: RET
// export function DangerAtRange ( unit , range ) ; begin
70319: LD_INT 0
70321: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
70322: LD_ADDR_VAR 0 3
70326: PUSH
70327: LD_VAR 0 1
70331: PPUSH
70332: CALL_OW 255
70336: PPUSH
70337: LD_VAR 0 1
70341: PPUSH
70342: CALL_OW 250
70346: PPUSH
70347: LD_VAR 0 1
70351: PPUSH
70352: CALL_OW 251
70356: PPUSH
70357: LD_VAR 0 2
70361: PPUSH
70362: CALL 68622 0 4
70366: ST_TO_ADDR
// end ;
70367: LD_VAR 0 3
70371: RET
// export function DangerInArea ( side , area ) ; begin
70372: LD_INT 0
70374: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
70375: LD_ADDR_VAR 0 3
70379: PUSH
70380: LD_VAR 0 2
70384: PPUSH
70385: LD_INT 81
70387: PUSH
70388: LD_VAR 0 1
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PPUSH
70397: CALL_OW 70
70401: ST_TO_ADDR
// end ;
70402: LD_VAR 0 3
70406: RET
// export function IsExtension ( b ) ; begin
70407: LD_INT 0
70409: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
70410: LD_ADDR_VAR 0 2
70414: PUSH
70415: LD_VAR 0 1
70419: PUSH
70420: LD_INT 23
70422: PUSH
70423: LD_INT 20
70425: PUSH
70426: LD_INT 22
70428: PUSH
70429: LD_INT 17
70431: PUSH
70432: LD_INT 24
70434: PUSH
70435: LD_INT 21
70437: PUSH
70438: LD_INT 19
70440: PUSH
70441: LD_INT 16
70443: PUSH
70444: LD_INT 25
70446: PUSH
70447: LD_INT 18
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: IN
70462: ST_TO_ADDR
// end ;
70463: LD_VAR 0 2
70467: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
70468: LD_INT 0
70470: PPUSH
70471: PPUSH
70472: PPUSH
// result := [ ] ;
70473: LD_ADDR_VAR 0 3
70477: PUSH
70478: EMPTY
70479: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
70480: LD_ADDR_VAR 0 4
70484: PUSH
70485: LD_VAR 0 2
70489: PPUSH
70490: LD_INT 21
70492: PUSH
70493: LD_INT 3
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PPUSH
70500: CALL_OW 70
70504: ST_TO_ADDR
// if not tmp then
70505: LD_VAR 0 4
70509: NOT
70510: IFFALSE 70514
// exit ;
70512: GO 70572
// for i in tmp do
70514: LD_ADDR_VAR 0 5
70518: PUSH
70519: LD_VAR 0 4
70523: PUSH
70524: FOR_IN
70525: IFFALSE 70560
// if GetBase ( i ) <> base then
70527: LD_VAR 0 5
70531: PPUSH
70532: CALL_OW 274
70536: PUSH
70537: LD_VAR 0 1
70541: NONEQUAL
70542: IFFALSE 70558
// ComLinkToBase ( base , i ) ;
70544: LD_VAR 0 1
70548: PPUSH
70549: LD_VAR 0 5
70553: PPUSH
70554: CALL_OW 169
70558: GO 70524
70560: POP
70561: POP
// result := tmp ;
70562: LD_ADDR_VAR 0 3
70566: PUSH
70567: LD_VAR 0 4
70571: ST_TO_ADDR
// end ;
70572: LD_VAR 0 3
70576: RET
// export function ComComplete ( unit , b ) ; var i ; begin
70577: LD_INT 0
70579: PPUSH
70580: PPUSH
// if BuildingStatus ( b ) = bs_build then
70581: LD_VAR 0 2
70585: PPUSH
70586: CALL_OW 461
70590: PUSH
70591: LD_INT 1
70593: EQUAL
70594: IFFALSE 70654
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
70596: LD_VAR 0 1
70600: PPUSH
70601: LD_STRING h
70603: PUSH
70604: LD_VAR 0 2
70608: PPUSH
70609: CALL_OW 250
70613: PUSH
70614: LD_VAR 0 2
70618: PPUSH
70619: CALL_OW 251
70623: PUSH
70624: LD_VAR 0 2
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: LD_INT 0
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: PUSH
70647: EMPTY
70648: LIST
70649: PPUSH
70650: CALL_OW 446
// end ;
70654: LD_VAR 0 3
70658: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
70659: LD_INT 0
70661: PPUSH
70662: PPUSH
70663: PPUSH
70664: PPUSH
70665: PPUSH
70666: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
70667: LD_VAR 0 1
70671: NOT
70672: PUSH
70673: LD_VAR 0 1
70677: PPUSH
70678: CALL_OW 263
70682: PUSH
70683: LD_INT 2
70685: EQUAL
70686: NOT
70687: OR
70688: IFFALSE 70692
// exit ;
70690: GO 71008
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
70692: LD_ADDR_VAR 0 6
70696: PUSH
70697: LD_INT 22
70699: PUSH
70700: LD_VAR 0 1
70704: PPUSH
70705: CALL_OW 255
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: PUSH
70717: LD_INT 30
70719: PUSH
70720: LD_INT 36
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 34
70729: PUSH
70730: LD_INT 31
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: LIST
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PPUSH
70746: CALL_OW 69
70750: ST_TO_ADDR
// if not tmp then
70751: LD_VAR 0 6
70755: NOT
70756: IFFALSE 70760
// exit ;
70758: GO 71008
// result := [ ] ;
70760: LD_ADDR_VAR 0 2
70764: PUSH
70765: EMPTY
70766: ST_TO_ADDR
// for i in tmp do
70767: LD_ADDR_VAR 0 3
70771: PUSH
70772: LD_VAR 0 6
70776: PUSH
70777: FOR_IN
70778: IFFALSE 70849
// begin t := UnitsInside ( i ) ;
70780: LD_ADDR_VAR 0 4
70784: PUSH
70785: LD_VAR 0 3
70789: PPUSH
70790: CALL_OW 313
70794: ST_TO_ADDR
// if t then
70795: LD_VAR 0 4
70799: IFFALSE 70847
// for j in t do
70801: LD_ADDR_VAR 0 7
70805: PUSH
70806: LD_VAR 0 4
70810: PUSH
70811: FOR_IN
70812: IFFALSE 70845
// result := Insert ( result , result + 1 , j ) ;
70814: LD_ADDR_VAR 0 2
70818: PUSH
70819: LD_VAR 0 2
70823: PPUSH
70824: LD_VAR 0 2
70828: PUSH
70829: LD_INT 1
70831: PLUS
70832: PPUSH
70833: LD_VAR 0 7
70837: PPUSH
70838: CALL_OW 2
70842: ST_TO_ADDR
70843: GO 70811
70845: POP
70846: POP
// end ;
70847: GO 70777
70849: POP
70850: POP
// if not result then
70851: LD_VAR 0 2
70855: NOT
70856: IFFALSE 70860
// exit ;
70858: GO 71008
// mech := result [ 1 ] ;
70860: LD_ADDR_VAR 0 5
70864: PUSH
70865: LD_VAR 0 2
70869: PUSH
70870: LD_INT 1
70872: ARRAY
70873: ST_TO_ADDR
// if result > 1 then
70874: LD_VAR 0 2
70878: PUSH
70879: LD_INT 1
70881: GREATER
70882: IFFALSE 70994
// for i = 2 to result do
70884: LD_ADDR_VAR 0 3
70888: PUSH
70889: DOUBLE
70890: LD_INT 2
70892: DEC
70893: ST_TO_ADDR
70894: LD_VAR 0 2
70898: PUSH
70899: FOR_TO
70900: IFFALSE 70992
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
70902: LD_ADDR_VAR 0 4
70906: PUSH
70907: LD_VAR 0 2
70911: PUSH
70912: LD_VAR 0 3
70916: ARRAY
70917: PPUSH
70918: LD_INT 3
70920: PPUSH
70921: CALL_OW 259
70925: PUSH
70926: LD_VAR 0 2
70930: PUSH
70931: LD_VAR 0 3
70935: ARRAY
70936: PPUSH
70937: CALL_OW 432
70941: MINUS
70942: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
70943: LD_VAR 0 4
70947: PUSH
70948: LD_VAR 0 5
70952: PPUSH
70953: LD_INT 3
70955: PPUSH
70956: CALL_OW 259
70960: PUSH
70961: LD_VAR 0 5
70965: PPUSH
70966: CALL_OW 432
70970: MINUS
70971: GREATEREQUAL
70972: IFFALSE 70990
// mech := result [ i ] ;
70974: LD_ADDR_VAR 0 5
70978: PUSH
70979: LD_VAR 0 2
70983: PUSH
70984: LD_VAR 0 3
70988: ARRAY
70989: ST_TO_ADDR
// end ;
70990: GO 70899
70992: POP
70993: POP
// ComLinkTo ( vehicle , mech ) ;
70994: LD_VAR 0 1
70998: PPUSH
70999: LD_VAR 0 5
71003: PPUSH
71004: CALL_OW 135
// end ;
71008: LD_VAR 0 2
71012: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71013: LD_INT 0
71015: PPUSH
71016: PPUSH
71017: PPUSH
71018: PPUSH
71019: PPUSH
71020: PPUSH
71021: PPUSH
71022: PPUSH
71023: PPUSH
71024: PPUSH
71025: PPUSH
71026: PPUSH
71027: PPUSH
// result := [ ] ;
71028: LD_ADDR_VAR 0 7
71032: PUSH
71033: EMPTY
71034: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71035: LD_VAR 0 1
71039: PPUSH
71040: CALL_OW 266
71044: PUSH
71045: LD_INT 0
71047: PUSH
71048: LD_INT 1
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: IN
71055: NOT
71056: IFFALSE 71060
// exit ;
71058: GO 72691
// if name then
71060: LD_VAR 0 3
71064: IFFALSE 71080
// SetBName ( base_dep , name ) ;
71066: LD_VAR 0 1
71070: PPUSH
71071: LD_VAR 0 3
71075: PPUSH
71076: CALL_OW 500
// base := GetBase ( base_dep ) ;
71080: LD_ADDR_VAR 0 15
71084: PUSH
71085: LD_VAR 0 1
71089: PPUSH
71090: CALL_OW 274
71094: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71095: LD_ADDR_VAR 0 16
71099: PUSH
71100: LD_VAR 0 1
71104: PPUSH
71105: CALL_OW 255
71109: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71110: LD_ADDR_VAR 0 17
71114: PUSH
71115: LD_VAR 0 1
71119: PPUSH
71120: CALL_OW 248
71124: ST_TO_ADDR
// if sources then
71125: LD_VAR 0 5
71129: IFFALSE 71176
// for i = 1 to 3 do
71131: LD_ADDR_VAR 0 8
71135: PUSH
71136: DOUBLE
71137: LD_INT 1
71139: DEC
71140: ST_TO_ADDR
71141: LD_INT 3
71143: PUSH
71144: FOR_TO
71145: IFFALSE 71174
// AddResourceType ( base , i , sources [ i ] ) ;
71147: LD_VAR 0 15
71151: PPUSH
71152: LD_VAR 0 8
71156: PPUSH
71157: LD_VAR 0 5
71161: PUSH
71162: LD_VAR 0 8
71166: ARRAY
71167: PPUSH
71168: CALL_OW 276
71172: GO 71144
71174: POP
71175: POP
// buildings := GetBaseBuildings ( base , area ) ;
71176: LD_ADDR_VAR 0 18
71180: PUSH
71181: LD_VAR 0 15
71185: PPUSH
71186: LD_VAR 0 2
71190: PPUSH
71191: CALL 70468 0 2
71195: ST_TO_ADDR
// InitHc ;
71196: CALL_OW 19
// InitUc ;
71200: CALL_OW 18
// uc_side := side ;
71204: LD_ADDR_OWVAR 20
71208: PUSH
71209: LD_VAR 0 16
71213: ST_TO_ADDR
// uc_nation := nation ;
71214: LD_ADDR_OWVAR 21
71218: PUSH
71219: LD_VAR 0 17
71223: ST_TO_ADDR
// if buildings then
71224: LD_VAR 0 18
71228: IFFALSE 72550
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
71230: LD_ADDR_VAR 0 19
71234: PUSH
71235: LD_VAR 0 18
71239: PPUSH
71240: LD_INT 2
71242: PUSH
71243: LD_INT 30
71245: PUSH
71246: LD_INT 29
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PUSH
71253: LD_INT 30
71255: PUSH
71256: LD_INT 30
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: LIST
71267: PPUSH
71268: CALL_OW 72
71272: ST_TO_ADDR
// if tmp then
71273: LD_VAR 0 19
71277: IFFALSE 71325
// for i in tmp do
71279: LD_ADDR_VAR 0 8
71283: PUSH
71284: LD_VAR 0 19
71288: PUSH
71289: FOR_IN
71290: IFFALSE 71323
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71292: LD_VAR 0 8
71296: PPUSH
71297: CALL_OW 250
71301: PPUSH
71302: LD_VAR 0 8
71306: PPUSH
71307: CALL_OW 251
71311: PPUSH
71312: LD_VAR 0 16
71316: PPUSH
71317: CALL_OW 441
71321: GO 71289
71323: POP
71324: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71325: LD_VAR 0 18
71329: PPUSH
71330: LD_INT 2
71332: PUSH
71333: LD_INT 30
71335: PUSH
71336: LD_INT 32
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 30
71345: PUSH
71346: LD_INT 33
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: LIST
71357: PPUSH
71358: CALL_OW 72
71362: IFFALSE 71450
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
71364: LD_ADDR_VAR 0 8
71368: PUSH
71369: LD_VAR 0 18
71373: PPUSH
71374: LD_INT 2
71376: PUSH
71377: LD_INT 30
71379: PUSH
71380: LD_INT 32
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 30
71389: PUSH
71390: LD_INT 33
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: LIST
71401: PPUSH
71402: CALL_OW 72
71406: PUSH
71407: FOR_IN
71408: IFFALSE 71448
// begin if not GetBWeapon ( i ) then
71410: LD_VAR 0 8
71414: PPUSH
71415: CALL_OW 269
71419: NOT
71420: IFFALSE 71446
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
71422: LD_VAR 0 8
71426: PPUSH
71427: LD_VAR 0 8
71431: PPUSH
71432: LD_VAR 0 2
71436: PPUSH
71437: CALL 72696 0 2
71441: PPUSH
71442: CALL_OW 431
// end ;
71446: GO 71407
71448: POP
71449: POP
// end ; for i = 1 to personel do
71450: LD_ADDR_VAR 0 8
71454: PUSH
71455: DOUBLE
71456: LD_INT 1
71458: DEC
71459: ST_TO_ADDR
71460: LD_VAR 0 6
71464: PUSH
71465: FOR_TO
71466: IFFALSE 72530
// begin if i > 4 then
71468: LD_VAR 0 8
71472: PUSH
71473: LD_INT 4
71475: GREATER
71476: IFFALSE 71480
// break ;
71478: GO 72530
// case i of 1 :
71480: LD_VAR 0 8
71484: PUSH
71485: LD_INT 1
71487: DOUBLE
71488: EQUAL
71489: IFTRUE 71493
71491: GO 71573
71493: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
71494: LD_ADDR_VAR 0 12
71498: PUSH
71499: LD_VAR 0 18
71503: PPUSH
71504: LD_INT 22
71506: PUSH
71507: LD_VAR 0 16
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 58
71518: PUSH
71519: EMPTY
71520: LIST
71521: PUSH
71522: LD_INT 2
71524: PUSH
71525: LD_INT 30
71527: PUSH
71528: LD_INT 32
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 30
71537: PUSH
71538: LD_INT 4
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 30
71547: PUSH
71548: LD_INT 5
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: LIST
71565: PPUSH
71566: CALL_OW 72
71570: ST_TO_ADDR
71571: GO 71795
71573: LD_INT 2
71575: DOUBLE
71576: EQUAL
71577: IFTRUE 71581
71579: GO 71643
71581: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
71582: LD_ADDR_VAR 0 12
71586: PUSH
71587: LD_VAR 0 18
71591: PPUSH
71592: LD_INT 22
71594: PUSH
71595: LD_VAR 0 16
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 2
71606: PUSH
71607: LD_INT 30
71609: PUSH
71610: LD_INT 0
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 30
71619: PUSH
71620: LD_INT 1
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: LIST
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PPUSH
71636: CALL_OW 72
71640: ST_TO_ADDR
71641: GO 71795
71643: LD_INT 3
71645: DOUBLE
71646: EQUAL
71647: IFTRUE 71651
71649: GO 71713
71651: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
71652: LD_ADDR_VAR 0 12
71656: PUSH
71657: LD_VAR 0 18
71661: PPUSH
71662: LD_INT 22
71664: PUSH
71665: LD_VAR 0 16
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 2
71676: PUSH
71677: LD_INT 30
71679: PUSH
71680: LD_INT 2
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 30
71689: PUSH
71690: LD_INT 3
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: LIST
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PPUSH
71706: CALL_OW 72
71710: ST_TO_ADDR
71711: GO 71795
71713: LD_INT 4
71715: DOUBLE
71716: EQUAL
71717: IFTRUE 71721
71719: GO 71794
71721: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
71722: LD_ADDR_VAR 0 12
71726: PUSH
71727: LD_VAR 0 18
71731: PPUSH
71732: LD_INT 22
71734: PUSH
71735: LD_VAR 0 16
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 2
71746: PUSH
71747: LD_INT 30
71749: PUSH
71750: LD_INT 6
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 30
71759: PUSH
71760: LD_INT 7
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 30
71769: PUSH
71770: LD_INT 8
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PPUSH
71787: CALL_OW 72
71791: ST_TO_ADDR
71792: GO 71795
71794: POP
// if i = 1 then
71795: LD_VAR 0 8
71799: PUSH
71800: LD_INT 1
71802: EQUAL
71803: IFFALSE 71914
// begin tmp := [ ] ;
71805: LD_ADDR_VAR 0 19
71809: PUSH
71810: EMPTY
71811: ST_TO_ADDR
// for j in f do
71812: LD_ADDR_VAR 0 9
71816: PUSH
71817: LD_VAR 0 12
71821: PUSH
71822: FOR_IN
71823: IFFALSE 71896
// if GetBType ( j ) = b_bunker then
71825: LD_VAR 0 9
71829: PPUSH
71830: CALL_OW 266
71834: PUSH
71835: LD_INT 32
71837: EQUAL
71838: IFFALSE 71865
// tmp := Insert ( tmp , 1 , j ) else
71840: LD_ADDR_VAR 0 19
71844: PUSH
71845: LD_VAR 0 19
71849: PPUSH
71850: LD_INT 1
71852: PPUSH
71853: LD_VAR 0 9
71857: PPUSH
71858: CALL_OW 2
71862: ST_TO_ADDR
71863: GO 71894
// tmp := Insert ( tmp , tmp + 1 , j ) ;
71865: LD_ADDR_VAR 0 19
71869: PUSH
71870: LD_VAR 0 19
71874: PPUSH
71875: LD_VAR 0 19
71879: PUSH
71880: LD_INT 1
71882: PLUS
71883: PPUSH
71884: LD_VAR 0 9
71888: PPUSH
71889: CALL_OW 2
71893: ST_TO_ADDR
71894: GO 71822
71896: POP
71897: POP
// if tmp then
71898: LD_VAR 0 19
71902: IFFALSE 71914
// f := tmp ;
71904: LD_ADDR_VAR 0 12
71908: PUSH
71909: LD_VAR 0 19
71913: ST_TO_ADDR
// end ; x := personel [ i ] ;
71914: LD_ADDR_VAR 0 13
71918: PUSH
71919: LD_VAR 0 6
71923: PUSH
71924: LD_VAR 0 8
71928: ARRAY
71929: ST_TO_ADDR
// if x = - 1 then
71930: LD_VAR 0 13
71934: PUSH
71935: LD_INT 1
71937: NEG
71938: EQUAL
71939: IFFALSE 72148
// begin for j in f do
71941: LD_ADDR_VAR 0 9
71945: PUSH
71946: LD_VAR 0 12
71950: PUSH
71951: FOR_IN
71952: IFFALSE 72144
// repeat InitHc ;
71954: CALL_OW 19
// if GetBType ( j ) = b_barracks then
71958: LD_VAR 0 9
71962: PPUSH
71963: CALL_OW 266
71967: PUSH
71968: LD_INT 5
71970: EQUAL
71971: IFFALSE 72041
// begin if UnitsInside ( j ) < 3 then
71973: LD_VAR 0 9
71977: PPUSH
71978: CALL_OW 313
71982: PUSH
71983: LD_INT 3
71985: LESS
71986: IFFALSE 72022
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
71988: LD_INT 0
71990: PPUSH
71991: LD_INT 5
71993: PUSH
71994: LD_INT 8
71996: PUSH
71997: LD_INT 9
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: LIST
72004: PUSH
72005: LD_VAR 0 17
72009: ARRAY
72010: PPUSH
72011: LD_VAR 0 4
72015: PPUSH
72016: CALL_OW 380
72020: GO 72039
// PrepareHuman ( false , i , skill ) ;
72022: LD_INT 0
72024: PPUSH
72025: LD_VAR 0 8
72029: PPUSH
72030: LD_VAR 0 4
72034: PPUSH
72035: CALL_OW 380
// end else
72039: GO 72058
// PrepareHuman ( false , i , skill ) ;
72041: LD_INT 0
72043: PPUSH
72044: LD_VAR 0 8
72048: PPUSH
72049: LD_VAR 0 4
72053: PPUSH
72054: CALL_OW 380
// un := CreateHuman ;
72058: LD_ADDR_VAR 0 14
72062: PUSH
72063: CALL_OW 44
72067: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72068: LD_ADDR_VAR 0 7
72072: PUSH
72073: LD_VAR 0 7
72077: PPUSH
72078: LD_INT 1
72080: PPUSH
72081: LD_VAR 0 14
72085: PPUSH
72086: CALL_OW 2
72090: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72091: LD_VAR 0 14
72095: PPUSH
72096: LD_VAR 0 9
72100: PPUSH
72101: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72105: LD_VAR 0 9
72109: PPUSH
72110: CALL_OW 313
72114: PUSH
72115: LD_INT 6
72117: EQUAL
72118: PUSH
72119: LD_VAR 0 9
72123: PPUSH
72124: CALL_OW 266
72128: PUSH
72129: LD_INT 32
72131: PUSH
72132: LD_INT 31
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: IN
72139: OR
72140: IFFALSE 71954
72142: GO 71951
72144: POP
72145: POP
// end else
72146: GO 72528
// for j = 1 to x do
72148: LD_ADDR_VAR 0 9
72152: PUSH
72153: DOUBLE
72154: LD_INT 1
72156: DEC
72157: ST_TO_ADDR
72158: LD_VAR 0 13
72162: PUSH
72163: FOR_TO
72164: IFFALSE 72526
// begin InitHc ;
72166: CALL_OW 19
// if not f then
72170: LD_VAR 0 12
72174: NOT
72175: IFFALSE 72264
// begin PrepareHuman ( false , i , skill ) ;
72177: LD_INT 0
72179: PPUSH
72180: LD_VAR 0 8
72184: PPUSH
72185: LD_VAR 0 4
72189: PPUSH
72190: CALL_OW 380
// un := CreateHuman ;
72194: LD_ADDR_VAR 0 14
72198: PUSH
72199: CALL_OW 44
72203: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72204: LD_ADDR_VAR 0 7
72208: PUSH
72209: LD_VAR 0 7
72213: PPUSH
72214: LD_INT 1
72216: PPUSH
72217: LD_VAR 0 14
72221: PPUSH
72222: CALL_OW 2
72226: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72227: LD_VAR 0 14
72231: PPUSH
72232: LD_VAR 0 1
72236: PPUSH
72237: CALL_OW 250
72241: PPUSH
72242: LD_VAR 0 1
72246: PPUSH
72247: CALL_OW 251
72251: PPUSH
72252: LD_INT 10
72254: PPUSH
72255: LD_INT 0
72257: PPUSH
72258: CALL_OW 50
// continue ;
72262: GO 72163
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
72264: LD_VAR 0 12
72268: PUSH
72269: LD_INT 1
72271: ARRAY
72272: PPUSH
72273: CALL_OW 313
72277: PUSH
72278: LD_VAR 0 12
72282: PUSH
72283: LD_INT 1
72285: ARRAY
72286: PPUSH
72287: CALL_OW 266
72291: PUSH
72292: LD_INT 32
72294: PUSH
72295: LD_INT 31
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: IN
72302: AND
72303: PUSH
72304: LD_VAR 0 12
72308: PUSH
72309: LD_INT 1
72311: ARRAY
72312: PPUSH
72313: CALL_OW 313
72317: PUSH
72318: LD_INT 6
72320: EQUAL
72321: OR
72322: IFFALSE 72342
// f := Delete ( f , 1 ) ;
72324: LD_ADDR_VAR 0 12
72328: PUSH
72329: LD_VAR 0 12
72333: PPUSH
72334: LD_INT 1
72336: PPUSH
72337: CALL_OW 3
72341: ST_TO_ADDR
// if not f then
72342: LD_VAR 0 12
72346: NOT
72347: IFFALSE 72365
// begin x := x + 2 ;
72349: LD_ADDR_VAR 0 13
72353: PUSH
72354: LD_VAR 0 13
72358: PUSH
72359: LD_INT 2
72361: PLUS
72362: ST_TO_ADDR
// continue ;
72363: GO 72163
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
72365: LD_VAR 0 12
72369: PUSH
72370: LD_INT 1
72372: ARRAY
72373: PPUSH
72374: CALL_OW 266
72378: PUSH
72379: LD_INT 5
72381: EQUAL
72382: IFFALSE 72456
// begin if UnitsInside ( f [ 1 ] ) < 3 then
72384: LD_VAR 0 12
72388: PUSH
72389: LD_INT 1
72391: ARRAY
72392: PPUSH
72393: CALL_OW 313
72397: PUSH
72398: LD_INT 3
72400: LESS
72401: IFFALSE 72437
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72403: LD_INT 0
72405: PPUSH
72406: LD_INT 5
72408: PUSH
72409: LD_INT 8
72411: PUSH
72412: LD_INT 9
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: LIST
72419: PUSH
72420: LD_VAR 0 17
72424: ARRAY
72425: PPUSH
72426: LD_VAR 0 4
72430: PPUSH
72431: CALL_OW 380
72435: GO 72454
// PrepareHuman ( false , i , skill ) ;
72437: LD_INT 0
72439: PPUSH
72440: LD_VAR 0 8
72444: PPUSH
72445: LD_VAR 0 4
72449: PPUSH
72450: CALL_OW 380
// end else
72454: GO 72473
// PrepareHuman ( false , i , skill ) ;
72456: LD_INT 0
72458: PPUSH
72459: LD_VAR 0 8
72463: PPUSH
72464: LD_VAR 0 4
72468: PPUSH
72469: CALL_OW 380
// un := CreateHuman ;
72473: LD_ADDR_VAR 0 14
72477: PUSH
72478: CALL_OW 44
72482: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72483: LD_ADDR_VAR 0 7
72487: PUSH
72488: LD_VAR 0 7
72492: PPUSH
72493: LD_INT 1
72495: PPUSH
72496: LD_VAR 0 14
72500: PPUSH
72501: CALL_OW 2
72505: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
72506: LD_VAR 0 14
72510: PPUSH
72511: LD_VAR 0 12
72515: PUSH
72516: LD_INT 1
72518: ARRAY
72519: PPUSH
72520: CALL_OW 52
// end ;
72524: GO 72163
72526: POP
72527: POP
// end ;
72528: GO 71465
72530: POP
72531: POP
// result := result ^ buildings ;
72532: LD_ADDR_VAR 0 7
72536: PUSH
72537: LD_VAR 0 7
72541: PUSH
72542: LD_VAR 0 18
72546: ADD
72547: ST_TO_ADDR
// end else
72548: GO 72691
// begin for i = 1 to personel do
72550: LD_ADDR_VAR 0 8
72554: PUSH
72555: DOUBLE
72556: LD_INT 1
72558: DEC
72559: ST_TO_ADDR
72560: LD_VAR 0 6
72564: PUSH
72565: FOR_TO
72566: IFFALSE 72689
// begin if i > 4 then
72568: LD_VAR 0 8
72572: PUSH
72573: LD_INT 4
72575: GREATER
72576: IFFALSE 72580
// break ;
72578: GO 72689
// x := personel [ i ] ;
72580: LD_ADDR_VAR 0 13
72584: PUSH
72585: LD_VAR 0 6
72589: PUSH
72590: LD_VAR 0 8
72594: ARRAY
72595: ST_TO_ADDR
// if x = - 1 then
72596: LD_VAR 0 13
72600: PUSH
72601: LD_INT 1
72603: NEG
72604: EQUAL
72605: IFFALSE 72609
// continue ;
72607: GO 72565
// PrepareHuman ( false , i , skill ) ;
72609: LD_INT 0
72611: PPUSH
72612: LD_VAR 0 8
72616: PPUSH
72617: LD_VAR 0 4
72621: PPUSH
72622: CALL_OW 380
// un := CreateHuman ;
72626: LD_ADDR_VAR 0 14
72630: PUSH
72631: CALL_OW 44
72635: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72636: LD_VAR 0 14
72640: PPUSH
72641: LD_VAR 0 1
72645: PPUSH
72646: CALL_OW 250
72650: PPUSH
72651: LD_VAR 0 1
72655: PPUSH
72656: CALL_OW 251
72660: PPUSH
72661: LD_INT 10
72663: PPUSH
72664: LD_INT 0
72666: PPUSH
72667: CALL_OW 50
// result := result ^ un ;
72671: LD_ADDR_VAR 0 7
72675: PUSH
72676: LD_VAR 0 7
72680: PUSH
72681: LD_VAR 0 14
72685: ADD
72686: ST_TO_ADDR
// end ;
72687: GO 72565
72689: POP
72690: POP
// end ; end ;
72691: LD_VAR 0 7
72695: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
72696: LD_INT 0
72698: PPUSH
72699: PPUSH
72700: PPUSH
72701: PPUSH
72702: PPUSH
72703: PPUSH
72704: PPUSH
72705: PPUSH
72706: PPUSH
72707: PPUSH
72708: PPUSH
72709: PPUSH
72710: PPUSH
72711: PPUSH
72712: PPUSH
72713: PPUSH
// result := false ;
72714: LD_ADDR_VAR 0 3
72718: PUSH
72719: LD_INT 0
72721: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
72722: LD_VAR 0 1
72726: NOT
72727: PUSH
72728: LD_VAR 0 1
72732: PPUSH
72733: CALL_OW 266
72737: PUSH
72738: LD_INT 32
72740: PUSH
72741: LD_INT 33
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: IN
72748: NOT
72749: OR
72750: IFFALSE 72754
// exit ;
72752: GO 73890
// nat := GetNation ( tower ) ;
72754: LD_ADDR_VAR 0 12
72758: PUSH
72759: LD_VAR 0 1
72763: PPUSH
72764: CALL_OW 248
72768: ST_TO_ADDR
// side := GetSide ( tower ) ;
72769: LD_ADDR_VAR 0 16
72773: PUSH
72774: LD_VAR 0 1
72778: PPUSH
72779: CALL_OW 255
72783: ST_TO_ADDR
// x := GetX ( tower ) ;
72784: LD_ADDR_VAR 0 10
72788: PUSH
72789: LD_VAR 0 1
72793: PPUSH
72794: CALL_OW 250
72798: ST_TO_ADDR
// y := GetY ( tower ) ;
72799: LD_ADDR_VAR 0 11
72803: PUSH
72804: LD_VAR 0 1
72808: PPUSH
72809: CALL_OW 251
72813: ST_TO_ADDR
// if not x or not y then
72814: LD_VAR 0 10
72818: NOT
72819: PUSH
72820: LD_VAR 0 11
72824: NOT
72825: OR
72826: IFFALSE 72830
// exit ;
72828: GO 73890
// weapon := 0 ;
72830: LD_ADDR_VAR 0 18
72834: PUSH
72835: LD_INT 0
72837: ST_TO_ADDR
// fac_list := [ ] ;
72838: LD_ADDR_VAR 0 17
72842: PUSH
72843: EMPTY
72844: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
72845: LD_ADDR_VAR 0 6
72849: PUSH
72850: LD_VAR 0 1
72854: PPUSH
72855: CALL_OW 274
72859: PPUSH
72860: LD_VAR 0 2
72864: PPUSH
72865: CALL 70468 0 2
72869: PPUSH
72870: LD_INT 30
72872: PUSH
72873: LD_INT 3
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PPUSH
72880: CALL_OW 72
72884: ST_TO_ADDR
// if not factories then
72885: LD_VAR 0 6
72889: NOT
72890: IFFALSE 72894
// exit ;
72892: GO 73890
// for i in factories do
72894: LD_ADDR_VAR 0 8
72898: PUSH
72899: LD_VAR 0 6
72903: PUSH
72904: FOR_IN
72905: IFFALSE 72930
// fac_list := fac_list union AvailableWeaponList ( i ) ;
72907: LD_ADDR_VAR 0 17
72911: PUSH
72912: LD_VAR 0 17
72916: PUSH
72917: LD_VAR 0 8
72921: PPUSH
72922: CALL_OW 478
72926: UNION
72927: ST_TO_ADDR
72928: GO 72904
72930: POP
72931: POP
// if not fac_list then
72932: LD_VAR 0 17
72936: NOT
72937: IFFALSE 72941
// exit ;
72939: GO 73890
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
72941: LD_ADDR_VAR 0 5
72945: PUSH
72946: LD_INT 4
72948: PUSH
72949: LD_INT 5
72951: PUSH
72952: LD_INT 9
72954: PUSH
72955: LD_INT 10
72957: PUSH
72958: LD_INT 6
72960: PUSH
72961: LD_INT 7
72963: PUSH
72964: LD_INT 11
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: LIST
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 27
72978: PUSH
72979: LD_INT 28
72981: PUSH
72982: LD_INT 26
72984: PUSH
72985: LD_INT 30
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: PUSH
72994: LD_INT 43
72996: PUSH
72997: LD_INT 44
72999: PUSH
73000: LD_INT 46
73002: PUSH
73003: LD_INT 45
73005: PUSH
73006: LD_INT 47
73008: PUSH
73009: LD_INT 49
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: LIST
73024: PUSH
73025: LD_VAR 0 12
73029: ARRAY
73030: ST_TO_ADDR
// for i in list do
73031: LD_ADDR_VAR 0 8
73035: PUSH
73036: LD_VAR 0 5
73040: PUSH
73041: FOR_IN
73042: IFFALSE 73075
// if not i in fac_list then
73044: LD_VAR 0 8
73048: PUSH
73049: LD_VAR 0 17
73053: IN
73054: NOT
73055: IFFALSE 73073
// list := list diff i ;
73057: LD_ADDR_VAR 0 5
73061: PUSH
73062: LD_VAR 0 5
73066: PUSH
73067: LD_VAR 0 8
73071: DIFF
73072: ST_TO_ADDR
73073: GO 73041
73075: POP
73076: POP
// if not list then
73077: LD_VAR 0 5
73081: NOT
73082: IFFALSE 73086
// exit ;
73084: GO 73890
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73086: LD_VAR 0 12
73090: PUSH
73091: LD_INT 3
73093: EQUAL
73094: PUSH
73095: LD_INT 49
73097: PUSH
73098: LD_VAR 0 5
73102: IN
73103: AND
73104: PUSH
73105: LD_INT 31
73107: PPUSH
73108: LD_VAR 0 16
73112: PPUSH
73113: CALL_OW 321
73117: PUSH
73118: LD_INT 2
73120: EQUAL
73121: AND
73122: IFFALSE 73182
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73124: LD_INT 22
73126: PUSH
73127: LD_VAR 0 16
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 35
73138: PUSH
73139: LD_INT 49
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 91
73148: PUSH
73149: LD_VAR 0 1
73153: PUSH
73154: LD_INT 10
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: LIST
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: LIST
73166: PPUSH
73167: CALL_OW 69
73171: NOT
73172: IFFALSE 73182
// weapon := ru_time_lapser ;
73174: LD_ADDR_VAR 0 18
73178: PUSH
73179: LD_INT 49
73181: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73182: LD_VAR 0 12
73186: PUSH
73187: LD_INT 1
73189: PUSH
73190: LD_INT 2
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: IN
73197: PUSH
73198: LD_INT 11
73200: PUSH
73201: LD_VAR 0 5
73205: IN
73206: PUSH
73207: LD_INT 30
73209: PUSH
73210: LD_VAR 0 5
73214: IN
73215: OR
73216: AND
73217: PUSH
73218: LD_INT 6
73220: PPUSH
73221: LD_VAR 0 16
73225: PPUSH
73226: CALL_OW 321
73230: PUSH
73231: LD_INT 2
73233: EQUAL
73234: AND
73235: IFFALSE 73400
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
73237: LD_INT 22
73239: PUSH
73240: LD_VAR 0 16
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 2
73251: PUSH
73252: LD_INT 35
73254: PUSH
73255: LD_INT 11
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: LD_INT 35
73264: PUSH
73265: LD_INT 30
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: LIST
73276: PUSH
73277: LD_INT 91
73279: PUSH
73280: LD_VAR 0 1
73284: PUSH
73285: LD_INT 18
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: LIST
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: LIST
73297: PPUSH
73298: CALL_OW 69
73302: NOT
73303: PUSH
73304: LD_INT 22
73306: PUSH
73307: LD_VAR 0 16
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 2
73318: PUSH
73319: LD_INT 30
73321: PUSH
73322: LD_INT 32
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 30
73331: PUSH
73332: LD_INT 33
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 91
73346: PUSH
73347: LD_VAR 0 1
73351: PUSH
73352: LD_INT 12
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: LIST
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: LIST
73364: PUSH
73365: EMPTY
73366: LIST
73367: PPUSH
73368: CALL_OW 69
73372: PUSH
73373: LD_INT 2
73375: GREATER
73376: AND
73377: IFFALSE 73400
// weapon := [ us_radar , ar_radar ] [ nat ] ;
73379: LD_ADDR_VAR 0 18
73383: PUSH
73384: LD_INT 11
73386: PUSH
73387: LD_INT 30
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_VAR 0 12
73398: ARRAY
73399: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
73400: LD_VAR 0 18
73404: NOT
73405: PUSH
73406: LD_INT 40
73408: PPUSH
73409: LD_VAR 0 16
73413: PPUSH
73414: CALL_OW 321
73418: PUSH
73419: LD_INT 2
73421: EQUAL
73422: AND
73423: PUSH
73424: LD_INT 7
73426: PUSH
73427: LD_VAR 0 5
73431: IN
73432: PUSH
73433: LD_INT 28
73435: PUSH
73436: LD_VAR 0 5
73440: IN
73441: OR
73442: PUSH
73443: LD_INT 45
73445: PUSH
73446: LD_VAR 0 5
73450: IN
73451: OR
73452: AND
73453: IFFALSE 73707
// begin hex := GetHexInfo ( x , y ) ;
73455: LD_ADDR_VAR 0 4
73459: PUSH
73460: LD_VAR 0 10
73464: PPUSH
73465: LD_VAR 0 11
73469: PPUSH
73470: CALL_OW 546
73474: ST_TO_ADDR
// if hex [ 1 ] then
73475: LD_VAR 0 4
73479: PUSH
73480: LD_INT 1
73482: ARRAY
73483: IFFALSE 73487
// exit ;
73485: GO 73890
// height := hex [ 2 ] ;
73487: LD_ADDR_VAR 0 15
73491: PUSH
73492: LD_VAR 0 4
73496: PUSH
73497: LD_INT 2
73499: ARRAY
73500: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
73501: LD_ADDR_VAR 0 14
73505: PUSH
73506: LD_INT 0
73508: PUSH
73509: LD_INT 2
73511: PUSH
73512: LD_INT 3
73514: PUSH
73515: LD_INT 5
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: ST_TO_ADDR
// for i in tmp do
73524: LD_ADDR_VAR 0 8
73528: PUSH
73529: LD_VAR 0 14
73533: PUSH
73534: FOR_IN
73535: IFFALSE 73705
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
73537: LD_ADDR_VAR 0 9
73541: PUSH
73542: LD_VAR 0 10
73546: PPUSH
73547: LD_VAR 0 8
73551: PPUSH
73552: LD_INT 5
73554: PPUSH
73555: CALL_OW 272
73559: PUSH
73560: LD_VAR 0 11
73564: PPUSH
73565: LD_VAR 0 8
73569: PPUSH
73570: LD_INT 5
73572: PPUSH
73573: CALL_OW 273
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
73582: LD_VAR 0 9
73586: PUSH
73587: LD_INT 1
73589: ARRAY
73590: PPUSH
73591: LD_VAR 0 9
73595: PUSH
73596: LD_INT 2
73598: ARRAY
73599: PPUSH
73600: CALL_OW 488
73604: IFFALSE 73703
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
73606: LD_ADDR_VAR 0 4
73610: PUSH
73611: LD_VAR 0 9
73615: PUSH
73616: LD_INT 1
73618: ARRAY
73619: PPUSH
73620: LD_VAR 0 9
73624: PUSH
73625: LD_INT 2
73627: ARRAY
73628: PPUSH
73629: CALL_OW 546
73633: ST_TO_ADDR
// if hex [ 1 ] then
73634: LD_VAR 0 4
73638: PUSH
73639: LD_INT 1
73641: ARRAY
73642: IFFALSE 73646
// continue ;
73644: GO 73534
// h := hex [ 2 ] ;
73646: LD_ADDR_VAR 0 13
73650: PUSH
73651: LD_VAR 0 4
73655: PUSH
73656: LD_INT 2
73658: ARRAY
73659: ST_TO_ADDR
// if h + 7 < height then
73660: LD_VAR 0 13
73664: PUSH
73665: LD_INT 7
73667: PLUS
73668: PUSH
73669: LD_VAR 0 15
73673: LESS
73674: IFFALSE 73703
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
73676: LD_ADDR_VAR 0 18
73680: PUSH
73681: LD_INT 7
73683: PUSH
73684: LD_INT 28
73686: PUSH
73687: LD_INT 45
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: LIST
73694: PUSH
73695: LD_VAR 0 12
73699: ARRAY
73700: ST_TO_ADDR
// break ;
73701: GO 73705
// end ; end ; end ;
73703: GO 73534
73705: POP
73706: POP
// end ; if not weapon then
73707: LD_VAR 0 18
73711: NOT
73712: IFFALSE 73772
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
73714: LD_ADDR_VAR 0 5
73718: PUSH
73719: LD_VAR 0 5
73723: PUSH
73724: LD_INT 11
73726: PUSH
73727: LD_INT 30
73729: PUSH
73730: LD_INT 49
73732: PUSH
73733: EMPTY
73734: LIST
73735: LIST
73736: LIST
73737: DIFF
73738: ST_TO_ADDR
// if not list then
73739: LD_VAR 0 5
73743: NOT
73744: IFFALSE 73748
// exit ;
73746: GO 73890
// weapon := list [ rand ( 1 , list ) ] ;
73748: LD_ADDR_VAR 0 18
73752: PUSH
73753: LD_VAR 0 5
73757: PUSH
73758: LD_INT 1
73760: PPUSH
73761: LD_VAR 0 5
73765: PPUSH
73766: CALL_OW 12
73770: ARRAY
73771: ST_TO_ADDR
// end ; if weapon then
73772: LD_VAR 0 18
73776: IFFALSE 73890
// begin tmp := CostOfWeapon ( weapon ) ;
73778: LD_ADDR_VAR 0 14
73782: PUSH
73783: LD_VAR 0 18
73787: PPUSH
73788: CALL_OW 451
73792: ST_TO_ADDR
// j := GetBase ( tower ) ;
73793: LD_ADDR_VAR 0 9
73797: PUSH
73798: LD_VAR 0 1
73802: PPUSH
73803: CALL_OW 274
73807: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
73808: LD_VAR 0 9
73812: PPUSH
73813: LD_INT 1
73815: PPUSH
73816: CALL_OW 275
73820: PUSH
73821: LD_VAR 0 14
73825: PUSH
73826: LD_INT 1
73828: ARRAY
73829: GREATEREQUAL
73830: PUSH
73831: LD_VAR 0 9
73835: PPUSH
73836: LD_INT 2
73838: PPUSH
73839: CALL_OW 275
73843: PUSH
73844: LD_VAR 0 14
73848: PUSH
73849: LD_INT 2
73851: ARRAY
73852: GREATEREQUAL
73853: AND
73854: PUSH
73855: LD_VAR 0 9
73859: PPUSH
73860: LD_INT 3
73862: PPUSH
73863: CALL_OW 275
73867: PUSH
73868: LD_VAR 0 14
73872: PUSH
73873: LD_INT 3
73875: ARRAY
73876: GREATEREQUAL
73877: AND
73878: IFFALSE 73890
// result := weapon ;
73880: LD_ADDR_VAR 0 3
73884: PUSH
73885: LD_VAR 0 18
73889: ST_TO_ADDR
// end ; end ;
73890: LD_VAR 0 3
73894: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
73895: LD_INT 0
73897: PPUSH
73898: PPUSH
// result := true ;
73899: LD_ADDR_VAR 0 3
73903: PUSH
73904: LD_INT 1
73906: ST_TO_ADDR
// if array1 = array2 then
73907: LD_VAR 0 1
73911: PUSH
73912: LD_VAR 0 2
73916: EQUAL
73917: IFFALSE 73977
// begin for i = 1 to array1 do
73919: LD_ADDR_VAR 0 4
73923: PUSH
73924: DOUBLE
73925: LD_INT 1
73927: DEC
73928: ST_TO_ADDR
73929: LD_VAR 0 1
73933: PUSH
73934: FOR_TO
73935: IFFALSE 73973
// if array1 [ i ] <> array2 [ i ] then
73937: LD_VAR 0 1
73941: PUSH
73942: LD_VAR 0 4
73946: ARRAY
73947: PUSH
73948: LD_VAR 0 2
73952: PUSH
73953: LD_VAR 0 4
73957: ARRAY
73958: NONEQUAL
73959: IFFALSE 73971
// begin result := false ;
73961: LD_ADDR_VAR 0 3
73965: PUSH
73966: LD_INT 0
73968: ST_TO_ADDR
// break ;
73969: GO 73973
// end ;
73971: GO 73934
73973: POP
73974: POP
// end else
73975: GO 73985
// result := false ;
73977: LD_ADDR_VAR 0 3
73981: PUSH
73982: LD_INT 0
73984: ST_TO_ADDR
// end ;
73985: LD_VAR 0 3
73989: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
73990: LD_INT 0
73992: PPUSH
73993: PPUSH
73994: PPUSH
// pom := GetBase ( fac ) ;
73995: LD_ADDR_VAR 0 5
73999: PUSH
74000: LD_VAR 0 1
74004: PPUSH
74005: CALL_OW 274
74009: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74010: LD_ADDR_VAR 0 4
74014: PUSH
74015: LD_VAR 0 2
74019: PUSH
74020: LD_INT 1
74022: ARRAY
74023: PPUSH
74024: LD_VAR 0 2
74028: PUSH
74029: LD_INT 2
74031: ARRAY
74032: PPUSH
74033: LD_VAR 0 2
74037: PUSH
74038: LD_INT 3
74040: ARRAY
74041: PPUSH
74042: LD_VAR 0 2
74046: PUSH
74047: LD_INT 4
74049: ARRAY
74050: PPUSH
74051: CALL_OW 449
74055: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74056: LD_ADDR_VAR 0 3
74060: PUSH
74061: LD_VAR 0 5
74065: PPUSH
74066: LD_INT 1
74068: PPUSH
74069: CALL_OW 275
74073: PUSH
74074: LD_VAR 0 4
74078: PUSH
74079: LD_INT 1
74081: ARRAY
74082: GREATEREQUAL
74083: PUSH
74084: LD_VAR 0 5
74088: PPUSH
74089: LD_INT 2
74091: PPUSH
74092: CALL_OW 275
74096: PUSH
74097: LD_VAR 0 4
74101: PUSH
74102: LD_INT 2
74104: ARRAY
74105: GREATEREQUAL
74106: AND
74107: PUSH
74108: LD_VAR 0 5
74112: PPUSH
74113: LD_INT 3
74115: PPUSH
74116: CALL_OW 275
74120: PUSH
74121: LD_VAR 0 4
74125: PUSH
74126: LD_INT 3
74128: ARRAY
74129: GREATEREQUAL
74130: AND
74131: ST_TO_ADDR
// end ;
74132: LD_VAR 0 3
74136: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74137: LD_INT 0
74139: PPUSH
74140: PPUSH
74141: PPUSH
74142: PPUSH
// pom := GetBase ( building ) ;
74143: LD_ADDR_VAR 0 3
74147: PUSH
74148: LD_VAR 0 1
74152: PPUSH
74153: CALL_OW 274
74157: ST_TO_ADDR
// if not pom then
74158: LD_VAR 0 3
74162: NOT
74163: IFFALSE 74167
// exit ;
74165: GO 74337
// btype := GetBType ( building ) ;
74167: LD_ADDR_VAR 0 5
74171: PUSH
74172: LD_VAR 0 1
74176: PPUSH
74177: CALL_OW 266
74181: ST_TO_ADDR
// if btype = b_armoury then
74182: LD_VAR 0 5
74186: PUSH
74187: LD_INT 4
74189: EQUAL
74190: IFFALSE 74200
// btype := b_barracks ;
74192: LD_ADDR_VAR 0 5
74196: PUSH
74197: LD_INT 5
74199: ST_TO_ADDR
// if btype = b_depot then
74200: LD_VAR 0 5
74204: PUSH
74205: LD_INT 0
74207: EQUAL
74208: IFFALSE 74218
// btype := b_warehouse ;
74210: LD_ADDR_VAR 0 5
74214: PUSH
74215: LD_INT 1
74217: ST_TO_ADDR
// if btype = b_workshop then
74218: LD_VAR 0 5
74222: PUSH
74223: LD_INT 2
74225: EQUAL
74226: IFFALSE 74236
// btype := b_factory ;
74228: LD_ADDR_VAR 0 5
74232: PUSH
74233: LD_INT 3
74235: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74236: LD_ADDR_VAR 0 4
74240: PUSH
74241: LD_VAR 0 5
74245: PPUSH
74246: LD_VAR 0 1
74250: PPUSH
74251: CALL_OW 248
74255: PPUSH
74256: CALL_OW 450
74260: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74261: LD_ADDR_VAR 0 2
74265: PUSH
74266: LD_VAR 0 3
74270: PPUSH
74271: LD_INT 1
74273: PPUSH
74274: CALL_OW 275
74278: PUSH
74279: LD_VAR 0 4
74283: PUSH
74284: LD_INT 1
74286: ARRAY
74287: GREATEREQUAL
74288: PUSH
74289: LD_VAR 0 3
74293: PPUSH
74294: LD_INT 2
74296: PPUSH
74297: CALL_OW 275
74301: PUSH
74302: LD_VAR 0 4
74306: PUSH
74307: LD_INT 2
74309: ARRAY
74310: GREATEREQUAL
74311: AND
74312: PUSH
74313: LD_VAR 0 3
74317: PPUSH
74318: LD_INT 3
74320: PPUSH
74321: CALL_OW 275
74325: PUSH
74326: LD_VAR 0 4
74330: PUSH
74331: LD_INT 3
74333: ARRAY
74334: GREATEREQUAL
74335: AND
74336: ST_TO_ADDR
// end ;
74337: LD_VAR 0 2
74341: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
74342: LD_INT 0
74344: PPUSH
74345: PPUSH
74346: PPUSH
// pom := GetBase ( building ) ;
74347: LD_ADDR_VAR 0 4
74351: PUSH
74352: LD_VAR 0 1
74356: PPUSH
74357: CALL_OW 274
74361: ST_TO_ADDR
// if not pom then
74362: LD_VAR 0 4
74366: NOT
74367: IFFALSE 74371
// exit ;
74369: GO 74472
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74371: LD_ADDR_VAR 0 5
74375: PUSH
74376: LD_VAR 0 2
74380: PPUSH
74381: LD_VAR 0 1
74385: PPUSH
74386: CALL_OW 248
74390: PPUSH
74391: CALL_OW 450
74395: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74396: LD_ADDR_VAR 0 3
74400: PUSH
74401: LD_VAR 0 4
74405: PPUSH
74406: LD_INT 1
74408: PPUSH
74409: CALL_OW 275
74413: PUSH
74414: LD_VAR 0 5
74418: PUSH
74419: LD_INT 1
74421: ARRAY
74422: GREATEREQUAL
74423: PUSH
74424: LD_VAR 0 4
74428: PPUSH
74429: LD_INT 2
74431: PPUSH
74432: CALL_OW 275
74436: PUSH
74437: LD_VAR 0 5
74441: PUSH
74442: LD_INT 2
74444: ARRAY
74445: GREATEREQUAL
74446: AND
74447: PUSH
74448: LD_VAR 0 4
74452: PPUSH
74453: LD_INT 3
74455: PPUSH
74456: CALL_OW 275
74460: PUSH
74461: LD_VAR 0 5
74465: PUSH
74466: LD_INT 3
74468: ARRAY
74469: GREATEREQUAL
74470: AND
74471: ST_TO_ADDR
// end ;
74472: LD_VAR 0 3
74476: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
74477: LD_INT 0
74479: PPUSH
74480: PPUSH
74481: PPUSH
74482: PPUSH
74483: PPUSH
74484: PPUSH
74485: PPUSH
74486: PPUSH
74487: PPUSH
74488: PPUSH
// result := false ;
74489: LD_ADDR_VAR 0 6
74493: PUSH
74494: LD_INT 0
74496: ST_TO_ADDR
// if not base or not btype or not x or not y then
74497: LD_VAR 0 1
74501: NOT
74502: PUSH
74503: LD_VAR 0 2
74507: NOT
74508: OR
74509: PUSH
74510: LD_VAR 0 3
74514: NOT
74515: OR
74516: PUSH
74517: LD_VAR 0 4
74521: NOT
74522: OR
74523: IFFALSE 74527
// exit ;
74525: GO 75118
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
74527: LD_ADDR_VAR 0 12
74531: PUSH
74532: LD_VAR 0 2
74536: PPUSH
74537: LD_VAR 0 3
74541: PPUSH
74542: LD_VAR 0 4
74546: PPUSH
74547: LD_VAR 0 5
74551: PPUSH
74552: LD_VAR 0 1
74556: PUSH
74557: LD_INT 1
74559: ARRAY
74560: PPUSH
74561: CALL_OW 248
74565: PPUSH
74566: LD_INT 0
74568: PPUSH
74569: CALL 75955 0 6
74573: ST_TO_ADDR
// if not hexes then
74574: LD_VAR 0 12
74578: NOT
74579: IFFALSE 74583
// exit ;
74581: GO 75118
// for i = 1 to hexes do
74583: LD_ADDR_VAR 0 7
74587: PUSH
74588: DOUBLE
74589: LD_INT 1
74591: DEC
74592: ST_TO_ADDR
74593: LD_VAR 0 12
74597: PUSH
74598: FOR_TO
74599: IFFALSE 75116
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74601: LD_ADDR_VAR 0 11
74605: PUSH
74606: LD_VAR 0 12
74610: PUSH
74611: LD_VAR 0 7
74615: ARRAY
74616: PUSH
74617: LD_INT 1
74619: ARRAY
74620: PPUSH
74621: LD_VAR 0 12
74625: PUSH
74626: LD_VAR 0 7
74630: ARRAY
74631: PUSH
74632: LD_INT 2
74634: ARRAY
74635: PPUSH
74636: CALL_OW 428
74640: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
74641: LD_VAR 0 12
74645: PUSH
74646: LD_VAR 0 7
74650: ARRAY
74651: PUSH
74652: LD_INT 1
74654: ARRAY
74655: PPUSH
74656: LD_VAR 0 12
74660: PUSH
74661: LD_VAR 0 7
74665: ARRAY
74666: PUSH
74667: LD_INT 2
74669: ARRAY
74670: PPUSH
74671: CALL_OW 351
74675: PUSH
74676: LD_VAR 0 12
74680: PUSH
74681: LD_VAR 0 7
74685: ARRAY
74686: PUSH
74687: LD_INT 1
74689: ARRAY
74690: PPUSH
74691: LD_VAR 0 12
74695: PUSH
74696: LD_VAR 0 7
74700: ARRAY
74701: PUSH
74702: LD_INT 2
74704: ARRAY
74705: PPUSH
74706: CALL_OW 488
74710: NOT
74711: OR
74712: PUSH
74713: LD_VAR 0 11
74717: PPUSH
74718: CALL_OW 247
74722: PUSH
74723: LD_INT 3
74725: EQUAL
74726: OR
74727: IFFALSE 74733
// exit ;
74729: POP
74730: POP
74731: GO 75118
// if not tmp then
74733: LD_VAR 0 11
74737: NOT
74738: IFFALSE 74742
// continue ;
74740: GO 74598
// result := true ;
74742: LD_ADDR_VAR 0 6
74746: PUSH
74747: LD_INT 1
74749: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74750: LD_ADDR_VAR 0 15
74754: PUSH
74755: LD_INT 22
74757: PUSH
74758: LD_VAR 0 11
74762: PPUSH
74763: CALL_OW 255
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 2
74774: PUSH
74775: LD_INT 30
74777: PUSH
74778: LD_INT 0
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: LD_INT 30
74787: PUSH
74788: LD_INT 1
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: LIST
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PPUSH
74804: CALL_OW 69
74808: ST_TO_ADDR
// if dep then
74809: LD_VAR 0 15
74813: IFFALSE 74949
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
74815: LD_ADDR_VAR 0 14
74819: PUSH
74820: LD_VAR 0 15
74824: PUSH
74825: LD_INT 1
74827: ARRAY
74828: PPUSH
74829: CALL_OW 250
74833: PPUSH
74834: LD_VAR 0 15
74838: PUSH
74839: LD_INT 1
74841: ARRAY
74842: PPUSH
74843: CALL_OW 254
74847: PPUSH
74848: LD_INT 5
74850: PPUSH
74851: CALL_OW 272
74855: PUSH
74856: LD_VAR 0 15
74860: PUSH
74861: LD_INT 1
74863: ARRAY
74864: PPUSH
74865: CALL_OW 251
74869: PPUSH
74870: LD_VAR 0 15
74874: PUSH
74875: LD_INT 1
74877: ARRAY
74878: PPUSH
74879: CALL_OW 254
74883: PPUSH
74884: LD_INT 5
74886: PPUSH
74887: CALL_OW 273
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
74896: LD_VAR 0 14
74900: PUSH
74901: LD_INT 1
74903: ARRAY
74904: PPUSH
74905: LD_VAR 0 14
74909: PUSH
74910: LD_INT 2
74912: ARRAY
74913: PPUSH
74914: CALL_OW 488
74918: IFFALSE 74949
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
74920: LD_VAR 0 11
74924: PPUSH
74925: LD_VAR 0 14
74929: PUSH
74930: LD_INT 1
74932: ARRAY
74933: PPUSH
74934: LD_VAR 0 14
74938: PUSH
74939: LD_INT 2
74941: ARRAY
74942: PPUSH
74943: CALL_OW 111
// continue ;
74947: GO 74598
// end ; end ; r := GetDir ( tmp ) ;
74949: LD_ADDR_VAR 0 13
74953: PUSH
74954: LD_VAR 0 11
74958: PPUSH
74959: CALL_OW 254
74963: ST_TO_ADDR
// if r = 5 then
74964: LD_VAR 0 13
74968: PUSH
74969: LD_INT 5
74971: EQUAL
74972: IFFALSE 74982
// r := 0 ;
74974: LD_ADDR_VAR 0 13
74978: PUSH
74979: LD_INT 0
74981: ST_TO_ADDR
// for j = r to 5 do
74982: LD_ADDR_VAR 0 8
74986: PUSH
74987: DOUBLE
74988: LD_VAR 0 13
74992: DEC
74993: ST_TO_ADDR
74994: LD_INT 5
74996: PUSH
74997: FOR_TO
74998: IFFALSE 75112
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75000: LD_ADDR_VAR 0 9
75004: PUSH
75005: LD_VAR 0 11
75009: PPUSH
75010: CALL_OW 250
75014: PPUSH
75015: LD_VAR 0 8
75019: PPUSH
75020: LD_INT 2
75022: PPUSH
75023: CALL_OW 272
75027: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75028: LD_ADDR_VAR 0 10
75032: PUSH
75033: LD_VAR 0 11
75037: PPUSH
75038: CALL_OW 251
75042: PPUSH
75043: LD_VAR 0 8
75047: PPUSH
75048: LD_INT 2
75050: PPUSH
75051: CALL_OW 273
75055: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75056: LD_VAR 0 9
75060: PPUSH
75061: LD_VAR 0 10
75065: PPUSH
75066: CALL_OW 488
75070: PUSH
75071: LD_VAR 0 9
75075: PPUSH
75076: LD_VAR 0 10
75080: PPUSH
75081: CALL_OW 428
75085: NOT
75086: AND
75087: IFFALSE 75110
// begin ComMoveXY ( tmp , _x , _y ) ;
75089: LD_VAR 0 11
75093: PPUSH
75094: LD_VAR 0 9
75098: PPUSH
75099: LD_VAR 0 10
75103: PPUSH
75104: CALL_OW 111
// break ;
75108: GO 75112
// end ; end ;
75110: GO 74997
75112: POP
75113: POP
// end ;
75114: GO 74598
75116: POP
75117: POP
// end ;
75118: LD_VAR 0 6
75122: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
75123: LD_INT 0
75125: PPUSH
75126: PPUSH
75127: PPUSH
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
// result := false ;
75135: LD_ADDR_VAR 0 6
75139: PUSH
75140: LD_INT 0
75142: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
75143: LD_VAR 0 1
75147: NOT
75148: PUSH
75149: LD_VAR 0 1
75153: PPUSH
75154: CALL_OW 266
75158: PUSH
75159: LD_INT 0
75161: PUSH
75162: LD_INT 1
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: IN
75169: NOT
75170: OR
75171: PUSH
75172: LD_VAR 0 2
75176: NOT
75177: OR
75178: PUSH
75179: LD_VAR 0 5
75183: PUSH
75184: LD_INT 0
75186: PUSH
75187: LD_INT 1
75189: PUSH
75190: LD_INT 2
75192: PUSH
75193: LD_INT 3
75195: PUSH
75196: LD_INT 4
75198: PUSH
75199: LD_INT 5
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: IN
75210: NOT
75211: OR
75212: PUSH
75213: LD_VAR 0 3
75217: PPUSH
75218: LD_VAR 0 4
75222: PPUSH
75223: CALL_OW 488
75227: NOT
75228: OR
75229: IFFALSE 75233
// exit ;
75231: GO 75950
// pom := GetBase ( bdepot ) ;
75233: LD_ADDR_VAR 0 10
75237: PUSH
75238: LD_VAR 0 1
75242: PPUSH
75243: CALL_OW 274
75247: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
75248: LD_ADDR_VAR 0 11
75252: PUSH
75253: LD_VAR 0 2
75257: PPUSH
75258: LD_VAR 0 1
75262: PPUSH
75263: CALL_OW 248
75267: PPUSH
75268: CALL_OW 450
75272: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
75273: LD_VAR 0 10
75277: PPUSH
75278: LD_INT 1
75280: PPUSH
75281: CALL_OW 275
75285: PUSH
75286: LD_VAR 0 11
75290: PUSH
75291: LD_INT 1
75293: ARRAY
75294: GREATEREQUAL
75295: PUSH
75296: LD_VAR 0 10
75300: PPUSH
75301: LD_INT 2
75303: PPUSH
75304: CALL_OW 275
75308: PUSH
75309: LD_VAR 0 11
75313: PUSH
75314: LD_INT 2
75316: ARRAY
75317: GREATEREQUAL
75318: AND
75319: PUSH
75320: LD_VAR 0 10
75324: PPUSH
75325: LD_INT 3
75327: PPUSH
75328: CALL_OW 275
75332: PUSH
75333: LD_VAR 0 11
75337: PUSH
75338: LD_INT 3
75340: ARRAY
75341: GREATEREQUAL
75342: AND
75343: NOT
75344: IFFALSE 75348
// exit ;
75346: GO 75950
// if GetBType ( bdepot ) = b_depot then
75348: LD_VAR 0 1
75352: PPUSH
75353: CALL_OW 266
75357: PUSH
75358: LD_INT 0
75360: EQUAL
75361: IFFALSE 75373
// dist := 28 else
75363: LD_ADDR_VAR 0 14
75367: PUSH
75368: LD_INT 28
75370: ST_TO_ADDR
75371: GO 75381
// dist := 36 ;
75373: LD_ADDR_VAR 0 14
75377: PUSH
75378: LD_INT 36
75380: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
75381: LD_VAR 0 1
75385: PPUSH
75386: LD_VAR 0 3
75390: PPUSH
75391: LD_VAR 0 4
75395: PPUSH
75396: CALL_OW 297
75400: PUSH
75401: LD_VAR 0 14
75405: GREATER
75406: IFFALSE 75410
// exit ;
75408: GO 75950
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
75410: LD_ADDR_VAR 0 12
75414: PUSH
75415: LD_VAR 0 2
75419: PPUSH
75420: LD_VAR 0 3
75424: PPUSH
75425: LD_VAR 0 4
75429: PPUSH
75430: LD_VAR 0 5
75434: PPUSH
75435: LD_VAR 0 1
75439: PPUSH
75440: CALL_OW 248
75444: PPUSH
75445: LD_INT 0
75447: PPUSH
75448: CALL 75955 0 6
75452: ST_TO_ADDR
// if not hexes then
75453: LD_VAR 0 12
75457: NOT
75458: IFFALSE 75462
// exit ;
75460: GO 75950
// hex := GetHexInfo ( x , y ) ;
75462: LD_ADDR_VAR 0 15
75466: PUSH
75467: LD_VAR 0 3
75471: PPUSH
75472: LD_VAR 0 4
75476: PPUSH
75477: CALL_OW 546
75481: ST_TO_ADDR
// if hex [ 1 ] then
75482: LD_VAR 0 15
75486: PUSH
75487: LD_INT 1
75489: ARRAY
75490: IFFALSE 75494
// exit ;
75492: GO 75950
// height := hex [ 2 ] ;
75494: LD_ADDR_VAR 0 13
75498: PUSH
75499: LD_VAR 0 15
75503: PUSH
75504: LD_INT 2
75506: ARRAY
75507: ST_TO_ADDR
// for i = 1 to hexes do
75508: LD_ADDR_VAR 0 7
75512: PUSH
75513: DOUBLE
75514: LD_INT 1
75516: DEC
75517: ST_TO_ADDR
75518: LD_VAR 0 12
75522: PUSH
75523: FOR_TO
75524: IFFALSE 75854
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
75526: LD_VAR 0 12
75530: PUSH
75531: LD_VAR 0 7
75535: ARRAY
75536: PUSH
75537: LD_INT 1
75539: ARRAY
75540: PPUSH
75541: LD_VAR 0 12
75545: PUSH
75546: LD_VAR 0 7
75550: ARRAY
75551: PUSH
75552: LD_INT 2
75554: ARRAY
75555: PPUSH
75556: CALL_OW 488
75560: NOT
75561: PUSH
75562: LD_VAR 0 12
75566: PUSH
75567: LD_VAR 0 7
75571: ARRAY
75572: PUSH
75573: LD_INT 1
75575: ARRAY
75576: PPUSH
75577: LD_VAR 0 12
75581: PUSH
75582: LD_VAR 0 7
75586: ARRAY
75587: PUSH
75588: LD_INT 2
75590: ARRAY
75591: PPUSH
75592: CALL_OW 428
75596: PUSH
75597: LD_INT 0
75599: GREATER
75600: OR
75601: PUSH
75602: LD_VAR 0 12
75606: PUSH
75607: LD_VAR 0 7
75611: ARRAY
75612: PUSH
75613: LD_INT 1
75615: ARRAY
75616: PPUSH
75617: LD_VAR 0 12
75621: PUSH
75622: LD_VAR 0 7
75626: ARRAY
75627: PUSH
75628: LD_INT 2
75630: ARRAY
75631: PPUSH
75632: CALL_OW 351
75636: OR
75637: IFFALSE 75643
// exit ;
75639: POP
75640: POP
75641: GO 75950
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75643: LD_ADDR_VAR 0 8
75647: PUSH
75648: LD_VAR 0 12
75652: PUSH
75653: LD_VAR 0 7
75657: ARRAY
75658: PUSH
75659: LD_INT 1
75661: ARRAY
75662: PPUSH
75663: LD_VAR 0 12
75667: PUSH
75668: LD_VAR 0 7
75672: ARRAY
75673: PUSH
75674: LD_INT 2
75676: ARRAY
75677: PPUSH
75678: CALL_OW 546
75682: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
75683: LD_VAR 0 8
75687: PUSH
75688: LD_INT 1
75690: ARRAY
75691: PUSH
75692: LD_VAR 0 8
75696: PUSH
75697: LD_INT 2
75699: ARRAY
75700: PUSH
75701: LD_VAR 0 13
75705: PUSH
75706: LD_INT 2
75708: PLUS
75709: GREATER
75710: OR
75711: PUSH
75712: LD_VAR 0 8
75716: PUSH
75717: LD_INT 2
75719: ARRAY
75720: PUSH
75721: LD_VAR 0 13
75725: PUSH
75726: LD_INT 2
75728: MINUS
75729: LESS
75730: OR
75731: PUSH
75732: LD_VAR 0 8
75736: PUSH
75737: LD_INT 3
75739: ARRAY
75740: PUSH
75741: LD_INT 0
75743: PUSH
75744: LD_INT 8
75746: PUSH
75747: LD_INT 9
75749: PUSH
75750: LD_INT 10
75752: PUSH
75753: LD_INT 11
75755: PUSH
75756: LD_INT 12
75758: PUSH
75759: LD_INT 13
75761: PUSH
75762: LD_INT 16
75764: PUSH
75765: LD_INT 17
75767: PUSH
75768: LD_INT 18
75770: PUSH
75771: LD_INT 19
75773: PUSH
75774: LD_INT 20
75776: PUSH
75777: LD_INT 21
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: LIST
75784: LIST
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: IN
75795: NOT
75796: OR
75797: PUSH
75798: LD_VAR 0 8
75802: PUSH
75803: LD_INT 5
75805: ARRAY
75806: NOT
75807: OR
75808: PUSH
75809: LD_VAR 0 8
75813: PUSH
75814: LD_INT 6
75816: ARRAY
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: LD_INT 2
75823: PUSH
75824: LD_INT 7
75826: PUSH
75827: LD_INT 9
75829: PUSH
75830: LD_INT 10
75832: PUSH
75833: LD_INT 11
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: IN
75844: NOT
75845: OR
75846: IFFALSE 75852
// exit ;
75848: POP
75849: POP
75850: GO 75950
// end ;
75852: GO 75523
75854: POP
75855: POP
// side := GetSide ( bdepot ) ;
75856: LD_ADDR_VAR 0 9
75860: PUSH
75861: LD_VAR 0 1
75865: PPUSH
75866: CALL_OW 255
75870: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75871: LD_VAR 0 9
75875: PPUSH
75876: LD_VAR 0 3
75880: PPUSH
75881: LD_VAR 0 4
75885: PPUSH
75886: LD_INT 20
75888: PPUSH
75889: CALL 68622 0 4
75893: PUSH
75894: LD_INT 4
75896: ARRAY
75897: IFFALSE 75901
// exit ;
75899: GO 75950
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
75901: LD_VAR 0 2
75905: PUSH
75906: LD_INT 29
75908: PUSH
75909: LD_INT 30
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: IN
75916: PUSH
75917: LD_VAR 0 3
75921: PPUSH
75922: LD_VAR 0 4
75926: PPUSH
75927: LD_VAR 0 9
75931: PPUSH
75932: CALL_OW 440
75936: NOT
75937: AND
75938: IFFALSE 75942
// exit ;
75940: GO 75950
// result := true ;
75942: LD_ADDR_VAR 0 6
75946: PUSH
75947: LD_INT 1
75949: ST_TO_ADDR
// end ;
75950: LD_VAR 0 6
75954: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
75955: LD_INT 0
75957: PPUSH
75958: PPUSH
75959: PPUSH
75960: PPUSH
75961: PPUSH
75962: PPUSH
75963: PPUSH
75964: PPUSH
75965: PPUSH
75966: PPUSH
75967: PPUSH
75968: PPUSH
75969: PPUSH
75970: PPUSH
75971: PPUSH
75972: PPUSH
75973: PPUSH
75974: PPUSH
75975: PPUSH
75976: PPUSH
75977: PPUSH
75978: PPUSH
75979: PPUSH
75980: PPUSH
75981: PPUSH
75982: PPUSH
75983: PPUSH
75984: PPUSH
75985: PPUSH
75986: PPUSH
75987: PPUSH
75988: PPUSH
75989: PPUSH
75990: PPUSH
75991: PPUSH
75992: PPUSH
75993: PPUSH
75994: PPUSH
75995: PPUSH
75996: PPUSH
75997: PPUSH
75998: PPUSH
75999: PPUSH
76000: PPUSH
76001: PPUSH
76002: PPUSH
76003: PPUSH
76004: PPUSH
76005: PPUSH
76006: PPUSH
76007: PPUSH
76008: PPUSH
76009: PPUSH
76010: PPUSH
76011: PPUSH
76012: PPUSH
76013: PPUSH
76014: PPUSH
// result = [ ] ;
76015: LD_ADDR_VAR 0 7
76019: PUSH
76020: EMPTY
76021: ST_TO_ADDR
// temp_list = [ ] ;
76022: LD_ADDR_VAR 0 9
76026: PUSH
76027: EMPTY
76028: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
76029: LD_VAR 0 4
76033: PUSH
76034: LD_INT 0
76036: PUSH
76037: LD_INT 1
76039: PUSH
76040: LD_INT 2
76042: PUSH
76043: LD_INT 3
76045: PUSH
76046: LD_INT 4
76048: PUSH
76049: LD_INT 5
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: IN
76060: NOT
76061: PUSH
76062: LD_VAR 0 1
76066: PUSH
76067: LD_INT 0
76069: PUSH
76070: LD_INT 1
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: IN
76077: PUSH
76078: LD_VAR 0 5
76082: PUSH
76083: LD_INT 1
76085: PUSH
76086: LD_INT 2
76088: PUSH
76089: LD_INT 3
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: LIST
76096: IN
76097: NOT
76098: AND
76099: OR
76100: IFFALSE 76104
// exit ;
76102: GO 94489
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
76104: LD_VAR 0 1
76108: PUSH
76109: LD_INT 6
76111: PUSH
76112: LD_INT 7
76114: PUSH
76115: LD_INT 8
76117: PUSH
76118: LD_INT 13
76120: PUSH
76121: LD_INT 12
76123: PUSH
76124: LD_INT 15
76126: PUSH
76127: LD_INT 11
76129: PUSH
76130: LD_INT 14
76132: PUSH
76133: LD_INT 10
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: IN
76147: IFFALSE 76157
// btype = b_lab ;
76149: LD_ADDR_VAR 0 1
76153: PUSH
76154: LD_INT 6
76156: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
76157: LD_VAR 0 6
76161: PUSH
76162: LD_INT 0
76164: PUSH
76165: LD_INT 1
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: LIST
76175: IN
76176: NOT
76177: PUSH
76178: LD_VAR 0 1
76182: PUSH
76183: LD_INT 0
76185: PUSH
76186: LD_INT 1
76188: PUSH
76189: LD_INT 2
76191: PUSH
76192: LD_INT 3
76194: PUSH
76195: LD_INT 6
76197: PUSH
76198: LD_INT 36
76200: PUSH
76201: LD_INT 4
76203: PUSH
76204: LD_INT 5
76206: PUSH
76207: LD_INT 31
76209: PUSH
76210: LD_INT 32
76212: PUSH
76213: LD_INT 33
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: IN
76229: NOT
76230: PUSH
76231: LD_VAR 0 6
76235: PUSH
76236: LD_INT 1
76238: EQUAL
76239: AND
76240: OR
76241: PUSH
76242: LD_VAR 0 1
76246: PUSH
76247: LD_INT 2
76249: PUSH
76250: LD_INT 3
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: IN
76257: NOT
76258: PUSH
76259: LD_VAR 0 6
76263: PUSH
76264: LD_INT 2
76266: EQUAL
76267: AND
76268: OR
76269: IFFALSE 76279
// mode = 0 ;
76271: LD_ADDR_VAR 0 6
76275: PUSH
76276: LD_INT 0
76278: ST_TO_ADDR
// case mode of 0 :
76279: LD_VAR 0 6
76283: PUSH
76284: LD_INT 0
76286: DOUBLE
76287: EQUAL
76288: IFTRUE 76292
76290: GO 87745
76292: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76293: LD_ADDR_VAR 0 11
76297: PUSH
76298: LD_INT 0
76300: PUSH
76301: LD_INT 0
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 0
76310: PUSH
76311: LD_INT 1
76313: NEG
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 1
76321: PUSH
76322: LD_INT 0
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 1
76331: PUSH
76332: LD_INT 1
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: LD_INT 0
76341: PUSH
76342: LD_INT 1
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 1
76351: NEG
76352: PUSH
76353: LD_INT 0
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 1
76362: NEG
76363: PUSH
76364: LD_INT 1
76366: NEG
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 1
76374: NEG
76375: PUSH
76376: LD_INT 2
76378: NEG
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 0
76386: PUSH
76387: LD_INT 2
76389: NEG
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 1
76397: PUSH
76398: LD_INT 1
76400: NEG
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: LD_INT 2
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: LD_INT 2
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 1
76428: NEG
76429: PUSH
76430: LD_INT 1
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 1
76439: PUSH
76440: LD_INT 3
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 0
76449: PUSH
76450: LD_INT 3
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 1
76459: NEG
76460: PUSH
76461: LD_INT 2
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76486: LD_ADDR_VAR 0 12
76490: PUSH
76491: LD_INT 0
76493: PUSH
76494: LD_INT 0
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 0
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 1
76514: PUSH
76515: LD_INT 0
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 1
76524: PUSH
76525: LD_INT 1
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 0
76534: PUSH
76535: LD_INT 1
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 1
76544: NEG
76545: PUSH
76546: LD_INT 0
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 1
76555: NEG
76556: PUSH
76557: LD_INT 1
76559: NEG
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 1
76567: PUSH
76568: LD_INT 1
76570: NEG
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 2
76578: PUSH
76579: LD_INT 0
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 2
76588: PUSH
76589: LD_INT 1
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 1
76598: NEG
76599: PUSH
76600: LD_INT 1
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: LD_INT 2
76609: NEG
76610: PUSH
76611: LD_INT 0
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 2
76620: NEG
76621: PUSH
76622: LD_INT 1
76624: NEG
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 2
76632: NEG
76633: PUSH
76634: LD_INT 1
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 3
76643: NEG
76644: PUSH
76645: LD_INT 0
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: LD_INT 3
76654: NEG
76655: PUSH
76656: LD_INT 1
76658: NEG
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76682: LD_ADDR_VAR 0 13
76686: PUSH
76687: LD_INT 0
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 0
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 1
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: LD_INT 1
76740: NEG
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: LD_INT 1
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 1
76763: NEG
76764: PUSH
76765: LD_INT 2
76767: NEG
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 1
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 2
76785: PUSH
76786: LD_INT 2
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 1
76795: PUSH
76796: LD_INT 2
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 2
76805: NEG
76806: PUSH
76807: LD_INT 1
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 2
76817: NEG
76818: PUSH
76819: LD_INT 2
76821: NEG
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 2
76829: NEG
76830: PUSH
76831: LD_INT 3
76833: NEG
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 3
76841: NEG
76842: PUSH
76843: LD_INT 2
76845: NEG
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 3
76853: NEG
76854: PUSH
76855: LD_INT 3
76857: NEG
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: LIST
76878: LIST
76879: LIST
76880: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76881: LD_ADDR_VAR 0 14
76885: PUSH
76886: LD_INT 0
76888: PUSH
76889: LD_INT 0
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 0
76898: PUSH
76899: LD_INT 1
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: LD_INT 0
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 1
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 0
76929: PUSH
76930: LD_INT 1
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: LD_INT 0
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 1
76950: NEG
76951: PUSH
76952: LD_INT 1
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 1
76962: NEG
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: LD_INT 2
76977: NEG
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 1
76985: PUSH
76986: LD_INT 1
76988: NEG
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: LD_INT 2
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 0
77006: PUSH
77007: LD_INT 2
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 1
77016: NEG
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 1
77027: NEG
77028: PUSH
77029: LD_INT 3
77031: NEG
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 0
77039: PUSH
77040: LD_INT 3
77042: NEG
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 1
77050: PUSH
77051: LD_INT 2
77053: NEG
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: LIST
77070: LIST
77071: LIST
77072: LIST
77073: LIST
77074: LIST
77075: LIST
77076: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77077: LD_ADDR_VAR 0 15
77081: PUSH
77082: LD_INT 0
77084: PUSH
77085: LD_INT 0
77087: PUSH
77088: EMPTY
77089: LIST
77090: LIST
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: LD_INT 1
77097: NEG
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 1
77105: PUSH
77106: LD_INT 0
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 1
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 0
77125: PUSH
77126: LD_INT 1
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 1
77135: NEG
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 1
77146: NEG
77147: PUSH
77148: LD_INT 1
77150: NEG
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: PUSH
77156: LD_INT 1
77158: PUSH
77159: LD_INT 1
77161: NEG
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PUSH
77167: LD_INT 2
77169: PUSH
77170: LD_INT 0
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: LD_INT 2
77179: PUSH
77180: LD_INT 1
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 1
77189: NEG
77190: PUSH
77191: LD_INT 1
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 2
77200: NEG
77201: PUSH
77202: LD_INT 0
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 2
77211: NEG
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 2
77223: PUSH
77224: LD_INT 1
77226: NEG
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 3
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 3
77244: PUSH
77245: LD_INT 1
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: LIST
77256: LIST
77257: LIST
77258: LIST
77259: LIST
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: LIST
77267: LIST
77268: LIST
77269: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77270: LD_ADDR_VAR 0 16
77274: PUSH
77275: LD_INT 0
77277: PUSH
77278: LD_INT 0
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 0
77287: PUSH
77288: LD_INT 1
77290: NEG
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 1
77298: PUSH
77299: LD_INT 0
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: PUSH
77309: LD_INT 1
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 0
77318: PUSH
77319: LD_INT 1
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 1
77328: NEG
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 1
77339: NEG
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: NEG
77352: PUSH
77353: LD_INT 2
77355: NEG
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 2
77363: PUSH
77364: LD_INT 1
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 2
77373: PUSH
77374: LD_INT 2
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 1
77383: PUSH
77384: LD_INT 2
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 2
77393: NEG
77394: PUSH
77395: LD_INT 1
77397: NEG
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 2
77405: NEG
77406: PUSH
77407: LD_INT 2
77409: NEG
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 3
77417: PUSH
77418: LD_INT 2
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 3
77427: PUSH
77428: LD_INT 3
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 2
77437: PUSH
77438: LD_INT 3
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77463: LD_ADDR_VAR 0 17
77467: PUSH
77468: LD_INT 0
77470: PUSH
77471: LD_INT 0
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: LD_INT 0
77480: PUSH
77481: LD_INT 1
77483: NEG
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 1
77491: PUSH
77492: LD_INT 0
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 1
77501: PUSH
77502: LD_INT 1
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 1
77521: NEG
77522: PUSH
77523: LD_INT 0
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 1
77532: NEG
77533: PUSH
77534: LD_INT 1
77536: NEG
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 1
77544: NEG
77545: PUSH
77546: LD_INT 2
77548: NEG
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 0
77556: PUSH
77557: LD_INT 2
77559: NEG
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: LD_INT 1
77567: PUSH
77568: LD_INT 1
77570: NEG
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: LD_INT 2
77578: PUSH
77579: LD_INT 0
77581: PUSH
77582: EMPTY
77583: LIST
77584: LIST
77585: PUSH
77586: LD_INT 2
77588: PUSH
77589: LD_INT 1
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: PUSH
77596: LD_INT 2
77598: PUSH
77599: LD_INT 2
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 1
77608: PUSH
77609: LD_INT 2
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: PUSH
77616: LD_INT 0
77618: PUSH
77619: LD_INT 2
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 1
77628: NEG
77629: PUSH
77630: LD_INT 1
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 2
77639: NEG
77640: PUSH
77641: LD_INT 0
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 2
77650: NEG
77651: PUSH
77652: LD_INT 1
77654: NEG
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 2
77662: NEG
77663: PUSH
77664: LD_INT 2
77666: NEG
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77693: LD_ADDR_VAR 0 18
77697: PUSH
77698: LD_INT 0
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 0
77710: PUSH
77711: LD_INT 1
77713: NEG
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 1
77721: PUSH
77722: LD_INT 0
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: LD_INT 1
77731: PUSH
77732: LD_INT 1
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 0
77741: PUSH
77742: LD_INT 1
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 1
77751: NEG
77752: PUSH
77753: LD_INT 0
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 1
77762: NEG
77763: PUSH
77764: LD_INT 1
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 1
77774: NEG
77775: PUSH
77776: LD_INT 2
77778: NEG
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: LD_INT 0
77786: PUSH
77787: LD_INT 2
77789: NEG
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 1
77797: PUSH
77798: LD_INT 1
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 2
77808: PUSH
77809: LD_INT 0
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: LD_INT 2
77818: PUSH
77819: LD_INT 1
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 2
77828: PUSH
77829: LD_INT 2
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 1
77838: PUSH
77839: LD_INT 2
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 0
77848: PUSH
77849: LD_INT 2
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 1
77858: NEG
77859: PUSH
77860: LD_INT 1
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 2
77869: NEG
77870: PUSH
77871: LD_INT 0
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 2
77880: NEG
77881: PUSH
77882: LD_INT 1
77884: NEG
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 2
77892: NEG
77893: PUSH
77894: LD_INT 2
77896: NEG
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: LIST
77906: LIST
77907: LIST
77908: LIST
77909: LIST
77910: LIST
77911: LIST
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: LIST
77919: LIST
77920: LIST
77921: LIST
77922: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77923: LD_ADDR_VAR 0 19
77927: PUSH
77928: LD_INT 0
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 0
77940: PUSH
77941: LD_INT 1
77943: NEG
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 1
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 1
77961: PUSH
77962: LD_INT 1
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 0
77971: PUSH
77972: LD_INT 1
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 1
77981: NEG
77982: PUSH
77983: LD_INT 0
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 1
77992: NEG
77993: PUSH
77994: LD_INT 1
77996: NEG
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: PUSH
78002: LD_INT 1
78004: NEG
78005: PUSH
78006: LD_INT 2
78008: NEG
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: LD_INT 0
78016: PUSH
78017: LD_INT 2
78019: NEG
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 1
78027: PUSH
78028: LD_INT 1
78030: NEG
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 2
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 2
78048: PUSH
78049: LD_INT 1
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 2
78058: PUSH
78059: LD_INT 2
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: LD_INT 2
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 0
78078: PUSH
78079: LD_INT 2
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 1
78088: NEG
78089: PUSH
78090: LD_INT 1
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 2
78099: NEG
78100: PUSH
78101: LD_INT 0
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 2
78110: NEG
78111: PUSH
78112: LD_INT 1
78114: NEG
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 2
78122: NEG
78123: PUSH
78124: LD_INT 2
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78153: LD_ADDR_VAR 0 20
78157: PUSH
78158: LD_INT 0
78160: PUSH
78161: LD_INT 0
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 0
78170: PUSH
78171: LD_INT 1
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: LD_INT 0
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 1
78191: PUSH
78192: LD_INT 1
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: LD_INT 0
78201: PUSH
78202: LD_INT 1
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: LD_INT 1
78211: NEG
78212: PUSH
78213: LD_INT 0
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 1
78222: NEG
78223: PUSH
78224: LD_INT 1
78226: NEG
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PUSH
78232: LD_INT 1
78234: NEG
78235: PUSH
78236: LD_INT 2
78238: NEG
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 0
78246: PUSH
78247: LD_INT 2
78249: NEG
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: PUSH
78255: LD_INT 1
78257: PUSH
78258: LD_INT 1
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 2
78268: PUSH
78269: LD_INT 0
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 2
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 2
78288: PUSH
78289: LD_INT 2
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 1
78298: PUSH
78299: LD_INT 2
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 0
78308: PUSH
78309: LD_INT 2
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: LD_INT 1
78318: NEG
78319: PUSH
78320: LD_INT 1
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 2
78329: NEG
78330: PUSH
78331: LD_INT 0
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 2
78340: NEG
78341: PUSH
78342: LD_INT 1
78344: NEG
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 2
78352: NEG
78353: PUSH
78354: LD_INT 2
78356: NEG
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78383: LD_ADDR_VAR 0 21
78387: PUSH
78388: LD_INT 0
78390: PUSH
78391: LD_INT 0
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 0
78400: PUSH
78401: LD_INT 1
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 1
78411: PUSH
78412: LD_INT 0
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 1
78421: PUSH
78422: LD_INT 1
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 0
78431: PUSH
78432: LD_INT 1
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: LD_INT 1
78441: NEG
78442: PUSH
78443: LD_INT 0
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 1
78452: NEG
78453: PUSH
78454: LD_INT 1
78456: NEG
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 1
78464: NEG
78465: PUSH
78466: LD_INT 2
78468: NEG
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 0
78476: PUSH
78477: LD_INT 2
78479: NEG
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 1
78487: PUSH
78488: LD_INT 1
78490: NEG
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 2
78498: PUSH
78499: LD_INT 0
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 2
78508: PUSH
78509: LD_INT 1
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 2
78518: PUSH
78519: LD_INT 2
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: PUSH
78529: LD_INT 2
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 0
78538: PUSH
78539: LD_INT 2
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 1
78548: NEG
78549: PUSH
78550: LD_INT 1
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 2
78559: NEG
78560: PUSH
78561: LD_INT 0
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 2
78570: NEG
78571: PUSH
78572: LD_INT 1
78574: NEG
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 2
78582: NEG
78583: PUSH
78584: LD_INT 2
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78613: LD_ADDR_VAR 0 22
78617: PUSH
78618: LD_INT 0
78620: PUSH
78621: LD_INT 0
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 0
78630: PUSH
78631: LD_INT 1
78633: NEG
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 1
78641: PUSH
78642: LD_INT 0
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 1
78651: PUSH
78652: LD_INT 1
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 0
78661: PUSH
78662: LD_INT 1
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 1
78671: NEG
78672: PUSH
78673: LD_INT 0
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 1
78682: NEG
78683: PUSH
78684: LD_INT 1
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 1
78694: NEG
78695: PUSH
78696: LD_INT 2
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 0
78706: PUSH
78707: LD_INT 2
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 1
78717: PUSH
78718: LD_INT 1
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 2
78728: PUSH
78729: LD_INT 0
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 2
78738: PUSH
78739: LD_INT 1
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 2
78748: PUSH
78749: LD_INT 2
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 1
78758: PUSH
78759: LD_INT 2
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: LD_INT 2
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 1
78778: NEG
78779: PUSH
78780: LD_INT 1
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 2
78789: NEG
78790: PUSH
78791: LD_INT 0
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 2
78800: NEG
78801: PUSH
78802: LD_INT 1
78804: NEG
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 2
78812: NEG
78813: PUSH
78814: LD_INT 2
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78843: LD_ADDR_VAR 0 23
78847: PUSH
78848: LD_INT 0
78850: PUSH
78851: LD_INT 0
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 0
78860: PUSH
78861: LD_INT 1
78863: NEG
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 1
78871: PUSH
78872: LD_INT 0
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: PUSH
78882: LD_INT 1
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: LD_INT 1
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: LD_INT 0
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 1
78912: NEG
78913: PUSH
78914: LD_INT 1
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 1
78924: NEG
78925: PUSH
78926: LD_INT 2
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 0
78936: PUSH
78937: LD_INT 2
78939: NEG
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PUSH
78945: LD_INT 1
78947: PUSH
78948: LD_INT 1
78950: NEG
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 2
78958: PUSH
78959: LD_INT 0
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 2
78968: PUSH
78969: LD_INT 1
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 2
78978: PUSH
78979: LD_INT 2
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 1
78988: PUSH
78989: LD_INT 2
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 0
78998: PUSH
78999: LD_INT 2
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 1
79008: NEG
79009: PUSH
79010: LD_INT 1
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 2
79019: NEG
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 2
79030: NEG
79031: PUSH
79032: LD_INT 1
79034: NEG
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 2
79042: NEG
79043: PUSH
79044: LD_INT 2
79046: NEG
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 2
79054: NEG
79055: PUSH
79056: LD_INT 3
79058: NEG
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: LD_INT 3
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 1
79078: PUSH
79079: LD_INT 2
79081: NEG
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 2
79089: PUSH
79090: LD_INT 1
79092: NEG
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
79123: LD_ADDR_VAR 0 24
79127: PUSH
79128: LD_INT 0
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 0
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 1
79151: PUSH
79152: LD_INT 0
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 1
79161: PUSH
79162: LD_INT 1
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 0
79171: PUSH
79172: LD_INT 1
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 1
79181: NEG
79182: PUSH
79183: LD_INT 0
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 1
79192: NEG
79193: PUSH
79194: LD_INT 1
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: LD_INT 2
79208: NEG
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 0
79216: PUSH
79217: LD_INT 2
79219: NEG
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: LD_INT 1
79230: NEG
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 2
79238: PUSH
79239: LD_INT 0
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 2
79248: PUSH
79249: LD_INT 1
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 2
79258: PUSH
79259: LD_INT 2
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 1
79268: PUSH
79269: LD_INT 2
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 0
79278: PUSH
79279: LD_INT 2
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 1
79288: NEG
79289: PUSH
79290: LD_INT 1
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 2
79299: NEG
79300: PUSH
79301: LD_INT 0
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 2
79310: NEG
79311: PUSH
79312: LD_INT 1
79314: NEG
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 2
79322: NEG
79323: PUSH
79324: LD_INT 2
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: LD_INT 1
79334: PUSH
79335: LD_INT 2
79337: NEG
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 2
79345: PUSH
79346: LD_INT 1
79348: NEG
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 3
79356: PUSH
79357: LD_INT 1
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 3
79366: PUSH
79367: LD_INT 2
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
79399: LD_ADDR_VAR 0 25
79403: PUSH
79404: LD_INT 0
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 0
79416: PUSH
79417: LD_INT 1
79419: NEG
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 1
79427: PUSH
79428: LD_INT 0
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 1
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 0
79447: PUSH
79448: LD_INT 1
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 1
79457: NEG
79458: PUSH
79459: LD_INT 0
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 1
79468: NEG
79469: PUSH
79470: LD_INT 1
79472: NEG
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 1
79480: NEG
79481: PUSH
79482: LD_INT 2
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 0
79492: PUSH
79493: LD_INT 2
79495: NEG
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 1
79503: PUSH
79504: LD_INT 1
79506: NEG
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 2
79514: PUSH
79515: LD_INT 0
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: LD_INT 2
79524: PUSH
79525: LD_INT 1
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 2
79534: PUSH
79535: LD_INT 2
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 1
79544: PUSH
79545: LD_INT 2
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 0
79554: PUSH
79555: LD_INT 2
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 1
79564: NEG
79565: PUSH
79566: LD_INT 1
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PUSH
79573: LD_INT 2
79575: NEG
79576: PUSH
79577: LD_INT 0
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 2
79586: NEG
79587: PUSH
79588: LD_INT 1
79590: NEG
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 2
79598: NEG
79599: PUSH
79600: LD_INT 2
79602: NEG
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 3
79610: PUSH
79611: LD_INT 1
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 3
79620: PUSH
79621: LD_INT 2
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 2
79630: PUSH
79631: LD_INT 3
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 1
79640: PUSH
79641: LD_INT 3
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79673: LD_ADDR_VAR 0 26
79677: PUSH
79678: LD_INT 0
79680: PUSH
79681: LD_INT 0
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 0
79690: PUSH
79691: LD_INT 1
79693: NEG
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 1
79701: PUSH
79702: LD_INT 0
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 1
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 0
79721: PUSH
79722: LD_INT 1
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: NEG
79732: PUSH
79733: LD_INT 0
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 1
79742: NEG
79743: PUSH
79744: LD_INT 1
79746: NEG
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 1
79754: NEG
79755: PUSH
79756: LD_INT 2
79758: NEG
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 0
79766: PUSH
79767: LD_INT 2
79769: NEG
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 1
79777: PUSH
79778: LD_INT 1
79780: NEG
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: LD_INT 0
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 2
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 2
79808: PUSH
79809: LD_INT 2
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: LD_INT 2
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 0
79828: PUSH
79829: LD_INT 2
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 1
79838: NEG
79839: PUSH
79840: LD_INT 1
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 2
79849: NEG
79850: PUSH
79851: LD_INT 0
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 2
79860: NEG
79861: PUSH
79862: LD_INT 1
79864: NEG
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 2
79872: NEG
79873: PUSH
79874: LD_INT 2
79876: NEG
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: LD_INT 2
79884: PUSH
79885: LD_INT 3
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 1
79894: PUSH
79895: LD_INT 3
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 1
79904: NEG
79905: PUSH
79906: LD_INT 2
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 2
79915: NEG
79916: PUSH
79917: LD_INT 1
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79949: LD_ADDR_VAR 0 27
79953: PUSH
79954: LD_INT 0
79956: PUSH
79957: LD_INT 0
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: LD_INT 0
79966: PUSH
79967: LD_INT 1
79969: NEG
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 1
79977: PUSH
79978: LD_INT 0
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 1
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 0
79997: PUSH
79998: LD_INT 1
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: LD_INT 0
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 1
80018: NEG
80019: PUSH
80020: LD_INT 1
80022: NEG
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 1
80030: NEG
80031: PUSH
80032: LD_INT 2
80034: NEG
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 0
80042: PUSH
80043: LD_INT 2
80045: NEG
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 1
80053: PUSH
80054: LD_INT 1
80056: NEG
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: LD_INT 2
80064: PUSH
80065: LD_INT 0
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 2
80074: PUSH
80075: LD_INT 1
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 2
80084: PUSH
80085: LD_INT 2
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: LD_INT 1
80094: PUSH
80095: LD_INT 2
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: LD_INT 2
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: LD_INT 1
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 2
80125: NEG
80126: PUSH
80127: LD_INT 0
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 2
80136: NEG
80137: PUSH
80138: LD_INT 1
80140: NEG
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 2
80148: NEG
80149: PUSH
80150: LD_INT 2
80152: NEG
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: NEG
80161: PUSH
80162: LD_INT 2
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 2
80171: NEG
80172: PUSH
80173: LD_INT 1
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 3
80182: NEG
80183: PUSH
80184: LD_INT 1
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 3
80194: NEG
80195: PUSH
80196: LD_INT 2
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: LIST
80224: LIST
80225: LIST
80226: LIST
80227: LIST
80228: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80229: LD_ADDR_VAR 0 28
80233: PUSH
80234: LD_INT 0
80236: PUSH
80237: LD_INT 0
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 0
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 1
80257: PUSH
80258: LD_INT 0
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 1
80267: PUSH
80268: LD_INT 1
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 0
80277: PUSH
80278: LD_INT 1
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 1
80287: NEG
80288: PUSH
80289: LD_INT 0
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 1
80298: NEG
80299: PUSH
80300: LD_INT 1
80302: NEG
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 1
80310: NEG
80311: PUSH
80312: LD_INT 2
80314: NEG
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 0
80322: PUSH
80323: LD_INT 2
80325: NEG
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 1
80333: PUSH
80334: LD_INT 1
80336: NEG
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: LD_INT 2
80344: PUSH
80345: LD_INT 0
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 2
80354: PUSH
80355: LD_INT 1
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 2
80364: PUSH
80365: LD_INT 2
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 1
80374: PUSH
80375: LD_INT 2
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 0
80384: PUSH
80385: LD_INT 2
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 1
80394: NEG
80395: PUSH
80396: LD_INT 1
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 2
80405: NEG
80406: PUSH
80407: LD_INT 0
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 2
80416: NEG
80417: PUSH
80418: LD_INT 1
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 2
80428: NEG
80429: PUSH
80430: LD_INT 2
80432: NEG
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 2
80440: NEG
80441: PUSH
80442: LD_INT 3
80444: NEG
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 1
80452: NEG
80453: PUSH
80454: LD_INT 3
80456: NEG
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 3
80464: NEG
80465: PUSH
80466: LD_INT 1
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 3
80476: NEG
80477: PUSH
80478: LD_INT 2
80480: NEG
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80511: LD_ADDR_VAR 0 29
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 0
80528: PUSH
80529: LD_INT 1
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 1
80539: PUSH
80540: LD_INT 0
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 1
80549: PUSH
80550: LD_INT 1
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 1
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 1
80569: NEG
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 1
80580: NEG
80581: PUSH
80582: LD_INT 1
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: NEG
80593: PUSH
80594: LD_INT 2
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: LD_INT 2
80607: NEG
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 1
80615: PUSH
80616: LD_INT 1
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 2
80626: PUSH
80627: LD_INT 0
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 2
80636: PUSH
80637: LD_INT 1
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 2
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 0
80656: PUSH
80657: LD_INT 2
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 1
80666: NEG
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 2
80677: NEG
80678: PUSH
80679: LD_INT 1
80681: NEG
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 2
80689: NEG
80690: PUSH
80691: LD_INT 2
80693: NEG
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 2
80701: NEG
80702: PUSH
80703: LD_INT 3
80705: NEG
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 2
80713: PUSH
80714: LD_INT 1
80716: NEG
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 3
80724: PUSH
80725: LD_INT 1
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: LD_INT 3
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 1
80744: NEG
80745: PUSH
80746: LD_INT 2
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 3
80755: NEG
80756: PUSH
80757: LD_INT 2
80759: NEG
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80790: LD_ADDR_VAR 0 30
80794: PUSH
80795: LD_INT 0
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_INT 0
80807: PUSH
80808: LD_INT 1
80810: NEG
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: PUSH
80819: LD_INT 0
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 1
80828: PUSH
80829: LD_INT 1
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 0
80838: PUSH
80839: LD_INT 1
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 1
80848: NEG
80849: PUSH
80850: LD_INT 0
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 1
80859: NEG
80860: PUSH
80861: LD_INT 1
80863: NEG
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 1
80871: NEG
80872: PUSH
80873: LD_INT 2
80875: NEG
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 0
80883: PUSH
80884: LD_INT 2
80886: NEG
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: LD_INT 1
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 2
80905: PUSH
80906: LD_INT 0
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 2
80915: PUSH
80916: LD_INT 1
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 2
80925: PUSH
80926: LD_INT 2
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 1
80935: PUSH
80936: LD_INT 2
80938: PUSH
80939: EMPTY
80940: LIST
80941: LIST
80942: PUSH
80943: LD_INT 1
80945: NEG
80946: PUSH
80947: LD_INT 1
80949: PUSH
80950: EMPTY
80951: LIST
80952: LIST
80953: PUSH
80954: LD_INT 2
80956: NEG
80957: PUSH
80958: LD_INT 0
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 2
80967: NEG
80968: PUSH
80969: LD_INT 1
80971: NEG
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 1
80979: NEG
80980: PUSH
80981: LD_INT 3
80983: NEG
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: LD_INT 2
80994: NEG
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: LD_INT 2
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: PUSH
81013: LD_INT 3
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 2
81022: NEG
81023: PUSH
81024: LD_INT 1
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 3
81033: NEG
81034: PUSH
81035: LD_INT 1
81037: NEG
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81068: LD_ADDR_VAR 0 31
81072: PUSH
81073: LD_INT 0
81075: PUSH
81076: LD_INT 0
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 0
81085: PUSH
81086: LD_INT 1
81088: NEG
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: LD_INT 0
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: LD_INT 1
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 0
81116: PUSH
81117: LD_INT 1
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 1
81126: NEG
81127: PUSH
81128: LD_INT 0
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 1
81137: NEG
81138: PUSH
81139: LD_INT 1
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 1
81149: NEG
81150: PUSH
81151: LD_INT 2
81153: NEG
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: LD_INT 1
81164: NEG
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: LD_INT 2
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 2
81182: PUSH
81183: LD_INT 1
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 2
81192: PUSH
81193: LD_INT 2
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 1
81202: PUSH
81203: LD_INT 2
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: LD_INT 2
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: LD_INT 1
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 2
81233: NEG
81234: PUSH
81235: LD_INT 1
81237: NEG
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: LD_INT 2
81245: NEG
81246: PUSH
81247: LD_INT 2
81249: NEG
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PUSH
81255: LD_INT 2
81257: NEG
81258: PUSH
81259: LD_INT 3
81261: NEG
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 2
81269: PUSH
81270: LD_INT 1
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 3
81280: PUSH
81281: LD_INT 1
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 1
81290: PUSH
81291: LD_INT 3
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 1
81300: NEG
81301: PUSH
81302: LD_INT 2
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 3
81311: NEG
81312: PUSH
81313: LD_INT 2
81315: NEG
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: LIST
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81346: LD_ADDR_VAR 0 32
81350: PUSH
81351: LD_INT 0
81353: PUSH
81354: LD_INT 0
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 0
81363: PUSH
81364: LD_INT 1
81366: NEG
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 1
81374: PUSH
81375: LD_INT 0
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 1
81384: PUSH
81385: LD_INT 1
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PUSH
81392: LD_INT 0
81394: PUSH
81395: LD_INT 1
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 1
81404: NEG
81405: PUSH
81406: LD_INT 0
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 1
81415: NEG
81416: PUSH
81417: LD_INT 1
81419: NEG
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 1
81427: NEG
81428: PUSH
81429: LD_INT 2
81431: NEG
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 0
81439: PUSH
81440: LD_INT 2
81442: NEG
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: PUSH
81451: LD_INT 1
81453: NEG
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 2
81461: PUSH
81462: LD_INT 1
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: LD_INT 2
81471: PUSH
81472: LD_INT 2
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 1
81481: PUSH
81482: LD_INT 2
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 0
81491: PUSH
81492: LD_INT 2
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: NEG
81502: PUSH
81503: LD_INT 1
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 2
81512: NEG
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 2
81523: NEG
81524: PUSH
81525: LD_INT 1
81527: NEG
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: PUSH
81533: LD_INT 1
81535: NEG
81536: PUSH
81537: LD_INT 3
81539: NEG
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 1
81547: PUSH
81548: LD_INT 2
81550: NEG
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 3
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 2
81568: PUSH
81569: LD_INT 3
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: LD_INT 2
81578: NEG
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 3
81589: NEG
81590: PUSH
81591: LD_INT 1
81593: NEG
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81624: LD_ADDR_VAR 0 33
81628: PUSH
81629: LD_INT 0
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 0
81641: PUSH
81642: LD_INT 1
81644: NEG
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 1
81652: PUSH
81653: LD_INT 0
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 1
81662: PUSH
81663: LD_INT 1
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 0
81672: PUSH
81673: LD_INT 1
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 1
81682: NEG
81683: PUSH
81684: LD_INT 0
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: PUSH
81691: LD_INT 1
81693: NEG
81694: PUSH
81695: LD_INT 1
81697: NEG
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_INT 1
81705: NEG
81706: PUSH
81707: LD_INT 2
81709: NEG
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 1
81717: PUSH
81718: LD_INT 1
81720: NEG
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 2
81728: PUSH
81729: LD_INT 0
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 2
81738: PUSH
81739: LD_INT 1
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 1
81748: PUSH
81749: LD_INT 2
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 0
81758: PUSH
81759: LD_INT 2
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 1
81768: NEG
81769: PUSH
81770: LD_INT 1
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 2
81779: NEG
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: LD_INT 1
81794: NEG
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 2
81802: NEG
81803: PUSH
81804: LD_INT 2
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 2
81814: NEG
81815: PUSH
81816: LD_INT 3
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 2
81826: PUSH
81827: LD_INT 1
81829: NEG
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 3
81837: PUSH
81838: LD_INT 1
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 1
81847: PUSH
81848: LD_INT 3
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 1
81857: NEG
81858: PUSH
81859: LD_INT 2
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 3
81868: NEG
81869: PUSH
81870: LD_INT 2
81872: NEG
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: LIST
81892: LIST
81893: LIST
81894: LIST
81895: LIST
81896: LIST
81897: LIST
81898: LIST
81899: LIST
81900: LIST
81901: LIST
81902: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81903: LD_ADDR_VAR 0 34
81907: PUSH
81908: LD_INT 0
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 0
81920: PUSH
81921: LD_INT 1
81923: NEG
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 1
81931: PUSH
81932: LD_INT 0
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 1
81941: PUSH
81942: LD_INT 1
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 0
81951: PUSH
81952: LD_INT 1
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 1
81961: NEG
81962: PUSH
81963: LD_INT 0
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 1
81972: NEG
81973: PUSH
81974: LD_INT 1
81976: NEG
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 1
81984: NEG
81985: PUSH
81986: LD_INT 2
81988: NEG
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 2
81999: NEG
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: LD_INT 1
82007: PUSH
82008: LD_INT 1
82010: NEG
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 2
82018: PUSH
82019: LD_INT 1
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 2
82028: PUSH
82029: LD_INT 2
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 1
82038: PUSH
82039: LD_INT 2
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: LD_INT 1
82048: NEG
82049: PUSH
82050: LD_INT 1
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 2
82059: NEG
82060: PUSH
82061: LD_INT 0
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 2
82070: NEG
82071: PUSH
82072: LD_INT 1
82074: NEG
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 2
82082: NEG
82083: PUSH
82084: LD_INT 2
82086: NEG
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: NEG
82095: PUSH
82096: LD_INT 3
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 1
82106: PUSH
82107: LD_INT 2
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 3
82117: PUSH
82118: LD_INT 2
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 2
82127: PUSH
82128: LD_INT 3
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 2
82137: NEG
82138: PUSH
82139: LD_INT 1
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 3
82148: NEG
82149: PUSH
82150: LD_INT 1
82152: NEG
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82183: LD_ADDR_VAR 0 35
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: LD_INT 0
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 0
82200: PUSH
82201: LD_INT 1
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: PUSH
82212: LD_INT 0
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 1
82221: PUSH
82222: LD_INT 1
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 0
82231: PUSH
82232: LD_INT 1
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 1
82241: NEG
82242: PUSH
82243: LD_INT 0
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 1
82252: NEG
82253: PUSH
82254: LD_INT 1
82256: NEG
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 2
82264: PUSH
82265: LD_INT 1
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 2
82274: NEG
82275: PUSH
82276: LD_INT 1
82278: NEG
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
82295: LD_ADDR_VAR 0 36
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 0
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 0
82312: PUSH
82313: LD_INT 1
82315: NEG
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 1
82323: PUSH
82324: LD_INT 0
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 1
82333: PUSH
82334: LD_INT 1
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 0
82343: PUSH
82344: LD_INT 1
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: LD_INT 0
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 1
82364: NEG
82365: PUSH
82366: LD_INT 1
82368: NEG
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: LD_INT 2
82380: NEG
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 1
82388: PUSH
82389: LD_INT 2
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
82407: LD_ADDR_VAR 0 37
82411: PUSH
82412: LD_INT 0
82414: PUSH
82415: LD_INT 0
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: LD_INT 1
82427: NEG
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 1
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 1
82445: PUSH
82446: LD_INT 1
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: LD_INT 0
82455: PUSH
82456: LD_INT 1
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 1
82465: NEG
82466: PUSH
82467: LD_INT 0
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: LD_INT 1
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 1
82488: PUSH
82489: LD_INT 1
82491: NEG
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 1
82499: NEG
82500: PUSH
82501: LD_INT 1
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82519: LD_ADDR_VAR 0 38
82523: PUSH
82524: LD_INT 0
82526: PUSH
82527: LD_INT 0
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 0
82536: PUSH
82537: LD_INT 1
82539: NEG
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 1
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 1
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 0
82567: PUSH
82568: LD_INT 1
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 1
82577: NEG
82578: PUSH
82579: LD_INT 0
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 1
82588: NEG
82589: PUSH
82590: LD_INT 1
82592: NEG
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 2
82600: PUSH
82601: LD_INT 1
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 2
82610: NEG
82611: PUSH
82612: LD_INT 1
82614: NEG
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
82631: LD_ADDR_VAR 0 39
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: LD_INT 0
82648: PUSH
82649: LD_INT 1
82651: NEG
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 1
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 1
82669: PUSH
82670: LD_INT 1
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 0
82679: PUSH
82680: LD_INT 1
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 1
82689: NEG
82690: PUSH
82691: LD_INT 0
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 1
82700: NEG
82701: PUSH
82702: LD_INT 1
82704: NEG
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 1
82712: NEG
82713: PUSH
82714: LD_INT 2
82716: NEG
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 1
82724: PUSH
82725: LD_INT 2
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
82743: LD_ADDR_VAR 0 40
82747: PUSH
82748: LD_INT 0
82750: PUSH
82751: LD_INT 0
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 0
82760: PUSH
82761: LD_INT 1
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 1
82771: PUSH
82772: LD_INT 0
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 1
82781: PUSH
82782: LD_INT 1
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 0
82791: PUSH
82792: LD_INT 1
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 1
82801: NEG
82802: PUSH
82803: LD_INT 0
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 1
82812: NEG
82813: PUSH
82814: LD_INT 1
82816: NEG
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 1
82824: PUSH
82825: LD_INT 1
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: NEG
82836: PUSH
82837: LD_INT 1
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82855: LD_ADDR_VAR 0 41
82859: PUSH
82860: LD_INT 0
82862: PUSH
82863: LD_INT 0
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 0
82872: PUSH
82873: LD_INT 1
82875: NEG
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 1
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: LD_INT 1
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: LD_INT 1
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 1
82913: NEG
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 1
82924: NEG
82925: PUSH
82926: LD_INT 1
82928: NEG
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 1
82936: NEG
82937: PUSH
82938: LD_INT 2
82940: NEG
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 1
82948: PUSH
82949: LD_INT 1
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 2
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 2
82969: PUSH
82970: LD_INT 1
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 2
82979: PUSH
82980: LD_INT 2
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 1
82989: PUSH
82990: LD_INT 2
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 1
82999: NEG
83000: PUSH
83001: LD_INT 1
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: LD_INT 2
83010: NEG
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 2
83021: NEG
83022: PUSH
83023: LD_INT 1
83025: NEG
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 2
83033: NEG
83034: PUSH
83035: LD_INT 2
83037: NEG
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 2
83045: NEG
83046: PUSH
83047: LD_INT 3
83049: NEG
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 2
83057: PUSH
83058: LD_INT 1
83060: NEG
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 3
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 3
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 3
83088: PUSH
83089: LD_INT 2
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 3
83098: PUSH
83099: LD_INT 3
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 2
83108: PUSH
83109: LD_INT 3
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 2
83118: NEG
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 3
83129: NEG
83130: PUSH
83131: LD_INT 0
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 3
83140: NEG
83141: PUSH
83142: LD_INT 1
83144: NEG
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 3
83152: NEG
83153: PUSH
83154: LD_INT 2
83156: NEG
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 3
83164: NEG
83165: PUSH
83166: LD_INT 3
83168: NEG
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83205: LD_ADDR_VAR 0 42
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: LD_INT 0
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 0
83222: PUSH
83223: LD_INT 1
83225: NEG
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 1
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 1
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 0
83253: PUSH
83254: LD_INT 1
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 1
83263: NEG
83264: PUSH
83265: LD_INT 0
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: PUSH
83272: LD_INT 1
83274: NEG
83275: PUSH
83276: LD_INT 1
83278: NEG
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 1
83286: NEG
83287: PUSH
83288: LD_INT 2
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 0
83298: PUSH
83299: LD_INT 2
83301: NEG
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 1
83309: PUSH
83310: LD_INT 1
83312: NEG
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 2
83320: PUSH
83321: LD_INT 1
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 2
83330: PUSH
83331: LD_INT 2
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 1
83340: PUSH
83341: LD_INT 2
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 0
83350: PUSH
83351: LD_INT 2
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 1
83360: NEG
83361: PUSH
83362: LD_INT 1
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 2
83371: NEG
83372: PUSH
83373: LD_INT 1
83375: NEG
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: LD_INT 2
83383: NEG
83384: PUSH
83385: LD_INT 2
83387: NEG
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 2
83395: NEG
83396: PUSH
83397: LD_INT 3
83399: NEG
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: LD_INT 3
83411: NEG
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: LD_INT 3
83422: NEG
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 1
83430: PUSH
83431: LD_INT 2
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 3
83441: PUSH
83442: LD_INT 2
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 3
83451: PUSH
83452: LD_INT 3
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: PUSH
83462: LD_INT 3
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 1
83471: PUSH
83472: LD_INT 3
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 0
83481: PUSH
83482: LD_INT 3
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: NEG
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 3
83502: NEG
83503: PUSH
83504: LD_INT 2
83506: NEG
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 3
83514: NEG
83515: PUSH
83516: LD_INT 3
83518: NEG
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83555: LD_ADDR_VAR 0 43
83559: PUSH
83560: LD_INT 0
83562: PUSH
83563: LD_INT 0
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 0
83572: PUSH
83573: LD_INT 1
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 1
83583: PUSH
83584: LD_INT 0
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: LD_INT 1
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 0
83603: PUSH
83604: LD_INT 1
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 1
83613: NEG
83614: PUSH
83615: LD_INT 0
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 1
83624: NEG
83625: PUSH
83626: LD_INT 1
83628: NEG
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 1
83636: NEG
83637: PUSH
83638: LD_INT 2
83640: NEG
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 0
83648: PUSH
83649: LD_INT 2
83651: NEG
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 1
83659: PUSH
83660: LD_INT 1
83662: NEG
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: PUSH
83668: LD_INT 2
83670: PUSH
83671: LD_INT 0
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: PUSH
83678: LD_INT 2
83680: PUSH
83681: LD_INT 1
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 1
83690: PUSH
83691: LD_INT 2
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: PUSH
83698: LD_INT 0
83700: PUSH
83701: LD_INT 2
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: NEG
83711: PUSH
83712: LD_INT 1
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 2
83721: NEG
83722: PUSH
83723: LD_INT 0
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 2
83732: NEG
83733: PUSH
83734: LD_INT 1
83736: NEG
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 1
83744: NEG
83745: PUSH
83746: LD_INT 3
83748: NEG
83749: PUSH
83750: EMPTY
83751: LIST
83752: LIST
83753: PUSH
83754: LD_INT 0
83756: PUSH
83757: LD_INT 3
83759: NEG
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 1
83767: PUSH
83768: LD_INT 2
83770: NEG
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 2
83778: PUSH
83779: LD_INT 1
83781: NEG
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 3
83789: PUSH
83790: LD_INT 0
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 3
83799: PUSH
83800: LD_INT 1
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 1
83809: PUSH
83810: LD_INT 3
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: LD_INT 3
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 1
83829: NEG
83830: PUSH
83831: LD_INT 2
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 2
83840: NEG
83841: PUSH
83842: LD_INT 1
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: PUSH
83849: LD_INT 3
83851: NEG
83852: PUSH
83853: LD_INT 0
83855: PUSH
83856: EMPTY
83857: LIST
83858: LIST
83859: PUSH
83860: LD_INT 3
83862: NEG
83863: PUSH
83864: LD_INT 1
83866: NEG
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: LIST
83899: LIST
83900: LIST
83901: LIST
83902: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83903: LD_ADDR_VAR 0 44
83907: PUSH
83908: LD_INT 0
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 0
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 1
83931: PUSH
83932: LD_INT 0
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: LD_INT 1
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 0
83951: PUSH
83952: LD_INT 1
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 1
83961: NEG
83962: PUSH
83963: LD_INT 0
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 1
83972: NEG
83973: PUSH
83974: LD_INT 1
83976: NEG
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 1
83984: NEG
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 1
83996: PUSH
83997: LD_INT 1
83999: NEG
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 2
84007: PUSH
84008: LD_INT 0
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PUSH
84015: LD_INT 2
84017: PUSH
84018: LD_INT 1
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 2
84027: PUSH
84028: LD_INT 2
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 1
84037: PUSH
84038: LD_INT 2
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: NEG
84048: PUSH
84049: LD_INT 1
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 2
84058: NEG
84059: PUSH
84060: LD_INT 0
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: LD_INT 1
84073: NEG
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PUSH
84079: LD_INT 2
84081: NEG
84082: PUSH
84083: LD_INT 2
84085: NEG
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 2
84093: NEG
84094: PUSH
84095: LD_INT 3
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 2
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 3
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 3
84126: PUSH
84127: LD_INT 1
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 3
84136: PUSH
84137: LD_INT 2
84139: PUSH
84140: EMPTY
84141: LIST
84142: LIST
84143: PUSH
84144: LD_INT 3
84146: PUSH
84147: LD_INT 3
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 2
84156: PUSH
84157: LD_INT 3
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 2
84166: NEG
84167: PUSH
84168: LD_INT 1
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 3
84177: NEG
84178: PUSH
84179: LD_INT 0
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 3
84188: NEG
84189: PUSH
84190: LD_INT 1
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 3
84200: NEG
84201: PUSH
84202: LD_INT 2
84204: NEG
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: LD_INT 3
84212: NEG
84213: PUSH
84214: LD_INT 3
84216: NEG
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: LIST
84252: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84253: LD_ADDR_VAR 0 45
84257: PUSH
84258: LD_INT 0
84260: PUSH
84261: LD_INT 0
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: PUSH
84268: LD_INT 0
84270: PUSH
84271: LD_INT 1
84273: NEG
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 1
84281: PUSH
84282: LD_INT 0
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 1
84291: PUSH
84292: LD_INT 1
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 0
84301: PUSH
84302: LD_INT 1
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 1
84311: NEG
84312: PUSH
84313: LD_INT 0
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: LD_INT 1
84326: NEG
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 1
84334: NEG
84335: PUSH
84336: LD_INT 2
84338: NEG
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: LD_INT 2
84349: NEG
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 1
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 2
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 2
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 0
84398: PUSH
84399: LD_INT 2
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: PUSH
84406: LD_INT 1
84408: NEG
84409: PUSH
84410: LD_INT 1
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 2
84419: NEG
84420: PUSH
84421: LD_INT 1
84423: NEG
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 2
84431: NEG
84432: PUSH
84433: LD_INT 2
84435: NEG
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 2
84443: NEG
84444: PUSH
84445: LD_INT 3
84447: NEG
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: LD_INT 3
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 0
84467: PUSH
84468: LD_INT 3
84470: NEG
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 1
84478: PUSH
84479: LD_INT 2
84481: NEG
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 3
84489: PUSH
84490: LD_INT 2
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 3
84499: PUSH
84500: LD_INT 3
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 2
84509: PUSH
84510: LD_INT 3
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 1
84519: PUSH
84520: LD_INT 3
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: LD_INT 3
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 1
84539: NEG
84540: PUSH
84541: LD_INT 2
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 3
84550: NEG
84551: PUSH
84552: LD_INT 2
84554: NEG
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 3
84562: NEG
84563: PUSH
84564: LD_INT 3
84566: NEG
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84603: LD_ADDR_VAR 0 46
84607: PUSH
84608: LD_INT 0
84610: PUSH
84611: LD_INT 0
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 0
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 1
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 0
84651: PUSH
84652: LD_INT 1
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: LD_INT 1
84672: NEG
84673: PUSH
84674: LD_INT 1
84676: NEG
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 1
84684: NEG
84685: PUSH
84686: LD_INT 2
84688: NEG
84689: PUSH
84690: EMPTY
84691: LIST
84692: LIST
84693: PUSH
84694: LD_INT 0
84696: PUSH
84697: LD_INT 2
84699: NEG
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 1
84707: PUSH
84708: LD_INT 1
84710: NEG
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: PUSH
84716: LD_INT 2
84718: PUSH
84719: LD_INT 0
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 2
84728: PUSH
84729: LD_INT 1
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 1
84738: PUSH
84739: LD_INT 2
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: LD_INT 0
84748: PUSH
84749: LD_INT 2
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 1
84758: NEG
84759: PUSH
84760: LD_INT 1
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 2
84769: NEG
84770: PUSH
84771: LD_INT 0
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 2
84780: NEG
84781: PUSH
84782: LD_INT 1
84784: NEG
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 1
84792: NEG
84793: PUSH
84794: LD_INT 3
84796: NEG
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 0
84804: PUSH
84805: LD_INT 3
84807: NEG
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 1
84815: PUSH
84816: LD_INT 2
84818: NEG
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: LD_INT 1
84829: NEG
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 3
84837: PUSH
84838: LD_INT 0
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 3
84847: PUSH
84848: LD_INT 1
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 1
84857: PUSH
84858: LD_INT 3
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_INT 0
84867: PUSH
84868: LD_INT 3
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: NEG
84878: PUSH
84879: LD_INT 2
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: NEG
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 3
84899: NEG
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 3
84910: NEG
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84951: LD_ADDR_VAR 0 47
84955: PUSH
84956: LD_INT 0
84958: PUSH
84959: LD_INT 0
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: PUSH
84966: LD_INT 0
84968: PUSH
84969: LD_INT 1
84971: NEG
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 1
84979: PUSH
84980: LD_INT 0
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 0
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 1
85009: NEG
85010: PUSH
85011: LD_INT 0
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: NEG
85021: PUSH
85022: LD_INT 1
85024: NEG
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: NEG
85033: PUSH
85034: LD_INT 2
85036: NEG
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: PUSH
85042: LD_INT 0
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 1
85055: PUSH
85056: LD_INT 1
85058: NEG
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 2
85066: NEG
85067: PUSH
85068: LD_INT 1
85070: NEG
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: PUSH
85076: LD_INT 2
85078: NEG
85079: PUSH
85080: LD_INT 2
85082: NEG
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85102: LD_ADDR_VAR 0 48
85106: PUSH
85107: LD_INT 0
85109: PUSH
85110: LD_INT 0
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 0
85119: PUSH
85120: LD_INT 1
85122: NEG
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: PUSH
85128: LD_INT 1
85130: PUSH
85131: LD_INT 0
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 1
85140: PUSH
85141: LD_INT 1
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: PUSH
85148: LD_INT 0
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 1
85160: NEG
85161: PUSH
85162: LD_INT 0
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: NEG
85172: PUSH
85173: LD_INT 1
85175: NEG
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 1
85183: NEG
85184: PUSH
85185: LD_INT 2
85187: NEG
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: LD_INT 2
85198: NEG
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 1
85206: PUSH
85207: LD_INT 1
85209: NEG
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 2
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 2
85227: PUSH
85228: LD_INT 1
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85249: LD_ADDR_VAR 0 49
85253: PUSH
85254: LD_INT 0
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 0
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 1
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 1
85287: PUSH
85288: LD_INT 1
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 0
85297: PUSH
85298: LD_INT 1
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 1
85307: NEG
85308: PUSH
85309: LD_INT 0
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 1
85318: NEG
85319: PUSH
85320: LD_INT 1
85322: NEG
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 1
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 2
85341: PUSH
85342: LD_INT 0
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 2
85351: PUSH
85352: LD_INT 1
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: PUSH
85359: LD_INT 2
85361: PUSH
85362: LD_INT 2
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 1
85371: PUSH
85372: LD_INT 2
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
85393: LD_ADDR_VAR 0 50
85397: PUSH
85398: LD_INT 0
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: LD_INT 1
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 1
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 1
85431: PUSH
85432: LD_INT 1
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 0
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 1
85451: NEG
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 1
85462: NEG
85463: PUSH
85464: LD_INT 1
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 2
85474: PUSH
85475: LD_INT 1
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 2
85484: PUSH
85485: LD_INT 2
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 1
85494: PUSH
85495: LD_INT 2
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: PUSH
85502: LD_INT 0
85504: PUSH
85505: LD_INT 2
85507: PUSH
85508: EMPTY
85509: LIST
85510: LIST
85511: PUSH
85512: LD_INT 1
85514: NEG
85515: PUSH
85516: LD_INT 1
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
85537: LD_ADDR_VAR 0 51
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: LD_INT 0
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 0
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: LD_INT 0
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 1
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 0
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 1
85595: NEG
85596: PUSH
85597: LD_INT 0
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 1
85606: NEG
85607: PUSH
85608: LD_INT 1
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: LD_INT 2
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 0
85628: PUSH
85629: LD_INT 2
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 1
85638: NEG
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 2
85649: NEG
85650: PUSH
85651: LD_INT 0
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 2
85660: NEG
85661: PUSH
85662: LD_INT 1
85664: NEG
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: EMPTY
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85684: LD_ADDR_VAR 0 52
85688: PUSH
85689: LD_INT 0
85691: PUSH
85692: LD_INT 0
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: LD_INT 0
85701: PUSH
85702: LD_INT 1
85704: NEG
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 1
85712: PUSH
85713: LD_INT 0
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 1
85722: PUSH
85723: LD_INT 1
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 0
85732: PUSH
85733: LD_INT 1
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: PUSH
85740: LD_INT 1
85742: NEG
85743: PUSH
85744: LD_INT 0
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 1
85753: NEG
85754: PUSH
85755: LD_INT 1
85757: NEG
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 1
85765: NEG
85766: PUSH
85767: LD_INT 2
85769: NEG
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PUSH
85775: LD_INT 1
85777: NEG
85778: PUSH
85779: LD_INT 1
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 2
85788: NEG
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 2
85799: NEG
85800: PUSH
85801: LD_INT 1
85803: NEG
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 2
85811: NEG
85812: PUSH
85813: LD_INT 2
85815: NEG
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85835: LD_ADDR_VAR 0 53
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: LD_INT 0
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: PUSH
85864: LD_INT 0
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 1
85873: PUSH
85874: LD_INT 1
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: LD_INT 1
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 1
85893: NEG
85894: PUSH
85895: LD_INT 0
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 1
85904: NEG
85905: PUSH
85906: LD_INT 1
85908: NEG
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: LD_INT 2
85920: NEG
85921: PUSH
85922: EMPTY
85923: LIST
85924: LIST
85925: PUSH
85926: LD_INT 0
85928: PUSH
85929: LD_INT 2
85931: NEG
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: LD_INT 1
85942: NEG
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 2
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 2
85960: PUSH
85961: LD_INT 1
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 2
85970: PUSH
85971: LD_INT 2
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: LD_INT 2
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 0
85990: PUSH
85991: LD_INT 2
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: NEG
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 2
86011: NEG
86012: PUSH
86013: LD_INT 0
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 2
86022: NEG
86023: PUSH
86024: LD_INT 1
86026: NEG
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 2
86034: NEG
86035: PUSH
86036: LD_INT 2
86038: NEG
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86065: LD_ADDR_VAR 0 54
86069: PUSH
86070: LD_INT 0
86072: PUSH
86073: LD_INT 0
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 0
86082: PUSH
86083: LD_INT 1
86085: NEG
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: LD_INT 1
86093: PUSH
86094: LD_INT 0
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PUSH
86101: LD_INT 1
86103: PUSH
86104: LD_INT 1
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 0
86113: PUSH
86114: LD_INT 1
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: NEG
86124: PUSH
86125: LD_INT 0
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: LD_INT 1
86134: NEG
86135: PUSH
86136: LD_INT 1
86138: NEG
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PUSH
86144: LD_INT 1
86146: NEG
86147: PUSH
86148: LD_INT 2
86150: NEG
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 0
86158: PUSH
86159: LD_INT 2
86161: NEG
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 1
86169: PUSH
86170: LD_INT 1
86172: NEG
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 2
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 2
86190: PUSH
86191: LD_INT 1
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 2
86200: PUSH
86201: LD_INT 2
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: PUSH
86211: LD_INT 2
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 0
86220: PUSH
86221: LD_INT 2
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: LD_INT 1
86230: NEG
86231: PUSH
86232: LD_INT 1
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 2
86241: NEG
86242: PUSH
86243: LD_INT 0
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 2
86252: NEG
86253: PUSH
86254: LD_INT 1
86256: NEG
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 2
86264: NEG
86265: PUSH
86266: LD_INT 2
86268: NEG
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: LIST
86283: LIST
86284: LIST
86285: LIST
86286: LIST
86287: LIST
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: LIST
86294: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86295: LD_ADDR_VAR 0 55
86299: PUSH
86300: LD_INT 0
86302: PUSH
86303: LD_INT 0
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 0
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 1
86323: PUSH
86324: LD_INT 0
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 1
86333: PUSH
86334: LD_INT 1
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 0
86343: PUSH
86344: LD_INT 1
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: PUSH
86351: LD_INT 1
86353: NEG
86354: PUSH
86355: LD_INT 0
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: PUSH
86362: LD_INT 1
86364: NEG
86365: PUSH
86366: LD_INT 1
86368: NEG
86369: PUSH
86370: EMPTY
86371: LIST
86372: LIST
86373: PUSH
86374: LD_INT 1
86376: NEG
86377: PUSH
86378: LD_INT 2
86380: NEG
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 0
86388: PUSH
86389: LD_INT 2
86391: NEG
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 1
86399: PUSH
86400: LD_INT 1
86402: NEG
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 2
86410: PUSH
86411: LD_INT 0
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 2
86420: PUSH
86421: LD_INT 1
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 2
86430: PUSH
86431: LD_INT 2
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 1
86440: PUSH
86441: LD_INT 2
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 0
86450: PUSH
86451: LD_INT 2
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 1
86460: NEG
86461: PUSH
86462: LD_INT 1
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 2
86471: NEG
86472: PUSH
86473: LD_INT 0
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 2
86482: NEG
86483: PUSH
86484: LD_INT 1
86486: NEG
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 2
86494: NEG
86495: PUSH
86496: LD_INT 2
86498: NEG
86499: PUSH
86500: EMPTY
86501: LIST
86502: LIST
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86525: LD_ADDR_VAR 0 56
86529: PUSH
86530: LD_INT 0
86532: PUSH
86533: LD_INT 0
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 1
86545: NEG
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 1
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: PUSH
86564: LD_INT 1
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 0
86573: PUSH
86574: LD_INT 1
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: NEG
86584: PUSH
86585: LD_INT 0
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PUSH
86592: LD_INT 1
86594: NEG
86595: PUSH
86596: LD_INT 1
86598: NEG
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 1
86606: NEG
86607: PUSH
86608: LD_INT 2
86610: NEG
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: LD_INT 2
86621: NEG
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: LD_INT 1
86629: PUSH
86630: LD_INT 1
86632: NEG
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: PUSH
86638: LD_INT 2
86640: PUSH
86641: LD_INT 0
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 2
86650: PUSH
86651: LD_INT 1
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 2
86660: PUSH
86661: LD_INT 2
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: PUSH
86668: LD_INT 1
86670: PUSH
86671: LD_INT 2
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 0
86680: PUSH
86681: LD_INT 2
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 1
86690: NEG
86691: PUSH
86692: LD_INT 1
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 2
86701: NEG
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 2
86712: NEG
86713: PUSH
86714: LD_INT 1
86716: NEG
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 2
86724: NEG
86725: PUSH
86726: LD_INT 2
86728: NEG
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86755: LD_ADDR_VAR 0 57
86759: PUSH
86760: LD_INT 0
86762: PUSH
86763: LD_INT 0
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: PUSH
86770: LD_INT 0
86772: PUSH
86773: LD_INT 1
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: LD_INT 0
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: LD_INT 1
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 0
86803: PUSH
86804: LD_INT 1
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 1
86813: NEG
86814: PUSH
86815: LD_INT 0
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: PUSH
86822: LD_INT 1
86824: NEG
86825: PUSH
86826: LD_INT 1
86828: NEG
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 1
86836: NEG
86837: PUSH
86838: LD_INT 2
86840: NEG
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 0
86848: PUSH
86849: LD_INT 2
86851: NEG
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 1
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 2
86870: PUSH
86871: LD_INT 0
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 2
86880: PUSH
86881: LD_INT 1
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 2
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 1
86900: PUSH
86901: LD_INT 2
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 0
86910: PUSH
86911: LD_INT 2
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 1
86920: NEG
86921: PUSH
86922: LD_INT 1
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 2
86931: NEG
86932: PUSH
86933: LD_INT 0
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 2
86942: NEG
86943: PUSH
86944: LD_INT 1
86946: NEG
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 2
86954: NEG
86955: PUSH
86956: LD_INT 2
86958: NEG
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86985: LD_ADDR_VAR 0 58
86989: PUSH
86990: LD_INT 0
86992: PUSH
86993: LD_INT 0
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 0
87002: PUSH
87003: LD_INT 1
87005: NEG
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 1
87013: PUSH
87014: LD_INT 0
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 1
87023: PUSH
87024: LD_INT 1
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 0
87033: PUSH
87034: LD_INT 1
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 1
87043: NEG
87044: PUSH
87045: LD_INT 0
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: LD_INT 1
87054: NEG
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 1
87066: NEG
87067: PUSH
87068: LD_INT 2
87070: NEG
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: LD_INT 2
87081: NEG
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: PUSH
87090: LD_INT 1
87092: NEG
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 2
87100: PUSH
87101: LD_INT 0
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 2
87110: PUSH
87111: LD_INT 1
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: PUSH
87118: LD_INT 2
87120: PUSH
87121: LD_INT 2
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: LD_INT 1
87130: PUSH
87131: LD_INT 2
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 0
87140: PUSH
87141: LD_INT 2
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 1
87150: NEG
87151: PUSH
87152: LD_INT 1
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 2
87161: NEG
87162: PUSH
87163: LD_INT 0
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 2
87172: NEG
87173: PUSH
87174: LD_INT 1
87176: NEG
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 2
87184: NEG
87185: PUSH
87186: LD_INT 2
87188: NEG
87189: PUSH
87190: EMPTY
87191: LIST
87192: LIST
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87215: LD_ADDR_VAR 0 59
87219: PUSH
87220: LD_INT 0
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 0
87232: PUSH
87233: LD_INT 1
87235: NEG
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 1
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: LD_INT 1
87253: PUSH
87254: LD_INT 1
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 0
87263: PUSH
87264: LD_INT 1
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 1
87273: NEG
87274: PUSH
87275: LD_INT 0
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 1
87284: NEG
87285: PUSH
87286: LD_INT 1
87288: NEG
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: LIST
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87303: LD_ADDR_VAR 0 60
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: LD_INT 0
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 0
87320: PUSH
87321: LD_INT 1
87323: NEG
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 1
87331: PUSH
87332: LD_INT 0
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 1
87341: PUSH
87342: LD_INT 1
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 0
87351: PUSH
87352: LD_INT 1
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 1
87361: NEG
87362: PUSH
87363: LD_INT 0
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: NEG
87373: PUSH
87374: LD_INT 1
87376: NEG
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87391: LD_ADDR_VAR 0 61
87395: PUSH
87396: LD_INT 0
87398: PUSH
87399: LD_INT 0
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: LD_INT 1
87411: NEG
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 1
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 1
87429: PUSH
87430: LD_INT 1
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 0
87439: PUSH
87440: LD_INT 1
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: LD_INT 1
87449: NEG
87450: PUSH
87451: LD_INT 0
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 1
87460: NEG
87461: PUSH
87462: LD_INT 1
87464: NEG
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87479: LD_ADDR_VAR 0 62
87483: PUSH
87484: LD_INT 0
87486: PUSH
87487: LD_INT 0
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PUSH
87494: LD_INT 0
87496: PUSH
87497: LD_INT 1
87499: NEG
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: LD_INT 0
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 1
87517: PUSH
87518: LD_INT 1
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PUSH
87525: LD_INT 0
87527: PUSH
87528: LD_INT 1
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: NEG
87538: PUSH
87539: LD_INT 0
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 1
87548: NEG
87549: PUSH
87550: LD_INT 1
87552: NEG
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87567: LD_ADDR_VAR 0 63
87571: PUSH
87572: LD_INT 0
87574: PUSH
87575: LD_INT 0
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 0
87584: PUSH
87585: LD_INT 1
87587: NEG
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 1
87595: PUSH
87596: LD_INT 0
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 1
87605: PUSH
87606: LD_INT 1
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 0
87615: PUSH
87616: LD_INT 1
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 1
87625: NEG
87626: PUSH
87627: LD_INT 0
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 1
87636: NEG
87637: PUSH
87638: LD_INT 1
87640: NEG
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: LIST
87650: LIST
87651: LIST
87652: LIST
87653: LIST
87654: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87655: LD_ADDR_VAR 0 64
87659: PUSH
87660: LD_INT 0
87662: PUSH
87663: LD_INT 0
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 0
87672: PUSH
87673: LD_INT 1
87675: NEG
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 1
87683: PUSH
87684: LD_INT 0
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 1
87693: PUSH
87694: LD_INT 1
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 0
87703: PUSH
87704: LD_INT 1
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: LD_INT 0
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 1
87724: NEG
87725: PUSH
87726: LD_INT 1
87728: NEG
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: ST_TO_ADDR
// end ; 1 :
87743: GO 93640
87745: LD_INT 1
87747: DOUBLE
87748: EQUAL
87749: IFTRUE 87753
87751: GO 90376
87753: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
87754: LD_ADDR_VAR 0 11
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 3
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 3
87776: NEG
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 1
87784: PUSH
87785: LD_INT 2
87787: NEG
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: LIST
87797: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87798: LD_ADDR_VAR 0 12
87802: PUSH
87803: LD_INT 2
87805: PUSH
87806: LD_INT 1
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 3
87816: PUSH
87817: LD_INT 0
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 3
87826: PUSH
87827: LD_INT 1
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: LIST
87838: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
87839: LD_ADDR_VAR 0 13
87843: PUSH
87844: LD_INT 3
87846: PUSH
87847: LD_INT 2
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 3
87856: PUSH
87857: LD_INT 3
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 2
87866: PUSH
87867: LD_INT 3
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: LIST
87878: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
87879: LD_ADDR_VAR 0 14
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: LD_INT 3
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: LD_INT 3
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PUSH
87904: LD_INT 1
87906: NEG
87907: PUSH
87908: LD_INT 2
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: LIST
87919: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87920: LD_ADDR_VAR 0 15
87924: PUSH
87925: LD_INT 2
87927: NEG
87928: PUSH
87929: LD_INT 1
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 3
87938: NEG
87939: PUSH
87940: LD_INT 0
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: LD_INT 3
87949: NEG
87950: PUSH
87951: LD_INT 1
87953: NEG
87954: PUSH
87955: EMPTY
87956: LIST
87957: LIST
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: LIST
87963: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87964: LD_ADDR_VAR 0 16
87968: PUSH
87969: LD_INT 2
87971: NEG
87972: PUSH
87973: LD_INT 3
87975: NEG
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 3
87983: NEG
87984: PUSH
87985: LD_INT 2
87987: NEG
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 3
87995: NEG
87996: PUSH
87997: LD_INT 3
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: LIST
88009: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88010: LD_ADDR_VAR 0 17
88014: PUSH
88015: LD_INT 1
88017: NEG
88018: PUSH
88019: LD_INT 3
88021: NEG
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 0
88029: PUSH
88030: LD_INT 3
88032: NEG
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 1
88040: PUSH
88041: LD_INT 2
88043: NEG
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: LIST
88053: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88054: LD_ADDR_VAR 0 18
88058: PUSH
88059: LD_INT 2
88061: PUSH
88062: LD_INT 1
88064: NEG
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 3
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 3
88082: PUSH
88083: LD_INT 1
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: LIST
88094: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88095: LD_ADDR_VAR 0 19
88099: PUSH
88100: LD_INT 3
88102: PUSH
88103: LD_INT 2
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 3
88112: PUSH
88113: LD_INT 3
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 2
88122: PUSH
88123: LD_INT 3
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: LIST
88134: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88135: LD_ADDR_VAR 0 20
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: LD_INT 3
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: LD_INT 3
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: NEG
88163: PUSH
88164: LD_INT 2
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: LIST
88175: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88176: LD_ADDR_VAR 0 21
88180: PUSH
88181: LD_INT 2
88183: NEG
88184: PUSH
88185: LD_INT 1
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: LD_INT 3
88194: NEG
88195: PUSH
88196: LD_INT 0
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 3
88205: NEG
88206: PUSH
88207: LD_INT 1
88209: NEG
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: LIST
88219: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88220: LD_ADDR_VAR 0 22
88224: PUSH
88225: LD_INT 2
88227: NEG
88228: PUSH
88229: LD_INT 3
88231: NEG
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 3
88239: NEG
88240: PUSH
88241: LD_INT 2
88243: NEG
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 3
88251: NEG
88252: PUSH
88253: LD_INT 3
88255: NEG
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: LIST
88265: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
88266: LD_ADDR_VAR 0 23
88270: PUSH
88271: LD_INT 0
88273: PUSH
88274: LD_INT 3
88276: NEG
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 1
88284: NEG
88285: PUSH
88286: LD_INT 4
88288: NEG
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PUSH
88294: LD_INT 1
88296: PUSH
88297: LD_INT 3
88299: NEG
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: LIST
88309: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
88310: LD_ADDR_VAR 0 24
88314: PUSH
88315: LD_INT 3
88317: PUSH
88318: LD_INT 0
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: PUSH
88325: LD_INT 3
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 4
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: LIST
88350: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
88351: LD_ADDR_VAR 0 25
88355: PUSH
88356: LD_INT 3
88358: PUSH
88359: LD_INT 3
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 4
88368: PUSH
88369: LD_INT 3
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 3
88378: PUSH
88379: LD_INT 4
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: LIST
88390: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
88391: LD_ADDR_VAR 0 26
88395: PUSH
88396: LD_INT 0
88398: PUSH
88399: LD_INT 3
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: PUSH
88406: LD_INT 1
88408: PUSH
88409: LD_INT 4
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 1
88418: NEG
88419: PUSH
88420: LD_INT 3
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: LIST
88431: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
88432: LD_ADDR_VAR 0 27
88436: PUSH
88437: LD_INT 3
88439: NEG
88440: PUSH
88441: LD_INT 0
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 3
88450: NEG
88451: PUSH
88452: LD_INT 1
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 4
88461: NEG
88462: PUSH
88463: LD_INT 1
88465: NEG
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: LIST
88475: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
88476: LD_ADDR_VAR 0 28
88480: PUSH
88481: LD_INT 3
88483: NEG
88484: PUSH
88485: LD_INT 3
88487: NEG
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 3
88495: NEG
88496: PUSH
88497: LD_INT 4
88499: NEG
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 4
88507: NEG
88508: PUSH
88509: LD_INT 3
88511: NEG
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: LIST
88521: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
88522: LD_ADDR_VAR 0 29
88526: PUSH
88527: LD_INT 1
88529: NEG
88530: PUSH
88531: LD_INT 3
88533: NEG
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 0
88541: PUSH
88542: LD_INT 3
88544: NEG
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: LD_INT 2
88555: NEG
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 1
88563: NEG
88564: PUSH
88565: LD_INT 4
88567: NEG
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: PUSH
88573: LD_INT 0
88575: PUSH
88576: LD_INT 4
88578: NEG
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 1
88586: PUSH
88587: LD_INT 3
88589: NEG
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: PUSH
88595: LD_INT 1
88597: NEG
88598: PUSH
88599: LD_INT 5
88601: NEG
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 0
88609: PUSH
88610: LD_INT 5
88612: NEG
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 1
88620: PUSH
88621: LD_INT 4
88623: NEG
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: LD_INT 1
88631: NEG
88632: PUSH
88633: LD_INT 6
88635: NEG
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: LD_INT 6
88646: NEG
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: LD_INT 5
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
88677: LD_ADDR_VAR 0 30
88681: PUSH
88682: LD_INT 2
88684: PUSH
88685: LD_INT 1
88687: NEG
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PUSH
88693: LD_INT 3
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 3
88705: PUSH
88706: LD_INT 1
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 3
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 4
88726: PUSH
88727: LD_INT 0
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 4
88736: PUSH
88737: LD_INT 1
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 4
88746: PUSH
88747: LD_INT 1
88749: NEG
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 5
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 5
88767: PUSH
88768: LD_INT 1
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 5
88777: PUSH
88778: LD_INT 1
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 6
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 6
88798: PUSH
88799: LD_INT 1
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
88820: LD_ADDR_VAR 0 31
88824: PUSH
88825: LD_INT 3
88827: PUSH
88828: LD_INT 2
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 3
88837: PUSH
88838: LD_INT 3
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 2
88847: PUSH
88848: LD_INT 3
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 4
88857: PUSH
88858: LD_INT 3
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 4
88867: PUSH
88868: LD_INT 4
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 3
88877: PUSH
88878: LD_INT 4
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: PUSH
88885: LD_INT 5
88887: PUSH
88888: LD_INT 4
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 5
88897: PUSH
88898: LD_INT 5
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 4
88907: PUSH
88908: LD_INT 5
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 6
88917: PUSH
88918: LD_INT 5
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 6
88927: PUSH
88928: LD_INT 6
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 5
88937: PUSH
88938: LD_INT 6
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
88959: LD_ADDR_VAR 0 32
88963: PUSH
88964: LD_INT 1
88966: PUSH
88967: LD_INT 3
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: LD_INT 3
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 1
88986: NEG
88987: PUSH
88988: LD_INT 2
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 1
88997: PUSH
88998: LD_INT 4
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: LD_INT 4
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: NEG
89018: PUSH
89019: LD_INT 3
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 1
89028: PUSH
89029: LD_INT 5
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 0
89038: PUSH
89039: LD_INT 5
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 1
89048: NEG
89049: PUSH
89050: LD_INT 4
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: PUSH
89060: LD_INT 6
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 0
89069: PUSH
89070: LD_INT 6
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: NEG
89080: PUSH
89081: LD_INT 5
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
89102: LD_ADDR_VAR 0 33
89106: PUSH
89107: LD_INT 2
89109: NEG
89110: PUSH
89111: LD_INT 1
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 3
89120: NEG
89121: PUSH
89122: LD_INT 0
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: LD_INT 3
89131: NEG
89132: PUSH
89133: LD_INT 1
89135: NEG
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 3
89143: NEG
89144: PUSH
89145: LD_INT 1
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 4
89154: NEG
89155: PUSH
89156: LD_INT 0
89158: PUSH
89159: EMPTY
89160: LIST
89161: LIST
89162: PUSH
89163: LD_INT 4
89165: NEG
89166: PUSH
89167: LD_INT 1
89169: NEG
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 4
89177: NEG
89178: PUSH
89179: LD_INT 1
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: PUSH
89186: LD_INT 5
89188: NEG
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 5
89199: NEG
89200: PUSH
89201: LD_INT 1
89203: NEG
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: PUSH
89209: LD_INT 5
89211: NEG
89212: PUSH
89213: LD_INT 1
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 6
89222: NEG
89223: PUSH
89224: LD_INT 0
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 6
89233: NEG
89234: PUSH
89235: LD_INT 1
89237: NEG
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
89257: LD_ADDR_VAR 0 34
89261: PUSH
89262: LD_INT 2
89264: NEG
89265: PUSH
89266: LD_INT 3
89268: NEG
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 3
89276: NEG
89277: PUSH
89278: LD_INT 2
89280: NEG
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: PUSH
89286: LD_INT 3
89288: NEG
89289: PUSH
89290: LD_INT 3
89292: NEG
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 3
89300: NEG
89301: PUSH
89302: LD_INT 4
89304: NEG
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 4
89312: NEG
89313: PUSH
89314: LD_INT 3
89316: NEG
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: LD_INT 4
89324: NEG
89325: PUSH
89326: LD_INT 4
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 4
89336: NEG
89337: PUSH
89338: LD_INT 5
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 5
89348: NEG
89349: PUSH
89350: LD_INT 4
89352: NEG
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 5
89360: NEG
89361: PUSH
89362: LD_INT 5
89364: NEG
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 5
89372: NEG
89373: PUSH
89374: LD_INT 6
89376: NEG
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 6
89384: NEG
89385: PUSH
89386: LD_INT 5
89388: NEG
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 6
89396: NEG
89397: PUSH
89398: LD_INT 6
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
89420: LD_ADDR_VAR 0 41
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: LD_INT 2
89430: NEG
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: NEG
89439: PUSH
89440: LD_INT 3
89442: NEG
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 1
89450: PUSH
89451: LD_INT 2
89453: NEG
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: LIST
89463: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
89464: LD_ADDR_VAR 0 42
89468: PUSH
89469: LD_INT 2
89471: PUSH
89472: LD_INT 0
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 2
89481: PUSH
89482: LD_INT 1
89484: NEG
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 3
89492: PUSH
89493: LD_INT 1
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: LIST
89504: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
89505: LD_ADDR_VAR 0 43
89509: PUSH
89510: LD_INT 2
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 3
89522: PUSH
89523: LD_INT 2
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 2
89532: PUSH
89533: LD_INT 3
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: LIST
89544: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
89545: LD_ADDR_VAR 0 44
89549: PUSH
89550: LD_INT 0
89552: PUSH
89553: LD_INT 2
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 1
89562: PUSH
89563: LD_INT 3
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 1
89572: NEG
89573: PUSH
89574: LD_INT 2
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: LIST
89585: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89586: LD_ADDR_VAR 0 45
89590: PUSH
89591: LD_INT 2
89593: NEG
89594: PUSH
89595: LD_INT 0
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 2
89604: NEG
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: PUSH
89613: LD_INT 3
89615: NEG
89616: PUSH
89617: LD_INT 1
89619: NEG
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: LIST
89629: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
89630: LD_ADDR_VAR 0 46
89634: PUSH
89635: LD_INT 2
89637: NEG
89638: PUSH
89639: LD_INT 2
89641: NEG
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: PUSH
89647: LD_INT 2
89649: NEG
89650: PUSH
89651: LD_INT 3
89653: NEG
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: PUSH
89659: LD_INT 3
89661: NEG
89662: PUSH
89663: LD_INT 2
89665: NEG
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: LIST
89675: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
89676: LD_ADDR_VAR 0 47
89680: PUSH
89681: LD_INT 2
89683: NEG
89684: PUSH
89685: LD_INT 3
89687: NEG
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 1
89695: NEG
89696: PUSH
89697: LD_INT 3
89699: NEG
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
89709: LD_ADDR_VAR 0 48
89713: PUSH
89714: LD_INT 1
89716: PUSH
89717: LD_INT 2
89719: NEG
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: PUSH
89725: LD_INT 2
89727: PUSH
89728: LD_INT 1
89730: NEG
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
89740: LD_ADDR_VAR 0 49
89744: PUSH
89745: LD_INT 3
89747: PUSH
89748: LD_INT 1
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 3
89757: PUSH
89758: LD_INT 2
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
89769: LD_ADDR_VAR 0 50
89773: PUSH
89774: LD_INT 2
89776: PUSH
89777: LD_INT 3
89779: PUSH
89780: EMPTY
89781: LIST
89782: LIST
89783: PUSH
89784: LD_INT 1
89786: PUSH
89787: LD_INT 3
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
89798: LD_ADDR_VAR 0 51
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: LD_INT 2
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: LD_INT 2
89816: NEG
89817: PUSH
89818: LD_INT 1
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89829: LD_ADDR_VAR 0 52
89833: PUSH
89834: LD_INT 3
89836: NEG
89837: PUSH
89838: LD_INT 1
89840: NEG
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 3
89848: NEG
89849: PUSH
89850: LD_INT 2
89852: NEG
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89862: LD_ADDR_VAR 0 53
89866: PUSH
89867: LD_INT 1
89869: NEG
89870: PUSH
89871: LD_INT 3
89873: NEG
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 0
89881: PUSH
89882: LD_INT 3
89884: NEG
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 1
89892: PUSH
89893: LD_INT 2
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: LIST
89905: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89906: LD_ADDR_VAR 0 54
89910: PUSH
89911: LD_INT 2
89913: PUSH
89914: LD_INT 1
89916: NEG
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 3
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 3
89934: PUSH
89935: LD_INT 1
89937: PUSH
89938: EMPTY
89939: LIST
89940: LIST
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: LIST
89946: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89947: LD_ADDR_VAR 0 55
89951: PUSH
89952: LD_INT 3
89954: PUSH
89955: LD_INT 2
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 3
89964: PUSH
89965: LD_INT 3
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 2
89974: PUSH
89975: LD_INT 3
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: LIST
89986: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89987: LD_ADDR_VAR 0 56
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 3
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: LD_INT 3
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 1
90014: NEG
90015: PUSH
90016: LD_INT 2
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: LIST
90027: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90028: LD_ADDR_VAR 0 57
90032: PUSH
90033: LD_INT 2
90035: NEG
90036: PUSH
90037: LD_INT 1
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 3
90046: NEG
90047: PUSH
90048: LD_INT 0
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 3
90057: NEG
90058: PUSH
90059: LD_INT 1
90061: NEG
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: LIST
90071: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90072: LD_ADDR_VAR 0 58
90076: PUSH
90077: LD_INT 2
90079: NEG
90080: PUSH
90081: LD_INT 3
90083: NEG
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 3
90091: NEG
90092: PUSH
90093: LD_INT 2
90095: NEG
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 3
90103: NEG
90104: PUSH
90105: LD_INT 3
90107: NEG
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: LIST
90117: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
90118: LD_ADDR_VAR 0 59
90122: PUSH
90123: LD_INT 1
90125: NEG
90126: PUSH
90127: LD_INT 2
90129: NEG
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 0
90137: PUSH
90138: LD_INT 2
90140: NEG
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: LD_INT 1
90151: NEG
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: LIST
90161: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90162: LD_ADDR_VAR 0 60
90166: PUSH
90167: LD_INT 1
90169: PUSH
90170: LD_INT 1
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 2
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 2
90190: PUSH
90191: LD_INT 1
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: LIST
90202: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90203: LD_ADDR_VAR 0 61
90207: PUSH
90208: LD_INT 2
90210: PUSH
90211: LD_INT 1
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 2
90220: PUSH
90221: LD_INT 2
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 1
90230: PUSH
90231: LD_INT 2
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: LIST
90242: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90243: LD_ADDR_VAR 0 62
90247: PUSH
90248: LD_INT 1
90250: PUSH
90251: LD_INT 2
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 0
90260: PUSH
90261: LD_INT 2
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: NEG
90271: PUSH
90272: LD_INT 1
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: LIST
90283: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90284: LD_ADDR_VAR 0 63
90288: PUSH
90289: LD_INT 1
90291: NEG
90292: PUSH
90293: LD_INT 1
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 2
90302: NEG
90303: PUSH
90304: LD_INT 0
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 2
90313: NEG
90314: PUSH
90315: LD_INT 1
90317: NEG
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: LIST
90327: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90328: LD_ADDR_VAR 0 64
90332: PUSH
90333: LD_INT 1
90335: NEG
90336: PUSH
90337: LD_INT 2
90339: NEG
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: LD_INT 2
90347: NEG
90348: PUSH
90349: LD_INT 1
90351: NEG
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 2
90359: NEG
90360: PUSH
90361: LD_INT 2
90363: NEG
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: LIST
90373: ST_TO_ADDR
// end ; 2 :
90374: GO 93640
90376: LD_INT 2
90378: DOUBLE
90379: EQUAL
90380: IFTRUE 90384
90382: GO 93639
90384: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
90385: LD_ADDR_VAR 0 29
90389: PUSH
90390: LD_INT 4
90392: PUSH
90393: LD_INT 0
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 4
90402: PUSH
90403: LD_INT 1
90405: NEG
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 5
90413: PUSH
90414: LD_INT 0
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: LD_INT 5
90423: PUSH
90424: LD_INT 1
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 4
90433: PUSH
90434: LD_INT 1
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 3
90443: PUSH
90444: LD_INT 0
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 3
90453: PUSH
90454: LD_INT 1
90456: NEG
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 3
90464: PUSH
90465: LD_INT 2
90467: NEG
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 5
90475: PUSH
90476: LD_INT 2
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 3
90485: PUSH
90486: LD_INT 3
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 3
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 4
90505: PUSH
90506: LD_INT 3
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 4
90515: PUSH
90516: LD_INT 4
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 3
90525: PUSH
90526: LD_INT 4
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 2
90535: PUSH
90536: LD_INT 3
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 2
90545: PUSH
90546: LD_INT 2
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 4
90555: PUSH
90556: LD_INT 2
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PUSH
90563: LD_INT 2
90565: PUSH
90566: LD_INT 4
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: LD_INT 4
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 0
90585: PUSH
90586: LD_INT 3
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 1
90595: PUSH
90596: LD_INT 4
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: LD_INT 1
90605: PUSH
90606: LD_INT 5
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PUSH
90613: LD_INT 0
90615: PUSH
90616: LD_INT 5
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 1
90625: NEG
90626: PUSH
90627: LD_INT 4
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 1
90636: NEG
90637: PUSH
90638: LD_INT 3
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: LD_INT 2
90647: PUSH
90648: LD_INT 5
90650: PUSH
90651: EMPTY
90652: LIST
90653: LIST
90654: PUSH
90655: LD_INT 2
90657: NEG
90658: PUSH
90659: LD_INT 3
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 3
90668: NEG
90669: PUSH
90670: LD_INT 0
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PUSH
90677: LD_INT 3
90679: NEG
90680: PUSH
90681: LD_INT 1
90683: NEG
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: LD_INT 2
90691: NEG
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 2
90702: NEG
90703: PUSH
90704: LD_INT 1
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 3
90713: NEG
90714: PUSH
90715: LD_INT 1
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: PUSH
90722: LD_INT 4
90724: NEG
90725: PUSH
90726: LD_INT 0
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 4
90735: NEG
90736: PUSH
90737: LD_INT 1
90739: NEG
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 4
90747: NEG
90748: PUSH
90749: LD_INT 2
90751: NEG
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: LD_INT 2
90759: NEG
90760: PUSH
90761: LD_INT 2
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 4
90770: NEG
90771: PUSH
90772: LD_INT 4
90774: NEG
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 4
90782: NEG
90783: PUSH
90784: LD_INT 5
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 3
90794: NEG
90795: PUSH
90796: LD_INT 4
90798: NEG
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 3
90806: NEG
90807: PUSH
90808: LD_INT 3
90810: NEG
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PUSH
90816: LD_INT 4
90818: NEG
90819: PUSH
90820: LD_INT 3
90822: NEG
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 5
90830: NEG
90831: PUSH
90832: LD_INT 4
90834: NEG
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 5
90842: NEG
90843: PUSH
90844: LD_INT 5
90846: NEG
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PUSH
90852: LD_INT 3
90854: NEG
90855: PUSH
90856: LD_INT 5
90858: NEG
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 5
90866: NEG
90867: PUSH
90868: LD_INT 3
90870: NEG
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: LIST
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
90923: LD_ADDR_VAR 0 30
90927: PUSH
90928: LD_INT 4
90930: PUSH
90931: LD_INT 4
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 4
90940: PUSH
90941: LD_INT 3
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 5
90950: PUSH
90951: LD_INT 4
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 5
90960: PUSH
90961: LD_INT 5
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: LD_INT 4
90970: PUSH
90971: LD_INT 5
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 3
90980: PUSH
90981: LD_INT 4
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 3
90990: PUSH
90991: LD_INT 3
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 5
91000: PUSH
91001: LD_INT 3
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 3
91010: PUSH
91011: LD_INT 5
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 0
91020: PUSH
91021: LD_INT 3
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 0
91030: PUSH
91031: LD_INT 2
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 1
91040: PUSH
91041: LD_INT 3
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 1
91050: PUSH
91051: LD_INT 4
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 0
91060: PUSH
91061: LD_INT 4
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: NEG
91071: PUSH
91072: LD_INT 3
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 1
91081: NEG
91082: PUSH
91083: LD_INT 2
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 2
91092: PUSH
91093: LD_INT 4
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: LD_INT 2
91102: NEG
91103: PUSH
91104: LD_INT 2
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 4
91113: NEG
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 4
91124: NEG
91125: PUSH
91126: LD_INT 1
91128: NEG
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 3
91136: NEG
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 3
91147: NEG
91148: PUSH
91149: LD_INT 1
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: LD_INT 4
91158: NEG
91159: PUSH
91160: LD_INT 1
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 5
91169: NEG
91170: PUSH
91171: LD_INT 0
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 5
91180: NEG
91181: PUSH
91182: LD_INT 1
91184: NEG
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 5
91192: NEG
91193: PUSH
91194: LD_INT 2
91196: NEG
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 3
91204: NEG
91205: PUSH
91206: LD_INT 2
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 3
91215: NEG
91216: PUSH
91217: LD_INT 3
91219: NEG
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 3
91227: NEG
91228: PUSH
91229: LD_INT 4
91231: NEG
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 2
91239: NEG
91240: PUSH
91241: LD_INT 3
91243: NEG
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 2
91251: NEG
91252: PUSH
91253: LD_INT 2
91255: NEG
91256: PUSH
91257: EMPTY
91258: LIST
91259: LIST
91260: PUSH
91261: LD_INT 3
91263: NEG
91264: PUSH
91265: LD_INT 2
91267: NEG
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 4
91275: NEG
91276: PUSH
91277: LD_INT 3
91279: NEG
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: LD_INT 4
91287: NEG
91288: PUSH
91289: LD_INT 4
91291: NEG
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 2
91299: NEG
91300: PUSH
91301: LD_INT 4
91303: NEG
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 4
91311: NEG
91312: PUSH
91313: LD_INT 2
91315: NEG
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 0
91323: PUSH
91324: LD_INT 4
91326: NEG
91327: PUSH
91328: EMPTY
91329: LIST
91330: LIST
91331: PUSH
91332: LD_INT 0
91334: PUSH
91335: LD_INT 5
91337: NEG
91338: PUSH
91339: EMPTY
91340: LIST
91341: LIST
91342: PUSH
91343: LD_INT 1
91345: PUSH
91346: LD_INT 4
91348: NEG
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: PUSH
91354: LD_INT 1
91356: PUSH
91357: LD_INT 3
91359: NEG
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 0
91367: PUSH
91368: LD_INT 3
91370: NEG
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 1
91378: NEG
91379: PUSH
91380: LD_INT 4
91382: NEG
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 1
91390: NEG
91391: PUSH
91392: LD_INT 5
91394: NEG
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: LD_INT 2
91402: PUSH
91403: LD_INT 3
91405: NEG
91406: PUSH
91407: EMPTY
91408: LIST
91409: LIST
91410: PUSH
91411: LD_INT 2
91413: NEG
91414: PUSH
91415: LD_INT 5
91417: NEG
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
91470: LD_ADDR_VAR 0 31
91474: PUSH
91475: LD_INT 0
91477: PUSH
91478: LD_INT 4
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 0
91487: PUSH
91488: LD_INT 3
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 1
91497: PUSH
91498: LD_INT 4
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 1
91507: PUSH
91508: LD_INT 5
91510: PUSH
91511: EMPTY
91512: LIST
91513: LIST
91514: PUSH
91515: LD_INT 0
91517: PUSH
91518: LD_INT 5
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 1
91527: NEG
91528: PUSH
91529: LD_INT 4
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 1
91538: NEG
91539: PUSH
91540: LD_INT 3
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 2
91549: PUSH
91550: LD_INT 5
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 2
91559: NEG
91560: PUSH
91561: LD_INT 3
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 3
91570: NEG
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 3
91581: NEG
91582: PUSH
91583: LD_INT 1
91585: NEG
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 2
91593: NEG
91594: PUSH
91595: LD_INT 0
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 2
91604: NEG
91605: PUSH
91606: LD_INT 1
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 3
91615: NEG
91616: PUSH
91617: LD_INT 1
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 4
91626: NEG
91627: PUSH
91628: LD_INT 0
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 4
91637: NEG
91638: PUSH
91639: LD_INT 1
91641: NEG
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: LD_INT 4
91649: NEG
91650: PUSH
91651: LD_INT 2
91653: NEG
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PUSH
91659: LD_INT 2
91661: NEG
91662: PUSH
91663: LD_INT 2
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: LD_INT 4
91672: NEG
91673: PUSH
91674: LD_INT 4
91676: NEG
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 4
91684: NEG
91685: PUSH
91686: LD_INT 5
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 3
91696: NEG
91697: PUSH
91698: LD_INT 4
91700: NEG
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 3
91708: NEG
91709: PUSH
91710: LD_INT 3
91712: NEG
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: LD_INT 4
91720: NEG
91721: PUSH
91722: LD_INT 3
91724: NEG
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: LD_INT 5
91732: NEG
91733: PUSH
91734: LD_INT 4
91736: NEG
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 5
91744: NEG
91745: PUSH
91746: LD_INT 5
91748: NEG
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 3
91756: NEG
91757: PUSH
91758: LD_INT 5
91760: NEG
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 5
91768: NEG
91769: PUSH
91770: LD_INT 3
91772: NEG
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 0
91780: PUSH
91781: LD_INT 3
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 0
91791: PUSH
91792: LD_INT 4
91794: NEG
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 1
91802: PUSH
91803: LD_INT 3
91805: NEG
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 1
91813: PUSH
91814: LD_INT 2
91816: NEG
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 0
91824: PUSH
91825: LD_INT 2
91827: NEG
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: LD_INT 1
91835: NEG
91836: PUSH
91837: LD_INT 3
91839: NEG
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 1
91847: NEG
91848: PUSH
91849: LD_INT 4
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 2
91859: PUSH
91860: LD_INT 2
91862: NEG
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 2
91870: NEG
91871: PUSH
91872: LD_INT 4
91874: NEG
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: LD_INT 4
91882: PUSH
91883: LD_INT 0
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 4
91892: PUSH
91893: LD_INT 1
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 5
91903: PUSH
91904: LD_INT 0
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 5
91913: PUSH
91914: LD_INT 1
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 4
91923: PUSH
91924: LD_INT 1
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 3
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 3
91943: PUSH
91944: LD_INT 1
91946: NEG
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 3
91954: PUSH
91955: LD_INT 2
91957: NEG
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 5
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
92020: LD_ADDR_VAR 0 32
92024: PUSH
92025: LD_INT 4
92027: NEG
92028: PUSH
92029: LD_INT 0
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 4
92038: NEG
92039: PUSH
92040: LD_INT 1
92042: NEG
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 3
92050: NEG
92051: PUSH
92052: LD_INT 0
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: PUSH
92059: LD_INT 3
92061: NEG
92062: PUSH
92063: LD_INT 1
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: PUSH
92070: LD_INT 4
92072: NEG
92073: PUSH
92074: LD_INT 1
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: PUSH
92081: LD_INT 5
92083: NEG
92084: PUSH
92085: LD_INT 0
92087: PUSH
92088: EMPTY
92089: LIST
92090: LIST
92091: PUSH
92092: LD_INT 5
92094: NEG
92095: PUSH
92096: LD_INT 1
92098: NEG
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 5
92106: NEG
92107: PUSH
92108: LD_INT 2
92110: NEG
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: LD_INT 3
92118: NEG
92119: PUSH
92120: LD_INT 2
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 3
92129: NEG
92130: PUSH
92131: LD_INT 3
92133: NEG
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 3
92141: NEG
92142: PUSH
92143: LD_INT 4
92145: NEG
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: LD_INT 2
92153: NEG
92154: PUSH
92155: LD_INT 3
92157: NEG
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: PUSH
92163: LD_INT 2
92165: NEG
92166: PUSH
92167: LD_INT 2
92169: NEG
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 3
92177: NEG
92178: PUSH
92179: LD_INT 2
92181: NEG
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 4
92189: NEG
92190: PUSH
92191: LD_INT 3
92193: NEG
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 4
92201: NEG
92202: PUSH
92203: LD_INT 4
92205: NEG
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 2
92213: NEG
92214: PUSH
92215: LD_INT 4
92217: NEG
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 4
92225: NEG
92226: PUSH
92227: LD_INT 2
92229: NEG
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 0
92237: PUSH
92238: LD_INT 4
92240: NEG
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 0
92248: PUSH
92249: LD_INT 5
92251: NEG
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 1
92259: PUSH
92260: LD_INT 4
92262: NEG
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 1
92270: PUSH
92271: LD_INT 3
92273: NEG
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 0
92281: PUSH
92282: LD_INT 3
92284: NEG
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: LD_INT 1
92292: NEG
92293: PUSH
92294: LD_INT 4
92296: NEG
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PUSH
92302: LD_INT 1
92304: NEG
92305: PUSH
92306: LD_INT 5
92308: NEG
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 2
92316: PUSH
92317: LD_INT 3
92319: NEG
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: LD_INT 2
92327: NEG
92328: PUSH
92329: LD_INT 5
92331: NEG
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 3
92339: PUSH
92340: LD_INT 0
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 3
92349: PUSH
92350: LD_INT 1
92352: NEG
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 4
92360: PUSH
92361: LD_INT 0
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 4
92370: PUSH
92371: LD_INT 1
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 3
92380: PUSH
92381: LD_INT 1
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 2
92390: PUSH
92391: LD_INT 0
92393: PUSH
92394: EMPTY
92395: LIST
92396: LIST
92397: PUSH
92398: LD_INT 2
92400: PUSH
92401: LD_INT 1
92403: NEG
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 2
92411: PUSH
92412: LD_INT 2
92414: NEG
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PUSH
92420: LD_INT 4
92422: PUSH
92423: LD_INT 2
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PUSH
92430: LD_INT 4
92432: PUSH
92433: LD_INT 4
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: PUSH
92440: LD_INT 4
92442: PUSH
92443: LD_INT 3
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 5
92452: PUSH
92453: LD_INT 4
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: LD_INT 5
92462: PUSH
92463: LD_INT 5
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 4
92472: PUSH
92473: LD_INT 5
92475: PUSH
92476: EMPTY
92477: LIST
92478: LIST
92479: PUSH
92480: LD_INT 3
92482: PUSH
92483: LD_INT 4
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: PUSH
92490: LD_INT 3
92492: PUSH
92493: LD_INT 3
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 5
92502: PUSH
92503: LD_INT 3
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 3
92512: PUSH
92513: LD_INT 5
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
92567: LD_ADDR_VAR 0 33
92571: PUSH
92572: LD_INT 4
92574: NEG
92575: PUSH
92576: LD_INT 4
92578: NEG
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 4
92586: NEG
92587: PUSH
92588: LD_INT 5
92590: NEG
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 3
92598: NEG
92599: PUSH
92600: LD_INT 4
92602: NEG
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 3
92610: NEG
92611: PUSH
92612: LD_INT 3
92614: NEG
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 4
92622: NEG
92623: PUSH
92624: LD_INT 3
92626: NEG
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 5
92634: NEG
92635: PUSH
92636: LD_INT 4
92638: NEG
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: PUSH
92644: LD_INT 5
92646: NEG
92647: PUSH
92648: LD_INT 5
92650: NEG
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: LD_INT 3
92658: NEG
92659: PUSH
92660: LD_INT 5
92662: NEG
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: PUSH
92668: LD_INT 5
92670: NEG
92671: PUSH
92672: LD_INT 3
92674: NEG
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 0
92682: PUSH
92683: LD_INT 3
92685: NEG
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 0
92693: PUSH
92694: LD_INT 4
92696: NEG
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: LD_INT 1
92704: PUSH
92705: LD_INT 3
92707: NEG
92708: PUSH
92709: EMPTY
92710: LIST
92711: LIST
92712: PUSH
92713: LD_INT 1
92715: PUSH
92716: LD_INT 2
92718: NEG
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: PUSH
92724: LD_INT 0
92726: PUSH
92727: LD_INT 2
92729: NEG
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 1
92737: NEG
92738: PUSH
92739: LD_INT 3
92741: NEG
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: PUSH
92747: LD_INT 1
92749: NEG
92750: PUSH
92751: LD_INT 4
92753: NEG
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 2
92761: PUSH
92762: LD_INT 2
92764: NEG
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 2
92772: NEG
92773: PUSH
92774: LD_INT 4
92776: NEG
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: PUSH
92782: LD_INT 4
92784: PUSH
92785: LD_INT 0
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 4
92794: PUSH
92795: LD_INT 1
92797: NEG
92798: PUSH
92799: EMPTY
92800: LIST
92801: LIST
92802: PUSH
92803: LD_INT 5
92805: PUSH
92806: LD_INT 0
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 5
92815: PUSH
92816: LD_INT 1
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 4
92825: PUSH
92826: LD_INT 1
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 3
92835: PUSH
92836: LD_INT 0
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 3
92845: PUSH
92846: LD_INT 1
92848: NEG
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 3
92856: PUSH
92857: LD_INT 2
92859: NEG
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 5
92867: PUSH
92868: LD_INT 2
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 3
92877: PUSH
92878: LD_INT 3
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 3
92887: PUSH
92888: LD_INT 2
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 4
92897: PUSH
92898: LD_INT 3
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: LD_INT 4
92907: PUSH
92908: LD_INT 4
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PUSH
92915: LD_INT 3
92917: PUSH
92918: LD_INT 4
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 2
92927: PUSH
92928: LD_INT 3
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 2
92937: PUSH
92938: LD_INT 2
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 4
92947: PUSH
92948: LD_INT 2
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 2
92957: PUSH
92958: LD_INT 4
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 0
92967: PUSH
92968: LD_INT 4
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 0
92977: PUSH
92978: LD_INT 3
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 1
92987: PUSH
92988: LD_INT 4
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 1
92997: PUSH
92998: LD_INT 5
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 0
93007: PUSH
93008: LD_INT 5
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 1
93017: NEG
93018: PUSH
93019: LD_INT 4
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 1
93028: NEG
93029: PUSH
93030: LD_INT 3
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 2
93039: PUSH
93040: LD_INT 5
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: PUSH
93047: LD_INT 2
93049: NEG
93050: PUSH
93051: LD_INT 3
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: LIST
93104: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
93105: LD_ADDR_VAR 0 34
93109: PUSH
93110: LD_INT 0
93112: PUSH
93113: LD_INT 4
93115: NEG
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: PUSH
93121: LD_INT 0
93123: PUSH
93124: LD_INT 5
93126: NEG
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 1
93134: PUSH
93135: LD_INT 4
93137: NEG
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: PUSH
93143: LD_INT 1
93145: PUSH
93146: LD_INT 3
93148: NEG
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: LD_INT 3
93159: NEG
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: LD_INT 1
93167: NEG
93168: PUSH
93169: LD_INT 4
93171: NEG
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: LD_INT 1
93179: NEG
93180: PUSH
93181: LD_INT 5
93183: NEG
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 2
93191: PUSH
93192: LD_INT 3
93194: NEG
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 2
93202: NEG
93203: PUSH
93204: LD_INT 5
93206: NEG
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 3
93214: PUSH
93215: LD_INT 0
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 3
93224: PUSH
93225: LD_INT 1
93227: NEG
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 4
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 4
93245: PUSH
93246: LD_INT 1
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 3
93255: PUSH
93256: LD_INT 1
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: PUSH
93263: LD_INT 2
93265: PUSH
93266: LD_INT 0
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 2
93275: PUSH
93276: LD_INT 1
93278: NEG
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 2
93286: PUSH
93287: LD_INT 2
93289: NEG
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 4
93297: PUSH
93298: LD_INT 2
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 4
93307: PUSH
93308: LD_INT 4
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: PUSH
93315: LD_INT 4
93317: PUSH
93318: LD_INT 3
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: LD_INT 5
93327: PUSH
93328: LD_INT 4
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 5
93337: PUSH
93338: LD_INT 5
93340: PUSH
93341: EMPTY
93342: LIST
93343: LIST
93344: PUSH
93345: LD_INT 4
93347: PUSH
93348: LD_INT 5
93350: PUSH
93351: EMPTY
93352: LIST
93353: LIST
93354: PUSH
93355: LD_INT 3
93357: PUSH
93358: LD_INT 4
93360: PUSH
93361: EMPTY
93362: LIST
93363: LIST
93364: PUSH
93365: LD_INT 3
93367: PUSH
93368: LD_INT 3
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: LD_INT 5
93377: PUSH
93378: LD_INT 3
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 3
93387: PUSH
93388: LD_INT 5
93390: PUSH
93391: EMPTY
93392: LIST
93393: LIST
93394: PUSH
93395: LD_INT 0
93397: PUSH
93398: LD_INT 3
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PUSH
93405: LD_INT 0
93407: PUSH
93408: LD_INT 2
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 1
93417: PUSH
93418: LD_INT 3
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 1
93427: PUSH
93428: LD_INT 4
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 0
93437: PUSH
93438: LD_INT 4
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 1
93447: NEG
93448: PUSH
93449: LD_INT 3
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 1
93458: NEG
93459: PUSH
93460: LD_INT 2
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 2
93469: PUSH
93470: LD_INT 4
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: LD_INT 2
93479: NEG
93480: PUSH
93481: LD_INT 2
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 4
93490: NEG
93491: PUSH
93492: LD_INT 0
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PUSH
93499: LD_INT 4
93501: NEG
93502: PUSH
93503: LD_INT 1
93505: NEG
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: LD_INT 3
93513: NEG
93514: PUSH
93515: LD_INT 0
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 3
93524: NEG
93525: PUSH
93526: LD_INT 1
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: PUSH
93533: LD_INT 4
93535: NEG
93536: PUSH
93537: LD_INT 1
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 5
93546: NEG
93547: PUSH
93548: LD_INT 0
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: LD_INT 5
93557: NEG
93558: PUSH
93559: LD_INT 1
93561: NEG
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 5
93569: NEG
93570: PUSH
93571: LD_INT 2
93573: NEG
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 3
93581: NEG
93582: PUSH
93583: LD_INT 2
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: ST_TO_ADDR
// end ; end ;
93637: GO 93640
93639: POP
// case btype of b_depot , b_warehouse :
93640: LD_VAR 0 1
93644: PUSH
93645: LD_INT 0
93647: DOUBLE
93648: EQUAL
93649: IFTRUE 93659
93651: LD_INT 1
93653: DOUBLE
93654: EQUAL
93655: IFTRUE 93659
93657: GO 93860
93659: POP
// case nation of nation_american :
93660: LD_VAR 0 5
93664: PUSH
93665: LD_INT 1
93667: DOUBLE
93668: EQUAL
93669: IFTRUE 93673
93671: GO 93729
93673: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
93674: LD_ADDR_VAR 0 9
93678: PUSH
93679: LD_VAR 0 11
93683: PUSH
93684: LD_VAR 0 12
93688: PUSH
93689: LD_VAR 0 13
93693: PUSH
93694: LD_VAR 0 14
93698: PUSH
93699: LD_VAR 0 15
93703: PUSH
93704: LD_VAR 0 16
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: PUSH
93717: LD_VAR 0 4
93721: PUSH
93722: LD_INT 1
93724: PLUS
93725: ARRAY
93726: ST_TO_ADDR
93727: GO 93858
93729: LD_INT 2
93731: DOUBLE
93732: EQUAL
93733: IFTRUE 93737
93735: GO 93793
93737: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
93738: LD_ADDR_VAR 0 9
93742: PUSH
93743: LD_VAR 0 17
93747: PUSH
93748: LD_VAR 0 18
93752: PUSH
93753: LD_VAR 0 19
93757: PUSH
93758: LD_VAR 0 20
93762: PUSH
93763: LD_VAR 0 21
93767: PUSH
93768: LD_VAR 0 22
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: PUSH
93781: LD_VAR 0 4
93785: PUSH
93786: LD_INT 1
93788: PLUS
93789: ARRAY
93790: ST_TO_ADDR
93791: GO 93858
93793: LD_INT 3
93795: DOUBLE
93796: EQUAL
93797: IFTRUE 93801
93799: GO 93857
93801: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
93802: LD_ADDR_VAR 0 9
93806: PUSH
93807: LD_VAR 0 23
93811: PUSH
93812: LD_VAR 0 24
93816: PUSH
93817: LD_VAR 0 25
93821: PUSH
93822: LD_VAR 0 26
93826: PUSH
93827: LD_VAR 0 27
93831: PUSH
93832: LD_VAR 0 28
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: PUSH
93845: LD_VAR 0 4
93849: PUSH
93850: LD_INT 1
93852: PLUS
93853: ARRAY
93854: ST_TO_ADDR
93855: GO 93858
93857: POP
93858: GO 94407
93860: LD_INT 2
93862: DOUBLE
93863: EQUAL
93864: IFTRUE 93874
93866: LD_INT 3
93868: DOUBLE
93869: EQUAL
93870: IFTRUE 93874
93872: GO 93930
93874: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
93875: LD_ADDR_VAR 0 9
93879: PUSH
93880: LD_VAR 0 29
93884: PUSH
93885: LD_VAR 0 30
93889: PUSH
93890: LD_VAR 0 31
93894: PUSH
93895: LD_VAR 0 32
93899: PUSH
93900: LD_VAR 0 33
93904: PUSH
93905: LD_VAR 0 34
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: PUSH
93918: LD_VAR 0 4
93922: PUSH
93923: LD_INT 1
93925: PLUS
93926: ARRAY
93927: ST_TO_ADDR
93928: GO 94407
93930: LD_INT 16
93932: DOUBLE
93933: EQUAL
93934: IFTRUE 93986
93936: LD_INT 17
93938: DOUBLE
93939: EQUAL
93940: IFTRUE 93986
93942: LD_INT 18
93944: DOUBLE
93945: EQUAL
93946: IFTRUE 93986
93948: LD_INT 19
93950: DOUBLE
93951: EQUAL
93952: IFTRUE 93986
93954: LD_INT 20
93956: DOUBLE
93957: EQUAL
93958: IFTRUE 93986
93960: LD_INT 21
93962: DOUBLE
93963: EQUAL
93964: IFTRUE 93986
93966: LD_INT 23
93968: DOUBLE
93969: EQUAL
93970: IFTRUE 93986
93972: LD_INT 24
93974: DOUBLE
93975: EQUAL
93976: IFTRUE 93986
93978: LD_INT 25
93980: DOUBLE
93981: EQUAL
93982: IFTRUE 93986
93984: GO 94042
93986: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
93987: LD_ADDR_VAR 0 9
93991: PUSH
93992: LD_VAR 0 35
93996: PUSH
93997: LD_VAR 0 36
94001: PUSH
94002: LD_VAR 0 37
94006: PUSH
94007: LD_VAR 0 38
94011: PUSH
94012: LD_VAR 0 39
94016: PUSH
94017: LD_VAR 0 40
94021: PUSH
94022: EMPTY
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: PUSH
94030: LD_VAR 0 4
94034: PUSH
94035: LD_INT 1
94037: PLUS
94038: ARRAY
94039: ST_TO_ADDR
94040: GO 94407
94042: LD_INT 6
94044: DOUBLE
94045: EQUAL
94046: IFTRUE 94098
94048: LD_INT 7
94050: DOUBLE
94051: EQUAL
94052: IFTRUE 94098
94054: LD_INT 8
94056: DOUBLE
94057: EQUAL
94058: IFTRUE 94098
94060: LD_INT 13
94062: DOUBLE
94063: EQUAL
94064: IFTRUE 94098
94066: LD_INT 12
94068: DOUBLE
94069: EQUAL
94070: IFTRUE 94098
94072: LD_INT 15
94074: DOUBLE
94075: EQUAL
94076: IFTRUE 94098
94078: LD_INT 11
94080: DOUBLE
94081: EQUAL
94082: IFTRUE 94098
94084: LD_INT 14
94086: DOUBLE
94087: EQUAL
94088: IFTRUE 94098
94090: LD_INT 10
94092: DOUBLE
94093: EQUAL
94094: IFTRUE 94098
94096: GO 94154
94098: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
94099: LD_ADDR_VAR 0 9
94103: PUSH
94104: LD_VAR 0 41
94108: PUSH
94109: LD_VAR 0 42
94113: PUSH
94114: LD_VAR 0 43
94118: PUSH
94119: LD_VAR 0 44
94123: PUSH
94124: LD_VAR 0 45
94128: PUSH
94129: LD_VAR 0 46
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: PUSH
94142: LD_VAR 0 4
94146: PUSH
94147: LD_INT 1
94149: PLUS
94150: ARRAY
94151: ST_TO_ADDR
94152: GO 94407
94154: LD_INT 36
94156: DOUBLE
94157: EQUAL
94158: IFTRUE 94162
94160: GO 94218
94162: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
94163: LD_ADDR_VAR 0 9
94167: PUSH
94168: LD_VAR 0 47
94172: PUSH
94173: LD_VAR 0 48
94177: PUSH
94178: LD_VAR 0 49
94182: PUSH
94183: LD_VAR 0 50
94187: PUSH
94188: LD_VAR 0 51
94192: PUSH
94193: LD_VAR 0 52
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: PUSH
94206: LD_VAR 0 4
94210: PUSH
94211: LD_INT 1
94213: PLUS
94214: ARRAY
94215: ST_TO_ADDR
94216: GO 94407
94218: LD_INT 4
94220: DOUBLE
94221: EQUAL
94222: IFTRUE 94244
94224: LD_INT 5
94226: DOUBLE
94227: EQUAL
94228: IFTRUE 94244
94230: LD_INT 34
94232: DOUBLE
94233: EQUAL
94234: IFTRUE 94244
94236: LD_INT 37
94238: DOUBLE
94239: EQUAL
94240: IFTRUE 94244
94242: GO 94300
94244: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
94245: LD_ADDR_VAR 0 9
94249: PUSH
94250: LD_VAR 0 53
94254: PUSH
94255: LD_VAR 0 54
94259: PUSH
94260: LD_VAR 0 55
94264: PUSH
94265: LD_VAR 0 56
94269: PUSH
94270: LD_VAR 0 57
94274: PUSH
94275: LD_VAR 0 58
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: PUSH
94288: LD_VAR 0 4
94292: PUSH
94293: LD_INT 1
94295: PLUS
94296: ARRAY
94297: ST_TO_ADDR
94298: GO 94407
94300: LD_INT 31
94302: DOUBLE
94303: EQUAL
94304: IFTRUE 94350
94306: LD_INT 32
94308: DOUBLE
94309: EQUAL
94310: IFTRUE 94350
94312: LD_INT 33
94314: DOUBLE
94315: EQUAL
94316: IFTRUE 94350
94318: LD_INT 27
94320: DOUBLE
94321: EQUAL
94322: IFTRUE 94350
94324: LD_INT 26
94326: DOUBLE
94327: EQUAL
94328: IFTRUE 94350
94330: LD_INT 28
94332: DOUBLE
94333: EQUAL
94334: IFTRUE 94350
94336: LD_INT 29
94338: DOUBLE
94339: EQUAL
94340: IFTRUE 94350
94342: LD_INT 30
94344: DOUBLE
94345: EQUAL
94346: IFTRUE 94350
94348: GO 94406
94350: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
94351: LD_ADDR_VAR 0 9
94355: PUSH
94356: LD_VAR 0 59
94360: PUSH
94361: LD_VAR 0 60
94365: PUSH
94366: LD_VAR 0 61
94370: PUSH
94371: LD_VAR 0 62
94375: PUSH
94376: LD_VAR 0 63
94380: PUSH
94381: LD_VAR 0 64
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: PUSH
94394: LD_VAR 0 4
94398: PUSH
94399: LD_INT 1
94401: PLUS
94402: ARRAY
94403: ST_TO_ADDR
94404: GO 94407
94406: POP
// temp_list2 = [ ] ;
94407: LD_ADDR_VAR 0 10
94411: PUSH
94412: EMPTY
94413: ST_TO_ADDR
// for i in temp_list do
94414: LD_ADDR_VAR 0 8
94418: PUSH
94419: LD_VAR 0 9
94423: PUSH
94424: FOR_IN
94425: IFFALSE 94477
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
94427: LD_ADDR_VAR 0 10
94431: PUSH
94432: LD_VAR 0 10
94436: PUSH
94437: LD_VAR 0 8
94441: PUSH
94442: LD_INT 1
94444: ARRAY
94445: PUSH
94446: LD_VAR 0 2
94450: PLUS
94451: PUSH
94452: LD_VAR 0 8
94456: PUSH
94457: LD_INT 2
94459: ARRAY
94460: PUSH
94461: LD_VAR 0 3
94465: PLUS
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: PUSH
94471: EMPTY
94472: LIST
94473: ADD
94474: ST_TO_ADDR
94475: GO 94424
94477: POP
94478: POP
// result = temp_list2 ;
94479: LD_ADDR_VAR 0 7
94483: PUSH
94484: LD_VAR 0 10
94488: ST_TO_ADDR
// end ;
94489: LD_VAR 0 7
94493: RET
// export function EnemyInRange ( unit , dist ) ; begin
94494: LD_INT 0
94496: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
94497: LD_ADDR_VAR 0 3
94501: PUSH
94502: LD_VAR 0 1
94506: PPUSH
94507: CALL_OW 255
94511: PPUSH
94512: LD_VAR 0 1
94516: PPUSH
94517: CALL_OW 250
94521: PPUSH
94522: LD_VAR 0 1
94526: PPUSH
94527: CALL_OW 251
94531: PPUSH
94532: LD_VAR 0 2
94536: PPUSH
94537: CALL 68622 0 4
94541: PUSH
94542: LD_INT 4
94544: ARRAY
94545: ST_TO_ADDR
// end ;
94546: LD_VAR 0 3
94550: RET
// export function PlayerSeeMe ( unit ) ; begin
94551: LD_INT 0
94553: PPUSH
// result := See ( your_side , unit ) ;
94554: LD_ADDR_VAR 0 2
94558: PUSH
94559: LD_OWVAR 2
94563: PPUSH
94564: LD_VAR 0 1
94568: PPUSH
94569: CALL_OW 292
94573: ST_TO_ADDR
// end ;
94574: LD_VAR 0 2
94578: RET
// export function ReverseDir ( unit ) ; begin
94579: LD_INT 0
94581: PPUSH
// if not unit then
94582: LD_VAR 0 1
94586: NOT
94587: IFFALSE 94591
// exit ;
94589: GO 94637
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
94591: LD_ADDR_VAR 0 2
94595: PUSH
94596: LD_INT 3
94598: PUSH
94599: LD_INT 4
94601: PUSH
94602: LD_INT 5
94604: PUSH
94605: LD_INT 0
94607: PUSH
94608: LD_INT 1
94610: PUSH
94611: LD_INT 2
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: PUSH
94622: LD_VAR 0 1
94626: PPUSH
94627: CALL_OW 254
94631: PUSH
94632: LD_INT 1
94634: PLUS
94635: ARRAY
94636: ST_TO_ADDR
// end ;
94637: LD_VAR 0 2
94641: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
94642: LD_INT 0
94644: PPUSH
94645: PPUSH
94646: PPUSH
94647: PPUSH
94648: PPUSH
// if not hexes then
94649: LD_VAR 0 2
94653: NOT
94654: IFFALSE 94658
// exit ;
94656: GO 94806
// dist := 9999 ;
94658: LD_ADDR_VAR 0 5
94662: PUSH
94663: LD_INT 9999
94665: ST_TO_ADDR
// for i = 1 to hexes do
94666: LD_ADDR_VAR 0 4
94670: PUSH
94671: DOUBLE
94672: LD_INT 1
94674: DEC
94675: ST_TO_ADDR
94676: LD_VAR 0 2
94680: PUSH
94681: FOR_TO
94682: IFFALSE 94794
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
94684: LD_VAR 0 1
94688: PPUSH
94689: LD_VAR 0 2
94693: PUSH
94694: LD_VAR 0 4
94698: ARRAY
94699: PUSH
94700: LD_INT 1
94702: ARRAY
94703: PPUSH
94704: LD_VAR 0 2
94708: PUSH
94709: LD_VAR 0 4
94713: ARRAY
94714: PUSH
94715: LD_INT 2
94717: ARRAY
94718: PPUSH
94719: CALL_OW 297
94723: PUSH
94724: LD_VAR 0 5
94728: LESS
94729: IFFALSE 94792
// begin hex := hexes [ i ] ;
94731: LD_ADDR_VAR 0 7
94735: PUSH
94736: LD_VAR 0 2
94740: PUSH
94741: LD_VAR 0 4
94745: ARRAY
94746: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
94747: LD_ADDR_VAR 0 5
94751: PUSH
94752: LD_VAR 0 1
94756: PPUSH
94757: LD_VAR 0 2
94761: PUSH
94762: LD_VAR 0 4
94766: ARRAY
94767: PUSH
94768: LD_INT 1
94770: ARRAY
94771: PPUSH
94772: LD_VAR 0 2
94776: PUSH
94777: LD_VAR 0 4
94781: ARRAY
94782: PUSH
94783: LD_INT 2
94785: ARRAY
94786: PPUSH
94787: CALL_OW 297
94791: ST_TO_ADDR
// end ; end ;
94792: GO 94681
94794: POP
94795: POP
// result := hex ;
94796: LD_ADDR_VAR 0 3
94800: PUSH
94801: LD_VAR 0 7
94805: ST_TO_ADDR
// end ;
94806: LD_VAR 0 3
94810: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
94811: LD_INT 0
94813: PPUSH
94814: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
94815: LD_VAR 0 1
94819: NOT
94820: PUSH
94821: LD_VAR 0 1
94825: PUSH
94826: LD_INT 21
94828: PUSH
94829: LD_INT 2
94831: PUSH
94832: EMPTY
94833: LIST
94834: LIST
94835: PUSH
94836: LD_INT 23
94838: PUSH
94839: LD_INT 2
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PPUSH
94850: CALL_OW 69
94854: IN
94855: NOT
94856: OR
94857: IFFALSE 94861
// exit ;
94859: GO 94908
// for i = 1 to 3 do
94861: LD_ADDR_VAR 0 3
94865: PUSH
94866: DOUBLE
94867: LD_INT 1
94869: DEC
94870: ST_TO_ADDR
94871: LD_INT 3
94873: PUSH
94874: FOR_TO
94875: IFFALSE 94906
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
94877: LD_VAR 0 1
94881: PPUSH
94882: CALL_OW 250
94886: PPUSH
94887: LD_VAR 0 1
94891: PPUSH
94892: CALL_OW 251
94896: PPUSH
94897: LD_INT 1
94899: PPUSH
94900: CALL_OW 453
94904: GO 94874
94906: POP
94907: POP
// end ;
94908: LD_VAR 0 2
94912: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
94913: LD_INT 0
94915: PPUSH
94916: PPUSH
94917: PPUSH
94918: PPUSH
94919: PPUSH
94920: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
94921: LD_VAR 0 1
94925: NOT
94926: PUSH
94927: LD_VAR 0 2
94931: NOT
94932: OR
94933: PUSH
94934: LD_VAR 0 1
94938: PPUSH
94939: CALL_OW 314
94943: OR
94944: IFFALSE 94948
// exit ;
94946: GO 95389
// x := GetX ( enemy_unit ) ;
94948: LD_ADDR_VAR 0 7
94952: PUSH
94953: LD_VAR 0 2
94957: PPUSH
94958: CALL_OW 250
94962: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
94963: LD_ADDR_VAR 0 8
94967: PUSH
94968: LD_VAR 0 2
94972: PPUSH
94973: CALL_OW 251
94977: ST_TO_ADDR
// if not x or not y then
94978: LD_VAR 0 7
94982: NOT
94983: PUSH
94984: LD_VAR 0 8
94988: NOT
94989: OR
94990: IFFALSE 94994
// exit ;
94992: GO 95389
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
94994: LD_ADDR_VAR 0 6
94998: PUSH
94999: LD_VAR 0 7
95003: PPUSH
95004: LD_INT 0
95006: PPUSH
95007: LD_INT 4
95009: PPUSH
95010: CALL_OW 272
95014: PUSH
95015: LD_VAR 0 8
95019: PPUSH
95020: LD_INT 0
95022: PPUSH
95023: LD_INT 4
95025: PPUSH
95026: CALL_OW 273
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_VAR 0 7
95039: PPUSH
95040: LD_INT 1
95042: PPUSH
95043: LD_INT 4
95045: PPUSH
95046: CALL_OW 272
95050: PUSH
95051: LD_VAR 0 8
95055: PPUSH
95056: LD_INT 1
95058: PPUSH
95059: LD_INT 4
95061: PPUSH
95062: CALL_OW 273
95066: PUSH
95067: EMPTY
95068: LIST
95069: LIST
95070: PUSH
95071: LD_VAR 0 7
95075: PPUSH
95076: LD_INT 2
95078: PPUSH
95079: LD_INT 4
95081: PPUSH
95082: CALL_OW 272
95086: PUSH
95087: LD_VAR 0 8
95091: PPUSH
95092: LD_INT 2
95094: PPUSH
95095: LD_INT 4
95097: PPUSH
95098: CALL_OW 273
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: PUSH
95107: LD_VAR 0 7
95111: PPUSH
95112: LD_INT 3
95114: PPUSH
95115: LD_INT 4
95117: PPUSH
95118: CALL_OW 272
95122: PUSH
95123: LD_VAR 0 8
95127: PPUSH
95128: LD_INT 3
95130: PPUSH
95131: LD_INT 4
95133: PPUSH
95134: CALL_OW 273
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_VAR 0 7
95147: PPUSH
95148: LD_INT 4
95150: PPUSH
95151: LD_INT 4
95153: PPUSH
95154: CALL_OW 272
95158: PUSH
95159: LD_VAR 0 8
95163: PPUSH
95164: LD_INT 4
95166: PPUSH
95167: LD_INT 4
95169: PPUSH
95170: CALL_OW 273
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_VAR 0 7
95183: PPUSH
95184: LD_INT 5
95186: PPUSH
95187: LD_INT 4
95189: PPUSH
95190: CALL_OW 272
95194: PUSH
95195: LD_VAR 0 8
95199: PPUSH
95200: LD_INT 5
95202: PPUSH
95203: LD_INT 4
95205: PPUSH
95206: CALL_OW 273
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: ST_TO_ADDR
// for i = tmp downto 1 do
95223: LD_ADDR_VAR 0 4
95227: PUSH
95228: DOUBLE
95229: LD_VAR 0 6
95233: INC
95234: ST_TO_ADDR
95235: LD_INT 1
95237: PUSH
95238: FOR_DOWNTO
95239: IFFALSE 95340
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
95241: LD_VAR 0 6
95245: PUSH
95246: LD_VAR 0 4
95250: ARRAY
95251: PUSH
95252: LD_INT 1
95254: ARRAY
95255: PPUSH
95256: LD_VAR 0 6
95260: PUSH
95261: LD_VAR 0 4
95265: ARRAY
95266: PUSH
95267: LD_INT 2
95269: ARRAY
95270: PPUSH
95271: CALL_OW 488
95275: NOT
95276: PUSH
95277: LD_VAR 0 6
95281: PUSH
95282: LD_VAR 0 4
95286: ARRAY
95287: PUSH
95288: LD_INT 1
95290: ARRAY
95291: PPUSH
95292: LD_VAR 0 6
95296: PUSH
95297: LD_VAR 0 4
95301: ARRAY
95302: PUSH
95303: LD_INT 2
95305: ARRAY
95306: PPUSH
95307: CALL_OW 428
95311: PUSH
95312: LD_INT 0
95314: NONEQUAL
95315: OR
95316: IFFALSE 95338
// tmp := Delete ( tmp , i ) ;
95318: LD_ADDR_VAR 0 6
95322: PUSH
95323: LD_VAR 0 6
95327: PPUSH
95328: LD_VAR 0 4
95332: PPUSH
95333: CALL_OW 3
95337: ST_TO_ADDR
95338: GO 95238
95340: POP
95341: POP
// j := GetClosestHex ( unit , tmp ) ;
95342: LD_ADDR_VAR 0 5
95346: PUSH
95347: LD_VAR 0 1
95351: PPUSH
95352: LD_VAR 0 6
95356: PPUSH
95357: CALL 94642 0 2
95361: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
95362: LD_VAR 0 1
95366: PPUSH
95367: LD_VAR 0 5
95371: PUSH
95372: LD_INT 1
95374: ARRAY
95375: PPUSH
95376: LD_VAR 0 5
95380: PUSH
95381: LD_INT 2
95383: ARRAY
95384: PPUSH
95385: CALL_OW 111
// end ;
95389: LD_VAR 0 3
95393: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
95394: LD_INT 0
95396: PPUSH
95397: PPUSH
95398: PPUSH
// uc_side = 0 ;
95399: LD_ADDR_OWVAR 20
95403: PUSH
95404: LD_INT 0
95406: ST_TO_ADDR
// uc_nation = 0 ;
95407: LD_ADDR_OWVAR 21
95411: PUSH
95412: LD_INT 0
95414: ST_TO_ADDR
// InitHc ;
95415: CALL_OW 19
// InitVc ;
95419: CALL_OW 20
// if mastodonts then
95423: LD_VAR 0 6
95427: IFFALSE 95494
// for i = 1 to mastodonts do
95429: LD_ADDR_VAR 0 11
95433: PUSH
95434: DOUBLE
95435: LD_INT 1
95437: DEC
95438: ST_TO_ADDR
95439: LD_VAR 0 6
95443: PUSH
95444: FOR_TO
95445: IFFALSE 95492
// begin vc_chassis := 31 ;
95447: LD_ADDR_OWVAR 37
95451: PUSH
95452: LD_INT 31
95454: ST_TO_ADDR
// vc_control := control_rider ;
95455: LD_ADDR_OWVAR 38
95459: PUSH
95460: LD_INT 4
95462: ST_TO_ADDR
// animal := CreateVehicle ;
95463: LD_ADDR_VAR 0 12
95467: PUSH
95468: CALL_OW 45
95472: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95473: LD_VAR 0 12
95477: PPUSH
95478: LD_VAR 0 8
95482: PPUSH
95483: LD_INT 0
95485: PPUSH
95486: CALL 102200 0 3
// end ;
95490: GO 95444
95492: POP
95493: POP
// if horses then
95494: LD_VAR 0 5
95498: IFFALSE 95565
// for i = 1 to horses do
95500: LD_ADDR_VAR 0 11
95504: PUSH
95505: DOUBLE
95506: LD_INT 1
95508: DEC
95509: ST_TO_ADDR
95510: LD_VAR 0 5
95514: PUSH
95515: FOR_TO
95516: IFFALSE 95563
// begin hc_class := 21 ;
95518: LD_ADDR_OWVAR 28
95522: PUSH
95523: LD_INT 21
95525: ST_TO_ADDR
// hc_gallery :=  ;
95526: LD_ADDR_OWVAR 33
95530: PUSH
95531: LD_STRING 
95533: ST_TO_ADDR
// animal := CreateHuman ;
95534: LD_ADDR_VAR 0 12
95538: PUSH
95539: CALL_OW 44
95543: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95544: LD_VAR 0 12
95548: PPUSH
95549: LD_VAR 0 8
95553: PPUSH
95554: LD_INT 0
95556: PPUSH
95557: CALL 102200 0 3
// end ;
95561: GO 95515
95563: POP
95564: POP
// if birds then
95565: LD_VAR 0 1
95569: IFFALSE 95636
// for i = 1 to birds do
95571: LD_ADDR_VAR 0 11
95575: PUSH
95576: DOUBLE
95577: LD_INT 1
95579: DEC
95580: ST_TO_ADDR
95581: LD_VAR 0 1
95585: PUSH
95586: FOR_TO
95587: IFFALSE 95634
// begin hc_class = 18 ;
95589: LD_ADDR_OWVAR 28
95593: PUSH
95594: LD_INT 18
95596: ST_TO_ADDR
// hc_gallery =  ;
95597: LD_ADDR_OWVAR 33
95601: PUSH
95602: LD_STRING 
95604: ST_TO_ADDR
// animal := CreateHuman ;
95605: LD_ADDR_VAR 0 12
95609: PUSH
95610: CALL_OW 44
95614: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95615: LD_VAR 0 12
95619: PPUSH
95620: LD_VAR 0 8
95624: PPUSH
95625: LD_INT 0
95627: PPUSH
95628: CALL 102200 0 3
// end ;
95632: GO 95586
95634: POP
95635: POP
// if tigers then
95636: LD_VAR 0 2
95640: IFFALSE 95724
// for i = 1 to tigers do
95642: LD_ADDR_VAR 0 11
95646: PUSH
95647: DOUBLE
95648: LD_INT 1
95650: DEC
95651: ST_TO_ADDR
95652: LD_VAR 0 2
95656: PUSH
95657: FOR_TO
95658: IFFALSE 95722
// begin hc_class = class_tiger ;
95660: LD_ADDR_OWVAR 28
95664: PUSH
95665: LD_INT 14
95667: ST_TO_ADDR
// hc_gallery =  ;
95668: LD_ADDR_OWVAR 33
95672: PUSH
95673: LD_STRING 
95675: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
95676: LD_ADDR_OWVAR 35
95680: PUSH
95681: LD_INT 7
95683: NEG
95684: PPUSH
95685: LD_INT 7
95687: PPUSH
95688: CALL_OW 12
95692: ST_TO_ADDR
// animal := CreateHuman ;
95693: LD_ADDR_VAR 0 12
95697: PUSH
95698: CALL_OW 44
95702: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95703: LD_VAR 0 12
95707: PPUSH
95708: LD_VAR 0 8
95712: PPUSH
95713: LD_INT 0
95715: PPUSH
95716: CALL 102200 0 3
// end ;
95720: GO 95657
95722: POP
95723: POP
// if apemans then
95724: LD_VAR 0 3
95728: IFFALSE 95851
// for i = 1 to apemans do
95730: LD_ADDR_VAR 0 11
95734: PUSH
95735: DOUBLE
95736: LD_INT 1
95738: DEC
95739: ST_TO_ADDR
95740: LD_VAR 0 3
95744: PUSH
95745: FOR_TO
95746: IFFALSE 95849
// begin hc_class = class_apeman ;
95748: LD_ADDR_OWVAR 28
95752: PUSH
95753: LD_INT 12
95755: ST_TO_ADDR
// hc_gallery =  ;
95756: LD_ADDR_OWVAR 33
95760: PUSH
95761: LD_STRING 
95763: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
95764: LD_ADDR_OWVAR 35
95768: PUSH
95769: LD_INT 5
95771: NEG
95772: PPUSH
95773: LD_INT 5
95775: PPUSH
95776: CALL_OW 12
95780: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
95781: LD_ADDR_OWVAR 31
95785: PUSH
95786: LD_INT 1
95788: PPUSH
95789: LD_INT 3
95791: PPUSH
95792: CALL_OW 12
95796: PUSH
95797: LD_INT 1
95799: PPUSH
95800: LD_INT 3
95802: PPUSH
95803: CALL_OW 12
95807: PUSH
95808: LD_INT 0
95810: PUSH
95811: LD_INT 0
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: ST_TO_ADDR
// animal := CreateHuman ;
95820: LD_ADDR_VAR 0 12
95824: PUSH
95825: CALL_OW 44
95829: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95830: LD_VAR 0 12
95834: PPUSH
95835: LD_VAR 0 8
95839: PPUSH
95840: LD_INT 0
95842: PPUSH
95843: CALL 102200 0 3
// end ;
95847: GO 95745
95849: POP
95850: POP
// if enchidnas then
95851: LD_VAR 0 4
95855: IFFALSE 95922
// for i = 1 to enchidnas do
95857: LD_ADDR_VAR 0 11
95861: PUSH
95862: DOUBLE
95863: LD_INT 1
95865: DEC
95866: ST_TO_ADDR
95867: LD_VAR 0 4
95871: PUSH
95872: FOR_TO
95873: IFFALSE 95920
// begin hc_class = 13 ;
95875: LD_ADDR_OWVAR 28
95879: PUSH
95880: LD_INT 13
95882: ST_TO_ADDR
// hc_gallery =  ;
95883: LD_ADDR_OWVAR 33
95887: PUSH
95888: LD_STRING 
95890: ST_TO_ADDR
// animal := CreateHuman ;
95891: LD_ADDR_VAR 0 12
95895: PUSH
95896: CALL_OW 44
95900: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95901: LD_VAR 0 12
95905: PPUSH
95906: LD_VAR 0 8
95910: PPUSH
95911: LD_INT 0
95913: PPUSH
95914: CALL 102200 0 3
// end ;
95918: GO 95872
95920: POP
95921: POP
// if fishes then
95922: LD_VAR 0 7
95926: IFFALSE 95993
// for i = 1 to fishes do
95928: LD_ADDR_VAR 0 11
95932: PUSH
95933: DOUBLE
95934: LD_INT 1
95936: DEC
95937: ST_TO_ADDR
95938: LD_VAR 0 7
95942: PUSH
95943: FOR_TO
95944: IFFALSE 95991
// begin hc_class = 20 ;
95946: LD_ADDR_OWVAR 28
95950: PUSH
95951: LD_INT 20
95953: ST_TO_ADDR
// hc_gallery =  ;
95954: LD_ADDR_OWVAR 33
95958: PUSH
95959: LD_STRING 
95961: ST_TO_ADDR
// animal := CreateHuman ;
95962: LD_ADDR_VAR 0 12
95966: PUSH
95967: CALL_OW 44
95971: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
95972: LD_VAR 0 12
95976: PPUSH
95977: LD_VAR 0 9
95981: PPUSH
95982: LD_INT 0
95984: PPUSH
95985: CALL 102200 0 3
// end ;
95989: GO 95943
95991: POP
95992: POP
// end ;
95993: LD_VAR 0 10
95997: RET
// export function WantHeal ( sci , unit ) ; begin
95998: LD_INT 0
96000: PPUSH
// if GetTaskList ( sci ) > 0 then
96001: LD_VAR 0 1
96005: PPUSH
96006: CALL_OW 437
96010: PUSH
96011: LD_INT 0
96013: GREATER
96014: IFFALSE 96084
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
96016: LD_VAR 0 1
96020: PPUSH
96021: CALL_OW 437
96025: PUSH
96026: LD_INT 1
96028: ARRAY
96029: PUSH
96030: LD_INT 1
96032: ARRAY
96033: PUSH
96034: LD_STRING l
96036: EQUAL
96037: PUSH
96038: LD_VAR 0 1
96042: PPUSH
96043: CALL_OW 437
96047: PUSH
96048: LD_INT 1
96050: ARRAY
96051: PUSH
96052: LD_INT 4
96054: ARRAY
96055: PUSH
96056: LD_VAR 0 2
96060: EQUAL
96061: AND
96062: IFFALSE 96074
// result := true else
96064: LD_ADDR_VAR 0 3
96068: PUSH
96069: LD_INT 1
96071: ST_TO_ADDR
96072: GO 96082
// result := false ;
96074: LD_ADDR_VAR 0 3
96078: PUSH
96079: LD_INT 0
96081: ST_TO_ADDR
// end else
96082: GO 96092
// result := false ;
96084: LD_ADDR_VAR 0 3
96088: PUSH
96089: LD_INT 0
96091: ST_TO_ADDR
// end ;
96092: LD_VAR 0 3
96096: RET
// export function HealTarget ( sci ) ; begin
96097: LD_INT 0
96099: PPUSH
// if not sci then
96100: LD_VAR 0 1
96104: NOT
96105: IFFALSE 96109
// exit ;
96107: GO 96174
// result := 0 ;
96109: LD_ADDR_VAR 0 2
96113: PUSH
96114: LD_INT 0
96116: ST_TO_ADDR
// if GetTaskList ( sci ) then
96117: LD_VAR 0 1
96121: PPUSH
96122: CALL_OW 437
96126: IFFALSE 96174
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
96128: LD_VAR 0 1
96132: PPUSH
96133: CALL_OW 437
96137: PUSH
96138: LD_INT 1
96140: ARRAY
96141: PUSH
96142: LD_INT 1
96144: ARRAY
96145: PUSH
96146: LD_STRING l
96148: EQUAL
96149: IFFALSE 96174
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
96151: LD_ADDR_VAR 0 2
96155: PUSH
96156: LD_VAR 0 1
96160: PPUSH
96161: CALL_OW 437
96165: PUSH
96166: LD_INT 1
96168: ARRAY
96169: PUSH
96170: LD_INT 4
96172: ARRAY
96173: ST_TO_ADDR
// end ;
96174: LD_VAR 0 2
96178: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
96179: LD_INT 0
96181: PPUSH
96182: PPUSH
96183: PPUSH
96184: PPUSH
96185: PPUSH
96186: PPUSH
96187: PPUSH
96188: PPUSH
96189: PPUSH
96190: PPUSH
96191: PPUSH
96192: PPUSH
96193: PPUSH
96194: PPUSH
96195: PPUSH
96196: PPUSH
96197: PPUSH
96198: PPUSH
96199: PPUSH
96200: PPUSH
96201: PPUSH
96202: PPUSH
96203: PPUSH
96204: PPUSH
96205: PPUSH
96206: PPUSH
96207: PPUSH
96208: PPUSH
96209: PPUSH
96210: PPUSH
96211: PPUSH
96212: PPUSH
96213: PPUSH
// if not list then
96214: LD_VAR 0 1
96218: NOT
96219: IFFALSE 96223
// exit ;
96221: GO 100811
// base := list [ 1 ] ;
96223: LD_ADDR_VAR 0 3
96227: PUSH
96228: LD_VAR 0 1
96232: PUSH
96233: LD_INT 1
96235: ARRAY
96236: ST_TO_ADDR
// group := list [ 2 ] ;
96237: LD_ADDR_VAR 0 4
96241: PUSH
96242: LD_VAR 0 1
96246: PUSH
96247: LD_INT 2
96249: ARRAY
96250: ST_TO_ADDR
// path := list [ 3 ] ;
96251: LD_ADDR_VAR 0 5
96255: PUSH
96256: LD_VAR 0 1
96260: PUSH
96261: LD_INT 3
96263: ARRAY
96264: ST_TO_ADDR
// flags := list [ 4 ] ;
96265: LD_ADDR_VAR 0 6
96269: PUSH
96270: LD_VAR 0 1
96274: PUSH
96275: LD_INT 4
96277: ARRAY
96278: ST_TO_ADDR
// mined := [ ] ;
96279: LD_ADDR_VAR 0 27
96283: PUSH
96284: EMPTY
96285: ST_TO_ADDR
// bombed := [ ] ;
96286: LD_ADDR_VAR 0 28
96290: PUSH
96291: EMPTY
96292: ST_TO_ADDR
// healers := [ ] ;
96293: LD_ADDR_VAR 0 31
96297: PUSH
96298: EMPTY
96299: ST_TO_ADDR
// to_heal := [ ] ;
96300: LD_ADDR_VAR 0 30
96304: PUSH
96305: EMPTY
96306: ST_TO_ADDR
// repairs := [ ] ;
96307: LD_ADDR_VAR 0 33
96311: PUSH
96312: EMPTY
96313: ST_TO_ADDR
// to_repair := [ ] ;
96314: LD_ADDR_VAR 0 32
96318: PUSH
96319: EMPTY
96320: ST_TO_ADDR
// if not group or not path then
96321: LD_VAR 0 4
96325: NOT
96326: PUSH
96327: LD_VAR 0 5
96331: NOT
96332: OR
96333: IFFALSE 96337
// exit ;
96335: GO 100811
// if flags then
96337: LD_VAR 0 6
96341: IFFALSE 96485
// begin f_ignore_area := flags [ 1 ] ;
96343: LD_ADDR_VAR 0 17
96347: PUSH
96348: LD_VAR 0 6
96352: PUSH
96353: LD_INT 1
96355: ARRAY
96356: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
96357: LD_ADDR_VAR 0 18
96361: PUSH
96362: LD_VAR 0 6
96366: PUSH
96367: LD_INT 2
96369: ARRAY
96370: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
96371: LD_ADDR_VAR 0 19
96375: PUSH
96376: LD_VAR 0 6
96380: PUSH
96381: LD_INT 3
96383: ARRAY
96384: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
96385: LD_ADDR_VAR 0 20
96389: PUSH
96390: LD_VAR 0 6
96394: PUSH
96395: LD_INT 4
96397: ARRAY
96398: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
96399: LD_ADDR_VAR 0 21
96403: PUSH
96404: LD_VAR 0 6
96408: PUSH
96409: LD_INT 5
96411: ARRAY
96412: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
96413: LD_ADDR_VAR 0 22
96417: PUSH
96418: LD_VAR 0 6
96422: PUSH
96423: LD_INT 6
96425: ARRAY
96426: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
96427: LD_ADDR_VAR 0 23
96431: PUSH
96432: LD_VAR 0 6
96436: PUSH
96437: LD_INT 7
96439: ARRAY
96440: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
96441: LD_ADDR_VAR 0 24
96445: PUSH
96446: LD_VAR 0 6
96450: PUSH
96451: LD_INT 8
96453: ARRAY
96454: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
96455: LD_ADDR_VAR 0 25
96459: PUSH
96460: LD_VAR 0 6
96464: PUSH
96465: LD_INT 9
96467: ARRAY
96468: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
96469: LD_ADDR_VAR 0 26
96473: PUSH
96474: LD_VAR 0 6
96478: PUSH
96479: LD_INT 10
96481: ARRAY
96482: ST_TO_ADDR
// end else
96483: GO 96565
// begin f_ignore_area := false ;
96485: LD_ADDR_VAR 0 17
96489: PUSH
96490: LD_INT 0
96492: ST_TO_ADDR
// f_capture := false ;
96493: LD_ADDR_VAR 0 18
96497: PUSH
96498: LD_INT 0
96500: ST_TO_ADDR
// f_ignore_civ := false ;
96501: LD_ADDR_VAR 0 19
96505: PUSH
96506: LD_INT 0
96508: ST_TO_ADDR
// f_murder := false ;
96509: LD_ADDR_VAR 0 20
96513: PUSH
96514: LD_INT 0
96516: ST_TO_ADDR
// f_mines := false ;
96517: LD_ADDR_VAR 0 21
96521: PUSH
96522: LD_INT 0
96524: ST_TO_ADDR
// f_repair := false ;
96525: LD_ADDR_VAR 0 22
96529: PUSH
96530: LD_INT 0
96532: ST_TO_ADDR
// f_heal := false ;
96533: LD_ADDR_VAR 0 23
96537: PUSH
96538: LD_INT 0
96540: ST_TO_ADDR
// f_spacetime := false ;
96541: LD_ADDR_VAR 0 24
96545: PUSH
96546: LD_INT 0
96548: ST_TO_ADDR
// f_attack_depot := false ;
96549: LD_ADDR_VAR 0 25
96553: PUSH
96554: LD_INT 0
96556: ST_TO_ADDR
// f_crawl := false ;
96557: LD_ADDR_VAR 0 26
96561: PUSH
96562: LD_INT 0
96564: ST_TO_ADDR
// end ; if f_heal then
96565: LD_VAR 0 23
96569: IFFALSE 96596
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
96571: LD_ADDR_VAR 0 31
96575: PUSH
96576: LD_VAR 0 4
96580: PPUSH
96581: LD_INT 25
96583: PUSH
96584: LD_INT 4
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PPUSH
96591: CALL_OW 72
96595: ST_TO_ADDR
// if f_repair then
96596: LD_VAR 0 22
96600: IFFALSE 96627
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
96602: LD_ADDR_VAR 0 33
96606: PUSH
96607: LD_VAR 0 4
96611: PPUSH
96612: LD_INT 25
96614: PUSH
96615: LD_INT 3
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PPUSH
96622: CALL_OW 72
96626: ST_TO_ADDR
// units_path := [ ] ;
96627: LD_ADDR_VAR 0 16
96631: PUSH
96632: EMPTY
96633: ST_TO_ADDR
// for i = 1 to group do
96634: LD_ADDR_VAR 0 7
96638: PUSH
96639: DOUBLE
96640: LD_INT 1
96642: DEC
96643: ST_TO_ADDR
96644: LD_VAR 0 4
96648: PUSH
96649: FOR_TO
96650: IFFALSE 96679
// units_path := Replace ( units_path , i , path ) ;
96652: LD_ADDR_VAR 0 16
96656: PUSH
96657: LD_VAR 0 16
96661: PPUSH
96662: LD_VAR 0 7
96666: PPUSH
96667: LD_VAR 0 5
96671: PPUSH
96672: CALL_OW 1
96676: ST_TO_ADDR
96677: GO 96649
96679: POP
96680: POP
// repeat for i = group downto 1 do
96681: LD_ADDR_VAR 0 7
96685: PUSH
96686: DOUBLE
96687: LD_VAR 0 4
96691: INC
96692: ST_TO_ADDR
96693: LD_INT 1
96695: PUSH
96696: FOR_DOWNTO
96697: IFFALSE 100793
// begin wait ( 5 ) ;
96699: LD_INT 5
96701: PPUSH
96702: CALL_OW 67
// tmp := [ ] ;
96706: LD_ADDR_VAR 0 14
96710: PUSH
96711: EMPTY
96712: ST_TO_ADDR
// attacking := false ;
96713: LD_ADDR_VAR 0 29
96717: PUSH
96718: LD_INT 0
96720: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
96721: LD_VAR 0 4
96725: PUSH
96726: LD_VAR 0 7
96730: ARRAY
96731: PPUSH
96732: CALL_OW 301
96736: PUSH
96737: LD_VAR 0 4
96741: PUSH
96742: LD_VAR 0 7
96746: ARRAY
96747: NOT
96748: OR
96749: IFFALSE 96858
// begin if GetType ( group [ i ] ) = unit_human then
96751: LD_VAR 0 4
96755: PUSH
96756: LD_VAR 0 7
96760: ARRAY
96761: PPUSH
96762: CALL_OW 247
96766: PUSH
96767: LD_INT 1
96769: EQUAL
96770: IFFALSE 96816
// begin to_heal := to_heal diff group [ i ] ;
96772: LD_ADDR_VAR 0 30
96776: PUSH
96777: LD_VAR 0 30
96781: PUSH
96782: LD_VAR 0 4
96786: PUSH
96787: LD_VAR 0 7
96791: ARRAY
96792: DIFF
96793: ST_TO_ADDR
// healers := healers diff group [ i ] ;
96794: LD_ADDR_VAR 0 31
96798: PUSH
96799: LD_VAR 0 31
96803: PUSH
96804: LD_VAR 0 4
96808: PUSH
96809: LD_VAR 0 7
96813: ARRAY
96814: DIFF
96815: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
96816: LD_ADDR_VAR 0 4
96820: PUSH
96821: LD_VAR 0 4
96825: PPUSH
96826: LD_VAR 0 7
96830: PPUSH
96831: CALL_OW 3
96835: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
96836: LD_ADDR_VAR 0 16
96840: PUSH
96841: LD_VAR 0 16
96845: PPUSH
96846: LD_VAR 0 7
96850: PPUSH
96851: CALL_OW 3
96855: ST_TO_ADDR
// continue ;
96856: GO 96696
// end ; if f_repair then
96858: LD_VAR 0 22
96862: IFFALSE 97351
// begin if GetType ( group [ i ] ) = unit_vehicle then
96864: LD_VAR 0 4
96868: PUSH
96869: LD_VAR 0 7
96873: ARRAY
96874: PPUSH
96875: CALL_OW 247
96879: PUSH
96880: LD_INT 2
96882: EQUAL
96883: IFFALSE 97073
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
96885: LD_VAR 0 4
96889: PUSH
96890: LD_VAR 0 7
96894: ARRAY
96895: PPUSH
96896: CALL_OW 256
96900: PUSH
96901: LD_INT 700
96903: LESS
96904: PUSH
96905: LD_VAR 0 4
96909: PUSH
96910: LD_VAR 0 7
96914: ARRAY
96915: PUSH
96916: LD_VAR 0 32
96920: IN
96921: NOT
96922: AND
96923: IFFALSE 96947
// to_repair := to_repair union group [ i ] ;
96925: LD_ADDR_VAR 0 32
96929: PUSH
96930: LD_VAR 0 32
96934: PUSH
96935: LD_VAR 0 4
96939: PUSH
96940: LD_VAR 0 7
96944: ARRAY
96945: UNION
96946: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
96947: LD_VAR 0 4
96951: PUSH
96952: LD_VAR 0 7
96956: ARRAY
96957: PPUSH
96958: CALL_OW 256
96962: PUSH
96963: LD_INT 1000
96965: EQUAL
96966: PUSH
96967: LD_VAR 0 4
96971: PUSH
96972: LD_VAR 0 7
96976: ARRAY
96977: PUSH
96978: LD_VAR 0 32
96982: IN
96983: AND
96984: IFFALSE 97008
// to_repair := to_repair diff group [ i ] ;
96986: LD_ADDR_VAR 0 32
96990: PUSH
96991: LD_VAR 0 32
96995: PUSH
96996: LD_VAR 0 4
97000: PUSH
97001: LD_VAR 0 7
97005: ARRAY
97006: DIFF
97007: ST_TO_ADDR
// if group [ i ] in to_repair then
97008: LD_VAR 0 4
97012: PUSH
97013: LD_VAR 0 7
97017: ARRAY
97018: PUSH
97019: LD_VAR 0 32
97023: IN
97024: IFFALSE 97071
// begin if not IsInArea ( group [ i ] , f_repair ) then
97026: LD_VAR 0 4
97030: PUSH
97031: LD_VAR 0 7
97035: ARRAY
97036: PPUSH
97037: LD_VAR 0 22
97041: PPUSH
97042: CALL_OW 308
97046: NOT
97047: IFFALSE 97069
// ComMoveToArea ( group [ i ] , f_repair ) ;
97049: LD_VAR 0 4
97053: PUSH
97054: LD_VAR 0 7
97058: ARRAY
97059: PPUSH
97060: LD_VAR 0 22
97064: PPUSH
97065: CALL_OW 113
// continue ;
97069: GO 96696
// end ; end else
97071: GO 97351
// if group [ i ] in repairs then
97073: LD_VAR 0 4
97077: PUSH
97078: LD_VAR 0 7
97082: ARRAY
97083: PUSH
97084: LD_VAR 0 33
97088: IN
97089: IFFALSE 97351
// begin if IsInUnit ( group [ i ] ) then
97091: LD_VAR 0 4
97095: PUSH
97096: LD_VAR 0 7
97100: ARRAY
97101: PPUSH
97102: CALL_OW 310
97106: IFFALSE 97174
// begin z := IsInUnit ( group [ i ] ) ;
97108: LD_ADDR_VAR 0 13
97112: PUSH
97113: LD_VAR 0 4
97117: PUSH
97118: LD_VAR 0 7
97122: ARRAY
97123: PPUSH
97124: CALL_OW 310
97128: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
97129: LD_VAR 0 13
97133: PUSH
97134: LD_VAR 0 32
97138: IN
97139: PUSH
97140: LD_VAR 0 13
97144: PPUSH
97145: LD_VAR 0 22
97149: PPUSH
97150: CALL_OW 308
97154: AND
97155: IFFALSE 97172
// ComExitVehicle ( group [ i ] ) ;
97157: LD_VAR 0 4
97161: PUSH
97162: LD_VAR 0 7
97166: ARRAY
97167: PPUSH
97168: CALL_OW 121
// end else
97172: GO 97351
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
97174: LD_ADDR_VAR 0 13
97178: PUSH
97179: LD_VAR 0 4
97183: PPUSH
97184: LD_INT 95
97186: PUSH
97187: LD_VAR 0 22
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 58
97198: PUSH
97199: EMPTY
97200: LIST
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PPUSH
97206: CALL_OW 72
97210: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
97211: LD_VAR 0 4
97215: PUSH
97216: LD_VAR 0 7
97220: ARRAY
97221: PPUSH
97222: CALL_OW 314
97226: NOT
97227: IFFALSE 97349
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
97229: LD_ADDR_VAR 0 10
97233: PUSH
97234: LD_VAR 0 13
97238: PPUSH
97239: LD_VAR 0 4
97243: PUSH
97244: LD_VAR 0 7
97248: ARRAY
97249: PPUSH
97250: CALL_OW 74
97254: ST_TO_ADDR
// if not x then
97255: LD_VAR 0 10
97259: NOT
97260: IFFALSE 97264
// continue ;
97262: GO 96696
// if GetLives ( x ) < 1000 then
97264: LD_VAR 0 10
97268: PPUSH
97269: CALL_OW 256
97273: PUSH
97274: LD_INT 1000
97276: LESS
97277: IFFALSE 97301
// ComRepairVehicle ( group [ i ] , x ) else
97279: LD_VAR 0 4
97283: PUSH
97284: LD_VAR 0 7
97288: ARRAY
97289: PPUSH
97290: LD_VAR 0 10
97294: PPUSH
97295: CALL_OW 129
97299: GO 97349
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
97301: LD_VAR 0 23
97305: PUSH
97306: LD_VAR 0 4
97310: PUSH
97311: LD_VAR 0 7
97315: ARRAY
97316: PPUSH
97317: CALL_OW 256
97321: PUSH
97322: LD_INT 1000
97324: LESS
97325: AND
97326: NOT
97327: IFFALSE 97349
// ComEnterUnit ( group [ i ] , x ) ;
97329: LD_VAR 0 4
97333: PUSH
97334: LD_VAR 0 7
97338: ARRAY
97339: PPUSH
97340: LD_VAR 0 10
97344: PPUSH
97345: CALL_OW 120
// end ; continue ;
97349: GO 96696
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
97351: LD_VAR 0 23
97355: PUSH
97356: LD_VAR 0 4
97360: PUSH
97361: LD_VAR 0 7
97365: ARRAY
97366: PPUSH
97367: CALL_OW 247
97371: PUSH
97372: LD_INT 1
97374: EQUAL
97375: AND
97376: IFFALSE 97854
// begin if group [ i ] in healers then
97378: LD_VAR 0 4
97382: PUSH
97383: LD_VAR 0 7
97387: ARRAY
97388: PUSH
97389: LD_VAR 0 31
97393: IN
97394: IFFALSE 97667
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
97396: LD_VAR 0 4
97400: PUSH
97401: LD_VAR 0 7
97405: ARRAY
97406: PPUSH
97407: LD_VAR 0 23
97411: PPUSH
97412: CALL_OW 308
97416: NOT
97417: PUSH
97418: LD_VAR 0 4
97422: PUSH
97423: LD_VAR 0 7
97427: ARRAY
97428: PPUSH
97429: CALL_OW 314
97433: NOT
97434: AND
97435: IFFALSE 97459
// ComMoveToArea ( group [ i ] , f_heal ) else
97437: LD_VAR 0 4
97441: PUSH
97442: LD_VAR 0 7
97446: ARRAY
97447: PPUSH
97448: LD_VAR 0 23
97452: PPUSH
97453: CALL_OW 113
97457: GO 97665
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
97459: LD_VAR 0 4
97463: PUSH
97464: LD_VAR 0 7
97468: ARRAY
97469: PPUSH
97470: CALL 96097 0 1
97474: PPUSH
97475: CALL_OW 256
97479: PUSH
97480: LD_INT 1000
97482: EQUAL
97483: IFFALSE 97502
// ComStop ( group [ i ] ) else
97485: LD_VAR 0 4
97489: PUSH
97490: LD_VAR 0 7
97494: ARRAY
97495: PPUSH
97496: CALL_OW 141
97500: GO 97665
// if not HasTask ( group [ i ] ) and to_heal then
97502: LD_VAR 0 4
97506: PUSH
97507: LD_VAR 0 7
97511: ARRAY
97512: PPUSH
97513: CALL_OW 314
97517: NOT
97518: PUSH
97519: LD_VAR 0 30
97523: AND
97524: IFFALSE 97665
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
97526: LD_ADDR_VAR 0 13
97530: PUSH
97531: LD_VAR 0 30
97535: PPUSH
97536: LD_INT 3
97538: PUSH
97539: LD_INT 54
97541: PUSH
97542: EMPTY
97543: LIST
97544: PUSH
97545: EMPTY
97546: LIST
97547: LIST
97548: PPUSH
97549: CALL_OW 72
97553: PPUSH
97554: LD_VAR 0 4
97558: PUSH
97559: LD_VAR 0 7
97563: ARRAY
97564: PPUSH
97565: CALL_OW 74
97569: ST_TO_ADDR
// if z then
97570: LD_VAR 0 13
97574: IFFALSE 97665
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
97576: LD_INT 91
97578: PUSH
97579: LD_VAR 0 13
97583: PUSH
97584: LD_INT 10
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: LIST
97591: PUSH
97592: LD_INT 81
97594: PUSH
97595: LD_VAR 0 13
97599: PPUSH
97600: CALL_OW 255
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: EMPTY
97610: LIST
97611: LIST
97612: PPUSH
97613: CALL_OW 69
97617: PUSH
97618: LD_INT 0
97620: EQUAL
97621: IFFALSE 97645
// ComHeal ( group [ i ] , z ) else
97623: LD_VAR 0 4
97627: PUSH
97628: LD_VAR 0 7
97632: ARRAY
97633: PPUSH
97634: LD_VAR 0 13
97638: PPUSH
97639: CALL_OW 128
97643: GO 97665
// ComMoveToArea ( group [ i ] , f_heal ) ;
97645: LD_VAR 0 4
97649: PUSH
97650: LD_VAR 0 7
97654: ARRAY
97655: PPUSH
97656: LD_VAR 0 23
97660: PPUSH
97661: CALL_OW 113
// end ; continue ;
97665: GO 96696
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
97667: LD_VAR 0 4
97671: PUSH
97672: LD_VAR 0 7
97676: ARRAY
97677: PPUSH
97678: CALL_OW 256
97682: PUSH
97683: LD_INT 700
97685: LESS
97686: PUSH
97687: LD_VAR 0 4
97691: PUSH
97692: LD_VAR 0 7
97696: ARRAY
97697: PUSH
97698: LD_VAR 0 30
97702: IN
97703: NOT
97704: AND
97705: IFFALSE 97729
// to_heal := to_heal union group [ i ] ;
97707: LD_ADDR_VAR 0 30
97711: PUSH
97712: LD_VAR 0 30
97716: PUSH
97717: LD_VAR 0 4
97721: PUSH
97722: LD_VAR 0 7
97726: ARRAY
97727: UNION
97728: ST_TO_ADDR
// if group [ i ] in to_heal then
97729: LD_VAR 0 4
97733: PUSH
97734: LD_VAR 0 7
97738: ARRAY
97739: PUSH
97740: LD_VAR 0 30
97744: IN
97745: IFFALSE 97854
// begin if GetLives ( group [ i ] ) = 1000 then
97747: LD_VAR 0 4
97751: PUSH
97752: LD_VAR 0 7
97756: ARRAY
97757: PPUSH
97758: CALL_OW 256
97762: PUSH
97763: LD_INT 1000
97765: EQUAL
97766: IFFALSE 97792
// to_heal := to_heal diff group [ i ] else
97768: LD_ADDR_VAR 0 30
97772: PUSH
97773: LD_VAR 0 30
97777: PUSH
97778: LD_VAR 0 4
97782: PUSH
97783: LD_VAR 0 7
97787: ARRAY
97788: DIFF
97789: ST_TO_ADDR
97790: GO 97854
// begin if not IsInArea ( group [ i ] , to_heal ) then
97792: LD_VAR 0 4
97796: PUSH
97797: LD_VAR 0 7
97801: ARRAY
97802: PPUSH
97803: LD_VAR 0 30
97807: PPUSH
97808: CALL_OW 308
97812: NOT
97813: IFFALSE 97837
// ComMoveToArea ( group [ i ] , f_heal ) else
97815: LD_VAR 0 4
97819: PUSH
97820: LD_VAR 0 7
97824: ARRAY
97825: PPUSH
97826: LD_VAR 0 23
97830: PPUSH
97831: CALL_OW 113
97835: GO 97852
// ComHold ( group [ i ] ) ;
97837: LD_VAR 0 4
97841: PUSH
97842: LD_VAR 0 7
97846: ARRAY
97847: PPUSH
97848: CALL_OW 140
// continue ;
97852: GO 96696
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
97854: LD_VAR 0 4
97858: PUSH
97859: LD_VAR 0 7
97863: ARRAY
97864: PPUSH
97865: LD_INT 10
97867: PPUSH
97868: CALL 94494 0 2
97872: NOT
97873: PUSH
97874: LD_VAR 0 16
97878: PUSH
97879: LD_VAR 0 7
97883: ARRAY
97884: PUSH
97885: EMPTY
97886: EQUAL
97887: NOT
97888: AND
97889: IFFALSE 98155
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
97891: LD_VAR 0 4
97895: PUSH
97896: LD_VAR 0 7
97900: ARRAY
97901: PPUSH
97902: CALL_OW 262
97906: PUSH
97907: LD_INT 1
97909: PUSH
97910: LD_INT 2
97912: PUSH
97913: EMPTY
97914: LIST
97915: LIST
97916: IN
97917: IFFALSE 97958
// if GetFuel ( group [ i ] ) < 10 then
97919: LD_VAR 0 4
97923: PUSH
97924: LD_VAR 0 7
97928: ARRAY
97929: PPUSH
97930: CALL_OW 261
97934: PUSH
97935: LD_INT 10
97937: LESS
97938: IFFALSE 97958
// SetFuel ( group [ i ] , 12 ) ;
97940: LD_VAR 0 4
97944: PUSH
97945: LD_VAR 0 7
97949: ARRAY
97950: PPUSH
97951: LD_INT 12
97953: PPUSH
97954: CALL_OW 240
// if units_path [ i ] then
97958: LD_VAR 0 16
97962: PUSH
97963: LD_VAR 0 7
97967: ARRAY
97968: IFFALSE 98153
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
97970: LD_VAR 0 4
97974: PUSH
97975: LD_VAR 0 7
97979: ARRAY
97980: PPUSH
97981: LD_VAR 0 16
97985: PUSH
97986: LD_VAR 0 7
97990: ARRAY
97991: PUSH
97992: LD_INT 1
97994: ARRAY
97995: PUSH
97996: LD_INT 1
97998: ARRAY
97999: PPUSH
98000: LD_VAR 0 16
98004: PUSH
98005: LD_VAR 0 7
98009: ARRAY
98010: PUSH
98011: LD_INT 1
98013: ARRAY
98014: PUSH
98015: LD_INT 2
98017: ARRAY
98018: PPUSH
98019: CALL_OW 297
98023: PUSH
98024: LD_INT 6
98026: GREATER
98027: IFFALSE 98102
// begin if not HasTask ( group [ i ] ) then
98029: LD_VAR 0 4
98033: PUSH
98034: LD_VAR 0 7
98038: ARRAY
98039: PPUSH
98040: CALL_OW 314
98044: NOT
98045: IFFALSE 98100
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
98047: LD_VAR 0 4
98051: PUSH
98052: LD_VAR 0 7
98056: ARRAY
98057: PPUSH
98058: LD_VAR 0 16
98062: PUSH
98063: LD_VAR 0 7
98067: ARRAY
98068: PUSH
98069: LD_INT 1
98071: ARRAY
98072: PUSH
98073: LD_INT 1
98075: ARRAY
98076: PPUSH
98077: LD_VAR 0 16
98081: PUSH
98082: LD_VAR 0 7
98086: ARRAY
98087: PUSH
98088: LD_INT 1
98090: ARRAY
98091: PUSH
98092: LD_INT 2
98094: ARRAY
98095: PPUSH
98096: CALL_OW 114
// end else
98100: GO 98153
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
98102: LD_ADDR_VAR 0 15
98106: PUSH
98107: LD_VAR 0 16
98111: PUSH
98112: LD_VAR 0 7
98116: ARRAY
98117: PPUSH
98118: LD_INT 1
98120: PPUSH
98121: CALL_OW 3
98125: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
98126: LD_ADDR_VAR 0 16
98130: PUSH
98131: LD_VAR 0 16
98135: PPUSH
98136: LD_VAR 0 7
98140: PPUSH
98141: LD_VAR 0 15
98145: PPUSH
98146: CALL_OW 1
98150: ST_TO_ADDR
// continue ;
98151: GO 96696
// end ; end ; end else
98153: GO 100791
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
98155: LD_ADDR_VAR 0 14
98159: PUSH
98160: LD_INT 81
98162: PUSH
98163: LD_VAR 0 4
98167: PUSH
98168: LD_VAR 0 7
98172: ARRAY
98173: PPUSH
98174: CALL_OW 255
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: PPUSH
98183: CALL_OW 69
98187: ST_TO_ADDR
// if not tmp then
98188: LD_VAR 0 14
98192: NOT
98193: IFFALSE 98197
// continue ;
98195: GO 96696
// if f_ignore_area then
98197: LD_VAR 0 17
98201: IFFALSE 98289
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
98203: LD_ADDR_VAR 0 15
98207: PUSH
98208: LD_VAR 0 14
98212: PPUSH
98213: LD_INT 3
98215: PUSH
98216: LD_INT 92
98218: PUSH
98219: LD_VAR 0 17
98223: PUSH
98224: LD_INT 1
98226: ARRAY
98227: PUSH
98228: LD_VAR 0 17
98232: PUSH
98233: LD_INT 2
98235: ARRAY
98236: PUSH
98237: LD_VAR 0 17
98241: PUSH
98242: LD_INT 3
98244: ARRAY
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: PUSH
98252: EMPTY
98253: LIST
98254: LIST
98255: PPUSH
98256: CALL_OW 72
98260: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
98261: LD_VAR 0 14
98265: PUSH
98266: LD_VAR 0 15
98270: DIFF
98271: IFFALSE 98289
// tmp := tmp diff tmp2 ;
98273: LD_ADDR_VAR 0 14
98277: PUSH
98278: LD_VAR 0 14
98282: PUSH
98283: LD_VAR 0 15
98287: DIFF
98288: ST_TO_ADDR
// end ; if not f_murder then
98289: LD_VAR 0 20
98293: NOT
98294: IFFALSE 98352
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
98296: LD_ADDR_VAR 0 15
98300: PUSH
98301: LD_VAR 0 14
98305: PPUSH
98306: LD_INT 3
98308: PUSH
98309: LD_INT 50
98311: PUSH
98312: EMPTY
98313: LIST
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: PPUSH
98319: CALL_OW 72
98323: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
98324: LD_VAR 0 14
98328: PUSH
98329: LD_VAR 0 15
98333: DIFF
98334: IFFALSE 98352
// tmp := tmp diff tmp2 ;
98336: LD_ADDR_VAR 0 14
98340: PUSH
98341: LD_VAR 0 14
98345: PUSH
98346: LD_VAR 0 15
98350: DIFF
98351: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
98352: LD_ADDR_VAR 0 14
98356: PUSH
98357: LD_VAR 0 4
98361: PUSH
98362: LD_VAR 0 7
98366: ARRAY
98367: PPUSH
98368: LD_VAR 0 14
98372: PPUSH
98373: LD_INT 1
98375: PPUSH
98376: LD_INT 1
98378: PPUSH
98379: CALL 68161 0 4
98383: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
98384: LD_VAR 0 4
98388: PUSH
98389: LD_VAR 0 7
98393: ARRAY
98394: PPUSH
98395: CALL_OW 257
98399: PUSH
98400: LD_INT 1
98402: EQUAL
98403: IFFALSE 98851
// begin if WantPlant ( group [ i ] ) then
98405: LD_VAR 0 4
98409: PUSH
98410: LD_VAR 0 7
98414: ARRAY
98415: PPUSH
98416: CALL 67662 0 1
98420: IFFALSE 98424
// continue ;
98422: GO 96696
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
98424: LD_VAR 0 18
98428: PUSH
98429: LD_VAR 0 4
98433: PUSH
98434: LD_VAR 0 7
98438: ARRAY
98439: PPUSH
98440: CALL_OW 310
98444: NOT
98445: AND
98446: PUSH
98447: LD_VAR 0 14
98451: PUSH
98452: LD_INT 1
98454: ARRAY
98455: PUSH
98456: LD_VAR 0 14
98460: PPUSH
98461: LD_INT 21
98463: PUSH
98464: LD_INT 2
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 58
98473: PUSH
98474: EMPTY
98475: LIST
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PPUSH
98481: CALL_OW 72
98485: IN
98486: AND
98487: IFFALSE 98523
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
98489: LD_VAR 0 4
98493: PUSH
98494: LD_VAR 0 7
98498: ARRAY
98499: PPUSH
98500: LD_VAR 0 14
98504: PUSH
98505: LD_INT 1
98507: ARRAY
98508: PPUSH
98509: CALL_OW 120
// attacking := true ;
98513: LD_ADDR_VAR 0 29
98517: PUSH
98518: LD_INT 1
98520: ST_TO_ADDR
// continue ;
98521: GO 96696
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
98523: LD_VAR 0 26
98527: PUSH
98528: LD_VAR 0 4
98532: PUSH
98533: LD_VAR 0 7
98537: ARRAY
98538: PPUSH
98539: CALL_OW 257
98543: PUSH
98544: LD_INT 1
98546: EQUAL
98547: AND
98548: PUSH
98549: LD_VAR 0 4
98553: PUSH
98554: LD_VAR 0 7
98558: ARRAY
98559: PPUSH
98560: CALL_OW 256
98564: PUSH
98565: LD_INT 800
98567: LESS
98568: AND
98569: PUSH
98570: LD_VAR 0 4
98574: PUSH
98575: LD_VAR 0 7
98579: ARRAY
98580: PPUSH
98581: CALL_OW 318
98585: NOT
98586: AND
98587: IFFALSE 98604
// ComCrawl ( group [ i ] ) ;
98589: LD_VAR 0 4
98593: PUSH
98594: LD_VAR 0 7
98598: ARRAY
98599: PPUSH
98600: CALL_OW 137
// if f_mines then
98604: LD_VAR 0 21
98608: IFFALSE 98851
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
98610: LD_VAR 0 14
98614: PUSH
98615: LD_INT 1
98617: ARRAY
98618: PPUSH
98619: CALL_OW 247
98623: PUSH
98624: LD_INT 3
98626: EQUAL
98627: PUSH
98628: LD_VAR 0 14
98632: PUSH
98633: LD_INT 1
98635: ARRAY
98636: PUSH
98637: LD_VAR 0 27
98641: IN
98642: NOT
98643: AND
98644: IFFALSE 98851
// begin x := GetX ( tmp [ 1 ] ) ;
98646: LD_ADDR_VAR 0 10
98650: PUSH
98651: LD_VAR 0 14
98655: PUSH
98656: LD_INT 1
98658: ARRAY
98659: PPUSH
98660: CALL_OW 250
98664: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
98665: LD_ADDR_VAR 0 11
98669: PUSH
98670: LD_VAR 0 14
98674: PUSH
98675: LD_INT 1
98677: ARRAY
98678: PPUSH
98679: CALL_OW 251
98683: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
98684: LD_ADDR_VAR 0 12
98688: PUSH
98689: LD_VAR 0 4
98693: PUSH
98694: LD_VAR 0 7
98698: ARRAY
98699: PPUSH
98700: CALL 94579 0 1
98704: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
98705: LD_VAR 0 4
98709: PUSH
98710: LD_VAR 0 7
98714: ARRAY
98715: PPUSH
98716: LD_VAR 0 10
98720: PPUSH
98721: LD_VAR 0 11
98725: PPUSH
98726: LD_VAR 0 14
98730: PUSH
98731: LD_INT 1
98733: ARRAY
98734: PPUSH
98735: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
98739: LD_VAR 0 4
98743: PUSH
98744: LD_VAR 0 7
98748: ARRAY
98749: PPUSH
98750: LD_VAR 0 10
98754: PPUSH
98755: LD_VAR 0 12
98759: PPUSH
98760: LD_INT 7
98762: PPUSH
98763: CALL_OW 272
98767: PPUSH
98768: LD_VAR 0 11
98772: PPUSH
98773: LD_VAR 0 12
98777: PPUSH
98778: LD_INT 7
98780: PPUSH
98781: CALL_OW 273
98785: PPUSH
98786: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
98790: LD_VAR 0 4
98794: PUSH
98795: LD_VAR 0 7
98799: ARRAY
98800: PPUSH
98801: LD_INT 71
98803: PPUSH
98804: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
98808: LD_ADDR_VAR 0 27
98812: PUSH
98813: LD_VAR 0 27
98817: PPUSH
98818: LD_VAR 0 27
98822: PUSH
98823: LD_INT 1
98825: PLUS
98826: PPUSH
98827: LD_VAR 0 14
98831: PUSH
98832: LD_INT 1
98834: ARRAY
98835: PPUSH
98836: CALL_OW 1
98840: ST_TO_ADDR
// attacking := true ;
98841: LD_ADDR_VAR 0 29
98845: PUSH
98846: LD_INT 1
98848: ST_TO_ADDR
// continue ;
98849: GO 96696
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
98851: LD_VAR 0 4
98855: PUSH
98856: LD_VAR 0 7
98860: ARRAY
98861: PPUSH
98862: CALL_OW 257
98866: PUSH
98867: LD_INT 17
98869: EQUAL
98870: PUSH
98871: LD_VAR 0 4
98875: PUSH
98876: LD_VAR 0 7
98880: ARRAY
98881: PPUSH
98882: CALL_OW 110
98886: PUSH
98887: LD_INT 71
98889: EQUAL
98890: NOT
98891: AND
98892: IFFALSE 99038
// begin attacking := false ;
98894: LD_ADDR_VAR 0 29
98898: PUSH
98899: LD_INT 0
98901: ST_TO_ADDR
// k := 5 ;
98902: LD_ADDR_VAR 0 9
98906: PUSH
98907: LD_INT 5
98909: ST_TO_ADDR
// if tmp < k then
98910: LD_VAR 0 14
98914: PUSH
98915: LD_VAR 0 9
98919: LESS
98920: IFFALSE 98932
// k := tmp ;
98922: LD_ADDR_VAR 0 9
98926: PUSH
98927: LD_VAR 0 14
98931: ST_TO_ADDR
// for j = 1 to k do
98932: LD_ADDR_VAR 0 8
98936: PUSH
98937: DOUBLE
98938: LD_INT 1
98940: DEC
98941: ST_TO_ADDR
98942: LD_VAR 0 9
98946: PUSH
98947: FOR_TO
98948: IFFALSE 99036
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
98950: LD_VAR 0 14
98954: PUSH
98955: LD_VAR 0 8
98959: ARRAY
98960: PUSH
98961: LD_VAR 0 14
98965: PPUSH
98966: LD_INT 58
98968: PUSH
98969: EMPTY
98970: LIST
98971: PPUSH
98972: CALL_OW 72
98976: IN
98977: NOT
98978: IFFALSE 99034
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98980: LD_VAR 0 4
98984: PUSH
98985: LD_VAR 0 7
98989: ARRAY
98990: PPUSH
98991: LD_VAR 0 14
98995: PUSH
98996: LD_VAR 0 8
99000: ARRAY
99001: PPUSH
99002: CALL_OW 115
// attacking := true ;
99006: LD_ADDR_VAR 0 29
99010: PUSH
99011: LD_INT 1
99013: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
99014: LD_VAR 0 4
99018: PUSH
99019: LD_VAR 0 7
99023: ARRAY
99024: PPUSH
99025: LD_INT 71
99027: PPUSH
99028: CALL_OW 109
// continue ;
99032: GO 98947
// end ; end ;
99034: GO 98947
99036: POP
99037: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
99038: LD_VAR 0 4
99042: PUSH
99043: LD_VAR 0 7
99047: ARRAY
99048: PPUSH
99049: CALL_OW 257
99053: PUSH
99054: LD_INT 8
99056: EQUAL
99057: PUSH
99058: LD_VAR 0 4
99062: PUSH
99063: LD_VAR 0 7
99067: ARRAY
99068: PPUSH
99069: CALL_OW 264
99073: PUSH
99074: LD_INT 28
99076: PUSH
99077: LD_INT 45
99079: PUSH
99080: LD_INT 7
99082: PUSH
99083: LD_INT 47
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: LIST
99090: LIST
99091: IN
99092: OR
99093: IFFALSE 99323
// begin attacking := false ;
99095: LD_ADDR_VAR 0 29
99099: PUSH
99100: LD_INT 0
99102: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
99103: LD_VAR 0 14
99107: PUSH
99108: LD_INT 1
99110: ARRAY
99111: PPUSH
99112: CALL_OW 266
99116: PUSH
99117: LD_INT 32
99119: PUSH
99120: LD_INT 31
99122: PUSH
99123: LD_INT 33
99125: PUSH
99126: LD_INT 4
99128: PUSH
99129: LD_INT 5
99131: PUSH
99132: EMPTY
99133: LIST
99134: LIST
99135: LIST
99136: LIST
99137: LIST
99138: IN
99139: IFFALSE 99323
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
99141: LD_ADDR_VAR 0 9
99145: PUSH
99146: LD_VAR 0 14
99150: PUSH
99151: LD_INT 1
99153: ARRAY
99154: PPUSH
99155: CALL_OW 266
99159: PPUSH
99160: LD_VAR 0 14
99164: PUSH
99165: LD_INT 1
99167: ARRAY
99168: PPUSH
99169: CALL_OW 250
99173: PPUSH
99174: LD_VAR 0 14
99178: PUSH
99179: LD_INT 1
99181: ARRAY
99182: PPUSH
99183: CALL_OW 251
99187: PPUSH
99188: LD_VAR 0 14
99192: PUSH
99193: LD_INT 1
99195: ARRAY
99196: PPUSH
99197: CALL_OW 254
99201: PPUSH
99202: LD_VAR 0 14
99206: PUSH
99207: LD_INT 1
99209: ARRAY
99210: PPUSH
99211: CALL_OW 248
99215: PPUSH
99216: LD_INT 0
99218: PPUSH
99219: CALL 75955 0 6
99223: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
99224: LD_ADDR_VAR 0 8
99228: PUSH
99229: LD_VAR 0 4
99233: PUSH
99234: LD_VAR 0 7
99238: ARRAY
99239: PPUSH
99240: LD_VAR 0 9
99244: PPUSH
99245: CALL 94642 0 2
99249: ST_TO_ADDR
// if j then
99250: LD_VAR 0 8
99254: IFFALSE 99323
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
99256: LD_VAR 0 8
99260: PUSH
99261: LD_INT 1
99263: ARRAY
99264: PPUSH
99265: LD_VAR 0 8
99269: PUSH
99270: LD_INT 2
99272: ARRAY
99273: PPUSH
99274: CALL_OW 488
99278: IFFALSE 99323
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
99280: LD_VAR 0 4
99284: PUSH
99285: LD_VAR 0 7
99289: ARRAY
99290: PPUSH
99291: LD_VAR 0 8
99295: PUSH
99296: LD_INT 1
99298: ARRAY
99299: PPUSH
99300: LD_VAR 0 8
99304: PUSH
99305: LD_INT 2
99307: ARRAY
99308: PPUSH
99309: CALL_OW 116
// attacking := true ;
99313: LD_ADDR_VAR 0 29
99317: PUSH
99318: LD_INT 1
99320: ST_TO_ADDR
// continue ;
99321: GO 96696
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
99323: LD_VAR 0 4
99327: PUSH
99328: LD_VAR 0 7
99332: ARRAY
99333: PPUSH
99334: CALL_OW 265
99338: PUSH
99339: LD_INT 11
99341: EQUAL
99342: IFFALSE 99620
// begin k := 10 ;
99344: LD_ADDR_VAR 0 9
99348: PUSH
99349: LD_INT 10
99351: ST_TO_ADDR
// x := 0 ;
99352: LD_ADDR_VAR 0 10
99356: PUSH
99357: LD_INT 0
99359: ST_TO_ADDR
// if tmp < k then
99360: LD_VAR 0 14
99364: PUSH
99365: LD_VAR 0 9
99369: LESS
99370: IFFALSE 99382
// k := tmp ;
99372: LD_ADDR_VAR 0 9
99376: PUSH
99377: LD_VAR 0 14
99381: ST_TO_ADDR
// for j = k downto 1 do
99382: LD_ADDR_VAR 0 8
99386: PUSH
99387: DOUBLE
99388: LD_VAR 0 9
99392: INC
99393: ST_TO_ADDR
99394: LD_INT 1
99396: PUSH
99397: FOR_DOWNTO
99398: IFFALSE 99473
// begin if GetType ( tmp [ j ] ) = unit_human then
99400: LD_VAR 0 14
99404: PUSH
99405: LD_VAR 0 8
99409: ARRAY
99410: PPUSH
99411: CALL_OW 247
99415: PUSH
99416: LD_INT 1
99418: EQUAL
99419: IFFALSE 99471
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
99421: LD_VAR 0 4
99425: PUSH
99426: LD_VAR 0 7
99430: ARRAY
99431: PPUSH
99432: LD_VAR 0 14
99436: PUSH
99437: LD_VAR 0 8
99441: ARRAY
99442: PPUSH
99443: CALL 94913 0 2
// x := tmp [ j ] ;
99447: LD_ADDR_VAR 0 10
99451: PUSH
99452: LD_VAR 0 14
99456: PUSH
99457: LD_VAR 0 8
99461: ARRAY
99462: ST_TO_ADDR
// attacking := true ;
99463: LD_ADDR_VAR 0 29
99467: PUSH
99468: LD_INT 1
99470: ST_TO_ADDR
// end ; end ;
99471: GO 99397
99473: POP
99474: POP
// if not x then
99475: LD_VAR 0 10
99479: NOT
99480: IFFALSE 99620
// begin attacking := true ;
99482: LD_ADDR_VAR 0 29
99486: PUSH
99487: LD_INT 1
99489: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
99490: LD_VAR 0 4
99494: PUSH
99495: LD_VAR 0 7
99499: ARRAY
99500: PPUSH
99501: CALL_OW 250
99505: PPUSH
99506: LD_VAR 0 4
99510: PUSH
99511: LD_VAR 0 7
99515: ARRAY
99516: PPUSH
99517: CALL_OW 251
99521: PPUSH
99522: CALL_OW 546
99526: PUSH
99527: LD_INT 2
99529: ARRAY
99530: PUSH
99531: LD_VAR 0 14
99535: PUSH
99536: LD_INT 1
99538: ARRAY
99539: PPUSH
99540: CALL_OW 250
99544: PPUSH
99545: LD_VAR 0 14
99549: PUSH
99550: LD_INT 1
99552: ARRAY
99553: PPUSH
99554: CALL_OW 251
99558: PPUSH
99559: CALL_OW 546
99563: PUSH
99564: LD_INT 2
99566: ARRAY
99567: EQUAL
99568: IFFALSE 99596
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
99570: LD_VAR 0 4
99574: PUSH
99575: LD_VAR 0 7
99579: ARRAY
99580: PPUSH
99581: LD_VAR 0 14
99585: PUSH
99586: LD_INT 1
99588: ARRAY
99589: PPUSH
99590: CALL 94913 0 2
99594: GO 99620
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99596: LD_VAR 0 4
99600: PUSH
99601: LD_VAR 0 7
99605: ARRAY
99606: PPUSH
99607: LD_VAR 0 14
99611: PUSH
99612: LD_INT 1
99614: ARRAY
99615: PPUSH
99616: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
99620: LD_VAR 0 4
99624: PUSH
99625: LD_VAR 0 7
99629: ARRAY
99630: PPUSH
99631: CALL_OW 264
99635: PUSH
99636: LD_INT 29
99638: EQUAL
99639: IFFALSE 100005
// begin if WantsToAttack ( group [ i ] ) in bombed then
99641: LD_VAR 0 4
99645: PUSH
99646: LD_VAR 0 7
99650: ARRAY
99651: PPUSH
99652: CALL_OW 319
99656: PUSH
99657: LD_VAR 0 28
99661: IN
99662: IFFALSE 99666
// continue ;
99664: GO 96696
// k := 8 ;
99666: LD_ADDR_VAR 0 9
99670: PUSH
99671: LD_INT 8
99673: ST_TO_ADDR
// x := 0 ;
99674: LD_ADDR_VAR 0 10
99678: PUSH
99679: LD_INT 0
99681: ST_TO_ADDR
// if tmp < k then
99682: LD_VAR 0 14
99686: PUSH
99687: LD_VAR 0 9
99691: LESS
99692: IFFALSE 99704
// k := tmp ;
99694: LD_ADDR_VAR 0 9
99698: PUSH
99699: LD_VAR 0 14
99703: ST_TO_ADDR
// for j = 1 to k do
99704: LD_ADDR_VAR 0 8
99708: PUSH
99709: DOUBLE
99710: LD_INT 1
99712: DEC
99713: ST_TO_ADDR
99714: LD_VAR 0 9
99718: PUSH
99719: FOR_TO
99720: IFFALSE 99852
// begin if GetType ( tmp [ j ] ) = unit_building then
99722: LD_VAR 0 14
99726: PUSH
99727: LD_VAR 0 8
99731: ARRAY
99732: PPUSH
99733: CALL_OW 247
99737: PUSH
99738: LD_INT 3
99740: EQUAL
99741: IFFALSE 99850
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
99743: LD_VAR 0 14
99747: PUSH
99748: LD_VAR 0 8
99752: ARRAY
99753: PUSH
99754: LD_VAR 0 28
99758: IN
99759: NOT
99760: PUSH
99761: LD_VAR 0 14
99765: PUSH
99766: LD_VAR 0 8
99770: ARRAY
99771: PPUSH
99772: CALL_OW 313
99776: AND
99777: IFFALSE 99850
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99779: LD_VAR 0 4
99783: PUSH
99784: LD_VAR 0 7
99788: ARRAY
99789: PPUSH
99790: LD_VAR 0 14
99794: PUSH
99795: LD_VAR 0 8
99799: ARRAY
99800: PPUSH
99801: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
99805: LD_ADDR_VAR 0 28
99809: PUSH
99810: LD_VAR 0 28
99814: PPUSH
99815: LD_VAR 0 28
99819: PUSH
99820: LD_INT 1
99822: PLUS
99823: PPUSH
99824: LD_VAR 0 14
99828: PUSH
99829: LD_VAR 0 8
99833: ARRAY
99834: PPUSH
99835: CALL_OW 1
99839: ST_TO_ADDR
// attacking := true ;
99840: LD_ADDR_VAR 0 29
99844: PUSH
99845: LD_INT 1
99847: ST_TO_ADDR
// break ;
99848: GO 99852
// end ; end ;
99850: GO 99719
99852: POP
99853: POP
// if not attacking and f_attack_depot then
99854: LD_VAR 0 29
99858: NOT
99859: PUSH
99860: LD_VAR 0 25
99864: AND
99865: IFFALSE 99960
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99867: LD_ADDR_VAR 0 13
99871: PUSH
99872: LD_VAR 0 14
99876: PPUSH
99877: LD_INT 2
99879: PUSH
99880: LD_INT 30
99882: PUSH
99883: LD_INT 0
99885: PUSH
99886: EMPTY
99887: LIST
99888: LIST
99889: PUSH
99890: LD_INT 30
99892: PUSH
99893: LD_INT 1
99895: PUSH
99896: EMPTY
99897: LIST
99898: LIST
99899: PUSH
99900: EMPTY
99901: LIST
99902: LIST
99903: LIST
99904: PPUSH
99905: CALL_OW 72
99909: ST_TO_ADDR
// if z then
99910: LD_VAR 0 13
99914: IFFALSE 99960
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
99916: LD_VAR 0 4
99920: PUSH
99921: LD_VAR 0 7
99925: ARRAY
99926: PPUSH
99927: LD_VAR 0 13
99931: PPUSH
99932: LD_VAR 0 4
99936: PUSH
99937: LD_VAR 0 7
99941: ARRAY
99942: PPUSH
99943: CALL_OW 74
99947: PPUSH
99948: CALL_OW 115
// attacking := true ;
99952: LD_ADDR_VAR 0 29
99956: PUSH
99957: LD_INT 1
99959: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
99960: LD_VAR 0 4
99964: PUSH
99965: LD_VAR 0 7
99969: ARRAY
99970: PPUSH
99971: CALL_OW 256
99975: PUSH
99976: LD_INT 500
99978: LESS
99979: IFFALSE 100005
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99981: LD_VAR 0 4
99985: PUSH
99986: LD_VAR 0 7
99990: ARRAY
99991: PPUSH
99992: LD_VAR 0 14
99996: PUSH
99997: LD_INT 1
99999: ARRAY
100000: PPUSH
100001: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
100005: LD_VAR 0 4
100009: PUSH
100010: LD_VAR 0 7
100014: ARRAY
100015: PPUSH
100016: CALL_OW 264
100020: PUSH
100021: LD_INT 49
100023: EQUAL
100024: IFFALSE 100145
// begin if not HasTask ( group [ i ] ) then
100026: LD_VAR 0 4
100030: PUSH
100031: LD_VAR 0 7
100035: ARRAY
100036: PPUSH
100037: CALL_OW 314
100041: NOT
100042: IFFALSE 100145
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
100044: LD_ADDR_VAR 0 9
100048: PUSH
100049: LD_INT 81
100051: PUSH
100052: LD_VAR 0 4
100056: PUSH
100057: LD_VAR 0 7
100061: ARRAY
100062: PPUSH
100063: CALL_OW 255
100067: PUSH
100068: EMPTY
100069: LIST
100070: LIST
100071: PPUSH
100072: CALL_OW 69
100076: PPUSH
100077: LD_VAR 0 4
100081: PUSH
100082: LD_VAR 0 7
100086: ARRAY
100087: PPUSH
100088: CALL_OW 74
100092: ST_TO_ADDR
// if k then
100093: LD_VAR 0 9
100097: IFFALSE 100145
// if GetDistUnits ( group [ i ] , k ) > 10 then
100099: LD_VAR 0 4
100103: PUSH
100104: LD_VAR 0 7
100108: ARRAY
100109: PPUSH
100110: LD_VAR 0 9
100114: PPUSH
100115: CALL_OW 296
100119: PUSH
100120: LD_INT 10
100122: GREATER
100123: IFFALSE 100145
// ComMoveUnit ( group [ i ] , k ) ;
100125: LD_VAR 0 4
100129: PUSH
100130: LD_VAR 0 7
100134: ARRAY
100135: PPUSH
100136: LD_VAR 0 9
100140: PPUSH
100141: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100145: LD_VAR 0 4
100149: PUSH
100150: LD_VAR 0 7
100154: ARRAY
100155: PPUSH
100156: CALL_OW 256
100160: PUSH
100161: LD_INT 250
100163: LESS
100164: PUSH
100165: LD_VAR 0 4
100169: PUSH
100170: LD_VAR 0 7
100174: ARRAY
100175: PUSH
100176: LD_INT 21
100178: PUSH
100179: LD_INT 2
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: PUSH
100186: LD_INT 23
100188: PUSH
100189: LD_INT 2
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PUSH
100196: EMPTY
100197: LIST
100198: LIST
100199: PPUSH
100200: CALL_OW 69
100204: IN
100205: AND
100206: IFFALSE 100331
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
100208: LD_ADDR_VAR 0 9
100212: PUSH
100213: LD_OWVAR 3
100217: PUSH
100218: LD_VAR 0 4
100222: PUSH
100223: LD_VAR 0 7
100227: ARRAY
100228: DIFF
100229: PPUSH
100230: LD_VAR 0 4
100234: PUSH
100235: LD_VAR 0 7
100239: ARRAY
100240: PPUSH
100241: CALL_OW 74
100245: ST_TO_ADDR
// if not k then
100246: LD_VAR 0 9
100250: NOT
100251: IFFALSE 100255
// continue ;
100253: GO 96696
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
100255: LD_VAR 0 9
100259: PUSH
100260: LD_INT 81
100262: PUSH
100263: LD_VAR 0 4
100267: PUSH
100268: LD_VAR 0 7
100272: ARRAY
100273: PPUSH
100274: CALL_OW 255
100278: PUSH
100279: EMPTY
100280: LIST
100281: LIST
100282: PPUSH
100283: CALL_OW 69
100287: IN
100288: PUSH
100289: LD_VAR 0 9
100293: PPUSH
100294: LD_VAR 0 4
100298: PUSH
100299: LD_VAR 0 7
100303: ARRAY
100304: PPUSH
100305: CALL_OW 296
100309: PUSH
100310: LD_INT 5
100312: LESS
100313: AND
100314: IFFALSE 100331
// ComAutodestruct ( group [ i ] ) ;
100316: LD_VAR 0 4
100320: PUSH
100321: LD_VAR 0 7
100325: ARRAY
100326: PPUSH
100327: CALL 94811 0 1
// end ; if f_attack_depot then
100331: LD_VAR 0 25
100335: IFFALSE 100447
// begin k := 6 ;
100337: LD_ADDR_VAR 0 9
100341: PUSH
100342: LD_INT 6
100344: ST_TO_ADDR
// if tmp < k then
100345: LD_VAR 0 14
100349: PUSH
100350: LD_VAR 0 9
100354: LESS
100355: IFFALSE 100367
// k := tmp ;
100357: LD_ADDR_VAR 0 9
100361: PUSH
100362: LD_VAR 0 14
100366: ST_TO_ADDR
// for j = 1 to k do
100367: LD_ADDR_VAR 0 8
100371: PUSH
100372: DOUBLE
100373: LD_INT 1
100375: DEC
100376: ST_TO_ADDR
100377: LD_VAR 0 9
100381: PUSH
100382: FOR_TO
100383: IFFALSE 100445
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
100385: LD_VAR 0 8
100389: PPUSH
100390: CALL_OW 266
100394: PUSH
100395: LD_INT 0
100397: PUSH
100398: LD_INT 1
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: IN
100405: IFFALSE 100443
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100407: LD_VAR 0 4
100411: PUSH
100412: LD_VAR 0 7
100416: ARRAY
100417: PPUSH
100418: LD_VAR 0 14
100422: PUSH
100423: LD_VAR 0 8
100427: ARRAY
100428: PPUSH
100429: CALL_OW 115
// attacking := true ;
100433: LD_ADDR_VAR 0 29
100437: PUSH
100438: LD_INT 1
100440: ST_TO_ADDR
// break ;
100441: GO 100445
// end ;
100443: GO 100382
100445: POP
100446: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
100447: LD_VAR 0 4
100451: PUSH
100452: LD_VAR 0 7
100456: ARRAY
100457: PPUSH
100458: CALL_OW 302
100462: PUSH
100463: LD_VAR 0 29
100467: NOT
100468: AND
100469: IFFALSE 100791
// begin if GetTag ( group [ i ] ) = 71 then
100471: LD_VAR 0 4
100475: PUSH
100476: LD_VAR 0 7
100480: ARRAY
100481: PPUSH
100482: CALL_OW 110
100486: PUSH
100487: LD_INT 71
100489: EQUAL
100490: IFFALSE 100531
// begin if HasTask ( group [ i ] ) then
100492: LD_VAR 0 4
100496: PUSH
100497: LD_VAR 0 7
100501: ARRAY
100502: PPUSH
100503: CALL_OW 314
100507: IFFALSE 100513
// continue else
100509: GO 96696
100511: GO 100531
// SetTag ( group [ i ] , 0 ) ;
100513: LD_VAR 0 4
100517: PUSH
100518: LD_VAR 0 7
100522: ARRAY
100523: PPUSH
100524: LD_INT 0
100526: PPUSH
100527: CALL_OW 109
// end ; k := 8 ;
100531: LD_ADDR_VAR 0 9
100535: PUSH
100536: LD_INT 8
100538: ST_TO_ADDR
// x := 0 ;
100539: LD_ADDR_VAR 0 10
100543: PUSH
100544: LD_INT 0
100546: ST_TO_ADDR
// if tmp < k then
100547: LD_VAR 0 14
100551: PUSH
100552: LD_VAR 0 9
100556: LESS
100557: IFFALSE 100569
// k := tmp ;
100559: LD_ADDR_VAR 0 9
100563: PUSH
100564: LD_VAR 0 14
100568: ST_TO_ADDR
// for j = 1 to k do
100569: LD_ADDR_VAR 0 8
100573: PUSH
100574: DOUBLE
100575: LD_INT 1
100577: DEC
100578: ST_TO_ADDR
100579: LD_VAR 0 9
100583: PUSH
100584: FOR_TO
100585: IFFALSE 100683
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
100587: LD_VAR 0 14
100591: PUSH
100592: LD_VAR 0 8
100596: ARRAY
100597: PPUSH
100598: CALL_OW 247
100602: PUSH
100603: LD_INT 1
100605: EQUAL
100606: PUSH
100607: LD_VAR 0 14
100611: PUSH
100612: LD_VAR 0 8
100616: ARRAY
100617: PPUSH
100618: CALL_OW 256
100622: PUSH
100623: LD_INT 250
100625: LESS
100626: PUSH
100627: LD_VAR 0 20
100631: AND
100632: PUSH
100633: LD_VAR 0 20
100637: NOT
100638: PUSH
100639: LD_VAR 0 14
100643: PUSH
100644: LD_VAR 0 8
100648: ARRAY
100649: PPUSH
100650: CALL_OW 256
100654: PUSH
100655: LD_INT 250
100657: GREATEREQUAL
100658: AND
100659: OR
100660: AND
100661: IFFALSE 100681
// begin x := tmp [ j ] ;
100663: LD_ADDR_VAR 0 10
100667: PUSH
100668: LD_VAR 0 14
100672: PUSH
100673: LD_VAR 0 8
100677: ARRAY
100678: ST_TO_ADDR
// break ;
100679: GO 100683
// end ;
100681: GO 100584
100683: POP
100684: POP
// if x then
100685: LD_VAR 0 10
100689: IFFALSE 100713
// ComAttackUnit ( group [ i ] , x ) else
100691: LD_VAR 0 4
100695: PUSH
100696: LD_VAR 0 7
100700: ARRAY
100701: PPUSH
100702: LD_VAR 0 10
100706: PPUSH
100707: CALL_OW 115
100711: GO 100737
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100713: LD_VAR 0 4
100717: PUSH
100718: LD_VAR 0 7
100722: ARRAY
100723: PPUSH
100724: LD_VAR 0 14
100728: PUSH
100729: LD_INT 1
100731: ARRAY
100732: PPUSH
100733: CALL_OW 115
// if not HasTask ( group [ i ] ) then
100737: LD_VAR 0 4
100741: PUSH
100742: LD_VAR 0 7
100746: ARRAY
100747: PPUSH
100748: CALL_OW 314
100752: NOT
100753: IFFALSE 100791
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
100755: LD_VAR 0 4
100759: PUSH
100760: LD_VAR 0 7
100764: ARRAY
100765: PPUSH
100766: LD_VAR 0 14
100770: PPUSH
100771: LD_VAR 0 4
100775: PUSH
100776: LD_VAR 0 7
100780: ARRAY
100781: PPUSH
100782: CALL_OW 74
100786: PPUSH
100787: CALL_OW 115
// end ; end ; end ;
100791: GO 96696
100793: POP
100794: POP
// wait ( 0 0$1 ) ;
100795: LD_INT 35
100797: PPUSH
100798: CALL_OW 67
// until group = [ ] ;
100802: LD_VAR 0 4
100806: PUSH
100807: EMPTY
100808: EQUAL
100809: IFFALSE 96681
// end ;
100811: LD_VAR 0 2
100815: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100816: LD_INT 0
100818: PPUSH
100819: PPUSH
100820: PPUSH
100821: PPUSH
// if not base_units then
100822: LD_VAR 0 1
100826: NOT
100827: IFFALSE 100831
// exit ;
100829: GO 100918
// result := false ;
100831: LD_ADDR_VAR 0 2
100835: PUSH
100836: LD_INT 0
100838: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100839: LD_ADDR_VAR 0 5
100843: PUSH
100844: LD_VAR 0 1
100848: PPUSH
100849: LD_INT 21
100851: PUSH
100852: LD_INT 3
100854: PUSH
100855: EMPTY
100856: LIST
100857: LIST
100858: PPUSH
100859: CALL_OW 72
100863: ST_TO_ADDR
// if not tmp then
100864: LD_VAR 0 5
100868: NOT
100869: IFFALSE 100873
// exit ;
100871: GO 100918
// for i in tmp do
100873: LD_ADDR_VAR 0 3
100877: PUSH
100878: LD_VAR 0 5
100882: PUSH
100883: FOR_IN
100884: IFFALSE 100916
// begin result := EnemyInRange ( i , 22 ) ;
100886: LD_ADDR_VAR 0 2
100890: PUSH
100891: LD_VAR 0 3
100895: PPUSH
100896: LD_INT 22
100898: PPUSH
100899: CALL 94494 0 2
100903: ST_TO_ADDR
// if result then
100904: LD_VAR 0 2
100908: IFFALSE 100914
// exit ;
100910: POP
100911: POP
100912: GO 100918
// end ;
100914: GO 100883
100916: POP
100917: POP
// end ;
100918: LD_VAR 0 2
100922: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
100923: LD_INT 0
100925: PPUSH
100926: PPUSH
// if not units then
100927: LD_VAR 0 1
100931: NOT
100932: IFFALSE 100936
// exit ;
100934: GO 101006
// result := [ ] ;
100936: LD_ADDR_VAR 0 3
100940: PUSH
100941: EMPTY
100942: ST_TO_ADDR
// for i in units do
100943: LD_ADDR_VAR 0 4
100947: PUSH
100948: LD_VAR 0 1
100952: PUSH
100953: FOR_IN
100954: IFFALSE 101004
// if GetTag ( i ) = tag then
100956: LD_VAR 0 4
100960: PPUSH
100961: CALL_OW 110
100965: PUSH
100966: LD_VAR 0 2
100970: EQUAL
100971: IFFALSE 101002
// result := Insert ( result , result + 1 , i ) ;
100973: LD_ADDR_VAR 0 3
100977: PUSH
100978: LD_VAR 0 3
100982: PPUSH
100983: LD_VAR 0 3
100987: PUSH
100988: LD_INT 1
100990: PLUS
100991: PPUSH
100992: LD_VAR 0 4
100996: PPUSH
100997: CALL_OW 2
101001: ST_TO_ADDR
101002: GO 100953
101004: POP
101005: POP
// end ;
101006: LD_VAR 0 3
101010: RET
// export function IsDriver ( un ) ; begin
101011: LD_INT 0
101013: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
101014: LD_ADDR_VAR 0 2
101018: PUSH
101019: LD_VAR 0 1
101023: PUSH
101024: LD_INT 55
101026: PUSH
101027: EMPTY
101028: LIST
101029: PPUSH
101030: CALL_OW 69
101034: IN
101035: ST_TO_ADDR
// end ;
101036: LD_VAR 0 2
101040: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
101041: LD_INT 0
101043: PPUSH
101044: PPUSH
// list := [ ] ;
101045: LD_ADDR_VAR 0 5
101049: PUSH
101050: EMPTY
101051: ST_TO_ADDR
// case d of 0 :
101052: LD_VAR 0 3
101056: PUSH
101057: LD_INT 0
101059: DOUBLE
101060: EQUAL
101061: IFTRUE 101065
101063: GO 101198
101065: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
101066: LD_ADDR_VAR 0 5
101070: PUSH
101071: LD_VAR 0 1
101075: PUSH
101076: LD_INT 4
101078: MINUS
101079: PUSH
101080: LD_VAR 0 2
101084: PUSH
101085: LD_INT 4
101087: MINUS
101088: PUSH
101089: LD_INT 2
101091: PUSH
101092: EMPTY
101093: LIST
101094: LIST
101095: LIST
101096: PUSH
101097: LD_VAR 0 1
101101: PUSH
101102: LD_INT 3
101104: MINUS
101105: PUSH
101106: LD_VAR 0 2
101110: PUSH
101111: LD_INT 1
101113: PUSH
101114: EMPTY
101115: LIST
101116: LIST
101117: LIST
101118: PUSH
101119: LD_VAR 0 1
101123: PUSH
101124: LD_INT 4
101126: PLUS
101127: PUSH
101128: LD_VAR 0 2
101132: PUSH
101133: LD_INT 4
101135: PUSH
101136: EMPTY
101137: LIST
101138: LIST
101139: LIST
101140: PUSH
101141: LD_VAR 0 1
101145: PUSH
101146: LD_INT 3
101148: PLUS
101149: PUSH
101150: LD_VAR 0 2
101154: PUSH
101155: LD_INT 3
101157: PLUS
101158: PUSH
101159: LD_INT 5
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: LIST
101166: PUSH
101167: LD_VAR 0 1
101171: PUSH
101172: LD_VAR 0 2
101176: PUSH
101177: LD_INT 4
101179: PLUS
101180: PUSH
101181: LD_INT 0
101183: PUSH
101184: EMPTY
101185: LIST
101186: LIST
101187: LIST
101188: PUSH
101189: EMPTY
101190: LIST
101191: LIST
101192: LIST
101193: LIST
101194: LIST
101195: ST_TO_ADDR
// end ; 1 :
101196: GO 101896
101198: LD_INT 1
101200: DOUBLE
101201: EQUAL
101202: IFTRUE 101206
101204: GO 101339
101206: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
101207: LD_ADDR_VAR 0 5
101211: PUSH
101212: LD_VAR 0 1
101216: PUSH
101217: LD_VAR 0 2
101221: PUSH
101222: LD_INT 4
101224: MINUS
101225: PUSH
101226: LD_INT 3
101228: PUSH
101229: EMPTY
101230: LIST
101231: LIST
101232: LIST
101233: PUSH
101234: LD_VAR 0 1
101238: PUSH
101239: LD_INT 3
101241: MINUS
101242: PUSH
101243: LD_VAR 0 2
101247: PUSH
101248: LD_INT 3
101250: MINUS
101251: PUSH
101252: LD_INT 2
101254: PUSH
101255: EMPTY
101256: LIST
101257: LIST
101258: LIST
101259: PUSH
101260: LD_VAR 0 1
101264: PUSH
101265: LD_INT 4
101267: MINUS
101268: PUSH
101269: LD_VAR 0 2
101273: PUSH
101274: LD_INT 1
101276: PUSH
101277: EMPTY
101278: LIST
101279: LIST
101280: LIST
101281: PUSH
101282: LD_VAR 0 1
101286: PUSH
101287: LD_VAR 0 2
101291: PUSH
101292: LD_INT 3
101294: PLUS
101295: PUSH
101296: LD_INT 0
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: LIST
101303: PUSH
101304: LD_VAR 0 1
101308: PUSH
101309: LD_INT 4
101311: PLUS
101312: PUSH
101313: LD_VAR 0 2
101317: PUSH
101318: LD_INT 4
101320: PLUS
101321: PUSH
101322: LD_INT 5
101324: PUSH
101325: EMPTY
101326: LIST
101327: LIST
101328: LIST
101329: PUSH
101330: EMPTY
101331: LIST
101332: LIST
101333: LIST
101334: LIST
101335: LIST
101336: ST_TO_ADDR
// end ; 2 :
101337: GO 101896
101339: LD_INT 2
101341: DOUBLE
101342: EQUAL
101343: IFTRUE 101347
101345: GO 101476
101347: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
101348: LD_ADDR_VAR 0 5
101352: PUSH
101353: LD_VAR 0 1
101357: PUSH
101358: LD_VAR 0 2
101362: PUSH
101363: LD_INT 3
101365: MINUS
101366: PUSH
101367: LD_INT 3
101369: PUSH
101370: EMPTY
101371: LIST
101372: LIST
101373: LIST
101374: PUSH
101375: LD_VAR 0 1
101379: PUSH
101380: LD_INT 4
101382: PLUS
101383: PUSH
101384: LD_VAR 0 2
101388: PUSH
101389: LD_INT 4
101391: PUSH
101392: EMPTY
101393: LIST
101394: LIST
101395: LIST
101396: PUSH
101397: LD_VAR 0 1
101401: PUSH
101402: LD_VAR 0 2
101406: PUSH
101407: LD_INT 4
101409: PLUS
101410: PUSH
101411: LD_INT 0
101413: PUSH
101414: EMPTY
101415: LIST
101416: LIST
101417: LIST
101418: PUSH
101419: LD_VAR 0 1
101423: PUSH
101424: LD_INT 3
101426: MINUS
101427: PUSH
101428: LD_VAR 0 2
101432: PUSH
101433: LD_INT 1
101435: PUSH
101436: EMPTY
101437: LIST
101438: LIST
101439: LIST
101440: PUSH
101441: LD_VAR 0 1
101445: PUSH
101446: LD_INT 4
101448: MINUS
101449: PUSH
101450: LD_VAR 0 2
101454: PUSH
101455: LD_INT 4
101457: MINUS
101458: PUSH
101459: LD_INT 2
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: LIST
101466: PUSH
101467: EMPTY
101468: LIST
101469: LIST
101470: LIST
101471: LIST
101472: LIST
101473: ST_TO_ADDR
// end ; 3 :
101474: GO 101896
101476: LD_INT 3
101478: DOUBLE
101479: EQUAL
101480: IFTRUE 101484
101482: GO 101617
101484: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
101485: LD_ADDR_VAR 0 5
101489: PUSH
101490: LD_VAR 0 1
101494: PUSH
101495: LD_INT 3
101497: PLUS
101498: PUSH
101499: LD_VAR 0 2
101503: PUSH
101504: LD_INT 4
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: LIST
101511: PUSH
101512: LD_VAR 0 1
101516: PUSH
101517: LD_INT 4
101519: PLUS
101520: PUSH
101521: LD_VAR 0 2
101525: PUSH
101526: LD_INT 4
101528: PLUS
101529: PUSH
101530: LD_INT 5
101532: PUSH
101533: EMPTY
101534: LIST
101535: LIST
101536: LIST
101537: PUSH
101538: LD_VAR 0 1
101542: PUSH
101543: LD_INT 4
101545: MINUS
101546: PUSH
101547: LD_VAR 0 2
101551: PUSH
101552: LD_INT 1
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: LIST
101559: PUSH
101560: LD_VAR 0 1
101564: PUSH
101565: LD_VAR 0 2
101569: PUSH
101570: LD_INT 4
101572: MINUS
101573: PUSH
101574: LD_INT 3
101576: PUSH
101577: EMPTY
101578: LIST
101579: LIST
101580: LIST
101581: PUSH
101582: LD_VAR 0 1
101586: PUSH
101587: LD_INT 3
101589: MINUS
101590: PUSH
101591: LD_VAR 0 2
101595: PUSH
101596: LD_INT 3
101598: MINUS
101599: PUSH
101600: LD_INT 2
101602: PUSH
101603: EMPTY
101604: LIST
101605: LIST
101606: LIST
101607: PUSH
101608: EMPTY
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: LIST
101614: ST_TO_ADDR
// end ; 4 :
101615: GO 101896
101617: LD_INT 4
101619: DOUBLE
101620: EQUAL
101621: IFTRUE 101625
101623: GO 101758
101625: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
101626: LD_ADDR_VAR 0 5
101630: PUSH
101631: LD_VAR 0 1
101635: PUSH
101636: LD_VAR 0 2
101640: PUSH
101641: LD_INT 4
101643: PLUS
101644: PUSH
101645: LD_INT 0
101647: PUSH
101648: EMPTY
101649: LIST
101650: LIST
101651: LIST
101652: PUSH
101653: LD_VAR 0 1
101657: PUSH
101658: LD_INT 3
101660: PLUS
101661: PUSH
101662: LD_VAR 0 2
101666: PUSH
101667: LD_INT 3
101669: PLUS
101670: PUSH
101671: LD_INT 5
101673: PUSH
101674: EMPTY
101675: LIST
101676: LIST
101677: LIST
101678: PUSH
101679: LD_VAR 0 1
101683: PUSH
101684: LD_INT 4
101686: PLUS
101687: PUSH
101688: LD_VAR 0 2
101692: PUSH
101693: LD_INT 4
101695: PUSH
101696: EMPTY
101697: LIST
101698: LIST
101699: LIST
101700: PUSH
101701: LD_VAR 0 1
101705: PUSH
101706: LD_VAR 0 2
101710: PUSH
101711: LD_INT 3
101713: MINUS
101714: PUSH
101715: LD_INT 3
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: LIST
101722: PUSH
101723: LD_VAR 0 1
101727: PUSH
101728: LD_INT 4
101730: MINUS
101731: PUSH
101732: LD_VAR 0 2
101736: PUSH
101737: LD_INT 4
101739: MINUS
101740: PUSH
101741: LD_INT 2
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: LIST
101748: PUSH
101749: EMPTY
101750: LIST
101751: LIST
101752: LIST
101753: LIST
101754: LIST
101755: ST_TO_ADDR
// end ; 5 :
101756: GO 101896
101758: LD_INT 5
101760: DOUBLE
101761: EQUAL
101762: IFTRUE 101766
101764: GO 101895
101766: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
101767: LD_ADDR_VAR 0 5
101771: PUSH
101772: LD_VAR 0 1
101776: PUSH
101777: LD_INT 4
101779: MINUS
101780: PUSH
101781: LD_VAR 0 2
101785: PUSH
101786: LD_INT 1
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: LIST
101793: PUSH
101794: LD_VAR 0 1
101798: PUSH
101799: LD_VAR 0 2
101803: PUSH
101804: LD_INT 4
101806: MINUS
101807: PUSH
101808: LD_INT 3
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: LIST
101815: PUSH
101816: LD_VAR 0 1
101820: PUSH
101821: LD_INT 4
101823: PLUS
101824: PUSH
101825: LD_VAR 0 2
101829: PUSH
101830: LD_INT 4
101832: PLUS
101833: PUSH
101834: LD_INT 5
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: LIST
101841: PUSH
101842: LD_VAR 0 1
101846: PUSH
101847: LD_INT 3
101849: PLUS
101850: PUSH
101851: LD_VAR 0 2
101855: PUSH
101856: LD_INT 4
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: LIST
101863: PUSH
101864: LD_VAR 0 1
101868: PUSH
101869: LD_VAR 0 2
101873: PUSH
101874: LD_INT 3
101876: PLUS
101877: PUSH
101878: LD_INT 0
101880: PUSH
101881: EMPTY
101882: LIST
101883: LIST
101884: LIST
101885: PUSH
101886: EMPTY
101887: LIST
101888: LIST
101889: LIST
101890: LIST
101891: LIST
101892: ST_TO_ADDR
// end ; end ;
101893: GO 101896
101895: POP
// result := list ;
101896: LD_ADDR_VAR 0 4
101900: PUSH
101901: LD_VAR 0 5
101905: ST_TO_ADDR
// end ;
101906: LD_VAR 0 4
101910: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101911: LD_INT 0
101913: PPUSH
101914: PPUSH
101915: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101916: LD_VAR 0 1
101920: NOT
101921: PUSH
101922: LD_VAR 0 2
101926: PUSH
101927: LD_INT 1
101929: PUSH
101930: LD_INT 2
101932: PUSH
101933: LD_INT 3
101935: PUSH
101936: LD_INT 4
101938: PUSH
101939: EMPTY
101940: LIST
101941: LIST
101942: LIST
101943: LIST
101944: IN
101945: NOT
101946: OR
101947: IFFALSE 101951
// exit ;
101949: GO 102043
// tmp := [ ] ;
101951: LD_ADDR_VAR 0 5
101955: PUSH
101956: EMPTY
101957: ST_TO_ADDR
// for i in units do
101958: LD_ADDR_VAR 0 4
101962: PUSH
101963: LD_VAR 0 1
101967: PUSH
101968: FOR_IN
101969: IFFALSE 102012
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101971: LD_ADDR_VAR 0 5
101975: PUSH
101976: LD_VAR 0 5
101980: PPUSH
101981: LD_VAR 0 5
101985: PUSH
101986: LD_INT 1
101988: PLUS
101989: PPUSH
101990: LD_VAR 0 4
101994: PPUSH
101995: LD_VAR 0 2
101999: PPUSH
102000: CALL_OW 259
102004: PPUSH
102005: CALL_OW 2
102009: ST_TO_ADDR
102010: GO 101968
102012: POP
102013: POP
// if not tmp then
102014: LD_VAR 0 5
102018: NOT
102019: IFFALSE 102023
// exit ;
102021: GO 102043
// result := SortListByListDesc ( units , tmp ) ;
102023: LD_ADDR_VAR 0 3
102027: PUSH
102028: LD_VAR 0 1
102032: PPUSH
102033: LD_VAR 0 5
102037: PPUSH
102038: CALL_OW 77
102042: ST_TO_ADDR
// end ;
102043: LD_VAR 0 3
102047: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
102048: LD_INT 0
102050: PPUSH
102051: PPUSH
102052: PPUSH
// x := GetX ( building ) ;
102053: LD_ADDR_VAR 0 4
102057: PUSH
102058: LD_VAR 0 2
102062: PPUSH
102063: CALL_OW 250
102067: ST_TO_ADDR
// y := GetY ( building ) ;
102068: LD_ADDR_VAR 0 5
102072: PUSH
102073: LD_VAR 0 2
102077: PPUSH
102078: CALL_OW 251
102082: ST_TO_ADDR
// if GetTaskList ( unit ) then
102083: LD_VAR 0 1
102087: PPUSH
102088: CALL_OW 437
102092: IFFALSE 102187
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102094: LD_STRING e
102096: PUSH
102097: LD_VAR 0 1
102101: PPUSH
102102: CALL_OW 437
102106: PUSH
102107: LD_INT 1
102109: ARRAY
102110: PUSH
102111: LD_INT 1
102113: ARRAY
102114: EQUAL
102115: PUSH
102116: LD_VAR 0 4
102120: PUSH
102121: LD_VAR 0 1
102125: PPUSH
102126: CALL_OW 437
102130: PUSH
102131: LD_INT 1
102133: ARRAY
102134: PUSH
102135: LD_INT 2
102137: ARRAY
102138: EQUAL
102139: AND
102140: PUSH
102141: LD_VAR 0 5
102145: PUSH
102146: LD_VAR 0 1
102150: PPUSH
102151: CALL_OW 437
102155: PUSH
102156: LD_INT 1
102158: ARRAY
102159: PUSH
102160: LD_INT 3
102162: ARRAY
102163: EQUAL
102164: AND
102165: IFFALSE 102177
// result := true else
102167: LD_ADDR_VAR 0 3
102171: PUSH
102172: LD_INT 1
102174: ST_TO_ADDR
102175: GO 102185
// result := false ;
102177: LD_ADDR_VAR 0 3
102181: PUSH
102182: LD_INT 0
102184: ST_TO_ADDR
// end else
102185: GO 102195
// result := false ;
102187: LD_ADDR_VAR 0 3
102191: PUSH
102192: LD_INT 0
102194: ST_TO_ADDR
// end ;
102195: LD_VAR 0 3
102199: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
102200: LD_INT 0
102202: PPUSH
102203: PPUSH
102204: PPUSH
102205: PPUSH
// if not unit or not area then
102206: LD_VAR 0 1
102210: NOT
102211: PUSH
102212: LD_VAR 0 2
102216: NOT
102217: OR
102218: IFFALSE 102222
// exit ;
102220: GO 102387
// tmp := AreaToList ( area , i ) ;
102222: LD_ADDR_VAR 0 6
102226: PUSH
102227: LD_VAR 0 2
102231: PPUSH
102232: LD_VAR 0 5
102236: PPUSH
102237: CALL_OW 517
102241: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
102242: LD_ADDR_VAR 0 5
102246: PUSH
102247: DOUBLE
102248: LD_INT 1
102250: DEC
102251: ST_TO_ADDR
102252: LD_VAR 0 6
102256: PUSH
102257: LD_INT 1
102259: ARRAY
102260: PUSH
102261: FOR_TO
102262: IFFALSE 102377
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
102264: LD_ADDR_VAR 0 7
102268: PUSH
102269: LD_VAR 0 6
102273: PUSH
102274: LD_INT 1
102276: ARRAY
102277: PUSH
102278: LD_VAR 0 5
102282: ARRAY
102283: PUSH
102284: LD_VAR 0 6
102288: PUSH
102289: LD_INT 2
102291: ARRAY
102292: PUSH
102293: LD_VAR 0 5
102297: ARRAY
102298: PUSH
102299: EMPTY
102300: LIST
102301: LIST
102302: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
102303: LD_VAR 0 7
102307: PUSH
102308: LD_INT 1
102310: ARRAY
102311: PPUSH
102312: LD_VAR 0 7
102316: PUSH
102317: LD_INT 2
102319: ARRAY
102320: PPUSH
102321: CALL_OW 428
102325: PUSH
102326: LD_INT 0
102328: EQUAL
102329: IFFALSE 102375
// begin result := true ;
102331: LD_ADDR_VAR 0 4
102335: PUSH
102336: LD_INT 1
102338: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
102339: LD_VAR 0 1
102343: PPUSH
102344: LD_VAR 0 7
102348: PUSH
102349: LD_INT 1
102351: ARRAY
102352: PPUSH
102353: LD_VAR 0 7
102357: PUSH
102358: LD_INT 2
102360: ARRAY
102361: PPUSH
102362: LD_VAR 0 3
102366: PPUSH
102367: CALL_OW 48
// exit ;
102371: POP
102372: POP
102373: GO 102387
// end ; end ;
102375: GO 102261
102377: POP
102378: POP
// result := false ;
102379: LD_ADDR_VAR 0 4
102383: PUSH
102384: LD_INT 0
102386: ST_TO_ADDR
// end ;
102387: LD_VAR 0 4
102391: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
102392: LD_INT 0
102394: PPUSH
102395: PPUSH
102396: PPUSH
// if not side or side > 8 then
102397: LD_VAR 0 1
102401: NOT
102402: PUSH
102403: LD_VAR 0 1
102407: PUSH
102408: LD_INT 8
102410: GREATER
102411: OR
102412: IFFALSE 102416
// exit ;
102414: GO 102603
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
102416: LD_ADDR_VAR 0 4
102420: PUSH
102421: LD_INT 22
102423: PUSH
102424: LD_VAR 0 1
102428: PUSH
102429: EMPTY
102430: LIST
102431: LIST
102432: PUSH
102433: LD_INT 21
102435: PUSH
102436: LD_INT 3
102438: PUSH
102439: EMPTY
102440: LIST
102441: LIST
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: PPUSH
102447: CALL_OW 69
102451: ST_TO_ADDR
// if not tmp then
102452: LD_VAR 0 4
102456: NOT
102457: IFFALSE 102461
// exit ;
102459: GO 102603
// enable_addtolog := true ;
102461: LD_ADDR_OWVAR 81
102465: PUSH
102466: LD_INT 1
102468: ST_TO_ADDR
// AddToLog ( [ ) ;
102469: LD_STRING [
102471: PPUSH
102472: CALL_OW 561
// for i in tmp do
102476: LD_ADDR_VAR 0 3
102480: PUSH
102481: LD_VAR 0 4
102485: PUSH
102486: FOR_IN
102487: IFFALSE 102594
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
102489: LD_STRING [
102491: PUSH
102492: LD_VAR 0 3
102496: PPUSH
102497: CALL_OW 266
102501: STR
102502: PUSH
102503: LD_STRING , 
102505: STR
102506: PUSH
102507: LD_VAR 0 3
102511: PPUSH
102512: CALL_OW 250
102516: STR
102517: PUSH
102518: LD_STRING , 
102520: STR
102521: PUSH
102522: LD_VAR 0 3
102526: PPUSH
102527: CALL_OW 251
102531: STR
102532: PUSH
102533: LD_STRING , 
102535: STR
102536: PUSH
102537: LD_VAR 0 3
102541: PPUSH
102542: CALL_OW 254
102546: STR
102547: PUSH
102548: LD_STRING , 
102550: STR
102551: PUSH
102552: LD_VAR 0 3
102556: PPUSH
102557: LD_INT 1
102559: PPUSH
102560: CALL_OW 268
102564: STR
102565: PUSH
102566: LD_STRING , 
102568: STR
102569: PUSH
102570: LD_VAR 0 3
102574: PPUSH
102575: LD_INT 2
102577: PPUSH
102578: CALL_OW 268
102582: STR
102583: PUSH
102584: LD_STRING ],
102586: STR
102587: PPUSH
102588: CALL_OW 561
// end ;
102592: GO 102486
102594: POP
102595: POP
// AddToLog ( ]; ) ;
102596: LD_STRING ];
102598: PPUSH
102599: CALL_OW 561
// end ;
102603: LD_VAR 0 2
102607: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
102608: LD_INT 0
102610: PPUSH
102611: PPUSH
102612: PPUSH
102613: PPUSH
102614: PPUSH
// if not area or not rate or not max then
102615: LD_VAR 0 1
102619: NOT
102620: PUSH
102621: LD_VAR 0 2
102625: NOT
102626: OR
102627: PUSH
102628: LD_VAR 0 4
102632: NOT
102633: OR
102634: IFFALSE 102638
// exit ;
102636: GO 102830
// while 1 do
102638: LD_INT 1
102640: IFFALSE 102830
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
102642: LD_ADDR_VAR 0 9
102646: PUSH
102647: LD_VAR 0 1
102651: PPUSH
102652: LD_INT 1
102654: PPUSH
102655: CALL_OW 287
102659: PUSH
102660: LD_INT 10
102662: MUL
102663: ST_TO_ADDR
// r := rate / 10 ;
102664: LD_ADDR_VAR 0 7
102668: PUSH
102669: LD_VAR 0 2
102673: PUSH
102674: LD_INT 10
102676: DIVREAL
102677: ST_TO_ADDR
// time := 1 1$00 ;
102678: LD_ADDR_VAR 0 8
102682: PUSH
102683: LD_INT 2100
102685: ST_TO_ADDR
// if amount < min then
102686: LD_VAR 0 9
102690: PUSH
102691: LD_VAR 0 3
102695: LESS
102696: IFFALSE 102714
// r := r * 2 else
102698: LD_ADDR_VAR 0 7
102702: PUSH
102703: LD_VAR 0 7
102707: PUSH
102708: LD_INT 2
102710: MUL
102711: ST_TO_ADDR
102712: GO 102740
// if amount > max then
102714: LD_VAR 0 9
102718: PUSH
102719: LD_VAR 0 4
102723: GREATER
102724: IFFALSE 102740
// r := r / 2 ;
102726: LD_ADDR_VAR 0 7
102730: PUSH
102731: LD_VAR 0 7
102735: PUSH
102736: LD_INT 2
102738: DIVREAL
102739: ST_TO_ADDR
// time := time / r ;
102740: LD_ADDR_VAR 0 8
102744: PUSH
102745: LD_VAR 0 8
102749: PUSH
102750: LD_VAR 0 7
102754: DIVREAL
102755: ST_TO_ADDR
// if time < 0 then
102756: LD_VAR 0 8
102760: PUSH
102761: LD_INT 0
102763: LESS
102764: IFFALSE 102781
// time := time * - 1 ;
102766: LD_ADDR_VAR 0 8
102770: PUSH
102771: LD_VAR 0 8
102775: PUSH
102776: LD_INT 1
102778: NEG
102779: MUL
102780: ST_TO_ADDR
// wait ( time ) ;
102781: LD_VAR 0 8
102785: PPUSH
102786: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
102790: LD_INT 35
102792: PPUSH
102793: LD_INT 875
102795: PPUSH
102796: CALL_OW 12
102800: PPUSH
102801: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102805: LD_INT 1
102807: PPUSH
102808: LD_INT 5
102810: PPUSH
102811: CALL_OW 12
102815: PPUSH
102816: LD_VAR 0 1
102820: PPUSH
102821: LD_INT 1
102823: PPUSH
102824: CALL_OW 55
// end ;
102828: GO 102638
// end ;
102830: LD_VAR 0 5
102834: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102835: LD_INT 0
102837: PPUSH
102838: PPUSH
102839: PPUSH
102840: PPUSH
102841: PPUSH
102842: PPUSH
102843: PPUSH
102844: PPUSH
// if not turrets or not factories then
102845: LD_VAR 0 1
102849: NOT
102850: PUSH
102851: LD_VAR 0 2
102855: NOT
102856: OR
102857: IFFALSE 102861
// exit ;
102859: GO 103168
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102861: LD_ADDR_VAR 0 10
102865: PUSH
102866: LD_INT 5
102868: PUSH
102869: LD_INT 6
102871: PUSH
102872: EMPTY
102873: LIST
102874: LIST
102875: PUSH
102876: LD_INT 2
102878: PUSH
102879: LD_INT 4
102881: PUSH
102882: EMPTY
102883: LIST
102884: LIST
102885: PUSH
102886: LD_INT 3
102888: PUSH
102889: LD_INT 5
102891: PUSH
102892: EMPTY
102893: LIST
102894: LIST
102895: PUSH
102896: EMPTY
102897: LIST
102898: LIST
102899: LIST
102900: PUSH
102901: LD_INT 24
102903: PUSH
102904: LD_INT 25
102906: PUSH
102907: EMPTY
102908: LIST
102909: LIST
102910: PUSH
102911: LD_INT 23
102913: PUSH
102914: LD_INT 27
102916: PUSH
102917: EMPTY
102918: LIST
102919: LIST
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: PUSH
102925: LD_INT 42
102927: PUSH
102928: LD_INT 43
102930: PUSH
102931: EMPTY
102932: LIST
102933: LIST
102934: PUSH
102935: LD_INT 44
102937: PUSH
102938: LD_INT 46
102940: PUSH
102941: EMPTY
102942: LIST
102943: LIST
102944: PUSH
102945: LD_INT 45
102947: PUSH
102948: LD_INT 47
102950: PUSH
102951: EMPTY
102952: LIST
102953: LIST
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: LIST
102959: PUSH
102960: EMPTY
102961: LIST
102962: LIST
102963: LIST
102964: ST_TO_ADDR
// result := [ ] ;
102965: LD_ADDR_VAR 0 3
102969: PUSH
102970: EMPTY
102971: ST_TO_ADDR
// for i in turrets do
102972: LD_ADDR_VAR 0 4
102976: PUSH
102977: LD_VAR 0 1
102981: PUSH
102982: FOR_IN
102983: IFFALSE 103166
// begin nat := GetNation ( i ) ;
102985: LD_ADDR_VAR 0 7
102989: PUSH
102990: LD_VAR 0 4
102994: PPUSH
102995: CALL_OW 248
102999: ST_TO_ADDR
// weapon := 0 ;
103000: LD_ADDR_VAR 0 8
103004: PUSH
103005: LD_INT 0
103007: ST_TO_ADDR
// if not nat then
103008: LD_VAR 0 7
103012: NOT
103013: IFFALSE 103017
// continue ;
103015: GO 102982
// for j in list [ nat ] do
103017: LD_ADDR_VAR 0 5
103021: PUSH
103022: LD_VAR 0 10
103026: PUSH
103027: LD_VAR 0 7
103031: ARRAY
103032: PUSH
103033: FOR_IN
103034: IFFALSE 103075
// if GetBWeapon ( i ) = j [ 1 ] then
103036: LD_VAR 0 4
103040: PPUSH
103041: CALL_OW 269
103045: PUSH
103046: LD_VAR 0 5
103050: PUSH
103051: LD_INT 1
103053: ARRAY
103054: EQUAL
103055: IFFALSE 103073
// begin weapon := j [ 2 ] ;
103057: LD_ADDR_VAR 0 8
103061: PUSH
103062: LD_VAR 0 5
103066: PUSH
103067: LD_INT 2
103069: ARRAY
103070: ST_TO_ADDR
// break ;
103071: GO 103075
// end ;
103073: GO 103033
103075: POP
103076: POP
// if not weapon then
103077: LD_VAR 0 8
103081: NOT
103082: IFFALSE 103086
// continue ;
103084: GO 102982
// for k in factories do
103086: LD_ADDR_VAR 0 6
103090: PUSH
103091: LD_VAR 0 2
103095: PUSH
103096: FOR_IN
103097: IFFALSE 103162
// begin weapons := AvailableWeaponList ( k ) ;
103099: LD_ADDR_VAR 0 9
103103: PUSH
103104: LD_VAR 0 6
103108: PPUSH
103109: CALL_OW 478
103113: ST_TO_ADDR
// if not weapons then
103114: LD_VAR 0 9
103118: NOT
103119: IFFALSE 103123
// continue ;
103121: GO 103096
// if weapon in weapons then
103123: LD_VAR 0 8
103127: PUSH
103128: LD_VAR 0 9
103132: IN
103133: IFFALSE 103160
// begin result := [ i , weapon ] ;
103135: LD_ADDR_VAR 0 3
103139: PUSH
103140: LD_VAR 0 4
103144: PUSH
103145: LD_VAR 0 8
103149: PUSH
103150: EMPTY
103151: LIST
103152: LIST
103153: ST_TO_ADDR
// exit ;
103154: POP
103155: POP
103156: POP
103157: POP
103158: GO 103168
// end ; end ;
103160: GO 103096
103162: POP
103163: POP
// end ;
103164: GO 102982
103166: POP
103167: POP
// end ;
103168: LD_VAR 0 3
103172: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
103173: LD_INT 0
103175: PPUSH
// if not side or side > 8 then
103176: LD_VAR 0 3
103180: NOT
103181: PUSH
103182: LD_VAR 0 3
103186: PUSH
103187: LD_INT 8
103189: GREATER
103190: OR
103191: IFFALSE 103195
// exit ;
103193: GO 103254
// if not range then
103195: LD_VAR 0 4
103199: NOT
103200: IFFALSE 103211
// range := - 12 ;
103202: LD_ADDR_VAR 0 4
103206: PUSH
103207: LD_INT 12
103209: NEG
103210: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
103211: LD_VAR 0 1
103215: PPUSH
103216: LD_VAR 0 2
103220: PPUSH
103221: LD_VAR 0 3
103225: PPUSH
103226: LD_VAR 0 4
103230: PPUSH
103231: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
103235: LD_VAR 0 1
103239: PPUSH
103240: LD_VAR 0 2
103244: PPUSH
103245: LD_VAR 0 3
103249: PPUSH
103250: CALL_OW 331
// end ;
103254: LD_VAR 0 5
103258: RET
// export function Video ( mode ) ; begin
103259: LD_INT 0
103261: PPUSH
// ingame_video = mode ;
103262: LD_ADDR_OWVAR 52
103266: PUSH
103267: LD_VAR 0 1
103271: ST_TO_ADDR
// interface_hidden = mode ;
103272: LD_ADDR_OWVAR 54
103276: PUSH
103277: LD_VAR 0 1
103281: ST_TO_ADDR
// end ;
103282: LD_VAR 0 2
103286: RET
// export function Join ( array , element ) ; begin
103287: LD_INT 0
103289: PPUSH
// result := array ^ element ;
103290: LD_ADDR_VAR 0 3
103294: PUSH
103295: LD_VAR 0 1
103299: PUSH
103300: LD_VAR 0 2
103304: ADD
103305: ST_TO_ADDR
// end ;
103306: LD_VAR 0 3
103310: RET
// export function JoinUnion ( array , element ) ; begin
103311: LD_INT 0
103313: PPUSH
// result := array union element ;
103314: LD_ADDR_VAR 0 3
103318: PUSH
103319: LD_VAR 0 1
103323: PUSH
103324: LD_VAR 0 2
103328: UNION
103329: ST_TO_ADDR
// end ;
103330: LD_VAR 0 3
103334: RET
// export function GetBehemoths ( side ) ; begin
103335: LD_INT 0
103337: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
103338: LD_ADDR_VAR 0 2
103342: PUSH
103343: LD_INT 22
103345: PUSH
103346: LD_VAR 0 1
103350: PUSH
103351: EMPTY
103352: LIST
103353: LIST
103354: PUSH
103355: LD_INT 31
103357: PUSH
103358: LD_INT 25
103360: PUSH
103361: EMPTY
103362: LIST
103363: LIST
103364: PUSH
103365: EMPTY
103366: LIST
103367: LIST
103368: PPUSH
103369: CALL_OW 69
103373: ST_TO_ADDR
// end ;
103374: LD_VAR 0 2
103378: RET
// export function Shuffle ( array ) ; var i , index ; begin
103379: LD_INT 0
103381: PPUSH
103382: PPUSH
103383: PPUSH
// result := [ ] ;
103384: LD_ADDR_VAR 0 2
103388: PUSH
103389: EMPTY
103390: ST_TO_ADDR
// if not array then
103391: LD_VAR 0 1
103395: NOT
103396: IFFALSE 103400
// exit ;
103398: GO 103499
// Randomize ;
103400: CALL_OW 10
// for i = array downto 1 do
103404: LD_ADDR_VAR 0 3
103408: PUSH
103409: DOUBLE
103410: LD_VAR 0 1
103414: INC
103415: ST_TO_ADDR
103416: LD_INT 1
103418: PUSH
103419: FOR_DOWNTO
103420: IFFALSE 103497
// begin index := rand ( 1 , array ) ;
103422: LD_ADDR_VAR 0 4
103426: PUSH
103427: LD_INT 1
103429: PPUSH
103430: LD_VAR 0 1
103434: PPUSH
103435: CALL_OW 12
103439: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
103440: LD_ADDR_VAR 0 2
103444: PUSH
103445: LD_VAR 0 2
103449: PPUSH
103450: LD_VAR 0 2
103454: PUSH
103455: LD_INT 1
103457: PLUS
103458: PPUSH
103459: LD_VAR 0 1
103463: PUSH
103464: LD_VAR 0 4
103468: ARRAY
103469: PPUSH
103470: CALL_OW 2
103474: ST_TO_ADDR
// array := Delete ( array , index ) ;
103475: LD_ADDR_VAR 0 1
103479: PUSH
103480: LD_VAR 0 1
103484: PPUSH
103485: LD_VAR 0 4
103489: PPUSH
103490: CALL_OW 3
103494: ST_TO_ADDR
// end ;
103495: GO 103419
103497: POP
103498: POP
// end ;
103499: LD_VAR 0 2
103503: RET
