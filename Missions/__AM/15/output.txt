// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 41 0 0
// InitMacro ;
   8: CALL 3531 0 0
// PrepareAlliance ;
  12: CALL 2233 0 0
// PrepareRussian ;
  16: CALL 1895 0 0
// PrepareLegion ;
  20: CALL 1318 0 0
// PreparePowell ;
  24: CALL 322 0 0
// PrepareAmerican ;
  28: CALL 292 0 0
// Action ;
  32: CALL 3148 0 0
// MC_Start ( ) ;
  36: CALL 4678 0 0
// end ;
  40: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus ; export function InitVariables ; begin
  41: LD_INT 0
  43: PPUSH
// debug := true ;
  44: LD_ADDR_EXP 1
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 14_KappaStatus_1
  59: PPUSH
  60: LD_INT 0
  62: PPUSH
  63: CALL_OW 30
  67: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
  68: LD_ADDR_EXP 3
  72: PUSH
  73: LD_STRING 06_KurtStatus_1
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: CALL_OW 30
  83: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , [ ] ) ;
  84: LD_ADDR_EXP 4
  88: PUSH
  89: LD_STRING 14_JMMVeh_1
  91: PPUSH
  92: EMPTY
  93: PPUSH
  94: CALL_OW 30
  98: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , [ ] ) ;
  99: LD_ADDR_EXP 5
 103: PUSH
 104: LD_STRING 14_JMMGirlVeh_1
 106: PPUSH
 107: EMPTY
 108: PPUSH
 109: CALL_OW 30
 113: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 3 ) ;
 114: LD_ADDR_EXP 7
 118: PUSH
 119: LD_STRING 14_JMMGirl_1
 121: PPUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 30
 129: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 130: LD_ADDR_EXP 6
 134: PUSH
 135: LD_STRING 14_JMMGirlStatus_1
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: CALL_OW 30
 145: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 146: LD_ADDR_EXP 8
 150: PUSH
 151: LD_STRING 10_KhatamStatus_1
 153: PPUSH
 154: LD_INT 0
 156: PPUSH
 157: CALL_OW 30
 161: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 9
 166: PUSH
 167: LD_STRING 13_BurlakStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 10
 182: PUSH
 183: LD_STRING 13_StevensStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// end ;
 194: LD_VAR 0 1
 198: RET
// export function CustomInitMacro ( ) ; begin
 199: LD_INT 0
 201: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea ] ;
 202: LD_ADDR_EXP 81
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 6
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea ] ;
 221: LD_ADDR_EXP 82
 225: PUSH
 226: LD_INT 1
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: LD_INT 5
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 240: LD_ADDR_EXP 86
 244: PUSH
 245: LD_EXP 86
 249: PPUSH
 250: LD_INT 3
 252: PPUSH
 253: LD_INT 22
 255: PUSH
 256: LD_INT 8
 258: PUSH
 259: EMPTY
 260: LIST
 261: LIST
 262: PUSH
 263: LD_INT 25
 265: PUSH
 266: LD_INT 15
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: PPUSH
 277: CALL_OW 69
 281: PPUSH
 282: CALL_OW 1
 286: ST_TO_ADDR
// end ; end_of_file
 287: LD_VAR 0 1
 291: RET
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie ; export function PrepareAmerican ; begin
 292: LD_INT 0
 294: PPUSH
// JMM := PrepareUnit ( JMM , ( not debug ) ,  ) ;
 295: LD_ADDR_EXP 11
 299: PUSH
 300: LD_STRING JMM
 302: PPUSH
 303: LD_EXP 1
 307: NOT
 308: PPUSH
 309: LD_STRING 
 311: PPUSH
 312: CALL 31127 0 3
 316: ST_TO_ADDR
// end ; end_of_file
 317: LD_VAR 0 1
 321: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , tmp , depot , lab , armoury , workshop ; begin
 322: LD_INT 0
 324: PPUSH
 325: PPUSH
 326: PPUSH
 327: PPUSH
 328: PPUSH
 329: PPUSH
 330: PPUSH
 331: PPUSH
// uc_side := 4 ;
 332: LD_ADDR_OWVAR 20
 336: PUSH
 337: LD_INT 4
 339: ST_TO_ADDR
// uc_nation := 1 ;
 340: LD_ADDR_OWVAR 21
 344: PUSH
 345: LD_INT 1
 347: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 348: LD_ADDR_EXP 27
 352: PUSH
 353: LD_STRING Powell
 355: PPUSH
 356: CALL_OW 25
 360: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
 361: LD_EXP 27
 365: PPUSH
 366: LD_INT 57
 368: PPUSH
 369: LD_INT 94
 371: PPUSH
 372: LD_INT 0
 374: PPUSH
 375: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
 379: LD_EXP 27
 383: PPUSH
 384: LD_INT 58
 386: PPUSH
 387: LD_INT 94
 389: PPUSH
 390: CALL_OW 118
// vip := [ ] ;
 394: LD_ADDR_EXP 28
 398: PUSH
 399: EMPTY
 400: ST_TO_ADDR
// tmp := [ ] ;
 401: LD_ADDR_VAR 0 4
 405: PUSH
 406: EMPTY
 407: ST_TO_ADDR
// if JMMGirl <> 2 then
 408: LD_EXP 7
 412: PUSH
 413: LD_INT 2
 415: NONEQUAL
 416: IFFALSE 440
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
 418: LD_ADDR_EXP 14
 422: PUSH
 423: LD_STRING Lisa
 425: PPUSH
 426: LD_EXP 1
 430: NOT
 431: PPUSH
 432: LD_STRING 13s_
 434: PPUSH
 435: CALL 31127 0 3
 439: ST_TO_ADDR
// if Lisa then
 440: LD_EXP 14
 444: IFFALSE 462
// tmp := tmp ^ Lisa ;
 446: LD_ADDR_VAR 0 4
 450: PUSH
 451: LD_VAR 0 4
 455: PUSH
 456: LD_EXP 14
 460: ADD
 461: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
 462: LD_ADDR_EXP 15
 466: PUSH
 467: LD_STRING Donaldson
 469: PPUSH
 470: LD_EXP 1
 474: NOT
 475: PPUSH
 476: LD_STRING 13s_
 478: PPUSH
 479: CALL 31127 0 3
 483: ST_TO_ADDR
// if Donaldson then
 484: LD_EXP 15
 488: IFFALSE 506
// tmp := tmp ^ Donaldson ;
 490: LD_ADDR_VAR 0 4
 494: PUSH
 495: LD_VAR 0 4
 499: PUSH
 500: LD_EXP 15
 504: ADD
 505: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
 506: LD_ADDR_EXP 16
 510: PUSH
 511: LD_STRING Bobby
 513: PPUSH
 514: LD_EXP 1
 518: NOT
 519: PPUSH
 520: LD_STRING 13s_
 522: PPUSH
 523: CALL 31127 0 3
 527: ST_TO_ADDR
// if Bobby then
 528: LD_EXP 16
 532: IFFALSE 550
// tmp := tmp ^ Bobby ;
 534: LD_ADDR_VAR 0 4
 538: PUSH
 539: LD_VAR 0 4
 543: PUSH
 544: LD_EXP 16
 548: ADD
 549: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
 550: LD_ADDR_EXP 17
 554: PUSH
 555: LD_STRING Cyrus
 557: PPUSH
 558: LD_EXP 1
 562: NOT
 563: PPUSH
 564: LD_STRING 13s_
 566: PPUSH
 567: CALL 31127 0 3
 571: ST_TO_ADDR
// if Cyrus then
 572: LD_EXP 17
 576: IFFALSE 594
// tmp := tmp ^ Cyrus ;
 578: LD_ADDR_VAR 0 4
 582: PUSH
 583: LD_VAR 0 4
 587: PUSH
 588: LD_EXP 17
 592: ADD
 593: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
 594: LD_ADDR_EXP 18
 598: PUSH
 599: LD_STRING Denis
 601: PPUSH
 602: LD_EXP 1
 606: NOT
 607: PPUSH
 608: LD_STRING 13s_
 610: PPUSH
 611: CALL 31127 0 3
 615: ST_TO_ADDR
// if Denis then
 616: LD_EXP 18
 620: IFFALSE 638
// tmp := tmp ^ Denis ;
 622: LD_ADDR_VAR 0 4
 626: PUSH
 627: LD_VAR 0 4
 631: PUSH
 632: LD_EXP 18
 636: ADD
 637: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
 638: LD_ADDR_EXP 19
 642: PUSH
 643: LD_STRING Brown
 645: PPUSH
 646: LD_EXP 1
 650: NOT
 651: PPUSH
 652: LD_STRING 13s_
 654: PPUSH
 655: CALL 31127 0 3
 659: ST_TO_ADDR
// if Brown then
 660: LD_EXP 19
 664: IFFALSE 682
// tmp := tmp ^ Brown ;
 666: LD_ADDR_VAR 0 4
 670: PUSH
 671: LD_VAR 0 4
 675: PUSH
 676: LD_EXP 19
 680: ADD
 681: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
 682: LD_ADDR_EXP 20
 686: PUSH
 687: LD_STRING Gladstone
 689: PPUSH
 690: LD_EXP 1
 694: NOT
 695: PPUSH
 696: LD_STRING 13s_
 698: PPUSH
 699: CALL 31127 0 3
 703: ST_TO_ADDR
// if Gladstone then
 704: LD_EXP 20
 708: IFFALSE 726
// tmp := tmp ^ Gladstone ;
 710: LD_ADDR_VAR 0 4
 714: PUSH
 715: LD_VAR 0 4
 719: PUSH
 720: LD_EXP 20
 724: ADD
 725: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
 726: LD_ADDR_EXP 21
 730: PUSH
 731: LD_STRING Houten
 733: PPUSH
 734: LD_EXP 1
 738: NOT
 739: PPUSH
 740: LD_STRING 13s_
 742: PPUSH
 743: CALL 31127 0 3
 747: ST_TO_ADDR
// if Houten then
 748: LD_EXP 21
 752: IFFALSE 770
// tmp := tmp ^ Houten ;
 754: LD_ADDR_VAR 0 4
 758: PUSH
 759: LD_VAR 0 4
 763: PUSH
 764: LD_EXP 21
 768: ADD
 769: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
 770: LD_ADDR_EXP 22
 774: PUSH
 775: LD_STRING Cornel
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 13s_
 786: PPUSH
 787: CALL 31127 0 3
 791: ST_TO_ADDR
// if Cornel then
 792: LD_EXP 22
 796: IFFALSE 814
// tmp := tmp ^ Cornel ;
 798: LD_ADDR_VAR 0 4
 802: PUSH
 803: LD_VAR 0 4
 807: PUSH
 808: LD_EXP 22
 812: ADD
 813: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
 814: LD_ADDR_EXP 23
 818: PUSH
 819: LD_STRING Gary
 821: PPUSH
 822: LD_EXP 1
 826: NOT
 827: PPUSH
 828: LD_STRING 13s_
 830: PPUSH
 831: CALL 31127 0 3
 835: ST_TO_ADDR
// if Gary then
 836: LD_EXP 23
 840: IFFALSE 858
// tmp := tmp ^ Gary ;
 842: LD_ADDR_VAR 0 4
 846: PUSH
 847: LD_VAR 0 4
 851: PUSH
 852: LD_EXP 23
 856: ADD
 857: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
 858: LD_ADDR_EXP 24
 862: PUSH
 863: LD_STRING Frank
 865: PPUSH
 866: LD_EXP 1
 870: NOT
 871: PPUSH
 872: LD_STRING 13s_
 874: PPUSH
 875: CALL 31127 0 3
 879: ST_TO_ADDR
// if Frank then
 880: LD_EXP 24
 884: IFFALSE 902
// tmp := tmp ^ Frank ;
 886: LD_ADDR_VAR 0 4
 890: PUSH
 891: LD_VAR 0 4
 895: PUSH
 896: LD_EXP 24
 900: ADD
 901: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
 902: LD_ADDR_EXP 25
 906: PUSH
 907: LD_STRING Kikuchi
 909: PPUSH
 910: LD_EXP 1
 914: NOT
 915: PPUSH
 916: LD_STRING 13s_
 918: PPUSH
 919: CALL 31127 0 3
 923: ST_TO_ADDR
// if Kikuchi then
 924: LD_EXP 25
 928: IFFALSE 946
// tmp := tmp ^ Kikuchi ;
 930: LD_ADDR_VAR 0 4
 934: PUSH
 935: LD_VAR 0 4
 939: PUSH
 940: LD_EXP 25
 944: ADD
 945: ST_TO_ADDR
// vip := tmp ;
 946: LD_ADDR_EXP 28
 950: PUSH
 951: LD_VAR 0 4
 955: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 4
 965: PUSH
 966: LD_STRING 13s_others
 968: PPUSH
 969: CALL_OW 31
 973: UNION
 974: ST_TO_ADDR
// if tmp < 20 then
 975: LD_VAR 0 4
 979: PUSH
 980: LD_INT 20
 982: LESS
 983: IFFALSE 1050
// for i = 1 to 20 - tmp do
 985: LD_ADDR_VAR 0 2
 989: PUSH
 990: DOUBLE
 991: LD_INT 1
 993: DEC
 994: ST_TO_ADDR
 995: LD_INT 20
 997: PUSH
 998: LD_VAR 0 4
1002: MINUS
1003: PUSH
1004: FOR_TO
1005: IFFALSE 1048
// begin PrepareHuman ( false , i mod 4 + 1 , 8 ) ;
1007: LD_INT 0
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 4
1017: MOD
1018: PUSH
1019: LD_INT 1
1021: PLUS
1022: PPUSH
1023: LD_INT 8
1025: PPUSH
1026: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1030: LD_ADDR_VAR 0 4
1034: PUSH
1035: LD_VAR 0 4
1039: PUSH
1040: CALL_OW 44
1044: ADD
1045: ST_TO_ADDR
// end ;
1046: GO 1004
1048: POP
1049: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1050: LD_ADDR_VAR 0 5
1054: PUSH
1055: LD_INT 22
1057: PUSH
1058: LD_INT 4
1060: PUSH
1061: EMPTY
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 30
1067: PUSH
1068: LD_INT 0
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: PUSH
1075: EMPTY
1076: LIST
1077: LIST
1078: PPUSH
1079: CALL_OW 69
1083: PUSH
1084: LD_INT 1
1086: ARRAY
1087: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
1088: LD_ADDR_VAR 0 6
1092: PUSH
1093: LD_INT 22
1095: PUSH
1096: LD_INT 4
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: PUSH
1103: LD_INT 30
1105: PUSH
1106: LD_INT 6
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: PPUSH
1117: CALL_OW 69
1121: PUSH
1122: LD_INT 1
1124: ARRAY
1125: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
1126: LD_ADDR_VAR 0 7
1130: PUSH
1131: LD_INT 22
1133: PUSH
1134: LD_INT 4
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 30
1143: PUSH
1144: LD_INT 4
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: PPUSH
1155: CALL_OW 69
1159: PUSH
1160: LD_INT 1
1162: ARRAY
1163: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
1164: LD_ADDR_VAR 0 8
1168: PUSH
1169: LD_INT 22
1171: PUSH
1172: LD_INT 4
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: PUSH
1179: LD_INT 30
1181: PUSH
1182: LD_INT 2
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: PUSH
1189: EMPTY
1190: LIST
1191: LIST
1192: PPUSH
1193: CALL_OW 69
1197: PUSH
1198: LD_INT 1
1200: ARRAY
1201: ST_TO_ADDR
// for i in tmp do
1202: LD_ADDR_VAR 0 2
1206: PUSH
1207: LD_VAR 0 4
1211: PUSH
1212: FOR_IN
1213: IFFALSE 1311
// begin b := [ armoury , depot , workshop , lab ] [ GetClass ( i ) ] ;
1215: LD_ADDR_VAR 0 3
1219: PUSH
1220: LD_VAR 0 7
1224: PUSH
1225: LD_VAR 0 5
1229: PUSH
1230: LD_VAR 0 8
1234: PUSH
1235: LD_VAR 0 6
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: PUSH
1246: LD_VAR 0 2
1250: PPUSH
1251: CALL_OW 257
1255: ARRAY
1256: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
1257: LD_VAR 0 3
1261: PPUSH
1262: CALL_OW 313
1266: PUSH
1267: LD_INT 6
1269: LESS
1270: IFFALSE 1288
// PlaceHumanInUnit ( i , b ) else
1272: LD_VAR 0 2
1276: PPUSH
1277: LD_VAR 0 3
1281: PPUSH
1282: CALL_OW 52
1286: GO 1309
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
1288: LD_VAR 0 2
1292: PPUSH
1293: LD_INT 58
1295: PPUSH
1296: LD_INT 91
1298: PPUSH
1299: LD_INT 6
1301: PPUSH
1302: LD_INT 0
1304: PPUSH
1305: CALL_OW 50
// end ;
1309: GO 1212
1311: POP
1312: POP
// end ; end_of_file
1313: LD_VAR 0 1
1317: RET
// export Kurt , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
1318: LD_INT 0
1320: PPUSH
1321: PPUSH
1322: PPUSH
1323: PPUSH
1324: PPUSH
// side := 8 ;
1325: LD_ADDR_VAR 0 3
1329: PUSH
1330: LD_INT 8
1332: ST_TO_ADDR
// uc_side := side ;
1333: LD_ADDR_OWVAR 20
1337: PUSH
1338: LD_VAR 0 3
1342: ST_TO_ADDR
// uc_nation := 2 ;
1343: LD_ADDR_OWVAR 21
1347: PUSH
1348: LD_INT 2
1350: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
1351: LD_ADDR_VAR 0 2
1355: PUSH
1356: LD_INT 22
1358: PUSH
1359: LD_VAR 0 3
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: LD_INT 21
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: PPUSH
1382: CALL_OW 69
1386: PUSH
1387: FOR_IN
1388: IFFALSE 1404
// SetBLevel ( i , 10 ) ;
1390: LD_VAR 0 2
1394: PPUSH
1395: LD_INT 10
1397: PPUSH
1398: CALL_OW 241
1402: GO 1387
1404: POP
1405: POP
// if KurtStatus then
1406: LD_EXP 3
1410: IFFALSE 1433
// Kurt := PrepareUnit ( Kurt , false ,  ) else
1412: LD_ADDR_EXP 29
1416: PUSH
1417: LD_STRING Kurt
1419: PPUSH
1420: LD_INT 0
1422: PPUSH
1423: LD_STRING 
1425: PPUSH
1426: CALL 31127 0 3
1430: ST_TO_ADDR
1431: GO 1455
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
1433: LD_ADDR_EXP 29
1437: PUSH
1438: LD_STRING AltKurt
1440: PPUSH
1441: LD_EXP 1
1445: NOT
1446: PPUSH
1447: LD_STRING 
1449: PPUSH
1450: CALL 31127 0 3
1454: ST_TO_ADDR
// if not Kurt then
1455: LD_EXP 29
1459: NOT
1460: IFFALSE 1486
// begin InitHc ;
1462: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
1466: LD_INT 1
1468: PPUSH
1469: LD_INT 10
1471: PPUSH
1472: CALL_OW 381
// Kurt := CreateHuman ;
1476: LD_ADDR_EXP 29
1480: PUSH
1481: CALL_OW 44
1485: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
1486: LD_EXP 29
1490: PPUSH
1491: LD_INT 324
1493: PPUSH
1494: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
1498: LD_ADDR_EXP 30
1502: PUSH
1503: LD_STRING Kozlov
1505: PPUSH
1506: LD_INT 0
1508: PPUSH
1509: LD_STRING 
1511: PPUSH
1512: CALL 31127 0 3
1516: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
1517: LD_EXP 30
1521: PPUSH
1522: LD_INT 22
1524: PUSH
1525: LD_INT 8
1527: PUSH
1528: EMPTY
1529: LIST
1530: LIST
1531: PUSH
1532: LD_INT 23
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PUSH
1542: LD_INT 30
1544: PUSH
1545: LD_INT 8
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: PPUSH
1557: CALL_OW 69
1561: PUSH
1562: LD_INT 1
1564: ARRAY
1565: PPUSH
1566: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
1570: LD_ADDR_VAR 0 5
1574: PUSH
1575: LD_INT 22
1577: PUSH
1578: LD_VAR 0 3
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PUSH
1587: LD_INT 30
1589: PUSH
1590: LD_INT 32
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 58
1599: PUSH
1600: EMPTY
1601: LIST
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: LIST
1607: PPUSH
1608: CALL_OW 69
1612: ST_TO_ADDR
// for i = 1 to 10 do
1613: LD_ADDR_VAR 0 2
1617: PUSH
1618: DOUBLE
1619: LD_INT 1
1621: DEC
1622: ST_TO_ADDR
1623: LD_INT 10
1625: PUSH
1626: FOR_TO
1627: IFFALSE 1699
// begin uc_nation := nation_nature ;
1629: LD_ADDR_OWVAR 21
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
1637: LD_ADDR_OWVAR 28
1641: PUSH
1642: LD_INT 15
1644: ST_TO_ADDR
// hc_gallery :=  ;
1645: LD_ADDR_OWVAR 33
1649: PUSH
1650: LD_STRING 
1652: ST_TO_ADDR
// hc_name :=  ;
1653: LD_ADDR_OWVAR 26
1657: PUSH
1658: LD_STRING 
1660: ST_TO_ADDR
// un := CreateHuman ;
1661: LD_ADDR_VAR 0 4
1665: PUSH
1666: CALL_OW 44
1670: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
1671: LD_VAR 0 4
1675: PPUSH
1676: LD_VAR 0 5
1680: PUSH
1681: LD_VAR 0 5
1685: PUSH
1686: LD_VAR 0 2
1690: MINUS
1691: ARRAY
1692: PPUSH
1693: CALL_OW 52
// end ;
1697: GO 1626
1699: POP
1700: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
1701: LD_ADDR_VAR 0 5
1705: PUSH
1706: LD_STRING 12_kurt_squad
1708: PPUSH
1709: CALL_OW 31
1713: ST_TO_ADDR
// if tmp then
1714: LD_VAR 0 5
1718: IFFALSE 1752
// for i in tmp do
1720: LD_ADDR_VAR 0 2
1724: PUSH
1725: LD_VAR 0 5
1729: PUSH
1730: FOR_IN
1731: IFFALSE 1750
// PlaceUnitArea ( i , legionBaseArea , false ) ;
1733: LD_VAR 0 2
1737: PPUSH
1738: LD_INT 5
1740: PPUSH
1741: LD_INT 0
1743: PPUSH
1744: CALL_OW 49
1748: GO 1730
1750: POP
1751: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
1752: LD_INT 324
1754: PPUSH
1755: LD_INT 5
1757: PPUSH
1758: LD_STRING 
1760: PPUSH
1761: LD_INT 8
1763: PUSH
1764: LD_INT 9
1766: PUSH
1767: LD_INT 10
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: PUSH
1775: LD_OWVAR 67
1779: ARRAY
1780: PPUSH
1781: LD_INT 3000
1783: PUSH
1784: LD_INT 500
1786: PUSH
1787: LD_INT 150
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: LIST
1794: PPUSH
1795: LD_INT 16
1797: PUSH
1798: LD_INT 6
1800: PUSH
1801: LD_INT 6
1803: PUSH
1804: LD_INT 8
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: PPUSH
1813: CALL 41169 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
1817: LD_ADDR_EXP 57
1821: PUSH
1822: LD_EXP 57
1826: PPUSH
1827: LD_INT 3
1829: PPUSH
1830: LD_INT 22
1832: PUSH
1833: LD_VAR 0 3
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 23
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: PUSH
1852: LD_INT 3
1854: PUSH
1855: LD_INT 21
1857: PUSH
1858: LD_INT 2
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: PUSH
1869: EMPTY
1870: LIST
1871: LIST
1872: LIST
1873: PPUSH
1874: CALL_OW 69
1878: PUSH
1879: LD_EXP 29
1883: DIFF
1884: PPUSH
1885: CALL_OW 1
1889: ST_TO_ADDR
// end ; end_of_file
1890: LD_VAR 0 1
1894: RET
// export Platonov , Kovalyuk ; export function PrepareRussian ; var i , base , tmp , side ; begin
1895: LD_INT 0
1897: PPUSH
1898: PPUSH
1899: PPUSH
1900: PPUSH
1901: PPUSH
// side := 3 ;
1902: LD_ADDR_VAR 0 5
1906: PUSH
1907: LD_INT 3
1909: ST_TO_ADDR
// uc_side := side ;
1910: LD_ADDR_OWVAR 20
1914: PUSH
1915: LD_VAR 0 5
1919: ST_TO_ADDR
// uc_nation := 3 ;
1920: LD_ADDR_OWVAR 21
1924: PUSH
1925: LD_INT 3
1927: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
1928: LD_ADDR_VAR 0 2
1932: PUSH
1933: LD_INT 22
1935: PUSH
1936: LD_VAR 0 5
1940: PUSH
1941: EMPTY
1942: LIST
1943: LIST
1944: PUSH
1945: LD_INT 21
1947: PUSH
1948: LD_INT 3
1950: PUSH
1951: EMPTY
1952: LIST
1953: LIST
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PPUSH
1959: CALL_OW 69
1963: PUSH
1964: FOR_IN
1965: IFFALSE 1981
// SetBLevel ( i , 10 ) ;
1967: LD_VAR 0 2
1971: PPUSH
1972: LD_INT 10
1974: PPUSH
1975: CALL_OW 241
1979: GO 1964
1981: POP
1982: POP
// Platonov := NewCharacter ( Platonov ) ;
1983: LD_ADDR_EXP 31
1987: PUSH
1988: LD_STRING Platonov
1990: PPUSH
1991: CALL_OW 25
1995: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
1996: LD_ADDR_EXP 32
2000: PUSH
2001: LD_STRING Kovalyuk
2003: PPUSH
2004: CALL_OW 25
2008: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , ru_depot ) ;
2009: LD_EXP 31
2013: PPUSH
2014: LD_INT 126
2016: PPUSH
2017: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
2021: LD_EXP 32
2025: PPUSH
2026: LD_INT 134
2028: PPUSH
2029: CALL_OW 52
// PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 1000 , 300 ] , [ - 1 , 8 , 13 , 8 ] ) ;
2033: LD_INT 126
2035: PPUSH
2036: LD_INT 4
2038: PPUSH
2039: LD_STRING zhukov
2041: PPUSH
2042: LD_INT 9
2044: PUSH
2045: LD_INT 10
2047: PUSH
2048: LD_INT 10
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: LIST
2055: PUSH
2056: LD_OWVAR 67
2060: ARRAY
2061: PPUSH
2062: LD_INT 3000
2064: PUSH
2065: LD_INT 1000
2067: PUSH
2068: LD_INT 300
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: LIST
2075: PPUSH
2076: LD_INT 1
2078: NEG
2079: PUSH
2080: LD_INT 8
2082: PUSH
2083: LD_INT 13
2085: PUSH
2086: LD_INT 8
2088: PUSH
2089: EMPTY
2090: LIST
2091: LIST
2092: LIST
2093: LIST
2094: PPUSH
2095: CALL 41169 0 6
// base := GetBase ( ru_depot2 ) ;
2099: LD_ADDR_VAR 0 3
2103: PUSH
2104: LD_INT 267
2106: PPUSH
2107: CALL_OW 274
2111: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 600 ) ;
2112: LD_VAR 0 3
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_INT 600
2122: PPUSH
2123: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
2127: LD_VAR 0 3
2131: PPUSH
2132: LD_INT 2
2134: PPUSH
2135: LD_INT 200
2137: PPUSH
2138: CALL_OW 277
// SetResourceType ( base , mat_siberit , 20 ) ;
2142: LD_VAR 0 3
2146: PPUSH
2147: LD_INT 3
2149: PPUSH
2150: LD_INT 20
2152: PPUSH
2153: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Platonov , Kovalyuk ] ) ;
2157: LD_ADDR_EXP 57
2161: PUSH
2162: LD_EXP 57
2166: PPUSH
2167: LD_INT 2
2169: PPUSH
2170: LD_INT 22
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: EMPTY
2179: LIST
2180: LIST
2181: PUSH
2182: LD_INT 3
2184: PUSH
2185: LD_INT 21
2187: PUSH
2188: LD_INT 2
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 69
2207: PUSH
2208: LD_EXP 31
2212: PUSH
2213: LD_EXP 32
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: DIFF
2222: PPUSH
2223: CALL_OW 1
2227: ST_TO_ADDR
// end ; end_of_file
2228: LD_VAR 0 1
2232: RET
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
2233: LD_INT 0
2235: PPUSH
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
// side := 7 ;
2241: LD_ADDR_VAR 0 5
2245: PUSH
2246: LD_INT 7
2248: ST_TO_ADDR
// uc_side := side ;
2249: LD_ADDR_OWVAR 20
2253: PUSH
2254: LD_VAR 0 5
2258: ST_TO_ADDR
// uc_nation := 1 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 1
2266: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
2267: LD_ADDR_VAR 0 2
2271: PUSH
2272: LD_INT 22
2274: PUSH
2275: LD_VAR 0 5
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: PUSH
2284: LD_INT 21
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: PPUSH
2298: CALL_OW 69
2302: PUSH
2303: FOR_IN
2304: IFFALSE 2320
// SetBLevel ( i , 10 ) ;
2306: LD_VAR 0 2
2310: PPUSH
2311: LD_INT 10
2313: PPUSH
2314: CALL_OW 241
2318: GO 2303
2320: POP
2321: POP
// base := GetBase ( al_depot ) ;
2322: LD_ADDR_VAR 0 4
2326: PUSH
2327: LD_INT 2
2329: PPUSH
2330: CALL_OW 274
2334: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
2335: LD_ADDR_VAR 0 6
2339: PUSH
2340: LD_INT 22
2342: PUSH
2343: LD_VAR 0 5
2347: PUSH
2348: EMPTY
2349: LIST
2350: LIST
2351: PUSH
2352: LD_INT 30
2354: PUSH
2355: LD_INT 34
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: PPUSH
2366: CALL_OW 69
2370: ST_TO_ADDR
// if teleport then
2371: LD_VAR 0 6
2375: IFFALSE 2396
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
2377: LD_VAR 0 6
2381: PUSH
2382: LD_INT 1
2384: ARRAY
2385: PPUSH
2386: LD_INT 262
2388: PPUSH
2389: LD_INT 119
2391: PPUSH
2392: CALL_OW 243
// SetResourceType ( base , mat_cans , 2500 ) ;
2396: LD_VAR 0 4
2400: PPUSH
2401: LD_INT 1
2403: PPUSH
2404: LD_INT 2500
2406: PPUSH
2407: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
2411: LD_VAR 0 4
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: LD_INT 200
2421: PPUSH
2422: CALL_OW 277
// SetResourceType ( base , mat_siberit , 50 ) ;
2426: LD_VAR 0 4
2430: PPUSH
2431: LD_INT 3
2433: PPUSH
2434: LD_INT 50
2436: PPUSH
2437: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
2441: LD_ADDR_EXP 33
2445: PUSH
2446: LD_STRING Roth
2448: PPUSH
2449: CALL_OW 25
2453: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
2454: LD_ADDR_EXP 34
2458: PUSH
2459: LD_STRING Simms
2461: PPUSH
2462: LD_EXP 1
2466: NOT
2467: PPUSH
2468: LD_STRING 10c_
2470: PPUSH
2471: CALL 31127 0 3
2475: ST_TO_ADDR
// uc_nation := 3 ;
2476: LD_ADDR_OWVAR 21
2480: PUSH
2481: LD_INT 3
2483: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
2484: LD_ADDR_EXP 35
2488: PUSH
2489: LD_STRING Kirilenkova
2491: PPUSH
2492: CALL_OW 25
2496: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2497: LD_ADDR_EXP 49
2501: PUSH
2502: LD_STRING Oblukov
2504: PPUSH
2505: CALL_OW 25
2509: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2510: LD_ADDR_EXP 36
2514: PUSH
2515: LD_STRING Dolgov
2517: PPUSH
2518: CALL_OW 25
2522: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2523: LD_ADDR_EXP 37
2527: PUSH
2528: LD_STRING Petrosyan
2530: PPUSH
2531: CALL_OW 25
2535: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2536: LD_ADDR_EXP 48
2540: PUSH
2541: LD_STRING Scholtze
2543: PPUSH
2544: CALL_OW 25
2548: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2549: LD_ADDR_EXP 47
2553: PUSH
2554: LD_STRING Kapitsova
2556: PPUSH
2557: CALL_OW 25
2561: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
2562: LD_ADDR_EXP 38
2566: PUSH
2567: LD_STRING Petrovova
2569: PPUSH
2570: CALL_OW 25
2574: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2575: LD_ADDR_EXP 39
2579: PUSH
2580: LD_STRING Kuzmov
2582: PPUSH
2583: CALL_OW 25
2587: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2588: LD_ADDR_EXP 46
2592: PUSH
2593: LD_STRING Karamazov
2595: PPUSH
2596: CALL_OW 25
2600: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
2601: LD_STRING 13_Lipshchin_1
2603: PPUSH
2604: LD_INT 0
2606: PPUSH
2607: CALL_OW 30
2611: IFFALSE 2626
// Lipshchin := NewCharacter ( Lipshchin ) ;
2613: LD_ADDR_EXP 40
2617: PUSH
2618: LD_STRING Lipshchin
2620: PPUSH
2621: CALL_OW 25
2625: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
2626: LD_STRING 13_Titov_1
2628: PPUSH
2629: LD_INT 0
2631: PPUSH
2632: CALL_OW 30
2636: IFFALSE 2651
// Titov := NewCharacter ( Titov ) ;
2638: LD_ADDR_EXP 42
2642: PUSH
2643: LD_STRING Titov
2645: PPUSH
2646: CALL_OW 25
2650: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
2651: LD_STRING 13_Gnyevko_1
2653: PPUSH
2654: LD_INT 0
2656: PPUSH
2657: CALL_OW 30
2661: IFFALSE 2676
// Gnyevko := NewCharacter ( Gnyevko ) ;
2663: LD_ADDR_EXP 41
2667: PUSH
2668: LD_STRING Gnyevko
2670: PPUSH
2671: CALL_OW 25
2675: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
2676: LD_STRING 13_Xavier_1
2678: PPUSH
2679: LD_INT 0
2681: PPUSH
2682: CALL_OW 30
2686: IFFALSE 2701
// Xavier := NewCharacter ( Xavier2 ) ;
2688: LD_ADDR_EXP 43
2692: PUSH
2693: LD_STRING Xavier2
2695: PPUSH
2696: CALL_OW 25
2700: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
2701: LD_STRING 13_Belkov_1
2703: PPUSH
2704: LD_INT 0
2706: PPUSH
2707: CALL_OW 30
2711: IFFALSE 2726
// Belkov := NewCharacter ( Belkov ) ;
2713: LD_ADDR_EXP 44
2717: PUSH
2718: LD_STRING Belkov
2720: PPUSH
2721: CALL_OW 25
2725: ST_TO_ADDR
// if not BurlakStatus then
2726: LD_EXP 9
2730: NOT
2731: IFFALSE 2746
// Burlak = NewCharacter ( Burlak ) ;
2733: LD_ADDR_EXP 45
2737: PUSH
2738: LD_STRING Burlak
2740: PPUSH
2741: CALL_OW 25
2745: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
2746: LD_ADDR_VAR 0 3
2750: PUSH
2751: LD_EXP 33
2755: PUSH
2756: LD_EXP 35
2760: PUSH
2761: LD_EXP 49
2765: PUSH
2766: LD_EXP 36
2770: PUSH
2771: LD_EXP 37
2775: PUSH
2776: LD_EXP 48
2780: PUSH
2781: LD_EXP 47
2785: PUSH
2786: LD_EXP 38
2790: PUSH
2791: LD_EXP 39
2795: PUSH
2796: LD_EXP 46
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: ST_TO_ADDR
// if Simms then
2813: LD_EXP 34
2817: IFFALSE 2835
// tmp := tmp ^ Simms ;
2819: LD_ADDR_VAR 0 3
2823: PUSH
2824: LD_VAR 0 3
2828: PUSH
2829: LD_EXP 34
2833: ADD
2834: ST_TO_ADDR
// if Titov then
2835: LD_EXP 42
2839: IFFALSE 2857
// tmp := tmp ^ Titov ;
2841: LD_ADDR_VAR 0 3
2845: PUSH
2846: LD_VAR 0 3
2850: PUSH
2851: LD_EXP 42
2855: ADD
2856: ST_TO_ADDR
// if Lipshchin then
2857: LD_EXP 40
2861: IFFALSE 2879
// tmp := tmp ^ Lipshchin ;
2863: LD_ADDR_VAR 0 3
2867: PUSH
2868: LD_VAR 0 3
2872: PUSH
2873: LD_EXP 40
2877: ADD
2878: ST_TO_ADDR
// if Gnyevko then
2879: LD_EXP 41
2883: IFFALSE 2901
// tmp := tmp ^ Gnyevko ;
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 3
2894: PUSH
2895: LD_EXP 41
2899: ADD
2900: ST_TO_ADDR
// if Xavier then
2901: LD_EXP 43
2905: IFFALSE 2923
// tmp := tmp ^ Xavier ;
2907: LD_ADDR_VAR 0 3
2911: PUSH
2912: LD_VAR 0 3
2916: PUSH
2917: LD_EXP 43
2921: ADD
2922: ST_TO_ADDR
// if Belkov then
2923: LD_EXP 44
2927: IFFALSE 2945
// tmp := tmp ^ Belkov ;
2929: LD_ADDR_VAR 0 3
2933: PUSH
2934: LD_VAR 0 3
2938: PUSH
2939: LD_EXP 44
2943: ADD
2944: ST_TO_ADDR
// if Burlak then
2945: LD_EXP 45
2949: IFFALSE 2967
// tmp := tmp ^ Burlak ;
2951: LD_ADDR_VAR 0 3
2955: PUSH
2956: LD_VAR 0 3
2960: PUSH
2961: LD_EXP 45
2965: ADD
2966: ST_TO_ADDR
// for i = 1 to 8 do
2967: LD_ADDR_VAR 0 2
2971: PUSH
2972: DOUBLE
2973: LD_INT 1
2975: DEC
2976: ST_TO_ADDR
2977: LD_INT 8
2979: PUSH
2980: FOR_TO
2981: IFFALSE 3047
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2983: LD_ADDR_OWVAR 21
2987: PUSH
2988: LD_INT 1
2990: PUSH
2991: LD_INT 3
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: PUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_INT 2
3003: PPUSH
3004: CALL_OW 12
3008: ARRAY
3009: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
3010: LD_INT 0
3012: PPUSH
3013: LD_VAR 0 2
3017: PUSH
3018: LD_INT 2
3020: DIV
3021: PPUSH
3022: LD_INT 10
3024: PPUSH
3025: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3029: LD_ADDR_VAR 0 3
3033: PUSH
3034: LD_VAR 0 3
3038: PUSH
3039: CALL_OW 44
3043: ADD
3044: ST_TO_ADDR
// end ;
3045: GO 2980
3047: POP
3048: POP
// for i in tmp do
3049: LD_ADDR_VAR 0 2
3053: PUSH
3054: LD_VAR 0 3
3058: PUSH
3059: FOR_IN
3060: IFFALSE 3085
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
3062: LD_VAR 0 2
3066: PPUSH
3067: LD_INT 260
3069: PPUSH
3070: LD_INT 235
3072: PPUSH
3073: LD_INT 8
3075: PPUSH
3076: LD_INT 0
3078: PPUSH
3079: CALL_OW 50
3083: GO 3059
3085: POP
3086: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
3087: LD_ADDR_EXP 57
3091: PUSH
3092: LD_EXP 57
3096: PPUSH
3097: LD_INT 1
3099: PPUSH
3100: LD_INT 22
3102: PUSH
3103: LD_VAR 0 5
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: PUSH
3112: LD_INT 3
3114: PUSH
3115: LD_INT 21
3117: PUSH
3118: LD_INT 2
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PPUSH
3133: CALL_OW 69
3137: PPUSH
3138: CALL_OW 1
3142: ST_TO_ADDR
// end ; end_of_file end_of_file
3143: LD_VAR 0 1
3147: RET
// export function Action ; var i , tmp ; begin
3148: LD_INT 0
3150: PPUSH
3151: PPUSH
3152: PPUSH
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
3153: LD_ADDR_VAR 0 3
3157: PUSH
3158: LD_INT 8
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 517
3168: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3169: LD_ADDR_VAR 0 2
3173: PUSH
3174: DOUBLE
3175: LD_INT 1
3177: DEC
3178: ST_TO_ADDR
3179: LD_VAR 0 3
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PUSH
3188: FOR_TO
3189: IFFALSE 3234
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
3191: LD_VAR 0 3
3195: PUSH
3196: LD_INT 1
3198: ARRAY
3199: PUSH
3200: LD_VAR 0 2
3204: ARRAY
3205: PPUSH
3206: LD_VAR 0 3
3210: PUSH
3211: LD_INT 2
3213: ARRAY
3214: PUSH
3215: LD_VAR 0 2
3219: ARRAY
3220: PPUSH
3221: LD_INT 1
3223: PPUSH
3224: LD_INT 15
3226: NEG
3227: PPUSH
3228: CALL 73329 0 4
3232: GO 3188
3234: POP
3235: POP
// end ; end_of_file
3236: LD_VAR 0 1
3240: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
3241: LD_VAR 0 1
3245: PPUSH
3246: CALL 28645 0 1
// end ;
3250: PPOPN 1
3252: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
3253: LD_VAR 0 1
3257: PPUSH
3258: LD_VAR 0 2
3262: PPUSH
3263: CALL 30530 0 2
// end ;
3267: PPOPN 2
3269: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
3270: LD_VAR 0 1
3274: PPUSH
3275: CALL 29612 0 1
// end ;
3279: PPOPN 1
3281: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
3282: LD_VAR 0 1
3286: PPUSH
3287: CALL 29846 0 1
// end ;
3291: PPOPN 1
3293: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
3294: LD_VAR 0 1
3298: PPUSH
3299: LD_VAR 0 2
3303: PPUSH
3304: CALL 28357 0 2
// end ;
3308: PPOPN 2
3310: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
3311: LD_VAR 0 1
3315: PPUSH
3316: LD_VAR 0 2
3320: PPUSH
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_VAR 0 4
3330: PPUSH
3331: LD_VAR 0 5
3335: PPUSH
3336: CALL 27984 0 5
// end ;
3340: PPOPN 5
3342: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
3343: LD_VAR 0 1
3347: PPUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL 27581 0 2
// end ;
3357: PPOPN 2
3359: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
3360: LD_VAR 0 1
3364: PPUSH
3365: LD_VAR 0 2
3369: PPUSH
3370: LD_VAR 0 3
3374: PPUSH
3375: LD_VAR 0 4
3379: PPUSH
3380: CALL 27426 0 4
// end ;
3384: PPOPN 4
3386: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
3387: LD_VAR 0 1
3391: PPUSH
3392: LD_VAR 0 2
3396: PPUSH
3397: LD_VAR 0 3
3401: PPUSH
3402: CALL 27208 0 3
// end ;
3406: PPOPN 3
3408: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
3409: LD_VAR 0 1
3413: PPUSH
3414: LD_VAR 0 2
3418: PPUSH
3419: CALL 27100 0 2
// end ;
3423: PPOPN 2
3425: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
3426: LD_VAR 0 1
3430: PPUSH
3431: LD_VAR 0 2
3435: PPUSH
3436: CALL 30784 0 2
// end ;
3440: PPOPN 2
3442: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
3443: LD_VAR 0 1
3447: PPUSH
3448: LD_VAR 0 2
3452: PPUSH
3453: LD_VAR 0 3
3457: PPUSH
3458: LD_VAR 0 4
3462: PPUSH
3463: CALL 30993 0 4
// end ;
3467: PPOPN 4
3469: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
3470: LD_VAR 0 1
3474: PPUSH
3475: LD_VAR 0 2
3479: PPUSH
3480: CALL 26916 0 2
// end ; end_of_file
3484: PPOPN 2
3486: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
3487: GO 3489
3489: DISABLE
// begin ru_radar := 98 ;
3490: LD_ADDR_EXP 50
3494: PUSH
3495: LD_INT 98
3497: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
3498: LD_ADDR_EXP 51
3502: PUSH
3503: LD_INT 89
3505: ST_TO_ADDR
// us_hack := 99 ;
3506: LD_ADDR_EXP 52
3510: PUSH
3511: LD_INT 99
3513: ST_TO_ADDR
// us_artillery := 97 ;
3514: LD_ADDR_EXP 53
3518: PUSH
3519: LD_INT 97
3521: ST_TO_ADDR
// ar_bio_bomb := 91 ;
3522: LD_ADDR_EXP 54
3526: PUSH
3527: LD_INT 91
3529: ST_TO_ADDR
// end ; end_of_file
3530: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
3531: LD_INT 0
3533: PPUSH
3534: PPUSH
// skirmish := false ;
3535: LD_ADDR_EXP 55
3539: PUSH
3540: LD_INT 0
3542: ST_TO_ADDR
// debug_mc := false ;
3543: LD_ADDR_EXP 56
3547: PUSH
3548: LD_INT 0
3550: ST_TO_ADDR
// mc_bases := [ ] ;
3551: LD_ADDR_EXP 57
3555: PUSH
3556: EMPTY
3557: ST_TO_ADDR
// mc_sides := [ ] ;
3558: LD_ADDR_EXP 83
3562: PUSH
3563: EMPTY
3564: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
3565: LD_ADDR_EXP 58
3569: PUSH
3570: EMPTY
3571: ST_TO_ADDR
// mc_building_repairs := [ ] ;
3572: LD_ADDR_EXP 59
3576: PUSH
3577: EMPTY
3578: ST_TO_ADDR
// mc_need_heal := [ ] ;
3579: LD_ADDR_EXP 60
3583: PUSH
3584: EMPTY
3585: ST_TO_ADDR
// mc_healers := [ ] ;
3586: LD_ADDR_EXP 61
3590: PUSH
3591: EMPTY
3592: ST_TO_ADDR
// mc_build_list := [ ] ;
3593: LD_ADDR_EXP 62
3597: PUSH
3598: EMPTY
3599: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
3600: LD_ADDR_EXP 89
3604: PUSH
3605: EMPTY
3606: ST_TO_ADDR
// mc_builders := [ ] ;
3607: LD_ADDR_EXP 63
3611: PUSH
3612: EMPTY
3613: ST_TO_ADDR
// mc_construct_list := [ ] ;
3614: LD_ADDR_EXP 64
3618: PUSH
3619: EMPTY
3620: ST_TO_ADDR
// mc_turret_list := [ ] ;
3621: LD_ADDR_EXP 65
3625: PUSH
3626: EMPTY
3627: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
3628: LD_ADDR_EXP 66
3632: PUSH
3633: EMPTY
3634: ST_TO_ADDR
// mc_miners := [ ] ;
3635: LD_ADDR_EXP 71
3639: PUSH
3640: EMPTY
3641: ST_TO_ADDR
// mc_mines := [ ] ;
3642: LD_ADDR_EXP 70
3646: PUSH
3647: EMPTY
3648: ST_TO_ADDR
// mc_minefields := [ ] ;
3649: LD_ADDR_EXP 72
3653: PUSH
3654: EMPTY
3655: ST_TO_ADDR
// mc_crates := [ ] ;
3656: LD_ADDR_EXP 73
3660: PUSH
3661: EMPTY
3662: ST_TO_ADDR
// mc_crates_collector := [ ] ;
3663: LD_ADDR_EXP 74
3667: PUSH
3668: EMPTY
3669: ST_TO_ADDR
// mc_crates_area := [ ] ;
3670: LD_ADDR_EXP 75
3674: PUSH
3675: EMPTY
3676: ST_TO_ADDR
// mc_vehicles := [ ] ;
3677: LD_ADDR_EXP 76
3681: PUSH
3682: EMPTY
3683: ST_TO_ADDR
// mc_attack := [ ] ;
3684: LD_ADDR_EXP 77
3688: PUSH
3689: EMPTY
3690: ST_TO_ADDR
// mc_produce := [ ] ;
3691: LD_ADDR_EXP 78
3695: PUSH
3696: EMPTY
3697: ST_TO_ADDR
// mc_defender := [ ] ;
3698: LD_ADDR_EXP 79
3702: PUSH
3703: EMPTY
3704: ST_TO_ADDR
// mc_parking := [ ] ;
3705: LD_ADDR_EXP 81
3709: PUSH
3710: EMPTY
3711: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
3712: LD_ADDR_EXP 67
3716: PUSH
3717: EMPTY
3718: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
3719: LD_ADDR_EXP 69
3723: PUSH
3724: EMPTY
3725: ST_TO_ADDR
// mc_scan := [ ] ;
3726: LD_ADDR_EXP 80
3730: PUSH
3731: EMPTY
3732: ST_TO_ADDR
// mc_scan_area := [ ] ;
3733: LD_ADDR_EXP 82
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// mc_tech := [ ] ;
3740: LD_ADDR_EXP 84
3744: PUSH
3745: EMPTY
3746: ST_TO_ADDR
// mc_class := [ ] ;
3747: LD_ADDR_EXP 98
3751: PUSH
3752: EMPTY
3753: ST_TO_ADDR
// mc_class_case_use := [ ] ;
3754: LD_ADDR_EXP 99
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// end ;
3761: LD_VAR 0 1
3765: RET
// export function MC_Kill ( base ) ; begin
3766: LD_INT 0
3768: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
3769: LD_ADDR_EXP 57
3773: PUSH
3774: LD_EXP 57
3778: PPUSH
3779: LD_VAR 0 1
3783: PPUSH
3784: EMPTY
3785: PPUSH
3786: CALL_OW 1
3790: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
3791: LD_ADDR_EXP 58
3795: PUSH
3796: LD_EXP 58
3800: PPUSH
3801: LD_VAR 0 1
3805: PPUSH
3806: EMPTY
3807: PPUSH
3808: CALL_OW 1
3812: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
3813: LD_ADDR_EXP 59
3817: PUSH
3818: LD_EXP 59
3822: PPUSH
3823: LD_VAR 0 1
3827: PPUSH
3828: EMPTY
3829: PPUSH
3830: CALL_OW 1
3834: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
3835: LD_ADDR_EXP 60
3839: PUSH
3840: LD_EXP 60
3844: PPUSH
3845: LD_VAR 0 1
3849: PPUSH
3850: EMPTY
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
3857: LD_ADDR_EXP 61
3861: PUSH
3862: LD_EXP 61
3866: PPUSH
3867: LD_VAR 0 1
3871: PPUSH
3872: EMPTY
3873: PPUSH
3874: CALL_OW 1
3878: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
3879: LD_ADDR_EXP 62
3883: PUSH
3884: LD_EXP 62
3888: PPUSH
3889: LD_VAR 0 1
3893: PPUSH
3894: EMPTY
3895: PPUSH
3896: CALL_OW 1
3900: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
3901: LD_ADDR_EXP 63
3905: PUSH
3906: LD_EXP 63
3910: PPUSH
3911: LD_VAR 0 1
3915: PPUSH
3916: EMPTY
3917: PPUSH
3918: CALL_OW 1
3922: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
3923: LD_ADDR_EXP 64
3927: PUSH
3928: LD_EXP 64
3932: PPUSH
3933: LD_VAR 0 1
3937: PPUSH
3938: EMPTY
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
3945: LD_ADDR_EXP 65
3949: PUSH
3950: LD_EXP 65
3954: PPUSH
3955: LD_VAR 0 1
3959: PPUSH
3960: EMPTY
3961: PPUSH
3962: CALL_OW 1
3966: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
3967: LD_ADDR_EXP 66
3971: PUSH
3972: LD_EXP 66
3976: PPUSH
3977: LD_VAR 0 1
3981: PPUSH
3982: EMPTY
3983: PPUSH
3984: CALL_OW 1
3988: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
3989: LD_ADDR_EXP 67
3993: PUSH
3994: LD_EXP 67
3998: PPUSH
3999: LD_VAR 0 1
4003: PPUSH
4004: EMPTY
4005: PPUSH
4006: CALL_OW 1
4010: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
4011: LD_ADDR_EXP 68
4015: PUSH
4016: LD_EXP 68
4020: PPUSH
4021: LD_VAR 0 1
4025: PPUSH
4026: LD_INT 0
4028: PPUSH
4029: CALL_OW 1
4033: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
4034: LD_ADDR_EXP 69
4038: PUSH
4039: LD_EXP 69
4043: PPUSH
4044: LD_VAR 0 1
4048: PPUSH
4049: EMPTY
4050: PPUSH
4051: CALL_OW 1
4055: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
4056: LD_ADDR_EXP 70
4060: PUSH
4061: LD_EXP 70
4065: PPUSH
4066: LD_VAR 0 1
4070: PPUSH
4071: EMPTY
4072: PPUSH
4073: CALL_OW 1
4077: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
4078: LD_ADDR_EXP 71
4082: PUSH
4083: LD_EXP 71
4087: PPUSH
4088: LD_VAR 0 1
4092: PPUSH
4093: EMPTY
4094: PPUSH
4095: CALL_OW 1
4099: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
4100: LD_ADDR_EXP 72
4104: PUSH
4105: LD_EXP 72
4109: PPUSH
4110: LD_VAR 0 1
4114: PPUSH
4115: EMPTY
4116: PPUSH
4117: CALL_OW 1
4121: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
4122: LD_ADDR_EXP 73
4126: PUSH
4127: LD_EXP 73
4131: PPUSH
4132: LD_VAR 0 1
4136: PPUSH
4137: EMPTY
4138: PPUSH
4139: CALL_OW 1
4143: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
4144: LD_ADDR_EXP 74
4148: PUSH
4149: LD_EXP 74
4153: PPUSH
4154: LD_VAR 0 1
4158: PPUSH
4159: EMPTY
4160: PPUSH
4161: CALL_OW 1
4165: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
4166: LD_ADDR_EXP 75
4170: PUSH
4171: LD_EXP 75
4175: PPUSH
4176: LD_VAR 0 1
4180: PPUSH
4181: EMPTY
4182: PPUSH
4183: CALL_OW 1
4187: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
4188: LD_ADDR_EXP 76
4192: PUSH
4193: LD_EXP 76
4197: PPUSH
4198: LD_VAR 0 1
4202: PPUSH
4203: EMPTY
4204: PPUSH
4205: CALL_OW 1
4209: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
4210: LD_ADDR_EXP 77
4214: PUSH
4215: LD_EXP 77
4219: PPUSH
4220: LD_VAR 0 1
4224: PPUSH
4225: EMPTY
4226: PPUSH
4227: CALL_OW 1
4231: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
4232: LD_ADDR_EXP 78
4236: PUSH
4237: LD_EXP 78
4241: PPUSH
4242: LD_VAR 0 1
4246: PPUSH
4247: EMPTY
4248: PPUSH
4249: CALL_OW 1
4253: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
4254: LD_ADDR_EXP 79
4258: PUSH
4259: LD_EXP 79
4263: PPUSH
4264: LD_VAR 0 1
4268: PPUSH
4269: EMPTY
4270: PPUSH
4271: CALL_OW 1
4275: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
4276: LD_ADDR_EXP 80
4280: PUSH
4281: LD_EXP 80
4285: PPUSH
4286: LD_VAR 0 1
4290: PPUSH
4291: EMPTY
4292: PPUSH
4293: CALL_OW 1
4297: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
4298: LD_ADDR_EXP 81
4302: PUSH
4303: LD_EXP 81
4307: PPUSH
4308: LD_VAR 0 1
4312: PPUSH
4313: EMPTY
4314: PPUSH
4315: CALL_OW 1
4319: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
4320: LD_ADDR_EXP 82
4324: PUSH
4325: LD_EXP 82
4329: PPUSH
4330: LD_VAR 0 1
4334: PPUSH
4335: EMPTY
4336: PPUSH
4337: CALL_OW 1
4341: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
4342: LD_ADDR_EXP 84
4346: PUSH
4347: LD_EXP 84
4351: PPUSH
4352: LD_VAR 0 1
4356: PPUSH
4357: EMPTY
4358: PPUSH
4359: CALL_OW 1
4363: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
4364: LD_ADDR_EXP 86
4368: PUSH
4369: LD_EXP 86
4373: PPUSH
4374: LD_VAR 0 1
4378: PPUSH
4379: EMPTY
4380: PPUSH
4381: CALL_OW 1
4385: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
4386: LD_ADDR_EXP 87
4390: PUSH
4391: LD_EXP 87
4395: PPUSH
4396: LD_VAR 0 1
4400: PPUSH
4401: EMPTY
4402: PPUSH
4403: CALL_OW 1
4407: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
4408: LD_ADDR_EXP 88
4412: PUSH
4413: LD_EXP 88
4417: PPUSH
4418: LD_VAR 0 1
4422: PPUSH
4423: EMPTY
4424: PPUSH
4425: CALL_OW 1
4429: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
4430: LD_ADDR_EXP 89
4434: PUSH
4435: LD_EXP 89
4439: PPUSH
4440: LD_VAR 0 1
4444: PPUSH
4445: EMPTY
4446: PPUSH
4447: CALL_OW 1
4451: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
4452: LD_ADDR_EXP 90
4456: PUSH
4457: LD_EXP 90
4461: PPUSH
4462: LD_VAR 0 1
4466: PPUSH
4467: EMPTY
4468: PPUSH
4469: CALL_OW 1
4473: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
4474: LD_ADDR_EXP 91
4478: PUSH
4479: LD_EXP 91
4483: PPUSH
4484: LD_VAR 0 1
4488: PPUSH
4489: EMPTY
4490: PPUSH
4491: CALL_OW 1
4495: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
4496: LD_ADDR_EXP 92
4500: PUSH
4501: LD_EXP 92
4505: PPUSH
4506: LD_VAR 0 1
4510: PPUSH
4511: EMPTY
4512: PPUSH
4513: CALL_OW 1
4517: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
4518: LD_ADDR_EXP 93
4522: PUSH
4523: LD_EXP 93
4527: PPUSH
4528: LD_VAR 0 1
4532: PPUSH
4533: EMPTY
4534: PPUSH
4535: CALL_OW 1
4539: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
4540: LD_ADDR_EXP 94
4544: PUSH
4545: LD_EXP 94
4549: PPUSH
4550: LD_VAR 0 1
4554: PPUSH
4555: EMPTY
4556: PPUSH
4557: CALL_OW 1
4561: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
4562: LD_ADDR_EXP 95
4566: PUSH
4567: LD_EXP 95
4571: PPUSH
4572: LD_VAR 0 1
4576: PPUSH
4577: EMPTY
4578: PPUSH
4579: CALL_OW 1
4583: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
4584: LD_ADDR_EXP 96
4588: PUSH
4589: LD_EXP 96
4593: PPUSH
4594: LD_VAR 0 1
4598: PPUSH
4599: EMPTY
4600: PPUSH
4601: CALL_OW 1
4605: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
4606: LD_ADDR_EXP 97
4610: PUSH
4611: LD_EXP 97
4615: PPUSH
4616: LD_VAR 0 1
4620: PPUSH
4621: EMPTY
4622: PPUSH
4623: CALL_OW 1
4627: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
4628: LD_ADDR_EXP 98
4632: PUSH
4633: LD_EXP 98
4637: PPUSH
4638: LD_VAR 0 1
4642: PPUSH
4643: EMPTY
4644: PPUSH
4645: CALL_OW 1
4649: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
4650: LD_ADDR_EXP 99
4654: PUSH
4655: LD_EXP 99
4659: PPUSH
4660: LD_VAR 0 1
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 1
4672: ST_TO_ADDR
// end ;
4673: LD_VAR 0 2
4677: RET
// export function MC_Start ( ) ; var i ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
// for i = 1 to mc_bases do
4682: LD_ADDR_VAR 0 2
4686: PUSH
4687: DOUBLE
4688: LD_INT 1
4690: DEC
4691: ST_TO_ADDR
4692: LD_EXP 57
4696: PUSH
4697: FOR_TO
4698: IFFALSE 5775
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
4700: LD_ADDR_EXP 57
4704: PUSH
4705: LD_EXP 57
4709: PPUSH
4710: LD_VAR 0 2
4714: PPUSH
4715: LD_EXP 57
4719: PUSH
4720: LD_VAR 0 2
4724: ARRAY
4725: PUSH
4726: LD_INT 0
4728: DIFF
4729: PPUSH
4730: CALL_OW 1
4734: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
4735: LD_ADDR_EXP 58
4739: PUSH
4740: LD_EXP 58
4744: PPUSH
4745: LD_VAR 0 2
4749: PPUSH
4750: EMPTY
4751: PPUSH
4752: CALL_OW 1
4756: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
4757: LD_ADDR_EXP 59
4761: PUSH
4762: LD_EXP 59
4766: PPUSH
4767: LD_VAR 0 2
4771: PPUSH
4772: EMPTY
4773: PPUSH
4774: CALL_OW 1
4778: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
4779: LD_ADDR_EXP 60
4783: PUSH
4784: LD_EXP 60
4788: PPUSH
4789: LD_VAR 0 2
4793: PPUSH
4794: EMPTY
4795: PPUSH
4796: CALL_OW 1
4800: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
4801: LD_ADDR_EXP 61
4805: PUSH
4806: LD_EXP 61
4810: PPUSH
4811: LD_VAR 0 2
4815: PPUSH
4816: EMPTY
4817: PUSH
4818: EMPTY
4819: PUSH
4820: EMPTY
4821: LIST
4822: LIST
4823: PPUSH
4824: CALL_OW 1
4828: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
4829: LD_ADDR_EXP 62
4833: PUSH
4834: LD_EXP 62
4838: PPUSH
4839: LD_VAR 0 2
4843: PPUSH
4844: EMPTY
4845: PPUSH
4846: CALL_OW 1
4850: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
4851: LD_ADDR_EXP 89
4855: PUSH
4856: LD_EXP 89
4860: PPUSH
4861: LD_VAR 0 2
4865: PPUSH
4866: EMPTY
4867: PPUSH
4868: CALL_OW 1
4872: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
4873: LD_ADDR_EXP 63
4877: PUSH
4878: LD_EXP 63
4882: PPUSH
4883: LD_VAR 0 2
4887: PPUSH
4888: EMPTY
4889: PPUSH
4890: CALL_OW 1
4894: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
4895: LD_ADDR_EXP 64
4899: PUSH
4900: LD_EXP 64
4904: PPUSH
4905: LD_VAR 0 2
4909: PPUSH
4910: EMPTY
4911: PPUSH
4912: CALL_OW 1
4916: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
4917: LD_ADDR_EXP 65
4921: PUSH
4922: LD_EXP 65
4926: PPUSH
4927: LD_VAR 0 2
4931: PPUSH
4932: LD_EXP 57
4936: PUSH
4937: LD_VAR 0 2
4941: ARRAY
4942: PPUSH
4943: LD_INT 2
4945: PUSH
4946: LD_INT 30
4948: PUSH
4949: LD_INT 32
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PUSH
4956: LD_INT 30
4958: PUSH
4959: LD_INT 33
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: LIST
4970: PPUSH
4971: CALL_OW 72
4975: PPUSH
4976: CALL_OW 1
4980: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
4981: LD_ADDR_EXP 66
4985: PUSH
4986: LD_EXP 66
4990: PPUSH
4991: LD_VAR 0 2
4995: PPUSH
4996: LD_EXP 57
5000: PUSH
5001: LD_VAR 0 2
5005: ARRAY
5006: PPUSH
5007: LD_INT 2
5009: PUSH
5010: LD_INT 30
5012: PUSH
5013: LD_INT 32
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 30
5022: PUSH
5023: LD_INT 31
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: PUSH
5035: LD_INT 58
5037: PUSH
5038: EMPTY
5039: LIST
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: PPUSH
5045: CALL_OW 72
5049: PPUSH
5050: CALL_OW 1
5054: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
5055: LD_ADDR_EXP 67
5059: PUSH
5060: LD_EXP 67
5064: PPUSH
5065: LD_VAR 0 2
5069: PPUSH
5070: EMPTY
5071: PPUSH
5072: CALL_OW 1
5076: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
5077: LD_ADDR_EXP 71
5081: PUSH
5082: LD_EXP 71
5086: PPUSH
5087: LD_VAR 0 2
5091: PPUSH
5092: EMPTY
5093: PPUSH
5094: CALL_OW 1
5098: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
5099: LD_ADDR_EXP 70
5103: PUSH
5104: LD_EXP 70
5108: PPUSH
5109: LD_VAR 0 2
5113: PPUSH
5114: EMPTY
5115: PPUSH
5116: CALL_OW 1
5120: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
5121: LD_ADDR_EXP 72
5125: PUSH
5126: LD_EXP 72
5130: PPUSH
5131: LD_VAR 0 2
5135: PPUSH
5136: EMPTY
5137: PPUSH
5138: CALL_OW 1
5142: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
5143: LD_ADDR_EXP 73
5147: PUSH
5148: LD_EXP 73
5152: PPUSH
5153: LD_VAR 0 2
5157: PPUSH
5158: EMPTY
5159: PPUSH
5160: CALL_OW 1
5164: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
5165: LD_ADDR_EXP 74
5169: PUSH
5170: LD_EXP 74
5174: PPUSH
5175: LD_VAR 0 2
5179: PPUSH
5180: EMPTY
5181: PPUSH
5182: CALL_OW 1
5186: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
5187: LD_ADDR_EXP 75
5191: PUSH
5192: LD_EXP 75
5196: PPUSH
5197: LD_VAR 0 2
5201: PPUSH
5202: EMPTY
5203: PPUSH
5204: CALL_OW 1
5208: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
5209: LD_ADDR_EXP 76
5213: PUSH
5214: LD_EXP 76
5218: PPUSH
5219: LD_VAR 0 2
5223: PPUSH
5224: EMPTY
5225: PPUSH
5226: CALL_OW 1
5230: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
5231: LD_ADDR_EXP 77
5235: PUSH
5236: LD_EXP 77
5240: PPUSH
5241: LD_VAR 0 2
5245: PPUSH
5246: EMPTY
5247: PPUSH
5248: CALL_OW 1
5252: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
5253: LD_ADDR_EXP 78
5257: PUSH
5258: LD_EXP 78
5262: PPUSH
5263: LD_VAR 0 2
5267: PPUSH
5268: EMPTY
5269: PPUSH
5270: CALL_OW 1
5274: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
5275: LD_ADDR_EXP 79
5279: PUSH
5280: LD_EXP 79
5284: PPUSH
5285: LD_VAR 0 2
5289: PPUSH
5290: EMPTY
5291: PPUSH
5292: CALL_OW 1
5296: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
5297: LD_ADDR_EXP 68
5301: PUSH
5302: LD_EXP 68
5306: PPUSH
5307: LD_VAR 0 2
5311: PPUSH
5312: LD_INT 0
5314: PPUSH
5315: CALL_OW 1
5319: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
5320: LD_ADDR_EXP 81
5324: PUSH
5325: LD_EXP 81
5329: PPUSH
5330: LD_VAR 0 2
5334: PPUSH
5335: LD_INT 0
5337: PPUSH
5338: CALL_OW 1
5342: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
5343: LD_ADDR_EXP 69
5347: PUSH
5348: LD_EXP 69
5352: PPUSH
5353: LD_VAR 0 2
5357: PPUSH
5358: EMPTY
5359: PPUSH
5360: CALL_OW 1
5364: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
5365: LD_ADDR_EXP 80
5369: PUSH
5370: LD_EXP 80
5374: PPUSH
5375: LD_VAR 0 2
5379: PPUSH
5380: LD_INT 0
5382: PPUSH
5383: CALL_OW 1
5387: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
5388: LD_ADDR_EXP 82
5392: PUSH
5393: LD_EXP 82
5397: PPUSH
5398: LD_VAR 0 2
5402: PPUSH
5403: EMPTY
5404: PPUSH
5405: CALL_OW 1
5409: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
5410: LD_ADDR_EXP 85
5414: PUSH
5415: LD_EXP 85
5419: PPUSH
5420: LD_VAR 0 2
5424: PPUSH
5425: LD_INT 0
5427: PPUSH
5428: CALL_OW 1
5432: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
5433: LD_ADDR_EXP 86
5437: PUSH
5438: LD_EXP 86
5442: PPUSH
5443: LD_VAR 0 2
5447: PPUSH
5448: EMPTY
5449: PPUSH
5450: CALL_OW 1
5454: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
5455: LD_ADDR_EXP 87
5459: PUSH
5460: LD_EXP 87
5464: PPUSH
5465: LD_VAR 0 2
5469: PPUSH
5470: EMPTY
5471: PPUSH
5472: CALL_OW 1
5476: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
5477: LD_ADDR_EXP 88
5481: PUSH
5482: LD_EXP 88
5486: PPUSH
5487: LD_VAR 0 2
5491: PPUSH
5492: EMPTY
5493: PPUSH
5494: CALL_OW 1
5498: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
5499: LD_ADDR_EXP 90
5503: PUSH
5504: LD_EXP 90
5508: PPUSH
5509: LD_VAR 0 2
5513: PPUSH
5514: LD_EXP 57
5518: PUSH
5519: LD_VAR 0 2
5523: ARRAY
5524: PPUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 30
5530: PUSH
5531: LD_INT 6
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 30
5540: PUSH
5541: LD_INT 7
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: LD_INT 30
5550: PUSH
5551: LD_INT 8
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PUSH
5558: EMPTY
5559: LIST
5560: LIST
5561: LIST
5562: LIST
5563: PPUSH
5564: CALL_OW 72
5568: PPUSH
5569: CALL_OW 1
5573: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
5574: LD_ADDR_EXP 91
5578: PUSH
5579: LD_EXP 91
5583: PPUSH
5584: LD_VAR 0 2
5588: PPUSH
5589: EMPTY
5590: PPUSH
5591: CALL_OW 1
5595: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
5596: LD_ADDR_EXP 92
5600: PUSH
5601: LD_EXP 92
5605: PPUSH
5606: LD_VAR 0 2
5610: PPUSH
5611: EMPTY
5612: PPUSH
5613: CALL_OW 1
5617: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
5618: LD_ADDR_EXP 93
5622: PUSH
5623: LD_EXP 93
5627: PPUSH
5628: LD_VAR 0 2
5632: PPUSH
5633: EMPTY
5634: PPUSH
5635: CALL_OW 1
5639: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
5640: LD_ADDR_EXP 94
5644: PUSH
5645: LD_EXP 94
5649: PPUSH
5650: LD_VAR 0 2
5654: PPUSH
5655: EMPTY
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
5662: LD_ADDR_EXP 95
5666: PUSH
5667: LD_EXP 95
5671: PPUSH
5672: LD_VAR 0 2
5676: PPUSH
5677: EMPTY
5678: PPUSH
5679: CALL_OW 1
5683: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
5684: LD_ADDR_EXP 96
5688: PUSH
5689: LD_EXP 96
5693: PPUSH
5694: LD_VAR 0 2
5698: PPUSH
5699: EMPTY
5700: PPUSH
5701: CALL_OW 1
5705: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
5706: LD_ADDR_EXP 97
5710: PUSH
5711: LD_EXP 97
5715: PPUSH
5716: LD_VAR 0 2
5720: PPUSH
5721: EMPTY
5722: PPUSH
5723: CALL_OW 1
5727: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
5728: LD_ADDR_EXP 98
5732: PUSH
5733: LD_EXP 98
5737: PPUSH
5738: LD_VAR 0 2
5742: PPUSH
5743: EMPTY
5744: PPUSH
5745: CALL_OW 1
5749: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
5750: LD_ADDR_EXP 99
5754: PUSH
5755: LD_EXP 99
5759: PPUSH
5760: LD_VAR 0 2
5764: PPUSH
5765: LD_INT 0
5767: PPUSH
5768: CALL_OW 1
5772: ST_TO_ADDR
// end ;
5773: GO 4697
5775: POP
5776: POP
// MC_InitSides ( ) ;
5777: CALL 6063 0 0
// MC_InitResearch ( ) ;
5781: CALL 5802 0 0
// CustomInitMacro ( ) ;
5785: CALL 199 0 0
// skirmish := true ;
5789: LD_ADDR_EXP 55
5793: PUSH
5794: LD_INT 1
5796: ST_TO_ADDR
// end ;
5797: LD_VAR 0 1
5801: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
5802: LD_INT 0
5804: PPUSH
5805: PPUSH
5806: PPUSH
5807: PPUSH
5808: PPUSH
5809: PPUSH
// if not mc_bases then
5810: LD_EXP 57
5814: NOT
5815: IFFALSE 5819
// exit ;
5817: GO 6058
// for i = 1 to 8 do
5819: LD_ADDR_VAR 0 2
5823: PUSH
5824: DOUBLE
5825: LD_INT 1
5827: DEC
5828: ST_TO_ADDR
5829: LD_INT 8
5831: PUSH
5832: FOR_TO
5833: IFFALSE 5859
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
5835: LD_ADDR_EXP 84
5839: PUSH
5840: LD_EXP 84
5844: PPUSH
5845: LD_VAR 0 2
5849: PPUSH
5850: EMPTY
5851: PPUSH
5852: CALL_OW 1
5856: ST_TO_ADDR
5857: GO 5832
5859: POP
5860: POP
// tmp := [ ] ;
5861: LD_ADDR_VAR 0 5
5865: PUSH
5866: EMPTY
5867: ST_TO_ADDR
// for i = 1 to mc_sides do
5868: LD_ADDR_VAR 0 2
5872: PUSH
5873: DOUBLE
5874: LD_INT 1
5876: DEC
5877: ST_TO_ADDR
5878: LD_EXP 83
5882: PUSH
5883: FOR_TO
5884: IFFALSE 5942
// if not mc_sides [ i ] in tmp then
5886: LD_EXP 83
5890: PUSH
5891: LD_VAR 0 2
5895: ARRAY
5896: PUSH
5897: LD_VAR 0 5
5901: IN
5902: NOT
5903: IFFALSE 5940
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
5905: LD_ADDR_VAR 0 5
5909: PUSH
5910: LD_VAR 0 5
5914: PPUSH
5915: LD_VAR 0 5
5919: PUSH
5920: LD_INT 1
5922: PLUS
5923: PPUSH
5924: LD_EXP 83
5928: PUSH
5929: LD_VAR 0 2
5933: ARRAY
5934: PPUSH
5935: CALL_OW 2
5939: ST_TO_ADDR
5940: GO 5883
5942: POP
5943: POP
// if not tmp then
5944: LD_VAR 0 5
5948: NOT
5949: IFFALSE 5953
// exit ;
5951: GO 6058
// for j in tmp do
5953: LD_ADDR_VAR 0 3
5957: PUSH
5958: LD_VAR 0 5
5962: PUSH
5963: FOR_IN
5964: IFFALSE 6056
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
5966: LD_ADDR_VAR 0 6
5970: PUSH
5971: LD_INT 22
5973: PUSH
5974: LD_VAR 0 3
5978: PUSH
5979: EMPTY
5980: LIST
5981: LIST
5982: PPUSH
5983: CALL_OW 69
5987: ST_TO_ADDR
// if not un then
5988: LD_VAR 0 6
5992: NOT
5993: IFFALSE 5997
// continue ;
5995: GO 5963
// nation := GetNation ( un [ 1 ] ) ;
5997: LD_ADDR_VAR 0 4
6001: PUSH
6002: LD_VAR 0 6
6006: PUSH
6007: LD_INT 1
6009: ARRAY
6010: PPUSH
6011: CALL_OW 248
6015: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
6016: LD_ADDR_EXP 84
6020: PUSH
6021: LD_EXP 84
6025: PPUSH
6026: LD_VAR 0 3
6030: PPUSH
6031: LD_VAR 0 3
6035: PPUSH
6036: LD_VAR 0 4
6040: PPUSH
6041: LD_INT 1
6043: PPUSH
6044: CALL 31190 0 3
6048: PPUSH
6049: CALL_OW 1
6053: ST_TO_ADDR
// end ;
6054: GO 5963
6056: POP
6057: POP
// end ;
6058: LD_VAR 0 1
6062: RET
// export function MC_InitSides ( ) ; var i ; begin
6063: LD_INT 0
6065: PPUSH
6066: PPUSH
// if not mc_bases then
6067: LD_EXP 57
6071: NOT
6072: IFFALSE 6076
// exit ;
6074: GO 6150
// for i = 1 to mc_bases do
6076: LD_ADDR_VAR 0 2
6080: PUSH
6081: DOUBLE
6082: LD_INT 1
6084: DEC
6085: ST_TO_ADDR
6086: LD_EXP 57
6090: PUSH
6091: FOR_TO
6092: IFFALSE 6148
// if mc_bases [ i ] then
6094: LD_EXP 57
6098: PUSH
6099: LD_VAR 0 2
6103: ARRAY
6104: IFFALSE 6146
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
6106: LD_ADDR_EXP 83
6110: PUSH
6111: LD_EXP 83
6115: PPUSH
6116: LD_VAR 0 2
6120: PPUSH
6121: LD_EXP 57
6125: PUSH
6126: LD_VAR 0 2
6130: ARRAY
6131: PUSH
6132: LD_INT 1
6134: ARRAY
6135: PPUSH
6136: CALL_OW 255
6140: PPUSH
6141: CALL_OW 1
6145: ST_TO_ADDR
6146: GO 6091
6148: POP
6149: POP
// end ;
6150: LD_VAR 0 1
6154: RET
// every 0 0$01 trigger skirmish do
6155: LD_EXP 55
6159: IFFALSE 6313
6161: GO 6163
6163: DISABLE
// begin enable ;
6164: ENABLE
// MC_CheckBuildings ( ) ;
6165: CALL 10460 0 0
// MC_CheckPeopleLife ( ) ;
6169: CALL 10585 0 0
// RaiseSailEvent ( 100 ) ;
6173: LD_INT 100
6175: PPUSH
6176: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
6180: LD_INT 103
6182: PPUSH
6183: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
6187: LD_INT 104
6189: PPUSH
6190: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
6194: LD_INT 105
6196: PPUSH
6197: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
6201: LD_INT 106
6203: PPUSH
6204: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
6208: LD_INT 107
6210: PPUSH
6211: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
6215: LD_INT 108
6217: PPUSH
6218: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
6222: LD_INT 109
6224: PPUSH
6225: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
6229: LD_INT 110
6231: PPUSH
6232: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
6236: LD_INT 111
6238: PPUSH
6239: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
6243: LD_INT 112
6245: PPUSH
6246: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
6250: LD_INT 113
6252: PPUSH
6253: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
6257: LD_INT 120
6259: PPUSH
6260: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
6264: LD_INT 121
6266: PPUSH
6267: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
6271: LD_INT 122
6273: PPUSH
6274: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
6278: LD_INT 123
6280: PPUSH
6281: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
6285: LD_INT 124
6287: PPUSH
6288: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
6292: LD_INT 125
6294: PPUSH
6295: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
6299: LD_INT 126
6301: PPUSH
6302: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
6306: LD_INT 200
6308: PPUSH
6309: CALL_OW 427
// end ;
6313: END
// on SailEvent ( event ) do begin if event = 100 then
6314: LD_VAR 0 1
6318: PUSH
6319: LD_INT 100
6321: EQUAL
6322: IFFALSE 6328
// MC_ClassManager ( ) ;
6324: CALL 6720 0 0
// if event = 101 then
6328: LD_VAR 0 1
6332: PUSH
6333: LD_INT 101
6335: EQUAL
6336: IFFALSE 6342
// MC_RepairBuildings ( ) ;
6338: CALL 11181 0 0
// if event = 102 then
6342: LD_VAR 0 1
6346: PUSH
6347: LD_INT 102
6349: EQUAL
6350: IFFALSE 6356
// MC_Heal ( ) ;
6352: CALL 11587 0 0
// if event = 103 then
6356: LD_VAR 0 1
6360: PUSH
6361: LD_INT 103
6363: EQUAL
6364: IFFALSE 6370
// MC_Build ( ) ;
6366: CALL 12009 0 0
// if event = 104 then
6370: LD_VAR 0 1
6374: PUSH
6375: LD_INT 104
6377: EQUAL
6378: IFFALSE 6384
// MC_TurretWeapon ( ) ;
6380: CALL 13622 0 0
// if event = 105 then
6384: LD_VAR 0 1
6388: PUSH
6389: LD_INT 105
6391: EQUAL
6392: IFFALSE 6398
// MC_BuildUpgrade ( ) ;
6394: CALL 13173 0 0
// if event = 106 then
6398: LD_VAR 0 1
6402: PUSH
6403: LD_INT 106
6405: EQUAL
6406: IFFALSE 6412
// MC_PlantMines ( ) ;
6408: CALL 14052 0 0
// if event = 107 then
6412: LD_VAR 0 1
6416: PUSH
6417: LD_INT 107
6419: EQUAL
6420: IFFALSE 6426
// MC_CollectCrates ( ) ;
6422: CALL 15086 0 0
// if event = 108 then
6426: LD_VAR 0 1
6430: PUSH
6431: LD_INT 108
6433: EQUAL
6434: IFFALSE 6440
// MC_LinkRemoteControl ( ) ;
6436: CALL 16843 0 0
// if event = 109 then
6440: LD_VAR 0 1
6444: PUSH
6445: LD_INT 109
6447: EQUAL
6448: IFFALSE 6454
// MC_ProduceVehicle ( ) ;
6450: CALL 17024 0 0
// if event = 110 then
6454: LD_VAR 0 1
6458: PUSH
6459: LD_INT 110
6461: EQUAL
6462: IFFALSE 6468
// MC_SendAttack ( ) ;
6464: CALL 17505 0 0
// if event = 111 then
6468: LD_VAR 0 1
6472: PUSH
6473: LD_INT 111
6475: EQUAL
6476: IFFALSE 6482
// MC_Defend ( ) ;
6478: CALL 17613 0 0
// if event = 112 then
6482: LD_VAR 0 1
6486: PUSH
6487: LD_INT 112
6489: EQUAL
6490: IFFALSE 6496
// MC_Research ( ) ;
6492: CALL 18240 0 0
// if event = 113 then
6496: LD_VAR 0 1
6500: PUSH
6501: LD_INT 113
6503: EQUAL
6504: IFFALSE 6510
// MC_MinesTrigger ( ) ;
6506: CALL 19354 0 0
// if event = 120 then
6510: LD_VAR 0 1
6514: PUSH
6515: LD_INT 120
6517: EQUAL
6518: IFFALSE 6524
// MC_RepairVehicle ( ) ;
6520: CALL 19453 0 0
// if event = 121 then
6524: LD_VAR 0 1
6528: PUSH
6529: LD_INT 121
6531: EQUAL
6532: IFFALSE 6538
// MC_TameApe ( ) ;
6534: CALL 20196 0 0
// if event = 122 then
6538: LD_VAR 0 1
6542: PUSH
6543: LD_INT 122
6545: EQUAL
6546: IFFALSE 6552
// MC_ChangeApeClass ( ) ;
6548: CALL 21025 0 0
// if event = 123 then
6552: LD_VAR 0 1
6556: PUSH
6557: LD_INT 123
6559: EQUAL
6560: IFFALSE 6566
// MC_Bazooka ( ) ;
6562: CALL 21675 0 0
// if event = 124 then
6566: LD_VAR 0 1
6570: PUSH
6571: LD_INT 124
6573: EQUAL
6574: IFFALSE 6580
// MC_TeleportExit ( ) ;
6576: CALL 21873 0 0
// if event = 125 then
6580: LD_VAR 0 1
6584: PUSH
6585: LD_INT 125
6587: EQUAL
6588: IFFALSE 6594
// MC_Deposits ( ) ;
6590: CALL 22520 0 0
// if event = 126 then
6594: LD_VAR 0 1
6598: PUSH
6599: LD_INT 126
6601: EQUAL
6602: IFFALSE 6608
// MC_RemoteDriver ( ) ;
6604: CALL 23145 0 0
// if event = 200 then
6608: LD_VAR 0 1
6612: PUSH
6613: LD_INT 200
6615: EQUAL
6616: IFFALSE 6622
// MC_Idle ( ) ;
6618: CALL 24878 0 0
// end ;
6622: PPOPN 1
6624: END
// export function MC_Reset ( base , tag ) ; var i ; begin
6625: LD_INT 0
6627: PPUSH
6628: PPUSH
// if not mc_bases [ base ] or not tag then
6629: LD_EXP 57
6633: PUSH
6634: LD_VAR 0 1
6638: ARRAY
6639: NOT
6640: PUSH
6641: LD_VAR 0 2
6645: NOT
6646: OR
6647: IFFALSE 6651
// exit ;
6649: GO 6715
// for i in mc_bases [ base ] union mc_ape [ base ] do
6651: LD_ADDR_VAR 0 4
6655: PUSH
6656: LD_EXP 57
6660: PUSH
6661: LD_VAR 0 1
6665: ARRAY
6666: PUSH
6667: LD_EXP 86
6671: PUSH
6672: LD_VAR 0 1
6676: ARRAY
6677: UNION
6678: PUSH
6679: FOR_IN
6680: IFFALSE 6713
// if GetTag ( i ) = tag then
6682: LD_VAR 0 4
6686: PPUSH
6687: CALL_OW 110
6691: PUSH
6692: LD_VAR 0 2
6696: EQUAL
6697: IFFALSE 6711
// SetTag ( i , 0 ) ;
6699: LD_VAR 0 4
6703: PPUSH
6704: LD_INT 0
6706: PPUSH
6707: CALL_OW 109
6711: GO 6679
6713: POP
6714: POP
// end ;
6715: LD_VAR 0 3
6719: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
6720: LD_INT 0
6722: PPUSH
6723: PPUSH
6724: PPUSH
6725: PPUSH
6726: PPUSH
6727: PPUSH
6728: PPUSH
6729: PPUSH
// if not mc_bases then
6730: LD_EXP 57
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 7197
// for i = 1 to mc_bases do
6739: LD_ADDR_VAR 0 2
6743: PUSH
6744: DOUBLE
6745: LD_INT 1
6747: DEC
6748: ST_TO_ADDR
6749: LD_EXP 57
6753: PUSH
6754: FOR_TO
6755: IFFALSE 7195
// begin tmp := MC_ClassCheckReq ( i ) ;
6757: LD_ADDR_VAR 0 4
6761: PUSH
6762: LD_VAR 0 2
6766: PPUSH
6767: CALL 7202 0 1
6771: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
6772: LD_ADDR_EXP 98
6776: PUSH
6777: LD_EXP 98
6781: PPUSH
6782: LD_VAR 0 2
6786: PPUSH
6787: LD_VAR 0 4
6791: PPUSH
6792: CALL_OW 1
6796: ST_TO_ADDR
// if not tmp then
6797: LD_VAR 0 4
6801: NOT
6802: IFFALSE 6806
// continue ;
6804: GO 6754
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
6806: LD_ADDR_VAR 0 6
6810: PUSH
6811: LD_EXP 57
6815: PUSH
6816: LD_VAR 0 2
6820: ARRAY
6821: PPUSH
6822: LD_INT 2
6824: PUSH
6825: LD_INT 30
6827: PUSH
6828: LD_INT 4
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 30
6837: PUSH
6838: LD_INT 5
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: PPUSH
6850: CALL_OW 72
6854: PUSH
6855: LD_EXP 57
6859: PUSH
6860: LD_VAR 0 2
6864: ARRAY
6865: PPUSH
6866: LD_INT 2
6868: PUSH
6869: LD_INT 30
6871: PUSH
6872: LD_INT 0
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PUSH
6879: LD_INT 30
6881: PUSH
6882: LD_INT 1
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 72
6898: PUSH
6899: LD_EXP 57
6903: PUSH
6904: LD_VAR 0 2
6908: ARRAY
6909: PPUSH
6910: LD_INT 30
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 72
6924: PUSH
6925: LD_EXP 57
6929: PUSH
6930: LD_VAR 0 2
6934: ARRAY
6935: PPUSH
6936: LD_INT 2
6938: PUSH
6939: LD_INT 30
6941: PUSH
6942: LD_INT 6
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PUSH
6949: LD_INT 30
6951: PUSH
6952: LD_INT 7
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PUSH
6959: LD_INT 30
6961: PUSH
6962: LD_INT 8
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: PUSH
6969: EMPTY
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: PPUSH
6975: CALL_OW 72
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: LIST
6985: ST_TO_ADDR
// for j = 1 to 4 do
6986: LD_ADDR_VAR 0 3
6990: PUSH
6991: DOUBLE
6992: LD_INT 1
6994: DEC
6995: ST_TO_ADDR
6996: LD_INT 4
6998: PUSH
6999: FOR_TO
7000: IFFALSE 7191
// begin if not tmp [ j ] then
7002: LD_VAR 0 4
7006: PUSH
7007: LD_VAR 0 3
7011: ARRAY
7012: NOT
7013: IFFALSE 7017
// continue ;
7015: GO 6999
// for p in tmp [ j ] do
7017: LD_ADDR_VAR 0 5
7021: PUSH
7022: LD_VAR 0 4
7026: PUSH
7027: LD_VAR 0 3
7031: ARRAY
7032: PUSH
7033: FOR_IN
7034: IFFALSE 7187
// begin if not b [ j ] then
7036: LD_VAR 0 6
7040: PUSH
7041: LD_VAR 0 3
7045: ARRAY
7046: NOT
7047: IFFALSE 7051
// break ;
7049: GO 7187
// e := 0 ;
7051: LD_ADDR_VAR 0 7
7055: PUSH
7056: LD_INT 0
7058: ST_TO_ADDR
// for k in b [ j ] do
7059: LD_ADDR_VAR 0 8
7063: PUSH
7064: LD_VAR 0 6
7068: PUSH
7069: LD_VAR 0 3
7073: ARRAY
7074: PUSH
7075: FOR_IN
7076: IFFALSE 7103
// if IsNotFull ( k ) then
7078: LD_VAR 0 8
7082: PPUSH
7083: CALL 35216 0 1
7087: IFFALSE 7101
// begin e := k ;
7089: LD_ADDR_VAR 0 7
7093: PUSH
7094: LD_VAR 0 8
7098: ST_TO_ADDR
// break ;
7099: GO 7103
// end ;
7101: GO 7075
7103: POP
7104: POP
// if e and not UnitGoingToBuilding ( p , e ) then
7105: LD_VAR 0 7
7109: PUSH
7110: LD_VAR 0 5
7114: PPUSH
7115: LD_VAR 0 7
7119: PPUSH
7120: CALL 72204 0 2
7124: NOT
7125: AND
7126: IFFALSE 7185
// begin if IsInUnit ( p ) then
7128: LD_VAR 0 5
7132: PPUSH
7133: CALL_OW 310
7137: IFFALSE 7148
// ComExitBuilding ( p ) ;
7139: LD_VAR 0 5
7143: PPUSH
7144: CALL_OW 122
// ComEnterUnit ( p , e ) ;
7148: LD_VAR 0 5
7152: PPUSH
7153: LD_VAR 0 7
7157: PPUSH
7158: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
7162: LD_VAR 0 5
7166: PPUSH
7167: LD_VAR 0 3
7171: PPUSH
7172: CALL_OW 183
// AddComExitBuilding ( p ) ;
7176: LD_VAR 0 5
7180: PPUSH
7181: CALL_OW 182
// end ; end ;
7185: GO 7033
7187: POP
7188: POP
// end ;
7189: GO 6999
7191: POP
7192: POP
// end ;
7193: GO 6754
7195: POP
7196: POP
// end ;
7197: LD_VAR 0 1
7201: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
7202: LD_INT 0
7204: PPUSH
7205: PPUSH
7206: PPUSH
7207: PPUSH
7208: PPUSH
7209: PPUSH
7210: PPUSH
7211: PPUSH
7212: PPUSH
7213: PPUSH
7214: PPUSH
7215: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
7216: LD_VAR 0 1
7220: NOT
7221: PUSH
7222: LD_EXP 57
7226: PUSH
7227: LD_VAR 0 1
7231: ARRAY
7232: NOT
7233: OR
7234: PUSH
7235: LD_EXP 57
7239: PUSH
7240: LD_VAR 0 1
7244: ARRAY
7245: PPUSH
7246: LD_INT 2
7248: PUSH
7249: LD_INT 30
7251: PUSH
7252: LD_INT 0
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: LD_INT 30
7261: PUSH
7262: LD_INT 1
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: LIST
7273: PPUSH
7274: CALL_OW 72
7278: NOT
7279: OR
7280: IFFALSE 7284
// exit ;
7282: GO 10455
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
7284: LD_ADDR_VAR 0 4
7288: PUSH
7289: LD_EXP 57
7293: PUSH
7294: LD_VAR 0 1
7298: ARRAY
7299: PPUSH
7300: LD_INT 2
7302: PUSH
7303: LD_INT 25
7305: PUSH
7306: LD_INT 1
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: PUSH
7313: LD_INT 25
7315: PUSH
7316: LD_INT 2
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 25
7325: PUSH
7326: LD_INT 3
7328: PUSH
7329: EMPTY
7330: LIST
7331: LIST
7332: PUSH
7333: LD_INT 25
7335: PUSH
7336: LD_INT 4
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PUSH
7343: LD_INT 25
7345: PUSH
7346: LD_INT 5
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: PUSH
7353: LD_INT 25
7355: PUSH
7356: LD_INT 8
7358: PUSH
7359: EMPTY
7360: LIST
7361: LIST
7362: PUSH
7363: LD_INT 25
7365: PUSH
7366: LD_INT 9
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: LIST
7378: LIST
7379: LIST
7380: LIST
7381: LIST
7382: PPUSH
7383: CALL_OW 72
7387: ST_TO_ADDR
// for i in tmp do
7388: LD_ADDR_VAR 0 3
7392: PUSH
7393: LD_VAR 0 4
7397: PUSH
7398: FOR_IN
7399: IFFALSE 7430
// if GetTag ( i ) then
7401: LD_VAR 0 3
7405: PPUSH
7406: CALL_OW 110
7410: IFFALSE 7428
// tmp := tmp diff i ;
7412: LD_ADDR_VAR 0 4
7416: PUSH
7417: LD_VAR 0 4
7421: PUSH
7422: LD_VAR 0 3
7426: DIFF
7427: ST_TO_ADDR
7428: GO 7398
7430: POP
7431: POP
// if not tmp then
7432: LD_VAR 0 4
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 10455
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
7441: LD_ADDR_VAR 0 5
7445: PUSH
7446: LD_EXP 57
7450: PUSH
7451: LD_VAR 0 1
7455: ARRAY
7456: PPUSH
7457: LD_INT 2
7459: PUSH
7460: LD_INT 25
7462: PUSH
7463: LD_INT 1
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: LD_INT 25
7472: PUSH
7473: LD_INT 5
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 25
7482: PUSH
7483: LD_INT 8
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 25
7492: PUSH
7493: LD_INT 9
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PPUSH
7507: CALL_OW 72
7511: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
7512: LD_ADDR_VAR 0 6
7516: PUSH
7517: LD_EXP 57
7521: PUSH
7522: LD_VAR 0 1
7526: ARRAY
7527: PPUSH
7528: LD_INT 25
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: PPUSH
7538: CALL_OW 72
7542: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
7543: LD_ADDR_VAR 0 7
7547: PUSH
7548: LD_EXP 57
7552: PUSH
7553: LD_VAR 0 1
7557: ARRAY
7558: PPUSH
7559: LD_INT 25
7561: PUSH
7562: LD_INT 3
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL_OW 72
7573: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
7574: LD_ADDR_VAR 0 8
7578: PUSH
7579: LD_EXP 57
7583: PUSH
7584: LD_VAR 0 1
7588: ARRAY
7589: PPUSH
7590: LD_INT 25
7592: PUSH
7593: LD_INT 4
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PUSH
7600: LD_INT 24
7602: PUSH
7603: LD_INT 251
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PPUSH
7614: CALL_OW 72
7618: ST_TO_ADDR
// if mc_scan [ base ] then
7619: LD_EXP 80
7623: PUSH
7624: LD_VAR 0 1
7628: ARRAY
7629: IFFALSE 8090
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
7631: LD_ADDR_EXP 99
7635: PUSH
7636: LD_EXP 99
7640: PPUSH
7641: LD_VAR 0 1
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL_OW 1
7653: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
7654: LD_ADDR_VAR 0 12
7658: PUSH
7659: LD_EXP 57
7663: PUSH
7664: LD_VAR 0 1
7668: ARRAY
7669: PPUSH
7670: LD_INT 2
7672: PUSH
7673: LD_INT 30
7675: PUSH
7676: LD_INT 4
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 30
7685: PUSH
7686: LD_INT 5
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: LIST
7697: PPUSH
7698: CALL_OW 72
7702: ST_TO_ADDR
// if not b then
7703: LD_VAR 0 12
7707: NOT
7708: IFFALSE 7712
// exit ;
7710: GO 10455
// p := [ ] ;
7712: LD_ADDR_VAR 0 11
7716: PUSH
7717: EMPTY
7718: ST_TO_ADDR
// if sci >= 2 then
7719: LD_VAR 0 8
7723: PUSH
7724: LD_INT 2
7726: GREATEREQUAL
7727: IFFALSE 7758
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
7729: LD_ADDR_VAR 0 8
7733: PUSH
7734: LD_VAR 0 8
7738: PUSH
7739: LD_INT 1
7741: ARRAY
7742: PUSH
7743: LD_VAR 0 8
7747: PUSH
7748: LD_INT 2
7750: ARRAY
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: ST_TO_ADDR
7756: GO 7819
// if sci = 1 then
7758: LD_VAR 0 8
7762: PUSH
7763: LD_INT 1
7765: EQUAL
7766: IFFALSE 7787
// sci := [ sci [ 1 ] ] else
7768: LD_ADDR_VAR 0 8
7772: PUSH
7773: LD_VAR 0 8
7777: PUSH
7778: LD_INT 1
7780: ARRAY
7781: PUSH
7782: EMPTY
7783: LIST
7784: ST_TO_ADDR
7785: GO 7819
// if sci = 0 then
7787: LD_VAR 0 8
7791: PUSH
7792: LD_INT 0
7794: EQUAL
7795: IFFALSE 7819
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
7797: LD_ADDR_VAR 0 11
7801: PUSH
7802: LD_VAR 0 4
7806: PPUSH
7807: LD_INT 4
7809: PPUSH
7810: CALL 72067 0 2
7814: PUSH
7815: LD_INT 1
7817: ARRAY
7818: ST_TO_ADDR
// if eng > 4 then
7819: LD_VAR 0 6
7823: PUSH
7824: LD_INT 4
7826: GREATER
7827: IFFALSE 7873
// for i = eng downto 4 do
7829: LD_ADDR_VAR 0 3
7833: PUSH
7834: DOUBLE
7835: LD_VAR 0 6
7839: INC
7840: ST_TO_ADDR
7841: LD_INT 4
7843: PUSH
7844: FOR_DOWNTO
7845: IFFALSE 7871
// eng := eng diff eng [ i ] ;
7847: LD_ADDR_VAR 0 6
7851: PUSH
7852: LD_VAR 0 6
7856: PUSH
7857: LD_VAR 0 6
7861: PUSH
7862: LD_VAR 0 3
7866: ARRAY
7867: DIFF
7868: ST_TO_ADDR
7869: GO 7844
7871: POP
7872: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
7873: LD_ADDR_VAR 0 4
7877: PUSH
7878: LD_VAR 0 4
7882: PUSH
7883: LD_VAR 0 5
7887: PUSH
7888: LD_VAR 0 6
7892: UNION
7893: PUSH
7894: LD_VAR 0 7
7898: UNION
7899: PUSH
7900: LD_VAR 0 8
7904: UNION
7905: DIFF
7906: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
7907: LD_ADDR_VAR 0 13
7911: PUSH
7912: LD_EXP 57
7916: PUSH
7917: LD_VAR 0 1
7921: ARRAY
7922: PPUSH
7923: LD_INT 2
7925: PUSH
7926: LD_INT 30
7928: PUSH
7929: LD_INT 32
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: LD_INT 30
7938: PUSH
7939: LD_INT 31
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: LIST
7950: PPUSH
7951: CALL_OW 72
7955: PUSH
7956: LD_EXP 57
7960: PUSH
7961: LD_VAR 0 1
7965: ARRAY
7966: PPUSH
7967: LD_INT 2
7969: PUSH
7970: LD_INT 30
7972: PUSH
7973: LD_INT 4
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PUSH
7980: LD_INT 30
7982: PUSH
7983: LD_INT 5
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: PPUSH
7995: CALL_OW 72
7999: PUSH
8000: LD_INT 6
8002: MUL
8003: PLUS
8004: ST_TO_ADDR
// if bcount < tmp then
8005: LD_VAR 0 13
8009: PUSH
8010: LD_VAR 0 4
8014: LESS
8015: IFFALSE 8061
// for i = tmp downto bcount do
8017: LD_ADDR_VAR 0 3
8021: PUSH
8022: DOUBLE
8023: LD_VAR 0 4
8027: INC
8028: ST_TO_ADDR
8029: LD_VAR 0 13
8033: PUSH
8034: FOR_DOWNTO
8035: IFFALSE 8059
// tmp := Delete ( tmp , tmp ) ;
8037: LD_ADDR_VAR 0 4
8041: PUSH
8042: LD_VAR 0 4
8046: PPUSH
8047: LD_VAR 0 4
8051: PPUSH
8052: CALL_OW 3
8056: ST_TO_ADDR
8057: GO 8034
8059: POP
8060: POP
// result := [ tmp , 0 , 0 , p ] ;
8061: LD_ADDR_VAR 0 2
8065: PUSH
8066: LD_VAR 0 4
8070: PUSH
8071: LD_INT 0
8073: PUSH
8074: LD_INT 0
8076: PUSH
8077: LD_VAR 0 11
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: LIST
8086: LIST
8087: ST_TO_ADDR
// exit ;
8088: GO 10455
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
8090: LD_EXP 57
8094: PUSH
8095: LD_VAR 0 1
8099: ARRAY
8100: PPUSH
8101: LD_INT 2
8103: PUSH
8104: LD_INT 30
8106: PUSH
8107: LD_INT 6
8109: PUSH
8110: EMPTY
8111: LIST
8112: LIST
8113: PUSH
8114: LD_INT 30
8116: PUSH
8117: LD_INT 7
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PUSH
8124: LD_INT 30
8126: PUSH
8127: LD_INT 8
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: LIST
8138: LIST
8139: PPUSH
8140: CALL_OW 72
8144: NOT
8145: PUSH
8146: LD_EXP 57
8150: PUSH
8151: LD_VAR 0 1
8155: ARRAY
8156: PPUSH
8157: LD_INT 30
8159: PUSH
8160: LD_INT 3
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 72
8171: NOT
8172: AND
8173: IFFALSE 8245
// begin if eng = tmp then
8175: LD_VAR 0 6
8179: PUSH
8180: LD_VAR 0 4
8184: EQUAL
8185: IFFALSE 8189
// exit ;
8187: GO 10455
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
8189: LD_ADDR_EXP 99
8193: PUSH
8194: LD_EXP 99
8198: PPUSH
8199: LD_VAR 0 1
8203: PPUSH
8204: LD_INT 1
8206: PPUSH
8207: CALL_OW 1
8211: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
8212: LD_ADDR_VAR 0 2
8216: PUSH
8217: LD_INT 0
8219: PUSH
8220: LD_VAR 0 4
8224: PUSH
8225: LD_VAR 0 6
8229: DIFF
8230: PUSH
8231: LD_INT 0
8233: PUSH
8234: LD_INT 0
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: LIST
8241: LIST
8242: ST_TO_ADDR
// exit ;
8243: GO 10455
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
8245: LD_EXP 84
8249: PUSH
8250: LD_EXP 83
8254: PUSH
8255: LD_VAR 0 1
8259: ARRAY
8260: ARRAY
8261: PUSH
8262: LD_EXP 57
8266: PUSH
8267: LD_VAR 0 1
8271: ARRAY
8272: PPUSH
8273: LD_INT 2
8275: PUSH
8276: LD_INT 30
8278: PUSH
8279: LD_INT 6
8281: PUSH
8282: EMPTY
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 30
8288: PUSH
8289: LD_INT 7
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PUSH
8296: LD_INT 30
8298: PUSH
8299: LD_INT 8
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 72
8316: AND
8317: PUSH
8318: LD_EXP 57
8322: PUSH
8323: LD_VAR 0 1
8327: ARRAY
8328: PPUSH
8329: LD_INT 30
8331: PUSH
8332: LD_INT 3
8334: PUSH
8335: EMPTY
8336: LIST
8337: LIST
8338: PPUSH
8339: CALL_OW 72
8343: NOT
8344: AND
8345: IFFALSE 8559
// begin if sci >= 6 then
8347: LD_VAR 0 8
8351: PUSH
8352: LD_INT 6
8354: GREATEREQUAL
8355: IFFALSE 8359
// exit ;
8357: GO 10455
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
8359: LD_ADDR_EXP 99
8363: PUSH
8364: LD_EXP 99
8368: PPUSH
8369: LD_VAR 0 1
8373: PPUSH
8374: LD_INT 2
8376: PPUSH
8377: CALL_OW 1
8381: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
8382: LD_ADDR_VAR 0 9
8386: PUSH
8387: LD_VAR 0 4
8391: PUSH
8392: LD_VAR 0 8
8396: DIFF
8397: PPUSH
8398: LD_INT 4
8400: PPUSH
8401: CALL 72067 0 2
8405: ST_TO_ADDR
// p := [ ] ;
8406: LD_ADDR_VAR 0 11
8410: PUSH
8411: EMPTY
8412: ST_TO_ADDR
// if sci < 6 and sort > 6 then
8413: LD_VAR 0 8
8417: PUSH
8418: LD_INT 6
8420: LESS
8421: PUSH
8422: LD_VAR 0 9
8426: PUSH
8427: LD_INT 6
8429: GREATER
8430: AND
8431: IFFALSE 8512
// begin for i = 1 to 6 - sci do
8433: LD_ADDR_VAR 0 3
8437: PUSH
8438: DOUBLE
8439: LD_INT 1
8441: DEC
8442: ST_TO_ADDR
8443: LD_INT 6
8445: PUSH
8446: LD_VAR 0 8
8450: MINUS
8451: PUSH
8452: FOR_TO
8453: IFFALSE 8508
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
8455: LD_ADDR_VAR 0 11
8459: PUSH
8460: LD_VAR 0 11
8464: PPUSH
8465: LD_VAR 0 11
8469: PUSH
8470: LD_INT 1
8472: PLUS
8473: PPUSH
8474: LD_VAR 0 9
8478: PUSH
8479: LD_INT 1
8481: ARRAY
8482: PPUSH
8483: CALL_OW 2
8487: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
8488: LD_ADDR_VAR 0 9
8492: PUSH
8493: LD_VAR 0 9
8497: PPUSH
8498: LD_INT 1
8500: PPUSH
8501: CALL_OW 3
8505: ST_TO_ADDR
// end ;
8506: GO 8452
8508: POP
8509: POP
// end else
8510: GO 8532
// if sort then
8512: LD_VAR 0 9
8516: IFFALSE 8532
// p := sort [ 1 ] ;
8518: LD_ADDR_VAR 0 11
8522: PUSH
8523: LD_VAR 0 9
8527: PUSH
8528: LD_INT 1
8530: ARRAY
8531: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
8532: LD_ADDR_VAR 0 2
8536: PUSH
8537: LD_INT 0
8539: PUSH
8540: LD_INT 0
8542: PUSH
8543: LD_INT 0
8545: PUSH
8546: LD_VAR 0 11
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: ST_TO_ADDR
// exit ;
8557: GO 10455
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
8559: LD_EXP 84
8563: PUSH
8564: LD_EXP 83
8568: PUSH
8569: LD_VAR 0 1
8573: ARRAY
8574: ARRAY
8575: PUSH
8576: LD_EXP 57
8580: PUSH
8581: LD_VAR 0 1
8585: ARRAY
8586: PPUSH
8587: LD_INT 2
8589: PUSH
8590: LD_INT 30
8592: PUSH
8593: LD_INT 6
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 30
8602: PUSH
8603: LD_INT 7
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: LD_INT 30
8612: PUSH
8613: LD_INT 8
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: LIST
8625: PPUSH
8626: CALL_OW 72
8630: AND
8631: PUSH
8632: LD_EXP 57
8636: PUSH
8637: LD_VAR 0 1
8641: ARRAY
8642: PPUSH
8643: LD_INT 30
8645: PUSH
8646: LD_INT 3
8648: PUSH
8649: EMPTY
8650: LIST
8651: LIST
8652: PPUSH
8653: CALL_OW 72
8657: AND
8658: IFFALSE 9185
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
8660: LD_ADDR_EXP 99
8664: PUSH
8665: LD_EXP 99
8669: PPUSH
8670: LD_VAR 0 1
8674: PPUSH
8675: LD_INT 3
8677: PPUSH
8678: CALL_OW 1
8682: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
8683: LD_ADDR_VAR 0 2
8687: PUSH
8688: LD_INT 0
8690: PUSH
8691: LD_INT 0
8693: PUSH
8694: LD_INT 0
8696: PUSH
8697: LD_INT 0
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: LIST
8705: ST_TO_ADDR
// if not eng then
8706: LD_VAR 0 6
8710: NOT
8711: IFFALSE 8774
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
8713: LD_ADDR_VAR 0 11
8717: PUSH
8718: LD_VAR 0 4
8722: PPUSH
8723: LD_INT 2
8725: PPUSH
8726: CALL 72067 0 2
8730: PUSH
8731: LD_INT 1
8733: ARRAY
8734: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
8735: LD_ADDR_VAR 0 2
8739: PUSH
8740: LD_VAR 0 2
8744: PPUSH
8745: LD_INT 2
8747: PPUSH
8748: LD_VAR 0 11
8752: PPUSH
8753: CALL_OW 1
8757: ST_TO_ADDR
// tmp := tmp diff p ;
8758: LD_ADDR_VAR 0 4
8762: PUSH
8763: LD_VAR 0 4
8767: PUSH
8768: LD_VAR 0 11
8772: DIFF
8773: ST_TO_ADDR
// end ; if not eng then
8774: LD_VAR 0 6
8778: NOT
8779: IFFALSE 8805
// tmp := tmp diff ( mech union sci ) else
8781: LD_ADDR_VAR 0 4
8785: PUSH
8786: LD_VAR 0 4
8790: PUSH
8791: LD_VAR 0 7
8795: PUSH
8796: LD_VAR 0 8
8800: UNION
8801: DIFF
8802: ST_TO_ADDR
8803: GO 8837
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
8805: LD_ADDR_VAR 0 4
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_VAR 0 6
8819: PUSH
8820: LD_INT 1
8822: ARRAY
8823: PUSH
8824: LD_VAR 0 7
8828: UNION
8829: PUSH
8830: LD_VAR 0 8
8834: UNION
8835: DIFF
8836: ST_TO_ADDR
// if tmp and sci < 6 then
8837: LD_VAR 0 4
8841: PUSH
8842: LD_VAR 0 8
8846: PUSH
8847: LD_INT 6
8849: LESS
8850: AND
8851: IFFALSE 9010
// begin sort := SortBySkill ( tmp , 4 ) ;
8853: LD_ADDR_VAR 0 9
8857: PUSH
8858: LD_VAR 0 4
8862: PPUSH
8863: LD_INT 4
8865: PPUSH
8866: CALL 72067 0 2
8870: ST_TO_ADDR
// p := [ ] ;
8871: LD_ADDR_VAR 0 11
8875: PUSH
8876: EMPTY
8877: ST_TO_ADDR
// if sort then
8878: LD_VAR 0 9
8882: IFFALSE 8981
// for i = 1 to 6 - sci do
8884: LD_ADDR_VAR 0 3
8888: PUSH
8889: DOUBLE
8890: LD_INT 1
8892: DEC
8893: ST_TO_ADDR
8894: LD_INT 6
8896: PUSH
8897: LD_VAR 0 8
8901: MINUS
8902: PUSH
8903: FOR_TO
8904: IFFALSE 8979
// begin if i = sort then
8906: LD_VAR 0 3
8910: PUSH
8911: LD_VAR 0 9
8915: EQUAL
8916: IFFALSE 8920
// break ;
8918: GO 8979
// p := Insert ( p , p + 1 , sort [ i ] ) ;
8920: LD_ADDR_VAR 0 11
8924: PUSH
8925: LD_VAR 0 11
8929: PPUSH
8930: LD_VAR 0 11
8934: PUSH
8935: LD_INT 1
8937: PLUS
8938: PPUSH
8939: LD_VAR 0 9
8943: PUSH
8944: LD_VAR 0 3
8948: ARRAY
8949: PPUSH
8950: CALL_OW 2
8954: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
8955: LD_ADDR_VAR 0 4
8959: PUSH
8960: LD_VAR 0 4
8964: PUSH
8965: LD_VAR 0 9
8969: PUSH
8970: LD_VAR 0 3
8974: ARRAY
8975: DIFF
8976: ST_TO_ADDR
// end ;
8977: GO 8903
8979: POP
8980: POP
// if p then
8981: LD_VAR 0 11
8985: IFFALSE 9010
// result := Replace ( result , 4 , p ) ;
8987: LD_ADDR_VAR 0 2
8991: PUSH
8992: LD_VAR 0 2
8996: PPUSH
8997: LD_INT 4
8999: PPUSH
9000: LD_VAR 0 11
9004: PPUSH
9005: CALL_OW 1
9009: ST_TO_ADDR
// end ; if tmp and mech < 6 then
9010: LD_VAR 0 4
9014: PUSH
9015: LD_VAR 0 7
9019: PUSH
9020: LD_INT 6
9022: LESS
9023: AND
9024: IFFALSE 9183
// begin sort := SortBySkill ( tmp , 3 ) ;
9026: LD_ADDR_VAR 0 9
9030: PUSH
9031: LD_VAR 0 4
9035: PPUSH
9036: LD_INT 3
9038: PPUSH
9039: CALL 72067 0 2
9043: ST_TO_ADDR
// p := [ ] ;
9044: LD_ADDR_VAR 0 11
9048: PUSH
9049: EMPTY
9050: ST_TO_ADDR
// if sort then
9051: LD_VAR 0 9
9055: IFFALSE 9154
// for i = 1 to 6 - mech do
9057: LD_ADDR_VAR 0 3
9061: PUSH
9062: DOUBLE
9063: LD_INT 1
9065: DEC
9066: ST_TO_ADDR
9067: LD_INT 6
9069: PUSH
9070: LD_VAR 0 7
9074: MINUS
9075: PUSH
9076: FOR_TO
9077: IFFALSE 9152
// begin if i = sort then
9079: LD_VAR 0 3
9083: PUSH
9084: LD_VAR 0 9
9088: EQUAL
9089: IFFALSE 9093
// break ;
9091: GO 9152
// p := Insert ( p , p + 1 , sort [ i ] ) ;
9093: LD_ADDR_VAR 0 11
9097: PUSH
9098: LD_VAR 0 11
9102: PPUSH
9103: LD_VAR 0 11
9107: PUSH
9108: LD_INT 1
9110: PLUS
9111: PPUSH
9112: LD_VAR 0 9
9116: PUSH
9117: LD_VAR 0 3
9121: ARRAY
9122: PPUSH
9123: CALL_OW 2
9127: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
9128: LD_ADDR_VAR 0 4
9132: PUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 9
9142: PUSH
9143: LD_VAR 0 3
9147: ARRAY
9148: DIFF
9149: ST_TO_ADDR
// end ;
9150: GO 9076
9152: POP
9153: POP
// if p then
9154: LD_VAR 0 11
9158: IFFALSE 9183
// result := Replace ( result , 3 , p ) ;
9160: LD_ADDR_VAR 0 2
9164: PUSH
9165: LD_VAR 0 2
9169: PPUSH
9170: LD_INT 3
9172: PPUSH
9173: LD_VAR 0 11
9177: PPUSH
9178: CALL_OW 1
9182: ST_TO_ADDR
// end ; exit ;
9183: GO 10455
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
9185: LD_EXP 84
9189: PUSH
9190: LD_EXP 83
9194: PUSH
9195: LD_VAR 0 1
9199: ARRAY
9200: ARRAY
9201: NOT
9202: PUSH
9203: LD_EXP 57
9207: PUSH
9208: LD_VAR 0 1
9212: ARRAY
9213: PPUSH
9214: LD_INT 30
9216: PUSH
9217: LD_INT 3
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: PPUSH
9224: CALL_OW 72
9228: AND
9229: PUSH
9230: LD_EXP 62
9234: PUSH
9235: LD_VAR 0 1
9239: ARRAY
9240: AND
9241: IFFALSE 9785
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
9243: LD_ADDR_EXP 99
9247: PUSH
9248: LD_EXP 99
9252: PPUSH
9253: LD_VAR 0 1
9257: PPUSH
9258: LD_INT 5
9260: PPUSH
9261: CALL_OW 1
9265: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
9266: LD_ADDR_VAR 0 2
9270: PUSH
9271: LD_INT 0
9273: PUSH
9274: LD_INT 0
9276: PUSH
9277: LD_INT 0
9279: PUSH
9280: LD_INT 0
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: LIST
9288: ST_TO_ADDR
// if sci > 1 then
9289: LD_VAR 0 8
9293: PUSH
9294: LD_INT 1
9296: GREATER
9297: IFFALSE 9325
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
9299: LD_ADDR_VAR 0 4
9303: PUSH
9304: LD_VAR 0 4
9308: PUSH
9309: LD_VAR 0 8
9313: PUSH
9314: LD_VAR 0 8
9318: PUSH
9319: LD_INT 1
9321: ARRAY
9322: DIFF
9323: DIFF
9324: ST_TO_ADDR
// if tmp and not sci then
9325: LD_VAR 0 4
9329: PUSH
9330: LD_VAR 0 8
9334: NOT
9335: AND
9336: IFFALSE 9405
// begin sort := SortBySkill ( tmp , 4 ) ;
9338: LD_ADDR_VAR 0 9
9342: PUSH
9343: LD_VAR 0 4
9347: PPUSH
9348: LD_INT 4
9350: PPUSH
9351: CALL 72067 0 2
9355: ST_TO_ADDR
// if sort then
9356: LD_VAR 0 9
9360: IFFALSE 9376
// p := sort [ 1 ] ;
9362: LD_ADDR_VAR 0 11
9366: PUSH
9367: LD_VAR 0 9
9371: PUSH
9372: LD_INT 1
9374: ARRAY
9375: ST_TO_ADDR
// if p then
9376: LD_VAR 0 11
9380: IFFALSE 9405
// result := Replace ( result , 4 , p ) ;
9382: LD_ADDR_VAR 0 2
9386: PUSH
9387: LD_VAR 0 2
9391: PPUSH
9392: LD_INT 4
9394: PPUSH
9395: LD_VAR 0 11
9399: PPUSH
9400: CALL_OW 1
9404: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
9405: LD_ADDR_VAR 0 4
9409: PUSH
9410: LD_VAR 0 4
9414: PUSH
9415: LD_VAR 0 7
9419: DIFF
9420: ST_TO_ADDR
// if tmp and mech < 6 then
9421: LD_VAR 0 4
9425: PUSH
9426: LD_VAR 0 7
9430: PUSH
9431: LD_INT 6
9433: LESS
9434: AND
9435: IFFALSE 9594
// begin sort := SortBySkill ( tmp , 3 ) ;
9437: LD_ADDR_VAR 0 9
9441: PUSH
9442: LD_VAR 0 4
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: CALL 72067 0 2
9454: ST_TO_ADDR
// p := [ ] ;
9455: LD_ADDR_VAR 0 11
9459: PUSH
9460: EMPTY
9461: ST_TO_ADDR
// if sort then
9462: LD_VAR 0 9
9466: IFFALSE 9565
// for i = 1 to 6 - mech do
9468: LD_ADDR_VAR 0 3
9472: PUSH
9473: DOUBLE
9474: LD_INT 1
9476: DEC
9477: ST_TO_ADDR
9478: LD_INT 6
9480: PUSH
9481: LD_VAR 0 7
9485: MINUS
9486: PUSH
9487: FOR_TO
9488: IFFALSE 9563
// begin if i = sort then
9490: LD_VAR 0 3
9494: PUSH
9495: LD_VAR 0 9
9499: EQUAL
9500: IFFALSE 9504
// break ;
9502: GO 9563
// p := Insert ( p , p + 1 , sort [ i ] ) ;
9504: LD_ADDR_VAR 0 11
9508: PUSH
9509: LD_VAR 0 11
9513: PPUSH
9514: LD_VAR 0 11
9518: PUSH
9519: LD_INT 1
9521: PLUS
9522: PPUSH
9523: LD_VAR 0 9
9527: PUSH
9528: LD_VAR 0 3
9532: ARRAY
9533: PPUSH
9534: CALL_OW 2
9538: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
9539: LD_ADDR_VAR 0 4
9543: PUSH
9544: LD_VAR 0 4
9548: PUSH
9549: LD_VAR 0 9
9553: PUSH
9554: LD_VAR 0 3
9558: ARRAY
9559: DIFF
9560: ST_TO_ADDR
// end ;
9561: GO 9487
9563: POP
9564: POP
// if p then
9565: LD_VAR 0 11
9569: IFFALSE 9594
// result := Replace ( result , 3 , p ) ;
9571: LD_ADDR_VAR 0 2
9575: PUSH
9576: LD_VAR 0 2
9580: PPUSH
9581: LD_INT 3
9583: PPUSH
9584: LD_VAR 0 11
9588: PPUSH
9589: CALL_OW 1
9593: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
9594: LD_ADDR_VAR 0 4
9598: PUSH
9599: LD_VAR 0 4
9603: PUSH
9604: LD_VAR 0 6
9608: DIFF
9609: ST_TO_ADDR
// if tmp and eng < 6 then
9610: LD_VAR 0 4
9614: PUSH
9615: LD_VAR 0 6
9619: PUSH
9620: LD_INT 6
9622: LESS
9623: AND
9624: IFFALSE 9783
// begin sort := SortBySkill ( tmp , 2 ) ;
9626: LD_ADDR_VAR 0 9
9630: PUSH
9631: LD_VAR 0 4
9635: PPUSH
9636: LD_INT 2
9638: PPUSH
9639: CALL 72067 0 2
9643: ST_TO_ADDR
// p := [ ] ;
9644: LD_ADDR_VAR 0 11
9648: PUSH
9649: EMPTY
9650: ST_TO_ADDR
// if sort then
9651: LD_VAR 0 9
9655: IFFALSE 9754
// for i = 1 to 6 - eng do
9657: LD_ADDR_VAR 0 3
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_INT 6
9669: PUSH
9670: LD_VAR 0 6
9674: MINUS
9675: PUSH
9676: FOR_TO
9677: IFFALSE 9752
// begin if i = sort then
9679: LD_VAR 0 3
9683: PUSH
9684: LD_VAR 0 9
9688: EQUAL
9689: IFFALSE 9693
// break ;
9691: GO 9752
// p := Insert ( p , p + 1 , sort [ i ] ) ;
9693: LD_ADDR_VAR 0 11
9697: PUSH
9698: LD_VAR 0 11
9702: PPUSH
9703: LD_VAR 0 11
9707: PUSH
9708: LD_INT 1
9710: PLUS
9711: PPUSH
9712: LD_VAR 0 9
9716: PUSH
9717: LD_VAR 0 3
9721: ARRAY
9722: PPUSH
9723: CALL_OW 2
9727: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
9728: LD_ADDR_VAR 0 4
9732: PUSH
9733: LD_VAR 0 4
9737: PUSH
9738: LD_VAR 0 9
9742: PUSH
9743: LD_VAR 0 3
9747: ARRAY
9748: DIFF
9749: ST_TO_ADDR
// end ;
9750: GO 9676
9752: POP
9753: POP
// if p then
9754: LD_VAR 0 11
9758: IFFALSE 9783
// result := Replace ( result , 2 , p ) ;
9760: LD_ADDR_VAR 0 2
9764: PUSH
9765: LD_VAR 0 2
9769: PPUSH
9770: LD_INT 2
9772: PPUSH
9773: LD_VAR 0 11
9777: PPUSH
9778: CALL_OW 1
9782: ST_TO_ADDR
// end ; exit ;
9783: GO 10455
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
9785: LD_EXP 84
9789: PUSH
9790: LD_EXP 83
9794: PUSH
9795: LD_VAR 0 1
9799: ARRAY
9800: ARRAY
9801: NOT
9802: PUSH
9803: LD_EXP 57
9807: PUSH
9808: LD_VAR 0 1
9812: ARRAY
9813: PPUSH
9814: LD_INT 30
9816: PUSH
9817: LD_INT 3
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PPUSH
9824: CALL_OW 72
9828: AND
9829: PUSH
9830: LD_EXP 62
9834: PUSH
9835: LD_VAR 0 1
9839: ARRAY
9840: NOT
9841: AND
9842: IFFALSE 10455
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
9844: LD_ADDR_EXP 99
9848: PUSH
9849: LD_EXP 99
9853: PPUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: LD_INT 6
9861: PPUSH
9862: CALL_OW 1
9866: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
9867: LD_ADDR_VAR 0 2
9871: PUSH
9872: LD_INT 0
9874: PUSH
9875: LD_INT 0
9877: PUSH
9878: LD_INT 0
9880: PUSH
9881: LD_INT 0
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: ST_TO_ADDR
// if sci >= 1 then
9890: LD_VAR 0 8
9894: PUSH
9895: LD_INT 1
9897: GREATEREQUAL
9898: IFFALSE 9920
// tmp := tmp diff sci [ 1 ] ;
9900: LD_ADDR_VAR 0 4
9904: PUSH
9905: LD_VAR 0 4
9909: PUSH
9910: LD_VAR 0 8
9914: PUSH
9915: LD_INT 1
9917: ARRAY
9918: DIFF
9919: ST_TO_ADDR
// if tmp and not sci then
9920: LD_VAR 0 4
9924: PUSH
9925: LD_VAR 0 8
9929: NOT
9930: AND
9931: IFFALSE 10000
// begin sort := SortBySkill ( tmp , 4 ) ;
9933: LD_ADDR_VAR 0 9
9937: PUSH
9938: LD_VAR 0 4
9942: PPUSH
9943: LD_INT 4
9945: PPUSH
9946: CALL 72067 0 2
9950: ST_TO_ADDR
// if sort then
9951: LD_VAR 0 9
9955: IFFALSE 9971
// p := sort [ 1 ] ;
9957: LD_ADDR_VAR 0 11
9961: PUSH
9962: LD_VAR 0 9
9966: PUSH
9967: LD_INT 1
9969: ARRAY
9970: ST_TO_ADDR
// if p then
9971: LD_VAR 0 11
9975: IFFALSE 10000
// result := Replace ( result , 4 , p ) ;
9977: LD_ADDR_VAR 0 2
9981: PUSH
9982: LD_VAR 0 2
9986: PPUSH
9987: LD_INT 4
9989: PPUSH
9990: LD_VAR 0 11
9994: PPUSH
9995: CALL_OW 1
9999: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
10000: LD_ADDR_VAR 0 4
10004: PUSH
10005: LD_VAR 0 4
10009: PUSH
10010: LD_VAR 0 7
10014: DIFF
10015: ST_TO_ADDR
// if tmp and mech < 6 then
10016: LD_VAR 0 4
10020: PUSH
10021: LD_VAR 0 7
10025: PUSH
10026: LD_INT 6
10028: LESS
10029: AND
10030: IFFALSE 10189
// begin sort := SortBySkill ( tmp , 3 ) ;
10032: LD_ADDR_VAR 0 9
10036: PUSH
10037: LD_VAR 0 4
10041: PPUSH
10042: LD_INT 3
10044: PPUSH
10045: CALL 72067 0 2
10049: ST_TO_ADDR
// p := [ ] ;
10050: LD_ADDR_VAR 0 11
10054: PUSH
10055: EMPTY
10056: ST_TO_ADDR
// if sort then
10057: LD_VAR 0 9
10061: IFFALSE 10160
// for i = 1 to 6 - mech do
10063: LD_ADDR_VAR 0 3
10067: PUSH
10068: DOUBLE
10069: LD_INT 1
10071: DEC
10072: ST_TO_ADDR
10073: LD_INT 6
10075: PUSH
10076: LD_VAR 0 7
10080: MINUS
10081: PUSH
10082: FOR_TO
10083: IFFALSE 10158
// begin if i = sort then
10085: LD_VAR 0 3
10089: PUSH
10090: LD_VAR 0 9
10094: EQUAL
10095: IFFALSE 10099
// break ;
10097: GO 10158
// p := Insert ( p , p + 1 , sort [ i ] ) ;
10099: LD_ADDR_VAR 0 11
10103: PUSH
10104: LD_VAR 0 11
10108: PPUSH
10109: LD_VAR 0 11
10113: PUSH
10114: LD_INT 1
10116: PLUS
10117: PPUSH
10118: LD_VAR 0 9
10122: PUSH
10123: LD_VAR 0 3
10127: ARRAY
10128: PPUSH
10129: CALL_OW 2
10133: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
10134: LD_ADDR_VAR 0 4
10138: PUSH
10139: LD_VAR 0 4
10143: PUSH
10144: LD_VAR 0 9
10148: PUSH
10149: LD_VAR 0 3
10153: ARRAY
10154: DIFF
10155: ST_TO_ADDR
// end ;
10156: GO 10082
10158: POP
10159: POP
// if p then
10160: LD_VAR 0 11
10164: IFFALSE 10189
// result := Replace ( result , 3 , p ) ;
10166: LD_ADDR_VAR 0 2
10170: PUSH
10171: LD_VAR 0 2
10175: PPUSH
10176: LD_INT 3
10178: PPUSH
10179: LD_VAR 0 11
10183: PPUSH
10184: CALL_OW 1
10188: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
10189: LD_ADDR_VAR 0 4
10193: PUSH
10194: LD_VAR 0 4
10198: PUSH
10199: LD_VAR 0 6
10203: DIFF
10204: ST_TO_ADDR
// if tmp and eng < 4 then
10205: LD_VAR 0 4
10209: PUSH
10210: LD_VAR 0 6
10214: PUSH
10215: LD_INT 4
10217: LESS
10218: AND
10219: IFFALSE 10380
// begin sort := SortBySkill ( tmp , 2 ) ;
10221: LD_ADDR_VAR 0 9
10225: PUSH
10226: LD_VAR 0 4
10230: PPUSH
10231: LD_INT 2
10233: PPUSH
10234: CALL 72067 0 2
10238: ST_TO_ADDR
// p := [ ] ;
10239: LD_ADDR_VAR 0 11
10243: PUSH
10244: EMPTY
10245: ST_TO_ADDR
// if sort then
10246: LD_VAR 0 9
10250: IFFALSE 10349
// for i = 1 to 4 - eng do
10252: LD_ADDR_VAR 0 3
10256: PUSH
10257: DOUBLE
10258: LD_INT 1
10260: DEC
10261: ST_TO_ADDR
10262: LD_INT 4
10264: PUSH
10265: LD_VAR 0 6
10269: MINUS
10270: PUSH
10271: FOR_TO
10272: IFFALSE 10347
// begin if i = sort then
10274: LD_VAR 0 3
10278: PUSH
10279: LD_VAR 0 9
10283: EQUAL
10284: IFFALSE 10288
// break ;
10286: GO 10347
// p := Insert ( p , p + 1 , sort [ i ] ) ;
10288: LD_ADDR_VAR 0 11
10292: PUSH
10293: LD_VAR 0 11
10297: PPUSH
10298: LD_VAR 0 11
10302: PUSH
10303: LD_INT 1
10305: PLUS
10306: PPUSH
10307: LD_VAR 0 9
10311: PUSH
10312: LD_VAR 0 3
10316: ARRAY
10317: PPUSH
10318: CALL_OW 2
10322: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
10323: LD_ADDR_VAR 0 4
10327: PUSH
10328: LD_VAR 0 4
10332: PUSH
10333: LD_VAR 0 9
10337: PUSH
10338: LD_VAR 0 3
10342: ARRAY
10343: DIFF
10344: ST_TO_ADDR
// end ;
10345: GO 10271
10347: POP
10348: POP
// if p then
10349: LD_VAR 0 11
10353: IFFALSE 10378
// result := Replace ( result , 2 , p ) ;
10355: LD_ADDR_VAR 0 2
10359: PUSH
10360: LD_VAR 0 2
10364: PPUSH
10365: LD_INT 2
10367: PPUSH
10368: LD_VAR 0 11
10372: PPUSH
10373: CALL_OW 1
10377: ST_TO_ADDR
// end else
10378: GO 10424
// for i = eng downto 5 do
10380: LD_ADDR_VAR 0 3
10384: PUSH
10385: DOUBLE
10386: LD_VAR 0 6
10390: INC
10391: ST_TO_ADDR
10392: LD_INT 5
10394: PUSH
10395: FOR_DOWNTO
10396: IFFALSE 10422
// tmp := tmp union eng [ i ] ;
10398: LD_ADDR_VAR 0 4
10402: PUSH
10403: LD_VAR 0 4
10407: PUSH
10408: LD_VAR 0 6
10412: PUSH
10413: LD_VAR 0 3
10417: ARRAY
10418: UNION
10419: ST_TO_ADDR
10420: GO 10395
10422: POP
10423: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_INT 1
10436: PPUSH
10437: LD_VAR 0 4
10441: PUSH
10442: LD_VAR 0 5
10446: DIFF
10447: PPUSH
10448: CALL_OW 1
10452: ST_TO_ADDR
// exit ;
10453: GO 10455
// end ; end ;
10455: LD_VAR 0 2
10459: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
10460: LD_INT 0
10462: PPUSH
10463: PPUSH
10464: PPUSH
// if not mc_bases then
10465: LD_EXP 57
10469: NOT
10470: IFFALSE 10474
// exit ;
10472: GO 10580
// for i = 1 to mc_bases do
10474: LD_ADDR_VAR 0 2
10478: PUSH
10479: DOUBLE
10480: LD_INT 1
10482: DEC
10483: ST_TO_ADDR
10484: LD_EXP 57
10488: PUSH
10489: FOR_TO
10490: IFFALSE 10571
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10492: LD_ADDR_VAR 0 3
10496: PUSH
10497: LD_EXP 57
10501: PUSH
10502: LD_VAR 0 2
10506: ARRAY
10507: PPUSH
10508: LD_INT 21
10510: PUSH
10511: LD_INT 3
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: PUSH
10518: LD_INT 3
10520: PUSH
10521: LD_INT 24
10523: PUSH
10524: LD_INT 1000
10526: PUSH
10527: EMPTY
10528: LIST
10529: LIST
10530: PUSH
10531: EMPTY
10532: LIST
10533: LIST
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: PPUSH
10539: CALL_OW 72
10543: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
10544: LD_ADDR_EXP 58
10548: PUSH
10549: LD_EXP 58
10553: PPUSH
10554: LD_VAR 0 2
10558: PPUSH
10559: LD_VAR 0 3
10563: PPUSH
10564: CALL_OW 1
10568: ST_TO_ADDR
// end ;
10569: GO 10489
10571: POP
10572: POP
// RaiseSailEvent ( 101 ) ;
10573: LD_INT 101
10575: PPUSH
10576: CALL_OW 427
// end ;
10580: LD_VAR 0 1
10584: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
10585: LD_INT 0
10587: PPUSH
10588: PPUSH
10589: PPUSH
10590: PPUSH
10591: PPUSH
10592: PPUSH
10593: PPUSH
// if not mc_bases then
10594: LD_EXP 57
10598: NOT
10599: IFFALSE 10603
// exit ;
10601: GO 11176
// for i = 1 to mc_bases do
10603: LD_ADDR_VAR 0 2
10607: PUSH
10608: DOUBLE
10609: LD_INT 1
10611: DEC
10612: ST_TO_ADDR
10613: LD_EXP 57
10617: PUSH
10618: FOR_TO
10619: IFFALSE 11167
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
10621: LD_ADDR_VAR 0 5
10625: PUSH
10626: LD_EXP 57
10630: PUSH
10631: LD_VAR 0 2
10635: ARRAY
10636: PUSH
10637: LD_EXP 86
10641: PUSH
10642: LD_VAR 0 2
10646: ARRAY
10647: UNION
10648: PPUSH
10649: LD_INT 21
10651: PUSH
10652: LD_INT 1
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: LD_INT 1
10661: PUSH
10662: LD_INT 3
10664: PUSH
10665: LD_INT 54
10667: PUSH
10668: EMPTY
10669: LIST
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PUSH
10675: LD_INT 3
10677: PUSH
10678: LD_INT 24
10680: PUSH
10681: LD_INT 750
10683: PUSH
10684: EMPTY
10685: LIST
10686: LIST
10687: PUSH
10688: EMPTY
10689: LIST
10690: LIST
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: PUSH
10697: EMPTY
10698: LIST
10699: LIST
10700: PPUSH
10701: CALL_OW 72
10705: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
10706: LD_ADDR_VAR 0 6
10710: PUSH
10711: LD_EXP 57
10715: PUSH
10716: LD_VAR 0 2
10720: ARRAY
10721: PPUSH
10722: LD_INT 21
10724: PUSH
10725: LD_INT 1
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 1
10734: PUSH
10735: LD_INT 3
10737: PUSH
10738: LD_INT 54
10740: PUSH
10741: EMPTY
10742: LIST
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PUSH
10748: LD_INT 3
10750: PUSH
10751: LD_INT 24
10753: PUSH
10754: LD_INT 250
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: LIST
10769: PUSH
10770: EMPTY
10771: LIST
10772: LIST
10773: PPUSH
10774: CALL_OW 72
10778: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
10779: LD_ADDR_VAR 0 7
10783: PUSH
10784: LD_VAR 0 5
10788: PUSH
10789: LD_VAR 0 6
10793: DIFF
10794: ST_TO_ADDR
// if not need_heal_1 then
10795: LD_VAR 0 6
10799: NOT
10800: IFFALSE 10833
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
10802: LD_ADDR_EXP 60
10806: PUSH
10807: LD_EXP 60
10811: PPUSH
10812: LD_VAR 0 2
10816: PUSH
10817: LD_INT 1
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PPUSH
10824: EMPTY
10825: PPUSH
10826: CALL 37882 0 3
10830: ST_TO_ADDR
10831: GO 10903
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
10833: LD_ADDR_EXP 60
10837: PUSH
10838: LD_EXP 60
10842: PPUSH
10843: LD_VAR 0 2
10847: PUSH
10848: LD_INT 1
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: PPUSH
10855: LD_EXP 60
10859: PUSH
10860: LD_VAR 0 2
10864: ARRAY
10865: PUSH
10866: LD_INT 1
10868: ARRAY
10869: PPUSH
10870: LD_INT 3
10872: PUSH
10873: LD_INT 24
10875: PUSH
10876: LD_INT 1000
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: PPUSH
10887: CALL_OW 72
10891: PUSH
10892: LD_VAR 0 6
10896: UNION
10897: PPUSH
10898: CALL 37882 0 3
10902: ST_TO_ADDR
// if not need_heal_2 then
10903: LD_VAR 0 7
10907: NOT
10908: IFFALSE 10941
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
10910: LD_ADDR_EXP 60
10914: PUSH
10915: LD_EXP 60
10919: PPUSH
10920: LD_VAR 0 2
10924: PUSH
10925: LD_INT 2
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PPUSH
10932: EMPTY
10933: PPUSH
10934: CALL 37882 0 3
10938: ST_TO_ADDR
10939: GO 10973
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
10941: LD_ADDR_EXP 60
10945: PUSH
10946: LD_EXP 60
10950: PPUSH
10951: LD_VAR 0 2
10955: PUSH
10956: LD_INT 2
10958: PUSH
10959: EMPTY
10960: LIST
10961: LIST
10962: PPUSH
10963: LD_VAR 0 7
10967: PPUSH
10968: CALL 37882 0 3
10972: ST_TO_ADDR
// if need_heal_2 then
10973: LD_VAR 0 7
10977: IFFALSE 11149
// for j in need_heal_2 do
10979: LD_ADDR_VAR 0 3
10983: PUSH
10984: LD_VAR 0 7
10988: PUSH
10989: FOR_IN
10990: IFFALSE 11147
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
10992: LD_ADDR_VAR 0 5
10996: PUSH
10997: LD_EXP 57
11001: PUSH
11002: LD_VAR 0 2
11006: ARRAY
11007: PPUSH
11008: LD_INT 2
11010: PUSH
11011: LD_INT 30
11013: PUSH
11014: LD_INT 6
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: PUSH
11021: LD_INT 30
11023: PUSH
11024: LD_INT 7
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: PUSH
11031: LD_INT 30
11033: PUSH
11034: LD_INT 8
11036: PUSH
11037: EMPTY
11038: LIST
11039: LIST
11040: PUSH
11041: LD_INT 30
11043: PUSH
11044: LD_INT 0
11046: PUSH
11047: EMPTY
11048: LIST
11049: LIST
11050: PUSH
11051: LD_INT 30
11053: PUSH
11054: LD_INT 1
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: PUSH
11061: LD_INT 25
11063: PUSH
11064: LD_INT 4
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: LIST
11078: LIST
11079: PPUSH
11080: CALL_OW 72
11084: ST_TO_ADDR
// if tmp then
11085: LD_VAR 0 5
11089: IFFALSE 11145
// begin k := NearestUnitToUnit ( tmp , j ) ;
11091: LD_ADDR_VAR 0 4
11095: PUSH
11096: LD_VAR 0 5
11100: PPUSH
11101: LD_VAR 0 3
11105: PPUSH
11106: CALL_OW 74
11110: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
11111: LD_VAR 0 3
11115: PPUSH
11116: LD_VAR 0 4
11120: PPUSH
11121: CALL_OW 296
11125: PUSH
11126: LD_INT 7
11128: GREATER
11129: IFFALSE 11145
// ComMoveUnit ( j , k ) ;
11131: LD_VAR 0 3
11135: PPUSH
11136: LD_VAR 0 4
11140: PPUSH
11141: CALL_OW 112
// end ; end ;
11145: GO 10989
11147: POP
11148: POP
// if not need_heal_1 and not need_heal_2 then
11149: LD_VAR 0 6
11153: NOT
11154: PUSH
11155: LD_VAR 0 7
11159: NOT
11160: AND
11161: IFFALSE 11165
// continue ;
11163: GO 10618
// end ;
11165: GO 10618
11167: POP
11168: POP
// RaiseSailEvent ( 102 ) ;
11169: LD_INT 102
11171: PPUSH
11172: CALL_OW 427
// end ;
11176: LD_VAR 0 1
11180: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
11181: LD_INT 0
11183: PPUSH
11184: PPUSH
11185: PPUSH
11186: PPUSH
11187: PPUSH
// if not mc_bases then
11188: LD_EXP 57
11192: NOT
11193: IFFALSE 11197
// exit ;
11195: GO 11582
// for i = 1 to mc_bases do
11197: LD_ADDR_VAR 0 2
11201: PUSH
11202: DOUBLE
11203: LD_INT 1
11205: DEC
11206: ST_TO_ADDR
11207: LD_EXP 57
11211: PUSH
11212: FOR_TO
11213: IFFALSE 11580
// begin if not mc_building_need_repair [ i ] then
11215: LD_EXP 58
11219: PUSH
11220: LD_VAR 0 2
11224: ARRAY
11225: NOT
11226: IFFALSE 11264
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
11228: LD_ADDR_EXP 59
11232: PUSH
11233: LD_EXP 59
11237: PPUSH
11238: LD_VAR 0 2
11242: PPUSH
11243: EMPTY
11244: PPUSH
11245: CALL_OW 1
11249: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
11250: LD_VAR 0 2
11254: PPUSH
11255: LD_INT 101
11257: PPUSH
11258: CALL 6625 0 2
// continue ;
11262: GO 11212
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
11264: LD_ADDR_EXP 63
11268: PUSH
11269: LD_EXP 63
11273: PPUSH
11274: LD_VAR 0 2
11278: PPUSH
11279: EMPTY
11280: PPUSH
11281: CALL_OW 1
11285: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_INT 103
11293: PPUSH
11294: CALL 6625 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
11298: LD_ADDR_VAR 0 5
11302: PUSH
11303: LD_EXP 57
11307: PUSH
11308: LD_VAR 0 2
11312: ARRAY
11313: PUSH
11314: LD_EXP 86
11318: PUSH
11319: LD_VAR 0 2
11323: ARRAY
11324: UNION
11325: PPUSH
11326: LD_INT 2
11328: PUSH
11329: LD_INT 25
11331: PUSH
11332: LD_INT 2
11334: PUSH
11335: EMPTY
11336: LIST
11337: LIST
11338: PUSH
11339: LD_INT 25
11341: PUSH
11342: LD_INT 16
11344: PUSH
11345: EMPTY
11346: LIST
11347: LIST
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: LIST
11353: PUSH
11354: EMPTY
11355: LIST
11356: PPUSH
11357: CALL_OW 72
11361: ST_TO_ADDR
// if not tmp then
11362: LD_VAR 0 5
11366: NOT
11367: IFFALSE 11371
// continue ;
11369: GO 11212
// for j in tmp do
11371: LD_ADDR_VAR 0 3
11375: PUSH
11376: LD_VAR 0 5
11380: PUSH
11381: FOR_IN
11382: IFFALSE 11576
// begin if mc_need_heal [ i ] then
11384: LD_EXP 60
11388: PUSH
11389: LD_VAR 0 2
11393: ARRAY
11394: IFFALSE 11442
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
11396: LD_VAR 0 3
11400: PUSH
11401: LD_EXP 60
11405: PUSH
11406: LD_VAR 0 2
11410: ARRAY
11411: PUSH
11412: LD_INT 1
11414: ARRAY
11415: IN
11416: PUSH
11417: LD_VAR 0 3
11421: PUSH
11422: LD_EXP 60
11426: PUSH
11427: LD_VAR 0 2
11431: ARRAY
11432: PUSH
11433: LD_INT 2
11435: ARRAY
11436: IN
11437: OR
11438: IFFALSE 11442
// continue ;
11440: GO 11381
// if IsInUnit ( j ) then
11442: LD_VAR 0 3
11446: PPUSH
11447: CALL_OW 310
11451: IFFALSE 11462
// ComExitBuilding ( j ) ;
11453: LD_VAR 0 3
11457: PPUSH
11458: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
11462: LD_VAR 0 3
11466: PUSH
11467: LD_EXP 59
11471: PUSH
11472: LD_VAR 0 2
11476: ARRAY
11477: IN
11478: NOT
11479: IFFALSE 11537
// begin SetTag ( j , 101 ) ;
11481: LD_VAR 0 3
11485: PPUSH
11486: LD_INT 101
11488: PPUSH
11489: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
11493: LD_ADDR_EXP 59
11497: PUSH
11498: LD_EXP 59
11502: PPUSH
11503: LD_VAR 0 2
11507: PUSH
11508: LD_EXP 59
11512: PUSH
11513: LD_VAR 0 2
11517: ARRAY
11518: PUSH
11519: LD_INT 1
11521: PLUS
11522: PUSH
11523: EMPTY
11524: LIST
11525: LIST
11526: PPUSH
11527: LD_VAR 0 3
11531: PPUSH
11532: CALL 37882 0 3
11536: ST_TO_ADDR
// end ; wait ( 1 ) ;
11537: LD_INT 1
11539: PPUSH
11540: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
11544: LD_VAR 0 3
11548: PPUSH
11549: LD_EXP 58
11553: PUSH
11554: LD_VAR 0 2
11558: ARRAY
11559: PPUSH
11560: LD_VAR 0 3
11564: PPUSH
11565: CALL_OW 74
11569: PPUSH
11570: CALL_OW 130
// end ;
11574: GO 11381
11576: POP
11577: POP
// end ;
11578: GO 11212
11580: POP
11581: POP
// end ;
11582: LD_VAR 0 1
11586: RET
// export function MC_Heal ; var i , j , tmp ; begin
11587: LD_INT 0
11589: PPUSH
11590: PPUSH
11591: PPUSH
11592: PPUSH
// if not mc_bases then
11593: LD_EXP 57
11597: NOT
11598: IFFALSE 11602
// exit ;
11600: GO 12004
// for i = 1 to mc_bases do
11602: LD_ADDR_VAR 0 2
11606: PUSH
11607: DOUBLE
11608: LD_INT 1
11610: DEC
11611: ST_TO_ADDR
11612: LD_EXP 57
11616: PUSH
11617: FOR_TO
11618: IFFALSE 12002
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
11620: LD_EXP 60
11624: PUSH
11625: LD_VAR 0 2
11629: ARRAY
11630: PUSH
11631: LD_INT 1
11633: ARRAY
11634: NOT
11635: PUSH
11636: LD_EXP 60
11640: PUSH
11641: LD_VAR 0 2
11645: ARRAY
11646: PUSH
11647: LD_INT 2
11649: ARRAY
11650: NOT
11651: AND
11652: IFFALSE 11690
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
11654: LD_ADDR_EXP 61
11658: PUSH
11659: LD_EXP 61
11663: PPUSH
11664: LD_VAR 0 2
11668: PPUSH
11669: EMPTY
11670: PPUSH
11671: CALL_OW 1
11675: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
11676: LD_VAR 0 2
11680: PPUSH
11681: LD_INT 102
11683: PPUSH
11684: CALL 6625 0 2
// continue ;
11688: GO 11617
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
11690: LD_ADDR_VAR 0 4
11694: PUSH
11695: LD_EXP 57
11699: PUSH
11700: LD_VAR 0 2
11704: ARRAY
11705: PPUSH
11706: LD_INT 25
11708: PUSH
11709: LD_INT 4
11711: PUSH
11712: EMPTY
11713: LIST
11714: LIST
11715: PPUSH
11716: CALL_OW 72
11720: ST_TO_ADDR
// if not tmp then
11721: LD_VAR 0 4
11725: NOT
11726: IFFALSE 11730
// continue ;
11728: GO 11617
// if mc_taming [ i ] then
11730: LD_EXP 88
11734: PUSH
11735: LD_VAR 0 2
11739: ARRAY
11740: IFFALSE 11764
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
11742: LD_ADDR_EXP 88
11746: PUSH
11747: LD_EXP 88
11751: PPUSH
11752: LD_VAR 0 2
11756: PPUSH
11757: EMPTY
11758: PPUSH
11759: CALL_OW 1
11763: ST_TO_ADDR
// for j in tmp do
11764: LD_ADDR_VAR 0 3
11768: PUSH
11769: LD_VAR 0 4
11773: PUSH
11774: FOR_IN
11775: IFFALSE 11998
// begin if IsInUnit ( j ) then
11777: LD_VAR 0 3
11781: PPUSH
11782: CALL_OW 310
11786: IFFALSE 11797
// ComExitBuilding ( j ) ;
11788: LD_VAR 0 3
11792: PPUSH
11793: CALL_OW 122
// if not j in mc_healers [ i ] then
11797: LD_VAR 0 3
11801: PUSH
11802: LD_EXP 61
11806: PUSH
11807: LD_VAR 0 2
11811: ARRAY
11812: IN
11813: NOT
11814: IFFALSE 11860
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
11816: LD_ADDR_EXP 61
11820: PUSH
11821: LD_EXP 61
11825: PPUSH
11826: LD_VAR 0 2
11830: PUSH
11831: LD_EXP 61
11835: PUSH
11836: LD_VAR 0 2
11840: ARRAY
11841: PUSH
11842: LD_INT 1
11844: PLUS
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PPUSH
11850: LD_VAR 0 3
11854: PPUSH
11855: CALL 37882 0 3
11859: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
11860: LD_VAR 0 3
11864: PPUSH
11865: CALL_OW 110
11869: PUSH
11870: LD_INT 102
11872: NONEQUAL
11873: IFFALSE 11887
// SetTag ( j , 102 ) ;
11875: LD_VAR 0 3
11879: PPUSH
11880: LD_INT 102
11882: PPUSH
11883: CALL_OW 109
// Wait ( 3 ) ;
11887: LD_INT 3
11889: PPUSH
11890: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
11894: LD_EXP 60
11898: PUSH
11899: LD_VAR 0 2
11903: ARRAY
11904: PUSH
11905: LD_INT 1
11907: ARRAY
11908: IFFALSE 11940
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
11910: LD_VAR 0 3
11914: PPUSH
11915: LD_EXP 60
11919: PUSH
11920: LD_VAR 0 2
11924: ARRAY
11925: PUSH
11926: LD_INT 1
11928: ARRAY
11929: PUSH
11930: LD_INT 1
11932: ARRAY
11933: PPUSH
11934: CALL_OW 128
11938: GO 11996
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
11940: LD_VAR 0 3
11944: PPUSH
11945: CALL_OW 314
11949: NOT
11950: PUSH
11951: LD_EXP 60
11955: PUSH
11956: LD_VAR 0 2
11960: ARRAY
11961: PUSH
11962: LD_INT 2
11964: ARRAY
11965: AND
11966: IFFALSE 11996
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
11968: LD_VAR 0 3
11972: PPUSH
11973: LD_EXP 60
11977: PUSH
11978: LD_VAR 0 2
11982: ARRAY
11983: PUSH
11984: LD_INT 2
11986: ARRAY
11987: PUSH
11988: LD_INT 1
11990: ARRAY
11991: PPUSH
11992: CALL_OW 128
// end ;
11996: GO 11774
11998: POP
11999: POP
// end ;
12000: GO 11617
12002: POP
12003: POP
// end ;
12004: LD_VAR 0 1
12008: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
12009: LD_INT 0
12011: PPUSH
12012: PPUSH
12013: PPUSH
12014: PPUSH
12015: PPUSH
// if not mc_bases then
12016: LD_EXP 57
12020: NOT
12021: IFFALSE 12025
// exit ;
12023: GO 13168
// for i = 1 to mc_bases do
12025: LD_ADDR_VAR 0 2
12029: PUSH
12030: DOUBLE
12031: LD_INT 1
12033: DEC
12034: ST_TO_ADDR
12035: LD_EXP 57
12039: PUSH
12040: FOR_TO
12041: IFFALSE 13166
// begin if mc_scan [ i ] then
12043: LD_EXP 80
12047: PUSH
12048: LD_VAR 0 2
12052: ARRAY
12053: IFFALSE 12057
// continue ;
12055: GO 12040
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
12057: LD_EXP 62
12061: PUSH
12062: LD_VAR 0 2
12066: ARRAY
12067: NOT
12068: PUSH
12069: LD_EXP 64
12073: PUSH
12074: LD_VAR 0 2
12078: ARRAY
12079: NOT
12080: AND
12081: PUSH
12082: LD_EXP 63
12086: PUSH
12087: LD_VAR 0 2
12091: ARRAY
12092: AND
12093: IFFALSE 12131
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
12095: LD_ADDR_EXP 63
12099: PUSH
12100: LD_EXP 63
12104: PPUSH
12105: LD_VAR 0 2
12109: PPUSH
12110: EMPTY
12111: PPUSH
12112: CALL_OW 1
12116: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
12117: LD_VAR 0 2
12121: PPUSH
12122: LD_INT 103
12124: PPUSH
12125: CALL 6625 0 2
// continue ;
12129: GO 12040
// end ; if mc_construct_list [ i ] then
12131: LD_EXP 64
12135: PUSH
12136: LD_VAR 0 2
12140: ARRAY
12141: IFFALSE 12361
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
12143: LD_ADDR_VAR 0 4
12147: PUSH
12148: LD_EXP 57
12152: PUSH
12153: LD_VAR 0 2
12157: ARRAY
12158: PPUSH
12159: LD_INT 25
12161: PUSH
12162: LD_INT 2
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PPUSH
12169: CALL_OW 72
12173: PUSH
12174: LD_EXP 59
12178: PUSH
12179: LD_VAR 0 2
12183: ARRAY
12184: DIFF
12185: ST_TO_ADDR
// if not tmp then
12186: LD_VAR 0 4
12190: NOT
12191: IFFALSE 12195
// continue ;
12193: GO 12040
// for j in tmp do
12195: LD_ADDR_VAR 0 3
12199: PUSH
12200: LD_VAR 0 4
12204: PUSH
12205: FOR_IN
12206: IFFALSE 12357
// begin if not mc_builders [ i ] then
12208: LD_EXP 63
12212: PUSH
12213: LD_VAR 0 2
12217: ARRAY
12218: NOT
12219: IFFALSE 12277
// begin SetTag ( j , 103 ) ;
12221: LD_VAR 0 3
12225: PPUSH
12226: LD_INT 103
12228: PPUSH
12229: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
12233: LD_ADDR_EXP 63
12237: PUSH
12238: LD_EXP 63
12242: PPUSH
12243: LD_VAR 0 2
12247: PUSH
12248: LD_EXP 63
12252: PUSH
12253: LD_VAR 0 2
12257: ARRAY
12258: PUSH
12259: LD_INT 1
12261: PLUS
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: PPUSH
12267: LD_VAR 0 3
12271: PPUSH
12272: CALL 37882 0 3
12276: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
12277: LD_VAR 0 3
12281: PPUSH
12282: CALL_OW 310
12286: IFFALSE 12297
// ComExitBuilding ( j ) ;
12288: LD_VAR 0 3
12292: PPUSH
12293: CALL_OW 122
// wait ( 3 ) ;
12297: LD_INT 3
12299: PPUSH
12300: CALL_OW 67
// if not mc_construct_list [ i ] then
12304: LD_EXP 64
12308: PUSH
12309: LD_VAR 0 2
12313: ARRAY
12314: NOT
12315: IFFALSE 12319
// break ;
12317: GO 12357
// if not HasTask ( j ) then
12319: LD_VAR 0 3
12323: PPUSH
12324: CALL_OW 314
12328: NOT
12329: IFFALSE 12355
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
12331: LD_VAR 0 3
12335: PPUSH
12336: LD_EXP 64
12340: PUSH
12341: LD_VAR 0 2
12345: ARRAY
12346: PUSH
12347: LD_INT 1
12349: ARRAY
12350: PPUSH
12351: CALL 40733 0 2
// end ;
12355: GO 12205
12357: POP
12358: POP
// end else
12359: GO 13164
// if mc_build_list [ i ] then
12361: LD_EXP 62
12365: PUSH
12366: LD_VAR 0 2
12370: ARRAY
12371: IFFALSE 13164
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
12373: LD_ADDR_VAR 0 5
12377: PUSH
12378: LD_EXP 57
12382: PUSH
12383: LD_VAR 0 2
12387: ARRAY
12388: PPUSH
12389: LD_INT 2
12391: PUSH
12392: LD_INT 30
12394: PUSH
12395: LD_INT 0
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PUSH
12402: LD_INT 30
12404: PUSH
12405: LD_INT 1
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: LIST
12416: PPUSH
12417: CALL_OW 72
12421: ST_TO_ADDR
// if depot then
12422: LD_VAR 0 5
12426: IFFALSE 12444
// depot := depot [ 1 ] else
12428: LD_ADDR_VAR 0 5
12432: PUSH
12433: LD_VAR 0 5
12437: PUSH
12438: LD_INT 1
12440: ARRAY
12441: ST_TO_ADDR
12442: GO 12452
// depot := 0 ;
12444: LD_ADDR_VAR 0 5
12448: PUSH
12449: LD_INT 0
12451: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
12452: LD_EXP 62
12456: PUSH
12457: LD_VAR 0 2
12461: ARRAY
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PUSH
12467: LD_INT 1
12469: ARRAY
12470: PPUSH
12471: CALL 40563 0 1
12475: PUSH
12476: LD_EXP 57
12480: PUSH
12481: LD_VAR 0 2
12485: ARRAY
12486: PPUSH
12487: LD_INT 2
12489: PUSH
12490: LD_INT 30
12492: PUSH
12493: LD_INT 2
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: LD_INT 30
12502: PUSH
12503: LD_INT 3
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: LIST
12514: PPUSH
12515: CALL_OW 72
12519: NOT
12520: AND
12521: IFFALSE 12626
// begin for j = 1 to mc_build_list [ i ] do
12523: LD_ADDR_VAR 0 3
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_EXP 62
12537: PUSH
12538: LD_VAR 0 2
12542: ARRAY
12543: PUSH
12544: FOR_TO
12545: IFFALSE 12624
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
12547: LD_EXP 62
12551: PUSH
12552: LD_VAR 0 2
12556: ARRAY
12557: PUSH
12558: LD_VAR 0 3
12562: ARRAY
12563: PUSH
12564: LD_INT 1
12566: ARRAY
12567: PUSH
12568: LD_INT 2
12570: EQUAL
12571: IFFALSE 12622
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
12573: LD_ADDR_EXP 62
12577: PUSH
12578: LD_EXP 62
12582: PPUSH
12583: LD_VAR 0 2
12587: PPUSH
12588: LD_EXP 62
12592: PUSH
12593: LD_VAR 0 2
12597: ARRAY
12598: PPUSH
12599: LD_VAR 0 3
12603: PPUSH
12604: LD_INT 1
12606: PPUSH
12607: LD_INT 0
12609: PPUSH
12610: CALL 37300 0 4
12614: PPUSH
12615: CALL_OW 1
12619: ST_TO_ADDR
// break ;
12620: GO 12624
// end ;
12622: GO 12544
12624: POP
12625: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
12626: LD_EXP 62
12630: PUSH
12631: LD_VAR 0 2
12635: ARRAY
12636: PUSH
12637: LD_INT 1
12639: ARRAY
12640: PUSH
12641: LD_INT 1
12643: ARRAY
12644: PUSH
12645: LD_INT 0
12647: EQUAL
12648: PUSH
12649: LD_VAR 0 5
12653: PUSH
12654: LD_VAR 0 5
12658: PPUSH
12659: LD_EXP 62
12663: PUSH
12664: LD_VAR 0 2
12668: ARRAY
12669: PUSH
12670: LD_INT 1
12672: ARRAY
12673: PUSH
12674: LD_INT 1
12676: ARRAY
12677: PPUSH
12678: LD_EXP 62
12682: PUSH
12683: LD_VAR 0 2
12687: ARRAY
12688: PUSH
12689: LD_INT 1
12691: ARRAY
12692: PUSH
12693: LD_INT 2
12695: ARRAY
12696: PPUSH
12697: LD_EXP 62
12701: PUSH
12702: LD_VAR 0 2
12706: ARRAY
12707: PUSH
12708: LD_INT 1
12710: ARRAY
12711: PUSH
12712: LD_INT 3
12714: ARRAY
12715: PPUSH
12716: LD_EXP 62
12720: PUSH
12721: LD_VAR 0 2
12725: ARRAY
12726: PUSH
12727: LD_INT 1
12729: ARRAY
12730: PUSH
12731: LD_INT 4
12733: ARRAY
12734: PPUSH
12735: CALL 45279 0 5
12739: AND
12740: OR
12741: IFFALSE 13022
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
12743: LD_ADDR_VAR 0 4
12747: PUSH
12748: LD_EXP 57
12752: PUSH
12753: LD_VAR 0 2
12757: ARRAY
12758: PPUSH
12759: LD_INT 25
12761: PUSH
12762: LD_INT 2
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: PUSH
12774: LD_EXP 59
12778: PUSH
12779: LD_VAR 0 2
12783: ARRAY
12784: DIFF
12785: ST_TO_ADDR
// if not tmp then
12786: LD_VAR 0 4
12790: NOT
12791: IFFALSE 12795
// continue ;
12793: GO 12040
// for j in tmp do
12795: LD_ADDR_VAR 0 3
12799: PUSH
12800: LD_VAR 0 4
12804: PUSH
12805: FOR_IN
12806: IFFALSE 13018
// begin if not mc_builders [ i ] then
12808: LD_EXP 63
12812: PUSH
12813: LD_VAR 0 2
12817: ARRAY
12818: NOT
12819: IFFALSE 12877
// begin SetTag ( j , 103 ) ;
12821: LD_VAR 0 3
12825: PPUSH
12826: LD_INT 103
12828: PPUSH
12829: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
12833: LD_ADDR_EXP 63
12837: PUSH
12838: LD_EXP 63
12842: PPUSH
12843: LD_VAR 0 2
12847: PUSH
12848: LD_EXP 63
12852: PUSH
12853: LD_VAR 0 2
12857: ARRAY
12858: PUSH
12859: LD_INT 1
12861: PLUS
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PPUSH
12867: LD_VAR 0 3
12871: PPUSH
12872: CALL 37882 0 3
12876: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
12877: LD_VAR 0 3
12881: PPUSH
12882: CALL_OW 310
12886: IFFALSE 12897
// ComExitBuilding ( j ) ;
12888: LD_VAR 0 3
12892: PPUSH
12893: CALL_OW 122
// wait ( 3 ) ;
12897: LD_INT 3
12899: PPUSH
12900: CALL_OW 67
// if not mc_build_list [ i ] then
12904: LD_EXP 62
12908: PUSH
12909: LD_VAR 0 2
12913: ARRAY
12914: NOT
12915: IFFALSE 12919
// break ;
12917: GO 13018
// if not HasTask ( j ) then
12919: LD_VAR 0 3
12923: PPUSH
12924: CALL_OW 314
12928: NOT
12929: IFFALSE 13016
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
12931: LD_VAR 0 3
12935: PPUSH
12936: LD_EXP 62
12940: PUSH
12941: LD_VAR 0 2
12945: ARRAY
12946: PUSH
12947: LD_INT 1
12949: ARRAY
12950: PUSH
12951: LD_INT 1
12953: ARRAY
12954: PPUSH
12955: LD_EXP 62
12959: PUSH
12960: LD_VAR 0 2
12964: ARRAY
12965: PUSH
12966: LD_INT 1
12968: ARRAY
12969: PUSH
12970: LD_INT 2
12972: ARRAY
12973: PPUSH
12974: LD_EXP 62
12978: PUSH
12979: LD_VAR 0 2
12983: ARRAY
12984: PUSH
12985: LD_INT 1
12987: ARRAY
12988: PUSH
12989: LD_INT 3
12991: ARRAY
12992: PPUSH
12993: LD_EXP 62
12997: PUSH
12998: LD_VAR 0 2
13002: ARRAY
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: PUSH
13008: LD_INT 4
13010: ARRAY
13011: PPUSH
13012: CALL_OW 145
// end ;
13016: GO 12805
13018: POP
13019: POP
// end else
13020: GO 13164
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
13022: LD_EXP 57
13026: PUSH
13027: LD_VAR 0 2
13031: ARRAY
13032: PPUSH
13033: LD_EXP 62
13037: PUSH
13038: LD_VAR 0 2
13042: ARRAY
13043: PUSH
13044: LD_INT 1
13046: ARRAY
13047: PUSH
13048: LD_INT 1
13050: ARRAY
13051: PPUSH
13052: LD_EXP 62
13056: PUSH
13057: LD_VAR 0 2
13061: ARRAY
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PUSH
13067: LD_INT 2
13069: ARRAY
13070: PPUSH
13071: LD_EXP 62
13075: PUSH
13076: LD_VAR 0 2
13080: ARRAY
13081: PUSH
13082: LD_INT 1
13084: ARRAY
13085: PUSH
13086: LD_INT 3
13088: ARRAY
13089: PPUSH
13090: LD_EXP 62
13094: PUSH
13095: LD_VAR 0 2
13099: ARRAY
13100: PUSH
13101: LD_INT 1
13103: ARRAY
13104: PUSH
13105: LD_INT 4
13107: ARRAY
13108: PPUSH
13109: CALL 44633 0 5
13113: NOT
13114: IFFALSE 13164
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
13116: LD_ADDR_EXP 62
13120: PUSH
13121: LD_EXP 62
13125: PPUSH
13126: LD_VAR 0 2
13130: PPUSH
13131: LD_EXP 62
13135: PUSH
13136: LD_VAR 0 2
13140: ARRAY
13141: PPUSH
13142: LD_INT 1
13144: PPUSH
13145: LD_INT 1
13147: NEG
13148: PPUSH
13149: LD_INT 0
13151: PPUSH
13152: CALL 37300 0 4
13156: PPUSH
13157: CALL_OW 1
13161: ST_TO_ADDR
// continue ;
13162: GO 12040
// end ; end ; end ;
13164: GO 12040
13166: POP
13167: POP
// end ;
13168: LD_VAR 0 1
13172: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
13173: LD_INT 0
13175: PPUSH
13176: PPUSH
13177: PPUSH
13178: PPUSH
13179: PPUSH
13180: PPUSH
// if not mc_bases then
13181: LD_EXP 57
13185: NOT
13186: IFFALSE 13190
// exit ;
13188: GO 13617
// for i = 1 to mc_bases do
13190: LD_ADDR_VAR 0 2
13194: PUSH
13195: DOUBLE
13196: LD_INT 1
13198: DEC
13199: ST_TO_ADDR
13200: LD_EXP 57
13204: PUSH
13205: FOR_TO
13206: IFFALSE 13615
// begin tmp := mc_build_upgrade [ i ] ;
13208: LD_ADDR_VAR 0 4
13212: PUSH
13213: LD_EXP 89
13217: PUSH
13218: LD_VAR 0 2
13222: ARRAY
13223: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
13224: LD_ADDR_VAR 0 6
13228: PUSH
13229: LD_EXP 90
13233: PUSH
13234: LD_VAR 0 2
13238: ARRAY
13239: PPUSH
13240: LD_INT 2
13242: PUSH
13243: LD_INT 30
13245: PUSH
13246: LD_INT 6
13248: PUSH
13249: EMPTY
13250: LIST
13251: LIST
13252: PUSH
13253: LD_INT 30
13255: PUSH
13256: LD_INT 7
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: PUSH
13263: EMPTY
13264: LIST
13265: LIST
13266: LIST
13267: PPUSH
13268: CALL_OW 72
13272: ST_TO_ADDR
// if not tmp and not lab then
13273: LD_VAR 0 4
13277: NOT
13278: PUSH
13279: LD_VAR 0 6
13283: NOT
13284: AND
13285: IFFALSE 13289
// continue ;
13287: GO 13205
// if tmp then
13289: LD_VAR 0 4
13293: IFFALSE 13413
// for j in tmp do
13295: LD_ADDR_VAR 0 3
13299: PUSH
13300: LD_VAR 0 4
13304: PUSH
13305: FOR_IN
13306: IFFALSE 13411
// begin if UpgradeCost ( j ) then
13308: LD_VAR 0 3
13312: PPUSH
13313: CALL 44293 0 1
13317: IFFALSE 13409
// begin ComUpgrade ( j ) ;
13319: LD_VAR 0 3
13323: PPUSH
13324: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
13328: LD_ADDR_EXP 89
13332: PUSH
13333: LD_EXP 89
13337: PPUSH
13338: LD_VAR 0 2
13342: PPUSH
13343: LD_EXP 89
13347: PUSH
13348: LD_VAR 0 2
13352: ARRAY
13353: PUSH
13354: LD_VAR 0 3
13358: DIFF
13359: PPUSH
13360: CALL_OW 1
13364: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
13365: LD_ADDR_EXP 64
13369: PUSH
13370: LD_EXP 64
13374: PPUSH
13375: LD_VAR 0 2
13379: PUSH
13380: LD_EXP 64
13384: PUSH
13385: LD_VAR 0 2
13389: ARRAY
13390: PUSH
13391: LD_INT 1
13393: PLUS
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PPUSH
13399: LD_VAR 0 3
13403: PPUSH
13404: CALL 37882 0 3
13408: ST_TO_ADDR
// end ; end ;
13409: GO 13305
13411: POP
13412: POP
// if not lab or not mc_lab_upgrade [ i ] then
13413: LD_VAR 0 6
13417: NOT
13418: PUSH
13419: LD_EXP 91
13423: PUSH
13424: LD_VAR 0 2
13428: ARRAY
13429: NOT
13430: OR
13431: IFFALSE 13435
// continue ;
13433: GO 13205
// for j in lab do
13435: LD_ADDR_VAR 0 3
13439: PUSH
13440: LD_VAR 0 6
13444: PUSH
13445: FOR_IN
13446: IFFALSE 13611
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
13448: LD_VAR 0 3
13452: PPUSH
13453: CALL_OW 266
13457: PUSH
13458: LD_INT 6
13460: PUSH
13461: LD_INT 7
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: IN
13468: PUSH
13469: LD_VAR 0 3
13473: PPUSH
13474: CALL_OW 461
13478: PUSH
13479: LD_INT 1
13481: NONEQUAL
13482: AND
13483: IFFALSE 13609
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
13485: LD_VAR 0 3
13489: PPUSH
13490: LD_EXP 91
13494: PUSH
13495: LD_VAR 0 2
13499: ARRAY
13500: PUSH
13501: LD_INT 1
13503: ARRAY
13504: PPUSH
13505: CALL 44498 0 2
13509: IFFALSE 13609
// begin ComCancel ( j ) ;
13511: LD_VAR 0 3
13515: PPUSH
13516: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
13520: LD_VAR 0 3
13524: PPUSH
13525: LD_EXP 91
13529: PUSH
13530: LD_VAR 0 2
13534: ARRAY
13535: PUSH
13536: LD_INT 1
13538: ARRAY
13539: PPUSH
13540: CALL_OW 207
// if not j in mc_construct_list [ i ] then
13544: LD_VAR 0 3
13548: PUSH
13549: LD_EXP 64
13553: PUSH
13554: LD_VAR 0 2
13558: ARRAY
13559: IN
13560: NOT
13561: IFFALSE 13607
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
13563: LD_ADDR_EXP 64
13567: PUSH
13568: LD_EXP 64
13572: PPUSH
13573: LD_VAR 0 2
13577: PUSH
13578: LD_EXP 64
13582: PUSH
13583: LD_VAR 0 2
13587: ARRAY
13588: PUSH
13589: LD_INT 1
13591: PLUS
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PPUSH
13597: LD_VAR 0 3
13601: PPUSH
13602: CALL 37882 0 3
13606: ST_TO_ADDR
// break ;
13607: GO 13611
// end ; end ; end ;
13609: GO 13445
13611: POP
13612: POP
// end ;
13613: GO 13205
13615: POP
13616: POP
// end ;
13617: LD_VAR 0 1
13621: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
13622: LD_INT 0
13624: PPUSH
13625: PPUSH
13626: PPUSH
13627: PPUSH
13628: PPUSH
13629: PPUSH
13630: PPUSH
13631: PPUSH
13632: PPUSH
// if not mc_bases then
13633: LD_EXP 57
13637: NOT
13638: IFFALSE 13642
// exit ;
13640: GO 14047
// for i = 1 to mc_bases do
13642: LD_ADDR_VAR 0 2
13646: PUSH
13647: DOUBLE
13648: LD_INT 1
13650: DEC
13651: ST_TO_ADDR
13652: LD_EXP 57
13656: PUSH
13657: FOR_TO
13658: IFFALSE 14045
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
13660: LD_EXP 65
13664: PUSH
13665: LD_VAR 0 2
13669: ARRAY
13670: NOT
13671: PUSH
13672: LD_EXP 57
13676: PUSH
13677: LD_VAR 0 2
13681: ARRAY
13682: PPUSH
13683: LD_INT 30
13685: PUSH
13686: LD_INT 3
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 72
13697: NOT
13698: OR
13699: IFFALSE 13703
// continue ;
13701: GO 13657
// busy := false ;
13703: LD_ADDR_VAR 0 8
13707: PUSH
13708: LD_INT 0
13710: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
13711: LD_ADDR_VAR 0 4
13715: PUSH
13716: LD_EXP 57
13720: PUSH
13721: LD_VAR 0 2
13725: ARRAY
13726: PPUSH
13727: LD_INT 30
13729: PUSH
13730: LD_INT 3
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PPUSH
13737: CALL_OW 72
13741: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
13742: LD_ADDR_VAR 0 6
13746: PUSH
13747: LD_EXP 65
13751: PUSH
13752: LD_VAR 0 2
13756: ARRAY
13757: PPUSH
13758: LD_INT 2
13760: PUSH
13761: LD_INT 30
13763: PUSH
13764: LD_INT 32
13766: PUSH
13767: EMPTY
13768: LIST
13769: LIST
13770: PUSH
13771: LD_INT 30
13773: PUSH
13774: LD_INT 33
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: PUSH
13781: EMPTY
13782: LIST
13783: LIST
13784: LIST
13785: PPUSH
13786: CALL_OW 72
13790: ST_TO_ADDR
// if not t then
13791: LD_VAR 0 6
13795: NOT
13796: IFFALSE 13800
// continue ;
13798: GO 13657
// for j in tmp do
13800: LD_ADDR_VAR 0 3
13804: PUSH
13805: LD_VAR 0 4
13809: PUSH
13810: FOR_IN
13811: IFFALSE 13841
// if not BuildingStatus ( j ) = bs_idle then
13813: LD_VAR 0 3
13817: PPUSH
13818: CALL_OW 461
13822: PUSH
13823: LD_INT 2
13825: EQUAL
13826: NOT
13827: IFFALSE 13839
// begin busy := true ;
13829: LD_ADDR_VAR 0 8
13833: PUSH
13834: LD_INT 1
13836: ST_TO_ADDR
// break ;
13837: GO 13841
// end ;
13839: GO 13810
13841: POP
13842: POP
// if busy then
13843: LD_VAR 0 8
13847: IFFALSE 13851
// continue ;
13849: GO 13657
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
13851: LD_ADDR_VAR 0 7
13855: PUSH
13856: LD_VAR 0 6
13860: PPUSH
13861: LD_INT 35
13863: PUSH
13864: LD_INT 0
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: PPUSH
13871: CALL_OW 72
13875: ST_TO_ADDR
// if tw then
13876: LD_VAR 0 7
13880: IFFALSE 13957
// begin tw := tw [ 1 ] ;
13882: LD_ADDR_VAR 0 7
13886: PUSH
13887: LD_VAR 0 7
13891: PUSH
13892: LD_INT 1
13894: ARRAY
13895: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
13896: LD_ADDR_VAR 0 9
13900: PUSH
13901: LD_VAR 0 7
13905: PPUSH
13906: LD_EXP 82
13910: PUSH
13911: LD_VAR 0 2
13915: ARRAY
13916: PPUSH
13917: CALL 42852 0 2
13921: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
13922: LD_EXP 96
13926: PUSH
13927: LD_VAR 0 2
13931: ARRAY
13932: IFFALSE 13955
// if not weapon in mc_allowed_tower_weapons [ i ] then
13934: LD_VAR 0 9
13938: PUSH
13939: LD_EXP 96
13943: PUSH
13944: LD_VAR 0 2
13948: ARRAY
13949: IN
13950: NOT
13951: IFFALSE 13955
// continue ;
13953: GO 13657
// end else
13955: GO 14020
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
13957: LD_ADDR_VAR 0 5
13961: PUSH
13962: LD_EXP 65
13966: PUSH
13967: LD_VAR 0 2
13971: ARRAY
13972: PPUSH
13973: LD_VAR 0 4
13977: PPUSH
13978: CALL 72991 0 2
13982: ST_TO_ADDR
// if not tmp2 then
13983: LD_VAR 0 5
13987: NOT
13988: IFFALSE 13992
// continue ;
13990: GO 13657
// tw := tmp2 [ 1 ] ;
13992: LD_ADDR_VAR 0 7
13996: PUSH
13997: LD_VAR 0 5
14001: PUSH
14002: LD_INT 1
14004: ARRAY
14005: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
14006: LD_ADDR_VAR 0 9
14010: PUSH
14011: LD_VAR 0 5
14015: PUSH
14016: LD_INT 2
14018: ARRAY
14019: ST_TO_ADDR
// end ; if not weapon then
14020: LD_VAR 0 9
14024: NOT
14025: IFFALSE 14029
// continue ;
14027: GO 13657
// ComPlaceWeapon ( tw , weapon ) ;
14029: LD_VAR 0 7
14033: PPUSH
14034: LD_VAR 0 9
14038: PPUSH
14039: CALL_OW 148
// end ;
14043: GO 13657
14045: POP
14046: POP
// end ;
14047: LD_VAR 0 1
14051: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
14052: LD_INT 0
14054: PPUSH
14055: PPUSH
14056: PPUSH
14057: PPUSH
14058: PPUSH
14059: PPUSH
// if not mc_bases then
14060: LD_EXP 57
14064: NOT
14065: IFFALSE 14069
// exit ;
14067: GO 15081
// for i = 1 to mc_bases do
14069: LD_ADDR_VAR 0 2
14073: PUSH
14074: DOUBLE
14075: LD_INT 1
14077: DEC
14078: ST_TO_ADDR
14079: LD_EXP 57
14083: PUSH
14084: FOR_TO
14085: IFFALSE 15079
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
14087: LD_EXP 70
14091: PUSH
14092: LD_VAR 0 2
14096: ARRAY
14097: NOT
14098: PUSH
14099: LD_EXP 70
14103: PUSH
14104: LD_VAR 0 2
14108: ARRAY
14109: PUSH
14110: LD_EXP 71
14114: PUSH
14115: LD_VAR 0 2
14119: ARRAY
14120: EQUAL
14121: OR
14122: IFFALSE 14126
// continue ;
14124: GO 14084
// if mc_miners [ i ] then
14126: LD_EXP 71
14130: PUSH
14131: LD_VAR 0 2
14135: ARRAY
14136: IFFALSE 14766
// begin k := 1 ;
14138: LD_ADDR_VAR 0 4
14142: PUSH
14143: LD_INT 1
14145: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
14146: LD_ADDR_VAR 0 3
14150: PUSH
14151: DOUBLE
14152: LD_EXP 71
14156: PUSH
14157: LD_VAR 0 2
14161: ARRAY
14162: INC
14163: ST_TO_ADDR
14164: LD_INT 1
14166: PUSH
14167: FOR_DOWNTO
14168: IFFALSE 14764
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
14170: LD_EXP 71
14174: PUSH
14175: LD_VAR 0 2
14179: ARRAY
14180: PUSH
14181: LD_VAR 0 3
14185: ARRAY
14186: PPUSH
14187: CALL_OW 301
14191: PUSH
14192: LD_EXP 71
14196: PUSH
14197: LD_VAR 0 2
14201: ARRAY
14202: PUSH
14203: LD_VAR 0 3
14207: ARRAY
14208: PPUSH
14209: CALL_OW 257
14213: PUSH
14214: LD_INT 1
14216: NONEQUAL
14217: OR
14218: IFFALSE 14281
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
14220: LD_ADDR_VAR 0 5
14224: PUSH
14225: LD_EXP 71
14229: PUSH
14230: LD_VAR 0 2
14234: ARRAY
14235: PUSH
14236: LD_EXP 71
14240: PUSH
14241: LD_VAR 0 2
14245: ARRAY
14246: PUSH
14247: LD_VAR 0 3
14251: ARRAY
14252: DIFF
14253: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
14254: LD_ADDR_EXP 71
14258: PUSH
14259: LD_EXP 71
14263: PPUSH
14264: LD_VAR 0 2
14268: PPUSH
14269: LD_VAR 0 5
14273: PPUSH
14274: CALL_OW 1
14278: ST_TO_ADDR
// continue ;
14279: GO 14167
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
14281: LD_EXP 71
14285: PUSH
14286: LD_VAR 0 2
14290: ARRAY
14291: PUSH
14292: LD_VAR 0 3
14296: ARRAY
14297: PPUSH
14298: CALL 37818 0 1
14302: PUSH
14303: LD_EXP 71
14307: PUSH
14308: LD_VAR 0 2
14312: ARRAY
14313: PUSH
14314: LD_VAR 0 3
14318: ARRAY
14319: PPUSH
14320: CALL_OW 255
14324: PPUSH
14325: LD_EXP 70
14329: PUSH
14330: LD_VAR 0 2
14334: ARRAY
14335: PUSH
14336: LD_VAR 0 4
14340: ARRAY
14341: PUSH
14342: LD_INT 1
14344: ARRAY
14345: PPUSH
14346: LD_EXP 70
14350: PUSH
14351: LD_VAR 0 2
14355: ARRAY
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: PUSH
14363: LD_INT 2
14365: ARRAY
14366: PPUSH
14367: LD_INT 15
14369: PPUSH
14370: CALL 38778 0 4
14374: PUSH
14375: LD_INT 4
14377: ARRAY
14378: PUSH
14379: LD_EXP 71
14383: PUSH
14384: LD_VAR 0 2
14388: ARRAY
14389: PUSH
14390: LD_VAR 0 3
14394: ARRAY
14395: PPUSH
14396: LD_INT 10
14398: PPUSH
14399: CALL 40475 0 2
14403: PUSH
14404: LD_INT 4
14406: ARRAY
14407: OR
14408: AND
14409: IFFALSE 14432
// ComStop ( mc_miners [ i ] [ j ] ) ;
14411: LD_EXP 71
14415: PUSH
14416: LD_VAR 0 2
14420: ARRAY
14421: PUSH
14422: LD_VAR 0 3
14426: ARRAY
14427: PPUSH
14428: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
14432: LD_EXP 71
14436: PUSH
14437: LD_VAR 0 2
14441: ARRAY
14442: PUSH
14443: LD_VAR 0 3
14447: ARRAY
14448: PPUSH
14449: CALL_OW 257
14453: PUSH
14454: LD_INT 1
14456: EQUAL
14457: PUSH
14458: LD_EXP 71
14462: PUSH
14463: LD_VAR 0 2
14467: ARRAY
14468: PUSH
14469: LD_VAR 0 3
14473: ARRAY
14474: PPUSH
14475: CALL_OW 459
14479: NOT
14480: AND
14481: PUSH
14482: LD_EXP 71
14486: PUSH
14487: LD_VAR 0 2
14491: ARRAY
14492: PUSH
14493: LD_VAR 0 3
14497: ARRAY
14498: PPUSH
14499: CALL_OW 255
14503: PPUSH
14504: LD_EXP 70
14508: PUSH
14509: LD_VAR 0 2
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: PUSH
14521: LD_INT 1
14523: ARRAY
14524: PPUSH
14525: LD_EXP 70
14529: PUSH
14530: LD_VAR 0 2
14534: ARRAY
14535: PUSH
14536: LD_VAR 0 4
14540: ARRAY
14541: PUSH
14542: LD_INT 2
14544: ARRAY
14545: PPUSH
14546: LD_INT 15
14548: PPUSH
14549: CALL 38778 0 4
14553: PUSH
14554: LD_INT 4
14556: ARRAY
14557: PUSH
14558: LD_INT 0
14560: EQUAL
14561: AND
14562: PUSH
14563: LD_EXP 71
14567: PUSH
14568: LD_VAR 0 2
14572: ARRAY
14573: PUSH
14574: LD_VAR 0 3
14578: ARRAY
14579: PPUSH
14580: CALL_OW 314
14584: NOT
14585: AND
14586: IFFALSE 14762
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
14588: LD_EXP 71
14592: PUSH
14593: LD_VAR 0 2
14597: ARRAY
14598: PUSH
14599: LD_VAR 0 3
14603: ARRAY
14604: PPUSH
14605: CALL_OW 310
14609: IFFALSE 14632
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
14611: LD_EXP 71
14615: PUSH
14616: LD_VAR 0 2
14620: ARRAY
14621: PUSH
14622: LD_VAR 0 3
14626: ARRAY
14627: PPUSH
14628: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
14632: LD_EXP 71
14636: PUSH
14637: LD_VAR 0 2
14641: ARRAY
14642: PUSH
14643: LD_VAR 0 3
14647: ARRAY
14648: PPUSH
14649: CALL_OW 314
14653: NOT
14654: IFFALSE 14722
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
14656: LD_EXP 71
14660: PUSH
14661: LD_VAR 0 2
14665: ARRAY
14666: PUSH
14667: LD_VAR 0 3
14671: ARRAY
14672: PPUSH
14673: LD_EXP 70
14677: PUSH
14678: LD_VAR 0 2
14682: ARRAY
14683: PUSH
14684: LD_VAR 0 4
14688: ARRAY
14689: PUSH
14690: LD_INT 1
14692: ARRAY
14693: PPUSH
14694: LD_EXP 70
14698: PUSH
14699: LD_VAR 0 2
14703: ARRAY
14704: PUSH
14705: LD_VAR 0 4
14709: ARRAY
14710: PUSH
14711: LD_INT 2
14713: ARRAY
14714: PPUSH
14715: LD_INT 0
14717: PPUSH
14718: CALL_OW 193
// k := k + 1 ;
14722: LD_ADDR_VAR 0 4
14726: PUSH
14727: LD_VAR 0 4
14731: PUSH
14732: LD_INT 1
14734: PLUS
14735: ST_TO_ADDR
// if k > mc_mines [ i ] then
14736: LD_VAR 0 4
14740: PUSH
14741: LD_EXP 70
14745: PUSH
14746: LD_VAR 0 2
14750: ARRAY
14751: GREATER
14752: IFFALSE 14762
// k := 1 ;
14754: LD_ADDR_VAR 0 4
14758: PUSH
14759: LD_INT 1
14761: ST_TO_ADDR
// end ; end ;
14762: GO 14167
14764: POP
14765: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
14766: LD_ADDR_VAR 0 5
14770: PUSH
14771: LD_EXP 57
14775: PUSH
14776: LD_VAR 0 2
14780: ARRAY
14781: PPUSH
14782: LD_INT 2
14784: PUSH
14785: LD_INT 30
14787: PUSH
14788: LD_INT 4
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: PUSH
14795: LD_INT 30
14797: PUSH
14798: LD_INT 5
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 30
14807: PUSH
14808: LD_INT 32
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: PPUSH
14821: CALL_OW 72
14825: ST_TO_ADDR
// if not tmp then
14826: LD_VAR 0 5
14830: NOT
14831: IFFALSE 14835
// continue ;
14833: GO 14084
// list := [ ] ;
14835: LD_ADDR_VAR 0 6
14839: PUSH
14840: EMPTY
14841: ST_TO_ADDR
// for j in tmp do
14842: LD_ADDR_VAR 0 3
14846: PUSH
14847: LD_VAR 0 5
14851: PUSH
14852: FOR_IN
14853: IFFALSE 14922
// begin for k in UnitsInside ( j ) do
14855: LD_ADDR_VAR 0 4
14859: PUSH
14860: LD_VAR 0 3
14864: PPUSH
14865: CALL_OW 313
14869: PUSH
14870: FOR_IN
14871: IFFALSE 14918
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
14873: LD_VAR 0 4
14877: PPUSH
14878: CALL_OW 257
14882: PUSH
14883: LD_INT 1
14885: EQUAL
14886: PUSH
14887: LD_VAR 0 4
14891: PPUSH
14892: CALL_OW 459
14896: NOT
14897: AND
14898: IFFALSE 14916
// list := list ^ k ;
14900: LD_ADDR_VAR 0 6
14904: PUSH
14905: LD_VAR 0 6
14909: PUSH
14910: LD_VAR 0 4
14914: ADD
14915: ST_TO_ADDR
14916: GO 14870
14918: POP
14919: POP
// end ;
14920: GO 14852
14922: POP
14923: POP
// list := list diff mc_miners [ i ] ;
14924: LD_ADDR_VAR 0 6
14928: PUSH
14929: LD_VAR 0 6
14933: PUSH
14934: LD_EXP 71
14938: PUSH
14939: LD_VAR 0 2
14943: ARRAY
14944: DIFF
14945: ST_TO_ADDR
// if not list then
14946: LD_VAR 0 6
14950: NOT
14951: IFFALSE 14955
// continue ;
14953: GO 14084
// k := mc_mines [ i ] - mc_miners [ i ] ;
14955: LD_ADDR_VAR 0 4
14959: PUSH
14960: LD_EXP 70
14964: PUSH
14965: LD_VAR 0 2
14969: ARRAY
14970: PUSH
14971: LD_EXP 71
14975: PUSH
14976: LD_VAR 0 2
14980: ARRAY
14981: MINUS
14982: ST_TO_ADDR
// if k > list then
14983: LD_VAR 0 4
14987: PUSH
14988: LD_VAR 0 6
14992: GREATER
14993: IFFALSE 15005
// k := list ;
14995: LD_ADDR_VAR 0 4
14999: PUSH
15000: LD_VAR 0 6
15004: ST_TO_ADDR
// for j = 1 to k do
15005: LD_ADDR_VAR 0 3
15009: PUSH
15010: DOUBLE
15011: LD_INT 1
15013: DEC
15014: ST_TO_ADDR
15015: LD_VAR 0 4
15019: PUSH
15020: FOR_TO
15021: IFFALSE 15075
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
15023: LD_ADDR_EXP 71
15027: PUSH
15028: LD_EXP 71
15032: PPUSH
15033: LD_VAR 0 2
15037: PUSH
15038: LD_EXP 71
15042: PUSH
15043: LD_VAR 0 2
15047: ARRAY
15048: PUSH
15049: LD_INT 1
15051: PLUS
15052: PUSH
15053: EMPTY
15054: LIST
15055: LIST
15056: PPUSH
15057: LD_VAR 0 6
15061: PUSH
15062: LD_VAR 0 3
15066: ARRAY
15067: PPUSH
15068: CALL 37882 0 3
15072: ST_TO_ADDR
15073: GO 15020
15075: POP
15076: POP
// end ;
15077: GO 14084
15079: POP
15080: POP
// end ;
15081: LD_VAR 0 1
15085: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
15093: PPUSH
15094: PPUSH
15095: PPUSH
15096: PPUSH
15097: PPUSH
// if not mc_bases then
15098: LD_EXP 57
15102: NOT
15103: IFFALSE 15107
// exit ;
15105: GO 16838
// for i = 1 to mc_bases do
15107: LD_ADDR_VAR 0 2
15111: PUSH
15112: DOUBLE
15113: LD_INT 1
15115: DEC
15116: ST_TO_ADDR
15117: LD_EXP 57
15121: PUSH
15122: FOR_TO
15123: IFFALSE 16836
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
15125: LD_EXP 57
15129: PUSH
15130: LD_VAR 0 2
15134: ARRAY
15135: NOT
15136: PUSH
15137: LD_EXP 64
15141: PUSH
15142: LD_VAR 0 2
15146: ARRAY
15147: OR
15148: IFFALSE 15152
// continue ;
15150: GO 15122
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
15152: LD_EXP 73
15156: PUSH
15157: LD_VAR 0 2
15161: ARRAY
15162: NOT
15163: PUSH
15164: LD_EXP 74
15168: PUSH
15169: LD_VAR 0 2
15173: ARRAY
15174: AND
15175: IFFALSE 15213
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
15177: LD_ADDR_EXP 74
15181: PUSH
15182: LD_EXP 74
15186: PPUSH
15187: LD_VAR 0 2
15191: PPUSH
15192: EMPTY
15193: PPUSH
15194: CALL_OW 1
15198: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
15199: LD_VAR 0 2
15203: PPUSH
15204: LD_INT 107
15206: PPUSH
15207: CALL 6625 0 2
// continue ;
15211: GO 15122
// end ; target := [ ] ;
15213: LD_ADDR_VAR 0 6
15217: PUSH
15218: EMPTY
15219: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
15220: LD_ADDR_VAR 0 3
15224: PUSH
15225: DOUBLE
15226: LD_EXP 73
15230: PUSH
15231: LD_VAR 0 2
15235: ARRAY
15236: INC
15237: ST_TO_ADDR
15238: LD_INT 1
15240: PUSH
15241: FOR_DOWNTO
15242: IFFALSE 15502
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
15244: LD_EXP 73
15248: PUSH
15249: LD_VAR 0 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 3
15259: ARRAY
15260: PUSH
15261: LD_INT 2
15263: ARRAY
15264: PPUSH
15265: LD_EXP 73
15269: PUSH
15270: LD_VAR 0 2
15274: ARRAY
15275: PUSH
15276: LD_VAR 0 3
15280: ARRAY
15281: PUSH
15282: LD_INT 3
15284: ARRAY
15285: PPUSH
15286: CALL_OW 488
15290: PUSH
15291: LD_EXP 73
15295: PUSH
15296: LD_VAR 0 2
15300: ARRAY
15301: PUSH
15302: LD_VAR 0 3
15306: ARRAY
15307: PUSH
15308: LD_INT 2
15310: ARRAY
15311: PPUSH
15312: LD_EXP 73
15316: PUSH
15317: LD_VAR 0 2
15321: ARRAY
15322: PUSH
15323: LD_VAR 0 3
15327: ARRAY
15328: PUSH
15329: LD_INT 3
15331: ARRAY
15332: PPUSH
15333: CALL_OW 284
15337: PUSH
15338: LD_INT 0
15340: EQUAL
15341: AND
15342: IFFALSE 15397
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
15344: LD_ADDR_VAR 0 5
15348: PUSH
15349: LD_EXP 73
15353: PUSH
15354: LD_VAR 0 2
15358: ARRAY
15359: PPUSH
15360: LD_VAR 0 3
15364: PPUSH
15365: CALL_OW 3
15369: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
15370: LD_ADDR_EXP 73
15374: PUSH
15375: LD_EXP 73
15379: PPUSH
15380: LD_VAR 0 2
15384: PPUSH
15385: LD_VAR 0 5
15389: PPUSH
15390: CALL_OW 1
15394: ST_TO_ADDR
// continue ;
15395: GO 15241
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
15397: LD_EXP 57
15401: PUSH
15402: LD_VAR 0 2
15406: ARRAY
15407: PUSH
15408: LD_INT 1
15410: ARRAY
15411: PPUSH
15412: CALL_OW 255
15416: PPUSH
15417: LD_EXP 73
15421: PUSH
15422: LD_VAR 0 2
15426: ARRAY
15427: PUSH
15428: LD_VAR 0 3
15432: ARRAY
15433: PUSH
15434: LD_INT 2
15436: ARRAY
15437: PPUSH
15438: LD_EXP 73
15442: PUSH
15443: LD_VAR 0 2
15447: ARRAY
15448: PUSH
15449: LD_VAR 0 3
15453: ARRAY
15454: PUSH
15455: LD_INT 3
15457: ARRAY
15458: PPUSH
15459: LD_INT 30
15461: PPUSH
15462: CALL 38778 0 4
15466: PUSH
15467: LD_INT 4
15469: ARRAY
15470: PUSH
15471: LD_INT 0
15473: EQUAL
15474: IFFALSE 15500
// begin target := mc_crates [ i ] [ j ] ;
15476: LD_ADDR_VAR 0 6
15480: PUSH
15481: LD_EXP 73
15485: PUSH
15486: LD_VAR 0 2
15490: ARRAY
15491: PUSH
15492: LD_VAR 0 3
15496: ARRAY
15497: ST_TO_ADDR
// break ;
15498: GO 15502
// end ; end ;
15500: GO 15241
15502: POP
15503: POP
// if not target then
15504: LD_VAR 0 6
15508: NOT
15509: IFFALSE 15513
// continue ;
15511: GO 15122
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
15513: LD_ADDR_VAR 0 7
15517: PUSH
15518: LD_EXP 76
15522: PUSH
15523: LD_VAR 0 2
15527: ARRAY
15528: PPUSH
15529: LD_INT 2
15531: PUSH
15532: LD_INT 3
15534: PUSH
15535: LD_INT 58
15537: PUSH
15538: EMPTY
15539: LIST
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PUSH
15545: LD_INT 61
15547: PUSH
15548: EMPTY
15549: LIST
15550: PUSH
15551: LD_INT 33
15553: PUSH
15554: LD_INT 5
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PUSH
15561: LD_INT 33
15563: PUSH
15564: LD_INT 3
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: PUSH
15578: LD_INT 2
15580: PUSH
15581: LD_INT 34
15583: PUSH
15584: LD_INT 32
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: PUSH
15591: LD_INT 34
15593: PUSH
15594: LD_INT 51
15596: PUSH
15597: EMPTY
15598: LIST
15599: LIST
15600: PUSH
15601: LD_INT 34
15603: PUSH
15604: LD_INT 12
15606: PUSH
15607: EMPTY
15608: LIST
15609: LIST
15610: PUSH
15611: EMPTY
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: PUSH
15617: EMPTY
15618: LIST
15619: LIST
15620: PPUSH
15621: CALL_OW 72
15625: ST_TO_ADDR
// if not cargo then
15626: LD_VAR 0 7
15630: NOT
15631: IFFALSE 16274
// begin if mc_crates_collector [ i ] < 5 then
15633: LD_EXP 74
15637: PUSH
15638: LD_VAR 0 2
15642: ARRAY
15643: PUSH
15644: LD_INT 5
15646: LESS
15647: IFFALSE 16013
// begin if mc_ape [ i ] then
15649: LD_EXP 86
15653: PUSH
15654: LD_VAR 0 2
15658: ARRAY
15659: IFFALSE 15706
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
15661: LD_ADDR_VAR 0 5
15665: PUSH
15666: LD_EXP 86
15670: PUSH
15671: LD_VAR 0 2
15675: ARRAY
15676: PPUSH
15677: LD_INT 25
15679: PUSH
15680: LD_INT 16
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: LD_INT 24
15689: PUSH
15690: LD_INT 750
15692: PUSH
15693: EMPTY
15694: LIST
15695: LIST
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PPUSH
15701: CALL_OW 72
15705: ST_TO_ADDR
// if not tmp then
15706: LD_VAR 0 5
15710: NOT
15711: IFFALSE 15758
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
15713: LD_ADDR_VAR 0 5
15717: PUSH
15718: LD_EXP 57
15722: PUSH
15723: LD_VAR 0 2
15727: ARRAY
15728: PPUSH
15729: LD_INT 25
15731: PUSH
15732: LD_INT 2
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: PUSH
15739: LD_INT 24
15741: PUSH
15742: LD_INT 750
15744: PUSH
15745: EMPTY
15746: LIST
15747: LIST
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PPUSH
15753: CALL_OW 72
15757: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
15758: LD_EXP 86
15762: PUSH
15763: LD_VAR 0 2
15767: ARRAY
15768: PUSH
15769: LD_EXP 57
15773: PUSH
15774: LD_VAR 0 2
15778: ARRAY
15779: PPUSH
15780: LD_INT 25
15782: PUSH
15783: LD_INT 2
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 24
15792: PUSH
15793: LD_INT 750
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: PPUSH
15804: CALL_OW 72
15808: AND
15809: PUSH
15810: LD_VAR 0 5
15814: PUSH
15815: LD_INT 5
15817: LESS
15818: AND
15819: IFFALSE 15901
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
15821: LD_ADDR_VAR 0 3
15825: PUSH
15826: LD_EXP 57
15830: PUSH
15831: LD_VAR 0 2
15835: ARRAY
15836: PPUSH
15837: LD_INT 25
15839: PUSH
15840: LD_INT 2
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: PUSH
15847: LD_INT 24
15849: PUSH
15850: LD_INT 750
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: PPUSH
15861: CALL_OW 72
15865: PUSH
15866: FOR_IN
15867: IFFALSE 15899
// begin tmp := tmp union j ;
15869: LD_ADDR_VAR 0 5
15873: PUSH
15874: LD_VAR 0 5
15878: PUSH
15879: LD_VAR 0 3
15883: UNION
15884: ST_TO_ADDR
// if tmp >= 5 then
15885: LD_VAR 0 5
15889: PUSH
15890: LD_INT 5
15892: GREATEREQUAL
15893: IFFALSE 15897
// break ;
15895: GO 15899
// end ;
15897: GO 15866
15899: POP
15900: POP
// end ; if not tmp then
15901: LD_VAR 0 5
15905: NOT
15906: IFFALSE 15910
// continue ;
15908: GO 15122
// for j in tmp do
15910: LD_ADDR_VAR 0 3
15914: PUSH
15915: LD_VAR 0 5
15919: PUSH
15920: FOR_IN
15921: IFFALSE 16011
// if not GetTag ( j ) then
15923: LD_VAR 0 3
15927: PPUSH
15928: CALL_OW 110
15932: NOT
15933: IFFALSE 16009
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
15935: LD_ADDR_EXP 74
15939: PUSH
15940: LD_EXP 74
15944: PPUSH
15945: LD_VAR 0 2
15949: PUSH
15950: LD_EXP 74
15954: PUSH
15955: LD_VAR 0 2
15959: ARRAY
15960: PUSH
15961: LD_INT 1
15963: PLUS
15964: PUSH
15965: EMPTY
15966: LIST
15967: LIST
15968: PPUSH
15969: LD_VAR 0 3
15973: PPUSH
15974: CALL 37882 0 3
15978: ST_TO_ADDR
// SetTag ( j , 107 ) ;
15979: LD_VAR 0 3
15983: PPUSH
15984: LD_INT 107
15986: PPUSH
15987: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
15991: LD_EXP 74
15995: PUSH
15996: LD_VAR 0 2
16000: ARRAY
16001: PUSH
16002: LD_INT 5
16004: GREATEREQUAL
16005: IFFALSE 16009
// break ;
16007: GO 16011
// end ;
16009: GO 15920
16011: POP
16012: POP
// end ; if mc_crates_collector [ i ] and target then
16013: LD_EXP 74
16017: PUSH
16018: LD_VAR 0 2
16022: ARRAY
16023: PUSH
16024: LD_VAR 0 6
16028: AND
16029: IFFALSE 16272
// begin if mc_crates_collector [ i ] < target [ 1 ] then
16031: LD_EXP 74
16035: PUSH
16036: LD_VAR 0 2
16040: ARRAY
16041: PUSH
16042: LD_VAR 0 6
16046: PUSH
16047: LD_INT 1
16049: ARRAY
16050: LESS
16051: IFFALSE 16071
// tmp := mc_crates_collector [ i ] else
16053: LD_ADDR_VAR 0 5
16057: PUSH
16058: LD_EXP 74
16062: PUSH
16063: LD_VAR 0 2
16067: ARRAY
16068: ST_TO_ADDR
16069: GO 16085
// tmp := target [ 1 ] ;
16071: LD_ADDR_VAR 0 5
16075: PUSH
16076: LD_VAR 0 6
16080: PUSH
16081: LD_INT 1
16083: ARRAY
16084: ST_TO_ADDR
// k := 0 ;
16085: LD_ADDR_VAR 0 4
16089: PUSH
16090: LD_INT 0
16092: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
16093: LD_ADDR_VAR 0 3
16097: PUSH
16098: LD_EXP 74
16102: PUSH
16103: LD_VAR 0 2
16107: ARRAY
16108: PUSH
16109: FOR_IN
16110: IFFALSE 16270
// begin k := k + 1 ;
16112: LD_ADDR_VAR 0 4
16116: PUSH
16117: LD_VAR 0 4
16121: PUSH
16122: LD_INT 1
16124: PLUS
16125: ST_TO_ADDR
// if k > tmp then
16126: LD_VAR 0 4
16130: PUSH
16131: LD_VAR 0 5
16135: GREATER
16136: IFFALSE 16140
// break ;
16138: GO 16270
// if not GetClass ( j ) in [ 2 , 16 ] then
16140: LD_VAR 0 3
16144: PPUSH
16145: CALL_OW 257
16149: PUSH
16150: LD_INT 2
16152: PUSH
16153: LD_INT 16
16155: PUSH
16156: EMPTY
16157: LIST
16158: LIST
16159: IN
16160: NOT
16161: IFFALSE 16214
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
16163: LD_ADDR_EXP 74
16167: PUSH
16168: LD_EXP 74
16172: PPUSH
16173: LD_VAR 0 2
16177: PPUSH
16178: LD_EXP 74
16182: PUSH
16183: LD_VAR 0 2
16187: ARRAY
16188: PUSH
16189: LD_VAR 0 3
16193: DIFF
16194: PPUSH
16195: CALL_OW 1
16199: ST_TO_ADDR
// SetTag ( j , 0 ) ;
16200: LD_VAR 0 3
16204: PPUSH
16205: LD_INT 0
16207: PPUSH
16208: CALL_OW 109
// continue ;
16212: GO 16109
// end ; if IsInUnit ( j ) then
16214: LD_VAR 0 3
16218: PPUSH
16219: CALL_OW 310
16223: IFFALSE 16234
// ComExitBuilding ( j ) ;
16225: LD_VAR 0 3
16229: PPUSH
16230: CALL_OW 122
// wait ( 3 ) ;
16234: LD_INT 3
16236: PPUSH
16237: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
16241: LD_VAR 0 3
16245: PPUSH
16246: LD_VAR 0 6
16250: PUSH
16251: LD_INT 2
16253: ARRAY
16254: PPUSH
16255: LD_VAR 0 6
16259: PUSH
16260: LD_INT 3
16262: ARRAY
16263: PPUSH
16264: CALL_OW 117
// end ;
16268: GO 16109
16270: POP
16271: POP
// end ; end else
16272: GO 16834
// begin for j in cargo do
16274: LD_ADDR_VAR 0 3
16278: PUSH
16279: LD_VAR 0 7
16283: PUSH
16284: FOR_IN
16285: IFFALSE 16832
// begin if GetTag ( j ) <> 0 then
16287: LD_VAR 0 3
16291: PPUSH
16292: CALL_OW 110
16296: PUSH
16297: LD_INT 0
16299: NONEQUAL
16300: IFFALSE 16304
// continue ;
16302: GO 16284
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
16304: LD_VAR 0 3
16308: PPUSH
16309: CALL_OW 256
16313: PUSH
16314: LD_INT 1000
16316: LESS
16317: PUSH
16318: LD_VAR 0 3
16322: PPUSH
16323: LD_EXP 81
16327: PUSH
16328: LD_VAR 0 2
16332: ARRAY
16333: PPUSH
16334: CALL_OW 308
16338: NOT
16339: AND
16340: IFFALSE 16362
// ComMoveToArea ( j , mc_parking [ i ] ) ;
16342: LD_VAR 0 3
16346: PPUSH
16347: LD_EXP 81
16351: PUSH
16352: LD_VAR 0 2
16356: ARRAY
16357: PPUSH
16358: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
16362: LD_VAR 0 3
16366: PPUSH
16367: CALL_OW 256
16371: PUSH
16372: LD_INT 1000
16374: LESS
16375: PUSH
16376: LD_VAR 0 3
16380: PPUSH
16381: LD_EXP 81
16385: PUSH
16386: LD_VAR 0 2
16390: ARRAY
16391: PPUSH
16392: CALL_OW 308
16396: AND
16397: IFFALSE 16401
// continue ;
16399: GO 16284
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
16401: LD_VAR 0 3
16405: PPUSH
16406: CALL_OW 262
16410: PUSH
16411: LD_INT 2
16413: EQUAL
16414: PUSH
16415: LD_VAR 0 3
16419: PPUSH
16420: CALL_OW 261
16424: PUSH
16425: LD_INT 15
16427: LESS
16428: AND
16429: IFFALSE 16433
// continue ;
16431: GO 16284
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
16433: LD_VAR 0 3
16437: PPUSH
16438: CALL_OW 262
16442: PUSH
16443: LD_INT 1
16445: EQUAL
16446: PUSH
16447: LD_VAR 0 3
16451: PPUSH
16452: CALL_OW 261
16456: PUSH
16457: LD_INT 10
16459: LESS
16460: AND
16461: IFFALSE 16771
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
16463: LD_ADDR_VAR 0 8
16467: PUSH
16468: LD_EXP 57
16472: PUSH
16473: LD_VAR 0 2
16477: ARRAY
16478: PPUSH
16479: LD_INT 2
16481: PUSH
16482: LD_INT 30
16484: PUSH
16485: LD_INT 0
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 30
16494: PUSH
16495: LD_INT 1
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: LIST
16506: PPUSH
16507: CALL_OW 72
16511: ST_TO_ADDR
// if not depot then
16512: LD_VAR 0 8
16516: NOT
16517: IFFALSE 16521
// continue ;
16519: GO 16284
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
16521: LD_VAR 0 3
16525: PPUSH
16526: LD_VAR 0 8
16530: PPUSH
16531: LD_VAR 0 3
16535: PPUSH
16536: CALL_OW 74
16540: PPUSH
16541: CALL_OW 296
16545: PUSH
16546: LD_INT 6
16548: LESS
16549: IFFALSE 16565
// SetFuel ( j , 100 ) else
16551: LD_VAR 0 3
16555: PPUSH
16556: LD_INT 100
16558: PPUSH
16559: CALL_OW 240
16563: GO 16771
// if GetFuel ( j ) = 0 then
16565: LD_VAR 0 3
16569: PPUSH
16570: CALL_OW 261
16574: PUSH
16575: LD_INT 0
16577: EQUAL
16578: IFFALSE 16771
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
16580: LD_ADDR_EXP 76
16584: PUSH
16585: LD_EXP 76
16589: PPUSH
16590: LD_VAR 0 2
16594: PPUSH
16595: LD_EXP 76
16599: PUSH
16600: LD_VAR 0 2
16604: ARRAY
16605: PUSH
16606: LD_VAR 0 3
16610: DIFF
16611: PPUSH
16612: CALL_OW 1
16616: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
16617: LD_VAR 0 3
16621: PPUSH
16622: CALL_OW 263
16626: PUSH
16627: LD_INT 1
16629: EQUAL
16630: IFFALSE 16646
// ComExitVehicle ( IsInUnit ( j ) ) ;
16632: LD_VAR 0 3
16636: PPUSH
16637: CALL_OW 310
16641: PPUSH
16642: CALL_OW 121
// if GetControl ( j ) = control_remote then
16646: LD_VAR 0 3
16650: PPUSH
16651: CALL_OW 263
16655: PUSH
16656: LD_INT 2
16658: EQUAL
16659: IFFALSE 16670
// ComUnlink ( j ) ;
16661: LD_VAR 0 3
16665: PPUSH
16666: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
16670: LD_ADDR_VAR 0 9
16674: PUSH
16675: LD_VAR 0 2
16679: PPUSH
16680: LD_INT 3
16682: PPUSH
16683: CALL 25933 0 2
16687: ST_TO_ADDR
// if fac then
16688: LD_VAR 0 9
16692: IFFALSE 16769
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
16694: LD_ADDR_VAR 0 10
16698: PUSH
16699: LD_VAR 0 9
16703: PPUSH
16704: LD_VAR 0 3
16708: PPUSH
16709: CALL_OW 265
16713: PPUSH
16714: LD_VAR 0 3
16718: PPUSH
16719: CALL_OW 262
16723: PPUSH
16724: LD_VAR 0 3
16728: PPUSH
16729: CALL_OW 263
16733: PPUSH
16734: LD_VAR 0 3
16738: PPUSH
16739: CALL_OW 264
16743: PPUSH
16744: CALL 35482 0 5
16748: ST_TO_ADDR
// if components then
16749: LD_VAR 0 10
16753: IFFALSE 16769
// MC_InsertProduceList ( i , components ) ;
16755: LD_VAR 0 2
16759: PPUSH
16760: LD_VAR 0 10
16764: PPUSH
16765: CALL 25503 0 2
// end ; continue ;
16769: GO 16284
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
16771: LD_VAR 0 3
16775: PPUSH
16776: LD_INT 1
16778: PPUSH
16779: CALL_OW 289
16783: PUSH
16784: LD_INT 100
16786: LESS
16787: PUSH
16788: LD_VAR 0 3
16792: PPUSH
16793: CALL_OW 314
16797: NOT
16798: AND
16799: IFFALSE 16828
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
16801: LD_VAR 0 3
16805: PPUSH
16806: LD_VAR 0 6
16810: PUSH
16811: LD_INT 2
16813: ARRAY
16814: PPUSH
16815: LD_VAR 0 6
16819: PUSH
16820: LD_INT 3
16822: ARRAY
16823: PPUSH
16824: CALL_OW 117
// break ;
16828: GO 16832
// end ;
16830: GO 16284
16832: POP
16833: POP
// end ; end ;
16834: GO 15122
16836: POP
16837: POP
// end ;
16838: LD_VAR 0 1
16842: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
16843: LD_INT 0
16845: PPUSH
16846: PPUSH
16847: PPUSH
16848: PPUSH
// if not mc_bases then
16849: LD_EXP 57
16853: NOT
16854: IFFALSE 16858
// exit ;
16856: GO 17019
// for i = 1 to mc_bases do
16858: LD_ADDR_VAR 0 2
16862: PUSH
16863: DOUBLE
16864: LD_INT 1
16866: DEC
16867: ST_TO_ADDR
16868: LD_EXP 57
16872: PUSH
16873: FOR_TO
16874: IFFALSE 17017
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
16876: LD_ADDR_VAR 0 4
16880: PUSH
16881: LD_EXP 76
16885: PUSH
16886: LD_VAR 0 2
16890: ARRAY
16891: PUSH
16892: LD_EXP 79
16896: PUSH
16897: LD_VAR 0 2
16901: ARRAY
16902: UNION
16903: PPUSH
16904: LD_INT 33
16906: PUSH
16907: LD_INT 2
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: PPUSH
16914: CALL_OW 72
16918: ST_TO_ADDR
// if tmp then
16919: LD_VAR 0 4
16923: IFFALSE 17015
// for j in tmp do
16925: LD_ADDR_VAR 0 3
16929: PUSH
16930: LD_VAR 0 4
16934: PUSH
16935: FOR_IN
16936: IFFALSE 17013
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
16938: LD_VAR 0 3
16942: PPUSH
16943: CALL_OW 312
16947: NOT
16948: PUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 256
16958: PUSH
16959: LD_INT 250
16961: GREATEREQUAL
16962: AND
16963: IFFALSE 16976
// Connect ( j ) else
16965: LD_VAR 0 3
16969: PPUSH
16970: CALL 40815 0 1
16974: GO 17011
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
16976: LD_VAR 0 3
16980: PPUSH
16981: CALL_OW 256
16985: PUSH
16986: LD_INT 250
16988: LESS
16989: PUSH
16990: LD_VAR 0 3
16994: PPUSH
16995: CALL_OW 312
16999: AND
17000: IFFALSE 17011
// ComUnlink ( j ) ;
17002: LD_VAR 0 3
17006: PPUSH
17007: CALL_OW 136
17011: GO 16935
17013: POP
17014: POP
// end ;
17015: GO 16873
17017: POP
17018: POP
// end ;
17019: LD_VAR 0 1
17023: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
17024: LD_INT 0
17026: PPUSH
17027: PPUSH
17028: PPUSH
17029: PPUSH
17030: PPUSH
// if not mc_bases then
17031: LD_EXP 57
17035: NOT
17036: IFFALSE 17040
// exit ;
17038: GO 17500
// for i = 1 to mc_bases do
17040: LD_ADDR_VAR 0 2
17044: PUSH
17045: DOUBLE
17046: LD_INT 1
17048: DEC
17049: ST_TO_ADDR
17050: LD_EXP 57
17054: PUSH
17055: FOR_TO
17056: IFFALSE 17498
// begin if not mc_produce [ i ] then
17058: LD_EXP 78
17062: PUSH
17063: LD_VAR 0 2
17067: ARRAY
17068: NOT
17069: IFFALSE 17073
// continue ;
17071: GO 17055
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
17073: LD_ADDR_VAR 0 5
17077: PUSH
17078: LD_EXP 57
17082: PUSH
17083: LD_VAR 0 2
17087: ARRAY
17088: PPUSH
17089: LD_INT 30
17091: PUSH
17092: LD_INT 3
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PPUSH
17099: CALL_OW 72
17103: ST_TO_ADDR
// if not fac then
17104: LD_VAR 0 5
17108: NOT
17109: IFFALSE 17113
// continue ;
17111: GO 17055
// for j in fac do
17113: LD_ADDR_VAR 0 3
17117: PUSH
17118: LD_VAR 0 5
17122: PUSH
17123: FOR_IN
17124: IFFALSE 17494
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
17126: LD_VAR 0 3
17130: PPUSH
17131: CALL_OW 461
17135: PUSH
17136: LD_INT 2
17138: NONEQUAL
17139: PUSH
17140: LD_VAR 0 3
17144: PPUSH
17145: LD_INT 15
17147: PPUSH
17148: CALL 40475 0 2
17152: PUSH
17153: LD_INT 4
17155: ARRAY
17156: OR
17157: PUSH
17158: LD_VAR 0 3
17162: PPUSH
17163: CALL_OW 313
17167: PUSH
17168: LD_INT 0
17170: EQUAL
17171: OR
17172: IFFALSE 17176
// continue ;
17174: GO 17123
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
17176: LD_VAR 0 3
17180: PPUSH
17181: LD_EXP 78
17185: PUSH
17186: LD_VAR 0 2
17190: ARRAY
17191: PUSH
17192: LD_INT 1
17194: ARRAY
17195: PUSH
17196: LD_INT 1
17198: ARRAY
17199: PPUSH
17200: LD_EXP 78
17204: PUSH
17205: LD_VAR 0 2
17209: ARRAY
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PUSH
17215: LD_INT 2
17217: ARRAY
17218: PPUSH
17219: LD_EXP 78
17223: PUSH
17224: LD_VAR 0 2
17228: ARRAY
17229: PUSH
17230: LD_INT 1
17232: ARRAY
17233: PUSH
17234: LD_INT 3
17236: ARRAY
17237: PPUSH
17238: LD_EXP 78
17242: PUSH
17243: LD_VAR 0 2
17247: ARRAY
17248: PUSH
17249: LD_INT 1
17251: ARRAY
17252: PUSH
17253: LD_INT 4
17255: ARRAY
17256: PPUSH
17257: CALL_OW 448
17261: PUSH
17262: LD_VAR 0 3
17266: PPUSH
17267: LD_EXP 78
17271: PUSH
17272: LD_VAR 0 2
17276: ARRAY
17277: PUSH
17278: LD_INT 1
17280: ARRAY
17281: PUSH
17282: LD_INT 1
17284: ARRAY
17285: PUSH
17286: LD_EXP 78
17290: PUSH
17291: LD_VAR 0 2
17295: ARRAY
17296: PUSH
17297: LD_INT 1
17299: ARRAY
17300: PUSH
17301: LD_INT 2
17303: ARRAY
17304: PUSH
17305: LD_EXP 78
17309: PUSH
17310: LD_VAR 0 2
17314: ARRAY
17315: PUSH
17316: LD_INT 1
17318: ARRAY
17319: PUSH
17320: LD_INT 3
17322: ARRAY
17323: PUSH
17324: LD_EXP 78
17328: PUSH
17329: LD_VAR 0 2
17333: ARRAY
17334: PUSH
17335: LD_INT 1
17337: ARRAY
17338: PUSH
17339: LD_INT 4
17341: ARRAY
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: PPUSH
17349: CALL 44146 0 2
17353: AND
17354: IFFALSE 17492
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
17356: LD_VAR 0 3
17360: PPUSH
17361: LD_EXP 78
17365: PUSH
17366: LD_VAR 0 2
17370: ARRAY
17371: PUSH
17372: LD_INT 1
17374: ARRAY
17375: PUSH
17376: LD_INT 1
17378: ARRAY
17379: PPUSH
17380: LD_EXP 78
17384: PUSH
17385: LD_VAR 0 2
17389: ARRAY
17390: PUSH
17391: LD_INT 1
17393: ARRAY
17394: PUSH
17395: LD_INT 2
17397: ARRAY
17398: PPUSH
17399: LD_EXP 78
17403: PUSH
17404: LD_VAR 0 2
17408: ARRAY
17409: PUSH
17410: LD_INT 1
17412: ARRAY
17413: PUSH
17414: LD_INT 3
17416: ARRAY
17417: PPUSH
17418: LD_EXP 78
17422: PUSH
17423: LD_VAR 0 2
17427: ARRAY
17428: PUSH
17429: LD_INT 1
17431: ARRAY
17432: PUSH
17433: LD_INT 4
17435: ARRAY
17436: PPUSH
17437: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
17441: LD_ADDR_VAR 0 4
17445: PUSH
17446: LD_EXP 78
17450: PUSH
17451: LD_VAR 0 2
17455: ARRAY
17456: PPUSH
17457: LD_INT 1
17459: PPUSH
17460: CALL_OW 3
17464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
17465: LD_ADDR_EXP 78
17469: PUSH
17470: LD_EXP 78
17474: PPUSH
17475: LD_VAR 0 2
17479: PPUSH
17480: LD_VAR 0 4
17484: PPUSH
17485: CALL_OW 1
17489: ST_TO_ADDR
// break ;
17490: GO 17494
// end ; end ;
17492: GO 17123
17494: POP
17495: POP
// end ;
17496: GO 17055
17498: POP
17499: POP
// end ;
17500: LD_VAR 0 1
17504: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
17505: LD_INT 0
17507: PPUSH
17508: PPUSH
17509: PPUSH
// if not mc_bases then
17510: LD_EXP 57
17514: NOT
17515: IFFALSE 17519
// exit ;
17517: GO 17608
// for i = 1 to mc_bases do
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: DOUBLE
17525: LD_INT 1
17527: DEC
17528: ST_TO_ADDR
17529: LD_EXP 57
17533: PUSH
17534: FOR_TO
17535: IFFALSE 17606
// begin if mc_attack [ i ] then
17537: LD_EXP 77
17541: PUSH
17542: LD_VAR 0 2
17546: ARRAY
17547: IFFALSE 17604
// begin tmp := mc_attack [ i ] [ 1 ] ;
17549: LD_ADDR_VAR 0 3
17553: PUSH
17554: LD_EXP 77
17558: PUSH
17559: LD_VAR 0 2
17563: ARRAY
17564: PUSH
17565: LD_INT 1
17567: ARRAY
17568: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
17569: LD_ADDR_EXP 77
17573: PUSH
17574: LD_EXP 77
17578: PPUSH
17579: LD_VAR 0 2
17583: PPUSH
17584: EMPTY
17585: PPUSH
17586: CALL_OW 1
17590: ST_TO_ADDR
// Attack ( tmp ) ;
17591: LD_VAR 0 3
17595: PPUSH
17596: CALL 66335 0 1
// exit ;
17600: POP
17601: POP
17602: GO 17608
// end ; end ;
17604: GO 17534
17606: POP
17607: POP
// end ;
17608: LD_VAR 0 1
17612: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
17613: LD_INT 0
17615: PPUSH
17616: PPUSH
17617: PPUSH
17618: PPUSH
17619: PPUSH
17620: PPUSH
17621: PPUSH
// if not mc_bases then
17622: LD_EXP 57
17626: NOT
17627: IFFALSE 17631
// exit ;
17629: GO 18235
// for i = 1 to mc_bases do
17631: LD_ADDR_VAR 0 2
17635: PUSH
17636: DOUBLE
17637: LD_INT 1
17639: DEC
17640: ST_TO_ADDR
17641: LD_EXP 57
17645: PUSH
17646: FOR_TO
17647: IFFALSE 18233
// begin if not mc_bases [ i ] then
17649: LD_EXP 57
17653: PUSH
17654: LD_VAR 0 2
17658: ARRAY
17659: NOT
17660: IFFALSE 17664
// continue ;
17662: GO 17646
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
17664: LD_ADDR_VAR 0 7
17668: PUSH
17669: LD_EXP 57
17673: PUSH
17674: LD_VAR 0 2
17678: ARRAY
17679: PUSH
17680: LD_INT 1
17682: ARRAY
17683: PPUSH
17684: CALL 34786 0 1
17688: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
17689: LD_ADDR_EXP 80
17693: PUSH
17694: LD_EXP 80
17698: PPUSH
17699: LD_VAR 0 2
17703: PPUSH
17704: LD_EXP 57
17708: PUSH
17709: LD_VAR 0 2
17713: ARRAY
17714: PUSH
17715: LD_INT 1
17717: ARRAY
17718: PPUSH
17719: CALL_OW 255
17723: PPUSH
17724: LD_EXP 82
17728: PUSH
17729: LD_VAR 0 2
17733: ARRAY
17734: PPUSH
17735: CALL 32746 0 2
17739: PPUSH
17740: CALL_OW 1
17744: ST_TO_ADDR
// if not mc_scan [ i ] then
17745: LD_EXP 80
17749: PUSH
17750: LD_VAR 0 2
17754: ARRAY
17755: NOT
17756: IFFALSE 17911
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17758: LD_ADDR_VAR 0 4
17762: PUSH
17763: LD_EXP 57
17767: PUSH
17768: LD_VAR 0 2
17772: ARRAY
17773: PPUSH
17774: LD_INT 2
17776: PUSH
17777: LD_INT 25
17779: PUSH
17780: LD_INT 5
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: PUSH
17787: LD_INT 25
17789: PUSH
17790: LD_INT 8
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PUSH
17797: LD_INT 25
17799: PUSH
17800: LD_INT 9
17802: PUSH
17803: EMPTY
17804: LIST
17805: LIST
17806: PUSH
17807: EMPTY
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: PPUSH
17813: CALL_OW 72
17817: ST_TO_ADDR
// if not tmp then
17818: LD_VAR 0 4
17822: NOT
17823: IFFALSE 17827
// continue ;
17825: GO 17646
// for j in tmp do
17827: LD_ADDR_VAR 0 3
17831: PUSH
17832: LD_VAR 0 4
17836: PUSH
17837: FOR_IN
17838: IFFALSE 17909
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
17840: LD_VAR 0 3
17844: PPUSH
17845: CALL_OW 310
17849: PPUSH
17850: CALL_OW 266
17854: PUSH
17855: LD_INT 5
17857: EQUAL
17858: PUSH
17859: LD_VAR 0 3
17863: PPUSH
17864: CALL_OW 257
17868: PUSH
17869: LD_INT 1
17871: EQUAL
17872: AND
17873: PUSH
17874: LD_VAR 0 3
17878: PPUSH
17879: CALL_OW 459
17883: NOT
17884: AND
17885: PUSH
17886: LD_VAR 0 7
17890: AND
17891: IFFALSE 17907
// ComChangeProfession ( j , class ) ;
17893: LD_VAR 0 3
17897: PPUSH
17898: LD_VAR 0 7
17902: PPUSH
17903: CALL_OW 123
17907: GO 17837
17909: POP
17910: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
17911: LD_EXP 80
17915: PUSH
17916: LD_VAR 0 2
17920: ARRAY
17921: PUSH
17922: LD_EXP 79
17926: PUSH
17927: LD_VAR 0 2
17931: ARRAY
17932: NOT
17933: AND
17934: PUSH
17935: LD_EXP 57
17939: PUSH
17940: LD_VAR 0 2
17944: ARRAY
17945: PPUSH
17946: LD_INT 30
17948: PUSH
17949: LD_INT 32
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: PPUSH
17956: CALL_OW 72
17960: NOT
17961: AND
17962: PUSH
17963: LD_EXP 57
17967: PUSH
17968: LD_VAR 0 2
17972: ARRAY
17973: PPUSH
17974: LD_INT 2
17976: PUSH
17977: LD_INT 30
17979: PUSH
17980: LD_INT 4
17982: PUSH
17983: EMPTY
17984: LIST
17985: LIST
17986: PUSH
17987: LD_INT 30
17989: PUSH
17990: LD_INT 5
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: PUSH
17997: EMPTY
17998: LIST
17999: LIST
18000: LIST
18001: PPUSH
18002: CALL_OW 72
18006: NOT
18007: AND
18008: IFFALSE 18140
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
18010: LD_ADDR_VAR 0 4
18014: PUSH
18015: LD_EXP 57
18019: PUSH
18020: LD_VAR 0 2
18024: ARRAY
18025: PPUSH
18026: LD_INT 2
18028: PUSH
18029: LD_INT 25
18031: PUSH
18032: LD_INT 1
18034: PUSH
18035: EMPTY
18036: LIST
18037: LIST
18038: PUSH
18039: LD_INT 25
18041: PUSH
18042: LD_INT 5
18044: PUSH
18045: EMPTY
18046: LIST
18047: LIST
18048: PUSH
18049: LD_INT 25
18051: PUSH
18052: LD_INT 8
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 25
18061: PUSH
18062: LD_INT 9
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: LIST
18073: LIST
18074: LIST
18075: PPUSH
18076: CALL_OW 72
18080: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
18081: LD_ADDR_VAR 0 4
18085: PUSH
18086: LD_VAR 0 4
18090: PUSH
18091: LD_VAR 0 4
18095: PPUSH
18096: LD_INT 18
18098: PPUSH
18099: CALL 71079 0 2
18103: DIFF
18104: ST_TO_ADDR
// if tmp then
18105: LD_VAR 0 4
18109: IFFALSE 18140
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
18111: LD_VAR 0 2
18115: PPUSH
18116: LD_VAR 0 4
18120: PPUSH
18121: LD_EXP 82
18125: PUSH
18126: LD_VAR 0 2
18130: ARRAY
18131: PPUSH
18132: CALL 32781 0 3
// exit ;
18136: POP
18137: POP
18138: GO 18235
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
18140: LD_EXP 80
18144: PUSH
18145: LD_VAR 0 2
18149: ARRAY
18150: PUSH
18151: LD_EXP 79
18155: PUSH
18156: LD_VAR 0 2
18160: ARRAY
18161: AND
18162: IFFALSE 18231
// begin tmp := mc_defender [ i ] ;
18164: LD_ADDR_VAR 0 4
18168: PUSH
18169: LD_EXP 79
18173: PUSH
18174: LD_VAR 0 2
18178: ARRAY
18179: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
18180: LD_ADDR_EXP 79
18184: PUSH
18185: LD_EXP 79
18189: PPUSH
18190: LD_VAR 0 2
18194: PPUSH
18195: EMPTY
18196: PPUSH
18197: CALL_OW 1
18201: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
18202: LD_VAR 0 2
18206: PPUSH
18207: LD_VAR 0 4
18211: PPUSH
18212: LD_EXP 80
18216: PUSH
18217: LD_VAR 0 2
18221: ARRAY
18222: PPUSH
18223: CALL 33279 0 3
// exit ;
18227: POP
18228: POP
18229: GO 18235
// end ; end ;
18231: GO 17646
18233: POP
18234: POP
// end ;
18235: LD_VAR 0 1
18239: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
18240: LD_INT 0
18242: PPUSH
18243: PPUSH
18244: PPUSH
18245: PPUSH
18246: PPUSH
18247: PPUSH
18248: PPUSH
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
// if not mc_bases then
18253: LD_EXP 57
18257: NOT
18258: IFFALSE 18262
// exit ;
18260: GO 19349
// for i = 1 to mc_bases do
18262: LD_ADDR_VAR 0 2
18266: PUSH
18267: DOUBLE
18268: LD_INT 1
18270: DEC
18271: ST_TO_ADDR
18272: LD_EXP 57
18276: PUSH
18277: FOR_TO
18278: IFFALSE 19347
// begin tmp := mc_lab [ i ] ;
18280: LD_ADDR_VAR 0 6
18284: PUSH
18285: LD_EXP 90
18289: PUSH
18290: LD_VAR 0 2
18294: ARRAY
18295: ST_TO_ADDR
// if not tmp then
18296: LD_VAR 0 6
18300: NOT
18301: IFFALSE 18305
// continue ;
18303: GO 18277
// idle_lab := 0 ;
18305: LD_ADDR_VAR 0 11
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// for j in tmp do
18313: LD_ADDR_VAR 0 3
18317: PUSH
18318: LD_VAR 0 6
18322: PUSH
18323: FOR_IN
18324: IFFALSE 19343
// begin researching := false ;
18326: LD_ADDR_VAR 0 10
18330: PUSH
18331: LD_INT 0
18333: ST_TO_ADDR
// side := GetSide ( j ) ;
18334: LD_ADDR_VAR 0 4
18338: PUSH
18339: LD_VAR 0 3
18343: PPUSH
18344: CALL_OW 255
18348: ST_TO_ADDR
// if not mc_tech [ side ] then
18349: LD_EXP 84
18353: PUSH
18354: LD_VAR 0 4
18358: ARRAY
18359: NOT
18360: IFFALSE 18364
// continue ;
18362: GO 18323
// if BuildingStatus ( j ) = bs_idle then
18364: LD_VAR 0 3
18368: PPUSH
18369: CALL_OW 461
18373: PUSH
18374: LD_INT 2
18376: EQUAL
18377: IFFALSE 18565
// begin if idle_lab and UnitsInside ( j ) < 6 then
18379: LD_VAR 0 11
18383: PUSH
18384: LD_VAR 0 3
18388: PPUSH
18389: CALL_OW 313
18393: PUSH
18394: LD_INT 6
18396: LESS
18397: AND
18398: IFFALSE 18469
// begin tmp2 := UnitsInside ( idle_lab ) ;
18400: LD_ADDR_VAR 0 9
18404: PUSH
18405: LD_VAR 0 11
18409: PPUSH
18410: CALL_OW 313
18414: ST_TO_ADDR
// if tmp2 then
18415: LD_VAR 0 9
18419: IFFALSE 18461
// for x in tmp2 do
18421: LD_ADDR_VAR 0 7
18425: PUSH
18426: LD_VAR 0 9
18430: PUSH
18431: FOR_IN
18432: IFFALSE 18459
// begin ComExitBuilding ( x ) ;
18434: LD_VAR 0 7
18438: PPUSH
18439: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
18443: LD_VAR 0 7
18447: PPUSH
18448: LD_VAR 0 3
18452: PPUSH
18453: CALL_OW 180
// end ;
18457: GO 18431
18459: POP
18460: POP
// idle_lab := 0 ;
18461: LD_ADDR_VAR 0 11
18465: PUSH
18466: LD_INT 0
18468: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
18469: LD_ADDR_VAR 0 5
18473: PUSH
18474: LD_EXP 84
18478: PUSH
18479: LD_VAR 0 4
18483: ARRAY
18484: PUSH
18485: FOR_IN
18486: IFFALSE 18546
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
18488: LD_VAR 0 3
18492: PPUSH
18493: LD_VAR 0 5
18497: PPUSH
18498: CALL_OW 430
18502: PUSH
18503: LD_VAR 0 4
18507: PPUSH
18508: LD_VAR 0 5
18512: PPUSH
18513: CALL 31851 0 2
18517: AND
18518: IFFALSE 18544
// begin researching := true ;
18520: LD_ADDR_VAR 0 10
18524: PUSH
18525: LD_INT 1
18527: ST_TO_ADDR
// ComResearch ( j , t ) ;
18528: LD_VAR 0 3
18532: PPUSH
18533: LD_VAR 0 5
18537: PPUSH
18538: CALL_OW 124
// break ;
18542: GO 18546
// end ;
18544: GO 18485
18546: POP
18547: POP
// if not researching then
18548: LD_VAR 0 10
18552: NOT
18553: IFFALSE 18565
// idle_lab := j ;
18555: LD_ADDR_VAR 0 11
18559: PUSH
18560: LD_VAR 0 3
18564: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
18565: LD_VAR 0 3
18569: PPUSH
18570: CALL_OW 461
18574: PUSH
18575: LD_INT 10
18577: EQUAL
18578: IFFALSE 19166
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
18580: LD_EXP 86
18584: PUSH
18585: LD_VAR 0 2
18589: ARRAY
18590: NOT
18591: PUSH
18592: LD_EXP 87
18596: PUSH
18597: LD_VAR 0 2
18601: ARRAY
18602: NOT
18603: AND
18604: PUSH
18605: LD_EXP 84
18609: PUSH
18610: LD_VAR 0 4
18614: ARRAY
18615: PUSH
18616: LD_INT 1
18618: GREATER
18619: AND
18620: IFFALSE 18751
// begin ComCancel ( j ) ;
18622: LD_VAR 0 3
18626: PPUSH
18627: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
18631: LD_ADDR_EXP 84
18635: PUSH
18636: LD_EXP 84
18640: PPUSH
18641: LD_VAR 0 4
18645: PPUSH
18646: LD_EXP 84
18650: PUSH
18651: LD_VAR 0 4
18655: ARRAY
18656: PPUSH
18657: LD_EXP 84
18661: PUSH
18662: LD_VAR 0 4
18666: ARRAY
18667: PUSH
18668: LD_INT 1
18670: MINUS
18671: PPUSH
18672: LD_EXP 84
18676: PUSH
18677: LD_VAR 0 4
18681: ARRAY
18682: PPUSH
18683: LD_INT 0
18685: PPUSH
18686: CALL 37300 0 4
18690: PPUSH
18691: CALL_OW 1
18695: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
18696: LD_ADDR_EXP 84
18700: PUSH
18701: LD_EXP 84
18705: PPUSH
18706: LD_VAR 0 4
18710: PPUSH
18711: LD_EXP 84
18715: PUSH
18716: LD_VAR 0 4
18720: ARRAY
18721: PPUSH
18722: LD_EXP 84
18726: PUSH
18727: LD_VAR 0 4
18731: ARRAY
18732: PPUSH
18733: LD_INT 1
18735: PPUSH
18736: LD_INT 0
18738: PPUSH
18739: CALL 37300 0 4
18743: PPUSH
18744: CALL_OW 1
18748: ST_TO_ADDR
// continue ;
18749: GO 18323
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
18751: LD_EXP 86
18755: PUSH
18756: LD_VAR 0 2
18760: ARRAY
18761: PUSH
18762: LD_EXP 87
18766: PUSH
18767: LD_VAR 0 2
18771: ARRAY
18772: NOT
18773: AND
18774: IFFALSE 18901
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
18776: LD_ADDR_EXP 87
18780: PUSH
18781: LD_EXP 87
18785: PPUSH
18786: LD_VAR 0 2
18790: PUSH
18791: LD_EXP 87
18795: PUSH
18796: LD_VAR 0 2
18800: ARRAY
18801: PUSH
18802: LD_INT 1
18804: PLUS
18805: PUSH
18806: EMPTY
18807: LIST
18808: LIST
18809: PPUSH
18810: LD_EXP 86
18814: PUSH
18815: LD_VAR 0 2
18819: ARRAY
18820: PUSH
18821: LD_INT 1
18823: ARRAY
18824: PPUSH
18825: CALL 37882 0 3
18829: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
18830: LD_EXP 86
18834: PUSH
18835: LD_VAR 0 2
18839: ARRAY
18840: PUSH
18841: LD_INT 1
18843: ARRAY
18844: PPUSH
18845: LD_INT 112
18847: PPUSH
18848: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
18852: LD_ADDR_VAR 0 9
18856: PUSH
18857: LD_EXP 86
18861: PUSH
18862: LD_VAR 0 2
18866: ARRAY
18867: PPUSH
18868: LD_INT 1
18870: PPUSH
18871: CALL_OW 3
18875: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
18876: LD_ADDR_EXP 86
18880: PUSH
18881: LD_EXP 86
18885: PPUSH
18886: LD_VAR 0 2
18890: PPUSH
18891: LD_VAR 0 9
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
18901: LD_EXP 86
18905: PUSH
18906: LD_VAR 0 2
18910: ARRAY
18911: PUSH
18912: LD_EXP 87
18916: PUSH
18917: LD_VAR 0 2
18921: ARRAY
18922: AND
18923: PUSH
18924: LD_EXP 87
18928: PUSH
18929: LD_VAR 0 2
18933: ARRAY
18934: PUSH
18935: LD_INT 1
18937: ARRAY
18938: PPUSH
18939: CALL_OW 310
18943: NOT
18944: AND
18945: PUSH
18946: LD_VAR 0 3
18950: PPUSH
18951: CALL_OW 313
18955: PUSH
18956: LD_INT 6
18958: EQUAL
18959: AND
18960: IFFALSE 19016
// begin tmp2 := UnitsInside ( j ) ;
18962: LD_ADDR_VAR 0 9
18966: PUSH
18967: LD_VAR 0 3
18971: PPUSH
18972: CALL_OW 313
18976: ST_TO_ADDR
// if tmp2 = 6 then
18977: LD_VAR 0 9
18981: PUSH
18982: LD_INT 6
18984: EQUAL
18985: IFFALSE 19016
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
18987: LD_VAR 0 9
18991: PUSH
18992: LD_INT 1
18994: ARRAY
18995: PPUSH
18996: LD_INT 112
18998: PPUSH
18999: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
19003: LD_VAR 0 9
19007: PUSH
19008: LD_INT 1
19010: ARRAY
19011: PPUSH
19012: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
19016: LD_EXP 87
19020: PUSH
19021: LD_VAR 0 2
19025: ARRAY
19026: PUSH
19027: LD_EXP 87
19031: PUSH
19032: LD_VAR 0 2
19036: ARRAY
19037: PUSH
19038: LD_INT 1
19040: ARRAY
19041: PPUSH
19042: CALL_OW 314
19046: NOT
19047: AND
19048: PUSH
19049: LD_EXP 87
19053: PUSH
19054: LD_VAR 0 2
19058: ARRAY
19059: PUSH
19060: LD_INT 1
19062: ARRAY
19063: PPUSH
19064: CALL_OW 310
19068: NOT
19069: AND
19070: IFFALSE 19096
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
19072: LD_EXP 87
19076: PUSH
19077: LD_VAR 0 2
19081: ARRAY
19082: PUSH
19083: LD_INT 1
19085: ARRAY
19086: PPUSH
19087: LD_VAR 0 3
19091: PPUSH
19092: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
19096: LD_EXP 87
19100: PUSH
19101: LD_VAR 0 2
19105: ARRAY
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: CALL_OW 310
19115: PUSH
19116: LD_EXP 87
19120: PUSH
19121: LD_VAR 0 2
19125: ARRAY
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PPUSH
19131: CALL_OW 310
19135: PPUSH
19136: CALL_OW 461
19140: PUSH
19141: LD_INT 3
19143: NONEQUAL
19144: AND
19145: IFFALSE 19166
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
19147: LD_EXP 87
19151: PUSH
19152: LD_VAR 0 2
19156: ARRAY
19157: PUSH
19158: LD_INT 1
19160: ARRAY
19161: PPUSH
19162: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
19166: LD_VAR 0 3
19170: PPUSH
19171: CALL_OW 461
19175: PUSH
19176: LD_INT 6
19178: EQUAL
19179: PUSH
19180: LD_VAR 0 6
19184: PUSH
19185: LD_INT 1
19187: GREATER
19188: AND
19189: IFFALSE 19341
// begin sci := [ ] ;
19191: LD_ADDR_VAR 0 8
19195: PUSH
19196: EMPTY
19197: ST_TO_ADDR
// for x in ( tmp diff j ) do
19198: LD_ADDR_VAR 0 7
19202: PUSH
19203: LD_VAR 0 6
19207: PUSH
19208: LD_VAR 0 3
19212: DIFF
19213: PUSH
19214: FOR_IN
19215: IFFALSE 19267
// begin if sci = 6 then
19217: LD_VAR 0 8
19221: PUSH
19222: LD_INT 6
19224: EQUAL
19225: IFFALSE 19229
// break ;
19227: GO 19267
// if BuildingStatus ( x ) = bs_idle then
19229: LD_VAR 0 7
19233: PPUSH
19234: CALL_OW 461
19238: PUSH
19239: LD_INT 2
19241: EQUAL
19242: IFFALSE 19265
// sci := sci ^ UnitsInside ( x ) ;
19244: LD_ADDR_VAR 0 8
19248: PUSH
19249: LD_VAR 0 8
19253: PUSH
19254: LD_VAR 0 7
19258: PPUSH
19259: CALL_OW 313
19263: ADD
19264: ST_TO_ADDR
// end ;
19265: GO 19214
19267: POP
19268: POP
// if not sci then
19269: LD_VAR 0 8
19273: NOT
19274: IFFALSE 19278
// continue ;
19276: GO 18323
// for x in sci do
19278: LD_ADDR_VAR 0 7
19282: PUSH
19283: LD_VAR 0 8
19287: PUSH
19288: FOR_IN
19289: IFFALSE 19339
// if IsInUnit ( x ) and not HasTask ( x ) then
19291: LD_VAR 0 7
19295: PPUSH
19296: CALL_OW 310
19300: PUSH
19301: LD_VAR 0 7
19305: PPUSH
19306: CALL_OW 314
19310: NOT
19311: AND
19312: IFFALSE 19337
// begin ComExitBuilding ( x ) ;
19314: LD_VAR 0 7
19318: PPUSH
19319: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
19323: LD_VAR 0 7
19327: PPUSH
19328: LD_VAR 0 3
19332: PPUSH
19333: CALL_OW 180
// end ;
19337: GO 19288
19339: POP
19340: POP
// end ; end ;
19341: GO 18323
19343: POP
19344: POP
// end ;
19345: GO 18277
19347: POP
19348: POP
// end ;
19349: LD_VAR 0 1
19353: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
19354: LD_INT 0
19356: PPUSH
19357: PPUSH
// if not mc_bases then
19358: LD_EXP 57
19362: NOT
19363: IFFALSE 19367
// exit ;
19365: GO 19448
// for i = 1 to mc_bases do
19367: LD_ADDR_VAR 0 2
19371: PUSH
19372: DOUBLE
19373: LD_INT 1
19375: DEC
19376: ST_TO_ADDR
19377: LD_EXP 57
19381: PUSH
19382: FOR_TO
19383: IFFALSE 19446
// if mc_mines [ i ] and mc_miners [ i ] then
19385: LD_EXP 70
19389: PUSH
19390: LD_VAR 0 2
19394: ARRAY
19395: PUSH
19396: LD_EXP 71
19400: PUSH
19401: LD_VAR 0 2
19405: ARRAY
19406: AND
19407: IFFALSE 19444
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
19409: LD_EXP 71
19413: PUSH
19414: LD_VAR 0 2
19418: ARRAY
19419: PUSH
19420: LD_INT 1
19422: ARRAY
19423: PPUSH
19424: CALL_OW 255
19428: PPUSH
19429: LD_EXP 70
19433: PUSH
19434: LD_VAR 0 2
19438: ARRAY
19439: PPUSH
19440: CALL 34939 0 2
19444: GO 19382
19446: POP
19447: POP
// end ;
19448: LD_VAR 0 1
19452: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
19453: LD_INT 0
19455: PPUSH
19456: PPUSH
19457: PPUSH
19458: PPUSH
19459: PPUSH
19460: PPUSH
19461: PPUSH
19462: PPUSH
// if not mc_bases or not mc_parking then
19463: LD_EXP 57
19467: NOT
19468: PUSH
19469: LD_EXP 81
19473: NOT
19474: OR
19475: IFFALSE 19479
// exit ;
19477: GO 20191
// for i = 1 to mc_bases do
19479: LD_ADDR_VAR 0 2
19483: PUSH
19484: DOUBLE
19485: LD_INT 1
19487: DEC
19488: ST_TO_ADDR
19489: LD_EXP 57
19493: PUSH
19494: FOR_TO
19495: IFFALSE 20189
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
19497: LD_EXP 57
19501: PUSH
19502: LD_VAR 0 2
19506: ARRAY
19507: NOT
19508: PUSH
19509: LD_EXP 81
19513: PUSH
19514: LD_VAR 0 2
19518: ARRAY
19519: NOT
19520: OR
19521: IFFALSE 19525
// continue ;
19523: GO 19494
// if mc_scan [ i ] then
19525: LD_EXP 80
19529: PUSH
19530: LD_VAR 0 2
19534: ARRAY
19535: IFFALSE 19561
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19537: LD_ADDR_EXP 69
19541: PUSH
19542: LD_EXP 69
19546: PPUSH
19547: LD_VAR 0 2
19551: PPUSH
19552: EMPTY
19553: PPUSH
19554: CALL_OW 1
19558: ST_TO_ADDR
// continue ;
19559: GO 19494
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
19561: LD_ADDR_VAR 0 5
19565: PUSH
19566: LD_EXP 57
19570: PUSH
19571: LD_VAR 0 2
19575: ARRAY
19576: PUSH
19577: LD_INT 1
19579: ARRAY
19580: PPUSH
19581: CALL_OW 255
19585: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
19586: LD_ADDR_VAR 0 6
19590: PUSH
19591: LD_EXP 57
19595: PUSH
19596: LD_VAR 0 2
19600: ARRAY
19601: PPUSH
19602: LD_INT 30
19604: PUSH
19605: LD_INT 3
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: PPUSH
19612: CALL_OW 72
19616: ST_TO_ADDR
// if not fac then
19617: LD_VAR 0 6
19621: NOT
19622: IFFALSE 19673
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
19624: LD_ADDR_VAR 0 6
19628: PUSH
19629: LD_EXP 57
19633: PUSH
19634: LD_VAR 0 2
19638: ARRAY
19639: PPUSH
19640: LD_INT 2
19642: PUSH
19643: LD_INT 30
19645: PUSH
19646: LD_INT 0
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: PUSH
19653: LD_INT 30
19655: PUSH
19656: LD_INT 1
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: PUSH
19663: EMPTY
19664: LIST
19665: LIST
19666: LIST
19667: PPUSH
19668: CALL_OW 72
19672: ST_TO_ADDR
// if not fac then
19673: LD_VAR 0 6
19677: NOT
19678: IFFALSE 19682
// continue ;
19680: GO 19494
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19682: LD_ADDR_VAR 0 7
19686: PUSH
19687: LD_EXP 81
19691: PUSH
19692: LD_VAR 0 2
19696: ARRAY
19697: PPUSH
19698: LD_INT 22
19700: PUSH
19701: LD_VAR 0 5
19705: PUSH
19706: EMPTY
19707: LIST
19708: LIST
19709: PUSH
19710: LD_INT 21
19712: PUSH
19713: LD_INT 2
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PUSH
19720: LD_INT 3
19722: PUSH
19723: LD_INT 24
19725: PUSH
19726: LD_INT 1000
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: EMPTY
19734: LIST
19735: LIST
19736: PUSH
19737: EMPTY
19738: LIST
19739: LIST
19740: LIST
19741: PPUSH
19742: CALL_OW 70
19746: PUSH
19747: LD_INT 22
19749: PUSH
19750: LD_VAR 0 5
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: PUSH
19759: LD_INT 91
19761: PUSH
19762: LD_VAR 0 6
19766: PUSH
19767: LD_INT 1
19769: ARRAY
19770: PUSH
19771: LD_INT 25
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 21
19781: PUSH
19782: LD_INT 2
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 3
19791: PUSH
19792: LD_INT 24
19794: PUSH
19795: LD_INT 1000
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: EMPTY
19803: LIST
19804: LIST
19805: PUSH
19806: EMPTY
19807: LIST
19808: LIST
19809: LIST
19810: LIST
19811: PPUSH
19812: CALL_OW 69
19816: UNION
19817: ST_TO_ADDR
// if not vehs then
19818: LD_VAR 0 7
19822: NOT
19823: IFFALSE 19849
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19825: LD_ADDR_EXP 69
19829: PUSH
19830: LD_EXP 69
19834: PPUSH
19835: LD_VAR 0 2
19839: PPUSH
19840: EMPTY
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
// continue ;
19847: GO 19494
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
19849: LD_ADDR_VAR 0 8
19853: PUSH
19854: LD_EXP 57
19858: PUSH
19859: LD_VAR 0 2
19863: ARRAY
19864: PPUSH
19865: LD_INT 30
19867: PUSH
19868: LD_INT 3
19870: PUSH
19871: EMPTY
19872: LIST
19873: LIST
19874: PPUSH
19875: CALL_OW 72
19879: ST_TO_ADDR
// if tmp then
19880: LD_VAR 0 8
19884: IFFALSE 19987
// begin for j in tmp do
19886: LD_ADDR_VAR 0 3
19890: PUSH
19891: LD_VAR 0 8
19895: PUSH
19896: FOR_IN
19897: IFFALSE 19985
// for k in UnitsInside ( j ) do
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 3
19908: PPUSH
19909: CALL_OW 313
19913: PUSH
19914: FOR_IN
19915: IFFALSE 19981
// if k then
19917: LD_VAR 0 4
19921: IFFALSE 19979
// if not k in mc_repair_vehicle [ i ] then
19923: LD_VAR 0 4
19927: PUSH
19928: LD_EXP 69
19932: PUSH
19933: LD_VAR 0 2
19937: ARRAY
19938: IN
19939: NOT
19940: IFFALSE 19979
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
19942: LD_ADDR_EXP 69
19946: PUSH
19947: LD_EXP 69
19951: PPUSH
19952: LD_VAR 0 2
19956: PPUSH
19957: LD_EXP 69
19961: PUSH
19962: LD_VAR 0 2
19966: ARRAY
19967: PUSH
19968: LD_VAR 0 4
19972: UNION
19973: PPUSH
19974: CALL_OW 1
19978: ST_TO_ADDR
19979: GO 19914
19981: POP
19982: POP
19983: GO 19896
19985: POP
19986: POP
// end ; if not mc_repair_vehicle [ i ] then
19987: LD_EXP 69
19991: PUSH
19992: LD_VAR 0 2
19996: ARRAY
19997: NOT
19998: IFFALSE 20002
// continue ;
20000: GO 19494
// for j in mc_repair_vehicle [ i ] do
20002: LD_ADDR_VAR 0 3
20006: PUSH
20007: LD_EXP 69
20011: PUSH
20012: LD_VAR 0 2
20016: ARRAY
20017: PUSH
20018: FOR_IN
20019: IFFALSE 20185
// begin if GetClass ( j ) <> 3 then
20021: LD_VAR 0 3
20025: PPUSH
20026: CALL_OW 257
20030: PUSH
20031: LD_INT 3
20033: NONEQUAL
20034: IFFALSE 20075
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
20036: LD_ADDR_EXP 69
20040: PUSH
20041: LD_EXP 69
20045: PPUSH
20046: LD_VAR 0 2
20050: PPUSH
20051: LD_EXP 69
20055: PUSH
20056: LD_VAR 0 2
20060: ARRAY
20061: PUSH
20062: LD_VAR 0 3
20066: DIFF
20067: PPUSH
20068: CALL_OW 1
20072: ST_TO_ADDR
// continue ;
20073: GO 20018
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
20075: LD_VAR 0 3
20079: PPUSH
20080: CALL_OW 311
20084: NOT
20085: PUSH
20086: LD_VAR 0 3
20090: PUSH
20091: LD_EXP 60
20095: PUSH
20096: LD_VAR 0 2
20100: ARRAY
20101: PUSH
20102: LD_INT 1
20104: ARRAY
20105: IN
20106: NOT
20107: AND
20108: PUSH
20109: LD_VAR 0 3
20113: PUSH
20114: LD_EXP 60
20118: PUSH
20119: LD_VAR 0 2
20123: ARRAY
20124: PUSH
20125: LD_INT 2
20127: ARRAY
20128: IN
20129: NOT
20130: AND
20131: IFFALSE 20183
// begin if IsInUnit ( j ) then
20133: LD_VAR 0 3
20137: PPUSH
20138: CALL_OW 310
20142: IFFALSE 20153
// ComExitBuilding ( j ) ;
20144: LD_VAR 0 3
20148: PPUSH
20149: CALL_OW 122
// if not HasTask ( j ) then
20153: LD_VAR 0 3
20157: PPUSH
20158: CALL_OW 314
20162: NOT
20163: IFFALSE 20183
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
20165: LD_VAR 0 3
20169: PPUSH
20170: LD_VAR 0 7
20174: PUSH
20175: LD_INT 1
20177: ARRAY
20178: PPUSH
20179: CALL_OW 189
// end ; end ;
20183: GO 20018
20185: POP
20186: POP
// end ;
20187: GO 19494
20189: POP
20190: POP
// end ;
20191: LD_VAR 0 1
20195: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
20196: LD_INT 0
20198: PPUSH
20199: PPUSH
20200: PPUSH
20201: PPUSH
20202: PPUSH
20203: PPUSH
20204: PPUSH
20205: PPUSH
20206: PPUSH
20207: PPUSH
20208: PPUSH
// if not mc_bases then
20209: LD_EXP 57
20213: NOT
20214: IFFALSE 20218
// exit ;
20216: GO 21020
// for i = 1 to mc_bases do
20218: LD_ADDR_VAR 0 2
20222: PUSH
20223: DOUBLE
20224: LD_INT 1
20226: DEC
20227: ST_TO_ADDR
20228: LD_EXP 57
20232: PUSH
20233: FOR_TO
20234: IFFALSE 21018
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
20236: LD_EXP 85
20240: PUSH
20241: LD_VAR 0 2
20245: ARRAY
20246: NOT
20247: PUSH
20248: LD_EXP 60
20252: PUSH
20253: LD_VAR 0 2
20257: ARRAY
20258: PUSH
20259: LD_INT 1
20261: ARRAY
20262: OR
20263: PUSH
20264: LD_EXP 60
20268: PUSH
20269: LD_VAR 0 2
20273: ARRAY
20274: PUSH
20275: LD_INT 2
20277: ARRAY
20278: OR
20279: PUSH
20280: LD_EXP 83
20284: PUSH
20285: LD_VAR 0 2
20289: ARRAY
20290: PPUSH
20291: LD_INT 1
20293: PPUSH
20294: CALL_OW 325
20298: NOT
20299: OR
20300: PUSH
20301: LD_EXP 80
20305: PUSH
20306: LD_VAR 0 2
20310: ARRAY
20311: OR
20312: IFFALSE 20316
// continue ;
20314: GO 20233
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
20316: LD_ADDR_VAR 0 8
20320: PUSH
20321: LD_EXP 57
20325: PUSH
20326: LD_VAR 0 2
20330: ARRAY
20331: PPUSH
20332: LD_INT 25
20334: PUSH
20335: LD_INT 4
20337: PUSH
20338: EMPTY
20339: LIST
20340: LIST
20341: PUSH
20342: LD_INT 50
20344: PUSH
20345: EMPTY
20346: LIST
20347: PUSH
20348: LD_INT 3
20350: PUSH
20351: LD_INT 60
20353: PUSH
20354: EMPTY
20355: LIST
20356: PUSH
20357: EMPTY
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: PPUSH
20366: CALL_OW 72
20370: PUSH
20371: LD_EXP 61
20375: PUSH
20376: LD_VAR 0 2
20380: ARRAY
20381: DIFF
20382: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
20383: LD_ADDR_VAR 0 9
20387: PUSH
20388: LD_EXP 57
20392: PUSH
20393: LD_VAR 0 2
20397: ARRAY
20398: PPUSH
20399: LD_INT 2
20401: PUSH
20402: LD_INT 30
20404: PUSH
20405: LD_INT 0
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: LD_INT 30
20414: PUSH
20415: LD_INT 1
20417: PUSH
20418: EMPTY
20419: LIST
20420: LIST
20421: PUSH
20422: EMPTY
20423: LIST
20424: LIST
20425: LIST
20426: PPUSH
20427: CALL_OW 72
20431: ST_TO_ADDR
// if not tmp or not dep then
20432: LD_VAR 0 8
20436: NOT
20437: PUSH
20438: LD_VAR 0 9
20442: NOT
20443: OR
20444: IFFALSE 20448
// continue ;
20446: GO 20233
// side := GetSide ( tmp [ 1 ] ) ;
20448: LD_ADDR_VAR 0 11
20452: PUSH
20453: LD_VAR 0 8
20457: PUSH
20458: LD_INT 1
20460: ARRAY
20461: PPUSH
20462: CALL_OW 255
20466: ST_TO_ADDR
// dep := dep [ 1 ] ;
20467: LD_ADDR_VAR 0 9
20471: PUSH
20472: LD_VAR 0 9
20476: PUSH
20477: LD_INT 1
20479: ARRAY
20480: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
20481: LD_ADDR_VAR 0 7
20485: PUSH
20486: LD_EXP 85
20490: PUSH
20491: LD_VAR 0 2
20495: ARRAY
20496: PPUSH
20497: LD_INT 22
20499: PUSH
20500: LD_INT 0
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 25
20509: PUSH
20510: LD_INT 12
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: PPUSH
20521: CALL_OW 70
20525: PUSH
20526: LD_INT 22
20528: PUSH
20529: LD_INT 0
20531: PUSH
20532: EMPTY
20533: LIST
20534: LIST
20535: PUSH
20536: LD_INT 25
20538: PUSH
20539: LD_INT 12
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: PUSH
20546: LD_INT 91
20548: PUSH
20549: LD_VAR 0 9
20553: PUSH
20554: LD_INT 20
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: LIST
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: LIST
20566: PPUSH
20567: CALL_OW 69
20571: UNION
20572: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
20573: LD_ADDR_VAR 0 10
20577: PUSH
20578: LD_EXP 85
20582: PUSH
20583: LD_VAR 0 2
20587: ARRAY
20588: PPUSH
20589: LD_INT 81
20591: PUSH
20592: LD_VAR 0 11
20596: PUSH
20597: EMPTY
20598: LIST
20599: LIST
20600: PPUSH
20601: CALL_OW 70
20605: ST_TO_ADDR
// if not apes or danger_at_area then
20606: LD_VAR 0 7
20610: NOT
20611: PUSH
20612: LD_VAR 0 10
20616: OR
20617: IFFALSE 20667
// begin if mc_taming [ i ] then
20619: LD_EXP 88
20623: PUSH
20624: LD_VAR 0 2
20628: ARRAY
20629: IFFALSE 20665
// begin MC_Reset ( i , 121 ) ;
20631: LD_VAR 0 2
20635: PPUSH
20636: LD_INT 121
20638: PPUSH
20639: CALL 6625 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20643: LD_ADDR_EXP 88
20647: PUSH
20648: LD_EXP 88
20652: PPUSH
20653: LD_VAR 0 2
20657: PPUSH
20658: EMPTY
20659: PPUSH
20660: CALL_OW 1
20664: ST_TO_ADDR
// end ; continue ;
20665: GO 20233
// end ; for j in tmp do
20667: LD_ADDR_VAR 0 3
20671: PUSH
20672: LD_VAR 0 8
20676: PUSH
20677: FOR_IN
20678: IFFALSE 21014
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
20680: LD_VAR 0 3
20684: PUSH
20685: LD_EXP 88
20689: PUSH
20690: LD_VAR 0 2
20694: ARRAY
20695: IN
20696: NOT
20697: PUSH
20698: LD_EXP 88
20702: PUSH
20703: LD_VAR 0 2
20707: ARRAY
20708: PUSH
20709: LD_INT 3
20711: LESS
20712: AND
20713: IFFALSE 20771
// begin SetTag ( j , 121 ) ;
20715: LD_VAR 0 3
20719: PPUSH
20720: LD_INT 121
20722: PPUSH
20723: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
20727: LD_ADDR_EXP 88
20731: PUSH
20732: LD_EXP 88
20736: PPUSH
20737: LD_VAR 0 2
20741: PUSH
20742: LD_EXP 88
20746: PUSH
20747: LD_VAR 0 2
20751: ARRAY
20752: PUSH
20753: LD_INT 1
20755: PLUS
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: PPUSH
20761: LD_VAR 0 3
20765: PPUSH
20766: CALL 37882 0 3
20770: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
20771: LD_VAR 0 3
20775: PUSH
20776: LD_EXP 88
20780: PUSH
20781: LD_VAR 0 2
20785: ARRAY
20786: IN
20787: IFFALSE 21012
// begin if GetClass ( j ) <> 4 then
20789: LD_VAR 0 3
20793: PPUSH
20794: CALL_OW 257
20798: PUSH
20799: LD_INT 4
20801: NONEQUAL
20802: IFFALSE 20855
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
20804: LD_ADDR_EXP 88
20808: PUSH
20809: LD_EXP 88
20813: PPUSH
20814: LD_VAR 0 2
20818: PPUSH
20819: LD_EXP 88
20823: PUSH
20824: LD_VAR 0 2
20828: ARRAY
20829: PUSH
20830: LD_VAR 0 3
20834: DIFF
20835: PPUSH
20836: CALL_OW 1
20840: ST_TO_ADDR
// SetTag ( j , 0 ) ;
20841: LD_VAR 0 3
20845: PPUSH
20846: LD_INT 0
20848: PPUSH
20849: CALL_OW 109
// continue ;
20853: GO 20677
// end ; if IsInUnit ( j ) then
20855: LD_VAR 0 3
20859: PPUSH
20860: CALL_OW 310
20864: IFFALSE 20875
// ComExitBuilding ( j ) ;
20866: LD_VAR 0 3
20870: PPUSH
20871: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
20875: LD_ADDR_VAR 0 6
20879: PUSH
20880: LD_VAR 0 7
20884: PPUSH
20885: LD_VAR 0 3
20889: PPUSH
20890: CALL_OW 74
20894: ST_TO_ADDR
// if not ape then
20895: LD_VAR 0 6
20899: NOT
20900: IFFALSE 20904
// break ;
20902: GO 21014
// x := GetX ( ape ) ;
20904: LD_ADDR_VAR 0 4
20908: PUSH
20909: LD_VAR 0 6
20913: PPUSH
20914: CALL_OW 250
20918: ST_TO_ADDR
// y := GetY ( ape ) ;
20919: LD_ADDR_VAR 0 5
20923: PUSH
20924: LD_VAR 0 6
20928: PPUSH
20929: CALL_OW 251
20933: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
20934: LD_VAR 0 4
20938: PPUSH
20939: LD_VAR 0 5
20943: PPUSH
20944: CALL_OW 488
20948: NOT
20949: PUSH
20950: LD_VAR 0 11
20954: PPUSH
20955: LD_VAR 0 4
20959: PPUSH
20960: LD_VAR 0 5
20964: PPUSH
20965: LD_INT 20
20967: PPUSH
20968: CALL 38778 0 4
20972: PUSH
20973: LD_INT 4
20975: ARRAY
20976: OR
20977: IFFALSE 20981
// break ;
20979: GO 21014
// if not HasTask ( j ) then
20981: LD_VAR 0 3
20985: PPUSH
20986: CALL_OW 314
20990: NOT
20991: IFFALSE 21012
// ComTameXY ( j , x , y ) ;
20993: LD_VAR 0 3
20997: PPUSH
20998: LD_VAR 0 4
21002: PPUSH
21003: LD_VAR 0 5
21007: PPUSH
21008: CALL_OW 131
// end ; end ;
21012: GO 20677
21014: POP
21015: POP
// end ;
21016: GO 20233
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 1
21024: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
21025: LD_INT 0
21027: PPUSH
21028: PPUSH
21029: PPUSH
21030: PPUSH
21031: PPUSH
21032: PPUSH
21033: PPUSH
21034: PPUSH
// if not mc_bases then
21035: LD_EXP 57
21039: NOT
21040: IFFALSE 21044
// exit ;
21042: GO 21670
// for i = 1 to mc_bases do
21044: LD_ADDR_VAR 0 2
21048: PUSH
21049: DOUBLE
21050: LD_INT 1
21052: DEC
21053: ST_TO_ADDR
21054: LD_EXP 57
21058: PUSH
21059: FOR_TO
21060: IFFALSE 21668
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
21062: LD_EXP 86
21066: PUSH
21067: LD_VAR 0 2
21071: ARRAY
21072: NOT
21073: PUSH
21074: LD_EXP 86
21078: PUSH
21079: LD_VAR 0 2
21083: ARRAY
21084: PPUSH
21085: LD_INT 25
21087: PUSH
21088: LD_INT 12
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: PPUSH
21095: CALL_OW 72
21099: NOT
21100: OR
21101: IFFALSE 21105
// continue ;
21103: GO 21059
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
21105: LD_ADDR_VAR 0 5
21109: PUSH
21110: LD_EXP 86
21114: PUSH
21115: LD_VAR 0 2
21119: ARRAY
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PPUSH
21125: CALL_OW 255
21129: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
21130: LD_VAR 0 5
21134: PPUSH
21135: LD_INT 2
21137: PPUSH
21138: CALL_OW 325
21142: IFFALSE 21395
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
21144: LD_ADDR_VAR 0 4
21148: PUSH
21149: LD_EXP 86
21153: PUSH
21154: LD_VAR 0 2
21158: ARRAY
21159: PPUSH
21160: LD_INT 25
21162: PUSH
21163: LD_INT 16
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: PPUSH
21170: CALL_OW 72
21174: ST_TO_ADDR
// if tmp < 6 then
21175: LD_VAR 0 4
21179: PUSH
21180: LD_INT 6
21182: LESS
21183: IFFALSE 21395
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
21185: LD_ADDR_VAR 0 6
21189: PUSH
21190: LD_EXP 57
21194: PUSH
21195: LD_VAR 0 2
21199: ARRAY
21200: PPUSH
21201: LD_INT 2
21203: PUSH
21204: LD_INT 30
21206: PUSH
21207: LD_INT 0
21209: PUSH
21210: EMPTY
21211: LIST
21212: LIST
21213: PUSH
21214: LD_INT 30
21216: PUSH
21217: LD_INT 1
21219: PUSH
21220: EMPTY
21221: LIST
21222: LIST
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: LIST
21228: PPUSH
21229: CALL_OW 72
21233: ST_TO_ADDR
// if depot then
21234: LD_VAR 0 6
21238: IFFALSE 21395
// begin selected := 0 ;
21240: LD_ADDR_VAR 0 7
21244: PUSH
21245: LD_INT 0
21247: ST_TO_ADDR
// for j in depot do
21248: LD_ADDR_VAR 0 3
21252: PUSH
21253: LD_VAR 0 6
21257: PUSH
21258: FOR_IN
21259: IFFALSE 21290
// begin if UnitsInside ( j ) < 6 then
21261: LD_VAR 0 3
21265: PPUSH
21266: CALL_OW 313
21270: PUSH
21271: LD_INT 6
21273: LESS
21274: IFFALSE 21288
// begin selected := j ;
21276: LD_ADDR_VAR 0 7
21280: PUSH
21281: LD_VAR 0 3
21285: ST_TO_ADDR
// break ;
21286: GO 21290
// end ; end ;
21288: GO 21258
21290: POP
21291: POP
// if selected then
21292: LD_VAR 0 7
21296: IFFALSE 21395
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
21298: LD_ADDR_VAR 0 3
21302: PUSH
21303: LD_EXP 86
21307: PUSH
21308: LD_VAR 0 2
21312: ARRAY
21313: PPUSH
21314: LD_INT 25
21316: PUSH
21317: LD_INT 12
21319: PUSH
21320: EMPTY
21321: LIST
21322: LIST
21323: PPUSH
21324: CALL_OW 72
21328: PUSH
21329: FOR_IN
21330: IFFALSE 21393
// if not HasTask ( j ) then
21332: LD_VAR 0 3
21336: PPUSH
21337: CALL_OW 314
21341: NOT
21342: IFFALSE 21391
// begin if not IsInUnit ( j ) then
21344: LD_VAR 0 3
21348: PPUSH
21349: CALL_OW 310
21353: NOT
21354: IFFALSE 21370
// ComEnterUnit ( j , selected ) ;
21356: LD_VAR 0 3
21360: PPUSH
21361: LD_VAR 0 7
21365: PPUSH
21366: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
21370: LD_VAR 0 3
21374: PPUSH
21375: LD_INT 16
21377: PPUSH
21378: CALL_OW 183
// AddComExitBuilding ( j ) ;
21382: LD_VAR 0 3
21386: PPUSH
21387: CALL_OW 182
// end ;
21391: GO 21329
21393: POP
21394: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
21395: LD_VAR 0 5
21399: PPUSH
21400: LD_INT 11
21402: PPUSH
21403: CALL_OW 325
21407: IFFALSE 21666
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
21409: LD_ADDR_VAR 0 4
21413: PUSH
21414: LD_EXP 86
21418: PUSH
21419: LD_VAR 0 2
21423: ARRAY
21424: PPUSH
21425: LD_INT 25
21427: PUSH
21428: LD_INT 16
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: PPUSH
21435: CALL_OW 72
21439: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
21440: LD_VAR 0 4
21444: PUSH
21445: LD_INT 6
21447: GREATEREQUAL
21448: PUSH
21449: LD_VAR 0 5
21453: PPUSH
21454: LD_INT 2
21456: PPUSH
21457: CALL_OW 325
21461: NOT
21462: OR
21463: IFFALSE 21666
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
21465: LD_ADDR_VAR 0 8
21469: PUSH
21470: LD_EXP 57
21474: PUSH
21475: LD_VAR 0 2
21479: ARRAY
21480: PPUSH
21481: LD_INT 2
21483: PUSH
21484: LD_INT 30
21486: PUSH
21487: LD_INT 4
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: LD_INT 30
21496: PUSH
21497: LD_INT 5
21499: PUSH
21500: EMPTY
21501: LIST
21502: LIST
21503: PUSH
21504: EMPTY
21505: LIST
21506: LIST
21507: LIST
21508: PPUSH
21509: CALL_OW 72
21513: ST_TO_ADDR
// if barracks then
21514: LD_VAR 0 8
21518: IFFALSE 21666
// begin selected := 0 ;
21520: LD_ADDR_VAR 0 7
21524: PUSH
21525: LD_INT 0
21527: ST_TO_ADDR
// for j in barracks do
21528: LD_ADDR_VAR 0 3
21532: PUSH
21533: LD_VAR 0 8
21537: PUSH
21538: FOR_IN
21539: IFFALSE 21570
// begin if UnitsInside ( j ) < 6 then
21541: LD_VAR 0 3
21545: PPUSH
21546: CALL_OW 313
21550: PUSH
21551: LD_INT 6
21553: LESS
21554: IFFALSE 21568
// begin selected := j ;
21556: LD_ADDR_VAR 0 7
21560: PUSH
21561: LD_VAR 0 3
21565: ST_TO_ADDR
// break ;
21566: GO 21570
// end ; end ;
21568: GO 21538
21570: POP
21571: POP
// if selected then
21572: LD_VAR 0 7
21576: IFFALSE 21666
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
21578: LD_ADDR_VAR 0 3
21582: PUSH
21583: LD_EXP 86
21587: PUSH
21588: LD_VAR 0 2
21592: ARRAY
21593: PPUSH
21594: LD_INT 25
21596: PUSH
21597: LD_INT 12
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PPUSH
21604: CALL_OW 72
21608: PUSH
21609: FOR_IN
21610: IFFALSE 21664
// if not IsInUnit ( j ) and not HasTask ( j ) then
21612: LD_VAR 0 3
21616: PPUSH
21617: CALL_OW 310
21621: NOT
21622: PUSH
21623: LD_VAR 0 3
21627: PPUSH
21628: CALL_OW 314
21632: NOT
21633: AND
21634: IFFALSE 21662
// begin ComEnterUnit ( j , selected ) ;
21636: LD_VAR 0 3
21640: PPUSH
21641: LD_VAR 0 7
21645: PPUSH
21646: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
21650: LD_VAR 0 3
21654: PPUSH
21655: LD_INT 15
21657: PPUSH
21658: CALL_OW 183
// end ;
21662: GO 21609
21664: POP
21665: POP
// end ; end ; end ; end ; end ;
21666: GO 21059
21668: POP
21669: POP
// end ;
21670: LD_VAR 0 1
21674: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
21675: LD_INT 0
21677: PPUSH
21678: PPUSH
21679: PPUSH
21680: PPUSH
// if not mc_bases then
21681: LD_EXP 57
21685: NOT
21686: IFFALSE 21690
// exit ;
21688: GO 21868
// for i = 1 to mc_bases do
21690: LD_ADDR_VAR 0 2
21694: PUSH
21695: DOUBLE
21696: LD_INT 1
21698: DEC
21699: ST_TO_ADDR
21700: LD_EXP 57
21704: PUSH
21705: FOR_TO
21706: IFFALSE 21866
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
21708: LD_ADDR_VAR 0 4
21712: PUSH
21713: LD_EXP 57
21717: PUSH
21718: LD_VAR 0 2
21722: ARRAY
21723: PPUSH
21724: LD_INT 25
21726: PUSH
21727: LD_INT 9
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PPUSH
21734: CALL_OW 72
21738: ST_TO_ADDR
// if not tmp then
21739: LD_VAR 0 4
21743: NOT
21744: IFFALSE 21748
// continue ;
21746: GO 21705
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
21748: LD_EXP 83
21752: PUSH
21753: LD_VAR 0 2
21757: ARRAY
21758: PPUSH
21759: LD_INT 29
21761: PPUSH
21762: CALL_OW 325
21766: NOT
21767: PUSH
21768: LD_EXP 83
21772: PUSH
21773: LD_VAR 0 2
21777: ARRAY
21778: PPUSH
21779: LD_INT 28
21781: PPUSH
21782: CALL_OW 325
21786: NOT
21787: AND
21788: IFFALSE 21792
// continue ;
21790: GO 21705
// for j in tmp do
21792: LD_ADDR_VAR 0 3
21796: PUSH
21797: LD_VAR 0 4
21801: PUSH
21802: FOR_IN
21803: IFFALSE 21862
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
21805: LD_VAR 0 3
21809: PUSH
21810: LD_EXP 60
21814: PUSH
21815: LD_VAR 0 2
21819: ARRAY
21820: PUSH
21821: LD_INT 1
21823: ARRAY
21824: IN
21825: NOT
21826: PUSH
21827: LD_VAR 0 3
21831: PUSH
21832: LD_EXP 60
21836: PUSH
21837: LD_VAR 0 2
21841: ARRAY
21842: PUSH
21843: LD_INT 2
21845: ARRAY
21846: IN
21847: NOT
21848: AND
21849: IFFALSE 21860
// ComSpaceTimeShoot ( j ) ;
21851: LD_VAR 0 3
21855: PPUSH
21856: CALL 31942 0 1
21860: GO 21802
21862: POP
21863: POP
// end ;
21864: GO 21705
21866: POP
21867: POP
// end ;
21868: LD_VAR 0 1
21872: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
21873: LD_INT 0
21875: PPUSH
21876: PPUSH
21877: PPUSH
21878: PPUSH
21879: PPUSH
21880: PPUSH
21881: PPUSH
21882: PPUSH
21883: PPUSH
// if not mc_bases then
21884: LD_EXP 57
21888: NOT
21889: IFFALSE 21893
// exit ;
21891: GO 22515
// for i = 1 to mc_bases do
21893: LD_ADDR_VAR 0 2
21897: PUSH
21898: DOUBLE
21899: LD_INT 1
21901: DEC
21902: ST_TO_ADDR
21903: LD_EXP 57
21907: PUSH
21908: FOR_TO
21909: IFFALSE 22513
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
21911: LD_EXP 92
21915: PUSH
21916: LD_VAR 0 2
21920: ARRAY
21921: NOT
21922: PUSH
21923: LD_INT 38
21925: PPUSH
21926: LD_EXP 83
21930: PUSH
21931: LD_VAR 0 2
21935: ARRAY
21936: PPUSH
21937: CALL_OW 321
21941: PUSH
21942: LD_INT 2
21944: NONEQUAL
21945: OR
21946: IFFALSE 21950
// continue ;
21948: GO 21908
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
21950: LD_ADDR_VAR 0 8
21954: PUSH
21955: LD_EXP 57
21959: PUSH
21960: LD_VAR 0 2
21964: ARRAY
21965: PPUSH
21966: LD_INT 30
21968: PUSH
21969: LD_INT 34
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: PPUSH
21976: CALL_OW 72
21980: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
21981: LD_ADDR_VAR 0 9
21985: PUSH
21986: LD_EXP 57
21990: PUSH
21991: LD_VAR 0 2
21995: ARRAY
21996: PPUSH
21997: LD_INT 25
21999: PUSH
22000: LD_INT 4
22002: PUSH
22003: EMPTY
22004: LIST
22005: LIST
22006: PPUSH
22007: CALL_OW 72
22011: PPUSH
22012: LD_INT 0
22014: PPUSH
22015: CALL 71079 0 2
22019: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
22020: LD_VAR 0 9
22024: NOT
22025: PUSH
22026: LD_VAR 0 8
22030: NOT
22031: OR
22032: PUSH
22033: LD_EXP 57
22037: PUSH
22038: LD_VAR 0 2
22042: ARRAY
22043: PPUSH
22044: LD_INT 124
22046: PPUSH
22047: CALL 71079 0 2
22051: OR
22052: IFFALSE 22056
// continue ;
22054: GO 21908
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
22056: LD_EXP 93
22060: PUSH
22061: LD_VAR 0 2
22065: ARRAY
22066: PUSH
22067: LD_EXP 92
22071: PUSH
22072: LD_VAR 0 2
22076: ARRAY
22077: LESS
22078: PUSH
22079: LD_EXP 93
22083: PUSH
22084: LD_VAR 0 2
22088: ARRAY
22089: PUSH
22090: LD_VAR 0 8
22094: LESS
22095: AND
22096: IFFALSE 22511
// begin tmp := sci [ 1 ] ;
22098: LD_ADDR_VAR 0 7
22102: PUSH
22103: LD_VAR 0 9
22107: PUSH
22108: LD_INT 1
22110: ARRAY
22111: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
22112: LD_VAR 0 7
22116: PPUSH
22117: LD_INT 124
22119: PPUSH
22120: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
22124: LD_ADDR_VAR 0 3
22128: PUSH
22129: DOUBLE
22130: LD_EXP 92
22134: PUSH
22135: LD_VAR 0 2
22139: ARRAY
22140: INC
22141: ST_TO_ADDR
22142: LD_EXP 92
22146: PUSH
22147: LD_VAR 0 2
22151: ARRAY
22152: PUSH
22153: FOR_DOWNTO
22154: IFFALSE 22497
// begin if IsInUnit ( tmp ) then
22156: LD_VAR 0 7
22160: PPUSH
22161: CALL_OW 310
22165: IFFALSE 22176
// ComExitBuilding ( tmp ) ;
22167: LD_VAR 0 7
22171: PPUSH
22172: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
22176: LD_INT 35
22178: PPUSH
22179: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
22183: LD_VAR 0 7
22187: PPUSH
22188: CALL_OW 310
22192: NOT
22193: PUSH
22194: LD_VAR 0 7
22198: PPUSH
22199: CALL_OW 314
22203: NOT
22204: AND
22205: IFFALSE 22176
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
22207: LD_ADDR_VAR 0 6
22211: PUSH
22212: LD_VAR 0 7
22216: PPUSH
22217: CALL_OW 250
22221: PUSH
22222: LD_VAR 0 7
22226: PPUSH
22227: CALL_OW 251
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22236: LD_INT 35
22238: PPUSH
22239: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
22243: LD_ADDR_VAR 0 4
22247: PUSH
22248: LD_EXP 92
22252: PUSH
22253: LD_VAR 0 2
22257: ARRAY
22258: PUSH
22259: LD_VAR 0 3
22263: ARRAY
22264: PUSH
22265: LD_INT 1
22267: ARRAY
22268: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
22269: LD_ADDR_VAR 0 5
22273: PUSH
22274: LD_EXP 92
22278: PUSH
22279: LD_VAR 0 2
22283: ARRAY
22284: PUSH
22285: LD_VAR 0 3
22289: ARRAY
22290: PUSH
22291: LD_INT 2
22293: ARRAY
22294: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
22295: LD_VAR 0 7
22299: PPUSH
22300: LD_INT 10
22302: PPUSH
22303: CALL 40475 0 2
22307: PUSH
22308: LD_INT 4
22310: ARRAY
22311: IFFALSE 22349
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
22313: LD_VAR 0 7
22317: PPUSH
22318: LD_VAR 0 6
22322: PUSH
22323: LD_INT 1
22325: ARRAY
22326: PPUSH
22327: LD_VAR 0 6
22331: PUSH
22332: LD_INT 2
22334: ARRAY
22335: PPUSH
22336: CALL_OW 111
// wait ( 0 0$10 ) ;
22340: LD_INT 350
22342: PPUSH
22343: CALL_OW 67
// end else
22347: GO 22375
// begin ComMoveXY ( tmp , x , y ) ;
22349: LD_VAR 0 7
22353: PPUSH
22354: LD_VAR 0 4
22358: PPUSH
22359: LD_VAR 0 5
22363: PPUSH
22364: CALL_OW 111
// wait ( 0 0$3 ) ;
22368: LD_INT 105
22370: PPUSH
22371: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
22375: LD_VAR 0 7
22379: PPUSH
22380: LD_VAR 0 4
22384: PPUSH
22385: LD_VAR 0 5
22389: PPUSH
22390: CALL_OW 307
22394: IFFALSE 22236
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
22396: LD_VAR 0 7
22400: PPUSH
22401: LD_VAR 0 4
22405: PPUSH
22406: LD_VAR 0 5
22410: PPUSH
22411: LD_VAR 0 8
22415: PUSH
22416: LD_VAR 0 3
22420: ARRAY
22421: PPUSH
22422: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
22426: LD_INT 35
22428: PPUSH
22429: CALL_OW 67
// until not HasTask ( tmp ) ;
22433: LD_VAR 0 7
22437: PPUSH
22438: CALL_OW 314
22442: NOT
22443: IFFALSE 22426
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
22445: LD_ADDR_EXP 93
22449: PUSH
22450: LD_EXP 93
22454: PPUSH
22455: LD_VAR 0 2
22459: PUSH
22460: LD_EXP 93
22464: PUSH
22465: LD_VAR 0 2
22469: ARRAY
22470: PUSH
22471: LD_INT 1
22473: PLUS
22474: PUSH
22475: EMPTY
22476: LIST
22477: LIST
22478: PPUSH
22479: LD_VAR 0 8
22483: PUSH
22484: LD_VAR 0 3
22488: ARRAY
22489: PPUSH
22490: CALL 37882 0 3
22494: ST_TO_ADDR
// end ;
22495: GO 22153
22497: POP
22498: POP
// MC_Reset ( i , 124 ) ;
22499: LD_VAR 0 2
22503: PPUSH
22504: LD_INT 124
22506: PPUSH
22507: CALL 6625 0 2
// end ; end ;
22511: GO 21908
22513: POP
22514: POP
// end ;
22515: LD_VAR 0 1
22519: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
22520: LD_INT 0
22522: PPUSH
22523: PPUSH
22524: PPUSH
// if not mc_bases then
22525: LD_EXP 57
22529: NOT
22530: IFFALSE 22534
// exit ;
22532: GO 23140
// for i = 1 to mc_bases do
22534: LD_ADDR_VAR 0 2
22538: PUSH
22539: DOUBLE
22540: LD_INT 1
22542: DEC
22543: ST_TO_ADDR
22544: LD_EXP 57
22548: PUSH
22549: FOR_TO
22550: IFFALSE 23138
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
22552: LD_ADDR_VAR 0 3
22556: PUSH
22557: LD_EXP 57
22561: PUSH
22562: LD_VAR 0 2
22566: ARRAY
22567: PPUSH
22568: LD_INT 25
22570: PUSH
22571: LD_INT 4
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: PPUSH
22578: CALL_OW 72
22582: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22583: LD_VAR 0 3
22587: NOT
22588: PUSH
22589: LD_EXP 94
22593: PUSH
22594: LD_VAR 0 2
22598: ARRAY
22599: NOT
22600: OR
22601: PUSH
22602: LD_EXP 57
22606: PUSH
22607: LD_VAR 0 2
22611: ARRAY
22612: PPUSH
22613: LD_INT 2
22615: PUSH
22616: LD_INT 30
22618: PUSH
22619: LD_INT 0
22621: PUSH
22622: EMPTY
22623: LIST
22624: LIST
22625: PUSH
22626: LD_INT 30
22628: PUSH
22629: LD_INT 1
22631: PUSH
22632: EMPTY
22633: LIST
22634: LIST
22635: PUSH
22636: EMPTY
22637: LIST
22638: LIST
22639: LIST
22640: PPUSH
22641: CALL_OW 72
22645: NOT
22646: OR
22647: IFFALSE 22697
// begin if mc_deposits_finder [ i ] then
22649: LD_EXP 95
22653: PUSH
22654: LD_VAR 0 2
22658: ARRAY
22659: IFFALSE 22695
// begin MC_Reset ( i , 125 ) ;
22661: LD_VAR 0 2
22665: PPUSH
22666: LD_INT 125
22668: PPUSH
22669: CALL 6625 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
22673: LD_ADDR_EXP 95
22677: PUSH
22678: LD_EXP 95
22682: PPUSH
22683: LD_VAR 0 2
22687: PPUSH
22688: EMPTY
22689: PPUSH
22690: CALL_OW 1
22694: ST_TO_ADDR
// end ; continue ;
22695: GO 22549
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
22697: LD_EXP 94
22701: PUSH
22702: LD_VAR 0 2
22706: ARRAY
22707: PUSH
22708: LD_INT 1
22710: ARRAY
22711: PUSH
22712: LD_INT 3
22714: ARRAY
22715: PUSH
22716: LD_INT 1
22718: EQUAL
22719: PUSH
22720: LD_INT 20
22722: PPUSH
22723: LD_EXP 83
22727: PUSH
22728: LD_VAR 0 2
22732: ARRAY
22733: PPUSH
22734: CALL_OW 321
22738: PUSH
22739: LD_INT 2
22741: NONEQUAL
22742: AND
22743: IFFALSE 22793
// begin if mc_deposits_finder [ i ] then
22745: LD_EXP 95
22749: PUSH
22750: LD_VAR 0 2
22754: ARRAY
22755: IFFALSE 22791
// begin MC_Reset ( i , 125 ) ;
22757: LD_VAR 0 2
22761: PPUSH
22762: LD_INT 125
22764: PPUSH
22765: CALL 6625 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
22769: LD_ADDR_EXP 95
22773: PUSH
22774: LD_EXP 95
22778: PPUSH
22779: LD_VAR 0 2
22783: PPUSH
22784: EMPTY
22785: PPUSH
22786: CALL_OW 1
22790: ST_TO_ADDR
// end ; continue ;
22791: GO 22549
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
22793: LD_EXP 94
22797: PUSH
22798: LD_VAR 0 2
22802: ARRAY
22803: PUSH
22804: LD_INT 1
22806: ARRAY
22807: PUSH
22808: LD_INT 1
22810: ARRAY
22811: PPUSH
22812: LD_EXP 94
22816: PUSH
22817: LD_VAR 0 2
22821: ARRAY
22822: PUSH
22823: LD_INT 1
22825: ARRAY
22826: PUSH
22827: LD_INT 2
22829: ARRAY
22830: PPUSH
22831: LD_EXP 83
22835: PUSH
22836: LD_VAR 0 2
22840: ARRAY
22841: PPUSH
22842: CALL_OW 440
22846: IFFALSE 22889
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
22848: LD_ADDR_EXP 94
22852: PUSH
22853: LD_EXP 94
22857: PPUSH
22858: LD_VAR 0 2
22862: PPUSH
22863: LD_EXP 94
22867: PUSH
22868: LD_VAR 0 2
22872: ARRAY
22873: PPUSH
22874: LD_INT 1
22876: PPUSH
22877: CALL_OW 3
22881: PPUSH
22882: CALL_OW 1
22886: ST_TO_ADDR
22887: GO 23136
// begin if not mc_deposits_finder [ i ] then
22889: LD_EXP 95
22893: PUSH
22894: LD_VAR 0 2
22898: ARRAY
22899: NOT
22900: IFFALSE 22952
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
22902: LD_ADDR_EXP 95
22906: PUSH
22907: LD_EXP 95
22911: PPUSH
22912: LD_VAR 0 2
22916: PPUSH
22917: LD_VAR 0 3
22921: PUSH
22922: LD_INT 1
22924: ARRAY
22925: PUSH
22926: EMPTY
22927: LIST
22928: PPUSH
22929: CALL_OW 1
22933: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
22934: LD_VAR 0 3
22938: PUSH
22939: LD_INT 1
22941: ARRAY
22942: PPUSH
22943: LD_INT 125
22945: PPUSH
22946: CALL_OW 109
// end else
22950: GO 23136
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
22952: LD_EXP 95
22956: PUSH
22957: LD_VAR 0 2
22961: ARRAY
22962: PUSH
22963: LD_INT 1
22965: ARRAY
22966: PPUSH
22967: CALL_OW 310
22971: IFFALSE 22994
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
22973: LD_EXP 95
22977: PUSH
22978: LD_VAR 0 2
22982: ARRAY
22983: PUSH
22984: LD_INT 1
22986: ARRAY
22987: PPUSH
22988: CALL_OW 122
22992: GO 23136
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
22994: LD_EXP 95
22998: PUSH
22999: LD_VAR 0 2
23003: ARRAY
23004: PUSH
23005: LD_INT 1
23007: ARRAY
23008: PPUSH
23009: CALL_OW 314
23013: NOT
23014: PUSH
23015: LD_EXP 95
23019: PUSH
23020: LD_VAR 0 2
23024: ARRAY
23025: PUSH
23026: LD_INT 1
23028: ARRAY
23029: PPUSH
23030: LD_EXP 94
23034: PUSH
23035: LD_VAR 0 2
23039: ARRAY
23040: PUSH
23041: LD_INT 1
23043: ARRAY
23044: PUSH
23045: LD_INT 1
23047: ARRAY
23048: PPUSH
23049: LD_EXP 94
23053: PUSH
23054: LD_VAR 0 2
23058: ARRAY
23059: PUSH
23060: LD_INT 1
23062: ARRAY
23063: PUSH
23064: LD_INT 2
23066: ARRAY
23067: PPUSH
23068: CALL_OW 297
23072: PUSH
23073: LD_INT 6
23075: GREATER
23076: AND
23077: IFFALSE 23136
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
23079: LD_EXP 95
23083: PUSH
23084: LD_VAR 0 2
23088: ARRAY
23089: PUSH
23090: LD_INT 1
23092: ARRAY
23093: PPUSH
23094: LD_EXP 94
23098: PUSH
23099: LD_VAR 0 2
23103: ARRAY
23104: PUSH
23105: LD_INT 1
23107: ARRAY
23108: PUSH
23109: LD_INT 1
23111: ARRAY
23112: PPUSH
23113: LD_EXP 94
23117: PUSH
23118: LD_VAR 0 2
23122: ARRAY
23123: PUSH
23124: LD_INT 1
23126: ARRAY
23127: PUSH
23128: LD_INT 2
23130: ARRAY
23131: PPUSH
23132: CALL_OW 111
// end ; end ; end ;
23136: GO 22549
23138: POP
23139: POP
// end ;
23140: LD_VAR 0 1
23144: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
23145: LD_INT 0
23147: PPUSH
23148: PPUSH
23149: PPUSH
23150: PPUSH
23151: PPUSH
23152: PPUSH
23153: PPUSH
23154: PPUSH
23155: PPUSH
23156: PPUSH
23157: PPUSH
// if not mc_bases then
23158: LD_EXP 57
23162: NOT
23163: IFFALSE 23167
// exit ;
23165: GO 23891
// for i = 1 to mc_bases do
23167: LD_ADDR_VAR 0 2
23171: PUSH
23172: DOUBLE
23173: LD_INT 1
23175: DEC
23176: ST_TO_ADDR
23177: LD_EXP 57
23181: PUSH
23182: FOR_TO
23183: IFFALSE 23889
// begin if not mc_bases [ i ] then
23185: LD_EXP 57
23189: PUSH
23190: LD_VAR 0 2
23194: ARRAY
23195: NOT
23196: IFFALSE 23200
// continue ;
23198: GO 23182
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
23200: LD_ADDR_VAR 0 7
23204: PUSH
23205: LD_EXP 57
23209: PUSH
23210: LD_VAR 0 2
23214: ARRAY
23215: PUSH
23216: LD_INT 1
23218: ARRAY
23219: PPUSH
23220: CALL_OW 248
23224: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
23225: LD_VAR 0 7
23229: PUSH
23230: LD_INT 3
23232: EQUAL
23233: PUSH
23234: LD_EXP 76
23238: PUSH
23239: LD_VAR 0 2
23243: ARRAY
23244: PUSH
23245: LD_EXP 79
23249: PUSH
23250: LD_VAR 0 2
23254: ARRAY
23255: UNION
23256: PPUSH
23257: LD_INT 33
23259: PUSH
23260: LD_INT 2
23262: PUSH
23263: EMPTY
23264: LIST
23265: LIST
23266: PPUSH
23267: CALL_OW 72
23271: NOT
23272: OR
23273: IFFALSE 23277
// continue ;
23275: GO 23182
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
23277: LD_ADDR_VAR 0 9
23281: PUSH
23282: LD_EXP 57
23286: PUSH
23287: LD_VAR 0 2
23291: ARRAY
23292: PPUSH
23293: LD_INT 30
23295: PUSH
23296: LD_INT 36
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PPUSH
23303: CALL_OW 72
23307: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
23308: LD_ADDR_VAR 0 10
23312: PUSH
23313: LD_EXP 76
23317: PUSH
23318: LD_VAR 0 2
23322: ARRAY
23323: PPUSH
23324: LD_INT 34
23326: PUSH
23327: LD_INT 31
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: PPUSH
23334: CALL_OW 72
23338: ST_TO_ADDR
// if not cts and not mcts then
23339: LD_VAR 0 9
23343: NOT
23344: PUSH
23345: LD_VAR 0 10
23349: NOT
23350: AND
23351: IFFALSE 23355
// continue ;
23353: GO 23182
// x := cts ;
23355: LD_ADDR_VAR 0 11
23359: PUSH
23360: LD_VAR 0 9
23364: ST_TO_ADDR
// if not x then
23365: LD_VAR 0 11
23369: NOT
23370: IFFALSE 23382
// x := mcts ;
23372: LD_ADDR_VAR 0 11
23376: PUSH
23377: LD_VAR 0 10
23381: ST_TO_ADDR
// if mc_remote_driver [ i ] then
23382: LD_EXP 97
23386: PUSH
23387: LD_VAR 0 2
23391: ARRAY
23392: IFFALSE 23661
// for j in mc_remote_driver [ i ] do
23394: LD_ADDR_VAR 0 3
23398: PUSH
23399: LD_EXP 97
23403: PUSH
23404: LD_VAR 0 2
23408: ARRAY
23409: PUSH
23410: FOR_IN
23411: IFFALSE 23659
// begin if GetClass ( j ) <> 3 then
23413: LD_VAR 0 3
23417: PPUSH
23418: CALL_OW 257
23422: PUSH
23423: LD_INT 3
23425: NONEQUAL
23426: IFFALSE 23479
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
23428: LD_ADDR_EXP 97
23432: PUSH
23433: LD_EXP 97
23437: PPUSH
23438: LD_VAR 0 2
23442: PPUSH
23443: LD_EXP 97
23447: PUSH
23448: LD_VAR 0 2
23452: ARRAY
23453: PUSH
23454: LD_VAR 0 3
23458: DIFF
23459: PPUSH
23460: CALL_OW 1
23464: ST_TO_ADDR
// SetTag ( j , 0 ) ;
23465: LD_VAR 0 3
23469: PPUSH
23470: LD_INT 0
23472: PPUSH
23473: CALL_OW 109
// continue ;
23477: GO 23410
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
23479: LD_VAR 0 3
23483: PPUSH
23484: CALL_OW 310
23488: NOT
23489: PUSH
23490: LD_VAR 0 3
23494: PPUSH
23495: CALL_OW 310
23499: PPUSH
23500: CALL_OW 266
23504: PUSH
23505: LD_INT 36
23507: NONEQUAL
23508: PUSH
23509: LD_VAR 0 3
23513: PPUSH
23514: CALL 71167 0 1
23518: NOT
23519: AND
23520: OR
23521: IFFALSE 23657
// begin if IsInUnit ( j ) then
23523: LD_VAR 0 3
23527: PPUSH
23528: CALL_OW 310
23532: IFFALSE 23543
// ComExitBuilding ( j ) ;
23534: LD_VAR 0 3
23538: PPUSH
23539: CALL_OW 122
// ct := 0 ;
23543: LD_ADDR_VAR 0 8
23547: PUSH
23548: LD_INT 0
23550: ST_TO_ADDR
// for k in x do
23551: LD_ADDR_VAR 0 4
23555: PUSH
23556: LD_VAR 0 11
23560: PUSH
23561: FOR_IN
23562: IFFALSE 23635
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
23564: LD_VAR 0 4
23568: PPUSH
23569: CALL_OW 264
23573: PUSH
23574: LD_INT 31
23576: EQUAL
23577: PUSH
23578: LD_VAR 0 4
23582: PPUSH
23583: CALL_OW 311
23587: NOT
23588: AND
23589: PUSH
23590: LD_VAR 0 4
23594: PPUSH
23595: CALL_OW 266
23599: PUSH
23600: LD_INT 36
23602: EQUAL
23603: PUSH
23604: LD_VAR 0 4
23608: PPUSH
23609: CALL_OW 313
23613: PUSH
23614: LD_INT 3
23616: LESS
23617: AND
23618: OR
23619: IFFALSE 23633
// begin ct := k ;
23621: LD_ADDR_VAR 0 8
23625: PUSH
23626: LD_VAR 0 4
23630: ST_TO_ADDR
// break ;
23631: GO 23635
// end ;
23633: GO 23561
23635: POP
23636: POP
// if ct then
23637: LD_VAR 0 8
23641: IFFALSE 23657
// ComEnterUnit ( j , ct ) ;
23643: LD_VAR 0 3
23647: PPUSH
23648: LD_VAR 0 8
23652: PPUSH
23653: CALL_OW 120
// end ; end ;
23657: GO 23410
23659: POP
23660: POP
// places := 0 ;
23661: LD_ADDR_VAR 0 5
23665: PUSH
23666: LD_INT 0
23668: ST_TO_ADDR
// for j = 1 to x do
23669: LD_ADDR_VAR 0 3
23673: PUSH
23674: DOUBLE
23675: LD_INT 1
23677: DEC
23678: ST_TO_ADDR
23679: LD_VAR 0 11
23683: PUSH
23684: FOR_TO
23685: IFFALSE 23740
// if GetWeapon ( x [ j ] ) = ar_control_tower then
23687: LD_VAR 0 11
23691: PUSH
23692: LD_VAR 0 3
23696: ARRAY
23697: PPUSH
23698: CALL_OW 264
23702: PUSH
23703: LD_INT 31
23705: EQUAL
23706: IFFALSE 23724
// places := places + 1 else
23708: LD_ADDR_VAR 0 5
23712: PUSH
23713: LD_VAR 0 5
23717: PUSH
23718: LD_INT 1
23720: PLUS
23721: ST_TO_ADDR
23722: GO 23738
// places := places + 3 ;
23724: LD_ADDR_VAR 0 5
23728: PUSH
23729: LD_VAR 0 5
23733: PUSH
23734: LD_INT 3
23736: PLUS
23737: ST_TO_ADDR
23738: GO 23684
23740: POP
23741: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
23742: LD_ADDR_VAR 0 6
23746: PUSH
23747: LD_EXP 57
23751: PUSH
23752: LD_VAR 0 2
23756: ARRAY
23757: PPUSH
23758: LD_INT 25
23760: PUSH
23761: LD_INT 3
23763: PUSH
23764: EMPTY
23765: LIST
23766: LIST
23767: PPUSH
23768: CALL_OW 72
23772: PUSH
23773: LD_EXP 97
23777: PUSH
23778: LD_VAR 0 2
23782: ARRAY
23783: DIFF
23784: PPUSH
23785: LD_INT 3
23787: PPUSH
23788: CALL 72067 0 2
23792: ST_TO_ADDR
// if not tmp then
23793: LD_VAR 0 6
23797: NOT
23798: IFFALSE 23802
// continue ;
23800: GO 23182
// places := places - mc_remote_driver [ i ] ;
23802: LD_ADDR_VAR 0 5
23806: PUSH
23807: LD_VAR 0 5
23811: PUSH
23812: LD_EXP 97
23816: PUSH
23817: LD_VAR 0 2
23821: ARRAY
23822: MINUS
23823: ST_TO_ADDR
// if places then
23824: LD_VAR 0 5
23828: IFFALSE 23887
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
23830: LD_ADDR_EXP 97
23834: PUSH
23835: LD_EXP 97
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: LD_EXP 97
23849: PUSH
23850: LD_VAR 0 2
23854: ARRAY
23855: PUSH
23856: LD_VAR 0 6
23860: PUSH
23861: LD_INT 1
23863: ARRAY
23864: UNION
23865: PPUSH
23866: CALL_OW 1
23870: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
23871: LD_VAR 0 6
23875: PUSH
23876: LD_INT 1
23878: ARRAY
23879: PPUSH
23880: LD_INT 126
23882: PPUSH
23883: CALL_OW 109
// end ; end ;
23887: GO 23182
23889: POP
23890: POP
// end ;
23891: LD_VAR 0 1
23895: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
23896: LD_INT 0
23898: PPUSH
23899: PPUSH
23900: PPUSH
23901: PPUSH
23902: PPUSH
23903: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
23904: LD_VAR 0 1
23908: NOT
23909: PUSH
23910: LD_VAR 0 2
23914: NOT
23915: OR
23916: PUSH
23917: LD_VAR 0 3
23921: NOT
23922: OR
23923: PUSH
23924: LD_VAR 0 4
23928: PUSH
23929: LD_INT 1
23931: PUSH
23932: LD_INT 2
23934: PUSH
23935: LD_INT 3
23937: PUSH
23938: LD_INT 4
23940: PUSH
23941: LD_INT 5
23943: PUSH
23944: LD_INT 8
23946: PUSH
23947: LD_INT 9
23949: PUSH
23950: LD_INT 15
23952: PUSH
23953: LD_INT 16
23955: PUSH
23956: EMPTY
23957: LIST
23958: LIST
23959: LIST
23960: LIST
23961: LIST
23962: LIST
23963: LIST
23964: LIST
23965: LIST
23966: IN
23967: NOT
23968: OR
23969: IFFALSE 23973
// exit ;
23971: GO 24873
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
23973: LD_ADDR_VAR 0 2
23977: PUSH
23978: LD_VAR 0 2
23982: PPUSH
23983: LD_INT 21
23985: PUSH
23986: LD_INT 3
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: PUSH
23993: LD_INT 24
23995: PUSH
23996: LD_INT 250
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PPUSH
24007: CALL_OW 72
24011: ST_TO_ADDR
// case class of 1 , 15 :
24012: LD_VAR 0 4
24016: PUSH
24017: LD_INT 1
24019: DOUBLE
24020: EQUAL
24021: IFTRUE 24031
24023: LD_INT 15
24025: DOUBLE
24026: EQUAL
24027: IFTRUE 24031
24029: GO 24116
24031: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
24032: LD_ADDR_VAR 0 8
24036: PUSH
24037: LD_VAR 0 2
24041: PPUSH
24042: LD_INT 2
24044: PUSH
24045: LD_INT 30
24047: PUSH
24048: LD_INT 32
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 30
24057: PUSH
24058: LD_INT 31
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: LIST
24069: PPUSH
24070: CALL_OW 72
24074: PUSH
24075: LD_VAR 0 2
24079: PPUSH
24080: LD_INT 2
24082: PUSH
24083: LD_INT 30
24085: PUSH
24086: LD_INT 4
24088: PUSH
24089: EMPTY
24090: LIST
24091: LIST
24092: PUSH
24093: LD_INT 30
24095: PUSH
24096: LD_INT 5
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: PUSH
24103: EMPTY
24104: LIST
24105: LIST
24106: LIST
24107: PPUSH
24108: CALL_OW 72
24112: ADD
24113: ST_TO_ADDR
24114: GO 24362
24116: LD_INT 2
24118: DOUBLE
24119: EQUAL
24120: IFTRUE 24130
24122: LD_INT 16
24124: DOUBLE
24125: EQUAL
24126: IFTRUE 24130
24128: GO 24176
24130: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
24131: LD_ADDR_VAR 0 8
24135: PUSH
24136: LD_VAR 0 2
24140: PPUSH
24141: LD_INT 2
24143: PUSH
24144: LD_INT 30
24146: PUSH
24147: LD_INT 0
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: LD_INT 30
24156: PUSH
24157: LD_INT 1
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: LIST
24168: PPUSH
24169: CALL_OW 72
24173: ST_TO_ADDR
24174: GO 24362
24176: LD_INT 3
24178: DOUBLE
24179: EQUAL
24180: IFTRUE 24184
24182: GO 24230
24184: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
24185: LD_ADDR_VAR 0 8
24189: PUSH
24190: LD_VAR 0 2
24194: PPUSH
24195: LD_INT 2
24197: PUSH
24198: LD_INT 30
24200: PUSH
24201: LD_INT 2
24203: PUSH
24204: EMPTY
24205: LIST
24206: LIST
24207: PUSH
24208: LD_INT 30
24210: PUSH
24211: LD_INT 3
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: PUSH
24218: EMPTY
24219: LIST
24220: LIST
24221: LIST
24222: PPUSH
24223: CALL_OW 72
24227: ST_TO_ADDR
24228: GO 24362
24230: LD_INT 4
24232: DOUBLE
24233: EQUAL
24234: IFTRUE 24238
24236: GO 24295
24238: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
24239: LD_ADDR_VAR 0 8
24243: PUSH
24244: LD_VAR 0 2
24248: PPUSH
24249: LD_INT 2
24251: PUSH
24252: LD_INT 30
24254: PUSH
24255: LD_INT 6
24257: PUSH
24258: EMPTY
24259: LIST
24260: LIST
24261: PUSH
24262: LD_INT 30
24264: PUSH
24265: LD_INT 7
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: PUSH
24272: LD_INT 30
24274: PUSH
24275: LD_INT 8
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: EMPTY
24283: LIST
24284: LIST
24285: LIST
24286: LIST
24287: PPUSH
24288: CALL_OW 72
24292: ST_TO_ADDR
24293: GO 24362
24295: LD_INT 5
24297: DOUBLE
24298: EQUAL
24299: IFTRUE 24315
24301: LD_INT 8
24303: DOUBLE
24304: EQUAL
24305: IFTRUE 24315
24307: LD_INT 9
24309: DOUBLE
24310: EQUAL
24311: IFTRUE 24315
24313: GO 24361
24315: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
24316: LD_ADDR_VAR 0 8
24320: PUSH
24321: LD_VAR 0 2
24325: PPUSH
24326: LD_INT 2
24328: PUSH
24329: LD_INT 30
24331: PUSH
24332: LD_INT 4
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 30
24341: PUSH
24342: LD_INT 5
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: LIST
24353: PPUSH
24354: CALL_OW 72
24358: ST_TO_ADDR
24359: GO 24362
24361: POP
// if not tmp then
24362: LD_VAR 0 8
24366: NOT
24367: IFFALSE 24371
// exit ;
24369: GO 24873
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
24371: LD_VAR 0 4
24375: PUSH
24376: LD_INT 1
24378: PUSH
24379: LD_INT 15
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: IN
24386: PUSH
24387: LD_EXP 66
24391: PUSH
24392: LD_VAR 0 1
24396: ARRAY
24397: AND
24398: IFFALSE 24554
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
24400: LD_ADDR_VAR 0 9
24404: PUSH
24405: LD_EXP 66
24409: PUSH
24410: LD_VAR 0 1
24414: ARRAY
24415: PUSH
24416: LD_INT 1
24418: ARRAY
24419: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
24420: LD_VAR 0 9
24424: PUSH
24425: LD_EXP 67
24429: PUSH
24430: LD_VAR 0 1
24434: ARRAY
24435: IN
24436: NOT
24437: IFFALSE 24552
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
24439: LD_ADDR_EXP 67
24443: PUSH
24444: LD_EXP 67
24448: PPUSH
24449: LD_VAR 0 1
24453: PUSH
24454: LD_EXP 67
24458: PUSH
24459: LD_VAR 0 1
24463: ARRAY
24464: PUSH
24465: LD_INT 1
24467: PLUS
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PPUSH
24473: LD_VAR 0 9
24477: PPUSH
24478: CALL 37882 0 3
24482: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
24483: LD_ADDR_EXP 66
24487: PUSH
24488: LD_EXP 66
24492: PPUSH
24493: LD_VAR 0 1
24497: PPUSH
24498: LD_EXP 66
24502: PUSH
24503: LD_VAR 0 1
24507: ARRAY
24508: PUSH
24509: LD_VAR 0 9
24513: DIFF
24514: PPUSH
24515: CALL_OW 1
24519: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
24520: LD_VAR 0 3
24524: PPUSH
24525: LD_EXP 67
24529: PUSH
24530: LD_VAR 0 1
24534: ARRAY
24535: PUSH
24536: LD_EXP 67
24540: PUSH
24541: LD_VAR 0 1
24545: ARRAY
24546: ARRAY
24547: PPUSH
24548: CALL_OW 120
// end ; exit ;
24552: GO 24873
// end ; if tmp > 1 then
24554: LD_VAR 0 8
24558: PUSH
24559: LD_INT 1
24561: GREATER
24562: IFFALSE 24666
// for i = 2 to tmp do
24564: LD_ADDR_VAR 0 6
24568: PUSH
24569: DOUBLE
24570: LD_INT 2
24572: DEC
24573: ST_TO_ADDR
24574: LD_VAR 0 8
24578: PUSH
24579: FOR_TO
24580: IFFALSE 24664
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
24582: LD_VAR 0 8
24586: PUSH
24587: LD_VAR 0 6
24591: ARRAY
24592: PPUSH
24593: CALL_OW 461
24597: PUSH
24598: LD_INT 6
24600: EQUAL
24601: IFFALSE 24662
// begin x := tmp [ i ] ;
24603: LD_ADDR_VAR 0 9
24607: PUSH
24608: LD_VAR 0 8
24612: PUSH
24613: LD_VAR 0 6
24617: ARRAY
24618: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
24619: LD_ADDR_VAR 0 8
24623: PUSH
24624: LD_VAR 0 8
24628: PPUSH
24629: LD_VAR 0 6
24633: PPUSH
24634: CALL_OW 3
24638: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
24639: LD_ADDR_VAR 0 8
24643: PUSH
24644: LD_VAR 0 8
24648: PPUSH
24649: LD_INT 1
24651: PPUSH
24652: LD_VAR 0 9
24656: PPUSH
24657: CALL_OW 2
24661: ST_TO_ADDR
// end ;
24662: GO 24579
24664: POP
24665: POP
// for i in tmp do
24666: LD_ADDR_VAR 0 6
24670: PUSH
24671: LD_VAR 0 8
24675: PUSH
24676: FOR_IN
24677: IFFALSE 24746
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
24679: LD_VAR 0 6
24683: PPUSH
24684: CALL_OW 313
24688: PUSH
24689: LD_INT 6
24691: LESS
24692: PUSH
24693: LD_VAR 0 6
24697: PPUSH
24698: CALL_OW 266
24702: PUSH
24703: LD_INT 31
24705: PUSH
24706: LD_INT 32
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: IN
24713: NOT
24714: AND
24715: PUSH
24716: LD_VAR 0 6
24720: PPUSH
24721: CALL_OW 313
24725: PUSH
24726: LD_INT 0
24728: EQUAL
24729: OR
24730: IFFALSE 24744
// begin j := i ;
24732: LD_ADDR_VAR 0 7
24736: PUSH
24737: LD_VAR 0 6
24741: ST_TO_ADDR
// break ;
24742: GO 24746
// end ; end ;
24744: GO 24676
24746: POP
24747: POP
// if j then
24748: LD_VAR 0 7
24752: IFFALSE 24770
// ComEnterUnit ( unit , j ) else
24754: LD_VAR 0 3
24758: PPUSH
24759: LD_VAR 0 7
24763: PPUSH
24764: CALL_OW 120
24768: GO 24873
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
24770: LD_ADDR_VAR 0 10
24774: PUSH
24775: LD_VAR 0 2
24779: PPUSH
24780: LD_INT 2
24782: PUSH
24783: LD_INT 30
24785: PUSH
24786: LD_INT 0
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: LD_INT 30
24795: PUSH
24796: LD_INT 1
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: LIST
24807: PPUSH
24808: CALL_OW 72
24812: ST_TO_ADDR
// if depot then
24813: LD_VAR 0 10
24817: IFFALSE 24873
// begin depot := NearestUnitToUnit ( depot , unit ) ;
24819: LD_ADDR_VAR 0 10
24823: PUSH
24824: LD_VAR 0 10
24828: PPUSH
24829: LD_VAR 0 3
24833: PPUSH
24834: CALL_OW 74
24838: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
24839: LD_VAR 0 3
24843: PPUSH
24844: LD_VAR 0 10
24848: PPUSH
24849: CALL_OW 296
24853: PUSH
24854: LD_INT 10
24856: GREATER
24857: IFFALSE 24873
// ComStandNearbyBuilding ( unit , depot ) ;
24859: LD_VAR 0 3
24863: PPUSH
24864: LD_VAR 0 10
24868: PPUSH
24869: CALL 32559 0 2
// end ; end ; end ;
24873: LD_VAR 0 5
24877: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
24878: LD_INT 0
24880: PPUSH
24881: PPUSH
24882: PPUSH
24883: PPUSH
// if not mc_bases then
24884: LD_EXP 57
24888: NOT
24889: IFFALSE 24893
// exit ;
24891: GO 25132
// for i = 1 to mc_bases do
24893: LD_ADDR_VAR 0 2
24897: PUSH
24898: DOUBLE
24899: LD_INT 1
24901: DEC
24902: ST_TO_ADDR
24903: LD_EXP 57
24907: PUSH
24908: FOR_TO
24909: IFFALSE 25130
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
24911: LD_ADDR_VAR 0 4
24915: PUSH
24916: LD_EXP 57
24920: PUSH
24921: LD_VAR 0 2
24925: ARRAY
24926: PPUSH
24927: LD_INT 21
24929: PUSH
24930: LD_INT 1
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PPUSH
24937: CALL_OW 72
24941: PUSH
24942: LD_EXP 86
24946: PUSH
24947: LD_VAR 0 2
24951: ARRAY
24952: UNION
24953: ST_TO_ADDR
// if not tmp then
24954: LD_VAR 0 4
24958: NOT
24959: IFFALSE 24963
// continue ;
24961: GO 24908
// for j in tmp do
24963: LD_ADDR_VAR 0 3
24967: PUSH
24968: LD_VAR 0 4
24972: PUSH
24973: FOR_IN
24974: IFFALSE 25126
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
24976: LD_VAR 0 3
24980: PPUSH
24981: CALL_OW 110
24985: NOT
24986: PUSH
24987: LD_VAR 0 3
24991: PPUSH
24992: CALL_OW 314
24996: NOT
24997: AND
24998: PUSH
24999: LD_VAR 0 3
25003: PPUSH
25004: CALL_OW 311
25008: NOT
25009: AND
25010: PUSH
25011: LD_VAR 0 3
25015: PPUSH
25016: CALL_OW 310
25020: NOT
25021: AND
25022: PUSH
25023: LD_VAR 0 3
25027: PUSH
25028: LD_EXP 60
25032: PUSH
25033: LD_VAR 0 2
25037: ARRAY
25038: PUSH
25039: LD_INT 1
25041: ARRAY
25042: IN
25043: NOT
25044: AND
25045: PUSH
25046: LD_VAR 0 3
25050: PUSH
25051: LD_EXP 60
25055: PUSH
25056: LD_VAR 0 2
25060: ARRAY
25061: PUSH
25062: LD_INT 2
25064: ARRAY
25065: IN
25066: NOT
25067: AND
25068: PUSH
25069: LD_VAR 0 3
25073: PUSH
25074: LD_EXP 69
25078: PUSH
25079: LD_VAR 0 2
25083: ARRAY
25084: IN
25085: NOT
25086: AND
25087: IFFALSE 25124
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
25089: LD_VAR 0 2
25093: PPUSH
25094: LD_EXP 57
25098: PUSH
25099: LD_VAR 0 2
25103: ARRAY
25104: PPUSH
25105: LD_VAR 0 3
25109: PPUSH
25110: LD_VAR 0 3
25114: PPUSH
25115: CALL_OW 257
25119: PPUSH
25120: CALL 23896 0 4
// end ;
25124: GO 24973
25126: POP
25127: POP
// end ;
25128: GO 24908
25130: POP
25131: POP
// end ;
25132: LD_VAR 0 1
25136: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
25137: LD_INT 0
25139: PPUSH
25140: PPUSH
25141: PPUSH
25142: PPUSH
25143: PPUSH
25144: PPUSH
// if not mc_bases [ base ] then
25145: LD_EXP 57
25149: PUSH
25150: LD_VAR 0 1
25154: ARRAY
25155: NOT
25156: IFFALSE 25160
// exit ;
25158: GO 25342
// tmp := [ ] ;
25160: LD_ADDR_VAR 0 6
25164: PUSH
25165: EMPTY
25166: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
25167: LD_ADDR_VAR 0 7
25171: PUSH
25172: LD_VAR 0 3
25176: PPUSH
25177: LD_INT 0
25179: PPUSH
25180: CALL_OW 517
25184: ST_TO_ADDR
// if not list then
25185: LD_VAR 0 7
25189: NOT
25190: IFFALSE 25194
// exit ;
25192: GO 25342
// for i = 1 to amount do
25194: LD_ADDR_VAR 0 5
25198: PUSH
25199: DOUBLE
25200: LD_INT 1
25202: DEC
25203: ST_TO_ADDR
25204: LD_VAR 0 2
25208: PUSH
25209: FOR_TO
25210: IFFALSE 25290
// begin x := rand ( 1 , list [ 1 ] ) ;
25212: LD_ADDR_VAR 0 8
25216: PUSH
25217: LD_INT 1
25219: PPUSH
25220: LD_VAR 0 7
25224: PUSH
25225: LD_INT 1
25227: ARRAY
25228: PPUSH
25229: CALL_OW 12
25233: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
25234: LD_ADDR_VAR 0 6
25238: PUSH
25239: LD_VAR 0 6
25243: PPUSH
25244: LD_VAR 0 5
25248: PPUSH
25249: LD_VAR 0 7
25253: PUSH
25254: LD_INT 1
25256: ARRAY
25257: PUSH
25258: LD_VAR 0 8
25262: ARRAY
25263: PUSH
25264: LD_VAR 0 7
25268: PUSH
25269: LD_INT 2
25271: ARRAY
25272: PUSH
25273: LD_VAR 0 8
25277: ARRAY
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PPUSH
25283: CALL_OW 1
25287: ST_TO_ADDR
// end ;
25288: GO 25209
25290: POP
25291: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
25292: LD_ADDR_EXP 70
25296: PUSH
25297: LD_EXP 70
25301: PPUSH
25302: LD_VAR 0 1
25306: PPUSH
25307: LD_VAR 0 6
25311: PPUSH
25312: CALL_OW 1
25316: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
25317: LD_ADDR_EXP 72
25321: PUSH
25322: LD_EXP 72
25326: PPUSH
25327: LD_VAR 0 1
25331: PPUSH
25332: LD_VAR 0 3
25336: PPUSH
25337: CALL_OW 1
25341: ST_TO_ADDR
// end ;
25342: LD_VAR 0 4
25346: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
25347: LD_INT 0
25349: PPUSH
// if not mc_bases [ base ] then
25350: LD_EXP 57
25354: PUSH
25355: LD_VAR 0 1
25359: ARRAY
25360: NOT
25361: IFFALSE 25365
// exit ;
25363: GO 25390
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
25365: LD_ADDR_EXP 62
25369: PUSH
25370: LD_EXP 62
25374: PPUSH
25375: LD_VAR 0 1
25379: PPUSH
25380: LD_VAR 0 2
25384: PPUSH
25385: CALL_OW 1
25389: ST_TO_ADDR
// end ;
25390: LD_VAR 0 3
25394: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
25395: LD_INT 0
25397: PPUSH
// if not mc_bases [ base ] then
25398: LD_EXP 57
25402: PUSH
25403: LD_VAR 0 1
25407: ARRAY
25408: NOT
25409: IFFALSE 25413
// exit ;
25411: GO 25450
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
25413: LD_ADDR_EXP 62
25417: PUSH
25418: LD_EXP 62
25422: PPUSH
25423: LD_VAR 0 1
25427: PPUSH
25428: LD_EXP 62
25432: PUSH
25433: LD_VAR 0 1
25437: ARRAY
25438: PUSH
25439: LD_VAR 0 2
25443: UNION
25444: PPUSH
25445: CALL_OW 1
25449: ST_TO_ADDR
// end ;
25450: LD_VAR 0 3
25454: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
25455: LD_INT 0
25457: PPUSH
// if not mc_bases [ base ] then
25458: LD_EXP 57
25462: PUSH
25463: LD_VAR 0 1
25467: ARRAY
25468: NOT
25469: IFFALSE 25473
// exit ;
25471: GO 25498
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
25473: LD_ADDR_EXP 78
25477: PUSH
25478: LD_EXP 78
25482: PPUSH
25483: LD_VAR 0 1
25487: PPUSH
25488: LD_VAR 0 2
25492: PPUSH
25493: CALL_OW 1
25497: ST_TO_ADDR
// end ;
25498: LD_VAR 0 3
25502: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
25503: LD_INT 0
25505: PPUSH
// if not mc_bases [ base ] then
25506: LD_EXP 57
25510: PUSH
25511: LD_VAR 0 1
25515: ARRAY
25516: NOT
25517: IFFALSE 25521
// exit ;
25519: GO 25558
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
25521: LD_ADDR_EXP 78
25525: PUSH
25526: LD_EXP 78
25530: PPUSH
25531: LD_VAR 0 1
25535: PPUSH
25536: LD_EXP 78
25540: PUSH
25541: LD_VAR 0 1
25545: ARRAY
25546: PUSH
25547: LD_VAR 0 2
25551: UNION
25552: PPUSH
25553: CALL_OW 1
25557: ST_TO_ADDR
// end ;
25558: LD_VAR 0 3
25562: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
25563: LD_INT 0
25565: PPUSH
// if not mc_bases [ base ] then
25566: LD_EXP 57
25570: PUSH
25571: LD_VAR 0 1
25575: ARRAY
25576: NOT
25577: IFFALSE 25581
// exit ;
25579: GO 25693
// mc_defender := Replace ( mc_defender , base , deflist ) ;
25581: LD_ADDR_EXP 79
25585: PUSH
25586: LD_EXP 79
25590: PPUSH
25591: LD_VAR 0 1
25595: PPUSH
25596: LD_VAR 0 2
25600: PPUSH
25601: CALL_OW 1
25605: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
25606: LD_ADDR_EXP 68
25610: PUSH
25611: LD_EXP 68
25615: PPUSH
25616: LD_VAR 0 1
25620: PPUSH
25621: LD_VAR 0 2
25625: PUSH
25626: LD_INT 0
25628: PLUS
25629: PPUSH
25630: CALL_OW 1
25634: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
25635: LD_ADDR_EXP 76
25639: PUSH
25640: LD_EXP 76
25644: PPUSH
25645: LD_VAR 0 1
25649: PPUSH
25650: LD_EXP 76
25654: PUSH
25655: LD_VAR 0 1
25659: ARRAY
25660: PUSH
25661: LD_EXP 79
25665: PUSH
25666: LD_VAR 0 1
25670: ARRAY
25671: PPUSH
25672: LD_INT 21
25674: PUSH
25675: LD_INT 2
25677: PUSH
25678: EMPTY
25679: LIST
25680: LIST
25681: PPUSH
25682: CALL_OW 72
25686: UNION
25687: PPUSH
25688: CALL_OW 1
25692: ST_TO_ADDR
// end ;
25693: LD_VAR 0 3
25697: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
25698: LD_INT 0
25700: PPUSH
// if not mc_bases [ base ] then
25701: LD_EXP 57
25705: PUSH
25706: LD_VAR 0 1
25710: ARRAY
25711: NOT
25712: IFFALSE 25716
// exit ;
25714: GO 25741
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
25716: LD_ADDR_EXP 68
25720: PUSH
25721: LD_EXP 68
25725: PPUSH
25726: LD_VAR 0 1
25730: PPUSH
25731: LD_VAR 0 2
25735: PPUSH
25736: CALL_OW 1
25740: ST_TO_ADDR
// end ;
25741: LD_VAR 0 3
25745: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
25746: LD_INT 0
25748: PPUSH
25749: PPUSH
25750: PPUSH
25751: PPUSH
// if not mc_bases [ base ] then
25752: LD_EXP 57
25756: PUSH
25757: LD_VAR 0 1
25761: ARRAY
25762: NOT
25763: IFFALSE 25767
// exit ;
25765: GO 25832
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
25767: LD_ADDR_EXP 77
25771: PUSH
25772: LD_EXP 77
25776: PPUSH
25777: LD_VAR 0 1
25781: PUSH
25782: LD_EXP 77
25786: PUSH
25787: LD_VAR 0 1
25791: ARRAY
25792: PUSH
25793: LD_INT 1
25795: PLUS
25796: PUSH
25797: EMPTY
25798: LIST
25799: LIST
25800: PPUSH
25801: LD_VAR 0 1
25805: PUSH
25806: LD_VAR 0 2
25810: PUSH
25811: LD_VAR 0 3
25815: PUSH
25816: LD_VAR 0 4
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: LIST
25825: LIST
25826: PPUSH
25827: CALL 37882 0 3
25831: ST_TO_ADDR
// end ;
25832: LD_VAR 0 5
25836: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
25837: LD_INT 0
25839: PPUSH
// if not mc_bases [ base ] then
25840: LD_EXP 57
25844: PUSH
25845: LD_VAR 0 1
25849: ARRAY
25850: NOT
25851: IFFALSE 25855
// exit ;
25853: GO 25880
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
25855: LD_ADDR_EXP 94
25859: PUSH
25860: LD_EXP 94
25864: PPUSH
25865: LD_VAR 0 1
25869: PPUSH
25870: LD_VAR 0 2
25874: PPUSH
25875: CALL_OW 1
25879: ST_TO_ADDR
// end ;
25880: LD_VAR 0 3
25884: RET
// export function MC_GetMinesField ( base ) ; begin
25885: LD_INT 0
25887: PPUSH
// result := mc_mines [ base ] ;
25888: LD_ADDR_VAR 0 2
25892: PUSH
25893: LD_EXP 70
25897: PUSH
25898: LD_VAR 0 1
25902: ARRAY
25903: ST_TO_ADDR
// end ;
25904: LD_VAR 0 2
25908: RET
// export function MC_GetProduceList ( base ) ; begin
25909: LD_INT 0
25911: PPUSH
// result := mc_produce [ base ] ;
25912: LD_ADDR_VAR 0 2
25916: PUSH
25917: LD_EXP 78
25921: PUSH
25922: LD_VAR 0 1
25926: ARRAY
25927: ST_TO_ADDR
// end ;
25928: LD_VAR 0 2
25932: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
// if not mc_bases then
25937: LD_EXP 57
25941: NOT
25942: IFFALSE 25946
// exit ;
25944: GO 26011
// if mc_bases [ base ] then
25946: LD_EXP 57
25950: PUSH
25951: LD_VAR 0 1
25955: ARRAY
25956: IFFALSE 26011
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
25958: LD_ADDR_VAR 0 3
25962: PUSH
25963: LD_EXP 57
25967: PUSH
25968: LD_VAR 0 1
25972: ARRAY
25973: PPUSH
25974: LD_INT 30
25976: PUSH
25977: LD_VAR 0 2
25981: PUSH
25982: EMPTY
25983: LIST
25984: LIST
25985: PPUSH
25986: CALL_OW 72
25990: ST_TO_ADDR
// if result then
25991: LD_VAR 0 3
25995: IFFALSE 26011
// result := result [ 1 ] ;
25997: LD_ADDR_VAR 0 3
26001: PUSH
26002: LD_VAR 0 3
26006: PUSH
26007: LD_INT 1
26009: ARRAY
26010: ST_TO_ADDR
// end ; end ;
26011: LD_VAR 0 3
26015: RET
// export function MC_SetTame ( base , area ) ; begin
26016: LD_INT 0
26018: PPUSH
// if not mc_bases or not base then
26019: LD_EXP 57
26023: NOT
26024: PUSH
26025: LD_VAR 0 1
26029: NOT
26030: OR
26031: IFFALSE 26035
// exit ;
26033: GO 26060
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
26035: LD_ADDR_EXP 85
26039: PUSH
26040: LD_EXP 85
26044: PPUSH
26045: LD_VAR 0 1
26049: PPUSH
26050: LD_VAR 0 2
26054: PPUSH
26055: CALL_OW 1
26059: ST_TO_ADDR
// end ;
26060: LD_VAR 0 3
26064: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
26065: LD_INT 0
26067: PPUSH
26068: PPUSH
// if not mc_bases or not base then
26069: LD_EXP 57
26073: NOT
26074: PUSH
26075: LD_VAR 0 1
26079: NOT
26080: OR
26081: IFFALSE 26085
// exit ;
26083: GO 26187
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
26085: LD_ADDR_VAR 0 4
26089: PUSH
26090: LD_EXP 57
26094: PUSH
26095: LD_VAR 0 1
26099: ARRAY
26100: PPUSH
26101: LD_INT 30
26103: PUSH
26104: LD_VAR 0 2
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PPUSH
26113: CALL_OW 72
26117: ST_TO_ADDR
// if not tmp then
26118: LD_VAR 0 4
26122: NOT
26123: IFFALSE 26127
// exit ;
26125: GO 26187
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
26127: LD_ADDR_EXP 89
26131: PUSH
26132: LD_EXP 89
26136: PPUSH
26137: LD_VAR 0 1
26141: PPUSH
26142: LD_EXP 89
26146: PUSH
26147: LD_VAR 0 1
26151: ARRAY
26152: PPUSH
26153: LD_EXP 89
26157: PUSH
26158: LD_VAR 0 1
26162: ARRAY
26163: PUSH
26164: LD_INT 1
26166: PLUS
26167: PPUSH
26168: LD_VAR 0 4
26172: PUSH
26173: LD_INT 1
26175: ARRAY
26176: PPUSH
26177: CALL_OW 2
26181: PPUSH
26182: CALL_OW 1
26186: ST_TO_ADDR
// end ;
26187: LD_VAR 0 3
26191: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
26192: LD_INT 0
26194: PPUSH
26195: PPUSH
// if not mc_bases or not base or not kinds then
26196: LD_EXP 57
26200: NOT
26201: PUSH
26202: LD_VAR 0 1
26206: NOT
26207: OR
26208: PUSH
26209: LD_VAR 0 2
26213: NOT
26214: OR
26215: IFFALSE 26219
// exit ;
26217: GO 26280
// for i in kinds do
26219: LD_ADDR_VAR 0 4
26223: PUSH
26224: LD_VAR 0 2
26228: PUSH
26229: FOR_IN
26230: IFFALSE 26278
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
26232: LD_ADDR_EXP 91
26236: PUSH
26237: LD_EXP 91
26241: PPUSH
26242: LD_VAR 0 1
26246: PUSH
26247: LD_EXP 91
26251: PUSH
26252: LD_VAR 0 1
26256: ARRAY
26257: PUSH
26258: LD_INT 1
26260: PLUS
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PPUSH
26266: LD_VAR 0 4
26270: PPUSH
26271: CALL 37882 0 3
26275: ST_TO_ADDR
26276: GO 26229
26278: POP
26279: POP
// end ;
26280: LD_VAR 0 3
26284: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
26285: LD_INT 0
26287: PPUSH
// if not mc_bases or not base or not areas then
26288: LD_EXP 57
26292: NOT
26293: PUSH
26294: LD_VAR 0 1
26298: NOT
26299: OR
26300: PUSH
26301: LD_VAR 0 2
26305: NOT
26306: OR
26307: IFFALSE 26311
// exit ;
26309: GO 26336
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
26311: LD_ADDR_EXP 75
26315: PUSH
26316: LD_EXP 75
26320: PPUSH
26321: LD_VAR 0 1
26325: PPUSH
26326: LD_VAR 0 2
26330: PPUSH
26331: CALL_OW 1
26335: ST_TO_ADDR
// end ;
26336: LD_VAR 0 3
26340: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
26341: LD_INT 0
26343: PPUSH
// if not mc_bases or not base or not teleports_exit then
26344: LD_EXP 57
26348: NOT
26349: PUSH
26350: LD_VAR 0 1
26354: NOT
26355: OR
26356: PUSH
26357: LD_VAR 0 2
26361: NOT
26362: OR
26363: IFFALSE 26367
// exit ;
26365: GO 26392
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
26367: LD_ADDR_EXP 92
26371: PUSH
26372: LD_EXP 92
26376: PPUSH
26377: LD_VAR 0 1
26381: PPUSH
26382: LD_VAR 0 2
26386: PPUSH
26387: CALL_OW 1
26391: ST_TO_ADDR
// end ;
26392: LD_VAR 0 3
26396: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
26397: LD_INT 0
26399: PPUSH
26400: PPUSH
26401: PPUSH
// if not mc_bases or not base or not ext_list then
26402: LD_EXP 57
26406: NOT
26407: PUSH
26408: LD_VAR 0 1
26412: NOT
26413: OR
26414: PUSH
26415: LD_VAR 0 5
26419: NOT
26420: OR
26421: IFFALSE 26425
// exit ;
26423: GO 26598
// tmp := GetFacExtXYD ( x , y , d ) ;
26425: LD_ADDR_VAR 0 8
26429: PUSH
26430: LD_VAR 0 2
26434: PPUSH
26435: LD_VAR 0 3
26439: PPUSH
26440: LD_VAR 0 4
26444: PPUSH
26445: CALL 71197 0 3
26449: ST_TO_ADDR
// if not tmp then
26450: LD_VAR 0 8
26454: NOT
26455: IFFALSE 26459
// exit ;
26457: GO 26598
// for i in tmp do
26459: LD_ADDR_VAR 0 7
26463: PUSH
26464: LD_VAR 0 8
26468: PUSH
26469: FOR_IN
26470: IFFALSE 26596
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
26472: LD_ADDR_EXP 62
26476: PUSH
26477: LD_EXP 62
26481: PPUSH
26482: LD_VAR 0 1
26486: PPUSH
26487: LD_EXP 62
26491: PUSH
26492: LD_VAR 0 1
26496: ARRAY
26497: PPUSH
26498: LD_EXP 62
26502: PUSH
26503: LD_VAR 0 1
26507: ARRAY
26508: PUSH
26509: LD_INT 1
26511: PLUS
26512: PPUSH
26513: LD_VAR 0 5
26517: PUSH
26518: LD_INT 1
26520: ARRAY
26521: PUSH
26522: LD_VAR 0 7
26526: PUSH
26527: LD_INT 1
26529: ARRAY
26530: PUSH
26531: LD_VAR 0 7
26535: PUSH
26536: LD_INT 2
26538: ARRAY
26539: PUSH
26540: LD_VAR 0 7
26544: PUSH
26545: LD_INT 3
26547: ARRAY
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: PPUSH
26555: CALL_OW 2
26559: PPUSH
26560: CALL_OW 1
26564: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
26565: LD_ADDR_VAR 0 5
26569: PUSH
26570: LD_VAR 0 5
26574: PPUSH
26575: LD_INT 1
26577: PPUSH
26578: CALL_OW 3
26582: ST_TO_ADDR
// if not ext_list then
26583: LD_VAR 0 5
26587: NOT
26588: IFFALSE 26594
// exit ;
26590: POP
26591: POP
26592: GO 26598
// end ;
26594: GO 26469
26596: POP
26597: POP
// end ;
26598: LD_VAR 0 6
26602: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
26603: LD_INT 0
26605: PPUSH
// if not mc_bases or not base or not weapon_list then
26606: LD_EXP 57
26610: NOT
26611: PUSH
26612: LD_VAR 0 1
26616: NOT
26617: OR
26618: PUSH
26619: LD_VAR 0 2
26623: NOT
26624: OR
26625: IFFALSE 26629
// exit ;
26627: GO 26654
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
26629: LD_ADDR_EXP 96
26633: PUSH
26634: LD_EXP 96
26638: PPUSH
26639: LD_VAR 0 1
26643: PPUSH
26644: LD_VAR 0 2
26648: PPUSH
26649: CALL_OW 1
26653: ST_TO_ADDR
// end ;
26654: LD_VAR 0 3
26658: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
26659: LD_INT 0
26661: PPUSH
// if not mc_bases or not base or not tech_list then
26662: LD_EXP 57
26666: NOT
26667: PUSH
26668: LD_VAR 0 1
26672: NOT
26673: OR
26674: PUSH
26675: LD_VAR 0 2
26679: NOT
26680: OR
26681: IFFALSE 26685
// exit ;
26683: GO 26710
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
26685: LD_ADDR_EXP 84
26689: PUSH
26690: LD_EXP 84
26694: PPUSH
26695: LD_VAR 0 1
26699: PPUSH
26700: LD_VAR 0 2
26704: PPUSH
26705: CALL_OW 1
26709: ST_TO_ADDR
// end ;
26710: LD_VAR 0 3
26714: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
26715: LD_INT 0
26717: PPUSH
// if not mc_bases or not parking_area or not base then
26718: LD_EXP 57
26722: NOT
26723: PUSH
26724: LD_VAR 0 2
26728: NOT
26729: OR
26730: PUSH
26731: LD_VAR 0 1
26735: NOT
26736: OR
26737: IFFALSE 26741
// exit ;
26739: GO 26766
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
26741: LD_ADDR_EXP 81
26745: PUSH
26746: LD_EXP 81
26750: PPUSH
26751: LD_VAR 0 1
26755: PPUSH
26756: LD_VAR 0 2
26760: PPUSH
26761: CALL_OW 1
26765: ST_TO_ADDR
// end ;
26766: LD_VAR 0 3
26770: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
26771: LD_INT 0
26773: PPUSH
// if not mc_bases or not base or not scan_area then
26774: LD_EXP 57
26778: NOT
26779: PUSH
26780: LD_VAR 0 1
26784: NOT
26785: OR
26786: PUSH
26787: LD_VAR 0 2
26791: NOT
26792: OR
26793: IFFALSE 26797
// exit ;
26795: GO 26822
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
26797: LD_ADDR_EXP 82
26801: PUSH
26802: LD_EXP 82
26806: PPUSH
26807: LD_VAR 0 1
26811: PPUSH
26812: LD_VAR 0 2
26816: PPUSH
26817: CALL_OW 1
26821: ST_TO_ADDR
// end ;
26822: LD_VAR 0 3
26826: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
26827: LD_INT 0
26829: PPUSH
26830: PPUSH
// if not mc_bases or not base then
26831: LD_EXP 57
26835: NOT
26836: PUSH
26837: LD_VAR 0 1
26841: NOT
26842: OR
26843: IFFALSE 26847
// exit ;
26845: GO 26911
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
26847: LD_ADDR_VAR 0 3
26851: PUSH
26852: LD_INT 1
26854: PUSH
26855: LD_INT 2
26857: PUSH
26858: LD_INT 3
26860: PUSH
26861: LD_INT 4
26863: PUSH
26864: LD_INT 11
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: LIST
26871: LIST
26872: LIST
26873: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
26874: LD_ADDR_EXP 84
26878: PUSH
26879: LD_EXP 84
26883: PPUSH
26884: LD_VAR 0 1
26888: PPUSH
26889: LD_EXP 84
26893: PUSH
26894: LD_VAR 0 1
26898: ARRAY
26899: PUSH
26900: LD_VAR 0 3
26904: DIFF
26905: PPUSH
26906: CALL_OW 1
26910: ST_TO_ADDR
// end ; end_of_file
26911: LD_VAR 0 2
26915: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
26916: LD_INT 0
26918: PPUSH
26919: PPUSH
26920: PPUSH
// if not mc_bases then
26921: LD_EXP 57
26925: NOT
26926: IFFALSE 26930
// exit ;
26928: GO 27095
// for i = 1 to mc_bases do
26930: LD_ADDR_VAR 0 4
26934: PUSH
26935: DOUBLE
26936: LD_INT 1
26938: DEC
26939: ST_TO_ADDR
26940: LD_EXP 57
26944: PUSH
26945: FOR_TO
26946: IFFALSE 27093
// begin if sci in mc_bases [ i ] then
26948: LD_VAR 0 2
26952: PUSH
26953: LD_EXP 57
26957: PUSH
26958: LD_VAR 0 4
26962: ARRAY
26963: IN
26964: IFFALSE 27091
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
26966: LD_ADDR_EXP 86
26970: PUSH
26971: LD_EXP 86
26975: PPUSH
26976: LD_VAR 0 4
26980: PUSH
26981: LD_EXP 86
26985: PUSH
26986: LD_VAR 0 4
26990: ARRAY
26991: PUSH
26992: LD_INT 1
26994: PLUS
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PPUSH
27000: LD_VAR 0 1
27004: PPUSH
27005: CALL 37882 0 3
27009: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
27010: LD_ADDR_VAR 0 5
27014: PUSH
27015: LD_EXP 57
27019: PUSH
27020: LD_VAR 0 4
27024: ARRAY
27025: PPUSH
27026: LD_INT 2
27028: PUSH
27029: LD_INT 30
27031: PUSH
27032: LD_INT 0
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 30
27041: PUSH
27042: LD_INT 1
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: LIST
27053: PPUSH
27054: CALL_OW 72
27058: PPUSH
27059: LD_VAR 0 1
27063: PPUSH
27064: CALL_OW 74
27068: ST_TO_ADDR
// if tmp then
27069: LD_VAR 0 5
27073: IFFALSE 27089
// ComStandNearbyBuilding ( ape , tmp ) ;
27075: LD_VAR 0 1
27079: PPUSH
27080: LD_VAR 0 5
27084: PPUSH
27085: CALL 32559 0 2
// break ;
27089: GO 27093
// end ; end ;
27091: GO 26945
27093: POP
27094: POP
// end ;
27095: LD_VAR 0 3
27099: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
27100: LD_INT 0
27102: PPUSH
27103: PPUSH
27104: PPUSH
// if not mc_bases then
27105: LD_EXP 57
27109: NOT
27110: IFFALSE 27114
// exit ;
27112: GO 27203
// for i = 1 to mc_bases do
27114: LD_ADDR_VAR 0 4
27118: PUSH
27119: DOUBLE
27120: LD_INT 1
27122: DEC
27123: ST_TO_ADDR
27124: LD_EXP 57
27128: PUSH
27129: FOR_TO
27130: IFFALSE 27201
// begin if building in mc_busy_turret_list [ i ] then
27132: LD_VAR 0 1
27136: PUSH
27137: LD_EXP 67
27141: PUSH
27142: LD_VAR 0 4
27146: ARRAY
27147: IN
27148: IFFALSE 27199
// begin tmp := mc_busy_turret_list [ i ] diff building ;
27150: LD_ADDR_VAR 0 5
27154: PUSH
27155: LD_EXP 67
27159: PUSH
27160: LD_VAR 0 4
27164: ARRAY
27165: PUSH
27166: LD_VAR 0 1
27170: DIFF
27171: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
27172: LD_ADDR_EXP 67
27176: PUSH
27177: LD_EXP 67
27181: PPUSH
27182: LD_VAR 0 4
27186: PPUSH
27187: LD_VAR 0 5
27191: PPUSH
27192: CALL_OW 1
27196: ST_TO_ADDR
// break ;
27197: GO 27201
// end ; end ;
27199: GO 27129
27201: POP
27202: POP
// end ;
27203: LD_VAR 0 3
27207: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
27208: LD_INT 0
27210: PPUSH
27211: PPUSH
27212: PPUSH
// if not mc_bases then
27213: LD_EXP 57
27217: NOT
27218: IFFALSE 27222
// exit ;
27220: GO 27421
// for i = 1 to mc_bases do
27222: LD_ADDR_VAR 0 5
27226: PUSH
27227: DOUBLE
27228: LD_INT 1
27230: DEC
27231: ST_TO_ADDR
27232: LD_EXP 57
27236: PUSH
27237: FOR_TO
27238: IFFALSE 27419
// if building in mc_bases [ i ] then
27240: LD_VAR 0 1
27244: PUSH
27245: LD_EXP 57
27249: PUSH
27250: LD_VAR 0 5
27254: ARRAY
27255: IN
27256: IFFALSE 27417
// begin tmp := mc_bases [ i ] diff building ;
27258: LD_ADDR_VAR 0 6
27262: PUSH
27263: LD_EXP 57
27267: PUSH
27268: LD_VAR 0 5
27272: ARRAY
27273: PUSH
27274: LD_VAR 0 1
27278: DIFF
27279: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
27280: LD_ADDR_EXP 57
27284: PUSH
27285: LD_EXP 57
27289: PPUSH
27290: LD_VAR 0 5
27294: PPUSH
27295: LD_VAR 0 6
27299: PPUSH
27300: CALL_OW 1
27304: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
27305: LD_VAR 0 1
27309: PUSH
27310: LD_EXP 65
27314: PUSH
27315: LD_VAR 0 5
27319: ARRAY
27320: IN
27321: IFFALSE 27360
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
27323: LD_ADDR_EXP 65
27327: PUSH
27328: LD_EXP 65
27332: PPUSH
27333: LD_VAR 0 5
27337: PPUSH
27338: LD_EXP 65
27342: PUSH
27343: LD_VAR 0 5
27347: ARRAY
27348: PUSH
27349: LD_VAR 0 1
27353: DIFF
27354: PPUSH
27355: CALL_OW 1
27359: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
27360: LD_VAR 0 1
27364: PUSH
27365: LD_EXP 66
27369: PUSH
27370: LD_VAR 0 5
27374: ARRAY
27375: IN
27376: IFFALSE 27415
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
27378: LD_ADDR_EXP 66
27382: PUSH
27383: LD_EXP 66
27387: PPUSH
27388: LD_VAR 0 5
27392: PPUSH
27393: LD_EXP 66
27397: PUSH
27398: LD_VAR 0 5
27402: ARRAY
27403: PUSH
27404: LD_VAR 0 1
27408: DIFF
27409: PPUSH
27410: CALL_OW 1
27414: ST_TO_ADDR
// break ;
27415: GO 27419
// end ;
27417: GO 27237
27419: POP
27420: POP
// end ;
27421: LD_VAR 0 4
27425: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
27426: LD_INT 0
27428: PPUSH
27429: PPUSH
27430: PPUSH
// if not mc_bases or not side in mc_sides then
27431: LD_EXP 57
27435: NOT
27436: PUSH
27437: LD_VAR 0 3
27441: PUSH
27442: LD_EXP 83
27446: IN
27447: NOT
27448: OR
27449: IFFALSE 27453
// exit ;
27451: GO 27576
// for i = 1 to mc_vehicles do
27453: LD_ADDR_VAR 0 6
27457: PUSH
27458: DOUBLE
27459: LD_INT 1
27461: DEC
27462: ST_TO_ADDR
27463: LD_EXP 76
27467: PUSH
27468: FOR_TO
27469: IFFALSE 27574
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
27471: LD_VAR 0 2
27475: PUSH
27476: LD_EXP 76
27480: PUSH
27481: LD_VAR 0 6
27485: ARRAY
27486: IN
27487: PUSH
27488: LD_VAR 0 1
27492: PUSH
27493: LD_EXP 76
27497: PUSH
27498: LD_VAR 0 6
27502: ARRAY
27503: IN
27504: OR
27505: IFFALSE 27572
// begin tmp := mc_vehicles [ i ] diff old ;
27507: LD_ADDR_VAR 0 7
27511: PUSH
27512: LD_EXP 76
27516: PUSH
27517: LD_VAR 0 6
27521: ARRAY
27522: PUSH
27523: LD_VAR 0 2
27527: DIFF
27528: ST_TO_ADDR
// tmp := tmp diff new ;
27529: LD_ADDR_VAR 0 7
27533: PUSH
27534: LD_VAR 0 7
27538: PUSH
27539: LD_VAR 0 1
27543: DIFF
27544: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
27545: LD_ADDR_EXP 76
27549: PUSH
27550: LD_EXP 76
27554: PPUSH
27555: LD_VAR 0 6
27559: PPUSH
27560: LD_VAR 0 7
27564: PPUSH
27565: CALL_OW 1
27569: ST_TO_ADDR
// break ;
27570: GO 27574
// end ;
27572: GO 27468
27574: POP
27575: POP
// end ;
27576: LD_VAR 0 5
27580: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
27581: LD_INT 0
27583: PPUSH
27584: PPUSH
27585: PPUSH
27586: PPUSH
// if not mc_bases then
27587: LD_EXP 57
27591: NOT
27592: IFFALSE 27596
// exit ;
27594: GO 27979
// side := GetSide ( vehicle ) ;
27596: LD_ADDR_VAR 0 5
27600: PUSH
27601: LD_VAR 0 1
27605: PPUSH
27606: CALL_OW 255
27610: ST_TO_ADDR
// for i = 1 to mc_bases do
27611: LD_ADDR_VAR 0 4
27615: PUSH
27616: DOUBLE
27617: LD_INT 1
27619: DEC
27620: ST_TO_ADDR
27621: LD_EXP 57
27625: PUSH
27626: FOR_TO
27627: IFFALSE 27977
// begin if factory in mc_bases [ i ] then
27629: LD_VAR 0 2
27633: PUSH
27634: LD_EXP 57
27638: PUSH
27639: LD_VAR 0 4
27643: ARRAY
27644: IN
27645: IFFALSE 27975
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
27647: LD_EXP 79
27651: PUSH
27652: LD_VAR 0 4
27656: ARRAY
27657: PUSH
27658: LD_EXP 68
27662: PUSH
27663: LD_VAR 0 4
27667: ARRAY
27668: LESS
27669: PUSH
27670: LD_VAR 0 1
27674: PPUSH
27675: CALL_OW 264
27679: PUSH
27680: LD_INT 31
27682: PUSH
27683: LD_INT 32
27685: PUSH
27686: LD_INT 51
27688: PUSH
27689: LD_EXP 51
27693: PUSH
27694: LD_INT 12
27696: PUSH
27697: LD_INT 30
27699: PUSH
27700: LD_EXP 50
27704: PUSH
27705: LD_INT 11
27707: PUSH
27708: LD_INT 53
27710: PUSH
27711: LD_INT 14
27713: PUSH
27714: LD_EXP 54
27718: PUSH
27719: LD_INT 29
27721: PUSH
27722: LD_EXP 52
27726: PUSH
27727: LD_INT 13
27729: PUSH
27730: LD_INT 52
27732: PUSH
27733: LD_INT 48
27735: PUSH
27736: LD_INT 8
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: LIST
27743: LIST
27744: LIST
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: IN
27758: NOT
27759: AND
27760: IFFALSE 27801
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
27762: LD_ADDR_EXP 79
27766: PUSH
27767: LD_EXP 79
27771: PPUSH
27772: LD_VAR 0 4
27776: PPUSH
27777: LD_EXP 79
27781: PUSH
27782: LD_VAR 0 4
27786: ARRAY
27787: PUSH
27788: LD_VAR 0 1
27792: ADD
27793: PPUSH
27794: CALL_OW 1
27798: ST_TO_ADDR
27799: GO 27845
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
27801: LD_ADDR_EXP 76
27805: PUSH
27806: LD_EXP 76
27810: PPUSH
27811: LD_VAR 0 4
27815: PUSH
27816: LD_EXP 76
27820: PUSH
27821: LD_VAR 0 4
27825: ARRAY
27826: PUSH
27827: LD_INT 1
27829: PLUS
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PPUSH
27835: LD_VAR 0 1
27839: PPUSH
27840: CALL 37882 0 3
27844: ST_TO_ADDR
// if not mc_scan [ i ] then
27845: LD_EXP 80
27849: PUSH
27850: LD_VAR 0 4
27854: ARRAY
27855: NOT
27856: IFFALSE 27975
// begin if GetControl ( vehicle ) = control_remote then
27858: LD_VAR 0 1
27862: PPUSH
27863: CALL_OW 263
27867: PUSH
27868: LD_INT 2
27870: EQUAL
27871: IFFALSE 27891
// repeat wait ( 0 0$1 ) ;
27873: LD_INT 35
27875: PPUSH
27876: CALL_OW 67
// until IsControledBy ( vehicle ) ;
27880: LD_VAR 0 1
27884: PPUSH
27885: CALL_OW 312
27889: IFFALSE 27873
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
27891: LD_VAR 0 1
27895: PPUSH
27896: LD_EXP 81
27900: PUSH
27901: LD_VAR 0 4
27905: ARRAY
27906: PPUSH
27907: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
27911: LD_VAR 0 1
27915: PPUSH
27916: CALL_OW 263
27920: PUSH
27921: LD_INT 1
27923: NONEQUAL
27924: IFFALSE 27928
// break ;
27926: GO 27977
// repeat wait ( 0 0$1 ) ;
27928: LD_INT 35
27930: PPUSH
27931: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
27935: LD_VAR 0 1
27939: PPUSH
27940: LD_EXP 81
27944: PUSH
27945: LD_VAR 0 4
27949: ARRAY
27950: PPUSH
27951: CALL_OW 308
27955: IFFALSE 27928
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
27957: LD_VAR 0 1
27961: PPUSH
27962: CALL_OW 311
27966: PPUSH
27967: CALL_OW 121
// exit ;
27971: POP
27972: POP
27973: GO 27979
// end ; end ; end ;
27975: GO 27626
27977: POP
27978: POP
// end ;
27979: LD_VAR 0 3
27983: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
27984: LD_INT 0
27986: PPUSH
27987: PPUSH
27988: PPUSH
27989: PPUSH
// if not mc_bases then
27990: LD_EXP 57
27994: NOT
27995: IFFALSE 27999
// exit ;
27997: GO 28352
// repeat wait ( 0 0$1 ) ;
27999: LD_INT 35
28001: PPUSH
28002: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
28006: LD_VAR 0 2
28010: PPUSH
28011: LD_VAR 0 3
28015: PPUSH
28016: CALL_OW 284
28020: IFFALSE 27999
// if GetResourceTypeXY ( x , y ) = mat_artefact then
28022: LD_VAR 0 2
28026: PPUSH
28027: LD_VAR 0 3
28031: PPUSH
28032: CALL_OW 283
28036: PUSH
28037: LD_INT 4
28039: EQUAL
28040: IFFALSE 28044
// exit ;
28042: GO 28352
// for i = 1 to mc_bases do
28044: LD_ADDR_VAR 0 7
28048: PUSH
28049: DOUBLE
28050: LD_INT 1
28052: DEC
28053: ST_TO_ADDR
28054: LD_EXP 57
28058: PUSH
28059: FOR_TO
28060: IFFALSE 28350
// begin if mc_crates_area [ i ] then
28062: LD_EXP 75
28066: PUSH
28067: LD_VAR 0 7
28071: ARRAY
28072: IFFALSE 28183
// for j in mc_crates_area [ i ] do
28074: LD_ADDR_VAR 0 8
28078: PUSH
28079: LD_EXP 75
28083: PUSH
28084: LD_VAR 0 7
28088: ARRAY
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28181
// if InArea ( x , y , j ) then
28093: LD_VAR 0 2
28097: PPUSH
28098: LD_VAR 0 3
28102: PPUSH
28103: LD_VAR 0 8
28107: PPUSH
28108: CALL_OW 309
28112: IFFALSE 28179
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
28114: LD_ADDR_EXP 73
28118: PUSH
28119: LD_EXP 73
28123: PPUSH
28124: LD_VAR 0 7
28128: PUSH
28129: LD_EXP 73
28133: PUSH
28134: LD_VAR 0 7
28138: ARRAY
28139: PUSH
28140: LD_INT 1
28142: PLUS
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PPUSH
28148: LD_VAR 0 4
28152: PUSH
28153: LD_VAR 0 2
28157: PUSH
28158: LD_VAR 0 3
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: LIST
28167: PPUSH
28168: CALL 37882 0 3
28172: ST_TO_ADDR
// exit ;
28173: POP
28174: POP
28175: POP
28176: POP
28177: GO 28352
// end ;
28179: GO 28090
28181: POP
28182: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28183: LD_ADDR_VAR 0 9
28187: PUSH
28188: LD_EXP 57
28192: PUSH
28193: LD_VAR 0 7
28197: ARRAY
28198: PPUSH
28199: LD_INT 2
28201: PUSH
28202: LD_INT 30
28204: PUSH
28205: LD_INT 0
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: LD_INT 30
28214: PUSH
28215: LD_INT 1
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: LIST
28226: PPUSH
28227: CALL_OW 72
28231: ST_TO_ADDR
// if not depot then
28232: LD_VAR 0 9
28236: NOT
28237: IFFALSE 28241
// continue ;
28239: GO 28059
// for j in depot do
28241: LD_ADDR_VAR 0 8
28245: PUSH
28246: LD_VAR 0 9
28250: PUSH
28251: FOR_IN
28252: IFFALSE 28346
// if GetDistUnitXY ( j , x , y ) < 30 then
28254: LD_VAR 0 8
28258: PPUSH
28259: LD_VAR 0 2
28263: PPUSH
28264: LD_VAR 0 3
28268: PPUSH
28269: CALL_OW 297
28273: PUSH
28274: LD_INT 30
28276: LESS
28277: IFFALSE 28344
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
28279: LD_ADDR_EXP 73
28283: PUSH
28284: LD_EXP 73
28288: PPUSH
28289: LD_VAR 0 7
28293: PUSH
28294: LD_EXP 73
28298: PUSH
28299: LD_VAR 0 7
28303: ARRAY
28304: PUSH
28305: LD_INT 1
28307: PLUS
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PPUSH
28313: LD_VAR 0 4
28317: PUSH
28318: LD_VAR 0 2
28322: PUSH
28323: LD_VAR 0 3
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: LIST
28332: PPUSH
28333: CALL 37882 0 3
28337: ST_TO_ADDR
// exit ;
28338: POP
28339: POP
28340: POP
28341: POP
28342: GO 28352
// end ;
28344: GO 28251
28346: POP
28347: POP
// end ;
28348: GO 28059
28350: POP
28351: POP
// end ;
28352: LD_VAR 0 6
28356: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
28357: LD_INT 0
28359: PPUSH
28360: PPUSH
28361: PPUSH
28362: PPUSH
// side := GetSide ( lab ) ;
28363: LD_ADDR_VAR 0 4
28367: PUSH
28368: LD_VAR 0 2
28372: PPUSH
28373: CALL_OW 255
28377: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
28378: LD_VAR 0 4
28382: PUSH
28383: LD_EXP 83
28387: IN
28388: NOT
28389: PUSH
28390: LD_EXP 84
28394: NOT
28395: OR
28396: PUSH
28397: LD_EXP 57
28401: NOT
28402: OR
28403: IFFALSE 28407
// exit ;
28405: GO 28640
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
28407: LD_ADDR_EXP 84
28411: PUSH
28412: LD_EXP 84
28416: PPUSH
28417: LD_VAR 0 4
28421: PPUSH
28422: LD_EXP 84
28426: PUSH
28427: LD_VAR 0 4
28431: ARRAY
28432: PUSH
28433: LD_VAR 0 1
28437: DIFF
28438: PPUSH
28439: CALL_OW 1
28443: ST_TO_ADDR
// for i = 1 to mc_bases do
28444: LD_ADDR_VAR 0 5
28448: PUSH
28449: DOUBLE
28450: LD_INT 1
28452: DEC
28453: ST_TO_ADDR
28454: LD_EXP 57
28458: PUSH
28459: FOR_TO
28460: IFFALSE 28638
// begin if lab in mc_bases [ i ] then
28462: LD_VAR 0 2
28466: PUSH
28467: LD_EXP 57
28471: PUSH
28472: LD_VAR 0 5
28476: ARRAY
28477: IN
28478: IFFALSE 28636
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
28480: LD_VAR 0 1
28484: PUSH
28485: LD_INT 11
28487: PUSH
28488: LD_INT 4
28490: PUSH
28491: LD_INT 3
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: LIST
28501: LIST
28502: IN
28503: PUSH
28504: LD_EXP 87
28508: PUSH
28509: LD_VAR 0 5
28513: ARRAY
28514: AND
28515: IFFALSE 28636
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
28517: LD_ADDR_VAR 0 6
28521: PUSH
28522: LD_EXP 87
28526: PUSH
28527: LD_VAR 0 5
28531: ARRAY
28532: PUSH
28533: LD_INT 1
28535: ARRAY
28536: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
28537: LD_ADDR_EXP 87
28541: PUSH
28542: LD_EXP 87
28546: PPUSH
28547: LD_VAR 0 5
28551: PPUSH
28552: EMPTY
28553: PPUSH
28554: CALL_OW 1
28558: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
28559: LD_VAR 0 6
28563: PPUSH
28564: LD_INT 0
28566: PPUSH
28567: CALL_OW 109
// ComExitBuilding ( tmp ) ;
28571: LD_VAR 0 6
28575: PPUSH
28576: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
28580: LD_ADDR_EXP 86
28584: PUSH
28585: LD_EXP 86
28589: PPUSH
28590: LD_VAR 0 5
28594: PPUSH
28595: LD_EXP 86
28599: PUSH
28600: LD_VAR 0 5
28604: ARRAY
28605: PPUSH
28606: LD_INT 1
28608: PPUSH
28609: LD_VAR 0 6
28613: PPUSH
28614: CALL_OW 2
28618: PPUSH
28619: CALL_OW 1
28623: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
28624: LD_VAR 0 5
28628: PPUSH
28629: LD_INT 112
28631: PPUSH
28632: CALL 6625 0 2
// end ; end ; end ;
28636: GO 28459
28638: POP
28639: POP
// end ;
28640: LD_VAR 0 3
28644: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
28645: LD_INT 0
28647: PPUSH
28648: PPUSH
28649: PPUSH
28650: PPUSH
28651: PPUSH
28652: PPUSH
28653: PPUSH
28654: PPUSH
// if not mc_bases then
28655: LD_EXP 57
28659: NOT
28660: IFFALSE 28664
// exit ;
28662: GO 29607
// for i = 1 to mc_bases do
28664: LD_ADDR_VAR 0 3
28668: PUSH
28669: DOUBLE
28670: LD_INT 1
28672: DEC
28673: ST_TO_ADDR
28674: LD_EXP 57
28678: PUSH
28679: FOR_TO
28680: IFFALSE 29605
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
28682: LD_VAR 0 1
28686: PUSH
28687: LD_EXP 57
28691: PUSH
28692: LD_VAR 0 3
28696: ARRAY
28697: IN
28698: PUSH
28699: LD_VAR 0 1
28703: PUSH
28704: LD_EXP 64
28708: PUSH
28709: LD_VAR 0 3
28713: ARRAY
28714: IN
28715: OR
28716: PUSH
28717: LD_VAR 0 1
28721: PUSH
28722: LD_EXP 76
28726: PUSH
28727: LD_VAR 0 3
28731: ARRAY
28732: IN
28733: OR
28734: PUSH
28735: LD_VAR 0 1
28739: PUSH
28740: LD_EXP 86
28744: PUSH
28745: LD_VAR 0 3
28749: ARRAY
28750: IN
28751: OR
28752: PUSH
28753: LD_VAR 0 1
28757: PUSH
28758: LD_EXP 87
28762: PUSH
28763: LD_VAR 0 3
28767: ARRAY
28768: IN
28769: OR
28770: IFFALSE 29603
// begin if un in mc_ape [ i ] then
28772: LD_VAR 0 1
28776: PUSH
28777: LD_EXP 86
28781: PUSH
28782: LD_VAR 0 3
28786: ARRAY
28787: IN
28788: IFFALSE 28827
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
28790: LD_ADDR_EXP 86
28794: PUSH
28795: LD_EXP 86
28799: PPUSH
28800: LD_VAR 0 3
28804: PPUSH
28805: LD_EXP 86
28809: PUSH
28810: LD_VAR 0 3
28814: ARRAY
28815: PUSH
28816: LD_VAR 0 1
28820: DIFF
28821: PPUSH
28822: CALL_OW 1
28826: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
28827: LD_VAR 0 1
28831: PUSH
28832: LD_EXP 87
28836: PUSH
28837: LD_VAR 0 3
28841: ARRAY
28842: IN
28843: IFFALSE 28867
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
28845: LD_ADDR_EXP 87
28849: PUSH
28850: LD_EXP 87
28854: PPUSH
28855: LD_VAR 0 3
28859: PPUSH
28860: EMPTY
28861: PPUSH
28862: CALL_OW 1
28866: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
28867: LD_VAR 0 1
28871: PPUSH
28872: CALL_OW 247
28876: PUSH
28877: LD_INT 2
28879: EQUAL
28880: PUSH
28881: LD_VAR 0 1
28885: PPUSH
28886: CALL_OW 110
28890: PUSH
28891: LD_INT 20
28893: EQUAL
28894: AND
28895: IFFALSE 28998
// begin fac := MC_GetBuilding ( i , b_factory ) ;
28897: LD_ADDR_VAR 0 8
28901: PUSH
28902: LD_VAR 0 3
28906: PPUSH
28907: LD_INT 3
28909: PPUSH
28910: CALL 25933 0 2
28914: ST_TO_ADDR
// if fac then
28915: LD_VAR 0 8
28919: IFFALSE 28998
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
28921: LD_ADDR_VAR 0 9
28925: PUSH
28926: LD_VAR 0 8
28930: PPUSH
28931: LD_VAR 0 1
28935: PPUSH
28936: CALL_OW 265
28940: PPUSH
28941: LD_VAR 0 1
28945: PPUSH
28946: CALL_OW 262
28950: PPUSH
28951: LD_VAR 0 1
28955: PPUSH
28956: CALL_OW 263
28960: PPUSH
28961: LD_VAR 0 1
28965: PPUSH
28966: CALL_OW 264
28970: PPUSH
28971: CALL 35482 0 5
28975: ST_TO_ADDR
// if components then
28976: LD_VAR 0 9
28980: IFFALSE 28996
// MC_InsertProduceList ( i , components ) ;
28982: LD_VAR 0 3
28986: PPUSH
28987: LD_VAR 0 9
28991: PPUSH
28992: CALL 25503 0 2
// break ;
28996: GO 29605
// end ; end ; if GetType ( un ) = unit_building then
28998: LD_VAR 0 1
29002: PPUSH
29003: CALL_OW 247
29007: PUSH
29008: LD_INT 3
29010: EQUAL
29011: IFFALSE 29326
// begin btype := GetBType ( un ) ;
29013: LD_ADDR_VAR 0 5
29017: PUSH
29018: LD_VAR 0 1
29022: PPUSH
29023: CALL_OW 266
29027: ST_TO_ADDR
// if btype = b_warehouse then
29028: LD_VAR 0 5
29032: PUSH
29033: LD_INT 1
29035: EQUAL
29036: IFFALSE 29054
// begin btype := b_depot ;
29038: LD_ADDR_VAR 0 5
29042: PUSH
29043: LD_INT 0
29045: ST_TO_ADDR
// pos := 1 ;
29046: LD_ADDR_VAR 0 6
29050: PUSH
29051: LD_INT 1
29053: ST_TO_ADDR
// end ; if btype = b_factory then
29054: LD_VAR 0 5
29058: PUSH
29059: LD_INT 3
29061: EQUAL
29062: IFFALSE 29080
// begin btype := b_workshop ;
29064: LD_ADDR_VAR 0 5
29068: PUSH
29069: LD_INT 2
29071: ST_TO_ADDR
// pos := 1 ;
29072: LD_ADDR_VAR 0 6
29076: PUSH
29077: LD_INT 1
29079: ST_TO_ADDR
// end ; if btype = b_barracks then
29080: LD_VAR 0 5
29084: PUSH
29085: LD_INT 5
29087: EQUAL
29088: IFFALSE 29098
// btype := b_armoury ;
29090: LD_ADDR_VAR 0 5
29094: PUSH
29095: LD_INT 4
29097: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
29098: LD_VAR 0 5
29102: PUSH
29103: LD_INT 7
29105: PUSH
29106: LD_INT 8
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: IN
29113: IFFALSE 29123
// btype := b_lab ;
29115: LD_ADDR_VAR 0 5
29119: PUSH
29120: LD_INT 6
29122: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
29123: LD_ADDR_EXP 62
29127: PUSH
29128: LD_EXP 62
29132: PPUSH
29133: LD_VAR 0 3
29137: PUSH
29138: LD_EXP 62
29142: PUSH
29143: LD_VAR 0 3
29147: ARRAY
29148: PUSH
29149: LD_INT 1
29151: PLUS
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PPUSH
29157: LD_VAR 0 5
29161: PUSH
29162: LD_VAR 0 1
29166: PPUSH
29167: CALL_OW 250
29171: PUSH
29172: LD_VAR 0 1
29176: PPUSH
29177: CALL_OW 251
29181: PUSH
29182: LD_VAR 0 1
29186: PPUSH
29187: CALL_OW 254
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: PPUSH
29198: CALL 37882 0 3
29202: ST_TO_ADDR
// if pos = 1 then
29203: LD_VAR 0 6
29207: PUSH
29208: LD_INT 1
29210: EQUAL
29211: IFFALSE 29326
// begin tmp := mc_build_list [ i ] ;
29213: LD_ADDR_VAR 0 7
29217: PUSH
29218: LD_EXP 62
29222: PUSH
29223: LD_VAR 0 3
29227: ARRAY
29228: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
29229: LD_VAR 0 7
29233: PPUSH
29234: LD_INT 2
29236: PUSH
29237: LD_INT 30
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 30
29249: PUSH
29250: LD_INT 1
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: LIST
29261: PPUSH
29262: CALL_OW 72
29266: IFFALSE 29276
// pos := 2 ;
29268: LD_ADDR_VAR 0 6
29272: PUSH
29273: LD_INT 2
29275: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
29276: LD_ADDR_VAR 0 7
29280: PUSH
29281: LD_VAR 0 7
29285: PPUSH
29286: LD_VAR 0 6
29290: PPUSH
29291: LD_VAR 0 7
29295: PPUSH
29296: CALL 38208 0 3
29300: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
29301: LD_ADDR_EXP 62
29305: PUSH
29306: LD_EXP 62
29310: PPUSH
29311: LD_VAR 0 3
29315: PPUSH
29316: LD_VAR 0 7
29320: PPUSH
29321: CALL_OW 1
29325: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
29326: LD_VAR 0 1
29330: PUSH
29331: LD_EXP 57
29335: PUSH
29336: LD_VAR 0 3
29340: ARRAY
29341: IN
29342: IFFALSE 29381
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
29344: LD_ADDR_EXP 57
29348: PUSH
29349: LD_EXP 57
29353: PPUSH
29354: LD_VAR 0 3
29358: PPUSH
29359: LD_EXP 57
29363: PUSH
29364: LD_VAR 0 3
29368: ARRAY
29369: PUSH
29370: LD_VAR 0 1
29374: DIFF
29375: PPUSH
29376: CALL_OW 1
29380: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
29381: LD_VAR 0 1
29385: PUSH
29386: LD_EXP 64
29390: PUSH
29391: LD_VAR 0 3
29395: ARRAY
29396: IN
29397: IFFALSE 29436
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
29399: LD_ADDR_EXP 64
29403: PUSH
29404: LD_EXP 64
29408: PPUSH
29409: LD_VAR 0 3
29413: PPUSH
29414: LD_EXP 64
29418: PUSH
29419: LD_VAR 0 3
29423: ARRAY
29424: PUSH
29425: LD_VAR 0 1
29429: DIFF
29430: PPUSH
29431: CALL_OW 1
29435: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
29436: LD_VAR 0 1
29440: PUSH
29441: LD_EXP 76
29445: PUSH
29446: LD_VAR 0 3
29450: ARRAY
29451: IN
29452: IFFALSE 29491
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
29454: LD_ADDR_EXP 76
29458: PUSH
29459: LD_EXP 76
29463: PPUSH
29464: LD_VAR 0 3
29468: PPUSH
29469: LD_EXP 76
29473: PUSH
29474: LD_VAR 0 3
29478: ARRAY
29479: PUSH
29480: LD_VAR 0 1
29484: DIFF
29485: PPUSH
29486: CALL_OW 1
29490: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
29491: LD_VAR 0 1
29495: PUSH
29496: LD_EXP 66
29500: PUSH
29501: LD_VAR 0 3
29505: ARRAY
29506: IN
29507: IFFALSE 29546
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
29509: LD_ADDR_EXP 66
29513: PUSH
29514: LD_EXP 66
29518: PPUSH
29519: LD_VAR 0 3
29523: PPUSH
29524: LD_EXP 66
29528: PUSH
29529: LD_VAR 0 3
29533: ARRAY
29534: PUSH
29535: LD_VAR 0 1
29539: DIFF
29540: PPUSH
29541: CALL_OW 1
29545: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
29546: LD_VAR 0 1
29550: PUSH
29551: LD_EXP 65
29555: PUSH
29556: LD_VAR 0 3
29560: ARRAY
29561: IN
29562: IFFALSE 29601
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
29564: LD_ADDR_EXP 65
29568: PUSH
29569: LD_EXP 65
29573: PPUSH
29574: LD_VAR 0 3
29578: PPUSH
29579: LD_EXP 65
29583: PUSH
29584: LD_VAR 0 3
29588: ARRAY
29589: PUSH
29590: LD_VAR 0 1
29594: DIFF
29595: PPUSH
29596: CALL_OW 1
29600: ST_TO_ADDR
// end ; break ;
29601: GO 29605
// end ;
29603: GO 28679
29605: POP
29606: POP
// end ;
29607: LD_VAR 0 2
29611: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
29612: LD_INT 0
29614: PPUSH
29615: PPUSH
29616: PPUSH
// if not mc_bases then
29617: LD_EXP 57
29621: NOT
29622: IFFALSE 29626
// exit ;
29624: GO 29841
// for i = 1 to mc_bases do
29626: LD_ADDR_VAR 0 3
29630: PUSH
29631: DOUBLE
29632: LD_INT 1
29634: DEC
29635: ST_TO_ADDR
29636: LD_EXP 57
29640: PUSH
29641: FOR_TO
29642: IFFALSE 29839
// begin if building in mc_construct_list [ i ] then
29644: LD_VAR 0 1
29648: PUSH
29649: LD_EXP 64
29653: PUSH
29654: LD_VAR 0 3
29658: ARRAY
29659: IN
29660: IFFALSE 29837
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
29662: LD_ADDR_EXP 64
29666: PUSH
29667: LD_EXP 64
29671: PPUSH
29672: LD_VAR 0 3
29676: PPUSH
29677: LD_EXP 64
29681: PUSH
29682: LD_VAR 0 3
29686: ARRAY
29687: PUSH
29688: LD_VAR 0 1
29692: DIFF
29693: PPUSH
29694: CALL_OW 1
29698: ST_TO_ADDR
// if building in mc_lab [ i ] then
29699: LD_VAR 0 1
29703: PUSH
29704: LD_EXP 90
29708: PUSH
29709: LD_VAR 0 3
29713: ARRAY
29714: IN
29715: IFFALSE 29770
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
29717: LD_ADDR_EXP 91
29721: PUSH
29722: LD_EXP 91
29726: PPUSH
29727: LD_VAR 0 3
29731: PPUSH
29732: LD_EXP 91
29736: PUSH
29737: LD_VAR 0 3
29741: ARRAY
29742: PPUSH
29743: LD_INT 1
29745: PPUSH
29746: LD_EXP 91
29750: PUSH
29751: LD_VAR 0 3
29755: ARRAY
29756: PPUSH
29757: LD_INT 0
29759: PPUSH
29760: CALL 37300 0 4
29764: PPUSH
29765: CALL_OW 1
29769: ST_TO_ADDR
// if not building in mc_bases [ i ] then
29770: LD_VAR 0 1
29774: PUSH
29775: LD_EXP 57
29779: PUSH
29780: LD_VAR 0 3
29784: ARRAY
29785: IN
29786: NOT
29787: IFFALSE 29833
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
29789: LD_ADDR_EXP 57
29793: PUSH
29794: LD_EXP 57
29798: PPUSH
29799: LD_VAR 0 3
29803: PUSH
29804: LD_EXP 57
29808: PUSH
29809: LD_VAR 0 3
29813: ARRAY
29814: PUSH
29815: LD_INT 1
29817: PLUS
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PPUSH
29823: LD_VAR 0 1
29827: PPUSH
29828: CALL 37882 0 3
29832: ST_TO_ADDR
// exit ;
29833: POP
29834: POP
29835: GO 29841
// end ; end ;
29837: GO 29641
29839: POP
29840: POP
// end ;
29841: LD_VAR 0 2
29845: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
29846: LD_INT 0
29848: PPUSH
29849: PPUSH
29850: PPUSH
29851: PPUSH
29852: PPUSH
29853: PPUSH
29854: PPUSH
// if not mc_bases then
29855: LD_EXP 57
29859: NOT
29860: IFFALSE 29864
// exit ;
29862: GO 30525
// for i = 1 to mc_bases do
29864: LD_ADDR_VAR 0 3
29868: PUSH
29869: DOUBLE
29870: LD_INT 1
29872: DEC
29873: ST_TO_ADDR
29874: LD_EXP 57
29878: PUSH
29879: FOR_TO
29880: IFFALSE 30523
// begin if building in mc_construct_list [ i ] then
29882: LD_VAR 0 1
29886: PUSH
29887: LD_EXP 64
29891: PUSH
29892: LD_VAR 0 3
29896: ARRAY
29897: IN
29898: IFFALSE 30521
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
29900: LD_ADDR_EXP 64
29904: PUSH
29905: LD_EXP 64
29909: PPUSH
29910: LD_VAR 0 3
29914: PPUSH
29915: LD_EXP 64
29919: PUSH
29920: LD_VAR 0 3
29924: ARRAY
29925: PUSH
29926: LD_VAR 0 1
29930: DIFF
29931: PPUSH
29932: CALL_OW 1
29936: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
29937: LD_ADDR_EXP 57
29941: PUSH
29942: LD_EXP 57
29946: PPUSH
29947: LD_VAR 0 3
29951: PUSH
29952: LD_EXP 57
29956: PUSH
29957: LD_VAR 0 3
29961: ARRAY
29962: PUSH
29963: LD_INT 1
29965: PLUS
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PPUSH
29971: LD_VAR 0 1
29975: PPUSH
29976: CALL 37882 0 3
29980: ST_TO_ADDR
// btype := GetBType ( building ) ;
29981: LD_ADDR_VAR 0 5
29985: PUSH
29986: LD_VAR 0 1
29990: PPUSH
29991: CALL_OW 266
29995: ST_TO_ADDR
// side := GetSide ( building ) ;
29996: LD_ADDR_VAR 0 8
30000: PUSH
30001: LD_VAR 0 1
30005: PPUSH
30006: CALL_OW 255
30010: ST_TO_ADDR
// if btype = b_lab then
30011: LD_VAR 0 5
30015: PUSH
30016: LD_INT 6
30018: EQUAL
30019: IFFALSE 30069
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
30021: LD_ADDR_EXP 90
30025: PUSH
30026: LD_EXP 90
30030: PPUSH
30031: LD_VAR 0 3
30035: PUSH
30036: LD_EXP 90
30040: PUSH
30041: LD_VAR 0 3
30045: ARRAY
30046: PUSH
30047: LD_INT 1
30049: PLUS
30050: PUSH
30051: EMPTY
30052: LIST
30053: LIST
30054: PPUSH
30055: LD_VAR 0 1
30059: PPUSH
30060: CALL 37882 0 3
30064: ST_TO_ADDR
// exit ;
30065: POP
30066: POP
30067: GO 30525
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
30069: LD_VAR 0 5
30073: PUSH
30074: LD_INT 0
30076: PUSH
30077: LD_INT 2
30079: PUSH
30080: LD_INT 4
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: LIST
30087: IN
30088: IFFALSE 30212
// begin if btype = b_armoury then
30090: LD_VAR 0 5
30094: PUSH
30095: LD_INT 4
30097: EQUAL
30098: IFFALSE 30108
// btype := b_barracks ;
30100: LD_ADDR_VAR 0 5
30104: PUSH
30105: LD_INT 5
30107: ST_TO_ADDR
// if btype = b_depot then
30108: LD_VAR 0 5
30112: PUSH
30113: LD_INT 0
30115: EQUAL
30116: IFFALSE 30126
// btype := b_warehouse ;
30118: LD_ADDR_VAR 0 5
30122: PUSH
30123: LD_INT 1
30125: ST_TO_ADDR
// if btype = b_workshop then
30126: LD_VAR 0 5
30130: PUSH
30131: LD_INT 2
30133: EQUAL
30134: IFFALSE 30144
// btype := b_factory ;
30136: LD_ADDR_VAR 0 5
30140: PUSH
30141: LD_INT 3
30143: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
30144: LD_VAR 0 5
30148: PPUSH
30149: LD_VAR 0 8
30153: PPUSH
30154: CALL_OW 323
30158: PUSH
30159: LD_INT 1
30161: EQUAL
30162: IFFALSE 30208
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
30164: LD_ADDR_EXP 89
30168: PUSH
30169: LD_EXP 89
30173: PPUSH
30174: LD_VAR 0 3
30178: PUSH
30179: LD_EXP 89
30183: PUSH
30184: LD_VAR 0 3
30188: ARRAY
30189: PUSH
30190: LD_INT 1
30192: PLUS
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PPUSH
30198: LD_VAR 0 1
30202: PPUSH
30203: CALL 37882 0 3
30207: ST_TO_ADDR
// exit ;
30208: POP
30209: POP
30210: GO 30525
// end ; if btype in [ b_bunker , b_turret ] then
30212: LD_VAR 0 5
30216: PUSH
30217: LD_INT 32
30219: PUSH
30220: LD_INT 33
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: IN
30227: IFFALSE 30517
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
30229: LD_ADDR_EXP 65
30233: PUSH
30234: LD_EXP 65
30238: PPUSH
30239: LD_VAR 0 3
30243: PUSH
30244: LD_EXP 65
30248: PUSH
30249: LD_VAR 0 3
30253: ARRAY
30254: PUSH
30255: LD_INT 1
30257: PLUS
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PPUSH
30263: LD_VAR 0 1
30267: PPUSH
30268: CALL 37882 0 3
30272: ST_TO_ADDR
// if btype = b_bunker then
30273: LD_VAR 0 5
30277: PUSH
30278: LD_INT 32
30280: EQUAL
30281: IFFALSE 30517
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
30283: LD_ADDR_EXP 66
30287: PUSH
30288: LD_EXP 66
30292: PPUSH
30293: LD_VAR 0 3
30297: PUSH
30298: LD_EXP 66
30302: PUSH
30303: LD_VAR 0 3
30307: ARRAY
30308: PUSH
30309: LD_INT 1
30311: PLUS
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PPUSH
30317: LD_VAR 0 1
30321: PPUSH
30322: CALL 37882 0 3
30326: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
30327: LD_ADDR_VAR 0 6
30331: PUSH
30332: LD_EXP 57
30336: PUSH
30337: LD_VAR 0 3
30341: ARRAY
30342: PPUSH
30343: LD_INT 25
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 3
30355: PUSH
30356: LD_INT 54
30358: PUSH
30359: EMPTY
30360: LIST
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PPUSH
30370: CALL_OW 72
30374: ST_TO_ADDR
// if tmp then
30375: LD_VAR 0 6
30379: IFFALSE 30385
// exit ;
30381: POP
30382: POP
30383: GO 30525
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
30385: LD_ADDR_VAR 0 6
30389: PUSH
30390: LD_EXP 57
30394: PUSH
30395: LD_VAR 0 3
30399: ARRAY
30400: PPUSH
30401: LD_INT 2
30403: PUSH
30404: LD_INT 30
30406: PUSH
30407: LD_INT 4
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 30
30416: PUSH
30417: LD_INT 5
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: LIST
30428: PPUSH
30429: CALL_OW 72
30433: ST_TO_ADDR
// if not tmp then
30434: LD_VAR 0 6
30438: NOT
30439: IFFALSE 30445
// exit ;
30441: POP
30442: POP
30443: GO 30525
// for j in tmp do
30445: LD_ADDR_VAR 0 4
30449: PUSH
30450: LD_VAR 0 6
30454: PUSH
30455: FOR_IN
30456: IFFALSE 30515
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
30458: LD_ADDR_VAR 0 7
30462: PUSH
30463: LD_VAR 0 4
30467: PPUSH
30468: CALL_OW 313
30472: PPUSH
30473: LD_INT 25
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: PPUSH
30483: CALL_OW 72
30487: ST_TO_ADDR
// if units then
30488: LD_VAR 0 7
30492: IFFALSE 30513
// begin ComExitBuilding ( units [ 1 ] ) ;
30494: LD_VAR 0 7
30498: PUSH
30499: LD_INT 1
30501: ARRAY
30502: PPUSH
30503: CALL_OW 122
// exit ;
30507: POP
30508: POP
30509: POP
30510: POP
30511: GO 30525
// end ; end ;
30513: GO 30455
30515: POP
30516: POP
// end ; end ; exit ;
30517: POP
30518: POP
30519: GO 30525
// end ; end ;
30521: GO 29879
30523: POP
30524: POP
// end ;
30525: LD_VAR 0 2
30529: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
30530: LD_INT 0
30532: PPUSH
30533: PPUSH
30534: PPUSH
30535: PPUSH
30536: PPUSH
30537: PPUSH
30538: PPUSH
// if not mc_bases then
30539: LD_EXP 57
30543: NOT
30544: IFFALSE 30548
// exit ;
30546: GO 30779
// btype := GetBType ( building ) ;
30548: LD_ADDR_VAR 0 6
30552: PUSH
30553: LD_VAR 0 1
30557: PPUSH
30558: CALL_OW 266
30562: ST_TO_ADDR
// x := GetX ( building ) ;
30563: LD_ADDR_VAR 0 7
30567: PUSH
30568: LD_VAR 0 1
30572: PPUSH
30573: CALL_OW 250
30577: ST_TO_ADDR
// y := GetY ( building ) ;
30578: LD_ADDR_VAR 0 8
30582: PUSH
30583: LD_VAR 0 1
30587: PPUSH
30588: CALL_OW 251
30592: ST_TO_ADDR
// d := GetDir ( building ) ;
30593: LD_ADDR_VAR 0 9
30597: PUSH
30598: LD_VAR 0 1
30602: PPUSH
30603: CALL_OW 254
30607: ST_TO_ADDR
// for i = 1 to mc_bases do
30608: LD_ADDR_VAR 0 4
30612: PUSH
30613: DOUBLE
30614: LD_INT 1
30616: DEC
30617: ST_TO_ADDR
30618: LD_EXP 57
30622: PUSH
30623: FOR_TO
30624: IFFALSE 30777
// begin if not mc_build_list [ i ] then
30626: LD_EXP 62
30630: PUSH
30631: LD_VAR 0 4
30635: ARRAY
30636: NOT
30637: IFFALSE 30641
// continue ;
30639: GO 30623
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
30641: LD_VAR 0 6
30645: PUSH
30646: LD_VAR 0 7
30650: PUSH
30651: LD_VAR 0 8
30655: PUSH
30656: LD_VAR 0 9
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: LIST
30665: LIST
30666: PPUSH
30667: LD_EXP 62
30671: PUSH
30672: LD_VAR 0 4
30676: ARRAY
30677: PUSH
30678: LD_INT 1
30680: ARRAY
30681: PPUSH
30682: CALL 44051 0 2
30686: IFFALSE 30775
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
30688: LD_ADDR_EXP 62
30692: PUSH
30693: LD_EXP 62
30697: PPUSH
30698: LD_VAR 0 4
30702: PPUSH
30703: LD_EXP 62
30707: PUSH
30708: LD_VAR 0 4
30712: ARRAY
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: CALL_OW 3
30721: PPUSH
30722: CALL_OW 1
30726: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
30727: LD_ADDR_EXP 64
30731: PUSH
30732: LD_EXP 64
30736: PPUSH
30737: LD_VAR 0 4
30741: PUSH
30742: LD_EXP 64
30746: PUSH
30747: LD_VAR 0 4
30751: ARRAY
30752: PUSH
30753: LD_INT 1
30755: PLUS
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PPUSH
30761: LD_VAR 0 1
30765: PPUSH
30766: CALL 37882 0 3
30770: ST_TO_ADDR
// exit ;
30771: POP
30772: POP
30773: GO 30779
// end ; end ;
30775: GO 30623
30777: POP
30778: POP
// end ;
30779: LD_VAR 0 3
30783: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
30784: LD_INT 0
30786: PPUSH
30787: PPUSH
30788: PPUSH
// if not mc_bases then
30789: LD_EXP 57
30793: NOT
30794: IFFALSE 30798
// exit ;
30796: GO 30988
// for i = 1 to mc_bases do
30798: LD_ADDR_VAR 0 4
30802: PUSH
30803: DOUBLE
30804: LD_INT 1
30806: DEC
30807: ST_TO_ADDR
30808: LD_EXP 57
30812: PUSH
30813: FOR_TO
30814: IFFALSE 30901
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
30816: LD_VAR 0 1
30820: PUSH
30821: LD_EXP 65
30825: PUSH
30826: LD_VAR 0 4
30830: ARRAY
30831: IN
30832: PUSH
30833: LD_VAR 0 1
30837: PUSH
30838: LD_EXP 66
30842: PUSH
30843: LD_VAR 0 4
30847: ARRAY
30848: IN
30849: NOT
30850: AND
30851: IFFALSE 30899
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
30853: LD_ADDR_EXP 66
30857: PUSH
30858: LD_EXP 66
30862: PPUSH
30863: LD_VAR 0 4
30867: PUSH
30868: LD_EXP 66
30872: PUSH
30873: LD_VAR 0 4
30877: ARRAY
30878: PUSH
30879: LD_INT 1
30881: PLUS
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PPUSH
30887: LD_VAR 0 1
30891: PPUSH
30892: CALL 37882 0 3
30896: ST_TO_ADDR
// break ;
30897: GO 30901
// end ; end ;
30899: GO 30813
30901: POP
30902: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
30903: LD_VAR 0 1
30907: PPUSH
30908: CALL_OW 257
30912: PUSH
30913: LD_EXP 83
30917: IN
30918: PUSH
30919: LD_VAR 0 1
30923: PPUSH
30924: CALL_OW 266
30928: PUSH
30929: LD_INT 5
30931: EQUAL
30932: AND
30933: PUSH
30934: LD_VAR 0 2
30938: PPUSH
30939: CALL_OW 110
30943: PUSH
30944: LD_INT 18
30946: NONEQUAL
30947: AND
30948: IFFALSE 30988
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
30950: LD_VAR 0 2
30954: PPUSH
30955: CALL_OW 257
30959: PUSH
30960: LD_INT 5
30962: PUSH
30963: LD_INT 8
30965: PUSH
30966: LD_INT 9
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: LIST
30973: IN
30974: IFFALSE 30988
// SetClass ( unit , 1 ) ;
30976: LD_VAR 0 2
30980: PPUSH
30981: LD_INT 1
30983: PPUSH
30984: CALL_OW 336
// end ;
30988: LD_VAR 0 3
30992: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
30993: LD_INT 0
30995: PPUSH
30996: PPUSH
// if not mc_bases then
30997: LD_EXP 57
31001: NOT
31002: IFFALSE 31006
// exit ;
31004: GO 31122
// if GetLives ( abandoned_vehicle ) > 250 then
31006: LD_VAR 0 2
31010: PPUSH
31011: CALL_OW 256
31015: PUSH
31016: LD_INT 250
31018: GREATER
31019: IFFALSE 31023
// exit ;
31021: GO 31122
// for i = 1 to mc_bases do
31023: LD_ADDR_VAR 0 6
31027: PUSH
31028: DOUBLE
31029: LD_INT 1
31031: DEC
31032: ST_TO_ADDR
31033: LD_EXP 57
31037: PUSH
31038: FOR_TO
31039: IFFALSE 31120
// begin if driver in mc_bases [ i ] then
31041: LD_VAR 0 1
31045: PUSH
31046: LD_EXP 57
31050: PUSH
31051: LD_VAR 0 6
31055: ARRAY
31056: IN
31057: IFFALSE 31118
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
31059: LD_VAR 0 1
31063: PPUSH
31064: LD_EXP 57
31068: PUSH
31069: LD_VAR 0 6
31073: ARRAY
31074: PPUSH
31075: LD_INT 2
31077: PUSH
31078: LD_INT 30
31080: PUSH
31081: LD_INT 0
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 30
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: LIST
31102: PPUSH
31103: CALL_OW 72
31107: PUSH
31108: LD_INT 1
31110: ARRAY
31111: PPUSH
31112: CALL_OW 112
// break ;
31116: GO 31120
// end ; end ;
31118: GO 31038
31120: POP
31121: POP
// end ; end_of_file
31122: LD_VAR 0 5
31126: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
31127: LD_INT 0
31129: PPUSH
31130: PPUSH
// if exist_mode then
31131: LD_VAR 0 2
31135: IFFALSE 31160
// unit := CreateCharacter ( prefix & ident ) else
31137: LD_ADDR_VAR 0 5
31141: PUSH
31142: LD_VAR 0 3
31146: PUSH
31147: LD_VAR 0 1
31151: STR
31152: PPUSH
31153: CALL_OW 34
31157: ST_TO_ADDR
31158: GO 31175
// unit := NewCharacter ( ident ) ;
31160: LD_ADDR_VAR 0 5
31164: PUSH
31165: LD_VAR 0 1
31169: PPUSH
31170: CALL_OW 25
31174: ST_TO_ADDR
// result := unit ;
31175: LD_ADDR_VAR 0 4
31179: PUSH
31180: LD_VAR 0 5
31184: ST_TO_ADDR
// end ;
31185: LD_VAR 0 4
31189: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
31190: LD_INT 0
31192: PPUSH
31193: PPUSH
// if not side or not nation then
31194: LD_VAR 0 1
31198: NOT
31199: PUSH
31200: LD_VAR 0 2
31204: NOT
31205: OR
31206: IFFALSE 31210
// exit ;
31208: GO 31846
// case nation of nation_american :
31210: LD_VAR 0 2
31214: PUSH
31215: LD_INT 1
31217: DOUBLE
31218: EQUAL
31219: IFTRUE 31223
31221: GO 31393
31223: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
31224: LD_ADDR_VAR 0 4
31228: PUSH
31229: LD_INT 35
31231: PUSH
31232: LD_INT 45
31234: PUSH
31235: LD_INT 46
31237: PUSH
31238: LD_INT 47
31240: PUSH
31241: LD_INT 1
31243: PUSH
31244: LD_INT 2
31246: PUSH
31247: LD_INT 6
31249: PUSH
31250: LD_INT 15
31252: PUSH
31253: LD_INT 16
31255: PUSH
31256: LD_INT 7
31258: PUSH
31259: LD_INT 12
31261: PUSH
31262: LD_INT 13
31264: PUSH
31265: LD_INT 10
31267: PUSH
31268: LD_INT 14
31270: PUSH
31271: LD_INT 20
31273: PUSH
31274: LD_INT 21
31276: PUSH
31277: LD_INT 22
31279: PUSH
31280: LD_INT 25
31282: PUSH
31283: LD_INT 32
31285: PUSH
31286: LD_INT 27
31288: PUSH
31289: LD_INT 36
31291: PUSH
31292: LD_INT 69
31294: PUSH
31295: LD_INT 39
31297: PUSH
31298: LD_INT 34
31300: PUSH
31301: LD_INT 40
31303: PUSH
31304: LD_INT 48
31306: PUSH
31307: LD_INT 49
31309: PUSH
31310: LD_INT 50
31312: PUSH
31313: LD_INT 51
31315: PUSH
31316: LD_INT 52
31318: PUSH
31319: LD_INT 53
31321: PUSH
31322: LD_INT 54
31324: PUSH
31325: LD_INT 55
31327: PUSH
31328: LD_INT 56
31330: PUSH
31331: LD_INT 57
31333: PUSH
31334: LD_INT 58
31336: PUSH
31337: LD_INT 59
31339: PUSH
31340: LD_INT 60
31342: PUSH
31343: LD_INT 61
31345: PUSH
31346: LD_INT 62
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: LIST
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: ST_TO_ADDR
31391: GO 31770
31393: LD_INT 2
31395: DOUBLE
31396: EQUAL
31397: IFTRUE 31401
31399: GO 31579
31401: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
31402: LD_ADDR_VAR 0 4
31406: PUSH
31407: LD_INT 35
31409: PUSH
31410: LD_INT 45
31412: PUSH
31413: LD_INT 46
31415: PUSH
31416: LD_INT 47
31418: PUSH
31419: LD_INT 70
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 11
31427: PUSH
31428: LD_INT 3
31430: PUSH
31431: LD_INT 4
31433: PUSH
31434: LD_INT 5
31436: PUSH
31437: LD_INT 6
31439: PUSH
31440: LD_INT 15
31442: PUSH
31443: LD_INT 18
31445: PUSH
31446: LD_INT 7
31448: PUSH
31449: LD_INT 17
31451: PUSH
31452: LD_INT 8
31454: PUSH
31455: LD_INT 20
31457: PUSH
31458: LD_INT 21
31460: PUSH
31461: LD_INT 22
31463: PUSH
31464: LD_INT 72
31466: PUSH
31467: LD_INT 26
31469: PUSH
31470: LD_INT 69
31472: PUSH
31473: LD_INT 39
31475: PUSH
31476: LD_INT 40
31478: PUSH
31479: LD_INT 41
31481: PUSH
31482: LD_INT 42
31484: PUSH
31485: LD_INT 43
31487: PUSH
31488: LD_INT 48
31490: PUSH
31491: LD_INT 49
31493: PUSH
31494: LD_INT 50
31496: PUSH
31497: LD_INT 51
31499: PUSH
31500: LD_INT 52
31502: PUSH
31503: LD_INT 53
31505: PUSH
31506: LD_INT 54
31508: PUSH
31509: LD_INT 55
31511: PUSH
31512: LD_INT 56
31514: PUSH
31515: LD_INT 60
31517: PUSH
31518: LD_INT 61
31520: PUSH
31521: LD_INT 62
31523: PUSH
31524: LD_INT 66
31526: PUSH
31527: LD_INT 67
31529: PUSH
31530: LD_INT 68
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: LIST
31574: LIST
31575: LIST
31576: ST_TO_ADDR
31577: GO 31770
31579: LD_INT 3
31581: DOUBLE
31582: EQUAL
31583: IFTRUE 31587
31585: GO 31769
31587: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
31588: LD_ADDR_VAR 0 4
31592: PUSH
31593: LD_INT 46
31595: PUSH
31596: LD_INT 47
31598: PUSH
31599: LD_INT 1
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: LD_INT 11
31607: PUSH
31608: LD_INT 9
31610: PUSH
31611: LD_INT 20
31613: PUSH
31614: LD_INT 19
31616: PUSH
31617: LD_INT 21
31619: PUSH
31620: LD_INT 24
31622: PUSH
31623: LD_INT 22
31625: PUSH
31626: LD_INT 25
31628: PUSH
31629: LD_INT 28
31631: PUSH
31632: LD_INT 29
31634: PUSH
31635: LD_INT 30
31637: PUSH
31638: LD_INT 31
31640: PUSH
31641: LD_INT 37
31643: PUSH
31644: LD_INT 38
31646: PUSH
31647: LD_INT 32
31649: PUSH
31650: LD_INT 27
31652: PUSH
31653: LD_INT 33
31655: PUSH
31656: LD_INT 69
31658: PUSH
31659: LD_INT 39
31661: PUSH
31662: LD_INT 34
31664: PUSH
31665: LD_INT 40
31667: PUSH
31668: LD_INT 71
31670: PUSH
31671: LD_INT 23
31673: PUSH
31674: LD_INT 44
31676: PUSH
31677: LD_INT 48
31679: PUSH
31680: LD_INT 49
31682: PUSH
31683: LD_INT 50
31685: PUSH
31686: LD_INT 51
31688: PUSH
31689: LD_INT 52
31691: PUSH
31692: LD_INT 53
31694: PUSH
31695: LD_INT 54
31697: PUSH
31698: LD_INT 55
31700: PUSH
31701: LD_INT 56
31703: PUSH
31704: LD_INT 57
31706: PUSH
31707: LD_INT 58
31709: PUSH
31710: LD_INT 59
31712: PUSH
31713: LD_INT 63
31715: PUSH
31716: LD_INT 64
31718: PUSH
31719: LD_INT 65
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: ST_TO_ADDR
31767: GO 31770
31769: POP
// if state > - 1 and state < 3 then
31770: LD_VAR 0 3
31774: PUSH
31775: LD_INT 1
31777: NEG
31778: GREATER
31779: PUSH
31780: LD_VAR 0 3
31784: PUSH
31785: LD_INT 3
31787: LESS
31788: AND
31789: IFFALSE 31846
// for i in result do
31791: LD_ADDR_VAR 0 5
31795: PUSH
31796: LD_VAR 0 4
31800: PUSH
31801: FOR_IN
31802: IFFALSE 31844
// if GetTech ( i , side ) <> state then
31804: LD_VAR 0 5
31808: PPUSH
31809: LD_VAR 0 1
31813: PPUSH
31814: CALL_OW 321
31818: PUSH
31819: LD_VAR 0 3
31823: NONEQUAL
31824: IFFALSE 31842
// result := result diff i ;
31826: LD_ADDR_VAR 0 4
31830: PUSH
31831: LD_VAR 0 4
31835: PUSH
31836: LD_VAR 0 5
31840: DIFF
31841: ST_TO_ADDR
31842: GO 31801
31844: POP
31845: POP
// end ;
31846: LD_VAR 0 4
31850: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
31851: LD_INT 0
31853: PPUSH
31854: PPUSH
31855: PPUSH
// result := true ;
31856: LD_ADDR_VAR 0 3
31860: PUSH
31861: LD_INT 1
31863: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
31864: LD_ADDR_VAR 0 5
31868: PUSH
31869: LD_VAR 0 2
31873: PPUSH
31874: CALL_OW 480
31878: ST_TO_ADDR
// if not tmp then
31879: LD_VAR 0 5
31883: NOT
31884: IFFALSE 31888
// exit ;
31886: GO 31937
// for i in tmp do
31888: LD_ADDR_VAR 0 4
31892: PUSH
31893: LD_VAR 0 5
31897: PUSH
31898: FOR_IN
31899: IFFALSE 31935
// if GetTech ( i , side ) <> state_researched then
31901: LD_VAR 0 4
31905: PPUSH
31906: LD_VAR 0 1
31910: PPUSH
31911: CALL_OW 321
31915: PUSH
31916: LD_INT 2
31918: NONEQUAL
31919: IFFALSE 31933
// begin result := false ;
31921: LD_ADDR_VAR 0 3
31925: PUSH
31926: LD_INT 0
31928: ST_TO_ADDR
// exit ;
31929: POP
31930: POP
31931: GO 31937
// end ;
31933: GO 31898
31935: POP
31936: POP
// end ;
31937: LD_VAR 0 3
31941: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
31942: LD_INT 0
31944: PPUSH
31945: PPUSH
31946: PPUSH
31947: PPUSH
31948: PPUSH
31949: PPUSH
31950: PPUSH
31951: PPUSH
31952: PPUSH
31953: PPUSH
31954: PPUSH
31955: PPUSH
31956: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
31957: LD_VAR 0 1
31961: NOT
31962: PUSH
31963: LD_VAR 0 1
31967: PPUSH
31968: CALL_OW 257
31972: PUSH
31973: LD_INT 9
31975: NONEQUAL
31976: OR
31977: IFFALSE 31981
// exit ;
31979: GO 32554
// side := GetSide ( unit ) ;
31981: LD_ADDR_VAR 0 9
31985: PUSH
31986: LD_VAR 0 1
31990: PPUSH
31991: CALL_OW 255
31995: ST_TO_ADDR
// tech_space := tech_spacanom ;
31996: LD_ADDR_VAR 0 12
32000: PUSH
32001: LD_INT 29
32003: ST_TO_ADDR
// tech_time := tech_taurad ;
32004: LD_ADDR_VAR 0 13
32008: PUSH
32009: LD_INT 28
32011: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
32012: LD_ADDR_VAR 0 11
32016: PUSH
32017: LD_VAR 0 1
32021: PPUSH
32022: CALL_OW 310
32026: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
32027: LD_VAR 0 11
32031: PPUSH
32032: CALL_OW 247
32036: PUSH
32037: LD_INT 2
32039: EQUAL
32040: IFFALSE 32044
// exit ;
32042: GO 32554
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
32044: LD_ADDR_VAR 0 8
32048: PUSH
32049: LD_INT 81
32051: PUSH
32052: LD_VAR 0 9
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 3
32063: PUSH
32064: LD_INT 21
32066: PUSH
32067: LD_INT 3
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PPUSH
32082: CALL_OW 69
32086: ST_TO_ADDR
// if not tmp then
32087: LD_VAR 0 8
32091: NOT
32092: IFFALSE 32096
// exit ;
32094: GO 32554
// if in_unit then
32096: LD_VAR 0 11
32100: IFFALSE 32124
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
32102: LD_ADDR_VAR 0 10
32106: PUSH
32107: LD_VAR 0 8
32111: PPUSH
32112: LD_VAR 0 11
32116: PPUSH
32117: CALL_OW 74
32121: ST_TO_ADDR
32122: GO 32144
// enemy := NearestUnitToUnit ( tmp , unit ) ;
32124: LD_ADDR_VAR 0 10
32128: PUSH
32129: LD_VAR 0 8
32133: PPUSH
32134: LD_VAR 0 1
32138: PPUSH
32139: CALL_OW 74
32143: ST_TO_ADDR
// if not enemy then
32144: LD_VAR 0 10
32148: NOT
32149: IFFALSE 32153
// exit ;
32151: GO 32554
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
32153: LD_VAR 0 11
32157: PUSH
32158: LD_VAR 0 11
32162: PPUSH
32163: LD_VAR 0 10
32167: PPUSH
32168: CALL_OW 296
32172: PUSH
32173: LD_INT 13
32175: GREATER
32176: AND
32177: PUSH
32178: LD_VAR 0 1
32182: PPUSH
32183: LD_VAR 0 10
32187: PPUSH
32188: CALL_OW 296
32192: PUSH
32193: LD_INT 12
32195: GREATER
32196: OR
32197: IFFALSE 32201
// exit ;
32199: GO 32554
// missile := [ 1 ] ;
32201: LD_ADDR_VAR 0 14
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: EMPTY
32210: LIST
32211: ST_TO_ADDR
// if Researched ( side , tech_space ) then
32212: LD_VAR 0 9
32216: PPUSH
32217: LD_VAR 0 12
32221: PPUSH
32222: CALL_OW 325
32226: IFFALSE 32255
// missile := Insert ( missile , missile + 1 , 2 ) ;
32228: LD_ADDR_VAR 0 14
32232: PUSH
32233: LD_VAR 0 14
32237: PPUSH
32238: LD_VAR 0 14
32242: PUSH
32243: LD_INT 1
32245: PLUS
32246: PPUSH
32247: LD_INT 2
32249: PPUSH
32250: CALL_OW 2
32254: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
32255: LD_VAR 0 9
32259: PPUSH
32260: LD_VAR 0 13
32264: PPUSH
32265: CALL_OW 325
32269: PUSH
32270: LD_VAR 0 10
32274: PPUSH
32275: CALL_OW 255
32279: PPUSH
32280: LD_VAR 0 13
32284: PPUSH
32285: CALL_OW 325
32289: NOT
32290: AND
32291: IFFALSE 32320
// missile := Insert ( missile , missile + 1 , 3 ) ;
32293: LD_ADDR_VAR 0 14
32297: PUSH
32298: LD_VAR 0 14
32302: PPUSH
32303: LD_VAR 0 14
32307: PUSH
32308: LD_INT 1
32310: PLUS
32311: PPUSH
32312: LD_INT 3
32314: PPUSH
32315: CALL_OW 2
32319: ST_TO_ADDR
// if missile < 2 then
32320: LD_VAR 0 14
32324: PUSH
32325: LD_INT 2
32327: LESS
32328: IFFALSE 32332
// exit ;
32330: GO 32554
// x := GetX ( enemy ) ;
32332: LD_ADDR_VAR 0 4
32336: PUSH
32337: LD_VAR 0 10
32341: PPUSH
32342: CALL_OW 250
32346: ST_TO_ADDR
// y := GetY ( enemy ) ;
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_VAR 0 10
32356: PPUSH
32357: CALL_OW 251
32361: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
32362: LD_ADDR_VAR 0 6
32366: PUSH
32367: LD_VAR 0 4
32371: PUSH
32372: LD_INT 1
32374: NEG
32375: PPUSH
32376: LD_INT 1
32378: PPUSH
32379: CALL_OW 12
32383: PLUS
32384: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
32385: LD_ADDR_VAR 0 7
32389: PUSH
32390: LD_VAR 0 5
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PPUSH
32399: LD_INT 1
32401: PPUSH
32402: CALL_OW 12
32406: PLUS
32407: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
32408: LD_VAR 0 6
32412: PPUSH
32413: LD_VAR 0 7
32417: PPUSH
32418: CALL_OW 488
32422: NOT
32423: IFFALSE 32445
// begin _x := x ;
32425: LD_ADDR_VAR 0 6
32429: PUSH
32430: LD_VAR 0 4
32434: ST_TO_ADDR
// _y := y ;
32435: LD_ADDR_VAR 0 7
32439: PUSH
32440: LD_VAR 0 5
32444: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
32445: LD_ADDR_VAR 0 3
32449: PUSH
32450: LD_INT 1
32452: PPUSH
32453: LD_VAR 0 14
32457: PPUSH
32458: CALL_OW 12
32462: ST_TO_ADDR
// case i of 1 :
32463: LD_VAR 0 3
32467: PUSH
32468: LD_INT 1
32470: DOUBLE
32471: EQUAL
32472: IFTRUE 32476
32474: GO 32493
32476: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
32477: LD_VAR 0 1
32481: PPUSH
32482: LD_VAR 0 10
32486: PPUSH
32487: CALL_OW 115
32491: GO 32554
32493: LD_INT 2
32495: DOUBLE
32496: EQUAL
32497: IFTRUE 32501
32499: GO 32523
32501: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
32502: LD_VAR 0 1
32506: PPUSH
32507: LD_VAR 0 6
32511: PPUSH
32512: LD_VAR 0 7
32516: PPUSH
32517: CALL_OW 153
32521: GO 32554
32523: LD_INT 3
32525: DOUBLE
32526: EQUAL
32527: IFTRUE 32531
32529: GO 32553
32531: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
32532: LD_VAR 0 1
32536: PPUSH
32537: LD_VAR 0 6
32541: PPUSH
32542: LD_VAR 0 7
32546: PPUSH
32547: CALL_OW 154
32551: GO 32554
32553: POP
// end ;
32554: LD_VAR 0 2
32558: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
32559: LD_INT 0
32561: PPUSH
32562: PPUSH
32563: PPUSH
32564: PPUSH
32565: PPUSH
32566: PPUSH
// if not unit or not building then
32567: LD_VAR 0 1
32571: NOT
32572: PUSH
32573: LD_VAR 0 2
32577: NOT
32578: OR
32579: IFFALSE 32583
// exit ;
32581: GO 32741
// x := GetX ( building ) ;
32583: LD_ADDR_VAR 0 5
32587: PUSH
32588: LD_VAR 0 2
32592: PPUSH
32593: CALL_OW 250
32597: ST_TO_ADDR
// y := GetY ( building ) ;
32598: LD_ADDR_VAR 0 6
32602: PUSH
32603: LD_VAR 0 2
32607: PPUSH
32608: CALL_OW 251
32612: ST_TO_ADDR
// for i = 0 to 5 do
32613: LD_ADDR_VAR 0 4
32617: PUSH
32618: DOUBLE
32619: LD_INT 0
32621: DEC
32622: ST_TO_ADDR
32623: LD_INT 5
32625: PUSH
32626: FOR_TO
32627: IFFALSE 32739
// begin _x := ShiftX ( x , i , 3 ) ;
32629: LD_ADDR_VAR 0 7
32633: PUSH
32634: LD_VAR 0 5
32638: PPUSH
32639: LD_VAR 0 4
32643: PPUSH
32644: LD_INT 3
32646: PPUSH
32647: CALL_OW 272
32651: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
32652: LD_ADDR_VAR 0 8
32656: PUSH
32657: LD_VAR 0 6
32661: PPUSH
32662: LD_VAR 0 4
32666: PPUSH
32667: LD_INT 3
32669: PPUSH
32670: CALL_OW 273
32674: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
32675: LD_VAR 0 7
32679: PPUSH
32680: LD_VAR 0 8
32684: PPUSH
32685: CALL_OW 488
32689: NOT
32690: IFFALSE 32694
// continue ;
32692: GO 32626
// if HexInfo ( _x , _y ) = 0 then
32694: LD_VAR 0 7
32698: PPUSH
32699: LD_VAR 0 8
32703: PPUSH
32704: CALL_OW 428
32708: PUSH
32709: LD_INT 0
32711: EQUAL
32712: IFFALSE 32737
// begin ComMoveXY ( unit , _x , _y ) ;
32714: LD_VAR 0 1
32718: PPUSH
32719: LD_VAR 0 7
32723: PPUSH
32724: LD_VAR 0 8
32728: PPUSH
32729: CALL_OW 111
// exit ;
32733: POP
32734: POP
32735: GO 32741
// end ; end ;
32737: GO 32626
32739: POP
32740: POP
// end ;
32741: LD_VAR 0 3
32745: RET
// export function ScanBase ( side , base_area ) ; begin
32746: LD_INT 0
32748: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
32749: LD_ADDR_VAR 0 3
32753: PUSH
32754: LD_VAR 0 2
32758: PPUSH
32759: LD_INT 81
32761: PUSH
32762: LD_VAR 0 1
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PPUSH
32771: CALL_OW 70
32775: ST_TO_ADDR
// end ;
32776: LD_VAR 0 3
32780: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
32781: LD_INT 0
32783: PPUSH
32784: PPUSH
32785: PPUSH
32786: PPUSH
32787: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
32788: LD_VAR 0 1
32792: NOT
32793: PUSH
32794: LD_EXP 57
32798: PUSH
32799: LD_VAR 0 1
32803: ARRAY
32804: NOT
32805: OR
32806: PUSH
32807: LD_VAR 0 2
32811: NOT
32812: OR
32813: PUSH
32814: LD_VAR 0 3
32818: NOT
32819: OR
32820: IFFALSE 32824
// exit ;
32822: GO 33274
// side := mc_sides [ base ] ;
32824: LD_ADDR_VAR 0 6
32828: PUSH
32829: LD_EXP 83
32833: PUSH
32834: LD_VAR 0 1
32838: ARRAY
32839: ST_TO_ADDR
// if not side then
32840: LD_VAR 0 6
32844: NOT
32845: IFFALSE 32849
// exit ;
32847: GO 33274
// for i in solds do
32849: LD_ADDR_VAR 0 7
32853: PUSH
32854: LD_VAR 0 2
32858: PUSH
32859: FOR_IN
32860: IFFALSE 32921
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
32862: LD_VAR 0 7
32866: PPUSH
32867: CALL_OW 310
32871: PPUSH
32872: CALL_OW 266
32876: PUSH
32877: LD_INT 32
32879: PUSH
32880: LD_INT 31
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: IN
32887: IFFALSE 32907
// solds := solds diff i else
32889: LD_ADDR_VAR 0 2
32893: PUSH
32894: LD_VAR 0 2
32898: PUSH
32899: LD_VAR 0 7
32903: DIFF
32904: ST_TO_ADDR
32905: GO 32919
// SetTag ( i , 18 ) ;
32907: LD_VAR 0 7
32911: PPUSH
32912: LD_INT 18
32914: PPUSH
32915: CALL_OW 109
32919: GO 32859
32921: POP
32922: POP
// if not solds then
32923: LD_VAR 0 2
32927: NOT
32928: IFFALSE 32932
// exit ;
32930: GO 33274
// repeat wait ( 0 0$1 ) ;
32932: LD_INT 35
32934: PPUSH
32935: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
32939: LD_ADDR_VAR 0 5
32943: PUSH
32944: LD_VAR 0 6
32948: PPUSH
32949: LD_VAR 0 3
32953: PPUSH
32954: CALL 32746 0 2
32958: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
32959: LD_VAR 0 5
32963: NOT
32964: PUSH
32965: LD_VAR 0 5
32969: PUSH
32970: LD_INT 3
32972: GREATER
32973: OR
32974: PUSH
32975: LD_EXP 79
32979: PUSH
32980: LD_VAR 0 1
32984: ARRAY
32985: OR
32986: IFFALSE 33027
// begin for i in solds do
32988: LD_ADDR_VAR 0 7
32992: PUSH
32993: LD_VAR 0 2
32997: PUSH
32998: FOR_IN
32999: IFFALSE 33023
// if HasTask ( i ) then
33001: LD_VAR 0 7
33005: PPUSH
33006: CALL_OW 314
33010: IFFALSE 33021
// ComStop ( i ) ;
33012: LD_VAR 0 7
33016: PPUSH
33017: CALL_OW 141
33021: GO 32998
33023: POP
33024: POP
// break ;
33025: GO 33262
// end ; for i in solds do
33027: LD_ADDR_VAR 0 7
33031: PUSH
33032: LD_VAR 0 2
33036: PUSH
33037: FOR_IN
33038: IFFALSE 33254
// begin if IsInUnit ( i ) then
33040: LD_VAR 0 7
33044: PPUSH
33045: CALL_OW 310
33049: IFFALSE 33060
// ComExitBuilding ( i ) ;
33051: LD_VAR 0 7
33055: PPUSH
33056: CALL_OW 122
// if GetLives ( i ) > 333 then
33060: LD_VAR 0 7
33064: PPUSH
33065: CALL_OW 256
33069: PUSH
33070: LD_INT 333
33072: GREATER
33073: IFFALSE 33101
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
33075: LD_VAR 0 7
33079: PPUSH
33080: LD_VAR 0 5
33084: PPUSH
33085: LD_VAR 0 7
33089: PPUSH
33090: CALL_OW 74
33094: PPUSH
33095: CALL_OW 115
33099: GO 33252
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
33101: LD_ADDR_VAR 0 8
33105: PUSH
33106: LD_EXP 57
33110: PUSH
33111: LD_VAR 0 1
33115: ARRAY
33116: PPUSH
33117: LD_INT 2
33119: PUSH
33120: LD_INT 30
33122: PUSH
33123: LD_INT 0
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 30
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 30
33142: PUSH
33143: LD_INT 6
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: PPUSH
33156: CALL_OW 72
33160: PPUSH
33161: LD_VAR 0 7
33165: PPUSH
33166: CALL_OW 74
33170: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
33171: LD_VAR 0 7
33175: PPUSH
33176: LD_VAR 0 8
33180: PPUSH
33181: CALL_OW 250
33185: PPUSH
33186: LD_INT 3
33188: PPUSH
33189: LD_INT 5
33191: PPUSH
33192: CALL_OW 272
33196: PPUSH
33197: LD_VAR 0 8
33201: PPUSH
33202: CALL_OW 251
33206: PPUSH
33207: LD_INT 3
33209: PPUSH
33210: LD_INT 5
33212: PPUSH
33213: CALL_OW 273
33217: PPUSH
33218: CALL_OW 111
// SetTag ( i , 0 ) ;
33222: LD_VAR 0 7
33226: PPUSH
33227: LD_INT 0
33229: PPUSH
33230: CALL_OW 109
// solds := solds diff i ;
33234: LD_ADDR_VAR 0 2
33238: PUSH
33239: LD_VAR 0 2
33243: PUSH
33244: LD_VAR 0 7
33248: DIFF
33249: ST_TO_ADDR
// continue ;
33250: GO 33037
// end ; end ;
33252: GO 33037
33254: POP
33255: POP
// until solds ;
33256: LD_VAR 0 2
33260: IFFALSE 32932
// MC_Reset ( base , 18 ) ;
33262: LD_VAR 0 1
33266: PPUSH
33267: LD_INT 18
33269: PPUSH
33270: CALL 6625 0 2
// end ;
33274: LD_VAR 0 4
33278: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
33279: LD_INT 0
33281: PPUSH
33282: PPUSH
33283: PPUSH
33284: PPUSH
33285: PPUSH
33286: PPUSH
33287: PPUSH
33288: PPUSH
33289: PPUSH
33290: PPUSH
33291: PPUSH
33292: PPUSH
33293: PPUSH
33294: PPUSH
33295: PPUSH
33296: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
33297: LD_ADDR_VAR 0 12
33301: PUSH
33302: LD_EXP 57
33306: PUSH
33307: LD_VAR 0 1
33311: ARRAY
33312: PPUSH
33313: LD_INT 25
33315: PUSH
33316: LD_INT 3
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PPUSH
33323: CALL_OW 72
33327: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33328: LD_ADDR_VAR 0 8
33332: PUSH
33333: LD_EXP 57
33337: PUSH
33338: LD_VAR 0 1
33342: ARRAY
33343: PPUSH
33344: LD_INT 2
33346: PUSH
33347: LD_INT 25
33349: PUSH
33350: LD_INT 1
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 25
33359: PUSH
33360: LD_INT 5
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 25
33369: PUSH
33370: LD_INT 8
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 25
33379: PUSH
33380: LD_INT 9
33382: PUSH
33383: EMPTY
33384: LIST
33385: LIST
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: PPUSH
33394: CALL_OW 72
33398: ST_TO_ADDR
// if not defenders and not solds then
33399: LD_VAR 0 2
33403: NOT
33404: PUSH
33405: LD_VAR 0 8
33409: NOT
33410: AND
33411: IFFALSE 33415
// exit ;
33413: GO 34781
// depot_under_attack := false ;
33415: LD_ADDR_VAR 0 16
33419: PUSH
33420: LD_INT 0
33422: ST_TO_ADDR
// sold_defenders := [ ] ;
33423: LD_ADDR_VAR 0 17
33427: PUSH
33428: EMPTY
33429: ST_TO_ADDR
// if mechs then
33430: LD_VAR 0 12
33434: IFFALSE 33563
// for i in defenders do
33436: LD_ADDR_VAR 0 5
33440: PUSH
33441: LD_VAR 0 2
33445: PUSH
33446: FOR_IN
33447: IFFALSE 33561
// begin SetTag ( i , 20 ) ;
33449: LD_VAR 0 5
33453: PPUSH
33454: LD_INT 20
33456: PPUSH
33457: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
33461: LD_VAR 0 5
33465: PPUSH
33466: CALL_OW 263
33470: PUSH
33471: LD_INT 1
33473: EQUAL
33474: PUSH
33475: LD_VAR 0 5
33479: PPUSH
33480: CALL_OW 311
33484: NOT
33485: AND
33486: PUSH
33487: LD_VAR 0 12
33491: AND
33492: IFFALSE 33559
// begin un := mechs [ 1 ] ;
33494: LD_ADDR_VAR 0 10
33498: PUSH
33499: LD_VAR 0 12
33503: PUSH
33504: LD_INT 1
33506: ARRAY
33507: ST_TO_ADDR
// ComExitBuilding ( un ) ;
33508: LD_VAR 0 10
33512: PPUSH
33513: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
33517: LD_VAR 0 10
33521: PPUSH
33522: LD_VAR 0 5
33526: PPUSH
33527: CALL_OW 180
// SetTag ( un , 19 ) ;
33531: LD_VAR 0 10
33535: PPUSH
33536: LD_INT 19
33538: PPUSH
33539: CALL_OW 109
// mechs := mechs diff un ;
33543: LD_ADDR_VAR 0 12
33547: PUSH
33548: LD_VAR 0 12
33552: PUSH
33553: LD_VAR 0 10
33557: DIFF
33558: ST_TO_ADDR
// end ; end ;
33559: GO 33446
33561: POP
33562: POP
// if solds then
33563: LD_VAR 0 8
33567: IFFALSE 33626
// for i in solds do
33569: LD_ADDR_VAR 0 5
33573: PUSH
33574: LD_VAR 0 8
33578: PUSH
33579: FOR_IN
33580: IFFALSE 33624
// if not GetTag ( i ) then
33582: LD_VAR 0 5
33586: PPUSH
33587: CALL_OW 110
33591: NOT
33592: IFFALSE 33622
// begin defenders := defenders union i ;
33594: LD_ADDR_VAR 0 2
33598: PUSH
33599: LD_VAR 0 2
33603: PUSH
33604: LD_VAR 0 5
33608: UNION
33609: ST_TO_ADDR
// SetTag ( i , 18 ) ;
33610: LD_VAR 0 5
33614: PPUSH
33615: LD_INT 18
33617: PPUSH
33618: CALL_OW 109
// end ;
33622: GO 33579
33624: POP
33625: POP
// repeat wait ( 0 0$1 ) ;
33626: LD_INT 35
33628: PPUSH
33629: CALL_OW 67
// enemy := mc_scan [ base ] ;
33633: LD_ADDR_VAR 0 3
33637: PUSH
33638: LD_EXP 80
33642: PUSH
33643: LD_VAR 0 1
33647: ARRAY
33648: ST_TO_ADDR
// for i in defenders do
33649: LD_ADDR_VAR 0 5
33653: PUSH
33654: LD_VAR 0 2
33658: PUSH
33659: FOR_IN
33660: IFFALSE 34345
// begin e := NearestUnitToUnit ( enemy , i ) ;
33662: LD_ADDR_VAR 0 13
33666: PUSH
33667: LD_VAR 0 3
33671: PPUSH
33672: LD_VAR 0 5
33676: PPUSH
33677: CALL_OW 74
33681: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
33682: LD_ADDR_VAR 0 16
33686: PUSH
33687: LD_EXP 57
33691: PUSH
33692: LD_VAR 0 1
33696: ARRAY
33697: PPUSH
33698: LD_INT 2
33700: PUSH
33701: LD_INT 30
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 30
33713: PUSH
33714: LD_INT 1
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: LIST
33725: PPUSH
33726: CALL_OW 72
33730: NOT
33731: PUSH
33732: LD_EXP 57
33736: PUSH
33737: LD_VAR 0 1
33741: ARRAY
33742: PPUSH
33743: LD_INT 2
33745: PUSH
33746: LD_INT 30
33748: PUSH
33749: LD_INT 0
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 30
33758: PUSH
33759: LD_INT 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: LIST
33770: PPUSH
33771: CALL_OW 72
33775: PPUSH
33776: CALL_OW 256
33780: PUSH
33781: LD_INT 600
33783: LESS
33784: OR
33785: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
33786: LD_VAR 0 5
33790: PPUSH
33791: CALL_OW 247
33795: PUSH
33796: LD_INT 2
33798: DOUBLE
33799: EQUAL
33800: IFTRUE 33804
33802: GO 34051
33804: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
33805: LD_VAR 0 5
33809: PPUSH
33810: CALL_OW 256
33814: PUSH
33815: LD_INT 650
33817: GREATER
33818: PUSH
33819: LD_VAR 0 5
33823: PPUSH
33824: LD_VAR 0 13
33828: PPUSH
33829: CALL_OW 296
33833: PUSH
33834: LD_INT 40
33836: LESS
33837: AND
33838: IFFALSE 33856
// ComAttackUnit ( i , e ) else
33840: LD_VAR 0 5
33844: PPUSH
33845: LD_VAR 0 13
33849: PPUSH
33850: CALL_OW 115
33854: GO 33934
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
33856: LD_VAR 0 5
33860: PPUSH
33861: LD_VAR 0 13
33865: PPUSH
33866: CALL_OW 296
33870: PUSH
33871: LD_INT 30
33873: GREATEREQUAL
33874: PUSH
33875: LD_VAR 0 5
33879: PPUSH
33880: CALL_OW 256
33884: PUSH
33885: LD_INT 650
33887: LESSEQUAL
33888: OR
33889: PUSH
33890: LD_VAR 0 5
33894: PPUSH
33895: LD_EXP 81
33899: PUSH
33900: LD_VAR 0 1
33904: ARRAY
33905: PPUSH
33906: CALL_OW 308
33910: NOT
33911: AND
33912: IFFALSE 33934
// ComMoveToArea ( i , mc_parking [ base ] ) ;
33914: LD_VAR 0 5
33918: PPUSH
33919: LD_EXP 81
33923: PUSH
33924: LD_VAR 0 1
33928: ARRAY
33929: PPUSH
33930: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
33934: LD_VAR 0 5
33938: PPUSH
33939: CALL_OW 256
33943: PUSH
33944: LD_INT 998
33946: LESS
33947: PUSH
33948: LD_VAR 0 5
33952: PPUSH
33953: CALL_OW 263
33957: PUSH
33958: LD_INT 1
33960: EQUAL
33961: AND
33962: PUSH
33963: LD_VAR 0 5
33967: PPUSH
33968: CALL_OW 311
33972: AND
33973: PUSH
33974: LD_VAR 0 5
33978: PPUSH
33979: LD_EXP 81
33983: PUSH
33984: LD_VAR 0 1
33988: ARRAY
33989: PPUSH
33990: CALL_OW 308
33994: AND
33995: IFFALSE 34049
// begin mech := IsDrivenBy ( i ) ;
33997: LD_ADDR_VAR 0 9
34001: PUSH
34002: LD_VAR 0 5
34006: PPUSH
34007: CALL_OW 311
34011: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
34012: LD_VAR 0 9
34016: PPUSH
34017: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
34021: LD_VAR 0 9
34025: PPUSH
34026: LD_VAR 0 5
34030: PPUSH
34031: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
34035: LD_VAR 0 9
34039: PPUSH
34040: LD_VAR 0 5
34044: PPUSH
34045: CALL_OW 180
// end ; end ; unit_human :
34049: GO 34316
34051: LD_INT 1
34053: DOUBLE
34054: EQUAL
34055: IFTRUE 34059
34057: GO 34315
34059: POP
// begin b := IsInUnit ( i ) ;
34060: LD_ADDR_VAR 0 18
34064: PUSH
34065: LD_VAR 0 5
34069: PPUSH
34070: CALL_OW 310
34074: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
34075: LD_ADDR_VAR 0 19
34079: PUSH
34080: LD_VAR 0 18
34084: NOT
34085: PUSH
34086: LD_VAR 0 18
34090: PPUSH
34091: CALL_OW 266
34095: PUSH
34096: LD_INT 32
34098: PUSH
34099: LD_INT 31
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: IN
34106: OR
34107: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
34108: LD_VAR 0 16
34112: PUSH
34113: LD_VAR 0 2
34117: PPUSH
34118: LD_INT 21
34120: PUSH
34121: LD_INT 2
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PPUSH
34128: CALL_OW 72
34132: PUSH
34133: LD_INT 1
34135: LESSEQUAL
34136: OR
34137: PUSH
34138: LD_VAR 0 19
34142: AND
34143: PUSH
34144: LD_VAR 0 5
34148: PUSH
34149: LD_VAR 0 17
34153: IN
34154: NOT
34155: AND
34156: IFFALSE 34249
// begin if b then
34158: LD_VAR 0 18
34162: IFFALSE 34211
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
34164: LD_VAR 0 18
34168: PPUSH
34169: LD_VAR 0 3
34173: PPUSH
34174: LD_VAR 0 18
34178: PPUSH
34179: CALL_OW 74
34183: PPUSH
34184: CALL_OW 296
34188: PUSH
34189: LD_INT 10
34191: LESS
34192: PUSH
34193: LD_VAR 0 18
34197: PPUSH
34198: CALL_OW 461
34202: PUSH
34203: LD_INT 7
34205: NONEQUAL
34206: AND
34207: IFFALSE 34211
// continue ;
34209: GO 33659
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
34211: LD_ADDR_VAR 0 17
34215: PUSH
34216: LD_VAR 0 17
34220: PPUSH
34221: LD_VAR 0 17
34225: PUSH
34226: LD_INT 1
34228: PLUS
34229: PPUSH
34230: LD_VAR 0 5
34234: PPUSH
34235: CALL_OW 1
34239: ST_TO_ADDR
// ComExitBuilding ( i ) ;
34240: LD_VAR 0 5
34244: PPUSH
34245: CALL_OW 122
// end ; if sold_defenders then
34249: LD_VAR 0 17
34253: IFFALSE 34313
// if i in sold_defenders then
34255: LD_VAR 0 5
34259: PUSH
34260: LD_VAR 0 17
34264: IN
34265: IFFALSE 34313
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
34267: LD_VAR 0 5
34271: PPUSH
34272: CALL_OW 314
34276: NOT
34277: PUSH
34278: LD_VAR 0 5
34282: PPUSH
34283: LD_VAR 0 13
34287: PPUSH
34288: CALL_OW 296
34292: PUSH
34293: LD_INT 30
34295: LESS
34296: AND
34297: IFFALSE 34313
// ComAttackUnit ( i , e ) ;
34299: LD_VAR 0 5
34303: PPUSH
34304: LD_VAR 0 13
34308: PPUSH
34309: CALL_OW 115
// end ; end ; end ;
34313: GO 34316
34315: POP
// if IsDead ( i ) then
34316: LD_VAR 0 5
34320: PPUSH
34321: CALL_OW 301
34325: IFFALSE 34343
// defenders := defenders diff i ;
34327: LD_ADDR_VAR 0 2
34331: PUSH
34332: LD_VAR 0 2
34336: PUSH
34337: LD_VAR 0 5
34341: DIFF
34342: ST_TO_ADDR
// end ;
34343: GO 33659
34345: POP
34346: POP
// until not enemy or not defenders ;
34347: LD_VAR 0 3
34351: NOT
34352: PUSH
34353: LD_VAR 0 2
34357: NOT
34358: OR
34359: IFFALSE 33626
// MC_Reset ( base , 18 ) ;
34361: LD_VAR 0 1
34365: PPUSH
34366: LD_INT 18
34368: PPUSH
34369: CALL 6625 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34373: LD_ADDR_VAR 0 2
34377: PUSH
34378: LD_VAR 0 2
34382: PUSH
34383: LD_VAR 0 2
34387: PPUSH
34388: LD_INT 2
34390: PUSH
34391: LD_INT 25
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 25
34403: PUSH
34404: LD_INT 5
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 25
34413: PUSH
34414: LD_INT 8
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 25
34423: PUSH
34424: LD_INT 9
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: PPUSH
34438: CALL_OW 72
34442: DIFF
34443: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
34444: LD_VAR 0 3
34448: NOT
34449: PUSH
34450: LD_VAR 0 2
34454: PPUSH
34455: LD_INT 21
34457: PUSH
34458: LD_INT 2
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PPUSH
34465: CALL_OW 72
34469: AND
34470: IFFALSE 34732
// begin tmp := FilterByTag ( defenders , 19 ) ;
34472: LD_ADDR_VAR 0 11
34476: PUSH
34477: LD_VAR 0 2
34481: PPUSH
34482: LD_INT 19
34484: PPUSH
34485: CALL 71079 0 2
34489: ST_TO_ADDR
// if tmp then
34490: LD_VAR 0 11
34494: IFFALSE 34564
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
34496: LD_ADDR_VAR 0 11
34500: PUSH
34501: LD_VAR 0 11
34505: PPUSH
34506: LD_INT 25
34508: PUSH
34509: LD_INT 3
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PPUSH
34516: CALL_OW 72
34520: ST_TO_ADDR
// if tmp then
34521: LD_VAR 0 11
34525: IFFALSE 34564
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
34527: LD_ADDR_EXP 69
34531: PUSH
34532: LD_EXP 69
34536: PPUSH
34537: LD_VAR 0 1
34541: PPUSH
34542: LD_EXP 69
34546: PUSH
34547: LD_VAR 0 1
34551: ARRAY
34552: PUSH
34553: LD_VAR 0 11
34557: UNION
34558: PPUSH
34559: CALL_OW 1
34563: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
34564: LD_VAR 0 1
34568: PPUSH
34569: LD_INT 19
34571: PPUSH
34572: CALL 6625 0 2
// repeat wait ( 0 0$1 ) ;
34576: LD_INT 35
34578: PPUSH
34579: CALL_OW 67
// for i in defenders do
34583: LD_ADDR_VAR 0 5
34587: PUSH
34588: LD_VAR 0 2
34592: PUSH
34593: FOR_IN
34594: IFFALSE 34683
// begin if not IsInArea ( i , mc_parking [ base ] ) then
34596: LD_VAR 0 5
34600: PPUSH
34601: LD_EXP 81
34605: PUSH
34606: LD_VAR 0 1
34610: ARRAY
34611: PPUSH
34612: CALL_OW 308
34616: NOT
34617: IFFALSE 34641
// ComMoveToArea ( i , mc_parking [ base ] ) else
34619: LD_VAR 0 5
34623: PPUSH
34624: LD_EXP 81
34628: PUSH
34629: LD_VAR 0 1
34633: ARRAY
34634: PPUSH
34635: CALL_OW 113
34639: GO 34681
// if GetControl ( i ) = control_manual then
34641: LD_VAR 0 5
34645: PPUSH
34646: CALL_OW 263
34650: PUSH
34651: LD_INT 1
34653: EQUAL
34654: IFFALSE 34681
// if IsDrivenBy ( i ) then
34656: LD_VAR 0 5
34660: PPUSH
34661: CALL_OW 311
34665: IFFALSE 34681
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
34667: LD_VAR 0 5
34671: PPUSH
34672: CALL_OW 311
34676: PPUSH
34677: CALL_OW 121
// end ;
34681: GO 34593
34683: POP
34684: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
34685: LD_VAR 0 2
34689: PPUSH
34690: LD_INT 95
34692: PUSH
34693: LD_EXP 81
34697: PUSH
34698: LD_VAR 0 1
34702: ARRAY
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PPUSH
34708: CALL_OW 72
34712: PUSH
34713: LD_VAR 0 2
34717: EQUAL
34718: PUSH
34719: LD_EXP 80
34723: PUSH
34724: LD_VAR 0 1
34728: ARRAY
34729: OR
34730: IFFALSE 34576
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
34732: LD_ADDR_EXP 79
34736: PUSH
34737: LD_EXP 79
34741: PPUSH
34742: LD_VAR 0 1
34746: PPUSH
34747: LD_EXP 79
34751: PUSH
34752: LD_VAR 0 1
34756: ARRAY
34757: PUSH
34758: LD_VAR 0 2
34762: UNION
34763: PPUSH
34764: CALL_OW 1
34768: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
34769: LD_VAR 0 1
34773: PPUSH
34774: LD_INT 20
34776: PPUSH
34777: CALL 6625 0 2
// end ;
34781: LD_VAR 0 4
34785: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
34786: LD_INT 0
34788: PPUSH
34789: PPUSH
34790: PPUSH
34791: PPUSH
// result := false ;
34792: LD_ADDR_VAR 0 2
34796: PUSH
34797: LD_INT 0
34799: ST_TO_ADDR
// side := GetSide ( unit ) ;
34800: LD_ADDR_VAR 0 3
34804: PUSH
34805: LD_VAR 0 1
34809: PPUSH
34810: CALL_OW 255
34814: ST_TO_ADDR
// nat := GetNation ( unit ) ;
34815: LD_ADDR_VAR 0 4
34819: PUSH
34820: LD_VAR 0 1
34824: PPUSH
34825: CALL_OW 248
34829: ST_TO_ADDR
// case nat of 1 :
34830: LD_VAR 0 4
34834: PUSH
34835: LD_INT 1
34837: DOUBLE
34838: EQUAL
34839: IFTRUE 34843
34841: GO 34854
34843: POP
// tech := tech_lassight ; 2 :
34844: LD_ADDR_VAR 0 5
34848: PUSH
34849: LD_INT 12
34851: ST_TO_ADDR
34852: GO 34893
34854: LD_INT 2
34856: DOUBLE
34857: EQUAL
34858: IFTRUE 34862
34860: GO 34873
34862: POP
// tech := tech_mortar ; 3 :
34863: LD_ADDR_VAR 0 5
34867: PUSH
34868: LD_INT 41
34870: ST_TO_ADDR
34871: GO 34893
34873: LD_INT 3
34875: DOUBLE
34876: EQUAL
34877: IFTRUE 34881
34879: GO 34892
34881: POP
// tech := tech_bazooka ; end ;
34882: LD_ADDR_VAR 0 5
34886: PUSH
34887: LD_INT 44
34889: ST_TO_ADDR
34890: GO 34893
34892: POP
// if Researched ( side , tech ) then
34893: LD_VAR 0 3
34897: PPUSH
34898: LD_VAR 0 5
34902: PPUSH
34903: CALL_OW 325
34907: IFFALSE 34934
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
34909: LD_ADDR_VAR 0 2
34913: PUSH
34914: LD_INT 5
34916: PUSH
34917: LD_INT 8
34919: PUSH
34920: LD_INT 9
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_VAR 0 4
34932: ARRAY
34933: ST_TO_ADDR
// end ;
34934: LD_VAR 0 2
34938: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
34939: LD_INT 0
34941: PPUSH
34942: PPUSH
34943: PPUSH
// if not mines then
34944: LD_VAR 0 2
34948: NOT
34949: IFFALSE 34953
// exit ;
34951: GO 35097
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
34953: LD_ADDR_VAR 0 5
34957: PUSH
34958: LD_INT 81
34960: PUSH
34961: LD_VAR 0 1
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 3
34972: PUSH
34973: LD_INT 21
34975: PUSH
34976: LD_INT 3
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PPUSH
34991: CALL_OW 69
34995: ST_TO_ADDR
// for i in mines do
34996: LD_ADDR_VAR 0 4
35000: PUSH
35001: LD_VAR 0 2
35005: PUSH
35006: FOR_IN
35007: IFFALSE 35095
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
35009: LD_VAR 0 4
35013: PUSH
35014: LD_INT 1
35016: ARRAY
35017: PPUSH
35018: LD_VAR 0 4
35022: PUSH
35023: LD_INT 2
35025: ARRAY
35026: PPUSH
35027: CALL_OW 458
35031: NOT
35032: IFFALSE 35036
// continue ;
35034: GO 35006
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
35036: LD_VAR 0 4
35040: PUSH
35041: LD_INT 1
35043: ARRAY
35044: PPUSH
35045: LD_VAR 0 4
35049: PUSH
35050: LD_INT 2
35052: ARRAY
35053: PPUSH
35054: CALL_OW 428
35058: PUSH
35059: LD_VAR 0 5
35063: IN
35064: IFFALSE 35093
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
35066: LD_VAR 0 4
35070: PUSH
35071: LD_INT 1
35073: ARRAY
35074: PPUSH
35075: LD_VAR 0 4
35079: PUSH
35080: LD_INT 2
35082: ARRAY
35083: PPUSH
35084: LD_VAR 0 1
35088: PPUSH
35089: CALL_OW 456
// end ;
35093: GO 35006
35095: POP
35096: POP
// end ;
35097: LD_VAR 0 3
35101: RET
// export function Count ( array ) ; var i ; begin
35102: LD_INT 0
35104: PPUSH
35105: PPUSH
// result := 0 ;
35106: LD_ADDR_VAR 0 2
35110: PUSH
35111: LD_INT 0
35113: ST_TO_ADDR
// for i in array do
35114: LD_ADDR_VAR 0 3
35118: PUSH
35119: LD_VAR 0 1
35123: PUSH
35124: FOR_IN
35125: IFFALSE 35149
// if i then
35127: LD_VAR 0 3
35131: IFFALSE 35147
// result := result + 1 ;
35133: LD_ADDR_VAR 0 2
35137: PUSH
35138: LD_VAR 0 2
35142: PUSH
35143: LD_INT 1
35145: PLUS
35146: ST_TO_ADDR
35147: GO 35124
35149: POP
35150: POP
// end ;
35151: LD_VAR 0 2
35155: RET
// export function IsEmpty ( building ) ; begin
35156: LD_INT 0
35158: PPUSH
// if not building then
35159: LD_VAR 0 1
35163: NOT
35164: IFFALSE 35168
// exit ;
35166: GO 35211
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
35168: LD_ADDR_VAR 0 2
35172: PUSH
35173: LD_VAR 0 1
35177: PUSH
35178: LD_INT 22
35180: PUSH
35181: LD_VAR 0 1
35185: PPUSH
35186: CALL_OW 255
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 58
35197: PUSH
35198: EMPTY
35199: LIST
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PPUSH
35205: CALL_OW 69
35209: IN
35210: ST_TO_ADDR
// end ;
35211: LD_VAR 0 2
35215: RET
// export function IsNotFull ( building ) ; begin
35216: LD_INT 0
35218: PPUSH
// if not building then
35219: LD_VAR 0 1
35223: NOT
35224: IFFALSE 35228
// exit ;
35226: GO 35247
// result := UnitsInside ( building ) < 6 ;
35228: LD_ADDR_VAR 0 2
35232: PUSH
35233: LD_VAR 0 1
35237: PPUSH
35238: CALL_OW 313
35242: PUSH
35243: LD_INT 6
35245: LESS
35246: ST_TO_ADDR
// end ;
35247: LD_VAR 0 2
35251: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
35252: LD_INT 0
35254: PPUSH
35255: PPUSH
35256: PPUSH
35257: PPUSH
// tmp := [ ] ;
35258: LD_ADDR_VAR 0 3
35262: PUSH
35263: EMPTY
35264: ST_TO_ADDR
// list := [ ] ;
35265: LD_ADDR_VAR 0 5
35269: PUSH
35270: EMPTY
35271: ST_TO_ADDR
// for i = 16 to 25 do
35272: LD_ADDR_VAR 0 4
35276: PUSH
35277: DOUBLE
35278: LD_INT 16
35280: DEC
35281: ST_TO_ADDR
35282: LD_INT 25
35284: PUSH
35285: FOR_TO
35286: IFFALSE 35359
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
35288: LD_ADDR_VAR 0 3
35292: PUSH
35293: LD_VAR 0 3
35297: PUSH
35298: LD_INT 22
35300: PUSH
35301: LD_VAR 0 1
35305: PPUSH
35306: CALL_OW 255
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 91
35317: PUSH
35318: LD_VAR 0 1
35322: PUSH
35323: LD_INT 6
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 30
35333: PUSH
35334: LD_VAR 0 4
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: LIST
35347: PUSH
35348: EMPTY
35349: LIST
35350: PPUSH
35351: CALL_OW 69
35355: ADD
35356: ST_TO_ADDR
35357: GO 35285
35359: POP
35360: POP
// for i = 1 to tmp do
35361: LD_ADDR_VAR 0 4
35365: PUSH
35366: DOUBLE
35367: LD_INT 1
35369: DEC
35370: ST_TO_ADDR
35371: LD_VAR 0 3
35375: PUSH
35376: FOR_TO
35377: IFFALSE 35465
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
35379: LD_ADDR_VAR 0 5
35383: PUSH
35384: LD_VAR 0 5
35388: PUSH
35389: LD_VAR 0 3
35393: PUSH
35394: LD_VAR 0 4
35398: ARRAY
35399: PPUSH
35400: CALL_OW 266
35404: PUSH
35405: LD_VAR 0 3
35409: PUSH
35410: LD_VAR 0 4
35414: ARRAY
35415: PPUSH
35416: CALL_OW 250
35420: PUSH
35421: LD_VAR 0 3
35425: PUSH
35426: LD_VAR 0 4
35430: ARRAY
35431: PPUSH
35432: CALL_OW 251
35436: PUSH
35437: LD_VAR 0 3
35441: PUSH
35442: LD_VAR 0 4
35446: ARRAY
35447: PPUSH
35448: CALL_OW 254
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: PUSH
35459: EMPTY
35460: LIST
35461: ADD
35462: ST_TO_ADDR
35463: GO 35376
35465: POP
35466: POP
// result := list ;
35467: LD_ADDR_VAR 0 2
35471: PUSH
35472: LD_VAR 0 5
35476: ST_TO_ADDR
// end ;
35477: LD_VAR 0 2
35481: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
35482: LD_INT 0
35484: PPUSH
35485: PPUSH
35486: PPUSH
35487: PPUSH
35488: PPUSH
35489: PPUSH
35490: PPUSH
// if not factory then
35491: LD_VAR 0 1
35495: NOT
35496: IFFALSE 35500
// exit ;
35498: GO 36025
// if control = control_apeman then
35500: LD_VAR 0 4
35504: PUSH
35505: LD_INT 5
35507: EQUAL
35508: IFFALSE 35617
// begin tmp := UnitsInside ( factory ) ;
35510: LD_ADDR_VAR 0 8
35514: PUSH
35515: LD_VAR 0 1
35519: PPUSH
35520: CALL_OW 313
35524: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
35525: LD_VAR 0 8
35529: PPUSH
35530: LD_INT 25
35532: PUSH
35533: LD_INT 12
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PPUSH
35540: CALL_OW 72
35544: NOT
35545: IFFALSE 35555
// control := control_manual ;
35547: LD_ADDR_VAR 0 4
35551: PUSH
35552: LD_INT 1
35554: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
35555: LD_ADDR_VAR 0 8
35559: PUSH
35560: LD_VAR 0 1
35564: PPUSH
35565: CALL 35252 0 1
35569: ST_TO_ADDR
// if tmp then
35570: LD_VAR 0 8
35574: IFFALSE 35617
// begin for i in tmp do
35576: LD_ADDR_VAR 0 7
35580: PUSH
35581: LD_VAR 0 8
35585: PUSH
35586: FOR_IN
35587: IFFALSE 35615
// if i [ 1 ] = b_ext_radar then
35589: LD_VAR 0 7
35593: PUSH
35594: LD_INT 1
35596: ARRAY
35597: PUSH
35598: LD_INT 20
35600: EQUAL
35601: IFFALSE 35613
// begin control := control_remote ;
35603: LD_ADDR_VAR 0 4
35607: PUSH
35608: LD_INT 2
35610: ST_TO_ADDR
// break ;
35611: GO 35615
// end ;
35613: GO 35586
35615: POP
35616: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
35617: LD_VAR 0 1
35621: PPUSH
35622: LD_VAR 0 2
35626: PPUSH
35627: LD_VAR 0 3
35631: PPUSH
35632: LD_VAR 0 4
35636: PPUSH
35637: LD_VAR 0 5
35641: PPUSH
35642: CALL_OW 448
35646: IFFALSE 35681
// begin result := [ chassis , engine , control , weapon ] ;
35648: LD_ADDR_VAR 0 6
35652: PUSH
35653: LD_VAR 0 2
35657: PUSH
35658: LD_VAR 0 3
35662: PUSH
35663: LD_VAR 0 4
35667: PUSH
35668: LD_VAR 0 5
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: ST_TO_ADDR
// exit ;
35679: GO 36025
// end ; _chassis := AvailableChassisList ( factory ) ;
35681: LD_ADDR_VAR 0 9
35685: PUSH
35686: LD_VAR 0 1
35690: PPUSH
35691: CALL_OW 475
35695: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
35696: LD_ADDR_VAR 0 11
35700: PUSH
35701: LD_VAR 0 1
35705: PPUSH
35706: CALL_OW 476
35710: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
35711: LD_ADDR_VAR 0 12
35715: PUSH
35716: LD_VAR 0 1
35720: PPUSH
35721: CALL_OW 477
35725: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
35726: LD_ADDR_VAR 0 10
35730: PUSH
35731: LD_VAR 0 1
35735: PPUSH
35736: CALL_OW 478
35740: ST_TO_ADDR
// if not chassis in _chassis then
35741: LD_VAR 0 2
35745: PUSH
35746: LD_VAR 0 9
35750: IN
35751: NOT
35752: IFFALSE 35778
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
35754: LD_ADDR_VAR 0 2
35758: PUSH
35759: LD_VAR 0 9
35763: PUSH
35764: LD_INT 1
35766: PPUSH
35767: LD_VAR 0 9
35771: PPUSH
35772: CALL_OW 12
35776: ARRAY
35777: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
35778: LD_VAR 0 2
35782: PPUSH
35783: LD_VAR 0 3
35787: PPUSH
35788: CALL 36030 0 2
35792: NOT
35793: IFFALSE 35852
// repeat engine := _engine [ 1 ] ;
35795: LD_ADDR_VAR 0 3
35799: PUSH
35800: LD_VAR 0 11
35804: PUSH
35805: LD_INT 1
35807: ARRAY
35808: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
35809: LD_ADDR_VAR 0 11
35813: PUSH
35814: LD_VAR 0 11
35818: PPUSH
35819: LD_INT 1
35821: PPUSH
35822: CALL_OW 3
35826: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
35827: LD_VAR 0 2
35831: PPUSH
35832: LD_VAR 0 3
35836: PPUSH
35837: CALL 36030 0 2
35841: PUSH
35842: LD_VAR 0 11
35846: PUSH
35847: EMPTY
35848: EQUAL
35849: OR
35850: IFFALSE 35795
// if not control in _control then
35852: LD_VAR 0 4
35856: PUSH
35857: LD_VAR 0 12
35861: IN
35862: NOT
35863: IFFALSE 35889
// control := _control [ rand ( 1 , _control ) ] ;
35865: LD_ADDR_VAR 0 4
35869: PUSH
35870: LD_VAR 0 12
35874: PUSH
35875: LD_INT 1
35877: PPUSH
35878: LD_VAR 0 12
35882: PPUSH
35883: CALL_OW 12
35887: ARRAY
35888: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
35889: LD_VAR 0 2
35893: PPUSH
35894: LD_VAR 0 5
35898: PPUSH
35899: CALL 36250 0 2
35903: NOT
35904: IFFALSE 35963
// repeat weapon := _weapon [ 1 ] ;
35906: LD_ADDR_VAR 0 5
35910: PUSH
35911: LD_VAR 0 10
35915: PUSH
35916: LD_INT 1
35918: ARRAY
35919: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
35920: LD_ADDR_VAR 0 10
35924: PUSH
35925: LD_VAR 0 10
35929: PPUSH
35930: LD_INT 1
35932: PPUSH
35933: CALL_OW 3
35937: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
35938: LD_VAR 0 2
35942: PPUSH
35943: LD_VAR 0 5
35947: PPUSH
35948: CALL 36250 0 2
35952: PUSH
35953: LD_VAR 0 10
35957: PUSH
35958: EMPTY
35959: EQUAL
35960: OR
35961: IFFALSE 35906
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
35963: LD_VAR 0 1
35967: PPUSH
35968: LD_VAR 0 2
35972: PPUSH
35973: LD_VAR 0 3
35977: PPUSH
35978: LD_VAR 0 4
35982: PPUSH
35983: LD_VAR 0 5
35987: PPUSH
35988: CALL_OW 448
35992: IFFALSE 36025
// result := [ chassis , engine , control , weapon ] ;
35994: LD_ADDR_VAR 0 6
35998: PUSH
35999: LD_VAR 0 2
36003: PUSH
36004: LD_VAR 0 3
36008: PUSH
36009: LD_VAR 0 4
36013: PUSH
36014: LD_VAR 0 5
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: LIST
36023: LIST
36024: ST_TO_ADDR
// end ;
36025: LD_VAR 0 6
36029: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
36030: LD_INT 0
36032: PPUSH
// if not chassis or not engine then
36033: LD_VAR 0 1
36037: NOT
36038: PUSH
36039: LD_VAR 0 2
36043: NOT
36044: OR
36045: IFFALSE 36049
// exit ;
36047: GO 36245
// case engine of engine_solar :
36049: LD_VAR 0 2
36053: PUSH
36054: LD_INT 2
36056: DOUBLE
36057: EQUAL
36058: IFTRUE 36062
36060: GO 36100
36062: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
36063: LD_ADDR_VAR 0 3
36067: PUSH
36068: LD_INT 11
36070: PUSH
36071: LD_INT 12
36073: PUSH
36074: LD_INT 13
36076: PUSH
36077: LD_INT 14
36079: PUSH
36080: LD_INT 1
36082: PUSH
36083: LD_INT 2
36085: PUSH
36086: LD_INT 3
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: ST_TO_ADDR
36098: GO 36229
36100: LD_INT 1
36102: DOUBLE
36103: EQUAL
36104: IFTRUE 36108
36106: GO 36170
36108: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
36109: LD_ADDR_VAR 0 3
36113: PUSH
36114: LD_INT 11
36116: PUSH
36117: LD_INT 12
36119: PUSH
36120: LD_INT 13
36122: PUSH
36123: LD_INT 14
36125: PUSH
36126: LD_INT 1
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: LD_INT 3
36134: PUSH
36135: LD_INT 4
36137: PUSH
36138: LD_INT 5
36140: PUSH
36141: LD_INT 21
36143: PUSH
36144: LD_INT 23
36146: PUSH
36147: LD_INT 22
36149: PUSH
36150: LD_INT 24
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: ST_TO_ADDR
36168: GO 36229
36170: LD_INT 3
36172: DOUBLE
36173: EQUAL
36174: IFTRUE 36178
36176: GO 36228
36178: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
36179: LD_ADDR_VAR 0 3
36183: PUSH
36184: LD_INT 13
36186: PUSH
36187: LD_INT 14
36189: PUSH
36190: LD_INT 2
36192: PUSH
36193: LD_INT 3
36195: PUSH
36196: LD_INT 4
36198: PUSH
36199: LD_INT 5
36201: PUSH
36202: LD_INT 21
36204: PUSH
36205: LD_INT 22
36207: PUSH
36208: LD_INT 23
36210: PUSH
36211: LD_INT 24
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: ST_TO_ADDR
36226: GO 36229
36228: POP
// result := ( chassis in result ) ;
36229: LD_ADDR_VAR 0 3
36233: PUSH
36234: LD_VAR 0 1
36238: PUSH
36239: LD_VAR 0 3
36243: IN
36244: ST_TO_ADDR
// end ;
36245: LD_VAR 0 3
36249: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
36250: LD_INT 0
36252: PPUSH
// if not chassis or not weapon then
36253: LD_VAR 0 1
36257: NOT
36258: PUSH
36259: LD_VAR 0 2
36263: NOT
36264: OR
36265: IFFALSE 36269
// exit ;
36267: GO 37295
// case weapon of us_machine_gun :
36269: LD_VAR 0 2
36273: PUSH
36274: LD_INT 2
36276: DOUBLE
36277: EQUAL
36278: IFTRUE 36282
36280: GO 36312
36282: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
36283: LD_ADDR_VAR 0 3
36287: PUSH
36288: LD_INT 1
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: LD_INT 3
36296: PUSH
36297: LD_INT 4
36299: PUSH
36300: LD_INT 5
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: ST_TO_ADDR
36310: GO 37279
36312: LD_INT 3
36314: DOUBLE
36315: EQUAL
36316: IFTRUE 36320
36318: GO 36350
36320: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
36321: LD_ADDR_VAR 0 3
36325: PUSH
36326: LD_INT 1
36328: PUSH
36329: LD_INT 2
36331: PUSH
36332: LD_INT 3
36334: PUSH
36335: LD_INT 4
36337: PUSH
36338: LD_INT 5
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: ST_TO_ADDR
36348: GO 37279
36350: LD_INT 11
36352: DOUBLE
36353: EQUAL
36354: IFTRUE 36358
36356: GO 36388
36358: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
36359: LD_ADDR_VAR 0 3
36363: PUSH
36364: LD_INT 1
36366: PUSH
36367: LD_INT 2
36369: PUSH
36370: LD_INT 3
36372: PUSH
36373: LD_INT 4
36375: PUSH
36376: LD_INT 5
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: ST_TO_ADDR
36386: GO 37279
36388: LD_INT 4
36390: DOUBLE
36391: EQUAL
36392: IFTRUE 36396
36394: GO 36422
36396: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
36397: LD_ADDR_VAR 0 3
36401: PUSH
36402: LD_INT 2
36404: PUSH
36405: LD_INT 3
36407: PUSH
36408: LD_INT 4
36410: PUSH
36411: LD_INT 5
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: LIST
36418: LIST
36419: ST_TO_ADDR
36420: GO 37279
36422: LD_INT 5
36424: DOUBLE
36425: EQUAL
36426: IFTRUE 36430
36428: GO 36456
36430: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
36431: LD_ADDR_VAR 0 3
36435: PUSH
36436: LD_INT 2
36438: PUSH
36439: LD_INT 3
36441: PUSH
36442: LD_INT 4
36444: PUSH
36445: LD_INT 5
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: LIST
36452: LIST
36453: ST_TO_ADDR
36454: GO 37279
36456: LD_INT 9
36458: DOUBLE
36459: EQUAL
36460: IFTRUE 36464
36462: GO 36490
36464: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
36465: LD_ADDR_VAR 0 3
36469: PUSH
36470: LD_INT 2
36472: PUSH
36473: LD_INT 3
36475: PUSH
36476: LD_INT 4
36478: PUSH
36479: LD_INT 5
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: ST_TO_ADDR
36488: GO 37279
36490: LD_INT 7
36492: DOUBLE
36493: EQUAL
36494: IFTRUE 36498
36496: GO 36524
36498: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
36499: LD_ADDR_VAR 0 3
36503: PUSH
36504: LD_INT 2
36506: PUSH
36507: LD_INT 3
36509: PUSH
36510: LD_INT 4
36512: PUSH
36513: LD_INT 5
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: ST_TO_ADDR
36522: GO 37279
36524: LD_INT 12
36526: DOUBLE
36527: EQUAL
36528: IFTRUE 36532
36530: GO 36558
36532: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
36533: LD_ADDR_VAR 0 3
36537: PUSH
36538: LD_INT 2
36540: PUSH
36541: LD_INT 3
36543: PUSH
36544: LD_INT 4
36546: PUSH
36547: LD_INT 5
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: ST_TO_ADDR
36556: GO 37279
36558: LD_INT 13
36560: DOUBLE
36561: EQUAL
36562: IFTRUE 36566
36564: GO 36592
36566: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
36567: LD_ADDR_VAR 0 3
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: LD_INT 3
36577: PUSH
36578: LD_INT 4
36580: PUSH
36581: LD_INT 5
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: ST_TO_ADDR
36590: GO 37279
36592: LD_INT 14
36594: DOUBLE
36595: EQUAL
36596: IFTRUE 36600
36598: GO 36618
36600: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
36601: LD_ADDR_VAR 0 3
36605: PUSH
36606: LD_INT 4
36608: PUSH
36609: LD_INT 5
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: ST_TO_ADDR
36616: GO 37279
36618: LD_INT 6
36620: DOUBLE
36621: EQUAL
36622: IFTRUE 36626
36624: GO 36644
36626: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
36627: LD_ADDR_VAR 0 3
36631: PUSH
36632: LD_INT 4
36634: PUSH
36635: LD_INT 5
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: ST_TO_ADDR
36642: GO 37279
36644: LD_INT 10
36646: DOUBLE
36647: EQUAL
36648: IFTRUE 36652
36650: GO 36670
36652: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
36653: LD_ADDR_VAR 0 3
36657: PUSH
36658: LD_INT 4
36660: PUSH
36661: LD_INT 5
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: ST_TO_ADDR
36668: GO 37279
36670: LD_INT 22
36672: DOUBLE
36673: EQUAL
36674: IFTRUE 36678
36676: GO 36704
36678: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
36679: LD_ADDR_VAR 0 3
36683: PUSH
36684: LD_INT 11
36686: PUSH
36687: LD_INT 12
36689: PUSH
36690: LD_INT 13
36692: PUSH
36693: LD_INT 14
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: ST_TO_ADDR
36702: GO 37279
36704: LD_INT 23
36706: DOUBLE
36707: EQUAL
36708: IFTRUE 36712
36710: GO 36738
36712: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
36713: LD_ADDR_VAR 0 3
36717: PUSH
36718: LD_INT 11
36720: PUSH
36721: LD_INT 12
36723: PUSH
36724: LD_INT 13
36726: PUSH
36727: LD_INT 14
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: ST_TO_ADDR
36736: GO 37279
36738: LD_INT 24
36740: DOUBLE
36741: EQUAL
36742: IFTRUE 36746
36744: GO 36772
36746: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
36747: LD_ADDR_VAR 0 3
36751: PUSH
36752: LD_INT 11
36754: PUSH
36755: LD_INT 12
36757: PUSH
36758: LD_INT 13
36760: PUSH
36761: LD_INT 14
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: ST_TO_ADDR
36770: GO 37279
36772: LD_INT 30
36774: DOUBLE
36775: EQUAL
36776: IFTRUE 36780
36778: GO 36806
36780: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
36781: LD_ADDR_VAR 0 3
36785: PUSH
36786: LD_INT 11
36788: PUSH
36789: LD_INT 12
36791: PUSH
36792: LD_INT 13
36794: PUSH
36795: LD_INT 14
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: ST_TO_ADDR
36804: GO 37279
36806: LD_INT 25
36808: DOUBLE
36809: EQUAL
36810: IFTRUE 36814
36812: GO 36832
36814: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
36815: LD_ADDR_VAR 0 3
36819: PUSH
36820: LD_INT 13
36822: PUSH
36823: LD_INT 14
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: ST_TO_ADDR
36830: GO 37279
36832: LD_INT 27
36834: DOUBLE
36835: EQUAL
36836: IFTRUE 36840
36838: GO 36858
36840: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
36841: LD_ADDR_VAR 0 3
36845: PUSH
36846: LD_INT 13
36848: PUSH
36849: LD_INT 14
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: ST_TO_ADDR
36856: GO 37279
36858: LD_INT 28
36860: DOUBLE
36861: EQUAL
36862: IFTRUE 36866
36864: GO 36884
36866: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
36867: LD_ADDR_VAR 0 3
36871: PUSH
36872: LD_INT 13
36874: PUSH
36875: LD_INT 14
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: ST_TO_ADDR
36882: GO 37279
36884: LD_INT 29
36886: DOUBLE
36887: EQUAL
36888: IFTRUE 36892
36890: GO 36910
36892: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
36893: LD_ADDR_VAR 0 3
36897: PUSH
36898: LD_INT 13
36900: PUSH
36901: LD_INT 14
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: ST_TO_ADDR
36908: GO 37279
36910: LD_INT 31
36912: DOUBLE
36913: EQUAL
36914: IFTRUE 36918
36916: GO 36936
36918: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
36919: LD_ADDR_VAR 0 3
36923: PUSH
36924: LD_INT 13
36926: PUSH
36927: LD_INT 14
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: ST_TO_ADDR
36934: GO 37279
36936: LD_INT 26
36938: DOUBLE
36939: EQUAL
36940: IFTRUE 36944
36942: GO 36962
36944: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
36945: LD_ADDR_VAR 0 3
36949: PUSH
36950: LD_INT 13
36952: PUSH
36953: LD_INT 14
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: ST_TO_ADDR
36960: GO 37279
36962: LD_INT 42
36964: DOUBLE
36965: EQUAL
36966: IFTRUE 36970
36968: GO 36996
36970: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
36971: LD_ADDR_VAR 0 3
36975: PUSH
36976: LD_INT 21
36978: PUSH
36979: LD_INT 22
36981: PUSH
36982: LD_INT 23
36984: PUSH
36985: LD_INT 24
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: ST_TO_ADDR
36994: GO 37279
36996: LD_INT 43
36998: DOUBLE
36999: EQUAL
37000: IFTRUE 37004
37002: GO 37030
37004: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
37005: LD_ADDR_VAR 0 3
37009: PUSH
37010: LD_INT 21
37012: PUSH
37013: LD_INT 22
37015: PUSH
37016: LD_INT 23
37018: PUSH
37019: LD_INT 24
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: ST_TO_ADDR
37028: GO 37279
37030: LD_INT 44
37032: DOUBLE
37033: EQUAL
37034: IFTRUE 37038
37036: GO 37064
37038: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
37039: LD_ADDR_VAR 0 3
37043: PUSH
37044: LD_INT 21
37046: PUSH
37047: LD_INT 22
37049: PUSH
37050: LD_INT 23
37052: PUSH
37053: LD_INT 24
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: ST_TO_ADDR
37062: GO 37279
37064: LD_INT 45
37066: DOUBLE
37067: EQUAL
37068: IFTRUE 37072
37070: GO 37098
37072: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
37073: LD_ADDR_VAR 0 3
37077: PUSH
37078: LD_INT 21
37080: PUSH
37081: LD_INT 22
37083: PUSH
37084: LD_INT 23
37086: PUSH
37087: LD_INT 24
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: LIST
37094: LIST
37095: ST_TO_ADDR
37096: GO 37279
37098: LD_INT 49
37100: DOUBLE
37101: EQUAL
37102: IFTRUE 37106
37104: GO 37132
37106: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
37107: LD_ADDR_VAR 0 3
37111: PUSH
37112: LD_INT 21
37114: PUSH
37115: LD_INT 22
37117: PUSH
37118: LD_INT 23
37120: PUSH
37121: LD_INT 24
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: ST_TO_ADDR
37130: GO 37279
37132: LD_INT 51
37134: DOUBLE
37135: EQUAL
37136: IFTRUE 37140
37138: GO 37166
37140: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
37141: LD_ADDR_VAR 0 3
37145: PUSH
37146: LD_INT 21
37148: PUSH
37149: LD_INT 22
37151: PUSH
37152: LD_INT 23
37154: PUSH
37155: LD_INT 24
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: LIST
37162: LIST
37163: ST_TO_ADDR
37164: GO 37279
37166: LD_INT 52
37168: DOUBLE
37169: EQUAL
37170: IFTRUE 37174
37172: GO 37200
37174: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
37175: LD_ADDR_VAR 0 3
37179: PUSH
37180: LD_INT 21
37182: PUSH
37183: LD_INT 22
37185: PUSH
37186: LD_INT 23
37188: PUSH
37189: LD_INT 24
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: ST_TO_ADDR
37198: GO 37279
37200: LD_INT 53
37202: DOUBLE
37203: EQUAL
37204: IFTRUE 37208
37206: GO 37226
37208: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
37209: LD_ADDR_VAR 0 3
37213: PUSH
37214: LD_INT 23
37216: PUSH
37217: LD_INT 24
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: ST_TO_ADDR
37224: GO 37279
37226: LD_INT 46
37228: DOUBLE
37229: EQUAL
37230: IFTRUE 37234
37232: GO 37252
37234: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
37235: LD_ADDR_VAR 0 3
37239: PUSH
37240: LD_INT 23
37242: PUSH
37243: LD_INT 24
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: ST_TO_ADDR
37250: GO 37279
37252: LD_INT 47
37254: DOUBLE
37255: EQUAL
37256: IFTRUE 37260
37258: GO 37278
37260: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
37261: LD_ADDR_VAR 0 3
37265: PUSH
37266: LD_INT 23
37268: PUSH
37269: LD_INT 24
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: ST_TO_ADDR
37276: GO 37279
37278: POP
// result := ( chassis in result ) ;
37279: LD_ADDR_VAR 0 3
37283: PUSH
37284: LD_VAR 0 1
37288: PUSH
37289: LD_VAR 0 3
37293: IN
37294: ST_TO_ADDR
// end ;
37295: LD_VAR 0 3
37299: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
37300: LD_INT 0
37302: PPUSH
37303: PPUSH
37304: PPUSH
37305: PPUSH
37306: PPUSH
37307: PPUSH
37308: PPUSH
// result := array ;
37309: LD_ADDR_VAR 0 5
37313: PUSH
37314: LD_VAR 0 1
37318: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
37319: LD_VAR 0 1
37323: NOT
37324: PUSH
37325: LD_VAR 0 2
37329: NOT
37330: OR
37331: PUSH
37332: LD_VAR 0 3
37336: NOT
37337: OR
37338: PUSH
37339: LD_VAR 0 2
37343: PUSH
37344: LD_VAR 0 1
37348: GREATER
37349: OR
37350: PUSH
37351: LD_VAR 0 3
37355: PUSH
37356: LD_VAR 0 1
37360: GREATER
37361: OR
37362: IFFALSE 37366
// exit ;
37364: GO 37662
// if direction then
37366: LD_VAR 0 4
37370: IFFALSE 37434
// begin d := 1 ;
37372: LD_ADDR_VAR 0 9
37376: PUSH
37377: LD_INT 1
37379: ST_TO_ADDR
// if i_from > i_to then
37380: LD_VAR 0 2
37384: PUSH
37385: LD_VAR 0 3
37389: GREATER
37390: IFFALSE 37416
// length := ( array - i_from ) + i_to else
37392: LD_ADDR_VAR 0 11
37396: PUSH
37397: LD_VAR 0 1
37401: PUSH
37402: LD_VAR 0 2
37406: MINUS
37407: PUSH
37408: LD_VAR 0 3
37412: PLUS
37413: ST_TO_ADDR
37414: GO 37432
// length := i_to - i_from ;
37416: LD_ADDR_VAR 0 11
37420: PUSH
37421: LD_VAR 0 3
37425: PUSH
37426: LD_VAR 0 2
37430: MINUS
37431: ST_TO_ADDR
// end else
37432: GO 37495
// begin d := - 1 ;
37434: LD_ADDR_VAR 0 9
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: ST_TO_ADDR
// if i_from > i_to then
37443: LD_VAR 0 2
37447: PUSH
37448: LD_VAR 0 3
37452: GREATER
37453: IFFALSE 37473
// length := i_from - i_to else
37455: LD_ADDR_VAR 0 11
37459: PUSH
37460: LD_VAR 0 2
37464: PUSH
37465: LD_VAR 0 3
37469: MINUS
37470: ST_TO_ADDR
37471: GO 37495
// length := ( array - i_to ) + i_from ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PUSH
37483: LD_VAR 0 3
37487: MINUS
37488: PUSH
37489: LD_VAR 0 2
37493: PLUS
37494: ST_TO_ADDR
// end ; if not length then
37495: LD_VAR 0 11
37499: NOT
37500: IFFALSE 37504
// exit ;
37502: GO 37662
// tmp := array ;
37504: LD_ADDR_VAR 0 10
37508: PUSH
37509: LD_VAR 0 1
37513: ST_TO_ADDR
// for i = 1 to length do
37514: LD_ADDR_VAR 0 6
37518: PUSH
37519: DOUBLE
37520: LD_INT 1
37522: DEC
37523: ST_TO_ADDR
37524: LD_VAR 0 11
37528: PUSH
37529: FOR_TO
37530: IFFALSE 37650
// begin for j = 1 to array do
37532: LD_ADDR_VAR 0 7
37536: PUSH
37537: DOUBLE
37538: LD_INT 1
37540: DEC
37541: ST_TO_ADDR
37542: LD_VAR 0 1
37546: PUSH
37547: FOR_TO
37548: IFFALSE 37636
// begin k := j + d ;
37550: LD_ADDR_VAR 0 8
37554: PUSH
37555: LD_VAR 0 7
37559: PUSH
37560: LD_VAR 0 9
37564: PLUS
37565: ST_TO_ADDR
// if k > array then
37566: LD_VAR 0 8
37570: PUSH
37571: LD_VAR 0 1
37575: GREATER
37576: IFFALSE 37586
// k := 1 ;
37578: LD_ADDR_VAR 0 8
37582: PUSH
37583: LD_INT 1
37585: ST_TO_ADDR
// if not k then
37586: LD_VAR 0 8
37590: NOT
37591: IFFALSE 37603
// k := array ;
37593: LD_ADDR_VAR 0 8
37597: PUSH
37598: LD_VAR 0 1
37602: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
37603: LD_ADDR_VAR 0 10
37607: PUSH
37608: LD_VAR 0 10
37612: PPUSH
37613: LD_VAR 0 8
37617: PPUSH
37618: LD_VAR 0 1
37622: PUSH
37623: LD_VAR 0 7
37627: ARRAY
37628: PPUSH
37629: CALL_OW 1
37633: ST_TO_ADDR
// end ;
37634: GO 37547
37636: POP
37637: POP
// array := tmp ;
37638: LD_ADDR_VAR 0 1
37642: PUSH
37643: LD_VAR 0 10
37647: ST_TO_ADDR
// end ;
37648: GO 37529
37650: POP
37651: POP
// result := array ;
37652: LD_ADDR_VAR 0 5
37656: PUSH
37657: LD_VAR 0 1
37661: ST_TO_ADDR
// end ;
37662: LD_VAR 0 5
37666: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
37667: LD_INT 0
37669: PPUSH
37670: PPUSH
// result := 0 ;
37671: LD_ADDR_VAR 0 3
37675: PUSH
37676: LD_INT 0
37678: ST_TO_ADDR
// if not array or not value in array then
37679: LD_VAR 0 1
37683: NOT
37684: PUSH
37685: LD_VAR 0 2
37689: PUSH
37690: LD_VAR 0 1
37694: IN
37695: NOT
37696: OR
37697: IFFALSE 37701
// exit ;
37699: GO 37755
// for i = 1 to array do
37701: LD_ADDR_VAR 0 4
37705: PUSH
37706: DOUBLE
37707: LD_INT 1
37709: DEC
37710: ST_TO_ADDR
37711: LD_VAR 0 1
37715: PUSH
37716: FOR_TO
37717: IFFALSE 37753
// if value = array [ i ] then
37719: LD_VAR 0 2
37723: PUSH
37724: LD_VAR 0 1
37728: PUSH
37729: LD_VAR 0 4
37733: ARRAY
37734: EQUAL
37735: IFFALSE 37751
// begin result := i ;
37737: LD_ADDR_VAR 0 3
37741: PUSH
37742: LD_VAR 0 4
37746: ST_TO_ADDR
// exit ;
37747: POP
37748: POP
37749: GO 37755
// end ;
37751: GO 37716
37753: POP
37754: POP
// end ;
37755: LD_VAR 0 3
37759: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
37760: LD_INT 0
37762: PPUSH
// vc_chassis := chassis ;
37763: LD_ADDR_OWVAR 37
37767: PUSH
37768: LD_VAR 0 1
37772: ST_TO_ADDR
// vc_engine := engine ;
37773: LD_ADDR_OWVAR 39
37777: PUSH
37778: LD_VAR 0 2
37782: ST_TO_ADDR
// vc_control := control ;
37783: LD_ADDR_OWVAR 38
37787: PUSH
37788: LD_VAR 0 3
37792: ST_TO_ADDR
// vc_weapon := weapon ;
37793: LD_ADDR_OWVAR 40
37797: PUSH
37798: LD_VAR 0 4
37802: ST_TO_ADDR
// vc_fuel_battery := fuel ;
37803: LD_ADDR_OWVAR 41
37807: PUSH
37808: LD_VAR 0 5
37812: ST_TO_ADDR
// end ;
37813: LD_VAR 0 6
37817: RET
// export function WantPlant ( unit ) ; var task ; begin
37818: LD_INT 0
37820: PPUSH
37821: PPUSH
// result := false ;
37822: LD_ADDR_VAR 0 2
37826: PUSH
37827: LD_INT 0
37829: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
37830: LD_ADDR_VAR 0 3
37834: PUSH
37835: LD_VAR 0 1
37839: PPUSH
37840: CALL_OW 437
37844: ST_TO_ADDR
// if task then
37845: LD_VAR 0 3
37849: IFFALSE 37877
// if task [ 1 ] [ 1 ] = p then
37851: LD_VAR 0 3
37855: PUSH
37856: LD_INT 1
37858: ARRAY
37859: PUSH
37860: LD_INT 1
37862: ARRAY
37863: PUSH
37864: LD_STRING p
37866: EQUAL
37867: IFFALSE 37877
// result := true ;
37869: LD_ADDR_VAR 0 2
37873: PUSH
37874: LD_INT 1
37876: ST_TO_ADDR
// end ;
37877: LD_VAR 0 2
37881: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
37882: LD_INT 0
37884: PPUSH
37885: PPUSH
37886: PPUSH
37887: PPUSH
// if pos < 1 then
37888: LD_VAR 0 2
37892: PUSH
37893: LD_INT 1
37895: LESS
37896: IFFALSE 37900
// exit ;
37898: GO 38203
// if pos = 1 then
37900: LD_VAR 0 2
37904: PUSH
37905: LD_INT 1
37907: EQUAL
37908: IFFALSE 37941
// result := Replace ( arr , pos [ 1 ] , value ) else
37910: LD_ADDR_VAR 0 4
37914: PUSH
37915: LD_VAR 0 1
37919: PPUSH
37920: LD_VAR 0 2
37924: PUSH
37925: LD_INT 1
37927: ARRAY
37928: PPUSH
37929: LD_VAR 0 3
37933: PPUSH
37934: CALL_OW 1
37938: ST_TO_ADDR
37939: GO 38203
// begin tmp := arr ;
37941: LD_ADDR_VAR 0 6
37945: PUSH
37946: LD_VAR 0 1
37950: ST_TO_ADDR
// s_arr := [ tmp ] ;
37951: LD_ADDR_VAR 0 7
37955: PUSH
37956: LD_VAR 0 6
37960: PUSH
37961: EMPTY
37962: LIST
37963: ST_TO_ADDR
// for i = 1 to pos - 1 do
37964: LD_ADDR_VAR 0 5
37968: PUSH
37969: DOUBLE
37970: LD_INT 1
37972: DEC
37973: ST_TO_ADDR
37974: LD_VAR 0 2
37978: PUSH
37979: LD_INT 1
37981: MINUS
37982: PUSH
37983: FOR_TO
37984: IFFALSE 38029
// begin tmp := tmp [ pos [ i ] ] ;
37986: LD_ADDR_VAR 0 6
37990: PUSH
37991: LD_VAR 0 6
37995: PUSH
37996: LD_VAR 0 2
38000: PUSH
38001: LD_VAR 0 5
38005: ARRAY
38006: ARRAY
38007: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
38008: LD_ADDR_VAR 0 7
38012: PUSH
38013: LD_VAR 0 7
38017: PUSH
38018: LD_VAR 0 6
38022: PUSH
38023: EMPTY
38024: LIST
38025: ADD
38026: ST_TO_ADDR
// end ;
38027: GO 37983
38029: POP
38030: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
38031: LD_ADDR_VAR 0 6
38035: PUSH
38036: LD_VAR 0 6
38040: PPUSH
38041: LD_VAR 0 2
38045: PUSH
38046: LD_VAR 0 2
38050: ARRAY
38051: PPUSH
38052: LD_VAR 0 3
38056: PPUSH
38057: CALL_OW 1
38061: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
38062: LD_ADDR_VAR 0 7
38066: PUSH
38067: LD_VAR 0 7
38071: PPUSH
38072: LD_VAR 0 7
38076: PPUSH
38077: LD_VAR 0 6
38081: PPUSH
38082: CALL_OW 1
38086: ST_TO_ADDR
// for i = s_arr downto 2 do
38087: LD_ADDR_VAR 0 5
38091: PUSH
38092: DOUBLE
38093: LD_VAR 0 7
38097: INC
38098: ST_TO_ADDR
38099: LD_INT 2
38101: PUSH
38102: FOR_DOWNTO
38103: IFFALSE 38187
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
38105: LD_ADDR_VAR 0 6
38109: PUSH
38110: LD_VAR 0 7
38114: PUSH
38115: LD_VAR 0 5
38119: PUSH
38120: LD_INT 1
38122: MINUS
38123: ARRAY
38124: PPUSH
38125: LD_VAR 0 2
38129: PUSH
38130: LD_VAR 0 5
38134: PUSH
38135: LD_INT 1
38137: MINUS
38138: ARRAY
38139: PPUSH
38140: LD_VAR 0 7
38144: PUSH
38145: LD_VAR 0 5
38149: ARRAY
38150: PPUSH
38151: CALL_OW 1
38155: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
38156: LD_ADDR_VAR 0 7
38160: PUSH
38161: LD_VAR 0 7
38165: PPUSH
38166: LD_VAR 0 5
38170: PUSH
38171: LD_INT 1
38173: MINUS
38174: PPUSH
38175: LD_VAR 0 6
38179: PPUSH
38180: CALL_OW 1
38184: ST_TO_ADDR
// end ;
38185: GO 38102
38187: POP
38188: POP
// result := s_arr [ 1 ] ;
38189: LD_ADDR_VAR 0 4
38193: PUSH
38194: LD_VAR 0 7
38198: PUSH
38199: LD_INT 1
38201: ARRAY
38202: ST_TO_ADDR
// end ; end ;
38203: LD_VAR 0 4
38207: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
38208: LD_INT 0
38210: PPUSH
38211: PPUSH
// if not list then
38212: LD_VAR 0 1
38216: NOT
38217: IFFALSE 38221
// exit ;
38219: GO 38312
// i := list [ pos1 ] ;
38221: LD_ADDR_VAR 0 5
38225: PUSH
38226: LD_VAR 0 1
38230: PUSH
38231: LD_VAR 0 2
38235: ARRAY
38236: ST_TO_ADDR
// if not i then
38237: LD_VAR 0 5
38241: NOT
38242: IFFALSE 38246
// exit ;
38244: GO 38312
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
38246: LD_ADDR_VAR 0 1
38250: PUSH
38251: LD_VAR 0 1
38255: PPUSH
38256: LD_VAR 0 2
38260: PPUSH
38261: LD_VAR 0 1
38265: PUSH
38266: LD_VAR 0 3
38270: ARRAY
38271: PPUSH
38272: CALL_OW 1
38276: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
38277: LD_ADDR_VAR 0 1
38281: PUSH
38282: LD_VAR 0 1
38286: PPUSH
38287: LD_VAR 0 3
38291: PPUSH
38292: LD_VAR 0 5
38296: PPUSH
38297: CALL_OW 1
38301: ST_TO_ADDR
// result := list ;
38302: LD_ADDR_VAR 0 4
38306: PUSH
38307: LD_VAR 0 1
38311: ST_TO_ADDR
// end ;
38312: LD_VAR 0 4
38316: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
38317: LD_INT 0
38319: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
38320: LD_ADDR_VAR 0 5
38324: PUSH
38325: LD_VAR 0 1
38329: PPUSH
38330: CALL_OW 250
38334: PPUSH
38335: LD_VAR 0 1
38339: PPUSH
38340: CALL_OW 251
38344: PPUSH
38345: LD_VAR 0 2
38349: PPUSH
38350: LD_VAR 0 3
38354: PPUSH
38355: LD_VAR 0 4
38359: PPUSH
38360: CALL 38370 0 5
38364: ST_TO_ADDR
// end ;
38365: LD_VAR 0 5
38369: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
38370: LD_INT 0
38372: PPUSH
38373: PPUSH
38374: PPUSH
38375: PPUSH
// if not list then
38376: LD_VAR 0 3
38380: NOT
38381: IFFALSE 38385
// exit ;
38383: GO 38773
// result := [ ] ;
38385: LD_ADDR_VAR 0 6
38389: PUSH
38390: EMPTY
38391: ST_TO_ADDR
// for i in list do
38392: LD_ADDR_VAR 0 7
38396: PUSH
38397: LD_VAR 0 3
38401: PUSH
38402: FOR_IN
38403: IFFALSE 38605
// begin tmp := GetDistUnitXY ( i , x , y ) ;
38405: LD_ADDR_VAR 0 9
38409: PUSH
38410: LD_VAR 0 7
38414: PPUSH
38415: LD_VAR 0 1
38419: PPUSH
38420: LD_VAR 0 2
38424: PPUSH
38425: CALL_OW 297
38429: ST_TO_ADDR
// if not result then
38430: LD_VAR 0 6
38434: NOT
38435: IFFALSE 38461
// result := [ [ i , tmp ] ] else
38437: LD_ADDR_VAR 0 6
38441: PUSH
38442: LD_VAR 0 7
38446: PUSH
38447: LD_VAR 0 9
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: EMPTY
38457: LIST
38458: ST_TO_ADDR
38459: GO 38603
// begin if result [ result ] [ 2 ] < tmp then
38461: LD_VAR 0 6
38465: PUSH
38466: LD_VAR 0 6
38470: ARRAY
38471: PUSH
38472: LD_INT 2
38474: ARRAY
38475: PUSH
38476: LD_VAR 0 9
38480: LESS
38481: IFFALSE 38523
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
38483: LD_ADDR_VAR 0 6
38487: PUSH
38488: LD_VAR 0 6
38492: PPUSH
38493: LD_VAR 0 6
38497: PUSH
38498: LD_INT 1
38500: PLUS
38501: PPUSH
38502: LD_VAR 0 7
38506: PUSH
38507: LD_VAR 0 9
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PPUSH
38516: CALL_OW 2
38520: ST_TO_ADDR
38521: GO 38603
// for j = 1 to result do
38523: LD_ADDR_VAR 0 8
38527: PUSH
38528: DOUBLE
38529: LD_INT 1
38531: DEC
38532: ST_TO_ADDR
38533: LD_VAR 0 6
38537: PUSH
38538: FOR_TO
38539: IFFALSE 38601
// begin if tmp < result [ j ] [ 2 ] then
38541: LD_VAR 0 9
38545: PUSH
38546: LD_VAR 0 6
38550: PUSH
38551: LD_VAR 0 8
38555: ARRAY
38556: PUSH
38557: LD_INT 2
38559: ARRAY
38560: LESS
38561: IFFALSE 38599
// begin result := Insert ( result , j , [ i , tmp ] ) ;
38563: LD_ADDR_VAR 0 6
38567: PUSH
38568: LD_VAR 0 6
38572: PPUSH
38573: LD_VAR 0 8
38577: PPUSH
38578: LD_VAR 0 7
38582: PUSH
38583: LD_VAR 0 9
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PPUSH
38592: CALL_OW 2
38596: ST_TO_ADDR
// break ;
38597: GO 38601
// end ; end ;
38599: GO 38538
38601: POP
38602: POP
// end ; end ;
38603: GO 38402
38605: POP
38606: POP
// if result and not asc then
38607: LD_VAR 0 6
38611: PUSH
38612: LD_VAR 0 4
38616: NOT
38617: AND
38618: IFFALSE 38693
// begin tmp := result ;
38620: LD_ADDR_VAR 0 9
38624: PUSH
38625: LD_VAR 0 6
38629: ST_TO_ADDR
// for i = tmp downto 1 do
38630: LD_ADDR_VAR 0 7
38634: PUSH
38635: DOUBLE
38636: LD_VAR 0 9
38640: INC
38641: ST_TO_ADDR
38642: LD_INT 1
38644: PUSH
38645: FOR_DOWNTO
38646: IFFALSE 38691
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
38648: LD_ADDR_VAR 0 6
38652: PUSH
38653: LD_VAR 0 6
38657: PPUSH
38658: LD_VAR 0 9
38662: PUSH
38663: LD_VAR 0 7
38667: MINUS
38668: PUSH
38669: LD_INT 1
38671: PLUS
38672: PPUSH
38673: LD_VAR 0 9
38677: PUSH
38678: LD_VAR 0 7
38682: ARRAY
38683: PPUSH
38684: CALL_OW 1
38688: ST_TO_ADDR
38689: GO 38645
38691: POP
38692: POP
// end ; tmp := [ ] ;
38693: LD_ADDR_VAR 0 9
38697: PUSH
38698: EMPTY
38699: ST_TO_ADDR
// if mode then
38700: LD_VAR 0 5
38704: IFFALSE 38773
// begin for i = 1 to result do
38706: LD_ADDR_VAR 0 7
38710: PUSH
38711: DOUBLE
38712: LD_INT 1
38714: DEC
38715: ST_TO_ADDR
38716: LD_VAR 0 6
38720: PUSH
38721: FOR_TO
38722: IFFALSE 38761
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
38724: LD_ADDR_VAR 0 9
38728: PUSH
38729: LD_VAR 0 9
38733: PPUSH
38734: LD_VAR 0 7
38738: PPUSH
38739: LD_VAR 0 6
38743: PUSH
38744: LD_VAR 0 7
38748: ARRAY
38749: PUSH
38750: LD_INT 1
38752: ARRAY
38753: PPUSH
38754: CALL_OW 1
38758: ST_TO_ADDR
38759: GO 38721
38761: POP
38762: POP
// result := tmp ;
38763: LD_ADDR_VAR 0 6
38767: PUSH
38768: LD_VAR 0 9
38772: ST_TO_ADDR
// end ; end ;
38773: LD_VAR 0 6
38777: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
38778: LD_INT 0
38780: PPUSH
38781: PPUSH
38782: PPUSH
38783: PPUSH
38784: PPUSH
38785: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
38786: LD_ADDR_VAR 0 5
38790: PUSH
38791: LD_INT 0
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: LD_INT 0
38799: PUSH
38800: EMPTY
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: ST_TO_ADDR
// if not x or not y then
38808: LD_VAR 0 2
38812: NOT
38813: PUSH
38814: LD_VAR 0 3
38818: NOT
38819: OR
38820: IFFALSE 38824
// exit ;
38822: GO 40470
// if not range then
38824: LD_VAR 0 4
38828: NOT
38829: IFFALSE 38839
// range := 10 ;
38831: LD_ADDR_VAR 0 4
38835: PUSH
38836: LD_INT 10
38838: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
38839: LD_ADDR_VAR 0 8
38843: PUSH
38844: LD_INT 81
38846: PUSH
38847: LD_VAR 0 1
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 92
38858: PUSH
38859: LD_VAR 0 2
38863: PUSH
38864: LD_VAR 0 3
38868: PUSH
38869: LD_VAR 0 4
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 3
38882: PUSH
38883: LD_INT 21
38885: PUSH
38886: LD_INT 3
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: LIST
38901: PPUSH
38902: CALL_OW 69
38906: ST_TO_ADDR
// if not tmp then
38907: LD_VAR 0 8
38911: NOT
38912: IFFALSE 38916
// exit ;
38914: GO 40470
// for i in tmp do
38916: LD_ADDR_VAR 0 6
38920: PUSH
38921: LD_VAR 0 8
38925: PUSH
38926: FOR_IN
38927: IFFALSE 40445
// begin points := [ 0 , 0 , 0 ] ;
38929: LD_ADDR_VAR 0 9
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 0
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: LIST
38947: ST_TO_ADDR
// bpoints := 1 ;
38948: LD_ADDR_VAR 0 10
38952: PUSH
38953: LD_INT 1
38955: ST_TO_ADDR
// case GetType ( i ) of unit_human :
38956: LD_VAR 0 6
38960: PPUSH
38961: CALL_OW 247
38965: PUSH
38966: LD_INT 1
38968: DOUBLE
38969: EQUAL
38970: IFTRUE 38974
38972: GO 39552
38974: POP
// begin if GetClass ( i ) = 1 then
38975: LD_VAR 0 6
38979: PPUSH
38980: CALL_OW 257
38984: PUSH
38985: LD_INT 1
38987: EQUAL
38988: IFFALSE 39009
// points := [ 10 , 5 , 3 ] ;
38990: LD_ADDR_VAR 0 9
38994: PUSH
38995: LD_INT 10
38997: PUSH
38998: LD_INT 5
39000: PUSH
39001: LD_INT 3
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: LIST
39008: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
39009: LD_VAR 0 6
39013: PPUSH
39014: CALL_OW 257
39018: PUSH
39019: LD_INT 2
39021: PUSH
39022: LD_INT 3
39024: PUSH
39025: LD_INT 4
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: LIST
39032: IN
39033: IFFALSE 39054
// points := [ 3 , 2 , 1 ] ;
39035: LD_ADDR_VAR 0 9
39039: PUSH
39040: LD_INT 3
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: LD_INT 1
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: LIST
39053: ST_TO_ADDR
// if GetClass ( i ) = 5 then
39054: LD_VAR 0 6
39058: PPUSH
39059: CALL_OW 257
39063: PUSH
39064: LD_INT 5
39066: EQUAL
39067: IFFALSE 39088
// points := [ 130 , 5 , 2 ] ;
39069: LD_ADDR_VAR 0 9
39073: PUSH
39074: LD_INT 130
39076: PUSH
39077: LD_INT 5
39079: PUSH
39080: LD_INT 2
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: LIST
39087: ST_TO_ADDR
// if GetClass ( i ) = 8 then
39088: LD_VAR 0 6
39092: PPUSH
39093: CALL_OW 257
39097: PUSH
39098: LD_INT 8
39100: EQUAL
39101: IFFALSE 39122
// points := [ 35 , 35 , 30 ] ;
39103: LD_ADDR_VAR 0 9
39107: PUSH
39108: LD_INT 35
39110: PUSH
39111: LD_INT 35
39113: PUSH
39114: LD_INT 30
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: LIST
39121: ST_TO_ADDR
// if GetClass ( i ) = 9 then
39122: LD_VAR 0 6
39126: PPUSH
39127: CALL_OW 257
39131: PUSH
39132: LD_INT 9
39134: EQUAL
39135: IFFALSE 39156
// points := [ 20 , 55 , 40 ] ;
39137: LD_ADDR_VAR 0 9
39141: PUSH
39142: LD_INT 20
39144: PUSH
39145: LD_INT 55
39147: PUSH
39148: LD_INT 40
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: LIST
39155: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
39156: LD_VAR 0 6
39160: PPUSH
39161: CALL_OW 257
39165: PUSH
39166: LD_INT 12
39168: PUSH
39169: LD_INT 16
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: IN
39176: IFFALSE 39197
// points := [ 5 , 3 , 2 ] ;
39178: LD_ADDR_VAR 0 9
39182: PUSH
39183: LD_INT 5
39185: PUSH
39186: LD_INT 3
39188: PUSH
39189: LD_INT 2
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: LIST
39196: ST_TO_ADDR
// if GetClass ( i ) = 17 then
39197: LD_VAR 0 6
39201: PPUSH
39202: CALL_OW 257
39206: PUSH
39207: LD_INT 17
39209: EQUAL
39210: IFFALSE 39231
// points := [ 100 , 50 , 75 ] ;
39212: LD_ADDR_VAR 0 9
39216: PUSH
39217: LD_INT 100
39219: PUSH
39220: LD_INT 50
39222: PUSH
39223: LD_INT 75
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: LIST
39230: ST_TO_ADDR
// if GetClass ( i ) = 15 then
39231: LD_VAR 0 6
39235: PPUSH
39236: CALL_OW 257
39240: PUSH
39241: LD_INT 15
39243: EQUAL
39244: IFFALSE 39265
// points := [ 10 , 5 , 3 ] ;
39246: LD_ADDR_VAR 0 9
39250: PUSH
39251: LD_INT 10
39253: PUSH
39254: LD_INT 5
39256: PUSH
39257: LD_INT 3
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: LIST
39264: ST_TO_ADDR
// if GetClass ( i ) = 14 then
39265: LD_VAR 0 6
39269: PPUSH
39270: CALL_OW 257
39274: PUSH
39275: LD_INT 14
39277: EQUAL
39278: IFFALSE 39299
// points := [ 10 , 0 , 0 ] ;
39280: LD_ADDR_VAR 0 9
39284: PUSH
39285: LD_INT 10
39287: PUSH
39288: LD_INT 0
39290: PUSH
39291: LD_INT 0
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// if GetClass ( i ) = 11 then
39299: LD_VAR 0 6
39303: PPUSH
39304: CALL_OW 257
39308: PUSH
39309: LD_INT 11
39311: EQUAL
39312: IFFALSE 39333
// points := [ 30 , 10 , 5 ] ;
39314: LD_ADDR_VAR 0 9
39318: PUSH
39319: LD_INT 30
39321: PUSH
39322: LD_INT 10
39324: PUSH
39325: LD_INT 5
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: LIST
39332: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
39333: LD_VAR 0 1
39337: PPUSH
39338: LD_INT 5
39340: PPUSH
39341: CALL_OW 321
39345: PUSH
39346: LD_INT 2
39348: EQUAL
39349: IFFALSE 39366
// bpoints := bpoints * 1.8 ;
39351: LD_ADDR_VAR 0 10
39355: PUSH
39356: LD_VAR 0 10
39360: PUSH
39361: LD_REAL  1.80000000000000E+0000
39364: MUL
39365: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
39366: LD_VAR 0 6
39370: PPUSH
39371: CALL_OW 257
39375: PUSH
39376: LD_INT 1
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 3
39384: PUSH
39385: LD_INT 4
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: LIST
39392: LIST
39393: IN
39394: PUSH
39395: LD_VAR 0 1
39399: PPUSH
39400: LD_INT 51
39402: PPUSH
39403: CALL_OW 321
39407: PUSH
39408: LD_INT 2
39410: EQUAL
39411: AND
39412: IFFALSE 39429
// bpoints := bpoints * 1.2 ;
39414: LD_ADDR_VAR 0 10
39418: PUSH
39419: LD_VAR 0 10
39423: PUSH
39424: LD_REAL  1.20000000000000E+0000
39427: MUL
39428: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
39429: LD_VAR 0 6
39433: PPUSH
39434: CALL_OW 257
39438: PUSH
39439: LD_INT 5
39441: PUSH
39442: LD_INT 7
39444: PUSH
39445: LD_INT 9
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: LIST
39452: IN
39453: PUSH
39454: LD_VAR 0 1
39458: PPUSH
39459: LD_INT 52
39461: PPUSH
39462: CALL_OW 321
39466: PUSH
39467: LD_INT 2
39469: EQUAL
39470: AND
39471: IFFALSE 39488
// bpoints := bpoints * 1.5 ;
39473: LD_ADDR_VAR 0 10
39477: PUSH
39478: LD_VAR 0 10
39482: PUSH
39483: LD_REAL  1.50000000000000E+0000
39486: MUL
39487: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
39488: LD_VAR 0 1
39492: PPUSH
39493: LD_INT 66
39495: PPUSH
39496: CALL_OW 321
39500: PUSH
39501: LD_INT 2
39503: EQUAL
39504: IFFALSE 39521
// bpoints := bpoints * 1.1 ;
39506: LD_ADDR_VAR 0 10
39510: PUSH
39511: LD_VAR 0 10
39515: PUSH
39516: LD_REAL  1.10000000000000E+0000
39519: MUL
39520: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
39521: LD_ADDR_VAR 0 10
39525: PUSH
39526: LD_VAR 0 10
39530: PUSH
39531: LD_VAR 0 6
39535: PPUSH
39536: LD_INT 1
39538: PPUSH
39539: CALL_OW 259
39543: PUSH
39544: LD_REAL  1.15000000000000E+0000
39547: MUL
39548: MUL
39549: ST_TO_ADDR
// end ; unit_vehicle :
39550: GO 40374
39552: LD_INT 2
39554: DOUBLE
39555: EQUAL
39556: IFTRUE 39560
39558: GO 40362
39560: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
39561: LD_VAR 0 6
39565: PPUSH
39566: CALL_OW 264
39570: PUSH
39571: LD_INT 2
39573: PUSH
39574: LD_INT 42
39576: PUSH
39577: LD_INT 24
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: LIST
39584: IN
39585: IFFALSE 39606
// points := [ 25 , 5 , 3 ] ;
39587: LD_ADDR_VAR 0 9
39591: PUSH
39592: LD_INT 25
39594: PUSH
39595: LD_INT 5
39597: PUSH
39598: LD_INT 3
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: LIST
39605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
39606: LD_VAR 0 6
39610: PPUSH
39611: CALL_OW 264
39615: PUSH
39616: LD_INT 4
39618: PUSH
39619: LD_INT 43
39621: PUSH
39622: LD_INT 25
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: LIST
39629: IN
39630: IFFALSE 39651
// points := [ 40 , 15 , 5 ] ;
39632: LD_ADDR_VAR 0 9
39636: PUSH
39637: LD_INT 40
39639: PUSH
39640: LD_INT 15
39642: PUSH
39643: LD_INT 5
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: LIST
39650: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
39651: LD_VAR 0 6
39655: PPUSH
39656: CALL_OW 264
39660: PUSH
39661: LD_INT 3
39663: PUSH
39664: LD_INT 23
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: IN
39671: IFFALSE 39692
// points := [ 7 , 25 , 8 ] ;
39673: LD_ADDR_VAR 0 9
39677: PUSH
39678: LD_INT 7
39680: PUSH
39681: LD_INT 25
39683: PUSH
39684: LD_INT 8
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: LIST
39691: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
39692: LD_VAR 0 6
39696: PPUSH
39697: CALL_OW 264
39701: PUSH
39702: LD_INT 5
39704: PUSH
39705: LD_INT 27
39707: PUSH
39708: LD_INT 44
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: LIST
39715: IN
39716: IFFALSE 39737
// points := [ 14 , 50 , 16 ] ;
39718: LD_ADDR_VAR 0 9
39722: PUSH
39723: LD_INT 14
39725: PUSH
39726: LD_INT 50
39728: PUSH
39729: LD_INT 16
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: LIST
39736: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
39737: LD_VAR 0 6
39741: PPUSH
39742: CALL_OW 264
39746: PUSH
39747: LD_INT 6
39749: PUSH
39750: LD_INT 46
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: IN
39757: IFFALSE 39778
// points := [ 32 , 120 , 70 ] ;
39759: LD_ADDR_VAR 0 9
39763: PUSH
39764: LD_INT 32
39766: PUSH
39767: LD_INT 120
39769: PUSH
39770: LD_INT 70
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: LIST
39777: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
39778: LD_VAR 0 6
39782: PPUSH
39783: CALL_OW 264
39787: PUSH
39788: LD_INT 7
39790: PUSH
39791: LD_INT 28
39793: PUSH
39794: LD_INT 45
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: LIST
39801: IN
39802: IFFALSE 39823
// points := [ 35 , 20 , 45 ] ;
39804: LD_ADDR_VAR 0 9
39808: PUSH
39809: LD_INT 35
39811: PUSH
39812: LD_INT 20
39814: PUSH
39815: LD_INT 45
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: LIST
39822: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
39823: LD_VAR 0 6
39827: PPUSH
39828: CALL_OW 264
39832: PUSH
39833: LD_INT 47
39835: PUSH
39836: EMPTY
39837: LIST
39838: IN
39839: IFFALSE 39860
// points := [ 67 , 45 , 75 ] ;
39841: LD_ADDR_VAR 0 9
39845: PUSH
39846: LD_INT 67
39848: PUSH
39849: LD_INT 45
39851: PUSH
39852: LD_INT 75
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: LIST
39859: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
39860: LD_VAR 0 6
39864: PPUSH
39865: CALL_OW 264
39869: PUSH
39870: LD_INT 26
39872: PUSH
39873: EMPTY
39874: LIST
39875: IN
39876: IFFALSE 39897
// points := [ 120 , 30 , 80 ] ;
39878: LD_ADDR_VAR 0 9
39882: PUSH
39883: LD_INT 120
39885: PUSH
39886: LD_INT 30
39888: PUSH
39889: LD_INT 80
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: LIST
39896: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
39897: LD_VAR 0 6
39901: PPUSH
39902: CALL_OW 264
39906: PUSH
39907: LD_INT 22
39909: PUSH
39910: EMPTY
39911: LIST
39912: IN
39913: IFFALSE 39934
// points := [ 40 , 1 , 1 ] ;
39915: LD_ADDR_VAR 0 9
39919: PUSH
39920: LD_INT 40
39922: PUSH
39923: LD_INT 1
39925: PUSH
39926: LD_INT 1
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: LIST
39933: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
39934: LD_VAR 0 6
39938: PPUSH
39939: CALL_OW 264
39943: PUSH
39944: LD_INT 29
39946: PUSH
39947: EMPTY
39948: LIST
39949: IN
39950: IFFALSE 39971
// points := [ 70 , 200 , 400 ] ;
39952: LD_ADDR_VAR 0 9
39956: PUSH
39957: LD_INT 70
39959: PUSH
39960: LD_INT 200
39962: PUSH
39963: LD_INT 400
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: LIST
39970: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
39971: LD_VAR 0 6
39975: PPUSH
39976: CALL_OW 264
39980: PUSH
39981: LD_INT 14
39983: PUSH
39984: LD_INT 53
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: IN
39991: IFFALSE 40012
// points := [ 40 , 10 , 20 ] ;
39993: LD_ADDR_VAR 0 9
39997: PUSH
39998: LD_INT 40
40000: PUSH
40001: LD_INT 10
40003: PUSH
40004: LD_INT 20
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: LIST
40011: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
40012: LD_VAR 0 6
40016: PPUSH
40017: CALL_OW 264
40021: PUSH
40022: LD_INT 9
40024: PUSH
40025: EMPTY
40026: LIST
40027: IN
40028: IFFALSE 40049
// points := [ 5 , 70 , 20 ] ;
40030: LD_ADDR_VAR 0 9
40034: PUSH
40035: LD_INT 5
40037: PUSH
40038: LD_INT 70
40040: PUSH
40041: LD_INT 20
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: LIST
40048: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
40049: LD_VAR 0 6
40053: PPUSH
40054: CALL_OW 264
40058: PUSH
40059: LD_INT 10
40061: PUSH
40062: EMPTY
40063: LIST
40064: IN
40065: IFFALSE 40086
// points := [ 35 , 110 , 70 ] ;
40067: LD_ADDR_VAR 0 9
40071: PUSH
40072: LD_INT 35
40074: PUSH
40075: LD_INT 110
40077: PUSH
40078: LD_INT 70
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: LIST
40085: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
40086: LD_VAR 0 6
40090: PPUSH
40091: CALL_OW 265
40095: PUSH
40096: LD_INT 25
40098: EQUAL
40099: IFFALSE 40120
// points := [ 80 , 65 , 100 ] ;
40101: LD_ADDR_VAR 0 9
40105: PUSH
40106: LD_INT 80
40108: PUSH
40109: LD_INT 65
40111: PUSH
40112: LD_INT 100
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: LIST
40119: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
40120: LD_VAR 0 6
40124: PPUSH
40125: CALL_OW 263
40129: PUSH
40130: LD_INT 1
40132: EQUAL
40133: IFFALSE 40168
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
40135: LD_ADDR_VAR 0 10
40139: PUSH
40140: LD_VAR 0 10
40144: PUSH
40145: LD_VAR 0 6
40149: PPUSH
40150: CALL_OW 311
40154: PPUSH
40155: LD_INT 3
40157: PPUSH
40158: CALL_OW 259
40162: PUSH
40163: LD_INT 4
40165: MUL
40166: MUL
40167: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
40168: LD_VAR 0 6
40172: PPUSH
40173: CALL_OW 263
40177: PUSH
40178: LD_INT 2
40180: EQUAL
40181: IFFALSE 40232
// begin j := IsControledBy ( i ) ;
40183: LD_ADDR_VAR 0 7
40187: PUSH
40188: LD_VAR 0 6
40192: PPUSH
40193: CALL_OW 312
40197: ST_TO_ADDR
// if j then
40198: LD_VAR 0 7
40202: IFFALSE 40232
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
40204: LD_ADDR_VAR 0 10
40208: PUSH
40209: LD_VAR 0 10
40213: PUSH
40214: LD_VAR 0 7
40218: PPUSH
40219: LD_INT 3
40221: PPUSH
40222: CALL_OW 259
40226: PUSH
40227: LD_INT 3
40229: MUL
40230: MUL
40231: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
40232: LD_VAR 0 6
40236: PPUSH
40237: CALL_OW 264
40241: PUSH
40242: LD_INT 5
40244: PUSH
40245: LD_INT 6
40247: PUSH
40248: LD_INT 46
40250: PUSH
40251: LD_INT 44
40253: PUSH
40254: LD_INT 47
40256: PUSH
40257: LD_INT 45
40259: PUSH
40260: LD_INT 28
40262: PUSH
40263: LD_INT 7
40265: PUSH
40266: LD_INT 27
40268: PUSH
40269: LD_INT 29
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: LIST
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: IN
40284: PUSH
40285: LD_VAR 0 1
40289: PPUSH
40290: LD_INT 52
40292: PPUSH
40293: CALL_OW 321
40297: PUSH
40298: LD_INT 2
40300: EQUAL
40301: AND
40302: IFFALSE 40319
// bpoints := bpoints * 1.2 ;
40304: LD_ADDR_VAR 0 10
40308: PUSH
40309: LD_VAR 0 10
40313: PUSH
40314: LD_REAL  1.20000000000000E+0000
40317: MUL
40318: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
40319: LD_VAR 0 6
40323: PPUSH
40324: CALL_OW 264
40328: PUSH
40329: LD_INT 6
40331: PUSH
40332: LD_INT 46
40334: PUSH
40335: LD_INT 47
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: LIST
40342: IN
40343: IFFALSE 40360
// bpoints := bpoints * 1.2 ;
40345: LD_ADDR_VAR 0 10
40349: PUSH
40350: LD_VAR 0 10
40354: PUSH
40355: LD_REAL  1.20000000000000E+0000
40358: MUL
40359: ST_TO_ADDR
// end ; unit_building :
40360: GO 40374
40362: LD_INT 3
40364: DOUBLE
40365: EQUAL
40366: IFTRUE 40370
40368: GO 40373
40370: POP
// ; end ;
40371: GO 40374
40373: POP
// for j = 1 to 3 do
40374: LD_ADDR_VAR 0 7
40378: PUSH
40379: DOUBLE
40380: LD_INT 1
40382: DEC
40383: ST_TO_ADDR
40384: LD_INT 3
40386: PUSH
40387: FOR_TO
40388: IFFALSE 40441
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
40390: LD_ADDR_VAR 0 5
40394: PUSH
40395: LD_VAR 0 5
40399: PPUSH
40400: LD_VAR 0 7
40404: PPUSH
40405: LD_VAR 0 5
40409: PUSH
40410: LD_VAR 0 7
40414: ARRAY
40415: PUSH
40416: LD_VAR 0 9
40420: PUSH
40421: LD_VAR 0 7
40425: ARRAY
40426: PUSH
40427: LD_VAR 0 10
40431: MUL
40432: PLUS
40433: PPUSH
40434: CALL_OW 1
40438: ST_TO_ADDR
40439: GO 40387
40441: POP
40442: POP
// end ;
40443: GO 38926
40445: POP
40446: POP
// result := Replace ( result , 4 , tmp ) ;
40447: LD_ADDR_VAR 0 5
40451: PUSH
40452: LD_VAR 0 5
40456: PPUSH
40457: LD_INT 4
40459: PPUSH
40460: LD_VAR 0 8
40464: PPUSH
40465: CALL_OW 1
40469: ST_TO_ADDR
// end ;
40470: LD_VAR 0 5
40474: RET
// export function DangerAtRange ( unit , range ) ; begin
40475: LD_INT 0
40477: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
40478: LD_ADDR_VAR 0 3
40482: PUSH
40483: LD_VAR 0 1
40487: PPUSH
40488: CALL_OW 255
40492: PPUSH
40493: LD_VAR 0 1
40497: PPUSH
40498: CALL_OW 250
40502: PPUSH
40503: LD_VAR 0 1
40507: PPUSH
40508: CALL_OW 251
40512: PPUSH
40513: LD_VAR 0 2
40517: PPUSH
40518: CALL 38778 0 4
40522: ST_TO_ADDR
// end ;
40523: LD_VAR 0 3
40527: RET
// export function DangerInArea ( side , area ) ; begin
40528: LD_INT 0
40530: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
40531: LD_ADDR_VAR 0 3
40535: PUSH
40536: LD_VAR 0 2
40540: PPUSH
40541: LD_INT 81
40543: PUSH
40544: LD_VAR 0 1
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PPUSH
40553: CALL_OW 70
40557: ST_TO_ADDR
// end ;
40558: LD_VAR 0 3
40562: RET
// export function IsExtension ( b ) ; begin
40563: LD_INT 0
40565: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
40566: LD_ADDR_VAR 0 2
40570: PUSH
40571: LD_VAR 0 1
40575: PUSH
40576: LD_INT 23
40578: PUSH
40579: LD_INT 20
40581: PUSH
40582: LD_INT 22
40584: PUSH
40585: LD_INT 17
40587: PUSH
40588: LD_INT 24
40590: PUSH
40591: LD_INT 21
40593: PUSH
40594: LD_INT 19
40596: PUSH
40597: LD_INT 16
40599: PUSH
40600: LD_INT 25
40602: PUSH
40603: LD_INT 18
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: IN
40618: ST_TO_ADDR
// end ;
40619: LD_VAR 0 2
40623: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
40624: LD_INT 0
40626: PPUSH
40627: PPUSH
40628: PPUSH
// result := [ ] ;
40629: LD_ADDR_VAR 0 3
40633: PUSH
40634: EMPTY
40635: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
40636: LD_ADDR_VAR 0 4
40640: PUSH
40641: LD_VAR 0 2
40645: PPUSH
40646: LD_INT 21
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PPUSH
40656: CALL_OW 70
40660: ST_TO_ADDR
// if not tmp then
40661: LD_VAR 0 4
40665: NOT
40666: IFFALSE 40670
// exit ;
40668: GO 40728
// for i in tmp do
40670: LD_ADDR_VAR 0 5
40674: PUSH
40675: LD_VAR 0 4
40679: PUSH
40680: FOR_IN
40681: IFFALSE 40716
// if GetBase ( i ) <> base then
40683: LD_VAR 0 5
40687: PPUSH
40688: CALL_OW 274
40692: PUSH
40693: LD_VAR 0 1
40697: NONEQUAL
40698: IFFALSE 40714
// ComLinkToBase ( base , i ) ;
40700: LD_VAR 0 1
40704: PPUSH
40705: LD_VAR 0 5
40709: PPUSH
40710: CALL_OW 169
40714: GO 40680
40716: POP
40717: POP
// result := tmp ;
40718: LD_ADDR_VAR 0 3
40722: PUSH
40723: LD_VAR 0 4
40727: ST_TO_ADDR
// end ;
40728: LD_VAR 0 3
40732: RET
// export function ComComplete ( unit , b ) ; var i ; begin
40733: LD_INT 0
40735: PPUSH
40736: PPUSH
// if BuildingStatus ( b ) = bs_build then
40737: LD_VAR 0 2
40741: PPUSH
40742: CALL_OW 461
40746: PUSH
40747: LD_INT 1
40749: EQUAL
40750: IFFALSE 40810
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
40752: LD_VAR 0 1
40756: PPUSH
40757: LD_STRING h
40759: PUSH
40760: LD_VAR 0 2
40764: PPUSH
40765: CALL_OW 250
40769: PUSH
40770: LD_VAR 0 2
40774: PPUSH
40775: CALL_OW 251
40779: PUSH
40780: LD_VAR 0 2
40784: PUSH
40785: LD_INT 0
40787: PUSH
40788: LD_INT 0
40790: PUSH
40791: LD_INT 0
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: LIST
40798: LIST
40799: LIST
40800: LIST
40801: LIST
40802: PUSH
40803: EMPTY
40804: LIST
40805: PPUSH
40806: CALL_OW 446
// end ;
40810: LD_VAR 0 3
40814: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
40815: LD_INT 0
40817: PPUSH
40818: PPUSH
40819: PPUSH
40820: PPUSH
40821: PPUSH
40822: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
40823: LD_VAR 0 1
40827: NOT
40828: PUSH
40829: LD_VAR 0 1
40833: PPUSH
40834: CALL_OW 263
40838: PUSH
40839: LD_INT 2
40841: EQUAL
40842: NOT
40843: OR
40844: IFFALSE 40848
// exit ;
40846: GO 41164
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
40848: LD_ADDR_VAR 0 6
40852: PUSH
40853: LD_INT 22
40855: PUSH
40856: LD_VAR 0 1
40860: PPUSH
40861: CALL_OW 255
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 2
40872: PUSH
40873: LD_INT 30
40875: PUSH
40876: LD_INT 36
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 34
40885: PUSH
40886: LD_INT 31
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PPUSH
40902: CALL_OW 69
40906: ST_TO_ADDR
// if not tmp then
40907: LD_VAR 0 6
40911: NOT
40912: IFFALSE 40916
// exit ;
40914: GO 41164
// result := [ ] ;
40916: LD_ADDR_VAR 0 2
40920: PUSH
40921: EMPTY
40922: ST_TO_ADDR
// for i in tmp do
40923: LD_ADDR_VAR 0 3
40927: PUSH
40928: LD_VAR 0 6
40932: PUSH
40933: FOR_IN
40934: IFFALSE 41005
// begin t := UnitsInside ( i ) ;
40936: LD_ADDR_VAR 0 4
40940: PUSH
40941: LD_VAR 0 3
40945: PPUSH
40946: CALL_OW 313
40950: ST_TO_ADDR
// if t then
40951: LD_VAR 0 4
40955: IFFALSE 41003
// for j in t do
40957: LD_ADDR_VAR 0 7
40961: PUSH
40962: LD_VAR 0 4
40966: PUSH
40967: FOR_IN
40968: IFFALSE 41001
// result := Insert ( result , result + 1 , j ) ;
40970: LD_ADDR_VAR 0 2
40974: PUSH
40975: LD_VAR 0 2
40979: PPUSH
40980: LD_VAR 0 2
40984: PUSH
40985: LD_INT 1
40987: PLUS
40988: PPUSH
40989: LD_VAR 0 7
40993: PPUSH
40994: CALL_OW 2
40998: ST_TO_ADDR
40999: GO 40967
41001: POP
41002: POP
// end ;
41003: GO 40933
41005: POP
41006: POP
// if not result then
41007: LD_VAR 0 2
41011: NOT
41012: IFFALSE 41016
// exit ;
41014: GO 41164
// mech := result [ 1 ] ;
41016: LD_ADDR_VAR 0 5
41020: PUSH
41021: LD_VAR 0 2
41025: PUSH
41026: LD_INT 1
41028: ARRAY
41029: ST_TO_ADDR
// if result > 1 then
41030: LD_VAR 0 2
41034: PUSH
41035: LD_INT 1
41037: GREATER
41038: IFFALSE 41150
// for i = 2 to result do
41040: LD_ADDR_VAR 0 3
41044: PUSH
41045: DOUBLE
41046: LD_INT 2
41048: DEC
41049: ST_TO_ADDR
41050: LD_VAR 0 2
41054: PUSH
41055: FOR_TO
41056: IFFALSE 41148
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
41058: LD_ADDR_VAR 0 4
41062: PUSH
41063: LD_VAR 0 2
41067: PUSH
41068: LD_VAR 0 3
41072: ARRAY
41073: PPUSH
41074: LD_INT 3
41076: PPUSH
41077: CALL_OW 259
41081: PUSH
41082: LD_VAR 0 2
41086: PUSH
41087: LD_VAR 0 3
41091: ARRAY
41092: PPUSH
41093: CALL_OW 432
41097: MINUS
41098: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
41099: LD_VAR 0 4
41103: PUSH
41104: LD_VAR 0 5
41108: PPUSH
41109: LD_INT 3
41111: PPUSH
41112: CALL_OW 259
41116: PUSH
41117: LD_VAR 0 5
41121: PPUSH
41122: CALL_OW 432
41126: MINUS
41127: GREATEREQUAL
41128: IFFALSE 41146
// mech := result [ i ] ;
41130: LD_ADDR_VAR 0 5
41134: PUSH
41135: LD_VAR 0 2
41139: PUSH
41140: LD_VAR 0 3
41144: ARRAY
41145: ST_TO_ADDR
// end ;
41146: GO 41055
41148: POP
41149: POP
// ComLinkTo ( vehicle , mech ) ;
41150: LD_VAR 0 1
41154: PPUSH
41155: LD_VAR 0 5
41159: PPUSH
41160: CALL_OW 135
// end ;
41164: LD_VAR 0 2
41168: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
41169: LD_INT 0
41171: PPUSH
41172: PPUSH
41173: PPUSH
41174: PPUSH
41175: PPUSH
41176: PPUSH
41177: PPUSH
41178: PPUSH
41179: PPUSH
41180: PPUSH
41181: PPUSH
41182: PPUSH
41183: PPUSH
// result := [ ] ;
41184: LD_ADDR_VAR 0 7
41188: PUSH
41189: EMPTY
41190: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
41191: LD_VAR 0 1
41195: PPUSH
41196: CALL_OW 266
41200: PUSH
41201: LD_INT 0
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: IN
41211: NOT
41212: IFFALSE 41216
// exit ;
41214: GO 42847
// if name then
41216: LD_VAR 0 3
41220: IFFALSE 41236
// SetBName ( base_dep , name ) ;
41222: LD_VAR 0 1
41226: PPUSH
41227: LD_VAR 0 3
41231: PPUSH
41232: CALL_OW 500
// base := GetBase ( base_dep ) ;
41236: LD_ADDR_VAR 0 15
41240: PUSH
41241: LD_VAR 0 1
41245: PPUSH
41246: CALL_OW 274
41250: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
41251: LD_ADDR_VAR 0 16
41255: PUSH
41256: LD_VAR 0 1
41260: PPUSH
41261: CALL_OW 255
41265: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
41266: LD_ADDR_VAR 0 17
41270: PUSH
41271: LD_VAR 0 1
41275: PPUSH
41276: CALL_OW 248
41280: ST_TO_ADDR
// if sources then
41281: LD_VAR 0 5
41285: IFFALSE 41332
// for i = 1 to 3 do
41287: LD_ADDR_VAR 0 8
41291: PUSH
41292: DOUBLE
41293: LD_INT 1
41295: DEC
41296: ST_TO_ADDR
41297: LD_INT 3
41299: PUSH
41300: FOR_TO
41301: IFFALSE 41330
// AddResourceType ( base , i , sources [ i ] ) ;
41303: LD_VAR 0 15
41307: PPUSH
41308: LD_VAR 0 8
41312: PPUSH
41313: LD_VAR 0 5
41317: PUSH
41318: LD_VAR 0 8
41322: ARRAY
41323: PPUSH
41324: CALL_OW 276
41328: GO 41300
41330: POP
41331: POP
// buildings := GetBaseBuildings ( base , area ) ;
41332: LD_ADDR_VAR 0 18
41336: PUSH
41337: LD_VAR 0 15
41341: PPUSH
41342: LD_VAR 0 2
41346: PPUSH
41347: CALL 40624 0 2
41351: ST_TO_ADDR
// InitHc ;
41352: CALL_OW 19
// InitUc ;
41356: CALL_OW 18
// uc_side := side ;
41360: LD_ADDR_OWVAR 20
41364: PUSH
41365: LD_VAR 0 16
41369: ST_TO_ADDR
// uc_nation := nation ;
41370: LD_ADDR_OWVAR 21
41374: PUSH
41375: LD_VAR 0 17
41379: ST_TO_ADDR
// if buildings then
41380: LD_VAR 0 18
41384: IFFALSE 42706
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
41386: LD_ADDR_VAR 0 19
41390: PUSH
41391: LD_VAR 0 18
41395: PPUSH
41396: LD_INT 2
41398: PUSH
41399: LD_INT 30
41401: PUSH
41402: LD_INT 29
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 30
41411: PUSH
41412: LD_INT 30
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: LIST
41423: PPUSH
41424: CALL_OW 72
41428: ST_TO_ADDR
// if tmp then
41429: LD_VAR 0 19
41433: IFFALSE 41481
// for i in tmp do
41435: LD_ADDR_VAR 0 8
41439: PUSH
41440: LD_VAR 0 19
41444: PUSH
41445: FOR_IN
41446: IFFALSE 41479
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
41448: LD_VAR 0 8
41452: PPUSH
41453: CALL_OW 250
41457: PPUSH
41458: LD_VAR 0 8
41462: PPUSH
41463: CALL_OW 251
41467: PPUSH
41468: LD_VAR 0 16
41472: PPUSH
41473: CALL_OW 441
41477: GO 41445
41479: POP
41480: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
41481: LD_VAR 0 18
41485: PPUSH
41486: LD_INT 2
41488: PUSH
41489: LD_INT 30
41491: PUSH
41492: LD_INT 32
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 30
41501: PUSH
41502: LD_INT 33
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: LIST
41513: PPUSH
41514: CALL_OW 72
41518: IFFALSE 41606
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
41520: LD_ADDR_VAR 0 8
41524: PUSH
41525: LD_VAR 0 18
41529: PPUSH
41530: LD_INT 2
41532: PUSH
41533: LD_INT 30
41535: PUSH
41536: LD_INT 32
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: PUSH
41543: LD_INT 30
41545: PUSH
41546: LD_INT 33
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: LIST
41557: PPUSH
41558: CALL_OW 72
41562: PUSH
41563: FOR_IN
41564: IFFALSE 41604
// begin if not GetBWeapon ( i ) then
41566: LD_VAR 0 8
41570: PPUSH
41571: CALL_OW 269
41575: NOT
41576: IFFALSE 41602
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
41578: LD_VAR 0 8
41582: PPUSH
41583: LD_VAR 0 8
41587: PPUSH
41588: LD_VAR 0 2
41592: PPUSH
41593: CALL 42852 0 2
41597: PPUSH
41598: CALL_OW 431
// end ;
41602: GO 41563
41604: POP
41605: POP
// end ; for i = 1 to personel do
41606: LD_ADDR_VAR 0 8
41610: PUSH
41611: DOUBLE
41612: LD_INT 1
41614: DEC
41615: ST_TO_ADDR
41616: LD_VAR 0 6
41620: PUSH
41621: FOR_TO
41622: IFFALSE 42686
// begin if i > 4 then
41624: LD_VAR 0 8
41628: PUSH
41629: LD_INT 4
41631: GREATER
41632: IFFALSE 41636
// break ;
41634: GO 42686
// case i of 1 :
41636: LD_VAR 0 8
41640: PUSH
41641: LD_INT 1
41643: DOUBLE
41644: EQUAL
41645: IFTRUE 41649
41647: GO 41729
41649: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
41650: LD_ADDR_VAR 0 12
41654: PUSH
41655: LD_VAR 0 18
41659: PPUSH
41660: LD_INT 22
41662: PUSH
41663: LD_VAR 0 16
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 58
41674: PUSH
41675: EMPTY
41676: LIST
41677: PUSH
41678: LD_INT 2
41680: PUSH
41681: LD_INT 30
41683: PUSH
41684: LD_INT 32
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: PUSH
41691: LD_INT 30
41693: PUSH
41694: LD_INT 4
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 30
41703: PUSH
41704: LD_INT 5
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: LIST
41715: LIST
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: LIST
41721: PPUSH
41722: CALL_OW 72
41726: ST_TO_ADDR
41727: GO 41951
41729: LD_INT 2
41731: DOUBLE
41732: EQUAL
41733: IFTRUE 41737
41735: GO 41799
41737: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
41738: LD_ADDR_VAR 0 12
41742: PUSH
41743: LD_VAR 0 18
41747: PPUSH
41748: LD_INT 22
41750: PUSH
41751: LD_VAR 0 16
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 2
41762: PUSH
41763: LD_INT 30
41765: PUSH
41766: LD_INT 0
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 30
41775: PUSH
41776: LD_INT 1
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: LIST
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PPUSH
41792: CALL_OW 72
41796: ST_TO_ADDR
41797: GO 41951
41799: LD_INT 3
41801: DOUBLE
41802: EQUAL
41803: IFTRUE 41807
41805: GO 41869
41807: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
41808: LD_ADDR_VAR 0 12
41812: PUSH
41813: LD_VAR 0 18
41817: PPUSH
41818: LD_INT 22
41820: PUSH
41821: LD_VAR 0 16
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 2
41832: PUSH
41833: LD_INT 30
41835: PUSH
41836: LD_INT 2
41838: PUSH
41839: EMPTY
41840: LIST
41841: LIST
41842: PUSH
41843: LD_INT 30
41845: PUSH
41846: LD_INT 3
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PPUSH
41862: CALL_OW 72
41866: ST_TO_ADDR
41867: GO 41951
41869: LD_INT 4
41871: DOUBLE
41872: EQUAL
41873: IFTRUE 41877
41875: GO 41950
41877: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
41878: LD_ADDR_VAR 0 12
41882: PUSH
41883: LD_VAR 0 18
41887: PPUSH
41888: LD_INT 22
41890: PUSH
41891: LD_VAR 0 16
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 2
41902: PUSH
41903: LD_INT 30
41905: PUSH
41906: LD_INT 6
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 30
41915: PUSH
41916: LD_INT 7
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 30
41925: PUSH
41926: LD_INT 8
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: LIST
41937: LIST
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PPUSH
41943: CALL_OW 72
41947: ST_TO_ADDR
41948: GO 41951
41950: POP
// if i = 1 then
41951: LD_VAR 0 8
41955: PUSH
41956: LD_INT 1
41958: EQUAL
41959: IFFALSE 42070
// begin tmp := [ ] ;
41961: LD_ADDR_VAR 0 19
41965: PUSH
41966: EMPTY
41967: ST_TO_ADDR
// for j in f do
41968: LD_ADDR_VAR 0 9
41972: PUSH
41973: LD_VAR 0 12
41977: PUSH
41978: FOR_IN
41979: IFFALSE 42052
// if GetBType ( j ) = b_bunker then
41981: LD_VAR 0 9
41985: PPUSH
41986: CALL_OW 266
41990: PUSH
41991: LD_INT 32
41993: EQUAL
41994: IFFALSE 42021
// tmp := Insert ( tmp , 1 , j ) else
41996: LD_ADDR_VAR 0 19
42000: PUSH
42001: LD_VAR 0 19
42005: PPUSH
42006: LD_INT 1
42008: PPUSH
42009: LD_VAR 0 9
42013: PPUSH
42014: CALL_OW 2
42018: ST_TO_ADDR
42019: GO 42050
// tmp := Insert ( tmp , tmp + 1 , j ) ;
42021: LD_ADDR_VAR 0 19
42025: PUSH
42026: LD_VAR 0 19
42030: PPUSH
42031: LD_VAR 0 19
42035: PUSH
42036: LD_INT 1
42038: PLUS
42039: PPUSH
42040: LD_VAR 0 9
42044: PPUSH
42045: CALL_OW 2
42049: ST_TO_ADDR
42050: GO 41978
42052: POP
42053: POP
// if tmp then
42054: LD_VAR 0 19
42058: IFFALSE 42070
// f := tmp ;
42060: LD_ADDR_VAR 0 12
42064: PUSH
42065: LD_VAR 0 19
42069: ST_TO_ADDR
// end ; x := personel [ i ] ;
42070: LD_ADDR_VAR 0 13
42074: PUSH
42075: LD_VAR 0 6
42079: PUSH
42080: LD_VAR 0 8
42084: ARRAY
42085: ST_TO_ADDR
// if x = - 1 then
42086: LD_VAR 0 13
42090: PUSH
42091: LD_INT 1
42093: NEG
42094: EQUAL
42095: IFFALSE 42304
// begin for j in f do
42097: LD_ADDR_VAR 0 9
42101: PUSH
42102: LD_VAR 0 12
42106: PUSH
42107: FOR_IN
42108: IFFALSE 42300
// repeat InitHc ;
42110: CALL_OW 19
// if GetBType ( j ) = b_barracks then
42114: LD_VAR 0 9
42118: PPUSH
42119: CALL_OW 266
42123: PUSH
42124: LD_INT 5
42126: EQUAL
42127: IFFALSE 42197
// begin if UnitsInside ( j ) < 3 then
42129: LD_VAR 0 9
42133: PPUSH
42134: CALL_OW 313
42138: PUSH
42139: LD_INT 3
42141: LESS
42142: IFFALSE 42178
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
42144: LD_INT 0
42146: PPUSH
42147: LD_INT 5
42149: PUSH
42150: LD_INT 8
42152: PUSH
42153: LD_INT 9
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: LIST
42160: PUSH
42161: LD_VAR 0 17
42165: ARRAY
42166: PPUSH
42167: LD_VAR 0 4
42171: PPUSH
42172: CALL_OW 380
42176: GO 42195
// PrepareHuman ( false , i , skill ) ;
42178: LD_INT 0
42180: PPUSH
42181: LD_VAR 0 8
42185: PPUSH
42186: LD_VAR 0 4
42190: PPUSH
42191: CALL_OW 380
// end else
42195: GO 42214
// PrepareHuman ( false , i , skill ) ;
42197: LD_INT 0
42199: PPUSH
42200: LD_VAR 0 8
42204: PPUSH
42205: LD_VAR 0 4
42209: PPUSH
42210: CALL_OW 380
// un := CreateHuman ;
42214: LD_ADDR_VAR 0 14
42218: PUSH
42219: CALL_OW 44
42223: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
42224: LD_ADDR_VAR 0 7
42228: PUSH
42229: LD_VAR 0 7
42233: PPUSH
42234: LD_INT 1
42236: PPUSH
42237: LD_VAR 0 14
42241: PPUSH
42242: CALL_OW 2
42246: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
42247: LD_VAR 0 14
42251: PPUSH
42252: LD_VAR 0 9
42256: PPUSH
42257: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
42261: LD_VAR 0 9
42265: PPUSH
42266: CALL_OW 313
42270: PUSH
42271: LD_INT 6
42273: EQUAL
42274: PUSH
42275: LD_VAR 0 9
42279: PPUSH
42280: CALL_OW 266
42284: PUSH
42285: LD_INT 32
42287: PUSH
42288: LD_INT 31
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: IN
42295: OR
42296: IFFALSE 42110
42298: GO 42107
42300: POP
42301: POP
// end else
42302: GO 42684
// for j = 1 to x do
42304: LD_ADDR_VAR 0 9
42308: PUSH
42309: DOUBLE
42310: LD_INT 1
42312: DEC
42313: ST_TO_ADDR
42314: LD_VAR 0 13
42318: PUSH
42319: FOR_TO
42320: IFFALSE 42682
// begin InitHc ;
42322: CALL_OW 19
// if not f then
42326: LD_VAR 0 12
42330: NOT
42331: IFFALSE 42420
// begin PrepareHuman ( false , i , skill ) ;
42333: LD_INT 0
42335: PPUSH
42336: LD_VAR 0 8
42340: PPUSH
42341: LD_VAR 0 4
42345: PPUSH
42346: CALL_OW 380
// un := CreateHuman ;
42350: LD_ADDR_VAR 0 14
42354: PUSH
42355: CALL_OW 44
42359: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
42360: LD_ADDR_VAR 0 7
42364: PUSH
42365: LD_VAR 0 7
42369: PPUSH
42370: LD_INT 1
42372: PPUSH
42373: LD_VAR 0 14
42377: PPUSH
42378: CALL_OW 2
42382: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
42383: LD_VAR 0 14
42387: PPUSH
42388: LD_VAR 0 1
42392: PPUSH
42393: CALL_OW 250
42397: PPUSH
42398: LD_VAR 0 1
42402: PPUSH
42403: CALL_OW 251
42407: PPUSH
42408: LD_INT 10
42410: PPUSH
42411: LD_INT 0
42413: PPUSH
42414: CALL_OW 50
// continue ;
42418: GO 42319
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
42420: LD_VAR 0 12
42424: PUSH
42425: LD_INT 1
42427: ARRAY
42428: PPUSH
42429: CALL_OW 313
42433: PUSH
42434: LD_VAR 0 12
42438: PUSH
42439: LD_INT 1
42441: ARRAY
42442: PPUSH
42443: CALL_OW 266
42447: PUSH
42448: LD_INT 32
42450: PUSH
42451: LD_INT 31
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: IN
42458: AND
42459: PUSH
42460: LD_VAR 0 12
42464: PUSH
42465: LD_INT 1
42467: ARRAY
42468: PPUSH
42469: CALL_OW 313
42473: PUSH
42474: LD_INT 6
42476: EQUAL
42477: OR
42478: IFFALSE 42498
// f := Delete ( f , 1 ) ;
42480: LD_ADDR_VAR 0 12
42484: PUSH
42485: LD_VAR 0 12
42489: PPUSH
42490: LD_INT 1
42492: PPUSH
42493: CALL_OW 3
42497: ST_TO_ADDR
// if not f then
42498: LD_VAR 0 12
42502: NOT
42503: IFFALSE 42521
// begin x := x + 2 ;
42505: LD_ADDR_VAR 0 13
42509: PUSH
42510: LD_VAR 0 13
42514: PUSH
42515: LD_INT 2
42517: PLUS
42518: ST_TO_ADDR
// continue ;
42519: GO 42319
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
42521: LD_VAR 0 12
42525: PUSH
42526: LD_INT 1
42528: ARRAY
42529: PPUSH
42530: CALL_OW 266
42534: PUSH
42535: LD_INT 5
42537: EQUAL
42538: IFFALSE 42612
// begin if UnitsInside ( f [ 1 ] ) < 3 then
42540: LD_VAR 0 12
42544: PUSH
42545: LD_INT 1
42547: ARRAY
42548: PPUSH
42549: CALL_OW 313
42553: PUSH
42554: LD_INT 3
42556: LESS
42557: IFFALSE 42593
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
42559: LD_INT 0
42561: PPUSH
42562: LD_INT 5
42564: PUSH
42565: LD_INT 8
42567: PUSH
42568: LD_INT 9
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: LIST
42575: PUSH
42576: LD_VAR 0 17
42580: ARRAY
42581: PPUSH
42582: LD_VAR 0 4
42586: PPUSH
42587: CALL_OW 380
42591: GO 42610
// PrepareHuman ( false , i , skill ) ;
42593: LD_INT 0
42595: PPUSH
42596: LD_VAR 0 8
42600: PPUSH
42601: LD_VAR 0 4
42605: PPUSH
42606: CALL_OW 380
// end else
42610: GO 42629
// PrepareHuman ( false , i , skill ) ;
42612: LD_INT 0
42614: PPUSH
42615: LD_VAR 0 8
42619: PPUSH
42620: LD_VAR 0 4
42624: PPUSH
42625: CALL_OW 380
// un := CreateHuman ;
42629: LD_ADDR_VAR 0 14
42633: PUSH
42634: CALL_OW 44
42638: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
42639: LD_ADDR_VAR 0 7
42643: PUSH
42644: LD_VAR 0 7
42648: PPUSH
42649: LD_INT 1
42651: PPUSH
42652: LD_VAR 0 14
42656: PPUSH
42657: CALL_OW 2
42661: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
42662: LD_VAR 0 14
42666: PPUSH
42667: LD_VAR 0 12
42671: PUSH
42672: LD_INT 1
42674: ARRAY
42675: PPUSH
42676: CALL_OW 52
// end ;
42680: GO 42319
42682: POP
42683: POP
// end ;
42684: GO 41621
42686: POP
42687: POP
// result := result ^ buildings ;
42688: LD_ADDR_VAR 0 7
42692: PUSH
42693: LD_VAR 0 7
42697: PUSH
42698: LD_VAR 0 18
42702: ADD
42703: ST_TO_ADDR
// end else
42704: GO 42847
// begin for i = 1 to personel do
42706: LD_ADDR_VAR 0 8
42710: PUSH
42711: DOUBLE
42712: LD_INT 1
42714: DEC
42715: ST_TO_ADDR
42716: LD_VAR 0 6
42720: PUSH
42721: FOR_TO
42722: IFFALSE 42845
// begin if i > 4 then
42724: LD_VAR 0 8
42728: PUSH
42729: LD_INT 4
42731: GREATER
42732: IFFALSE 42736
// break ;
42734: GO 42845
// x := personel [ i ] ;
42736: LD_ADDR_VAR 0 13
42740: PUSH
42741: LD_VAR 0 6
42745: PUSH
42746: LD_VAR 0 8
42750: ARRAY
42751: ST_TO_ADDR
// if x = - 1 then
42752: LD_VAR 0 13
42756: PUSH
42757: LD_INT 1
42759: NEG
42760: EQUAL
42761: IFFALSE 42765
// continue ;
42763: GO 42721
// PrepareHuman ( false , i , skill ) ;
42765: LD_INT 0
42767: PPUSH
42768: LD_VAR 0 8
42772: PPUSH
42773: LD_VAR 0 4
42777: PPUSH
42778: CALL_OW 380
// un := CreateHuman ;
42782: LD_ADDR_VAR 0 14
42786: PUSH
42787: CALL_OW 44
42791: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
42792: LD_VAR 0 14
42796: PPUSH
42797: LD_VAR 0 1
42801: PPUSH
42802: CALL_OW 250
42806: PPUSH
42807: LD_VAR 0 1
42811: PPUSH
42812: CALL_OW 251
42816: PPUSH
42817: LD_INT 10
42819: PPUSH
42820: LD_INT 0
42822: PPUSH
42823: CALL_OW 50
// result := result ^ un ;
42827: LD_ADDR_VAR 0 7
42831: PUSH
42832: LD_VAR 0 7
42836: PUSH
42837: LD_VAR 0 14
42841: ADD
42842: ST_TO_ADDR
// end ;
42843: GO 42721
42845: POP
42846: POP
// end ; end ;
42847: LD_VAR 0 7
42851: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
42852: LD_INT 0
42854: PPUSH
42855: PPUSH
42856: PPUSH
42857: PPUSH
42858: PPUSH
42859: PPUSH
42860: PPUSH
42861: PPUSH
42862: PPUSH
42863: PPUSH
42864: PPUSH
42865: PPUSH
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
// result := false ;
42870: LD_ADDR_VAR 0 3
42874: PUSH
42875: LD_INT 0
42877: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
42878: LD_VAR 0 1
42882: NOT
42883: PUSH
42884: LD_VAR 0 1
42888: PPUSH
42889: CALL_OW 266
42893: PUSH
42894: LD_INT 32
42896: PUSH
42897: LD_INT 33
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: IN
42904: NOT
42905: OR
42906: IFFALSE 42910
// exit ;
42908: GO 44046
// nat := GetNation ( tower ) ;
42910: LD_ADDR_VAR 0 12
42914: PUSH
42915: LD_VAR 0 1
42919: PPUSH
42920: CALL_OW 248
42924: ST_TO_ADDR
// side := GetSide ( tower ) ;
42925: LD_ADDR_VAR 0 16
42929: PUSH
42930: LD_VAR 0 1
42934: PPUSH
42935: CALL_OW 255
42939: ST_TO_ADDR
// x := GetX ( tower ) ;
42940: LD_ADDR_VAR 0 10
42944: PUSH
42945: LD_VAR 0 1
42949: PPUSH
42950: CALL_OW 250
42954: ST_TO_ADDR
// y := GetY ( tower ) ;
42955: LD_ADDR_VAR 0 11
42959: PUSH
42960: LD_VAR 0 1
42964: PPUSH
42965: CALL_OW 251
42969: ST_TO_ADDR
// if not x or not y then
42970: LD_VAR 0 10
42974: NOT
42975: PUSH
42976: LD_VAR 0 11
42980: NOT
42981: OR
42982: IFFALSE 42986
// exit ;
42984: GO 44046
// weapon := 0 ;
42986: LD_ADDR_VAR 0 18
42990: PUSH
42991: LD_INT 0
42993: ST_TO_ADDR
// fac_list := [ ] ;
42994: LD_ADDR_VAR 0 17
42998: PUSH
42999: EMPTY
43000: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
43001: LD_ADDR_VAR 0 6
43005: PUSH
43006: LD_VAR 0 1
43010: PPUSH
43011: CALL_OW 274
43015: PPUSH
43016: LD_VAR 0 2
43020: PPUSH
43021: CALL 40624 0 2
43025: PPUSH
43026: LD_INT 30
43028: PUSH
43029: LD_INT 3
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PPUSH
43036: CALL_OW 72
43040: ST_TO_ADDR
// if not factories then
43041: LD_VAR 0 6
43045: NOT
43046: IFFALSE 43050
// exit ;
43048: GO 44046
// for i in factories do
43050: LD_ADDR_VAR 0 8
43054: PUSH
43055: LD_VAR 0 6
43059: PUSH
43060: FOR_IN
43061: IFFALSE 43086
// fac_list := fac_list union AvailableWeaponList ( i ) ;
43063: LD_ADDR_VAR 0 17
43067: PUSH
43068: LD_VAR 0 17
43072: PUSH
43073: LD_VAR 0 8
43077: PPUSH
43078: CALL_OW 478
43082: UNION
43083: ST_TO_ADDR
43084: GO 43060
43086: POP
43087: POP
// if not fac_list then
43088: LD_VAR 0 17
43092: NOT
43093: IFFALSE 43097
// exit ;
43095: GO 44046
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
43097: LD_ADDR_VAR 0 5
43101: PUSH
43102: LD_INT 4
43104: PUSH
43105: LD_INT 5
43107: PUSH
43108: LD_INT 9
43110: PUSH
43111: LD_INT 10
43113: PUSH
43114: LD_INT 6
43116: PUSH
43117: LD_INT 7
43119: PUSH
43120: LD_INT 11
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: LIST
43127: LIST
43128: LIST
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 27
43134: PUSH
43135: LD_INT 28
43137: PUSH
43138: LD_INT 26
43140: PUSH
43141: LD_INT 30
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 43
43152: PUSH
43153: LD_INT 44
43155: PUSH
43156: LD_INT 46
43158: PUSH
43159: LD_INT 45
43161: PUSH
43162: LD_INT 47
43164: PUSH
43165: LD_INT 49
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: LIST
43180: PUSH
43181: LD_VAR 0 12
43185: ARRAY
43186: ST_TO_ADDR
// for i in list do
43187: LD_ADDR_VAR 0 8
43191: PUSH
43192: LD_VAR 0 5
43196: PUSH
43197: FOR_IN
43198: IFFALSE 43231
// if not i in fac_list then
43200: LD_VAR 0 8
43204: PUSH
43205: LD_VAR 0 17
43209: IN
43210: NOT
43211: IFFALSE 43229
// list := list diff i ;
43213: LD_ADDR_VAR 0 5
43217: PUSH
43218: LD_VAR 0 5
43222: PUSH
43223: LD_VAR 0 8
43227: DIFF
43228: ST_TO_ADDR
43229: GO 43197
43231: POP
43232: POP
// if not list then
43233: LD_VAR 0 5
43237: NOT
43238: IFFALSE 43242
// exit ;
43240: GO 44046
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
43242: LD_VAR 0 12
43246: PUSH
43247: LD_INT 3
43249: EQUAL
43250: PUSH
43251: LD_INT 49
43253: PUSH
43254: LD_VAR 0 5
43258: IN
43259: AND
43260: PUSH
43261: LD_INT 31
43263: PPUSH
43264: LD_VAR 0 16
43268: PPUSH
43269: CALL_OW 321
43273: PUSH
43274: LD_INT 2
43276: EQUAL
43277: AND
43278: IFFALSE 43338
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
43280: LD_INT 22
43282: PUSH
43283: LD_VAR 0 16
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 35
43294: PUSH
43295: LD_INT 49
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: LD_INT 91
43304: PUSH
43305: LD_VAR 0 1
43309: PUSH
43310: LD_INT 10
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: LIST
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: LIST
43322: PPUSH
43323: CALL_OW 69
43327: NOT
43328: IFFALSE 43338
// weapon := ru_time_lapser ;
43330: LD_ADDR_VAR 0 18
43334: PUSH
43335: LD_INT 49
43337: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
43338: LD_VAR 0 12
43342: PUSH
43343: LD_INT 1
43345: PUSH
43346: LD_INT 2
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: IN
43353: PUSH
43354: LD_INT 11
43356: PUSH
43357: LD_VAR 0 5
43361: IN
43362: PUSH
43363: LD_INT 30
43365: PUSH
43366: LD_VAR 0 5
43370: IN
43371: OR
43372: AND
43373: PUSH
43374: LD_INT 6
43376: PPUSH
43377: LD_VAR 0 16
43381: PPUSH
43382: CALL_OW 321
43386: PUSH
43387: LD_INT 2
43389: EQUAL
43390: AND
43391: IFFALSE 43556
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
43393: LD_INT 22
43395: PUSH
43396: LD_VAR 0 16
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: LD_INT 2
43407: PUSH
43408: LD_INT 35
43410: PUSH
43411: LD_INT 11
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 35
43420: PUSH
43421: LD_INT 30
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 91
43435: PUSH
43436: LD_VAR 0 1
43440: PUSH
43441: LD_INT 18
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: LIST
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: LIST
43453: PPUSH
43454: CALL_OW 69
43458: NOT
43459: PUSH
43460: LD_INT 22
43462: PUSH
43463: LD_VAR 0 16
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 30
43477: PUSH
43478: LD_INT 32
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 30
43487: PUSH
43488: LD_INT 33
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: LIST
43499: PUSH
43500: LD_INT 91
43502: PUSH
43503: LD_VAR 0 1
43507: PUSH
43508: LD_INT 12
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: LIST
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: LIST
43520: PUSH
43521: EMPTY
43522: LIST
43523: PPUSH
43524: CALL_OW 69
43528: PUSH
43529: LD_INT 2
43531: GREATER
43532: AND
43533: IFFALSE 43556
// weapon := [ us_radar , ar_radar ] [ nat ] ;
43535: LD_ADDR_VAR 0 18
43539: PUSH
43540: LD_INT 11
43542: PUSH
43543: LD_INT 30
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PUSH
43550: LD_VAR 0 12
43554: ARRAY
43555: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
43556: LD_VAR 0 18
43560: NOT
43561: PUSH
43562: LD_INT 40
43564: PPUSH
43565: LD_VAR 0 16
43569: PPUSH
43570: CALL_OW 321
43574: PUSH
43575: LD_INT 2
43577: EQUAL
43578: AND
43579: PUSH
43580: LD_INT 7
43582: PUSH
43583: LD_VAR 0 5
43587: IN
43588: PUSH
43589: LD_INT 28
43591: PUSH
43592: LD_VAR 0 5
43596: IN
43597: OR
43598: PUSH
43599: LD_INT 45
43601: PUSH
43602: LD_VAR 0 5
43606: IN
43607: OR
43608: AND
43609: IFFALSE 43863
// begin hex := GetHexInfo ( x , y ) ;
43611: LD_ADDR_VAR 0 4
43615: PUSH
43616: LD_VAR 0 10
43620: PPUSH
43621: LD_VAR 0 11
43625: PPUSH
43626: CALL_OW 546
43630: ST_TO_ADDR
// if hex [ 1 ] then
43631: LD_VAR 0 4
43635: PUSH
43636: LD_INT 1
43638: ARRAY
43639: IFFALSE 43643
// exit ;
43641: GO 44046
// height := hex [ 2 ] ;
43643: LD_ADDR_VAR 0 15
43647: PUSH
43648: LD_VAR 0 4
43652: PUSH
43653: LD_INT 2
43655: ARRAY
43656: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
43657: LD_ADDR_VAR 0 14
43661: PUSH
43662: LD_INT 0
43664: PUSH
43665: LD_INT 2
43667: PUSH
43668: LD_INT 3
43670: PUSH
43671: LD_INT 5
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: LIST
43678: LIST
43679: ST_TO_ADDR
// for i in tmp do
43680: LD_ADDR_VAR 0 8
43684: PUSH
43685: LD_VAR 0 14
43689: PUSH
43690: FOR_IN
43691: IFFALSE 43861
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
43693: LD_ADDR_VAR 0 9
43697: PUSH
43698: LD_VAR 0 10
43702: PPUSH
43703: LD_VAR 0 8
43707: PPUSH
43708: LD_INT 5
43710: PPUSH
43711: CALL_OW 272
43715: PUSH
43716: LD_VAR 0 11
43720: PPUSH
43721: LD_VAR 0 8
43725: PPUSH
43726: LD_INT 5
43728: PPUSH
43729: CALL_OW 273
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
43738: LD_VAR 0 9
43742: PUSH
43743: LD_INT 1
43745: ARRAY
43746: PPUSH
43747: LD_VAR 0 9
43751: PUSH
43752: LD_INT 2
43754: ARRAY
43755: PPUSH
43756: CALL_OW 488
43760: IFFALSE 43859
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
43762: LD_ADDR_VAR 0 4
43766: PUSH
43767: LD_VAR 0 9
43771: PUSH
43772: LD_INT 1
43774: ARRAY
43775: PPUSH
43776: LD_VAR 0 9
43780: PUSH
43781: LD_INT 2
43783: ARRAY
43784: PPUSH
43785: CALL_OW 546
43789: ST_TO_ADDR
// if hex [ 1 ] then
43790: LD_VAR 0 4
43794: PUSH
43795: LD_INT 1
43797: ARRAY
43798: IFFALSE 43802
// continue ;
43800: GO 43690
// h := hex [ 2 ] ;
43802: LD_ADDR_VAR 0 13
43806: PUSH
43807: LD_VAR 0 4
43811: PUSH
43812: LD_INT 2
43814: ARRAY
43815: ST_TO_ADDR
// if h + 7 < height then
43816: LD_VAR 0 13
43820: PUSH
43821: LD_INT 7
43823: PLUS
43824: PUSH
43825: LD_VAR 0 15
43829: LESS
43830: IFFALSE 43859
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
43832: LD_ADDR_VAR 0 18
43836: PUSH
43837: LD_INT 7
43839: PUSH
43840: LD_INT 28
43842: PUSH
43843: LD_INT 45
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: LIST
43850: PUSH
43851: LD_VAR 0 12
43855: ARRAY
43856: ST_TO_ADDR
// break ;
43857: GO 43861
// end ; end ; end ;
43859: GO 43690
43861: POP
43862: POP
// end ; if not weapon then
43863: LD_VAR 0 18
43867: NOT
43868: IFFALSE 43928
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
43870: LD_ADDR_VAR 0 5
43874: PUSH
43875: LD_VAR 0 5
43879: PUSH
43880: LD_INT 11
43882: PUSH
43883: LD_INT 30
43885: PUSH
43886: LD_INT 49
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: LIST
43893: DIFF
43894: ST_TO_ADDR
// if not list then
43895: LD_VAR 0 5
43899: NOT
43900: IFFALSE 43904
// exit ;
43902: GO 44046
// weapon := list [ rand ( 1 , list ) ] ;
43904: LD_ADDR_VAR 0 18
43908: PUSH
43909: LD_VAR 0 5
43913: PUSH
43914: LD_INT 1
43916: PPUSH
43917: LD_VAR 0 5
43921: PPUSH
43922: CALL_OW 12
43926: ARRAY
43927: ST_TO_ADDR
// end ; if weapon then
43928: LD_VAR 0 18
43932: IFFALSE 44046
// begin tmp := CostOfWeapon ( weapon ) ;
43934: LD_ADDR_VAR 0 14
43938: PUSH
43939: LD_VAR 0 18
43943: PPUSH
43944: CALL_OW 451
43948: ST_TO_ADDR
// j := GetBase ( tower ) ;
43949: LD_ADDR_VAR 0 9
43953: PUSH
43954: LD_VAR 0 1
43958: PPUSH
43959: CALL_OW 274
43963: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
43964: LD_VAR 0 9
43968: PPUSH
43969: LD_INT 1
43971: PPUSH
43972: CALL_OW 275
43976: PUSH
43977: LD_VAR 0 14
43981: PUSH
43982: LD_INT 1
43984: ARRAY
43985: GREATEREQUAL
43986: PUSH
43987: LD_VAR 0 9
43991: PPUSH
43992: LD_INT 2
43994: PPUSH
43995: CALL_OW 275
43999: PUSH
44000: LD_VAR 0 14
44004: PUSH
44005: LD_INT 2
44007: ARRAY
44008: GREATEREQUAL
44009: AND
44010: PUSH
44011: LD_VAR 0 9
44015: PPUSH
44016: LD_INT 3
44018: PPUSH
44019: CALL_OW 275
44023: PUSH
44024: LD_VAR 0 14
44028: PUSH
44029: LD_INT 3
44031: ARRAY
44032: GREATEREQUAL
44033: AND
44034: IFFALSE 44046
// result := weapon ;
44036: LD_ADDR_VAR 0 3
44040: PUSH
44041: LD_VAR 0 18
44045: ST_TO_ADDR
// end ; end ;
44046: LD_VAR 0 3
44050: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
44051: LD_INT 0
44053: PPUSH
44054: PPUSH
// result := true ;
44055: LD_ADDR_VAR 0 3
44059: PUSH
44060: LD_INT 1
44062: ST_TO_ADDR
// if array1 = array2 then
44063: LD_VAR 0 1
44067: PUSH
44068: LD_VAR 0 2
44072: EQUAL
44073: IFFALSE 44133
// begin for i = 1 to array1 do
44075: LD_ADDR_VAR 0 4
44079: PUSH
44080: DOUBLE
44081: LD_INT 1
44083: DEC
44084: ST_TO_ADDR
44085: LD_VAR 0 1
44089: PUSH
44090: FOR_TO
44091: IFFALSE 44129
// if array1 [ i ] <> array2 [ i ] then
44093: LD_VAR 0 1
44097: PUSH
44098: LD_VAR 0 4
44102: ARRAY
44103: PUSH
44104: LD_VAR 0 2
44108: PUSH
44109: LD_VAR 0 4
44113: ARRAY
44114: NONEQUAL
44115: IFFALSE 44127
// begin result := false ;
44117: LD_ADDR_VAR 0 3
44121: PUSH
44122: LD_INT 0
44124: ST_TO_ADDR
// break ;
44125: GO 44129
// end ;
44127: GO 44090
44129: POP
44130: POP
// end else
44131: GO 44141
// result := false ;
44133: LD_ADDR_VAR 0 3
44137: PUSH
44138: LD_INT 0
44140: ST_TO_ADDR
// end ;
44141: LD_VAR 0 3
44145: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
44146: LD_INT 0
44148: PPUSH
44149: PPUSH
44150: PPUSH
// pom := GetBase ( fac ) ;
44151: LD_ADDR_VAR 0 5
44155: PUSH
44156: LD_VAR 0 1
44160: PPUSH
44161: CALL_OW 274
44165: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
44166: LD_ADDR_VAR 0 4
44170: PUSH
44171: LD_VAR 0 2
44175: PUSH
44176: LD_INT 1
44178: ARRAY
44179: PPUSH
44180: LD_VAR 0 2
44184: PUSH
44185: LD_INT 2
44187: ARRAY
44188: PPUSH
44189: LD_VAR 0 2
44193: PUSH
44194: LD_INT 3
44196: ARRAY
44197: PPUSH
44198: LD_VAR 0 2
44202: PUSH
44203: LD_INT 4
44205: ARRAY
44206: PPUSH
44207: CALL_OW 449
44211: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
44212: LD_ADDR_VAR 0 3
44216: PUSH
44217: LD_VAR 0 5
44221: PPUSH
44222: LD_INT 1
44224: PPUSH
44225: CALL_OW 275
44229: PUSH
44230: LD_VAR 0 4
44234: PUSH
44235: LD_INT 1
44237: ARRAY
44238: GREATEREQUAL
44239: PUSH
44240: LD_VAR 0 5
44244: PPUSH
44245: LD_INT 2
44247: PPUSH
44248: CALL_OW 275
44252: PUSH
44253: LD_VAR 0 4
44257: PUSH
44258: LD_INT 2
44260: ARRAY
44261: GREATEREQUAL
44262: AND
44263: PUSH
44264: LD_VAR 0 5
44268: PPUSH
44269: LD_INT 3
44271: PPUSH
44272: CALL_OW 275
44276: PUSH
44277: LD_VAR 0 4
44281: PUSH
44282: LD_INT 3
44284: ARRAY
44285: GREATEREQUAL
44286: AND
44287: ST_TO_ADDR
// end ;
44288: LD_VAR 0 3
44292: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
44293: LD_INT 0
44295: PPUSH
44296: PPUSH
44297: PPUSH
44298: PPUSH
// pom := GetBase ( building ) ;
44299: LD_ADDR_VAR 0 3
44303: PUSH
44304: LD_VAR 0 1
44308: PPUSH
44309: CALL_OW 274
44313: ST_TO_ADDR
// if not pom then
44314: LD_VAR 0 3
44318: NOT
44319: IFFALSE 44323
// exit ;
44321: GO 44493
// btype := GetBType ( building ) ;
44323: LD_ADDR_VAR 0 5
44327: PUSH
44328: LD_VAR 0 1
44332: PPUSH
44333: CALL_OW 266
44337: ST_TO_ADDR
// if btype = b_armoury then
44338: LD_VAR 0 5
44342: PUSH
44343: LD_INT 4
44345: EQUAL
44346: IFFALSE 44356
// btype := b_barracks ;
44348: LD_ADDR_VAR 0 5
44352: PUSH
44353: LD_INT 5
44355: ST_TO_ADDR
// if btype = b_depot then
44356: LD_VAR 0 5
44360: PUSH
44361: LD_INT 0
44363: EQUAL
44364: IFFALSE 44374
// btype := b_warehouse ;
44366: LD_ADDR_VAR 0 5
44370: PUSH
44371: LD_INT 1
44373: ST_TO_ADDR
// if btype = b_workshop then
44374: LD_VAR 0 5
44378: PUSH
44379: LD_INT 2
44381: EQUAL
44382: IFFALSE 44392
// btype := b_factory ;
44384: LD_ADDR_VAR 0 5
44388: PUSH
44389: LD_INT 3
44391: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
44392: LD_ADDR_VAR 0 4
44396: PUSH
44397: LD_VAR 0 5
44401: PPUSH
44402: LD_VAR 0 1
44406: PPUSH
44407: CALL_OW 248
44411: PPUSH
44412: CALL_OW 450
44416: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
44417: LD_ADDR_VAR 0 2
44421: PUSH
44422: LD_VAR 0 3
44426: PPUSH
44427: LD_INT 1
44429: PPUSH
44430: CALL_OW 275
44434: PUSH
44435: LD_VAR 0 4
44439: PUSH
44440: LD_INT 1
44442: ARRAY
44443: GREATEREQUAL
44444: PUSH
44445: LD_VAR 0 3
44449: PPUSH
44450: LD_INT 2
44452: PPUSH
44453: CALL_OW 275
44457: PUSH
44458: LD_VAR 0 4
44462: PUSH
44463: LD_INT 2
44465: ARRAY
44466: GREATEREQUAL
44467: AND
44468: PUSH
44469: LD_VAR 0 3
44473: PPUSH
44474: LD_INT 3
44476: PPUSH
44477: CALL_OW 275
44481: PUSH
44482: LD_VAR 0 4
44486: PUSH
44487: LD_INT 3
44489: ARRAY
44490: GREATEREQUAL
44491: AND
44492: ST_TO_ADDR
// end ;
44493: LD_VAR 0 2
44497: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
44498: LD_INT 0
44500: PPUSH
44501: PPUSH
44502: PPUSH
// pom := GetBase ( building ) ;
44503: LD_ADDR_VAR 0 4
44507: PUSH
44508: LD_VAR 0 1
44512: PPUSH
44513: CALL_OW 274
44517: ST_TO_ADDR
// if not pom then
44518: LD_VAR 0 4
44522: NOT
44523: IFFALSE 44527
// exit ;
44525: GO 44628
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
44527: LD_ADDR_VAR 0 5
44531: PUSH
44532: LD_VAR 0 2
44536: PPUSH
44537: LD_VAR 0 1
44541: PPUSH
44542: CALL_OW 248
44546: PPUSH
44547: CALL_OW 450
44551: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
44552: LD_ADDR_VAR 0 3
44556: PUSH
44557: LD_VAR 0 4
44561: PPUSH
44562: LD_INT 1
44564: PPUSH
44565: CALL_OW 275
44569: PUSH
44570: LD_VAR 0 5
44574: PUSH
44575: LD_INT 1
44577: ARRAY
44578: GREATEREQUAL
44579: PUSH
44580: LD_VAR 0 4
44584: PPUSH
44585: LD_INT 2
44587: PPUSH
44588: CALL_OW 275
44592: PUSH
44593: LD_VAR 0 5
44597: PUSH
44598: LD_INT 2
44600: ARRAY
44601: GREATEREQUAL
44602: AND
44603: PUSH
44604: LD_VAR 0 4
44608: PPUSH
44609: LD_INT 3
44611: PPUSH
44612: CALL_OW 275
44616: PUSH
44617: LD_VAR 0 5
44621: PUSH
44622: LD_INT 3
44624: ARRAY
44625: GREATEREQUAL
44626: AND
44627: ST_TO_ADDR
// end ;
44628: LD_VAR 0 3
44632: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
44633: LD_INT 0
44635: PPUSH
44636: PPUSH
44637: PPUSH
44638: PPUSH
44639: PPUSH
44640: PPUSH
44641: PPUSH
44642: PPUSH
44643: PPUSH
44644: PPUSH
// result := false ;
44645: LD_ADDR_VAR 0 6
44649: PUSH
44650: LD_INT 0
44652: ST_TO_ADDR
// if not base or not btype or not x or not y then
44653: LD_VAR 0 1
44657: NOT
44658: PUSH
44659: LD_VAR 0 2
44663: NOT
44664: OR
44665: PUSH
44666: LD_VAR 0 3
44670: NOT
44671: OR
44672: PUSH
44673: LD_VAR 0 4
44677: NOT
44678: OR
44679: IFFALSE 44683
// exit ;
44681: GO 45274
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
44683: LD_ADDR_VAR 0 12
44687: PUSH
44688: LD_VAR 0 2
44692: PPUSH
44693: LD_VAR 0 3
44697: PPUSH
44698: LD_VAR 0 4
44702: PPUSH
44703: LD_VAR 0 5
44707: PPUSH
44708: LD_VAR 0 1
44712: PUSH
44713: LD_INT 1
44715: ARRAY
44716: PPUSH
44717: CALL_OW 248
44721: PPUSH
44722: LD_INT 0
44724: PPUSH
44725: CALL 46111 0 6
44729: ST_TO_ADDR
// if not hexes then
44730: LD_VAR 0 12
44734: NOT
44735: IFFALSE 44739
// exit ;
44737: GO 45274
// for i = 1 to hexes do
44739: LD_ADDR_VAR 0 7
44743: PUSH
44744: DOUBLE
44745: LD_INT 1
44747: DEC
44748: ST_TO_ADDR
44749: LD_VAR 0 12
44753: PUSH
44754: FOR_TO
44755: IFFALSE 45272
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44757: LD_ADDR_VAR 0 11
44761: PUSH
44762: LD_VAR 0 12
44766: PUSH
44767: LD_VAR 0 7
44771: ARRAY
44772: PUSH
44773: LD_INT 1
44775: ARRAY
44776: PPUSH
44777: LD_VAR 0 12
44781: PUSH
44782: LD_VAR 0 7
44786: ARRAY
44787: PUSH
44788: LD_INT 2
44790: ARRAY
44791: PPUSH
44792: CALL_OW 428
44796: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
44797: LD_VAR 0 12
44801: PUSH
44802: LD_VAR 0 7
44806: ARRAY
44807: PUSH
44808: LD_INT 1
44810: ARRAY
44811: PPUSH
44812: LD_VAR 0 12
44816: PUSH
44817: LD_VAR 0 7
44821: ARRAY
44822: PUSH
44823: LD_INT 2
44825: ARRAY
44826: PPUSH
44827: CALL_OW 351
44831: PUSH
44832: LD_VAR 0 12
44836: PUSH
44837: LD_VAR 0 7
44841: ARRAY
44842: PUSH
44843: LD_INT 1
44845: ARRAY
44846: PPUSH
44847: LD_VAR 0 12
44851: PUSH
44852: LD_VAR 0 7
44856: ARRAY
44857: PUSH
44858: LD_INT 2
44860: ARRAY
44861: PPUSH
44862: CALL_OW 488
44866: NOT
44867: OR
44868: PUSH
44869: LD_VAR 0 11
44873: PPUSH
44874: CALL_OW 247
44878: PUSH
44879: LD_INT 3
44881: EQUAL
44882: OR
44883: IFFALSE 44889
// exit ;
44885: POP
44886: POP
44887: GO 45274
// if not tmp then
44889: LD_VAR 0 11
44893: NOT
44894: IFFALSE 44898
// continue ;
44896: GO 44754
// result := true ;
44898: LD_ADDR_VAR 0 6
44902: PUSH
44903: LD_INT 1
44905: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
44906: LD_ADDR_VAR 0 15
44910: PUSH
44911: LD_INT 22
44913: PUSH
44914: LD_VAR 0 11
44918: PPUSH
44919: CALL_OW 255
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PUSH
44928: LD_INT 2
44930: PUSH
44931: LD_INT 30
44933: PUSH
44934: LD_INT 0
44936: PUSH
44937: EMPTY
44938: LIST
44939: LIST
44940: PUSH
44941: LD_INT 30
44943: PUSH
44944: LD_INT 1
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: LIST
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PPUSH
44960: CALL_OW 69
44964: ST_TO_ADDR
// if dep then
44965: LD_VAR 0 15
44969: IFFALSE 45105
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
44971: LD_ADDR_VAR 0 14
44975: PUSH
44976: LD_VAR 0 15
44980: PUSH
44981: LD_INT 1
44983: ARRAY
44984: PPUSH
44985: CALL_OW 250
44989: PPUSH
44990: LD_VAR 0 15
44994: PUSH
44995: LD_INT 1
44997: ARRAY
44998: PPUSH
44999: CALL_OW 254
45003: PPUSH
45004: LD_INT 5
45006: PPUSH
45007: CALL_OW 272
45011: PUSH
45012: LD_VAR 0 15
45016: PUSH
45017: LD_INT 1
45019: ARRAY
45020: PPUSH
45021: CALL_OW 251
45025: PPUSH
45026: LD_VAR 0 15
45030: PUSH
45031: LD_INT 1
45033: ARRAY
45034: PPUSH
45035: CALL_OW 254
45039: PPUSH
45040: LD_INT 5
45042: PPUSH
45043: CALL_OW 273
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
45052: LD_VAR 0 14
45056: PUSH
45057: LD_INT 1
45059: ARRAY
45060: PPUSH
45061: LD_VAR 0 14
45065: PUSH
45066: LD_INT 2
45068: ARRAY
45069: PPUSH
45070: CALL_OW 488
45074: IFFALSE 45105
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
45076: LD_VAR 0 11
45080: PPUSH
45081: LD_VAR 0 14
45085: PUSH
45086: LD_INT 1
45088: ARRAY
45089: PPUSH
45090: LD_VAR 0 14
45094: PUSH
45095: LD_INT 2
45097: ARRAY
45098: PPUSH
45099: CALL_OW 111
// continue ;
45103: GO 44754
// end ; end ; r := GetDir ( tmp ) ;
45105: LD_ADDR_VAR 0 13
45109: PUSH
45110: LD_VAR 0 11
45114: PPUSH
45115: CALL_OW 254
45119: ST_TO_ADDR
// if r = 5 then
45120: LD_VAR 0 13
45124: PUSH
45125: LD_INT 5
45127: EQUAL
45128: IFFALSE 45138
// r := 0 ;
45130: LD_ADDR_VAR 0 13
45134: PUSH
45135: LD_INT 0
45137: ST_TO_ADDR
// for j = r to 5 do
45138: LD_ADDR_VAR 0 8
45142: PUSH
45143: DOUBLE
45144: LD_VAR 0 13
45148: DEC
45149: ST_TO_ADDR
45150: LD_INT 5
45152: PUSH
45153: FOR_TO
45154: IFFALSE 45268
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
45156: LD_ADDR_VAR 0 9
45160: PUSH
45161: LD_VAR 0 11
45165: PPUSH
45166: CALL_OW 250
45170: PPUSH
45171: LD_VAR 0 8
45175: PPUSH
45176: LD_INT 2
45178: PPUSH
45179: CALL_OW 272
45183: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
45184: LD_ADDR_VAR 0 10
45188: PUSH
45189: LD_VAR 0 11
45193: PPUSH
45194: CALL_OW 251
45198: PPUSH
45199: LD_VAR 0 8
45203: PPUSH
45204: LD_INT 2
45206: PPUSH
45207: CALL_OW 273
45211: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
45212: LD_VAR 0 9
45216: PPUSH
45217: LD_VAR 0 10
45221: PPUSH
45222: CALL_OW 488
45226: PUSH
45227: LD_VAR 0 9
45231: PPUSH
45232: LD_VAR 0 10
45236: PPUSH
45237: CALL_OW 428
45241: NOT
45242: AND
45243: IFFALSE 45266
// begin ComMoveXY ( tmp , _x , _y ) ;
45245: LD_VAR 0 11
45249: PPUSH
45250: LD_VAR 0 9
45254: PPUSH
45255: LD_VAR 0 10
45259: PPUSH
45260: CALL_OW 111
// break ;
45264: GO 45268
// end ; end ;
45266: GO 45153
45268: POP
45269: POP
// end ;
45270: GO 44754
45272: POP
45273: POP
// end ;
45274: LD_VAR 0 6
45278: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
45279: LD_INT 0
45281: PPUSH
45282: PPUSH
45283: PPUSH
45284: PPUSH
45285: PPUSH
45286: PPUSH
45287: PPUSH
45288: PPUSH
45289: PPUSH
45290: PPUSH
// result := false ;
45291: LD_ADDR_VAR 0 6
45295: PUSH
45296: LD_INT 0
45298: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
45299: LD_VAR 0 1
45303: NOT
45304: PUSH
45305: LD_VAR 0 1
45309: PPUSH
45310: CALL_OW 266
45314: PUSH
45315: LD_INT 0
45317: PUSH
45318: LD_INT 1
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: IN
45325: NOT
45326: OR
45327: PUSH
45328: LD_VAR 0 2
45332: NOT
45333: OR
45334: PUSH
45335: LD_VAR 0 5
45339: PUSH
45340: LD_INT 0
45342: PUSH
45343: LD_INT 1
45345: PUSH
45346: LD_INT 2
45348: PUSH
45349: LD_INT 3
45351: PUSH
45352: LD_INT 4
45354: PUSH
45355: LD_INT 5
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: IN
45366: NOT
45367: OR
45368: PUSH
45369: LD_VAR 0 3
45373: PPUSH
45374: LD_VAR 0 4
45378: PPUSH
45379: CALL_OW 488
45383: NOT
45384: OR
45385: IFFALSE 45389
// exit ;
45387: GO 46106
// pom := GetBase ( bdepot ) ;
45389: LD_ADDR_VAR 0 10
45393: PUSH
45394: LD_VAR 0 1
45398: PPUSH
45399: CALL_OW 274
45403: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
45404: LD_ADDR_VAR 0 11
45408: PUSH
45409: LD_VAR 0 2
45413: PPUSH
45414: LD_VAR 0 1
45418: PPUSH
45419: CALL_OW 248
45423: PPUSH
45424: CALL_OW 450
45428: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
45429: LD_VAR 0 10
45433: PPUSH
45434: LD_INT 1
45436: PPUSH
45437: CALL_OW 275
45441: PUSH
45442: LD_VAR 0 11
45446: PUSH
45447: LD_INT 1
45449: ARRAY
45450: GREATEREQUAL
45451: PUSH
45452: LD_VAR 0 10
45456: PPUSH
45457: LD_INT 2
45459: PPUSH
45460: CALL_OW 275
45464: PUSH
45465: LD_VAR 0 11
45469: PUSH
45470: LD_INT 2
45472: ARRAY
45473: GREATEREQUAL
45474: AND
45475: PUSH
45476: LD_VAR 0 10
45480: PPUSH
45481: LD_INT 3
45483: PPUSH
45484: CALL_OW 275
45488: PUSH
45489: LD_VAR 0 11
45493: PUSH
45494: LD_INT 3
45496: ARRAY
45497: GREATEREQUAL
45498: AND
45499: NOT
45500: IFFALSE 45504
// exit ;
45502: GO 46106
// if GetBType ( bdepot ) = b_depot then
45504: LD_VAR 0 1
45508: PPUSH
45509: CALL_OW 266
45513: PUSH
45514: LD_INT 0
45516: EQUAL
45517: IFFALSE 45529
// dist := 28 else
45519: LD_ADDR_VAR 0 14
45523: PUSH
45524: LD_INT 28
45526: ST_TO_ADDR
45527: GO 45537
// dist := 36 ;
45529: LD_ADDR_VAR 0 14
45533: PUSH
45534: LD_INT 36
45536: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
45537: LD_VAR 0 1
45541: PPUSH
45542: LD_VAR 0 3
45546: PPUSH
45547: LD_VAR 0 4
45551: PPUSH
45552: CALL_OW 297
45556: PUSH
45557: LD_VAR 0 14
45561: GREATER
45562: IFFALSE 45566
// exit ;
45564: GO 46106
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
45566: LD_ADDR_VAR 0 12
45570: PUSH
45571: LD_VAR 0 2
45575: PPUSH
45576: LD_VAR 0 3
45580: PPUSH
45581: LD_VAR 0 4
45585: PPUSH
45586: LD_VAR 0 5
45590: PPUSH
45591: LD_VAR 0 1
45595: PPUSH
45596: CALL_OW 248
45600: PPUSH
45601: LD_INT 0
45603: PPUSH
45604: CALL 46111 0 6
45608: ST_TO_ADDR
// if not hexes then
45609: LD_VAR 0 12
45613: NOT
45614: IFFALSE 45618
// exit ;
45616: GO 46106
// hex := GetHexInfo ( x , y ) ;
45618: LD_ADDR_VAR 0 15
45622: PUSH
45623: LD_VAR 0 3
45627: PPUSH
45628: LD_VAR 0 4
45632: PPUSH
45633: CALL_OW 546
45637: ST_TO_ADDR
// if hex [ 1 ] then
45638: LD_VAR 0 15
45642: PUSH
45643: LD_INT 1
45645: ARRAY
45646: IFFALSE 45650
// exit ;
45648: GO 46106
// height := hex [ 2 ] ;
45650: LD_ADDR_VAR 0 13
45654: PUSH
45655: LD_VAR 0 15
45659: PUSH
45660: LD_INT 2
45662: ARRAY
45663: ST_TO_ADDR
// for i = 1 to hexes do
45664: LD_ADDR_VAR 0 7
45668: PUSH
45669: DOUBLE
45670: LD_INT 1
45672: DEC
45673: ST_TO_ADDR
45674: LD_VAR 0 12
45678: PUSH
45679: FOR_TO
45680: IFFALSE 46010
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
45682: LD_VAR 0 12
45686: PUSH
45687: LD_VAR 0 7
45691: ARRAY
45692: PUSH
45693: LD_INT 1
45695: ARRAY
45696: PPUSH
45697: LD_VAR 0 12
45701: PUSH
45702: LD_VAR 0 7
45706: ARRAY
45707: PUSH
45708: LD_INT 2
45710: ARRAY
45711: PPUSH
45712: CALL_OW 488
45716: NOT
45717: PUSH
45718: LD_VAR 0 12
45722: PUSH
45723: LD_VAR 0 7
45727: ARRAY
45728: PUSH
45729: LD_INT 1
45731: ARRAY
45732: PPUSH
45733: LD_VAR 0 12
45737: PUSH
45738: LD_VAR 0 7
45742: ARRAY
45743: PUSH
45744: LD_INT 2
45746: ARRAY
45747: PPUSH
45748: CALL_OW 428
45752: PUSH
45753: LD_INT 0
45755: GREATER
45756: OR
45757: PUSH
45758: LD_VAR 0 12
45762: PUSH
45763: LD_VAR 0 7
45767: ARRAY
45768: PUSH
45769: LD_INT 1
45771: ARRAY
45772: PPUSH
45773: LD_VAR 0 12
45777: PUSH
45778: LD_VAR 0 7
45782: ARRAY
45783: PUSH
45784: LD_INT 2
45786: ARRAY
45787: PPUSH
45788: CALL_OW 351
45792: OR
45793: IFFALSE 45799
// exit ;
45795: POP
45796: POP
45797: GO 46106
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45799: LD_ADDR_VAR 0 8
45803: PUSH
45804: LD_VAR 0 12
45808: PUSH
45809: LD_VAR 0 7
45813: ARRAY
45814: PUSH
45815: LD_INT 1
45817: ARRAY
45818: PPUSH
45819: LD_VAR 0 12
45823: PUSH
45824: LD_VAR 0 7
45828: ARRAY
45829: PUSH
45830: LD_INT 2
45832: ARRAY
45833: PPUSH
45834: CALL_OW 546
45838: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
45839: LD_VAR 0 8
45843: PUSH
45844: LD_INT 1
45846: ARRAY
45847: PUSH
45848: LD_VAR 0 8
45852: PUSH
45853: LD_INT 2
45855: ARRAY
45856: PUSH
45857: LD_VAR 0 13
45861: PUSH
45862: LD_INT 2
45864: PLUS
45865: GREATER
45866: OR
45867: PUSH
45868: LD_VAR 0 8
45872: PUSH
45873: LD_INT 2
45875: ARRAY
45876: PUSH
45877: LD_VAR 0 13
45881: PUSH
45882: LD_INT 2
45884: MINUS
45885: LESS
45886: OR
45887: PUSH
45888: LD_VAR 0 8
45892: PUSH
45893: LD_INT 3
45895: ARRAY
45896: PUSH
45897: LD_INT 0
45899: PUSH
45900: LD_INT 8
45902: PUSH
45903: LD_INT 9
45905: PUSH
45906: LD_INT 10
45908: PUSH
45909: LD_INT 11
45911: PUSH
45912: LD_INT 12
45914: PUSH
45915: LD_INT 13
45917: PUSH
45918: LD_INT 16
45920: PUSH
45921: LD_INT 17
45923: PUSH
45924: LD_INT 18
45926: PUSH
45927: LD_INT 19
45929: PUSH
45930: LD_INT 20
45932: PUSH
45933: LD_INT 21
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: IN
45951: NOT
45952: OR
45953: PUSH
45954: LD_VAR 0 8
45958: PUSH
45959: LD_INT 5
45961: ARRAY
45962: NOT
45963: OR
45964: PUSH
45965: LD_VAR 0 8
45969: PUSH
45970: LD_INT 6
45972: ARRAY
45973: PUSH
45974: LD_INT 1
45976: PUSH
45977: LD_INT 2
45979: PUSH
45980: LD_INT 7
45982: PUSH
45983: LD_INT 9
45985: PUSH
45986: LD_INT 10
45988: PUSH
45989: LD_INT 11
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: IN
46000: NOT
46001: OR
46002: IFFALSE 46008
// exit ;
46004: POP
46005: POP
46006: GO 46106
// end ;
46008: GO 45679
46010: POP
46011: POP
// side := GetSide ( bdepot ) ;
46012: LD_ADDR_VAR 0 9
46016: PUSH
46017: LD_VAR 0 1
46021: PPUSH
46022: CALL_OW 255
46026: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
46027: LD_VAR 0 9
46031: PPUSH
46032: LD_VAR 0 3
46036: PPUSH
46037: LD_VAR 0 4
46041: PPUSH
46042: LD_INT 20
46044: PPUSH
46045: CALL 38778 0 4
46049: PUSH
46050: LD_INT 4
46052: ARRAY
46053: IFFALSE 46057
// exit ;
46055: GO 46106
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
46057: LD_VAR 0 2
46061: PUSH
46062: LD_INT 29
46064: PUSH
46065: LD_INT 30
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: IN
46072: PUSH
46073: LD_VAR 0 3
46077: PPUSH
46078: LD_VAR 0 4
46082: PPUSH
46083: LD_VAR 0 9
46087: PPUSH
46088: CALL_OW 440
46092: NOT
46093: AND
46094: IFFALSE 46098
// exit ;
46096: GO 46106
// result := true ;
46098: LD_ADDR_VAR 0 6
46102: PUSH
46103: LD_INT 1
46105: ST_TO_ADDR
// end ;
46106: LD_VAR 0 6
46110: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
46111: LD_INT 0
46113: PPUSH
46114: PPUSH
46115: PPUSH
46116: PPUSH
46117: PPUSH
46118: PPUSH
46119: PPUSH
46120: PPUSH
46121: PPUSH
46122: PPUSH
46123: PPUSH
46124: PPUSH
46125: PPUSH
46126: PPUSH
46127: PPUSH
46128: PPUSH
46129: PPUSH
46130: PPUSH
46131: PPUSH
46132: PPUSH
46133: PPUSH
46134: PPUSH
46135: PPUSH
46136: PPUSH
46137: PPUSH
46138: PPUSH
46139: PPUSH
46140: PPUSH
46141: PPUSH
46142: PPUSH
46143: PPUSH
46144: PPUSH
46145: PPUSH
46146: PPUSH
46147: PPUSH
46148: PPUSH
46149: PPUSH
46150: PPUSH
46151: PPUSH
46152: PPUSH
46153: PPUSH
46154: PPUSH
46155: PPUSH
46156: PPUSH
46157: PPUSH
46158: PPUSH
46159: PPUSH
46160: PPUSH
46161: PPUSH
46162: PPUSH
46163: PPUSH
46164: PPUSH
46165: PPUSH
46166: PPUSH
46167: PPUSH
46168: PPUSH
46169: PPUSH
46170: PPUSH
// result = [ ] ;
46171: LD_ADDR_VAR 0 7
46175: PUSH
46176: EMPTY
46177: ST_TO_ADDR
// temp_list = [ ] ;
46178: LD_ADDR_VAR 0 9
46182: PUSH
46183: EMPTY
46184: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
46185: LD_VAR 0 4
46189: PUSH
46190: LD_INT 0
46192: PUSH
46193: LD_INT 1
46195: PUSH
46196: LD_INT 2
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: LD_INT 4
46204: PUSH
46205: LD_INT 5
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: IN
46216: NOT
46217: PUSH
46218: LD_VAR 0 1
46222: PUSH
46223: LD_INT 0
46225: PUSH
46226: LD_INT 1
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: IN
46233: PUSH
46234: LD_VAR 0 5
46238: PUSH
46239: LD_INT 1
46241: PUSH
46242: LD_INT 2
46244: PUSH
46245: LD_INT 3
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: LIST
46252: IN
46253: NOT
46254: AND
46255: OR
46256: IFFALSE 46260
// exit ;
46258: GO 64645
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
46260: LD_VAR 0 1
46264: PUSH
46265: LD_INT 6
46267: PUSH
46268: LD_INT 7
46270: PUSH
46271: LD_INT 8
46273: PUSH
46274: LD_INT 13
46276: PUSH
46277: LD_INT 12
46279: PUSH
46280: LD_INT 15
46282: PUSH
46283: LD_INT 11
46285: PUSH
46286: LD_INT 14
46288: PUSH
46289: LD_INT 10
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: IN
46303: IFFALSE 46313
// btype = b_lab ;
46305: LD_ADDR_VAR 0 1
46309: PUSH
46310: LD_INT 6
46312: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
46313: LD_VAR 0 6
46317: PUSH
46318: LD_INT 0
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: LD_INT 2
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: LIST
46331: IN
46332: NOT
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_INT 0
46341: PUSH
46342: LD_INT 1
46344: PUSH
46345: LD_INT 2
46347: PUSH
46348: LD_INT 3
46350: PUSH
46351: LD_INT 6
46353: PUSH
46354: LD_INT 36
46356: PUSH
46357: LD_INT 4
46359: PUSH
46360: LD_INT 5
46362: PUSH
46363: LD_INT 31
46365: PUSH
46366: LD_INT 32
46368: PUSH
46369: LD_INT 33
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: IN
46385: NOT
46386: PUSH
46387: LD_VAR 0 6
46391: PUSH
46392: LD_INT 1
46394: EQUAL
46395: AND
46396: OR
46397: PUSH
46398: LD_VAR 0 1
46402: PUSH
46403: LD_INT 2
46405: PUSH
46406: LD_INT 3
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: IN
46413: NOT
46414: PUSH
46415: LD_VAR 0 6
46419: PUSH
46420: LD_INT 2
46422: EQUAL
46423: AND
46424: OR
46425: IFFALSE 46435
// mode = 0 ;
46427: LD_ADDR_VAR 0 6
46431: PUSH
46432: LD_INT 0
46434: ST_TO_ADDR
// case mode of 0 :
46435: LD_VAR 0 6
46439: PUSH
46440: LD_INT 0
46442: DOUBLE
46443: EQUAL
46444: IFTRUE 46448
46446: GO 57901
46448: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46449: LD_ADDR_VAR 0 11
46453: PUSH
46454: LD_INT 0
46456: PUSH
46457: LD_INT 0
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: PUSH
46464: LD_INT 0
46466: PUSH
46467: LD_INT 1
46469: NEG
46470: PUSH
46471: EMPTY
46472: LIST
46473: LIST
46474: PUSH
46475: LD_INT 1
46477: PUSH
46478: LD_INT 0
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PUSH
46485: LD_INT 1
46487: PUSH
46488: LD_INT 1
46490: PUSH
46491: EMPTY
46492: LIST
46493: LIST
46494: PUSH
46495: LD_INT 0
46497: PUSH
46498: LD_INT 1
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: PUSH
46505: LD_INT 1
46507: NEG
46508: PUSH
46509: LD_INT 0
46511: PUSH
46512: EMPTY
46513: LIST
46514: LIST
46515: PUSH
46516: LD_INT 1
46518: NEG
46519: PUSH
46520: LD_INT 1
46522: NEG
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: PUSH
46528: LD_INT 1
46530: NEG
46531: PUSH
46532: LD_INT 2
46534: NEG
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: LD_INT 0
46542: PUSH
46543: LD_INT 2
46545: NEG
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: PUSH
46551: LD_INT 1
46553: PUSH
46554: LD_INT 1
46556: NEG
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PUSH
46562: LD_INT 1
46564: PUSH
46565: LD_INT 2
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 0
46574: PUSH
46575: LD_INT 2
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 1
46584: NEG
46585: PUSH
46586: LD_INT 1
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: PUSH
46593: LD_INT 1
46595: PUSH
46596: LD_INT 3
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 0
46605: PUSH
46606: LD_INT 3
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 1
46615: NEG
46616: PUSH
46617: LD_INT 2
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: EMPTY
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: LIST
46641: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46642: LD_ADDR_VAR 0 12
46646: PUSH
46647: LD_INT 0
46649: PUSH
46650: LD_INT 0
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 0
46659: PUSH
46660: LD_INT 1
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 1
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 1
46680: PUSH
46681: LD_INT 1
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 0
46690: PUSH
46691: LD_INT 1
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 1
46700: NEG
46701: PUSH
46702: LD_INT 0
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 1
46711: NEG
46712: PUSH
46713: LD_INT 1
46715: NEG
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 1
46723: PUSH
46724: LD_INT 1
46726: NEG
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: LD_INT 2
46734: PUSH
46735: LD_INT 0
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: LD_INT 2
46744: PUSH
46745: LD_INT 1
46747: PUSH
46748: EMPTY
46749: LIST
46750: LIST
46751: PUSH
46752: LD_INT 1
46754: NEG
46755: PUSH
46756: LD_INT 1
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: LD_INT 2
46765: NEG
46766: PUSH
46767: LD_INT 0
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: LD_INT 2
46776: NEG
46777: PUSH
46778: LD_INT 1
46780: NEG
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: LD_INT 2
46788: NEG
46789: PUSH
46790: LD_INT 1
46792: PUSH
46793: EMPTY
46794: LIST
46795: LIST
46796: PUSH
46797: LD_INT 3
46799: NEG
46800: PUSH
46801: LD_INT 0
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: LD_INT 3
46810: NEG
46811: PUSH
46812: LD_INT 1
46814: NEG
46815: PUSH
46816: EMPTY
46817: LIST
46818: LIST
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46838: LD_ADDR_VAR 0 13
46842: PUSH
46843: LD_INT 0
46845: PUSH
46846: LD_INT 0
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 0
46855: PUSH
46856: LD_INT 1
46858: NEG
46859: PUSH
46860: EMPTY
46861: LIST
46862: LIST
46863: PUSH
46864: LD_INT 1
46866: PUSH
46867: LD_INT 0
46869: PUSH
46870: EMPTY
46871: LIST
46872: LIST
46873: PUSH
46874: LD_INT 1
46876: PUSH
46877: LD_INT 1
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: PUSH
46884: LD_INT 0
46886: PUSH
46887: LD_INT 1
46889: PUSH
46890: EMPTY
46891: LIST
46892: LIST
46893: PUSH
46894: LD_INT 1
46896: NEG
46897: PUSH
46898: LD_INT 0
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: PUSH
46905: LD_INT 1
46907: NEG
46908: PUSH
46909: LD_INT 1
46911: NEG
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: PUSH
46917: LD_INT 1
46919: NEG
46920: PUSH
46921: LD_INT 2
46923: NEG
46924: PUSH
46925: EMPTY
46926: LIST
46927: LIST
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: LD_INT 1
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: LD_INT 2
46941: PUSH
46942: LD_INT 2
46944: PUSH
46945: EMPTY
46946: LIST
46947: LIST
46948: PUSH
46949: LD_INT 1
46951: PUSH
46952: LD_INT 2
46954: PUSH
46955: EMPTY
46956: LIST
46957: LIST
46958: PUSH
46959: LD_INT 2
46961: NEG
46962: PUSH
46963: LD_INT 1
46965: NEG
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 2
46973: NEG
46974: PUSH
46975: LD_INT 2
46977: NEG
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PUSH
46983: LD_INT 2
46985: NEG
46986: PUSH
46987: LD_INT 3
46989: NEG
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: PUSH
46995: LD_INT 3
46997: NEG
46998: PUSH
46999: LD_INT 2
47001: NEG
47002: PUSH
47003: EMPTY
47004: LIST
47005: LIST
47006: PUSH
47007: LD_INT 3
47009: NEG
47010: PUSH
47011: LD_INT 3
47013: NEG
47014: PUSH
47015: EMPTY
47016: LIST
47017: LIST
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47037: LD_ADDR_VAR 0 14
47041: PUSH
47042: LD_INT 0
47044: PUSH
47045: LD_INT 0
47047: PUSH
47048: EMPTY
47049: LIST
47050: LIST
47051: PUSH
47052: LD_INT 0
47054: PUSH
47055: LD_INT 1
47057: NEG
47058: PUSH
47059: EMPTY
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 1
47065: PUSH
47066: LD_INT 0
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PUSH
47073: LD_INT 1
47075: PUSH
47076: LD_INT 1
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: PUSH
47083: LD_INT 0
47085: PUSH
47086: LD_INT 1
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: LD_INT 1
47095: NEG
47096: PUSH
47097: LD_INT 0
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: PUSH
47104: LD_INT 1
47106: NEG
47107: PUSH
47108: LD_INT 1
47110: NEG
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: PUSH
47116: LD_INT 1
47118: NEG
47119: PUSH
47120: LD_INT 2
47122: NEG
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: LD_INT 0
47130: PUSH
47131: LD_INT 2
47133: NEG
47134: PUSH
47135: EMPTY
47136: LIST
47137: LIST
47138: PUSH
47139: LD_INT 1
47141: PUSH
47142: LD_INT 1
47144: NEG
47145: PUSH
47146: EMPTY
47147: LIST
47148: LIST
47149: PUSH
47150: LD_INT 1
47152: PUSH
47153: LD_INT 2
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: PUSH
47160: LD_INT 0
47162: PUSH
47163: LD_INT 2
47165: PUSH
47166: EMPTY
47167: LIST
47168: LIST
47169: PUSH
47170: LD_INT 1
47172: NEG
47173: PUSH
47174: LD_INT 1
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: PUSH
47181: LD_INT 1
47183: NEG
47184: PUSH
47185: LD_INT 3
47187: NEG
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: PUSH
47193: LD_INT 0
47195: PUSH
47196: LD_INT 3
47198: NEG
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 1
47206: PUSH
47207: LD_INT 2
47209: NEG
47210: PUSH
47211: EMPTY
47212: LIST
47213: LIST
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47233: LD_ADDR_VAR 0 15
47237: PUSH
47238: LD_INT 0
47240: PUSH
47241: LD_INT 0
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 0
47250: PUSH
47251: LD_INT 1
47253: NEG
47254: PUSH
47255: EMPTY
47256: LIST
47257: LIST
47258: PUSH
47259: LD_INT 1
47261: PUSH
47262: LD_INT 0
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 1
47271: PUSH
47272: LD_INT 1
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 0
47281: PUSH
47282: LD_INT 1
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 1
47291: NEG
47292: PUSH
47293: LD_INT 0
47295: PUSH
47296: EMPTY
47297: LIST
47298: LIST
47299: PUSH
47300: LD_INT 1
47302: NEG
47303: PUSH
47304: LD_INT 1
47306: NEG
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: PUSH
47312: LD_INT 1
47314: PUSH
47315: LD_INT 1
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: LD_INT 2
47325: PUSH
47326: LD_INT 0
47328: PUSH
47329: EMPTY
47330: LIST
47331: LIST
47332: PUSH
47333: LD_INT 2
47335: PUSH
47336: LD_INT 1
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: LD_INT 1
47345: NEG
47346: PUSH
47347: LD_INT 1
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: LD_INT 2
47356: NEG
47357: PUSH
47358: LD_INT 0
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 2
47367: NEG
47368: PUSH
47369: LD_INT 1
47371: NEG
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: PUSH
47377: LD_INT 2
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 3
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 3
47400: PUSH
47401: LD_INT 1
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47426: LD_ADDR_VAR 0 16
47430: PUSH
47431: LD_INT 0
47433: PUSH
47434: LD_INT 0
47436: PUSH
47437: EMPTY
47438: LIST
47439: LIST
47440: PUSH
47441: LD_INT 0
47443: PUSH
47444: LD_INT 1
47446: NEG
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: PUSH
47452: LD_INT 1
47454: PUSH
47455: LD_INT 0
47457: PUSH
47458: EMPTY
47459: LIST
47460: LIST
47461: PUSH
47462: LD_INT 1
47464: PUSH
47465: LD_INT 1
47467: PUSH
47468: EMPTY
47469: LIST
47470: LIST
47471: PUSH
47472: LD_INT 0
47474: PUSH
47475: LD_INT 1
47477: PUSH
47478: EMPTY
47479: LIST
47480: LIST
47481: PUSH
47482: LD_INT 1
47484: NEG
47485: PUSH
47486: LD_INT 0
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: PUSH
47493: LD_INT 1
47495: NEG
47496: PUSH
47497: LD_INT 1
47499: NEG
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 1
47507: NEG
47508: PUSH
47509: LD_INT 2
47511: NEG
47512: PUSH
47513: EMPTY
47514: LIST
47515: LIST
47516: PUSH
47517: LD_INT 2
47519: PUSH
47520: LD_INT 1
47522: PUSH
47523: EMPTY
47524: LIST
47525: LIST
47526: PUSH
47527: LD_INT 2
47529: PUSH
47530: LD_INT 2
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PUSH
47537: LD_INT 1
47539: PUSH
47540: LD_INT 2
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 2
47549: NEG
47550: PUSH
47551: LD_INT 1
47553: NEG
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: PUSH
47559: LD_INT 2
47561: NEG
47562: PUSH
47563: LD_INT 2
47565: NEG
47566: PUSH
47567: EMPTY
47568: LIST
47569: LIST
47570: PUSH
47571: LD_INT 3
47573: PUSH
47574: LD_INT 2
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 3
47583: PUSH
47584: LD_INT 3
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 2
47593: PUSH
47594: LD_INT 3
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47619: LD_ADDR_VAR 0 17
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: LD_INT 0
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: LD_INT 0
47636: PUSH
47637: LD_INT 1
47639: NEG
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: PUSH
47645: LD_INT 1
47647: PUSH
47648: LD_INT 0
47650: PUSH
47651: EMPTY
47652: LIST
47653: LIST
47654: PUSH
47655: LD_INT 1
47657: PUSH
47658: LD_INT 1
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PUSH
47665: LD_INT 0
47667: PUSH
47668: LD_INT 1
47670: PUSH
47671: EMPTY
47672: LIST
47673: LIST
47674: PUSH
47675: LD_INT 1
47677: NEG
47678: PUSH
47679: LD_INT 0
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: LD_INT 1
47688: NEG
47689: PUSH
47690: LD_INT 1
47692: NEG
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: PUSH
47698: LD_INT 1
47700: NEG
47701: PUSH
47702: LD_INT 2
47704: NEG
47705: PUSH
47706: EMPTY
47707: LIST
47708: LIST
47709: PUSH
47710: LD_INT 0
47712: PUSH
47713: LD_INT 2
47715: NEG
47716: PUSH
47717: EMPTY
47718: LIST
47719: LIST
47720: PUSH
47721: LD_INT 1
47723: PUSH
47724: LD_INT 1
47726: NEG
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: LD_INT 2
47734: PUSH
47735: LD_INT 0
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PUSH
47742: LD_INT 2
47744: PUSH
47745: LD_INT 1
47747: PUSH
47748: EMPTY
47749: LIST
47750: LIST
47751: PUSH
47752: LD_INT 2
47754: PUSH
47755: LD_INT 2
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 1
47764: PUSH
47765: LD_INT 2
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PUSH
47772: LD_INT 0
47774: PUSH
47775: LD_INT 2
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PUSH
47782: LD_INT 1
47784: NEG
47785: PUSH
47786: LD_INT 1
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 2
47795: NEG
47796: PUSH
47797: LD_INT 0
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: PUSH
47804: LD_INT 2
47806: NEG
47807: PUSH
47808: LD_INT 1
47810: NEG
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 2
47818: NEG
47819: PUSH
47820: LD_INT 2
47822: NEG
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47849: LD_ADDR_VAR 0 18
47853: PUSH
47854: LD_INT 0
47856: PUSH
47857: LD_INT 0
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: PUSH
47864: LD_INT 0
47866: PUSH
47867: LD_INT 1
47869: NEG
47870: PUSH
47871: EMPTY
47872: LIST
47873: LIST
47874: PUSH
47875: LD_INT 1
47877: PUSH
47878: LD_INT 0
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 1
47887: PUSH
47888: LD_INT 1
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: PUSH
47895: LD_INT 0
47897: PUSH
47898: LD_INT 1
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: LD_INT 1
47907: NEG
47908: PUSH
47909: LD_INT 0
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 1
47918: NEG
47919: PUSH
47920: LD_INT 1
47922: NEG
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: PUSH
47928: LD_INT 1
47930: NEG
47931: PUSH
47932: LD_INT 2
47934: NEG
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: PUSH
47940: LD_INT 0
47942: PUSH
47943: LD_INT 2
47945: NEG
47946: PUSH
47947: EMPTY
47948: LIST
47949: LIST
47950: PUSH
47951: LD_INT 1
47953: PUSH
47954: LD_INT 1
47956: NEG
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: PUSH
47962: LD_INT 2
47964: PUSH
47965: LD_INT 0
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: PUSH
47972: LD_INT 2
47974: PUSH
47975: LD_INT 1
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: LD_INT 2
47984: PUSH
47985: LD_INT 2
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 1
47994: PUSH
47995: LD_INT 2
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 0
48004: PUSH
48005: LD_INT 2
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 1
48014: NEG
48015: PUSH
48016: LD_INT 1
48018: PUSH
48019: EMPTY
48020: LIST
48021: LIST
48022: PUSH
48023: LD_INT 2
48025: NEG
48026: PUSH
48027: LD_INT 0
48029: PUSH
48030: EMPTY
48031: LIST
48032: LIST
48033: PUSH
48034: LD_INT 2
48036: NEG
48037: PUSH
48038: LD_INT 1
48040: NEG
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_INT 2
48048: NEG
48049: PUSH
48050: LD_INT 2
48052: NEG
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: LIST
48062: LIST
48063: LIST
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48079: LD_ADDR_VAR 0 19
48083: PUSH
48084: LD_INT 0
48086: PUSH
48087: LD_INT 0
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_INT 0
48096: PUSH
48097: LD_INT 1
48099: NEG
48100: PUSH
48101: EMPTY
48102: LIST
48103: LIST
48104: PUSH
48105: LD_INT 1
48107: PUSH
48108: LD_INT 0
48110: PUSH
48111: EMPTY
48112: LIST
48113: LIST
48114: PUSH
48115: LD_INT 1
48117: PUSH
48118: LD_INT 1
48120: PUSH
48121: EMPTY
48122: LIST
48123: LIST
48124: PUSH
48125: LD_INT 0
48127: PUSH
48128: LD_INT 1
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PUSH
48135: LD_INT 1
48137: NEG
48138: PUSH
48139: LD_INT 0
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: PUSH
48146: LD_INT 1
48148: NEG
48149: PUSH
48150: LD_INT 1
48152: NEG
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 1
48160: NEG
48161: PUSH
48162: LD_INT 2
48164: NEG
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: LD_INT 0
48172: PUSH
48173: LD_INT 2
48175: NEG
48176: PUSH
48177: EMPTY
48178: LIST
48179: LIST
48180: PUSH
48181: LD_INT 1
48183: PUSH
48184: LD_INT 1
48186: NEG
48187: PUSH
48188: EMPTY
48189: LIST
48190: LIST
48191: PUSH
48192: LD_INT 2
48194: PUSH
48195: LD_INT 0
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PUSH
48202: LD_INT 2
48204: PUSH
48205: LD_INT 1
48207: PUSH
48208: EMPTY
48209: LIST
48210: LIST
48211: PUSH
48212: LD_INT 2
48214: PUSH
48215: LD_INT 2
48217: PUSH
48218: EMPTY
48219: LIST
48220: LIST
48221: PUSH
48222: LD_INT 1
48224: PUSH
48225: LD_INT 2
48227: PUSH
48228: EMPTY
48229: LIST
48230: LIST
48231: PUSH
48232: LD_INT 0
48234: PUSH
48235: LD_INT 2
48237: PUSH
48238: EMPTY
48239: LIST
48240: LIST
48241: PUSH
48242: LD_INT 1
48244: NEG
48245: PUSH
48246: LD_INT 1
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: LD_INT 2
48255: NEG
48256: PUSH
48257: LD_INT 0
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: PUSH
48264: LD_INT 2
48266: NEG
48267: PUSH
48268: LD_INT 1
48270: NEG
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 2
48278: NEG
48279: PUSH
48280: LD_INT 2
48282: NEG
48283: PUSH
48284: EMPTY
48285: LIST
48286: LIST
48287: PUSH
48288: EMPTY
48289: LIST
48290: LIST
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: LIST
48299: LIST
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: LIST
48306: LIST
48307: LIST
48308: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48309: LD_ADDR_VAR 0 20
48313: PUSH
48314: LD_INT 0
48316: PUSH
48317: LD_INT 0
48319: PUSH
48320: EMPTY
48321: LIST
48322: LIST
48323: PUSH
48324: LD_INT 0
48326: PUSH
48327: LD_INT 1
48329: NEG
48330: PUSH
48331: EMPTY
48332: LIST
48333: LIST
48334: PUSH
48335: LD_INT 1
48337: PUSH
48338: LD_INT 0
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PUSH
48345: LD_INT 1
48347: PUSH
48348: LD_INT 1
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 0
48357: PUSH
48358: LD_INT 1
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: PUSH
48365: LD_INT 1
48367: NEG
48368: PUSH
48369: LD_INT 0
48371: PUSH
48372: EMPTY
48373: LIST
48374: LIST
48375: PUSH
48376: LD_INT 1
48378: NEG
48379: PUSH
48380: LD_INT 1
48382: NEG
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: LD_INT 1
48390: NEG
48391: PUSH
48392: LD_INT 2
48394: NEG
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: PUSH
48400: LD_INT 0
48402: PUSH
48403: LD_INT 2
48405: NEG
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 1
48413: PUSH
48414: LD_INT 1
48416: NEG
48417: PUSH
48418: EMPTY
48419: LIST
48420: LIST
48421: PUSH
48422: LD_INT 2
48424: PUSH
48425: LD_INT 0
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: PUSH
48432: LD_INT 2
48434: PUSH
48435: LD_INT 1
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 2
48444: PUSH
48445: LD_INT 2
48447: PUSH
48448: EMPTY
48449: LIST
48450: LIST
48451: PUSH
48452: LD_INT 1
48454: PUSH
48455: LD_INT 2
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: PUSH
48462: LD_INT 0
48464: PUSH
48465: LD_INT 2
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: PUSH
48472: LD_INT 1
48474: NEG
48475: PUSH
48476: LD_INT 1
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 2
48485: NEG
48486: PUSH
48487: LD_INT 0
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: PUSH
48494: LD_INT 2
48496: NEG
48497: PUSH
48498: LD_INT 1
48500: NEG
48501: PUSH
48502: EMPTY
48503: LIST
48504: LIST
48505: PUSH
48506: LD_INT 2
48508: NEG
48509: PUSH
48510: LD_INT 2
48512: NEG
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: EMPTY
48519: LIST
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: LIST
48530: LIST
48531: LIST
48532: LIST
48533: LIST
48534: LIST
48535: LIST
48536: LIST
48537: LIST
48538: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48539: LD_ADDR_VAR 0 21
48543: PUSH
48544: LD_INT 0
48546: PUSH
48547: LD_INT 0
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: PUSH
48554: LD_INT 0
48556: PUSH
48557: LD_INT 1
48559: NEG
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: PUSH
48565: LD_INT 1
48567: PUSH
48568: LD_INT 0
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 1
48577: PUSH
48578: LD_INT 1
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: PUSH
48585: LD_INT 0
48587: PUSH
48588: LD_INT 1
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: PUSH
48595: LD_INT 1
48597: NEG
48598: PUSH
48599: LD_INT 0
48601: PUSH
48602: EMPTY
48603: LIST
48604: LIST
48605: PUSH
48606: LD_INT 1
48608: NEG
48609: PUSH
48610: LD_INT 1
48612: NEG
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 1
48620: NEG
48621: PUSH
48622: LD_INT 2
48624: NEG
48625: PUSH
48626: EMPTY
48627: LIST
48628: LIST
48629: PUSH
48630: LD_INT 0
48632: PUSH
48633: LD_INT 2
48635: NEG
48636: PUSH
48637: EMPTY
48638: LIST
48639: LIST
48640: PUSH
48641: LD_INT 1
48643: PUSH
48644: LD_INT 1
48646: NEG
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 2
48654: PUSH
48655: LD_INT 0
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: LD_INT 2
48664: PUSH
48665: LD_INT 1
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: PUSH
48672: LD_INT 2
48674: PUSH
48675: LD_INT 2
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: PUSH
48682: LD_INT 1
48684: PUSH
48685: LD_INT 2
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 0
48694: PUSH
48695: LD_INT 2
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: LD_INT 1
48704: NEG
48705: PUSH
48706: LD_INT 1
48708: PUSH
48709: EMPTY
48710: LIST
48711: LIST
48712: PUSH
48713: LD_INT 2
48715: NEG
48716: PUSH
48717: LD_INT 0
48719: PUSH
48720: EMPTY
48721: LIST
48722: LIST
48723: PUSH
48724: LD_INT 2
48726: NEG
48727: PUSH
48728: LD_INT 1
48730: NEG
48731: PUSH
48732: EMPTY
48733: LIST
48734: LIST
48735: PUSH
48736: LD_INT 2
48738: NEG
48739: PUSH
48740: LD_INT 2
48742: NEG
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: EMPTY
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: LIST
48759: LIST
48760: LIST
48761: LIST
48762: LIST
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48769: LD_ADDR_VAR 0 22
48773: PUSH
48774: LD_INT 0
48776: PUSH
48777: LD_INT 0
48779: PUSH
48780: EMPTY
48781: LIST
48782: LIST
48783: PUSH
48784: LD_INT 0
48786: PUSH
48787: LD_INT 1
48789: NEG
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 1
48797: PUSH
48798: LD_INT 0
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PUSH
48805: LD_INT 1
48807: PUSH
48808: LD_INT 1
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: PUSH
48815: LD_INT 0
48817: PUSH
48818: LD_INT 1
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PUSH
48825: LD_INT 1
48827: NEG
48828: PUSH
48829: LD_INT 0
48831: PUSH
48832: EMPTY
48833: LIST
48834: LIST
48835: PUSH
48836: LD_INT 1
48838: NEG
48839: PUSH
48840: LD_INT 1
48842: NEG
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 1
48850: NEG
48851: PUSH
48852: LD_INT 2
48854: NEG
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 0
48862: PUSH
48863: LD_INT 2
48865: NEG
48866: PUSH
48867: EMPTY
48868: LIST
48869: LIST
48870: PUSH
48871: LD_INT 1
48873: PUSH
48874: LD_INT 1
48876: NEG
48877: PUSH
48878: EMPTY
48879: LIST
48880: LIST
48881: PUSH
48882: LD_INT 2
48884: PUSH
48885: LD_INT 0
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 2
48894: PUSH
48895: LD_INT 1
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PUSH
48902: LD_INT 2
48904: PUSH
48905: LD_INT 2
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PUSH
48912: LD_INT 1
48914: PUSH
48915: LD_INT 2
48917: PUSH
48918: EMPTY
48919: LIST
48920: LIST
48921: PUSH
48922: LD_INT 0
48924: PUSH
48925: LD_INT 2
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: PUSH
48932: LD_INT 1
48934: NEG
48935: PUSH
48936: LD_INT 1
48938: PUSH
48939: EMPTY
48940: LIST
48941: LIST
48942: PUSH
48943: LD_INT 2
48945: NEG
48946: PUSH
48947: LD_INT 0
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_INT 2
48956: NEG
48957: PUSH
48958: LD_INT 1
48960: NEG
48961: PUSH
48962: EMPTY
48963: LIST
48964: LIST
48965: PUSH
48966: LD_INT 2
48968: NEG
48969: PUSH
48970: LD_INT 2
48972: NEG
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: LIST
48982: LIST
48983: LIST
48984: LIST
48985: LIST
48986: LIST
48987: LIST
48988: LIST
48989: LIST
48990: LIST
48991: LIST
48992: LIST
48993: LIST
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
48999: LD_ADDR_VAR 0 23
49003: PUSH
49004: LD_INT 0
49006: PUSH
49007: LD_INT 0
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 0
49016: PUSH
49017: LD_INT 1
49019: NEG
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: LD_INT 1
49027: PUSH
49028: LD_INT 0
49030: PUSH
49031: EMPTY
49032: LIST
49033: LIST
49034: PUSH
49035: LD_INT 1
49037: PUSH
49038: LD_INT 1
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: PUSH
49045: LD_INT 0
49047: PUSH
49048: LD_INT 1
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: PUSH
49055: LD_INT 1
49057: NEG
49058: PUSH
49059: LD_INT 0
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 1
49068: NEG
49069: PUSH
49070: LD_INT 1
49072: NEG
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: LD_INT 1
49080: NEG
49081: PUSH
49082: LD_INT 2
49084: NEG
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 0
49092: PUSH
49093: LD_INT 2
49095: NEG
49096: PUSH
49097: EMPTY
49098: LIST
49099: LIST
49100: PUSH
49101: LD_INT 1
49103: PUSH
49104: LD_INT 1
49106: NEG
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PUSH
49112: LD_INT 2
49114: PUSH
49115: LD_INT 0
49117: PUSH
49118: EMPTY
49119: LIST
49120: LIST
49121: PUSH
49122: LD_INT 2
49124: PUSH
49125: LD_INT 1
49127: PUSH
49128: EMPTY
49129: LIST
49130: LIST
49131: PUSH
49132: LD_INT 2
49134: PUSH
49135: LD_INT 2
49137: PUSH
49138: EMPTY
49139: LIST
49140: LIST
49141: PUSH
49142: LD_INT 1
49144: PUSH
49145: LD_INT 2
49147: PUSH
49148: EMPTY
49149: LIST
49150: LIST
49151: PUSH
49152: LD_INT 0
49154: PUSH
49155: LD_INT 2
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 1
49164: NEG
49165: PUSH
49166: LD_INT 1
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 2
49175: NEG
49176: PUSH
49177: LD_INT 0
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: PUSH
49184: LD_INT 2
49186: NEG
49187: PUSH
49188: LD_INT 1
49190: NEG
49191: PUSH
49192: EMPTY
49193: LIST
49194: LIST
49195: PUSH
49196: LD_INT 2
49198: NEG
49199: PUSH
49200: LD_INT 2
49202: NEG
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 2
49210: NEG
49211: PUSH
49212: LD_INT 3
49214: NEG
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: PUSH
49220: LD_INT 1
49222: NEG
49223: PUSH
49224: LD_INT 3
49226: NEG
49227: PUSH
49228: EMPTY
49229: LIST
49230: LIST
49231: PUSH
49232: LD_INT 1
49234: PUSH
49235: LD_INT 2
49237: NEG
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: PUSH
49243: LD_INT 2
49245: PUSH
49246: LD_INT 1
49248: NEG
49249: PUSH
49250: EMPTY
49251: LIST
49252: LIST
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: LIST
49258: LIST
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: LIST
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: LIST
49269: LIST
49270: LIST
49271: LIST
49272: LIST
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
49279: LD_ADDR_VAR 0 24
49283: PUSH
49284: LD_INT 0
49286: PUSH
49287: LD_INT 0
49289: PUSH
49290: EMPTY
49291: LIST
49292: LIST
49293: PUSH
49294: LD_INT 0
49296: PUSH
49297: LD_INT 1
49299: NEG
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: PUSH
49305: LD_INT 1
49307: PUSH
49308: LD_INT 0
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: PUSH
49315: LD_INT 1
49317: PUSH
49318: LD_INT 1
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PUSH
49325: LD_INT 0
49327: PUSH
49328: LD_INT 1
49330: PUSH
49331: EMPTY
49332: LIST
49333: LIST
49334: PUSH
49335: LD_INT 1
49337: NEG
49338: PUSH
49339: LD_INT 0
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: PUSH
49346: LD_INT 1
49348: NEG
49349: PUSH
49350: LD_INT 1
49352: NEG
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: LD_INT 1
49360: NEG
49361: PUSH
49362: LD_INT 2
49364: NEG
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: PUSH
49370: LD_INT 0
49372: PUSH
49373: LD_INT 2
49375: NEG
49376: PUSH
49377: EMPTY
49378: LIST
49379: LIST
49380: PUSH
49381: LD_INT 1
49383: PUSH
49384: LD_INT 1
49386: NEG
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 2
49394: PUSH
49395: LD_INT 0
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: LD_INT 2
49404: PUSH
49405: LD_INT 1
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PUSH
49412: LD_INT 2
49414: PUSH
49415: LD_INT 2
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: PUSH
49422: LD_INT 1
49424: PUSH
49425: LD_INT 2
49427: PUSH
49428: EMPTY
49429: LIST
49430: LIST
49431: PUSH
49432: LD_INT 0
49434: PUSH
49435: LD_INT 2
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: PUSH
49442: LD_INT 1
49444: NEG
49445: PUSH
49446: LD_INT 1
49448: PUSH
49449: EMPTY
49450: LIST
49451: LIST
49452: PUSH
49453: LD_INT 2
49455: NEG
49456: PUSH
49457: LD_INT 0
49459: PUSH
49460: EMPTY
49461: LIST
49462: LIST
49463: PUSH
49464: LD_INT 2
49466: NEG
49467: PUSH
49468: LD_INT 1
49470: NEG
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: PUSH
49476: LD_INT 2
49478: NEG
49479: PUSH
49480: LD_INT 2
49482: NEG
49483: PUSH
49484: EMPTY
49485: LIST
49486: LIST
49487: PUSH
49488: LD_INT 1
49490: PUSH
49491: LD_INT 2
49493: NEG
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: PUSH
49499: LD_INT 2
49501: PUSH
49502: LD_INT 1
49504: NEG
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 3
49512: PUSH
49513: LD_INT 1
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 3
49522: PUSH
49523: LD_INT 2
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: LIST
49534: LIST
49535: LIST
49536: LIST
49537: LIST
49538: LIST
49539: LIST
49540: LIST
49541: LIST
49542: LIST
49543: LIST
49544: LIST
49545: LIST
49546: LIST
49547: LIST
49548: LIST
49549: LIST
49550: LIST
49551: LIST
49552: LIST
49553: LIST
49554: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
49555: LD_ADDR_VAR 0 25
49559: PUSH
49560: LD_INT 0
49562: PUSH
49563: LD_INT 0
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PUSH
49570: LD_INT 0
49572: PUSH
49573: LD_INT 1
49575: NEG
49576: PUSH
49577: EMPTY
49578: LIST
49579: LIST
49580: PUSH
49581: LD_INT 1
49583: PUSH
49584: LD_INT 0
49586: PUSH
49587: EMPTY
49588: LIST
49589: LIST
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: LD_INT 1
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: LD_INT 1
49606: PUSH
49607: EMPTY
49608: LIST
49609: LIST
49610: PUSH
49611: LD_INT 1
49613: NEG
49614: PUSH
49615: LD_INT 0
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: PUSH
49622: LD_INT 1
49624: NEG
49625: PUSH
49626: LD_INT 1
49628: NEG
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: LD_INT 1
49636: NEG
49637: PUSH
49638: LD_INT 2
49640: NEG
49641: PUSH
49642: EMPTY
49643: LIST
49644: LIST
49645: PUSH
49646: LD_INT 0
49648: PUSH
49649: LD_INT 2
49651: NEG
49652: PUSH
49653: EMPTY
49654: LIST
49655: LIST
49656: PUSH
49657: LD_INT 1
49659: PUSH
49660: LD_INT 1
49662: NEG
49663: PUSH
49664: EMPTY
49665: LIST
49666: LIST
49667: PUSH
49668: LD_INT 2
49670: PUSH
49671: LD_INT 0
49673: PUSH
49674: EMPTY
49675: LIST
49676: LIST
49677: PUSH
49678: LD_INT 2
49680: PUSH
49681: LD_INT 1
49683: PUSH
49684: EMPTY
49685: LIST
49686: LIST
49687: PUSH
49688: LD_INT 2
49690: PUSH
49691: LD_INT 2
49693: PUSH
49694: EMPTY
49695: LIST
49696: LIST
49697: PUSH
49698: LD_INT 1
49700: PUSH
49701: LD_INT 2
49703: PUSH
49704: EMPTY
49705: LIST
49706: LIST
49707: PUSH
49708: LD_INT 0
49710: PUSH
49711: LD_INT 2
49713: PUSH
49714: EMPTY
49715: LIST
49716: LIST
49717: PUSH
49718: LD_INT 1
49720: NEG
49721: PUSH
49722: LD_INT 1
49724: PUSH
49725: EMPTY
49726: LIST
49727: LIST
49728: PUSH
49729: LD_INT 2
49731: NEG
49732: PUSH
49733: LD_INT 0
49735: PUSH
49736: EMPTY
49737: LIST
49738: LIST
49739: PUSH
49740: LD_INT 2
49742: NEG
49743: PUSH
49744: LD_INT 1
49746: NEG
49747: PUSH
49748: EMPTY
49749: LIST
49750: LIST
49751: PUSH
49752: LD_INT 2
49754: NEG
49755: PUSH
49756: LD_INT 2
49758: NEG
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: PUSH
49764: LD_INT 3
49766: PUSH
49767: LD_INT 1
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: PUSH
49774: LD_INT 3
49776: PUSH
49777: LD_INT 2
49779: PUSH
49780: EMPTY
49781: LIST
49782: LIST
49783: PUSH
49784: LD_INT 2
49786: PUSH
49787: LD_INT 3
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 1
49796: PUSH
49797: LD_INT 3
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: PUSH
49804: EMPTY
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: LIST
49814: LIST
49815: LIST
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: LIST
49821: LIST
49822: LIST
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
49829: LD_ADDR_VAR 0 26
49833: PUSH
49834: LD_INT 0
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PUSH
49844: LD_INT 0
49846: PUSH
49847: LD_INT 1
49849: NEG
49850: PUSH
49851: EMPTY
49852: LIST
49853: LIST
49854: PUSH
49855: LD_INT 1
49857: PUSH
49858: LD_INT 0
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: PUSH
49865: LD_INT 1
49867: PUSH
49868: LD_INT 1
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PUSH
49875: LD_INT 0
49877: PUSH
49878: LD_INT 1
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: PUSH
49885: LD_INT 1
49887: NEG
49888: PUSH
49889: LD_INT 0
49891: PUSH
49892: EMPTY
49893: LIST
49894: LIST
49895: PUSH
49896: LD_INT 1
49898: NEG
49899: PUSH
49900: LD_INT 1
49902: NEG
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: PUSH
49908: LD_INT 1
49910: NEG
49911: PUSH
49912: LD_INT 2
49914: NEG
49915: PUSH
49916: EMPTY
49917: LIST
49918: LIST
49919: PUSH
49920: LD_INT 0
49922: PUSH
49923: LD_INT 2
49925: NEG
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: PUSH
49931: LD_INT 1
49933: PUSH
49934: LD_INT 1
49936: NEG
49937: PUSH
49938: EMPTY
49939: LIST
49940: LIST
49941: PUSH
49942: LD_INT 2
49944: PUSH
49945: LD_INT 0
49947: PUSH
49948: EMPTY
49949: LIST
49950: LIST
49951: PUSH
49952: LD_INT 2
49954: PUSH
49955: LD_INT 1
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: PUSH
49962: LD_INT 2
49964: PUSH
49965: LD_INT 2
49967: PUSH
49968: EMPTY
49969: LIST
49970: LIST
49971: PUSH
49972: LD_INT 1
49974: PUSH
49975: LD_INT 2
49977: PUSH
49978: EMPTY
49979: LIST
49980: LIST
49981: PUSH
49982: LD_INT 0
49984: PUSH
49985: LD_INT 2
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PUSH
49992: LD_INT 1
49994: NEG
49995: PUSH
49996: LD_INT 1
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: PUSH
50003: LD_INT 2
50005: NEG
50006: PUSH
50007: LD_INT 0
50009: PUSH
50010: EMPTY
50011: LIST
50012: LIST
50013: PUSH
50014: LD_INT 2
50016: NEG
50017: PUSH
50018: LD_INT 1
50020: NEG
50021: PUSH
50022: EMPTY
50023: LIST
50024: LIST
50025: PUSH
50026: LD_INT 2
50028: NEG
50029: PUSH
50030: LD_INT 2
50032: NEG
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: PUSH
50038: LD_INT 2
50040: PUSH
50041: LD_INT 3
50043: PUSH
50044: EMPTY
50045: LIST
50046: LIST
50047: PUSH
50048: LD_INT 1
50050: PUSH
50051: LD_INT 3
50053: PUSH
50054: EMPTY
50055: LIST
50056: LIST
50057: PUSH
50058: LD_INT 1
50060: NEG
50061: PUSH
50062: LD_INT 2
50064: PUSH
50065: EMPTY
50066: LIST
50067: LIST
50068: PUSH
50069: LD_INT 2
50071: NEG
50072: PUSH
50073: LD_INT 1
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PUSH
50080: EMPTY
50081: LIST
50082: LIST
50083: LIST
50084: LIST
50085: LIST
50086: LIST
50087: LIST
50088: LIST
50089: LIST
50090: LIST
50091: LIST
50092: LIST
50093: LIST
50094: LIST
50095: LIST
50096: LIST
50097: LIST
50098: LIST
50099: LIST
50100: LIST
50101: LIST
50102: LIST
50103: LIST
50104: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
50105: LD_ADDR_VAR 0 27
50109: PUSH
50110: LD_INT 0
50112: PUSH
50113: LD_INT 0
50115: PUSH
50116: EMPTY
50117: LIST
50118: LIST
50119: PUSH
50120: LD_INT 0
50122: PUSH
50123: LD_INT 1
50125: NEG
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: LD_INT 1
50133: PUSH
50134: LD_INT 0
50136: PUSH
50137: EMPTY
50138: LIST
50139: LIST
50140: PUSH
50141: LD_INT 1
50143: PUSH
50144: LD_INT 1
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: PUSH
50151: LD_INT 0
50153: PUSH
50154: LD_INT 1
50156: PUSH
50157: EMPTY
50158: LIST
50159: LIST
50160: PUSH
50161: LD_INT 1
50163: NEG
50164: PUSH
50165: LD_INT 0
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PUSH
50172: LD_INT 1
50174: NEG
50175: PUSH
50176: LD_INT 1
50178: NEG
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: LD_INT 1
50186: NEG
50187: PUSH
50188: LD_INT 2
50190: NEG
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: PUSH
50196: LD_INT 0
50198: PUSH
50199: LD_INT 2
50201: NEG
50202: PUSH
50203: EMPTY
50204: LIST
50205: LIST
50206: PUSH
50207: LD_INT 1
50209: PUSH
50210: LD_INT 1
50212: NEG
50213: PUSH
50214: EMPTY
50215: LIST
50216: LIST
50217: PUSH
50218: LD_INT 2
50220: PUSH
50221: LD_INT 0
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PUSH
50228: LD_INT 2
50230: PUSH
50231: LD_INT 1
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 2
50240: PUSH
50241: LD_INT 2
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: PUSH
50248: LD_INT 1
50250: PUSH
50251: LD_INT 2
50253: PUSH
50254: EMPTY
50255: LIST
50256: LIST
50257: PUSH
50258: LD_INT 0
50260: PUSH
50261: LD_INT 2
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: LD_INT 1
50270: NEG
50271: PUSH
50272: LD_INT 1
50274: PUSH
50275: EMPTY
50276: LIST
50277: LIST
50278: PUSH
50279: LD_INT 2
50281: NEG
50282: PUSH
50283: LD_INT 0
50285: PUSH
50286: EMPTY
50287: LIST
50288: LIST
50289: PUSH
50290: LD_INT 2
50292: NEG
50293: PUSH
50294: LD_INT 1
50296: NEG
50297: PUSH
50298: EMPTY
50299: LIST
50300: LIST
50301: PUSH
50302: LD_INT 2
50304: NEG
50305: PUSH
50306: LD_INT 2
50308: NEG
50309: PUSH
50310: EMPTY
50311: LIST
50312: LIST
50313: PUSH
50314: LD_INT 1
50316: NEG
50317: PUSH
50318: LD_INT 2
50320: PUSH
50321: EMPTY
50322: LIST
50323: LIST
50324: PUSH
50325: LD_INT 2
50327: NEG
50328: PUSH
50329: LD_INT 1
50331: PUSH
50332: EMPTY
50333: LIST
50334: LIST
50335: PUSH
50336: LD_INT 3
50338: NEG
50339: PUSH
50340: LD_INT 1
50342: NEG
50343: PUSH
50344: EMPTY
50345: LIST
50346: LIST
50347: PUSH
50348: LD_INT 3
50350: NEG
50351: PUSH
50352: LD_INT 2
50354: NEG
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: LIST
50364: LIST
50365: LIST
50366: LIST
50367: LIST
50368: LIST
50369: LIST
50370: LIST
50371: LIST
50372: LIST
50373: LIST
50374: LIST
50375: LIST
50376: LIST
50377: LIST
50378: LIST
50379: LIST
50380: LIST
50381: LIST
50382: LIST
50383: LIST
50384: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
50385: LD_ADDR_VAR 0 28
50389: PUSH
50390: LD_INT 0
50392: PUSH
50393: LD_INT 0
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: PUSH
50400: LD_INT 0
50402: PUSH
50403: LD_INT 1
50405: NEG
50406: PUSH
50407: EMPTY
50408: LIST
50409: LIST
50410: PUSH
50411: LD_INT 1
50413: PUSH
50414: LD_INT 0
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: LD_INT 1
50423: PUSH
50424: LD_INT 1
50426: PUSH
50427: EMPTY
50428: LIST
50429: LIST
50430: PUSH
50431: LD_INT 0
50433: PUSH
50434: LD_INT 1
50436: PUSH
50437: EMPTY
50438: LIST
50439: LIST
50440: PUSH
50441: LD_INT 1
50443: NEG
50444: PUSH
50445: LD_INT 0
50447: PUSH
50448: EMPTY
50449: LIST
50450: LIST
50451: PUSH
50452: LD_INT 1
50454: NEG
50455: PUSH
50456: LD_INT 1
50458: NEG
50459: PUSH
50460: EMPTY
50461: LIST
50462: LIST
50463: PUSH
50464: LD_INT 1
50466: NEG
50467: PUSH
50468: LD_INT 2
50470: NEG
50471: PUSH
50472: EMPTY
50473: LIST
50474: LIST
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: LD_INT 2
50481: NEG
50482: PUSH
50483: EMPTY
50484: LIST
50485: LIST
50486: PUSH
50487: LD_INT 1
50489: PUSH
50490: LD_INT 1
50492: NEG
50493: PUSH
50494: EMPTY
50495: LIST
50496: LIST
50497: PUSH
50498: LD_INT 2
50500: PUSH
50501: LD_INT 0
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PUSH
50508: LD_INT 2
50510: PUSH
50511: LD_INT 1
50513: PUSH
50514: EMPTY
50515: LIST
50516: LIST
50517: PUSH
50518: LD_INT 2
50520: PUSH
50521: LD_INT 2
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: PUSH
50528: LD_INT 1
50530: PUSH
50531: LD_INT 2
50533: PUSH
50534: EMPTY
50535: LIST
50536: LIST
50537: PUSH
50538: LD_INT 0
50540: PUSH
50541: LD_INT 2
50543: PUSH
50544: EMPTY
50545: LIST
50546: LIST
50547: PUSH
50548: LD_INT 1
50550: NEG
50551: PUSH
50552: LD_INT 1
50554: PUSH
50555: EMPTY
50556: LIST
50557: LIST
50558: PUSH
50559: LD_INT 2
50561: NEG
50562: PUSH
50563: LD_INT 0
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: PUSH
50570: LD_INT 2
50572: NEG
50573: PUSH
50574: LD_INT 1
50576: NEG
50577: PUSH
50578: EMPTY
50579: LIST
50580: LIST
50581: PUSH
50582: LD_INT 2
50584: NEG
50585: PUSH
50586: LD_INT 2
50588: NEG
50589: PUSH
50590: EMPTY
50591: LIST
50592: LIST
50593: PUSH
50594: LD_INT 2
50596: NEG
50597: PUSH
50598: LD_INT 3
50600: NEG
50601: PUSH
50602: EMPTY
50603: LIST
50604: LIST
50605: PUSH
50606: LD_INT 1
50608: NEG
50609: PUSH
50610: LD_INT 3
50612: NEG
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: LD_INT 3
50620: NEG
50621: PUSH
50622: LD_INT 1
50624: NEG
50625: PUSH
50626: EMPTY
50627: LIST
50628: LIST
50629: PUSH
50630: LD_INT 3
50632: NEG
50633: PUSH
50634: LD_INT 2
50636: NEG
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: LIST
50646: LIST
50647: LIST
50648: LIST
50649: LIST
50650: LIST
50651: LIST
50652: LIST
50653: LIST
50654: LIST
50655: LIST
50656: LIST
50657: LIST
50658: LIST
50659: LIST
50660: LIST
50661: LIST
50662: LIST
50663: LIST
50664: LIST
50665: LIST
50666: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
50667: LD_ADDR_VAR 0 29
50671: PUSH
50672: LD_INT 0
50674: PUSH
50675: LD_INT 0
50677: PUSH
50678: EMPTY
50679: LIST
50680: LIST
50681: PUSH
50682: LD_INT 0
50684: PUSH
50685: LD_INT 1
50687: NEG
50688: PUSH
50689: EMPTY
50690: LIST
50691: LIST
50692: PUSH
50693: LD_INT 1
50695: PUSH
50696: LD_INT 0
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: PUSH
50703: LD_INT 1
50705: PUSH
50706: LD_INT 1
50708: PUSH
50709: EMPTY
50710: LIST
50711: LIST
50712: PUSH
50713: LD_INT 0
50715: PUSH
50716: LD_INT 1
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 1
50725: NEG
50726: PUSH
50727: LD_INT 0
50729: PUSH
50730: EMPTY
50731: LIST
50732: LIST
50733: PUSH
50734: LD_INT 1
50736: NEG
50737: PUSH
50738: LD_INT 1
50740: NEG
50741: PUSH
50742: EMPTY
50743: LIST
50744: LIST
50745: PUSH
50746: LD_INT 1
50748: NEG
50749: PUSH
50750: LD_INT 2
50752: NEG
50753: PUSH
50754: EMPTY
50755: LIST
50756: LIST
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: LD_INT 2
50763: NEG
50764: PUSH
50765: EMPTY
50766: LIST
50767: LIST
50768: PUSH
50769: LD_INT 1
50771: PUSH
50772: LD_INT 1
50774: NEG
50775: PUSH
50776: EMPTY
50777: LIST
50778: LIST
50779: PUSH
50780: LD_INT 2
50782: PUSH
50783: LD_INT 0
50785: PUSH
50786: EMPTY
50787: LIST
50788: LIST
50789: PUSH
50790: LD_INT 2
50792: PUSH
50793: LD_INT 1
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: LD_INT 1
50802: PUSH
50803: LD_INT 2
50805: PUSH
50806: EMPTY
50807: LIST
50808: LIST
50809: PUSH
50810: LD_INT 0
50812: PUSH
50813: LD_INT 2
50815: PUSH
50816: EMPTY
50817: LIST
50818: LIST
50819: PUSH
50820: LD_INT 1
50822: NEG
50823: PUSH
50824: LD_INT 1
50826: PUSH
50827: EMPTY
50828: LIST
50829: LIST
50830: PUSH
50831: LD_INT 2
50833: NEG
50834: PUSH
50835: LD_INT 1
50837: NEG
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 2
50845: NEG
50846: PUSH
50847: LD_INT 2
50849: NEG
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: PUSH
50855: LD_INT 2
50857: NEG
50858: PUSH
50859: LD_INT 3
50861: NEG
50862: PUSH
50863: EMPTY
50864: LIST
50865: LIST
50866: PUSH
50867: LD_INT 2
50869: PUSH
50870: LD_INT 1
50872: NEG
50873: PUSH
50874: EMPTY
50875: LIST
50876: LIST
50877: PUSH
50878: LD_INT 3
50880: PUSH
50881: LD_INT 1
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PUSH
50888: LD_INT 1
50890: PUSH
50891: LD_INT 3
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: LD_INT 1
50900: NEG
50901: PUSH
50902: LD_INT 2
50904: PUSH
50905: EMPTY
50906: LIST
50907: LIST
50908: PUSH
50909: LD_INT 3
50911: NEG
50912: PUSH
50913: LD_INT 2
50915: NEG
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: PUSH
50921: EMPTY
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
50946: LD_ADDR_VAR 0 30
50950: PUSH
50951: LD_INT 0
50953: PUSH
50954: LD_INT 0
50956: PUSH
50957: EMPTY
50958: LIST
50959: LIST
50960: PUSH
50961: LD_INT 0
50963: PUSH
50964: LD_INT 1
50966: NEG
50967: PUSH
50968: EMPTY
50969: LIST
50970: LIST
50971: PUSH
50972: LD_INT 1
50974: PUSH
50975: LD_INT 0
50977: PUSH
50978: EMPTY
50979: LIST
50980: LIST
50981: PUSH
50982: LD_INT 1
50984: PUSH
50985: LD_INT 1
50987: PUSH
50988: EMPTY
50989: LIST
50990: LIST
50991: PUSH
50992: LD_INT 0
50994: PUSH
50995: LD_INT 1
50997: PUSH
50998: EMPTY
50999: LIST
51000: LIST
51001: PUSH
51002: LD_INT 1
51004: NEG
51005: PUSH
51006: LD_INT 0
51008: PUSH
51009: EMPTY
51010: LIST
51011: LIST
51012: PUSH
51013: LD_INT 1
51015: NEG
51016: PUSH
51017: LD_INT 1
51019: NEG
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: PUSH
51025: LD_INT 1
51027: NEG
51028: PUSH
51029: LD_INT 2
51031: NEG
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: PUSH
51037: LD_INT 0
51039: PUSH
51040: LD_INT 2
51042: NEG
51043: PUSH
51044: EMPTY
51045: LIST
51046: LIST
51047: PUSH
51048: LD_INT 1
51050: PUSH
51051: LD_INT 1
51053: NEG
51054: PUSH
51055: EMPTY
51056: LIST
51057: LIST
51058: PUSH
51059: LD_INT 2
51061: PUSH
51062: LD_INT 0
51064: PUSH
51065: EMPTY
51066: LIST
51067: LIST
51068: PUSH
51069: LD_INT 2
51071: PUSH
51072: LD_INT 1
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: PUSH
51079: LD_INT 2
51081: PUSH
51082: LD_INT 2
51084: PUSH
51085: EMPTY
51086: LIST
51087: LIST
51088: PUSH
51089: LD_INT 1
51091: PUSH
51092: LD_INT 2
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: PUSH
51099: LD_INT 1
51101: NEG
51102: PUSH
51103: LD_INT 1
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: PUSH
51110: LD_INT 2
51112: NEG
51113: PUSH
51114: LD_INT 0
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: PUSH
51121: LD_INT 2
51123: NEG
51124: PUSH
51125: LD_INT 1
51127: NEG
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: PUSH
51133: LD_INT 1
51135: NEG
51136: PUSH
51137: LD_INT 3
51139: NEG
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: PUSH
51145: LD_INT 1
51147: PUSH
51148: LD_INT 2
51150: NEG
51151: PUSH
51152: EMPTY
51153: LIST
51154: LIST
51155: PUSH
51156: LD_INT 3
51158: PUSH
51159: LD_INT 2
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: PUSH
51166: LD_INT 2
51168: PUSH
51169: LD_INT 3
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PUSH
51176: LD_INT 2
51178: NEG
51179: PUSH
51180: LD_INT 1
51182: PUSH
51183: EMPTY
51184: LIST
51185: LIST
51186: PUSH
51187: LD_INT 3
51189: NEG
51190: PUSH
51191: LD_INT 1
51193: NEG
51194: PUSH
51195: EMPTY
51196: LIST
51197: LIST
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: LIST
51203: LIST
51204: LIST
51205: LIST
51206: LIST
51207: LIST
51208: LIST
51209: LIST
51210: LIST
51211: LIST
51212: LIST
51213: LIST
51214: LIST
51215: LIST
51216: LIST
51217: LIST
51218: LIST
51219: LIST
51220: LIST
51221: LIST
51222: LIST
51223: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
51224: LD_ADDR_VAR 0 31
51228: PUSH
51229: LD_INT 0
51231: PUSH
51232: LD_INT 0
51234: PUSH
51235: EMPTY
51236: LIST
51237: LIST
51238: PUSH
51239: LD_INT 0
51241: PUSH
51242: LD_INT 1
51244: NEG
51245: PUSH
51246: EMPTY
51247: LIST
51248: LIST
51249: PUSH
51250: LD_INT 1
51252: PUSH
51253: LD_INT 0
51255: PUSH
51256: EMPTY
51257: LIST
51258: LIST
51259: PUSH
51260: LD_INT 1
51262: PUSH
51263: LD_INT 1
51265: PUSH
51266: EMPTY
51267: LIST
51268: LIST
51269: PUSH
51270: LD_INT 0
51272: PUSH
51273: LD_INT 1
51275: PUSH
51276: EMPTY
51277: LIST
51278: LIST
51279: PUSH
51280: LD_INT 1
51282: NEG
51283: PUSH
51284: LD_INT 0
51286: PUSH
51287: EMPTY
51288: LIST
51289: LIST
51290: PUSH
51291: LD_INT 1
51293: NEG
51294: PUSH
51295: LD_INT 1
51297: NEG
51298: PUSH
51299: EMPTY
51300: LIST
51301: LIST
51302: PUSH
51303: LD_INT 1
51305: NEG
51306: PUSH
51307: LD_INT 2
51309: NEG
51310: PUSH
51311: EMPTY
51312: LIST
51313: LIST
51314: PUSH
51315: LD_INT 1
51317: PUSH
51318: LD_INT 1
51320: NEG
51321: PUSH
51322: EMPTY
51323: LIST
51324: LIST
51325: PUSH
51326: LD_INT 2
51328: PUSH
51329: LD_INT 0
51331: PUSH
51332: EMPTY
51333: LIST
51334: LIST
51335: PUSH
51336: LD_INT 2
51338: PUSH
51339: LD_INT 1
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 2
51348: PUSH
51349: LD_INT 2
51351: PUSH
51352: EMPTY
51353: LIST
51354: LIST
51355: PUSH
51356: LD_INT 1
51358: PUSH
51359: LD_INT 2
51361: PUSH
51362: EMPTY
51363: LIST
51364: LIST
51365: PUSH
51366: LD_INT 0
51368: PUSH
51369: LD_INT 2
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: PUSH
51376: LD_INT 1
51378: NEG
51379: PUSH
51380: LD_INT 1
51382: PUSH
51383: EMPTY
51384: LIST
51385: LIST
51386: PUSH
51387: LD_INT 2
51389: NEG
51390: PUSH
51391: LD_INT 1
51393: NEG
51394: PUSH
51395: EMPTY
51396: LIST
51397: LIST
51398: PUSH
51399: LD_INT 2
51401: NEG
51402: PUSH
51403: LD_INT 2
51405: NEG
51406: PUSH
51407: EMPTY
51408: LIST
51409: LIST
51410: PUSH
51411: LD_INT 2
51413: NEG
51414: PUSH
51415: LD_INT 3
51417: NEG
51418: PUSH
51419: EMPTY
51420: LIST
51421: LIST
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: LD_INT 1
51428: NEG
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: PUSH
51434: LD_INT 3
51436: PUSH
51437: LD_INT 1
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: PUSH
51444: LD_INT 1
51446: PUSH
51447: LD_INT 3
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: PUSH
51454: LD_INT 1
51456: NEG
51457: PUSH
51458: LD_INT 2
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PUSH
51465: LD_INT 3
51467: NEG
51468: PUSH
51469: LD_INT 2
51471: NEG
51472: PUSH
51473: EMPTY
51474: LIST
51475: LIST
51476: PUSH
51477: EMPTY
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: LIST
51495: LIST
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
51502: LD_ADDR_VAR 0 32
51506: PUSH
51507: LD_INT 0
51509: PUSH
51510: LD_INT 0
51512: PUSH
51513: EMPTY
51514: LIST
51515: LIST
51516: PUSH
51517: LD_INT 0
51519: PUSH
51520: LD_INT 1
51522: NEG
51523: PUSH
51524: EMPTY
51525: LIST
51526: LIST
51527: PUSH
51528: LD_INT 1
51530: PUSH
51531: LD_INT 0
51533: PUSH
51534: EMPTY
51535: LIST
51536: LIST
51537: PUSH
51538: LD_INT 1
51540: PUSH
51541: LD_INT 1
51543: PUSH
51544: EMPTY
51545: LIST
51546: LIST
51547: PUSH
51548: LD_INT 0
51550: PUSH
51551: LD_INT 1
51553: PUSH
51554: EMPTY
51555: LIST
51556: LIST
51557: PUSH
51558: LD_INT 1
51560: NEG
51561: PUSH
51562: LD_INT 0
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PUSH
51569: LD_INT 1
51571: NEG
51572: PUSH
51573: LD_INT 1
51575: NEG
51576: PUSH
51577: EMPTY
51578: LIST
51579: LIST
51580: PUSH
51581: LD_INT 1
51583: NEG
51584: PUSH
51585: LD_INT 2
51587: NEG
51588: PUSH
51589: EMPTY
51590: LIST
51591: LIST
51592: PUSH
51593: LD_INT 0
51595: PUSH
51596: LD_INT 2
51598: NEG
51599: PUSH
51600: EMPTY
51601: LIST
51602: LIST
51603: PUSH
51604: LD_INT 1
51606: PUSH
51607: LD_INT 1
51609: NEG
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: PUSH
51615: LD_INT 2
51617: PUSH
51618: LD_INT 1
51620: PUSH
51621: EMPTY
51622: LIST
51623: LIST
51624: PUSH
51625: LD_INT 2
51627: PUSH
51628: LD_INT 2
51630: PUSH
51631: EMPTY
51632: LIST
51633: LIST
51634: PUSH
51635: LD_INT 1
51637: PUSH
51638: LD_INT 2
51640: PUSH
51641: EMPTY
51642: LIST
51643: LIST
51644: PUSH
51645: LD_INT 0
51647: PUSH
51648: LD_INT 2
51650: PUSH
51651: EMPTY
51652: LIST
51653: LIST
51654: PUSH
51655: LD_INT 1
51657: NEG
51658: PUSH
51659: LD_INT 1
51661: PUSH
51662: EMPTY
51663: LIST
51664: LIST
51665: PUSH
51666: LD_INT 2
51668: NEG
51669: PUSH
51670: LD_INT 0
51672: PUSH
51673: EMPTY
51674: LIST
51675: LIST
51676: PUSH
51677: LD_INT 2
51679: NEG
51680: PUSH
51681: LD_INT 1
51683: NEG
51684: PUSH
51685: EMPTY
51686: LIST
51687: LIST
51688: PUSH
51689: LD_INT 1
51691: NEG
51692: PUSH
51693: LD_INT 3
51695: NEG
51696: PUSH
51697: EMPTY
51698: LIST
51699: LIST
51700: PUSH
51701: LD_INT 1
51703: PUSH
51704: LD_INT 2
51706: NEG
51707: PUSH
51708: EMPTY
51709: LIST
51710: LIST
51711: PUSH
51712: LD_INT 3
51714: PUSH
51715: LD_INT 2
51717: PUSH
51718: EMPTY
51719: LIST
51720: LIST
51721: PUSH
51722: LD_INT 2
51724: PUSH
51725: LD_INT 3
51727: PUSH
51728: EMPTY
51729: LIST
51730: LIST
51731: PUSH
51732: LD_INT 2
51734: NEG
51735: PUSH
51736: LD_INT 1
51738: PUSH
51739: EMPTY
51740: LIST
51741: LIST
51742: PUSH
51743: LD_INT 3
51745: NEG
51746: PUSH
51747: LD_INT 1
51749: NEG
51750: PUSH
51751: EMPTY
51752: LIST
51753: LIST
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: LIST
51762: LIST
51763: LIST
51764: LIST
51765: LIST
51766: LIST
51767: LIST
51768: LIST
51769: LIST
51770: LIST
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: LIST
51776: LIST
51777: LIST
51778: LIST
51779: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
51780: LD_ADDR_VAR 0 33
51784: PUSH
51785: LD_INT 0
51787: PUSH
51788: LD_INT 0
51790: PUSH
51791: EMPTY
51792: LIST
51793: LIST
51794: PUSH
51795: LD_INT 0
51797: PUSH
51798: LD_INT 1
51800: NEG
51801: PUSH
51802: EMPTY
51803: LIST
51804: LIST
51805: PUSH
51806: LD_INT 1
51808: PUSH
51809: LD_INT 0
51811: PUSH
51812: EMPTY
51813: LIST
51814: LIST
51815: PUSH
51816: LD_INT 1
51818: PUSH
51819: LD_INT 1
51821: PUSH
51822: EMPTY
51823: LIST
51824: LIST
51825: PUSH
51826: LD_INT 0
51828: PUSH
51829: LD_INT 1
51831: PUSH
51832: EMPTY
51833: LIST
51834: LIST
51835: PUSH
51836: LD_INT 1
51838: NEG
51839: PUSH
51840: LD_INT 0
51842: PUSH
51843: EMPTY
51844: LIST
51845: LIST
51846: PUSH
51847: LD_INT 1
51849: NEG
51850: PUSH
51851: LD_INT 1
51853: NEG
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: PUSH
51859: LD_INT 1
51861: NEG
51862: PUSH
51863: LD_INT 2
51865: NEG
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: PUSH
51871: LD_INT 1
51873: PUSH
51874: LD_INT 1
51876: NEG
51877: PUSH
51878: EMPTY
51879: LIST
51880: LIST
51881: PUSH
51882: LD_INT 2
51884: PUSH
51885: LD_INT 0
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: PUSH
51892: LD_INT 2
51894: PUSH
51895: LD_INT 1
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: PUSH
51902: LD_INT 1
51904: PUSH
51905: LD_INT 2
51907: PUSH
51908: EMPTY
51909: LIST
51910: LIST
51911: PUSH
51912: LD_INT 0
51914: PUSH
51915: LD_INT 2
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: PUSH
51922: LD_INT 1
51924: NEG
51925: PUSH
51926: LD_INT 1
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: PUSH
51933: LD_INT 2
51935: NEG
51936: PUSH
51937: LD_INT 0
51939: PUSH
51940: EMPTY
51941: LIST
51942: LIST
51943: PUSH
51944: LD_INT 2
51946: NEG
51947: PUSH
51948: LD_INT 1
51950: NEG
51951: PUSH
51952: EMPTY
51953: LIST
51954: LIST
51955: PUSH
51956: LD_INT 2
51958: NEG
51959: PUSH
51960: LD_INT 2
51962: NEG
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: PUSH
51968: LD_INT 2
51970: NEG
51971: PUSH
51972: LD_INT 3
51974: NEG
51975: PUSH
51976: EMPTY
51977: LIST
51978: LIST
51979: PUSH
51980: LD_INT 2
51982: PUSH
51983: LD_INT 1
51985: NEG
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: PUSH
51991: LD_INT 3
51993: PUSH
51994: LD_INT 1
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: PUSH
52001: LD_INT 1
52003: PUSH
52004: LD_INT 3
52006: PUSH
52007: EMPTY
52008: LIST
52009: LIST
52010: PUSH
52011: LD_INT 1
52013: NEG
52014: PUSH
52015: LD_INT 2
52017: PUSH
52018: EMPTY
52019: LIST
52020: LIST
52021: PUSH
52022: LD_INT 3
52024: NEG
52025: PUSH
52026: LD_INT 2
52028: NEG
52029: PUSH
52030: EMPTY
52031: LIST
52032: LIST
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: LIST
52040: LIST
52041: LIST
52042: LIST
52043: LIST
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: LIST
52051: LIST
52052: LIST
52053: LIST
52054: LIST
52055: LIST
52056: LIST
52057: LIST
52058: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
52059: LD_ADDR_VAR 0 34
52063: PUSH
52064: LD_INT 0
52066: PUSH
52067: LD_INT 0
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: PUSH
52074: LD_INT 0
52076: PUSH
52077: LD_INT 1
52079: NEG
52080: PUSH
52081: EMPTY
52082: LIST
52083: LIST
52084: PUSH
52085: LD_INT 1
52087: PUSH
52088: LD_INT 0
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PUSH
52095: LD_INT 1
52097: PUSH
52098: LD_INT 1
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: PUSH
52105: LD_INT 0
52107: PUSH
52108: LD_INT 1
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: PUSH
52115: LD_INT 1
52117: NEG
52118: PUSH
52119: LD_INT 0
52121: PUSH
52122: EMPTY
52123: LIST
52124: LIST
52125: PUSH
52126: LD_INT 1
52128: NEG
52129: PUSH
52130: LD_INT 1
52132: NEG
52133: PUSH
52134: EMPTY
52135: LIST
52136: LIST
52137: PUSH
52138: LD_INT 1
52140: NEG
52141: PUSH
52142: LD_INT 2
52144: NEG
52145: PUSH
52146: EMPTY
52147: LIST
52148: LIST
52149: PUSH
52150: LD_INT 0
52152: PUSH
52153: LD_INT 2
52155: NEG
52156: PUSH
52157: EMPTY
52158: LIST
52159: LIST
52160: PUSH
52161: LD_INT 1
52163: PUSH
52164: LD_INT 1
52166: NEG
52167: PUSH
52168: EMPTY
52169: LIST
52170: LIST
52171: PUSH
52172: LD_INT 2
52174: PUSH
52175: LD_INT 1
52177: PUSH
52178: EMPTY
52179: LIST
52180: LIST
52181: PUSH
52182: LD_INT 2
52184: PUSH
52185: LD_INT 2
52187: PUSH
52188: EMPTY
52189: LIST
52190: LIST
52191: PUSH
52192: LD_INT 1
52194: PUSH
52195: LD_INT 2
52197: PUSH
52198: EMPTY
52199: LIST
52200: LIST
52201: PUSH
52202: LD_INT 1
52204: NEG
52205: PUSH
52206: LD_INT 1
52208: PUSH
52209: EMPTY
52210: LIST
52211: LIST
52212: PUSH
52213: LD_INT 2
52215: NEG
52216: PUSH
52217: LD_INT 0
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: PUSH
52224: LD_INT 2
52226: NEG
52227: PUSH
52228: LD_INT 1
52230: NEG
52231: PUSH
52232: EMPTY
52233: LIST
52234: LIST
52235: PUSH
52236: LD_INT 2
52238: NEG
52239: PUSH
52240: LD_INT 2
52242: NEG
52243: PUSH
52244: EMPTY
52245: LIST
52246: LIST
52247: PUSH
52248: LD_INT 1
52250: NEG
52251: PUSH
52252: LD_INT 3
52254: NEG
52255: PUSH
52256: EMPTY
52257: LIST
52258: LIST
52259: PUSH
52260: LD_INT 1
52262: PUSH
52263: LD_INT 2
52265: NEG
52266: PUSH
52267: EMPTY
52268: LIST
52269: LIST
52270: PUSH
52271: LD_INT 3
52273: PUSH
52274: LD_INT 2
52276: PUSH
52277: EMPTY
52278: LIST
52279: LIST
52280: PUSH
52281: LD_INT 2
52283: PUSH
52284: LD_INT 3
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: PUSH
52291: LD_INT 2
52293: NEG
52294: PUSH
52295: LD_INT 1
52297: PUSH
52298: EMPTY
52299: LIST
52300: LIST
52301: PUSH
52302: LD_INT 3
52304: NEG
52305: PUSH
52306: LD_INT 1
52308: NEG
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: PUSH
52314: EMPTY
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
52339: LD_ADDR_VAR 0 35
52343: PUSH
52344: LD_INT 0
52346: PUSH
52347: LD_INT 0
52349: PUSH
52350: EMPTY
52351: LIST
52352: LIST
52353: PUSH
52354: LD_INT 0
52356: PUSH
52357: LD_INT 1
52359: NEG
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PUSH
52365: LD_INT 1
52367: PUSH
52368: LD_INT 0
52370: PUSH
52371: EMPTY
52372: LIST
52373: LIST
52374: PUSH
52375: LD_INT 1
52377: PUSH
52378: LD_INT 1
52380: PUSH
52381: EMPTY
52382: LIST
52383: LIST
52384: PUSH
52385: LD_INT 0
52387: PUSH
52388: LD_INT 1
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PUSH
52395: LD_INT 1
52397: NEG
52398: PUSH
52399: LD_INT 0
52401: PUSH
52402: EMPTY
52403: LIST
52404: LIST
52405: PUSH
52406: LD_INT 1
52408: NEG
52409: PUSH
52410: LD_INT 1
52412: NEG
52413: PUSH
52414: EMPTY
52415: LIST
52416: LIST
52417: PUSH
52418: LD_INT 2
52420: PUSH
52421: LD_INT 1
52423: PUSH
52424: EMPTY
52425: LIST
52426: LIST
52427: PUSH
52428: LD_INT 2
52430: NEG
52431: PUSH
52432: LD_INT 1
52434: NEG
52435: PUSH
52436: EMPTY
52437: LIST
52438: LIST
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: LIST
52444: LIST
52445: LIST
52446: LIST
52447: LIST
52448: LIST
52449: LIST
52450: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
52451: LD_ADDR_VAR 0 36
52455: PUSH
52456: LD_INT 0
52458: PUSH
52459: LD_INT 0
52461: PUSH
52462: EMPTY
52463: LIST
52464: LIST
52465: PUSH
52466: LD_INT 0
52468: PUSH
52469: LD_INT 1
52471: NEG
52472: PUSH
52473: EMPTY
52474: LIST
52475: LIST
52476: PUSH
52477: LD_INT 1
52479: PUSH
52480: LD_INT 0
52482: PUSH
52483: EMPTY
52484: LIST
52485: LIST
52486: PUSH
52487: LD_INT 1
52489: PUSH
52490: LD_INT 1
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: PUSH
52497: LD_INT 0
52499: PUSH
52500: LD_INT 1
52502: PUSH
52503: EMPTY
52504: LIST
52505: LIST
52506: PUSH
52507: LD_INT 1
52509: NEG
52510: PUSH
52511: LD_INT 0
52513: PUSH
52514: EMPTY
52515: LIST
52516: LIST
52517: PUSH
52518: LD_INT 1
52520: NEG
52521: PUSH
52522: LD_INT 1
52524: NEG
52525: PUSH
52526: EMPTY
52527: LIST
52528: LIST
52529: PUSH
52530: LD_INT 1
52532: NEG
52533: PUSH
52534: LD_INT 2
52536: NEG
52537: PUSH
52538: EMPTY
52539: LIST
52540: LIST
52541: PUSH
52542: LD_INT 1
52544: PUSH
52545: LD_INT 2
52547: PUSH
52548: EMPTY
52549: LIST
52550: LIST
52551: PUSH
52552: EMPTY
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
52563: LD_ADDR_VAR 0 37
52567: PUSH
52568: LD_INT 0
52570: PUSH
52571: LD_INT 0
52573: PUSH
52574: EMPTY
52575: LIST
52576: LIST
52577: PUSH
52578: LD_INT 0
52580: PUSH
52581: LD_INT 1
52583: NEG
52584: PUSH
52585: EMPTY
52586: LIST
52587: LIST
52588: PUSH
52589: LD_INT 1
52591: PUSH
52592: LD_INT 0
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: PUSH
52599: LD_INT 1
52601: PUSH
52602: LD_INT 1
52604: PUSH
52605: EMPTY
52606: LIST
52607: LIST
52608: PUSH
52609: LD_INT 0
52611: PUSH
52612: LD_INT 1
52614: PUSH
52615: EMPTY
52616: LIST
52617: LIST
52618: PUSH
52619: LD_INT 1
52621: NEG
52622: PUSH
52623: LD_INT 0
52625: PUSH
52626: EMPTY
52627: LIST
52628: LIST
52629: PUSH
52630: LD_INT 1
52632: NEG
52633: PUSH
52634: LD_INT 1
52636: NEG
52637: PUSH
52638: EMPTY
52639: LIST
52640: LIST
52641: PUSH
52642: LD_INT 1
52644: PUSH
52645: LD_INT 1
52647: NEG
52648: PUSH
52649: EMPTY
52650: LIST
52651: LIST
52652: PUSH
52653: LD_INT 1
52655: NEG
52656: PUSH
52657: LD_INT 1
52659: PUSH
52660: EMPTY
52661: LIST
52662: LIST
52663: PUSH
52664: EMPTY
52665: LIST
52666: LIST
52667: LIST
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: LIST
52673: LIST
52674: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
52675: LD_ADDR_VAR 0 38
52679: PUSH
52680: LD_INT 0
52682: PUSH
52683: LD_INT 0
52685: PUSH
52686: EMPTY
52687: LIST
52688: LIST
52689: PUSH
52690: LD_INT 0
52692: PUSH
52693: LD_INT 1
52695: NEG
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: PUSH
52701: LD_INT 1
52703: PUSH
52704: LD_INT 0
52706: PUSH
52707: EMPTY
52708: LIST
52709: LIST
52710: PUSH
52711: LD_INT 1
52713: PUSH
52714: LD_INT 1
52716: PUSH
52717: EMPTY
52718: LIST
52719: LIST
52720: PUSH
52721: LD_INT 0
52723: PUSH
52724: LD_INT 1
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PUSH
52731: LD_INT 1
52733: NEG
52734: PUSH
52735: LD_INT 0
52737: PUSH
52738: EMPTY
52739: LIST
52740: LIST
52741: PUSH
52742: LD_INT 1
52744: NEG
52745: PUSH
52746: LD_INT 1
52748: NEG
52749: PUSH
52750: EMPTY
52751: LIST
52752: LIST
52753: PUSH
52754: LD_INT 2
52756: PUSH
52757: LD_INT 1
52759: PUSH
52760: EMPTY
52761: LIST
52762: LIST
52763: PUSH
52764: LD_INT 2
52766: NEG
52767: PUSH
52768: LD_INT 1
52770: NEG
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: PUSH
52776: EMPTY
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
52787: LD_ADDR_VAR 0 39
52791: PUSH
52792: LD_INT 0
52794: PUSH
52795: LD_INT 0
52797: PUSH
52798: EMPTY
52799: LIST
52800: LIST
52801: PUSH
52802: LD_INT 0
52804: PUSH
52805: LD_INT 1
52807: NEG
52808: PUSH
52809: EMPTY
52810: LIST
52811: LIST
52812: PUSH
52813: LD_INT 1
52815: PUSH
52816: LD_INT 0
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: LD_INT 1
52825: PUSH
52826: LD_INT 1
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PUSH
52833: LD_INT 0
52835: PUSH
52836: LD_INT 1
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: PUSH
52843: LD_INT 1
52845: NEG
52846: PUSH
52847: LD_INT 0
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PUSH
52854: LD_INT 1
52856: NEG
52857: PUSH
52858: LD_INT 1
52860: NEG
52861: PUSH
52862: EMPTY
52863: LIST
52864: LIST
52865: PUSH
52866: LD_INT 1
52868: NEG
52869: PUSH
52870: LD_INT 2
52872: NEG
52873: PUSH
52874: EMPTY
52875: LIST
52876: LIST
52877: PUSH
52878: LD_INT 1
52880: PUSH
52881: LD_INT 2
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: PUSH
52888: EMPTY
52889: LIST
52890: LIST
52891: LIST
52892: LIST
52893: LIST
52894: LIST
52895: LIST
52896: LIST
52897: LIST
52898: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
52899: LD_ADDR_VAR 0 40
52903: PUSH
52904: LD_INT 0
52906: PUSH
52907: LD_INT 0
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: PUSH
52914: LD_INT 0
52916: PUSH
52917: LD_INT 1
52919: NEG
52920: PUSH
52921: EMPTY
52922: LIST
52923: LIST
52924: PUSH
52925: LD_INT 1
52927: PUSH
52928: LD_INT 0
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: PUSH
52935: LD_INT 1
52937: PUSH
52938: LD_INT 1
52940: PUSH
52941: EMPTY
52942: LIST
52943: LIST
52944: PUSH
52945: LD_INT 0
52947: PUSH
52948: LD_INT 1
52950: PUSH
52951: EMPTY
52952: LIST
52953: LIST
52954: PUSH
52955: LD_INT 1
52957: NEG
52958: PUSH
52959: LD_INT 0
52961: PUSH
52962: EMPTY
52963: LIST
52964: LIST
52965: PUSH
52966: LD_INT 1
52968: NEG
52969: PUSH
52970: LD_INT 1
52972: NEG
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: PUSH
52978: LD_INT 1
52980: PUSH
52981: LD_INT 1
52983: NEG
52984: PUSH
52985: EMPTY
52986: LIST
52987: LIST
52988: PUSH
52989: LD_INT 1
52991: NEG
52992: PUSH
52993: LD_INT 1
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: LIST
53004: LIST
53005: LIST
53006: LIST
53007: LIST
53008: LIST
53009: LIST
53010: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
53011: LD_ADDR_VAR 0 41
53015: PUSH
53016: LD_INT 0
53018: PUSH
53019: LD_INT 0
53021: PUSH
53022: EMPTY
53023: LIST
53024: LIST
53025: PUSH
53026: LD_INT 0
53028: PUSH
53029: LD_INT 1
53031: NEG
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PUSH
53037: LD_INT 1
53039: PUSH
53040: LD_INT 0
53042: PUSH
53043: EMPTY
53044: LIST
53045: LIST
53046: PUSH
53047: LD_INT 1
53049: PUSH
53050: LD_INT 1
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: PUSH
53057: LD_INT 0
53059: PUSH
53060: LD_INT 1
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: PUSH
53067: LD_INT 1
53069: NEG
53070: PUSH
53071: LD_INT 0
53073: PUSH
53074: EMPTY
53075: LIST
53076: LIST
53077: PUSH
53078: LD_INT 1
53080: NEG
53081: PUSH
53082: LD_INT 1
53084: NEG
53085: PUSH
53086: EMPTY
53087: LIST
53088: LIST
53089: PUSH
53090: LD_INT 1
53092: NEG
53093: PUSH
53094: LD_INT 2
53096: NEG
53097: PUSH
53098: EMPTY
53099: LIST
53100: LIST
53101: PUSH
53102: LD_INT 1
53104: PUSH
53105: LD_INT 1
53107: NEG
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: PUSH
53113: LD_INT 2
53115: PUSH
53116: LD_INT 0
53118: PUSH
53119: EMPTY
53120: LIST
53121: LIST
53122: PUSH
53123: LD_INT 2
53125: PUSH
53126: LD_INT 1
53128: PUSH
53129: EMPTY
53130: LIST
53131: LIST
53132: PUSH
53133: LD_INT 2
53135: PUSH
53136: LD_INT 2
53138: PUSH
53139: EMPTY
53140: LIST
53141: LIST
53142: PUSH
53143: LD_INT 1
53145: PUSH
53146: LD_INT 2
53148: PUSH
53149: EMPTY
53150: LIST
53151: LIST
53152: PUSH
53153: LD_INT 1
53155: NEG
53156: PUSH
53157: LD_INT 1
53159: PUSH
53160: EMPTY
53161: LIST
53162: LIST
53163: PUSH
53164: LD_INT 2
53166: NEG
53167: PUSH
53168: LD_INT 0
53170: PUSH
53171: EMPTY
53172: LIST
53173: LIST
53174: PUSH
53175: LD_INT 2
53177: NEG
53178: PUSH
53179: LD_INT 1
53181: NEG
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: LD_INT 2
53189: NEG
53190: PUSH
53191: LD_INT 2
53193: NEG
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PUSH
53199: LD_INT 2
53201: NEG
53202: PUSH
53203: LD_INT 3
53205: NEG
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: PUSH
53211: LD_INT 2
53213: PUSH
53214: LD_INT 1
53216: NEG
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PUSH
53222: LD_INT 3
53224: PUSH
53225: LD_INT 0
53227: PUSH
53228: EMPTY
53229: LIST
53230: LIST
53231: PUSH
53232: LD_INT 3
53234: PUSH
53235: LD_INT 1
53237: PUSH
53238: EMPTY
53239: LIST
53240: LIST
53241: PUSH
53242: LD_INT 3
53244: PUSH
53245: LD_INT 2
53247: PUSH
53248: EMPTY
53249: LIST
53250: LIST
53251: PUSH
53252: LD_INT 3
53254: PUSH
53255: LD_INT 3
53257: PUSH
53258: EMPTY
53259: LIST
53260: LIST
53261: PUSH
53262: LD_INT 2
53264: PUSH
53265: LD_INT 3
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: PUSH
53272: LD_INT 2
53274: NEG
53275: PUSH
53276: LD_INT 1
53278: PUSH
53279: EMPTY
53280: LIST
53281: LIST
53282: PUSH
53283: LD_INT 3
53285: NEG
53286: PUSH
53287: LD_INT 0
53289: PUSH
53290: EMPTY
53291: LIST
53292: LIST
53293: PUSH
53294: LD_INT 3
53296: NEG
53297: PUSH
53298: LD_INT 1
53300: NEG
53301: PUSH
53302: EMPTY
53303: LIST
53304: LIST
53305: PUSH
53306: LD_INT 3
53308: NEG
53309: PUSH
53310: LD_INT 2
53312: NEG
53313: PUSH
53314: EMPTY
53315: LIST
53316: LIST
53317: PUSH
53318: LD_INT 3
53320: NEG
53321: PUSH
53322: LD_INT 3
53324: NEG
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PUSH
53330: EMPTY
53331: LIST
53332: LIST
53333: LIST
53334: LIST
53335: LIST
53336: LIST
53337: LIST
53338: LIST
53339: LIST
53340: LIST
53341: LIST
53342: LIST
53343: LIST
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: LIST
53349: LIST
53350: LIST
53351: LIST
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: LIST
53357: LIST
53358: LIST
53359: LIST
53360: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
53361: LD_ADDR_VAR 0 42
53365: PUSH
53366: LD_INT 0
53368: PUSH
53369: LD_INT 0
53371: PUSH
53372: EMPTY
53373: LIST
53374: LIST
53375: PUSH
53376: LD_INT 0
53378: PUSH
53379: LD_INT 1
53381: NEG
53382: PUSH
53383: EMPTY
53384: LIST
53385: LIST
53386: PUSH
53387: LD_INT 1
53389: PUSH
53390: LD_INT 0
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: PUSH
53397: LD_INT 1
53399: PUSH
53400: LD_INT 1
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: PUSH
53407: LD_INT 0
53409: PUSH
53410: LD_INT 1
53412: PUSH
53413: EMPTY
53414: LIST
53415: LIST
53416: PUSH
53417: LD_INT 1
53419: NEG
53420: PUSH
53421: LD_INT 0
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: PUSH
53428: LD_INT 1
53430: NEG
53431: PUSH
53432: LD_INT 1
53434: NEG
53435: PUSH
53436: EMPTY
53437: LIST
53438: LIST
53439: PUSH
53440: LD_INT 1
53442: NEG
53443: PUSH
53444: LD_INT 2
53446: NEG
53447: PUSH
53448: EMPTY
53449: LIST
53450: LIST
53451: PUSH
53452: LD_INT 0
53454: PUSH
53455: LD_INT 2
53457: NEG
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: LD_INT 1
53465: PUSH
53466: LD_INT 1
53468: NEG
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PUSH
53474: LD_INT 2
53476: PUSH
53477: LD_INT 1
53479: PUSH
53480: EMPTY
53481: LIST
53482: LIST
53483: PUSH
53484: LD_INT 2
53486: PUSH
53487: LD_INT 2
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: PUSH
53494: LD_INT 1
53496: PUSH
53497: LD_INT 2
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: PUSH
53504: LD_INT 0
53506: PUSH
53507: LD_INT 2
53509: PUSH
53510: EMPTY
53511: LIST
53512: LIST
53513: PUSH
53514: LD_INT 1
53516: NEG
53517: PUSH
53518: LD_INT 1
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: PUSH
53525: LD_INT 2
53527: NEG
53528: PUSH
53529: LD_INT 1
53531: NEG
53532: PUSH
53533: EMPTY
53534: LIST
53535: LIST
53536: PUSH
53537: LD_INT 2
53539: NEG
53540: PUSH
53541: LD_INT 2
53543: NEG
53544: PUSH
53545: EMPTY
53546: LIST
53547: LIST
53548: PUSH
53549: LD_INT 2
53551: NEG
53552: PUSH
53553: LD_INT 3
53555: NEG
53556: PUSH
53557: EMPTY
53558: LIST
53559: LIST
53560: PUSH
53561: LD_INT 1
53563: NEG
53564: PUSH
53565: LD_INT 3
53567: NEG
53568: PUSH
53569: EMPTY
53570: LIST
53571: LIST
53572: PUSH
53573: LD_INT 0
53575: PUSH
53576: LD_INT 3
53578: NEG
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PUSH
53584: LD_INT 1
53586: PUSH
53587: LD_INT 2
53589: NEG
53590: PUSH
53591: EMPTY
53592: LIST
53593: LIST
53594: PUSH
53595: LD_INT 3
53597: PUSH
53598: LD_INT 2
53600: PUSH
53601: EMPTY
53602: LIST
53603: LIST
53604: PUSH
53605: LD_INT 3
53607: PUSH
53608: LD_INT 3
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: PUSH
53615: LD_INT 2
53617: PUSH
53618: LD_INT 3
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: PUSH
53625: LD_INT 1
53627: PUSH
53628: LD_INT 3
53630: PUSH
53631: EMPTY
53632: LIST
53633: LIST
53634: PUSH
53635: LD_INT 0
53637: PUSH
53638: LD_INT 3
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: PUSH
53645: LD_INT 1
53647: NEG
53648: PUSH
53649: LD_INT 2
53651: PUSH
53652: EMPTY
53653: LIST
53654: LIST
53655: PUSH
53656: LD_INT 3
53658: NEG
53659: PUSH
53660: LD_INT 2
53662: NEG
53663: PUSH
53664: EMPTY
53665: LIST
53666: LIST
53667: PUSH
53668: LD_INT 3
53670: NEG
53671: PUSH
53672: LD_INT 3
53674: NEG
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: LIST
53684: LIST
53685: LIST
53686: LIST
53687: LIST
53688: LIST
53689: LIST
53690: LIST
53691: LIST
53692: LIST
53693: LIST
53694: LIST
53695: LIST
53696: LIST
53697: LIST
53698: LIST
53699: LIST
53700: LIST
53701: LIST
53702: LIST
53703: LIST
53704: LIST
53705: LIST
53706: LIST
53707: LIST
53708: LIST
53709: LIST
53710: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
53711: LD_ADDR_VAR 0 43
53715: PUSH
53716: LD_INT 0
53718: PUSH
53719: LD_INT 0
53721: PUSH
53722: EMPTY
53723: LIST
53724: LIST
53725: PUSH
53726: LD_INT 0
53728: PUSH
53729: LD_INT 1
53731: NEG
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: PUSH
53737: LD_INT 1
53739: PUSH
53740: LD_INT 0
53742: PUSH
53743: EMPTY
53744: LIST
53745: LIST
53746: PUSH
53747: LD_INT 1
53749: PUSH
53750: LD_INT 1
53752: PUSH
53753: EMPTY
53754: LIST
53755: LIST
53756: PUSH
53757: LD_INT 0
53759: PUSH
53760: LD_INT 1
53762: PUSH
53763: EMPTY
53764: LIST
53765: LIST
53766: PUSH
53767: LD_INT 1
53769: NEG
53770: PUSH
53771: LD_INT 0
53773: PUSH
53774: EMPTY
53775: LIST
53776: LIST
53777: PUSH
53778: LD_INT 1
53780: NEG
53781: PUSH
53782: LD_INT 1
53784: NEG
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: PUSH
53790: LD_INT 1
53792: NEG
53793: PUSH
53794: LD_INT 2
53796: NEG
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PUSH
53802: LD_INT 0
53804: PUSH
53805: LD_INT 2
53807: NEG
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: PUSH
53813: LD_INT 1
53815: PUSH
53816: LD_INT 1
53818: NEG
53819: PUSH
53820: EMPTY
53821: LIST
53822: LIST
53823: PUSH
53824: LD_INT 2
53826: PUSH
53827: LD_INT 0
53829: PUSH
53830: EMPTY
53831: LIST
53832: LIST
53833: PUSH
53834: LD_INT 2
53836: PUSH
53837: LD_INT 1
53839: PUSH
53840: EMPTY
53841: LIST
53842: LIST
53843: PUSH
53844: LD_INT 1
53846: PUSH
53847: LD_INT 2
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: PUSH
53854: LD_INT 0
53856: PUSH
53857: LD_INT 2
53859: PUSH
53860: EMPTY
53861: LIST
53862: LIST
53863: PUSH
53864: LD_INT 1
53866: NEG
53867: PUSH
53868: LD_INT 1
53870: PUSH
53871: EMPTY
53872: LIST
53873: LIST
53874: PUSH
53875: LD_INT 2
53877: NEG
53878: PUSH
53879: LD_INT 0
53881: PUSH
53882: EMPTY
53883: LIST
53884: LIST
53885: PUSH
53886: LD_INT 2
53888: NEG
53889: PUSH
53890: LD_INT 1
53892: NEG
53893: PUSH
53894: EMPTY
53895: LIST
53896: LIST
53897: PUSH
53898: LD_INT 1
53900: NEG
53901: PUSH
53902: LD_INT 3
53904: NEG
53905: PUSH
53906: EMPTY
53907: LIST
53908: LIST
53909: PUSH
53910: LD_INT 0
53912: PUSH
53913: LD_INT 3
53915: NEG
53916: PUSH
53917: EMPTY
53918: LIST
53919: LIST
53920: PUSH
53921: LD_INT 1
53923: PUSH
53924: LD_INT 2
53926: NEG
53927: PUSH
53928: EMPTY
53929: LIST
53930: LIST
53931: PUSH
53932: LD_INT 2
53934: PUSH
53935: LD_INT 1
53937: NEG
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PUSH
53943: LD_INT 3
53945: PUSH
53946: LD_INT 0
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: PUSH
53953: LD_INT 3
53955: PUSH
53956: LD_INT 1
53958: PUSH
53959: EMPTY
53960: LIST
53961: LIST
53962: PUSH
53963: LD_INT 1
53965: PUSH
53966: LD_INT 3
53968: PUSH
53969: EMPTY
53970: LIST
53971: LIST
53972: PUSH
53973: LD_INT 0
53975: PUSH
53976: LD_INT 3
53978: PUSH
53979: EMPTY
53980: LIST
53981: LIST
53982: PUSH
53983: LD_INT 1
53985: NEG
53986: PUSH
53987: LD_INT 2
53989: PUSH
53990: EMPTY
53991: LIST
53992: LIST
53993: PUSH
53994: LD_INT 2
53996: NEG
53997: PUSH
53998: LD_INT 1
54000: PUSH
54001: EMPTY
54002: LIST
54003: LIST
54004: PUSH
54005: LD_INT 3
54007: NEG
54008: PUSH
54009: LD_INT 0
54011: PUSH
54012: EMPTY
54013: LIST
54014: LIST
54015: PUSH
54016: LD_INT 3
54018: NEG
54019: PUSH
54020: LD_INT 1
54022: NEG
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PUSH
54028: EMPTY
54029: LIST
54030: LIST
54031: LIST
54032: LIST
54033: LIST
54034: LIST
54035: LIST
54036: LIST
54037: LIST
54038: LIST
54039: LIST
54040: LIST
54041: LIST
54042: LIST
54043: LIST
54044: LIST
54045: LIST
54046: LIST
54047: LIST
54048: LIST
54049: LIST
54050: LIST
54051: LIST
54052: LIST
54053: LIST
54054: LIST
54055: LIST
54056: LIST
54057: LIST
54058: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
54059: LD_ADDR_VAR 0 44
54063: PUSH
54064: LD_INT 0
54066: PUSH
54067: LD_INT 0
54069: PUSH
54070: EMPTY
54071: LIST
54072: LIST
54073: PUSH
54074: LD_INT 0
54076: PUSH
54077: LD_INT 1
54079: NEG
54080: PUSH
54081: EMPTY
54082: LIST
54083: LIST
54084: PUSH
54085: LD_INT 1
54087: PUSH
54088: LD_INT 0
54090: PUSH
54091: EMPTY
54092: LIST
54093: LIST
54094: PUSH
54095: LD_INT 1
54097: PUSH
54098: LD_INT 1
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: PUSH
54105: LD_INT 0
54107: PUSH
54108: LD_INT 1
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: PUSH
54115: LD_INT 1
54117: NEG
54118: PUSH
54119: LD_INT 0
54121: PUSH
54122: EMPTY
54123: LIST
54124: LIST
54125: PUSH
54126: LD_INT 1
54128: NEG
54129: PUSH
54130: LD_INT 1
54132: NEG
54133: PUSH
54134: EMPTY
54135: LIST
54136: LIST
54137: PUSH
54138: LD_INT 1
54140: NEG
54141: PUSH
54142: LD_INT 2
54144: NEG
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: PUSH
54150: LD_INT 1
54152: PUSH
54153: LD_INT 1
54155: NEG
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: PUSH
54161: LD_INT 2
54163: PUSH
54164: LD_INT 0
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: PUSH
54171: LD_INT 2
54173: PUSH
54174: LD_INT 1
54176: PUSH
54177: EMPTY
54178: LIST
54179: LIST
54180: PUSH
54181: LD_INT 2
54183: PUSH
54184: LD_INT 2
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: PUSH
54191: LD_INT 1
54193: PUSH
54194: LD_INT 2
54196: PUSH
54197: EMPTY
54198: LIST
54199: LIST
54200: PUSH
54201: LD_INT 1
54203: NEG
54204: PUSH
54205: LD_INT 1
54207: PUSH
54208: EMPTY
54209: LIST
54210: LIST
54211: PUSH
54212: LD_INT 2
54214: NEG
54215: PUSH
54216: LD_INT 0
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: PUSH
54223: LD_INT 2
54225: NEG
54226: PUSH
54227: LD_INT 1
54229: NEG
54230: PUSH
54231: EMPTY
54232: LIST
54233: LIST
54234: PUSH
54235: LD_INT 2
54237: NEG
54238: PUSH
54239: LD_INT 2
54241: NEG
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: PUSH
54247: LD_INT 2
54249: NEG
54250: PUSH
54251: LD_INT 3
54253: NEG
54254: PUSH
54255: EMPTY
54256: LIST
54257: LIST
54258: PUSH
54259: LD_INT 2
54261: PUSH
54262: LD_INT 1
54264: NEG
54265: PUSH
54266: EMPTY
54267: LIST
54268: LIST
54269: PUSH
54270: LD_INT 3
54272: PUSH
54273: LD_INT 0
54275: PUSH
54276: EMPTY
54277: LIST
54278: LIST
54279: PUSH
54280: LD_INT 3
54282: PUSH
54283: LD_INT 1
54285: PUSH
54286: EMPTY
54287: LIST
54288: LIST
54289: PUSH
54290: LD_INT 3
54292: PUSH
54293: LD_INT 2
54295: PUSH
54296: EMPTY
54297: LIST
54298: LIST
54299: PUSH
54300: LD_INT 3
54302: PUSH
54303: LD_INT 3
54305: PUSH
54306: EMPTY
54307: LIST
54308: LIST
54309: PUSH
54310: LD_INT 2
54312: PUSH
54313: LD_INT 3
54315: PUSH
54316: EMPTY
54317: LIST
54318: LIST
54319: PUSH
54320: LD_INT 2
54322: NEG
54323: PUSH
54324: LD_INT 1
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: PUSH
54331: LD_INT 3
54333: NEG
54334: PUSH
54335: LD_INT 0
54337: PUSH
54338: EMPTY
54339: LIST
54340: LIST
54341: PUSH
54342: LD_INT 3
54344: NEG
54345: PUSH
54346: LD_INT 1
54348: NEG
54349: PUSH
54350: EMPTY
54351: LIST
54352: LIST
54353: PUSH
54354: LD_INT 3
54356: NEG
54357: PUSH
54358: LD_INT 2
54360: NEG
54361: PUSH
54362: EMPTY
54363: LIST
54364: LIST
54365: PUSH
54366: LD_INT 3
54368: NEG
54369: PUSH
54370: LD_INT 3
54372: NEG
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: LIST
54382: LIST
54383: LIST
54384: LIST
54385: LIST
54386: LIST
54387: LIST
54388: LIST
54389: LIST
54390: LIST
54391: LIST
54392: LIST
54393: LIST
54394: LIST
54395: LIST
54396: LIST
54397: LIST
54398: LIST
54399: LIST
54400: LIST
54401: LIST
54402: LIST
54403: LIST
54404: LIST
54405: LIST
54406: LIST
54407: LIST
54408: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
54409: LD_ADDR_VAR 0 45
54413: PUSH
54414: LD_INT 0
54416: PUSH
54417: LD_INT 0
54419: PUSH
54420: EMPTY
54421: LIST
54422: LIST
54423: PUSH
54424: LD_INT 0
54426: PUSH
54427: LD_INT 1
54429: NEG
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: PUSH
54435: LD_INT 1
54437: PUSH
54438: LD_INT 0
54440: PUSH
54441: EMPTY
54442: LIST
54443: LIST
54444: PUSH
54445: LD_INT 1
54447: PUSH
54448: LD_INT 1
54450: PUSH
54451: EMPTY
54452: LIST
54453: LIST
54454: PUSH
54455: LD_INT 0
54457: PUSH
54458: LD_INT 1
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: PUSH
54465: LD_INT 1
54467: NEG
54468: PUSH
54469: LD_INT 0
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: PUSH
54476: LD_INT 1
54478: NEG
54479: PUSH
54480: LD_INT 1
54482: NEG
54483: PUSH
54484: EMPTY
54485: LIST
54486: LIST
54487: PUSH
54488: LD_INT 1
54490: NEG
54491: PUSH
54492: LD_INT 2
54494: NEG
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: PUSH
54500: LD_INT 0
54502: PUSH
54503: LD_INT 2
54505: NEG
54506: PUSH
54507: EMPTY
54508: LIST
54509: LIST
54510: PUSH
54511: LD_INT 1
54513: PUSH
54514: LD_INT 1
54516: NEG
54517: PUSH
54518: EMPTY
54519: LIST
54520: LIST
54521: PUSH
54522: LD_INT 2
54524: PUSH
54525: LD_INT 1
54527: PUSH
54528: EMPTY
54529: LIST
54530: LIST
54531: PUSH
54532: LD_INT 2
54534: PUSH
54535: LD_INT 2
54537: PUSH
54538: EMPTY
54539: LIST
54540: LIST
54541: PUSH
54542: LD_INT 1
54544: PUSH
54545: LD_INT 2
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: PUSH
54552: LD_INT 0
54554: PUSH
54555: LD_INT 2
54557: PUSH
54558: EMPTY
54559: LIST
54560: LIST
54561: PUSH
54562: LD_INT 1
54564: NEG
54565: PUSH
54566: LD_INT 1
54568: PUSH
54569: EMPTY
54570: LIST
54571: LIST
54572: PUSH
54573: LD_INT 2
54575: NEG
54576: PUSH
54577: LD_INT 1
54579: NEG
54580: PUSH
54581: EMPTY
54582: LIST
54583: LIST
54584: PUSH
54585: LD_INT 2
54587: NEG
54588: PUSH
54589: LD_INT 2
54591: NEG
54592: PUSH
54593: EMPTY
54594: LIST
54595: LIST
54596: PUSH
54597: LD_INT 2
54599: NEG
54600: PUSH
54601: LD_INT 3
54603: NEG
54604: PUSH
54605: EMPTY
54606: LIST
54607: LIST
54608: PUSH
54609: LD_INT 1
54611: NEG
54612: PUSH
54613: LD_INT 3
54615: NEG
54616: PUSH
54617: EMPTY
54618: LIST
54619: LIST
54620: PUSH
54621: LD_INT 0
54623: PUSH
54624: LD_INT 3
54626: NEG
54627: PUSH
54628: EMPTY
54629: LIST
54630: LIST
54631: PUSH
54632: LD_INT 1
54634: PUSH
54635: LD_INT 2
54637: NEG
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: PUSH
54643: LD_INT 3
54645: PUSH
54646: LD_INT 2
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: PUSH
54653: LD_INT 3
54655: PUSH
54656: LD_INT 3
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: PUSH
54663: LD_INT 2
54665: PUSH
54666: LD_INT 3
54668: PUSH
54669: EMPTY
54670: LIST
54671: LIST
54672: PUSH
54673: LD_INT 1
54675: PUSH
54676: LD_INT 3
54678: PUSH
54679: EMPTY
54680: LIST
54681: LIST
54682: PUSH
54683: LD_INT 0
54685: PUSH
54686: LD_INT 3
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: PUSH
54693: LD_INT 1
54695: NEG
54696: PUSH
54697: LD_INT 2
54699: PUSH
54700: EMPTY
54701: LIST
54702: LIST
54703: PUSH
54704: LD_INT 3
54706: NEG
54707: PUSH
54708: LD_INT 2
54710: NEG
54711: PUSH
54712: EMPTY
54713: LIST
54714: LIST
54715: PUSH
54716: LD_INT 3
54718: NEG
54719: PUSH
54720: LD_INT 3
54722: NEG
54723: PUSH
54724: EMPTY
54725: LIST
54726: LIST
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: LIST
54733: LIST
54734: LIST
54735: LIST
54736: LIST
54737: LIST
54738: LIST
54739: LIST
54740: LIST
54741: LIST
54742: LIST
54743: LIST
54744: LIST
54745: LIST
54746: LIST
54747: LIST
54748: LIST
54749: LIST
54750: LIST
54751: LIST
54752: LIST
54753: LIST
54754: LIST
54755: LIST
54756: LIST
54757: LIST
54758: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
54759: LD_ADDR_VAR 0 46
54763: PUSH
54764: LD_INT 0
54766: PUSH
54767: LD_INT 0
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: PUSH
54774: LD_INT 0
54776: PUSH
54777: LD_INT 1
54779: NEG
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: PUSH
54785: LD_INT 1
54787: PUSH
54788: LD_INT 0
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: PUSH
54795: LD_INT 1
54797: PUSH
54798: LD_INT 1
54800: PUSH
54801: EMPTY
54802: LIST
54803: LIST
54804: PUSH
54805: LD_INT 0
54807: PUSH
54808: LD_INT 1
54810: PUSH
54811: EMPTY
54812: LIST
54813: LIST
54814: PUSH
54815: LD_INT 1
54817: NEG
54818: PUSH
54819: LD_INT 0
54821: PUSH
54822: EMPTY
54823: LIST
54824: LIST
54825: PUSH
54826: LD_INT 1
54828: NEG
54829: PUSH
54830: LD_INT 1
54832: NEG
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: PUSH
54838: LD_INT 1
54840: NEG
54841: PUSH
54842: LD_INT 2
54844: NEG
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: PUSH
54850: LD_INT 0
54852: PUSH
54853: LD_INT 2
54855: NEG
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: PUSH
54861: LD_INT 1
54863: PUSH
54864: LD_INT 1
54866: NEG
54867: PUSH
54868: EMPTY
54869: LIST
54870: LIST
54871: PUSH
54872: LD_INT 2
54874: PUSH
54875: LD_INT 0
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: PUSH
54882: LD_INT 2
54884: PUSH
54885: LD_INT 1
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: PUSH
54892: LD_INT 1
54894: PUSH
54895: LD_INT 2
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: PUSH
54902: LD_INT 0
54904: PUSH
54905: LD_INT 2
54907: PUSH
54908: EMPTY
54909: LIST
54910: LIST
54911: PUSH
54912: LD_INT 1
54914: NEG
54915: PUSH
54916: LD_INT 1
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: PUSH
54923: LD_INT 2
54925: NEG
54926: PUSH
54927: LD_INT 0
54929: PUSH
54930: EMPTY
54931: LIST
54932: LIST
54933: PUSH
54934: LD_INT 2
54936: NEG
54937: PUSH
54938: LD_INT 1
54940: NEG
54941: PUSH
54942: EMPTY
54943: LIST
54944: LIST
54945: PUSH
54946: LD_INT 1
54948: NEG
54949: PUSH
54950: LD_INT 3
54952: NEG
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: PUSH
54958: LD_INT 0
54960: PUSH
54961: LD_INT 3
54963: NEG
54964: PUSH
54965: EMPTY
54966: LIST
54967: LIST
54968: PUSH
54969: LD_INT 1
54971: PUSH
54972: LD_INT 2
54974: NEG
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: PUSH
54980: LD_INT 2
54982: PUSH
54983: LD_INT 1
54985: NEG
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PUSH
54991: LD_INT 3
54993: PUSH
54994: LD_INT 0
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: PUSH
55001: LD_INT 3
55003: PUSH
55004: LD_INT 1
55006: PUSH
55007: EMPTY
55008: LIST
55009: LIST
55010: PUSH
55011: LD_INT 1
55013: PUSH
55014: LD_INT 3
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: PUSH
55021: LD_INT 0
55023: PUSH
55024: LD_INT 3
55026: PUSH
55027: EMPTY
55028: LIST
55029: LIST
55030: PUSH
55031: LD_INT 1
55033: NEG
55034: PUSH
55035: LD_INT 2
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: PUSH
55042: LD_INT 2
55044: NEG
55045: PUSH
55046: LD_INT 1
55048: PUSH
55049: EMPTY
55050: LIST
55051: LIST
55052: PUSH
55053: LD_INT 3
55055: NEG
55056: PUSH
55057: LD_INT 0
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: PUSH
55064: LD_INT 3
55066: NEG
55067: PUSH
55068: LD_INT 1
55070: NEG
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PUSH
55076: EMPTY
55077: LIST
55078: LIST
55079: LIST
55080: LIST
55081: LIST
55082: LIST
55083: LIST
55084: LIST
55085: LIST
55086: LIST
55087: LIST
55088: LIST
55089: LIST
55090: LIST
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: LIST
55103: LIST
55104: LIST
55105: LIST
55106: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55107: LD_ADDR_VAR 0 47
55111: PUSH
55112: LD_INT 0
55114: PUSH
55115: LD_INT 0
55117: PUSH
55118: EMPTY
55119: LIST
55120: LIST
55121: PUSH
55122: LD_INT 0
55124: PUSH
55125: LD_INT 1
55127: NEG
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: PUSH
55133: LD_INT 1
55135: PUSH
55136: LD_INT 0
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: PUSH
55143: LD_INT 1
55145: PUSH
55146: LD_INT 1
55148: PUSH
55149: EMPTY
55150: LIST
55151: LIST
55152: PUSH
55153: LD_INT 0
55155: PUSH
55156: LD_INT 1
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: PUSH
55163: LD_INT 1
55165: NEG
55166: PUSH
55167: LD_INT 0
55169: PUSH
55170: EMPTY
55171: LIST
55172: LIST
55173: PUSH
55174: LD_INT 1
55176: NEG
55177: PUSH
55178: LD_INT 1
55180: NEG
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: PUSH
55186: LD_INT 1
55188: NEG
55189: PUSH
55190: LD_INT 2
55192: NEG
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: PUSH
55198: LD_INT 0
55200: PUSH
55201: LD_INT 2
55203: NEG
55204: PUSH
55205: EMPTY
55206: LIST
55207: LIST
55208: PUSH
55209: LD_INT 1
55211: PUSH
55212: LD_INT 1
55214: NEG
55215: PUSH
55216: EMPTY
55217: LIST
55218: LIST
55219: PUSH
55220: LD_INT 2
55222: NEG
55223: PUSH
55224: LD_INT 1
55226: NEG
55227: PUSH
55228: EMPTY
55229: LIST
55230: LIST
55231: PUSH
55232: LD_INT 2
55234: NEG
55235: PUSH
55236: LD_INT 2
55238: NEG
55239: PUSH
55240: EMPTY
55241: LIST
55242: LIST
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
55258: LD_ADDR_VAR 0 48
55262: PUSH
55263: LD_INT 0
55265: PUSH
55266: LD_INT 0
55268: PUSH
55269: EMPTY
55270: LIST
55271: LIST
55272: PUSH
55273: LD_INT 0
55275: PUSH
55276: LD_INT 1
55278: NEG
55279: PUSH
55280: EMPTY
55281: LIST
55282: LIST
55283: PUSH
55284: LD_INT 1
55286: PUSH
55287: LD_INT 0
55289: PUSH
55290: EMPTY
55291: LIST
55292: LIST
55293: PUSH
55294: LD_INT 1
55296: PUSH
55297: LD_INT 1
55299: PUSH
55300: EMPTY
55301: LIST
55302: LIST
55303: PUSH
55304: LD_INT 0
55306: PUSH
55307: LD_INT 1
55309: PUSH
55310: EMPTY
55311: LIST
55312: LIST
55313: PUSH
55314: LD_INT 1
55316: NEG
55317: PUSH
55318: LD_INT 0
55320: PUSH
55321: EMPTY
55322: LIST
55323: LIST
55324: PUSH
55325: LD_INT 1
55327: NEG
55328: PUSH
55329: LD_INT 1
55331: NEG
55332: PUSH
55333: EMPTY
55334: LIST
55335: LIST
55336: PUSH
55337: LD_INT 1
55339: NEG
55340: PUSH
55341: LD_INT 2
55343: NEG
55344: PUSH
55345: EMPTY
55346: LIST
55347: LIST
55348: PUSH
55349: LD_INT 0
55351: PUSH
55352: LD_INT 2
55354: NEG
55355: PUSH
55356: EMPTY
55357: LIST
55358: LIST
55359: PUSH
55360: LD_INT 1
55362: PUSH
55363: LD_INT 1
55365: NEG
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PUSH
55371: LD_INT 2
55373: PUSH
55374: LD_INT 0
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: PUSH
55381: LD_INT 2
55383: PUSH
55384: LD_INT 1
55386: PUSH
55387: EMPTY
55388: LIST
55389: LIST
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: LIST
55395: LIST
55396: LIST
55397: LIST
55398: LIST
55399: LIST
55400: LIST
55401: LIST
55402: LIST
55403: LIST
55404: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
55405: LD_ADDR_VAR 0 49
55409: PUSH
55410: LD_INT 0
55412: PUSH
55413: LD_INT 0
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: PUSH
55420: LD_INT 0
55422: PUSH
55423: LD_INT 1
55425: NEG
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 1
55433: PUSH
55434: LD_INT 0
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: PUSH
55441: LD_INT 1
55443: PUSH
55444: LD_INT 1
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: PUSH
55451: LD_INT 0
55453: PUSH
55454: LD_INT 1
55456: PUSH
55457: EMPTY
55458: LIST
55459: LIST
55460: PUSH
55461: LD_INT 1
55463: NEG
55464: PUSH
55465: LD_INT 0
55467: PUSH
55468: EMPTY
55469: LIST
55470: LIST
55471: PUSH
55472: LD_INT 1
55474: NEG
55475: PUSH
55476: LD_INT 1
55478: NEG
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: PUSH
55484: LD_INT 1
55486: PUSH
55487: LD_INT 1
55489: NEG
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: PUSH
55495: LD_INT 2
55497: PUSH
55498: LD_INT 0
55500: PUSH
55501: EMPTY
55502: LIST
55503: LIST
55504: PUSH
55505: LD_INT 2
55507: PUSH
55508: LD_INT 1
55510: PUSH
55511: EMPTY
55512: LIST
55513: LIST
55514: PUSH
55515: LD_INT 2
55517: PUSH
55518: LD_INT 2
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PUSH
55525: LD_INT 1
55527: PUSH
55528: LD_INT 2
55530: PUSH
55531: EMPTY
55532: LIST
55533: LIST
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: LIST
55539: LIST
55540: LIST
55541: LIST
55542: LIST
55543: LIST
55544: LIST
55545: LIST
55546: LIST
55547: LIST
55548: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
55549: LD_ADDR_VAR 0 50
55553: PUSH
55554: LD_INT 0
55556: PUSH
55557: LD_INT 0
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: PUSH
55564: LD_INT 0
55566: PUSH
55567: LD_INT 1
55569: NEG
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: PUSH
55575: LD_INT 1
55577: PUSH
55578: LD_INT 0
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 1
55587: PUSH
55588: LD_INT 1
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: LD_INT 0
55597: PUSH
55598: LD_INT 1
55600: PUSH
55601: EMPTY
55602: LIST
55603: LIST
55604: PUSH
55605: LD_INT 1
55607: NEG
55608: PUSH
55609: LD_INT 0
55611: PUSH
55612: EMPTY
55613: LIST
55614: LIST
55615: PUSH
55616: LD_INT 1
55618: NEG
55619: PUSH
55620: LD_INT 1
55622: NEG
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: PUSH
55628: LD_INT 2
55630: PUSH
55631: LD_INT 1
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: PUSH
55638: LD_INT 2
55640: PUSH
55641: LD_INT 2
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: PUSH
55648: LD_INT 1
55650: PUSH
55651: LD_INT 2
55653: PUSH
55654: EMPTY
55655: LIST
55656: LIST
55657: PUSH
55658: LD_INT 0
55660: PUSH
55661: LD_INT 2
55663: PUSH
55664: EMPTY
55665: LIST
55666: LIST
55667: PUSH
55668: LD_INT 1
55670: NEG
55671: PUSH
55672: LD_INT 1
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: PUSH
55679: EMPTY
55680: LIST
55681: LIST
55682: LIST
55683: LIST
55684: LIST
55685: LIST
55686: LIST
55687: LIST
55688: LIST
55689: LIST
55690: LIST
55691: LIST
55692: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
55693: LD_ADDR_VAR 0 51
55697: PUSH
55698: LD_INT 0
55700: PUSH
55701: LD_INT 0
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: PUSH
55708: LD_INT 0
55710: PUSH
55711: LD_INT 1
55713: NEG
55714: PUSH
55715: EMPTY
55716: LIST
55717: LIST
55718: PUSH
55719: LD_INT 1
55721: PUSH
55722: LD_INT 0
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: PUSH
55729: LD_INT 1
55731: PUSH
55732: LD_INT 1
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: PUSH
55739: LD_INT 0
55741: PUSH
55742: LD_INT 1
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: PUSH
55749: LD_INT 1
55751: NEG
55752: PUSH
55753: LD_INT 0
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: PUSH
55760: LD_INT 1
55762: NEG
55763: PUSH
55764: LD_INT 1
55766: NEG
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: PUSH
55772: LD_INT 1
55774: PUSH
55775: LD_INT 2
55777: PUSH
55778: EMPTY
55779: LIST
55780: LIST
55781: PUSH
55782: LD_INT 0
55784: PUSH
55785: LD_INT 2
55787: PUSH
55788: EMPTY
55789: LIST
55790: LIST
55791: PUSH
55792: LD_INT 1
55794: NEG
55795: PUSH
55796: LD_INT 1
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: PUSH
55803: LD_INT 2
55805: NEG
55806: PUSH
55807: LD_INT 0
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: LD_INT 2
55816: NEG
55817: PUSH
55818: LD_INT 1
55820: NEG
55821: PUSH
55822: EMPTY
55823: LIST
55824: LIST
55825: PUSH
55826: EMPTY
55827: LIST
55828: LIST
55829: LIST
55830: LIST
55831: LIST
55832: LIST
55833: LIST
55834: LIST
55835: LIST
55836: LIST
55837: LIST
55838: LIST
55839: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55840: LD_ADDR_VAR 0 52
55844: PUSH
55845: LD_INT 0
55847: PUSH
55848: LD_INT 0
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: PUSH
55855: LD_INT 0
55857: PUSH
55858: LD_INT 1
55860: NEG
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: PUSH
55866: LD_INT 1
55868: PUSH
55869: LD_INT 0
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: PUSH
55876: LD_INT 1
55878: PUSH
55879: LD_INT 1
55881: PUSH
55882: EMPTY
55883: LIST
55884: LIST
55885: PUSH
55886: LD_INT 0
55888: PUSH
55889: LD_INT 1
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: PUSH
55896: LD_INT 1
55898: NEG
55899: PUSH
55900: LD_INT 0
55902: PUSH
55903: EMPTY
55904: LIST
55905: LIST
55906: PUSH
55907: LD_INT 1
55909: NEG
55910: PUSH
55911: LD_INT 1
55913: NEG
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: PUSH
55919: LD_INT 1
55921: NEG
55922: PUSH
55923: LD_INT 2
55925: NEG
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: PUSH
55931: LD_INT 1
55933: NEG
55934: PUSH
55935: LD_INT 1
55937: PUSH
55938: EMPTY
55939: LIST
55940: LIST
55941: PUSH
55942: LD_INT 2
55944: NEG
55945: PUSH
55946: LD_INT 0
55948: PUSH
55949: EMPTY
55950: LIST
55951: LIST
55952: PUSH
55953: LD_INT 2
55955: NEG
55956: PUSH
55957: LD_INT 1
55959: NEG
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: PUSH
55965: LD_INT 2
55967: NEG
55968: PUSH
55969: LD_INT 2
55971: NEG
55972: PUSH
55973: EMPTY
55974: LIST
55975: LIST
55976: PUSH
55977: EMPTY
55978: LIST
55979: LIST
55980: LIST
55981: LIST
55982: LIST
55983: LIST
55984: LIST
55985: LIST
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
55991: LD_ADDR_VAR 0 53
55995: PUSH
55996: LD_INT 0
55998: PUSH
55999: LD_INT 0
56001: PUSH
56002: EMPTY
56003: LIST
56004: LIST
56005: PUSH
56006: LD_INT 0
56008: PUSH
56009: LD_INT 1
56011: NEG
56012: PUSH
56013: EMPTY
56014: LIST
56015: LIST
56016: PUSH
56017: LD_INT 1
56019: PUSH
56020: LD_INT 0
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: PUSH
56027: LD_INT 1
56029: PUSH
56030: LD_INT 1
56032: PUSH
56033: EMPTY
56034: LIST
56035: LIST
56036: PUSH
56037: LD_INT 0
56039: PUSH
56040: LD_INT 1
56042: PUSH
56043: EMPTY
56044: LIST
56045: LIST
56046: PUSH
56047: LD_INT 1
56049: NEG
56050: PUSH
56051: LD_INT 0
56053: PUSH
56054: EMPTY
56055: LIST
56056: LIST
56057: PUSH
56058: LD_INT 1
56060: NEG
56061: PUSH
56062: LD_INT 1
56064: NEG
56065: PUSH
56066: EMPTY
56067: LIST
56068: LIST
56069: PUSH
56070: LD_INT 1
56072: NEG
56073: PUSH
56074: LD_INT 2
56076: NEG
56077: PUSH
56078: EMPTY
56079: LIST
56080: LIST
56081: PUSH
56082: LD_INT 0
56084: PUSH
56085: LD_INT 2
56087: NEG
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: PUSH
56093: LD_INT 1
56095: PUSH
56096: LD_INT 1
56098: NEG
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: PUSH
56104: LD_INT 2
56106: PUSH
56107: LD_INT 0
56109: PUSH
56110: EMPTY
56111: LIST
56112: LIST
56113: PUSH
56114: LD_INT 2
56116: PUSH
56117: LD_INT 1
56119: PUSH
56120: EMPTY
56121: LIST
56122: LIST
56123: PUSH
56124: LD_INT 2
56126: PUSH
56127: LD_INT 2
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: PUSH
56134: LD_INT 1
56136: PUSH
56137: LD_INT 2
56139: PUSH
56140: EMPTY
56141: LIST
56142: LIST
56143: PUSH
56144: LD_INT 0
56146: PUSH
56147: LD_INT 2
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: PUSH
56154: LD_INT 1
56156: NEG
56157: PUSH
56158: LD_INT 1
56160: PUSH
56161: EMPTY
56162: LIST
56163: LIST
56164: PUSH
56165: LD_INT 2
56167: NEG
56168: PUSH
56169: LD_INT 0
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: PUSH
56176: LD_INT 2
56178: NEG
56179: PUSH
56180: LD_INT 1
56182: NEG
56183: PUSH
56184: EMPTY
56185: LIST
56186: LIST
56187: PUSH
56188: LD_INT 2
56190: NEG
56191: PUSH
56192: LD_INT 2
56194: NEG
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: EMPTY
56201: LIST
56202: LIST
56203: LIST
56204: LIST
56205: LIST
56206: LIST
56207: LIST
56208: LIST
56209: LIST
56210: LIST
56211: LIST
56212: LIST
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: LIST
56218: LIST
56219: LIST
56220: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56221: LD_ADDR_VAR 0 54
56225: PUSH
56226: LD_INT 0
56228: PUSH
56229: LD_INT 0
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: PUSH
56236: LD_INT 0
56238: PUSH
56239: LD_INT 1
56241: NEG
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PUSH
56247: LD_INT 1
56249: PUSH
56250: LD_INT 0
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: PUSH
56257: LD_INT 1
56259: PUSH
56260: LD_INT 1
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: PUSH
56267: LD_INT 0
56269: PUSH
56270: LD_INT 1
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: PUSH
56277: LD_INT 1
56279: NEG
56280: PUSH
56281: LD_INT 0
56283: PUSH
56284: EMPTY
56285: LIST
56286: LIST
56287: PUSH
56288: LD_INT 1
56290: NEG
56291: PUSH
56292: LD_INT 1
56294: NEG
56295: PUSH
56296: EMPTY
56297: LIST
56298: LIST
56299: PUSH
56300: LD_INT 1
56302: NEG
56303: PUSH
56304: LD_INT 2
56306: NEG
56307: PUSH
56308: EMPTY
56309: LIST
56310: LIST
56311: PUSH
56312: LD_INT 0
56314: PUSH
56315: LD_INT 2
56317: NEG
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: LD_INT 1
56325: PUSH
56326: LD_INT 1
56328: NEG
56329: PUSH
56330: EMPTY
56331: LIST
56332: LIST
56333: PUSH
56334: LD_INT 2
56336: PUSH
56337: LD_INT 0
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: PUSH
56344: LD_INT 2
56346: PUSH
56347: LD_INT 1
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PUSH
56354: LD_INT 2
56356: PUSH
56357: LD_INT 2
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: PUSH
56364: LD_INT 1
56366: PUSH
56367: LD_INT 2
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: PUSH
56374: LD_INT 0
56376: PUSH
56377: LD_INT 2
56379: PUSH
56380: EMPTY
56381: LIST
56382: LIST
56383: PUSH
56384: LD_INT 1
56386: NEG
56387: PUSH
56388: LD_INT 1
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PUSH
56395: LD_INT 2
56397: NEG
56398: PUSH
56399: LD_INT 0
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: PUSH
56406: LD_INT 2
56408: NEG
56409: PUSH
56410: LD_INT 1
56412: NEG
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: PUSH
56418: LD_INT 2
56420: NEG
56421: PUSH
56422: LD_INT 2
56424: NEG
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: LIST
56434: LIST
56435: LIST
56436: LIST
56437: LIST
56438: LIST
56439: LIST
56440: LIST
56441: LIST
56442: LIST
56443: LIST
56444: LIST
56445: LIST
56446: LIST
56447: LIST
56448: LIST
56449: LIST
56450: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56451: LD_ADDR_VAR 0 55
56455: PUSH
56456: LD_INT 0
56458: PUSH
56459: LD_INT 0
56461: PUSH
56462: EMPTY
56463: LIST
56464: LIST
56465: PUSH
56466: LD_INT 0
56468: PUSH
56469: LD_INT 1
56471: NEG
56472: PUSH
56473: EMPTY
56474: LIST
56475: LIST
56476: PUSH
56477: LD_INT 1
56479: PUSH
56480: LD_INT 0
56482: PUSH
56483: EMPTY
56484: LIST
56485: LIST
56486: PUSH
56487: LD_INT 1
56489: PUSH
56490: LD_INT 1
56492: PUSH
56493: EMPTY
56494: LIST
56495: LIST
56496: PUSH
56497: LD_INT 0
56499: PUSH
56500: LD_INT 1
56502: PUSH
56503: EMPTY
56504: LIST
56505: LIST
56506: PUSH
56507: LD_INT 1
56509: NEG
56510: PUSH
56511: LD_INT 0
56513: PUSH
56514: EMPTY
56515: LIST
56516: LIST
56517: PUSH
56518: LD_INT 1
56520: NEG
56521: PUSH
56522: LD_INT 1
56524: NEG
56525: PUSH
56526: EMPTY
56527: LIST
56528: LIST
56529: PUSH
56530: LD_INT 1
56532: NEG
56533: PUSH
56534: LD_INT 2
56536: NEG
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: PUSH
56542: LD_INT 0
56544: PUSH
56545: LD_INT 2
56547: NEG
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: PUSH
56553: LD_INT 1
56555: PUSH
56556: LD_INT 1
56558: NEG
56559: PUSH
56560: EMPTY
56561: LIST
56562: LIST
56563: PUSH
56564: LD_INT 2
56566: PUSH
56567: LD_INT 0
56569: PUSH
56570: EMPTY
56571: LIST
56572: LIST
56573: PUSH
56574: LD_INT 2
56576: PUSH
56577: LD_INT 1
56579: PUSH
56580: EMPTY
56581: LIST
56582: LIST
56583: PUSH
56584: LD_INT 2
56586: PUSH
56587: LD_INT 2
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: PUSH
56594: LD_INT 1
56596: PUSH
56597: LD_INT 2
56599: PUSH
56600: EMPTY
56601: LIST
56602: LIST
56603: PUSH
56604: LD_INT 0
56606: PUSH
56607: LD_INT 2
56609: PUSH
56610: EMPTY
56611: LIST
56612: LIST
56613: PUSH
56614: LD_INT 1
56616: NEG
56617: PUSH
56618: LD_INT 1
56620: PUSH
56621: EMPTY
56622: LIST
56623: LIST
56624: PUSH
56625: LD_INT 2
56627: NEG
56628: PUSH
56629: LD_INT 0
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: PUSH
56636: LD_INT 2
56638: NEG
56639: PUSH
56640: LD_INT 1
56642: NEG
56643: PUSH
56644: EMPTY
56645: LIST
56646: LIST
56647: PUSH
56648: LD_INT 2
56650: NEG
56651: PUSH
56652: LD_INT 2
56654: NEG
56655: PUSH
56656: EMPTY
56657: LIST
56658: LIST
56659: PUSH
56660: EMPTY
56661: LIST
56662: LIST
56663: LIST
56664: LIST
56665: LIST
56666: LIST
56667: LIST
56668: LIST
56669: LIST
56670: LIST
56671: LIST
56672: LIST
56673: LIST
56674: LIST
56675: LIST
56676: LIST
56677: LIST
56678: LIST
56679: LIST
56680: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56681: LD_ADDR_VAR 0 56
56685: PUSH
56686: LD_INT 0
56688: PUSH
56689: LD_INT 0
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: PUSH
56696: LD_INT 0
56698: PUSH
56699: LD_INT 1
56701: NEG
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PUSH
56707: LD_INT 1
56709: PUSH
56710: LD_INT 0
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: PUSH
56717: LD_INT 1
56719: PUSH
56720: LD_INT 1
56722: PUSH
56723: EMPTY
56724: LIST
56725: LIST
56726: PUSH
56727: LD_INT 0
56729: PUSH
56730: LD_INT 1
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: PUSH
56737: LD_INT 1
56739: NEG
56740: PUSH
56741: LD_INT 0
56743: PUSH
56744: EMPTY
56745: LIST
56746: LIST
56747: PUSH
56748: LD_INT 1
56750: NEG
56751: PUSH
56752: LD_INT 1
56754: NEG
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: PUSH
56760: LD_INT 1
56762: NEG
56763: PUSH
56764: LD_INT 2
56766: NEG
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PUSH
56772: LD_INT 0
56774: PUSH
56775: LD_INT 2
56777: NEG
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PUSH
56783: LD_INT 1
56785: PUSH
56786: LD_INT 1
56788: NEG
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PUSH
56794: LD_INT 2
56796: PUSH
56797: LD_INT 0
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: PUSH
56804: LD_INT 2
56806: PUSH
56807: LD_INT 1
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: PUSH
56814: LD_INT 2
56816: PUSH
56817: LD_INT 2
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: PUSH
56824: LD_INT 1
56826: PUSH
56827: LD_INT 2
56829: PUSH
56830: EMPTY
56831: LIST
56832: LIST
56833: PUSH
56834: LD_INT 0
56836: PUSH
56837: LD_INT 2
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PUSH
56844: LD_INT 1
56846: NEG
56847: PUSH
56848: LD_INT 1
56850: PUSH
56851: EMPTY
56852: LIST
56853: LIST
56854: PUSH
56855: LD_INT 2
56857: NEG
56858: PUSH
56859: LD_INT 0
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: PUSH
56866: LD_INT 2
56868: NEG
56869: PUSH
56870: LD_INT 1
56872: NEG
56873: PUSH
56874: EMPTY
56875: LIST
56876: LIST
56877: PUSH
56878: LD_INT 2
56880: NEG
56881: PUSH
56882: LD_INT 2
56884: NEG
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: PUSH
56890: EMPTY
56891: LIST
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: LIST
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: LIST
56905: LIST
56906: LIST
56907: LIST
56908: LIST
56909: LIST
56910: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56911: LD_ADDR_VAR 0 57
56915: PUSH
56916: LD_INT 0
56918: PUSH
56919: LD_INT 0
56921: PUSH
56922: EMPTY
56923: LIST
56924: LIST
56925: PUSH
56926: LD_INT 0
56928: PUSH
56929: LD_INT 1
56931: NEG
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: PUSH
56937: LD_INT 1
56939: PUSH
56940: LD_INT 0
56942: PUSH
56943: EMPTY
56944: LIST
56945: LIST
56946: PUSH
56947: LD_INT 1
56949: PUSH
56950: LD_INT 1
56952: PUSH
56953: EMPTY
56954: LIST
56955: LIST
56956: PUSH
56957: LD_INT 0
56959: PUSH
56960: LD_INT 1
56962: PUSH
56963: EMPTY
56964: LIST
56965: LIST
56966: PUSH
56967: LD_INT 1
56969: NEG
56970: PUSH
56971: LD_INT 0
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: PUSH
56978: LD_INT 1
56980: NEG
56981: PUSH
56982: LD_INT 1
56984: NEG
56985: PUSH
56986: EMPTY
56987: LIST
56988: LIST
56989: PUSH
56990: LD_INT 1
56992: NEG
56993: PUSH
56994: LD_INT 2
56996: NEG
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: PUSH
57002: LD_INT 0
57004: PUSH
57005: LD_INT 2
57007: NEG
57008: PUSH
57009: EMPTY
57010: LIST
57011: LIST
57012: PUSH
57013: LD_INT 1
57015: PUSH
57016: LD_INT 1
57018: NEG
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: PUSH
57024: LD_INT 2
57026: PUSH
57027: LD_INT 0
57029: PUSH
57030: EMPTY
57031: LIST
57032: LIST
57033: PUSH
57034: LD_INT 2
57036: PUSH
57037: LD_INT 1
57039: PUSH
57040: EMPTY
57041: LIST
57042: LIST
57043: PUSH
57044: LD_INT 2
57046: PUSH
57047: LD_INT 2
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: PUSH
57054: LD_INT 1
57056: PUSH
57057: LD_INT 2
57059: PUSH
57060: EMPTY
57061: LIST
57062: LIST
57063: PUSH
57064: LD_INT 0
57066: PUSH
57067: LD_INT 2
57069: PUSH
57070: EMPTY
57071: LIST
57072: LIST
57073: PUSH
57074: LD_INT 1
57076: NEG
57077: PUSH
57078: LD_INT 1
57080: PUSH
57081: EMPTY
57082: LIST
57083: LIST
57084: PUSH
57085: LD_INT 2
57087: NEG
57088: PUSH
57089: LD_INT 0
57091: PUSH
57092: EMPTY
57093: LIST
57094: LIST
57095: PUSH
57096: LD_INT 2
57098: NEG
57099: PUSH
57100: LD_INT 1
57102: NEG
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PUSH
57108: LD_INT 2
57110: NEG
57111: PUSH
57112: LD_INT 2
57114: NEG
57115: PUSH
57116: EMPTY
57117: LIST
57118: LIST
57119: PUSH
57120: EMPTY
57121: LIST
57122: LIST
57123: LIST
57124: LIST
57125: LIST
57126: LIST
57127: LIST
57128: LIST
57129: LIST
57130: LIST
57131: LIST
57132: LIST
57133: LIST
57134: LIST
57135: LIST
57136: LIST
57137: LIST
57138: LIST
57139: LIST
57140: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57141: LD_ADDR_VAR 0 58
57145: PUSH
57146: LD_INT 0
57148: PUSH
57149: LD_INT 0
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: PUSH
57156: LD_INT 0
57158: PUSH
57159: LD_INT 1
57161: NEG
57162: PUSH
57163: EMPTY
57164: LIST
57165: LIST
57166: PUSH
57167: LD_INT 1
57169: PUSH
57170: LD_INT 0
57172: PUSH
57173: EMPTY
57174: LIST
57175: LIST
57176: PUSH
57177: LD_INT 1
57179: PUSH
57180: LD_INT 1
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: PUSH
57187: LD_INT 0
57189: PUSH
57190: LD_INT 1
57192: PUSH
57193: EMPTY
57194: LIST
57195: LIST
57196: PUSH
57197: LD_INT 1
57199: NEG
57200: PUSH
57201: LD_INT 0
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: LD_INT 1
57210: NEG
57211: PUSH
57212: LD_INT 1
57214: NEG
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: PUSH
57220: LD_INT 1
57222: NEG
57223: PUSH
57224: LD_INT 2
57226: NEG
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 0
57234: PUSH
57235: LD_INT 2
57237: NEG
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: LD_INT 1
57245: PUSH
57246: LD_INT 1
57248: NEG
57249: PUSH
57250: EMPTY
57251: LIST
57252: LIST
57253: PUSH
57254: LD_INT 2
57256: PUSH
57257: LD_INT 0
57259: PUSH
57260: EMPTY
57261: LIST
57262: LIST
57263: PUSH
57264: LD_INT 2
57266: PUSH
57267: LD_INT 1
57269: PUSH
57270: EMPTY
57271: LIST
57272: LIST
57273: PUSH
57274: LD_INT 2
57276: PUSH
57277: LD_INT 2
57279: PUSH
57280: EMPTY
57281: LIST
57282: LIST
57283: PUSH
57284: LD_INT 1
57286: PUSH
57287: LD_INT 2
57289: PUSH
57290: EMPTY
57291: LIST
57292: LIST
57293: PUSH
57294: LD_INT 0
57296: PUSH
57297: LD_INT 2
57299: PUSH
57300: EMPTY
57301: LIST
57302: LIST
57303: PUSH
57304: LD_INT 1
57306: NEG
57307: PUSH
57308: LD_INT 1
57310: PUSH
57311: EMPTY
57312: LIST
57313: LIST
57314: PUSH
57315: LD_INT 2
57317: NEG
57318: PUSH
57319: LD_INT 0
57321: PUSH
57322: EMPTY
57323: LIST
57324: LIST
57325: PUSH
57326: LD_INT 2
57328: NEG
57329: PUSH
57330: LD_INT 1
57332: NEG
57333: PUSH
57334: EMPTY
57335: LIST
57336: LIST
57337: PUSH
57338: LD_INT 2
57340: NEG
57341: PUSH
57342: LD_INT 2
57344: NEG
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: LIST
57354: LIST
57355: LIST
57356: LIST
57357: LIST
57358: LIST
57359: LIST
57360: LIST
57361: LIST
57362: LIST
57363: LIST
57364: LIST
57365: LIST
57366: LIST
57367: LIST
57368: LIST
57369: LIST
57370: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57371: LD_ADDR_VAR 0 59
57375: PUSH
57376: LD_INT 0
57378: PUSH
57379: LD_INT 0
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: LD_INT 0
57388: PUSH
57389: LD_INT 1
57391: NEG
57392: PUSH
57393: EMPTY
57394: LIST
57395: LIST
57396: PUSH
57397: LD_INT 1
57399: PUSH
57400: LD_INT 0
57402: PUSH
57403: EMPTY
57404: LIST
57405: LIST
57406: PUSH
57407: LD_INT 1
57409: PUSH
57410: LD_INT 1
57412: PUSH
57413: EMPTY
57414: LIST
57415: LIST
57416: PUSH
57417: LD_INT 0
57419: PUSH
57420: LD_INT 1
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: PUSH
57427: LD_INT 1
57429: NEG
57430: PUSH
57431: LD_INT 0
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: PUSH
57438: LD_INT 1
57440: NEG
57441: PUSH
57442: LD_INT 1
57444: NEG
57445: PUSH
57446: EMPTY
57447: LIST
57448: LIST
57449: PUSH
57450: EMPTY
57451: LIST
57452: LIST
57453: LIST
57454: LIST
57455: LIST
57456: LIST
57457: LIST
57458: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57459: LD_ADDR_VAR 0 60
57463: PUSH
57464: LD_INT 0
57466: PUSH
57467: LD_INT 0
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: PUSH
57474: LD_INT 0
57476: PUSH
57477: LD_INT 1
57479: NEG
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PUSH
57485: LD_INT 1
57487: PUSH
57488: LD_INT 0
57490: PUSH
57491: EMPTY
57492: LIST
57493: LIST
57494: PUSH
57495: LD_INT 1
57497: PUSH
57498: LD_INT 1
57500: PUSH
57501: EMPTY
57502: LIST
57503: LIST
57504: PUSH
57505: LD_INT 0
57507: PUSH
57508: LD_INT 1
57510: PUSH
57511: EMPTY
57512: LIST
57513: LIST
57514: PUSH
57515: LD_INT 1
57517: NEG
57518: PUSH
57519: LD_INT 0
57521: PUSH
57522: EMPTY
57523: LIST
57524: LIST
57525: PUSH
57526: LD_INT 1
57528: NEG
57529: PUSH
57530: LD_INT 1
57532: NEG
57533: PUSH
57534: EMPTY
57535: LIST
57536: LIST
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: LIST
57542: LIST
57543: LIST
57544: LIST
57545: LIST
57546: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57547: LD_ADDR_VAR 0 61
57551: PUSH
57552: LD_INT 0
57554: PUSH
57555: LD_INT 0
57557: PUSH
57558: EMPTY
57559: LIST
57560: LIST
57561: PUSH
57562: LD_INT 0
57564: PUSH
57565: LD_INT 1
57567: NEG
57568: PUSH
57569: EMPTY
57570: LIST
57571: LIST
57572: PUSH
57573: LD_INT 1
57575: PUSH
57576: LD_INT 0
57578: PUSH
57579: EMPTY
57580: LIST
57581: LIST
57582: PUSH
57583: LD_INT 1
57585: PUSH
57586: LD_INT 1
57588: PUSH
57589: EMPTY
57590: LIST
57591: LIST
57592: PUSH
57593: LD_INT 0
57595: PUSH
57596: LD_INT 1
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: PUSH
57603: LD_INT 1
57605: NEG
57606: PUSH
57607: LD_INT 0
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: PUSH
57614: LD_INT 1
57616: NEG
57617: PUSH
57618: LD_INT 1
57620: NEG
57621: PUSH
57622: EMPTY
57623: LIST
57624: LIST
57625: PUSH
57626: EMPTY
57627: LIST
57628: LIST
57629: LIST
57630: LIST
57631: LIST
57632: LIST
57633: LIST
57634: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57635: LD_ADDR_VAR 0 62
57639: PUSH
57640: LD_INT 0
57642: PUSH
57643: LD_INT 0
57645: PUSH
57646: EMPTY
57647: LIST
57648: LIST
57649: PUSH
57650: LD_INT 0
57652: PUSH
57653: LD_INT 1
57655: NEG
57656: PUSH
57657: EMPTY
57658: LIST
57659: LIST
57660: PUSH
57661: LD_INT 1
57663: PUSH
57664: LD_INT 0
57666: PUSH
57667: EMPTY
57668: LIST
57669: LIST
57670: PUSH
57671: LD_INT 1
57673: PUSH
57674: LD_INT 1
57676: PUSH
57677: EMPTY
57678: LIST
57679: LIST
57680: PUSH
57681: LD_INT 0
57683: PUSH
57684: LD_INT 1
57686: PUSH
57687: EMPTY
57688: LIST
57689: LIST
57690: PUSH
57691: LD_INT 1
57693: NEG
57694: PUSH
57695: LD_INT 0
57697: PUSH
57698: EMPTY
57699: LIST
57700: LIST
57701: PUSH
57702: LD_INT 1
57704: NEG
57705: PUSH
57706: LD_INT 1
57708: NEG
57709: PUSH
57710: EMPTY
57711: LIST
57712: LIST
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: LIST
57718: LIST
57719: LIST
57720: LIST
57721: LIST
57722: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57723: LD_ADDR_VAR 0 63
57727: PUSH
57728: LD_INT 0
57730: PUSH
57731: LD_INT 0
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: PUSH
57738: LD_INT 0
57740: PUSH
57741: LD_INT 1
57743: NEG
57744: PUSH
57745: EMPTY
57746: LIST
57747: LIST
57748: PUSH
57749: LD_INT 1
57751: PUSH
57752: LD_INT 0
57754: PUSH
57755: EMPTY
57756: LIST
57757: LIST
57758: PUSH
57759: LD_INT 1
57761: PUSH
57762: LD_INT 1
57764: PUSH
57765: EMPTY
57766: LIST
57767: LIST
57768: PUSH
57769: LD_INT 0
57771: PUSH
57772: LD_INT 1
57774: PUSH
57775: EMPTY
57776: LIST
57777: LIST
57778: PUSH
57779: LD_INT 1
57781: NEG
57782: PUSH
57783: LD_INT 0
57785: PUSH
57786: EMPTY
57787: LIST
57788: LIST
57789: PUSH
57790: LD_INT 1
57792: NEG
57793: PUSH
57794: LD_INT 1
57796: NEG
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: PUSH
57802: EMPTY
57803: LIST
57804: LIST
57805: LIST
57806: LIST
57807: LIST
57808: LIST
57809: LIST
57810: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
57811: LD_ADDR_VAR 0 64
57815: PUSH
57816: LD_INT 0
57818: PUSH
57819: LD_INT 0
57821: PUSH
57822: EMPTY
57823: LIST
57824: LIST
57825: PUSH
57826: LD_INT 0
57828: PUSH
57829: LD_INT 1
57831: NEG
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: PUSH
57837: LD_INT 1
57839: PUSH
57840: LD_INT 0
57842: PUSH
57843: EMPTY
57844: LIST
57845: LIST
57846: PUSH
57847: LD_INT 1
57849: PUSH
57850: LD_INT 1
57852: PUSH
57853: EMPTY
57854: LIST
57855: LIST
57856: PUSH
57857: LD_INT 0
57859: PUSH
57860: LD_INT 1
57862: PUSH
57863: EMPTY
57864: LIST
57865: LIST
57866: PUSH
57867: LD_INT 1
57869: NEG
57870: PUSH
57871: LD_INT 0
57873: PUSH
57874: EMPTY
57875: LIST
57876: LIST
57877: PUSH
57878: LD_INT 1
57880: NEG
57881: PUSH
57882: LD_INT 1
57884: NEG
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: LIST
57894: LIST
57895: LIST
57896: LIST
57897: LIST
57898: ST_TO_ADDR
// end ; 1 :
57899: GO 63796
57901: LD_INT 1
57903: DOUBLE
57904: EQUAL
57905: IFTRUE 57909
57907: GO 60532
57909: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
57910: LD_ADDR_VAR 0 11
57914: PUSH
57915: LD_INT 1
57917: NEG
57918: PUSH
57919: LD_INT 3
57921: NEG
57922: PUSH
57923: EMPTY
57924: LIST
57925: LIST
57926: PUSH
57927: LD_INT 0
57929: PUSH
57930: LD_INT 3
57932: NEG
57933: PUSH
57934: EMPTY
57935: LIST
57936: LIST
57937: PUSH
57938: LD_INT 1
57940: PUSH
57941: LD_INT 2
57943: NEG
57944: PUSH
57945: EMPTY
57946: LIST
57947: LIST
57948: PUSH
57949: EMPTY
57950: LIST
57951: LIST
57952: LIST
57953: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
57954: LD_ADDR_VAR 0 12
57958: PUSH
57959: LD_INT 2
57961: PUSH
57962: LD_INT 1
57964: NEG
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: PUSH
57970: LD_INT 3
57972: PUSH
57973: LD_INT 0
57975: PUSH
57976: EMPTY
57977: LIST
57978: LIST
57979: PUSH
57980: LD_INT 3
57982: PUSH
57983: LD_INT 1
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: PUSH
57990: EMPTY
57991: LIST
57992: LIST
57993: LIST
57994: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
57995: LD_ADDR_VAR 0 13
57999: PUSH
58000: LD_INT 3
58002: PUSH
58003: LD_INT 2
58005: PUSH
58006: EMPTY
58007: LIST
58008: LIST
58009: PUSH
58010: LD_INT 3
58012: PUSH
58013: LD_INT 3
58015: PUSH
58016: EMPTY
58017: LIST
58018: LIST
58019: PUSH
58020: LD_INT 2
58022: PUSH
58023: LD_INT 3
58025: PUSH
58026: EMPTY
58027: LIST
58028: LIST
58029: PUSH
58030: EMPTY
58031: LIST
58032: LIST
58033: LIST
58034: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
58035: LD_ADDR_VAR 0 14
58039: PUSH
58040: LD_INT 1
58042: PUSH
58043: LD_INT 3
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: PUSH
58050: LD_INT 0
58052: PUSH
58053: LD_INT 3
58055: PUSH
58056: EMPTY
58057: LIST
58058: LIST
58059: PUSH
58060: LD_INT 1
58062: NEG
58063: PUSH
58064: LD_INT 2
58066: PUSH
58067: EMPTY
58068: LIST
58069: LIST
58070: PUSH
58071: EMPTY
58072: LIST
58073: LIST
58074: LIST
58075: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
58076: LD_ADDR_VAR 0 15
58080: PUSH
58081: LD_INT 2
58083: NEG
58084: PUSH
58085: LD_INT 1
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: PUSH
58092: LD_INT 3
58094: NEG
58095: PUSH
58096: LD_INT 0
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: PUSH
58103: LD_INT 3
58105: NEG
58106: PUSH
58107: LD_INT 1
58109: NEG
58110: PUSH
58111: EMPTY
58112: LIST
58113: LIST
58114: PUSH
58115: EMPTY
58116: LIST
58117: LIST
58118: LIST
58119: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
58120: LD_ADDR_VAR 0 16
58124: PUSH
58125: LD_INT 2
58127: NEG
58128: PUSH
58129: LD_INT 3
58131: NEG
58132: PUSH
58133: EMPTY
58134: LIST
58135: LIST
58136: PUSH
58137: LD_INT 3
58139: NEG
58140: PUSH
58141: LD_INT 2
58143: NEG
58144: PUSH
58145: EMPTY
58146: LIST
58147: LIST
58148: PUSH
58149: LD_INT 3
58151: NEG
58152: PUSH
58153: LD_INT 3
58155: NEG
58156: PUSH
58157: EMPTY
58158: LIST
58159: LIST
58160: PUSH
58161: EMPTY
58162: LIST
58163: LIST
58164: LIST
58165: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
58166: LD_ADDR_VAR 0 17
58170: PUSH
58171: LD_INT 1
58173: NEG
58174: PUSH
58175: LD_INT 3
58177: NEG
58178: PUSH
58179: EMPTY
58180: LIST
58181: LIST
58182: PUSH
58183: LD_INT 0
58185: PUSH
58186: LD_INT 3
58188: NEG
58189: PUSH
58190: EMPTY
58191: LIST
58192: LIST
58193: PUSH
58194: LD_INT 1
58196: PUSH
58197: LD_INT 2
58199: NEG
58200: PUSH
58201: EMPTY
58202: LIST
58203: LIST
58204: PUSH
58205: EMPTY
58206: LIST
58207: LIST
58208: LIST
58209: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
58210: LD_ADDR_VAR 0 18
58214: PUSH
58215: LD_INT 2
58217: PUSH
58218: LD_INT 1
58220: NEG
58221: PUSH
58222: EMPTY
58223: LIST
58224: LIST
58225: PUSH
58226: LD_INT 3
58228: PUSH
58229: LD_INT 0
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: PUSH
58236: LD_INT 3
58238: PUSH
58239: LD_INT 1
58241: PUSH
58242: EMPTY
58243: LIST
58244: LIST
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: LIST
58250: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
58251: LD_ADDR_VAR 0 19
58255: PUSH
58256: LD_INT 3
58258: PUSH
58259: LD_INT 2
58261: PUSH
58262: EMPTY
58263: LIST
58264: LIST
58265: PUSH
58266: LD_INT 3
58268: PUSH
58269: LD_INT 3
58271: PUSH
58272: EMPTY
58273: LIST
58274: LIST
58275: PUSH
58276: LD_INT 2
58278: PUSH
58279: LD_INT 3
58281: PUSH
58282: EMPTY
58283: LIST
58284: LIST
58285: PUSH
58286: EMPTY
58287: LIST
58288: LIST
58289: LIST
58290: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
58291: LD_ADDR_VAR 0 20
58295: PUSH
58296: LD_INT 1
58298: PUSH
58299: LD_INT 3
58301: PUSH
58302: EMPTY
58303: LIST
58304: LIST
58305: PUSH
58306: LD_INT 0
58308: PUSH
58309: LD_INT 3
58311: PUSH
58312: EMPTY
58313: LIST
58314: LIST
58315: PUSH
58316: LD_INT 1
58318: NEG
58319: PUSH
58320: LD_INT 2
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: PUSH
58327: EMPTY
58328: LIST
58329: LIST
58330: LIST
58331: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
58332: LD_ADDR_VAR 0 21
58336: PUSH
58337: LD_INT 2
58339: NEG
58340: PUSH
58341: LD_INT 1
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: PUSH
58348: LD_INT 3
58350: NEG
58351: PUSH
58352: LD_INT 0
58354: PUSH
58355: EMPTY
58356: LIST
58357: LIST
58358: PUSH
58359: LD_INT 3
58361: NEG
58362: PUSH
58363: LD_INT 1
58365: NEG
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: LIST
58375: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
58376: LD_ADDR_VAR 0 22
58380: PUSH
58381: LD_INT 2
58383: NEG
58384: PUSH
58385: LD_INT 3
58387: NEG
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: PUSH
58393: LD_INT 3
58395: NEG
58396: PUSH
58397: LD_INT 2
58399: NEG
58400: PUSH
58401: EMPTY
58402: LIST
58403: LIST
58404: PUSH
58405: LD_INT 3
58407: NEG
58408: PUSH
58409: LD_INT 3
58411: NEG
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: LIST
58421: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
58422: LD_ADDR_VAR 0 23
58426: PUSH
58427: LD_INT 0
58429: PUSH
58430: LD_INT 3
58432: NEG
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: LD_INT 1
58440: NEG
58441: PUSH
58442: LD_INT 4
58444: NEG
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: PUSH
58450: LD_INT 1
58452: PUSH
58453: LD_INT 3
58455: NEG
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PUSH
58461: EMPTY
58462: LIST
58463: LIST
58464: LIST
58465: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
58466: LD_ADDR_VAR 0 24
58470: PUSH
58471: LD_INT 3
58473: PUSH
58474: LD_INT 0
58476: PUSH
58477: EMPTY
58478: LIST
58479: LIST
58480: PUSH
58481: LD_INT 3
58483: PUSH
58484: LD_INT 1
58486: NEG
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: PUSH
58492: LD_INT 4
58494: PUSH
58495: LD_INT 1
58497: PUSH
58498: EMPTY
58499: LIST
58500: LIST
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: LIST
58506: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
58507: LD_ADDR_VAR 0 25
58511: PUSH
58512: LD_INT 3
58514: PUSH
58515: LD_INT 3
58517: PUSH
58518: EMPTY
58519: LIST
58520: LIST
58521: PUSH
58522: LD_INT 4
58524: PUSH
58525: LD_INT 3
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: PUSH
58532: LD_INT 3
58534: PUSH
58535: LD_INT 4
58537: PUSH
58538: EMPTY
58539: LIST
58540: LIST
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: LIST
58546: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
58547: LD_ADDR_VAR 0 26
58551: PUSH
58552: LD_INT 0
58554: PUSH
58555: LD_INT 3
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: PUSH
58562: LD_INT 1
58564: PUSH
58565: LD_INT 4
58567: PUSH
58568: EMPTY
58569: LIST
58570: LIST
58571: PUSH
58572: LD_INT 1
58574: NEG
58575: PUSH
58576: LD_INT 3
58578: PUSH
58579: EMPTY
58580: LIST
58581: LIST
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: LIST
58587: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
58588: LD_ADDR_VAR 0 27
58592: PUSH
58593: LD_INT 3
58595: NEG
58596: PUSH
58597: LD_INT 0
58599: PUSH
58600: EMPTY
58601: LIST
58602: LIST
58603: PUSH
58604: LD_INT 3
58606: NEG
58607: PUSH
58608: LD_INT 1
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: PUSH
58615: LD_INT 4
58617: NEG
58618: PUSH
58619: LD_INT 1
58621: NEG
58622: PUSH
58623: EMPTY
58624: LIST
58625: LIST
58626: PUSH
58627: EMPTY
58628: LIST
58629: LIST
58630: LIST
58631: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
58632: LD_ADDR_VAR 0 28
58636: PUSH
58637: LD_INT 3
58639: NEG
58640: PUSH
58641: LD_INT 3
58643: NEG
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: PUSH
58649: LD_INT 3
58651: NEG
58652: PUSH
58653: LD_INT 4
58655: NEG
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: PUSH
58661: LD_INT 4
58663: NEG
58664: PUSH
58665: LD_INT 3
58667: NEG
58668: PUSH
58669: EMPTY
58670: LIST
58671: LIST
58672: PUSH
58673: EMPTY
58674: LIST
58675: LIST
58676: LIST
58677: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
58678: LD_ADDR_VAR 0 29
58682: PUSH
58683: LD_INT 1
58685: NEG
58686: PUSH
58687: LD_INT 3
58689: NEG
58690: PUSH
58691: EMPTY
58692: LIST
58693: LIST
58694: PUSH
58695: LD_INT 0
58697: PUSH
58698: LD_INT 3
58700: NEG
58701: PUSH
58702: EMPTY
58703: LIST
58704: LIST
58705: PUSH
58706: LD_INT 1
58708: PUSH
58709: LD_INT 2
58711: NEG
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: PUSH
58717: LD_INT 1
58719: NEG
58720: PUSH
58721: LD_INT 4
58723: NEG
58724: PUSH
58725: EMPTY
58726: LIST
58727: LIST
58728: PUSH
58729: LD_INT 0
58731: PUSH
58732: LD_INT 4
58734: NEG
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: PUSH
58740: LD_INT 1
58742: PUSH
58743: LD_INT 3
58745: NEG
58746: PUSH
58747: EMPTY
58748: LIST
58749: LIST
58750: PUSH
58751: LD_INT 1
58753: NEG
58754: PUSH
58755: LD_INT 5
58757: NEG
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PUSH
58763: LD_INT 0
58765: PUSH
58766: LD_INT 5
58768: NEG
58769: PUSH
58770: EMPTY
58771: LIST
58772: LIST
58773: PUSH
58774: LD_INT 1
58776: PUSH
58777: LD_INT 4
58779: NEG
58780: PUSH
58781: EMPTY
58782: LIST
58783: LIST
58784: PUSH
58785: LD_INT 1
58787: NEG
58788: PUSH
58789: LD_INT 6
58791: NEG
58792: PUSH
58793: EMPTY
58794: LIST
58795: LIST
58796: PUSH
58797: LD_INT 0
58799: PUSH
58800: LD_INT 6
58802: NEG
58803: PUSH
58804: EMPTY
58805: LIST
58806: LIST
58807: PUSH
58808: LD_INT 1
58810: PUSH
58811: LD_INT 5
58813: NEG
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: PUSH
58819: EMPTY
58820: LIST
58821: LIST
58822: LIST
58823: LIST
58824: LIST
58825: LIST
58826: LIST
58827: LIST
58828: LIST
58829: LIST
58830: LIST
58831: LIST
58832: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
58833: LD_ADDR_VAR 0 30
58837: PUSH
58838: LD_INT 2
58840: PUSH
58841: LD_INT 1
58843: NEG
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: PUSH
58849: LD_INT 3
58851: PUSH
58852: LD_INT 0
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: PUSH
58859: LD_INT 3
58861: PUSH
58862: LD_INT 1
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 3
58871: PUSH
58872: LD_INT 1
58874: NEG
58875: PUSH
58876: EMPTY
58877: LIST
58878: LIST
58879: PUSH
58880: LD_INT 4
58882: PUSH
58883: LD_INT 0
58885: PUSH
58886: EMPTY
58887: LIST
58888: LIST
58889: PUSH
58890: LD_INT 4
58892: PUSH
58893: LD_INT 1
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: PUSH
58900: LD_INT 4
58902: PUSH
58903: LD_INT 1
58905: NEG
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PUSH
58911: LD_INT 5
58913: PUSH
58914: LD_INT 0
58916: PUSH
58917: EMPTY
58918: LIST
58919: LIST
58920: PUSH
58921: LD_INT 5
58923: PUSH
58924: LD_INT 1
58926: PUSH
58927: EMPTY
58928: LIST
58929: LIST
58930: PUSH
58931: LD_INT 5
58933: PUSH
58934: LD_INT 1
58936: NEG
58937: PUSH
58938: EMPTY
58939: LIST
58940: LIST
58941: PUSH
58942: LD_INT 6
58944: PUSH
58945: LD_INT 0
58947: PUSH
58948: EMPTY
58949: LIST
58950: LIST
58951: PUSH
58952: LD_INT 6
58954: PUSH
58955: LD_INT 1
58957: PUSH
58958: EMPTY
58959: LIST
58960: LIST
58961: PUSH
58962: EMPTY
58963: LIST
58964: LIST
58965: LIST
58966: LIST
58967: LIST
58968: LIST
58969: LIST
58970: LIST
58971: LIST
58972: LIST
58973: LIST
58974: LIST
58975: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
58976: LD_ADDR_VAR 0 31
58980: PUSH
58981: LD_INT 3
58983: PUSH
58984: LD_INT 2
58986: PUSH
58987: EMPTY
58988: LIST
58989: LIST
58990: PUSH
58991: LD_INT 3
58993: PUSH
58994: LD_INT 3
58996: PUSH
58997: EMPTY
58998: LIST
58999: LIST
59000: PUSH
59001: LD_INT 2
59003: PUSH
59004: LD_INT 3
59006: PUSH
59007: EMPTY
59008: LIST
59009: LIST
59010: PUSH
59011: LD_INT 4
59013: PUSH
59014: LD_INT 3
59016: PUSH
59017: EMPTY
59018: LIST
59019: LIST
59020: PUSH
59021: LD_INT 4
59023: PUSH
59024: LD_INT 4
59026: PUSH
59027: EMPTY
59028: LIST
59029: LIST
59030: PUSH
59031: LD_INT 3
59033: PUSH
59034: LD_INT 4
59036: PUSH
59037: EMPTY
59038: LIST
59039: LIST
59040: PUSH
59041: LD_INT 5
59043: PUSH
59044: LD_INT 4
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PUSH
59051: LD_INT 5
59053: PUSH
59054: LD_INT 5
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: PUSH
59061: LD_INT 4
59063: PUSH
59064: LD_INT 5
59066: PUSH
59067: EMPTY
59068: LIST
59069: LIST
59070: PUSH
59071: LD_INT 6
59073: PUSH
59074: LD_INT 5
59076: PUSH
59077: EMPTY
59078: LIST
59079: LIST
59080: PUSH
59081: LD_INT 6
59083: PUSH
59084: LD_INT 6
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: PUSH
59091: LD_INT 5
59093: PUSH
59094: LD_INT 6
59096: PUSH
59097: EMPTY
59098: LIST
59099: LIST
59100: PUSH
59101: EMPTY
59102: LIST
59103: LIST
59104: LIST
59105: LIST
59106: LIST
59107: LIST
59108: LIST
59109: LIST
59110: LIST
59111: LIST
59112: LIST
59113: LIST
59114: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
59115: LD_ADDR_VAR 0 32
59119: PUSH
59120: LD_INT 1
59122: PUSH
59123: LD_INT 3
59125: PUSH
59126: EMPTY
59127: LIST
59128: LIST
59129: PUSH
59130: LD_INT 0
59132: PUSH
59133: LD_INT 3
59135: PUSH
59136: EMPTY
59137: LIST
59138: LIST
59139: PUSH
59140: LD_INT 1
59142: NEG
59143: PUSH
59144: LD_INT 2
59146: PUSH
59147: EMPTY
59148: LIST
59149: LIST
59150: PUSH
59151: LD_INT 1
59153: PUSH
59154: LD_INT 4
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: PUSH
59161: LD_INT 0
59163: PUSH
59164: LD_INT 4
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: PUSH
59171: LD_INT 1
59173: NEG
59174: PUSH
59175: LD_INT 3
59177: PUSH
59178: EMPTY
59179: LIST
59180: LIST
59181: PUSH
59182: LD_INT 1
59184: PUSH
59185: LD_INT 5
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: PUSH
59192: LD_INT 0
59194: PUSH
59195: LD_INT 5
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: PUSH
59202: LD_INT 1
59204: NEG
59205: PUSH
59206: LD_INT 4
59208: PUSH
59209: EMPTY
59210: LIST
59211: LIST
59212: PUSH
59213: LD_INT 1
59215: PUSH
59216: LD_INT 6
59218: PUSH
59219: EMPTY
59220: LIST
59221: LIST
59222: PUSH
59223: LD_INT 0
59225: PUSH
59226: LD_INT 6
59228: PUSH
59229: EMPTY
59230: LIST
59231: LIST
59232: PUSH
59233: LD_INT 1
59235: NEG
59236: PUSH
59237: LD_INT 5
59239: PUSH
59240: EMPTY
59241: LIST
59242: LIST
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: LIST
59248: LIST
59249: LIST
59250: LIST
59251: LIST
59252: LIST
59253: LIST
59254: LIST
59255: LIST
59256: LIST
59257: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
59258: LD_ADDR_VAR 0 33
59262: PUSH
59263: LD_INT 2
59265: NEG
59266: PUSH
59267: LD_INT 1
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: PUSH
59274: LD_INT 3
59276: NEG
59277: PUSH
59278: LD_INT 0
59280: PUSH
59281: EMPTY
59282: LIST
59283: LIST
59284: PUSH
59285: LD_INT 3
59287: NEG
59288: PUSH
59289: LD_INT 1
59291: NEG
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: PUSH
59297: LD_INT 3
59299: NEG
59300: PUSH
59301: LD_INT 1
59303: PUSH
59304: EMPTY
59305: LIST
59306: LIST
59307: PUSH
59308: LD_INT 4
59310: NEG
59311: PUSH
59312: LD_INT 0
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: PUSH
59319: LD_INT 4
59321: NEG
59322: PUSH
59323: LD_INT 1
59325: NEG
59326: PUSH
59327: EMPTY
59328: LIST
59329: LIST
59330: PUSH
59331: LD_INT 4
59333: NEG
59334: PUSH
59335: LD_INT 1
59337: PUSH
59338: EMPTY
59339: LIST
59340: LIST
59341: PUSH
59342: LD_INT 5
59344: NEG
59345: PUSH
59346: LD_INT 0
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: PUSH
59353: LD_INT 5
59355: NEG
59356: PUSH
59357: LD_INT 1
59359: NEG
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: LD_INT 5
59367: NEG
59368: PUSH
59369: LD_INT 1
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: PUSH
59376: LD_INT 6
59378: NEG
59379: PUSH
59380: LD_INT 0
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PUSH
59387: LD_INT 6
59389: NEG
59390: PUSH
59391: LD_INT 1
59393: NEG
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: LIST
59403: LIST
59404: LIST
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: LIST
59410: LIST
59411: LIST
59412: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
59413: LD_ADDR_VAR 0 34
59417: PUSH
59418: LD_INT 2
59420: NEG
59421: PUSH
59422: LD_INT 3
59424: NEG
59425: PUSH
59426: EMPTY
59427: LIST
59428: LIST
59429: PUSH
59430: LD_INT 3
59432: NEG
59433: PUSH
59434: LD_INT 2
59436: NEG
59437: PUSH
59438: EMPTY
59439: LIST
59440: LIST
59441: PUSH
59442: LD_INT 3
59444: NEG
59445: PUSH
59446: LD_INT 3
59448: NEG
59449: PUSH
59450: EMPTY
59451: LIST
59452: LIST
59453: PUSH
59454: LD_INT 3
59456: NEG
59457: PUSH
59458: LD_INT 4
59460: NEG
59461: PUSH
59462: EMPTY
59463: LIST
59464: LIST
59465: PUSH
59466: LD_INT 4
59468: NEG
59469: PUSH
59470: LD_INT 3
59472: NEG
59473: PUSH
59474: EMPTY
59475: LIST
59476: LIST
59477: PUSH
59478: LD_INT 4
59480: NEG
59481: PUSH
59482: LD_INT 4
59484: NEG
59485: PUSH
59486: EMPTY
59487: LIST
59488: LIST
59489: PUSH
59490: LD_INT 4
59492: NEG
59493: PUSH
59494: LD_INT 5
59496: NEG
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: LD_INT 5
59504: NEG
59505: PUSH
59506: LD_INT 4
59508: NEG
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PUSH
59514: LD_INT 5
59516: NEG
59517: PUSH
59518: LD_INT 5
59520: NEG
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: PUSH
59526: LD_INT 5
59528: NEG
59529: PUSH
59530: LD_INT 6
59532: NEG
59533: PUSH
59534: EMPTY
59535: LIST
59536: LIST
59537: PUSH
59538: LD_INT 6
59540: NEG
59541: PUSH
59542: LD_INT 5
59544: NEG
59545: PUSH
59546: EMPTY
59547: LIST
59548: LIST
59549: PUSH
59550: LD_INT 6
59552: NEG
59553: PUSH
59554: LD_INT 6
59556: NEG
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: LIST
59566: LIST
59567: LIST
59568: LIST
59569: LIST
59570: LIST
59571: LIST
59572: LIST
59573: LIST
59574: LIST
59575: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
59576: LD_ADDR_VAR 0 41
59580: PUSH
59581: LD_INT 0
59583: PUSH
59584: LD_INT 2
59586: NEG
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: PUSH
59592: LD_INT 1
59594: NEG
59595: PUSH
59596: LD_INT 3
59598: NEG
59599: PUSH
59600: EMPTY
59601: LIST
59602: LIST
59603: PUSH
59604: LD_INT 1
59606: PUSH
59607: LD_INT 2
59609: NEG
59610: PUSH
59611: EMPTY
59612: LIST
59613: LIST
59614: PUSH
59615: EMPTY
59616: LIST
59617: LIST
59618: LIST
59619: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
59620: LD_ADDR_VAR 0 42
59624: PUSH
59625: LD_INT 2
59627: PUSH
59628: LD_INT 0
59630: PUSH
59631: EMPTY
59632: LIST
59633: LIST
59634: PUSH
59635: LD_INT 2
59637: PUSH
59638: LD_INT 1
59640: NEG
59641: PUSH
59642: EMPTY
59643: LIST
59644: LIST
59645: PUSH
59646: LD_INT 3
59648: PUSH
59649: LD_INT 1
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: LIST
59660: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
59661: LD_ADDR_VAR 0 43
59665: PUSH
59666: LD_INT 2
59668: PUSH
59669: LD_INT 2
59671: PUSH
59672: EMPTY
59673: LIST
59674: LIST
59675: PUSH
59676: LD_INT 3
59678: PUSH
59679: LD_INT 2
59681: PUSH
59682: EMPTY
59683: LIST
59684: LIST
59685: PUSH
59686: LD_INT 2
59688: PUSH
59689: LD_INT 3
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: LIST
59700: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
59701: LD_ADDR_VAR 0 44
59705: PUSH
59706: LD_INT 0
59708: PUSH
59709: LD_INT 2
59711: PUSH
59712: EMPTY
59713: LIST
59714: LIST
59715: PUSH
59716: LD_INT 1
59718: PUSH
59719: LD_INT 3
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: PUSH
59726: LD_INT 1
59728: NEG
59729: PUSH
59730: LD_INT 2
59732: PUSH
59733: EMPTY
59734: LIST
59735: LIST
59736: PUSH
59737: EMPTY
59738: LIST
59739: LIST
59740: LIST
59741: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
59742: LD_ADDR_VAR 0 45
59746: PUSH
59747: LD_INT 2
59749: NEG
59750: PUSH
59751: LD_INT 0
59753: PUSH
59754: EMPTY
59755: LIST
59756: LIST
59757: PUSH
59758: LD_INT 2
59760: NEG
59761: PUSH
59762: LD_INT 1
59764: PUSH
59765: EMPTY
59766: LIST
59767: LIST
59768: PUSH
59769: LD_INT 3
59771: NEG
59772: PUSH
59773: LD_INT 1
59775: NEG
59776: PUSH
59777: EMPTY
59778: LIST
59779: LIST
59780: PUSH
59781: EMPTY
59782: LIST
59783: LIST
59784: LIST
59785: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
59786: LD_ADDR_VAR 0 46
59790: PUSH
59791: LD_INT 2
59793: NEG
59794: PUSH
59795: LD_INT 2
59797: NEG
59798: PUSH
59799: EMPTY
59800: LIST
59801: LIST
59802: PUSH
59803: LD_INT 2
59805: NEG
59806: PUSH
59807: LD_INT 3
59809: NEG
59810: PUSH
59811: EMPTY
59812: LIST
59813: LIST
59814: PUSH
59815: LD_INT 3
59817: NEG
59818: PUSH
59819: LD_INT 2
59821: NEG
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: LIST
59831: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
59832: LD_ADDR_VAR 0 47
59836: PUSH
59837: LD_INT 2
59839: NEG
59840: PUSH
59841: LD_INT 3
59843: NEG
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: LD_INT 1
59851: NEG
59852: PUSH
59853: LD_INT 3
59855: NEG
59856: PUSH
59857: EMPTY
59858: LIST
59859: LIST
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
59865: LD_ADDR_VAR 0 48
59869: PUSH
59870: LD_INT 1
59872: PUSH
59873: LD_INT 2
59875: NEG
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 2
59883: PUSH
59884: LD_INT 1
59886: NEG
59887: PUSH
59888: EMPTY
59889: LIST
59890: LIST
59891: PUSH
59892: EMPTY
59893: LIST
59894: LIST
59895: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
59896: LD_ADDR_VAR 0 49
59900: PUSH
59901: LD_INT 3
59903: PUSH
59904: LD_INT 1
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: LD_INT 3
59913: PUSH
59914: LD_INT 2
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
59925: LD_ADDR_VAR 0 50
59929: PUSH
59930: LD_INT 2
59932: PUSH
59933: LD_INT 3
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 1
59942: PUSH
59943: LD_INT 3
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
59954: LD_ADDR_VAR 0 51
59958: PUSH
59959: LD_INT 1
59961: NEG
59962: PUSH
59963: LD_INT 2
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: PUSH
59970: LD_INT 2
59972: NEG
59973: PUSH
59974: LD_INT 1
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: PUSH
59981: EMPTY
59982: LIST
59983: LIST
59984: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59985: LD_ADDR_VAR 0 52
59989: PUSH
59990: LD_INT 3
59992: NEG
59993: PUSH
59994: LD_INT 1
59996: NEG
59997: PUSH
59998: EMPTY
59999: LIST
60000: LIST
60001: PUSH
60002: LD_INT 3
60004: NEG
60005: PUSH
60006: LD_INT 2
60008: NEG
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PUSH
60014: EMPTY
60015: LIST
60016: LIST
60017: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
60018: LD_ADDR_VAR 0 53
60022: PUSH
60023: LD_INT 1
60025: NEG
60026: PUSH
60027: LD_INT 3
60029: NEG
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: PUSH
60035: LD_INT 0
60037: PUSH
60038: LD_INT 3
60040: NEG
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: PUSH
60046: LD_INT 1
60048: PUSH
60049: LD_INT 2
60051: NEG
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: PUSH
60057: EMPTY
60058: LIST
60059: LIST
60060: LIST
60061: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
60062: LD_ADDR_VAR 0 54
60066: PUSH
60067: LD_INT 2
60069: PUSH
60070: LD_INT 1
60072: NEG
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: PUSH
60078: LD_INT 3
60080: PUSH
60081: LD_INT 0
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: PUSH
60088: LD_INT 3
60090: PUSH
60091: LD_INT 1
60093: PUSH
60094: EMPTY
60095: LIST
60096: LIST
60097: PUSH
60098: EMPTY
60099: LIST
60100: LIST
60101: LIST
60102: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
60103: LD_ADDR_VAR 0 55
60107: PUSH
60108: LD_INT 3
60110: PUSH
60111: LD_INT 2
60113: PUSH
60114: EMPTY
60115: LIST
60116: LIST
60117: PUSH
60118: LD_INT 3
60120: PUSH
60121: LD_INT 3
60123: PUSH
60124: EMPTY
60125: LIST
60126: LIST
60127: PUSH
60128: LD_INT 2
60130: PUSH
60131: LD_INT 3
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: PUSH
60138: EMPTY
60139: LIST
60140: LIST
60141: LIST
60142: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
60143: LD_ADDR_VAR 0 56
60147: PUSH
60148: LD_INT 1
60150: PUSH
60151: LD_INT 3
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PUSH
60158: LD_INT 0
60160: PUSH
60161: LD_INT 3
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PUSH
60168: LD_INT 1
60170: NEG
60171: PUSH
60172: LD_INT 2
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: PUSH
60179: EMPTY
60180: LIST
60181: LIST
60182: LIST
60183: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
60184: LD_ADDR_VAR 0 57
60188: PUSH
60189: LD_INT 2
60191: NEG
60192: PUSH
60193: LD_INT 1
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: PUSH
60200: LD_INT 3
60202: NEG
60203: PUSH
60204: LD_INT 0
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PUSH
60211: LD_INT 3
60213: NEG
60214: PUSH
60215: LD_INT 1
60217: NEG
60218: PUSH
60219: EMPTY
60220: LIST
60221: LIST
60222: PUSH
60223: EMPTY
60224: LIST
60225: LIST
60226: LIST
60227: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
60228: LD_ADDR_VAR 0 58
60232: PUSH
60233: LD_INT 2
60235: NEG
60236: PUSH
60237: LD_INT 3
60239: NEG
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: LD_INT 3
60247: NEG
60248: PUSH
60249: LD_INT 2
60251: NEG
60252: PUSH
60253: EMPTY
60254: LIST
60255: LIST
60256: PUSH
60257: LD_INT 3
60259: NEG
60260: PUSH
60261: LD_INT 3
60263: NEG
60264: PUSH
60265: EMPTY
60266: LIST
60267: LIST
60268: PUSH
60269: EMPTY
60270: LIST
60271: LIST
60272: LIST
60273: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
60274: LD_ADDR_VAR 0 59
60278: PUSH
60279: LD_INT 1
60281: NEG
60282: PUSH
60283: LD_INT 2
60285: NEG
60286: PUSH
60287: EMPTY
60288: LIST
60289: LIST
60290: PUSH
60291: LD_INT 0
60293: PUSH
60294: LD_INT 2
60296: NEG
60297: PUSH
60298: EMPTY
60299: LIST
60300: LIST
60301: PUSH
60302: LD_INT 1
60304: PUSH
60305: LD_INT 1
60307: NEG
60308: PUSH
60309: EMPTY
60310: LIST
60311: LIST
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: LIST
60317: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
60318: LD_ADDR_VAR 0 60
60322: PUSH
60323: LD_INT 1
60325: PUSH
60326: LD_INT 1
60328: NEG
60329: PUSH
60330: EMPTY
60331: LIST
60332: LIST
60333: PUSH
60334: LD_INT 2
60336: PUSH
60337: LD_INT 0
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: PUSH
60344: LD_INT 2
60346: PUSH
60347: LD_INT 1
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: LIST
60358: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
60359: LD_ADDR_VAR 0 61
60363: PUSH
60364: LD_INT 2
60366: PUSH
60367: LD_INT 1
60369: PUSH
60370: EMPTY
60371: LIST
60372: LIST
60373: PUSH
60374: LD_INT 2
60376: PUSH
60377: LD_INT 2
60379: PUSH
60380: EMPTY
60381: LIST
60382: LIST
60383: PUSH
60384: LD_INT 1
60386: PUSH
60387: LD_INT 2
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PUSH
60394: EMPTY
60395: LIST
60396: LIST
60397: LIST
60398: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
60399: LD_ADDR_VAR 0 62
60403: PUSH
60404: LD_INT 1
60406: PUSH
60407: LD_INT 2
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: PUSH
60414: LD_INT 0
60416: PUSH
60417: LD_INT 2
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PUSH
60424: LD_INT 1
60426: NEG
60427: PUSH
60428: LD_INT 1
60430: PUSH
60431: EMPTY
60432: LIST
60433: LIST
60434: PUSH
60435: EMPTY
60436: LIST
60437: LIST
60438: LIST
60439: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
60440: LD_ADDR_VAR 0 63
60444: PUSH
60445: LD_INT 1
60447: NEG
60448: PUSH
60449: LD_INT 1
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: LD_INT 2
60458: NEG
60459: PUSH
60460: LD_INT 0
60462: PUSH
60463: EMPTY
60464: LIST
60465: LIST
60466: PUSH
60467: LD_INT 2
60469: NEG
60470: PUSH
60471: LD_INT 1
60473: NEG
60474: PUSH
60475: EMPTY
60476: LIST
60477: LIST
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: LIST
60483: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60484: LD_ADDR_VAR 0 64
60488: PUSH
60489: LD_INT 1
60491: NEG
60492: PUSH
60493: LD_INT 2
60495: NEG
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PUSH
60501: LD_INT 2
60503: NEG
60504: PUSH
60505: LD_INT 1
60507: NEG
60508: PUSH
60509: EMPTY
60510: LIST
60511: LIST
60512: PUSH
60513: LD_INT 2
60515: NEG
60516: PUSH
60517: LD_INT 2
60519: NEG
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PUSH
60525: EMPTY
60526: LIST
60527: LIST
60528: LIST
60529: ST_TO_ADDR
// end ; 2 :
60530: GO 63796
60532: LD_INT 2
60534: DOUBLE
60535: EQUAL
60536: IFTRUE 60540
60538: GO 63795
60540: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
60541: LD_ADDR_VAR 0 29
60545: PUSH
60546: LD_INT 4
60548: PUSH
60549: LD_INT 0
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PUSH
60556: LD_INT 4
60558: PUSH
60559: LD_INT 1
60561: NEG
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: PUSH
60567: LD_INT 5
60569: PUSH
60570: LD_INT 0
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: PUSH
60577: LD_INT 5
60579: PUSH
60580: LD_INT 1
60582: PUSH
60583: EMPTY
60584: LIST
60585: LIST
60586: PUSH
60587: LD_INT 4
60589: PUSH
60590: LD_INT 1
60592: PUSH
60593: EMPTY
60594: LIST
60595: LIST
60596: PUSH
60597: LD_INT 3
60599: PUSH
60600: LD_INT 0
60602: PUSH
60603: EMPTY
60604: LIST
60605: LIST
60606: PUSH
60607: LD_INT 3
60609: PUSH
60610: LD_INT 1
60612: NEG
60613: PUSH
60614: EMPTY
60615: LIST
60616: LIST
60617: PUSH
60618: LD_INT 3
60620: PUSH
60621: LD_INT 2
60623: NEG
60624: PUSH
60625: EMPTY
60626: LIST
60627: LIST
60628: PUSH
60629: LD_INT 5
60631: PUSH
60632: LD_INT 2
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PUSH
60639: LD_INT 3
60641: PUSH
60642: LD_INT 3
60644: PUSH
60645: EMPTY
60646: LIST
60647: LIST
60648: PUSH
60649: LD_INT 3
60651: PUSH
60652: LD_INT 2
60654: PUSH
60655: EMPTY
60656: LIST
60657: LIST
60658: PUSH
60659: LD_INT 4
60661: PUSH
60662: LD_INT 3
60664: PUSH
60665: EMPTY
60666: LIST
60667: LIST
60668: PUSH
60669: LD_INT 4
60671: PUSH
60672: LD_INT 4
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PUSH
60679: LD_INT 3
60681: PUSH
60682: LD_INT 4
60684: PUSH
60685: EMPTY
60686: LIST
60687: LIST
60688: PUSH
60689: LD_INT 2
60691: PUSH
60692: LD_INT 3
60694: PUSH
60695: EMPTY
60696: LIST
60697: LIST
60698: PUSH
60699: LD_INT 2
60701: PUSH
60702: LD_INT 2
60704: PUSH
60705: EMPTY
60706: LIST
60707: LIST
60708: PUSH
60709: LD_INT 4
60711: PUSH
60712: LD_INT 2
60714: PUSH
60715: EMPTY
60716: LIST
60717: LIST
60718: PUSH
60719: LD_INT 2
60721: PUSH
60722: LD_INT 4
60724: PUSH
60725: EMPTY
60726: LIST
60727: LIST
60728: PUSH
60729: LD_INT 0
60731: PUSH
60732: LD_INT 4
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: PUSH
60739: LD_INT 0
60741: PUSH
60742: LD_INT 3
60744: PUSH
60745: EMPTY
60746: LIST
60747: LIST
60748: PUSH
60749: LD_INT 1
60751: PUSH
60752: LD_INT 4
60754: PUSH
60755: EMPTY
60756: LIST
60757: LIST
60758: PUSH
60759: LD_INT 1
60761: PUSH
60762: LD_INT 5
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: LD_INT 0
60771: PUSH
60772: LD_INT 5
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: PUSH
60779: LD_INT 1
60781: NEG
60782: PUSH
60783: LD_INT 4
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: PUSH
60790: LD_INT 1
60792: NEG
60793: PUSH
60794: LD_INT 3
60796: PUSH
60797: EMPTY
60798: LIST
60799: LIST
60800: PUSH
60801: LD_INT 2
60803: PUSH
60804: LD_INT 5
60806: PUSH
60807: EMPTY
60808: LIST
60809: LIST
60810: PUSH
60811: LD_INT 2
60813: NEG
60814: PUSH
60815: LD_INT 3
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: LD_INT 3
60824: NEG
60825: PUSH
60826: LD_INT 0
60828: PUSH
60829: EMPTY
60830: LIST
60831: LIST
60832: PUSH
60833: LD_INT 3
60835: NEG
60836: PUSH
60837: LD_INT 1
60839: NEG
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: PUSH
60845: LD_INT 2
60847: NEG
60848: PUSH
60849: LD_INT 0
60851: PUSH
60852: EMPTY
60853: LIST
60854: LIST
60855: PUSH
60856: LD_INT 2
60858: NEG
60859: PUSH
60860: LD_INT 1
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: PUSH
60867: LD_INT 3
60869: NEG
60870: PUSH
60871: LD_INT 1
60873: PUSH
60874: EMPTY
60875: LIST
60876: LIST
60877: PUSH
60878: LD_INT 4
60880: NEG
60881: PUSH
60882: LD_INT 0
60884: PUSH
60885: EMPTY
60886: LIST
60887: LIST
60888: PUSH
60889: LD_INT 4
60891: NEG
60892: PUSH
60893: LD_INT 1
60895: NEG
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 4
60903: NEG
60904: PUSH
60905: LD_INT 2
60907: NEG
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: PUSH
60913: LD_INT 2
60915: NEG
60916: PUSH
60917: LD_INT 2
60919: PUSH
60920: EMPTY
60921: LIST
60922: LIST
60923: PUSH
60924: LD_INT 4
60926: NEG
60927: PUSH
60928: LD_INT 4
60930: NEG
60931: PUSH
60932: EMPTY
60933: LIST
60934: LIST
60935: PUSH
60936: LD_INT 4
60938: NEG
60939: PUSH
60940: LD_INT 5
60942: NEG
60943: PUSH
60944: EMPTY
60945: LIST
60946: LIST
60947: PUSH
60948: LD_INT 3
60950: NEG
60951: PUSH
60952: LD_INT 4
60954: NEG
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: PUSH
60960: LD_INT 3
60962: NEG
60963: PUSH
60964: LD_INT 3
60966: NEG
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 4
60974: NEG
60975: PUSH
60976: LD_INT 3
60978: NEG
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: LD_INT 5
60986: NEG
60987: PUSH
60988: LD_INT 4
60990: NEG
60991: PUSH
60992: EMPTY
60993: LIST
60994: LIST
60995: PUSH
60996: LD_INT 5
60998: NEG
60999: PUSH
61000: LD_INT 5
61002: NEG
61003: PUSH
61004: EMPTY
61005: LIST
61006: LIST
61007: PUSH
61008: LD_INT 3
61010: NEG
61011: PUSH
61012: LD_INT 5
61014: NEG
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: PUSH
61020: LD_INT 5
61022: NEG
61023: PUSH
61024: LD_INT 3
61026: NEG
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PUSH
61032: EMPTY
61033: LIST
61034: LIST
61035: LIST
61036: LIST
61037: LIST
61038: LIST
61039: LIST
61040: LIST
61041: LIST
61042: LIST
61043: LIST
61044: LIST
61045: LIST
61046: LIST
61047: LIST
61048: LIST
61049: LIST
61050: LIST
61051: LIST
61052: LIST
61053: LIST
61054: LIST
61055: LIST
61056: LIST
61057: LIST
61058: LIST
61059: LIST
61060: LIST
61061: LIST
61062: LIST
61063: LIST
61064: LIST
61065: LIST
61066: LIST
61067: LIST
61068: LIST
61069: LIST
61070: LIST
61071: LIST
61072: LIST
61073: LIST
61074: LIST
61075: LIST
61076: LIST
61077: LIST
61078: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
61079: LD_ADDR_VAR 0 30
61083: PUSH
61084: LD_INT 4
61086: PUSH
61087: LD_INT 4
61089: PUSH
61090: EMPTY
61091: LIST
61092: LIST
61093: PUSH
61094: LD_INT 4
61096: PUSH
61097: LD_INT 3
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PUSH
61104: LD_INT 5
61106: PUSH
61107: LD_INT 4
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: PUSH
61114: LD_INT 5
61116: PUSH
61117: LD_INT 5
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: LD_INT 4
61126: PUSH
61127: LD_INT 5
61129: PUSH
61130: EMPTY
61131: LIST
61132: LIST
61133: PUSH
61134: LD_INT 3
61136: PUSH
61137: LD_INT 4
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: PUSH
61144: LD_INT 3
61146: PUSH
61147: LD_INT 3
61149: PUSH
61150: EMPTY
61151: LIST
61152: LIST
61153: PUSH
61154: LD_INT 5
61156: PUSH
61157: LD_INT 3
61159: PUSH
61160: EMPTY
61161: LIST
61162: LIST
61163: PUSH
61164: LD_INT 3
61166: PUSH
61167: LD_INT 5
61169: PUSH
61170: EMPTY
61171: LIST
61172: LIST
61173: PUSH
61174: LD_INT 0
61176: PUSH
61177: LD_INT 3
61179: PUSH
61180: EMPTY
61181: LIST
61182: LIST
61183: PUSH
61184: LD_INT 0
61186: PUSH
61187: LD_INT 2
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PUSH
61194: LD_INT 1
61196: PUSH
61197: LD_INT 3
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: PUSH
61204: LD_INT 1
61206: PUSH
61207: LD_INT 4
61209: PUSH
61210: EMPTY
61211: LIST
61212: LIST
61213: PUSH
61214: LD_INT 0
61216: PUSH
61217: LD_INT 4
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 1
61226: NEG
61227: PUSH
61228: LD_INT 3
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: PUSH
61235: LD_INT 1
61237: NEG
61238: PUSH
61239: LD_INT 2
61241: PUSH
61242: EMPTY
61243: LIST
61244: LIST
61245: PUSH
61246: LD_INT 2
61248: PUSH
61249: LD_INT 4
61251: PUSH
61252: EMPTY
61253: LIST
61254: LIST
61255: PUSH
61256: LD_INT 2
61258: NEG
61259: PUSH
61260: LD_INT 2
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: PUSH
61267: LD_INT 4
61269: NEG
61270: PUSH
61271: LD_INT 0
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: LD_INT 4
61280: NEG
61281: PUSH
61282: LD_INT 1
61284: NEG
61285: PUSH
61286: EMPTY
61287: LIST
61288: LIST
61289: PUSH
61290: LD_INT 3
61292: NEG
61293: PUSH
61294: LD_INT 0
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 3
61303: NEG
61304: PUSH
61305: LD_INT 1
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: PUSH
61312: LD_INT 4
61314: NEG
61315: PUSH
61316: LD_INT 1
61318: PUSH
61319: EMPTY
61320: LIST
61321: LIST
61322: PUSH
61323: LD_INT 5
61325: NEG
61326: PUSH
61327: LD_INT 0
61329: PUSH
61330: EMPTY
61331: LIST
61332: LIST
61333: PUSH
61334: LD_INT 5
61336: NEG
61337: PUSH
61338: LD_INT 1
61340: NEG
61341: PUSH
61342: EMPTY
61343: LIST
61344: LIST
61345: PUSH
61346: LD_INT 5
61348: NEG
61349: PUSH
61350: LD_INT 2
61352: NEG
61353: PUSH
61354: EMPTY
61355: LIST
61356: LIST
61357: PUSH
61358: LD_INT 3
61360: NEG
61361: PUSH
61362: LD_INT 2
61364: PUSH
61365: EMPTY
61366: LIST
61367: LIST
61368: PUSH
61369: LD_INT 3
61371: NEG
61372: PUSH
61373: LD_INT 3
61375: NEG
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: PUSH
61381: LD_INT 3
61383: NEG
61384: PUSH
61385: LD_INT 4
61387: NEG
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: PUSH
61393: LD_INT 2
61395: NEG
61396: PUSH
61397: LD_INT 3
61399: NEG
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PUSH
61405: LD_INT 2
61407: NEG
61408: PUSH
61409: LD_INT 2
61411: NEG
61412: PUSH
61413: EMPTY
61414: LIST
61415: LIST
61416: PUSH
61417: LD_INT 3
61419: NEG
61420: PUSH
61421: LD_INT 2
61423: NEG
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 4
61431: NEG
61432: PUSH
61433: LD_INT 3
61435: NEG
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: PUSH
61441: LD_INT 4
61443: NEG
61444: PUSH
61445: LD_INT 4
61447: NEG
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: LD_INT 2
61455: NEG
61456: PUSH
61457: LD_INT 4
61459: NEG
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: PUSH
61465: LD_INT 4
61467: NEG
61468: PUSH
61469: LD_INT 2
61471: NEG
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PUSH
61477: LD_INT 0
61479: PUSH
61480: LD_INT 4
61482: NEG
61483: PUSH
61484: EMPTY
61485: LIST
61486: LIST
61487: PUSH
61488: LD_INT 0
61490: PUSH
61491: LD_INT 5
61493: NEG
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PUSH
61499: LD_INT 1
61501: PUSH
61502: LD_INT 4
61504: NEG
61505: PUSH
61506: EMPTY
61507: LIST
61508: LIST
61509: PUSH
61510: LD_INT 1
61512: PUSH
61513: LD_INT 3
61515: NEG
61516: PUSH
61517: EMPTY
61518: LIST
61519: LIST
61520: PUSH
61521: LD_INT 0
61523: PUSH
61524: LD_INT 3
61526: NEG
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: PUSH
61532: LD_INT 1
61534: NEG
61535: PUSH
61536: LD_INT 4
61538: NEG
61539: PUSH
61540: EMPTY
61541: LIST
61542: LIST
61543: PUSH
61544: LD_INT 1
61546: NEG
61547: PUSH
61548: LD_INT 5
61550: NEG
61551: PUSH
61552: EMPTY
61553: LIST
61554: LIST
61555: PUSH
61556: LD_INT 2
61558: PUSH
61559: LD_INT 3
61561: NEG
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: PUSH
61567: LD_INT 2
61569: NEG
61570: PUSH
61571: LD_INT 5
61573: NEG
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: LIST
61583: LIST
61584: LIST
61585: LIST
61586: LIST
61587: LIST
61588: LIST
61589: LIST
61590: LIST
61591: LIST
61592: LIST
61593: LIST
61594: LIST
61595: LIST
61596: LIST
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: LIST
61603: LIST
61604: LIST
61605: LIST
61606: LIST
61607: LIST
61608: LIST
61609: LIST
61610: LIST
61611: LIST
61612: LIST
61613: LIST
61614: LIST
61615: LIST
61616: LIST
61617: LIST
61618: LIST
61619: LIST
61620: LIST
61621: LIST
61622: LIST
61623: LIST
61624: LIST
61625: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
61626: LD_ADDR_VAR 0 31
61630: PUSH
61631: LD_INT 0
61633: PUSH
61634: LD_INT 4
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PUSH
61641: LD_INT 0
61643: PUSH
61644: LD_INT 3
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: PUSH
61651: LD_INT 1
61653: PUSH
61654: LD_INT 4
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: PUSH
61661: LD_INT 1
61663: PUSH
61664: LD_INT 5
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 0
61673: PUSH
61674: LD_INT 5
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PUSH
61681: LD_INT 1
61683: NEG
61684: PUSH
61685: LD_INT 4
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PUSH
61692: LD_INT 1
61694: NEG
61695: PUSH
61696: LD_INT 3
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: LD_INT 2
61705: PUSH
61706: LD_INT 5
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: LD_INT 2
61715: NEG
61716: PUSH
61717: LD_INT 3
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: PUSH
61724: LD_INT 3
61726: NEG
61727: PUSH
61728: LD_INT 0
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: PUSH
61735: LD_INT 3
61737: NEG
61738: PUSH
61739: LD_INT 1
61741: NEG
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PUSH
61747: LD_INT 2
61749: NEG
61750: PUSH
61751: LD_INT 0
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PUSH
61758: LD_INT 2
61760: NEG
61761: PUSH
61762: LD_INT 1
61764: PUSH
61765: EMPTY
61766: LIST
61767: LIST
61768: PUSH
61769: LD_INT 3
61771: NEG
61772: PUSH
61773: LD_INT 1
61775: PUSH
61776: EMPTY
61777: LIST
61778: LIST
61779: PUSH
61780: LD_INT 4
61782: NEG
61783: PUSH
61784: LD_INT 0
61786: PUSH
61787: EMPTY
61788: LIST
61789: LIST
61790: PUSH
61791: LD_INT 4
61793: NEG
61794: PUSH
61795: LD_INT 1
61797: NEG
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 4
61805: NEG
61806: PUSH
61807: LD_INT 2
61809: NEG
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: PUSH
61815: LD_INT 2
61817: NEG
61818: PUSH
61819: LD_INT 2
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: LD_INT 4
61828: NEG
61829: PUSH
61830: LD_INT 4
61832: NEG
61833: PUSH
61834: EMPTY
61835: LIST
61836: LIST
61837: PUSH
61838: LD_INT 4
61840: NEG
61841: PUSH
61842: LD_INT 5
61844: NEG
61845: PUSH
61846: EMPTY
61847: LIST
61848: LIST
61849: PUSH
61850: LD_INT 3
61852: NEG
61853: PUSH
61854: LD_INT 4
61856: NEG
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: PUSH
61862: LD_INT 3
61864: NEG
61865: PUSH
61866: LD_INT 3
61868: NEG
61869: PUSH
61870: EMPTY
61871: LIST
61872: LIST
61873: PUSH
61874: LD_INT 4
61876: NEG
61877: PUSH
61878: LD_INT 3
61880: NEG
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: PUSH
61886: LD_INT 5
61888: NEG
61889: PUSH
61890: LD_INT 4
61892: NEG
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: PUSH
61898: LD_INT 5
61900: NEG
61901: PUSH
61902: LD_INT 5
61904: NEG
61905: PUSH
61906: EMPTY
61907: LIST
61908: LIST
61909: PUSH
61910: LD_INT 3
61912: NEG
61913: PUSH
61914: LD_INT 5
61916: NEG
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: PUSH
61922: LD_INT 5
61924: NEG
61925: PUSH
61926: LD_INT 3
61928: NEG
61929: PUSH
61930: EMPTY
61931: LIST
61932: LIST
61933: PUSH
61934: LD_INT 0
61936: PUSH
61937: LD_INT 3
61939: NEG
61940: PUSH
61941: EMPTY
61942: LIST
61943: LIST
61944: PUSH
61945: LD_INT 0
61947: PUSH
61948: LD_INT 4
61950: NEG
61951: PUSH
61952: EMPTY
61953: LIST
61954: LIST
61955: PUSH
61956: LD_INT 1
61958: PUSH
61959: LD_INT 3
61961: NEG
61962: PUSH
61963: EMPTY
61964: LIST
61965: LIST
61966: PUSH
61967: LD_INT 1
61969: PUSH
61970: LD_INT 2
61972: NEG
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PUSH
61978: LD_INT 0
61980: PUSH
61981: LD_INT 2
61983: NEG
61984: PUSH
61985: EMPTY
61986: LIST
61987: LIST
61988: PUSH
61989: LD_INT 1
61991: NEG
61992: PUSH
61993: LD_INT 3
61995: NEG
61996: PUSH
61997: EMPTY
61998: LIST
61999: LIST
62000: PUSH
62001: LD_INT 1
62003: NEG
62004: PUSH
62005: LD_INT 4
62007: NEG
62008: PUSH
62009: EMPTY
62010: LIST
62011: LIST
62012: PUSH
62013: LD_INT 2
62015: PUSH
62016: LD_INT 2
62018: NEG
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: PUSH
62024: LD_INT 2
62026: NEG
62027: PUSH
62028: LD_INT 4
62030: NEG
62031: PUSH
62032: EMPTY
62033: LIST
62034: LIST
62035: PUSH
62036: LD_INT 4
62038: PUSH
62039: LD_INT 0
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: PUSH
62046: LD_INT 4
62048: PUSH
62049: LD_INT 1
62051: NEG
62052: PUSH
62053: EMPTY
62054: LIST
62055: LIST
62056: PUSH
62057: LD_INT 5
62059: PUSH
62060: LD_INT 0
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: PUSH
62067: LD_INT 5
62069: PUSH
62070: LD_INT 1
62072: PUSH
62073: EMPTY
62074: LIST
62075: LIST
62076: PUSH
62077: LD_INT 4
62079: PUSH
62080: LD_INT 1
62082: PUSH
62083: EMPTY
62084: LIST
62085: LIST
62086: PUSH
62087: LD_INT 3
62089: PUSH
62090: LD_INT 0
62092: PUSH
62093: EMPTY
62094: LIST
62095: LIST
62096: PUSH
62097: LD_INT 3
62099: PUSH
62100: LD_INT 1
62102: NEG
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: PUSH
62108: LD_INT 3
62110: PUSH
62111: LD_INT 2
62113: NEG
62114: PUSH
62115: EMPTY
62116: LIST
62117: LIST
62118: PUSH
62119: LD_INT 5
62121: PUSH
62122: LD_INT 2
62124: PUSH
62125: EMPTY
62126: LIST
62127: LIST
62128: PUSH
62129: EMPTY
62130: LIST
62131: LIST
62132: LIST
62133: LIST
62134: LIST
62135: LIST
62136: LIST
62137: LIST
62138: LIST
62139: LIST
62140: LIST
62141: LIST
62142: LIST
62143: LIST
62144: LIST
62145: LIST
62146: LIST
62147: LIST
62148: LIST
62149: LIST
62150: LIST
62151: LIST
62152: LIST
62153: LIST
62154: LIST
62155: LIST
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: LIST
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
62176: LD_ADDR_VAR 0 32
62180: PUSH
62181: LD_INT 4
62183: NEG
62184: PUSH
62185: LD_INT 0
62187: PUSH
62188: EMPTY
62189: LIST
62190: LIST
62191: PUSH
62192: LD_INT 4
62194: NEG
62195: PUSH
62196: LD_INT 1
62198: NEG
62199: PUSH
62200: EMPTY
62201: LIST
62202: LIST
62203: PUSH
62204: LD_INT 3
62206: NEG
62207: PUSH
62208: LD_INT 0
62210: PUSH
62211: EMPTY
62212: LIST
62213: LIST
62214: PUSH
62215: LD_INT 3
62217: NEG
62218: PUSH
62219: LD_INT 1
62221: PUSH
62222: EMPTY
62223: LIST
62224: LIST
62225: PUSH
62226: LD_INT 4
62228: NEG
62229: PUSH
62230: LD_INT 1
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PUSH
62237: LD_INT 5
62239: NEG
62240: PUSH
62241: LD_INT 0
62243: PUSH
62244: EMPTY
62245: LIST
62246: LIST
62247: PUSH
62248: LD_INT 5
62250: NEG
62251: PUSH
62252: LD_INT 1
62254: NEG
62255: PUSH
62256: EMPTY
62257: LIST
62258: LIST
62259: PUSH
62260: LD_INT 5
62262: NEG
62263: PUSH
62264: LD_INT 2
62266: NEG
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: PUSH
62272: LD_INT 3
62274: NEG
62275: PUSH
62276: LD_INT 2
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: LD_INT 3
62285: NEG
62286: PUSH
62287: LD_INT 3
62289: NEG
62290: PUSH
62291: EMPTY
62292: LIST
62293: LIST
62294: PUSH
62295: LD_INT 3
62297: NEG
62298: PUSH
62299: LD_INT 4
62301: NEG
62302: PUSH
62303: EMPTY
62304: LIST
62305: LIST
62306: PUSH
62307: LD_INT 2
62309: NEG
62310: PUSH
62311: LD_INT 3
62313: NEG
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: PUSH
62319: LD_INT 2
62321: NEG
62322: PUSH
62323: LD_INT 2
62325: NEG
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: LD_INT 3
62333: NEG
62334: PUSH
62335: LD_INT 2
62337: NEG
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: PUSH
62343: LD_INT 4
62345: NEG
62346: PUSH
62347: LD_INT 3
62349: NEG
62350: PUSH
62351: EMPTY
62352: LIST
62353: LIST
62354: PUSH
62355: LD_INT 4
62357: NEG
62358: PUSH
62359: LD_INT 4
62361: NEG
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: PUSH
62367: LD_INT 2
62369: NEG
62370: PUSH
62371: LD_INT 4
62373: NEG
62374: PUSH
62375: EMPTY
62376: LIST
62377: LIST
62378: PUSH
62379: LD_INT 4
62381: NEG
62382: PUSH
62383: LD_INT 2
62385: NEG
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: PUSH
62391: LD_INT 0
62393: PUSH
62394: LD_INT 4
62396: NEG
62397: PUSH
62398: EMPTY
62399: LIST
62400: LIST
62401: PUSH
62402: LD_INT 0
62404: PUSH
62405: LD_INT 5
62407: NEG
62408: PUSH
62409: EMPTY
62410: LIST
62411: LIST
62412: PUSH
62413: LD_INT 1
62415: PUSH
62416: LD_INT 4
62418: NEG
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: PUSH
62424: LD_INT 1
62426: PUSH
62427: LD_INT 3
62429: NEG
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: PUSH
62435: LD_INT 0
62437: PUSH
62438: LD_INT 3
62440: NEG
62441: PUSH
62442: EMPTY
62443: LIST
62444: LIST
62445: PUSH
62446: LD_INT 1
62448: NEG
62449: PUSH
62450: LD_INT 4
62452: NEG
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: PUSH
62458: LD_INT 1
62460: NEG
62461: PUSH
62462: LD_INT 5
62464: NEG
62465: PUSH
62466: EMPTY
62467: LIST
62468: LIST
62469: PUSH
62470: LD_INT 2
62472: PUSH
62473: LD_INT 3
62475: NEG
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: PUSH
62481: LD_INT 2
62483: NEG
62484: PUSH
62485: LD_INT 5
62487: NEG
62488: PUSH
62489: EMPTY
62490: LIST
62491: LIST
62492: PUSH
62493: LD_INT 3
62495: PUSH
62496: LD_INT 0
62498: PUSH
62499: EMPTY
62500: LIST
62501: LIST
62502: PUSH
62503: LD_INT 3
62505: PUSH
62506: LD_INT 1
62508: NEG
62509: PUSH
62510: EMPTY
62511: LIST
62512: LIST
62513: PUSH
62514: LD_INT 4
62516: PUSH
62517: LD_INT 0
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PUSH
62524: LD_INT 4
62526: PUSH
62527: LD_INT 1
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: PUSH
62534: LD_INT 3
62536: PUSH
62537: LD_INT 1
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: LD_INT 2
62546: PUSH
62547: LD_INT 0
62549: PUSH
62550: EMPTY
62551: LIST
62552: LIST
62553: PUSH
62554: LD_INT 2
62556: PUSH
62557: LD_INT 1
62559: NEG
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: PUSH
62565: LD_INT 2
62567: PUSH
62568: LD_INT 2
62570: NEG
62571: PUSH
62572: EMPTY
62573: LIST
62574: LIST
62575: PUSH
62576: LD_INT 4
62578: PUSH
62579: LD_INT 2
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: LD_INT 4
62588: PUSH
62589: LD_INT 4
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: PUSH
62596: LD_INT 4
62598: PUSH
62599: LD_INT 3
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PUSH
62606: LD_INT 5
62608: PUSH
62609: LD_INT 4
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: PUSH
62616: LD_INT 5
62618: PUSH
62619: LD_INT 5
62621: PUSH
62622: EMPTY
62623: LIST
62624: LIST
62625: PUSH
62626: LD_INT 4
62628: PUSH
62629: LD_INT 5
62631: PUSH
62632: EMPTY
62633: LIST
62634: LIST
62635: PUSH
62636: LD_INT 3
62638: PUSH
62639: LD_INT 4
62641: PUSH
62642: EMPTY
62643: LIST
62644: LIST
62645: PUSH
62646: LD_INT 3
62648: PUSH
62649: LD_INT 3
62651: PUSH
62652: EMPTY
62653: LIST
62654: LIST
62655: PUSH
62656: LD_INT 5
62658: PUSH
62659: LD_INT 3
62661: PUSH
62662: EMPTY
62663: LIST
62664: LIST
62665: PUSH
62666: LD_INT 3
62668: PUSH
62669: LD_INT 5
62671: PUSH
62672: EMPTY
62673: LIST
62674: LIST
62675: PUSH
62676: EMPTY
62677: LIST
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: LIST
62691: LIST
62692: LIST
62693: LIST
62694: LIST
62695: LIST
62696: LIST
62697: LIST
62698: LIST
62699: LIST
62700: LIST
62701: LIST
62702: LIST
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: LIST
62708: LIST
62709: LIST
62710: LIST
62711: LIST
62712: LIST
62713: LIST
62714: LIST
62715: LIST
62716: LIST
62717: LIST
62718: LIST
62719: LIST
62720: LIST
62721: LIST
62722: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
62723: LD_ADDR_VAR 0 33
62727: PUSH
62728: LD_INT 4
62730: NEG
62731: PUSH
62732: LD_INT 4
62734: NEG
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: PUSH
62740: LD_INT 4
62742: NEG
62743: PUSH
62744: LD_INT 5
62746: NEG
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: PUSH
62752: LD_INT 3
62754: NEG
62755: PUSH
62756: LD_INT 4
62758: NEG
62759: PUSH
62760: EMPTY
62761: LIST
62762: LIST
62763: PUSH
62764: LD_INT 3
62766: NEG
62767: PUSH
62768: LD_INT 3
62770: NEG
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: PUSH
62776: LD_INT 4
62778: NEG
62779: PUSH
62780: LD_INT 3
62782: NEG
62783: PUSH
62784: EMPTY
62785: LIST
62786: LIST
62787: PUSH
62788: LD_INT 5
62790: NEG
62791: PUSH
62792: LD_INT 4
62794: NEG
62795: PUSH
62796: EMPTY
62797: LIST
62798: LIST
62799: PUSH
62800: LD_INT 5
62802: NEG
62803: PUSH
62804: LD_INT 5
62806: NEG
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: PUSH
62812: LD_INT 3
62814: NEG
62815: PUSH
62816: LD_INT 5
62818: NEG
62819: PUSH
62820: EMPTY
62821: LIST
62822: LIST
62823: PUSH
62824: LD_INT 5
62826: NEG
62827: PUSH
62828: LD_INT 3
62830: NEG
62831: PUSH
62832: EMPTY
62833: LIST
62834: LIST
62835: PUSH
62836: LD_INT 0
62838: PUSH
62839: LD_INT 3
62841: NEG
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: PUSH
62847: LD_INT 0
62849: PUSH
62850: LD_INT 4
62852: NEG
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PUSH
62858: LD_INT 1
62860: PUSH
62861: LD_INT 3
62863: NEG
62864: PUSH
62865: EMPTY
62866: LIST
62867: LIST
62868: PUSH
62869: LD_INT 1
62871: PUSH
62872: LD_INT 2
62874: NEG
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 0
62882: PUSH
62883: LD_INT 2
62885: NEG
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 1
62893: NEG
62894: PUSH
62895: LD_INT 3
62897: NEG
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: PUSH
62903: LD_INT 1
62905: NEG
62906: PUSH
62907: LD_INT 4
62909: NEG
62910: PUSH
62911: EMPTY
62912: LIST
62913: LIST
62914: PUSH
62915: LD_INT 2
62917: PUSH
62918: LD_INT 2
62920: NEG
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: PUSH
62926: LD_INT 2
62928: NEG
62929: PUSH
62930: LD_INT 4
62932: NEG
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: PUSH
62938: LD_INT 4
62940: PUSH
62941: LD_INT 0
62943: PUSH
62944: EMPTY
62945: LIST
62946: LIST
62947: PUSH
62948: LD_INT 4
62950: PUSH
62951: LD_INT 1
62953: NEG
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: PUSH
62959: LD_INT 5
62961: PUSH
62962: LD_INT 0
62964: PUSH
62965: EMPTY
62966: LIST
62967: LIST
62968: PUSH
62969: LD_INT 5
62971: PUSH
62972: LD_INT 1
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: PUSH
62979: LD_INT 4
62981: PUSH
62982: LD_INT 1
62984: PUSH
62985: EMPTY
62986: LIST
62987: LIST
62988: PUSH
62989: LD_INT 3
62991: PUSH
62992: LD_INT 0
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: LD_INT 3
63001: PUSH
63002: LD_INT 1
63004: NEG
63005: PUSH
63006: EMPTY
63007: LIST
63008: LIST
63009: PUSH
63010: LD_INT 3
63012: PUSH
63013: LD_INT 2
63015: NEG
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 5
63023: PUSH
63024: LD_INT 2
63026: PUSH
63027: EMPTY
63028: LIST
63029: LIST
63030: PUSH
63031: LD_INT 3
63033: PUSH
63034: LD_INT 3
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PUSH
63041: LD_INT 3
63043: PUSH
63044: LD_INT 2
63046: PUSH
63047: EMPTY
63048: LIST
63049: LIST
63050: PUSH
63051: LD_INT 4
63053: PUSH
63054: LD_INT 3
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: PUSH
63061: LD_INT 4
63063: PUSH
63064: LD_INT 4
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: PUSH
63071: LD_INT 3
63073: PUSH
63074: LD_INT 4
63076: PUSH
63077: EMPTY
63078: LIST
63079: LIST
63080: PUSH
63081: LD_INT 2
63083: PUSH
63084: LD_INT 3
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: LD_INT 2
63093: PUSH
63094: LD_INT 2
63096: PUSH
63097: EMPTY
63098: LIST
63099: LIST
63100: PUSH
63101: LD_INT 4
63103: PUSH
63104: LD_INT 2
63106: PUSH
63107: EMPTY
63108: LIST
63109: LIST
63110: PUSH
63111: LD_INT 2
63113: PUSH
63114: LD_INT 4
63116: PUSH
63117: EMPTY
63118: LIST
63119: LIST
63120: PUSH
63121: LD_INT 0
63123: PUSH
63124: LD_INT 4
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: PUSH
63131: LD_INT 0
63133: PUSH
63134: LD_INT 3
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: PUSH
63141: LD_INT 1
63143: PUSH
63144: LD_INT 4
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 1
63153: PUSH
63154: LD_INT 5
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 0
63163: PUSH
63164: LD_INT 5
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 1
63173: NEG
63174: PUSH
63175: LD_INT 4
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: LD_INT 1
63184: NEG
63185: PUSH
63186: LD_INT 3
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 2
63195: PUSH
63196: LD_INT 5
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 2
63205: NEG
63206: PUSH
63207: LD_INT 3
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PUSH
63214: EMPTY
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: LIST
63238: LIST
63239: LIST
63240: LIST
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: LIST
63246: LIST
63247: LIST
63248: LIST
63249: LIST
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
63261: LD_ADDR_VAR 0 34
63265: PUSH
63266: LD_INT 0
63268: PUSH
63269: LD_INT 4
63271: NEG
63272: PUSH
63273: EMPTY
63274: LIST
63275: LIST
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: LD_INT 5
63282: NEG
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: PUSH
63288: LD_INT 1
63290: PUSH
63291: LD_INT 4
63293: NEG
63294: PUSH
63295: EMPTY
63296: LIST
63297: LIST
63298: PUSH
63299: LD_INT 1
63301: PUSH
63302: LD_INT 3
63304: NEG
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: PUSH
63310: LD_INT 0
63312: PUSH
63313: LD_INT 3
63315: NEG
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: PUSH
63321: LD_INT 1
63323: NEG
63324: PUSH
63325: LD_INT 4
63327: NEG
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: LD_INT 1
63335: NEG
63336: PUSH
63337: LD_INT 5
63339: NEG
63340: PUSH
63341: EMPTY
63342: LIST
63343: LIST
63344: PUSH
63345: LD_INT 2
63347: PUSH
63348: LD_INT 3
63350: NEG
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: LD_INT 2
63358: NEG
63359: PUSH
63360: LD_INT 5
63362: NEG
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: PUSH
63368: LD_INT 3
63370: PUSH
63371: LD_INT 0
63373: PUSH
63374: EMPTY
63375: LIST
63376: LIST
63377: PUSH
63378: LD_INT 3
63380: PUSH
63381: LD_INT 1
63383: NEG
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 4
63391: PUSH
63392: LD_INT 0
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: PUSH
63399: LD_INT 4
63401: PUSH
63402: LD_INT 1
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 3
63411: PUSH
63412: LD_INT 1
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 2
63421: PUSH
63422: LD_INT 0
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: PUSH
63429: LD_INT 2
63431: PUSH
63432: LD_INT 1
63434: NEG
63435: PUSH
63436: EMPTY
63437: LIST
63438: LIST
63439: PUSH
63440: LD_INT 2
63442: PUSH
63443: LD_INT 2
63445: NEG
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: PUSH
63451: LD_INT 4
63453: PUSH
63454: LD_INT 2
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: PUSH
63461: LD_INT 4
63463: PUSH
63464: LD_INT 4
63466: PUSH
63467: EMPTY
63468: LIST
63469: LIST
63470: PUSH
63471: LD_INT 4
63473: PUSH
63474: LD_INT 3
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: LD_INT 5
63483: PUSH
63484: LD_INT 4
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 5
63493: PUSH
63494: LD_INT 5
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 4
63503: PUSH
63504: LD_INT 5
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 3
63513: PUSH
63514: LD_INT 4
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 3
63523: PUSH
63524: LD_INT 3
63526: PUSH
63527: EMPTY
63528: LIST
63529: LIST
63530: PUSH
63531: LD_INT 5
63533: PUSH
63534: LD_INT 3
63536: PUSH
63537: EMPTY
63538: LIST
63539: LIST
63540: PUSH
63541: LD_INT 3
63543: PUSH
63544: LD_INT 5
63546: PUSH
63547: EMPTY
63548: LIST
63549: LIST
63550: PUSH
63551: LD_INT 0
63553: PUSH
63554: LD_INT 3
63556: PUSH
63557: EMPTY
63558: LIST
63559: LIST
63560: PUSH
63561: LD_INT 0
63563: PUSH
63564: LD_INT 2
63566: PUSH
63567: EMPTY
63568: LIST
63569: LIST
63570: PUSH
63571: LD_INT 1
63573: PUSH
63574: LD_INT 3
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: PUSH
63581: LD_INT 1
63583: PUSH
63584: LD_INT 4
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 0
63593: PUSH
63594: LD_INT 4
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PUSH
63601: LD_INT 1
63603: NEG
63604: PUSH
63605: LD_INT 3
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: LD_INT 1
63614: NEG
63615: PUSH
63616: LD_INT 2
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PUSH
63623: LD_INT 2
63625: PUSH
63626: LD_INT 4
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: PUSH
63633: LD_INT 2
63635: NEG
63636: PUSH
63637: LD_INT 2
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: PUSH
63644: LD_INT 4
63646: NEG
63647: PUSH
63648: LD_INT 0
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 4
63657: NEG
63658: PUSH
63659: LD_INT 1
63661: NEG
63662: PUSH
63663: EMPTY
63664: LIST
63665: LIST
63666: PUSH
63667: LD_INT 3
63669: NEG
63670: PUSH
63671: LD_INT 0
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: PUSH
63678: LD_INT 3
63680: NEG
63681: PUSH
63682: LD_INT 1
63684: PUSH
63685: EMPTY
63686: LIST
63687: LIST
63688: PUSH
63689: LD_INT 4
63691: NEG
63692: PUSH
63693: LD_INT 1
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 5
63702: NEG
63703: PUSH
63704: LD_INT 0
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 5
63713: NEG
63714: PUSH
63715: LD_INT 1
63717: NEG
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PUSH
63723: LD_INT 5
63725: NEG
63726: PUSH
63727: LD_INT 2
63729: NEG
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PUSH
63735: LD_INT 3
63737: NEG
63738: PUSH
63739: LD_INT 2
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: LIST
63752: LIST
63753: LIST
63754: LIST
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: LIST
63775: LIST
63776: LIST
63777: LIST
63778: LIST
63779: LIST
63780: LIST
63781: LIST
63782: LIST
63783: LIST
63784: LIST
63785: LIST
63786: LIST
63787: LIST
63788: LIST
63789: LIST
63790: LIST
63791: LIST
63792: ST_TO_ADDR
// end ; end ;
63793: GO 63796
63795: POP
// case btype of b_depot , b_warehouse :
63796: LD_VAR 0 1
63800: PUSH
63801: LD_INT 0
63803: DOUBLE
63804: EQUAL
63805: IFTRUE 63815
63807: LD_INT 1
63809: DOUBLE
63810: EQUAL
63811: IFTRUE 63815
63813: GO 64016
63815: POP
// case nation of nation_american :
63816: LD_VAR 0 5
63820: PUSH
63821: LD_INT 1
63823: DOUBLE
63824: EQUAL
63825: IFTRUE 63829
63827: GO 63885
63829: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
63830: LD_ADDR_VAR 0 9
63834: PUSH
63835: LD_VAR 0 11
63839: PUSH
63840: LD_VAR 0 12
63844: PUSH
63845: LD_VAR 0 13
63849: PUSH
63850: LD_VAR 0 14
63854: PUSH
63855: LD_VAR 0 15
63859: PUSH
63860: LD_VAR 0 16
63864: PUSH
63865: EMPTY
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: PUSH
63873: LD_VAR 0 4
63877: PUSH
63878: LD_INT 1
63880: PLUS
63881: ARRAY
63882: ST_TO_ADDR
63883: GO 64014
63885: LD_INT 2
63887: DOUBLE
63888: EQUAL
63889: IFTRUE 63893
63891: GO 63949
63893: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
63894: LD_ADDR_VAR 0 9
63898: PUSH
63899: LD_VAR 0 17
63903: PUSH
63904: LD_VAR 0 18
63908: PUSH
63909: LD_VAR 0 19
63913: PUSH
63914: LD_VAR 0 20
63918: PUSH
63919: LD_VAR 0 21
63923: PUSH
63924: LD_VAR 0 22
63928: PUSH
63929: EMPTY
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: PUSH
63937: LD_VAR 0 4
63941: PUSH
63942: LD_INT 1
63944: PLUS
63945: ARRAY
63946: ST_TO_ADDR
63947: GO 64014
63949: LD_INT 3
63951: DOUBLE
63952: EQUAL
63953: IFTRUE 63957
63955: GO 64013
63957: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
63958: LD_ADDR_VAR 0 9
63962: PUSH
63963: LD_VAR 0 23
63967: PUSH
63968: LD_VAR 0 24
63972: PUSH
63973: LD_VAR 0 25
63977: PUSH
63978: LD_VAR 0 26
63982: PUSH
63983: LD_VAR 0 27
63987: PUSH
63988: LD_VAR 0 28
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: LIST
63999: LIST
64000: PUSH
64001: LD_VAR 0 4
64005: PUSH
64006: LD_INT 1
64008: PLUS
64009: ARRAY
64010: ST_TO_ADDR
64011: GO 64014
64013: POP
64014: GO 64563
64016: LD_INT 2
64018: DOUBLE
64019: EQUAL
64020: IFTRUE 64030
64022: LD_INT 3
64024: DOUBLE
64025: EQUAL
64026: IFTRUE 64030
64028: GO 64086
64030: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
64031: LD_ADDR_VAR 0 9
64035: PUSH
64036: LD_VAR 0 29
64040: PUSH
64041: LD_VAR 0 30
64045: PUSH
64046: LD_VAR 0 31
64050: PUSH
64051: LD_VAR 0 32
64055: PUSH
64056: LD_VAR 0 33
64060: PUSH
64061: LD_VAR 0 34
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: PUSH
64074: LD_VAR 0 4
64078: PUSH
64079: LD_INT 1
64081: PLUS
64082: ARRAY
64083: ST_TO_ADDR
64084: GO 64563
64086: LD_INT 16
64088: DOUBLE
64089: EQUAL
64090: IFTRUE 64142
64092: LD_INT 17
64094: DOUBLE
64095: EQUAL
64096: IFTRUE 64142
64098: LD_INT 18
64100: DOUBLE
64101: EQUAL
64102: IFTRUE 64142
64104: LD_INT 19
64106: DOUBLE
64107: EQUAL
64108: IFTRUE 64142
64110: LD_INT 20
64112: DOUBLE
64113: EQUAL
64114: IFTRUE 64142
64116: LD_INT 21
64118: DOUBLE
64119: EQUAL
64120: IFTRUE 64142
64122: LD_INT 23
64124: DOUBLE
64125: EQUAL
64126: IFTRUE 64142
64128: LD_INT 24
64130: DOUBLE
64131: EQUAL
64132: IFTRUE 64142
64134: LD_INT 25
64136: DOUBLE
64137: EQUAL
64138: IFTRUE 64142
64140: GO 64198
64142: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
64143: LD_ADDR_VAR 0 9
64147: PUSH
64148: LD_VAR 0 35
64152: PUSH
64153: LD_VAR 0 36
64157: PUSH
64158: LD_VAR 0 37
64162: PUSH
64163: LD_VAR 0 38
64167: PUSH
64168: LD_VAR 0 39
64172: PUSH
64173: LD_VAR 0 40
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: LIST
64182: LIST
64183: LIST
64184: LIST
64185: PUSH
64186: LD_VAR 0 4
64190: PUSH
64191: LD_INT 1
64193: PLUS
64194: ARRAY
64195: ST_TO_ADDR
64196: GO 64563
64198: LD_INT 6
64200: DOUBLE
64201: EQUAL
64202: IFTRUE 64254
64204: LD_INT 7
64206: DOUBLE
64207: EQUAL
64208: IFTRUE 64254
64210: LD_INT 8
64212: DOUBLE
64213: EQUAL
64214: IFTRUE 64254
64216: LD_INT 13
64218: DOUBLE
64219: EQUAL
64220: IFTRUE 64254
64222: LD_INT 12
64224: DOUBLE
64225: EQUAL
64226: IFTRUE 64254
64228: LD_INT 15
64230: DOUBLE
64231: EQUAL
64232: IFTRUE 64254
64234: LD_INT 11
64236: DOUBLE
64237: EQUAL
64238: IFTRUE 64254
64240: LD_INT 14
64242: DOUBLE
64243: EQUAL
64244: IFTRUE 64254
64246: LD_INT 10
64248: DOUBLE
64249: EQUAL
64250: IFTRUE 64254
64252: GO 64310
64254: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
64255: LD_ADDR_VAR 0 9
64259: PUSH
64260: LD_VAR 0 41
64264: PUSH
64265: LD_VAR 0 42
64269: PUSH
64270: LD_VAR 0 43
64274: PUSH
64275: LD_VAR 0 44
64279: PUSH
64280: LD_VAR 0 45
64284: PUSH
64285: LD_VAR 0 46
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: PUSH
64298: LD_VAR 0 4
64302: PUSH
64303: LD_INT 1
64305: PLUS
64306: ARRAY
64307: ST_TO_ADDR
64308: GO 64563
64310: LD_INT 36
64312: DOUBLE
64313: EQUAL
64314: IFTRUE 64318
64316: GO 64374
64318: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
64319: LD_ADDR_VAR 0 9
64323: PUSH
64324: LD_VAR 0 47
64328: PUSH
64329: LD_VAR 0 48
64333: PUSH
64334: LD_VAR 0 49
64338: PUSH
64339: LD_VAR 0 50
64343: PUSH
64344: LD_VAR 0 51
64348: PUSH
64349: LD_VAR 0 52
64353: PUSH
64354: EMPTY
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: LIST
64360: LIST
64361: PUSH
64362: LD_VAR 0 4
64366: PUSH
64367: LD_INT 1
64369: PLUS
64370: ARRAY
64371: ST_TO_ADDR
64372: GO 64563
64374: LD_INT 4
64376: DOUBLE
64377: EQUAL
64378: IFTRUE 64400
64380: LD_INT 5
64382: DOUBLE
64383: EQUAL
64384: IFTRUE 64400
64386: LD_INT 34
64388: DOUBLE
64389: EQUAL
64390: IFTRUE 64400
64392: LD_INT 37
64394: DOUBLE
64395: EQUAL
64396: IFTRUE 64400
64398: GO 64456
64400: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
64401: LD_ADDR_VAR 0 9
64405: PUSH
64406: LD_VAR 0 53
64410: PUSH
64411: LD_VAR 0 54
64415: PUSH
64416: LD_VAR 0 55
64420: PUSH
64421: LD_VAR 0 56
64425: PUSH
64426: LD_VAR 0 57
64430: PUSH
64431: LD_VAR 0 58
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: LIST
64440: LIST
64441: LIST
64442: LIST
64443: PUSH
64444: LD_VAR 0 4
64448: PUSH
64449: LD_INT 1
64451: PLUS
64452: ARRAY
64453: ST_TO_ADDR
64454: GO 64563
64456: LD_INT 31
64458: DOUBLE
64459: EQUAL
64460: IFTRUE 64506
64462: LD_INT 32
64464: DOUBLE
64465: EQUAL
64466: IFTRUE 64506
64468: LD_INT 33
64470: DOUBLE
64471: EQUAL
64472: IFTRUE 64506
64474: LD_INT 27
64476: DOUBLE
64477: EQUAL
64478: IFTRUE 64506
64480: LD_INT 26
64482: DOUBLE
64483: EQUAL
64484: IFTRUE 64506
64486: LD_INT 28
64488: DOUBLE
64489: EQUAL
64490: IFTRUE 64506
64492: LD_INT 29
64494: DOUBLE
64495: EQUAL
64496: IFTRUE 64506
64498: LD_INT 30
64500: DOUBLE
64501: EQUAL
64502: IFTRUE 64506
64504: GO 64562
64506: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
64507: LD_ADDR_VAR 0 9
64511: PUSH
64512: LD_VAR 0 59
64516: PUSH
64517: LD_VAR 0 60
64521: PUSH
64522: LD_VAR 0 61
64526: PUSH
64527: LD_VAR 0 62
64531: PUSH
64532: LD_VAR 0 63
64536: PUSH
64537: LD_VAR 0 64
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: LIST
64549: PUSH
64550: LD_VAR 0 4
64554: PUSH
64555: LD_INT 1
64557: PLUS
64558: ARRAY
64559: ST_TO_ADDR
64560: GO 64563
64562: POP
// temp_list2 = [ ] ;
64563: LD_ADDR_VAR 0 10
64567: PUSH
64568: EMPTY
64569: ST_TO_ADDR
// for i in temp_list do
64570: LD_ADDR_VAR 0 8
64574: PUSH
64575: LD_VAR 0 9
64579: PUSH
64580: FOR_IN
64581: IFFALSE 64633
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
64583: LD_ADDR_VAR 0 10
64587: PUSH
64588: LD_VAR 0 10
64592: PUSH
64593: LD_VAR 0 8
64597: PUSH
64598: LD_INT 1
64600: ARRAY
64601: PUSH
64602: LD_VAR 0 2
64606: PLUS
64607: PUSH
64608: LD_VAR 0 8
64612: PUSH
64613: LD_INT 2
64615: ARRAY
64616: PUSH
64617: LD_VAR 0 3
64621: PLUS
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: EMPTY
64628: LIST
64629: ADD
64630: ST_TO_ADDR
64631: GO 64580
64633: POP
64634: POP
// result = temp_list2 ;
64635: LD_ADDR_VAR 0 7
64639: PUSH
64640: LD_VAR 0 10
64644: ST_TO_ADDR
// end ;
64645: LD_VAR 0 7
64649: RET
// export function EnemyInRange ( unit , dist ) ; begin
64650: LD_INT 0
64652: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
64653: LD_ADDR_VAR 0 3
64657: PUSH
64658: LD_VAR 0 1
64662: PPUSH
64663: CALL_OW 255
64667: PPUSH
64668: LD_VAR 0 1
64672: PPUSH
64673: CALL_OW 250
64677: PPUSH
64678: LD_VAR 0 1
64682: PPUSH
64683: CALL_OW 251
64687: PPUSH
64688: LD_VAR 0 2
64692: PPUSH
64693: CALL 38778 0 4
64697: PUSH
64698: LD_INT 4
64700: ARRAY
64701: ST_TO_ADDR
// end ;
64702: LD_VAR 0 3
64706: RET
// export function PlayerSeeMe ( unit ) ; begin
64707: LD_INT 0
64709: PPUSH
// result := See ( your_side , unit ) ;
64710: LD_ADDR_VAR 0 2
64714: PUSH
64715: LD_OWVAR 2
64719: PPUSH
64720: LD_VAR 0 1
64724: PPUSH
64725: CALL_OW 292
64729: ST_TO_ADDR
// end ;
64730: LD_VAR 0 2
64734: RET
// export function ReverseDir ( unit ) ; begin
64735: LD_INT 0
64737: PPUSH
// if not unit then
64738: LD_VAR 0 1
64742: NOT
64743: IFFALSE 64747
// exit ;
64745: GO 64793
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
64747: LD_ADDR_VAR 0 2
64751: PUSH
64752: LD_INT 3
64754: PUSH
64755: LD_INT 4
64757: PUSH
64758: LD_INT 5
64760: PUSH
64761: LD_INT 0
64763: PUSH
64764: LD_INT 1
64766: PUSH
64767: LD_INT 2
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: PUSH
64778: LD_VAR 0 1
64782: PPUSH
64783: CALL_OW 254
64787: PUSH
64788: LD_INT 1
64790: PLUS
64791: ARRAY
64792: ST_TO_ADDR
// end ;
64793: LD_VAR 0 2
64797: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
64798: LD_INT 0
64800: PPUSH
64801: PPUSH
64802: PPUSH
64803: PPUSH
64804: PPUSH
// if not hexes then
64805: LD_VAR 0 2
64809: NOT
64810: IFFALSE 64814
// exit ;
64812: GO 64962
// dist := 9999 ;
64814: LD_ADDR_VAR 0 5
64818: PUSH
64819: LD_INT 9999
64821: ST_TO_ADDR
// for i = 1 to hexes do
64822: LD_ADDR_VAR 0 4
64826: PUSH
64827: DOUBLE
64828: LD_INT 1
64830: DEC
64831: ST_TO_ADDR
64832: LD_VAR 0 2
64836: PUSH
64837: FOR_TO
64838: IFFALSE 64950
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
64840: LD_VAR 0 1
64844: PPUSH
64845: LD_VAR 0 2
64849: PUSH
64850: LD_VAR 0 4
64854: ARRAY
64855: PUSH
64856: LD_INT 1
64858: ARRAY
64859: PPUSH
64860: LD_VAR 0 2
64864: PUSH
64865: LD_VAR 0 4
64869: ARRAY
64870: PUSH
64871: LD_INT 2
64873: ARRAY
64874: PPUSH
64875: CALL_OW 297
64879: PUSH
64880: LD_VAR 0 5
64884: LESS
64885: IFFALSE 64948
// begin hex := hexes [ i ] ;
64887: LD_ADDR_VAR 0 7
64891: PUSH
64892: LD_VAR 0 2
64896: PUSH
64897: LD_VAR 0 4
64901: ARRAY
64902: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64903: LD_ADDR_VAR 0 5
64907: PUSH
64908: LD_VAR 0 1
64912: PPUSH
64913: LD_VAR 0 2
64917: PUSH
64918: LD_VAR 0 4
64922: ARRAY
64923: PUSH
64924: LD_INT 1
64926: ARRAY
64927: PPUSH
64928: LD_VAR 0 2
64932: PUSH
64933: LD_VAR 0 4
64937: ARRAY
64938: PUSH
64939: LD_INT 2
64941: ARRAY
64942: PPUSH
64943: CALL_OW 297
64947: ST_TO_ADDR
// end ; end ;
64948: GO 64837
64950: POP
64951: POP
// result := hex ;
64952: LD_ADDR_VAR 0 3
64956: PUSH
64957: LD_VAR 0 7
64961: ST_TO_ADDR
// end ;
64962: LD_VAR 0 3
64966: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
64967: LD_INT 0
64969: PPUSH
64970: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
64971: LD_VAR 0 1
64975: NOT
64976: PUSH
64977: LD_VAR 0 1
64981: PUSH
64982: LD_INT 21
64984: PUSH
64985: LD_INT 2
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: LD_INT 23
64994: PUSH
64995: LD_INT 2
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PPUSH
65006: CALL_OW 69
65010: IN
65011: NOT
65012: OR
65013: IFFALSE 65017
// exit ;
65015: GO 65064
// for i = 1 to 3 do
65017: LD_ADDR_VAR 0 3
65021: PUSH
65022: DOUBLE
65023: LD_INT 1
65025: DEC
65026: ST_TO_ADDR
65027: LD_INT 3
65029: PUSH
65030: FOR_TO
65031: IFFALSE 65062
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
65033: LD_VAR 0 1
65037: PPUSH
65038: CALL_OW 250
65042: PPUSH
65043: LD_VAR 0 1
65047: PPUSH
65048: CALL_OW 251
65052: PPUSH
65053: LD_INT 1
65055: PPUSH
65056: CALL_OW 453
65060: GO 65030
65062: POP
65063: POP
// end ;
65064: LD_VAR 0 2
65068: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
65069: LD_INT 0
65071: PPUSH
65072: PPUSH
65073: PPUSH
65074: PPUSH
65075: PPUSH
65076: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
65077: LD_VAR 0 1
65081: NOT
65082: PUSH
65083: LD_VAR 0 2
65087: NOT
65088: OR
65089: PUSH
65090: LD_VAR 0 1
65094: PPUSH
65095: CALL_OW 314
65099: OR
65100: IFFALSE 65104
// exit ;
65102: GO 65545
// x := GetX ( enemy_unit ) ;
65104: LD_ADDR_VAR 0 7
65108: PUSH
65109: LD_VAR 0 2
65113: PPUSH
65114: CALL_OW 250
65118: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
65119: LD_ADDR_VAR 0 8
65123: PUSH
65124: LD_VAR 0 2
65128: PPUSH
65129: CALL_OW 251
65133: ST_TO_ADDR
// if not x or not y then
65134: LD_VAR 0 7
65138: NOT
65139: PUSH
65140: LD_VAR 0 8
65144: NOT
65145: OR
65146: IFFALSE 65150
// exit ;
65148: GO 65545
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
65150: LD_ADDR_VAR 0 6
65154: PUSH
65155: LD_VAR 0 7
65159: PPUSH
65160: LD_INT 0
65162: PPUSH
65163: LD_INT 4
65165: PPUSH
65166: CALL_OW 272
65170: PUSH
65171: LD_VAR 0 8
65175: PPUSH
65176: LD_INT 0
65178: PPUSH
65179: LD_INT 4
65181: PPUSH
65182: CALL_OW 273
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_VAR 0 7
65195: PPUSH
65196: LD_INT 1
65198: PPUSH
65199: LD_INT 4
65201: PPUSH
65202: CALL_OW 272
65206: PUSH
65207: LD_VAR 0 8
65211: PPUSH
65212: LD_INT 1
65214: PPUSH
65215: LD_INT 4
65217: PPUSH
65218: CALL_OW 273
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_VAR 0 7
65231: PPUSH
65232: LD_INT 2
65234: PPUSH
65235: LD_INT 4
65237: PPUSH
65238: CALL_OW 272
65242: PUSH
65243: LD_VAR 0 8
65247: PPUSH
65248: LD_INT 2
65250: PPUSH
65251: LD_INT 4
65253: PPUSH
65254: CALL_OW 273
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PUSH
65263: LD_VAR 0 7
65267: PPUSH
65268: LD_INT 3
65270: PPUSH
65271: LD_INT 4
65273: PPUSH
65274: CALL_OW 272
65278: PUSH
65279: LD_VAR 0 8
65283: PPUSH
65284: LD_INT 3
65286: PPUSH
65287: LD_INT 4
65289: PPUSH
65290: CALL_OW 273
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_VAR 0 7
65303: PPUSH
65304: LD_INT 4
65306: PPUSH
65307: LD_INT 4
65309: PPUSH
65310: CALL_OW 272
65314: PUSH
65315: LD_VAR 0 8
65319: PPUSH
65320: LD_INT 4
65322: PPUSH
65323: LD_INT 4
65325: PPUSH
65326: CALL_OW 273
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: PUSH
65335: LD_VAR 0 7
65339: PPUSH
65340: LD_INT 5
65342: PPUSH
65343: LD_INT 4
65345: PPUSH
65346: CALL_OW 272
65350: PUSH
65351: LD_VAR 0 8
65355: PPUSH
65356: LD_INT 5
65358: PPUSH
65359: LD_INT 4
65361: PPUSH
65362: CALL_OW 273
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: ST_TO_ADDR
// for i = tmp downto 1 do
65379: LD_ADDR_VAR 0 4
65383: PUSH
65384: DOUBLE
65385: LD_VAR 0 6
65389: INC
65390: ST_TO_ADDR
65391: LD_INT 1
65393: PUSH
65394: FOR_DOWNTO
65395: IFFALSE 65496
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
65397: LD_VAR 0 6
65401: PUSH
65402: LD_VAR 0 4
65406: ARRAY
65407: PUSH
65408: LD_INT 1
65410: ARRAY
65411: PPUSH
65412: LD_VAR 0 6
65416: PUSH
65417: LD_VAR 0 4
65421: ARRAY
65422: PUSH
65423: LD_INT 2
65425: ARRAY
65426: PPUSH
65427: CALL_OW 488
65431: NOT
65432: PUSH
65433: LD_VAR 0 6
65437: PUSH
65438: LD_VAR 0 4
65442: ARRAY
65443: PUSH
65444: LD_INT 1
65446: ARRAY
65447: PPUSH
65448: LD_VAR 0 6
65452: PUSH
65453: LD_VAR 0 4
65457: ARRAY
65458: PUSH
65459: LD_INT 2
65461: ARRAY
65462: PPUSH
65463: CALL_OW 428
65467: PUSH
65468: LD_INT 0
65470: NONEQUAL
65471: OR
65472: IFFALSE 65494
// tmp := Delete ( tmp , i ) ;
65474: LD_ADDR_VAR 0 6
65478: PUSH
65479: LD_VAR 0 6
65483: PPUSH
65484: LD_VAR 0 4
65488: PPUSH
65489: CALL_OW 3
65493: ST_TO_ADDR
65494: GO 65394
65496: POP
65497: POP
// j := GetClosestHex ( unit , tmp ) ;
65498: LD_ADDR_VAR 0 5
65502: PUSH
65503: LD_VAR 0 1
65507: PPUSH
65508: LD_VAR 0 6
65512: PPUSH
65513: CALL 64798 0 2
65517: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
65518: LD_VAR 0 1
65522: PPUSH
65523: LD_VAR 0 5
65527: PUSH
65528: LD_INT 1
65530: ARRAY
65531: PPUSH
65532: LD_VAR 0 5
65536: PUSH
65537: LD_INT 2
65539: ARRAY
65540: PPUSH
65541: CALL_OW 111
// end ;
65545: LD_VAR 0 3
65549: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
65550: LD_INT 0
65552: PPUSH
65553: PPUSH
65554: PPUSH
// uc_side = 0 ;
65555: LD_ADDR_OWVAR 20
65559: PUSH
65560: LD_INT 0
65562: ST_TO_ADDR
// uc_nation = 0 ;
65563: LD_ADDR_OWVAR 21
65567: PUSH
65568: LD_INT 0
65570: ST_TO_ADDR
// InitHc ;
65571: CALL_OW 19
// InitVc ;
65575: CALL_OW 20
// if mastodonts then
65579: LD_VAR 0 6
65583: IFFALSE 65650
// for i = 1 to mastodonts do
65585: LD_ADDR_VAR 0 11
65589: PUSH
65590: DOUBLE
65591: LD_INT 1
65593: DEC
65594: ST_TO_ADDR
65595: LD_VAR 0 6
65599: PUSH
65600: FOR_TO
65601: IFFALSE 65648
// begin vc_chassis := 31 ;
65603: LD_ADDR_OWVAR 37
65607: PUSH
65608: LD_INT 31
65610: ST_TO_ADDR
// vc_control := control_rider ;
65611: LD_ADDR_OWVAR 38
65615: PUSH
65616: LD_INT 4
65618: ST_TO_ADDR
// animal := CreateVehicle ;
65619: LD_ADDR_VAR 0 12
65623: PUSH
65624: CALL_OW 45
65628: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65629: LD_VAR 0 12
65633: PPUSH
65634: LD_VAR 0 8
65638: PPUSH
65639: LD_INT 0
65641: PPUSH
65642: CALL 72356 0 3
// end ;
65646: GO 65600
65648: POP
65649: POP
// if horses then
65650: LD_VAR 0 5
65654: IFFALSE 65721
// for i = 1 to horses do
65656: LD_ADDR_VAR 0 11
65660: PUSH
65661: DOUBLE
65662: LD_INT 1
65664: DEC
65665: ST_TO_ADDR
65666: LD_VAR 0 5
65670: PUSH
65671: FOR_TO
65672: IFFALSE 65719
// begin hc_class := 21 ;
65674: LD_ADDR_OWVAR 28
65678: PUSH
65679: LD_INT 21
65681: ST_TO_ADDR
// hc_gallery :=  ;
65682: LD_ADDR_OWVAR 33
65686: PUSH
65687: LD_STRING 
65689: ST_TO_ADDR
// animal := CreateHuman ;
65690: LD_ADDR_VAR 0 12
65694: PUSH
65695: CALL_OW 44
65699: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65700: LD_VAR 0 12
65704: PPUSH
65705: LD_VAR 0 8
65709: PPUSH
65710: LD_INT 0
65712: PPUSH
65713: CALL 72356 0 3
// end ;
65717: GO 65671
65719: POP
65720: POP
// if birds then
65721: LD_VAR 0 1
65725: IFFALSE 65792
// for i = 1 to birds do
65727: LD_ADDR_VAR 0 11
65731: PUSH
65732: DOUBLE
65733: LD_INT 1
65735: DEC
65736: ST_TO_ADDR
65737: LD_VAR 0 1
65741: PUSH
65742: FOR_TO
65743: IFFALSE 65790
// begin hc_class = 18 ;
65745: LD_ADDR_OWVAR 28
65749: PUSH
65750: LD_INT 18
65752: ST_TO_ADDR
// hc_gallery =  ;
65753: LD_ADDR_OWVAR 33
65757: PUSH
65758: LD_STRING 
65760: ST_TO_ADDR
// animal := CreateHuman ;
65761: LD_ADDR_VAR 0 12
65765: PUSH
65766: CALL_OW 44
65770: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65771: LD_VAR 0 12
65775: PPUSH
65776: LD_VAR 0 8
65780: PPUSH
65781: LD_INT 0
65783: PPUSH
65784: CALL 72356 0 3
// end ;
65788: GO 65742
65790: POP
65791: POP
// if tigers then
65792: LD_VAR 0 2
65796: IFFALSE 65880
// for i = 1 to tigers do
65798: LD_ADDR_VAR 0 11
65802: PUSH
65803: DOUBLE
65804: LD_INT 1
65806: DEC
65807: ST_TO_ADDR
65808: LD_VAR 0 2
65812: PUSH
65813: FOR_TO
65814: IFFALSE 65878
// begin hc_class = class_tiger ;
65816: LD_ADDR_OWVAR 28
65820: PUSH
65821: LD_INT 14
65823: ST_TO_ADDR
// hc_gallery =  ;
65824: LD_ADDR_OWVAR 33
65828: PUSH
65829: LD_STRING 
65831: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
65832: LD_ADDR_OWVAR 35
65836: PUSH
65837: LD_INT 7
65839: NEG
65840: PPUSH
65841: LD_INT 7
65843: PPUSH
65844: CALL_OW 12
65848: ST_TO_ADDR
// animal := CreateHuman ;
65849: LD_ADDR_VAR 0 12
65853: PUSH
65854: CALL_OW 44
65858: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65859: LD_VAR 0 12
65863: PPUSH
65864: LD_VAR 0 8
65868: PPUSH
65869: LD_INT 0
65871: PPUSH
65872: CALL 72356 0 3
// end ;
65876: GO 65813
65878: POP
65879: POP
// if apemans then
65880: LD_VAR 0 3
65884: IFFALSE 66007
// for i = 1 to apemans do
65886: LD_ADDR_VAR 0 11
65890: PUSH
65891: DOUBLE
65892: LD_INT 1
65894: DEC
65895: ST_TO_ADDR
65896: LD_VAR 0 3
65900: PUSH
65901: FOR_TO
65902: IFFALSE 66005
// begin hc_class = class_apeman ;
65904: LD_ADDR_OWVAR 28
65908: PUSH
65909: LD_INT 12
65911: ST_TO_ADDR
// hc_gallery =  ;
65912: LD_ADDR_OWVAR 33
65916: PUSH
65917: LD_STRING 
65919: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
65920: LD_ADDR_OWVAR 35
65924: PUSH
65925: LD_INT 5
65927: NEG
65928: PPUSH
65929: LD_INT 5
65931: PPUSH
65932: CALL_OW 12
65936: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
65937: LD_ADDR_OWVAR 31
65941: PUSH
65942: LD_INT 1
65944: PPUSH
65945: LD_INT 3
65947: PPUSH
65948: CALL_OW 12
65952: PUSH
65953: LD_INT 1
65955: PPUSH
65956: LD_INT 3
65958: PPUSH
65959: CALL_OW 12
65963: PUSH
65964: LD_INT 0
65966: PUSH
65967: LD_INT 0
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: ST_TO_ADDR
// animal := CreateHuman ;
65976: LD_ADDR_VAR 0 12
65980: PUSH
65981: CALL_OW 44
65985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
65986: LD_VAR 0 12
65990: PPUSH
65991: LD_VAR 0 8
65995: PPUSH
65996: LD_INT 0
65998: PPUSH
65999: CALL 72356 0 3
// end ;
66003: GO 65901
66005: POP
66006: POP
// if enchidnas then
66007: LD_VAR 0 4
66011: IFFALSE 66078
// for i = 1 to enchidnas do
66013: LD_ADDR_VAR 0 11
66017: PUSH
66018: DOUBLE
66019: LD_INT 1
66021: DEC
66022: ST_TO_ADDR
66023: LD_VAR 0 4
66027: PUSH
66028: FOR_TO
66029: IFFALSE 66076
// begin hc_class = 13 ;
66031: LD_ADDR_OWVAR 28
66035: PUSH
66036: LD_INT 13
66038: ST_TO_ADDR
// hc_gallery =  ;
66039: LD_ADDR_OWVAR 33
66043: PUSH
66044: LD_STRING 
66046: ST_TO_ADDR
// animal := CreateHuman ;
66047: LD_ADDR_VAR 0 12
66051: PUSH
66052: CALL_OW 44
66056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
66057: LD_VAR 0 12
66061: PPUSH
66062: LD_VAR 0 8
66066: PPUSH
66067: LD_INT 0
66069: PPUSH
66070: CALL 72356 0 3
// end ;
66074: GO 66028
66076: POP
66077: POP
// if fishes then
66078: LD_VAR 0 7
66082: IFFALSE 66149
// for i = 1 to fishes do
66084: LD_ADDR_VAR 0 11
66088: PUSH
66089: DOUBLE
66090: LD_INT 1
66092: DEC
66093: ST_TO_ADDR
66094: LD_VAR 0 7
66098: PUSH
66099: FOR_TO
66100: IFFALSE 66147
// begin hc_class = 20 ;
66102: LD_ADDR_OWVAR 28
66106: PUSH
66107: LD_INT 20
66109: ST_TO_ADDR
// hc_gallery =  ;
66110: LD_ADDR_OWVAR 33
66114: PUSH
66115: LD_STRING 
66117: ST_TO_ADDR
// animal := CreateHuman ;
66118: LD_ADDR_VAR 0 12
66122: PUSH
66123: CALL_OW 44
66127: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
66128: LD_VAR 0 12
66132: PPUSH
66133: LD_VAR 0 9
66137: PPUSH
66138: LD_INT 0
66140: PPUSH
66141: CALL 72356 0 3
// end ;
66145: GO 66099
66147: POP
66148: POP
// end ;
66149: LD_VAR 0 10
66153: RET
// export function WantHeal ( sci , unit ) ; begin
66154: LD_INT 0
66156: PPUSH
// if GetTaskList ( sci ) > 0 then
66157: LD_VAR 0 1
66161: PPUSH
66162: CALL_OW 437
66166: PUSH
66167: LD_INT 0
66169: GREATER
66170: IFFALSE 66240
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
66172: LD_VAR 0 1
66176: PPUSH
66177: CALL_OW 437
66181: PUSH
66182: LD_INT 1
66184: ARRAY
66185: PUSH
66186: LD_INT 1
66188: ARRAY
66189: PUSH
66190: LD_STRING l
66192: EQUAL
66193: PUSH
66194: LD_VAR 0 1
66198: PPUSH
66199: CALL_OW 437
66203: PUSH
66204: LD_INT 1
66206: ARRAY
66207: PUSH
66208: LD_INT 4
66210: ARRAY
66211: PUSH
66212: LD_VAR 0 2
66216: EQUAL
66217: AND
66218: IFFALSE 66230
// result := true else
66220: LD_ADDR_VAR 0 3
66224: PUSH
66225: LD_INT 1
66227: ST_TO_ADDR
66228: GO 66238
// result := false ;
66230: LD_ADDR_VAR 0 3
66234: PUSH
66235: LD_INT 0
66237: ST_TO_ADDR
// end else
66238: GO 66248
// result := false ;
66240: LD_ADDR_VAR 0 3
66244: PUSH
66245: LD_INT 0
66247: ST_TO_ADDR
// end ;
66248: LD_VAR 0 3
66252: RET
// export function HealTarget ( sci ) ; begin
66253: LD_INT 0
66255: PPUSH
// if not sci then
66256: LD_VAR 0 1
66260: NOT
66261: IFFALSE 66265
// exit ;
66263: GO 66330
// result := 0 ;
66265: LD_ADDR_VAR 0 2
66269: PUSH
66270: LD_INT 0
66272: ST_TO_ADDR
// if GetTaskList ( sci ) then
66273: LD_VAR 0 1
66277: PPUSH
66278: CALL_OW 437
66282: IFFALSE 66330
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
66284: LD_VAR 0 1
66288: PPUSH
66289: CALL_OW 437
66293: PUSH
66294: LD_INT 1
66296: ARRAY
66297: PUSH
66298: LD_INT 1
66300: ARRAY
66301: PUSH
66302: LD_STRING l
66304: EQUAL
66305: IFFALSE 66330
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
66307: LD_ADDR_VAR 0 2
66311: PUSH
66312: LD_VAR 0 1
66316: PPUSH
66317: CALL_OW 437
66321: PUSH
66322: LD_INT 1
66324: ARRAY
66325: PUSH
66326: LD_INT 4
66328: ARRAY
66329: ST_TO_ADDR
// end ;
66330: LD_VAR 0 2
66334: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
66335: LD_INT 0
66337: PPUSH
66338: PPUSH
66339: PPUSH
66340: PPUSH
66341: PPUSH
66342: PPUSH
66343: PPUSH
66344: PPUSH
66345: PPUSH
66346: PPUSH
66347: PPUSH
66348: PPUSH
66349: PPUSH
66350: PPUSH
66351: PPUSH
66352: PPUSH
66353: PPUSH
66354: PPUSH
66355: PPUSH
66356: PPUSH
66357: PPUSH
66358: PPUSH
66359: PPUSH
66360: PPUSH
66361: PPUSH
66362: PPUSH
66363: PPUSH
66364: PPUSH
66365: PPUSH
66366: PPUSH
66367: PPUSH
66368: PPUSH
66369: PPUSH
// if not list then
66370: LD_VAR 0 1
66374: NOT
66375: IFFALSE 66379
// exit ;
66377: GO 70967
// base := list [ 1 ] ;
66379: LD_ADDR_VAR 0 3
66383: PUSH
66384: LD_VAR 0 1
66388: PUSH
66389: LD_INT 1
66391: ARRAY
66392: ST_TO_ADDR
// group := list [ 2 ] ;
66393: LD_ADDR_VAR 0 4
66397: PUSH
66398: LD_VAR 0 1
66402: PUSH
66403: LD_INT 2
66405: ARRAY
66406: ST_TO_ADDR
// path := list [ 3 ] ;
66407: LD_ADDR_VAR 0 5
66411: PUSH
66412: LD_VAR 0 1
66416: PUSH
66417: LD_INT 3
66419: ARRAY
66420: ST_TO_ADDR
// flags := list [ 4 ] ;
66421: LD_ADDR_VAR 0 6
66425: PUSH
66426: LD_VAR 0 1
66430: PUSH
66431: LD_INT 4
66433: ARRAY
66434: ST_TO_ADDR
// mined := [ ] ;
66435: LD_ADDR_VAR 0 27
66439: PUSH
66440: EMPTY
66441: ST_TO_ADDR
// bombed := [ ] ;
66442: LD_ADDR_VAR 0 28
66446: PUSH
66447: EMPTY
66448: ST_TO_ADDR
// healers := [ ] ;
66449: LD_ADDR_VAR 0 31
66453: PUSH
66454: EMPTY
66455: ST_TO_ADDR
// to_heal := [ ] ;
66456: LD_ADDR_VAR 0 30
66460: PUSH
66461: EMPTY
66462: ST_TO_ADDR
// repairs := [ ] ;
66463: LD_ADDR_VAR 0 33
66467: PUSH
66468: EMPTY
66469: ST_TO_ADDR
// to_repair := [ ] ;
66470: LD_ADDR_VAR 0 32
66474: PUSH
66475: EMPTY
66476: ST_TO_ADDR
// if not group or not path then
66477: LD_VAR 0 4
66481: NOT
66482: PUSH
66483: LD_VAR 0 5
66487: NOT
66488: OR
66489: IFFALSE 66493
// exit ;
66491: GO 70967
// if flags then
66493: LD_VAR 0 6
66497: IFFALSE 66641
// begin f_ignore_area := flags [ 1 ] ;
66499: LD_ADDR_VAR 0 17
66503: PUSH
66504: LD_VAR 0 6
66508: PUSH
66509: LD_INT 1
66511: ARRAY
66512: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
66513: LD_ADDR_VAR 0 18
66517: PUSH
66518: LD_VAR 0 6
66522: PUSH
66523: LD_INT 2
66525: ARRAY
66526: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
66527: LD_ADDR_VAR 0 19
66531: PUSH
66532: LD_VAR 0 6
66536: PUSH
66537: LD_INT 3
66539: ARRAY
66540: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
66541: LD_ADDR_VAR 0 20
66545: PUSH
66546: LD_VAR 0 6
66550: PUSH
66551: LD_INT 4
66553: ARRAY
66554: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
66555: LD_ADDR_VAR 0 21
66559: PUSH
66560: LD_VAR 0 6
66564: PUSH
66565: LD_INT 5
66567: ARRAY
66568: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
66569: LD_ADDR_VAR 0 22
66573: PUSH
66574: LD_VAR 0 6
66578: PUSH
66579: LD_INT 6
66581: ARRAY
66582: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
66583: LD_ADDR_VAR 0 23
66587: PUSH
66588: LD_VAR 0 6
66592: PUSH
66593: LD_INT 7
66595: ARRAY
66596: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
66597: LD_ADDR_VAR 0 24
66601: PUSH
66602: LD_VAR 0 6
66606: PUSH
66607: LD_INT 8
66609: ARRAY
66610: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
66611: LD_ADDR_VAR 0 25
66615: PUSH
66616: LD_VAR 0 6
66620: PUSH
66621: LD_INT 9
66623: ARRAY
66624: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
66625: LD_ADDR_VAR 0 26
66629: PUSH
66630: LD_VAR 0 6
66634: PUSH
66635: LD_INT 10
66637: ARRAY
66638: ST_TO_ADDR
// end else
66639: GO 66721
// begin f_ignore_area := false ;
66641: LD_ADDR_VAR 0 17
66645: PUSH
66646: LD_INT 0
66648: ST_TO_ADDR
// f_capture := false ;
66649: LD_ADDR_VAR 0 18
66653: PUSH
66654: LD_INT 0
66656: ST_TO_ADDR
// f_ignore_civ := false ;
66657: LD_ADDR_VAR 0 19
66661: PUSH
66662: LD_INT 0
66664: ST_TO_ADDR
// f_murder := false ;
66665: LD_ADDR_VAR 0 20
66669: PUSH
66670: LD_INT 0
66672: ST_TO_ADDR
// f_mines := false ;
66673: LD_ADDR_VAR 0 21
66677: PUSH
66678: LD_INT 0
66680: ST_TO_ADDR
// f_repair := false ;
66681: LD_ADDR_VAR 0 22
66685: PUSH
66686: LD_INT 0
66688: ST_TO_ADDR
// f_heal := false ;
66689: LD_ADDR_VAR 0 23
66693: PUSH
66694: LD_INT 0
66696: ST_TO_ADDR
// f_spacetime := false ;
66697: LD_ADDR_VAR 0 24
66701: PUSH
66702: LD_INT 0
66704: ST_TO_ADDR
// f_attack_depot := false ;
66705: LD_ADDR_VAR 0 25
66709: PUSH
66710: LD_INT 0
66712: ST_TO_ADDR
// f_crawl := false ;
66713: LD_ADDR_VAR 0 26
66717: PUSH
66718: LD_INT 0
66720: ST_TO_ADDR
// end ; if f_heal then
66721: LD_VAR 0 23
66725: IFFALSE 66752
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
66727: LD_ADDR_VAR 0 31
66731: PUSH
66732: LD_VAR 0 4
66736: PPUSH
66737: LD_INT 25
66739: PUSH
66740: LD_INT 4
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PPUSH
66747: CALL_OW 72
66751: ST_TO_ADDR
// if f_repair then
66752: LD_VAR 0 22
66756: IFFALSE 66783
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
66758: LD_ADDR_VAR 0 33
66762: PUSH
66763: LD_VAR 0 4
66767: PPUSH
66768: LD_INT 25
66770: PUSH
66771: LD_INT 3
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PPUSH
66778: CALL_OW 72
66782: ST_TO_ADDR
// units_path := [ ] ;
66783: LD_ADDR_VAR 0 16
66787: PUSH
66788: EMPTY
66789: ST_TO_ADDR
// for i = 1 to group do
66790: LD_ADDR_VAR 0 7
66794: PUSH
66795: DOUBLE
66796: LD_INT 1
66798: DEC
66799: ST_TO_ADDR
66800: LD_VAR 0 4
66804: PUSH
66805: FOR_TO
66806: IFFALSE 66835
// units_path := Replace ( units_path , i , path ) ;
66808: LD_ADDR_VAR 0 16
66812: PUSH
66813: LD_VAR 0 16
66817: PPUSH
66818: LD_VAR 0 7
66822: PPUSH
66823: LD_VAR 0 5
66827: PPUSH
66828: CALL_OW 1
66832: ST_TO_ADDR
66833: GO 66805
66835: POP
66836: POP
// repeat for i = group downto 1 do
66837: LD_ADDR_VAR 0 7
66841: PUSH
66842: DOUBLE
66843: LD_VAR 0 4
66847: INC
66848: ST_TO_ADDR
66849: LD_INT 1
66851: PUSH
66852: FOR_DOWNTO
66853: IFFALSE 70949
// begin wait ( 5 ) ;
66855: LD_INT 5
66857: PPUSH
66858: CALL_OW 67
// tmp := [ ] ;
66862: LD_ADDR_VAR 0 14
66866: PUSH
66867: EMPTY
66868: ST_TO_ADDR
// attacking := false ;
66869: LD_ADDR_VAR 0 29
66873: PUSH
66874: LD_INT 0
66876: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
66877: LD_VAR 0 4
66881: PUSH
66882: LD_VAR 0 7
66886: ARRAY
66887: PPUSH
66888: CALL_OW 301
66892: PUSH
66893: LD_VAR 0 4
66897: PUSH
66898: LD_VAR 0 7
66902: ARRAY
66903: NOT
66904: OR
66905: IFFALSE 67014
// begin if GetType ( group [ i ] ) = unit_human then
66907: LD_VAR 0 4
66911: PUSH
66912: LD_VAR 0 7
66916: ARRAY
66917: PPUSH
66918: CALL_OW 247
66922: PUSH
66923: LD_INT 1
66925: EQUAL
66926: IFFALSE 66972
// begin to_heal := to_heal diff group [ i ] ;
66928: LD_ADDR_VAR 0 30
66932: PUSH
66933: LD_VAR 0 30
66937: PUSH
66938: LD_VAR 0 4
66942: PUSH
66943: LD_VAR 0 7
66947: ARRAY
66948: DIFF
66949: ST_TO_ADDR
// healers := healers diff group [ i ] ;
66950: LD_ADDR_VAR 0 31
66954: PUSH
66955: LD_VAR 0 31
66959: PUSH
66960: LD_VAR 0 4
66964: PUSH
66965: LD_VAR 0 7
66969: ARRAY
66970: DIFF
66971: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
66972: LD_ADDR_VAR 0 4
66976: PUSH
66977: LD_VAR 0 4
66981: PPUSH
66982: LD_VAR 0 7
66986: PPUSH
66987: CALL_OW 3
66991: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
66992: LD_ADDR_VAR 0 16
66996: PUSH
66997: LD_VAR 0 16
67001: PPUSH
67002: LD_VAR 0 7
67006: PPUSH
67007: CALL_OW 3
67011: ST_TO_ADDR
// continue ;
67012: GO 66852
// end ; if f_repair then
67014: LD_VAR 0 22
67018: IFFALSE 67507
// begin if GetType ( group [ i ] ) = unit_vehicle then
67020: LD_VAR 0 4
67024: PUSH
67025: LD_VAR 0 7
67029: ARRAY
67030: PPUSH
67031: CALL_OW 247
67035: PUSH
67036: LD_INT 2
67038: EQUAL
67039: IFFALSE 67229
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
67041: LD_VAR 0 4
67045: PUSH
67046: LD_VAR 0 7
67050: ARRAY
67051: PPUSH
67052: CALL_OW 256
67056: PUSH
67057: LD_INT 700
67059: LESS
67060: PUSH
67061: LD_VAR 0 4
67065: PUSH
67066: LD_VAR 0 7
67070: ARRAY
67071: PUSH
67072: LD_VAR 0 32
67076: IN
67077: NOT
67078: AND
67079: IFFALSE 67103
// to_repair := to_repair union group [ i ] ;
67081: LD_ADDR_VAR 0 32
67085: PUSH
67086: LD_VAR 0 32
67090: PUSH
67091: LD_VAR 0 4
67095: PUSH
67096: LD_VAR 0 7
67100: ARRAY
67101: UNION
67102: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
67103: LD_VAR 0 4
67107: PUSH
67108: LD_VAR 0 7
67112: ARRAY
67113: PPUSH
67114: CALL_OW 256
67118: PUSH
67119: LD_INT 1000
67121: EQUAL
67122: PUSH
67123: LD_VAR 0 4
67127: PUSH
67128: LD_VAR 0 7
67132: ARRAY
67133: PUSH
67134: LD_VAR 0 32
67138: IN
67139: AND
67140: IFFALSE 67164
// to_repair := to_repair diff group [ i ] ;
67142: LD_ADDR_VAR 0 32
67146: PUSH
67147: LD_VAR 0 32
67151: PUSH
67152: LD_VAR 0 4
67156: PUSH
67157: LD_VAR 0 7
67161: ARRAY
67162: DIFF
67163: ST_TO_ADDR
// if group [ i ] in to_repair then
67164: LD_VAR 0 4
67168: PUSH
67169: LD_VAR 0 7
67173: ARRAY
67174: PUSH
67175: LD_VAR 0 32
67179: IN
67180: IFFALSE 67227
// begin if not IsInArea ( group [ i ] , f_repair ) then
67182: LD_VAR 0 4
67186: PUSH
67187: LD_VAR 0 7
67191: ARRAY
67192: PPUSH
67193: LD_VAR 0 22
67197: PPUSH
67198: CALL_OW 308
67202: NOT
67203: IFFALSE 67225
// ComMoveToArea ( group [ i ] , f_repair ) ;
67205: LD_VAR 0 4
67209: PUSH
67210: LD_VAR 0 7
67214: ARRAY
67215: PPUSH
67216: LD_VAR 0 22
67220: PPUSH
67221: CALL_OW 113
// continue ;
67225: GO 66852
// end ; end else
67227: GO 67507
// if group [ i ] in repairs then
67229: LD_VAR 0 4
67233: PUSH
67234: LD_VAR 0 7
67238: ARRAY
67239: PUSH
67240: LD_VAR 0 33
67244: IN
67245: IFFALSE 67507
// begin if IsInUnit ( group [ i ] ) then
67247: LD_VAR 0 4
67251: PUSH
67252: LD_VAR 0 7
67256: ARRAY
67257: PPUSH
67258: CALL_OW 310
67262: IFFALSE 67330
// begin z := IsInUnit ( group [ i ] ) ;
67264: LD_ADDR_VAR 0 13
67268: PUSH
67269: LD_VAR 0 4
67273: PUSH
67274: LD_VAR 0 7
67278: ARRAY
67279: PPUSH
67280: CALL_OW 310
67284: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
67285: LD_VAR 0 13
67289: PUSH
67290: LD_VAR 0 32
67294: IN
67295: PUSH
67296: LD_VAR 0 13
67300: PPUSH
67301: LD_VAR 0 22
67305: PPUSH
67306: CALL_OW 308
67310: AND
67311: IFFALSE 67328
// ComExitVehicle ( group [ i ] ) ;
67313: LD_VAR 0 4
67317: PUSH
67318: LD_VAR 0 7
67322: ARRAY
67323: PPUSH
67324: CALL_OW 121
// end else
67328: GO 67507
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
67330: LD_ADDR_VAR 0 13
67334: PUSH
67335: LD_VAR 0 4
67339: PPUSH
67340: LD_INT 95
67342: PUSH
67343: LD_VAR 0 22
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 58
67354: PUSH
67355: EMPTY
67356: LIST
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PPUSH
67362: CALL_OW 72
67366: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
67367: LD_VAR 0 4
67371: PUSH
67372: LD_VAR 0 7
67376: ARRAY
67377: PPUSH
67378: CALL_OW 314
67382: NOT
67383: IFFALSE 67505
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
67385: LD_ADDR_VAR 0 10
67389: PUSH
67390: LD_VAR 0 13
67394: PPUSH
67395: LD_VAR 0 4
67399: PUSH
67400: LD_VAR 0 7
67404: ARRAY
67405: PPUSH
67406: CALL_OW 74
67410: ST_TO_ADDR
// if not x then
67411: LD_VAR 0 10
67415: NOT
67416: IFFALSE 67420
// continue ;
67418: GO 66852
// if GetLives ( x ) < 1000 then
67420: LD_VAR 0 10
67424: PPUSH
67425: CALL_OW 256
67429: PUSH
67430: LD_INT 1000
67432: LESS
67433: IFFALSE 67457
// ComRepairVehicle ( group [ i ] , x ) else
67435: LD_VAR 0 4
67439: PUSH
67440: LD_VAR 0 7
67444: ARRAY
67445: PPUSH
67446: LD_VAR 0 10
67450: PPUSH
67451: CALL_OW 129
67455: GO 67505
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
67457: LD_VAR 0 23
67461: PUSH
67462: LD_VAR 0 4
67466: PUSH
67467: LD_VAR 0 7
67471: ARRAY
67472: PPUSH
67473: CALL_OW 256
67477: PUSH
67478: LD_INT 1000
67480: LESS
67481: AND
67482: NOT
67483: IFFALSE 67505
// ComEnterUnit ( group [ i ] , x ) ;
67485: LD_VAR 0 4
67489: PUSH
67490: LD_VAR 0 7
67494: ARRAY
67495: PPUSH
67496: LD_VAR 0 10
67500: PPUSH
67501: CALL_OW 120
// end ; continue ;
67505: GO 66852
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
67507: LD_VAR 0 23
67511: PUSH
67512: LD_VAR 0 4
67516: PUSH
67517: LD_VAR 0 7
67521: ARRAY
67522: PPUSH
67523: CALL_OW 247
67527: PUSH
67528: LD_INT 1
67530: EQUAL
67531: AND
67532: IFFALSE 68010
// begin if group [ i ] in healers then
67534: LD_VAR 0 4
67538: PUSH
67539: LD_VAR 0 7
67543: ARRAY
67544: PUSH
67545: LD_VAR 0 31
67549: IN
67550: IFFALSE 67823
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
67552: LD_VAR 0 4
67556: PUSH
67557: LD_VAR 0 7
67561: ARRAY
67562: PPUSH
67563: LD_VAR 0 23
67567: PPUSH
67568: CALL_OW 308
67572: NOT
67573: PUSH
67574: LD_VAR 0 4
67578: PUSH
67579: LD_VAR 0 7
67583: ARRAY
67584: PPUSH
67585: CALL_OW 314
67589: NOT
67590: AND
67591: IFFALSE 67615
// ComMoveToArea ( group [ i ] , f_heal ) else
67593: LD_VAR 0 4
67597: PUSH
67598: LD_VAR 0 7
67602: ARRAY
67603: PPUSH
67604: LD_VAR 0 23
67608: PPUSH
67609: CALL_OW 113
67613: GO 67821
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
67615: LD_VAR 0 4
67619: PUSH
67620: LD_VAR 0 7
67624: ARRAY
67625: PPUSH
67626: CALL 66253 0 1
67630: PPUSH
67631: CALL_OW 256
67635: PUSH
67636: LD_INT 1000
67638: EQUAL
67639: IFFALSE 67658
// ComStop ( group [ i ] ) else
67641: LD_VAR 0 4
67645: PUSH
67646: LD_VAR 0 7
67650: ARRAY
67651: PPUSH
67652: CALL_OW 141
67656: GO 67821
// if not HasTask ( group [ i ] ) and to_heal then
67658: LD_VAR 0 4
67662: PUSH
67663: LD_VAR 0 7
67667: ARRAY
67668: PPUSH
67669: CALL_OW 314
67673: NOT
67674: PUSH
67675: LD_VAR 0 30
67679: AND
67680: IFFALSE 67821
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
67682: LD_ADDR_VAR 0 13
67686: PUSH
67687: LD_VAR 0 30
67691: PPUSH
67692: LD_INT 3
67694: PUSH
67695: LD_INT 54
67697: PUSH
67698: EMPTY
67699: LIST
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PPUSH
67705: CALL_OW 72
67709: PPUSH
67710: LD_VAR 0 4
67714: PUSH
67715: LD_VAR 0 7
67719: ARRAY
67720: PPUSH
67721: CALL_OW 74
67725: ST_TO_ADDR
// if z then
67726: LD_VAR 0 13
67730: IFFALSE 67821
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
67732: LD_INT 91
67734: PUSH
67735: LD_VAR 0 13
67739: PUSH
67740: LD_INT 10
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 81
67750: PUSH
67751: LD_VAR 0 13
67755: PPUSH
67756: CALL_OW 255
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PPUSH
67769: CALL_OW 69
67773: PUSH
67774: LD_INT 0
67776: EQUAL
67777: IFFALSE 67801
// ComHeal ( group [ i ] , z ) else
67779: LD_VAR 0 4
67783: PUSH
67784: LD_VAR 0 7
67788: ARRAY
67789: PPUSH
67790: LD_VAR 0 13
67794: PPUSH
67795: CALL_OW 128
67799: GO 67821
// ComMoveToArea ( group [ i ] , f_heal ) ;
67801: LD_VAR 0 4
67805: PUSH
67806: LD_VAR 0 7
67810: ARRAY
67811: PPUSH
67812: LD_VAR 0 23
67816: PPUSH
67817: CALL_OW 113
// end ; continue ;
67821: GO 66852
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
67823: LD_VAR 0 4
67827: PUSH
67828: LD_VAR 0 7
67832: ARRAY
67833: PPUSH
67834: CALL_OW 256
67838: PUSH
67839: LD_INT 700
67841: LESS
67842: PUSH
67843: LD_VAR 0 4
67847: PUSH
67848: LD_VAR 0 7
67852: ARRAY
67853: PUSH
67854: LD_VAR 0 30
67858: IN
67859: NOT
67860: AND
67861: IFFALSE 67885
// to_heal := to_heal union group [ i ] ;
67863: LD_ADDR_VAR 0 30
67867: PUSH
67868: LD_VAR 0 30
67872: PUSH
67873: LD_VAR 0 4
67877: PUSH
67878: LD_VAR 0 7
67882: ARRAY
67883: UNION
67884: ST_TO_ADDR
// if group [ i ] in to_heal then
67885: LD_VAR 0 4
67889: PUSH
67890: LD_VAR 0 7
67894: ARRAY
67895: PUSH
67896: LD_VAR 0 30
67900: IN
67901: IFFALSE 68010
// begin if GetLives ( group [ i ] ) = 1000 then
67903: LD_VAR 0 4
67907: PUSH
67908: LD_VAR 0 7
67912: ARRAY
67913: PPUSH
67914: CALL_OW 256
67918: PUSH
67919: LD_INT 1000
67921: EQUAL
67922: IFFALSE 67948
// to_heal := to_heal diff group [ i ] else
67924: LD_ADDR_VAR 0 30
67928: PUSH
67929: LD_VAR 0 30
67933: PUSH
67934: LD_VAR 0 4
67938: PUSH
67939: LD_VAR 0 7
67943: ARRAY
67944: DIFF
67945: ST_TO_ADDR
67946: GO 68010
// begin if not IsInArea ( group [ i ] , to_heal ) then
67948: LD_VAR 0 4
67952: PUSH
67953: LD_VAR 0 7
67957: ARRAY
67958: PPUSH
67959: LD_VAR 0 30
67963: PPUSH
67964: CALL_OW 308
67968: NOT
67969: IFFALSE 67993
// ComMoveToArea ( group [ i ] , f_heal ) else
67971: LD_VAR 0 4
67975: PUSH
67976: LD_VAR 0 7
67980: ARRAY
67981: PPUSH
67982: LD_VAR 0 23
67986: PPUSH
67987: CALL_OW 113
67991: GO 68008
// ComHold ( group [ i ] ) ;
67993: LD_VAR 0 4
67997: PUSH
67998: LD_VAR 0 7
68002: ARRAY
68003: PPUSH
68004: CALL_OW 140
// continue ;
68008: GO 66852
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
68010: LD_VAR 0 4
68014: PUSH
68015: LD_VAR 0 7
68019: ARRAY
68020: PPUSH
68021: LD_INT 10
68023: PPUSH
68024: CALL 64650 0 2
68028: NOT
68029: PUSH
68030: LD_VAR 0 16
68034: PUSH
68035: LD_VAR 0 7
68039: ARRAY
68040: PUSH
68041: EMPTY
68042: EQUAL
68043: NOT
68044: AND
68045: IFFALSE 68311
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
68047: LD_VAR 0 4
68051: PUSH
68052: LD_VAR 0 7
68056: ARRAY
68057: PPUSH
68058: CALL_OW 262
68062: PUSH
68063: LD_INT 1
68065: PUSH
68066: LD_INT 2
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: IN
68073: IFFALSE 68114
// if GetFuel ( group [ i ] ) < 10 then
68075: LD_VAR 0 4
68079: PUSH
68080: LD_VAR 0 7
68084: ARRAY
68085: PPUSH
68086: CALL_OW 261
68090: PUSH
68091: LD_INT 10
68093: LESS
68094: IFFALSE 68114
// SetFuel ( group [ i ] , 12 ) ;
68096: LD_VAR 0 4
68100: PUSH
68101: LD_VAR 0 7
68105: ARRAY
68106: PPUSH
68107: LD_INT 12
68109: PPUSH
68110: CALL_OW 240
// if units_path [ i ] then
68114: LD_VAR 0 16
68118: PUSH
68119: LD_VAR 0 7
68123: ARRAY
68124: IFFALSE 68309
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
68126: LD_VAR 0 4
68130: PUSH
68131: LD_VAR 0 7
68135: ARRAY
68136: PPUSH
68137: LD_VAR 0 16
68141: PUSH
68142: LD_VAR 0 7
68146: ARRAY
68147: PUSH
68148: LD_INT 1
68150: ARRAY
68151: PUSH
68152: LD_INT 1
68154: ARRAY
68155: PPUSH
68156: LD_VAR 0 16
68160: PUSH
68161: LD_VAR 0 7
68165: ARRAY
68166: PUSH
68167: LD_INT 1
68169: ARRAY
68170: PUSH
68171: LD_INT 2
68173: ARRAY
68174: PPUSH
68175: CALL_OW 297
68179: PUSH
68180: LD_INT 6
68182: GREATER
68183: IFFALSE 68258
// begin if not HasTask ( group [ i ] ) then
68185: LD_VAR 0 4
68189: PUSH
68190: LD_VAR 0 7
68194: ARRAY
68195: PPUSH
68196: CALL_OW 314
68200: NOT
68201: IFFALSE 68256
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
68203: LD_VAR 0 4
68207: PUSH
68208: LD_VAR 0 7
68212: ARRAY
68213: PPUSH
68214: LD_VAR 0 16
68218: PUSH
68219: LD_VAR 0 7
68223: ARRAY
68224: PUSH
68225: LD_INT 1
68227: ARRAY
68228: PUSH
68229: LD_INT 1
68231: ARRAY
68232: PPUSH
68233: LD_VAR 0 16
68237: PUSH
68238: LD_VAR 0 7
68242: ARRAY
68243: PUSH
68244: LD_INT 1
68246: ARRAY
68247: PUSH
68248: LD_INT 2
68250: ARRAY
68251: PPUSH
68252: CALL_OW 114
// end else
68256: GO 68309
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
68258: LD_ADDR_VAR 0 15
68262: PUSH
68263: LD_VAR 0 16
68267: PUSH
68268: LD_VAR 0 7
68272: ARRAY
68273: PPUSH
68274: LD_INT 1
68276: PPUSH
68277: CALL_OW 3
68281: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
68282: LD_ADDR_VAR 0 16
68286: PUSH
68287: LD_VAR 0 16
68291: PPUSH
68292: LD_VAR 0 7
68296: PPUSH
68297: LD_VAR 0 15
68301: PPUSH
68302: CALL_OW 1
68306: ST_TO_ADDR
// continue ;
68307: GO 66852
// end ; end ; end else
68309: GO 70947
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
68311: LD_ADDR_VAR 0 14
68315: PUSH
68316: LD_INT 81
68318: PUSH
68319: LD_VAR 0 4
68323: PUSH
68324: LD_VAR 0 7
68328: ARRAY
68329: PPUSH
68330: CALL_OW 255
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PPUSH
68339: CALL_OW 69
68343: ST_TO_ADDR
// if not tmp then
68344: LD_VAR 0 14
68348: NOT
68349: IFFALSE 68353
// continue ;
68351: GO 66852
// if f_ignore_area then
68353: LD_VAR 0 17
68357: IFFALSE 68445
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
68359: LD_ADDR_VAR 0 15
68363: PUSH
68364: LD_VAR 0 14
68368: PPUSH
68369: LD_INT 3
68371: PUSH
68372: LD_INT 92
68374: PUSH
68375: LD_VAR 0 17
68379: PUSH
68380: LD_INT 1
68382: ARRAY
68383: PUSH
68384: LD_VAR 0 17
68388: PUSH
68389: LD_INT 2
68391: ARRAY
68392: PUSH
68393: LD_VAR 0 17
68397: PUSH
68398: LD_INT 3
68400: ARRAY
68401: PUSH
68402: EMPTY
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PPUSH
68412: CALL_OW 72
68416: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
68417: LD_VAR 0 14
68421: PUSH
68422: LD_VAR 0 15
68426: DIFF
68427: IFFALSE 68445
// tmp := tmp diff tmp2 ;
68429: LD_ADDR_VAR 0 14
68433: PUSH
68434: LD_VAR 0 14
68438: PUSH
68439: LD_VAR 0 15
68443: DIFF
68444: ST_TO_ADDR
// end ; if not f_murder then
68445: LD_VAR 0 20
68449: NOT
68450: IFFALSE 68508
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
68452: LD_ADDR_VAR 0 15
68456: PUSH
68457: LD_VAR 0 14
68461: PPUSH
68462: LD_INT 3
68464: PUSH
68465: LD_INT 50
68467: PUSH
68468: EMPTY
68469: LIST
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PPUSH
68475: CALL_OW 72
68479: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
68480: LD_VAR 0 14
68484: PUSH
68485: LD_VAR 0 15
68489: DIFF
68490: IFFALSE 68508
// tmp := tmp diff tmp2 ;
68492: LD_ADDR_VAR 0 14
68496: PUSH
68497: LD_VAR 0 14
68501: PUSH
68502: LD_VAR 0 15
68506: DIFF
68507: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
68508: LD_ADDR_VAR 0 14
68512: PUSH
68513: LD_VAR 0 4
68517: PUSH
68518: LD_VAR 0 7
68522: ARRAY
68523: PPUSH
68524: LD_VAR 0 14
68528: PPUSH
68529: LD_INT 1
68531: PPUSH
68532: LD_INT 1
68534: PPUSH
68535: CALL 38317 0 4
68539: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
68540: LD_VAR 0 4
68544: PUSH
68545: LD_VAR 0 7
68549: ARRAY
68550: PPUSH
68551: CALL_OW 257
68555: PUSH
68556: LD_INT 1
68558: EQUAL
68559: IFFALSE 69007
// begin if WantPlant ( group [ i ] ) then
68561: LD_VAR 0 4
68565: PUSH
68566: LD_VAR 0 7
68570: ARRAY
68571: PPUSH
68572: CALL 37818 0 1
68576: IFFALSE 68580
// continue ;
68578: GO 66852
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
68580: LD_VAR 0 18
68584: PUSH
68585: LD_VAR 0 4
68589: PUSH
68590: LD_VAR 0 7
68594: ARRAY
68595: PPUSH
68596: CALL_OW 310
68600: NOT
68601: AND
68602: PUSH
68603: LD_VAR 0 14
68607: PUSH
68608: LD_INT 1
68610: ARRAY
68611: PUSH
68612: LD_VAR 0 14
68616: PPUSH
68617: LD_INT 21
68619: PUSH
68620: LD_INT 2
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 58
68629: PUSH
68630: EMPTY
68631: LIST
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PPUSH
68637: CALL_OW 72
68641: IN
68642: AND
68643: IFFALSE 68679
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
68645: LD_VAR 0 4
68649: PUSH
68650: LD_VAR 0 7
68654: ARRAY
68655: PPUSH
68656: LD_VAR 0 14
68660: PUSH
68661: LD_INT 1
68663: ARRAY
68664: PPUSH
68665: CALL_OW 120
// attacking := true ;
68669: LD_ADDR_VAR 0 29
68673: PUSH
68674: LD_INT 1
68676: ST_TO_ADDR
// continue ;
68677: GO 66852
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
68679: LD_VAR 0 26
68683: PUSH
68684: LD_VAR 0 4
68688: PUSH
68689: LD_VAR 0 7
68693: ARRAY
68694: PPUSH
68695: CALL_OW 257
68699: PUSH
68700: LD_INT 1
68702: EQUAL
68703: AND
68704: PUSH
68705: LD_VAR 0 4
68709: PUSH
68710: LD_VAR 0 7
68714: ARRAY
68715: PPUSH
68716: CALL_OW 256
68720: PUSH
68721: LD_INT 800
68723: LESS
68724: AND
68725: PUSH
68726: LD_VAR 0 4
68730: PUSH
68731: LD_VAR 0 7
68735: ARRAY
68736: PPUSH
68737: CALL_OW 318
68741: NOT
68742: AND
68743: IFFALSE 68760
// ComCrawl ( group [ i ] ) ;
68745: LD_VAR 0 4
68749: PUSH
68750: LD_VAR 0 7
68754: ARRAY
68755: PPUSH
68756: CALL_OW 137
// if f_mines then
68760: LD_VAR 0 21
68764: IFFALSE 69007
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
68766: LD_VAR 0 14
68770: PUSH
68771: LD_INT 1
68773: ARRAY
68774: PPUSH
68775: CALL_OW 247
68779: PUSH
68780: LD_INT 3
68782: EQUAL
68783: PUSH
68784: LD_VAR 0 14
68788: PUSH
68789: LD_INT 1
68791: ARRAY
68792: PUSH
68793: LD_VAR 0 27
68797: IN
68798: NOT
68799: AND
68800: IFFALSE 69007
// begin x := GetX ( tmp [ 1 ] ) ;
68802: LD_ADDR_VAR 0 10
68806: PUSH
68807: LD_VAR 0 14
68811: PUSH
68812: LD_INT 1
68814: ARRAY
68815: PPUSH
68816: CALL_OW 250
68820: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
68821: LD_ADDR_VAR 0 11
68825: PUSH
68826: LD_VAR 0 14
68830: PUSH
68831: LD_INT 1
68833: ARRAY
68834: PPUSH
68835: CALL_OW 251
68839: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
68840: LD_ADDR_VAR 0 12
68844: PUSH
68845: LD_VAR 0 4
68849: PUSH
68850: LD_VAR 0 7
68854: ARRAY
68855: PPUSH
68856: CALL 64735 0 1
68860: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
68861: LD_VAR 0 4
68865: PUSH
68866: LD_VAR 0 7
68870: ARRAY
68871: PPUSH
68872: LD_VAR 0 10
68876: PPUSH
68877: LD_VAR 0 11
68881: PPUSH
68882: LD_VAR 0 14
68886: PUSH
68887: LD_INT 1
68889: ARRAY
68890: PPUSH
68891: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
68895: LD_VAR 0 4
68899: PUSH
68900: LD_VAR 0 7
68904: ARRAY
68905: PPUSH
68906: LD_VAR 0 10
68910: PPUSH
68911: LD_VAR 0 12
68915: PPUSH
68916: LD_INT 7
68918: PPUSH
68919: CALL_OW 272
68923: PPUSH
68924: LD_VAR 0 11
68928: PPUSH
68929: LD_VAR 0 12
68933: PPUSH
68934: LD_INT 7
68936: PPUSH
68937: CALL_OW 273
68941: PPUSH
68942: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
68946: LD_VAR 0 4
68950: PUSH
68951: LD_VAR 0 7
68955: ARRAY
68956: PPUSH
68957: LD_INT 71
68959: PPUSH
68960: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
68964: LD_ADDR_VAR 0 27
68968: PUSH
68969: LD_VAR 0 27
68973: PPUSH
68974: LD_VAR 0 27
68978: PUSH
68979: LD_INT 1
68981: PLUS
68982: PPUSH
68983: LD_VAR 0 14
68987: PUSH
68988: LD_INT 1
68990: ARRAY
68991: PPUSH
68992: CALL_OW 1
68996: ST_TO_ADDR
// attacking := true ;
68997: LD_ADDR_VAR 0 29
69001: PUSH
69002: LD_INT 1
69004: ST_TO_ADDR
// continue ;
69005: GO 66852
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
69007: LD_VAR 0 4
69011: PUSH
69012: LD_VAR 0 7
69016: ARRAY
69017: PPUSH
69018: CALL_OW 257
69022: PUSH
69023: LD_INT 17
69025: EQUAL
69026: PUSH
69027: LD_VAR 0 4
69031: PUSH
69032: LD_VAR 0 7
69036: ARRAY
69037: PPUSH
69038: CALL_OW 110
69042: PUSH
69043: LD_INT 71
69045: EQUAL
69046: NOT
69047: AND
69048: IFFALSE 69194
// begin attacking := false ;
69050: LD_ADDR_VAR 0 29
69054: PUSH
69055: LD_INT 0
69057: ST_TO_ADDR
// k := 5 ;
69058: LD_ADDR_VAR 0 9
69062: PUSH
69063: LD_INT 5
69065: ST_TO_ADDR
// if tmp < k then
69066: LD_VAR 0 14
69070: PUSH
69071: LD_VAR 0 9
69075: LESS
69076: IFFALSE 69088
// k := tmp ;
69078: LD_ADDR_VAR 0 9
69082: PUSH
69083: LD_VAR 0 14
69087: ST_TO_ADDR
// for j = 1 to k do
69088: LD_ADDR_VAR 0 8
69092: PUSH
69093: DOUBLE
69094: LD_INT 1
69096: DEC
69097: ST_TO_ADDR
69098: LD_VAR 0 9
69102: PUSH
69103: FOR_TO
69104: IFFALSE 69192
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
69106: LD_VAR 0 14
69110: PUSH
69111: LD_VAR 0 8
69115: ARRAY
69116: PUSH
69117: LD_VAR 0 14
69121: PPUSH
69122: LD_INT 58
69124: PUSH
69125: EMPTY
69126: LIST
69127: PPUSH
69128: CALL_OW 72
69132: IN
69133: NOT
69134: IFFALSE 69190
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
69136: LD_VAR 0 4
69140: PUSH
69141: LD_VAR 0 7
69145: ARRAY
69146: PPUSH
69147: LD_VAR 0 14
69151: PUSH
69152: LD_VAR 0 8
69156: ARRAY
69157: PPUSH
69158: CALL_OW 115
// attacking := true ;
69162: LD_ADDR_VAR 0 29
69166: PUSH
69167: LD_INT 1
69169: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
69170: LD_VAR 0 4
69174: PUSH
69175: LD_VAR 0 7
69179: ARRAY
69180: PPUSH
69181: LD_INT 71
69183: PPUSH
69184: CALL_OW 109
// continue ;
69188: GO 69103
// end ; end ;
69190: GO 69103
69192: POP
69193: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
69194: LD_VAR 0 4
69198: PUSH
69199: LD_VAR 0 7
69203: ARRAY
69204: PPUSH
69205: CALL_OW 257
69209: PUSH
69210: LD_INT 8
69212: EQUAL
69213: PUSH
69214: LD_VAR 0 4
69218: PUSH
69219: LD_VAR 0 7
69223: ARRAY
69224: PPUSH
69225: CALL_OW 264
69229: PUSH
69230: LD_INT 28
69232: PUSH
69233: LD_INT 45
69235: PUSH
69236: LD_INT 7
69238: PUSH
69239: LD_INT 47
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: IN
69248: OR
69249: IFFALSE 69479
// begin attacking := false ;
69251: LD_ADDR_VAR 0 29
69255: PUSH
69256: LD_INT 0
69258: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
69259: LD_VAR 0 14
69263: PUSH
69264: LD_INT 1
69266: ARRAY
69267: PPUSH
69268: CALL_OW 266
69272: PUSH
69273: LD_INT 32
69275: PUSH
69276: LD_INT 31
69278: PUSH
69279: LD_INT 33
69281: PUSH
69282: LD_INT 4
69284: PUSH
69285: LD_INT 5
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: IN
69295: IFFALSE 69479
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
69297: LD_ADDR_VAR 0 9
69301: PUSH
69302: LD_VAR 0 14
69306: PUSH
69307: LD_INT 1
69309: ARRAY
69310: PPUSH
69311: CALL_OW 266
69315: PPUSH
69316: LD_VAR 0 14
69320: PUSH
69321: LD_INT 1
69323: ARRAY
69324: PPUSH
69325: CALL_OW 250
69329: PPUSH
69330: LD_VAR 0 14
69334: PUSH
69335: LD_INT 1
69337: ARRAY
69338: PPUSH
69339: CALL_OW 251
69343: PPUSH
69344: LD_VAR 0 14
69348: PUSH
69349: LD_INT 1
69351: ARRAY
69352: PPUSH
69353: CALL_OW 254
69357: PPUSH
69358: LD_VAR 0 14
69362: PUSH
69363: LD_INT 1
69365: ARRAY
69366: PPUSH
69367: CALL_OW 248
69371: PPUSH
69372: LD_INT 0
69374: PPUSH
69375: CALL 46111 0 6
69379: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
69380: LD_ADDR_VAR 0 8
69384: PUSH
69385: LD_VAR 0 4
69389: PUSH
69390: LD_VAR 0 7
69394: ARRAY
69395: PPUSH
69396: LD_VAR 0 9
69400: PPUSH
69401: CALL 64798 0 2
69405: ST_TO_ADDR
// if j then
69406: LD_VAR 0 8
69410: IFFALSE 69479
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
69412: LD_VAR 0 8
69416: PUSH
69417: LD_INT 1
69419: ARRAY
69420: PPUSH
69421: LD_VAR 0 8
69425: PUSH
69426: LD_INT 2
69428: ARRAY
69429: PPUSH
69430: CALL_OW 488
69434: IFFALSE 69479
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
69436: LD_VAR 0 4
69440: PUSH
69441: LD_VAR 0 7
69445: ARRAY
69446: PPUSH
69447: LD_VAR 0 8
69451: PUSH
69452: LD_INT 1
69454: ARRAY
69455: PPUSH
69456: LD_VAR 0 8
69460: PUSH
69461: LD_INT 2
69463: ARRAY
69464: PPUSH
69465: CALL_OW 116
// attacking := true ;
69469: LD_ADDR_VAR 0 29
69473: PUSH
69474: LD_INT 1
69476: ST_TO_ADDR
// continue ;
69477: GO 66852
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
69479: LD_VAR 0 4
69483: PUSH
69484: LD_VAR 0 7
69488: ARRAY
69489: PPUSH
69490: CALL_OW 265
69494: PUSH
69495: LD_INT 11
69497: EQUAL
69498: IFFALSE 69776
// begin k := 10 ;
69500: LD_ADDR_VAR 0 9
69504: PUSH
69505: LD_INT 10
69507: ST_TO_ADDR
// x := 0 ;
69508: LD_ADDR_VAR 0 10
69512: PUSH
69513: LD_INT 0
69515: ST_TO_ADDR
// if tmp < k then
69516: LD_VAR 0 14
69520: PUSH
69521: LD_VAR 0 9
69525: LESS
69526: IFFALSE 69538
// k := tmp ;
69528: LD_ADDR_VAR 0 9
69532: PUSH
69533: LD_VAR 0 14
69537: ST_TO_ADDR
// for j = k downto 1 do
69538: LD_ADDR_VAR 0 8
69542: PUSH
69543: DOUBLE
69544: LD_VAR 0 9
69548: INC
69549: ST_TO_ADDR
69550: LD_INT 1
69552: PUSH
69553: FOR_DOWNTO
69554: IFFALSE 69629
// begin if GetType ( tmp [ j ] ) = unit_human then
69556: LD_VAR 0 14
69560: PUSH
69561: LD_VAR 0 8
69565: ARRAY
69566: PPUSH
69567: CALL_OW 247
69571: PUSH
69572: LD_INT 1
69574: EQUAL
69575: IFFALSE 69627
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
69577: LD_VAR 0 4
69581: PUSH
69582: LD_VAR 0 7
69586: ARRAY
69587: PPUSH
69588: LD_VAR 0 14
69592: PUSH
69593: LD_VAR 0 8
69597: ARRAY
69598: PPUSH
69599: CALL 65069 0 2
// x := tmp [ j ] ;
69603: LD_ADDR_VAR 0 10
69607: PUSH
69608: LD_VAR 0 14
69612: PUSH
69613: LD_VAR 0 8
69617: ARRAY
69618: ST_TO_ADDR
// attacking := true ;
69619: LD_ADDR_VAR 0 29
69623: PUSH
69624: LD_INT 1
69626: ST_TO_ADDR
// end ; end ;
69627: GO 69553
69629: POP
69630: POP
// if not x then
69631: LD_VAR 0 10
69635: NOT
69636: IFFALSE 69776
// begin attacking := true ;
69638: LD_ADDR_VAR 0 29
69642: PUSH
69643: LD_INT 1
69645: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
69646: LD_VAR 0 4
69650: PUSH
69651: LD_VAR 0 7
69655: ARRAY
69656: PPUSH
69657: CALL_OW 250
69661: PPUSH
69662: LD_VAR 0 4
69666: PUSH
69667: LD_VAR 0 7
69671: ARRAY
69672: PPUSH
69673: CALL_OW 251
69677: PPUSH
69678: CALL_OW 546
69682: PUSH
69683: LD_INT 2
69685: ARRAY
69686: PUSH
69687: LD_VAR 0 14
69691: PUSH
69692: LD_INT 1
69694: ARRAY
69695: PPUSH
69696: CALL_OW 250
69700: PPUSH
69701: LD_VAR 0 14
69705: PUSH
69706: LD_INT 1
69708: ARRAY
69709: PPUSH
69710: CALL_OW 251
69714: PPUSH
69715: CALL_OW 546
69719: PUSH
69720: LD_INT 2
69722: ARRAY
69723: EQUAL
69724: IFFALSE 69752
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
69726: LD_VAR 0 4
69730: PUSH
69731: LD_VAR 0 7
69735: ARRAY
69736: PPUSH
69737: LD_VAR 0 14
69741: PUSH
69742: LD_INT 1
69744: ARRAY
69745: PPUSH
69746: CALL 65069 0 2
69750: GO 69776
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
69752: LD_VAR 0 4
69756: PUSH
69757: LD_VAR 0 7
69761: ARRAY
69762: PPUSH
69763: LD_VAR 0 14
69767: PUSH
69768: LD_INT 1
69770: ARRAY
69771: PPUSH
69772: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
69776: LD_VAR 0 4
69780: PUSH
69781: LD_VAR 0 7
69785: ARRAY
69786: PPUSH
69787: CALL_OW 264
69791: PUSH
69792: LD_INT 29
69794: EQUAL
69795: IFFALSE 70161
// begin if WantsToAttack ( group [ i ] ) in bombed then
69797: LD_VAR 0 4
69801: PUSH
69802: LD_VAR 0 7
69806: ARRAY
69807: PPUSH
69808: CALL_OW 319
69812: PUSH
69813: LD_VAR 0 28
69817: IN
69818: IFFALSE 69822
// continue ;
69820: GO 66852
// k := 8 ;
69822: LD_ADDR_VAR 0 9
69826: PUSH
69827: LD_INT 8
69829: ST_TO_ADDR
// x := 0 ;
69830: LD_ADDR_VAR 0 10
69834: PUSH
69835: LD_INT 0
69837: ST_TO_ADDR
// if tmp < k then
69838: LD_VAR 0 14
69842: PUSH
69843: LD_VAR 0 9
69847: LESS
69848: IFFALSE 69860
// k := tmp ;
69850: LD_ADDR_VAR 0 9
69854: PUSH
69855: LD_VAR 0 14
69859: ST_TO_ADDR
// for j = 1 to k do
69860: LD_ADDR_VAR 0 8
69864: PUSH
69865: DOUBLE
69866: LD_INT 1
69868: DEC
69869: ST_TO_ADDR
69870: LD_VAR 0 9
69874: PUSH
69875: FOR_TO
69876: IFFALSE 70008
// begin if GetType ( tmp [ j ] ) = unit_building then
69878: LD_VAR 0 14
69882: PUSH
69883: LD_VAR 0 8
69887: ARRAY
69888: PPUSH
69889: CALL_OW 247
69893: PUSH
69894: LD_INT 3
69896: EQUAL
69897: IFFALSE 70006
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
69899: LD_VAR 0 14
69903: PUSH
69904: LD_VAR 0 8
69908: ARRAY
69909: PUSH
69910: LD_VAR 0 28
69914: IN
69915: NOT
69916: PUSH
69917: LD_VAR 0 14
69921: PUSH
69922: LD_VAR 0 8
69926: ARRAY
69927: PPUSH
69928: CALL_OW 313
69932: AND
69933: IFFALSE 70006
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
69935: LD_VAR 0 4
69939: PUSH
69940: LD_VAR 0 7
69944: ARRAY
69945: PPUSH
69946: LD_VAR 0 14
69950: PUSH
69951: LD_VAR 0 8
69955: ARRAY
69956: PPUSH
69957: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
69961: LD_ADDR_VAR 0 28
69965: PUSH
69966: LD_VAR 0 28
69970: PPUSH
69971: LD_VAR 0 28
69975: PUSH
69976: LD_INT 1
69978: PLUS
69979: PPUSH
69980: LD_VAR 0 14
69984: PUSH
69985: LD_VAR 0 8
69989: ARRAY
69990: PPUSH
69991: CALL_OW 1
69995: ST_TO_ADDR
// attacking := true ;
69996: LD_ADDR_VAR 0 29
70000: PUSH
70001: LD_INT 1
70003: ST_TO_ADDR
// break ;
70004: GO 70008
// end ; end ;
70006: GO 69875
70008: POP
70009: POP
// if not attacking and f_attack_depot then
70010: LD_VAR 0 29
70014: NOT
70015: PUSH
70016: LD_VAR 0 25
70020: AND
70021: IFFALSE 70116
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70023: LD_ADDR_VAR 0 13
70027: PUSH
70028: LD_VAR 0 14
70032: PPUSH
70033: LD_INT 2
70035: PUSH
70036: LD_INT 30
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 30
70048: PUSH
70049: LD_INT 1
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: LIST
70060: PPUSH
70061: CALL_OW 72
70065: ST_TO_ADDR
// if z then
70066: LD_VAR 0 13
70070: IFFALSE 70116
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
70072: LD_VAR 0 4
70076: PUSH
70077: LD_VAR 0 7
70081: ARRAY
70082: PPUSH
70083: LD_VAR 0 13
70087: PPUSH
70088: LD_VAR 0 4
70092: PUSH
70093: LD_VAR 0 7
70097: ARRAY
70098: PPUSH
70099: CALL_OW 74
70103: PPUSH
70104: CALL_OW 115
// attacking := true ;
70108: LD_ADDR_VAR 0 29
70112: PUSH
70113: LD_INT 1
70115: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
70116: LD_VAR 0 4
70120: PUSH
70121: LD_VAR 0 7
70125: ARRAY
70126: PPUSH
70127: CALL_OW 256
70131: PUSH
70132: LD_INT 500
70134: LESS
70135: IFFALSE 70161
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
70137: LD_VAR 0 4
70141: PUSH
70142: LD_VAR 0 7
70146: ARRAY
70147: PPUSH
70148: LD_VAR 0 14
70152: PUSH
70153: LD_INT 1
70155: ARRAY
70156: PPUSH
70157: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
70161: LD_VAR 0 4
70165: PUSH
70166: LD_VAR 0 7
70170: ARRAY
70171: PPUSH
70172: CALL_OW 264
70176: PUSH
70177: LD_INT 49
70179: EQUAL
70180: IFFALSE 70301
// begin if not HasTask ( group [ i ] ) then
70182: LD_VAR 0 4
70186: PUSH
70187: LD_VAR 0 7
70191: ARRAY
70192: PPUSH
70193: CALL_OW 314
70197: NOT
70198: IFFALSE 70301
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
70200: LD_ADDR_VAR 0 9
70204: PUSH
70205: LD_INT 81
70207: PUSH
70208: LD_VAR 0 4
70212: PUSH
70213: LD_VAR 0 7
70217: ARRAY
70218: PPUSH
70219: CALL_OW 255
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PPUSH
70228: CALL_OW 69
70232: PPUSH
70233: LD_VAR 0 4
70237: PUSH
70238: LD_VAR 0 7
70242: ARRAY
70243: PPUSH
70244: CALL_OW 74
70248: ST_TO_ADDR
// if k then
70249: LD_VAR 0 9
70253: IFFALSE 70301
// if GetDistUnits ( group [ i ] , k ) > 10 then
70255: LD_VAR 0 4
70259: PUSH
70260: LD_VAR 0 7
70264: ARRAY
70265: PPUSH
70266: LD_VAR 0 9
70270: PPUSH
70271: CALL_OW 296
70275: PUSH
70276: LD_INT 10
70278: GREATER
70279: IFFALSE 70301
// ComMoveUnit ( group [ i ] , k ) ;
70281: LD_VAR 0 4
70285: PUSH
70286: LD_VAR 0 7
70290: ARRAY
70291: PPUSH
70292: LD_VAR 0 9
70296: PPUSH
70297: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
70301: LD_VAR 0 4
70305: PUSH
70306: LD_VAR 0 7
70310: ARRAY
70311: PPUSH
70312: CALL_OW 256
70316: PUSH
70317: LD_INT 250
70319: LESS
70320: PUSH
70321: LD_VAR 0 4
70325: PUSH
70326: LD_VAR 0 7
70330: ARRAY
70331: PUSH
70332: LD_INT 21
70334: PUSH
70335: LD_INT 2
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 23
70344: PUSH
70345: LD_INT 2
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PPUSH
70356: CALL_OW 69
70360: IN
70361: AND
70362: IFFALSE 70487
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
70364: LD_ADDR_VAR 0 9
70368: PUSH
70369: LD_OWVAR 3
70373: PUSH
70374: LD_VAR 0 4
70378: PUSH
70379: LD_VAR 0 7
70383: ARRAY
70384: DIFF
70385: PPUSH
70386: LD_VAR 0 4
70390: PUSH
70391: LD_VAR 0 7
70395: ARRAY
70396: PPUSH
70397: CALL_OW 74
70401: ST_TO_ADDR
// if not k then
70402: LD_VAR 0 9
70406: NOT
70407: IFFALSE 70411
// continue ;
70409: GO 66852
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
70411: LD_VAR 0 9
70415: PUSH
70416: LD_INT 81
70418: PUSH
70419: LD_VAR 0 4
70423: PUSH
70424: LD_VAR 0 7
70428: ARRAY
70429: PPUSH
70430: CALL_OW 255
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PPUSH
70439: CALL_OW 69
70443: IN
70444: PUSH
70445: LD_VAR 0 9
70449: PPUSH
70450: LD_VAR 0 4
70454: PUSH
70455: LD_VAR 0 7
70459: ARRAY
70460: PPUSH
70461: CALL_OW 296
70465: PUSH
70466: LD_INT 5
70468: LESS
70469: AND
70470: IFFALSE 70487
// ComAutodestruct ( group [ i ] ) ;
70472: LD_VAR 0 4
70476: PUSH
70477: LD_VAR 0 7
70481: ARRAY
70482: PPUSH
70483: CALL 64967 0 1
// end ; if f_attack_depot then
70487: LD_VAR 0 25
70491: IFFALSE 70603
// begin k := 6 ;
70493: LD_ADDR_VAR 0 9
70497: PUSH
70498: LD_INT 6
70500: ST_TO_ADDR
// if tmp < k then
70501: LD_VAR 0 14
70505: PUSH
70506: LD_VAR 0 9
70510: LESS
70511: IFFALSE 70523
// k := tmp ;
70513: LD_ADDR_VAR 0 9
70517: PUSH
70518: LD_VAR 0 14
70522: ST_TO_ADDR
// for j = 1 to k do
70523: LD_ADDR_VAR 0 8
70527: PUSH
70528: DOUBLE
70529: LD_INT 1
70531: DEC
70532: ST_TO_ADDR
70533: LD_VAR 0 9
70537: PUSH
70538: FOR_TO
70539: IFFALSE 70601
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
70541: LD_VAR 0 8
70545: PPUSH
70546: CALL_OW 266
70550: PUSH
70551: LD_INT 0
70553: PUSH
70554: LD_INT 1
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: IN
70561: IFFALSE 70599
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
70563: LD_VAR 0 4
70567: PUSH
70568: LD_VAR 0 7
70572: ARRAY
70573: PPUSH
70574: LD_VAR 0 14
70578: PUSH
70579: LD_VAR 0 8
70583: ARRAY
70584: PPUSH
70585: CALL_OW 115
// attacking := true ;
70589: LD_ADDR_VAR 0 29
70593: PUSH
70594: LD_INT 1
70596: ST_TO_ADDR
// break ;
70597: GO 70601
// end ;
70599: GO 70538
70601: POP
70602: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
70603: LD_VAR 0 4
70607: PUSH
70608: LD_VAR 0 7
70612: ARRAY
70613: PPUSH
70614: CALL_OW 302
70618: PUSH
70619: LD_VAR 0 29
70623: NOT
70624: AND
70625: IFFALSE 70947
// begin if GetTag ( group [ i ] ) = 71 then
70627: LD_VAR 0 4
70631: PUSH
70632: LD_VAR 0 7
70636: ARRAY
70637: PPUSH
70638: CALL_OW 110
70642: PUSH
70643: LD_INT 71
70645: EQUAL
70646: IFFALSE 70687
// begin if HasTask ( group [ i ] ) then
70648: LD_VAR 0 4
70652: PUSH
70653: LD_VAR 0 7
70657: ARRAY
70658: PPUSH
70659: CALL_OW 314
70663: IFFALSE 70669
// continue else
70665: GO 66852
70667: GO 70687
// SetTag ( group [ i ] , 0 ) ;
70669: LD_VAR 0 4
70673: PUSH
70674: LD_VAR 0 7
70678: ARRAY
70679: PPUSH
70680: LD_INT 0
70682: PPUSH
70683: CALL_OW 109
// end ; k := 8 ;
70687: LD_ADDR_VAR 0 9
70691: PUSH
70692: LD_INT 8
70694: ST_TO_ADDR
// x := 0 ;
70695: LD_ADDR_VAR 0 10
70699: PUSH
70700: LD_INT 0
70702: ST_TO_ADDR
// if tmp < k then
70703: LD_VAR 0 14
70707: PUSH
70708: LD_VAR 0 9
70712: LESS
70713: IFFALSE 70725
// k := tmp ;
70715: LD_ADDR_VAR 0 9
70719: PUSH
70720: LD_VAR 0 14
70724: ST_TO_ADDR
// for j = 1 to k do
70725: LD_ADDR_VAR 0 8
70729: PUSH
70730: DOUBLE
70731: LD_INT 1
70733: DEC
70734: ST_TO_ADDR
70735: LD_VAR 0 9
70739: PUSH
70740: FOR_TO
70741: IFFALSE 70839
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
70743: LD_VAR 0 14
70747: PUSH
70748: LD_VAR 0 8
70752: ARRAY
70753: PPUSH
70754: CALL_OW 247
70758: PUSH
70759: LD_INT 1
70761: EQUAL
70762: PUSH
70763: LD_VAR 0 14
70767: PUSH
70768: LD_VAR 0 8
70772: ARRAY
70773: PPUSH
70774: CALL_OW 256
70778: PUSH
70779: LD_INT 250
70781: LESS
70782: PUSH
70783: LD_VAR 0 20
70787: AND
70788: PUSH
70789: LD_VAR 0 20
70793: NOT
70794: PUSH
70795: LD_VAR 0 14
70799: PUSH
70800: LD_VAR 0 8
70804: ARRAY
70805: PPUSH
70806: CALL_OW 256
70810: PUSH
70811: LD_INT 250
70813: GREATEREQUAL
70814: AND
70815: OR
70816: AND
70817: IFFALSE 70837
// begin x := tmp [ j ] ;
70819: LD_ADDR_VAR 0 10
70823: PUSH
70824: LD_VAR 0 14
70828: PUSH
70829: LD_VAR 0 8
70833: ARRAY
70834: ST_TO_ADDR
// break ;
70835: GO 70839
// end ;
70837: GO 70740
70839: POP
70840: POP
// if x then
70841: LD_VAR 0 10
70845: IFFALSE 70869
// ComAttackUnit ( group [ i ] , x ) else
70847: LD_VAR 0 4
70851: PUSH
70852: LD_VAR 0 7
70856: ARRAY
70857: PPUSH
70858: LD_VAR 0 10
70862: PPUSH
70863: CALL_OW 115
70867: GO 70893
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
70869: LD_VAR 0 4
70873: PUSH
70874: LD_VAR 0 7
70878: ARRAY
70879: PPUSH
70880: LD_VAR 0 14
70884: PUSH
70885: LD_INT 1
70887: ARRAY
70888: PPUSH
70889: CALL_OW 115
// if not HasTask ( group [ i ] ) then
70893: LD_VAR 0 4
70897: PUSH
70898: LD_VAR 0 7
70902: ARRAY
70903: PPUSH
70904: CALL_OW 314
70908: NOT
70909: IFFALSE 70947
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
70911: LD_VAR 0 4
70915: PUSH
70916: LD_VAR 0 7
70920: ARRAY
70921: PPUSH
70922: LD_VAR 0 14
70926: PPUSH
70927: LD_VAR 0 4
70931: PUSH
70932: LD_VAR 0 7
70936: ARRAY
70937: PPUSH
70938: CALL_OW 74
70942: PPUSH
70943: CALL_OW 115
// end ; end ; end ;
70947: GO 66852
70949: POP
70950: POP
// wait ( 0 0$1 ) ;
70951: LD_INT 35
70953: PPUSH
70954: CALL_OW 67
// until group = [ ] ;
70958: LD_VAR 0 4
70962: PUSH
70963: EMPTY
70964: EQUAL
70965: IFFALSE 66837
// end ;
70967: LD_VAR 0 2
70971: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
70972: LD_INT 0
70974: PPUSH
70975: PPUSH
70976: PPUSH
70977: PPUSH
// if not base_units then
70978: LD_VAR 0 1
70982: NOT
70983: IFFALSE 70987
// exit ;
70985: GO 71074
// result := false ;
70987: LD_ADDR_VAR 0 2
70991: PUSH
70992: LD_INT 0
70994: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
70995: LD_ADDR_VAR 0 5
70999: PUSH
71000: LD_VAR 0 1
71004: PPUSH
71005: LD_INT 21
71007: PUSH
71008: LD_INT 3
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PPUSH
71015: CALL_OW 72
71019: ST_TO_ADDR
// if not tmp then
71020: LD_VAR 0 5
71024: NOT
71025: IFFALSE 71029
// exit ;
71027: GO 71074
// for i in tmp do
71029: LD_ADDR_VAR 0 3
71033: PUSH
71034: LD_VAR 0 5
71038: PUSH
71039: FOR_IN
71040: IFFALSE 71072
// begin result := EnemyInRange ( i , 22 ) ;
71042: LD_ADDR_VAR 0 2
71046: PUSH
71047: LD_VAR 0 3
71051: PPUSH
71052: LD_INT 22
71054: PPUSH
71055: CALL 64650 0 2
71059: ST_TO_ADDR
// if result then
71060: LD_VAR 0 2
71064: IFFALSE 71070
// exit ;
71066: POP
71067: POP
71068: GO 71074
// end ;
71070: GO 71039
71072: POP
71073: POP
// end ;
71074: LD_VAR 0 2
71078: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
71079: LD_INT 0
71081: PPUSH
71082: PPUSH
// if not units then
71083: LD_VAR 0 1
71087: NOT
71088: IFFALSE 71092
// exit ;
71090: GO 71162
// result := [ ] ;
71092: LD_ADDR_VAR 0 3
71096: PUSH
71097: EMPTY
71098: ST_TO_ADDR
// for i in units do
71099: LD_ADDR_VAR 0 4
71103: PUSH
71104: LD_VAR 0 1
71108: PUSH
71109: FOR_IN
71110: IFFALSE 71160
// if GetTag ( i ) = tag then
71112: LD_VAR 0 4
71116: PPUSH
71117: CALL_OW 110
71121: PUSH
71122: LD_VAR 0 2
71126: EQUAL
71127: IFFALSE 71158
// result := Insert ( result , result + 1 , i ) ;
71129: LD_ADDR_VAR 0 3
71133: PUSH
71134: LD_VAR 0 3
71138: PPUSH
71139: LD_VAR 0 3
71143: PUSH
71144: LD_INT 1
71146: PLUS
71147: PPUSH
71148: LD_VAR 0 4
71152: PPUSH
71153: CALL_OW 2
71157: ST_TO_ADDR
71158: GO 71109
71160: POP
71161: POP
// end ;
71162: LD_VAR 0 3
71166: RET
// export function IsDriver ( un ) ; begin
71167: LD_INT 0
71169: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
71170: LD_ADDR_VAR 0 2
71174: PUSH
71175: LD_VAR 0 1
71179: PUSH
71180: LD_INT 55
71182: PUSH
71183: EMPTY
71184: LIST
71185: PPUSH
71186: CALL_OW 69
71190: IN
71191: ST_TO_ADDR
// end ;
71192: LD_VAR 0 2
71196: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
71197: LD_INT 0
71199: PPUSH
71200: PPUSH
// list := [ ] ;
71201: LD_ADDR_VAR 0 5
71205: PUSH
71206: EMPTY
71207: ST_TO_ADDR
// case d of 0 :
71208: LD_VAR 0 3
71212: PUSH
71213: LD_INT 0
71215: DOUBLE
71216: EQUAL
71217: IFTRUE 71221
71219: GO 71354
71221: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
71222: LD_ADDR_VAR 0 5
71226: PUSH
71227: LD_VAR 0 1
71231: PUSH
71232: LD_INT 4
71234: MINUS
71235: PUSH
71236: LD_VAR 0 2
71240: PUSH
71241: LD_INT 4
71243: MINUS
71244: PUSH
71245: LD_INT 2
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: LIST
71252: PUSH
71253: LD_VAR 0 1
71257: PUSH
71258: LD_INT 3
71260: MINUS
71261: PUSH
71262: LD_VAR 0 2
71266: PUSH
71267: LD_INT 1
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: LIST
71274: PUSH
71275: LD_VAR 0 1
71279: PUSH
71280: LD_INT 4
71282: PLUS
71283: PUSH
71284: LD_VAR 0 2
71288: PUSH
71289: LD_INT 4
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: LIST
71296: PUSH
71297: LD_VAR 0 1
71301: PUSH
71302: LD_INT 3
71304: PLUS
71305: PUSH
71306: LD_VAR 0 2
71310: PUSH
71311: LD_INT 3
71313: PLUS
71314: PUSH
71315: LD_INT 5
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: LIST
71322: PUSH
71323: LD_VAR 0 1
71327: PUSH
71328: LD_VAR 0 2
71332: PUSH
71333: LD_INT 4
71335: PLUS
71336: PUSH
71337: LD_INT 0
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: LIST
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: ST_TO_ADDR
// end ; 1 :
71352: GO 72052
71354: LD_INT 1
71356: DOUBLE
71357: EQUAL
71358: IFTRUE 71362
71360: GO 71495
71362: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
71363: LD_ADDR_VAR 0 5
71367: PUSH
71368: LD_VAR 0 1
71372: PUSH
71373: LD_VAR 0 2
71377: PUSH
71378: LD_INT 4
71380: MINUS
71381: PUSH
71382: LD_INT 3
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: LIST
71389: PUSH
71390: LD_VAR 0 1
71394: PUSH
71395: LD_INT 3
71397: MINUS
71398: PUSH
71399: LD_VAR 0 2
71403: PUSH
71404: LD_INT 3
71406: MINUS
71407: PUSH
71408: LD_INT 2
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: LIST
71415: PUSH
71416: LD_VAR 0 1
71420: PUSH
71421: LD_INT 4
71423: MINUS
71424: PUSH
71425: LD_VAR 0 2
71429: PUSH
71430: LD_INT 1
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: LIST
71437: PUSH
71438: LD_VAR 0 1
71442: PUSH
71443: LD_VAR 0 2
71447: PUSH
71448: LD_INT 3
71450: PLUS
71451: PUSH
71452: LD_INT 0
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: LIST
71459: PUSH
71460: LD_VAR 0 1
71464: PUSH
71465: LD_INT 4
71467: PLUS
71468: PUSH
71469: LD_VAR 0 2
71473: PUSH
71474: LD_INT 4
71476: PLUS
71477: PUSH
71478: LD_INT 5
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: LIST
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: ST_TO_ADDR
// end ; 2 :
71493: GO 72052
71495: LD_INT 2
71497: DOUBLE
71498: EQUAL
71499: IFTRUE 71503
71501: GO 71632
71503: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
71504: LD_ADDR_VAR 0 5
71508: PUSH
71509: LD_VAR 0 1
71513: PUSH
71514: LD_VAR 0 2
71518: PUSH
71519: LD_INT 3
71521: MINUS
71522: PUSH
71523: LD_INT 3
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: LIST
71530: PUSH
71531: LD_VAR 0 1
71535: PUSH
71536: LD_INT 4
71538: PLUS
71539: PUSH
71540: LD_VAR 0 2
71544: PUSH
71545: LD_INT 4
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: LIST
71552: PUSH
71553: LD_VAR 0 1
71557: PUSH
71558: LD_VAR 0 2
71562: PUSH
71563: LD_INT 4
71565: PLUS
71566: PUSH
71567: LD_INT 0
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: LIST
71574: PUSH
71575: LD_VAR 0 1
71579: PUSH
71580: LD_INT 3
71582: MINUS
71583: PUSH
71584: LD_VAR 0 2
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: LIST
71596: PUSH
71597: LD_VAR 0 1
71601: PUSH
71602: LD_INT 4
71604: MINUS
71605: PUSH
71606: LD_VAR 0 2
71610: PUSH
71611: LD_INT 4
71613: MINUS
71614: PUSH
71615: LD_INT 2
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: LIST
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: ST_TO_ADDR
// end ; 3 :
71630: GO 72052
71632: LD_INT 3
71634: DOUBLE
71635: EQUAL
71636: IFTRUE 71640
71638: GO 71773
71640: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
71641: LD_ADDR_VAR 0 5
71645: PUSH
71646: LD_VAR 0 1
71650: PUSH
71651: LD_INT 3
71653: PLUS
71654: PUSH
71655: LD_VAR 0 2
71659: PUSH
71660: LD_INT 4
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: PUSH
71668: LD_VAR 0 1
71672: PUSH
71673: LD_INT 4
71675: PLUS
71676: PUSH
71677: LD_VAR 0 2
71681: PUSH
71682: LD_INT 4
71684: PLUS
71685: PUSH
71686: LD_INT 5
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: LIST
71693: PUSH
71694: LD_VAR 0 1
71698: PUSH
71699: LD_INT 4
71701: MINUS
71702: PUSH
71703: LD_VAR 0 2
71707: PUSH
71708: LD_INT 1
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: LIST
71715: PUSH
71716: LD_VAR 0 1
71720: PUSH
71721: LD_VAR 0 2
71725: PUSH
71726: LD_INT 4
71728: MINUS
71729: PUSH
71730: LD_INT 3
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: LIST
71737: PUSH
71738: LD_VAR 0 1
71742: PUSH
71743: LD_INT 3
71745: MINUS
71746: PUSH
71747: LD_VAR 0 2
71751: PUSH
71752: LD_INT 3
71754: MINUS
71755: PUSH
71756: LD_INT 2
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: LIST
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: ST_TO_ADDR
// end ; 4 :
71771: GO 72052
71773: LD_INT 4
71775: DOUBLE
71776: EQUAL
71777: IFTRUE 71781
71779: GO 71914
71781: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
71782: LD_ADDR_VAR 0 5
71786: PUSH
71787: LD_VAR 0 1
71791: PUSH
71792: LD_VAR 0 2
71796: PUSH
71797: LD_INT 4
71799: PLUS
71800: PUSH
71801: LD_INT 0
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: LIST
71808: PUSH
71809: LD_VAR 0 1
71813: PUSH
71814: LD_INT 3
71816: PLUS
71817: PUSH
71818: LD_VAR 0 2
71822: PUSH
71823: LD_INT 3
71825: PLUS
71826: PUSH
71827: LD_INT 5
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: LIST
71834: PUSH
71835: LD_VAR 0 1
71839: PUSH
71840: LD_INT 4
71842: PLUS
71843: PUSH
71844: LD_VAR 0 2
71848: PUSH
71849: LD_INT 4
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: LIST
71856: PUSH
71857: LD_VAR 0 1
71861: PUSH
71862: LD_VAR 0 2
71866: PUSH
71867: LD_INT 3
71869: MINUS
71870: PUSH
71871: LD_INT 3
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: LIST
71878: PUSH
71879: LD_VAR 0 1
71883: PUSH
71884: LD_INT 4
71886: MINUS
71887: PUSH
71888: LD_VAR 0 2
71892: PUSH
71893: LD_INT 4
71895: MINUS
71896: PUSH
71897: LD_INT 2
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: LIST
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: ST_TO_ADDR
// end ; 5 :
71912: GO 72052
71914: LD_INT 5
71916: DOUBLE
71917: EQUAL
71918: IFTRUE 71922
71920: GO 72051
71922: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
71923: LD_ADDR_VAR 0 5
71927: PUSH
71928: LD_VAR 0 1
71932: PUSH
71933: LD_INT 4
71935: MINUS
71936: PUSH
71937: LD_VAR 0 2
71941: PUSH
71942: LD_INT 1
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: LIST
71949: PUSH
71950: LD_VAR 0 1
71954: PUSH
71955: LD_VAR 0 2
71959: PUSH
71960: LD_INT 4
71962: MINUS
71963: PUSH
71964: LD_INT 3
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: LIST
71971: PUSH
71972: LD_VAR 0 1
71976: PUSH
71977: LD_INT 4
71979: PLUS
71980: PUSH
71981: LD_VAR 0 2
71985: PUSH
71986: LD_INT 4
71988: PLUS
71989: PUSH
71990: LD_INT 5
71992: PUSH
71993: EMPTY
71994: LIST
71995: LIST
71996: LIST
71997: PUSH
71998: LD_VAR 0 1
72002: PUSH
72003: LD_INT 3
72005: PLUS
72006: PUSH
72007: LD_VAR 0 2
72011: PUSH
72012: LD_INT 4
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: LIST
72019: PUSH
72020: LD_VAR 0 1
72024: PUSH
72025: LD_VAR 0 2
72029: PUSH
72030: LD_INT 3
72032: PLUS
72033: PUSH
72034: LD_INT 0
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: LIST
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: ST_TO_ADDR
// end ; end ;
72049: GO 72052
72051: POP
// result := list ;
72052: LD_ADDR_VAR 0 4
72056: PUSH
72057: LD_VAR 0 5
72061: ST_TO_ADDR
// end ;
72062: LD_VAR 0 4
72066: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
72067: LD_INT 0
72069: PPUSH
72070: PPUSH
72071: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
72072: LD_VAR 0 1
72076: NOT
72077: PUSH
72078: LD_VAR 0 2
72082: PUSH
72083: LD_INT 1
72085: PUSH
72086: LD_INT 2
72088: PUSH
72089: LD_INT 3
72091: PUSH
72092: LD_INT 4
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: IN
72101: NOT
72102: OR
72103: IFFALSE 72107
// exit ;
72105: GO 72199
// tmp := [ ] ;
72107: LD_ADDR_VAR 0 5
72111: PUSH
72112: EMPTY
72113: ST_TO_ADDR
// for i in units do
72114: LD_ADDR_VAR 0 4
72118: PUSH
72119: LD_VAR 0 1
72123: PUSH
72124: FOR_IN
72125: IFFALSE 72168
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
72127: LD_ADDR_VAR 0 5
72131: PUSH
72132: LD_VAR 0 5
72136: PPUSH
72137: LD_VAR 0 5
72141: PUSH
72142: LD_INT 1
72144: PLUS
72145: PPUSH
72146: LD_VAR 0 4
72150: PPUSH
72151: LD_VAR 0 2
72155: PPUSH
72156: CALL_OW 259
72160: PPUSH
72161: CALL_OW 2
72165: ST_TO_ADDR
72166: GO 72124
72168: POP
72169: POP
// if not tmp then
72170: LD_VAR 0 5
72174: NOT
72175: IFFALSE 72179
// exit ;
72177: GO 72199
// result := SortListByListDesc ( units , tmp ) ;
72179: LD_ADDR_VAR 0 3
72183: PUSH
72184: LD_VAR 0 1
72188: PPUSH
72189: LD_VAR 0 5
72193: PPUSH
72194: CALL_OW 77
72198: ST_TO_ADDR
// end ;
72199: LD_VAR 0 3
72203: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
72204: LD_INT 0
72206: PPUSH
72207: PPUSH
72208: PPUSH
// x := GetX ( building ) ;
72209: LD_ADDR_VAR 0 4
72213: PUSH
72214: LD_VAR 0 2
72218: PPUSH
72219: CALL_OW 250
72223: ST_TO_ADDR
// y := GetY ( building ) ;
72224: LD_ADDR_VAR 0 5
72228: PUSH
72229: LD_VAR 0 2
72233: PPUSH
72234: CALL_OW 251
72238: ST_TO_ADDR
// if GetTaskList ( unit ) then
72239: LD_VAR 0 1
72243: PPUSH
72244: CALL_OW 437
72248: IFFALSE 72343
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
72250: LD_STRING e
72252: PUSH
72253: LD_VAR 0 1
72257: PPUSH
72258: CALL_OW 437
72262: PUSH
72263: LD_INT 1
72265: ARRAY
72266: PUSH
72267: LD_INT 1
72269: ARRAY
72270: EQUAL
72271: PUSH
72272: LD_VAR 0 4
72276: PUSH
72277: LD_VAR 0 1
72281: PPUSH
72282: CALL_OW 437
72286: PUSH
72287: LD_INT 1
72289: ARRAY
72290: PUSH
72291: LD_INT 2
72293: ARRAY
72294: EQUAL
72295: AND
72296: PUSH
72297: LD_VAR 0 5
72301: PUSH
72302: LD_VAR 0 1
72306: PPUSH
72307: CALL_OW 437
72311: PUSH
72312: LD_INT 1
72314: ARRAY
72315: PUSH
72316: LD_INT 3
72318: ARRAY
72319: EQUAL
72320: AND
72321: IFFALSE 72333
// result := true else
72323: LD_ADDR_VAR 0 3
72327: PUSH
72328: LD_INT 1
72330: ST_TO_ADDR
72331: GO 72341
// result := false ;
72333: LD_ADDR_VAR 0 3
72337: PUSH
72338: LD_INT 0
72340: ST_TO_ADDR
// end else
72341: GO 72351
// result := false ;
72343: LD_ADDR_VAR 0 3
72347: PUSH
72348: LD_INT 0
72350: ST_TO_ADDR
// end ;
72351: LD_VAR 0 3
72355: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
72356: LD_INT 0
72358: PPUSH
72359: PPUSH
72360: PPUSH
72361: PPUSH
// if not unit or not area then
72362: LD_VAR 0 1
72366: NOT
72367: PUSH
72368: LD_VAR 0 2
72372: NOT
72373: OR
72374: IFFALSE 72378
// exit ;
72376: GO 72543
// tmp := AreaToList ( area , i ) ;
72378: LD_ADDR_VAR 0 6
72382: PUSH
72383: LD_VAR 0 2
72387: PPUSH
72388: LD_VAR 0 5
72392: PPUSH
72393: CALL_OW 517
72397: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
72398: LD_ADDR_VAR 0 5
72402: PUSH
72403: DOUBLE
72404: LD_INT 1
72406: DEC
72407: ST_TO_ADDR
72408: LD_VAR 0 6
72412: PUSH
72413: LD_INT 1
72415: ARRAY
72416: PUSH
72417: FOR_TO
72418: IFFALSE 72533
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
72420: LD_ADDR_VAR 0 7
72424: PUSH
72425: LD_VAR 0 6
72429: PUSH
72430: LD_INT 1
72432: ARRAY
72433: PUSH
72434: LD_VAR 0 5
72438: ARRAY
72439: PUSH
72440: LD_VAR 0 6
72444: PUSH
72445: LD_INT 2
72447: ARRAY
72448: PUSH
72449: LD_VAR 0 5
72453: ARRAY
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
72459: LD_VAR 0 7
72463: PUSH
72464: LD_INT 1
72466: ARRAY
72467: PPUSH
72468: LD_VAR 0 7
72472: PUSH
72473: LD_INT 2
72475: ARRAY
72476: PPUSH
72477: CALL_OW 428
72481: PUSH
72482: LD_INT 0
72484: EQUAL
72485: IFFALSE 72531
// begin result := true ;
72487: LD_ADDR_VAR 0 4
72491: PUSH
72492: LD_INT 1
72494: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
72495: LD_VAR 0 1
72499: PPUSH
72500: LD_VAR 0 7
72504: PUSH
72505: LD_INT 1
72507: ARRAY
72508: PPUSH
72509: LD_VAR 0 7
72513: PUSH
72514: LD_INT 2
72516: ARRAY
72517: PPUSH
72518: LD_VAR 0 3
72522: PPUSH
72523: CALL_OW 48
// exit ;
72527: POP
72528: POP
72529: GO 72543
// end ; end ;
72531: GO 72417
72533: POP
72534: POP
// result := false ;
72535: LD_ADDR_VAR 0 4
72539: PUSH
72540: LD_INT 0
72542: ST_TO_ADDR
// end ;
72543: LD_VAR 0 4
72547: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
72548: LD_INT 0
72550: PPUSH
72551: PPUSH
72552: PPUSH
// if not side or side > 8 then
72553: LD_VAR 0 1
72557: NOT
72558: PUSH
72559: LD_VAR 0 1
72563: PUSH
72564: LD_INT 8
72566: GREATER
72567: OR
72568: IFFALSE 72572
// exit ;
72570: GO 72759
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
72572: LD_ADDR_VAR 0 4
72576: PUSH
72577: LD_INT 22
72579: PUSH
72580: LD_VAR 0 1
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 21
72591: PUSH
72592: LD_INT 3
72594: PUSH
72595: EMPTY
72596: LIST
72597: LIST
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PPUSH
72603: CALL_OW 69
72607: ST_TO_ADDR
// if not tmp then
72608: LD_VAR 0 4
72612: NOT
72613: IFFALSE 72617
// exit ;
72615: GO 72759
// enable_addtolog := true ;
72617: LD_ADDR_OWVAR 81
72621: PUSH
72622: LD_INT 1
72624: ST_TO_ADDR
// AddToLog ( [ ) ;
72625: LD_STRING [
72627: PPUSH
72628: CALL_OW 561
// for i in tmp do
72632: LD_ADDR_VAR 0 3
72636: PUSH
72637: LD_VAR 0 4
72641: PUSH
72642: FOR_IN
72643: IFFALSE 72750
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
72645: LD_STRING [
72647: PUSH
72648: LD_VAR 0 3
72652: PPUSH
72653: CALL_OW 266
72657: STR
72658: PUSH
72659: LD_STRING , 
72661: STR
72662: PUSH
72663: LD_VAR 0 3
72667: PPUSH
72668: CALL_OW 250
72672: STR
72673: PUSH
72674: LD_STRING , 
72676: STR
72677: PUSH
72678: LD_VAR 0 3
72682: PPUSH
72683: CALL_OW 251
72687: STR
72688: PUSH
72689: LD_STRING , 
72691: STR
72692: PUSH
72693: LD_VAR 0 3
72697: PPUSH
72698: CALL_OW 254
72702: STR
72703: PUSH
72704: LD_STRING , 
72706: STR
72707: PUSH
72708: LD_VAR 0 3
72712: PPUSH
72713: LD_INT 1
72715: PPUSH
72716: CALL_OW 268
72720: STR
72721: PUSH
72722: LD_STRING , 
72724: STR
72725: PUSH
72726: LD_VAR 0 3
72730: PPUSH
72731: LD_INT 2
72733: PPUSH
72734: CALL_OW 268
72738: STR
72739: PUSH
72740: LD_STRING ],
72742: STR
72743: PPUSH
72744: CALL_OW 561
// end ;
72748: GO 72642
72750: POP
72751: POP
// AddToLog ( ]; ) ;
72752: LD_STRING ];
72754: PPUSH
72755: CALL_OW 561
// end ;
72759: LD_VAR 0 2
72763: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
72764: LD_INT 0
72766: PPUSH
72767: PPUSH
72768: PPUSH
72769: PPUSH
72770: PPUSH
// if not area or not rate or not max then
72771: LD_VAR 0 1
72775: NOT
72776: PUSH
72777: LD_VAR 0 2
72781: NOT
72782: OR
72783: PUSH
72784: LD_VAR 0 4
72788: NOT
72789: OR
72790: IFFALSE 72794
// exit ;
72792: GO 72986
// while 1 do
72794: LD_INT 1
72796: IFFALSE 72986
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
72798: LD_ADDR_VAR 0 9
72802: PUSH
72803: LD_VAR 0 1
72807: PPUSH
72808: LD_INT 1
72810: PPUSH
72811: CALL_OW 287
72815: PUSH
72816: LD_INT 10
72818: MUL
72819: ST_TO_ADDR
// r := rate / 10 ;
72820: LD_ADDR_VAR 0 7
72824: PUSH
72825: LD_VAR 0 2
72829: PUSH
72830: LD_INT 10
72832: DIVREAL
72833: ST_TO_ADDR
// time := 1 1$00 ;
72834: LD_ADDR_VAR 0 8
72838: PUSH
72839: LD_INT 2100
72841: ST_TO_ADDR
// if amount < min then
72842: LD_VAR 0 9
72846: PUSH
72847: LD_VAR 0 3
72851: LESS
72852: IFFALSE 72870
// r := r * 2 else
72854: LD_ADDR_VAR 0 7
72858: PUSH
72859: LD_VAR 0 7
72863: PUSH
72864: LD_INT 2
72866: MUL
72867: ST_TO_ADDR
72868: GO 72896
// if amount > max then
72870: LD_VAR 0 9
72874: PUSH
72875: LD_VAR 0 4
72879: GREATER
72880: IFFALSE 72896
// r := r / 2 ;
72882: LD_ADDR_VAR 0 7
72886: PUSH
72887: LD_VAR 0 7
72891: PUSH
72892: LD_INT 2
72894: DIVREAL
72895: ST_TO_ADDR
// time := time / r ;
72896: LD_ADDR_VAR 0 8
72900: PUSH
72901: LD_VAR 0 8
72905: PUSH
72906: LD_VAR 0 7
72910: DIVREAL
72911: ST_TO_ADDR
// if time < 0 then
72912: LD_VAR 0 8
72916: PUSH
72917: LD_INT 0
72919: LESS
72920: IFFALSE 72937
// time := time * - 1 ;
72922: LD_ADDR_VAR 0 8
72926: PUSH
72927: LD_VAR 0 8
72931: PUSH
72932: LD_INT 1
72934: NEG
72935: MUL
72936: ST_TO_ADDR
// wait ( time ) ;
72937: LD_VAR 0 8
72941: PPUSH
72942: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
72946: LD_INT 35
72948: PPUSH
72949: LD_INT 875
72951: PPUSH
72952: CALL_OW 12
72956: PPUSH
72957: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
72961: LD_INT 1
72963: PPUSH
72964: LD_INT 5
72966: PPUSH
72967: CALL_OW 12
72971: PPUSH
72972: LD_VAR 0 1
72976: PPUSH
72977: LD_INT 1
72979: PPUSH
72980: CALL_OW 55
// end ;
72984: GO 72794
// end ;
72986: LD_VAR 0 5
72990: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
72991: LD_INT 0
72993: PPUSH
72994: PPUSH
72995: PPUSH
72996: PPUSH
72997: PPUSH
72998: PPUSH
72999: PPUSH
73000: PPUSH
// if not turrets or not factories then
73001: LD_VAR 0 1
73005: NOT
73006: PUSH
73007: LD_VAR 0 2
73011: NOT
73012: OR
73013: IFFALSE 73017
// exit ;
73015: GO 73324
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
73017: LD_ADDR_VAR 0 10
73021: PUSH
73022: LD_INT 5
73024: PUSH
73025: LD_INT 6
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 2
73034: PUSH
73035: LD_INT 4
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: LD_INT 5
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 24
73059: PUSH
73060: LD_INT 25
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 23
73069: PUSH
73070: LD_INT 27
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 42
73083: PUSH
73084: LD_INT 43
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: LD_INT 44
73093: PUSH
73094: LD_INT 46
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 45
73103: PUSH
73104: LD_INT 47
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: LIST
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: LIST
73120: ST_TO_ADDR
// result := [ ] ;
73121: LD_ADDR_VAR 0 3
73125: PUSH
73126: EMPTY
73127: ST_TO_ADDR
// for i in turrets do
73128: LD_ADDR_VAR 0 4
73132: PUSH
73133: LD_VAR 0 1
73137: PUSH
73138: FOR_IN
73139: IFFALSE 73322
// begin nat := GetNation ( i ) ;
73141: LD_ADDR_VAR 0 7
73145: PUSH
73146: LD_VAR 0 4
73150: PPUSH
73151: CALL_OW 248
73155: ST_TO_ADDR
// weapon := 0 ;
73156: LD_ADDR_VAR 0 8
73160: PUSH
73161: LD_INT 0
73163: ST_TO_ADDR
// if not nat then
73164: LD_VAR 0 7
73168: NOT
73169: IFFALSE 73173
// continue ;
73171: GO 73138
// for j in list [ nat ] do
73173: LD_ADDR_VAR 0 5
73177: PUSH
73178: LD_VAR 0 10
73182: PUSH
73183: LD_VAR 0 7
73187: ARRAY
73188: PUSH
73189: FOR_IN
73190: IFFALSE 73231
// if GetBWeapon ( i ) = j [ 1 ] then
73192: LD_VAR 0 4
73196: PPUSH
73197: CALL_OW 269
73201: PUSH
73202: LD_VAR 0 5
73206: PUSH
73207: LD_INT 1
73209: ARRAY
73210: EQUAL
73211: IFFALSE 73229
// begin weapon := j [ 2 ] ;
73213: LD_ADDR_VAR 0 8
73217: PUSH
73218: LD_VAR 0 5
73222: PUSH
73223: LD_INT 2
73225: ARRAY
73226: ST_TO_ADDR
// break ;
73227: GO 73231
// end ;
73229: GO 73189
73231: POP
73232: POP
// if not weapon then
73233: LD_VAR 0 8
73237: NOT
73238: IFFALSE 73242
// continue ;
73240: GO 73138
// for k in factories do
73242: LD_ADDR_VAR 0 6
73246: PUSH
73247: LD_VAR 0 2
73251: PUSH
73252: FOR_IN
73253: IFFALSE 73318
// begin weapons := AvailableWeaponList ( k ) ;
73255: LD_ADDR_VAR 0 9
73259: PUSH
73260: LD_VAR 0 6
73264: PPUSH
73265: CALL_OW 478
73269: ST_TO_ADDR
// if not weapons then
73270: LD_VAR 0 9
73274: NOT
73275: IFFALSE 73279
// continue ;
73277: GO 73252
// if weapon in weapons then
73279: LD_VAR 0 8
73283: PUSH
73284: LD_VAR 0 9
73288: IN
73289: IFFALSE 73316
// begin result := [ i , weapon ] ;
73291: LD_ADDR_VAR 0 3
73295: PUSH
73296: LD_VAR 0 4
73300: PUSH
73301: LD_VAR 0 8
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: ST_TO_ADDR
// exit ;
73310: POP
73311: POP
73312: POP
73313: POP
73314: GO 73324
// end ; end ;
73316: GO 73252
73318: POP
73319: POP
// end ;
73320: GO 73138
73322: POP
73323: POP
// end ;
73324: LD_VAR 0 3
73328: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
73329: LD_INT 0
73331: PPUSH
// if not side or side > 8 then
73332: LD_VAR 0 3
73336: NOT
73337: PUSH
73338: LD_VAR 0 3
73342: PUSH
73343: LD_INT 8
73345: GREATER
73346: OR
73347: IFFALSE 73351
// exit ;
73349: GO 73410
// if not range then
73351: LD_VAR 0 4
73355: NOT
73356: IFFALSE 73367
// range := - 12 ;
73358: LD_ADDR_VAR 0 4
73362: PUSH
73363: LD_INT 12
73365: NEG
73366: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
73367: LD_VAR 0 1
73371: PPUSH
73372: LD_VAR 0 2
73376: PPUSH
73377: LD_VAR 0 3
73381: PPUSH
73382: LD_VAR 0 4
73386: PPUSH
73387: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
73391: LD_VAR 0 1
73395: PPUSH
73396: LD_VAR 0 2
73400: PPUSH
73401: LD_VAR 0 3
73405: PPUSH
73406: CALL_OW 331
// end ;
73410: LD_VAR 0 5
73414: RET
