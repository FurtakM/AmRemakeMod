// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2451 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2172 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3758 0 3
 179: ST_TO_ADDR
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 180: LD_ADDR_EXP 18
 184: PUSH
 185: LD_STRING GammaCommander
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: CALL_OW 30
 195: ST_TO_ADDR
// if gamma_commander = 1 then
 196: LD_EXP 18
 200: PUSH
 201: LD_INT 1
 203: EQUAL
 204: IFFALSE 230
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 206: LD_ADDR_EXP 13
 210: PUSH
 211: LD_STRING Donaldson
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 04_
 222: PPUSH
 223: CALL 3758 0 3
 227: ST_TO_ADDR
// end else
 228: GO 301
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 230: LD_STRING DonaldsonIn06
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: IFFALSE 266
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 242: LD_ADDR_EXP 13
 246: PUSH
 247: LD_STRING Donaldson
 249: PPUSH
 250: LD_EXP 1
 254: NOT
 255: PPUSH
 256: LD_STRING 06c_
 258: PPUSH
 259: CALL 3758 0 3
 263: ST_TO_ADDR
 264: GO 301
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 266: LD_STRING DonaldsonStayInDelta
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: NOT
 277: IFFALSE 301
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 279: LD_ADDR_EXP 13
 283: PUSH
 284: LD_STRING Donaldson
 286: PPUSH
 287: LD_EXP 1
 291: NOT
 292: PPUSH
 293: LD_STRING 04_
 295: PPUSH
 296: CALL 3758 0 3
 300: ST_TO_ADDR
// end ; if Donaldson then
 301: LD_EXP 13
 305: IFFALSE 323
// team := team ^ Donaldson ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_EXP 13
 321: ADD
 322: ST_TO_ADDR
// if gamma_commander = 2 then
 323: LD_EXP 18
 327: PUSH
 328: LD_INT 2
 330: EQUAL
 331: IFFALSE 357
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 333: LD_ADDR_EXP 14
 337: PUSH
 338: LD_STRING Brown
 340: PPUSH
 341: LD_EXP 1
 345: NOT
 346: PPUSH
 347: LD_STRING 04_
 349: PPUSH
 350: CALL 3758 0 3
 354: ST_TO_ADDR
// end else
 355: GO 428
// begin if LoadVariable ( BrownIn06 , 0 ) then
 357: LD_STRING BrownIn06
 359: PPUSH
 360: LD_INT 0
 362: PPUSH
 363: CALL_OW 30
 367: IFFALSE 393
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 369: LD_ADDR_EXP 14
 373: PUSH
 374: LD_STRING Brown
 376: PPUSH
 377: LD_EXP 1
 381: NOT
 382: PPUSH
 383: LD_STRING 06c_
 385: PPUSH
 386: CALL 3758 0 3
 390: ST_TO_ADDR
 391: GO 428
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 393: LD_STRING BrownStayInDelta
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: CALL_OW 30
 403: NOT
 404: IFFALSE 428
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 406: LD_ADDR_EXP 14
 410: PUSH
 411: LD_STRING Brown
 413: PPUSH
 414: LD_EXP 1
 418: NOT
 419: PPUSH
 420: LD_STRING 04_
 422: PPUSH
 423: CALL 3758 0 3
 427: ST_TO_ADDR
// end ; if Brown then
 428: LD_EXP 14
 432: IFFALSE 450
// team := team ^ Brown ;
 434: LD_ADDR_VAR 0 6
 438: PUSH
 439: LD_VAR 0 6
 443: PUSH
 444: LD_EXP 14
 448: ADD
 449: ST_TO_ADDR
// if gamma_commander = 3 then
 450: LD_EXP 18
 454: PUSH
 455: LD_INT 3
 457: EQUAL
 458: IFFALSE 495
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 460: LD_ADDR_EXP 15
 464: PUSH
 465: LD_STRING VanHouten
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: LD_STRING 
 473: PPUSH
 474: CALL 3758 0 3
 478: ST_TO_ADDR
// team := team ^ Houten ;
 479: LD_ADDR_VAR 0 6
 483: PUSH
 484: LD_VAR 0 6
 488: PUSH
 489: LD_EXP 15
 493: ADD
 494: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 495: LD_STRING GladstoneIn06
 497: PPUSH
 498: LD_INT 0
 500: PPUSH
 501: CALL_OW 30
 505: IFFALSE 529
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) ;
 507: LD_ADDR_EXP 8
 511: PUSH
 512: LD_STRING Gladstone
 514: PPUSH
 515: LD_EXP 1
 519: NOT
 520: PPUSH
 521: LD_STRING 06c_
 523: PPUSH
 524: CALL 3758 0 3
 528: ST_TO_ADDR
// if Gladstone then
 529: LD_EXP 8
 533: IFFALSE 551
// team := team ^ Gladstone ;
 535: LD_ADDR_VAR 0 6
 539: PUSH
 540: LD_VAR 0 6
 544: PUSH
 545: LD_EXP 8
 549: ADD
 550: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 551: LD_ADDR_EXP 16
 555: PUSH
 556: LD_STRING Khatam
 558: PPUSH
 559: LD_EXP 1
 563: NOT
 564: PPUSH
 565: LD_STRING 03_
 567: PPUSH
 568: CALL 3758 0 3
 572: ST_TO_ADDR
// if Khatam then
 573: LD_EXP 16
 577: IFFALSE 595
// team := team ^ Khatam ;
 579: LD_ADDR_VAR 0 6
 583: PUSH
 584: LD_VAR 0 6
 588: PUSH
 589: LD_EXP 16
 593: ADD
 594: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 595: LD_STRING LisaIn06
 597: PPUSH
 598: LD_INT 0
 600: PPUSH
 601: CALL_OW 30
 605: IFFALSE 631
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 607: LD_ADDR_EXP 10
 611: PUSH
 612: LD_STRING Lisa
 614: PPUSH
 615: LD_EXP 1
 619: NOT
 620: PPUSH
 621: LD_STRING 06c_
 623: PPUSH
 624: CALL 3758 0 3
 628: ST_TO_ADDR
 629: GO 666
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 631: LD_STRING LisaStayInDelta
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 30
 641: NOT
 642: IFFALSE 666
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 644: LD_ADDR_EXP 10
 648: PUSH
 649: LD_STRING Lisa
 651: PPUSH
 652: LD_EXP 1
 656: NOT
 657: PPUSH
 658: LD_STRING 04_
 660: PPUSH
 661: CALL 3758 0 3
 665: ST_TO_ADDR
// if Lisa then
 666: LD_EXP 10
 670: IFFALSE 688
// team := team ^ Lisa ;
 672: LD_ADDR_VAR 0 6
 676: PUSH
 677: LD_VAR 0 6
 681: PUSH
 682: LD_EXP 10
 686: ADD
 687: ST_TO_ADDR
// if LoadVariable ( CyrusIn06 , 0 ) then
 688: LD_STRING CyrusIn06
 690: PPUSH
 691: LD_INT 0
 693: PPUSH
 694: CALL_OW 30
 698: IFFALSE 724
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_STRING Cyrus
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_STRING 06c_
 716: PPUSH
 717: CALL 3758 0 3
 721: ST_TO_ADDR
 722: GO 788
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 724: LD_STRING CyrusStayInDelta
 726: PPUSH
 727: LD_INT 0
 729: PPUSH
 730: CALL_OW 30
 734: NOT
 735: IFFALSE 788
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 737: LD_ADDR_EXP 11
 741: PUSH
 742: LD_STRING Cyrus
 744: PPUSH
 745: LD_EXP 1
 749: NOT
 750: PPUSH
 751: LD_STRING 04_
 753: PPUSH
 754: CALL 3758 0 3
 758: ST_TO_ADDR
// if not Cyrus then
 759: LD_EXP 11
 763: NOT
 764: IFFALSE 788
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 766: LD_ADDR_EXP 11
 770: PUSH
 771: LD_STRING Cyrus
 773: PPUSH
 774: LD_EXP 1
 778: NOT
 779: PPUSH
 780: LD_STRING 03_
 782: PPUSH
 783: CALL 3758 0 3
 787: ST_TO_ADDR
// end ; if Cyrus then
 788: LD_EXP 11
 792: IFFALSE 810
// team := team ^ Cyrus ;
 794: LD_ADDR_VAR 0 6
 798: PUSH
 799: LD_VAR 0 6
 803: PUSH
 804: LD_EXP 11
 808: ADD
 809: ST_TO_ADDR
// if LoadVariable ( BobbyIn06 , 0 ) then
 810: LD_STRING BobbyIn06
 812: PPUSH
 813: LD_INT 0
 815: PPUSH
 816: CALL_OW 30
 820: IFFALSE 846
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 822: LD_ADDR_EXP 12
 826: PUSH
 827: LD_STRING Bobby
 829: PPUSH
 830: LD_EXP 1
 834: NOT
 835: PPUSH
 836: LD_STRING 06c_
 838: PPUSH
 839: CALL 3758 0 3
 843: ST_TO_ADDR
 844: GO 910
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 846: LD_STRING BobbyStayInDelta
 848: PPUSH
 849: LD_INT 0
 851: PPUSH
 852: CALL_OW 30
 856: NOT
 857: IFFALSE 910
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 859: LD_ADDR_EXP 12
 863: PUSH
 864: LD_STRING Bobby
 866: PPUSH
 867: LD_EXP 1
 871: NOT
 872: PPUSH
 873: LD_STRING 04_
 875: PPUSH
 876: CALL 3758 0 3
 880: ST_TO_ADDR
// if not Bobby then
 881: LD_EXP 12
 885: NOT
 886: IFFALSE 910
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 888: LD_ADDR_EXP 12
 892: PUSH
 893: LD_STRING Bobby
 895: PPUSH
 896: LD_EXP 1
 900: NOT
 901: PPUSH
 902: LD_STRING 03_
 904: PPUSH
 905: CALL 3758 0 3
 909: ST_TO_ADDR
// end ; if Bobby then
 910: LD_EXP 12
 914: IFFALSE 932
// team := team ^ Bobby ;
 916: LD_ADDR_VAR 0 6
 920: PUSH
 921: LD_VAR 0 6
 925: PUSH
 926: LD_EXP 12
 930: ADD
 931: ST_TO_ADDR
// others4 := CreateCharacterSet ( othersGamma ) ;
 932: LD_ADDR_VAR 0 4
 936: PUSH
 937: LD_STRING othersGamma
 939: PPUSH
 940: CALL_OW 31
 944: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
 945: LD_ADDR_VAR 0 2
 949: PUSH
 950: LD_STRING 06_other_survivors
 952: PPUSH
 953: CALL_OW 31
 957: ST_TO_ADDR
// others := others union others4 ;
 958: LD_ADDR_VAR 0 2
 962: PUSH
 963: LD_VAR 0 2
 967: PUSH
 968: LD_VAR 0 4
 972: UNION
 973: ST_TO_ADDR
// team := team ^ others ;
 974: LD_ADDR_VAR 0 6
 978: PUSH
 979: LD_VAR 0 6
 983: PUSH
 984: LD_VAR 0 2
 988: ADD
 989: ST_TO_ADDR
// for i in others do
 990: LD_ADDR_VAR 0 13
 994: PUSH
 995: LD_VAR 0 2
 999: PUSH
1000: FOR_IN
1001: IFFALSE 1069
// begin if GetClass ( i ) = 2 then
1003: LD_VAR 0 13
1007: PPUSH
1008: CALL_OW 257
1012: PUSH
1013: LD_INT 2
1015: EQUAL
1016: IFFALSE 1030
// SetClass ( i , 1 ) ;
1018: LD_VAR 0 13
1022: PPUSH
1023: LD_INT 1
1025: PPUSH
1026: CALL_OW 336
// for j = 1 to 4 do
1030: LD_ADDR_VAR 0 14
1034: PUSH
1035: DOUBLE
1036: LD_INT 1
1038: DEC
1039: ST_TO_ADDR
1040: LD_INT 4
1042: PUSH
1043: FOR_TO
1044: IFFALSE 1065
// AddExperience ( i , j , 3000 ) ;
1046: LD_VAR 0 13
1050: PPUSH
1051: LD_VAR 0 14
1055: PPUSH
1056: LD_INT 3000
1058: PPUSH
1059: CALL_OW 492
1063: GO 1043
1065: POP
1066: POP
// end ;
1067: GO 1000
1069: POP
1070: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1071: LD_ADDR_VAR 0 7
1075: PUSH
1076: LD_INT 30
1078: PUSH
1079: LD_INT 0
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL_OW 69
1090: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1091: LD_ADDR_VAR 0 8
1095: PUSH
1096: LD_INT 30
1098: PUSH
1099: LD_INT 4
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL_OW 69
1110: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1111: LD_ADDR_VAR 0 9
1115: PUSH
1116: LD_INT 2
1118: PUSH
1119: LD_INT 30
1121: PUSH
1122: LD_INT 7
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: PUSH
1129: LD_INT 30
1131: PUSH
1132: LD_INT 6
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL_OW 69
1148: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1149: LD_ADDR_VAR 0 10
1153: PUSH
1154: LD_INT 30
1156: PUSH
1157: LD_INT 3
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: PPUSH
1164: CALL_OW 69
1168: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1169: LD_ADDR_VAR 0 11
1173: PUSH
1174: LD_INT 2
1176: PUSH
1177: LD_INT 30
1179: PUSH
1180: LD_INT 32
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 30
1189: PUSH
1190: LD_INT 31
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: EMPTY
1198: LIST
1199: LIST
1200: LIST
1201: PPUSH
1202: CALL_OW 69
1206: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1207: LD_VAR 0 7
1211: PPUSH
1212: LD_STRING Gamma
1214: PPUSH
1215: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1219: LD_VAR 0 7
1223: PPUSH
1224: CALL_OW 274
1228: PPUSH
1229: LD_INT 2
1231: PPUSH
1232: LD_INT 10000
1234: PPUSH
1235: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1239: LD_VAR 0 7
1243: PPUSH
1244: CALL_OW 274
1248: PPUSH
1249: LD_INT 1
1251: PPUSH
1252: LD_INT 10000
1254: PPUSH
1255: CALL_OW 277
// if dep then
1259: LD_VAR 0 7
1263: IFFALSE 1363
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1265: LD_EXP 7
1269: PPUSH
1270: LD_VAR 0 7
1274: PUSH
1275: LD_INT 1
1277: ARRAY
1278: PPUSH
1279: CALL_OW 52
// if Brown then
1283: LD_EXP 14
1287: IFFALSE 1323
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1289: LD_EXP 14
1293: PPUSH
1294: LD_VAR 0 7
1298: PUSH
1299: LD_INT 1
1301: ARRAY
1302: PPUSH
1303: CALL_OW 52
// team := team diff Brown ;
1307: LD_ADDR_VAR 0 6
1311: PUSH
1312: LD_VAR 0 6
1316: PUSH
1317: LD_EXP 14
1321: DIFF
1322: ST_TO_ADDR
// end ; if Donaldson then
1323: LD_EXP 13
1327: IFFALSE 1363
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1329: LD_EXP 13
1333: PPUSH
1334: LD_VAR 0 7
1338: PUSH
1339: LD_INT 1
1341: ARRAY
1342: PPUSH
1343: CALL_OW 52
// team := team diff Donaldson ;
1347: LD_ADDR_VAR 0 6
1351: PUSH
1352: LD_VAR 0 6
1356: PUSH
1357: LD_EXP 13
1361: DIFF
1362: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1363: LD_VAR 0 11
1367: PUSH
1368: LD_VAR 0 6
1372: PPUSH
1373: LD_INT 25
1375: PUSH
1376: LD_INT 1
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PPUSH
1383: CALL_OW 72
1387: AND
1388: IFFALSE 1497
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1390: LD_ADDR_VAR 0 12
1394: PUSH
1395: LD_VAR 0 6
1399: PPUSH
1400: LD_INT 25
1402: PUSH
1403: LD_INT 1
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: PPUSH
1410: CALL_OW 72
1414: ST_TO_ADDR
// for i in bun do
1415: LD_ADDR_VAR 0 13
1419: PUSH
1420: LD_VAR 0 11
1424: PUSH
1425: FOR_IN
1426: IFFALSE 1495
// begin if not filter then
1428: LD_VAR 0 12
1432: NOT
1433: IFFALSE 1437
// break ;
1435: GO 1495
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1437: LD_VAR 0 12
1441: PUSH
1442: LD_INT 1
1444: ARRAY
1445: PPUSH
1446: LD_VAR 0 13
1450: PPUSH
1451: CALL_OW 52
// team := team diff filter [ 1 ] ;
1455: LD_ADDR_VAR 0 6
1459: PUSH
1460: LD_VAR 0 6
1464: PUSH
1465: LD_VAR 0 12
1469: PUSH
1470: LD_INT 1
1472: ARRAY
1473: DIFF
1474: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1475: LD_ADDR_VAR 0 12
1479: PUSH
1480: LD_VAR 0 12
1484: PPUSH
1485: LD_INT 1
1487: PPUSH
1488: CALL_OW 3
1492: ST_TO_ADDR
// end ;
1493: GO 1425
1495: POP
1496: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1497: LD_VAR 0 8
1501: PUSH
1502: LD_VAR 0 6
1506: PPUSH
1507: LD_INT 25
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PPUSH
1517: CALL_OW 72
1521: AND
1522: IFFALSE 1644
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1524: LD_ADDR_VAR 0 12
1528: PUSH
1529: LD_VAR 0 6
1533: PPUSH
1534: LD_INT 25
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PPUSH
1544: CALL_OW 72
1548: ST_TO_ADDR
// for i = 1 to filter do
1549: LD_ADDR_VAR 0 13
1553: PUSH
1554: DOUBLE
1555: LD_INT 1
1557: DEC
1558: ST_TO_ADDR
1559: LD_VAR 0 12
1563: PUSH
1564: FOR_TO
1565: IFFALSE 1626
// begin if ( i <= 6 ) then
1567: LD_VAR 0 13
1571: PUSH
1572: LD_INT 6
1574: LESSEQUAL
1575: IFFALSE 1603
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1577: LD_VAR 0 12
1581: PUSH
1582: LD_VAR 0 13
1586: ARRAY
1587: PPUSH
1588: LD_VAR 0 8
1592: PUSH
1593: LD_INT 1
1595: ARRAY
1596: PPUSH
1597: CALL_OW 52
1601: GO 1624
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1603: LD_VAR 0 12
1607: PUSH
1608: LD_VAR 0 13
1612: ARRAY
1613: PPUSH
1614: LD_INT 1
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: CALL_OW 49
// end ;
1624: GO 1564
1626: POP
1627: POP
// team := team diff filter ;
1628: LD_ADDR_VAR 0 6
1632: PUSH
1633: LD_VAR 0 6
1637: PUSH
1638: LD_VAR 0 12
1642: DIFF
1643: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1644: LD_VAR 0 9
1648: PUSH
1649: LD_VAR 0 6
1653: PPUSH
1654: LD_INT 25
1656: PUSH
1657: LD_INT 4
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PPUSH
1664: CALL_OW 72
1668: AND
1669: IFFALSE 1791
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1671: LD_ADDR_VAR 0 12
1675: PUSH
1676: LD_VAR 0 6
1680: PPUSH
1681: LD_INT 25
1683: PUSH
1684: LD_INT 4
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: PPUSH
1691: CALL_OW 72
1695: ST_TO_ADDR
// for i = 1 to filter do
1696: LD_ADDR_VAR 0 13
1700: PUSH
1701: DOUBLE
1702: LD_INT 1
1704: DEC
1705: ST_TO_ADDR
1706: LD_VAR 0 12
1710: PUSH
1711: FOR_TO
1712: IFFALSE 1773
// begin if ( i <= 6 ) then
1714: LD_VAR 0 13
1718: PUSH
1719: LD_INT 6
1721: LESSEQUAL
1722: IFFALSE 1750
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1724: LD_VAR 0 12
1728: PUSH
1729: LD_VAR 0 13
1733: ARRAY
1734: PPUSH
1735: LD_VAR 0 9
1739: PUSH
1740: LD_INT 1
1742: ARRAY
1743: PPUSH
1744: CALL_OW 52
1748: GO 1771
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1750: LD_VAR 0 12
1754: PUSH
1755: LD_VAR 0 13
1759: ARRAY
1760: PPUSH
1761: LD_INT 1
1763: PPUSH
1764: LD_INT 0
1766: PPUSH
1767: CALL_OW 49
// end ;
1771: GO 1711
1773: POP
1774: POP
// team := team diff filter ;
1775: LD_ADDR_VAR 0 6
1779: PUSH
1780: LD_VAR 0 6
1784: PUSH
1785: LD_VAR 0 12
1789: DIFF
1790: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1791: LD_VAR 0 10
1795: PUSH
1796: LD_VAR 0 6
1800: PPUSH
1801: LD_INT 25
1803: PUSH
1804: LD_INT 3
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: PPUSH
1811: CALL_OW 72
1815: AND
1816: IFFALSE 1938
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1818: LD_ADDR_VAR 0 12
1822: PUSH
1823: LD_VAR 0 6
1827: PPUSH
1828: LD_INT 25
1830: PUSH
1831: LD_INT 3
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: PPUSH
1838: CALL_OW 72
1842: ST_TO_ADDR
// for i = 1 to filter do
1843: LD_ADDR_VAR 0 13
1847: PUSH
1848: DOUBLE
1849: LD_INT 1
1851: DEC
1852: ST_TO_ADDR
1853: LD_VAR 0 12
1857: PUSH
1858: FOR_TO
1859: IFFALSE 1920
// begin if ( i <= 6 ) then
1861: LD_VAR 0 13
1865: PUSH
1866: LD_INT 6
1868: LESSEQUAL
1869: IFFALSE 1897
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1871: LD_VAR 0 12
1875: PUSH
1876: LD_VAR 0 13
1880: ARRAY
1881: PPUSH
1882: LD_VAR 0 10
1886: PUSH
1887: LD_INT 1
1889: ARRAY
1890: PPUSH
1891: CALL_OW 52
1895: GO 1918
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1897: LD_VAR 0 12
1901: PUSH
1902: LD_VAR 0 13
1906: ARRAY
1907: PPUSH
1908: LD_INT 1
1910: PPUSH
1911: LD_INT 0
1913: PPUSH
1914: CALL_OW 49
// end ;
1918: GO 1858
1920: POP
1921: POP
// team := team diff filter ;
1922: LD_ADDR_VAR 0 6
1926: PUSH
1927: LD_VAR 0 6
1931: PUSH
1932: LD_VAR 0 12
1936: DIFF
1937: ST_TO_ADDR
// end ; if team then
1938: LD_VAR 0 6
1942: IFFALSE 1985
// for i in team do
1944: LD_ADDR_VAR 0 13
1948: PUSH
1949: LD_VAR 0 6
1953: PUSH
1954: FOR_IN
1955: IFFALSE 1983
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1957: LD_VAR 0 13
1961: PPUSH
1962: LD_INT 1
1964: PPUSH
1965: LD_INT 0
1967: PPUSH
1968: CALL_OW 49
// ComHold ( i ) ;
1972: LD_VAR 0 13
1976: PPUSH
1977: CALL_OW 140
// end ;
1981: GO 1954
1983: POP
1984: POP
// if fac then
1985: LD_VAR 0 10
1989: IFFALSE 2025
// if UnitsInside ( fac [ 1 ] ) then
1991: LD_VAR 0 10
1995: PUSH
1996: LD_INT 1
1998: ARRAY
1999: PPUSH
2000: CALL_OW 313
2004: IFFALSE 2025
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2006: LD_VAR 0 10
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_INT 10
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: CALL_OW 486
// if lab then
2025: LD_VAR 0 9
2029: IFFALSE 2065
// if UnitsInside ( lab [ 1 ] ) then
2031: LD_VAR 0 9
2035: PUSH
2036: LD_INT 1
2038: ARRAY
2039: PPUSH
2040: CALL_OW 313
2044: IFFALSE 2065
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2046: LD_VAR 0 9
2050: PUSH
2051: LD_INT 1
2053: ARRAY
2054: PPUSH
2055: LD_INT 10
2057: PPUSH
2058: LD_INT 0
2060: PPUSH
2061: CALL_OW 486
// uc_side := 4 ;
2065: LD_ADDR_OWVAR 20
2069: PUSH
2070: LD_INT 4
2072: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2073: LD_ADDR_EXP 17
2077: PUSH
2078: LD_STRING Harisson
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: LD_STRING 
2086: PPUSH
2087: CALL 3758 0 3
2091: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2092: LD_ADDR_VAR 0 5
2096: PUSH
2097: LD_INT 4
2099: PPUSH
2100: LD_INT 1
2102: PPUSH
2103: LD_INT 1
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 1
2111: PPUSH
2112: LD_INT 2
2114: PPUSH
2115: LD_INT 100
2117: PPUSH
2118: CALL 3821 0 7
2122: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2123: LD_VAR 0 5
2127: PPUSH
2128: LD_INT 2
2130: PPUSH
2131: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2135: LD_VAR 0 5
2139: PPUSH
2140: LD_INT 21
2142: PPUSH
2143: LD_INT 8
2145: PPUSH
2146: LD_INT 0
2148: PPUSH
2149: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2153: LD_EXP 17
2157: PPUSH
2158: LD_VAR 0 5
2162: PPUSH
2163: CALL_OW 52
// end ;
2167: LD_VAR 0 1
2171: RET
// function PrepareBase ; var blist , i , b ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
2176: PPUSH
2177: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2178: LD_INT 71
2180: PPUSH
2181: LD_INT 5
2183: PPUSH
2184: LD_INT 1
2186: PPUSH
2187: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2191: LD_ADDR_VAR 0 2
2195: PUSH
2196: LD_STRING GammaBase
2198: PPUSH
2199: EMPTY
2200: PPUSH
2201: CALL_OW 30
2205: ST_TO_ADDR
// if not blist and debug then
2206: LD_VAR 0 2
2210: NOT
2211: PUSH
2212: LD_EXP 1
2216: AND
2217: IFFALSE 2257
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2219: LD_ADDR_VAR 0 2
2223: PUSH
2224: LD_INT 0
2226: PUSH
2227: LD_INT 51
2229: PUSH
2230: LD_INT 10
2232: PUSH
2233: LD_INT 3
2235: PUSH
2236: LD_INT 3
2238: PUSH
2239: LD_INT 0
2241: PUSH
2242: LD_INT 0
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: LIST
2252: LIST
2253: PUSH
2254: EMPTY
2255: LIST
2256: ST_TO_ADDR
// if not blist then
2257: LD_VAR 0 2
2261: NOT
2262: IFFALSE 2266
// exit ;
2264: GO 2446
// uc_side := 1 ;
2266: LD_ADDR_OWVAR 20
2270: PUSH
2271: LD_INT 1
2273: ST_TO_ADDR
// uc_nation := 1 ;
2274: LD_ADDR_OWVAR 21
2278: PUSH
2279: LD_INT 1
2281: ST_TO_ADDR
// for i in blist do
2282: LD_ADDR_VAR 0 3
2286: PUSH
2287: LD_VAR 0 2
2291: PUSH
2292: FOR_IN
2293: IFFALSE 2444
// begin bc_type := i [ 1 ] ;
2295: LD_ADDR_OWVAR 42
2299: PUSH
2300: LD_VAR 0 3
2304: PUSH
2305: LD_INT 1
2307: ARRAY
2308: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2309: LD_ADDR_OWVAR 43
2313: PUSH
2314: LD_VAR 0 3
2318: PUSH
2319: LD_INT 5
2321: ARRAY
2322: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2323: LD_VAR 0 3
2327: PUSH
2328: LD_INT 1
2330: ARRAY
2331: PUSH
2332: LD_INT 7
2334: PUSH
2335: LD_INT 8
2337: PUSH
2338: EMPTY
2339: LIST
2340: LIST
2341: IN
2342: IFFALSE 2372
// begin bc_kind1 := i [ 7 ] ;
2344: LD_ADDR_OWVAR 44
2348: PUSH
2349: LD_VAR 0 3
2353: PUSH
2354: LD_INT 7
2356: ARRAY
2357: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2358: LD_ADDR_OWVAR 45
2362: PUSH
2363: LD_VAR 0 3
2367: PUSH
2368: LD_INT 8
2370: ARRAY
2371: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2372: LD_ADDR_VAR 0 4
2376: PUSH
2377: LD_VAR 0 3
2381: PUSH
2382: LD_INT 2
2384: ARRAY
2385: PPUSH
2386: LD_VAR 0 3
2390: PUSH
2391: LD_INT 3
2393: ARRAY
2394: PPUSH
2395: LD_VAR 0 3
2399: PUSH
2400: LD_INT 4
2402: ARRAY
2403: PPUSH
2404: CALL_OW 47
2408: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2409: LD_VAR 0 4
2413: PPUSH
2414: CALL_OW 266
2418: PUSH
2419: LD_INT 32
2421: EQUAL
2422: IFFALSE 2442
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2424: LD_VAR 0 4
2428: PPUSH
2429: LD_VAR 0 3
2433: PUSH
2434: LD_INT 7
2436: ARRAY
2437: PPUSH
2438: CALL_OW 431
// end ; end ;
2442: GO 2292
2444: POP
2445: POP
// end ; end_of_file
2446: LD_VAR 0 1
2450: RET
// export function Action ; var points , i , sol , team , filter ; begin
2451: LD_INT 0
2453: PPUSH
2454: PPUSH
2455: PPUSH
2456: PPUSH
2457: PPUSH
2458: PPUSH
// InGameOn ;
2459: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2463: LD_INT 33
2465: PPUSH
2466: LD_INT 11
2468: PPUSH
2469: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2473: LD_ADDR_VAR 0 2
2477: PUSH
2478: LD_INT 29
2480: PUSH
2481: LD_INT 21
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: PUSH
2488: LD_INT 41
2490: PUSH
2491: LD_INT 28
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: PUSH
2498: LD_INT 52
2500: PUSH
2501: LD_INT 26
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: LD_INT 49
2510: PUSH
2511: LD_INT 16
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PUSH
2518: EMPTY
2519: LIST
2520: LIST
2521: LIST
2522: LIST
2523: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2524: LD_ADDR_VAR 0 4
2528: PUSH
2529: LD_INT 22
2531: PUSH
2532: LD_INT 1
2534: PUSH
2535: EMPTY
2536: LIST
2537: LIST
2538: PUSH
2539: LD_INT 26
2541: PUSH
2542: LD_INT 1
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PPUSH
2553: CALL_OW 69
2557: PUSH
2558: LD_EXP 7
2562: PUSH
2563: LD_EXP 14
2567: PUSH
2568: LD_EXP 11
2572: PUSH
2573: LD_EXP 12
2577: PUSH
2578: LD_EXP 8
2582: PUSH
2583: LD_EXP 15
2587: PUSH
2588: LD_EXP 16
2592: PUSH
2593: EMPTY
2594: LIST
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: LIST
2600: LIST
2601: DIFF
2602: PUSH
2603: LD_INT 1
2605: ARRAY
2606: ST_TO_ADDR
// if sol then
2607: LD_VAR 0 4
2611: IFFALSE 2642
// begin ComMoveXY ( sol , 50 , 18 ) ;
2613: LD_VAR 0 4
2617: PPUSH
2618: LD_INT 50
2620: PPUSH
2621: LD_INT 18
2623: PPUSH
2624: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2628: LD_VAR 0 4
2632: PPUSH
2633: LD_EXP 17
2637: PPUSH
2638: CALL_OW 179
// end ; for i in points do
2642: LD_ADDR_VAR 0 3
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: FOR_IN
2653: IFFALSE 2684
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2655: LD_EXP 17
2659: PPUSH
2660: LD_VAR 0 3
2664: PUSH
2665: LD_INT 1
2667: ARRAY
2668: PPUSH
2669: LD_VAR 0 3
2673: PUSH
2674: LD_INT 2
2676: ARRAY
2677: PPUSH
2678: CALL_OW 171
2682: GO 2652
2684: POP
2685: POP
// AddComExitVehicle ( Harisson ) ;
2686: LD_EXP 17
2690: PPUSH
2691: CALL_OW 181
// repeat wait ( 3 ) ;
2695: LD_INT 3
2697: PPUSH
2698: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2702: LD_EXP 17
2706: PPUSH
2707: CALL_OW 310
2711: NOT
2712: IFFALSE 2695
// Say ( sol , D1-Sol1-1 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_STRING D1-Sol1-1
2721: PPUSH
2722: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2726: LD_EXP 17
2730: PPUSH
2731: LD_VAR 0 4
2735: PPUSH
2736: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2740: LD_EXP 17
2744: PPUSH
2745: LD_STRING D1-Har-1
2747: PPUSH
2748: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2752: LD_INT 10
2754: PPUSH
2755: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 35
2766: PPUSH
2767: LD_INT 21
2769: PPUSH
2770: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2774: LD_EXP 7
2778: PPUSH
2779: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2783: LD_EXP 7
2787: PPUSH
2788: LD_EXP 17
2792: PPUSH
2793: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2797: LD_EXP 17
2801: PPUSH
2802: LD_EXP 7
2806: PPUSH
2807: CALL_OW 119
// repeat wait ( 3 ) ;
2811: LD_INT 3
2813: PPUSH
2814: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2818: LD_EXP 7
2822: PPUSH
2823: LD_EXP 17
2827: PPUSH
2828: CALL_OW 296
2832: PUSH
2833: LD_INT 4
2835: LESS
2836: IFFALSE 2811
// ComTurnUnit ( JMM , Harisson ) ;
2838: LD_EXP 7
2842: PPUSH
2843: LD_EXP 17
2847: PPUSH
2848: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2852: LD_EXP 7
2856: PPUSH
2857: LD_STRING D1-JMM-1
2859: PPUSH
2860: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2864: LD_EXP 17
2868: PPUSH
2869: LD_STRING D1-Har-2
2871: PPUSH
2872: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
2876: LD_EXP 7
2880: PPUSH
2881: LD_STRING D1-JMM-2
2883: PPUSH
2884: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
2888: LD_EXP 17
2892: PPUSH
2893: LD_STRING D1-Har-3
2895: PPUSH
2896: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2900: LD_EXP 7
2904: PPUSH
2905: LD_STRING D1-JMM-3
2907: PPUSH
2908: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
2912: LD_EXP 17
2916: PPUSH
2917: LD_STRING D1-Har-4
2919: PPUSH
2920: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
2924: LD_EXP 7
2928: PPUSH
2929: LD_STRING D1-JMM-4
2931: PPUSH
2932: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
2936: LD_EXP 17
2940: PPUSH
2941: LD_STRING D1-Har-5
2943: PPUSH
2944: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
2948: LD_EXP 7
2952: PPUSH
2953: LD_STRING D1-JMM-5
2955: PPUSH
2956: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
2960: LD_EXP 17
2964: PPUSH
2965: LD_STRING D1-Har-6
2967: PPUSH
2968: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
2972: LD_EXP 7
2976: PPUSH
2977: LD_STRING D1-JMM-6
2979: PPUSH
2980: CALL_OW 88
// EndMission ;
2984: CALL 2993 0 0
// end ;
2988: LD_VAR 0 1
2992: RET
// export function EndMission ; var commander , i , all ; begin
2993: LD_INT 0
2995: PPUSH
2996: PPUSH
2997: PPUSH
2998: PPUSH
// case gamma_commander of 1 :
2999: LD_EXP 18
3003: PUSH
3004: LD_INT 1
3006: DOUBLE
3007: EQUAL
3008: IFTRUE 3012
3010: GO 3025
3012: POP
// commander := Donaldson ; 2 :
3013: LD_ADDR_VAR 0 2
3017: PUSH
3018: LD_EXP 13
3022: ST_TO_ADDR
3023: GO 3068
3025: LD_INT 2
3027: DOUBLE
3028: EQUAL
3029: IFTRUE 3033
3031: GO 3046
3033: POP
// commander := Brown ; 3 :
3034: LD_ADDR_VAR 0 2
3038: PUSH
3039: LD_EXP 14
3043: ST_TO_ADDR
3044: GO 3068
3046: LD_INT 3
3048: DOUBLE
3049: EQUAL
3050: IFTRUE 3054
3052: GO 3067
3054: POP
// commander := Houten ; end ;
3055: LD_ADDR_VAR 0 2
3059: PUSH
3060: LD_EXP 15
3064: ST_TO_ADDR
3065: GO 3068
3067: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3068: LD_ADDR_VAR 0 4
3072: PUSH
3073: LD_INT 22
3075: PUSH
3076: LD_INT 1
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: PUSH
3083: LD_INT 21
3085: PUSH
3086: LD_INT 1
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: PPUSH
3097: CALL_OW 69
3101: PUSH
3102: LD_EXP 7
3106: PUSH
3107: LD_VAR 0 2
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: DIFF
3116: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3117: LD_ADDR_EXP 4
3121: PUSH
3122: LD_STRING 1
3124: PPUSH
3125: LD_INT 10
3127: PPUSH
3128: LD_INT 10
3130: PPUSH
3131: LD_INT -5
3133: PUSH
3134: LD_EXP 7
3138: PUSH
3139: LD_INT -2
3141: PUSH
3142: LD_INT -3
3144: PUSH
3145: LD_INT -5
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: PUSH
3155: LD_VAR 0 4
3159: ADD
3160: PUSH
3161: LD_INT -6
3163: PUSH
3164: LD_INT -4
3166: PUSH
3167: LD_VAR 0 2
3171: PUSH
3172: LD_EXP 17
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: ADD
3186: PPUSH
3187: LD_INT 1
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: PUSH
3197: LD_INT 3
3199: PUSH
3200: LD_INT 3
3202: PUSH
3203: LD_INT 6
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: LIST
3210: PUSH
3211: LD_INT 4
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PPUSH
3226: CALL_OW 42
3230: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3231: LD_VAR 0 4
3235: PUSH
3236: LD_EXP 7
3240: PUSH
3241: LD_EXP 8
3245: PUSH
3246: LD_EXP 10
3250: PUSH
3251: LD_EXP 11
3255: PUSH
3256: LD_EXP 12
3260: PUSH
3261: LD_EXP 9
3265: PUSH
3266: LD_EXP 13
3270: PUSH
3271: LD_EXP 14
3275: PUSH
3276: LD_EXP 15
3280: PUSH
3281: LD_EXP 17
3285: PUSH
3286: LD_EXP 16
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: PUSH
3304: LD_EXP 4
3308: ADD
3309: DIFF
3310: PPUSH
3311: LD_STRING 07_othersGamma
3313: PPUSH
3314: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3318: LD_EXP 4
3322: PUSH
3323: LD_EXP 7
3327: PUSH
3328: LD_EXP 8
3332: PUSH
3333: LD_EXP 10
3337: PUSH
3338: LD_EXP 11
3342: PUSH
3343: LD_EXP 12
3347: PUSH
3348: LD_EXP 9
3352: PUSH
3353: LD_EXP 13
3357: PUSH
3358: LD_EXP 14
3362: PUSH
3363: LD_EXP 15
3367: PUSH
3368: LD_EXP 17
3372: PUSH
3373: LD_EXP 16
3377: PUSH
3378: LD_INT 0
3380: PUSH
3381: EMPTY
3382: LIST
3383: LIST
3384: LIST
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: DIFF
3395: PPUSH
3396: LD_STRING 07_others
3398: PPUSH
3399: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3403: LD_EXP 7
3407: PPUSH
3408: LD_EXP 5
3412: PUSH
3413: LD_STRING JMM
3415: STR
3416: PPUSH
3417: CALL_OW 38
// if Lisa then
3421: LD_EXP 10
3425: IFFALSE 3467
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3427: LD_EXP 10
3431: PPUSH
3432: LD_EXP 5
3436: PUSH
3437: LD_STRING Lisa
3439: STR
3440: PPUSH
3441: CALL_OW 38
// if Lisa in save_group then
3445: LD_EXP 10
3449: PUSH
3450: LD_EXP 4
3454: IN
3455: IFFALSE 3467
// SaveVariable ( true , LisaIn07 ) ;
3457: LD_INT 1
3459: PPUSH
3460: LD_STRING LisaIn07
3462: PPUSH
3463: CALL_OW 39
// end ; if Bobby then
3467: LD_EXP 12
3471: IFFALSE 3513
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3473: LD_EXP 12
3477: PPUSH
3478: LD_EXP 5
3482: PUSH
3483: LD_STRING Bobby
3485: STR
3486: PPUSH
3487: CALL_OW 38
// if Bobby in save_group then
3491: LD_EXP 12
3495: PUSH
3496: LD_EXP 4
3500: IN
3501: IFFALSE 3513
// SaveVariable ( true , BobbyIn07 ) ;
3503: LD_INT 1
3505: PPUSH
3506: LD_STRING BobbyIn07
3508: PPUSH
3509: CALL_OW 39
// end ; if Cyrus then
3513: LD_EXP 11
3517: IFFALSE 3559
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3519: LD_EXP 11
3523: PPUSH
3524: LD_EXP 5
3528: PUSH
3529: LD_STRING Cyrus
3531: STR
3532: PPUSH
3533: CALL_OW 38
// if Cyrus in save_group then
3537: LD_EXP 11
3541: PUSH
3542: LD_EXP 4
3546: IN
3547: IFFALSE 3559
// SaveVariable ( true , CyrusIn07 ) ;
3549: LD_INT 1
3551: PPUSH
3552: LD_STRING CyrusIn07
3554: PPUSH
3555: CALL_OW 39
// end ; if Brown then
3559: LD_EXP 14
3563: IFFALSE 3605
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3565: LD_EXP 14
3569: PPUSH
3570: LD_EXP 5
3574: PUSH
3575: LD_STRING Brown
3577: STR
3578: PPUSH
3579: CALL_OW 38
// if Brown in save_group then
3583: LD_EXP 14
3587: PUSH
3588: LD_EXP 4
3592: IN
3593: IFFALSE 3605
// SaveVariable ( true , BrownIn07 ) ;
3595: LD_INT 1
3597: PPUSH
3598: LD_STRING BrownIn07
3600: PPUSH
3601: CALL_OW 39
// end ; if Donaldson then
3605: LD_EXP 13
3609: IFFALSE 3651
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3611: LD_EXP 13
3615: PPUSH
3616: LD_EXP 5
3620: PUSH
3621: LD_STRING Donaldson
3623: STR
3624: PPUSH
3625: CALL_OW 38
// if Donaldson in save_group then
3629: LD_EXP 13
3633: PUSH
3634: LD_EXP 4
3638: IN
3639: IFFALSE 3651
// SaveVariable ( true , DonaldsonIn07 ) ;
3641: LD_INT 1
3643: PPUSH
3644: LD_STRING DonaldsonIn07
3646: PPUSH
3647: CALL_OW 39
// end ; if Gladstone then
3651: LD_EXP 8
3655: IFFALSE 3697
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3657: LD_EXP 8
3661: PPUSH
3662: LD_EXP 5
3666: PUSH
3667: LD_STRING Gladstone
3669: STR
3670: PPUSH
3671: CALL_OW 38
// if Gladstone in save_group then
3675: LD_EXP 8
3679: PUSH
3680: LD_EXP 4
3684: IN
3685: IFFALSE 3697
// SaveVariable ( true , GladstoneIn07 ) ;
3687: LD_INT 1
3689: PPUSH
3690: LD_STRING GladstoneIn07
3692: PPUSH
3693: CALL_OW 39
// end ; if Khatam then
3697: LD_EXP 16
3701: IFFALSE 3743
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3703: LD_EXP 16
3707: PPUSH
3708: LD_EXP 5
3712: PUSH
3713: LD_STRING Khatam
3715: STR
3716: PPUSH
3717: CALL_OW 38
// if Khatam in save_group then
3721: LD_EXP 16
3725: PUSH
3726: LD_EXP 4
3730: IN
3731: IFFALSE 3743
// SaveVariable ( true , KhatamIn07 ) ;
3733: LD_INT 1
3735: PPUSH
3736: LD_STRING KhatamIn07
3738: PPUSH
3739: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3743: LD_INT 1
3745: PPUSH
3746: LD_STRING %_cont
3748: PPUSH
3749: CALL_OW 340
// end ; end_of_file
3753: LD_VAR 0 1
3757: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3758: LD_INT 0
3760: PPUSH
3761: PPUSH
// if exist_mode then
3762: LD_VAR 0 2
3766: IFFALSE 3791
// unit := CreateCharacter ( prefix & ident ) else
3768: LD_ADDR_VAR 0 5
3772: PUSH
3773: LD_VAR 0 3
3777: PUSH
3778: LD_VAR 0 1
3782: STR
3783: PPUSH
3784: CALL_OW 34
3788: ST_TO_ADDR
3789: GO 3806
// unit := NewCharacter ( ident ) ;
3791: LD_ADDR_VAR 0 5
3795: PUSH
3796: LD_VAR 0 1
3800: PPUSH
3801: CALL_OW 25
3805: ST_TO_ADDR
// result := unit ;
3806: LD_ADDR_VAR 0 4
3810: PUSH
3811: LD_VAR 0 5
3815: ST_TO_ADDR
// end ;
3816: LD_VAR 0 4
3820: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3821: LD_INT 0
3823: PPUSH
// uc_side := side ;
3824: LD_ADDR_OWVAR 20
3828: PUSH
3829: LD_VAR 0 1
3833: ST_TO_ADDR
// uc_nation := nation ;
3834: LD_ADDR_OWVAR 21
3838: PUSH
3839: LD_VAR 0 2
3843: ST_TO_ADDR
// vc_chassis := chassis ;
3844: LD_ADDR_OWVAR 37
3848: PUSH
3849: LD_VAR 0 3
3853: ST_TO_ADDR
// vc_engine := engine ;
3854: LD_ADDR_OWVAR 39
3858: PUSH
3859: LD_VAR 0 4
3863: ST_TO_ADDR
// vc_control := control ;
3864: LD_ADDR_OWVAR 38
3868: PUSH
3869: LD_VAR 0 5
3873: ST_TO_ADDR
// vc_weapon := weapon ;
3874: LD_ADDR_OWVAR 40
3878: PUSH
3879: LD_VAR 0 6
3883: ST_TO_ADDR
// vc_fuel_battery := fuel ;
3884: LD_ADDR_OWVAR 41
3888: PUSH
3889: LD_VAR 0 7
3893: ST_TO_ADDR
// result := CreateVehicle ;
3894: LD_ADDR_VAR 0 8
3898: PUSH
3899: CALL_OW 45
3903: ST_TO_ADDR
// end ;
3904: LD_VAR 0 8
3908: RET
// export function SayX ( units , ident ) ; var i ; begin
3909: LD_INT 0
3911: PPUSH
3912: PPUSH
// result := false ;
3913: LD_ADDR_VAR 0 3
3917: PUSH
3918: LD_INT 0
3920: ST_TO_ADDR
// if not units then
3921: LD_VAR 0 1
3925: NOT
3926: IFFALSE 3930
// exit ;
3928: GO 3984
// for i in units do
3930: LD_ADDR_VAR 0 4
3934: PUSH
3935: LD_VAR 0 1
3939: PUSH
3940: FOR_IN
3941: IFFALSE 3982
// if IsOk ( i ) then
3943: LD_VAR 0 4
3947: PPUSH
3948: CALL_OW 302
3952: IFFALSE 3980
// begin Say ( i , ident ) ;
3954: LD_VAR 0 4
3958: PPUSH
3959: LD_VAR 0 2
3963: PPUSH
3964: CALL_OW 88
// result := i ;
3968: LD_ADDR_VAR 0 3
3972: PUSH
3973: LD_VAR 0 4
3977: ST_TO_ADDR
// break ;
3978: GO 3982
// end ;
3980: GO 3940
3982: POP
3983: POP
// end ;
3984: LD_VAR 0 3
3988: RET
