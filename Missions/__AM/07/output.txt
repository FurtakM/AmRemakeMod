// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2617 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2338 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3924 0 3
 179: ST_TO_ADDR
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 180: LD_ADDR_EXP 18
 184: PUSH
 185: LD_STRING GammaCommander
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: CALL_OW 30
 195: ST_TO_ADDR
// if gamma_commander = 1 then
 196: LD_EXP 18
 200: PUSH
 201: LD_INT 1
 203: EQUAL
 204: IFFALSE 230
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 206: LD_ADDR_EXP 13
 210: PUSH
 211: LD_STRING Donaldson
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 04_
 222: PPUSH
 223: CALL 3924 0 3
 227: ST_TO_ADDR
// end else
 228: GO 301
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 230: LD_STRING DonaldsonIn06
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: IFFALSE 266
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 242: LD_ADDR_EXP 13
 246: PUSH
 247: LD_STRING Donaldson
 249: PPUSH
 250: LD_EXP 1
 254: NOT
 255: PPUSH
 256: LD_STRING 06c_
 258: PPUSH
 259: CALL 3924 0 3
 263: ST_TO_ADDR
 264: GO 301
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 266: LD_STRING DonaldsonStayInDelta
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: NOT
 277: IFFALSE 301
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 279: LD_ADDR_EXP 13
 283: PUSH
 284: LD_STRING Donaldson
 286: PPUSH
 287: LD_EXP 1
 291: NOT
 292: PPUSH
 293: LD_STRING 04_
 295: PPUSH
 296: CALL 3924 0 3
 300: ST_TO_ADDR
// end ; if Donaldson then
 301: LD_EXP 13
 305: IFFALSE 323
// team := team ^ Donaldson ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_EXP 13
 321: ADD
 322: ST_TO_ADDR
// if gamma_commander = 2 then
 323: LD_EXP 18
 327: PUSH
 328: LD_INT 2
 330: EQUAL
 331: IFFALSE 357
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 333: LD_ADDR_EXP 14
 337: PUSH
 338: LD_STRING Brown
 340: PPUSH
 341: LD_EXP 1
 345: NOT
 346: PPUSH
 347: LD_STRING 04_
 349: PPUSH
 350: CALL 3924 0 3
 354: ST_TO_ADDR
// end else
 355: GO 428
// begin if LoadVariable ( BrownIn06 , 0 ) then
 357: LD_STRING BrownIn06
 359: PPUSH
 360: LD_INT 0
 362: PPUSH
 363: CALL_OW 30
 367: IFFALSE 393
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 369: LD_ADDR_EXP 14
 373: PUSH
 374: LD_STRING Brown
 376: PPUSH
 377: LD_EXP 1
 381: NOT
 382: PPUSH
 383: LD_STRING 06c_
 385: PPUSH
 386: CALL 3924 0 3
 390: ST_TO_ADDR
 391: GO 428
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 393: LD_STRING BrownStayInDelta
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: CALL_OW 30
 403: NOT
 404: IFFALSE 428
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 406: LD_ADDR_EXP 14
 410: PUSH
 411: LD_STRING Brown
 413: PPUSH
 414: LD_EXP 1
 418: NOT
 419: PPUSH
 420: LD_STRING 04_
 422: PPUSH
 423: CALL 3924 0 3
 427: ST_TO_ADDR
// end ; if Brown then
 428: LD_EXP 14
 432: IFFALSE 450
// team := team ^ Brown ;
 434: LD_ADDR_VAR 0 6
 438: PUSH
 439: LD_VAR 0 6
 443: PUSH
 444: LD_EXP 14
 448: ADD
 449: ST_TO_ADDR
// if gamma_commander = 3 then
 450: LD_EXP 18
 454: PUSH
 455: LD_INT 3
 457: EQUAL
 458: IFFALSE 495
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 460: LD_ADDR_EXP 15
 464: PUSH
 465: LD_STRING VanHouten
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: LD_STRING 
 473: PPUSH
 474: CALL 3924 0 3
 478: ST_TO_ADDR
// team := team ^ Houten ;
 479: LD_ADDR_VAR 0 6
 483: PUSH
 484: LD_VAR 0 6
 488: PUSH
 489: LD_EXP 15
 493: ADD
 494: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 495: LD_STRING GladstoneIn06
 497: PPUSH
 498: LD_INT 0
 500: PPUSH
 501: CALL_OW 30
 505: IFFALSE 531
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 507: LD_ADDR_EXP 8
 511: PUSH
 512: LD_STRING Gladstone
 514: PPUSH
 515: LD_EXP 1
 519: NOT
 520: PPUSH
 521: LD_STRING 06c_
 523: PPUSH
 524: CALL 3924 0 3
 528: ST_TO_ADDR
 529: GO 565
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 531: LD_STRING GladstoneStayInDelta
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 30
 541: IFFALSE 565
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 543: LD_ADDR_EXP 8
 547: PUSH
 548: LD_STRING Gladstone
 550: PPUSH
 551: LD_EXP 1
 555: NOT
 556: PPUSH
 557: LD_STRING 06_
 559: PPUSH
 560: CALL 3924 0 3
 564: ST_TO_ADDR
// if Gladstone then
 565: LD_EXP 8
 569: IFFALSE 587
// team := team ^ Gladstone ;
 571: LD_ADDR_VAR 0 6
 575: PUSH
 576: LD_VAR 0 6
 580: PUSH
 581: LD_EXP 8
 585: ADD
 586: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 587: LD_ADDR_EXP 16
 591: PUSH
 592: LD_STRING Khatam
 594: PPUSH
 595: LD_EXP 1
 599: NOT
 600: PPUSH
 601: LD_STRING 03_
 603: PPUSH
 604: CALL 3924 0 3
 608: ST_TO_ADDR
// if Khatam then
 609: LD_EXP 16
 613: IFFALSE 631
// team := team ^ Khatam ;
 615: LD_ADDR_VAR 0 6
 619: PUSH
 620: LD_VAR 0 6
 624: PUSH
 625: LD_EXP 16
 629: ADD
 630: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
 631: LD_STRING FrankIn06
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 30
 641: IFFALSE 667
// Frank := PrepareUnit ( Frank , ( not debug ) , 06c_ ) else
 643: LD_ADDR_EXP 9
 647: PUSH
 648: LD_STRING Frank
 650: PPUSH
 651: LD_EXP 1
 655: NOT
 656: PPUSH
 657: LD_STRING 06c_
 659: PPUSH
 660: CALL 3924 0 3
 664: ST_TO_ADDR
 665: GO 725
// if LoadVariable ( FrankInDelta , 0 ) then
 667: LD_STRING FrankInDelta
 669: PPUSH
 670: LD_INT 0
 672: PPUSH
 673: CALL_OW 30
 677: IFFALSE 703
// Frank := PrepareUnit ( Frank , ( not debug ) , 05_ ) else
 679: LD_ADDR_EXP 9
 683: PUSH
 684: LD_STRING Frank
 686: PPUSH
 687: LD_EXP 1
 691: NOT
 692: PPUSH
 693: LD_STRING 05_
 695: PPUSH
 696: CALL 3924 0 3
 700: ST_TO_ADDR
 701: GO 725
// Frank := PrepareUnit ( Frank , ( not debug ) , 04_ ) ;
 703: LD_ADDR_EXP 9
 707: PUSH
 708: LD_STRING Frank
 710: PPUSH
 711: LD_EXP 1
 715: NOT
 716: PPUSH
 717: LD_STRING 04_
 719: PPUSH
 720: CALL 3924 0 3
 724: ST_TO_ADDR
// if Frank then
 725: LD_EXP 9
 729: IFFALSE 747
// team := team ^ Frank ;
 731: LD_ADDR_VAR 0 6
 735: PUSH
 736: LD_VAR 0 6
 740: PUSH
 741: LD_EXP 9
 745: ADD
 746: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 747: LD_STRING LisaIn06
 749: PPUSH
 750: LD_INT 0
 752: PPUSH
 753: CALL_OW 30
 757: IFFALSE 783
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 759: LD_ADDR_EXP 10
 763: PUSH
 764: LD_STRING Lisa
 766: PPUSH
 767: LD_EXP 1
 771: NOT
 772: PPUSH
 773: LD_STRING 06c_
 775: PPUSH
 776: CALL 3924 0 3
 780: ST_TO_ADDR
 781: GO 818
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 783: LD_STRING LisaStayInDelta
 785: PPUSH
 786: LD_INT 0
 788: PPUSH
 789: CALL_OW 30
 793: NOT
 794: IFFALSE 818
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 796: LD_ADDR_EXP 10
 800: PUSH
 801: LD_STRING Lisa
 803: PPUSH
 804: LD_EXP 1
 808: NOT
 809: PPUSH
 810: LD_STRING 04_
 812: PPUSH
 813: CALL 3924 0 3
 817: ST_TO_ADDR
// if Lisa then
 818: LD_EXP 10
 822: IFFALSE 840
// team := team ^ Lisa ;
 824: LD_ADDR_VAR 0 6
 828: PUSH
 829: LD_VAR 0 6
 833: PUSH
 834: LD_EXP 10
 838: ADD
 839: ST_TO_ADDR
// if not Lisa then
 840: LD_EXP 10
 844: NOT
 845: IFFALSE 1098
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 847: LD_STRING CyrusIn06
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 30
 857: IFFALSE 883
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 859: LD_ADDR_EXP 11
 863: PUSH
 864: LD_STRING Cyrus
 866: PPUSH
 867: LD_EXP 1
 871: NOT
 872: PPUSH
 873: LD_STRING 06c_
 875: PPUSH
 876: CALL 3924 0 3
 880: ST_TO_ADDR
 881: GO 947
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 883: LD_STRING CyrusStayInDelta
 885: PPUSH
 886: LD_INT 0
 888: PPUSH
 889: CALL_OW 30
 893: NOT
 894: IFFALSE 947
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 896: LD_ADDR_EXP 11
 900: PUSH
 901: LD_STRING Cyrus
 903: PPUSH
 904: LD_EXP 1
 908: NOT
 909: PPUSH
 910: LD_STRING 04_
 912: PPUSH
 913: CALL 3924 0 3
 917: ST_TO_ADDR
// if not Cyrus then
 918: LD_EXP 11
 922: NOT
 923: IFFALSE 947
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 925: LD_ADDR_EXP 11
 929: PUSH
 930: LD_STRING Cyrus
 932: PPUSH
 933: LD_EXP 1
 937: NOT
 938: PPUSH
 939: LD_STRING 03_
 941: PPUSH
 942: CALL 3924 0 3
 946: ST_TO_ADDR
// end ; if Cyrus then
 947: LD_EXP 11
 951: IFFALSE 969
// team := team ^ Cyrus ;
 953: LD_ADDR_VAR 0 6
 957: PUSH
 958: LD_VAR 0 6
 962: PUSH
 963: LD_EXP 11
 967: ADD
 968: ST_TO_ADDR
// if not Cyrus then
 969: LD_EXP 11
 973: NOT
 974: IFFALSE 1098
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 976: LD_STRING BobbyIn06
 978: PPUSH
 979: LD_INT 0
 981: PPUSH
 982: CALL_OW 30
 986: IFFALSE 1012
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 988: LD_ADDR_EXP 12
 992: PUSH
 993: LD_STRING Bobby
 995: PPUSH
 996: LD_EXP 1
1000: NOT
1001: PPUSH
1002: LD_STRING 06c_
1004: PPUSH
1005: CALL 3924 0 3
1009: ST_TO_ADDR
1010: GO 1076
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
1012: LD_STRING BobbyStayInDelta
1014: PPUSH
1015: LD_INT 0
1017: PPUSH
1018: CALL_OW 30
1022: NOT
1023: IFFALSE 1076
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
1025: LD_ADDR_EXP 12
1029: PUSH
1030: LD_STRING Bobby
1032: PPUSH
1033: LD_EXP 1
1037: NOT
1038: PPUSH
1039: LD_STRING 04_
1041: PPUSH
1042: CALL 3924 0 3
1046: ST_TO_ADDR
// if not Bobby then
1047: LD_EXP 12
1051: NOT
1052: IFFALSE 1076
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
1054: LD_ADDR_EXP 12
1058: PUSH
1059: LD_STRING Bobby
1061: PPUSH
1062: LD_EXP 1
1066: NOT
1067: PPUSH
1068: LD_STRING 03_
1070: PPUSH
1071: CALL 3924 0 3
1075: ST_TO_ADDR
// end ; if Bobby then
1076: LD_EXP 12
1080: IFFALSE 1098
// team := team ^ Bobby ;
1082: LD_ADDR_VAR 0 6
1086: PUSH
1087: LD_VAR 0 6
1091: PUSH
1092: LD_EXP 12
1096: ADD
1097: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1098: LD_ADDR_VAR 0 4
1102: PUSH
1103: LD_STRING othersGamma
1105: PPUSH
1106: CALL_OW 31
1110: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_STRING 06_other_survivors
1118: PPUSH
1119: CALL_OW 31
1123: ST_TO_ADDR
// others := others union others4 ;
1124: LD_ADDR_VAR 0 2
1128: PUSH
1129: LD_VAR 0 2
1133: PUSH
1134: LD_VAR 0 4
1138: UNION
1139: ST_TO_ADDR
// team := team ^ others ;
1140: LD_ADDR_VAR 0 6
1144: PUSH
1145: LD_VAR 0 6
1149: PUSH
1150: LD_VAR 0 2
1154: ADD
1155: ST_TO_ADDR
// for i in others do
1156: LD_ADDR_VAR 0 13
1160: PUSH
1161: LD_VAR 0 2
1165: PUSH
1166: FOR_IN
1167: IFFALSE 1235
// begin if GetClass ( i ) = 2 then
1169: LD_VAR 0 13
1173: PPUSH
1174: CALL_OW 257
1178: PUSH
1179: LD_INT 2
1181: EQUAL
1182: IFFALSE 1196
// SetClass ( i , 1 ) ;
1184: LD_VAR 0 13
1188: PPUSH
1189: LD_INT 1
1191: PPUSH
1192: CALL_OW 336
// for j = 1 to 4 do
1196: LD_ADDR_VAR 0 14
1200: PUSH
1201: DOUBLE
1202: LD_INT 1
1204: DEC
1205: ST_TO_ADDR
1206: LD_INT 4
1208: PUSH
1209: FOR_TO
1210: IFFALSE 1231
// AddExperience ( i , j , 3000 ) ;
1212: LD_VAR 0 13
1216: PPUSH
1217: LD_VAR 0 14
1221: PPUSH
1222: LD_INT 3000
1224: PPUSH
1225: CALL_OW 492
1229: GO 1209
1231: POP
1232: POP
// end ;
1233: GO 1166
1235: POP
1236: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1237: LD_ADDR_VAR 0 7
1241: PUSH
1242: LD_INT 30
1244: PUSH
1245: LD_INT 0
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: PPUSH
1252: CALL_OW 69
1256: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1257: LD_ADDR_VAR 0 8
1261: PUSH
1262: LD_INT 30
1264: PUSH
1265: LD_INT 4
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1277: LD_ADDR_VAR 0 9
1281: PUSH
1282: LD_INT 2
1284: PUSH
1285: LD_INT 30
1287: PUSH
1288: LD_INT 7
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 30
1297: PUSH
1298: LD_INT 6
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: LIST
1309: PPUSH
1310: CALL_OW 69
1314: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1315: LD_ADDR_VAR 0 10
1319: PUSH
1320: LD_INT 30
1322: PUSH
1323: LD_INT 3
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: PPUSH
1330: CALL_OW 69
1334: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1335: LD_ADDR_VAR 0 11
1339: PUSH
1340: LD_INT 2
1342: PUSH
1343: LD_INT 30
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 30
1355: PUSH
1356: LD_INT 31
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL_OW 69
1372: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1373: LD_VAR 0 7
1377: PPUSH
1378: LD_STRING Gamma
1380: PPUSH
1381: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1385: LD_VAR 0 7
1389: PPUSH
1390: CALL_OW 274
1394: PPUSH
1395: LD_INT 2
1397: PPUSH
1398: LD_INT 10000
1400: PPUSH
1401: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1405: LD_VAR 0 7
1409: PPUSH
1410: CALL_OW 274
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_INT 10000
1420: PPUSH
1421: CALL_OW 277
// if dep then
1425: LD_VAR 0 7
1429: IFFALSE 1529
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1431: LD_EXP 7
1435: PPUSH
1436: LD_VAR 0 7
1440: PUSH
1441: LD_INT 1
1443: ARRAY
1444: PPUSH
1445: CALL_OW 52
// if Brown then
1449: LD_EXP 14
1453: IFFALSE 1489
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1455: LD_EXP 14
1459: PPUSH
1460: LD_VAR 0 7
1464: PUSH
1465: LD_INT 1
1467: ARRAY
1468: PPUSH
1469: CALL_OW 52
// team := team diff Brown ;
1473: LD_ADDR_VAR 0 6
1477: PUSH
1478: LD_VAR 0 6
1482: PUSH
1483: LD_EXP 14
1487: DIFF
1488: ST_TO_ADDR
// end ; if Donaldson then
1489: LD_EXP 13
1493: IFFALSE 1529
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1495: LD_EXP 13
1499: PPUSH
1500: LD_VAR 0 7
1504: PUSH
1505: LD_INT 1
1507: ARRAY
1508: PPUSH
1509: CALL_OW 52
// team := team diff Donaldson ;
1513: LD_ADDR_VAR 0 6
1517: PUSH
1518: LD_VAR 0 6
1522: PUSH
1523: LD_EXP 13
1527: DIFF
1528: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1529: LD_VAR 0 11
1533: PUSH
1534: LD_VAR 0 6
1538: PPUSH
1539: LD_INT 25
1541: PUSH
1542: LD_INT 1
1544: PUSH
1545: EMPTY
1546: LIST
1547: LIST
1548: PPUSH
1549: CALL_OW 72
1553: AND
1554: IFFALSE 1663
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1556: LD_ADDR_VAR 0 12
1560: PUSH
1561: LD_VAR 0 6
1565: PPUSH
1566: LD_INT 25
1568: PUSH
1569: LD_INT 1
1571: PUSH
1572: EMPTY
1573: LIST
1574: LIST
1575: PPUSH
1576: CALL_OW 72
1580: ST_TO_ADDR
// for i in bun do
1581: LD_ADDR_VAR 0 13
1585: PUSH
1586: LD_VAR 0 11
1590: PUSH
1591: FOR_IN
1592: IFFALSE 1661
// begin if not filter then
1594: LD_VAR 0 12
1598: NOT
1599: IFFALSE 1603
// break ;
1601: GO 1661
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1603: LD_VAR 0 12
1607: PUSH
1608: LD_INT 1
1610: ARRAY
1611: PPUSH
1612: LD_VAR 0 13
1616: PPUSH
1617: CALL_OW 52
// team := team diff filter [ 1 ] ;
1621: LD_ADDR_VAR 0 6
1625: PUSH
1626: LD_VAR 0 6
1630: PUSH
1631: LD_VAR 0 12
1635: PUSH
1636: LD_INT 1
1638: ARRAY
1639: DIFF
1640: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1641: LD_ADDR_VAR 0 12
1645: PUSH
1646: LD_VAR 0 12
1650: PPUSH
1651: LD_INT 1
1653: PPUSH
1654: CALL_OW 3
1658: ST_TO_ADDR
// end ;
1659: GO 1591
1661: POP
1662: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1663: LD_VAR 0 8
1667: PUSH
1668: LD_VAR 0 6
1672: PPUSH
1673: LD_INT 25
1675: PUSH
1676: LD_INT 1
1678: PUSH
1679: EMPTY
1680: LIST
1681: LIST
1682: PPUSH
1683: CALL_OW 72
1687: AND
1688: IFFALSE 1810
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1690: LD_ADDR_VAR 0 12
1694: PUSH
1695: LD_VAR 0 6
1699: PPUSH
1700: LD_INT 25
1702: PUSH
1703: LD_INT 1
1705: PUSH
1706: EMPTY
1707: LIST
1708: LIST
1709: PPUSH
1710: CALL_OW 72
1714: ST_TO_ADDR
// for i = 1 to filter do
1715: LD_ADDR_VAR 0 13
1719: PUSH
1720: DOUBLE
1721: LD_INT 1
1723: DEC
1724: ST_TO_ADDR
1725: LD_VAR 0 12
1729: PUSH
1730: FOR_TO
1731: IFFALSE 1792
// begin if ( i <= 6 ) then
1733: LD_VAR 0 13
1737: PUSH
1738: LD_INT 6
1740: LESSEQUAL
1741: IFFALSE 1769
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1743: LD_VAR 0 12
1747: PUSH
1748: LD_VAR 0 13
1752: ARRAY
1753: PPUSH
1754: LD_VAR 0 8
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: CALL_OW 52
1767: GO 1790
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1769: LD_VAR 0 12
1773: PUSH
1774: LD_VAR 0 13
1778: ARRAY
1779: PPUSH
1780: LD_INT 1
1782: PPUSH
1783: LD_INT 0
1785: PPUSH
1786: CALL_OW 49
// end ;
1790: GO 1730
1792: POP
1793: POP
// team := team diff filter ;
1794: LD_ADDR_VAR 0 6
1798: PUSH
1799: LD_VAR 0 6
1803: PUSH
1804: LD_VAR 0 12
1808: DIFF
1809: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1810: LD_VAR 0 9
1814: PUSH
1815: LD_VAR 0 6
1819: PPUSH
1820: LD_INT 25
1822: PUSH
1823: LD_INT 4
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: PPUSH
1830: CALL_OW 72
1834: AND
1835: IFFALSE 1957
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1837: LD_ADDR_VAR 0 12
1841: PUSH
1842: LD_VAR 0 6
1846: PPUSH
1847: LD_INT 25
1849: PUSH
1850: LD_INT 4
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: PPUSH
1857: CALL_OW 72
1861: ST_TO_ADDR
// for i = 1 to filter do
1862: LD_ADDR_VAR 0 13
1866: PUSH
1867: DOUBLE
1868: LD_INT 1
1870: DEC
1871: ST_TO_ADDR
1872: LD_VAR 0 12
1876: PUSH
1877: FOR_TO
1878: IFFALSE 1939
// begin if ( i <= 6 ) then
1880: LD_VAR 0 13
1884: PUSH
1885: LD_INT 6
1887: LESSEQUAL
1888: IFFALSE 1916
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1890: LD_VAR 0 12
1894: PUSH
1895: LD_VAR 0 13
1899: ARRAY
1900: PPUSH
1901: LD_VAR 0 9
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: PPUSH
1910: CALL_OW 52
1914: GO 1937
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1916: LD_VAR 0 12
1920: PUSH
1921: LD_VAR 0 13
1925: ARRAY
1926: PPUSH
1927: LD_INT 1
1929: PPUSH
1930: LD_INT 0
1932: PPUSH
1933: CALL_OW 49
// end ;
1937: GO 1877
1939: POP
1940: POP
// team := team diff filter ;
1941: LD_ADDR_VAR 0 6
1945: PUSH
1946: LD_VAR 0 6
1950: PUSH
1951: LD_VAR 0 12
1955: DIFF
1956: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1957: LD_VAR 0 10
1961: PUSH
1962: LD_VAR 0 6
1966: PPUSH
1967: LD_INT 25
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: EMPTY
1974: LIST
1975: LIST
1976: PPUSH
1977: CALL_OW 72
1981: AND
1982: IFFALSE 2104
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1984: LD_ADDR_VAR 0 12
1988: PUSH
1989: LD_VAR 0 6
1993: PPUSH
1994: LD_INT 25
1996: PUSH
1997: LD_INT 3
1999: PUSH
2000: EMPTY
2001: LIST
2002: LIST
2003: PPUSH
2004: CALL_OW 72
2008: ST_TO_ADDR
// for i = 1 to filter do
2009: LD_ADDR_VAR 0 13
2013: PUSH
2014: DOUBLE
2015: LD_INT 1
2017: DEC
2018: ST_TO_ADDR
2019: LD_VAR 0 12
2023: PUSH
2024: FOR_TO
2025: IFFALSE 2086
// begin if ( i <= 6 ) then
2027: LD_VAR 0 13
2031: PUSH
2032: LD_INT 6
2034: LESSEQUAL
2035: IFFALSE 2063
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2037: LD_VAR 0 12
2041: PUSH
2042: LD_VAR 0 13
2046: ARRAY
2047: PPUSH
2048: LD_VAR 0 10
2052: PUSH
2053: LD_INT 1
2055: ARRAY
2056: PPUSH
2057: CALL_OW 52
2061: GO 2084
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2063: LD_VAR 0 12
2067: PUSH
2068: LD_VAR 0 13
2072: ARRAY
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_INT 0
2079: PPUSH
2080: CALL_OW 49
// end ;
2084: GO 2024
2086: POP
2087: POP
// team := team diff filter ;
2088: LD_ADDR_VAR 0 6
2092: PUSH
2093: LD_VAR 0 6
2097: PUSH
2098: LD_VAR 0 12
2102: DIFF
2103: ST_TO_ADDR
// end ; if team then
2104: LD_VAR 0 6
2108: IFFALSE 2151
// for i in team do
2110: LD_ADDR_VAR 0 13
2114: PUSH
2115: LD_VAR 0 6
2119: PUSH
2120: FOR_IN
2121: IFFALSE 2149
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2123: LD_VAR 0 13
2127: PPUSH
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 49
// ComHold ( i ) ;
2138: LD_VAR 0 13
2142: PPUSH
2143: CALL_OW 140
// end ;
2147: GO 2120
2149: POP
2150: POP
// if fac then
2151: LD_VAR 0 10
2155: IFFALSE 2191
// if UnitsInside ( fac [ 1 ] ) then
2157: LD_VAR 0 10
2161: PUSH
2162: LD_INT 1
2164: ARRAY
2165: PPUSH
2166: CALL_OW 313
2170: IFFALSE 2191
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2172: LD_VAR 0 10
2176: PUSH
2177: LD_INT 1
2179: ARRAY
2180: PPUSH
2181: LD_INT 10
2183: PPUSH
2184: LD_INT 0
2186: PPUSH
2187: CALL_OW 486
// if lab then
2191: LD_VAR 0 9
2195: IFFALSE 2231
// if UnitsInside ( lab [ 1 ] ) then
2197: LD_VAR 0 9
2201: PUSH
2202: LD_INT 1
2204: ARRAY
2205: PPUSH
2206: CALL_OW 313
2210: IFFALSE 2231
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2212: LD_VAR 0 9
2216: PUSH
2217: LD_INT 1
2219: ARRAY
2220: PPUSH
2221: LD_INT 10
2223: PPUSH
2224: LD_INT 0
2226: PPUSH
2227: CALL_OW 486
// uc_side := 4 ;
2231: LD_ADDR_OWVAR 20
2235: PUSH
2236: LD_INT 4
2238: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2239: LD_ADDR_EXP 17
2243: PUSH
2244: LD_STRING Harisson
2246: PPUSH
2247: LD_INT 0
2249: PPUSH
2250: LD_STRING 
2252: PPUSH
2253: CALL 3924 0 3
2257: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2258: LD_ADDR_VAR 0 5
2262: PUSH
2263: LD_INT 4
2265: PPUSH
2266: LD_INT 1
2268: PPUSH
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 1
2274: PPUSH
2275: LD_INT 1
2277: PPUSH
2278: LD_INT 2
2280: PPUSH
2281: LD_INT 100
2283: PPUSH
2284: CALL 3987 0 7
2288: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2289: LD_VAR 0 5
2293: PPUSH
2294: LD_INT 2
2296: PPUSH
2297: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2301: LD_VAR 0 5
2305: PPUSH
2306: LD_INT 21
2308: PPUSH
2309: LD_INT 8
2311: PPUSH
2312: LD_INT 0
2314: PPUSH
2315: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2319: LD_EXP 17
2323: PPUSH
2324: LD_VAR 0 5
2328: PPUSH
2329: CALL_OW 52
// end ;
2333: LD_VAR 0 1
2337: RET
// function PrepareBase ; var blist , i , b ; begin
2338: LD_INT 0
2340: PPUSH
2341: PPUSH
2342: PPUSH
2343: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2344: LD_INT 71
2346: PPUSH
2347: LD_INT 5
2349: PPUSH
2350: LD_INT 1
2352: PPUSH
2353: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2357: LD_ADDR_VAR 0 2
2361: PUSH
2362: LD_STRING GammaBase
2364: PPUSH
2365: EMPTY
2366: PPUSH
2367: CALL_OW 30
2371: ST_TO_ADDR
// if not blist and debug then
2372: LD_VAR 0 2
2376: NOT
2377: PUSH
2378: LD_EXP 1
2382: AND
2383: IFFALSE 2423
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2385: LD_ADDR_VAR 0 2
2389: PUSH
2390: LD_INT 0
2392: PUSH
2393: LD_INT 51
2395: PUSH
2396: LD_INT 10
2398: PUSH
2399: LD_INT 3
2401: PUSH
2402: LD_INT 3
2404: PUSH
2405: LD_INT 0
2407: PUSH
2408: LD_INT 0
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: LIST
2418: LIST
2419: PUSH
2420: EMPTY
2421: LIST
2422: ST_TO_ADDR
// if not blist then
2423: LD_VAR 0 2
2427: NOT
2428: IFFALSE 2432
// exit ;
2430: GO 2612
// uc_side := 1 ;
2432: LD_ADDR_OWVAR 20
2436: PUSH
2437: LD_INT 1
2439: ST_TO_ADDR
// uc_nation := 1 ;
2440: LD_ADDR_OWVAR 21
2444: PUSH
2445: LD_INT 1
2447: ST_TO_ADDR
// for i in blist do
2448: LD_ADDR_VAR 0 3
2452: PUSH
2453: LD_VAR 0 2
2457: PUSH
2458: FOR_IN
2459: IFFALSE 2610
// begin bc_type := i [ 1 ] ;
2461: LD_ADDR_OWVAR 42
2465: PUSH
2466: LD_VAR 0 3
2470: PUSH
2471: LD_INT 1
2473: ARRAY
2474: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2475: LD_ADDR_OWVAR 43
2479: PUSH
2480: LD_VAR 0 3
2484: PUSH
2485: LD_INT 5
2487: ARRAY
2488: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2489: LD_VAR 0 3
2493: PUSH
2494: LD_INT 1
2496: ARRAY
2497: PUSH
2498: LD_INT 7
2500: PUSH
2501: LD_INT 8
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: IN
2508: IFFALSE 2538
// begin bc_kind1 := i [ 7 ] ;
2510: LD_ADDR_OWVAR 44
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_INT 7
2522: ARRAY
2523: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2524: LD_ADDR_OWVAR 45
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_INT 8
2536: ARRAY
2537: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2538: LD_ADDR_VAR 0 4
2542: PUSH
2543: LD_VAR 0 3
2547: PUSH
2548: LD_INT 2
2550: ARRAY
2551: PPUSH
2552: LD_VAR 0 3
2556: PUSH
2557: LD_INT 3
2559: ARRAY
2560: PPUSH
2561: LD_VAR 0 3
2565: PUSH
2566: LD_INT 4
2568: ARRAY
2569: PPUSH
2570: CALL_OW 47
2574: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2575: LD_VAR 0 4
2579: PPUSH
2580: CALL_OW 266
2584: PUSH
2585: LD_INT 32
2587: EQUAL
2588: IFFALSE 2608
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2590: LD_VAR 0 4
2594: PPUSH
2595: LD_VAR 0 3
2599: PUSH
2600: LD_INT 7
2602: ARRAY
2603: PPUSH
2604: CALL_OW 431
// end ; end ;
2608: GO 2458
2610: POP
2611: POP
// end ; end_of_file
2612: LD_VAR 0 1
2616: RET
// export function Action ; var points , i , sol , team , filter ; begin
2617: LD_INT 0
2619: PPUSH
2620: PPUSH
2621: PPUSH
2622: PPUSH
2623: PPUSH
2624: PPUSH
// InGameOn ;
2625: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2629: LD_INT 33
2631: PPUSH
2632: LD_INT 11
2634: PPUSH
2635: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2639: LD_ADDR_VAR 0 2
2643: PUSH
2644: LD_INT 29
2646: PUSH
2647: LD_INT 21
2649: PUSH
2650: EMPTY
2651: LIST
2652: LIST
2653: PUSH
2654: LD_INT 41
2656: PUSH
2657: LD_INT 28
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: PUSH
2664: LD_INT 52
2666: PUSH
2667: LD_INT 26
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PUSH
2674: LD_INT 49
2676: PUSH
2677: LD_INT 16
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: LIST
2688: LIST
2689: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2690: LD_ADDR_VAR 0 4
2694: PUSH
2695: LD_INT 22
2697: PUSH
2698: LD_INT 1
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PUSH
2705: LD_INT 26
2707: PUSH
2708: LD_INT 1
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PPUSH
2719: CALL_OW 69
2723: PUSH
2724: LD_EXP 7
2728: PUSH
2729: LD_EXP 14
2733: PUSH
2734: LD_EXP 11
2738: PUSH
2739: LD_EXP 12
2743: PUSH
2744: LD_EXP 8
2748: PUSH
2749: LD_EXP 15
2753: PUSH
2754: LD_EXP 16
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: LIST
2764: LIST
2765: LIST
2766: LIST
2767: DIFF
2768: PUSH
2769: LD_INT 1
2771: ARRAY
2772: ST_TO_ADDR
// if sol then
2773: LD_VAR 0 4
2777: IFFALSE 2808
// begin ComMoveXY ( sol , 50 , 18 ) ;
2779: LD_VAR 0 4
2783: PPUSH
2784: LD_INT 50
2786: PPUSH
2787: LD_INT 18
2789: PPUSH
2790: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2794: LD_VAR 0 4
2798: PPUSH
2799: LD_EXP 17
2803: PPUSH
2804: CALL_OW 179
// end ; for i in points do
2808: LD_ADDR_VAR 0 3
2812: PUSH
2813: LD_VAR 0 2
2817: PUSH
2818: FOR_IN
2819: IFFALSE 2850
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2821: LD_EXP 17
2825: PPUSH
2826: LD_VAR 0 3
2830: PUSH
2831: LD_INT 1
2833: ARRAY
2834: PPUSH
2835: LD_VAR 0 3
2839: PUSH
2840: LD_INT 2
2842: ARRAY
2843: PPUSH
2844: CALL_OW 171
2848: GO 2818
2850: POP
2851: POP
// AddComExitVehicle ( Harisson ) ;
2852: LD_EXP 17
2856: PPUSH
2857: CALL_OW 181
// repeat wait ( 3 ) ;
2861: LD_INT 3
2863: PPUSH
2864: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2868: LD_EXP 17
2872: PPUSH
2873: CALL_OW 310
2877: NOT
2878: IFFALSE 2861
// Say ( sol , D1-Sol1-1 ) ;
2880: LD_VAR 0 4
2884: PPUSH
2885: LD_STRING D1-Sol1-1
2887: PPUSH
2888: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2892: LD_EXP 17
2896: PPUSH
2897: LD_VAR 0 4
2901: PPUSH
2902: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2906: LD_EXP 17
2910: PPUSH
2911: LD_STRING D1-Har-1
2913: PPUSH
2914: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2918: LD_INT 10
2920: PPUSH
2921: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2925: LD_VAR 0 4
2929: PPUSH
2930: LD_INT 35
2932: PPUSH
2933: LD_INT 21
2935: PPUSH
2936: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2940: LD_EXP 7
2944: PPUSH
2945: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2949: LD_EXP 7
2953: PPUSH
2954: LD_EXP 17
2958: PPUSH
2959: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2963: LD_EXP 17
2967: PPUSH
2968: LD_EXP 7
2972: PPUSH
2973: CALL_OW 119
// repeat wait ( 3 ) ;
2977: LD_INT 3
2979: PPUSH
2980: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2984: LD_EXP 7
2988: PPUSH
2989: LD_EXP 17
2993: PPUSH
2994: CALL_OW 296
2998: PUSH
2999: LD_INT 4
3001: LESS
3002: IFFALSE 2977
// ComTurnUnit ( JMM , Harisson ) ;
3004: LD_EXP 7
3008: PPUSH
3009: LD_EXP 17
3013: PPUSH
3014: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3018: LD_EXP 7
3022: PPUSH
3023: LD_STRING D1-JMM-1
3025: PPUSH
3026: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3030: LD_EXP 17
3034: PPUSH
3035: LD_STRING D1-Har-2
3037: PPUSH
3038: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3042: LD_EXP 7
3046: PPUSH
3047: LD_STRING D1-JMM-2
3049: PPUSH
3050: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3054: LD_EXP 17
3058: PPUSH
3059: LD_STRING D1-Har-3
3061: PPUSH
3062: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3066: LD_EXP 7
3070: PPUSH
3071: LD_STRING D1-JMM-3
3073: PPUSH
3074: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3078: LD_EXP 17
3082: PPUSH
3083: LD_STRING D1-Har-4
3085: PPUSH
3086: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3090: LD_EXP 7
3094: PPUSH
3095: LD_STRING D1-JMM-4
3097: PPUSH
3098: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3102: LD_EXP 17
3106: PPUSH
3107: LD_STRING D1-Har-5
3109: PPUSH
3110: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3114: LD_EXP 7
3118: PPUSH
3119: LD_STRING D1-JMM-5
3121: PPUSH
3122: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3126: LD_EXP 17
3130: PPUSH
3131: LD_STRING D1-Har-6
3133: PPUSH
3134: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3138: LD_EXP 7
3142: PPUSH
3143: LD_STRING D1-JMM-6
3145: PPUSH
3146: CALL_OW 88
// EndMission ;
3150: CALL 3159 0 0
// end ;
3154: LD_VAR 0 1
3158: RET
// export function EndMission ; var commander , i , all ; begin
3159: LD_INT 0
3161: PPUSH
3162: PPUSH
3163: PPUSH
3164: PPUSH
// case gamma_commander of 1 :
3165: LD_EXP 18
3169: PUSH
3170: LD_INT 1
3172: DOUBLE
3173: EQUAL
3174: IFTRUE 3178
3176: GO 3191
3178: POP
// commander := Donaldson ; 2 :
3179: LD_ADDR_VAR 0 2
3183: PUSH
3184: LD_EXP 13
3188: ST_TO_ADDR
3189: GO 3234
3191: LD_INT 2
3193: DOUBLE
3194: EQUAL
3195: IFTRUE 3199
3197: GO 3212
3199: POP
// commander := Brown ; 3 :
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: LD_EXP 14
3209: ST_TO_ADDR
3210: GO 3234
3212: LD_INT 3
3214: DOUBLE
3215: EQUAL
3216: IFTRUE 3220
3218: GO 3233
3220: POP
// commander := Houten ; end ;
3221: LD_ADDR_VAR 0 2
3225: PUSH
3226: LD_EXP 15
3230: ST_TO_ADDR
3231: GO 3234
3233: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 22
3241: PUSH
3242: LD_INT 1
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: PUSH
3249: LD_INT 21
3251: PUSH
3252: LD_INT 1
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: PPUSH
3263: CALL_OW 69
3267: PUSH
3268: LD_EXP 7
3272: PUSH
3273: LD_VAR 0 2
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: DIFF
3282: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3283: LD_ADDR_EXP 4
3287: PUSH
3288: LD_STRING 1
3290: PPUSH
3291: LD_INT 10
3293: PPUSH
3294: LD_INT 10
3296: PPUSH
3297: LD_INT -5
3299: PUSH
3300: LD_EXP 7
3304: PUSH
3305: LD_INT -2
3307: PUSH
3308: LD_INT -3
3310: PUSH
3311: LD_INT -5
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: PUSH
3321: LD_VAR 0 4
3325: ADD
3326: PUSH
3327: LD_INT -6
3329: PUSH
3330: LD_INT -4
3332: PUSH
3333: LD_VAR 0 2
3337: PUSH
3338: LD_EXP 17
3342: PUSH
3343: EMPTY
3344: LIST
3345: LIST
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: LIST
3351: ADD
3352: PPUSH
3353: LD_INT 1
3355: PUSH
3356: LD_INT 3
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: PUSH
3363: LD_INT 3
3365: PUSH
3366: LD_INT 3
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: LIST
3376: PUSH
3377: LD_INT 4
3379: PUSH
3380: LD_INT 1
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: PPUSH
3392: CALL_OW 42
3396: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3397: LD_VAR 0 4
3401: PUSH
3402: LD_EXP 7
3406: PUSH
3407: LD_EXP 8
3411: PUSH
3412: LD_EXP 10
3416: PUSH
3417: LD_EXP 11
3421: PUSH
3422: LD_EXP 12
3426: PUSH
3427: LD_EXP 9
3431: PUSH
3432: LD_EXP 13
3436: PUSH
3437: LD_EXP 14
3441: PUSH
3442: LD_EXP 15
3446: PUSH
3447: LD_EXP 17
3451: PUSH
3452: LD_EXP 16
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: LIST
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: LIST
3469: PUSH
3470: LD_EXP 4
3474: ADD
3475: DIFF
3476: PPUSH
3477: LD_STRING 07_othersGamma
3479: PPUSH
3480: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3484: LD_EXP 4
3488: PUSH
3489: LD_EXP 7
3493: PUSH
3494: LD_EXP 8
3498: PUSH
3499: LD_EXP 10
3503: PUSH
3504: LD_EXP 11
3508: PUSH
3509: LD_EXP 12
3513: PUSH
3514: LD_EXP 9
3518: PUSH
3519: LD_EXP 13
3523: PUSH
3524: LD_EXP 14
3528: PUSH
3529: LD_EXP 15
3533: PUSH
3534: LD_EXP 17
3538: PUSH
3539: LD_EXP 16
3543: PUSH
3544: LD_INT 0
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: LIST
3560: DIFF
3561: PPUSH
3562: LD_STRING 07_others
3564: PPUSH
3565: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3569: LD_EXP 7
3573: PPUSH
3574: LD_EXP 5
3578: PUSH
3579: LD_STRING JMM
3581: STR
3582: PPUSH
3583: CALL_OW 38
// if Lisa then
3587: LD_EXP 10
3591: IFFALSE 3633
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3593: LD_EXP 10
3597: PPUSH
3598: LD_EXP 5
3602: PUSH
3603: LD_STRING Lisa
3605: STR
3606: PPUSH
3607: CALL_OW 38
// if Lisa in save_group then
3611: LD_EXP 10
3615: PUSH
3616: LD_EXP 4
3620: IN
3621: IFFALSE 3633
// SaveVariable ( true , LisaIn07 ) ;
3623: LD_INT 1
3625: PPUSH
3626: LD_STRING LisaIn07
3628: PPUSH
3629: CALL_OW 39
// end ; if Bobby then
3633: LD_EXP 12
3637: IFFALSE 3679
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3639: LD_EXP 12
3643: PPUSH
3644: LD_EXP 5
3648: PUSH
3649: LD_STRING Bobby
3651: STR
3652: PPUSH
3653: CALL_OW 38
// if Bobby in save_group then
3657: LD_EXP 12
3661: PUSH
3662: LD_EXP 4
3666: IN
3667: IFFALSE 3679
// SaveVariable ( true , BobbyIn07 ) ;
3669: LD_INT 1
3671: PPUSH
3672: LD_STRING BobbyIn07
3674: PPUSH
3675: CALL_OW 39
// end ; if Cyrus then
3679: LD_EXP 11
3683: IFFALSE 3725
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3685: LD_EXP 11
3689: PPUSH
3690: LD_EXP 5
3694: PUSH
3695: LD_STRING Cyrus
3697: STR
3698: PPUSH
3699: CALL_OW 38
// if Cyrus in save_group then
3703: LD_EXP 11
3707: PUSH
3708: LD_EXP 4
3712: IN
3713: IFFALSE 3725
// SaveVariable ( true , CyrusIn07 ) ;
3715: LD_INT 1
3717: PPUSH
3718: LD_STRING CyrusIn07
3720: PPUSH
3721: CALL_OW 39
// end ; if Brown then
3725: LD_EXP 14
3729: IFFALSE 3771
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3731: LD_EXP 14
3735: PPUSH
3736: LD_EXP 5
3740: PUSH
3741: LD_STRING Brown
3743: STR
3744: PPUSH
3745: CALL_OW 38
// if Brown in save_group then
3749: LD_EXP 14
3753: PUSH
3754: LD_EXP 4
3758: IN
3759: IFFALSE 3771
// SaveVariable ( true , BrownIn07 ) ;
3761: LD_INT 1
3763: PPUSH
3764: LD_STRING BrownIn07
3766: PPUSH
3767: CALL_OW 39
// end ; if Donaldson then
3771: LD_EXP 13
3775: IFFALSE 3817
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3777: LD_EXP 13
3781: PPUSH
3782: LD_EXP 5
3786: PUSH
3787: LD_STRING Donaldson
3789: STR
3790: PPUSH
3791: CALL_OW 38
// if Donaldson in save_group then
3795: LD_EXP 13
3799: PUSH
3800: LD_EXP 4
3804: IN
3805: IFFALSE 3817
// SaveVariable ( true , DonaldsonIn07 ) ;
3807: LD_INT 1
3809: PPUSH
3810: LD_STRING DonaldsonIn07
3812: PPUSH
3813: CALL_OW 39
// end ; if Gladstone then
3817: LD_EXP 8
3821: IFFALSE 3863
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3823: LD_EXP 8
3827: PPUSH
3828: LD_EXP 5
3832: PUSH
3833: LD_STRING Gladstone
3835: STR
3836: PPUSH
3837: CALL_OW 38
// if Gladstone in save_group then
3841: LD_EXP 8
3845: PUSH
3846: LD_EXP 4
3850: IN
3851: IFFALSE 3863
// SaveVariable ( true , GladstoneIn07 ) ;
3853: LD_INT 1
3855: PPUSH
3856: LD_STRING GladstoneIn07
3858: PPUSH
3859: CALL_OW 39
// end ; if Khatam then
3863: LD_EXP 16
3867: IFFALSE 3909
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3869: LD_EXP 16
3873: PPUSH
3874: LD_EXP 5
3878: PUSH
3879: LD_STRING Khatam
3881: STR
3882: PPUSH
3883: CALL_OW 38
// if Khatam in save_group then
3887: LD_EXP 16
3891: PUSH
3892: LD_EXP 4
3896: IN
3897: IFFALSE 3909
// SaveVariable ( true , KhatamIn07 ) ;
3899: LD_INT 1
3901: PPUSH
3902: LD_STRING KhatamIn07
3904: PPUSH
3905: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3909: LD_INT 1
3911: PPUSH
3912: LD_STRING %_cont
3914: PPUSH
3915: CALL_OW 340
// end ; end_of_file
3919: LD_VAR 0 1
3923: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3924: LD_INT 0
3926: PPUSH
3927: PPUSH
// if exist_mode then
3928: LD_VAR 0 2
3932: IFFALSE 3957
// unit := CreateCharacter ( prefix & ident ) else
3934: LD_ADDR_VAR 0 5
3938: PUSH
3939: LD_VAR 0 3
3943: PUSH
3944: LD_VAR 0 1
3948: STR
3949: PPUSH
3950: CALL_OW 34
3954: ST_TO_ADDR
3955: GO 3972
// unit := NewCharacter ( ident ) ;
3957: LD_ADDR_VAR 0 5
3961: PUSH
3962: LD_VAR 0 1
3966: PPUSH
3967: CALL_OW 25
3971: ST_TO_ADDR
// result := unit ;
3972: LD_ADDR_VAR 0 4
3976: PUSH
3977: LD_VAR 0 5
3981: ST_TO_ADDR
// end ;
3982: LD_VAR 0 4
3986: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3987: LD_INT 0
3989: PPUSH
// uc_side := side ;
3990: LD_ADDR_OWVAR 20
3994: PUSH
3995: LD_VAR 0 1
3999: ST_TO_ADDR
// uc_nation := nation ;
4000: LD_ADDR_OWVAR 21
4004: PUSH
4005: LD_VAR 0 2
4009: ST_TO_ADDR
// vc_chassis := chassis ;
4010: LD_ADDR_OWVAR 37
4014: PUSH
4015: LD_VAR 0 3
4019: ST_TO_ADDR
// vc_engine := engine ;
4020: LD_ADDR_OWVAR 39
4024: PUSH
4025: LD_VAR 0 4
4029: ST_TO_ADDR
// vc_control := control ;
4030: LD_ADDR_OWVAR 38
4034: PUSH
4035: LD_VAR 0 5
4039: ST_TO_ADDR
// vc_weapon := weapon ;
4040: LD_ADDR_OWVAR 40
4044: PUSH
4045: LD_VAR 0 6
4049: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4050: LD_ADDR_OWVAR 41
4054: PUSH
4055: LD_VAR 0 7
4059: ST_TO_ADDR
// result := CreateVehicle ;
4060: LD_ADDR_VAR 0 8
4064: PUSH
4065: CALL_OW 45
4069: ST_TO_ADDR
// end ;
4070: LD_VAR 0 8
4074: RET
// export function SayX ( units , ident ) ; var i ; begin
4075: LD_INT 0
4077: PPUSH
4078: PPUSH
// result := false ;
4079: LD_ADDR_VAR 0 3
4083: PUSH
4084: LD_INT 0
4086: ST_TO_ADDR
// if not units then
4087: LD_VAR 0 1
4091: NOT
4092: IFFALSE 4096
// exit ;
4094: GO 4150
// for i in units do
4096: LD_ADDR_VAR 0 4
4100: PUSH
4101: LD_VAR 0 1
4105: PUSH
4106: FOR_IN
4107: IFFALSE 4148
// if IsOk ( i ) then
4109: LD_VAR 0 4
4113: PPUSH
4114: CALL_OW 302
4118: IFFALSE 4146
// begin Say ( i , ident ) ;
4120: LD_VAR 0 4
4124: PPUSH
4125: LD_VAR 0 2
4129: PPUSH
4130: CALL_OW 88
// result := i ;
4134: LD_ADDR_VAR 0 3
4138: PUSH
4139: LD_VAR 0 4
4143: ST_TO_ADDR
// break ;
4144: GO 4148
// end ;
4146: GO 4106
4148: POP
4149: POP
// end ;
4150: LD_VAR 0 3
4154: RET
