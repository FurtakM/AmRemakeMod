// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2672 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export RandGuy ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2408 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 4155 0 3
 179: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 180: LD_EXP 7
 184: PPUSH
 185: CALL_OW 257
 189: PUSH
 190: LD_INT 2
 192: EQUAL
 193: IFFALSE 207
// SetClass ( JMM , 1 ) ;
 195: LD_EXP 7
 199: PPUSH
 200: LD_INT 1
 202: PPUSH
 203: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 207: LD_ADDR_EXP 18
 211: PUSH
 212: LD_STRING GammaCommander
 214: PPUSH
 215: LD_INT 3
 217: PPUSH
 218: CALL_OW 30
 222: ST_TO_ADDR
// if gamma_commander = 1 then
 223: LD_EXP 18
 227: PUSH
 228: LD_INT 1
 230: EQUAL
 231: IFFALSE 257
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 233: LD_ADDR_EXP 13
 237: PUSH
 238: LD_STRING Donaldson
 240: PPUSH
 241: LD_EXP 1
 245: NOT
 246: PPUSH
 247: LD_STRING 04_
 249: PPUSH
 250: CALL 4155 0 3
 254: ST_TO_ADDR
// end else
 255: GO 328
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 257: LD_STRING DonaldsonIn06
 259: PPUSH
 260: LD_INT 0
 262: PPUSH
 263: CALL_OW 30
 267: IFFALSE 293
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 269: LD_ADDR_EXP 13
 273: PUSH
 274: LD_STRING Donaldson
 276: PPUSH
 277: LD_EXP 1
 281: NOT
 282: PPUSH
 283: LD_STRING 06c_
 285: PPUSH
 286: CALL 4155 0 3
 290: ST_TO_ADDR
 291: GO 328
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 293: LD_STRING DonaldsonStayInDelta
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: CALL_OW 30
 303: NOT
 304: IFFALSE 328
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 306: LD_ADDR_EXP 13
 310: PUSH
 311: LD_STRING Donaldson
 313: PPUSH
 314: LD_EXP 1
 318: NOT
 319: PPUSH
 320: LD_STRING 04_
 322: PPUSH
 323: CALL 4155 0 3
 327: ST_TO_ADDR
// end ; if Donaldson then
 328: LD_EXP 13
 332: IFFALSE 350
// team := team ^ Donaldson ;
 334: LD_ADDR_VAR 0 6
 338: PUSH
 339: LD_VAR 0 6
 343: PUSH
 344: LD_EXP 13
 348: ADD
 349: ST_TO_ADDR
// if gamma_commander = 2 then
 350: LD_EXP 18
 354: PUSH
 355: LD_INT 2
 357: EQUAL
 358: IFFALSE 384
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 360: LD_ADDR_EXP 14
 364: PUSH
 365: LD_STRING Brown
 367: PPUSH
 368: LD_EXP 1
 372: NOT
 373: PPUSH
 374: LD_STRING 04_
 376: PPUSH
 377: CALL 4155 0 3
 381: ST_TO_ADDR
// end else
 382: GO 455
// begin if LoadVariable ( BrownIn06 , 0 ) then
 384: LD_STRING BrownIn06
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 30
 394: IFFALSE 420
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 396: LD_ADDR_EXP 14
 400: PUSH
 401: LD_STRING Brown
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: LD_STRING 06c_
 412: PPUSH
 413: CALL 4155 0 3
 417: ST_TO_ADDR
 418: GO 455
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 420: LD_STRING BrownStayInDelta
 422: PPUSH
 423: LD_INT 0
 425: PPUSH
 426: CALL_OW 30
 430: NOT
 431: IFFALSE 455
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 433: LD_ADDR_EXP 14
 437: PUSH
 438: LD_STRING Brown
 440: PPUSH
 441: LD_EXP 1
 445: NOT
 446: PPUSH
 447: LD_STRING 04_
 449: PPUSH
 450: CALL 4155 0 3
 454: ST_TO_ADDR
// end ; if Brown then
 455: LD_EXP 14
 459: IFFALSE 477
// team := team ^ Brown ;
 461: LD_ADDR_VAR 0 6
 465: PUSH
 466: LD_VAR 0 6
 470: PUSH
 471: LD_EXP 14
 475: ADD
 476: ST_TO_ADDR
// if gamma_commander = 3 then
 477: LD_EXP 18
 481: PUSH
 482: LD_INT 3
 484: EQUAL
 485: IFFALSE 522
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 487: LD_ADDR_EXP 15
 491: PUSH
 492: LD_STRING VanHouten
 494: PPUSH
 495: LD_INT 0
 497: PPUSH
 498: LD_STRING 
 500: PPUSH
 501: CALL 4155 0 3
 505: ST_TO_ADDR
// team := team ^ Houten ;
 506: LD_ADDR_VAR 0 6
 510: PUSH
 511: LD_VAR 0 6
 515: PUSH
 516: LD_EXP 15
 520: ADD
 521: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 522: LD_STRING GladstoneIn06
 524: PPUSH
 525: LD_INT 0
 527: PPUSH
 528: CALL_OW 30
 532: IFFALSE 558
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 534: LD_ADDR_EXP 8
 538: PUSH
 539: LD_STRING Gladstone
 541: PPUSH
 542: LD_EXP 1
 546: NOT
 547: PPUSH
 548: LD_STRING 06c_
 550: PPUSH
 551: CALL 4155 0 3
 555: ST_TO_ADDR
 556: GO 592
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 558: LD_STRING GladstoneStayInDelta
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 30
 568: IFFALSE 592
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 570: LD_ADDR_EXP 8
 574: PUSH
 575: LD_STRING Gladstone
 577: PPUSH
 578: LD_EXP 1
 582: NOT
 583: PPUSH
 584: LD_STRING 06_
 586: PPUSH
 587: CALL 4155 0 3
 591: ST_TO_ADDR
// if Gladstone then
 592: LD_EXP 8
 596: IFFALSE 614
// team := team ^ Gladstone ;
 598: LD_ADDR_VAR 0 6
 602: PUSH
 603: LD_VAR 0 6
 607: PUSH
 608: LD_EXP 8
 612: ADD
 613: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 614: LD_ADDR_EXP 16
 618: PUSH
 619: LD_STRING Khatam
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 03_
 630: PPUSH
 631: CALL 4155 0 3
 635: ST_TO_ADDR
// if Khatam then
 636: LD_EXP 16
 640: IFFALSE 658
// team := team ^ Khatam ;
 642: LD_ADDR_VAR 0 6
 646: PUSH
 647: LD_VAR 0 6
 651: PUSH
 652: LD_EXP 16
 656: ADD
 657: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 658: LD_STRING LisaIn06
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 30
 668: IFFALSE 694
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 670: LD_ADDR_EXP 10
 674: PUSH
 675: LD_STRING Lisa
 677: PPUSH
 678: LD_EXP 1
 682: NOT
 683: PPUSH
 684: LD_STRING 06c_
 686: PPUSH
 687: CALL 4155 0 3
 691: ST_TO_ADDR
 692: GO 729
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 694: LD_STRING LisaStayInDelta
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: CALL_OW 30
 704: NOT
 705: IFFALSE 729
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 707: LD_ADDR_EXP 10
 711: PUSH
 712: LD_STRING Lisa
 714: PPUSH
 715: LD_EXP 1
 719: NOT
 720: PPUSH
 721: LD_STRING 04_
 723: PPUSH
 724: CALL 4155 0 3
 728: ST_TO_ADDR
// if Lisa then
 729: LD_EXP 10
 733: IFFALSE 751
// team := team ^ Lisa ;
 735: LD_ADDR_VAR 0 6
 739: PUSH
 740: LD_VAR 0 6
 744: PUSH
 745: LD_EXP 10
 749: ADD
 750: ST_TO_ADDR
// if not Lisa then
 751: LD_EXP 10
 755: NOT
 756: IFFALSE 1009
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 758: LD_STRING CyrusIn06
 760: PPUSH
 761: LD_INT 0
 763: PPUSH
 764: CALL_OW 30
 768: IFFALSE 794
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 770: LD_ADDR_EXP 11
 774: PUSH
 775: LD_STRING Cyrus
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 06c_
 786: PPUSH
 787: CALL 4155 0 3
 791: ST_TO_ADDR
 792: GO 858
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 794: LD_STRING CyrusStayInDelta
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 30
 804: NOT
 805: IFFALSE 858
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 807: LD_ADDR_EXP 11
 811: PUSH
 812: LD_STRING Cyrus
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 04_
 823: PPUSH
 824: CALL 4155 0 3
 828: ST_TO_ADDR
// if not Cyrus then
 829: LD_EXP 11
 833: NOT
 834: IFFALSE 858
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 836: LD_ADDR_EXP 11
 840: PUSH
 841: LD_STRING Cyrus
 843: PPUSH
 844: LD_EXP 1
 848: NOT
 849: PPUSH
 850: LD_STRING 03_
 852: PPUSH
 853: CALL 4155 0 3
 857: ST_TO_ADDR
// end ; if Cyrus then
 858: LD_EXP 11
 862: IFFALSE 880
// team := team ^ Cyrus ;
 864: LD_ADDR_VAR 0 6
 868: PUSH
 869: LD_VAR 0 6
 873: PUSH
 874: LD_EXP 11
 878: ADD
 879: ST_TO_ADDR
// if not Cyrus then
 880: LD_EXP 11
 884: NOT
 885: IFFALSE 1009
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 887: LD_STRING BobbyIn06
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 30
 897: IFFALSE 923
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 899: LD_ADDR_EXP 12
 903: PUSH
 904: LD_STRING Bobby
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 06c_
 915: PPUSH
 916: CALL 4155 0 3
 920: ST_TO_ADDR
 921: GO 987
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 923: LD_STRING BobbyStayInDelta
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: NOT
 934: IFFALSE 987
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 936: LD_ADDR_EXP 12
 940: PUSH
 941: LD_STRING Bobby
 943: PPUSH
 944: LD_EXP 1
 948: NOT
 949: PPUSH
 950: LD_STRING 04_
 952: PPUSH
 953: CALL 4155 0 3
 957: ST_TO_ADDR
// if not Bobby then
 958: LD_EXP 12
 962: NOT
 963: IFFALSE 987
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 965: LD_ADDR_EXP 12
 969: PUSH
 970: LD_STRING Bobby
 972: PPUSH
 973: LD_EXP 1
 977: NOT
 978: PPUSH
 979: LD_STRING 03_
 981: PPUSH
 982: CALL 4155 0 3
 986: ST_TO_ADDR
// end ; if Bobby then
 987: LD_EXP 12
 991: IFFALSE 1009
// team := team ^ Bobby ;
 993: LD_ADDR_VAR 0 6
 997: PUSH
 998: LD_VAR 0 6
1002: PUSH
1003: LD_EXP 12
1007: ADD
1008: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1009: LD_ADDR_VAR 0 4
1013: PUSH
1014: LD_STRING othersGamma
1016: PPUSH
1017: CALL_OW 31
1021: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_STRING 06_other_survivors
1029: PPUSH
1030: CALL_OW 31
1034: ST_TO_ADDR
// others := others union others4 ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_VAR 0 4
1049: UNION
1050: ST_TO_ADDR
// team := team ^ others ;
1051: LD_ADDR_VAR 0 6
1055: PUSH
1056: LD_VAR 0 6
1060: PUSH
1061: LD_VAR 0 2
1065: ADD
1066: ST_TO_ADDR
// InitHc ;
1067: CALL_OW 19
// if team <= 12 then
1071: LD_VAR 0 6
1075: PUSH
1076: LD_INT 12
1078: LESSEQUAL
1079: IFFALSE 1128
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1081: LD_INT 0
1083: PPUSH
1084: LD_INT 1
1086: PPUSH
1087: LD_INT 4
1089: PPUSH
1090: CALL_OW 12
1094: PPUSH
1095: LD_INT 5
1097: PPUSH
1098: CALL_OW 380
// team := team ^ CreateHuman ;
1102: LD_ADDR_VAR 0 6
1106: PUSH
1107: LD_VAR 0 6
1111: PUSH
1112: CALL_OW 44
1116: ADD
1117: ST_TO_ADDR
// until team > 12 ;
1118: LD_VAR 0 6
1122: PUSH
1123: LD_INT 12
1125: GREATER
1126: IFFALSE 1081
// for i in others do
1128: LD_ADDR_VAR 0 13
1132: PUSH
1133: LD_VAR 0 2
1137: PUSH
1138: FOR_IN
1139: IFFALSE 1207
// begin if GetClass ( i ) = 2 then
1141: LD_VAR 0 13
1145: PPUSH
1146: CALL_OW 257
1150: PUSH
1151: LD_INT 2
1153: EQUAL
1154: IFFALSE 1168
// SetClass ( i , 1 ) ;
1156: LD_VAR 0 13
1160: PPUSH
1161: LD_INT 1
1163: PPUSH
1164: CALL_OW 336
// for j = 1 to 4 do
1168: LD_ADDR_VAR 0 14
1172: PUSH
1173: DOUBLE
1174: LD_INT 1
1176: DEC
1177: ST_TO_ADDR
1178: LD_INT 4
1180: PUSH
1181: FOR_TO
1182: IFFALSE 1203
// AddExperience ( i , j , 3000 ) ;
1184: LD_VAR 0 13
1188: PPUSH
1189: LD_VAR 0 14
1193: PPUSH
1194: LD_INT 3000
1196: PPUSH
1197: CALL_OW 492
1201: GO 1181
1203: POP
1204: POP
// end ;
1205: GO 1138
1207: POP
1208: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1209: LD_ADDR_VAR 0 7
1213: PUSH
1214: LD_INT 30
1216: PUSH
1217: LD_INT 0
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: PPUSH
1224: CALL_OW 69
1228: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1229: LD_ADDR_VAR 0 8
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 4
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: PPUSH
1244: CALL_OW 69
1248: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1249: LD_ADDR_VAR 0 9
1253: PUSH
1254: LD_INT 2
1256: PUSH
1257: LD_INT 30
1259: PUSH
1260: LD_INT 7
1262: PUSH
1263: EMPTY
1264: LIST
1265: LIST
1266: PUSH
1267: LD_INT 30
1269: PUSH
1270: LD_INT 6
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: EMPTY
1278: LIST
1279: LIST
1280: LIST
1281: PPUSH
1282: CALL_OW 69
1286: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1287: LD_ADDR_VAR 0 10
1291: PUSH
1292: LD_INT 30
1294: PUSH
1295: LD_INT 3
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: PPUSH
1302: CALL_OW 69
1306: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1307: LD_ADDR_VAR 0 11
1311: PUSH
1312: LD_INT 2
1314: PUSH
1315: LD_INT 30
1317: PUSH
1318: LD_INT 32
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 30
1327: PUSH
1328: LD_INT 31
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: PUSH
1335: EMPTY
1336: LIST
1337: LIST
1338: LIST
1339: PPUSH
1340: CALL_OW 69
1344: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1345: LD_VAR 0 7
1349: PPUSH
1350: LD_STRING Gamma
1352: PPUSH
1353: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1357: LD_VAR 0 7
1361: PPUSH
1362: CALL_OW 274
1366: PPUSH
1367: LD_INT 2
1369: PPUSH
1370: LD_INT 10000
1372: PPUSH
1373: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1377: LD_VAR 0 7
1381: PPUSH
1382: CALL_OW 274
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_INT 10000
1392: PPUSH
1393: CALL_OW 277
// if dep then
1397: LD_VAR 0 7
1401: IFFALSE 1501
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1403: LD_EXP 7
1407: PPUSH
1408: LD_VAR 0 7
1412: PUSH
1413: LD_INT 1
1415: ARRAY
1416: PPUSH
1417: CALL_OW 52
// if Brown then
1421: LD_EXP 14
1425: IFFALSE 1461
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1427: LD_EXP 14
1431: PPUSH
1432: LD_VAR 0 7
1436: PUSH
1437: LD_INT 1
1439: ARRAY
1440: PPUSH
1441: CALL_OW 52
// team := team diff Brown ;
1445: LD_ADDR_VAR 0 6
1449: PUSH
1450: LD_VAR 0 6
1454: PUSH
1455: LD_EXP 14
1459: DIFF
1460: ST_TO_ADDR
// end ; if Donaldson then
1461: LD_EXP 13
1465: IFFALSE 1501
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1467: LD_EXP 13
1471: PPUSH
1472: LD_VAR 0 7
1476: PUSH
1477: LD_INT 1
1479: ARRAY
1480: PPUSH
1481: CALL_OW 52
// team := team diff Donaldson ;
1485: LD_ADDR_VAR 0 6
1489: PUSH
1490: LD_VAR 0 6
1494: PUSH
1495: LD_EXP 13
1499: DIFF
1500: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1501: LD_VAR 0 11
1505: PUSH
1506: LD_VAR 0 6
1510: PPUSH
1511: LD_INT 25
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: PPUSH
1521: CALL_OW 72
1525: AND
1526: IFFALSE 1635
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1528: LD_ADDR_VAR 0 12
1532: PUSH
1533: LD_VAR 0 6
1537: PPUSH
1538: LD_INT 25
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: PPUSH
1548: CALL_OW 72
1552: ST_TO_ADDR
// for i in bun do
1553: LD_ADDR_VAR 0 13
1557: PUSH
1558: LD_VAR 0 11
1562: PUSH
1563: FOR_IN
1564: IFFALSE 1633
// begin if not filter then
1566: LD_VAR 0 12
1570: NOT
1571: IFFALSE 1575
// break ;
1573: GO 1633
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1575: LD_VAR 0 12
1579: PUSH
1580: LD_INT 1
1582: ARRAY
1583: PPUSH
1584: LD_VAR 0 13
1588: PPUSH
1589: CALL_OW 52
// team := team diff filter [ 1 ] ;
1593: LD_ADDR_VAR 0 6
1597: PUSH
1598: LD_VAR 0 6
1602: PUSH
1603: LD_VAR 0 12
1607: PUSH
1608: LD_INT 1
1610: ARRAY
1611: DIFF
1612: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1613: LD_ADDR_VAR 0 12
1617: PUSH
1618: LD_VAR 0 12
1622: PPUSH
1623: LD_INT 1
1625: PPUSH
1626: CALL_OW 3
1630: ST_TO_ADDR
// end ;
1631: GO 1563
1633: POP
1634: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1635: LD_VAR 0 8
1639: PUSH
1640: LD_VAR 0 6
1644: PPUSH
1645: LD_INT 25
1647: PUSH
1648: LD_INT 1
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: PPUSH
1655: CALL_OW 72
1659: AND
1660: IFFALSE 1782
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1662: LD_ADDR_VAR 0 12
1666: PUSH
1667: LD_VAR 0 6
1671: PPUSH
1672: LD_INT 25
1674: PUSH
1675: LD_INT 1
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: PPUSH
1682: CALL_OW 72
1686: ST_TO_ADDR
// for i = 1 to filter do
1687: LD_ADDR_VAR 0 13
1691: PUSH
1692: DOUBLE
1693: LD_INT 1
1695: DEC
1696: ST_TO_ADDR
1697: LD_VAR 0 12
1701: PUSH
1702: FOR_TO
1703: IFFALSE 1764
// begin if ( i <= 6 ) then
1705: LD_VAR 0 13
1709: PUSH
1710: LD_INT 6
1712: LESSEQUAL
1713: IFFALSE 1741
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1715: LD_VAR 0 12
1719: PUSH
1720: LD_VAR 0 13
1724: ARRAY
1725: PPUSH
1726: LD_VAR 0 8
1730: PUSH
1731: LD_INT 1
1733: ARRAY
1734: PPUSH
1735: CALL_OW 52
1739: GO 1762
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1741: LD_VAR 0 12
1745: PUSH
1746: LD_VAR 0 13
1750: ARRAY
1751: PPUSH
1752: LD_INT 1
1754: PPUSH
1755: LD_INT 0
1757: PPUSH
1758: CALL_OW 49
// end ;
1762: GO 1702
1764: POP
1765: POP
// team := team diff filter ;
1766: LD_ADDR_VAR 0 6
1770: PUSH
1771: LD_VAR 0 6
1775: PUSH
1776: LD_VAR 0 12
1780: DIFF
1781: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1782: LD_VAR 0 9
1786: PUSH
1787: LD_VAR 0 6
1791: PPUSH
1792: LD_INT 25
1794: PUSH
1795: LD_INT 4
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: PPUSH
1802: CALL_OW 72
1806: AND
1807: IFFALSE 1929
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1809: LD_ADDR_VAR 0 12
1813: PUSH
1814: LD_VAR 0 6
1818: PPUSH
1819: LD_INT 25
1821: PUSH
1822: LD_INT 4
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: PPUSH
1829: CALL_OW 72
1833: ST_TO_ADDR
// for i = 1 to filter do
1834: LD_ADDR_VAR 0 13
1838: PUSH
1839: DOUBLE
1840: LD_INT 1
1842: DEC
1843: ST_TO_ADDR
1844: LD_VAR 0 12
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1911
// begin if ( i <= 6 ) then
1852: LD_VAR 0 13
1856: PUSH
1857: LD_INT 6
1859: LESSEQUAL
1860: IFFALSE 1888
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1862: LD_VAR 0 12
1866: PUSH
1867: LD_VAR 0 13
1871: ARRAY
1872: PPUSH
1873: LD_VAR 0 9
1877: PUSH
1878: LD_INT 1
1880: ARRAY
1881: PPUSH
1882: CALL_OW 52
1886: GO 1909
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1888: LD_VAR 0 12
1892: PUSH
1893: LD_VAR 0 13
1897: ARRAY
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 49
// end ;
1909: GO 1849
1911: POP
1912: POP
// team := team diff filter ;
1913: LD_ADDR_VAR 0 6
1917: PUSH
1918: LD_VAR 0 6
1922: PUSH
1923: LD_VAR 0 12
1927: DIFF
1928: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1929: LD_VAR 0 10
1933: PUSH
1934: LD_VAR 0 6
1938: PPUSH
1939: LD_INT 25
1941: PUSH
1942: LD_INT 3
1944: PUSH
1945: EMPTY
1946: LIST
1947: LIST
1948: PPUSH
1949: CALL_OW 72
1953: AND
1954: IFFALSE 2076
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1956: LD_ADDR_VAR 0 12
1960: PUSH
1961: LD_VAR 0 6
1965: PPUSH
1966: LD_INT 25
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: PPUSH
1976: CALL_OW 72
1980: ST_TO_ADDR
// for i = 1 to filter do
1981: LD_ADDR_VAR 0 13
1985: PUSH
1986: DOUBLE
1987: LD_INT 1
1989: DEC
1990: ST_TO_ADDR
1991: LD_VAR 0 12
1995: PUSH
1996: FOR_TO
1997: IFFALSE 2058
// begin if ( i <= 6 ) then
1999: LD_VAR 0 13
2003: PUSH
2004: LD_INT 6
2006: LESSEQUAL
2007: IFFALSE 2035
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2009: LD_VAR 0 12
2013: PUSH
2014: LD_VAR 0 13
2018: ARRAY
2019: PPUSH
2020: LD_VAR 0 10
2024: PUSH
2025: LD_INT 1
2027: ARRAY
2028: PPUSH
2029: CALL_OW 52
2033: GO 2056
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2035: LD_VAR 0 12
2039: PUSH
2040: LD_VAR 0 13
2044: ARRAY
2045: PPUSH
2046: LD_INT 1
2048: PPUSH
2049: LD_INT 0
2051: PPUSH
2052: CALL_OW 49
// end ;
2056: GO 1996
2058: POP
2059: POP
// team := team diff filter ;
2060: LD_ADDR_VAR 0 6
2064: PUSH
2065: LD_VAR 0 6
2069: PUSH
2070: LD_VAR 0 12
2074: DIFF
2075: ST_TO_ADDR
// end ; if team then
2076: LD_VAR 0 6
2080: IFFALSE 2123
// for i in team do
2082: LD_ADDR_VAR 0 13
2086: PUSH
2087: LD_VAR 0 6
2091: PUSH
2092: FOR_IN
2093: IFFALSE 2121
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2095: LD_VAR 0 13
2099: PPUSH
2100: LD_INT 1
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// ComHold ( i ) ;
2110: LD_VAR 0 13
2114: PPUSH
2115: CALL_OW 140
// end ;
2119: GO 2092
2121: POP
2122: POP
// if fac then
2123: LD_VAR 0 10
2127: IFFALSE 2163
// if UnitsInside ( fac [ 1 ] ) then
2129: LD_VAR 0 10
2133: PUSH
2134: LD_INT 1
2136: ARRAY
2137: PPUSH
2138: CALL_OW 313
2142: IFFALSE 2163
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2144: LD_VAR 0 10
2148: PUSH
2149: LD_INT 1
2151: ARRAY
2152: PPUSH
2153: LD_INT 10
2155: PPUSH
2156: LD_INT 0
2158: PPUSH
2159: CALL_OW 486
// if lab then
2163: LD_VAR 0 9
2167: IFFALSE 2203
// if UnitsInside ( lab [ 1 ] ) then
2169: LD_VAR 0 9
2173: PUSH
2174: LD_INT 1
2176: ARRAY
2177: PPUSH
2178: CALL_OW 313
2182: IFFALSE 2203
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2184: LD_VAR 0 9
2188: PUSH
2189: LD_INT 1
2191: ARRAY
2192: PPUSH
2193: LD_INT 10
2195: PPUSH
2196: LD_INT 0
2198: PPUSH
2199: CALL_OW 486
// uc_side := 4 ;
2203: LD_ADDR_OWVAR 20
2207: PUSH
2208: LD_INT 4
2210: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2211: LD_ADDR_EXP 17
2215: PUSH
2216: LD_STRING Harisson
2218: PPUSH
2219: LD_INT 0
2221: PPUSH
2222: LD_STRING 
2224: PPUSH
2225: CALL 4155 0 3
2229: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_double_gun , 100 ) ;
2230: LD_ADDR_VAR 0 5
2234: PUSH
2235: LD_INT 4
2237: PPUSH
2238: LD_INT 1
2240: PPUSH
2241: LD_INT 2
2243: PPUSH
2244: LD_INT 1
2246: PPUSH
2247: LD_INT 1
2249: PPUSH
2250: LD_INT 5
2252: PPUSH
2253: LD_INT 100
2255: PPUSH
2256: CALL 4218 0 7
2260: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2261: LD_VAR 0 5
2265: PPUSH
2266: LD_INT 2
2268: PPUSH
2269: CALL_OW 233
// PlaceUnitXY ( veh , 22 , 9 , false ) ;
2273: LD_VAR 0 5
2277: PPUSH
2278: LD_INT 22
2280: PPUSH
2281: LD_INT 9
2283: PPUSH
2284: LD_INT 0
2286: PPUSH
2287: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2291: LD_EXP 17
2295: PPUSH
2296: LD_VAR 0 5
2300: PPUSH
2301: CALL_OW 52
// PrepareHuman ( false , 1 , 0 ) ;
2305: LD_INT 0
2307: PPUSH
2308: LD_INT 1
2310: PPUSH
2311: LD_INT 0
2313: PPUSH
2314: CALL_OW 380
// RandGuy := CreateHuman ;
2318: LD_ADDR_EXP 19
2322: PUSH
2323: CALL_OW 44
2327: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 100 ) ;
2328: LD_ADDR_VAR 0 5
2332: PUSH
2333: LD_INT 4
2335: PPUSH
2336: LD_INT 1
2338: PPUSH
2339: LD_INT 2
2341: PPUSH
2342: LD_INT 1
2344: PPUSH
2345: LD_INT 1
2347: PPUSH
2348: LD_INT 4
2350: PPUSH
2351: LD_INT 100
2353: PPUSH
2354: CALL 4218 0 7
2358: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2359: LD_VAR 0 5
2363: PPUSH
2364: LD_INT 2
2366: PPUSH
2367: CALL_OW 233
// PlaceUnitXY ( veh , 17 , 4 , false ) ;
2371: LD_VAR 0 5
2375: PPUSH
2376: LD_INT 17
2378: PPUSH
2379: LD_INT 4
2381: PPUSH
2382: LD_INT 0
2384: PPUSH
2385: CALL_OW 48
// PlaceHumanInUnit ( RandGuy , veh ) ;
2389: LD_EXP 19
2393: PPUSH
2394: LD_VAR 0 5
2398: PPUSH
2399: CALL_OW 52
// end ;
2403: LD_VAR 0 1
2407: RET
// function PrepareBase ; var blist , i , b ; begin
2408: LD_INT 0
2410: PPUSH
2411: PPUSH
2412: PPUSH
2413: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2414: LD_INT 71
2416: PPUSH
2417: LD_INT 5
2419: PPUSH
2420: LD_INT 1
2422: PPUSH
2423: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2427: LD_ADDR_VAR 0 2
2431: PUSH
2432: LD_STRING GammaBase
2434: PPUSH
2435: EMPTY
2436: PPUSH
2437: CALL_OW 30
2441: ST_TO_ADDR
// if not blist then
2442: LD_VAR 0 2
2446: NOT
2447: IFFALSE 2487
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2449: LD_ADDR_VAR 0 2
2453: PUSH
2454: LD_INT 0
2456: PUSH
2457: LD_INT 51
2459: PUSH
2460: LD_INT 10
2462: PUSH
2463: LD_INT 3
2465: PUSH
2466: LD_INT 3
2468: PUSH
2469: LD_INT 0
2471: PUSH
2472: LD_INT 0
2474: PUSH
2475: EMPTY
2476: LIST
2477: LIST
2478: LIST
2479: LIST
2480: LIST
2481: LIST
2482: LIST
2483: PUSH
2484: EMPTY
2485: LIST
2486: ST_TO_ADDR
// uc_side := 1 ;
2487: LD_ADDR_OWVAR 20
2491: PUSH
2492: LD_INT 1
2494: ST_TO_ADDR
// uc_nation := 1 ;
2495: LD_ADDR_OWVAR 21
2499: PUSH
2500: LD_INT 1
2502: ST_TO_ADDR
// for i in blist do
2503: LD_ADDR_VAR 0 3
2507: PUSH
2508: LD_VAR 0 2
2512: PUSH
2513: FOR_IN
2514: IFFALSE 2665
// begin bc_type := i [ 1 ] ;
2516: LD_ADDR_OWVAR 42
2520: PUSH
2521: LD_VAR 0 3
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2530: LD_ADDR_OWVAR 43
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_INT 5
2542: ARRAY
2543: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2544: LD_VAR 0 3
2548: PUSH
2549: LD_INT 1
2551: ARRAY
2552: PUSH
2553: LD_INT 7
2555: PUSH
2556: LD_INT 8
2558: PUSH
2559: EMPTY
2560: LIST
2561: LIST
2562: IN
2563: IFFALSE 2593
// begin bc_kind1 := i [ 7 ] ;
2565: LD_ADDR_OWVAR 44
2569: PUSH
2570: LD_VAR 0 3
2574: PUSH
2575: LD_INT 7
2577: ARRAY
2578: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2579: LD_ADDR_OWVAR 45
2583: PUSH
2584: LD_VAR 0 3
2588: PUSH
2589: LD_INT 8
2591: ARRAY
2592: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2593: LD_ADDR_VAR 0 4
2597: PUSH
2598: LD_VAR 0 3
2602: PUSH
2603: LD_INT 2
2605: ARRAY
2606: PPUSH
2607: LD_VAR 0 3
2611: PUSH
2612: LD_INT 3
2614: ARRAY
2615: PPUSH
2616: LD_VAR 0 3
2620: PUSH
2621: LD_INT 4
2623: ARRAY
2624: PPUSH
2625: CALL_OW 47
2629: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2630: LD_VAR 0 4
2634: PPUSH
2635: CALL_OW 266
2639: PUSH
2640: LD_INT 32
2642: EQUAL
2643: IFFALSE 2663
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2645: LD_VAR 0 4
2649: PPUSH
2650: LD_VAR 0 3
2654: PUSH
2655: LD_INT 7
2657: ARRAY
2658: PPUSH
2659: CALL_OW 431
// end ; end ;
2663: GO 2513
2665: POP
2666: POP
// end ; end_of_file
2667: LD_VAR 0 1
2671: RET
// export function Action ; var points , i , sol , time , team , filter ; begin
2672: LD_INT 0
2674: PPUSH
2675: PPUSH
2676: PPUSH
2677: PPUSH
2678: PPUSH
2679: PPUSH
2680: PPUSH
// InGameOn ;
2681: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2685: LD_INT 33
2687: PPUSH
2688: LD_INT 11
2690: PPUSH
2691: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2695: LD_ADDR_VAR 0 2
2699: PUSH
2700: LD_INT 29
2702: PUSH
2703: LD_INT 21
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: PUSH
2710: LD_INT 41
2712: PUSH
2713: LD_INT 28
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: PUSH
2720: LD_INT 52
2722: PUSH
2723: LD_INT 26
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 49
2732: PUSH
2733: LD_INT 16
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2746: LD_ADDR_VAR 0 4
2750: PUSH
2751: LD_INT 22
2753: PUSH
2754: LD_INT 1
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 26
2763: PUSH
2764: LD_INT 1
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PPUSH
2775: CALL_OW 69
2779: PUSH
2780: LD_EXP 7
2784: PUSH
2785: LD_EXP 14
2789: PUSH
2790: LD_EXP 11
2794: PUSH
2795: LD_EXP 12
2799: PUSH
2800: LD_EXP 8
2804: PUSH
2805: LD_EXP 15
2809: PUSH
2810: LD_EXP 16
2814: PUSH
2815: EMPTY
2816: LIST
2817: LIST
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: DIFF
2824: PUSH
2825: LD_INT 1
2827: ARRAY
2828: ST_TO_ADDR
// if sol then
2829: LD_VAR 0 4
2833: IFFALSE 2864
// begin ComMoveXY ( sol , 50 , 18 ) ;
2835: LD_VAR 0 4
2839: PPUSH
2840: LD_INT 50
2842: PPUSH
2843: LD_INT 18
2845: PPUSH
2846: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2850: LD_VAR 0 4
2854: PPUSH
2855: LD_EXP 17
2859: PPUSH
2860: CALL_OW 179
// end ; for i in points do
2864: LD_ADDR_VAR 0 3
2868: PUSH
2869: LD_VAR 0 2
2873: PUSH
2874: FOR_IN
2875: IFFALSE 2915
// AddComMoveXY ( [ Harisson , RandGuy ] , i [ 1 ] , i [ 2 ] ) ;
2877: LD_EXP 17
2881: PUSH
2882: LD_EXP 19
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PPUSH
2891: LD_VAR 0 3
2895: PUSH
2896: LD_INT 1
2898: ARRAY
2899: PPUSH
2900: LD_VAR 0 3
2904: PUSH
2905: LD_INT 2
2907: ARRAY
2908: PPUSH
2909: CALL_OW 171
2913: GO 2874
2915: POP
2916: POP
// AddComExitVehicle ( [ Harisson , RandGuy ] ) ;
2917: LD_EXP 17
2921: PUSH
2922: LD_EXP 19
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: PPUSH
2931: CALL_OW 181
// AddComTurnUnit ( [ Harisson , RandGuy ] , sol ) ;
2935: LD_EXP 17
2939: PUSH
2940: LD_EXP 19
2944: PUSH
2945: EMPTY
2946: LIST
2947: LIST
2948: PPUSH
2949: LD_VAR 0 4
2953: PPUSH
2954: CALL_OW 179
// time := 0 0$20 ;
2958: LD_ADDR_VAR 0 5
2962: PUSH
2963: LD_INT 700
2965: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
2966: LD_INT 10
2968: PPUSH
2969: CALL_OW 67
// time := time - 0 0$0.3 ;
2973: LD_ADDR_VAR 0 5
2977: PUSH
2978: LD_VAR 0 5
2982: PUSH
2983: LD_INT 10
2985: MINUS
2986: ST_TO_ADDR
// until not IsInUnit ( Harisson ) or time <= 0 0$00 ;
2987: LD_EXP 17
2991: PPUSH
2992: CALL_OW 310
2996: NOT
2997: PUSH
2998: LD_VAR 0 5
3002: PUSH
3003: LD_INT 0
3005: LESSEQUAL
3006: OR
3007: IFFALSE 2966
// Say ( sol , D1-Sol1-1 ) ;
3009: LD_VAR 0 4
3013: PPUSH
3014: LD_STRING D1-Sol1-1
3016: PPUSH
3017: CALL_OW 88
// Say ( Harisson , D1-Har-1 ) ;
3021: LD_EXP 17
3025: PPUSH
3026: LD_STRING D1-Har-1
3028: PPUSH
3029: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
3033: LD_INT 10
3035: PPUSH
3036: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
3040: LD_VAR 0 4
3044: PPUSH
3045: LD_INT 35
3047: PPUSH
3048: LD_INT 21
3050: PPUSH
3051: CALL_OW 111
// ComExitBuilding ( JMM ) ;
3055: LD_EXP 7
3059: PPUSH
3060: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
3064: LD_EXP 7
3068: PPUSH
3069: LD_EXP 17
3073: PPUSH
3074: CALL_OW 172
// ComTurnUnit ( [ Harisson , RandGuy ] , JMM ) ;
3078: LD_EXP 17
3082: PUSH
3083: LD_EXP 19
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PPUSH
3092: LD_EXP 7
3096: PPUSH
3097: CALL_OW 119
// time := 0 0$3 ;
3101: LD_ADDR_VAR 0 5
3105: PUSH
3106: LD_INT 105
3108: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3109: LD_INT 35
3111: PPUSH
3112: CALL_OW 67
// time := time - 0 0$1 ;
3116: LD_ADDR_VAR 0 5
3120: PUSH
3121: LD_VAR 0 5
3125: PUSH
3126: LD_INT 35
3128: MINUS
3129: ST_TO_ADDR
// until GetDistUnits ( JMM , Harisson ) < 4 or time = 0 0$00 ;
3130: LD_EXP 7
3134: PPUSH
3135: LD_EXP 17
3139: PPUSH
3140: CALL_OW 296
3144: PUSH
3145: LD_INT 4
3147: LESS
3148: PUSH
3149: LD_VAR 0 5
3153: PUSH
3154: LD_INT 0
3156: EQUAL
3157: OR
3158: IFFALSE 3109
// ComTurnUnit ( JMM , Harisson ) ;
3160: LD_EXP 7
3164: PPUSH
3165: LD_EXP 17
3169: PPUSH
3170: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3174: LD_EXP 7
3178: PPUSH
3179: LD_STRING D1-JMM-1
3181: PPUSH
3182: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3186: LD_EXP 17
3190: PPUSH
3191: LD_STRING D1-Har-2
3193: PPUSH
3194: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3198: LD_EXP 7
3202: PPUSH
3203: LD_STRING D1-JMM-2
3205: PPUSH
3206: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3210: LD_EXP 17
3214: PPUSH
3215: LD_STRING D1-Har-3
3217: PPUSH
3218: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3222: LD_EXP 7
3226: PPUSH
3227: LD_STRING D1-JMM-3
3229: PPUSH
3230: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3234: LD_EXP 17
3238: PPUSH
3239: LD_STRING D1-Har-4
3241: PPUSH
3242: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3246: LD_EXP 7
3250: PPUSH
3251: LD_STRING D1-JMM-4
3253: PPUSH
3254: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3258: LD_EXP 17
3262: PPUSH
3263: LD_STRING D1-Har-5
3265: PPUSH
3266: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3270: LD_EXP 7
3274: PPUSH
3275: LD_STRING D1-JMM-5
3277: PPUSH
3278: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3282: LD_EXP 17
3286: PPUSH
3287: LD_STRING D1-Har-6
3289: PPUSH
3290: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3294: LD_EXP 7
3298: PPUSH
3299: LD_STRING D1-JMM-6
3301: PPUSH
3302: CALL_OW 88
// EndMission ;
3306: CALL 3315 0 0
// end ;
3310: LD_VAR 0 1
3314: RET
// export function EndMission ; var commander , i , all ; begin
3315: LD_INT 0
3317: PPUSH
3318: PPUSH
3319: PPUSH
3320: PPUSH
// case gamma_commander of 1 :
3321: LD_EXP 18
3325: PUSH
3326: LD_INT 1
3328: DOUBLE
3329: EQUAL
3330: IFTRUE 3334
3332: GO 3347
3334: POP
// commander := Donaldson ; 2 :
3335: LD_ADDR_VAR 0 2
3339: PUSH
3340: LD_EXP 13
3344: ST_TO_ADDR
3345: GO 3390
3347: LD_INT 2
3349: DOUBLE
3350: EQUAL
3351: IFTRUE 3355
3353: GO 3368
3355: POP
// commander := Brown ; 3 :
3356: LD_ADDR_VAR 0 2
3360: PUSH
3361: LD_EXP 14
3365: ST_TO_ADDR
3366: GO 3390
3368: LD_INT 3
3370: DOUBLE
3371: EQUAL
3372: IFTRUE 3376
3374: GO 3389
3376: POP
// commander := Houten ; end ;
3377: LD_ADDR_VAR 0 2
3381: PUSH
3382: LD_EXP 15
3386: ST_TO_ADDR
3387: GO 3390
3389: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3390: LD_ADDR_VAR 0 4
3394: PUSH
3395: LD_INT 22
3397: PUSH
3398: LD_INT 1
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PUSH
3405: LD_INT 21
3407: PUSH
3408: LD_INT 1
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: PPUSH
3419: CALL_OW 69
3423: PUSH
3424: LD_EXP 7
3428: PUSH
3429: LD_VAR 0 2
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: DIFF
3438: ST_TO_ADDR
// if UnitFilter ( all , [ f_class , 2 ] ) then
3439: LD_VAR 0 4
3443: PPUSH
3444: LD_INT 25
3446: PUSH
3447: LD_INT 2
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: PPUSH
3454: CALL_OW 72
3458: IFFALSE 3504
// for i in UnitFilter ( all , [ f_class , 2 ] ) do
3460: LD_ADDR_VAR 0 3
3464: PUSH
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_INT 25
3472: PUSH
3473: LD_INT 2
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: PUSH
3485: FOR_IN
3486: IFFALSE 3502
// SetClass ( i , 2 ) ;
3488: LD_VAR 0 3
3492: PPUSH
3493: LD_INT 2
3495: PPUSH
3496: CALL_OW 336
3500: GO 3485
3502: POP
3503: POP
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable ] ^ [ commander , Harisson ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3504: LD_ADDR_EXP 4
3508: PUSH
3509: LD_STRING 1
3511: PPUSH
3512: LD_INT 10
3514: PPUSH
3515: LD_INT 10
3517: PPUSH
3518: LD_INT -5
3520: PUSH
3521: LD_EXP 7
3525: PUSH
3526: LD_INT -2
3528: PUSH
3529: LD_INT -3
3531: PUSH
3532: LD_INT -5
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: LIST
3541: PUSH
3542: LD_VAR 0 4
3546: ADD
3547: PUSH
3548: LD_INT -6
3550: PUSH
3551: LD_INT -4
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: ADD
3558: PUSH
3559: LD_VAR 0 2
3563: PUSH
3564: LD_EXP 17
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: ADD
3573: PPUSH
3574: LD_INT 1
3576: PUSH
3577: LD_INT 3
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 3
3586: PUSH
3587: LD_INT 3
3589: PUSH
3590: LD_INT 6
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 4
3600: PUSH
3601: LD_INT 1
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: PPUSH
3613: CALL_OW 42
3617: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3618: LD_VAR 0 4
3622: PUSH
3623: LD_EXP 7
3627: PUSH
3628: LD_EXP 8
3632: PUSH
3633: LD_EXP 10
3637: PUSH
3638: LD_EXP 11
3642: PUSH
3643: LD_EXP 12
3647: PUSH
3648: LD_EXP 9
3652: PUSH
3653: LD_EXP 13
3657: PUSH
3658: LD_EXP 14
3662: PUSH
3663: LD_EXP 15
3667: PUSH
3668: LD_EXP 17
3672: PUSH
3673: LD_EXP 16
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: LIST
3686: LIST
3687: LIST
3688: LIST
3689: LIST
3690: PUSH
3691: LD_EXP 4
3695: ADD
3696: DIFF
3697: PPUSH
3698: LD_STRING 07_othersGamma
3700: PPUSH
3701: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3705: LD_EXP 4
3709: PUSH
3710: LD_EXP 7
3714: PUSH
3715: LD_EXP 8
3719: PUSH
3720: LD_EXP 10
3724: PUSH
3725: LD_EXP 11
3729: PUSH
3730: LD_EXP 12
3734: PUSH
3735: LD_EXP 9
3739: PUSH
3740: LD_EXP 13
3744: PUSH
3745: LD_EXP 14
3749: PUSH
3750: LD_EXP 15
3754: PUSH
3755: LD_EXP 17
3759: PUSH
3760: LD_EXP 16
3764: PUSH
3765: LD_INT 0
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: LIST
3775: LIST
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: LIST
3781: DIFF
3782: PPUSH
3783: LD_STRING 07_others
3785: PPUSH
3786: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3790: LD_EXP 7
3794: PPUSH
3795: LD_EXP 5
3799: PUSH
3800: LD_STRING JMM
3802: STR
3803: PPUSH
3804: CALL_OW 38
// if Lisa then
3808: LD_EXP 10
3812: IFFALSE 3854
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3814: LD_EXP 10
3818: PPUSH
3819: LD_EXP 5
3823: PUSH
3824: LD_STRING Lisa
3826: STR
3827: PPUSH
3828: CALL_OW 38
// if Lisa in save_group then
3832: LD_EXP 10
3836: PUSH
3837: LD_EXP 4
3841: IN
3842: IFFALSE 3854
// SaveVariable ( true , LisaIn07 ) ;
3844: LD_INT 1
3846: PPUSH
3847: LD_STRING LisaIn07
3849: PPUSH
3850: CALL_OW 39
// end ; if Bobby then
3854: LD_EXP 12
3858: IFFALSE 3900
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3860: LD_EXP 12
3864: PPUSH
3865: LD_EXP 5
3869: PUSH
3870: LD_STRING Bobby
3872: STR
3873: PPUSH
3874: CALL_OW 38
// if Bobby in save_group then
3878: LD_EXP 12
3882: PUSH
3883: LD_EXP 4
3887: IN
3888: IFFALSE 3900
// SaveVariable ( true , BobbyIn07 ) ;
3890: LD_INT 1
3892: PPUSH
3893: LD_STRING BobbyIn07
3895: PPUSH
3896: CALL_OW 39
// end ; if Cyrus then
3900: LD_EXP 11
3904: IFFALSE 3946
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3906: LD_EXP 11
3910: PPUSH
3911: LD_EXP 5
3915: PUSH
3916: LD_STRING Cyrus
3918: STR
3919: PPUSH
3920: CALL_OW 38
// if Cyrus in save_group then
3924: LD_EXP 11
3928: PUSH
3929: LD_EXP 4
3933: IN
3934: IFFALSE 3946
// SaveVariable ( true , CyrusIn07 ) ;
3936: LD_INT 1
3938: PPUSH
3939: LD_STRING CyrusIn07
3941: PPUSH
3942: CALL_OW 39
// end ; if Brown then
3946: LD_EXP 14
3950: IFFALSE 3992
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3952: LD_EXP 14
3956: PPUSH
3957: LD_EXP 5
3961: PUSH
3962: LD_STRING Brown
3964: STR
3965: PPUSH
3966: CALL_OW 38
// if Brown in save_group then
3970: LD_EXP 14
3974: PUSH
3975: LD_EXP 4
3979: IN
3980: IFFALSE 3992
// SaveVariable ( true , BrownIn07 ) ;
3982: LD_INT 1
3984: PPUSH
3985: LD_STRING BrownIn07
3987: PPUSH
3988: CALL_OW 39
// end ; if Donaldson then
3992: LD_EXP 13
3996: IFFALSE 4038
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3998: LD_EXP 13
4002: PPUSH
4003: LD_EXP 5
4007: PUSH
4008: LD_STRING Donaldson
4010: STR
4011: PPUSH
4012: CALL_OW 38
// if Donaldson in save_group then
4016: LD_EXP 13
4020: PUSH
4021: LD_EXP 4
4025: IN
4026: IFFALSE 4038
// SaveVariable ( true , DonaldsonIn07 ) ;
4028: LD_INT 1
4030: PPUSH
4031: LD_STRING DonaldsonIn07
4033: PPUSH
4034: CALL_OW 39
// end ; if Gladstone then
4038: LD_EXP 8
4042: IFFALSE 4084
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4044: LD_EXP 8
4048: PPUSH
4049: LD_EXP 5
4053: PUSH
4054: LD_STRING Gladstone
4056: STR
4057: PPUSH
4058: CALL_OW 38
// if Gladstone in save_group then
4062: LD_EXP 8
4066: PUSH
4067: LD_EXP 4
4071: IN
4072: IFFALSE 4084
// SaveVariable ( true , GladstoneIn07 ) ;
4074: LD_INT 1
4076: PPUSH
4077: LD_STRING GladstoneIn07
4079: PPUSH
4080: CALL_OW 39
// end ; if Khatam then
4084: LD_EXP 16
4088: IFFALSE 4130
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
4090: LD_EXP 16
4094: PPUSH
4095: LD_EXP 5
4099: PUSH
4100: LD_STRING Khatam
4102: STR
4103: PPUSH
4104: CALL_OW 38
// if Khatam in save_group then
4108: LD_EXP 16
4112: PUSH
4113: LD_EXP 4
4117: IN
4118: IFFALSE 4130
// SaveVariable ( true , KhatamIn07 ) ;
4120: LD_INT 1
4122: PPUSH
4123: LD_STRING KhatamIn07
4125: PPUSH
4126: CALL_OW 39
// end ; if debug then
4130: LD_EXP 1
4134: IFFALSE 4140
// InGameOff ;
4136: CALL_OW 9
// ChangeMap ( 1 , %_cont ) ;
4140: LD_INT 1
4142: PPUSH
4143: LD_STRING %_cont
4145: PPUSH
4146: CALL_OW 340
// end ; end_of_file
4150: LD_VAR 0 1
4154: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4155: LD_INT 0
4157: PPUSH
4158: PPUSH
// if exist_mode then
4159: LD_VAR 0 2
4163: IFFALSE 4188
// unit := CreateCharacter ( prefix & ident ) else
4165: LD_ADDR_VAR 0 5
4169: PUSH
4170: LD_VAR 0 3
4174: PUSH
4175: LD_VAR 0 1
4179: STR
4180: PPUSH
4181: CALL_OW 34
4185: ST_TO_ADDR
4186: GO 4203
// unit := NewCharacter ( ident ) ;
4188: LD_ADDR_VAR 0 5
4192: PUSH
4193: LD_VAR 0 1
4197: PPUSH
4198: CALL_OW 25
4202: ST_TO_ADDR
// result := unit ;
4203: LD_ADDR_VAR 0 4
4207: PUSH
4208: LD_VAR 0 5
4212: ST_TO_ADDR
// end ;
4213: LD_VAR 0 4
4217: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4218: LD_INT 0
4220: PPUSH
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 1
4230: ST_TO_ADDR
// uc_nation := nation ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_VAR 0 2
4240: ST_TO_ADDR
// vc_chassis := chassis ;
4241: LD_ADDR_OWVAR 37
4245: PUSH
4246: LD_VAR 0 3
4250: ST_TO_ADDR
// vc_engine := engine ;
4251: LD_ADDR_OWVAR 39
4255: PUSH
4256: LD_VAR 0 4
4260: ST_TO_ADDR
// vc_control := control ;
4261: LD_ADDR_OWVAR 38
4265: PUSH
4266: LD_VAR 0 5
4270: ST_TO_ADDR
// vc_weapon := weapon ;
4271: LD_ADDR_OWVAR 40
4275: PUSH
4276: LD_VAR 0 6
4280: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4281: LD_ADDR_OWVAR 41
4285: PUSH
4286: LD_VAR 0 7
4290: ST_TO_ADDR
// result := CreateVehicle ;
4291: LD_ADDR_VAR 0 8
4295: PUSH
4296: CALL_OW 45
4300: ST_TO_ADDR
// end ;
4301: LD_VAR 0 8
4305: RET
// export function SayX ( units , ident ) ; var i ; begin
4306: LD_INT 0
4308: PPUSH
4309: PPUSH
// result := false ;
4310: LD_ADDR_VAR 0 3
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// if not units then
4318: LD_VAR 0 1
4322: NOT
4323: IFFALSE 4327
// exit ;
4325: GO 4381
// for i in units do
4327: LD_ADDR_VAR 0 4
4331: PUSH
4332: LD_VAR 0 1
4336: PUSH
4337: FOR_IN
4338: IFFALSE 4379
// if IsOk ( i ) then
4340: LD_VAR 0 4
4344: PPUSH
4345: CALL_OW 302
4349: IFFALSE 4377
// begin Say ( i , ident ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_VAR 0 2
4360: PPUSH
4361: CALL_OW 88
// result := i ;
4365: LD_ADDR_VAR 0 3
4369: PUSH
4370: LD_VAR 0 4
4374: ST_TO_ADDR
// break ;
4375: GO 4379
// end ;
4377: GO 4337
4379: POP
4380: POP
// end ;
4381: LD_VAR 0 3
4385: RET
