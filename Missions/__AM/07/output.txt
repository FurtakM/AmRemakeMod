// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2328 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2049 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3635 0 3
 179: ST_TO_ADDR
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 180: LD_ADDR_EXP 18
 184: PUSH
 185: LD_STRING GammaCommander
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: CALL_OW 30
 195: ST_TO_ADDR
// if gamma_commander = 1 then
 196: LD_EXP 18
 200: PUSH
 201: LD_INT 1
 203: EQUAL
 204: IFFALSE 230
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 206: LD_ADDR_EXP 13
 210: PUSH
 211: LD_STRING Donaldson
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 04_
 222: PPUSH
 223: CALL 3635 0 3
 227: ST_TO_ADDR
// end else
 228: GO 288
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 230: LD_STRING DonaldsonIn06
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: IFFALSE 266
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 242: LD_ADDR_EXP 13
 246: PUSH
 247: LD_STRING Donaldson
 249: PPUSH
 250: LD_EXP 1
 254: NOT
 255: PPUSH
 256: LD_STRING 06c_
 258: PPUSH
 259: CALL 3635 0 3
 263: ST_TO_ADDR
 264: GO 288
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 266: LD_ADDR_EXP 13
 270: PUSH
 271: LD_STRING Donaldson
 273: PPUSH
 274: LD_EXP 1
 278: NOT
 279: PPUSH
 280: LD_STRING 04_
 282: PPUSH
 283: CALL 3635 0 3
 287: ST_TO_ADDR
// end ; if Donaldson then
 288: LD_EXP 13
 292: IFFALSE 310
// team := team ^ Donaldson ;
 294: LD_ADDR_VAR 0 6
 298: PUSH
 299: LD_VAR 0 6
 303: PUSH
 304: LD_EXP 13
 308: ADD
 309: ST_TO_ADDR
// if gamma_commander = 2 then
 310: LD_EXP 18
 314: PUSH
 315: LD_INT 2
 317: EQUAL
 318: IFFALSE 344
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 320: LD_ADDR_EXP 14
 324: PUSH
 325: LD_STRING Brown
 327: PPUSH
 328: LD_EXP 1
 332: NOT
 333: PPUSH
 334: LD_STRING 04_
 336: PPUSH
 337: CALL 3635 0 3
 341: ST_TO_ADDR
// end else
 342: GO 402
// begin if LoadVariable ( BrownIn06 , 0 ) then
 344: LD_STRING BrownIn06
 346: PPUSH
 347: LD_INT 0
 349: PPUSH
 350: CALL_OW 30
 354: IFFALSE 380
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 356: LD_ADDR_EXP 14
 360: PUSH
 361: LD_STRING Brown
 363: PPUSH
 364: LD_EXP 1
 368: NOT
 369: PPUSH
 370: LD_STRING 06c_
 372: PPUSH
 373: CALL 3635 0 3
 377: ST_TO_ADDR
 378: GO 402
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 380: LD_ADDR_EXP 14
 384: PUSH
 385: LD_STRING Brown
 387: PPUSH
 388: LD_EXP 1
 392: NOT
 393: PPUSH
 394: LD_STRING 04_
 396: PPUSH
 397: CALL 3635 0 3
 401: ST_TO_ADDR
// end ; if Brown then
 402: LD_EXP 14
 406: IFFALSE 424
// team := team ^ Brown ;
 408: LD_ADDR_VAR 0 6
 412: PUSH
 413: LD_VAR 0 6
 417: PUSH
 418: LD_EXP 14
 422: ADD
 423: ST_TO_ADDR
// if gamma_commander = 3 then
 424: LD_EXP 18
 428: PUSH
 429: LD_INT 3
 431: EQUAL
 432: IFFALSE 469
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 434: LD_ADDR_EXP 15
 438: PUSH
 439: LD_STRING VanHouten
 441: PPUSH
 442: LD_INT 0
 444: PPUSH
 445: LD_STRING 
 447: PPUSH
 448: CALL 3635 0 3
 452: ST_TO_ADDR
// team := team ^ Houten ;
 453: LD_ADDR_VAR 0 6
 457: PUSH
 458: LD_VAR 0 6
 462: PUSH
 463: LD_EXP 15
 467: ADD
 468: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 469: LD_STRING GladstoneIn06
 471: PPUSH
 472: LD_INT 0
 474: PPUSH
 475: CALL_OW 30
 479: IFFALSE 503
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) ;
 481: LD_ADDR_EXP 8
 485: PUSH
 486: LD_STRING Gladstone
 488: PPUSH
 489: LD_EXP 1
 493: NOT
 494: PPUSH
 495: LD_STRING 06c_
 497: PPUSH
 498: CALL 3635 0 3
 502: ST_TO_ADDR
// if Gladstone then
 503: LD_EXP 8
 507: IFFALSE 525
// team := team ^ Gladstone ;
 509: LD_ADDR_VAR 0 6
 513: PUSH
 514: LD_VAR 0 6
 518: PUSH
 519: LD_EXP 8
 523: ADD
 524: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 525: LD_ADDR_EXP 16
 529: PUSH
 530: LD_STRING Khatam
 532: PPUSH
 533: LD_EXP 1
 537: NOT
 538: PPUSH
 539: LD_STRING 03_
 541: PPUSH
 542: CALL 3635 0 3
 546: ST_TO_ADDR
// if Khatam then
 547: LD_EXP 16
 551: IFFALSE 569
// team := team ^ Khatam ;
 553: LD_ADDR_VAR 0 6
 557: PUSH
 558: LD_VAR 0 6
 562: PUSH
 563: LD_EXP 16
 567: ADD
 568: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 569: LD_STRING LisaIn06
 571: PPUSH
 572: LD_INT 0
 574: PPUSH
 575: CALL_OW 30
 579: IFFALSE 605
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 581: LD_ADDR_EXP 10
 585: PUSH
 586: LD_STRING Lisa
 588: PPUSH
 589: LD_EXP 1
 593: NOT
 594: PPUSH
 595: LD_STRING 06c_
 597: PPUSH
 598: CALL 3635 0 3
 602: ST_TO_ADDR
 603: GO 627
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 605: LD_ADDR_EXP 10
 609: PUSH
 610: LD_STRING Lisa
 612: PPUSH
 613: LD_EXP 1
 617: NOT
 618: PPUSH
 619: LD_STRING 04_
 621: PPUSH
 622: CALL 3635 0 3
 626: ST_TO_ADDR
// if Lisa then
 627: LD_EXP 10
 631: IFFALSE 649
// team := team ^ Lisa ;
 633: LD_ADDR_VAR 0 6
 637: PUSH
 638: LD_VAR 0 6
 642: PUSH
 643: LD_EXP 10
 647: ADD
 648: ST_TO_ADDR
// if LoadVariable ( CyrusIn06 , 0 ) then
 649: LD_STRING CyrusIn06
 651: PPUSH
 652: LD_INT 0
 654: PPUSH
 655: CALL_OW 30
 659: IFFALSE 685
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 661: LD_ADDR_EXP 11
 665: PUSH
 666: LD_STRING Cyrus
 668: PPUSH
 669: LD_EXP 1
 673: NOT
 674: PPUSH
 675: LD_STRING 06c_
 677: PPUSH
 678: CALL 3635 0 3
 682: ST_TO_ADDR
 683: GO 707
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 685: LD_ADDR_EXP 11
 689: PUSH
 690: LD_STRING Cyrus
 692: PPUSH
 693: LD_EXP 1
 697: NOT
 698: PPUSH
 699: LD_STRING 03_
 701: PPUSH
 702: CALL 3635 0 3
 706: ST_TO_ADDR
// if Cyrus then
 707: LD_EXP 11
 711: IFFALSE 729
// team := team ^ Cyrus ;
 713: LD_ADDR_VAR 0 6
 717: PUSH
 718: LD_VAR 0 6
 722: PUSH
 723: LD_EXP 11
 727: ADD
 728: ST_TO_ADDR
// if LoadVariable ( BobbyIn06 , 0 ) then
 729: LD_STRING BobbyIn06
 731: PPUSH
 732: LD_INT 0
 734: PPUSH
 735: CALL_OW 30
 739: IFFALSE 765
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 741: LD_ADDR_EXP 12
 745: PUSH
 746: LD_STRING Bobby
 748: PPUSH
 749: LD_EXP 1
 753: NOT
 754: PPUSH
 755: LD_STRING 06c_
 757: PPUSH
 758: CALL 3635 0 3
 762: ST_TO_ADDR
 763: GO 787
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 765: LD_ADDR_EXP 12
 769: PUSH
 770: LD_STRING Bobby
 772: PPUSH
 773: LD_EXP 1
 777: NOT
 778: PPUSH
 779: LD_STRING 03_
 781: PPUSH
 782: CALL 3635 0 3
 786: ST_TO_ADDR
// if Bobby then
 787: LD_EXP 12
 791: IFFALSE 809
// team := team ^ Bobby ;
 793: LD_ADDR_VAR 0 6
 797: PUSH
 798: LD_VAR 0 6
 802: PUSH
 803: LD_EXP 12
 807: ADD
 808: ST_TO_ADDR
// others4 := CreateCharacterSet ( othersGamma ) ;
 809: LD_ADDR_VAR 0 4
 813: PUSH
 814: LD_STRING othersGamma
 816: PPUSH
 817: CALL_OW 31
 821: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
 822: LD_ADDR_VAR 0 2
 826: PUSH
 827: LD_STRING 06_other_survivors
 829: PPUSH
 830: CALL_OW 31
 834: ST_TO_ADDR
// others := others union others4 ;
 835: LD_ADDR_VAR 0 2
 839: PUSH
 840: LD_VAR 0 2
 844: PUSH
 845: LD_VAR 0 4
 849: UNION
 850: ST_TO_ADDR
// team := team ^ others ;
 851: LD_ADDR_VAR 0 6
 855: PUSH
 856: LD_VAR 0 6
 860: PUSH
 861: LD_VAR 0 2
 865: ADD
 866: ST_TO_ADDR
// for i in others do
 867: LD_ADDR_VAR 0 13
 871: PUSH
 872: LD_VAR 0 2
 876: PUSH
 877: FOR_IN
 878: IFFALSE 946
// begin if GetClass ( i ) = 2 then
 880: LD_VAR 0 13
 884: PPUSH
 885: CALL_OW 257
 889: PUSH
 890: LD_INT 2
 892: EQUAL
 893: IFFALSE 907
// SetClass ( i , 1 ) ;
 895: LD_VAR 0 13
 899: PPUSH
 900: LD_INT 1
 902: PPUSH
 903: CALL_OW 336
// for j = 1 to 4 do
 907: LD_ADDR_VAR 0 14
 911: PUSH
 912: DOUBLE
 913: LD_INT 1
 915: DEC
 916: ST_TO_ADDR
 917: LD_INT 4
 919: PUSH
 920: FOR_TO
 921: IFFALSE 942
// AddExperience ( i , j , 3000 ) ;
 923: LD_VAR 0 13
 927: PPUSH
 928: LD_VAR 0 14
 932: PPUSH
 933: LD_INT 3000
 935: PPUSH
 936: CALL_OW 492
 940: GO 920
 942: POP
 943: POP
// end ;
 944: GO 877
 946: POP
 947: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 948: LD_ADDR_VAR 0 7
 952: PUSH
 953: LD_INT 30
 955: PUSH
 956: LD_INT 0
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: PPUSH
 963: CALL_OW 69
 967: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 968: LD_ADDR_VAR 0 8
 972: PUSH
 973: LD_INT 30
 975: PUSH
 976: LD_INT 4
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: PPUSH
 983: CALL_OW 69
 987: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 988: LD_ADDR_VAR 0 9
 992: PUSH
 993: LD_INT 2
 995: PUSH
 996: LD_INT 30
 998: PUSH
 999: LD_INT 7
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: PUSH
1006: LD_INT 30
1008: PUSH
1009: LD_INT 6
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: PPUSH
1021: CALL_OW 69
1025: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1026: LD_ADDR_VAR 0 10
1030: PUSH
1031: LD_INT 30
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1046: LD_ADDR_VAR 0 11
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 30
1056: PUSH
1057: LD_INT 32
1059: PUSH
1060: EMPTY
1061: LIST
1062: LIST
1063: PUSH
1064: LD_INT 30
1066: PUSH
1067: LD_INT 31
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: LIST
1078: PPUSH
1079: CALL_OW 69
1083: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1084: LD_VAR 0 7
1088: PPUSH
1089: LD_STRING Gamma
1091: PPUSH
1092: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1096: LD_VAR 0 7
1100: PPUSH
1101: CALL_OW 274
1105: PPUSH
1106: LD_INT 2
1108: PPUSH
1109: LD_INT 10000
1111: PPUSH
1112: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1116: LD_VAR 0 7
1120: PPUSH
1121: CALL_OW 274
1125: PPUSH
1126: LD_INT 1
1128: PPUSH
1129: LD_INT 10000
1131: PPUSH
1132: CALL_OW 277
// if dep then
1136: LD_VAR 0 7
1140: IFFALSE 1240
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1142: LD_EXP 7
1146: PPUSH
1147: LD_VAR 0 7
1151: PUSH
1152: LD_INT 1
1154: ARRAY
1155: PPUSH
1156: CALL_OW 52
// if Brown then
1160: LD_EXP 14
1164: IFFALSE 1200
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1166: LD_EXP 14
1170: PPUSH
1171: LD_VAR 0 7
1175: PUSH
1176: LD_INT 1
1178: ARRAY
1179: PPUSH
1180: CALL_OW 52
// team := team diff Brown ;
1184: LD_ADDR_VAR 0 6
1188: PUSH
1189: LD_VAR 0 6
1193: PUSH
1194: LD_EXP 14
1198: DIFF
1199: ST_TO_ADDR
// end ; if Donaldson then
1200: LD_EXP 13
1204: IFFALSE 1240
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1206: LD_EXP 13
1210: PPUSH
1211: LD_VAR 0 7
1215: PUSH
1216: LD_INT 1
1218: ARRAY
1219: PPUSH
1220: CALL_OW 52
// team := team diff Donaldson ;
1224: LD_ADDR_VAR 0 6
1228: PUSH
1229: LD_VAR 0 6
1233: PUSH
1234: LD_EXP 13
1238: DIFF
1239: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1240: LD_VAR 0 11
1244: PUSH
1245: LD_VAR 0 6
1249: PPUSH
1250: LD_INT 25
1252: PUSH
1253: LD_INT 1
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PPUSH
1260: CALL_OW 72
1264: AND
1265: IFFALSE 1374
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1267: LD_ADDR_VAR 0 12
1271: PUSH
1272: LD_VAR 0 6
1276: PPUSH
1277: LD_INT 25
1279: PUSH
1280: LD_INT 1
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 72
1291: ST_TO_ADDR
// for i in bun do
1292: LD_ADDR_VAR 0 13
1296: PUSH
1297: LD_VAR 0 11
1301: PUSH
1302: FOR_IN
1303: IFFALSE 1372
// begin if not filter then
1305: LD_VAR 0 12
1309: NOT
1310: IFFALSE 1314
// break ;
1312: GO 1372
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1314: LD_VAR 0 12
1318: PUSH
1319: LD_INT 1
1321: ARRAY
1322: PPUSH
1323: LD_VAR 0 13
1327: PPUSH
1328: CALL_OW 52
// team := team diff filter [ 1 ] ;
1332: LD_ADDR_VAR 0 6
1336: PUSH
1337: LD_VAR 0 6
1341: PUSH
1342: LD_VAR 0 12
1346: PUSH
1347: LD_INT 1
1349: ARRAY
1350: DIFF
1351: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1352: LD_ADDR_VAR 0 12
1356: PUSH
1357: LD_VAR 0 12
1361: PPUSH
1362: LD_INT 1
1364: PPUSH
1365: CALL_OW 3
1369: ST_TO_ADDR
// end ;
1370: GO 1302
1372: POP
1373: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1374: LD_VAR 0 8
1378: PUSH
1379: LD_VAR 0 6
1383: PPUSH
1384: LD_INT 25
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PPUSH
1394: CALL_OW 72
1398: AND
1399: IFFALSE 1521
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1401: LD_ADDR_VAR 0 12
1405: PUSH
1406: LD_VAR 0 6
1410: PPUSH
1411: LD_INT 25
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: PPUSH
1421: CALL_OW 72
1425: ST_TO_ADDR
// for i = 1 to filter do
1426: LD_ADDR_VAR 0 13
1430: PUSH
1431: DOUBLE
1432: LD_INT 1
1434: DEC
1435: ST_TO_ADDR
1436: LD_VAR 0 12
1440: PUSH
1441: FOR_TO
1442: IFFALSE 1503
// begin if ( i <= 6 ) then
1444: LD_VAR 0 13
1448: PUSH
1449: LD_INT 6
1451: LESSEQUAL
1452: IFFALSE 1480
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1454: LD_VAR 0 12
1458: PUSH
1459: LD_VAR 0 13
1463: ARRAY
1464: PPUSH
1465: LD_VAR 0 8
1469: PUSH
1470: LD_INT 1
1472: ARRAY
1473: PPUSH
1474: CALL_OW 52
1478: GO 1501
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1480: LD_VAR 0 12
1484: PUSH
1485: LD_VAR 0 13
1489: ARRAY
1490: PPUSH
1491: LD_INT 1
1493: PPUSH
1494: LD_INT 0
1496: PPUSH
1497: CALL_OW 49
// end ;
1501: GO 1441
1503: POP
1504: POP
// team := team diff filter ;
1505: LD_ADDR_VAR 0 6
1509: PUSH
1510: LD_VAR 0 6
1514: PUSH
1515: LD_VAR 0 12
1519: DIFF
1520: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1521: LD_VAR 0 9
1525: PUSH
1526: LD_VAR 0 6
1530: PPUSH
1531: LD_INT 25
1533: PUSH
1534: LD_INT 4
1536: PUSH
1537: EMPTY
1538: LIST
1539: LIST
1540: PPUSH
1541: CALL_OW 72
1545: AND
1546: IFFALSE 1668
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1548: LD_ADDR_VAR 0 12
1552: PUSH
1553: LD_VAR 0 6
1557: PPUSH
1558: LD_INT 25
1560: PUSH
1561: LD_INT 4
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PPUSH
1568: CALL_OW 72
1572: ST_TO_ADDR
// for i = 1 to filter do
1573: LD_ADDR_VAR 0 13
1577: PUSH
1578: DOUBLE
1579: LD_INT 1
1581: DEC
1582: ST_TO_ADDR
1583: LD_VAR 0 12
1587: PUSH
1588: FOR_TO
1589: IFFALSE 1650
// begin if ( i <= 6 ) then
1591: LD_VAR 0 13
1595: PUSH
1596: LD_INT 6
1598: LESSEQUAL
1599: IFFALSE 1627
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1601: LD_VAR 0 12
1605: PUSH
1606: LD_VAR 0 13
1610: ARRAY
1611: PPUSH
1612: LD_VAR 0 9
1616: PUSH
1617: LD_INT 1
1619: ARRAY
1620: PPUSH
1621: CALL_OW 52
1625: GO 1648
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1627: LD_VAR 0 12
1631: PUSH
1632: LD_VAR 0 13
1636: ARRAY
1637: PPUSH
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 0
1643: PPUSH
1644: CALL_OW 49
// end ;
1648: GO 1588
1650: POP
1651: POP
// team := team diff filter ;
1652: LD_ADDR_VAR 0 6
1656: PUSH
1657: LD_VAR 0 6
1661: PUSH
1662: LD_VAR 0 12
1666: DIFF
1667: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1668: LD_VAR 0 10
1672: PUSH
1673: LD_VAR 0 6
1677: PPUSH
1678: LD_INT 25
1680: PUSH
1681: LD_INT 3
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: PPUSH
1688: CALL_OW 72
1692: AND
1693: IFFALSE 1815
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1695: LD_ADDR_VAR 0 12
1699: PUSH
1700: LD_VAR 0 6
1704: PPUSH
1705: LD_INT 25
1707: PUSH
1708: LD_INT 3
1710: PUSH
1711: EMPTY
1712: LIST
1713: LIST
1714: PPUSH
1715: CALL_OW 72
1719: ST_TO_ADDR
// for i = 1 to filter do
1720: LD_ADDR_VAR 0 13
1724: PUSH
1725: DOUBLE
1726: LD_INT 1
1728: DEC
1729: ST_TO_ADDR
1730: LD_VAR 0 12
1734: PUSH
1735: FOR_TO
1736: IFFALSE 1797
// begin if ( i <= 6 ) then
1738: LD_VAR 0 13
1742: PUSH
1743: LD_INT 6
1745: LESSEQUAL
1746: IFFALSE 1774
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1748: LD_VAR 0 12
1752: PUSH
1753: LD_VAR 0 13
1757: ARRAY
1758: PPUSH
1759: LD_VAR 0 10
1763: PUSH
1764: LD_INT 1
1766: ARRAY
1767: PPUSH
1768: CALL_OW 52
1772: GO 1795
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1774: LD_VAR 0 12
1778: PUSH
1779: LD_VAR 0 13
1783: ARRAY
1784: PPUSH
1785: LD_INT 1
1787: PPUSH
1788: LD_INT 0
1790: PPUSH
1791: CALL_OW 49
// end ;
1795: GO 1735
1797: POP
1798: POP
// team := team diff filter ;
1799: LD_ADDR_VAR 0 6
1803: PUSH
1804: LD_VAR 0 6
1808: PUSH
1809: LD_VAR 0 12
1813: DIFF
1814: ST_TO_ADDR
// end ; if team then
1815: LD_VAR 0 6
1819: IFFALSE 1862
// for i in team do
1821: LD_ADDR_VAR 0 13
1825: PUSH
1826: LD_VAR 0 6
1830: PUSH
1831: FOR_IN
1832: IFFALSE 1860
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1834: LD_VAR 0 13
1838: PPUSH
1839: LD_INT 1
1841: PPUSH
1842: LD_INT 0
1844: PPUSH
1845: CALL_OW 49
// ComHold ( i ) ;
1849: LD_VAR 0 13
1853: PPUSH
1854: CALL_OW 140
// end ;
1858: GO 1831
1860: POP
1861: POP
// if fac then
1862: LD_VAR 0 10
1866: IFFALSE 1902
// if UnitsInside ( fac [ 1 ] ) then
1868: LD_VAR 0 10
1872: PUSH
1873: LD_INT 1
1875: ARRAY
1876: PPUSH
1877: CALL_OW 313
1881: IFFALSE 1902
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1883: LD_VAR 0 10
1887: PUSH
1888: LD_INT 1
1890: ARRAY
1891: PPUSH
1892: LD_INT 10
1894: PPUSH
1895: LD_INT 0
1897: PPUSH
1898: CALL_OW 486
// if lab then
1902: LD_VAR 0 9
1906: IFFALSE 1942
// if UnitsInside ( lab [ 1 ] ) then
1908: LD_VAR 0 9
1912: PUSH
1913: LD_INT 1
1915: ARRAY
1916: PPUSH
1917: CALL_OW 313
1921: IFFALSE 1942
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1923: LD_VAR 0 9
1927: PUSH
1928: LD_INT 1
1930: ARRAY
1931: PPUSH
1932: LD_INT 10
1934: PPUSH
1935: LD_INT 0
1937: PPUSH
1938: CALL_OW 486
// uc_side := 4 ;
1942: LD_ADDR_OWVAR 20
1946: PUSH
1947: LD_INT 4
1949: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
1950: LD_ADDR_EXP 17
1954: PUSH
1955: LD_STRING Harisson
1957: PPUSH
1958: LD_INT 0
1960: PPUSH
1961: LD_STRING 
1963: PPUSH
1964: CALL 3635 0 3
1968: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
1969: LD_ADDR_VAR 0 5
1973: PUSH
1974: LD_INT 4
1976: PPUSH
1977: LD_INT 1
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 1
1985: PPUSH
1986: LD_INT 1
1988: PPUSH
1989: LD_INT 2
1991: PPUSH
1992: LD_INT 100
1994: PPUSH
1995: CALL 3698 0 7
1999: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2000: LD_VAR 0 5
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2012: LD_VAR 0 5
2016: PPUSH
2017: LD_INT 21
2019: PPUSH
2020: LD_INT 8
2022: PPUSH
2023: LD_INT 0
2025: PPUSH
2026: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2030: LD_EXP 17
2034: PPUSH
2035: LD_VAR 0 5
2039: PPUSH
2040: CALL_OW 52
// end ;
2044: LD_VAR 0 1
2048: RET
// function PrepareBase ; var blist , i , b ; begin
2049: LD_INT 0
2051: PPUSH
2052: PPUSH
2053: PPUSH
2054: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2055: LD_INT 71
2057: PPUSH
2058: LD_INT 5
2060: PPUSH
2061: LD_INT 1
2063: PPUSH
2064: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2068: LD_ADDR_VAR 0 2
2072: PUSH
2073: LD_STRING GammaBase
2075: PPUSH
2076: EMPTY
2077: PPUSH
2078: CALL_OW 30
2082: ST_TO_ADDR
// if not blist and debug then
2083: LD_VAR 0 2
2087: NOT
2088: PUSH
2089: LD_EXP 1
2093: AND
2094: IFFALSE 2134
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2096: LD_ADDR_VAR 0 2
2100: PUSH
2101: LD_INT 0
2103: PUSH
2104: LD_INT 51
2106: PUSH
2107: LD_INT 10
2109: PUSH
2110: LD_INT 3
2112: PUSH
2113: LD_INT 3
2115: PUSH
2116: LD_INT 0
2118: PUSH
2119: LD_INT 0
2121: PUSH
2122: EMPTY
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: LIST
2130: PUSH
2131: EMPTY
2132: LIST
2133: ST_TO_ADDR
// if not blist then
2134: LD_VAR 0 2
2138: NOT
2139: IFFALSE 2143
// exit ;
2141: GO 2323
// uc_side := 1 ;
2143: LD_ADDR_OWVAR 20
2147: PUSH
2148: LD_INT 1
2150: ST_TO_ADDR
// uc_nation := 1 ;
2151: LD_ADDR_OWVAR 21
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// for i in blist do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2321
// begin bc_type := i [ 1 ] ;
2172: LD_ADDR_OWVAR 42
2176: PUSH
2177: LD_VAR 0 3
2181: PUSH
2182: LD_INT 1
2184: ARRAY
2185: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2186: LD_ADDR_OWVAR 43
2190: PUSH
2191: LD_VAR 0 3
2195: PUSH
2196: LD_INT 5
2198: ARRAY
2199: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2200: LD_VAR 0 3
2204: PUSH
2205: LD_INT 1
2207: ARRAY
2208: PUSH
2209: LD_INT 7
2211: PUSH
2212: LD_INT 8
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: IN
2219: IFFALSE 2249
// begin bc_kind1 := i [ 7 ] ;
2221: LD_ADDR_OWVAR 44
2225: PUSH
2226: LD_VAR 0 3
2230: PUSH
2231: LD_INT 7
2233: ARRAY
2234: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2235: LD_ADDR_OWVAR 45
2239: PUSH
2240: LD_VAR 0 3
2244: PUSH
2245: LD_INT 8
2247: ARRAY
2248: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2249: LD_ADDR_VAR 0 4
2253: PUSH
2254: LD_VAR 0 3
2258: PUSH
2259: LD_INT 2
2261: ARRAY
2262: PPUSH
2263: LD_VAR 0 3
2267: PUSH
2268: LD_INT 3
2270: ARRAY
2271: PPUSH
2272: LD_VAR 0 3
2276: PUSH
2277: LD_INT 4
2279: ARRAY
2280: PPUSH
2281: CALL_OW 47
2285: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2286: LD_VAR 0 4
2290: PPUSH
2291: CALL_OW 266
2295: PUSH
2296: LD_INT 32
2298: EQUAL
2299: IFFALSE 2319
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2301: LD_VAR 0 4
2305: PPUSH
2306: LD_VAR 0 3
2310: PUSH
2311: LD_INT 7
2313: ARRAY
2314: PPUSH
2315: CALL_OW 431
// end ; end ;
2319: GO 2169
2321: POP
2322: POP
// end ; end_of_file
2323: LD_VAR 0 1
2327: RET
// export function Action ; var points , i , sol , team , filter ; begin
2328: LD_INT 0
2330: PPUSH
2331: PPUSH
2332: PPUSH
2333: PPUSH
2334: PPUSH
2335: PPUSH
// InGameOn ;
2336: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2340: LD_INT 33
2342: PPUSH
2343: LD_INT 11
2345: PPUSH
2346: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: LD_INT 29
2357: PUSH
2358: LD_INT 21
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PUSH
2365: LD_INT 41
2367: PUSH
2368: LD_INT 28
2370: PUSH
2371: EMPTY
2372: LIST
2373: LIST
2374: PUSH
2375: LD_INT 52
2377: PUSH
2378: LD_INT 26
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PUSH
2385: LD_INT 49
2387: PUSH
2388: LD_INT 16
2390: PUSH
2391: EMPTY
2392: LIST
2393: LIST
2394: PUSH
2395: EMPTY
2396: LIST
2397: LIST
2398: LIST
2399: LIST
2400: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2401: LD_ADDR_VAR 0 4
2405: PUSH
2406: LD_INT 22
2408: PUSH
2409: LD_INT 1
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 26
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: EMPTY
2423: LIST
2424: LIST
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PPUSH
2430: CALL_OW 69
2434: PUSH
2435: LD_EXP 7
2439: PUSH
2440: LD_EXP 14
2444: PUSH
2445: LD_EXP 11
2449: PUSH
2450: LD_EXP 12
2454: PUSH
2455: LD_EXP 8
2459: PUSH
2460: LD_EXP 15
2464: PUSH
2465: LD_EXP 16
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: LIST
2478: DIFF
2479: PUSH
2480: LD_INT 1
2482: ARRAY
2483: ST_TO_ADDR
// if sol then
2484: LD_VAR 0 4
2488: IFFALSE 2519
// begin ComMoveXY ( sol , 50 , 18 ) ;
2490: LD_VAR 0 4
2494: PPUSH
2495: LD_INT 50
2497: PPUSH
2498: LD_INT 18
2500: PPUSH
2501: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2505: LD_VAR 0 4
2509: PPUSH
2510: LD_EXP 17
2514: PPUSH
2515: CALL_OW 179
// end ; for i in points do
2519: LD_ADDR_VAR 0 3
2523: PUSH
2524: LD_VAR 0 2
2528: PUSH
2529: FOR_IN
2530: IFFALSE 2561
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2532: LD_EXP 17
2536: PPUSH
2537: LD_VAR 0 3
2541: PUSH
2542: LD_INT 1
2544: ARRAY
2545: PPUSH
2546: LD_VAR 0 3
2550: PUSH
2551: LD_INT 2
2553: ARRAY
2554: PPUSH
2555: CALL_OW 171
2559: GO 2529
2561: POP
2562: POP
// AddComExitVehicle ( Harisson ) ;
2563: LD_EXP 17
2567: PPUSH
2568: CALL_OW 181
// repeat wait ( 3 ) ;
2572: LD_INT 3
2574: PPUSH
2575: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2579: LD_EXP 17
2583: PPUSH
2584: CALL_OW 310
2588: NOT
2589: IFFALSE 2572
// Say ( sol , D1-Sol1-1 ) ;
2591: LD_VAR 0 4
2595: PPUSH
2596: LD_STRING D1-Sol1-1
2598: PPUSH
2599: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2603: LD_EXP 17
2607: PPUSH
2608: LD_VAR 0 4
2612: PPUSH
2613: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2617: LD_EXP 17
2621: PPUSH
2622: LD_STRING D1-Har-1
2624: PPUSH
2625: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2629: LD_INT 10
2631: PPUSH
2632: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2636: LD_VAR 0 4
2640: PPUSH
2641: LD_INT 35
2643: PPUSH
2644: LD_INT 21
2646: PPUSH
2647: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2651: LD_EXP 7
2655: PPUSH
2656: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2660: LD_EXP 7
2664: PPUSH
2665: LD_EXP 17
2669: PPUSH
2670: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2674: LD_EXP 17
2678: PPUSH
2679: LD_EXP 7
2683: PPUSH
2684: CALL_OW 119
// repeat wait ( 3 ) ;
2688: LD_INT 3
2690: PPUSH
2691: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2695: LD_EXP 7
2699: PPUSH
2700: LD_EXP 17
2704: PPUSH
2705: CALL_OW 296
2709: PUSH
2710: LD_INT 4
2712: LESS
2713: IFFALSE 2688
// ComTurnUnit ( JMM , Harisson ) ;
2715: LD_EXP 7
2719: PPUSH
2720: LD_EXP 17
2724: PPUSH
2725: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2729: LD_EXP 7
2733: PPUSH
2734: LD_STRING D1-JMM-1
2736: PPUSH
2737: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2741: LD_EXP 17
2745: PPUSH
2746: LD_STRING D1-Har-2
2748: PPUSH
2749: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
2753: LD_EXP 7
2757: PPUSH
2758: LD_STRING D1-JMM-2
2760: PPUSH
2761: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
2765: LD_EXP 17
2769: PPUSH
2770: LD_STRING D1-Har-3
2772: PPUSH
2773: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2777: LD_EXP 7
2781: PPUSH
2782: LD_STRING D1-JMM-3
2784: PPUSH
2785: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
2789: LD_EXP 17
2793: PPUSH
2794: LD_STRING D1-Har-4
2796: PPUSH
2797: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
2801: LD_EXP 7
2805: PPUSH
2806: LD_STRING D1-JMM-4
2808: PPUSH
2809: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
2813: LD_EXP 17
2817: PPUSH
2818: LD_STRING D1-Har-5
2820: PPUSH
2821: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
2825: LD_EXP 7
2829: PPUSH
2830: LD_STRING D1-JMM-5
2832: PPUSH
2833: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
2837: LD_EXP 17
2841: PPUSH
2842: LD_STRING D1-Har-6
2844: PPUSH
2845: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
2849: LD_EXP 7
2853: PPUSH
2854: LD_STRING D1-JMM-6
2856: PPUSH
2857: CALL_OW 88
// EndMission ;
2861: CALL 2870 0 0
// end ;
2865: LD_VAR 0 1
2869: RET
// export function EndMission ; var commander , i , all ; begin
2870: LD_INT 0
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
// case gamma_commander of 1 :
2876: LD_EXP 18
2880: PUSH
2881: LD_INT 1
2883: DOUBLE
2884: EQUAL
2885: IFTRUE 2889
2887: GO 2902
2889: POP
// commander := Donaldson ; 2 :
2890: LD_ADDR_VAR 0 2
2894: PUSH
2895: LD_EXP 13
2899: ST_TO_ADDR
2900: GO 2945
2902: LD_INT 2
2904: DOUBLE
2905: EQUAL
2906: IFTRUE 2910
2908: GO 2923
2910: POP
// commander := Brown ; 3 :
2911: LD_ADDR_VAR 0 2
2915: PUSH
2916: LD_EXP 14
2920: ST_TO_ADDR
2921: GO 2945
2923: LD_INT 3
2925: DOUBLE
2926: EQUAL
2927: IFTRUE 2931
2929: GO 2944
2931: POP
// commander := Houten ; end ;
2932: LD_ADDR_VAR 0 2
2936: PUSH
2937: LD_EXP 15
2941: ST_TO_ADDR
2942: GO 2945
2944: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
2945: LD_ADDR_VAR 0 4
2949: PUSH
2950: LD_INT 22
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: PUSH
2960: LD_INT 21
2962: PUSH
2963: LD_INT 1
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PPUSH
2974: CALL_OW 69
2978: PUSH
2979: LD_EXP 7
2983: PUSH
2984: LD_VAR 0 2
2988: PUSH
2989: EMPTY
2990: LIST
2991: LIST
2992: DIFF
2993: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
2994: LD_ADDR_EXP 4
2998: PUSH
2999: LD_STRING 1
3001: PPUSH
3002: LD_INT 10
3004: PPUSH
3005: LD_INT 10
3007: PPUSH
3008: LD_INT -5
3010: PUSH
3011: LD_EXP 7
3015: PUSH
3016: LD_INT -2
3018: PUSH
3019: LD_INT -3
3021: PUSH
3022: LD_INT -5
3024: PUSH
3025: EMPTY
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: LIST
3031: PUSH
3032: LD_VAR 0 4
3036: ADD
3037: PUSH
3038: LD_INT -6
3040: PUSH
3041: LD_INT -4
3043: PUSH
3044: LD_VAR 0 2
3048: PUSH
3049: LD_EXP 17
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: ADD
3063: PPUSH
3064: LD_INT 1
3066: PUSH
3067: LD_INT 3
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: PUSH
3074: LD_INT 3
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 6
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: PUSH
3088: LD_INT 4
3090: PUSH
3091: LD_INT 1
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: LIST
3102: PPUSH
3103: CALL_OW 42
3107: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3108: LD_VAR 0 4
3112: PUSH
3113: LD_EXP 7
3117: PUSH
3118: LD_EXP 8
3122: PUSH
3123: LD_EXP 10
3127: PUSH
3128: LD_EXP 11
3132: PUSH
3133: LD_EXP 12
3137: PUSH
3138: LD_EXP 9
3142: PUSH
3143: LD_EXP 13
3147: PUSH
3148: LD_EXP 14
3152: PUSH
3153: LD_EXP 15
3157: PUSH
3158: LD_EXP 17
3162: PUSH
3163: LD_EXP 16
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: LD_EXP 4
3185: ADD
3186: DIFF
3187: PPUSH
3188: LD_STRING 07_othersGamma
3190: PPUSH
3191: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3195: LD_EXP 4
3199: PUSH
3200: LD_EXP 7
3204: PUSH
3205: LD_EXP 8
3209: PUSH
3210: LD_EXP 10
3214: PUSH
3215: LD_EXP 11
3219: PUSH
3220: LD_EXP 12
3224: PUSH
3225: LD_EXP 9
3229: PUSH
3230: LD_EXP 13
3234: PUSH
3235: LD_EXP 14
3239: PUSH
3240: LD_EXP 15
3244: PUSH
3245: LD_EXP 17
3249: PUSH
3250: LD_EXP 16
3254: PUSH
3255: LD_INT 0
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: DIFF
3272: PPUSH
3273: LD_STRING 07_others
3275: PPUSH
3276: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3280: LD_EXP 7
3284: PPUSH
3285: LD_EXP 5
3289: PUSH
3290: LD_STRING JMM
3292: STR
3293: PPUSH
3294: CALL_OW 38
// if Lisa then
3298: LD_EXP 10
3302: IFFALSE 3344
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3304: LD_EXP 10
3308: PPUSH
3309: LD_EXP 5
3313: PUSH
3314: LD_STRING Lisa
3316: STR
3317: PPUSH
3318: CALL_OW 38
// if Lisa in save_group then
3322: LD_EXP 10
3326: PUSH
3327: LD_EXP 4
3331: IN
3332: IFFALSE 3344
// SaveVariable ( true , LisaIn07 ) ;
3334: LD_INT 1
3336: PPUSH
3337: LD_STRING LisaIn07
3339: PPUSH
3340: CALL_OW 39
// end ; if Bobby then
3344: LD_EXP 12
3348: IFFALSE 3390
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3350: LD_EXP 12
3354: PPUSH
3355: LD_EXP 5
3359: PUSH
3360: LD_STRING Bobby
3362: STR
3363: PPUSH
3364: CALL_OW 38
// if Bobby in save_group then
3368: LD_EXP 12
3372: PUSH
3373: LD_EXP 4
3377: IN
3378: IFFALSE 3390
// SaveVariable ( true , BobbyIn07 ) ;
3380: LD_INT 1
3382: PPUSH
3383: LD_STRING BobbyIn07
3385: PPUSH
3386: CALL_OW 39
// end ; if Cyrus then
3390: LD_EXP 11
3394: IFFALSE 3436
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3396: LD_EXP 11
3400: PPUSH
3401: LD_EXP 5
3405: PUSH
3406: LD_STRING Cyrus
3408: STR
3409: PPUSH
3410: CALL_OW 38
// if Cyrus in save_group then
3414: LD_EXP 11
3418: PUSH
3419: LD_EXP 4
3423: IN
3424: IFFALSE 3436
// SaveVariable ( true , CyrusIn07 ) ;
3426: LD_INT 1
3428: PPUSH
3429: LD_STRING CyrusIn07
3431: PPUSH
3432: CALL_OW 39
// end ; if Brown then
3436: LD_EXP 14
3440: IFFALSE 3482
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3442: LD_EXP 14
3446: PPUSH
3447: LD_EXP 5
3451: PUSH
3452: LD_STRING Brown
3454: STR
3455: PPUSH
3456: CALL_OW 38
// if Brown in save_group then
3460: LD_EXP 14
3464: PUSH
3465: LD_EXP 4
3469: IN
3470: IFFALSE 3482
// SaveVariable ( true , BrownIn07 ) ;
3472: LD_INT 1
3474: PPUSH
3475: LD_STRING BrownIn07
3477: PPUSH
3478: CALL_OW 39
// end ; if Donaldson then
3482: LD_EXP 13
3486: IFFALSE 3528
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3488: LD_EXP 13
3492: PPUSH
3493: LD_EXP 5
3497: PUSH
3498: LD_STRING Donaldson
3500: STR
3501: PPUSH
3502: CALL_OW 38
// if Donaldson in save_group then
3506: LD_EXP 13
3510: PUSH
3511: LD_EXP 4
3515: IN
3516: IFFALSE 3528
// SaveVariable ( true , DonaldsonIn07 ) ;
3518: LD_INT 1
3520: PPUSH
3521: LD_STRING DonaldsonIn07
3523: PPUSH
3524: CALL_OW 39
// end ; if Gladstone then
3528: LD_EXP 8
3532: IFFALSE 3574
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3534: LD_EXP 8
3538: PPUSH
3539: LD_EXP 5
3543: PUSH
3544: LD_STRING Gladstone
3546: STR
3547: PPUSH
3548: CALL_OW 38
// if Gladstone in save_group then
3552: LD_EXP 8
3556: PUSH
3557: LD_EXP 4
3561: IN
3562: IFFALSE 3574
// SaveVariable ( true , GladstoneIn07 ) ;
3564: LD_INT 1
3566: PPUSH
3567: LD_STRING GladstoneIn07
3569: PPUSH
3570: CALL_OW 39
// end ; if Khatam then
3574: LD_EXP 16
3578: IFFALSE 3620
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3580: LD_EXP 16
3584: PPUSH
3585: LD_EXP 5
3589: PUSH
3590: LD_STRING Khatam
3592: STR
3593: PPUSH
3594: CALL_OW 38
// if Khatam in save_group then
3598: LD_EXP 16
3602: PUSH
3603: LD_EXP 4
3607: IN
3608: IFFALSE 3620
// SaveVariable ( true , KhatamIn07 ) ;
3610: LD_INT 1
3612: PPUSH
3613: LD_STRING KhatamIn07
3615: PPUSH
3616: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3620: LD_INT 1
3622: PPUSH
3623: LD_STRING %_cont
3625: PPUSH
3626: CALL_OW 340
// end ; end_of_file
3630: LD_VAR 0 1
3634: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3635: LD_INT 0
3637: PPUSH
3638: PPUSH
// if exist_mode then
3639: LD_VAR 0 2
3643: IFFALSE 3668
// unit := CreateCharacter ( prefix & ident ) else
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_VAR 0 3
3654: PUSH
3655: LD_VAR 0 1
3659: STR
3660: PPUSH
3661: CALL_OW 34
3665: ST_TO_ADDR
3666: GO 3683
// unit := NewCharacter ( ident ) ;
3668: LD_ADDR_VAR 0 5
3672: PUSH
3673: LD_VAR 0 1
3677: PPUSH
3678: CALL_OW 25
3682: ST_TO_ADDR
// result := unit ;
3683: LD_ADDR_VAR 0 4
3687: PUSH
3688: LD_VAR 0 5
3692: ST_TO_ADDR
// end ;
3693: LD_VAR 0 4
3697: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3698: LD_INT 0
3700: PPUSH
// uc_side := side ;
3701: LD_ADDR_OWVAR 20
3705: PUSH
3706: LD_VAR 0 1
3710: ST_TO_ADDR
// uc_nation := nation ;
3711: LD_ADDR_OWVAR 21
3715: PUSH
3716: LD_VAR 0 2
3720: ST_TO_ADDR
// vc_chassis := chassis ;
3721: LD_ADDR_OWVAR 37
3725: PUSH
3726: LD_VAR 0 3
3730: ST_TO_ADDR
// vc_engine := engine ;
3731: LD_ADDR_OWVAR 39
3735: PUSH
3736: LD_VAR 0 4
3740: ST_TO_ADDR
// vc_control := control ;
3741: LD_ADDR_OWVAR 38
3745: PUSH
3746: LD_VAR 0 5
3750: ST_TO_ADDR
// vc_weapon := weapon ;
3751: LD_ADDR_OWVAR 40
3755: PUSH
3756: LD_VAR 0 6
3760: ST_TO_ADDR
// vc_fuel_battery := fuel ;
3761: LD_ADDR_OWVAR 41
3765: PUSH
3766: LD_VAR 0 7
3770: ST_TO_ADDR
// result := CreateVehicle ;
3771: LD_ADDR_VAR 0 8
3775: PUSH
3776: CALL_OW 45
3780: ST_TO_ADDR
// end ;
3781: LD_VAR 0 8
3785: RET
// export function SayX ( units , ident ) ; var i ; begin
3786: LD_INT 0
3788: PPUSH
3789: PPUSH
// result := false ;
3790: LD_ADDR_VAR 0 3
3794: PUSH
3795: LD_INT 0
3797: ST_TO_ADDR
// if not units then
3798: LD_VAR 0 1
3802: NOT
3803: IFFALSE 3807
// exit ;
3805: GO 3861
// for i in units do
3807: LD_ADDR_VAR 0 4
3811: PUSH
3812: LD_VAR 0 1
3816: PUSH
3817: FOR_IN
3818: IFFALSE 3859
// if IsOk ( i ) then
3820: LD_VAR 0 4
3824: PPUSH
3825: CALL_OW 302
3829: IFFALSE 3857
// begin Say ( i , ident ) ;
3831: LD_VAR 0 4
3835: PPUSH
3836: LD_VAR 0 2
3840: PPUSH
3841: CALL_OW 88
// result := i ;
3845: LD_ADDR_VAR 0 3
3849: PUSH
3850: LD_VAR 0 4
3854: ST_TO_ADDR
// break ;
3855: GO 3859
// end ;
3857: GO 3817
3859: POP
3860: POP
// end ;
3861: LD_VAR 0 3
3865: RET
