// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2501 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2222 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3808 0 3
 179: ST_TO_ADDR
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 180: LD_ADDR_EXP 18
 184: PUSH
 185: LD_STRING GammaCommander
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: CALL_OW 30
 195: ST_TO_ADDR
// if gamma_commander = 1 then
 196: LD_EXP 18
 200: PUSH
 201: LD_INT 1
 203: EQUAL
 204: IFFALSE 230
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 206: LD_ADDR_EXP 13
 210: PUSH
 211: LD_STRING Donaldson
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 04_
 222: PPUSH
 223: CALL 3808 0 3
 227: ST_TO_ADDR
// end else
 228: GO 301
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 230: LD_STRING DonaldsonIn06
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: IFFALSE 266
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 242: LD_ADDR_EXP 13
 246: PUSH
 247: LD_STRING Donaldson
 249: PPUSH
 250: LD_EXP 1
 254: NOT
 255: PPUSH
 256: LD_STRING 06c_
 258: PPUSH
 259: CALL 3808 0 3
 263: ST_TO_ADDR
 264: GO 301
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 266: LD_STRING DonaldsonStayInDelta
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: NOT
 277: IFFALSE 301
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 279: LD_ADDR_EXP 13
 283: PUSH
 284: LD_STRING Donaldson
 286: PPUSH
 287: LD_EXP 1
 291: NOT
 292: PPUSH
 293: LD_STRING 04_
 295: PPUSH
 296: CALL 3808 0 3
 300: ST_TO_ADDR
// end ; if Donaldson then
 301: LD_EXP 13
 305: IFFALSE 323
// team := team ^ Donaldson ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_EXP 13
 321: ADD
 322: ST_TO_ADDR
// if gamma_commander = 2 then
 323: LD_EXP 18
 327: PUSH
 328: LD_INT 2
 330: EQUAL
 331: IFFALSE 357
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 333: LD_ADDR_EXP 14
 337: PUSH
 338: LD_STRING Brown
 340: PPUSH
 341: LD_EXP 1
 345: NOT
 346: PPUSH
 347: LD_STRING 04_
 349: PPUSH
 350: CALL 3808 0 3
 354: ST_TO_ADDR
// end else
 355: GO 428
// begin if LoadVariable ( BrownIn06 , 0 ) then
 357: LD_STRING BrownIn06
 359: PPUSH
 360: LD_INT 0
 362: PPUSH
 363: CALL_OW 30
 367: IFFALSE 393
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 369: LD_ADDR_EXP 14
 373: PUSH
 374: LD_STRING Brown
 376: PPUSH
 377: LD_EXP 1
 381: NOT
 382: PPUSH
 383: LD_STRING 06c_
 385: PPUSH
 386: CALL 3808 0 3
 390: ST_TO_ADDR
 391: GO 428
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 393: LD_STRING BrownStayInDelta
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: CALL_OW 30
 403: NOT
 404: IFFALSE 428
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 406: LD_ADDR_EXP 14
 410: PUSH
 411: LD_STRING Brown
 413: PPUSH
 414: LD_EXP 1
 418: NOT
 419: PPUSH
 420: LD_STRING 04_
 422: PPUSH
 423: CALL 3808 0 3
 427: ST_TO_ADDR
// end ; if Brown then
 428: LD_EXP 14
 432: IFFALSE 450
// team := team ^ Brown ;
 434: LD_ADDR_VAR 0 6
 438: PUSH
 439: LD_VAR 0 6
 443: PUSH
 444: LD_EXP 14
 448: ADD
 449: ST_TO_ADDR
// if gamma_commander = 3 then
 450: LD_EXP 18
 454: PUSH
 455: LD_INT 3
 457: EQUAL
 458: IFFALSE 495
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 460: LD_ADDR_EXP 15
 464: PUSH
 465: LD_STRING VanHouten
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: LD_STRING 
 473: PPUSH
 474: CALL 3808 0 3
 478: ST_TO_ADDR
// team := team ^ Houten ;
 479: LD_ADDR_VAR 0 6
 483: PUSH
 484: LD_VAR 0 6
 488: PUSH
 489: LD_EXP 15
 493: ADD
 494: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 495: LD_STRING GladstoneIn06
 497: PPUSH
 498: LD_INT 0
 500: PPUSH
 501: CALL_OW 30
 505: IFFALSE 531
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 507: LD_ADDR_EXP 8
 511: PUSH
 512: LD_STRING Gladstone
 514: PPUSH
 515: LD_EXP 1
 519: NOT
 520: PPUSH
 521: LD_STRING 06c_
 523: PPUSH
 524: CALL 3808 0 3
 528: ST_TO_ADDR
 529: GO 565
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 531: LD_STRING GladstoneStayInDelta
 533: PPUSH
 534: LD_INT 0
 536: PPUSH
 537: CALL_OW 30
 541: IFFALSE 565
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 543: LD_ADDR_EXP 8
 547: PUSH
 548: LD_STRING Gladstone
 550: PPUSH
 551: LD_EXP 1
 555: NOT
 556: PPUSH
 557: LD_STRING 06_
 559: PPUSH
 560: CALL 3808 0 3
 564: ST_TO_ADDR
// if Gladstone then
 565: LD_EXP 8
 569: IFFALSE 587
// team := team ^ Gladstone ;
 571: LD_ADDR_VAR 0 6
 575: PUSH
 576: LD_VAR 0 6
 580: PUSH
 581: LD_EXP 8
 585: ADD
 586: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 587: LD_ADDR_EXP 16
 591: PUSH
 592: LD_STRING Khatam
 594: PPUSH
 595: LD_EXP 1
 599: NOT
 600: PPUSH
 601: LD_STRING 03_
 603: PPUSH
 604: CALL 3808 0 3
 608: ST_TO_ADDR
// if Khatam then
 609: LD_EXP 16
 613: IFFALSE 631
// team := team ^ Khatam ;
 615: LD_ADDR_VAR 0 6
 619: PUSH
 620: LD_VAR 0 6
 624: PUSH
 625: LD_EXP 16
 629: ADD
 630: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 631: LD_STRING LisaIn06
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 30
 641: IFFALSE 667
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 643: LD_ADDR_EXP 10
 647: PUSH
 648: LD_STRING Lisa
 650: PPUSH
 651: LD_EXP 1
 655: NOT
 656: PPUSH
 657: LD_STRING 06c_
 659: PPUSH
 660: CALL 3808 0 3
 664: ST_TO_ADDR
 665: GO 702
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 667: LD_STRING LisaStayInDelta
 669: PPUSH
 670: LD_INT 0
 672: PPUSH
 673: CALL_OW 30
 677: NOT
 678: IFFALSE 702
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 680: LD_ADDR_EXP 10
 684: PUSH
 685: LD_STRING Lisa
 687: PPUSH
 688: LD_EXP 1
 692: NOT
 693: PPUSH
 694: LD_STRING 04_
 696: PPUSH
 697: CALL 3808 0 3
 701: ST_TO_ADDR
// if Lisa then
 702: LD_EXP 10
 706: IFFALSE 724
// team := team ^ Lisa ;
 708: LD_ADDR_VAR 0 6
 712: PUSH
 713: LD_VAR 0 6
 717: PUSH
 718: LD_EXP 10
 722: ADD
 723: ST_TO_ADDR
// if not Lisa then
 724: LD_EXP 10
 728: NOT
 729: IFFALSE 982
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 731: LD_STRING CyrusIn06
 733: PPUSH
 734: LD_INT 0
 736: PPUSH
 737: CALL_OW 30
 741: IFFALSE 767
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 743: LD_ADDR_EXP 11
 747: PUSH
 748: LD_STRING Cyrus
 750: PPUSH
 751: LD_EXP 1
 755: NOT
 756: PPUSH
 757: LD_STRING 06c_
 759: PPUSH
 760: CALL 3808 0 3
 764: ST_TO_ADDR
 765: GO 831
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 767: LD_STRING CyrusStayInDelta
 769: PPUSH
 770: LD_INT 0
 772: PPUSH
 773: CALL_OW 30
 777: NOT
 778: IFFALSE 831
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 780: LD_ADDR_EXP 11
 784: PUSH
 785: LD_STRING Cyrus
 787: PPUSH
 788: LD_EXP 1
 792: NOT
 793: PPUSH
 794: LD_STRING 04_
 796: PPUSH
 797: CALL 3808 0 3
 801: ST_TO_ADDR
// if not Cyrus then
 802: LD_EXP 11
 806: NOT
 807: IFFALSE 831
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 809: LD_ADDR_EXP 11
 813: PUSH
 814: LD_STRING Cyrus
 816: PPUSH
 817: LD_EXP 1
 821: NOT
 822: PPUSH
 823: LD_STRING 03_
 825: PPUSH
 826: CALL 3808 0 3
 830: ST_TO_ADDR
// end ; if Cyrus then
 831: LD_EXP 11
 835: IFFALSE 853
// team := team ^ Cyrus ;
 837: LD_ADDR_VAR 0 6
 841: PUSH
 842: LD_VAR 0 6
 846: PUSH
 847: LD_EXP 11
 851: ADD
 852: ST_TO_ADDR
// if not Cyrus then
 853: LD_EXP 11
 857: NOT
 858: IFFALSE 982
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 860: LD_STRING BobbyIn06
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: CALL_OW 30
 870: IFFALSE 896
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 872: LD_ADDR_EXP 12
 876: PUSH
 877: LD_STRING Bobby
 879: PPUSH
 880: LD_EXP 1
 884: NOT
 885: PPUSH
 886: LD_STRING 06c_
 888: PPUSH
 889: CALL 3808 0 3
 893: ST_TO_ADDR
 894: GO 960
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 896: LD_STRING BobbyStayInDelta
 898: PPUSH
 899: LD_INT 0
 901: PPUSH
 902: CALL_OW 30
 906: NOT
 907: IFFALSE 960
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 909: LD_ADDR_EXP 12
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 04_
 925: PPUSH
 926: CALL 3808 0 3
 930: ST_TO_ADDR
// if not Bobby then
 931: LD_EXP 12
 935: NOT
 936: IFFALSE 960
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 938: LD_ADDR_EXP 12
 942: PUSH
 943: LD_STRING Bobby
 945: PPUSH
 946: LD_EXP 1
 950: NOT
 951: PPUSH
 952: LD_STRING 03_
 954: PPUSH
 955: CALL 3808 0 3
 959: ST_TO_ADDR
// end ; if Bobby then
 960: LD_EXP 12
 964: IFFALSE 982
// team := team ^ Bobby ;
 966: LD_ADDR_VAR 0 6
 970: PUSH
 971: LD_VAR 0 6
 975: PUSH
 976: LD_EXP 12
 980: ADD
 981: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
 982: LD_ADDR_VAR 0 4
 986: PUSH
 987: LD_STRING othersGamma
 989: PPUSH
 990: CALL_OW 31
 994: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
 995: LD_ADDR_VAR 0 2
 999: PUSH
1000: LD_STRING 06_other_survivors
1002: PPUSH
1003: CALL_OW 31
1007: ST_TO_ADDR
// others := others union others4 ;
1008: LD_ADDR_VAR 0 2
1012: PUSH
1013: LD_VAR 0 2
1017: PUSH
1018: LD_VAR 0 4
1022: UNION
1023: ST_TO_ADDR
// team := team ^ others ;
1024: LD_ADDR_VAR 0 6
1028: PUSH
1029: LD_VAR 0 6
1033: PUSH
1034: LD_VAR 0 2
1038: ADD
1039: ST_TO_ADDR
// for i in others do
1040: LD_ADDR_VAR 0 13
1044: PUSH
1045: LD_VAR 0 2
1049: PUSH
1050: FOR_IN
1051: IFFALSE 1119
// begin if GetClass ( i ) = 2 then
1053: LD_VAR 0 13
1057: PPUSH
1058: CALL_OW 257
1062: PUSH
1063: LD_INT 2
1065: EQUAL
1066: IFFALSE 1080
// SetClass ( i , 1 ) ;
1068: LD_VAR 0 13
1072: PPUSH
1073: LD_INT 1
1075: PPUSH
1076: CALL_OW 336
// for j = 1 to 4 do
1080: LD_ADDR_VAR 0 14
1084: PUSH
1085: DOUBLE
1086: LD_INT 1
1088: DEC
1089: ST_TO_ADDR
1090: LD_INT 4
1092: PUSH
1093: FOR_TO
1094: IFFALSE 1115
// AddExperience ( i , j , 3000 ) ;
1096: LD_VAR 0 13
1100: PPUSH
1101: LD_VAR 0 14
1105: PPUSH
1106: LD_INT 3000
1108: PPUSH
1109: CALL_OW 492
1113: GO 1093
1115: POP
1116: POP
// end ;
1117: GO 1050
1119: POP
1120: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1121: LD_ADDR_VAR 0 7
1125: PUSH
1126: LD_INT 30
1128: PUSH
1129: LD_INT 0
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: PPUSH
1136: CALL_OW 69
1140: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1141: LD_ADDR_VAR 0 8
1145: PUSH
1146: LD_INT 30
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: PPUSH
1156: CALL_OW 69
1160: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1161: LD_ADDR_VAR 0 9
1165: PUSH
1166: LD_INT 2
1168: PUSH
1169: LD_INT 30
1171: PUSH
1172: LD_INT 7
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: PUSH
1179: LD_INT 30
1181: PUSH
1182: LD_INT 6
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: PUSH
1189: EMPTY
1190: LIST
1191: LIST
1192: LIST
1193: PPUSH
1194: CALL_OW 69
1198: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1199: LD_ADDR_VAR 0 10
1203: PUSH
1204: LD_INT 30
1206: PUSH
1207: LD_INT 3
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: PPUSH
1214: CALL_OW 69
1218: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1219: LD_ADDR_VAR 0 11
1223: PUSH
1224: LD_INT 2
1226: PUSH
1227: LD_INT 30
1229: PUSH
1230: LD_INT 32
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 30
1239: PUSH
1240: LD_INT 31
1242: PUSH
1243: EMPTY
1244: LIST
1245: LIST
1246: PUSH
1247: EMPTY
1248: LIST
1249: LIST
1250: LIST
1251: PPUSH
1252: CALL_OW 69
1256: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1257: LD_VAR 0 7
1261: PPUSH
1262: LD_STRING Gamma
1264: PPUSH
1265: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1269: LD_VAR 0 7
1273: PPUSH
1274: CALL_OW 274
1278: PPUSH
1279: LD_INT 2
1281: PPUSH
1282: LD_INT 10000
1284: PPUSH
1285: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1289: LD_VAR 0 7
1293: PPUSH
1294: CALL_OW 274
1298: PPUSH
1299: LD_INT 1
1301: PPUSH
1302: LD_INT 10000
1304: PPUSH
1305: CALL_OW 277
// if dep then
1309: LD_VAR 0 7
1313: IFFALSE 1413
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1315: LD_EXP 7
1319: PPUSH
1320: LD_VAR 0 7
1324: PUSH
1325: LD_INT 1
1327: ARRAY
1328: PPUSH
1329: CALL_OW 52
// if Brown then
1333: LD_EXP 14
1337: IFFALSE 1373
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1339: LD_EXP 14
1343: PPUSH
1344: LD_VAR 0 7
1348: PUSH
1349: LD_INT 1
1351: ARRAY
1352: PPUSH
1353: CALL_OW 52
// team := team diff Brown ;
1357: LD_ADDR_VAR 0 6
1361: PUSH
1362: LD_VAR 0 6
1366: PUSH
1367: LD_EXP 14
1371: DIFF
1372: ST_TO_ADDR
// end ; if Donaldson then
1373: LD_EXP 13
1377: IFFALSE 1413
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1379: LD_EXP 13
1383: PPUSH
1384: LD_VAR 0 7
1388: PUSH
1389: LD_INT 1
1391: ARRAY
1392: PPUSH
1393: CALL_OW 52
// team := team diff Donaldson ;
1397: LD_ADDR_VAR 0 6
1401: PUSH
1402: LD_VAR 0 6
1406: PUSH
1407: LD_EXP 13
1411: DIFF
1412: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1413: LD_VAR 0 11
1417: PUSH
1418: LD_VAR 0 6
1422: PPUSH
1423: LD_INT 25
1425: PUSH
1426: LD_INT 1
1428: PUSH
1429: EMPTY
1430: LIST
1431: LIST
1432: PPUSH
1433: CALL_OW 72
1437: AND
1438: IFFALSE 1547
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1440: LD_ADDR_VAR 0 12
1444: PUSH
1445: LD_VAR 0 6
1449: PPUSH
1450: LD_INT 25
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: EMPTY
1457: LIST
1458: LIST
1459: PPUSH
1460: CALL_OW 72
1464: ST_TO_ADDR
// for i in bun do
1465: LD_ADDR_VAR 0 13
1469: PUSH
1470: LD_VAR 0 11
1474: PUSH
1475: FOR_IN
1476: IFFALSE 1545
// begin if not filter then
1478: LD_VAR 0 12
1482: NOT
1483: IFFALSE 1487
// break ;
1485: GO 1545
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1487: LD_VAR 0 12
1491: PUSH
1492: LD_INT 1
1494: ARRAY
1495: PPUSH
1496: LD_VAR 0 13
1500: PPUSH
1501: CALL_OW 52
// team := team diff filter [ 1 ] ;
1505: LD_ADDR_VAR 0 6
1509: PUSH
1510: LD_VAR 0 6
1514: PUSH
1515: LD_VAR 0 12
1519: PUSH
1520: LD_INT 1
1522: ARRAY
1523: DIFF
1524: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1525: LD_ADDR_VAR 0 12
1529: PUSH
1530: LD_VAR 0 12
1534: PPUSH
1535: LD_INT 1
1537: PPUSH
1538: CALL_OW 3
1542: ST_TO_ADDR
// end ;
1543: GO 1475
1545: POP
1546: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1547: LD_VAR 0 8
1551: PUSH
1552: LD_VAR 0 6
1556: PPUSH
1557: LD_INT 25
1559: PUSH
1560: LD_INT 1
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: PPUSH
1567: CALL_OW 72
1571: AND
1572: IFFALSE 1694
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1574: LD_ADDR_VAR 0 12
1578: PUSH
1579: LD_VAR 0 6
1583: PPUSH
1584: LD_INT 25
1586: PUSH
1587: LD_INT 1
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 72
1598: ST_TO_ADDR
// for i = 1 to filter do
1599: LD_ADDR_VAR 0 13
1603: PUSH
1604: DOUBLE
1605: LD_INT 1
1607: DEC
1608: ST_TO_ADDR
1609: LD_VAR 0 12
1613: PUSH
1614: FOR_TO
1615: IFFALSE 1676
// begin if ( i <= 6 ) then
1617: LD_VAR 0 13
1621: PUSH
1622: LD_INT 6
1624: LESSEQUAL
1625: IFFALSE 1653
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1627: LD_VAR 0 12
1631: PUSH
1632: LD_VAR 0 13
1636: ARRAY
1637: PPUSH
1638: LD_VAR 0 8
1642: PUSH
1643: LD_INT 1
1645: ARRAY
1646: PPUSH
1647: CALL_OW 52
1651: GO 1674
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1653: LD_VAR 0 12
1657: PUSH
1658: LD_VAR 0 13
1662: ARRAY
1663: PPUSH
1664: LD_INT 1
1666: PPUSH
1667: LD_INT 0
1669: PPUSH
1670: CALL_OW 49
// end ;
1674: GO 1614
1676: POP
1677: POP
// team := team diff filter ;
1678: LD_ADDR_VAR 0 6
1682: PUSH
1683: LD_VAR 0 6
1687: PUSH
1688: LD_VAR 0 12
1692: DIFF
1693: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1694: LD_VAR 0 9
1698: PUSH
1699: LD_VAR 0 6
1703: PPUSH
1704: LD_INT 25
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: PPUSH
1714: CALL_OW 72
1718: AND
1719: IFFALSE 1841
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1721: LD_ADDR_VAR 0 12
1725: PUSH
1726: LD_VAR 0 6
1730: PPUSH
1731: LD_INT 25
1733: PUSH
1734: LD_INT 4
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: PPUSH
1741: CALL_OW 72
1745: ST_TO_ADDR
// for i = 1 to filter do
1746: LD_ADDR_VAR 0 13
1750: PUSH
1751: DOUBLE
1752: LD_INT 1
1754: DEC
1755: ST_TO_ADDR
1756: LD_VAR 0 12
1760: PUSH
1761: FOR_TO
1762: IFFALSE 1823
// begin if ( i <= 6 ) then
1764: LD_VAR 0 13
1768: PUSH
1769: LD_INT 6
1771: LESSEQUAL
1772: IFFALSE 1800
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1774: LD_VAR 0 12
1778: PUSH
1779: LD_VAR 0 13
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 9
1789: PUSH
1790: LD_INT 1
1792: ARRAY
1793: PPUSH
1794: CALL_OW 52
1798: GO 1821
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1800: LD_VAR 0 12
1804: PUSH
1805: LD_VAR 0 13
1809: ARRAY
1810: PPUSH
1811: LD_INT 1
1813: PPUSH
1814: LD_INT 0
1816: PPUSH
1817: CALL_OW 49
// end ;
1821: GO 1761
1823: POP
1824: POP
// team := team diff filter ;
1825: LD_ADDR_VAR 0 6
1829: PUSH
1830: LD_VAR 0 6
1834: PUSH
1835: LD_VAR 0 12
1839: DIFF
1840: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1841: LD_VAR 0 10
1845: PUSH
1846: LD_VAR 0 6
1850: PPUSH
1851: LD_INT 25
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: PPUSH
1861: CALL_OW 72
1865: AND
1866: IFFALSE 1988
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1868: LD_ADDR_VAR 0 12
1872: PUSH
1873: LD_VAR 0 6
1877: PPUSH
1878: LD_INT 25
1880: PUSH
1881: LD_INT 3
1883: PUSH
1884: EMPTY
1885: LIST
1886: LIST
1887: PPUSH
1888: CALL_OW 72
1892: ST_TO_ADDR
// for i = 1 to filter do
1893: LD_ADDR_VAR 0 13
1897: PUSH
1898: DOUBLE
1899: LD_INT 1
1901: DEC
1902: ST_TO_ADDR
1903: LD_VAR 0 12
1907: PUSH
1908: FOR_TO
1909: IFFALSE 1970
// begin if ( i <= 6 ) then
1911: LD_VAR 0 13
1915: PUSH
1916: LD_INT 6
1918: LESSEQUAL
1919: IFFALSE 1947
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1921: LD_VAR 0 12
1925: PUSH
1926: LD_VAR 0 13
1930: ARRAY
1931: PPUSH
1932: LD_VAR 0 10
1936: PUSH
1937: LD_INT 1
1939: ARRAY
1940: PPUSH
1941: CALL_OW 52
1945: GO 1968
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1947: LD_VAR 0 12
1951: PUSH
1952: LD_VAR 0 13
1956: ARRAY
1957: PPUSH
1958: LD_INT 1
1960: PPUSH
1961: LD_INT 0
1963: PPUSH
1964: CALL_OW 49
// end ;
1968: GO 1908
1970: POP
1971: POP
// team := team diff filter ;
1972: LD_ADDR_VAR 0 6
1976: PUSH
1977: LD_VAR 0 6
1981: PUSH
1982: LD_VAR 0 12
1986: DIFF
1987: ST_TO_ADDR
// end ; if team then
1988: LD_VAR 0 6
1992: IFFALSE 2035
// for i in team do
1994: LD_ADDR_VAR 0 13
1998: PUSH
1999: LD_VAR 0 6
2003: PUSH
2004: FOR_IN
2005: IFFALSE 2033
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2007: LD_VAR 0 13
2011: PPUSH
2012: LD_INT 1
2014: PPUSH
2015: LD_INT 0
2017: PPUSH
2018: CALL_OW 49
// ComHold ( i ) ;
2022: LD_VAR 0 13
2026: PPUSH
2027: CALL_OW 140
// end ;
2031: GO 2004
2033: POP
2034: POP
// if fac then
2035: LD_VAR 0 10
2039: IFFALSE 2075
// if UnitsInside ( fac [ 1 ] ) then
2041: LD_VAR 0 10
2045: PUSH
2046: LD_INT 1
2048: ARRAY
2049: PPUSH
2050: CALL_OW 313
2054: IFFALSE 2075
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2056: LD_VAR 0 10
2060: PUSH
2061: LD_INT 1
2063: ARRAY
2064: PPUSH
2065: LD_INT 10
2067: PPUSH
2068: LD_INT 0
2070: PPUSH
2071: CALL_OW 486
// if lab then
2075: LD_VAR 0 9
2079: IFFALSE 2115
// if UnitsInside ( lab [ 1 ] ) then
2081: LD_VAR 0 9
2085: PUSH
2086: LD_INT 1
2088: ARRAY
2089: PPUSH
2090: CALL_OW 313
2094: IFFALSE 2115
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2096: LD_VAR 0 9
2100: PUSH
2101: LD_INT 1
2103: ARRAY
2104: PPUSH
2105: LD_INT 10
2107: PPUSH
2108: LD_INT 0
2110: PPUSH
2111: CALL_OW 486
// uc_side := 4 ;
2115: LD_ADDR_OWVAR 20
2119: PUSH
2120: LD_INT 4
2122: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2123: LD_ADDR_EXP 17
2127: PUSH
2128: LD_STRING Harisson
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: LD_STRING 
2136: PPUSH
2137: CALL 3808 0 3
2141: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2142: LD_ADDR_VAR 0 5
2146: PUSH
2147: LD_INT 4
2149: PPUSH
2150: LD_INT 1
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_INT 1
2158: PPUSH
2159: LD_INT 1
2161: PPUSH
2162: LD_INT 2
2164: PPUSH
2165: LD_INT 100
2167: PPUSH
2168: CALL 3871 0 7
2172: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2173: LD_VAR 0 5
2177: PPUSH
2178: LD_INT 2
2180: PPUSH
2181: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2185: LD_VAR 0 5
2189: PPUSH
2190: LD_INT 21
2192: PPUSH
2193: LD_INT 8
2195: PPUSH
2196: LD_INT 0
2198: PPUSH
2199: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2203: LD_EXP 17
2207: PPUSH
2208: LD_VAR 0 5
2212: PPUSH
2213: CALL_OW 52
// end ;
2217: LD_VAR 0 1
2221: RET
// function PrepareBase ; var blist , i , b ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
2226: PPUSH
2227: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2228: LD_INT 71
2230: PPUSH
2231: LD_INT 5
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2241: LD_ADDR_VAR 0 2
2245: PUSH
2246: LD_STRING GammaBase
2248: PPUSH
2249: EMPTY
2250: PPUSH
2251: CALL_OW 30
2255: ST_TO_ADDR
// if not blist and debug then
2256: LD_VAR 0 2
2260: NOT
2261: PUSH
2262: LD_EXP 1
2266: AND
2267: IFFALSE 2307
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2269: LD_ADDR_VAR 0 2
2273: PUSH
2274: LD_INT 0
2276: PUSH
2277: LD_INT 51
2279: PUSH
2280: LD_INT 10
2282: PUSH
2283: LD_INT 3
2285: PUSH
2286: LD_INT 3
2288: PUSH
2289: LD_INT 0
2291: PUSH
2292: LD_INT 0
2294: PUSH
2295: EMPTY
2296: LIST
2297: LIST
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: LIST
2303: PUSH
2304: EMPTY
2305: LIST
2306: ST_TO_ADDR
// if not blist then
2307: LD_VAR 0 2
2311: NOT
2312: IFFALSE 2316
// exit ;
2314: GO 2496
// uc_side := 1 ;
2316: LD_ADDR_OWVAR 20
2320: PUSH
2321: LD_INT 1
2323: ST_TO_ADDR
// uc_nation := 1 ;
2324: LD_ADDR_OWVAR 21
2328: PUSH
2329: LD_INT 1
2331: ST_TO_ADDR
// for i in blist do
2332: LD_ADDR_VAR 0 3
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: FOR_IN
2343: IFFALSE 2494
// begin bc_type := i [ 1 ] ;
2345: LD_ADDR_OWVAR 42
2349: PUSH
2350: LD_VAR 0 3
2354: PUSH
2355: LD_INT 1
2357: ARRAY
2358: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2359: LD_ADDR_OWVAR 43
2363: PUSH
2364: LD_VAR 0 3
2368: PUSH
2369: LD_INT 5
2371: ARRAY
2372: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 1
2380: ARRAY
2381: PUSH
2382: LD_INT 7
2384: PUSH
2385: LD_INT 8
2387: PUSH
2388: EMPTY
2389: LIST
2390: LIST
2391: IN
2392: IFFALSE 2422
// begin bc_kind1 := i [ 7 ] ;
2394: LD_ADDR_OWVAR 44
2398: PUSH
2399: LD_VAR 0 3
2403: PUSH
2404: LD_INT 7
2406: ARRAY
2407: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2408: LD_ADDR_OWVAR 45
2412: PUSH
2413: LD_VAR 0 3
2417: PUSH
2418: LD_INT 8
2420: ARRAY
2421: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2422: LD_ADDR_VAR 0 4
2426: PUSH
2427: LD_VAR 0 3
2431: PUSH
2432: LD_INT 2
2434: ARRAY
2435: PPUSH
2436: LD_VAR 0 3
2440: PUSH
2441: LD_INT 3
2443: ARRAY
2444: PPUSH
2445: LD_VAR 0 3
2449: PUSH
2450: LD_INT 4
2452: ARRAY
2453: PPUSH
2454: CALL_OW 47
2458: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2459: LD_VAR 0 4
2463: PPUSH
2464: CALL_OW 266
2468: PUSH
2469: LD_INT 32
2471: EQUAL
2472: IFFALSE 2492
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2474: LD_VAR 0 4
2478: PPUSH
2479: LD_VAR 0 3
2483: PUSH
2484: LD_INT 7
2486: ARRAY
2487: PPUSH
2488: CALL_OW 431
// end ; end ;
2492: GO 2342
2494: POP
2495: POP
// end ; end_of_file
2496: LD_VAR 0 1
2500: RET
// export function Action ; var points , i , sol , team , filter ; begin
2501: LD_INT 0
2503: PPUSH
2504: PPUSH
2505: PPUSH
2506: PPUSH
2507: PPUSH
2508: PPUSH
// InGameOn ;
2509: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2513: LD_INT 33
2515: PPUSH
2516: LD_INT 11
2518: PPUSH
2519: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2523: LD_ADDR_VAR 0 2
2527: PUSH
2528: LD_INT 29
2530: PUSH
2531: LD_INT 21
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: LD_INT 41
2540: PUSH
2541: LD_INT 28
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: PUSH
2548: LD_INT 52
2550: PUSH
2551: LD_INT 26
2553: PUSH
2554: EMPTY
2555: LIST
2556: LIST
2557: PUSH
2558: LD_INT 49
2560: PUSH
2561: LD_INT 16
2563: PUSH
2564: EMPTY
2565: LIST
2566: LIST
2567: PUSH
2568: EMPTY
2569: LIST
2570: LIST
2571: LIST
2572: LIST
2573: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2574: LD_ADDR_VAR 0 4
2578: PUSH
2579: LD_INT 22
2581: PUSH
2582: LD_INT 1
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: LD_INT 26
2591: PUSH
2592: LD_INT 1
2594: PUSH
2595: EMPTY
2596: LIST
2597: LIST
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: PPUSH
2603: CALL_OW 69
2607: PUSH
2608: LD_EXP 7
2612: PUSH
2613: LD_EXP 14
2617: PUSH
2618: LD_EXP 11
2622: PUSH
2623: LD_EXP 12
2627: PUSH
2628: LD_EXP 8
2632: PUSH
2633: LD_EXP 15
2637: PUSH
2638: LD_EXP 16
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: LIST
2650: LIST
2651: DIFF
2652: PUSH
2653: LD_INT 1
2655: ARRAY
2656: ST_TO_ADDR
// if sol then
2657: LD_VAR 0 4
2661: IFFALSE 2692
// begin ComMoveXY ( sol , 50 , 18 ) ;
2663: LD_VAR 0 4
2667: PPUSH
2668: LD_INT 50
2670: PPUSH
2671: LD_INT 18
2673: PPUSH
2674: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2678: LD_VAR 0 4
2682: PPUSH
2683: LD_EXP 17
2687: PPUSH
2688: CALL_OW 179
// end ; for i in points do
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_VAR 0 2
2701: PUSH
2702: FOR_IN
2703: IFFALSE 2734
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2705: LD_EXP 17
2709: PPUSH
2710: LD_VAR 0 3
2714: PUSH
2715: LD_INT 1
2717: ARRAY
2718: PPUSH
2719: LD_VAR 0 3
2723: PUSH
2724: LD_INT 2
2726: ARRAY
2727: PPUSH
2728: CALL_OW 171
2732: GO 2702
2734: POP
2735: POP
// AddComExitVehicle ( Harisson ) ;
2736: LD_EXP 17
2740: PPUSH
2741: CALL_OW 181
// repeat wait ( 3 ) ;
2745: LD_INT 3
2747: PPUSH
2748: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2752: LD_EXP 17
2756: PPUSH
2757: CALL_OW 310
2761: NOT
2762: IFFALSE 2745
// Say ( sol , D1-Sol1-1 ) ;
2764: LD_VAR 0 4
2768: PPUSH
2769: LD_STRING D1-Sol1-1
2771: PPUSH
2772: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2776: LD_EXP 17
2780: PPUSH
2781: LD_VAR 0 4
2785: PPUSH
2786: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2790: LD_EXP 17
2794: PPUSH
2795: LD_STRING D1-Har-1
2797: PPUSH
2798: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2802: LD_INT 10
2804: PPUSH
2805: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2809: LD_VAR 0 4
2813: PPUSH
2814: LD_INT 35
2816: PPUSH
2817: LD_INT 21
2819: PPUSH
2820: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2824: LD_EXP 7
2828: PPUSH
2829: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2833: LD_EXP 7
2837: PPUSH
2838: LD_EXP 17
2842: PPUSH
2843: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2847: LD_EXP 17
2851: PPUSH
2852: LD_EXP 7
2856: PPUSH
2857: CALL_OW 119
// repeat wait ( 3 ) ;
2861: LD_INT 3
2863: PPUSH
2864: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2868: LD_EXP 7
2872: PPUSH
2873: LD_EXP 17
2877: PPUSH
2878: CALL_OW 296
2882: PUSH
2883: LD_INT 4
2885: LESS
2886: IFFALSE 2861
// ComTurnUnit ( JMM , Harisson ) ;
2888: LD_EXP 7
2892: PPUSH
2893: LD_EXP 17
2897: PPUSH
2898: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2902: LD_EXP 7
2906: PPUSH
2907: LD_STRING D1-JMM-1
2909: PPUSH
2910: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2914: LD_EXP 17
2918: PPUSH
2919: LD_STRING D1-Har-2
2921: PPUSH
2922: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
2926: LD_EXP 7
2930: PPUSH
2931: LD_STRING D1-JMM-2
2933: PPUSH
2934: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
2938: LD_EXP 17
2942: PPUSH
2943: LD_STRING D1-Har-3
2945: PPUSH
2946: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2950: LD_EXP 7
2954: PPUSH
2955: LD_STRING D1-JMM-3
2957: PPUSH
2958: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
2962: LD_EXP 17
2966: PPUSH
2967: LD_STRING D1-Har-4
2969: PPUSH
2970: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
2974: LD_EXP 7
2978: PPUSH
2979: LD_STRING D1-JMM-4
2981: PPUSH
2982: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
2986: LD_EXP 17
2990: PPUSH
2991: LD_STRING D1-Har-5
2993: PPUSH
2994: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
2998: LD_EXP 7
3002: PPUSH
3003: LD_STRING D1-JMM-5
3005: PPUSH
3006: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3010: LD_EXP 17
3014: PPUSH
3015: LD_STRING D1-Har-6
3017: PPUSH
3018: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3022: LD_EXP 7
3026: PPUSH
3027: LD_STRING D1-JMM-6
3029: PPUSH
3030: CALL_OW 88
// EndMission ;
3034: CALL 3043 0 0
// end ;
3038: LD_VAR 0 1
3042: RET
// export function EndMission ; var commander , i , all ; begin
3043: LD_INT 0
3045: PPUSH
3046: PPUSH
3047: PPUSH
3048: PPUSH
// case gamma_commander of 1 :
3049: LD_EXP 18
3053: PUSH
3054: LD_INT 1
3056: DOUBLE
3057: EQUAL
3058: IFTRUE 3062
3060: GO 3075
3062: POP
// commander := Donaldson ; 2 :
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: LD_EXP 13
3072: ST_TO_ADDR
3073: GO 3118
3075: LD_INT 2
3077: DOUBLE
3078: EQUAL
3079: IFTRUE 3083
3081: GO 3096
3083: POP
// commander := Brown ; 3 :
3084: LD_ADDR_VAR 0 2
3088: PUSH
3089: LD_EXP 14
3093: ST_TO_ADDR
3094: GO 3118
3096: LD_INT 3
3098: DOUBLE
3099: EQUAL
3100: IFTRUE 3104
3102: GO 3117
3104: POP
// commander := Houten ; end ;
3105: LD_ADDR_VAR 0 2
3109: PUSH
3110: LD_EXP 15
3114: ST_TO_ADDR
3115: GO 3118
3117: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3118: LD_ADDR_VAR 0 4
3122: PUSH
3123: LD_INT 22
3125: PUSH
3126: LD_INT 1
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 21
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PPUSH
3147: CALL_OW 69
3151: PUSH
3152: LD_EXP 7
3156: PUSH
3157: LD_VAR 0 2
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: DIFF
3166: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3167: LD_ADDR_EXP 4
3171: PUSH
3172: LD_STRING 1
3174: PPUSH
3175: LD_INT 10
3177: PPUSH
3178: LD_INT 10
3180: PPUSH
3181: LD_INT -5
3183: PUSH
3184: LD_EXP 7
3188: PUSH
3189: LD_INT -2
3191: PUSH
3192: LD_INT -3
3194: PUSH
3195: LD_INT -5
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: PUSH
3205: LD_VAR 0 4
3209: ADD
3210: PUSH
3211: LD_INT -6
3213: PUSH
3214: LD_INT -4
3216: PUSH
3217: LD_VAR 0 2
3221: PUSH
3222: LD_EXP 17
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: ADD
3236: PPUSH
3237: LD_INT 1
3239: PUSH
3240: LD_INT 3
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: LD_INT 3
3249: PUSH
3250: LD_INT 3
3252: PUSH
3253: LD_INT 6
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 4
3263: PUSH
3264: LD_INT 1
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: PPUSH
3276: CALL_OW 42
3280: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3281: LD_VAR 0 4
3285: PUSH
3286: LD_EXP 7
3290: PUSH
3291: LD_EXP 8
3295: PUSH
3296: LD_EXP 10
3300: PUSH
3301: LD_EXP 11
3305: PUSH
3306: LD_EXP 12
3310: PUSH
3311: LD_EXP 9
3315: PUSH
3316: LD_EXP 13
3320: PUSH
3321: LD_EXP 14
3325: PUSH
3326: LD_EXP 15
3330: PUSH
3331: LD_EXP 17
3335: PUSH
3336: LD_EXP 16
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: LIST
3345: LIST
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: LIST
3351: LIST
3352: LIST
3353: PUSH
3354: LD_EXP 4
3358: ADD
3359: DIFF
3360: PPUSH
3361: LD_STRING 07_othersGamma
3363: PPUSH
3364: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3368: LD_EXP 4
3372: PUSH
3373: LD_EXP 7
3377: PUSH
3378: LD_EXP 8
3382: PUSH
3383: LD_EXP 10
3387: PUSH
3388: LD_EXP 11
3392: PUSH
3393: LD_EXP 12
3397: PUSH
3398: LD_EXP 9
3402: PUSH
3403: LD_EXP 13
3407: PUSH
3408: LD_EXP 14
3412: PUSH
3413: LD_EXP 15
3417: PUSH
3418: LD_EXP 17
3422: PUSH
3423: LD_EXP 16
3427: PUSH
3428: LD_INT 0
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: LIST
3444: DIFF
3445: PPUSH
3446: LD_STRING 07_others
3448: PPUSH
3449: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3453: LD_EXP 7
3457: PPUSH
3458: LD_EXP 5
3462: PUSH
3463: LD_STRING JMM
3465: STR
3466: PPUSH
3467: CALL_OW 38
// if Lisa then
3471: LD_EXP 10
3475: IFFALSE 3517
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3477: LD_EXP 10
3481: PPUSH
3482: LD_EXP 5
3486: PUSH
3487: LD_STRING Lisa
3489: STR
3490: PPUSH
3491: CALL_OW 38
// if Lisa in save_group then
3495: LD_EXP 10
3499: PUSH
3500: LD_EXP 4
3504: IN
3505: IFFALSE 3517
// SaveVariable ( true , LisaIn07 ) ;
3507: LD_INT 1
3509: PPUSH
3510: LD_STRING LisaIn07
3512: PPUSH
3513: CALL_OW 39
// end ; if Bobby then
3517: LD_EXP 12
3521: IFFALSE 3563
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3523: LD_EXP 12
3527: PPUSH
3528: LD_EXP 5
3532: PUSH
3533: LD_STRING Bobby
3535: STR
3536: PPUSH
3537: CALL_OW 38
// if Bobby in save_group then
3541: LD_EXP 12
3545: PUSH
3546: LD_EXP 4
3550: IN
3551: IFFALSE 3563
// SaveVariable ( true , BobbyIn07 ) ;
3553: LD_INT 1
3555: PPUSH
3556: LD_STRING BobbyIn07
3558: PPUSH
3559: CALL_OW 39
// end ; if Cyrus then
3563: LD_EXP 11
3567: IFFALSE 3609
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3569: LD_EXP 11
3573: PPUSH
3574: LD_EXP 5
3578: PUSH
3579: LD_STRING Cyrus
3581: STR
3582: PPUSH
3583: CALL_OW 38
// if Cyrus in save_group then
3587: LD_EXP 11
3591: PUSH
3592: LD_EXP 4
3596: IN
3597: IFFALSE 3609
// SaveVariable ( true , CyrusIn07 ) ;
3599: LD_INT 1
3601: PPUSH
3602: LD_STRING CyrusIn07
3604: PPUSH
3605: CALL_OW 39
// end ; if Brown then
3609: LD_EXP 14
3613: IFFALSE 3655
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3615: LD_EXP 14
3619: PPUSH
3620: LD_EXP 5
3624: PUSH
3625: LD_STRING Brown
3627: STR
3628: PPUSH
3629: CALL_OW 38
// if Brown in save_group then
3633: LD_EXP 14
3637: PUSH
3638: LD_EXP 4
3642: IN
3643: IFFALSE 3655
// SaveVariable ( true , BrownIn07 ) ;
3645: LD_INT 1
3647: PPUSH
3648: LD_STRING BrownIn07
3650: PPUSH
3651: CALL_OW 39
// end ; if Donaldson then
3655: LD_EXP 13
3659: IFFALSE 3701
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3661: LD_EXP 13
3665: PPUSH
3666: LD_EXP 5
3670: PUSH
3671: LD_STRING Donaldson
3673: STR
3674: PPUSH
3675: CALL_OW 38
// if Donaldson in save_group then
3679: LD_EXP 13
3683: PUSH
3684: LD_EXP 4
3688: IN
3689: IFFALSE 3701
// SaveVariable ( true , DonaldsonIn07 ) ;
3691: LD_INT 1
3693: PPUSH
3694: LD_STRING DonaldsonIn07
3696: PPUSH
3697: CALL_OW 39
// end ; if Gladstone then
3701: LD_EXP 8
3705: IFFALSE 3747
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3707: LD_EXP 8
3711: PPUSH
3712: LD_EXP 5
3716: PUSH
3717: LD_STRING Gladstone
3719: STR
3720: PPUSH
3721: CALL_OW 38
// if Gladstone in save_group then
3725: LD_EXP 8
3729: PUSH
3730: LD_EXP 4
3734: IN
3735: IFFALSE 3747
// SaveVariable ( true , GladstoneIn07 ) ;
3737: LD_INT 1
3739: PPUSH
3740: LD_STRING GladstoneIn07
3742: PPUSH
3743: CALL_OW 39
// end ; if Khatam then
3747: LD_EXP 16
3751: IFFALSE 3793
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3753: LD_EXP 16
3757: PPUSH
3758: LD_EXP 5
3762: PUSH
3763: LD_STRING Khatam
3765: STR
3766: PPUSH
3767: CALL_OW 38
// if Khatam in save_group then
3771: LD_EXP 16
3775: PUSH
3776: LD_EXP 4
3780: IN
3781: IFFALSE 3793
// SaveVariable ( true , KhatamIn07 ) ;
3783: LD_INT 1
3785: PPUSH
3786: LD_STRING KhatamIn07
3788: PPUSH
3789: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3793: LD_INT 1
3795: PPUSH
3796: LD_STRING %_cont
3798: PPUSH
3799: CALL_OW 340
// end ; end_of_file
3803: LD_VAR 0 1
3807: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3808: LD_INT 0
3810: PPUSH
3811: PPUSH
// if exist_mode then
3812: LD_VAR 0 2
3816: IFFALSE 3841
// unit := CreateCharacter ( prefix & ident ) else
3818: LD_ADDR_VAR 0 5
3822: PUSH
3823: LD_VAR 0 3
3827: PUSH
3828: LD_VAR 0 1
3832: STR
3833: PPUSH
3834: CALL_OW 34
3838: ST_TO_ADDR
3839: GO 3856
// unit := NewCharacter ( ident ) ;
3841: LD_ADDR_VAR 0 5
3845: PUSH
3846: LD_VAR 0 1
3850: PPUSH
3851: CALL_OW 25
3855: ST_TO_ADDR
// result := unit ;
3856: LD_ADDR_VAR 0 4
3860: PUSH
3861: LD_VAR 0 5
3865: ST_TO_ADDR
// end ;
3866: LD_VAR 0 4
3870: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3871: LD_INT 0
3873: PPUSH
// uc_side := side ;
3874: LD_ADDR_OWVAR 20
3878: PUSH
3879: LD_VAR 0 1
3883: ST_TO_ADDR
// uc_nation := nation ;
3884: LD_ADDR_OWVAR 21
3888: PUSH
3889: LD_VAR 0 2
3893: ST_TO_ADDR
// vc_chassis := chassis ;
3894: LD_ADDR_OWVAR 37
3898: PUSH
3899: LD_VAR 0 3
3903: ST_TO_ADDR
// vc_engine := engine ;
3904: LD_ADDR_OWVAR 39
3908: PUSH
3909: LD_VAR 0 4
3913: ST_TO_ADDR
// vc_control := control ;
3914: LD_ADDR_OWVAR 38
3918: PUSH
3919: LD_VAR 0 5
3923: ST_TO_ADDR
// vc_weapon := weapon ;
3924: LD_ADDR_OWVAR 40
3928: PUSH
3929: LD_VAR 0 6
3933: ST_TO_ADDR
// vc_fuel_battery := fuel ;
3934: LD_ADDR_OWVAR 41
3938: PUSH
3939: LD_VAR 0 7
3943: ST_TO_ADDR
// result := CreateVehicle ;
3944: LD_ADDR_VAR 0 8
3948: PUSH
3949: CALL_OW 45
3953: ST_TO_ADDR
// end ;
3954: LD_VAR 0 8
3958: RET
// export function SayX ( units , ident ) ; var i ; begin
3959: LD_INT 0
3961: PPUSH
3962: PPUSH
// result := false ;
3963: LD_ADDR_VAR 0 3
3967: PUSH
3968: LD_INT 0
3970: ST_TO_ADDR
// if not units then
3971: LD_VAR 0 1
3975: NOT
3976: IFFALSE 3980
// exit ;
3978: GO 4034
// for i in units do
3980: LD_ADDR_VAR 0 4
3984: PUSH
3985: LD_VAR 0 1
3989: PUSH
3990: FOR_IN
3991: IFFALSE 4032
// if IsOk ( i ) then
3993: LD_VAR 0 4
3997: PPUSH
3998: CALL_OW 302
4002: IFFALSE 4030
// begin Say ( i , ident ) ;
4004: LD_VAR 0 4
4008: PPUSH
4009: LD_VAR 0 2
4013: PPUSH
4014: CALL_OW 88
// result := i ;
4018: LD_ADDR_VAR 0 3
4022: PUSH
4023: LD_VAR 0 4
4027: ST_TO_ADDR
// break ;
4028: GO 4032
// end ;
4030: GO 3990
4032: POP
4033: POP
// end ;
4034: LD_VAR 0 3
4038: RET
