// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2851 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export RandGuy ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2517 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 4334 0 3
 179: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 180: LD_EXP 7
 184: PPUSH
 185: CALL_OW 257
 189: PUSH
 190: LD_INT 2
 192: EQUAL
 193: IFFALSE 207
// SetClass ( JMM , 1 ) ;
 195: LD_EXP 7
 199: PPUSH
 200: LD_INT 1
 202: PPUSH
 203: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 207: LD_ADDR_EXP 18
 211: PUSH
 212: LD_STRING GammaCommander
 214: PPUSH
 215: LD_INT 3
 217: PPUSH
 218: CALL_OW 30
 222: ST_TO_ADDR
// if gamma_commander = 1 then
 223: LD_EXP 18
 227: PUSH
 228: LD_INT 1
 230: EQUAL
 231: IFFALSE 257
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 233: LD_ADDR_EXP 13
 237: PUSH
 238: LD_STRING Donaldson
 240: PPUSH
 241: LD_EXP 1
 245: NOT
 246: PPUSH
 247: LD_STRING 04_
 249: PPUSH
 250: CALL 4334 0 3
 254: ST_TO_ADDR
// end else
 255: GO 328
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 257: LD_STRING DonaldsonIn06
 259: PPUSH
 260: LD_INT 0
 262: PPUSH
 263: CALL_OW 30
 267: IFFALSE 293
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 269: LD_ADDR_EXP 13
 273: PUSH
 274: LD_STRING Donaldson
 276: PPUSH
 277: LD_EXP 1
 281: NOT
 282: PPUSH
 283: LD_STRING 06c_
 285: PPUSH
 286: CALL 4334 0 3
 290: ST_TO_ADDR
 291: GO 328
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 293: LD_STRING DonaldsonStayInDelta
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: CALL_OW 30
 303: NOT
 304: IFFALSE 328
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 306: LD_ADDR_EXP 13
 310: PUSH
 311: LD_STRING Donaldson
 313: PPUSH
 314: LD_EXP 1
 318: NOT
 319: PPUSH
 320: LD_STRING 04_
 322: PPUSH
 323: CALL 4334 0 3
 327: ST_TO_ADDR
// end ; if Donaldson then
 328: LD_EXP 13
 332: IFFALSE 350
// team := team ^ Donaldson ;
 334: LD_ADDR_VAR 0 6
 338: PUSH
 339: LD_VAR 0 6
 343: PUSH
 344: LD_EXP 13
 348: ADD
 349: ST_TO_ADDR
// if gamma_commander = 2 then
 350: LD_EXP 18
 354: PUSH
 355: LD_INT 2
 357: EQUAL
 358: IFFALSE 384
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 360: LD_ADDR_EXP 14
 364: PUSH
 365: LD_STRING Brown
 367: PPUSH
 368: LD_EXP 1
 372: NOT
 373: PPUSH
 374: LD_STRING 04_
 376: PPUSH
 377: CALL 4334 0 3
 381: ST_TO_ADDR
// end else
 382: GO 455
// begin if LoadVariable ( BrownIn06 , 0 ) then
 384: LD_STRING BrownIn06
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 30
 394: IFFALSE 420
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 396: LD_ADDR_EXP 14
 400: PUSH
 401: LD_STRING Brown
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: LD_STRING 06c_
 412: PPUSH
 413: CALL 4334 0 3
 417: ST_TO_ADDR
 418: GO 455
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 420: LD_STRING BrownStayInDelta
 422: PPUSH
 423: LD_INT 0
 425: PPUSH
 426: CALL_OW 30
 430: NOT
 431: IFFALSE 455
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 433: LD_ADDR_EXP 14
 437: PUSH
 438: LD_STRING Brown
 440: PPUSH
 441: LD_EXP 1
 445: NOT
 446: PPUSH
 447: LD_STRING 04_
 449: PPUSH
 450: CALL 4334 0 3
 454: ST_TO_ADDR
// end ; if Brown then
 455: LD_EXP 14
 459: IFFALSE 477
// team := team ^ Brown ;
 461: LD_ADDR_VAR 0 6
 465: PUSH
 466: LD_VAR 0 6
 470: PUSH
 471: LD_EXP 14
 475: ADD
 476: ST_TO_ADDR
// if gamma_commander = 3 then
 477: LD_EXP 18
 481: PUSH
 482: LD_INT 3
 484: EQUAL
 485: IFFALSE 522
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 487: LD_ADDR_EXP 15
 491: PUSH
 492: LD_STRING VanHouten
 494: PPUSH
 495: LD_INT 0
 497: PPUSH
 498: LD_STRING 
 500: PPUSH
 501: CALL 4334 0 3
 505: ST_TO_ADDR
// team := team ^ Houten ;
 506: LD_ADDR_VAR 0 6
 510: PUSH
 511: LD_VAR 0 6
 515: PUSH
 516: LD_EXP 15
 520: ADD
 521: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 522: LD_STRING GladstoneIn06
 524: PPUSH
 525: LD_INT 0
 527: PPUSH
 528: CALL_OW 30
 532: IFFALSE 558
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 534: LD_ADDR_EXP 8
 538: PUSH
 539: LD_STRING Gladstone
 541: PPUSH
 542: LD_EXP 1
 546: NOT
 547: PPUSH
 548: LD_STRING 06c_
 550: PPUSH
 551: CALL 4334 0 3
 555: ST_TO_ADDR
 556: GO 592
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 558: LD_STRING GladstoneStayInDelta
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 30
 568: IFFALSE 592
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 570: LD_ADDR_EXP 8
 574: PUSH
 575: LD_STRING Gladstone
 577: PPUSH
 578: LD_EXP 1
 582: NOT
 583: PPUSH
 584: LD_STRING 06_
 586: PPUSH
 587: CALL 4334 0 3
 591: ST_TO_ADDR
// if Gladstone then
 592: LD_EXP 8
 596: IFFALSE 614
// team := team ^ Gladstone ;
 598: LD_ADDR_VAR 0 6
 602: PUSH
 603: LD_VAR 0 6
 607: PUSH
 608: LD_EXP 8
 612: ADD
 613: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 614: LD_ADDR_EXP 16
 618: PUSH
 619: LD_STRING Khatam
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 03_
 630: PPUSH
 631: CALL 4334 0 3
 635: ST_TO_ADDR
// if Khatam then
 636: LD_EXP 16
 640: IFFALSE 658
// team := team ^ Khatam ;
 642: LD_ADDR_VAR 0 6
 646: PUSH
 647: LD_VAR 0 6
 651: PUSH
 652: LD_EXP 16
 656: ADD
 657: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 658: LD_STRING LisaIn06
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 30
 668: IFFALSE 694
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 670: LD_ADDR_EXP 10
 674: PUSH
 675: LD_STRING Lisa
 677: PPUSH
 678: LD_EXP 1
 682: NOT
 683: PPUSH
 684: LD_STRING 06c_
 686: PPUSH
 687: CALL 4334 0 3
 691: ST_TO_ADDR
 692: GO 729
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 694: LD_STRING LisaStayInDelta
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: CALL_OW 30
 704: NOT
 705: IFFALSE 729
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 707: LD_ADDR_EXP 10
 711: PUSH
 712: LD_STRING Lisa
 714: PPUSH
 715: LD_EXP 1
 719: NOT
 720: PPUSH
 721: LD_STRING 04_
 723: PPUSH
 724: CALL 4334 0 3
 728: ST_TO_ADDR
// if Lisa then
 729: LD_EXP 10
 733: IFFALSE 751
// team := team ^ Lisa ;
 735: LD_ADDR_VAR 0 6
 739: PUSH
 740: LD_VAR 0 6
 744: PUSH
 745: LD_EXP 10
 749: ADD
 750: ST_TO_ADDR
// if not Lisa then
 751: LD_EXP 10
 755: NOT
 756: IFFALSE 1009
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 758: LD_STRING CyrusIn06
 760: PPUSH
 761: LD_INT 0
 763: PPUSH
 764: CALL_OW 30
 768: IFFALSE 794
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 770: LD_ADDR_EXP 11
 774: PUSH
 775: LD_STRING Cyrus
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 06c_
 786: PPUSH
 787: CALL 4334 0 3
 791: ST_TO_ADDR
 792: GO 858
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 794: LD_STRING CyrusStayInDelta
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 30
 804: NOT
 805: IFFALSE 858
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 807: LD_ADDR_EXP 11
 811: PUSH
 812: LD_STRING Cyrus
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 04_
 823: PPUSH
 824: CALL 4334 0 3
 828: ST_TO_ADDR
// if not Cyrus then
 829: LD_EXP 11
 833: NOT
 834: IFFALSE 858
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 836: LD_ADDR_EXP 11
 840: PUSH
 841: LD_STRING Cyrus
 843: PPUSH
 844: LD_EXP 1
 848: NOT
 849: PPUSH
 850: LD_STRING 03_
 852: PPUSH
 853: CALL 4334 0 3
 857: ST_TO_ADDR
// end ; if Cyrus then
 858: LD_EXP 11
 862: IFFALSE 880
// team := team ^ Cyrus ;
 864: LD_ADDR_VAR 0 6
 868: PUSH
 869: LD_VAR 0 6
 873: PUSH
 874: LD_EXP 11
 878: ADD
 879: ST_TO_ADDR
// if not Cyrus then
 880: LD_EXP 11
 884: NOT
 885: IFFALSE 1009
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 887: LD_STRING BobbyIn06
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 30
 897: IFFALSE 923
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 899: LD_ADDR_EXP 12
 903: PUSH
 904: LD_STRING Bobby
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 06c_
 915: PPUSH
 916: CALL 4334 0 3
 920: ST_TO_ADDR
 921: GO 987
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 923: LD_STRING BobbyStayInDelta
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: NOT
 934: IFFALSE 987
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 936: LD_ADDR_EXP 12
 940: PUSH
 941: LD_STRING Bobby
 943: PPUSH
 944: LD_EXP 1
 948: NOT
 949: PPUSH
 950: LD_STRING 04_
 952: PPUSH
 953: CALL 4334 0 3
 957: ST_TO_ADDR
// if not Bobby then
 958: LD_EXP 12
 962: NOT
 963: IFFALSE 987
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 965: LD_ADDR_EXP 12
 969: PUSH
 970: LD_STRING Bobby
 972: PPUSH
 973: LD_EXP 1
 977: NOT
 978: PPUSH
 979: LD_STRING 03_
 981: PPUSH
 982: CALL 4334 0 3
 986: ST_TO_ADDR
// end ; if Bobby then
 987: LD_EXP 12
 991: IFFALSE 1009
// team := team ^ Bobby ;
 993: LD_ADDR_VAR 0 6
 997: PUSH
 998: LD_VAR 0 6
1002: PUSH
1003: LD_EXP 12
1007: ADD
1008: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1009: LD_ADDR_VAR 0 4
1013: PUSH
1014: LD_STRING othersGamma
1016: PPUSH
1017: CALL_OW 31
1021: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_STRING 06_other_survivors
1029: PPUSH
1030: CALL_OW 31
1034: ST_TO_ADDR
// others := others union others4 ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_VAR 0 4
1049: UNION
1050: ST_TO_ADDR
// team := team ^ others ;
1051: LD_ADDR_VAR 0 6
1055: PUSH
1056: LD_VAR 0 6
1060: PUSH
1061: LD_VAR 0 2
1065: ADD
1066: ST_TO_ADDR
// InitHc ;
1067: CALL_OW 19
// if team <= 12 then
1071: LD_VAR 0 6
1075: PUSH
1076: LD_INT 12
1078: LESSEQUAL
1079: IFFALSE 1128
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1081: LD_INT 0
1083: PPUSH
1084: LD_INT 1
1086: PPUSH
1087: LD_INT 4
1089: PPUSH
1090: CALL_OW 12
1094: PPUSH
1095: LD_INT 5
1097: PPUSH
1098: CALL_OW 380
// team := team ^ CreateHuman ;
1102: LD_ADDR_VAR 0 6
1106: PUSH
1107: LD_VAR 0 6
1111: PUSH
1112: CALL_OW 44
1116: ADD
1117: ST_TO_ADDR
// until team > 12 ;
1118: LD_VAR 0 6
1122: PUSH
1123: LD_INT 12
1125: GREATER
1126: IFFALSE 1081
// for i in others do
1128: LD_ADDR_VAR 0 13
1132: PUSH
1133: LD_VAR 0 2
1137: PUSH
1138: FOR_IN
1139: IFFALSE 1207
// begin if GetClass ( i ) = 2 then
1141: LD_VAR 0 13
1145: PPUSH
1146: CALL_OW 257
1150: PUSH
1151: LD_INT 2
1153: EQUAL
1154: IFFALSE 1168
// SetClass ( i , 1 ) ;
1156: LD_VAR 0 13
1160: PPUSH
1161: LD_INT 1
1163: PPUSH
1164: CALL_OW 336
// for j = 1 to 4 do
1168: LD_ADDR_VAR 0 14
1172: PUSH
1173: DOUBLE
1174: LD_INT 1
1176: DEC
1177: ST_TO_ADDR
1178: LD_INT 4
1180: PUSH
1181: FOR_TO
1182: IFFALSE 1203
// AddExperience ( i , j , 3000 ) ;
1184: LD_VAR 0 13
1188: PPUSH
1189: LD_VAR 0 14
1193: PPUSH
1194: LD_INT 3000
1196: PPUSH
1197: CALL_OW 492
1201: GO 1181
1203: POP
1204: POP
// end ;
1205: GO 1138
1207: POP
1208: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1209: LD_ADDR_VAR 0 7
1213: PUSH
1214: LD_INT 30
1216: PUSH
1217: LD_INT 0
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: PPUSH
1224: CALL_OW 69
1228: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1229: LD_ADDR_VAR 0 8
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 4
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: PPUSH
1244: CALL_OW 69
1248: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1249: LD_ADDR_VAR 0 9
1253: PUSH
1254: LD_INT 2
1256: PUSH
1257: LD_INT 30
1259: PUSH
1260: LD_INT 7
1262: PUSH
1263: EMPTY
1264: LIST
1265: LIST
1266: PUSH
1267: LD_INT 30
1269: PUSH
1270: LD_INT 6
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: EMPTY
1278: LIST
1279: LIST
1280: LIST
1281: PPUSH
1282: CALL_OW 69
1286: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1287: LD_ADDR_VAR 0 10
1291: PUSH
1292: LD_INT 30
1294: PUSH
1295: LD_INT 3
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: PPUSH
1302: CALL_OW 69
1306: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1307: LD_ADDR_VAR 0 11
1311: PUSH
1312: LD_INT 2
1314: PUSH
1315: LD_INT 30
1317: PUSH
1318: LD_INT 32
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 30
1327: PUSH
1328: LD_INT 31
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: PUSH
1335: EMPTY
1336: LIST
1337: LIST
1338: LIST
1339: PPUSH
1340: CALL_OW 69
1344: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1345: LD_VAR 0 7
1349: PPUSH
1350: LD_STRING Gamma
1352: PPUSH
1353: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1357: LD_VAR 0 7
1361: PPUSH
1362: CALL_OW 274
1366: PPUSH
1367: LD_INT 2
1369: PPUSH
1370: LD_INT 10000
1372: PPUSH
1373: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1377: LD_VAR 0 7
1381: PPUSH
1382: CALL_OW 274
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_INT 10000
1392: PPUSH
1393: CALL_OW 277
// if dep then
1397: LD_VAR 0 7
1401: IFFALSE 1503
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1403: LD_EXP 7
1407: PPUSH
1408: LD_VAR 0 7
1412: PUSH
1413: LD_INT 1
1415: ARRAY
1416: PPUSH
1417: CALL_OW 52
// if Brown then
1421: LD_EXP 14
1425: IFFALSE 1461
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1427: LD_EXP 14
1431: PPUSH
1432: LD_VAR 0 7
1436: PUSH
1437: LD_INT 1
1439: ARRAY
1440: PPUSH
1441: CALL_OW 52
// team := team diff Brown ;
1445: LD_ADDR_VAR 0 6
1449: PUSH
1450: LD_VAR 0 6
1454: PUSH
1455: LD_EXP 14
1459: DIFF
1460: ST_TO_ADDR
// end ; if Donaldson then
1461: LD_EXP 13
1465: IFFALSE 1501
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1467: LD_EXP 13
1471: PPUSH
1472: LD_VAR 0 7
1476: PUSH
1477: LD_INT 1
1479: ARRAY
1480: PPUSH
1481: CALL_OW 52
// team := team diff Donaldson ;
1485: LD_ADDR_VAR 0 6
1489: PUSH
1490: LD_VAR 0 6
1494: PUSH
1495: LD_EXP 13
1499: DIFF
1500: ST_TO_ADDR
// end ; end else
1501: GO 1610
// begin PlaceUnitXYR ( JMM , 52 , 16 , 10 , false ) ;
1503: LD_EXP 7
1507: PPUSH
1508: LD_INT 52
1510: PPUSH
1511: LD_INT 16
1513: PPUSH
1514: LD_INT 10
1516: PPUSH
1517: LD_INT 0
1519: PPUSH
1520: CALL_OW 50
// if Brown then
1524: LD_EXP 14
1528: IFFALSE 1567
// begin PlaceUnitXYR ( Brown , 52 , 16 , 10 , false ) ;
1530: LD_EXP 14
1534: PPUSH
1535: LD_INT 52
1537: PPUSH
1538: LD_INT 16
1540: PPUSH
1541: LD_INT 10
1543: PPUSH
1544: LD_INT 0
1546: PPUSH
1547: CALL_OW 50
// team := team diff Brown ;
1551: LD_ADDR_VAR 0 6
1555: PUSH
1556: LD_VAR 0 6
1560: PUSH
1561: LD_EXP 14
1565: DIFF
1566: ST_TO_ADDR
// end ; if Donaldson then
1567: LD_EXP 13
1571: IFFALSE 1610
// begin PlaceUnitXYR ( Donaldson , 52 , 16 , 10 , false ) ;
1573: LD_EXP 13
1577: PPUSH
1578: LD_INT 52
1580: PPUSH
1581: LD_INT 16
1583: PPUSH
1584: LD_INT 10
1586: PPUSH
1587: LD_INT 0
1589: PPUSH
1590: CALL_OW 50
// team := team diff Donaldson ;
1594: LD_ADDR_VAR 0 6
1598: PUSH
1599: LD_VAR 0 6
1603: PUSH
1604: LD_EXP 13
1608: DIFF
1609: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1610: LD_VAR 0 11
1614: PUSH
1615: LD_VAR 0 6
1619: PPUSH
1620: LD_INT 25
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PPUSH
1630: CALL_OW 72
1634: AND
1635: IFFALSE 1744
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1637: LD_ADDR_VAR 0 12
1641: PUSH
1642: LD_VAR 0 6
1646: PPUSH
1647: LD_INT 25
1649: PUSH
1650: LD_INT 1
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: PPUSH
1657: CALL_OW 72
1661: ST_TO_ADDR
// for i in bun do
1662: LD_ADDR_VAR 0 13
1666: PUSH
1667: LD_VAR 0 11
1671: PUSH
1672: FOR_IN
1673: IFFALSE 1742
// begin if not filter then
1675: LD_VAR 0 12
1679: NOT
1680: IFFALSE 1684
// break ;
1682: GO 1742
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1684: LD_VAR 0 12
1688: PUSH
1689: LD_INT 1
1691: ARRAY
1692: PPUSH
1693: LD_VAR 0 13
1697: PPUSH
1698: CALL_OW 52
// team := team diff filter [ 1 ] ;
1702: LD_ADDR_VAR 0 6
1706: PUSH
1707: LD_VAR 0 6
1711: PUSH
1712: LD_VAR 0 12
1716: PUSH
1717: LD_INT 1
1719: ARRAY
1720: DIFF
1721: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1722: LD_ADDR_VAR 0 12
1726: PUSH
1727: LD_VAR 0 12
1731: PPUSH
1732: LD_INT 1
1734: PPUSH
1735: CALL_OW 3
1739: ST_TO_ADDR
// end ;
1740: GO 1672
1742: POP
1743: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1744: LD_VAR 0 8
1748: PUSH
1749: LD_VAR 0 6
1753: PPUSH
1754: LD_INT 25
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: EMPTY
1761: LIST
1762: LIST
1763: PPUSH
1764: CALL_OW 72
1768: AND
1769: IFFALSE 1891
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1771: LD_ADDR_VAR 0 12
1775: PUSH
1776: LD_VAR 0 6
1780: PPUSH
1781: LD_INT 25
1783: PUSH
1784: LD_INT 1
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PPUSH
1791: CALL_OW 72
1795: ST_TO_ADDR
// for i = 1 to filter do
1796: LD_ADDR_VAR 0 13
1800: PUSH
1801: DOUBLE
1802: LD_INT 1
1804: DEC
1805: ST_TO_ADDR
1806: LD_VAR 0 12
1810: PUSH
1811: FOR_TO
1812: IFFALSE 1873
// begin if ( i <= 6 ) then
1814: LD_VAR 0 13
1818: PUSH
1819: LD_INT 6
1821: LESSEQUAL
1822: IFFALSE 1850
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1824: LD_VAR 0 12
1828: PUSH
1829: LD_VAR 0 13
1833: ARRAY
1834: PPUSH
1835: LD_VAR 0 8
1839: PUSH
1840: LD_INT 1
1842: ARRAY
1843: PPUSH
1844: CALL_OW 52
1848: GO 1871
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1850: LD_VAR 0 12
1854: PUSH
1855: LD_VAR 0 13
1859: ARRAY
1860: PPUSH
1861: LD_INT 1
1863: PPUSH
1864: LD_INT 0
1866: PPUSH
1867: CALL_OW 49
// end ;
1871: GO 1811
1873: POP
1874: POP
// team := team diff filter ;
1875: LD_ADDR_VAR 0 6
1879: PUSH
1880: LD_VAR 0 6
1884: PUSH
1885: LD_VAR 0 12
1889: DIFF
1890: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1891: LD_VAR 0 9
1895: PUSH
1896: LD_VAR 0 6
1900: PPUSH
1901: LD_INT 25
1903: PUSH
1904: LD_INT 4
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: PPUSH
1911: CALL_OW 72
1915: AND
1916: IFFALSE 2038
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1918: LD_ADDR_VAR 0 12
1922: PUSH
1923: LD_VAR 0 6
1927: PPUSH
1928: LD_INT 25
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: EMPTY
1935: LIST
1936: LIST
1937: PPUSH
1938: CALL_OW 72
1942: ST_TO_ADDR
// for i = 1 to filter do
1943: LD_ADDR_VAR 0 13
1947: PUSH
1948: DOUBLE
1949: LD_INT 1
1951: DEC
1952: ST_TO_ADDR
1953: LD_VAR 0 12
1957: PUSH
1958: FOR_TO
1959: IFFALSE 2020
// begin if ( i <= 6 ) then
1961: LD_VAR 0 13
1965: PUSH
1966: LD_INT 6
1968: LESSEQUAL
1969: IFFALSE 1997
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1971: LD_VAR 0 12
1975: PUSH
1976: LD_VAR 0 13
1980: ARRAY
1981: PPUSH
1982: LD_VAR 0 9
1986: PUSH
1987: LD_INT 1
1989: ARRAY
1990: PPUSH
1991: CALL_OW 52
1995: GO 2018
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1997: LD_VAR 0 12
2001: PUSH
2002: LD_VAR 0 13
2006: ARRAY
2007: PPUSH
2008: LD_INT 1
2010: PPUSH
2011: LD_INT 0
2013: PPUSH
2014: CALL_OW 49
// end ;
2018: GO 1958
2020: POP
2021: POP
// team := team diff filter ;
2022: LD_ADDR_VAR 0 6
2026: PUSH
2027: LD_VAR 0 6
2031: PUSH
2032: LD_VAR 0 12
2036: DIFF
2037: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
2038: LD_VAR 0 10
2042: PUSH
2043: LD_VAR 0 6
2047: PPUSH
2048: LD_INT 25
2050: PUSH
2051: LD_INT 3
2053: PUSH
2054: EMPTY
2055: LIST
2056: LIST
2057: PPUSH
2058: CALL_OW 72
2062: AND
2063: IFFALSE 2185
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
2065: LD_ADDR_VAR 0 12
2069: PUSH
2070: LD_VAR 0 6
2074: PPUSH
2075: LD_INT 25
2077: PUSH
2078: LD_INT 3
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PPUSH
2085: CALL_OW 72
2089: ST_TO_ADDR
// for i = 1 to filter do
2090: LD_ADDR_VAR 0 13
2094: PUSH
2095: DOUBLE
2096: LD_INT 1
2098: DEC
2099: ST_TO_ADDR
2100: LD_VAR 0 12
2104: PUSH
2105: FOR_TO
2106: IFFALSE 2167
// begin if ( i <= 6 ) then
2108: LD_VAR 0 13
2112: PUSH
2113: LD_INT 6
2115: LESSEQUAL
2116: IFFALSE 2144
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2118: LD_VAR 0 12
2122: PUSH
2123: LD_VAR 0 13
2127: ARRAY
2128: PPUSH
2129: LD_VAR 0 10
2133: PUSH
2134: LD_INT 1
2136: ARRAY
2137: PPUSH
2138: CALL_OW 52
2142: GO 2165
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2144: LD_VAR 0 12
2148: PUSH
2149: LD_VAR 0 13
2153: ARRAY
2154: PPUSH
2155: LD_INT 1
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 2105
2167: POP
2168: POP
// team := team diff filter ;
2169: LD_ADDR_VAR 0 6
2173: PUSH
2174: LD_VAR 0 6
2178: PUSH
2179: LD_VAR 0 12
2183: DIFF
2184: ST_TO_ADDR
// end ; if team then
2185: LD_VAR 0 6
2189: IFFALSE 2232
// for i in team do
2191: LD_ADDR_VAR 0 13
2195: PUSH
2196: LD_VAR 0 6
2200: PUSH
2201: FOR_IN
2202: IFFALSE 2230
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2204: LD_VAR 0 13
2208: PPUSH
2209: LD_INT 1
2211: PPUSH
2212: LD_INT 0
2214: PPUSH
2215: CALL_OW 49
// ComHold ( i ) ;
2219: LD_VAR 0 13
2223: PPUSH
2224: CALL_OW 140
// end ;
2228: GO 2201
2230: POP
2231: POP
// if fac then
2232: LD_VAR 0 10
2236: IFFALSE 2272
// if UnitsInside ( fac [ 1 ] ) then
2238: LD_VAR 0 10
2242: PUSH
2243: LD_INT 1
2245: ARRAY
2246: PPUSH
2247: CALL_OW 313
2251: IFFALSE 2272
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2253: LD_VAR 0 10
2257: PUSH
2258: LD_INT 1
2260: ARRAY
2261: PPUSH
2262: LD_INT 10
2264: PPUSH
2265: LD_INT 0
2267: PPUSH
2268: CALL_OW 486
// if lab then
2272: LD_VAR 0 9
2276: IFFALSE 2312
// if UnitsInside ( lab [ 1 ] ) then
2278: LD_VAR 0 9
2282: PUSH
2283: LD_INT 1
2285: ARRAY
2286: PPUSH
2287: CALL_OW 313
2291: IFFALSE 2312
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2293: LD_VAR 0 9
2297: PUSH
2298: LD_INT 1
2300: ARRAY
2301: PPUSH
2302: LD_INT 10
2304: PPUSH
2305: LD_INT 0
2307: PPUSH
2308: CALL_OW 486
// uc_side := 4 ;
2312: LD_ADDR_OWVAR 20
2316: PUSH
2317: LD_INT 4
2319: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2320: LD_ADDR_EXP 17
2324: PUSH
2325: LD_STRING Harisson
2327: PPUSH
2328: LD_INT 0
2330: PPUSH
2331: LD_STRING 
2333: PPUSH
2334: CALL 4334 0 3
2338: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_double_gun , 100 ) ;
2339: LD_ADDR_VAR 0 5
2343: PUSH
2344: LD_INT 4
2346: PPUSH
2347: LD_INT 1
2349: PPUSH
2350: LD_INT 2
2352: PPUSH
2353: LD_INT 1
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: LD_INT 5
2361: PPUSH
2362: LD_INT 100
2364: PPUSH
2365: CALL 4397 0 7
2369: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2370: LD_VAR 0 5
2374: PPUSH
2375: LD_INT 2
2377: PPUSH
2378: CALL_OW 233
// PlaceUnitXY ( veh , 22 , 9 , false ) ;
2382: LD_VAR 0 5
2386: PPUSH
2387: LD_INT 22
2389: PPUSH
2390: LD_INT 9
2392: PPUSH
2393: LD_INT 0
2395: PPUSH
2396: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2400: LD_EXP 17
2404: PPUSH
2405: LD_VAR 0 5
2409: PPUSH
2410: CALL_OW 52
// PrepareHuman ( false , 1 , 0 ) ;
2414: LD_INT 0
2416: PPUSH
2417: LD_INT 1
2419: PPUSH
2420: LD_INT 0
2422: PPUSH
2423: CALL_OW 380
// RandGuy := CreateHuman ;
2427: LD_ADDR_EXP 19
2431: PUSH
2432: CALL_OW 44
2436: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 100 ) ;
2437: LD_ADDR_VAR 0 5
2441: PUSH
2442: LD_INT 4
2444: PPUSH
2445: LD_INT 1
2447: PPUSH
2448: LD_INT 2
2450: PPUSH
2451: LD_INT 1
2453: PPUSH
2454: LD_INT 1
2456: PPUSH
2457: LD_INT 4
2459: PPUSH
2460: LD_INT 100
2462: PPUSH
2463: CALL 4397 0 7
2467: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2468: LD_VAR 0 5
2472: PPUSH
2473: LD_INT 2
2475: PPUSH
2476: CALL_OW 233
// PlaceUnitXY ( veh , 17 , 4 , false ) ;
2480: LD_VAR 0 5
2484: PPUSH
2485: LD_INT 17
2487: PPUSH
2488: LD_INT 4
2490: PPUSH
2491: LD_INT 0
2493: PPUSH
2494: CALL_OW 48
// PlaceHumanInUnit ( RandGuy , veh ) ;
2498: LD_EXP 19
2502: PPUSH
2503: LD_VAR 0 5
2507: PPUSH
2508: CALL_OW 52
// end ;
2512: LD_VAR 0 1
2516: RET
// function PrepareBase ; var blist , i , b ; begin
2517: LD_INT 0
2519: PPUSH
2520: PPUSH
2521: PPUSH
2522: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2523: LD_INT 71
2525: PPUSH
2526: LD_INT 5
2528: PPUSH
2529: LD_INT 1
2531: PPUSH
2532: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_STRING GammaBase
2543: PPUSH
2544: EMPTY
2545: PPUSH
2546: CALL_OW 30
2550: ST_TO_ADDR
// if not blist then
2551: LD_VAR 0 2
2555: NOT
2556: IFFALSE 2596
// blist := [ [ b_depot , 52 , 12 , 3 , 3 , 0 , 0 ] ] ;
2558: LD_ADDR_VAR 0 2
2562: PUSH
2563: LD_INT 0
2565: PUSH
2566: LD_INT 52
2568: PUSH
2569: LD_INT 12
2571: PUSH
2572: LD_INT 3
2574: PUSH
2575: LD_INT 3
2577: PUSH
2578: LD_INT 0
2580: PUSH
2581: LD_INT 0
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: LIST
2589: LIST
2590: LIST
2591: LIST
2592: PUSH
2593: EMPTY
2594: LIST
2595: ST_TO_ADDR
// uc_side := 1 ;
2596: LD_ADDR_OWVAR 20
2600: PUSH
2601: LD_INT 1
2603: ST_TO_ADDR
// uc_nation := 1 ;
2604: LD_ADDR_OWVAR 21
2608: PUSH
2609: LD_INT 1
2611: ST_TO_ADDR
// bc_kind1 := - 1 ;
2612: LD_ADDR_OWVAR 44
2616: PUSH
2617: LD_INT 1
2619: NEG
2620: ST_TO_ADDR
// bc_kind2 := - 1 ;
2621: LD_ADDR_OWVAR 45
2625: PUSH
2626: LD_INT 1
2628: NEG
2629: ST_TO_ADDR
// for i in blist do
2630: LD_ADDR_VAR 0 3
2634: PUSH
2635: LD_VAR 0 2
2639: PUSH
2640: FOR_IN
2641: IFFALSE 2792
// begin bc_type := i [ 1 ] ;
2643: LD_ADDR_OWVAR 42
2647: PUSH
2648: LD_VAR 0 3
2652: PUSH
2653: LD_INT 1
2655: ARRAY
2656: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2657: LD_ADDR_OWVAR 43
2661: PUSH
2662: LD_VAR 0 3
2666: PUSH
2667: LD_INT 5
2669: ARRAY
2670: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2671: LD_VAR 0 3
2675: PUSH
2676: LD_INT 1
2678: ARRAY
2679: PUSH
2680: LD_INT 7
2682: PUSH
2683: LD_INT 8
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: IN
2690: IFFALSE 2720
// begin bc_kind1 := i [ 7 ] ;
2692: LD_ADDR_OWVAR 44
2696: PUSH
2697: LD_VAR 0 3
2701: PUSH
2702: LD_INT 7
2704: ARRAY
2705: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2706: LD_ADDR_OWVAR 45
2710: PUSH
2711: LD_VAR 0 3
2715: PUSH
2716: LD_INT 8
2718: ARRAY
2719: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_VAR 0 3
2729: PUSH
2730: LD_INT 2
2732: ARRAY
2733: PPUSH
2734: LD_VAR 0 3
2738: PUSH
2739: LD_INT 3
2741: ARRAY
2742: PPUSH
2743: LD_VAR 0 3
2747: PUSH
2748: LD_INT 4
2750: ARRAY
2751: PPUSH
2752: CALL_OW 47
2756: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2757: LD_VAR 0 4
2761: PPUSH
2762: CALL_OW 266
2766: PUSH
2767: LD_INT 32
2769: EQUAL
2770: IFFALSE 2790
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2772: LD_VAR 0 4
2776: PPUSH
2777: LD_VAR 0 3
2781: PUSH
2782: LD_INT 7
2784: ARRAY
2785: PPUSH
2786: CALL_OW 431
// end ; end ;
2790: GO 2640
2792: POP
2793: POP
// if not FilterAllUnits ( [ f_btype , b_depot ] ) then
2794: LD_INT 30
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PPUSH
2804: CALL_OW 69
2808: NOT
2809: IFFALSE 2846
// begin bc_type := b_depot ;
2811: LD_ADDR_OWVAR 42
2815: PUSH
2816: LD_INT 0
2818: ST_TO_ADDR
// bc_level := 6 ;
2819: LD_ADDR_OWVAR 43
2823: PUSH
2824: LD_INT 6
2826: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 52 , 12 , 3 ) ;
2827: LD_ADDR_VAR 0 4
2831: PUSH
2832: LD_INT 52
2834: PPUSH
2835: LD_INT 12
2837: PPUSH
2838: LD_INT 3
2840: PPUSH
2841: CALL_OW 47
2845: ST_TO_ADDR
// end ; end ; end_of_file
2846: LD_VAR 0 1
2850: RET
// export function Action ; var points , i , sol , time , team , filter ; begin
2851: LD_INT 0
2853: PPUSH
2854: PPUSH
2855: PPUSH
2856: PPUSH
2857: PPUSH
2858: PPUSH
2859: PPUSH
// InGameOn ;
2860: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2864: LD_INT 33
2866: PPUSH
2867: LD_INT 11
2869: PPUSH
2870: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: LD_INT 29
2881: PUSH
2882: LD_INT 21
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 41
2891: PUSH
2892: LD_INT 28
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: PUSH
2899: LD_INT 52
2901: PUSH
2902: LD_INT 26
2904: PUSH
2905: EMPTY
2906: LIST
2907: LIST
2908: PUSH
2909: LD_INT 49
2911: PUSH
2912: LD_INT 16
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: LIST
2923: LIST
2924: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2925: LD_ADDR_VAR 0 4
2929: PUSH
2930: LD_INT 22
2932: PUSH
2933: LD_INT 1
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_INT 26
2942: PUSH
2943: LD_INT 1
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: PUSH
2950: EMPTY
2951: LIST
2952: LIST
2953: PPUSH
2954: CALL_OW 69
2958: PUSH
2959: LD_EXP 7
2963: PUSH
2964: LD_EXP 14
2968: PUSH
2969: LD_EXP 11
2973: PUSH
2974: LD_EXP 12
2978: PUSH
2979: LD_EXP 8
2983: PUSH
2984: LD_EXP 15
2988: PUSH
2989: LD_EXP 16
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: LIST
3000: LIST
3001: LIST
3002: DIFF
3003: PUSH
3004: LD_INT 1
3006: ARRAY
3007: ST_TO_ADDR
// if sol then
3008: LD_VAR 0 4
3012: IFFALSE 3043
// begin ComMoveXY ( sol , 50 , 18 ) ;
3014: LD_VAR 0 4
3018: PPUSH
3019: LD_INT 50
3021: PPUSH
3022: LD_INT 18
3024: PPUSH
3025: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
3029: LD_VAR 0 4
3033: PPUSH
3034: LD_EXP 17
3038: PPUSH
3039: CALL_OW 179
// end ; for i in points do
3043: LD_ADDR_VAR 0 3
3047: PUSH
3048: LD_VAR 0 2
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3094
// AddComMoveXY ( [ Harisson , RandGuy ] , i [ 1 ] , i [ 2 ] ) ;
3056: LD_EXP 17
3060: PUSH
3061: LD_EXP 19
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: PPUSH
3070: LD_VAR 0 3
3074: PUSH
3075: LD_INT 1
3077: ARRAY
3078: PPUSH
3079: LD_VAR 0 3
3083: PUSH
3084: LD_INT 2
3086: ARRAY
3087: PPUSH
3088: CALL_OW 171
3092: GO 3053
3094: POP
3095: POP
// AddComExitVehicle ( [ Harisson , RandGuy ] ) ;
3096: LD_EXP 17
3100: PUSH
3101: LD_EXP 19
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL_OW 181
// AddComTurnUnit ( [ Harisson , RandGuy ] , sol ) ;
3114: LD_EXP 17
3118: PUSH
3119: LD_EXP 19
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: PPUSH
3128: LD_VAR 0 4
3132: PPUSH
3133: CALL_OW 179
// time := 0 0$20 ;
3137: LD_ADDR_VAR 0 5
3141: PUSH
3142: LD_INT 700
3144: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
3145: LD_INT 10
3147: PPUSH
3148: CALL_OW 67
// time := time - 0 0$0.3 ;
3152: LD_ADDR_VAR 0 5
3156: PUSH
3157: LD_VAR 0 5
3161: PUSH
3162: LD_INT 10
3164: MINUS
3165: ST_TO_ADDR
// until not IsInUnit ( Harisson ) or time <= 0 0$00 ;
3166: LD_EXP 17
3170: PPUSH
3171: CALL_OW 310
3175: NOT
3176: PUSH
3177: LD_VAR 0 5
3181: PUSH
3182: LD_INT 0
3184: LESSEQUAL
3185: OR
3186: IFFALSE 3145
// Say ( sol , D1-Sol1-1 ) ;
3188: LD_VAR 0 4
3192: PPUSH
3193: LD_STRING D1-Sol1-1
3195: PPUSH
3196: CALL_OW 88
// Say ( Harisson , D1-Har-1 ) ;
3200: LD_EXP 17
3204: PPUSH
3205: LD_STRING D1-Har-1
3207: PPUSH
3208: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
3212: LD_INT 10
3214: PPUSH
3215: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
3219: LD_VAR 0 4
3223: PPUSH
3224: LD_INT 35
3226: PPUSH
3227: LD_INT 21
3229: PPUSH
3230: CALL_OW 111
// ComExitBuilding ( JMM ) ;
3234: LD_EXP 7
3238: PPUSH
3239: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
3243: LD_EXP 7
3247: PPUSH
3248: LD_EXP 17
3252: PPUSH
3253: CALL_OW 172
// ComTurnUnit ( [ Harisson , RandGuy ] , JMM ) ;
3257: LD_EXP 17
3261: PUSH
3262: LD_EXP 19
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PPUSH
3271: LD_EXP 7
3275: PPUSH
3276: CALL_OW 119
// time := 0 0$3 ;
3280: LD_ADDR_VAR 0 5
3284: PUSH
3285: LD_INT 105
3287: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3288: LD_INT 35
3290: PPUSH
3291: CALL_OW 67
// time := time - 0 0$1 ;
3295: LD_ADDR_VAR 0 5
3299: PUSH
3300: LD_VAR 0 5
3304: PUSH
3305: LD_INT 35
3307: MINUS
3308: ST_TO_ADDR
// until GetDistUnits ( JMM , Harisson ) < 4 or time = 0 0$00 ;
3309: LD_EXP 7
3313: PPUSH
3314: LD_EXP 17
3318: PPUSH
3319: CALL_OW 296
3323: PUSH
3324: LD_INT 4
3326: LESS
3327: PUSH
3328: LD_VAR 0 5
3332: PUSH
3333: LD_INT 0
3335: EQUAL
3336: OR
3337: IFFALSE 3288
// ComTurnUnit ( JMM , Harisson ) ;
3339: LD_EXP 7
3343: PPUSH
3344: LD_EXP 17
3348: PPUSH
3349: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3353: LD_EXP 7
3357: PPUSH
3358: LD_STRING D1-JMM-1
3360: PPUSH
3361: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
3365: LD_EXP 17
3369: PPUSH
3370: LD_STRING D1-Har-2
3372: PPUSH
3373: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3377: LD_EXP 7
3381: PPUSH
3382: LD_STRING D1-JMM-2
3384: PPUSH
3385: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3389: LD_EXP 17
3393: PPUSH
3394: LD_STRING D1-Har-3
3396: PPUSH
3397: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3401: LD_EXP 7
3405: PPUSH
3406: LD_STRING D1-JMM-3
3408: PPUSH
3409: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3413: LD_EXP 17
3417: PPUSH
3418: LD_STRING D1-Har-4
3420: PPUSH
3421: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3425: LD_EXP 7
3429: PPUSH
3430: LD_STRING D1-JMM-4
3432: PPUSH
3433: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3437: LD_EXP 17
3441: PPUSH
3442: LD_STRING D1-Har-5
3444: PPUSH
3445: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3449: LD_EXP 7
3453: PPUSH
3454: LD_STRING D1-JMM-5
3456: PPUSH
3457: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3461: LD_EXP 17
3465: PPUSH
3466: LD_STRING D1-Har-6
3468: PPUSH
3469: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3473: LD_EXP 7
3477: PPUSH
3478: LD_STRING D1-JMM-6
3480: PPUSH
3481: CALL_OW 88
// EndMission ;
3485: CALL 3494 0 0
// end ;
3489: LD_VAR 0 1
3493: RET
// export function EndMission ; var commander , i , all ; begin
3494: LD_INT 0
3496: PPUSH
3497: PPUSH
3498: PPUSH
3499: PPUSH
// case gamma_commander of 1 :
3500: LD_EXP 18
3504: PUSH
3505: LD_INT 1
3507: DOUBLE
3508: EQUAL
3509: IFTRUE 3513
3511: GO 3526
3513: POP
// commander := Donaldson ; 2 :
3514: LD_ADDR_VAR 0 2
3518: PUSH
3519: LD_EXP 13
3523: ST_TO_ADDR
3524: GO 3569
3526: LD_INT 2
3528: DOUBLE
3529: EQUAL
3530: IFTRUE 3534
3532: GO 3547
3534: POP
// commander := Brown ; 3 :
3535: LD_ADDR_VAR 0 2
3539: PUSH
3540: LD_EXP 14
3544: ST_TO_ADDR
3545: GO 3569
3547: LD_INT 3
3549: DOUBLE
3550: EQUAL
3551: IFTRUE 3555
3553: GO 3568
3555: POP
// commander := Houten ; end ;
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_EXP 15
3565: ST_TO_ADDR
3566: GO 3569
3568: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3569: LD_ADDR_VAR 0 4
3573: PUSH
3574: LD_INT 22
3576: PUSH
3577: LD_INT 1
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 21
3586: PUSH
3587: LD_INT 1
3589: PUSH
3590: EMPTY
3591: LIST
3592: LIST
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: PPUSH
3598: CALL_OW 69
3602: PUSH
3603: LD_EXP 7
3607: PUSH
3608: LD_VAR 0 2
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: DIFF
3617: ST_TO_ADDR
// if UnitFilter ( all , [ f_class , 2 ] ) then
3618: LD_VAR 0 4
3622: PPUSH
3623: LD_INT 25
3625: PUSH
3626: LD_INT 2
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: PPUSH
3633: CALL_OW 72
3637: IFFALSE 3683
// for i in UnitFilter ( all , [ f_class , 2 ] ) do
3639: LD_ADDR_VAR 0 3
3643: PUSH
3644: LD_VAR 0 4
3648: PPUSH
3649: LD_INT 25
3651: PUSH
3652: LD_INT 2
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PPUSH
3659: CALL_OW 72
3663: PUSH
3664: FOR_IN
3665: IFFALSE 3681
// SetClass ( i , 2 ) ;
3667: LD_VAR 0 3
3671: PPUSH
3672: LD_INT 2
3674: PPUSH
3675: CALL_OW 336
3679: GO 3664
3681: POP
3682: POP
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable ] ^ [ commander , Harisson ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3683: LD_ADDR_EXP 4
3687: PUSH
3688: LD_STRING 1
3690: PPUSH
3691: LD_INT 10
3693: PPUSH
3694: LD_INT 10
3696: PPUSH
3697: LD_INT -5
3699: PUSH
3700: LD_EXP 7
3704: PUSH
3705: LD_INT -2
3707: PUSH
3708: LD_INT -3
3710: PUSH
3711: LD_INT -5
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_VAR 0 4
3725: ADD
3726: PUSH
3727: LD_INT -6
3729: PUSH
3730: LD_INT -4
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: ADD
3737: PUSH
3738: LD_VAR 0 2
3742: PUSH
3743: LD_EXP 17
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: ADD
3752: PPUSH
3753: LD_INT 1
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 3
3765: PUSH
3766: LD_INT 3
3768: PUSH
3769: LD_INT 6
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 4
3779: PUSH
3780: LD_INT 1
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: LIST
3791: PPUSH
3792: CALL_OW 42
3796: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3797: LD_VAR 0 4
3801: PUSH
3802: LD_EXP 7
3806: PUSH
3807: LD_EXP 8
3811: PUSH
3812: LD_EXP 10
3816: PUSH
3817: LD_EXP 11
3821: PUSH
3822: LD_EXP 12
3826: PUSH
3827: LD_EXP 9
3831: PUSH
3832: LD_EXP 13
3836: PUSH
3837: LD_EXP 14
3841: PUSH
3842: LD_EXP 15
3846: PUSH
3847: LD_EXP 17
3851: PUSH
3852: LD_EXP 16
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: LIST
3869: PUSH
3870: LD_EXP 4
3874: ADD
3875: DIFF
3876: PPUSH
3877: LD_STRING 07_othersGamma
3879: PPUSH
3880: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3884: LD_EXP 4
3888: PUSH
3889: LD_EXP 7
3893: PUSH
3894: LD_EXP 8
3898: PUSH
3899: LD_EXP 10
3903: PUSH
3904: LD_EXP 11
3908: PUSH
3909: LD_EXP 12
3913: PUSH
3914: LD_EXP 9
3918: PUSH
3919: LD_EXP 13
3923: PUSH
3924: LD_EXP 14
3928: PUSH
3929: LD_EXP 15
3933: PUSH
3934: LD_EXP 17
3938: PUSH
3939: LD_EXP 16
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: LIST
3955: LIST
3956: LIST
3957: LIST
3958: LIST
3959: LIST
3960: DIFF
3961: PPUSH
3962: LD_STRING 07_others
3964: PPUSH
3965: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3969: LD_EXP 7
3973: PPUSH
3974: LD_EXP 5
3978: PUSH
3979: LD_STRING JMM
3981: STR
3982: PPUSH
3983: CALL_OW 38
// if Lisa then
3987: LD_EXP 10
3991: IFFALSE 4033
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3993: LD_EXP 10
3997: PPUSH
3998: LD_EXP 5
4002: PUSH
4003: LD_STRING Lisa
4005: STR
4006: PPUSH
4007: CALL_OW 38
// if Lisa in save_group then
4011: LD_EXP 10
4015: PUSH
4016: LD_EXP 4
4020: IN
4021: IFFALSE 4033
// SaveVariable ( true , LisaIn07 ) ;
4023: LD_INT 1
4025: PPUSH
4026: LD_STRING LisaIn07
4028: PPUSH
4029: CALL_OW 39
// end ; if Bobby then
4033: LD_EXP 12
4037: IFFALSE 4079
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4039: LD_EXP 12
4043: PPUSH
4044: LD_EXP 5
4048: PUSH
4049: LD_STRING Bobby
4051: STR
4052: PPUSH
4053: CALL_OW 38
// if Bobby in save_group then
4057: LD_EXP 12
4061: PUSH
4062: LD_EXP 4
4066: IN
4067: IFFALSE 4079
// SaveVariable ( true , BobbyIn07 ) ;
4069: LD_INT 1
4071: PPUSH
4072: LD_STRING BobbyIn07
4074: PPUSH
4075: CALL_OW 39
// end ; if Cyrus then
4079: LD_EXP 11
4083: IFFALSE 4125
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4085: LD_EXP 11
4089: PPUSH
4090: LD_EXP 5
4094: PUSH
4095: LD_STRING Cyrus
4097: STR
4098: PPUSH
4099: CALL_OW 38
// if Cyrus in save_group then
4103: LD_EXP 11
4107: PUSH
4108: LD_EXP 4
4112: IN
4113: IFFALSE 4125
// SaveVariable ( true , CyrusIn07 ) ;
4115: LD_INT 1
4117: PPUSH
4118: LD_STRING CyrusIn07
4120: PPUSH
4121: CALL_OW 39
// end ; if Brown then
4125: LD_EXP 14
4129: IFFALSE 4171
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4131: LD_EXP 14
4135: PPUSH
4136: LD_EXP 5
4140: PUSH
4141: LD_STRING Brown
4143: STR
4144: PPUSH
4145: CALL_OW 38
// if Brown in save_group then
4149: LD_EXP 14
4153: PUSH
4154: LD_EXP 4
4158: IN
4159: IFFALSE 4171
// SaveVariable ( true , BrownIn07 ) ;
4161: LD_INT 1
4163: PPUSH
4164: LD_STRING BrownIn07
4166: PPUSH
4167: CALL_OW 39
// end ; if Donaldson then
4171: LD_EXP 13
4175: IFFALSE 4217
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4177: LD_EXP 13
4181: PPUSH
4182: LD_EXP 5
4186: PUSH
4187: LD_STRING Donaldson
4189: STR
4190: PPUSH
4191: CALL_OW 38
// if Donaldson in save_group then
4195: LD_EXP 13
4199: PUSH
4200: LD_EXP 4
4204: IN
4205: IFFALSE 4217
// SaveVariable ( true , DonaldsonIn07 ) ;
4207: LD_INT 1
4209: PPUSH
4210: LD_STRING DonaldsonIn07
4212: PPUSH
4213: CALL_OW 39
// end ; if Gladstone then
4217: LD_EXP 8
4221: IFFALSE 4263
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4223: LD_EXP 8
4227: PPUSH
4228: LD_EXP 5
4232: PUSH
4233: LD_STRING Gladstone
4235: STR
4236: PPUSH
4237: CALL_OW 38
// if Gladstone in save_group then
4241: LD_EXP 8
4245: PUSH
4246: LD_EXP 4
4250: IN
4251: IFFALSE 4263
// SaveVariable ( true , GladstoneIn07 ) ;
4253: LD_INT 1
4255: PPUSH
4256: LD_STRING GladstoneIn07
4258: PPUSH
4259: CALL_OW 39
// end ; if Khatam then
4263: LD_EXP 16
4267: IFFALSE 4309
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
4269: LD_EXP 16
4273: PPUSH
4274: LD_EXP 5
4278: PUSH
4279: LD_STRING Khatam
4281: STR
4282: PPUSH
4283: CALL_OW 38
// if Khatam in save_group then
4287: LD_EXP 16
4291: PUSH
4292: LD_EXP 4
4296: IN
4297: IFFALSE 4309
// SaveVariable ( true , KhatamIn07 ) ;
4299: LD_INT 1
4301: PPUSH
4302: LD_STRING KhatamIn07
4304: PPUSH
4305: CALL_OW 39
// end ; if debug then
4309: LD_EXP 1
4313: IFFALSE 4319
// InGameOff ;
4315: CALL_OW 9
// ChangeMap ( 1 , %_cont ) ;
4319: LD_INT 1
4321: PPUSH
4322: LD_STRING %_cont
4324: PPUSH
4325: CALL_OW 340
// end ; end_of_file
4329: LD_VAR 0 1
4333: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4334: LD_INT 0
4336: PPUSH
4337: PPUSH
// if exist_mode then
4338: LD_VAR 0 2
4342: IFFALSE 4367
// unit := CreateCharacter ( prefix & ident ) else
4344: LD_ADDR_VAR 0 5
4348: PUSH
4349: LD_VAR 0 3
4353: PUSH
4354: LD_VAR 0 1
4358: STR
4359: PPUSH
4360: CALL_OW 34
4364: ST_TO_ADDR
4365: GO 4382
// unit := NewCharacter ( ident ) ;
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 1
4376: PPUSH
4377: CALL_OW 25
4381: ST_TO_ADDR
// result := unit ;
4382: LD_ADDR_VAR 0 4
4386: PUSH
4387: LD_VAR 0 5
4391: ST_TO_ADDR
// end ;
4392: LD_VAR 0 4
4396: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4397: LD_INT 0
4399: PPUSH
// uc_side := side ;
4400: LD_ADDR_OWVAR 20
4404: PUSH
4405: LD_VAR 0 1
4409: ST_TO_ADDR
// uc_nation := nation ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_VAR 0 2
4419: ST_TO_ADDR
// vc_chassis := chassis ;
4420: LD_ADDR_OWVAR 37
4424: PUSH
4425: LD_VAR 0 3
4429: ST_TO_ADDR
// vc_engine := engine ;
4430: LD_ADDR_OWVAR 39
4434: PUSH
4435: LD_VAR 0 4
4439: ST_TO_ADDR
// vc_control := control ;
4440: LD_ADDR_OWVAR 38
4444: PUSH
4445: LD_VAR 0 5
4449: ST_TO_ADDR
// vc_weapon := weapon ;
4450: LD_ADDR_OWVAR 40
4454: PUSH
4455: LD_VAR 0 6
4459: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4460: LD_ADDR_OWVAR 41
4464: PUSH
4465: LD_VAR 0 7
4469: ST_TO_ADDR
// result := CreateVehicle ;
4470: LD_ADDR_VAR 0 8
4474: PUSH
4475: CALL_OW 45
4479: ST_TO_ADDR
// end ;
4480: LD_VAR 0 8
4484: RET
// export function SayX ( units , ident ) ; var i ; begin
4485: LD_INT 0
4487: PPUSH
4488: PPUSH
// result := false ;
4489: LD_ADDR_VAR 0 3
4493: PUSH
4494: LD_INT 0
4496: ST_TO_ADDR
// if not units then
4497: LD_VAR 0 1
4501: NOT
4502: IFFALSE 4506
// exit ;
4504: GO 4560
// for i in units do
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: LD_VAR 0 1
4515: PUSH
4516: FOR_IN
4517: IFFALSE 4558
// if IsOk ( i ) then
4519: LD_VAR 0 4
4523: PPUSH
4524: CALL_OW 302
4528: IFFALSE 4556
// begin Say ( i , ident ) ;
4530: LD_VAR 0 4
4534: PPUSH
4535: LD_VAR 0 2
4539: PPUSH
4540: CALL_OW 88
// result := i ;
4544: LD_ADDR_VAR 0 3
4548: PUSH
4549: LD_VAR 0 4
4553: ST_TO_ADDR
// break ;
4554: GO 4558
// end ;
4556: GO 4516
4558: POP
4559: POP
// end ;
4560: LD_VAR 0 3
4564: RET
