// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2528 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2249 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3835 0 3
 179: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 180: LD_EXP 7
 184: PPUSH
 185: CALL_OW 257
 189: PUSH
 190: LD_INT 2
 192: EQUAL
 193: IFFALSE 207
// SetClass ( JMM , 1 ) ;
 195: LD_EXP 7
 199: PPUSH
 200: LD_INT 1
 202: PPUSH
 203: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 207: LD_ADDR_EXP 18
 211: PUSH
 212: LD_STRING GammaCommander
 214: PPUSH
 215: LD_INT 3
 217: PPUSH
 218: CALL_OW 30
 222: ST_TO_ADDR
// if gamma_commander = 1 then
 223: LD_EXP 18
 227: PUSH
 228: LD_INT 1
 230: EQUAL
 231: IFFALSE 257
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 233: LD_ADDR_EXP 13
 237: PUSH
 238: LD_STRING Donaldson
 240: PPUSH
 241: LD_EXP 1
 245: NOT
 246: PPUSH
 247: LD_STRING 04_
 249: PPUSH
 250: CALL 3835 0 3
 254: ST_TO_ADDR
// end else
 255: GO 328
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 257: LD_STRING DonaldsonIn06
 259: PPUSH
 260: LD_INT 0
 262: PPUSH
 263: CALL_OW 30
 267: IFFALSE 293
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 269: LD_ADDR_EXP 13
 273: PUSH
 274: LD_STRING Donaldson
 276: PPUSH
 277: LD_EXP 1
 281: NOT
 282: PPUSH
 283: LD_STRING 06c_
 285: PPUSH
 286: CALL 3835 0 3
 290: ST_TO_ADDR
 291: GO 328
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 293: LD_STRING DonaldsonStayInDelta
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: CALL_OW 30
 303: NOT
 304: IFFALSE 328
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 306: LD_ADDR_EXP 13
 310: PUSH
 311: LD_STRING Donaldson
 313: PPUSH
 314: LD_EXP 1
 318: NOT
 319: PPUSH
 320: LD_STRING 04_
 322: PPUSH
 323: CALL 3835 0 3
 327: ST_TO_ADDR
// end ; if Donaldson then
 328: LD_EXP 13
 332: IFFALSE 350
// team := team ^ Donaldson ;
 334: LD_ADDR_VAR 0 6
 338: PUSH
 339: LD_VAR 0 6
 343: PUSH
 344: LD_EXP 13
 348: ADD
 349: ST_TO_ADDR
// if gamma_commander = 2 then
 350: LD_EXP 18
 354: PUSH
 355: LD_INT 2
 357: EQUAL
 358: IFFALSE 384
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 360: LD_ADDR_EXP 14
 364: PUSH
 365: LD_STRING Brown
 367: PPUSH
 368: LD_EXP 1
 372: NOT
 373: PPUSH
 374: LD_STRING 04_
 376: PPUSH
 377: CALL 3835 0 3
 381: ST_TO_ADDR
// end else
 382: GO 455
// begin if LoadVariable ( BrownIn06 , 0 ) then
 384: LD_STRING BrownIn06
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 30
 394: IFFALSE 420
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 396: LD_ADDR_EXP 14
 400: PUSH
 401: LD_STRING Brown
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: LD_STRING 06c_
 412: PPUSH
 413: CALL 3835 0 3
 417: ST_TO_ADDR
 418: GO 455
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 420: LD_STRING BrownStayInDelta
 422: PPUSH
 423: LD_INT 0
 425: PPUSH
 426: CALL_OW 30
 430: NOT
 431: IFFALSE 455
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 433: LD_ADDR_EXP 14
 437: PUSH
 438: LD_STRING Brown
 440: PPUSH
 441: LD_EXP 1
 445: NOT
 446: PPUSH
 447: LD_STRING 04_
 449: PPUSH
 450: CALL 3835 0 3
 454: ST_TO_ADDR
// end ; if Brown then
 455: LD_EXP 14
 459: IFFALSE 477
// team := team ^ Brown ;
 461: LD_ADDR_VAR 0 6
 465: PUSH
 466: LD_VAR 0 6
 470: PUSH
 471: LD_EXP 14
 475: ADD
 476: ST_TO_ADDR
// if gamma_commander = 3 then
 477: LD_EXP 18
 481: PUSH
 482: LD_INT 3
 484: EQUAL
 485: IFFALSE 522
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 487: LD_ADDR_EXP 15
 491: PUSH
 492: LD_STRING VanHouten
 494: PPUSH
 495: LD_INT 0
 497: PPUSH
 498: LD_STRING 
 500: PPUSH
 501: CALL 3835 0 3
 505: ST_TO_ADDR
// team := team ^ Houten ;
 506: LD_ADDR_VAR 0 6
 510: PUSH
 511: LD_VAR 0 6
 515: PUSH
 516: LD_EXP 15
 520: ADD
 521: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 522: LD_STRING GladstoneIn06
 524: PPUSH
 525: LD_INT 0
 527: PPUSH
 528: CALL_OW 30
 532: IFFALSE 558
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 534: LD_ADDR_EXP 8
 538: PUSH
 539: LD_STRING Gladstone
 541: PPUSH
 542: LD_EXP 1
 546: NOT
 547: PPUSH
 548: LD_STRING 06c_
 550: PPUSH
 551: CALL 3835 0 3
 555: ST_TO_ADDR
 556: GO 592
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 558: LD_STRING GladstoneStayInDelta
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 30
 568: IFFALSE 592
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 570: LD_ADDR_EXP 8
 574: PUSH
 575: LD_STRING Gladstone
 577: PPUSH
 578: LD_EXP 1
 582: NOT
 583: PPUSH
 584: LD_STRING 06_
 586: PPUSH
 587: CALL 3835 0 3
 591: ST_TO_ADDR
// if Gladstone then
 592: LD_EXP 8
 596: IFFALSE 614
// team := team ^ Gladstone ;
 598: LD_ADDR_VAR 0 6
 602: PUSH
 603: LD_VAR 0 6
 607: PUSH
 608: LD_EXP 8
 612: ADD
 613: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 614: LD_ADDR_EXP 16
 618: PUSH
 619: LD_STRING Khatam
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 03_
 630: PPUSH
 631: CALL 3835 0 3
 635: ST_TO_ADDR
// if Khatam then
 636: LD_EXP 16
 640: IFFALSE 658
// team := team ^ Khatam ;
 642: LD_ADDR_VAR 0 6
 646: PUSH
 647: LD_VAR 0 6
 651: PUSH
 652: LD_EXP 16
 656: ADD
 657: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 658: LD_STRING LisaIn06
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 30
 668: IFFALSE 694
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 670: LD_ADDR_EXP 10
 674: PUSH
 675: LD_STRING Lisa
 677: PPUSH
 678: LD_EXP 1
 682: NOT
 683: PPUSH
 684: LD_STRING 06c_
 686: PPUSH
 687: CALL 3835 0 3
 691: ST_TO_ADDR
 692: GO 729
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 694: LD_STRING LisaStayInDelta
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: CALL_OW 30
 704: NOT
 705: IFFALSE 729
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 707: LD_ADDR_EXP 10
 711: PUSH
 712: LD_STRING Lisa
 714: PPUSH
 715: LD_EXP 1
 719: NOT
 720: PPUSH
 721: LD_STRING 04_
 723: PPUSH
 724: CALL 3835 0 3
 728: ST_TO_ADDR
// if Lisa then
 729: LD_EXP 10
 733: IFFALSE 751
// team := team ^ Lisa ;
 735: LD_ADDR_VAR 0 6
 739: PUSH
 740: LD_VAR 0 6
 744: PUSH
 745: LD_EXP 10
 749: ADD
 750: ST_TO_ADDR
// if not Lisa then
 751: LD_EXP 10
 755: NOT
 756: IFFALSE 1009
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 758: LD_STRING CyrusIn06
 760: PPUSH
 761: LD_INT 0
 763: PPUSH
 764: CALL_OW 30
 768: IFFALSE 794
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 770: LD_ADDR_EXP 11
 774: PUSH
 775: LD_STRING Cyrus
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 06c_
 786: PPUSH
 787: CALL 3835 0 3
 791: ST_TO_ADDR
 792: GO 858
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 794: LD_STRING CyrusStayInDelta
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 30
 804: NOT
 805: IFFALSE 858
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 807: LD_ADDR_EXP 11
 811: PUSH
 812: LD_STRING Cyrus
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 04_
 823: PPUSH
 824: CALL 3835 0 3
 828: ST_TO_ADDR
// if not Cyrus then
 829: LD_EXP 11
 833: NOT
 834: IFFALSE 858
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 836: LD_ADDR_EXP 11
 840: PUSH
 841: LD_STRING Cyrus
 843: PPUSH
 844: LD_EXP 1
 848: NOT
 849: PPUSH
 850: LD_STRING 03_
 852: PPUSH
 853: CALL 3835 0 3
 857: ST_TO_ADDR
// end ; if Cyrus then
 858: LD_EXP 11
 862: IFFALSE 880
// team := team ^ Cyrus ;
 864: LD_ADDR_VAR 0 6
 868: PUSH
 869: LD_VAR 0 6
 873: PUSH
 874: LD_EXP 11
 878: ADD
 879: ST_TO_ADDR
// if not Cyrus then
 880: LD_EXP 11
 884: NOT
 885: IFFALSE 1009
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 887: LD_STRING BobbyIn06
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 30
 897: IFFALSE 923
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 899: LD_ADDR_EXP 12
 903: PUSH
 904: LD_STRING Bobby
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 06c_
 915: PPUSH
 916: CALL 3835 0 3
 920: ST_TO_ADDR
 921: GO 987
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 923: LD_STRING BobbyStayInDelta
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: NOT
 934: IFFALSE 987
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 936: LD_ADDR_EXP 12
 940: PUSH
 941: LD_STRING Bobby
 943: PPUSH
 944: LD_EXP 1
 948: NOT
 949: PPUSH
 950: LD_STRING 04_
 952: PPUSH
 953: CALL 3835 0 3
 957: ST_TO_ADDR
// if not Bobby then
 958: LD_EXP 12
 962: NOT
 963: IFFALSE 987
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 965: LD_ADDR_EXP 12
 969: PUSH
 970: LD_STRING Bobby
 972: PPUSH
 973: LD_EXP 1
 977: NOT
 978: PPUSH
 979: LD_STRING 03_
 981: PPUSH
 982: CALL 3835 0 3
 986: ST_TO_ADDR
// end ; if Bobby then
 987: LD_EXP 12
 991: IFFALSE 1009
// team := team ^ Bobby ;
 993: LD_ADDR_VAR 0 6
 997: PUSH
 998: LD_VAR 0 6
1002: PUSH
1003: LD_EXP 12
1007: ADD
1008: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1009: LD_ADDR_VAR 0 4
1013: PUSH
1014: LD_STRING othersGamma
1016: PPUSH
1017: CALL_OW 31
1021: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_STRING 06_other_survivors
1029: PPUSH
1030: CALL_OW 31
1034: ST_TO_ADDR
// others := others union others4 ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_VAR 0 4
1049: UNION
1050: ST_TO_ADDR
// team := team ^ others ;
1051: LD_ADDR_VAR 0 6
1055: PUSH
1056: LD_VAR 0 6
1060: PUSH
1061: LD_VAR 0 2
1065: ADD
1066: ST_TO_ADDR
// for i in others do
1067: LD_ADDR_VAR 0 13
1071: PUSH
1072: LD_VAR 0 2
1076: PUSH
1077: FOR_IN
1078: IFFALSE 1146
// begin if GetClass ( i ) = 2 then
1080: LD_VAR 0 13
1084: PPUSH
1085: CALL_OW 257
1089: PUSH
1090: LD_INT 2
1092: EQUAL
1093: IFFALSE 1107
// SetClass ( i , 1 ) ;
1095: LD_VAR 0 13
1099: PPUSH
1100: LD_INT 1
1102: PPUSH
1103: CALL_OW 336
// for j = 1 to 4 do
1107: LD_ADDR_VAR 0 14
1111: PUSH
1112: DOUBLE
1113: LD_INT 1
1115: DEC
1116: ST_TO_ADDR
1117: LD_INT 4
1119: PUSH
1120: FOR_TO
1121: IFFALSE 1142
// AddExperience ( i , j , 3000 ) ;
1123: LD_VAR 0 13
1127: PPUSH
1128: LD_VAR 0 14
1132: PPUSH
1133: LD_INT 3000
1135: PPUSH
1136: CALL_OW 492
1140: GO 1120
1142: POP
1143: POP
// end ;
1144: GO 1077
1146: POP
1147: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1148: LD_ADDR_VAR 0 7
1152: PUSH
1153: LD_INT 30
1155: PUSH
1156: LD_INT 0
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: PPUSH
1163: CALL_OW 69
1167: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1168: LD_ADDR_VAR 0 8
1172: PUSH
1173: LD_INT 30
1175: PUSH
1176: LD_INT 4
1178: PUSH
1179: EMPTY
1180: LIST
1181: LIST
1182: PPUSH
1183: CALL_OW 69
1187: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1188: LD_ADDR_VAR 0 9
1192: PUSH
1193: LD_INT 2
1195: PUSH
1196: LD_INT 30
1198: PUSH
1199: LD_INT 7
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PUSH
1206: LD_INT 30
1208: PUSH
1209: LD_INT 6
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: PPUSH
1221: CALL_OW 69
1225: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1226: LD_ADDR_VAR 0 10
1230: PUSH
1231: LD_INT 30
1233: PUSH
1234: LD_INT 3
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL_OW 69
1245: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1246: LD_ADDR_VAR 0 11
1250: PUSH
1251: LD_INT 2
1253: PUSH
1254: LD_INT 30
1256: PUSH
1257: LD_INT 32
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: PUSH
1264: LD_INT 30
1266: PUSH
1267: LD_INT 31
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: LIST
1278: PPUSH
1279: CALL_OW 69
1283: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1284: LD_VAR 0 7
1288: PPUSH
1289: LD_STRING Gamma
1291: PPUSH
1292: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1296: LD_VAR 0 7
1300: PPUSH
1301: CALL_OW 274
1305: PPUSH
1306: LD_INT 2
1308: PPUSH
1309: LD_INT 10000
1311: PPUSH
1312: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1316: LD_VAR 0 7
1320: PPUSH
1321: CALL_OW 274
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_INT 10000
1331: PPUSH
1332: CALL_OW 277
// if dep then
1336: LD_VAR 0 7
1340: IFFALSE 1440
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1342: LD_EXP 7
1346: PPUSH
1347: LD_VAR 0 7
1351: PUSH
1352: LD_INT 1
1354: ARRAY
1355: PPUSH
1356: CALL_OW 52
// if Brown then
1360: LD_EXP 14
1364: IFFALSE 1400
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1366: LD_EXP 14
1370: PPUSH
1371: LD_VAR 0 7
1375: PUSH
1376: LD_INT 1
1378: ARRAY
1379: PPUSH
1380: CALL_OW 52
// team := team diff Brown ;
1384: LD_ADDR_VAR 0 6
1388: PUSH
1389: LD_VAR 0 6
1393: PUSH
1394: LD_EXP 14
1398: DIFF
1399: ST_TO_ADDR
// end ; if Donaldson then
1400: LD_EXP 13
1404: IFFALSE 1440
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1406: LD_EXP 13
1410: PPUSH
1411: LD_VAR 0 7
1415: PUSH
1416: LD_INT 1
1418: ARRAY
1419: PPUSH
1420: CALL_OW 52
// team := team diff Donaldson ;
1424: LD_ADDR_VAR 0 6
1428: PUSH
1429: LD_VAR 0 6
1433: PUSH
1434: LD_EXP 13
1438: DIFF
1439: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1440: LD_VAR 0 11
1444: PUSH
1445: LD_VAR 0 6
1449: PPUSH
1450: LD_INT 25
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: EMPTY
1457: LIST
1458: LIST
1459: PPUSH
1460: CALL_OW 72
1464: AND
1465: IFFALSE 1574
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1467: LD_ADDR_VAR 0 12
1471: PUSH
1472: LD_VAR 0 6
1476: PPUSH
1477: LD_INT 25
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: EMPTY
1484: LIST
1485: LIST
1486: PPUSH
1487: CALL_OW 72
1491: ST_TO_ADDR
// for i in bun do
1492: LD_ADDR_VAR 0 13
1496: PUSH
1497: LD_VAR 0 11
1501: PUSH
1502: FOR_IN
1503: IFFALSE 1572
// begin if not filter then
1505: LD_VAR 0 12
1509: NOT
1510: IFFALSE 1514
// break ;
1512: GO 1572
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1514: LD_VAR 0 12
1518: PUSH
1519: LD_INT 1
1521: ARRAY
1522: PPUSH
1523: LD_VAR 0 13
1527: PPUSH
1528: CALL_OW 52
// team := team diff filter [ 1 ] ;
1532: LD_ADDR_VAR 0 6
1536: PUSH
1537: LD_VAR 0 6
1541: PUSH
1542: LD_VAR 0 12
1546: PUSH
1547: LD_INT 1
1549: ARRAY
1550: DIFF
1551: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1552: LD_ADDR_VAR 0 12
1556: PUSH
1557: LD_VAR 0 12
1561: PPUSH
1562: LD_INT 1
1564: PPUSH
1565: CALL_OW 3
1569: ST_TO_ADDR
// end ;
1570: GO 1502
1572: POP
1573: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1574: LD_VAR 0 8
1578: PUSH
1579: LD_VAR 0 6
1583: PPUSH
1584: LD_INT 25
1586: PUSH
1587: LD_INT 1
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 72
1598: AND
1599: IFFALSE 1721
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1601: LD_ADDR_VAR 0 12
1605: PUSH
1606: LD_VAR 0 6
1610: PPUSH
1611: LD_INT 25
1613: PUSH
1614: LD_INT 1
1616: PUSH
1617: EMPTY
1618: LIST
1619: LIST
1620: PPUSH
1621: CALL_OW 72
1625: ST_TO_ADDR
// for i = 1 to filter do
1626: LD_ADDR_VAR 0 13
1630: PUSH
1631: DOUBLE
1632: LD_INT 1
1634: DEC
1635: ST_TO_ADDR
1636: LD_VAR 0 12
1640: PUSH
1641: FOR_TO
1642: IFFALSE 1703
// begin if ( i <= 6 ) then
1644: LD_VAR 0 13
1648: PUSH
1649: LD_INT 6
1651: LESSEQUAL
1652: IFFALSE 1680
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1654: LD_VAR 0 12
1658: PUSH
1659: LD_VAR 0 13
1663: ARRAY
1664: PPUSH
1665: LD_VAR 0 8
1669: PUSH
1670: LD_INT 1
1672: ARRAY
1673: PPUSH
1674: CALL_OW 52
1678: GO 1701
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1680: LD_VAR 0 12
1684: PUSH
1685: LD_VAR 0 13
1689: ARRAY
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 0
1696: PPUSH
1697: CALL_OW 49
// end ;
1701: GO 1641
1703: POP
1704: POP
// team := team diff filter ;
1705: LD_ADDR_VAR 0 6
1709: PUSH
1710: LD_VAR 0 6
1714: PUSH
1715: LD_VAR 0 12
1719: DIFF
1720: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1721: LD_VAR 0 9
1725: PUSH
1726: LD_VAR 0 6
1730: PPUSH
1731: LD_INT 25
1733: PUSH
1734: LD_INT 4
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: PPUSH
1741: CALL_OW 72
1745: AND
1746: IFFALSE 1868
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1748: LD_ADDR_VAR 0 12
1752: PUSH
1753: LD_VAR 0 6
1757: PPUSH
1758: LD_INT 25
1760: PUSH
1761: LD_INT 4
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PPUSH
1768: CALL_OW 72
1772: ST_TO_ADDR
// for i = 1 to filter do
1773: LD_ADDR_VAR 0 13
1777: PUSH
1778: DOUBLE
1779: LD_INT 1
1781: DEC
1782: ST_TO_ADDR
1783: LD_VAR 0 12
1787: PUSH
1788: FOR_TO
1789: IFFALSE 1850
// begin if ( i <= 6 ) then
1791: LD_VAR 0 13
1795: PUSH
1796: LD_INT 6
1798: LESSEQUAL
1799: IFFALSE 1827
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1801: LD_VAR 0 12
1805: PUSH
1806: LD_VAR 0 13
1810: ARRAY
1811: PPUSH
1812: LD_VAR 0 9
1816: PUSH
1817: LD_INT 1
1819: ARRAY
1820: PPUSH
1821: CALL_OW 52
1825: GO 1848
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1827: LD_VAR 0 12
1831: PUSH
1832: LD_VAR 0 13
1836: ARRAY
1837: PPUSH
1838: LD_INT 1
1840: PPUSH
1841: LD_INT 0
1843: PPUSH
1844: CALL_OW 49
// end ;
1848: GO 1788
1850: POP
1851: POP
// team := team diff filter ;
1852: LD_ADDR_VAR 0 6
1856: PUSH
1857: LD_VAR 0 6
1861: PUSH
1862: LD_VAR 0 12
1866: DIFF
1867: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1868: LD_VAR 0 10
1872: PUSH
1873: LD_VAR 0 6
1877: PPUSH
1878: LD_INT 25
1880: PUSH
1881: LD_INT 3
1883: PUSH
1884: EMPTY
1885: LIST
1886: LIST
1887: PPUSH
1888: CALL_OW 72
1892: AND
1893: IFFALSE 2015
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1895: LD_ADDR_VAR 0 12
1899: PUSH
1900: LD_VAR 0 6
1904: PPUSH
1905: LD_INT 25
1907: PUSH
1908: LD_INT 3
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: PPUSH
1915: CALL_OW 72
1919: ST_TO_ADDR
// for i = 1 to filter do
1920: LD_ADDR_VAR 0 13
1924: PUSH
1925: DOUBLE
1926: LD_INT 1
1928: DEC
1929: ST_TO_ADDR
1930: LD_VAR 0 12
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1997
// begin if ( i <= 6 ) then
1938: LD_VAR 0 13
1942: PUSH
1943: LD_INT 6
1945: LESSEQUAL
1946: IFFALSE 1974
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1948: LD_VAR 0 12
1952: PUSH
1953: LD_VAR 0 13
1957: ARRAY
1958: PPUSH
1959: LD_VAR 0 10
1963: PUSH
1964: LD_INT 1
1966: ARRAY
1967: PPUSH
1968: CALL_OW 52
1972: GO 1995
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1974: LD_VAR 0 12
1978: PUSH
1979: LD_VAR 0 13
1983: ARRAY
1984: PPUSH
1985: LD_INT 1
1987: PPUSH
1988: LD_INT 0
1990: PPUSH
1991: CALL_OW 49
// end ;
1995: GO 1935
1997: POP
1998: POP
// team := team diff filter ;
1999: LD_ADDR_VAR 0 6
2003: PUSH
2004: LD_VAR 0 6
2008: PUSH
2009: LD_VAR 0 12
2013: DIFF
2014: ST_TO_ADDR
// end ; if team then
2015: LD_VAR 0 6
2019: IFFALSE 2062
// for i in team do
2021: LD_ADDR_VAR 0 13
2025: PUSH
2026: LD_VAR 0 6
2030: PUSH
2031: FOR_IN
2032: IFFALSE 2060
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2034: LD_VAR 0 13
2038: PPUSH
2039: LD_INT 1
2041: PPUSH
2042: LD_INT 0
2044: PPUSH
2045: CALL_OW 49
// ComHold ( i ) ;
2049: LD_VAR 0 13
2053: PPUSH
2054: CALL_OW 140
// end ;
2058: GO 2031
2060: POP
2061: POP
// if fac then
2062: LD_VAR 0 10
2066: IFFALSE 2102
// if UnitsInside ( fac [ 1 ] ) then
2068: LD_VAR 0 10
2072: PUSH
2073: LD_INT 1
2075: ARRAY
2076: PPUSH
2077: CALL_OW 313
2081: IFFALSE 2102
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2083: LD_VAR 0 10
2087: PUSH
2088: LD_INT 1
2090: ARRAY
2091: PPUSH
2092: LD_INT 10
2094: PPUSH
2095: LD_INT 0
2097: PPUSH
2098: CALL_OW 486
// if lab then
2102: LD_VAR 0 9
2106: IFFALSE 2142
// if UnitsInside ( lab [ 1 ] ) then
2108: LD_VAR 0 9
2112: PUSH
2113: LD_INT 1
2115: ARRAY
2116: PPUSH
2117: CALL_OW 313
2121: IFFALSE 2142
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2123: LD_VAR 0 9
2127: PUSH
2128: LD_INT 1
2130: ARRAY
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: LD_INT 0
2137: PPUSH
2138: CALL_OW 486
// uc_side := 4 ;
2142: LD_ADDR_OWVAR 20
2146: PUSH
2147: LD_INT 4
2149: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2150: LD_ADDR_EXP 17
2154: PUSH
2155: LD_STRING Harisson
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: LD_STRING 
2163: PPUSH
2164: CALL 3835 0 3
2168: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2169: LD_ADDR_VAR 0 5
2173: PUSH
2174: LD_INT 4
2176: PPUSH
2177: LD_INT 1
2179: PPUSH
2180: LD_INT 1
2182: PPUSH
2183: LD_INT 1
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 2
2191: PPUSH
2192: LD_INT 100
2194: PPUSH
2195: CALL 3898 0 7
2199: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2200: LD_VAR 0 5
2204: PPUSH
2205: LD_INT 2
2207: PPUSH
2208: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2212: LD_VAR 0 5
2216: PPUSH
2217: LD_INT 21
2219: PPUSH
2220: LD_INT 8
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2230: LD_EXP 17
2234: PPUSH
2235: LD_VAR 0 5
2239: PPUSH
2240: CALL_OW 52
// end ;
2244: LD_VAR 0 1
2248: RET
// function PrepareBase ; var blist , i , b ; begin
2249: LD_INT 0
2251: PPUSH
2252: PPUSH
2253: PPUSH
2254: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2255: LD_INT 71
2257: PPUSH
2258: LD_INT 5
2260: PPUSH
2261: LD_INT 1
2263: PPUSH
2264: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2268: LD_ADDR_VAR 0 2
2272: PUSH
2273: LD_STRING GammaBase
2275: PPUSH
2276: EMPTY
2277: PPUSH
2278: CALL_OW 30
2282: ST_TO_ADDR
// if not blist and debug then
2283: LD_VAR 0 2
2287: NOT
2288: PUSH
2289: LD_EXP 1
2293: AND
2294: IFFALSE 2334
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2296: LD_ADDR_VAR 0 2
2300: PUSH
2301: LD_INT 0
2303: PUSH
2304: LD_INT 51
2306: PUSH
2307: LD_INT 10
2309: PUSH
2310: LD_INT 3
2312: PUSH
2313: LD_INT 3
2315: PUSH
2316: LD_INT 0
2318: PUSH
2319: LD_INT 0
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: LIST
2326: LIST
2327: LIST
2328: LIST
2329: LIST
2330: PUSH
2331: EMPTY
2332: LIST
2333: ST_TO_ADDR
// if not blist then
2334: LD_VAR 0 2
2338: NOT
2339: IFFALSE 2343
// exit ;
2341: GO 2523
// uc_side := 1 ;
2343: LD_ADDR_OWVAR 20
2347: PUSH
2348: LD_INT 1
2350: ST_TO_ADDR
// uc_nation := 1 ;
2351: LD_ADDR_OWVAR 21
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// for i in blist do
2359: LD_ADDR_VAR 0 3
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: FOR_IN
2370: IFFALSE 2521
// begin bc_type := i [ 1 ] ;
2372: LD_ADDR_OWVAR 42
2376: PUSH
2377: LD_VAR 0 3
2381: PUSH
2382: LD_INT 1
2384: ARRAY
2385: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2386: LD_ADDR_OWVAR 43
2390: PUSH
2391: LD_VAR 0 3
2395: PUSH
2396: LD_INT 5
2398: ARRAY
2399: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2400: LD_VAR 0 3
2404: PUSH
2405: LD_INT 1
2407: ARRAY
2408: PUSH
2409: LD_INT 7
2411: PUSH
2412: LD_INT 8
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: IN
2419: IFFALSE 2449
// begin bc_kind1 := i [ 7 ] ;
2421: LD_ADDR_OWVAR 44
2425: PUSH
2426: LD_VAR 0 3
2430: PUSH
2431: LD_INT 7
2433: ARRAY
2434: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2435: LD_ADDR_OWVAR 45
2439: PUSH
2440: LD_VAR 0 3
2444: PUSH
2445: LD_INT 8
2447: ARRAY
2448: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2449: LD_ADDR_VAR 0 4
2453: PUSH
2454: LD_VAR 0 3
2458: PUSH
2459: LD_INT 2
2461: ARRAY
2462: PPUSH
2463: LD_VAR 0 3
2467: PUSH
2468: LD_INT 3
2470: ARRAY
2471: PPUSH
2472: LD_VAR 0 3
2476: PUSH
2477: LD_INT 4
2479: ARRAY
2480: PPUSH
2481: CALL_OW 47
2485: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2486: LD_VAR 0 4
2490: PPUSH
2491: CALL_OW 266
2495: PUSH
2496: LD_INT 32
2498: EQUAL
2499: IFFALSE 2519
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2501: LD_VAR 0 4
2505: PPUSH
2506: LD_VAR 0 3
2510: PUSH
2511: LD_INT 7
2513: ARRAY
2514: PPUSH
2515: CALL_OW 431
// end ; end ;
2519: GO 2369
2521: POP
2522: POP
// end ; end_of_file
2523: LD_VAR 0 1
2527: RET
// export function Action ; var points , i , sol , team , filter ; begin
2528: LD_INT 0
2530: PPUSH
2531: PPUSH
2532: PPUSH
2533: PPUSH
2534: PPUSH
2535: PPUSH
// InGameOn ;
2536: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2540: LD_INT 33
2542: PPUSH
2543: LD_INT 11
2545: PPUSH
2546: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2550: LD_ADDR_VAR 0 2
2554: PUSH
2555: LD_INT 29
2557: PUSH
2558: LD_INT 21
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PUSH
2565: LD_INT 41
2567: PUSH
2568: LD_INT 28
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 52
2577: PUSH
2578: LD_INT 26
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: LD_INT 49
2587: PUSH
2588: LD_INT 16
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PUSH
2595: EMPTY
2596: LIST
2597: LIST
2598: LIST
2599: LIST
2600: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2601: LD_ADDR_VAR 0 4
2605: PUSH
2606: LD_INT 22
2608: PUSH
2609: LD_INT 1
2611: PUSH
2612: EMPTY
2613: LIST
2614: LIST
2615: PUSH
2616: LD_INT 26
2618: PUSH
2619: LD_INT 1
2621: PUSH
2622: EMPTY
2623: LIST
2624: LIST
2625: PUSH
2626: EMPTY
2627: LIST
2628: LIST
2629: PPUSH
2630: CALL_OW 69
2634: PUSH
2635: LD_EXP 7
2639: PUSH
2640: LD_EXP 14
2644: PUSH
2645: LD_EXP 11
2649: PUSH
2650: LD_EXP 12
2654: PUSH
2655: LD_EXP 8
2659: PUSH
2660: LD_EXP 15
2664: PUSH
2665: LD_EXP 16
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: DIFF
2679: PUSH
2680: LD_INT 1
2682: ARRAY
2683: ST_TO_ADDR
// if sol then
2684: LD_VAR 0 4
2688: IFFALSE 2719
// begin ComMoveXY ( sol , 50 , 18 ) ;
2690: LD_VAR 0 4
2694: PPUSH
2695: LD_INT 50
2697: PPUSH
2698: LD_INT 18
2700: PPUSH
2701: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2705: LD_VAR 0 4
2709: PPUSH
2710: LD_EXP 17
2714: PPUSH
2715: CALL_OW 179
// end ; for i in points do
2719: LD_ADDR_VAR 0 3
2723: PUSH
2724: LD_VAR 0 2
2728: PUSH
2729: FOR_IN
2730: IFFALSE 2761
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2732: LD_EXP 17
2736: PPUSH
2737: LD_VAR 0 3
2741: PUSH
2742: LD_INT 1
2744: ARRAY
2745: PPUSH
2746: LD_VAR 0 3
2750: PUSH
2751: LD_INT 2
2753: ARRAY
2754: PPUSH
2755: CALL_OW 171
2759: GO 2729
2761: POP
2762: POP
// AddComExitVehicle ( Harisson ) ;
2763: LD_EXP 17
2767: PPUSH
2768: CALL_OW 181
// repeat wait ( 3 ) ;
2772: LD_INT 3
2774: PPUSH
2775: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2779: LD_EXP 17
2783: PPUSH
2784: CALL_OW 310
2788: NOT
2789: IFFALSE 2772
// Say ( sol , D1-Sol1-1 ) ;
2791: LD_VAR 0 4
2795: PPUSH
2796: LD_STRING D1-Sol1-1
2798: PPUSH
2799: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2803: LD_EXP 17
2807: PPUSH
2808: LD_VAR 0 4
2812: PPUSH
2813: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2817: LD_EXP 17
2821: PPUSH
2822: LD_STRING D1-Har-1
2824: PPUSH
2825: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2829: LD_INT 10
2831: PPUSH
2832: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2836: LD_VAR 0 4
2840: PPUSH
2841: LD_INT 35
2843: PPUSH
2844: LD_INT 21
2846: PPUSH
2847: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2851: LD_EXP 7
2855: PPUSH
2856: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2860: LD_EXP 7
2864: PPUSH
2865: LD_EXP 17
2869: PPUSH
2870: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2874: LD_EXP 17
2878: PPUSH
2879: LD_EXP 7
2883: PPUSH
2884: CALL_OW 119
// repeat wait ( 3 ) ;
2888: LD_INT 3
2890: PPUSH
2891: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2895: LD_EXP 7
2899: PPUSH
2900: LD_EXP 17
2904: PPUSH
2905: CALL_OW 296
2909: PUSH
2910: LD_INT 4
2912: LESS
2913: IFFALSE 2888
// ComTurnUnit ( JMM , Harisson ) ;
2915: LD_EXP 7
2919: PPUSH
2920: LD_EXP 17
2924: PPUSH
2925: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2929: LD_EXP 7
2933: PPUSH
2934: LD_STRING D1-JMM-1
2936: PPUSH
2937: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2941: LD_EXP 17
2945: PPUSH
2946: LD_STRING D1-Har-2
2948: PPUSH
2949: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
2953: LD_EXP 7
2957: PPUSH
2958: LD_STRING D1-JMM-2
2960: PPUSH
2961: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
2965: LD_EXP 17
2969: PPUSH
2970: LD_STRING D1-Har-3
2972: PPUSH
2973: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2977: LD_EXP 7
2981: PPUSH
2982: LD_STRING D1-JMM-3
2984: PPUSH
2985: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
2989: LD_EXP 17
2993: PPUSH
2994: LD_STRING D1-Har-4
2996: PPUSH
2997: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3001: LD_EXP 7
3005: PPUSH
3006: LD_STRING D1-JMM-4
3008: PPUSH
3009: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3013: LD_EXP 17
3017: PPUSH
3018: LD_STRING D1-Har-5
3020: PPUSH
3021: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3025: LD_EXP 7
3029: PPUSH
3030: LD_STRING D1-JMM-5
3032: PPUSH
3033: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3037: LD_EXP 17
3041: PPUSH
3042: LD_STRING D1-Har-6
3044: PPUSH
3045: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3049: LD_EXP 7
3053: PPUSH
3054: LD_STRING D1-JMM-6
3056: PPUSH
3057: CALL_OW 88
// EndMission ;
3061: CALL 3070 0 0
// end ;
3065: LD_VAR 0 1
3069: RET
// export function EndMission ; var commander , i , all ; begin
3070: LD_INT 0
3072: PPUSH
3073: PPUSH
3074: PPUSH
3075: PPUSH
// case gamma_commander of 1 :
3076: LD_EXP 18
3080: PUSH
3081: LD_INT 1
3083: DOUBLE
3084: EQUAL
3085: IFTRUE 3089
3087: GO 3102
3089: POP
// commander := Donaldson ; 2 :
3090: LD_ADDR_VAR 0 2
3094: PUSH
3095: LD_EXP 13
3099: ST_TO_ADDR
3100: GO 3145
3102: LD_INT 2
3104: DOUBLE
3105: EQUAL
3106: IFTRUE 3110
3108: GO 3123
3110: POP
// commander := Brown ; 3 :
3111: LD_ADDR_VAR 0 2
3115: PUSH
3116: LD_EXP 14
3120: ST_TO_ADDR
3121: GO 3145
3123: LD_INT 3
3125: DOUBLE
3126: EQUAL
3127: IFTRUE 3131
3129: GO 3144
3131: POP
// commander := Houten ; end ;
3132: LD_ADDR_VAR 0 2
3136: PUSH
3137: LD_EXP 15
3141: ST_TO_ADDR
3142: GO 3145
3144: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3145: LD_ADDR_VAR 0 4
3149: PUSH
3150: LD_INT 22
3152: PUSH
3153: LD_INT 1
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: LD_INT 21
3162: PUSH
3163: LD_INT 1
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: PPUSH
3174: CALL_OW 69
3178: PUSH
3179: LD_EXP 7
3183: PUSH
3184: LD_VAR 0 2
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: DIFF
3193: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3194: LD_ADDR_EXP 4
3198: PUSH
3199: LD_STRING 1
3201: PPUSH
3202: LD_INT 10
3204: PPUSH
3205: LD_INT 10
3207: PPUSH
3208: LD_INT -5
3210: PUSH
3211: LD_EXP 7
3215: PUSH
3216: LD_INT -2
3218: PUSH
3219: LD_INT -3
3221: PUSH
3222: LD_INT -5
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: PUSH
3232: LD_VAR 0 4
3236: ADD
3237: PUSH
3238: LD_INT -6
3240: PUSH
3241: LD_INT -4
3243: PUSH
3244: LD_VAR 0 2
3248: PUSH
3249: LD_EXP 17
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: LIST
3262: ADD
3263: PPUSH
3264: LD_INT 1
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 3
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 6
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_INT 4
3290: PUSH
3291: LD_INT 1
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: PPUSH
3303: CALL_OW 42
3307: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3308: LD_VAR 0 4
3312: PUSH
3313: LD_EXP 7
3317: PUSH
3318: LD_EXP 8
3322: PUSH
3323: LD_EXP 10
3327: PUSH
3328: LD_EXP 11
3332: PUSH
3333: LD_EXP 12
3337: PUSH
3338: LD_EXP 9
3342: PUSH
3343: LD_EXP 13
3347: PUSH
3348: LD_EXP 14
3352: PUSH
3353: LD_EXP 15
3357: PUSH
3358: LD_EXP 17
3362: PUSH
3363: LD_EXP 16
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: LIST
3372: LIST
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: PUSH
3381: LD_EXP 4
3385: ADD
3386: DIFF
3387: PPUSH
3388: LD_STRING 07_othersGamma
3390: PPUSH
3391: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3395: LD_EXP 4
3399: PUSH
3400: LD_EXP 7
3404: PUSH
3405: LD_EXP 8
3409: PUSH
3410: LD_EXP 10
3414: PUSH
3415: LD_EXP 11
3419: PUSH
3420: LD_EXP 12
3424: PUSH
3425: LD_EXP 9
3429: PUSH
3430: LD_EXP 13
3434: PUSH
3435: LD_EXP 14
3439: PUSH
3440: LD_EXP 15
3444: PUSH
3445: LD_EXP 17
3449: PUSH
3450: LD_EXP 16
3454: PUSH
3455: LD_INT 0
3457: PUSH
3458: EMPTY
3459: LIST
3460: LIST
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: DIFF
3472: PPUSH
3473: LD_STRING 07_others
3475: PPUSH
3476: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3480: LD_EXP 7
3484: PPUSH
3485: LD_EXP 5
3489: PUSH
3490: LD_STRING JMM
3492: STR
3493: PPUSH
3494: CALL_OW 38
// if Lisa then
3498: LD_EXP 10
3502: IFFALSE 3544
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3504: LD_EXP 10
3508: PPUSH
3509: LD_EXP 5
3513: PUSH
3514: LD_STRING Lisa
3516: STR
3517: PPUSH
3518: CALL_OW 38
// if Lisa in save_group then
3522: LD_EXP 10
3526: PUSH
3527: LD_EXP 4
3531: IN
3532: IFFALSE 3544
// SaveVariable ( true , LisaIn07 ) ;
3534: LD_INT 1
3536: PPUSH
3537: LD_STRING LisaIn07
3539: PPUSH
3540: CALL_OW 39
// end ; if Bobby then
3544: LD_EXP 12
3548: IFFALSE 3590
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3550: LD_EXP 12
3554: PPUSH
3555: LD_EXP 5
3559: PUSH
3560: LD_STRING Bobby
3562: STR
3563: PPUSH
3564: CALL_OW 38
// if Bobby in save_group then
3568: LD_EXP 12
3572: PUSH
3573: LD_EXP 4
3577: IN
3578: IFFALSE 3590
// SaveVariable ( true , BobbyIn07 ) ;
3580: LD_INT 1
3582: PPUSH
3583: LD_STRING BobbyIn07
3585: PPUSH
3586: CALL_OW 39
// end ; if Cyrus then
3590: LD_EXP 11
3594: IFFALSE 3636
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3596: LD_EXP 11
3600: PPUSH
3601: LD_EXP 5
3605: PUSH
3606: LD_STRING Cyrus
3608: STR
3609: PPUSH
3610: CALL_OW 38
// if Cyrus in save_group then
3614: LD_EXP 11
3618: PUSH
3619: LD_EXP 4
3623: IN
3624: IFFALSE 3636
// SaveVariable ( true , CyrusIn07 ) ;
3626: LD_INT 1
3628: PPUSH
3629: LD_STRING CyrusIn07
3631: PPUSH
3632: CALL_OW 39
// end ; if Brown then
3636: LD_EXP 14
3640: IFFALSE 3682
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3642: LD_EXP 14
3646: PPUSH
3647: LD_EXP 5
3651: PUSH
3652: LD_STRING Brown
3654: STR
3655: PPUSH
3656: CALL_OW 38
// if Brown in save_group then
3660: LD_EXP 14
3664: PUSH
3665: LD_EXP 4
3669: IN
3670: IFFALSE 3682
// SaveVariable ( true , BrownIn07 ) ;
3672: LD_INT 1
3674: PPUSH
3675: LD_STRING BrownIn07
3677: PPUSH
3678: CALL_OW 39
// end ; if Donaldson then
3682: LD_EXP 13
3686: IFFALSE 3728
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3688: LD_EXP 13
3692: PPUSH
3693: LD_EXP 5
3697: PUSH
3698: LD_STRING Donaldson
3700: STR
3701: PPUSH
3702: CALL_OW 38
// if Donaldson in save_group then
3706: LD_EXP 13
3710: PUSH
3711: LD_EXP 4
3715: IN
3716: IFFALSE 3728
// SaveVariable ( true , DonaldsonIn07 ) ;
3718: LD_INT 1
3720: PPUSH
3721: LD_STRING DonaldsonIn07
3723: PPUSH
3724: CALL_OW 39
// end ; if Gladstone then
3728: LD_EXP 8
3732: IFFALSE 3774
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3734: LD_EXP 8
3738: PPUSH
3739: LD_EXP 5
3743: PUSH
3744: LD_STRING Gladstone
3746: STR
3747: PPUSH
3748: CALL_OW 38
// if Gladstone in save_group then
3752: LD_EXP 8
3756: PUSH
3757: LD_EXP 4
3761: IN
3762: IFFALSE 3774
// SaveVariable ( true , GladstoneIn07 ) ;
3764: LD_INT 1
3766: PPUSH
3767: LD_STRING GladstoneIn07
3769: PPUSH
3770: CALL_OW 39
// end ; if Khatam then
3774: LD_EXP 16
3778: IFFALSE 3820
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3780: LD_EXP 16
3784: PPUSH
3785: LD_EXP 5
3789: PUSH
3790: LD_STRING Khatam
3792: STR
3793: PPUSH
3794: CALL_OW 38
// if Khatam in save_group then
3798: LD_EXP 16
3802: PUSH
3803: LD_EXP 4
3807: IN
3808: IFFALSE 3820
// SaveVariable ( true , KhatamIn07 ) ;
3810: LD_INT 1
3812: PPUSH
3813: LD_STRING KhatamIn07
3815: PPUSH
3816: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3820: LD_INT 1
3822: PPUSH
3823: LD_STRING %_cont
3825: PPUSH
3826: CALL_OW 340
// end ; end_of_file
3830: LD_VAR 0 1
3834: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3835: LD_INT 0
3837: PPUSH
3838: PPUSH
// if exist_mode then
3839: LD_VAR 0 2
3843: IFFALSE 3868
// unit := CreateCharacter ( prefix & ident ) else
3845: LD_ADDR_VAR 0 5
3849: PUSH
3850: LD_VAR 0 3
3854: PUSH
3855: LD_VAR 0 1
3859: STR
3860: PPUSH
3861: CALL_OW 34
3865: ST_TO_ADDR
3866: GO 3883
// unit := NewCharacter ( ident ) ;
3868: LD_ADDR_VAR 0 5
3872: PUSH
3873: LD_VAR 0 1
3877: PPUSH
3878: CALL_OW 25
3882: ST_TO_ADDR
// result := unit ;
3883: LD_ADDR_VAR 0 4
3887: PUSH
3888: LD_VAR 0 5
3892: ST_TO_ADDR
// end ;
3893: LD_VAR 0 4
3897: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3898: LD_INT 0
3900: PPUSH
// uc_side := side ;
3901: LD_ADDR_OWVAR 20
3905: PUSH
3906: LD_VAR 0 1
3910: ST_TO_ADDR
// uc_nation := nation ;
3911: LD_ADDR_OWVAR 21
3915: PUSH
3916: LD_VAR 0 2
3920: ST_TO_ADDR
// vc_chassis := chassis ;
3921: LD_ADDR_OWVAR 37
3925: PUSH
3926: LD_VAR 0 3
3930: ST_TO_ADDR
// vc_engine := engine ;
3931: LD_ADDR_OWVAR 39
3935: PUSH
3936: LD_VAR 0 4
3940: ST_TO_ADDR
// vc_control := control ;
3941: LD_ADDR_OWVAR 38
3945: PUSH
3946: LD_VAR 0 5
3950: ST_TO_ADDR
// vc_weapon := weapon ;
3951: LD_ADDR_OWVAR 40
3955: PUSH
3956: LD_VAR 0 6
3960: ST_TO_ADDR
// vc_fuel_battery := fuel ;
3961: LD_ADDR_OWVAR 41
3965: PUSH
3966: LD_VAR 0 7
3970: ST_TO_ADDR
// result := CreateVehicle ;
3971: LD_ADDR_VAR 0 8
3975: PUSH
3976: CALL_OW 45
3980: ST_TO_ADDR
// end ;
3981: LD_VAR 0 8
3985: RET
// export function SayX ( units , ident ) ; var i ; begin
3986: LD_INT 0
3988: PPUSH
3989: PPUSH
// result := false ;
3990: LD_ADDR_VAR 0 3
3994: PUSH
3995: LD_INT 0
3997: ST_TO_ADDR
// if not units then
3998: LD_VAR 0 1
4002: NOT
4003: IFFALSE 4007
// exit ;
4005: GO 4061
// for i in units do
4007: LD_ADDR_VAR 0 4
4011: PUSH
4012: LD_VAR 0 1
4016: PUSH
4017: FOR_IN
4018: IFFALSE 4059
// if IsOk ( i ) then
4020: LD_VAR 0 4
4024: PPUSH
4025: CALL_OW 302
4029: IFFALSE 4057
// begin Say ( i , ident ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_VAR 0 2
4040: PPUSH
4041: CALL_OW 88
// result := i ;
4045: LD_ADDR_VAR 0 3
4049: PUSH
4050: LD_VAR 0 4
4054: ST_TO_ADDR
// break ;
4055: GO 4059
// end ;
4057: GO 4017
4059: POP
4060: POP
// end ;
4061: LD_VAR 0 3
4065: RET
