// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2337 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2058 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3515 0 3
 179: ST_TO_ADDR
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_STRING GammaCommander
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: CALL_OW 30
 195: ST_TO_ADDR
// display_strings := gamma_commander ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_EXP 17
 205: ST_TO_ADDR
// if gamma_commander = 1 then
 206: LD_EXP 17
 210: PUSH
 211: LD_INT 1
 213: EQUAL
 214: IFFALSE 240
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 216: LD_ADDR_EXP 13
 220: PUSH
 221: LD_STRING Donaldson
 223: PPUSH
 224: LD_EXP 1
 228: NOT
 229: PPUSH
 230: LD_STRING 04_
 232: PPUSH
 233: CALL 3515 0 3
 237: ST_TO_ADDR
// end else
 238: GO 298
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 240: LD_STRING DonaldsonIn06
 242: PPUSH
 243: LD_INT 0
 245: PPUSH
 246: CALL_OW 30
 250: IFFALSE 276
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 252: LD_ADDR_EXP 13
 256: PUSH
 257: LD_STRING Donaldson
 259: PPUSH
 260: LD_EXP 1
 264: NOT
 265: PPUSH
 266: LD_STRING 06c_
 268: PPUSH
 269: CALL 3515 0 3
 273: ST_TO_ADDR
 274: GO 298
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 276: LD_ADDR_EXP 13
 280: PUSH
 281: LD_STRING Donaldson
 283: PPUSH
 284: LD_EXP 1
 288: NOT
 289: PPUSH
 290: LD_STRING 04_
 292: PPUSH
 293: CALL 3515 0 3
 297: ST_TO_ADDR
// end ; if Donaldson then
 298: LD_EXP 13
 302: IFFALSE 320
// team := team ^ Donaldson ;
 304: LD_ADDR_VAR 0 6
 308: PUSH
 309: LD_VAR 0 6
 313: PUSH
 314: LD_EXP 13
 318: ADD
 319: ST_TO_ADDR
// if gamma_commander = 2 then
 320: LD_EXP 17
 324: PUSH
 325: LD_INT 2
 327: EQUAL
 328: IFFALSE 354
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 330: LD_ADDR_EXP 14
 334: PUSH
 335: LD_STRING Brown
 337: PPUSH
 338: LD_EXP 1
 342: NOT
 343: PPUSH
 344: LD_STRING 04_
 346: PPUSH
 347: CALL 3515 0 3
 351: ST_TO_ADDR
// end else
 352: GO 412
// begin if LoadVariable ( BrownIn06 , 0 ) then
 354: LD_STRING BrownIn06
 356: PPUSH
 357: LD_INT 0
 359: PPUSH
 360: CALL_OW 30
 364: IFFALSE 390
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 366: LD_ADDR_EXP 14
 370: PUSH
 371: LD_STRING Brown
 373: PPUSH
 374: LD_EXP 1
 378: NOT
 379: PPUSH
 380: LD_STRING 06c_
 382: PPUSH
 383: CALL 3515 0 3
 387: ST_TO_ADDR
 388: GO 412
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 390: LD_ADDR_EXP 14
 394: PUSH
 395: LD_STRING Brown
 397: PPUSH
 398: LD_EXP 1
 402: NOT
 403: PPUSH
 404: LD_STRING 04_
 406: PPUSH
 407: CALL 3515 0 3
 411: ST_TO_ADDR
// end ; if Brown then
 412: LD_EXP 14
 416: IFFALSE 434
// team := team ^ Brown ;
 418: LD_ADDR_VAR 0 6
 422: PUSH
 423: LD_VAR 0 6
 427: PUSH
 428: LD_EXP 14
 432: ADD
 433: ST_TO_ADDR
// if gamma_commander = 3 then
 434: LD_EXP 17
 438: PUSH
 439: LD_INT 3
 441: EQUAL
 442: IFFALSE 479
// begin Houten := PrepareUnit ( Houten , false ,  ) ;
 444: LD_ADDR_EXP 15
 448: PUSH
 449: LD_STRING Houten
 451: PPUSH
 452: LD_INT 0
 454: PPUSH
 455: LD_STRING 
 457: PPUSH
 458: CALL 3515 0 3
 462: ST_TO_ADDR
// team := team ^ Houten ;
 463: LD_ADDR_VAR 0 6
 467: PUSH
 468: LD_VAR 0 6
 472: PUSH
 473: LD_EXP 15
 477: ADD
 478: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 479: LD_STRING GladstoneIn06
 481: PPUSH
 482: LD_INT 0
 484: PPUSH
 485: CALL_OW 30
 489: IFFALSE 513
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) ;
 491: LD_ADDR_EXP 8
 495: PUSH
 496: LD_STRING Gladstone
 498: PPUSH
 499: LD_EXP 1
 503: NOT
 504: PPUSH
 505: LD_STRING 06c_
 507: PPUSH
 508: CALL 3515 0 3
 512: ST_TO_ADDR
// if Gladstone then
 513: LD_EXP 8
 517: IFFALSE 535
// team := team ^ Gladstone ;
 519: LD_ADDR_VAR 0 6
 523: PUSH
 524: LD_VAR 0 6
 528: PUSH
 529: LD_EXP 8
 533: ADD
 534: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 535: LD_STRING LisaIn06
 537: PPUSH
 538: LD_INT 0
 540: PPUSH
 541: CALL_OW 30
 545: IFFALSE 571
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 547: LD_ADDR_EXP 10
 551: PUSH
 552: LD_STRING Lisa
 554: PPUSH
 555: LD_EXP 1
 559: NOT
 560: PPUSH
 561: LD_STRING 06c_
 563: PPUSH
 564: CALL 3515 0 3
 568: ST_TO_ADDR
 569: GO 593
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 571: LD_ADDR_EXP 10
 575: PUSH
 576: LD_STRING Lisa
 578: PPUSH
 579: LD_EXP 1
 583: NOT
 584: PPUSH
 585: LD_STRING 04_
 587: PPUSH
 588: CALL 3515 0 3
 592: ST_TO_ADDR
// if Lisa then
 593: LD_EXP 10
 597: IFFALSE 615
// team := team ^ Lisa ;
 599: LD_ADDR_VAR 0 6
 603: PUSH
 604: LD_VAR 0 6
 608: PUSH
 609: LD_EXP 10
 613: ADD
 614: ST_TO_ADDR
// if not Lisa then
 615: LD_EXP 10
 619: NOT
 620: IFFALSE 789
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 622: LD_STRING CyrusIn06
 624: PPUSH
 625: LD_INT 0
 627: PPUSH
 628: CALL_OW 30
 632: IFFALSE 658
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 634: LD_ADDR_EXP 11
 638: PUSH
 639: LD_STRING Cyrus
 641: PPUSH
 642: LD_EXP 1
 646: NOT
 647: PPUSH
 648: LD_STRING 06c_
 650: PPUSH
 651: CALL 3515 0 3
 655: ST_TO_ADDR
 656: GO 680
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 658: LD_ADDR_EXP 11
 662: PUSH
 663: LD_STRING Cyrus
 665: PPUSH
 666: LD_EXP 1
 670: NOT
 671: PPUSH
 672: LD_STRING 04_
 674: PPUSH
 675: CALL 3515 0 3
 679: ST_TO_ADDR
// if Cyrus then
 680: LD_EXP 11
 684: IFFALSE 702
// team := team ^ Cyrus ;
 686: LD_ADDR_VAR 0 6
 690: PUSH
 691: LD_VAR 0 6
 695: PUSH
 696: LD_EXP 11
 700: ADD
 701: ST_TO_ADDR
// if not Cyrus then
 702: LD_EXP 11
 706: NOT
 707: IFFALSE 789
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 709: LD_STRING BobbyIn06
 711: PPUSH
 712: LD_INT 0
 714: PPUSH
 715: CALL_OW 30
 719: IFFALSE 745
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 721: LD_ADDR_EXP 12
 725: PUSH
 726: LD_STRING Bobby
 728: PPUSH
 729: LD_EXP 1
 733: NOT
 734: PPUSH
 735: LD_STRING 06c_
 737: PPUSH
 738: CALL 3515 0 3
 742: ST_TO_ADDR
 743: GO 767
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 745: LD_ADDR_EXP 12
 749: PUSH
 750: LD_STRING Bobby
 752: PPUSH
 753: LD_EXP 1
 757: NOT
 758: PPUSH
 759: LD_STRING 04_
 761: PPUSH
 762: CALL 3515 0 3
 766: ST_TO_ADDR
// if Bobby then
 767: LD_EXP 12
 771: IFFALSE 789
// team := team ^ Bobby ;
 773: LD_ADDR_VAR 0 6
 777: PUSH
 778: LD_VAR 0 6
 782: PUSH
 783: LD_EXP 12
 787: ADD
 788: ST_TO_ADDR
// end ; end ; others_delta := CreateCharacterSet ( 05_other_survivors ) ;
 789: LD_ADDR_VAR 0 3
 793: PUSH
 794: LD_STRING 05_other_survivors
 796: PPUSH
 797: CALL_OW 31
 801: ST_TO_ADDR
// others4 := CreateCharacterSet ( othersGamma ) ;
 802: LD_ADDR_VAR 0 4
 806: PUSH
 807: LD_STRING othersGamma
 809: PPUSH
 810: CALL_OW 31
 814: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
 815: LD_ADDR_VAR 0 2
 819: PUSH
 820: LD_STRING 06_other_survivors
 822: PPUSH
 823: CALL_OW 31
 827: ST_TO_ADDR
// others := others union others4 ;
 828: LD_ADDR_VAR 0 2
 832: PUSH
 833: LD_VAR 0 2
 837: PUSH
 838: LD_VAR 0 4
 842: UNION
 843: ST_TO_ADDR
// others := others diff others_delta ;
 844: LD_ADDR_VAR 0 2
 848: PUSH
 849: LD_VAR 0 2
 853: PUSH
 854: LD_VAR 0 3
 858: DIFF
 859: ST_TO_ADDR
// team := team ^ others ;
 860: LD_ADDR_VAR 0 6
 864: PUSH
 865: LD_VAR 0 6
 869: PUSH
 870: LD_VAR 0 2
 874: ADD
 875: ST_TO_ADDR
// for i in others do
 876: LD_ADDR_VAR 0 13
 880: PUSH
 881: LD_VAR 0 2
 885: PUSH
 886: FOR_IN
 887: IFFALSE 955
// begin if GetClass ( i ) = 2 then
 889: LD_VAR 0 13
 893: PPUSH
 894: CALL_OW 257
 898: PUSH
 899: LD_INT 2
 901: EQUAL
 902: IFFALSE 916
// SetClass ( i , 1 ) ;
 904: LD_VAR 0 13
 908: PPUSH
 909: LD_INT 1
 911: PPUSH
 912: CALL_OW 336
// for j = 1 to 4 do
 916: LD_ADDR_VAR 0 14
 920: PUSH
 921: DOUBLE
 922: LD_INT 1
 924: DEC
 925: ST_TO_ADDR
 926: LD_INT 4
 928: PUSH
 929: FOR_TO
 930: IFFALSE 951
// AddExperience ( i , j , 3000 ) ;
 932: LD_VAR 0 13
 936: PPUSH
 937: LD_VAR 0 14
 941: PPUSH
 942: LD_INT 3000
 944: PPUSH
 945: CALL_OW 492
 949: GO 929
 951: POP
 952: POP
// end ;
 953: GO 886
 955: POP
 956: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 957: LD_ADDR_VAR 0 7
 961: PUSH
 962: LD_INT 30
 964: PUSH
 965: LD_INT 0
 967: PUSH
 968: EMPTY
 969: LIST
 970: LIST
 971: PPUSH
 972: CALL_OW 69
 976: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 977: LD_ADDR_VAR 0 8
 981: PUSH
 982: LD_INT 30
 984: PUSH
 985: LD_INT 4
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 997: LD_ADDR_VAR 0 9
1001: PUSH
1002: LD_INT 2
1004: PUSH
1005: LD_INT 30
1007: PUSH
1008: LD_INT 7
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 30
1017: PUSH
1018: LD_INT 6
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: LIST
1029: PPUSH
1030: CALL_OW 69
1034: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1035: LD_ADDR_VAR 0 10
1039: PUSH
1040: LD_INT 30
1042: PUSH
1043: LD_INT 3
1045: PUSH
1046: EMPTY
1047: LIST
1048: LIST
1049: PPUSH
1050: CALL_OW 69
1054: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1055: LD_ADDR_VAR 0 11
1059: PUSH
1060: LD_INT 2
1062: PUSH
1063: LD_INT 30
1065: PUSH
1066: LD_INT 32
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: PUSH
1073: LD_INT 30
1075: PUSH
1076: LD_INT 31
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: PPUSH
1088: CALL_OW 69
1092: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1093: LD_VAR 0 7
1097: PPUSH
1098: LD_STRING Gamma
1100: PPUSH
1101: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1105: LD_VAR 0 7
1109: PPUSH
1110: CALL_OW 274
1114: PPUSH
1115: LD_INT 2
1117: PPUSH
1118: LD_INT 10000
1120: PPUSH
1121: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1125: LD_VAR 0 7
1129: PPUSH
1130: CALL_OW 274
1134: PPUSH
1135: LD_INT 1
1137: PPUSH
1138: LD_INT 10000
1140: PPUSH
1141: CALL_OW 277
// if dep then
1145: LD_VAR 0 7
1149: IFFALSE 1249
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1151: LD_EXP 7
1155: PPUSH
1156: LD_VAR 0 7
1160: PUSH
1161: LD_INT 1
1163: ARRAY
1164: PPUSH
1165: CALL_OW 52
// if Brown then
1169: LD_EXP 14
1173: IFFALSE 1209
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1175: LD_EXP 14
1179: PPUSH
1180: LD_VAR 0 7
1184: PUSH
1185: LD_INT 1
1187: ARRAY
1188: PPUSH
1189: CALL_OW 52
// team := team diff Brown ;
1193: LD_ADDR_VAR 0 6
1197: PUSH
1198: LD_VAR 0 6
1202: PUSH
1203: LD_EXP 14
1207: DIFF
1208: ST_TO_ADDR
// end ; if Donaldson then
1209: LD_EXP 13
1213: IFFALSE 1249
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1215: LD_EXP 13
1219: PPUSH
1220: LD_VAR 0 7
1224: PUSH
1225: LD_INT 1
1227: ARRAY
1228: PPUSH
1229: CALL_OW 52
// team := team diff Donaldson ;
1233: LD_ADDR_VAR 0 6
1237: PUSH
1238: LD_VAR 0 6
1242: PUSH
1243: LD_EXP 13
1247: DIFF
1248: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1249: LD_VAR 0 11
1253: PUSH
1254: LD_VAR 0 6
1258: PPUSH
1259: LD_INT 25
1261: PUSH
1262: LD_INT 1
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PPUSH
1269: CALL_OW 72
1273: AND
1274: IFFALSE 1383
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1276: LD_ADDR_VAR 0 12
1280: PUSH
1281: LD_VAR 0 6
1285: PPUSH
1286: LD_INT 25
1288: PUSH
1289: LD_INT 1
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL_OW 72
1300: ST_TO_ADDR
// for i in bun do
1301: LD_ADDR_VAR 0 13
1305: PUSH
1306: LD_VAR 0 11
1310: PUSH
1311: FOR_IN
1312: IFFALSE 1381
// begin if not filter then
1314: LD_VAR 0 12
1318: NOT
1319: IFFALSE 1323
// break ;
1321: GO 1381
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1323: LD_VAR 0 12
1327: PUSH
1328: LD_INT 1
1330: ARRAY
1331: PPUSH
1332: LD_VAR 0 13
1336: PPUSH
1337: CALL_OW 52
// team := team diff filter [ 1 ] ;
1341: LD_ADDR_VAR 0 6
1345: PUSH
1346: LD_VAR 0 6
1350: PUSH
1351: LD_VAR 0 12
1355: PUSH
1356: LD_INT 1
1358: ARRAY
1359: DIFF
1360: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1361: LD_ADDR_VAR 0 12
1365: PUSH
1366: LD_VAR 0 12
1370: PPUSH
1371: LD_INT 1
1373: PPUSH
1374: CALL_OW 3
1378: ST_TO_ADDR
// end ;
1379: GO 1311
1381: POP
1382: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1383: LD_VAR 0 8
1387: PUSH
1388: LD_VAR 0 6
1392: PPUSH
1393: LD_INT 25
1395: PUSH
1396: LD_INT 1
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PPUSH
1403: CALL_OW 72
1407: AND
1408: IFFALSE 1530
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1410: LD_ADDR_VAR 0 12
1414: PUSH
1415: LD_VAR 0 6
1419: PPUSH
1420: LD_INT 25
1422: PUSH
1423: LD_INT 1
1425: PUSH
1426: EMPTY
1427: LIST
1428: LIST
1429: PPUSH
1430: CALL_OW 72
1434: ST_TO_ADDR
// for i = 1 to filter do
1435: LD_ADDR_VAR 0 13
1439: PUSH
1440: DOUBLE
1441: LD_INT 1
1443: DEC
1444: ST_TO_ADDR
1445: LD_VAR 0 12
1449: PUSH
1450: FOR_TO
1451: IFFALSE 1512
// begin if ( i <= 6 ) then
1453: LD_VAR 0 13
1457: PUSH
1458: LD_INT 6
1460: LESSEQUAL
1461: IFFALSE 1489
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1463: LD_VAR 0 12
1467: PUSH
1468: LD_VAR 0 13
1472: ARRAY
1473: PPUSH
1474: LD_VAR 0 8
1478: PUSH
1479: LD_INT 1
1481: ARRAY
1482: PPUSH
1483: CALL_OW 52
1487: GO 1510
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1489: LD_VAR 0 12
1493: PUSH
1494: LD_VAR 0 13
1498: ARRAY
1499: PPUSH
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 0
1505: PPUSH
1506: CALL_OW 49
// end ;
1510: GO 1450
1512: POP
1513: POP
// team := team diff filter ;
1514: LD_ADDR_VAR 0 6
1518: PUSH
1519: LD_VAR 0 6
1523: PUSH
1524: LD_VAR 0 12
1528: DIFF
1529: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1530: LD_VAR 0 9
1534: PUSH
1535: LD_VAR 0 6
1539: PPUSH
1540: LD_INT 25
1542: PUSH
1543: LD_INT 4
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: PPUSH
1550: CALL_OW 72
1554: AND
1555: IFFALSE 1677
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1557: LD_ADDR_VAR 0 12
1561: PUSH
1562: LD_VAR 0 6
1566: PPUSH
1567: LD_INT 25
1569: PUSH
1570: LD_INT 4
1572: PUSH
1573: EMPTY
1574: LIST
1575: LIST
1576: PPUSH
1577: CALL_OW 72
1581: ST_TO_ADDR
// for i = 1 to filter do
1582: LD_ADDR_VAR 0 13
1586: PUSH
1587: DOUBLE
1588: LD_INT 1
1590: DEC
1591: ST_TO_ADDR
1592: LD_VAR 0 12
1596: PUSH
1597: FOR_TO
1598: IFFALSE 1659
// begin if ( i <= 6 ) then
1600: LD_VAR 0 13
1604: PUSH
1605: LD_INT 6
1607: LESSEQUAL
1608: IFFALSE 1636
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1610: LD_VAR 0 12
1614: PUSH
1615: LD_VAR 0 13
1619: ARRAY
1620: PPUSH
1621: LD_VAR 0 9
1625: PUSH
1626: LD_INT 1
1628: ARRAY
1629: PPUSH
1630: CALL_OW 52
1634: GO 1657
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1636: LD_VAR 0 12
1640: PUSH
1641: LD_VAR 0 13
1645: ARRAY
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: LD_INT 0
1652: PPUSH
1653: CALL_OW 49
// end ;
1657: GO 1597
1659: POP
1660: POP
// team := team diff filter ;
1661: LD_ADDR_VAR 0 6
1665: PUSH
1666: LD_VAR 0 6
1670: PUSH
1671: LD_VAR 0 12
1675: DIFF
1676: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1677: LD_VAR 0 10
1681: PUSH
1682: LD_VAR 0 6
1686: PPUSH
1687: LD_INT 25
1689: PUSH
1690: LD_INT 3
1692: PUSH
1693: EMPTY
1694: LIST
1695: LIST
1696: PPUSH
1697: CALL_OW 72
1701: AND
1702: IFFALSE 1824
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1704: LD_ADDR_VAR 0 12
1708: PUSH
1709: LD_VAR 0 6
1713: PPUSH
1714: LD_INT 25
1716: PUSH
1717: LD_INT 3
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: PPUSH
1724: CALL_OW 72
1728: ST_TO_ADDR
// for i = 1 to filter do
1729: LD_ADDR_VAR 0 13
1733: PUSH
1734: DOUBLE
1735: LD_INT 1
1737: DEC
1738: ST_TO_ADDR
1739: LD_VAR 0 12
1743: PUSH
1744: FOR_TO
1745: IFFALSE 1806
// begin if ( i <= 6 ) then
1747: LD_VAR 0 13
1751: PUSH
1752: LD_INT 6
1754: LESSEQUAL
1755: IFFALSE 1783
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1757: LD_VAR 0 12
1761: PUSH
1762: LD_VAR 0 13
1766: ARRAY
1767: PPUSH
1768: LD_VAR 0 10
1772: PUSH
1773: LD_INT 1
1775: ARRAY
1776: PPUSH
1777: CALL_OW 52
1781: GO 1804
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1783: LD_VAR 0 12
1787: PUSH
1788: LD_VAR 0 13
1792: ARRAY
1793: PPUSH
1794: LD_INT 1
1796: PPUSH
1797: LD_INT 0
1799: PPUSH
1800: CALL_OW 49
// end ;
1804: GO 1744
1806: POP
1807: POP
// team := team diff filter ;
1808: LD_ADDR_VAR 0 6
1812: PUSH
1813: LD_VAR 0 6
1817: PUSH
1818: LD_VAR 0 12
1822: DIFF
1823: ST_TO_ADDR
// end ; if team then
1824: LD_VAR 0 6
1828: IFFALSE 1871
// for i in team do
1830: LD_ADDR_VAR 0 13
1834: PUSH
1835: LD_VAR 0 6
1839: PUSH
1840: FOR_IN
1841: IFFALSE 1869
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1843: LD_VAR 0 13
1847: PPUSH
1848: LD_INT 1
1850: PPUSH
1851: LD_INT 0
1853: PPUSH
1854: CALL_OW 49
// ComHold ( i ) ;
1858: LD_VAR 0 13
1862: PPUSH
1863: CALL_OW 140
// end ;
1867: GO 1840
1869: POP
1870: POP
// if fac then
1871: LD_VAR 0 10
1875: IFFALSE 1911
// if UnitsInside ( fac [ 1 ] ) then
1877: LD_VAR 0 10
1881: PUSH
1882: LD_INT 1
1884: ARRAY
1885: PPUSH
1886: CALL_OW 313
1890: IFFALSE 1911
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1892: LD_VAR 0 10
1896: PUSH
1897: LD_INT 1
1899: ARRAY
1900: PPUSH
1901: LD_INT 10
1903: PPUSH
1904: LD_INT 0
1906: PPUSH
1907: CALL_OW 486
// if lab then
1911: LD_VAR 0 9
1915: IFFALSE 1951
// if UnitsInside ( lab [ 1 ] ) then
1917: LD_VAR 0 9
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: CALL_OW 313
1930: IFFALSE 1951
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1932: LD_VAR 0 9
1936: PUSH
1937: LD_INT 1
1939: ARRAY
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: LD_INT 0
1946: PPUSH
1947: CALL_OW 486
// uc_side := 4 ;
1951: LD_ADDR_OWVAR 20
1955: PUSH
1956: LD_INT 4
1958: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
1959: LD_ADDR_EXP 16
1963: PUSH
1964: LD_STRING Harisson
1966: PPUSH
1967: LD_INT 0
1969: PPUSH
1970: LD_STRING 
1972: PPUSH
1973: CALL 3515 0 3
1977: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_INT 4
1985: PPUSH
1986: LD_INT 1
1988: PPUSH
1989: LD_INT 1
1991: PPUSH
1992: LD_INT 1
1994: PPUSH
1995: LD_INT 1
1997: PPUSH
1998: LD_INT 2
2000: PPUSH
2001: LD_INT 100
2003: PPUSH
2004: CALL 3578 0 7
2008: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2009: LD_VAR 0 5
2013: PPUSH
2014: LD_INT 2
2016: PPUSH
2017: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2021: LD_VAR 0 5
2025: PPUSH
2026: LD_INT 21
2028: PPUSH
2029: LD_INT 8
2031: PPUSH
2032: LD_INT 0
2034: PPUSH
2035: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2039: LD_EXP 16
2043: PPUSH
2044: LD_VAR 0 5
2048: PPUSH
2049: CALL_OW 52
// end ;
2053: LD_VAR 0 1
2057: RET
// function PrepareBase ; var blist , i , b ; begin
2058: LD_INT 0
2060: PPUSH
2061: PPUSH
2062: PPUSH
2063: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2064: LD_INT 71
2066: PPUSH
2067: LD_INT 5
2069: PPUSH
2070: LD_INT 1
2072: PPUSH
2073: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2077: LD_ADDR_VAR 0 2
2081: PUSH
2082: LD_STRING GammaBase
2084: PPUSH
2085: EMPTY
2086: PPUSH
2087: CALL_OW 30
2091: ST_TO_ADDR
// if not blist and debug then
2092: LD_VAR 0 2
2096: NOT
2097: PUSH
2098: LD_EXP 1
2102: AND
2103: IFFALSE 2143
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2105: LD_ADDR_VAR 0 2
2109: PUSH
2110: LD_INT 0
2112: PUSH
2113: LD_INT 51
2115: PUSH
2116: LD_INT 10
2118: PUSH
2119: LD_INT 3
2121: PUSH
2122: LD_INT 3
2124: PUSH
2125: LD_INT 0
2127: PUSH
2128: LD_INT 0
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: LIST
2139: PUSH
2140: EMPTY
2141: LIST
2142: ST_TO_ADDR
// if not blist then
2143: LD_VAR 0 2
2147: NOT
2148: IFFALSE 2152
// exit ;
2150: GO 2332
// uc_side := 1 ;
2152: LD_ADDR_OWVAR 20
2156: PUSH
2157: LD_INT 1
2159: ST_TO_ADDR
// uc_nation := 1 ;
2160: LD_ADDR_OWVAR 21
2164: PUSH
2165: LD_INT 1
2167: ST_TO_ADDR
// for i in blist do
2168: LD_ADDR_VAR 0 3
2172: PUSH
2173: LD_VAR 0 2
2177: PUSH
2178: FOR_IN
2179: IFFALSE 2330
// begin bc_type := i [ 1 ] ;
2181: LD_ADDR_OWVAR 42
2185: PUSH
2186: LD_VAR 0 3
2190: PUSH
2191: LD_INT 1
2193: ARRAY
2194: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2195: LD_ADDR_OWVAR 43
2199: PUSH
2200: LD_VAR 0 3
2204: PUSH
2205: LD_INT 5
2207: ARRAY
2208: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2209: LD_VAR 0 3
2213: PUSH
2214: LD_INT 1
2216: ARRAY
2217: PUSH
2218: LD_INT 7
2220: PUSH
2221: LD_INT 8
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: IN
2228: IFFALSE 2258
// begin bc_kind1 := i [ 7 ] ;
2230: LD_ADDR_OWVAR 44
2234: PUSH
2235: LD_VAR 0 3
2239: PUSH
2240: LD_INT 7
2242: ARRAY
2243: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2244: LD_ADDR_OWVAR 45
2248: PUSH
2249: LD_VAR 0 3
2253: PUSH
2254: LD_INT 8
2256: ARRAY
2257: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2258: LD_ADDR_VAR 0 4
2262: PUSH
2263: LD_VAR 0 3
2267: PUSH
2268: LD_INT 2
2270: ARRAY
2271: PPUSH
2272: LD_VAR 0 3
2276: PUSH
2277: LD_INT 3
2279: ARRAY
2280: PPUSH
2281: LD_VAR 0 3
2285: PUSH
2286: LD_INT 4
2288: ARRAY
2289: PPUSH
2290: CALL_OW 47
2294: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2295: LD_VAR 0 4
2299: PPUSH
2300: CALL_OW 266
2304: PUSH
2305: LD_INT 32
2307: EQUAL
2308: IFFALSE 2328
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2310: LD_VAR 0 4
2314: PPUSH
2315: LD_VAR 0 3
2319: PUSH
2320: LD_INT 7
2322: ARRAY
2323: PPUSH
2324: CALL_OW 431
// end ; end ;
2328: GO 2178
2330: POP
2331: POP
// end ; end_of_file
2332: LD_VAR 0 1
2336: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
2337: LD_INT 0
2339: PPUSH
2340: PPUSH
2341: PPUSH
2342: PPUSH
2343: PPUSH
2344: PPUSH
2345: PPUSH
2346: PPUSH
// InGameOn ;
2347: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2351: LD_INT 33
2353: PPUSH
2354: LD_INT 11
2356: PPUSH
2357: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2361: LD_ADDR_VAR 0 2
2365: PUSH
2366: LD_INT 29
2368: PUSH
2369: LD_INT 21
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: LD_INT 41
2378: PUSH
2379: LD_INT 28
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PUSH
2386: LD_INT 52
2388: PUSH
2389: LD_INT 26
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: PUSH
2396: LD_INT 49
2398: PUSH
2399: LD_INT 16
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: LIST
2410: LIST
2411: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten ] ) [ 1 ] ;
2412: LD_ADDR_VAR 0 4
2416: PUSH
2417: LD_INT 22
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: PUSH
2427: LD_INT 26
2429: PUSH
2430: LD_INT 1
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: PPUSH
2441: CALL_OW 69
2445: PUSH
2446: LD_EXP 7
2450: PUSH
2451: LD_EXP 14
2455: PUSH
2456: LD_EXP 11
2460: PUSH
2461: LD_EXP 12
2465: PUSH
2466: LD_EXP 8
2470: PUSH
2471: LD_EXP 15
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: LIST
2480: LIST
2481: LIST
2482: LIST
2483: DIFF
2484: PUSH
2485: LD_INT 1
2487: ARRAY
2488: ST_TO_ADDR
// if sol then
2489: LD_VAR 0 4
2493: IFFALSE 2524
// begin ComMoveXY ( sol , 50 , 18 ) ;
2495: LD_VAR 0 4
2499: PPUSH
2500: LD_INT 50
2502: PPUSH
2503: LD_INT 18
2505: PPUSH
2506: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2510: LD_VAR 0 4
2514: PPUSH
2515: LD_EXP 16
2519: PPUSH
2520: CALL_OW 179
// end ; for i in points do
2524: LD_ADDR_VAR 0 3
2528: PUSH
2529: LD_VAR 0 2
2533: PUSH
2534: FOR_IN
2535: IFFALSE 2566
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2537: LD_EXP 16
2541: PPUSH
2542: LD_VAR 0 3
2546: PUSH
2547: LD_INT 1
2549: ARRAY
2550: PPUSH
2551: LD_VAR 0 3
2555: PUSH
2556: LD_INT 2
2558: ARRAY
2559: PPUSH
2560: CALL_OW 171
2564: GO 2534
2566: POP
2567: POP
// AddComExitVehicle ( Harisson ) ;
2568: LD_EXP 16
2572: PPUSH
2573: CALL_OW 181
// repeat wait ( 3 ) ;
2577: LD_INT 3
2579: PPUSH
2580: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2584: LD_EXP 16
2588: PPUSH
2589: CALL_OW 310
2593: NOT
2594: IFFALSE 2577
// Say ( sol , D1-Sol1-1 ) ;
2596: LD_VAR 0 4
2600: PPUSH
2601: LD_STRING D1-Sol1-1
2603: PPUSH
2604: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2608: LD_EXP 16
2612: PPUSH
2613: LD_VAR 0 4
2617: PPUSH
2618: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2622: LD_EXP 16
2626: PPUSH
2627: LD_STRING D1-Har-1
2629: PPUSH
2630: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2634: LD_INT 10
2636: PPUSH
2637: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2641: LD_VAR 0 4
2645: PPUSH
2646: LD_INT 35
2648: PPUSH
2649: LD_INT 21
2651: PPUSH
2652: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2656: LD_EXP 7
2660: PPUSH
2661: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2665: LD_EXP 7
2669: PPUSH
2670: LD_EXP 16
2674: PPUSH
2675: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2679: LD_EXP 16
2683: PPUSH
2684: LD_EXP 7
2688: PPUSH
2689: CALL_OW 119
// repeat wait ( 3 ) ;
2693: LD_INT 3
2695: PPUSH
2696: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2700: LD_EXP 7
2704: PPUSH
2705: LD_EXP 16
2709: PPUSH
2710: CALL_OW 296
2714: PUSH
2715: LD_INT 4
2717: LESS
2718: IFFALSE 2693
// ComTurnUnit ( JMM , Harisson ) ;
2720: LD_EXP 7
2724: PPUSH
2725: LD_EXP 16
2729: PPUSH
2730: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2734: LD_EXP 7
2738: PPUSH
2739: LD_STRING D1-JMM-1
2741: PPUSH
2742: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2746: LD_EXP 16
2750: PPUSH
2751: LD_STRING D1-Har-2
2753: PPUSH
2754: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
2758: LD_EXP 7
2762: PPUSH
2763: LD_STRING D1-JMM-2
2765: PPUSH
2766: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
2770: LD_EXP 16
2774: PPUSH
2775: LD_STRING D1-Har-3
2777: PPUSH
2778: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2782: LD_EXP 7
2786: PPUSH
2787: LD_STRING D1-JMM-3
2789: PPUSH
2790: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
2794: LD_EXP 16
2798: PPUSH
2799: LD_STRING D1-Har-4
2801: PPUSH
2802: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
2806: LD_EXP 7
2810: PPUSH
2811: LD_STRING D1-JMM-4
2813: PPUSH
2814: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
2818: LD_EXP 16
2822: PPUSH
2823: LD_STRING D1-Har-5
2825: PPUSH
2826: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
2830: LD_EXP 7
2834: PPUSH
2835: LD_STRING D1-JMM-5
2837: PPUSH
2838: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
2842: LD_EXP 16
2846: PPUSH
2847: LD_STRING D1-Har-6
2849: PPUSH
2850: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
2854: LD_EXP 7
2858: PPUSH
2859: LD_STRING D1-JMM-6
2861: PPUSH
2862: CALL_OW 88
// case gamma_commander of 1 :
2866: LD_EXP 17
2870: PUSH
2871: LD_INT 1
2873: DOUBLE
2874: EQUAL
2875: IFTRUE 2879
2877: GO 2892
2879: POP
// commander := Donaldson ; 2 :
2880: LD_ADDR_VAR 0 7
2884: PUSH
2885: LD_EXP 13
2889: ST_TO_ADDR
2890: GO 2935
2892: LD_INT 2
2894: DOUBLE
2895: EQUAL
2896: IFTRUE 2900
2898: GO 2913
2900: POP
// commander := Brown ; 3 :
2901: LD_ADDR_VAR 0 7
2905: PUSH
2906: LD_EXP 14
2910: ST_TO_ADDR
2911: GO 2935
2913: LD_INT 3
2915: DOUBLE
2916: EQUAL
2917: IFTRUE 2921
2919: GO 2934
2921: POP
// commander := Houten ; end ;
2922: LD_ADDR_VAR 0 7
2926: PUSH
2927: LD_EXP 15
2931: ST_TO_ADDR
2932: GO 2935
2934: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
2935: LD_ADDR_VAR 0 6
2939: PUSH
2940: LD_INT 22
2942: PUSH
2943: LD_INT 1
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: PUSH
2950: LD_INT 21
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: PPUSH
2964: CALL_OW 69
2968: PUSH
2969: LD_EXP 7
2973: PUSH
2974: LD_VAR 0 7
2978: PUSH
2979: EMPTY
2980: LIST
2981: LIST
2982: DIFF
2983: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 8 , 8 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 2 ] , [ class_scientistic , 1 ] ] ) ;
2984: LD_ADDR_EXP 4
2988: PUSH
2989: LD_STRING 1
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: LD_INT 8
2997: PPUSH
2998: LD_INT -5
3000: PUSH
3001: LD_EXP 7
3005: PUSH
3006: LD_INT -2
3008: PUSH
3009: LD_INT -3
3011: PUSH
3012: LD_INT -5
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_VAR 0 6
3026: ADD
3027: PUSH
3028: LD_INT -6
3030: PUSH
3031: LD_INT -4
3033: PUSH
3034: LD_VAR 0 7
3038: PUSH
3039: LD_EXP 16
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: LIST
3052: ADD
3053: PPUSH
3054: LD_INT 1
3056: PUSH
3057: LD_INT 3
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 2
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: PUSH
3074: LD_INT 4
3076: PUSH
3077: LD_INT 1
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PPUSH
3089: CALL_OW 42
3093: ST_TO_ADDR
// InGameOff ;
3094: CALL_OW 9
// exit ;
3098: GO 3510
// SaveCharacters ( all diff [ save_group , JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson ] , 07_othersGamma ) ;
3100: LD_VAR 0 6
3104: PUSH
3105: LD_EXP 4
3109: PUSH
3110: LD_EXP 7
3114: PUSH
3115: LD_EXP 8
3119: PUSH
3120: LD_EXP 10
3124: PUSH
3125: LD_EXP 11
3129: PUSH
3130: LD_EXP 12
3134: PUSH
3135: LD_EXP 9
3139: PUSH
3140: LD_EXP 13
3144: PUSH
3145: LD_EXP 14
3149: PUSH
3150: LD_EXP 15
3154: PUSH
3155: LD_EXP 16
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: DIFF
3173: PPUSH
3174: LD_STRING 07_othersGamma
3176: PPUSH
3177: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , 0 ] , 07_others ) ;
3181: LD_EXP 4
3185: PUSH
3186: LD_EXP 7
3190: PUSH
3191: LD_EXP 8
3195: PUSH
3196: LD_EXP 10
3200: PUSH
3201: LD_EXP 11
3205: PUSH
3206: LD_EXP 12
3210: PUSH
3211: LD_EXP 9
3215: PUSH
3216: LD_EXP 13
3220: PUSH
3221: LD_EXP 14
3225: PUSH
3226: LD_EXP 15
3230: PUSH
3231: LD_EXP 16
3235: PUSH
3236: LD_INT 0
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: DIFF
3252: PPUSH
3253: LD_STRING 07_others
3255: PPUSH
3256: CALL_OW 38
// if Lisa in save_group then
3260: LD_EXP 10
3264: PUSH
3265: LD_EXP 4
3269: IN
3270: IFFALSE 3300
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3272: LD_EXP 10
3276: PPUSH
3277: LD_EXP 5
3281: PUSH
3282: LD_STRING Lisa
3284: STR
3285: PPUSH
3286: CALL_OW 38
// SaveVariable ( true , LisaIn07 ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_STRING LisaIn07
3295: PPUSH
3296: CALL_OW 39
// end ; if Bobby in save_group then
3300: LD_EXP 12
3304: PUSH
3305: LD_EXP 4
3309: IN
3310: IFFALSE 3340
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3312: LD_EXP 12
3316: PPUSH
3317: LD_EXP 5
3321: PUSH
3322: LD_STRING Bobby
3324: STR
3325: PPUSH
3326: CALL_OW 38
// SaveVariable ( true , BobbyIn07 ) ;
3330: LD_INT 1
3332: PPUSH
3333: LD_STRING BobbyIn07
3335: PPUSH
3336: CALL_OW 39
// end ; if Cyrus in save_group then
3340: LD_EXP 11
3344: PUSH
3345: LD_EXP 4
3349: IN
3350: IFFALSE 3380
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3352: LD_EXP 11
3356: PPUSH
3357: LD_EXP 5
3361: PUSH
3362: LD_STRING Cyrus
3364: STR
3365: PPUSH
3366: CALL_OW 38
// SaveVariable ( true , CyrusIn07 ) ;
3370: LD_INT 1
3372: PPUSH
3373: LD_STRING CyrusIn07
3375: PPUSH
3376: CALL_OW 39
// end ; if Brown in save_group then
3380: LD_EXP 14
3384: PUSH
3385: LD_EXP 4
3389: IN
3390: IFFALSE 3420
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3392: LD_EXP 14
3396: PPUSH
3397: LD_EXP 5
3401: PUSH
3402: LD_STRING Brown
3404: STR
3405: PPUSH
3406: CALL_OW 38
// SaveVariable ( true , BrownIn07 ) ;
3410: LD_INT 1
3412: PPUSH
3413: LD_STRING BrownIn07
3415: PPUSH
3416: CALL_OW 39
// end ; if Donaldson in save_group then
3420: LD_EXP 13
3424: PUSH
3425: LD_EXP 4
3429: IN
3430: IFFALSE 3460
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3432: LD_EXP 13
3436: PPUSH
3437: LD_EXP 5
3441: PUSH
3442: LD_STRING Donaldson
3444: STR
3445: PPUSH
3446: CALL_OW 38
// SaveVariable ( true , DonaldsonIn07 ) ;
3450: LD_INT 1
3452: PPUSH
3453: LD_STRING DonaldsonIn07
3455: PPUSH
3456: CALL_OW 39
// end ; if Gladstone in save_group then
3460: LD_EXP 8
3464: PUSH
3465: LD_EXP 4
3469: IN
3470: IFFALSE 3500
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3472: LD_EXP 8
3476: PPUSH
3477: LD_EXP 5
3481: PUSH
3482: LD_STRING Gladstone
3484: STR
3485: PPUSH
3486: CALL_OW 38
// SaveVariable ( true , GladstoneIn07 ) ;
3490: LD_INT 1
3492: PPUSH
3493: LD_STRING GladstoneIn07
3495: PPUSH
3496: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3500: LD_INT 1
3502: PPUSH
3503: LD_STRING %_cont
3505: PPUSH
3506: CALL_OW 340
// end ; end_of_file
3510: LD_VAR 0 1
3514: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3515: LD_INT 0
3517: PPUSH
3518: PPUSH
// if exist_mode then
3519: LD_VAR 0 2
3523: IFFALSE 3548
// unit := CreateCharacter ( prefix & ident ) else
3525: LD_ADDR_VAR 0 5
3529: PUSH
3530: LD_VAR 0 3
3534: PUSH
3535: LD_VAR 0 1
3539: STR
3540: PPUSH
3541: CALL_OW 34
3545: ST_TO_ADDR
3546: GO 3563
// unit := NewCharacter ( ident ) ;
3548: LD_ADDR_VAR 0 5
3552: PUSH
3553: LD_VAR 0 1
3557: PPUSH
3558: CALL_OW 25
3562: ST_TO_ADDR
// result := unit ;
3563: LD_ADDR_VAR 0 4
3567: PUSH
3568: LD_VAR 0 5
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 4
3577: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3578: LD_INT 0
3580: PPUSH
// uc_side := side ;
3581: LD_ADDR_OWVAR 20
3585: PUSH
3586: LD_VAR 0 1
3590: ST_TO_ADDR
// uc_nation := nation ;
3591: LD_ADDR_OWVAR 21
3595: PUSH
3596: LD_VAR 0 2
3600: ST_TO_ADDR
// vc_chassis := chassis ;
3601: LD_ADDR_OWVAR 37
3605: PUSH
3606: LD_VAR 0 3
3610: ST_TO_ADDR
// vc_engine := engine ;
3611: LD_ADDR_OWVAR 39
3615: PUSH
3616: LD_VAR 0 4
3620: ST_TO_ADDR
// vc_control := control ;
3621: LD_ADDR_OWVAR 38
3625: PUSH
3626: LD_VAR 0 5
3630: ST_TO_ADDR
// vc_weapon := weapon ;
3631: LD_ADDR_OWVAR 40
3635: PUSH
3636: LD_VAR 0 6
3640: ST_TO_ADDR
// vc_fuel_battery := fuel ;
3641: LD_ADDR_OWVAR 41
3645: PUSH
3646: LD_VAR 0 7
3650: ST_TO_ADDR
// result := CreateVehicle ;
3651: LD_ADDR_VAR 0 8
3655: PUSH
3656: CALL_OW 45
3660: ST_TO_ADDR
// end ;
3661: LD_VAR 0 8
3665: RET
// export function SayX ( units , ident ) ; var i ; begin
3666: LD_INT 0
3668: PPUSH
3669: PPUSH
// result := false ;
3670: LD_ADDR_VAR 0 3
3674: PUSH
3675: LD_INT 0
3677: ST_TO_ADDR
// if not units then
3678: LD_VAR 0 1
3682: NOT
3683: IFFALSE 3687
// exit ;
3685: GO 3741
// for i in units do
3687: LD_ADDR_VAR 0 4
3691: PUSH
3692: LD_VAR 0 1
3696: PUSH
3697: FOR_IN
3698: IFFALSE 3739
// if IsOk ( i ) then
3700: LD_VAR 0 4
3704: PPUSH
3705: CALL_OW 302
3709: IFFALSE 3737
// begin Say ( i , ident ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_VAR 0 2
3720: PPUSH
3721: CALL_OW 88
// result := i ;
3725: LD_ADDR_VAR 0 3
3729: PUSH
3730: LD_VAR 0 4
3734: ST_TO_ADDR
// break ;
3735: GO 3739
// end ;
3737: GO 3697
3739: POP
3740: POP
// end ;
3741: LD_VAR 0 3
3745: RET
