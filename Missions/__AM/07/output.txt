// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2586 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2322 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3893 0 3
 179: ST_TO_ADDR
// if GetClass ( JMM ) = 2 then
 180: LD_EXP 7
 184: PPUSH
 185: CALL_OW 257
 189: PUSH
 190: LD_INT 2
 192: EQUAL
 193: IFFALSE 207
// SetClass ( JMM , 1 ) ;
 195: LD_EXP 7
 199: PPUSH
 200: LD_INT 1
 202: PPUSH
 203: CALL_OW 336
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 207: LD_ADDR_EXP 18
 211: PUSH
 212: LD_STRING GammaCommander
 214: PPUSH
 215: LD_INT 3
 217: PPUSH
 218: CALL_OW 30
 222: ST_TO_ADDR
// if gamma_commander = 1 then
 223: LD_EXP 18
 227: PUSH
 228: LD_INT 1
 230: EQUAL
 231: IFFALSE 257
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 233: LD_ADDR_EXP 13
 237: PUSH
 238: LD_STRING Donaldson
 240: PPUSH
 241: LD_EXP 1
 245: NOT
 246: PPUSH
 247: LD_STRING 04_
 249: PPUSH
 250: CALL 3893 0 3
 254: ST_TO_ADDR
// end else
 255: GO 328
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 257: LD_STRING DonaldsonIn06
 259: PPUSH
 260: LD_INT 0
 262: PPUSH
 263: CALL_OW 30
 267: IFFALSE 293
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 269: LD_ADDR_EXP 13
 273: PUSH
 274: LD_STRING Donaldson
 276: PPUSH
 277: LD_EXP 1
 281: NOT
 282: PPUSH
 283: LD_STRING 06c_
 285: PPUSH
 286: CALL 3893 0 3
 290: ST_TO_ADDR
 291: GO 328
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 293: LD_STRING DonaldsonStayInDelta
 295: PPUSH
 296: LD_INT 0
 298: PPUSH
 299: CALL_OW 30
 303: NOT
 304: IFFALSE 328
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 306: LD_ADDR_EXP 13
 310: PUSH
 311: LD_STRING Donaldson
 313: PPUSH
 314: LD_EXP 1
 318: NOT
 319: PPUSH
 320: LD_STRING 04_
 322: PPUSH
 323: CALL 3893 0 3
 327: ST_TO_ADDR
// end ; if Donaldson then
 328: LD_EXP 13
 332: IFFALSE 350
// team := team ^ Donaldson ;
 334: LD_ADDR_VAR 0 6
 338: PUSH
 339: LD_VAR 0 6
 343: PUSH
 344: LD_EXP 13
 348: ADD
 349: ST_TO_ADDR
// if gamma_commander = 2 then
 350: LD_EXP 18
 354: PUSH
 355: LD_INT 2
 357: EQUAL
 358: IFFALSE 384
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 360: LD_ADDR_EXP 14
 364: PUSH
 365: LD_STRING Brown
 367: PPUSH
 368: LD_EXP 1
 372: NOT
 373: PPUSH
 374: LD_STRING 04_
 376: PPUSH
 377: CALL 3893 0 3
 381: ST_TO_ADDR
// end else
 382: GO 455
// begin if LoadVariable ( BrownIn06 , 0 ) then
 384: LD_STRING BrownIn06
 386: PPUSH
 387: LD_INT 0
 389: PPUSH
 390: CALL_OW 30
 394: IFFALSE 420
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 396: LD_ADDR_EXP 14
 400: PUSH
 401: LD_STRING Brown
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: LD_STRING 06c_
 412: PPUSH
 413: CALL 3893 0 3
 417: ST_TO_ADDR
 418: GO 455
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 420: LD_STRING BrownStayInDelta
 422: PPUSH
 423: LD_INT 0
 425: PPUSH
 426: CALL_OW 30
 430: NOT
 431: IFFALSE 455
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 433: LD_ADDR_EXP 14
 437: PUSH
 438: LD_STRING Brown
 440: PPUSH
 441: LD_EXP 1
 445: NOT
 446: PPUSH
 447: LD_STRING 04_
 449: PPUSH
 450: CALL 3893 0 3
 454: ST_TO_ADDR
// end ; if Brown then
 455: LD_EXP 14
 459: IFFALSE 477
// team := team ^ Brown ;
 461: LD_ADDR_VAR 0 6
 465: PUSH
 466: LD_VAR 0 6
 470: PUSH
 471: LD_EXP 14
 475: ADD
 476: ST_TO_ADDR
// if gamma_commander = 3 then
 477: LD_EXP 18
 481: PUSH
 482: LD_INT 3
 484: EQUAL
 485: IFFALSE 522
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 487: LD_ADDR_EXP 15
 491: PUSH
 492: LD_STRING VanHouten
 494: PPUSH
 495: LD_INT 0
 497: PPUSH
 498: LD_STRING 
 500: PPUSH
 501: CALL 3893 0 3
 505: ST_TO_ADDR
// team := team ^ Houten ;
 506: LD_ADDR_VAR 0 6
 510: PUSH
 511: LD_VAR 0 6
 515: PUSH
 516: LD_EXP 15
 520: ADD
 521: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 522: LD_STRING GladstoneIn06
 524: PPUSH
 525: LD_INT 0
 527: PPUSH
 528: CALL_OW 30
 532: IFFALSE 558
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) else
 534: LD_ADDR_EXP 8
 538: PUSH
 539: LD_STRING Gladstone
 541: PPUSH
 542: LD_EXP 1
 546: NOT
 547: PPUSH
 548: LD_STRING 06c_
 550: PPUSH
 551: CALL 3893 0 3
 555: ST_TO_ADDR
 556: GO 592
// if LoadVariable ( GladstoneStayInDelta , 0 ) then
 558: LD_STRING GladstoneStayInDelta
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 30
 568: IFFALSE 592
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06_ ) ;
 570: LD_ADDR_EXP 8
 574: PUSH
 575: LD_STRING Gladstone
 577: PPUSH
 578: LD_EXP 1
 582: NOT
 583: PPUSH
 584: LD_STRING 06_
 586: PPUSH
 587: CALL 3893 0 3
 591: ST_TO_ADDR
// if Gladstone then
 592: LD_EXP 8
 596: IFFALSE 614
// team := team ^ Gladstone ;
 598: LD_ADDR_VAR 0 6
 602: PUSH
 603: LD_VAR 0 6
 607: PUSH
 608: LD_EXP 8
 612: ADD
 613: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 614: LD_ADDR_EXP 16
 618: PUSH
 619: LD_STRING Khatam
 621: PPUSH
 622: LD_EXP 1
 626: NOT
 627: PPUSH
 628: LD_STRING 03_
 630: PPUSH
 631: CALL 3893 0 3
 635: ST_TO_ADDR
// if Khatam then
 636: LD_EXP 16
 640: IFFALSE 658
// team := team ^ Khatam ;
 642: LD_ADDR_VAR 0 6
 646: PUSH
 647: LD_VAR 0 6
 651: PUSH
 652: LD_EXP 16
 656: ADD
 657: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 658: LD_STRING LisaIn06
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 30
 668: IFFALSE 694
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 670: LD_ADDR_EXP 10
 674: PUSH
 675: LD_STRING Lisa
 677: PPUSH
 678: LD_EXP 1
 682: NOT
 683: PPUSH
 684: LD_STRING 06c_
 686: PPUSH
 687: CALL 3893 0 3
 691: ST_TO_ADDR
 692: GO 729
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 694: LD_STRING LisaStayInDelta
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: CALL_OW 30
 704: NOT
 705: IFFALSE 729
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 707: LD_ADDR_EXP 10
 711: PUSH
 712: LD_STRING Lisa
 714: PPUSH
 715: LD_EXP 1
 719: NOT
 720: PPUSH
 721: LD_STRING 04_
 723: PPUSH
 724: CALL 3893 0 3
 728: ST_TO_ADDR
// if Lisa then
 729: LD_EXP 10
 733: IFFALSE 751
// team := team ^ Lisa ;
 735: LD_ADDR_VAR 0 6
 739: PUSH
 740: LD_VAR 0 6
 744: PUSH
 745: LD_EXP 10
 749: ADD
 750: ST_TO_ADDR
// if not Lisa then
 751: LD_EXP 10
 755: NOT
 756: IFFALSE 1009
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 758: LD_STRING CyrusIn06
 760: PPUSH
 761: LD_INT 0
 763: PPUSH
 764: CALL_OW 30
 768: IFFALSE 794
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 770: LD_ADDR_EXP 11
 774: PUSH
 775: LD_STRING Cyrus
 777: PPUSH
 778: LD_EXP 1
 782: NOT
 783: PPUSH
 784: LD_STRING 06c_
 786: PPUSH
 787: CALL 3893 0 3
 791: ST_TO_ADDR
 792: GO 858
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 794: LD_STRING CyrusStayInDelta
 796: PPUSH
 797: LD_INT 0
 799: PPUSH
 800: CALL_OW 30
 804: NOT
 805: IFFALSE 858
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 807: LD_ADDR_EXP 11
 811: PUSH
 812: LD_STRING Cyrus
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 04_
 823: PPUSH
 824: CALL 3893 0 3
 828: ST_TO_ADDR
// if not Cyrus then
 829: LD_EXP 11
 833: NOT
 834: IFFALSE 858
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 836: LD_ADDR_EXP 11
 840: PUSH
 841: LD_STRING Cyrus
 843: PPUSH
 844: LD_EXP 1
 848: NOT
 849: PPUSH
 850: LD_STRING 03_
 852: PPUSH
 853: CALL 3893 0 3
 857: ST_TO_ADDR
// end ; if Cyrus then
 858: LD_EXP 11
 862: IFFALSE 880
// team := team ^ Cyrus ;
 864: LD_ADDR_VAR 0 6
 868: PUSH
 869: LD_VAR 0 6
 873: PUSH
 874: LD_EXP 11
 878: ADD
 879: ST_TO_ADDR
// if not Cyrus then
 880: LD_EXP 11
 884: NOT
 885: IFFALSE 1009
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 887: LD_STRING BobbyIn06
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 30
 897: IFFALSE 923
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 899: LD_ADDR_EXP 12
 903: PUSH
 904: LD_STRING Bobby
 906: PPUSH
 907: LD_EXP 1
 911: NOT
 912: PPUSH
 913: LD_STRING 06c_
 915: PPUSH
 916: CALL 3893 0 3
 920: ST_TO_ADDR
 921: GO 987
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 923: LD_STRING BobbyStayInDelta
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: NOT
 934: IFFALSE 987
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 936: LD_ADDR_EXP 12
 940: PUSH
 941: LD_STRING Bobby
 943: PPUSH
 944: LD_EXP 1
 948: NOT
 949: PPUSH
 950: LD_STRING 04_
 952: PPUSH
 953: CALL 3893 0 3
 957: ST_TO_ADDR
// if not Bobby then
 958: LD_EXP 12
 962: NOT
 963: IFFALSE 987
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
 965: LD_ADDR_EXP 12
 969: PUSH
 970: LD_STRING Bobby
 972: PPUSH
 973: LD_EXP 1
 977: NOT
 978: PPUSH
 979: LD_STRING 03_
 981: PPUSH
 982: CALL 3893 0 3
 986: ST_TO_ADDR
// end ; if Bobby then
 987: LD_EXP 12
 991: IFFALSE 1009
// team := team ^ Bobby ;
 993: LD_ADDR_VAR 0 6
 997: PUSH
 998: LD_VAR 0 6
1002: PUSH
1003: LD_EXP 12
1007: ADD
1008: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1009: LD_ADDR_VAR 0 4
1013: PUSH
1014: LD_STRING othersGamma
1016: PPUSH
1017: CALL_OW 31
1021: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_STRING 06_other_survivors
1029: PPUSH
1030: CALL_OW 31
1034: ST_TO_ADDR
// others := others union others4 ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_VAR 0 2
1044: PUSH
1045: LD_VAR 0 4
1049: UNION
1050: ST_TO_ADDR
// others := others diff others_delta ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_VAR 0 2
1060: PUSH
1061: LD_VAR 0 3
1065: DIFF
1066: ST_TO_ADDR
// team := team ^ others ;
1067: LD_ADDR_VAR 0 6
1071: PUSH
1072: LD_VAR 0 6
1076: PUSH
1077: LD_VAR 0 2
1081: ADD
1082: ST_TO_ADDR
// if team <= 12 then
1083: LD_VAR 0 6
1087: PUSH
1088: LD_INT 12
1090: LESSEQUAL
1091: IFFALSE 1140
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 5 ) ;
1093: LD_INT 0
1095: PPUSH
1096: LD_INT 1
1098: PPUSH
1099: LD_INT 4
1101: PPUSH
1102: CALL_OW 12
1106: PPUSH
1107: LD_INT 5
1109: PPUSH
1110: CALL_OW 380
// team := team ^ CreateHuman ;
1114: LD_ADDR_VAR 0 6
1118: PUSH
1119: LD_VAR 0 6
1123: PUSH
1124: CALL_OW 44
1128: ADD
1129: ST_TO_ADDR
// until team > 12 ;
1130: LD_VAR 0 6
1134: PUSH
1135: LD_INT 12
1137: GREATER
1138: IFFALSE 1093
// for i in others do
1140: LD_ADDR_VAR 0 13
1144: PUSH
1145: LD_VAR 0 2
1149: PUSH
1150: FOR_IN
1151: IFFALSE 1219
// begin if GetClass ( i ) = 2 then
1153: LD_VAR 0 13
1157: PPUSH
1158: CALL_OW 257
1162: PUSH
1163: LD_INT 2
1165: EQUAL
1166: IFFALSE 1180
// SetClass ( i , 1 ) ;
1168: LD_VAR 0 13
1172: PPUSH
1173: LD_INT 1
1175: PPUSH
1176: CALL_OW 336
// for j = 1 to 4 do
1180: LD_ADDR_VAR 0 14
1184: PUSH
1185: DOUBLE
1186: LD_INT 1
1188: DEC
1189: ST_TO_ADDR
1190: LD_INT 4
1192: PUSH
1193: FOR_TO
1194: IFFALSE 1215
// AddExperience ( i , j , 3000 ) ;
1196: LD_VAR 0 13
1200: PPUSH
1201: LD_VAR 0 14
1205: PPUSH
1206: LD_INT 3000
1208: PPUSH
1209: CALL_OW 492
1213: GO 1193
1215: POP
1216: POP
// end ;
1217: GO 1150
1219: POP
1220: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1221: LD_ADDR_VAR 0 7
1225: PUSH
1226: LD_INT 30
1228: PUSH
1229: LD_INT 0
1231: PUSH
1232: EMPTY
1233: LIST
1234: LIST
1235: PPUSH
1236: CALL_OW 69
1240: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1241: LD_ADDR_VAR 0 8
1245: PUSH
1246: LD_INT 30
1248: PUSH
1249: LD_INT 4
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: PPUSH
1256: CALL_OW 69
1260: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1261: LD_ADDR_VAR 0 9
1265: PUSH
1266: LD_INT 2
1268: PUSH
1269: LD_INT 30
1271: PUSH
1272: LD_INT 7
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 30
1281: PUSH
1282: LD_INT 6
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: PPUSH
1294: CALL_OW 69
1298: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1299: LD_ADDR_VAR 0 10
1303: PUSH
1304: LD_INT 30
1306: PUSH
1307: LD_INT 3
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: PPUSH
1314: CALL_OW 69
1318: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1319: LD_ADDR_VAR 0 11
1323: PUSH
1324: LD_INT 2
1326: PUSH
1327: LD_INT 30
1329: PUSH
1330: LD_INT 32
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: PUSH
1337: LD_INT 30
1339: PUSH
1340: LD_INT 31
1342: PUSH
1343: EMPTY
1344: LIST
1345: LIST
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL_OW 69
1356: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1357: LD_VAR 0 7
1361: PPUSH
1362: LD_STRING Gamma
1364: PPUSH
1365: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1369: LD_VAR 0 7
1373: PPUSH
1374: CALL_OW 274
1378: PPUSH
1379: LD_INT 2
1381: PPUSH
1382: LD_INT 10000
1384: PPUSH
1385: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1389: LD_VAR 0 7
1393: PPUSH
1394: CALL_OW 274
1398: PPUSH
1399: LD_INT 1
1401: PPUSH
1402: LD_INT 10000
1404: PPUSH
1405: CALL_OW 277
// if dep then
1409: LD_VAR 0 7
1413: IFFALSE 1513
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1415: LD_EXP 7
1419: PPUSH
1420: LD_VAR 0 7
1424: PUSH
1425: LD_INT 1
1427: ARRAY
1428: PPUSH
1429: CALL_OW 52
// if Brown then
1433: LD_EXP 14
1437: IFFALSE 1473
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1439: LD_EXP 14
1443: PPUSH
1444: LD_VAR 0 7
1448: PUSH
1449: LD_INT 1
1451: ARRAY
1452: PPUSH
1453: CALL_OW 52
// team := team diff Brown ;
1457: LD_ADDR_VAR 0 6
1461: PUSH
1462: LD_VAR 0 6
1466: PUSH
1467: LD_EXP 14
1471: DIFF
1472: ST_TO_ADDR
// end ; if Donaldson then
1473: LD_EXP 13
1477: IFFALSE 1513
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1479: LD_EXP 13
1483: PPUSH
1484: LD_VAR 0 7
1488: PUSH
1489: LD_INT 1
1491: ARRAY
1492: PPUSH
1493: CALL_OW 52
// team := team diff Donaldson ;
1497: LD_ADDR_VAR 0 6
1501: PUSH
1502: LD_VAR 0 6
1506: PUSH
1507: LD_EXP 13
1511: DIFF
1512: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1513: LD_VAR 0 11
1517: PUSH
1518: LD_VAR 0 6
1522: PPUSH
1523: LD_INT 25
1525: PUSH
1526: LD_INT 1
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: PPUSH
1533: CALL_OW 72
1537: AND
1538: IFFALSE 1647
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1540: LD_ADDR_VAR 0 12
1544: PUSH
1545: LD_VAR 0 6
1549: PPUSH
1550: LD_INT 25
1552: PUSH
1553: LD_INT 1
1555: PUSH
1556: EMPTY
1557: LIST
1558: LIST
1559: PPUSH
1560: CALL_OW 72
1564: ST_TO_ADDR
// for i in bun do
1565: LD_ADDR_VAR 0 13
1569: PUSH
1570: LD_VAR 0 11
1574: PUSH
1575: FOR_IN
1576: IFFALSE 1645
// begin if not filter then
1578: LD_VAR 0 12
1582: NOT
1583: IFFALSE 1587
// break ;
1585: GO 1645
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1587: LD_VAR 0 12
1591: PUSH
1592: LD_INT 1
1594: ARRAY
1595: PPUSH
1596: LD_VAR 0 13
1600: PPUSH
1601: CALL_OW 52
// team := team diff filter [ 1 ] ;
1605: LD_ADDR_VAR 0 6
1609: PUSH
1610: LD_VAR 0 6
1614: PUSH
1615: LD_VAR 0 12
1619: PUSH
1620: LD_INT 1
1622: ARRAY
1623: DIFF
1624: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1625: LD_ADDR_VAR 0 12
1629: PUSH
1630: LD_VAR 0 12
1634: PPUSH
1635: LD_INT 1
1637: PPUSH
1638: CALL_OW 3
1642: ST_TO_ADDR
// end ;
1643: GO 1575
1645: POP
1646: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1647: LD_VAR 0 8
1651: PUSH
1652: LD_VAR 0 6
1656: PPUSH
1657: LD_INT 25
1659: PUSH
1660: LD_INT 1
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL_OW 72
1671: AND
1672: IFFALSE 1794
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1674: LD_ADDR_VAR 0 12
1678: PUSH
1679: LD_VAR 0 6
1683: PPUSH
1684: LD_INT 25
1686: PUSH
1687: LD_INT 1
1689: PUSH
1690: EMPTY
1691: LIST
1692: LIST
1693: PPUSH
1694: CALL_OW 72
1698: ST_TO_ADDR
// for i = 1 to filter do
1699: LD_ADDR_VAR 0 13
1703: PUSH
1704: DOUBLE
1705: LD_INT 1
1707: DEC
1708: ST_TO_ADDR
1709: LD_VAR 0 12
1713: PUSH
1714: FOR_TO
1715: IFFALSE 1776
// begin if ( i <= 6 ) then
1717: LD_VAR 0 13
1721: PUSH
1722: LD_INT 6
1724: LESSEQUAL
1725: IFFALSE 1753
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1727: LD_VAR 0 12
1731: PUSH
1732: LD_VAR 0 13
1736: ARRAY
1737: PPUSH
1738: LD_VAR 0 8
1742: PUSH
1743: LD_INT 1
1745: ARRAY
1746: PPUSH
1747: CALL_OW 52
1751: GO 1774
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1753: LD_VAR 0 12
1757: PUSH
1758: LD_VAR 0 13
1762: ARRAY
1763: PPUSH
1764: LD_INT 1
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 49
// end ;
1774: GO 1714
1776: POP
1777: POP
// team := team diff filter ;
1778: LD_ADDR_VAR 0 6
1782: PUSH
1783: LD_VAR 0 6
1787: PUSH
1788: LD_VAR 0 12
1792: DIFF
1793: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1794: LD_VAR 0 9
1798: PUSH
1799: LD_VAR 0 6
1803: PPUSH
1804: LD_INT 25
1806: PUSH
1807: LD_INT 4
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL_OW 72
1818: AND
1819: IFFALSE 1941
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1821: LD_ADDR_VAR 0 12
1825: PUSH
1826: LD_VAR 0 6
1830: PPUSH
1831: LD_INT 25
1833: PUSH
1834: LD_INT 4
1836: PUSH
1837: EMPTY
1838: LIST
1839: LIST
1840: PPUSH
1841: CALL_OW 72
1845: ST_TO_ADDR
// for i = 1 to filter do
1846: LD_ADDR_VAR 0 13
1850: PUSH
1851: DOUBLE
1852: LD_INT 1
1854: DEC
1855: ST_TO_ADDR
1856: LD_VAR 0 12
1860: PUSH
1861: FOR_TO
1862: IFFALSE 1923
// begin if ( i <= 6 ) then
1864: LD_VAR 0 13
1868: PUSH
1869: LD_INT 6
1871: LESSEQUAL
1872: IFFALSE 1900
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1874: LD_VAR 0 12
1878: PUSH
1879: LD_VAR 0 13
1883: ARRAY
1884: PPUSH
1885: LD_VAR 0 9
1889: PUSH
1890: LD_INT 1
1892: ARRAY
1893: PPUSH
1894: CALL_OW 52
1898: GO 1921
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1900: LD_VAR 0 12
1904: PUSH
1905: LD_VAR 0 13
1909: ARRAY
1910: PPUSH
1911: LD_INT 1
1913: PPUSH
1914: LD_INT 0
1916: PPUSH
1917: CALL_OW 49
// end ;
1921: GO 1861
1923: POP
1924: POP
// team := team diff filter ;
1925: LD_ADDR_VAR 0 6
1929: PUSH
1930: LD_VAR 0 6
1934: PUSH
1935: LD_VAR 0 12
1939: DIFF
1940: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1941: LD_VAR 0 10
1945: PUSH
1946: LD_VAR 0 6
1950: PPUSH
1951: LD_INT 25
1953: PUSH
1954: LD_INT 3
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: PPUSH
1961: CALL_OW 72
1965: AND
1966: IFFALSE 2088
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1968: LD_ADDR_VAR 0 12
1972: PUSH
1973: LD_VAR 0 6
1977: PPUSH
1978: LD_INT 25
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: PPUSH
1988: CALL_OW 72
1992: ST_TO_ADDR
// for i = 1 to filter do
1993: LD_ADDR_VAR 0 13
1997: PUSH
1998: DOUBLE
1999: LD_INT 1
2001: DEC
2002: ST_TO_ADDR
2003: LD_VAR 0 12
2007: PUSH
2008: FOR_TO
2009: IFFALSE 2070
// begin if ( i <= 6 ) then
2011: LD_VAR 0 13
2015: PUSH
2016: LD_INT 6
2018: LESSEQUAL
2019: IFFALSE 2047
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2021: LD_VAR 0 12
2025: PUSH
2026: LD_VAR 0 13
2030: ARRAY
2031: PPUSH
2032: LD_VAR 0 10
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: CALL_OW 52
2045: GO 2068
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2047: LD_VAR 0 12
2051: PUSH
2052: LD_VAR 0 13
2056: ARRAY
2057: PPUSH
2058: LD_INT 1
2060: PPUSH
2061: LD_INT 0
2063: PPUSH
2064: CALL_OW 49
// end ;
2068: GO 2008
2070: POP
2071: POP
// team := team diff filter ;
2072: LD_ADDR_VAR 0 6
2076: PUSH
2077: LD_VAR 0 6
2081: PUSH
2082: LD_VAR 0 12
2086: DIFF
2087: ST_TO_ADDR
// end ; if team then
2088: LD_VAR 0 6
2092: IFFALSE 2135
// for i in team do
2094: LD_ADDR_VAR 0 13
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: FOR_IN
2105: IFFALSE 2133
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2107: LD_VAR 0 13
2111: PPUSH
2112: LD_INT 1
2114: PPUSH
2115: LD_INT 0
2117: PPUSH
2118: CALL_OW 49
// ComHold ( i ) ;
2122: LD_VAR 0 13
2126: PPUSH
2127: CALL_OW 140
// end ;
2131: GO 2104
2133: POP
2134: POP
// if fac then
2135: LD_VAR 0 10
2139: IFFALSE 2175
// if UnitsInside ( fac [ 1 ] ) then
2141: LD_VAR 0 10
2145: PUSH
2146: LD_INT 1
2148: ARRAY
2149: PPUSH
2150: CALL_OW 313
2154: IFFALSE 2175
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2156: LD_VAR 0 10
2160: PUSH
2161: LD_INT 1
2163: ARRAY
2164: PPUSH
2165: LD_INT 10
2167: PPUSH
2168: LD_INT 0
2170: PPUSH
2171: CALL_OW 486
// if lab then
2175: LD_VAR 0 9
2179: IFFALSE 2215
// if UnitsInside ( lab [ 1 ] ) then
2181: LD_VAR 0 9
2185: PUSH
2186: LD_INT 1
2188: ARRAY
2189: PPUSH
2190: CALL_OW 313
2194: IFFALSE 2215
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2196: LD_VAR 0 9
2200: PUSH
2201: LD_INT 1
2203: ARRAY
2204: PPUSH
2205: LD_INT 10
2207: PPUSH
2208: LD_INT 0
2210: PPUSH
2211: CALL_OW 486
// uc_side := 4 ;
2215: LD_ADDR_OWVAR 20
2219: PUSH
2220: LD_INT 4
2222: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2223: LD_ADDR_EXP 17
2227: PUSH
2228: LD_STRING Harisson
2230: PPUSH
2231: LD_INT 0
2233: PPUSH
2234: LD_STRING 
2236: PPUSH
2237: CALL 3893 0 3
2241: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_INT 4
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_INT 1
2255: PPUSH
2256: LD_INT 1
2258: PPUSH
2259: LD_INT 1
2261: PPUSH
2262: LD_INT 2
2264: PPUSH
2265: LD_INT 100
2267: PPUSH
2268: CALL 3956 0 7
2272: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2273: LD_VAR 0 5
2277: PPUSH
2278: LD_INT 2
2280: PPUSH
2281: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2285: LD_VAR 0 5
2289: PPUSH
2290: LD_INT 21
2292: PPUSH
2293: LD_INT 8
2295: PPUSH
2296: LD_INT 0
2298: PPUSH
2299: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2303: LD_EXP 17
2307: PPUSH
2308: LD_VAR 0 5
2312: PPUSH
2313: CALL_OW 52
// end ;
2317: LD_VAR 0 1
2321: RET
// function PrepareBase ; var blist , i , b ; begin
2322: LD_INT 0
2324: PPUSH
2325: PPUSH
2326: PPUSH
2327: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2328: LD_INT 71
2330: PPUSH
2331: LD_INT 5
2333: PPUSH
2334: LD_INT 1
2336: PPUSH
2337: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: LD_STRING GammaBase
2348: PPUSH
2349: EMPTY
2350: PPUSH
2351: CALL_OW 30
2355: ST_TO_ADDR
// if not blist then
2356: LD_VAR 0 2
2360: NOT
2361: IFFALSE 2401
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_INT 0
2370: PUSH
2371: LD_INT 51
2373: PUSH
2374: LD_INT 10
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 3
2382: PUSH
2383: LD_INT 0
2385: PUSH
2386: LD_INT 0
2388: PUSH
2389: EMPTY
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: ST_TO_ADDR
// uc_side := 1 ;
2401: LD_ADDR_OWVAR 20
2405: PUSH
2406: LD_INT 1
2408: ST_TO_ADDR
// uc_nation := 1 ;
2409: LD_ADDR_OWVAR 21
2413: PUSH
2414: LD_INT 1
2416: ST_TO_ADDR
// for i in blist do
2417: LD_ADDR_VAR 0 3
2421: PUSH
2422: LD_VAR 0 2
2426: PUSH
2427: FOR_IN
2428: IFFALSE 2579
// begin bc_type := i [ 1 ] ;
2430: LD_ADDR_OWVAR 42
2434: PUSH
2435: LD_VAR 0 3
2439: PUSH
2440: LD_INT 1
2442: ARRAY
2443: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2444: LD_ADDR_OWVAR 43
2448: PUSH
2449: LD_VAR 0 3
2453: PUSH
2454: LD_INT 5
2456: ARRAY
2457: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2458: LD_VAR 0 3
2462: PUSH
2463: LD_INT 1
2465: ARRAY
2466: PUSH
2467: LD_INT 7
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: IN
2477: IFFALSE 2507
// begin bc_kind1 := i [ 7 ] ;
2479: LD_ADDR_OWVAR 44
2483: PUSH
2484: LD_VAR 0 3
2488: PUSH
2489: LD_INT 7
2491: ARRAY
2492: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2493: LD_ADDR_OWVAR 45
2497: PUSH
2498: LD_VAR 0 3
2502: PUSH
2503: LD_INT 8
2505: ARRAY
2506: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2507: LD_ADDR_VAR 0 4
2511: PUSH
2512: LD_VAR 0 3
2516: PUSH
2517: LD_INT 2
2519: ARRAY
2520: PPUSH
2521: LD_VAR 0 3
2525: PUSH
2526: LD_INT 3
2528: ARRAY
2529: PPUSH
2530: LD_VAR 0 3
2534: PUSH
2535: LD_INT 4
2537: ARRAY
2538: PPUSH
2539: CALL_OW 47
2543: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2544: LD_VAR 0 4
2548: PPUSH
2549: CALL_OW 266
2553: PUSH
2554: LD_INT 32
2556: EQUAL
2557: IFFALSE 2577
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2559: LD_VAR 0 4
2563: PPUSH
2564: LD_VAR 0 3
2568: PUSH
2569: LD_INT 7
2571: ARRAY
2572: PPUSH
2573: CALL_OW 431
// end ; end ;
2577: GO 2427
2579: POP
2580: POP
// end ; end_of_file
2581: LD_VAR 0 1
2585: RET
// export function Action ; var points , i , sol , team , filter ; begin
2586: LD_INT 0
2588: PPUSH
2589: PPUSH
2590: PPUSH
2591: PPUSH
2592: PPUSH
2593: PPUSH
// InGameOn ;
2594: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2598: LD_INT 33
2600: PPUSH
2601: LD_INT 11
2603: PPUSH
2604: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2608: LD_ADDR_VAR 0 2
2612: PUSH
2613: LD_INT 29
2615: PUSH
2616: LD_INT 21
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: LD_INT 41
2625: PUSH
2626: LD_INT 28
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: PUSH
2633: LD_INT 52
2635: PUSH
2636: LD_INT 26
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: PUSH
2643: LD_INT 49
2645: PUSH
2646: LD_INT 16
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: LIST
2657: LIST
2658: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2659: LD_ADDR_VAR 0 4
2663: PUSH
2664: LD_INT 22
2666: PUSH
2667: LD_INT 1
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PUSH
2674: LD_INT 26
2676: PUSH
2677: LD_INT 1
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: PUSH
2693: LD_EXP 7
2697: PUSH
2698: LD_EXP 14
2702: PUSH
2703: LD_EXP 11
2707: PUSH
2708: LD_EXP 12
2712: PUSH
2713: LD_EXP 8
2717: PUSH
2718: LD_EXP 15
2722: PUSH
2723: LD_EXP 16
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: LIST
2732: LIST
2733: LIST
2734: LIST
2735: LIST
2736: DIFF
2737: PUSH
2738: LD_INT 1
2740: ARRAY
2741: ST_TO_ADDR
// if sol then
2742: LD_VAR 0 4
2746: IFFALSE 2777
// begin ComMoveXY ( sol , 50 , 18 ) ;
2748: LD_VAR 0 4
2752: PPUSH
2753: LD_INT 50
2755: PPUSH
2756: LD_INT 18
2758: PPUSH
2759: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2763: LD_VAR 0 4
2767: PPUSH
2768: LD_EXP 17
2772: PPUSH
2773: CALL_OW 179
// end ; for i in points do
2777: LD_ADDR_VAR 0 3
2781: PUSH
2782: LD_VAR 0 2
2786: PUSH
2787: FOR_IN
2788: IFFALSE 2819
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2790: LD_EXP 17
2794: PPUSH
2795: LD_VAR 0 3
2799: PUSH
2800: LD_INT 1
2802: ARRAY
2803: PPUSH
2804: LD_VAR 0 3
2808: PUSH
2809: LD_INT 2
2811: ARRAY
2812: PPUSH
2813: CALL_OW 171
2817: GO 2787
2819: POP
2820: POP
// AddComExitVehicle ( Harisson ) ;
2821: LD_EXP 17
2825: PPUSH
2826: CALL_OW 181
// repeat wait ( 3 ) ;
2830: LD_INT 3
2832: PPUSH
2833: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2837: LD_EXP 17
2841: PPUSH
2842: CALL_OW 310
2846: NOT
2847: IFFALSE 2830
// Say ( sol , D1-Sol1-1 ) ;
2849: LD_VAR 0 4
2853: PPUSH
2854: LD_STRING D1-Sol1-1
2856: PPUSH
2857: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2861: LD_EXP 17
2865: PPUSH
2866: LD_VAR 0 4
2870: PPUSH
2871: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2875: LD_EXP 17
2879: PPUSH
2880: LD_STRING D1-Har-1
2882: PPUSH
2883: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2887: LD_INT 10
2889: PPUSH
2890: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2894: LD_VAR 0 4
2898: PPUSH
2899: LD_INT 35
2901: PPUSH
2902: LD_INT 21
2904: PPUSH
2905: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2909: LD_EXP 7
2913: PPUSH
2914: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2918: LD_EXP 7
2922: PPUSH
2923: LD_EXP 17
2927: PPUSH
2928: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2932: LD_EXP 17
2936: PPUSH
2937: LD_EXP 7
2941: PPUSH
2942: CALL_OW 119
// repeat wait ( 3 ) ;
2946: LD_INT 3
2948: PPUSH
2949: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2953: LD_EXP 7
2957: PPUSH
2958: LD_EXP 17
2962: PPUSH
2963: CALL_OW 296
2967: PUSH
2968: LD_INT 4
2970: LESS
2971: IFFALSE 2946
// ComTurnUnit ( JMM , Harisson ) ;
2973: LD_EXP 7
2977: PPUSH
2978: LD_EXP 17
2982: PPUSH
2983: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2987: LD_EXP 7
2991: PPUSH
2992: LD_STRING D1-JMM-1
2994: PPUSH
2995: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2999: LD_EXP 17
3003: PPUSH
3004: LD_STRING D1-Har-2
3006: PPUSH
3007: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3011: LD_EXP 7
3015: PPUSH
3016: LD_STRING D1-JMM-2
3018: PPUSH
3019: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3023: LD_EXP 17
3027: PPUSH
3028: LD_STRING D1-Har-3
3030: PPUSH
3031: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3035: LD_EXP 7
3039: PPUSH
3040: LD_STRING D1-JMM-3
3042: PPUSH
3043: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3047: LD_EXP 17
3051: PPUSH
3052: LD_STRING D1-Har-4
3054: PPUSH
3055: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3059: LD_EXP 7
3063: PPUSH
3064: LD_STRING D1-JMM-4
3066: PPUSH
3067: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3071: LD_EXP 17
3075: PPUSH
3076: LD_STRING D1-Har-5
3078: PPUSH
3079: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3083: LD_EXP 7
3087: PPUSH
3088: LD_STRING D1-JMM-5
3090: PPUSH
3091: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3095: LD_EXP 17
3099: PPUSH
3100: LD_STRING D1-Har-6
3102: PPUSH
3103: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3107: LD_EXP 7
3111: PPUSH
3112: LD_STRING D1-JMM-6
3114: PPUSH
3115: CALL_OW 88
// EndMission ;
3119: CALL 3128 0 0
// end ;
3123: LD_VAR 0 1
3127: RET
// export function EndMission ; var commander , i , all ; begin
3128: LD_INT 0
3130: PPUSH
3131: PPUSH
3132: PPUSH
3133: PPUSH
// case gamma_commander of 1 :
3134: LD_EXP 18
3138: PUSH
3139: LD_INT 1
3141: DOUBLE
3142: EQUAL
3143: IFTRUE 3147
3145: GO 3160
3147: POP
// commander := Donaldson ; 2 :
3148: LD_ADDR_VAR 0 2
3152: PUSH
3153: LD_EXP 13
3157: ST_TO_ADDR
3158: GO 3203
3160: LD_INT 2
3162: DOUBLE
3163: EQUAL
3164: IFTRUE 3168
3166: GO 3181
3168: POP
// commander := Brown ; 3 :
3169: LD_ADDR_VAR 0 2
3173: PUSH
3174: LD_EXP 14
3178: ST_TO_ADDR
3179: GO 3203
3181: LD_INT 3
3183: DOUBLE
3184: EQUAL
3185: IFTRUE 3189
3187: GO 3202
3189: POP
// commander := Houten ; end ;
3190: LD_ADDR_VAR 0 2
3194: PUSH
3195: LD_EXP 15
3199: ST_TO_ADDR
3200: GO 3203
3202: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3203: LD_ADDR_VAR 0 4
3207: PUSH
3208: LD_INT 22
3210: PUSH
3211: LD_INT 1
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: PUSH
3218: LD_INT 21
3220: PUSH
3221: LD_INT 1
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL_OW 69
3236: PUSH
3237: LD_EXP 7
3241: PUSH
3242: LD_VAR 0 2
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: DIFF
3251: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3252: LD_ADDR_EXP 4
3256: PUSH
3257: LD_STRING 1
3259: PPUSH
3260: LD_INT 10
3262: PPUSH
3263: LD_INT 10
3265: PPUSH
3266: LD_INT -5
3268: PUSH
3269: LD_EXP 7
3273: PUSH
3274: LD_INT -2
3276: PUSH
3277: LD_INT -3
3279: PUSH
3280: LD_INT -5
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: PUSH
3290: LD_VAR 0 4
3294: ADD
3295: PUSH
3296: LD_INT -6
3298: PUSH
3299: LD_INT -4
3301: PUSH
3302: LD_VAR 0 2
3306: PUSH
3307: LD_EXP 17
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: LIST
3320: ADD
3321: PPUSH
3322: LD_INT 1
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: EMPTY
3329: LIST
3330: LIST
3331: PUSH
3332: LD_INT 3
3334: PUSH
3335: LD_INT 3
3337: PUSH
3338: LD_INT 6
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: LIST
3345: PUSH
3346: LD_INT 4
3348: PUSH
3349: LD_INT 1
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: LIST
3360: PPUSH
3361: CALL_OW 42
3365: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3366: LD_VAR 0 4
3370: PUSH
3371: LD_EXP 7
3375: PUSH
3376: LD_EXP 8
3380: PUSH
3381: LD_EXP 10
3385: PUSH
3386: LD_EXP 11
3390: PUSH
3391: LD_EXP 12
3395: PUSH
3396: LD_EXP 9
3400: PUSH
3401: LD_EXP 13
3405: PUSH
3406: LD_EXP 14
3410: PUSH
3411: LD_EXP 15
3415: PUSH
3416: LD_EXP 17
3420: PUSH
3421: LD_EXP 16
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_EXP 4
3443: ADD
3444: DIFF
3445: PPUSH
3446: LD_STRING 07_othersGamma
3448: PPUSH
3449: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3453: LD_EXP 4
3457: PUSH
3458: LD_EXP 7
3462: PUSH
3463: LD_EXP 8
3467: PUSH
3468: LD_EXP 10
3472: PUSH
3473: LD_EXP 11
3477: PUSH
3478: LD_EXP 12
3482: PUSH
3483: LD_EXP 9
3487: PUSH
3488: LD_EXP 13
3492: PUSH
3493: LD_EXP 14
3497: PUSH
3498: LD_EXP 15
3502: PUSH
3503: LD_EXP 17
3507: PUSH
3508: LD_EXP 16
3512: PUSH
3513: LD_INT 0
3515: PUSH
3516: EMPTY
3517: LIST
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: LIST
3528: LIST
3529: DIFF
3530: PPUSH
3531: LD_STRING 07_others
3533: PPUSH
3534: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3538: LD_EXP 7
3542: PPUSH
3543: LD_EXP 5
3547: PUSH
3548: LD_STRING JMM
3550: STR
3551: PPUSH
3552: CALL_OW 38
// if Lisa then
3556: LD_EXP 10
3560: IFFALSE 3602
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3562: LD_EXP 10
3566: PPUSH
3567: LD_EXP 5
3571: PUSH
3572: LD_STRING Lisa
3574: STR
3575: PPUSH
3576: CALL_OW 38
// if Lisa in save_group then
3580: LD_EXP 10
3584: PUSH
3585: LD_EXP 4
3589: IN
3590: IFFALSE 3602
// SaveVariable ( true , LisaIn07 ) ;
3592: LD_INT 1
3594: PPUSH
3595: LD_STRING LisaIn07
3597: PPUSH
3598: CALL_OW 39
// end ; if Bobby then
3602: LD_EXP 12
3606: IFFALSE 3648
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3608: LD_EXP 12
3612: PPUSH
3613: LD_EXP 5
3617: PUSH
3618: LD_STRING Bobby
3620: STR
3621: PPUSH
3622: CALL_OW 38
// if Bobby in save_group then
3626: LD_EXP 12
3630: PUSH
3631: LD_EXP 4
3635: IN
3636: IFFALSE 3648
// SaveVariable ( true , BobbyIn07 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_STRING BobbyIn07
3643: PPUSH
3644: CALL_OW 39
// end ; if Cyrus then
3648: LD_EXP 11
3652: IFFALSE 3694
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3654: LD_EXP 11
3658: PPUSH
3659: LD_EXP 5
3663: PUSH
3664: LD_STRING Cyrus
3666: STR
3667: PPUSH
3668: CALL_OW 38
// if Cyrus in save_group then
3672: LD_EXP 11
3676: PUSH
3677: LD_EXP 4
3681: IN
3682: IFFALSE 3694
// SaveVariable ( true , CyrusIn07 ) ;
3684: LD_INT 1
3686: PPUSH
3687: LD_STRING CyrusIn07
3689: PPUSH
3690: CALL_OW 39
// end ; if Brown then
3694: LD_EXP 14
3698: IFFALSE 3740
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3700: LD_EXP 14
3704: PPUSH
3705: LD_EXP 5
3709: PUSH
3710: LD_STRING Brown
3712: STR
3713: PPUSH
3714: CALL_OW 38
// if Brown in save_group then
3718: LD_EXP 14
3722: PUSH
3723: LD_EXP 4
3727: IN
3728: IFFALSE 3740
// SaveVariable ( true , BrownIn07 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_STRING BrownIn07
3735: PPUSH
3736: CALL_OW 39
// end ; if Donaldson then
3740: LD_EXP 13
3744: IFFALSE 3786
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3746: LD_EXP 13
3750: PPUSH
3751: LD_EXP 5
3755: PUSH
3756: LD_STRING Donaldson
3758: STR
3759: PPUSH
3760: CALL_OW 38
// if Donaldson in save_group then
3764: LD_EXP 13
3768: PUSH
3769: LD_EXP 4
3773: IN
3774: IFFALSE 3786
// SaveVariable ( true , DonaldsonIn07 ) ;
3776: LD_INT 1
3778: PPUSH
3779: LD_STRING DonaldsonIn07
3781: PPUSH
3782: CALL_OW 39
// end ; if Gladstone then
3786: LD_EXP 8
3790: IFFALSE 3832
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3792: LD_EXP 8
3796: PPUSH
3797: LD_EXP 5
3801: PUSH
3802: LD_STRING Gladstone
3804: STR
3805: PPUSH
3806: CALL_OW 38
// if Gladstone in save_group then
3810: LD_EXP 8
3814: PUSH
3815: LD_EXP 4
3819: IN
3820: IFFALSE 3832
// SaveVariable ( true , GladstoneIn07 ) ;
3822: LD_INT 1
3824: PPUSH
3825: LD_STRING GladstoneIn07
3827: PPUSH
3828: CALL_OW 39
// end ; if Khatam then
3832: LD_EXP 16
3836: IFFALSE 3878
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3838: LD_EXP 16
3842: PPUSH
3843: LD_EXP 5
3847: PUSH
3848: LD_STRING Khatam
3850: STR
3851: PPUSH
3852: CALL_OW 38
// if Khatam in save_group then
3856: LD_EXP 16
3860: PUSH
3861: LD_EXP 4
3865: IN
3866: IFFALSE 3878
// SaveVariable ( true , KhatamIn07 ) ;
3868: LD_INT 1
3870: PPUSH
3871: LD_STRING KhatamIn07
3873: PPUSH
3874: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3878: LD_INT 1
3880: PPUSH
3881: LD_STRING %_cont
3883: PPUSH
3884: CALL_OW 340
// end ; end_of_file
3888: LD_VAR 0 1
3892: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3893: LD_INT 0
3895: PPUSH
3896: PPUSH
// if exist_mode then
3897: LD_VAR 0 2
3901: IFFALSE 3926
// unit := CreateCharacter ( prefix & ident ) else
3903: LD_ADDR_VAR 0 5
3907: PUSH
3908: LD_VAR 0 3
3912: PUSH
3913: LD_VAR 0 1
3917: STR
3918: PPUSH
3919: CALL_OW 34
3923: ST_TO_ADDR
3924: GO 3941
// unit := NewCharacter ( ident ) ;
3926: LD_ADDR_VAR 0 5
3930: PUSH
3931: LD_VAR 0 1
3935: PPUSH
3936: CALL_OW 25
3940: ST_TO_ADDR
// result := unit ;
3941: LD_ADDR_VAR 0 4
3945: PUSH
3946: LD_VAR 0 5
3950: ST_TO_ADDR
// end ;
3951: LD_VAR 0 4
3955: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3956: LD_INT 0
3958: PPUSH
// uc_side := side ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_VAR 0 1
3968: ST_TO_ADDR
// uc_nation := nation ;
3969: LD_ADDR_OWVAR 21
3973: PUSH
3974: LD_VAR 0 2
3978: ST_TO_ADDR
// vc_chassis := chassis ;
3979: LD_ADDR_OWVAR 37
3983: PUSH
3984: LD_VAR 0 3
3988: ST_TO_ADDR
// vc_engine := engine ;
3989: LD_ADDR_OWVAR 39
3993: PUSH
3994: LD_VAR 0 4
3998: ST_TO_ADDR
// vc_control := control ;
3999: LD_ADDR_OWVAR 38
4003: PUSH
4004: LD_VAR 0 5
4008: ST_TO_ADDR
// vc_weapon := weapon ;
4009: LD_ADDR_OWVAR 40
4013: PUSH
4014: LD_VAR 0 6
4018: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4019: LD_ADDR_OWVAR 41
4023: PUSH
4024: LD_VAR 0 7
4028: ST_TO_ADDR
// result := CreateVehicle ;
4029: LD_ADDR_VAR 0 8
4033: PUSH
4034: CALL_OW 45
4038: ST_TO_ADDR
// end ;
4039: LD_VAR 0 8
4043: RET
// export function SayX ( units , ident ) ; var i ; begin
4044: LD_INT 0
4046: PPUSH
4047: PPUSH
// result := false ;
4048: LD_ADDR_VAR 0 3
4052: PUSH
4053: LD_INT 0
4055: ST_TO_ADDR
// if not units then
4056: LD_VAR 0 1
4060: NOT
4061: IFFALSE 4065
// exit ;
4063: GO 4119
// for i in units do
4065: LD_ADDR_VAR 0 4
4069: PUSH
4070: LD_VAR 0 1
4074: PUSH
4075: FOR_IN
4076: IFFALSE 4117
// if IsOk ( i ) then
4078: LD_VAR 0 4
4082: PPUSH
4083: CALL_OW 302
4087: IFFALSE 4115
// begin Say ( i , ident ) ;
4089: LD_VAR 0 4
4093: PPUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: CALL_OW 88
// result := i ;
4103: LD_ADDR_VAR 0 3
4107: PUSH
4108: LD_VAR 0 4
4112: ST_TO_ADDR
// break ;
4113: GO 4117
// end ;
4115: GO 4075
4117: POP
4118: POP
// end ;
4119: LD_VAR 0 3
4123: RET
