// starting begin ResetFog ;
   0: CALL_OW 335
// FogOff ( 1 ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// Randomize ;
  11: CALL_OW 10
// Init ;
  15: CALL 32 0 0
// DebugMode ;
  19: CALL 98 0 0
// PrepareAmerican ;
  23: CALL 115 0 0
// Action ;
  27: CALL 2581 0 0
// end ;
  31: END
// export debug ; export donaldson_commander , brown_commander , save_group ; export mission_prefix , mission_prefix_prev ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// debug := false ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// mission_prefix := 07_ ;
  43: LD_ADDR_EXP 5
  47: PUSH
  48: LD_STRING 07_
  50: ST_TO_ADDR
// mission_prefix_prev := [ 06_ , 05_ , 04_ ] ;
  51: LD_ADDR_EXP 6
  55: PUSH
  56: LD_STRING 06_
  58: PUSH
  59: LD_STRING 05_
  61: PUSH
  62: LD_STRING 04_
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: ST_TO_ADDR
// donaldson_commander := false ;
  70: LD_ADDR_EXP 2
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// brown_commander := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// save_group := [ ] ;
  86: LD_ADDR_EXP 4
  90: PUSH
  91: EMPTY
  92: ST_TO_ADDR
// end ;
  93: LD_VAR 0 1
  97: RET
// function DebugMode ; begin
  98: LD_INT 0
 100: PPUSH
// if not debug then
 101: LD_EXP 1
 105: NOT
 106: IFFALSE 110
// exit ;
 108: GO 110
// end ; end_of_file
 110: LD_VAR 0 1
 114: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown , Houten , Khatam , Harisson ; export gamma_commander ; export function PrepareAmerican ; var others , others_delta , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , j ; begin
 115: LD_INT 0
 117: PPUSH
 118: PPUSH
 119: PPUSH
 120: PPUSH
 121: PPUSH
 122: PPUSH
 123: PPUSH
 124: PPUSH
 125: PPUSH
 126: PPUSH
 127: PPUSH
 128: PPUSH
 129: PPUSH
 130: PPUSH
// PrepareBase ;
 131: CALL 2302 0 0
// uc_side := 1 ;
 135: LD_ADDR_OWVAR 20
 139: PUSH
 140: LD_INT 1
 142: ST_TO_ADDR
// uc_nation := 1 ;
 143: LD_ADDR_OWVAR 21
 147: PUSH
 148: LD_INT 1
 150: ST_TO_ADDR
// team := [ ] ;
 151: LD_ADDR_VAR 0 6
 155: PUSH
 156: EMPTY
 157: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 06c_ ) ;
 158: LD_ADDR_EXP 7
 162: PUSH
 163: LD_STRING JMM
 165: PPUSH
 166: LD_EXP 1
 170: NOT
 171: PPUSH
 172: LD_STRING 06c_
 174: PPUSH
 175: CALL 3888 0 3
 179: ST_TO_ADDR
// gamma_commander := LoadVariable ( GammaCommander , 3 ) ;
 180: LD_ADDR_EXP 18
 184: PUSH
 185: LD_STRING GammaCommander
 187: PPUSH
 188: LD_INT 3
 190: PPUSH
 191: CALL_OW 30
 195: ST_TO_ADDR
// if gamma_commander = 1 then
 196: LD_EXP 18
 200: PUSH
 201: LD_INT 1
 203: EQUAL
 204: IFFALSE 230
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 206: LD_ADDR_EXP 13
 210: PUSH
 211: LD_STRING Donaldson
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 04_
 222: PPUSH
 223: CALL 3888 0 3
 227: ST_TO_ADDR
// end else
 228: GO 301
// begin if LoadVariable ( DonaldsonIn06 , 0 ) then
 230: LD_STRING DonaldsonIn06
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: IFFALSE 266
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 06c_ ) else
 242: LD_ADDR_EXP 13
 246: PUSH
 247: LD_STRING Donaldson
 249: PPUSH
 250: LD_EXP 1
 254: NOT
 255: PPUSH
 256: LD_STRING 06c_
 258: PPUSH
 259: CALL 3888 0 3
 263: ST_TO_ADDR
 264: GO 301
// if not LoadVariable ( DonaldsonStayInDelta , 0 ) then
 266: LD_STRING DonaldsonStayInDelta
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: NOT
 277: IFFALSE 301
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 04_ ) ;
 279: LD_ADDR_EXP 13
 283: PUSH
 284: LD_STRING Donaldson
 286: PPUSH
 287: LD_EXP 1
 291: NOT
 292: PPUSH
 293: LD_STRING 04_
 295: PPUSH
 296: CALL 3888 0 3
 300: ST_TO_ADDR
// end ; if Donaldson then
 301: LD_EXP 13
 305: IFFALSE 323
// team := team ^ Donaldson ;
 307: LD_ADDR_VAR 0 6
 311: PUSH
 312: LD_VAR 0 6
 316: PUSH
 317: LD_EXP 13
 321: ADD
 322: ST_TO_ADDR
// if gamma_commander = 2 then
 323: LD_EXP 18
 327: PUSH
 328: LD_INT 2
 330: EQUAL
 331: IFFALSE 357
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 333: LD_ADDR_EXP 14
 337: PUSH
 338: LD_STRING Brown
 340: PPUSH
 341: LD_EXP 1
 345: NOT
 346: PPUSH
 347: LD_STRING 04_
 349: PPUSH
 350: CALL 3888 0 3
 354: ST_TO_ADDR
// end else
 355: GO 428
// begin if LoadVariable ( BrownIn06 , 0 ) then
 357: LD_STRING BrownIn06
 359: PPUSH
 360: LD_INT 0
 362: PPUSH
 363: CALL_OW 30
 367: IFFALSE 393
// Brown := PrepareUnit ( Brown , ( not debug ) , 06c_ ) else
 369: LD_ADDR_EXP 14
 373: PUSH
 374: LD_STRING Brown
 376: PPUSH
 377: LD_EXP 1
 381: NOT
 382: PPUSH
 383: LD_STRING 06c_
 385: PPUSH
 386: CALL 3888 0 3
 390: ST_TO_ADDR
 391: GO 428
// if not LoadVariable ( BrownStayInDelta , 0 ) then
 393: LD_STRING BrownStayInDelta
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: CALL_OW 30
 403: NOT
 404: IFFALSE 428
// Brown := PrepareUnit ( Brown , ( not debug ) , 04_ ) ;
 406: LD_ADDR_EXP 14
 410: PUSH
 411: LD_STRING Brown
 413: PPUSH
 414: LD_EXP 1
 418: NOT
 419: PPUSH
 420: LD_STRING 04_
 422: PPUSH
 423: CALL 3888 0 3
 427: ST_TO_ADDR
// end ; if Brown then
 428: LD_EXP 14
 432: IFFALSE 450
// team := team ^ Brown ;
 434: LD_ADDR_VAR 0 6
 438: PUSH
 439: LD_VAR 0 6
 443: PUSH
 444: LD_EXP 14
 448: ADD
 449: ST_TO_ADDR
// if gamma_commander = 3 then
 450: LD_EXP 18
 454: PUSH
 455: LD_INT 3
 457: EQUAL
 458: IFFALSE 495
// begin Houten := PrepareUnit ( VanHouten , false ,  ) ;
 460: LD_ADDR_EXP 15
 464: PUSH
 465: LD_STRING VanHouten
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: LD_STRING 
 473: PPUSH
 474: CALL 3888 0 3
 478: ST_TO_ADDR
// team := team ^ Houten ;
 479: LD_ADDR_VAR 0 6
 483: PUSH
 484: LD_VAR 0 6
 488: PUSH
 489: LD_EXP 15
 493: ADD
 494: ST_TO_ADDR
// end ; if LoadVariable ( GladstoneIn06 , 0 ) then
 495: LD_STRING GladstoneIn06
 497: PPUSH
 498: LD_INT 0
 500: PPUSH
 501: CALL_OW 30
 505: IFFALSE 529
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 06c_ ) ;
 507: LD_ADDR_EXP 8
 511: PUSH
 512: LD_STRING Gladstone
 514: PPUSH
 515: LD_EXP 1
 519: NOT
 520: PPUSH
 521: LD_STRING 06c_
 523: PPUSH
 524: CALL 3888 0 3
 528: ST_TO_ADDR
// if Gladstone then
 529: LD_EXP 8
 533: IFFALSE 551
// team := team ^ Gladstone ;
 535: LD_ADDR_VAR 0 6
 539: PUSH
 540: LD_VAR 0 6
 544: PUSH
 545: LD_EXP 8
 549: ADD
 550: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) , 03_ ) ;
 551: LD_ADDR_EXP 16
 555: PUSH
 556: LD_STRING Khatam
 558: PPUSH
 559: LD_EXP 1
 563: NOT
 564: PPUSH
 565: LD_STRING 03_
 567: PPUSH
 568: CALL 3888 0 3
 572: ST_TO_ADDR
// if Khatam then
 573: LD_EXP 16
 577: IFFALSE 595
// team := team ^ Khatam ;
 579: LD_ADDR_VAR 0 6
 583: PUSH
 584: LD_VAR 0 6
 588: PUSH
 589: LD_EXP 16
 593: ADD
 594: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
 595: LD_STRING FrankIn06
 597: PPUSH
 598: LD_INT 0
 600: PPUSH
 601: CALL_OW 30
 605: IFFALSE 631
// Frank := PrepareUnit ( Frank , ( not debug ) , 06c_ ) else
 607: LD_ADDR_EXP 9
 611: PUSH
 612: LD_STRING Frank
 614: PPUSH
 615: LD_EXP 1
 619: NOT
 620: PPUSH
 621: LD_STRING 06c_
 623: PPUSH
 624: CALL 3888 0 3
 628: ST_TO_ADDR
 629: GO 689
// if LoadVariable ( FrankInDelta , 0 ) then
 631: LD_STRING FrankInDelta
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 30
 641: IFFALSE 667
// Frank := PrepareUnit ( Frank , ( not debug ) , 05_ ) else
 643: LD_ADDR_EXP 9
 647: PUSH
 648: LD_STRING Frank
 650: PPUSH
 651: LD_EXP 1
 655: NOT
 656: PPUSH
 657: LD_STRING 05_
 659: PPUSH
 660: CALL 3888 0 3
 664: ST_TO_ADDR
 665: GO 689
// Frank := PrepareUnit ( Frank , ( not debug ) , 04_ ) ;
 667: LD_ADDR_EXP 9
 671: PUSH
 672: LD_STRING Frank
 674: PPUSH
 675: LD_EXP 1
 679: NOT
 680: PPUSH
 681: LD_STRING 04_
 683: PPUSH
 684: CALL 3888 0 3
 688: ST_TO_ADDR
// if Frank then
 689: LD_EXP 9
 693: IFFALSE 711
// team := team ^ Frank ;
 695: LD_ADDR_VAR 0 6
 699: PUSH
 700: LD_VAR 0 6
 704: PUSH
 705: LD_EXP 9
 709: ADD
 710: ST_TO_ADDR
// if LoadVariable ( LisaIn06 , 0 ) then
 711: LD_STRING LisaIn06
 713: PPUSH
 714: LD_INT 0
 716: PPUSH
 717: CALL_OW 30
 721: IFFALSE 747
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 06c_ ) else
 723: LD_ADDR_EXP 10
 727: PUSH
 728: LD_STRING Lisa
 730: PPUSH
 731: LD_EXP 1
 735: NOT
 736: PPUSH
 737: LD_STRING 06c_
 739: PPUSH
 740: CALL 3888 0 3
 744: ST_TO_ADDR
 745: GO 782
// if not LoadVariable ( LisaStayInDelta , 0 ) then
 747: LD_STRING LisaStayInDelta
 749: PPUSH
 750: LD_INT 0
 752: PPUSH
 753: CALL_OW 30
 757: NOT
 758: IFFALSE 782
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 04_ ) ;
 760: LD_ADDR_EXP 10
 764: PUSH
 765: LD_STRING Lisa
 767: PPUSH
 768: LD_EXP 1
 772: NOT
 773: PPUSH
 774: LD_STRING 04_
 776: PPUSH
 777: CALL 3888 0 3
 781: ST_TO_ADDR
// if Lisa then
 782: LD_EXP 10
 786: IFFALSE 804
// team := team ^ Lisa ;
 788: LD_ADDR_VAR 0 6
 792: PUSH
 793: LD_VAR 0 6
 797: PUSH
 798: LD_EXP 10
 802: ADD
 803: ST_TO_ADDR
// if not Lisa then
 804: LD_EXP 10
 808: NOT
 809: IFFALSE 1062
// begin if LoadVariable ( CyrusIn06 , 0 ) then
 811: LD_STRING CyrusIn06
 813: PPUSH
 814: LD_INT 0
 816: PPUSH
 817: CALL_OW 30
 821: IFFALSE 847
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 06c_ ) else
 823: LD_ADDR_EXP 11
 827: PUSH
 828: LD_STRING Cyrus
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 06c_
 839: PPUSH
 840: CALL 3888 0 3
 844: ST_TO_ADDR
 845: GO 911
// if not LoadVariable ( CyrusStayInDelta , 0 ) then
 847: LD_STRING CyrusStayInDelta
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 30
 857: NOT
 858: IFFALSE 911
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 04_ ) ;
 860: LD_ADDR_EXP 11
 864: PUSH
 865: LD_STRING Cyrus
 867: PPUSH
 868: LD_EXP 1
 872: NOT
 873: PPUSH
 874: LD_STRING 04_
 876: PPUSH
 877: CALL 3888 0 3
 881: ST_TO_ADDR
// if not Cyrus then
 882: LD_EXP 11
 886: NOT
 887: IFFALSE 911
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
 889: LD_ADDR_EXP 11
 893: PUSH
 894: LD_STRING Cyrus
 896: PPUSH
 897: LD_EXP 1
 901: NOT
 902: PPUSH
 903: LD_STRING 03_
 905: PPUSH
 906: CALL 3888 0 3
 910: ST_TO_ADDR
// end ; if Cyrus then
 911: LD_EXP 11
 915: IFFALSE 933
// team := team ^ Cyrus ;
 917: LD_ADDR_VAR 0 6
 921: PUSH
 922: LD_VAR 0 6
 926: PUSH
 927: LD_EXP 11
 931: ADD
 932: ST_TO_ADDR
// if not Cyrus then
 933: LD_EXP 11
 937: NOT
 938: IFFALSE 1062
// begin if LoadVariable ( BobbyIn06 , 0 ) then
 940: LD_STRING BobbyIn06
 942: PPUSH
 943: LD_INT 0
 945: PPUSH
 946: CALL_OW 30
 950: IFFALSE 976
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 06c_ ) else
 952: LD_ADDR_EXP 12
 956: PUSH
 957: LD_STRING Bobby
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 06c_
 968: PPUSH
 969: CALL 3888 0 3
 973: ST_TO_ADDR
 974: GO 1040
// if not LoadVariable ( BobbyStayInDelta , 0 ) then
 976: LD_STRING BobbyStayInDelta
 978: PPUSH
 979: LD_INT 0
 981: PPUSH
 982: CALL_OW 30
 986: NOT
 987: IFFALSE 1040
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 04_ ) ;
 989: LD_ADDR_EXP 12
 993: PUSH
 994: LD_STRING Bobby
 996: PPUSH
 997: LD_EXP 1
1001: NOT
1002: PPUSH
1003: LD_STRING 04_
1005: PPUSH
1006: CALL 3888 0 3
1010: ST_TO_ADDR
// if not Bobby then
1011: LD_EXP 12
1015: NOT
1016: IFFALSE 1040
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
1018: LD_ADDR_EXP 12
1022: PUSH
1023: LD_STRING Bobby
1025: PPUSH
1026: LD_EXP 1
1030: NOT
1031: PPUSH
1032: LD_STRING 03_
1034: PPUSH
1035: CALL 3888 0 3
1039: ST_TO_ADDR
// end ; if Bobby then
1040: LD_EXP 12
1044: IFFALSE 1062
// team := team ^ Bobby ;
1046: LD_ADDR_VAR 0 6
1050: PUSH
1051: LD_VAR 0 6
1055: PUSH
1056: LD_EXP 12
1060: ADD
1061: ST_TO_ADDR
// end ; end ; others4 := CreateCharacterSet ( othersGamma ) ;
1062: LD_ADDR_VAR 0 4
1066: PUSH
1067: LD_STRING othersGamma
1069: PPUSH
1070: CALL_OW 31
1074: ST_TO_ADDR
// others := CreateCharacterSet ( 06_other_survivors ) ;
1075: LD_ADDR_VAR 0 2
1079: PUSH
1080: LD_STRING 06_other_survivors
1082: PPUSH
1083: CALL_OW 31
1087: ST_TO_ADDR
// others := others union others4 ;
1088: LD_ADDR_VAR 0 2
1092: PUSH
1093: LD_VAR 0 2
1097: PUSH
1098: LD_VAR 0 4
1102: UNION
1103: ST_TO_ADDR
// team := team ^ others ;
1104: LD_ADDR_VAR 0 6
1108: PUSH
1109: LD_VAR 0 6
1113: PUSH
1114: LD_VAR 0 2
1118: ADD
1119: ST_TO_ADDR
// for i in others do
1120: LD_ADDR_VAR 0 13
1124: PUSH
1125: LD_VAR 0 2
1129: PUSH
1130: FOR_IN
1131: IFFALSE 1199
// begin if GetClass ( i ) = 2 then
1133: LD_VAR 0 13
1137: PPUSH
1138: CALL_OW 257
1142: PUSH
1143: LD_INT 2
1145: EQUAL
1146: IFFALSE 1160
// SetClass ( i , 1 ) ;
1148: LD_VAR 0 13
1152: PPUSH
1153: LD_INT 1
1155: PPUSH
1156: CALL_OW 336
// for j = 1 to 4 do
1160: LD_ADDR_VAR 0 14
1164: PUSH
1165: DOUBLE
1166: LD_INT 1
1168: DEC
1169: ST_TO_ADDR
1170: LD_INT 4
1172: PUSH
1173: FOR_TO
1174: IFFALSE 1195
// AddExperience ( i , j , 3000 ) ;
1176: LD_VAR 0 13
1180: PPUSH
1181: LD_VAR 0 14
1185: PPUSH
1186: LD_INT 3000
1188: PPUSH
1189: CALL_OW 492
1193: GO 1173
1195: POP
1196: POP
// end ;
1197: GO 1130
1199: POP
1200: POP
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
1201: LD_ADDR_VAR 0 7
1205: PUSH
1206: LD_INT 30
1208: PUSH
1209: LD_INT 0
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: PPUSH
1216: CALL_OW 69
1220: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
1221: LD_ADDR_VAR 0 8
1225: PUSH
1226: LD_INT 30
1228: PUSH
1229: LD_INT 4
1231: PUSH
1232: EMPTY
1233: LIST
1234: LIST
1235: PPUSH
1236: CALL_OW 69
1240: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
1241: LD_ADDR_VAR 0 9
1245: PUSH
1246: LD_INT 2
1248: PUSH
1249: LD_INT 30
1251: PUSH
1252: LD_INT 7
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 30
1261: PUSH
1262: LD_INT 6
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL_OW 69
1278: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
1279: LD_ADDR_VAR 0 10
1283: PUSH
1284: LD_INT 30
1286: PUSH
1287: LD_INT 3
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: PPUSH
1294: CALL_OW 69
1298: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1299: LD_ADDR_VAR 0 11
1303: PUSH
1304: LD_INT 2
1306: PUSH
1307: LD_INT 30
1309: PUSH
1310: LD_INT 32
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: PUSH
1317: LD_INT 30
1319: PUSH
1320: LD_INT 31
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: LIST
1331: PPUSH
1332: CALL_OW 69
1336: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
1337: LD_VAR 0 7
1341: PPUSH
1342: LD_STRING Gamma
1344: PPUSH
1345: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
1349: LD_VAR 0 7
1353: PPUSH
1354: CALL_OW 274
1358: PPUSH
1359: LD_INT 2
1361: PPUSH
1362: LD_INT 10000
1364: PPUSH
1365: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
1369: LD_VAR 0 7
1373: PPUSH
1374: CALL_OW 274
1378: PPUSH
1379: LD_INT 1
1381: PPUSH
1382: LD_INT 10000
1384: PPUSH
1385: CALL_OW 277
// if dep then
1389: LD_VAR 0 7
1393: IFFALSE 1493
// begin PlaceHumanInUnit ( JMM , dep [ 1 ] ) ;
1395: LD_EXP 7
1399: PPUSH
1400: LD_VAR 0 7
1404: PUSH
1405: LD_INT 1
1407: ARRAY
1408: PPUSH
1409: CALL_OW 52
// if Brown then
1413: LD_EXP 14
1417: IFFALSE 1453
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
1419: LD_EXP 14
1423: PPUSH
1424: LD_VAR 0 7
1428: PUSH
1429: LD_INT 1
1431: ARRAY
1432: PPUSH
1433: CALL_OW 52
// team := team diff Brown ;
1437: LD_ADDR_VAR 0 6
1441: PUSH
1442: LD_VAR 0 6
1446: PUSH
1447: LD_EXP 14
1451: DIFF
1452: ST_TO_ADDR
// end ; if Donaldson then
1453: LD_EXP 13
1457: IFFALSE 1493
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
1459: LD_EXP 13
1463: PPUSH
1464: LD_VAR 0 7
1468: PUSH
1469: LD_INT 1
1471: ARRAY
1472: PPUSH
1473: CALL_OW 52
// team := team diff Donaldson ;
1477: LD_ADDR_VAR 0 6
1481: PUSH
1482: LD_VAR 0 6
1486: PUSH
1487: LD_EXP 13
1491: DIFF
1492: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
1493: LD_VAR 0 11
1497: PUSH
1498: LD_VAR 0 6
1502: PPUSH
1503: LD_INT 25
1505: PUSH
1506: LD_INT 1
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PPUSH
1513: CALL_OW 72
1517: AND
1518: IFFALSE 1627
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1520: LD_ADDR_VAR 0 12
1524: PUSH
1525: LD_VAR 0 6
1529: PPUSH
1530: LD_INT 25
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: PPUSH
1540: CALL_OW 72
1544: ST_TO_ADDR
// for i in bun do
1545: LD_ADDR_VAR 0 13
1549: PUSH
1550: LD_VAR 0 11
1554: PUSH
1555: FOR_IN
1556: IFFALSE 1625
// begin if not filter then
1558: LD_VAR 0 12
1562: NOT
1563: IFFALSE 1567
// break ;
1565: GO 1625
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
1567: LD_VAR 0 12
1571: PUSH
1572: LD_INT 1
1574: ARRAY
1575: PPUSH
1576: LD_VAR 0 13
1580: PPUSH
1581: CALL_OW 52
// team := team diff filter [ 1 ] ;
1585: LD_ADDR_VAR 0 6
1589: PUSH
1590: LD_VAR 0 6
1594: PUSH
1595: LD_VAR 0 12
1599: PUSH
1600: LD_INT 1
1602: ARRAY
1603: DIFF
1604: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
1605: LD_ADDR_VAR 0 12
1609: PUSH
1610: LD_VAR 0 12
1614: PPUSH
1615: LD_INT 1
1617: PPUSH
1618: CALL_OW 3
1622: ST_TO_ADDR
// end ;
1623: GO 1555
1625: POP
1626: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1627: LD_VAR 0 8
1631: PUSH
1632: LD_VAR 0 6
1636: PPUSH
1637: LD_INT 25
1639: PUSH
1640: LD_INT 1
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PPUSH
1647: CALL_OW 72
1651: AND
1652: IFFALSE 1774
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1654: LD_ADDR_VAR 0 12
1658: PUSH
1659: LD_VAR 0 6
1663: PPUSH
1664: LD_INT 25
1666: PUSH
1667: LD_INT 1
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: PPUSH
1674: CALL_OW 72
1678: ST_TO_ADDR
// for i = 1 to filter do
1679: LD_ADDR_VAR 0 13
1683: PUSH
1684: DOUBLE
1685: LD_INT 1
1687: DEC
1688: ST_TO_ADDR
1689: LD_VAR 0 12
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1756
// begin if ( i <= 6 ) then
1697: LD_VAR 0 13
1701: PUSH
1702: LD_INT 6
1704: LESSEQUAL
1705: IFFALSE 1733
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1707: LD_VAR 0 12
1711: PUSH
1712: LD_VAR 0 13
1716: ARRAY
1717: PPUSH
1718: LD_VAR 0 8
1722: PUSH
1723: LD_INT 1
1725: ARRAY
1726: PPUSH
1727: CALL_OW 52
1731: GO 1754
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1733: LD_VAR 0 12
1737: PUSH
1738: LD_VAR 0 13
1742: ARRAY
1743: PPUSH
1744: LD_INT 1
1746: PPUSH
1747: LD_INT 0
1749: PPUSH
1750: CALL_OW 49
// end ;
1754: GO 1694
1756: POP
1757: POP
// team := team diff filter ;
1758: LD_ADDR_VAR 0 6
1762: PUSH
1763: LD_VAR 0 6
1767: PUSH
1768: LD_VAR 0 12
1772: DIFF
1773: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1774: LD_VAR 0 9
1778: PUSH
1779: LD_VAR 0 6
1783: PPUSH
1784: LD_INT 25
1786: PUSH
1787: LD_INT 4
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PPUSH
1794: CALL_OW 72
1798: AND
1799: IFFALSE 1921
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1801: LD_ADDR_VAR 0 12
1805: PUSH
1806: LD_VAR 0 6
1810: PPUSH
1811: LD_INT 25
1813: PUSH
1814: LD_INT 4
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: PPUSH
1821: CALL_OW 72
1825: ST_TO_ADDR
// for i = 1 to filter do
1826: LD_ADDR_VAR 0 13
1830: PUSH
1831: DOUBLE
1832: LD_INT 1
1834: DEC
1835: ST_TO_ADDR
1836: LD_VAR 0 12
1840: PUSH
1841: FOR_TO
1842: IFFALSE 1903
// begin if ( i <= 6 ) then
1844: LD_VAR 0 13
1848: PUSH
1849: LD_INT 6
1851: LESSEQUAL
1852: IFFALSE 1880
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1854: LD_VAR 0 12
1858: PUSH
1859: LD_VAR 0 13
1863: ARRAY
1864: PPUSH
1865: LD_VAR 0 9
1869: PUSH
1870: LD_INT 1
1872: ARRAY
1873: PPUSH
1874: CALL_OW 52
1878: GO 1901
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1880: LD_VAR 0 12
1884: PUSH
1885: LD_VAR 0 13
1889: ARRAY
1890: PPUSH
1891: LD_INT 1
1893: PPUSH
1894: LD_INT 0
1896: PPUSH
1897: CALL_OW 49
// end ;
1901: GO 1841
1903: POP
1904: POP
// team := team diff filter ;
1905: LD_ADDR_VAR 0 6
1909: PUSH
1910: LD_VAR 0 6
1914: PUSH
1915: LD_VAR 0 12
1919: DIFF
1920: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1921: LD_VAR 0 10
1925: PUSH
1926: LD_VAR 0 6
1930: PPUSH
1931: LD_INT 25
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: EMPTY
1938: LIST
1939: LIST
1940: PPUSH
1941: CALL_OW 72
1945: AND
1946: IFFALSE 2068
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1948: LD_ADDR_VAR 0 12
1952: PUSH
1953: LD_VAR 0 6
1957: PPUSH
1958: LD_INT 25
1960: PUSH
1961: LD_INT 3
1963: PUSH
1964: EMPTY
1965: LIST
1966: LIST
1967: PPUSH
1968: CALL_OW 72
1972: ST_TO_ADDR
// for i = 1 to filter do
1973: LD_ADDR_VAR 0 13
1977: PUSH
1978: DOUBLE
1979: LD_INT 1
1981: DEC
1982: ST_TO_ADDR
1983: LD_VAR 0 12
1987: PUSH
1988: FOR_TO
1989: IFFALSE 2050
// begin if ( i <= 6 ) then
1991: LD_VAR 0 13
1995: PUSH
1996: LD_INT 6
1998: LESSEQUAL
1999: IFFALSE 2027
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
2001: LD_VAR 0 12
2005: PUSH
2006: LD_VAR 0 13
2010: ARRAY
2011: PPUSH
2012: LD_VAR 0 10
2016: PUSH
2017: LD_INT 1
2019: ARRAY
2020: PPUSH
2021: CALL_OW 52
2025: GO 2048
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
2027: LD_VAR 0 12
2031: PUSH
2032: LD_VAR 0 13
2036: ARRAY
2037: PPUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 0
2043: PPUSH
2044: CALL_OW 49
// end ;
2048: GO 1988
2050: POP
2051: POP
// team := team diff filter ;
2052: LD_ADDR_VAR 0 6
2056: PUSH
2057: LD_VAR 0 6
2061: PUSH
2062: LD_VAR 0 12
2066: DIFF
2067: ST_TO_ADDR
// end ; if team then
2068: LD_VAR 0 6
2072: IFFALSE 2115
// for i in team do
2074: LD_ADDR_VAR 0 13
2078: PUSH
2079: LD_VAR 0 6
2083: PUSH
2084: FOR_IN
2085: IFFALSE 2113
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
2087: LD_VAR 0 13
2091: PPUSH
2092: LD_INT 1
2094: PPUSH
2095: LD_INT 0
2097: PPUSH
2098: CALL_OW 49
// ComHold ( i ) ;
2102: LD_VAR 0 13
2106: PPUSH
2107: CALL_OW 140
// end ;
2111: GO 2084
2113: POP
2114: POP
// if fac then
2115: LD_VAR 0 10
2119: IFFALSE 2155
// if UnitsInside ( fac [ 1 ] ) then
2121: LD_VAR 0 10
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PPUSH
2130: CALL_OW 313
2134: IFFALSE 2155
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
2136: LD_VAR 0 10
2140: PUSH
2141: LD_INT 1
2143: ARRAY
2144: PPUSH
2145: LD_INT 10
2147: PPUSH
2148: LD_INT 0
2150: PPUSH
2151: CALL_OW 486
// if lab then
2155: LD_VAR 0 9
2159: IFFALSE 2195
// if UnitsInside ( lab [ 1 ] ) then
2161: LD_VAR 0 9
2165: PUSH
2166: LD_INT 1
2168: ARRAY
2169: PPUSH
2170: CALL_OW 313
2174: IFFALSE 2195
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
2176: LD_VAR 0 9
2180: PUSH
2181: LD_INT 1
2183: ARRAY
2184: PPUSH
2185: LD_INT 10
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 486
// uc_side := 4 ;
2195: LD_ADDR_OWVAR 20
2199: PUSH
2200: LD_INT 4
2202: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ,  ) ;
2203: LD_ADDR_EXP 17
2207: PUSH
2208: LD_STRING Harisson
2210: PPUSH
2211: LD_INT 0
2213: PPUSH
2214: LD_STRING 
2216: PPUSH
2217: CALL 3888 0 3
2221: ST_TO_ADDR
// veh := PrepareTank ( 4 , 1 , us_light_wheeled , engine_combustion , control_manual , us_machine_gun , 100 ) ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_INT 4
2229: PPUSH
2230: LD_INT 1
2232: PPUSH
2233: LD_INT 1
2235: PPUSH
2236: LD_INT 1
2238: PPUSH
2239: LD_INT 1
2241: PPUSH
2242: LD_INT 2
2244: PPUSH
2245: LD_INT 100
2247: PPUSH
2248: CALL 3951 0 7
2252: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2253: LD_VAR 0 5
2257: PPUSH
2258: LD_INT 2
2260: PPUSH
2261: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
2265: LD_VAR 0 5
2269: PPUSH
2270: LD_INT 21
2272: PPUSH
2273: LD_INT 8
2275: PPUSH
2276: LD_INT 0
2278: PPUSH
2279: CALL_OW 48
// PlaceHumanInUnit ( Harisson , veh ) ;
2283: LD_EXP 17
2287: PPUSH
2288: LD_VAR 0 5
2292: PPUSH
2293: CALL_OW 52
// end ;
2297: LD_VAR 0 1
2301: RET
// function PrepareBase ; var blist , i , b ; begin
2302: LD_INT 0
2304: PPUSH
2305: PPUSH
2306: PPUSH
2307: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2308: LD_INT 71
2310: PPUSH
2311: LD_INT 5
2313: PPUSH
2314: LD_INT 1
2316: PPUSH
2317: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_STRING GammaBase
2328: PPUSH
2329: EMPTY
2330: PPUSH
2331: CALL_OW 30
2335: ST_TO_ADDR
// if not blist and debug then
2336: LD_VAR 0 2
2340: NOT
2341: PUSH
2342: LD_EXP 1
2346: AND
2347: IFFALSE 2387
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
2349: LD_ADDR_VAR 0 2
2353: PUSH
2354: LD_INT 0
2356: PUSH
2357: LD_INT 51
2359: PUSH
2360: LD_INT 10
2362: PUSH
2363: LD_INT 3
2365: PUSH
2366: LD_INT 3
2368: PUSH
2369: LD_INT 0
2371: PUSH
2372: LD_INT 0
2374: PUSH
2375: EMPTY
2376: LIST
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: LIST
2382: LIST
2383: PUSH
2384: EMPTY
2385: LIST
2386: ST_TO_ADDR
// if not blist then
2387: LD_VAR 0 2
2391: NOT
2392: IFFALSE 2396
// exit ;
2394: GO 2576
// uc_side := 1 ;
2396: LD_ADDR_OWVAR 20
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// uc_nation := 1 ;
2404: LD_ADDR_OWVAR 21
2408: PUSH
2409: LD_INT 1
2411: ST_TO_ADDR
// for i in blist do
2412: LD_ADDR_VAR 0 3
2416: PUSH
2417: LD_VAR 0 2
2421: PUSH
2422: FOR_IN
2423: IFFALSE 2574
// begin bc_type := i [ 1 ] ;
2425: LD_ADDR_OWVAR 42
2429: PUSH
2430: LD_VAR 0 3
2434: PUSH
2435: LD_INT 1
2437: ARRAY
2438: ST_TO_ADDR
// bc_level := i [ 5 ] ;
2439: LD_ADDR_OWVAR 43
2443: PUSH
2444: LD_VAR 0 3
2448: PUSH
2449: LD_INT 5
2451: ARRAY
2452: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
2453: LD_VAR 0 3
2457: PUSH
2458: LD_INT 1
2460: ARRAY
2461: PUSH
2462: LD_INT 7
2464: PUSH
2465: LD_INT 8
2467: PUSH
2468: EMPTY
2469: LIST
2470: LIST
2471: IN
2472: IFFALSE 2502
// begin bc_kind1 := i [ 7 ] ;
2474: LD_ADDR_OWVAR 44
2478: PUSH
2479: LD_VAR 0 3
2483: PUSH
2484: LD_INT 7
2486: ARRAY
2487: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
2488: LD_ADDR_OWVAR 45
2492: PUSH
2493: LD_VAR 0 3
2497: PUSH
2498: LD_INT 8
2500: ARRAY
2501: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2502: LD_ADDR_VAR 0 4
2506: PUSH
2507: LD_VAR 0 3
2511: PUSH
2512: LD_INT 2
2514: ARRAY
2515: PPUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_INT 3
2523: ARRAY
2524: PPUSH
2525: LD_VAR 0 3
2529: PUSH
2530: LD_INT 4
2532: ARRAY
2533: PPUSH
2534: CALL_OW 47
2538: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2539: LD_VAR 0 4
2543: PPUSH
2544: CALL_OW 266
2548: PUSH
2549: LD_INT 32
2551: EQUAL
2552: IFFALSE 2572
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2554: LD_VAR 0 4
2558: PPUSH
2559: LD_VAR 0 3
2563: PUSH
2564: LD_INT 7
2566: ARRAY
2567: PPUSH
2568: CALL_OW 431
// end ; end ;
2572: GO 2422
2574: POP
2575: POP
// end ; end_of_file
2576: LD_VAR 0 1
2580: RET
// export function Action ; var points , i , sol , team , filter ; begin
2581: LD_INT 0
2583: PPUSH
2584: PPUSH
2585: PPUSH
2586: PPUSH
2587: PPUSH
2588: PPUSH
// InGameOn ;
2589: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2593: LD_INT 33
2595: PPUSH
2596: LD_INT 11
2598: PPUSH
2599: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2603: LD_ADDR_VAR 0 2
2607: PUSH
2608: LD_INT 29
2610: PUSH
2611: LD_INT 21
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: LD_INT 41
2620: PUSH
2621: LD_INT 28
2623: PUSH
2624: EMPTY
2625: LIST
2626: LIST
2627: PUSH
2628: LD_INT 52
2630: PUSH
2631: LD_INT 26
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 49
2640: PUSH
2641: LD_INT 16
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: ST_TO_ADDR
// sol := ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , 1 ] ] ) diff [ JMM , Brown , Cyrus , Bobby , Gladstone , Houten , Khatam ] ) [ 1 ] ;
2654: LD_ADDR_VAR 0 4
2658: PUSH
2659: LD_INT 22
2661: PUSH
2662: LD_INT 1
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: PUSH
2669: LD_INT 26
2671: PUSH
2672: LD_INT 1
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: PUSH
2679: EMPTY
2680: LIST
2681: LIST
2682: PPUSH
2683: CALL_OW 69
2687: PUSH
2688: LD_EXP 7
2692: PUSH
2693: LD_EXP 14
2697: PUSH
2698: LD_EXP 11
2702: PUSH
2703: LD_EXP 12
2707: PUSH
2708: LD_EXP 8
2712: PUSH
2713: LD_EXP 15
2717: PUSH
2718: LD_EXP 16
2722: PUSH
2723: EMPTY
2724: LIST
2725: LIST
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: DIFF
2732: PUSH
2733: LD_INT 1
2735: ARRAY
2736: ST_TO_ADDR
// if sol then
2737: LD_VAR 0 4
2741: IFFALSE 2772
// begin ComMoveXY ( sol , 50 , 18 ) ;
2743: LD_VAR 0 4
2747: PPUSH
2748: LD_INT 50
2750: PPUSH
2751: LD_INT 18
2753: PPUSH
2754: CALL_OW 111
// AddComTurnUnit ( sol , Harisson ) ;
2758: LD_VAR 0 4
2762: PPUSH
2763: LD_EXP 17
2767: PPUSH
2768: CALL_OW 179
// end ; for i in points do
2772: LD_ADDR_VAR 0 3
2776: PUSH
2777: LD_VAR 0 2
2781: PUSH
2782: FOR_IN
2783: IFFALSE 2814
// AddComMoveXY ( Harisson , i [ 1 ] , i [ 2 ] ) ;
2785: LD_EXP 17
2789: PPUSH
2790: LD_VAR 0 3
2794: PUSH
2795: LD_INT 1
2797: ARRAY
2798: PPUSH
2799: LD_VAR 0 3
2803: PUSH
2804: LD_INT 2
2806: ARRAY
2807: PPUSH
2808: CALL_OW 171
2812: GO 2782
2814: POP
2815: POP
// AddComExitVehicle ( Harisson ) ;
2816: LD_EXP 17
2820: PPUSH
2821: CALL_OW 181
// repeat wait ( 3 ) ;
2825: LD_INT 3
2827: PPUSH
2828: CALL_OW 67
// until not IsInUnit ( Harisson ) ;
2832: LD_EXP 17
2836: PPUSH
2837: CALL_OW 310
2841: NOT
2842: IFFALSE 2825
// Say ( sol , D1-Sol1-1 ) ;
2844: LD_VAR 0 4
2848: PPUSH
2849: LD_STRING D1-Sol1-1
2851: PPUSH
2852: CALL_OW 88
// ComTurnUnit ( Harisson , sol ) ;
2856: LD_EXP 17
2860: PPUSH
2861: LD_VAR 0 4
2865: PPUSH
2866: CALL_OW 119
// Say ( Harisson , D1-Har-1 ) ;
2870: LD_EXP 17
2874: PPUSH
2875: LD_STRING D1-Har-1
2877: PPUSH
2878: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2882: LD_INT 10
2884: PPUSH
2885: CALL_OW 67
// ComMoveXY ( sol , 35 , 21 ) ;
2889: LD_VAR 0 4
2893: PPUSH
2894: LD_INT 35
2896: PPUSH
2897: LD_INT 21
2899: PPUSH
2900: CALL_OW 111
// ComExitBuilding ( JMM ) ;
2904: LD_EXP 7
2908: PPUSH
2909: CALL_OW 122
// AddComMoveUnit ( JMM , Harisson ) ;
2913: LD_EXP 7
2917: PPUSH
2918: LD_EXP 17
2922: PPUSH
2923: CALL_OW 172
// ComTurnUnit ( Harisson , JMM ) ;
2927: LD_EXP 17
2931: PPUSH
2932: LD_EXP 7
2936: PPUSH
2937: CALL_OW 119
// repeat wait ( 3 ) ;
2941: LD_INT 3
2943: PPUSH
2944: CALL_OW 67
// until GetDistUnits ( JMM , Harisson ) < 4 ;
2948: LD_EXP 7
2952: PPUSH
2953: LD_EXP 17
2957: PPUSH
2958: CALL_OW 296
2962: PUSH
2963: LD_INT 4
2965: LESS
2966: IFFALSE 2941
// ComTurnUnit ( JMM , Harisson ) ;
2968: LD_EXP 7
2972: PPUSH
2973: LD_EXP 17
2977: PPUSH
2978: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
2982: LD_EXP 7
2986: PPUSH
2987: LD_STRING D1-JMM-1
2989: PPUSH
2990: CALL_OW 88
// Say ( Harisson , D1-Har-2 ) ;
2994: LD_EXP 17
2998: PPUSH
2999: LD_STRING D1-Har-2
3001: PPUSH
3002: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
3006: LD_EXP 7
3010: PPUSH
3011: LD_STRING D1-JMM-2
3013: PPUSH
3014: CALL_OW 88
// Say ( Harisson , D1-Har-3 ) ;
3018: LD_EXP 17
3022: PPUSH
3023: LD_STRING D1-Har-3
3025: PPUSH
3026: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
3030: LD_EXP 7
3034: PPUSH
3035: LD_STRING D1-JMM-3
3037: PPUSH
3038: CALL_OW 88
// Say ( Harisson , D1-Har-4 ) ;
3042: LD_EXP 17
3046: PPUSH
3047: LD_STRING D1-Har-4
3049: PPUSH
3050: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
3054: LD_EXP 7
3058: PPUSH
3059: LD_STRING D1-JMM-4
3061: PPUSH
3062: CALL_OW 88
// Say ( Harisson , D1-Har-5 ) ;
3066: LD_EXP 17
3070: PPUSH
3071: LD_STRING D1-Har-5
3073: PPUSH
3074: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3078: LD_EXP 7
3082: PPUSH
3083: LD_STRING D1-JMM-5
3085: PPUSH
3086: CALL_OW 88
// Say ( Harisson , D1-Har-6 ) ;
3090: LD_EXP 17
3094: PPUSH
3095: LD_STRING D1-Har-6
3097: PPUSH
3098: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3102: LD_EXP 7
3106: PPUSH
3107: LD_STRING D1-JMM-6
3109: PPUSH
3110: CALL_OW 88
// EndMission ;
3114: CALL 3123 0 0
// end ;
3118: LD_VAR 0 1
3122: RET
// export function EndMission ; var commander , i , all ; begin
3123: LD_INT 0
3125: PPUSH
3126: PPUSH
3127: PPUSH
3128: PPUSH
// case gamma_commander of 1 :
3129: LD_EXP 18
3133: PUSH
3134: LD_INT 1
3136: DOUBLE
3137: EQUAL
3138: IFTRUE 3142
3140: GO 3155
3142: POP
// commander := Donaldson ; 2 :
3143: LD_ADDR_VAR 0 2
3147: PUSH
3148: LD_EXP 13
3152: ST_TO_ADDR
3153: GO 3198
3155: LD_INT 2
3157: DOUBLE
3158: EQUAL
3159: IFTRUE 3163
3161: GO 3176
3163: POP
// commander := Brown ; 3 :
3164: LD_ADDR_VAR 0 2
3168: PUSH
3169: LD_EXP 14
3173: ST_TO_ADDR
3174: GO 3198
3176: LD_INT 3
3178: DOUBLE
3179: EQUAL
3180: IFTRUE 3184
3182: GO 3197
3184: POP
// commander := Houten ; end ;
3185: LD_ADDR_VAR 0 2
3189: PUSH
3190: LD_EXP 15
3194: ST_TO_ADDR
3195: GO 3198
3197: POP
// all := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , commander ] ;
3198: LD_ADDR_VAR 0 4
3202: PUSH
3203: LD_INT 22
3205: PUSH
3206: LD_INT 1
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 21
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PPUSH
3227: CALL_OW 69
3231: PUSH
3232: LD_EXP 7
3236: PUSH
3237: LD_VAR 0 2
3241: PUSH
3242: EMPTY
3243: LIST
3244: LIST
3245: DIFF
3246: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 10 , 10 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , [ commander , Harisson ] ] , [ [ class_soldier , 3 ] , [ class_mechanic , 3 , 6 ] , [ class_scientistic , 1 ] ] ) ;
3247: LD_ADDR_EXP 4
3251: PUSH
3252: LD_STRING 1
3254: PPUSH
3255: LD_INT 10
3257: PPUSH
3258: LD_INT 10
3260: PPUSH
3261: LD_INT -5
3263: PUSH
3264: LD_EXP 7
3268: PUSH
3269: LD_INT -2
3271: PUSH
3272: LD_INT -3
3274: PUSH
3275: LD_INT -5
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: PUSH
3285: LD_VAR 0 4
3289: ADD
3290: PUSH
3291: LD_INT -6
3293: PUSH
3294: LD_INT -4
3296: PUSH
3297: LD_VAR 0 2
3301: PUSH
3302: LD_EXP 17
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: ADD
3316: PPUSH
3317: LD_INT 1
3319: PUSH
3320: LD_INT 3
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 3
3329: PUSH
3330: LD_INT 3
3332: PUSH
3333: LD_INT 6
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: LIST
3340: PUSH
3341: LD_INT 4
3343: PUSH
3344: LD_INT 1
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: LIST
3355: PPUSH
3356: CALL_OW 42
3360: ST_TO_ADDR
// SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam ] ^ save_group , 07_othersGamma ) ;
3361: LD_VAR 0 4
3365: PUSH
3366: LD_EXP 7
3370: PUSH
3371: LD_EXP 8
3375: PUSH
3376: LD_EXP 10
3380: PUSH
3381: LD_EXP 11
3385: PUSH
3386: LD_EXP 12
3390: PUSH
3391: LD_EXP 9
3395: PUSH
3396: LD_EXP 13
3400: PUSH
3401: LD_EXP 14
3405: PUSH
3406: LD_EXP 15
3410: PUSH
3411: LD_EXP 17
3415: PUSH
3416: LD_EXP 16
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: LD_EXP 4
3438: ADD
3439: DIFF
3440: PPUSH
3441: LD_STRING 07_othersGamma
3443: PPUSH
3444: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , Houten , Harisson , Khatam , 0 ] , 07_others ) ;
3448: LD_EXP 4
3452: PUSH
3453: LD_EXP 7
3457: PUSH
3458: LD_EXP 8
3462: PUSH
3463: LD_EXP 10
3467: PUSH
3468: LD_EXP 11
3472: PUSH
3473: LD_EXP 12
3477: PUSH
3478: LD_EXP 9
3482: PUSH
3483: LD_EXP 13
3487: PUSH
3488: LD_EXP 14
3492: PUSH
3493: LD_EXP 15
3497: PUSH
3498: LD_EXP 17
3502: PUSH
3503: LD_EXP 16
3507: PUSH
3508: LD_INT 0
3510: PUSH
3511: EMPTY
3512: LIST
3513: LIST
3514: LIST
3515: LIST
3516: LIST
3517: LIST
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: LIST
3523: LIST
3524: DIFF
3525: PPUSH
3526: LD_STRING 07_others
3528: PPUSH
3529: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3533: LD_EXP 7
3537: PPUSH
3538: LD_EXP 5
3542: PUSH
3543: LD_STRING JMM
3545: STR
3546: PPUSH
3547: CALL_OW 38
// if Lisa then
3551: LD_EXP 10
3555: IFFALSE 3597
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3557: LD_EXP 10
3561: PPUSH
3562: LD_EXP 5
3566: PUSH
3567: LD_STRING Lisa
3569: STR
3570: PPUSH
3571: CALL_OW 38
// if Lisa in save_group then
3575: LD_EXP 10
3579: PUSH
3580: LD_EXP 4
3584: IN
3585: IFFALSE 3597
// SaveVariable ( true , LisaIn07 ) ;
3587: LD_INT 1
3589: PPUSH
3590: LD_STRING LisaIn07
3592: PPUSH
3593: CALL_OW 39
// end ; if Bobby then
3597: LD_EXP 12
3601: IFFALSE 3643
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3603: LD_EXP 12
3607: PPUSH
3608: LD_EXP 5
3612: PUSH
3613: LD_STRING Bobby
3615: STR
3616: PPUSH
3617: CALL_OW 38
// if Bobby in save_group then
3621: LD_EXP 12
3625: PUSH
3626: LD_EXP 4
3630: IN
3631: IFFALSE 3643
// SaveVariable ( true , BobbyIn07 ) ;
3633: LD_INT 1
3635: PPUSH
3636: LD_STRING BobbyIn07
3638: PPUSH
3639: CALL_OW 39
// end ; if Cyrus then
3643: LD_EXP 11
3647: IFFALSE 3689
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3649: LD_EXP 11
3653: PPUSH
3654: LD_EXP 5
3658: PUSH
3659: LD_STRING Cyrus
3661: STR
3662: PPUSH
3663: CALL_OW 38
// if Cyrus in save_group then
3667: LD_EXP 11
3671: PUSH
3672: LD_EXP 4
3676: IN
3677: IFFALSE 3689
// SaveVariable ( true , CyrusIn07 ) ;
3679: LD_INT 1
3681: PPUSH
3682: LD_STRING CyrusIn07
3684: PPUSH
3685: CALL_OW 39
// end ; if Brown then
3689: LD_EXP 14
3693: IFFALSE 3735
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
3695: LD_EXP 14
3699: PPUSH
3700: LD_EXP 5
3704: PUSH
3705: LD_STRING Brown
3707: STR
3708: PPUSH
3709: CALL_OW 38
// if Brown in save_group then
3713: LD_EXP 14
3717: PUSH
3718: LD_EXP 4
3722: IN
3723: IFFALSE 3735
// SaveVariable ( true , BrownIn07 ) ;
3725: LD_INT 1
3727: PPUSH
3728: LD_STRING BrownIn07
3730: PPUSH
3731: CALL_OW 39
// end ; if Donaldson then
3735: LD_EXP 13
3739: IFFALSE 3781
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
3741: LD_EXP 13
3745: PPUSH
3746: LD_EXP 5
3750: PUSH
3751: LD_STRING Donaldson
3753: STR
3754: PPUSH
3755: CALL_OW 38
// if Donaldson in save_group then
3759: LD_EXP 13
3763: PUSH
3764: LD_EXP 4
3768: IN
3769: IFFALSE 3781
// SaveVariable ( true , DonaldsonIn07 ) ;
3771: LD_INT 1
3773: PPUSH
3774: LD_STRING DonaldsonIn07
3776: PPUSH
3777: CALL_OW 39
// end ; if Gladstone then
3781: LD_EXP 8
3785: IFFALSE 3827
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
3787: LD_EXP 8
3791: PPUSH
3792: LD_EXP 5
3796: PUSH
3797: LD_STRING Gladstone
3799: STR
3800: PPUSH
3801: CALL_OW 38
// if Gladstone in save_group then
3805: LD_EXP 8
3809: PUSH
3810: LD_EXP 4
3814: IN
3815: IFFALSE 3827
// SaveVariable ( true , GladstoneIn07 ) ;
3817: LD_INT 1
3819: PPUSH
3820: LD_STRING GladstoneIn07
3822: PPUSH
3823: CALL_OW 39
// end ; if Khatam then
3827: LD_EXP 16
3831: IFFALSE 3873
// begin SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
3833: LD_EXP 16
3837: PPUSH
3838: LD_EXP 5
3842: PUSH
3843: LD_STRING Khatam
3845: STR
3846: PPUSH
3847: CALL_OW 38
// if Khatam in save_group then
3851: LD_EXP 16
3855: PUSH
3856: LD_EXP 4
3860: IN
3861: IFFALSE 3873
// SaveVariable ( true , KhatamIn07 ) ;
3863: LD_INT 1
3865: PPUSH
3866: LD_STRING KhatamIn07
3868: PPUSH
3869: CALL_OW 39
// end ; ChangeMap ( 1 , %_cont ) ;
3873: LD_INT 1
3875: PPUSH
3876: LD_STRING %_cont
3878: PPUSH
3879: CALL_OW 340
// end ; end_of_file
3883: LD_VAR 0 1
3887: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
3888: LD_INT 0
3890: PPUSH
3891: PPUSH
// if exist_mode then
3892: LD_VAR 0 2
3896: IFFALSE 3921
// unit := CreateCharacter ( prefix & ident ) else
3898: LD_ADDR_VAR 0 5
3902: PUSH
3903: LD_VAR 0 3
3907: PUSH
3908: LD_VAR 0 1
3912: STR
3913: PPUSH
3914: CALL_OW 34
3918: ST_TO_ADDR
3919: GO 3936
// unit := NewCharacter ( ident ) ;
3921: LD_ADDR_VAR 0 5
3925: PUSH
3926: LD_VAR 0 1
3930: PPUSH
3931: CALL_OW 25
3935: ST_TO_ADDR
// result := unit ;
3936: LD_ADDR_VAR 0 4
3940: PUSH
3941: LD_VAR 0 5
3945: ST_TO_ADDR
// end ;
3946: LD_VAR 0 4
3950: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
3951: LD_INT 0
3953: PPUSH
// uc_side := side ;
3954: LD_ADDR_OWVAR 20
3958: PUSH
3959: LD_VAR 0 1
3963: ST_TO_ADDR
// uc_nation := nation ;
3964: LD_ADDR_OWVAR 21
3968: PUSH
3969: LD_VAR 0 2
3973: ST_TO_ADDR
// vc_chassis := chassis ;
3974: LD_ADDR_OWVAR 37
3978: PUSH
3979: LD_VAR 0 3
3983: ST_TO_ADDR
// vc_engine := engine ;
3984: LD_ADDR_OWVAR 39
3988: PUSH
3989: LD_VAR 0 4
3993: ST_TO_ADDR
// vc_control := control ;
3994: LD_ADDR_OWVAR 38
3998: PUSH
3999: LD_VAR 0 5
4003: ST_TO_ADDR
// vc_weapon := weapon ;
4004: LD_ADDR_OWVAR 40
4008: PUSH
4009: LD_VAR 0 6
4013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4014: LD_ADDR_OWVAR 41
4018: PUSH
4019: LD_VAR 0 7
4023: ST_TO_ADDR
// result := CreateVehicle ;
4024: LD_ADDR_VAR 0 8
4028: PUSH
4029: CALL_OW 45
4033: ST_TO_ADDR
// end ;
4034: LD_VAR 0 8
4038: RET
// export function SayX ( units , ident ) ; var i ; begin
4039: LD_INT 0
4041: PPUSH
4042: PPUSH
// result := false ;
4043: LD_ADDR_VAR 0 3
4047: PUSH
4048: LD_INT 0
4050: ST_TO_ADDR
// if not units then
4051: LD_VAR 0 1
4055: NOT
4056: IFFALSE 4060
// exit ;
4058: GO 4114
// for i in units do
4060: LD_ADDR_VAR 0 4
4064: PUSH
4065: LD_VAR 0 1
4069: PUSH
4070: FOR_IN
4071: IFFALSE 4112
// if IsOk ( i ) then
4073: LD_VAR 0 4
4077: PPUSH
4078: CALL_OW 302
4082: IFFALSE 4110
// begin Say ( i , ident ) ;
4084: LD_VAR 0 4
4088: PPUSH
4089: LD_VAR 0 2
4093: PPUSH
4094: CALL_OW 88
// result := i ;
4098: LD_ADDR_VAR 0 3
4102: PUSH
4103: LD_VAR 0 4
4107: ST_TO_ADDR
// break ;
4108: GO 4112
// end ;
4110: GO 4070
4112: POP
4113: POP
// end ;
4114: LD_VAR 0 3
4118: RET
