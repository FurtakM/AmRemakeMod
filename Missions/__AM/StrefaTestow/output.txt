// export destroyedBuildings ; export cargoTest ; export arabianMines ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// cargoTest = [ ] ;
  22: LD_ADDR_EXP 2
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// arabianMines = [ ] ;
  29: LD_ADDR_EXP 3
  33: PUSH
  34: EMPTY
  35: ST_TO_ADDR
// PlaceMines ( MineField1 , 10 ) ;
  36: LD_INT 5
  38: PPUSH
  39: LD_INT 10
  41: PPUSH
  42: CALL 5371 0 2
// end ;
  46: END
// every 0 0$01 do var b ;
  47: GO 49
  49: DISABLE
  50: LD_INT 0
  52: PPUSH
// begin end ;
  53: PPOPN 1
  55: END
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
  56: LD_INT 0
  58: PPUSH
  59: PPUSH
  60: PPUSH
  61: PPUSH
// for i = 1 to 3 do
  62: LD_ADDR_VAR 0 5
  66: PUSH
  67: DOUBLE
  68: LD_INT 1
  70: DEC
  71: ST_TO_ADDR
  72: LD_INT 3
  74: PUSH
  75: FOR_TO
  76: IFFALSE 106
// amount := amount + GetResourceArea ( area , i ) ;
  78: LD_ADDR_VAR 0 4
  82: PUSH
  83: LD_VAR 0 4
  87: PUSH
  88: LD_VAR 0 1
  92: PPUSH
  93: LD_VAR 0 5
  97: PPUSH
  98: CALL_OW 287
 102: PLUS
 103: ST_TO_ADDR
 104: GO 75
 106: POP
 107: POP
// if amount < materials then
 108: LD_VAR 0 4
 112: PUSH
 113: LD_VAR 0 2
 117: LESS
 118: IFFALSE 122
// exit ;
 120: GO 156
// for i = 1 to 3 do
 122: LD_ADDR_VAR 0 5
 126: PUSH
 127: DOUBLE
 128: LD_INT 1
 130: DEC
 131: ST_TO_ADDR
 132: LD_INT 3
 134: PUSH
 135: FOR_TO
 136: IFFALSE 154
// EraseResourceArea ( area , i ) ;
 138: LD_VAR 0 1
 142: PPUSH
 143: LD_VAR 0 5
 147: PPUSH
 148: CALL_OW 286
 152: GO 135
 154: POP
 155: POP
// end ;
 156: LD_VAR 0 3
 160: RET
// every 0 0$1 do
 161: GO 163
 163: DISABLE
// begin display_strings = [ arabianMines ] ;
 164: LD_ADDR_OWVAR 47
 168: PUSH
 169: LD_EXP 3
 173: PUSH
 174: EMPTY
 175: LIST
 176: ST_TO_ADDR
// end ; end_of_file
 177: END
// every 0 0$1 do
 178: GO 180
 180: DISABLE
// begin enable ;
 181: ENABLE
// RepairBuilding ( 3 , rudepot ) ;
 182: LD_INT 3
 184: PPUSH
 185: LD_INT 21
 187: PPUSH
 188: CALL 4393 0 2
// HealUnitInBase ( 3 , RuHealArea , RussianBase , rulab ) ;
 192: LD_INT 3
 194: PPUSH
 195: LD_INT 4
 197: PPUSH
 198: LD_INT 3
 200: PPUSH
 201: LD_INT 118
 203: PPUSH
 204: CALL 4681 0 4
// end ;
 208: END
// every 5 5$1 do
 209: GO 211
 211: DISABLE
// begin end ;
 212: END
// every 0 0$01 trigger arabianMines do var i , p ;
 213: LD_EXP 3
 217: IFFALSE 427
 219: GO 221
 221: DISABLE
 222: LD_INT 0
 224: PPUSH
 225: PPUSH
// begin enable ;
 226: ENABLE
// p := 1 ;
 227: LD_ADDR_VAR 0 2
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 235: LD_ADDR_VAR 0 1
 239: PUSH
 240: DOUBLE
 241: LD_INT 1
 243: DEC
 244: ST_TO_ADDR
 245: LD_EXP 3
 249: PUSH
 250: LD_INT 2
 252: DIVREAL
 253: PUSH
 254: FOR_TO
 255: IFFALSE 425
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 257: LD_INT 81
 259: PUSH
 260: LD_INT 2
 262: PUSH
 263: EMPTY
 264: LIST
 265: LIST
 266: PUSH
 267: LD_INT 92
 269: PUSH
 270: LD_EXP 3
 274: PUSH
 275: LD_VAR 0 2
 279: ARRAY
 280: PUSH
 281: LD_EXP 3
 285: PUSH
 286: LD_VAR 0 2
 290: PUSH
 291: LD_INT 1
 293: PLUS
 294: ARRAY
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: EMPTY
 306: LIST
 307: LIST
 308: PPUSH
 309: CALL_OW 69
 313: IFFALSE 409
// begin wait ( 0 0$0.5 ) ;
 315: LD_INT 18
 317: PPUSH
 318: CALL_OW 67
// LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 322: LD_EXP 3
 326: PUSH
 327: LD_VAR 0 2
 331: ARRAY
 332: PPUSH
 333: LD_EXP 3
 337: PUSH
 338: LD_VAR 0 2
 342: PUSH
 343: LD_INT 1
 345: PLUS
 346: ARRAY
 347: PPUSH
 348: LD_INT 2
 350: PPUSH
 351: CALL_OW 456
// arabianMines := Delete ( arabianMines , p ) ;
 355: LD_ADDR_EXP 3
 359: PUSH
 360: LD_EXP 3
 364: PPUSH
 365: LD_VAR 0 2
 369: PPUSH
 370: CALL_OW 3
 374: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 375: LD_ADDR_EXP 3
 379: PUSH
 380: LD_EXP 3
 384: PPUSH
 385: LD_VAR 0 2
 389: PPUSH
 390: CALL_OW 3
 394: ST_TO_ADDR
// p := p - 2 ;
 395: LD_ADDR_VAR 0 2
 399: PUSH
 400: LD_VAR 0 2
 404: PUSH
 405: LD_INT 2
 407: MINUS
 408: ST_TO_ADDR
// end ; p := p + 2 ;
 409: LD_ADDR_VAR 0 2
 413: PUSH
 414: LD_VAR 0 2
 418: PUSH
 419: LD_INT 2
 421: PLUS
 422: ST_TO_ADDR
// end ;
 423: GO 254
 425: POP
 426: POP
// end ; end_of_file
 427: PPOPN 2
 429: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 430: LD_INT 0
 432: PPUSH
 433: PPUSH
 434: PPUSH
// rnd = rand ( 1 , characters ) ;
 435: LD_ADDR_VAR 0 6
 439: PUSH
 440: LD_INT 1
 442: PPUSH
 443: LD_VAR 0 1
 447: PPUSH
 448: CALL_OW 12
 452: ST_TO_ADDR
// for i = 1 to characters do
 453: LD_ADDR_VAR 0 5
 457: PUSH
 458: DOUBLE
 459: LD_INT 1
 461: DEC
 462: ST_TO_ADDR
 463: LD_VAR 0 1
 467: PUSH
 468: FOR_TO
 469: IFFALSE 579
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 471: LD_VAR 0 5
 475: PUSH
 476: LD_VAR 0 6
 480: EQUAL
 481: PUSH
 482: LD_VAR 0 1
 486: PUSH
 487: LD_VAR 0 5
 491: ARRAY
 492: PPUSH
 493: CALL_OW 258
 497: PUSH
 498: LD_INT 1
 500: EQUAL
 501: AND
 502: IFFALSE 524
// Say ( characters [ i ] , dialogMID ) ;
 504: LD_VAR 0 1
 508: PUSH
 509: LD_VAR 0 5
 513: ARRAY
 514: PPUSH
 515: LD_VAR 0 2
 519: PPUSH
 520: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 524: LD_VAR 0 5
 528: PUSH
 529: LD_VAR 0 6
 533: EQUAL
 534: PUSH
 535: LD_VAR 0 1
 539: PUSH
 540: LD_VAR 0 5
 544: ARRAY
 545: PPUSH
 546: CALL_OW 258
 550: PUSH
 551: LD_INT 2
 553: EQUAL
 554: AND
 555: IFFALSE 577
// Say ( characters [ i ] , dialogFID ) ;
 557: LD_VAR 0 1
 561: PUSH
 562: LD_VAR 0 5
 566: ARRAY
 567: PPUSH
 568: LD_VAR 0 3
 572: PPUSH
 573: CALL_OW 88
// end ;
 577: GO 468
 579: POP
 580: POP
// end ;
 581: LD_VAR 0 4
 585: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 586: LD_INT 0
 588: PPUSH
 589: PPUSH
 590: PPUSH
 591: PPUSH
// for i = 1 to count do
 592: LD_ADDR_VAR 0 8
 596: PUSH
 597: DOUBLE
 598: LD_INT 1
 600: DEC
 601: ST_TO_ADDR
 602: LD_VAR 0 6
 606: PUSH
 607: FOR_TO
 608: IFFALSE 689
// begin uc_side = side ;
 610: LD_ADDR_OWVAR 20
 614: PUSH
 615: LD_VAR 0 1
 619: ST_TO_ADDR
// uc_nation = nation ;
 620: LD_ADDR_OWVAR 21
 624: PUSH
 625: LD_VAR 0 2
 629: ST_TO_ADDR
// hc_gallery =  ;
 630: LD_ADDR_OWVAR 33
 634: PUSH
 635: LD_STRING 
 637: ST_TO_ADDR
// hc_name =  ;
 638: LD_ADDR_OWVAR 26
 642: PUSH
 643: LD_STRING 
 645: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 646: LD_INT 0
 648: PPUSH
 649: LD_VAR 0 5
 653: PPUSH
 654: LD_VAR 0 4
 658: PPUSH
 659: CALL_OW 380
// un = CreateHuman ;
 663: LD_ADDR_VAR 0 10
 667: PUSH
 668: CALL_OW 44
 672: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 673: LD_VAR 0 10
 677: PPUSH
 678: LD_VAR 0 3
 682: PPUSH
 683: CALL_OW 52
// end ;
 687: GO 607
 689: POP
 690: POP
// end ;
 691: LD_VAR 0 7
 695: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 696: LD_INT 0
 698: PPUSH
 699: PPUSH
// for i in charactersList do
 700: LD_ADDR_VAR 0 4
 704: PUSH
 705: LD_VAR 0 1
 709: PUSH
 710: FOR_IN
 711: IFFALSE 751
// begin if IsOk ( i ) then
 713: LD_VAR 0 4
 717: PPUSH
 718: CALL_OW 302
 722: IFFALSE 740
// begin SaveCharacters ( i , ident ) ;
 724: LD_VAR 0 4
 728: PPUSH
 729: LD_VAR 0 2
 733: PPUSH
 734: CALL_OW 38
// end else
 738: GO 749
// begin DeleteCharacters ( ident ) ;
 740: LD_VAR 0 2
 744: PPUSH
 745: CALL_OW 40
// end ; end ;
 749: GO 710
 751: POP
 752: POP
// end ;
 753: LD_VAR 0 3
 757: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 758: LD_INT 0
 760: PPUSH
 761: PPUSH
 762: PPUSH
 763: PPUSH
 764: PPUSH
 765: PPUSH
 766: PPUSH
 767: PPUSH
 768: PPUSH
 769: PPUSH
 770: PPUSH
// amChassisTab = [ ] ;
 771: LD_ADDR_VAR 0 19
 775: PUSH
 776: EMPTY
 777: ST_TO_ADDR
// arChassisTab = [ ] ;
 778: LD_ADDR_VAR 0 18
 782: PUSH
 783: EMPTY
 784: ST_TO_ADDR
// ruChassisTab = [ ] ;
 785: LD_ADDR_VAR 0 17
 789: PUSH
 790: EMPTY
 791: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 792: LD_INT 35
 794: PPUSH
 795: CALL_OW 67
// if nation = 1 then
 799: LD_VAR 0 5
 803: PUSH
 804: LD_INT 1
 806: EQUAL
 807: IFFALSE 1298
// begin uc_side = side ;
 809: LD_ADDR_OWVAR 20
 813: PUSH
 814: LD_VAR 0 2
 818: ST_TO_ADDR
// uc_nation = nation ;
 819: LD_ADDR_OWVAR 21
 823: PUSH
 824: LD_VAR 0 5
 828: ST_TO_ADDR
// vc_engine = vehengine ;
 829: LD_ADDR_OWVAR 39
 833: PUSH
 834: LD_VAR 0 6
 838: ST_TO_ADDR
// vc_control = vehcontrol ;
 839: LD_ADDR_OWVAR 38
 843: PUSH
 844: LD_VAR 0 7
 848: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 849: LD_ADDR_OWVAR 40
 853: PUSH
 854: LD_VAR 0 10
 858: PUSH
 859: LD_INT 1
 861: PPUSH
 862: LD_VAR 0 10
 866: PPUSH
 867: CALL_OW 12
 871: ARRAY
 872: ST_TO_ADDR
// for j = 1 to AMWeapon do
 873: LD_ADDR_VAR 0 14
 877: PUSH
 878: DOUBLE
 879: LD_INT 1
 881: DEC
 882: ST_TO_ADDR
 883: LD_VAR 0 10
 887: PUSH
 888: FOR_TO
 889: IFFALSE 1190
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 891: LD_VAR 0 10
 895: PUSH
 896: LD_VAR 0 14
 900: ARRAY
 901: PUSH
 902: LD_INT 2
 904: EQUAL
 905: PUSH
 906: LD_VAR 0 10
 910: PUSH
 911: LD_VAR 0 14
 915: ARRAY
 916: PUSH
 917: LD_INT 3
 919: EQUAL
 920: OR
 921: IFFALSE 974
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 923: LD_ADDR_VAR 0 19
 927: PUSH
 928: LD_INT 1
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 4
 939: PUSH
 940: LD_INT 5
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 950: LD_ADDR_OWVAR 37
 954: PUSH
 955: LD_VAR 0 19
 959: PUSH
 960: LD_INT 1
 962: PPUSH
 963: LD_VAR 0 19
 967: PPUSH
 968: CALL_OW 12
 972: ARRAY
 973: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 974: LD_VAR 0 10
 978: PUSH
 979: LD_VAR 0 14
 983: ARRAY
 984: PUSH
 985: LD_INT 4
 987: EQUAL
 988: PUSH
 989: LD_VAR 0 10
 993: PUSH
 994: LD_VAR 0 14
 998: ARRAY
 999: PUSH
1000: LD_INT 5
1002: EQUAL
1003: OR
1004: PUSH
1005: LD_VAR 0 10
1009: PUSH
1010: LD_VAR 0 14
1014: ARRAY
1015: PUSH
1016: LD_INT 9
1018: EQUAL
1019: OR
1020: PUSH
1021: LD_VAR 0 10
1025: PUSH
1026: LD_VAR 0 14
1030: ARRAY
1031: PUSH
1032: LD_INT 11
1034: EQUAL
1035: OR
1036: PUSH
1037: LD_VAR 0 10
1041: PUSH
1042: LD_VAR 0 14
1046: ARRAY
1047: PUSH
1048: LD_INT 7
1050: EQUAL
1051: OR
1052: IFFALSE 1101
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1054: LD_ADDR_VAR 0 19
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 3
1064: PUSH
1065: LD_INT 4
1067: PUSH
1068: LD_INT 5
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1077: LD_ADDR_OWVAR 37
1081: PUSH
1082: LD_VAR 0 19
1086: PUSH
1087: LD_INT 1
1089: PPUSH
1090: LD_VAR 0 19
1094: PPUSH
1095: CALL_OW 12
1099: ARRAY
1100: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
1101: LD_VAR 0 10
1105: PUSH
1106: LD_VAR 0 14
1110: ARRAY
1111: PUSH
1112: LD_INT 8
1114: EQUAL
1115: PUSH
1116: LD_VAR 0 10
1120: PUSH
1121: LD_VAR 0 14
1125: ARRAY
1126: PUSH
1127: LD_INT 6
1129: EQUAL
1130: OR
1131: PUSH
1132: LD_VAR 0 10
1136: PUSH
1137: LD_VAR 0 14
1141: ARRAY
1142: PUSH
1143: LD_INT 10
1145: EQUAL
1146: OR
1147: IFFALSE 1188
// begin amChassisTab = [ 4 , 5 ] ;
1149: LD_ADDR_VAR 0 19
1153: PUSH
1154: LD_INT 4
1156: PUSH
1157: LD_INT 5
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1164: LD_ADDR_OWVAR 37
1168: PUSH
1169: LD_VAR 0 19
1173: PUSH
1174: LD_INT 1
1176: PPUSH
1177: LD_VAR 0 19
1181: PPUSH
1182: CALL_OW 12
1186: ARRAY
1187: ST_TO_ADDR
// end ; end ;
1188: GO 888
1190: POP
1191: POP
// veh = CreateVehicle ;
1192: LD_ADDR_VAR 0 16
1196: PUSH
1197: CALL_OW 45
1201: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1202: LD_VAR 0 16
1206: PPUSH
1207: LD_VAR 0 1
1211: PPUSH
1212: LD_INT 0
1214: PPUSH
1215: CALL_OW 49
// if vehControl = 1 then
1219: LD_VAR 0 7
1223: PUSH
1224: LD_INT 1
1226: EQUAL
1227: IFFALSE 1284
// begin hc_gallery =  ;
1229: LD_ADDR_OWVAR 33
1233: PUSH
1234: LD_STRING 
1236: ST_TO_ADDR
// hc_name =  ;
1237: LD_ADDR_OWVAR 26
1241: PUSH
1242: LD_STRING 
1244: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1245: LD_INT 0
1247: PPUSH
1248: LD_INT 3
1250: PPUSH
1251: LD_VAR 0 4
1255: PPUSH
1256: CALL_OW 380
// un = CreateHuman ;
1260: LD_ADDR_VAR 0 15
1264: PUSH
1265: CALL_OW 44
1269: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1270: LD_VAR 0 15
1274: PPUSH
1275: LD_VAR 0 16
1279: PPUSH
1280: CALL_OW 52
// end ; i = i + 1 ;
1284: LD_ADDR_VAR 0 13
1288: PUSH
1289: LD_VAR 0 13
1293: PUSH
1294: LD_INT 1
1296: PLUS
1297: ST_TO_ADDR
// end ; if nation = 2 then
1298: LD_VAR 0 5
1302: PUSH
1303: LD_INT 2
1305: EQUAL
1306: IFFALSE 1730
// begin uc_side = side ;
1308: LD_ADDR_OWVAR 20
1312: PUSH
1313: LD_VAR 0 2
1317: ST_TO_ADDR
// uc_nation = nation ;
1318: LD_ADDR_OWVAR 21
1322: PUSH
1323: LD_VAR 0 5
1327: ST_TO_ADDR
// vc_engine = vehengine ;
1328: LD_ADDR_OWVAR 39
1332: PUSH
1333: LD_VAR 0 6
1337: ST_TO_ADDR
// vc_control = vehcontrol ;
1338: LD_ADDR_OWVAR 38
1342: PUSH
1343: LD_VAR 0 7
1347: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1348: LD_ADDR_OWVAR 40
1352: PUSH
1353: LD_VAR 0 9
1357: PUSH
1358: LD_INT 1
1360: PPUSH
1361: LD_VAR 0 9
1365: PPUSH
1366: CALL_OW 12
1370: ARRAY
1371: ST_TO_ADDR
// for j = 1 to ARWeapons do
1372: LD_ADDR_VAR 0 14
1376: PUSH
1377: DOUBLE
1378: LD_INT 1
1380: DEC
1381: ST_TO_ADDR
1382: LD_VAR 0 9
1386: PUSH
1387: FOR_TO
1388: IFFALSE 1622
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1390: LD_VAR 0 9
1394: PUSH
1395: LD_VAR 0 14
1399: ARRAY
1400: PUSH
1401: LD_INT 24
1403: EQUAL
1404: PUSH
1405: LD_VAR 0 9
1409: PUSH
1410: LD_VAR 0 14
1414: ARRAY
1415: PUSH
1416: LD_INT 22
1418: EQUAL
1419: OR
1420: PUSH
1421: LD_VAR 0 9
1425: PUSH
1426: LD_VAR 0 14
1430: ARRAY
1431: PUSH
1432: LD_INT 23
1434: EQUAL
1435: OR
1436: PUSH
1437: LD_VAR 0 9
1441: PUSH
1442: LD_VAR 0 14
1446: ARRAY
1447: PUSH
1448: LD_INT 30
1450: EQUAL
1451: OR
1452: IFFALSE 1501
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1454: LD_ADDR_VAR 0 18
1458: PUSH
1459: LD_INT 11
1461: PUSH
1462: LD_INT 12
1464: PUSH
1465: LD_INT 13
1467: PUSH
1468: LD_INT 14
1470: PUSH
1471: EMPTY
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1477: LD_ADDR_OWVAR 37
1481: PUSH
1482: LD_VAR 0 18
1486: PUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_VAR 0 18
1494: PPUSH
1495: CALL_OW 12
1499: ARRAY
1500: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1501: LD_VAR 0 9
1505: PUSH
1506: LD_VAR 0 14
1510: ARRAY
1511: PUSH
1512: LD_INT 29
1514: EQUAL
1515: PUSH
1516: LD_VAR 0 9
1520: PUSH
1521: LD_VAR 0 14
1525: ARRAY
1526: PUSH
1527: LD_INT 28
1529: EQUAL
1530: OR
1531: PUSH
1532: LD_VAR 0 9
1536: PUSH
1537: LD_VAR 0 14
1541: ARRAY
1542: PUSH
1543: LD_INT 27
1545: EQUAL
1546: OR
1547: PUSH
1548: LD_VAR 0 9
1552: PUSH
1553: LD_VAR 0 14
1557: ARRAY
1558: PUSH
1559: LD_INT 26
1561: EQUAL
1562: OR
1563: PUSH
1564: LD_VAR 0 9
1568: PUSH
1569: LD_VAR 0 14
1573: ARRAY
1574: PUSH
1575: LD_INT 25
1577: EQUAL
1578: OR
1579: IFFALSE 1620
// begin arChassisTab = [ 13 , 14 ] ;
1581: LD_ADDR_VAR 0 18
1585: PUSH
1586: LD_INT 13
1588: PUSH
1589: LD_INT 14
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1596: LD_ADDR_OWVAR 37
1600: PUSH
1601: LD_VAR 0 18
1605: PUSH
1606: LD_INT 1
1608: PPUSH
1609: LD_VAR 0 18
1613: PPUSH
1614: CALL_OW 12
1618: ARRAY
1619: ST_TO_ADDR
// end ; end ;
1620: GO 1387
1622: POP
1623: POP
// veh = CreateVehicle ;
1624: LD_ADDR_VAR 0 16
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1634: LD_VAR 0 16
1638: PPUSH
1639: LD_VAR 0 1
1643: PPUSH
1644: LD_INT 0
1646: PPUSH
1647: CALL_OW 49
// if vehcontrol = 1 then
1651: LD_VAR 0 7
1655: PUSH
1656: LD_INT 1
1658: EQUAL
1659: IFFALSE 1716
// begin hc_gallery =  ;
1661: LD_ADDR_OWVAR 33
1665: PUSH
1666: LD_STRING 
1668: ST_TO_ADDR
// hc_name =  ;
1669: LD_ADDR_OWVAR 26
1673: PUSH
1674: LD_STRING 
1676: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1677: LD_INT 0
1679: PPUSH
1680: LD_INT 3
1682: PPUSH
1683: LD_VAR 0 4
1687: PPUSH
1688: CALL_OW 380
// un = CreateHuman ;
1692: LD_ADDR_VAR 0 15
1696: PUSH
1697: CALL_OW 44
1701: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1702: LD_VAR 0 15
1706: PPUSH
1707: LD_VAR 0 16
1711: PPUSH
1712: CALL_OW 52
// end ; i = i + 1 ;
1716: LD_ADDR_VAR 0 13
1720: PUSH
1721: LD_VAR 0 13
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: ST_TO_ADDR
// end ; if nation = 3 then
1730: LD_VAR 0 5
1734: PUSH
1735: LD_INT 3
1737: EQUAL
1738: IFFALSE 2130
// begin uc_side = side ;
1740: LD_ADDR_OWVAR 20
1744: PUSH
1745: LD_VAR 0 2
1749: ST_TO_ADDR
// uc_nation = nation ;
1750: LD_ADDR_OWVAR 21
1754: PUSH
1755: LD_VAR 0 5
1759: ST_TO_ADDR
// vc_engine = vehengine ;
1760: LD_ADDR_OWVAR 39
1764: PUSH
1765: LD_VAR 0 6
1769: ST_TO_ADDR
// vc_control = vehcontrol ;
1770: LD_ADDR_OWVAR 38
1774: PUSH
1775: LD_VAR 0 7
1779: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1780: LD_ADDR_OWVAR 40
1784: PUSH
1785: LD_VAR 0 8
1789: PUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 8
1797: PPUSH
1798: CALL_OW 12
1802: ARRAY
1803: ST_TO_ADDR
// for j = 1 to RuWeapons do
1804: LD_ADDR_VAR 0 14
1808: PUSH
1809: DOUBLE
1810: LD_INT 1
1812: DEC
1813: ST_TO_ADDR
1814: LD_VAR 0 8
1818: PUSH
1819: FOR_TO
1820: IFFALSE 2022
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1822: LD_VAR 0 8
1826: PUSH
1827: LD_VAR 0 14
1831: ARRAY
1832: PUSH
1833: LD_INT 42
1835: EQUAL
1836: PUSH
1837: LD_VAR 0 8
1841: PUSH
1842: LD_VAR 0 14
1846: ARRAY
1847: PUSH
1848: LD_INT 43
1850: EQUAL
1851: OR
1852: PUSH
1853: LD_VAR 0 8
1857: PUSH
1858: LD_VAR 0 14
1862: ARRAY
1863: PUSH
1864: LD_INT 44
1866: EQUAL
1867: OR
1868: PUSH
1869: LD_VAR 0 8
1873: PUSH
1874: LD_VAR 0 14
1878: ARRAY
1879: PUSH
1880: LD_INT 45
1882: EQUAL
1883: OR
1884: PUSH
1885: LD_VAR 0 8
1889: PUSH
1890: LD_VAR 0 14
1894: ARRAY
1895: PUSH
1896: LD_INT 49
1898: EQUAL
1899: OR
1900: IFFALSE 1949
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1902: LD_ADDR_VAR 0 17
1906: PUSH
1907: LD_INT 21
1909: PUSH
1910: LD_INT 22
1912: PUSH
1913: LD_INT 23
1915: PUSH
1916: LD_INT 24
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1925: LD_ADDR_OWVAR 37
1929: PUSH
1930: LD_VAR 0 17
1934: PUSH
1935: LD_INT 1
1937: PPUSH
1938: LD_VAR 0 17
1942: PPUSH
1943: CALL_OW 12
1947: ARRAY
1948: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1949: LD_VAR 0 8
1953: PUSH
1954: LD_VAR 0 14
1958: ARRAY
1959: PUSH
1960: LD_INT 46
1962: EQUAL
1963: PUSH
1964: LD_VAR 0 8
1968: PUSH
1969: LD_VAR 0 14
1973: ARRAY
1974: PUSH
1975: LD_INT 47
1977: EQUAL
1978: OR
1979: IFFALSE 2020
// begin ruChassisTab = [ 23 , 24 ] ;
1981: LD_ADDR_VAR 0 17
1985: PUSH
1986: LD_INT 23
1988: PUSH
1989: LD_INT 24
1991: PUSH
1992: EMPTY
1993: LIST
1994: LIST
1995: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1996: LD_ADDR_OWVAR 37
2000: PUSH
2001: LD_VAR 0 17
2005: PUSH
2006: LD_INT 1
2008: PPUSH
2009: LD_VAR 0 17
2013: PPUSH
2014: CALL_OW 12
2018: ARRAY
2019: ST_TO_ADDR
// end ; end ;
2020: GO 1819
2022: POP
2023: POP
// veh = CreateVehicle ;
2024: LD_ADDR_VAR 0 16
2028: PUSH
2029: CALL_OW 45
2033: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2034: LD_VAR 0 16
2038: PPUSH
2039: LD_VAR 0 1
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: CALL_OW 49
// if vehcontrol = 1 then
2051: LD_VAR 0 7
2055: PUSH
2056: LD_INT 1
2058: EQUAL
2059: IFFALSE 2116
// begin hc_gallery =  ;
2061: LD_ADDR_OWVAR 33
2065: PUSH
2066: LD_STRING 
2068: ST_TO_ADDR
// hc_name =  ;
2069: LD_ADDR_OWVAR 26
2073: PUSH
2074: LD_STRING 
2076: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2077: LD_INT 0
2079: PPUSH
2080: LD_INT 3
2082: PPUSH
2083: LD_VAR 0 4
2087: PPUSH
2088: CALL_OW 380
// un = CreateHuman ;
2092: LD_ADDR_VAR 0 15
2096: PUSH
2097: CALL_OW 44
2101: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2102: LD_VAR 0 15
2106: PPUSH
2107: LD_VAR 0 16
2111: PPUSH
2112: CALL_OW 52
// end ; i = i + 1 ;
2116: LD_ADDR_VAR 0 13
2120: PUSH
2121: LD_VAR 0 13
2125: PUSH
2126: LD_INT 1
2128: PLUS
2129: ST_TO_ADDR
// end ; until i = vehCount ;
2130: LD_VAR 0 13
2134: PUSH
2135: LD_VAR 0 3
2139: EQUAL
2140: IFFALSE 792
// repeat wait ( 0 0$1 ) ;
2142: LD_INT 35
2144: PPUSH
2145: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2149: LD_ADDR_VAR 0 20
2153: PUSH
2154: LD_INT 22
2156: PUSH
2157: LD_VAR 0 2
2161: PUSH
2162: EMPTY
2163: LIST
2164: LIST
2165: PUSH
2166: LD_INT 21
2168: PUSH
2169: LD_INT 2
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: PUSH
2176: LD_INT 24
2178: PUSH
2179: LD_INT 650
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: PUSH
2186: EMPTY
2187: LIST
2188: LIST
2189: LIST
2190: PPUSH
2191: CALL_OW 69
2195: ST_TO_ADDR
// if vehicleOK_list > 0 then
2196: LD_VAR 0 20
2200: PUSH
2201: LD_INT 0
2203: GREATER
2204: IFFALSE 2395
// begin for i in vehicleOK_list do
2206: LD_ADDR_VAR 0 13
2210: PUSH
2211: LD_VAR 0 20
2215: PUSH
2216: FOR_IN
2217: IFFALSE 2393
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2219: LD_ADDR_VAR 0 21
2223: PUSH
2224: LD_INT 22
2226: PUSH
2227: LD_VAR 0 11
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: PPUSH
2236: CALL_OW 69
2240: PPUSH
2241: LD_VAR 0 13
2245: PPUSH
2246: CALL_OW 74
2250: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2251: LD_ADDR_VAR 0 22
2255: PUSH
2256: LD_INT 22
2258: PUSH
2259: LD_VAR 0 11
2263: PUSH
2264: EMPTY
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 2
2270: PUSH
2271: LD_INT 59
2273: PUSH
2274: EMPTY
2275: LIST
2276: PUSH
2277: LD_INT 21
2279: PUSH
2280: LD_INT 1
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 21
2289: PUSH
2290: LD_INT 2
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: PPUSH
2310: CALL_OW 69
2314: PPUSH
2315: LD_VAR 0 13
2319: PPUSH
2320: CALL_OW 74
2324: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2325: LD_VAR 0 13
2329: PPUSH
2330: LD_VAR 0 21
2334: PPUSH
2335: CALL_OW 296
2339: PUSH
2340: LD_INT 8
2342: PLUS
2343: PUSH
2344: LD_VAR 0 13
2348: PPUSH
2349: LD_VAR 0 22
2353: PPUSH
2354: CALL_OW 296
2358: LESS
2359: IFFALSE 2377
// begin ComAttackUnit ( i , target1 ) ;
2361: LD_VAR 0 13
2365: PPUSH
2366: LD_VAR 0 21
2370: PPUSH
2371: CALL_OW 115
// end else
2375: GO 2391
// begin ComAttackUnit ( i , target2 ) ;
2377: LD_VAR 0 13
2381: PPUSH
2382: LD_VAR 0 22
2386: PPUSH
2387: CALL_OW 115
// end ; end ;
2391: GO 2216
2393: POP
2394: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2395: LD_INT 22
2397: PUSH
2398: LD_VAR 0 2
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 21
2409: PUSH
2410: LD_INT 2
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: PPUSH
2421: CALL_OW 69
2425: PUSH
2426: LD_INT 0
2428: EQUAL
2429: IFFALSE 2142
// end ;
2431: LD_VAR 0 12
2435: RET
// every 0 0$1 do
2436: GO 2438
2438: DISABLE
// begin enable ;
2439: ENABLE
// end ;
2440: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2441: LD_INT 0
2443: PPUSH
2444: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2445: LD_INT 22
2447: PUSH
2448: LD_VAR 0 1
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: PUSH
2457: LD_INT 21
2459: PUSH
2460: LD_INT 2
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PPUSH
2471: CALL_OW 69
2475: PUSH
2476: LD_VAR 0 3
2480: LESSEQUAL
2481: IFFALSE 2548
// for i = 1 to vehCount do
2483: LD_ADDR_VAR 0 9
2487: PUSH
2488: DOUBLE
2489: LD_INT 1
2491: DEC
2492: ST_TO_ADDR
2493: LD_VAR 0 3
2497: PUSH
2498: FOR_TO
2499: IFFALSE 2546
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2501: LD_VAR 0 2
2505: PPUSH
2506: LD_VAR 0 7
2510: PPUSH
2511: LD_VAR 0 5
2515: PPUSH
2516: LD_VAR 0 6
2520: PPUSH
2521: LD_VAR 0 4
2525: PUSH
2526: LD_INT 1
2528: PPUSH
2529: LD_VAR 0 4
2533: PPUSH
2534: CALL_OW 12
2538: ARRAY
2539: PPUSH
2540: CALL_OW 185
2544: GO 2498
2546: POP
2547: POP
// end ;
2548: LD_VAR 0 8
2552: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2553: LD_INT 0
2555: PPUSH
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// for i := 1 to CPU1Tanks do
2560: LD_ADDR_VAR 0 4
2564: PUSH
2565: DOUBLE
2566: LD_INT 1
2568: DEC
2569: ST_TO_ADDR
2570: LD_EXP 5
2574: PUSH
2575: FOR_TO
2576: IFFALSE 2904
// begin if i = 4 then
2578: LD_VAR 0 4
2582: PUSH
2583: LD_INT 4
2585: EQUAL
2586: IFFALSE 2902
// begin repeat wait ( 0 0$1 ) ;
2588: LD_INT 35
2590: PPUSH
2591: CALL_OW 67
// for i in CPU1Tanks do
2595: LD_ADDR_VAR 0 4
2599: PUSH
2600: LD_EXP 5
2604: PUSH
2605: FOR_IN
2606: IFFALSE 2890
// begin if GetLives ( i ) < 659 then
2608: LD_VAR 0 4
2612: PPUSH
2613: CALL_OW 256
2617: PUSH
2618: LD_INT 659
2620: LESS
2621: IFFALSE 2709
// begin tmp = i ;
2623: LD_ADDR_VAR 0 5
2627: PUSH
2628: LD_VAR 0 4
2632: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2633: LD_ADDR_VAR 0 4
2637: PUSH
2638: DOUBLE
2639: LD_INT 1
2641: DEC
2642: ST_TO_ADDR
2643: LD_EXP 5
2647: PUSH
2648: FOR_TO
2649: IFFALSE 2707
// begin if tmp = CPU1Tanks [ i ] then
2651: LD_VAR 0 5
2655: PUSH
2656: LD_EXP 5
2660: PUSH
2661: LD_VAR 0 4
2665: ARRAY
2666: EQUAL
2667: IFFALSE 2705
// begin CPU1Tanks = Delete ( CPU1Tanks , i ) ;
2669: LD_ADDR_EXP 5
2673: PUSH
2674: LD_EXP 5
2678: PPUSH
2679: LD_VAR 0 4
2683: PPUSH
2684: CALL_OW 3
2688: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2689: LD_ADDR_EXP 6
2693: PUSH
2694: LD_EXP 6
2698: PUSH
2699: LD_VAR 0 5
2703: ADD
2704: ST_TO_ADDR
// end ; end ;
2705: GO 2648
2707: POP
2708: POP
// end ; wait ( 0 0$1 ) ;
2709: LD_INT 35
2711: PPUSH
2712: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2716: LD_ADDR_VAR 0 6
2720: PUSH
2721: LD_INT 22
2723: PUSH
2724: LD_VAR 0 2
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PPUSH
2738: LD_VAR 0 4
2742: PPUSH
2743: CALL_OW 74
2747: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2748: LD_ADDR_VAR 0 7
2752: PUSH
2753: LD_INT 22
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 2
2767: PUSH
2768: LD_INT 59
2770: PUSH
2771: EMPTY
2772: LIST
2773: PUSH
2774: LD_INT 21
2776: PUSH
2777: LD_INT 1
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: LD_INT 21
2786: PUSH
2787: LD_INT 2
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: LIST
2798: LIST
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: EMPTY
2805: LIST
2806: PPUSH
2807: CALL_OW 69
2811: PPUSH
2812: LD_VAR 0 4
2816: PPUSH
2817: CALL_OW 74
2821: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2822: LD_VAR 0 4
2826: PPUSH
2827: LD_VAR 0 6
2831: PPUSH
2832: CALL_OW 296
2836: PUSH
2837: LD_INT 8
2839: PLUS
2840: PUSH
2841: LD_VAR 0 4
2845: PPUSH
2846: LD_VAR 0 7
2850: PPUSH
2851: CALL_OW 296
2855: LESS
2856: IFFALSE 2874
// begin ComAttackUnit ( i , target1 ) ;
2858: LD_VAR 0 4
2862: PPUSH
2863: LD_VAR 0 6
2867: PPUSH
2868: CALL_OW 115
// end else
2872: GO 2888
// begin ComAttackUnit ( i , target2 ) ;
2874: LD_VAR 0 4
2878: PPUSH
2879: LD_VAR 0 7
2883: PPUSH
2884: CALL_OW 115
// end ; end ;
2888: GO 2605
2890: POP
2891: POP
// until CPU1Tanks = 0 ;
2892: LD_EXP 5
2896: PUSH
2897: LD_INT 0
2899: EQUAL
2900: IFFALSE 2588
// end ; end ;
2902: GO 2575
2904: POP
2905: POP
// end ;
2906: LD_VAR 0 3
2910: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
2922: LD_ADDR_VAR 0 8
2926: PUSH
2927: LD_INT 22
2929: PUSH
2930: LD_VAR 0 1
2934: PUSH
2935: EMPTY
2936: LIST
2937: LIST
2938: PUSH
2939: LD_INT 21
2941: PUSH
2942: LD_INT 2
2944: PUSH
2945: EMPTY
2946: LIST
2947: LIST
2948: PUSH
2949: LD_INT 24
2951: PUSH
2952: LD_INT 660
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: LD_INT 58
2964: PUSH
2965: EMPTY
2966: LIST
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: LIST
2976: LIST
2977: PPUSH
2978: CALL_OW 69
2982: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2983: LD_ADDR_VAR 0 9
2987: PUSH
2988: LD_INT 22
2990: PUSH
2991: LD_VAR 0 1
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: PUSH
3000: LD_INT 21
3002: PUSH
3003: LD_INT 2
3005: PUSH
3006: EMPTY
3007: LIST
3008: LIST
3009: PUSH
3010: LD_INT 3
3012: PUSH
3013: LD_INT 24
3015: PUSH
3016: LD_INT 660
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: LIST
3031: PPUSH
3032: CALL_OW 69
3036: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3037: LD_ADDR_VAR 0 10
3041: PUSH
3042: LD_VAR 0 2
3046: PPUSH
3047: LD_INT 22
3049: PUSH
3050: LD_VAR 0 1
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: LD_INT 21
3061: PUSH
3062: LD_INT 2
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 3
3071: PUSH
3072: LD_INT 24
3074: PUSH
3075: LD_INT 1000
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: PPUSH
3091: CALL_OW 70
3095: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
3096: LD_ADDR_VAR 0 11
3100: PUSH
3101: LD_VAR 0 2
3105: PPUSH
3106: LD_INT 22
3108: PUSH
3109: LD_VAR 0 1
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PUSH
3118: LD_INT 21
3120: PUSH
3121: LD_INT 2
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: PUSH
3128: LD_INT 24
3130: PUSH
3131: LD_INT 1000
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: PUSH
3138: LD_INT 58
3140: PUSH
3141: EMPTY
3142: LIST
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: PPUSH
3150: CALL_OW 70
3154: ST_TO_ADDR
// mechanicInside_list = [ ] ;
3155: LD_ADDR_VAR 0 12
3159: PUSH
3160: EMPTY
3161: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
3162: LD_ADDR_VAR 0 13
3166: PUSH
3167: LD_VAR 0 2
3171: PPUSH
3172: LD_INT 22
3174: PUSH
3175: LD_VAR 0 1
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: PUSH
3184: LD_INT 25
3186: PUSH
3187: LD_INT 3
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PPUSH
3198: CALL_OW 70
3202: ST_TO_ADDR
// display_strings = [ w polu:  , CPU1Tanks , uszkodzone:  , CPU1DamageTanks , wylosowane: 4 , ok , vehicleOK_list ] ;
3203: LD_ADDR_OWVAR 47
3207: PUSH
3208: LD_STRING w polu: 
3210: PUSH
3211: LD_EXP 5
3215: PUSH
3216: LD_STRING uszkodzone: 
3218: PUSH
3219: LD_EXP 6
3223: PUSH
3224: LD_STRING wylosowane: 4
3226: PUSH
3227: LD_STRING ok
3229: PUSH
3230: LD_VAR 0 8
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: ST_TO_ADDR
// if damageVehicle_list > 0 then
3244: LD_VAR 0 9
3248: PUSH
3249: LD_INT 0
3251: GREATER
3252: IFFALSE 3290
// for i in damageVehicle_list do
3254: LD_ADDR_VAR 0 6
3258: PUSH
3259: LD_VAR 0 9
3263: PUSH
3264: FOR_IN
3265: IFFALSE 3288
// ComMoveXY ( i , repX , repY ) ;
3267: LD_VAR 0 6
3271: PPUSH
3272: LD_VAR 0 3
3276: PPUSH
3277: LD_VAR 0 4
3281: PPUSH
3282: CALL_OW 111
3286: GO 3264
3288: POP
3289: POP
// if vehicleNeedRepair_list > 0 then
3290: LD_VAR 0 10
3294: PUSH
3295: LD_INT 0
3297: GREATER
3298: IFFALSE 3385
// begin for i in vehicleNeedRepair_list do
3300: LD_ADDR_VAR 0 6
3304: PUSH
3305: LD_VAR 0 10
3309: PUSH
3310: FOR_IN
3311: IFFALSE 3383
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
3313: LD_ADDR_VAR 0 12
3317: PUSH
3318: LD_VAR 0 12
3322: PUSH
3323: LD_VAR 0 6
3327: PPUSH
3328: CALL_OW 313
3332: ADD
3333: ST_TO_ADDR
// for j in mechanicInside_list do
3334: LD_ADDR_VAR 0 7
3338: PUSH
3339: LD_VAR 0 12
3343: PUSH
3344: FOR_IN
3345: IFFALSE 3379
// begin ComExitVehicle ( j ) ;
3347: LD_VAR 0 7
3351: PPUSH
3352: CALL_OW 121
// wait ( 0 0$1 ) ;
3356: LD_INT 35
3358: PPUSH
3359: CALL_OW 67
// AddComRepairVehicle ( j , i ) ;
3363: LD_VAR 0 7
3367: PPUSH
3368: LD_VAR 0 6
3372: PPUSH
3373: CALL_OW 189
// end ;
3377: GO 3344
3379: POP
3380: POP
// end ;
3381: GO 3310
3383: POP
3384: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3385: LD_VAR 0 11
3389: PUSH
3390: LD_INT 0
3392: GREATER
3393: IFFALSE 3417
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3395: LD_VAR 0 13
3399: PUSH
3400: LD_INT 1
3402: ARRAY
3403: PPUSH
3404: LD_VAR 0 11
3408: PUSH
3409: LD_INT 1
3411: ARRAY
3412: PPUSH
3413: CALL_OW 120
// end ; if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3417: LD_VAR 0 8
3421: PUSH
3422: LD_INT 0
3424: GREATER
3425: PUSH
3426: LD_EXP 6
3430: PUSH
3431: LD_INT 0
3433: GREATER
3434: AND
3435: IFFALSE 3576
// begin for i := 1 to vehicleOK_list do
3437: LD_ADDR_VAR 0 6
3441: PUSH
3442: DOUBLE
3443: LD_INT 1
3445: DEC
3446: ST_TO_ADDR
3447: LD_VAR 0 8
3451: PUSH
3452: FOR_TO
3453: IFFALSE 3574
// begin if i = 4 then
3455: LD_VAR 0 6
3459: PUSH
3460: LD_INT 4
3462: EQUAL
3463: IFFALSE 3572
// begin for i in vehicleOK_list do
3465: LD_ADDR_VAR 0 6
3469: PUSH
3470: LD_VAR 0 8
3474: PUSH
3475: FOR_IN
3476: IFFALSE 3496
// CPU1Tanks = CPU1Tanks ^ i ;
3478: LD_ADDR_EXP 5
3482: PUSH
3483: LD_EXP 5
3487: PUSH
3488: LD_VAR 0 6
3492: ADD
3493: ST_TO_ADDR
3494: GO 3475
3496: POP
3497: POP
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3498: LD_ADDR_EXP 6
3502: PUSH
3503: LD_EXP 6
3507: PPUSH
3508: LD_INT 1
3510: PPUSH
3511: CALL_OW 3
3515: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3516: LD_ADDR_EXP 6
3520: PUSH
3521: LD_EXP 6
3525: PPUSH
3526: LD_INT 1
3528: PPUSH
3529: CALL_OW 3
3533: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3534: LD_ADDR_EXP 6
3538: PUSH
3539: LD_EXP 6
3543: PPUSH
3544: LD_INT 1
3546: PPUSH
3547: CALL_OW 3
3551: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3552: LD_ADDR_EXP 6
3556: PUSH
3557: LD_EXP 6
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: CALL_OW 3
3569: ST_TO_ADDR
// break ;
3570: GO 3574
// end ; end ;
3572: GO 3452
3574: POP
3575: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3576: LD_ADDR_VAR 0 6
3580: PUSH
3581: LD_VAR 0 2
3585: PPUSH
3586: LD_INT 22
3588: PUSH
3589: LD_VAR 0 1
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 25
3600: PUSH
3601: LD_INT 3
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PPUSH
3612: CALL_OW 70
3616: NOT
3617: PUSH
3618: FOR_IN
3619: IFFALSE 3642
// ComMoveXY ( i , repX , repY ) ;
3621: LD_VAR 0 6
3625: PPUSH
3626: LD_VAR 0 3
3630: PPUSH
3631: LD_VAR 0 4
3635: PPUSH
3636: CALL_OW 111
3640: GO 3618
3642: POP
3643: POP
// end ;
3644: LD_VAR 0 5
3648: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3649: LD_INT 0
3651: PPUSH
3652: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3653: LD_INT 22
3655: PUSH
3656: LD_VAR 0 1
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: PUSH
3665: LD_INT 25
3667: PUSH
3668: LD_INT 2
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PPUSH
3679: CALL_OW 69
3683: PUSH
3684: LD_INT 0
3686: GREATER
3687: PUSH
3688: LD_INT 22
3690: PUSH
3691: LD_VAR 0 1
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PUSH
3700: LD_INT 21
3702: PUSH
3703: LD_INT 3
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PUSH
3710: LD_INT 3
3712: PUSH
3713: LD_INT 24
3715: PUSH
3716: LD_INT 1000
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PPUSH
3732: CALL_OW 69
3736: PUSH
3737: LD_INT 0
3739: EQUAL
3740: AND
3741: PUSH
3742: LD_VAR 0 2
3746: PUSH
3747: LD_INT 0
3749: GREATER
3750: AND
3751: IFFALSE 3850
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3753: LD_ADDR_VAR 0 4
3757: PUSH
3758: LD_INT 22
3760: PUSH
3761: LD_VAR 0 1
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 25
3772: PUSH
3773: LD_INT 2
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PPUSH
3784: CALL_OW 69
3788: PUSH
3789: FOR_IN
3790: IFFALSE 3848
// begin AddComExitBuilding ( i ) ;
3792: LD_VAR 0 4
3796: PPUSH
3797: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_VAR 0 2
3810: PUSH
3811: LD_INT 1
3813: ARRAY
3814: PPUSH
3815: LD_VAR 0 2
3819: PUSH
3820: LD_INT 2
3822: ARRAY
3823: PPUSH
3824: LD_VAR 0 2
3828: PUSH
3829: LD_INT 3
3831: ARRAY
3832: PPUSH
3833: LD_VAR 0 2
3837: PUSH
3838: LD_INT 4
3840: ARRAY
3841: PPUSH
3842: CALL_OW 205
// end ;
3846: GO 3789
3848: POP
3849: POP
// end ; end ;
3850: LD_VAR 0 3
3854: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3855: LD_INT 0
3857: PPUSH
3858: PPUSH
3859: PPUSH
3860: PPUSH
3861: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3862: LD_ADDR_VAR 0 6
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_VAR 0 1
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PUSH
3879: LD_INT 2
3881: PUSH
3882: LD_INT 30
3884: PUSH
3885: LD_INT 31
3887: PUSH
3888: EMPTY
3889: LIST
3890: LIST
3891: PUSH
3892: LD_INT 30
3894: PUSH
3895: LD_INT 32
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 33
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: LD_INT 30
3914: PUSH
3915: LD_INT 4
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: LD_INT 30
3924: PUSH
3925: LD_INT 5
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: PUSH
3932: EMPTY
3933: LIST
3934: LIST
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: PPUSH
3944: CALL_OW 69
3948: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3949: LD_ADDR_VAR 0 7
3953: PUSH
3954: LD_INT 22
3956: PUSH
3957: LD_VAR 0 2
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: LD_INT 21
3968: PUSH
3969: LD_INT 3
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 58
3978: PUSH
3979: EMPTY
3980: LIST
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: LIST
3986: PPUSH
3987: CALL_OW 69
3991: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3992: LD_VAR 0 6
3996: PUSH
3997: LD_INT 0
3999: GREATER
4000: PUSH
4001: LD_VAR 0 7
4005: PUSH
4006: LD_INT 0
4008: GREATER
4009: AND
4010: IFFALSE 4080
// begin for i in turretsList do
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_VAR 0 6
4021: PUSH
4022: FOR_IN
4023: IFFALSE 4078
// begin for j in enemyBuildings do
4025: LD_ADDR_VAR 0 5
4029: PUSH
4030: LD_VAR 0 7
4034: PUSH
4035: FOR_IN
4036: IFFALSE 4074
// begin if GetDistUnits ( i , j ) < 20 then
4038: LD_VAR 0 4
4042: PPUSH
4043: LD_VAR 0 5
4047: PPUSH
4048: CALL_OW 296
4052: PUSH
4053: LD_INT 20
4055: LESS
4056: IFFALSE 4072
// begin ComAttackUnit ( i , j ) ;
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_VAR 0 5
4067: PPUSH
4068: CALL_OW 115
// end ; end ;
4072: GO 4035
4074: POP
4075: POP
// end ;
4076: GO 4022
4078: POP
4079: POP
// end ; end ;
4080: LD_VAR 0 3
4084: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
4093: LD_ADDR_VAR 0 7
4097: PUSH
4098: LD_INT 22
4100: PUSH
4101: LD_VAR 0 1
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: LD_INT 25
4112: PUSH
4113: LD_INT 9
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: PUSH
4120: EMPTY
4121: LIST
4122: LIST
4123: PPUSH
4124: CALL_OW 69
4128: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4129: LD_ADDR_VAR 0 8
4133: PUSH
4134: LD_INT 22
4136: PUSH
4137: LD_VAR 0 2
4141: PUSH
4142: EMPTY
4143: LIST
4144: LIST
4145: PUSH
4146: LD_INT 3
4148: PUSH
4149: LD_INT 21
4151: PUSH
4152: LD_INT 3
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: PUSH
4159: EMPTY
4160: LIST
4161: LIST
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: PPUSH
4167: CALL_OW 69
4171: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
4172: LD_ADDR_VAR 0 5
4176: PUSH
4177: LD_INT 1
4179: PPUSH
4180: LD_INT 3
4182: PPUSH
4183: CALL_OW 12
4187: ST_TO_ADDR
// for i = 1 to list do
4188: LD_ADDR_VAR 0 6
4192: PUSH
4193: DOUBLE
4194: LD_INT 1
4196: DEC
4197: ST_TO_ADDR
4198: LD_VAR 0 7
4202: PUSH
4203: FOR_TO
4204: IFFALSE 4386
// for ta in filter do
4206: LD_ADDR_VAR 0 4
4210: PUSH
4211: LD_VAR 0 8
4215: PUSH
4216: FOR_IN
4217: IFFALSE 4382
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
4219: LD_VAR 0 7
4223: PUSH
4224: LD_VAR 0 6
4228: ARRAY
4229: PPUSH
4230: LD_VAR 0 4
4234: PPUSH
4235: CALL_OW 296
4239: PUSH
4240: LD_INT 13
4242: LESSEQUAL
4243: IFFALSE 4380
// begin case c of 1 :
4245: LD_VAR 0 5
4249: PUSH
4250: LD_INT 1
4252: DOUBLE
4253: EQUAL
4254: IFTRUE 4258
4256: GO 4296
4258: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4259: LD_VAR 0 7
4263: PUSH
4264: LD_VAR 0 6
4268: ARRAY
4269: PPUSH
4270: LD_VAR 0 4
4274: PPUSH
4275: CALL_OW 250
4279: PPUSH
4280: LD_VAR 0 4
4284: PPUSH
4285: CALL_OW 251
4289: PPUSH
4290: CALL_OW 154
4294: GO 4380
4296: LD_INT 2
4298: DOUBLE
4299: EQUAL
4300: IFTRUE 4304
4302: GO 4368
4304: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4305: LD_VAR 0 7
4309: PUSH
4310: LD_VAR 0 6
4314: ARRAY
4315: PPUSH
4316: LD_VAR 0 4
4320: PPUSH
4321: CALL_OW 250
4325: PUSH
4326: LD_INT 1
4328: NEG
4329: PPUSH
4330: LD_INT 1
4332: PPUSH
4333: CALL_OW 12
4337: PLUS
4338: PPUSH
4339: LD_VAR 0 4
4343: PPUSH
4344: CALL_OW 251
4348: PUSH
4349: LD_INT 1
4351: NEG
4352: PPUSH
4353: LD_INT 1
4355: PPUSH
4356: CALL_OW 12
4360: PLUS
4361: PPUSH
4362: CALL_OW 153
4366: GO 4380
4368: LD_INT 3
4370: DOUBLE
4371: EQUAL
4372: IFTRUE 4376
4374: GO 4379
4376: POP
// ; end ;
4377: GO 4380
4379: POP
// end ; end ;
4380: GO 4216
4382: POP
4383: POP
4384: GO 4203
4386: POP
4387: POP
// end ;
4388: LD_VAR 0 3
4392: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
4393: LD_INT 0
4395: PPUSH
4396: PPUSH
4397: PPUSH
4398: PPUSH
4399: PPUSH
4400: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
4401: LD_ADDR_VAR 0 6
4405: PUSH
4406: LD_VAR 0 2
4410: PPUSH
4411: CALL_OW 313
4415: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
4416: LD_ADDR_VAR 0 7
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_VAR 0 1
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PUSH
4433: LD_INT 25
4435: PUSH
4436: LD_INT 2
4438: PUSH
4439: EMPTY
4440: LIST
4441: LIST
4442: PUSH
4443: LD_INT 24
4445: PUSH
4446: LD_INT 1000
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 3
4455: PUSH
4456: LD_INT 54
4458: PUSH
4459: EMPTY
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 69
4476: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4477: LD_ADDR_VAR 0 4
4481: PUSH
4482: LD_INT 22
4484: PUSH
4485: LD_VAR 0 1
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: PUSH
4494: LD_INT 21
4496: PUSH
4497: LD_INT 3
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PUSH
4504: LD_INT 3
4506: PUSH
4507: LD_INT 24
4509: PUSH
4510: LD_INT 1000
4512: PUSH
4513: EMPTY
4514: LIST
4515: LIST
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PUSH
4526: EMPTY
4527: LIST
4528: PPUSH
4529: CALL_OW 69
4533: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4534: LD_VAR 0 4
4538: NOT
4539: PUSH
4540: LD_VAR 0 7
4544: NOT
4545: AND
4546: PUSH
4547: LD_EXP 1
4551: NOT
4552: AND
4553: IFFALSE 4557
// exit ;
4555: GO 4676
// if buildings_list > 0 and engineerOkInside then
4557: LD_VAR 0 4
4561: PUSH
4562: LD_INT 0
4564: GREATER
4565: PUSH
4566: LD_VAR 0 6
4570: AND
4571: IFFALSE 4604
// for i in UnitsInside ( building ) do
4573: LD_ADDR_VAR 0 5
4577: PUSH
4578: LD_VAR 0 2
4582: PPUSH
4583: CALL_OW 313
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4602
// ComExitBuilding ( i ) ;
4591: LD_VAR 0 5
4595: PPUSH
4596: CALL_OW 122
4600: GO 4588
4602: POP
4603: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4604: LD_VAR 0 4
4608: PUSH
4609: LD_INT 0
4611: GREATER
4612: PUSH
4613: LD_VAR 0 7
4617: PUSH
4618: LD_INT 0
4620: GREATER
4621: AND
4622: IFFALSE 4676
// begin for i in engineerOkOutside do
4624: LD_ADDR_VAR 0 5
4628: PUSH
4629: LD_VAR 0 7
4633: PUSH
4634: FOR_IN
4635: IFFALSE 4674
// for j in buildings_list do
4637: LD_ADDR_VAR 0 8
4641: PUSH
4642: LD_VAR 0 4
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4670
// ComRepairBuilding ( i , j [ 1 ] ) ;
4650: LD_VAR 0 5
4654: PPUSH
4655: LD_VAR 0 8
4659: PUSH
4660: LD_INT 1
4662: ARRAY
4663: PPUSH
4664: CALL_OW 130
4668: GO 4647
4670: POP
4671: POP
4672: GO 4634
4674: POP
4675: POP
// end ; end ;
4676: LD_VAR 0 3
4680: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
4685: PPUSH
4686: PPUSH
4687: PPUSH
4688: PPUSH
4689: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4690: LD_ADDR_VAR 0 6
4694: PUSH
4695: LD_INT 22
4697: PUSH
4698: LD_VAR 0 1
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PUSH
4707: LD_INT 25
4709: PUSH
4710: LD_INT 4
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PUSH
4717: LD_INT 24
4719: PUSH
4720: LD_INT 251
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: PPUSH
4732: CALL_OW 69
4736: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4737: LD_ADDR_VAR 0 7
4741: PUSH
4742: LD_VAR 0 3
4746: PPUSH
4747: LD_INT 22
4749: PUSH
4750: LD_VAR 0 1
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: PUSH
4759: LD_INT 25
4761: PUSH
4762: LD_INT 4
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: PUSH
4769: LD_INT 50
4771: PUSH
4772: EMPTY
4773: LIST
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: LIST
4779: PPUSH
4780: CALL_OW 70
4784: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4785: LD_ADDR_VAR 0 10
4789: PUSH
4790: LD_VAR 0 3
4794: PPUSH
4795: LD_INT 22
4797: PUSH
4798: LD_VAR 0 1
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 21
4809: PUSH
4810: LD_INT 1
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: PUSH
4817: LD_INT 3
4819: PUSH
4820: LD_INT 24
4822: PUSH
4823: LD_INT 750
4825: PUSH
4826: EMPTY
4827: LIST
4828: LIST
4829: PUSH
4830: EMPTY
4831: LIST
4832: LIST
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: LIST
4838: PPUSH
4839: CALL_OW 70
4843: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4844: LD_ADDR_VAR 0 11
4848: PUSH
4849: LD_VAR 0 2
4853: PPUSH
4854: LD_INT 22
4856: PUSH
4857: LD_VAR 0 1
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 21
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 3
4878: PUSH
4879: LD_INT 24
4881: PUSH
4882: LD_INT 1000
4884: PUSH
4885: EMPTY
4886: LIST
4887: LIST
4888: PUSH
4889: EMPTY
4890: LIST
4891: LIST
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: LIST
4897: PPUSH
4898: CALL_OW 70
4902: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
4903: LD_VAR 0 10
4907: NOT
4908: PUSH
4909: LD_VAR 0 7
4913: NOT
4914: AND
4915: PUSH
4916: LD_VAR 0 11
4920: NOT
4921: AND
4922: IFFALSE 4926
// exit ;
4924: GO 5115
// if damageUnits > 0 and sci_list > 0 then
4926: LD_VAR 0 10
4930: PUSH
4931: LD_INT 0
4933: GREATER
4934: PUSH
4935: LD_VAR 0 6
4939: PUSH
4940: LD_INT 0
4942: GREATER
4943: AND
4944: IFFALSE 4977
// for i in damageUnits do
4946: LD_ADDR_VAR 0 8
4950: PUSH
4951: LD_VAR 0 10
4955: PUSH
4956: FOR_IN
4957: IFFALSE 4975
// ComMoveToArea ( i , healArea ) ;
4959: LD_VAR 0 8
4963: PPUSH
4964: LD_VAR 0 2
4968: PPUSH
4969: CALL_OW 113
4973: GO 4956
4975: POP
4976: POP
// if unitsToHeal > 0 and sci_list > 0 then
4977: LD_VAR 0 11
4981: PUSH
4982: LD_INT 0
4984: GREATER
4985: PUSH
4986: LD_VAR 0 6
4990: PUSH
4991: LD_INT 0
4993: GREATER
4994: AND
4995: IFFALSE 5054
// begin for i in sci_list do
4997: LD_ADDR_VAR 0 8
5001: PUSH
5002: LD_VAR 0 6
5006: PUSH
5007: FOR_IN
5008: IFFALSE 5052
// begin ComExitBuilding ( i ) ;
5010: LD_VAR 0 8
5014: PPUSH
5015: CALL_OW 122
// for j in unitsToHeal do
5019: LD_ADDR_VAR 0 9
5023: PUSH
5024: LD_VAR 0 11
5028: PUSH
5029: FOR_IN
5030: IFFALSE 5048
// AddComHeal ( i , j ) ;
5032: LD_VAR 0 8
5036: PPUSH
5037: LD_VAR 0 9
5041: PPUSH
5042: CALL_OW 188
5046: GO 5029
5048: POP
5049: POP
// end ;
5050: GO 5007
5052: POP
5053: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
5054: LD_VAR 0 10
5058: PUSH
5059: LD_INT 0
5061: EQUAL
5062: PUSH
5063: LD_VAR 0 11
5067: PUSH
5068: LD_INT 0
5070: EQUAL
5071: AND
5072: PUSH
5073: LD_VAR 0 7
5077: PUSH
5078: LD_INT 0
5080: GREATER
5081: AND
5082: IFFALSE 5115
// for i in sci_listOutside do
5084: LD_ADDR_VAR 0 8
5088: PUSH
5089: LD_VAR 0 7
5093: PUSH
5094: FOR_IN
5095: IFFALSE 5113
// ComEnterUnit ( i , build ) ;
5097: LD_VAR 0 8
5101: PPUSH
5102: LD_VAR 0 4
5106: PPUSH
5107: CALL_OW 120
5111: GO 5094
5113: POP
5114: POP
// end ; end_of_file
5115: LD_VAR 0 5
5119: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
5120: LD_INT 0
5122: PPUSH
5123: PPUSH
// if exist_mode then
5124: LD_VAR 0 2
5128: IFFALSE 5147
// unit := CreateCharacter ( ident ) else
5130: LD_ADDR_VAR 0 4
5134: PUSH
5135: LD_VAR 0 1
5139: PPUSH
5140: CALL_OW 34
5144: ST_TO_ADDR
5145: GO 5162
// unit := NewCharacter ( ident ) ;
5147: LD_ADDR_VAR 0 4
5151: PUSH
5152: LD_VAR 0 1
5156: PPUSH
5157: CALL_OW 25
5161: ST_TO_ADDR
// result := unit ;
5162: LD_ADDR_VAR 0 3
5166: PUSH
5167: LD_VAR 0 4
5171: ST_TO_ADDR
// end ;
5172: LD_VAR 0 3
5176: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
5177: LD_INT 0
5179: PPUSH
5180: PPUSH
5181: PPUSH
// uc_side := GetSide ( b ) ;
5182: LD_ADDR_OWVAR 20
5186: PUSH
5187: LD_VAR 0 2
5191: PPUSH
5192: CALL_OW 255
5196: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
5197: LD_ADDR_OWVAR 21
5201: PUSH
5202: LD_VAR 0 2
5206: PPUSH
5207: CALL_OW 248
5211: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5212: LD_INT 0
5214: PPUSH
5215: LD_INT 1
5217: PPUSH
5218: LD_VAR 0 1
5222: PPUSH
5223: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
5227: LD_ADDR_VAR 0 5
5231: PUSH
5232: LD_VAR 0 2
5236: PPUSH
5237: CALL_OW 254
5241: PUSH
5242: LD_INT 3
5244: MINUS
5245: ST_TO_ADDR
// if dir < 0 then
5246: LD_VAR 0 5
5250: PUSH
5251: LD_INT 0
5253: LESS
5254: IFFALSE 5270
// dir := 6 + dir ;
5256: LD_ADDR_VAR 0 5
5260: PUSH
5261: LD_INT 6
5263: PUSH
5264: LD_VAR 0 5
5268: PLUS
5269: ST_TO_ADDR
// un := CreateHuman ;
5270: LD_ADDR_VAR 0 4
5274: PUSH
5275: CALL_OW 44
5279: ST_TO_ADDR
// SetDir ( un , dir ) ;
5280: LD_VAR 0 4
5284: PPUSH
5285: LD_VAR 0 5
5289: PPUSH
5290: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5294: LD_VAR 0 4
5298: PPUSH
5299: LD_VAR 0 2
5303: PPUSH
5304: CALL_OW 52
// end ;
5308: LD_VAR 0 3
5312: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
5313: LD_INT 0
5315: PPUSH
5316: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
5317: LD_ADDR_VAR 0 2
5321: PUSH
5322: LD_VAR 0 1
5326: PPUSH
5327: LD_INT 1
5329: PPUSH
5330: CALL_OW 289
5334: PUSH
5335: LD_VAR 0 1
5339: PPUSH
5340: LD_INT 2
5342: PPUSH
5343: CALL_OW 289
5347: PUSH
5348: LD_VAR 0 1
5352: PPUSH
5353: LD_INT 3
5355: PPUSH
5356: CALL_OW 289
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: LIST
5365: ST_TO_ADDR
// end ;
5366: LD_VAR 0 2
5370: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
5371: LD_INT 0
5373: PPUSH
5374: PPUSH
5375: PPUSH
5376: PPUSH
// r := 100 ;
5377: LD_ADDR_VAR 0 5
5381: PUSH
5382: LD_INT 100
5384: ST_TO_ADDR
// x := 0 ;
5385: LD_ADDR_VAR 0 6
5389: PUSH
5390: LD_INT 0
5392: ST_TO_ADDR
// while ( x < n ) do
5393: LD_VAR 0 6
5397: PUSH
5398: LD_VAR 0 2
5402: LESS
5403: IFFALSE 5716
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
5405: LD_ADDR_VAR 0 4
5409: PUSH
5410: DOUBLE
5411: LD_INT 1
5413: DEC
5414: ST_TO_ADDR
5415: LD_VAR 0 1
5419: PPUSH
5420: LD_INT 0
5422: PPUSH
5423: CALL_OW 517
5427: PUSH
5428: LD_INT 1
5430: ARRAY
5431: PUSH
5432: FOR_TO
5433: IFFALSE 5712
// begin if r > 50 then
5435: LD_VAR 0 5
5439: PUSH
5440: LD_INT 50
5442: GREATER
5443: IFFALSE 5688
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
5445: LD_VAR 0 1
5449: PPUSH
5450: LD_INT 0
5452: PPUSH
5453: CALL_OW 517
5457: PUSH
5458: LD_INT 1
5460: ARRAY
5461: PUSH
5462: LD_VAR 0 4
5466: ARRAY
5467: PPUSH
5468: LD_VAR 0 1
5472: PPUSH
5473: LD_INT 0
5475: PPUSH
5476: CALL_OW 517
5480: PUSH
5481: LD_INT 2
5483: ARRAY
5484: PUSH
5485: LD_VAR 0 4
5489: ARRAY
5490: PPUSH
5491: CALL_OW 458
5495: NOT
5496: IFFALSE 5672
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , 2 , 0 ) ;
5498: LD_VAR 0 1
5502: PPUSH
5503: LD_INT 0
5505: PPUSH
5506: CALL_OW 517
5510: PUSH
5511: LD_INT 1
5513: ARRAY
5514: PUSH
5515: LD_VAR 0 4
5519: ARRAY
5520: PPUSH
5521: LD_VAR 0 1
5525: PPUSH
5526: LD_INT 0
5528: PPUSH
5529: CALL_OW 517
5533: PUSH
5534: LD_INT 2
5536: ARRAY
5537: PUSH
5538: LD_VAR 0 4
5542: ARRAY
5543: PPUSH
5544: LD_INT 2
5546: PPUSH
5547: LD_INT 0
5549: PPUSH
5550: CALL_OW 454
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
5554: LD_ADDR_EXP 3
5558: PUSH
5559: LD_EXP 3
5563: PPUSH
5564: LD_EXP 3
5568: PUSH
5569: LD_INT 1
5571: PLUS
5572: PPUSH
5573: LD_VAR 0 1
5577: PPUSH
5578: LD_INT 0
5580: PPUSH
5581: CALL_OW 517
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PUSH
5590: LD_VAR 0 4
5594: ARRAY
5595: PPUSH
5596: CALL_OW 2
5600: ST_TO_ADDR
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
5601: LD_ADDR_EXP 3
5605: PUSH
5606: LD_EXP 3
5610: PPUSH
5611: LD_EXP 3
5615: PUSH
5616: LD_INT 1
5618: PLUS
5619: PPUSH
5620: LD_VAR 0 1
5624: PPUSH
5625: LD_INT 0
5627: PPUSH
5628: CALL_OW 517
5632: PUSH
5633: LD_INT 2
5635: ARRAY
5636: PUSH
5637: LD_VAR 0 4
5641: ARRAY
5642: PPUSH
5643: CALL_OW 2
5647: ST_TO_ADDR
// r := 0 ;
5648: LD_ADDR_VAR 0 5
5652: PUSH
5653: LD_INT 0
5655: ST_TO_ADDR
// x := x + 1 ;
5656: LD_ADDR_VAR 0 6
5660: PUSH
5661: LD_VAR 0 6
5665: PUSH
5666: LD_INT 1
5668: PLUS
5669: ST_TO_ADDR
// end else
5670: GO 5686
// r := r + 35 ;
5672: LD_ADDR_VAR 0 5
5676: PUSH
5677: LD_VAR 0 5
5681: PUSH
5682: LD_INT 35
5684: PLUS
5685: ST_TO_ADDR
// end else
5686: GO 5710
// r := r + rand ( 10 , 25 ) ;
5688: LD_ADDR_VAR 0 5
5692: PUSH
5693: LD_VAR 0 5
5697: PUSH
5698: LD_INT 10
5700: PPUSH
5701: LD_INT 25
5703: PPUSH
5704: CALL_OW 12
5708: PLUS
5709: ST_TO_ADDR
// end ;
5710: GO 5432
5712: POP
5713: POP
5714: GO 5393
// end ; end_of_file
5716: LD_VAR 0 3
5720: RET
// on UnitDestroyed ( un ) do var i ;
5721: LD_INT 0
5723: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5724: LD_VAR 0 1
5728: PPUSH
5729: CALL_OW 255
5733: PUSH
5734: LD_INT 3
5736: EQUAL
5737: PUSH
5738: LD_VAR 0 1
5742: PPUSH
5743: CALL_OW 247
5747: PUSH
5748: LD_INT 3
5750: EQUAL
5751: AND
5752: IFFALSE 6444
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5754: LD_VAR 0 1
5758: PPUSH
5759: CALL_OW 266
5763: PUSH
5764: LD_INT 31
5766: EQUAL
5767: PUSH
5768: LD_VAR 0 1
5772: PPUSH
5773: CALL_OW 266
5777: PUSH
5778: LD_INT 32
5780: EQUAL
5781: OR
5782: PUSH
5783: LD_VAR 0 1
5787: PPUSH
5788: CALL_OW 266
5792: PUSH
5793: LD_INT 36
5795: EQUAL
5796: OR
5797: PUSH
5798: LD_VAR 0 1
5802: PPUSH
5803: CALL_OW 266
5807: PUSH
5808: LD_INT 0
5810: EQUAL
5811: OR
5812: PUSH
5813: LD_VAR 0 1
5817: PPUSH
5818: CALL_OW 266
5822: PUSH
5823: LD_INT 24
5825: EQUAL
5826: OR
5827: PUSH
5828: LD_VAR 0 1
5832: PPUSH
5833: CALL_OW 266
5837: PUSH
5838: LD_INT 17
5840: EQUAL
5841: OR
5842: PUSH
5843: LD_VAR 0 1
5847: PPUSH
5848: CALL_OW 266
5852: PUSH
5853: LD_INT 25
5855: EQUAL
5856: OR
5857: PUSH
5858: LD_VAR 0 1
5862: PPUSH
5863: CALL_OW 266
5867: PUSH
5868: LD_INT 19
5870: EQUAL
5871: OR
5872: PUSH
5873: LD_VAR 0 1
5877: PPUSH
5878: CALL_OW 266
5882: PUSH
5883: LD_INT 20
5885: EQUAL
5886: OR
5887: PUSH
5888: LD_VAR 0 1
5892: PPUSH
5893: CALL_OW 266
5897: PUSH
5898: LD_INT 18
5900: EQUAL
5901: OR
5902: PUSH
5903: LD_VAR 0 1
5907: PPUSH
5908: CALL_OW 266
5912: PUSH
5913: LD_INT 21
5915: EQUAL
5916: OR
5917: PUSH
5918: LD_VAR 0 1
5922: PPUSH
5923: CALL_OW 266
5927: PUSH
5928: LD_INT 23
5930: EQUAL
5931: OR
5932: PUSH
5933: LD_VAR 0 1
5937: PPUSH
5938: CALL_OW 266
5942: PUSH
5943: LD_INT 16
5945: EQUAL
5946: OR
5947: PUSH
5948: LD_VAR 0 1
5952: PPUSH
5953: CALL_OW 266
5957: PUSH
5958: LD_INT 6
5960: EQUAL
5961: OR
5962: PUSH
5963: LD_VAR 0 1
5967: PPUSH
5968: CALL_OW 266
5972: PUSH
5973: LD_INT 29
5975: EQUAL
5976: OR
5977: PUSH
5978: LD_VAR 0 1
5982: PPUSH
5983: CALL_OW 266
5987: PUSH
5988: LD_INT 26
5990: EQUAL
5991: OR
5992: PUSH
5993: LD_VAR 0 1
5997: PPUSH
5998: CALL_OW 266
6002: PUSH
6003: LD_INT 30
6005: EQUAL
6006: OR
6007: PUSH
6008: LD_VAR 0 1
6012: PPUSH
6013: CALL_OW 266
6017: PUSH
6018: LD_INT 28
6020: EQUAL
6021: OR
6022: PUSH
6023: LD_VAR 0 1
6027: PPUSH
6028: CALL_OW 266
6032: PUSH
6033: LD_INT 27
6035: EQUAL
6036: OR
6037: PUSH
6038: LD_VAR 0 1
6042: PPUSH
6043: CALL_OW 266
6047: PUSH
6048: LD_INT 33
6050: EQUAL
6051: OR
6052: PUSH
6053: LD_VAR 0 1
6057: PPUSH
6058: CALL_OW 266
6062: PUSH
6063: LD_INT 2
6065: EQUAL
6066: OR
6067: PUSH
6068: LD_VAR 0 1
6072: PPUSH
6073: CALL_OW 266
6077: PUSH
6078: LD_INT 4
6080: EQUAL
6081: OR
6082: IFFALSE 6168
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
6084: LD_ADDR_EXP 1
6088: PUSH
6089: LD_EXP 1
6093: PUSH
6094: LD_VAR 0 1
6098: PPUSH
6099: CALL_OW 266
6103: ADD
6104: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6105: LD_ADDR_EXP 1
6109: PUSH
6110: LD_EXP 1
6114: PUSH
6115: LD_VAR 0 1
6119: PPUSH
6120: CALL_OW 250
6124: ADD
6125: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6126: LD_ADDR_EXP 1
6130: PUSH
6131: LD_EXP 1
6135: PUSH
6136: LD_VAR 0 1
6140: PPUSH
6141: CALL_OW 251
6145: ADD
6146: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6147: LD_ADDR_EXP 1
6151: PUSH
6152: LD_EXP 1
6156: PUSH
6157: LD_VAR 0 1
6161: PPUSH
6162: CALL_OW 254
6166: ADD
6167: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
6168: LD_VAR 0 1
6172: PPUSH
6173: CALL_OW 266
6177: PUSH
6178: LD_INT 1
6180: EQUAL
6181: IFFALSE 6260
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
6183: LD_ADDR_EXP 1
6187: PUSH
6188: LD_EXP 1
6192: PUSH
6193: LD_INT 0
6195: ADD
6196: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6197: LD_ADDR_EXP 1
6201: PUSH
6202: LD_EXP 1
6206: PUSH
6207: LD_VAR 0 1
6211: PPUSH
6212: CALL_OW 250
6216: ADD
6217: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6218: LD_ADDR_EXP 1
6222: PUSH
6223: LD_EXP 1
6227: PUSH
6228: LD_VAR 0 1
6232: PPUSH
6233: CALL_OW 251
6237: ADD
6238: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6239: LD_ADDR_EXP 1
6243: PUSH
6244: LD_EXP 1
6248: PUSH
6249: LD_VAR 0 1
6253: PPUSH
6254: CALL_OW 254
6258: ADD
6259: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
6260: LD_VAR 0 1
6264: PPUSH
6265: CALL_OW 266
6269: PUSH
6270: LD_INT 3
6272: EQUAL
6273: IFFALSE 6352
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
6275: LD_ADDR_EXP 1
6279: PUSH
6280: LD_EXP 1
6284: PUSH
6285: LD_INT 2
6287: ADD
6288: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6289: LD_ADDR_EXP 1
6293: PUSH
6294: LD_EXP 1
6298: PUSH
6299: LD_VAR 0 1
6303: PPUSH
6304: CALL_OW 250
6308: ADD
6309: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6310: LD_ADDR_EXP 1
6314: PUSH
6315: LD_EXP 1
6319: PUSH
6320: LD_VAR 0 1
6324: PPUSH
6325: CALL_OW 251
6329: ADD
6330: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6331: LD_ADDR_EXP 1
6335: PUSH
6336: LD_EXP 1
6340: PUSH
6341: LD_VAR 0 1
6345: PPUSH
6346: CALL_OW 254
6350: ADD
6351: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
6352: LD_VAR 0 1
6356: PPUSH
6357: CALL_OW 266
6361: PUSH
6362: LD_INT 5
6364: EQUAL
6365: IFFALSE 6444
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
6367: LD_ADDR_EXP 1
6371: PUSH
6372: LD_EXP 1
6376: PUSH
6377: LD_INT 4
6379: ADD
6380: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6381: LD_ADDR_EXP 1
6385: PUSH
6386: LD_EXP 1
6390: PUSH
6391: LD_VAR 0 1
6395: PPUSH
6396: CALL_OW 250
6400: ADD
6401: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6402: LD_ADDR_EXP 1
6406: PUSH
6407: LD_EXP 1
6411: PUSH
6412: LD_VAR 0 1
6416: PPUSH
6417: CALL_OW 251
6421: ADD
6422: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6423: LD_ADDR_EXP 1
6427: PUSH
6428: LD_EXP 1
6432: PUSH
6433: LD_VAR 0 1
6437: PPUSH
6438: CALL_OW 254
6442: ADD
6443: ST_TO_ADDR
// end ; end ; if GetSide ( un ) = 3 and GetType ( un ) = unit_vehicle then
6444: LD_VAR 0 1
6448: PPUSH
6449: CALL_OW 255
6453: PUSH
6454: LD_INT 3
6456: EQUAL
6457: PUSH
6458: LD_VAR 0 1
6462: PPUSH
6463: CALL_OW 247
6467: PUSH
6468: LD_INT 2
6470: EQUAL
6471: AND
6472: IFFALSE 6576
// begin for i in CPU1DamageTanks do
6474: LD_ADDR_VAR 0 2
6478: PUSH
6479: LD_EXP 6
6483: PUSH
6484: FOR_IN
6485: IFFALSE 6574
// begin if i = un then
6487: LD_VAR 0 2
6491: PUSH
6492: LD_VAR 0 1
6496: EQUAL
6497: IFFALSE 6572
// begin AddComConstruct ( rufab , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
6499: LD_INT 30
6501: PPUSH
6502: LD_VAR 0 1
6506: PPUSH
6507: CALL_OW 265
6511: PPUSH
6512: LD_VAR 0 1
6516: PPUSH
6517: CALL_OW 262
6521: PPUSH
6522: LD_VAR 0 1
6526: PPUSH
6527: CALL_OW 263
6531: PPUSH
6532: LD_VAR 0 1
6536: PPUSH
6537: CALL_OW 264
6541: PPUSH
6542: CALL_OW 185
// CPU1DamageTanks = Delete ( CPU1DamageTanks , i [ i ] ) ;
6546: LD_ADDR_EXP 6
6550: PUSH
6551: LD_EXP 6
6555: PPUSH
6556: LD_VAR 0 2
6560: PUSH
6561: LD_VAR 0 2
6565: ARRAY
6566: PPUSH
6567: CALL_OW 3
6571: ST_TO_ADDR
// end ; end ;
6572: GO 6484
6574: POP
6575: POP
// end ; end ;
6576: PPOPN 2
6578: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6579: LD_VAR 0 1
6583: PPUSH
6584: CALL_OW 255
6588: PUSH
6589: LD_INT 3
6591: EQUAL
6592: IFFALSE 6666
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6594: LD_ADDR_EXP 1
6598: PUSH
6599: LD_EXP 1
6603: PPUSH
6604: LD_INT 1
6606: PPUSH
6607: CALL_OW 3
6611: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6612: LD_ADDR_EXP 1
6616: PUSH
6617: LD_EXP 1
6621: PPUSH
6622: LD_INT 1
6624: PPUSH
6625: CALL_OW 3
6629: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6630: LD_ADDR_EXP 1
6634: PUSH
6635: LD_EXP 1
6639: PPUSH
6640: LD_INT 1
6642: PPUSH
6643: CALL_OW 3
6647: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6648: LD_ADDR_EXP 1
6652: PUSH
6653: LD_EXP 1
6657: PPUSH
6658: LD_INT 1
6660: PPUSH
6661: CALL_OW 3
6665: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6666: LD_VAR 0 1
6670: PPUSH
6671: CALL_OW 255
6675: PUSH
6676: LD_INT 3
6678: EQUAL
6679: PUSH
6680: LD_VAR 0 1
6684: PPUSH
6685: CALL_OW 266
6689: PUSH
6690: LD_INT 0
6692: EQUAL
6693: PUSH
6694: LD_VAR 0 1
6698: PPUSH
6699: CALL_OW 266
6703: PUSH
6704: LD_INT 2
6706: EQUAL
6707: OR
6708: PUSH
6709: LD_VAR 0 1
6713: PPUSH
6714: CALL_OW 266
6718: PUSH
6719: LD_INT 4
6721: EQUAL
6722: OR
6723: PUSH
6724: EMPTY
6725: LIST
6726: AND
6727: IFFALSE 6738
// ComUpgrade ( building ) ;
6729: LD_VAR 0 1
6733: PPUSH
6734: CALL_OW 146
// end ;
6738: PPOPN 1
6740: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
6741: LD_VAR 0 1
6745: PPUSH
6746: CALL_OW 255
6750: PUSH
6751: LD_INT 3
6753: EQUAL
6754: IFFALSE 6772
// CPU1Tanks = CPU1Tanks ^ vehicle ;
6756: LD_ADDR_EXP 5
6760: PUSH
6761: LD_EXP 5
6765: PUSH
6766: LD_VAR 0 1
6770: ADD
6771: ST_TO_ADDR
// end ;
6772: PPOPN 2
6774: END
// on Command ( command_id ) do begin end ;
6775: PPOPN 1
6777: END
