// export destroyedBuildings ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// end ;
  22: END
// every 0 0$1 do
  23: GO 25
  25: DISABLE
// ComEnterUnit ( eng1 , ee1 ) ; end_of_file
  26: LD_INT 95
  28: PPUSH
  29: LD_INT 94
  31: PPUSH
  32: CALL_OW 120
  36: END
// every 0 0$1 do
  37: GO 39
  39: DISABLE
// begin end ;
  40: END
// every 5 5$1 do
  41: GO 43
  43: DISABLE
// begin end ; end_of_file
  44: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
  45: LD_INT 0
  47: PPUSH
  48: PPUSH
  49: PPUSH
// rnd = rand ( 1 , characters ) ;
  50: LD_ADDR_VAR 0 6
  54: PUSH
  55: LD_INT 1
  57: PPUSH
  58: LD_VAR 0 1
  62: PPUSH
  63: CALL_OW 12
  67: ST_TO_ADDR
// for i = 1 to characters do
  68: LD_ADDR_VAR 0 5
  72: PUSH
  73: DOUBLE
  74: LD_INT 1
  76: DEC
  77: ST_TO_ADDR
  78: LD_VAR 0 1
  82: PUSH
  83: FOR_TO
  84: IFFALSE 194
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
  86: LD_VAR 0 5
  90: PUSH
  91: LD_VAR 0 6
  95: EQUAL
  96: PUSH
  97: LD_VAR 0 1
 101: PUSH
 102: LD_VAR 0 5
 106: ARRAY
 107: PPUSH
 108: CALL_OW 258
 112: PUSH
 113: LD_INT 1
 115: EQUAL
 116: AND
 117: IFFALSE 139
// Say ( characters [ i ] , dialogMID ) ;
 119: LD_VAR 0 1
 123: PUSH
 124: LD_VAR 0 5
 128: ARRAY
 129: PPUSH
 130: LD_VAR 0 2
 134: PPUSH
 135: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 139: LD_VAR 0 5
 143: PUSH
 144: LD_VAR 0 6
 148: EQUAL
 149: PUSH
 150: LD_VAR 0 1
 154: PUSH
 155: LD_VAR 0 5
 159: ARRAY
 160: PPUSH
 161: CALL_OW 258
 165: PUSH
 166: LD_INT 2
 168: EQUAL
 169: AND
 170: IFFALSE 192
// Say ( characters [ i ] , dialogFID ) ;
 172: LD_VAR 0 1
 176: PUSH
 177: LD_VAR 0 5
 181: ARRAY
 182: PPUSH
 183: LD_VAR 0 3
 187: PPUSH
 188: CALL_OW 88
// end ;
 192: GO 83
 194: POP
 195: POP
// end ;
 196: LD_VAR 0 4
 200: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 201: LD_INT 0
 203: PPUSH
 204: PPUSH
 205: PPUSH
 206: PPUSH
// for i = 1 to count do
 207: LD_ADDR_VAR 0 8
 211: PUSH
 212: DOUBLE
 213: LD_INT 1
 215: DEC
 216: ST_TO_ADDR
 217: LD_VAR 0 6
 221: PUSH
 222: FOR_TO
 223: IFFALSE 304
// begin uc_side = side ;
 225: LD_ADDR_OWVAR 20
 229: PUSH
 230: LD_VAR 0 1
 234: ST_TO_ADDR
// uc_nation = nation ;
 235: LD_ADDR_OWVAR 21
 239: PUSH
 240: LD_VAR 0 2
 244: ST_TO_ADDR
// hc_gallery =  ;
 245: LD_ADDR_OWVAR 33
 249: PUSH
 250: LD_STRING 
 252: ST_TO_ADDR
// hc_name =  ;
 253: LD_ADDR_OWVAR 26
 257: PUSH
 258: LD_STRING 
 260: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 261: LD_INT 0
 263: PPUSH
 264: LD_VAR 0 5
 268: PPUSH
 269: LD_VAR 0 4
 273: PPUSH
 274: CALL_OW 380
// un = CreateHuman ;
 278: LD_ADDR_VAR 0 10
 282: PUSH
 283: CALL_OW 44
 287: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 288: LD_VAR 0 10
 292: PPUSH
 293: LD_VAR 0 3
 297: PPUSH
 298: CALL_OW 52
// end ;
 302: GO 222
 304: POP
 305: POP
// end ;
 306: LD_VAR 0 7
 310: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 311: LD_INT 0
 313: PPUSH
 314: PPUSH
// for i in charactersList do
 315: LD_ADDR_VAR 0 4
 319: PUSH
 320: LD_VAR 0 1
 324: PUSH
 325: FOR_IN
 326: IFFALSE 366
// begin if IsOk ( i ) then
 328: LD_VAR 0 4
 332: PPUSH
 333: CALL_OW 302
 337: IFFALSE 355
// begin SaveCharacters ( i , ident ) ;
 339: LD_VAR 0 4
 343: PPUSH
 344: LD_VAR 0 2
 348: PPUSH
 349: CALL_OW 38
// end else
 353: GO 364
// begin DeleteCharacters ( ident ) ;
 355: LD_VAR 0 2
 359: PPUSH
 360: CALL_OW 40
// end ; end ;
 364: GO 325
 366: POP
 367: POP
// end ;
 368: LD_VAR 0 3
 372: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 373: LD_INT 0
 375: PPUSH
 376: PPUSH
 377: PPUSH
 378: PPUSH
 379: PPUSH
 380: PPUSH
 381: PPUSH
 382: PPUSH
 383: PPUSH
 384: PPUSH
 385: PPUSH
// amChassisTab = [ ] ;
 386: LD_ADDR_VAR 0 19
 390: PUSH
 391: EMPTY
 392: ST_TO_ADDR
// arChassisTab = [ ] ;
 393: LD_ADDR_VAR 0 18
 397: PUSH
 398: EMPTY
 399: ST_TO_ADDR
// ruChassisTab = [ ] ;
 400: LD_ADDR_VAR 0 17
 404: PUSH
 405: EMPTY
 406: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 407: LD_INT 35
 409: PPUSH
 410: CALL_OW 67
// if nation = 1 then
 414: LD_VAR 0 5
 418: PUSH
 419: LD_INT 1
 421: EQUAL
 422: IFFALSE 913
// begin uc_side = side ;
 424: LD_ADDR_OWVAR 20
 428: PUSH
 429: LD_VAR 0 2
 433: ST_TO_ADDR
// uc_nation = nation ;
 434: LD_ADDR_OWVAR 21
 438: PUSH
 439: LD_VAR 0 5
 443: ST_TO_ADDR
// vc_engine = vehengine ;
 444: LD_ADDR_OWVAR 39
 448: PUSH
 449: LD_VAR 0 6
 453: ST_TO_ADDR
// vc_control = vehcontrol ;
 454: LD_ADDR_OWVAR 38
 458: PUSH
 459: LD_VAR 0 7
 463: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 464: LD_ADDR_OWVAR 40
 468: PUSH
 469: LD_VAR 0 10
 473: PUSH
 474: LD_INT 1
 476: PPUSH
 477: LD_VAR 0 10
 481: PPUSH
 482: CALL_OW 12
 486: ARRAY
 487: ST_TO_ADDR
// for j = 1 to AMWeapon do
 488: LD_ADDR_VAR 0 14
 492: PUSH
 493: DOUBLE
 494: LD_INT 1
 496: DEC
 497: ST_TO_ADDR
 498: LD_VAR 0 10
 502: PUSH
 503: FOR_TO
 504: IFFALSE 805
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 506: LD_VAR 0 10
 510: PUSH
 511: LD_VAR 0 14
 515: ARRAY
 516: PUSH
 517: LD_INT 2
 519: EQUAL
 520: PUSH
 521: LD_VAR 0 10
 525: PUSH
 526: LD_VAR 0 14
 530: ARRAY
 531: PUSH
 532: LD_INT 3
 534: EQUAL
 535: OR
 536: IFFALSE 589
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 538: LD_ADDR_VAR 0 19
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: LD_INT 4
 554: PUSH
 555: LD_INT 5
 557: PUSH
 558: EMPTY
 559: LIST
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 565: LD_ADDR_OWVAR 37
 569: PUSH
 570: LD_VAR 0 19
 574: PUSH
 575: LD_INT 1
 577: PPUSH
 578: LD_VAR 0 19
 582: PPUSH
 583: CALL_OW 12
 587: ARRAY
 588: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 589: LD_VAR 0 10
 593: PUSH
 594: LD_VAR 0 14
 598: ARRAY
 599: PUSH
 600: LD_INT 4
 602: EQUAL
 603: PUSH
 604: LD_VAR 0 10
 608: PUSH
 609: LD_VAR 0 14
 613: ARRAY
 614: PUSH
 615: LD_INT 5
 617: EQUAL
 618: OR
 619: PUSH
 620: LD_VAR 0 10
 624: PUSH
 625: LD_VAR 0 14
 629: ARRAY
 630: PUSH
 631: LD_INT 9
 633: EQUAL
 634: OR
 635: PUSH
 636: LD_VAR 0 10
 640: PUSH
 641: LD_VAR 0 14
 645: ARRAY
 646: PUSH
 647: LD_INT 11
 649: EQUAL
 650: OR
 651: PUSH
 652: LD_VAR 0 10
 656: PUSH
 657: LD_VAR 0 14
 661: ARRAY
 662: PUSH
 663: LD_INT 7
 665: EQUAL
 666: OR
 667: IFFALSE 716
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
 669: LD_ADDR_VAR 0 19
 673: PUSH
 674: LD_INT 2
 676: PUSH
 677: LD_INT 3
 679: PUSH
 680: LD_INT 4
 682: PUSH
 683: LD_INT 5
 685: PUSH
 686: EMPTY
 687: LIST
 688: LIST
 689: LIST
 690: LIST
 691: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 692: LD_ADDR_OWVAR 37
 696: PUSH
 697: LD_VAR 0 19
 701: PUSH
 702: LD_INT 1
 704: PPUSH
 705: LD_VAR 0 19
 709: PPUSH
 710: CALL_OW 12
 714: ARRAY
 715: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
 716: LD_VAR 0 10
 720: PUSH
 721: LD_VAR 0 14
 725: ARRAY
 726: PUSH
 727: LD_INT 8
 729: EQUAL
 730: PUSH
 731: LD_VAR 0 10
 735: PUSH
 736: LD_VAR 0 14
 740: ARRAY
 741: PUSH
 742: LD_INT 6
 744: EQUAL
 745: OR
 746: PUSH
 747: LD_VAR 0 10
 751: PUSH
 752: LD_VAR 0 14
 756: ARRAY
 757: PUSH
 758: LD_INT 10
 760: EQUAL
 761: OR
 762: IFFALSE 803
// begin amChassisTab = [ 4 , 5 ] ;
 764: LD_ADDR_VAR 0 19
 768: PUSH
 769: LD_INT 4
 771: PUSH
 772: LD_INT 5
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 779: LD_ADDR_OWVAR 37
 783: PUSH
 784: LD_VAR 0 19
 788: PUSH
 789: LD_INT 1
 791: PPUSH
 792: LD_VAR 0 19
 796: PPUSH
 797: CALL_OW 12
 801: ARRAY
 802: ST_TO_ADDR
// end ; end ;
 803: GO 503
 805: POP
 806: POP
// veh = CreateVehicle ;
 807: LD_ADDR_VAR 0 16
 811: PUSH
 812: CALL_OW 45
 816: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
 817: LD_VAR 0 16
 821: PPUSH
 822: LD_VAR 0 1
 826: PPUSH
 827: LD_INT 0
 829: PPUSH
 830: CALL_OW 49
// if vehControl = 1 then
 834: LD_VAR 0 7
 838: PUSH
 839: LD_INT 1
 841: EQUAL
 842: IFFALSE 899
// begin hc_gallery =  ;
 844: LD_ADDR_OWVAR 33
 848: PUSH
 849: LD_STRING 
 851: ST_TO_ADDR
// hc_name =  ;
 852: LD_ADDR_OWVAR 26
 856: PUSH
 857: LD_STRING 
 859: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
 860: LD_INT 0
 862: PPUSH
 863: LD_INT 3
 865: PPUSH
 866: LD_VAR 0 4
 870: PPUSH
 871: CALL_OW 380
// un = CreateHuman ;
 875: LD_ADDR_VAR 0 15
 879: PUSH
 880: CALL_OW 44
 884: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
 885: LD_VAR 0 15
 889: PPUSH
 890: LD_VAR 0 16
 894: PPUSH
 895: CALL_OW 52
// end ; i = i + 1 ;
 899: LD_ADDR_VAR 0 13
 903: PUSH
 904: LD_VAR 0 13
 908: PUSH
 909: LD_INT 1
 911: PLUS
 912: ST_TO_ADDR
// end ; if nation = 2 then
 913: LD_VAR 0 5
 917: PUSH
 918: LD_INT 2
 920: EQUAL
 921: IFFALSE 1345
// begin uc_side = side ;
 923: LD_ADDR_OWVAR 20
 927: PUSH
 928: LD_VAR 0 2
 932: ST_TO_ADDR
// uc_nation = nation ;
 933: LD_ADDR_OWVAR 21
 937: PUSH
 938: LD_VAR 0 5
 942: ST_TO_ADDR
// vc_engine = vehengine ;
 943: LD_ADDR_OWVAR 39
 947: PUSH
 948: LD_VAR 0 6
 952: ST_TO_ADDR
// vc_control = vehcontrol ;
 953: LD_ADDR_OWVAR 38
 957: PUSH
 958: LD_VAR 0 7
 962: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
 963: LD_ADDR_OWVAR 40
 967: PUSH
 968: LD_VAR 0 9
 972: PUSH
 973: LD_INT 1
 975: PPUSH
 976: LD_VAR 0 9
 980: PPUSH
 981: CALL_OW 12
 985: ARRAY
 986: ST_TO_ADDR
// for j = 1 to ARWeapons do
 987: LD_ADDR_VAR 0 14
 991: PUSH
 992: DOUBLE
 993: LD_INT 1
 995: DEC
 996: ST_TO_ADDR
 997: LD_VAR 0 9
1001: PUSH
1002: FOR_TO
1003: IFFALSE 1237
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1005: LD_VAR 0 9
1009: PUSH
1010: LD_VAR 0 14
1014: ARRAY
1015: PUSH
1016: LD_INT 24
1018: EQUAL
1019: PUSH
1020: LD_VAR 0 9
1024: PUSH
1025: LD_VAR 0 14
1029: ARRAY
1030: PUSH
1031: LD_INT 22
1033: EQUAL
1034: OR
1035: PUSH
1036: LD_VAR 0 9
1040: PUSH
1041: LD_VAR 0 14
1045: ARRAY
1046: PUSH
1047: LD_INT 23
1049: EQUAL
1050: OR
1051: PUSH
1052: LD_VAR 0 9
1056: PUSH
1057: LD_VAR 0 14
1061: ARRAY
1062: PUSH
1063: LD_INT 30
1065: EQUAL
1066: OR
1067: IFFALSE 1116
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1069: LD_ADDR_VAR 0 18
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 12
1079: PUSH
1080: LD_INT 13
1082: PUSH
1083: LD_INT 14
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1092: LD_ADDR_OWVAR 37
1096: PUSH
1097: LD_VAR 0 18
1101: PUSH
1102: LD_INT 1
1104: PPUSH
1105: LD_VAR 0 18
1109: PPUSH
1110: CALL_OW 12
1114: ARRAY
1115: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1116: LD_VAR 0 9
1120: PUSH
1121: LD_VAR 0 14
1125: ARRAY
1126: PUSH
1127: LD_INT 29
1129: EQUAL
1130: PUSH
1131: LD_VAR 0 9
1135: PUSH
1136: LD_VAR 0 14
1140: ARRAY
1141: PUSH
1142: LD_INT 28
1144: EQUAL
1145: OR
1146: PUSH
1147: LD_VAR 0 9
1151: PUSH
1152: LD_VAR 0 14
1156: ARRAY
1157: PUSH
1158: LD_INT 27
1160: EQUAL
1161: OR
1162: PUSH
1163: LD_VAR 0 9
1167: PUSH
1168: LD_VAR 0 14
1172: ARRAY
1173: PUSH
1174: LD_INT 26
1176: EQUAL
1177: OR
1178: PUSH
1179: LD_VAR 0 9
1183: PUSH
1184: LD_VAR 0 14
1188: ARRAY
1189: PUSH
1190: LD_INT 25
1192: EQUAL
1193: OR
1194: IFFALSE 1235
// begin arChassisTab = [ 13 , 14 ] ;
1196: LD_ADDR_VAR 0 18
1200: PUSH
1201: LD_INT 13
1203: PUSH
1204: LD_INT 14
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1211: LD_ADDR_OWVAR 37
1215: PUSH
1216: LD_VAR 0 18
1220: PUSH
1221: LD_INT 1
1223: PPUSH
1224: LD_VAR 0 18
1228: PPUSH
1229: CALL_OW 12
1233: ARRAY
1234: ST_TO_ADDR
// end ; end ;
1235: GO 1002
1237: POP
1238: POP
// veh = CreateVehicle ;
1239: LD_ADDR_VAR 0 16
1243: PUSH
1244: CALL_OW 45
1248: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1249: LD_VAR 0 16
1253: PPUSH
1254: LD_VAR 0 1
1258: PPUSH
1259: LD_INT 0
1261: PPUSH
1262: CALL_OW 49
// if vehcontrol = 1 then
1266: LD_VAR 0 7
1270: PUSH
1271: LD_INT 1
1273: EQUAL
1274: IFFALSE 1331
// begin hc_gallery =  ;
1276: LD_ADDR_OWVAR 33
1280: PUSH
1281: LD_STRING 
1283: ST_TO_ADDR
// hc_name =  ;
1284: LD_ADDR_OWVAR 26
1288: PUSH
1289: LD_STRING 
1291: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1292: LD_INT 0
1294: PPUSH
1295: LD_INT 3
1297: PPUSH
1298: LD_VAR 0 4
1302: PPUSH
1303: CALL_OW 380
// un = CreateHuman ;
1307: LD_ADDR_VAR 0 15
1311: PUSH
1312: CALL_OW 44
1316: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1317: LD_VAR 0 15
1321: PPUSH
1322: LD_VAR 0 16
1326: PPUSH
1327: CALL_OW 52
// end ; i = i + 1 ;
1331: LD_ADDR_VAR 0 13
1335: PUSH
1336: LD_VAR 0 13
1340: PUSH
1341: LD_INT 1
1343: PLUS
1344: ST_TO_ADDR
// end ; if nation = 3 then
1345: LD_VAR 0 5
1349: PUSH
1350: LD_INT 3
1352: EQUAL
1353: IFFALSE 1745
// begin uc_side = side ;
1355: LD_ADDR_OWVAR 20
1359: PUSH
1360: LD_VAR 0 2
1364: ST_TO_ADDR
// uc_nation = nation ;
1365: LD_ADDR_OWVAR 21
1369: PUSH
1370: LD_VAR 0 5
1374: ST_TO_ADDR
// vc_engine = vehengine ;
1375: LD_ADDR_OWVAR 39
1379: PUSH
1380: LD_VAR 0 6
1384: ST_TO_ADDR
// vc_control = vehcontrol ;
1385: LD_ADDR_OWVAR 38
1389: PUSH
1390: LD_VAR 0 7
1394: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1395: LD_ADDR_OWVAR 40
1399: PUSH
1400: LD_VAR 0 8
1404: PUSH
1405: LD_INT 1
1407: PPUSH
1408: LD_VAR 0 8
1412: PPUSH
1413: CALL_OW 12
1417: ARRAY
1418: ST_TO_ADDR
// for j = 1 to RuWeapons do
1419: LD_ADDR_VAR 0 14
1423: PUSH
1424: DOUBLE
1425: LD_INT 1
1427: DEC
1428: ST_TO_ADDR
1429: LD_VAR 0 8
1433: PUSH
1434: FOR_TO
1435: IFFALSE 1637
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1437: LD_VAR 0 8
1441: PUSH
1442: LD_VAR 0 14
1446: ARRAY
1447: PUSH
1448: LD_INT 42
1450: EQUAL
1451: PUSH
1452: LD_VAR 0 8
1456: PUSH
1457: LD_VAR 0 14
1461: ARRAY
1462: PUSH
1463: LD_INT 43
1465: EQUAL
1466: OR
1467: PUSH
1468: LD_VAR 0 8
1472: PUSH
1473: LD_VAR 0 14
1477: ARRAY
1478: PUSH
1479: LD_INT 44
1481: EQUAL
1482: OR
1483: PUSH
1484: LD_VAR 0 8
1488: PUSH
1489: LD_VAR 0 14
1493: ARRAY
1494: PUSH
1495: LD_INT 45
1497: EQUAL
1498: OR
1499: PUSH
1500: LD_VAR 0 8
1504: PUSH
1505: LD_VAR 0 14
1509: ARRAY
1510: PUSH
1511: LD_INT 49
1513: EQUAL
1514: OR
1515: IFFALSE 1564
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1517: LD_ADDR_VAR 0 17
1521: PUSH
1522: LD_INT 21
1524: PUSH
1525: LD_INT 22
1527: PUSH
1528: LD_INT 23
1530: PUSH
1531: LD_INT 24
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1540: LD_ADDR_OWVAR 37
1544: PUSH
1545: LD_VAR 0 17
1549: PUSH
1550: LD_INT 1
1552: PPUSH
1553: LD_VAR 0 17
1557: PPUSH
1558: CALL_OW 12
1562: ARRAY
1563: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1564: LD_VAR 0 8
1568: PUSH
1569: LD_VAR 0 14
1573: ARRAY
1574: PUSH
1575: LD_INT 46
1577: EQUAL
1578: PUSH
1579: LD_VAR 0 8
1583: PUSH
1584: LD_VAR 0 14
1588: ARRAY
1589: PUSH
1590: LD_INT 47
1592: EQUAL
1593: OR
1594: IFFALSE 1635
// begin ruChassisTab = [ 23 , 24 ] ;
1596: LD_ADDR_VAR 0 17
1600: PUSH
1601: LD_INT 23
1603: PUSH
1604: LD_INT 24
1606: PUSH
1607: EMPTY
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1611: LD_ADDR_OWVAR 37
1615: PUSH
1616: LD_VAR 0 17
1620: PUSH
1621: LD_INT 1
1623: PPUSH
1624: LD_VAR 0 17
1628: PPUSH
1629: CALL_OW 12
1633: ARRAY
1634: ST_TO_ADDR
// end ; end ;
1635: GO 1434
1637: POP
1638: POP
// veh = CreateVehicle ;
1639: LD_ADDR_VAR 0 16
1643: PUSH
1644: CALL_OW 45
1648: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1649: LD_VAR 0 16
1653: PPUSH
1654: LD_VAR 0 1
1658: PPUSH
1659: LD_INT 0
1661: PPUSH
1662: CALL_OW 49
// if vehcontrol = 1 then
1666: LD_VAR 0 7
1670: PUSH
1671: LD_INT 1
1673: EQUAL
1674: IFFALSE 1731
// begin hc_gallery =  ;
1676: LD_ADDR_OWVAR 33
1680: PUSH
1681: LD_STRING 
1683: ST_TO_ADDR
// hc_name =  ;
1684: LD_ADDR_OWVAR 26
1688: PUSH
1689: LD_STRING 
1691: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1692: LD_INT 0
1694: PPUSH
1695: LD_INT 3
1697: PPUSH
1698: LD_VAR 0 4
1702: PPUSH
1703: CALL_OW 380
// un = CreateHuman ;
1707: LD_ADDR_VAR 0 15
1711: PUSH
1712: CALL_OW 44
1716: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1717: LD_VAR 0 15
1721: PPUSH
1722: LD_VAR 0 16
1726: PPUSH
1727: CALL_OW 52
// end ; i = i + 1 ;
1731: LD_ADDR_VAR 0 13
1735: PUSH
1736: LD_VAR 0 13
1740: PUSH
1741: LD_INT 1
1743: PLUS
1744: ST_TO_ADDR
// end ; until i = vehCount ;
1745: LD_VAR 0 13
1749: PUSH
1750: LD_VAR 0 3
1754: EQUAL
1755: IFFALSE 407
// repeat wait ( 0 0$1 ) ;
1757: LD_INT 35
1759: PPUSH
1760: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
1764: LD_ADDR_VAR 0 20
1768: PUSH
1769: LD_INT 22
1771: PUSH
1772: LD_VAR 0 2
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 21
1783: PUSH
1784: LD_INT 2
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: PUSH
1791: LD_INT 24
1793: PUSH
1794: LD_INT 650
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PPUSH
1806: CALL_OW 69
1810: ST_TO_ADDR
// if vehicleOK_list > 0 then
1811: LD_VAR 0 20
1815: PUSH
1816: LD_INT 0
1818: GREATER
1819: IFFALSE 2010
// begin for i in vehicleOK_list do
1821: LD_ADDR_VAR 0 13
1825: PUSH
1826: LD_VAR 0 20
1830: PUSH
1831: FOR_IN
1832: IFFALSE 2008
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
1834: LD_ADDR_VAR 0 21
1838: PUSH
1839: LD_INT 22
1841: PUSH
1842: LD_VAR 0 11
1846: PUSH
1847: EMPTY
1848: LIST
1849: LIST
1850: PPUSH
1851: CALL_OW 69
1855: PPUSH
1856: LD_VAR 0 13
1860: PPUSH
1861: CALL_OW 74
1865: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
1866: LD_ADDR_VAR 0 22
1870: PUSH
1871: LD_INT 22
1873: PUSH
1874: LD_VAR 0 11
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 2
1885: PUSH
1886: LD_INT 59
1888: PUSH
1889: EMPTY
1890: LIST
1891: PUSH
1892: LD_INT 21
1894: PUSH
1895: LD_INT 1
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: LD_INT 21
1904: PUSH
1905: LD_INT 2
1907: PUSH
1908: EMPTY
1909: LIST
1910: LIST
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: PUSH
1922: EMPTY
1923: LIST
1924: PPUSH
1925: CALL_OW 69
1929: PPUSH
1930: LD_VAR 0 13
1934: PPUSH
1935: CALL_OW 74
1939: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
1940: LD_VAR 0 13
1944: PPUSH
1945: LD_VAR 0 21
1949: PPUSH
1950: CALL_OW 296
1954: PUSH
1955: LD_INT 8
1957: PLUS
1958: PUSH
1959: LD_VAR 0 13
1963: PPUSH
1964: LD_VAR 0 22
1968: PPUSH
1969: CALL_OW 296
1973: LESS
1974: IFFALSE 1992
// begin ComAttackUnit ( i , target1 ) ;
1976: LD_VAR 0 13
1980: PPUSH
1981: LD_VAR 0 21
1985: PPUSH
1986: CALL_OW 115
// end else
1990: GO 2006
// begin ComAttackUnit ( i , target2 ) ;
1992: LD_VAR 0 13
1996: PPUSH
1997: LD_VAR 0 22
2001: PPUSH
2002: CALL_OW 115
// end ; end ;
2006: GO 1831
2008: POP
2009: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2010: LD_INT 22
2012: PUSH
2013: LD_VAR 0 2
2017: PUSH
2018: EMPTY
2019: LIST
2020: LIST
2021: PUSH
2022: LD_INT 21
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: EMPTY
2029: LIST
2030: LIST
2031: PUSH
2032: EMPTY
2033: LIST
2034: LIST
2035: PPUSH
2036: CALL_OW 69
2040: PUSH
2041: LD_INT 0
2043: EQUAL
2044: IFFALSE 1757
// end ;
2046: LD_VAR 0 12
2050: RET
// every 0 0$1 do
2051: GO 2053
2053: DISABLE
// begin enable ;
2054: ENABLE
// end ;
2055: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2056: LD_INT 0
2058: PPUSH
2059: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2060: LD_INT 22
2062: PUSH
2063: LD_VAR 0 1
2067: PUSH
2068: EMPTY
2069: LIST
2070: LIST
2071: PUSH
2072: LD_INT 21
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: EMPTY
2079: LIST
2080: LIST
2081: PUSH
2082: EMPTY
2083: LIST
2084: LIST
2085: PPUSH
2086: CALL_OW 69
2090: PUSH
2091: LD_VAR 0 3
2095: LESSEQUAL
2096: IFFALSE 2163
// for i = 1 to vehCount do
2098: LD_ADDR_VAR 0 9
2102: PUSH
2103: DOUBLE
2104: LD_INT 1
2106: DEC
2107: ST_TO_ADDR
2108: LD_VAR 0 3
2112: PUSH
2113: FOR_TO
2114: IFFALSE 2161
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2116: LD_VAR 0 2
2120: PPUSH
2121: LD_VAR 0 7
2125: PPUSH
2126: LD_VAR 0 5
2130: PPUSH
2131: LD_VAR 0 6
2135: PPUSH
2136: LD_VAR 0 4
2140: PUSH
2141: LD_INT 1
2143: PPUSH
2144: LD_VAR 0 4
2148: PPUSH
2149: CALL_OW 12
2153: ARRAY
2154: PPUSH
2155: CALL_OW 185
2159: GO 2113
2161: POP
2162: POP
// end ;
2163: LD_VAR 0 8
2167: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2168: LD_INT 0
2170: PPUSH
2171: PPUSH
2172: PPUSH
2173: PPUSH
2174: PPUSH
// for i := 1 to CPU1Tanks do
2175: LD_ADDR_VAR 0 4
2179: PUSH
2180: DOUBLE
2181: LD_INT 1
2183: DEC
2184: ST_TO_ADDR
2185: LD_EXP 3
2189: PUSH
2190: FOR_TO
2191: IFFALSE 2519
// begin if i = 4 then
2193: LD_VAR 0 4
2197: PUSH
2198: LD_INT 4
2200: EQUAL
2201: IFFALSE 2517
// begin repeat wait ( 0 0$1 ) ;
2203: LD_INT 35
2205: PPUSH
2206: CALL_OW 67
// for i in CPU1Tanks do
2210: LD_ADDR_VAR 0 4
2214: PUSH
2215: LD_EXP 3
2219: PUSH
2220: FOR_IN
2221: IFFALSE 2505
// begin if GetLives ( i ) < 659 then
2223: LD_VAR 0 4
2227: PPUSH
2228: CALL_OW 256
2232: PUSH
2233: LD_INT 659
2235: LESS
2236: IFFALSE 2324
// begin tmp = i ;
2238: LD_ADDR_VAR 0 5
2242: PUSH
2243: LD_VAR 0 4
2247: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2248: LD_ADDR_VAR 0 4
2252: PUSH
2253: DOUBLE
2254: LD_INT 1
2256: DEC
2257: ST_TO_ADDR
2258: LD_EXP 3
2262: PUSH
2263: FOR_TO
2264: IFFALSE 2322
// begin if tmp = CPU1Tanks [ i ] then
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 3
2275: PUSH
2276: LD_VAR 0 4
2280: ARRAY
2281: EQUAL
2282: IFFALSE 2320
// begin CPU1Tanks = Delete ( CPU1Tanks , i ) ;
2284: LD_ADDR_EXP 3
2288: PUSH
2289: LD_EXP 3
2293: PPUSH
2294: LD_VAR 0 4
2298: PPUSH
2299: CALL_OW 3
2303: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2304: LD_ADDR_EXP 4
2308: PUSH
2309: LD_EXP 4
2313: PUSH
2314: LD_VAR 0 5
2318: ADD
2319: ST_TO_ADDR
// end ; end ;
2320: GO 2263
2322: POP
2323: POP
// end ; wait ( 0 0$1 ) ;
2324: LD_INT 35
2326: PPUSH
2327: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2331: LD_ADDR_VAR 0 6
2335: PUSH
2336: LD_INT 22
2338: PUSH
2339: LD_VAR 0 2
2343: PUSH
2344: EMPTY
2345: LIST
2346: LIST
2347: PPUSH
2348: CALL_OW 69
2352: PPUSH
2353: LD_VAR 0 4
2357: PPUSH
2358: CALL_OW 74
2362: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2363: LD_ADDR_VAR 0 7
2367: PUSH
2368: LD_INT 22
2370: PUSH
2371: LD_VAR 0 2
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 2
2382: PUSH
2383: LD_INT 59
2385: PUSH
2386: EMPTY
2387: LIST
2388: PUSH
2389: LD_INT 21
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: EMPTY
2396: LIST
2397: LIST
2398: PUSH
2399: LD_INT 21
2401: PUSH
2402: LD_INT 2
2404: PUSH
2405: EMPTY
2406: LIST
2407: LIST
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: LIST
2413: LIST
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: PUSH
2419: EMPTY
2420: LIST
2421: PPUSH
2422: CALL_OW 69
2426: PPUSH
2427: LD_VAR 0 4
2431: PPUSH
2432: CALL_OW 74
2436: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2437: LD_VAR 0 4
2441: PPUSH
2442: LD_VAR 0 6
2446: PPUSH
2447: CALL_OW 296
2451: PUSH
2452: LD_INT 8
2454: PLUS
2455: PUSH
2456: LD_VAR 0 4
2460: PPUSH
2461: LD_VAR 0 7
2465: PPUSH
2466: CALL_OW 296
2470: LESS
2471: IFFALSE 2489
// begin ComAttackUnit ( i , target1 ) ;
2473: LD_VAR 0 4
2477: PPUSH
2478: LD_VAR 0 6
2482: PPUSH
2483: CALL_OW 115
// end else
2487: GO 2503
// begin ComAttackUnit ( i , target2 ) ;
2489: LD_VAR 0 4
2493: PPUSH
2494: LD_VAR 0 7
2498: PPUSH
2499: CALL_OW 115
// end ; end ;
2503: GO 2220
2505: POP
2506: POP
// until CPU1Tanks = 0 ;
2507: LD_EXP 3
2511: PUSH
2512: LD_INT 0
2514: EQUAL
2515: IFFALSE 2203
// end ; end ;
2517: GO 2190
2519: POP
2520: POP
// end ;
2521: LD_VAR 0 3
2525: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2526: LD_INT 0
2528: PPUSH
2529: PPUSH
2530: PPUSH
2531: PPUSH
2532: PPUSH
2533: PPUSH
2534: PPUSH
2535: PPUSH
2536: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
2537: LD_ADDR_VAR 0 8
2541: PUSH
2542: LD_INT 22
2544: PUSH
2545: LD_VAR 0 1
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 21
2556: PUSH
2557: LD_INT 2
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: PUSH
2564: LD_INT 24
2566: PUSH
2567: LD_INT 660
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PUSH
2574: LD_INT 3
2576: PUSH
2577: LD_INT 58
2579: PUSH
2580: EMPTY
2581: LIST
2582: PUSH
2583: EMPTY
2584: LIST
2585: LIST
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2598: LD_ADDR_VAR 0 9
2602: PUSH
2603: LD_INT 22
2605: PUSH
2606: LD_VAR 0 1
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 2
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: LD_INT 3
2627: PUSH
2628: LD_INT 24
2630: PUSH
2631: LD_INT 660
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: EMPTY
2639: LIST
2640: LIST
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: LIST
2646: PPUSH
2647: CALL_OW 69
2651: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2652: LD_ADDR_VAR 0 10
2656: PUSH
2657: LD_VAR 0 2
2661: PPUSH
2662: LD_INT 22
2664: PUSH
2665: LD_VAR 0 1
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PUSH
2674: LD_INT 21
2676: PUSH
2677: LD_INT 2
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PUSH
2684: LD_INT 3
2686: PUSH
2687: LD_INT 24
2689: PUSH
2690: LD_INT 1000
2692: PUSH
2693: EMPTY
2694: LIST
2695: LIST
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: PPUSH
2706: CALL_OW 70
2710: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
2711: LD_ADDR_VAR 0 11
2715: PUSH
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 22
2723: PUSH
2724: LD_VAR 0 1
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 21
2735: PUSH
2736: LD_INT 2
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PUSH
2743: LD_INT 24
2745: PUSH
2746: LD_INT 1000
2748: PUSH
2749: EMPTY
2750: LIST
2751: LIST
2752: PUSH
2753: LD_INT 58
2755: PUSH
2756: EMPTY
2757: LIST
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: LIST
2764: PPUSH
2765: CALL_OW 70
2769: ST_TO_ADDR
// mechanicInside_list = [ ] ;
2770: LD_ADDR_VAR 0 12
2774: PUSH
2775: EMPTY
2776: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
2777: LD_ADDR_VAR 0 13
2781: PUSH
2782: LD_VAR 0 2
2786: PPUSH
2787: LD_INT 22
2789: PUSH
2790: LD_VAR 0 1
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: PUSH
2799: LD_INT 25
2801: PUSH
2802: LD_INT 3
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: PPUSH
2813: CALL_OW 70
2817: ST_TO_ADDR
// display_strings = [ w polu:  , CPU1Tanks , uszkodzone:  , CPU1DamageTanks , wylosowane: 4 , ok , vehicleOK_list ] ;
2818: LD_ADDR_OWVAR 47
2822: PUSH
2823: LD_STRING w polu: 
2825: PUSH
2826: LD_EXP 3
2830: PUSH
2831: LD_STRING uszkodzone: 
2833: PUSH
2834: LD_EXP 4
2838: PUSH
2839: LD_STRING wylosowane: 4
2841: PUSH
2842: LD_STRING ok
2844: PUSH
2845: LD_VAR 0 8
2849: PUSH
2850: EMPTY
2851: LIST
2852: LIST
2853: LIST
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: ST_TO_ADDR
// if damageVehicle_list > 0 then
2859: LD_VAR 0 9
2863: PUSH
2864: LD_INT 0
2866: GREATER
2867: IFFALSE 2905
// for i in damageVehicle_list do
2869: LD_ADDR_VAR 0 6
2873: PUSH
2874: LD_VAR 0 9
2878: PUSH
2879: FOR_IN
2880: IFFALSE 2903
// ComMoveXY ( i , repX , repY ) ;
2882: LD_VAR 0 6
2886: PPUSH
2887: LD_VAR 0 3
2891: PPUSH
2892: LD_VAR 0 4
2896: PPUSH
2897: CALL_OW 111
2901: GO 2879
2903: POP
2904: POP
// if vehicleNeedRepair_list > 0 then
2905: LD_VAR 0 10
2909: PUSH
2910: LD_INT 0
2912: GREATER
2913: IFFALSE 3000
// begin for i in vehicleNeedRepair_list do
2915: LD_ADDR_VAR 0 6
2919: PUSH
2920: LD_VAR 0 10
2924: PUSH
2925: FOR_IN
2926: IFFALSE 2998
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
2928: LD_ADDR_VAR 0 12
2932: PUSH
2933: LD_VAR 0 12
2937: PUSH
2938: LD_VAR 0 6
2942: PPUSH
2943: CALL_OW 313
2947: ADD
2948: ST_TO_ADDR
// for j in mechanicInside_list do
2949: LD_ADDR_VAR 0 7
2953: PUSH
2954: LD_VAR 0 12
2958: PUSH
2959: FOR_IN
2960: IFFALSE 2994
// begin ComExitVehicle ( j ) ;
2962: LD_VAR 0 7
2966: PPUSH
2967: CALL_OW 121
// wait ( 0 0$1 ) ;
2971: LD_INT 35
2973: PPUSH
2974: CALL_OW 67
// AddComRepairVehicle ( j , i ) ;
2978: LD_VAR 0 7
2982: PPUSH
2983: LD_VAR 0 6
2987: PPUSH
2988: CALL_OW 189
// end ;
2992: GO 2959
2994: POP
2995: POP
// end ;
2996: GO 2925
2998: POP
2999: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3000: LD_VAR 0 11
3004: PUSH
3005: LD_INT 0
3007: GREATER
3008: IFFALSE 3032
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3010: LD_VAR 0 13
3014: PUSH
3015: LD_INT 1
3017: ARRAY
3018: PPUSH
3019: LD_VAR 0 11
3023: PUSH
3024: LD_INT 1
3026: ARRAY
3027: PPUSH
3028: CALL_OW 120
// end ; if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3032: LD_VAR 0 8
3036: PUSH
3037: LD_INT 0
3039: GREATER
3040: PUSH
3041: LD_EXP 4
3045: PUSH
3046: LD_INT 0
3048: GREATER
3049: AND
3050: IFFALSE 3191
// begin for i := 1 to vehicleOK_list do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 8
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3189
// begin if i = 4 then
3070: LD_VAR 0 6
3074: PUSH
3075: LD_INT 4
3077: EQUAL
3078: IFFALSE 3187
// begin for i in vehicleOK_list do
3080: LD_ADDR_VAR 0 6
3084: PUSH
3085: LD_VAR 0 8
3089: PUSH
3090: FOR_IN
3091: IFFALSE 3111
// CPU1Tanks = CPU1Tanks ^ i ;
3093: LD_ADDR_EXP 3
3097: PUSH
3098: LD_EXP 3
3102: PUSH
3103: LD_VAR 0 6
3107: ADD
3108: ST_TO_ADDR
3109: GO 3090
3111: POP
3112: POP
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3113: LD_ADDR_EXP 4
3117: PUSH
3118: LD_EXP 4
3122: PPUSH
3123: LD_INT 1
3125: PPUSH
3126: CALL_OW 3
3130: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3131: LD_ADDR_EXP 4
3135: PUSH
3136: LD_EXP 4
3140: PPUSH
3141: LD_INT 1
3143: PPUSH
3144: CALL_OW 3
3148: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3149: LD_ADDR_EXP 4
3153: PUSH
3154: LD_EXP 4
3158: PPUSH
3159: LD_INT 1
3161: PPUSH
3162: CALL_OW 3
3166: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3167: LD_ADDR_EXP 4
3171: PUSH
3172: LD_EXP 4
3176: PPUSH
3177: LD_INT 1
3179: PPUSH
3180: CALL_OW 3
3184: ST_TO_ADDR
// break ;
3185: GO 3189
// end ; end ;
3187: GO 3067
3189: POP
3190: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3191: LD_ADDR_VAR 0 6
3195: PUSH
3196: LD_VAR 0 2
3200: PPUSH
3201: LD_INT 22
3203: PUSH
3204: LD_VAR 0 1
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 3
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PPUSH
3227: CALL_OW 70
3231: NOT
3232: PUSH
3233: FOR_IN
3234: IFFALSE 3257
// ComMoveXY ( i , repX , repY ) ;
3236: LD_VAR 0 6
3240: PPUSH
3241: LD_VAR 0 3
3245: PPUSH
3246: LD_VAR 0 4
3250: PPUSH
3251: CALL_OW 111
3255: GO 3233
3257: POP
3258: POP
// end ;
3259: LD_VAR 0 5
3263: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3264: LD_INT 0
3266: PPUSH
3267: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3268: LD_INT 22
3270: PUSH
3271: LD_VAR 0 1
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PUSH
3280: LD_INT 25
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PPUSH
3294: CALL_OW 69
3298: PUSH
3299: LD_INT 0
3301: GREATER
3302: PUSH
3303: LD_INT 22
3305: PUSH
3306: LD_VAR 0 1
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 21
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 24
3330: PUSH
3331: LD_INT 1000
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: LIST
3346: PPUSH
3347: CALL_OW 69
3351: PUSH
3352: LD_INT 0
3354: EQUAL
3355: AND
3356: PUSH
3357: LD_VAR 0 2
3361: PUSH
3362: LD_INT 0
3364: GREATER
3365: AND
3366: IFFALSE 3465
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3368: LD_ADDR_VAR 0 4
3372: PUSH
3373: LD_INT 22
3375: PUSH
3376: LD_VAR 0 1
3380: PUSH
3381: EMPTY
3382: LIST
3383: LIST
3384: PUSH
3385: LD_INT 25
3387: PUSH
3388: LD_INT 2
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: PPUSH
3399: CALL_OW 69
3403: PUSH
3404: FOR_IN
3405: IFFALSE 3463
// begin AddComExitBuilding ( i ) ;
3407: LD_VAR 0 4
3411: PPUSH
3412: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3416: LD_VAR 0 4
3420: PPUSH
3421: LD_VAR 0 2
3425: PUSH
3426: LD_INT 1
3428: ARRAY
3429: PPUSH
3430: LD_VAR 0 2
3434: PUSH
3435: LD_INT 2
3437: ARRAY
3438: PPUSH
3439: LD_VAR 0 2
3443: PUSH
3444: LD_INT 3
3446: ARRAY
3447: PPUSH
3448: LD_VAR 0 2
3452: PUSH
3453: LD_INT 4
3455: ARRAY
3456: PPUSH
3457: CALL_OW 205
// end ;
3461: GO 3404
3463: POP
3464: POP
// end ; end ;
3465: LD_VAR 0 3
3469: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3470: LD_INT 0
3472: PPUSH
3473: PPUSH
3474: PPUSH
3475: PPUSH
3476: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_INT 22
3484: PUSH
3485: LD_VAR 0 1
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: PUSH
3494: LD_INT 2
3496: PUSH
3497: LD_INT 30
3499: PUSH
3500: LD_INT 31
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PUSH
3507: LD_INT 30
3509: PUSH
3510: LD_INT 32
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PUSH
3517: LD_INT 30
3519: PUSH
3520: LD_INT 33
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 30
3529: PUSH
3530: LD_INT 4
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: PUSH
3537: LD_INT 30
3539: PUSH
3540: LD_INT 5
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PPUSH
3559: CALL_OW 69
3563: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3564: LD_ADDR_VAR 0 7
3568: PUSH
3569: LD_INT 22
3571: PUSH
3572: LD_VAR 0 2
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PUSH
3581: LD_INT 21
3583: PUSH
3584: LD_INT 3
3586: PUSH
3587: EMPTY
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 58
3593: PUSH
3594: EMPTY
3595: LIST
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: LIST
3601: PPUSH
3602: CALL_OW 69
3606: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3607: LD_VAR 0 6
3611: PUSH
3612: LD_INT 0
3614: GREATER
3615: PUSH
3616: LD_VAR 0 7
3620: PUSH
3621: LD_INT 0
3623: GREATER
3624: AND
3625: IFFALSE 3695
// begin for i in turretsList do
3627: LD_ADDR_VAR 0 4
3631: PUSH
3632: LD_VAR 0 6
3636: PUSH
3637: FOR_IN
3638: IFFALSE 3693
// begin for j in enemyBuildings do
3640: LD_ADDR_VAR 0 5
3644: PUSH
3645: LD_VAR 0 7
3649: PUSH
3650: FOR_IN
3651: IFFALSE 3689
// begin if GetDistUnits ( i , j ) < 20 then
3653: LD_VAR 0 4
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: CALL_OW 296
3667: PUSH
3668: LD_INT 20
3670: LESS
3671: IFFALSE 3687
// begin ComAttackUnit ( i , j ) ;
3673: LD_VAR 0 4
3677: PPUSH
3678: LD_VAR 0 5
3682: PPUSH
3683: CALL_OW 115
// end ; end ;
3687: GO 3650
3689: POP
3690: POP
// end ;
3691: GO 3637
3693: POP
3694: POP
// end ; end ;
3695: LD_VAR 0 3
3699: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3700: LD_INT 0
3702: PPUSH
3703: PPUSH
3704: PPUSH
3705: PPUSH
3706: PPUSH
3707: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3708: LD_ADDR_VAR 0 7
3712: PUSH
3713: LD_INT 22
3715: PUSH
3716: LD_VAR 0 1
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 25
3727: PUSH
3728: LD_INT 9
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PPUSH
3739: CALL_OW 69
3743: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3744: LD_ADDR_VAR 0 8
3748: PUSH
3749: LD_INT 22
3751: PUSH
3752: LD_VAR 0 2
3756: PUSH
3757: EMPTY
3758: LIST
3759: LIST
3760: PUSH
3761: LD_INT 3
3763: PUSH
3764: LD_INT 21
3766: PUSH
3767: LD_INT 3
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PPUSH
3782: CALL_OW 69
3786: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3787: LD_ADDR_VAR 0 5
3791: PUSH
3792: LD_INT 1
3794: PPUSH
3795: LD_INT 3
3797: PPUSH
3798: CALL_OW 12
3802: ST_TO_ADDR
// for i = 1 to list do
3803: LD_ADDR_VAR 0 6
3807: PUSH
3808: DOUBLE
3809: LD_INT 1
3811: DEC
3812: ST_TO_ADDR
3813: LD_VAR 0 7
3817: PUSH
3818: FOR_TO
3819: IFFALSE 4001
// for ta in filter do
3821: LD_ADDR_VAR 0 4
3825: PUSH
3826: LD_VAR 0 8
3830: PUSH
3831: FOR_IN
3832: IFFALSE 3997
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3834: LD_VAR 0 7
3838: PUSH
3839: LD_VAR 0 6
3843: ARRAY
3844: PPUSH
3845: LD_VAR 0 4
3849: PPUSH
3850: CALL_OW 296
3854: PUSH
3855: LD_INT 13
3857: LESSEQUAL
3858: IFFALSE 3995
// begin case c of 1 :
3860: LD_VAR 0 5
3864: PUSH
3865: LD_INT 1
3867: DOUBLE
3868: EQUAL
3869: IFTRUE 3873
3871: GO 3911
3873: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3874: LD_VAR 0 7
3878: PUSH
3879: LD_VAR 0 6
3883: ARRAY
3884: PPUSH
3885: LD_VAR 0 4
3889: PPUSH
3890: CALL_OW 250
3894: PPUSH
3895: LD_VAR 0 4
3899: PPUSH
3900: CALL_OW 251
3904: PPUSH
3905: CALL_OW 154
3909: GO 3995
3911: LD_INT 2
3913: DOUBLE
3914: EQUAL
3915: IFTRUE 3919
3917: GO 3983
3919: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
3920: LD_VAR 0 7
3924: PUSH
3925: LD_VAR 0 6
3929: ARRAY
3930: PPUSH
3931: LD_VAR 0 4
3935: PPUSH
3936: CALL_OW 250
3940: PUSH
3941: LD_INT 1
3943: NEG
3944: PPUSH
3945: LD_INT 1
3947: PPUSH
3948: CALL_OW 12
3952: PLUS
3953: PPUSH
3954: LD_VAR 0 4
3958: PPUSH
3959: CALL_OW 251
3963: PUSH
3964: LD_INT 1
3966: NEG
3967: PPUSH
3968: LD_INT 1
3970: PPUSH
3971: CALL_OW 12
3975: PLUS
3976: PPUSH
3977: CALL_OW 153
3981: GO 3995
3983: LD_INT 3
3985: DOUBLE
3986: EQUAL
3987: IFTRUE 3991
3989: GO 3994
3991: POP
// ; end ;
3992: GO 3995
3994: POP
// end ; end ;
3995: GO 3831
3997: POP
3998: POP
3999: GO 3818
4001: POP
4002: POP
// end ; end_of_file
4003: LD_VAR 0 3
4007: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4008: LD_INT 0
4010: PPUSH
4011: PPUSH
// if exist_mode then
4012: LD_VAR 0 2
4016: IFFALSE 4035
// unit := CreateCharacter ( ident ) else
4018: LD_ADDR_VAR 0 4
4022: PUSH
4023: LD_VAR 0 1
4027: PPUSH
4028: CALL_OW 34
4032: ST_TO_ADDR
4033: GO 4050
// unit := NewCharacter ( ident ) ;
4035: LD_ADDR_VAR 0 4
4039: PUSH
4040: LD_VAR 0 1
4044: PPUSH
4045: CALL_OW 25
4049: ST_TO_ADDR
// result := unit ;
4050: LD_ADDR_VAR 0 3
4054: PUSH
4055: LD_VAR 0 4
4059: ST_TO_ADDR
// end ;
4060: LD_VAR 0 3
4064: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4065: LD_INT 0
4067: PPUSH
4068: PPUSH
4069: PPUSH
// uc_side := GetSide ( b ) ;
4070: LD_ADDR_OWVAR 20
4074: PUSH
4075: LD_VAR 0 2
4079: PPUSH
4080: CALL_OW 255
4084: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4085: LD_ADDR_OWVAR 21
4089: PUSH
4090: LD_VAR 0 2
4094: PPUSH
4095: CALL_OW 248
4099: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4100: LD_INT 0
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_VAR 0 1
4110: PPUSH
4111: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4115: LD_ADDR_VAR 0 5
4119: PUSH
4120: LD_VAR 0 2
4124: PPUSH
4125: CALL_OW 254
4129: PUSH
4130: LD_INT 3
4132: MINUS
4133: ST_TO_ADDR
// if dir < 0 then
4134: LD_VAR 0 5
4138: PUSH
4139: LD_INT 0
4141: LESS
4142: IFFALSE 4158
// dir := 6 + dir ;
4144: LD_ADDR_VAR 0 5
4148: PUSH
4149: LD_INT 6
4151: PUSH
4152: LD_VAR 0 5
4156: PLUS
4157: ST_TO_ADDR
// un := CreateHuman ;
4158: LD_ADDR_VAR 0 4
4162: PUSH
4163: CALL_OW 44
4167: ST_TO_ADDR
// SetDir ( un , dir ) ;
4168: LD_VAR 0 4
4172: PPUSH
4173: LD_VAR 0 5
4177: PPUSH
4178: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4182: LD_VAR 0 4
4186: PPUSH
4187: LD_VAR 0 2
4191: PPUSH
4192: CALL_OW 52
// end ; end_of_file
4196: LD_VAR 0 3
4200: RET
// on UnitDestroyed ( un ) do var i ;
4201: LD_INT 0
4203: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
4204: LD_VAR 0 1
4208: PPUSH
4209: CALL_OW 255
4213: PUSH
4214: LD_INT 3
4216: EQUAL
4217: PUSH
4218: LD_VAR 0 1
4222: PPUSH
4223: CALL_OW 247
4227: PUSH
4228: LD_INT 3
4230: EQUAL
4231: AND
4232: IFFALSE 4924
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
4234: LD_VAR 0 1
4238: PPUSH
4239: CALL_OW 266
4243: PUSH
4244: LD_INT 31
4246: EQUAL
4247: PUSH
4248: LD_VAR 0 1
4252: PPUSH
4253: CALL_OW 266
4257: PUSH
4258: LD_INT 32
4260: EQUAL
4261: OR
4262: PUSH
4263: LD_VAR 0 1
4267: PPUSH
4268: CALL_OW 266
4272: PUSH
4273: LD_INT 36
4275: EQUAL
4276: OR
4277: PUSH
4278: LD_VAR 0 1
4282: PPUSH
4283: CALL_OW 266
4287: PUSH
4288: LD_INT 0
4290: EQUAL
4291: OR
4292: PUSH
4293: LD_VAR 0 1
4297: PPUSH
4298: CALL_OW 266
4302: PUSH
4303: LD_INT 24
4305: EQUAL
4306: OR
4307: PUSH
4308: LD_VAR 0 1
4312: PPUSH
4313: CALL_OW 266
4317: PUSH
4318: LD_INT 17
4320: EQUAL
4321: OR
4322: PUSH
4323: LD_VAR 0 1
4327: PPUSH
4328: CALL_OW 266
4332: PUSH
4333: LD_INT 25
4335: EQUAL
4336: OR
4337: PUSH
4338: LD_VAR 0 1
4342: PPUSH
4343: CALL_OW 266
4347: PUSH
4348: LD_INT 19
4350: EQUAL
4351: OR
4352: PUSH
4353: LD_VAR 0 1
4357: PPUSH
4358: CALL_OW 266
4362: PUSH
4363: LD_INT 20
4365: EQUAL
4366: OR
4367: PUSH
4368: LD_VAR 0 1
4372: PPUSH
4373: CALL_OW 266
4377: PUSH
4378: LD_INT 18
4380: EQUAL
4381: OR
4382: PUSH
4383: LD_VAR 0 1
4387: PPUSH
4388: CALL_OW 266
4392: PUSH
4393: LD_INT 21
4395: EQUAL
4396: OR
4397: PUSH
4398: LD_VAR 0 1
4402: PPUSH
4403: CALL_OW 266
4407: PUSH
4408: LD_INT 23
4410: EQUAL
4411: OR
4412: PUSH
4413: LD_VAR 0 1
4417: PPUSH
4418: CALL_OW 266
4422: PUSH
4423: LD_INT 16
4425: EQUAL
4426: OR
4427: PUSH
4428: LD_VAR 0 1
4432: PPUSH
4433: CALL_OW 266
4437: PUSH
4438: LD_INT 6
4440: EQUAL
4441: OR
4442: PUSH
4443: LD_VAR 0 1
4447: PPUSH
4448: CALL_OW 266
4452: PUSH
4453: LD_INT 29
4455: EQUAL
4456: OR
4457: PUSH
4458: LD_VAR 0 1
4462: PPUSH
4463: CALL_OW 266
4467: PUSH
4468: LD_INT 26
4470: EQUAL
4471: OR
4472: PUSH
4473: LD_VAR 0 1
4477: PPUSH
4478: CALL_OW 266
4482: PUSH
4483: LD_INT 30
4485: EQUAL
4486: OR
4487: PUSH
4488: LD_VAR 0 1
4492: PPUSH
4493: CALL_OW 266
4497: PUSH
4498: LD_INT 28
4500: EQUAL
4501: OR
4502: PUSH
4503: LD_VAR 0 1
4507: PPUSH
4508: CALL_OW 266
4512: PUSH
4513: LD_INT 27
4515: EQUAL
4516: OR
4517: PUSH
4518: LD_VAR 0 1
4522: PPUSH
4523: CALL_OW 266
4527: PUSH
4528: LD_INT 33
4530: EQUAL
4531: OR
4532: PUSH
4533: LD_VAR 0 1
4537: PPUSH
4538: CALL_OW 266
4542: PUSH
4543: LD_INT 2
4545: EQUAL
4546: OR
4547: PUSH
4548: LD_VAR 0 1
4552: PPUSH
4553: CALL_OW 266
4557: PUSH
4558: LD_INT 4
4560: EQUAL
4561: OR
4562: IFFALSE 4648
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
4564: LD_ADDR_EXP 1
4568: PUSH
4569: LD_EXP 1
4573: PUSH
4574: LD_VAR 0 1
4578: PPUSH
4579: CALL_OW 266
4583: ADD
4584: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4585: LD_ADDR_EXP 1
4589: PUSH
4590: LD_EXP 1
4594: PUSH
4595: LD_VAR 0 1
4599: PPUSH
4600: CALL_OW 250
4604: ADD
4605: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4606: LD_ADDR_EXP 1
4610: PUSH
4611: LD_EXP 1
4615: PUSH
4616: LD_VAR 0 1
4620: PPUSH
4621: CALL_OW 251
4625: ADD
4626: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4627: LD_ADDR_EXP 1
4631: PUSH
4632: LD_EXP 1
4636: PUSH
4637: LD_VAR 0 1
4641: PPUSH
4642: CALL_OW 254
4646: ADD
4647: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
4648: LD_VAR 0 1
4652: PPUSH
4653: CALL_OW 266
4657: PUSH
4658: LD_INT 1
4660: EQUAL
4661: IFFALSE 4740
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
4663: LD_ADDR_EXP 1
4667: PUSH
4668: LD_EXP 1
4672: PUSH
4673: LD_INT 0
4675: ADD
4676: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4677: LD_ADDR_EXP 1
4681: PUSH
4682: LD_EXP 1
4686: PUSH
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 250
4696: ADD
4697: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4698: LD_ADDR_EXP 1
4702: PUSH
4703: LD_EXP 1
4707: PUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 251
4717: ADD
4718: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4719: LD_ADDR_EXP 1
4723: PUSH
4724: LD_EXP 1
4728: PUSH
4729: LD_VAR 0 1
4733: PPUSH
4734: CALL_OW 254
4738: ADD
4739: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4740: LD_VAR 0 1
4744: PPUSH
4745: CALL_OW 266
4749: PUSH
4750: LD_INT 3
4752: EQUAL
4753: IFFALSE 4832
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4755: LD_ADDR_EXP 1
4759: PUSH
4760: LD_EXP 1
4764: PUSH
4765: LD_INT 2
4767: ADD
4768: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4769: LD_ADDR_EXP 1
4773: PUSH
4774: LD_EXP 1
4778: PUSH
4779: LD_VAR 0 1
4783: PPUSH
4784: CALL_OW 250
4788: ADD
4789: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4790: LD_ADDR_EXP 1
4794: PUSH
4795: LD_EXP 1
4799: PUSH
4800: LD_VAR 0 1
4804: PPUSH
4805: CALL_OW 251
4809: ADD
4810: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4811: LD_ADDR_EXP 1
4815: PUSH
4816: LD_EXP 1
4820: PUSH
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 254
4830: ADD
4831: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4832: LD_VAR 0 1
4836: PPUSH
4837: CALL_OW 266
4841: PUSH
4842: LD_INT 5
4844: EQUAL
4845: IFFALSE 4924
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
4847: LD_ADDR_EXP 1
4851: PUSH
4852: LD_EXP 1
4856: PUSH
4857: LD_INT 4
4859: ADD
4860: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4861: LD_ADDR_EXP 1
4865: PUSH
4866: LD_EXP 1
4870: PUSH
4871: LD_VAR 0 1
4875: PPUSH
4876: CALL_OW 250
4880: ADD
4881: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4882: LD_ADDR_EXP 1
4886: PUSH
4887: LD_EXP 1
4891: PUSH
4892: LD_VAR 0 1
4896: PPUSH
4897: CALL_OW 251
4901: ADD
4902: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4903: LD_ADDR_EXP 1
4907: PUSH
4908: LD_EXP 1
4912: PUSH
4913: LD_VAR 0 1
4917: PPUSH
4918: CALL_OW 254
4922: ADD
4923: ST_TO_ADDR
// end ; end ; if GetSide ( un ) = 3 and GetType ( un ) = unit_vehicle then
4924: LD_VAR 0 1
4928: PPUSH
4929: CALL_OW 255
4933: PUSH
4934: LD_INT 3
4936: EQUAL
4937: PUSH
4938: LD_VAR 0 1
4942: PPUSH
4943: CALL_OW 247
4947: PUSH
4948: LD_INT 2
4950: EQUAL
4951: AND
4952: IFFALSE 5056
// begin for i in CPU1DamageTanks do
4954: LD_ADDR_VAR 0 2
4958: PUSH
4959: LD_EXP 4
4963: PUSH
4964: FOR_IN
4965: IFFALSE 5054
// begin if i = un then
4967: LD_VAR 0 2
4971: PUSH
4972: LD_VAR 0 1
4976: EQUAL
4977: IFFALSE 5052
// begin AddComConstruct ( rufab , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
4979: LD_INT 30
4981: PPUSH
4982: LD_VAR 0 1
4986: PPUSH
4987: CALL_OW 265
4991: PPUSH
4992: LD_VAR 0 1
4996: PPUSH
4997: CALL_OW 262
5001: PPUSH
5002: LD_VAR 0 1
5006: PPUSH
5007: CALL_OW 263
5011: PPUSH
5012: LD_VAR 0 1
5016: PPUSH
5017: CALL_OW 264
5021: PPUSH
5022: CALL_OW 185
// CPU1DamageTanks = Delete ( CPU1DamageTanks , i [ i ] ) ;
5026: LD_ADDR_EXP 4
5030: PUSH
5031: LD_EXP 4
5035: PPUSH
5036: LD_VAR 0 2
5040: PUSH
5041: LD_VAR 0 2
5045: ARRAY
5046: PPUSH
5047: CALL_OW 3
5051: ST_TO_ADDR
// end ; end ;
5052: GO 4964
5054: POP
5055: POP
// end ; end ;
5056: PPOPN 2
5058: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
5059: LD_VAR 0 1
5063: PPUSH
5064: CALL_OW 255
5068: PUSH
5069: LD_INT 3
5071: EQUAL
5072: IFFALSE 5146
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5074: LD_ADDR_EXP 1
5078: PUSH
5079: LD_EXP 1
5083: PPUSH
5084: LD_INT 1
5086: PPUSH
5087: CALL_OW 3
5091: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5092: LD_ADDR_EXP 1
5096: PUSH
5097: LD_EXP 1
5101: PPUSH
5102: LD_INT 1
5104: PPUSH
5105: CALL_OW 3
5109: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5110: LD_ADDR_EXP 1
5114: PUSH
5115: LD_EXP 1
5119: PPUSH
5120: LD_INT 1
5122: PPUSH
5123: CALL_OW 3
5127: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5128: LD_ADDR_EXP 1
5132: PUSH
5133: LD_EXP 1
5137: PPUSH
5138: LD_INT 1
5140: PPUSH
5141: CALL_OW 3
5145: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
5146: LD_VAR 0 1
5150: PPUSH
5151: CALL_OW 255
5155: PUSH
5156: LD_INT 3
5158: EQUAL
5159: PUSH
5160: LD_VAR 0 1
5164: PPUSH
5165: CALL_OW 266
5169: PUSH
5170: LD_INT 0
5172: EQUAL
5173: PUSH
5174: LD_VAR 0 1
5178: PPUSH
5179: CALL_OW 266
5183: PUSH
5184: LD_INT 2
5186: EQUAL
5187: OR
5188: PUSH
5189: LD_VAR 0 1
5193: PPUSH
5194: CALL_OW 266
5198: PUSH
5199: LD_INT 4
5201: EQUAL
5202: OR
5203: PUSH
5204: EMPTY
5205: LIST
5206: AND
5207: IFFALSE 5218
// ComUpgrade ( building ) ;
5209: LD_VAR 0 1
5213: PPUSH
5214: CALL_OW 146
// end ;
5218: PPOPN 1
5220: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
5221: LD_VAR 0 1
5225: PPUSH
5226: CALL_OW 255
5230: PUSH
5231: LD_INT 3
5233: EQUAL
5234: IFFALSE 5252
// CPU1Tanks = CPU1Tanks ^ vehicle ;
5236: LD_ADDR_EXP 3
5240: PUSH
5241: LD_EXP 3
5245: PUSH
5246: LD_VAR 0 1
5250: ADD
5251: ST_TO_ADDR
// end ;
5252: PPOPN 2
5254: END
// on Command ( command_id ) do begin display_strings = command_id ;
5255: LD_ADDR_OWVAR 47
5259: PUSH
5260: LD_VAR 0 1
5264: ST_TO_ADDR
// end ;
5265: PPOPN 1
5267: END
