// export destroyedBuildings ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// end ;
  22: END
// every 0 0$1 do
  23: GO 25
  25: DISABLE
// ComEnterUnit ( eng1 , ee1 ) ; end_of_file
  26: LD_INT 95
  28: PPUSH
  29: LD_INT 94
  31: PPUSH
  32: CALL_OW 120
  36: END
// every 0 0$1 do
  37: GO 39
  39: DISABLE
// begin enable ;
  40: ENABLE
// RepairVehicle ( 1 , reparea , 26 , 13 ) ;
  41: LD_INT 1
  43: PPUSH
  44: LD_INT 1
  46: PPUSH
  47: LD_INT 26
  49: PPUSH
  50: LD_INT 13
  52: PPUSH
  53: CALL 412 0 4
// RebuildBuildings ( 3 , destroyedBuildings ) ;
  57: LD_INT 3
  59: PPUSH
  60: LD_EXP 1
  64: PPUSH
  65: CALL 3113 0 2
// IntBazooka ( 3 , 1 ) ;
  69: LD_INT 3
  71: PPUSH
  72: LD_INT 1
  74: PPUSH
  75: CALL 3572 0 2
// end ;
  79: END
// every 5 5$1 do
  80: GO 82
  82: DISABLE
// begin end ; end_of_file
  83: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
  84: LD_INT 0
  86: PPUSH
  87: PPUSH
  88: PPUSH
// rnd = rand ( 1 , characters ) ;
  89: LD_ADDR_VAR 0 6
  93: PUSH
  94: LD_INT 1
  96: PPUSH
  97: LD_VAR 0 1
 101: PPUSH
 102: CALL_OW 12
 106: ST_TO_ADDR
// for i = 1 to characters do
 107: LD_ADDR_VAR 0 5
 111: PUSH
 112: DOUBLE
 113: LD_INT 1
 115: DEC
 116: ST_TO_ADDR
 117: LD_VAR 0 1
 121: PUSH
 122: FOR_TO
 123: IFFALSE 233
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 125: LD_VAR 0 5
 129: PUSH
 130: LD_VAR 0 6
 134: EQUAL
 135: PUSH
 136: LD_VAR 0 1
 140: PUSH
 141: LD_VAR 0 5
 145: ARRAY
 146: PPUSH
 147: CALL_OW 258
 151: PUSH
 152: LD_INT 1
 154: EQUAL
 155: AND
 156: IFFALSE 178
// Say ( characters [ i ] , dialogMID ) ;
 158: LD_VAR 0 1
 162: PUSH
 163: LD_VAR 0 5
 167: ARRAY
 168: PPUSH
 169: LD_VAR 0 2
 173: PPUSH
 174: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 178: LD_VAR 0 5
 182: PUSH
 183: LD_VAR 0 6
 187: EQUAL
 188: PUSH
 189: LD_VAR 0 1
 193: PUSH
 194: LD_VAR 0 5
 198: ARRAY
 199: PPUSH
 200: CALL_OW 258
 204: PUSH
 205: LD_INT 2
 207: EQUAL
 208: AND
 209: IFFALSE 231
// Say ( characters [ i ] , dialogFID ) ;
 211: LD_VAR 0 1
 215: PUSH
 216: LD_VAR 0 5
 220: ARRAY
 221: PPUSH
 222: LD_VAR 0 3
 226: PPUSH
 227: CALL_OW 88
// end ;
 231: GO 122
 233: POP
 234: POP
// end ;
 235: LD_VAR 0 4
 239: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 240: LD_INT 0
 242: PPUSH
 243: PPUSH
 244: PPUSH
 245: PPUSH
// for i = 1 to count do
 246: LD_ADDR_VAR 0 8
 250: PUSH
 251: DOUBLE
 252: LD_INT 1
 254: DEC
 255: ST_TO_ADDR
 256: LD_VAR 0 6
 260: PUSH
 261: FOR_TO
 262: IFFALSE 343
// begin uc_side = side ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_VAR 0 1
 273: ST_TO_ADDR
// uc_nation = nation ;
 274: LD_ADDR_OWVAR 21
 278: PUSH
 279: LD_VAR 0 2
 283: ST_TO_ADDR
// hc_gallery =  ;
 284: LD_ADDR_OWVAR 33
 288: PUSH
 289: LD_STRING 
 291: ST_TO_ADDR
// hc_name =  ;
 292: LD_ADDR_OWVAR 26
 296: PUSH
 297: LD_STRING 
 299: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 300: LD_INT 0
 302: PPUSH
 303: LD_VAR 0 5
 307: PPUSH
 308: LD_VAR 0 4
 312: PPUSH
 313: CALL_OW 380
// un = CreateHuman ;
 317: LD_ADDR_VAR 0 10
 321: PUSH
 322: CALL_OW 44
 326: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 327: LD_VAR 0 10
 331: PPUSH
 332: LD_VAR 0 3
 336: PPUSH
 337: CALL_OW 52
// end ;
 341: GO 261
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 7
 349: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 350: LD_INT 0
 352: PPUSH
 353: PPUSH
// for i in charactersList do
 354: LD_ADDR_VAR 0 4
 358: PUSH
 359: LD_VAR 0 1
 363: PUSH
 364: FOR_IN
 365: IFFALSE 405
// begin if IsOk ( i ) then
 367: LD_VAR 0 4
 371: PPUSH
 372: CALL_OW 302
 376: IFFALSE 394
// begin SaveCharacters ( i , ident ) ;
 378: LD_VAR 0 4
 382: PPUSH
 383: LD_VAR 0 2
 387: PPUSH
 388: CALL_OW 38
// end else
 392: GO 403
// begin DeleteCharacters ( ident ) ;
 394: LD_VAR 0 2
 398: PPUSH
 399: CALL_OW 40
// end ; end ;
 403: GO 364
 405: POP
 406: POP
// end ;
 407: LD_VAR 0 3
 411: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
 412: LD_INT 0
 414: PPUSH
 415: PPUSH
 416: PPUSH
 417: PPUSH
 418: PPUSH
 419: PPUSH
 420: PPUSH
 421: PPUSH
 422: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
 423: LD_ADDR_VAR 0 8
 427: PUSH
 428: LD_INT 22
 430: PUSH
 431: LD_VAR 0 1
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: PUSH
 440: LD_INT 21
 442: PUSH
 443: LD_INT 2
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 24
 452: PUSH
 453: LD_INT 660
 455: PUSH
 456: EMPTY
 457: LIST
 458: LIST
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: LD_INT 58
 465: PUSH
 466: EMPTY
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PPUSH
 479: CALL_OW 69
 483: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
 484: LD_ADDR_VAR 0 9
 488: PUSH
 489: LD_INT 22
 491: PUSH
 492: LD_VAR 0 1
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 21
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 3
 513: PUSH
 514: LD_INT 24
 516: PUSH
 517: LD_INT 660
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
 538: LD_ADDR_VAR 0 10
 542: PUSH
 543: LD_VAR 0 2
 547: PPUSH
 548: LD_INT 22
 550: PUSH
 551: LD_VAR 0 1
 555: PUSH
 556: EMPTY
 557: LIST
 558: LIST
 559: PUSH
 560: LD_INT 21
 562: PUSH
 563: LD_INT 2
 565: PUSH
 566: EMPTY
 567: LIST
 568: LIST
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 24
 575: PUSH
 576: LD_INT 1000
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: PPUSH
 592: CALL_OW 70
 596: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
 597: LD_ADDR_VAR 0 11
 601: PUSH
 602: LD_VAR 0 2
 606: PPUSH
 607: LD_INT 22
 609: PUSH
 610: LD_VAR 0 1
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 21
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 1000
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 58
 641: PUSH
 642: EMPTY
 643: LIST
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: LIST
 649: LIST
 650: PPUSH
 651: CALL_OW 70
 655: ST_TO_ADDR
// mechanicInside_list = [ ] ;
 656: LD_ADDR_VAR 0 12
 660: PUSH
 661: EMPTY
 662: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
 663: LD_ADDR_VAR 0 13
 667: PUSH
 668: LD_VAR 0 2
 672: PPUSH
 673: LD_INT 22
 675: PUSH
 676: LD_VAR 0 1
 680: PUSH
 681: EMPTY
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 25
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL_OW 70
 703: ST_TO_ADDR
// if damageVehicle_list > 0 then
 704: LD_VAR 0 9
 708: PUSH
 709: LD_INT 0
 711: GREATER
 712: IFFALSE 771
// begin for i in damageVehicle_list do
 714: LD_ADDR_VAR 0 6
 718: PUSH
 719: LD_VAR 0 9
 723: PUSH
 724: FOR_IN
 725: IFFALSE 769
// begin ComMoveXY ( i , repX , repY ) ;
 727: LD_VAR 0 6
 731: PPUSH
 732: LD_VAR 0 3
 736: PPUSH
 737: LD_VAR 0 4
 741: PPUSH
 742: CALL_OW 111
// mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
 746: LD_ADDR_VAR 0 12
 750: PUSH
 751: LD_VAR 0 12
 755: PUSH
 756: LD_VAR 0 6
 760: PPUSH
 761: CALL_OW 313
 765: ADD
 766: ST_TO_ADDR
// end ;
 767: GO 724
 769: POP
 770: POP
// end ; if vehicleNeedRepair_list > 0 then
 771: LD_VAR 0 10
 775: PUSH
 776: LD_INT 0
 778: GREATER
 779: IFFALSE 845
// begin for i in mechanicInside_list do
 781: LD_ADDR_VAR 0 6
 785: PUSH
 786: LD_VAR 0 12
 790: PUSH
 791: FOR_IN
 792: IFFALSE 843
// begin for j in vehicleNeedRepair_list do
 794: LD_ADDR_VAR 0 7
 798: PUSH
 799: LD_VAR 0 10
 803: PUSH
 804: FOR_IN
 805: IFFALSE 839
// begin AddComExitVehicle ( i ) ;
 807: LD_VAR 0 6
 811: PPUSH
 812: CALL_OW 181
// wait ( 0 0$1 ) ;
 816: LD_INT 35
 818: PPUSH
 819: CALL_OW 67
// AddComRepairVehicle ( i , j ) ;
 823: LD_VAR 0 6
 827: PPUSH
 828: LD_VAR 0 7
 832: PPUSH
 833: CALL_OW 189
// end ;
 837: GO 804
 839: POP
 840: POP
// end ;
 841: GO 791
 843: POP
 844: POP
// end ; if vehicleDontNeedRepair_list > 0 then
 845: LD_VAR 0 11
 849: PUSH
 850: LD_INT 0
 852: GREATER
 853: IFFALSE 877
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
 855: LD_VAR 0 13
 859: PUSH
 860: LD_INT 1
 862: ARRAY
 863: PPUSH
 864: LD_VAR 0 11
 868: PUSH
 869: LD_INT 1
 871: ARRAY
 872: PPUSH
 873: CALL_OW 120
// end ; if vehicleOK_list > 0 then
 877: LD_VAR 0 8
 881: PUSH
 882: LD_INT 0
 884: GREATER
 885: IFFALSE 919
// begin for i in vehicleOK_list do
 887: LD_ADDR_VAR 0 6
 891: PUSH
 892: LD_VAR 0 8
 896: PUSH
 897: FOR_IN
 898: IFFALSE 917
// ComAgressiveMove ( i , 50 , 50 ) ;
 900: LD_VAR 0 6
 904: PPUSH
 905: LD_INT 50
 907: PPUSH
 908: LD_INT 50
 910: PPUSH
 911: CALL_OW 114
 915: GO 897
 917: POP
 918: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
 919: LD_ADDR_VAR 0 6
 923: PUSH
 924: LD_VAR 0 2
 928: PPUSH
 929: LD_INT 22
 931: PUSH
 932: LD_VAR 0 1
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: PUSH
 941: LD_INT 25
 943: PUSH
 944: LD_INT 3
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: PPUSH
 955: CALL_OW 70
 959: NOT
 960: PUSH
 961: FOR_IN
 962: IFFALSE 985
// ComMoveXY ( i , repX , repY ) ;
 964: LD_VAR 0 6
 968: PPUSH
 969: LD_VAR 0 3
 973: PPUSH
 974: LD_VAR 0 4
 978: PPUSH
 979: CALL_OW 111
 983: GO 961
 985: POP
 986: POP
// end ;
 987: LD_VAR 0 5
 991: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
 997: PPUSH
 998: PPUSH
 999: PPUSH
1000: PPUSH
1001: PPUSH
1002: PPUSH
1003: PPUSH
1004: PPUSH
// amChassisTab = [ ] ;
1005: LD_ADDR_VAR 0 19
1009: PUSH
1010: EMPTY
1011: ST_TO_ADDR
// arChassisTab = [ ] ;
1012: LD_ADDR_VAR 0 18
1016: PUSH
1017: EMPTY
1018: ST_TO_ADDR
// ruChassisTab = [ ] ;
1019: LD_ADDR_VAR 0 17
1023: PUSH
1024: EMPTY
1025: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
1026: LD_INT 35
1028: PPUSH
1029: CALL_OW 67
// if nation = 1 then
1033: LD_VAR 0 5
1037: PUSH
1038: LD_INT 1
1040: EQUAL
1041: IFFALSE 1532
// begin uc_side = side ;
1043: LD_ADDR_OWVAR 20
1047: PUSH
1048: LD_VAR 0 2
1052: ST_TO_ADDR
// uc_nation = nation ;
1053: LD_ADDR_OWVAR 21
1057: PUSH
1058: LD_VAR 0 5
1062: ST_TO_ADDR
// vc_engine = vehengine ;
1063: LD_ADDR_OWVAR 39
1067: PUSH
1068: LD_VAR 0 6
1072: ST_TO_ADDR
// vc_control = vehcontrol ;
1073: LD_ADDR_OWVAR 38
1077: PUSH
1078: LD_VAR 0 7
1082: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
1083: LD_ADDR_OWVAR 40
1087: PUSH
1088: LD_VAR 0 10
1092: PUSH
1093: LD_INT 1
1095: PPUSH
1096: LD_VAR 0 10
1100: PPUSH
1101: CALL_OW 12
1105: ARRAY
1106: ST_TO_ADDR
// for j = 1 to AMWeapon do
1107: LD_ADDR_VAR 0 14
1111: PUSH
1112: DOUBLE
1113: LD_INT 1
1115: DEC
1116: ST_TO_ADDR
1117: LD_VAR 0 10
1121: PUSH
1122: FOR_TO
1123: IFFALSE 1424
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
1125: LD_VAR 0 10
1129: PUSH
1130: LD_VAR 0 14
1134: ARRAY
1135: PUSH
1136: LD_INT 2
1138: EQUAL
1139: PUSH
1140: LD_VAR 0 10
1144: PUSH
1145: LD_VAR 0 14
1149: ARRAY
1150: PUSH
1151: LD_INT 3
1153: EQUAL
1154: OR
1155: IFFALSE 1208
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
1157: LD_ADDR_VAR 0 19
1161: PUSH
1162: LD_INT 1
1164: PUSH
1165: LD_INT 2
1167: PUSH
1168: LD_INT 3
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: LD_INT 5
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1184: LD_ADDR_OWVAR 37
1188: PUSH
1189: LD_VAR 0 19
1193: PUSH
1194: LD_INT 1
1196: PPUSH
1197: LD_VAR 0 19
1201: PPUSH
1202: CALL_OW 12
1206: ARRAY
1207: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
1208: LD_VAR 0 10
1212: PUSH
1213: LD_VAR 0 14
1217: ARRAY
1218: PUSH
1219: LD_INT 4
1221: EQUAL
1222: PUSH
1223: LD_VAR 0 10
1227: PUSH
1228: LD_VAR 0 14
1232: ARRAY
1233: PUSH
1234: LD_INT 5
1236: EQUAL
1237: OR
1238: PUSH
1239: LD_VAR 0 10
1243: PUSH
1244: LD_VAR 0 14
1248: ARRAY
1249: PUSH
1250: LD_INT 9
1252: EQUAL
1253: OR
1254: PUSH
1255: LD_VAR 0 10
1259: PUSH
1260: LD_VAR 0 14
1264: ARRAY
1265: PUSH
1266: LD_INT 11
1268: EQUAL
1269: OR
1270: PUSH
1271: LD_VAR 0 10
1275: PUSH
1276: LD_VAR 0 14
1280: ARRAY
1281: PUSH
1282: LD_INT 7
1284: EQUAL
1285: OR
1286: IFFALSE 1335
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1288: LD_ADDR_VAR 0 19
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: LD_INT 3
1298: PUSH
1299: LD_INT 4
1301: PUSH
1302: LD_INT 5
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1311: LD_ADDR_OWVAR 37
1315: PUSH
1316: LD_VAR 0 19
1320: PUSH
1321: LD_INT 1
1323: PPUSH
1324: LD_VAR 0 19
1328: PPUSH
1329: CALL_OW 12
1333: ARRAY
1334: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
1335: LD_VAR 0 10
1339: PUSH
1340: LD_VAR 0 14
1344: ARRAY
1345: PUSH
1346: LD_INT 8
1348: EQUAL
1349: PUSH
1350: LD_VAR 0 10
1354: PUSH
1355: LD_VAR 0 14
1359: ARRAY
1360: PUSH
1361: LD_INT 6
1363: EQUAL
1364: OR
1365: PUSH
1366: LD_VAR 0 10
1370: PUSH
1371: LD_VAR 0 14
1375: ARRAY
1376: PUSH
1377: LD_INT 10
1379: EQUAL
1380: OR
1381: IFFALSE 1422
// begin amChassisTab = [ 4 , 5 ] ;
1383: LD_ADDR_VAR 0 19
1387: PUSH
1388: LD_INT 4
1390: PUSH
1391: LD_INT 5
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1398: LD_ADDR_OWVAR 37
1402: PUSH
1403: LD_VAR 0 19
1407: PUSH
1408: LD_INT 1
1410: PPUSH
1411: LD_VAR 0 19
1415: PPUSH
1416: CALL_OW 12
1420: ARRAY
1421: ST_TO_ADDR
// end ; end ;
1422: GO 1122
1424: POP
1425: POP
// veh = CreateVehicle ;
1426: LD_ADDR_VAR 0 16
1430: PUSH
1431: CALL_OW 45
1435: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1436: LD_VAR 0 16
1440: PPUSH
1441: LD_VAR 0 1
1445: PPUSH
1446: LD_INT 0
1448: PPUSH
1449: CALL_OW 49
// if vehControl = 1 then
1453: LD_VAR 0 7
1457: PUSH
1458: LD_INT 1
1460: EQUAL
1461: IFFALSE 1518
// begin hc_gallery =  ;
1463: LD_ADDR_OWVAR 33
1467: PUSH
1468: LD_STRING 
1470: ST_TO_ADDR
// hc_name =  ;
1471: LD_ADDR_OWVAR 26
1475: PUSH
1476: LD_STRING 
1478: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1479: LD_INT 0
1481: PPUSH
1482: LD_INT 3
1484: PPUSH
1485: LD_VAR 0 4
1489: PPUSH
1490: CALL_OW 380
// un = CreateHuman ;
1494: LD_ADDR_VAR 0 15
1498: PUSH
1499: CALL_OW 44
1503: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1504: LD_VAR 0 15
1508: PPUSH
1509: LD_VAR 0 16
1513: PPUSH
1514: CALL_OW 52
// end ; i = i + 1 ;
1518: LD_ADDR_VAR 0 13
1522: PUSH
1523: LD_VAR 0 13
1527: PUSH
1528: LD_INT 1
1530: PLUS
1531: ST_TO_ADDR
// end ; if nation = 2 then
1532: LD_VAR 0 5
1536: PUSH
1537: LD_INT 2
1539: EQUAL
1540: IFFALSE 1964
// begin uc_side = side ;
1542: LD_ADDR_OWVAR 20
1546: PUSH
1547: LD_VAR 0 2
1551: ST_TO_ADDR
// uc_nation = nation ;
1552: LD_ADDR_OWVAR 21
1556: PUSH
1557: LD_VAR 0 5
1561: ST_TO_ADDR
// vc_engine = vehengine ;
1562: LD_ADDR_OWVAR 39
1566: PUSH
1567: LD_VAR 0 6
1571: ST_TO_ADDR
// vc_control = vehcontrol ;
1572: LD_ADDR_OWVAR 38
1576: PUSH
1577: LD_VAR 0 7
1581: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1582: LD_ADDR_OWVAR 40
1586: PUSH
1587: LD_VAR 0 9
1591: PUSH
1592: LD_INT 1
1594: PPUSH
1595: LD_VAR 0 9
1599: PPUSH
1600: CALL_OW 12
1604: ARRAY
1605: ST_TO_ADDR
// for j = 1 to ARWeapons do
1606: LD_ADDR_VAR 0 14
1610: PUSH
1611: DOUBLE
1612: LD_INT 1
1614: DEC
1615: ST_TO_ADDR
1616: LD_VAR 0 9
1620: PUSH
1621: FOR_TO
1622: IFFALSE 1856
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1624: LD_VAR 0 9
1628: PUSH
1629: LD_VAR 0 14
1633: ARRAY
1634: PUSH
1635: LD_INT 24
1637: EQUAL
1638: PUSH
1639: LD_VAR 0 9
1643: PUSH
1644: LD_VAR 0 14
1648: ARRAY
1649: PUSH
1650: LD_INT 22
1652: EQUAL
1653: OR
1654: PUSH
1655: LD_VAR 0 9
1659: PUSH
1660: LD_VAR 0 14
1664: ARRAY
1665: PUSH
1666: LD_INT 23
1668: EQUAL
1669: OR
1670: PUSH
1671: LD_VAR 0 9
1675: PUSH
1676: LD_VAR 0 14
1680: ARRAY
1681: PUSH
1682: LD_INT 30
1684: EQUAL
1685: OR
1686: IFFALSE 1735
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1688: LD_ADDR_VAR 0 18
1692: PUSH
1693: LD_INT 11
1695: PUSH
1696: LD_INT 12
1698: PUSH
1699: LD_INT 13
1701: PUSH
1702: LD_INT 14
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1711: LD_ADDR_OWVAR 37
1715: PUSH
1716: LD_VAR 0 18
1720: PUSH
1721: LD_INT 1
1723: PPUSH
1724: LD_VAR 0 18
1728: PPUSH
1729: CALL_OW 12
1733: ARRAY
1734: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1735: LD_VAR 0 9
1739: PUSH
1740: LD_VAR 0 14
1744: ARRAY
1745: PUSH
1746: LD_INT 29
1748: EQUAL
1749: PUSH
1750: LD_VAR 0 9
1754: PUSH
1755: LD_VAR 0 14
1759: ARRAY
1760: PUSH
1761: LD_INT 28
1763: EQUAL
1764: OR
1765: PUSH
1766: LD_VAR 0 9
1770: PUSH
1771: LD_VAR 0 14
1775: ARRAY
1776: PUSH
1777: LD_INT 27
1779: EQUAL
1780: OR
1781: PUSH
1782: LD_VAR 0 9
1786: PUSH
1787: LD_VAR 0 14
1791: ARRAY
1792: PUSH
1793: LD_INT 26
1795: EQUAL
1796: OR
1797: PUSH
1798: LD_VAR 0 9
1802: PUSH
1803: LD_VAR 0 14
1807: ARRAY
1808: PUSH
1809: LD_INT 25
1811: EQUAL
1812: OR
1813: IFFALSE 1854
// begin arChassisTab = [ 13 , 14 ] ;
1815: LD_ADDR_VAR 0 18
1819: PUSH
1820: LD_INT 13
1822: PUSH
1823: LD_INT 14
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1830: LD_ADDR_OWVAR 37
1834: PUSH
1835: LD_VAR 0 18
1839: PUSH
1840: LD_INT 1
1842: PPUSH
1843: LD_VAR 0 18
1847: PPUSH
1848: CALL_OW 12
1852: ARRAY
1853: ST_TO_ADDR
// end ; end ;
1854: GO 1621
1856: POP
1857: POP
// veh = CreateVehicle ;
1858: LD_ADDR_VAR 0 16
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1868: LD_VAR 0 16
1872: PPUSH
1873: LD_VAR 0 1
1877: PPUSH
1878: LD_INT 0
1880: PPUSH
1881: CALL_OW 49
// if vehcontrol = 1 then
1885: LD_VAR 0 7
1889: PUSH
1890: LD_INT 1
1892: EQUAL
1893: IFFALSE 1950
// begin hc_gallery =  ;
1895: LD_ADDR_OWVAR 33
1899: PUSH
1900: LD_STRING 
1902: ST_TO_ADDR
// hc_name =  ;
1903: LD_ADDR_OWVAR 26
1907: PUSH
1908: LD_STRING 
1910: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1911: LD_INT 0
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: LD_VAR 0 4
1921: PPUSH
1922: CALL_OW 380
// un = CreateHuman ;
1926: LD_ADDR_VAR 0 15
1930: PUSH
1931: CALL_OW 44
1935: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1936: LD_VAR 0 15
1940: PPUSH
1941: LD_VAR 0 16
1945: PPUSH
1946: CALL_OW 52
// end ; i = i + 1 ;
1950: LD_ADDR_VAR 0 13
1954: PUSH
1955: LD_VAR 0 13
1959: PUSH
1960: LD_INT 1
1962: PLUS
1963: ST_TO_ADDR
// end ; if nation = 3 then
1964: LD_VAR 0 5
1968: PUSH
1969: LD_INT 3
1971: EQUAL
1972: IFFALSE 2364
// begin uc_side = side ;
1974: LD_ADDR_OWVAR 20
1978: PUSH
1979: LD_VAR 0 2
1983: ST_TO_ADDR
// uc_nation = nation ;
1984: LD_ADDR_OWVAR 21
1988: PUSH
1989: LD_VAR 0 5
1993: ST_TO_ADDR
// vc_engine = vehengine ;
1994: LD_ADDR_OWVAR 39
1998: PUSH
1999: LD_VAR 0 6
2003: ST_TO_ADDR
// vc_control = vehcontrol ;
2004: LD_ADDR_OWVAR 38
2008: PUSH
2009: LD_VAR 0 7
2013: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
2014: LD_ADDR_OWVAR 40
2018: PUSH
2019: LD_VAR 0 8
2023: PUSH
2024: LD_INT 1
2026: PPUSH
2027: LD_VAR 0 8
2031: PPUSH
2032: CALL_OW 12
2036: ARRAY
2037: ST_TO_ADDR
// for j = 1 to RuWeapons do
2038: LD_ADDR_VAR 0 14
2042: PUSH
2043: DOUBLE
2044: LD_INT 1
2046: DEC
2047: ST_TO_ADDR
2048: LD_VAR 0 8
2052: PUSH
2053: FOR_TO
2054: IFFALSE 2256
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
2056: LD_VAR 0 8
2060: PUSH
2061: LD_VAR 0 14
2065: ARRAY
2066: PUSH
2067: LD_INT 42
2069: EQUAL
2070: PUSH
2071: LD_VAR 0 8
2075: PUSH
2076: LD_VAR 0 14
2080: ARRAY
2081: PUSH
2082: LD_INT 43
2084: EQUAL
2085: OR
2086: PUSH
2087: LD_VAR 0 8
2091: PUSH
2092: LD_VAR 0 14
2096: ARRAY
2097: PUSH
2098: LD_INT 44
2100: EQUAL
2101: OR
2102: PUSH
2103: LD_VAR 0 8
2107: PUSH
2108: LD_VAR 0 14
2112: ARRAY
2113: PUSH
2114: LD_INT 45
2116: EQUAL
2117: OR
2118: PUSH
2119: LD_VAR 0 8
2123: PUSH
2124: LD_VAR 0 14
2128: ARRAY
2129: PUSH
2130: LD_INT 49
2132: EQUAL
2133: OR
2134: IFFALSE 2183
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
2136: LD_ADDR_VAR 0 17
2140: PUSH
2141: LD_INT 21
2143: PUSH
2144: LD_INT 22
2146: PUSH
2147: LD_INT 23
2149: PUSH
2150: LD_INT 24
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2159: LD_ADDR_OWVAR 37
2163: PUSH
2164: LD_VAR 0 17
2168: PUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 17
2176: PPUSH
2177: CALL_OW 12
2181: ARRAY
2182: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
2183: LD_VAR 0 8
2187: PUSH
2188: LD_VAR 0 14
2192: ARRAY
2193: PUSH
2194: LD_INT 46
2196: EQUAL
2197: PUSH
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 14
2207: ARRAY
2208: PUSH
2209: LD_INT 47
2211: EQUAL
2212: OR
2213: IFFALSE 2254
// begin ruChassisTab = [ 23 , 24 ] ;
2215: LD_ADDR_VAR 0 17
2219: PUSH
2220: LD_INT 23
2222: PUSH
2223: LD_INT 24
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2230: LD_ADDR_OWVAR 37
2234: PUSH
2235: LD_VAR 0 17
2239: PUSH
2240: LD_INT 1
2242: PPUSH
2243: LD_VAR 0 17
2247: PPUSH
2248: CALL_OW 12
2252: ARRAY
2253: ST_TO_ADDR
// end ; end ;
2254: GO 2053
2256: POP
2257: POP
// veh = CreateVehicle ;
2258: LD_ADDR_VAR 0 16
2262: PUSH
2263: CALL_OW 45
2267: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2268: LD_VAR 0 16
2272: PPUSH
2273: LD_VAR 0 1
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 49
// if vehcontrol = 1 then
2285: LD_VAR 0 7
2289: PUSH
2290: LD_INT 1
2292: EQUAL
2293: IFFALSE 2350
// begin hc_gallery =  ;
2295: LD_ADDR_OWVAR 33
2299: PUSH
2300: LD_STRING 
2302: ST_TO_ADDR
// hc_name =  ;
2303: LD_ADDR_OWVAR 26
2307: PUSH
2308: LD_STRING 
2310: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2311: LD_INT 0
2313: PPUSH
2314: LD_INT 3
2316: PPUSH
2317: LD_VAR 0 4
2321: PPUSH
2322: CALL_OW 380
// un = CreateHuman ;
2326: LD_ADDR_VAR 0 15
2330: PUSH
2331: CALL_OW 44
2335: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2336: LD_VAR 0 15
2340: PPUSH
2341: LD_VAR 0 16
2345: PPUSH
2346: CALL_OW 52
// end ; i = i + 1 ;
2350: LD_ADDR_VAR 0 13
2354: PUSH
2355: LD_VAR 0 13
2359: PUSH
2360: LD_INT 1
2362: PLUS
2363: ST_TO_ADDR
// end ; until i = vehCount ;
2364: LD_VAR 0 13
2368: PUSH
2369: LD_VAR 0 3
2373: EQUAL
2374: IFFALSE 1026
// repeat wait ( 0 0$1 ) ;
2376: LD_INT 35
2378: PPUSH
2379: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2383: LD_ADDR_VAR 0 20
2387: PUSH
2388: LD_INT 22
2390: PUSH
2391: LD_VAR 0 2
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 21
2402: PUSH
2403: LD_INT 2
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: PUSH
2410: LD_INT 24
2412: PUSH
2413: LD_INT 650
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: PPUSH
2425: CALL_OW 69
2429: ST_TO_ADDR
// if vehicleOK_list > 0 then
2430: LD_VAR 0 20
2434: PUSH
2435: LD_INT 0
2437: GREATER
2438: IFFALSE 2629
// begin for i in vehicleOK_list do
2440: LD_ADDR_VAR 0 13
2444: PUSH
2445: LD_VAR 0 20
2449: PUSH
2450: FOR_IN
2451: IFFALSE 2627
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2453: LD_ADDR_VAR 0 21
2457: PUSH
2458: LD_INT 22
2460: PUSH
2461: LD_VAR 0 11
2465: PUSH
2466: EMPTY
2467: LIST
2468: LIST
2469: PPUSH
2470: CALL_OW 69
2474: PPUSH
2475: LD_VAR 0 13
2479: PPUSH
2480: CALL_OW 74
2484: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2485: LD_ADDR_VAR 0 22
2489: PUSH
2490: LD_INT 22
2492: PUSH
2493: LD_VAR 0 11
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PUSH
2502: LD_INT 2
2504: PUSH
2505: LD_INT 59
2507: PUSH
2508: EMPTY
2509: LIST
2510: PUSH
2511: LD_INT 21
2513: PUSH
2514: LD_INT 1
2516: PUSH
2517: EMPTY
2518: LIST
2519: LIST
2520: PUSH
2521: LD_INT 21
2523: PUSH
2524: LD_INT 2
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: LIST
2535: LIST
2536: PUSH
2537: EMPTY
2538: LIST
2539: LIST
2540: PUSH
2541: EMPTY
2542: LIST
2543: PPUSH
2544: CALL_OW 69
2548: PPUSH
2549: LD_VAR 0 13
2553: PPUSH
2554: CALL_OW 74
2558: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2559: LD_VAR 0 13
2563: PPUSH
2564: LD_VAR 0 21
2568: PPUSH
2569: CALL_OW 296
2573: PUSH
2574: LD_INT 8
2576: PLUS
2577: PUSH
2578: LD_VAR 0 13
2582: PPUSH
2583: LD_VAR 0 22
2587: PPUSH
2588: CALL_OW 296
2592: LESS
2593: IFFALSE 2611
// begin ComAttackUnit ( i , target1 ) ;
2595: LD_VAR 0 13
2599: PPUSH
2600: LD_VAR 0 21
2604: PPUSH
2605: CALL_OW 115
// end else
2609: GO 2625
// begin ComAttackUnit ( i , target2 ) ;
2611: LD_VAR 0 13
2615: PPUSH
2616: LD_VAR 0 22
2620: PPUSH
2621: CALL_OW 115
// end ; end ;
2625: GO 2450
2627: POP
2628: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2629: LD_INT 22
2631: PUSH
2632: LD_VAR 0 2
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 21
2643: PUSH
2644: LD_INT 2
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: PPUSH
2655: CALL_OW 69
2659: PUSH
2660: LD_INT 0
2662: EQUAL
2663: IFFALSE 2376
// end ;
2665: LD_VAR 0 12
2669: RET
// export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , targetSide , weaponTab , engine , control , chassis ) ; var i , j , temp , target1 , target2 ; begin
2670: LD_INT 0
2672: PPUSH
2673: PPUSH
2674: PPUSH
2675: PPUSH
2676: PPUSH
2677: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2678: LD_INT 22
2680: PUSH
2681: LD_VAR 0 1
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PUSH
2690: LD_INT 21
2692: PUSH
2693: LD_INT 2
2695: PUSH
2696: EMPTY
2697: LIST
2698: LIST
2699: PUSH
2700: EMPTY
2701: LIST
2702: LIST
2703: PPUSH
2704: CALL_OW 69
2708: PUSH
2709: LD_VAR 0 3
2713: LESSEQUAL
2714: IFFALSE 2781
// for i = 1 to vehCount do
2716: LD_ADDR_VAR 0 10
2720: PUSH
2721: DOUBLE
2722: LD_INT 1
2724: DEC
2725: ST_TO_ADDR
2726: LD_VAR 0 3
2730: PUSH
2731: FOR_TO
2732: IFFALSE 2779
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_VAR 0 8
2743: PPUSH
2744: LD_VAR 0 6
2748: PPUSH
2749: LD_VAR 0 7
2753: PPUSH
2754: LD_VAR 0 5
2758: PUSH
2759: LD_INT 1
2761: PPUSH
2762: LD_VAR 0 5
2766: PPUSH
2767: CALL_OW 12
2771: ARRAY
2772: PPUSH
2773: CALL_OW 185
2777: GO 2731
2779: POP
2780: POP
// repeat wait ( 0 0$1 ) ;
2781: LD_INT 35
2783: PPUSH
2784: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] ] ) >= vehCount ;
2788: LD_INT 22
2790: PUSH
2791: LD_VAR 0 1
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: LD_INT 21
2802: PUSH
2803: LD_INT 2
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PUSH
2810: LD_INT 24
2812: PUSH
2813: LD_INT 250
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: EMPTY
2821: LIST
2822: LIST
2823: LIST
2824: PPUSH
2825: CALL_OW 69
2829: PUSH
2830: LD_VAR 0 3
2834: GREATEREQUAL
2835: IFFALSE 2781
// repeat begin wait ( 0 0$1 ) ;
2837: LD_INT 35
2839: PPUSH
2840: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 651 ] ] ) do
2844: LD_ADDR_VAR 0 10
2848: PUSH
2849: LD_INT 22
2851: PUSH
2852: LD_VAR 0 1
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: LD_INT 21
2863: PUSH
2864: LD_INT 2
2866: PUSH
2867: EMPTY
2868: LIST
2869: LIST
2870: PUSH
2871: LD_INT 24
2873: PUSH
2874: LD_INT 651
2876: PUSH
2877: EMPTY
2878: LIST
2879: LIST
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: PPUSH
2886: CALL_OW 69
2890: PUSH
2891: FOR_IN
2892: IFFALSE 3068
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2894: LD_ADDR_VAR 0 13
2898: PUSH
2899: LD_INT 22
2901: PUSH
2902: LD_VAR 0 4
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: PPUSH
2911: CALL_OW 69
2915: PPUSH
2916: LD_VAR 0 10
2920: PPUSH
2921: CALL_OW 74
2925: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2926: LD_ADDR_VAR 0 14
2930: PUSH
2931: LD_INT 22
2933: PUSH
2934: LD_VAR 0 4
2938: PUSH
2939: EMPTY
2940: LIST
2941: LIST
2942: PUSH
2943: LD_INT 2
2945: PUSH
2946: LD_INT 59
2948: PUSH
2949: EMPTY
2950: LIST
2951: PUSH
2952: LD_INT 21
2954: PUSH
2955: LD_INT 1
2957: PUSH
2958: EMPTY
2959: LIST
2960: LIST
2961: PUSH
2962: LD_INT 21
2964: PUSH
2965: LD_INT 2
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: LIST
2976: LIST
2977: PUSH
2978: EMPTY
2979: LIST
2980: LIST
2981: PUSH
2982: EMPTY
2983: LIST
2984: PPUSH
2985: CALL_OW 69
2989: PPUSH
2990: LD_VAR 0 10
2994: PPUSH
2995: CALL_OW 74
2999: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
3000: LD_VAR 0 10
3004: PPUSH
3005: LD_VAR 0 13
3009: PPUSH
3010: CALL_OW 296
3014: PUSH
3015: LD_INT 8
3017: PLUS
3018: PUSH
3019: LD_VAR 0 10
3023: PPUSH
3024: LD_VAR 0 14
3028: PPUSH
3029: CALL_OW 296
3033: LESS
3034: IFFALSE 3052
// begin ComAttackUnit ( i , target1 ) ;
3036: LD_VAR 0 10
3040: PPUSH
3041: LD_VAR 0 13
3045: PPUSH
3046: CALL_OW 115
// end else
3050: GO 3066
// begin ComAttackUnit ( i , target2 ) ;
3052: LD_VAR 0 10
3056: PPUSH
3057: LD_VAR 0 14
3061: PPUSH
3062: CALL_OW 115
// end ; end ;
3066: GO 2891
3068: POP
3069: POP
// end until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount ;
3070: LD_INT 22
3072: PUSH
3073: LD_VAR 0 1
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: PUSH
3082: LD_INT 21
3084: PUSH
3085: LD_INT 2
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: PPUSH
3096: CALL_OW 69
3100: PUSH
3101: LD_VAR 0 3
3105: LESSEQUAL
3106: IFFALSE 2837
// end ;
3108: LD_VAR 0 9
3112: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3113: LD_INT 0
3115: PPUSH
3116: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3117: LD_INT 22
3119: PUSH
3120: LD_VAR 0 1
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: LD_INT 25
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 69
3147: PUSH
3148: LD_INT 0
3150: GREATER
3151: PUSH
3152: LD_INT 22
3154: PUSH
3155: LD_VAR 0 1
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: LD_INT 21
3166: PUSH
3167: LD_INT 3
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 24
3179: PUSH
3180: LD_INT 1000
3182: PUSH
3183: EMPTY
3184: LIST
3185: LIST
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: LIST
3195: PPUSH
3196: CALL_OW 69
3200: PUSH
3201: LD_INT 0
3203: EQUAL
3204: AND
3205: PUSH
3206: LD_VAR 0 2
3210: PUSH
3211: LD_INT 0
3213: GREATER
3214: AND
3215: IFFALSE 3314
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3217: LD_ADDR_VAR 0 4
3221: PUSH
3222: LD_INT 22
3224: PUSH
3225: LD_VAR 0 1
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: LD_INT 25
3236: PUSH
3237: LD_INT 2
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PUSH
3244: EMPTY
3245: LIST
3246: LIST
3247: PPUSH
3248: CALL_OW 69
3252: PUSH
3253: FOR_IN
3254: IFFALSE 3312
// begin AddComExitBuilding ( i ) ;
3256: LD_VAR 0 4
3260: PPUSH
3261: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3265: LD_VAR 0 4
3269: PPUSH
3270: LD_VAR 0 2
3274: PUSH
3275: LD_INT 1
3277: ARRAY
3278: PPUSH
3279: LD_VAR 0 2
3283: PUSH
3284: LD_INT 2
3286: ARRAY
3287: PPUSH
3288: LD_VAR 0 2
3292: PUSH
3293: LD_INT 3
3295: ARRAY
3296: PPUSH
3297: LD_VAR 0 2
3301: PUSH
3302: LD_INT 4
3304: ARRAY
3305: PPUSH
3306: CALL_OW 205
// end ;
3310: GO 3253
3312: POP
3313: POP
// end ; end ;
3314: LD_VAR 0 3
3318: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3319: LD_INT 0
3321: PPUSH
3322: PPUSH
3323: PPUSH
3324: PPUSH
3325: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3326: LD_ADDR_VAR 0 6
3330: PUSH
3331: LD_INT 22
3333: PUSH
3334: LD_VAR 0 1
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 2
3345: PUSH
3346: LD_INT 30
3348: PUSH
3349: LD_INT 31
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: LD_INT 30
3358: PUSH
3359: LD_INT 32
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: PUSH
3366: LD_INT 30
3368: PUSH
3369: LD_INT 33
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: PUSH
3376: LD_INT 30
3378: PUSH
3379: LD_INT 4
3381: PUSH
3382: EMPTY
3383: LIST
3384: LIST
3385: PUSH
3386: LD_INT 30
3388: PUSH
3389: LD_INT 5
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: LIST
3402: LIST
3403: PUSH
3404: EMPTY
3405: LIST
3406: LIST
3407: PPUSH
3408: CALL_OW 69
3412: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3413: LD_ADDR_VAR 0 7
3417: PUSH
3418: LD_INT 22
3420: PUSH
3421: LD_VAR 0 2
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: PUSH
3430: LD_INT 21
3432: PUSH
3433: LD_INT 3
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: PUSH
3440: LD_INT 58
3442: PUSH
3443: EMPTY
3444: LIST
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: PPUSH
3451: CALL_OW 69
3455: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3456: LD_VAR 0 6
3460: PUSH
3461: LD_INT 0
3463: GREATER
3464: PUSH
3465: LD_VAR 0 7
3469: PUSH
3470: LD_INT 0
3472: GREATER
3473: AND
3474: IFFALSE 3567
// begin for i in turretsList do
3476: LD_ADDR_VAR 0 4
3480: PUSH
3481: LD_VAR 0 6
3485: PUSH
3486: FOR_IN
3487: IFFALSE 3565
// begin for j in enemyBuildings do
3489: LD_ADDR_VAR 0 5
3493: PUSH
3494: LD_VAR 0 7
3498: PUSH
3499: FOR_IN
3500: IFFALSE 3561
// begin display_strings = [ GetDistUnits ( i , j ) ] ;
3502: LD_ADDR_OWVAR 47
3506: PUSH
3507: LD_VAR 0 4
3511: PPUSH
3512: LD_VAR 0 5
3516: PPUSH
3517: CALL_OW 296
3521: PUSH
3522: EMPTY
3523: LIST
3524: ST_TO_ADDR
// if GetDistUnits ( i , j ) < 20 then
3525: LD_VAR 0 4
3529: PPUSH
3530: LD_VAR 0 5
3534: PPUSH
3535: CALL_OW 296
3539: PUSH
3540: LD_INT 20
3542: LESS
3543: IFFALSE 3559
// begin ComAttackUnit ( i , j ) ;
3545: LD_VAR 0 4
3549: PPUSH
3550: LD_VAR 0 5
3554: PPUSH
3555: CALL_OW 115
// end ; end ;
3559: GO 3499
3561: POP
3562: POP
// end ;
3563: GO 3486
3565: POP
3566: POP
// end ; end ;
3567: LD_VAR 0 3
3571: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3572: LD_INT 0
3574: PPUSH
3575: PPUSH
3576: PPUSH
3577: PPUSH
3578: PPUSH
3579: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3580: LD_ADDR_VAR 0 7
3584: PUSH
3585: LD_INT 22
3587: PUSH
3588: LD_VAR 0 1
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: PUSH
3597: LD_INT 25
3599: PUSH
3600: LD_INT 9
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PPUSH
3611: CALL_OW 69
3615: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3616: LD_ADDR_VAR 0 8
3620: PUSH
3621: LD_INT 22
3623: PUSH
3624: LD_VAR 0 2
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: PUSH
3633: LD_INT 3
3635: PUSH
3636: LD_INT 21
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: PUSH
3646: EMPTY
3647: LIST
3648: LIST
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PPUSH
3654: CALL_OW 69
3658: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3659: LD_ADDR_VAR 0 5
3663: PUSH
3664: LD_INT 1
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: CALL_OW 12
3674: ST_TO_ADDR
// for i = 1 to list do
3675: LD_ADDR_VAR 0 6
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_VAR 0 7
3689: PUSH
3690: FOR_TO
3691: IFFALSE 3873
// for ta in filter do
3693: LD_ADDR_VAR 0 4
3697: PUSH
3698: LD_VAR 0 8
3702: PUSH
3703: FOR_IN
3704: IFFALSE 3869
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3706: LD_VAR 0 7
3710: PUSH
3711: LD_VAR 0 6
3715: ARRAY
3716: PPUSH
3717: LD_VAR 0 4
3721: PPUSH
3722: CALL_OW 296
3726: PUSH
3727: LD_INT 13
3729: LESSEQUAL
3730: IFFALSE 3867
// begin case c of 1 :
3732: LD_VAR 0 5
3736: PUSH
3737: LD_INT 1
3739: DOUBLE
3740: EQUAL
3741: IFTRUE 3745
3743: GO 3783
3745: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3746: LD_VAR 0 7
3750: PUSH
3751: LD_VAR 0 6
3755: ARRAY
3756: PPUSH
3757: LD_VAR 0 4
3761: PPUSH
3762: CALL_OW 250
3766: PPUSH
3767: LD_VAR 0 4
3771: PPUSH
3772: CALL_OW 251
3776: PPUSH
3777: CALL_OW 154
3781: GO 3867
3783: LD_INT 2
3785: DOUBLE
3786: EQUAL
3787: IFTRUE 3791
3789: GO 3855
3791: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
3792: LD_VAR 0 7
3796: PUSH
3797: LD_VAR 0 6
3801: ARRAY
3802: PPUSH
3803: LD_VAR 0 4
3807: PPUSH
3808: CALL_OW 250
3812: PUSH
3813: LD_INT 1
3815: NEG
3816: PPUSH
3817: LD_INT 1
3819: PPUSH
3820: CALL_OW 12
3824: PLUS
3825: PPUSH
3826: LD_VAR 0 4
3830: PPUSH
3831: CALL_OW 251
3835: PUSH
3836: LD_INT 1
3838: NEG
3839: PPUSH
3840: LD_INT 1
3842: PPUSH
3843: CALL_OW 12
3847: PLUS
3848: PPUSH
3849: CALL_OW 153
3853: GO 3867
3855: LD_INT 3
3857: DOUBLE
3858: EQUAL
3859: IFTRUE 3863
3861: GO 3866
3863: POP
// ; end ;
3864: GO 3867
3866: POP
// end ; end ;
3867: GO 3703
3869: POP
3870: POP
3871: GO 3690
3873: POP
3874: POP
// end ; end_of_file
3875: LD_VAR 0 3
3879: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
3880: LD_INT 0
3882: PPUSH
3883: PPUSH
// if exist_mode then
3884: LD_VAR 0 2
3888: IFFALSE 3907
// unit := CreateCharacter ( ident ) else
3890: LD_ADDR_VAR 0 4
3894: PUSH
3895: LD_VAR 0 1
3899: PPUSH
3900: CALL_OW 34
3904: ST_TO_ADDR
3905: GO 3922
// unit := NewCharacter ( ident ) ;
3907: LD_ADDR_VAR 0 4
3911: PUSH
3912: LD_VAR 0 1
3916: PPUSH
3917: CALL_OW 25
3921: ST_TO_ADDR
// result := unit ;
3922: LD_ADDR_VAR 0 3
3926: PUSH
3927: LD_VAR 0 4
3931: ST_TO_ADDR
// end ;
3932: LD_VAR 0 3
3936: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
3937: LD_INT 0
3939: PPUSH
3940: PPUSH
3941: PPUSH
// uc_side := GetSide ( b ) ;
3942: LD_ADDR_OWVAR 20
3946: PUSH
3947: LD_VAR 0 2
3951: PPUSH
3952: CALL_OW 255
3956: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
3957: LD_ADDR_OWVAR 21
3961: PUSH
3962: LD_VAR 0 2
3966: PPUSH
3967: CALL_OW 248
3971: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3972: LD_INT 0
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_VAR 0 1
3982: PPUSH
3983: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
3987: LD_ADDR_VAR 0 5
3991: PUSH
3992: LD_VAR 0 2
3996: PPUSH
3997: CALL_OW 254
4001: PUSH
4002: LD_INT 3
4004: MINUS
4005: ST_TO_ADDR
// if dir < 0 then
4006: LD_VAR 0 5
4010: PUSH
4011: LD_INT 0
4013: LESS
4014: IFFALSE 4030
// dir := 6 + dir ;
4016: LD_ADDR_VAR 0 5
4020: PUSH
4021: LD_INT 6
4023: PUSH
4024: LD_VAR 0 5
4028: PLUS
4029: ST_TO_ADDR
// un := CreateHuman ;
4030: LD_ADDR_VAR 0 4
4034: PUSH
4035: CALL_OW 44
4039: ST_TO_ADDR
// SetDir ( un , dir ) ;
4040: LD_VAR 0 4
4044: PPUSH
4045: LD_VAR 0 5
4049: PPUSH
4050: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4054: LD_VAR 0 4
4058: PPUSH
4059: LD_VAR 0 2
4063: PPUSH
4064: CALL_OW 52
// end ; end_of_file
4068: LD_VAR 0 3
4072: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
4073: LD_VAR 0 1
4077: PPUSH
4078: CALL_OW 255
4082: PUSH
4083: LD_INT 3
4085: EQUAL
4086: PUSH
4087: LD_VAR 0 1
4091: PPUSH
4092: CALL_OW 247
4096: PUSH
4097: LD_INT 3
4099: EQUAL
4100: AND
4101: IFFALSE 4793
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
4103: LD_VAR 0 1
4107: PPUSH
4108: CALL_OW 266
4112: PUSH
4113: LD_INT 31
4115: EQUAL
4116: PUSH
4117: LD_VAR 0 1
4121: PPUSH
4122: CALL_OW 266
4126: PUSH
4127: LD_INT 32
4129: EQUAL
4130: OR
4131: PUSH
4132: LD_VAR 0 1
4136: PPUSH
4137: CALL_OW 266
4141: PUSH
4142: LD_INT 36
4144: EQUAL
4145: OR
4146: PUSH
4147: LD_VAR 0 1
4151: PPUSH
4152: CALL_OW 266
4156: PUSH
4157: LD_INT 0
4159: EQUAL
4160: OR
4161: PUSH
4162: LD_VAR 0 1
4166: PPUSH
4167: CALL_OW 266
4171: PUSH
4172: LD_INT 24
4174: EQUAL
4175: OR
4176: PUSH
4177: LD_VAR 0 1
4181: PPUSH
4182: CALL_OW 266
4186: PUSH
4187: LD_INT 17
4189: EQUAL
4190: OR
4191: PUSH
4192: LD_VAR 0 1
4196: PPUSH
4197: CALL_OW 266
4201: PUSH
4202: LD_INT 25
4204: EQUAL
4205: OR
4206: PUSH
4207: LD_VAR 0 1
4211: PPUSH
4212: CALL_OW 266
4216: PUSH
4217: LD_INT 19
4219: EQUAL
4220: OR
4221: PUSH
4222: LD_VAR 0 1
4226: PPUSH
4227: CALL_OW 266
4231: PUSH
4232: LD_INT 20
4234: EQUAL
4235: OR
4236: PUSH
4237: LD_VAR 0 1
4241: PPUSH
4242: CALL_OW 266
4246: PUSH
4247: LD_INT 18
4249: EQUAL
4250: OR
4251: PUSH
4252: LD_VAR 0 1
4256: PPUSH
4257: CALL_OW 266
4261: PUSH
4262: LD_INT 21
4264: EQUAL
4265: OR
4266: PUSH
4267: LD_VAR 0 1
4271: PPUSH
4272: CALL_OW 266
4276: PUSH
4277: LD_INT 23
4279: EQUAL
4280: OR
4281: PUSH
4282: LD_VAR 0 1
4286: PPUSH
4287: CALL_OW 266
4291: PUSH
4292: LD_INT 16
4294: EQUAL
4295: OR
4296: PUSH
4297: LD_VAR 0 1
4301: PPUSH
4302: CALL_OW 266
4306: PUSH
4307: LD_INT 6
4309: EQUAL
4310: OR
4311: PUSH
4312: LD_VAR 0 1
4316: PPUSH
4317: CALL_OW 266
4321: PUSH
4322: LD_INT 29
4324: EQUAL
4325: OR
4326: PUSH
4327: LD_VAR 0 1
4331: PPUSH
4332: CALL_OW 266
4336: PUSH
4337: LD_INT 26
4339: EQUAL
4340: OR
4341: PUSH
4342: LD_VAR 0 1
4346: PPUSH
4347: CALL_OW 266
4351: PUSH
4352: LD_INT 30
4354: EQUAL
4355: OR
4356: PUSH
4357: LD_VAR 0 1
4361: PPUSH
4362: CALL_OW 266
4366: PUSH
4367: LD_INT 28
4369: EQUAL
4370: OR
4371: PUSH
4372: LD_VAR 0 1
4376: PPUSH
4377: CALL_OW 266
4381: PUSH
4382: LD_INT 27
4384: EQUAL
4385: OR
4386: PUSH
4387: LD_VAR 0 1
4391: PPUSH
4392: CALL_OW 266
4396: PUSH
4397: LD_INT 33
4399: EQUAL
4400: OR
4401: PUSH
4402: LD_VAR 0 1
4406: PPUSH
4407: CALL_OW 266
4411: PUSH
4412: LD_INT 2
4414: EQUAL
4415: OR
4416: PUSH
4417: LD_VAR 0 1
4421: PPUSH
4422: CALL_OW 266
4426: PUSH
4427: LD_INT 4
4429: EQUAL
4430: OR
4431: IFFALSE 4517
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
4433: LD_ADDR_EXP 1
4437: PUSH
4438: LD_EXP 1
4442: PUSH
4443: LD_VAR 0 1
4447: PPUSH
4448: CALL_OW 266
4452: ADD
4453: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4454: LD_ADDR_EXP 1
4458: PUSH
4459: LD_EXP 1
4463: PUSH
4464: LD_VAR 0 1
4468: PPUSH
4469: CALL_OW 250
4473: ADD
4474: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4475: LD_ADDR_EXP 1
4479: PUSH
4480: LD_EXP 1
4484: PUSH
4485: LD_VAR 0 1
4489: PPUSH
4490: CALL_OW 251
4494: ADD
4495: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4496: LD_ADDR_EXP 1
4500: PUSH
4501: LD_EXP 1
4505: PUSH
4506: LD_VAR 0 1
4510: PPUSH
4511: CALL_OW 254
4515: ADD
4516: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
4517: LD_VAR 0 1
4521: PPUSH
4522: CALL_OW 266
4526: PUSH
4527: LD_INT 1
4529: EQUAL
4530: IFFALSE 4609
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
4532: LD_ADDR_EXP 1
4536: PUSH
4537: LD_EXP 1
4541: PUSH
4542: LD_INT 0
4544: ADD
4545: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4546: LD_ADDR_EXP 1
4550: PUSH
4551: LD_EXP 1
4555: PUSH
4556: LD_VAR 0 1
4560: PPUSH
4561: CALL_OW 250
4565: ADD
4566: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4567: LD_ADDR_EXP 1
4571: PUSH
4572: LD_EXP 1
4576: PUSH
4577: LD_VAR 0 1
4581: PPUSH
4582: CALL_OW 251
4586: ADD
4587: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4588: LD_ADDR_EXP 1
4592: PUSH
4593: LD_EXP 1
4597: PUSH
4598: LD_VAR 0 1
4602: PPUSH
4603: CALL_OW 254
4607: ADD
4608: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4609: LD_VAR 0 1
4613: PPUSH
4614: CALL_OW 266
4618: PUSH
4619: LD_INT 3
4621: EQUAL
4622: IFFALSE 4701
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4624: LD_ADDR_EXP 1
4628: PUSH
4629: LD_EXP 1
4633: PUSH
4634: LD_INT 2
4636: ADD
4637: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4638: LD_ADDR_EXP 1
4642: PUSH
4643: LD_EXP 1
4647: PUSH
4648: LD_VAR 0 1
4652: PPUSH
4653: CALL_OW 250
4657: ADD
4658: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4659: LD_ADDR_EXP 1
4663: PUSH
4664: LD_EXP 1
4668: PUSH
4669: LD_VAR 0 1
4673: PPUSH
4674: CALL_OW 251
4678: ADD
4679: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4680: LD_ADDR_EXP 1
4684: PUSH
4685: LD_EXP 1
4689: PUSH
4690: LD_VAR 0 1
4694: PPUSH
4695: CALL_OW 254
4699: ADD
4700: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4701: LD_VAR 0 1
4705: PPUSH
4706: CALL_OW 266
4710: PUSH
4711: LD_INT 5
4713: EQUAL
4714: IFFALSE 4793
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
4716: LD_ADDR_EXP 1
4720: PUSH
4721: LD_EXP 1
4725: PUSH
4726: LD_INT 4
4728: ADD
4729: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4730: LD_ADDR_EXP 1
4734: PUSH
4735: LD_EXP 1
4739: PUSH
4740: LD_VAR 0 1
4744: PPUSH
4745: CALL_OW 250
4749: ADD
4750: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4751: LD_ADDR_EXP 1
4755: PUSH
4756: LD_EXP 1
4760: PUSH
4761: LD_VAR 0 1
4765: PPUSH
4766: CALL_OW 251
4770: ADD
4771: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4772: LD_ADDR_EXP 1
4776: PUSH
4777: LD_EXP 1
4781: PUSH
4782: LD_VAR 0 1
4786: PPUSH
4787: CALL_OW 254
4791: ADD
4792: ST_TO_ADDR
// end ; end ; end ;
4793: PPOPN 1
4795: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
4796: LD_VAR 0 1
4800: PPUSH
4801: CALL_OW 255
4805: PUSH
4806: LD_INT 3
4808: EQUAL
4809: IFFALSE 4883
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4811: LD_ADDR_EXP 1
4815: PUSH
4816: LD_EXP 1
4820: PPUSH
4821: LD_INT 1
4823: PPUSH
4824: CALL_OW 3
4828: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4829: LD_ADDR_EXP 1
4833: PUSH
4834: LD_EXP 1
4838: PPUSH
4839: LD_INT 1
4841: PPUSH
4842: CALL_OW 3
4846: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4847: LD_ADDR_EXP 1
4851: PUSH
4852: LD_EXP 1
4856: PPUSH
4857: LD_INT 1
4859: PPUSH
4860: CALL_OW 3
4864: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4865: LD_ADDR_EXP 1
4869: PUSH
4870: LD_EXP 1
4874: PPUSH
4875: LD_INT 1
4877: PPUSH
4878: CALL_OW 3
4882: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
4883: LD_VAR 0 1
4887: PPUSH
4888: CALL_OW 255
4892: PUSH
4893: LD_INT 3
4895: EQUAL
4896: PUSH
4897: LD_VAR 0 1
4901: PPUSH
4902: CALL_OW 266
4906: PUSH
4907: LD_INT 0
4909: EQUAL
4910: PUSH
4911: LD_VAR 0 1
4915: PPUSH
4916: CALL_OW 266
4920: PUSH
4921: LD_INT 2
4923: EQUAL
4924: OR
4925: PUSH
4926: LD_VAR 0 1
4930: PPUSH
4931: CALL_OW 266
4935: PUSH
4936: LD_INT 4
4938: EQUAL
4939: OR
4940: PUSH
4941: EMPTY
4942: LIST
4943: AND
4944: IFFALSE 4955
// ComUpgrade ( building ) ;
4946: LD_VAR 0 1
4950: PPUSH
4951: CALL_OW 146
// end ;
4955: PPOPN 1
4957: END
