// export destroyedBuildings ; export cargoTest ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// cargoTest = [ ] ;
  22: LD_ADDR_EXP 2
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// end ;
  29: END
// every 0 0$1 do
  30: GO 32
  32: DISABLE
// ComEnterUnit ( eng1 , ee1 ) ;
  33: LD_INT 95
  35: PPUSH
  36: LD_INT 94
  38: PPUSH
  39: CALL_OW 120
  43: END
// every 0 0$1 do var i ;
  44: GO 46
  46: DISABLE
  47: LD_INT 0
  49: PPUSH
// begin cargoTest = [ ] ;
  50: LD_ADDR_EXP 2
  54: PUSH
  55: EMPTY
  56: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , us_cargo_bay ] ] ) do
  57: LD_ADDR_VAR 0 1
  61: PUSH
  62: LD_INT 22
  64: PUSH
  65: LD_INT 3
  67: PUSH
  68: EMPTY
  69: LIST
  70: LIST
  71: PUSH
  72: LD_INT 34
  74: PUSH
  75: LD_INT 12
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: PPUSH
  86: CALL_OW 69
  90: PUSH
  91: FOR_IN
  92: IFFALSE 117
// cargoTest = cargoTest ^ GetMultiCargo ( i ) ;
  94: LD_ADDR_EXP 2
  98: PUSH
  99: LD_EXP 2
 103: PUSH
 104: LD_VAR 0 1
 108: PPUSH
 109: CALL 4300 0 1
 113: ADD
 114: ST_TO_ADDR
 115: GO 91
 117: POP
 118: POP
// display_strings = [ cargoTest ] ;
 119: LD_ADDR_OWVAR 47
 123: PUSH
 124: LD_EXP 2
 128: PUSH
 129: EMPTY
 130: LIST
 131: ST_TO_ADDR
// enable ;
 132: ENABLE
// end ; end_of_file
 133: PPOPN 1
 135: END
// every 0 0$1 do
 136: GO 138
 138: DISABLE
// begin end ;
 139: END
// every 5 5$1 do
 140: GO 142
 142: DISABLE
// begin end ; end_of_file
 143: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 144: LD_INT 0
 146: PPUSH
 147: PPUSH
 148: PPUSH
// rnd = rand ( 1 , characters ) ;
 149: LD_ADDR_VAR 0 6
 153: PUSH
 154: LD_INT 1
 156: PPUSH
 157: LD_VAR 0 1
 161: PPUSH
 162: CALL_OW 12
 166: ST_TO_ADDR
// for i = 1 to characters do
 167: LD_ADDR_VAR 0 5
 171: PUSH
 172: DOUBLE
 173: LD_INT 1
 175: DEC
 176: ST_TO_ADDR
 177: LD_VAR 0 1
 181: PUSH
 182: FOR_TO
 183: IFFALSE 293
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 185: LD_VAR 0 5
 189: PUSH
 190: LD_VAR 0 6
 194: EQUAL
 195: PUSH
 196: LD_VAR 0 1
 200: PUSH
 201: LD_VAR 0 5
 205: ARRAY
 206: PPUSH
 207: CALL_OW 258
 211: PUSH
 212: LD_INT 1
 214: EQUAL
 215: AND
 216: IFFALSE 238
// Say ( characters [ i ] , dialogMID ) ;
 218: LD_VAR 0 1
 222: PUSH
 223: LD_VAR 0 5
 227: ARRAY
 228: PPUSH
 229: LD_VAR 0 2
 233: PPUSH
 234: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 238: LD_VAR 0 5
 242: PUSH
 243: LD_VAR 0 6
 247: EQUAL
 248: PUSH
 249: LD_VAR 0 1
 253: PUSH
 254: LD_VAR 0 5
 258: ARRAY
 259: PPUSH
 260: CALL_OW 258
 264: PUSH
 265: LD_INT 2
 267: EQUAL
 268: AND
 269: IFFALSE 291
// Say ( characters [ i ] , dialogFID ) ;
 271: LD_VAR 0 1
 275: PUSH
 276: LD_VAR 0 5
 280: ARRAY
 281: PPUSH
 282: LD_VAR 0 3
 286: PPUSH
 287: CALL_OW 88
// end ;
 291: GO 182
 293: POP
 294: POP
// end ;
 295: LD_VAR 0 4
 299: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
 305: PPUSH
// for i = 1 to count do
 306: LD_ADDR_VAR 0 8
 310: PUSH
 311: DOUBLE
 312: LD_INT 1
 314: DEC
 315: ST_TO_ADDR
 316: LD_VAR 0 6
 320: PUSH
 321: FOR_TO
 322: IFFALSE 403
// begin uc_side = side ;
 324: LD_ADDR_OWVAR 20
 328: PUSH
 329: LD_VAR 0 1
 333: ST_TO_ADDR
// uc_nation = nation ;
 334: LD_ADDR_OWVAR 21
 338: PUSH
 339: LD_VAR 0 2
 343: ST_TO_ADDR
// hc_gallery =  ;
 344: LD_ADDR_OWVAR 33
 348: PUSH
 349: LD_STRING 
 351: ST_TO_ADDR
// hc_name =  ;
 352: LD_ADDR_OWVAR 26
 356: PUSH
 357: LD_STRING 
 359: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 360: LD_INT 0
 362: PPUSH
 363: LD_VAR 0 5
 367: PPUSH
 368: LD_VAR 0 4
 372: PPUSH
 373: CALL_OW 380
// un = CreateHuman ;
 377: LD_ADDR_VAR 0 10
 381: PUSH
 382: CALL_OW 44
 386: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 387: LD_VAR 0 10
 391: PPUSH
 392: LD_VAR 0 3
 396: PPUSH
 397: CALL_OW 52
// end ;
 401: GO 321
 403: POP
 404: POP
// end ;
 405: LD_VAR 0 7
 409: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 410: LD_INT 0
 412: PPUSH
 413: PPUSH
// for i in charactersList do
 414: LD_ADDR_VAR 0 4
 418: PUSH
 419: LD_VAR 0 1
 423: PUSH
 424: FOR_IN
 425: IFFALSE 465
// begin if IsOk ( i ) then
 427: LD_VAR 0 4
 431: PPUSH
 432: CALL_OW 302
 436: IFFALSE 454
// begin SaveCharacters ( i , ident ) ;
 438: LD_VAR 0 4
 442: PPUSH
 443: LD_VAR 0 2
 447: PPUSH
 448: CALL_OW 38
// end else
 452: GO 463
// begin DeleteCharacters ( ident ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: CALL_OW 40
// end ; end ;
 463: GO 424
 465: POP
 466: POP
// end ;
 467: LD_VAR 0 3
 471: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 472: LD_INT 0
 474: PPUSH
 475: PPUSH
 476: PPUSH
 477: PPUSH
 478: PPUSH
 479: PPUSH
 480: PPUSH
 481: PPUSH
 482: PPUSH
 483: PPUSH
 484: PPUSH
// amChassisTab = [ ] ;
 485: LD_ADDR_VAR 0 19
 489: PUSH
 490: EMPTY
 491: ST_TO_ADDR
// arChassisTab = [ ] ;
 492: LD_ADDR_VAR 0 18
 496: PUSH
 497: EMPTY
 498: ST_TO_ADDR
// ruChassisTab = [ ] ;
 499: LD_ADDR_VAR 0 17
 503: PUSH
 504: EMPTY
 505: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 506: LD_INT 35
 508: PPUSH
 509: CALL_OW 67
// if nation = 1 then
 513: LD_VAR 0 5
 517: PUSH
 518: LD_INT 1
 520: EQUAL
 521: IFFALSE 1012
// begin uc_side = side ;
 523: LD_ADDR_OWVAR 20
 527: PUSH
 528: LD_VAR 0 2
 532: ST_TO_ADDR
// uc_nation = nation ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 5
 542: ST_TO_ADDR
// vc_engine = vehengine ;
 543: LD_ADDR_OWVAR 39
 547: PUSH
 548: LD_VAR 0 6
 552: ST_TO_ADDR
// vc_control = vehcontrol ;
 553: LD_ADDR_OWVAR 38
 557: PUSH
 558: LD_VAR 0 7
 562: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 563: LD_ADDR_OWVAR 40
 567: PUSH
 568: LD_VAR 0 10
 572: PUSH
 573: LD_INT 1
 575: PPUSH
 576: LD_VAR 0 10
 580: PPUSH
 581: CALL_OW 12
 585: ARRAY
 586: ST_TO_ADDR
// for j = 1 to AMWeapon do
 587: LD_ADDR_VAR 0 14
 591: PUSH
 592: DOUBLE
 593: LD_INT 1
 595: DEC
 596: ST_TO_ADDR
 597: LD_VAR 0 10
 601: PUSH
 602: FOR_TO
 603: IFFALSE 904
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 605: LD_VAR 0 10
 609: PUSH
 610: LD_VAR 0 14
 614: ARRAY
 615: PUSH
 616: LD_INT 2
 618: EQUAL
 619: PUSH
 620: LD_VAR 0 10
 624: PUSH
 625: LD_VAR 0 14
 629: ARRAY
 630: PUSH
 631: LD_INT 3
 633: EQUAL
 634: OR
 635: IFFALSE 688
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 637: LD_ADDR_VAR 0 19
 641: PUSH
 642: LD_INT 1
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: LD_INT 3
 650: PUSH
 651: LD_INT 4
 653: PUSH
 654: LD_INT 5
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 664: LD_ADDR_OWVAR 37
 668: PUSH
 669: LD_VAR 0 19
 673: PUSH
 674: LD_INT 1
 676: PPUSH
 677: LD_VAR 0 19
 681: PPUSH
 682: CALL_OW 12
 686: ARRAY
 687: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 688: LD_VAR 0 10
 692: PUSH
 693: LD_VAR 0 14
 697: ARRAY
 698: PUSH
 699: LD_INT 4
 701: EQUAL
 702: PUSH
 703: LD_VAR 0 10
 707: PUSH
 708: LD_VAR 0 14
 712: ARRAY
 713: PUSH
 714: LD_INT 5
 716: EQUAL
 717: OR
 718: PUSH
 719: LD_VAR 0 10
 723: PUSH
 724: LD_VAR 0 14
 728: ARRAY
 729: PUSH
 730: LD_INT 9
 732: EQUAL
 733: OR
 734: PUSH
 735: LD_VAR 0 10
 739: PUSH
 740: LD_VAR 0 14
 744: ARRAY
 745: PUSH
 746: LD_INT 11
 748: EQUAL
 749: OR
 750: PUSH
 751: LD_VAR 0 10
 755: PUSH
 756: LD_VAR 0 14
 760: ARRAY
 761: PUSH
 762: LD_INT 7
 764: EQUAL
 765: OR
 766: IFFALSE 815
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
 768: LD_ADDR_VAR 0 19
 772: PUSH
 773: LD_INT 2
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 4
 781: PUSH
 782: LD_INT 5
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 791: LD_ADDR_OWVAR 37
 795: PUSH
 796: LD_VAR 0 19
 800: PUSH
 801: LD_INT 1
 803: PPUSH
 804: LD_VAR 0 19
 808: PPUSH
 809: CALL_OW 12
 813: ARRAY
 814: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
 815: LD_VAR 0 10
 819: PUSH
 820: LD_VAR 0 14
 824: ARRAY
 825: PUSH
 826: LD_INT 8
 828: EQUAL
 829: PUSH
 830: LD_VAR 0 10
 834: PUSH
 835: LD_VAR 0 14
 839: ARRAY
 840: PUSH
 841: LD_INT 6
 843: EQUAL
 844: OR
 845: PUSH
 846: LD_VAR 0 10
 850: PUSH
 851: LD_VAR 0 14
 855: ARRAY
 856: PUSH
 857: LD_INT 10
 859: EQUAL
 860: OR
 861: IFFALSE 902
// begin amChassisTab = [ 4 , 5 ] ;
 863: LD_ADDR_VAR 0 19
 867: PUSH
 868: LD_INT 4
 870: PUSH
 871: LD_INT 5
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 878: LD_ADDR_OWVAR 37
 882: PUSH
 883: LD_VAR 0 19
 887: PUSH
 888: LD_INT 1
 890: PPUSH
 891: LD_VAR 0 19
 895: PPUSH
 896: CALL_OW 12
 900: ARRAY
 901: ST_TO_ADDR
// end ; end ;
 902: GO 602
 904: POP
 905: POP
// veh = CreateVehicle ;
 906: LD_ADDR_VAR 0 16
 910: PUSH
 911: CALL_OW 45
 915: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
 916: LD_VAR 0 16
 920: PPUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 49
// if vehControl = 1 then
 933: LD_VAR 0 7
 937: PUSH
 938: LD_INT 1
 940: EQUAL
 941: IFFALSE 998
// begin hc_gallery =  ;
 943: LD_ADDR_OWVAR 33
 947: PUSH
 948: LD_STRING 
 950: ST_TO_ADDR
// hc_name =  ;
 951: LD_ADDR_OWVAR 26
 955: PUSH
 956: LD_STRING 
 958: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
 959: LD_INT 0
 961: PPUSH
 962: LD_INT 3
 964: PPUSH
 965: LD_VAR 0 4
 969: PPUSH
 970: CALL_OW 380
// un = CreateHuman ;
 974: LD_ADDR_VAR 0 15
 978: PUSH
 979: CALL_OW 44
 983: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
 984: LD_VAR 0 15
 988: PPUSH
 989: LD_VAR 0 16
 993: PPUSH
 994: CALL_OW 52
// end ; i = i + 1 ;
 998: LD_ADDR_VAR 0 13
1002: PUSH
1003: LD_VAR 0 13
1007: PUSH
1008: LD_INT 1
1010: PLUS
1011: ST_TO_ADDR
// end ; if nation = 2 then
1012: LD_VAR 0 5
1016: PUSH
1017: LD_INT 2
1019: EQUAL
1020: IFFALSE 1444
// begin uc_side = side ;
1022: LD_ADDR_OWVAR 20
1026: PUSH
1027: LD_VAR 0 2
1031: ST_TO_ADDR
// uc_nation = nation ;
1032: LD_ADDR_OWVAR 21
1036: PUSH
1037: LD_VAR 0 5
1041: ST_TO_ADDR
// vc_engine = vehengine ;
1042: LD_ADDR_OWVAR 39
1046: PUSH
1047: LD_VAR 0 6
1051: ST_TO_ADDR
// vc_control = vehcontrol ;
1052: LD_ADDR_OWVAR 38
1056: PUSH
1057: LD_VAR 0 7
1061: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1062: LD_ADDR_OWVAR 40
1066: PUSH
1067: LD_VAR 0 9
1071: PUSH
1072: LD_INT 1
1074: PPUSH
1075: LD_VAR 0 9
1079: PPUSH
1080: CALL_OW 12
1084: ARRAY
1085: ST_TO_ADDR
// for j = 1 to ARWeapons do
1086: LD_ADDR_VAR 0 14
1090: PUSH
1091: DOUBLE
1092: LD_INT 1
1094: DEC
1095: ST_TO_ADDR
1096: LD_VAR 0 9
1100: PUSH
1101: FOR_TO
1102: IFFALSE 1336
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1104: LD_VAR 0 9
1108: PUSH
1109: LD_VAR 0 14
1113: ARRAY
1114: PUSH
1115: LD_INT 24
1117: EQUAL
1118: PUSH
1119: LD_VAR 0 9
1123: PUSH
1124: LD_VAR 0 14
1128: ARRAY
1129: PUSH
1130: LD_INT 22
1132: EQUAL
1133: OR
1134: PUSH
1135: LD_VAR 0 9
1139: PUSH
1140: LD_VAR 0 14
1144: ARRAY
1145: PUSH
1146: LD_INT 23
1148: EQUAL
1149: OR
1150: PUSH
1151: LD_VAR 0 9
1155: PUSH
1156: LD_VAR 0 14
1160: ARRAY
1161: PUSH
1162: LD_INT 30
1164: EQUAL
1165: OR
1166: IFFALSE 1215
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1168: LD_ADDR_VAR 0 18
1172: PUSH
1173: LD_INT 11
1175: PUSH
1176: LD_INT 12
1178: PUSH
1179: LD_INT 13
1181: PUSH
1182: LD_INT 14
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1191: LD_ADDR_OWVAR 37
1195: PUSH
1196: LD_VAR 0 18
1200: PUSH
1201: LD_INT 1
1203: PPUSH
1204: LD_VAR 0 18
1208: PPUSH
1209: CALL_OW 12
1213: ARRAY
1214: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1215: LD_VAR 0 9
1219: PUSH
1220: LD_VAR 0 14
1224: ARRAY
1225: PUSH
1226: LD_INT 29
1228: EQUAL
1229: PUSH
1230: LD_VAR 0 9
1234: PUSH
1235: LD_VAR 0 14
1239: ARRAY
1240: PUSH
1241: LD_INT 28
1243: EQUAL
1244: OR
1245: PUSH
1246: LD_VAR 0 9
1250: PUSH
1251: LD_VAR 0 14
1255: ARRAY
1256: PUSH
1257: LD_INT 27
1259: EQUAL
1260: OR
1261: PUSH
1262: LD_VAR 0 9
1266: PUSH
1267: LD_VAR 0 14
1271: ARRAY
1272: PUSH
1273: LD_INT 26
1275: EQUAL
1276: OR
1277: PUSH
1278: LD_VAR 0 9
1282: PUSH
1283: LD_VAR 0 14
1287: ARRAY
1288: PUSH
1289: LD_INT 25
1291: EQUAL
1292: OR
1293: IFFALSE 1334
// begin arChassisTab = [ 13 , 14 ] ;
1295: LD_ADDR_VAR 0 18
1299: PUSH
1300: LD_INT 13
1302: PUSH
1303: LD_INT 14
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1310: LD_ADDR_OWVAR 37
1314: PUSH
1315: LD_VAR 0 18
1319: PUSH
1320: LD_INT 1
1322: PPUSH
1323: LD_VAR 0 18
1327: PPUSH
1328: CALL_OW 12
1332: ARRAY
1333: ST_TO_ADDR
// end ; end ;
1334: GO 1101
1336: POP
1337: POP
// veh = CreateVehicle ;
1338: LD_ADDR_VAR 0 16
1342: PUSH
1343: CALL_OW 45
1347: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1348: LD_VAR 0 16
1352: PPUSH
1353: LD_VAR 0 1
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// if vehcontrol = 1 then
1365: LD_VAR 0 7
1369: PUSH
1370: LD_INT 1
1372: EQUAL
1373: IFFALSE 1430
// begin hc_gallery =  ;
1375: LD_ADDR_OWVAR 33
1379: PUSH
1380: LD_STRING 
1382: ST_TO_ADDR
// hc_name =  ;
1383: LD_ADDR_OWVAR 26
1387: PUSH
1388: LD_STRING 
1390: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1391: LD_INT 0
1393: PPUSH
1394: LD_INT 3
1396: PPUSH
1397: LD_VAR 0 4
1401: PPUSH
1402: CALL_OW 380
// un = CreateHuman ;
1406: LD_ADDR_VAR 0 15
1410: PUSH
1411: CALL_OW 44
1415: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1416: LD_VAR 0 15
1420: PPUSH
1421: LD_VAR 0 16
1425: PPUSH
1426: CALL_OW 52
// end ; i = i + 1 ;
1430: LD_ADDR_VAR 0 13
1434: PUSH
1435: LD_VAR 0 13
1439: PUSH
1440: LD_INT 1
1442: PLUS
1443: ST_TO_ADDR
// end ; if nation = 3 then
1444: LD_VAR 0 5
1448: PUSH
1449: LD_INT 3
1451: EQUAL
1452: IFFALSE 1844
// begin uc_side = side ;
1454: LD_ADDR_OWVAR 20
1458: PUSH
1459: LD_VAR 0 2
1463: ST_TO_ADDR
// uc_nation = nation ;
1464: LD_ADDR_OWVAR 21
1468: PUSH
1469: LD_VAR 0 5
1473: ST_TO_ADDR
// vc_engine = vehengine ;
1474: LD_ADDR_OWVAR 39
1478: PUSH
1479: LD_VAR 0 6
1483: ST_TO_ADDR
// vc_control = vehcontrol ;
1484: LD_ADDR_OWVAR 38
1488: PUSH
1489: LD_VAR 0 7
1493: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1494: LD_ADDR_OWVAR 40
1498: PUSH
1499: LD_VAR 0 8
1503: PUSH
1504: LD_INT 1
1506: PPUSH
1507: LD_VAR 0 8
1511: PPUSH
1512: CALL_OW 12
1516: ARRAY
1517: ST_TO_ADDR
// for j = 1 to RuWeapons do
1518: LD_ADDR_VAR 0 14
1522: PUSH
1523: DOUBLE
1524: LD_INT 1
1526: DEC
1527: ST_TO_ADDR
1528: LD_VAR 0 8
1532: PUSH
1533: FOR_TO
1534: IFFALSE 1736
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1536: LD_VAR 0 8
1540: PUSH
1541: LD_VAR 0 14
1545: ARRAY
1546: PUSH
1547: LD_INT 42
1549: EQUAL
1550: PUSH
1551: LD_VAR 0 8
1555: PUSH
1556: LD_VAR 0 14
1560: ARRAY
1561: PUSH
1562: LD_INT 43
1564: EQUAL
1565: OR
1566: PUSH
1567: LD_VAR 0 8
1571: PUSH
1572: LD_VAR 0 14
1576: ARRAY
1577: PUSH
1578: LD_INT 44
1580: EQUAL
1581: OR
1582: PUSH
1583: LD_VAR 0 8
1587: PUSH
1588: LD_VAR 0 14
1592: ARRAY
1593: PUSH
1594: LD_INT 45
1596: EQUAL
1597: OR
1598: PUSH
1599: LD_VAR 0 8
1603: PUSH
1604: LD_VAR 0 14
1608: ARRAY
1609: PUSH
1610: LD_INT 49
1612: EQUAL
1613: OR
1614: IFFALSE 1663
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1616: LD_ADDR_VAR 0 17
1620: PUSH
1621: LD_INT 21
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 23
1629: PUSH
1630: LD_INT 24
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1639: LD_ADDR_OWVAR 37
1643: PUSH
1644: LD_VAR 0 17
1648: PUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_VAR 0 17
1656: PPUSH
1657: CALL_OW 12
1661: ARRAY
1662: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1663: LD_VAR 0 8
1667: PUSH
1668: LD_VAR 0 14
1672: ARRAY
1673: PUSH
1674: LD_INT 46
1676: EQUAL
1677: PUSH
1678: LD_VAR 0 8
1682: PUSH
1683: LD_VAR 0 14
1687: ARRAY
1688: PUSH
1689: LD_INT 47
1691: EQUAL
1692: OR
1693: IFFALSE 1734
// begin ruChassisTab = [ 23 , 24 ] ;
1695: LD_ADDR_VAR 0 17
1699: PUSH
1700: LD_INT 23
1702: PUSH
1703: LD_INT 24
1705: PUSH
1706: EMPTY
1707: LIST
1708: LIST
1709: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1710: LD_ADDR_OWVAR 37
1714: PUSH
1715: LD_VAR 0 17
1719: PUSH
1720: LD_INT 1
1722: PPUSH
1723: LD_VAR 0 17
1727: PPUSH
1728: CALL_OW 12
1732: ARRAY
1733: ST_TO_ADDR
// end ; end ;
1734: GO 1533
1736: POP
1737: POP
// veh = CreateVehicle ;
1738: LD_ADDR_VAR 0 16
1742: PUSH
1743: CALL_OW 45
1747: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1748: LD_VAR 0 16
1752: PPUSH
1753: LD_VAR 0 1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 49
// if vehcontrol = 1 then
1765: LD_VAR 0 7
1769: PUSH
1770: LD_INT 1
1772: EQUAL
1773: IFFALSE 1830
// begin hc_gallery =  ;
1775: LD_ADDR_OWVAR 33
1779: PUSH
1780: LD_STRING 
1782: ST_TO_ADDR
// hc_name =  ;
1783: LD_ADDR_OWVAR 26
1787: PUSH
1788: LD_STRING 
1790: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1791: LD_INT 0
1793: PPUSH
1794: LD_INT 3
1796: PPUSH
1797: LD_VAR 0 4
1801: PPUSH
1802: CALL_OW 380
// un = CreateHuman ;
1806: LD_ADDR_VAR 0 15
1810: PUSH
1811: CALL_OW 44
1815: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1816: LD_VAR 0 15
1820: PPUSH
1821: LD_VAR 0 16
1825: PPUSH
1826: CALL_OW 52
// end ; i = i + 1 ;
1830: LD_ADDR_VAR 0 13
1834: PUSH
1835: LD_VAR 0 13
1839: PUSH
1840: LD_INT 1
1842: PLUS
1843: ST_TO_ADDR
// end ; until i = vehCount ;
1844: LD_VAR 0 13
1848: PUSH
1849: LD_VAR 0 3
1853: EQUAL
1854: IFFALSE 506
// repeat wait ( 0 0$1 ) ;
1856: LD_INT 35
1858: PPUSH
1859: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
1863: LD_ADDR_VAR 0 20
1867: PUSH
1868: LD_INT 22
1870: PUSH
1871: LD_VAR 0 2
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: PUSH
1880: LD_INT 21
1882: PUSH
1883: LD_INT 2
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: PUSH
1890: LD_INT 24
1892: PUSH
1893: LD_INT 650
1895: PUSH
1896: EMPTY
1897: LIST
1898: LIST
1899: PUSH
1900: EMPTY
1901: LIST
1902: LIST
1903: LIST
1904: PPUSH
1905: CALL_OW 69
1909: ST_TO_ADDR
// if vehicleOK_list > 0 then
1910: LD_VAR 0 20
1914: PUSH
1915: LD_INT 0
1917: GREATER
1918: IFFALSE 2109
// begin for i in vehicleOK_list do
1920: LD_ADDR_VAR 0 13
1924: PUSH
1925: LD_VAR 0 20
1929: PUSH
1930: FOR_IN
1931: IFFALSE 2107
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
1933: LD_ADDR_VAR 0 21
1937: PUSH
1938: LD_INT 22
1940: PUSH
1941: LD_VAR 0 11
1945: PUSH
1946: EMPTY
1947: LIST
1948: LIST
1949: PPUSH
1950: CALL_OW 69
1954: PPUSH
1955: LD_VAR 0 13
1959: PPUSH
1960: CALL_OW 74
1964: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
1965: LD_ADDR_VAR 0 22
1969: PUSH
1970: LD_INT 22
1972: PUSH
1973: LD_VAR 0 11
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 2
1984: PUSH
1985: LD_INT 59
1987: PUSH
1988: EMPTY
1989: LIST
1990: PUSH
1991: LD_INT 21
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 21
2003: PUSH
2004: LD_INT 2
2006: PUSH
2007: EMPTY
2008: LIST
2009: LIST
2010: PUSH
2011: EMPTY
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: PUSH
2017: EMPTY
2018: LIST
2019: LIST
2020: PUSH
2021: EMPTY
2022: LIST
2023: PPUSH
2024: CALL_OW 69
2028: PPUSH
2029: LD_VAR 0 13
2033: PPUSH
2034: CALL_OW 74
2038: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2039: LD_VAR 0 13
2043: PPUSH
2044: LD_VAR 0 21
2048: PPUSH
2049: CALL_OW 296
2053: PUSH
2054: LD_INT 8
2056: PLUS
2057: PUSH
2058: LD_VAR 0 13
2062: PPUSH
2063: LD_VAR 0 22
2067: PPUSH
2068: CALL_OW 296
2072: LESS
2073: IFFALSE 2091
// begin ComAttackUnit ( i , target1 ) ;
2075: LD_VAR 0 13
2079: PPUSH
2080: LD_VAR 0 21
2084: PPUSH
2085: CALL_OW 115
// end else
2089: GO 2105
// begin ComAttackUnit ( i , target2 ) ;
2091: LD_VAR 0 13
2095: PPUSH
2096: LD_VAR 0 22
2100: PPUSH
2101: CALL_OW 115
// end ; end ;
2105: GO 1930
2107: POP
2108: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2109: LD_INT 22
2111: PUSH
2112: LD_VAR 0 2
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PUSH
2121: LD_INT 21
2123: PUSH
2124: LD_INT 2
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PPUSH
2135: CALL_OW 69
2139: PUSH
2140: LD_INT 0
2142: EQUAL
2143: IFFALSE 1856
// end ;
2145: LD_VAR 0 12
2149: RET
// every 0 0$1 do
2150: GO 2152
2152: DISABLE
// begin enable ;
2153: ENABLE
// end ;
2154: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2155: LD_INT 0
2157: PPUSH
2158: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2159: LD_INT 22
2161: PUSH
2162: LD_VAR 0 1
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 21
2173: PUSH
2174: LD_INT 2
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: PPUSH
2185: CALL_OW 69
2189: PUSH
2190: LD_VAR 0 3
2194: LESSEQUAL
2195: IFFALSE 2262
// for i = 1 to vehCount do
2197: LD_ADDR_VAR 0 9
2201: PUSH
2202: DOUBLE
2203: LD_INT 1
2205: DEC
2206: ST_TO_ADDR
2207: LD_VAR 0 3
2211: PUSH
2212: FOR_TO
2213: IFFALSE 2260
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2215: LD_VAR 0 2
2219: PPUSH
2220: LD_VAR 0 7
2224: PPUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 6
2234: PPUSH
2235: LD_VAR 0 4
2239: PUSH
2240: LD_INT 1
2242: PPUSH
2243: LD_VAR 0 4
2247: PPUSH
2248: CALL_OW 12
2252: ARRAY
2253: PPUSH
2254: CALL_OW 185
2258: GO 2212
2260: POP
2261: POP
// end ;
2262: LD_VAR 0 8
2266: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2267: LD_INT 0
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
2273: PPUSH
// for i := 1 to CPU1Tanks do
2274: LD_ADDR_VAR 0 4
2278: PUSH
2279: DOUBLE
2280: LD_INT 1
2282: DEC
2283: ST_TO_ADDR
2284: LD_EXP 4
2288: PUSH
2289: FOR_TO
2290: IFFALSE 2618
// begin if i = 4 then
2292: LD_VAR 0 4
2296: PUSH
2297: LD_INT 4
2299: EQUAL
2300: IFFALSE 2616
// begin repeat wait ( 0 0$1 ) ;
2302: LD_INT 35
2304: PPUSH
2305: CALL_OW 67
// for i in CPU1Tanks do
2309: LD_ADDR_VAR 0 4
2313: PUSH
2314: LD_EXP 4
2318: PUSH
2319: FOR_IN
2320: IFFALSE 2604
// begin if GetLives ( i ) < 659 then
2322: LD_VAR 0 4
2326: PPUSH
2327: CALL_OW 256
2331: PUSH
2332: LD_INT 659
2334: LESS
2335: IFFALSE 2423
// begin tmp = i ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 4
2346: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2347: LD_ADDR_VAR 0 4
2351: PUSH
2352: DOUBLE
2353: LD_INT 1
2355: DEC
2356: ST_TO_ADDR
2357: LD_EXP 4
2361: PUSH
2362: FOR_TO
2363: IFFALSE 2421
// begin if tmp = CPU1Tanks [ i ] then
2365: LD_VAR 0 5
2369: PUSH
2370: LD_EXP 4
2374: PUSH
2375: LD_VAR 0 4
2379: ARRAY
2380: EQUAL
2381: IFFALSE 2419
// begin CPU1Tanks = Delete ( CPU1Tanks , i ) ;
2383: LD_ADDR_EXP 4
2387: PUSH
2388: LD_EXP 4
2392: PPUSH
2393: LD_VAR 0 4
2397: PPUSH
2398: CALL_OW 3
2402: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2403: LD_ADDR_EXP 5
2407: PUSH
2408: LD_EXP 5
2412: PUSH
2413: LD_VAR 0 5
2417: ADD
2418: ST_TO_ADDR
// end ; end ;
2419: GO 2362
2421: POP
2422: POP
// end ; wait ( 0 0$1 ) ;
2423: LD_INT 35
2425: PPUSH
2426: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2430: LD_ADDR_VAR 0 6
2434: PUSH
2435: LD_INT 22
2437: PUSH
2438: LD_VAR 0 2
2442: PUSH
2443: EMPTY
2444: LIST
2445: LIST
2446: PPUSH
2447: CALL_OW 69
2451: PPUSH
2452: LD_VAR 0 4
2456: PPUSH
2457: CALL_OW 74
2461: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2462: LD_ADDR_VAR 0 7
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_VAR 0 2
2474: PUSH
2475: EMPTY
2476: LIST
2477: LIST
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: LD_INT 59
2484: PUSH
2485: EMPTY
2486: LIST
2487: PUSH
2488: LD_INT 21
2490: PUSH
2491: LD_INT 1
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: PUSH
2498: LD_INT 21
2500: PUSH
2501: LD_INT 2
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: LIST
2512: LIST
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PUSH
2518: EMPTY
2519: LIST
2520: PPUSH
2521: CALL_OW 69
2525: PPUSH
2526: LD_VAR 0 4
2530: PPUSH
2531: CALL_OW 74
2535: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2536: LD_VAR 0 4
2540: PPUSH
2541: LD_VAR 0 6
2545: PPUSH
2546: CALL_OW 296
2550: PUSH
2551: LD_INT 8
2553: PLUS
2554: PUSH
2555: LD_VAR 0 4
2559: PPUSH
2560: LD_VAR 0 7
2564: PPUSH
2565: CALL_OW 296
2569: LESS
2570: IFFALSE 2588
// begin ComAttackUnit ( i , target1 ) ;
2572: LD_VAR 0 4
2576: PPUSH
2577: LD_VAR 0 6
2581: PPUSH
2582: CALL_OW 115
// end else
2586: GO 2602
// begin ComAttackUnit ( i , target2 ) ;
2588: LD_VAR 0 4
2592: PPUSH
2593: LD_VAR 0 7
2597: PPUSH
2598: CALL_OW 115
// end ; end ;
2602: GO 2319
2604: POP
2605: POP
// until CPU1Tanks = 0 ;
2606: LD_EXP 4
2610: PUSH
2611: LD_INT 0
2613: EQUAL
2614: IFFALSE 2302
// end ; end ;
2616: GO 2289
2618: POP
2619: POP
// end ;
2620: LD_VAR 0 3
2624: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2625: LD_INT 0
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
2633: PPUSH
2634: PPUSH
2635: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
2636: LD_ADDR_VAR 0 8
2640: PUSH
2641: LD_INT 22
2643: PUSH
2644: LD_VAR 0 1
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 21
2655: PUSH
2656: LD_INT 2
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: LD_INT 24
2665: PUSH
2666: LD_INT 660
2668: PUSH
2669: EMPTY
2670: LIST
2671: LIST
2672: PUSH
2673: LD_INT 3
2675: PUSH
2676: LD_INT 58
2678: PUSH
2679: EMPTY
2680: LIST
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: LIST
2690: LIST
2691: PPUSH
2692: CALL_OW 69
2696: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2697: LD_ADDR_VAR 0 9
2701: PUSH
2702: LD_INT 22
2704: PUSH
2705: LD_VAR 0 1
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: PUSH
2714: LD_INT 21
2716: PUSH
2717: LD_INT 2
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: PUSH
2724: LD_INT 3
2726: PUSH
2727: LD_INT 24
2729: PUSH
2730: LD_INT 660
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: PPUSH
2746: CALL_OW 69
2750: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2751: LD_ADDR_VAR 0 10
2755: PUSH
2756: LD_VAR 0 2
2760: PPUSH
2761: LD_INT 22
2763: PUSH
2764: LD_VAR 0 1
2768: PUSH
2769: EMPTY
2770: LIST
2771: LIST
2772: PUSH
2773: LD_INT 21
2775: PUSH
2776: LD_INT 2
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: PUSH
2783: LD_INT 3
2785: PUSH
2786: LD_INT 24
2788: PUSH
2789: LD_INT 1000
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: PPUSH
2805: CALL_OW 70
2809: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
2810: LD_ADDR_VAR 0 11
2814: PUSH
2815: LD_VAR 0 2
2819: PPUSH
2820: LD_INT 22
2822: PUSH
2823: LD_VAR 0 1
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 21
2834: PUSH
2835: LD_INT 2
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 24
2844: PUSH
2845: LD_INT 1000
2847: PUSH
2848: EMPTY
2849: LIST
2850: LIST
2851: PUSH
2852: LD_INT 58
2854: PUSH
2855: EMPTY
2856: LIST
2857: PUSH
2858: EMPTY
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: PPUSH
2864: CALL_OW 70
2868: ST_TO_ADDR
// mechanicInside_list = [ ] ;
2869: LD_ADDR_VAR 0 12
2873: PUSH
2874: EMPTY
2875: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
2876: LD_ADDR_VAR 0 13
2880: PUSH
2881: LD_VAR 0 2
2885: PPUSH
2886: LD_INT 22
2888: PUSH
2889: LD_VAR 0 1
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PUSH
2898: LD_INT 25
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: PPUSH
2912: CALL_OW 70
2916: ST_TO_ADDR
// display_strings = [ w polu:  , CPU1Tanks , uszkodzone:  , CPU1DamageTanks , wylosowane: 4 , ok , vehicleOK_list ] ;
2917: LD_ADDR_OWVAR 47
2921: PUSH
2922: LD_STRING w polu: 
2924: PUSH
2925: LD_EXP 4
2929: PUSH
2930: LD_STRING uszkodzone: 
2932: PUSH
2933: LD_EXP 5
2937: PUSH
2938: LD_STRING wylosowane: 4
2940: PUSH
2941: LD_STRING ok
2943: PUSH
2944: LD_VAR 0 8
2948: PUSH
2949: EMPTY
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: LIST
2955: LIST
2956: LIST
2957: ST_TO_ADDR
// if damageVehicle_list > 0 then
2958: LD_VAR 0 9
2962: PUSH
2963: LD_INT 0
2965: GREATER
2966: IFFALSE 3004
// for i in damageVehicle_list do
2968: LD_ADDR_VAR 0 6
2972: PUSH
2973: LD_VAR 0 9
2977: PUSH
2978: FOR_IN
2979: IFFALSE 3002
// ComMoveXY ( i , repX , repY ) ;
2981: LD_VAR 0 6
2985: PPUSH
2986: LD_VAR 0 3
2990: PPUSH
2991: LD_VAR 0 4
2995: PPUSH
2996: CALL_OW 111
3000: GO 2978
3002: POP
3003: POP
// if vehicleNeedRepair_list > 0 then
3004: LD_VAR 0 10
3008: PUSH
3009: LD_INT 0
3011: GREATER
3012: IFFALSE 3099
// begin for i in vehicleNeedRepair_list do
3014: LD_ADDR_VAR 0 6
3018: PUSH
3019: LD_VAR 0 10
3023: PUSH
3024: FOR_IN
3025: IFFALSE 3097
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
3027: LD_ADDR_VAR 0 12
3031: PUSH
3032: LD_VAR 0 12
3036: PUSH
3037: LD_VAR 0 6
3041: PPUSH
3042: CALL_OW 313
3046: ADD
3047: ST_TO_ADDR
// for j in mechanicInside_list do
3048: LD_ADDR_VAR 0 7
3052: PUSH
3053: LD_VAR 0 12
3057: PUSH
3058: FOR_IN
3059: IFFALSE 3093
// begin ComExitVehicle ( j ) ;
3061: LD_VAR 0 7
3065: PPUSH
3066: CALL_OW 121
// wait ( 0 0$1 ) ;
3070: LD_INT 35
3072: PPUSH
3073: CALL_OW 67
// AddComRepairVehicle ( j , i ) ;
3077: LD_VAR 0 7
3081: PPUSH
3082: LD_VAR 0 6
3086: PPUSH
3087: CALL_OW 189
// end ;
3091: GO 3058
3093: POP
3094: POP
// end ;
3095: GO 3024
3097: POP
3098: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3099: LD_VAR 0 11
3103: PUSH
3104: LD_INT 0
3106: GREATER
3107: IFFALSE 3131
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3109: LD_VAR 0 13
3113: PUSH
3114: LD_INT 1
3116: ARRAY
3117: PPUSH
3118: LD_VAR 0 11
3122: PUSH
3123: LD_INT 1
3125: ARRAY
3126: PPUSH
3127: CALL_OW 120
// end ; if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3131: LD_VAR 0 8
3135: PUSH
3136: LD_INT 0
3138: GREATER
3139: PUSH
3140: LD_EXP 5
3144: PUSH
3145: LD_INT 0
3147: GREATER
3148: AND
3149: IFFALSE 3290
// begin for i := 1 to vehicleOK_list do
3151: LD_ADDR_VAR 0 6
3155: PUSH
3156: DOUBLE
3157: LD_INT 1
3159: DEC
3160: ST_TO_ADDR
3161: LD_VAR 0 8
3165: PUSH
3166: FOR_TO
3167: IFFALSE 3288
// begin if i = 4 then
3169: LD_VAR 0 6
3173: PUSH
3174: LD_INT 4
3176: EQUAL
3177: IFFALSE 3286
// begin for i in vehicleOK_list do
3179: LD_ADDR_VAR 0 6
3183: PUSH
3184: LD_VAR 0 8
3188: PUSH
3189: FOR_IN
3190: IFFALSE 3210
// CPU1Tanks = CPU1Tanks ^ i ;
3192: LD_ADDR_EXP 4
3196: PUSH
3197: LD_EXP 4
3201: PUSH
3202: LD_VAR 0 6
3206: ADD
3207: ST_TO_ADDR
3208: GO 3189
3210: POP
3211: POP
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3212: LD_ADDR_EXP 5
3216: PUSH
3217: LD_EXP 5
3221: PPUSH
3222: LD_INT 1
3224: PPUSH
3225: CALL_OW 3
3229: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3230: LD_ADDR_EXP 5
3234: PUSH
3235: LD_EXP 5
3239: PPUSH
3240: LD_INT 1
3242: PPUSH
3243: CALL_OW 3
3247: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3248: LD_ADDR_EXP 5
3252: PUSH
3253: LD_EXP 5
3257: PPUSH
3258: LD_INT 1
3260: PPUSH
3261: CALL_OW 3
3265: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3266: LD_ADDR_EXP 5
3270: PUSH
3271: LD_EXP 5
3275: PPUSH
3276: LD_INT 1
3278: PPUSH
3279: CALL_OW 3
3283: ST_TO_ADDR
// break ;
3284: GO 3288
// end ; end ;
3286: GO 3166
3288: POP
3289: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3290: LD_ADDR_VAR 0 6
3294: PUSH
3295: LD_VAR 0 2
3299: PPUSH
3300: LD_INT 22
3302: PUSH
3303: LD_VAR 0 1
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PUSH
3312: LD_INT 25
3314: PUSH
3315: LD_INT 3
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PPUSH
3326: CALL_OW 70
3330: NOT
3331: PUSH
3332: FOR_IN
3333: IFFALSE 3356
// ComMoveXY ( i , repX , repY ) ;
3335: LD_VAR 0 6
3339: PPUSH
3340: LD_VAR 0 3
3344: PPUSH
3345: LD_VAR 0 4
3349: PPUSH
3350: CALL_OW 111
3354: GO 3332
3356: POP
3357: POP
// end ;
3358: LD_VAR 0 5
3362: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3363: LD_INT 0
3365: PPUSH
3366: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3367: LD_INT 22
3369: PUSH
3370: LD_VAR 0 1
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 25
3381: PUSH
3382: LD_INT 2
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PUSH
3389: EMPTY
3390: LIST
3391: LIST
3392: PPUSH
3393: CALL_OW 69
3397: PUSH
3398: LD_INT 0
3400: GREATER
3401: PUSH
3402: LD_INT 22
3404: PUSH
3405: LD_VAR 0 1
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: PUSH
3414: LD_INT 21
3416: PUSH
3417: LD_INT 3
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: LD_INT 24
3429: PUSH
3430: LD_INT 1000
3432: PUSH
3433: EMPTY
3434: LIST
3435: LIST
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: LIST
3445: PPUSH
3446: CALL_OW 69
3450: PUSH
3451: LD_INT 0
3453: EQUAL
3454: AND
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 0
3463: GREATER
3464: AND
3465: IFFALSE 3564
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3467: LD_ADDR_VAR 0 4
3471: PUSH
3472: LD_INT 22
3474: PUSH
3475: LD_VAR 0 1
3479: PUSH
3480: EMPTY
3481: LIST
3482: LIST
3483: PUSH
3484: LD_INT 25
3486: PUSH
3487: LD_INT 2
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PPUSH
3498: CALL_OW 69
3502: PUSH
3503: FOR_IN
3504: IFFALSE 3562
// begin AddComExitBuilding ( i ) ;
3506: LD_VAR 0 4
3510: PPUSH
3511: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3515: LD_VAR 0 4
3519: PPUSH
3520: LD_VAR 0 2
3524: PUSH
3525: LD_INT 1
3527: ARRAY
3528: PPUSH
3529: LD_VAR 0 2
3533: PUSH
3534: LD_INT 2
3536: ARRAY
3537: PPUSH
3538: LD_VAR 0 2
3542: PUSH
3543: LD_INT 3
3545: ARRAY
3546: PPUSH
3547: LD_VAR 0 2
3551: PUSH
3552: LD_INT 4
3554: ARRAY
3555: PPUSH
3556: CALL_OW 205
// end ;
3560: GO 3503
3562: POP
3563: POP
// end ; end ;
3564: LD_VAR 0 3
3568: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3569: LD_INT 0
3571: PPUSH
3572: PPUSH
3573: PPUSH
3574: PPUSH
3575: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3576: LD_ADDR_VAR 0 6
3580: PUSH
3581: LD_INT 22
3583: PUSH
3584: LD_VAR 0 1
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: PUSH
3593: LD_INT 2
3595: PUSH
3596: LD_INT 30
3598: PUSH
3599: LD_INT 31
3601: PUSH
3602: EMPTY
3603: LIST
3604: LIST
3605: PUSH
3606: LD_INT 30
3608: PUSH
3609: LD_INT 32
3611: PUSH
3612: EMPTY
3613: LIST
3614: LIST
3615: PUSH
3616: LD_INT 30
3618: PUSH
3619: LD_INT 33
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: PUSH
3626: LD_INT 30
3628: PUSH
3629: LD_INT 4
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: PUSH
3636: LD_INT 30
3638: PUSH
3639: LD_INT 5
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: PUSH
3646: EMPTY
3647: LIST
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PPUSH
3658: CALL_OW 69
3662: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3663: LD_ADDR_VAR 0 7
3667: PUSH
3668: LD_INT 22
3670: PUSH
3671: LD_VAR 0 2
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: PUSH
3680: LD_INT 21
3682: PUSH
3683: LD_INT 3
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PUSH
3690: LD_INT 58
3692: PUSH
3693: EMPTY
3694: LIST
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: LIST
3700: PPUSH
3701: CALL_OW 69
3705: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 0
3713: GREATER
3714: PUSH
3715: LD_VAR 0 7
3719: PUSH
3720: LD_INT 0
3722: GREATER
3723: AND
3724: IFFALSE 3794
// begin for i in turretsList do
3726: LD_ADDR_VAR 0 4
3730: PUSH
3731: LD_VAR 0 6
3735: PUSH
3736: FOR_IN
3737: IFFALSE 3792
// begin for j in enemyBuildings do
3739: LD_ADDR_VAR 0 5
3743: PUSH
3744: LD_VAR 0 7
3748: PUSH
3749: FOR_IN
3750: IFFALSE 3788
// begin if GetDistUnits ( i , j ) < 20 then
3752: LD_VAR 0 4
3756: PPUSH
3757: LD_VAR 0 5
3761: PPUSH
3762: CALL_OW 296
3766: PUSH
3767: LD_INT 20
3769: LESS
3770: IFFALSE 3786
// begin ComAttackUnit ( i , j ) ;
3772: LD_VAR 0 4
3776: PPUSH
3777: LD_VAR 0 5
3781: PPUSH
3782: CALL_OW 115
// end ; end ;
3786: GO 3749
3788: POP
3789: POP
// end ;
3790: GO 3736
3792: POP
3793: POP
// end ; end ;
3794: LD_VAR 0 3
3798: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3799: LD_INT 0
3801: PPUSH
3802: PPUSH
3803: PPUSH
3804: PPUSH
3805: PPUSH
3806: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3807: LD_ADDR_VAR 0 7
3811: PUSH
3812: LD_INT 22
3814: PUSH
3815: LD_VAR 0 1
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 25
3826: PUSH
3827: LD_INT 9
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PPUSH
3838: CALL_OW 69
3842: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3843: LD_ADDR_VAR 0 8
3847: PUSH
3848: LD_INT 22
3850: PUSH
3851: LD_VAR 0 2
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 3
3862: PUSH
3863: LD_INT 21
3865: PUSH
3866: LD_INT 3
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: PPUSH
3881: CALL_OW 69
3885: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3886: LD_ADDR_VAR 0 5
3890: PUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 3
3896: PPUSH
3897: CALL_OW 12
3901: ST_TO_ADDR
// for i = 1 to list do
3902: LD_ADDR_VAR 0 6
3906: PUSH
3907: DOUBLE
3908: LD_INT 1
3910: DEC
3911: ST_TO_ADDR
3912: LD_VAR 0 7
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4100
// for ta in filter do
3920: LD_ADDR_VAR 0 4
3924: PUSH
3925: LD_VAR 0 8
3929: PUSH
3930: FOR_IN
3931: IFFALSE 4096
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3933: LD_VAR 0 7
3937: PUSH
3938: LD_VAR 0 6
3942: ARRAY
3943: PPUSH
3944: LD_VAR 0 4
3948: PPUSH
3949: CALL_OW 296
3953: PUSH
3954: LD_INT 13
3956: LESSEQUAL
3957: IFFALSE 4094
// begin case c of 1 :
3959: LD_VAR 0 5
3963: PUSH
3964: LD_INT 1
3966: DOUBLE
3967: EQUAL
3968: IFTRUE 3972
3970: GO 4010
3972: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3973: LD_VAR 0 7
3977: PUSH
3978: LD_VAR 0 6
3982: ARRAY
3983: PPUSH
3984: LD_VAR 0 4
3988: PPUSH
3989: CALL_OW 250
3993: PPUSH
3994: LD_VAR 0 4
3998: PPUSH
3999: CALL_OW 251
4003: PPUSH
4004: CALL_OW 154
4008: GO 4094
4010: LD_INT 2
4012: DOUBLE
4013: EQUAL
4014: IFTRUE 4018
4016: GO 4082
4018: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4019: LD_VAR 0 7
4023: PUSH
4024: LD_VAR 0 6
4028: ARRAY
4029: PPUSH
4030: LD_VAR 0 4
4034: PPUSH
4035: CALL_OW 250
4039: PUSH
4040: LD_INT 1
4042: NEG
4043: PPUSH
4044: LD_INT 1
4046: PPUSH
4047: CALL_OW 12
4051: PLUS
4052: PPUSH
4053: LD_VAR 0 4
4057: PPUSH
4058: CALL_OW 251
4062: PUSH
4063: LD_INT 1
4065: NEG
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: CALL_OW 12
4074: PLUS
4075: PPUSH
4076: CALL_OW 153
4080: GO 4094
4082: LD_INT 3
4084: DOUBLE
4085: EQUAL
4086: IFTRUE 4090
4088: GO 4093
4090: POP
// ; end ;
4091: GO 4094
4093: POP
// end ; end ;
4094: GO 3930
4096: POP
4097: POP
4098: GO 3917
4100: POP
4101: POP
// end ; end_of_file
4102: LD_VAR 0 3
4106: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4107: LD_INT 0
4109: PPUSH
4110: PPUSH
// if exist_mode then
4111: LD_VAR 0 2
4115: IFFALSE 4134
// unit := CreateCharacter ( ident ) else
4117: LD_ADDR_VAR 0 4
4121: PUSH
4122: LD_VAR 0 1
4126: PPUSH
4127: CALL_OW 34
4131: ST_TO_ADDR
4132: GO 4149
// unit := NewCharacter ( ident ) ;
4134: LD_ADDR_VAR 0 4
4138: PUSH
4139: LD_VAR 0 1
4143: PPUSH
4144: CALL_OW 25
4148: ST_TO_ADDR
// result := unit ;
4149: LD_ADDR_VAR 0 3
4153: PUSH
4154: LD_VAR 0 4
4158: ST_TO_ADDR
// end ;
4159: LD_VAR 0 3
4163: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4164: LD_INT 0
4166: PPUSH
4167: PPUSH
4168: PPUSH
// uc_side := GetSide ( b ) ;
4169: LD_ADDR_OWVAR 20
4173: PUSH
4174: LD_VAR 0 2
4178: PPUSH
4179: CALL_OW 255
4183: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4184: LD_ADDR_OWVAR 21
4188: PUSH
4189: LD_VAR 0 2
4193: PPUSH
4194: CALL_OW 248
4198: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_VAR 0 1
4209: PPUSH
4210: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4214: LD_ADDR_VAR 0 5
4218: PUSH
4219: LD_VAR 0 2
4223: PPUSH
4224: CALL_OW 254
4228: PUSH
4229: LD_INT 3
4231: MINUS
4232: ST_TO_ADDR
// if dir < 0 then
4233: LD_VAR 0 5
4237: PUSH
4238: LD_INT 0
4240: LESS
4241: IFFALSE 4257
// dir := 6 + dir ;
4243: LD_ADDR_VAR 0 5
4247: PUSH
4248: LD_INT 6
4250: PUSH
4251: LD_VAR 0 5
4255: PLUS
4256: ST_TO_ADDR
// un := CreateHuman ;
4257: LD_ADDR_VAR 0 4
4261: PUSH
4262: CALL_OW 44
4266: ST_TO_ADDR
// SetDir ( un , dir ) ;
4267: LD_VAR 0 4
4271: PPUSH
4272: LD_VAR 0 5
4276: PPUSH
4277: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4281: LD_VAR 0 4
4285: PPUSH
4286: LD_VAR 0 2
4290: PPUSH
4291: CALL_OW 52
// end ;
4295: LD_VAR 0 3
4299: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
4300: LD_INT 0
4302: PPUSH
4303: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
4304: LD_ADDR_VAR 0 2
4308: PUSH
4309: LD_VAR 0 1
4313: PPUSH
4314: LD_INT 1
4316: PPUSH
4317: CALL_OW 289
4321: PUSH
4322: LD_VAR 0 1
4326: PPUSH
4327: LD_INT 2
4329: PPUSH
4330: CALL_OW 289
4334: PUSH
4335: LD_VAR 0 1
4339: PPUSH
4340: LD_INT 3
4342: PPUSH
4343: CALL_OW 289
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: ST_TO_ADDR
// end ; end_of_file
4353: LD_VAR 0 2
4357: RET
// on UnitDestroyed ( un ) do var i ;
4358: LD_INT 0
4360: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
4361: LD_VAR 0 1
4365: PPUSH
4366: CALL_OW 255
4370: PUSH
4371: LD_INT 3
4373: EQUAL
4374: PUSH
4375: LD_VAR 0 1
4379: PPUSH
4380: CALL_OW 247
4384: PUSH
4385: LD_INT 3
4387: EQUAL
4388: AND
4389: IFFALSE 5081
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
4391: LD_VAR 0 1
4395: PPUSH
4396: CALL_OW 266
4400: PUSH
4401: LD_INT 31
4403: EQUAL
4404: PUSH
4405: LD_VAR 0 1
4409: PPUSH
4410: CALL_OW 266
4414: PUSH
4415: LD_INT 32
4417: EQUAL
4418: OR
4419: PUSH
4420: LD_VAR 0 1
4424: PPUSH
4425: CALL_OW 266
4429: PUSH
4430: LD_INT 36
4432: EQUAL
4433: OR
4434: PUSH
4435: LD_VAR 0 1
4439: PPUSH
4440: CALL_OW 266
4444: PUSH
4445: LD_INT 0
4447: EQUAL
4448: OR
4449: PUSH
4450: LD_VAR 0 1
4454: PPUSH
4455: CALL_OW 266
4459: PUSH
4460: LD_INT 24
4462: EQUAL
4463: OR
4464: PUSH
4465: LD_VAR 0 1
4469: PPUSH
4470: CALL_OW 266
4474: PUSH
4475: LD_INT 17
4477: EQUAL
4478: OR
4479: PUSH
4480: LD_VAR 0 1
4484: PPUSH
4485: CALL_OW 266
4489: PUSH
4490: LD_INT 25
4492: EQUAL
4493: OR
4494: PUSH
4495: LD_VAR 0 1
4499: PPUSH
4500: CALL_OW 266
4504: PUSH
4505: LD_INT 19
4507: EQUAL
4508: OR
4509: PUSH
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 266
4519: PUSH
4520: LD_INT 20
4522: EQUAL
4523: OR
4524: PUSH
4525: LD_VAR 0 1
4529: PPUSH
4530: CALL_OW 266
4534: PUSH
4535: LD_INT 18
4537: EQUAL
4538: OR
4539: PUSH
4540: LD_VAR 0 1
4544: PPUSH
4545: CALL_OW 266
4549: PUSH
4550: LD_INT 21
4552: EQUAL
4553: OR
4554: PUSH
4555: LD_VAR 0 1
4559: PPUSH
4560: CALL_OW 266
4564: PUSH
4565: LD_INT 23
4567: EQUAL
4568: OR
4569: PUSH
4570: LD_VAR 0 1
4574: PPUSH
4575: CALL_OW 266
4579: PUSH
4580: LD_INT 16
4582: EQUAL
4583: OR
4584: PUSH
4585: LD_VAR 0 1
4589: PPUSH
4590: CALL_OW 266
4594: PUSH
4595: LD_INT 6
4597: EQUAL
4598: OR
4599: PUSH
4600: LD_VAR 0 1
4604: PPUSH
4605: CALL_OW 266
4609: PUSH
4610: LD_INT 29
4612: EQUAL
4613: OR
4614: PUSH
4615: LD_VAR 0 1
4619: PPUSH
4620: CALL_OW 266
4624: PUSH
4625: LD_INT 26
4627: EQUAL
4628: OR
4629: PUSH
4630: LD_VAR 0 1
4634: PPUSH
4635: CALL_OW 266
4639: PUSH
4640: LD_INT 30
4642: EQUAL
4643: OR
4644: PUSH
4645: LD_VAR 0 1
4649: PPUSH
4650: CALL_OW 266
4654: PUSH
4655: LD_INT 28
4657: EQUAL
4658: OR
4659: PUSH
4660: LD_VAR 0 1
4664: PPUSH
4665: CALL_OW 266
4669: PUSH
4670: LD_INT 27
4672: EQUAL
4673: OR
4674: PUSH
4675: LD_VAR 0 1
4679: PPUSH
4680: CALL_OW 266
4684: PUSH
4685: LD_INT 33
4687: EQUAL
4688: OR
4689: PUSH
4690: LD_VAR 0 1
4694: PPUSH
4695: CALL_OW 266
4699: PUSH
4700: LD_INT 2
4702: EQUAL
4703: OR
4704: PUSH
4705: LD_VAR 0 1
4709: PPUSH
4710: CALL_OW 266
4714: PUSH
4715: LD_INT 4
4717: EQUAL
4718: OR
4719: IFFALSE 4805
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
4721: LD_ADDR_EXP 1
4725: PUSH
4726: LD_EXP 1
4730: PUSH
4731: LD_VAR 0 1
4735: PPUSH
4736: CALL_OW 266
4740: ADD
4741: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4742: LD_ADDR_EXP 1
4746: PUSH
4747: LD_EXP 1
4751: PUSH
4752: LD_VAR 0 1
4756: PPUSH
4757: CALL_OW 250
4761: ADD
4762: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4763: LD_ADDR_EXP 1
4767: PUSH
4768: LD_EXP 1
4772: PUSH
4773: LD_VAR 0 1
4777: PPUSH
4778: CALL_OW 251
4782: ADD
4783: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4784: LD_ADDR_EXP 1
4788: PUSH
4789: LD_EXP 1
4793: PUSH
4794: LD_VAR 0 1
4798: PPUSH
4799: CALL_OW 254
4803: ADD
4804: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
4805: LD_VAR 0 1
4809: PPUSH
4810: CALL_OW 266
4814: PUSH
4815: LD_INT 1
4817: EQUAL
4818: IFFALSE 4897
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
4820: LD_ADDR_EXP 1
4824: PUSH
4825: LD_EXP 1
4829: PUSH
4830: LD_INT 0
4832: ADD
4833: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4834: LD_ADDR_EXP 1
4838: PUSH
4839: LD_EXP 1
4843: PUSH
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 250
4853: ADD
4854: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4855: LD_ADDR_EXP 1
4859: PUSH
4860: LD_EXP 1
4864: PUSH
4865: LD_VAR 0 1
4869: PPUSH
4870: CALL_OW 251
4874: ADD
4875: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4876: LD_ADDR_EXP 1
4880: PUSH
4881: LD_EXP 1
4885: PUSH
4886: LD_VAR 0 1
4890: PPUSH
4891: CALL_OW 254
4895: ADD
4896: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4897: LD_VAR 0 1
4901: PPUSH
4902: CALL_OW 266
4906: PUSH
4907: LD_INT 3
4909: EQUAL
4910: IFFALSE 4989
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4912: LD_ADDR_EXP 1
4916: PUSH
4917: LD_EXP 1
4921: PUSH
4922: LD_INT 2
4924: ADD
4925: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4926: LD_ADDR_EXP 1
4930: PUSH
4931: LD_EXP 1
4935: PUSH
4936: LD_VAR 0 1
4940: PPUSH
4941: CALL_OW 250
4945: ADD
4946: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4947: LD_ADDR_EXP 1
4951: PUSH
4952: LD_EXP 1
4956: PUSH
4957: LD_VAR 0 1
4961: PPUSH
4962: CALL_OW 251
4966: ADD
4967: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4968: LD_ADDR_EXP 1
4972: PUSH
4973: LD_EXP 1
4977: PUSH
4978: LD_VAR 0 1
4982: PPUSH
4983: CALL_OW 254
4987: ADD
4988: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4989: LD_VAR 0 1
4993: PPUSH
4994: CALL_OW 266
4998: PUSH
4999: LD_INT 5
5001: EQUAL
5002: IFFALSE 5081
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
5004: LD_ADDR_EXP 1
5008: PUSH
5009: LD_EXP 1
5013: PUSH
5014: LD_INT 4
5016: ADD
5017: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
5018: LD_ADDR_EXP 1
5022: PUSH
5023: LD_EXP 1
5027: PUSH
5028: LD_VAR 0 1
5032: PPUSH
5033: CALL_OW 250
5037: ADD
5038: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
5039: LD_ADDR_EXP 1
5043: PUSH
5044: LD_EXP 1
5048: PUSH
5049: LD_VAR 0 1
5053: PPUSH
5054: CALL_OW 251
5058: ADD
5059: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
5060: LD_ADDR_EXP 1
5064: PUSH
5065: LD_EXP 1
5069: PUSH
5070: LD_VAR 0 1
5074: PPUSH
5075: CALL_OW 254
5079: ADD
5080: ST_TO_ADDR
// end ; end ; if GetSide ( un ) = 3 and GetType ( un ) = unit_vehicle then
5081: LD_VAR 0 1
5085: PPUSH
5086: CALL_OW 255
5090: PUSH
5091: LD_INT 3
5093: EQUAL
5094: PUSH
5095: LD_VAR 0 1
5099: PPUSH
5100: CALL_OW 247
5104: PUSH
5105: LD_INT 2
5107: EQUAL
5108: AND
5109: IFFALSE 5213
// begin for i in CPU1DamageTanks do
5111: LD_ADDR_VAR 0 2
5115: PUSH
5116: LD_EXP 5
5120: PUSH
5121: FOR_IN
5122: IFFALSE 5211
// begin if i = un then
5124: LD_VAR 0 2
5128: PUSH
5129: LD_VAR 0 1
5133: EQUAL
5134: IFFALSE 5209
// begin AddComConstruct ( rufab , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
5136: LD_INT 30
5138: PPUSH
5139: LD_VAR 0 1
5143: PPUSH
5144: CALL_OW 265
5148: PPUSH
5149: LD_VAR 0 1
5153: PPUSH
5154: CALL_OW 262
5158: PPUSH
5159: LD_VAR 0 1
5163: PPUSH
5164: CALL_OW 263
5168: PPUSH
5169: LD_VAR 0 1
5173: PPUSH
5174: CALL_OW 264
5178: PPUSH
5179: CALL_OW 185
// CPU1DamageTanks = Delete ( CPU1DamageTanks , i [ i ] ) ;
5183: LD_ADDR_EXP 5
5187: PUSH
5188: LD_EXP 5
5192: PPUSH
5193: LD_VAR 0 2
5197: PUSH
5198: LD_VAR 0 2
5202: ARRAY
5203: PPUSH
5204: CALL_OW 3
5208: ST_TO_ADDR
// end ; end ;
5209: GO 5121
5211: POP
5212: POP
// end ; end ;
5213: PPOPN 2
5215: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
5216: LD_VAR 0 1
5220: PPUSH
5221: CALL_OW 255
5225: PUSH
5226: LD_INT 3
5228: EQUAL
5229: IFFALSE 5303
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5231: LD_ADDR_EXP 1
5235: PUSH
5236: LD_EXP 1
5240: PPUSH
5241: LD_INT 1
5243: PPUSH
5244: CALL_OW 3
5248: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5249: LD_ADDR_EXP 1
5253: PUSH
5254: LD_EXP 1
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 3
5266: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5267: LD_ADDR_EXP 1
5271: PUSH
5272: LD_EXP 1
5276: PPUSH
5277: LD_INT 1
5279: PPUSH
5280: CALL_OW 3
5284: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5285: LD_ADDR_EXP 1
5289: PUSH
5290: LD_EXP 1
5294: PPUSH
5295: LD_INT 1
5297: PPUSH
5298: CALL_OW 3
5302: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
5303: LD_VAR 0 1
5307: PPUSH
5308: CALL_OW 255
5312: PUSH
5313: LD_INT 3
5315: EQUAL
5316: PUSH
5317: LD_VAR 0 1
5321: PPUSH
5322: CALL_OW 266
5326: PUSH
5327: LD_INT 0
5329: EQUAL
5330: PUSH
5331: LD_VAR 0 1
5335: PPUSH
5336: CALL_OW 266
5340: PUSH
5341: LD_INT 2
5343: EQUAL
5344: OR
5345: PUSH
5346: LD_VAR 0 1
5350: PPUSH
5351: CALL_OW 266
5355: PUSH
5356: LD_INT 4
5358: EQUAL
5359: OR
5360: PUSH
5361: EMPTY
5362: LIST
5363: AND
5364: IFFALSE 5375
// ComUpgrade ( building ) ;
5366: LD_VAR 0 1
5370: PPUSH
5371: CALL_OW 146
// end ;
5375: PPOPN 1
5377: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
5378: LD_VAR 0 1
5382: PPUSH
5383: CALL_OW 255
5387: PUSH
5388: LD_INT 3
5390: EQUAL
5391: IFFALSE 5409
// CPU1Tanks = CPU1Tanks ^ vehicle ;
5393: LD_ADDR_EXP 4
5397: PUSH
5398: LD_EXP 4
5402: PUSH
5403: LD_VAR 0 1
5407: ADD
5408: ST_TO_ADDR
// end ;
5409: PPOPN 2
5411: END
// on Command ( command_id ) do begin display_strings = command_id ;
5412: LD_ADDR_OWVAR 47
5416: PUSH
5417: LD_VAR 0 1
5421: ST_TO_ADDR
// end ;
5422: PPOPN 1
5424: END
