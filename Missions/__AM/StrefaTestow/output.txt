// export destroyedBuildings ; export cargoTest ; export vehicleDriverTab ; export arabianMines ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// destroyedBuildings = [ ] ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// cargoTest = [ ] ;
  15: LD_ADDR_EXP 2
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// arabianMines = [ ] ;
  22: LD_ADDR_EXP 4
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// end ;
  29: END
// every 0 0$01 do var un , un2 ;
  30: GO 32
  32: DISABLE
  33: LD_INT 0
  35: PPUSH
  36: PPUSH
// begin uc_side := 0 ;
  37: LD_ADDR_OWVAR 20
  41: PUSH
  42: LD_INT 0
  44: ST_TO_ADDR
// uc_nation := 0 ;
  45: LD_ADDR_OWVAR 21
  49: PUSH
  50: LD_INT 0
  52: ST_TO_ADDR
// hc_class := 1 ;
  53: LD_ADDR_OWVAR 28
  57: PUSH
  58: LD_INT 1
  60: ST_TO_ADDR
// hc_gallery :=  ;
  61: LD_ADDR_OWVAR 33
  65: PUSH
  66: LD_STRING 
  68: ST_TO_ADDR
// un := CreateHuman ;
  69: LD_ADDR_VAR 0 1
  73: PUSH
  74: CALL_OW 44
  78: ST_TO_ADDR
// un2 := CreateHuman ;
  79: LD_ADDR_VAR 0 2
  83: PUSH
  84: CALL_OW 44
  88: ST_TO_ADDR
// PlaceUnitXY ( un , 192 , 25 , false ) ;
  89: LD_VAR 0 1
  93: PPUSH
  94: LD_INT 192
  96: PPUSH
  97: LD_INT 25
  99: PPUSH
 100: LD_INT 0
 102: PPUSH
 103: CALL_OW 48
// PlaceUnitXY ( un2 , 190 , 25 , false ) ;
 107: LD_VAR 0 2
 111: PPUSH
 112: LD_INT 190
 114: PPUSH
 115: LD_INT 25
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: CALL_OW 48
// SetTag ( un , 0 ) ;
 125: LD_VAR 0 1
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: CALL_OW 109
// display_strings := [ not GetTag ( un ) , not GetTag ( un2 ) ] ;
 137: LD_ADDR_OWVAR 47
 141: PUSH
 142: LD_VAR 0 1
 146: PPUSH
 147: CALL_OW 110
 151: NOT
 152: PUSH
 153: LD_VAR 0 2
 157: PPUSH
 158: CALL_OW 110
 162: NOT
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: ST_TO_ADDR
// end ;
 168: PPOPN 2
 170: END
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
 171: LD_INT 0
 173: PPUSH
 174: PPUSH
 175: PPUSH
 176: PPUSH
// for i = 1 to 3 do
 177: LD_ADDR_VAR 0 5
 181: PUSH
 182: DOUBLE
 183: LD_INT 1
 185: DEC
 186: ST_TO_ADDR
 187: LD_INT 3
 189: PUSH
 190: FOR_TO
 191: IFFALSE 221
// amount := amount + GetResourceArea ( area , i ) ;
 193: LD_ADDR_VAR 0 4
 197: PUSH
 198: LD_VAR 0 4
 202: PUSH
 203: LD_VAR 0 1
 207: PPUSH
 208: LD_VAR 0 5
 212: PPUSH
 213: CALL_OW 287
 217: PLUS
 218: ST_TO_ADDR
 219: GO 190
 221: POP
 222: POP
// if amount < materials then
 223: LD_VAR 0 4
 227: PUSH
 228: LD_VAR 0 2
 232: LESS
 233: IFFALSE 237
// exit ;
 235: GO 271
// for i = 1 to 3 do
 237: LD_ADDR_VAR 0 5
 241: PUSH
 242: DOUBLE
 243: LD_INT 1
 245: DEC
 246: ST_TO_ADDR
 247: LD_INT 3
 249: PUSH
 250: FOR_TO
 251: IFFALSE 269
// EraseResourceArea ( area , i ) ;
 253: LD_VAR 0 1
 257: PPUSH
 258: LD_VAR 0 5
 262: PPUSH
 263: CALL_OW 286
 267: GO 250
 269: POP
 270: POP
// end ; end_of_file
 271: LD_VAR 0 3
 275: RET
// every 0 0$1 do
 276: GO 278
 278: DISABLE
// begin enable ;
 279: ENABLE
// RepairVehicles ( 3 , EnemyVehSpawn , 89 , 7 ) ;
 280: LD_INT 3
 282: PPUSH
 283: LD_INT 2
 285: PPUSH
 286: LD_INT 89
 288: PPUSH
 289: LD_INT 7
 291: PPUSH
 292: CALL 2566 0 4
// AttackVehicles ( 3 , EnemyVehSpawn , [ 213 , 115 , 96 ] , [ 13 , 14 , 8 ] ) ;
 296: LD_INT 3
 298: PPUSH
 299: LD_INT 2
 301: PPUSH
 302: LD_INT 213
 304: PUSH
 305: LD_INT 115
 307: PUSH
 308: LD_INT 96
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: PPUSH
 316: LD_INT 13
 318: PUSH
 319: LD_INT 14
 321: PUSH
 322: LD_INT 8
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: LIST
 329: PPUSH
 330: CALL 2769 0 4
// end ;
 334: END
// every 5 5$1 do
 335: GO 337
 337: DISABLE
// begin BuildingVehicle ( 3 , rufab , 4 , [ 42 ] , 1 , 1 , 23 ) ;
 338: LD_INT 3
 340: PPUSH
 341: LD_INT 30
 343: PPUSH
 344: LD_INT 4
 346: PPUSH
 347: LD_INT 42
 349: PUSH
 350: EMPTY
 351: LIST
 352: PPUSH
 353: LD_INT 1
 355: PPUSH
 356: LD_INT 1
 358: PPUSH
 359: LD_INT 23
 361: PPUSH
 362: CALL 2454 0 7
// end ;
 366: END
// every 0 0$1 do
 367: GO 369
 369: DISABLE
// begin RespawnAttackVehicle ( EnemyVehSpawn , 3 , 5 , 10 , nation_russian , engine_siberite , control_manual , [ 44 , 46 ] , [ ] , [ ] ) ;
 370: LD_INT 2
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: LD_INT 5
 378: PPUSH
 379: LD_INT 10
 381: PPUSH
 382: LD_INT 3
 384: PPUSH
 385: LD_INT 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 44
 393: PUSH
 394: LD_INT 46
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: PPUSH
 401: EMPTY
 402: PPUSH
 403: EMPTY
 404: PPUSH
 405: CALL 948 0 10
// end ;
 409: END
// every 0 0$01 trigger arabianMines do var i , p ;
 410: LD_EXP 4
 414: IFFALSE 617
 416: GO 418
 418: DISABLE
 419: LD_INT 0
 421: PPUSH
 422: PPUSH
// begin enable ;
 423: ENABLE
// p := 1 ;
 424: LD_ADDR_VAR 0 2
 428: PUSH
 429: LD_INT 1
 431: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 432: LD_ADDR_VAR 0 1
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 4
 446: PUSH
 447: LD_INT 2
 449: DIVREAL
 450: PUSH
 451: FOR_TO
 452: IFFALSE 615
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 454: LD_INT 81
 456: PUSH
 457: LD_INT 2
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: PUSH
 464: LD_INT 92
 466: PUSH
 467: LD_EXP 4
 471: PUSH
 472: LD_VAR 0 2
 476: ARRAY
 477: PUSH
 478: LD_EXP 4
 482: PUSH
 483: LD_VAR 0 2
 487: PUSH
 488: LD_INT 1
 490: PLUS
 491: ARRAY
 492: PUSH
 493: LD_INT 2
 495: PUSH
 496: EMPTY
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PPUSH
 506: CALL_OW 69
 510: IFFALSE 599
// begin LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 512: LD_EXP 4
 516: PUSH
 517: LD_VAR 0 2
 521: ARRAY
 522: PPUSH
 523: LD_EXP 4
 527: PUSH
 528: LD_VAR 0 2
 532: PUSH
 533: LD_INT 1
 535: PLUS
 536: ARRAY
 537: PPUSH
 538: LD_INT 2
 540: PPUSH
 541: CALL_OW 456
// arabianMines := Delete ( arabianMines , p ) ;
 545: LD_ADDR_EXP 4
 549: PUSH
 550: LD_EXP 4
 554: PPUSH
 555: LD_VAR 0 2
 559: PPUSH
 560: CALL_OW 3
 564: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 565: LD_ADDR_EXP 4
 569: PUSH
 570: LD_EXP 4
 574: PPUSH
 575: LD_VAR 0 2
 579: PPUSH
 580: CALL_OW 3
 584: ST_TO_ADDR
// p := p - 2 ;
 585: LD_ADDR_VAR 0 2
 589: PUSH
 590: LD_VAR 0 2
 594: PUSH
 595: LD_INT 2
 597: MINUS
 598: ST_TO_ADDR
// end ; p := p + 2 ;
 599: LD_ADDR_VAR 0 2
 603: PUSH
 604: LD_VAR 0 2
 608: PUSH
 609: LD_INT 2
 611: PLUS
 612: ST_TO_ADDR
// end ;
 613: GO 451
 615: POP
 616: POP
// end ; end_of_file
 617: PPOPN 2
 619: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 620: LD_INT 0
 622: PPUSH
 623: PPUSH
 624: PPUSH
// rnd = rand ( 1 , characters ) ;
 625: LD_ADDR_VAR 0 6
 629: PUSH
 630: LD_INT 1
 632: PPUSH
 633: LD_VAR 0 1
 637: PPUSH
 638: CALL_OW 12
 642: ST_TO_ADDR
// for i = 1 to characters do
 643: LD_ADDR_VAR 0 5
 647: PUSH
 648: DOUBLE
 649: LD_INT 1
 651: DEC
 652: ST_TO_ADDR
 653: LD_VAR 0 1
 657: PUSH
 658: FOR_TO
 659: IFFALSE 769
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 661: LD_VAR 0 5
 665: PUSH
 666: LD_VAR 0 6
 670: EQUAL
 671: PUSH
 672: LD_VAR 0 1
 676: PUSH
 677: LD_VAR 0 5
 681: ARRAY
 682: PPUSH
 683: CALL_OW 258
 687: PUSH
 688: LD_INT 1
 690: EQUAL
 691: AND
 692: IFFALSE 714
// Say ( characters [ i ] , dialogMID ) ;
 694: LD_VAR 0 1
 698: PUSH
 699: LD_VAR 0 5
 703: ARRAY
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 714: LD_VAR 0 5
 718: PUSH
 719: LD_VAR 0 6
 723: EQUAL
 724: PUSH
 725: LD_VAR 0 1
 729: PUSH
 730: LD_VAR 0 5
 734: ARRAY
 735: PPUSH
 736: CALL_OW 258
 740: PUSH
 741: LD_INT 2
 743: EQUAL
 744: AND
 745: IFFALSE 767
// Say ( characters [ i ] , dialogFID ) ;
 747: LD_VAR 0 1
 751: PUSH
 752: LD_VAR 0 5
 756: ARRAY
 757: PPUSH
 758: LD_VAR 0 3
 762: PPUSH
 763: CALL_OW 88
// end ;
 767: GO 658
 769: POP
 770: POP
// end ;
 771: LD_VAR 0 4
 775: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 776: LD_INT 0
 778: PPUSH
 779: PPUSH
 780: PPUSH
 781: PPUSH
// for i = 1 to count do
 782: LD_ADDR_VAR 0 8
 786: PUSH
 787: DOUBLE
 788: LD_INT 1
 790: DEC
 791: ST_TO_ADDR
 792: LD_VAR 0 6
 796: PUSH
 797: FOR_TO
 798: IFFALSE 879
// begin uc_side = side ;
 800: LD_ADDR_OWVAR 20
 804: PUSH
 805: LD_VAR 0 1
 809: ST_TO_ADDR
// uc_nation = nation ;
 810: LD_ADDR_OWVAR 21
 814: PUSH
 815: LD_VAR 0 2
 819: ST_TO_ADDR
// hc_gallery =  ;
 820: LD_ADDR_OWVAR 33
 824: PUSH
 825: LD_STRING 
 827: ST_TO_ADDR
// hc_name =  ;
 828: LD_ADDR_OWVAR 26
 832: PUSH
 833: LD_STRING 
 835: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 836: LD_INT 0
 838: PPUSH
 839: LD_VAR 0 5
 843: PPUSH
 844: LD_VAR 0 4
 848: PPUSH
 849: CALL_OW 380
// un = CreateHuman ;
 853: LD_ADDR_VAR 0 10
 857: PUSH
 858: CALL_OW 44
 862: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 863: LD_VAR 0 10
 867: PPUSH
 868: LD_VAR 0 3
 872: PPUSH
 873: CALL_OW 52
// end ;
 877: GO 797
 879: POP
 880: POP
// end ;
 881: LD_VAR 0 7
 885: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 886: LD_INT 0
 888: PPUSH
 889: PPUSH
// for i in charactersList do
 890: LD_ADDR_VAR 0 4
 894: PUSH
 895: LD_VAR 0 1
 899: PUSH
 900: FOR_IN
 901: IFFALSE 941
// begin if IsOk ( i ) then
 903: LD_VAR 0 4
 907: PPUSH
 908: CALL_OW 302
 912: IFFALSE 930
// begin SaveCharacters ( i , ident ) ;
 914: LD_VAR 0 4
 918: PPUSH
 919: LD_VAR 0 2
 923: PPUSH
 924: CALL_OW 38
// end else
 928: GO 939
// begin DeleteCharacters ( ident ) ;
 930: LD_VAR 0 2
 934: PPUSH
 935: CALL_OW 40
// end ; end ;
 939: GO 900
 941: POP
 942: POP
// end ;
 943: LD_VAR 0 3
 947: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 948: LD_INT 0
 950: PPUSH
 951: PPUSH
 952: PPUSH
 953: PPUSH
 954: PPUSH
 955: PPUSH
 956: PPUSH
 957: PPUSH
 958: PPUSH
 959: PPUSH
 960: PPUSH
// amChassisTab = [ ] ;
 961: LD_ADDR_VAR 0 18
 965: PUSH
 966: EMPTY
 967: ST_TO_ADDR
// arChassisTab = [ ] ;
 968: LD_ADDR_VAR 0 17
 972: PUSH
 973: EMPTY
 974: ST_TO_ADDR
// ruChassisTab = [ ] ;
 975: LD_ADDR_VAR 0 16
 979: PUSH
 980: EMPTY
 981: ST_TO_ADDR
// if nation = 1 then
 982: LD_VAR 0 5
 986: PUSH
 987: LD_INT 1
 989: EQUAL
 990: IFFALSE 1407
// begin for i := 1 to vehCount do
 992: LD_ADDR_VAR 0 12
 996: PUSH
 997: DOUBLE
 998: LD_INT 1
1000: DEC
1001: ST_TO_ADDR
1002: LD_VAR 0 3
1006: PUSH
1007: FOR_TO
1008: IFFALSE 1405
// begin uc_side = side ;
1010: LD_ADDR_OWVAR 20
1014: PUSH
1015: LD_VAR 0 2
1019: ST_TO_ADDR
// uc_nation = nation ;
1020: LD_ADDR_OWVAR 21
1024: PUSH
1025: LD_VAR 0 5
1029: ST_TO_ADDR
// vc_engine = vehengine ;
1030: LD_ADDR_OWVAR 39
1034: PUSH
1035: LD_VAR 0 6
1039: ST_TO_ADDR
// vc_control = vehcontrol ;
1040: LD_ADDR_OWVAR 38
1044: PUSH
1045: LD_VAR 0 7
1049: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
1050: LD_ADDR_OWVAR 40
1054: PUSH
1055: LD_VAR 0 10
1059: PUSH
1060: LD_INT 1
1062: PPUSH
1063: LD_VAR 0 10
1067: PPUSH
1068: CALL_OW 12
1072: ARRAY
1073: ST_TO_ADDR
// if vc_weapon = 2 or vc_weapon = 3 then
1074: LD_OWVAR 40
1078: PUSH
1079: LD_INT 2
1081: EQUAL
1082: PUSH
1083: LD_OWVAR 40
1087: PUSH
1088: LD_INT 3
1090: EQUAL
1091: OR
1092: IFFALSE 1145
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
1094: LD_ADDR_VAR 0 18
1098: PUSH
1099: LD_INT 1
1101: PUSH
1102: LD_INT 2
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: LD_INT 4
1110: PUSH
1111: LD_INT 5
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1121: LD_ADDR_OWVAR 37
1125: PUSH
1126: LD_VAR 0 18
1130: PUSH
1131: LD_INT 1
1133: PPUSH
1134: LD_VAR 0 18
1138: PPUSH
1139: CALL_OW 12
1143: ARRAY
1144: ST_TO_ADDR
// end ; if vc_weapon = 4 or vc_weapon = 5 or vc_weapon = 9 or vc_weapon = 11 or vc_weapon = 7 then
1145: LD_OWVAR 40
1149: PUSH
1150: LD_INT 4
1152: EQUAL
1153: PUSH
1154: LD_OWVAR 40
1158: PUSH
1159: LD_INT 5
1161: EQUAL
1162: OR
1163: PUSH
1164: LD_OWVAR 40
1168: PUSH
1169: LD_INT 9
1171: EQUAL
1172: OR
1173: PUSH
1174: LD_OWVAR 40
1178: PUSH
1179: LD_INT 11
1181: EQUAL
1182: OR
1183: PUSH
1184: LD_OWVAR 40
1188: PUSH
1189: LD_INT 7
1191: EQUAL
1192: OR
1193: IFFALSE 1242
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1195: LD_ADDR_VAR 0 18
1199: PUSH
1200: LD_INT 2
1202: PUSH
1203: LD_INT 3
1205: PUSH
1206: LD_INT 4
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1218: LD_ADDR_OWVAR 37
1222: PUSH
1223: LD_VAR 0 18
1227: PUSH
1228: LD_INT 1
1230: PPUSH
1231: LD_VAR 0 18
1235: PPUSH
1236: CALL_OW 12
1240: ARRAY
1241: ST_TO_ADDR
// end ; if vc_weapon = 8 or vc_weapon = 6 or vc_weapon = 10 then
1242: LD_OWVAR 40
1246: PUSH
1247: LD_INT 8
1249: EQUAL
1250: PUSH
1251: LD_OWVAR 40
1255: PUSH
1256: LD_INT 6
1258: EQUAL
1259: OR
1260: PUSH
1261: LD_OWVAR 40
1265: PUSH
1266: LD_INT 10
1268: EQUAL
1269: OR
1270: IFFALSE 1311
// begin amChassisTab = [ 4 , 5 ] ;
1272: LD_ADDR_VAR 0 18
1276: PUSH
1277: LD_INT 4
1279: PUSH
1280: LD_INT 5
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1287: LD_ADDR_OWVAR 37
1291: PUSH
1292: LD_VAR 0 18
1296: PUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_VAR 0 18
1304: PPUSH
1305: CALL_OW 12
1309: ARRAY
1310: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1311: LD_ADDR_VAR 0 15
1315: PUSH
1316: CALL_OW 45
1320: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1321: LD_VAR 0 15
1325: PPUSH
1326: LD_VAR 0 1
1330: PPUSH
1331: LD_INT 0
1333: PPUSH
1334: CALL_OW 49
// if vehcontrol = 1 then
1338: LD_VAR 0 7
1342: PUSH
1343: LD_INT 1
1345: EQUAL
1346: IFFALSE 1403
// begin hc_gallery =  ;
1348: LD_ADDR_OWVAR 33
1352: PUSH
1353: LD_STRING 
1355: ST_TO_ADDR
// hc_name =  ;
1356: LD_ADDR_OWVAR 26
1360: PUSH
1361: LD_STRING 
1363: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1364: LD_INT 0
1366: PPUSH
1367: LD_INT 3
1369: PPUSH
1370: LD_VAR 0 4
1374: PPUSH
1375: CALL_OW 380
// un = CreateHuman ;
1379: LD_ADDR_VAR 0 14
1383: PUSH
1384: CALL_OW 44
1388: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1389: LD_VAR 0 14
1393: PPUSH
1394: LD_VAR 0 15
1398: PPUSH
1399: CALL_OW 52
// end ; end ;
1403: GO 1007
1405: POP
1406: POP
// end ; if nation = 2 then
1407: LD_VAR 0 5
1411: PUSH
1412: LD_INT 2
1414: EQUAL
1415: IFFALSE 1771
// begin for i := 1 to vehCount do
1417: LD_ADDR_VAR 0 12
1421: PUSH
1422: DOUBLE
1423: LD_INT 1
1425: DEC
1426: ST_TO_ADDR
1427: LD_VAR 0 3
1431: PUSH
1432: FOR_TO
1433: IFFALSE 1769
// begin uc_side = side ;
1435: LD_ADDR_OWVAR 20
1439: PUSH
1440: LD_VAR 0 2
1444: ST_TO_ADDR
// uc_nation = nation ;
1445: LD_ADDR_OWVAR 21
1449: PUSH
1450: LD_VAR 0 5
1454: ST_TO_ADDR
// vc_engine = vehengine ;
1455: LD_ADDR_OWVAR 39
1459: PUSH
1460: LD_VAR 0 6
1464: ST_TO_ADDR
// vc_control = vehcontrol ;
1465: LD_ADDR_OWVAR 38
1469: PUSH
1470: LD_VAR 0 7
1474: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1475: LD_ADDR_OWVAR 40
1479: PUSH
1480: LD_VAR 0 9
1484: PUSH
1485: LD_INT 1
1487: PPUSH
1488: LD_VAR 0 9
1492: PPUSH
1493: CALL_OW 12
1497: ARRAY
1498: ST_TO_ADDR
// if vc_weapon = 24 or vc_weapon = 22 or vc_weapon = 23 or vc_weapon = 30 then
1499: LD_OWVAR 40
1503: PUSH
1504: LD_INT 24
1506: EQUAL
1507: PUSH
1508: LD_OWVAR 40
1512: PUSH
1513: LD_INT 22
1515: EQUAL
1516: OR
1517: PUSH
1518: LD_OWVAR 40
1522: PUSH
1523: LD_INT 23
1525: EQUAL
1526: OR
1527: PUSH
1528: LD_OWVAR 40
1532: PUSH
1533: LD_INT 30
1535: EQUAL
1536: OR
1537: IFFALSE 1586
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1539: LD_ADDR_VAR 0 17
1543: PUSH
1544: LD_INT 11
1546: PUSH
1547: LD_INT 12
1549: PUSH
1550: LD_INT 13
1552: PUSH
1553: LD_INT 14
1555: PUSH
1556: EMPTY
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1562: LD_ADDR_OWVAR 37
1566: PUSH
1567: LD_VAR 0 17
1571: PUSH
1572: LD_INT 1
1574: PPUSH
1575: LD_VAR 0 17
1579: PPUSH
1580: CALL_OW 12
1584: ARRAY
1585: ST_TO_ADDR
// end ; if vc_weapon = 29 or vc_weapon = 28 or vc_weapon = 27 or vc_weapon = 26 or vc_weapon = 25 then
1586: LD_OWVAR 40
1590: PUSH
1591: LD_INT 29
1593: EQUAL
1594: PUSH
1595: LD_OWVAR 40
1599: PUSH
1600: LD_INT 28
1602: EQUAL
1603: OR
1604: PUSH
1605: LD_OWVAR 40
1609: PUSH
1610: LD_INT 27
1612: EQUAL
1613: OR
1614: PUSH
1615: LD_OWVAR 40
1619: PUSH
1620: LD_INT 26
1622: EQUAL
1623: OR
1624: PUSH
1625: LD_OWVAR 40
1629: PUSH
1630: LD_INT 25
1632: EQUAL
1633: OR
1634: IFFALSE 1675
// begin arChassisTab = [ 13 , 14 ] ;
1636: LD_ADDR_VAR 0 17
1640: PUSH
1641: LD_INT 13
1643: PUSH
1644: LD_INT 14
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1651: LD_ADDR_OWVAR 37
1655: PUSH
1656: LD_VAR 0 17
1660: PUSH
1661: LD_INT 1
1663: PPUSH
1664: LD_VAR 0 17
1668: PPUSH
1669: CALL_OW 12
1673: ARRAY
1674: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1675: LD_ADDR_VAR 0 15
1679: PUSH
1680: CALL_OW 45
1684: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1685: LD_VAR 0 15
1689: PPUSH
1690: LD_VAR 0 1
1694: PPUSH
1695: LD_INT 0
1697: PPUSH
1698: CALL_OW 49
// if vehcontrol = 1 then
1702: LD_VAR 0 7
1706: PUSH
1707: LD_INT 1
1709: EQUAL
1710: IFFALSE 1767
// begin hc_gallery =  ;
1712: LD_ADDR_OWVAR 33
1716: PUSH
1717: LD_STRING 
1719: ST_TO_ADDR
// hc_name =  ;
1720: LD_ADDR_OWVAR 26
1724: PUSH
1725: LD_STRING 
1727: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1728: LD_INT 0
1730: PPUSH
1731: LD_INT 3
1733: PPUSH
1734: LD_VAR 0 4
1738: PPUSH
1739: CALL_OW 380
// un = CreateHuman ;
1743: LD_ADDR_VAR 0 14
1747: PUSH
1748: CALL_OW 44
1752: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1753: LD_VAR 0 14
1757: PPUSH
1758: LD_VAR 0 15
1762: PPUSH
1763: CALL_OW 52
// end ; end ;
1767: GO 1432
1769: POP
1770: POP
// end ; if nation = 3 then
1771: LD_VAR 0 5
1775: PUSH
1776: LD_INT 3
1778: EQUAL
1779: IFFALSE 2137
// begin for i := 1 to vehCount do
1781: LD_ADDR_VAR 0 12
1785: PUSH
1786: DOUBLE
1787: LD_INT 1
1789: DEC
1790: ST_TO_ADDR
1791: LD_VAR 0 3
1795: PUSH
1796: FOR_TO
1797: IFFALSE 2135
// begin uc_side = side ;
1799: LD_ADDR_OWVAR 20
1803: PUSH
1804: LD_VAR 0 2
1808: ST_TO_ADDR
// uc_nation = nation ;
1809: LD_ADDR_OWVAR 21
1813: PUSH
1814: LD_VAR 0 5
1818: ST_TO_ADDR
// vc_engine = vehengine ;
1819: LD_ADDR_OWVAR 39
1823: PUSH
1824: LD_VAR 0 6
1828: ST_TO_ADDR
// vc_control = vehcontrol ;
1829: LD_ADDR_OWVAR 38
1833: PUSH
1834: LD_VAR 0 7
1838: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1839: LD_ADDR_OWVAR 40
1843: PUSH
1844: LD_VAR 0 8
1848: PUSH
1849: LD_INT 1
1851: PPUSH
1852: LD_VAR 0 8
1856: PPUSH
1857: CALL_OW 12
1861: ARRAY
1862: ST_TO_ADDR
// for j = 1 to RuWeapons do
1863: LD_ADDR_VAR 0 13
1867: PUSH
1868: DOUBLE
1869: LD_INT 1
1871: DEC
1872: ST_TO_ADDR
1873: LD_VAR 0 8
1877: PUSH
1878: FOR_TO
1879: IFFALSE 2039
// begin if vc_weapon = 42 or vc_weapon = 43 or vc_weapon = 44 or vc_weapon = 45 or vc_weapon = 49 then
1881: LD_OWVAR 40
1885: PUSH
1886: LD_INT 42
1888: EQUAL
1889: PUSH
1890: LD_OWVAR 40
1894: PUSH
1895: LD_INT 43
1897: EQUAL
1898: OR
1899: PUSH
1900: LD_OWVAR 40
1904: PUSH
1905: LD_INT 44
1907: EQUAL
1908: OR
1909: PUSH
1910: LD_OWVAR 40
1914: PUSH
1915: LD_INT 45
1917: EQUAL
1918: OR
1919: PUSH
1920: LD_OWVAR 40
1924: PUSH
1925: LD_INT 49
1927: EQUAL
1928: OR
1929: IFFALSE 1978
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1931: LD_ADDR_VAR 0 16
1935: PUSH
1936: LD_INT 21
1938: PUSH
1939: LD_INT 22
1941: PUSH
1942: LD_INT 23
1944: PUSH
1945: LD_INT 24
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1954: LD_ADDR_OWVAR 37
1958: PUSH
1959: LD_VAR 0 16
1963: PUSH
1964: LD_INT 1
1966: PPUSH
1967: LD_VAR 0 16
1971: PPUSH
1972: CALL_OW 12
1976: ARRAY
1977: ST_TO_ADDR
// end ; if vc_weapon = 46 or vc_weapon = 47 then
1978: LD_OWVAR 40
1982: PUSH
1983: LD_INT 46
1985: EQUAL
1986: PUSH
1987: LD_OWVAR 40
1991: PUSH
1992: LD_INT 47
1994: EQUAL
1995: OR
1996: IFFALSE 2037
// begin ruChassisTab = [ 23 , 24 ] ;
1998: LD_ADDR_VAR 0 16
2002: PUSH
2003: LD_INT 23
2005: PUSH
2006: LD_INT 24
2008: PUSH
2009: EMPTY
2010: LIST
2011: LIST
2012: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2013: LD_ADDR_OWVAR 37
2017: PUSH
2018: LD_VAR 0 16
2022: PUSH
2023: LD_INT 1
2025: PPUSH
2026: LD_VAR 0 16
2030: PPUSH
2031: CALL_OW 12
2035: ARRAY
2036: ST_TO_ADDR
// end ; end ;
2037: GO 1878
2039: POP
2040: POP
// veh = CreateVehicle ;
2041: LD_ADDR_VAR 0 15
2045: PUSH
2046: CALL_OW 45
2050: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2051: LD_VAR 0 15
2055: PPUSH
2056: LD_VAR 0 1
2060: PPUSH
2061: LD_INT 0
2063: PPUSH
2064: CALL_OW 49
// if vehcontrol = 1 then
2068: LD_VAR 0 7
2072: PUSH
2073: LD_INT 1
2075: EQUAL
2076: IFFALSE 2133
// begin hc_gallery =  ;
2078: LD_ADDR_OWVAR 33
2082: PUSH
2083: LD_STRING 
2085: ST_TO_ADDR
// hc_name =  ;
2086: LD_ADDR_OWVAR 26
2090: PUSH
2091: LD_STRING 
2093: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2094: LD_INT 0
2096: PPUSH
2097: LD_INT 3
2099: PPUSH
2100: LD_VAR 0 4
2104: PPUSH
2105: CALL_OW 380
// un = CreateHuman ;
2109: LD_ADDR_VAR 0 14
2113: PUSH
2114: CALL_OW 44
2118: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2119: LD_VAR 0 14
2123: PPUSH
2124: LD_VAR 0 15
2128: PPUSH
2129: CALL_OW 52
// end ; end ;
2133: GO 1796
2135: POP
2136: POP
// end ; repeat wait ( 0 0$1 ) ;
2137: LD_INT 35
2139: PPUSH
2140: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2144: LD_ADDR_VAR 0 19
2148: PUSH
2149: LD_INT 22
2151: PUSH
2152: LD_VAR 0 2
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 24
2173: PUSH
2174: LD_INT 650
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: LIST
2185: PPUSH
2186: CALL_OW 69
2190: ST_TO_ADDR
// if vehicleOK_list > 0 then
2191: LD_VAR 0 19
2195: PUSH
2196: LD_INT 0
2198: GREATER
2199: IFFALSE 2390
// begin for i in vehicleOK_list do
2201: LD_ADDR_VAR 0 12
2205: PUSH
2206: LD_VAR 0 19
2210: PUSH
2211: FOR_IN
2212: IFFALSE 2388
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , side ] ) , i ) ;
2214: LD_ADDR_VAR 0 20
2218: PUSH
2219: LD_INT 81
2221: PUSH
2222: LD_VAR 0 2
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: PPUSH
2231: CALL_OW 69
2235: PPUSH
2236: LD_VAR 0 12
2240: PPUSH
2241: CALL_OW 74
2245: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2246: LD_ADDR_VAR 0 21
2250: PUSH
2251: LD_INT 81
2253: PUSH
2254: LD_VAR 0 2
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: PUSH
2263: LD_INT 2
2265: PUSH
2266: LD_INT 59
2268: PUSH
2269: EMPTY
2270: LIST
2271: PUSH
2272: LD_INT 21
2274: PUSH
2275: LD_INT 1
2277: PUSH
2278: EMPTY
2279: LIST
2280: LIST
2281: PUSH
2282: LD_INT 21
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: LIST
2296: LIST
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: PPUSH
2305: CALL_OW 69
2309: PPUSH
2310: LD_VAR 0 12
2314: PPUSH
2315: CALL_OW 74
2319: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2320: LD_VAR 0 12
2324: PPUSH
2325: LD_VAR 0 20
2329: PPUSH
2330: CALL_OW 296
2334: PUSH
2335: LD_INT 8
2337: PLUS
2338: PUSH
2339: LD_VAR 0 12
2343: PPUSH
2344: LD_VAR 0 21
2348: PPUSH
2349: CALL_OW 296
2353: LESS
2354: IFFALSE 2372
// ComAttackUnit ( i , target1 ) else
2356: LD_VAR 0 12
2360: PPUSH
2361: LD_VAR 0 20
2365: PPUSH
2366: CALL_OW 115
2370: GO 2386
// ComAttackUnit ( i , target2 ) ;
2372: LD_VAR 0 12
2376: PPUSH
2377: LD_VAR 0 21
2381: PPUSH
2382: CALL_OW 115
// end ;
2386: GO 2211
2388: POP
2389: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_empty ] ] ) = 0 ;
2390: LD_INT 22
2392: PUSH
2393: LD_VAR 0 2
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: PUSH
2402: LD_INT 21
2404: PUSH
2405: LD_INT 2
2407: PUSH
2408: EMPTY
2409: LIST
2410: LIST
2411: PUSH
2412: LD_INT 24
2414: PUSH
2415: LD_INT 250
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: PUSH
2422: LD_INT 58
2424: PUSH
2425: EMPTY
2426: LIST
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PPUSH
2434: CALL_OW 69
2438: PUSH
2439: LD_INT 0
2441: EQUAL
2442: IFFALSE 2137
// end ;
2444: LD_VAR 0 11
2448: RET
// every 0 0$1 do
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// end ;
2453: END
// export function BuildingVehicle ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2454: LD_INT 0
2456: PPUSH
2457: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2458: LD_INT 22
2460: PUSH
2461: LD_VAR 0 1
2465: PUSH
2466: EMPTY
2467: LIST
2468: LIST
2469: PUSH
2470: LD_INT 21
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: PPUSH
2484: CALL_OW 69
2488: PUSH
2489: LD_VAR 0 3
2493: LESSEQUAL
2494: IFFALSE 2561
// for i = 1 to vehCount do
2496: LD_ADDR_VAR 0 9
2500: PUSH
2501: DOUBLE
2502: LD_INT 1
2504: DEC
2505: ST_TO_ADDR
2506: LD_VAR 0 3
2510: PUSH
2511: FOR_TO
2512: IFFALSE 2559
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2514: LD_VAR 0 2
2518: PPUSH
2519: LD_VAR 0 7
2523: PPUSH
2524: LD_VAR 0 5
2528: PPUSH
2529: LD_VAR 0 6
2533: PPUSH
2534: LD_VAR 0 4
2538: PUSH
2539: LD_INT 1
2541: PPUSH
2542: LD_VAR 0 4
2546: PPUSH
2547: CALL_OW 12
2551: ARRAY
2552: PPUSH
2553: CALL_OW 185
2557: GO 2511
2559: POP
2560: POP
// end ;
2561: LD_VAR 0 8
2565: RET
// export function RepairVehicles ( side , area , repX , repY ) ; var i , j , damageVehicles ; begin
2566: LD_INT 0
2568: PPUSH
2569: PPUSH
2570: PPUSH
2571: PPUSH
// damageVehicles = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
2572: LD_ADDR_VAR 0 8
2576: PUSH
2577: LD_INT 22
2579: PUSH
2580: LD_VAR 0 1
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: LD_INT 21
2591: PUSH
2592: LD_INT 2
2594: PUSH
2595: EMPTY
2596: LIST
2597: LIST
2598: PUSH
2599: LD_INT 3
2601: PUSH
2602: LD_INT 24
2604: PUSH
2605: LD_INT 650
2607: PUSH
2608: EMPTY
2609: LIST
2610: LIST
2611: PUSH
2612: EMPTY
2613: LIST
2614: LIST
2615: PUSH
2616: EMPTY
2617: LIST
2618: LIST
2619: LIST
2620: PPUSH
2621: CALL_OW 69
2625: ST_TO_ADDR
// if damageVehicles > 0 then
2626: LD_VAR 0 8
2630: PUSH
2631: LD_INT 0
2633: GREATER
2634: IFFALSE 2655
// ComMoveXY ( damageVehicles , repX , repY ) ;
2636: LD_VAR 0 8
2640: PPUSH
2641: LD_VAR 0 3
2645: PPUSH
2646: LD_VAR 0 4
2650: PPUSH
2651: CALL_OW 111
// if UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) > 0 then
2655: LD_VAR 0 8
2659: PPUSH
2660: LD_INT 95
2662: PUSH
2663: LD_VAR 0 2
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PUSH
2672: LD_INT 3
2674: PUSH
2675: LD_INT 58
2677: PUSH
2678: EMPTY
2679: LIST
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: EMPTY
2686: LIST
2687: LIST
2688: PPUSH
2689: CALL_OW 72
2693: PUSH
2694: LD_INT 0
2696: GREATER
2697: IFFALSE 2764
// for i in UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) do
2699: LD_ADDR_VAR 0 6
2703: PUSH
2704: LD_VAR 0 8
2708: PPUSH
2709: LD_INT 95
2711: PUSH
2712: LD_VAR 0 2
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PUSH
2721: LD_INT 3
2723: PUSH
2724: LD_INT 58
2726: PUSH
2727: EMPTY
2728: LIST
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: PPUSH
2738: CALL_OW 72
2742: PUSH
2743: FOR_IN
2744: IFFALSE 2762
// ComExitVehicle ( UnitsInside ( i ) ) ;
2746: LD_VAR 0 6
2750: PPUSH
2751: CALL_OW 313
2755: PPUSH
2756: CALL_OW 121
2760: GO 2743
2762: POP
2763: POP
// end ;
2764: LD_VAR 0 5
2768: RET
// export function AttackVehicles ( side , meetArea , wayX , wayY ) ; var i , j , vehiclesOK , target1 , target2 , seeEnemy ; begin
2769: LD_INT 0
2771: PPUSH
2772: PPUSH
2773: PPUSH
2774: PPUSH
2775: PPUSH
2776: PPUSH
2777: PPUSH
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2778: LD_ADDR_VAR 0 8
2782: PUSH
2783: LD_INT 22
2785: PUSH
2786: LD_VAR 0 1
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: LD_INT 21
2797: PUSH
2798: LD_INT 2
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: PUSH
2805: LD_INT 24
2807: PUSH
2808: LD_INT 650
2810: PUSH
2811: EMPTY
2812: LIST
2813: LIST
2814: PUSH
2815: EMPTY
2816: LIST
2817: LIST
2818: LIST
2819: PPUSH
2820: CALL_OW 69
2824: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 5 then
2825: LD_INT 22
2827: PUSH
2828: LD_VAR 0 1
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 21
2839: PUSH
2840: LD_INT 2
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 24
2849: PUSH
2850: LD_INT 1000
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: PUSH
2867: LD_INT 5
2869: EQUAL
2870: IFFALSE 3337
// repeat wait ( 0 0$1 ) ;
2872: LD_INT 35
2874: PPUSH
2875: CALL_OW 67
// display_strings = seeEnemy ;
2879: LD_ADDR_OWVAR 47
2883: PUSH
2884: LD_VAR 0 11
2888: ST_TO_ADDR
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2889: LD_ADDR_VAR 0 8
2893: PUSH
2894: LD_INT 22
2896: PUSH
2897: LD_VAR 0 1
2901: PUSH
2902: EMPTY
2903: LIST
2904: LIST
2905: PUSH
2906: LD_INT 21
2908: PUSH
2909: LD_INT 2
2911: PUSH
2912: EMPTY
2913: LIST
2914: LIST
2915: PUSH
2916: LD_INT 24
2918: PUSH
2919: LD_INT 650
2921: PUSH
2922: EMPTY
2923: LIST
2924: LIST
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: LIST
2930: PPUSH
2931: CALL_OW 69
2935: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) and seeEnemy = 0 then
2936: LD_INT 22
2938: PUSH
2939: LD_VAR 0 1
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 95
2950: PUSH
2951: LD_VAR 0 2
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: PPUSH
2964: CALL_OW 69
2968: NOT
2969: PUSH
2970: LD_VAR 0 11
2974: PUSH
2975: LD_INT 0
2977: EQUAL
2978: AND
2979: IFFALSE 3034
// for i := 1 to wayX do
2981: LD_ADDR_VAR 0 6
2985: PUSH
2986: DOUBLE
2987: LD_INT 1
2989: DEC
2990: ST_TO_ADDR
2991: LD_VAR 0 3
2995: PUSH
2996: FOR_TO
2997: IFFALSE 3032
// AddComAgressiveMove ( vehiclesOK , wayX [ i ] , wayY [ i ] ) ;
2999: LD_VAR 0 8
3003: PPUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_VAR 0 6
3013: ARRAY
3014: PPUSH
3015: LD_VAR 0 4
3019: PUSH
3020: LD_VAR 0 6
3024: ARRAY
3025: PPUSH
3026: CALL_OW 174
3030: GO 2996
3032: POP
3033: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) then
3034: LD_INT 22
3036: PUSH
3037: LD_VAR 0 1
3041: PUSH
3042: EMPTY
3043: LIST
3044: LIST
3045: PUSH
3046: LD_INT 95
3048: PUSH
3049: LD_VAR 0 2
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3290
// begin seeEnemy = 1 ;
3068: LD_ADDR_VAR 0 11
3072: PUSH
3073: LD_INT 1
3075: ST_TO_ADDR
// for j in vehiclesOK do
3076: LD_ADDR_VAR 0 7
3080: PUSH
3081: LD_VAR 0 8
3085: PUSH
3086: FOR_IN
3087: IFFALSE 3288
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , side ] , [ f_see , 1 ] ] ) , j ) ;
3089: LD_ADDR_VAR 0 9
3093: PUSH
3094: LD_INT 81
3096: PUSH
3097: LD_VAR 0 1
3101: PUSH
3102: EMPTY
3103: LIST
3104: LIST
3105: PUSH
3106: LD_INT 101
3108: PUSH
3109: LD_INT 1
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL_OW 69
3124: PPUSH
3125: LD_VAR 0 7
3129: PPUSH
3130: CALL_OW 74
3134: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_see , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , j ) ;
3135: LD_ADDR_VAR 0 10
3139: PUSH
3140: LD_INT 81
3142: PUSH
3143: LD_VAR 0 1
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: LD_INT 101
3154: PUSH
3155: LD_INT 1
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: PUSH
3162: LD_INT 2
3164: PUSH
3165: LD_INT 59
3167: PUSH
3168: EMPTY
3169: LIST
3170: PUSH
3171: LD_INT 21
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 21
3183: PUSH
3184: LD_INT 2
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: LIST
3195: LIST
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: EMPTY
3203: LIST
3204: PPUSH
3205: CALL_OW 69
3209: PPUSH
3210: LD_VAR 0 7
3214: PPUSH
3215: CALL_OW 74
3219: ST_TO_ADDR
// if GetDistUnits ( j , target1 ) + 8 < GetDistUnits ( j , target2 ) then
3220: LD_VAR 0 7
3224: PPUSH
3225: LD_VAR 0 9
3229: PPUSH
3230: CALL_OW 296
3234: PUSH
3235: LD_INT 8
3237: PLUS
3238: PUSH
3239: LD_VAR 0 7
3243: PPUSH
3244: LD_VAR 0 10
3248: PPUSH
3249: CALL_OW 296
3253: LESS
3254: IFFALSE 3272
// ComAttackUnit ( j , target1 ) else
3256: LD_VAR 0 7
3260: PPUSH
3261: LD_VAR 0 9
3265: PPUSH
3266: CALL_OW 115
3270: GO 3286
// ComAttackUnit ( j , target2 ) ;
3272: LD_VAR 0 7
3276: PPUSH
3277: LD_VAR 0 10
3281: PPUSH
3282: CALL_OW 115
// end ;
3286: GO 3086
3288: POP
3289: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 0 ;
3290: LD_INT 22
3292: PUSH
3293: LD_VAR 0 1
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 21
3304: PUSH
3305: LD_INT 2
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PUSH
3312: LD_INT 24
3314: PUSH
3315: LD_INT 1000
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: LIST
3326: PPUSH
3327: CALL_OW 69
3331: PUSH
3332: LD_INT 0
3334: EQUAL
3335: IFFALSE 2872
// seeEnemy = 0 ;
3337: LD_ADDR_VAR 0 11
3341: PUSH
3342: LD_INT 0
3344: ST_TO_ADDR
// end ;
3345: LD_VAR 0 5
3349: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3350: LD_INT 0
3352: PPUSH
3353: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3354: LD_INT 22
3356: PUSH
3357: LD_VAR 0 1
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: PUSH
3366: LD_INT 25
3368: PUSH
3369: LD_INT 2
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PPUSH
3380: CALL_OW 69
3384: PUSH
3385: LD_INT 0
3387: GREATER
3388: PUSH
3389: LD_INT 22
3391: PUSH
3392: LD_VAR 0 1
3396: PUSH
3397: EMPTY
3398: LIST
3399: LIST
3400: PUSH
3401: LD_INT 21
3403: PUSH
3404: LD_INT 3
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: PUSH
3411: LD_INT 3
3413: PUSH
3414: LD_INT 24
3416: PUSH
3417: LD_INT 1000
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: PPUSH
3433: CALL_OW 69
3437: PUSH
3438: LD_INT 0
3440: EQUAL
3441: AND
3442: PUSH
3443: LD_VAR 0 2
3447: PUSH
3448: LD_INT 0
3450: GREATER
3451: AND
3452: IFFALSE 3551
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3454: LD_ADDR_VAR 0 4
3458: PUSH
3459: LD_INT 22
3461: PUSH
3462: LD_VAR 0 1
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PUSH
3471: LD_INT 25
3473: PUSH
3474: LD_INT 2
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: PPUSH
3485: CALL_OW 69
3489: PUSH
3490: FOR_IN
3491: IFFALSE 3549
// begin AddComExitBuilding ( i ) ;
3493: LD_VAR 0 4
3497: PPUSH
3498: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3502: LD_VAR 0 4
3506: PPUSH
3507: LD_VAR 0 2
3511: PUSH
3512: LD_INT 1
3514: ARRAY
3515: PPUSH
3516: LD_VAR 0 2
3520: PUSH
3521: LD_INT 2
3523: ARRAY
3524: PPUSH
3525: LD_VAR 0 2
3529: PUSH
3530: LD_INT 3
3532: ARRAY
3533: PPUSH
3534: LD_VAR 0 2
3538: PUSH
3539: LD_INT 4
3541: ARRAY
3542: PPUSH
3543: CALL_OW 205
// end ;
3547: GO 3490
3549: POP
3550: POP
// end ; end ;
3551: LD_VAR 0 3
3555: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3556: LD_INT 0
3558: PPUSH
3559: PPUSH
3560: PPUSH
3561: PPUSH
3562: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3563: LD_ADDR_VAR 0 6
3567: PUSH
3568: LD_INT 22
3570: PUSH
3571: LD_VAR 0 1
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: PUSH
3580: LD_INT 2
3582: PUSH
3583: LD_INT 30
3585: PUSH
3586: LD_INT 31
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: PUSH
3593: LD_INT 30
3595: PUSH
3596: LD_INT 32
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 30
3605: PUSH
3606: LD_INT 33
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: PUSH
3613: LD_INT 30
3615: PUSH
3616: LD_INT 4
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: PUSH
3623: LD_INT 30
3625: PUSH
3626: LD_INT 5
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PPUSH
3645: CALL_OW 69
3649: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3650: LD_ADDR_VAR 0 7
3654: PUSH
3655: LD_INT 22
3657: PUSH
3658: LD_VAR 0 2
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PUSH
3667: LD_INT 21
3669: PUSH
3670: LD_INT 3
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: PUSH
3677: LD_INT 58
3679: PUSH
3680: EMPTY
3681: LIST
3682: PUSH
3683: EMPTY
3684: LIST
3685: LIST
3686: LIST
3687: PPUSH
3688: CALL_OW 69
3692: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3693: LD_VAR 0 6
3697: PUSH
3698: LD_INT 0
3700: GREATER
3701: PUSH
3702: LD_VAR 0 7
3706: PUSH
3707: LD_INT 0
3709: GREATER
3710: AND
3711: IFFALSE 3781
// begin for i in turretsList do
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 6
3722: PUSH
3723: FOR_IN
3724: IFFALSE 3779
// begin for j in enemyBuildings do
3726: LD_ADDR_VAR 0 5
3730: PUSH
3731: LD_VAR 0 7
3735: PUSH
3736: FOR_IN
3737: IFFALSE 3775
// begin if GetDistUnits ( i , j ) < 20 then
3739: LD_VAR 0 4
3743: PPUSH
3744: LD_VAR 0 5
3748: PPUSH
3749: CALL_OW 296
3753: PUSH
3754: LD_INT 20
3756: LESS
3757: IFFALSE 3773
// begin ComAttackUnit ( i , j ) ;
3759: LD_VAR 0 4
3763: PPUSH
3764: LD_VAR 0 5
3768: PPUSH
3769: CALL_OW 115
// end ; end ;
3773: GO 3736
3775: POP
3776: POP
// end ;
3777: GO 3723
3779: POP
3780: POP
// end ; end ;
3781: LD_VAR 0 3
3785: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3786: LD_INT 0
3788: PPUSH
3789: PPUSH
3790: PPUSH
3791: PPUSH
3792: PPUSH
3793: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3794: LD_ADDR_VAR 0 7
3798: PUSH
3799: LD_INT 22
3801: PUSH
3802: LD_VAR 0 1
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: LD_INT 25
3813: PUSH
3814: LD_INT 9
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PPUSH
3825: CALL_OW 69
3829: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3830: LD_ADDR_VAR 0 8
3834: PUSH
3835: LD_INT 22
3837: PUSH
3838: LD_VAR 0 2
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PUSH
3847: LD_INT 3
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3873: LD_ADDR_VAR 0 5
3877: PUSH
3878: LD_INT 1
3880: PPUSH
3881: LD_INT 3
3883: PPUSH
3884: CALL_OW 12
3888: ST_TO_ADDR
// for i = 1 to list do
3889: LD_ADDR_VAR 0 6
3893: PUSH
3894: DOUBLE
3895: LD_INT 1
3897: DEC
3898: ST_TO_ADDR
3899: LD_VAR 0 7
3903: PUSH
3904: FOR_TO
3905: IFFALSE 4087
// for ta in filter do
3907: LD_ADDR_VAR 0 4
3911: PUSH
3912: LD_VAR 0 8
3916: PUSH
3917: FOR_IN
3918: IFFALSE 4083
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3920: LD_VAR 0 7
3924: PUSH
3925: LD_VAR 0 6
3929: ARRAY
3930: PPUSH
3931: LD_VAR 0 4
3935: PPUSH
3936: CALL_OW 296
3940: PUSH
3941: LD_INT 13
3943: LESSEQUAL
3944: IFFALSE 4081
// begin case c of 1 :
3946: LD_VAR 0 5
3950: PUSH
3951: LD_INT 1
3953: DOUBLE
3954: EQUAL
3955: IFTRUE 3959
3957: GO 3997
3959: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3960: LD_VAR 0 7
3964: PUSH
3965: LD_VAR 0 6
3969: ARRAY
3970: PPUSH
3971: LD_VAR 0 4
3975: PPUSH
3976: CALL_OW 250
3980: PPUSH
3981: LD_VAR 0 4
3985: PPUSH
3986: CALL_OW 251
3990: PPUSH
3991: CALL_OW 154
3995: GO 4081
3997: LD_INT 2
3999: DOUBLE
4000: EQUAL
4001: IFTRUE 4005
4003: GO 4069
4005: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4006: LD_VAR 0 7
4010: PUSH
4011: LD_VAR 0 6
4015: ARRAY
4016: PPUSH
4017: LD_VAR 0 4
4021: PPUSH
4022: CALL_OW 250
4026: PUSH
4027: LD_INT 1
4029: NEG
4030: PPUSH
4031: LD_INT 1
4033: PPUSH
4034: CALL_OW 12
4038: PLUS
4039: PPUSH
4040: LD_VAR 0 4
4044: PPUSH
4045: CALL_OW 251
4049: PUSH
4050: LD_INT 1
4052: NEG
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: CALL_OW 12
4061: PLUS
4062: PPUSH
4063: CALL_OW 153
4067: GO 4081
4069: LD_INT 3
4071: DOUBLE
4072: EQUAL
4073: IFTRUE 4077
4075: GO 4080
4077: POP
// ; end ;
4078: GO 4081
4080: POP
// end ; end ;
4081: GO 3917
4083: POP
4084: POP
4085: GO 3904
4087: POP
4088: POP
// end ;
4089: LD_VAR 0 3
4093: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
4094: LD_INT 0
4096: PPUSH
4097: PPUSH
4098: PPUSH
4099: PPUSH
4100: PPUSH
4101: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
4102: LD_ADDR_VAR 0 6
4106: PUSH
4107: LD_VAR 0 2
4111: PPUSH
4112: CALL_OW 313
4116: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
4117: LD_ADDR_VAR 0 7
4121: PUSH
4122: LD_INT 22
4124: PUSH
4125: LD_VAR 0 1
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 25
4136: PUSH
4137: LD_INT 2
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 24
4146: PUSH
4147: LD_INT 1000
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: LD_INT 3
4156: PUSH
4157: LD_INT 54
4159: PUSH
4160: EMPTY
4161: LIST
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: PPUSH
4173: CALL_OW 69
4177: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4178: LD_ADDR_VAR 0 4
4182: PUSH
4183: LD_INT 22
4185: PUSH
4186: LD_VAR 0 1
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PUSH
4195: LD_INT 21
4197: PUSH
4198: LD_INT 3
4200: PUSH
4201: EMPTY
4202: LIST
4203: LIST
4204: PUSH
4205: LD_INT 3
4207: PUSH
4208: LD_INT 24
4210: PUSH
4211: LD_INT 1000
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: EMPTY
4228: LIST
4229: PPUSH
4230: CALL_OW 69
4234: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4235: LD_VAR 0 4
4239: NOT
4240: PUSH
4241: LD_VAR 0 7
4245: NOT
4246: AND
4247: PUSH
4248: LD_EXP 1
4252: NOT
4253: AND
4254: IFFALSE 4258
// exit ;
4256: GO 4377
// if buildings_list > 0 and engineerOkInside then
4258: LD_VAR 0 4
4262: PUSH
4263: LD_INT 0
4265: GREATER
4266: PUSH
4267: LD_VAR 0 6
4271: AND
4272: IFFALSE 4305
// for i in UnitsInside ( building ) do
4274: LD_ADDR_VAR 0 5
4278: PUSH
4279: LD_VAR 0 2
4283: PPUSH
4284: CALL_OW 313
4288: PUSH
4289: FOR_IN
4290: IFFALSE 4303
// ComExitBuilding ( i ) ;
4292: LD_VAR 0 5
4296: PPUSH
4297: CALL_OW 122
4301: GO 4289
4303: POP
4304: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4305: LD_VAR 0 4
4309: PUSH
4310: LD_INT 0
4312: GREATER
4313: PUSH
4314: LD_VAR 0 7
4318: PUSH
4319: LD_INT 0
4321: GREATER
4322: AND
4323: IFFALSE 4377
// begin for i in engineerOkOutside do
4325: LD_ADDR_VAR 0 5
4329: PUSH
4330: LD_VAR 0 7
4334: PUSH
4335: FOR_IN
4336: IFFALSE 4375
// for j in buildings_list do
4338: LD_ADDR_VAR 0 8
4342: PUSH
4343: LD_VAR 0 4
4347: PUSH
4348: FOR_IN
4349: IFFALSE 4371
// ComRepairBuilding ( i , j [ 1 ] ) ;
4351: LD_VAR 0 5
4355: PPUSH
4356: LD_VAR 0 8
4360: PUSH
4361: LD_INT 1
4363: ARRAY
4364: PPUSH
4365: CALL_OW 130
4369: GO 4348
4371: POP
4372: POP
4373: GO 4335
4375: POP
4376: POP
// end ; end ;
4377: LD_VAR 0 3
4381: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4382: LD_INT 0
4384: PPUSH
4385: PPUSH
4386: PPUSH
4387: PPUSH
4388: PPUSH
4389: PPUSH
4390: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4391: LD_ADDR_VAR 0 6
4395: PUSH
4396: LD_INT 22
4398: PUSH
4399: LD_VAR 0 1
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 25
4410: PUSH
4411: LD_INT 4
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 24
4420: PUSH
4421: LD_INT 251
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4438: LD_ADDR_VAR 0 7
4442: PUSH
4443: LD_VAR 0 3
4447: PPUSH
4448: LD_INT 22
4450: PUSH
4451: LD_VAR 0 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 25
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PUSH
4470: LD_INT 50
4472: PUSH
4473: EMPTY
4474: LIST
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 70
4485: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4486: LD_ADDR_VAR 0 10
4490: PUSH
4491: LD_VAR 0 3
4495: PPUSH
4496: LD_INT 22
4498: PUSH
4499: LD_VAR 0 1
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 21
4510: PUSH
4511: LD_INT 1
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: PUSH
4518: LD_INT 3
4520: PUSH
4521: LD_INT 24
4523: PUSH
4524: LD_INT 750
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: LIST
4539: PPUSH
4540: CALL_OW 70
4544: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4545: LD_ADDR_VAR 0 11
4549: PUSH
4550: LD_VAR 0 2
4554: PPUSH
4555: LD_INT 22
4557: PUSH
4558: LD_VAR 0 1
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: LD_INT 21
4569: PUSH
4570: LD_INT 1
4572: PUSH
4573: EMPTY
4574: LIST
4575: LIST
4576: PUSH
4577: LD_INT 3
4579: PUSH
4580: LD_INT 24
4582: PUSH
4583: LD_INT 1000
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PPUSH
4599: CALL_OW 70
4603: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
4604: LD_VAR 0 10
4608: NOT
4609: PUSH
4610: LD_VAR 0 7
4614: NOT
4615: AND
4616: PUSH
4617: LD_VAR 0 11
4621: NOT
4622: AND
4623: IFFALSE 4627
// exit ;
4625: GO 4816
// if damageUnits > 0 and sci_list > 0 then
4627: LD_VAR 0 10
4631: PUSH
4632: LD_INT 0
4634: GREATER
4635: PUSH
4636: LD_VAR 0 6
4640: PUSH
4641: LD_INT 0
4643: GREATER
4644: AND
4645: IFFALSE 4678
// for i in damageUnits do
4647: LD_ADDR_VAR 0 8
4651: PUSH
4652: LD_VAR 0 10
4656: PUSH
4657: FOR_IN
4658: IFFALSE 4676
// ComMoveToArea ( i , healArea ) ;
4660: LD_VAR 0 8
4664: PPUSH
4665: LD_VAR 0 2
4669: PPUSH
4670: CALL_OW 113
4674: GO 4657
4676: POP
4677: POP
// if unitsToHeal > 0 and sci_list > 0 then
4678: LD_VAR 0 11
4682: PUSH
4683: LD_INT 0
4685: GREATER
4686: PUSH
4687: LD_VAR 0 6
4691: PUSH
4692: LD_INT 0
4694: GREATER
4695: AND
4696: IFFALSE 4755
// begin for i in sci_list do
4698: LD_ADDR_VAR 0 8
4702: PUSH
4703: LD_VAR 0 6
4707: PUSH
4708: FOR_IN
4709: IFFALSE 4753
// begin ComExitBuilding ( i ) ;
4711: LD_VAR 0 8
4715: PPUSH
4716: CALL_OW 122
// for j in unitsToHeal do
4720: LD_ADDR_VAR 0 9
4724: PUSH
4725: LD_VAR 0 11
4729: PUSH
4730: FOR_IN
4731: IFFALSE 4749
// AddComHeal ( i , j ) ;
4733: LD_VAR 0 8
4737: PPUSH
4738: LD_VAR 0 9
4742: PPUSH
4743: CALL_OW 188
4747: GO 4730
4749: POP
4750: POP
// end ;
4751: GO 4708
4753: POP
4754: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
4755: LD_VAR 0 10
4759: PUSH
4760: LD_INT 0
4762: EQUAL
4763: PUSH
4764: LD_VAR 0 11
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: AND
4773: PUSH
4774: LD_VAR 0 7
4778: PUSH
4779: LD_INT 0
4781: GREATER
4782: AND
4783: IFFALSE 4816
// for i in sci_listOutside do
4785: LD_ADDR_VAR 0 8
4789: PUSH
4790: LD_VAR 0 7
4794: PUSH
4795: FOR_IN
4796: IFFALSE 4814
// ComEnterUnit ( i , build ) ;
4798: LD_VAR 0 8
4802: PPUSH
4803: LD_VAR 0 4
4807: PPUSH
4808: CALL_OW 120
4812: GO 4795
4814: POP
4815: POP
// end ; end_of_file
4816: LD_VAR 0 5
4820: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4821: LD_INT 0
4823: PPUSH
4824: PPUSH
// if exist_mode then
4825: LD_VAR 0 2
4829: IFFALSE 4848
// unit := CreateCharacter ( ident ) else
4831: LD_ADDR_VAR 0 4
4835: PUSH
4836: LD_VAR 0 1
4840: PPUSH
4841: CALL_OW 34
4845: ST_TO_ADDR
4846: GO 4863
// unit := NewCharacter ( ident ) ;
4848: LD_ADDR_VAR 0 4
4852: PUSH
4853: LD_VAR 0 1
4857: PPUSH
4858: CALL_OW 25
4862: ST_TO_ADDR
// result := unit ;
4863: LD_ADDR_VAR 0 3
4867: PUSH
4868: LD_VAR 0 4
4872: ST_TO_ADDR
// end ;
4873: LD_VAR 0 3
4877: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4878: LD_INT 0
4880: PPUSH
4881: PPUSH
4882: PPUSH
// uc_side := GetSide ( b ) ;
4883: LD_ADDR_OWVAR 20
4887: PUSH
4888: LD_VAR 0 2
4892: PPUSH
4893: CALL_OW 255
4897: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4898: LD_ADDR_OWVAR 21
4902: PUSH
4903: LD_VAR 0 2
4907: PPUSH
4908: CALL_OW 248
4912: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4913: LD_INT 0
4915: PPUSH
4916: LD_INT 1
4918: PPUSH
4919: LD_VAR 0 1
4923: PPUSH
4924: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 2
4937: PPUSH
4938: CALL_OW 254
4942: PUSH
4943: LD_INT 3
4945: MINUS
4946: ST_TO_ADDR
// if dir < 0 then
4947: LD_VAR 0 5
4951: PUSH
4952: LD_INT 0
4954: LESS
4955: IFFALSE 4971
// dir := 6 + dir ;
4957: LD_ADDR_VAR 0 5
4961: PUSH
4962: LD_INT 6
4964: PUSH
4965: LD_VAR 0 5
4969: PLUS
4970: ST_TO_ADDR
// un := CreateHuman ;
4971: LD_ADDR_VAR 0 4
4975: PUSH
4976: CALL_OW 44
4980: ST_TO_ADDR
// SetDir ( un , dir ) ;
4981: LD_VAR 0 4
4985: PPUSH
4986: LD_VAR 0 5
4990: PPUSH
4991: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4995: LD_VAR 0 4
4999: PPUSH
5000: LD_VAR 0 2
5004: PPUSH
5005: CALL_OW 52
// end ;
5009: LD_VAR 0 3
5013: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
5014: LD_INT 0
5016: PPUSH
5017: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
5018: LD_ADDR_VAR 0 2
5022: PUSH
5023: LD_VAR 0 1
5027: PPUSH
5028: LD_INT 1
5030: PPUSH
5031: CALL_OW 289
5035: PUSH
5036: LD_VAR 0 1
5040: PPUSH
5041: LD_INT 2
5043: PPUSH
5044: CALL_OW 289
5048: PUSH
5049: LD_VAR 0 1
5053: PPUSH
5054: LD_INT 3
5056: PPUSH
5057: CALL_OW 289
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: LIST
5066: ST_TO_ADDR
// end ;
5067: LD_VAR 0 2
5071: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
5072: LD_INT 0
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
// r := 100 ;
5078: LD_ADDR_VAR 0 5
5082: PUSH
5083: LD_INT 100
5085: ST_TO_ADDR
// x := 0 ;
5086: LD_ADDR_VAR 0 6
5090: PUSH
5091: LD_INT 0
5093: ST_TO_ADDR
// while ( x < n ) do
5094: LD_VAR 0 6
5098: PUSH
5099: LD_VAR 0 2
5103: LESS
5104: IFFALSE 5417
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
5106: LD_ADDR_VAR 0 4
5110: PUSH
5111: DOUBLE
5112: LD_INT 1
5114: DEC
5115: ST_TO_ADDR
5116: LD_VAR 0 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 517
5128: PUSH
5129: LD_INT 1
5131: ARRAY
5132: PUSH
5133: FOR_TO
5134: IFFALSE 5413
// begin if r > 50 then
5136: LD_VAR 0 5
5140: PUSH
5141: LD_INT 50
5143: GREATER
5144: IFFALSE 5389
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
5146: LD_VAR 0 1
5150: PPUSH
5151: LD_INT 0
5153: PPUSH
5154: CALL_OW 517
5158: PUSH
5159: LD_INT 1
5161: ARRAY
5162: PUSH
5163: LD_VAR 0 4
5167: ARRAY
5168: PPUSH
5169: LD_VAR 0 1
5173: PPUSH
5174: LD_INT 0
5176: PPUSH
5177: CALL_OW 517
5181: PUSH
5182: LD_INT 2
5184: ARRAY
5185: PUSH
5186: LD_VAR 0 4
5190: ARRAY
5191: PPUSH
5192: CALL_OW 458
5196: NOT
5197: IFFALSE 5373
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , 2 , 0 ) ;
5199: LD_VAR 0 1
5203: PPUSH
5204: LD_INT 0
5206: PPUSH
5207: CALL_OW 517
5211: PUSH
5212: LD_INT 1
5214: ARRAY
5215: PUSH
5216: LD_VAR 0 4
5220: ARRAY
5221: PPUSH
5222: LD_VAR 0 1
5226: PPUSH
5227: LD_INT 0
5229: PPUSH
5230: CALL_OW 517
5234: PUSH
5235: LD_INT 2
5237: ARRAY
5238: PUSH
5239: LD_VAR 0 4
5243: ARRAY
5244: PPUSH
5245: LD_INT 2
5247: PPUSH
5248: LD_INT 0
5250: PPUSH
5251: CALL_OW 454
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
5255: LD_ADDR_EXP 4
5259: PUSH
5260: LD_EXP 4
5264: PPUSH
5265: LD_EXP 4
5269: PUSH
5270: LD_INT 1
5272: PLUS
5273: PPUSH
5274: LD_VAR 0 1
5278: PPUSH
5279: LD_INT 0
5281: PPUSH
5282: CALL_OW 517
5286: PUSH
5287: LD_INT 1
5289: ARRAY
5290: PUSH
5291: LD_VAR 0 4
5295: ARRAY
5296: PPUSH
5297: CALL_OW 2
5301: ST_TO_ADDR
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
5302: LD_ADDR_EXP 4
5306: PUSH
5307: LD_EXP 4
5311: PPUSH
5312: LD_EXP 4
5316: PUSH
5317: LD_INT 1
5319: PLUS
5320: PPUSH
5321: LD_VAR 0 1
5325: PPUSH
5326: LD_INT 0
5328: PPUSH
5329: CALL_OW 517
5333: PUSH
5334: LD_INT 2
5336: ARRAY
5337: PUSH
5338: LD_VAR 0 4
5342: ARRAY
5343: PPUSH
5344: CALL_OW 2
5348: ST_TO_ADDR
// r := 0 ;
5349: LD_ADDR_VAR 0 5
5353: PUSH
5354: LD_INT 0
5356: ST_TO_ADDR
// x := x + 1 ;
5357: LD_ADDR_VAR 0 6
5361: PUSH
5362: LD_VAR 0 6
5366: PUSH
5367: LD_INT 1
5369: PLUS
5370: ST_TO_ADDR
// end else
5371: GO 5387
// r := r + 35 ;
5373: LD_ADDR_VAR 0 5
5377: PUSH
5378: LD_VAR 0 5
5382: PUSH
5383: LD_INT 35
5385: PLUS
5386: ST_TO_ADDR
// end else
5387: GO 5411
// r := r + rand ( 10 , 25 ) ;
5389: LD_ADDR_VAR 0 5
5393: PUSH
5394: LD_VAR 0 5
5398: PUSH
5399: LD_INT 10
5401: PPUSH
5402: LD_INT 25
5404: PPUSH
5405: CALL_OW 12
5409: PLUS
5410: ST_TO_ADDR
// end ;
5411: GO 5133
5413: POP
5414: POP
5415: GO 5094
// end ;
5417: LD_VAR 0 3
5421: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
5422: LD_INT 0
5424: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
5425: LD_ADDR_VAR 0 4
5429: PUSH
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 250
5439: PPUSH
5440: LD_VAR 0 1
5444: PPUSH
5445: CALL_OW 251
5449: PPUSH
5450: LD_VAR 0 2
5454: PPUSH
5455: LD_VAR 0 3
5459: PPUSH
5460: CALL 5470 0 4
5464: ST_TO_ADDR
// end ;
5465: LD_VAR 0 4
5469: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
5470: LD_INT 0
5472: PPUSH
5473: PPUSH
5474: PPUSH
5475: PPUSH
// if not list then
5476: LD_VAR 0 3
5480: NOT
5481: IFFALSE 5485
// exit ;
5483: GO 5793
// result := [ ] ;
5485: LD_ADDR_VAR 0 5
5489: PUSH
5490: EMPTY
5491: ST_TO_ADDR
// for i in list do
5492: LD_ADDR_VAR 0 6
5496: PUSH
5497: LD_VAR 0 3
5501: PUSH
5502: FOR_IN
5503: IFFALSE 5705
// begin tmp := GetDistUnitXY ( i , x , y ) ;
5505: LD_ADDR_VAR 0 8
5509: PUSH
5510: LD_VAR 0 6
5514: PPUSH
5515: LD_VAR 0 1
5519: PPUSH
5520: LD_VAR 0 2
5524: PPUSH
5525: CALL_OW 297
5529: ST_TO_ADDR
// if not result then
5530: LD_VAR 0 5
5534: NOT
5535: IFFALSE 5561
// result := [ [ i , tmp ] ] else
5537: LD_ADDR_VAR 0 5
5541: PUSH
5542: LD_VAR 0 6
5546: PUSH
5547: LD_VAR 0 8
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: ST_TO_ADDR
5559: GO 5703
// begin if result [ result ] [ 2 ] < tmp then
5561: LD_VAR 0 5
5565: PUSH
5566: LD_VAR 0 5
5570: ARRAY
5571: PUSH
5572: LD_INT 2
5574: ARRAY
5575: PUSH
5576: LD_VAR 0 8
5580: LESS
5581: IFFALSE 5623
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
5583: LD_ADDR_VAR 0 5
5587: PUSH
5588: LD_VAR 0 5
5592: PPUSH
5593: LD_VAR 0 5
5597: PUSH
5598: LD_INT 1
5600: PLUS
5601: PPUSH
5602: LD_VAR 0 6
5606: PUSH
5607: LD_VAR 0 8
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PPUSH
5616: CALL_OW 2
5620: ST_TO_ADDR
5621: GO 5703
// for j = 1 to result do
5623: LD_ADDR_VAR 0 7
5627: PUSH
5628: DOUBLE
5629: LD_INT 1
5631: DEC
5632: ST_TO_ADDR
5633: LD_VAR 0 5
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5701
// begin if tmp < result [ j ] [ 2 ] then
5641: LD_VAR 0 8
5645: PUSH
5646: LD_VAR 0 5
5650: PUSH
5651: LD_VAR 0 7
5655: ARRAY
5656: PUSH
5657: LD_INT 2
5659: ARRAY
5660: LESS
5661: IFFALSE 5699
// begin result := Insert ( result , j , [ i , tmp ] ) ;
5663: LD_ADDR_VAR 0 5
5667: PUSH
5668: LD_VAR 0 5
5672: PPUSH
5673: LD_VAR 0 7
5677: PPUSH
5678: LD_VAR 0 6
5682: PUSH
5683: LD_VAR 0 8
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: PPUSH
5692: CALL_OW 2
5696: ST_TO_ADDR
// break ;
5697: GO 5701
// end ; end ;
5699: GO 5638
5701: POP
5702: POP
// end ; end ;
5703: GO 5502
5705: POP
5706: POP
// if result and not asc then
5707: LD_VAR 0 5
5711: PUSH
5712: LD_VAR 0 4
5716: NOT
5717: AND
5718: IFFALSE 5793
// begin tmp := result ;
5720: LD_ADDR_VAR 0 8
5724: PUSH
5725: LD_VAR 0 5
5729: ST_TO_ADDR
// for i = tmp downto 1 do
5730: LD_ADDR_VAR 0 6
5734: PUSH
5735: DOUBLE
5736: LD_VAR 0 8
5740: INC
5741: ST_TO_ADDR
5742: LD_INT 1
5744: PUSH
5745: FOR_DOWNTO
5746: IFFALSE 5791
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
5748: LD_ADDR_VAR 0 5
5752: PUSH
5753: LD_VAR 0 5
5757: PPUSH
5758: LD_VAR 0 8
5762: PUSH
5763: LD_VAR 0 6
5767: MINUS
5768: PUSH
5769: LD_INT 1
5771: PLUS
5772: PPUSH
5773: LD_VAR 0 8
5777: PUSH
5778: LD_VAR 0 6
5782: ARRAY
5783: PPUSH
5784: CALL_OW 1
5788: ST_TO_ADDR
5789: GO 5745
5791: POP
5792: POP
// end ; end ; end_of_file
5793: LD_VAR 0 5
5797: RET
// on UnitDestroyed ( un ) do var i ;
5798: LD_INT 0
5800: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5801: LD_VAR 0 1
5805: PPUSH
5806: CALL_OW 255
5810: PUSH
5811: LD_INT 3
5813: EQUAL
5814: PUSH
5815: LD_VAR 0 1
5819: PPUSH
5820: CALL_OW 247
5824: PUSH
5825: LD_INT 3
5827: EQUAL
5828: AND
5829: IFFALSE 6521
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5831: LD_VAR 0 1
5835: PPUSH
5836: CALL_OW 266
5840: PUSH
5841: LD_INT 31
5843: EQUAL
5844: PUSH
5845: LD_VAR 0 1
5849: PPUSH
5850: CALL_OW 266
5854: PUSH
5855: LD_INT 32
5857: EQUAL
5858: OR
5859: PUSH
5860: LD_VAR 0 1
5864: PPUSH
5865: CALL_OW 266
5869: PUSH
5870: LD_INT 36
5872: EQUAL
5873: OR
5874: PUSH
5875: LD_VAR 0 1
5879: PPUSH
5880: CALL_OW 266
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: OR
5889: PUSH
5890: LD_VAR 0 1
5894: PPUSH
5895: CALL_OW 266
5899: PUSH
5900: LD_INT 24
5902: EQUAL
5903: OR
5904: PUSH
5905: LD_VAR 0 1
5909: PPUSH
5910: CALL_OW 266
5914: PUSH
5915: LD_INT 17
5917: EQUAL
5918: OR
5919: PUSH
5920: LD_VAR 0 1
5924: PPUSH
5925: CALL_OW 266
5929: PUSH
5930: LD_INT 25
5932: EQUAL
5933: OR
5934: PUSH
5935: LD_VAR 0 1
5939: PPUSH
5940: CALL_OW 266
5944: PUSH
5945: LD_INT 19
5947: EQUAL
5948: OR
5949: PUSH
5950: LD_VAR 0 1
5954: PPUSH
5955: CALL_OW 266
5959: PUSH
5960: LD_INT 20
5962: EQUAL
5963: OR
5964: PUSH
5965: LD_VAR 0 1
5969: PPUSH
5970: CALL_OW 266
5974: PUSH
5975: LD_INT 18
5977: EQUAL
5978: OR
5979: PUSH
5980: LD_VAR 0 1
5984: PPUSH
5985: CALL_OW 266
5989: PUSH
5990: LD_INT 21
5992: EQUAL
5993: OR
5994: PUSH
5995: LD_VAR 0 1
5999: PPUSH
6000: CALL_OW 266
6004: PUSH
6005: LD_INT 23
6007: EQUAL
6008: OR
6009: PUSH
6010: LD_VAR 0 1
6014: PPUSH
6015: CALL_OW 266
6019: PUSH
6020: LD_INT 16
6022: EQUAL
6023: OR
6024: PUSH
6025: LD_VAR 0 1
6029: PPUSH
6030: CALL_OW 266
6034: PUSH
6035: LD_INT 6
6037: EQUAL
6038: OR
6039: PUSH
6040: LD_VAR 0 1
6044: PPUSH
6045: CALL_OW 266
6049: PUSH
6050: LD_INT 29
6052: EQUAL
6053: OR
6054: PUSH
6055: LD_VAR 0 1
6059: PPUSH
6060: CALL_OW 266
6064: PUSH
6065: LD_INT 26
6067: EQUAL
6068: OR
6069: PUSH
6070: LD_VAR 0 1
6074: PPUSH
6075: CALL_OW 266
6079: PUSH
6080: LD_INT 30
6082: EQUAL
6083: OR
6084: PUSH
6085: LD_VAR 0 1
6089: PPUSH
6090: CALL_OW 266
6094: PUSH
6095: LD_INT 28
6097: EQUAL
6098: OR
6099: PUSH
6100: LD_VAR 0 1
6104: PPUSH
6105: CALL_OW 266
6109: PUSH
6110: LD_INT 27
6112: EQUAL
6113: OR
6114: PUSH
6115: LD_VAR 0 1
6119: PPUSH
6120: CALL_OW 266
6124: PUSH
6125: LD_INT 33
6127: EQUAL
6128: OR
6129: PUSH
6130: LD_VAR 0 1
6134: PPUSH
6135: CALL_OW 266
6139: PUSH
6140: LD_INT 2
6142: EQUAL
6143: OR
6144: PUSH
6145: LD_VAR 0 1
6149: PPUSH
6150: CALL_OW 266
6154: PUSH
6155: LD_INT 4
6157: EQUAL
6158: OR
6159: IFFALSE 6245
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
6161: LD_ADDR_EXP 1
6165: PUSH
6166: LD_EXP 1
6170: PUSH
6171: LD_VAR 0 1
6175: PPUSH
6176: CALL_OW 266
6180: ADD
6181: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6182: LD_ADDR_EXP 1
6186: PUSH
6187: LD_EXP 1
6191: PUSH
6192: LD_VAR 0 1
6196: PPUSH
6197: CALL_OW 250
6201: ADD
6202: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6203: LD_ADDR_EXP 1
6207: PUSH
6208: LD_EXP 1
6212: PUSH
6213: LD_VAR 0 1
6217: PPUSH
6218: CALL_OW 251
6222: ADD
6223: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6224: LD_ADDR_EXP 1
6228: PUSH
6229: LD_EXP 1
6233: PUSH
6234: LD_VAR 0 1
6238: PPUSH
6239: CALL_OW 254
6243: ADD
6244: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
6245: LD_VAR 0 1
6249: PPUSH
6250: CALL_OW 266
6254: PUSH
6255: LD_INT 1
6257: EQUAL
6258: IFFALSE 6337
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
6260: LD_ADDR_EXP 1
6264: PUSH
6265: LD_EXP 1
6269: PUSH
6270: LD_INT 0
6272: ADD
6273: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6274: LD_ADDR_EXP 1
6278: PUSH
6279: LD_EXP 1
6283: PUSH
6284: LD_VAR 0 1
6288: PPUSH
6289: CALL_OW 250
6293: ADD
6294: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6295: LD_ADDR_EXP 1
6299: PUSH
6300: LD_EXP 1
6304: PUSH
6305: LD_VAR 0 1
6309: PPUSH
6310: CALL_OW 251
6314: ADD
6315: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6316: LD_ADDR_EXP 1
6320: PUSH
6321: LD_EXP 1
6325: PUSH
6326: LD_VAR 0 1
6330: PPUSH
6331: CALL_OW 254
6335: ADD
6336: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
6337: LD_VAR 0 1
6341: PPUSH
6342: CALL_OW 266
6346: PUSH
6347: LD_INT 3
6349: EQUAL
6350: IFFALSE 6429
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
6352: LD_ADDR_EXP 1
6356: PUSH
6357: LD_EXP 1
6361: PUSH
6362: LD_INT 2
6364: ADD
6365: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6366: LD_ADDR_EXP 1
6370: PUSH
6371: LD_EXP 1
6375: PUSH
6376: LD_VAR 0 1
6380: PPUSH
6381: CALL_OW 250
6385: ADD
6386: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6387: LD_ADDR_EXP 1
6391: PUSH
6392: LD_EXP 1
6396: PUSH
6397: LD_VAR 0 1
6401: PPUSH
6402: CALL_OW 251
6406: ADD
6407: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6408: LD_ADDR_EXP 1
6412: PUSH
6413: LD_EXP 1
6417: PUSH
6418: LD_VAR 0 1
6422: PPUSH
6423: CALL_OW 254
6427: ADD
6428: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
6429: LD_VAR 0 1
6433: PPUSH
6434: CALL_OW 266
6438: PUSH
6439: LD_INT 5
6441: EQUAL
6442: IFFALSE 6521
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
6444: LD_ADDR_EXP 1
6448: PUSH
6449: LD_EXP 1
6453: PUSH
6454: LD_INT 4
6456: ADD
6457: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6458: LD_ADDR_EXP 1
6462: PUSH
6463: LD_EXP 1
6467: PUSH
6468: LD_VAR 0 1
6472: PPUSH
6473: CALL_OW 250
6477: ADD
6478: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6479: LD_ADDR_EXP 1
6483: PUSH
6484: LD_EXP 1
6488: PUSH
6489: LD_VAR 0 1
6493: PPUSH
6494: CALL_OW 251
6498: ADD
6499: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6500: LD_ADDR_EXP 1
6504: PUSH
6505: LD_EXP 1
6509: PUSH
6510: LD_VAR 0 1
6514: PPUSH
6515: CALL_OW 254
6519: ADD
6520: ST_TO_ADDR
// end ; end ; end ;
6521: PPOPN 2
6523: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6524: LD_VAR 0 1
6528: PPUSH
6529: CALL_OW 255
6533: PUSH
6534: LD_INT 3
6536: EQUAL
6537: IFFALSE 6611
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6539: LD_ADDR_EXP 1
6543: PUSH
6544: LD_EXP 1
6548: PPUSH
6549: LD_INT 1
6551: PPUSH
6552: CALL_OW 3
6556: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6557: LD_ADDR_EXP 1
6561: PUSH
6562: LD_EXP 1
6566: PPUSH
6567: LD_INT 1
6569: PPUSH
6570: CALL_OW 3
6574: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6575: LD_ADDR_EXP 1
6579: PUSH
6580: LD_EXP 1
6584: PPUSH
6585: LD_INT 1
6587: PPUSH
6588: CALL_OW 3
6592: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6593: LD_ADDR_EXP 1
6597: PUSH
6598: LD_EXP 1
6602: PPUSH
6603: LD_INT 1
6605: PPUSH
6606: CALL_OW 3
6610: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6611: LD_VAR 0 1
6615: PPUSH
6616: CALL_OW 255
6620: PUSH
6621: LD_INT 3
6623: EQUAL
6624: PUSH
6625: LD_VAR 0 1
6629: PPUSH
6630: CALL_OW 266
6634: PUSH
6635: LD_INT 0
6637: EQUAL
6638: PUSH
6639: LD_VAR 0 1
6643: PPUSH
6644: CALL_OW 266
6648: PUSH
6649: LD_INT 2
6651: EQUAL
6652: OR
6653: PUSH
6654: LD_VAR 0 1
6658: PPUSH
6659: CALL_OW 266
6663: PUSH
6664: LD_INT 4
6666: EQUAL
6667: OR
6668: PUSH
6669: EMPTY
6670: LIST
6671: AND
6672: IFFALSE 6683
// ComUpgrade ( building ) ;
6674: LD_VAR 0 1
6678: PPUSH
6679: CALL_OW 146
// end ;
6683: PPOPN 1
6685: END
// on LeaveVehicle ( vehicle , human ) do begin ComRepairVehicle ( human , vehicle ) ;
6686: LD_VAR 0 2
6690: PPUSH
6691: LD_VAR 0 1
6695: PPUSH
6696: CALL_OW 129
// AddComEnterUnit ( human , vehicle ) ;
6700: LD_VAR 0 2
6704: PPUSH
6705: LD_VAR 0 1
6709: PPUSH
6710: CALL_OW 180
// end ;
6714: PPOPN 2
6716: END
// on VehicleConstructed ( vehicle , building ) do begin end ;
6717: PPOPN 2
6719: END
// on Command ( command_id ) do begin end ;
6720: PPOPN 1
6722: END
