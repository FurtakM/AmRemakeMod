// export destroyedBuildings ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// end ;
  22: END
// every 0 0$1 do
  23: GO 25
  25: DISABLE
// ComEnterUnit ( eng1 , ee1 ) ; end_of_file
  26: LD_INT 95
  28: PPUSH
  29: LD_INT 94
  31: PPUSH
  32: CALL_OW 120
  36: END
// every 0 0$1 do
  37: GO 39
  39: DISABLE
// begin enable ;
  40: ENABLE
// RepairVehicle ( 3 , EnemyVehSpawn , 89 , 7 ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 2
  46: PPUSH
  47: LD_INT 89
  49: PPUSH
  50: LD_INT 7
  52: PPUSH
  53: CALL 2603 0 4
// RebuildBuildings ( 3 , destroyedBuildings ) ;
  57: LD_INT 3
  59: PPUSH
  60: LD_EXP 1
  64: PPUSH
  65: CALL 3341 0 2
// EnemyVehicleAttack ( 3 , 1 ) ;
  69: LD_INT 3
  71: PPUSH
  72: LD_INT 1
  74: PPUSH
  75: CALL 2245 0 2
// IntBazooka ( 3 , 1 ) ;
  79: LD_INT 3
  81: PPUSH
  82: LD_INT 1
  84: PPUSH
  85: CALL 3777 0 2
// end ;
  89: END
// every 5 5$1 do
  90: GO 92
  92: DISABLE
// begin BuildingVehicleAndAttackEnemy ( 3 , rufab , 4 , [ 42 ] , 1 , 1 , 23 ) ;
  93: LD_INT 3
  95: PPUSH
  96: LD_INT 30
  98: PPUSH
  99: LD_INT 4
 101: PPUSH
 102: LD_INT 42
 104: PUSH
 105: EMPTY
 106: LIST
 107: PPUSH
 108: LD_INT 1
 110: PPUSH
 111: LD_INT 1
 113: PPUSH
 114: LD_INT 23
 116: PPUSH
 117: CALL 2133 0 7
// end ; end_of_file
 121: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 122: LD_INT 0
 124: PPUSH
 125: PPUSH
 126: PPUSH
// rnd = rand ( 1 , characters ) ;
 127: LD_ADDR_VAR 0 6
 131: PUSH
 132: LD_INT 1
 134: PPUSH
 135: LD_VAR 0 1
 139: PPUSH
 140: CALL_OW 12
 144: ST_TO_ADDR
// for i = 1 to characters do
 145: LD_ADDR_VAR 0 5
 149: PUSH
 150: DOUBLE
 151: LD_INT 1
 153: DEC
 154: ST_TO_ADDR
 155: LD_VAR 0 1
 159: PUSH
 160: FOR_TO
 161: IFFALSE 271
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 163: LD_VAR 0 5
 167: PUSH
 168: LD_VAR 0 6
 172: EQUAL
 173: PUSH
 174: LD_VAR 0 1
 178: PUSH
 179: LD_VAR 0 5
 183: ARRAY
 184: PPUSH
 185: CALL_OW 258
 189: PUSH
 190: LD_INT 1
 192: EQUAL
 193: AND
 194: IFFALSE 216
// Say ( characters [ i ] , dialogMID ) ;
 196: LD_VAR 0 1
 200: PUSH
 201: LD_VAR 0 5
 205: ARRAY
 206: PPUSH
 207: LD_VAR 0 2
 211: PPUSH
 212: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 216: LD_VAR 0 5
 220: PUSH
 221: LD_VAR 0 6
 225: EQUAL
 226: PUSH
 227: LD_VAR 0 1
 231: PUSH
 232: LD_VAR 0 5
 236: ARRAY
 237: PPUSH
 238: CALL_OW 258
 242: PUSH
 243: LD_INT 2
 245: EQUAL
 246: AND
 247: IFFALSE 269
// Say ( characters [ i ] , dialogFID ) ;
 249: LD_VAR 0 1
 253: PUSH
 254: LD_VAR 0 5
 258: ARRAY
 259: PPUSH
 260: LD_VAR 0 3
 264: PPUSH
 265: CALL_OW 88
// end ;
 269: GO 160
 271: POP
 272: POP
// end ;
 273: LD_VAR 0 4
 277: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 278: LD_INT 0
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
// for i = 1 to count do
 284: LD_ADDR_VAR 0 8
 288: PUSH
 289: DOUBLE
 290: LD_INT 1
 292: DEC
 293: ST_TO_ADDR
 294: LD_VAR 0 6
 298: PUSH
 299: FOR_TO
 300: IFFALSE 381
// begin uc_side = side ;
 302: LD_ADDR_OWVAR 20
 306: PUSH
 307: LD_VAR 0 1
 311: ST_TO_ADDR
// uc_nation = nation ;
 312: LD_ADDR_OWVAR 21
 316: PUSH
 317: LD_VAR 0 2
 321: ST_TO_ADDR
// hc_gallery =  ;
 322: LD_ADDR_OWVAR 33
 326: PUSH
 327: LD_STRING 
 329: ST_TO_ADDR
// hc_name =  ;
 330: LD_ADDR_OWVAR 26
 334: PUSH
 335: LD_STRING 
 337: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 338: LD_INT 0
 340: PPUSH
 341: LD_VAR 0 5
 345: PPUSH
 346: LD_VAR 0 4
 350: PPUSH
 351: CALL_OW 380
// un = CreateHuman ;
 355: LD_ADDR_VAR 0 10
 359: PUSH
 360: CALL_OW 44
 364: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 365: LD_VAR 0 10
 369: PPUSH
 370: LD_VAR 0 3
 374: PPUSH
 375: CALL_OW 52
// end ;
 379: GO 299
 381: POP
 382: POP
// end ;
 383: LD_VAR 0 7
 387: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 388: LD_INT 0
 390: PPUSH
 391: PPUSH
// for i in charactersList do
 392: LD_ADDR_VAR 0 4
 396: PUSH
 397: LD_VAR 0 1
 401: PUSH
 402: FOR_IN
 403: IFFALSE 443
// begin if IsOk ( i ) then
 405: LD_VAR 0 4
 409: PPUSH
 410: CALL_OW 302
 414: IFFALSE 432
// begin SaveCharacters ( i , ident ) ;
 416: LD_VAR 0 4
 420: PPUSH
 421: LD_VAR 0 2
 425: PPUSH
 426: CALL_OW 38
// end else
 430: GO 441
// begin DeleteCharacters ( ident ) ;
 432: LD_VAR 0 2
 436: PPUSH
 437: CALL_OW 40
// end ; end ;
 441: GO 402
 443: POP
 444: POP
// end ;
 445: LD_VAR 0 3
 449: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 450: LD_INT 0
 452: PPUSH
 453: PPUSH
 454: PPUSH
 455: PPUSH
 456: PPUSH
 457: PPUSH
 458: PPUSH
 459: PPUSH
 460: PPUSH
 461: PPUSH
 462: PPUSH
// amChassisTab = [ ] ;
 463: LD_ADDR_VAR 0 19
 467: PUSH
 468: EMPTY
 469: ST_TO_ADDR
// arChassisTab = [ ] ;
 470: LD_ADDR_VAR 0 18
 474: PUSH
 475: EMPTY
 476: ST_TO_ADDR
// ruChassisTab = [ ] ;
 477: LD_ADDR_VAR 0 17
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 484: LD_INT 35
 486: PPUSH
 487: CALL_OW 67
// if nation = 1 then
 491: LD_VAR 0 5
 495: PUSH
 496: LD_INT 1
 498: EQUAL
 499: IFFALSE 990
// begin uc_side = side ;
 501: LD_ADDR_OWVAR 20
 505: PUSH
 506: LD_VAR 0 2
 510: ST_TO_ADDR
// uc_nation = nation ;
 511: LD_ADDR_OWVAR 21
 515: PUSH
 516: LD_VAR 0 5
 520: ST_TO_ADDR
// vc_engine = vehengine ;
 521: LD_ADDR_OWVAR 39
 525: PUSH
 526: LD_VAR 0 6
 530: ST_TO_ADDR
// vc_control = vehcontrol ;
 531: LD_ADDR_OWVAR 38
 535: PUSH
 536: LD_VAR 0 7
 540: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 541: LD_ADDR_OWVAR 40
 545: PUSH
 546: LD_VAR 0 10
 550: PUSH
 551: LD_INT 1
 553: PPUSH
 554: LD_VAR 0 10
 558: PPUSH
 559: CALL_OW 12
 563: ARRAY
 564: ST_TO_ADDR
// for j = 1 to AMWeapon do
 565: LD_ADDR_VAR 0 14
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 10
 579: PUSH
 580: FOR_TO
 581: IFFALSE 882
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 583: LD_VAR 0 10
 587: PUSH
 588: LD_VAR 0 14
 592: ARRAY
 593: PUSH
 594: LD_INT 2
 596: EQUAL
 597: PUSH
 598: LD_VAR 0 10
 602: PUSH
 603: LD_VAR 0 14
 607: ARRAY
 608: PUSH
 609: LD_INT 3
 611: EQUAL
 612: OR
 613: IFFALSE 666
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 615: LD_ADDR_VAR 0 19
 619: PUSH
 620: LD_INT 1
 622: PUSH
 623: LD_INT 2
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 4
 631: PUSH
 632: LD_INT 5
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 642: LD_ADDR_OWVAR 37
 646: PUSH
 647: LD_VAR 0 19
 651: PUSH
 652: LD_INT 1
 654: PPUSH
 655: LD_VAR 0 19
 659: PPUSH
 660: CALL_OW 12
 664: ARRAY
 665: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 666: LD_VAR 0 10
 670: PUSH
 671: LD_VAR 0 14
 675: ARRAY
 676: PUSH
 677: LD_INT 4
 679: EQUAL
 680: PUSH
 681: LD_VAR 0 10
 685: PUSH
 686: LD_VAR 0 14
 690: ARRAY
 691: PUSH
 692: LD_INT 5
 694: EQUAL
 695: OR
 696: PUSH
 697: LD_VAR 0 10
 701: PUSH
 702: LD_VAR 0 14
 706: ARRAY
 707: PUSH
 708: LD_INT 9
 710: EQUAL
 711: OR
 712: PUSH
 713: LD_VAR 0 10
 717: PUSH
 718: LD_VAR 0 14
 722: ARRAY
 723: PUSH
 724: LD_INT 11
 726: EQUAL
 727: OR
 728: PUSH
 729: LD_VAR 0 10
 733: PUSH
 734: LD_VAR 0 14
 738: ARRAY
 739: PUSH
 740: LD_INT 7
 742: EQUAL
 743: OR
 744: IFFALSE 793
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
 746: LD_ADDR_VAR 0 19
 750: PUSH
 751: LD_INT 2
 753: PUSH
 754: LD_INT 3
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 5
 762: PUSH
 763: EMPTY
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 769: LD_ADDR_OWVAR 37
 773: PUSH
 774: LD_VAR 0 19
 778: PUSH
 779: LD_INT 1
 781: PPUSH
 782: LD_VAR 0 19
 786: PPUSH
 787: CALL_OW 12
 791: ARRAY
 792: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
 793: LD_VAR 0 10
 797: PUSH
 798: LD_VAR 0 14
 802: ARRAY
 803: PUSH
 804: LD_INT 8
 806: EQUAL
 807: PUSH
 808: LD_VAR 0 10
 812: PUSH
 813: LD_VAR 0 14
 817: ARRAY
 818: PUSH
 819: LD_INT 6
 821: EQUAL
 822: OR
 823: PUSH
 824: LD_VAR 0 10
 828: PUSH
 829: LD_VAR 0 14
 833: ARRAY
 834: PUSH
 835: LD_INT 10
 837: EQUAL
 838: OR
 839: IFFALSE 880
// begin amChassisTab = [ 4 , 5 ] ;
 841: LD_ADDR_VAR 0 19
 845: PUSH
 846: LD_INT 4
 848: PUSH
 849: LD_INT 5
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 856: LD_ADDR_OWVAR 37
 860: PUSH
 861: LD_VAR 0 19
 865: PUSH
 866: LD_INT 1
 868: PPUSH
 869: LD_VAR 0 19
 873: PPUSH
 874: CALL_OW 12
 878: ARRAY
 879: ST_TO_ADDR
// end ; end ;
 880: GO 580
 882: POP
 883: POP
// veh = CreateVehicle ;
 884: LD_ADDR_VAR 0 16
 888: PUSH
 889: CALL_OW 45
 893: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
 894: LD_VAR 0 16
 898: PPUSH
 899: LD_VAR 0 1
 903: PPUSH
 904: LD_INT 0
 906: PPUSH
 907: CALL_OW 49
// if vehControl = 1 then
 911: LD_VAR 0 7
 915: PUSH
 916: LD_INT 1
 918: EQUAL
 919: IFFALSE 976
// begin hc_gallery =  ;
 921: LD_ADDR_OWVAR 33
 925: PUSH
 926: LD_STRING 
 928: ST_TO_ADDR
// hc_name =  ;
 929: LD_ADDR_OWVAR 26
 933: PUSH
 934: LD_STRING 
 936: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
 937: LD_INT 0
 939: PPUSH
 940: LD_INT 3
 942: PPUSH
 943: LD_VAR 0 4
 947: PPUSH
 948: CALL_OW 380
// un = CreateHuman ;
 952: LD_ADDR_VAR 0 15
 956: PUSH
 957: CALL_OW 44
 961: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
 962: LD_VAR 0 15
 966: PPUSH
 967: LD_VAR 0 16
 971: PPUSH
 972: CALL_OW 52
// end ; i = i + 1 ;
 976: LD_ADDR_VAR 0 13
 980: PUSH
 981: LD_VAR 0 13
 985: PUSH
 986: LD_INT 1
 988: PLUS
 989: ST_TO_ADDR
// end ; if nation = 2 then
 990: LD_VAR 0 5
 994: PUSH
 995: LD_INT 2
 997: EQUAL
 998: IFFALSE 1422
// begin uc_side = side ;
1000: LD_ADDR_OWVAR 20
1004: PUSH
1005: LD_VAR 0 2
1009: ST_TO_ADDR
// uc_nation = nation ;
1010: LD_ADDR_OWVAR 21
1014: PUSH
1015: LD_VAR 0 5
1019: ST_TO_ADDR
// vc_engine = vehengine ;
1020: LD_ADDR_OWVAR 39
1024: PUSH
1025: LD_VAR 0 6
1029: ST_TO_ADDR
// vc_control = vehcontrol ;
1030: LD_ADDR_OWVAR 38
1034: PUSH
1035: LD_VAR 0 7
1039: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1040: LD_ADDR_OWVAR 40
1044: PUSH
1045: LD_VAR 0 9
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_VAR 0 9
1057: PPUSH
1058: CALL_OW 12
1062: ARRAY
1063: ST_TO_ADDR
// for j = 1 to ARWeapons do
1064: LD_ADDR_VAR 0 14
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 9
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1314
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1082: LD_VAR 0 9
1086: PUSH
1087: LD_VAR 0 14
1091: ARRAY
1092: PUSH
1093: LD_INT 24
1095: EQUAL
1096: PUSH
1097: LD_VAR 0 9
1101: PUSH
1102: LD_VAR 0 14
1106: ARRAY
1107: PUSH
1108: LD_INT 22
1110: EQUAL
1111: OR
1112: PUSH
1113: LD_VAR 0 9
1117: PUSH
1118: LD_VAR 0 14
1122: ARRAY
1123: PUSH
1124: LD_INT 23
1126: EQUAL
1127: OR
1128: PUSH
1129: LD_VAR 0 9
1133: PUSH
1134: LD_VAR 0 14
1138: ARRAY
1139: PUSH
1140: LD_INT 30
1142: EQUAL
1143: OR
1144: IFFALSE 1193
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1146: LD_ADDR_VAR 0 18
1150: PUSH
1151: LD_INT 11
1153: PUSH
1154: LD_INT 12
1156: PUSH
1157: LD_INT 13
1159: PUSH
1160: LD_INT 14
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1169: LD_ADDR_OWVAR 37
1173: PUSH
1174: LD_VAR 0 18
1178: PUSH
1179: LD_INT 1
1181: PPUSH
1182: LD_VAR 0 18
1186: PPUSH
1187: CALL_OW 12
1191: ARRAY
1192: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1193: LD_VAR 0 9
1197: PUSH
1198: LD_VAR 0 14
1202: ARRAY
1203: PUSH
1204: LD_INT 29
1206: EQUAL
1207: PUSH
1208: LD_VAR 0 9
1212: PUSH
1213: LD_VAR 0 14
1217: ARRAY
1218: PUSH
1219: LD_INT 28
1221: EQUAL
1222: OR
1223: PUSH
1224: LD_VAR 0 9
1228: PUSH
1229: LD_VAR 0 14
1233: ARRAY
1234: PUSH
1235: LD_INT 27
1237: EQUAL
1238: OR
1239: PUSH
1240: LD_VAR 0 9
1244: PUSH
1245: LD_VAR 0 14
1249: ARRAY
1250: PUSH
1251: LD_INT 26
1253: EQUAL
1254: OR
1255: PUSH
1256: LD_VAR 0 9
1260: PUSH
1261: LD_VAR 0 14
1265: ARRAY
1266: PUSH
1267: LD_INT 25
1269: EQUAL
1270: OR
1271: IFFALSE 1312
// begin arChassisTab = [ 13 , 14 ] ;
1273: LD_ADDR_VAR 0 18
1277: PUSH
1278: LD_INT 13
1280: PUSH
1281: LD_INT 14
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1288: LD_ADDR_OWVAR 37
1292: PUSH
1293: LD_VAR 0 18
1297: PUSH
1298: LD_INT 1
1300: PPUSH
1301: LD_VAR 0 18
1305: PPUSH
1306: CALL_OW 12
1310: ARRAY
1311: ST_TO_ADDR
// end ; end ;
1312: GO 1079
1314: POP
1315: POP
// veh = CreateVehicle ;
1316: LD_ADDR_VAR 0 16
1320: PUSH
1321: CALL_OW 45
1325: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1326: LD_VAR 0 16
1330: PPUSH
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 0
1338: PPUSH
1339: CALL_OW 49
// if vehcontrol = 1 then
1343: LD_VAR 0 7
1347: PUSH
1348: LD_INT 1
1350: EQUAL
1351: IFFALSE 1408
// begin hc_gallery =  ;
1353: LD_ADDR_OWVAR 33
1357: PUSH
1358: LD_STRING 
1360: ST_TO_ADDR
// hc_name =  ;
1361: LD_ADDR_OWVAR 26
1365: PUSH
1366: LD_STRING 
1368: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1369: LD_INT 0
1371: PPUSH
1372: LD_INT 3
1374: PPUSH
1375: LD_VAR 0 4
1379: PPUSH
1380: CALL_OW 380
// un = CreateHuman ;
1384: LD_ADDR_VAR 0 15
1388: PUSH
1389: CALL_OW 44
1393: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1394: LD_VAR 0 15
1398: PPUSH
1399: LD_VAR 0 16
1403: PPUSH
1404: CALL_OW 52
// end ; i = i + 1 ;
1408: LD_ADDR_VAR 0 13
1412: PUSH
1413: LD_VAR 0 13
1417: PUSH
1418: LD_INT 1
1420: PLUS
1421: ST_TO_ADDR
// end ; if nation = 3 then
1422: LD_VAR 0 5
1426: PUSH
1427: LD_INT 3
1429: EQUAL
1430: IFFALSE 1822
// begin uc_side = side ;
1432: LD_ADDR_OWVAR 20
1436: PUSH
1437: LD_VAR 0 2
1441: ST_TO_ADDR
// uc_nation = nation ;
1442: LD_ADDR_OWVAR 21
1446: PUSH
1447: LD_VAR 0 5
1451: ST_TO_ADDR
// vc_engine = vehengine ;
1452: LD_ADDR_OWVAR 39
1456: PUSH
1457: LD_VAR 0 6
1461: ST_TO_ADDR
// vc_control = vehcontrol ;
1462: LD_ADDR_OWVAR 38
1466: PUSH
1467: LD_VAR 0 7
1471: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1472: LD_ADDR_OWVAR 40
1476: PUSH
1477: LD_VAR 0 8
1481: PUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 8
1489: PPUSH
1490: CALL_OW 12
1494: ARRAY
1495: ST_TO_ADDR
// for j = 1 to RuWeapons do
1496: LD_ADDR_VAR 0 14
1500: PUSH
1501: DOUBLE
1502: LD_INT 1
1504: DEC
1505: ST_TO_ADDR
1506: LD_VAR 0 8
1510: PUSH
1511: FOR_TO
1512: IFFALSE 1714
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1514: LD_VAR 0 8
1518: PUSH
1519: LD_VAR 0 14
1523: ARRAY
1524: PUSH
1525: LD_INT 42
1527: EQUAL
1528: PUSH
1529: LD_VAR 0 8
1533: PUSH
1534: LD_VAR 0 14
1538: ARRAY
1539: PUSH
1540: LD_INT 43
1542: EQUAL
1543: OR
1544: PUSH
1545: LD_VAR 0 8
1549: PUSH
1550: LD_VAR 0 14
1554: ARRAY
1555: PUSH
1556: LD_INT 44
1558: EQUAL
1559: OR
1560: PUSH
1561: LD_VAR 0 8
1565: PUSH
1566: LD_VAR 0 14
1570: ARRAY
1571: PUSH
1572: LD_INT 45
1574: EQUAL
1575: OR
1576: PUSH
1577: LD_VAR 0 8
1581: PUSH
1582: LD_VAR 0 14
1586: ARRAY
1587: PUSH
1588: LD_INT 49
1590: EQUAL
1591: OR
1592: IFFALSE 1641
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1594: LD_ADDR_VAR 0 17
1598: PUSH
1599: LD_INT 21
1601: PUSH
1602: LD_INT 22
1604: PUSH
1605: LD_INT 23
1607: PUSH
1608: LD_INT 24
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1617: LD_ADDR_OWVAR 37
1621: PUSH
1622: LD_VAR 0 17
1626: PUSH
1627: LD_INT 1
1629: PPUSH
1630: LD_VAR 0 17
1634: PPUSH
1635: CALL_OW 12
1639: ARRAY
1640: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1641: LD_VAR 0 8
1645: PUSH
1646: LD_VAR 0 14
1650: ARRAY
1651: PUSH
1652: LD_INT 46
1654: EQUAL
1655: PUSH
1656: LD_VAR 0 8
1660: PUSH
1661: LD_VAR 0 14
1665: ARRAY
1666: PUSH
1667: LD_INT 47
1669: EQUAL
1670: OR
1671: IFFALSE 1712
// begin ruChassisTab = [ 23 , 24 ] ;
1673: LD_ADDR_VAR 0 17
1677: PUSH
1678: LD_INT 23
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1688: LD_ADDR_OWVAR 37
1692: PUSH
1693: LD_VAR 0 17
1697: PUSH
1698: LD_INT 1
1700: PPUSH
1701: LD_VAR 0 17
1705: PPUSH
1706: CALL_OW 12
1710: ARRAY
1711: ST_TO_ADDR
// end ; end ;
1712: GO 1511
1714: POP
1715: POP
// veh = CreateVehicle ;
1716: LD_ADDR_VAR 0 16
1720: PUSH
1721: CALL_OW 45
1725: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1726: LD_VAR 0 16
1730: PPUSH
1731: LD_VAR 0 1
1735: PPUSH
1736: LD_INT 0
1738: PPUSH
1739: CALL_OW 49
// if vehcontrol = 1 then
1743: LD_VAR 0 7
1747: PUSH
1748: LD_INT 1
1750: EQUAL
1751: IFFALSE 1808
// begin hc_gallery =  ;
1753: LD_ADDR_OWVAR 33
1757: PUSH
1758: LD_STRING 
1760: ST_TO_ADDR
// hc_name =  ;
1761: LD_ADDR_OWVAR 26
1765: PUSH
1766: LD_STRING 
1768: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1769: LD_INT 0
1771: PPUSH
1772: LD_INT 3
1774: PPUSH
1775: LD_VAR 0 4
1779: PPUSH
1780: CALL_OW 380
// un = CreateHuman ;
1784: LD_ADDR_VAR 0 15
1788: PUSH
1789: CALL_OW 44
1793: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1794: LD_VAR 0 15
1798: PPUSH
1799: LD_VAR 0 16
1803: PPUSH
1804: CALL_OW 52
// end ; i = i + 1 ;
1808: LD_ADDR_VAR 0 13
1812: PUSH
1813: LD_VAR 0 13
1817: PUSH
1818: LD_INT 1
1820: PLUS
1821: ST_TO_ADDR
// end ; until i = vehCount ;
1822: LD_VAR 0 13
1826: PUSH
1827: LD_VAR 0 3
1831: EQUAL
1832: IFFALSE 484
// repeat wait ( 0 0$1 ) ;
1834: LD_INT 35
1836: PPUSH
1837: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
1841: LD_ADDR_VAR 0 20
1845: PUSH
1846: LD_INT 22
1848: PUSH
1849: LD_VAR 0 2
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: LD_INT 21
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 24
1870: PUSH
1871: LD_INT 650
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: PPUSH
1883: CALL_OW 69
1887: ST_TO_ADDR
// if vehicleOK_list > 0 then
1888: LD_VAR 0 20
1892: PUSH
1893: LD_INT 0
1895: GREATER
1896: IFFALSE 2087
// begin for i in vehicleOK_list do
1898: LD_ADDR_VAR 0 13
1902: PUSH
1903: LD_VAR 0 20
1907: PUSH
1908: FOR_IN
1909: IFFALSE 2085
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
1911: LD_ADDR_VAR 0 21
1915: PUSH
1916: LD_INT 22
1918: PUSH
1919: LD_VAR 0 11
1923: PUSH
1924: EMPTY
1925: LIST
1926: LIST
1927: PPUSH
1928: CALL_OW 69
1932: PPUSH
1933: LD_VAR 0 13
1937: PPUSH
1938: CALL_OW 74
1942: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
1943: LD_ADDR_VAR 0 22
1947: PUSH
1948: LD_INT 22
1950: PUSH
1951: LD_VAR 0 11
1955: PUSH
1956: EMPTY
1957: LIST
1958: LIST
1959: PUSH
1960: LD_INT 2
1962: PUSH
1963: LD_INT 59
1965: PUSH
1966: EMPTY
1967: LIST
1968: PUSH
1969: LD_INT 21
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: PUSH
1979: LD_INT 21
1981: PUSH
1982: LD_INT 2
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: LIST
1993: LIST
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: PUSH
1999: EMPTY
2000: LIST
2001: PPUSH
2002: CALL_OW 69
2006: PPUSH
2007: LD_VAR 0 13
2011: PPUSH
2012: CALL_OW 74
2016: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2017: LD_VAR 0 13
2021: PPUSH
2022: LD_VAR 0 21
2026: PPUSH
2027: CALL_OW 296
2031: PUSH
2032: LD_INT 8
2034: PLUS
2035: PUSH
2036: LD_VAR 0 13
2040: PPUSH
2041: LD_VAR 0 22
2045: PPUSH
2046: CALL_OW 296
2050: LESS
2051: IFFALSE 2069
// begin ComAttackUnit ( i , target1 ) ;
2053: LD_VAR 0 13
2057: PPUSH
2058: LD_VAR 0 21
2062: PPUSH
2063: CALL_OW 115
// end else
2067: GO 2083
// begin ComAttackUnit ( i , target2 ) ;
2069: LD_VAR 0 13
2073: PPUSH
2074: LD_VAR 0 22
2078: PPUSH
2079: CALL_OW 115
// end ; end ;
2083: GO 1908
2085: POP
2086: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2087: LD_INT 22
2089: PUSH
2090: LD_VAR 0 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: PUSH
2099: LD_INT 21
2101: PUSH
2102: LD_INT 2
2104: PUSH
2105: EMPTY
2106: LIST
2107: LIST
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PPUSH
2113: CALL_OW 69
2117: PUSH
2118: LD_INT 0
2120: EQUAL
2121: IFFALSE 1834
// end ;
2123: LD_VAR 0 12
2127: RET
// every 0 0$1 do
2128: GO 2130
2130: DISABLE
// begin enable ;
2131: ENABLE
// end ;
2132: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2133: LD_INT 0
2135: PPUSH
2136: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2137: LD_INT 22
2139: PUSH
2140: LD_VAR 0 1
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: PUSH
2149: LD_INT 21
2151: PUSH
2152: LD_INT 2
2154: PUSH
2155: EMPTY
2156: LIST
2157: LIST
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PPUSH
2163: CALL_OW 69
2167: PUSH
2168: LD_VAR 0 3
2172: LESSEQUAL
2173: IFFALSE 2240
// for i = 1 to vehCount do
2175: LD_ADDR_VAR 0 9
2179: PUSH
2180: DOUBLE
2181: LD_INT 1
2183: DEC
2184: ST_TO_ADDR
2185: LD_VAR 0 3
2189: PUSH
2190: FOR_TO
2191: IFFALSE 2238
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2193: LD_VAR 0 2
2197: PPUSH
2198: LD_VAR 0 7
2202: PPUSH
2203: LD_VAR 0 5
2207: PPUSH
2208: LD_VAR 0 6
2212: PPUSH
2213: LD_VAR 0 4
2217: PUSH
2218: LD_INT 1
2220: PPUSH
2221: LD_VAR 0 4
2225: PPUSH
2226: CALL_OW 12
2230: ARRAY
2231: PPUSH
2232: CALL_OW 185
2236: GO 2190
2238: POP
2239: POP
// end ;
2240: LD_VAR 0 8
2244: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2245: LD_INT 0
2247: PPUSH
2248: PPUSH
2249: PPUSH
2250: PPUSH
2251: PPUSH
// for i := 1 to CPU1Tanks do
2252: LD_ADDR_VAR 0 4
2256: PUSH
2257: DOUBLE
2258: LD_INT 1
2260: DEC
2261: ST_TO_ADDR
2262: LD_EXP 3
2266: PUSH
2267: FOR_TO
2268: IFFALSE 2596
// begin if i = 4 then
2270: LD_VAR 0 4
2274: PUSH
2275: LD_INT 4
2277: EQUAL
2278: IFFALSE 2594
// begin repeat wait ( 0 0$1 ) ;
2280: LD_INT 35
2282: PPUSH
2283: CALL_OW 67
// for i in CPU1Tanks do
2287: LD_ADDR_VAR 0 4
2291: PUSH
2292: LD_EXP 3
2296: PUSH
2297: FOR_IN
2298: IFFALSE 2582
// begin if GetLives ( i ) < 659 then
2300: LD_VAR 0 4
2304: PPUSH
2305: CALL_OW 256
2309: PUSH
2310: LD_INT 659
2312: LESS
2313: IFFALSE 2401
// begin tmp = i ;
2315: LD_ADDR_VAR 0 5
2319: PUSH
2320: LD_VAR 0 4
2324: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2325: LD_ADDR_VAR 0 4
2329: PUSH
2330: DOUBLE
2331: LD_INT 1
2333: DEC
2334: ST_TO_ADDR
2335: LD_EXP 3
2339: PUSH
2340: FOR_TO
2341: IFFALSE 2399
// begin if tmp = CPU1Tanks [ i ] then
2343: LD_VAR 0 5
2347: PUSH
2348: LD_EXP 3
2352: PUSH
2353: LD_VAR 0 4
2357: ARRAY
2358: EQUAL
2359: IFFALSE 2397
// begin CPU1Tanks = Delete ( CPU1Tanks , i ) ;
2361: LD_ADDR_EXP 3
2365: PUSH
2366: LD_EXP 3
2370: PPUSH
2371: LD_VAR 0 4
2375: PPUSH
2376: CALL_OW 3
2380: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2381: LD_ADDR_EXP 4
2385: PUSH
2386: LD_EXP 4
2390: PUSH
2391: LD_VAR 0 5
2395: ADD
2396: ST_TO_ADDR
// end ; end ;
2397: GO 2340
2399: POP
2400: POP
// end ; wait ( 0 0$1 ) ;
2401: LD_INT 35
2403: PPUSH
2404: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2408: LD_ADDR_VAR 0 6
2412: PUSH
2413: LD_INT 22
2415: PUSH
2416: LD_VAR 0 2
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: PPUSH
2425: CALL_OW 69
2429: PPUSH
2430: LD_VAR 0 4
2434: PPUSH
2435: CALL_OW 74
2439: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2440: LD_ADDR_VAR 0 7
2444: PUSH
2445: LD_INT 22
2447: PUSH
2448: LD_VAR 0 2
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: PUSH
2457: LD_INT 2
2459: PUSH
2460: LD_INT 59
2462: PUSH
2463: EMPTY
2464: LIST
2465: PUSH
2466: LD_INT 21
2468: PUSH
2469: LD_INT 1
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: PUSH
2476: LD_INT 21
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: EMPTY
2483: LIST
2484: LIST
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: LIST
2490: LIST
2491: PUSH
2492: EMPTY
2493: LIST
2494: LIST
2495: PUSH
2496: EMPTY
2497: LIST
2498: PPUSH
2499: CALL_OW 69
2503: PPUSH
2504: LD_VAR 0 4
2508: PPUSH
2509: CALL_OW 74
2513: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2514: LD_VAR 0 4
2518: PPUSH
2519: LD_VAR 0 6
2523: PPUSH
2524: CALL_OW 296
2528: PUSH
2529: LD_INT 8
2531: PLUS
2532: PUSH
2533: LD_VAR 0 4
2537: PPUSH
2538: LD_VAR 0 7
2542: PPUSH
2543: CALL_OW 296
2547: LESS
2548: IFFALSE 2566
// begin ComAttackUnit ( i , target1 ) ;
2550: LD_VAR 0 4
2554: PPUSH
2555: LD_VAR 0 6
2559: PPUSH
2560: CALL_OW 115
// end else
2564: GO 2580
// begin ComAttackUnit ( i , target2 ) ;
2566: LD_VAR 0 4
2570: PPUSH
2571: LD_VAR 0 7
2575: PPUSH
2576: CALL_OW 115
// end ; end ;
2580: GO 2297
2582: POP
2583: POP
// until CPU1Tanks = 0 ;
2584: LD_EXP 3
2588: PUSH
2589: LD_INT 0
2591: EQUAL
2592: IFFALSE 2280
// end ; end ;
2594: GO 2267
2596: POP
2597: POP
// end ;
2598: LD_VAR 0 3
2602: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2603: LD_INT 0
2605: PPUSH
2606: PPUSH
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
2613: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
2614: LD_ADDR_VAR 0 8
2618: PUSH
2619: LD_INT 22
2621: PUSH
2622: LD_VAR 0 1
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 21
2633: PUSH
2634: LD_INT 2
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 24
2643: PUSH
2644: LD_INT 660
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 3
2653: PUSH
2654: LD_INT 58
2656: PUSH
2657: EMPTY
2658: LIST
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PPUSH
2670: CALL_OW 69
2674: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2675: LD_ADDR_VAR 0 9
2679: PUSH
2680: LD_INT 22
2682: PUSH
2683: LD_VAR 0 1
2687: PUSH
2688: EMPTY
2689: LIST
2690: LIST
2691: PUSH
2692: LD_INT 21
2694: PUSH
2695: LD_INT 2
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: PUSH
2702: LD_INT 3
2704: PUSH
2705: LD_INT 24
2707: PUSH
2708: LD_INT 660
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: LIST
2723: PPUSH
2724: CALL_OW 69
2728: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2729: LD_ADDR_VAR 0 10
2733: PUSH
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 22
2741: PUSH
2742: LD_VAR 0 1
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: PUSH
2751: LD_INT 21
2753: PUSH
2754: LD_INT 2
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: LD_INT 24
2766: PUSH
2767: LD_INT 1000
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL_OW 70
2787: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
2788: LD_ADDR_VAR 0 11
2792: PUSH
2793: LD_VAR 0 2
2797: PPUSH
2798: LD_INT 22
2800: PUSH
2801: LD_VAR 0 1
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PUSH
2810: LD_INT 21
2812: PUSH
2813: LD_INT 2
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 24
2822: PUSH
2823: LD_INT 1000
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: PUSH
2830: LD_INT 58
2832: PUSH
2833: EMPTY
2834: LIST
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: LIST
2841: PPUSH
2842: CALL_OW 70
2846: ST_TO_ADDR
// mechanicInside_list = [ ] ;
2847: LD_ADDR_VAR 0 12
2851: PUSH
2852: EMPTY
2853: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
2854: LD_ADDR_VAR 0 13
2858: PUSH
2859: LD_VAR 0 2
2863: PPUSH
2864: LD_INT 22
2866: PUSH
2867: LD_VAR 0 1
2871: PUSH
2872: EMPTY
2873: LIST
2874: LIST
2875: PUSH
2876: LD_INT 25
2878: PUSH
2879: LD_INT 3
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PPUSH
2890: CALL_OW 70
2894: ST_TO_ADDR
// display_strings = [ w polu:  , CPU1Tanks , uszkodzone:  , CPU1DamageTanks , wylosowane: 4 , ok , vehicleOK_list ] ;
2895: LD_ADDR_OWVAR 47
2899: PUSH
2900: LD_STRING w polu: 
2902: PUSH
2903: LD_EXP 3
2907: PUSH
2908: LD_STRING uszkodzone: 
2910: PUSH
2911: LD_EXP 4
2915: PUSH
2916: LD_STRING wylosowane: 4
2918: PUSH
2919: LD_STRING ok
2921: PUSH
2922: LD_VAR 0 8
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: ST_TO_ADDR
// if damageVehicle_list > 0 then
2936: LD_VAR 0 9
2940: PUSH
2941: LD_INT 0
2943: GREATER
2944: IFFALSE 2982
// for i in damageVehicle_list do
2946: LD_ADDR_VAR 0 6
2950: PUSH
2951: LD_VAR 0 9
2955: PUSH
2956: FOR_IN
2957: IFFALSE 2980
// ComMoveXY ( i , repX , repY ) ;
2959: LD_VAR 0 6
2963: PPUSH
2964: LD_VAR 0 3
2968: PPUSH
2969: LD_VAR 0 4
2973: PPUSH
2974: CALL_OW 111
2978: GO 2956
2980: POP
2981: POP
// if vehicleNeedRepair_list > 0 then
2982: LD_VAR 0 10
2986: PUSH
2987: LD_INT 0
2989: GREATER
2990: IFFALSE 3077
// begin for i in vehicleNeedRepair_list do
2992: LD_ADDR_VAR 0 6
2996: PUSH
2997: LD_VAR 0 10
3001: PUSH
3002: FOR_IN
3003: IFFALSE 3075
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
3005: LD_ADDR_VAR 0 12
3009: PUSH
3010: LD_VAR 0 12
3014: PUSH
3015: LD_VAR 0 6
3019: PPUSH
3020: CALL_OW 313
3024: ADD
3025: ST_TO_ADDR
// for j in mechanicInside_list do
3026: LD_ADDR_VAR 0 7
3030: PUSH
3031: LD_VAR 0 12
3035: PUSH
3036: FOR_IN
3037: IFFALSE 3071
// begin ComExitVehicle ( j ) ;
3039: LD_VAR 0 7
3043: PPUSH
3044: CALL_OW 121
// wait ( 0 0$1 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// AddComRepairVehicle ( j , i ) ;
3055: LD_VAR 0 7
3059: PPUSH
3060: LD_VAR 0 6
3064: PPUSH
3065: CALL_OW 189
// end ;
3069: GO 3036
3071: POP
3072: POP
// end ;
3073: GO 3002
3075: POP
3076: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3077: LD_VAR 0 11
3081: PUSH
3082: LD_INT 0
3084: GREATER
3085: IFFALSE 3109
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3087: LD_VAR 0 13
3091: PUSH
3092: LD_INT 1
3094: ARRAY
3095: PPUSH
3096: LD_VAR 0 11
3100: PUSH
3101: LD_INT 1
3103: ARRAY
3104: PPUSH
3105: CALL_OW 120
// end ; if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3109: LD_VAR 0 8
3113: PUSH
3114: LD_INT 0
3116: GREATER
3117: PUSH
3118: LD_EXP 4
3122: PUSH
3123: LD_INT 0
3125: GREATER
3126: AND
3127: IFFALSE 3268
// begin for i := 1 to vehicleOK_list do
3129: LD_ADDR_VAR 0 6
3133: PUSH
3134: DOUBLE
3135: LD_INT 1
3137: DEC
3138: ST_TO_ADDR
3139: LD_VAR 0 8
3143: PUSH
3144: FOR_TO
3145: IFFALSE 3266
// begin if i = 4 then
3147: LD_VAR 0 6
3151: PUSH
3152: LD_INT 4
3154: EQUAL
3155: IFFALSE 3264
// begin for i in vehicleOK_list do
3157: LD_ADDR_VAR 0 6
3161: PUSH
3162: LD_VAR 0 8
3166: PUSH
3167: FOR_IN
3168: IFFALSE 3188
// CPU1Tanks = CPU1Tanks ^ i ;
3170: LD_ADDR_EXP 3
3174: PUSH
3175: LD_EXP 3
3179: PUSH
3180: LD_VAR 0 6
3184: ADD
3185: ST_TO_ADDR
3186: GO 3167
3188: POP
3189: POP
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3190: LD_ADDR_EXP 4
3194: PUSH
3195: LD_EXP 4
3199: PPUSH
3200: LD_INT 1
3202: PPUSH
3203: CALL_OW 3
3207: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3208: LD_ADDR_EXP 4
3212: PUSH
3213: LD_EXP 4
3217: PPUSH
3218: LD_INT 1
3220: PPUSH
3221: CALL_OW 3
3225: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3226: LD_ADDR_EXP 4
3230: PUSH
3231: LD_EXP 4
3235: PPUSH
3236: LD_INT 1
3238: PPUSH
3239: CALL_OW 3
3243: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3244: LD_ADDR_EXP 4
3248: PUSH
3249: LD_EXP 4
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: CALL_OW 3
3261: ST_TO_ADDR
// break ;
3262: GO 3266
// end ; end ;
3264: GO 3144
3266: POP
3267: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3268: LD_ADDR_VAR 0 6
3272: PUSH
3273: LD_VAR 0 2
3277: PPUSH
3278: LD_INT 22
3280: PUSH
3281: LD_VAR 0 1
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: LD_INT 25
3292: PUSH
3293: LD_INT 3
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PPUSH
3304: CALL_OW 70
3308: NOT
3309: PUSH
3310: FOR_IN
3311: IFFALSE 3334
// ComMoveXY ( i , repX , repY ) ;
3313: LD_VAR 0 6
3317: PPUSH
3318: LD_VAR 0 3
3322: PPUSH
3323: LD_VAR 0 4
3327: PPUSH
3328: CALL_OW 111
3332: GO 3310
3334: POP
3335: POP
// end ;
3336: LD_VAR 0 5
3340: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3341: LD_INT 0
3343: PPUSH
3344: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3345: LD_INT 22
3347: PUSH
3348: LD_VAR 0 1
3352: PUSH
3353: EMPTY
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 25
3359: PUSH
3360: LD_INT 2
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: PPUSH
3371: CALL_OW 69
3375: PUSH
3376: LD_INT 0
3378: GREATER
3379: PUSH
3380: LD_INT 22
3382: PUSH
3383: LD_VAR 0 1
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 21
3394: PUSH
3395: LD_INT 3
3397: PUSH
3398: EMPTY
3399: LIST
3400: LIST
3401: PUSH
3402: LD_INT 3
3404: PUSH
3405: LD_INT 24
3407: PUSH
3408: LD_INT 1000
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: LIST
3423: PPUSH
3424: CALL_OW 69
3428: PUSH
3429: LD_INT 0
3431: EQUAL
3432: AND
3433: PUSH
3434: LD_VAR 0 2
3438: PUSH
3439: LD_INT 0
3441: GREATER
3442: AND
3443: IFFALSE 3542
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3445: LD_ADDR_VAR 0 4
3449: PUSH
3450: LD_INT 22
3452: PUSH
3453: LD_VAR 0 1
3457: PUSH
3458: EMPTY
3459: LIST
3460: LIST
3461: PUSH
3462: LD_INT 25
3464: PUSH
3465: LD_INT 2
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: PUSH
3472: EMPTY
3473: LIST
3474: LIST
3475: PPUSH
3476: CALL_OW 69
3480: PUSH
3481: FOR_IN
3482: IFFALSE 3540
// begin AddComExitBuilding ( i ) ;
3484: LD_VAR 0 4
3488: PPUSH
3489: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3493: LD_VAR 0 4
3497: PPUSH
3498: LD_VAR 0 2
3502: PUSH
3503: LD_INT 1
3505: ARRAY
3506: PPUSH
3507: LD_VAR 0 2
3511: PUSH
3512: LD_INT 2
3514: ARRAY
3515: PPUSH
3516: LD_VAR 0 2
3520: PUSH
3521: LD_INT 3
3523: ARRAY
3524: PPUSH
3525: LD_VAR 0 2
3529: PUSH
3530: LD_INT 4
3532: ARRAY
3533: PPUSH
3534: CALL_OW 205
// end ;
3538: GO 3481
3540: POP
3541: POP
// end ; end ;
3542: LD_VAR 0 3
3546: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3547: LD_INT 0
3549: PPUSH
3550: PPUSH
3551: PPUSH
3552: PPUSH
3553: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3554: LD_ADDR_VAR 0 6
3558: PUSH
3559: LD_INT 22
3561: PUSH
3562: LD_VAR 0 1
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: PUSH
3571: LD_INT 2
3573: PUSH
3574: LD_INT 30
3576: PUSH
3577: LD_INT 31
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 30
3586: PUSH
3587: LD_INT 32
3589: PUSH
3590: EMPTY
3591: LIST
3592: LIST
3593: PUSH
3594: LD_INT 30
3596: PUSH
3597: LD_INT 33
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 30
3606: PUSH
3607: LD_INT 4
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 30
3616: PUSH
3617: LD_INT 5
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: PPUSH
3636: CALL_OW 69
3640: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3641: LD_ADDR_VAR 0 7
3645: PUSH
3646: LD_INT 22
3648: PUSH
3649: LD_VAR 0 2
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PUSH
3658: LD_INT 21
3660: PUSH
3661: LD_INT 3
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: PUSH
3668: LD_INT 58
3670: PUSH
3671: EMPTY
3672: LIST
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: PPUSH
3679: CALL_OW 69
3683: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3684: LD_VAR 0 6
3688: PUSH
3689: LD_INT 0
3691: GREATER
3692: PUSH
3693: LD_VAR 0 7
3697: PUSH
3698: LD_INT 0
3700: GREATER
3701: AND
3702: IFFALSE 3772
// begin for i in turretsList do
3704: LD_ADDR_VAR 0 4
3708: PUSH
3709: LD_VAR 0 6
3713: PUSH
3714: FOR_IN
3715: IFFALSE 3770
// begin for j in enemyBuildings do
3717: LD_ADDR_VAR 0 5
3721: PUSH
3722: LD_VAR 0 7
3726: PUSH
3727: FOR_IN
3728: IFFALSE 3766
// begin if GetDistUnits ( i , j ) < 20 then
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_VAR 0 5
3739: PPUSH
3740: CALL_OW 296
3744: PUSH
3745: LD_INT 20
3747: LESS
3748: IFFALSE 3764
// begin ComAttackUnit ( i , j ) ;
3750: LD_VAR 0 4
3754: PPUSH
3755: LD_VAR 0 5
3759: PPUSH
3760: CALL_OW 115
// end ; end ;
3764: GO 3727
3766: POP
3767: POP
// end ;
3768: GO 3714
3770: POP
3771: POP
// end ; end ;
3772: LD_VAR 0 3
3776: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3777: LD_INT 0
3779: PPUSH
3780: PPUSH
3781: PPUSH
3782: PPUSH
3783: PPUSH
3784: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3785: LD_ADDR_VAR 0 7
3789: PUSH
3790: LD_INT 22
3792: PUSH
3793: LD_VAR 0 1
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PUSH
3802: LD_INT 25
3804: PUSH
3805: LD_INT 9
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: PUSH
3812: EMPTY
3813: LIST
3814: LIST
3815: PPUSH
3816: CALL_OW 69
3820: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3821: LD_ADDR_VAR 0 8
3825: PUSH
3826: LD_INT 22
3828: PUSH
3829: LD_VAR 0 2
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PUSH
3838: LD_INT 3
3840: PUSH
3841: LD_INT 21
3843: PUSH
3844: LD_INT 3
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PPUSH
3859: CALL_OW 69
3863: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3864: LD_ADDR_VAR 0 5
3868: PUSH
3869: LD_INT 1
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: CALL_OW 12
3879: ST_TO_ADDR
// for i = 1 to list do
3880: LD_ADDR_VAR 0 6
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_VAR 0 7
3894: PUSH
3895: FOR_TO
3896: IFFALSE 4078
// for ta in filter do
3898: LD_ADDR_VAR 0 4
3902: PUSH
3903: LD_VAR 0 8
3907: PUSH
3908: FOR_IN
3909: IFFALSE 4074
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3911: LD_VAR 0 7
3915: PUSH
3916: LD_VAR 0 6
3920: ARRAY
3921: PPUSH
3922: LD_VAR 0 4
3926: PPUSH
3927: CALL_OW 296
3931: PUSH
3932: LD_INT 13
3934: LESSEQUAL
3935: IFFALSE 4072
// begin case c of 1 :
3937: LD_VAR 0 5
3941: PUSH
3942: LD_INT 1
3944: DOUBLE
3945: EQUAL
3946: IFTRUE 3950
3948: GO 3988
3950: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3951: LD_VAR 0 7
3955: PUSH
3956: LD_VAR 0 6
3960: ARRAY
3961: PPUSH
3962: LD_VAR 0 4
3966: PPUSH
3967: CALL_OW 250
3971: PPUSH
3972: LD_VAR 0 4
3976: PPUSH
3977: CALL_OW 251
3981: PPUSH
3982: CALL_OW 154
3986: GO 4072
3988: LD_INT 2
3990: DOUBLE
3991: EQUAL
3992: IFTRUE 3996
3994: GO 4060
3996: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
3997: LD_VAR 0 7
4001: PUSH
4002: LD_VAR 0 6
4006: ARRAY
4007: PPUSH
4008: LD_VAR 0 4
4012: PPUSH
4013: CALL_OW 250
4017: PUSH
4018: LD_INT 1
4020: NEG
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: CALL_OW 12
4029: PLUS
4030: PPUSH
4031: LD_VAR 0 4
4035: PPUSH
4036: CALL_OW 251
4040: PUSH
4041: LD_INT 1
4043: NEG
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: CALL_OW 12
4052: PLUS
4053: PPUSH
4054: CALL_OW 153
4058: GO 4072
4060: LD_INT 3
4062: DOUBLE
4063: EQUAL
4064: IFTRUE 4068
4066: GO 4071
4068: POP
// ; end ;
4069: GO 4072
4071: POP
// end ; end ;
4072: GO 3908
4074: POP
4075: POP
4076: GO 3895
4078: POP
4079: POP
// end ; end_of_file
4080: LD_VAR 0 3
4084: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
// if exist_mode then
4089: LD_VAR 0 2
4093: IFFALSE 4112
// unit := CreateCharacter ( ident ) else
4095: LD_ADDR_VAR 0 4
4099: PUSH
4100: LD_VAR 0 1
4104: PPUSH
4105: CALL_OW 34
4109: ST_TO_ADDR
4110: GO 4127
// unit := NewCharacter ( ident ) ;
4112: LD_ADDR_VAR 0 4
4116: PUSH
4117: LD_VAR 0 1
4121: PPUSH
4122: CALL_OW 25
4126: ST_TO_ADDR
// result := unit ;
4127: LD_ADDR_VAR 0 3
4131: PUSH
4132: LD_VAR 0 4
4136: ST_TO_ADDR
// end ;
4137: LD_VAR 0 3
4141: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4142: LD_INT 0
4144: PPUSH
4145: PPUSH
4146: PPUSH
// uc_side := GetSide ( b ) ;
4147: LD_ADDR_OWVAR 20
4151: PUSH
4152: LD_VAR 0 2
4156: PPUSH
4157: CALL_OW 255
4161: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4162: LD_ADDR_OWVAR 21
4166: PUSH
4167: LD_VAR 0 2
4171: PPUSH
4172: CALL_OW 248
4176: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4177: LD_INT 0
4179: PPUSH
4180: LD_INT 1
4182: PPUSH
4183: LD_VAR 0 1
4187: PPUSH
4188: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4192: LD_ADDR_VAR 0 5
4196: PUSH
4197: LD_VAR 0 2
4201: PPUSH
4202: CALL_OW 254
4206: PUSH
4207: LD_INT 3
4209: MINUS
4210: ST_TO_ADDR
// if dir < 0 then
4211: LD_VAR 0 5
4215: PUSH
4216: LD_INT 0
4218: LESS
4219: IFFALSE 4235
// dir := 6 + dir ;
4221: LD_ADDR_VAR 0 5
4225: PUSH
4226: LD_INT 6
4228: PUSH
4229: LD_VAR 0 5
4233: PLUS
4234: ST_TO_ADDR
// un := CreateHuman ;
4235: LD_ADDR_VAR 0 4
4239: PUSH
4240: CALL_OW 44
4244: ST_TO_ADDR
// SetDir ( un , dir ) ;
4245: LD_VAR 0 4
4249: PPUSH
4250: LD_VAR 0 5
4254: PPUSH
4255: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4259: LD_VAR 0 4
4263: PPUSH
4264: LD_VAR 0 2
4268: PPUSH
4269: CALL_OW 52
// end ; end_of_file
4273: LD_VAR 0 3
4277: RET
// on UnitDestroyed ( un ) do var i ;
4278: LD_INT 0
4280: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
4281: LD_VAR 0 1
4285: PPUSH
4286: CALL_OW 255
4290: PUSH
4291: LD_INT 3
4293: EQUAL
4294: PUSH
4295: LD_VAR 0 1
4299: PPUSH
4300: CALL_OW 247
4304: PUSH
4305: LD_INT 3
4307: EQUAL
4308: AND
4309: IFFALSE 5001
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
4311: LD_VAR 0 1
4315: PPUSH
4316: CALL_OW 266
4320: PUSH
4321: LD_INT 31
4323: EQUAL
4324: PUSH
4325: LD_VAR 0 1
4329: PPUSH
4330: CALL_OW 266
4334: PUSH
4335: LD_INT 32
4337: EQUAL
4338: OR
4339: PUSH
4340: LD_VAR 0 1
4344: PPUSH
4345: CALL_OW 266
4349: PUSH
4350: LD_INT 36
4352: EQUAL
4353: OR
4354: PUSH
4355: LD_VAR 0 1
4359: PPUSH
4360: CALL_OW 266
4364: PUSH
4365: LD_INT 0
4367: EQUAL
4368: OR
4369: PUSH
4370: LD_VAR 0 1
4374: PPUSH
4375: CALL_OW 266
4379: PUSH
4380: LD_INT 24
4382: EQUAL
4383: OR
4384: PUSH
4385: LD_VAR 0 1
4389: PPUSH
4390: CALL_OW 266
4394: PUSH
4395: LD_INT 17
4397: EQUAL
4398: OR
4399: PUSH
4400: LD_VAR 0 1
4404: PPUSH
4405: CALL_OW 266
4409: PUSH
4410: LD_INT 25
4412: EQUAL
4413: OR
4414: PUSH
4415: LD_VAR 0 1
4419: PPUSH
4420: CALL_OW 266
4424: PUSH
4425: LD_INT 19
4427: EQUAL
4428: OR
4429: PUSH
4430: LD_VAR 0 1
4434: PPUSH
4435: CALL_OW 266
4439: PUSH
4440: LD_INT 20
4442: EQUAL
4443: OR
4444: PUSH
4445: LD_VAR 0 1
4449: PPUSH
4450: CALL_OW 266
4454: PUSH
4455: LD_INT 18
4457: EQUAL
4458: OR
4459: PUSH
4460: LD_VAR 0 1
4464: PPUSH
4465: CALL_OW 266
4469: PUSH
4470: LD_INT 21
4472: EQUAL
4473: OR
4474: PUSH
4475: LD_VAR 0 1
4479: PPUSH
4480: CALL_OW 266
4484: PUSH
4485: LD_INT 23
4487: EQUAL
4488: OR
4489: PUSH
4490: LD_VAR 0 1
4494: PPUSH
4495: CALL_OW 266
4499: PUSH
4500: LD_INT 16
4502: EQUAL
4503: OR
4504: PUSH
4505: LD_VAR 0 1
4509: PPUSH
4510: CALL_OW 266
4514: PUSH
4515: LD_INT 6
4517: EQUAL
4518: OR
4519: PUSH
4520: LD_VAR 0 1
4524: PPUSH
4525: CALL_OW 266
4529: PUSH
4530: LD_INT 29
4532: EQUAL
4533: OR
4534: PUSH
4535: LD_VAR 0 1
4539: PPUSH
4540: CALL_OW 266
4544: PUSH
4545: LD_INT 26
4547: EQUAL
4548: OR
4549: PUSH
4550: LD_VAR 0 1
4554: PPUSH
4555: CALL_OW 266
4559: PUSH
4560: LD_INT 30
4562: EQUAL
4563: OR
4564: PUSH
4565: LD_VAR 0 1
4569: PPUSH
4570: CALL_OW 266
4574: PUSH
4575: LD_INT 28
4577: EQUAL
4578: OR
4579: PUSH
4580: LD_VAR 0 1
4584: PPUSH
4585: CALL_OW 266
4589: PUSH
4590: LD_INT 27
4592: EQUAL
4593: OR
4594: PUSH
4595: LD_VAR 0 1
4599: PPUSH
4600: CALL_OW 266
4604: PUSH
4605: LD_INT 33
4607: EQUAL
4608: OR
4609: PUSH
4610: LD_VAR 0 1
4614: PPUSH
4615: CALL_OW 266
4619: PUSH
4620: LD_INT 2
4622: EQUAL
4623: OR
4624: PUSH
4625: LD_VAR 0 1
4629: PPUSH
4630: CALL_OW 266
4634: PUSH
4635: LD_INT 4
4637: EQUAL
4638: OR
4639: IFFALSE 4725
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
4641: LD_ADDR_EXP 1
4645: PUSH
4646: LD_EXP 1
4650: PUSH
4651: LD_VAR 0 1
4655: PPUSH
4656: CALL_OW 266
4660: ADD
4661: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4662: LD_ADDR_EXP 1
4666: PUSH
4667: LD_EXP 1
4671: PUSH
4672: LD_VAR 0 1
4676: PPUSH
4677: CALL_OW 250
4681: ADD
4682: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4683: LD_ADDR_EXP 1
4687: PUSH
4688: LD_EXP 1
4692: PUSH
4693: LD_VAR 0 1
4697: PPUSH
4698: CALL_OW 251
4702: ADD
4703: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4704: LD_ADDR_EXP 1
4708: PUSH
4709: LD_EXP 1
4713: PUSH
4714: LD_VAR 0 1
4718: PPUSH
4719: CALL_OW 254
4723: ADD
4724: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
4725: LD_VAR 0 1
4729: PPUSH
4730: CALL_OW 266
4734: PUSH
4735: LD_INT 1
4737: EQUAL
4738: IFFALSE 4817
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
4740: LD_ADDR_EXP 1
4744: PUSH
4745: LD_EXP 1
4749: PUSH
4750: LD_INT 0
4752: ADD
4753: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4754: LD_ADDR_EXP 1
4758: PUSH
4759: LD_EXP 1
4763: PUSH
4764: LD_VAR 0 1
4768: PPUSH
4769: CALL_OW 250
4773: ADD
4774: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4775: LD_ADDR_EXP 1
4779: PUSH
4780: LD_EXP 1
4784: PUSH
4785: LD_VAR 0 1
4789: PPUSH
4790: CALL_OW 251
4794: ADD
4795: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4796: LD_ADDR_EXP 1
4800: PUSH
4801: LD_EXP 1
4805: PUSH
4806: LD_VAR 0 1
4810: PPUSH
4811: CALL_OW 254
4815: ADD
4816: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4817: LD_VAR 0 1
4821: PPUSH
4822: CALL_OW 266
4826: PUSH
4827: LD_INT 3
4829: EQUAL
4830: IFFALSE 4909
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4832: LD_ADDR_EXP 1
4836: PUSH
4837: LD_EXP 1
4841: PUSH
4842: LD_INT 2
4844: ADD
4845: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4846: LD_ADDR_EXP 1
4850: PUSH
4851: LD_EXP 1
4855: PUSH
4856: LD_VAR 0 1
4860: PPUSH
4861: CALL_OW 250
4865: ADD
4866: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4867: LD_ADDR_EXP 1
4871: PUSH
4872: LD_EXP 1
4876: PUSH
4877: LD_VAR 0 1
4881: PPUSH
4882: CALL_OW 251
4886: ADD
4887: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4888: LD_ADDR_EXP 1
4892: PUSH
4893: LD_EXP 1
4897: PUSH
4898: LD_VAR 0 1
4902: PPUSH
4903: CALL_OW 254
4907: ADD
4908: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4909: LD_VAR 0 1
4913: PPUSH
4914: CALL_OW 266
4918: PUSH
4919: LD_INT 5
4921: EQUAL
4922: IFFALSE 5001
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
4924: LD_ADDR_EXP 1
4928: PUSH
4929: LD_EXP 1
4933: PUSH
4934: LD_INT 4
4936: ADD
4937: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4938: LD_ADDR_EXP 1
4942: PUSH
4943: LD_EXP 1
4947: PUSH
4948: LD_VAR 0 1
4952: PPUSH
4953: CALL_OW 250
4957: ADD
4958: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4959: LD_ADDR_EXP 1
4963: PUSH
4964: LD_EXP 1
4968: PUSH
4969: LD_VAR 0 1
4973: PPUSH
4974: CALL_OW 251
4978: ADD
4979: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4980: LD_ADDR_EXP 1
4984: PUSH
4985: LD_EXP 1
4989: PUSH
4990: LD_VAR 0 1
4994: PPUSH
4995: CALL_OW 254
4999: ADD
5000: ST_TO_ADDR
// end ; end ; if GetSide ( un ) = 3 and GetType ( un ) = unit_vehicle then
5001: LD_VAR 0 1
5005: PPUSH
5006: CALL_OW 255
5010: PUSH
5011: LD_INT 3
5013: EQUAL
5014: PUSH
5015: LD_VAR 0 1
5019: PPUSH
5020: CALL_OW 247
5024: PUSH
5025: LD_INT 2
5027: EQUAL
5028: AND
5029: IFFALSE 5133
// begin for i in CPU1DamageTanks do
5031: LD_ADDR_VAR 0 2
5035: PUSH
5036: LD_EXP 4
5040: PUSH
5041: FOR_IN
5042: IFFALSE 5131
// begin if i = un then
5044: LD_VAR 0 2
5048: PUSH
5049: LD_VAR 0 1
5053: EQUAL
5054: IFFALSE 5129
// begin AddComConstruct ( rufab , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
5056: LD_INT 30
5058: PPUSH
5059: LD_VAR 0 1
5063: PPUSH
5064: CALL_OW 265
5068: PPUSH
5069: LD_VAR 0 1
5073: PPUSH
5074: CALL_OW 262
5078: PPUSH
5079: LD_VAR 0 1
5083: PPUSH
5084: CALL_OW 263
5088: PPUSH
5089: LD_VAR 0 1
5093: PPUSH
5094: CALL_OW 264
5098: PPUSH
5099: CALL_OW 185
// CPU1DamageTanks = Delete ( CPU1DamageTanks , i [ i ] ) ;
5103: LD_ADDR_EXP 4
5107: PUSH
5108: LD_EXP 4
5112: PPUSH
5113: LD_VAR 0 2
5117: PUSH
5118: LD_VAR 0 2
5122: ARRAY
5123: PPUSH
5124: CALL_OW 3
5128: ST_TO_ADDR
// end ; end ;
5129: GO 5041
5131: POP
5132: POP
// end ; end ;
5133: PPOPN 2
5135: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
5136: LD_VAR 0 1
5140: PPUSH
5141: CALL_OW 255
5145: PUSH
5146: LD_INT 3
5148: EQUAL
5149: IFFALSE 5223
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5151: LD_ADDR_EXP 1
5155: PUSH
5156: LD_EXP 1
5160: PPUSH
5161: LD_INT 1
5163: PPUSH
5164: CALL_OW 3
5168: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5169: LD_ADDR_EXP 1
5173: PUSH
5174: LD_EXP 1
5178: PPUSH
5179: LD_INT 1
5181: PPUSH
5182: CALL_OW 3
5186: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5187: LD_ADDR_EXP 1
5191: PUSH
5192: LD_EXP 1
5196: PPUSH
5197: LD_INT 1
5199: PPUSH
5200: CALL_OW 3
5204: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
5205: LD_ADDR_EXP 1
5209: PUSH
5210: LD_EXP 1
5214: PPUSH
5215: LD_INT 1
5217: PPUSH
5218: CALL_OW 3
5222: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
5223: LD_VAR 0 1
5227: PPUSH
5228: CALL_OW 255
5232: PUSH
5233: LD_INT 3
5235: EQUAL
5236: PUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 266
5246: PUSH
5247: LD_INT 0
5249: EQUAL
5250: PUSH
5251: LD_VAR 0 1
5255: PPUSH
5256: CALL_OW 266
5260: PUSH
5261: LD_INT 2
5263: EQUAL
5264: OR
5265: PUSH
5266: LD_VAR 0 1
5270: PPUSH
5271: CALL_OW 266
5275: PUSH
5276: LD_INT 4
5278: EQUAL
5279: OR
5280: PUSH
5281: EMPTY
5282: LIST
5283: AND
5284: IFFALSE 5295
// ComUpgrade ( building ) ;
5286: LD_VAR 0 1
5290: PPUSH
5291: CALL_OW 146
// end ;
5295: PPOPN 1
5297: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
5298: LD_VAR 0 1
5302: PPUSH
5303: CALL_OW 255
5307: PUSH
5308: LD_INT 3
5310: EQUAL
5311: IFFALSE 5329
// CPU1Tanks = CPU1Tanks ^ vehicle ;
5313: LD_ADDR_EXP 3
5317: PUSH
5318: LD_EXP 3
5322: PUSH
5323: LD_VAR 0 1
5327: ADD
5328: ST_TO_ADDR
// end ;
5329: PPOPN 2
5331: END
