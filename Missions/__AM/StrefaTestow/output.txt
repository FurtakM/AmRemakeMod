// export destroyedBuildings ; export cargoTest ; export vehicleDriverTab ; export arabianMines ; export JMM ; starting var i ; begin Resetfog ;
   0: NOP4
// RandomizeAll ;
   4: NOP4
// destroyedBuildings = [ ] ;
   8: NOP4
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// cargoTest = [ ] ;
  15: NOP4
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// arabianMines = [ ] ;
  22: NOP4
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// end ;
  29: END
// export function SortBySkill ( list , asc ) ; var i , j , tmp ; begin
  30: LD_INT 0
  32: PPUSH
  33: PPUSH
  34: PPUSH
  35: PPUSH
// if not list then
  36: NOP4
  40: NOT
  41: IFFALSE 45
// exit ;
  43: GO 392
// result := [ ] ;
  45: NOP4
  49: PUSH
  50: EMPTY
  51: ST_TO_ADDR
// for i in list do
  52: NOP4
  56: PUSH
  57: NOP4
  61: PUSH
  62: FOR_IN
  63: IFFALSE 304
// begin tmp := ( ( GetSkill ( i , 1 ) + GetSkill ( i , 2 ) + GetSkill ( i , 3 ) + GetSkill ( i , 4 ) ) div 4 ) ;
  65: NOP4
  69: PUSH
  70: NOP4
  74: PPUSH
  75: LD_INT 1
  77: PPUSH
  78: NOP4
  82: PUSH
  83: NOP4
  87: PPUSH
  88: LD_INT 2
  90: PPUSH
  91: NOP4
  95: PLUS
  96: PUSH
  97: NOP4
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: NOP4
 109: PLUS
 110: PUSH
 111: NOP4
 115: PPUSH
 116: LD_INT 4
 118: PPUSH
 119: NOP4
 123: PLUS
 124: PUSH
 125: LD_INT 4
 127: DIV
 128: ST_TO_ADDR
// if not result then
 129: NOP4
 133: NOT
 134: IFFALSE 160
// result := [ [ i , tmp ] ] else
 136: NOP4
 140: PUSH
 141: NOP4
 145: PUSH
 146: NOP4
 150: PUSH
 151: EMPTY
 152: LIST
 153: LIST
 154: PUSH
 155: EMPTY
 156: LIST
 157: ST_TO_ADDR
 158: GO 302
// begin if result [ result ] [ 2 ] <= tmp then
 160: NOP4
 164: PUSH
 165: NOP4
 169: ARRAY
 170: PUSH
 171: LD_INT 2
 173: ARRAY
 174: PUSH
 175: NOP4
 179: LESSEQUAL
 180: IFFALSE 222
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
 182: NOP4
 186: PUSH
 187: NOP4
 191: PPUSH
 192: NOP4
 196: PUSH
 197: LD_INT 1
 199: PLUS
 200: PPUSH
 201: NOP4
 205: PUSH
 206: NOP4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: PPUSH
 215: NOP4
 219: ST_TO_ADDR
 220: GO 302
// for j = 1 to result do
 222: NOP4
 226: PUSH
 227: DOUBLE
 228: LD_INT 1
 230: DEC
 231: ST_TO_ADDR
 232: NOP4
 236: PUSH
 237: FOR_TO
 238: IFFALSE 300
// begin if tmp < result [ j ] [ 2 ] then
 240: NOP4
 244: PUSH
 245: NOP4
 249: PUSH
 250: NOP4
 254: ARRAY
 255: PUSH
 256: LD_INT 2
 258: ARRAY
 259: LESS
 260: IFFALSE 298
// begin result := Insert ( result , j , [ i , tmp ] ) ;
 262: NOP4
 266: PUSH
 267: NOP4
 271: PPUSH
 272: NOP4
 276: PPUSH
 277: NOP4
 281: PUSH
 282: NOP4
 286: PUSH
 287: EMPTY
 288: LIST
 289: LIST
 290: PPUSH
 291: NOP4
 295: ST_TO_ADDR
// break ;
 296: GO 300
// end ; end ;
 298: GO 237
 300: POP
 301: POP
// end ; end ;
 302: GO 62
 304: POP
 305: POP
// if result and not asc then
 306: NOP4
 310: PUSH
 311: NOP4
 315: NOT
 316: AND
 317: IFFALSE 392
// begin tmp := result ;
 319: NOP4
 323: PUSH
 324: NOP4
 328: ST_TO_ADDR
// for i = tmp downto 1 do
 329: NOP4
 333: PUSH
 334: DOUBLE
 335: NOP4
 339: INC
 340: ST_TO_ADDR
 341: LD_INT 1
 343: PUSH
 344: FOR_DOWNTO
 345: IFFALSE 390
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
 347: NOP4
 351: PUSH
 352: NOP4
 356: PPUSH
 357: NOP4
 361: PUSH
 362: NOP4
 366: MINUS
 367: PUSH
 368: LD_INT 1
 370: PLUS
 371: PPUSH
 372: NOP4
 376: PUSH
 377: NOP4
 381: ARRAY
 382: PPUSH
 383: NOP4
 387: ST_TO_ADDR
 388: GO 344
 390: POP
 391: POP
// end ; end ;
 392: LD_VAR 0 3
 396: RET
// export function ReverseNumber ( number ) ; var i ; begin
 397: LD_INT 0
 399: PPUSH
 400: PPUSH
// result :=  ;
 401: NOP4
 405: PUSH
 406: LD_STRING 
 408: ST_TO_ADDR
// while ( number ) do
 409: NOP4
 413: IFFALSE 451
// begin result := result & ( number mod 10 ) ;
 415: NOP4
 419: PUSH
 420: NOP4
 424: PUSH
 425: NOP4
 429: PUSH
 430: LD_INT 10
 432: MOD
 433: STR
 434: ST_TO_ADDR
// number := number div 10 ;
 435: NOP4
 439: PUSH
 440: NOP4
 444: PUSH
 445: LD_INT 10
 447: DIV
 448: ST_TO_ADDR
// end ;
 449: GO 409
// end ;
 451: LD_VAR 0 2
 455: RET
// export d ; every 0 0$01 do var un , un2 ;
 456: GO 458
 458: DISABLE
 459: LD_INT 0
 461: PPUSH
 462: PPUSH
// begin uc_side := 1 ;
 463: LD_ADDR_OWVAR 20
 467: PUSH
 468: LD_INT 1
 470: ST_TO_ADDR
// uc_nation := 2 ;
 471: LD_ADDR_OWVAR 21
 475: PUSH
 476: LD_INT 2
 478: ST_TO_ADDR
// hc_class := 1 ;
 479: LD_ADDR_OWVAR 28
 483: PUSH
 484: LD_INT 1
 486: ST_TO_ADDR
// hc_gallery :=  ;
 487: LD_ADDR_OWVAR 33
 491: PUSH
 492: LD_STRING 
 494: ST_TO_ADDR
// un := CreateHuman ;
 495: NOP4
 499: PUSH
 500: NOP4
 504: ST_TO_ADDR
// d := CreateHuman ;
 505: NOP4
 509: PUSH
 510: NOP4
 514: ST_TO_ADDR
// PlaceUnitXY ( un , 192 , 25 , false ) ;
 515: NOP4
 519: PPUSH
 520: LD_INT 192
 522: PPUSH
 523: LD_INT 25
 525: PPUSH
 526: LD_INT 0
 528: PPUSH
 529: NOP4
// PlaceUnitXY ( d , 190 , 25 , false ) ;
 533: NOP4
 537: PPUSH
 538: LD_INT 190
 540: PPUSH
 541: LD_INT 25
 543: PPUSH
 544: LD_INT 0
 546: PPUSH
 547: NOP4
// end ;
 551: PPOPN 2
 553: END
// export function WantPlant ( unit ) ; var task ; begin
 554: LD_INT 0
 556: PPUSH
 557: PPUSH
// result := false ;
 558: NOP4
 562: PUSH
 563: LD_INT 0
 565: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
 566: NOP4
 570: PUSH
 571: NOP4
 575: PPUSH
 576: NOP4
 580: ST_TO_ADDR
// if task then
 581: NOP4
 585: IFFALSE 613
// if task [ 1 ] [ 1 ] = p then
 587: NOP4
 591: PUSH
 592: LD_INT 1
 594: ARRAY
 595: PUSH
 596: LD_INT 1
 598: ARRAY
 599: PUSH
 600: LD_STRING p
 602: EQUAL
 603: IFFALSE 613
// result := true ;
 605: NOP4
 609: PUSH
 610: LD_INT 1
 612: ST_TO_ADDR
// end ;
 613: LD_VAR 0 2
 617: RET
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
 618: LD_INT 0
 620: PPUSH
 621: PPUSH
 622: PPUSH
 623: PPUSH
// for i = 1 to 3 do
 624: NOP4
 628: PUSH
 629: DOUBLE
 630: LD_INT 1
 632: DEC
 633: ST_TO_ADDR
 634: LD_INT 3
 636: PUSH
 637: FOR_TO
 638: IFFALSE 668
// amount := amount + GetResourceArea ( area , i ) ;
 640: NOP4
 644: PUSH
 645: NOP4
 649: PUSH
 650: NOP4
 654: PPUSH
 655: NOP4
 659: PPUSH
 660: NOP4
 664: PLUS
 665: ST_TO_ADDR
 666: GO 637
 668: POP
 669: POP
// if amount < materials then
 670: NOP4
 674: PUSH
 675: NOP4
 679: LESS
 680: IFFALSE 684
// exit ;
 682: GO 718
// for i = 1 to 3 do
 684: NOP4
 688: PUSH
 689: DOUBLE
 690: LD_INT 1
 692: DEC
 693: ST_TO_ADDR
 694: LD_INT 3
 696: PUSH
 697: FOR_TO
 698: IFFALSE 716
// EraseResourceArea ( area , i ) ;
 700: NOP4
 704: PPUSH
 705: NOP4
 709: PPUSH
 710: NOP4
 714: GO 697
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 3
 722: RET
// every 0 0$1 do
 723: GO 725
 725: DISABLE
// begin enable ;
 726: ENABLE
// CraneRepairBuild ( 3 , craneRepair , destroyedBuildings ) ;
 727: LD_INT 3
 729: PPUSH
 730: NOP4
 734: PPUSH
 735: NOP4
 739: PPUSH
 740: NOP4
// end ;
 744: END
// every 5 5$1 do
 745: GO 747
 747: DISABLE
// begin end ;
 748: END
// every 0 0$1 do
 749: GO 751
 751: DISABLE
// begin end ;
 752: END
// every 0 0$01 trigger arabianMines do var i , p ;
 753: NOP4
 757: IFFALSE 960
 759: GO 761
 761: DISABLE
 762: LD_INT 0
 764: PPUSH
 765: PPUSH
// begin enable ;
 766: ENABLE
// p := 1 ;
 767: NOP4
 771: PUSH
 772: LD_INT 1
 774: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 775: NOP4
 779: PUSH
 780: DOUBLE
 781: LD_INT 1
 783: DEC
 784: ST_TO_ADDR
 785: NOP4
 789: PUSH
 790: LD_INT 2
 792: DIVREAL
 793: PUSH
 794: FOR_TO
 795: IFFALSE 958
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 797: LD_INT 81
 799: PUSH
 800: LD_INT 2
 802: PUSH
 803: EMPTY
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 92
 809: PUSH
 810: NOP4
 814: PUSH
 815: NOP4
 819: ARRAY
 820: PUSH
 821: NOP4
 825: PUSH
 826: NOP4
 830: PUSH
 831: LD_INT 1
 833: PLUS
 834: ARRAY
 835: PUSH
 836: LD_INT 2
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: PUSH
 845: EMPTY
 846: LIST
 847: LIST
 848: PPUSH
 849: NOP4
 853: IFFALSE 942
// begin LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 855: NOP4
 859: PUSH
 860: NOP4
 864: ARRAY
 865: PPUSH
 866: NOP4
 870: PUSH
 871: NOP4
 875: PUSH
 876: LD_INT 1
 878: PLUS
 879: ARRAY
 880: PPUSH
 881: LD_INT 2
 883: PPUSH
 884: NOP4
// arabianMines := Delete ( arabianMines , p ) ;
 888: NOP4
 892: PUSH
 893: NOP4
 897: PPUSH
 898: NOP4
 902: PPUSH
 903: NOP4
 907: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 908: NOP4
 912: PUSH
 913: NOP4
 917: PPUSH
 918: NOP4
 922: PPUSH
 923: NOP4
 927: ST_TO_ADDR
// p := p - 2 ;
 928: NOP4
 932: PUSH
 933: NOP4
 937: PUSH
 938: LD_INT 2
 940: MINUS
 941: ST_TO_ADDR
// end ; p := p + 2 ;
 942: NOP4
 946: PUSH
 947: NOP4
 951: PUSH
 952: LD_INT 2
 954: PLUS
 955: ST_TO_ADDR
// end ;
 956: GO 794
 958: POP
 959: POP
// end ; end_of_file
 960: PPOPN 2
 962: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 963: LD_INT 0
 965: PPUSH
 966: PPUSH
 967: PPUSH
// rnd = rand ( 1 , characters ) ;
 968: NOP4
 972: PUSH
 973: LD_INT 1
 975: PPUSH
 976: NOP4
 980: PPUSH
 981: NOP4
 985: ST_TO_ADDR
// for i = 1 to characters do
 986: NOP4
 990: PUSH
 991: DOUBLE
 992: LD_INT 1
 994: DEC
 995: ST_TO_ADDR
 996: NOP4
1000: PUSH
1001: FOR_TO
1002: IFFALSE 1112
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
1004: NOP4
1008: PUSH
1009: NOP4
1013: EQUAL
1014: PUSH
1015: NOP4
1019: PUSH
1020: NOP4
1024: ARRAY
1025: PPUSH
1026: NOP4
1030: PUSH
1031: LD_INT 1
1033: EQUAL
1034: AND
1035: IFFALSE 1057
// Say ( characters [ i ] , dialogMID ) ;
1037: NOP4
1041: PUSH
1042: NOP4
1046: ARRAY
1047: PPUSH
1048: NOP4
1052: PPUSH
1053: NOP4
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
1057: NOP4
1061: PUSH
1062: NOP4
1066: EQUAL
1067: PUSH
1068: NOP4
1072: PUSH
1073: NOP4
1077: ARRAY
1078: PPUSH
1079: NOP4
1083: PUSH
1084: LD_INT 2
1086: EQUAL
1087: AND
1088: IFFALSE 1110
// Say ( characters [ i ] , dialogFID ) ;
1090: NOP4
1094: PUSH
1095: NOP4
1099: ARRAY
1100: PPUSH
1101: NOP4
1105: PPUSH
1106: NOP4
// end ;
1110: GO 1001
1112: POP
1113: POP
// end ;
1114: LD_VAR 0 4
1118: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
1119: LD_INT 0
1121: PPUSH
1122: PPUSH
1123: PPUSH
1124: PPUSH
// for i = 1 to count do
1125: NOP4
1129: PUSH
1130: DOUBLE
1131: LD_INT 1
1133: DEC
1134: ST_TO_ADDR
1135: NOP4
1139: PUSH
1140: FOR_TO
1141: IFFALSE 1222
// begin uc_side = side ;
1143: LD_ADDR_OWVAR 20
1147: PUSH
1148: NOP4
1152: ST_TO_ADDR
// uc_nation = nation ;
1153: LD_ADDR_OWVAR 21
1157: PUSH
1158: NOP4
1162: ST_TO_ADDR
// hc_gallery =  ;
1163: LD_ADDR_OWVAR 33
1167: PUSH
1168: LD_STRING 
1170: ST_TO_ADDR
// hc_name =  ;
1171: LD_ADDR_OWVAR 26
1175: PUSH
1176: LD_STRING 
1178: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
1179: LD_INT 0
1181: PPUSH
1182: NOP4
1186: PPUSH
1187: NOP4
1191: PPUSH
1192: NOP4
// un = CreateHuman ;
1196: NOP4
1200: PUSH
1201: NOP4
1205: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
1206: NOP4
1210: PPUSH
1211: NOP4
1215: PPUSH
1216: NOP4
// end ;
1220: GO 1140
1222: POP
1223: POP
// end ;
1224: LD_VAR 0 7
1228: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
1229: LD_INT 0
1231: PPUSH
1232: PPUSH
// for i in charactersList do
1233: NOP4
1237: PUSH
1238: NOP4
1242: PUSH
1243: FOR_IN
1244: IFFALSE 1284
// begin if IsOk ( i ) then
1246: NOP4
1250: PPUSH
1251: NOP4
1255: IFFALSE 1273
// begin SaveCharacters ( i , ident ) ;
1257: NOP4
1261: PPUSH
1262: NOP4
1266: PPUSH
1267: NOP4
// end else
1271: GO 1282
// begin DeleteCharacters ( ident ) ;
1273: NOP4
1277: PPUSH
1278: NOP4
// end ; end ;
1282: GO 1243
1284: POP
1285: POP
// end ;
1286: LD_VAR 0 3
1290: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
1291: LD_INT 0
1293: PPUSH
1294: PPUSH
1295: PPUSH
1296: PPUSH
1297: PPUSH
1298: PPUSH
1299: PPUSH
1300: PPUSH
1301: PPUSH
1302: PPUSH
1303: PPUSH
// amChassisTab = [ ] ;
1304: NOP4
1308: PUSH
1309: EMPTY
1310: ST_TO_ADDR
// arChassisTab = [ ] ;
1311: NOP4
1315: PUSH
1316: EMPTY
1317: ST_TO_ADDR
// ruChassisTab = [ ] ;
1318: NOP4
1322: PUSH
1323: EMPTY
1324: ST_TO_ADDR
// if nation = 1 then
1325: NOP4
1329: PUSH
1330: LD_INT 1
1332: EQUAL
1333: IFFALSE 1750
// begin for i := 1 to vehCount do
1335: NOP4
1339: PUSH
1340: DOUBLE
1341: LD_INT 1
1343: DEC
1344: ST_TO_ADDR
1345: NOP4
1349: PUSH
1350: FOR_TO
1351: IFFALSE 1748
// begin uc_side = side ;
1353: LD_ADDR_OWVAR 20
1357: PUSH
1358: NOP4
1362: ST_TO_ADDR
// uc_nation = nation ;
1363: LD_ADDR_OWVAR 21
1367: PUSH
1368: NOP4
1372: ST_TO_ADDR
// vc_engine = vehengine ;
1373: LD_ADDR_OWVAR 39
1377: PUSH
1378: NOP4
1382: ST_TO_ADDR
// vc_control = vehcontrol ;
1383: LD_ADDR_OWVAR 38
1387: PUSH
1388: NOP4
1392: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
1393: LD_ADDR_OWVAR 40
1397: PUSH
1398: NOP4
1402: PUSH
1403: LD_INT 1
1405: PPUSH
1406: NOP4
1410: PPUSH
1411: NOP4
1415: ARRAY
1416: ST_TO_ADDR
// if vc_weapon = 2 or vc_weapon = 3 then
1417: NOP4
1421: PUSH
1422: LD_INT 2
1424: EQUAL
1425: PUSH
1426: NOP4
1430: PUSH
1431: LD_INT 3
1433: EQUAL
1434: OR
1435: IFFALSE 1488
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
1437: NOP4
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 2
1447: PUSH
1448: LD_INT 3
1450: PUSH
1451: LD_INT 4
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1464: LD_ADDR_OWVAR 37
1468: PUSH
1469: NOP4
1473: PUSH
1474: LD_INT 1
1476: PPUSH
1477: NOP4
1481: PPUSH
1482: NOP4
1486: ARRAY
1487: ST_TO_ADDR
// end ; if vc_weapon = 4 or vc_weapon = 5 or vc_weapon = 9 or vc_weapon = 11 or vc_weapon = 7 then
1488: NOP4
1492: PUSH
1493: LD_INT 4
1495: EQUAL
1496: PUSH
1497: NOP4
1501: PUSH
1502: LD_INT 5
1504: EQUAL
1505: OR
1506: PUSH
1507: NOP4
1511: PUSH
1512: LD_INT 9
1514: EQUAL
1515: OR
1516: PUSH
1517: NOP4
1521: PUSH
1522: LD_INT 11
1524: EQUAL
1525: OR
1526: PUSH
1527: NOP4
1531: PUSH
1532: LD_INT 7
1534: EQUAL
1535: OR
1536: IFFALSE 1585
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1538: NOP4
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 3
1548: PUSH
1549: LD_INT 4
1551: PUSH
1552: LD_INT 5
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1561: LD_ADDR_OWVAR 37
1565: PUSH
1566: NOP4
1570: PUSH
1571: LD_INT 1
1573: PPUSH
1574: NOP4
1578: PPUSH
1579: NOP4
1583: ARRAY
1584: ST_TO_ADDR
// end ; if vc_weapon = 8 or vc_weapon = 6 or vc_weapon = 10 then
1585: NOP4
1589: PUSH
1590: LD_INT 8
1592: EQUAL
1593: PUSH
1594: NOP4
1598: PUSH
1599: LD_INT 6
1601: EQUAL
1602: OR
1603: PUSH
1604: NOP4
1608: PUSH
1609: LD_INT 10
1611: EQUAL
1612: OR
1613: IFFALSE 1654
// begin amChassisTab = [ 4 , 5 ] ;
1615: NOP4
1619: PUSH
1620: LD_INT 4
1622: PUSH
1623: LD_INT 5
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1630: LD_ADDR_OWVAR 37
1634: PUSH
1635: NOP4
1639: PUSH
1640: LD_INT 1
1642: PPUSH
1643: NOP4
1647: PPUSH
1648: NOP4
1652: ARRAY
1653: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1654: NOP4
1658: PUSH
1659: NOP4
1663: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1664: NOP4
1668: PPUSH
1669: NOP4
1673: PPUSH
1674: LD_INT 0
1676: PPUSH
1677: NOP4
// if vehcontrol = 1 then
1681: NOP4
1685: PUSH
1686: LD_INT 1
1688: EQUAL
1689: IFFALSE 1746
// begin hc_gallery =  ;
1691: LD_ADDR_OWVAR 33
1695: PUSH
1696: LD_STRING 
1698: ST_TO_ADDR
// hc_name =  ;
1699: LD_ADDR_OWVAR 26
1703: PUSH
1704: LD_STRING 
1706: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1707: LD_INT 0
1709: PPUSH
1710: LD_INT 3
1712: PPUSH
1713: NOP4
1717: PPUSH
1718: NOP4
// un = CreateHuman ;
1722: NOP4
1726: PUSH
1727: NOP4
1731: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1732: NOP4
1736: PPUSH
1737: NOP4
1741: PPUSH
1742: NOP4
// end ; end ;
1746: GO 1350
1748: POP
1749: POP
// end ; if nation = 2 then
1750: NOP4
1754: PUSH
1755: LD_INT 2
1757: EQUAL
1758: IFFALSE 2114
// begin for i := 1 to vehCount do
1760: NOP4
1764: PUSH
1765: DOUBLE
1766: LD_INT 1
1768: DEC
1769: ST_TO_ADDR
1770: NOP4
1774: PUSH
1775: FOR_TO
1776: IFFALSE 2112
// begin uc_side = side ;
1778: LD_ADDR_OWVAR 20
1782: PUSH
1783: NOP4
1787: ST_TO_ADDR
// uc_nation = nation ;
1788: LD_ADDR_OWVAR 21
1792: PUSH
1793: NOP4
1797: ST_TO_ADDR
// vc_engine = vehengine ;
1798: LD_ADDR_OWVAR 39
1802: PUSH
1803: NOP4
1807: ST_TO_ADDR
// vc_control = vehcontrol ;
1808: LD_ADDR_OWVAR 38
1812: PUSH
1813: NOP4
1817: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1818: LD_ADDR_OWVAR 40
1822: PUSH
1823: NOP4
1827: PUSH
1828: LD_INT 1
1830: PPUSH
1831: NOP4
1835: PPUSH
1836: NOP4
1840: ARRAY
1841: ST_TO_ADDR
// if vc_weapon = 24 or vc_weapon = 22 or vc_weapon = 23 or vc_weapon = 30 then
1842: NOP4
1846: PUSH
1847: LD_INT 24
1849: EQUAL
1850: PUSH
1851: NOP4
1855: PUSH
1856: LD_INT 22
1858: EQUAL
1859: OR
1860: PUSH
1861: NOP4
1865: PUSH
1866: LD_INT 23
1868: EQUAL
1869: OR
1870: PUSH
1871: NOP4
1875: PUSH
1876: LD_INT 30
1878: EQUAL
1879: OR
1880: IFFALSE 1929
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1882: NOP4
1886: PUSH
1887: LD_INT 11
1889: PUSH
1890: LD_INT 12
1892: PUSH
1893: LD_INT 13
1895: PUSH
1896: LD_INT 14
1898: PUSH
1899: EMPTY
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1905: LD_ADDR_OWVAR 37
1909: PUSH
1910: NOP4
1914: PUSH
1915: LD_INT 1
1917: PPUSH
1918: NOP4
1922: PPUSH
1923: NOP4
1927: ARRAY
1928: ST_TO_ADDR
// end ; if vc_weapon = 29 or vc_weapon = 28 or vc_weapon = 27 or vc_weapon = 26 or vc_weapon = 25 then
1929: NOP4
1933: PUSH
1934: LD_INT 29
1936: EQUAL
1937: PUSH
1938: NOP4
1942: PUSH
1943: LD_INT 28
1945: EQUAL
1946: OR
1947: PUSH
1948: NOP4
1952: PUSH
1953: LD_INT 27
1955: EQUAL
1956: OR
1957: PUSH
1958: NOP4
1962: PUSH
1963: LD_INT 26
1965: EQUAL
1966: OR
1967: PUSH
1968: NOP4
1972: PUSH
1973: LD_INT 25
1975: EQUAL
1976: OR
1977: IFFALSE 2018
// begin arChassisTab = [ 13 , 14 ] ;
1979: NOP4
1983: PUSH
1984: LD_INT 13
1986: PUSH
1987: LD_INT 14
1989: PUSH
1990: EMPTY
1991: LIST
1992: LIST
1993: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1994: LD_ADDR_OWVAR 37
1998: PUSH
1999: NOP4
2003: PUSH
2004: LD_INT 1
2006: PPUSH
2007: NOP4
2011: PPUSH
2012: NOP4
2016: ARRAY
2017: ST_TO_ADDR
// end ; veh = CreateVehicle ;
2018: NOP4
2022: PUSH
2023: NOP4
2027: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2028: NOP4
2032: PPUSH
2033: NOP4
2037: PPUSH
2038: LD_INT 0
2040: PPUSH
2041: NOP4
// if vehcontrol = 1 then
2045: NOP4
2049: PUSH
2050: LD_INT 1
2052: EQUAL
2053: IFFALSE 2110
// begin hc_gallery =  ;
2055: LD_ADDR_OWVAR 33
2059: PUSH
2060: LD_STRING 
2062: ST_TO_ADDR
// hc_name =  ;
2063: LD_ADDR_OWVAR 26
2067: PUSH
2068: LD_STRING 
2070: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2071: LD_INT 0
2073: PPUSH
2074: LD_INT 3
2076: PPUSH
2077: NOP4
2081: PPUSH
2082: NOP4
// un = CreateHuman ;
2086: NOP4
2090: PUSH
2091: NOP4
2095: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2096: NOP4
2100: PPUSH
2101: NOP4
2105: PPUSH
2106: NOP4
// end ; end ;
2110: GO 1775
2112: POP
2113: POP
// end ; if nation = 3 then
2114: NOP4
2118: PUSH
2119: LD_INT 3
2121: EQUAL
2122: IFFALSE 2480
// begin for i := 1 to vehCount do
2124: NOP4
2128: PUSH
2129: DOUBLE
2130: LD_INT 1
2132: DEC
2133: ST_TO_ADDR
2134: NOP4
2138: PUSH
2139: FOR_TO
2140: IFFALSE 2478
// begin uc_side = side ;
2142: LD_ADDR_OWVAR 20
2146: PUSH
2147: NOP4
2151: ST_TO_ADDR
// uc_nation = nation ;
2152: LD_ADDR_OWVAR 21
2156: PUSH
2157: NOP4
2161: ST_TO_ADDR
// vc_engine = vehengine ;
2162: LD_ADDR_OWVAR 39
2166: PUSH
2167: NOP4
2171: ST_TO_ADDR
// vc_control = vehcontrol ;
2172: LD_ADDR_OWVAR 38
2176: PUSH
2177: NOP4
2181: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
2182: LD_ADDR_OWVAR 40
2186: PUSH
2187: NOP4
2191: PUSH
2192: LD_INT 1
2194: PPUSH
2195: NOP4
2199: PPUSH
2200: NOP4
2204: ARRAY
2205: ST_TO_ADDR
// for j = 1 to RuWeapons do
2206: NOP4
2210: PUSH
2211: DOUBLE
2212: LD_INT 1
2214: DEC
2215: ST_TO_ADDR
2216: NOP4
2220: PUSH
2221: FOR_TO
2222: IFFALSE 2382
// begin if vc_weapon = 42 or vc_weapon = 43 or vc_weapon = 44 or vc_weapon = 45 or vc_weapon = 49 then
2224: NOP4
2228: PUSH
2229: LD_INT 42
2231: EQUAL
2232: PUSH
2233: NOP4
2237: PUSH
2238: LD_INT 43
2240: EQUAL
2241: OR
2242: PUSH
2243: NOP4
2247: PUSH
2248: LD_INT 44
2250: EQUAL
2251: OR
2252: PUSH
2253: NOP4
2257: PUSH
2258: LD_INT 45
2260: EQUAL
2261: OR
2262: PUSH
2263: NOP4
2267: PUSH
2268: LD_INT 49
2270: EQUAL
2271: OR
2272: IFFALSE 2321
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
2274: NOP4
2278: PUSH
2279: LD_INT 21
2281: PUSH
2282: LD_INT 22
2284: PUSH
2285: LD_INT 23
2287: PUSH
2288: LD_INT 24
2290: PUSH
2291: EMPTY
2292: LIST
2293: LIST
2294: LIST
2295: LIST
2296: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2297: LD_ADDR_OWVAR 37
2301: PUSH
2302: NOP4
2306: PUSH
2307: LD_INT 1
2309: PPUSH
2310: NOP4
2314: PPUSH
2315: NOP4
2319: ARRAY
2320: ST_TO_ADDR
// end ; if vc_weapon = 46 or vc_weapon = 47 then
2321: NOP4
2325: PUSH
2326: LD_INT 46
2328: EQUAL
2329: PUSH
2330: NOP4
2334: PUSH
2335: LD_INT 47
2337: EQUAL
2338: OR
2339: IFFALSE 2380
// begin ruChassisTab = [ 23 , 24 ] ;
2341: NOP4
2345: PUSH
2346: LD_INT 23
2348: PUSH
2349: LD_INT 24
2351: PUSH
2352: EMPTY
2353: LIST
2354: LIST
2355: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2356: LD_ADDR_OWVAR 37
2360: PUSH
2361: NOP4
2365: PUSH
2366: LD_INT 1
2368: PPUSH
2369: NOP4
2373: PPUSH
2374: NOP4
2378: ARRAY
2379: ST_TO_ADDR
// end ; end ;
2380: GO 2221
2382: POP
2383: POP
// veh = CreateVehicle ;
2384: NOP4
2388: PUSH
2389: NOP4
2393: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2394: NOP4
2398: PPUSH
2399: NOP4
2403: PPUSH
2404: LD_INT 0
2406: PPUSH
2407: NOP4
// if vehcontrol = 1 then
2411: NOP4
2415: PUSH
2416: LD_INT 1
2418: EQUAL
2419: IFFALSE 2476
// begin hc_gallery =  ;
2421: LD_ADDR_OWVAR 33
2425: PUSH
2426: LD_STRING 
2428: ST_TO_ADDR
// hc_name =  ;
2429: LD_ADDR_OWVAR 26
2433: PUSH
2434: LD_STRING 
2436: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2437: LD_INT 0
2439: PPUSH
2440: LD_INT 3
2442: PPUSH
2443: NOP4
2447: PPUSH
2448: NOP4
// un = CreateHuman ;
2452: NOP4
2456: PUSH
2457: NOP4
2461: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2462: NOP4
2466: PPUSH
2467: NOP4
2471: PPUSH
2472: NOP4
// end ; end ;
2476: GO 2139
2478: POP
2479: POP
// end ; repeat wait ( 0 0$1 ) ;
2480: LD_INT 35
2482: PPUSH
2483: NOP4
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2487: NOP4
2491: PUSH
2492: LD_INT 22
2494: PUSH
2495: NOP4
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PUSH
2504: LD_INT 21
2506: PUSH
2507: LD_INT 2
2509: PUSH
2510: EMPTY
2511: LIST
2512: LIST
2513: PUSH
2514: LD_INT 24
2516: PUSH
2517: LD_INT 650
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: PUSH
2524: EMPTY
2525: LIST
2526: LIST
2527: LIST
2528: PPUSH
2529: NOP4
2533: ST_TO_ADDR
// if vehicleOK_list > 0 then
2534: NOP4
2538: PUSH
2539: LD_INT 0
2541: GREATER
2542: IFFALSE 2733
// begin for i in vehicleOK_list do
2544: NOP4
2548: PUSH
2549: NOP4
2553: PUSH
2554: FOR_IN
2555: IFFALSE 2731
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , side ] ) , i ) ;
2557: NOP4
2561: PUSH
2562: LD_INT 81
2564: PUSH
2565: NOP4
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: NOP4
2578: PPUSH
2579: NOP4
2583: PPUSH
2584: NOP4
2588: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2589: NOP4
2593: PUSH
2594: LD_INT 81
2596: PUSH
2597: NOP4
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: PUSH
2606: LD_INT 2
2608: PUSH
2609: LD_INT 59
2611: PUSH
2612: EMPTY
2613: LIST
2614: PUSH
2615: LD_INT 21
2617: PUSH
2618: LD_INT 1
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: LD_INT 21
2627: PUSH
2628: LD_INT 2
2630: PUSH
2631: EMPTY
2632: LIST
2633: LIST
2634: PUSH
2635: EMPTY
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: EMPTY
2642: LIST
2643: LIST
2644: PUSH
2645: EMPTY
2646: LIST
2647: PPUSH
2648: NOP4
2652: PPUSH
2653: NOP4
2657: PPUSH
2658: NOP4
2662: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2663: NOP4
2667: PPUSH
2668: NOP4
2672: PPUSH
2673: NOP4
2677: PUSH
2678: LD_INT 8
2680: PLUS
2681: PUSH
2682: NOP4
2686: PPUSH
2687: NOP4
2691: PPUSH
2692: NOP4
2696: LESS
2697: IFFALSE 2715
// ComAttackUnit ( i , target1 ) else
2699: NOP4
2703: PPUSH
2704: NOP4
2708: PPUSH
2709: NOP4
2713: GO 2729
// ComAttackUnit ( i , target2 ) ;
2715: NOP4
2719: PPUSH
2720: NOP4
2724: PPUSH
2725: NOP4
// end ;
2729: GO 2554
2731: POP
2732: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_empty ] ] ) = 0 ;
2733: LD_INT 22
2735: PUSH
2736: NOP4
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: PUSH
2745: LD_INT 21
2747: PUSH
2748: LD_INT 2
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: PUSH
2755: LD_INT 24
2757: PUSH
2758: LD_INT 250
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 58
2767: PUSH
2768: EMPTY
2769: LIST
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: LIST
2775: LIST
2776: PPUSH
2777: NOP4
2781: PUSH
2782: LD_INT 0
2784: EQUAL
2785: IFFALSE 2480
// end ;
2787: LD_VAR 0 11
2791: RET
// every 0 0$1 do
2792: GO 2794
2794: DISABLE
// begin enable ;
2795: ENABLE
// end ;
2796: END
// export function BuildingVehicle ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2797: LD_INT 0
2799: PPUSH
2800: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2801: LD_INT 22
2803: PUSH
2804: NOP4
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: PUSH
2813: LD_INT 21
2815: PUSH
2816: LD_INT 2
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PUSH
2823: EMPTY
2824: LIST
2825: LIST
2826: PPUSH
2827: NOP4
2831: PUSH
2832: NOP4
2836: LESSEQUAL
2837: IFFALSE 2904
// for i = 1 to vehCount do
2839: NOP4
2843: PUSH
2844: DOUBLE
2845: LD_INT 1
2847: DEC
2848: ST_TO_ADDR
2849: NOP4
2853: PUSH
2854: FOR_TO
2855: IFFALSE 2902
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2857: NOP4
2861: PPUSH
2862: NOP4
2866: PPUSH
2867: NOP4
2871: PPUSH
2872: NOP4
2876: PPUSH
2877: NOP4
2881: PUSH
2882: LD_INT 1
2884: PPUSH
2885: NOP4
2889: PPUSH
2890: NOP4
2894: ARRAY
2895: PPUSH
2896: NOP4
2900: GO 2854
2902: POP
2903: POP
// end ;
2904: LD_VAR 0 8
2908: RET
// export function RepairVehicles ( side , area , repX , repY ) ; var i , j , damageVehicles ; begin
2909: LD_INT 0
2911: PPUSH
2912: PPUSH
2913: PPUSH
2914: PPUSH
// damageVehicles = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
2915: NOP4
2919: PUSH
2920: LD_INT 22
2922: PUSH
2923: NOP4
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: PUSH
2932: LD_INT 21
2934: PUSH
2935: LD_INT 2
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 3
2944: PUSH
2945: LD_INT 24
2947: PUSH
2948: LD_INT 650
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: PPUSH
2964: NOP4
2968: ST_TO_ADDR
// if damageVehicles > 0 then
2969: NOP4
2973: PUSH
2974: LD_INT 0
2976: GREATER
2977: IFFALSE 2998
// ComMoveXY ( damageVehicles , repX , repY ) ;
2979: NOP4
2983: PPUSH
2984: NOP4
2988: PPUSH
2989: NOP4
2993: PPUSH
2994: NOP4
// if UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) > 0 then
2998: NOP4
3002: PPUSH
3003: LD_INT 95
3005: PUSH
3006: NOP4
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 3
3017: PUSH
3018: LD_INT 58
3020: PUSH
3021: EMPTY
3022: LIST
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: PPUSH
3032: NOP4
3036: PUSH
3037: LD_INT 0
3039: GREATER
3040: IFFALSE 3107
// for i in UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) do
3042: NOP4
3046: PUSH
3047: NOP4
3051: PPUSH
3052: LD_INT 95
3054: PUSH
3055: NOP4
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 58
3069: PUSH
3070: EMPTY
3071: LIST
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PPUSH
3081: NOP4
3085: PUSH
3086: FOR_IN
3087: IFFALSE 3105
// ComExitVehicle ( UnitsInside ( i ) ) ;
3089: NOP4
3093: PPUSH
3094: NOP4
3098: PPUSH
3099: NOP4
3103: GO 3086
3105: POP
3106: POP
// end ;
3107: LD_VAR 0 5
3111: RET
// export function AttackVehicles ( side , meetArea , wayX , wayY ) ; var i , j , vehiclesOK , target1 , target2 , seeEnemy ; begin
3112: LD_INT 0
3114: PPUSH
3115: PPUSH
3116: PPUSH
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
3121: NOP4
3125: PUSH
3126: LD_INT 22
3128: PUSH
3129: NOP4
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: PUSH
3138: LD_INT 21
3140: PUSH
3141: LD_INT 2
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: LD_INT 24
3150: PUSH
3151: LD_INT 650
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: LIST
3162: PPUSH
3163: NOP4
3167: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 5 then
3168: LD_INT 22
3170: PUSH
3171: NOP4
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: PUSH
3180: LD_INT 21
3182: PUSH
3183: LD_INT 2
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PUSH
3190: LD_INT 24
3192: PUSH
3193: LD_INT 1000
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: NOP4
3209: PUSH
3210: LD_INT 5
3212: EQUAL
3213: IFFALSE 3670
// repeat wait ( 0 0$1 ) ;
3215: LD_INT 35
3217: PPUSH
3218: NOP4
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
3222: NOP4
3226: PUSH
3227: LD_INT 22
3229: PUSH
3230: NOP4
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: PUSH
3239: LD_INT 21
3241: PUSH
3242: LD_INT 2
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: PUSH
3249: LD_INT 24
3251: PUSH
3252: LD_INT 650
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: LIST
3263: PPUSH
3264: NOP4
3268: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) and seeEnemy = 0 then
3269: LD_INT 22
3271: PUSH
3272: NOP4
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 95
3283: PUSH
3284: NOP4
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: PPUSH
3297: NOP4
3301: NOT
3302: PUSH
3303: NOP4
3307: PUSH
3308: LD_INT 0
3310: EQUAL
3311: AND
3312: IFFALSE 3367
// for i := 1 to wayX do
3314: NOP4
3318: PUSH
3319: DOUBLE
3320: LD_INT 1
3322: DEC
3323: ST_TO_ADDR
3324: NOP4
3328: PUSH
3329: FOR_TO
3330: IFFALSE 3365
// AddComAgressiveMove ( vehiclesOK , wayX [ i ] , wayY [ i ] ) ;
3332: NOP4
3336: PPUSH
3337: NOP4
3341: PUSH
3342: NOP4
3346: ARRAY
3347: PPUSH
3348: NOP4
3352: PUSH
3353: NOP4
3357: ARRAY
3358: PPUSH
3359: NOP4
3363: GO 3329
3365: POP
3366: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) then
3367: LD_INT 22
3369: PUSH
3370: NOP4
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 95
3381: PUSH
3382: NOP4
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: PPUSH
3395: NOP4
3399: IFFALSE 3623
// begin seeEnemy = 1 ;
3401: NOP4
3405: PUSH
3406: LD_INT 1
3408: ST_TO_ADDR
// for j in vehiclesOK do
3409: NOP4
3413: PUSH
3414: NOP4
3418: PUSH
3419: FOR_IN
3420: IFFALSE 3621
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , side ] , [ f_see , 1 ] ] ) , j ) ;
3422: NOP4
3426: PUSH
3427: LD_INT 81
3429: PUSH
3430: NOP4
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 101
3441: PUSH
3442: LD_INT 1
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: PPUSH
3453: NOP4
3457: PPUSH
3458: NOP4
3462: PPUSH
3463: NOP4
3467: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_see , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , j ) ;
3468: NOP4
3472: PUSH
3473: LD_INT 81
3475: PUSH
3476: NOP4
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: PUSH
3485: LD_INT 101
3487: PUSH
3488: LD_INT 1
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: PUSH
3495: LD_INT 2
3497: PUSH
3498: LD_INT 59
3500: PUSH
3501: EMPTY
3502: LIST
3503: PUSH
3504: LD_INT 21
3506: PUSH
3507: LD_INT 1
3509: PUSH
3510: EMPTY
3511: LIST
3512: LIST
3513: PUSH
3514: LD_INT 21
3516: PUSH
3517: LD_INT 2
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: PUSH
3524: EMPTY
3525: LIST
3526: LIST
3527: LIST
3528: LIST
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: LIST
3534: PUSH
3535: EMPTY
3536: LIST
3537: PPUSH
3538: NOP4
3542: PPUSH
3543: NOP4
3547: PPUSH
3548: NOP4
3552: ST_TO_ADDR
// if GetDistUnits ( j , target1 ) + 8 < GetDistUnits ( j , target2 ) then
3553: NOP4
3557: PPUSH
3558: NOP4
3562: PPUSH
3563: NOP4
3567: PUSH
3568: LD_INT 8
3570: PLUS
3571: PUSH
3572: NOP4
3576: PPUSH
3577: NOP4
3581: PPUSH
3582: NOP4
3586: LESS
3587: IFFALSE 3605
// ComAttackUnit ( j , target1 ) else
3589: NOP4
3593: PPUSH
3594: NOP4
3598: PPUSH
3599: NOP4
3603: GO 3619
// ComAttackUnit ( j , target2 ) ;
3605: NOP4
3609: PPUSH
3610: NOP4
3614: PPUSH
3615: NOP4
// end ;
3619: GO 3419
3621: POP
3622: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 0 ;
3623: LD_INT 22
3625: PUSH
3626: NOP4
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 21
3637: PUSH
3638: LD_INT 2
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 24
3647: PUSH
3648: LD_INT 1000
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: LIST
3659: PPUSH
3660: NOP4
3664: PUSH
3665: LD_INT 0
3667: EQUAL
3668: IFFALSE 3215
// seeEnemy = 0 ;
3670: NOP4
3674: PUSH
3675: LD_INT 0
3677: ST_TO_ADDR
// end ;
3678: LD_VAR 0 5
3682: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3683: LD_INT 0
3685: PPUSH
3686: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3687: LD_INT 22
3689: PUSH
3690: NOP4
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 25
3701: PUSH
3702: LD_INT 2
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PPUSH
3713: NOP4
3717: PUSH
3718: LD_INT 0
3720: GREATER
3721: PUSH
3722: LD_INT 22
3724: PUSH
3725: NOP4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 21
3736: PUSH
3737: LD_INT 3
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: LD_INT 3
3746: PUSH
3747: LD_INT 24
3749: PUSH
3750: LD_INT 1000
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: EMPTY
3758: LIST
3759: LIST
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: LIST
3765: PPUSH
3766: NOP4
3770: PUSH
3771: LD_INT 0
3773: EQUAL
3774: AND
3775: PUSH
3776: NOP4
3780: PUSH
3781: LD_INT 0
3783: GREATER
3784: AND
3785: IFFALSE 3884
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3787: NOP4
3791: PUSH
3792: LD_INT 22
3794: PUSH
3795: NOP4
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: PUSH
3804: LD_INT 25
3806: PUSH
3807: LD_INT 2
3809: PUSH
3810: EMPTY
3811: LIST
3812: LIST
3813: PUSH
3814: EMPTY
3815: LIST
3816: LIST
3817: PPUSH
3818: NOP4
3822: PUSH
3823: FOR_IN
3824: IFFALSE 3882
// begin AddComExitBuilding ( i ) ;
3826: NOP4
3830: PPUSH
3831: NOP4
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3835: NOP4
3839: PPUSH
3840: NOP4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: PPUSH
3849: NOP4
3853: PUSH
3854: LD_INT 2
3856: ARRAY
3857: PPUSH
3858: NOP4
3862: PUSH
3863: LD_INT 3
3865: ARRAY
3866: PPUSH
3867: NOP4
3871: PUSH
3872: LD_INT 4
3874: ARRAY
3875: PPUSH
3876: NOP4
// end ;
3880: GO 3823
3882: POP
3883: POP
// end ; end ;
3884: LD_VAR 0 3
3888: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3889: LD_INT 0
3891: PPUSH
3892: PPUSH
3893: PPUSH
3894: PPUSH
3895: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3896: NOP4
3900: PUSH
3901: LD_INT 22
3903: PUSH
3904: NOP4
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: LD_INT 30
3918: PUSH
3919: LD_INT 31
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 30
3928: PUSH
3929: LD_INT 32
3931: PUSH
3932: EMPTY
3933: LIST
3934: LIST
3935: PUSH
3936: LD_INT 30
3938: PUSH
3939: LD_INT 33
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PUSH
3946: LD_INT 30
3948: PUSH
3949: LD_INT 4
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 30
3958: PUSH
3959: LD_INT 5
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: LIST
3970: LIST
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: NOP4
3982: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3983: NOP4
3987: PUSH
3988: LD_INT 22
3990: PUSH
3991: NOP4
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: PUSH
4000: LD_INT 21
4002: PUSH
4003: LD_INT 3
4005: PUSH
4006: EMPTY
4007: LIST
4008: LIST
4009: PUSH
4010: LD_INT 58
4012: PUSH
4013: EMPTY
4014: LIST
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: LIST
4020: PPUSH
4021: NOP4
4025: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
4026: NOP4
4030: PUSH
4031: LD_INT 0
4033: GREATER
4034: PUSH
4035: NOP4
4039: PUSH
4040: LD_INT 0
4042: GREATER
4043: AND
4044: IFFALSE 4114
// begin for i in turretsList do
4046: NOP4
4050: PUSH
4051: NOP4
4055: PUSH
4056: FOR_IN
4057: IFFALSE 4112
// begin for j in enemyBuildings do
4059: NOP4
4063: PUSH
4064: NOP4
4068: PUSH
4069: FOR_IN
4070: IFFALSE 4108
// begin if GetDistUnits ( i , j ) < 20 then
4072: NOP4
4076: PPUSH
4077: NOP4
4081: PPUSH
4082: NOP4
4086: PUSH
4087: LD_INT 20
4089: LESS
4090: IFFALSE 4106
// begin ComAttackUnit ( i , j ) ;
4092: NOP4
4096: PPUSH
4097: NOP4
4101: PPUSH
4102: NOP4
// end ; end ;
4106: GO 4069
4108: POP
4109: POP
// end ;
4110: GO 4056
4112: POP
4113: POP
// end ; end ;
4114: LD_VAR 0 3
4118: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
4119: LD_INT 0
4121: PPUSH
4122: PPUSH
4123: PPUSH
4124: PPUSH
4125: PPUSH
4126: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
4127: NOP4
4131: PUSH
4132: LD_INT 22
4134: PUSH
4135: NOP4
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 25
4146: PUSH
4147: LD_INT 9
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: PPUSH
4158: NOP4
4162: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4163: NOP4
4167: PUSH
4168: LD_INT 22
4170: PUSH
4171: NOP4
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: PUSH
4180: LD_INT 3
4182: PUSH
4183: LD_INT 21
4185: PUSH
4186: LD_INT 3
4188: PUSH
4189: EMPTY
4190: LIST
4191: LIST
4192: PUSH
4193: EMPTY
4194: LIST
4195: LIST
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: PPUSH
4201: NOP4
4205: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
4206: NOP4
4210: PUSH
4211: LD_INT 1
4213: PPUSH
4214: LD_INT 3
4216: PPUSH
4217: NOP4
4221: ST_TO_ADDR
// for i = 1 to list do
4222: NOP4
4226: PUSH
4227: DOUBLE
4228: LD_INT 1
4230: DEC
4231: ST_TO_ADDR
4232: NOP4
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4420
// for ta in filter do
4240: NOP4
4244: PUSH
4245: NOP4
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4416
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
4253: NOP4
4257: PUSH
4258: NOP4
4262: ARRAY
4263: PPUSH
4264: NOP4
4268: PPUSH
4269: NOP4
4273: PUSH
4274: LD_INT 13
4276: LESSEQUAL
4277: IFFALSE 4414
// begin case c of 1 :
4279: NOP4
4283: PUSH
4284: LD_INT 1
4286: DOUBLE
4287: EQUAL
4288: IFTRUE 4292
4290: GO 4330
4292: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4293: NOP4
4297: PUSH
4298: NOP4
4302: ARRAY
4303: PPUSH
4304: NOP4
4308: PPUSH
4309: NOP4
4313: PPUSH
4314: NOP4
4318: PPUSH
4319: NOP4
4323: PPUSH
4324: NOP4
4328: GO 4414
4330: LD_INT 2
4332: DOUBLE
4333: EQUAL
4334: IFTRUE 4338
4336: GO 4402
4338: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4339: NOP4
4343: PUSH
4344: NOP4
4348: ARRAY
4349: PPUSH
4350: NOP4
4354: PPUSH
4355: NOP4
4359: PUSH
4360: LD_INT 1
4362: NEG
4363: PPUSH
4364: LD_INT 1
4366: PPUSH
4367: NOP4
4371: PLUS
4372: PPUSH
4373: NOP4
4377: PPUSH
4378: NOP4
4382: PUSH
4383: LD_INT 1
4385: NEG
4386: PPUSH
4387: LD_INT 1
4389: PPUSH
4390: NOP4
4394: PLUS
4395: PPUSH
4396: NOP4
4400: GO 4414
4402: LD_INT 3
4404: DOUBLE
4405: EQUAL
4406: IFTRUE 4410
4408: GO 4413
4410: POP
// ; end ;
4411: GO 4414
4413: POP
// end ; end ;
4414: GO 4250
4416: POP
4417: POP
4418: GO 4237
4420: POP
4421: POP
// end ;
4422: LD_VAR 0 3
4426: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
4427: LD_INT 0
4429: PPUSH
4430: PPUSH
4431: PPUSH
4432: PPUSH
4433: PPUSH
4434: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
4435: NOP4
4439: PUSH
4440: NOP4
4444: PPUSH
4445: NOP4
4449: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
4450: NOP4
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: NOP4
4462: PUSH
4463: EMPTY
4464: LIST
4465: LIST
4466: PUSH
4467: LD_INT 25
4469: PUSH
4470: LD_INT 2
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PUSH
4477: LD_INT 24
4479: PUSH
4480: LD_INT 1000
4482: PUSH
4483: EMPTY
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 3
4489: PUSH
4490: LD_INT 54
4492: PUSH
4493: EMPTY
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PPUSH
4506: NOP4
4510: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4511: NOP4
4515: PUSH
4516: LD_INT 22
4518: PUSH
4519: NOP4
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 3
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: LD_INT 3
4540: PUSH
4541: LD_INT 24
4543: PUSH
4544: LD_INT 1000
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: LIST
4559: PUSH
4560: EMPTY
4561: LIST
4562: PPUSH
4563: NOP4
4567: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4568: NOP4
4572: NOT
4573: PUSH
4574: NOP4
4578: NOT
4579: AND
4580: PUSH
4581: NOP4
4585: NOT
4586: AND
4587: IFFALSE 4591
// exit ;
4589: GO 4710
// if buildings_list > 0 and engineerOkInside then
4591: NOP4
4595: PUSH
4596: LD_INT 0
4598: GREATER
4599: PUSH
4600: NOP4
4604: AND
4605: IFFALSE 4638
// for i in UnitsInside ( building ) do
4607: NOP4
4611: PUSH
4612: NOP4
4616: PPUSH
4617: NOP4
4621: PUSH
4622: FOR_IN
4623: IFFALSE 4636
// ComExitBuilding ( i ) ;
4625: NOP4
4629: PPUSH
4630: NOP4
4634: GO 4622
4636: POP
4637: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4638: NOP4
4642: PUSH
4643: LD_INT 0
4645: GREATER
4646: PUSH
4647: NOP4
4651: PUSH
4652: LD_INT 0
4654: GREATER
4655: AND
4656: IFFALSE 4710
// begin for i in engineerOkOutside do
4658: NOP4
4662: PUSH
4663: NOP4
4667: PUSH
4668: FOR_IN
4669: IFFALSE 4708
// for j in buildings_list do
4671: NOP4
4675: PUSH
4676: NOP4
4680: PUSH
4681: FOR_IN
4682: IFFALSE 4704
// ComRepairBuilding ( i , j [ 1 ] ) ;
4684: NOP4
4688: PPUSH
4689: NOP4
4693: PUSH
4694: LD_INT 1
4696: ARRAY
4697: PPUSH
4698: NOP4
4702: GO 4681
4704: POP
4705: POP
4706: GO 4668
4708: POP
4709: POP
// end ; end ;
4710: LD_VAR 0 3
4714: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4715: LD_INT 0
4717: PPUSH
4718: PPUSH
4719: PPUSH
4720: PPUSH
4721: PPUSH
4722: PPUSH
4723: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4724: NOP4
4728: PUSH
4729: LD_INT 22
4731: PUSH
4732: NOP4
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: PUSH
4741: LD_INT 25
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: PUSH
4751: LD_INT 24
4753: PUSH
4754: LD_INT 251
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: LIST
4765: PPUSH
4766: NOP4
4770: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4771: NOP4
4775: PUSH
4776: NOP4
4780: PPUSH
4781: LD_INT 22
4783: PUSH
4784: NOP4
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: LD_INT 25
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: PUSH
4803: LD_INT 50
4805: PUSH
4806: EMPTY
4807: LIST
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: LIST
4813: PPUSH
4814: NOP4
4818: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4819: NOP4
4823: PUSH
4824: NOP4
4828: PPUSH
4829: LD_INT 22
4831: PUSH
4832: NOP4
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PUSH
4841: LD_INT 21
4843: PUSH
4844: LD_INT 1
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: LD_INT 24
4856: PUSH
4857: LD_INT 750
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: NOP4
4877: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4878: NOP4
4882: PUSH
4883: NOP4
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: NOP4
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: LD_INT 21
4902: PUSH
4903: LD_INT 1
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 3
4912: PUSH
4913: LD_INT 24
4915: PUSH
4916: LD_INT 1000
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: LIST
4931: PPUSH
4932: NOP4
4936: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
4937: NOP4
4941: NOT
4942: PUSH
4943: NOP4
4947: NOT
4948: AND
4949: PUSH
4950: NOP4
4954: NOT
4955: AND
4956: IFFALSE 4960
// exit ;
4958: GO 5149
// if damageUnits > 0 and sci_list > 0 then
4960: NOP4
4964: PUSH
4965: LD_INT 0
4967: GREATER
4968: PUSH
4969: NOP4
4973: PUSH
4974: LD_INT 0
4976: GREATER
4977: AND
4978: IFFALSE 5011
// for i in damageUnits do
4980: NOP4
4984: PUSH
4985: NOP4
4989: PUSH
4990: FOR_IN
4991: IFFALSE 5009
// ComMoveToArea ( i , healArea ) ;
4993: NOP4
4997: PPUSH
4998: NOP4
5002: PPUSH
5003: NOP4
5007: GO 4990
5009: POP
5010: POP
// if unitsToHeal > 0 and sci_list > 0 then
5011: NOP4
5015: PUSH
5016: LD_INT 0
5018: GREATER
5019: PUSH
5020: NOP4
5024: PUSH
5025: LD_INT 0
5027: GREATER
5028: AND
5029: IFFALSE 5088
// begin for i in sci_list do
5031: NOP4
5035: PUSH
5036: NOP4
5040: PUSH
5041: FOR_IN
5042: IFFALSE 5086
// begin ComExitBuilding ( i ) ;
5044: NOP4
5048: PPUSH
5049: NOP4
// for j in unitsToHeal do
5053: NOP4
5057: PUSH
5058: NOP4
5062: PUSH
5063: FOR_IN
5064: IFFALSE 5082
// AddComHeal ( i , j ) ;
5066: NOP4
5070: PPUSH
5071: NOP4
5075: PPUSH
5076: NOP4
5080: GO 5063
5082: POP
5083: POP
// end ;
5084: GO 5041
5086: POP
5087: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
5088: NOP4
5092: PUSH
5093: LD_INT 0
5095: EQUAL
5096: PUSH
5097: NOP4
5101: PUSH
5102: LD_INT 0
5104: EQUAL
5105: AND
5106: PUSH
5107: NOP4
5111: PUSH
5112: LD_INT 0
5114: GREATER
5115: AND
5116: IFFALSE 5149
// for i in sci_listOutside do
5118: NOP4
5122: PUSH
5123: NOP4
5127: PUSH
5128: FOR_IN
5129: IFFALSE 5147
// ComEnterUnit ( i , build ) ;
5131: NOP4
5135: PPUSH
5136: NOP4
5140: PPUSH
5141: NOP4
5145: GO 5128
5147: POP
5148: POP
// end ;
5149: LD_VAR 0 5
5153: RET
// export function CraneRepairBuild ( side , repairArea , destroyedBuildings ) ; var i , mechTmp , vehicleTmp , crane_list , buildings_list ; begin
5154: LD_INT 0
5156: PPUSH
5157: PPUSH
5158: PPUSH
5159: PPUSH
5160: PPUSH
5161: PPUSH
// crane_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_crane ] ] ) ;
5162: NOP4
5166: PUSH
5167: LD_INT 22
5169: PUSH
5170: NOP4
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: PUSH
5179: LD_INT 21
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PUSH
5189: LD_INT 34
5191: PUSH
5192: LD_INT 52
5194: PUSH
5195: EMPTY
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: PPUSH
5204: NOP4
5208: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
5209: NOP4
5213: PUSH
5214: LD_INT 22
5216: PUSH
5217: NOP4
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 21
5228: PUSH
5229: LD_INT 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 3
5238: PUSH
5239: LD_INT 24
5241: PUSH
5242: LD_INT 1000
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: LIST
5257: PUSH
5258: EMPTY
5259: LIST
5260: PPUSH
5261: NOP4
5265: ST_TO_ADDR
// if buildings_list > 0 and UnitFilter ( crane_list , [ f_lives , 750 ] ) > 0 then
5266: NOP4
5270: PUSH
5271: LD_INT 0
5273: GREATER
5274: PUSH
5275: NOP4
5279: PPUSH
5280: LD_INT 24
5282: PUSH
5283: LD_INT 750
5285: PUSH
5286: EMPTY
5287: LIST
5288: LIST
5289: PPUSH
5290: NOP4
5294: PUSH
5295: LD_INT 0
5297: GREATER
5298: AND
5299: IFFALSE 5334
// ComRepairBuilding ( UnitFilter ( crane_list , [ f_lives , 750 ] ) , buildings_list [ 1 ] ) ;
5301: NOP4
5305: PPUSH
5306: LD_INT 24
5308: PUSH
5309: LD_INT 750
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PPUSH
5316: NOP4
5320: PPUSH
5321: NOP4
5325: PUSH
5326: LD_INT 1
5328: ARRAY
5329: PPUSH
5330: NOP4
// if UnitFilter ( crane_list , [ f_not , [ f_lives , 750 ] ] ) > 0 then
5334: NOP4
5338: PPUSH
5339: LD_INT 3
5341: PUSH
5342: LD_INT 24
5344: PUSH
5345: LD_INT 750
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: PPUSH
5356: NOP4
5360: PUSH
5361: LD_INT 0
5363: GREATER
5364: IFFALSE 5402
// ComMoveToArea ( UnitFilter ( crane_list , [ f_not , [ f_lives , 750 ] ] ) , repairArea ) ;
5366: NOP4
5370: PPUSH
5371: LD_INT 3
5373: PUSH
5374: LD_INT 24
5376: PUSH
5377: LD_INT 750
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PPUSH
5388: NOP4
5392: PPUSH
5393: NOP4
5397: PPUSH
5398: NOP4
// if crane_list > 0 and buildings_list = 0 and destroyedBuildings > 0 then
5402: NOP4
5406: PUSH
5407: LD_INT 0
5409: GREATER
5410: PUSH
5411: NOP4
5415: PUSH
5416: LD_INT 0
5418: EQUAL
5419: AND
5420: PUSH
5421: NOP4
5425: PUSH
5426: LD_INT 0
5428: GREATER
5429: AND
5430: IFFALSE 5477
// AddComCraneBuild ( crane_list , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
5432: NOP4
5436: PPUSH
5437: NOP4
5441: PUSH
5442: LD_INT 1
5444: ARRAY
5445: PPUSH
5446: NOP4
5450: PUSH
5451: LD_INT 2
5453: ARRAY
5454: PPUSH
5455: NOP4
5459: PUSH
5460: LD_INT 3
5462: ARRAY
5463: PPUSH
5464: NOP4
5468: PUSH
5469: LD_INT 4
5471: ARRAY
5472: PPUSH
5473: NOP4
// if FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_crane ] , [ f_not , [ f_lives , 750 ] ] ] ) > 0 then
5477: NOP4
5481: PPUSH
5482: LD_INT 22
5484: PUSH
5485: NOP4
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 21
5496: PUSH
5497: LD_INT 2
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: PUSH
5504: LD_INT 34
5506: PUSH
5507: LD_INT 52
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: PUSH
5514: LD_INT 3
5516: PUSH
5517: LD_INT 24
5519: PUSH
5520: LD_INT 750
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PPUSH
5537: NOP4
5541: PUSH
5542: LD_INT 0
5544: GREATER
5545: IFFALSE 5747
// begin for i in FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_crane ] , [ f_not , [ f_lives , 750 ] ] ] ) do
5547: NOP4
5551: PUSH
5552: NOP4
5556: PPUSH
5557: LD_INT 22
5559: PUSH
5560: NOP4
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 2
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PUSH
5579: LD_INT 34
5581: PUSH
5582: LD_INT 52
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 3
5591: PUSH
5592: LD_INT 24
5594: PUSH
5595: LD_INT 750
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PPUSH
5612: NOP4
5616: PUSH
5617: FOR_IN
5618: IFFALSE 5745
// begin mechTmp = UnitsInside ( i ) ;
5620: NOP4
5624: PUSH
5625: NOP4
5629: PPUSH
5630: NOP4
5634: ST_TO_ADDR
// ComExitVehicle ( mechTmp ) ;
5635: NOP4
5639: PPUSH
5640: NOP4
// AddComRepairVehicle ( mechTmp , vehicleTmp ) ;
5644: NOP4
5648: PPUSH
5649: NOP4
5653: PPUSH
5654: NOP4
// wait ( 0 0$2 ) ;
5658: LD_INT 70
5660: PPUSH
5661: NOP4
// AddComEnterUnit ( mechTmp , FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_crane ] , [ f_lives , 1000 ] , [ f_empty ] ] ) [ 1 ] ) ;
5665: NOP4
5669: PPUSH
5670: NOP4
5674: PPUSH
5675: LD_INT 22
5677: PUSH
5678: NOP4
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: PUSH
5687: LD_INT 21
5689: PUSH
5690: LD_INT 2
5692: PUSH
5693: EMPTY
5694: LIST
5695: LIST
5696: PUSH
5697: LD_INT 34
5699: PUSH
5700: LD_INT 52
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 24
5709: PUSH
5710: LD_INT 1000
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: PUSH
5717: LD_INT 58
5719: PUSH
5720: EMPTY
5721: LIST
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: NOP4
5734: PUSH
5735: LD_INT 1
5737: ARRAY
5738: PPUSH
5739: NOP4
// end ;
5743: GO 5617
5745: POP
5746: POP
// end ; end ; end_of_file
5747: LD_VAR 0 4
5751: RET
// on UnitDestroyed ( un ) do var i ;
5752: LD_INT 0
5754: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5755: NOP4
5759: PPUSH
5760: NOP4
5764: PUSH
5765: LD_INT 3
5767: EQUAL
5768: PUSH
5769: NOP4
5773: PPUSH
5774: NOP4
5778: PUSH
5779: LD_INT 3
5781: EQUAL
5782: AND
5783: IFFALSE 6475
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5785: NOP4
5789: PPUSH
5790: NOP4
5794: PUSH
5795: LD_INT 31
5797: EQUAL
5798: PUSH
5799: NOP4
5803: PPUSH
5804: NOP4
5808: PUSH
5809: LD_INT 32
5811: EQUAL
5812: OR
5813: PUSH
5814: NOP4
5818: PPUSH
5819: NOP4
5823: PUSH
5824: LD_INT 36
5826: EQUAL
5827: OR
5828: PUSH
5829: NOP4
5833: PPUSH
5834: NOP4
5838: PUSH
5839: LD_INT 0
5841: EQUAL
5842: OR
5843: PUSH
5844: NOP4
5848: PPUSH
5849: NOP4
5853: PUSH
5854: LD_INT 24
5856: EQUAL
5857: OR
5858: PUSH
5859: NOP4
5863: PPUSH
5864: NOP4
5868: PUSH
5869: LD_INT 17
5871: EQUAL
5872: OR
5873: PUSH
5874: NOP4
5878: PPUSH
5879: NOP4
5883: PUSH
5884: LD_INT 25
5886: EQUAL
5887: OR
5888: PUSH
5889: NOP4
5893: PPUSH
5894: NOP4
5898: PUSH
5899: LD_INT 19
5901: EQUAL
5902: OR
5903: PUSH
5904: NOP4
5908: PPUSH
5909: NOP4
5913: PUSH
5914: LD_INT 20
5916: EQUAL
5917: OR
5918: PUSH
5919: NOP4
5923: PPUSH
5924: NOP4
5928: PUSH
5929: LD_INT 18
5931: EQUAL
5932: OR
5933: PUSH
5934: NOP4
5938: PPUSH
5939: NOP4
5943: PUSH
5944: LD_INT 21
5946: EQUAL
5947: OR
5948: PUSH
5949: NOP4
5953: PPUSH
5954: NOP4
5958: PUSH
5959: LD_INT 23
5961: EQUAL
5962: OR
5963: PUSH
5964: NOP4
5968: PPUSH
5969: NOP4
5973: PUSH
5974: LD_INT 16
5976: EQUAL
5977: OR
5978: PUSH
5979: NOP4
5983: PPUSH
5984: NOP4
5988: PUSH
5989: LD_INT 6
5991: EQUAL
5992: OR
5993: PUSH
5994: NOP4
5998: PPUSH
5999: NOP4
6003: PUSH
6004: LD_INT 29
6006: EQUAL
6007: OR
6008: PUSH
6009: NOP4
6013: PPUSH
6014: NOP4
6018: PUSH
6019: LD_INT 26
6021: EQUAL
6022: OR
6023: PUSH
6024: NOP4
6028: PPUSH
6029: NOP4
6033: PUSH
6034: LD_INT 30
6036: EQUAL
6037: OR
6038: PUSH
6039: NOP4
6043: PPUSH
6044: NOP4
6048: PUSH
6049: LD_INT 28
6051: EQUAL
6052: OR
6053: PUSH
6054: NOP4
6058: PPUSH
6059: NOP4
6063: PUSH
6064: LD_INT 27
6066: EQUAL
6067: OR
6068: PUSH
6069: NOP4
6073: PPUSH
6074: NOP4
6078: PUSH
6079: LD_INT 33
6081: EQUAL
6082: OR
6083: PUSH
6084: NOP4
6088: PPUSH
6089: NOP4
6093: PUSH
6094: LD_INT 2
6096: EQUAL
6097: OR
6098: PUSH
6099: NOP4
6103: PPUSH
6104: NOP4
6108: PUSH
6109: LD_INT 4
6111: EQUAL
6112: OR
6113: IFFALSE 6199
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
6115: NOP4
6119: PUSH
6120: NOP4
6124: PUSH
6125: NOP4
6129: PPUSH
6130: NOP4
6134: ADD
6135: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6136: NOP4
6140: PUSH
6141: NOP4
6145: PUSH
6146: NOP4
6150: PPUSH
6151: NOP4
6155: ADD
6156: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6157: NOP4
6161: PUSH
6162: NOP4
6166: PUSH
6167: NOP4
6171: PPUSH
6172: NOP4
6176: ADD
6177: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6178: NOP4
6182: PUSH
6183: NOP4
6187: PUSH
6188: NOP4
6192: PPUSH
6193: NOP4
6197: ADD
6198: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
6199: NOP4
6203: PPUSH
6204: NOP4
6208: PUSH
6209: LD_INT 1
6211: EQUAL
6212: IFFALSE 6291
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
6214: NOP4
6218: PUSH
6219: NOP4
6223: PUSH
6224: LD_INT 0
6226: ADD
6227: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6228: NOP4
6232: PUSH
6233: NOP4
6237: PUSH
6238: NOP4
6242: PPUSH
6243: NOP4
6247: ADD
6248: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6249: NOP4
6253: PUSH
6254: NOP4
6258: PUSH
6259: NOP4
6263: PPUSH
6264: NOP4
6268: ADD
6269: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6270: NOP4
6274: PUSH
6275: NOP4
6279: PUSH
6280: NOP4
6284: PPUSH
6285: NOP4
6289: ADD
6290: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
6291: NOP4
6295: PPUSH
6296: NOP4
6300: PUSH
6301: LD_INT 3
6303: EQUAL
6304: IFFALSE 6383
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
6306: NOP4
6310: PUSH
6311: NOP4
6315: PUSH
6316: LD_INT 2
6318: ADD
6319: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6320: NOP4
6324: PUSH
6325: NOP4
6329: PUSH
6330: NOP4
6334: PPUSH
6335: NOP4
6339: ADD
6340: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6341: NOP4
6345: PUSH
6346: NOP4
6350: PUSH
6351: NOP4
6355: PPUSH
6356: NOP4
6360: ADD
6361: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6362: NOP4
6366: PUSH
6367: NOP4
6371: PUSH
6372: NOP4
6376: PPUSH
6377: NOP4
6381: ADD
6382: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
6383: NOP4
6387: PPUSH
6388: NOP4
6392: PUSH
6393: LD_INT 5
6395: EQUAL
6396: IFFALSE 6475
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
6398: NOP4
6402: PUSH
6403: NOP4
6407: PUSH
6408: LD_INT 4
6410: ADD
6411: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6412: NOP4
6416: PUSH
6417: NOP4
6421: PUSH
6422: NOP4
6426: PPUSH
6427: NOP4
6431: ADD
6432: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6433: NOP4
6437: PUSH
6438: NOP4
6442: PUSH
6443: NOP4
6447: PPUSH
6448: NOP4
6452: ADD
6453: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6454: NOP4
6458: PUSH
6459: NOP4
6463: PUSH
6464: NOP4
6468: PPUSH
6469: NOP4
6473: ADD
6474: ST_TO_ADDR
// end ; end ; end ;
6475: PPOPN 2
6477: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6478: NOP4
6482: PPUSH
6483: NOP4
6487: PUSH
6488: LD_INT 3
6490: EQUAL
6491: IFFALSE 6565
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6493: NOP4
6497: PUSH
6498: NOP4
6502: PPUSH
6503: LD_INT 1
6505: PPUSH
6506: NOP4
6510: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6511: NOP4
6515: PUSH
6516: NOP4
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: NOP4
6528: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6529: NOP4
6533: PUSH
6534: NOP4
6538: PPUSH
6539: LD_INT 1
6541: PPUSH
6542: NOP4
6546: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6547: NOP4
6551: PUSH
6552: NOP4
6556: PPUSH
6557: LD_INT 1
6559: PPUSH
6560: NOP4
6564: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6565: NOP4
6569: PPUSH
6570: NOP4
6574: PUSH
6575: LD_INT 3
6577: EQUAL
6578: PUSH
6579: NOP4
6583: PPUSH
6584: NOP4
6588: PUSH
6589: LD_INT 0
6591: EQUAL
6592: PUSH
6593: NOP4
6597: PPUSH
6598: NOP4
6602: PUSH
6603: LD_INT 2
6605: EQUAL
6606: OR
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 4
6620: EQUAL
6621: OR
6622: PUSH
6623: EMPTY
6624: LIST
6625: AND
6626: IFFALSE 6637
// ComUpgrade ( building ) ;
6628: NOP4
6632: PPUSH
6633: NOP4
// end ;
6637: PPOPN 1
6639: END
// on LeaveVehicle ( vehicle , human ) do begin ComRepairVehicle ( human , vehicle ) ;
6640: NOP4
6644: PPUSH
6645: NOP4
6649: PPUSH
6650: NOP4
// AddComEnterUnit ( human , vehicle ) ;
6654: NOP4
6658: PPUSH
6659: NOP4
6663: PPUSH
6664: NOP4
// end ;
6668: PPOPN 2
6670: END
// on VehicleConstructed ( vehicle , building ) do begin end ;
6671: PPOPN 2
6673: END
// on Command ( command_id ) do begin end ;
6674: PPOPN 1
6676: END
