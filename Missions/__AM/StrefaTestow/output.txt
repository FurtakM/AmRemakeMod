// export destroyedBuildings ; export cargoTest ; export arabianMines ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// destroyedBuildings = [ ] ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// cargoTest = [ ] ;
  15: LD_ADDR_EXP 2
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// arabianMines = [ ] ;
  22: LD_ADDR_EXP 3
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// end ;
  29: END
// every 0 0$01 do var b ;
  30: GO 32
  32: DISABLE
  33: LD_INT 0
  35: PPUSH
// begin end ;
  36: PPOPN 1
  38: END
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
  39: LD_INT 0
  41: PPUSH
  42: PPUSH
  43: PPUSH
  44: PPUSH
// for i = 1 to 3 do
  45: LD_ADDR_VAR 0 5
  49: PUSH
  50: DOUBLE
  51: LD_INT 1
  53: DEC
  54: ST_TO_ADDR
  55: LD_INT 3
  57: PUSH
  58: FOR_TO
  59: IFFALSE 89
// amount := amount + GetResourceArea ( area , i ) ;
  61: LD_ADDR_VAR 0 4
  65: PUSH
  66: LD_VAR 0 4
  70: PUSH
  71: LD_VAR 0 1
  75: PPUSH
  76: LD_VAR 0 5
  80: PPUSH
  81: CALL_OW 287
  85: PLUS
  86: ST_TO_ADDR
  87: GO 58
  89: POP
  90: POP
// if amount < materials then
  91: LD_VAR 0 4
  95: PUSH
  96: LD_VAR 0 2
 100: LESS
 101: IFFALSE 105
// exit ;
 103: GO 139
// for i = 1 to 3 do
 105: LD_ADDR_VAR 0 5
 109: PUSH
 110: DOUBLE
 111: LD_INT 1
 113: DEC
 114: ST_TO_ADDR
 115: LD_INT 3
 117: PUSH
 118: FOR_TO
 119: IFFALSE 137
// EraseResourceArea ( area , i ) ;
 121: LD_VAR 0 1
 125: PPUSH
 126: LD_VAR 0 5
 130: PPUSH
 131: CALL_OW 286
 135: GO 118
 137: POP
 138: POP
// end ; end_of_file
 139: LD_VAR 0 3
 143: RET
// every 0 0$1 do
 144: GO 146
 146: DISABLE
// begin enable ;
 147: ENABLE
// RepairVehicle ( 3 , EnemyVehSpawn , 89 , 7 ) ;
 148: LD_INT 3
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: LD_INT 89
 156: PPUSH
 157: LD_INT 7
 159: PPUSH
 160: CALL 2904 0 4
// CheckMechanicsStatus ( 3 , EnemyVehSpawn ) ;
 164: LD_INT 3
 166: PPUSH
 167: LD_INT 2
 169: PPUSH
 170: CALL 3646 0 2
// EnemyVehicleAttack ( 3 , 1 ) ;
 174: LD_INT 3
 176: PPUSH
 177: LD_INT 1
 179: PPUSH
 180: CALL 2550 0 2
// end ;
 184: END
// every 5 5$1 do
 185: GO 187
 187: DISABLE
// begin BuildingVehicleAndAttackEnemy ( 3 , rufab , 4 , [ 42 ] , 1 , 1 , 23 ) ;
 188: LD_INT 3
 190: PPUSH
 191: LD_INT 30
 193: PPUSH
 194: LD_INT 4
 196: PPUSH
 197: LD_INT 42
 199: PUSH
 200: EMPTY
 201: LIST
 202: PPUSH
 203: LD_INT 1
 205: PPUSH
 206: LD_INT 1
 208: PPUSH
 209: LD_INT 23
 211: PPUSH
 212: CALL 2438 0 7
// end ;
 216: END
// every 0 0$01 trigger arabianMines do var i , p ;
 217: LD_EXP 3
 221: IFFALSE 424
 223: GO 225
 225: DISABLE
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
// begin enable ;
 230: ENABLE
// p := 1 ;
 231: LD_ADDR_VAR 0 2
 235: PUSH
 236: LD_INT 1
 238: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 239: LD_ADDR_VAR 0 1
 243: PUSH
 244: DOUBLE
 245: LD_INT 1
 247: DEC
 248: ST_TO_ADDR
 249: LD_EXP 3
 253: PUSH
 254: LD_INT 2
 256: DIVREAL
 257: PUSH
 258: FOR_TO
 259: IFFALSE 422
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 261: LD_INT 81
 263: PUSH
 264: LD_INT 2
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: PUSH
 271: LD_INT 92
 273: PUSH
 274: LD_EXP 3
 278: PUSH
 279: LD_VAR 0 2
 283: ARRAY
 284: PUSH
 285: LD_EXP 3
 289: PUSH
 290: LD_VAR 0 2
 294: PUSH
 295: LD_INT 1
 297: PLUS
 298: ARRAY
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: LIST
 307: LIST
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL_OW 69
 317: IFFALSE 406
// begin LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 319: LD_EXP 3
 323: PUSH
 324: LD_VAR 0 2
 328: ARRAY
 329: PPUSH
 330: LD_EXP 3
 334: PUSH
 335: LD_VAR 0 2
 339: PUSH
 340: LD_INT 1
 342: PLUS
 343: ARRAY
 344: PPUSH
 345: LD_INT 2
 347: PPUSH
 348: CALL_OW 456
// arabianMines := Delete ( arabianMines , p ) ;
 352: LD_ADDR_EXP 3
 356: PUSH
 357: LD_EXP 3
 361: PPUSH
 362: LD_VAR 0 2
 366: PPUSH
 367: CALL_OW 3
 371: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 372: LD_ADDR_EXP 3
 376: PUSH
 377: LD_EXP 3
 381: PPUSH
 382: LD_VAR 0 2
 386: PPUSH
 387: CALL_OW 3
 391: ST_TO_ADDR
// p := p - 2 ;
 392: LD_ADDR_VAR 0 2
 396: PUSH
 397: LD_VAR 0 2
 401: PUSH
 402: LD_INT 2
 404: MINUS
 405: ST_TO_ADDR
// end ; p := p + 2 ;
 406: LD_ADDR_VAR 0 2
 410: PUSH
 411: LD_VAR 0 2
 415: PUSH
 416: LD_INT 2
 418: PLUS
 419: ST_TO_ADDR
// end ;
 420: GO 258
 422: POP
 423: POP
// end ; end_of_file
 424: PPOPN 2
 426: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
 431: PPUSH
// rnd = rand ( 1 , characters ) ;
 432: LD_ADDR_VAR 0 6
 436: PUSH
 437: LD_INT 1
 439: PPUSH
 440: LD_VAR 0 1
 444: PPUSH
 445: CALL_OW 12
 449: ST_TO_ADDR
// for i = 1 to characters do
 450: LD_ADDR_VAR 0 5
 454: PUSH
 455: DOUBLE
 456: LD_INT 1
 458: DEC
 459: ST_TO_ADDR
 460: LD_VAR 0 1
 464: PUSH
 465: FOR_TO
 466: IFFALSE 576
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 468: LD_VAR 0 5
 472: PUSH
 473: LD_VAR 0 6
 477: EQUAL
 478: PUSH
 479: LD_VAR 0 1
 483: PUSH
 484: LD_VAR 0 5
 488: ARRAY
 489: PPUSH
 490: CALL_OW 258
 494: PUSH
 495: LD_INT 1
 497: EQUAL
 498: AND
 499: IFFALSE 521
// Say ( characters [ i ] , dialogMID ) ;
 501: LD_VAR 0 1
 505: PUSH
 506: LD_VAR 0 5
 510: ARRAY
 511: PPUSH
 512: LD_VAR 0 2
 516: PPUSH
 517: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 521: LD_VAR 0 5
 525: PUSH
 526: LD_VAR 0 6
 530: EQUAL
 531: PUSH
 532: LD_VAR 0 1
 536: PUSH
 537: LD_VAR 0 5
 541: ARRAY
 542: PPUSH
 543: CALL_OW 258
 547: PUSH
 548: LD_INT 2
 550: EQUAL
 551: AND
 552: IFFALSE 574
// Say ( characters [ i ] , dialogFID ) ;
 554: LD_VAR 0 1
 558: PUSH
 559: LD_VAR 0 5
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 3
 569: PPUSH
 570: CALL_OW 88
// end ;
 574: GO 465
 576: POP
 577: POP
// end ;
 578: LD_VAR 0 4
 582: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 583: LD_INT 0
 585: PPUSH
 586: PPUSH
 587: PPUSH
 588: PPUSH
// for i = 1 to count do
 589: LD_ADDR_VAR 0 8
 593: PUSH
 594: DOUBLE
 595: LD_INT 1
 597: DEC
 598: ST_TO_ADDR
 599: LD_VAR 0 6
 603: PUSH
 604: FOR_TO
 605: IFFALSE 686
// begin uc_side = side ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_VAR 0 1
 616: ST_TO_ADDR
// uc_nation = nation ;
 617: LD_ADDR_OWVAR 21
 621: PUSH
 622: LD_VAR 0 2
 626: ST_TO_ADDR
// hc_gallery =  ;
 627: LD_ADDR_OWVAR 33
 631: PUSH
 632: LD_STRING 
 634: ST_TO_ADDR
// hc_name =  ;
 635: LD_ADDR_OWVAR 26
 639: PUSH
 640: LD_STRING 
 642: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 643: LD_INT 0
 645: PPUSH
 646: LD_VAR 0 5
 650: PPUSH
 651: LD_VAR 0 4
 655: PPUSH
 656: CALL_OW 380
// un = CreateHuman ;
 660: LD_ADDR_VAR 0 10
 664: PUSH
 665: CALL_OW 44
 669: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 670: LD_VAR 0 10
 674: PPUSH
 675: LD_VAR 0 3
 679: PPUSH
 680: CALL_OW 52
// end ;
 684: GO 604
 686: POP
 687: POP
// end ;
 688: LD_VAR 0 7
 692: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 693: LD_INT 0
 695: PPUSH
 696: PPUSH
// for i in charactersList do
 697: LD_ADDR_VAR 0 4
 701: PUSH
 702: LD_VAR 0 1
 706: PUSH
 707: FOR_IN
 708: IFFALSE 748
// begin if IsOk ( i ) then
 710: LD_VAR 0 4
 714: PPUSH
 715: CALL_OW 302
 719: IFFALSE 737
// begin SaveCharacters ( i , ident ) ;
 721: LD_VAR 0 4
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: CALL_OW 38
// end else
 735: GO 746
// begin DeleteCharacters ( ident ) ;
 737: LD_VAR 0 2
 741: PPUSH
 742: CALL_OW 40
// end ; end ;
 746: GO 707
 748: POP
 749: POP
// end ;
 750: LD_VAR 0 3
 754: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 755: LD_INT 0
 757: PPUSH
 758: PPUSH
 759: PPUSH
 760: PPUSH
 761: PPUSH
 762: PPUSH
 763: PPUSH
 764: PPUSH
 765: PPUSH
 766: PPUSH
 767: PPUSH
// amChassisTab = [ ] ;
 768: LD_ADDR_VAR 0 19
 772: PUSH
 773: EMPTY
 774: ST_TO_ADDR
// arChassisTab = [ ] ;
 775: LD_ADDR_VAR 0 18
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// ruChassisTab = [ ] ;
 782: LD_ADDR_VAR 0 17
 786: PUSH
 787: EMPTY
 788: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 789: LD_INT 35
 791: PPUSH
 792: CALL_OW 67
// if nation = 1 then
 796: LD_VAR 0 5
 800: PUSH
 801: LD_INT 1
 803: EQUAL
 804: IFFALSE 1295
// begin uc_side = side ;
 806: LD_ADDR_OWVAR 20
 810: PUSH
 811: LD_VAR 0 2
 815: ST_TO_ADDR
// uc_nation = nation ;
 816: LD_ADDR_OWVAR 21
 820: PUSH
 821: LD_VAR 0 5
 825: ST_TO_ADDR
// vc_engine = vehengine ;
 826: LD_ADDR_OWVAR 39
 830: PUSH
 831: LD_VAR 0 6
 835: ST_TO_ADDR
// vc_control = vehcontrol ;
 836: LD_ADDR_OWVAR 38
 840: PUSH
 841: LD_VAR 0 7
 845: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 846: LD_ADDR_OWVAR 40
 850: PUSH
 851: LD_VAR 0 10
 855: PUSH
 856: LD_INT 1
 858: PPUSH
 859: LD_VAR 0 10
 863: PPUSH
 864: CALL_OW 12
 868: ARRAY
 869: ST_TO_ADDR
// for j = 1 to AMWeapon do
 870: LD_ADDR_VAR 0 14
 874: PUSH
 875: DOUBLE
 876: LD_INT 1
 878: DEC
 879: ST_TO_ADDR
 880: LD_VAR 0 10
 884: PUSH
 885: FOR_TO
 886: IFFALSE 1187
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 888: LD_VAR 0 10
 892: PUSH
 893: LD_VAR 0 14
 897: ARRAY
 898: PUSH
 899: LD_INT 2
 901: EQUAL
 902: PUSH
 903: LD_VAR 0 10
 907: PUSH
 908: LD_VAR 0 14
 912: ARRAY
 913: PUSH
 914: LD_INT 3
 916: EQUAL
 917: OR
 918: IFFALSE 971
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 920: LD_ADDR_VAR 0 19
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 4
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: LIST
 946: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 947: LD_ADDR_OWVAR 37
 951: PUSH
 952: LD_VAR 0 19
 956: PUSH
 957: LD_INT 1
 959: PPUSH
 960: LD_VAR 0 19
 964: PPUSH
 965: CALL_OW 12
 969: ARRAY
 970: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 971: LD_VAR 0 10
 975: PUSH
 976: LD_VAR 0 14
 980: ARRAY
 981: PUSH
 982: LD_INT 4
 984: EQUAL
 985: PUSH
 986: LD_VAR 0 10
 990: PUSH
 991: LD_VAR 0 14
 995: ARRAY
 996: PUSH
 997: LD_INT 5
 999: EQUAL
1000: OR
1001: PUSH
1002: LD_VAR 0 10
1006: PUSH
1007: LD_VAR 0 14
1011: ARRAY
1012: PUSH
1013: LD_INT 9
1015: EQUAL
1016: OR
1017: PUSH
1018: LD_VAR 0 10
1022: PUSH
1023: LD_VAR 0 14
1027: ARRAY
1028: PUSH
1029: LD_INT 11
1031: EQUAL
1032: OR
1033: PUSH
1034: LD_VAR 0 10
1038: PUSH
1039: LD_VAR 0 14
1043: ARRAY
1044: PUSH
1045: LD_INT 7
1047: EQUAL
1048: OR
1049: IFFALSE 1098
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1051: LD_ADDR_VAR 0 19
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: LD_INT 3
1061: PUSH
1062: LD_INT 4
1064: PUSH
1065: LD_INT 5
1067: PUSH
1068: EMPTY
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1074: LD_ADDR_OWVAR 37
1078: PUSH
1079: LD_VAR 0 19
1083: PUSH
1084: LD_INT 1
1086: PPUSH
1087: LD_VAR 0 19
1091: PPUSH
1092: CALL_OW 12
1096: ARRAY
1097: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
1098: LD_VAR 0 10
1102: PUSH
1103: LD_VAR 0 14
1107: ARRAY
1108: PUSH
1109: LD_INT 8
1111: EQUAL
1112: PUSH
1113: LD_VAR 0 10
1117: PUSH
1118: LD_VAR 0 14
1122: ARRAY
1123: PUSH
1124: LD_INT 6
1126: EQUAL
1127: OR
1128: PUSH
1129: LD_VAR 0 10
1133: PUSH
1134: LD_VAR 0 14
1138: ARRAY
1139: PUSH
1140: LD_INT 10
1142: EQUAL
1143: OR
1144: IFFALSE 1185
// begin amChassisTab = [ 4 , 5 ] ;
1146: LD_ADDR_VAR 0 19
1150: PUSH
1151: LD_INT 4
1153: PUSH
1154: LD_INT 5
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1161: LD_ADDR_OWVAR 37
1165: PUSH
1166: LD_VAR 0 19
1170: PUSH
1171: LD_INT 1
1173: PPUSH
1174: LD_VAR 0 19
1178: PPUSH
1179: CALL_OW 12
1183: ARRAY
1184: ST_TO_ADDR
// end ; end ;
1185: GO 885
1187: POP
1188: POP
// veh = CreateVehicle ;
1189: LD_ADDR_VAR 0 16
1193: PUSH
1194: CALL_OW 45
1198: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1199: LD_VAR 0 16
1203: PPUSH
1204: LD_VAR 0 1
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL_OW 49
// if vehControl = 1 then
1216: LD_VAR 0 7
1220: PUSH
1221: LD_INT 1
1223: EQUAL
1224: IFFALSE 1281
// begin hc_gallery =  ;
1226: LD_ADDR_OWVAR 33
1230: PUSH
1231: LD_STRING 
1233: ST_TO_ADDR
// hc_name =  ;
1234: LD_ADDR_OWVAR 26
1238: PUSH
1239: LD_STRING 
1241: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1242: LD_INT 0
1244: PPUSH
1245: LD_INT 3
1247: PPUSH
1248: LD_VAR 0 4
1252: PPUSH
1253: CALL_OW 380
// un = CreateHuman ;
1257: LD_ADDR_VAR 0 15
1261: PUSH
1262: CALL_OW 44
1266: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1267: LD_VAR 0 15
1271: PPUSH
1272: LD_VAR 0 16
1276: PPUSH
1277: CALL_OW 52
// end ; i = i + 1 ;
1281: LD_ADDR_VAR 0 13
1285: PUSH
1286: LD_VAR 0 13
1290: PUSH
1291: LD_INT 1
1293: PLUS
1294: ST_TO_ADDR
// end ; if nation = 2 then
1295: LD_VAR 0 5
1299: PUSH
1300: LD_INT 2
1302: EQUAL
1303: IFFALSE 1727
// begin uc_side = side ;
1305: LD_ADDR_OWVAR 20
1309: PUSH
1310: LD_VAR 0 2
1314: ST_TO_ADDR
// uc_nation = nation ;
1315: LD_ADDR_OWVAR 21
1319: PUSH
1320: LD_VAR 0 5
1324: ST_TO_ADDR
// vc_engine = vehengine ;
1325: LD_ADDR_OWVAR 39
1329: PUSH
1330: LD_VAR 0 6
1334: ST_TO_ADDR
// vc_control = vehcontrol ;
1335: LD_ADDR_OWVAR 38
1339: PUSH
1340: LD_VAR 0 7
1344: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1345: LD_ADDR_OWVAR 40
1349: PUSH
1350: LD_VAR 0 9
1354: PUSH
1355: LD_INT 1
1357: PPUSH
1358: LD_VAR 0 9
1362: PPUSH
1363: CALL_OW 12
1367: ARRAY
1368: ST_TO_ADDR
// for j = 1 to ARWeapons do
1369: LD_ADDR_VAR 0 14
1373: PUSH
1374: DOUBLE
1375: LD_INT 1
1377: DEC
1378: ST_TO_ADDR
1379: LD_VAR 0 9
1383: PUSH
1384: FOR_TO
1385: IFFALSE 1619
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1387: LD_VAR 0 9
1391: PUSH
1392: LD_VAR 0 14
1396: ARRAY
1397: PUSH
1398: LD_INT 24
1400: EQUAL
1401: PUSH
1402: LD_VAR 0 9
1406: PUSH
1407: LD_VAR 0 14
1411: ARRAY
1412: PUSH
1413: LD_INT 22
1415: EQUAL
1416: OR
1417: PUSH
1418: LD_VAR 0 9
1422: PUSH
1423: LD_VAR 0 14
1427: ARRAY
1428: PUSH
1429: LD_INT 23
1431: EQUAL
1432: OR
1433: PUSH
1434: LD_VAR 0 9
1438: PUSH
1439: LD_VAR 0 14
1443: ARRAY
1444: PUSH
1445: LD_INT 30
1447: EQUAL
1448: OR
1449: IFFALSE 1498
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1451: LD_ADDR_VAR 0 18
1455: PUSH
1456: LD_INT 11
1458: PUSH
1459: LD_INT 12
1461: PUSH
1462: LD_INT 13
1464: PUSH
1465: LD_INT 14
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1474: LD_ADDR_OWVAR 37
1478: PUSH
1479: LD_VAR 0 18
1483: PUSH
1484: LD_INT 1
1486: PPUSH
1487: LD_VAR 0 18
1491: PPUSH
1492: CALL_OW 12
1496: ARRAY
1497: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1498: LD_VAR 0 9
1502: PUSH
1503: LD_VAR 0 14
1507: ARRAY
1508: PUSH
1509: LD_INT 29
1511: EQUAL
1512: PUSH
1513: LD_VAR 0 9
1517: PUSH
1518: LD_VAR 0 14
1522: ARRAY
1523: PUSH
1524: LD_INT 28
1526: EQUAL
1527: OR
1528: PUSH
1529: LD_VAR 0 9
1533: PUSH
1534: LD_VAR 0 14
1538: ARRAY
1539: PUSH
1540: LD_INT 27
1542: EQUAL
1543: OR
1544: PUSH
1545: LD_VAR 0 9
1549: PUSH
1550: LD_VAR 0 14
1554: ARRAY
1555: PUSH
1556: LD_INT 26
1558: EQUAL
1559: OR
1560: PUSH
1561: LD_VAR 0 9
1565: PUSH
1566: LD_VAR 0 14
1570: ARRAY
1571: PUSH
1572: LD_INT 25
1574: EQUAL
1575: OR
1576: IFFALSE 1617
// begin arChassisTab = [ 13 , 14 ] ;
1578: LD_ADDR_VAR 0 18
1582: PUSH
1583: LD_INT 13
1585: PUSH
1586: LD_INT 14
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1593: LD_ADDR_OWVAR 37
1597: PUSH
1598: LD_VAR 0 18
1602: PUSH
1603: LD_INT 1
1605: PPUSH
1606: LD_VAR 0 18
1610: PPUSH
1611: CALL_OW 12
1615: ARRAY
1616: ST_TO_ADDR
// end ; end ;
1617: GO 1384
1619: POP
1620: POP
// veh = CreateVehicle ;
1621: LD_ADDR_VAR 0 16
1625: PUSH
1626: CALL_OW 45
1630: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1631: LD_VAR 0 16
1635: PPUSH
1636: LD_VAR 0 1
1640: PPUSH
1641: LD_INT 0
1643: PPUSH
1644: CALL_OW 49
// if vehcontrol = 1 then
1648: LD_VAR 0 7
1652: PUSH
1653: LD_INT 1
1655: EQUAL
1656: IFFALSE 1713
// begin hc_gallery =  ;
1658: LD_ADDR_OWVAR 33
1662: PUSH
1663: LD_STRING 
1665: ST_TO_ADDR
// hc_name =  ;
1666: LD_ADDR_OWVAR 26
1670: PUSH
1671: LD_STRING 
1673: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1674: LD_INT 0
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: LD_VAR 0 4
1684: PPUSH
1685: CALL_OW 380
// un = CreateHuman ;
1689: LD_ADDR_VAR 0 15
1693: PUSH
1694: CALL_OW 44
1698: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1699: LD_VAR 0 15
1703: PPUSH
1704: LD_VAR 0 16
1708: PPUSH
1709: CALL_OW 52
// end ; i = i + 1 ;
1713: LD_ADDR_VAR 0 13
1717: PUSH
1718: LD_VAR 0 13
1722: PUSH
1723: LD_INT 1
1725: PLUS
1726: ST_TO_ADDR
// end ; if nation = 3 then
1727: LD_VAR 0 5
1731: PUSH
1732: LD_INT 3
1734: EQUAL
1735: IFFALSE 2127
// begin uc_side = side ;
1737: LD_ADDR_OWVAR 20
1741: PUSH
1742: LD_VAR 0 2
1746: ST_TO_ADDR
// uc_nation = nation ;
1747: LD_ADDR_OWVAR 21
1751: PUSH
1752: LD_VAR 0 5
1756: ST_TO_ADDR
// vc_engine = vehengine ;
1757: LD_ADDR_OWVAR 39
1761: PUSH
1762: LD_VAR 0 6
1766: ST_TO_ADDR
// vc_control = vehcontrol ;
1767: LD_ADDR_OWVAR 38
1771: PUSH
1772: LD_VAR 0 7
1776: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1777: LD_ADDR_OWVAR 40
1781: PUSH
1782: LD_VAR 0 8
1786: PUSH
1787: LD_INT 1
1789: PPUSH
1790: LD_VAR 0 8
1794: PPUSH
1795: CALL_OW 12
1799: ARRAY
1800: ST_TO_ADDR
// for j = 1 to RuWeapons do
1801: LD_ADDR_VAR 0 14
1805: PUSH
1806: DOUBLE
1807: LD_INT 1
1809: DEC
1810: ST_TO_ADDR
1811: LD_VAR 0 8
1815: PUSH
1816: FOR_TO
1817: IFFALSE 2019
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1819: LD_VAR 0 8
1823: PUSH
1824: LD_VAR 0 14
1828: ARRAY
1829: PUSH
1830: LD_INT 42
1832: EQUAL
1833: PUSH
1834: LD_VAR 0 8
1838: PUSH
1839: LD_VAR 0 14
1843: ARRAY
1844: PUSH
1845: LD_INT 43
1847: EQUAL
1848: OR
1849: PUSH
1850: LD_VAR 0 8
1854: PUSH
1855: LD_VAR 0 14
1859: ARRAY
1860: PUSH
1861: LD_INT 44
1863: EQUAL
1864: OR
1865: PUSH
1866: LD_VAR 0 8
1870: PUSH
1871: LD_VAR 0 14
1875: ARRAY
1876: PUSH
1877: LD_INT 45
1879: EQUAL
1880: OR
1881: PUSH
1882: LD_VAR 0 8
1886: PUSH
1887: LD_VAR 0 14
1891: ARRAY
1892: PUSH
1893: LD_INT 49
1895: EQUAL
1896: OR
1897: IFFALSE 1946
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1899: LD_ADDR_VAR 0 17
1903: PUSH
1904: LD_INT 21
1906: PUSH
1907: LD_INT 22
1909: PUSH
1910: LD_INT 23
1912: PUSH
1913: LD_INT 24
1915: PUSH
1916: EMPTY
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1922: LD_ADDR_OWVAR 37
1926: PUSH
1927: LD_VAR 0 17
1931: PUSH
1932: LD_INT 1
1934: PPUSH
1935: LD_VAR 0 17
1939: PPUSH
1940: CALL_OW 12
1944: ARRAY
1945: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1946: LD_VAR 0 8
1950: PUSH
1951: LD_VAR 0 14
1955: ARRAY
1956: PUSH
1957: LD_INT 46
1959: EQUAL
1960: PUSH
1961: LD_VAR 0 8
1965: PUSH
1966: LD_VAR 0 14
1970: ARRAY
1971: PUSH
1972: LD_INT 47
1974: EQUAL
1975: OR
1976: IFFALSE 2017
// begin ruChassisTab = [ 23 , 24 ] ;
1978: LD_ADDR_VAR 0 17
1982: PUSH
1983: LD_INT 23
1985: PUSH
1986: LD_INT 24
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1993: LD_ADDR_OWVAR 37
1997: PUSH
1998: LD_VAR 0 17
2002: PUSH
2003: LD_INT 1
2005: PPUSH
2006: LD_VAR 0 17
2010: PPUSH
2011: CALL_OW 12
2015: ARRAY
2016: ST_TO_ADDR
// end ; end ;
2017: GO 1816
2019: POP
2020: POP
// veh = CreateVehicle ;
2021: LD_ADDR_VAR 0 16
2025: PUSH
2026: CALL_OW 45
2030: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2031: LD_VAR 0 16
2035: PPUSH
2036: LD_VAR 0 1
2040: PPUSH
2041: LD_INT 0
2043: PPUSH
2044: CALL_OW 49
// if vehcontrol = 1 then
2048: LD_VAR 0 7
2052: PUSH
2053: LD_INT 1
2055: EQUAL
2056: IFFALSE 2113
// begin hc_gallery =  ;
2058: LD_ADDR_OWVAR 33
2062: PUSH
2063: LD_STRING 
2065: ST_TO_ADDR
// hc_name =  ;
2066: LD_ADDR_OWVAR 26
2070: PUSH
2071: LD_STRING 
2073: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2074: LD_INT 0
2076: PPUSH
2077: LD_INT 3
2079: PPUSH
2080: LD_VAR 0 4
2084: PPUSH
2085: CALL_OW 380
// un = CreateHuman ;
2089: LD_ADDR_VAR 0 15
2093: PUSH
2094: CALL_OW 44
2098: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2099: LD_VAR 0 15
2103: PPUSH
2104: LD_VAR 0 16
2108: PPUSH
2109: CALL_OW 52
// end ; i = i + 1 ;
2113: LD_ADDR_VAR 0 13
2117: PUSH
2118: LD_VAR 0 13
2122: PUSH
2123: LD_INT 1
2125: PLUS
2126: ST_TO_ADDR
// end ; until i = vehCount ;
2127: LD_VAR 0 13
2131: PUSH
2132: LD_VAR 0 3
2136: EQUAL
2137: IFFALSE 789
// repeat wait ( 0 0$1 ) ;
2139: LD_INT 35
2141: PPUSH
2142: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2146: LD_ADDR_VAR 0 20
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_VAR 0 2
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 21
2165: PUSH
2166: LD_INT 2
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: LD_INT 24
2175: PUSH
2176: LD_INT 650
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: LIST
2187: PPUSH
2188: CALL_OW 69
2192: ST_TO_ADDR
// if vehicleOK_list > 0 then
2193: LD_VAR 0 20
2197: PUSH
2198: LD_INT 0
2200: GREATER
2201: IFFALSE 2392
// begin for i in vehicleOK_list do
2203: LD_ADDR_VAR 0 13
2207: PUSH
2208: LD_VAR 0 20
2212: PUSH
2213: FOR_IN
2214: IFFALSE 2390
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2216: LD_ADDR_VAR 0 21
2220: PUSH
2221: LD_INT 22
2223: PUSH
2224: LD_VAR 0 11
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: PPUSH
2233: CALL_OW 69
2237: PPUSH
2238: LD_VAR 0 13
2242: PPUSH
2243: CALL_OW 74
2247: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2248: LD_ADDR_VAR 0 22
2252: PUSH
2253: LD_INT 22
2255: PUSH
2256: LD_VAR 0 11
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PUSH
2265: LD_INT 2
2267: PUSH
2268: LD_INT 59
2270: PUSH
2271: EMPTY
2272: LIST
2273: PUSH
2274: LD_INT 21
2276: PUSH
2277: LD_INT 1
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: PUSH
2284: LD_INT 21
2286: PUSH
2287: LD_INT 2
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: LIST
2298: LIST
2299: PUSH
2300: EMPTY
2301: LIST
2302: LIST
2303: PUSH
2304: EMPTY
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PPUSH
2312: LD_VAR 0 13
2316: PPUSH
2317: CALL_OW 74
2321: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2322: LD_VAR 0 13
2326: PPUSH
2327: LD_VAR 0 21
2331: PPUSH
2332: CALL_OW 296
2336: PUSH
2337: LD_INT 8
2339: PLUS
2340: PUSH
2341: LD_VAR 0 13
2345: PPUSH
2346: LD_VAR 0 22
2350: PPUSH
2351: CALL_OW 296
2355: LESS
2356: IFFALSE 2374
// begin ComAttackUnit ( i , target1 ) ;
2358: LD_VAR 0 13
2362: PPUSH
2363: LD_VAR 0 21
2367: PPUSH
2368: CALL_OW 115
// end else
2372: GO 2388
// begin ComAttackUnit ( i , target2 ) ;
2374: LD_VAR 0 13
2378: PPUSH
2379: LD_VAR 0 22
2383: PPUSH
2384: CALL_OW 115
// end ; end ;
2388: GO 2213
2390: POP
2391: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2392: LD_INT 22
2394: PUSH
2395: LD_VAR 0 2
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PUSH
2404: LD_INT 21
2406: PUSH
2407: LD_INT 2
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: PPUSH
2418: CALL_OW 69
2422: PUSH
2423: LD_INT 0
2425: EQUAL
2426: IFFALSE 2139
// end ;
2428: LD_VAR 0 12
2432: RET
// every 0 0$1 do
2433: GO 2435
2435: DISABLE
// begin enable ;
2436: ENABLE
// end ;
2437: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2438: LD_INT 0
2440: PPUSH
2441: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2442: LD_INT 22
2444: PUSH
2445: LD_VAR 0 1
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PUSH
2454: LD_INT 21
2456: PUSH
2457: LD_INT 2
2459: PUSH
2460: EMPTY
2461: LIST
2462: LIST
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: PPUSH
2468: CALL_OW 69
2472: PUSH
2473: LD_VAR 0 3
2477: LESSEQUAL
2478: IFFALSE 2545
// for i = 1 to vehCount do
2480: LD_ADDR_VAR 0 9
2484: PUSH
2485: DOUBLE
2486: LD_INT 1
2488: DEC
2489: ST_TO_ADDR
2490: LD_VAR 0 3
2494: PUSH
2495: FOR_TO
2496: IFFALSE 2543
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2498: LD_VAR 0 2
2502: PPUSH
2503: LD_VAR 0 7
2507: PPUSH
2508: LD_VAR 0 5
2512: PPUSH
2513: LD_VAR 0 6
2517: PPUSH
2518: LD_VAR 0 4
2522: PUSH
2523: LD_INT 1
2525: PPUSH
2526: LD_VAR 0 4
2530: PPUSH
2531: CALL_OW 12
2535: ARRAY
2536: PPUSH
2537: CALL_OW 185
2541: GO 2495
2543: POP
2544: POP
// end ;
2545: LD_VAR 0 8
2549: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2550: LD_INT 0
2552: PPUSH
2553: PPUSH
2554: PPUSH
2555: PPUSH
2556: PPUSH
// for i := 1 to CPU1Tanks do
2557: LD_ADDR_VAR 0 4
2561: PUSH
2562: DOUBLE
2563: LD_INT 1
2565: DEC
2566: ST_TO_ADDR
2567: LD_EXP 5
2571: PUSH
2572: FOR_TO
2573: IFFALSE 2897
// begin if i = 4 then
2575: LD_VAR 0 4
2579: PUSH
2580: LD_INT 4
2582: EQUAL
2583: IFFALSE 2895
// begin repeat wait ( 0 0$1 ) ;
2585: LD_INT 35
2587: PPUSH
2588: CALL_OW 67
// for i in CPU1Tanks do
2592: LD_ADDR_VAR 0 4
2596: PUSH
2597: LD_EXP 5
2601: PUSH
2602: FOR_IN
2603: IFFALSE 2883
// begin if GetLives ( i ) < 659 then
2605: LD_VAR 0 4
2609: PPUSH
2610: CALL_OW 256
2614: PUSH
2615: LD_INT 659
2617: LESS
2618: IFFALSE 2702
// begin tmp = i ;
2620: LD_ADDR_VAR 0 5
2624: PUSH
2625: LD_VAR 0 4
2629: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2630: LD_ADDR_VAR 0 4
2634: PUSH
2635: DOUBLE
2636: LD_INT 1
2638: DEC
2639: ST_TO_ADDR
2640: LD_EXP 5
2644: PUSH
2645: FOR_TO
2646: IFFALSE 2700
// begin if tmp = CPU1Tanks [ i ] then
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 5
2657: PUSH
2658: LD_VAR 0 4
2662: ARRAY
2663: EQUAL
2664: IFFALSE 2698
// begin CPU1Tanks = CPU1Tanks diff tmp ;
2666: LD_ADDR_EXP 5
2670: PUSH
2671: LD_EXP 5
2675: PUSH
2676: LD_VAR 0 5
2680: DIFF
2681: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2682: LD_ADDR_EXP 6
2686: PUSH
2687: LD_EXP 6
2691: PUSH
2692: LD_VAR 0 5
2696: ADD
2697: ST_TO_ADDR
// end ; end ;
2698: GO 2645
2700: POP
2701: POP
// end ; wait ( 0 0$1 ) ;
2702: LD_INT 35
2704: PPUSH
2705: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2709: LD_ADDR_VAR 0 6
2713: PUSH
2714: LD_INT 22
2716: PUSH
2717: LD_VAR 0 2
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PPUSH
2731: LD_VAR 0 4
2735: PPUSH
2736: CALL_OW 74
2740: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2741: LD_ADDR_VAR 0 7
2745: PUSH
2746: LD_INT 22
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 2
2760: PUSH
2761: LD_INT 59
2763: PUSH
2764: EMPTY
2765: LIST
2766: PUSH
2767: LD_INT 21
2769: PUSH
2770: LD_INT 1
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 21
2779: PUSH
2780: LD_INT 2
2782: PUSH
2783: EMPTY
2784: LIST
2785: LIST
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: LIST
2791: LIST
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PUSH
2797: EMPTY
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: PPUSH
2805: LD_VAR 0 4
2809: PPUSH
2810: CALL_OW 74
2814: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2815: LD_VAR 0 4
2819: PPUSH
2820: LD_VAR 0 6
2824: PPUSH
2825: CALL_OW 296
2829: PUSH
2830: LD_INT 8
2832: PLUS
2833: PUSH
2834: LD_VAR 0 4
2838: PPUSH
2839: LD_VAR 0 7
2843: PPUSH
2844: CALL_OW 296
2848: LESS
2849: IFFALSE 2867
// begin ComAttackUnit ( i , target1 ) ;
2851: LD_VAR 0 4
2855: PPUSH
2856: LD_VAR 0 6
2860: PPUSH
2861: CALL_OW 115
// end else
2865: GO 2881
// begin ComAttackUnit ( i , target2 ) ;
2867: LD_VAR 0 4
2871: PPUSH
2872: LD_VAR 0 7
2876: PPUSH
2877: CALL_OW 115
// end ; end ;
2881: GO 2602
2883: POP
2884: POP
// until CPU1Tanks = 0 ;
2885: LD_EXP 5
2889: PUSH
2890: LD_INT 0
2892: EQUAL
2893: IFFALSE 2585
// end ; end ;
2895: GO 2572
2897: POP
2898: POP
// end ;
2899: LD_VAR 0 3
2903: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2904: LD_INT 0
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
2911: PPUSH
2912: PPUSH
2913: PPUSH
2914: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 661 ] , [ f_not , [ f_empty ] ] ] ) ;
2915: LD_ADDR_VAR 0 8
2919: PUSH
2920: LD_INT 22
2922: PUSH
2923: LD_VAR 0 1
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: PUSH
2932: LD_INT 21
2934: PUSH
2935: LD_INT 2
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 24
2944: PUSH
2945: LD_INT 661
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: LD_INT 3
2954: PUSH
2955: LD_INT 58
2957: PUSH
2958: EMPTY
2959: LIST
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: PUSH
2965: EMPTY
2966: LIST
2967: LIST
2968: LIST
2969: LIST
2970: PPUSH
2971: CALL_OW 69
2975: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2976: LD_ADDR_VAR 0 9
2980: PUSH
2981: LD_INT 22
2983: PUSH
2984: LD_VAR 0 1
2988: PUSH
2989: EMPTY
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 21
2995: PUSH
2996: LD_INT 2
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 24
3008: PUSH
3009: LD_INT 660
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: LIST
3024: PPUSH
3025: CALL_OW 69
3029: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3030: LD_ADDR_VAR 0 10
3034: PUSH
3035: LD_VAR 0 2
3039: PPUSH
3040: LD_INT 22
3042: PUSH
3043: LD_VAR 0 1
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 21
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: LD_INT 3
3064: PUSH
3065: LD_INT 24
3067: PUSH
3068: LD_INT 1000
3070: PUSH
3071: EMPTY
3072: LIST
3073: LIST
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: LIST
3083: PPUSH
3084: CALL_OW 70
3088: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
3089: LD_ADDR_VAR 0 11
3093: PUSH
3094: LD_VAR 0 2
3098: PPUSH
3099: LD_INT 22
3101: PUSH
3102: LD_VAR 0 1
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: PUSH
3111: LD_INT 21
3113: PUSH
3114: LD_INT 2
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 24
3123: PUSH
3124: LD_INT 1000
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: PUSH
3131: LD_INT 58
3133: PUSH
3134: EMPTY
3135: LIST
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 70
3147: ST_TO_ADDR
// mechanicInside_list = [ ] ;
3148: LD_ADDR_VAR 0 12
3152: PUSH
3153: EMPTY
3154: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
3155: LD_ADDR_VAR 0 13
3159: PUSH
3160: LD_VAR 0 2
3164: PPUSH
3165: LD_INT 22
3167: PUSH
3168: LD_VAR 0 1
3172: PUSH
3173: EMPTY
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 25
3179: PUSH
3180: LD_INT 3
3182: PUSH
3183: EMPTY
3184: LIST
3185: LIST
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PPUSH
3191: CALL_OW 70
3195: ST_TO_ADDR
// display_strings = [ w polu:  , vehicleOK_list , uszkodzone:  , damageVehicle_list , ogolnie czolgi , CPU1Tanks , rzekodo uszkodzone , CPU1DamageTanks ] ;
3196: LD_ADDR_OWVAR 47
3200: PUSH
3201: LD_STRING w polu: 
3203: PUSH
3204: LD_VAR 0 8
3208: PUSH
3209: LD_STRING uszkodzone: 
3211: PUSH
3212: LD_VAR 0 9
3216: PUSH
3217: LD_STRING ogolnie czolgi
3219: PUSH
3220: LD_EXP 5
3224: PUSH
3225: LD_STRING rzekodo uszkodzone
3227: PUSH
3228: LD_EXP 6
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: ST_TO_ADDR
// if damageVehicle_list > 0 then
3243: LD_VAR 0 9
3247: PUSH
3248: LD_INT 0
3250: GREATER
3251: IFFALSE 3272
// ComMoveXY ( damageVehicle_list , repX , repY ) ;
3253: LD_VAR 0 9
3257: PPUSH
3258: LD_VAR 0 3
3262: PPUSH
3263: LD_VAR 0 4
3267: PPUSH
3268: CALL_OW 111
// if vehicleNeedRepair_list > 0 then
3272: LD_VAR 0 10
3276: PUSH
3277: LD_INT 0
3279: GREATER
3280: IFFALSE 3382
// begin for i in vehicleNeedRepair_list do
3282: LD_ADDR_VAR 0 6
3286: PUSH
3287: LD_VAR 0 10
3291: PUSH
3292: FOR_IN
3293: IFFALSE 3380
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
3295: LD_ADDR_VAR 0 12
3299: PUSH
3300: LD_VAR 0 12
3304: PUSH
3305: LD_VAR 0 6
3309: PPUSH
3310: CALL_OW 313
3314: ADD
3315: ST_TO_ADDR
// ComExitVehicle ( mechanicInside_list ) ;
3316: LD_VAR 0 12
3320: PPUSH
3321: CALL_OW 121
// wait ( 0 0$1 ) ;
3325: LD_INT 35
3327: PPUSH
3328: CALL_OW 67
// if mechanicInside_list > 0 then
3332: LD_VAR 0 12
3336: PUSH
3337: LD_INT 0
3339: GREATER
3340: IFFALSE 3360
// AddComRepairVehicle ( mechanicInside_list [ 1 ] , i ) ;
3342: LD_VAR 0 12
3346: PUSH
3347: LD_INT 1
3349: ARRAY
3350: PPUSH
3351: LD_VAR 0 6
3355: PPUSH
3356: CALL_OW 189
// AddComEnterUnit ( mechanicInside_list [ 1 ] , i ) ;
3360: LD_VAR 0 12
3364: PUSH
3365: LD_INT 1
3367: ARRAY
3368: PPUSH
3369: LD_VAR 0 6
3373: PPUSH
3374: CALL_OW 180
// end ;
3378: GO 3292
3380: POP
3381: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3382: LD_VAR 0 11
3386: PUSH
3387: LD_INT 0
3389: GREATER
3390: IFFALSE 3414
// AddComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3392: LD_VAR 0 13
3396: PUSH
3397: LD_INT 1
3399: ARRAY
3400: PPUSH
3401: LD_VAR 0 11
3405: PUSH
3406: LD_INT 1
3408: ARRAY
3409: PPUSH
3410: CALL_OW 180
// if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3414: LD_VAR 0 8
3418: PUSH
3419: LD_INT 0
3421: GREATER
3422: PUSH
3423: LD_EXP 6
3427: PUSH
3428: LD_INT 0
3430: GREATER
3431: AND
3432: IFFALSE 3573
// begin for i := 1 to vehicleOK_list do
3434: LD_ADDR_VAR 0 6
3438: PUSH
3439: DOUBLE
3440: LD_INT 1
3442: DEC
3443: ST_TO_ADDR
3444: LD_VAR 0 8
3448: PUSH
3449: FOR_TO
3450: IFFALSE 3571
// begin if i = 4 then
3452: LD_VAR 0 6
3456: PUSH
3457: LD_INT 4
3459: EQUAL
3460: IFFALSE 3569
// begin for i in vehicleOK_list do
3462: LD_ADDR_VAR 0 6
3466: PUSH
3467: LD_VAR 0 8
3471: PUSH
3472: FOR_IN
3473: IFFALSE 3493
// CPU1Tanks = CPU1Tanks ^ i ;
3475: LD_ADDR_EXP 5
3479: PUSH
3480: LD_EXP 5
3484: PUSH
3485: LD_VAR 0 6
3489: ADD
3490: ST_TO_ADDR
3491: GO 3472
3493: POP
3494: POP
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3495: LD_ADDR_EXP 6
3499: PUSH
3500: LD_EXP 6
3504: PPUSH
3505: LD_INT 1
3507: PPUSH
3508: CALL_OW 3
3512: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3513: LD_ADDR_EXP 6
3517: PUSH
3518: LD_EXP 6
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: CALL_OW 3
3530: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3531: LD_ADDR_EXP 6
3535: PUSH
3536: LD_EXP 6
3540: PPUSH
3541: LD_INT 1
3543: PPUSH
3544: CALL_OW 3
3548: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3549: LD_ADDR_EXP 6
3553: PUSH
3554: LD_EXP 6
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: CALL_OW 3
3566: ST_TO_ADDR
// break ;
3567: GO 3571
// end ; end ;
3569: GO 3449
3571: POP
3572: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 2
3582: PPUSH
3583: LD_INT 22
3585: PUSH
3586: LD_VAR 0 1
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 25
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: EMPTY
3606: LIST
3607: LIST
3608: PPUSH
3609: CALL_OW 70
3613: NOT
3614: PUSH
3615: FOR_IN
3616: IFFALSE 3639
// ComMoveXY ( i , repX , repY ) ;
3618: LD_VAR 0 6
3622: PPUSH
3623: LD_VAR 0 3
3627: PPUSH
3628: LD_VAR 0 4
3632: PPUSH
3633: CALL_OW 111
3637: GO 3615
3639: POP
3640: POP
// end ;
3641: LD_VAR 0 5
3645: RET
// export function CheckMechanicsStatus ( side , area ) ; var i , mechList , vehicleNeedRepair_list ; begin
3646: LD_INT 0
3648: PPUSH
3649: PPUSH
3650: PPUSH
3651: PPUSH
// mechList = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , 3 ] ] ) ;
3652: LD_ADDR_VAR 0 5
3656: PUSH
3657: LD_INT 22
3659: PUSH
3660: LD_VAR 0 1
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 21
3671: PUSH
3672: LD_INT 1
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 25
3681: PUSH
3682: LD_INT 3
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: LIST
3693: PPUSH
3694: CALL_OW 69
3698: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3699: LD_ADDR_VAR 0 6
3703: PUSH
3704: LD_VAR 0 2
3708: PPUSH
3709: LD_INT 22
3711: PUSH
3712: LD_VAR 0 1
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 21
3723: PUSH
3724: LD_INT 2
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 3
3733: PUSH
3734: LD_INT 24
3736: PUSH
3737: LD_INT 1000
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: LIST
3752: PPUSH
3753: CALL_OW 70
3757: ST_TO_ADDR
// if mechList > 0 then
3758: LD_VAR 0 5
3762: PUSH
3763: LD_INT 0
3765: GREATER
3766: IFFALSE 3848
// if UnitFilter ( mechList , [ [ f_inarea , area ] , [ f_not , [ f_hastask ] ] ] ) then
3768: LD_VAR 0 5
3772: PPUSH
3773: LD_INT 95
3775: PUSH
3776: LD_VAR 0 2
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PUSH
3785: LD_INT 3
3787: PUSH
3788: LD_INT 60
3790: PUSH
3791: EMPTY
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 72
3806: IFFALSE 3848
// AddComRepairVehicle ( UnitFilter ( mechList , [ f_not , [ f_hastask ] ] ) [ 1 ] , vehicleNeedRepair_list [ 1 ] ) ;
3808: LD_VAR 0 5
3812: PPUSH
3813: LD_INT 3
3815: PUSH
3816: LD_INT 60
3818: PUSH
3819: EMPTY
3820: LIST
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PPUSH
3826: CALL_OW 72
3830: PUSH
3831: LD_INT 1
3833: ARRAY
3834: PPUSH
3835: LD_VAR 0 6
3839: PUSH
3840: LD_INT 1
3842: ARRAY
3843: PPUSH
3844: CALL_OW 189
// end ;
3848: LD_VAR 0 3
3852: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3853: LD_INT 0
3855: PPUSH
3856: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3857: LD_INT 22
3859: PUSH
3860: LD_VAR 0 1
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: PUSH
3869: LD_INT 25
3871: PUSH
3872: LD_INT 2
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PUSH
3879: EMPTY
3880: LIST
3881: LIST
3882: PPUSH
3883: CALL_OW 69
3887: PUSH
3888: LD_INT 0
3890: GREATER
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_VAR 0 1
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PUSH
3904: LD_INT 21
3906: PUSH
3907: LD_INT 3
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: PUSH
3914: LD_INT 3
3916: PUSH
3917: LD_INT 24
3919: PUSH
3920: LD_INT 1000
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: LIST
3935: PPUSH
3936: CALL_OW 69
3940: PUSH
3941: LD_INT 0
3943: EQUAL
3944: AND
3945: PUSH
3946: LD_VAR 0 2
3950: PUSH
3951: LD_INT 0
3953: GREATER
3954: AND
3955: IFFALSE 4054
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3957: LD_ADDR_VAR 0 4
3961: PUSH
3962: LD_INT 22
3964: PUSH
3965: LD_VAR 0 1
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: LD_INT 25
3976: PUSH
3977: LD_INT 2
3979: PUSH
3980: EMPTY
3981: LIST
3982: LIST
3983: PUSH
3984: EMPTY
3985: LIST
3986: LIST
3987: PPUSH
3988: CALL_OW 69
3992: PUSH
3993: FOR_IN
3994: IFFALSE 4052
// begin AddComExitBuilding ( i ) ;
3996: LD_VAR 0 4
4000: PPUSH
4001: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
4005: LD_VAR 0 4
4009: PPUSH
4010: LD_VAR 0 2
4014: PUSH
4015: LD_INT 1
4017: ARRAY
4018: PPUSH
4019: LD_VAR 0 2
4023: PUSH
4024: LD_INT 2
4026: ARRAY
4027: PPUSH
4028: LD_VAR 0 2
4032: PUSH
4033: LD_INT 3
4035: ARRAY
4036: PPUSH
4037: LD_VAR 0 2
4041: PUSH
4042: LD_INT 4
4044: ARRAY
4045: PPUSH
4046: CALL_OW 205
// end ;
4050: GO 3993
4052: POP
4053: POP
// end ; end ;
4054: LD_VAR 0 3
4058: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
4059: LD_INT 0
4061: PPUSH
4062: PPUSH
4063: PPUSH
4064: PPUSH
4065: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
4066: LD_ADDR_VAR 0 6
4070: PUSH
4071: LD_INT 22
4073: PUSH
4074: LD_VAR 0 1
4078: PUSH
4079: EMPTY
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 2
4085: PUSH
4086: LD_INT 30
4088: PUSH
4089: LD_INT 31
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 30
4098: PUSH
4099: LD_INT 32
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: PUSH
4106: LD_INT 30
4108: PUSH
4109: LD_INT 33
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: PUSH
4116: LD_INT 30
4118: PUSH
4119: LD_INT 4
4121: PUSH
4122: EMPTY
4123: LIST
4124: LIST
4125: PUSH
4126: LD_INT 30
4128: PUSH
4129: LD_INT 5
4131: PUSH
4132: EMPTY
4133: LIST
4134: LIST
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 69
4152: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
4153: LD_ADDR_VAR 0 7
4157: PUSH
4158: LD_INT 22
4160: PUSH
4161: LD_VAR 0 2
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: PUSH
4170: LD_INT 21
4172: PUSH
4173: LD_INT 3
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: PUSH
4180: LD_INT 58
4182: PUSH
4183: EMPTY
4184: LIST
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: LIST
4190: PPUSH
4191: CALL_OW 69
4195: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
4196: LD_VAR 0 6
4200: PUSH
4201: LD_INT 0
4203: GREATER
4204: PUSH
4205: LD_VAR 0 7
4209: PUSH
4210: LD_INT 0
4212: GREATER
4213: AND
4214: IFFALSE 4284
// begin for i in turretsList do
4216: LD_ADDR_VAR 0 4
4220: PUSH
4221: LD_VAR 0 6
4225: PUSH
4226: FOR_IN
4227: IFFALSE 4282
// begin for j in enemyBuildings do
4229: LD_ADDR_VAR 0 5
4233: PUSH
4234: LD_VAR 0 7
4238: PUSH
4239: FOR_IN
4240: IFFALSE 4278
// begin if GetDistUnits ( i , j ) < 20 then
4242: LD_VAR 0 4
4246: PPUSH
4247: LD_VAR 0 5
4251: PPUSH
4252: CALL_OW 296
4256: PUSH
4257: LD_INT 20
4259: LESS
4260: IFFALSE 4276
// begin ComAttackUnit ( i , j ) ;
4262: LD_VAR 0 4
4266: PPUSH
4267: LD_VAR 0 5
4271: PPUSH
4272: CALL_OW 115
// end ; end ;
4276: GO 4239
4278: POP
4279: POP
// end ;
4280: GO 4226
4282: POP
4283: POP
// end ; end ;
4284: LD_VAR 0 3
4288: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
4289: LD_INT 0
4291: PPUSH
4292: PPUSH
4293: PPUSH
4294: PPUSH
4295: PPUSH
4296: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
4297: LD_ADDR_VAR 0 7
4301: PUSH
4302: LD_INT 22
4304: PUSH
4305: LD_VAR 0 1
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 25
4316: PUSH
4317: LD_INT 9
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PPUSH
4328: CALL_OW 69
4332: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4333: LD_ADDR_VAR 0 8
4337: PUSH
4338: LD_INT 22
4340: PUSH
4341: LD_VAR 0 2
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 3
4352: PUSH
4353: LD_INT 21
4355: PUSH
4356: LD_INT 3
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PPUSH
4371: CALL_OW 69
4375: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
4376: LD_ADDR_VAR 0 5
4380: PUSH
4381: LD_INT 1
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: CALL_OW 12
4391: ST_TO_ADDR
// for i = 1 to list do
4392: LD_ADDR_VAR 0 6
4396: PUSH
4397: DOUBLE
4398: LD_INT 1
4400: DEC
4401: ST_TO_ADDR
4402: LD_VAR 0 7
4406: PUSH
4407: FOR_TO
4408: IFFALSE 4590
// for ta in filter do
4410: LD_ADDR_VAR 0 4
4414: PUSH
4415: LD_VAR 0 8
4419: PUSH
4420: FOR_IN
4421: IFFALSE 4586
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
4423: LD_VAR 0 7
4427: PUSH
4428: LD_VAR 0 6
4432: ARRAY
4433: PPUSH
4434: LD_VAR 0 4
4438: PPUSH
4439: CALL_OW 296
4443: PUSH
4444: LD_INT 13
4446: LESSEQUAL
4447: IFFALSE 4584
// begin case c of 1 :
4449: LD_VAR 0 5
4453: PUSH
4454: LD_INT 1
4456: DOUBLE
4457: EQUAL
4458: IFTRUE 4462
4460: GO 4500
4462: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4463: LD_VAR 0 7
4467: PUSH
4468: LD_VAR 0 6
4472: ARRAY
4473: PPUSH
4474: LD_VAR 0 4
4478: PPUSH
4479: CALL_OW 250
4483: PPUSH
4484: LD_VAR 0 4
4488: PPUSH
4489: CALL_OW 251
4493: PPUSH
4494: CALL_OW 154
4498: GO 4584
4500: LD_INT 2
4502: DOUBLE
4503: EQUAL
4504: IFTRUE 4508
4506: GO 4572
4508: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4509: LD_VAR 0 7
4513: PUSH
4514: LD_VAR 0 6
4518: ARRAY
4519: PPUSH
4520: LD_VAR 0 4
4524: PPUSH
4525: CALL_OW 250
4529: PUSH
4530: LD_INT 1
4532: NEG
4533: PPUSH
4534: LD_INT 1
4536: PPUSH
4537: CALL_OW 12
4541: PLUS
4542: PPUSH
4543: LD_VAR 0 4
4547: PPUSH
4548: CALL_OW 251
4552: PUSH
4553: LD_INT 1
4555: NEG
4556: PPUSH
4557: LD_INT 1
4559: PPUSH
4560: CALL_OW 12
4564: PLUS
4565: PPUSH
4566: CALL_OW 153
4570: GO 4584
4572: LD_INT 3
4574: DOUBLE
4575: EQUAL
4576: IFTRUE 4580
4578: GO 4583
4580: POP
// ; end ;
4581: GO 4584
4583: POP
// end ; end ;
4584: GO 4420
4586: POP
4587: POP
4588: GO 4407
4590: POP
4591: POP
// end ;
4592: LD_VAR 0 3
4596: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
4605: LD_ADDR_VAR 0 6
4609: PUSH
4610: LD_VAR 0 2
4614: PPUSH
4615: CALL_OW 313
4619: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
4620: LD_ADDR_VAR 0 7
4624: PUSH
4625: LD_INT 22
4627: PUSH
4628: LD_VAR 0 1
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PUSH
4637: LD_INT 25
4639: PUSH
4640: LD_INT 2
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: PUSH
4647: LD_INT 24
4649: PUSH
4650: LD_INT 1000
4652: PUSH
4653: EMPTY
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 3
4659: PUSH
4660: LD_INT 54
4662: PUSH
4663: EMPTY
4664: LIST
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: PUSH
4670: EMPTY
4671: LIST
4672: LIST
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4681: LD_ADDR_VAR 0 4
4685: PUSH
4686: LD_INT 22
4688: PUSH
4689: LD_VAR 0 1
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: LD_INT 21
4700: PUSH
4701: LD_INT 3
4703: PUSH
4704: EMPTY
4705: LIST
4706: LIST
4707: PUSH
4708: LD_INT 3
4710: PUSH
4711: LD_INT 24
4713: PUSH
4714: LD_INT 1000
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: PPUSH
4733: CALL_OW 69
4737: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4738: LD_VAR 0 4
4742: NOT
4743: PUSH
4744: LD_VAR 0 7
4748: NOT
4749: AND
4750: PUSH
4751: LD_EXP 1
4755: NOT
4756: AND
4757: IFFALSE 4761
// exit ;
4759: GO 4880
// if buildings_list > 0 and engineerOkInside then
4761: LD_VAR 0 4
4765: PUSH
4766: LD_INT 0
4768: GREATER
4769: PUSH
4770: LD_VAR 0 6
4774: AND
4775: IFFALSE 4808
// for i in UnitsInside ( building ) do
4777: LD_ADDR_VAR 0 5
4781: PUSH
4782: LD_VAR 0 2
4786: PPUSH
4787: CALL_OW 313
4791: PUSH
4792: FOR_IN
4793: IFFALSE 4806
// ComExitBuilding ( i ) ;
4795: LD_VAR 0 5
4799: PPUSH
4800: CALL_OW 122
4804: GO 4792
4806: POP
4807: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4808: LD_VAR 0 4
4812: PUSH
4813: LD_INT 0
4815: GREATER
4816: PUSH
4817: LD_VAR 0 7
4821: PUSH
4822: LD_INT 0
4824: GREATER
4825: AND
4826: IFFALSE 4880
// begin for i in engineerOkOutside do
4828: LD_ADDR_VAR 0 5
4832: PUSH
4833: LD_VAR 0 7
4837: PUSH
4838: FOR_IN
4839: IFFALSE 4878
// for j in buildings_list do
4841: LD_ADDR_VAR 0 8
4845: PUSH
4846: LD_VAR 0 4
4850: PUSH
4851: FOR_IN
4852: IFFALSE 4874
// ComRepairBuilding ( i , j [ 1 ] ) ;
4854: LD_VAR 0 5
4858: PPUSH
4859: LD_VAR 0 8
4863: PUSH
4864: LD_INT 1
4866: ARRAY
4867: PPUSH
4868: CALL_OW 130
4872: GO 4851
4874: POP
4875: POP
4876: GO 4838
4878: POP
4879: POP
// end ; end ;
4880: LD_VAR 0 3
4884: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4885: LD_INT 0
4887: PPUSH
4888: PPUSH
4889: PPUSH
4890: PPUSH
4891: PPUSH
4892: PPUSH
4893: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4894: LD_ADDR_VAR 0 6
4898: PUSH
4899: LD_INT 22
4901: PUSH
4902: LD_VAR 0 1
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 25
4913: PUSH
4914: LD_INT 4
4916: PUSH
4917: EMPTY
4918: LIST
4919: LIST
4920: PUSH
4921: LD_INT 24
4923: PUSH
4924: LD_INT 251
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: PUSH
4931: EMPTY
4932: LIST
4933: LIST
4934: LIST
4935: PPUSH
4936: CALL_OW 69
4940: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4941: LD_ADDR_VAR 0 7
4945: PUSH
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 22
4953: PUSH
4954: LD_VAR 0 1
4958: PUSH
4959: EMPTY
4960: LIST
4961: LIST
4962: PUSH
4963: LD_INT 25
4965: PUSH
4966: LD_INT 4
4968: PUSH
4969: EMPTY
4970: LIST
4971: LIST
4972: PUSH
4973: LD_INT 50
4975: PUSH
4976: EMPTY
4977: LIST
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: LIST
4983: PPUSH
4984: CALL_OW 70
4988: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4989: LD_ADDR_VAR 0 10
4993: PUSH
4994: LD_VAR 0 3
4998: PPUSH
4999: LD_INT 22
5001: PUSH
5002: LD_VAR 0 1
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 21
5013: PUSH
5014: LD_INT 1
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 3
5023: PUSH
5024: LD_INT 24
5026: PUSH
5027: LD_INT 750
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: LIST
5042: PPUSH
5043: CALL_OW 70
5047: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5048: LD_ADDR_VAR 0 11
5052: PUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 22
5060: PUSH
5061: LD_VAR 0 1
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 21
5072: PUSH
5073: LD_INT 1
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 3
5082: PUSH
5083: LD_INT 24
5085: PUSH
5086: LD_INT 1000
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: LIST
5101: PPUSH
5102: CALL_OW 70
5106: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
5107: LD_VAR 0 10
5111: NOT
5112: PUSH
5113: LD_VAR 0 7
5117: NOT
5118: AND
5119: PUSH
5120: LD_VAR 0 11
5124: NOT
5125: AND
5126: IFFALSE 5130
// exit ;
5128: GO 5319
// if damageUnits > 0 and sci_list > 0 then
5130: LD_VAR 0 10
5134: PUSH
5135: LD_INT 0
5137: GREATER
5138: PUSH
5139: LD_VAR 0 6
5143: PUSH
5144: LD_INT 0
5146: GREATER
5147: AND
5148: IFFALSE 5181
// for i in damageUnits do
5150: LD_ADDR_VAR 0 8
5154: PUSH
5155: LD_VAR 0 10
5159: PUSH
5160: FOR_IN
5161: IFFALSE 5179
// ComMoveToArea ( i , healArea ) ;
5163: LD_VAR 0 8
5167: PPUSH
5168: LD_VAR 0 2
5172: PPUSH
5173: CALL_OW 113
5177: GO 5160
5179: POP
5180: POP
// if unitsToHeal > 0 and sci_list > 0 then
5181: LD_VAR 0 11
5185: PUSH
5186: LD_INT 0
5188: GREATER
5189: PUSH
5190: LD_VAR 0 6
5194: PUSH
5195: LD_INT 0
5197: GREATER
5198: AND
5199: IFFALSE 5258
// begin for i in sci_list do
5201: LD_ADDR_VAR 0 8
5205: PUSH
5206: LD_VAR 0 6
5210: PUSH
5211: FOR_IN
5212: IFFALSE 5256
// begin ComExitBuilding ( i ) ;
5214: LD_VAR 0 8
5218: PPUSH
5219: CALL_OW 122
// for j in unitsToHeal do
5223: LD_ADDR_VAR 0 9
5227: PUSH
5228: LD_VAR 0 11
5232: PUSH
5233: FOR_IN
5234: IFFALSE 5252
// AddComHeal ( i , j ) ;
5236: LD_VAR 0 8
5240: PPUSH
5241: LD_VAR 0 9
5245: PPUSH
5246: CALL_OW 188
5250: GO 5233
5252: POP
5253: POP
// end ;
5254: GO 5211
5256: POP
5257: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
5258: LD_VAR 0 10
5262: PUSH
5263: LD_INT 0
5265: EQUAL
5266: PUSH
5267: LD_VAR 0 11
5271: PUSH
5272: LD_INT 0
5274: EQUAL
5275: AND
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_INT 0
5284: GREATER
5285: AND
5286: IFFALSE 5319
// for i in sci_listOutside do
5288: LD_ADDR_VAR 0 8
5292: PUSH
5293: LD_VAR 0 7
5297: PUSH
5298: FOR_IN
5299: IFFALSE 5317
// ComEnterUnit ( i , build ) ;
5301: LD_VAR 0 8
5305: PPUSH
5306: LD_VAR 0 4
5310: PPUSH
5311: CALL_OW 120
5315: GO 5298
5317: POP
5318: POP
// end ; end_of_file
5319: LD_VAR 0 5
5323: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
5324: LD_INT 0
5326: PPUSH
5327: PPUSH
// if exist_mode then
5328: LD_VAR 0 2
5332: IFFALSE 5351
// unit := CreateCharacter ( ident ) else
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_VAR 0 1
5343: PPUSH
5344: CALL_OW 34
5348: ST_TO_ADDR
5349: GO 5366
// unit := NewCharacter ( ident ) ;
5351: LD_ADDR_VAR 0 4
5355: PUSH
5356: LD_VAR 0 1
5360: PPUSH
5361: CALL_OW 25
5365: ST_TO_ADDR
// result := unit ;
5366: LD_ADDR_VAR 0 3
5370: PUSH
5371: LD_VAR 0 4
5375: ST_TO_ADDR
// end ;
5376: LD_VAR 0 3
5380: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
5381: LD_INT 0
5383: PPUSH
5384: PPUSH
5385: PPUSH
// uc_side := GetSide ( b ) ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_VAR 0 2
5395: PPUSH
5396: CALL_OW 255
5400: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
5401: LD_ADDR_OWVAR 21
5405: PUSH
5406: LD_VAR 0 2
5410: PPUSH
5411: CALL_OW 248
5415: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5416: LD_INT 0
5418: PPUSH
5419: LD_INT 1
5421: PPUSH
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
5431: LD_ADDR_VAR 0 5
5435: PUSH
5436: LD_VAR 0 2
5440: PPUSH
5441: CALL_OW 254
5445: PUSH
5446: LD_INT 3
5448: MINUS
5449: ST_TO_ADDR
// if dir < 0 then
5450: LD_VAR 0 5
5454: PUSH
5455: LD_INT 0
5457: LESS
5458: IFFALSE 5474
// dir := 6 + dir ;
5460: LD_ADDR_VAR 0 5
5464: PUSH
5465: LD_INT 6
5467: PUSH
5468: LD_VAR 0 5
5472: PLUS
5473: ST_TO_ADDR
// un := CreateHuman ;
5474: LD_ADDR_VAR 0 4
5478: PUSH
5479: CALL_OW 44
5483: ST_TO_ADDR
// SetDir ( un , dir ) ;
5484: LD_VAR 0 4
5488: PPUSH
5489: LD_VAR 0 5
5493: PPUSH
5494: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5498: LD_VAR 0 4
5502: PPUSH
5503: LD_VAR 0 2
5507: PPUSH
5508: CALL_OW 52
// end ;
5512: LD_VAR 0 3
5516: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
5517: LD_INT 0
5519: PPUSH
5520: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
5521: LD_ADDR_VAR 0 2
5525: PUSH
5526: LD_VAR 0 1
5530: PPUSH
5531: LD_INT 1
5533: PPUSH
5534: CALL_OW 289
5538: PUSH
5539: LD_VAR 0 1
5543: PPUSH
5544: LD_INT 2
5546: PPUSH
5547: CALL_OW 289
5551: PUSH
5552: LD_VAR 0 1
5556: PPUSH
5557: LD_INT 3
5559: PPUSH
5560: CALL_OW 289
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: ST_TO_ADDR
// end ;
5570: LD_VAR 0 2
5574: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
5575: LD_INT 0
5577: PPUSH
5578: PPUSH
5579: PPUSH
5580: PPUSH
// r := 100 ;
5581: LD_ADDR_VAR 0 5
5585: PUSH
5586: LD_INT 100
5588: ST_TO_ADDR
// x := 0 ;
5589: LD_ADDR_VAR 0 6
5593: PUSH
5594: LD_INT 0
5596: ST_TO_ADDR
// while ( x < n ) do
5597: LD_VAR 0 6
5601: PUSH
5602: LD_VAR 0 2
5606: LESS
5607: IFFALSE 5920
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
5609: LD_ADDR_VAR 0 4
5613: PUSH
5614: DOUBLE
5615: LD_INT 1
5617: DEC
5618: ST_TO_ADDR
5619: LD_VAR 0 1
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: PUSH
5632: LD_INT 1
5634: ARRAY
5635: PUSH
5636: FOR_TO
5637: IFFALSE 5916
// begin if r > 50 then
5639: LD_VAR 0 5
5643: PUSH
5644: LD_INT 50
5646: GREATER
5647: IFFALSE 5892
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
5649: LD_VAR 0 1
5653: PPUSH
5654: LD_INT 0
5656: PPUSH
5657: CALL_OW 517
5661: PUSH
5662: LD_INT 1
5664: ARRAY
5665: PUSH
5666: LD_VAR 0 4
5670: ARRAY
5671: PPUSH
5672: LD_VAR 0 1
5676: PPUSH
5677: LD_INT 0
5679: PPUSH
5680: CALL_OW 517
5684: PUSH
5685: LD_INT 2
5687: ARRAY
5688: PUSH
5689: LD_VAR 0 4
5693: ARRAY
5694: PPUSH
5695: CALL_OW 458
5699: NOT
5700: IFFALSE 5876
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , 2 , 0 ) ;
5702: LD_VAR 0 1
5706: PPUSH
5707: LD_INT 0
5709: PPUSH
5710: CALL_OW 517
5714: PUSH
5715: LD_INT 1
5717: ARRAY
5718: PUSH
5719: LD_VAR 0 4
5723: ARRAY
5724: PPUSH
5725: LD_VAR 0 1
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 517
5737: PUSH
5738: LD_INT 2
5740: ARRAY
5741: PUSH
5742: LD_VAR 0 4
5746: ARRAY
5747: PPUSH
5748: LD_INT 2
5750: PPUSH
5751: LD_INT 0
5753: PPUSH
5754: CALL_OW 454
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
5758: LD_ADDR_EXP 3
5762: PUSH
5763: LD_EXP 3
5767: PPUSH
5768: LD_EXP 3
5772: PUSH
5773: LD_INT 1
5775: PLUS
5776: PPUSH
5777: LD_VAR 0 1
5781: PPUSH
5782: LD_INT 0
5784: PPUSH
5785: CALL_OW 517
5789: PUSH
5790: LD_INT 1
5792: ARRAY
5793: PUSH
5794: LD_VAR 0 4
5798: ARRAY
5799: PPUSH
5800: CALL_OW 2
5804: ST_TO_ADDR
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
5805: LD_ADDR_EXP 3
5809: PUSH
5810: LD_EXP 3
5814: PPUSH
5815: LD_EXP 3
5819: PUSH
5820: LD_INT 1
5822: PLUS
5823: PPUSH
5824: LD_VAR 0 1
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 517
5836: PUSH
5837: LD_INT 2
5839: ARRAY
5840: PUSH
5841: LD_VAR 0 4
5845: ARRAY
5846: PPUSH
5847: CALL_OW 2
5851: ST_TO_ADDR
// r := 0 ;
5852: LD_ADDR_VAR 0 5
5856: PUSH
5857: LD_INT 0
5859: ST_TO_ADDR
// x := x + 1 ;
5860: LD_ADDR_VAR 0 6
5864: PUSH
5865: LD_VAR 0 6
5869: PUSH
5870: LD_INT 1
5872: PLUS
5873: ST_TO_ADDR
// end else
5874: GO 5890
// r := r + 35 ;
5876: LD_ADDR_VAR 0 5
5880: PUSH
5881: LD_VAR 0 5
5885: PUSH
5886: LD_INT 35
5888: PLUS
5889: ST_TO_ADDR
// end else
5890: GO 5914
// r := r + rand ( 10 , 25 ) ;
5892: LD_ADDR_VAR 0 5
5896: PUSH
5897: LD_VAR 0 5
5901: PUSH
5902: LD_INT 10
5904: PPUSH
5905: LD_INT 25
5907: PPUSH
5908: CALL_OW 12
5912: PLUS
5913: ST_TO_ADDR
// end ;
5914: GO 5636
5916: POP
5917: POP
5918: GO 5597
// end ; end_of_file
5920: LD_VAR 0 3
5924: RET
// on UnitDestroyed ( un ) do var i ;
5925: LD_INT 0
5927: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5928: LD_VAR 0 1
5932: PPUSH
5933: CALL_OW 255
5937: PUSH
5938: LD_INT 3
5940: EQUAL
5941: PUSH
5942: LD_VAR 0 1
5946: PPUSH
5947: CALL_OW 247
5951: PUSH
5952: LD_INT 3
5954: EQUAL
5955: AND
5956: IFFALSE 6648
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5958: LD_VAR 0 1
5962: PPUSH
5963: CALL_OW 266
5967: PUSH
5968: LD_INT 31
5970: EQUAL
5971: PUSH
5972: LD_VAR 0 1
5976: PPUSH
5977: CALL_OW 266
5981: PUSH
5982: LD_INT 32
5984: EQUAL
5985: OR
5986: PUSH
5987: LD_VAR 0 1
5991: PPUSH
5992: CALL_OW 266
5996: PUSH
5997: LD_INT 36
5999: EQUAL
6000: OR
6001: PUSH
6002: LD_VAR 0 1
6006: PPUSH
6007: CALL_OW 266
6011: PUSH
6012: LD_INT 0
6014: EQUAL
6015: OR
6016: PUSH
6017: LD_VAR 0 1
6021: PPUSH
6022: CALL_OW 266
6026: PUSH
6027: LD_INT 24
6029: EQUAL
6030: OR
6031: PUSH
6032: LD_VAR 0 1
6036: PPUSH
6037: CALL_OW 266
6041: PUSH
6042: LD_INT 17
6044: EQUAL
6045: OR
6046: PUSH
6047: LD_VAR 0 1
6051: PPUSH
6052: CALL_OW 266
6056: PUSH
6057: LD_INT 25
6059: EQUAL
6060: OR
6061: PUSH
6062: LD_VAR 0 1
6066: PPUSH
6067: CALL_OW 266
6071: PUSH
6072: LD_INT 19
6074: EQUAL
6075: OR
6076: PUSH
6077: LD_VAR 0 1
6081: PPUSH
6082: CALL_OW 266
6086: PUSH
6087: LD_INT 20
6089: EQUAL
6090: OR
6091: PUSH
6092: LD_VAR 0 1
6096: PPUSH
6097: CALL_OW 266
6101: PUSH
6102: LD_INT 18
6104: EQUAL
6105: OR
6106: PUSH
6107: LD_VAR 0 1
6111: PPUSH
6112: CALL_OW 266
6116: PUSH
6117: LD_INT 21
6119: EQUAL
6120: OR
6121: PUSH
6122: LD_VAR 0 1
6126: PPUSH
6127: CALL_OW 266
6131: PUSH
6132: LD_INT 23
6134: EQUAL
6135: OR
6136: PUSH
6137: LD_VAR 0 1
6141: PPUSH
6142: CALL_OW 266
6146: PUSH
6147: LD_INT 16
6149: EQUAL
6150: OR
6151: PUSH
6152: LD_VAR 0 1
6156: PPUSH
6157: CALL_OW 266
6161: PUSH
6162: LD_INT 6
6164: EQUAL
6165: OR
6166: PUSH
6167: LD_VAR 0 1
6171: PPUSH
6172: CALL_OW 266
6176: PUSH
6177: LD_INT 29
6179: EQUAL
6180: OR
6181: PUSH
6182: LD_VAR 0 1
6186: PPUSH
6187: CALL_OW 266
6191: PUSH
6192: LD_INT 26
6194: EQUAL
6195: OR
6196: PUSH
6197: LD_VAR 0 1
6201: PPUSH
6202: CALL_OW 266
6206: PUSH
6207: LD_INT 30
6209: EQUAL
6210: OR
6211: PUSH
6212: LD_VAR 0 1
6216: PPUSH
6217: CALL_OW 266
6221: PUSH
6222: LD_INT 28
6224: EQUAL
6225: OR
6226: PUSH
6227: LD_VAR 0 1
6231: PPUSH
6232: CALL_OW 266
6236: PUSH
6237: LD_INT 27
6239: EQUAL
6240: OR
6241: PUSH
6242: LD_VAR 0 1
6246: PPUSH
6247: CALL_OW 266
6251: PUSH
6252: LD_INT 33
6254: EQUAL
6255: OR
6256: PUSH
6257: LD_VAR 0 1
6261: PPUSH
6262: CALL_OW 266
6266: PUSH
6267: LD_INT 2
6269: EQUAL
6270: OR
6271: PUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 266
6281: PUSH
6282: LD_INT 4
6284: EQUAL
6285: OR
6286: IFFALSE 6372
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
6288: LD_ADDR_EXP 1
6292: PUSH
6293: LD_EXP 1
6297: PUSH
6298: LD_VAR 0 1
6302: PPUSH
6303: CALL_OW 266
6307: ADD
6308: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6309: LD_ADDR_EXP 1
6313: PUSH
6314: LD_EXP 1
6318: PUSH
6319: LD_VAR 0 1
6323: PPUSH
6324: CALL_OW 250
6328: ADD
6329: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6330: LD_ADDR_EXP 1
6334: PUSH
6335: LD_EXP 1
6339: PUSH
6340: LD_VAR 0 1
6344: PPUSH
6345: CALL_OW 251
6349: ADD
6350: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6351: LD_ADDR_EXP 1
6355: PUSH
6356: LD_EXP 1
6360: PUSH
6361: LD_VAR 0 1
6365: PPUSH
6366: CALL_OW 254
6370: ADD
6371: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 266
6381: PUSH
6382: LD_INT 1
6384: EQUAL
6385: IFFALSE 6464
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
6387: LD_ADDR_EXP 1
6391: PUSH
6392: LD_EXP 1
6396: PUSH
6397: LD_INT 0
6399: ADD
6400: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6401: LD_ADDR_EXP 1
6405: PUSH
6406: LD_EXP 1
6410: PUSH
6411: LD_VAR 0 1
6415: PPUSH
6416: CALL_OW 250
6420: ADD
6421: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6422: LD_ADDR_EXP 1
6426: PUSH
6427: LD_EXP 1
6431: PUSH
6432: LD_VAR 0 1
6436: PPUSH
6437: CALL_OW 251
6441: ADD
6442: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6443: LD_ADDR_EXP 1
6447: PUSH
6448: LD_EXP 1
6452: PUSH
6453: LD_VAR 0 1
6457: PPUSH
6458: CALL_OW 254
6462: ADD
6463: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
6464: LD_VAR 0 1
6468: PPUSH
6469: CALL_OW 266
6473: PUSH
6474: LD_INT 3
6476: EQUAL
6477: IFFALSE 6556
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
6479: LD_ADDR_EXP 1
6483: PUSH
6484: LD_EXP 1
6488: PUSH
6489: LD_INT 2
6491: ADD
6492: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6493: LD_ADDR_EXP 1
6497: PUSH
6498: LD_EXP 1
6502: PUSH
6503: LD_VAR 0 1
6507: PPUSH
6508: CALL_OW 250
6512: ADD
6513: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6514: LD_ADDR_EXP 1
6518: PUSH
6519: LD_EXP 1
6523: PUSH
6524: LD_VAR 0 1
6528: PPUSH
6529: CALL_OW 251
6533: ADD
6534: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6535: LD_ADDR_EXP 1
6539: PUSH
6540: LD_EXP 1
6544: PUSH
6545: LD_VAR 0 1
6549: PPUSH
6550: CALL_OW 254
6554: ADD
6555: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
6556: LD_VAR 0 1
6560: PPUSH
6561: CALL_OW 266
6565: PUSH
6566: LD_INT 5
6568: EQUAL
6569: IFFALSE 6648
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
6571: LD_ADDR_EXP 1
6575: PUSH
6576: LD_EXP 1
6580: PUSH
6581: LD_INT 4
6583: ADD
6584: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6585: LD_ADDR_EXP 1
6589: PUSH
6590: LD_EXP 1
6594: PUSH
6595: LD_VAR 0 1
6599: PPUSH
6600: CALL_OW 250
6604: ADD
6605: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6606: LD_ADDR_EXP 1
6610: PUSH
6611: LD_EXP 1
6615: PUSH
6616: LD_VAR 0 1
6620: PPUSH
6621: CALL_OW 251
6625: ADD
6626: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6627: LD_ADDR_EXP 1
6631: PUSH
6632: LD_EXP 1
6636: PUSH
6637: LD_VAR 0 1
6641: PPUSH
6642: CALL_OW 254
6646: ADD
6647: ST_TO_ADDR
// end ; end ; if GetSide ( un ) = 3 and GetType ( un ) = unit_vehicle then
6648: LD_VAR 0 1
6652: PPUSH
6653: CALL_OW 255
6657: PUSH
6658: LD_INT 3
6660: EQUAL
6661: PUSH
6662: LD_VAR 0 1
6666: PPUSH
6667: CALL_OW 247
6671: PUSH
6672: LD_INT 2
6674: EQUAL
6675: AND
6676: IFFALSE 6780
// begin for i in CPU1DamageTanks do
6678: LD_ADDR_VAR 0 2
6682: PUSH
6683: LD_EXP 6
6687: PUSH
6688: FOR_IN
6689: IFFALSE 6778
// begin if i = un then
6691: LD_VAR 0 2
6695: PUSH
6696: LD_VAR 0 1
6700: EQUAL
6701: IFFALSE 6776
// begin AddComConstruct ( rufab , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
6703: LD_INT 30
6705: PPUSH
6706: LD_VAR 0 1
6710: PPUSH
6711: CALL_OW 265
6715: PPUSH
6716: LD_VAR 0 1
6720: PPUSH
6721: CALL_OW 262
6725: PPUSH
6726: LD_VAR 0 1
6730: PPUSH
6731: CALL_OW 263
6735: PPUSH
6736: LD_VAR 0 1
6740: PPUSH
6741: CALL_OW 264
6745: PPUSH
6746: CALL_OW 185
// CPU1DamageTanks = Delete ( CPU1DamageTanks , i [ i ] ) ;
6750: LD_ADDR_EXP 6
6754: PUSH
6755: LD_EXP 6
6759: PPUSH
6760: LD_VAR 0 2
6764: PUSH
6765: LD_VAR 0 2
6769: ARRAY
6770: PPUSH
6771: CALL_OW 3
6775: ST_TO_ADDR
// end ; end ;
6776: GO 6688
6778: POP
6779: POP
// end ; end ;
6780: PPOPN 2
6782: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6783: LD_VAR 0 1
6787: PPUSH
6788: CALL_OW 255
6792: PUSH
6793: LD_INT 3
6795: EQUAL
6796: IFFALSE 6870
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6798: LD_ADDR_EXP 1
6802: PUSH
6803: LD_EXP 1
6807: PPUSH
6808: LD_INT 1
6810: PPUSH
6811: CALL_OW 3
6815: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6816: LD_ADDR_EXP 1
6820: PUSH
6821: LD_EXP 1
6825: PPUSH
6826: LD_INT 1
6828: PPUSH
6829: CALL_OW 3
6833: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6834: LD_ADDR_EXP 1
6838: PUSH
6839: LD_EXP 1
6843: PPUSH
6844: LD_INT 1
6846: PPUSH
6847: CALL_OW 3
6851: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6852: LD_ADDR_EXP 1
6856: PUSH
6857: LD_EXP 1
6861: PPUSH
6862: LD_INT 1
6864: PPUSH
6865: CALL_OW 3
6869: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6870: LD_VAR 0 1
6874: PPUSH
6875: CALL_OW 255
6879: PUSH
6880: LD_INT 3
6882: EQUAL
6883: PUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 266
6893: PUSH
6894: LD_INT 0
6896: EQUAL
6897: PUSH
6898: LD_VAR 0 1
6902: PPUSH
6903: CALL_OW 266
6907: PUSH
6908: LD_INT 2
6910: EQUAL
6911: OR
6912: PUSH
6913: LD_VAR 0 1
6917: PPUSH
6918: CALL_OW 266
6922: PUSH
6923: LD_INT 4
6925: EQUAL
6926: OR
6927: PUSH
6928: EMPTY
6929: LIST
6930: AND
6931: IFFALSE 6942
// ComUpgrade ( building ) ;
6933: LD_VAR 0 1
6937: PPUSH
6938: CALL_OW 146
// end ;
6942: PPOPN 1
6944: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
6945: LD_VAR 0 1
6949: PPUSH
6950: CALL_OW 255
6954: PUSH
6955: LD_INT 3
6957: EQUAL
6958: IFFALSE 6976
// CPU1Tanks = CPU1Tanks ^ vehicle ;
6960: LD_ADDR_EXP 5
6964: PUSH
6965: LD_EXP 5
6969: PUSH
6970: LD_VAR 0 1
6974: ADD
6975: ST_TO_ADDR
// end ;
6976: PPOPN 2
6978: END
// on Command ( command_id ) do begin end ;
6979: PPOPN 1
6981: END
