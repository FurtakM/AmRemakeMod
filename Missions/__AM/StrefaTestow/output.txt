// export destroyedBuildings ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// end ;
  22: END
// every 0 0$1 do
  23: GO 25
  25: DISABLE
// ComEnterUnit ( eng1 , ee1 ) ;
  26: LD_INT 95
  28: PPUSH
  29: LD_INT 94
  31: PPUSH
  32: CALL_OW 120
  36: END
// every 0 0$1 do
  37: GO 39
  39: DISABLE
// begin enable ;
  40: ENABLE
// display_strings := GetTaskList ( eng1 ) ;
  41: LD_ADDR_OWVAR 47
  45: PUSH
  46: LD_INT 95
  48: PPUSH
  49: CALL_OW 437
  53: ST_TO_ADDR
// end ; end_of_file
  54: END
// every 0 0$1 do
  55: GO 57
  57: DISABLE
// begin enable ;
  58: ENABLE
// RepairVehicle ( 1 , reparea , 26 , 13 ) ;
  59: LD_INT 1
  61: PPUSH
  62: LD_INT 1
  64: PPUSH
  65: LD_INT 26
  67: PPUSH
  68: LD_INT 13
  70: PPUSH
  71: CALL 430 0 4
// RebuildBuildings ( 3 , destroyedBuildings ) ;
  75: LD_INT 3
  77: PPUSH
  78: LD_EXP 1
  82: PPUSH
  83: CALL 3131 0 2
// IntBazooka ( 3 , 1 ) ;
  87: LD_INT 3
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: CALL 3590 0 2
// end ;
  97: END
// every 5 5$1 do
  98: GO 100
 100: DISABLE
// begin end ; end_of_file
 101: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 102: LD_INT 0
 104: PPUSH
 105: PPUSH
 106: PPUSH
// rnd = rand ( 1 , characters ) ;
 107: LD_ADDR_VAR 0 6
 111: PUSH
 112: LD_INT 1
 114: PPUSH
 115: LD_VAR 0 1
 119: PPUSH
 120: CALL_OW 12
 124: ST_TO_ADDR
// for i = 1 to characters do
 125: LD_ADDR_VAR 0 5
 129: PUSH
 130: DOUBLE
 131: LD_INT 1
 133: DEC
 134: ST_TO_ADDR
 135: LD_VAR 0 1
 139: PUSH
 140: FOR_TO
 141: IFFALSE 251
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 143: LD_VAR 0 5
 147: PUSH
 148: LD_VAR 0 6
 152: EQUAL
 153: PUSH
 154: LD_VAR 0 1
 158: PUSH
 159: LD_VAR 0 5
 163: ARRAY
 164: PPUSH
 165: CALL_OW 258
 169: PUSH
 170: LD_INT 1
 172: EQUAL
 173: AND
 174: IFFALSE 196
// Say ( characters [ i ] , dialogMID ) ;
 176: LD_VAR 0 1
 180: PUSH
 181: LD_VAR 0 5
 185: ARRAY
 186: PPUSH
 187: LD_VAR 0 2
 191: PPUSH
 192: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 196: LD_VAR 0 5
 200: PUSH
 201: LD_VAR 0 6
 205: EQUAL
 206: PUSH
 207: LD_VAR 0 1
 211: PUSH
 212: LD_VAR 0 5
 216: ARRAY
 217: PPUSH
 218: CALL_OW 258
 222: PUSH
 223: LD_INT 2
 225: EQUAL
 226: AND
 227: IFFALSE 249
// Say ( characters [ i ] , dialogFID ) ;
 229: LD_VAR 0 1
 233: PUSH
 234: LD_VAR 0 5
 238: ARRAY
 239: PPUSH
 240: LD_VAR 0 3
 244: PPUSH
 245: CALL_OW 88
// end ;
 249: GO 140
 251: POP
 252: POP
// end ;
 253: LD_VAR 0 4
 257: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 258: LD_INT 0
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
// for i = 1 to count do
 264: LD_ADDR_VAR 0 8
 268: PUSH
 269: DOUBLE
 270: LD_INT 1
 272: DEC
 273: ST_TO_ADDR
 274: LD_VAR 0 6
 278: PUSH
 279: FOR_TO
 280: IFFALSE 361
// begin uc_side = side ;
 282: LD_ADDR_OWVAR 20
 286: PUSH
 287: LD_VAR 0 1
 291: ST_TO_ADDR
// uc_nation = nation ;
 292: LD_ADDR_OWVAR 21
 296: PUSH
 297: LD_VAR 0 2
 301: ST_TO_ADDR
// hc_gallery =  ;
 302: LD_ADDR_OWVAR 33
 306: PUSH
 307: LD_STRING 
 309: ST_TO_ADDR
// hc_name =  ;
 310: LD_ADDR_OWVAR 26
 314: PUSH
 315: LD_STRING 
 317: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 318: LD_INT 0
 320: PPUSH
 321: LD_VAR 0 5
 325: PPUSH
 326: LD_VAR 0 4
 330: PPUSH
 331: CALL_OW 380
// un = CreateHuman ;
 335: LD_ADDR_VAR 0 10
 339: PUSH
 340: CALL_OW 44
 344: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 345: LD_VAR 0 10
 349: PPUSH
 350: LD_VAR 0 3
 354: PPUSH
 355: CALL_OW 52
// end ;
 359: GO 279
 361: POP
 362: POP
// end ;
 363: LD_VAR 0 7
 367: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 368: LD_INT 0
 370: PPUSH
 371: PPUSH
// for i in charactersList do
 372: LD_ADDR_VAR 0 4
 376: PUSH
 377: LD_VAR 0 1
 381: PUSH
 382: FOR_IN
 383: IFFALSE 423
// begin if IsOk ( i ) then
 385: LD_VAR 0 4
 389: PPUSH
 390: CALL_OW 302
 394: IFFALSE 412
// begin SaveCharacters ( i , ident ) ;
 396: LD_VAR 0 4
 400: PPUSH
 401: LD_VAR 0 2
 405: PPUSH
 406: CALL_OW 38
// end else
 410: GO 421
// begin DeleteCharacters ( ident ) ;
 412: LD_VAR 0 2
 416: PPUSH
 417: CALL_OW 40
// end ; end ;
 421: GO 382
 423: POP
 424: POP
// end ;
 425: LD_VAR 0 3
 429: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
 430: LD_INT 0
 432: PPUSH
 433: PPUSH
 434: PPUSH
 435: PPUSH
 436: PPUSH
 437: PPUSH
 438: PPUSH
 439: PPUSH
 440: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: LD_INT 22
 448: PUSH
 449: LD_VAR 0 1
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: PUSH
 458: LD_INT 21
 460: PUSH
 461: LD_INT 2
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 24
 470: PUSH
 471: LD_INT 660
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 58
 483: PUSH
 484: EMPTY
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PPUSH
 497: CALL_OW 69
 501: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
 502: LD_ADDR_VAR 0 9
 506: PUSH
 507: LD_INT 22
 509: PUSH
 510: LD_VAR 0 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 21
 521: PUSH
 522: LD_INT 2
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 3
 531: PUSH
 532: LD_INT 24
 534: PUSH
 535: LD_INT 660
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 69
 555: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
 556: LD_ADDR_VAR 0 10
 560: PUSH
 561: LD_VAR 0 2
 565: PPUSH
 566: LD_INT 22
 568: PUSH
 569: LD_VAR 0 1
 573: PUSH
 574: EMPTY
 575: LIST
 576: LIST
 577: PUSH
 578: LD_INT 21
 580: PUSH
 581: LD_INT 2
 583: PUSH
 584: EMPTY
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 24
 593: PUSH
 594: LD_INT 1000
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL_OW 70
 614: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
 615: LD_ADDR_VAR 0 11
 619: PUSH
 620: LD_VAR 0 2
 624: PPUSH
 625: LD_INT 22
 627: PUSH
 628: LD_VAR 0 1
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 21
 639: PUSH
 640: LD_INT 2
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 1000
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 58
 659: PUSH
 660: EMPTY
 661: LIST
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: CALL_OW 70
 673: ST_TO_ADDR
// mechanicInside_list = [ ] ;
 674: LD_ADDR_VAR 0 12
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
 681: LD_ADDR_VAR 0 13
 685: PUSH
 686: LD_VAR 0 2
 690: PPUSH
 691: LD_INT 22
 693: PUSH
 694: LD_VAR 0 1
 698: PUSH
 699: EMPTY
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 25
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: PUSH
 713: EMPTY
 714: LIST
 715: LIST
 716: PPUSH
 717: CALL_OW 70
 721: ST_TO_ADDR
// if damageVehicle_list > 0 then
 722: LD_VAR 0 9
 726: PUSH
 727: LD_INT 0
 729: GREATER
 730: IFFALSE 789
// begin for i in damageVehicle_list do
 732: LD_ADDR_VAR 0 6
 736: PUSH
 737: LD_VAR 0 9
 741: PUSH
 742: FOR_IN
 743: IFFALSE 787
// begin ComMoveXY ( i , repX , repY ) ;
 745: LD_VAR 0 6
 749: PPUSH
 750: LD_VAR 0 3
 754: PPUSH
 755: LD_VAR 0 4
 759: PPUSH
 760: CALL_OW 111
// mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
 764: LD_ADDR_VAR 0 12
 768: PUSH
 769: LD_VAR 0 12
 773: PUSH
 774: LD_VAR 0 6
 778: PPUSH
 779: CALL_OW 313
 783: ADD
 784: ST_TO_ADDR
// end ;
 785: GO 742
 787: POP
 788: POP
// end ; if vehicleNeedRepair_list > 0 then
 789: LD_VAR 0 10
 793: PUSH
 794: LD_INT 0
 796: GREATER
 797: IFFALSE 863
// begin for i in mechanicInside_list do
 799: LD_ADDR_VAR 0 6
 803: PUSH
 804: LD_VAR 0 12
 808: PUSH
 809: FOR_IN
 810: IFFALSE 861
// begin for j in vehicleNeedRepair_list do
 812: LD_ADDR_VAR 0 7
 816: PUSH
 817: LD_VAR 0 10
 821: PUSH
 822: FOR_IN
 823: IFFALSE 857
// begin AddComExitVehicle ( i ) ;
 825: LD_VAR 0 6
 829: PPUSH
 830: CALL_OW 181
// wait ( 0 0$1 ) ;
 834: LD_INT 35
 836: PPUSH
 837: CALL_OW 67
// AddComRepairVehicle ( i , j ) ;
 841: LD_VAR 0 6
 845: PPUSH
 846: LD_VAR 0 7
 850: PPUSH
 851: CALL_OW 189
// end ;
 855: GO 822
 857: POP
 858: POP
// end ;
 859: GO 809
 861: POP
 862: POP
// end ; if vehicleDontNeedRepair_list > 0 then
 863: LD_VAR 0 11
 867: PUSH
 868: LD_INT 0
 870: GREATER
 871: IFFALSE 895
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
 873: LD_VAR 0 13
 877: PUSH
 878: LD_INT 1
 880: ARRAY
 881: PPUSH
 882: LD_VAR 0 11
 886: PUSH
 887: LD_INT 1
 889: ARRAY
 890: PPUSH
 891: CALL_OW 120
// end ; if vehicleOK_list > 0 then
 895: LD_VAR 0 8
 899: PUSH
 900: LD_INT 0
 902: GREATER
 903: IFFALSE 937
// begin for i in vehicleOK_list do
 905: LD_ADDR_VAR 0 6
 909: PUSH
 910: LD_VAR 0 8
 914: PUSH
 915: FOR_IN
 916: IFFALSE 935
// ComAgressiveMove ( i , 50 , 50 ) ;
 918: LD_VAR 0 6
 922: PPUSH
 923: LD_INT 50
 925: PPUSH
 926: LD_INT 50
 928: PPUSH
 929: CALL_OW 114
 933: GO 915
 935: POP
 936: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
 937: LD_ADDR_VAR 0 6
 941: PUSH
 942: LD_VAR 0 2
 946: PPUSH
 947: LD_INT 22
 949: PUSH
 950: LD_VAR 0 1
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: PUSH
 959: LD_INT 25
 961: PUSH
 962: LD_INT 3
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: PPUSH
 973: CALL_OW 70
 977: NOT
 978: PUSH
 979: FOR_IN
 980: IFFALSE 1003
// ComMoveXY ( i , repX , repY ) ;
 982: LD_VAR 0 6
 986: PPUSH
 987: LD_VAR 0 3
 991: PPUSH
 992: LD_VAR 0 4
 996: PPUSH
 997: CALL_OW 111
1001: GO 979
1003: POP
1004: POP
// end ;
1005: LD_VAR 0 5
1009: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
1010: LD_INT 0
1012: PPUSH
1013: PPUSH
1014: PPUSH
1015: PPUSH
1016: PPUSH
1017: PPUSH
1018: PPUSH
1019: PPUSH
1020: PPUSH
1021: PPUSH
1022: PPUSH
// amChassisTab = [ ] ;
1023: LD_ADDR_VAR 0 19
1027: PUSH
1028: EMPTY
1029: ST_TO_ADDR
// arChassisTab = [ ] ;
1030: LD_ADDR_VAR 0 18
1034: PUSH
1035: EMPTY
1036: ST_TO_ADDR
// ruChassisTab = [ ] ;
1037: LD_ADDR_VAR 0 17
1041: PUSH
1042: EMPTY
1043: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
1044: LD_INT 35
1046: PPUSH
1047: CALL_OW 67
// if nation = 1 then
1051: LD_VAR 0 5
1055: PUSH
1056: LD_INT 1
1058: EQUAL
1059: IFFALSE 1550
// begin uc_side = side ;
1061: LD_ADDR_OWVAR 20
1065: PUSH
1066: LD_VAR 0 2
1070: ST_TO_ADDR
// uc_nation = nation ;
1071: LD_ADDR_OWVAR 21
1075: PUSH
1076: LD_VAR 0 5
1080: ST_TO_ADDR
// vc_engine = vehengine ;
1081: LD_ADDR_OWVAR 39
1085: PUSH
1086: LD_VAR 0 6
1090: ST_TO_ADDR
// vc_control = vehcontrol ;
1091: LD_ADDR_OWVAR 38
1095: PUSH
1096: LD_VAR 0 7
1100: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
1101: LD_ADDR_OWVAR 40
1105: PUSH
1106: LD_VAR 0 10
1110: PUSH
1111: LD_INT 1
1113: PPUSH
1114: LD_VAR 0 10
1118: PPUSH
1119: CALL_OW 12
1123: ARRAY
1124: ST_TO_ADDR
// for j = 1 to AMWeapon do
1125: LD_ADDR_VAR 0 14
1129: PUSH
1130: DOUBLE
1131: LD_INT 1
1133: DEC
1134: ST_TO_ADDR
1135: LD_VAR 0 10
1139: PUSH
1140: FOR_TO
1141: IFFALSE 1442
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
1143: LD_VAR 0 10
1147: PUSH
1148: LD_VAR 0 14
1152: ARRAY
1153: PUSH
1154: LD_INT 2
1156: EQUAL
1157: PUSH
1158: LD_VAR 0 10
1162: PUSH
1163: LD_VAR 0 14
1167: ARRAY
1168: PUSH
1169: LD_INT 3
1171: EQUAL
1172: OR
1173: IFFALSE 1226
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
1175: LD_ADDR_VAR 0 19
1179: PUSH
1180: LD_INT 1
1182: PUSH
1183: LD_INT 2
1185: PUSH
1186: LD_INT 3
1188: PUSH
1189: LD_INT 4
1191: PUSH
1192: LD_INT 5
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: LIST
1201: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1202: LD_ADDR_OWVAR 37
1206: PUSH
1207: LD_VAR 0 19
1211: PUSH
1212: LD_INT 1
1214: PPUSH
1215: LD_VAR 0 19
1219: PPUSH
1220: CALL_OW 12
1224: ARRAY
1225: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
1226: LD_VAR 0 10
1230: PUSH
1231: LD_VAR 0 14
1235: ARRAY
1236: PUSH
1237: LD_INT 4
1239: EQUAL
1240: PUSH
1241: LD_VAR 0 10
1245: PUSH
1246: LD_VAR 0 14
1250: ARRAY
1251: PUSH
1252: LD_INT 5
1254: EQUAL
1255: OR
1256: PUSH
1257: LD_VAR 0 10
1261: PUSH
1262: LD_VAR 0 14
1266: ARRAY
1267: PUSH
1268: LD_INT 9
1270: EQUAL
1271: OR
1272: PUSH
1273: LD_VAR 0 10
1277: PUSH
1278: LD_VAR 0 14
1282: ARRAY
1283: PUSH
1284: LD_INT 11
1286: EQUAL
1287: OR
1288: PUSH
1289: LD_VAR 0 10
1293: PUSH
1294: LD_VAR 0 14
1298: ARRAY
1299: PUSH
1300: LD_INT 7
1302: EQUAL
1303: OR
1304: IFFALSE 1353
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1306: LD_ADDR_VAR 0 19
1310: PUSH
1311: LD_INT 2
1313: PUSH
1314: LD_INT 3
1316: PUSH
1317: LD_INT 4
1319: PUSH
1320: LD_INT 5
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1329: LD_ADDR_OWVAR 37
1333: PUSH
1334: LD_VAR 0 19
1338: PUSH
1339: LD_INT 1
1341: PPUSH
1342: LD_VAR 0 19
1346: PPUSH
1347: CALL_OW 12
1351: ARRAY
1352: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
1353: LD_VAR 0 10
1357: PUSH
1358: LD_VAR 0 14
1362: ARRAY
1363: PUSH
1364: LD_INT 8
1366: EQUAL
1367: PUSH
1368: LD_VAR 0 10
1372: PUSH
1373: LD_VAR 0 14
1377: ARRAY
1378: PUSH
1379: LD_INT 6
1381: EQUAL
1382: OR
1383: PUSH
1384: LD_VAR 0 10
1388: PUSH
1389: LD_VAR 0 14
1393: ARRAY
1394: PUSH
1395: LD_INT 10
1397: EQUAL
1398: OR
1399: IFFALSE 1440
// begin amChassisTab = [ 4 , 5 ] ;
1401: LD_ADDR_VAR 0 19
1405: PUSH
1406: LD_INT 4
1408: PUSH
1409: LD_INT 5
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1416: LD_ADDR_OWVAR 37
1420: PUSH
1421: LD_VAR 0 19
1425: PUSH
1426: LD_INT 1
1428: PPUSH
1429: LD_VAR 0 19
1433: PPUSH
1434: CALL_OW 12
1438: ARRAY
1439: ST_TO_ADDR
// end ; end ;
1440: GO 1140
1442: POP
1443: POP
// veh = CreateVehicle ;
1444: LD_ADDR_VAR 0 16
1448: PUSH
1449: CALL_OW 45
1453: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1454: LD_VAR 0 16
1458: PPUSH
1459: LD_VAR 0 1
1463: PPUSH
1464: LD_INT 0
1466: PPUSH
1467: CALL_OW 49
// if vehControl = 1 then
1471: LD_VAR 0 7
1475: PUSH
1476: LD_INT 1
1478: EQUAL
1479: IFFALSE 1536
// begin hc_gallery =  ;
1481: LD_ADDR_OWVAR 33
1485: PUSH
1486: LD_STRING 
1488: ST_TO_ADDR
// hc_name =  ;
1489: LD_ADDR_OWVAR 26
1493: PUSH
1494: LD_STRING 
1496: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1497: LD_INT 0
1499: PPUSH
1500: LD_INT 3
1502: PPUSH
1503: LD_VAR 0 4
1507: PPUSH
1508: CALL_OW 380
// un = CreateHuman ;
1512: LD_ADDR_VAR 0 15
1516: PUSH
1517: CALL_OW 44
1521: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1522: LD_VAR 0 15
1526: PPUSH
1527: LD_VAR 0 16
1531: PPUSH
1532: CALL_OW 52
// end ; i = i + 1 ;
1536: LD_ADDR_VAR 0 13
1540: PUSH
1541: LD_VAR 0 13
1545: PUSH
1546: LD_INT 1
1548: PLUS
1549: ST_TO_ADDR
// end ; if nation = 2 then
1550: LD_VAR 0 5
1554: PUSH
1555: LD_INT 2
1557: EQUAL
1558: IFFALSE 1982
// begin uc_side = side ;
1560: LD_ADDR_OWVAR 20
1564: PUSH
1565: LD_VAR 0 2
1569: ST_TO_ADDR
// uc_nation = nation ;
1570: LD_ADDR_OWVAR 21
1574: PUSH
1575: LD_VAR 0 5
1579: ST_TO_ADDR
// vc_engine = vehengine ;
1580: LD_ADDR_OWVAR 39
1584: PUSH
1585: LD_VAR 0 6
1589: ST_TO_ADDR
// vc_control = vehcontrol ;
1590: LD_ADDR_OWVAR 38
1594: PUSH
1595: LD_VAR 0 7
1599: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1600: LD_ADDR_OWVAR 40
1604: PUSH
1605: LD_VAR 0 9
1609: PUSH
1610: LD_INT 1
1612: PPUSH
1613: LD_VAR 0 9
1617: PPUSH
1618: CALL_OW 12
1622: ARRAY
1623: ST_TO_ADDR
// for j = 1 to ARWeapons do
1624: LD_ADDR_VAR 0 14
1628: PUSH
1629: DOUBLE
1630: LD_INT 1
1632: DEC
1633: ST_TO_ADDR
1634: LD_VAR 0 9
1638: PUSH
1639: FOR_TO
1640: IFFALSE 1874
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1642: LD_VAR 0 9
1646: PUSH
1647: LD_VAR 0 14
1651: ARRAY
1652: PUSH
1653: LD_INT 24
1655: EQUAL
1656: PUSH
1657: LD_VAR 0 9
1661: PUSH
1662: LD_VAR 0 14
1666: ARRAY
1667: PUSH
1668: LD_INT 22
1670: EQUAL
1671: OR
1672: PUSH
1673: LD_VAR 0 9
1677: PUSH
1678: LD_VAR 0 14
1682: ARRAY
1683: PUSH
1684: LD_INT 23
1686: EQUAL
1687: OR
1688: PUSH
1689: LD_VAR 0 9
1693: PUSH
1694: LD_VAR 0 14
1698: ARRAY
1699: PUSH
1700: LD_INT 30
1702: EQUAL
1703: OR
1704: IFFALSE 1753
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1706: LD_ADDR_VAR 0 18
1710: PUSH
1711: LD_INT 11
1713: PUSH
1714: LD_INT 12
1716: PUSH
1717: LD_INT 13
1719: PUSH
1720: LD_INT 14
1722: PUSH
1723: EMPTY
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1729: LD_ADDR_OWVAR 37
1733: PUSH
1734: LD_VAR 0 18
1738: PUSH
1739: LD_INT 1
1741: PPUSH
1742: LD_VAR 0 18
1746: PPUSH
1747: CALL_OW 12
1751: ARRAY
1752: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1753: LD_VAR 0 9
1757: PUSH
1758: LD_VAR 0 14
1762: ARRAY
1763: PUSH
1764: LD_INT 29
1766: EQUAL
1767: PUSH
1768: LD_VAR 0 9
1772: PUSH
1773: LD_VAR 0 14
1777: ARRAY
1778: PUSH
1779: LD_INT 28
1781: EQUAL
1782: OR
1783: PUSH
1784: LD_VAR 0 9
1788: PUSH
1789: LD_VAR 0 14
1793: ARRAY
1794: PUSH
1795: LD_INT 27
1797: EQUAL
1798: OR
1799: PUSH
1800: LD_VAR 0 9
1804: PUSH
1805: LD_VAR 0 14
1809: ARRAY
1810: PUSH
1811: LD_INT 26
1813: EQUAL
1814: OR
1815: PUSH
1816: LD_VAR 0 9
1820: PUSH
1821: LD_VAR 0 14
1825: ARRAY
1826: PUSH
1827: LD_INT 25
1829: EQUAL
1830: OR
1831: IFFALSE 1872
// begin arChassisTab = [ 13 , 14 ] ;
1833: LD_ADDR_VAR 0 18
1837: PUSH
1838: LD_INT 13
1840: PUSH
1841: LD_INT 14
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1848: LD_ADDR_OWVAR 37
1852: PUSH
1853: LD_VAR 0 18
1857: PUSH
1858: LD_INT 1
1860: PPUSH
1861: LD_VAR 0 18
1865: PPUSH
1866: CALL_OW 12
1870: ARRAY
1871: ST_TO_ADDR
// end ; end ;
1872: GO 1639
1874: POP
1875: POP
// veh = CreateVehicle ;
1876: LD_ADDR_VAR 0 16
1880: PUSH
1881: CALL_OW 45
1885: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1886: LD_VAR 0 16
1890: PPUSH
1891: LD_VAR 0 1
1895: PPUSH
1896: LD_INT 0
1898: PPUSH
1899: CALL_OW 49
// if vehcontrol = 1 then
1903: LD_VAR 0 7
1907: PUSH
1908: LD_INT 1
1910: EQUAL
1911: IFFALSE 1968
// begin hc_gallery =  ;
1913: LD_ADDR_OWVAR 33
1917: PUSH
1918: LD_STRING 
1920: ST_TO_ADDR
// hc_name =  ;
1921: LD_ADDR_OWVAR 26
1925: PUSH
1926: LD_STRING 
1928: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1929: LD_INT 0
1931: PPUSH
1932: LD_INT 3
1934: PPUSH
1935: LD_VAR 0 4
1939: PPUSH
1940: CALL_OW 380
// un = CreateHuman ;
1944: LD_ADDR_VAR 0 15
1948: PUSH
1949: CALL_OW 44
1953: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1954: LD_VAR 0 15
1958: PPUSH
1959: LD_VAR 0 16
1963: PPUSH
1964: CALL_OW 52
// end ; i = i + 1 ;
1968: LD_ADDR_VAR 0 13
1972: PUSH
1973: LD_VAR 0 13
1977: PUSH
1978: LD_INT 1
1980: PLUS
1981: ST_TO_ADDR
// end ; if nation = 3 then
1982: LD_VAR 0 5
1986: PUSH
1987: LD_INT 3
1989: EQUAL
1990: IFFALSE 2382
// begin uc_side = side ;
1992: LD_ADDR_OWVAR 20
1996: PUSH
1997: LD_VAR 0 2
2001: ST_TO_ADDR
// uc_nation = nation ;
2002: LD_ADDR_OWVAR 21
2006: PUSH
2007: LD_VAR 0 5
2011: ST_TO_ADDR
// vc_engine = vehengine ;
2012: LD_ADDR_OWVAR 39
2016: PUSH
2017: LD_VAR 0 6
2021: ST_TO_ADDR
// vc_control = vehcontrol ;
2022: LD_ADDR_OWVAR 38
2026: PUSH
2027: LD_VAR 0 7
2031: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
2032: LD_ADDR_OWVAR 40
2036: PUSH
2037: LD_VAR 0 8
2041: PUSH
2042: LD_INT 1
2044: PPUSH
2045: LD_VAR 0 8
2049: PPUSH
2050: CALL_OW 12
2054: ARRAY
2055: ST_TO_ADDR
// for j = 1 to RuWeapons do
2056: LD_ADDR_VAR 0 14
2060: PUSH
2061: DOUBLE
2062: LD_INT 1
2064: DEC
2065: ST_TO_ADDR
2066: LD_VAR 0 8
2070: PUSH
2071: FOR_TO
2072: IFFALSE 2274
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
2074: LD_VAR 0 8
2078: PUSH
2079: LD_VAR 0 14
2083: ARRAY
2084: PUSH
2085: LD_INT 42
2087: EQUAL
2088: PUSH
2089: LD_VAR 0 8
2093: PUSH
2094: LD_VAR 0 14
2098: ARRAY
2099: PUSH
2100: LD_INT 43
2102: EQUAL
2103: OR
2104: PUSH
2105: LD_VAR 0 8
2109: PUSH
2110: LD_VAR 0 14
2114: ARRAY
2115: PUSH
2116: LD_INT 44
2118: EQUAL
2119: OR
2120: PUSH
2121: LD_VAR 0 8
2125: PUSH
2126: LD_VAR 0 14
2130: ARRAY
2131: PUSH
2132: LD_INT 45
2134: EQUAL
2135: OR
2136: PUSH
2137: LD_VAR 0 8
2141: PUSH
2142: LD_VAR 0 14
2146: ARRAY
2147: PUSH
2148: LD_INT 49
2150: EQUAL
2151: OR
2152: IFFALSE 2201
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
2154: LD_ADDR_VAR 0 17
2158: PUSH
2159: LD_INT 21
2161: PUSH
2162: LD_INT 22
2164: PUSH
2165: LD_INT 23
2167: PUSH
2168: LD_INT 24
2170: PUSH
2171: EMPTY
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2177: LD_ADDR_OWVAR 37
2181: PUSH
2182: LD_VAR 0 17
2186: PUSH
2187: LD_INT 1
2189: PPUSH
2190: LD_VAR 0 17
2194: PPUSH
2195: CALL_OW 12
2199: ARRAY
2200: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
2201: LD_VAR 0 8
2205: PUSH
2206: LD_VAR 0 14
2210: ARRAY
2211: PUSH
2212: LD_INT 46
2214: EQUAL
2215: PUSH
2216: LD_VAR 0 8
2220: PUSH
2221: LD_VAR 0 14
2225: ARRAY
2226: PUSH
2227: LD_INT 47
2229: EQUAL
2230: OR
2231: IFFALSE 2272
// begin ruChassisTab = [ 23 , 24 ] ;
2233: LD_ADDR_VAR 0 17
2237: PUSH
2238: LD_INT 23
2240: PUSH
2241: LD_INT 24
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2248: LD_ADDR_OWVAR 37
2252: PUSH
2253: LD_VAR 0 17
2257: PUSH
2258: LD_INT 1
2260: PPUSH
2261: LD_VAR 0 17
2265: PPUSH
2266: CALL_OW 12
2270: ARRAY
2271: ST_TO_ADDR
// end ; end ;
2272: GO 2071
2274: POP
2275: POP
// veh = CreateVehicle ;
2276: LD_ADDR_VAR 0 16
2280: PUSH
2281: CALL_OW 45
2285: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2286: LD_VAR 0 16
2290: PPUSH
2291: LD_VAR 0 1
2295: PPUSH
2296: LD_INT 0
2298: PPUSH
2299: CALL_OW 49
// if vehcontrol = 1 then
2303: LD_VAR 0 7
2307: PUSH
2308: LD_INT 1
2310: EQUAL
2311: IFFALSE 2368
// begin hc_gallery =  ;
2313: LD_ADDR_OWVAR 33
2317: PUSH
2318: LD_STRING 
2320: ST_TO_ADDR
// hc_name =  ;
2321: LD_ADDR_OWVAR 26
2325: PUSH
2326: LD_STRING 
2328: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2329: LD_INT 0
2331: PPUSH
2332: LD_INT 3
2334: PPUSH
2335: LD_VAR 0 4
2339: PPUSH
2340: CALL_OW 380
// un = CreateHuman ;
2344: LD_ADDR_VAR 0 15
2348: PUSH
2349: CALL_OW 44
2353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2354: LD_VAR 0 15
2358: PPUSH
2359: LD_VAR 0 16
2363: PPUSH
2364: CALL_OW 52
// end ; i = i + 1 ;
2368: LD_ADDR_VAR 0 13
2372: PUSH
2373: LD_VAR 0 13
2377: PUSH
2378: LD_INT 1
2380: PLUS
2381: ST_TO_ADDR
// end ; until i = vehCount ;
2382: LD_VAR 0 13
2386: PUSH
2387: LD_VAR 0 3
2391: EQUAL
2392: IFFALSE 1044
// repeat wait ( 0 0$1 ) ;
2394: LD_INT 35
2396: PPUSH
2397: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2401: LD_ADDR_VAR 0 20
2405: PUSH
2406: LD_INT 22
2408: PUSH
2409: LD_VAR 0 2
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 21
2420: PUSH
2421: LD_INT 2
2423: PUSH
2424: EMPTY
2425: LIST
2426: LIST
2427: PUSH
2428: LD_INT 24
2430: PUSH
2431: LD_INT 650
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: PPUSH
2443: CALL_OW 69
2447: ST_TO_ADDR
// if vehicleOK_list > 0 then
2448: LD_VAR 0 20
2452: PUSH
2453: LD_INT 0
2455: GREATER
2456: IFFALSE 2647
// begin for i in vehicleOK_list do
2458: LD_ADDR_VAR 0 13
2462: PUSH
2463: LD_VAR 0 20
2467: PUSH
2468: FOR_IN
2469: IFFALSE 2645
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2471: LD_ADDR_VAR 0 21
2475: PUSH
2476: LD_INT 22
2478: PUSH
2479: LD_VAR 0 11
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: PPUSH
2488: CALL_OW 69
2492: PPUSH
2493: LD_VAR 0 13
2497: PPUSH
2498: CALL_OW 74
2502: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2503: LD_ADDR_VAR 0 22
2507: PUSH
2508: LD_INT 22
2510: PUSH
2511: LD_VAR 0 11
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: LD_INT 2
2522: PUSH
2523: LD_INT 59
2525: PUSH
2526: EMPTY
2527: LIST
2528: PUSH
2529: LD_INT 21
2531: PUSH
2532: LD_INT 1
2534: PUSH
2535: EMPTY
2536: LIST
2537: LIST
2538: PUSH
2539: LD_INT 21
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: PUSH
2559: EMPTY
2560: LIST
2561: PPUSH
2562: CALL_OW 69
2566: PPUSH
2567: LD_VAR 0 13
2571: PPUSH
2572: CALL_OW 74
2576: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2577: LD_VAR 0 13
2581: PPUSH
2582: LD_VAR 0 21
2586: PPUSH
2587: CALL_OW 296
2591: PUSH
2592: LD_INT 8
2594: PLUS
2595: PUSH
2596: LD_VAR 0 13
2600: PPUSH
2601: LD_VAR 0 22
2605: PPUSH
2606: CALL_OW 296
2610: LESS
2611: IFFALSE 2629
// begin ComAttackUnit ( i , target1 ) ;
2613: LD_VAR 0 13
2617: PPUSH
2618: LD_VAR 0 21
2622: PPUSH
2623: CALL_OW 115
// end else
2627: GO 2643
// begin ComAttackUnit ( i , target2 ) ;
2629: LD_VAR 0 13
2633: PPUSH
2634: LD_VAR 0 22
2638: PPUSH
2639: CALL_OW 115
// end ; end ;
2643: GO 2468
2645: POP
2646: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2647: LD_INT 22
2649: PUSH
2650: LD_VAR 0 2
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: LD_INT 21
2661: PUSH
2662: LD_INT 2
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: PUSH
2669: EMPTY
2670: LIST
2671: LIST
2672: PPUSH
2673: CALL_OW 69
2677: PUSH
2678: LD_INT 0
2680: EQUAL
2681: IFFALSE 2394
// end ;
2683: LD_VAR 0 12
2687: RET
// export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , targetSide , weaponTab , engine , control , chassis ) ; var i , j , temp , target1 , target2 ; begin
2688: LD_INT 0
2690: PPUSH
2691: PPUSH
2692: PPUSH
2693: PPUSH
2694: PPUSH
2695: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2696: LD_INT 22
2698: PUSH
2699: LD_VAR 0 1
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PUSH
2708: LD_INT 21
2710: PUSH
2711: LD_INT 2
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PPUSH
2722: CALL_OW 69
2726: PUSH
2727: LD_VAR 0 3
2731: LESSEQUAL
2732: IFFALSE 2799
// for i = 1 to vehCount do
2734: LD_ADDR_VAR 0 10
2738: PUSH
2739: DOUBLE
2740: LD_INT 1
2742: DEC
2743: ST_TO_ADDR
2744: LD_VAR 0 3
2748: PUSH
2749: FOR_TO
2750: IFFALSE 2797
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2752: LD_VAR 0 2
2756: PPUSH
2757: LD_VAR 0 8
2761: PPUSH
2762: LD_VAR 0 6
2766: PPUSH
2767: LD_VAR 0 7
2771: PPUSH
2772: LD_VAR 0 5
2776: PUSH
2777: LD_INT 1
2779: PPUSH
2780: LD_VAR 0 5
2784: PPUSH
2785: CALL_OW 12
2789: ARRAY
2790: PPUSH
2791: CALL_OW 185
2795: GO 2749
2797: POP
2798: POP
// repeat wait ( 0 0$1 ) ;
2799: LD_INT 35
2801: PPUSH
2802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] ] ) >= vehCount ;
2806: LD_INT 22
2808: PUSH
2809: LD_VAR 0 1
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 21
2820: PUSH
2821: LD_INT 2
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PUSH
2828: LD_INT 24
2830: PUSH
2831: LD_INT 250
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: PUSH
2838: EMPTY
2839: LIST
2840: LIST
2841: LIST
2842: PPUSH
2843: CALL_OW 69
2847: PUSH
2848: LD_VAR 0 3
2852: GREATEREQUAL
2853: IFFALSE 2799
// repeat begin wait ( 0 0$1 ) ;
2855: LD_INT 35
2857: PPUSH
2858: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 651 ] ] ) do
2862: LD_ADDR_VAR 0 10
2866: PUSH
2867: LD_INT 22
2869: PUSH
2870: LD_VAR 0 1
2874: PUSH
2875: EMPTY
2876: LIST
2877: LIST
2878: PUSH
2879: LD_INT 21
2881: PUSH
2882: LD_INT 2
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 24
2891: PUSH
2892: LD_INT 651
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: LIST
2903: PPUSH
2904: CALL_OW 69
2908: PUSH
2909: FOR_IN
2910: IFFALSE 3086
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2912: LD_ADDR_VAR 0 13
2916: PUSH
2917: LD_INT 22
2919: PUSH
2920: LD_VAR 0 4
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PPUSH
2929: CALL_OW 69
2933: PPUSH
2934: LD_VAR 0 10
2938: PPUSH
2939: CALL_OW 74
2943: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2944: LD_ADDR_VAR 0 14
2948: PUSH
2949: LD_INT 22
2951: PUSH
2952: LD_VAR 0 4
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 2
2963: PUSH
2964: LD_INT 59
2966: PUSH
2967: EMPTY
2968: LIST
2969: PUSH
2970: LD_INT 21
2972: PUSH
2973: LD_INT 1
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PUSH
2980: LD_INT 21
2982: PUSH
2983: LD_INT 2
2985: PUSH
2986: EMPTY
2987: LIST
2988: LIST
2989: PUSH
2990: EMPTY
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: PUSH
3000: EMPTY
3001: LIST
3002: PPUSH
3003: CALL_OW 69
3007: PPUSH
3008: LD_VAR 0 10
3012: PPUSH
3013: CALL_OW 74
3017: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
3018: LD_VAR 0 10
3022: PPUSH
3023: LD_VAR 0 13
3027: PPUSH
3028: CALL_OW 296
3032: PUSH
3033: LD_INT 8
3035: PLUS
3036: PUSH
3037: LD_VAR 0 10
3041: PPUSH
3042: LD_VAR 0 14
3046: PPUSH
3047: CALL_OW 296
3051: LESS
3052: IFFALSE 3070
// begin ComAttackUnit ( i , target1 ) ;
3054: LD_VAR 0 10
3058: PPUSH
3059: LD_VAR 0 13
3063: PPUSH
3064: CALL_OW 115
// end else
3068: GO 3084
// begin ComAttackUnit ( i , target2 ) ;
3070: LD_VAR 0 10
3074: PPUSH
3075: LD_VAR 0 14
3079: PPUSH
3080: CALL_OW 115
// end ; end ;
3084: GO 2909
3086: POP
3087: POP
// end until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount ;
3088: LD_INT 22
3090: PUSH
3091: LD_VAR 0 1
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: PUSH
3100: LD_INT 21
3102: PUSH
3103: LD_INT 2
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PPUSH
3114: CALL_OW 69
3118: PUSH
3119: LD_VAR 0 3
3123: LESSEQUAL
3124: IFFALSE 2855
// end ;
3126: LD_VAR 0 9
3130: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3131: LD_INT 0
3133: PPUSH
3134: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3135: LD_INT 22
3137: PUSH
3138: LD_VAR 0 1
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 25
3149: PUSH
3150: LD_INT 2
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PPUSH
3161: CALL_OW 69
3165: PUSH
3166: LD_INT 0
3168: GREATER
3169: PUSH
3170: LD_INT 22
3172: PUSH
3173: LD_VAR 0 1
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: PUSH
3182: LD_INT 21
3184: PUSH
3185: LD_INT 3
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 3
3194: PUSH
3195: LD_INT 24
3197: PUSH
3198: LD_INT 1000
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: LIST
3213: PPUSH
3214: CALL_OW 69
3218: PUSH
3219: LD_INT 0
3221: EQUAL
3222: AND
3223: PUSH
3224: LD_VAR 0 2
3228: PUSH
3229: LD_INT 0
3231: GREATER
3232: AND
3233: IFFALSE 3332
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3235: LD_ADDR_VAR 0 4
3239: PUSH
3240: LD_INT 22
3242: PUSH
3243: LD_VAR 0 1
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PUSH
3252: LD_INT 25
3254: PUSH
3255: LD_INT 2
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PPUSH
3266: CALL_OW 69
3270: PUSH
3271: FOR_IN
3272: IFFALSE 3330
// begin AddComExitBuilding ( i ) ;
3274: LD_VAR 0 4
3278: PPUSH
3279: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3283: LD_VAR 0 4
3287: PPUSH
3288: LD_VAR 0 2
3292: PUSH
3293: LD_INT 1
3295: ARRAY
3296: PPUSH
3297: LD_VAR 0 2
3301: PUSH
3302: LD_INT 2
3304: ARRAY
3305: PPUSH
3306: LD_VAR 0 2
3310: PUSH
3311: LD_INT 3
3313: ARRAY
3314: PPUSH
3315: LD_VAR 0 2
3319: PUSH
3320: LD_INT 4
3322: ARRAY
3323: PPUSH
3324: CALL_OW 205
// end ;
3328: GO 3271
3330: POP
3331: POP
// end ; end ;
3332: LD_VAR 0 3
3336: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3337: LD_INT 0
3339: PPUSH
3340: PPUSH
3341: PPUSH
3342: PPUSH
3343: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3344: LD_ADDR_VAR 0 6
3348: PUSH
3349: LD_INT 22
3351: PUSH
3352: LD_VAR 0 1
3356: PUSH
3357: EMPTY
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 2
3363: PUSH
3364: LD_INT 30
3366: PUSH
3367: LD_INT 31
3369: PUSH
3370: EMPTY
3371: LIST
3372: LIST
3373: PUSH
3374: LD_INT 30
3376: PUSH
3377: LD_INT 32
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 30
3386: PUSH
3387: LD_INT 33
3389: PUSH
3390: EMPTY
3391: LIST
3392: LIST
3393: PUSH
3394: LD_INT 30
3396: PUSH
3397: LD_INT 4
3399: PUSH
3400: EMPTY
3401: LIST
3402: LIST
3403: PUSH
3404: LD_INT 30
3406: PUSH
3407: LD_INT 5
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PPUSH
3426: CALL_OW 69
3430: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3431: LD_ADDR_VAR 0 7
3435: PUSH
3436: LD_INT 22
3438: PUSH
3439: LD_VAR 0 2
3443: PUSH
3444: EMPTY
3445: LIST
3446: LIST
3447: PUSH
3448: LD_INT 21
3450: PUSH
3451: LD_INT 3
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: PUSH
3458: LD_INT 58
3460: PUSH
3461: EMPTY
3462: LIST
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: LIST
3468: PPUSH
3469: CALL_OW 69
3473: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3474: LD_VAR 0 6
3478: PUSH
3479: LD_INT 0
3481: GREATER
3482: PUSH
3483: LD_VAR 0 7
3487: PUSH
3488: LD_INT 0
3490: GREATER
3491: AND
3492: IFFALSE 3585
// begin for i in turretsList do
3494: LD_ADDR_VAR 0 4
3498: PUSH
3499: LD_VAR 0 6
3503: PUSH
3504: FOR_IN
3505: IFFALSE 3583
// begin for j in enemyBuildings do
3507: LD_ADDR_VAR 0 5
3511: PUSH
3512: LD_VAR 0 7
3516: PUSH
3517: FOR_IN
3518: IFFALSE 3579
// begin display_strings = [ GetDistUnits ( i , j ) ] ;
3520: LD_ADDR_OWVAR 47
3524: PUSH
3525: LD_VAR 0 4
3529: PPUSH
3530: LD_VAR 0 5
3534: PPUSH
3535: CALL_OW 296
3539: PUSH
3540: EMPTY
3541: LIST
3542: ST_TO_ADDR
// if GetDistUnits ( i , j ) < 20 then
3543: LD_VAR 0 4
3547: PPUSH
3548: LD_VAR 0 5
3552: PPUSH
3553: CALL_OW 296
3557: PUSH
3558: LD_INT 20
3560: LESS
3561: IFFALSE 3577
// begin ComAttackUnit ( i , j ) ;
3563: LD_VAR 0 4
3567: PPUSH
3568: LD_VAR 0 5
3572: PPUSH
3573: CALL_OW 115
// end ; end ;
3577: GO 3517
3579: POP
3580: POP
// end ;
3581: GO 3504
3583: POP
3584: POP
// end ; end ;
3585: LD_VAR 0 3
3589: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3590: LD_INT 0
3592: PPUSH
3593: PPUSH
3594: PPUSH
3595: PPUSH
3596: PPUSH
3597: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3598: LD_ADDR_VAR 0 7
3602: PUSH
3603: LD_INT 22
3605: PUSH
3606: LD_VAR 0 1
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: LD_INT 25
3617: PUSH
3618: LD_INT 9
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: PPUSH
3629: CALL_OW 69
3633: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3634: LD_ADDR_VAR 0 8
3638: PUSH
3639: LD_INT 22
3641: PUSH
3642: LD_VAR 0 2
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: LD_INT 3
3653: PUSH
3654: LD_INT 21
3656: PUSH
3657: LD_INT 3
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: PUSH
3668: EMPTY
3669: LIST
3670: LIST
3671: PPUSH
3672: CALL_OW 69
3676: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3677: LD_ADDR_VAR 0 5
3681: PUSH
3682: LD_INT 1
3684: PPUSH
3685: LD_INT 3
3687: PPUSH
3688: CALL_OW 12
3692: ST_TO_ADDR
// for i = 1 to list do
3693: LD_ADDR_VAR 0 6
3697: PUSH
3698: DOUBLE
3699: LD_INT 1
3701: DEC
3702: ST_TO_ADDR
3703: LD_VAR 0 7
3707: PUSH
3708: FOR_TO
3709: IFFALSE 3891
// for ta in filter do
3711: LD_ADDR_VAR 0 4
3715: PUSH
3716: LD_VAR 0 8
3720: PUSH
3721: FOR_IN
3722: IFFALSE 3887
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3724: LD_VAR 0 7
3728: PUSH
3729: LD_VAR 0 6
3733: ARRAY
3734: PPUSH
3735: LD_VAR 0 4
3739: PPUSH
3740: CALL_OW 296
3744: PUSH
3745: LD_INT 13
3747: LESSEQUAL
3748: IFFALSE 3885
// begin case c of 1 :
3750: LD_VAR 0 5
3754: PUSH
3755: LD_INT 1
3757: DOUBLE
3758: EQUAL
3759: IFTRUE 3763
3761: GO 3801
3763: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3764: LD_VAR 0 7
3768: PUSH
3769: LD_VAR 0 6
3773: ARRAY
3774: PPUSH
3775: LD_VAR 0 4
3779: PPUSH
3780: CALL_OW 250
3784: PPUSH
3785: LD_VAR 0 4
3789: PPUSH
3790: CALL_OW 251
3794: PPUSH
3795: CALL_OW 154
3799: GO 3885
3801: LD_INT 2
3803: DOUBLE
3804: EQUAL
3805: IFTRUE 3809
3807: GO 3873
3809: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
3810: LD_VAR 0 7
3814: PUSH
3815: LD_VAR 0 6
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 4
3825: PPUSH
3826: CALL_OW 250
3830: PUSH
3831: LD_INT 1
3833: NEG
3834: PPUSH
3835: LD_INT 1
3837: PPUSH
3838: CALL_OW 12
3842: PLUS
3843: PPUSH
3844: LD_VAR 0 4
3848: PPUSH
3849: CALL_OW 251
3853: PUSH
3854: LD_INT 1
3856: NEG
3857: PPUSH
3858: LD_INT 1
3860: PPUSH
3861: CALL_OW 12
3865: PLUS
3866: PPUSH
3867: CALL_OW 153
3871: GO 3885
3873: LD_INT 3
3875: DOUBLE
3876: EQUAL
3877: IFTRUE 3881
3879: GO 3884
3881: POP
// ; end ;
3882: GO 3885
3884: POP
// end ; end ;
3885: GO 3721
3887: POP
3888: POP
3889: GO 3708
3891: POP
3892: POP
// end ; end_of_file
3893: LD_VAR 0 3
3897: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
3898: LD_INT 0
3900: PPUSH
3901: PPUSH
// if exist_mode then
3902: LD_VAR 0 2
3906: IFFALSE 3925
// unit := CreateCharacter ( ident ) else
3908: LD_ADDR_VAR 0 4
3912: PUSH
3913: LD_VAR 0 1
3917: PPUSH
3918: CALL_OW 34
3922: ST_TO_ADDR
3923: GO 3940
// unit := NewCharacter ( ident ) ;
3925: LD_ADDR_VAR 0 4
3929: PUSH
3930: LD_VAR 0 1
3934: PPUSH
3935: CALL_OW 25
3939: ST_TO_ADDR
// result := unit ;
3940: LD_ADDR_VAR 0 3
3944: PUSH
3945: LD_VAR 0 4
3949: ST_TO_ADDR
// end ;
3950: LD_VAR 0 3
3954: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
3955: LD_INT 0
3957: PPUSH
3958: PPUSH
3959: PPUSH
// uc_side := GetSide ( b ) ;
3960: LD_ADDR_OWVAR 20
3964: PUSH
3965: LD_VAR 0 2
3969: PPUSH
3970: CALL_OW 255
3974: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
3975: LD_ADDR_OWVAR 21
3979: PUSH
3980: LD_VAR 0 2
3984: PPUSH
3985: CALL_OW 248
3989: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3990: LD_INT 0
3992: PPUSH
3993: LD_INT 1
3995: PPUSH
3996: LD_VAR 0 1
4000: PPUSH
4001: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4005: LD_ADDR_VAR 0 5
4009: PUSH
4010: LD_VAR 0 2
4014: PPUSH
4015: CALL_OW 254
4019: PUSH
4020: LD_INT 3
4022: MINUS
4023: ST_TO_ADDR
// if dir < 0 then
4024: LD_VAR 0 5
4028: PUSH
4029: LD_INT 0
4031: LESS
4032: IFFALSE 4048
// dir := 6 + dir ;
4034: LD_ADDR_VAR 0 5
4038: PUSH
4039: LD_INT 6
4041: PUSH
4042: LD_VAR 0 5
4046: PLUS
4047: ST_TO_ADDR
// un := CreateHuman ;
4048: LD_ADDR_VAR 0 4
4052: PUSH
4053: CALL_OW 44
4057: ST_TO_ADDR
// SetDir ( un , dir ) ;
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_VAR 0 5
4067: PPUSH
4068: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4072: LD_VAR 0 4
4076: PPUSH
4077: LD_VAR 0 2
4081: PPUSH
4082: CALL_OW 52
// end ; end_of_file
4086: LD_VAR 0 3
4090: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
4091: LD_VAR 0 1
4095: PPUSH
4096: CALL_OW 255
4100: PUSH
4101: LD_INT 3
4103: EQUAL
4104: PUSH
4105: LD_VAR 0 1
4109: PPUSH
4110: CALL_OW 247
4114: PUSH
4115: LD_INT 3
4117: EQUAL
4118: AND
4119: IFFALSE 4811
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
4121: LD_VAR 0 1
4125: PPUSH
4126: CALL_OW 266
4130: PUSH
4131: LD_INT 31
4133: EQUAL
4134: PUSH
4135: LD_VAR 0 1
4139: PPUSH
4140: CALL_OW 266
4144: PUSH
4145: LD_INT 32
4147: EQUAL
4148: OR
4149: PUSH
4150: LD_VAR 0 1
4154: PPUSH
4155: CALL_OW 266
4159: PUSH
4160: LD_INT 36
4162: EQUAL
4163: OR
4164: PUSH
4165: LD_VAR 0 1
4169: PPUSH
4170: CALL_OW 266
4174: PUSH
4175: LD_INT 0
4177: EQUAL
4178: OR
4179: PUSH
4180: LD_VAR 0 1
4184: PPUSH
4185: CALL_OW 266
4189: PUSH
4190: LD_INT 24
4192: EQUAL
4193: OR
4194: PUSH
4195: LD_VAR 0 1
4199: PPUSH
4200: CALL_OW 266
4204: PUSH
4205: LD_INT 17
4207: EQUAL
4208: OR
4209: PUSH
4210: LD_VAR 0 1
4214: PPUSH
4215: CALL_OW 266
4219: PUSH
4220: LD_INT 25
4222: EQUAL
4223: OR
4224: PUSH
4225: LD_VAR 0 1
4229: PPUSH
4230: CALL_OW 266
4234: PUSH
4235: LD_INT 19
4237: EQUAL
4238: OR
4239: PUSH
4240: LD_VAR 0 1
4244: PPUSH
4245: CALL_OW 266
4249: PUSH
4250: LD_INT 20
4252: EQUAL
4253: OR
4254: PUSH
4255: LD_VAR 0 1
4259: PPUSH
4260: CALL_OW 266
4264: PUSH
4265: LD_INT 18
4267: EQUAL
4268: OR
4269: PUSH
4270: LD_VAR 0 1
4274: PPUSH
4275: CALL_OW 266
4279: PUSH
4280: LD_INT 21
4282: EQUAL
4283: OR
4284: PUSH
4285: LD_VAR 0 1
4289: PPUSH
4290: CALL_OW 266
4294: PUSH
4295: LD_INT 23
4297: EQUAL
4298: OR
4299: PUSH
4300: LD_VAR 0 1
4304: PPUSH
4305: CALL_OW 266
4309: PUSH
4310: LD_INT 16
4312: EQUAL
4313: OR
4314: PUSH
4315: LD_VAR 0 1
4319: PPUSH
4320: CALL_OW 266
4324: PUSH
4325: LD_INT 6
4327: EQUAL
4328: OR
4329: PUSH
4330: LD_VAR 0 1
4334: PPUSH
4335: CALL_OW 266
4339: PUSH
4340: LD_INT 29
4342: EQUAL
4343: OR
4344: PUSH
4345: LD_VAR 0 1
4349: PPUSH
4350: CALL_OW 266
4354: PUSH
4355: LD_INT 26
4357: EQUAL
4358: OR
4359: PUSH
4360: LD_VAR 0 1
4364: PPUSH
4365: CALL_OW 266
4369: PUSH
4370: LD_INT 30
4372: EQUAL
4373: OR
4374: PUSH
4375: LD_VAR 0 1
4379: PPUSH
4380: CALL_OW 266
4384: PUSH
4385: LD_INT 28
4387: EQUAL
4388: OR
4389: PUSH
4390: LD_VAR 0 1
4394: PPUSH
4395: CALL_OW 266
4399: PUSH
4400: LD_INT 27
4402: EQUAL
4403: OR
4404: PUSH
4405: LD_VAR 0 1
4409: PPUSH
4410: CALL_OW 266
4414: PUSH
4415: LD_INT 33
4417: EQUAL
4418: OR
4419: PUSH
4420: LD_VAR 0 1
4424: PPUSH
4425: CALL_OW 266
4429: PUSH
4430: LD_INT 2
4432: EQUAL
4433: OR
4434: PUSH
4435: LD_VAR 0 1
4439: PPUSH
4440: CALL_OW 266
4444: PUSH
4445: LD_INT 4
4447: EQUAL
4448: OR
4449: IFFALSE 4535
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
4451: LD_ADDR_EXP 1
4455: PUSH
4456: LD_EXP 1
4460: PUSH
4461: LD_VAR 0 1
4465: PPUSH
4466: CALL_OW 266
4470: ADD
4471: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4472: LD_ADDR_EXP 1
4476: PUSH
4477: LD_EXP 1
4481: PUSH
4482: LD_VAR 0 1
4486: PPUSH
4487: CALL_OW 250
4491: ADD
4492: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4493: LD_ADDR_EXP 1
4497: PUSH
4498: LD_EXP 1
4502: PUSH
4503: LD_VAR 0 1
4507: PPUSH
4508: CALL_OW 251
4512: ADD
4513: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4514: LD_ADDR_EXP 1
4518: PUSH
4519: LD_EXP 1
4523: PUSH
4524: LD_VAR 0 1
4528: PPUSH
4529: CALL_OW 254
4533: ADD
4534: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
4535: LD_VAR 0 1
4539: PPUSH
4540: CALL_OW 266
4544: PUSH
4545: LD_INT 1
4547: EQUAL
4548: IFFALSE 4627
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
4550: LD_ADDR_EXP 1
4554: PUSH
4555: LD_EXP 1
4559: PUSH
4560: LD_INT 0
4562: ADD
4563: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4564: LD_ADDR_EXP 1
4568: PUSH
4569: LD_EXP 1
4573: PUSH
4574: LD_VAR 0 1
4578: PPUSH
4579: CALL_OW 250
4583: ADD
4584: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4585: LD_ADDR_EXP 1
4589: PUSH
4590: LD_EXP 1
4594: PUSH
4595: LD_VAR 0 1
4599: PPUSH
4600: CALL_OW 251
4604: ADD
4605: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4606: LD_ADDR_EXP 1
4610: PUSH
4611: LD_EXP 1
4615: PUSH
4616: LD_VAR 0 1
4620: PPUSH
4621: CALL_OW 254
4625: ADD
4626: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4627: LD_VAR 0 1
4631: PPUSH
4632: CALL_OW 266
4636: PUSH
4637: LD_INT 3
4639: EQUAL
4640: IFFALSE 4719
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4642: LD_ADDR_EXP 1
4646: PUSH
4647: LD_EXP 1
4651: PUSH
4652: LD_INT 2
4654: ADD
4655: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4656: LD_ADDR_EXP 1
4660: PUSH
4661: LD_EXP 1
4665: PUSH
4666: LD_VAR 0 1
4670: PPUSH
4671: CALL_OW 250
4675: ADD
4676: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4677: LD_ADDR_EXP 1
4681: PUSH
4682: LD_EXP 1
4686: PUSH
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 251
4696: ADD
4697: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4698: LD_ADDR_EXP 1
4702: PUSH
4703: LD_EXP 1
4707: PUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 254
4717: ADD
4718: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4719: LD_VAR 0 1
4723: PPUSH
4724: CALL_OW 266
4728: PUSH
4729: LD_INT 5
4731: EQUAL
4732: IFFALSE 4811
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
4734: LD_ADDR_EXP 1
4738: PUSH
4739: LD_EXP 1
4743: PUSH
4744: LD_INT 4
4746: ADD
4747: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4748: LD_ADDR_EXP 1
4752: PUSH
4753: LD_EXP 1
4757: PUSH
4758: LD_VAR 0 1
4762: PPUSH
4763: CALL_OW 250
4767: ADD
4768: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4769: LD_ADDR_EXP 1
4773: PUSH
4774: LD_EXP 1
4778: PUSH
4779: LD_VAR 0 1
4783: PPUSH
4784: CALL_OW 251
4788: ADD
4789: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4790: LD_ADDR_EXP 1
4794: PUSH
4795: LD_EXP 1
4799: PUSH
4800: LD_VAR 0 1
4804: PPUSH
4805: CALL_OW 254
4809: ADD
4810: ST_TO_ADDR
// end ; end ; end ;
4811: PPOPN 1
4813: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
4814: LD_VAR 0 1
4818: PPUSH
4819: CALL_OW 255
4823: PUSH
4824: LD_INT 3
4826: EQUAL
4827: IFFALSE 4901
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4829: LD_ADDR_EXP 1
4833: PUSH
4834: LD_EXP 1
4838: PPUSH
4839: LD_INT 1
4841: PPUSH
4842: CALL_OW 3
4846: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4847: LD_ADDR_EXP 1
4851: PUSH
4852: LD_EXP 1
4856: PPUSH
4857: LD_INT 1
4859: PPUSH
4860: CALL_OW 3
4864: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4865: LD_ADDR_EXP 1
4869: PUSH
4870: LD_EXP 1
4874: PPUSH
4875: LD_INT 1
4877: PPUSH
4878: CALL_OW 3
4882: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4883: LD_ADDR_EXP 1
4887: PUSH
4888: LD_EXP 1
4892: PPUSH
4893: LD_INT 1
4895: PPUSH
4896: CALL_OW 3
4900: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
4901: LD_VAR 0 1
4905: PPUSH
4906: CALL_OW 255
4910: PUSH
4911: LD_INT 3
4913: EQUAL
4914: PUSH
4915: LD_VAR 0 1
4919: PPUSH
4920: CALL_OW 266
4924: PUSH
4925: LD_INT 0
4927: EQUAL
4928: PUSH
4929: LD_VAR 0 1
4933: PPUSH
4934: CALL_OW 266
4938: PUSH
4939: LD_INT 2
4941: EQUAL
4942: OR
4943: PUSH
4944: LD_VAR 0 1
4948: PPUSH
4949: CALL_OW 266
4953: PUSH
4954: LD_INT 4
4956: EQUAL
4957: OR
4958: PUSH
4959: EMPTY
4960: LIST
4961: AND
4962: IFFALSE 4973
// ComUpgrade ( building ) ;
4964: LD_VAR 0 1
4968: PPUSH
4969: CALL_OW 146
// end ;
4973: PPOPN 1
4975: END
