// export destroyedBuildings ; export cargoTest ; export arabianMines ; export JMM ; starting var i ; begin RandomizeAll ;
   0: CALL_OW 11
// destroyedBuildings = [ ] ;
   4: LD_ADDR_EXP 1
   8: PUSH
   9: EMPTY
  10: ST_TO_ADDR
// cargoTest = [ ] ;
  11: LD_ADDR_EXP 2
  15: PUSH
  16: EMPTY
  17: ST_TO_ADDR
// arabianMines = [ ] ;
  18: LD_ADDR_EXP 3
  22: PUSH
  23: EMPTY
  24: ST_TO_ADDR
// PlaceMines ( MineField1 , 10 ) ;
  25: LD_INT 5
  27: PPUSH
  28: LD_INT 10
  30: PPUSH
  31: CALL 5353 0 2
// end ;
  35: END
// every 0 0$01 do var b ;
  36: GO 38
  38: DISABLE
  39: LD_INT 0
  41: PPUSH
// begin end ;
  42: PPOPN 1
  44: END
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
  45: LD_INT 0
  47: PPUSH
  48: PPUSH
  49: PPUSH
  50: PPUSH
// for i = 1 to 3 do
  51: LD_ADDR_VAR 0 5
  55: PUSH
  56: DOUBLE
  57: LD_INT 1
  59: DEC
  60: ST_TO_ADDR
  61: LD_INT 3
  63: PUSH
  64: FOR_TO
  65: IFFALSE 95
// amount := amount + GetResourceArea ( area , i ) ;
  67: LD_ADDR_VAR 0 4
  71: PUSH
  72: LD_VAR 0 4
  76: PUSH
  77: LD_VAR 0 1
  81: PPUSH
  82: LD_VAR 0 5
  86: PPUSH
  87: CALL_OW 287
  91: PLUS
  92: ST_TO_ADDR
  93: GO 64
  95: POP
  96: POP
// if amount < materials then
  97: LD_VAR 0 4
 101: PUSH
 102: LD_VAR 0 2
 106: LESS
 107: IFFALSE 111
// exit ;
 109: GO 145
// for i = 1 to 3 do
 111: LD_ADDR_VAR 0 5
 115: PUSH
 116: DOUBLE
 117: LD_INT 1
 119: DEC
 120: ST_TO_ADDR
 121: LD_INT 3
 123: PUSH
 124: FOR_TO
 125: IFFALSE 143
// EraseResourceArea ( area , i ) ;
 127: LD_VAR 0 1
 131: PPUSH
 132: LD_VAR 0 5
 136: PPUSH
 137: CALL_OW 286
 141: GO 124
 143: POP
 144: POP
// end ;
 145: LD_VAR 0 3
 149: RET
// every 0 0$1 do
 150: GO 152
 152: DISABLE
// begin display_strings = [ arabianMines ] ;
 153: LD_ADDR_OWVAR 47
 157: PUSH
 158: LD_EXP 3
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// end ; end_of_file
 166: END
// every 0 0$1 do
 167: GO 169
 169: DISABLE
// begin enable ;
 170: ENABLE
// RepairBuilding ( 3 , rudepot ) ;
 171: LD_INT 3
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 4375 0 2
// HealUnitInBase ( 3 , RuHealArea , RussianBase , rulab ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 4
 186: PPUSH
 187: LD_INT 3
 189: PPUSH
 190: LD_INT 118
 192: PPUSH
 193: CALL 4663 0 4
// end ;
 197: END
// every 5 5$1 do
 198: GO 200
 200: DISABLE
// begin end ;
 201: END
// every 0 0$01 trigger arabianMines do var i , p ;
 202: LD_EXP 3
 206: IFFALSE 409
 208: GO 210
 210: DISABLE
 211: LD_INT 0
 213: PPUSH
 214: PPUSH
// begin enable ;
 215: ENABLE
// p := 1 ;
 216: LD_ADDR_VAR 0 2
 220: PUSH
 221: LD_INT 1
 223: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 224: LD_ADDR_VAR 0 1
 228: PUSH
 229: DOUBLE
 230: LD_INT 1
 232: DEC
 233: ST_TO_ADDR
 234: LD_EXP 3
 238: PUSH
 239: LD_INT 2
 241: DIVREAL
 242: PUSH
 243: FOR_TO
 244: IFFALSE 407
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 246: LD_INT 81
 248: PUSH
 249: LD_INT 2
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: PUSH
 256: LD_INT 92
 258: PUSH
 259: LD_EXP 3
 263: PUSH
 264: LD_VAR 0 2
 268: ARRAY
 269: PUSH
 270: LD_EXP 3
 274: PUSH
 275: LD_VAR 0 2
 279: PUSH
 280: LD_INT 1
 282: PLUS
 283: ARRAY
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: LIST
 297: PPUSH
 298: CALL_OW 69
 302: IFFALSE 391
// begin LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 304: LD_EXP 3
 308: PUSH
 309: LD_VAR 0 2
 313: ARRAY
 314: PPUSH
 315: LD_EXP 3
 319: PUSH
 320: LD_VAR 0 2
 324: PUSH
 325: LD_INT 1
 327: PLUS
 328: ARRAY
 329: PPUSH
 330: LD_INT 2
 332: PPUSH
 333: CALL_OW 456
// arabianMines := Delete ( arabianMines , p ) ;
 337: LD_ADDR_EXP 3
 341: PUSH
 342: LD_EXP 3
 346: PPUSH
 347: LD_VAR 0 2
 351: PPUSH
 352: CALL_OW 3
 356: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 357: LD_ADDR_EXP 3
 361: PUSH
 362: LD_EXP 3
 366: PPUSH
 367: LD_VAR 0 2
 371: PPUSH
 372: CALL_OW 3
 376: ST_TO_ADDR
// p := p - 2 ;
 377: LD_ADDR_VAR 0 2
 381: PUSH
 382: LD_VAR 0 2
 386: PUSH
 387: LD_INT 2
 389: MINUS
 390: ST_TO_ADDR
// end ; p := p + 2 ;
 391: LD_ADDR_VAR 0 2
 395: PUSH
 396: LD_VAR 0 2
 400: PUSH
 401: LD_INT 2
 403: PLUS
 404: ST_TO_ADDR
// end ;
 405: GO 243
 407: POP
 408: POP
// end ; end_of_file
 409: PPOPN 2
 411: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 412: LD_INT 0
 414: PPUSH
 415: PPUSH
 416: PPUSH
// rnd = rand ( 1 , characters ) ;
 417: LD_ADDR_VAR 0 6
 421: PUSH
 422: LD_INT 1
 424: PPUSH
 425: LD_VAR 0 1
 429: PPUSH
 430: CALL_OW 12
 434: ST_TO_ADDR
// for i = 1 to characters do
 435: LD_ADDR_VAR 0 5
 439: PUSH
 440: DOUBLE
 441: LD_INT 1
 443: DEC
 444: ST_TO_ADDR
 445: LD_VAR 0 1
 449: PUSH
 450: FOR_TO
 451: IFFALSE 561
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 453: LD_VAR 0 5
 457: PUSH
 458: LD_VAR 0 6
 462: EQUAL
 463: PUSH
 464: LD_VAR 0 1
 468: PUSH
 469: LD_VAR 0 5
 473: ARRAY
 474: PPUSH
 475: CALL_OW 258
 479: PUSH
 480: LD_INT 1
 482: EQUAL
 483: AND
 484: IFFALSE 506
// Say ( characters [ i ] , dialogMID ) ;
 486: LD_VAR 0 1
 490: PUSH
 491: LD_VAR 0 5
 495: ARRAY
 496: PPUSH
 497: LD_VAR 0 2
 501: PPUSH
 502: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 506: LD_VAR 0 5
 510: PUSH
 511: LD_VAR 0 6
 515: EQUAL
 516: PUSH
 517: LD_VAR 0 1
 521: PUSH
 522: LD_VAR 0 5
 526: ARRAY
 527: PPUSH
 528: CALL_OW 258
 532: PUSH
 533: LD_INT 2
 535: EQUAL
 536: AND
 537: IFFALSE 559
// Say ( characters [ i ] , dialogFID ) ;
 539: LD_VAR 0 1
 543: PUSH
 544: LD_VAR 0 5
 548: ARRAY
 549: PPUSH
 550: LD_VAR 0 3
 554: PPUSH
 555: CALL_OW 88
// end ;
 559: GO 450
 561: POP
 562: POP
// end ;
 563: LD_VAR 0 4
 567: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 568: LD_INT 0
 570: PPUSH
 571: PPUSH
 572: PPUSH
 573: PPUSH
// for i = 1 to count do
 574: LD_ADDR_VAR 0 8
 578: PUSH
 579: DOUBLE
 580: LD_INT 1
 582: DEC
 583: ST_TO_ADDR
 584: LD_VAR 0 6
 588: PUSH
 589: FOR_TO
 590: IFFALSE 671
// begin uc_side = side ;
 592: LD_ADDR_OWVAR 20
 596: PUSH
 597: LD_VAR 0 1
 601: ST_TO_ADDR
// uc_nation = nation ;
 602: LD_ADDR_OWVAR 21
 606: PUSH
 607: LD_VAR 0 2
 611: ST_TO_ADDR
// hc_gallery =  ;
 612: LD_ADDR_OWVAR 33
 616: PUSH
 617: LD_STRING 
 619: ST_TO_ADDR
// hc_name =  ;
 620: LD_ADDR_OWVAR 26
 624: PUSH
 625: LD_STRING 
 627: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 628: LD_INT 0
 630: PPUSH
 631: LD_VAR 0 5
 635: PPUSH
 636: LD_VAR 0 4
 640: PPUSH
 641: CALL_OW 380
// un = CreateHuman ;
 645: LD_ADDR_VAR 0 10
 649: PUSH
 650: CALL_OW 44
 654: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 655: LD_VAR 0 10
 659: PPUSH
 660: LD_VAR 0 3
 664: PPUSH
 665: CALL_OW 52
// end ;
 669: GO 589
 671: POP
 672: POP
// end ;
 673: LD_VAR 0 7
 677: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 678: LD_INT 0
 680: PPUSH
 681: PPUSH
// for i in charactersList do
 682: LD_ADDR_VAR 0 4
 686: PUSH
 687: LD_VAR 0 1
 691: PUSH
 692: FOR_IN
 693: IFFALSE 733
// begin if IsOk ( i ) then
 695: LD_VAR 0 4
 699: PPUSH
 700: CALL_OW 302
 704: IFFALSE 722
// begin SaveCharacters ( i , ident ) ;
 706: LD_VAR 0 4
 710: PPUSH
 711: LD_VAR 0 2
 715: PPUSH
 716: CALL_OW 38
// end else
 720: GO 731
// begin DeleteCharacters ( ident ) ;
 722: LD_VAR 0 2
 726: PPUSH
 727: CALL_OW 40
// end ; end ;
 731: GO 692
 733: POP
 734: POP
// end ;
 735: LD_VAR 0 3
 739: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 740: LD_INT 0
 742: PPUSH
 743: PPUSH
 744: PPUSH
 745: PPUSH
 746: PPUSH
 747: PPUSH
 748: PPUSH
 749: PPUSH
 750: PPUSH
 751: PPUSH
 752: PPUSH
// amChassisTab = [ ] ;
 753: LD_ADDR_VAR 0 19
 757: PUSH
 758: EMPTY
 759: ST_TO_ADDR
// arChassisTab = [ ] ;
 760: LD_ADDR_VAR 0 18
 764: PUSH
 765: EMPTY
 766: ST_TO_ADDR
// ruChassisTab = [ ] ;
 767: LD_ADDR_VAR 0 17
 771: PUSH
 772: EMPTY
 773: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 774: LD_INT 35
 776: PPUSH
 777: CALL_OW 67
// if nation = 1 then
 781: LD_VAR 0 5
 785: PUSH
 786: LD_INT 1
 788: EQUAL
 789: IFFALSE 1280
// begin uc_side = side ;
 791: LD_ADDR_OWVAR 20
 795: PUSH
 796: LD_VAR 0 2
 800: ST_TO_ADDR
// uc_nation = nation ;
 801: LD_ADDR_OWVAR 21
 805: PUSH
 806: LD_VAR 0 5
 810: ST_TO_ADDR
// vc_engine = vehengine ;
 811: LD_ADDR_OWVAR 39
 815: PUSH
 816: LD_VAR 0 6
 820: ST_TO_ADDR
// vc_control = vehcontrol ;
 821: LD_ADDR_OWVAR 38
 825: PUSH
 826: LD_VAR 0 7
 830: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 831: LD_ADDR_OWVAR 40
 835: PUSH
 836: LD_VAR 0 10
 840: PUSH
 841: LD_INT 1
 843: PPUSH
 844: LD_VAR 0 10
 848: PPUSH
 849: CALL_OW 12
 853: ARRAY
 854: ST_TO_ADDR
// for j = 1 to AMWeapon do
 855: LD_ADDR_VAR 0 14
 859: PUSH
 860: DOUBLE
 861: LD_INT 1
 863: DEC
 864: ST_TO_ADDR
 865: LD_VAR 0 10
 869: PUSH
 870: FOR_TO
 871: IFFALSE 1172
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 873: LD_VAR 0 10
 877: PUSH
 878: LD_VAR 0 14
 882: ARRAY
 883: PUSH
 884: LD_INT 2
 886: EQUAL
 887: PUSH
 888: LD_VAR 0 10
 892: PUSH
 893: LD_VAR 0 14
 897: ARRAY
 898: PUSH
 899: LD_INT 3
 901: EQUAL
 902: OR
 903: IFFALSE 956
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 905: LD_ADDR_VAR 0 19
 909: PUSH
 910: LD_INT 1
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 4
 921: PUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: LIST
 931: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 932: LD_ADDR_OWVAR 37
 936: PUSH
 937: LD_VAR 0 19
 941: PUSH
 942: LD_INT 1
 944: PPUSH
 945: LD_VAR 0 19
 949: PPUSH
 950: CALL_OW 12
 954: ARRAY
 955: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 956: LD_VAR 0 10
 960: PUSH
 961: LD_VAR 0 14
 965: ARRAY
 966: PUSH
 967: LD_INT 4
 969: EQUAL
 970: PUSH
 971: LD_VAR 0 10
 975: PUSH
 976: LD_VAR 0 14
 980: ARRAY
 981: PUSH
 982: LD_INT 5
 984: EQUAL
 985: OR
 986: PUSH
 987: LD_VAR 0 10
 991: PUSH
 992: LD_VAR 0 14
 996: ARRAY
 997: PUSH
 998: LD_INT 9
1000: EQUAL
1001: OR
1002: PUSH
1003: LD_VAR 0 10
1007: PUSH
1008: LD_VAR 0 14
1012: ARRAY
1013: PUSH
1014: LD_INT 11
1016: EQUAL
1017: OR
1018: PUSH
1019: LD_VAR 0 10
1023: PUSH
1024: LD_VAR 0 14
1028: ARRAY
1029: PUSH
1030: LD_INT 7
1032: EQUAL
1033: OR
1034: IFFALSE 1083
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1036: LD_ADDR_VAR 0 19
1040: PUSH
1041: LD_INT 2
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 4
1049: PUSH
1050: LD_INT 5
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1059: LD_ADDR_OWVAR 37
1063: PUSH
1064: LD_VAR 0 19
1068: PUSH
1069: LD_INT 1
1071: PPUSH
1072: LD_VAR 0 19
1076: PPUSH
1077: CALL_OW 12
1081: ARRAY
1082: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
1083: LD_VAR 0 10
1087: PUSH
1088: LD_VAR 0 14
1092: ARRAY
1093: PUSH
1094: LD_INT 8
1096: EQUAL
1097: PUSH
1098: LD_VAR 0 10
1102: PUSH
1103: LD_VAR 0 14
1107: ARRAY
1108: PUSH
1109: LD_INT 6
1111: EQUAL
1112: OR
1113: PUSH
1114: LD_VAR 0 10
1118: PUSH
1119: LD_VAR 0 14
1123: ARRAY
1124: PUSH
1125: LD_INT 10
1127: EQUAL
1128: OR
1129: IFFALSE 1170
// begin amChassisTab = [ 4 , 5 ] ;
1131: LD_ADDR_VAR 0 19
1135: PUSH
1136: LD_INT 4
1138: PUSH
1139: LD_INT 5
1141: PUSH
1142: EMPTY
1143: LIST
1144: LIST
1145: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1146: LD_ADDR_OWVAR 37
1150: PUSH
1151: LD_VAR 0 19
1155: PUSH
1156: LD_INT 1
1158: PPUSH
1159: LD_VAR 0 19
1163: PPUSH
1164: CALL_OW 12
1168: ARRAY
1169: ST_TO_ADDR
// end ; end ;
1170: GO 870
1172: POP
1173: POP
// veh = CreateVehicle ;
1174: LD_ADDR_VAR 0 16
1178: PUSH
1179: CALL_OW 45
1183: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1184: LD_VAR 0 16
1188: PPUSH
1189: LD_VAR 0 1
1193: PPUSH
1194: LD_INT 0
1196: PPUSH
1197: CALL_OW 49
// if vehControl = 1 then
1201: LD_VAR 0 7
1205: PUSH
1206: LD_INT 1
1208: EQUAL
1209: IFFALSE 1266
// begin hc_gallery =  ;
1211: LD_ADDR_OWVAR 33
1215: PUSH
1216: LD_STRING 
1218: ST_TO_ADDR
// hc_name =  ;
1219: LD_ADDR_OWVAR 26
1223: PUSH
1224: LD_STRING 
1226: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1227: LD_INT 0
1229: PPUSH
1230: LD_INT 3
1232: PPUSH
1233: LD_VAR 0 4
1237: PPUSH
1238: CALL_OW 380
// un = CreateHuman ;
1242: LD_ADDR_VAR 0 15
1246: PUSH
1247: CALL_OW 44
1251: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1252: LD_VAR 0 15
1256: PPUSH
1257: LD_VAR 0 16
1261: PPUSH
1262: CALL_OW 52
// end ; i = i + 1 ;
1266: LD_ADDR_VAR 0 13
1270: PUSH
1271: LD_VAR 0 13
1275: PUSH
1276: LD_INT 1
1278: PLUS
1279: ST_TO_ADDR
// end ; if nation = 2 then
1280: LD_VAR 0 5
1284: PUSH
1285: LD_INT 2
1287: EQUAL
1288: IFFALSE 1712
// begin uc_side = side ;
1290: LD_ADDR_OWVAR 20
1294: PUSH
1295: LD_VAR 0 2
1299: ST_TO_ADDR
// uc_nation = nation ;
1300: LD_ADDR_OWVAR 21
1304: PUSH
1305: LD_VAR 0 5
1309: ST_TO_ADDR
// vc_engine = vehengine ;
1310: LD_ADDR_OWVAR 39
1314: PUSH
1315: LD_VAR 0 6
1319: ST_TO_ADDR
// vc_control = vehcontrol ;
1320: LD_ADDR_OWVAR 38
1324: PUSH
1325: LD_VAR 0 7
1329: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1330: LD_ADDR_OWVAR 40
1334: PUSH
1335: LD_VAR 0 9
1339: PUSH
1340: LD_INT 1
1342: PPUSH
1343: LD_VAR 0 9
1347: PPUSH
1348: CALL_OW 12
1352: ARRAY
1353: ST_TO_ADDR
// for j = 1 to ARWeapons do
1354: LD_ADDR_VAR 0 14
1358: PUSH
1359: DOUBLE
1360: LD_INT 1
1362: DEC
1363: ST_TO_ADDR
1364: LD_VAR 0 9
1368: PUSH
1369: FOR_TO
1370: IFFALSE 1604
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1372: LD_VAR 0 9
1376: PUSH
1377: LD_VAR 0 14
1381: ARRAY
1382: PUSH
1383: LD_INT 24
1385: EQUAL
1386: PUSH
1387: LD_VAR 0 9
1391: PUSH
1392: LD_VAR 0 14
1396: ARRAY
1397: PUSH
1398: LD_INT 22
1400: EQUAL
1401: OR
1402: PUSH
1403: LD_VAR 0 9
1407: PUSH
1408: LD_VAR 0 14
1412: ARRAY
1413: PUSH
1414: LD_INT 23
1416: EQUAL
1417: OR
1418: PUSH
1419: LD_VAR 0 9
1423: PUSH
1424: LD_VAR 0 14
1428: ARRAY
1429: PUSH
1430: LD_INT 30
1432: EQUAL
1433: OR
1434: IFFALSE 1483
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1436: LD_ADDR_VAR 0 18
1440: PUSH
1441: LD_INT 11
1443: PUSH
1444: LD_INT 12
1446: PUSH
1447: LD_INT 13
1449: PUSH
1450: LD_INT 14
1452: PUSH
1453: EMPTY
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1459: LD_ADDR_OWVAR 37
1463: PUSH
1464: LD_VAR 0 18
1468: PUSH
1469: LD_INT 1
1471: PPUSH
1472: LD_VAR 0 18
1476: PPUSH
1477: CALL_OW 12
1481: ARRAY
1482: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1483: LD_VAR 0 9
1487: PUSH
1488: LD_VAR 0 14
1492: ARRAY
1493: PUSH
1494: LD_INT 29
1496: EQUAL
1497: PUSH
1498: LD_VAR 0 9
1502: PUSH
1503: LD_VAR 0 14
1507: ARRAY
1508: PUSH
1509: LD_INT 28
1511: EQUAL
1512: OR
1513: PUSH
1514: LD_VAR 0 9
1518: PUSH
1519: LD_VAR 0 14
1523: ARRAY
1524: PUSH
1525: LD_INT 27
1527: EQUAL
1528: OR
1529: PUSH
1530: LD_VAR 0 9
1534: PUSH
1535: LD_VAR 0 14
1539: ARRAY
1540: PUSH
1541: LD_INT 26
1543: EQUAL
1544: OR
1545: PUSH
1546: LD_VAR 0 9
1550: PUSH
1551: LD_VAR 0 14
1555: ARRAY
1556: PUSH
1557: LD_INT 25
1559: EQUAL
1560: OR
1561: IFFALSE 1602
// begin arChassisTab = [ 13 , 14 ] ;
1563: LD_ADDR_VAR 0 18
1567: PUSH
1568: LD_INT 13
1570: PUSH
1571: LD_INT 14
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1578: LD_ADDR_OWVAR 37
1582: PUSH
1583: LD_VAR 0 18
1587: PUSH
1588: LD_INT 1
1590: PPUSH
1591: LD_VAR 0 18
1595: PPUSH
1596: CALL_OW 12
1600: ARRAY
1601: ST_TO_ADDR
// end ; end ;
1602: GO 1369
1604: POP
1605: POP
// veh = CreateVehicle ;
1606: LD_ADDR_VAR 0 16
1610: PUSH
1611: CALL_OW 45
1615: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1616: LD_VAR 0 16
1620: PPUSH
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// if vehcontrol = 1 then
1633: LD_VAR 0 7
1637: PUSH
1638: LD_INT 1
1640: EQUAL
1641: IFFALSE 1698
// begin hc_gallery =  ;
1643: LD_ADDR_OWVAR 33
1647: PUSH
1648: LD_STRING 
1650: ST_TO_ADDR
// hc_name =  ;
1651: LD_ADDR_OWVAR 26
1655: PUSH
1656: LD_STRING 
1658: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1659: LD_INT 0
1661: PPUSH
1662: LD_INT 3
1664: PPUSH
1665: LD_VAR 0 4
1669: PPUSH
1670: CALL_OW 380
// un = CreateHuman ;
1674: LD_ADDR_VAR 0 15
1678: PUSH
1679: CALL_OW 44
1683: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1684: LD_VAR 0 15
1688: PPUSH
1689: LD_VAR 0 16
1693: PPUSH
1694: CALL_OW 52
// end ; i = i + 1 ;
1698: LD_ADDR_VAR 0 13
1702: PUSH
1703: LD_VAR 0 13
1707: PUSH
1708: LD_INT 1
1710: PLUS
1711: ST_TO_ADDR
// end ; if nation = 3 then
1712: LD_VAR 0 5
1716: PUSH
1717: LD_INT 3
1719: EQUAL
1720: IFFALSE 2112
// begin uc_side = side ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_VAR 0 2
1731: ST_TO_ADDR
// uc_nation = nation ;
1732: LD_ADDR_OWVAR 21
1736: PUSH
1737: LD_VAR 0 5
1741: ST_TO_ADDR
// vc_engine = vehengine ;
1742: LD_ADDR_OWVAR 39
1746: PUSH
1747: LD_VAR 0 6
1751: ST_TO_ADDR
// vc_control = vehcontrol ;
1752: LD_ADDR_OWVAR 38
1756: PUSH
1757: LD_VAR 0 7
1761: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1762: LD_ADDR_OWVAR 40
1766: PUSH
1767: LD_VAR 0 8
1771: PUSH
1772: LD_INT 1
1774: PPUSH
1775: LD_VAR 0 8
1779: PPUSH
1780: CALL_OW 12
1784: ARRAY
1785: ST_TO_ADDR
// for j = 1 to RuWeapons do
1786: LD_ADDR_VAR 0 14
1790: PUSH
1791: DOUBLE
1792: LD_INT 1
1794: DEC
1795: ST_TO_ADDR
1796: LD_VAR 0 8
1800: PUSH
1801: FOR_TO
1802: IFFALSE 2004
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1804: LD_VAR 0 8
1808: PUSH
1809: LD_VAR 0 14
1813: ARRAY
1814: PUSH
1815: LD_INT 42
1817: EQUAL
1818: PUSH
1819: LD_VAR 0 8
1823: PUSH
1824: LD_VAR 0 14
1828: ARRAY
1829: PUSH
1830: LD_INT 43
1832: EQUAL
1833: OR
1834: PUSH
1835: LD_VAR 0 8
1839: PUSH
1840: LD_VAR 0 14
1844: ARRAY
1845: PUSH
1846: LD_INT 44
1848: EQUAL
1849: OR
1850: PUSH
1851: LD_VAR 0 8
1855: PUSH
1856: LD_VAR 0 14
1860: ARRAY
1861: PUSH
1862: LD_INT 45
1864: EQUAL
1865: OR
1866: PUSH
1867: LD_VAR 0 8
1871: PUSH
1872: LD_VAR 0 14
1876: ARRAY
1877: PUSH
1878: LD_INT 49
1880: EQUAL
1881: OR
1882: IFFALSE 1931
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1884: LD_ADDR_VAR 0 17
1888: PUSH
1889: LD_INT 21
1891: PUSH
1892: LD_INT 22
1894: PUSH
1895: LD_INT 23
1897: PUSH
1898: LD_INT 24
1900: PUSH
1901: EMPTY
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1907: LD_ADDR_OWVAR 37
1911: PUSH
1912: LD_VAR 0 17
1916: PUSH
1917: LD_INT 1
1919: PPUSH
1920: LD_VAR 0 17
1924: PPUSH
1925: CALL_OW 12
1929: ARRAY
1930: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1931: LD_VAR 0 8
1935: PUSH
1936: LD_VAR 0 14
1940: ARRAY
1941: PUSH
1942: LD_INT 46
1944: EQUAL
1945: PUSH
1946: LD_VAR 0 8
1950: PUSH
1951: LD_VAR 0 14
1955: ARRAY
1956: PUSH
1957: LD_INT 47
1959: EQUAL
1960: OR
1961: IFFALSE 2002
// begin ruChassisTab = [ 23 , 24 ] ;
1963: LD_ADDR_VAR 0 17
1967: PUSH
1968: LD_INT 23
1970: PUSH
1971: LD_INT 24
1973: PUSH
1974: EMPTY
1975: LIST
1976: LIST
1977: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1978: LD_ADDR_OWVAR 37
1982: PUSH
1983: LD_VAR 0 17
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_VAR 0 17
1995: PPUSH
1996: CALL_OW 12
2000: ARRAY
2001: ST_TO_ADDR
// end ; end ;
2002: GO 1801
2004: POP
2005: POP
// veh = CreateVehicle ;
2006: LD_ADDR_VAR 0 16
2010: PUSH
2011: CALL_OW 45
2015: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2016: LD_VAR 0 16
2020: PPUSH
2021: LD_VAR 0 1
2025: PPUSH
2026: LD_INT 0
2028: PPUSH
2029: CALL_OW 49
// if vehcontrol = 1 then
2033: LD_VAR 0 7
2037: PUSH
2038: LD_INT 1
2040: EQUAL
2041: IFFALSE 2098
// begin hc_gallery =  ;
2043: LD_ADDR_OWVAR 33
2047: PUSH
2048: LD_STRING 
2050: ST_TO_ADDR
// hc_name =  ;
2051: LD_ADDR_OWVAR 26
2055: PUSH
2056: LD_STRING 
2058: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2059: LD_INT 0
2061: PPUSH
2062: LD_INT 3
2064: PPUSH
2065: LD_VAR 0 4
2069: PPUSH
2070: CALL_OW 380
// un = CreateHuman ;
2074: LD_ADDR_VAR 0 15
2078: PUSH
2079: CALL_OW 44
2083: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2084: LD_VAR 0 15
2088: PPUSH
2089: LD_VAR 0 16
2093: PPUSH
2094: CALL_OW 52
// end ; i = i + 1 ;
2098: LD_ADDR_VAR 0 13
2102: PUSH
2103: LD_VAR 0 13
2107: PUSH
2108: LD_INT 1
2110: PLUS
2111: ST_TO_ADDR
// end ; until i = vehCount ;
2112: LD_VAR 0 13
2116: PUSH
2117: LD_VAR 0 3
2121: EQUAL
2122: IFFALSE 774
// repeat wait ( 0 0$1 ) ;
2124: LD_INT 35
2126: PPUSH
2127: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2131: LD_ADDR_VAR 0 20
2135: PUSH
2136: LD_INT 22
2138: PUSH
2139: LD_VAR 0 2
2143: PUSH
2144: EMPTY
2145: LIST
2146: LIST
2147: PUSH
2148: LD_INT 21
2150: PUSH
2151: LD_INT 2
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: PUSH
2158: LD_INT 24
2160: PUSH
2161: LD_INT 650
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 69
2177: ST_TO_ADDR
// if vehicleOK_list > 0 then
2178: LD_VAR 0 20
2182: PUSH
2183: LD_INT 0
2185: GREATER
2186: IFFALSE 2377
// begin for i in vehicleOK_list do
2188: LD_ADDR_VAR 0 13
2192: PUSH
2193: LD_VAR 0 20
2197: PUSH
2198: FOR_IN
2199: IFFALSE 2375
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2201: LD_ADDR_VAR 0 21
2205: PUSH
2206: LD_INT 22
2208: PUSH
2209: LD_VAR 0 11
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: PPUSH
2218: CALL_OW 69
2222: PPUSH
2223: LD_VAR 0 13
2227: PPUSH
2228: CALL_OW 74
2232: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2233: LD_ADDR_VAR 0 22
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_VAR 0 11
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 2
2252: PUSH
2253: LD_INT 59
2255: PUSH
2256: EMPTY
2257: LIST
2258: PUSH
2259: LD_INT 21
2261: PUSH
2262: LD_INT 1
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: LD_INT 21
2271: PUSH
2272: LD_INT 2
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: LIST
2284: PUSH
2285: EMPTY
2286: LIST
2287: LIST
2288: PUSH
2289: EMPTY
2290: LIST
2291: PPUSH
2292: CALL_OW 69
2296: PPUSH
2297: LD_VAR 0 13
2301: PPUSH
2302: CALL_OW 74
2306: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2307: LD_VAR 0 13
2311: PPUSH
2312: LD_VAR 0 21
2316: PPUSH
2317: CALL_OW 296
2321: PUSH
2322: LD_INT 8
2324: PLUS
2325: PUSH
2326: LD_VAR 0 13
2330: PPUSH
2331: LD_VAR 0 22
2335: PPUSH
2336: CALL_OW 296
2340: LESS
2341: IFFALSE 2359
// begin ComAttackUnit ( i , target1 ) ;
2343: LD_VAR 0 13
2347: PPUSH
2348: LD_VAR 0 21
2352: PPUSH
2353: CALL_OW 115
// end else
2357: GO 2373
// begin ComAttackUnit ( i , target2 ) ;
2359: LD_VAR 0 13
2363: PPUSH
2364: LD_VAR 0 22
2368: PPUSH
2369: CALL_OW 115
// end ; end ;
2373: GO 2198
2375: POP
2376: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2377: LD_INT 22
2379: PUSH
2380: LD_VAR 0 2
2384: PUSH
2385: EMPTY
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 21
2391: PUSH
2392: LD_INT 2
2394: PUSH
2395: EMPTY
2396: LIST
2397: LIST
2398: PUSH
2399: EMPTY
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: IFFALSE 2124
// end ;
2413: LD_VAR 0 12
2417: RET
// every 0 0$1 do
2418: GO 2420
2420: DISABLE
// begin enable ;
2421: ENABLE
// end ;
2422: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2423: LD_INT 0
2425: PPUSH
2426: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2427: LD_INT 22
2429: PUSH
2430: LD_VAR 0 1
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: PUSH
2439: LD_INT 21
2441: PUSH
2442: LD_INT 2
2444: PUSH
2445: EMPTY
2446: LIST
2447: LIST
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PPUSH
2453: CALL_OW 69
2457: PUSH
2458: LD_VAR 0 3
2462: LESSEQUAL
2463: IFFALSE 2530
// for i = 1 to vehCount do
2465: LD_ADDR_VAR 0 9
2469: PUSH
2470: DOUBLE
2471: LD_INT 1
2473: DEC
2474: ST_TO_ADDR
2475: LD_VAR 0 3
2479: PUSH
2480: FOR_TO
2481: IFFALSE 2528
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2483: LD_VAR 0 2
2487: PPUSH
2488: LD_VAR 0 7
2492: PPUSH
2493: LD_VAR 0 5
2497: PPUSH
2498: LD_VAR 0 6
2502: PPUSH
2503: LD_VAR 0 4
2507: PUSH
2508: LD_INT 1
2510: PPUSH
2511: LD_VAR 0 4
2515: PPUSH
2516: CALL_OW 12
2520: ARRAY
2521: PPUSH
2522: CALL_OW 185
2526: GO 2480
2528: POP
2529: POP
// end ;
2530: LD_VAR 0 8
2534: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2535: LD_INT 0
2537: PPUSH
2538: PPUSH
2539: PPUSH
2540: PPUSH
2541: PPUSH
// for i := 1 to CPU1Tanks do
2542: LD_ADDR_VAR 0 4
2546: PUSH
2547: DOUBLE
2548: LD_INT 1
2550: DEC
2551: ST_TO_ADDR
2552: LD_EXP 5
2556: PUSH
2557: FOR_TO
2558: IFFALSE 2886
// begin if i = 4 then
2560: LD_VAR 0 4
2564: PUSH
2565: LD_INT 4
2567: EQUAL
2568: IFFALSE 2884
// begin repeat wait ( 0 0$1 ) ;
2570: LD_INT 35
2572: PPUSH
2573: CALL_OW 67
// for i in CPU1Tanks do
2577: LD_ADDR_VAR 0 4
2581: PUSH
2582: LD_EXP 5
2586: PUSH
2587: FOR_IN
2588: IFFALSE 2872
// begin if GetLives ( i ) < 659 then
2590: LD_VAR 0 4
2594: PPUSH
2595: CALL_OW 256
2599: PUSH
2600: LD_INT 659
2602: LESS
2603: IFFALSE 2691
// begin tmp = i ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 4
2614: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2615: LD_ADDR_VAR 0 4
2619: PUSH
2620: DOUBLE
2621: LD_INT 1
2623: DEC
2624: ST_TO_ADDR
2625: LD_EXP 5
2629: PUSH
2630: FOR_TO
2631: IFFALSE 2689
// begin if tmp = CPU1Tanks [ i ] then
2633: LD_VAR 0 5
2637: PUSH
2638: LD_EXP 5
2642: PUSH
2643: LD_VAR 0 4
2647: ARRAY
2648: EQUAL
2649: IFFALSE 2687
// begin CPU1Tanks = Delete ( CPU1Tanks , i ) ;
2651: LD_ADDR_EXP 5
2655: PUSH
2656: LD_EXP 5
2660: PPUSH
2661: LD_VAR 0 4
2665: PPUSH
2666: CALL_OW 3
2670: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2671: LD_ADDR_EXP 6
2675: PUSH
2676: LD_EXP 6
2680: PUSH
2681: LD_VAR 0 5
2685: ADD
2686: ST_TO_ADDR
// end ; end ;
2687: GO 2630
2689: POP
2690: POP
// end ; wait ( 0 0$1 ) ;
2691: LD_INT 35
2693: PPUSH
2694: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2698: LD_ADDR_VAR 0 6
2702: PUSH
2703: LD_INT 22
2705: PUSH
2706: LD_VAR 0 2
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PPUSH
2715: CALL_OW 69
2719: PPUSH
2720: LD_VAR 0 4
2724: PPUSH
2725: CALL_OW 74
2729: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2730: LD_ADDR_VAR 0 7
2734: PUSH
2735: LD_INT 22
2737: PUSH
2738: LD_VAR 0 2
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PUSH
2747: LD_INT 2
2749: PUSH
2750: LD_INT 59
2752: PUSH
2753: EMPTY
2754: LIST
2755: PUSH
2756: LD_INT 21
2758: PUSH
2759: LD_INT 1
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: PUSH
2766: LD_INT 21
2768: PUSH
2769: LD_INT 2
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: LIST
2780: LIST
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: PUSH
2786: EMPTY
2787: LIST
2788: PPUSH
2789: CALL_OW 69
2793: PPUSH
2794: LD_VAR 0 4
2798: PPUSH
2799: CALL_OW 74
2803: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2804: LD_VAR 0 4
2808: PPUSH
2809: LD_VAR 0 6
2813: PPUSH
2814: CALL_OW 296
2818: PUSH
2819: LD_INT 8
2821: PLUS
2822: PUSH
2823: LD_VAR 0 4
2827: PPUSH
2828: LD_VAR 0 7
2832: PPUSH
2833: CALL_OW 296
2837: LESS
2838: IFFALSE 2856
// begin ComAttackUnit ( i , target1 ) ;
2840: LD_VAR 0 4
2844: PPUSH
2845: LD_VAR 0 6
2849: PPUSH
2850: CALL_OW 115
// end else
2854: GO 2870
// begin ComAttackUnit ( i , target2 ) ;
2856: LD_VAR 0 4
2860: PPUSH
2861: LD_VAR 0 7
2865: PPUSH
2866: CALL_OW 115
// end ; end ;
2870: GO 2587
2872: POP
2873: POP
// until CPU1Tanks = 0 ;
2874: LD_EXP 5
2878: PUSH
2879: LD_INT 0
2881: EQUAL
2882: IFFALSE 2570
// end ; end ;
2884: GO 2557
2886: POP
2887: POP
// end ;
2888: LD_VAR 0 3
2892: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2893: LD_INT 0
2895: PPUSH
2896: PPUSH
2897: PPUSH
2898: PPUSH
2899: PPUSH
2900: PPUSH
2901: PPUSH
2902: PPUSH
2903: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
2904: LD_ADDR_VAR 0 8
2908: PUSH
2909: LD_INT 22
2911: PUSH
2912: LD_VAR 0 1
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: PUSH
2921: LD_INT 21
2923: PUSH
2924: LD_INT 2
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: PUSH
2931: LD_INT 24
2933: PUSH
2934: LD_INT 660
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 3
2943: PUSH
2944: LD_INT 58
2946: PUSH
2947: EMPTY
2948: LIST
2949: PUSH
2950: EMPTY
2951: LIST
2952: LIST
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PPUSH
2960: CALL_OW 69
2964: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2965: LD_ADDR_VAR 0 9
2969: PUSH
2970: LD_INT 22
2972: PUSH
2973: LD_VAR 0 1
2977: PUSH
2978: EMPTY
2979: LIST
2980: LIST
2981: PUSH
2982: LD_INT 21
2984: PUSH
2985: LD_INT 2
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: LD_INT 24
2997: PUSH
2998: LD_INT 660
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: LIST
3013: PPUSH
3014: CALL_OW 69
3018: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3019: LD_ADDR_VAR 0 10
3023: PUSH
3024: LD_VAR 0 2
3028: PPUSH
3029: LD_INT 22
3031: PUSH
3032: LD_VAR 0 1
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: PUSH
3041: LD_INT 21
3043: PUSH
3044: LD_INT 2
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: PUSH
3051: LD_INT 3
3053: PUSH
3054: LD_INT 24
3056: PUSH
3057: LD_INT 1000
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: PUSH
3068: EMPTY
3069: LIST
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 70
3077: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
3078: LD_ADDR_VAR 0 11
3082: PUSH
3083: LD_VAR 0 2
3087: PPUSH
3088: LD_INT 22
3090: PUSH
3091: LD_VAR 0 1
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: PUSH
3100: LD_INT 21
3102: PUSH
3103: LD_INT 2
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PUSH
3110: LD_INT 24
3112: PUSH
3113: LD_INT 1000
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: LD_INT 58
3122: PUSH
3123: EMPTY
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: PPUSH
3132: CALL_OW 70
3136: ST_TO_ADDR
// mechanicInside_list = [ ] ;
3137: LD_ADDR_VAR 0 12
3141: PUSH
3142: EMPTY
3143: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
3144: LD_ADDR_VAR 0 13
3148: PUSH
3149: LD_VAR 0 2
3153: PPUSH
3154: LD_INT 22
3156: PUSH
3157: LD_VAR 0 1
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: PUSH
3166: LD_INT 25
3168: PUSH
3169: LD_INT 3
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: PPUSH
3180: CALL_OW 70
3184: ST_TO_ADDR
// display_strings = [ w polu:  , CPU1Tanks , uszkodzone:  , CPU1DamageTanks , wylosowane: 4 , ok , vehicleOK_list ] ;
3185: LD_ADDR_OWVAR 47
3189: PUSH
3190: LD_STRING w polu: 
3192: PUSH
3193: LD_EXP 5
3197: PUSH
3198: LD_STRING uszkodzone: 
3200: PUSH
3201: LD_EXP 6
3205: PUSH
3206: LD_STRING wylosowane: 4
3208: PUSH
3209: LD_STRING ok
3211: PUSH
3212: LD_VAR 0 8
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: ST_TO_ADDR
// if damageVehicle_list > 0 then
3226: LD_VAR 0 9
3230: PUSH
3231: LD_INT 0
3233: GREATER
3234: IFFALSE 3272
// for i in damageVehicle_list do
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 9
3245: PUSH
3246: FOR_IN
3247: IFFALSE 3270
// ComMoveXY ( i , repX , repY ) ;
3249: LD_VAR 0 6
3253: PPUSH
3254: LD_VAR 0 3
3258: PPUSH
3259: LD_VAR 0 4
3263: PPUSH
3264: CALL_OW 111
3268: GO 3246
3270: POP
3271: POP
// if vehicleNeedRepair_list > 0 then
3272: LD_VAR 0 10
3276: PUSH
3277: LD_INT 0
3279: GREATER
3280: IFFALSE 3367
// begin for i in vehicleNeedRepair_list do
3282: LD_ADDR_VAR 0 6
3286: PUSH
3287: LD_VAR 0 10
3291: PUSH
3292: FOR_IN
3293: IFFALSE 3365
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
3295: LD_ADDR_VAR 0 12
3299: PUSH
3300: LD_VAR 0 12
3304: PUSH
3305: LD_VAR 0 6
3309: PPUSH
3310: CALL_OW 313
3314: ADD
3315: ST_TO_ADDR
// for j in mechanicInside_list do
3316: LD_ADDR_VAR 0 7
3320: PUSH
3321: LD_VAR 0 12
3325: PUSH
3326: FOR_IN
3327: IFFALSE 3361
// begin ComExitVehicle ( j ) ;
3329: LD_VAR 0 7
3333: PPUSH
3334: CALL_OW 121
// wait ( 0 0$1 ) ;
3338: LD_INT 35
3340: PPUSH
3341: CALL_OW 67
// AddComRepairVehicle ( j , i ) ;
3345: LD_VAR 0 7
3349: PPUSH
3350: LD_VAR 0 6
3354: PPUSH
3355: CALL_OW 189
// end ;
3359: GO 3326
3361: POP
3362: POP
// end ;
3363: GO 3292
3365: POP
3366: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3367: LD_VAR 0 11
3371: PUSH
3372: LD_INT 0
3374: GREATER
3375: IFFALSE 3399
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3377: LD_VAR 0 13
3381: PUSH
3382: LD_INT 1
3384: ARRAY
3385: PPUSH
3386: LD_VAR 0 11
3390: PUSH
3391: LD_INT 1
3393: ARRAY
3394: PPUSH
3395: CALL_OW 120
// end ; if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3399: LD_VAR 0 8
3403: PUSH
3404: LD_INT 0
3406: GREATER
3407: PUSH
3408: LD_EXP 6
3412: PUSH
3413: LD_INT 0
3415: GREATER
3416: AND
3417: IFFALSE 3558
// begin for i := 1 to vehicleOK_list do
3419: LD_ADDR_VAR 0 6
3423: PUSH
3424: DOUBLE
3425: LD_INT 1
3427: DEC
3428: ST_TO_ADDR
3429: LD_VAR 0 8
3433: PUSH
3434: FOR_TO
3435: IFFALSE 3556
// begin if i = 4 then
3437: LD_VAR 0 6
3441: PUSH
3442: LD_INT 4
3444: EQUAL
3445: IFFALSE 3554
// begin for i in vehicleOK_list do
3447: LD_ADDR_VAR 0 6
3451: PUSH
3452: LD_VAR 0 8
3456: PUSH
3457: FOR_IN
3458: IFFALSE 3478
// CPU1Tanks = CPU1Tanks ^ i ;
3460: LD_ADDR_EXP 5
3464: PUSH
3465: LD_EXP 5
3469: PUSH
3470: LD_VAR 0 6
3474: ADD
3475: ST_TO_ADDR
3476: GO 3457
3478: POP
3479: POP
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3480: LD_ADDR_EXP 6
3484: PUSH
3485: LD_EXP 6
3489: PPUSH
3490: LD_INT 1
3492: PPUSH
3493: CALL_OW 3
3497: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3498: LD_ADDR_EXP 6
3502: PUSH
3503: LD_EXP 6
3507: PPUSH
3508: LD_INT 1
3510: PPUSH
3511: CALL_OW 3
3515: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3516: LD_ADDR_EXP 6
3520: PUSH
3521: LD_EXP 6
3525: PPUSH
3526: LD_INT 1
3528: PPUSH
3529: CALL_OW 3
3533: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3534: LD_ADDR_EXP 6
3538: PUSH
3539: LD_EXP 6
3543: PPUSH
3544: LD_INT 1
3546: PPUSH
3547: CALL_OW 3
3551: ST_TO_ADDR
// break ;
3552: GO 3556
// end ; end ;
3554: GO 3434
3556: POP
3557: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3558: LD_ADDR_VAR 0 6
3562: PUSH
3563: LD_VAR 0 2
3567: PPUSH
3568: LD_INT 22
3570: PUSH
3571: LD_VAR 0 1
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: PUSH
3580: LD_INT 25
3582: PUSH
3583: LD_INT 3
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: PUSH
3590: EMPTY
3591: LIST
3592: LIST
3593: PPUSH
3594: CALL_OW 70
3598: NOT
3599: PUSH
3600: FOR_IN
3601: IFFALSE 3624
// ComMoveXY ( i , repX , repY ) ;
3603: LD_VAR 0 6
3607: PPUSH
3608: LD_VAR 0 3
3612: PPUSH
3613: LD_VAR 0 4
3617: PPUSH
3618: CALL_OW 111
3622: GO 3600
3624: POP
3625: POP
// end ;
3626: LD_VAR 0 5
3630: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3631: LD_INT 0
3633: PPUSH
3634: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3635: LD_INT 22
3637: PUSH
3638: LD_VAR 0 1
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: LD_INT 25
3649: PUSH
3650: LD_INT 2
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: PUSH
3657: EMPTY
3658: LIST
3659: LIST
3660: PPUSH
3661: CALL_OW 69
3665: PUSH
3666: LD_INT 0
3668: GREATER
3669: PUSH
3670: LD_INT 22
3672: PUSH
3673: LD_VAR 0 1
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: PUSH
3682: LD_INT 21
3684: PUSH
3685: LD_INT 3
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: PUSH
3692: LD_INT 3
3694: PUSH
3695: LD_INT 24
3697: PUSH
3698: LD_INT 1000
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: PPUSH
3714: CALL_OW 69
3718: PUSH
3719: LD_INT 0
3721: EQUAL
3722: AND
3723: PUSH
3724: LD_VAR 0 2
3728: PUSH
3729: LD_INT 0
3731: GREATER
3732: AND
3733: IFFALSE 3832
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: LD_INT 22
3742: PUSH
3743: LD_VAR 0 1
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: LD_INT 25
3754: PUSH
3755: LD_INT 2
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: PPUSH
3766: CALL_OW 69
3770: PUSH
3771: FOR_IN
3772: IFFALSE 3830
// begin AddComExitBuilding ( i ) ;
3774: LD_VAR 0 4
3778: PPUSH
3779: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3783: LD_VAR 0 4
3787: PPUSH
3788: LD_VAR 0 2
3792: PUSH
3793: LD_INT 1
3795: ARRAY
3796: PPUSH
3797: LD_VAR 0 2
3801: PUSH
3802: LD_INT 2
3804: ARRAY
3805: PPUSH
3806: LD_VAR 0 2
3810: PUSH
3811: LD_INT 3
3813: ARRAY
3814: PPUSH
3815: LD_VAR 0 2
3819: PUSH
3820: LD_INT 4
3822: ARRAY
3823: PPUSH
3824: CALL_OW 205
// end ;
3828: GO 3771
3830: POP
3831: POP
// end ; end ;
3832: LD_VAR 0 3
3836: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3837: LD_INT 0
3839: PPUSH
3840: PPUSH
3841: PPUSH
3842: PPUSH
3843: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3844: LD_ADDR_VAR 0 6
3848: PUSH
3849: LD_INT 22
3851: PUSH
3852: LD_VAR 0 1
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: PUSH
3861: LD_INT 2
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 31
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: LD_INT 30
3876: PUSH
3877: LD_INT 32
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PUSH
3884: LD_INT 30
3886: PUSH
3887: LD_INT 33
3889: PUSH
3890: EMPTY
3891: LIST
3892: LIST
3893: PUSH
3894: LD_INT 30
3896: PUSH
3897: LD_INT 4
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PUSH
3904: LD_INT 30
3906: PUSH
3907: LD_INT 5
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: PUSH
3914: EMPTY
3915: LIST
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: LIST
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PPUSH
3926: CALL_OW 69
3930: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3931: LD_ADDR_VAR 0 7
3935: PUSH
3936: LD_INT 22
3938: PUSH
3939: LD_VAR 0 2
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: PUSH
3948: LD_INT 21
3950: PUSH
3951: LD_INT 3
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: PUSH
3958: LD_INT 58
3960: PUSH
3961: EMPTY
3962: LIST
3963: PUSH
3964: EMPTY
3965: LIST
3966: LIST
3967: LIST
3968: PPUSH
3969: CALL_OW 69
3973: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3974: LD_VAR 0 6
3978: PUSH
3979: LD_INT 0
3981: GREATER
3982: PUSH
3983: LD_VAR 0 7
3987: PUSH
3988: LD_INT 0
3990: GREATER
3991: AND
3992: IFFALSE 4062
// begin for i in turretsList do
3994: LD_ADDR_VAR 0 4
3998: PUSH
3999: LD_VAR 0 6
4003: PUSH
4004: FOR_IN
4005: IFFALSE 4060
// begin for j in enemyBuildings do
4007: LD_ADDR_VAR 0 5
4011: PUSH
4012: LD_VAR 0 7
4016: PUSH
4017: FOR_IN
4018: IFFALSE 4056
// begin if GetDistUnits ( i , j ) < 20 then
4020: LD_VAR 0 4
4024: PPUSH
4025: LD_VAR 0 5
4029: PPUSH
4030: CALL_OW 296
4034: PUSH
4035: LD_INT 20
4037: LESS
4038: IFFALSE 4054
// begin ComAttackUnit ( i , j ) ;
4040: LD_VAR 0 4
4044: PPUSH
4045: LD_VAR 0 5
4049: PPUSH
4050: CALL_OW 115
// end ; end ;
4054: GO 4017
4056: POP
4057: POP
// end ;
4058: GO 4004
4060: POP
4061: POP
// end ; end ;
4062: LD_VAR 0 3
4066: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
4067: LD_INT 0
4069: PPUSH
4070: PPUSH
4071: PPUSH
4072: PPUSH
4073: PPUSH
4074: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
4075: LD_ADDR_VAR 0 7
4079: PUSH
4080: LD_INT 22
4082: PUSH
4083: LD_VAR 0 1
4087: PUSH
4088: EMPTY
4089: LIST
4090: LIST
4091: PUSH
4092: LD_INT 25
4094: PUSH
4095: LD_INT 9
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: PPUSH
4106: CALL_OW 69
4110: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4111: LD_ADDR_VAR 0 8
4115: PUSH
4116: LD_INT 22
4118: PUSH
4119: LD_VAR 0 2
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PUSH
4128: LD_INT 3
4130: PUSH
4131: LD_INT 21
4133: PUSH
4134: LD_INT 3
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: PUSH
4141: EMPTY
4142: LIST
4143: LIST
4144: PUSH
4145: EMPTY
4146: LIST
4147: LIST
4148: PPUSH
4149: CALL_OW 69
4153: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
4154: LD_ADDR_VAR 0 5
4158: PUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_INT 3
4164: PPUSH
4165: CALL_OW 12
4169: ST_TO_ADDR
// for i = 1 to list do
4170: LD_ADDR_VAR 0 6
4174: PUSH
4175: DOUBLE
4176: LD_INT 1
4178: DEC
4179: ST_TO_ADDR
4180: LD_VAR 0 7
4184: PUSH
4185: FOR_TO
4186: IFFALSE 4368
// for ta in filter do
4188: LD_ADDR_VAR 0 4
4192: PUSH
4193: LD_VAR 0 8
4197: PUSH
4198: FOR_IN
4199: IFFALSE 4364
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
4201: LD_VAR 0 7
4205: PUSH
4206: LD_VAR 0 6
4210: ARRAY
4211: PPUSH
4212: LD_VAR 0 4
4216: PPUSH
4217: CALL_OW 296
4221: PUSH
4222: LD_INT 13
4224: LESSEQUAL
4225: IFFALSE 4362
// begin case c of 1 :
4227: LD_VAR 0 5
4231: PUSH
4232: LD_INT 1
4234: DOUBLE
4235: EQUAL
4236: IFTRUE 4240
4238: GO 4278
4240: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4241: LD_VAR 0 7
4245: PUSH
4246: LD_VAR 0 6
4250: ARRAY
4251: PPUSH
4252: LD_VAR 0 4
4256: PPUSH
4257: CALL_OW 250
4261: PPUSH
4262: LD_VAR 0 4
4266: PPUSH
4267: CALL_OW 251
4271: PPUSH
4272: CALL_OW 154
4276: GO 4362
4278: LD_INT 2
4280: DOUBLE
4281: EQUAL
4282: IFTRUE 4286
4284: GO 4350
4286: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4287: LD_VAR 0 7
4291: PUSH
4292: LD_VAR 0 6
4296: ARRAY
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 250
4307: PUSH
4308: LD_INT 1
4310: NEG
4311: PPUSH
4312: LD_INT 1
4314: PPUSH
4315: CALL_OW 12
4319: PLUS
4320: PPUSH
4321: LD_VAR 0 4
4325: PPUSH
4326: CALL_OW 251
4330: PUSH
4331: LD_INT 1
4333: NEG
4334: PPUSH
4335: LD_INT 1
4337: PPUSH
4338: CALL_OW 12
4342: PLUS
4343: PPUSH
4344: CALL_OW 153
4348: GO 4362
4350: LD_INT 3
4352: DOUBLE
4353: EQUAL
4354: IFTRUE 4358
4356: GO 4361
4358: POP
// ; end ;
4359: GO 4362
4361: POP
// end ; end ;
4362: GO 4198
4364: POP
4365: POP
4366: GO 4185
4368: POP
4369: POP
// end ;
4370: LD_VAR 0 3
4374: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
4375: LD_INT 0
4377: PPUSH
4378: PPUSH
4379: PPUSH
4380: PPUSH
4381: PPUSH
4382: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
4383: LD_ADDR_VAR 0 6
4387: PUSH
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL_OW 313
4397: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
4398: LD_ADDR_VAR 0 7
4402: PUSH
4403: LD_INT 22
4405: PUSH
4406: LD_VAR 0 1
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 2
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 24
4427: PUSH
4428: LD_INT 1000
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 3
4437: PUSH
4438: LD_INT 54
4440: PUSH
4441: EMPTY
4442: LIST
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: PPUSH
4454: CALL_OW 69
4458: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4459: LD_ADDR_VAR 0 4
4463: PUSH
4464: LD_INT 22
4466: PUSH
4467: LD_VAR 0 1
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 21
4478: PUSH
4479: LD_INT 3
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 3
4488: PUSH
4489: LD_INT 24
4491: PUSH
4492: LD_INT 1000
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: PUSH
4503: EMPTY
4504: LIST
4505: LIST
4506: LIST
4507: PUSH
4508: EMPTY
4509: LIST
4510: PPUSH
4511: CALL_OW 69
4515: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4516: LD_VAR 0 4
4520: NOT
4521: PUSH
4522: LD_VAR 0 7
4526: NOT
4527: AND
4528: PUSH
4529: LD_EXP 1
4533: NOT
4534: AND
4535: IFFALSE 4539
// exit ;
4537: GO 4658
// if buildings_list > 0 and engineerOkInside then
4539: LD_VAR 0 4
4543: PUSH
4544: LD_INT 0
4546: GREATER
4547: PUSH
4548: LD_VAR 0 6
4552: AND
4553: IFFALSE 4586
// for i in UnitsInside ( building ) do
4555: LD_ADDR_VAR 0 5
4559: PUSH
4560: LD_VAR 0 2
4564: PPUSH
4565: CALL_OW 313
4569: PUSH
4570: FOR_IN
4571: IFFALSE 4584
// ComExitBuilding ( i ) ;
4573: LD_VAR 0 5
4577: PPUSH
4578: CALL_OW 122
4582: GO 4570
4584: POP
4585: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4586: LD_VAR 0 4
4590: PUSH
4591: LD_INT 0
4593: GREATER
4594: PUSH
4595: LD_VAR 0 7
4599: PUSH
4600: LD_INT 0
4602: GREATER
4603: AND
4604: IFFALSE 4658
// begin for i in engineerOkOutside do
4606: LD_ADDR_VAR 0 5
4610: PUSH
4611: LD_VAR 0 7
4615: PUSH
4616: FOR_IN
4617: IFFALSE 4656
// for j in buildings_list do
4619: LD_ADDR_VAR 0 8
4623: PUSH
4624: LD_VAR 0 4
4628: PUSH
4629: FOR_IN
4630: IFFALSE 4652
// ComRepairBuilding ( i , j [ 1 ] ) ;
4632: LD_VAR 0 5
4636: PPUSH
4637: LD_VAR 0 8
4641: PUSH
4642: LD_INT 1
4644: ARRAY
4645: PPUSH
4646: CALL_OW 130
4650: GO 4629
4652: POP
4653: POP
4654: GO 4616
4656: POP
4657: POP
// end ; end ;
4658: LD_VAR 0 3
4662: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4663: LD_INT 0
4665: PPUSH
4666: PPUSH
4667: PPUSH
4668: PPUSH
4669: PPUSH
4670: PPUSH
4671: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4672: LD_ADDR_VAR 0 6
4676: PUSH
4677: LD_INT 22
4679: PUSH
4680: LD_VAR 0 1
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: PUSH
4689: LD_INT 25
4691: PUSH
4692: LD_INT 4
4694: PUSH
4695: EMPTY
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 24
4701: PUSH
4702: LD_INT 251
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: LIST
4713: PPUSH
4714: CALL_OW 69
4718: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4719: LD_ADDR_VAR 0 7
4723: PUSH
4724: LD_VAR 0 3
4728: PPUSH
4729: LD_INT 22
4731: PUSH
4732: LD_VAR 0 1
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: PUSH
4741: LD_INT 25
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: PUSH
4751: LD_INT 50
4753: PUSH
4754: EMPTY
4755: LIST
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: LIST
4761: PPUSH
4762: CALL_OW 70
4766: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4767: LD_ADDR_VAR 0 10
4771: PUSH
4772: LD_VAR 0 3
4776: PPUSH
4777: LD_INT 22
4779: PUSH
4780: LD_VAR 0 1
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 21
4791: PUSH
4792: LD_INT 1
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: LD_INT 3
4801: PUSH
4802: LD_INT 24
4804: PUSH
4805: LD_INT 750
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: LIST
4820: PPUSH
4821: CALL_OW 70
4825: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4826: LD_ADDR_VAR 0 11
4830: PUSH
4831: LD_VAR 0 2
4835: PPUSH
4836: LD_INT 22
4838: PUSH
4839: LD_VAR 0 1
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 21
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 3
4860: PUSH
4861: LD_INT 24
4863: PUSH
4864: LD_INT 1000
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: PPUSH
4880: CALL_OW 70
4884: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
4885: LD_VAR 0 10
4889: NOT
4890: PUSH
4891: LD_VAR 0 7
4895: NOT
4896: AND
4897: PUSH
4898: LD_VAR 0 11
4902: NOT
4903: AND
4904: IFFALSE 4908
// exit ;
4906: GO 5097
// if damageUnits > 0 and sci_list > 0 then
4908: LD_VAR 0 10
4912: PUSH
4913: LD_INT 0
4915: GREATER
4916: PUSH
4917: LD_VAR 0 6
4921: PUSH
4922: LD_INT 0
4924: GREATER
4925: AND
4926: IFFALSE 4959
// for i in damageUnits do
4928: LD_ADDR_VAR 0 8
4932: PUSH
4933: LD_VAR 0 10
4937: PUSH
4938: FOR_IN
4939: IFFALSE 4957
// ComMoveToArea ( i , healArea ) ;
4941: LD_VAR 0 8
4945: PPUSH
4946: LD_VAR 0 2
4950: PPUSH
4951: CALL_OW 113
4955: GO 4938
4957: POP
4958: POP
// if unitsToHeal > 0 and sci_list > 0 then
4959: LD_VAR 0 11
4963: PUSH
4964: LD_INT 0
4966: GREATER
4967: PUSH
4968: LD_VAR 0 6
4972: PUSH
4973: LD_INT 0
4975: GREATER
4976: AND
4977: IFFALSE 5036
// begin for i in sci_list do
4979: LD_ADDR_VAR 0 8
4983: PUSH
4984: LD_VAR 0 6
4988: PUSH
4989: FOR_IN
4990: IFFALSE 5034
// begin ComExitBuilding ( i ) ;
4992: LD_VAR 0 8
4996: PPUSH
4997: CALL_OW 122
// for j in unitsToHeal do
5001: LD_ADDR_VAR 0 9
5005: PUSH
5006: LD_VAR 0 11
5010: PUSH
5011: FOR_IN
5012: IFFALSE 5030
// AddComHeal ( i , j ) ;
5014: LD_VAR 0 8
5018: PPUSH
5019: LD_VAR 0 9
5023: PPUSH
5024: CALL_OW 188
5028: GO 5011
5030: POP
5031: POP
// end ;
5032: GO 4989
5034: POP
5035: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
5036: LD_VAR 0 10
5040: PUSH
5041: LD_INT 0
5043: EQUAL
5044: PUSH
5045: LD_VAR 0 11
5049: PUSH
5050: LD_INT 0
5052: EQUAL
5053: AND
5054: PUSH
5055: LD_VAR 0 7
5059: PUSH
5060: LD_INT 0
5062: GREATER
5063: AND
5064: IFFALSE 5097
// for i in sci_listOutside do
5066: LD_ADDR_VAR 0 8
5070: PUSH
5071: LD_VAR 0 7
5075: PUSH
5076: FOR_IN
5077: IFFALSE 5095
// ComEnterUnit ( i , build ) ;
5079: LD_VAR 0 8
5083: PPUSH
5084: LD_VAR 0 4
5088: PPUSH
5089: CALL_OW 120
5093: GO 5076
5095: POP
5096: POP
// end ; end_of_file
5097: LD_VAR 0 5
5101: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
// if exist_mode then
5106: LD_VAR 0 2
5110: IFFALSE 5129
// unit := CreateCharacter ( ident ) else
5112: LD_ADDR_VAR 0 4
5116: PUSH
5117: LD_VAR 0 1
5121: PPUSH
5122: CALL_OW 34
5126: ST_TO_ADDR
5127: GO 5144
// unit := NewCharacter ( ident ) ;
5129: LD_ADDR_VAR 0 4
5133: PUSH
5134: LD_VAR 0 1
5138: PPUSH
5139: CALL_OW 25
5143: ST_TO_ADDR
// result := unit ;
5144: LD_ADDR_VAR 0 3
5148: PUSH
5149: LD_VAR 0 4
5153: ST_TO_ADDR
// end ;
5154: LD_VAR 0 3
5158: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
5159: LD_INT 0
5161: PPUSH
5162: PPUSH
5163: PPUSH
// uc_side := GetSide ( b ) ;
5164: LD_ADDR_OWVAR 20
5168: PUSH
5169: LD_VAR 0 2
5173: PPUSH
5174: CALL_OW 255
5178: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
5179: LD_ADDR_OWVAR 21
5183: PUSH
5184: LD_VAR 0 2
5188: PPUSH
5189: CALL_OW 248
5193: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5194: LD_INT 0
5196: PPUSH
5197: LD_INT 1
5199: PPUSH
5200: LD_VAR 0 1
5204: PPUSH
5205: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
5209: LD_ADDR_VAR 0 5
5213: PUSH
5214: LD_VAR 0 2
5218: PPUSH
5219: CALL_OW 254
5223: PUSH
5224: LD_INT 3
5226: MINUS
5227: ST_TO_ADDR
// if dir < 0 then
5228: LD_VAR 0 5
5232: PUSH
5233: LD_INT 0
5235: LESS
5236: IFFALSE 5252
// dir := 6 + dir ;
5238: LD_ADDR_VAR 0 5
5242: PUSH
5243: LD_INT 6
5245: PUSH
5246: LD_VAR 0 5
5250: PLUS
5251: ST_TO_ADDR
// un := CreateHuman ;
5252: LD_ADDR_VAR 0 4
5256: PUSH
5257: CALL_OW 44
5261: ST_TO_ADDR
// SetDir ( un , dir ) ;
5262: LD_VAR 0 4
5266: PPUSH
5267: LD_VAR 0 5
5271: PPUSH
5272: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5276: LD_VAR 0 4
5280: PPUSH
5281: LD_VAR 0 2
5285: PPUSH
5286: CALL_OW 52
// end ;
5290: LD_VAR 0 3
5294: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
5295: LD_INT 0
5297: PPUSH
5298: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
5299: LD_ADDR_VAR 0 2
5303: PUSH
5304: LD_VAR 0 1
5308: PPUSH
5309: LD_INT 1
5311: PPUSH
5312: CALL_OW 289
5316: PUSH
5317: LD_VAR 0 1
5321: PPUSH
5322: LD_INT 2
5324: PPUSH
5325: CALL_OW 289
5329: PUSH
5330: LD_VAR 0 1
5334: PPUSH
5335: LD_INT 3
5337: PPUSH
5338: CALL_OW 289
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: LIST
5347: ST_TO_ADDR
// end ;
5348: LD_VAR 0 2
5352: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
5353: LD_INT 0
5355: PPUSH
5356: PPUSH
5357: PPUSH
5358: PPUSH
// r := 100 ;
5359: LD_ADDR_VAR 0 5
5363: PUSH
5364: LD_INT 100
5366: ST_TO_ADDR
// x := 0 ;
5367: LD_ADDR_VAR 0 6
5371: PUSH
5372: LD_INT 0
5374: ST_TO_ADDR
// while ( x < n ) do
5375: LD_VAR 0 6
5379: PUSH
5380: LD_VAR 0 2
5384: LESS
5385: IFFALSE 5698
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
5387: LD_ADDR_VAR 0 4
5391: PUSH
5392: DOUBLE
5393: LD_INT 1
5395: DEC
5396: ST_TO_ADDR
5397: LD_VAR 0 1
5401: PPUSH
5402: LD_INT 0
5404: PPUSH
5405: CALL_OW 517
5409: PUSH
5410: LD_INT 1
5412: ARRAY
5413: PUSH
5414: FOR_TO
5415: IFFALSE 5694
// begin if r > 50 then
5417: LD_VAR 0 5
5421: PUSH
5422: LD_INT 50
5424: GREATER
5425: IFFALSE 5670
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
5427: LD_VAR 0 1
5431: PPUSH
5432: LD_INT 0
5434: PPUSH
5435: CALL_OW 517
5439: PUSH
5440: LD_INT 1
5442: ARRAY
5443: PUSH
5444: LD_VAR 0 4
5448: ARRAY
5449: PPUSH
5450: LD_VAR 0 1
5454: PPUSH
5455: LD_INT 0
5457: PPUSH
5458: CALL_OW 517
5462: PUSH
5463: LD_INT 2
5465: ARRAY
5466: PUSH
5467: LD_VAR 0 4
5471: ARRAY
5472: PPUSH
5473: CALL_OW 458
5477: NOT
5478: IFFALSE 5654
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , 2 , 0 ) ;
5480: LD_VAR 0 1
5484: PPUSH
5485: LD_INT 0
5487: PPUSH
5488: CALL_OW 517
5492: PUSH
5493: LD_INT 1
5495: ARRAY
5496: PUSH
5497: LD_VAR 0 4
5501: ARRAY
5502: PPUSH
5503: LD_VAR 0 1
5507: PPUSH
5508: LD_INT 0
5510: PPUSH
5511: CALL_OW 517
5515: PUSH
5516: LD_INT 2
5518: ARRAY
5519: PUSH
5520: LD_VAR 0 4
5524: ARRAY
5525: PPUSH
5526: LD_INT 2
5528: PPUSH
5529: LD_INT 0
5531: PPUSH
5532: CALL_OW 454
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
5536: LD_ADDR_EXP 3
5540: PUSH
5541: LD_EXP 3
5545: PPUSH
5546: LD_EXP 3
5550: PUSH
5551: LD_INT 1
5553: PLUS
5554: PPUSH
5555: LD_VAR 0 1
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: CALL_OW 517
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PUSH
5572: LD_VAR 0 4
5576: ARRAY
5577: PPUSH
5578: CALL_OW 2
5582: ST_TO_ADDR
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
5583: LD_ADDR_EXP 3
5587: PUSH
5588: LD_EXP 3
5592: PPUSH
5593: LD_EXP 3
5597: PUSH
5598: LD_INT 1
5600: PLUS
5601: PPUSH
5602: LD_VAR 0 1
5606: PPUSH
5607: LD_INT 0
5609: PPUSH
5610: CALL_OW 517
5614: PUSH
5615: LD_INT 2
5617: ARRAY
5618: PUSH
5619: LD_VAR 0 4
5623: ARRAY
5624: PPUSH
5625: CALL_OW 2
5629: ST_TO_ADDR
// r := 0 ;
5630: LD_ADDR_VAR 0 5
5634: PUSH
5635: LD_INT 0
5637: ST_TO_ADDR
// x := x + 1 ;
5638: LD_ADDR_VAR 0 6
5642: PUSH
5643: LD_VAR 0 6
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: ST_TO_ADDR
// end else
5652: GO 5668
// r := r + 35 ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PUSH
5664: LD_INT 35
5666: PLUS
5667: ST_TO_ADDR
// end else
5668: GO 5692
// r := r + rand ( 10 , 25 ) ;
5670: LD_ADDR_VAR 0 5
5674: PUSH
5675: LD_VAR 0 5
5679: PUSH
5680: LD_INT 10
5682: PPUSH
5683: LD_INT 25
5685: PPUSH
5686: CALL_OW 12
5690: PLUS
5691: ST_TO_ADDR
// end ;
5692: GO 5414
5694: POP
5695: POP
5696: GO 5375
// end ; end_of_file
5698: LD_VAR 0 3
5702: RET
// on UnitDestroyed ( un ) do var i ;
5703: LD_INT 0
5705: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5706: LD_VAR 0 1
5710: PPUSH
5711: CALL_OW 255
5715: PUSH
5716: LD_INT 3
5718: EQUAL
5719: PUSH
5720: LD_VAR 0 1
5724: PPUSH
5725: CALL_OW 247
5729: PUSH
5730: LD_INT 3
5732: EQUAL
5733: AND
5734: IFFALSE 6426
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5736: LD_VAR 0 1
5740: PPUSH
5741: CALL_OW 266
5745: PUSH
5746: LD_INT 31
5748: EQUAL
5749: PUSH
5750: LD_VAR 0 1
5754: PPUSH
5755: CALL_OW 266
5759: PUSH
5760: LD_INT 32
5762: EQUAL
5763: OR
5764: PUSH
5765: LD_VAR 0 1
5769: PPUSH
5770: CALL_OW 266
5774: PUSH
5775: LD_INT 36
5777: EQUAL
5778: OR
5779: PUSH
5780: LD_VAR 0 1
5784: PPUSH
5785: CALL_OW 266
5789: PUSH
5790: LD_INT 0
5792: EQUAL
5793: OR
5794: PUSH
5795: LD_VAR 0 1
5799: PPUSH
5800: CALL_OW 266
5804: PUSH
5805: LD_INT 24
5807: EQUAL
5808: OR
5809: PUSH
5810: LD_VAR 0 1
5814: PPUSH
5815: CALL_OW 266
5819: PUSH
5820: LD_INT 17
5822: EQUAL
5823: OR
5824: PUSH
5825: LD_VAR 0 1
5829: PPUSH
5830: CALL_OW 266
5834: PUSH
5835: LD_INT 25
5837: EQUAL
5838: OR
5839: PUSH
5840: LD_VAR 0 1
5844: PPUSH
5845: CALL_OW 266
5849: PUSH
5850: LD_INT 19
5852: EQUAL
5853: OR
5854: PUSH
5855: LD_VAR 0 1
5859: PPUSH
5860: CALL_OW 266
5864: PUSH
5865: LD_INT 20
5867: EQUAL
5868: OR
5869: PUSH
5870: LD_VAR 0 1
5874: PPUSH
5875: CALL_OW 266
5879: PUSH
5880: LD_INT 18
5882: EQUAL
5883: OR
5884: PUSH
5885: LD_VAR 0 1
5889: PPUSH
5890: CALL_OW 266
5894: PUSH
5895: LD_INT 21
5897: EQUAL
5898: OR
5899: PUSH
5900: LD_VAR 0 1
5904: PPUSH
5905: CALL_OW 266
5909: PUSH
5910: LD_INT 23
5912: EQUAL
5913: OR
5914: PUSH
5915: LD_VAR 0 1
5919: PPUSH
5920: CALL_OW 266
5924: PUSH
5925: LD_INT 16
5927: EQUAL
5928: OR
5929: PUSH
5930: LD_VAR 0 1
5934: PPUSH
5935: CALL_OW 266
5939: PUSH
5940: LD_INT 6
5942: EQUAL
5943: OR
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 266
5954: PUSH
5955: LD_INT 29
5957: EQUAL
5958: OR
5959: PUSH
5960: LD_VAR 0 1
5964: PPUSH
5965: CALL_OW 266
5969: PUSH
5970: LD_INT 26
5972: EQUAL
5973: OR
5974: PUSH
5975: LD_VAR 0 1
5979: PPUSH
5980: CALL_OW 266
5984: PUSH
5985: LD_INT 30
5987: EQUAL
5988: OR
5989: PUSH
5990: LD_VAR 0 1
5994: PPUSH
5995: CALL_OW 266
5999: PUSH
6000: LD_INT 28
6002: EQUAL
6003: OR
6004: PUSH
6005: LD_VAR 0 1
6009: PPUSH
6010: CALL_OW 266
6014: PUSH
6015: LD_INT 27
6017: EQUAL
6018: OR
6019: PUSH
6020: LD_VAR 0 1
6024: PPUSH
6025: CALL_OW 266
6029: PUSH
6030: LD_INT 33
6032: EQUAL
6033: OR
6034: PUSH
6035: LD_VAR 0 1
6039: PPUSH
6040: CALL_OW 266
6044: PUSH
6045: LD_INT 2
6047: EQUAL
6048: OR
6049: PUSH
6050: LD_VAR 0 1
6054: PPUSH
6055: CALL_OW 266
6059: PUSH
6060: LD_INT 4
6062: EQUAL
6063: OR
6064: IFFALSE 6150
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
6066: LD_ADDR_EXP 1
6070: PUSH
6071: LD_EXP 1
6075: PUSH
6076: LD_VAR 0 1
6080: PPUSH
6081: CALL_OW 266
6085: ADD
6086: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6087: LD_ADDR_EXP 1
6091: PUSH
6092: LD_EXP 1
6096: PUSH
6097: LD_VAR 0 1
6101: PPUSH
6102: CALL_OW 250
6106: ADD
6107: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6108: LD_ADDR_EXP 1
6112: PUSH
6113: LD_EXP 1
6117: PUSH
6118: LD_VAR 0 1
6122: PPUSH
6123: CALL_OW 251
6127: ADD
6128: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6129: LD_ADDR_EXP 1
6133: PUSH
6134: LD_EXP 1
6138: PUSH
6139: LD_VAR 0 1
6143: PPUSH
6144: CALL_OW 254
6148: ADD
6149: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
6150: LD_VAR 0 1
6154: PPUSH
6155: CALL_OW 266
6159: PUSH
6160: LD_INT 1
6162: EQUAL
6163: IFFALSE 6242
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
6165: LD_ADDR_EXP 1
6169: PUSH
6170: LD_EXP 1
6174: PUSH
6175: LD_INT 0
6177: ADD
6178: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6179: LD_ADDR_EXP 1
6183: PUSH
6184: LD_EXP 1
6188: PUSH
6189: LD_VAR 0 1
6193: PPUSH
6194: CALL_OW 250
6198: ADD
6199: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6200: LD_ADDR_EXP 1
6204: PUSH
6205: LD_EXP 1
6209: PUSH
6210: LD_VAR 0 1
6214: PPUSH
6215: CALL_OW 251
6219: ADD
6220: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6221: LD_ADDR_EXP 1
6225: PUSH
6226: LD_EXP 1
6230: PUSH
6231: LD_VAR 0 1
6235: PPUSH
6236: CALL_OW 254
6240: ADD
6241: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
6242: LD_VAR 0 1
6246: PPUSH
6247: CALL_OW 266
6251: PUSH
6252: LD_INT 3
6254: EQUAL
6255: IFFALSE 6334
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
6257: LD_ADDR_EXP 1
6261: PUSH
6262: LD_EXP 1
6266: PUSH
6267: LD_INT 2
6269: ADD
6270: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6271: LD_ADDR_EXP 1
6275: PUSH
6276: LD_EXP 1
6280: PUSH
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 250
6290: ADD
6291: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6292: LD_ADDR_EXP 1
6296: PUSH
6297: LD_EXP 1
6301: PUSH
6302: LD_VAR 0 1
6306: PPUSH
6307: CALL_OW 251
6311: ADD
6312: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6313: LD_ADDR_EXP 1
6317: PUSH
6318: LD_EXP 1
6322: PUSH
6323: LD_VAR 0 1
6327: PPUSH
6328: CALL_OW 254
6332: ADD
6333: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
6334: LD_VAR 0 1
6338: PPUSH
6339: CALL_OW 266
6343: PUSH
6344: LD_INT 5
6346: EQUAL
6347: IFFALSE 6426
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
6349: LD_ADDR_EXP 1
6353: PUSH
6354: LD_EXP 1
6358: PUSH
6359: LD_INT 4
6361: ADD
6362: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6363: LD_ADDR_EXP 1
6367: PUSH
6368: LD_EXP 1
6372: PUSH
6373: LD_VAR 0 1
6377: PPUSH
6378: CALL_OW 250
6382: ADD
6383: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6384: LD_ADDR_EXP 1
6388: PUSH
6389: LD_EXP 1
6393: PUSH
6394: LD_VAR 0 1
6398: PPUSH
6399: CALL_OW 251
6403: ADD
6404: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6405: LD_ADDR_EXP 1
6409: PUSH
6410: LD_EXP 1
6414: PUSH
6415: LD_VAR 0 1
6419: PPUSH
6420: CALL_OW 254
6424: ADD
6425: ST_TO_ADDR
// end ; end ; if GetSide ( un ) = 3 and GetType ( un ) = unit_vehicle then
6426: LD_VAR 0 1
6430: PPUSH
6431: CALL_OW 255
6435: PUSH
6436: LD_INT 3
6438: EQUAL
6439: PUSH
6440: LD_VAR 0 1
6444: PPUSH
6445: CALL_OW 247
6449: PUSH
6450: LD_INT 2
6452: EQUAL
6453: AND
6454: IFFALSE 6558
// begin for i in CPU1DamageTanks do
6456: LD_ADDR_VAR 0 2
6460: PUSH
6461: LD_EXP 6
6465: PUSH
6466: FOR_IN
6467: IFFALSE 6556
// begin if i = un then
6469: LD_VAR 0 2
6473: PUSH
6474: LD_VAR 0 1
6478: EQUAL
6479: IFFALSE 6554
// begin AddComConstruct ( rufab , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
6481: LD_INT 30
6483: PPUSH
6484: LD_VAR 0 1
6488: PPUSH
6489: CALL_OW 265
6493: PPUSH
6494: LD_VAR 0 1
6498: PPUSH
6499: CALL_OW 262
6503: PPUSH
6504: LD_VAR 0 1
6508: PPUSH
6509: CALL_OW 263
6513: PPUSH
6514: LD_VAR 0 1
6518: PPUSH
6519: CALL_OW 264
6523: PPUSH
6524: CALL_OW 185
// CPU1DamageTanks = Delete ( CPU1DamageTanks , i [ i ] ) ;
6528: LD_ADDR_EXP 6
6532: PUSH
6533: LD_EXP 6
6537: PPUSH
6538: LD_VAR 0 2
6542: PUSH
6543: LD_VAR 0 2
6547: ARRAY
6548: PPUSH
6549: CALL_OW 3
6553: ST_TO_ADDR
// end ; end ;
6554: GO 6466
6556: POP
6557: POP
// end ; end ;
6558: PPOPN 2
6560: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 255
6570: PUSH
6571: LD_INT 3
6573: EQUAL
6574: IFFALSE 6648
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6576: LD_ADDR_EXP 1
6580: PUSH
6581: LD_EXP 1
6585: PPUSH
6586: LD_INT 1
6588: PPUSH
6589: CALL_OW 3
6593: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6594: LD_ADDR_EXP 1
6598: PUSH
6599: LD_EXP 1
6603: PPUSH
6604: LD_INT 1
6606: PPUSH
6607: CALL_OW 3
6611: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6612: LD_ADDR_EXP 1
6616: PUSH
6617: LD_EXP 1
6621: PPUSH
6622: LD_INT 1
6624: PPUSH
6625: CALL_OW 3
6629: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6630: LD_ADDR_EXP 1
6634: PUSH
6635: LD_EXP 1
6639: PPUSH
6640: LD_INT 1
6642: PPUSH
6643: CALL_OW 3
6647: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6648: LD_VAR 0 1
6652: PPUSH
6653: CALL_OW 255
6657: PUSH
6658: LD_INT 3
6660: EQUAL
6661: PUSH
6662: LD_VAR 0 1
6666: PPUSH
6667: CALL_OW 266
6671: PUSH
6672: LD_INT 0
6674: EQUAL
6675: PUSH
6676: LD_VAR 0 1
6680: PPUSH
6681: CALL_OW 266
6685: PUSH
6686: LD_INT 2
6688: EQUAL
6689: OR
6690: PUSH
6691: LD_VAR 0 1
6695: PPUSH
6696: CALL_OW 266
6700: PUSH
6701: LD_INT 4
6703: EQUAL
6704: OR
6705: PUSH
6706: EMPTY
6707: LIST
6708: AND
6709: IFFALSE 6720
// ComUpgrade ( building ) ;
6711: LD_VAR 0 1
6715: PPUSH
6716: CALL_OW 146
// end ;
6720: PPOPN 1
6722: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 255
6732: PUSH
6733: LD_INT 3
6735: EQUAL
6736: IFFALSE 6754
// CPU1Tanks = CPU1Tanks ^ vehicle ;
6738: LD_ADDR_EXP 5
6742: PUSH
6743: LD_EXP 5
6747: PUSH
6748: LD_VAR 0 1
6752: ADD
6753: ST_TO_ADDR
// end ;
6754: PPOPN 2
6756: END
// on Command ( command_id ) do begin end ;
6757: PPOPN 1
6759: END
