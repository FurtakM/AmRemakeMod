// export destroyedBuildings ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// end ; end_of_file
  22: END
// every 0 0$1 do
  23: GO 25
  25: DISABLE
// begin enable ;
  26: ENABLE
// RepairVehicle ( 1 , reparea , 26 , 13 ) ;
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 1
  32: PPUSH
  33: LD_INT 26
  35: PPUSH
  36: LD_INT 13
  38: PPUSH
  39: CALL 387 0 4
// RebuildBuildings ( 3 , destroyedBuildings ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_EXP 1
  50: PPUSH
  51: CALL 3088 0 2
// display_strings = [ destroyedBuildings , FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ] ;
  55: LD_ADDR_OWVAR 47
  59: PUSH
  60: LD_EXP 1
  64: PUSH
  65: LD_INT 22
  67: PUSH
  68: LD_INT 3
  70: PUSH
  71: EMPTY
  72: LIST
  73: LIST
  74: PUSH
  75: LD_INT 21
  77: PUSH
  78: LD_INT 3
  80: PUSH
  81: EMPTY
  82: LIST
  83: LIST
  84: PUSH
  85: LD_INT 3
  87: PUSH
  88: LD_INT 24
  90: PUSH
  91: LD_INT 1000
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PPUSH
 107: CALL_OW 69
 111: PUSH
 112: EMPTY
 113: LIST
 114: LIST
 115: ST_TO_ADDR
// end ;
 116: END
// every 5 5$1 do
 117: GO 119
 119: DISABLE
// begin end ; end_of_file
 120: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 121: LD_INT 0
 123: PPUSH
 124: PPUSH
 125: PPUSH
// rnd = rand ( 1 , characters ) ;
 126: LD_ADDR_VAR 0 6
 130: PUSH
 131: LD_INT 1
 133: PPUSH
 134: LD_VAR 0 1
 138: PPUSH
 139: CALL_OW 12
 143: ST_TO_ADDR
// for i = 1 to characters do
 144: LD_ADDR_VAR 0 5
 148: PUSH
 149: DOUBLE
 150: LD_INT 1
 152: DEC
 153: ST_TO_ADDR
 154: LD_VAR 0 1
 158: PUSH
 159: FOR_TO
 160: IFFALSE 270
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 162: LD_VAR 0 5
 166: PUSH
 167: LD_VAR 0 6
 171: EQUAL
 172: PUSH
 173: LD_VAR 0 1
 177: PUSH
 178: LD_VAR 0 5
 182: ARRAY
 183: PPUSH
 184: CALL_OW 258
 188: PUSH
 189: LD_INT 1
 191: EQUAL
 192: AND
 193: IFFALSE 215
// Say ( characters [ i ] , dialogMID ) ;
 195: LD_VAR 0 1
 199: PUSH
 200: LD_VAR 0 5
 204: ARRAY
 205: PPUSH
 206: LD_VAR 0 2
 210: PPUSH
 211: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 215: LD_VAR 0 5
 219: PUSH
 220: LD_VAR 0 6
 224: EQUAL
 225: PUSH
 226: LD_VAR 0 1
 230: PUSH
 231: LD_VAR 0 5
 235: ARRAY
 236: PPUSH
 237: CALL_OW 258
 241: PUSH
 242: LD_INT 2
 244: EQUAL
 245: AND
 246: IFFALSE 268
// Say ( characters [ i ] , dialogFID ) ;
 248: LD_VAR 0 1
 252: PUSH
 253: LD_VAR 0 5
 257: ARRAY
 258: PPUSH
 259: LD_VAR 0 3
 263: PPUSH
 264: CALL_OW 88
// end ;
 268: GO 159
 270: POP
 271: POP
// end ;
 272: LD_VAR 0 4
 276: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
// for i = 1 to count do
 283: LD_ADDR_VAR 0 8
 287: PUSH
 288: DOUBLE
 289: LD_INT 1
 291: DEC
 292: ST_TO_ADDR
 293: LD_VAR 0 6
 297: PUSH
 298: FOR_TO
 299: IFFALSE 380
// begin uc_side = side ;
 301: LD_ADDR_OWVAR 20
 305: PUSH
 306: LD_VAR 0 1
 310: ST_TO_ADDR
// uc_nation = nation ;
 311: LD_ADDR_OWVAR 21
 315: PUSH
 316: LD_VAR 0 2
 320: ST_TO_ADDR
// hc_gallery =  ;
 321: LD_ADDR_OWVAR 33
 325: PUSH
 326: LD_STRING 
 328: ST_TO_ADDR
// hc_name =  ;
 329: LD_ADDR_OWVAR 26
 333: PUSH
 334: LD_STRING 
 336: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 337: LD_INT 0
 339: PPUSH
 340: LD_VAR 0 5
 344: PPUSH
 345: LD_VAR 0 4
 349: PPUSH
 350: CALL_OW 380
// un = CreateHuman ;
 354: LD_ADDR_VAR 0 10
 358: PUSH
 359: CALL_OW 44
 363: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 364: LD_VAR 0 10
 368: PPUSH
 369: LD_VAR 0 3
 373: PPUSH
 374: CALL_OW 52
// end ;
 378: GO 298
 380: POP
 381: POP
// end ;
 382: LD_VAR 0 7
 386: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
 387: LD_INT 0
 389: PPUSH
 390: PPUSH
 391: PPUSH
 392: PPUSH
 393: PPUSH
 394: PPUSH
 395: PPUSH
 396: PPUSH
 397: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
 398: LD_ADDR_VAR 0 8
 402: PUSH
 403: LD_INT 22
 405: PUSH
 406: LD_VAR 0 1
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: PUSH
 415: LD_INT 21
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 24
 427: PUSH
 428: LD_INT 660
 430: PUSH
 431: EMPTY
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 3
 437: PUSH
 438: LD_INT 58
 440: PUSH
 441: EMPTY
 442: LIST
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PPUSH
 454: CALL_OW 69
 458: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
 459: LD_ADDR_VAR 0 9
 463: PUSH
 464: LD_INT 22
 466: PUSH
 467: LD_VAR 0 1
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: PUSH
 476: LD_INT 21
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 24
 491: PUSH
 492: LD_INT 660
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: PPUSH
 508: CALL_OW 69
 512: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
 513: LD_ADDR_VAR 0 10
 517: PUSH
 518: LD_VAR 0 2
 522: PPUSH
 523: LD_INT 22
 525: PUSH
 526: LD_VAR 0 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 21
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: PUSH
 545: LD_INT 3
 547: PUSH
 548: LD_INT 24
 550: PUSH
 551: LD_INT 1000
 553: PUSH
 554: EMPTY
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: LIST
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: PPUSH
 567: CALL_OW 70
 571: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
 572: LD_ADDR_VAR 0 11
 576: PUSH
 577: LD_VAR 0 2
 581: PPUSH
 582: LD_INT 22
 584: PUSH
 585: LD_VAR 0 1
 589: PUSH
 590: EMPTY
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 21
 596: PUSH
 597: LD_INT 2
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: PUSH
 604: LD_INT 24
 606: PUSH
 607: LD_INT 1000
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PUSH
 614: LD_INT 58
 616: PUSH
 617: EMPTY
 618: LIST
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: LIST
 624: LIST
 625: PPUSH
 626: CALL_OW 70
 630: ST_TO_ADDR
// mechanicInside_list = [ ] ;
 631: LD_ADDR_VAR 0 12
 635: PUSH
 636: EMPTY
 637: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
 638: LD_ADDR_VAR 0 13
 642: PUSH
 643: LD_VAR 0 2
 647: PPUSH
 648: LD_INT 22
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: PUSH
 660: LD_INT 25
 662: PUSH
 663: LD_INT 3
 665: PUSH
 666: EMPTY
 667: LIST
 668: LIST
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PPUSH
 674: CALL_OW 70
 678: ST_TO_ADDR
// if damageVehicle_list > 0 then
 679: LD_VAR 0 9
 683: PUSH
 684: LD_INT 0
 686: GREATER
 687: IFFALSE 746
// begin for i in damageVehicle_list do
 689: LD_ADDR_VAR 0 6
 693: PUSH
 694: LD_VAR 0 9
 698: PUSH
 699: FOR_IN
 700: IFFALSE 744
// begin ComMoveXY ( i , repX , repY ) ;
 702: LD_VAR 0 6
 706: PPUSH
 707: LD_VAR 0 3
 711: PPUSH
 712: LD_VAR 0 4
 716: PPUSH
 717: CALL_OW 111
// mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
 721: LD_ADDR_VAR 0 12
 725: PUSH
 726: LD_VAR 0 12
 730: PUSH
 731: LD_VAR 0 6
 735: PPUSH
 736: CALL_OW 313
 740: ADD
 741: ST_TO_ADDR
// end ;
 742: GO 699
 744: POP
 745: POP
// end ; if vehicleNeedRepair_list > 0 then
 746: LD_VAR 0 10
 750: PUSH
 751: LD_INT 0
 753: GREATER
 754: IFFALSE 820
// begin for i in mechanicInside_list do
 756: LD_ADDR_VAR 0 6
 760: PUSH
 761: LD_VAR 0 12
 765: PUSH
 766: FOR_IN
 767: IFFALSE 818
// begin for j in vehicleNeedRepair_list do
 769: LD_ADDR_VAR 0 7
 773: PUSH
 774: LD_VAR 0 10
 778: PUSH
 779: FOR_IN
 780: IFFALSE 814
// begin AddComExitVehicle ( i ) ;
 782: LD_VAR 0 6
 786: PPUSH
 787: CALL_OW 181
// wait ( 0 0$1 ) ;
 791: LD_INT 35
 793: PPUSH
 794: CALL_OW 67
// AddComRepairVehicle ( i , j ) ;
 798: LD_VAR 0 6
 802: PPUSH
 803: LD_VAR 0 7
 807: PPUSH
 808: CALL_OW 189
// end ;
 812: GO 779
 814: POP
 815: POP
// end ;
 816: GO 766
 818: POP
 819: POP
// end ; if vehicleDontNeedRepair_list > 0 then
 820: LD_VAR 0 11
 824: PUSH
 825: LD_INT 0
 827: GREATER
 828: IFFALSE 852
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
 830: LD_VAR 0 13
 834: PUSH
 835: LD_INT 1
 837: ARRAY
 838: PPUSH
 839: LD_VAR 0 11
 843: PUSH
 844: LD_INT 1
 846: ARRAY
 847: PPUSH
 848: CALL_OW 120
// end ; if vehicleOK_list > 0 then
 852: LD_VAR 0 8
 856: PUSH
 857: LD_INT 0
 859: GREATER
 860: IFFALSE 894
// begin for i in vehicleOK_list do
 862: LD_ADDR_VAR 0 6
 866: PUSH
 867: LD_VAR 0 8
 871: PUSH
 872: FOR_IN
 873: IFFALSE 892
// ComAgressiveMove ( i , 50 , 50 ) ;
 875: LD_VAR 0 6
 879: PPUSH
 880: LD_INT 50
 882: PPUSH
 883: LD_INT 50
 885: PPUSH
 886: CALL_OW 114
 890: GO 872
 892: POP
 893: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
 894: LD_ADDR_VAR 0 6
 898: PUSH
 899: LD_VAR 0 2
 903: PPUSH
 904: LD_INT 22
 906: PUSH
 907: LD_VAR 0 1
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 25
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: PUSH
 926: EMPTY
 927: LIST
 928: LIST
 929: PPUSH
 930: CALL_OW 70
 934: NOT
 935: PUSH
 936: FOR_IN
 937: IFFALSE 960
// ComMoveXY ( i , repX , repY ) ;
 939: LD_VAR 0 6
 943: PPUSH
 944: LD_VAR 0 3
 948: PPUSH
 949: LD_VAR 0 4
 953: PPUSH
 954: CALL_OW 111
 958: GO 936
 960: POP
 961: POP
// end ;
 962: LD_VAR 0 5
 966: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 967: LD_INT 0
 969: PPUSH
 970: PPUSH
 971: PPUSH
 972: PPUSH
 973: PPUSH
 974: PPUSH
 975: PPUSH
 976: PPUSH
 977: PPUSH
 978: PPUSH
 979: PPUSH
// amChassisTab = [ ] ;
 980: LD_ADDR_VAR 0 19
 984: PUSH
 985: EMPTY
 986: ST_TO_ADDR
// arChassisTab = [ ] ;
 987: LD_ADDR_VAR 0 18
 991: PUSH
 992: EMPTY
 993: ST_TO_ADDR
// ruChassisTab = [ ] ;
 994: LD_ADDR_VAR 0 17
 998: PUSH
 999: EMPTY
1000: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
1001: LD_INT 35
1003: PPUSH
1004: CALL_OW 67
// if nation = 1 then
1008: LD_VAR 0 5
1012: PUSH
1013: LD_INT 1
1015: EQUAL
1016: IFFALSE 1507
// begin uc_side = side ;
1018: LD_ADDR_OWVAR 20
1022: PUSH
1023: LD_VAR 0 2
1027: ST_TO_ADDR
// uc_nation = nation ;
1028: LD_ADDR_OWVAR 21
1032: PUSH
1033: LD_VAR 0 5
1037: ST_TO_ADDR
// vc_engine = vehengine ;
1038: LD_ADDR_OWVAR 39
1042: PUSH
1043: LD_VAR 0 6
1047: ST_TO_ADDR
// vc_control = vehcontrol ;
1048: LD_ADDR_OWVAR 38
1052: PUSH
1053: LD_VAR 0 7
1057: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
1058: LD_ADDR_OWVAR 40
1062: PUSH
1063: LD_VAR 0 10
1067: PUSH
1068: LD_INT 1
1070: PPUSH
1071: LD_VAR 0 10
1075: PPUSH
1076: CALL_OW 12
1080: ARRAY
1081: ST_TO_ADDR
// for j = 1 to AMWeapon do
1082: LD_ADDR_VAR 0 14
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_VAR 0 10
1096: PUSH
1097: FOR_TO
1098: IFFALSE 1399
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
1100: LD_VAR 0 10
1104: PUSH
1105: LD_VAR 0 14
1109: ARRAY
1110: PUSH
1111: LD_INT 2
1113: EQUAL
1114: PUSH
1115: LD_VAR 0 10
1119: PUSH
1120: LD_VAR 0 14
1124: ARRAY
1125: PUSH
1126: LD_INT 3
1128: EQUAL
1129: OR
1130: IFFALSE 1183
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
1132: LD_ADDR_VAR 0 19
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 2
1142: PUSH
1143: LD_INT 3
1145: PUSH
1146: LD_INT 4
1148: PUSH
1149: LD_INT 5
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: LIST
1158: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1159: LD_ADDR_OWVAR 37
1163: PUSH
1164: LD_VAR 0 19
1168: PUSH
1169: LD_INT 1
1171: PPUSH
1172: LD_VAR 0 19
1176: PPUSH
1177: CALL_OW 12
1181: ARRAY
1182: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
1183: LD_VAR 0 10
1187: PUSH
1188: LD_VAR 0 14
1192: ARRAY
1193: PUSH
1194: LD_INT 4
1196: EQUAL
1197: PUSH
1198: LD_VAR 0 10
1202: PUSH
1203: LD_VAR 0 14
1207: ARRAY
1208: PUSH
1209: LD_INT 5
1211: EQUAL
1212: OR
1213: PUSH
1214: LD_VAR 0 10
1218: PUSH
1219: LD_VAR 0 14
1223: ARRAY
1224: PUSH
1225: LD_INT 9
1227: EQUAL
1228: OR
1229: PUSH
1230: LD_VAR 0 10
1234: PUSH
1235: LD_VAR 0 14
1239: ARRAY
1240: PUSH
1241: LD_INT 11
1243: EQUAL
1244: OR
1245: PUSH
1246: LD_VAR 0 10
1250: PUSH
1251: LD_VAR 0 14
1255: ARRAY
1256: PUSH
1257: LD_INT 7
1259: EQUAL
1260: OR
1261: IFFALSE 1310
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1263: LD_ADDR_VAR 0 19
1267: PUSH
1268: LD_INT 2
1270: PUSH
1271: LD_INT 3
1273: PUSH
1274: LD_INT 4
1276: PUSH
1277: LD_INT 5
1279: PUSH
1280: EMPTY
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1286: LD_ADDR_OWVAR 37
1290: PUSH
1291: LD_VAR 0 19
1295: PUSH
1296: LD_INT 1
1298: PPUSH
1299: LD_VAR 0 19
1303: PPUSH
1304: CALL_OW 12
1308: ARRAY
1309: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
1310: LD_VAR 0 10
1314: PUSH
1315: LD_VAR 0 14
1319: ARRAY
1320: PUSH
1321: LD_INT 8
1323: EQUAL
1324: PUSH
1325: LD_VAR 0 10
1329: PUSH
1330: LD_VAR 0 14
1334: ARRAY
1335: PUSH
1336: LD_INT 6
1338: EQUAL
1339: OR
1340: PUSH
1341: LD_VAR 0 10
1345: PUSH
1346: LD_VAR 0 14
1350: ARRAY
1351: PUSH
1352: LD_INT 10
1354: EQUAL
1355: OR
1356: IFFALSE 1397
// begin amChassisTab = [ 4 , 5 ] ;
1358: LD_ADDR_VAR 0 19
1362: PUSH
1363: LD_INT 4
1365: PUSH
1366: LD_INT 5
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1373: LD_ADDR_OWVAR 37
1377: PUSH
1378: LD_VAR 0 19
1382: PUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_VAR 0 19
1390: PPUSH
1391: CALL_OW 12
1395: ARRAY
1396: ST_TO_ADDR
// end ; end ;
1397: GO 1097
1399: POP
1400: POP
// veh = CreateVehicle ;
1401: LD_ADDR_VAR 0 16
1405: PUSH
1406: CALL_OW 45
1410: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1411: LD_VAR 0 16
1415: PPUSH
1416: LD_VAR 0 1
1420: PPUSH
1421: LD_INT 0
1423: PPUSH
1424: CALL_OW 49
// if vehControl = 1 then
1428: LD_VAR 0 7
1432: PUSH
1433: LD_INT 1
1435: EQUAL
1436: IFFALSE 1493
// begin hc_gallery =  ;
1438: LD_ADDR_OWVAR 33
1442: PUSH
1443: LD_STRING 
1445: ST_TO_ADDR
// hc_name =  ;
1446: LD_ADDR_OWVAR 26
1450: PUSH
1451: LD_STRING 
1453: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1454: LD_INT 0
1456: PPUSH
1457: LD_INT 3
1459: PPUSH
1460: LD_VAR 0 4
1464: PPUSH
1465: CALL_OW 380
// un = CreateHuman ;
1469: LD_ADDR_VAR 0 15
1473: PUSH
1474: CALL_OW 44
1478: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1479: LD_VAR 0 15
1483: PPUSH
1484: LD_VAR 0 16
1488: PPUSH
1489: CALL_OW 52
// end ; i = i + 1 ;
1493: LD_ADDR_VAR 0 13
1497: PUSH
1498: LD_VAR 0 13
1502: PUSH
1503: LD_INT 1
1505: PLUS
1506: ST_TO_ADDR
// end ; if nation = 2 then
1507: LD_VAR 0 5
1511: PUSH
1512: LD_INT 2
1514: EQUAL
1515: IFFALSE 1939
// begin uc_side = side ;
1517: LD_ADDR_OWVAR 20
1521: PUSH
1522: LD_VAR 0 2
1526: ST_TO_ADDR
// uc_nation = nation ;
1527: LD_ADDR_OWVAR 21
1531: PUSH
1532: LD_VAR 0 5
1536: ST_TO_ADDR
// vc_engine = vehengine ;
1537: LD_ADDR_OWVAR 39
1541: PUSH
1542: LD_VAR 0 6
1546: ST_TO_ADDR
// vc_control = vehcontrol ;
1547: LD_ADDR_OWVAR 38
1551: PUSH
1552: LD_VAR 0 7
1556: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1557: LD_ADDR_OWVAR 40
1561: PUSH
1562: LD_VAR 0 9
1566: PUSH
1567: LD_INT 1
1569: PPUSH
1570: LD_VAR 0 9
1574: PPUSH
1575: CALL_OW 12
1579: ARRAY
1580: ST_TO_ADDR
// for j = 1 to ARWeapons do
1581: LD_ADDR_VAR 0 14
1585: PUSH
1586: DOUBLE
1587: LD_INT 1
1589: DEC
1590: ST_TO_ADDR
1591: LD_VAR 0 9
1595: PUSH
1596: FOR_TO
1597: IFFALSE 1831
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1599: LD_VAR 0 9
1603: PUSH
1604: LD_VAR 0 14
1608: ARRAY
1609: PUSH
1610: LD_INT 24
1612: EQUAL
1613: PUSH
1614: LD_VAR 0 9
1618: PUSH
1619: LD_VAR 0 14
1623: ARRAY
1624: PUSH
1625: LD_INT 22
1627: EQUAL
1628: OR
1629: PUSH
1630: LD_VAR 0 9
1634: PUSH
1635: LD_VAR 0 14
1639: ARRAY
1640: PUSH
1641: LD_INT 23
1643: EQUAL
1644: OR
1645: PUSH
1646: LD_VAR 0 9
1650: PUSH
1651: LD_VAR 0 14
1655: ARRAY
1656: PUSH
1657: LD_INT 30
1659: EQUAL
1660: OR
1661: IFFALSE 1710
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1663: LD_ADDR_VAR 0 18
1667: PUSH
1668: LD_INT 11
1670: PUSH
1671: LD_INT 12
1673: PUSH
1674: LD_INT 13
1676: PUSH
1677: LD_INT 14
1679: PUSH
1680: EMPTY
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1686: LD_ADDR_OWVAR 37
1690: PUSH
1691: LD_VAR 0 18
1695: PUSH
1696: LD_INT 1
1698: PPUSH
1699: LD_VAR 0 18
1703: PPUSH
1704: CALL_OW 12
1708: ARRAY
1709: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1710: LD_VAR 0 9
1714: PUSH
1715: LD_VAR 0 14
1719: ARRAY
1720: PUSH
1721: LD_INT 29
1723: EQUAL
1724: PUSH
1725: LD_VAR 0 9
1729: PUSH
1730: LD_VAR 0 14
1734: ARRAY
1735: PUSH
1736: LD_INT 28
1738: EQUAL
1739: OR
1740: PUSH
1741: LD_VAR 0 9
1745: PUSH
1746: LD_VAR 0 14
1750: ARRAY
1751: PUSH
1752: LD_INT 27
1754: EQUAL
1755: OR
1756: PUSH
1757: LD_VAR 0 9
1761: PUSH
1762: LD_VAR 0 14
1766: ARRAY
1767: PUSH
1768: LD_INT 26
1770: EQUAL
1771: OR
1772: PUSH
1773: LD_VAR 0 9
1777: PUSH
1778: LD_VAR 0 14
1782: ARRAY
1783: PUSH
1784: LD_INT 25
1786: EQUAL
1787: OR
1788: IFFALSE 1829
// begin arChassisTab = [ 13 , 14 ] ;
1790: LD_ADDR_VAR 0 18
1794: PUSH
1795: LD_INT 13
1797: PUSH
1798: LD_INT 14
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1805: LD_ADDR_OWVAR 37
1809: PUSH
1810: LD_VAR 0 18
1814: PUSH
1815: LD_INT 1
1817: PPUSH
1818: LD_VAR 0 18
1822: PPUSH
1823: CALL_OW 12
1827: ARRAY
1828: ST_TO_ADDR
// end ; end ;
1829: GO 1596
1831: POP
1832: POP
// veh = CreateVehicle ;
1833: LD_ADDR_VAR 0 16
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1843: LD_VAR 0 16
1847: PPUSH
1848: LD_VAR 0 1
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 49
// if vehcontrol = 1 then
1860: LD_VAR 0 7
1864: PUSH
1865: LD_INT 1
1867: EQUAL
1868: IFFALSE 1925
// begin hc_gallery =  ;
1870: LD_ADDR_OWVAR 33
1874: PUSH
1875: LD_STRING 
1877: ST_TO_ADDR
// hc_name =  ;
1878: LD_ADDR_OWVAR 26
1882: PUSH
1883: LD_STRING 
1885: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1886: LD_INT 0
1888: PPUSH
1889: LD_INT 3
1891: PPUSH
1892: LD_VAR 0 4
1896: PPUSH
1897: CALL_OW 380
// un = CreateHuman ;
1901: LD_ADDR_VAR 0 15
1905: PUSH
1906: CALL_OW 44
1910: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1911: LD_VAR 0 15
1915: PPUSH
1916: LD_VAR 0 16
1920: PPUSH
1921: CALL_OW 52
// end ; i = i + 1 ;
1925: LD_ADDR_VAR 0 13
1929: PUSH
1930: LD_VAR 0 13
1934: PUSH
1935: LD_INT 1
1937: PLUS
1938: ST_TO_ADDR
// end ; if nation = 3 then
1939: LD_VAR 0 5
1943: PUSH
1944: LD_INT 3
1946: EQUAL
1947: IFFALSE 2339
// begin uc_side = side ;
1949: LD_ADDR_OWVAR 20
1953: PUSH
1954: LD_VAR 0 2
1958: ST_TO_ADDR
// uc_nation = nation ;
1959: LD_ADDR_OWVAR 21
1963: PUSH
1964: LD_VAR 0 5
1968: ST_TO_ADDR
// vc_engine = vehengine ;
1969: LD_ADDR_OWVAR 39
1973: PUSH
1974: LD_VAR 0 6
1978: ST_TO_ADDR
// vc_control = vehcontrol ;
1979: LD_ADDR_OWVAR 38
1983: PUSH
1984: LD_VAR 0 7
1988: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1989: LD_ADDR_OWVAR 40
1993: PUSH
1994: LD_VAR 0 8
1998: PUSH
1999: LD_INT 1
2001: PPUSH
2002: LD_VAR 0 8
2006: PPUSH
2007: CALL_OW 12
2011: ARRAY
2012: ST_TO_ADDR
// for j = 1 to RuWeapons do
2013: LD_ADDR_VAR 0 14
2017: PUSH
2018: DOUBLE
2019: LD_INT 1
2021: DEC
2022: ST_TO_ADDR
2023: LD_VAR 0 8
2027: PUSH
2028: FOR_TO
2029: IFFALSE 2231
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
2031: LD_VAR 0 8
2035: PUSH
2036: LD_VAR 0 14
2040: ARRAY
2041: PUSH
2042: LD_INT 42
2044: EQUAL
2045: PUSH
2046: LD_VAR 0 8
2050: PUSH
2051: LD_VAR 0 14
2055: ARRAY
2056: PUSH
2057: LD_INT 43
2059: EQUAL
2060: OR
2061: PUSH
2062: LD_VAR 0 8
2066: PUSH
2067: LD_VAR 0 14
2071: ARRAY
2072: PUSH
2073: LD_INT 44
2075: EQUAL
2076: OR
2077: PUSH
2078: LD_VAR 0 8
2082: PUSH
2083: LD_VAR 0 14
2087: ARRAY
2088: PUSH
2089: LD_INT 45
2091: EQUAL
2092: OR
2093: PUSH
2094: LD_VAR 0 8
2098: PUSH
2099: LD_VAR 0 14
2103: ARRAY
2104: PUSH
2105: LD_INT 49
2107: EQUAL
2108: OR
2109: IFFALSE 2158
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
2111: LD_ADDR_VAR 0 17
2115: PUSH
2116: LD_INT 21
2118: PUSH
2119: LD_INT 22
2121: PUSH
2122: LD_INT 23
2124: PUSH
2125: LD_INT 24
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2134: LD_ADDR_OWVAR 37
2138: PUSH
2139: LD_VAR 0 17
2143: PUSH
2144: LD_INT 1
2146: PPUSH
2147: LD_VAR 0 17
2151: PPUSH
2152: CALL_OW 12
2156: ARRAY
2157: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
2158: LD_VAR 0 8
2162: PUSH
2163: LD_VAR 0 14
2167: ARRAY
2168: PUSH
2169: LD_INT 46
2171: EQUAL
2172: PUSH
2173: LD_VAR 0 8
2177: PUSH
2178: LD_VAR 0 14
2182: ARRAY
2183: PUSH
2184: LD_INT 47
2186: EQUAL
2187: OR
2188: IFFALSE 2229
// begin ruChassisTab = [ 23 , 24 ] ;
2190: LD_ADDR_VAR 0 17
2194: PUSH
2195: LD_INT 23
2197: PUSH
2198: LD_INT 24
2200: PUSH
2201: EMPTY
2202: LIST
2203: LIST
2204: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2205: LD_ADDR_OWVAR 37
2209: PUSH
2210: LD_VAR 0 17
2214: PUSH
2215: LD_INT 1
2217: PPUSH
2218: LD_VAR 0 17
2222: PPUSH
2223: CALL_OW 12
2227: ARRAY
2228: ST_TO_ADDR
// end ; end ;
2229: GO 2028
2231: POP
2232: POP
// veh = CreateVehicle ;
2233: LD_ADDR_VAR 0 16
2237: PUSH
2238: CALL_OW 45
2242: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2243: LD_VAR 0 16
2247: PPUSH
2248: LD_VAR 0 1
2252: PPUSH
2253: LD_INT 0
2255: PPUSH
2256: CALL_OW 49
// if vehcontrol = 1 then
2260: LD_VAR 0 7
2264: PUSH
2265: LD_INT 1
2267: EQUAL
2268: IFFALSE 2325
// begin hc_gallery =  ;
2270: LD_ADDR_OWVAR 33
2274: PUSH
2275: LD_STRING 
2277: ST_TO_ADDR
// hc_name =  ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING 
2285: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2286: LD_INT 0
2288: PPUSH
2289: LD_INT 3
2291: PPUSH
2292: LD_VAR 0 4
2296: PPUSH
2297: CALL_OW 380
// un = CreateHuman ;
2301: LD_ADDR_VAR 0 15
2305: PUSH
2306: CALL_OW 44
2310: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2311: LD_VAR 0 15
2315: PPUSH
2316: LD_VAR 0 16
2320: PPUSH
2321: CALL_OW 52
// end ; i = i + 1 ;
2325: LD_ADDR_VAR 0 13
2329: PUSH
2330: LD_VAR 0 13
2334: PUSH
2335: LD_INT 1
2337: PLUS
2338: ST_TO_ADDR
// end ; until i = vehCount ;
2339: LD_VAR 0 13
2343: PUSH
2344: LD_VAR 0 3
2348: EQUAL
2349: IFFALSE 1001
// repeat wait ( 0 0$1 ) ;
2351: LD_INT 35
2353: PPUSH
2354: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2358: LD_ADDR_VAR 0 20
2362: PUSH
2363: LD_INT 22
2365: PUSH
2366: LD_VAR 0 2
2370: PUSH
2371: EMPTY
2372: LIST
2373: LIST
2374: PUSH
2375: LD_INT 21
2377: PUSH
2378: LD_INT 2
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PUSH
2385: LD_INT 24
2387: PUSH
2388: LD_INT 650
2390: PUSH
2391: EMPTY
2392: LIST
2393: LIST
2394: PUSH
2395: EMPTY
2396: LIST
2397: LIST
2398: LIST
2399: PPUSH
2400: CALL_OW 69
2404: ST_TO_ADDR
// if vehicleOK_list > 0 then
2405: LD_VAR 0 20
2409: PUSH
2410: LD_INT 0
2412: GREATER
2413: IFFALSE 2604
// begin for i in vehicleOK_list do
2415: LD_ADDR_VAR 0 13
2419: PUSH
2420: LD_VAR 0 20
2424: PUSH
2425: FOR_IN
2426: IFFALSE 2602
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2428: LD_ADDR_VAR 0 21
2432: PUSH
2433: LD_INT 22
2435: PUSH
2436: LD_VAR 0 11
2440: PUSH
2441: EMPTY
2442: LIST
2443: LIST
2444: PPUSH
2445: CALL_OW 69
2449: PPUSH
2450: LD_VAR 0 13
2454: PPUSH
2455: CALL_OW 74
2459: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2460: LD_ADDR_VAR 0 22
2464: PUSH
2465: LD_INT 22
2467: PUSH
2468: LD_VAR 0 11
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PUSH
2477: LD_INT 2
2479: PUSH
2480: LD_INT 59
2482: PUSH
2483: EMPTY
2484: LIST
2485: PUSH
2486: LD_INT 21
2488: PUSH
2489: LD_INT 1
2491: PUSH
2492: EMPTY
2493: LIST
2494: LIST
2495: PUSH
2496: LD_INT 21
2498: PUSH
2499: LD_INT 2
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: LIST
2510: LIST
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: PPUSH
2519: CALL_OW 69
2523: PPUSH
2524: LD_VAR 0 13
2528: PPUSH
2529: CALL_OW 74
2533: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2534: LD_VAR 0 13
2538: PPUSH
2539: LD_VAR 0 21
2543: PPUSH
2544: CALL_OW 296
2548: PUSH
2549: LD_INT 8
2551: PLUS
2552: PUSH
2553: LD_VAR 0 13
2557: PPUSH
2558: LD_VAR 0 22
2562: PPUSH
2563: CALL_OW 296
2567: LESS
2568: IFFALSE 2586
// begin ComAttackUnit ( i , target1 ) ;
2570: LD_VAR 0 13
2574: PPUSH
2575: LD_VAR 0 21
2579: PPUSH
2580: CALL_OW 115
// end else
2584: GO 2600
// begin ComAttackUnit ( i , target2 ) ;
2586: LD_VAR 0 13
2590: PPUSH
2591: LD_VAR 0 22
2595: PPUSH
2596: CALL_OW 115
// end ; end ;
2600: GO 2425
2602: POP
2603: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2604: LD_INT 22
2606: PUSH
2607: LD_VAR 0 2
2611: PUSH
2612: EMPTY
2613: LIST
2614: LIST
2615: PUSH
2616: LD_INT 21
2618: PUSH
2619: LD_INT 2
2621: PUSH
2622: EMPTY
2623: LIST
2624: LIST
2625: PUSH
2626: EMPTY
2627: LIST
2628: LIST
2629: PPUSH
2630: CALL_OW 69
2634: PUSH
2635: LD_INT 0
2637: EQUAL
2638: IFFALSE 2351
// end ;
2640: LD_VAR 0 12
2644: RET
// export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , targetSide , weaponTab , engine , control , chassis ) ; var i , j , temp , target1 , target2 ; begin
2645: LD_INT 0
2647: PPUSH
2648: PPUSH
2649: PPUSH
2650: PPUSH
2651: PPUSH
2652: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2653: LD_INT 22
2655: PUSH
2656: LD_VAR 0 1
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 21
2667: PUSH
2668: LD_INT 2
2670: PUSH
2671: EMPTY
2672: LIST
2673: LIST
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: PPUSH
2679: CALL_OW 69
2683: PUSH
2684: LD_VAR 0 3
2688: LESSEQUAL
2689: IFFALSE 2756
// for i = 1 to vehCount do
2691: LD_ADDR_VAR 0 10
2695: PUSH
2696: DOUBLE
2697: LD_INT 1
2699: DEC
2700: ST_TO_ADDR
2701: LD_VAR 0 3
2705: PUSH
2706: FOR_TO
2707: IFFALSE 2754
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2709: LD_VAR 0 2
2713: PPUSH
2714: LD_VAR 0 8
2718: PPUSH
2719: LD_VAR 0 6
2723: PPUSH
2724: LD_VAR 0 7
2728: PPUSH
2729: LD_VAR 0 5
2733: PUSH
2734: LD_INT 1
2736: PPUSH
2737: LD_VAR 0 5
2741: PPUSH
2742: CALL_OW 12
2746: ARRAY
2747: PPUSH
2748: CALL_OW 185
2752: GO 2706
2754: POP
2755: POP
// repeat wait ( 0 0$1 ) ;
2756: LD_INT 35
2758: PPUSH
2759: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] ] ) >= vehCount ;
2763: LD_INT 22
2765: PUSH
2766: LD_VAR 0 1
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: LD_INT 21
2777: PUSH
2778: LD_INT 2
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 24
2787: PUSH
2788: LD_INT 250
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: PUSH
2805: LD_VAR 0 3
2809: GREATEREQUAL
2810: IFFALSE 2756
// repeat begin wait ( 0 0$1 ) ;
2812: LD_INT 35
2814: PPUSH
2815: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 651 ] ] ) do
2819: LD_ADDR_VAR 0 10
2823: PUSH
2824: LD_INT 22
2826: PUSH
2827: LD_VAR 0 1
2831: PUSH
2832: EMPTY
2833: LIST
2834: LIST
2835: PUSH
2836: LD_INT 21
2838: PUSH
2839: LD_INT 2
2841: PUSH
2842: EMPTY
2843: LIST
2844: LIST
2845: PUSH
2846: LD_INT 24
2848: PUSH
2849: LD_INT 651
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: PUSH
2866: FOR_IN
2867: IFFALSE 3043
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2869: LD_ADDR_VAR 0 13
2873: PUSH
2874: LD_INT 22
2876: PUSH
2877: LD_VAR 0 4
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: PPUSH
2886: CALL_OW 69
2890: PPUSH
2891: LD_VAR 0 10
2895: PPUSH
2896: CALL_OW 74
2900: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2901: LD_ADDR_VAR 0 14
2905: PUSH
2906: LD_INT 22
2908: PUSH
2909: LD_VAR 0 4
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: LD_INT 2
2920: PUSH
2921: LD_INT 59
2923: PUSH
2924: EMPTY
2925: LIST
2926: PUSH
2927: LD_INT 21
2929: PUSH
2930: LD_INT 1
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: LD_INT 21
2939: PUSH
2940: LD_INT 2
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: LIST
2951: LIST
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: PPUSH
2960: CALL_OW 69
2964: PPUSH
2965: LD_VAR 0 10
2969: PPUSH
2970: CALL_OW 74
2974: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2975: LD_VAR 0 10
2979: PPUSH
2980: LD_VAR 0 13
2984: PPUSH
2985: CALL_OW 296
2989: PUSH
2990: LD_INT 8
2992: PLUS
2993: PUSH
2994: LD_VAR 0 10
2998: PPUSH
2999: LD_VAR 0 14
3003: PPUSH
3004: CALL_OW 296
3008: LESS
3009: IFFALSE 3027
// begin ComAttackUnit ( i , target1 ) ;
3011: LD_VAR 0 10
3015: PPUSH
3016: LD_VAR 0 13
3020: PPUSH
3021: CALL_OW 115
// end else
3025: GO 3041
// begin ComAttackUnit ( i , target2 ) ;
3027: LD_VAR 0 10
3031: PPUSH
3032: LD_VAR 0 14
3036: PPUSH
3037: CALL_OW 115
// end ; end ;
3041: GO 2866
3043: POP
3044: POP
// end until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount ;
3045: LD_INT 22
3047: PUSH
3048: LD_VAR 0 1
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 21
3059: PUSH
3060: LD_INT 2
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: PPUSH
3071: CALL_OW 69
3075: PUSH
3076: LD_VAR 0 3
3080: LESSEQUAL
3081: IFFALSE 2812
// end ;
3083: LD_VAR 0 9
3087: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3088: LD_INT 0
3090: PPUSH
3091: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3092: LD_INT 22
3094: PUSH
3095: LD_VAR 0 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 25
3106: PUSH
3107: LD_INT 2
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PPUSH
3118: CALL_OW 69
3122: PUSH
3123: LD_INT 0
3125: GREATER
3126: PUSH
3127: LD_INT 22
3129: PUSH
3130: LD_VAR 0 1
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PUSH
3139: LD_INT 21
3141: PUSH
3142: LD_INT 3
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 3
3151: PUSH
3152: LD_INT 24
3154: PUSH
3155: LD_INT 1000
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: LIST
3170: PPUSH
3171: CALL_OW 69
3175: PUSH
3176: LD_INT 0
3178: EQUAL
3179: AND
3180: PUSH
3181: LD_VAR 0 2
3185: PUSH
3186: LD_INT 0
3188: GREATER
3189: AND
3190: IFFALSE 3289
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3192: LD_ADDR_VAR 0 4
3196: PUSH
3197: LD_INT 22
3199: PUSH
3200: LD_VAR 0 1
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: PUSH
3209: LD_INT 25
3211: PUSH
3212: LD_INT 2
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL_OW 69
3227: PUSH
3228: FOR_IN
3229: IFFALSE 3287
// begin AddComExitBuilding ( i ) ;
3231: LD_VAR 0 4
3235: PPUSH
3236: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3240: LD_VAR 0 4
3244: PPUSH
3245: LD_VAR 0 2
3249: PUSH
3250: LD_INT 1
3252: ARRAY
3253: PPUSH
3254: LD_VAR 0 2
3258: PUSH
3259: LD_INT 2
3261: ARRAY
3262: PPUSH
3263: LD_VAR 0 2
3267: PUSH
3268: LD_INT 3
3270: ARRAY
3271: PPUSH
3272: LD_VAR 0 2
3276: PUSH
3277: LD_INT 4
3279: ARRAY
3280: PPUSH
3281: CALL_OW 205
// end ;
3285: GO 3228
3287: POP
3288: POP
// end ; end ; end_of_file
3289: LD_VAR 0 3
3293: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
3294: LD_INT 0
3296: PPUSH
3297: PPUSH
// if exist_mode then
3298: LD_VAR 0 2
3302: IFFALSE 3321
// unit := CreateCharacter ( ident ) else
3304: LD_ADDR_VAR 0 4
3308: PUSH
3309: LD_VAR 0 1
3313: PPUSH
3314: CALL_OW 34
3318: ST_TO_ADDR
3319: GO 3336
// unit := NewCharacter ( ident ) ;
3321: LD_ADDR_VAR 0 4
3325: PUSH
3326: LD_VAR 0 1
3330: PPUSH
3331: CALL_OW 25
3335: ST_TO_ADDR
// result := unit ;
3336: LD_ADDR_VAR 0 3
3340: PUSH
3341: LD_VAR 0 4
3345: ST_TO_ADDR
// end ;
3346: LD_VAR 0 3
3350: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
3351: LD_INT 0
3353: PPUSH
3354: PPUSH
3355: PPUSH
// uc_side := GetSide ( b ) ;
3356: LD_ADDR_OWVAR 20
3360: PUSH
3361: LD_VAR 0 2
3365: PPUSH
3366: CALL_OW 255
3370: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
3371: LD_ADDR_OWVAR 21
3375: PUSH
3376: LD_VAR 0 2
3380: PPUSH
3381: CALL_OW 248
3385: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_INT 1
3391: PPUSH
3392: LD_VAR 0 1
3396: PPUSH
3397: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
3401: LD_ADDR_VAR 0 5
3405: PUSH
3406: LD_VAR 0 2
3410: PPUSH
3411: CALL_OW 254
3415: PUSH
3416: LD_INT 3
3418: MINUS
3419: ST_TO_ADDR
// if dir < 0 then
3420: LD_VAR 0 5
3424: PUSH
3425: LD_INT 0
3427: LESS
3428: IFFALSE 3444
// dir := 6 + dir ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_INT 6
3437: PUSH
3438: LD_VAR 0 5
3442: PLUS
3443: ST_TO_ADDR
// un := CreateHuman ;
3444: LD_ADDR_VAR 0 4
3448: PUSH
3449: CALL_OW 44
3453: ST_TO_ADDR
// SetDir ( un , dir ) ;
3454: LD_VAR 0 4
3458: PPUSH
3459: LD_VAR 0 5
3463: PPUSH
3464: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
3468: LD_VAR 0 4
3472: PPUSH
3473: LD_VAR 0 2
3477: PPUSH
3478: CALL_OW 52
// end ; end_of_file
3482: LD_VAR 0 3
3486: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
3487: LD_VAR 0 1
3491: PPUSH
3492: CALL_OW 255
3496: PUSH
3497: LD_INT 3
3499: EQUAL
3500: PUSH
3501: LD_VAR 0 1
3505: PPUSH
3506: CALL_OW 247
3510: PUSH
3511: LD_INT 3
3513: EQUAL
3514: AND
3515: IFFALSE 4207
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
3517: LD_VAR 0 1
3521: PPUSH
3522: CALL_OW 266
3526: PUSH
3527: LD_INT 31
3529: EQUAL
3530: PUSH
3531: LD_VAR 0 1
3535: PPUSH
3536: CALL_OW 266
3540: PUSH
3541: LD_INT 32
3543: EQUAL
3544: OR
3545: PUSH
3546: LD_VAR 0 1
3550: PPUSH
3551: CALL_OW 266
3555: PUSH
3556: LD_INT 36
3558: EQUAL
3559: OR
3560: PUSH
3561: LD_VAR 0 1
3565: PPUSH
3566: CALL_OW 266
3570: PUSH
3571: LD_INT 0
3573: EQUAL
3574: OR
3575: PUSH
3576: LD_VAR 0 1
3580: PPUSH
3581: CALL_OW 266
3585: PUSH
3586: LD_INT 24
3588: EQUAL
3589: OR
3590: PUSH
3591: LD_VAR 0 1
3595: PPUSH
3596: CALL_OW 266
3600: PUSH
3601: LD_INT 17
3603: EQUAL
3604: OR
3605: PUSH
3606: LD_VAR 0 1
3610: PPUSH
3611: CALL_OW 266
3615: PUSH
3616: LD_INT 25
3618: EQUAL
3619: OR
3620: PUSH
3621: LD_VAR 0 1
3625: PPUSH
3626: CALL_OW 266
3630: PUSH
3631: LD_INT 19
3633: EQUAL
3634: OR
3635: PUSH
3636: LD_VAR 0 1
3640: PPUSH
3641: CALL_OW 266
3645: PUSH
3646: LD_INT 20
3648: EQUAL
3649: OR
3650: PUSH
3651: LD_VAR 0 1
3655: PPUSH
3656: CALL_OW 266
3660: PUSH
3661: LD_INT 18
3663: EQUAL
3664: OR
3665: PUSH
3666: LD_VAR 0 1
3670: PPUSH
3671: CALL_OW 266
3675: PUSH
3676: LD_INT 21
3678: EQUAL
3679: OR
3680: PUSH
3681: LD_VAR 0 1
3685: PPUSH
3686: CALL_OW 266
3690: PUSH
3691: LD_INT 23
3693: EQUAL
3694: OR
3695: PUSH
3696: LD_VAR 0 1
3700: PPUSH
3701: CALL_OW 266
3705: PUSH
3706: LD_INT 16
3708: EQUAL
3709: OR
3710: PUSH
3711: LD_VAR 0 1
3715: PPUSH
3716: CALL_OW 266
3720: PUSH
3721: LD_INT 6
3723: EQUAL
3724: OR
3725: PUSH
3726: LD_VAR 0 1
3730: PPUSH
3731: CALL_OW 266
3735: PUSH
3736: LD_INT 29
3738: EQUAL
3739: OR
3740: PUSH
3741: LD_VAR 0 1
3745: PPUSH
3746: CALL_OW 266
3750: PUSH
3751: LD_INT 26
3753: EQUAL
3754: OR
3755: PUSH
3756: LD_VAR 0 1
3760: PPUSH
3761: CALL_OW 266
3765: PUSH
3766: LD_INT 30
3768: EQUAL
3769: OR
3770: PUSH
3771: LD_VAR 0 1
3775: PPUSH
3776: CALL_OW 266
3780: PUSH
3781: LD_INT 28
3783: EQUAL
3784: OR
3785: PUSH
3786: LD_VAR 0 1
3790: PPUSH
3791: CALL_OW 266
3795: PUSH
3796: LD_INT 27
3798: EQUAL
3799: OR
3800: PUSH
3801: LD_VAR 0 1
3805: PPUSH
3806: CALL_OW 266
3810: PUSH
3811: LD_INT 33
3813: EQUAL
3814: OR
3815: PUSH
3816: LD_VAR 0 1
3820: PPUSH
3821: CALL_OW 266
3825: PUSH
3826: LD_INT 2
3828: EQUAL
3829: OR
3830: PUSH
3831: LD_VAR 0 1
3835: PPUSH
3836: CALL_OW 266
3840: PUSH
3841: LD_INT 4
3843: EQUAL
3844: OR
3845: IFFALSE 3931
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
3847: LD_ADDR_EXP 1
3851: PUSH
3852: LD_EXP 1
3856: PUSH
3857: LD_VAR 0 1
3861: PPUSH
3862: CALL_OW 266
3866: ADD
3867: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
3868: LD_ADDR_EXP 1
3872: PUSH
3873: LD_EXP 1
3877: PUSH
3878: LD_VAR 0 1
3882: PPUSH
3883: CALL_OW 250
3887: ADD
3888: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
3889: LD_ADDR_EXP 1
3893: PUSH
3894: LD_EXP 1
3898: PUSH
3899: LD_VAR 0 1
3903: PPUSH
3904: CALL_OW 251
3908: ADD
3909: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
3910: LD_ADDR_EXP 1
3914: PUSH
3915: LD_EXP 1
3919: PUSH
3920: LD_VAR 0 1
3924: PPUSH
3925: CALL_OW 254
3929: ADD
3930: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
3931: LD_VAR 0 1
3935: PPUSH
3936: CALL_OW 266
3940: PUSH
3941: LD_INT 1
3943: EQUAL
3944: IFFALSE 4023
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
3946: LD_ADDR_EXP 1
3950: PUSH
3951: LD_EXP 1
3955: PUSH
3956: LD_INT 0
3958: ADD
3959: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
3960: LD_ADDR_EXP 1
3964: PUSH
3965: LD_EXP 1
3969: PUSH
3970: LD_VAR 0 1
3974: PPUSH
3975: CALL_OW 250
3979: ADD
3980: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
3981: LD_ADDR_EXP 1
3985: PUSH
3986: LD_EXP 1
3990: PUSH
3991: LD_VAR 0 1
3995: PPUSH
3996: CALL_OW 251
4000: ADD
4001: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4002: LD_ADDR_EXP 1
4006: PUSH
4007: LD_EXP 1
4011: PUSH
4012: LD_VAR 0 1
4016: PPUSH
4017: CALL_OW 254
4021: ADD
4022: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4023: LD_VAR 0 1
4027: PPUSH
4028: CALL_OW 266
4032: PUSH
4033: LD_INT 3
4035: EQUAL
4036: IFFALSE 4115
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4038: LD_ADDR_EXP 1
4042: PUSH
4043: LD_EXP 1
4047: PUSH
4048: LD_INT 2
4050: ADD
4051: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4052: LD_ADDR_EXP 1
4056: PUSH
4057: LD_EXP 1
4061: PUSH
4062: LD_VAR 0 1
4066: PPUSH
4067: CALL_OW 250
4071: ADD
4072: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4073: LD_ADDR_EXP 1
4077: PUSH
4078: LD_EXP 1
4082: PUSH
4083: LD_VAR 0 1
4087: PPUSH
4088: CALL_OW 251
4092: ADD
4093: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4094: LD_ADDR_EXP 1
4098: PUSH
4099: LD_EXP 1
4103: PUSH
4104: LD_VAR 0 1
4108: PPUSH
4109: CALL_OW 254
4113: ADD
4114: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4115: LD_VAR 0 1
4119: PPUSH
4120: CALL_OW 266
4124: PUSH
4125: LD_INT 5
4127: EQUAL
4128: IFFALSE 4207
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
4130: LD_ADDR_EXP 1
4134: PUSH
4135: LD_EXP 1
4139: PUSH
4140: LD_INT 4
4142: ADD
4143: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4144: LD_ADDR_EXP 1
4148: PUSH
4149: LD_EXP 1
4153: PUSH
4154: LD_VAR 0 1
4158: PPUSH
4159: CALL_OW 250
4163: ADD
4164: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4165: LD_ADDR_EXP 1
4169: PUSH
4170: LD_EXP 1
4174: PUSH
4175: LD_VAR 0 1
4179: PPUSH
4180: CALL_OW 251
4184: ADD
4185: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4186: LD_ADDR_EXP 1
4190: PUSH
4191: LD_EXP 1
4195: PUSH
4196: LD_VAR 0 1
4200: PPUSH
4201: CALL_OW 254
4205: ADD
4206: ST_TO_ADDR
// end ; end ; end ;
4207: PPOPN 1
4209: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
4210: LD_VAR 0 1
4214: PPUSH
4215: CALL_OW 255
4219: PUSH
4220: LD_INT 3
4222: EQUAL
4223: IFFALSE 4297
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4225: LD_ADDR_EXP 1
4229: PUSH
4230: LD_EXP 1
4234: PPUSH
4235: LD_INT 1
4237: PPUSH
4238: CALL_OW 3
4242: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4243: LD_ADDR_EXP 1
4247: PUSH
4248: LD_EXP 1
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: CALL_OW 3
4260: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4261: LD_ADDR_EXP 1
4265: PUSH
4266: LD_EXP 1
4270: PPUSH
4271: LD_INT 1
4273: PPUSH
4274: CALL_OW 3
4278: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4279: LD_ADDR_EXP 1
4283: PUSH
4284: LD_EXP 1
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: CALL_OW 3
4296: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
4297: LD_VAR 0 1
4301: PPUSH
4302: CALL_OW 255
4306: PUSH
4307: LD_INT 3
4309: EQUAL
4310: PUSH
4311: LD_VAR 0 1
4315: PPUSH
4316: CALL_OW 266
4320: PUSH
4321: LD_INT 0
4323: EQUAL
4324: PUSH
4325: LD_VAR 0 1
4329: PPUSH
4330: CALL_OW 266
4334: PUSH
4335: LD_INT 2
4337: EQUAL
4338: OR
4339: PUSH
4340: LD_VAR 0 1
4344: PPUSH
4345: CALL_OW 266
4349: PUSH
4350: LD_INT 4
4352: EQUAL
4353: OR
4354: PUSH
4355: EMPTY
4356: LIST
4357: AND
4358: IFFALSE 4369
// ComUpgrade ( building ) ;
4360: LD_VAR 0 1
4364: PPUSH
4365: CALL_OW 146
// end ;
4369: PPOPN 1
4371: END
