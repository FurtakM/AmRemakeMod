// export destroyedBuildings ; export cargoTest ; export vehicleDriverTab ; export arabianMines ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// destroyedBuildings = [ ] ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// cargoTest = [ ] ;
  15: LD_ADDR_EXP 2
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// arabianMines = [ ] ;
  22: LD_ADDR_EXP 4
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// end ;
  29: END
// every 0 0$01 do var b ;
  30: GO 32
  32: DISABLE
  33: LD_INT 0
  35: PPUSH
// begin end ;
  36: PPOPN 1
  38: END
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
  39: LD_INT 0
  41: PPUSH
  42: PPUSH
  43: PPUSH
  44: PPUSH
// for i = 1 to 3 do
  45: LD_ADDR_VAR 0 5
  49: PUSH
  50: DOUBLE
  51: LD_INT 1
  53: DEC
  54: ST_TO_ADDR
  55: LD_INT 3
  57: PUSH
  58: FOR_TO
  59: IFFALSE 89
// amount := amount + GetResourceArea ( area , i ) ;
  61: LD_ADDR_VAR 0 4
  65: PUSH
  66: LD_VAR 0 4
  70: PUSH
  71: LD_VAR 0 1
  75: PPUSH
  76: LD_VAR 0 5
  80: PPUSH
  81: CALL_OW 287
  85: PLUS
  86: ST_TO_ADDR
  87: GO 58
  89: POP
  90: POP
// if amount < materials then
  91: LD_VAR 0 4
  95: PUSH
  96: LD_VAR 0 2
 100: LESS
 101: IFFALSE 105
// exit ;
 103: GO 139
// for i = 1 to 3 do
 105: LD_ADDR_VAR 0 5
 109: PUSH
 110: DOUBLE
 111: LD_INT 1
 113: DEC
 114: ST_TO_ADDR
 115: LD_INT 3
 117: PUSH
 118: FOR_TO
 119: IFFALSE 137
// EraseResourceArea ( area , i ) ;
 121: LD_VAR 0 1
 125: PPUSH
 126: LD_VAR 0 5
 130: PPUSH
 131: CALL_OW 286
 135: GO 118
 137: POP
 138: POP
// end ; end_of_file
 139: LD_VAR 0 3
 143: RET
// every 0 0$1 do
 144: GO 146
 146: DISABLE
// begin enable ;
 147: ENABLE
// RepairVehicles ( 3 , EnemyVehSpawn , 89 , 7 ) ;
 148: LD_INT 3
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: LD_INT 89
 156: PPUSH
 157: LD_INT 7
 159: PPUSH
 160: CALL 2434 0 4
// AttackVehicles ( 3 , EnemyVehSpawn , [ 213 , 115 , 96 ] , [ 13 , 14 , 8 ] ) ;
 164: LD_INT 3
 166: PPUSH
 167: LD_INT 2
 169: PPUSH
 170: LD_INT 213
 172: PUSH
 173: LD_INT 115
 175: PUSH
 176: LD_INT 96
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PPUSH
 184: LD_INT 13
 186: PUSH
 187: LD_INT 14
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: PPUSH
 198: CALL 2637 0 4
// end ;
 202: END
// every 5 5$1 do
 203: GO 205
 205: DISABLE
// begin BuildingVehicle ( 3 , rufab , 4 , [ 42 ] , 1 , 1 , 23 ) ;
 206: LD_INT 3
 208: PPUSH
 209: LD_INT 30
 211: PPUSH
 212: LD_INT 4
 214: PPUSH
 215: LD_INT 42
 217: PUSH
 218: EMPTY
 219: LIST
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: LD_INT 1
 226: PPUSH
 227: LD_INT 23
 229: PPUSH
 230: CALL 2322 0 7
// end ;
 234: END
// every 0 0$1 do
 235: GO 237
 237: DISABLE
// begin RespawnAttackVehicle ( EnemyVehSpawn , 3 , 5 , 10 , nation_russian , engine_siberite , control_manual , [ 44 , 46 ] , [ ] , [ ] ) ;
 238: LD_INT 2
 240: PPUSH
 241: LD_INT 3
 243: PPUSH
 244: LD_INT 5
 246: PPUSH
 247: LD_INT 10
 249: PPUSH
 250: LD_INT 3
 252: PPUSH
 253: LD_INT 3
 255: PPUSH
 256: LD_INT 1
 258: PPUSH
 259: LD_INT 44
 261: PUSH
 262: LD_INT 46
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: PPUSH
 269: EMPTY
 270: PPUSH
 271: EMPTY
 272: PPUSH
 273: CALL 816 0 10
// end ;
 277: END
// every 0 0$01 trigger arabianMines do var i , p ;
 278: LD_EXP 4
 282: IFFALSE 485
 284: GO 286
 286: DISABLE
 287: LD_INT 0
 289: PPUSH
 290: PPUSH
// begin enable ;
 291: ENABLE
// p := 1 ;
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: LD_INT 1
 299: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 300: LD_ADDR_VAR 0 1
 304: PUSH
 305: DOUBLE
 306: LD_INT 1
 308: DEC
 309: ST_TO_ADDR
 310: LD_EXP 4
 314: PUSH
 315: LD_INT 2
 317: DIVREAL
 318: PUSH
 319: FOR_TO
 320: IFFALSE 483
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 322: LD_INT 81
 324: PUSH
 325: LD_INT 2
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: PUSH
 332: LD_INT 92
 334: PUSH
 335: LD_EXP 4
 339: PUSH
 340: LD_VAR 0 2
 344: ARRAY
 345: PUSH
 346: LD_EXP 4
 350: PUSH
 351: LD_VAR 0 2
 355: PUSH
 356: LD_INT 1
 358: PLUS
 359: ARRAY
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: PPUSH
 374: CALL_OW 69
 378: IFFALSE 467
// begin LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 380: LD_EXP 4
 384: PUSH
 385: LD_VAR 0 2
 389: ARRAY
 390: PPUSH
 391: LD_EXP 4
 395: PUSH
 396: LD_VAR 0 2
 400: PUSH
 401: LD_INT 1
 403: PLUS
 404: ARRAY
 405: PPUSH
 406: LD_INT 2
 408: PPUSH
 409: CALL_OW 456
// arabianMines := Delete ( arabianMines , p ) ;
 413: LD_ADDR_EXP 4
 417: PUSH
 418: LD_EXP 4
 422: PPUSH
 423: LD_VAR 0 2
 427: PPUSH
 428: CALL_OW 3
 432: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 433: LD_ADDR_EXP 4
 437: PUSH
 438: LD_EXP 4
 442: PPUSH
 443: LD_VAR 0 2
 447: PPUSH
 448: CALL_OW 3
 452: ST_TO_ADDR
// p := p - 2 ;
 453: LD_ADDR_VAR 0 2
 457: PUSH
 458: LD_VAR 0 2
 462: PUSH
 463: LD_INT 2
 465: MINUS
 466: ST_TO_ADDR
// end ; p := p + 2 ;
 467: LD_ADDR_VAR 0 2
 471: PUSH
 472: LD_VAR 0 2
 476: PUSH
 477: LD_INT 2
 479: PLUS
 480: ST_TO_ADDR
// end ;
 481: GO 319
 483: POP
 484: POP
// end ; end_of_file
 485: PPOPN 2
 487: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 488: LD_INT 0
 490: PPUSH
 491: PPUSH
 492: PPUSH
// rnd = rand ( 1 , characters ) ;
 493: LD_ADDR_VAR 0 6
 497: PUSH
 498: LD_INT 1
 500: PPUSH
 501: LD_VAR 0 1
 505: PPUSH
 506: CALL_OW 12
 510: ST_TO_ADDR
// for i = 1 to characters do
 511: LD_ADDR_VAR 0 5
 515: PUSH
 516: DOUBLE
 517: LD_INT 1
 519: DEC
 520: ST_TO_ADDR
 521: LD_VAR 0 1
 525: PUSH
 526: FOR_TO
 527: IFFALSE 637
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 529: LD_VAR 0 5
 533: PUSH
 534: LD_VAR 0 6
 538: EQUAL
 539: PUSH
 540: LD_VAR 0 1
 544: PUSH
 545: LD_VAR 0 5
 549: ARRAY
 550: PPUSH
 551: CALL_OW 258
 555: PUSH
 556: LD_INT 1
 558: EQUAL
 559: AND
 560: IFFALSE 582
// Say ( characters [ i ] , dialogMID ) ;
 562: LD_VAR 0 1
 566: PUSH
 567: LD_VAR 0 5
 571: ARRAY
 572: PPUSH
 573: LD_VAR 0 2
 577: PPUSH
 578: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 582: LD_VAR 0 5
 586: PUSH
 587: LD_VAR 0 6
 591: EQUAL
 592: PUSH
 593: LD_VAR 0 1
 597: PUSH
 598: LD_VAR 0 5
 602: ARRAY
 603: PPUSH
 604: CALL_OW 258
 608: PUSH
 609: LD_INT 2
 611: EQUAL
 612: AND
 613: IFFALSE 635
// Say ( characters [ i ] , dialogFID ) ;
 615: LD_VAR 0 1
 619: PUSH
 620: LD_VAR 0 5
 624: ARRAY
 625: PPUSH
 626: LD_VAR 0 3
 630: PPUSH
 631: CALL_OW 88
// end ;
 635: GO 526
 637: POP
 638: POP
// end ;
 639: LD_VAR 0 4
 643: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 644: LD_INT 0
 646: PPUSH
 647: PPUSH
 648: PPUSH
 649: PPUSH
// for i = 1 to count do
 650: LD_ADDR_VAR 0 8
 654: PUSH
 655: DOUBLE
 656: LD_INT 1
 658: DEC
 659: ST_TO_ADDR
 660: LD_VAR 0 6
 664: PUSH
 665: FOR_TO
 666: IFFALSE 747
// begin uc_side = side ;
 668: LD_ADDR_OWVAR 20
 672: PUSH
 673: LD_VAR 0 1
 677: ST_TO_ADDR
// uc_nation = nation ;
 678: LD_ADDR_OWVAR 21
 682: PUSH
 683: LD_VAR 0 2
 687: ST_TO_ADDR
// hc_gallery =  ;
 688: LD_ADDR_OWVAR 33
 692: PUSH
 693: LD_STRING 
 695: ST_TO_ADDR
// hc_name =  ;
 696: LD_ADDR_OWVAR 26
 700: PUSH
 701: LD_STRING 
 703: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 704: LD_INT 0
 706: PPUSH
 707: LD_VAR 0 5
 711: PPUSH
 712: LD_VAR 0 4
 716: PPUSH
 717: CALL_OW 380
// un = CreateHuman ;
 721: LD_ADDR_VAR 0 10
 725: PUSH
 726: CALL_OW 44
 730: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 731: LD_VAR 0 10
 735: PPUSH
 736: LD_VAR 0 3
 740: PPUSH
 741: CALL_OW 52
// end ;
 745: GO 665
 747: POP
 748: POP
// end ;
 749: LD_VAR 0 7
 753: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 754: LD_INT 0
 756: PPUSH
 757: PPUSH
// for i in charactersList do
 758: LD_ADDR_VAR 0 4
 762: PUSH
 763: LD_VAR 0 1
 767: PUSH
 768: FOR_IN
 769: IFFALSE 809
// begin if IsOk ( i ) then
 771: LD_VAR 0 4
 775: PPUSH
 776: CALL_OW 302
 780: IFFALSE 798
// begin SaveCharacters ( i , ident ) ;
 782: LD_VAR 0 4
 786: PPUSH
 787: LD_VAR 0 2
 791: PPUSH
 792: CALL_OW 38
// end else
 796: GO 807
// begin DeleteCharacters ( ident ) ;
 798: LD_VAR 0 2
 802: PPUSH
 803: CALL_OW 40
// end ; end ;
 807: GO 768
 809: POP
 810: POP
// end ;
 811: LD_VAR 0 3
 815: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 816: LD_INT 0
 818: PPUSH
 819: PPUSH
 820: PPUSH
 821: PPUSH
 822: PPUSH
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
 827: PPUSH
 828: PPUSH
// amChassisTab = [ ] ;
 829: LD_ADDR_VAR 0 18
 833: PUSH
 834: EMPTY
 835: ST_TO_ADDR
// arChassisTab = [ ] ;
 836: LD_ADDR_VAR 0 17
 840: PUSH
 841: EMPTY
 842: ST_TO_ADDR
// ruChassisTab = [ ] ;
 843: LD_ADDR_VAR 0 16
 847: PUSH
 848: EMPTY
 849: ST_TO_ADDR
// if nation = 1 then
 850: LD_VAR 0 5
 854: PUSH
 855: LD_INT 1
 857: EQUAL
 858: IFFALSE 1275
// begin for i := 1 to vehCount do
 860: LD_ADDR_VAR 0 12
 864: PUSH
 865: DOUBLE
 866: LD_INT 1
 868: DEC
 869: ST_TO_ADDR
 870: LD_VAR 0 3
 874: PUSH
 875: FOR_TO
 876: IFFALSE 1273
// begin uc_side = side ;
 878: LD_ADDR_OWVAR 20
 882: PUSH
 883: LD_VAR 0 2
 887: ST_TO_ADDR
// uc_nation = nation ;
 888: LD_ADDR_OWVAR 21
 892: PUSH
 893: LD_VAR 0 5
 897: ST_TO_ADDR
// vc_engine = vehengine ;
 898: LD_ADDR_OWVAR 39
 902: PUSH
 903: LD_VAR 0 6
 907: ST_TO_ADDR
// vc_control = vehcontrol ;
 908: LD_ADDR_OWVAR 38
 912: PUSH
 913: LD_VAR 0 7
 917: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 918: LD_ADDR_OWVAR 40
 922: PUSH
 923: LD_VAR 0 10
 927: PUSH
 928: LD_INT 1
 930: PPUSH
 931: LD_VAR 0 10
 935: PPUSH
 936: CALL_OW 12
 940: ARRAY
 941: ST_TO_ADDR
// if vc_weapon = 2 or vc_weapon = 3 then
 942: LD_OWVAR 40
 946: PUSH
 947: LD_INT 2
 949: EQUAL
 950: PUSH
 951: LD_OWVAR 40
 955: PUSH
 956: LD_INT 3
 958: EQUAL
 959: OR
 960: IFFALSE 1013
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 962: LD_ADDR_VAR 0 18
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 2
 972: PUSH
 973: LD_INT 3
 975: PUSH
 976: LD_INT 4
 978: PUSH
 979: LD_INT 5
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: LIST
 988: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 989: LD_ADDR_OWVAR 37
 993: PUSH
 994: LD_VAR 0 18
 998: PUSH
 999: LD_INT 1
1001: PPUSH
1002: LD_VAR 0 18
1006: PPUSH
1007: CALL_OW 12
1011: ARRAY
1012: ST_TO_ADDR
// end ; if vc_weapon = 4 or vc_weapon = 5 or vc_weapon = 9 or vc_weapon = 11 or vc_weapon = 7 then
1013: LD_OWVAR 40
1017: PUSH
1018: LD_INT 4
1020: EQUAL
1021: PUSH
1022: LD_OWVAR 40
1026: PUSH
1027: LD_INT 5
1029: EQUAL
1030: OR
1031: PUSH
1032: LD_OWVAR 40
1036: PUSH
1037: LD_INT 9
1039: EQUAL
1040: OR
1041: PUSH
1042: LD_OWVAR 40
1046: PUSH
1047: LD_INT 11
1049: EQUAL
1050: OR
1051: PUSH
1052: LD_OWVAR 40
1056: PUSH
1057: LD_INT 7
1059: EQUAL
1060: OR
1061: IFFALSE 1110
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1063: LD_ADDR_VAR 0 18
1067: PUSH
1068: LD_INT 2
1070: PUSH
1071: LD_INT 3
1073: PUSH
1074: LD_INT 4
1076: PUSH
1077: LD_INT 5
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1086: LD_ADDR_OWVAR 37
1090: PUSH
1091: LD_VAR 0 18
1095: PUSH
1096: LD_INT 1
1098: PPUSH
1099: LD_VAR 0 18
1103: PPUSH
1104: CALL_OW 12
1108: ARRAY
1109: ST_TO_ADDR
// end ; if vc_weapon = 8 or vc_weapon = 6 or vc_weapon = 10 then
1110: LD_OWVAR 40
1114: PUSH
1115: LD_INT 8
1117: EQUAL
1118: PUSH
1119: LD_OWVAR 40
1123: PUSH
1124: LD_INT 6
1126: EQUAL
1127: OR
1128: PUSH
1129: LD_OWVAR 40
1133: PUSH
1134: LD_INT 10
1136: EQUAL
1137: OR
1138: IFFALSE 1179
// begin amChassisTab = [ 4 , 5 ] ;
1140: LD_ADDR_VAR 0 18
1144: PUSH
1145: LD_INT 4
1147: PUSH
1148: LD_INT 5
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1155: LD_ADDR_OWVAR 37
1159: PUSH
1160: LD_VAR 0 18
1164: PUSH
1165: LD_INT 1
1167: PPUSH
1168: LD_VAR 0 18
1172: PPUSH
1173: CALL_OW 12
1177: ARRAY
1178: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1179: LD_ADDR_VAR 0 15
1183: PUSH
1184: CALL_OW 45
1188: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1189: LD_VAR 0 15
1193: PPUSH
1194: LD_VAR 0 1
1198: PPUSH
1199: LD_INT 0
1201: PPUSH
1202: CALL_OW 49
// if vehcontrol = 1 then
1206: LD_VAR 0 7
1210: PUSH
1211: LD_INT 1
1213: EQUAL
1214: IFFALSE 1271
// begin hc_gallery =  ;
1216: LD_ADDR_OWVAR 33
1220: PUSH
1221: LD_STRING 
1223: ST_TO_ADDR
// hc_name =  ;
1224: LD_ADDR_OWVAR 26
1228: PUSH
1229: LD_STRING 
1231: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1232: LD_INT 0
1234: PPUSH
1235: LD_INT 3
1237: PPUSH
1238: LD_VAR 0 4
1242: PPUSH
1243: CALL_OW 380
// un = CreateHuman ;
1247: LD_ADDR_VAR 0 14
1251: PUSH
1252: CALL_OW 44
1256: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1257: LD_VAR 0 14
1261: PPUSH
1262: LD_VAR 0 15
1266: PPUSH
1267: CALL_OW 52
// end ; end ;
1271: GO 875
1273: POP
1274: POP
// end ; if nation = 2 then
1275: LD_VAR 0 5
1279: PUSH
1280: LD_INT 2
1282: EQUAL
1283: IFFALSE 1639
// begin for i := 1 to vehCount do
1285: LD_ADDR_VAR 0 12
1289: PUSH
1290: DOUBLE
1291: LD_INT 1
1293: DEC
1294: ST_TO_ADDR
1295: LD_VAR 0 3
1299: PUSH
1300: FOR_TO
1301: IFFALSE 1637
// begin uc_side = side ;
1303: LD_ADDR_OWVAR 20
1307: PUSH
1308: LD_VAR 0 2
1312: ST_TO_ADDR
// uc_nation = nation ;
1313: LD_ADDR_OWVAR 21
1317: PUSH
1318: LD_VAR 0 5
1322: ST_TO_ADDR
// vc_engine = vehengine ;
1323: LD_ADDR_OWVAR 39
1327: PUSH
1328: LD_VAR 0 6
1332: ST_TO_ADDR
// vc_control = vehcontrol ;
1333: LD_ADDR_OWVAR 38
1337: PUSH
1338: LD_VAR 0 7
1342: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1343: LD_ADDR_OWVAR 40
1347: PUSH
1348: LD_VAR 0 9
1352: PUSH
1353: LD_INT 1
1355: PPUSH
1356: LD_VAR 0 9
1360: PPUSH
1361: CALL_OW 12
1365: ARRAY
1366: ST_TO_ADDR
// if vc_weapon = 24 or vc_weapon = 22 or vc_weapon = 23 or vc_weapon = 30 then
1367: LD_OWVAR 40
1371: PUSH
1372: LD_INT 24
1374: EQUAL
1375: PUSH
1376: LD_OWVAR 40
1380: PUSH
1381: LD_INT 22
1383: EQUAL
1384: OR
1385: PUSH
1386: LD_OWVAR 40
1390: PUSH
1391: LD_INT 23
1393: EQUAL
1394: OR
1395: PUSH
1396: LD_OWVAR 40
1400: PUSH
1401: LD_INT 30
1403: EQUAL
1404: OR
1405: IFFALSE 1454
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1407: LD_ADDR_VAR 0 17
1411: PUSH
1412: LD_INT 11
1414: PUSH
1415: LD_INT 12
1417: PUSH
1418: LD_INT 13
1420: PUSH
1421: LD_INT 14
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1430: LD_ADDR_OWVAR 37
1434: PUSH
1435: LD_VAR 0 17
1439: PUSH
1440: LD_INT 1
1442: PPUSH
1443: LD_VAR 0 17
1447: PPUSH
1448: CALL_OW 12
1452: ARRAY
1453: ST_TO_ADDR
// end ; if vc_weapon = 29 or vc_weapon = 28 or vc_weapon = 27 or vc_weapon = 26 or vc_weapon = 25 then
1454: LD_OWVAR 40
1458: PUSH
1459: LD_INT 29
1461: EQUAL
1462: PUSH
1463: LD_OWVAR 40
1467: PUSH
1468: LD_INT 28
1470: EQUAL
1471: OR
1472: PUSH
1473: LD_OWVAR 40
1477: PUSH
1478: LD_INT 27
1480: EQUAL
1481: OR
1482: PUSH
1483: LD_OWVAR 40
1487: PUSH
1488: LD_INT 26
1490: EQUAL
1491: OR
1492: PUSH
1493: LD_OWVAR 40
1497: PUSH
1498: LD_INT 25
1500: EQUAL
1501: OR
1502: IFFALSE 1543
// begin arChassisTab = [ 13 , 14 ] ;
1504: LD_ADDR_VAR 0 17
1508: PUSH
1509: LD_INT 13
1511: PUSH
1512: LD_INT 14
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1519: LD_ADDR_OWVAR 37
1523: PUSH
1524: LD_VAR 0 17
1528: PUSH
1529: LD_INT 1
1531: PPUSH
1532: LD_VAR 0 17
1536: PPUSH
1537: CALL_OW 12
1541: ARRAY
1542: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1543: LD_ADDR_VAR 0 15
1547: PUSH
1548: CALL_OW 45
1552: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1553: LD_VAR 0 15
1557: PPUSH
1558: LD_VAR 0 1
1562: PPUSH
1563: LD_INT 0
1565: PPUSH
1566: CALL_OW 49
// if vehcontrol = 1 then
1570: LD_VAR 0 7
1574: PUSH
1575: LD_INT 1
1577: EQUAL
1578: IFFALSE 1635
// begin hc_gallery =  ;
1580: LD_ADDR_OWVAR 33
1584: PUSH
1585: LD_STRING 
1587: ST_TO_ADDR
// hc_name =  ;
1588: LD_ADDR_OWVAR 26
1592: PUSH
1593: LD_STRING 
1595: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1596: LD_INT 0
1598: PPUSH
1599: LD_INT 3
1601: PPUSH
1602: LD_VAR 0 4
1606: PPUSH
1607: CALL_OW 380
// un = CreateHuman ;
1611: LD_ADDR_VAR 0 14
1615: PUSH
1616: CALL_OW 44
1620: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1621: LD_VAR 0 14
1625: PPUSH
1626: LD_VAR 0 15
1630: PPUSH
1631: CALL_OW 52
// end ; end ;
1635: GO 1300
1637: POP
1638: POP
// end ; if nation = 3 then
1639: LD_VAR 0 5
1643: PUSH
1644: LD_INT 3
1646: EQUAL
1647: IFFALSE 2005
// begin for i := 1 to vehCount do
1649: LD_ADDR_VAR 0 12
1653: PUSH
1654: DOUBLE
1655: LD_INT 1
1657: DEC
1658: ST_TO_ADDR
1659: LD_VAR 0 3
1663: PUSH
1664: FOR_TO
1665: IFFALSE 2003
// begin uc_side = side ;
1667: LD_ADDR_OWVAR 20
1671: PUSH
1672: LD_VAR 0 2
1676: ST_TO_ADDR
// uc_nation = nation ;
1677: LD_ADDR_OWVAR 21
1681: PUSH
1682: LD_VAR 0 5
1686: ST_TO_ADDR
// vc_engine = vehengine ;
1687: LD_ADDR_OWVAR 39
1691: PUSH
1692: LD_VAR 0 6
1696: ST_TO_ADDR
// vc_control = vehcontrol ;
1697: LD_ADDR_OWVAR 38
1701: PUSH
1702: LD_VAR 0 7
1706: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1707: LD_ADDR_OWVAR 40
1711: PUSH
1712: LD_VAR 0 8
1716: PUSH
1717: LD_INT 1
1719: PPUSH
1720: LD_VAR 0 8
1724: PPUSH
1725: CALL_OW 12
1729: ARRAY
1730: ST_TO_ADDR
// for j = 1 to RuWeapons do
1731: LD_ADDR_VAR 0 13
1735: PUSH
1736: DOUBLE
1737: LD_INT 1
1739: DEC
1740: ST_TO_ADDR
1741: LD_VAR 0 8
1745: PUSH
1746: FOR_TO
1747: IFFALSE 1907
// begin if vc_weapon = 42 or vc_weapon = 43 or vc_weapon = 44 or vc_weapon = 45 or vc_weapon = 49 then
1749: LD_OWVAR 40
1753: PUSH
1754: LD_INT 42
1756: EQUAL
1757: PUSH
1758: LD_OWVAR 40
1762: PUSH
1763: LD_INT 43
1765: EQUAL
1766: OR
1767: PUSH
1768: LD_OWVAR 40
1772: PUSH
1773: LD_INT 44
1775: EQUAL
1776: OR
1777: PUSH
1778: LD_OWVAR 40
1782: PUSH
1783: LD_INT 45
1785: EQUAL
1786: OR
1787: PUSH
1788: LD_OWVAR 40
1792: PUSH
1793: LD_INT 49
1795: EQUAL
1796: OR
1797: IFFALSE 1846
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1799: LD_ADDR_VAR 0 16
1803: PUSH
1804: LD_INT 21
1806: PUSH
1807: LD_INT 22
1809: PUSH
1810: LD_INT 23
1812: PUSH
1813: LD_INT 24
1815: PUSH
1816: EMPTY
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1822: LD_ADDR_OWVAR 37
1826: PUSH
1827: LD_VAR 0 16
1831: PUSH
1832: LD_INT 1
1834: PPUSH
1835: LD_VAR 0 16
1839: PPUSH
1840: CALL_OW 12
1844: ARRAY
1845: ST_TO_ADDR
// end ; if vc_weapon = 46 or vc_weapon = 47 then
1846: LD_OWVAR 40
1850: PUSH
1851: LD_INT 46
1853: EQUAL
1854: PUSH
1855: LD_OWVAR 40
1859: PUSH
1860: LD_INT 47
1862: EQUAL
1863: OR
1864: IFFALSE 1905
// begin ruChassisTab = [ 23 , 24 ] ;
1866: LD_ADDR_VAR 0 16
1870: PUSH
1871: LD_INT 23
1873: PUSH
1874: LD_INT 24
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1881: LD_ADDR_OWVAR 37
1885: PUSH
1886: LD_VAR 0 16
1890: PUSH
1891: LD_INT 1
1893: PPUSH
1894: LD_VAR 0 16
1898: PPUSH
1899: CALL_OW 12
1903: ARRAY
1904: ST_TO_ADDR
// end ; end ;
1905: GO 1746
1907: POP
1908: POP
// veh = CreateVehicle ;
1909: LD_ADDR_VAR 0 15
1913: PUSH
1914: CALL_OW 45
1918: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1919: LD_VAR 0 15
1923: PPUSH
1924: LD_VAR 0 1
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
// if vehcontrol = 1 then
1936: LD_VAR 0 7
1940: PUSH
1941: LD_INT 1
1943: EQUAL
1944: IFFALSE 2001
// begin hc_gallery =  ;
1946: LD_ADDR_OWVAR 33
1950: PUSH
1951: LD_STRING 
1953: ST_TO_ADDR
// hc_name =  ;
1954: LD_ADDR_OWVAR 26
1958: PUSH
1959: LD_STRING 
1961: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1962: LD_INT 0
1964: PPUSH
1965: LD_INT 3
1967: PPUSH
1968: LD_VAR 0 4
1972: PPUSH
1973: CALL_OW 380
// un = CreateHuman ;
1977: LD_ADDR_VAR 0 14
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1987: LD_VAR 0 14
1991: PPUSH
1992: LD_VAR 0 15
1996: PPUSH
1997: CALL_OW 52
// end ; end ;
2001: GO 1664
2003: POP
2004: POP
// end ; repeat wait ( 0 0$1 ) ;
2005: LD_INT 35
2007: PPUSH
2008: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2012: LD_ADDR_VAR 0 19
2016: PUSH
2017: LD_INT 22
2019: PUSH
2020: LD_VAR 0 2
2024: PUSH
2025: EMPTY
2026: LIST
2027: LIST
2028: PUSH
2029: LD_INT 21
2031: PUSH
2032: LD_INT 2
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: PUSH
2039: LD_INT 24
2041: PUSH
2042: LD_INT 650
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: PPUSH
2054: CALL_OW 69
2058: ST_TO_ADDR
// if vehicleOK_list > 0 then
2059: LD_VAR 0 19
2063: PUSH
2064: LD_INT 0
2066: GREATER
2067: IFFALSE 2258
// begin for i in vehicleOK_list do
2069: LD_ADDR_VAR 0 12
2073: PUSH
2074: LD_VAR 0 19
2078: PUSH
2079: FOR_IN
2080: IFFALSE 2256
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , side ] ) , i ) ;
2082: LD_ADDR_VAR 0 20
2086: PUSH
2087: LD_INT 81
2089: PUSH
2090: LD_VAR 0 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: PPUSH
2099: CALL_OW 69
2103: PPUSH
2104: LD_VAR 0 12
2108: PPUSH
2109: CALL_OW 74
2113: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2114: LD_ADDR_VAR 0 21
2118: PUSH
2119: LD_INT 81
2121: PUSH
2122: LD_VAR 0 2
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 2
2133: PUSH
2134: LD_INT 59
2136: PUSH
2137: EMPTY
2138: LIST
2139: PUSH
2140: LD_INT 21
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: PUSH
2150: LD_INT 21
2152: PUSH
2153: LD_INT 2
2155: PUSH
2156: EMPTY
2157: LIST
2158: LIST
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: PUSH
2166: EMPTY
2167: LIST
2168: LIST
2169: PUSH
2170: EMPTY
2171: LIST
2172: PPUSH
2173: CALL_OW 69
2177: PPUSH
2178: LD_VAR 0 12
2182: PPUSH
2183: CALL_OW 74
2187: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2188: LD_VAR 0 12
2192: PPUSH
2193: LD_VAR 0 20
2197: PPUSH
2198: CALL_OW 296
2202: PUSH
2203: LD_INT 8
2205: PLUS
2206: PUSH
2207: LD_VAR 0 12
2211: PPUSH
2212: LD_VAR 0 21
2216: PPUSH
2217: CALL_OW 296
2221: LESS
2222: IFFALSE 2240
// ComAttackUnit ( i , target1 ) else
2224: LD_VAR 0 12
2228: PPUSH
2229: LD_VAR 0 20
2233: PPUSH
2234: CALL_OW 115
2238: GO 2254
// ComAttackUnit ( i , target2 ) ;
2240: LD_VAR 0 12
2244: PPUSH
2245: LD_VAR 0 21
2249: PPUSH
2250: CALL_OW 115
// end ;
2254: GO 2079
2256: POP
2257: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_empty ] ] ) = 0 ;
2258: LD_INT 22
2260: PUSH
2261: LD_VAR 0 2
2265: PUSH
2266: EMPTY
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 21
2272: PUSH
2273: LD_INT 2
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: PUSH
2280: LD_INT 24
2282: PUSH
2283: LD_INT 250
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: PUSH
2290: LD_INT 58
2292: PUSH
2293: EMPTY
2294: LIST
2295: PUSH
2296: EMPTY
2297: LIST
2298: LIST
2299: LIST
2300: LIST
2301: PPUSH
2302: CALL_OW 69
2306: PUSH
2307: LD_INT 0
2309: EQUAL
2310: IFFALSE 2005
// end ;
2312: LD_VAR 0 11
2316: RET
// every 0 0$1 do
2317: GO 2319
2319: DISABLE
// begin enable ;
2320: ENABLE
// end ;
2321: END
// export function BuildingVehicle ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2322: LD_INT 0
2324: PPUSH
2325: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2326: LD_INT 22
2328: PUSH
2329: LD_VAR 0 1
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PUSH
2338: LD_INT 21
2340: PUSH
2341: LD_INT 2
2343: PUSH
2344: EMPTY
2345: LIST
2346: LIST
2347: PUSH
2348: EMPTY
2349: LIST
2350: LIST
2351: PPUSH
2352: CALL_OW 69
2356: PUSH
2357: LD_VAR 0 3
2361: LESSEQUAL
2362: IFFALSE 2429
// for i = 1 to vehCount do
2364: LD_ADDR_VAR 0 9
2368: PUSH
2369: DOUBLE
2370: LD_INT 1
2372: DEC
2373: ST_TO_ADDR
2374: LD_VAR 0 3
2378: PUSH
2379: FOR_TO
2380: IFFALSE 2427
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2382: LD_VAR 0 2
2386: PPUSH
2387: LD_VAR 0 7
2391: PPUSH
2392: LD_VAR 0 5
2396: PPUSH
2397: LD_VAR 0 6
2401: PPUSH
2402: LD_VAR 0 4
2406: PUSH
2407: LD_INT 1
2409: PPUSH
2410: LD_VAR 0 4
2414: PPUSH
2415: CALL_OW 12
2419: ARRAY
2420: PPUSH
2421: CALL_OW 185
2425: GO 2379
2427: POP
2428: POP
// end ;
2429: LD_VAR 0 8
2433: RET
// export function RepairVehicles ( side , area , repX , repY ) ; var i , j , damageVehicles ; begin
2434: LD_INT 0
2436: PPUSH
2437: PPUSH
2438: PPUSH
2439: PPUSH
// damageVehicles = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
2440: LD_ADDR_VAR 0 8
2444: PUSH
2445: LD_INT 22
2447: PUSH
2448: LD_VAR 0 1
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: PUSH
2457: LD_INT 21
2459: PUSH
2460: LD_INT 2
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PUSH
2467: LD_INT 3
2469: PUSH
2470: LD_INT 24
2472: PUSH
2473: LD_INT 650
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: LIST
2488: PPUSH
2489: CALL_OW 69
2493: ST_TO_ADDR
// if damageVehicles > 0 then
2494: LD_VAR 0 8
2498: PUSH
2499: LD_INT 0
2501: GREATER
2502: IFFALSE 2523
// ComMoveXY ( damageVehicles , repX , repY ) ;
2504: LD_VAR 0 8
2508: PPUSH
2509: LD_VAR 0 3
2513: PPUSH
2514: LD_VAR 0 4
2518: PPUSH
2519: CALL_OW 111
// if UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) > 0 then
2523: LD_VAR 0 8
2527: PPUSH
2528: LD_INT 95
2530: PUSH
2531: LD_VAR 0 2
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: PUSH
2540: LD_INT 3
2542: PUSH
2543: LD_INT 58
2545: PUSH
2546: EMPTY
2547: LIST
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 72
2561: PUSH
2562: LD_INT 0
2564: GREATER
2565: IFFALSE 2632
// for i in UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) do
2567: LD_ADDR_VAR 0 6
2571: PUSH
2572: LD_VAR 0 8
2576: PPUSH
2577: LD_INT 95
2579: PUSH
2580: LD_VAR 0 2
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: LD_INT 3
2591: PUSH
2592: LD_INT 58
2594: PUSH
2595: EMPTY
2596: LIST
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: PPUSH
2606: CALL_OW 72
2610: PUSH
2611: FOR_IN
2612: IFFALSE 2630
// ComExitVehicle ( UnitsInside ( i ) ) ;
2614: LD_VAR 0 6
2618: PPUSH
2619: CALL_OW 313
2623: PPUSH
2624: CALL_OW 121
2628: GO 2611
2630: POP
2631: POP
// end ;
2632: LD_VAR 0 5
2636: RET
// export function AttackVehicles ( side , meetArea , wayX , wayY ) ; var i , j , vehiclesOK , target1 , target2 , seeEnemy ; begin
2637: LD_INT 0
2639: PPUSH
2640: PPUSH
2641: PPUSH
2642: PPUSH
2643: PPUSH
2644: PPUSH
2645: PPUSH
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2646: LD_ADDR_VAR 0 8
2650: PUSH
2651: LD_INT 22
2653: PUSH
2654: LD_VAR 0 1
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: LD_INT 21
2665: PUSH
2666: LD_INT 2
2668: PUSH
2669: EMPTY
2670: LIST
2671: LIST
2672: PUSH
2673: LD_INT 24
2675: PUSH
2676: LD_INT 650
2678: PUSH
2679: EMPTY
2680: LIST
2681: LIST
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 5 then
2693: LD_INT 22
2695: PUSH
2696: LD_VAR 0 1
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PUSH
2705: LD_INT 21
2707: PUSH
2708: LD_INT 2
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PUSH
2715: LD_INT 24
2717: PUSH
2718: LD_INT 1000
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL_OW 69
2734: PUSH
2735: LD_INT 5
2737: EQUAL
2738: IFFALSE 3205
// repeat wait ( 0 0$1 ) ;
2740: LD_INT 35
2742: PPUSH
2743: CALL_OW 67
// display_strings = seeEnemy ;
2747: LD_ADDR_OWVAR 47
2751: PUSH
2752: LD_VAR 0 11
2756: ST_TO_ADDR
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2757: LD_ADDR_VAR 0 8
2761: PUSH
2762: LD_INT 22
2764: PUSH
2765: LD_VAR 0 1
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: LD_INT 21
2776: PUSH
2777: LD_INT 2
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: LD_INT 24
2786: PUSH
2787: LD_INT 650
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: LIST
2798: PPUSH
2799: CALL_OW 69
2803: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) and seeEnemy = 0 then
2804: LD_INT 22
2806: PUSH
2807: LD_VAR 0 1
2811: PUSH
2812: EMPTY
2813: LIST
2814: LIST
2815: PUSH
2816: LD_INT 95
2818: PUSH
2819: LD_VAR 0 2
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PPUSH
2832: CALL_OW 69
2836: NOT
2837: PUSH
2838: LD_VAR 0 11
2842: PUSH
2843: LD_INT 0
2845: EQUAL
2846: AND
2847: IFFALSE 2902
// for i := 1 to wayX do
2849: LD_ADDR_VAR 0 6
2853: PUSH
2854: DOUBLE
2855: LD_INT 1
2857: DEC
2858: ST_TO_ADDR
2859: LD_VAR 0 3
2863: PUSH
2864: FOR_TO
2865: IFFALSE 2900
// AddComAgressiveMove ( vehiclesOK , wayX [ i ] , wayY [ i ] ) ;
2867: LD_VAR 0 8
2871: PPUSH
2872: LD_VAR 0 3
2876: PUSH
2877: LD_VAR 0 6
2881: ARRAY
2882: PPUSH
2883: LD_VAR 0 4
2887: PUSH
2888: LD_VAR 0 6
2892: ARRAY
2893: PPUSH
2894: CALL_OW 174
2898: GO 2864
2900: POP
2901: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) then
2902: LD_INT 22
2904: PUSH
2905: LD_VAR 0 1
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: PUSH
2914: LD_INT 95
2916: PUSH
2917: LD_VAR 0 2
2921: PUSH
2922: EMPTY
2923: LIST
2924: LIST
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: PPUSH
2930: CALL_OW 69
2934: IFFALSE 3158
// begin seeEnemy = 1 ;
2936: LD_ADDR_VAR 0 11
2940: PUSH
2941: LD_INT 1
2943: ST_TO_ADDR
// for j in vehiclesOK do
2944: LD_ADDR_VAR 0 7
2948: PUSH
2949: LD_VAR 0 8
2953: PUSH
2954: FOR_IN
2955: IFFALSE 3156
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , side ] , [ f_see , 1 ] ] ) , j ) ;
2957: LD_ADDR_VAR 0 9
2961: PUSH
2962: LD_INT 81
2964: PUSH
2965: LD_VAR 0 1
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 101
2976: PUSH
2977: LD_INT 1
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: PPUSH
2988: CALL_OW 69
2992: PPUSH
2993: LD_VAR 0 7
2997: PPUSH
2998: CALL_OW 74
3002: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_see , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , j ) ;
3003: LD_ADDR_VAR 0 10
3007: PUSH
3008: LD_INT 81
3010: PUSH
3011: LD_VAR 0 1
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: PUSH
3020: LD_INT 101
3022: PUSH
3023: LD_INT 1
3025: PUSH
3026: EMPTY
3027: LIST
3028: LIST
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: LD_INT 59
3035: PUSH
3036: EMPTY
3037: LIST
3038: PUSH
3039: LD_INT 21
3041: PUSH
3042: LD_INT 1
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: PUSH
3049: LD_INT 21
3051: PUSH
3052: LD_INT 2
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: LIST
3069: PUSH
3070: EMPTY
3071: LIST
3072: PPUSH
3073: CALL_OW 69
3077: PPUSH
3078: LD_VAR 0 7
3082: PPUSH
3083: CALL_OW 74
3087: ST_TO_ADDR
// if GetDistUnits ( j , target1 ) + 8 < GetDistUnits ( j , target2 ) then
3088: LD_VAR 0 7
3092: PPUSH
3093: LD_VAR 0 9
3097: PPUSH
3098: CALL_OW 296
3102: PUSH
3103: LD_INT 8
3105: PLUS
3106: PUSH
3107: LD_VAR 0 7
3111: PPUSH
3112: LD_VAR 0 10
3116: PPUSH
3117: CALL_OW 296
3121: LESS
3122: IFFALSE 3140
// ComAttackUnit ( j , target1 ) else
3124: LD_VAR 0 7
3128: PPUSH
3129: LD_VAR 0 9
3133: PPUSH
3134: CALL_OW 115
3138: GO 3154
// ComAttackUnit ( j , target2 ) ;
3140: LD_VAR 0 7
3144: PPUSH
3145: LD_VAR 0 10
3149: PPUSH
3150: CALL_OW 115
// end ;
3154: GO 2954
3156: POP
3157: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 0 ;
3158: LD_INT 22
3160: PUSH
3161: LD_VAR 0 1
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: LD_INT 21
3172: PUSH
3173: LD_INT 2
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: PUSH
3180: LD_INT 24
3182: PUSH
3183: LD_INT 1000
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: LIST
3194: PPUSH
3195: CALL_OW 69
3199: PUSH
3200: LD_INT 0
3202: EQUAL
3203: IFFALSE 2740
// seeEnemy = 0 ;
3205: LD_ADDR_VAR 0 11
3209: PUSH
3210: LD_INT 0
3212: ST_TO_ADDR
// end ;
3213: LD_VAR 0 5
3217: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3218: LD_INT 0
3220: PPUSH
3221: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3222: LD_INT 22
3224: PUSH
3225: LD_VAR 0 1
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: LD_INT 25
3236: PUSH
3237: LD_INT 2
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PUSH
3244: EMPTY
3245: LIST
3246: LIST
3247: PPUSH
3248: CALL_OW 69
3252: PUSH
3253: LD_INT 0
3255: GREATER
3256: PUSH
3257: LD_INT 22
3259: PUSH
3260: LD_VAR 0 1
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PUSH
3269: LD_INT 21
3271: PUSH
3272: LD_INT 3
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 3
3281: PUSH
3282: LD_INT 24
3284: PUSH
3285: LD_INT 1000
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: LIST
3300: PPUSH
3301: CALL_OW 69
3305: PUSH
3306: LD_INT 0
3308: EQUAL
3309: AND
3310: PUSH
3311: LD_VAR 0 2
3315: PUSH
3316: LD_INT 0
3318: GREATER
3319: AND
3320: IFFALSE 3419
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3322: LD_ADDR_VAR 0 4
3326: PUSH
3327: LD_INT 22
3329: PUSH
3330: LD_VAR 0 1
3334: PUSH
3335: EMPTY
3336: LIST
3337: LIST
3338: PUSH
3339: LD_INT 25
3341: PUSH
3342: LD_INT 2
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PPUSH
3353: CALL_OW 69
3357: PUSH
3358: FOR_IN
3359: IFFALSE 3417
// begin AddComExitBuilding ( i ) ;
3361: LD_VAR 0 4
3365: PPUSH
3366: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3370: LD_VAR 0 4
3374: PPUSH
3375: LD_VAR 0 2
3379: PUSH
3380: LD_INT 1
3382: ARRAY
3383: PPUSH
3384: LD_VAR 0 2
3388: PUSH
3389: LD_INT 2
3391: ARRAY
3392: PPUSH
3393: LD_VAR 0 2
3397: PUSH
3398: LD_INT 3
3400: ARRAY
3401: PPUSH
3402: LD_VAR 0 2
3406: PUSH
3407: LD_INT 4
3409: ARRAY
3410: PPUSH
3411: CALL_OW 205
// end ;
3415: GO 3358
3417: POP
3418: POP
// end ; end ;
3419: LD_VAR 0 3
3423: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3424: LD_INT 0
3426: PPUSH
3427: PPUSH
3428: PPUSH
3429: PPUSH
3430: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3431: LD_ADDR_VAR 0 6
3435: PUSH
3436: LD_INT 22
3438: PUSH
3439: LD_VAR 0 1
3443: PUSH
3444: EMPTY
3445: LIST
3446: LIST
3447: PUSH
3448: LD_INT 2
3450: PUSH
3451: LD_INT 30
3453: PUSH
3454: LD_INT 31
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 30
3463: PUSH
3464: LD_INT 32
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PUSH
3471: LD_INT 30
3473: PUSH
3474: LD_INT 33
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: PUSH
3481: LD_INT 30
3483: PUSH
3484: LD_INT 4
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PUSH
3491: LD_INT 30
3493: PUSH
3494: LD_INT 5
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: PUSH
3501: EMPTY
3502: LIST
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: LIST
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PPUSH
3513: CALL_OW 69
3517: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3518: LD_ADDR_VAR 0 7
3522: PUSH
3523: LD_INT 22
3525: PUSH
3526: LD_VAR 0 2
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PUSH
3535: LD_INT 21
3537: PUSH
3538: LD_INT 3
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PUSH
3545: LD_INT 58
3547: PUSH
3548: EMPTY
3549: LIST
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: LIST
3555: PPUSH
3556: CALL_OW 69
3560: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3561: LD_VAR 0 6
3565: PUSH
3566: LD_INT 0
3568: GREATER
3569: PUSH
3570: LD_VAR 0 7
3574: PUSH
3575: LD_INT 0
3577: GREATER
3578: AND
3579: IFFALSE 3649
// begin for i in turretsList do
3581: LD_ADDR_VAR 0 4
3585: PUSH
3586: LD_VAR 0 6
3590: PUSH
3591: FOR_IN
3592: IFFALSE 3647
// begin for j in enemyBuildings do
3594: LD_ADDR_VAR 0 5
3598: PUSH
3599: LD_VAR 0 7
3603: PUSH
3604: FOR_IN
3605: IFFALSE 3643
// begin if GetDistUnits ( i , j ) < 20 then
3607: LD_VAR 0 4
3611: PPUSH
3612: LD_VAR 0 5
3616: PPUSH
3617: CALL_OW 296
3621: PUSH
3622: LD_INT 20
3624: LESS
3625: IFFALSE 3641
// begin ComAttackUnit ( i , j ) ;
3627: LD_VAR 0 4
3631: PPUSH
3632: LD_VAR 0 5
3636: PPUSH
3637: CALL_OW 115
// end ; end ;
3641: GO 3604
3643: POP
3644: POP
// end ;
3645: GO 3591
3647: POP
3648: POP
// end ; end ;
3649: LD_VAR 0 3
3653: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3654: LD_INT 0
3656: PPUSH
3657: PPUSH
3658: PPUSH
3659: PPUSH
3660: PPUSH
3661: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3662: LD_ADDR_VAR 0 7
3666: PUSH
3667: LD_INT 22
3669: PUSH
3670: LD_VAR 0 1
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 25
3681: PUSH
3682: LD_INT 9
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PPUSH
3693: CALL_OW 69
3697: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3698: LD_ADDR_VAR 0 8
3702: PUSH
3703: LD_INT 22
3705: PUSH
3706: LD_VAR 0 2
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 3
3717: PUSH
3718: LD_INT 21
3720: PUSH
3721: LD_INT 3
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: PUSH
3732: EMPTY
3733: LIST
3734: LIST
3735: PPUSH
3736: CALL_OW 69
3740: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3741: LD_ADDR_VAR 0 5
3745: PUSH
3746: LD_INT 1
3748: PPUSH
3749: LD_INT 3
3751: PPUSH
3752: CALL_OW 12
3756: ST_TO_ADDR
// for i = 1 to list do
3757: LD_ADDR_VAR 0 6
3761: PUSH
3762: DOUBLE
3763: LD_INT 1
3765: DEC
3766: ST_TO_ADDR
3767: LD_VAR 0 7
3771: PUSH
3772: FOR_TO
3773: IFFALSE 3955
// for ta in filter do
3775: LD_ADDR_VAR 0 4
3779: PUSH
3780: LD_VAR 0 8
3784: PUSH
3785: FOR_IN
3786: IFFALSE 3951
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3788: LD_VAR 0 7
3792: PUSH
3793: LD_VAR 0 6
3797: ARRAY
3798: PPUSH
3799: LD_VAR 0 4
3803: PPUSH
3804: CALL_OW 296
3808: PUSH
3809: LD_INT 13
3811: LESSEQUAL
3812: IFFALSE 3949
// begin case c of 1 :
3814: LD_VAR 0 5
3818: PUSH
3819: LD_INT 1
3821: DOUBLE
3822: EQUAL
3823: IFTRUE 3827
3825: GO 3865
3827: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3828: LD_VAR 0 7
3832: PUSH
3833: LD_VAR 0 6
3837: ARRAY
3838: PPUSH
3839: LD_VAR 0 4
3843: PPUSH
3844: CALL_OW 250
3848: PPUSH
3849: LD_VAR 0 4
3853: PPUSH
3854: CALL_OW 251
3858: PPUSH
3859: CALL_OW 154
3863: GO 3949
3865: LD_INT 2
3867: DOUBLE
3868: EQUAL
3869: IFTRUE 3873
3871: GO 3937
3873: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
3874: LD_VAR 0 7
3878: PUSH
3879: LD_VAR 0 6
3883: ARRAY
3884: PPUSH
3885: LD_VAR 0 4
3889: PPUSH
3890: CALL_OW 250
3894: PUSH
3895: LD_INT 1
3897: NEG
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: CALL_OW 12
3906: PLUS
3907: PPUSH
3908: LD_VAR 0 4
3912: PPUSH
3913: CALL_OW 251
3917: PUSH
3918: LD_INT 1
3920: NEG
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 12
3929: PLUS
3930: PPUSH
3931: CALL_OW 153
3935: GO 3949
3937: LD_INT 3
3939: DOUBLE
3940: EQUAL
3941: IFTRUE 3945
3943: GO 3948
3945: POP
// ; end ;
3946: GO 3949
3948: POP
// end ; end ;
3949: GO 3785
3951: POP
3952: POP
3953: GO 3772
3955: POP
3956: POP
// end ;
3957: LD_VAR 0 3
3961: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
3962: LD_INT 0
3964: PPUSH
3965: PPUSH
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
3970: LD_ADDR_VAR 0 6
3974: PUSH
3975: LD_VAR 0 2
3979: PPUSH
3980: CALL_OW 313
3984: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
3985: LD_ADDR_VAR 0 7
3989: PUSH
3990: LD_INT 22
3992: PUSH
3993: LD_VAR 0 1
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: PUSH
4002: LD_INT 25
4004: PUSH
4005: LD_INT 2
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: PUSH
4012: LD_INT 24
4014: PUSH
4015: LD_INT 1000
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: PUSH
4022: LD_INT 3
4024: PUSH
4025: LD_INT 54
4027: PUSH
4028: EMPTY
4029: LIST
4030: PUSH
4031: EMPTY
4032: LIST
4033: LIST
4034: PUSH
4035: EMPTY
4036: LIST
4037: LIST
4038: LIST
4039: LIST
4040: PPUSH
4041: CALL_OW 69
4045: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: LD_INT 22
4053: PUSH
4054: LD_VAR 0 1
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: PUSH
4063: LD_INT 21
4065: PUSH
4066: LD_INT 3
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: PUSH
4073: LD_INT 3
4075: PUSH
4076: LD_INT 24
4078: PUSH
4079: LD_INT 1000
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: PUSH
4095: EMPTY
4096: LIST
4097: PPUSH
4098: CALL_OW 69
4102: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4103: LD_VAR 0 4
4107: NOT
4108: PUSH
4109: LD_VAR 0 7
4113: NOT
4114: AND
4115: PUSH
4116: LD_EXP 1
4120: NOT
4121: AND
4122: IFFALSE 4126
// exit ;
4124: GO 4245
// if buildings_list > 0 and engineerOkInside then
4126: LD_VAR 0 4
4130: PUSH
4131: LD_INT 0
4133: GREATER
4134: PUSH
4135: LD_VAR 0 6
4139: AND
4140: IFFALSE 4173
// for i in UnitsInside ( building ) do
4142: LD_ADDR_VAR 0 5
4146: PUSH
4147: LD_VAR 0 2
4151: PPUSH
4152: CALL_OW 313
4156: PUSH
4157: FOR_IN
4158: IFFALSE 4171
// ComExitBuilding ( i ) ;
4160: LD_VAR 0 5
4164: PPUSH
4165: CALL_OW 122
4169: GO 4157
4171: POP
4172: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4173: LD_VAR 0 4
4177: PUSH
4178: LD_INT 0
4180: GREATER
4181: PUSH
4182: LD_VAR 0 7
4186: PUSH
4187: LD_INT 0
4189: GREATER
4190: AND
4191: IFFALSE 4245
// begin for i in engineerOkOutside do
4193: LD_ADDR_VAR 0 5
4197: PUSH
4198: LD_VAR 0 7
4202: PUSH
4203: FOR_IN
4204: IFFALSE 4243
// for j in buildings_list do
4206: LD_ADDR_VAR 0 8
4210: PUSH
4211: LD_VAR 0 4
4215: PUSH
4216: FOR_IN
4217: IFFALSE 4239
// ComRepairBuilding ( i , j [ 1 ] ) ;
4219: LD_VAR 0 5
4223: PPUSH
4224: LD_VAR 0 8
4228: PUSH
4229: LD_INT 1
4231: ARRAY
4232: PPUSH
4233: CALL_OW 130
4237: GO 4216
4239: POP
4240: POP
4241: GO 4203
4243: POP
4244: POP
// end ; end ;
4245: LD_VAR 0 3
4249: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4250: LD_INT 0
4252: PPUSH
4253: PPUSH
4254: PPUSH
4255: PPUSH
4256: PPUSH
4257: PPUSH
4258: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4259: LD_ADDR_VAR 0 6
4263: PUSH
4264: LD_INT 22
4266: PUSH
4267: LD_VAR 0 1
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: PUSH
4276: LD_INT 25
4278: PUSH
4279: LD_INT 4
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: PUSH
4286: LD_INT 24
4288: PUSH
4289: LD_INT 251
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: LIST
4300: PPUSH
4301: CALL_OW 69
4305: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4306: LD_ADDR_VAR 0 7
4310: PUSH
4311: LD_VAR 0 3
4315: PPUSH
4316: LD_INT 22
4318: PUSH
4319: LD_VAR 0 1
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 25
4330: PUSH
4331: LD_INT 4
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 50
4340: PUSH
4341: EMPTY
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: LIST
4348: PPUSH
4349: CALL_OW 70
4353: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4354: LD_ADDR_VAR 0 10
4358: PUSH
4359: LD_VAR 0 3
4363: PPUSH
4364: LD_INT 22
4366: PUSH
4367: LD_VAR 0 1
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: LD_INT 21
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 3
4388: PUSH
4389: LD_INT 24
4391: PUSH
4392: LD_INT 750
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: PUSH
4399: EMPTY
4400: LIST
4401: LIST
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: PPUSH
4408: CALL_OW 70
4412: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4413: LD_ADDR_VAR 0 11
4417: PUSH
4418: LD_VAR 0 2
4422: PPUSH
4423: LD_INT 22
4425: PUSH
4426: LD_VAR 0 1
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 21
4437: PUSH
4438: LD_INT 1
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PUSH
4445: LD_INT 3
4447: PUSH
4448: LD_INT 24
4450: PUSH
4451: LD_INT 1000
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: LIST
4466: PPUSH
4467: CALL_OW 70
4471: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
4472: LD_VAR 0 10
4476: NOT
4477: PUSH
4478: LD_VAR 0 7
4482: NOT
4483: AND
4484: PUSH
4485: LD_VAR 0 11
4489: NOT
4490: AND
4491: IFFALSE 4495
// exit ;
4493: GO 4684
// if damageUnits > 0 and sci_list > 0 then
4495: LD_VAR 0 10
4499: PUSH
4500: LD_INT 0
4502: GREATER
4503: PUSH
4504: LD_VAR 0 6
4508: PUSH
4509: LD_INT 0
4511: GREATER
4512: AND
4513: IFFALSE 4546
// for i in damageUnits do
4515: LD_ADDR_VAR 0 8
4519: PUSH
4520: LD_VAR 0 10
4524: PUSH
4525: FOR_IN
4526: IFFALSE 4544
// ComMoveToArea ( i , healArea ) ;
4528: LD_VAR 0 8
4532: PPUSH
4533: LD_VAR 0 2
4537: PPUSH
4538: CALL_OW 113
4542: GO 4525
4544: POP
4545: POP
// if unitsToHeal > 0 and sci_list > 0 then
4546: LD_VAR 0 11
4550: PUSH
4551: LD_INT 0
4553: GREATER
4554: PUSH
4555: LD_VAR 0 6
4559: PUSH
4560: LD_INT 0
4562: GREATER
4563: AND
4564: IFFALSE 4623
// begin for i in sci_list do
4566: LD_ADDR_VAR 0 8
4570: PUSH
4571: LD_VAR 0 6
4575: PUSH
4576: FOR_IN
4577: IFFALSE 4621
// begin ComExitBuilding ( i ) ;
4579: LD_VAR 0 8
4583: PPUSH
4584: CALL_OW 122
// for j in unitsToHeal do
4588: LD_ADDR_VAR 0 9
4592: PUSH
4593: LD_VAR 0 11
4597: PUSH
4598: FOR_IN
4599: IFFALSE 4617
// AddComHeal ( i , j ) ;
4601: LD_VAR 0 8
4605: PPUSH
4606: LD_VAR 0 9
4610: PPUSH
4611: CALL_OW 188
4615: GO 4598
4617: POP
4618: POP
// end ;
4619: GO 4576
4621: POP
4622: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
4623: LD_VAR 0 10
4627: PUSH
4628: LD_INT 0
4630: EQUAL
4631: PUSH
4632: LD_VAR 0 11
4636: PUSH
4637: LD_INT 0
4639: EQUAL
4640: AND
4641: PUSH
4642: LD_VAR 0 7
4646: PUSH
4647: LD_INT 0
4649: GREATER
4650: AND
4651: IFFALSE 4684
// for i in sci_listOutside do
4653: LD_ADDR_VAR 0 8
4657: PUSH
4658: LD_VAR 0 7
4662: PUSH
4663: FOR_IN
4664: IFFALSE 4682
// ComEnterUnit ( i , build ) ;
4666: LD_VAR 0 8
4670: PPUSH
4671: LD_VAR 0 4
4675: PPUSH
4676: CALL_OW 120
4680: GO 4663
4682: POP
4683: POP
// end ; end_of_file
4684: LD_VAR 0 5
4688: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4689: LD_INT 0
4691: PPUSH
4692: PPUSH
// if exist_mode then
4693: LD_VAR 0 2
4697: IFFALSE 4716
// unit := CreateCharacter ( ident ) else
4699: LD_ADDR_VAR 0 4
4703: PUSH
4704: LD_VAR 0 1
4708: PPUSH
4709: CALL_OW 34
4713: ST_TO_ADDR
4714: GO 4731
// unit := NewCharacter ( ident ) ;
4716: LD_ADDR_VAR 0 4
4720: PUSH
4721: LD_VAR 0 1
4725: PPUSH
4726: CALL_OW 25
4730: ST_TO_ADDR
// result := unit ;
4731: LD_ADDR_VAR 0 3
4735: PUSH
4736: LD_VAR 0 4
4740: ST_TO_ADDR
// end ;
4741: LD_VAR 0 3
4745: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4746: LD_INT 0
4748: PPUSH
4749: PPUSH
4750: PPUSH
// uc_side := GetSide ( b ) ;
4751: LD_ADDR_OWVAR 20
4755: PUSH
4756: LD_VAR 0 2
4760: PPUSH
4761: CALL_OW 255
4765: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4766: LD_ADDR_OWVAR 21
4770: PUSH
4771: LD_VAR 0 2
4775: PPUSH
4776: CALL_OW 248
4780: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4781: LD_INT 0
4783: PPUSH
4784: LD_INT 1
4786: PPUSH
4787: LD_VAR 0 1
4791: PPUSH
4792: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4796: LD_ADDR_VAR 0 5
4800: PUSH
4801: LD_VAR 0 2
4805: PPUSH
4806: CALL_OW 254
4810: PUSH
4811: LD_INT 3
4813: MINUS
4814: ST_TO_ADDR
// if dir < 0 then
4815: LD_VAR 0 5
4819: PUSH
4820: LD_INT 0
4822: LESS
4823: IFFALSE 4839
// dir := 6 + dir ;
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_INT 6
4832: PUSH
4833: LD_VAR 0 5
4837: PLUS
4838: ST_TO_ADDR
// un := CreateHuman ;
4839: LD_ADDR_VAR 0 4
4843: PUSH
4844: CALL_OW 44
4848: ST_TO_ADDR
// SetDir ( un , dir ) ;
4849: LD_VAR 0 4
4853: PPUSH
4854: LD_VAR 0 5
4858: PPUSH
4859: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4863: LD_VAR 0 4
4867: PPUSH
4868: LD_VAR 0 2
4872: PPUSH
4873: CALL_OW 52
// end ;
4877: LD_VAR 0 3
4881: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
4882: LD_INT 0
4884: PPUSH
4885: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
4886: LD_ADDR_VAR 0 2
4890: PUSH
4891: LD_VAR 0 1
4895: PPUSH
4896: LD_INT 1
4898: PPUSH
4899: CALL_OW 289
4903: PUSH
4904: LD_VAR 0 1
4908: PPUSH
4909: LD_INT 2
4911: PPUSH
4912: CALL_OW 289
4916: PUSH
4917: LD_VAR 0 1
4921: PPUSH
4922: LD_INT 3
4924: PPUSH
4925: CALL_OW 289
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: LIST
4934: ST_TO_ADDR
// end ;
4935: LD_VAR 0 2
4939: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
4940: LD_INT 0
4942: PPUSH
4943: PPUSH
4944: PPUSH
4945: PPUSH
// r := 100 ;
4946: LD_ADDR_VAR 0 5
4950: PUSH
4951: LD_INT 100
4953: ST_TO_ADDR
// x := 0 ;
4954: LD_ADDR_VAR 0 6
4958: PUSH
4959: LD_INT 0
4961: ST_TO_ADDR
// while ( x < n ) do
4962: LD_VAR 0 6
4966: PUSH
4967: LD_VAR 0 2
4971: LESS
4972: IFFALSE 5285
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
4974: LD_ADDR_VAR 0 4
4978: PUSH
4979: DOUBLE
4980: LD_INT 1
4982: DEC
4983: ST_TO_ADDR
4984: LD_VAR 0 1
4988: PPUSH
4989: LD_INT 0
4991: PPUSH
4992: CALL_OW 517
4996: PUSH
4997: LD_INT 1
4999: ARRAY
5000: PUSH
5001: FOR_TO
5002: IFFALSE 5281
// begin if r > 50 then
5004: LD_VAR 0 5
5008: PUSH
5009: LD_INT 50
5011: GREATER
5012: IFFALSE 5257
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
5014: LD_VAR 0 1
5018: PPUSH
5019: LD_INT 0
5021: PPUSH
5022: CALL_OW 517
5026: PUSH
5027: LD_INT 1
5029: ARRAY
5030: PUSH
5031: LD_VAR 0 4
5035: ARRAY
5036: PPUSH
5037: LD_VAR 0 1
5041: PPUSH
5042: LD_INT 0
5044: PPUSH
5045: CALL_OW 517
5049: PUSH
5050: LD_INT 2
5052: ARRAY
5053: PUSH
5054: LD_VAR 0 4
5058: ARRAY
5059: PPUSH
5060: CALL_OW 458
5064: NOT
5065: IFFALSE 5241
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , 2 , 0 ) ;
5067: LD_VAR 0 1
5071: PPUSH
5072: LD_INT 0
5074: PPUSH
5075: CALL_OW 517
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PUSH
5084: LD_VAR 0 4
5088: ARRAY
5089: PPUSH
5090: LD_VAR 0 1
5094: PPUSH
5095: LD_INT 0
5097: PPUSH
5098: CALL_OW 517
5102: PUSH
5103: LD_INT 2
5105: ARRAY
5106: PUSH
5107: LD_VAR 0 4
5111: ARRAY
5112: PPUSH
5113: LD_INT 2
5115: PPUSH
5116: LD_INT 0
5118: PPUSH
5119: CALL_OW 454
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
5123: LD_ADDR_EXP 4
5127: PUSH
5128: LD_EXP 4
5132: PPUSH
5133: LD_EXP 4
5137: PUSH
5138: LD_INT 1
5140: PLUS
5141: PPUSH
5142: LD_VAR 0 1
5146: PPUSH
5147: LD_INT 0
5149: PPUSH
5150: CALL_OW 517
5154: PUSH
5155: LD_INT 1
5157: ARRAY
5158: PUSH
5159: LD_VAR 0 4
5163: ARRAY
5164: PPUSH
5165: CALL_OW 2
5169: ST_TO_ADDR
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
5170: LD_ADDR_EXP 4
5174: PUSH
5175: LD_EXP 4
5179: PPUSH
5180: LD_EXP 4
5184: PUSH
5185: LD_INT 1
5187: PLUS
5188: PPUSH
5189: LD_VAR 0 1
5193: PPUSH
5194: LD_INT 0
5196: PPUSH
5197: CALL_OW 517
5201: PUSH
5202: LD_INT 2
5204: ARRAY
5205: PUSH
5206: LD_VAR 0 4
5210: ARRAY
5211: PPUSH
5212: CALL_OW 2
5216: ST_TO_ADDR
// r := 0 ;
5217: LD_ADDR_VAR 0 5
5221: PUSH
5222: LD_INT 0
5224: ST_TO_ADDR
// x := x + 1 ;
5225: LD_ADDR_VAR 0 6
5229: PUSH
5230: LD_VAR 0 6
5234: PUSH
5235: LD_INT 1
5237: PLUS
5238: ST_TO_ADDR
// end else
5239: GO 5255
// r := r + 35 ;
5241: LD_ADDR_VAR 0 5
5245: PUSH
5246: LD_VAR 0 5
5250: PUSH
5251: LD_INT 35
5253: PLUS
5254: ST_TO_ADDR
// end else
5255: GO 5279
// r := r + rand ( 10 , 25 ) ;
5257: LD_ADDR_VAR 0 5
5261: PUSH
5262: LD_VAR 0 5
5266: PUSH
5267: LD_INT 10
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 12
5277: PLUS
5278: ST_TO_ADDR
// end ;
5279: GO 5001
5281: POP
5282: POP
5283: GO 4962
// end ; end_of_file
5285: LD_VAR 0 3
5289: RET
// on UnitDestroyed ( un ) do var i ;
5290: LD_INT 0
5292: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5293: LD_VAR 0 1
5297: PPUSH
5298: CALL_OW 255
5302: PUSH
5303: LD_INT 3
5305: EQUAL
5306: PUSH
5307: LD_VAR 0 1
5311: PPUSH
5312: CALL_OW 247
5316: PUSH
5317: LD_INT 3
5319: EQUAL
5320: AND
5321: IFFALSE 6013
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5323: LD_VAR 0 1
5327: PPUSH
5328: CALL_OW 266
5332: PUSH
5333: LD_INT 31
5335: EQUAL
5336: PUSH
5337: LD_VAR 0 1
5341: PPUSH
5342: CALL_OW 266
5346: PUSH
5347: LD_INT 32
5349: EQUAL
5350: OR
5351: PUSH
5352: LD_VAR 0 1
5356: PPUSH
5357: CALL_OW 266
5361: PUSH
5362: LD_INT 36
5364: EQUAL
5365: OR
5366: PUSH
5367: LD_VAR 0 1
5371: PPUSH
5372: CALL_OW 266
5376: PUSH
5377: LD_INT 0
5379: EQUAL
5380: OR
5381: PUSH
5382: LD_VAR 0 1
5386: PPUSH
5387: CALL_OW 266
5391: PUSH
5392: LD_INT 24
5394: EQUAL
5395: OR
5396: PUSH
5397: LD_VAR 0 1
5401: PPUSH
5402: CALL_OW 266
5406: PUSH
5407: LD_INT 17
5409: EQUAL
5410: OR
5411: PUSH
5412: LD_VAR 0 1
5416: PPUSH
5417: CALL_OW 266
5421: PUSH
5422: LD_INT 25
5424: EQUAL
5425: OR
5426: PUSH
5427: LD_VAR 0 1
5431: PPUSH
5432: CALL_OW 266
5436: PUSH
5437: LD_INT 19
5439: EQUAL
5440: OR
5441: PUSH
5442: LD_VAR 0 1
5446: PPUSH
5447: CALL_OW 266
5451: PUSH
5452: LD_INT 20
5454: EQUAL
5455: OR
5456: PUSH
5457: LD_VAR 0 1
5461: PPUSH
5462: CALL_OW 266
5466: PUSH
5467: LD_INT 18
5469: EQUAL
5470: OR
5471: PUSH
5472: LD_VAR 0 1
5476: PPUSH
5477: CALL_OW 266
5481: PUSH
5482: LD_INT 21
5484: EQUAL
5485: OR
5486: PUSH
5487: LD_VAR 0 1
5491: PPUSH
5492: CALL_OW 266
5496: PUSH
5497: LD_INT 23
5499: EQUAL
5500: OR
5501: PUSH
5502: LD_VAR 0 1
5506: PPUSH
5507: CALL_OW 266
5511: PUSH
5512: LD_INT 16
5514: EQUAL
5515: OR
5516: PUSH
5517: LD_VAR 0 1
5521: PPUSH
5522: CALL_OW 266
5526: PUSH
5527: LD_INT 6
5529: EQUAL
5530: OR
5531: PUSH
5532: LD_VAR 0 1
5536: PPUSH
5537: CALL_OW 266
5541: PUSH
5542: LD_INT 29
5544: EQUAL
5545: OR
5546: PUSH
5547: LD_VAR 0 1
5551: PPUSH
5552: CALL_OW 266
5556: PUSH
5557: LD_INT 26
5559: EQUAL
5560: OR
5561: PUSH
5562: LD_VAR 0 1
5566: PPUSH
5567: CALL_OW 266
5571: PUSH
5572: LD_INT 30
5574: EQUAL
5575: OR
5576: PUSH
5577: LD_VAR 0 1
5581: PPUSH
5582: CALL_OW 266
5586: PUSH
5587: LD_INT 28
5589: EQUAL
5590: OR
5591: PUSH
5592: LD_VAR 0 1
5596: PPUSH
5597: CALL_OW 266
5601: PUSH
5602: LD_INT 27
5604: EQUAL
5605: OR
5606: PUSH
5607: LD_VAR 0 1
5611: PPUSH
5612: CALL_OW 266
5616: PUSH
5617: LD_INT 33
5619: EQUAL
5620: OR
5621: PUSH
5622: LD_VAR 0 1
5626: PPUSH
5627: CALL_OW 266
5631: PUSH
5632: LD_INT 2
5634: EQUAL
5635: OR
5636: PUSH
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 266
5646: PUSH
5647: LD_INT 4
5649: EQUAL
5650: OR
5651: IFFALSE 5737
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
5653: LD_ADDR_EXP 1
5657: PUSH
5658: LD_EXP 1
5662: PUSH
5663: LD_VAR 0 1
5667: PPUSH
5668: CALL_OW 266
5672: ADD
5673: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
5674: LD_ADDR_EXP 1
5678: PUSH
5679: LD_EXP 1
5683: PUSH
5684: LD_VAR 0 1
5688: PPUSH
5689: CALL_OW 250
5693: ADD
5694: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
5695: LD_ADDR_EXP 1
5699: PUSH
5700: LD_EXP 1
5704: PUSH
5705: LD_VAR 0 1
5709: PPUSH
5710: CALL_OW 251
5714: ADD
5715: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
5716: LD_ADDR_EXP 1
5720: PUSH
5721: LD_EXP 1
5725: PUSH
5726: LD_VAR 0 1
5730: PPUSH
5731: CALL_OW 254
5735: ADD
5736: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
5737: LD_VAR 0 1
5741: PPUSH
5742: CALL_OW 266
5746: PUSH
5747: LD_INT 1
5749: EQUAL
5750: IFFALSE 5829
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
5752: LD_ADDR_EXP 1
5756: PUSH
5757: LD_EXP 1
5761: PUSH
5762: LD_INT 0
5764: ADD
5765: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
5766: LD_ADDR_EXP 1
5770: PUSH
5771: LD_EXP 1
5775: PUSH
5776: LD_VAR 0 1
5780: PPUSH
5781: CALL_OW 250
5785: ADD
5786: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
5787: LD_ADDR_EXP 1
5791: PUSH
5792: LD_EXP 1
5796: PUSH
5797: LD_VAR 0 1
5801: PPUSH
5802: CALL_OW 251
5806: ADD
5807: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
5808: LD_ADDR_EXP 1
5812: PUSH
5813: LD_EXP 1
5817: PUSH
5818: LD_VAR 0 1
5822: PPUSH
5823: CALL_OW 254
5827: ADD
5828: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
5829: LD_VAR 0 1
5833: PPUSH
5834: CALL_OW 266
5838: PUSH
5839: LD_INT 3
5841: EQUAL
5842: IFFALSE 5921
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
5844: LD_ADDR_EXP 1
5848: PUSH
5849: LD_EXP 1
5853: PUSH
5854: LD_INT 2
5856: ADD
5857: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
5858: LD_ADDR_EXP 1
5862: PUSH
5863: LD_EXP 1
5867: PUSH
5868: LD_VAR 0 1
5872: PPUSH
5873: CALL_OW 250
5877: ADD
5878: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
5879: LD_ADDR_EXP 1
5883: PUSH
5884: LD_EXP 1
5888: PUSH
5889: LD_VAR 0 1
5893: PPUSH
5894: CALL_OW 251
5898: ADD
5899: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
5900: LD_ADDR_EXP 1
5904: PUSH
5905: LD_EXP 1
5909: PUSH
5910: LD_VAR 0 1
5914: PPUSH
5915: CALL_OW 254
5919: ADD
5920: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
5921: LD_VAR 0 1
5925: PPUSH
5926: CALL_OW 266
5930: PUSH
5931: LD_INT 5
5933: EQUAL
5934: IFFALSE 6013
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
5936: LD_ADDR_EXP 1
5940: PUSH
5941: LD_EXP 1
5945: PUSH
5946: LD_INT 4
5948: ADD
5949: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
5950: LD_ADDR_EXP 1
5954: PUSH
5955: LD_EXP 1
5959: PUSH
5960: LD_VAR 0 1
5964: PPUSH
5965: CALL_OW 250
5969: ADD
5970: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
5971: LD_ADDR_EXP 1
5975: PUSH
5976: LD_EXP 1
5980: PUSH
5981: LD_VAR 0 1
5985: PPUSH
5986: CALL_OW 251
5990: ADD
5991: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
5992: LD_ADDR_EXP 1
5996: PUSH
5997: LD_EXP 1
6001: PUSH
6002: LD_VAR 0 1
6006: PPUSH
6007: CALL_OW 254
6011: ADD
6012: ST_TO_ADDR
// end ; end ; end ;
6013: PPOPN 2
6015: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6016: LD_VAR 0 1
6020: PPUSH
6021: CALL_OW 255
6025: PUSH
6026: LD_INT 3
6028: EQUAL
6029: IFFALSE 6103
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6031: LD_ADDR_EXP 1
6035: PUSH
6036: LD_EXP 1
6040: PPUSH
6041: LD_INT 1
6043: PPUSH
6044: CALL_OW 3
6048: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6049: LD_ADDR_EXP 1
6053: PUSH
6054: LD_EXP 1
6058: PPUSH
6059: LD_INT 1
6061: PPUSH
6062: CALL_OW 3
6066: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6067: LD_ADDR_EXP 1
6071: PUSH
6072: LD_EXP 1
6076: PPUSH
6077: LD_INT 1
6079: PPUSH
6080: CALL_OW 3
6084: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6085: LD_ADDR_EXP 1
6089: PUSH
6090: LD_EXP 1
6094: PPUSH
6095: LD_INT 1
6097: PPUSH
6098: CALL_OW 3
6102: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6103: LD_VAR 0 1
6107: PPUSH
6108: CALL_OW 255
6112: PUSH
6113: LD_INT 3
6115: EQUAL
6116: PUSH
6117: LD_VAR 0 1
6121: PPUSH
6122: CALL_OW 266
6126: PUSH
6127: LD_INT 0
6129: EQUAL
6130: PUSH
6131: LD_VAR 0 1
6135: PPUSH
6136: CALL_OW 266
6140: PUSH
6141: LD_INT 2
6143: EQUAL
6144: OR
6145: PUSH
6146: LD_VAR 0 1
6150: PPUSH
6151: CALL_OW 266
6155: PUSH
6156: LD_INT 4
6158: EQUAL
6159: OR
6160: PUSH
6161: EMPTY
6162: LIST
6163: AND
6164: IFFALSE 6175
// ComUpgrade ( building ) ;
6166: LD_VAR 0 1
6170: PPUSH
6171: CALL_OW 146
// end ;
6175: PPOPN 1
6177: END
// on LeaveVehicle ( vehicle , human ) do begin ComRepairVehicle ( human , vehicle ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_VAR 0 1
6187: PPUSH
6188: CALL_OW 129
// AddComEnterUnit ( human , vehicle ) ;
6192: LD_VAR 0 2
6196: PPUSH
6197: LD_VAR 0 1
6201: PPUSH
6202: CALL_OW 180
// end ;
6206: PPOPN 2
6208: END
// on VehicleConstructed ( vehicle , building ) do begin end ;
6209: PPOPN 2
6211: END
// on Command ( command_id ) do begin end ;
6212: PPOPN 1
6214: END
