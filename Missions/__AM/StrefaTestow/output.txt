// export destroyedBuildings ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// FogOff ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 344
// RandomizeAll ;
  11: CALL_OW 11
// destroyedBuildings = [ ] ;
  15: LD_ADDR_EXP 1
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// end ;
  22: END
// every 0 0$1 do
  23: GO 25
  25: DISABLE
// ComEnterUnit ( eng1 , ee1 ) ; end_of_file
  26: LD_INT 95
  28: PPUSH
  29: LD_INT 94
  31: PPUSH
  32: CALL_OW 120
  36: END
// every 0 0$1 do
  37: GO 39
  39: DISABLE
// begin enable ;
  40: ENABLE
// RepairVehicle ( 3 , EnemyVehSpawn , 89 , 7 ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 2
  46: PPUSH
  47: LD_INT 89
  49: PPUSH
  50: LD_INT 7
  52: PPUSH
  53: CALL 2603 0 4
// RebuildBuildings ( 3 , destroyedBuildings ) ;
  57: LD_INT 3
  59: PPUSH
  60: LD_EXP 1
  64: PPUSH
  65: CALL 3268 0 2
// EnemyVehicleAttack ( 3 , 1 ) ;
  69: LD_INT 3
  71: PPUSH
  72: LD_INT 1
  74: PPUSH
  75: CALL 2245 0 2
// IntBazooka ( 3 , 1 ) ;
  79: LD_INT 3
  81: PPUSH
  82: LD_INT 1
  84: PPUSH
  85: CALL 3704 0 2
// end ;
  89: END
// every 5 5$1 do
  90: GO 92
  92: DISABLE
// begin BuildingVehicleAndAttackEnemy ( 3 , rufab , 4 , [ 42 ] , 1 , 1 , 23 ) ;
  93: LD_INT 3
  95: PPUSH
  96: LD_INT 30
  98: PPUSH
  99: LD_INT 4
 101: PPUSH
 102: LD_INT 42
 104: PUSH
 105: EMPTY
 106: LIST
 107: PPUSH
 108: LD_INT 1
 110: PPUSH
 111: LD_INT 1
 113: PPUSH
 114: LD_INT 23
 116: PPUSH
 117: CALL 2133 0 7
// end ; end_of_file
 121: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 122: LD_INT 0
 124: PPUSH
 125: PPUSH
 126: PPUSH
// rnd = rand ( 1 , characters ) ;
 127: LD_ADDR_VAR 0 6
 131: PUSH
 132: LD_INT 1
 134: PPUSH
 135: LD_VAR 0 1
 139: PPUSH
 140: CALL_OW 12
 144: ST_TO_ADDR
// for i = 1 to characters do
 145: LD_ADDR_VAR 0 5
 149: PUSH
 150: DOUBLE
 151: LD_INT 1
 153: DEC
 154: ST_TO_ADDR
 155: LD_VAR 0 1
 159: PUSH
 160: FOR_TO
 161: IFFALSE 271
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 163: LD_VAR 0 5
 167: PUSH
 168: LD_VAR 0 6
 172: EQUAL
 173: PUSH
 174: LD_VAR 0 1
 178: PUSH
 179: LD_VAR 0 5
 183: ARRAY
 184: PPUSH
 185: CALL_OW 258
 189: PUSH
 190: LD_INT 1
 192: EQUAL
 193: AND
 194: IFFALSE 216
// Say ( characters [ i ] , dialogMID ) ;
 196: LD_VAR 0 1
 200: PUSH
 201: LD_VAR 0 5
 205: ARRAY
 206: PPUSH
 207: LD_VAR 0 2
 211: PPUSH
 212: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 216: LD_VAR 0 5
 220: PUSH
 221: LD_VAR 0 6
 225: EQUAL
 226: PUSH
 227: LD_VAR 0 1
 231: PUSH
 232: LD_VAR 0 5
 236: ARRAY
 237: PPUSH
 238: CALL_OW 258
 242: PUSH
 243: LD_INT 2
 245: EQUAL
 246: AND
 247: IFFALSE 269
// Say ( characters [ i ] , dialogFID ) ;
 249: LD_VAR 0 1
 253: PUSH
 254: LD_VAR 0 5
 258: ARRAY
 259: PPUSH
 260: LD_VAR 0 3
 264: PPUSH
 265: CALL_OW 88
// end ;
 269: GO 160
 271: POP
 272: POP
// end ;
 273: LD_VAR 0 4
 277: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 278: LD_INT 0
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
// for i = 1 to count do
 284: LD_ADDR_VAR 0 8
 288: PUSH
 289: DOUBLE
 290: LD_INT 1
 292: DEC
 293: ST_TO_ADDR
 294: LD_VAR 0 6
 298: PUSH
 299: FOR_TO
 300: IFFALSE 381
// begin uc_side = side ;
 302: LD_ADDR_OWVAR 20
 306: PUSH
 307: LD_VAR 0 1
 311: ST_TO_ADDR
// uc_nation = nation ;
 312: LD_ADDR_OWVAR 21
 316: PUSH
 317: LD_VAR 0 2
 321: ST_TO_ADDR
// hc_gallery =  ;
 322: LD_ADDR_OWVAR 33
 326: PUSH
 327: LD_STRING 
 329: ST_TO_ADDR
// hc_name =  ;
 330: LD_ADDR_OWVAR 26
 334: PUSH
 335: LD_STRING 
 337: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 338: LD_INT 0
 340: PPUSH
 341: LD_VAR 0 5
 345: PPUSH
 346: LD_VAR 0 4
 350: PPUSH
 351: CALL_OW 380
// un = CreateHuman ;
 355: LD_ADDR_VAR 0 10
 359: PUSH
 360: CALL_OW 44
 364: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 365: LD_VAR 0 10
 369: PPUSH
 370: LD_VAR 0 3
 374: PPUSH
 375: CALL_OW 52
// end ;
 379: GO 299
 381: POP
 382: POP
// end ;
 383: LD_VAR 0 7
 387: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 388: LD_INT 0
 390: PPUSH
 391: PPUSH
// for i in charactersList do
 392: LD_ADDR_VAR 0 4
 396: PUSH
 397: LD_VAR 0 1
 401: PUSH
 402: FOR_IN
 403: IFFALSE 443
// begin if IsOk ( i ) then
 405: LD_VAR 0 4
 409: PPUSH
 410: CALL_OW 302
 414: IFFALSE 432
// begin SaveCharacters ( i , ident ) ;
 416: LD_VAR 0 4
 420: PPUSH
 421: LD_VAR 0 2
 425: PPUSH
 426: CALL_OW 38
// end else
 430: GO 441
// begin DeleteCharacters ( ident ) ;
 432: LD_VAR 0 2
 436: PPUSH
 437: CALL_OW 40
// end ; end ;
 441: GO 402
 443: POP
 444: POP
// end ;
 445: LD_VAR 0 3
 449: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon , targetSide ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 450: LD_INT 0
 452: PPUSH
 453: PPUSH
 454: PPUSH
 455: PPUSH
 456: PPUSH
 457: PPUSH
 458: PPUSH
 459: PPUSH
 460: PPUSH
 461: PPUSH
 462: PPUSH
// amChassisTab = [ ] ;
 463: LD_ADDR_VAR 0 19
 467: PUSH
 468: EMPTY
 469: ST_TO_ADDR
// arChassisTab = [ ] ;
 470: LD_ADDR_VAR 0 18
 474: PUSH
 475: EMPTY
 476: ST_TO_ADDR
// ruChassisTab = [ ] ;
 477: LD_ADDR_VAR 0 17
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
 484: LD_INT 35
 486: PPUSH
 487: CALL_OW 67
// if nation = 1 then
 491: LD_VAR 0 5
 495: PUSH
 496: LD_INT 1
 498: EQUAL
 499: IFFALSE 990
// begin uc_side = side ;
 501: LD_ADDR_OWVAR 20
 505: PUSH
 506: LD_VAR 0 2
 510: ST_TO_ADDR
// uc_nation = nation ;
 511: LD_ADDR_OWVAR 21
 515: PUSH
 516: LD_VAR 0 5
 520: ST_TO_ADDR
// vc_engine = vehengine ;
 521: LD_ADDR_OWVAR 39
 525: PUSH
 526: LD_VAR 0 6
 530: ST_TO_ADDR
// vc_control = vehcontrol ;
 531: LD_ADDR_OWVAR 38
 535: PUSH
 536: LD_VAR 0 7
 540: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
 541: LD_ADDR_OWVAR 40
 545: PUSH
 546: LD_VAR 0 10
 550: PUSH
 551: LD_INT 1
 553: PPUSH
 554: LD_VAR 0 10
 558: PPUSH
 559: CALL_OW 12
 563: ARRAY
 564: ST_TO_ADDR
// for j = 1 to AMWeapon do
 565: LD_ADDR_VAR 0 14
 569: PUSH
 570: DOUBLE
 571: LD_INT 1
 573: DEC
 574: ST_TO_ADDR
 575: LD_VAR 0 10
 579: PUSH
 580: FOR_TO
 581: IFFALSE 882
// begin if AMWeapon [ j ] = 2 or AMWeapon [ j ] = 3 then
 583: LD_VAR 0 10
 587: PUSH
 588: LD_VAR 0 14
 592: ARRAY
 593: PUSH
 594: LD_INT 2
 596: EQUAL
 597: PUSH
 598: LD_VAR 0 10
 602: PUSH
 603: LD_VAR 0 14
 607: ARRAY
 608: PUSH
 609: LD_INT 3
 611: EQUAL
 612: OR
 613: IFFALSE 666
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
 615: LD_ADDR_VAR 0 19
 619: PUSH
 620: LD_INT 1
 622: PUSH
 623: LD_INT 2
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 4
 631: PUSH
 632: LD_INT 5
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 642: LD_ADDR_OWVAR 37
 646: PUSH
 647: LD_VAR 0 19
 651: PUSH
 652: LD_INT 1
 654: PPUSH
 655: LD_VAR 0 19
 659: PPUSH
 660: CALL_OW 12
 664: ARRAY
 665: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 4 or AMWeapon [ j ] = 5 or AMWeapon [ j ] = 9 or AMWeapon [ j ] = 11 or AMWeapon [ j ] = 7 then
 666: LD_VAR 0 10
 670: PUSH
 671: LD_VAR 0 14
 675: ARRAY
 676: PUSH
 677: LD_INT 4
 679: EQUAL
 680: PUSH
 681: LD_VAR 0 10
 685: PUSH
 686: LD_VAR 0 14
 690: ARRAY
 691: PUSH
 692: LD_INT 5
 694: EQUAL
 695: OR
 696: PUSH
 697: LD_VAR 0 10
 701: PUSH
 702: LD_VAR 0 14
 706: ARRAY
 707: PUSH
 708: LD_INT 9
 710: EQUAL
 711: OR
 712: PUSH
 713: LD_VAR 0 10
 717: PUSH
 718: LD_VAR 0 14
 722: ARRAY
 723: PUSH
 724: LD_INT 11
 726: EQUAL
 727: OR
 728: PUSH
 729: LD_VAR 0 10
 733: PUSH
 734: LD_VAR 0 14
 738: ARRAY
 739: PUSH
 740: LD_INT 7
 742: EQUAL
 743: OR
 744: IFFALSE 793
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
 746: LD_ADDR_VAR 0 19
 750: PUSH
 751: LD_INT 2
 753: PUSH
 754: LD_INT 3
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 5
 762: PUSH
 763: EMPTY
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 769: LD_ADDR_OWVAR 37
 773: PUSH
 774: LD_VAR 0 19
 778: PUSH
 779: LD_INT 1
 781: PPUSH
 782: LD_VAR 0 19
 786: PPUSH
 787: CALL_OW 12
 791: ARRAY
 792: ST_TO_ADDR
// end ; if AMWeapon [ j ] = 8 or AMWeapon [ j ] = 6 or AMWeapon [ j ] = 10 then
 793: LD_VAR 0 10
 797: PUSH
 798: LD_VAR 0 14
 802: ARRAY
 803: PUSH
 804: LD_INT 8
 806: EQUAL
 807: PUSH
 808: LD_VAR 0 10
 812: PUSH
 813: LD_VAR 0 14
 817: ARRAY
 818: PUSH
 819: LD_INT 6
 821: EQUAL
 822: OR
 823: PUSH
 824: LD_VAR 0 10
 828: PUSH
 829: LD_VAR 0 14
 833: ARRAY
 834: PUSH
 835: LD_INT 10
 837: EQUAL
 838: OR
 839: IFFALSE 880
// begin amChassisTab = [ 4 , 5 ] ;
 841: LD_ADDR_VAR 0 19
 845: PUSH
 846: LD_INT 4
 848: PUSH
 849: LD_INT 5
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
 856: LD_ADDR_OWVAR 37
 860: PUSH
 861: LD_VAR 0 19
 865: PUSH
 866: LD_INT 1
 868: PPUSH
 869: LD_VAR 0 19
 873: PPUSH
 874: CALL_OW 12
 878: ARRAY
 879: ST_TO_ADDR
// end ; end ;
 880: GO 580
 882: POP
 883: POP
// veh = CreateVehicle ;
 884: LD_ADDR_VAR 0 16
 888: PUSH
 889: CALL_OW 45
 893: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
 894: LD_VAR 0 16
 898: PPUSH
 899: LD_VAR 0 1
 903: PPUSH
 904: LD_INT 0
 906: PPUSH
 907: CALL_OW 49
// if vehControl = 1 then
 911: LD_VAR 0 7
 915: PUSH
 916: LD_INT 1
 918: EQUAL
 919: IFFALSE 976
// begin hc_gallery =  ;
 921: LD_ADDR_OWVAR 33
 925: PUSH
 926: LD_STRING 
 928: ST_TO_ADDR
// hc_name =  ;
 929: LD_ADDR_OWVAR 26
 933: PUSH
 934: LD_STRING 
 936: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
 937: LD_INT 0
 939: PPUSH
 940: LD_INT 3
 942: PPUSH
 943: LD_VAR 0 4
 947: PPUSH
 948: CALL_OW 380
// un = CreateHuman ;
 952: LD_ADDR_VAR 0 15
 956: PUSH
 957: CALL_OW 44
 961: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
 962: LD_VAR 0 15
 966: PPUSH
 967: LD_VAR 0 16
 971: PPUSH
 972: CALL_OW 52
// end ; i = i + 1 ;
 976: LD_ADDR_VAR 0 13
 980: PUSH
 981: LD_VAR 0 13
 985: PUSH
 986: LD_INT 1
 988: PLUS
 989: ST_TO_ADDR
// end ; if nation = 2 then
 990: LD_VAR 0 5
 994: PUSH
 995: LD_INT 2
 997: EQUAL
 998: IFFALSE 1422
// begin uc_side = side ;
1000: LD_ADDR_OWVAR 20
1004: PUSH
1005: LD_VAR 0 2
1009: ST_TO_ADDR
// uc_nation = nation ;
1010: LD_ADDR_OWVAR 21
1014: PUSH
1015: LD_VAR 0 5
1019: ST_TO_ADDR
// vc_engine = vehengine ;
1020: LD_ADDR_OWVAR 39
1024: PUSH
1025: LD_VAR 0 6
1029: ST_TO_ADDR
// vc_control = vehcontrol ;
1030: LD_ADDR_OWVAR 38
1034: PUSH
1035: LD_VAR 0 7
1039: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1040: LD_ADDR_OWVAR 40
1044: PUSH
1045: LD_VAR 0 9
1049: PUSH
1050: LD_INT 1
1052: PPUSH
1053: LD_VAR 0 9
1057: PPUSH
1058: CALL_OW 12
1062: ARRAY
1063: ST_TO_ADDR
// for j = 1 to ARWeapons do
1064: LD_ADDR_VAR 0 14
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 9
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1314
// begin if ARWeapons [ j ] = 24 or ARWeapons [ j ] = 22 or ARWeapons [ j ] = 23 or ARWeapons [ j ] = 30 then
1082: LD_VAR 0 9
1086: PUSH
1087: LD_VAR 0 14
1091: ARRAY
1092: PUSH
1093: LD_INT 24
1095: EQUAL
1096: PUSH
1097: LD_VAR 0 9
1101: PUSH
1102: LD_VAR 0 14
1106: ARRAY
1107: PUSH
1108: LD_INT 22
1110: EQUAL
1111: OR
1112: PUSH
1113: LD_VAR 0 9
1117: PUSH
1118: LD_VAR 0 14
1122: ARRAY
1123: PUSH
1124: LD_INT 23
1126: EQUAL
1127: OR
1128: PUSH
1129: LD_VAR 0 9
1133: PUSH
1134: LD_VAR 0 14
1138: ARRAY
1139: PUSH
1140: LD_INT 30
1142: EQUAL
1143: OR
1144: IFFALSE 1193
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1146: LD_ADDR_VAR 0 18
1150: PUSH
1151: LD_INT 11
1153: PUSH
1154: LD_INT 12
1156: PUSH
1157: LD_INT 13
1159: PUSH
1160: LD_INT 14
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1169: LD_ADDR_OWVAR 37
1173: PUSH
1174: LD_VAR 0 18
1178: PUSH
1179: LD_INT 1
1181: PPUSH
1182: LD_VAR 0 18
1186: PPUSH
1187: CALL_OW 12
1191: ARRAY
1192: ST_TO_ADDR
// end ; if ARWeapons [ j ] = 29 or ARWeapons [ j ] = 28 or ARWeapons [ j ] = 27 or ARWeapons [ j ] = 26 or ARWeapons [ j ] = 25 then
1193: LD_VAR 0 9
1197: PUSH
1198: LD_VAR 0 14
1202: ARRAY
1203: PUSH
1204: LD_INT 29
1206: EQUAL
1207: PUSH
1208: LD_VAR 0 9
1212: PUSH
1213: LD_VAR 0 14
1217: ARRAY
1218: PUSH
1219: LD_INT 28
1221: EQUAL
1222: OR
1223: PUSH
1224: LD_VAR 0 9
1228: PUSH
1229: LD_VAR 0 14
1233: ARRAY
1234: PUSH
1235: LD_INT 27
1237: EQUAL
1238: OR
1239: PUSH
1240: LD_VAR 0 9
1244: PUSH
1245: LD_VAR 0 14
1249: ARRAY
1250: PUSH
1251: LD_INT 26
1253: EQUAL
1254: OR
1255: PUSH
1256: LD_VAR 0 9
1260: PUSH
1261: LD_VAR 0 14
1265: ARRAY
1266: PUSH
1267: LD_INT 25
1269: EQUAL
1270: OR
1271: IFFALSE 1312
// begin arChassisTab = [ 13 , 14 ] ;
1273: LD_ADDR_VAR 0 18
1277: PUSH
1278: LD_INT 13
1280: PUSH
1281: LD_INT 14
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1288: LD_ADDR_OWVAR 37
1292: PUSH
1293: LD_VAR 0 18
1297: PUSH
1298: LD_INT 1
1300: PPUSH
1301: LD_VAR 0 18
1305: PPUSH
1306: CALL_OW 12
1310: ARRAY
1311: ST_TO_ADDR
// end ; end ;
1312: GO 1079
1314: POP
1315: POP
// veh = CreateVehicle ;
1316: LD_ADDR_VAR 0 16
1320: PUSH
1321: CALL_OW 45
1325: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1326: LD_VAR 0 16
1330: PPUSH
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 0
1338: PPUSH
1339: CALL_OW 49
// if vehcontrol = 1 then
1343: LD_VAR 0 7
1347: PUSH
1348: LD_INT 1
1350: EQUAL
1351: IFFALSE 1408
// begin hc_gallery =  ;
1353: LD_ADDR_OWVAR 33
1357: PUSH
1358: LD_STRING 
1360: ST_TO_ADDR
// hc_name =  ;
1361: LD_ADDR_OWVAR 26
1365: PUSH
1366: LD_STRING 
1368: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1369: LD_INT 0
1371: PPUSH
1372: LD_INT 3
1374: PPUSH
1375: LD_VAR 0 4
1379: PPUSH
1380: CALL_OW 380
// un = CreateHuman ;
1384: LD_ADDR_VAR 0 15
1388: PUSH
1389: CALL_OW 44
1393: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1394: LD_VAR 0 15
1398: PPUSH
1399: LD_VAR 0 16
1403: PPUSH
1404: CALL_OW 52
// end ; i = i + 1 ;
1408: LD_ADDR_VAR 0 13
1412: PUSH
1413: LD_VAR 0 13
1417: PUSH
1418: LD_INT 1
1420: PLUS
1421: ST_TO_ADDR
// end ; if nation = 3 then
1422: LD_VAR 0 5
1426: PUSH
1427: LD_INT 3
1429: EQUAL
1430: IFFALSE 1822
// begin uc_side = side ;
1432: LD_ADDR_OWVAR 20
1436: PUSH
1437: LD_VAR 0 2
1441: ST_TO_ADDR
// uc_nation = nation ;
1442: LD_ADDR_OWVAR 21
1446: PUSH
1447: LD_VAR 0 5
1451: ST_TO_ADDR
// vc_engine = vehengine ;
1452: LD_ADDR_OWVAR 39
1456: PUSH
1457: LD_VAR 0 6
1461: ST_TO_ADDR
// vc_control = vehcontrol ;
1462: LD_ADDR_OWVAR 38
1466: PUSH
1467: LD_VAR 0 7
1471: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1472: LD_ADDR_OWVAR 40
1476: PUSH
1477: LD_VAR 0 8
1481: PUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 8
1489: PPUSH
1490: CALL_OW 12
1494: ARRAY
1495: ST_TO_ADDR
// for j = 1 to RuWeapons do
1496: LD_ADDR_VAR 0 14
1500: PUSH
1501: DOUBLE
1502: LD_INT 1
1504: DEC
1505: ST_TO_ADDR
1506: LD_VAR 0 8
1510: PUSH
1511: FOR_TO
1512: IFFALSE 1714
// begin if RUWeapons [ j ] = 42 or RUWeapons [ j ] = 43 or RUWeapons [ j ] = 44 or RUWeapons [ j ] = 45 or RUWeapons [ j ] = 49 then
1514: LD_VAR 0 8
1518: PUSH
1519: LD_VAR 0 14
1523: ARRAY
1524: PUSH
1525: LD_INT 42
1527: EQUAL
1528: PUSH
1529: LD_VAR 0 8
1533: PUSH
1534: LD_VAR 0 14
1538: ARRAY
1539: PUSH
1540: LD_INT 43
1542: EQUAL
1543: OR
1544: PUSH
1545: LD_VAR 0 8
1549: PUSH
1550: LD_VAR 0 14
1554: ARRAY
1555: PUSH
1556: LD_INT 44
1558: EQUAL
1559: OR
1560: PUSH
1561: LD_VAR 0 8
1565: PUSH
1566: LD_VAR 0 14
1570: ARRAY
1571: PUSH
1572: LD_INT 45
1574: EQUAL
1575: OR
1576: PUSH
1577: LD_VAR 0 8
1581: PUSH
1582: LD_VAR 0 14
1586: ARRAY
1587: PUSH
1588: LD_INT 49
1590: EQUAL
1591: OR
1592: IFFALSE 1641
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1594: LD_ADDR_VAR 0 17
1598: PUSH
1599: LD_INT 21
1601: PUSH
1602: LD_INT 22
1604: PUSH
1605: LD_INT 23
1607: PUSH
1608: LD_INT 24
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1617: LD_ADDR_OWVAR 37
1621: PUSH
1622: LD_VAR 0 17
1626: PUSH
1627: LD_INT 1
1629: PPUSH
1630: LD_VAR 0 17
1634: PPUSH
1635: CALL_OW 12
1639: ARRAY
1640: ST_TO_ADDR
// end ; if RUWeapons [ j ] = 46 or RUWeapons [ j ] = 47 then
1641: LD_VAR 0 8
1645: PUSH
1646: LD_VAR 0 14
1650: ARRAY
1651: PUSH
1652: LD_INT 46
1654: EQUAL
1655: PUSH
1656: LD_VAR 0 8
1660: PUSH
1661: LD_VAR 0 14
1665: ARRAY
1666: PUSH
1667: LD_INT 47
1669: EQUAL
1670: OR
1671: IFFALSE 1712
// begin ruChassisTab = [ 23 , 24 ] ;
1673: LD_ADDR_VAR 0 17
1677: PUSH
1678: LD_INT 23
1680: PUSH
1681: LD_INT 24
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1688: LD_ADDR_OWVAR 37
1692: PUSH
1693: LD_VAR 0 17
1697: PUSH
1698: LD_INT 1
1700: PPUSH
1701: LD_VAR 0 17
1705: PPUSH
1706: CALL_OW 12
1710: ARRAY
1711: ST_TO_ADDR
// end ; end ;
1712: GO 1511
1714: POP
1715: POP
// veh = CreateVehicle ;
1716: LD_ADDR_VAR 0 16
1720: PUSH
1721: CALL_OW 45
1725: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1726: LD_VAR 0 16
1730: PPUSH
1731: LD_VAR 0 1
1735: PPUSH
1736: LD_INT 0
1738: PPUSH
1739: CALL_OW 49
// if vehcontrol = 1 then
1743: LD_VAR 0 7
1747: PUSH
1748: LD_INT 1
1750: EQUAL
1751: IFFALSE 1808
// begin hc_gallery =  ;
1753: LD_ADDR_OWVAR 33
1757: PUSH
1758: LD_STRING 
1760: ST_TO_ADDR
// hc_name =  ;
1761: LD_ADDR_OWVAR 26
1765: PUSH
1766: LD_STRING 
1768: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1769: LD_INT 0
1771: PPUSH
1772: LD_INT 3
1774: PPUSH
1775: LD_VAR 0 4
1779: PPUSH
1780: CALL_OW 380
// un = CreateHuman ;
1784: LD_ADDR_VAR 0 15
1788: PUSH
1789: CALL_OW 44
1793: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1794: LD_VAR 0 15
1798: PPUSH
1799: LD_VAR 0 16
1803: PPUSH
1804: CALL_OW 52
// end ; i = i + 1 ;
1808: LD_ADDR_VAR 0 13
1812: PUSH
1813: LD_VAR 0 13
1817: PUSH
1818: LD_INT 1
1820: PLUS
1821: ST_TO_ADDR
// end ; until i = vehCount ;
1822: LD_VAR 0 13
1826: PUSH
1827: LD_VAR 0 3
1831: EQUAL
1832: IFFALSE 484
// repeat wait ( 0 0$1 ) ;
1834: LD_INT 35
1836: PPUSH
1837: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
1841: LD_ADDR_VAR 0 20
1845: PUSH
1846: LD_INT 22
1848: PUSH
1849: LD_VAR 0 2
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: LD_INT 21
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 24
1870: PUSH
1871: LD_INT 650
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: PPUSH
1883: CALL_OW 69
1887: ST_TO_ADDR
// if vehicleOK_list > 0 then
1888: LD_VAR 0 20
1892: PUSH
1893: LD_INT 0
1895: GREATER
1896: IFFALSE 2087
// begin for i in vehicleOK_list do
1898: LD_ADDR_VAR 0 13
1902: PUSH
1903: LD_VAR 0 20
1907: PUSH
1908: FOR_IN
1909: IFFALSE 2085
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
1911: LD_ADDR_VAR 0 21
1915: PUSH
1916: LD_INT 22
1918: PUSH
1919: LD_VAR 0 11
1923: PUSH
1924: EMPTY
1925: LIST
1926: LIST
1927: PPUSH
1928: CALL_OW 69
1932: PPUSH
1933: LD_VAR 0 13
1937: PPUSH
1938: CALL_OW 74
1942: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
1943: LD_ADDR_VAR 0 22
1947: PUSH
1948: LD_INT 22
1950: PUSH
1951: LD_VAR 0 11
1955: PUSH
1956: EMPTY
1957: LIST
1958: LIST
1959: PUSH
1960: LD_INT 2
1962: PUSH
1963: LD_INT 59
1965: PUSH
1966: EMPTY
1967: LIST
1968: PUSH
1969: LD_INT 21
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: PUSH
1979: LD_INT 21
1981: PUSH
1982: LD_INT 2
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: LIST
1993: LIST
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: PUSH
1999: EMPTY
2000: LIST
2001: PPUSH
2002: CALL_OW 69
2006: PPUSH
2007: LD_VAR 0 13
2011: PPUSH
2012: CALL_OW 74
2016: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2017: LD_VAR 0 13
2021: PPUSH
2022: LD_VAR 0 21
2026: PPUSH
2027: CALL_OW 296
2031: PUSH
2032: LD_INT 8
2034: PLUS
2035: PUSH
2036: LD_VAR 0 13
2040: PPUSH
2041: LD_VAR 0 22
2045: PPUSH
2046: CALL_OW 296
2050: LESS
2051: IFFALSE 2069
// begin ComAttackUnit ( i , target1 ) ;
2053: LD_VAR 0 13
2057: PPUSH
2058: LD_VAR 0 21
2062: PPUSH
2063: CALL_OW 115
// end else
2067: GO 2083
// begin ComAttackUnit ( i , target2 ) ;
2069: LD_VAR 0 13
2073: PPUSH
2074: LD_VAR 0 22
2078: PPUSH
2079: CALL_OW 115
// end ; end ;
2083: GO 1908
2085: POP
2086: POP
// end ; until ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ) = 0 ;
2087: LD_INT 22
2089: PUSH
2090: LD_VAR 0 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: PUSH
2099: LD_INT 21
2101: PUSH
2102: LD_INT 2
2104: PUSH
2105: EMPTY
2106: LIST
2107: LIST
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PPUSH
2113: CALL_OW 69
2117: PUSH
2118: LD_INT 0
2120: EQUAL
2121: IFFALSE 1834
// end ;
2123: LD_VAR 0 12
2127: RET
// every 0 0$1 do
2128: GO 2130
2130: DISABLE
// begin enable ;
2131: ENABLE
// end ;
2132: END
// export CPU1Tanks , CPU1DamageTanks ; export function BuildingVehicleAndAttackEnemy ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2133: LD_INT 0
2135: PPUSH
2136: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2137: LD_INT 22
2139: PUSH
2140: LD_VAR 0 1
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: PUSH
2149: LD_INT 21
2151: PUSH
2152: LD_INT 2
2154: PUSH
2155: EMPTY
2156: LIST
2157: LIST
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PPUSH
2163: CALL_OW 69
2167: PUSH
2168: LD_VAR 0 3
2172: LESSEQUAL
2173: IFFALSE 2240
// for i = 1 to vehCount do
2175: LD_ADDR_VAR 0 9
2179: PUSH
2180: DOUBLE
2181: LD_INT 1
2183: DEC
2184: ST_TO_ADDR
2185: LD_VAR 0 3
2189: PUSH
2190: FOR_TO
2191: IFFALSE 2238
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2193: LD_VAR 0 2
2197: PPUSH
2198: LD_VAR 0 7
2202: PPUSH
2203: LD_VAR 0 5
2207: PPUSH
2208: LD_VAR 0 6
2212: PPUSH
2213: LD_VAR 0 4
2217: PUSH
2218: LD_INT 1
2220: PPUSH
2221: LD_VAR 0 4
2225: PPUSH
2226: CALL_OW 12
2230: ARRAY
2231: PPUSH
2232: CALL_OW 185
2236: GO 2190
2238: POP
2239: POP
// end ;
2240: LD_VAR 0 8
2244: RET
// export function EnemyVehicleAttack ( side , targetSide ) ; var i , tmp , target1 , target2 ; begin
2245: LD_INT 0
2247: PPUSH
2248: PPUSH
2249: PPUSH
2250: PPUSH
2251: PPUSH
// for i := 1 to CPU1Tanks do
2252: LD_ADDR_VAR 0 4
2256: PUSH
2257: DOUBLE
2258: LD_INT 1
2260: DEC
2261: ST_TO_ADDR
2262: LD_EXP 3
2266: PUSH
2267: FOR_TO
2268: IFFALSE 2596
// begin if i = 4 then
2270: LD_VAR 0 4
2274: PUSH
2275: LD_INT 4
2277: EQUAL
2278: IFFALSE 2594
// begin repeat wait ( 0 0$1 ) ;
2280: LD_INT 35
2282: PPUSH
2283: CALL_OW 67
// for i in CPU1Tanks do
2287: LD_ADDR_VAR 0 4
2291: PUSH
2292: LD_EXP 3
2296: PUSH
2297: FOR_IN
2298: IFFALSE 2582
// begin if GetLives ( i ) < 659 then
2300: LD_VAR 0 4
2304: PPUSH
2305: CALL_OW 256
2309: PUSH
2310: LD_INT 659
2312: LESS
2313: IFFALSE 2401
// begin tmp = i ;
2315: LD_ADDR_VAR 0 5
2319: PUSH
2320: LD_VAR 0 4
2324: ST_TO_ADDR
// for i := 1 to CPU1Tanks do
2325: LD_ADDR_VAR 0 4
2329: PUSH
2330: DOUBLE
2331: LD_INT 1
2333: DEC
2334: ST_TO_ADDR
2335: LD_EXP 3
2339: PUSH
2340: FOR_TO
2341: IFFALSE 2399
// begin if tmp = CPU1Tanks [ i ] then
2343: LD_VAR 0 5
2347: PUSH
2348: LD_EXP 3
2352: PUSH
2353: LD_VAR 0 4
2357: ARRAY
2358: EQUAL
2359: IFFALSE 2397
// begin CPU1Tanks = Delete ( CPU1Tanks , i ) ;
2361: LD_ADDR_EXP 3
2365: PUSH
2366: LD_EXP 3
2370: PPUSH
2371: LD_VAR 0 4
2375: PPUSH
2376: CALL_OW 3
2380: ST_TO_ADDR
// CPU1DamageTanks = CPU1DamageTanks ^ tmp ;
2381: LD_ADDR_EXP 4
2385: PUSH
2386: LD_EXP 4
2390: PUSH
2391: LD_VAR 0 5
2395: ADD
2396: ST_TO_ADDR
// end ; end ;
2397: GO 2340
2399: POP
2400: POP
// end ; wait ( 0 0$1 ) ;
2401: LD_INT 35
2403: PPUSH
2404: CALL_OW 67
// target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , targetSide ] ) , i ) ;
2408: LD_ADDR_VAR 0 6
2412: PUSH
2413: LD_INT 22
2415: PUSH
2416: LD_VAR 0 2
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: PPUSH
2425: CALL_OW 69
2429: PPUSH
2430: LD_VAR 0 4
2434: PPUSH
2435: CALL_OW 74
2439: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , targetSide ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2440: LD_ADDR_VAR 0 7
2444: PUSH
2445: LD_INT 22
2447: PUSH
2448: LD_VAR 0 2
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: PUSH
2457: LD_INT 2
2459: PUSH
2460: LD_INT 59
2462: PUSH
2463: EMPTY
2464: LIST
2465: PUSH
2466: LD_INT 21
2468: PUSH
2469: LD_INT 1
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: PUSH
2476: LD_INT 21
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: EMPTY
2483: LIST
2484: LIST
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: LIST
2490: LIST
2491: PUSH
2492: EMPTY
2493: LIST
2494: LIST
2495: PUSH
2496: EMPTY
2497: LIST
2498: PPUSH
2499: CALL_OW 69
2503: PPUSH
2504: LD_VAR 0 4
2508: PPUSH
2509: CALL_OW 74
2513: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2514: LD_VAR 0 4
2518: PPUSH
2519: LD_VAR 0 6
2523: PPUSH
2524: CALL_OW 296
2528: PUSH
2529: LD_INT 8
2531: PLUS
2532: PUSH
2533: LD_VAR 0 4
2537: PPUSH
2538: LD_VAR 0 7
2542: PPUSH
2543: CALL_OW 296
2547: LESS
2548: IFFALSE 2566
// begin ComAttackUnit ( i , target1 ) ;
2550: LD_VAR 0 4
2554: PPUSH
2555: LD_VAR 0 6
2559: PPUSH
2560: CALL_OW 115
// end else
2564: GO 2580
// begin ComAttackUnit ( i , target2 ) ;
2566: LD_VAR 0 4
2570: PPUSH
2571: LD_VAR 0 7
2575: PPUSH
2576: CALL_OW 115
// end ; end ;
2580: GO 2297
2582: POP
2583: POP
// until CPU1Tanks = 0 ;
2584: LD_EXP 3
2588: PUSH
2589: LD_INT 0
2591: EQUAL
2592: IFFALSE 2280
// end ; end ;
2594: GO 2267
2596: POP
2597: POP
// end ;
2598: LD_VAR 0 3
2602: RET
// export function RepairVehicle ( side , repairArea , repX , repY ) ; var i , j , vehicleOK_list , damageVehicle_list , vehicleNeedRepair_list , vehicleDontNeedRepair_list , mechanicInside_list , mechanicOutside_list ; begin
2603: LD_INT 0
2605: PPUSH
2606: PPUSH
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
2613: PPUSH
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 660 ] , [ f_not , [ f_empty ] ] ] ) ;
2614: LD_ADDR_VAR 0 8
2618: PUSH
2619: LD_INT 22
2621: PUSH
2622: LD_VAR 0 1
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 21
2633: PUSH
2634: LD_INT 2
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 24
2643: PUSH
2644: LD_INT 660
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 3
2653: PUSH
2654: LD_INT 58
2656: PUSH
2657: EMPTY
2658: LIST
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PPUSH
2670: CALL_OW 69
2674: ST_TO_ADDR
// damageVehicle_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 660 ] ] ] ) ;
2675: LD_ADDR_VAR 0 9
2679: PUSH
2680: LD_INT 22
2682: PUSH
2683: LD_VAR 0 1
2687: PUSH
2688: EMPTY
2689: LIST
2690: LIST
2691: PUSH
2692: LD_INT 21
2694: PUSH
2695: LD_INT 2
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: PUSH
2702: LD_INT 3
2704: PUSH
2705: LD_INT 24
2707: PUSH
2708: LD_INT 660
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: LIST
2723: PPUSH
2724: CALL_OW 69
2728: ST_TO_ADDR
// vehicleNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
2729: LD_ADDR_VAR 0 10
2733: PUSH
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 22
2741: PUSH
2742: LD_VAR 0 1
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: PUSH
2751: LD_INT 21
2753: PUSH
2754: LD_INT 2
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: LD_INT 24
2766: PUSH
2767: LD_INT 1000
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL_OW 70
2787: ST_TO_ADDR
// vehicleDontNeedRepair_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
2788: LD_ADDR_VAR 0 11
2792: PUSH
2793: LD_VAR 0 2
2797: PPUSH
2798: LD_INT 22
2800: PUSH
2801: LD_VAR 0 1
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PUSH
2810: LD_INT 21
2812: PUSH
2813: LD_INT 2
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 24
2822: PUSH
2823: LD_INT 1000
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: PUSH
2830: LD_INT 58
2832: PUSH
2833: EMPTY
2834: LIST
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: LIST
2841: PPUSH
2842: CALL_OW 70
2846: ST_TO_ADDR
// mechanicInside_list = [ ] ;
2847: LD_ADDR_VAR 0 12
2851: PUSH
2852: EMPTY
2853: ST_TO_ADDR
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
2854: LD_ADDR_VAR 0 13
2858: PUSH
2859: LD_VAR 0 2
2863: PPUSH
2864: LD_INT 22
2866: PUSH
2867: LD_VAR 0 1
2871: PUSH
2872: EMPTY
2873: LIST
2874: LIST
2875: PUSH
2876: LD_INT 25
2878: PUSH
2879: LD_INT 3
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PPUSH
2890: CALL_OW 70
2894: ST_TO_ADDR
// display_strings = [ w polu:  , CPU1Tanks , uszkodzone:  , CPU1DamageTanks , wylosowane: 4 , ok , vehicleOK_list ] ;
2895: LD_ADDR_OWVAR 47
2899: PUSH
2900: LD_STRING w polu: 
2902: PUSH
2903: LD_EXP 3
2907: PUSH
2908: LD_STRING uszkodzone: 
2910: PUSH
2911: LD_EXP 4
2915: PUSH
2916: LD_STRING wylosowane: 4
2918: PUSH
2919: LD_STRING ok
2921: PUSH
2922: LD_VAR 0 8
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: ST_TO_ADDR
// if damageVehicle_list > 0 then
2936: LD_VAR 0 9
2940: PUSH
2941: LD_INT 0
2943: GREATER
2944: IFFALSE 2982
// for i in damageVehicle_list do
2946: LD_ADDR_VAR 0 6
2950: PUSH
2951: LD_VAR 0 9
2955: PUSH
2956: FOR_IN
2957: IFFALSE 2980
// ComMoveXY ( i , repX , repY ) ;
2959: LD_VAR 0 6
2963: PPUSH
2964: LD_VAR 0 3
2968: PPUSH
2969: LD_VAR 0 4
2973: PPUSH
2974: CALL_OW 111
2978: GO 2956
2980: POP
2981: POP
// if vehicleNeedRepair_list > 0 then
2982: LD_VAR 0 10
2986: PUSH
2987: LD_INT 0
2989: GREATER
2990: IFFALSE 3077
// begin for i in vehicleNeedRepair_list do
2992: LD_ADDR_VAR 0 6
2996: PUSH
2997: LD_VAR 0 10
3001: PUSH
3002: FOR_IN
3003: IFFALSE 3075
// begin mechanicInside_list = mechanicInside_list ^ UnitsInside ( i ) ;
3005: LD_ADDR_VAR 0 12
3009: PUSH
3010: LD_VAR 0 12
3014: PUSH
3015: LD_VAR 0 6
3019: PPUSH
3020: CALL_OW 313
3024: ADD
3025: ST_TO_ADDR
// for j in mechanicInside_list do
3026: LD_ADDR_VAR 0 7
3030: PUSH
3031: LD_VAR 0 12
3035: PUSH
3036: FOR_IN
3037: IFFALSE 3071
// begin ComExitVehicle ( j ) ;
3039: LD_VAR 0 7
3043: PPUSH
3044: CALL_OW 121
// wait ( 0 0$1 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// ComRepairVehicle ( j , i ) ;
3055: LD_VAR 0 7
3059: PPUSH
3060: LD_VAR 0 6
3064: PPUSH
3065: CALL_OW 129
// end ;
3069: GO 3036
3071: POP
3072: POP
// end ;
3073: GO 3002
3075: POP
3076: POP
// end ; if vehicleDontNeedRepair_list > 0 then
3077: LD_VAR 0 11
3081: PUSH
3082: LD_INT 0
3084: GREATER
3085: IFFALSE 3109
// begin ComEnterUnit ( mechanicOutside_list [ 1 ] , vehicleDontNeedRepair_list [ 1 ] ) ;
3087: LD_VAR 0 13
3091: PUSH
3092: LD_INT 1
3094: ARRAY
3095: PPUSH
3096: LD_VAR 0 11
3100: PUSH
3101: LD_INT 1
3103: ARRAY
3104: PPUSH
3105: CALL_OW 120
// end ; if vehicleOK_list > 0 and CPU1DamageTanks > 0 then
3109: LD_VAR 0 8
3113: PUSH
3114: LD_INT 0
3116: GREATER
3117: PUSH
3118: LD_EXP 4
3122: PUSH
3123: LD_INT 0
3125: GREATER
3126: AND
3127: IFFALSE 3195
// begin for i := 1 to vehicleOK_list do
3129: LD_ADDR_VAR 0 6
3133: PUSH
3134: DOUBLE
3135: LD_INT 1
3137: DEC
3138: ST_TO_ADDR
3139: LD_VAR 0 8
3143: PUSH
3144: FOR_TO
3145: IFFALSE 3193
// begin if i = 4 then
3147: LD_VAR 0 6
3151: PUSH
3152: LD_INT 4
3154: EQUAL
3155: IFFALSE 3191
// begin CPU1Tanks = CPU1Tanks ^ vehicleOK_list ;
3157: LD_ADDR_EXP 3
3161: PUSH
3162: LD_EXP 3
3166: PUSH
3167: LD_VAR 0 8
3171: ADD
3172: ST_TO_ADDR
// CPU1DamageTanks = Delete ( CPU1DamageTanks , 1 ) ;
3173: LD_ADDR_EXP 4
3177: PUSH
3178: LD_EXP 4
3182: PPUSH
3183: LD_INT 1
3185: PPUSH
3186: CALL_OW 3
3190: ST_TO_ADDR
// end ; end ;
3191: GO 3144
3193: POP
3194: POP
// end ; for i in not FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) do
3195: LD_ADDR_VAR 0 6
3199: PUSH
3200: LD_VAR 0 2
3204: PPUSH
3205: LD_INT 22
3207: PUSH
3208: LD_VAR 0 1
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 25
3219: PUSH
3220: LD_INT 3
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PPUSH
3231: CALL_OW 70
3235: NOT
3236: PUSH
3237: FOR_IN
3238: IFFALSE 3261
// ComMoveXY ( i , repX , repY ) ;
3240: LD_VAR 0 6
3244: PPUSH
3245: LD_VAR 0 3
3249: PPUSH
3250: LD_VAR 0 4
3254: PPUSH
3255: CALL_OW 111
3259: GO 3237
3261: POP
3262: POP
// end ;
3263: LD_VAR 0 5
3267: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3268: LD_INT 0
3270: PPUSH
3271: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3272: LD_INT 22
3274: PUSH
3275: LD_VAR 0 1
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: LD_INT 25
3286: PUSH
3287: LD_INT 2
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL_OW 69
3302: PUSH
3303: LD_INT 0
3305: GREATER
3306: PUSH
3307: LD_INT 22
3309: PUSH
3310: LD_VAR 0 1
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: LD_INT 21
3321: PUSH
3322: LD_INT 3
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: PUSH
3329: LD_INT 3
3331: PUSH
3332: LD_INT 24
3334: PUSH
3335: LD_INT 1000
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: PPUSH
3351: CALL_OW 69
3355: PUSH
3356: LD_INT 0
3358: EQUAL
3359: AND
3360: PUSH
3361: LD_VAR 0 2
3365: PUSH
3366: LD_INT 0
3368: GREATER
3369: AND
3370: IFFALSE 3469
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3372: LD_ADDR_VAR 0 4
3376: PUSH
3377: LD_INT 22
3379: PUSH
3380: LD_VAR 0 1
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PUSH
3389: LD_INT 25
3391: PUSH
3392: LD_INT 2
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: PUSH
3399: EMPTY
3400: LIST
3401: LIST
3402: PPUSH
3403: CALL_OW 69
3407: PUSH
3408: FOR_IN
3409: IFFALSE 3467
// begin AddComExitBuilding ( i ) ;
3411: LD_VAR 0 4
3415: PPUSH
3416: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3420: LD_VAR 0 4
3424: PPUSH
3425: LD_VAR 0 2
3429: PUSH
3430: LD_INT 1
3432: ARRAY
3433: PPUSH
3434: LD_VAR 0 2
3438: PUSH
3439: LD_INT 2
3441: ARRAY
3442: PPUSH
3443: LD_VAR 0 2
3447: PUSH
3448: LD_INT 3
3450: ARRAY
3451: PPUSH
3452: LD_VAR 0 2
3456: PUSH
3457: LD_INT 4
3459: ARRAY
3460: PPUSH
3461: CALL_OW 205
// end ;
3465: GO 3408
3467: POP
3468: POP
// end ; end ;
3469: LD_VAR 0 3
3473: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3474: LD_INT 0
3476: PPUSH
3477: PPUSH
3478: PPUSH
3479: PPUSH
3480: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3481: LD_ADDR_VAR 0 6
3485: PUSH
3486: LD_INT 22
3488: PUSH
3489: LD_VAR 0 1
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: LD_INT 2
3500: PUSH
3501: LD_INT 30
3503: PUSH
3504: LD_INT 31
3506: PUSH
3507: EMPTY
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 30
3513: PUSH
3514: LD_INT 32
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: LD_INT 30
3523: PUSH
3524: LD_INT 33
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: LD_INT 30
3533: PUSH
3534: LD_INT 4
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 30
3543: PUSH
3544: LD_INT 5
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: PPUSH
3563: CALL_OW 69
3567: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3568: LD_ADDR_VAR 0 7
3572: PUSH
3573: LD_INT 22
3575: PUSH
3576: LD_VAR 0 2
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PUSH
3585: LD_INT 21
3587: PUSH
3588: LD_INT 3
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 58
3597: PUSH
3598: EMPTY
3599: LIST
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: LIST
3605: PPUSH
3606: CALL_OW 69
3610: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3611: LD_VAR 0 6
3615: PUSH
3616: LD_INT 0
3618: GREATER
3619: PUSH
3620: LD_VAR 0 7
3624: PUSH
3625: LD_INT 0
3627: GREATER
3628: AND
3629: IFFALSE 3699
// begin for i in turretsList do
3631: LD_ADDR_VAR 0 4
3635: PUSH
3636: LD_VAR 0 6
3640: PUSH
3641: FOR_IN
3642: IFFALSE 3697
// begin for j in enemyBuildings do
3644: LD_ADDR_VAR 0 5
3648: PUSH
3649: LD_VAR 0 7
3653: PUSH
3654: FOR_IN
3655: IFFALSE 3693
// begin if GetDistUnits ( i , j ) < 20 then
3657: LD_VAR 0 4
3661: PPUSH
3662: LD_VAR 0 5
3666: PPUSH
3667: CALL_OW 296
3671: PUSH
3672: LD_INT 20
3674: LESS
3675: IFFALSE 3691
// begin ComAttackUnit ( i , j ) ;
3677: LD_VAR 0 4
3681: PPUSH
3682: LD_VAR 0 5
3686: PPUSH
3687: CALL_OW 115
// end ; end ;
3691: GO 3654
3693: POP
3694: POP
// end ;
3695: GO 3641
3697: POP
3698: POP
// end ; end ;
3699: LD_VAR 0 3
3703: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3704: LD_INT 0
3706: PPUSH
3707: PPUSH
3708: PPUSH
3709: PPUSH
3710: PPUSH
3711: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3712: LD_ADDR_VAR 0 7
3716: PUSH
3717: LD_INT 22
3719: PUSH
3720: LD_VAR 0 1
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PUSH
3729: LD_INT 25
3731: PUSH
3732: LD_INT 9
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: PPUSH
3743: CALL_OW 69
3747: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3748: LD_ADDR_VAR 0 8
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_VAR 0 2
3760: PUSH
3761: EMPTY
3762: LIST
3763: LIST
3764: PUSH
3765: LD_INT 3
3767: PUSH
3768: LD_INT 21
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3791: LD_ADDR_VAR 0 5
3795: PUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 3
3801: PPUSH
3802: CALL_OW 12
3806: ST_TO_ADDR
// for i = 1 to list do
3807: LD_ADDR_VAR 0 6
3811: PUSH
3812: DOUBLE
3813: LD_INT 1
3815: DEC
3816: ST_TO_ADDR
3817: LD_VAR 0 7
3821: PUSH
3822: FOR_TO
3823: IFFALSE 4005
// for ta in filter do
3825: LD_ADDR_VAR 0 4
3829: PUSH
3830: LD_VAR 0 8
3834: PUSH
3835: FOR_IN
3836: IFFALSE 4001
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3838: LD_VAR 0 7
3842: PUSH
3843: LD_VAR 0 6
3847: ARRAY
3848: PPUSH
3849: LD_VAR 0 4
3853: PPUSH
3854: CALL_OW 296
3858: PUSH
3859: LD_INT 13
3861: LESSEQUAL
3862: IFFALSE 3999
// begin case c of 1 :
3864: LD_VAR 0 5
3868: PUSH
3869: LD_INT 1
3871: DOUBLE
3872: EQUAL
3873: IFTRUE 3877
3875: GO 3915
3877: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
3878: LD_VAR 0 7
3882: PUSH
3883: LD_VAR 0 6
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 250
3898: PPUSH
3899: LD_VAR 0 4
3903: PPUSH
3904: CALL_OW 251
3908: PPUSH
3909: CALL_OW 154
3913: GO 3999
3915: LD_INT 2
3917: DOUBLE
3918: EQUAL
3919: IFTRUE 3923
3921: GO 3987
3923: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
3924: LD_VAR 0 7
3928: PUSH
3929: LD_VAR 0 6
3933: ARRAY
3934: PPUSH
3935: LD_VAR 0 4
3939: PPUSH
3940: CALL_OW 250
3944: PUSH
3945: LD_INT 1
3947: NEG
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: CALL_OW 12
3956: PLUS
3957: PPUSH
3958: LD_VAR 0 4
3962: PPUSH
3963: CALL_OW 251
3967: PUSH
3968: LD_INT 1
3970: NEG
3971: PPUSH
3972: LD_INT 1
3974: PPUSH
3975: CALL_OW 12
3979: PLUS
3980: PPUSH
3981: CALL_OW 153
3985: GO 3999
3987: LD_INT 3
3989: DOUBLE
3990: EQUAL
3991: IFTRUE 3995
3993: GO 3998
3995: POP
// ; end ;
3996: GO 3999
3998: POP
// end ; end ;
3999: GO 3835
4001: POP
4002: POP
4003: GO 3822
4005: POP
4006: POP
// end ; end_of_file
4007: LD_VAR 0 3
4011: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4012: LD_INT 0
4014: PPUSH
4015: PPUSH
// if exist_mode then
4016: LD_VAR 0 2
4020: IFFALSE 4039
// unit := CreateCharacter ( ident ) else
4022: LD_ADDR_VAR 0 4
4026: PUSH
4027: LD_VAR 0 1
4031: PPUSH
4032: CALL_OW 34
4036: ST_TO_ADDR
4037: GO 4054
// unit := NewCharacter ( ident ) ;
4039: LD_ADDR_VAR 0 4
4043: PUSH
4044: LD_VAR 0 1
4048: PPUSH
4049: CALL_OW 25
4053: ST_TO_ADDR
// result := unit ;
4054: LD_ADDR_VAR 0 3
4058: PUSH
4059: LD_VAR 0 4
4063: ST_TO_ADDR
// end ;
4064: LD_VAR 0 3
4068: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4069: LD_INT 0
4071: PPUSH
4072: PPUSH
4073: PPUSH
// uc_side := GetSide ( b ) ;
4074: LD_ADDR_OWVAR 20
4078: PUSH
4079: LD_VAR 0 2
4083: PPUSH
4084: CALL_OW 255
4088: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4089: LD_ADDR_OWVAR 21
4093: PUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: CALL_OW 248
4103: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4104: LD_INT 0
4106: PPUSH
4107: LD_INT 1
4109: PPUSH
4110: LD_VAR 0 1
4114: PPUSH
4115: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4119: LD_ADDR_VAR 0 5
4123: PUSH
4124: LD_VAR 0 2
4128: PPUSH
4129: CALL_OW 254
4133: PUSH
4134: LD_INT 3
4136: MINUS
4137: ST_TO_ADDR
// if dir < 0 then
4138: LD_VAR 0 5
4142: PUSH
4143: LD_INT 0
4145: LESS
4146: IFFALSE 4162
// dir := 6 + dir ;
4148: LD_ADDR_VAR 0 5
4152: PUSH
4153: LD_INT 6
4155: PUSH
4156: LD_VAR 0 5
4160: PLUS
4161: ST_TO_ADDR
// un := CreateHuman ;
4162: LD_ADDR_VAR 0 4
4166: PUSH
4167: CALL_OW 44
4171: ST_TO_ADDR
// SetDir ( un , dir ) ;
4172: LD_VAR 0 4
4176: PPUSH
4177: LD_VAR 0 5
4181: PPUSH
4182: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4186: LD_VAR 0 4
4190: PPUSH
4191: LD_VAR 0 2
4195: PPUSH
4196: CALL_OW 52
// end ; end_of_file
4200: LD_VAR 0 3
4204: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
4205: LD_VAR 0 1
4209: PPUSH
4210: CALL_OW 255
4214: PUSH
4215: LD_INT 3
4217: EQUAL
4218: PUSH
4219: LD_VAR 0 1
4223: PPUSH
4224: CALL_OW 247
4228: PUSH
4229: LD_INT 3
4231: EQUAL
4232: AND
4233: IFFALSE 4925
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
4235: LD_VAR 0 1
4239: PPUSH
4240: CALL_OW 266
4244: PUSH
4245: LD_INT 31
4247: EQUAL
4248: PUSH
4249: LD_VAR 0 1
4253: PPUSH
4254: CALL_OW 266
4258: PUSH
4259: LD_INT 32
4261: EQUAL
4262: OR
4263: PUSH
4264: LD_VAR 0 1
4268: PPUSH
4269: CALL_OW 266
4273: PUSH
4274: LD_INT 36
4276: EQUAL
4277: OR
4278: PUSH
4279: LD_VAR 0 1
4283: PPUSH
4284: CALL_OW 266
4288: PUSH
4289: LD_INT 0
4291: EQUAL
4292: OR
4293: PUSH
4294: LD_VAR 0 1
4298: PPUSH
4299: CALL_OW 266
4303: PUSH
4304: LD_INT 24
4306: EQUAL
4307: OR
4308: PUSH
4309: LD_VAR 0 1
4313: PPUSH
4314: CALL_OW 266
4318: PUSH
4319: LD_INT 17
4321: EQUAL
4322: OR
4323: PUSH
4324: LD_VAR 0 1
4328: PPUSH
4329: CALL_OW 266
4333: PUSH
4334: LD_INT 25
4336: EQUAL
4337: OR
4338: PUSH
4339: LD_VAR 0 1
4343: PPUSH
4344: CALL_OW 266
4348: PUSH
4349: LD_INT 19
4351: EQUAL
4352: OR
4353: PUSH
4354: LD_VAR 0 1
4358: PPUSH
4359: CALL_OW 266
4363: PUSH
4364: LD_INT 20
4366: EQUAL
4367: OR
4368: PUSH
4369: LD_VAR 0 1
4373: PPUSH
4374: CALL_OW 266
4378: PUSH
4379: LD_INT 18
4381: EQUAL
4382: OR
4383: PUSH
4384: LD_VAR 0 1
4388: PPUSH
4389: CALL_OW 266
4393: PUSH
4394: LD_INT 21
4396: EQUAL
4397: OR
4398: PUSH
4399: LD_VAR 0 1
4403: PPUSH
4404: CALL_OW 266
4408: PUSH
4409: LD_INT 23
4411: EQUAL
4412: OR
4413: PUSH
4414: LD_VAR 0 1
4418: PPUSH
4419: CALL_OW 266
4423: PUSH
4424: LD_INT 16
4426: EQUAL
4427: OR
4428: PUSH
4429: LD_VAR 0 1
4433: PPUSH
4434: CALL_OW 266
4438: PUSH
4439: LD_INT 6
4441: EQUAL
4442: OR
4443: PUSH
4444: LD_VAR 0 1
4448: PPUSH
4449: CALL_OW 266
4453: PUSH
4454: LD_INT 29
4456: EQUAL
4457: OR
4458: PUSH
4459: LD_VAR 0 1
4463: PPUSH
4464: CALL_OW 266
4468: PUSH
4469: LD_INT 26
4471: EQUAL
4472: OR
4473: PUSH
4474: LD_VAR 0 1
4478: PPUSH
4479: CALL_OW 266
4483: PUSH
4484: LD_INT 30
4486: EQUAL
4487: OR
4488: PUSH
4489: LD_VAR 0 1
4493: PPUSH
4494: CALL_OW 266
4498: PUSH
4499: LD_INT 28
4501: EQUAL
4502: OR
4503: PUSH
4504: LD_VAR 0 1
4508: PPUSH
4509: CALL_OW 266
4513: PUSH
4514: LD_INT 27
4516: EQUAL
4517: OR
4518: PUSH
4519: LD_VAR 0 1
4523: PPUSH
4524: CALL_OW 266
4528: PUSH
4529: LD_INT 33
4531: EQUAL
4532: OR
4533: PUSH
4534: LD_VAR 0 1
4538: PPUSH
4539: CALL_OW 266
4543: PUSH
4544: LD_INT 2
4546: EQUAL
4547: OR
4548: PUSH
4549: LD_VAR 0 1
4553: PPUSH
4554: CALL_OW 266
4558: PUSH
4559: LD_INT 4
4561: EQUAL
4562: OR
4563: IFFALSE 4649
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
4565: LD_ADDR_EXP 1
4569: PUSH
4570: LD_EXP 1
4574: PUSH
4575: LD_VAR 0 1
4579: PPUSH
4580: CALL_OW 266
4584: ADD
4585: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4586: LD_ADDR_EXP 1
4590: PUSH
4591: LD_EXP 1
4595: PUSH
4596: LD_VAR 0 1
4600: PPUSH
4601: CALL_OW 250
4605: ADD
4606: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4607: LD_ADDR_EXP 1
4611: PUSH
4612: LD_EXP 1
4616: PUSH
4617: LD_VAR 0 1
4621: PPUSH
4622: CALL_OW 251
4626: ADD
4627: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4628: LD_ADDR_EXP 1
4632: PUSH
4633: LD_EXP 1
4637: PUSH
4638: LD_VAR 0 1
4642: PPUSH
4643: CALL_OW 254
4647: ADD
4648: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
4649: LD_VAR 0 1
4653: PPUSH
4654: CALL_OW 266
4658: PUSH
4659: LD_INT 1
4661: EQUAL
4662: IFFALSE 4741
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
4664: LD_ADDR_EXP 1
4668: PUSH
4669: LD_EXP 1
4673: PUSH
4674: LD_INT 0
4676: ADD
4677: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4678: LD_ADDR_EXP 1
4682: PUSH
4683: LD_EXP 1
4687: PUSH
4688: LD_VAR 0 1
4692: PPUSH
4693: CALL_OW 250
4697: ADD
4698: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4699: LD_ADDR_EXP 1
4703: PUSH
4704: LD_EXP 1
4708: PUSH
4709: LD_VAR 0 1
4713: PPUSH
4714: CALL_OW 251
4718: ADD
4719: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4720: LD_ADDR_EXP 1
4724: PUSH
4725: LD_EXP 1
4729: PUSH
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 254
4739: ADD
4740: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
4741: LD_VAR 0 1
4745: PPUSH
4746: CALL_OW 266
4750: PUSH
4751: LD_INT 3
4753: EQUAL
4754: IFFALSE 4833
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
4756: LD_ADDR_EXP 1
4760: PUSH
4761: LD_EXP 1
4765: PUSH
4766: LD_INT 2
4768: ADD
4769: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4770: LD_ADDR_EXP 1
4774: PUSH
4775: LD_EXP 1
4779: PUSH
4780: LD_VAR 0 1
4784: PPUSH
4785: CALL_OW 250
4789: ADD
4790: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4791: LD_ADDR_EXP 1
4795: PUSH
4796: LD_EXP 1
4800: PUSH
4801: LD_VAR 0 1
4805: PPUSH
4806: CALL_OW 251
4810: ADD
4811: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4812: LD_ADDR_EXP 1
4816: PUSH
4817: LD_EXP 1
4821: PUSH
4822: LD_VAR 0 1
4826: PPUSH
4827: CALL_OW 254
4831: ADD
4832: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
4833: LD_VAR 0 1
4837: PPUSH
4838: CALL_OW 266
4842: PUSH
4843: LD_INT 5
4845: EQUAL
4846: IFFALSE 4925
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
4848: LD_ADDR_EXP 1
4852: PUSH
4853: LD_EXP 1
4857: PUSH
4858: LD_INT 4
4860: ADD
4861: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
4862: LD_ADDR_EXP 1
4866: PUSH
4867: LD_EXP 1
4871: PUSH
4872: LD_VAR 0 1
4876: PPUSH
4877: CALL_OW 250
4881: ADD
4882: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
4883: LD_ADDR_EXP 1
4887: PUSH
4888: LD_EXP 1
4892: PUSH
4893: LD_VAR 0 1
4897: PPUSH
4898: CALL_OW 251
4902: ADD
4903: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
4904: LD_ADDR_EXP 1
4908: PUSH
4909: LD_EXP 1
4913: PUSH
4914: LD_VAR 0 1
4918: PPUSH
4919: CALL_OW 254
4923: ADD
4924: ST_TO_ADDR
// end ; end ; end ;
4925: PPOPN 1
4927: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
4928: LD_VAR 0 1
4932: PPUSH
4933: CALL_OW 255
4937: PUSH
4938: LD_INT 3
4940: EQUAL
4941: IFFALSE 5015
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4943: LD_ADDR_EXP 1
4947: PUSH
4948: LD_EXP 1
4952: PPUSH
4953: LD_INT 1
4955: PPUSH
4956: CALL_OW 3
4960: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4961: LD_ADDR_EXP 1
4965: PUSH
4966: LD_EXP 1
4970: PPUSH
4971: LD_INT 1
4973: PPUSH
4974: CALL_OW 3
4978: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4979: LD_ADDR_EXP 1
4983: PUSH
4984: LD_EXP 1
4988: PPUSH
4989: LD_INT 1
4991: PPUSH
4992: CALL_OW 3
4996: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
4997: LD_ADDR_EXP 1
5001: PUSH
5002: LD_EXP 1
5006: PPUSH
5007: LD_INT 1
5009: PPUSH
5010: CALL_OW 3
5014: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
5015: LD_VAR 0 1
5019: PPUSH
5020: CALL_OW 255
5024: PUSH
5025: LD_INT 3
5027: EQUAL
5028: PUSH
5029: LD_VAR 0 1
5033: PPUSH
5034: CALL_OW 266
5038: PUSH
5039: LD_INT 0
5041: EQUAL
5042: PUSH
5043: LD_VAR 0 1
5047: PPUSH
5048: CALL_OW 266
5052: PUSH
5053: LD_INT 2
5055: EQUAL
5056: OR
5057: PUSH
5058: LD_VAR 0 1
5062: PPUSH
5063: CALL_OW 266
5067: PUSH
5068: LD_INT 4
5070: EQUAL
5071: OR
5072: PUSH
5073: EMPTY
5074: LIST
5075: AND
5076: IFFALSE 5087
// ComUpgrade ( building ) ;
5078: LD_VAR 0 1
5082: PPUSH
5083: CALL_OW 146
// end ;
5087: PPOPN 1
5089: END
// on VehicleConstructed ( vehicle , building ) do begin if GetSide ( vehicle ) = 3 then
5090: LD_VAR 0 1
5094: PPUSH
5095: CALL_OW 255
5099: PUSH
5100: LD_INT 3
5102: EQUAL
5103: IFFALSE 5121
// CPU1Tanks = CPU1Tanks ^ vehicle ;
5105: LD_ADDR_EXP 3
5109: PUSH
5110: LD_EXP 3
5114: PUSH
5115: LD_VAR 0 1
5119: ADD
5120: ST_TO_ADDR
// end ;
5121: PPOPN 2
5123: END
