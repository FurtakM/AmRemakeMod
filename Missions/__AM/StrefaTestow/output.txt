// export destroyedBuildings ; export cargoTest ; export vehicleDriverTab ; export arabianMines ; export JMM ; starting var i ; begin Resetfog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// destroyedBuildings = [ ] ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// cargoTest = [ ] ;
  15: LD_ADDR_EXP 2
  19: PUSH
  20: EMPTY
  21: ST_TO_ADDR
// arabianMines = [ ] ;
  22: LD_ADDR_EXP 4
  26: PUSH
  27: EMPTY
  28: ST_TO_ADDR
// end ;
  29: END
// export d ; every 0 0$01 do var un , un2 ;
  30: GO 32
  32: DISABLE
  33: LD_INT 0
  35: PPUSH
  36: PPUSH
// begin uc_side := 1 ;
  37: LD_ADDR_OWVAR 20
  41: PUSH
  42: LD_INT 1
  44: ST_TO_ADDR
// uc_nation := 2 ;
  45: LD_ADDR_OWVAR 21
  49: PUSH
  50: LD_INT 2
  52: ST_TO_ADDR
// hc_class := 1 ;
  53: LD_ADDR_OWVAR 28
  57: PUSH
  58: LD_INT 1
  60: ST_TO_ADDR
// hc_gallery :=  ;
  61: LD_ADDR_OWVAR 33
  65: PUSH
  66: LD_STRING 
  68: ST_TO_ADDR
// un := CreateHuman ;
  69: LD_ADDR_VAR 0 1
  73: PUSH
  74: CALL_OW 44
  78: ST_TO_ADDR
// d := CreateHuman ;
  79: LD_ADDR_EXP 6
  83: PUSH
  84: CALL_OW 44
  88: ST_TO_ADDR
// PlaceUnitXY ( un , 192 , 25 , false ) ;
  89: LD_VAR 0 1
  93: PPUSH
  94: LD_INT 192
  96: PPUSH
  97: LD_INT 25
  99: PPUSH
 100: LD_INT 0
 102: PPUSH
 103: CALL_OW 48
// PlaceUnitXY ( d , 190 , 25 , false ) ;
 107: LD_EXP 6
 111: PPUSH
 112: LD_INT 190
 114: PPUSH
 115: LD_INT 25
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: CALL_OW 48
// end ;
 125: PPOPN 2
 127: END
// every 0 0$01 do
 128: GO 130
 130: DISABLE
// begin enable ;
 131: ENABLE
// display_strings := WantPlant ( d ) ;
 132: LD_ADDR_OWVAR 47
 136: PUSH
 137: LD_EXP 6
 141: PPUSH
 142: CALL 148 0 1
 146: ST_TO_ADDR
// end ;
 147: END
// export function WantPlant ( unit ) ; var task ; begin
 148: LD_INT 0
 150: PPUSH
 151: PPUSH
// result := false ;
 152: LD_ADDR_VAR 0 2
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
 160: LD_ADDR_VAR 0 3
 164: PUSH
 165: LD_VAR 0 1
 169: PPUSH
 170: CALL_OW 437
 174: ST_TO_ADDR
// if task then
 175: LD_VAR 0 3
 179: IFFALSE 207
// if task [ 1 ] [ 1 ] = p then
 181: LD_VAR 0 3
 185: PUSH
 186: LD_INT 1
 188: ARRAY
 189: PUSH
 190: LD_INT 1
 192: ARRAY
 193: PUSH
 194: LD_STRING p
 196: EQUAL
 197: IFFALSE 207
// result := true ;
 199: LD_ADDR_VAR 0 2
 203: PUSH
 204: LD_INT 1
 206: ST_TO_ADDR
// end ;
 207: LD_VAR 0 2
 211: RET
// export function RemoveResourcesFromArea ( area , materials ) ; var amount , i , tmp ; begin
 212: LD_INT 0
 214: PPUSH
 215: PPUSH
 216: PPUSH
 217: PPUSH
// for i = 1 to 3 do
 218: LD_ADDR_VAR 0 5
 222: PUSH
 223: DOUBLE
 224: LD_INT 1
 226: DEC
 227: ST_TO_ADDR
 228: LD_INT 3
 230: PUSH
 231: FOR_TO
 232: IFFALSE 262
// amount := amount + GetResourceArea ( area , i ) ;
 234: LD_ADDR_VAR 0 4
 238: PUSH
 239: LD_VAR 0 4
 243: PUSH
 244: LD_VAR 0 1
 248: PPUSH
 249: LD_VAR 0 5
 253: PPUSH
 254: CALL_OW 287
 258: PLUS
 259: ST_TO_ADDR
 260: GO 231
 262: POP
 263: POP
// if amount < materials then
 264: LD_VAR 0 4
 268: PUSH
 269: LD_VAR 0 2
 273: LESS
 274: IFFALSE 278
// exit ;
 276: GO 312
// for i = 1 to 3 do
 278: LD_ADDR_VAR 0 5
 282: PUSH
 283: DOUBLE
 284: LD_INT 1
 286: DEC
 287: ST_TO_ADDR
 288: LD_INT 3
 290: PUSH
 291: FOR_TO
 292: IFFALSE 310
// EraseResourceArea ( area , i ) ;
 294: LD_VAR 0 1
 298: PPUSH
 299: LD_VAR 0 5
 303: PPUSH
 304: CALL_OW 286
 308: GO 291
 310: POP
 311: POP
// end ; end_of_file
 312: LD_VAR 0 3
 316: RET
// every 0 0$1 do
 317: GO 319
 319: DISABLE
// begin enable ;
 320: ENABLE
// RepairVehicles ( 3 , EnemyVehSpawn , 89 , 7 ) ;
 321: LD_INT 3
 323: PPUSH
 324: LD_INT 2
 326: PPUSH
 327: LD_INT 89
 329: PPUSH
 330: LD_INT 7
 332: PPUSH
 333: CALL 2607 0 4
// AttackVehicles ( 3 , EnemyVehSpawn , [ 213 , 115 , 96 ] , [ 13 , 14 , 8 ] ) ;
 337: LD_INT 3
 339: PPUSH
 340: LD_INT 2
 342: PPUSH
 343: LD_INT 213
 345: PUSH
 346: LD_INT 115
 348: PUSH
 349: LD_INT 96
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: PPUSH
 357: LD_INT 13
 359: PUSH
 360: LD_INT 14
 362: PUSH
 363: LD_INT 8
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL 2810 0 4
// end ;
 375: END
// every 5 5$1 do
 376: GO 378
 378: DISABLE
// begin BuildingVehicle ( 3 , rufab , 4 , [ 42 ] , 1 , 1 , 23 ) ;
 379: LD_INT 3
 381: PPUSH
 382: LD_INT 30
 384: PPUSH
 385: LD_INT 4
 387: PPUSH
 388: LD_INT 42
 390: PUSH
 391: EMPTY
 392: LIST
 393: PPUSH
 394: LD_INT 1
 396: PPUSH
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 23
 402: PPUSH
 403: CALL 2495 0 7
// end ;
 407: END
// every 0 0$1 do
 408: GO 410
 410: DISABLE
// begin RespawnAttackVehicle ( EnemyVehSpawn , 3 , 5 , 10 , nation_russian , engine_siberite , control_manual , [ 44 , 46 ] , [ ] , [ ] ) ;
 411: LD_INT 2
 413: PPUSH
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 5
 419: PPUSH
 420: LD_INT 10
 422: PPUSH
 423: LD_INT 3
 425: PPUSH
 426: LD_INT 3
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: LD_INT 44
 434: PUSH
 435: LD_INT 46
 437: PUSH
 438: EMPTY
 439: LIST
 440: LIST
 441: PPUSH
 442: EMPTY
 443: PPUSH
 444: EMPTY
 445: PPUSH
 446: CALL 989 0 10
// end ;
 450: END
// every 0 0$01 trigger arabianMines do var i , p ;
 451: LD_EXP 4
 455: IFFALSE 658
 457: GO 459
 459: DISABLE
 460: LD_INT 0
 462: PPUSH
 463: PPUSH
// begin enable ;
 464: ENABLE
// p := 1 ;
 465: LD_ADDR_VAR 0 2
 469: PUSH
 470: LD_INT 1
 472: ST_TO_ADDR
// for i = 1 to arabianMines / 2 do
 473: LD_ADDR_VAR 0 1
 477: PUSH
 478: DOUBLE
 479: LD_INT 1
 481: DEC
 482: ST_TO_ADDR
 483: LD_EXP 4
 487: PUSH
 488: LD_INT 2
 490: DIVREAL
 491: PUSH
 492: FOR_TO
 493: IFFALSE 656
// begin if FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_distxy , arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ] ] ) then
 495: LD_INT 81
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 92
 507: PUSH
 508: LD_EXP 4
 512: PUSH
 513: LD_VAR 0 2
 517: ARRAY
 518: PUSH
 519: LD_EXP 4
 523: PUSH
 524: LD_VAR 0 2
 528: PUSH
 529: LD_INT 1
 531: PLUS
 532: ARRAY
 533: PUSH
 534: LD_INT 2
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: PPUSH
 547: CALL_OW 69
 551: IFFALSE 640
// begin LaunchMineAtPos ( arabianMines [ p ] , arabianMines [ p + 1 ] , 2 ) ;
 553: LD_EXP 4
 557: PUSH
 558: LD_VAR 0 2
 562: ARRAY
 563: PPUSH
 564: LD_EXP 4
 568: PUSH
 569: LD_VAR 0 2
 573: PUSH
 574: LD_INT 1
 576: PLUS
 577: ARRAY
 578: PPUSH
 579: LD_INT 2
 581: PPUSH
 582: CALL_OW 456
// arabianMines := Delete ( arabianMines , p ) ;
 586: LD_ADDR_EXP 4
 590: PUSH
 591: LD_EXP 4
 595: PPUSH
 596: LD_VAR 0 2
 600: PPUSH
 601: CALL_OW 3
 605: ST_TO_ADDR
// arabianMines := Delete ( arabianMines , p ) ;
 606: LD_ADDR_EXP 4
 610: PUSH
 611: LD_EXP 4
 615: PPUSH
 616: LD_VAR 0 2
 620: PPUSH
 621: CALL_OW 3
 625: ST_TO_ADDR
// p := p - 2 ;
 626: LD_ADDR_VAR 0 2
 630: PUSH
 631: LD_VAR 0 2
 635: PUSH
 636: LD_INT 2
 638: MINUS
 639: ST_TO_ADDR
// end ; p := p + 2 ;
 640: LD_ADDR_VAR 0 2
 644: PUSH
 645: LD_VAR 0 2
 649: PUSH
 650: LD_INT 2
 652: PLUS
 653: ST_TO_ADDR
// end ;
 654: GO 492
 656: POP
 657: POP
// end ; end_of_file
 658: PPOPN 2
 660: END
// export function DialogRandom ( characters , dialogMID , dialogFID ) ; var i , rnd ; begin
 661: LD_INT 0
 663: PPUSH
 664: PPUSH
 665: PPUSH
// rnd = rand ( 1 , characters ) ;
 666: LD_ADDR_VAR 0 6
 670: PUSH
 671: LD_INT 1
 673: PPUSH
 674: LD_VAR 0 1
 678: PPUSH
 679: CALL_OW 12
 683: ST_TO_ADDR
// for i = 1 to characters do
 684: LD_ADDR_VAR 0 5
 688: PUSH
 689: DOUBLE
 690: LD_INT 1
 692: DEC
 693: ST_TO_ADDR
 694: LD_VAR 0 1
 698: PUSH
 699: FOR_TO
 700: IFFALSE 810
// begin if i = rnd and GetSex ( characters [ i ] ) = 1 then
 702: LD_VAR 0 5
 706: PUSH
 707: LD_VAR 0 6
 711: EQUAL
 712: PUSH
 713: LD_VAR 0 1
 717: PUSH
 718: LD_VAR 0 5
 722: ARRAY
 723: PPUSH
 724: CALL_OW 258
 728: PUSH
 729: LD_INT 1
 731: EQUAL
 732: AND
 733: IFFALSE 755
// Say ( characters [ i ] , dialogMID ) ;
 735: LD_VAR 0 1
 739: PUSH
 740: LD_VAR 0 5
 744: ARRAY
 745: PPUSH
 746: LD_VAR 0 2
 750: PPUSH
 751: CALL_OW 88
// if i = rnd and GetSex ( characters [ i ] ) = 2 then
 755: LD_VAR 0 5
 759: PUSH
 760: LD_VAR 0 6
 764: EQUAL
 765: PUSH
 766: LD_VAR 0 1
 770: PUSH
 771: LD_VAR 0 5
 775: ARRAY
 776: PPUSH
 777: CALL_OW 258
 781: PUSH
 782: LD_INT 2
 784: EQUAL
 785: AND
 786: IFFALSE 808
// Say ( characters [ i ] , dialogFID ) ;
 788: LD_VAR 0 1
 792: PUSH
 793: LD_VAR 0 5
 797: ARRAY
 798: PPUSH
 799: LD_VAR 0 3
 803: PPUSH
 804: CALL_OW 88
// end ;
 808: GO 699
 810: POP
 811: POP
// end ;
 812: LD_VAR 0 4
 816: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 817: LD_INT 0
 819: PPUSH
 820: PPUSH
 821: PPUSH
 822: PPUSH
// for i = 1 to count do
 823: LD_ADDR_VAR 0 8
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_VAR 0 6
 837: PUSH
 838: FOR_TO
 839: IFFALSE 920
// begin uc_side = side ;
 841: LD_ADDR_OWVAR 20
 845: PUSH
 846: LD_VAR 0 1
 850: ST_TO_ADDR
// uc_nation = nation ;
 851: LD_ADDR_OWVAR 21
 855: PUSH
 856: LD_VAR 0 2
 860: ST_TO_ADDR
// hc_gallery =  ;
 861: LD_ADDR_OWVAR 33
 865: PUSH
 866: LD_STRING 
 868: ST_TO_ADDR
// hc_name =  ;
 869: LD_ADDR_OWVAR 26
 873: PUSH
 874: LD_STRING 
 876: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 877: LD_INT 0
 879: PPUSH
 880: LD_VAR 0 5
 884: PPUSH
 885: LD_VAR 0 4
 889: PPUSH
 890: CALL_OW 380
// un = CreateHuman ;
 894: LD_ADDR_VAR 0 10
 898: PUSH
 899: CALL_OW 44
 903: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 904: LD_VAR 0 10
 908: PPUSH
 909: LD_VAR 0 3
 913: PPUSH
 914: CALL_OW 52
// end ;
 918: GO 838
 920: POP
 921: POP
// end ;
 922: LD_VAR 0 7
 926: RET
// export function EnchancedSaveCharacters ( charactersList , ident ) ; var i ; begin
 927: LD_INT 0
 929: PPUSH
 930: PPUSH
// for i in charactersList do
 931: LD_ADDR_VAR 0 4
 935: PUSH
 936: LD_VAR 0 1
 940: PUSH
 941: FOR_IN
 942: IFFALSE 982
// begin if IsOk ( i ) then
 944: LD_VAR 0 4
 948: PPUSH
 949: CALL_OW 302
 953: IFFALSE 971
// begin SaveCharacters ( i , ident ) ;
 955: LD_VAR 0 4
 959: PPUSH
 960: LD_VAR 0 2
 964: PPUSH
 965: CALL_OW 38
// end else
 969: GO 980
// begin DeleteCharacters ( ident ) ;
 971: LD_VAR 0 2
 975: PPUSH
 976: CALL_OW 40
// end ; end ;
 980: GO 941
 982: POP
 983: POP
// end ;
 984: LD_VAR 0 3
 988: RET
// export function RespawnAttackVehicle ( area , side , vehCount , mehskill , nation , vehEngine , vehControl , RUWeapons , ARWeapons , AMWeapon ) ; var i , j , un , veh , ruChassisTab , arChassisTab , amChassisTab , vehicleOK_list , target1 , target2 ; begin
 989: LD_INT 0
 991: PPUSH
 992: PPUSH
 993: PPUSH
 994: PPUSH
 995: PPUSH
 996: PPUSH
 997: PPUSH
 998: PPUSH
 999: PPUSH
1000: PPUSH
1001: PPUSH
// amChassisTab = [ ] ;
1002: LD_ADDR_VAR 0 18
1006: PUSH
1007: EMPTY
1008: ST_TO_ADDR
// arChassisTab = [ ] ;
1009: LD_ADDR_VAR 0 17
1013: PUSH
1014: EMPTY
1015: ST_TO_ADDR
// ruChassisTab = [ ] ;
1016: LD_ADDR_VAR 0 16
1020: PUSH
1021: EMPTY
1022: ST_TO_ADDR
// if nation = 1 then
1023: LD_VAR 0 5
1027: PUSH
1028: LD_INT 1
1030: EQUAL
1031: IFFALSE 1448
// begin for i := 1 to vehCount do
1033: LD_ADDR_VAR 0 12
1037: PUSH
1038: DOUBLE
1039: LD_INT 1
1041: DEC
1042: ST_TO_ADDR
1043: LD_VAR 0 3
1047: PUSH
1048: FOR_TO
1049: IFFALSE 1446
// begin uc_side = side ;
1051: LD_ADDR_OWVAR 20
1055: PUSH
1056: LD_VAR 0 2
1060: ST_TO_ADDR
// uc_nation = nation ;
1061: LD_ADDR_OWVAR 21
1065: PUSH
1066: LD_VAR 0 5
1070: ST_TO_ADDR
// vc_engine = vehengine ;
1071: LD_ADDR_OWVAR 39
1075: PUSH
1076: LD_VAR 0 6
1080: ST_TO_ADDR
// vc_control = vehcontrol ;
1081: LD_ADDR_OWVAR 38
1085: PUSH
1086: LD_VAR 0 7
1090: ST_TO_ADDR
// vc_weapon = AMWeapon [ Rand ( 1 , AMWeapon ) ] ;
1091: LD_ADDR_OWVAR 40
1095: PUSH
1096: LD_VAR 0 10
1100: PUSH
1101: LD_INT 1
1103: PPUSH
1104: LD_VAR 0 10
1108: PPUSH
1109: CALL_OW 12
1113: ARRAY
1114: ST_TO_ADDR
// if vc_weapon = 2 or vc_weapon = 3 then
1115: LD_OWVAR 40
1119: PUSH
1120: LD_INT 2
1122: EQUAL
1123: PUSH
1124: LD_OWVAR 40
1128: PUSH
1129: LD_INT 3
1131: EQUAL
1132: OR
1133: IFFALSE 1186
// begin amChassisTab = [ 1 , 2 , 3 , 4 , 5 ] ;
1135: LD_ADDR_VAR 0 18
1139: PUSH
1140: LD_INT 1
1142: PUSH
1143: LD_INT 2
1145: PUSH
1146: LD_INT 3
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: LD_INT 5
1154: PUSH
1155: EMPTY
1156: LIST
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1162: LD_ADDR_OWVAR 37
1166: PUSH
1167: LD_VAR 0 18
1171: PUSH
1172: LD_INT 1
1174: PPUSH
1175: LD_VAR 0 18
1179: PPUSH
1180: CALL_OW 12
1184: ARRAY
1185: ST_TO_ADDR
// end ; if vc_weapon = 4 or vc_weapon = 5 or vc_weapon = 9 or vc_weapon = 11 or vc_weapon = 7 then
1186: LD_OWVAR 40
1190: PUSH
1191: LD_INT 4
1193: EQUAL
1194: PUSH
1195: LD_OWVAR 40
1199: PUSH
1200: LD_INT 5
1202: EQUAL
1203: OR
1204: PUSH
1205: LD_OWVAR 40
1209: PUSH
1210: LD_INT 9
1212: EQUAL
1213: OR
1214: PUSH
1215: LD_OWVAR 40
1219: PUSH
1220: LD_INT 11
1222: EQUAL
1223: OR
1224: PUSH
1225: LD_OWVAR 40
1229: PUSH
1230: LD_INT 7
1232: EQUAL
1233: OR
1234: IFFALSE 1283
// begin amChassisTab = [ 2 , 3 , 4 , 5 ] ;
1236: LD_ADDR_VAR 0 18
1240: PUSH
1241: LD_INT 2
1243: PUSH
1244: LD_INT 3
1246: PUSH
1247: LD_INT 4
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1259: LD_ADDR_OWVAR 37
1263: PUSH
1264: LD_VAR 0 18
1268: PUSH
1269: LD_INT 1
1271: PPUSH
1272: LD_VAR 0 18
1276: PPUSH
1277: CALL_OW 12
1281: ARRAY
1282: ST_TO_ADDR
// end ; if vc_weapon = 8 or vc_weapon = 6 or vc_weapon = 10 then
1283: LD_OWVAR 40
1287: PUSH
1288: LD_INT 8
1290: EQUAL
1291: PUSH
1292: LD_OWVAR 40
1296: PUSH
1297: LD_INT 6
1299: EQUAL
1300: OR
1301: PUSH
1302: LD_OWVAR 40
1306: PUSH
1307: LD_INT 10
1309: EQUAL
1310: OR
1311: IFFALSE 1352
// begin amChassisTab = [ 4 , 5 ] ;
1313: LD_ADDR_VAR 0 18
1317: PUSH
1318: LD_INT 4
1320: PUSH
1321: LD_INT 5
1323: PUSH
1324: EMPTY
1325: LIST
1326: LIST
1327: ST_TO_ADDR
// vc_chassis = amChassisTab [ Rand ( 1 , amChassisTab ) ] ;
1328: LD_ADDR_OWVAR 37
1332: PUSH
1333: LD_VAR 0 18
1337: PUSH
1338: LD_INT 1
1340: PPUSH
1341: LD_VAR 0 18
1345: PPUSH
1346: CALL_OW 12
1350: ARRAY
1351: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1352: LD_ADDR_VAR 0 15
1356: PUSH
1357: CALL_OW 45
1361: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1362: LD_VAR 0 15
1366: PPUSH
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 0
1374: PPUSH
1375: CALL_OW 49
// if vehcontrol = 1 then
1379: LD_VAR 0 7
1383: PUSH
1384: LD_INT 1
1386: EQUAL
1387: IFFALSE 1444
// begin hc_gallery =  ;
1389: LD_ADDR_OWVAR 33
1393: PUSH
1394: LD_STRING 
1396: ST_TO_ADDR
// hc_name =  ;
1397: LD_ADDR_OWVAR 26
1401: PUSH
1402: LD_STRING 
1404: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1405: LD_INT 0
1407: PPUSH
1408: LD_INT 3
1410: PPUSH
1411: LD_VAR 0 4
1415: PPUSH
1416: CALL_OW 380
// un = CreateHuman ;
1420: LD_ADDR_VAR 0 14
1424: PUSH
1425: CALL_OW 44
1429: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1430: LD_VAR 0 14
1434: PPUSH
1435: LD_VAR 0 15
1439: PPUSH
1440: CALL_OW 52
// end ; end ;
1444: GO 1048
1446: POP
1447: POP
// end ; if nation = 2 then
1448: LD_VAR 0 5
1452: PUSH
1453: LD_INT 2
1455: EQUAL
1456: IFFALSE 1812
// begin for i := 1 to vehCount do
1458: LD_ADDR_VAR 0 12
1462: PUSH
1463: DOUBLE
1464: LD_INT 1
1466: DEC
1467: ST_TO_ADDR
1468: LD_VAR 0 3
1472: PUSH
1473: FOR_TO
1474: IFFALSE 1810
// begin uc_side = side ;
1476: LD_ADDR_OWVAR 20
1480: PUSH
1481: LD_VAR 0 2
1485: ST_TO_ADDR
// uc_nation = nation ;
1486: LD_ADDR_OWVAR 21
1490: PUSH
1491: LD_VAR 0 5
1495: ST_TO_ADDR
// vc_engine = vehengine ;
1496: LD_ADDR_OWVAR 39
1500: PUSH
1501: LD_VAR 0 6
1505: ST_TO_ADDR
// vc_control = vehcontrol ;
1506: LD_ADDR_OWVAR 38
1510: PUSH
1511: LD_VAR 0 7
1515: ST_TO_ADDR
// vc_weapon = ARWeapons [ Rand ( 1 , ARWeapons ) ] ;
1516: LD_ADDR_OWVAR 40
1520: PUSH
1521: LD_VAR 0 9
1525: PUSH
1526: LD_INT 1
1528: PPUSH
1529: LD_VAR 0 9
1533: PPUSH
1534: CALL_OW 12
1538: ARRAY
1539: ST_TO_ADDR
// if vc_weapon = 24 or vc_weapon = 22 or vc_weapon = 23 or vc_weapon = 30 then
1540: LD_OWVAR 40
1544: PUSH
1545: LD_INT 24
1547: EQUAL
1548: PUSH
1549: LD_OWVAR 40
1553: PUSH
1554: LD_INT 22
1556: EQUAL
1557: OR
1558: PUSH
1559: LD_OWVAR 40
1563: PUSH
1564: LD_INT 23
1566: EQUAL
1567: OR
1568: PUSH
1569: LD_OWVAR 40
1573: PUSH
1574: LD_INT 30
1576: EQUAL
1577: OR
1578: IFFALSE 1627
// begin arChassisTab = [ 11 , 12 , 13 , 14 ] ;
1580: LD_ADDR_VAR 0 17
1584: PUSH
1585: LD_INT 11
1587: PUSH
1588: LD_INT 12
1590: PUSH
1591: LD_INT 13
1593: PUSH
1594: LD_INT 14
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1603: LD_ADDR_OWVAR 37
1607: PUSH
1608: LD_VAR 0 17
1612: PUSH
1613: LD_INT 1
1615: PPUSH
1616: LD_VAR 0 17
1620: PPUSH
1621: CALL_OW 12
1625: ARRAY
1626: ST_TO_ADDR
// end ; if vc_weapon = 29 or vc_weapon = 28 or vc_weapon = 27 or vc_weapon = 26 or vc_weapon = 25 then
1627: LD_OWVAR 40
1631: PUSH
1632: LD_INT 29
1634: EQUAL
1635: PUSH
1636: LD_OWVAR 40
1640: PUSH
1641: LD_INT 28
1643: EQUAL
1644: OR
1645: PUSH
1646: LD_OWVAR 40
1650: PUSH
1651: LD_INT 27
1653: EQUAL
1654: OR
1655: PUSH
1656: LD_OWVAR 40
1660: PUSH
1661: LD_INT 26
1663: EQUAL
1664: OR
1665: PUSH
1666: LD_OWVAR 40
1670: PUSH
1671: LD_INT 25
1673: EQUAL
1674: OR
1675: IFFALSE 1716
// begin arChassisTab = [ 13 , 14 ] ;
1677: LD_ADDR_VAR 0 17
1681: PUSH
1682: LD_INT 13
1684: PUSH
1685: LD_INT 14
1687: PUSH
1688: EMPTY
1689: LIST
1690: LIST
1691: ST_TO_ADDR
// vc_chassis = arChassisTab [ Rand ( 1 , arChassisTab ) ] ;
1692: LD_ADDR_OWVAR 37
1696: PUSH
1697: LD_VAR 0 17
1701: PUSH
1702: LD_INT 1
1704: PPUSH
1705: LD_VAR 0 17
1709: PPUSH
1710: CALL_OW 12
1714: ARRAY
1715: ST_TO_ADDR
// end ; veh = CreateVehicle ;
1716: LD_ADDR_VAR 0 15
1720: PUSH
1721: CALL_OW 45
1725: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
1726: LD_VAR 0 15
1730: PPUSH
1731: LD_VAR 0 1
1735: PPUSH
1736: LD_INT 0
1738: PPUSH
1739: CALL_OW 49
// if vehcontrol = 1 then
1743: LD_VAR 0 7
1747: PUSH
1748: LD_INT 1
1750: EQUAL
1751: IFFALSE 1808
// begin hc_gallery =  ;
1753: LD_ADDR_OWVAR 33
1757: PUSH
1758: LD_STRING 
1760: ST_TO_ADDR
// hc_name =  ;
1761: LD_ADDR_OWVAR 26
1765: PUSH
1766: LD_STRING 
1768: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
1769: LD_INT 0
1771: PPUSH
1772: LD_INT 3
1774: PPUSH
1775: LD_VAR 0 4
1779: PPUSH
1780: CALL_OW 380
// un = CreateHuman ;
1784: LD_ADDR_VAR 0 14
1788: PUSH
1789: CALL_OW 44
1793: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
1794: LD_VAR 0 14
1798: PPUSH
1799: LD_VAR 0 15
1803: PPUSH
1804: CALL_OW 52
// end ; end ;
1808: GO 1473
1810: POP
1811: POP
// end ; if nation = 3 then
1812: LD_VAR 0 5
1816: PUSH
1817: LD_INT 3
1819: EQUAL
1820: IFFALSE 2178
// begin for i := 1 to vehCount do
1822: LD_ADDR_VAR 0 12
1826: PUSH
1827: DOUBLE
1828: LD_INT 1
1830: DEC
1831: ST_TO_ADDR
1832: LD_VAR 0 3
1836: PUSH
1837: FOR_TO
1838: IFFALSE 2176
// begin uc_side = side ;
1840: LD_ADDR_OWVAR 20
1844: PUSH
1845: LD_VAR 0 2
1849: ST_TO_ADDR
// uc_nation = nation ;
1850: LD_ADDR_OWVAR 21
1854: PUSH
1855: LD_VAR 0 5
1859: ST_TO_ADDR
// vc_engine = vehengine ;
1860: LD_ADDR_OWVAR 39
1864: PUSH
1865: LD_VAR 0 6
1869: ST_TO_ADDR
// vc_control = vehcontrol ;
1870: LD_ADDR_OWVAR 38
1874: PUSH
1875: LD_VAR 0 7
1879: ST_TO_ADDR
// vc_weapon = RUWeapons [ Rand ( 1 , RUWeapons ) ] ;
1880: LD_ADDR_OWVAR 40
1884: PUSH
1885: LD_VAR 0 8
1889: PUSH
1890: LD_INT 1
1892: PPUSH
1893: LD_VAR 0 8
1897: PPUSH
1898: CALL_OW 12
1902: ARRAY
1903: ST_TO_ADDR
// for j = 1 to RuWeapons do
1904: LD_ADDR_VAR 0 13
1908: PUSH
1909: DOUBLE
1910: LD_INT 1
1912: DEC
1913: ST_TO_ADDR
1914: LD_VAR 0 8
1918: PUSH
1919: FOR_TO
1920: IFFALSE 2080
// begin if vc_weapon = 42 or vc_weapon = 43 or vc_weapon = 44 or vc_weapon = 45 or vc_weapon = 49 then
1922: LD_OWVAR 40
1926: PUSH
1927: LD_INT 42
1929: EQUAL
1930: PUSH
1931: LD_OWVAR 40
1935: PUSH
1936: LD_INT 43
1938: EQUAL
1939: OR
1940: PUSH
1941: LD_OWVAR 40
1945: PUSH
1946: LD_INT 44
1948: EQUAL
1949: OR
1950: PUSH
1951: LD_OWVAR 40
1955: PUSH
1956: LD_INT 45
1958: EQUAL
1959: OR
1960: PUSH
1961: LD_OWVAR 40
1965: PUSH
1966: LD_INT 49
1968: EQUAL
1969: OR
1970: IFFALSE 2019
// begin ruChassisTab = [ 21 , 22 , 23 , 24 ] ;
1972: LD_ADDR_VAR 0 16
1976: PUSH
1977: LD_INT 21
1979: PUSH
1980: LD_INT 22
1982: PUSH
1983: LD_INT 23
1985: PUSH
1986: LD_INT 24
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: LIST
1993: LIST
1994: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 16
2004: PUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_VAR 0 16
2012: PPUSH
2013: CALL_OW 12
2017: ARRAY
2018: ST_TO_ADDR
// end ; if vc_weapon = 46 or vc_weapon = 47 then
2019: LD_OWVAR 40
2023: PUSH
2024: LD_INT 46
2026: EQUAL
2027: PUSH
2028: LD_OWVAR 40
2032: PUSH
2033: LD_INT 47
2035: EQUAL
2036: OR
2037: IFFALSE 2078
// begin ruChassisTab = [ 23 , 24 ] ;
2039: LD_ADDR_VAR 0 16
2043: PUSH
2044: LD_INT 23
2046: PUSH
2047: LD_INT 24
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: ST_TO_ADDR
// vc_chassis = ruChassisTab [ Rand ( 1 , ruChassisTab ) ] ;
2054: LD_ADDR_OWVAR 37
2058: PUSH
2059: LD_VAR 0 16
2063: PUSH
2064: LD_INT 1
2066: PPUSH
2067: LD_VAR 0 16
2071: PPUSH
2072: CALL_OW 12
2076: ARRAY
2077: ST_TO_ADDR
// end ; end ;
2078: GO 1919
2080: POP
2081: POP
// veh = CreateVehicle ;
2082: LD_ADDR_VAR 0 15
2086: PUSH
2087: CALL_OW 45
2091: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2092: LD_VAR 0 15
2096: PPUSH
2097: LD_VAR 0 1
2101: PPUSH
2102: LD_INT 0
2104: PPUSH
2105: CALL_OW 49
// if vehcontrol = 1 then
2109: LD_VAR 0 7
2113: PUSH
2114: LD_INT 1
2116: EQUAL
2117: IFFALSE 2174
// begin hc_gallery =  ;
2119: LD_ADDR_OWVAR 33
2123: PUSH
2124: LD_STRING 
2126: ST_TO_ADDR
// hc_name =  ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING 
2134: ST_TO_ADDR
// PrepareHuman ( false , 3 , mehskill ) ;
2135: LD_INT 0
2137: PPUSH
2138: LD_INT 3
2140: PPUSH
2141: LD_VAR 0 4
2145: PPUSH
2146: CALL_OW 380
// un = CreateHuman ;
2150: LD_ADDR_VAR 0 14
2154: PUSH
2155: CALL_OW 44
2159: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
2160: LD_VAR 0 14
2164: PPUSH
2165: LD_VAR 0 15
2169: PPUSH
2170: CALL_OW 52
// end ; end ;
2174: GO 1837
2176: POP
2177: POP
// end ; repeat wait ( 0 0$1 ) ;
2178: LD_INT 35
2180: PPUSH
2181: CALL_OW 67
// vehicleOK_list = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2185: LD_ADDR_VAR 0 19
2189: PUSH
2190: LD_INT 22
2192: PUSH
2193: LD_VAR 0 2
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: PUSH
2202: LD_INT 21
2204: PUSH
2205: LD_INT 2
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 24
2214: PUSH
2215: LD_INT 650
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: LIST
2226: PPUSH
2227: CALL_OW 69
2231: ST_TO_ADDR
// if vehicleOK_list > 0 then
2232: LD_VAR 0 19
2236: PUSH
2237: LD_INT 0
2239: GREATER
2240: IFFALSE 2431
// begin for i in vehicleOK_list do
2242: LD_ADDR_VAR 0 12
2246: PUSH
2247: LD_VAR 0 19
2251: PUSH
2252: FOR_IN
2253: IFFALSE 2429
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , side ] ) , i ) ;
2255: LD_ADDR_VAR 0 20
2259: PUSH
2260: LD_INT 81
2262: PUSH
2263: LD_VAR 0 2
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: PPUSH
2277: LD_VAR 0 12
2281: PPUSH
2282: CALL_OW 74
2286: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
2287: LD_ADDR_VAR 0 21
2291: PUSH
2292: LD_INT 81
2294: PUSH
2295: LD_VAR 0 2
2299: PUSH
2300: EMPTY
2301: LIST
2302: LIST
2303: PUSH
2304: LD_INT 2
2306: PUSH
2307: LD_INT 59
2309: PUSH
2310: EMPTY
2311: LIST
2312: PUSH
2313: LD_INT 21
2315: PUSH
2316: LD_INT 1
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: LD_INT 21
2325: PUSH
2326: LD_INT 2
2328: PUSH
2329: EMPTY
2330: LIST
2331: LIST
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: LIST
2337: LIST
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: PUSH
2343: EMPTY
2344: LIST
2345: PPUSH
2346: CALL_OW 69
2350: PPUSH
2351: LD_VAR 0 12
2355: PPUSH
2356: CALL_OW 74
2360: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
2361: LD_VAR 0 12
2365: PPUSH
2366: LD_VAR 0 20
2370: PPUSH
2371: CALL_OW 296
2375: PUSH
2376: LD_INT 8
2378: PLUS
2379: PUSH
2380: LD_VAR 0 12
2384: PPUSH
2385: LD_VAR 0 21
2389: PPUSH
2390: CALL_OW 296
2394: LESS
2395: IFFALSE 2413
// ComAttackUnit ( i , target1 ) else
2397: LD_VAR 0 12
2401: PPUSH
2402: LD_VAR 0 20
2406: PPUSH
2407: CALL_OW 115
2411: GO 2427
// ComAttackUnit ( i , target2 ) ;
2413: LD_VAR 0 12
2417: PPUSH
2418: LD_VAR 0 21
2422: PPUSH
2423: CALL_OW 115
// end ;
2427: GO 2252
2429: POP
2430: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 250 ] , [ f_empty ] ] ) = 0 ;
2431: LD_INT 22
2433: PUSH
2434: LD_VAR 0 2
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 21
2445: PUSH
2446: LD_INT 2
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 250
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: LD_INT 58
2465: PUSH
2466: EMPTY
2467: LIST
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: LIST
2473: LIST
2474: PPUSH
2475: CALL_OW 69
2479: PUSH
2480: LD_INT 0
2482: EQUAL
2483: IFFALSE 2178
// end ;
2485: LD_VAR 0 11
2489: RET
// every 0 0$1 do
2490: GO 2492
2492: DISABLE
// begin enable ;
2493: ENABLE
// end ;
2494: END
// export function BuildingVehicle ( side , fabric , vehCount , weaponTab , engine , control , chassis ) ; var i ; begin
2495: LD_INT 0
2497: PPUSH
2498: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) <= vehCount then
2499: LD_INT 22
2501: PUSH
2502: LD_VAR 0 1
2506: PUSH
2507: EMPTY
2508: LIST
2509: LIST
2510: PUSH
2511: LD_INT 21
2513: PUSH
2514: LD_INT 2
2516: PUSH
2517: EMPTY
2518: LIST
2519: LIST
2520: PUSH
2521: EMPTY
2522: LIST
2523: LIST
2524: PPUSH
2525: CALL_OW 69
2529: PUSH
2530: LD_VAR 0 3
2534: LESSEQUAL
2535: IFFALSE 2602
// for i = 1 to vehCount do
2537: LD_ADDR_VAR 0 9
2541: PUSH
2542: DOUBLE
2543: LD_INT 1
2545: DEC
2546: ST_TO_ADDR
2547: LD_VAR 0 3
2551: PUSH
2552: FOR_TO
2553: IFFALSE 2600
// AddComConstruct ( fabric , chassis , engine , control , weaponTab [ Rand ( 1 , weaponTab ) ] ) ;
2555: LD_VAR 0 2
2559: PPUSH
2560: LD_VAR 0 7
2564: PPUSH
2565: LD_VAR 0 5
2569: PPUSH
2570: LD_VAR 0 6
2574: PPUSH
2575: LD_VAR 0 4
2579: PUSH
2580: LD_INT 1
2582: PPUSH
2583: LD_VAR 0 4
2587: PPUSH
2588: CALL_OW 12
2592: ARRAY
2593: PPUSH
2594: CALL_OW 185
2598: GO 2552
2600: POP
2601: POP
// end ;
2602: LD_VAR 0 8
2606: RET
// export function RepairVehicles ( side , area , repX , repY ) ; var i , j , damageVehicles ; begin
2607: LD_INT 0
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// damageVehicles = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
2613: LD_ADDR_VAR 0 8
2617: PUSH
2618: LD_INT 22
2620: PUSH
2621: LD_VAR 0 1
2625: PUSH
2626: EMPTY
2627: LIST
2628: LIST
2629: PUSH
2630: LD_INT 21
2632: PUSH
2633: LD_INT 2
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: PUSH
2640: LD_INT 3
2642: PUSH
2643: LD_INT 24
2645: PUSH
2646: LD_INT 650
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: LIST
2661: PPUSH
2662: CALL_OW 69
2666: ST_TO_ADDR
// if damageVehicles > 0 then
2667: LD_VAR 0 8
2671: PUSH
2672: LD_INT 0
2674: GREATER
2675: IFFALSE 2696
// ComMoveXY ( damageVehicles , repX , repY ) ;
2677: LD_VAR 0 8
2681: PPUSH
2682: LD_VAR 0 3
2686: PPUSH
2687: LD_VAR 0 4
2691: PPUSH
2692: CALL_OW 111
// if UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) > 0 then
2696: LD_VAR 0 8
2700: PPUSH
2701: LD_INT 95
2703: PUSH
2704: LD_VAR 0 2
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: PUSH
2713: LD_INT 3
2715: PUSH
2716: LD_INT 58
2718: PUSH
2719: EMPTY
2720: LIST
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL_OW 72
2734: PUSH
2735: LD_INT 0
2737: GREATER
2738: IFFALSE 2805
// for i in UnitFilter ( damageVehicles , [ [ f_inarea , area ] , [ f_not , [ f_empty ] ] ] ) do
2740: LD_ADDR_VAR 0 6
2744: PUSH
2745: LD_VAR 0 8
2749: PPUSH
2750: LD_INT 95
2752: PUSH
2753: LD_VAR 0 2
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 3
2764: PUSH
2765: LD_INT 58
2767: PUSH
2768: EMPTY
2769: LIST
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PPUSH
2779: CALL_OW 72
2783: PUSH
2784: FOR_IN
2785: IFFALSE 2803
// ComExitVehicle ( UnitsInside ( i ) ) ;
2787: LD_VAR 0 6
2791: PPUSH
2792: CALL_OW 313
2796: PPUSH
2797: CALL_OW 121
2801: GO 2784
2803: POP
2804: POP
// end ;
2805: LD_VAR 0 5
2809: RET
// export function AttackVehicles ( side , meetArea , wayX , wayY ) ; var i , j , vehiclesOK , target1 , target2 , seeEnemy ; begin
2810: LD_INT 0
2812: PPUSH
2813: PPUSH
2814: PPUSH
2815: PPUSH
2816: PPUSH
2817: PPUSH
2818: PPUSH
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2819: LD_ADDR_VAR 0 8
2823: PUSH
2824: LD_INT 22
2826: PUSH
2827: LD_VAR 0 1
2831: PUSH
2832: EMPTY
2833: LIST
2834: LIST
2835: PUSH
2836: LD_INT 21
2838: PUSH
2839: LD_INT 2
2841: PUSH
2842: EMPTY
2843: LIST
2844: LIST
2845: PUSH
2846: LD_INT 24
2848: PUSH
2849: LD_INT 650
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 5 then
2866: LD_INT 22
2868: PUSH
2869: LD_VAR 0 1
2873: PUSH
2874: EMPTY
2875: LIST
2876: LIST
2877: PUSH
2878: LD_INT 21
2880: PUSH
2881: LD_INT 2
2883: PUSH
2884: EMPTY
2885: LIST
2886: LIST
2887: PUSH
2888: LD_INT 24
2890: PUSH
2891: LD_INT 1000
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: LIST
2902: PPUSH
2903: CALL_OW 69
2907: PUSH
2908: LD_INT 5
2910: EQUAL
2911: IFFALSE 3378
// repeat wait ( 0 0$1 ) ;
2913: LD_INT 35
2915: PPUSH
2916: CALL_OW 67
// display_strings = seeEnemy ;
2920: LD_ADDR_OWVAR 47
2924: PUSH
2925: LD_VAR 0 11
2929: ST_TO_ADDR
// vehiclesOK = FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] ] ) ;
2930: LD_ADDR_VAR 0 8
2934: PUSH
2935: LD_INT 22
2937: PUSH
2938: LD_VAR 0 1
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 21
2949: PUSH
2950: LD_INT 2
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: PUSH
2957: LD_INT 24
2959: PUSH
2960: LD_INT 650
2962: PUSH
2963: EMPTY
2964: LIST
2965: LIST
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: LIST
2971: PPUSH
2972: CALL_OW 69
2976: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) and seeEnemy = 0 then
2977: LD_INT 22
2979: PUSH
2980: LD_VAR 0 1
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 95
2991: PUSH
2992: LD_VAR 0 2
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL_OW 69
3009: NOT
3010: PUSH
3011: LD_VAR 0 11
3015: PUSH
3016: LD_INT 0
3018: EQUAL
3019: AND
3020: IFFALSE 3075
// for i := 1 to wayX do
3022: LD_ADDR_VAR 0 6
3026: PUSH
3027: DOUBLE
3028: LD_INT 1
3030: DEC
3031: ST_TO_ADDR
3032: LD_VAR 0 3
3036: PUSH
3037: FOR_TO
3038: IFFALSE 3073
// AddComAgressiveMove ( vehiclesOK , wayX [ i ] , wayY [ i ] ) ;
3040: LD_VAR 0 8
3044: PPUSH
3045: LD_VAR 0 3
3049: PUSH
3050: LD_VAR 0 6
3054: ARRAY
3055: PPUSH
3056: LD_VAR 0 4
3060: PUSH
3061: LD_VAR 0 6
3065: ARRAY
3066: PPUSH
3067: CALL_OW 174
3071: GO 3037
3073: POP
3074: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_inarea , meetArea ] ] ) then
3075: LD_INT 22
3077: PUSH
3078: LD_VAR 0 1
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PUSH
3087: LD_INT 95
3089: PUSH
3090: LD_VAR 0 2
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: PUSH
3099: EMPTY
3100: LIST
3101: LIST
3102: PPUSH
3103: CALL_OW 69
3107: IFFALSE 3331
// begin seeEnemy = 1 ;
3109: LD_ADDR_VAR 0 11
3113: PUSH
3114: LD_INT 1
3116: ST_TO_ADDR
// for j in vehiclesOK do
3117: LD_ADDR_VAR 0 7
3121: PUSH
3122: LD_VAR 0 8
3126: PUSH
3127: FOR_IN
3128: IFFALSE 3329
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , side ] , [ f_see , 1 ] ] ) , j ) ;
3130: LD_ADDR_VAR 0 9
3134: PUSH
3135: LD_INT 81
3137: PUSH
3138: LD_VAR 0 1
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 101
3149: PUSH
3150: LD_INT 1
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PPUSH
3161: CALL_OW 69
3165: PPUSH
3166: LD_VAR 0 7
3170: PPUSH
3171: CALL_OW 74
3175: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_enemy , side ] , [ f_see , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , j ) ;
3176: LD_ADDR_VAR 0 10
3180: PUSH
3181: LD_INT 81
3183: PUSH
3184: LD_VAR 0 1
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: PUSH
3193: LD_INT 101
3195: PUSH
3196: LD_INT 1
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: PUSH
3203: LD_INT 2
3205: PUSH
3206: LD_INT 59
3208: PUSH
3209: EMPTY
3210: LIST
3211: PUSH
3212: LD_INT 21
3214: PUSH
3215: LD_INT 1
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 21
3224: PUSH
3225: LD_INT 2
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: LIST
3242: PUSH
3243: EMPTY
3244: LIST
3245: PPUSH
3246: CALL_OW 69
3250: PPUSH
3251: LD_VAR 0 7
3255: PPUSH
3256: CALL_OW 74
3260: ST_TO_ADDR
// if GetDistUnits ( j , target1 ) + 8 < GetDistUnits ( j , target2 ) then
3261: LD_VAR 0 7
3265: PPUSH
3266: LD_VAR 0 9
3270: PPUSH
3271: CALL_OW 296
3275: PUSH
3276: LD_INT 8
3278: PLUS
3279: PUSH
3280: LD_VAR 0 7
3284: PPUSH
3285: LD_VAR 0 10
3289: PPUSH
3290: CALL_OW 296
3294: LESS
3295: IFFALSE 3313
// ComAttackUnit ( j , target1 ) else
3297: LD_VAR 0 7
3301: PPUSH
3302: LD_VAR 0 9
3306: PPUSH
3307: CALL_OW 115
3311: GO 3327
// ComAttackUnit ( j , target2 ) ;
3313: LD_VAR 0 7
3317: PPUSH
3318: LD_VAR 0 10
3322: PPUSH
3323: CALL_OW 115
// end ;
3327: GO 3127
3329: POP
3330: POP
// end ; until FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 1000 ] ] ) = 0 ;
3331: LD_INT 22
3333: PUSH
3334: LD_VAR 0 1
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 21
3345: PUSH
3346: LD_INT 2
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 24
3355: PUSH
3356: LD_INT 1000
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: PUSH
3373: LD_INT 0
3375: EQUAL
3376: IFFALSE 2913
// seeEnemy = 0 ;
3378: LD_ADDR_VAR 0 11
3382: PUSH
3383: LD_INT 0
3385: ST_TO_ADDR
// end ;
3386: LD_VAR 0 5
3390: RET
// export function RebuildBuildings ( side , destroyedBuildings ) ; var i ; begin
3391: LD_INT 0
3393: PPUSH
3394: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) > 0 and FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 and destroyedBuildings > 0 then
3395: LD_INT 22
3397: PUSH
3398: LD_VAR 0 1
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: PUSH
3407: LD_INT 25
3409: PUSH
3410: LD_INT 2
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: PUSH
3417: EMPTY
3418: LIST
3419: LIST
3420: PPUSH
3421: CALL_OW 69
3425: PUSH
3426: LD_INT 0
3428: GREATER
3429: PUSH
3430: LD_INT 22
3432: PUSH
3433: LD_VAR 0 1
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: LD_INT 21
3444: PUSH
3445: LD_INT 3
3447: PUSH
3448: EMPTY
3449: LIST
3450: LIST
3451: PUSH
3452: LD_INT 3
3454: PUSH
3455: LD_INT 24
3457: PUSH
3458: LD_INT 1000
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PUSH
3469: EMPTY
3470: LIST
3471: LIST
3472: LIST
3473: PPUSH
3474: CALL_OW 69
3478: PUSH
3479: LD_INT 0
3481: EQUAL
3482: AND
3483: PUSH
3484: LD_VAR 0 2
3488: PUSH
3489: LD_INT 0
3491: GREATER
3492: AND
3493: IFFALSE 3592
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) do
3495: LD_ADDR_VAR 0 4
3499: PUSH
3500: LD_INT 22
3502: PUSH
3503: LD_VAR 0 1
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: PUSH
3512: LD_INT 25
3514: PUSH
3515: LD_INT 2
3517: PUSH
3518: EMPTY
3519: LIST
3520: LIST
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: PPUSH
3526: CALL_OW 69
3530: PUSH
3531: FOR_IN
3532: IFFALSE 3590
// begin AddComExitBuilding ( i ) ;
3534: LD_VAR 0 4
3538: PPUSH
3539: CALL_OW 182
// AddComBuild ( i , destroyedBuildings [ 1 ] , destroyedBuildings [ 2 ] , destroyedBuildings [ 3 ] , destroyedBuildings [ 4 ] ) ;
3543: LD_VAR 0 4
3547: PPUSH
3548: LD_VAR 0 2
3552: PUSH
3553: LD_INT 1
3555: ARRAY
3556: PPUSH
3557: LD_VAR 0 2
3561: PUSH
3562: LD_INT 2
3564: ARRAY
3565: PPUSH
3566: LD_VAR 0 2
3570: PUSH
3571: LD_INT 3
3573: ARRAY
3574: PPUSH
3575: LD_VAR 0 2
3579: PUSH
3580: LD_INT 4
3582: ARRAY
3583: PPUSH
3584: CALL_OW 205
// end ;
3588: GO 3531
3590: POP
3591: POP
// end ; end ;
3592: LD_VAR 0 3
3596: RET
// export function AttackNearBuildings ( side , enemySide ) ; var i , j , turretsList , enemyBuildings ; begin
3597: LD_INT 0
3599: PPUSH
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
// turretsList = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , 31 ] , [ f_btype , 32 ] , [ f_btype , 33 ] , [ f_btype , 4 ] , [ f_btype , 5 ] ] ] ) ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_INT 22
3611: PUSH
3612: LD_VAR 0 1
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PUSH
3621: LD_INT 2
3623: PUSH
3624: LD_INT 30
3626: PUSH
3627: LD_INT 31
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 30
3636: PUSH
3637: LD_INT 32
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: LD_INT 30
3646: PUSH
3647: LD_INT 33
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PUSH
3654: LD_INT 30
3656: PUSH
3657: LD_INT 4
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PUSH
3664: LD_INT 30
3666: PUSH
3667: LD_INT 5
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: LIST
3679: LIST
3680: LIST
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL_OW 69
3690: ST_TO_ADDR
// enemyBuildings = FilterAllUnits ( [ [ f_side , enemySide ] , [ f_type , unit_building ] , [ f_empty ] ] ) ;
3691: LD_ADDR_VAR 0 7
3695: PUSH
3696: LD_INT 22
3698: PUSH
3699: LD_VAR 0 2
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: PUSH
3708: LD_INT 21
3710: PUSH
3711: LD_INT 3
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_INT 58
3720: PUSH
3721: EMPTY
3722: LIST
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: PPUSH
3729: CALL_OW 69
3733: ST_TO_ADDR
// if turretsList > 0 and enemyBuildings > 0 then
3734: LD_VAR 0 6
3738: PUSH
3739: LD_INT 0
3741: GREATER
3742: PUSH
3743: LD_VAR 0 7
3747: PUSH
3748: LD_INT 0
3750: GREATER
3751: AND
3752: IFFALSE 3822
// begin for i in turretsList do
3754: LD_ADDR_VAR 0 4
3758: PUSH
3759: LD_VAR 0 6
3763: PUSH
3764: FOR_IN
3765: IFFALSE 3820
// begin for j in enemyBuildings do
3767: LD_ADDR_VAR 0 5
3771: PUSH
3772: LD_VAR 0 7
3776: PUSH
3777: FOR_IN
3778: IFFALSE 3816
// begin if GetDistUnits ( i , j ) < 20 then
3780: LD_VAR 0 4
3784: PPUSH
3785: LD_VAR 0 5
3789: PPUSH
3790: CALL_OW 296
3794: PUSH
3795: LD_INT 20
3797: LESS
3798: IFFALSE 3814
// begin ComAttackUnit ( i , j ) ;
3800: LD_VAR 0 4
3804: PPUSH
3805: LD_VAR 0 5
3809: PPUSH
3810: CALL_OW 115
// end ; end ;
3814: GO 3777
3816: POP
3817: POP
// end ;
3818: GO 3764
3820: POP
3821: POP
// end ; end ;
3822: LD_VAR 0 3
3826: RET
// export function IntBazooka ( side , targetSide ) ; var ta , c , i , list , filter ; begin
3827: LD_INT 0
3829: PPUSH
3830: PPUSH
3831: PPUSH
3832: PPUSH
3833: PPUSH
3834: PPUSH
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_bazooker ] ] ) ;
3835: LD_ADDR_VAR 0 7
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_VAR 0 1
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: LD_INT 25
3854: PUSH
3855: LD_INT 9
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL_OW 69
3870: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , targetSide ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
3871: LD_ADDR_VAR 0 8
3875: PUSH
3876: LD_INT 22
3878: PUSH
3879: LD_VAR 0 2
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PUSH
3888: LD_INT 3
3890: PUSH
3891: LD_INT 21
3893: PUSH
3894: LD_INT 3
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PPUSH
3909: CALL_OW 69
3913: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_INT 1
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: CALL_OW 12
3929: ST_TO_ADDR
// for i = 1 to list do
3930: LD_ADDR_VAR 0 6
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_VAR 0 7
3944: PUSH
3945: FOR_TO
3946: IFFALSE 4128
// for ta in filter do
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 8
3957: PUSH
3958: FOR_IN
3959: IFFALSE 4124
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
3961: LD_VAR 0 7
3965: PUSH
3966: LD_VAR 0 6
3970: ARRAY
3971: PPUSH
3972: LD_VAR 0 4
3976: PPUSH
3977: CALL_OW 296
3981: PUSH
3982: LD_INT 13
3984: LESSEQUAL
3985: IFFALSE 4122
// begin case c of 1 :
3987: LD_VAR 0 5
3991: PUSH
3992: LD_INT 1
3994: DOUBLE
3995: EQUAL
3996: IFTRUE 4000
3998: GO 4038
4000: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4001: LD_VAR 0 7
4005: PUSH
4006: LD_VAR 0 6
4010: ARRAY
4011: PPUSH
4012: LD_VAR 0 4
4016: PPUSH
4017: CALL_OW 250
4021: PPUSH
4022: LD_VAR 0 4
4026: PPUSH
4027: CALL_OW 251
4031: PPUSH
4032: CALL_OW 154
4036: GO 4122
4038: LD_INT 2
4040: DOUBLE
4041: EQUAL
4042: IFTRUE 4046
4044: GO 4110
4046: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4047: LD_VAR 0 7
4051: PUSH
4052: LD_VAR 0 6
4056: ARRAY
4057: PPUSH
4058: LD_VAR 0 4
4062: PPUSH
4063: CALL_OW 250
4067: PUSH
4068: LD_INT 1
4070: NEG
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: CALL_OW 12
4079: PLUS
4080: PPUSH
4081: LD_VAR 0 4
4085: PPUSH
4086: CALL_OW 251
4090: PUSH
4091: LD_INT 1
4093: NEG
4094: PPUSH
4095: LD_INT 1
4097: PPUSH
4098: CALL_OW 12
4102: PLUS
4103: PPUSH
4104: CALL_OW 153
4108: GO 4122
4110: LD_INT 3
4112: DOUBLE
4113: EQUAL
4114: IFTRUE 4118
4116: GO 4121
4118: POP
// ; end ;
4119: GO 4122
4121: POP
// end ; end ;
4122: GO 3958
4124: POP
4125: POP
4126: GO 3945
4128: POP
4129: POP
// end ;
4130: LD_VAR 0 3
4134: RET
// export function RepairBuilding ( side , building ) ; var buildings_list , i , engineerOkInside , engineerOkOutside , j ; begin
4135: LD_INT 0
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
// engineerOkInside = UnitsInside ( building ) ;
4143: LD_ADDR_VAR 0 6
4147: PUSH
4148: LD_VAR 0 2
4152: PPUSH
4153: CALL_OW 313
4157: ST_TO_ADDR
// engineerOkOutside = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] , [ f_not , [ f_inside ] ] ] ) ;
4158: LD_ADDR_VAR 0 7
4162: PUSH
4163: LD_INT 22
4165: PUSH
4166: LD_VAR 0 1
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: PUSH
4175: LD_INT 25
4177: PUSH
4178: LD_INT 2
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: LD_INT 24
4187: PUSH
4188: LD_INT 1000
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: LD_INT 54
4200: PUSH
4201: EMPTY
4202: LIST
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: PPUSH
4214: CALL_OW 69
4218: ST_TO_ADDR
// buildings_list = FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
4219: LD_ADDR_VAR 0 4
4223: PUSH
4224: LD_INT 22
4226: PUSH
4227: LD_VAR 0 1
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: PUSH
4236: LD_INT 21
4238: PUSH
4239: LD_INT 3
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PUSH
4246: LD_INT 3
4248: PUSH
4249: LD_INT 24
4251: PUSH
4252: LD_INT 1000
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: EMPTY
4269: LIST
4270: PPUSH
4271: CALL_OW 69
4275: ST_TO_ADDR
// if not buildings_list and not engineerOkOutside and not destroyedBuildings then
4276: LD_VAR 0 4
4280: NOT
4281: PUSH
4282: LD_VAR 0 7
4286: NOT
4287: AND
4288: PUSH
4289: LD_EXP 1
4293: NOT
4294: AND
4295: IFFALSE 4299
// exit ;
4297: GO 4418
// if buildings_list > 0 and engineerOkInside then
4299: LD_VAR 0 4
4303: PUSH
4304: LD_INT 0
4306: GREATER
4307: PUSH
4308: LD_VAR 0 6
4312: AND
4313: IFFALSE 4346
// for i in UnitsInside ( building ) do
4315: LD_ADDR_VAR 0 5
4319: PUSH
4320: LD_VAR 0 2
4324: PPUSH
4325: CALL_OW 313
4329: PUSH
4330: FOR_IN
4331: IFFALSE 4344
// ComExitBuilding ( i ) ;
4333: LD_VAR 0 5
4337: PPUSH
4338: CALL_OW 122
4342: GO 4330
4344: POP
4345: POP
// if buildings_list > 0 and engineerOkOutside > 0 then
4346: LD_VAR 0 4
4350: PUSH
4351: LD_INT 0
4353: GREATER
4354: PUSH
4355: LD_VAR 0 7
4359: PUSH
4360: LD_INT 0
4362: GREATER
4363: AND
4364: IFFALSE 4418
// begin for i in engineerOkOutside do
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 7
4375: PUSH
4376: FOR_IN
4377: IFFALSE 4416
// for j in buildings_list do
4379: LD_ADDR_VAR 0 8
4383: PUSH
4384: LD_VAR 0 4
4388: PUSH
4389: FOR_IN
4390: IFFALSE 4412
// ComRepairBuilding ( i , j [ 1 ] ) ;
4392: LD_VAR 0 5
4396: PPUSH
4397: LD_VAR 0 8
4401: PUSH
4402: LD_INT 1
4404: ARRAY
4405: PPUSH
4406: CALL_OW 130
4410: GO 4389
4412: POP
4413: POP
4414: GO 4376
4416: POP
4417: POP
// end ; end ;
4418: LD_VAR 0 3
4422: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , sci_listOutside , i , j , damageUnits , unitsToHeal ; begin
4423: LD_INT 0
4425: PPUSH
4426: PPUSH
4427: PPUSH
4428: PPUSH
4429: PPUSH
4430: PPUSH
4431: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4432: LD_ADDR_VAR 0 6
4436: PUSH
4437: LD_INT 22
4439: PUSH
4440: LD_VAR 0 1
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 25
4451: PUSH
4452: LD_INT 4
4454: PUSH
4455: EMPTY
4456: LIST
4457: LIST
4458: PUSH
4459: LD_INT 24
4461: PUSH
4462: LD_INT 251
4464: PUSH
4465: EMPTY
4466: LIST
4467: LIST
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 69
4478: ST_TO_ADDR
// sci_listOutside = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_class , 4 ] , [ f_ok ] ] ) ;
4479: LD_ADDR_VAR 0 7
4483: PUSH
4484: LD_VAR 0 3
4488: PPUSH
4489: LD_INT 22
4491: PUSH
4492: LD_VAR 0 1
4496: PUSH
4497: EMPTY
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 25
4503: PUSH
4504: LD_INT 4
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: PUSH
4511: LD_INT 50
4513: PUSH
4514: EMPTY
4515: LIST
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL_OW 70
4526: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
4527: LD_ADDR_VAR 0 10
4531: PUSH
4532: LD_VAR 0 3
4536: PPUSH
4537: LD_INT 22
4539: PUSH
4540: LD_VAR 0 1
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: PUSH
4549: LD_INT 21
4551: PUSH
4552: LD_INT 1
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: PUSH
4559: LD_INT 3
4561: PUSH
4562: LD_INT 24
4564: PUSH
4565: LD_INT 750
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: PPUSH
4581: CALL_OW 70
4585: ST_TO_ADDR
// unitsToHeal = FilterUnitsInArea ( healArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4586: LD_ADDR_VAR 0 11
4590: PUSH
4591: LD_VAR 0 2
4595: PPUSH
4596: LD_INT 22
4598: PUSH
4599: LD_VAR 0 1
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PUSH
4608: LD_INT 21
4610: PUSH
4611: LD_INT 1
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: PUSH
4618: LD_INT 3
4620: PUSH
4621: LD_INT 24
4623: PUSH
4624: LD_INT 1000
4626: PUSH
4627: EMPTY
4628: LIST
4629: LIST
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: PUSH
4635: EMPTY
4636: LIST
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 70
4644: ST_TO_ADDR
// if not damageUnits and not sci_listOutside and not unitsToHeal then
4645: LD_VAR 0 10
4649: NOT
4650: PUSH
4651: LD_VAR 0 7
4655: NOT
4656: AND
4657: PUSH
4658: LD_VAR 0 11
4662: NOT
4663: AND
4664: IFFALSE 4668
// exit ;
4666: GO 4857
// if damageUnits > 0 and sci_list > 0 then
4668: LD_VAR 0 10
4672: PUSH
4673: LD_INT 0
4675: GREATER
4676: PUSH
4677: LD_VAR 0 6
4681: PUSH
4682: LD_INT 0
4684: GREATER
4685: AND
4686: IFFALSE 4719
// for i in damageUnits do
4688: LD_ADDR_VAR 0 8
4692: PUSH
4693: LD_VAR 0 10
4697: PUSH
4698: FOR_IN
4699: IFFALSE 4717
// ComMoveToArea ( i , healArea ) ;
4701: LD_VAR 0 8
4705: PPUSH
4706: LD_VAR 0 2
4710: PPUSH
4711: CALL_OW 113
4715: GO 4698
4717: POP
4718: POP
// if unitsToHeal > 0 and sci_list > 0 then
4719: LD_VAR 0 11
4723: PUSH
4724: LD_INT 0
4726: GREATER
4727: PUSH
4728: LD_VAR 0 6
4732: PUSH
4733: LD_INT 0
4735: GREATER
4736: AND
4737: IFFALSE 4796
// begin for i in sci_list do
4739: LD_ADDR_VAR 0 8
4743: PUSH
4744: LD_VAR 0 6
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4794
// begin ComExitBuilding ( i ) ;
4752: LD_VAR 0 8
4756: PPUSH
4757: CALL_OW 122
// for j in unitsToHeal do
4761: LD_ADDR_VAR 0 9
4765: PUSH
4766: LD_VAR 0 11
4770: PUSH
4771: FOR_IN
4772: IFFALSE 4790
// AddComHeal ( i , j ) ;
4774: LD_VAR 0 8
4778: PPUSH
4779: LD_VAR 0 9
4783: PPUSH
4784: CALL_OW 188
4788: GO 4771
4790: POP
4791: POP
// end ;
4792: GO 4749
4794: POP
4795: POP
// end ; if damageUnits = 0 and unitsToHeal = 0 and sci_listOutside > 0 then
4796: LD_VAR 0 10
4800: PUSH
4801: LD_INT 0
4803: EQUAL
4804: PUSH
4805: LD_VAR 0 11
4809: PUSH
4810: LD_INT 0
4812: EQUAL
4813: AND
4814: PUSH
4815: LD_VAR 0 7
4819: PUSH
4820: LD_INT 0
4822: GREATER
4823: AND
4824: IFFALSE 4857
// for i in sci_listOutside do
4826: LD_ADDR_VAR 0 8
4830: PUSH
4831: LD_VAR 0 7
4835: PUSH
4836: FOR_IN
4837: IFFALSE 4855
// ComEnterUnit ( i , build ) ;
4839: LD_VAR 0 8
4843: PPUSH
4844: LD_VAR 0 4
4848: PPUSH
4849: CALL_OW 120
4853: GO 4836
4855: POP
4856: POP
// end ; end_of_file
4857: LD_VAR 0 5
4861: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
// if exist_mode then
4866: LD_VAR 0 2
4870: IFFALSE 4889
// unit := CreateCharacter ( ident ) else
4872: LD_ADDR_VAR 0 4
4876: PUSH
4877: LD_VAR 0 1
4881: PPUSH
4882: CALL_OW 34
4886: ST_TO_ADDR
4887: GO 4904
// unit := NewCharacter ( ident ) ;
4889: LD_ADDR_VAR 0 4
4893: PUSH
4894: LD_VAR 0 1
4898: PPUSH
4899: CALL_OW 25
4903: ST_TO_ADDR
// result := unit ;
4904: LD_ADDR_VAR 0 3
4908: PUSH
4909: LD_VAR 0 4
4913: ST_TO_ADDR
// end ;
4914: LD_VAR 0 3
4918: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
4919: LD_INT 0
4921: PPUSH
4922: PPUSH
4923: PPUSH
// uc_side := GetSide ( b ) ;
4924: LD_ADDR_OWVAR 20
4928: PUSH
4929: LD_VAR 0 2
4933: PPUSH
4934: CALL_OW 255
4938: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
4939: LD_ADDR_OWVAR 21
4943: PUSH
4944: LD_VAR 0 2
4948: PPUSH
4949: CALL_OW 248
4953: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4954: LD_INT 0
4956: PPUSH
4957: LD_INT 1
4959: PPUSH
4960: LD_VAR 0 1
4964: PPUSH
4965: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
4969: LD_ADDR_VAR 0 5
4973: PUSH
4974: LD_VAR 0 2
4978: PPUSH
4979: CALL_OW 254
4983: PUSH
4984: LD_INT 3
4986: MINUS
4987: ST_TO_ADDR
// if dir < 0 then
4988: LD_VAR 0 5
4992: PUSH
4993: LD_INT 0
4995: LESS
4996: IFFALSE 5012
// dir := 6 + dir ;
4998: LD_ADDR_VAR 0 5
5002: PUSH
5003: LD_INT 6
5005: PUSH
5006: LD_VAR 0 5
5010: PLUS
5011: ST_TO_ADDR
// un := CreateHuman ;
5012: LD_ADDR_VAR 0 4
5016: PUSH
5017: CALL_OW 44
5021: ST_TO_ADDR
// SetDir ( un , dir ) ;
5022: LD_VAR 0 4
5026: PPUSH
5027: LD_VAR 0 5
5031: PPUSH
5032: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5036: LD_VAR 0 4
5040: PPUSH
5041: LD_VAR 0 2
5045: PPUSH
5046: CALL_OW 52
// end ;
5050: LD_VAR 0 3
5054: RET
// export function GetMultiCargo ( cargo_bay ) ; var i ; begin
5055: LD_INT 0
5057: PPUSH
5058: PPUSH
// result := [ GetCargo ( cargo_bay , mat_cans ) , GetCargo ( cargo_bay , mat_oil ) , GetCargo ( cargo_bay , mat_siberit ) ] ;
5059: LD_ADDR_VAR 0 2
5063: PUSH
5064: LD_VAR 0 1
5068: PPUSH
5069: LD_INT 1
5071: PPUSH
5072: CALL_OW 289
5076: PUSH
5077: LD_VAR 0 1
5081: PPUSH
5082: LD_INT 2
5084: PPUSH
5085: CALL_OW 289
5089: PUSH
5090: LD_VAR 0 1
5094: PPUSH
5095: LD_INT 3
5097: PPUSH
5098: CALL_OW 289
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: LIST
5107: ST_TO_ADDR
// end ;
5108: LD_VAR 0 2
5112: RET
// export function PlaceMines ( area , n ) ; var i , r , x ; begin
5113: LD_INT 0
5115: PPUSH
5116: PPUSH
5117: PPUSH
5118: PPUSH
// r := 100 ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: LD_INT 100
5126: ST_TO_ADDR
// x := 0 ;
5127: LD_ADDR_VAR 0 6
5131: PUSH
5132: LD_INT 0
5134: ST_TO_ADDR
// while ( x < n ) do
5135: LD_VAR 0 6
5139: PUSH
5140: LD_VAR 0 2
5144: LESS
5145: IFFALSE 5458
// for i = 1 to AreaToList ( area , 0 ) [ 1 ] do
5147: LD_ADDR_VAR 0 4
5151: PUSH
5152: DOUBLE
5153: LD_INT 1
5155: DEC
5156: ST_TO_ADDR
5157: LD_VAR 0 1
5161: PPUSH
5162: LD_INT 0
5164: PPUSH
5165: CALL_OW 517
5169: PUSH
5170: LD_INT 1
5172: ARRAY
5173: PUSH
5174: FOR_TO
5175: IFFALSE 5454
// begin if r > 50 then
5177: LD_VAR 0 5
5181: PUSH
5182: LD_INT 50
5184: GREATER
5185: IFFALSE 5430
// begin if not MineAtPos ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] ) then
5187: LD_VAR 0 1
5191: PPUSH
5192: LD_INT 0
5194: PPUSH
5195: CALL_OW 517
5199: PUSH
5200: LD_INT 1
5202: ARRAY
5203: PUSH
5204: LD_VAR 0 4
5208: ARRAY
5209: PPUSH
5210: LD_VAR 0 1
5214: PPUSH
5215: LD_INT 0
5217: PPUSH
5218: CALL_OW 517
5222: PUSH
5223: LD_INT 2
5225: ARRAY
5226: PUSH
5227: LD_VAR 0 4
5231: ARRAY
5232: PPUSH
5233: CALL_OW 458
5237: NOT
5238: IFFALSE 5414
// begin PlaceMine ( AreaToList ( area , 0 ) [ 1 ] [ i ] , AreaToList ( area , 0 ) [ 2 ] [ i ] , 2 , 0 ) ;
5240: LD_VAR 0 1
5244: PPUSH
5245: LD_INT 0
5247: PPUSH
5248: CALL_OW 517
5252: PUSH
5253: LD_INT 1
5255: ARRAY
5256: PUSH
5257: LD_VAR 0 4
5261: ARRAY
5262: PPUSH
5263: LD_VAR 0 1
5267: PPUSH
5268: LD_INT 0
5270: PPUSH
5271: CALL_OW 517
5275: PUSH
5276: LD_INT 2
5278: ARRAY
5279: PUSH
5280: LD_VAR 0 4
5284: ARRAY
5285: PPUSH
5286: LD_INT 2
5288: PPUSH
5289: LD_INT 0
5291: PPUSH
5292: CALL_OW 454
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 1 ] [ i ] ) ;
5296: LD_ADDR_EXP 4
5300: PUSH
5301: LD_EXP 4
5305: PPUSH
5306: LD_EXP 4
5310: PUSH
5311: LD_INT 1
5313: PLUS
5314: PPUSH
5315: LD_VAR 0 1
5319: PPUSH
5320: LD_INT 0
5322: PPUSH
5323: CALL_OW 517
5327: PUSH
5328: LD_INT 1
5330: ARRAY
5331: PUSH
5332: LD_VAR 0 4
5336: ARRAY
5337: PPUSH
5338: CALL_OW 2
5342: ST_TO_ADDR
// arabianMines := Insert ( arabianMines , arabianMines + 1 , AreaToList ( area , 0 ) [ 2 ] [ i ] ) ;
5343: LD_ADDR_EXP 4
5347: PUSH
5348: LD_EXP 4
5352: PPUSH
5353: LD_EXP 4
5357: PUSH
5358: LD_INT 1
5360: PLUS
5361: PPUSH
5362: LD_VAR 0 1
5366: PPUSH
5367: LD_INT 0
5369: PPUSH
5370: CALL_OW 517
5374: PUSH
5375: LD_INT 2
5377: ARRAY
5378: PUSH
5379: LD_VAR 0 4
5383: ARRAY
5384: PPUSH
5385: CALL_OW 2
5389: ST_TO_ADDR
// r := 0 ;
5390: LD_ADDR_VAR 0 5
5394: PUSH
5395: LD_INT 0
5397: ST_TO_ADDR
// x := x + 1 ;
5398: LD_ADDR_VAR 0 6
5402: PUSH
5403: LD_VAR 0 6
5407: PUSH
5408: LD_INT 1
5410: PLUS
5411: ST_TO_ADDR
// end else
5412: GO 5428
// r := r + 35 ;
5414: LD_ADDR_VAR 0 5
5418: PUSH
5419: LD_VAR 0 5
5423: PUSH
5424: LD_INT 35
5426: PLUS
5427: ST_TO_ADDR
// end else
5428: GO 5452
// r := r + rand ( 10 , 25 ) ;
5430: LD_ADDR_VAR 0 5
5434: PUSH
5435: LD_VAR 0 5
5439: PUSH
5440: LD_INT 10
5442: PPUSH
5443: LD_INT 25
5445: PPUSH
5446: CALL_OW 12
5450: PLUS
5451: ST_TO_ADDR
// end ;
5452: GO 5174
5454: POP
5455: POP
5456: GO 5135
// end ;
5458: LD_VAR 0 3
5462: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
5463: LD_INT 0
5465: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
5466: LD_ADDR_VAR 0 4
5470: PUSH
5471: LD_VAR 0 1
5475: PPUSH
5476: CALL_OW 250
5480: PPUSH
5481: LD_VAR 0 1
5485: PPUSH
5486: CALL_OW 251
5490: PPUSH
5491: LD_VAR 0 2
5495: PPUSH
5496: LD_VAR 0 3
5500: PPUSH
5501: CALL 5511 0 4
5505: ST_TO_ADDR
// end ;
5506: LD_VAR 0 4
5510: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
5511: LD_INT 0
5513: PPUSH
5514: PPUSH
5515: PPUSH
5516: PPUSH
// if not list then
5517: LD_VAR 0 3
5521: NOT
5522: IFFALSE 5526
// exit ;
5524: GO 5834
// result := [ ] ;
5526: LD_ADDR_VAR 0 5
5530: PUSH
5531: EMPTY
5532: ST_TO_ADDR
// for i in list do
5533: LD_ADDR_VAR 0 6
5537: PUSH
5538: LD_VAR 0 3
5542: PUSH
5543: FOR_IN
5544: IFFALSE 5746
// begin tmp := GetDistUnitXY ( i , x , y ) ;
5546: LD_ADDR_VAR 0 8
5550: PUSH
5551: LD_VAR 0 6
5555: PPUSH
5556: LD_VAR 0 1
5560: PPUSH
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL_OW 297
5570: ST_TO_ADDR
// if not result then
5571: LD_VAR 0 5
5575: NOT
5576: IFFALSE 5602
// result := [ [ i , tmp ] ] else
5578: LD_ADDR_VAR 0 5
5582: PUSH
5583: LD_VAR 0 6
5587: PUSH
5588: LD_VAR 0 8
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: EMPTY
5598: LIST
5599: ST_TO_ADDR
5600: GO 5744
// begin if result [ result ] [ 2 ] < tmp then
5602: LD_VAR 0 5
5606: PUSH
5607: LD_VAR 0 5
5611: ARRAY
5612: PUSH
5613: LD_INT 2
5615: ARRAY
5616: PUSH
5617: LD_VAR 0 8
5621: LESS
5622: IFFALSE 5664
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
5624: LD_ADDR_VAR 0 5
5628: PUSH
5629: LD_VAR 0 5
5633: PPUSH
5634: LD_VAR 0 5
5638: PUSH
5639: LD_INT 1
5641: PLUS
5642: PPUSH
5643: LD_VAR 0 6
5647: PUSH
5648: LD_VAR 0 8
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: CALL_OW 2
5661: ST_TO_ADDR
5662: GO 5744
// for j = 1 to result do
5664: LD_ADDR_VAR 0 7
5668: PUSH
5669: DOUBLE
5670: LD_INT 1
5672: DEC
5673: ST_TO_ADDR
5674: LD_VAR 0 5
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5742
// begin if tmp < result [ j ] [ 2 ] then
5682: LD_VAR 0 8
5686: PUSH
5687: LD_VAR 0 5
5691: PUSH
5692: LD_VAR 0 7
5696: ARRAY
5697: PUSH
5698: LD_INT 2
5700: ARRAY
5701: LESS
5702: IFFALSE 5740
// begin result := Insert ( result , j , [ i , tmp ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_VAR 0 7
5718: PPUSH
5719: LD_VAR 0 6
5723: PUSH
5724: LD_VAR 0 8
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PPUSH
5733: CALL_OW 2
5737: ST_TO_ADDR
// break ;
5738: GO 5742
// end ; end ;
5740: GO 5679
5742: POP
5743: POP
// end ; end ;
5744: GO 5543
5746: POP
5747: POP
// if result and not asc then
5748: LD_VAR 0 5
5752: PUSH
5753: LD_VAR 0 4
5757: NOT
5758: AND
5759: IFFALSE 5834
// begin tmp := result ;
5761: LD_ADDR_VAR 0 8
5765: PUSH
5766: LD_VAR 0 5
5770: ST_TO_ADDR
// for i = tmp downto 1 do
5771: LD_ADDR_VAR 0 6
5775: PUSH
5776: DOUBLE
5777: LD_VAR 0 8
5781: INC
5782: ST_TO_ADDR
5783: LD_INT 1
5785: PUSH
5786: FOR_DOWNTO
5787: IFFALSE 5832
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
5789: LD_ADDR_VAR 0 5
5793: PUSH
5794: LD_VAR 0 5
5798: PPUSH
5799: LD_VAR 0 8
5803: PUSH
5804: LD_VAR 0 6
5808: MINUS
5809: PUSH
5810: LD_INT 1
5812: PLUS
5813: PPUSH
5814: LD_VAR 0 8
5818: PUSH
5819: LD_VAR 0 6
5823: ARRAY
5824: PPUSH
5825: CALL_OW 1
5829: ST_TO_ADDR
5830: GO 5786
5832: POP
5833: POP
// end ; end ; end_of_file
5834: LD_VAR 0 5
5838: RET
// on UnitDestroyed ( un ) do var i ;
5839: LD_INT 0
5841: PPUSH
// begin if GetSide ( un ) = 3 and GetType ( un ) = unit_building then
5842: LD_VAR 0 1
5846: PPUSH
5847: CALL_OW 255
5851: PUSH
5852: LD_INT 3
5854: EQUAL
5855: PUSH
5856: LD_VAR 0 1
5860: PPUSH
5861: CALL_OW 247
5865: PUSH
5866: LD_INT 3
5868: EQUAL
5869: AND
5870: IFFALSE 6562
// begin if GetBType ( un ) = 31 or GetBType ( un ) = 32 or GetBType ( un ) = 36 or GetBType ( un ) = 0 or GetBType ( un ) = 24 or GetBType ( un ) = 17 or GetBType ( un ) = 25 or GetBType ( un ) = 19 or GetBType ( un ) = 20 or GetBType ( un ) = 18 or GetBType ( un ) = 21 or GetBType ( un ) = 23 or GetBType ( un ) = 16 or GetBType ( un ) = 6 or GetBType ( un ) = 29 or GetBType ( un ) = 26 or GetBType ( un ) = 30 or GetBType ( un ) = 28 or GetBType ( un ) = 27 or GetBType ( un ) = 33 or GetBType ( un ) = 2 or GetBType ( un ) = 4 then
5872: LD_VAR 0 1
5876: PPUSH
5877: CALL_OW 266
5881: PUSH
5882: LD_INT 31
5884: EQUAL
5885: PUSH
5886: LD_VAR 0 1
5890: PPUSH
5891: CALL_OW 266
5895: PUSH
5896: LD_INT 32
5898: EQUAL
5899: OR
5900: PUSH
5901: LD_VAR 0 1
5905: PPUSH
5906: CALL_OW 266
5910: PUSH
5911: LD_INT 36
5913: EQUAL
5914: OR
5915: PUSH
5916: LD_VAR 0 1
5920: PPUSH
5921: CALL_OW 266
5925: PUSH
5926: LD_INT 0
5928: EQUAL
5929: OR
5930: PUSH
5931: LD_VAR 0 1
5935: PPUSH
5936: CALL_OW 266
5940: PUSH
5941: LD_INT 24
5943: EQUAL
5944: OR
5945: PUSH
5946: LD_VAR 0 1
5950: PPUSH
5951: CALL_OW 266
5955: PUSH
5956: LD_INT 17
5958: EQUAL
5959: OR
5960: PUSH
5961: LD_VAR 0 1
5965: PPUSH
5966: CALL_OW 266
5970: PUSH
5971: LD_INT 25
5973: EQUAL
5974: OR
5975: PUSH
5976: LD_VAR 0 1
5980: PPUSH
5981: CALL_OW 266
5985: PUSH
5986: LD_INT 19
5988: EQUAL
5989: OR
5990: PUSH
5991: LD_VAR 0 1
5995: PPUSH
5996: CALL_OW 266
6000: PUSH
6001: LD_INT 20
6003: EQUAL
6004: OR
6005: PUSH
6006: LD_VAR 0 1
6010: PPUSH
6011: CALL_OW 266
6015: PUSH
6016: LD_INT 18
6018: EQUAL
6019: OR
6020: PUSH
6021: LD_VAR 0 1
6025: PPUSH
6026: CALL_OW 266
6030: PUSH
6031: LD_INT 21
6033: EQUAL
6034: OR
6035: PUSH
6036: LD_VAR 0 1
6040: PPUSH
6041: CALL_OW 266
6045: PUSH
6046: LD_INT 23
6048: EQUAL
6049: OR
6050: PUSH
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 266
6060: PUSH
6061: LD_INT 16
6063: EQUAL
6064: OR
6065: PUSH
6066: LD_VAR 0 1
6070: PPUSH
6071: CALL_OW 266
6075: PUSH
6076: LD_INT 6
6078: EQUAL
6079: OR
6080: PUSH
6081: LD_VAR 0 1
6085: PPUSH
6086: CALL_OW 266
6090: PUSH
6091: LD_INT 29
6093: EQUAL
6094: OR
6095: PUSH
6096: LD_VAR 0 1
6100: PPUSH
6101: CALL_OW 266
6105: PUSH
6106: LD_INT 26
6108: EQUAL
6109: OR
6110: PUSH
6111: LD_VAR 0 1
6115: PPUSH
6116: CALL_OW 266
6120: PUSH
6121: LD_INT 30
6123: EQUAL
6124: OR
6125: PUSH
6126: LD_VAR 0 1
6130: PPUSH
6131: CALL_OW 266
6135: PUSH
6136: LD_INT 28
6138: EQUAL
6139: OR
6140: PUSH
6141: LD_VAR 0 1
6145: PPUSH
6146: CALL_OW 266
6150: PUSH
6151: LD_INT 27
6153: EQUAL
6154: OR
6155: PUSH
6156: LD_VAR 0 1
6160: PPUSH
6161: CALL_OW 266
6165: PUSH
6166: LD_INT 33
6168: EQUAL
6169: OR
6170: PUSH
6171: LD_VAR 0 1
6175: PPUSH
6176: CALL_OW 266
6180: PUSH
6181: LD_INT 2
6183: EQUAL
6184: OR
6185: PUSH
6186: LD_VAR 0 1
6190: PPUSH
6191: CALL_OW 266
6195: PUSH
6196: LD_INT 4
6198: EQUAL
6199: OR
6200: IFFALSE 6286
// begin destroyedBuildings = destroyedBuildings ^ GetBType ( un ) ;
6202: LD_ADDR_EXP 1
6206: PUSH
6207: LD_EXP 1
6211: PUSH
6212: LD_VAR 0 1
6216: PPUSH
6217: CALL_OW 266
6221: ADD
6222: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6223: LD_ADDR_EXP 1
6227: PUSH
6228: LD_EXP 1
6232: PUSH
6233: LD_VAR 0 1
6237: PPUSH
6238: CALL_OW 250
6242: ADD
6243: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6244: LD_ADDR_EXP 1
6248: PUSH
6249: LD_EXP 1
6253: PUSH
6254: LD_VAR 0 1
6258: PPUSH
6259: CALL_OW 251
6263: ADD
6264: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6265: LD_ADDR_EXP 1
6269: PUSH
6270: LD_EXP 1
6274: PUSH
6275: LD_VAR 0 1
6279: PPUSH
6280: CALL_OW 254
6284: ADD
6285: ST_TO_ADDR
// end ; if GetBType ( un ) = 1 then
6286: LD_VAR 0 1
6290: PPUSH
6291: CALL_OW 266
6295: PUSH
6296: LD_INT 1
6298: EQUAL
6299: IFFALSE 6378
// begin destroyedBuildings = destroyedBuildings ^ 0 ;
6301: LD_ADDR_EXP 1
6305: PUSH
6306: LD_EXP 1
6310: PUSH
6311: LD_INT 0
6313: ADD
6314: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6315: LD_ADDR_EXP 1
6319: PUSH
6320: LD_EXP 1
6324: PUSH
6325: LD_VAR 0 1
6329: PPUSH
6330: CALL_OW 250
6334: ADD
6335: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6336: LD_ADDR_EXP 1
6340: PUSH
6341: LD_EXP 1
6345: PUSH
6346: LD_VAR 0 1
6350: PPUSH
6351: CALL_OW 251
6355: ADD
6356: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6357: LD_ADDR_EXP 1
6361: PUSH
6362: LD_EXP 1
6366: PUSH
6367: LD_VAR 0 1
6371: PPUSH
6372: CALL_OW 254
6376: ADD
6377: ST_TO_ADDR
// end ; if GetBType ( un ) = 3 then
6378: LD_VAR 0 1
6382: PPUSH
6383: CALL_OW 266
6387: PUSH
6388: LD_INT 3
6390: EQUAL
6391: IFFALSE 6470
// begin destroyedBuildings = destroyedBuildings ^ 2 ;
6393: LD_ADDR_EXP 1
6397: PUSH
6398: LD_EXP 1
6402: PUSH
6403: LD_INT 2
6405: ADD
6406: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6407: LD_ADDR_EXP 1
6411: PUSH
6412: LD_EXP 1
6416: PUSH
6417: LD_VAR 0 1
6421: PPUSH
6422: CALL_OW 250
6426: ADD
6427: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6428: LD_ADDR_EXP 1
6432: PUSH
6433: LD_EXP 1
6437: PUSH
6438: LD_VAR 0 1
6442: PPUSH
6443: CALL_OW 251
6447: ADD
6448: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6449: LD_ADDR_EXP 1
6453: PUSH
6454: LD_EXP 1
6458: PUSH
6459: LD_VAR 0 1
6463: PPUSH
6464: CALL_OW 254
6468: ADD
6469: ST_TO_ADDR
// end ; if GetBType ( un ) = 5 then
6470: LD_VAR 0 1
6474: PPUSH
6475: CALL_OW 266
6479: PUSH
6480: LD_INT 5
6482: EQUAL
6483: IFFALSE 6562
// begin destroyedBuildings = destroyedBuildings ^ 4 ;
6485: LD_ADDR_EXP 1
6489: PUSH
6490: LD_EXP 1
6494: PUSH
6495: LD_INT 4
6497: ADD
6498: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetX ( un ) ;
6499: LD_ADDR_EXP 1
6503: PUSH
6504: LD_EXP 1
6508: PUSH
6509: LD_VAR 0 1
6513: PPUSH
6514: CALL_OW 250
6518: ADD
6519: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetY ( un ) ;
6520: LD_ADDR_EXP 1
6524: PUSH
6525: LD_EXP 1
6529: PUSH
6530: LD_VAR 0 1
6534: PPUSH
6535: CALL_OW 251
6539: ADD
6540: ST_TO_ADDR
// destroyedBuildings = destroyedBuildings ^ GetDir ( un ) ;
6541: LD_ADDR_EXP 1
6545: PUSH
6546: LD_EXP 1
6550: PUSH
6551: LD_VAR 0 1
6555: PPUSH
6556: CALL_OW 254
6560: ADD
6561: ST_TO_ADDR
// end ; end ; end ;
6562: PPOPN 2
6564: END
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 then
6565: LD_VAR 0 1
6569: PPUSH
6570: CALL_OW 255
6574: PUSH
6575: LD_INT 3
6577: EQUAL
6578: IFFALSE 6652
// begin destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6580: LD_ADDR_EXP 1
6584: PUSH
6585: LD_EXP 1
6589: PPUSH
6590: LD_INT 1
6592: PPUSH
6593: CALL_OW 3
6597: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6598: LD_ADDR_EXP 1
6602: PUSH
6603: LD_EXP 1
6607: PPUSH
6608: LD_INT 1
6610: PPUSH
6611: CALL_OW 3
6615: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6616: LD_ADDR_EXP 1
6620: PUSH
6621: LD_EXP 1
6625: PPUSH
6626: LD_INT 1
6628: PPUSH
6629: CALL_OW 3
6633: ST_TO_ADDR
// destroyedBuildings := Delete ( destroyedBuildings , 1 ) ;
6634: LD_ADDR_EXP 1
6638: PUSH
6639: LD_EXP 1
6643: PPUSH
6644: LD_INT 1
6646: PPUSH
6647: CALL_OW 3
6651: ST_TO_ADDR
// end ; if GetSide ( building ) = 3 and [ GetBType ( building ) = 0 or GetBType ( building ) = 2 or GetBType ( building ) = 4 ] then
6652: LD_VAR 0 1
6656: PPUSH
6657: CALL_OW 255
6661: PUSH
6662: LD_INT 3
6664: EQUAL
6665: PUSH
6666: LD_VAR 0 1
6670: PPUSH
6671: CALL_OW 266
6675: PUSH
6676: LD_INT 0
6678: EQUAL
6679: PUSH
6680: LD_VAR 0 1
6684: PPUSH
6685: CALL_OW 266
6689: PUSH
6690: LD_INT 2
6692: EQUAL
6693: OR
6694: PUSH
6695: LD_VAR 0 1
6699: PPUSH
6700: CALL_OW 266
6704: PUSH
6705: LD_INT 4
6707: EQUAL
6708: OR
6709: PUSH
6710: EMPTY
6711: LIST
6712: AND
6713: IFFALSE 6724
// ComUpgrade ( building ) ;
6715: LD_VAR 0 1
6719: PPUSH
6720: CALL_OW 146
// end ;
6724: PPOPN 1
6726: END
// on LeaveVehicle ( vehicle , human ) do begin ComRepairVehicle ( human , vehicle ) ;
6727: LD_VAR 0 2
6731: PPUSH
6732: LD_VAR 0 1
6736: PPUSH
6737: CALL_OW 129
// AddComEnterUnit ( human , vehicle ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_VAR 0 1
6750: PPUSH
6751: CALL_OW 180
// end ;
6755: PPOPN 2
6757: END
// on VehicleConstructed ( vehicle , building ) do begin end ;
6758: PPOPN 2
6760: END
// on Command ( command_id ) do begin end ;
6761: PPOPN 1
6763: END
