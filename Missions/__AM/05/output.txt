// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 64 0 0
// PrepareAmerican ;
  16: CALL 88 0 0
// Action ;
  20: CALL 1905 0 0
// end ;
  24: END
// export debug ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// donaldson_commander := false ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// brown_commander := false ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// save_group := [ ] ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: EMPTY
  58: ST_TO_ADDR
// end ;
  59: LD_VAR 0 1
  63: RET
// function DebugMode ; begin
  64: LD_INT 0
  66: PPUSH
// if not debug then
  67: LD_EXP 1
  71: NOT
  72: IFFALSE 76
// exit ;
  74: GO 83
// FogOff ( 1 ) ;
  76: LD_INT 1
  78: PPUSH
  79: CALL_OW 344
// end ; end_of_file
  83: LD_VAR 0 1
  87: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i ; begin
  88: LD_INT 0
  90: PPUSH
  91: PPUSH
  92: PPUSH
  93: PPUSH
  94: PPUSH
  95: PPUSH
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
 100: PPUSH
 101: PPUSH
// PrepareBase ;
 102: CALL 1635 0 0
// uc_side := 1 ;
 106: LD_ADDR_OWVAR 20
 110: PUSH
 111: LD_INT 1
 113: ST_TO_ADDR
// uc_nation := 1 ;
 114: LD_ADDR_OWVAR 21
 118: PUSH
 119: LD_INT 1
 121: ST_TO_ADDR
// team := [ ] ;
 122: LD_ADDR_VAR 0 5
 126: PUSH
 127: EMPTY
 128: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_STRING JMM
 136: PPUSH
 137: LD_EXP 1
 141: NOT
 142: PPUSH
 143: CALL 4125 0 2
 147: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 148: LD_ADDR_EXP 6
 152: PUSH
 153: LD_STRING Gladstone
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: CALL 4125 0 2
 163: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 164: LD_ADDR_EXP 7
 168: PUSH
 169: LD_STRING Frank
 171: PPUSH
 172: LD_EXP 1
 176: NOT
 177: PPUSH
 178: CALL 4125 0 2
 182: ST_TO_ADDR
// if Frank then
 183: LD_EXP 7
 187: IFFALSE 205
// team := team ^ Frank ;
 189: LD_ADDR_VAR 0 5
 193: PUSH
 194: LD_VAR 0 5
 198: PUSH
 199: LD_EXP 7
 203: ADD
 204: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 205: LD_ADDR_EXP 8
 209: PUSH
 210: LD_STRING Lisa
 212: PPUSH
 213: LD_EXP 1
 217: NOT
 218: PPUSH
 219: CALL 4125 0 2
 223: ST_TO_ADDR
// if Lisa then
 224: LD_EXP 8
 228: IFFALSE 246
// team := team ^ Lisa ;
 230: LD_ADDR_VAR 0 5
 234: PUSH
 235: LD_VAR 0 5
 239: PUSH
 240: LD_EXP 8
 244: ADD
 245: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 246: LD_ADDR_EXP 11
 250: PUSH
 251: LD_STRING Donaldson
 253: PPUSH
 254: LD_EXP 1
 258: NOT
 259: PPUSH
 260: CALL 4125 0 2
 264: ST_TO_ADDR
// if Donaldson then
 265: LD_EXP 11
 269: IFFALSE 287
// team := team ^ Donaldson ;
 271: LD_ADDR_VAR 0 5
 275: PUSH
 276: LD_VAR 0 5
 280: PUSH
 281: LD_EXP 11
 285: ADD
 286: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 287: LD_ADDR_EXP 12
 291: PUSH
 292: LD_STRING Brown
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: CALL 4125 0 2
 305: ST_TO_ADDR
// if Brown then
 306: LD_EXP 12
 310: IFFALSE 328
// team := team ^ Brown ;
 312: LD_ADDR_VAR 0 5
 316: PUSH
 317: LD_VAR 0 5
 321: PUSH
 322: LD_EXP 12
 326: ADD
 327: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 328: LD_ADDR_VAR 0 3
 332: PUSH
 333: LD_STRING 04_other_survivors
 335: PPUSH
 336: CALL_OW 31
 340: ST_TO_ADDR
// if not Lisa then
 341: LD_EXP 8
 345: NOT
 346: IFFALSE 457
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 348: LD_ADDR_EXP 9
 352: PUSH
 353: LD_STRING Cyrus
 355: PPUSH
 356: LD_EXP 1
 360: NOT
 361: PPUSH
 362: CALL 4125 0 2
 366: ST_TO_ADDR
// if Cyrus then
 367: LD_EXP 9
 371: IFFALSE 389
// team := team ^ Cyrus ;
 373: LD_ADDR_VAR 0 5
 377: PUSH
 378: LD_VAR 0 5
 382: PUSH
 383: LD_EXP 9
 387: ADD
 388: ST_TO_ADDR
// if not Cyrus then
 389: LD_EXP 9
 393: NOT
 394: IFFALSE 457
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 396: LD_ADDR_EXP 10
 400: PUSH
 401: LD_STRING Bobby
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: CALL 4125 0 2
 414: ST_TO_ADDR
// if Bobby then
 415: LD_EXP 10
 419: IFFALSE 437
// team := team ^ Bobby ;
 421: LD_ADDR_VAR 0 5
 425: PUSH
 426: LD_VAR 0 5
 430: PUSH
 431: LD_EXP 10
 435: ADD
 436: ST_TO_ADDR
// if not Bobby then
 437: LD_EXP 10
 441: NOT
 442: IFFALSE 457
// begin others3 := CreateCharacterSet ( 03_others ) ;
 444: LD_ADDR_VAR 0 2
 448: PUSH
 449: LD_STRING 03_others
 451: PPUSH
 452: CALL_OW 31
 456: ST_TO_ADDR
// end ; end ; end ; if others4 then
 457: LD_VAR 0 3
 461: IFFALSE 479
// team := team ^ others4 ;
 463: LD_ADDR_VAR 0 5
 467: PUSH
 468: LD_VAR 0 5
 472: PUSH
 473: LD_VAR 0 3
 477: ADD
 478: ST_TO_ADDR
// if others3 then
 479: LD_VAR 0 2
 483: IFFALSE 501
// team := team ^ others3 ;
 485: LD_ADDR_VAR 0 5
 489: PUSH
 490: LD_VAR 0 5
 494: PUSH
 495: LD_VAR 0 2
 499: ADD
 500: ST_TO_ADDR
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 501: LD_ADDR_VAR 0 6
 505: PUSH
 506: LD_INT 30
 508: PUSH
 509: LD_INT 0
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PPUSH
 516: CALL_OW 69
 520: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 521: LD_ADDR_VAR 0 7
 525: PUSH
 526: LD_INT 30
 528: PUSH
 529: LD_INT 4
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: PPUSH
 536: CALL_OW 69
 540: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 541: LD_ADDR_VAR 0 8
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 30
 551: PUSH
 552: LD_INT 7
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: PUSH
 559: LD_INT 30
 561: PUSH
 562: LD_INT 6
 564: PUSH
 565: EMPTY
 566: LIST
 567: LIST
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: PPUSH
 574: CALL_OW 69
 578: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 579: LD_ADDR_VAR 0 9
 583: PUSH
 584: LD_INT 30
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: EMPTY
 591: LIST
 592: LIST
 593: PPUSH
 594: CALL_OW 69
 598: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 599: LD_ADDR_VAR 0 10
 603: PUSH
 604: LD_INT 2
 606: PUSH
 607: LD_INT 30
 609: PUSH
 610: LD_INT 32
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 30
 619: PUSH
 620: LD_INT 31
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: PPUSH
 632: CALL_OW 69
 636: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 637: LD_VAR 0 6
 641: PPUSH
 642: LD_STRING Gamma
 644: PPUSH
 645: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 649: LD_VAR 0 6
 653: PPUSH
 654: CALL_OW 274
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 10000
 664: PPUSH
 665: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 669: LD_VAR 0 6
 673: PPUSH
 674: CALL_OW 274
 678: PPUSH
 679: LD_INT 1
 681: PPUSH
 682: LD_INT 10000
 684: PPUSH
 685: CALL_OW 277
// if dep then
 689: LD_VAR 0 6
 693: IFFALSE 775
// begin if Brown then
 695: LD_EXP 12
 699: IFFALSE 735
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 701: LD_EXP 12
 705: PPUSH
 706: LD_VAR 0 6
 710: PUSH
 711: LD_INT 1
 713: ARRAY
 714: PPUSH
 715: CALL_OW 52
// team := team diff Brown ;
 719: LD_ADDR_VAR 0 5
 723: PUSH
 724: LD_VAR 0 5
 728: PUSH
 729: LD_EXP 12
 733: DIFF
 734: ST_TO_ADDR
// end ; if Donaldson then
 735: LD_EXP 11
 739: IFFALSE 775
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 741: LD_EXP 11
 745: PPUSH
 746: LD_VAR 0 6
 750: PUSH
 751: LD_INT 1
 753: ARRAY
 754: PPUSH
 755: CALL_OW 52
// team := team diff Donaldson ;
 759: LD_ADDR_VAR 0 5
 763: PUSH
 764: LD_VAR 0 5
 768: PUSH
 769: LD_EXP 11
 773: DIFF
 774: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 775: LD_VAR 0 10
 779: PUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: LD_INT 25
 787: PUSH
 788: LD_INT 1
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PPUSH
 795: CALL_OW 72
 799: AND
 800: IFFALSE 905
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 802: LD_ADDR_VAR 0 11
 806: PUSH
 807: LD_VAR 0 5
 811: PPUSH
 812: LD_INT 25
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL_OW 72
 826: ST_TO_ADDR
// for i in bun do
 827: LD_ADDR_VAR 0 12
 831: PUSH
 832: LD_VAR 0 10
 836: PUSH
 837: FOR_IN
 838: IFFALSE 887
// begin if not filter then
 840: LD_VAR 0 11
 844: NOT
 845: IFFALSE 849
// break ;
 847: GO 887
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 849: LD_VAR 0 11
 853: PUSH
 854: LD_INT 1
 856: ARRAY
 857: PPUSH
 858: LD_VAR 0 12
 862: PPUSH
 863: CALL_OW 52
// filter := Delete ( filter , 1 ) ;
 867: LD_ADDR_VAR 0 11
 871: PUSH
 872: LD_VAR 0 11
 876: PPUSH
 877: LD_INT 1
 879: PPUSH
 880: CALL_OW 3
 884: ST_TO_ADDR
// end ;
 885: GO 837
 887: POP
 888: POP
// team := team diff filter ;
 889: LD_ADDR_VAR 0 5
 893: PUSH
 894: LD_VAR 0 5
 898: PUSH
 899: LD_VAR 0 11
 903: DIFF
 904: ST_TO_ADDR
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
 905: LD_VAR 0 7
 909: PUSH
 910: LD_VAR 0 5
 914: PPUSH
 915: LD_INT 25
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: PPUSH
 925: CALL_OW 72
 929: AND
 930: IFFALSE 1033
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 932: LD_ADDR_VAR 0 11
 936: PUSH
 937: LD_VAR 0 5
 941: PPUSH
 942: LD_INT 25
 944: PUSH
 945: LD_INT 1
 947: PUSH
 948: EMPTY
 949: LIST
 950: LIST
 951: PPUSH
 952: CALL_OW 72
 956: ST_TO_ADDR
// for i = 1 to 6 do
 957: LD_ADDR_VAR 0 12
 961: PUSH
 962: DOUBLE
 963: LD_INT 1
 965: DEC
 966: ST_TO_ADDR
 967: LD_INT 6
 969: PUSH
 970: FOR_TO
 971: IFFALSE 1015
// begin PlaceHumanInUnit ( filter [ 1 ] , bar [ 1 ] ) ;
 973: LD_VAR 0 11
 977: PUSH
 978: LD_INT 1
 980: ARRAY
 981: PPUSH
 982: LD_VAR 0 7
 986: PUSH
 987: LD_INT 1
 989: ARRAY
 990: PPUSH
 991: CALL_OW 52
// filter := Delete ( filter , 1 ) ;
 995: LD_ADDR_VAR 0 11
 999: PUSH
1000: LD_VAR 0 11
1004: PPUSH
1005: LD_INT 1
1007: PPUSH
1008: CALL_OW 3
1012: ST_TO_ADDR
// end ;
1013: GO 970
1015: POP
1016: POP
// team := team diff filter ;
1017: LD_ADDR_VAR 0 5
1021: PUSH
1022: LD_VAR 0 5
1026: PUSH
1027: LD_VAR 0 11
1031: DIFF
1032: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1033: LD_VAR 0 8
1037: PUSH
1038: LD_VAR 0 5
1042: PPUSH
1043: LD_INT 25
1045: PUSH
1046: LD_INT 4
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL_OW 72
1057: AND
1058: IFFALSE 1159
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1060: LD_ADDR_VAR 0 11
1064: PUSH
1065: LD_VAR 0 5
1069: PPUSH
1070: LD_INT 25
1072: PUSH
1073: LD_INT 4
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: PPUSH
1080: CALL_OW 72
1084: ST_TO_ADDR
// for i = 1 to filter do
1085: LD_ADDR_VAR 0 12
1089: PUSH
1090: DOUBLE
1091: LD_INT 1
1093: DEC
1094: ST_TO_ADDR
1095: LD_VAR 0 11
1099: PUSH
1100: FOR_TO
1101: IFFALSE 1141
// begin if ( i > 6 ) then
1103: LD_VAR 0 12
1107: PUSH
1108: LD_INT 6
1110: GREATER
1111: IFFALSE 1115
// break ;
1113: GO 1141
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) ;
1115: LD_VAR 0 11
1119: PUSH
1120: LD_VAR 0 12
1124: ARRAY
1125: PPUSH
1126: LD_VAR 0 8
1130: PUSH
1131: LD_INT 1
1133: ARRAY
1134: PPUSH
1135: CALL_OW 52
// end ;
1139: GO 1100
1141: POP
1142: POP
// team := team diff filter ;
1143: LD_ADDR_VAR 0 5
1147: PUSH
1148: LD_VAR 0 5
1152: PUSH
1153: LD_VAR 0 11
1157: DIFF
1158: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1159: LD_VAR 0 9
1163: PUSH
1164: LD_VAR 0 5
1168: PPUSH
1169: LD_INT 25
1171: PUSH
1172: LD_INT 3
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: PPUSH
1179: CALL_OW 72
1183: AND
1184: IFFALSE 1287
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1186: LD_ADDR_VAR 0 11
1190: PUSH
1191: LD_VAR 0 5
1195: PPUSH
1196: LD_INT 25
1198: PUSH
1199: LD_INT 3
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PPUSH
1206: CALL_OW 72
1210: ST_TO_ADDR
// for i = 1 to 6 do
1211: LD_ADDR_VAR 0 12
1215: PUSH
1216: DOUBLE
1217: LD_INT 1
1219: DEC
1220: ST_TO_ADDR
1221: LD_INT 6
1223: PUSH
1224: FOR_TO
1225: IFFALSE 1269
// begin PlaceHumanInUnit ( filter [ 1 ] , fac [ 1 ] ) ;
1227: LD_VAR 0 11
1231: PUSH
1232: LD_INT 1
1234: ARRAY
1235: PPUSH
1236: LD_VAR 0 9
1240: PUSH
1241: LD_INT 1
1243: ARRAY
1244: PPUSH
1245: CALL_OW 52
// filter := Delete ( filter , 1 ) ;
1249: LD_ADDR_VAR 0 11
1253: PUSH
1254: LD_VAR 0 11
1258: PPUSH
1259: LD_INT 1
1261: PPUSH
1262: CALL_OW 3
1266: ST_TO_ADDR
// end ;
1267: GO 1224
1269: POP
1270: POP
// team := team diff filter ;
1271: LD_ADDR_VAR 0 5
1275: PUSH
1276: LD_VAR 0 5
1280: PUSH
1281: LD_VAR 0 11
1285: DIFF
1286: ST_TO_ADDR
// end ; if team then
1287: LD_VAR 0 5
1291: IFFALSE 1334
// for i in team do
1293: LD_ADDR_VAR 0 12
1297: PUSH
1298: LD_VAR 0 5
1302: PUSH
1303: FOR_IN
1304: IFFALSE 1332
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1306: LD_VAR 0 12
1310: PPUSH
1311: LD_INT 1
1313: PPUSH
1314: LD_INT 0
1316: PPUSH
1317: CALL_OW 49
// ComHold ( i ) ;
1321: LD_VAR 0 12
1325: PPUSH
1326: CALL_OW 140
// end ;
1330: GO 1303
1332: POP
1333: POP
// if fac then
1334: LD_VAR 0 9
1338: IFFALSE 1374
// if UnitsInside ( fac [ 1 ] ) then
1340: LD_VAR 0 9
1344: PUSH
1345: LD_INT 1
1347: ARRAY
1348: PPUSH
1349: CALL_OW 313
1353: IFFALSE 1374
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1355: LD_VAR 0 9
1359: PUSH
1360: LD_INT 1
1362: ARRAY
1363: PPUSH
1364: LD_INT 10
1366: PPUSH
1367: LD_INT 0
1369: PPUSH
1370: CALL_OW 486
// if lab then
1374: LD_VAR 0 8
1378: IFFALSE 1414
// if UnitsInside ( lab [ 1 ] ) then
1380: LD_VAR 0 8
1384: PUSH
1385: LD_INT 1
1387: ARRAY
1388: PPUSH
1389: CALL_OW 313
1393: IFFALSE 1414
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1395: LD_VAR 0 8
1399: PUSH
1400: LD_INT 1
1402: ARRAY
1403: PPUSH
1404: LD_INT 10
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1414: LD_ADDR_VAR 0 4
1418: PUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 1
1424: PPUSH
1425: LD_INT 1
1427: PPUSH
1428: LD_INT 2
1430: PPUSH
1431: LD_INT 1
1433: PPUSH
1434: LD_INT 3
1436: PPUSH
1437: LD_INT 100
1439: PPUSH
1440: CALL 4182 0 7
1444: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1445: LD_VAR 0 4
1449: PPUSH
1450: LD_INT 2
1452: PPUSH
1453: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1457: LD_VAR 0 4
1461: PPUSH
1462: LD_INT 21
1464: PPUSH
1465: LD_INT 8
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1475: LD_EXP 5
1479: PPUSH
1480: LD_VAR 0 4
1484: PPUSH
1485: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1489: LD_ADDR_VAR 0 4
1493: PUSH
1494: LD_INT 1
1496: PPUSH
1497: LD_INT 1
1499: PPUSH
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 2
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 2
1511: PPUSH
1512: LD_INT 100
1514: PPUSH
1515: CALL 4182 0 7
1519: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1520: LD_VAR 0 4
1524: PPUSH
1525: LD_INT 2
1527: PPUSH
1528: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1532: LD_VAR 0 4
1536: PPUSH
1537: LD_INT 16
1539: PPUSH
1540: LD_INT 3
1542: PPUSH
1543: LD_INT 0
1545: PPUSH
1546: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1550: LD_EXP 6
1554: PPUSH
1555: LD_VAR 0 4
1559: PPUSH
1560: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1564: LD_ADDR_VAR 0 4
1568: PUSH
1569: LD_INT 1
1571: PPUSH
1572: LD_INT 1
1574: PPUSH
1575: LD_INT 2
1577: PPUSH
1578: LD_INT 2
1580: PPUSH
1581: LD_INT 1
1583: PPUSH
1584: LD_INT 12
1586: PPUSH
1587: LD_INT 100
1589: PPUSH
1590: CALL 4182 0 7
1594: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1595: LD_VAR 0 4
1599: PPUSH
1600: LD_INT 0
1602: PPUSH
1603: LD_INT 5
1605: PPUSH
1606: CALL_OW 12
1610: PPUSH
1611: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1615: LD_VAR 0 4
1619: PPUSH
1620: LD_INT 1
1622: PPUSH
1623: LD_INT 0
1625: PPUSH
1626: CALL_OW 49
// end ;
1630: LD_VAR 0 1
1634: RET
// function PrepareBase ; var blist , i , b ; begin
1635: LD_INT 0
1637: PPUSH
1638: PPUSH
1639: PPUSH
1640: PPUSH
// blist := LoadVariable ( GammaBase , [ ] ) ;
1641: LD_ADDR_VAR 0 2
1645: PUSH
1646: LD_STRING GammaBase
1648: PPUSH
1649: EMPTY
1650: PPUSH
1651: CALL_OW 30
1655: ST_TO_ADDR
// if not blist and debug then
1656: LD_VAR 0 2
1660: NOT
1661: PUSH
1662: LD_EXP 1
1666: AND
1667: IFFALSE 1707
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1669: LD_ADDR_VAR 0 2
1673: PUSH
1674: LD_INT 0
1676: PUSH
1677: LD_INT 51
1679: PUSH
1680: LD_INT 10
1682: PUSH
1683: LD_INT 3
1685: PUSH
1686: LD_INT 3
1688: PUSH
1689: LD_INT 0
1691: PUSH
1692: LD_INT 0
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: PUSH
1704: EMPTY
1705: LIST
1706: ST_TO_ADDR
// if not blist then
1707: LD_VAR 0 2
1711: NOT
1712: IFFALSE 1716
// exit ;
1714: GO 1900
// uc_side := 1 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 1
1723: ST_TO_ADDR
// uc_nation := 1 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 1
1731: ST_TO_ADDR
// for i in blist do
1732: LD_ADDR_VAR 0 3
1736: PUSH
1737: LD_VAR 0 2
1741: PUSH
1742: FOR_IN
1743: IFFALSE 1898
// begin bc_type := i [ 1 ] ;
1745: LD_ADDR_OWVAR 42
1749: PUSH
1750: LD_VAR 0 3
1754: PUSH
1755: LD_INT 1
1757: ARRAY
1758: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1759: LD_ADDR_OWVAR 43
1763: PUSH
1764: LD_VAR 0 3
1768: PUSH
1769: LD_INT 5
1771: ARRAY
1772: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1773: LD_VAR 0 3
1777: PUSH
1778: LD_INT 1
1780: ARRAY
1781: PUSH
1782: LD_INT 7
1784: PUSH
1785: LD_INT 8
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: IN
1792: IFFALSE 1822
// begin bc_kind1 := i [ 7 ] ;
1794: LD_ADDR_OWVAR 44
1798: PUSH
1799: LD_VAR 0 3
1803: PUSH
1804: LD_INT 7
1806: ARRAY
1807: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1808: LD_ADDR_OWVAR 45
1812: PUSH
1813: LD_VAR 0 3
1817: PUSH
1818: LD_INT 8
1820: ARRAY
1821: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1822: LD_ADDR_VAR 0 4
1826: PUSH
1827: LD_VAR 0 3
1831: PUSH
1832: LD_INT 2
1834: ARRAY
1835: PPUSH
1836: LD_VAR 0 3
1840: PUSH
1841: LD_INT 3
1843: ARRAY
1844: PPUSH
1845: LD_VAR 0 3
1849: PUSH
1850: LD_INT 4
1852: ARRAY
1853: PPUSH
1854: CALL_OW 47
1858: ST_TO_ADDR
// if GetBType ( i [ 1 ] ) = b_bunker then
1859: LD_VAR 0 3
1863: PUSH
1864: LD_INT 1
1866: ARRAY
1867: PPUSH
1868: CALL_OW 266
1872: PUSH
1873: LD_INT 32
1875: EQUAL
1876: IFFALSE 1896
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
1878: LD_VAR 0 4
1882: PPUSH
1883: LD_VAR 0 3
1887: PUSH
1888: LD_INT 7
1890: ARRAY
1891: PPUSH
1892: CALL_OW 431
// end ; end ;
1896: GO 1742
1898: POP
1899: POP
// end ; end_of_file
1900: LD_VAR 0 1
1904: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
1905: LD_INT 0
1907: PPUSH
1908: PPUSH
1909: PPUSH
1910: PPUSH
1911: PPUSH
1912: PPUSH
1913: PPUSH
1914: PPUSH
// InGameOn ;
1915: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
1919: LD_INT 33
1921: PPUSH
1922: LD_INT 11
1924: PPUSH
1925: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
1929: LD_ADDR_VAR 0 2
1933: PUSH
1934: LD_INT 29
1936: PUSH
1937: LD_INT 21
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: PUSH
1944: LD_INT 41
1946: PUSH
1947: LD_INT 28
1949: PUSH
1950: EMPTY
1951: LIST
1952: LIST
1953: PUSH
1954: LD_INT 52
1956: PUSH
1957: LD_INT 26
1959: PUSH
1960: EMPTY
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 49
1966: PUSH
1967: LD_INT 16
1969: PUSH
1970: EMPTY
1971: LIST
1972: LIST
1973: PUSH
1974: EMPTY
1975: LIST
1976: LIST
1977: LIST
1978: LIST
1979: ST_TO_ADDR
// for i in points do
1980: LD_ADDR_VAR 0 3
1984: PUSH
1985: LD_VAR 0 2
1989: PUSH
1990: FOR_IN
1991: IFFALSE 2031
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_EXP 6
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: PPUSH
2007: LD_VAR 0 3
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_VAR 0 3
2020: PUSH
2021: LD_INT 2
2023: ARRAY
2024: PPUSH
2025: CALL_OW 171
2029: GO 1990
2031: POP
2032: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2033: LD_EXP 5
2037: PUSH
2038: LD_EXP 6
2042: PUSH
2043: EMPTY
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2058: LD_EXP 5
2062: PPUSH
2063: CALL_OW 310
2067: NOT
2068: PUSH
2069: LD_EXP 6
2073: PPUSH
2074: CALL_OW 310
2078: NOT
2079: AND
2080: IFFALSE 2051
// ComTurnUnit ( JMM , Gladstone ) ;
2082: LD_EXP 5
2086: PPUSH
2087: LD_EXP 6
2091: PPUSH
2092: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2096: LD_EXP 6
2100: PPUSH
2101: LD_EXP 5
2105: PPUSH
2106: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2110: LD_ADDR_VAR 0 4
2114: PUSH
2115: LD_INT 26
2117: PUSH
2118: LD_INT 1
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PPUSH
2125: CALL_OW 69
2129: PUSH
2130: LD_EXP 5
2134: PUSH
2135: LD_EXP 6
2139: PUSH
2140: LD_EXP 10
2144: PUSH
2145: LD_EXP 9
2149: PUSH
2150: LD_EXP 7
2154: PUSH
2155: LD_EXP 12
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: LIST
2167: DIFF
2168: ST_TO_ADDR
// if sol then
2169: LD_VAR 0 4
2173: IFFALSE 2189
// sol := sol [ 1 ] ;
2175: LD_ADDR_VAR 0 4
2179: PUSH
2180: LD_VAR 0 4
2184: PUSH
2185: LD_INT 1
2187: ARRAY
2188: ST_TO_ADDR
// team := [ ] ;
2189: LD_ADDR_VAR 0 5
2193: PUSH
2194: EMPTY
2195: ST_TO_ADDR
// if sol then
2196: LD_VAR 0 4
2200: IFFALSE 2218
// team := team ^ sol ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_VAR 0 4
2216: ADD
2217: ST_TO_ADDR
// if Lisa then
2218: LD_EXP 8
2222: IFFALSE 2240
// team := team ^ Lisa ;
2224: LD_ADDR_VAR 0 5
2228: PUSH
2229: LD_VAR 0 5
2233: PUSH
2234: LD_EXP 8
2238: ADD
2239: ST_TO_ADDR
// if Donaldson then
2240: LD_EXP 11
2244: IFFALSE 2262
// team := team ^ Donaldson ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 11
2260: ADD
2261: ST_TO_ADDR
// if Brown then
2262: LD_EXP 12
2266: IFFALSE 2284
// team := team ^ Brown ;
2268: LD_ADDR_VAR 0 5
2272: PUSH
2273: LD_VAR 0 5
2277: PUSH
2278: LD_EXP 12
2282: ADD
2283: ST_TO_ADDR
// if Bobby then
2284: LD_EXP 10
2288: IFFALSE 2306
// team := team ^ Bobby ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 10
2304: ADD
2305: ST_TO_ADDR
// if Cyrus then
2306: LD_EXP 9
2310: IFFALSE 2328
// team := team ^ Cyrus ;
2312: LD_ADDR_VAR 0 5
2316: PUSH
2317: LD_VAR 0 5
2321: PUSH
2322: LD_EXP 9
2326: ADD
2327: ST_TO_ADDR
// if Frank then
2328: LD_EXP 7
2332: IFFALSE 2350
// team := team ^ Frank ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 7
2348: ADD
2349: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2350: LD_ADDR_VAR 0 3
2354: PUSH
2355: LD_INT 1
2357: PPUSH
2358: LD_INT 3
2360: PUSH
2361: LD_INT 54
2363: PUSH
2364: EMPTY
2365: LIST
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 70
2389: PUSH
2390: LD_EXP 5
2394: PUSH
2395: LD_EXP 6
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: DIFF
2404: PUSH
2405: EMPTY
2406: LIST
2407: PUSH
2408: FOR_IN
2409: IFFALSE 2429
// team := team ^ i ;
2411: LD_ADDR_VAR 0 5
2415: PUSH
2416: LD_VAR 0 5
2420: PUSH
2421: LD_VAR 0 3
2425: ADD
2426: ST_TO_ADDR
2427: GO 2408
2429: POP
2430: POP
// if team then
2431: LD_VAR 0 5
2435: IFFALSE 2511
// begin ComExitBuilding ( team ) ;
2437: LD_VAR 0 5
2441: PPUSH
2442: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2446: LD_VAR 0 5
2450: PPUSH
2451: LD_EXP 5
2455: PPUSH
2456: CALL_OW 172
// repeat wait ( 1 ) ;
2460: LD_INT 1
2462: PPUSH
2463: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2467: LD_EXP 5
2471: PPUSH
2472: LD_VAR 0 5
2476: PPUSH
2477: LD_EXP 5
2481: PPUSH
2482: CALL_OW 74
2486: PPUSH
2487: CALL_OW 296
2491: PUSH
2492: LD_INT 6
2494: LESS
2495: IFFALSE 2460
// ComTurnUnit ( team , JMM ) ;
2497: LD_VAR 0 5
2501: PPUSH
2502: LD_EXP 5
2506: PPUSH
2507: CALL_OW 119
// end ; if Lisa then
2511: LD_EXP 8
2515: IFFALSE 2543
// begin ComTurnUnit ( JMM , Lisa ) ;
2517: LD_EXP 5
2521: PPUSH
2522: LD_EXP 8
2526: PPUSH
2527: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2531: LD_EXP 8
2535: PPUSH
2536: LD_STRING D1-Lisa-1
2538: PPUSH
2539: CALL_OW 88
// end ; if sol then
2543: LD_VAR 0 4
2547: IFFALSE 2575
// begin ComTurnUnit ( JMM , sol ) ;
2549: LD_EXP 5
2553: PPUSH
2554: LD_VAR 0 4
2558: PPUSH
2559: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2563: LD_VAR 0 4
2567: PPUSH
2568: LD_STRING D1-Sol1-1
2570: PPUSH
2571: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2575: LD_EXP 5
2579: PPUSH
2580: LD_STRING D1-JMM-1
2582: PPUSH
2583: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2587: LD_EXP 5
2591: PPUSH
2592: LD_STRING D1-JMM-1a
2594: PPUSH
2595: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2599: LD_EXP 5
2603: PPUSH
2604: LD_EXP 6
2608: PPUSH
2609: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2613: LD_VAR 0 5
2617: PPUSH
2618: LD_EXP 6
2622: PPUSH
2623: CALL_OW 119
// if Frank then
2627: LD_EXP 7
2631: IFFALSE 2659
// begin Say ( Frank , D1-Frank-1 ) ;
2633: LD_EXP 7
2637: PPUSH
2638: LD_STRING D1-Frank-1
2640: PPUSH
2641: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2645: LD_EXP 5
2649: PPUSH
2650: LD_EXP 7
2654: PPUSH
2655: CALL_OW 119
// end ; if Lisa then
2659: LD_EXP 8
2663: IFFALSE 2691
// begin ComTurnUnit ( JMM , Lisa ) ;
2665: LD_EXP 5
2669: PPUSH
2670: LD_EXP 8
2674: PPUSH
2675: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2679: LD_EXP 8
2683: PPUSH
2684: LD_STRING D1-Lisa-2
2686: PPUSH
2687: CALL_OW 88
// end ; if sol then
2691: LD_VAR 0 4
2695: IFFALSE 2723
// begin ComTurnUnit ( JMM , sol ) ;
2697: LD_EXP 5
2701: PPUSH
2702: LD_VAR 0 4
2706: PPUSH
2707: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2711: LD_VAR 0 4
2715: PPUSH
2716: LD_STRING D1-Sol1-2
2718: PPUSH
2719: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2723: LD_EXP 6
2727: PPUSH
2728: LD_STRING D1-Glad-2
2730: PPUSH
2731: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2735: LD_VAR 0 5
2739: PPUSH
2740: LD_EXP 5
2744: PPUSH
2745: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2749: LD_EXP 5
2753: PPUSH
2754: LD_STRING D1-JMM-2
2756: PPUSH
2757: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2761: LD_EXP 5
2765: PPUSH
2766: LD_EXP 6
2770: PPUSH
2771: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2775: LD_EXP 6
2779: PPUSH
2780: LD_STRING D1-Glad-3
2782: PPUSH
2783: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2787: LD_EXP 5
2791: PPUSH
2792: LD_STRING D1-JMM-3
2794: PPUSH
2795: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2799: LD_EXP 6
2803: PPUSH
2804: LD_STRING D1-Glad-4
2806: PPUSH
2807: CALL_OW 88
// if Frank then
2811: LD_EXP 7
2815: IFFALSE 2843
// begin ComTurnUnit ( JMM , Frank ) ;
2817: LD_EXP 5
2821: PPUSH
2822: LD_EXP 7
2826: PPUSH
2827: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2831: LD_EXP 7
2835: PPUSH
2836: LD_STRING D1-Frank-4
2838: PPUSH
2839: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
2843: LD_EXP 5
2847: PPUSH
2848: LD_EXP 6
2852: PPUSH
2853: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
2857: LD_EXP 5
2861: PPUSH
2862: LD_STRING D1-JMM-4
2864: PPUSH
2865: CALL_OW 88
// if Lisa then
2869: LD_EXP 8
2873: IFFALSE 2940
// begin Say ( Lisa , D1-Lisa-4 ) ;
2875: LD_EXP 8
2879: PPUSH
2880: LD_STRING D1-Lisa-4
2882: PPUSH
2883: CALL_OW 88
// if Frank then
2887: LD_EXP 7
2891: IFFALSE 2940
// begin ComTurnUnit ( Frank , Lisa ) ;
2893: LD_EXP 7
2897: PPUSH
2898: LD_EXP 8
2902: PPUSH
2903: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
2907: LD_EXP 7
2911: PPUSH
2912: LD_STRING D1-Frank-5
2914: PPUSH
2915: CALL_OW 88
// Wait ( 3 ) ;
2919: LD_INT 3
2921: PPUSH
2922: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
2926: LD_EXP 7
2930: PPUSH
2931: LD_EXP 5
2935: PPUSH
2936: CALL_OW 179
// end ; end ; if sol then
2940: LD_VAR 0 4
2944: IFFALSE 2958
// Say ( sol , D1-Sol1-5 ) ;
2946: LD_VAR 0 4
2950: PPUSH
2951: LD_STRING D1-Sol1-5
2953: PPUSH
2954: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
2958: LD_EXP 5
2962: PPUSH
2963: LD_STRING D1-JMM-5
2965: PPUSH
2966: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
2970: LD_EXP 6
2974: PPUSH
2975: LD_STRING D1-Glad-5
2977: PPUSH
2978: CALL_OW 88
// if Frank then
2982: LD_EXP 7
2986: IFFALSE 3000
// Say ( Frank , D1-Frank-6 ) ;
2988: LD_EXP 7
2992: PPUSH
2993: LD_STRING D1-Frank-6
2995: PPUSH
2996: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3000: LD_EXP 5
3004: PPUSH
3005: LD_STRING D1-JMM-6
3007: PPUSH
3008: CALL_OW 88
// if Brown and Donaldson then
3012: LD_EXP 12
3016: PUSH
3017: LD_EXP 11
3021: AND
3022: IFFALSE 3071
// case Query ( QCommander ) of 1 :
3024: LD_STRING QCommander
3026: PPUSH
3027: CALL_OW 97
3031: PUSH
3032: LD_INT 1
3034: DOUBLE
3035: EQUAL
3036: IFTRUE 3040
3038: GO 3051
3040: POP
// donaldson_commander := true ; 2 :
3041: LD_ADDR_EXP 2
3045: PUSH
3046: LD_INT 1
3048: ST_TO_ADDR
3049: GO 3071
3051: LD_INT 2
3053: DOUBLE
3054: EQUAL
3055: IFTRUE 3059
3057: GO 3070
3059: POP
// brown_commander := true ; end ;
3060: LD_ADDR_EXP 3
3064: PUSH
3065: LD_INT 1
3067: ST_TO_ADDR
3068: GO 3071
3070: POP
// if not Brown and Donaldson then
3071: LD_EXP 12
3075: NOT
3076: PUSH
3077: LD_EXP 11
3081: AND
3082: IFFALSE 3092
// donaldson_commander := true ;
3084: LD_ADDR_EXP 2
3088: PUSH
3089: LD_INT 1
3091: ST_TO_ADDR
// if Brown and not Donaldson then
3092: LD_EXP 12
3096: PUSH
3097: LD_EXP 11
3101: NOT
3102: AND
3103: IFFALSE 3113
// brown_commander := true ;
3105: LD_ADDR_EXP 3
3109: PUSH
3110: LD_INT 1
3112: ST_TO_ADDR
// if donaldson_commander then
3113: LD_EXP 2
3117: IFFALSE 3264
// begin ComTurnUnit ( JMM , Donaldson ) ;
3119: LD_EXP 5
3123: PPUSH
3124: LD_EXP 11
3128: PPUSH
3129: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3133: LD_EXP 5
3137: PPUSH
3138: LD_STRING D1a-JMM-1
3140: PPUSH
3141: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3145: LD_EXP 11
3149: PPUSH
3150: LD_EXP 5
3154: PPUSH
3155: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3159: LD_EXP 11
3163: PPUSH
3164: LD_EXP 5
3168: PPUSH
3169: CALL_OW 179
// Wait ( 3 ) ;
3173: LD_INT 3
3175: PPUSH
3176: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3180: LD_EXP 11
3184: PPUSH
3185: LD_STRING D1a-Don-1
3187: PPUSH
3188: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3192: LD_EXP 5
3196: PPUSH
3197: LD_STRING D1b-JMM-2
3199: PPUSH
3200: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3204: LD_EXP 11
3208: PPUSH
3209: LD_STRING D1a-Don-2
3211: PPUSH
3212: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3216: LD_EXP 11
3220: PPUSH
3221: LD_INT 30
3223: PUSH
3224: LD_INT 0
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PPUSH
3231: CALL_OW 69
3235: PUSH
3236: LD_INT 1
3238: ARRAY
3239: PPUSH
3240: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3244: LD_INT 1
3246: PPUSH
3247: LD_STRING GammaCommander
3249: PPUSH
3250: CALL_OW 39
// commander := Donaldson ;
3254: LD_ADDR_VAR 0 7
3258: PUSH
3259: LD_EXP 11
3263: ST_TO_ADDR
// end ; if brown_commander then
3264: LD_EXP 3
3268: IFFALSE 3415
// begin ComTurnUnit ( JMM , Brown ) ;
3270: LD_EXP 5
3274: PPUSH
3275: LD_EXP 12
3279: PPUSH
3280: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3284: LD_EXP 5
3288: PPUSH
3289: LD_STRING D1b-JMM-1
3291: PPUSH
3292: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3296: LD_EXP 12
3300: PPUSH
3301: LD_EXP 5
3305: PPUSH
3306: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3310: LD_EXP 12
3314: PPUSH
3315: LD_EXP 5
3319: PPUSH
3320: CALL_OW 179
// Wait ( 3 ) ;
3324: LD_INT 3
3326: PPUSH
3327: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3331: LD_EXP 12
3335: PPUSH
3336: LD_STRING D1b-Brown-1
3338: PPUSH
3339: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3343: LD_EXP 5
3347: PPUSH
3348: LD_STRING D1a-JMM-2
3350: PPUSH
3351: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3355: LD_EXP 12
3359: PPUSH
3360: LD_STRING D1b-Brown-2
3362: PPUSH
3363: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3367: LD_EXP 12
3371: PPUSH
3372: LD_INT 30
3374: PUSH
3375: LD_INT 0
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PPUSH
3382: CALL_OW 69
3386: PUSH
3387: LD_INT 1
3389: ARRAY
3390: PPUSH
3391: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3395: LD_INT 2
3397: PPUSH
3398: LD_STRING GammaCommander
3400: PPUSH
3401: CALL_OW 39
// commander := Brown ;
3405: LD_ADDR_VAR 0 7
3409: PUSH
3410: LD_EXP 12
3414: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3415: LD_EXP 5
3419: PPUSH
3420: LD_EXP 6
3424: PPUSH
3425: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3429: LD_EXP 2
3433: NOT
3434: PUSH
3435: LD_EXP 3
3439: NOT
3440: AND
3441: IFFALSE 3465
// begin Say ( JMM , D1c-JMM-1 ) ;
3443: LD_EXP 5
3447: PPUSH
3448: LD_STRING D1c-JMM-1
3450: PPUSH
3451: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3455: LD_INT 3
3457: PPUSH
3458: LD_STRING GammaCommander
3460: PPUSH
3461: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3465: LD_EXP 5
3469: PPUSH
3470: LD_STRING D1d-JMM-1
3472: PPUSH
3473: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_INT 21
3484: PUSH
3485: LD_INT 1
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: PPUSH
3492: CALL_OW 69
3496: PUSH
3497: LD_EXP 5
3501: PUSH
3502: LD_EXP 6
3506: PUSH
3507: LD_VAR 0 7
3511: PUSH
3512: EMPTY
3513: LIST
3514: LIST
3515: LIST
3516: DIFF
3517: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3518: LD_ADDR_EXP 4
3522: PUSH
3523: LD_STRING 1
3525: PPUSH
3526: LD_INT 5
3528: PPUSH
3529: LD_INT 5
3531: PPUSH
3532: LD_INT -5
3534: PUSH
3535: LD_EXP 5
3539: PUSH
3540: LD_INT -6
3542: PUSH
3543: LD_EXP 6
3547: PUSH
3548: LD_INT -2
3550: PUSH
3551: LD_INT -3
3553: PUSH
3554: LD_INT -5
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_VAR 0 6
3570: ADD
3571: PUSH
3572: LD_INT -6
3574: PUSH
3575: LD_INT -4
3577: PUSH
3578: LD_VAR 0 7
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: ADD
3588: PPUSH
3589: LD_INT 1
3591: PUSH
3592: LD_INT 3
3594: PUSH
3595: LD_INT 2
3597: PUSH
3598: LD_INT 1
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 4
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 42
3618: ST_TO_ADDR
// SaveCharacters ( all diff [ save_group , JMM , Gladstone ] , othersGamma ) ;
3619: LD_VAR 0 6
3623: PUSH
3624: LD_EXP 4
3628: PUSH
3629: LD_EXP 5
3633: PUSH
3634: LD_EXP 6
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: LIST
3643: DIFF
3644: PPUSH
3645: LD_STRING othersGamma
3647: PPUSH
3648: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
3652: LD_EXP 4
3656: PUSH
3657: LD_EXP 5
3661: PUSH
3662: LD_EXP 6
3666: PUSH
3667: LD_EXP 8
3671: PUSH
3672: LD_EXP 9
3676: PUSH
3677: LD_EXP 10
3681: PUSH
3682: LD_EXP 7
3686: PUSH
3687: LD_EXP 11
3691: PUSH
3692: LD_EXP 12
3696: PUSH
3697: LD_INT 0
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: LIST
3706: LIST
3707: LIST
3708: LIST
3709: LIST
3710: DIFF
3711: PPUSH
3712: LD_STRING othersDelta
3714: PPUSH
3715: CALL_OW 38
// if Lisa in save_group then
3719: LD_EXP 8
3723: PUSH
3724: LD_EXP 4
3728: IN
3729: IFFALSE 3753
// begin SaveCharacters ( Lisa , Lisa ) ;
3731: LD_EXP 8
3735: PPUSH
3736: LD_STRING Lisa
3738: PPUSH
3739: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
3743: LD_INT 1
3745: PPUSH
3746: LD_STRING LisaInDelta
3748: PPUSH
3749: CALL_OW 39
// end ; if Bobby in save_group then
3753: LD_EXP 10
3757: PUSH
3758: LD_EXP 4
3762: IN
3763: IFFALSE 3787
// begin SaveCharacters ( Bobby , Bobby ) ;
3765: LD_EXP 10
3769: PPUSH
3770: LD_STRING Bobby
3772: PPUSH
3773: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
3777: LD_INT 1
3779: PPUSH
3780: LD_STRING BobbyInDelta
3782: PPUSH
3783: CALL_OW 39
// end ; if Cyrus in save_group then
3787: LD_EXP 9
3791: PUSH
3792: LD_EXP 4
3796: IN
3797: IFFALSE 3821
// begin SaveCharacters ( Cyrus , Cyrus ) ;
3799: LD_EXP 9
3803: PPUSH
3804: LD_STRING Cyrus
3806: PPUSH
3807: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
3811: LD_INT 1
3813: PPUSH
3814: LD_STRING CyrusInDelta
3816: PPUSH
3817: CALL_OW 39
// end ; if Frank in save_group then
3821: LD_EXP 7
3825: PUSH
3826: LD_EXP 4
3830: IN
3831: IFFALSE 3855
// begin SaveCharacters ( Frank , Frank ) ;
3833: LD_EXP 7
3837: PPUSH
3838: LD_STRING Frank
3840: PPUSH
3841: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
3845: LD_INT 1
3847: PPUSH
3848: LD_STRING FrankInDelta
3850: PPUSH
3851: CALL_OW 39
// end ; if Brown in save_group then
3855: LD_EXP 12
3859: PUSH
3860: LD_EXP 4
3864: IN
3865: IFFALSE 3889
// begin SaveCharacters ( Brown , Brown ) ;
3867: LD_EXP 12
3871: PPUSH
3872: LD_STRING Brown
3874: PPUSH
3875: CALL_OW 38
// SaveVariable ( true , BrownInDelta ) ;
3879: LD_INT 1
3881: PPUSH
3882: LD_STRING BrownInDelta
3884: PPUSH
3885: CALL_OW 39
// end ; if Donaldson in save_group then
3889: LD_EXP 11
3893: PUSH
3894: LD_EXP 4
3898: IN
3899: IFFALSE 3923
// begin SaveCharacters ( Donaldson , Donaldson ) ;
3901: LD_EXP 11
3905: PPUSH
3906: LD_STRING Donaldson
3908: PPUSH
3909: CALL_OW 38
// SaveVariable ( true , DonaldsonInDelta ) ;
3913: LD_INT 1
3915: PPUSH
3916: LD_STRING DonaldsonInDelta
3918: PPUSH
3919: CALL_OW 39
// end ; Wait ( 3 ) ;
3923: LD_INT 3
3925: PPUSH
3926: CALL_OW 67
// for i in save_group do
3930: LD_ADDR_VAR 0 3
3934: PUSH
3935: LD_EXP 4
3939: PUSH
3940: FOR_IN
3941: IFFALSE 3972
// begin if IsInUnit ( i ) then
3943: LD_VAR 0 3
3947: PPUSH
3948: CALL_OW 310
3952: IFFALSE 3963
// ComExitBuilding ( i ) ;
3954: LD_VAR 0 3
3958: PPUSH
3959: CALL_OW 122
// Wait ( 3 ) ;
3963: LD_INT 3
3965: PPUSH
3966: CALL_OW 67
// end ;
3970: GO 3940
3972: POP
3973: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
3974: LD_ADDR_EXP 4
3978: PUSH
3979: LD_EXP 4
3983: PPUSH
3984: LD_INT 1
3986: PPUSH
3987: LD_EXP 5
3991: PPUSH
3992: CALL_OW 2
3996: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
3997: LD_ADDR_EXP 4
4001: PUSH
4002: LD_EXP 4
4006: PPUSH
4007: LD_INT 2
4009: PPUSH
4010: LD_EXP 6
4014: PPUSH
4015: CALL_OW 2
4019: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4020: LD_ADDR_VAR 0 8
4024: PUSH
4025: LD_INT 21
4027: PUSH
4028: LD_INT 2
4030: PUSH
4031: EMPTY
4032: LIST
4033: LIST
4034: PPUSH
4035: CALL_OW 69
4039: ST_TO_ADDR
// for i = 1 to filter do
4040: LD_ADDR_VAR 0 3
4044: PUSH
4045: DOUBLE
4046: LD_INT 1
4048: DEC
4049: ST_TO_ADDR
4050: LD_VAR 0 8
4054: PUSH
4055: FOR_TO
4056: IFFALSE 4086
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4058: LD_EXP 4
4062: PUSH
4063: LD_VAR 0 3
4067: ARRAY
4068: PPUSH
4069: LD_VAR 0 8
4073: PUSH
4074: LD_VAR 0 3
4078: ARRAY
4079: PPUSH
4080: CALL_OW 120
4084: GO 4055
4086: POP
4087: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4088: LD_EXP 4
4092: PPUSH
4093: LD_INT 87
4095: PPUSH
4096: LD_INT 27
4098: PPUSH
4099: CALL_OW 171
// Wait ( 0 0$05 ) ;
4103: LD_INT 175
4105: PPUSH
4106: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4110: LD_INT 1
4112: PPUSH
4113: LD_STRING %_cont
4115: PPUSH
4116: CALL_OW 340
// end ; end_of_file
4120: LD_VAR 0 1
4124: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4125: LD_INT 0
4127: PPUSH
4128: PPUSH
// if exist_mode then
4129: LD_VAR 0 2
4133: IFFALSE 4152
// unit := CreateCharacter ( ident ) else
4135: LD_ADDR_VAR 0 4
4139: PUSH
4140: LD_VAR 0 1
4144: PPUSH
4145: CALL_OW 34
4149: ST_TO_ADDR
4150: GO 4167
// unit := NewCharacter ( ident ) ;
4152: LD_ADDR_VAR 0 4
4156: PUSH
4157: LD_VAR 0 1
4161: PPUSH
4162: CALL_OW 25
4166: ST_TO_ADDR
// result := unit ;
4167: LD_ADDR_VAR 0 3
4171: PUSH
4172: LD_VAR 0 4
4176: ST_TO_ADDR
// end ;
4177: LD_VAR 0 3
4181: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4182: LD_INT 0
4184: PPUSH
// uc_side := side ;
4185: LD_ADDR_OWVAR 20
4189: PUSH
4190: LD_VAR 0 1
4194: ST_TO_ADDR
// uc_nation := nation ;
4195: LD_ADDR_OWVAR 21
4199: PUSH
4200: LD_VAR 0 2
4204: ST_TO_ADDR
// vc_chassis := chassis ;
4205: LD_ADDR_OWVAR 37
4209: PUSH
4210: LD_VAR 0 3
4214: ST_TO_ADDR
// vc_engine := engine ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_VAR 0 4
4224: ST_TO_ADDR
// vc_control := control ;
4225: LD_ADDR_OWVAR 38
4229: PUSH
4230: LD_VAR 0 5
4234: ST_TO_ADDR
// vc_weapon := weapon ;
4235: LD_ADDR_OWVAR 40
4239: PUSH
4240: LD_VAR 0 6
4244: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4245: LD_ADDR_OWVAR 41
4249: PUSH
4250: LD_VAR 0 7
4254: ST_TO_ADDR
// result := CreateVehicle ;
4255: LD_ADDR_VAR 0 8
4259: PUSH
4260: CALL_OW 45
4264: ST_TO_ADDR
// end ;
4265: LD_VAR 0 8
4269: RET
// export function SayX ( units , ident ) ; var i ; begin
4270: LD_INT 0
4272: PPUSH
4273: PPUSH
// result := false ;
4274: LD_ADDR_VAR 0 3
4278: PUSH
4279: LD_INT 0
4281: ST_TO_ADDR
// if not units then
4282: LD_VAR 0 1
4286: NOT
4287: IFFALSE 4291
// exit ;
4289: GO 4345
// for i in units do
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_VAR 0 1
4300: PUSH
4301: FOR_IN
4302: IFFALSE 4343
// if IsOk ( i ) then
4304: LD_VAR 0 4
4308: PPUSH
4309: CALL_OW 302
4313: IFFALSE 4341
// begin Say ( i , ident ) ;
4315: LD_VAR 0 4
4319: PPUSH
4320: LD_VAR 0 2
4324: PPUSH
4325: CALL_OW 88
// result := i ;
4329: LD_ADDR_VAR 0 3
4333: PUSH
4334: LD_VAR 0 4
4338: ST_TO_ADDR
// break ;
4339: GO 4343
// end ;
4341: GO 4301
4343: POP
4344: POP
// end ;
4345: LD_VAR 0 3
4349: RET
