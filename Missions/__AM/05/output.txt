// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 1984 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
// PrepareBase ;
 118: CALL 1718 0 0
// uc_side := 1 ;
 122: LD_ADDR_OWVAR 20
 126: PUSH
 127: LD_INT 1
 129: ST_TO_ADDR
// uc_nation := 1 ;
 130: LD_ADDR_OWVAR 21
 134: PUSH
 135: LD_INT 1
 137: ST_TO_ADDR
// team := [ ] ;
 138: LD_ADDR_VAR 0 5
 142: PUSH
 143: EMPTY
 144: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 145: LD_ADDR_EXP 7
 149: PUSH
 150: LD_STRING JMM
 152: PPUSH
 153: LD_EXP 1
 157: NOT
 158: PPUSH
 159: CALL 4162 0 2
 163: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 164: LD_ADDR_EXP 8
 168: PUSH
 169: LD_STRING Gladstone
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: CALL 4162 0 2
 179: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 180: LD_ADDR_EXP 9
 184: PUSH
 185: LD_STRING Frank
 187: PPUSH
 188: LD_EXP 1
 192: NOT
 193: PPUSH
 194: CALL 4162 0 2
 198: ST_TO_ADDR
// if Frank then
 199: LD_EXP 9
 203: IFFALSE 221
// team := team ^ Frank ;
 205: LD_ADDR_VAR 0 5
 209: PUSH
 210: LD_VAR 0 5
 214: PUSH
 215: LD_EXP 9
 219: ADD
 220: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 221: LD_ADDR_EXP 10
 225: PUSH
 226: LD_STRING Lisa
 228: PPUSH
 229: LD_EXP 1
 233: NOT
 234: PPUSH
 235: CALL 4162 0 2
 239: ST_TO_ADDR
// if Lisa then
 240: LD_EXP 10
 244: IFFALSE 262
// team := team ^ Lisa ;
 246: LD_ADDR_VAR 0 5
 250: PUSH
 251: LD_VAR 0 5
 255: PUSH
 256: LD_EXP 10
 260: ADD
 261: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 262: LD_ADDR_EXP 13
 266: PUSH
 267: LD_STRING Donaldson
 269: PPUSH
 270: LD_EXP 1
 274: NOT
 275: PPUSH
 276: CALL 4162 0 2
 280: ST_TO_ADDR
// if Donaldson then
 281: LD_EXP 13
 285: IFFALSE 303
// team := team ^ Donaldson ;
 287: LD_ADDR_VAR 0 5
 291: PUSH
 292: LD_VAR 0 5
 296: PUSH
 297: LD_EXP 13
 301: ADD
 302: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 303: LD_ADDR_EXP 14
 307: PUSH
 308: LD_STRING Brown
 310: PPUSH
 311: LD_EXP 1
 315: NOT
 316: PPUSH
 317: CALL 4162 0 2
 321: ST_TO_ADDR
// if Brown then
 322: LD_EXP 14
 326: IFFALSE 344
// team := team ^ Brown ;
 328: LD_ADDR_VAR 0 5
 332: PUSH
 333: LD_VAR 0 5
 337: PUSH
 338: LD_EXP 14
 342: ADD
 343: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_STRING 04_other_survivors
 351: PPUSH
 352: CALL_OW 31
 356: ST_TO_ADDR
// if not Lisa then
 357: LD_EXP 10
 361: NOT
 362: IFFALSE 473
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 364: LD_ADDR_EXP 11
 368: PUSH
 369: LD_STRING Cyrus
 371: PPUSH
 372: LD_EXP 1
 376: NOT
 377: PPUSH
 378: CALL 4162 0 2
 382: ST_TO_ADDR
// if Cyrus then
 383: LD_EXP 11
 387: IFFALSE 405
// team := team ^ Cyrus ;
 389: LD_ADDR_VAR 0 5
 393: PUSH
 394: LD_VAR 0 5
 398: PUSH
 399: LD_EXP 11
 403: ADD
 404: ST_TO_ADDR
// if not Cyrus then
 405: LD_EXP 11
 409: NOT
 410: IFFALSE 473
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 412: LD_ADDR_EXP 12
 416: PUSH
 417: LD_STRING Bobby
 419: PPUSH
 420: LD_EXP 1
 424: NOT
 425: PPUSH
 426: CALL 4162 0 2
 430: ST_TO_ADDR
// if Bobby then
 431: LD_EXP 12
 435: IFFALSE 453
// team := team ^ Bobby ;
 437: LD_ADDR_VAR 0 5
 441: PUSH
 442: LD_VAR 0 5
 446: PUSH
 447: LD_EXP 12
 451: ADD
 452: ST_TO_ADDR
// if not Bobby then
 453: LD_EXP 12
 457: NOT
 458: IFFALSE 473
// begin others3 := CreateCharacterSet ( 03_others ) ;
 460: LD_ADDR_VAR 0 2
 464: PUSH
 465: LD_STRING 03_others
 467: PPUSH
 468: CALL_OW 31
 472: ST_TO_ADDR
// end ; end ; end ; if others4 then
 473: LD_VAR 0 3
 477: IFFALSE 495
// team := team ^ others4 ;
 479: LD_ADDR_VAR 0 5
 483: PUSH
 484: LD_VAR 0 5
 488: PUSH
 489: LD_VAR 0 3
 493: ADD
 494: ST_TO_ADDR
// if others3 then
 495: LD_VAR 0 2
 499: IFFALSE 517
// team := team ^ others3 ;
 501: LD_ADDR_VAR 0 5
 505: PUSH
 506: LD_VAR 0 5
 510: PUSH
 511: LD_VAR 0 2
 515: ADD
 516: ST_TO_ADDR
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 517: LD_ADDR_VAR 0 6
 521: PUSH
 522: LD_INT 30
 524: PUSH
 525: LD_INT 0
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: PPUSH
 532: CALL_OW 69
 536: PUSH
 537: LD_INT 1
 539: ARRAY
 540: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 541: LD_ADDR_VAR 0 7
 545: PUSH
 546: LD_INT 30
 548: PUSH
 549: LD_INT 4
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL_OW 69
 560: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 561: LD_ADDR_VAR 0 8
 565: PUSH
 566: LD_INT 2
 568: PUSH
 569: LD_INT 30
 571: PUSH
 572: LD_INT 7
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: PUSH
 579: LD_INT 30
 581: PUSH
 582: LD_INT 6
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: PPUSH
 594: CALL_OW 69
 598: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 599: LD_ADDR_VAR 0 9
 603: PUSH
 604: LD_INT 30
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PPUSH
 614: CALL_OW 69
 618: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 619: LD_ADDR_VAR 0 10
 623: PUSH
 624: LD_INT 2
 626: PUSH
 627: LD_INT 30
 629: PUSH
 630: LD_INT 32
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 30
 639: PUSH
 640: LD_INT 31
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: PPUSH
 652: CALL_OW 69
 656: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 657: LD_VAR 0 6
 661: PPUSH
 662: LD_STRING Gamma
 664: PPUSH
 665: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 669: LD_VAR 0 6
 673: PPUSH
 674: CALL_OW 274
 678: PPUSH
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 10000
 684: PPUSH
 685: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 689: LD_VAR 0 6
 693: PPUSH
 694: CALL_OW 274
 698: PPUSH
 699: LD_INT 1
 701: PPUSH
 702: LD_INT 10000
 704: PPUSH
 705: CALL_OW 277
// if dep then
 709: LD_VAR 0 6
 713: IFFALSE 795
// begin if Brown then
 715: LD_EXP 14
 719: IFFALSE 755
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 721: LD_EXP 14
 725: PPUSH
 726: LD_VAR 0 6
 730: PUSH
 731: LD_INT 1
 733: ARRAY
 734: PPUSH
 735: CALL_OW 52
// team := team diff Brown ;
 739: LD_ADDR_VAR 0 5
 743: PUSH
 744: LD_VAR 0 5
 748: PUSH
 749: LD_EXP 14
 753: DIFF
 754: ST_TO_ADDR
// end ; if Donaldson then
 755: LD_EXP 13
 759: IFFALSE 795
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 761: LD_EXP 13
 765: PPUSH
 766: LD_VAR 0 6
 770: PUSH
 771: LD_INT 1
 773: ARRAY
 774: PPUSH
 775: CALL_OW 52
// team := team diff Donaldson ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 5
 788: PUSH
 789: LD_EXP 13
 793: DIFF
 794: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 795: LD_VAR 0 10
 799: PUSH
 800: LD_VAR 0 5
 804: PPUSH
 805: LD_INT 25
 807: PUSH
 808: LD_INT 1
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: PPUSH
 815: CALL_OW 72
 819: AND
 820: IFFALSE 929
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 822: LD_ADDR_VAR 0 11
 826: PUSH
 827: LD_VAR 0 5
 831: PPUSH
 832: LD_INT 25
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: EMPTY
 839: LIST
 840: LIST
 841: PPUSH
 842: CALL_OW 72
 846: ST_TO_ADDR
// for i in bun do
 847: LD_ADDR_VAR 0 12
 851: PUSH
 852: LD_VAR 0 10
 856: PUSH
 857: FOR_IN
 858: IFFALSE 927
// begin if not filter then
 860: LD_VAR 0 11
 864: NOT
 865: IFFALSE 869
// break ;
 867: GO 927
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 869: LD_VAR 0 11
 873: PUSH
 874: LD_INT 1
 876: ARRAY
 877: PPUSH
 878: LD_VAR 0 12
 882: PPUSH
 883: CALL_OW 52
// team := team diff filter [ 1 ] ;
 887: LD_ADDR_VAR 0 5
 891: PUSH
 892: LD_VAR 0 5
 896: PUSH
 897: LD_VAR 0 11
 901: PUSH
 902: LD_INT 1
 904: ARRAY
 905: DIFF
 906: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
 907: LD_ADDR_VAR 0 11
 911: PUSH
 912: LD_VAR 0 11
 916: PPUSH
 917: LD_INT 1
 919: PPUSH
 920: CALL_OW 3
 924: ST_TO_ADDR
// end ;
 925: GO 857
 927: POP
 928: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
 929: LD_VAR 0 7
 933: PUSH
 934: LD_VAR 0 5
 938: PPUSH
 939: LD_INT 25
 941: PUSH
 942: LD_INT 1
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: PPUSH
 949: CALL_OW 72
 953: AND
 954: IFFALSE 1076
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 956: LD_ADDR_VAR 0 11
 960: PUSH
 961: LD_VAR 0 5
 965: PPUSH
 966: LD_INT 25
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PPUSH
 976: CALL_OW 72
 980: ST_TO_ADDR
// for i = 1 to filter do
 981: LD_ADDR_VAR 0 12
 985: PUSH
 986: DOUBLE
 987: LD_INT 1
 989: DEC
 990: ST_TO_ADDR
 991: LD_VAR 0 11
 995: PUSH
 996: FOR_TO
 997: IFFALSE 1058
// begin if ( i <= 6 ) then
 999: LD_VAR 0 12
1003: PUSH
1004: LD_INT 6
1006: LESSEQUAL
1007: IFFALSE 1035
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1009: LD_VAR 0 11
1013: PUSH
1014: LD_VAR 0 12
1018: ARRAY
1019: PPUSH
1020: LD_VAR 0 7
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: CALL_OW 52
1033: GO 1056
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1035: LD_VAR 0 11
1039: PUSH
1040: LD_VAR 0 12
1044: ARRAY
1045: PPUSH
1046: LD_INT 1
1048: PPUSH
1049: LD_INT 0
1051: PPUSH
1052: CALL_OW 49
// end ;
1056: GO 996
1058: POP
1059: POP
// team := team diff filter ;
1060: LD_ADDR_VAR 0 5
1064: PUSH
1065: LD_VAR 0 5
1069: PUSH
1070: LD_VAR 0 11
1074: DIFF
1075: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1076: LD_VAR 0 8
1080: PUSH
1081: LD_VAR 0 5
1085: PPUSH
1086: LD_INT 25
1088: PUSH
1089: LD_INT 4
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 72
1100: AND
1101: IFFALSE 1223
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1103: LD_ADDR_VAR 0 11
1107: PUSH
1108: LD_VAR 0 5
1112: PPUSH
1113: LD_INT 25
1115: PUSH
1116: LD_INT 4
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL_OW 72
1127: ST_TO_ADDR
// for i = 1 to filter do
1128: LD_ADDR_VAR 0 12
1132: PUSH
1133: DOUBLE
1134: LD_INT 1
1136: DEC
1137: ST_TO_ADDR
1138: LD_VAR 0 11
1142: PUSH
1143: FOR_TO
1144: IFFALSE 1205
// begin if ( i <= 6 ) then
1146: LD_VAR 0 12
1150: PUSH
1151: LD_INT 6
1153: LESSEQUAL
1154: IFFALSE 1182
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1156: LD_VAR 0 11
1160: PUSH
1161: LD_VAR 0 12
1165: ARRAY
1166: PPUSH
1167: LD_VAR 0 8
1171: PUSH
1172: LD_INT 1
1174: ARRAY
1175: PPUSH
1176: CALL_OW 52
1180: GO 1203
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1182: LD_VAR 0 11
1186: PUSH
1187: LD_VAR 0 12
1191: ARRAY
1192: PPUSH
1193: LD_INT 1
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// end ;
1203: GO 1143
1205: POP
1206: POP
// team := team diff filter ;
1207: LD_ADDR_VAR 0 5
1211: PUSH
1212: LD_VAR 0 5
1216: PUSH
1217: LD_VAR 0 11
1221: DIFF
1222: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1223: LD_VAR 0 9
1227: PUSH
1228: LD_VAR 0 5
1232: PPUSH
1233: LD_INT 25
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: PPUSH
1243: CALL_OW 72
1247: AND
1248: IFFALSE 1370
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1250: LD_ADDR_VAR 0 11
1254: PUSH
1255: LD_VAR 0 5
1259: PPUSH
1260: LD_INT 25
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: PPUSH
1270: CALL_OW 72
1274: ST_TO_ADDR
// for i = 1 to filter do
1275: LD_ADDR_VAR 0 12
1279: PUSH
1280: DOUBLE
1281: LD_INT 1
1283: DEC
1284: ST_TO_ADDR
1285: LD_VAR 0 11
1289: PUSH
1290: FOR_TO
1291: IFFALSE 1352
// begin if ( i <= 6 ) then
1293: LD_VAR 0 12
1297: PUSH
1298: LD_INT 6
1300: LESSEQUAL
1301: IFFALSE 1329
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1303: LD_VAR 0 11
1307: PUSH
1308: LD_VAR 0 12
1312: ARRAY
1313: PPUSH
1314: LD_VAR 0 9
1318: PUSH
1319: LD_INT 1
1321: ARRAY
1322: PPUSH
1323: CALL_OW 52
1327: GO 1350
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1329: LD_VAR 0 11
1333: PUSH
1334: LD_VAR 0 12
1338: ARRAY
1339: PPUSH
1340: LD_INT 1
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 49
// end ;
1350: GO 1290
1352: POP
1353: POP
// team := team diff filter ;
1354: LD_ADDR_VAR 0 5
1358: PUSH
1359: LD_VAR 0 5
1363: PUSH
1364: LD_VAR 0 11
1368: DIFF
1369: ST_TO_ADDR
// end ; if team then
1370: LD_VAR 0 5
1374: IFFALSE 1417
// for i in team do
1376: LD_ADDR_VAR 0 12
1380: PUSH
1381: LD_VAR 0 5
1385: PUSH
1386: FOR_IN
1387: IFFALSE 1415
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1389: LD_VAR 0 12
1393: PPUSH
1394: LD_INT 1
1396: PPUSH
1397: LD_INT 0
1399: PPUSH
1400: CALL_OW 49
// ComHold ( i ) ;
1404: LD_VAR 0 12
1408: PPUSH
1409: CALL_OW 140
// end ;
1413: GO 1386
1415: POP
1416: POP
// if fac then
1417: LD_VAR 0 9
1421: IFFALSE 1457
// if UnitsInside ( fac [ 1 ] ) then
1423: LD_VAR 0 9
1427: PUSH
1428: LD_INT 1
1430: ARRAY
1431: PPUSH
1432: CALL_OW 313
1436: IFFALSE 1457
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1438: LD_VAR 0 9
1442: PUSH
1443: LD_INT 1
1445: ARRAY
1446: PPUSH
1447: LD_INT 10
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 486
// if lab then
1457: LD_VAR 0 8
1461: IFFALSE 1497
// if UnitsInside ( lab [ 1 ] ) then
1463: LD_VAR 0 8
1467: PUSH
1468: LD_INT 1
1470: ARRAY
1471: PPUSH
1472: CALL_OW 313
1476: IFFALSE 1497
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1478: LD_VAR 0 8
1482: PUSH
1483: LD_INT 1
1485: ARRAY
1486: PPUSH
1487: LD_INT 10
1489: PPUSH
1490: LD_INT 0
1492: PPUSH
1493: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_INT 1
1504: PPUSH
1505: LD_INT 1
1507: PPUSH
1508: LD_INT 1
1510: PPUSH
1511: LD_INT 2
1513: PPUSH
1514: LD_INT 1
1516: PPUSH
1517: LD_INT 3
1519: PPUSH
1520: LD_INT 100
1522: PPUSH
1523: CALL 4225 0 7
1527: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1528: LD_VAR 0 4
1532: PPUSH
1533: LD_INT 2
1535: PPUSH
1536: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1540: LD_VAR 0 4
1544: PPUSH
1545: LD_INT 21
1547: PPUSH
1548: LD_INT 8
1550: PPUSH
1551: LD_INT 0
1553: PPUSH
1554: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1558: LD_EXP 7
1562: PPUSH
1563: LD_VAR 0 4
1567: PPUSH
1568: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1572: LD_ADDR_VAR 0 4
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 1
1582: PPUSH
1583: LD_INT 1
1585: PPUSH
1586: LD_INT 2
1588: PPUSH
1589: LD_INT 1
1591: PPUSH
1592: LD_INT 2
1594: PPUSH
1595: LD_INT 100
1597: PPUSH
1598: CALL 4225 0 7
1602: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1603: LD_VAR 0 4
1607: PPUSH
1608: LD_INT 2
1610: PPUSH
1611: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1615: LD_VAR 0 4
1619: PPUSH
1620: LD_INT 16
1622: PPUSH
1623: LD_INT 3
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1633: LD_EXP 8
1637: PPUSH
1638: LD_VAR 0 4
1642: PPUSH
1643: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1647: LD_ADDR_VAR 0 4
1651: PUSH
1652: LD_INT 1
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 2
1660: PPUSH
1661: LD_INT 2
1663: PPUSH
1664: LD_INT 1
1666: PPUSH
1667: LD_INT 12
1669: PPUSH
1670: LD_INT 100
1672: PPUSH
1673: CALL 4225 0 7
1677: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1678: LD_VAR 0 4
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: LD_INT 5
1688: PPUSH
1689: CALL_OW 12
1693: PPUSH
1694: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1698: LD_VAR 0 4
1702: PPUSH
1703: LD_INT 1
1705: PPUSH
1706: LD_INT 0
1708: PPUSH
1709: CALL_OW 49
// end ;
1713: LD_VAR 0 1
1717: RET
// function PrepareBase ; var blist , i , b ; begin
1718: LD_INT 0
1720: PPUSH
1721: PPUSH
1722: PPUSH
1723: PPUSH
// blist := LoadVariable ( GammaBase , [ ] ) ;
1724: LD_ADDR_VAR 0 2
1728: PUSH
1729: LD_STRING GammaBase
1731: PPUSH
1732: EMPTY
1733: PPUSH
1734: CALL_OW 30
1738: ST_TO_ADDR
// if not blist and debug then
1739: LD_VAR 0 2
1743: NOT
1744: PUSH
1745: LD_EXP 1
1749: AND
1750: IFFALSE 1790
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1752: LD_ADDR_VAR 0 2
1756: PUSH
1757: LD_INT 0
1759: PUSH
1760: LD_INT 51
1762: PUSH
1763: LD_INT 10
1765: PUSH
1766: LD_INT 3
1768: PUSH
1769: LD_INT 3
1771: PUSH
1772: LD_INT 0
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: EMPTY
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: PUSH
1787: EMPTY
1788: LIST
1789: ST_TO_ADDR
// if not blist then
1790: LD_VAR 0 2
1794: NOT
1795: IFFALSE 1799
// exit ;
1797: GO 1979
// uc_side := 1 ;
1799: LD_ADDR_OWVAR 20
1803: PUSH
1804: LD_INT 1
1806: ST_TO_ADDR
// uc_nation := 1 ;
1807: LD_ADDR_OWVAR 21
1811: PUSH
1812: LD_INT 1
1814: ST_TO_ADDR
// for i in blist do
1815: LD_ADDR_VAR 0 3
1819: PUSH
1820: LD_VAR 0 2
1824: PUSH
1825: FOR_IN
1826: IFFALSE 1977
// begin bc_type := i [ 1 ] ;
1828: LD_ADDR_OWVAR 42
1832: PUSH
1833: LD_VAR 0 3
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1842: LD_ADDR_OWVAR 43
1846: PUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_INT 5
1854: ARRAY
1855: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1856: LD_VAR 0 3
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: PUSH
1865: LD_INT 7
1867: PUSH
1868: LD_INT 8
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: IN
1875: IFFALSE 1905
// begin bc_kind1 := i [ 7 ] ;
1877: LD_ADDR_OWVAR 44
1881: PUSH
1882: LD_VAR 0 3
1886: PUSH
1887: LD_INT 7
1889: ARRAY
1890: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1891: LD_ADDR_OWVAR 45
1895: PUSH
1896: LD_VAR 0 3
1900: PUSH
1901: LD_INT 8
1903: ARRAY
1904: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1905: LD_ADDR_VAR 0 4
1909: PUSH
1910: LD_VAR 0 3
1914: PUSH
1915: LD_INT 2
1917: ARRAY
1918: PPUSH
1919: LD_VAR 0 3
1923: PUSH
1924: LD_INT 3
1926: ARRAY
1927: PPUSH
1928: LD_VAR 0 3
1932: PUSH
1933: LD_INT 4
1935: ARRAY
1936: PPUSH
1937: CALL_OW 47
1941: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
1942: LD_VAR 0 4
1946: PPUSH
1947: CALL_OW 266
1951: PUSH
1952: LD_INT 32
1954: EQUAL
1955: IFFALSE 1975
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
1957: LD_VAR 0 4
1961: PPUSH
1962: LD_VAR 0 3
1966: PUSH
1967: LD_INT 7
1969: ARRAY
1970: PPUSH
1971: CALL_OW 431
// end ; end ;
1975: GO 1825
1977: POP
1978: POP
// end ; end_of_file
1979: LD_VAR 0 1
1983: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
1984: LD_INT 0
1986: PPUSH
1987: PPUSH
1988: PPUSH
1989: PPUSH
1990: PPUSH
1991: PPUSH
1992: PPUSH
1993: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
1994: LD_INT 0
1996: PPUSH
1997: LD_INT 0
1999: PPUSH
2000: LD_INT 1
2002: PPUSH
2003: LD_INT 32976
2005: NEG
2006: PPUSH
2007: CALL_OW 330
// SetResourceVisibility ( 71 , 5 , 1 ) ;
2011: LD_INT 71
2013: PPUSH
2014: LD_INT 5
2016: PPUSH
2017: LD_INT 1
2019: PPUSH
2020: CALL_OW 441
// InGameOn ;
2024: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2028: LD_INT 33
2030: PPUSH
2031: LD_INT 11
2033: PPUSH
2034: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2038: LD_ADDR_VAR 0 2
2042: PUSH
2043: LD_INT 29
2045: PUSH
2046: LD_INT 21
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: PUSH
2053: LD_INT 41
2055: PUSH
2056: LD_INT 28
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: PUSH
2063: LD_INT 52
2065: PUSH
2066: LD_INT 26
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PUSH
2073: LD_INT 49
2075: PUSH
2076: LD_INT 16
2078: PUSH
2079: EMPTY
2080: LIST
2081: LIST
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: LIST
2087: LIST
2088: ST_TO_ADDR
// for i in points do
2089: LD_ADDR_VAR 0 3
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: FOR_IN
2100: IFFALSE 2140
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2102: LD_EXP 7
2106: PUSH
2107: LD_EXP 8
2111: PUSH
2112: EMPTY
2113: LIST
2114: LIST
2115: PPUSH
2116: LD_VAR 0 3
2120: PUSH
2121: LD_INT 1
2123: ARRAY
2124: PPUSH
2125: LD_VAR 0 3
2129: PUSH
2130: LD_INT 2
2132: ARRAY
2133: PPUSH
2134: CALL_OW 171
2138: GO 2099
2140: POP
2141: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2142: LD_EXP 7
2146: PUSH
2147: LD_EXP 8
2151: PUSH
2152: EMPTY
2153: LIST
2154: LIST
2155: PPUSH
2156: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2160: LD_INT 35
2162: PPUSH
2163: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2167: LD_EXP 7
2171: PPUSH
2172: CALL_OW 310
2176: NOT
2177: PUSH
2178: LD_EXP 8
2182: PPUSH
2183: CALL_OW 310
2187: NOT
2188: AND
2189: IFFALSE 2160
// ComTurnUnit ( JMM , Gladstone ) ;
2191: LD_EXP 7
2195: PPUSH
2196: LD_EXP 8
2200: PPUSH
2201: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2205: LD_EXP 8
2209: PPUSH
2210: LD_EXP 7
2214: PPUSH
2215: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2219: LD_ADDR_VAR 0 4
2223: PUSH
2224: LD_INT 26
2226: PUSH
2227: LD_INT 1
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PPUSH
2234: CALL_OW 69
2238: PUSH
2239: LD_EXP 7
2243: PUSH
2244: LD_EXP 8
2248: PUSH
2249: LD_EXP 12
2253: PUSH
2254: LD_EXP 11
2258: PUSH
2259: LD_EXP 9
2263: PUSH
2264: LD_EXP 14
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: LIST
2273: LIST
2274: LIST
2275: LIST
2276: DIFF
2277: ST_TO_ADDR
// if sol then
2278: LD_VAR 0 4
2282: IFFALSE 2298
// sol := sol [ 1 ] ;
2284: LD_ADDR_VAR 0 4
2288: PUSH
2289: LD_VAR 0 4
2293: PUSH
2294: LD_INT 1
2296: ARRAY
2297: ST_TO_ADDR
// team := [ ] ;
2298: LD_ADDR_VAR 0 5
2302: PUSH
2303: EMPTY
2304: ST_TO_ADDR
// if sol then
2305: LD_VAR 0 4
2309: IFFALSE 2327
// team := team ^ sol ;
2311: LD_ADDR_VAR 0 5
2315: PUSH
2316: LD_VAR 0 5
2320: PUSH
2321: LD_VAR 0 4
2325: ADD
2326: ST_TO_ADDR
// if Lisa then
2327: LD_EXP 10
2331: IFFALSE 2349
// team := team ^ Lisa ;
2333: LD_ADDR_VAR 0 5
2337: PUSH
2338: LD_VAR 0 5
2342: PUSH
2343: LD_EXP 10
2347: ADD
2348: ST_TO_ADDR
// if Donaldson then
2349: LD_EXP 13
2353: IFFALSE 2371
// team := team ^ Donaldson ;
2355: LD_ADDR_VAR 0 5
2359: PUSH
2360: LD_VAR 0 5
2364: PUSH
2365: LD_EXP 13
2369: ADD
2370: ST_TO_ADDR
// if Brown then
2371: LD_EXP 14
2375: IFFALSE 2393
// team := team ^ Brown ;
2377: LD_ADDR_VAR 0 5
2381: PUSH
2382: LD_VAR 0 5
2386: PUSH
2387: LD_EXP 14
2391: ADD
2392: ST_TO_ADDR
// if Bobby then
2393: LD_EXP 12
2397: IFFALSE 2415
// team := team ^ Bobby ;
2399: LD_ADDR_VAR 0 5
2403: PUSH
2404: LD_VAR 0 5
2408: PUSH
2409: LD_EXP 12
2413: ADD
2414: ST_TO_ADDR
// if Cyrus then
2415: LD_EXP 11
2419: IFFALSE 2437
// team := team ^ Cyrus ;
2421: LD_ADDR_VAR 0 5
2425: PUSH
2426: LD_VAR 0 5
2430: PUSH
2431: LD_EXP 11
2435: ADD
2436: ST_TO_ADDR
// if Frank then
2437: LD_EXP 9
2441: IFFALSE 2459
// team := team ^ Frank ;
2443: LD_ADDR_VAR 0 5
2447: PUSH
2448: LD_VAR 0 5
2452: PUSH
2453: LD_EXP 9
2457: ADD
2458: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2459: LD_ADDR_VAR 0 3
2463: PUSH
2464: LD_INT 1
2466: PPUSH
2467: LD_INT 3
2469: PUSH
2470: LD_INT 54
2472: PUSH
2473: EMPTY
2474: LIST
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 1
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: PPUSH
2494: CALL_OW 70
2498: PUSH
2499: LD_EXP 7
2503: PUSH
2504: LD_EXP 8
2508: PUSH
2509: EMPTY
2510: LIST
2511: LIST
2512: DIFF
2513: PUSH
2514: EMPTY
2515: LIST
2516: PUSH
2517: FOR_IN
2518: IFFALSE 2538
// team := team ^ i ;
2520: LD_ADDR_VAR 0 5
2524: PUSH
2525: LD_VAR 0 5
2529: PUSH
2530: LD_VAR 0 3
2534: ADD
2535: ST_TO_ADDR
2536: GO 2517
2538: POP
2539: POP
// if team then
2540: LD_VAR 0 5
2544: IFFALSE 2620
// begin ComExitBuilding ( team ) ;
2546: LD_VAR 0 5
2550: PPUSH
2551: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2555: LD_VAR 0 5
2559: PPUSH
2560: LD_EXP 7
2564: PPUSH
2565: CALL_OW 172
// repeat wait ( 1 ) ;
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2576: LD_EXP 7
2580: PPUSH
2581: LD_VAR 0 5
2585: PPUSH
2586: LD_EXP 7
2590: PPUSH
2591: CALL_OW 74
2595: PPUSH
2596: CALL_OW 296
2600: PUSH
2601: LD_INT 6
2603: LESS
2604: IFFALSE 2569
// ComTurnUnit ( team , JMM ) ;
2606: LD_VAR 0 5
2610: PPUSH
2611: LD_EXP 7
2615: PPUSH
2616: CALL_OW 119
// end ; if Lisa then
2620: LD_EXP 10
2624: IFFALSE 2652
// begin ComTurnUnit ( JMM , Lisa ) ;
2626: LD_EXP 7
2630: PPUSH
2631: LD_EXP 10
2635: PPUSH
2636: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2640: LD_EXP 10
2644: PPUSH
2645: LD_STRING D1-Lisa-1
2647: PPUSH
2648: CALL_OW 88
// end ; if sol then
2652: LD_VAR 0 4
2656: IFFALSE 2684
// begin ComTurnUnit ( JMM , sol ) ;
2658: LD_EXP 7
2662: PPUSH
2663: LD_VAR 0 4
2667: PPUSH
2668: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2672: LD_VAR 0 4
2676: PPUSH
2677: LD_STRING D1-Sol1-1
2679: PPUSH
2680: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2684: LD_EXP 7
2688: PPUSH
2689: LD_STRING D1-JMM-1
2691: PPUSH
2692: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2696: LD_EXP 7
2700: PPUSH
2701: LD_STRING D1-JMM-1a
2703: PPUSH
2704: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2708: LD_EXP 7
2712: PPUSH
2713: LD_EXP 8
2717: PPUSH
2718: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2722: LD_VAR 0 5
2726: PPUSH
2727: LD_EXP 8
2731: PPUSH
2732: CALL_OW 119
// if Frank then
2736: LD_EXP 9
2740: IFFALSE 2768
// begin Say ( Frank , D1-Frank-1 ) ;
2742: LD_EXP 9
2746: PPUSH
2747: LD_STRING D1-Frank-1
2749: PPUSH
2750: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2754: LD_EXP 7
2758: PPUSH
2759: LD_EXP 9
2763: PPUSH
2764: CALL_OW 119
// end ; if Lisa then
2768: LD_EXP 10
2772: IFFALSE 2800
// begin ComTurnUnit ( JMM , Lisa ) ;
2774: LD_EXP 7
2778: PPUSH
2779: LD_EXP 10
2783: PPUSH
2784: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2788: LD_EXP 10
2792: PPUSH
2793: LD_STRING D1-Lisa-2
2795: PPUSH
2796: CALL_OW 88
// end ; if sol then
2800: LD_VAR 0 4
2804: IFFALSE 2832
// begin ComTurnUnit ( JMM , sol ) ;
2806: LD_EXP 7
2810: PPUSH
2811: LD_VAR 0 4
2815: PPUSH
2816: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2820: LD_VAR 0 4
2824: PPUSH
2825: LD_STRING D1-Sol1-2
2827: PPUSH
2828: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2832: LD_EXP 8
2836: PPUSH
2837: LD_STRING D1-Glad-2
2839: PPUSH
2840: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2844: LD_VAR 0 5
2848: PPUSH
2849: LD_EXP 7
2853: PPUSH
2854: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2858: LD_EXP 7
2862: PPUSH
2863: LD_STRING D1-JMM-2
2865: PPUSH
2866: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2870: LD_EXP 7
2874: PPUSH
2875: LD_EXP 8
2879: PPUSH
2880: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2884: LD_EXP 8
2888: PPUSH
2889: LD_STRING D1-Glad-3
2891: PPUSH
2892: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2896: LD_EXP 7
2900: PPUSH
2901: LD_STRING D1-JMM-3
2903: PPUSH
2904: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2908: LD_EXP 8
2912: PPUSH
2913: LD_STRING D1-Glad-4
2915: PPUSH
2916: CALL_OW 88
// if Frank then
2920: LD_EXP 9
2924: IFFALSE 2952
// begin ComTurnUnit ( JMM , Frank ) ;
2926: LD_EXP 7
2930: PPUSH
2931: LD_EXP 9
2935: PPUSH
2936: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2940: LD_EXP 9
2944: PPUSH
2945: LD_STRING D1-Frank-4
2947: PPUSH
2948: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
2952: LD_EXP 7
2956: PPUSH
2957: LD_EXP 8
2961: PPUSH
2962: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
2966: LD_EXP 7
2970: PPUSH
2971: LD_STRING D1-JMM-4
2973: PPUSH
2974: CALL_OW 88
// if Lisa then
2978: LD_EXP 10
2982: IFFALSE 3049
// begin Say ( Lisa , D1-Lisa-4 ) ;
2984: LD_EXP 10
2988: PPUSH
2989: LD_STRING D1-Lisa-4
2991: PPUSH
2992: CALL_OW 88
// if Frank then
2996: LD_EXP 9
3000: IFFALSE 3049
// begin ComTurnUnit ( Frank , Lisa ) ;
3002: LD_EXP 9
3006: PPUSH
3007: LD_EXP 10
3011: PPUSH
3012: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3016: LD_EXP 9
3020: PPUSH
3021: LD_STRING D1-Frank-5
3023: PPUSH
3024: CALL_OW 88
// Wait ( 3 ) ;
3028: LD_INT 3
3030: PPUSH
3031: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3035: LD_EXP 9
3039: PPUSH
3040: LD_EXP 7
3044: PPUSH
3045: CALL_OW 179
// end ; end ; if sol then
3049: LD_VAR 0 4
3053: IFFALSE 3067
// Say ( sol , D1-Sol1-5 ) ;
3055: LD_VAR 0 4
3059: PPUSH
3060: LD_STRING D1-Sol1-5
3062: PPUSH
3063: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3067: LD_EXP 7
3071: PPUSH
3072: LD_STRING D1-JMM-5
3074: PPUSH
3075: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3079: LD_EXP 8
3083: PPUSH
3084: LD_STRING D1-Glad-5
3086: PPUSH
3087: CALL_OW 88
// if Frank then
3091: LD_EXP 9
3095: IFFALSE 3109
// Say ( Frank , D1-Frank-6 ) ;
3097: LD_EXP 9
3101: PPUSH
3102: LD_STRING D1-Frank-6
3104: PPUSH
3105: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3109: LD_EXP 7
3113: PPUSH
3114: LD_STRING D1-JMM-6
3116: PPUSH
3117: CALL_OW 88
// if Brown and Donaldson then
3121: LD_EXP 14
3125: PUSH
3126: LD_EXP 13
3130: AND
3131: IFFALSE 3180
// case Query ( QCommander ) of 1 :
3133: LD_STRING QCommander
3135: PPUSH
3136: CALL_OW 97
3140: PUSH
3141: LD_INT 1
3143: DOUBLE
3144: EQUAL
3145: IFTRUE 3149
3147: GO 3160
3149: POP
// donaldson_commander := true ; 2 :
3150: LD_ADDR_EXP 4
3154: PUSH
3155: LD_INT 1
3157: ST_TO_ADDR
3158: GO 3180
3160: LD_INT 2
3162: DOUBLE
3163: EQUAL
3164: IFTRUE 3168
3166: GO 3179
3168: POP
// brown_commander := true ; end ;
3169: LD_ADDR_EXP 5
3173: PUSH
3174: LD_INT 1
3176: ST_TO_ADDR
3177: GO 3180
3179: POP
// if not Brown and Donaldson then
3180: LD_EXP 14
3184: NOT
3185: PUSH
3186: LD_EXP 13
3190: AND
3191: IFFALSE 3201
// donaldson_commander := true ;
3193: LD_ADDR_EXP 4
3197: PUSH
3198: LD_INT 1
3200: ST_TO_ADDR
// if Brown and not Donaldson then
3201: LD_EXP 14
3205: PUSH
3206: LD_EXP 13
3210: NOT
3211: AND
3212: IFFALSE 3222
// brown_commander := true ;
3214: LD_ADDR_EXP 5
3218: PUSH
3219: LD_INT 1
3221: ST_TO_ADDR
// if donaldson_commander then
3222: LD_EXP 4
3226: IFFALSE 3373
// begin ComTurnUnit ( JMM , Donaldson ) ;
3228: LD_EXP 7
3232: PPUSH
3233: LD_EXP 13
3237: PPUSH
3238: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3242: LD_EXP 7
3246: PPUSH
3247: LD_STRING D1a-JMM-1
3249: PPUSH
3250: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3254: LD_EXP 13
3258: PPUSH
3259: LD_EXP 7
3263: PPUSH
3264: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3268: LD_EXP 13
3272: PPUSH
3273: LD_EXP 7
3277: PPUSH
3278: CALL_OW 179
// Wait ( 3 ) ;
3282: LD_INT 3
3284: PPUSH
3285: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3289: LD_EXP 13
3293: PPUSH
3294: LD_STRING D1a-Don-1
3296: PPUSH
3297: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3301: LD_EXP 7
3305: PPUSH
3306: LD_STRING D1b-JMM-2
3308: PPUSH
3309: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3313: LD_EXP 13
3317: PPUSH
3318: LD_STRING D1a-Don-2
3320: PPUSH
3321: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3325: LD_EXP 13
3329: PPUSH
3330: LD_INT 30
3332: PUSH
3333: LD_INT 0
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PPUSH
3340: CALL_OW 69
3344: PUSH
3345: LD_INT 1
3347: ARRAY
3348: PPUSH
3349: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3353: LD_INT 1
3355: PPUSH
3356: LD_STRING GammaCommander
3358: PPUSH
3359: CALL_OW 39
// commander := Donaldson ;
3363: LD_ADDR_VAR 0 7
3367: PUSH
3368: LD_EXP 13
3372: ST_TO_ADDR
// end ; if brown_commander then
3373: LD_EXP 5
3377: IFFALSE 3524
// begin ComTurnUnit ( JMM , Brown ) ;
3379: LD_EXP 7
3383: PPUSH
3384: LD_EXP 14
3388: PPUSH
3389: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3393: LD_EXP 7
3397: PPUSH
3398: LD_STRING D1b-JMM-1
3400: PPUSH
3401: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3405: LD_EXP 14
3409: PPUSH
3410: LD_EXP 7
3414: PPUSH
3415: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3419: LD_EXP 14
3423: PPUSH
3424: LD_EXP 7
3428: PPUSH
3429: CALL_OW 179
// Wait ( 3 ) ;
3433: LD_INT 3
3435: PPUSH
3436: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3440: LD_EXP 14
3444: PPUSH
3445: LD_STRING D1b-Brown-1
3447: PPUSH
3448: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3452: LD_EXP 7
3456: PPUSH
3457: LD_STRING D1a-JMM-2
3459: PPUSH
3460: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3464: LD_EXP 14
3468: PPUSH
3469: LD_STRING D1b-Brown-2
3471: PPUSH
3472: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3476: LD_EXP 14
3480: PPUSH
3481: LD_INT 30
3483: PUSH
3484: LD_INT 0
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PPUSH
3491: CALL_OW 69
3495: PUSH
3496: LD_INT 1
3498: ARRAY
3499: PPUSH
3500: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3504: LD_INT 2
3506: PPUSH
3507: LD_STRING GammaCommander
3509: PPUSH
3510: CALL_OW 39
// commander := Brown ;
3514: LD_ADDR_VAR 0 7
3518: PUSH
3519: LD_EXP 14
3523: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3524: LD_EXP 7
3528: PPUSH
3529: LD_EXP 8
3533: PPUSH
3534: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3538: LD_EXP 4
3542: NOT
3543: PUSH
3544: LD_EXP 5
3548: NOT
3549: AND
3550: IFFALSE 3574
// begin Say ( JMM , D1c-JMM-1 ) ;
3552: LD_EXP 7
3556: PPUSH
3557: LD_STRING D1c-JMM-1
3559: PPUSH
3560: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3564: LD_INT 3
3566: PPUSH
3567: LD_STRING GammaCommander
3569: PPUSH
3570: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3574: LD_EXP 7
3578: PPUSH
3579: LD_STRING D1d-JMM-1
3581: PPUSH
3582: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3586: LD_ADDR_VAR 0 6
3590: PUSH
3591: LD_INT 21
3593: PUSH
3594: LD_INT 1
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: PPUSH
3601: CALL_OW 69
3605: PUSH
3606: LD_EXP 7
3610: PUSH
3611: LD_EXP 8
3615: PUSH
3616: LD_VAR 0 7
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: LIST
3625: DIFF
3626: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3627: LD_ADDR_EXP 6
3631: PUSH
3632: LD_STRING 1
3634: PPUSH
3635: LD_INT 5
3637: PPUSH
3638: LD_INT 5
3640: PPUSH
3641: LD_INT -5
3643: PUSH
3644: LD_EXP 7
3648: PUSH
3649: LD_INT -6
3651: PUSH
3652: LD_EXP 8
3656: PUSH
3657: LD_INT -2
3659: PUSH
3660: LD_INT -3
3662: PUSH
3663: LD_INT -5
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: LIST
3670: LIST
3671: LIST
3672: LIST
3673: LIST
3674: PUSH
3675: LD_VAR 0 6
3679: ADD
3680: PUSH
3681: LD_INT -6
3683: PUSH
3684: LD_INT -4
3686: PUSH
3687: LD_VAR 0 7
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: LIST
3696: ADD
3697: PPUSH
3698: LD_INT 1
3700: PUSH
3701: LD_INT 3
3703: PUSH
3704: LD_INT 2
3706: PUSH
3707: LD_INT 1
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 4
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: LIST
3721: LIST
3722: PPUSH
3723: CALL_OW 42
3727: ST_TO_ADDR
// SaveCharacters ( all diff [ save_group , JMM , Gladstone ] , othersGamma ) ;
3728: LD_VAR 0 6
3732: PUSH
3733: LD_EXP 6
3737: PUSH
3738: LD_EXP 7
3742: PUSH
3743: LD_EXP 8
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: LIST
3752: DIFF
3753: PPUSH
3754: LD_STRING othersGamma
3756: PPUSH
3757: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
3761: LD_EXP 6
3765: PUSH
3766: LD_EXP 7
3770: PUSH
3771: LD_EXP 8
3775: PUSH
3776: LD_EXP 10
3780: PUSH
3781: LD_EXP 11
3785: PUSH
3786: LD_EXP 12
3790: PUSH
3791: LD_EXP 9
3795: PUSH
3796: LD_EXP 13
3800: PUSH
3801: LD_EXP 14
3805: PUSH
3806: LD_INT 0
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: DIFF
3820: PPUSH
3821: LD_STRING othersDelta
3823: PPUSH
3824: CALL_OW 38
// if Lisa in save_group then
3828: LD_EXP 10
3832: PUSH
3833: LD_EXP 6
3837: IN
3838: IFFALSE 3850
// begin SaveVariable ( true , LisaInDelta ) ;
3840: LD_INT 1
3842: PPUSH
3843: LD_STRING LisaInDelta
3845: PPUSH
3846: CALL_OW 39
// end ; if Bobby in save_group then
3850: LD_EXP 12
3854: PUSH
3855: LD_EXP 6
3859: IN
3860: IFFALSE 3872
// begin SaveVariable ( true , BobbyInDelta ) ;
3862: LD_INT 1
3864: PPUSH
3865: LD_STRING BobbyInDelta
3867: PPUSH
3868: CALL_OW 39
// end ; if Cyrus in save_group then
3872: LD_EXP 11
3876: PUSH
3877: LD_EXP 6
3881: IN
3882: IFFALSE 3894
// begin SaveVariable ( true , CyrusInDelta ) ;
3884: LD_INT 1
3886: PPUSH
3887: LD_STRING CyrusInDelta
3889: PPUSH
3890: CALL_OW 39
// end ; if Frank in save_group then
3894: LD_EXP 9
3898: PUSH
3899: LD_EXP 6
3903: IN
3904: IFFALSE 3916
// begin SaveVariable ( true , FrankInDelta ) ;
3906: LD_INT 1
3908: PPUSH
3909: LD_STRING FrankInDelta
3911: PPUSH
3912: CALL_OW 39
// end ; if Brown in save_group then
3916: LD_EXP 14
3920: PUSH
3921: LD_EXP 6
3925: IN
3926: IFFALSE 3938
// begin SaveVariable ( true , BrownInDelta ) ;
3928: LD_INT 1
3930: PPUSH
3931: LD_STRING BrownInDelta
3933: PPUSH
3934: CALL_OW 39
// end ; if Donaldson in save_group then
3938: LD_EXP 13
3942: PUSH
3943: LD_EXP 6
3947: IN
3948: IFFALSE 3960
// begin SaveVariable ( true , DonaldsonInDelta ) ;
3950: LD_INT 1
3952: PPUSH
3953: LD_STRING DonaldsonInDelta
3955: PPUSH
3956: CALL_OW 39
// end ; Wait ( 3 ) ;
3960: LD_INT 3
3962: PPUSH
3963: CALL_OW 67
// for i in save_group do
3967: LD_ADDR_VAR 0 3
3971: PUSH
3972: LD_EXP 6
3976: PUSH
3977: FOR_IN
3978: IFFALSE 4009
// begin if IsInUnit ( i ) then
3980: LD_VAR 0 3
3984: PPUSH
3985: CALL_OW 310
3989: IFFALSE 4000
// ComExitBuilding ( i ) ;
3991: LD_VAR 0 3
3995: PPUSH
3996: CALL_OW 122
// Wait ( 3 ) ;
4000: LD_INT 3
4002: PPUSH
4003: CALL_OW 67
// end ;
4007: GO 3977
4009: POP
4010: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4011: LD_ADDR_EXP 6
4015: PUSH
4016: LD_EXP 6
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_EXP 7
4028: PPUSH
4029: CALL_OW 2
4033: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4034: LD_ADDR_EXP 6
4038: PUSH
4039: LD_EXP 6
4043: PPUSH
4044: LD_INT 2
4046: PPUSH
4047: LD_EXP 8
4051: PPUSH
4052: CALL_OW 2
4056: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4057: LD_ADDR_VAR 0 8
4061: PUSH
4062: LD_INT 21
4064: PUSH
4065: LD_INT 2
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// for i = 1 to filter do
4077: LD_ADDR_VAR 0 3
4081: PUSH
4082: DOUBLE
4083: LD_INT 1
4085: DEC
4086: ST_TO_ADDR
4087: LD_VAR 0 8
4091: PUSH
4092: FOR_TO
4093: IFFALSE 4123
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4095: LD_EXP 6
4099: PUSH
4100: LD_VAR 0 3
4104: ARRAY
4105: PPUSH
4106: LD_VAR 0 8
4110: PUSH
4111: LD_VAR 0 3
4115: ARRAY
4116: PPUSH
4117: CALL_OW 120
4121: GO 4092
4123: POP
4124: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4125: LD_EXP 6
4129: PPUSH
4130: LD_INT 87
4132: PPUSH
4133: LD_INT 27
4135: PPUSH
4136: CALL_OW 171
// Wait ( 0 0$05 ) ;
4140: LD_INT 175
4142: PPUSH
4143: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4147: LD_INT 1
4149: PPUSH
4150: LD_STRING %_cont
4152: PPUSH
4153: CALL_OW 340
// end ; end_of_file
4157: LD_VAR 0 1
4161: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4162: LD_INT 0
4164: PPUSH
4165: PPUSH
// if exist_mode then
4166: LD_VAR 0 2
4170: IFFALSE 4195
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4172: LD_ADDR_VAR 0 4
4176: PUSH
4177: LD_EXP 3
4181: PUSH
4182: LD_VAR 0 1
4186: STR
4187: PPUSH
4188: CALL_OW 34
4192: ST_TO_ADDR
4193: GO 4210
// unit := NewCharacter ( ident ) ;
4195: LD_ADDR_VAR 0 4
4199: PUSH
4200: LD_VAR 0 1
4204: PPUSH
4205: CALL_OW 25
4209: ST_TO_ADDR
// result := unit ;
4210: LD_ADDR_VAR 0 3
4214: PUSH
4215: LD_VAR 0 4
4219: ST_TO_ADDR
// end ;
4220: LD_VAR 0 3
4224: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4225: LD_INT 0
4227: PPUSH
// uc_side := side ;
4228: LD_ADDR_OWVAR 20
4232: PUSH
4233: LD_VAR 0 1
4237: ST_TO_ADDR
// uc_nation := nation ;
4238: LD_ADDR_OWVAR 21
4242: PUSH
4243: LD_VAR 0 2
4247: ST_TO_ADDR
// vc_chassis := chassis ;
4248: LD_ADDR_OWVAR 37
4252: PUSH
4253: LD_VAR 0 3
4257: ST_TO_ADDR
// vc_engine := engine ;
4258: LD_ADDR_OWVAR 39
4262: PUSH
4263: LD_VAR 0 4
4267: ST_TO_ADDR
// vc_control := control ;
4268: LD_ADDR_OWVAR 38
4272: PUSH
4273: LD_VAR 0 5
4277: ST_TO_ADDR
// vc_weapon := weapon ;
4278: LD_ADDR_OWVAR 40
4282: PUSH
4283: LD_VAR 0 6
4287: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4288: LD_ADDR_OWVAR 41
4292: PUSH
4293: LD_VAR 0 7
4297: ST_TO_ADDR
// result := CreateVehicle ;
4298: LD_ADDR_VAR 0 8
4302: PUSH
4303: CALL_OW 45
4307: ST_TO_ADDR
// end ;
4308: LD_VAR 0 8
4312: RET
// export function SayX ( units , ident ) ; var i ; begin
4313: LD_INT 0
4315: PPUSH
4316: PPUSH
// result := false ;
4317: LD_ADDR_VAR 0 3
4321: PUSH
4322: LD_INT 0
4324: ST_TO_ADDR
// if not units then
4325: LD_VAR 0 1
4329: NOT
4330: IFFALSE 4334
// exit ;
4332: GO 4388
// for i in units do
4334: LD_ADDR_VAR 0 4
4338: PUSH
4339: LD_VAR 0 1
4343: PUSH
4344: FOR_IN
4345: IFFALSE 4386
// if IsOk ( i ) then
4347: LD_VAR 0 4
4351: PPUSH
4352: CALL_OW 302
4356: IFFALSE 4384
// begin Say ( i , ident ) ;
4358: LD_VAR 0 4
4362: PPUSH
4363: LD_VAR 0 2
4367: PPUSH
4368: CALL_OW 88
// result := i ;
4372: LD_ADDR_VAR 0 3
4376: PUSH
4377: LD_VAR 0 4
4381: ST_TO_ADDR
// break ;
4382: GO 4386
// end ;
4384: GO 4344
4386: POP
4387: POP
// end ;
4388: LD_VAR 0 3
4392: RET
