// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 1984 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
// PrepareBase ;
 118: CALL 1718 0 0
// uc_side := 1 ;
 122: LD_ADDR_OWVAR 20
 126: PUSH
 127: LD_INT 1
 129: ST_TO_ADDR
// uc_nation := 1 ;
 130: LD_ADDR_OWVAR 21
 134: PUSH
 135: LD_INT 1
 137: ST_TO_ADDR
// team := [ ] ;
 138: LD_ADDR_VAR 0 5
 142: PUSH
 143: EMPTY
 144: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 145: LD_ADDR_EXP 7
 149: PUSH
 150: LD_STRING JMM
 152: PPUSH
 153: LD_EXP 1
 157: NOT
 158: PPUSH
 159: CALL 4149 0 2
 163: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 164: LD_ADDR_EXP 8
 168: PUSH
 169: LD_STRING Gladstone
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: CALL 4149 0 2
 179: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 180: LD_ADDR_EXP 9
 184: PUSH
 185: LD_STRING Frank
 187: PPUSH
 188: LD_EXP 1
 192: NOT
 193: PPUSH
 194: CALL 4149 0 2
 198: ST_TO_ADDR
// if Frank then
 199: LD_EXP 9
 203: IFFALSE 221
// team := team ^ Frank ;
 205: LD_ADDR_VAR 0 5
 209: PUSH
 210: LD_VAR 0 5
 214: PUSH
 215: LD_EXP 9
 219: ADD
 220: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 221: LD_ADDR_EXP 10
 225: PUSH
 226: LD_STRING Lisa
 228: PPUSH
 229: LD_EXP 1
 233: NOT
 234: PPUSH
 235: CALL 4149 0 2
 239: ST_TO_ADDR
// if Lisa then
 240: LD_EXP 10
 244: IFFALSE 262
// team := team ^ Lisa ;
 246: LD_ADDR_VAR 0 5
 250: PUSH
 251: LD_VAR 0 5
 255: PUSH
 256: LD_EXP 10
 260: ADD
 261: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 262: LD_ADDR_EXP 13
 266: PUSH
 267: LD_STRING Donaldson
 269: PPUSH
 270: LD_EXP 1
 274: NOT
 275: PPUSH
 276: CALL 4149 0 2
 280: ST_TO_ADDR
// if Donaldson then
 281: LD_EXP 13
 285: IFFALSE 303
// team := team ^ Donaldson ;
 287: LD_ADDR_VAR 0 5
 291: PUSH
 292: LD_VAR 0 5
 296: PUSH
 297: LD_EXP 13
 301: ADD
 302: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 303: LD_ADDR_EXP 14
 307: PUSH
 308: LD_STRING Brown
 310: PPUSH
 311: LD_EXP 1
 315: NOT
 316: PPUSH
 317: CALL 4149 0 2
 321: ST_TO_ADDR
// if Brown then
 322: LD_EXP 14
 326: IFFALSE 344
// team := team ^ Brown ;
 328: LD_ADDR_VAR 0 5
 332: PUSH
 333: LD_VAR 0 5
 337: PUSH
 338: LD_EXP 14
 342: ADD
 343: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_STRING 04_other_survivors
 351: PPUSH
 352: CALL_OW 31
 356: ST_TO_ADDR
// if not Lisa then
 357: LD_EXP 10
 361: NOT
 362: IFFALSE 473
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 364: LD_ADDR_EXP 11
 368: PUSH
 369: LD_STRING Cyrus
 371: PPUSH
 372: LD_EXP 1
 376: NOT
 377: PPUSH
 378: CALL 4149 0 2
 382: ST_TO_ADDR
// if Cyrus then
 383: LD_EXP 11
 387: IFFALSE 405
// team := team ^ Cyrus ;
 389: LD_ADDR_VAR 0 5
 393: PUSH
 394: LD_VAR 0 5
 398: PUSH
 399: LD_EXP 11
 403: ADD
 404: ST_TO_ADDR
// if not Cyrus then
 405: LD_EXP 11
 409: NOT
 410: IFFALSE 473
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 412: LD_ADDR_EXP 12
 416: PUSH
 417: LD_STRING Bobby
 419: PPUSH
 420: LD_EXP 1
 424: NOT
 425: PPUSH
 426: CALL 4149 0 2
 430: ST_TO_ADDR
// if Bobby then
 431: LD_EXP 12
 435: IFFALSE 453
// team := team ^ Bobby ;
 437: LD_ADDR_VAR 0 5
 441: PUSH
 442: LD_VAR 0 5
 446: PUSH
 447: LD_EXP 12
 451: ADD
 452: ST_TO_ADDR
// if not Bobby then
 453: LD_EXP 12
 457: NOT
 458: IFFALSE 473
// begin others3 := CreateCharacterSet ( 03_others ) ;
 460: LD_ADDR_VAR 0 2
 464: PUSH
 465: LD_STRING 03_others
 467: PPUSH
 468: CALL_OW 31
 472: ST_TO_ADDR
// end ; end ; end ; if others4 then
 473: LD_VAR 0 3
 477: IFFALSE 495
// team := team ^ others4 ;
 479: LD_ADDR_VAR 0 5
 483: PUSH
 484: LD_VAR 0 5
 488: PUSH
 489: LD_VAR 0 3
 493: ADD
 494: ST_TO_ADDR
// if others3 then
 495: LD_VAR 0 2
 499: IFFALSE 517
// team := team ^ others3 ;
 501: LD_ADDR_VAR 0 5
 505: PUSH
 506: LD_VAR 0 5
 510: PUSH
 511: LD_VAR 0 2
 515: ADD
 516: ST_TO_ADDR
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 517: LD_ADDR_VAR 0 6
 521: PUSH
 522: LD_INT 30
 524: PUSH
 525: LD_INT 0
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: PPUSH
 532: CALL_OW 69
 536: PUSH
 537: LD_INT 1
 539: ARRAY
 540: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 541: LD_ADDR_VAR 0 7
 545: PUSH
 546: LD_INT 30
 548: PUSH
 549: LD_INT 4
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL_OW 69
 560: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 561: LD_ADDR_VAR 0 8
 565: PUSH
 566: LD_INT 2
 568: PUSH
 569: LD_INT 30
 571: PUSH
 572: LD_INT 7
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: PUSH
 579: LD_INT 30
 581: PUSH
 582: LD_INT 6
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: PPUSH
 594: CALL_OW 69
 598: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 599: LD_ADDR_VAR 0 9
 603: PUSH
 604: LD_INT 30
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PPUSH
 614: CALL_OW 69
 618: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 619: LD_ADDR_VAR 0 10
 623: PUSH
 624: LD_INT 2
 626: PUSH
 627: LD_INT 30
 629: PUSH
 630: LD_INT 32
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 30
 639: PUSH
 640: LD_INT 31
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: PPUSH
 652: CALL_OW 69
 656: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 657: LD_VAR 0 6
 661: PPUSH
 662: LD_STRING Gamma
 664: PPUSH
 665: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 669: LD_VAR 0 6
 673: PPUSH
 674: CALL_OW 274
 678: PPUSH
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 10000
 684: PPUSH
 685: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 689: LD_VAR 0 6
 693: PPUSH
 694: CALL_OW 274
 698: PPUSH
 699: LD_INT 1
 701: PPUSH
 702: LD_INT 10000
 704: PPUSH
 705: CALL_OW 277
// if dep then
 709: LD_VAR 0 6
 713: IFFALSE 795
// begin if Brown then
 715: LD_EXP 14
 719: IFFALSE 755
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 721: LD_EXP 14
 725: PPUSH
 726: LD_VAR 0 6
 730: PUSH
 731: LD_INT 1
 733: ARRAY
 734: PPUSH
 735: CALL_OW 52
// team := team diff Brown ;
 739: LD_ADDR_VAR 0 5
 743: PUSH
 744: LD_VAR 0 5
 748: PUSH
 749: LD_EXP 14
 753: DIFF
 754: ST_TO_ADDR
// end ; if Donaldson then
 755: LD_EXP 13
 759: IFFALSE 795
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 761: LD_EXP 13
 765: PPUSH
 766: LD_VAR 0 6
 770: PUSH
 771: LD_INT 1
 773: ARRAY
 774: PPUSH
 775: CALL_OW 52
// team := team diff Donaldson ;
 779: LD_ADDR_VAR 0 5
 783: PUSH
 784: LD_VAR 0 5
 788: PUSH
 789: LD_EXP 13
 793: DIFF
 794: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 795: LD_VAR 0 10
 799: PUSH
 800: LD_VAR 0 5
 804: PPUSH
 805: LD_INT 25
 807: PUSH
 808: LD_INT 1
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: PPUSH
 815: CALL_OW 72
 819: AND
 820: IFFALSE 929
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 822: LD_ADDR_VAR 0 11
 826: PUSH
 827: LD_VAR 0 5
 831: PPUSH
 832: LD_INT 25
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: EMPTY
 839: LIST
 840: LIST
 841: PPUSH
 842: CALL_OW 72
 846: ST_TO_ADDR
// for i in bun do
 847: LD_ADDR_VAR 0 12
 851: PUSH
 852: LD_VAR 0 10
 856: PUSH
 857: FOR_IN
 858: IFFALSE 927
// begin if not filter then
 860: LD_VAR 0 11
 864: NOT
 865: IFFALSE 869
// break ;
 867: GO 927
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 869: LD_VAR 0 11
 873: PUSH
 874: LD_INT 1
 876: ARRAY
 877: PPUSH
 878: LD_VAR 0 12
 882: PPUSH
 883: CALL_OW 52
// team := team diff filter [ 1 ] ;
 887: LD_ADDR_VAR 0 5
 891: PUSH
 892: LD_VAR 0 5
 896: PUSH
 897: LD_VAR 0 11
 901: PUSH
 902: LD_INT 1
 904: ARRAY
 905: DIFF
 906: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
 907: LD_ADDR_VAR 0 11
 911: PUSH
 912: LD_VAR 0 11
 916: PPUSH
 917: LD_INT 1
 919: PPUSH
 920: CALL_OW 3
 924: ST_TO_ADDR
// end ;
 925: GO 857
 927: POP
 928: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
 929: LD_VAR 0 7
 933: PUSH
 934: LD_VAR 0 5
 938: PPUSH
 939: LD_INT 25
 941: PUSH
 942: LD_INT 1
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: PPUSH
 949: CALL_OW 72
 953: AND
 954: IFFALSE 1076
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 956: LD_ADDR_VAR 0 11
 960: PUSH
 961: LD_VAR 0 5
 965: PPUSH
 966: LD_INT 25
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PPUSH
 976: CALL_OW 72
 980: ST_TO_ADDR
// for i = 1 to filter do
 981: LD_ADDR_VAR 0 12
 985: PUSH
 986: DOUBLE
 987: LD_INT 1
 989: DEC
 990: ST_TO_ADDR
 991: LD_VAR 0 11
 995: PUSH
 996: FOR_TO
 997: IFFALSE 1058
// begin if ( i <= 6 ) then
 999: LD_VAR 0 12
1003: PUSH
1004: LD_INT 6
1006: LESSEQUAL
1007: IFFALSE 1035
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1009: LD_VAR 0 11
1013: PUSH
1014: LD_VAR 0 12
1018: ARRAY
1019: PPUSH
1020: LD_VAR 0 7
1024: PUSH
1025: LD_INT 1
1027: ARRAY
1028: PPUSH
1029: CALL_OW 52
1033: GO 1056
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1035: LD_VAR 0 11
1039: PUSH
1040: LD_VAR 0 12
1044: ARRAY
1045: PPUSH
1046: LD_INT 1
1048: PPUSH
1049: LD_INT 0
1051: PPUSH
1052: CALL_OW 49
// end ;
1056: GO 996
1058: POP
1059: POP
// team := team diff filter ;
1060: LD_ADDR_VAR 0 5
1064: PUSH
1065: LD_VAR 0 5
1069: PUSH
1070: LD_VAR 0 11
1074: DIFF
1075: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1076: LD_VAR 0 8
1080: PUSH
1081: LD_VAR 0 5
1085: PPUSH
1086: LD_INT 25
1088: PUSH
1089: LD_INT 4
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 72
1100: AND
1101: IFFALSE 1223
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1103: LD_ADDR_VAR 0 11
1107: PUSH
1108: LD_VAR 0 5
1112: PPUSH
1113: LD_INT 25
1115: PUSH
1116: LD_INT 4
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL_OW 72
1127: ST_TO_ADDR
// for i = 1 to filter do
1128: LD_ADDR_VAR 0 12
1132: PUSH
1133: DOUBLE
1134: LD_INT 1
1136: DEC
1137: ST_TO_ADDR
1138: LD_VAR 0 11
1142: PUSH
1143: FOR_TO
1144: IFFALSE 1205
// begin if ( i <= 6 ) then
1146: LD_VAR 0 12
1150: PUSH
1151: LD_INT 6
1153: LESSEQUAL
1154: IFFALSE 1182
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1156: LD_VAR 0 11
1160: PUSH
1161: LD_VAR 0 12
1165: ARRAY
1166: PPUSH
1167: LD_VAR 0 8
1171: PUSH
1172: LD_INT 1
1174: ARRAY
1175: PPUSH
1176: CALL_OW 52
1180: GO 1203
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1182: LD_VAR 0 11
1186: PUSH
1187: LD_VAR 0 12
1191: ARRAY
1192: PPUSH
1193: LD_INT 1
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// end ;
1203: GO 1143
1205: POP
1206: POP
// team := team diff filter ;
1207: LD_ADDR_VAR 0 5
1211: PUSH
1212: LD_VAR 0 5
1216: PUSH
1217: LD_VAR 0 11
1221: DIFF
1222: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1223: LD_VAR 0 9
1227: PUSH
1228: LD_VAR 0 5
1232: PPUSH
1233: LD_INT 25
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: PPUSH
1243: CALL_OW 72
1247: AND
1248: IFFALSE 1370
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1250: LD_ADDR_VAR 0 11
1254: PUSH
1255: LD_VAR 0 5
1259: PPUSH
1260: LD_INT 25
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: PPUSH
1270: CALL_OW 72
1274: ST_TO_ADDR
// for i = 1 to filter do
1275: LD_ADDR_VAR 0 12
1279: PUSH
1280: DOUBLE
1281: LD_INT 1
1283: DEC
1284: ST_TO_ADDR
1285: LD_VAR 0 11
1289: PUSH
1290: FOR_TO
1291: IFFALSE 1352
// begin if ( i <= 6 ) then
1293: LD_VAR 0 12
1297: PUSH
1298: LD_INT 6
1300: LESSEQUAL
1301: IFFALSE 1329
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1303: LD_VAR 0 11
1307: PUSH
1308: LD_VAR 0 12
1312: ARRAY
1313: PPUSH
1314: LD_VAR 0 9
1318: PUSH
1319: LD_INT 1
1321: ARRAY
1322: PPUSH
1323: CALL_OW 52
1327: GO 1350
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1329: LD_VAR 0 11
1333: PUSH
1334: LD_VAR 0 12
1338: ARRAY
1339: PPUSH
1340: LD_INT 1
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 49
// end ;
1350: GO 1290
1352: POP
1353: POP
// team := team diff filter ;
1354: LD_ADDR_VAR 0 5
1358: PUSH
1359: LD_VAR 0 5
1363: PUSH
1364: LD_VAR 0 11
1368: DIFF
1369: ST_TO_ADDR
// end ; if team then
1370: LD_VAR 0 5
1374: IFFALSE 1417
// for i in team do
1376: LD_ADDR_VAR 0 12
1380: PUSH
1381: LD_VAR 0 5
1385: PUSH
1386: FOR_IN
1387: IFFALSE 1415
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1389: LD_VAR 0 12
1393: PPUSH
1394: LD_INT 1
1396: PPUSH
1397: LD_INT 0
1399: PPUSH
1400: CALL_OW 49
// ComHold ( i ) ;
1404: LD_VAR 0 12
1408: PPUSH
1409: CALL_OW 140
// end ;
1413: GO 1386
1415: POP
1416: POP
// if fac then
1417: LD_VAR 0 9
1421: IFFALSE 1457
// if UnitsInside ( fac [ 1 ] ) then
1423: LD_VAR 0 9
1427: PUSH
1428: LD_INT 1
1430: ARRAY
1431: PPUSH
1432: CALL_OW 313
1436: IFFALSE 1457
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1438: LD_VAR 0 9
1442: PUSH
1443: LD_INT 1
1445: ARRAY
1446: PPUSH
1447: LD_INT 10
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 486
// if lab then
1457: LD_VAR 0 8
1461: IFFALSE 1497
// if UnitsInside ( lab [ 1 ] ) then
1463: LD_VAR 0 8
1467: PUSH
1468: LD_INT 1
1470: ARRAY
1471: PPUSH
1472: CALL_OW 313
1476: IFFALSE 1497
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1478: LD_VAR 0 8
1482: PUSH
1483: LD_INT 1
1485: ARRAY
1486: PPUSH
1487: LD_INT 10
1489: PPUSH
1490: LD_INT 0
1492: PPUSH
1493: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_INT 1
1504: PPUSH
1505: LD_INT 1
1507: PPUSH
1508: LD_INT 1
1510: PPUSH
1511: LD_INT 2
1513: PPUSH
1514: LD_INT 1
1516: PPUSH
1517: LD_INT 3
1519: PPUSH
1520: LD_INT 100
1522: PPUSH
1523: CALL 4212 0 7
1527: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1528: LD_VAR 0 4
1532: PPUSH
1533: LD_INT 2
1535: PPUSH
1536: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1540: LD_VAR 0 4
1544: PPUSH
1545: LD_INT 21
1547: PPUSH
1548: LD_INT 8
1550: PPUSH
1551: LD_INT 0
1553: PPUSH
1554: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1558: LD_EXP 7
1562: PPUSH
1563: LD_VAR 0 4
1567: PPUSH
1568: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1572: LD_ADDR_VAR 0 4
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 1
1582: PPUSH
1583: LD_INT 1
1585: PPUSH
1586: LD_INT 2
1588: PPUSH
1589: LD_INT 1
1591: PPUSH
1592: LD_INT 2
1594: PPUSH
1595: LD_INT 100
1597: PPUSH
1598: CALL 4212 0 7
1602: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1603: LD_VAR 0 4
1607: PPUSH
1608: LD_INT 2
1610: PPUSH
1611: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1615: LD_VAR 0 4
1619: PPUSH
1620: LD_INT 16
1622: PPUSH
1623: LD_INT 3
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1633: LD_EXP 8
1637: PPUSH
1638: LD_VAR 0 4
1642: PPUSH
1643: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1647: LD_ADDR_VAR 0 4
1651: PUSH
1652: LD_INT 1
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 2
1660: PPUSH
1661: LD_INT 2
1663: PPUSH
1664: LD_INT 1
1666: PPUSH
1667: LD_INT 12
1669: PPUSH
1670: LD_INT 100
1672: PPUSH
1673: CALL 4212 0 7
1677: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1678: LD_VAR 0 4
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: LD_INT 5
1688: PPUSH
1689: CALL_OW 12
1693: PPUSH
1694: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1698: LD_VAR 0 4
1702: PPUSH
1703: LD_INT 1
1705: PPUSH
1706: LD_INT 0
1708: PPUSH
1709: CALL_OW 49
// end ;
1713: LD_VAR 0 1
1717: RET
// function PrepareBase ; var blist , i , b ; begin
1718: LD_INT 0
1720: PPUSH
1721: PPUSH
1722: PPUSH
1723: PPUSH
// blist := LoadVariable ( GammaBase , [ ] ) ;
1724: LD_ADDR_VAR 0 2
1728: PUSH
1729: LD_STRING GammaBase
1731: PPUSH
1732: EMPTY
1733: PPUSH
1734: CALL_OW 30
1738: ST_TO_ADDR
// if not blist and debug then
1739: LD_VAR 0 2
1743: NOT
1744: PUSH
1745: LD_EXP 1
1749: AND
1750: IFFALSE 1790
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1752: LD_ADDR_VAR 0 2
1756: PUSH
1757: LD_INT 0
1759: PUSH
1760: LD_INT 51
1762: PUSH
1763: LD_INT 10
1765: PUSH
1766: LD_INT 3
1768: PUSH
1769: LD_INT 3
1771: PUSH
1772: LD_INT 0
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: EMPTY
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: PUSH
1787: EMPTY
1788: LIST
1789: ST_TO_ADDR
// if not blist then
1790: LD_VAR 0 2
1794: NOT
1795: IFFALSE 1799
// exit ;
1797: GO 1979
// uc_side := 1 ;
1799: LD_ADDR_OWVAR 20
1803: PUSH
1804: LD_INT 1
1806: ST_TO_ADDR
// uc_nation := 1 ;
1807: LD_ADDR_OWVAR 21
1811: PUSH
1812: LD_INT 1
1814: ST_TO_ADDR
// for i in blist do
1815: LD_ADDR_VAR 0 3
1819: PUSH
1820: LD_VAR 0 2
1824: PUSH
1825: FOR_IN
1826: IFFALSE 1977
// begin bc_type := i [ 1 ] ;
1828: LD_ADDR_OWVAR 42
1832: PUSH
1833: LD_VAR 0 3
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1842: LD_ADDR_OWVAR 43
1846: PUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_INT 5
1854: ARRAY
1855: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1856: LD_VAR 0 3
1860: PUSH
1861: LD_INT 1
1863: ARRAY
1864: PUSH
1865: LD_INT 7
1867: PUSH
1868: LD_INT 8
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: IN
1875: IFFALSE 1905
// begin bc_kind1 := i [ 7 ] ;
1877: LD_ADDR_OWVAR 44
1881: PUSH
1882: LD_VAR 0 3
1886: PUSH
1887: LD_INT 7
1889: ARRAY
1890: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1891: LD_ADDR_OWVAR 45
1895: PUSH
1896: LD_VAR 0 3
1900: PUSH
1901: LD_INT 8
1903: ARRAY
1904: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1905: LD_ADDR_VAR 0 4
1909: PUSH
1910: LD_VAR 0 3
1914: PUSH
1915: LD_INT 2
1917: ARRAY
1918: PPUSH
1919: LD_VAR 0 3
1923: PUSH
1924: LD_INT 3
1926: ARRAY
1927: PPUSH
1928: LD_VAR 0 3
1932: PUSH
1933: LD_INT 4
1935: ARRAY
1936: PPUSH
1937: CALL_OW 47
1941: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
1942: LD_VAR 0 4
1946: PPUSH
1947: CALL_OW 266
1951: PUSH
1952: LD_INT 32
1954: EQUAL
1955: IFFALSE 1975
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
1957: LD_VAR 0 4
1961: PPUSH
1962: LD_VAR 0 3
1966: PUSH
1967: LD_INT 7
1969: ARRAY
1970: PPUSH
1971: CALL_OW 431
// end ; end ;
1975: GO 1825
1977: POP
1978: POP
// end ; end_of_file
1979: LD_VAR 0 1
1983: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
1984: LD_INT 0
1986: PPUSH
1987: PPUSH
1988: PPUSH
1989: PPUSH
1990: PPUSH
1991: PPUSH
1992: PPUSH
1993: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
1994: LD_INT 0
1996: PPUSH
1997: LD_INT 0
1999: PPUSH
2000: LD_INT 1
2002: PPUSH
2003: LD_INT 32976
2005: NEG
2006: PPUSH
2007: CALL_OW 330
// InGameOn ;
2011: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2015: LD_INT 33
2017: PPUSH
2018: LD_INT 11
2020: PPUSH
2021: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2025: LD_ADDR_VAR 0 2
2029: PUSH
2030: LD_INT 29
2032: PUSH
2033: LD_INT 21
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: PUSH
2040: LD_INT 41
2042: PUSH
2043: LD_INT 28
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: PUSH
2050: LD_INT 52
2052: PUSH
2053: LD_INT 26
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: PUSH
2060: LD_INT 49
2062: PUSH
2063: LD_INT 16
2065: PUSH
2066: EMPTY
2067: LIST
2068: LIST
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// for i in points do
2076: LD_ADDR_VAR 0 3
2080: PUSH
2081: LD_VAR 0 2
2085: PUSH
2086: FOR_IN
2087: IFFALSE 2127
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2089: LD_EXP 7
2093: PUSH
2094: LD_EXP 8
2098: PUSH
2099: EMPTY
2100: LIST
2101: LIST
2102: PPUSH
2103: LD_VAR 0 3
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PPUSH
2112: LD_VAR 0 3
2116: PUSH
2117: LD_INT 2
2119: ARRAY
2120: PPUSH
2121: CALL_OW 171
2125: GO 2086
2127: POP
2128: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2129: LD_EXP 7
2133: PUSH
2134: LD_EXP 8
2138: PUSH
2139: EMPTY
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2147: LD_INT 35
2149: PPUSH
2150: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2154: LD_EXP 7
2158: PPUSH
2159: CALL_OW 310
2163: NOT
2164: PUSH
2165: LD_EXP 8
2169: PPUSH
2170: CALL_OW 310
2174: NOT
2175: AND
2176: IFFALSE 2147
// ComTurnUnit ( JMM , Gladstone ) ;
2178: LD_EXP 7
2182: PPUSH
2183: LD_EXP 8
2187: PPUSH
2188: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2192: LD_EXP 8
2196: PPUSH
2197: LD_EXP 7
2201: PPUSH
2202: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2206: LD_ADDR_VAR 0 4
2210: PUSH
2211: LD_INT 26
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PPUSH
2221: CALL_OW 69
2225: PUSH
2226: LD_EXP 7
2230: PUSH
2231: LD_EXP 8
2235: PUSH
2236: LD_EXP 12
2240: PUSH
2241: LD_EXP 11
2245: PUSH
2246: LD_EXP 9
2250: PUSH
2251: LD_EXP 14
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: LIST
2260: LIST
2261: LIST
2262: LIST
2263: DIFF
2264: ST_TO_ADDR
// if sol then
2265: LD_VAR 0 4
2269: IFFALSE 2285
// sol := sol [ 1 ] ;
2271: LD_ADDR_VAR 0 4
2275: PUSH
2276: LD_VAR 0 4
2280: PUSH
2281: LD_INT 1
2283: ARRAY
2284: ST_TO_ADDR
// team := [ ] ;
2285: LD_ADDR_VAR 0 5
2289: PUSH
2290: EMPTY
2291: ST_TO_ADDR
// if sol then
2292: LD_VAR 0 4
2296: IFFALSE 2314
// team := team ^ sol ;
2298: LD_ADDR_VAR 0 5
2302: PUSH
2303: LD_VAR 0 5
2307: PUSH
2308: LD_VAR 0 4
2312: ADD
2313: ST_TO_ADDR
// if Lisa then
2314: LD_EXP 10
2318: IFFALSE 2336
// team := team ^ Lisa ;
2320: LD_ADDR_VAR 0 5
2324: PUSH
2325: LD_VAR 0 5
2329: PUSH
2330: LD_EXP 10
2334: ADD
2335: ST_TO_ADDR
// if Donaldson then
2336: LD_EXP 13
2340: IFFALSE 2358
// team := team ^ Donaldson ;
2342: LD_ADDR_VAR 0 5
2346: PUSH
2347: LD_VAR 0 5
2351: PUSH
2352: LD_EXP 13
2356: ADD
2357: ST_TO_ADDR
// if Brown then
2358: LD_EXP 14
2362: IFFALSE 2380
// team := team ^ Brown ;
2364: LD_ADDR_VAR 0 5
2368: PUSH
2369: LD_VAR 0 5
2373: PUSH
2374: LD_EXP 14
2378: ADD
2379: ST_TO_ADDR
// if Bobby then
2380: LD_EXP 12
2384: IFFALSE 2402
// team := team ^ Bobby ;
2386: LD_ADDR_VAR 0 5
2390: PUSH
2391: LD_VAR 0 5
2395: PUSH
2396: LD_EXP 12
2400: ADD
2401: ST_TO_ADDR
// if Cyrus then
2402: LD_EXP 11
2406: IFFALSE 2424
// team := team ^ Cyrus ;
2408: LD_ADDR_VAR 0 5
2412: PUSH
2413: LD_VAR 0 5
2417: PUSH
2418: LD_EXP 11
2422: ADD
2423: ST_TO_ADDR
// if Frank then
2424: LD_EXP 9
2428: IFFALSE 2446
// team := team ^ Frank ;
2430: LD_ADDR_VAR 0 5
2434: PUSH
2435: LD_VAR 0 5
2439: PUSH
2440: LD_EXP 9
2444: ADD
2445: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2446: LD_ADDR_VAR 0 3
2450: PUSH
2451: LD_INT 1
2453: PPUSH
2454: LD_INT 3
2456: PUSH
2457: LD_INT 54
2459: PUSH
2460: EMPTY
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PUSH
2467: LD_INT 21
2469: PUSH
2470: LD_INT 1
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PPUSH
2481: CALL_OW 70
2485: PUSH
2486: LD_EXP 7
2490: PUSH
2491: LD_EXP 8
2495: PUSH
2496: EMPTY
2497: LIST
2498: LIST
2499: DIFF
2500: PUSH
2501: EMPTY
2502: LIST
2503: PUSH
2504: FOR_IN
2505: IFFALSE 2525
// team := team ^ i ;
2507: LD_ADDR_VAR 0 5
2511: PUSH
2512: LD_VAR 0 5
2516: PUSH
2517: LD_VAR 0 3
2521: ADD
2522: ST_TO_ADDR
2523: GO 2504
2525: POP
2526: POP
// if team then
2527: LD_VAR 0 5
2531: IFFALSE 2607
// begin ComExitBuilding ( team ) ;
2533: LD_VAR 0 5
2537: PPUSH
2538: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2542: LD_VAR 0 5
2546: PPUSH
2547: LD_EXP 7
2551: PPUSH
2552: CALL_OW 172
// repeat wait ( 1 ) ;
2556: LD_INT 1
2558: PPUSH
2559: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2563: LD_EXP 7
2567: PPUSH
2568: LD_VAR 0 5
2572: PPUSH
2573: LD_EXP 7
2577: PPUSH
2578: CALL_OW 74
2582: PPUSH
2583: CALL_OW 296
2587: PUSH
2588: LD_INT 6
2590: LESS
2591: IFFALSE 2556
// ComTurnUnit ( team , JMM ) ;
2593: LD_VAR 0 5
2597: PPUSH
2598: LD_EXP 7
2602: PPUSH
2603: CALL_OW 119
// end ; if Lisa then
2607: LD_EXP 10
2611: IFFALSE 2639
// begin ComTurnUnit ( JMM , Lisa ) ;
2613: LD_EXP 7
2617: PPUSH
2618: LD_EXP 10
2622: PPUSH
2623: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2627: LD_EXP 10
2631: PPUSH
2632: LD_STRING D1-Lisa-1
2634: PPUSH
2635: CALL_OW 88
// end ; if sol then
2639: LD_VAR 0 4
2643: IFFALSE 2671
// begin ComTurnUnit ( JMM , sol ) ;
2645: LD_EXP 7
2649: PPUSH
2650: LD_VAR 0 4
2654: PPUSH
2655: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2659: LD_VAR 0 4
2663: PPUSH
2664: LD_STRING D1-Sol1-1
2666: PPUSH
2667: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2671: LD_EXP 7
2675: PPUSH
2676: LD_STRING D1-JMM-1
2678: PPUSH
2679: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2683: LD_EXP 7
2687: PPUSH
2688: LD_STRING D1-JMM-1a
2690: PPUSH
2691: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2695: LD_EXP 7
2699: PPUSH
2700: LD_EXP 8
2704: PPUSH
2705: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2709: LD_VAR 0 5
2713: PPUSH
2714: LD_EXP 8
2718: PPUSH
2719: CALL_OW 119
// if Frank then
2723: LD_EXP 9
2727: IFFALSE 2755
// begin Say ( Frank , D1-Frank-1 ) ;
2729: LD_EXP 9
2733: PPUSH
2734: LD_STRING D1-Frank-1
2736: PPUSH
2737: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2741: LD_EXP 7
2745: PPUSH
2746: LD_EXP 9
2750: PPUSH
2751: CALL_OW 119
// end ; if Lisa then
2755: LD_EXP 10
2759: IFFALSE 2787
// begin ComTurnUnit ( JMM , Lisa ) ;
2761: LD_EXP 7
2765: PPUSH
2766: LD_EXP 10
2770: PPUSH
2771: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2775: LD_EXP 10
2779: PPUSH
2780: LD_STRING D1-Lisa-2
2782: PPUSH
2783: CALL_OW 88
// end ; if sol then
2787: LD_VAR 0 4
2791: IFFALSE 2819
// begin ComTurnUnit ( JMM , sol ) ;
2793: LD_EXP 7
2797: PPUSH
2798: LD_VAR 0 4
2802: PPUSH
2803: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2807: LD_VAR 0 4
2811: PPUSH
2812: LD_STRING D1-Sol1-2
2814: PPUSH
2815: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2819: LD_EXP 8
2823: PPUSH
2824: LD_STRING D1-Glad-2
2826: PPUSH
2827: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2831: LD_VAR 0 5
2835: PPUSH
2836: LD_EXP 7
2840: PPUSH
2841: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2845: LD_EXP 7
2849: PPUSH
2850: LD_STRING D1-JMM-2
2852: PPUSH
2853: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2857: LD_EXP 7
2861: PPUSH
2862: LD_EXP 8
2866: PPUSH
2867: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2871: LD_EXP 8
2875: PPUSH
2876: LD_STRING D1-Glad-3
2878: PPUSH
2879: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2883: LD_EXP 7
2887: PPUSH
2888: LD_STRING D1-JMM-3
2890: PPUSH
2891: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2895: LD_EXP 8
2899: PPUSH
2900: LD_STRING D1-Glad-4
2902: PPUSH
2903: CALL_OW 88
// if Frank then
2907: LD_EXP 9
2911: IFFALSE 2939
// begin ComTurnUnit ( JMM , Frank ) ;
2913: LD_EXP 7
2917: PPUSH
2918: LD_EXP 9
2922: PPUSH
2923: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2927: LD_EXP 9
2931: PPUSH
2932: LD_STRING D1-Frank-4
2934: PPUSH
2935: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
2939: LD_EXP 7
2943: PPUSH
2944: LD_EXP 8
2948: PPUSH
2949: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
2953: LD_EXP 7
2957: PPUSH
2958: LD_STRING D1-JMM-4
2960: PPUSH
2961: CALL_OW 88
// if Lisa then
2965: LD_EXP 10
2969: IFFALSE 3036
// begin Say ( Lisa , D1-Lisa-4 ) ;
2971: LD_EXP 10
2975: PPUSH
2976: LD_STRING D1-Lisa-4
2978: PPUSH
2979: CALL_OW 88
// if Frank then
2983: LD_EXP 9
2987: IFFALSE 3036
// begin ComTurnUnit ( Frank , Lisa ) ;
2989: LD_EXP 9
2993: PPUSH
2994: LD_EXP 10
2998: PPUSH
2999: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3003: LD_EXP 9
3007: PPUSH
3008: LD_STRING D1-Frank-5
3010: PPUSH
3011: CALL_OW 88
// Wait ( 3 ) ;
3015: LD_INT 3
3017: PPUSH
3018: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3022: LD_EXP 9
3026: PPUSH
3027: LD_EXP 7
3031: PPUSH
3032: CALL_OW 179
// end ; end ; if sol then
3036: LD_VAR 0 4
3040: IFFALSE 3054
// Say ( sol , D1-Sol1-5 ) ;
3042: LD_VAR 0 4
3046: PPUSH
3047: LD_STRING D1-Sol1-5
3049: PPUSH
3050: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3054: LD_EXP 7
3058: PPUSH
3059: LD_STRING D1-JMM-5
3061: PPUSH
3062: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3066: LD_EXP 8
3070: PPUSH
3071: LD_STRING D1-Glad-5
3073: PPUSH
3074: CALL_OW 88
// if Frank then
3078: LD_EXP 9
3082: IFFALSE 3096
// Say ( Frank , D1-Frank-6 ) ;
3084: LD_EXP 9
3088: PPUSH
3089: LD_STRING D1-Frank-6
3091: PPUSH
3092: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3096: LD_EXP 7
3100: PPUSH
3101: LD_STRING D1-JMM-6
3103: PPUSH
3104: CALL_OW 88
// if Brown and Donaldson then
3108: LD_EXP 14
3112: PUSH
3113: LD_EXP 13
3117: AND
3118: IFFALSE 3167
// case Query ( QCommander ) of 1 :
3120: LD_STRING QCommander
3122: PPUSH
3123: CALL_OW 97
3127: PUSH
3128: LD_INT 1
3130: DOUBLE
3131: EQUAL
3132: IFTRUE 3136
3134: GO 3147
3136: POP
// donaldson_commander := true ; 2 :
3137: LD_ADDR_EXP 4
3141: PUSH
3142: LD_INT 1
3144: ST_TO_ADDR
3145: GO 3167
3147: LD_INT 2
3149: DOUBLE
3150: EQUAL
3151: IFTRUE 3155
3153: GO 3166
3155: POP
// brown_commander := true ; end ;
3156: LD_ADDR_EXP 5
3160: PUSH
3161: LD_INT 1
3163: ST_TO_ADDR
3164: GO 3167
3166: POP
// if not Brown and Donaldson then
3167: LD_EXP 14
3171: NOT
3172: PUSH
3173: LD_EXP 13
3177: AND
3178: IFFALSE 3188
// donaldson_commander := true ;
3180: LD_ADDR_EXP 4
3184: PUSH
3185: LD_INT 1
3187: ST_TO_ADDR
// if Brown and not Donaldson then
3188: LD_EXP 14
3192: PUSH
3193: LD_EXP 13
3197: NOT
3198: AND
3199: IFFALSE 3209
// brown_commander := true ;
3201: LD_ADDR_EXP 5
3205: PUSH
3206: LD_INT 1
3208: ST_TO_ADDR
// if donaldson_commander then
3209: LD_EXP 4
3213: IFFALSE 3360
// begin ComTurnUnit ( JMM , Donaldson ) ;
3215: LD_EXP 7
3219: PPUSH
3220: LD_EXP 13
3224: PPUSH
3225: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3229: LD_EXP 7
3233: PPUSH
3234: LD_STRING D1a-JMM-1
3236: PPUSH
3237: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3241: LD_EXP 13
3245: PPUSH
3246: LD_EXP 7
3250: PPUSH
3251: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3255: LD_EXP 13
3259: PPUSH
3260: LD_EXP 7
3264: PPUSH
3265: CALL_OW 179
// Wait ( 3 ) ;
3269: LD_INT 3
3271: PPUSH
3272: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3276: LD_EXP 13
3280: PPUSH
3281: LD_STRING D1a-Don-1
3283: PPUSH
3284: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3288: LD_EXP 7
3292: PPUSH
3293: LD_STRING D1b-JMM-2
3295: PPUSH
3296: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3300: LD_EXP 13
3304: PPUSH
3305: LD_STRING D1a-Don-2
3307: PPUSH
3308: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3312: LD_EXP 13
3316: PPUSH
3317: LD_INT 30
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PPUSH
3327: CALL_OW 69
3331: PUSH
3332: LD_INT 1
3334: ARRAY
3335: PPUSH
3336: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3340: LD_INT 1
3342: PPUSH
3343: LD_STRING GammaCommander
3345: PPUSH
3346: CALL_OW 39
// commander := Donaldson ;
3350: LD_ADDR_VAR 0 7
3354: PUSH
3355: LD_EXP 13
3359: ST_TO_ADDR
// end ; if brown_commander then
3360: LD_EXP 5
3364: IFFALSE 3511
// begin ComTurnUnit ( JMM , Brown ) ;
3366: LD_EXP 7
3370: PPUSH
3371: LD_EXP 14
3375: PPUSH
3376: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3380: LD_EXP 7
3384: PPUSH
3385: LD_STRING D1b-JMM-1
3387: PPUSH
3388: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3392: LD_EXP 14
3396: PPUSH
3397: LD_EXP 7
3401: PPUSH
3402: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3406: LD_EXP 14
3410: PPUSH
3411: LD_EXP 7
3415: PPUSH
3416: CALL_OW 179
// Wait ( 3 ) ;
3420: LD_INT 3
3422: PPUSH
3423: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3427: LD_EXP 14
3431: PPUSH
3432: LD_STRING D1b-Brown-1
3434: PPUSH
3435: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3439: LD_EXP 7
3443: PPUSH
3444: LD_STRING D1a-JMM-2
3446: PPUSH
3447: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3451: LD_EXP 14
3455: PPUSH
3456: LD_STRING D1b-Brown-2
3458: PPUSH
3459: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3463: LD_EXP 14
3467: PPUSH
3468: LD_INT 30
3470: PUSH
3471: LD_INT 0
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: PPUSH
3478: CALL_OW 69
3482: PUSH
3483: LD_INT 1
3485: ARRAY
3486: PPUSH
3487: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3491: LD_INT 2
3493: PPUSH
3494: LD_STRING GammaCommander
3496: PPUSH
3497: CALL_OW 39
// commander := Brown ;
3501: LD_ADDR_VAR 0 7
3505: PUSH
3506: LD_EXP 14
3510: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3511: LD_EXP 7
3515: PPUSH
3516: LD_EXP 8
3520: PPUSH
3521: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3525: LD_EXP 4
3529: NOT
3530: PUSH
3531: LD_EXP 5
3535: NOT
3536: AND
3537: IFFALSE 3561
// begin Say ( JMM , D1c-JMM-1 ) ;
3539: LD_EXP 7
3543: PPUSH
3544: LD_STRING D1c-JMM-1
3546: PPUSH
3547: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3551: LD_INT 3
3553: PPUSH
3554: LD_STRING GammaCommander
3556: PPUSH
3557: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3561: LD_EXP 7
3565: PPUSH
3566: LD_STRING D1d-JMM-1
3568: PPUSH
3569: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_INT 21
3580: PUSH
3581: LD_INT 1
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: PPUSH
3588: CALL_OW 69
3592: PUSH
3593: LD_EXP 7
3597: PUSH
3598: LD_EXP 8
3602: PUSH
3603: LD_VAR 0 7
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: DIFF
3613: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3614: LD_ADDR_EXP 6
3618: PUSH
3619: LD_STRING 1
3621: PPUSH
3622: LD_INT 5
3624: PPUSH
3625: LD_INT 5
3627: PPUSH
3628: LD_INT -5
3630: PUSH
3631: LD_EXP 7
3635: PUSH
3636: LD_INT -6
3638: PUSH
3639: LD_EXP 8
3643: PUSH
3644: LD_INT -2
3646: PUSH
3647: LD_INT -3
3649: PUSH
3650: LD_INT -5
3652: PUSH
3653: EMPTY
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: LIST
3661: PUSH
3662: LD_VAR 0 6
3666: ADD
3667: PUSH
3668: LD_INT -6
3670: PUSH
3671: LD_INT -4
3673: PUSH
3674: LD_VAR 0 7
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: ADD
3684: PPUSH
3685: LD_INT 1
3687: PUSH
3688: LD_INT 3
3690: PUSH
3691: LD_INT 2
3693: PUSH
3694: LD_INT 1
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: PUSH
3701: LD_INT 4
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 42
3714: ST_TO_ADDR
// SaveCharacters ( all diff [ save_group , JMM , Gladstone ] , othersGamma ) ;
3715: LD_VAR 0 6
3719: PUSH
3720: LD_EXP 6
3724: PUSH
3725: LD_EXP 7
3729: PUSH
3730: LD_EXP 8
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: DIFF
3740: PPUSH
3741: LD_STRING othersGamma
3743: PPUSH
3744: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
3748: LD_EXP 6
3752: PUSH
3753: LD_EXP 7
3757: PUSH
3758: LD_EXP 8
3762: PUSH
3763: LD_EXP 10
3767: PUSH
3768: LD_EXP 11
3772: PUSH
3773: LD_EXP 12
3777: PUSH
3778: LD_EXP 9
3782: PUSH
3783: LD_EXP 13
3787: PUSH
3788: LD_EXP 14
3792: PUSH
3793: LD_INT 0
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: DIFF
3807: PPUSH
3808: LD_STRING othersDelta
3810: PPUSH
3811: CALL_OW 38
// if Lisa in save_group then
3815: LD_EXP 10
3819: PUSH
3820: LD_EXP 6
3824: IN
3825: IFFALSE 3837
// begin SaveVariable ( true , LisaInDelta ) ;
3827: LD_INT 1
3829: PPUSH
3830: LD_STRING LisaInDelta
3832: PPUSH
3833: CALL_OW 39
// end ; if Bobby in save_group then
3837: LD_EXP 12
3841: PUSH
3842: LD_EXP 6
3846: IN
3847: IFFALSE 3859
// begin SaveVariable ( true , BobbyInDelta ) ;
3849: LD_INT 1
3851: PPUSH
3852: LD_STRING BobbyInDelta
3854: PPUSH
3855: CALL_OW 39
// end ; if Cyrus in save_group then
3859: LD_EXP 11
3863: PUSH
3864: LD_EXP 6
3868: IN
3869: IFFALSE 3881
// begin SaveVariable ( true , CyrusInDelta ) ;
3871: LD_INT 1
3873: PPUSH
3874: LD_STRING CyrusInDelta
3876: PPUSH
3877: CALL_OW 39
// end ; if Frank in save_group then
3881: LD_EXP 9
3885: PUSH
3886: LD_EXP 6
3890: IN
3891: IFFALSE 3903
// begin SaveVariable ( true , FrankInDelta ) ;
3893: LD_INT 1
3895: PPUSH
3896: LD_STRING FrankInDelta
3898: PPUSH
3899: CALL_OW 39
// end ; if Brown in save_group then
3903: LD_EXP 14
3907: PUSH
3908: LD_EXP 6
3912: IN
3913: IFFALSE 3925
// begin SaveVariable ( true , BrownInDelta ) ;
3915: LD_INT 1
3917: PPUSH
3918: LD_STRING BrownInDelta
3920: PPUSH
3921: CALL_OW 39
// end ; if Donaldson in save_group then
3925: LD_EXP 13
3929: PUSH
3930: LD_EXP 6
3934: IN
3935: IFFALSE 3947
// begin SaveVariable ( true , DonaldsonInDelta ) ;
3937: LD_INT 1
3939: PPUSH
3940: LD_STRING DonaldsonInDelta
3942: PPUSH
3943: CALL_OW 39
// end ; Wait ( 3 ) ;
3947: LD_INT 3
3949: PPUSH
3950: CALL_OW 67
// for i in save_group do
3954: LD_ADDR_VAR 0 3
3958: PUSH
3959: LD_EXP 6
3963: PUSH
3964: FOR_IN
3965: IFFALSE 3996
// begin if IsInUnit ( i ) then
3967: LD_VAR 0 3
3971: PPUSH
3972: CALL_OW 310
3976: IFFALSE 3987
// ComExitBuilding ( i ) ;
3978: LD_VAR 0 3
3982: PPUSH
3983: CALL_OW 122
// Wait ( 3 ) ;
3987: LD_INT 3
3989: PPUSH
3990: CALL_OW 67
// end ;
3994: GO 3964
3996: POP
3997: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
3998: LD_ADDR_EXP 6
4002: PUSH
4003: LD_EXP 6
4007: PPUSH
4008: LD_INT 1
4010: PPUSH
4011: LD_EXP 7
4015: PPUSH
4016: CALL_OW 2
4020: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4021: LD_ADDR_EXP 6
4025: PUSH
4026: LD_EXP 6
4030: PPUSH
4031: LD_INT 2
4033: PPUSH
4034: LD_EXP 8
4038: PPUSH
4039: CALL_OW 2
4043: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4044: LD_ADDR_VAR 0 8
4048: PUSH
4049: LD_INT 21
4051: PUSH
4052: LD_INT 2
4054: PUSH
4055: EMPTY
4056: LIST
4057: LIST
4058: PPUSH
4059: CALL_OW 69
4063: ST_TO_ADDR
// for i = 1 to filter do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_VAR 0 8
4078: PUSH
4079: FOR_TO
4080: IFFALSE 4110
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4082: LD_EXP 6
4086: PUSH
4087: LD_VAR 0 3
4091: ARRAY
4092: PPUSH
4093: LD_VAR 0 8
4097: PUSH
4098: LD_VAR 0 3
4102: ARRAY
4103: PPUSH
4104: CALL_OW 120
4108: GO 4079
4110: POP
4111: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4112: LD_EXP 6
4116: PPUSH
4117: LD_INT 87
4119: PPUSH
4120: LD_INT 27
4122: PPUSH
4123: CALL_OW 171
// Wait ( 0 0$05 ) ;
4127: LD_INT 175
4129: PPUSH
4130: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4134: LD_INT 1
4136: PPUSH
4137: LD_STRING %_cont
4139: PPUSH
4140: CALL_OW 340
// end ; end_of_file
4144: LD_VAR 0 1
4148: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4149: LD_INT 0
4151: PPUSH
4152: PPUSH
// if exist_mode then
4153: LD_VAR 0 2
4157: IFFALSE 4182
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4159: LD_ADDR_VAR 0 4
4163: PUSH
4164: LD_EXP 3
4168: PUSH
4169: LD_VAR 0 1
4173: STR
4174: PPUSH
4175: CALL_OW 34
4179: ST_TO_ADDR
4180: GO 4197
// unit := NewCharacter ( ident ) ;
4182: LD_ADDR_VAR 0 4
4186: PUSH
4187: LD_VAR 0 1
4191: PPUSH
4192: CALL_OW 25
4196: ST_TO_ADDR
// result := unit ;
4197: LD_ADDR_VAR 0 3
4201: PUSH
4202: LD_VAR 0 4
4206: ST_TO_ADDR
// end ;
4207: LD_VAR 0 3
4211: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4212: LD_INT 0
4214: PPUSH
// uc_side := side ;
4215: LD_ADDR_OWVAR 20
4219: PUSH
4220: LD_VAR 0 1
4224: ST_TO_ADDR
// uc_nation := nation ;
4225: LD_ADDR_OWVAR 21
4229: PUSH
4230: LD_VAR 0 2
4234: ST_TO_ADDR
// vc_chassis := chassis ;
4235: LD_ADDR_OWVAR 37
4239: PUSH
4240: LD_VAR 0 3
4244: ST_TO_ADDR
// vc_engine := engine ;
4245: LD_ADDR_OWVAR 39
4249: PUSH
4250: LD_VAR 0 4
4254: ST_TO_ADDR
// vc_control := control ;
4255: LD_ADDR_OWVAR 38
4259: PUSH
4260: LD_VAR 0 5
4264: ST_TO_ADDR
// vc_weapon := weapon ;
4265: LD_ADDR_OWVAR 40
4269: PUSH
4270: LD_VAR 0 6
4274: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4275: LD_ADDR_OWVAR 41
4279: PUSH
4280: LD_VAR 0 7
4284: ST_TO_ADDR
// result := CreateVehicle ;
4285: LD_ADDR_VAR 0 8
4289: PUSH
4290: CALL_OW 45
4294: ST_TO_ADDR
// end ;
4295: LD_VAR 0 8
4299: RET
// export function SayX ( units , ident ) ; var i ; begin
4300: LD_INT 0
4302: PPUSH
4303: PPUSH
// result := false ;
4304: LD_ADDR_VAR 0 3
4308: PUSH
4309: LD_INT 0
4311: ST_TO_ADDR
// if not units then
4312: LD_VAR 0 1
4316: NOT
4317: IFFALSE 4321
// exit ;
4319: GO 4375
// for i in units do
4321: LD_ADDR_VAR 0 4
4325: PUSH
4326: LD_VAR 0 1
4330: PUSH
4331: FOR_IN
4332: IFFALSE 4373
// if IsOk ( i ) then
4334: LD_VAR 0 4
4338: PPUSH
4339: CALL_OW 302
4343: IFFALSE 4371
// begin Say ( i , ident ) ;
4345: LD_VAR 0 4
4349: PPUSH
4350: LD_VAR 0 2
4354: PPUSH
4355: CALL_OW 88
// result := i ;
4359: LD_ADDR_VAR 0 3
4363: PUSH
4364: LD_VAR 0 4
4368: ST_TO_ADDR
// break ;
4369: GO 4373
// end ;
4371: GO 4331
4373: POP
4374: POP
// end ;
4375: LD_VAR 0 3
4379: RET
