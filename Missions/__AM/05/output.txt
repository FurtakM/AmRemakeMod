// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 2069 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05a_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05a_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , tmp ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
 118: PPUSH
// PrepareBase ;
 119: CALL 1790 0 0
// uc_side := 1 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// uc_nation := 1 ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// team := [ ] ;
 139: LD_ADDR_VAR 0 5
 143: PUSH
 144: EMPTY
 145: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_STRING JMM
 153: PPUSH
 154: LD_EXP 1
 158: NOT
 159: PPUSH
 160: CALL 4400 0 2
 164: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_STRING Gladstone
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: CALL 4400 0 2
 180: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 181: LD_ADDR_EXP 9
 185: PUSH
 186: LD_STRING Frank
 188: PPUSH
 189: LD_EXP 1
 193: NOT
 194: PPUSH
 195: CALL 4400 0 2
 199: ST_TO_ADDR
// if Frank then
 200: LD_EXP 9
 204: IFFALSE 222
// team := team ^ Frank ;
 206: LD_ADDR_VAR 0 5
 210: PUSH
 211: LD_VAR 0 5
 215: PUSH
 216: LD_EXP 9
 220: ADD
 221: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 222: LD_ADDR_EXP 10
 226: PUSH
 227: LD_STRING Lisa
 229: PPUSH
 230: LD_EXP 1
 234: NOT
 235: PPUSH
 236: CALL 4400 0 2
 240: ST_TO_ADDR
// if Lisa then
 241: LD_EXP 10
 245: IFFALSE 263
// team := team ^ Lisa ;
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 5
 256: PUSH
 257: LD_EXP 10
 261: ADD
 262: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 263: LD_ADDR_EXP 13
 267: PUSH
 268: LD_STRING Donaldson
 270: PPUSH
 271: LD_EXP 1
 275: NOT
 276: PPUSH
 277: CALL 4400 0 2
 281: ST_TO_ADDR
// if Donaldson then
 282: LD_EXP 13
 286: IFFALSE 304
// team := team ^ Donaldson ;
 288: LD_ADDR_VAR 0 5
 292: PUSH
 293: LD_VAR 0 5
 297: PUSH
 298: LD_EXP 13
 302: ADD
 303: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 304: LD_ADDR_EXP 14
 308: PUSH
 309: LD_STRING Brown
 311: PPUSH
 312: LD_EXP 1
 316: NOT
 317: PPUSH
 318: CALL 4400 0 2
 322: ST_TO_ADDR
// if Brown then
 323: LD_EXP 14
 327: IFFALSE 345
// team := team ^ Brown ;
 329: LD_ADDR_VAR 0 5
 333: PUSH
 334: LD_VAR 0 5
 338: PUSH
 339: LD_EXP 14
 343: ADD
 344: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 345: LD_ADDR_VAR 0 3
 349: PUSH
 350: LD_STRING 04_other_survivors
 352: PPUSH
 353: CALL_OW 31
 357: ST_TO_ADDR
// DeleteCharacters ( 04_other_survivors ) ;
 358: LD_STRING 04_other_survivors
 360: PPUSH
 361: CALL_OW 40
// if not Lisa then
 365: LD_EXP 10
 369: NOT
 370: IFFALSE 488
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 372: LD_ADDR_EXP 11
 376: PUSH
 377: LD_STRING Cyrus
 379: PPUSH
 380: LD_EXP 1
 384: NOT
 385: PPUSH
 386: CALL 4400 0 2
 390: ST_TO_ADDR
// if Cyrus then
 391: LD_EXP 11
 395: IFFALSE 413
// team := team ^ Cyrus ;
 397: LD_ADDR_VAR 0 5
 401: PUSH
 402: LD_VAR 0 5
 406: PUSH
 407: LD_EXP 11
 411: ADD
 412: ST_TO_ADDR
// if not Cyrus then
 413: LD_EXP 11
 417: NOT
 418: IFFALSE 488
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 420: LD_ADDR_EXP 12
 424: PUSH
 425: LD_STRING Bobby
 427: PPUSH
 428: LD_EXP 1
 432: NOT
 433: PPUSH
 434: CALL 4400 0 2
 438: ST_TO_ADDR
// if Bobby then
 439: LD_EXP 12
 443: IFFALSE 461
// team := team ^ Bobby ;
 445: LD_ADDR_VAR 0 5
 449: PUSH
 450: LD_VAR 0 5
 454: PUSH
 455: LD_EXP 12
 459: ADD
 460: ST_TO_ADDR
// if not Bobby then
 461: LD_EXP 12
 465: NOT
 466: IFFALSE 488
// begin others3 := CreateCharacterSet ( 03_others ) ;
 468: LD_ADDR_VAR 0 2
 472: PUSH
 473: LD_STRING 03_others
 475: PPUSH
 476: CALL_OW 31
 480: ST_TO_ADDR
// DeleteCharacters ( 03_others ) ;
 481: LD_STRING 03_others
 483: PPUSH
 484: CALL_OW 40
// end ; end ; end ; if others4 then
 488: LD_VAR 0 3
 492: IFFALSE 510
// team := team ^ others4 ;
 494: LD_ADDR_VAR 0 5
 498: PUSH
 499: LD_VAR 0 5
 503: PUSH
 504: LD_VAR 0 3
 508: ADD
 509: ST_TO_ADDR
// if others3 then
 510: LD_VAR 0 2
 514: IFFALSE 532
// team := team ^ others3 ;
 516: LD_ADDR_VAR 0 5
 520: PUSH
 521: LD_VAR 0 5
 525: PUSH
 526: LD_VAR 0 2
 530: ADD
 531: ST_TO_ADDR
// if team < 9 then
 532: LD_VAR 0 5
 536: PUSH
 537: LD_INT 9
 539: LESS
 540: IFFALSE 589
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 4 ) ;
 542: LD_INT 0
 544: PPUSH
 545: LD_INT 1
 547: PPUSH
 548: LD_INT 4
 550: PPUSH
 551: CALL_OW 12
 555: PPUSH
 556: LD_INT 4
 558: PPUSH
 559: CALL_OW 380
// team := team ^ CreateHuman ;
 563: LD_ADDR_VAR 0 5
 567: PUSH
 568: LD_VAR 0 5
 572: PUSH
 573: CALL_OW 44
 577: ADD
 578: ST_TO_ADDR
// until team = 9 ;
 579: LD_VAR 0 5
 583: PUSH
 584: LD_INT 9
 586: EQUAL
 587: IFFALSE 542
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 589: LD_ADDR_VAR 0 6
 593: PUSH
 594: LD_INT 30
 596: PUSH
 597: LD_INT 0
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: PPUSH
 604: CALL_OW 69
 608: PUSH
 609: LD_INT 1
 611: ARRAY
 612: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 613: LD_ADDR_VAR 0 7
 617: PUSH
 618: LD_INT 30
 620: PUSH
 621: LD_INT 4
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: PPUSH
 628: CALL_OW 69
 632: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 633: LD_ADDR_VAR 0 8
 637: PUSH
 638: LD_INT 2
 640: PUSH
 641: LD_INT 30
 643: PUSH
 644: LD_INT 7
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 30
 653: PUSH
 654: LD_INT 6
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: PPUSH
 666: CALL_OW 69
 670: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 671: LD_ADDR_VAR 0 9
 675: PUSH
 676: LD_INT 30
 678: PUSH
 679: LD_INT 3
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: PPUSH
 686: CALL_OW 69
 690: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 691: LD_ADDR_VAR 0 10
 695: PUSH
 696: LD_INT 2
 698: PUSH
 699: LD_INT 30
 701: PUSH
 702: LD_INT 32
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: PUSH
 709: LD_INT 30
 711: PUSH
 712: LD_INT 31
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: PPUSH
 724: CALL_OW 69
 728: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 729: LD_VAR 0 6
 733: PPUSH
 734: LD_STRING Gamma
 736: PPUSH
 737: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 741: LD_VAR 0 6
 745: PPUSH
 746: CALL_OW 274
 750: PPUSH
 751: LD_INT 2
 753: PPUSH
 754: LD_INT 10000
 756: PPUSH
 757: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 761: LD_VAR 0 6
 765: PPUSH
 766: CALL_OW 274
 770: PPUSH
 771: LD_INT 1
 773: PPUSH
 774: LD_INT 10000
 776: PPUSH
 777: CALL_OW 277
// if dep then
 781: LD_VAR 0 6
 785: IFFALSE 867
// begin if Brown then
 787: LD_EXP 14
 791: IFFALSE 827
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 793: LD_EXP 14
 797: PPUSH
 798: LD_VAR 0 6
 802: PUSH
 803: LD_INT 1
 805: ARRAY
 806: PPUSH
 807: CALL_OW 52
// team := team diff Brown ;
 811: LD_ADDR_VAR 0 5
 815: PUSH
 816: LD_VAR 0 5
 820: PUSH
 821: LD_EXP 14
 825: DIFF
 826: ST_TO_ADDR
// end ; if Donaldson then
 827: LD_EXP 13
 831: IFFALSE 867
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 833: LD_EXP 13
 837: PPUSH
 838: LD_VAR 0 6
 842: PUSH
 843: LD_INT 1
 845: ARRAY
 846: PPUSH
 847: CALL_OW 52
// team := team diff Donaldson ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 5
 860: PUSH
 861: LD_EXP 13
 865: DIFF
 866: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 867: LD_VAR 0 10
 871: PUSH
 872: LD_VAR 0 5
 876: PPUSH
 877: LD_INT 25
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: PPUSH
 887: CALL_OW 72
 891: AND
 892: IFFALSE 1001
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 894: LD_ADDR_VAR 0 11
 898: PUSH
 899: LD_VAR 0 5
 903: PPUSH
 904: LD_INT 25
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: PPUSH
 914: CALL_OW 72
 918: ST_TO_ADDR
// for i in bun do
 919: LD_ADDR_VAR 0 12
 923: PUSH
 924: LD_VAR 0 10
 928: PUSH
 929: FOR_IN
 930: IFFALSE 999
// begin if not filter then
 932: LD_VAR 0 11
 936: NOT
 937: IFFALSE 941
// break ;
 939: GO 999
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 941: LD_VAR 0 11
 945: PUSH
 946: LD_INT 1
 948: ARRAY
 949: PPUSH
 950: LD_VAR 0 12
 954: PPUSH
 955: CALL_OW 52
// team := team diff filter [ 1 ] ;
 959: LD_ADDR_VAR 0 5
 963: PUSH
 964: LD_VAR 0 5
 968: PUSH
 969: LD_VAR 0 11
 973: PUSH
 974: LD_INT 1
 976: ARRAY
 977: DIFF
 978: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
 979: LD_ADDR_VAR 0 11
 983: PUSH
 984: LD_VAR 0 11
 988: PPUSH
 989: LD_INT 1
 991: PPUSH
 992: CALL_OW 3
 996: ST_TO_ADDR
// end ;
 997: GO 929
 999: POP
1000: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1001: LD_VAR 0 7
1005: PUSH
1006: LD_VAR 0 5
1010: PPUSH
1011: LD_INT 25
1013: PUSH
1014: LD_INT 1
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: PPUSH
1021: CALL_OW 72
1025: AND
1026: IFFALSE 1148
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1028: LD_ADDR_VAR 0 11
1032: PUSH
1033: LD_VAR 0 5
1037: PPUSH
1038: LD_INT 25
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: EMPTY
1045: LIST
1046: LIST
1047: PPUSH
1048: CALL_OW 72
1052: ST_TO_ADDR
// for i = 1 to filter do
1053: LD_ADDR_VAR 0 12
1057: PUSH
1058: DOUBLE
1059: LD_INT 1
1061: DEC
1062: ST_TO_ADDR
1063: LD_VAR 0 11
1067: PUSH
1068: FOR_TO
1069: IFFALSE 1130
// begin if ( i <= 6 ) then
1071: LD_VAR 0 12
1075: PUSH
1076: LD_INT 6
1078: LESSEQUAL
1079: IFFALSE 1107
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1081: LD_VAR 0 11
1085: PUSH
1086: LD_VAR 0 12
1090: ARRAY
1091: PPUSH
1092: LD_VAR 0 7
1096: PUSH
1097: LD_INT 1
1099: ARRAY
1100: PPUSH
1101: CALL_OW 52
1105: GO 1128
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1107: LD_VAR 0 11
1111: PUSH
1112: LD_VAR 0 12
1116: ARRAY
1117: PPUSH
1118: LD_INT 1
1120: PPUSH
1121: LD_INT 0
1123: PPUSH
1124: CALL_OW 49
// end ;
1128: GO 1068
1130: POP
1131: POP
// team := team diff filter ;
1132: LD_ADDR_VAR 0 5
1136: PUSH
1137: LD_VAR 0 5
1141: PUSH
1142: LD_VAR 0 11
1146: DIFF
1147: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1148: LD_VAR 0 8
1152: PUSH
1153: LD_VAR 0 5
1157: PPUSH
1158: LD_INT 25
1160: PUSH
1161: LD_INT 4
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: PPUSH
1168: CALL_OW 72
1172: AND
1173: IFFALSE 1295
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1175: LD_ADDR_VAR 0 11
1179: PUSH
1180: LD_VAR 0 5
1184: PPUSH
1185: LD_INT 25
1187: PUSH
1188: LD_INT 4
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: PPUSH
1195: CALL_OW 72
1199: ST_TO_ADDR
// for i = 1 to filter do
1200: LD_ADDR_VAR 0 12
1204: PUSH
1205: DOUBLE
1206: LD_INT 1
1208: DEC
1209: ST_TO_ADDR
1210: LD_VAR 0 11
1214: PUSH
1215: FOR_TO
1216: IFFALSE 1277
// begin if ( i <= 6 ) then
1218: LD_VAR 0 12
1222: PUSH
1223: LD_INT 6
1225: LESSEQUAL
1226: IFFALSE 1254
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1228: LD_VAR 0 11
1232: PUSH
1233: LD_VAR 0 12
1237: ARRAY
1238: PPUSH
1239: LD_VAR 0 8
1243: PUSH
1244: LD_INT 1
1246: ARRAY
1247: PPUSH
1248: CALL_OW 52
1252: GO 1275
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1254: LD_VAR 0 11
1258: PUSH
1259: LD_VAR 0 12
1263: ARRAY
1264: PPUSH
1265: LD_INT 1
1267: PPUSH
1268: LD_INT 0
1270: PPUSH
1271: CALL_OW 49
// end ;
1275: GO 1215
1277: POP
1278: POP
// team := team diff filter ;
1279: LD_ADDR_VAR 0 5
1283: PUSH
1284: LD_VAR 0 5
1288: PUSH
1289: LD_VAR 0 11
1293: DIFF
1294: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1295: LD_VAR 0 9
1299: PUSH
1300: LD_VAR 0 5
1304: PPUSH
1305: LD_INT 25
1307: PUSH
1308: LD_INT 3
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL_OW 72
1319: AND
1320: IFFALSE 1442
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1322: LD_ADDR_VAR 0 11
1326: PUSH
1327: LD_VAR 0 5
1331: PPUSH
1332: LD_INT 25
1334: PUSH
1335: LD_INT 3
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: PPUSH
1342: CALL_OW 72
1346: ST_TO_ADDR
// for i = 1 to filter do
1347: LD_ADDR_VAR 0 12
1351: PUSH
1352: DOUBLE
1353: LD_INT 1
1355: DEC
1356: ST_TO_ADDR
1357: LD_VAR 0 11
1361: PUSH
1362: FOR_TO
1363: IFFALSE 1424
// begin if ( i <= 6 ) then
1365: LD_VAR 0 12
1369: PUSH
1370: LD_INT 6
1372: LESSEQUAL
1373: IFFALSE 1401
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1375: LD_VAR 0 11
1379: PUSH
1380: LD_VAR 0 12
1384: ARRAY
1385: PPUSH
1386: LD_VAR 0 9
1390: PUSH
1391: LD_INT 1
1393: ARRAY
1394: PPUSH
1395: CALL_OW 52
1399: GO 1422
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1401: LD_VAR 0 11
1405: PUSH
1406: LD_VAR 0 12
1410: ARRAY
1411: PPUSH
1412: LD_INT 1
1414: PPUSH
1415: LD_INT 0
1417: PPUSH
1418: CALL_OW 49
// end ;
1422: GO 1362
1424: POP
1425: POP
// team := team diff filter ;
1426: LD_ADDR_VAR 0 5
1430: PUSH
1431: LD_VAR 0 5
1435: PUSH
1436: LD_VAR 0 11
1440: DIFF
1441: ST_TO_ADDR
// end ; if team then
1442: LD_VAR 0 5
1446: IFFALSE 1489
// for i in team do
1448: LD_ADDR_VAR 0 12
1452: PUSH
1453: LD_VAR 0 5
1457: PUSH
1458: FOR_IN
1459: IFFALSE 1487
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1461: LD_VAR 0 12
1465: PPUSH
1466: LD_INT 1
1468: PPUSH
1469: LD_INT 0
1471: PPUSH
1472: CALL_OW 49
// ComHold ( i ) ;
1476: LD_VAR 0 12
1480: PPUSH
1481: CALL_OW 140
// end ;
1485: GO 1458
1487: POP
1488: POP
// if fac then
1489: LD_VAR 0 9
1493: IFFALSE 1529
// if UnitsInside ( fac [ 1 ] ) then
1495: LD_VAR 0 9
1499: PUSH
1500: LD_INT 1
1502: ARRAY
1503: PPUSH
1504: CALL_OW 313
1508: IFFALSE 1529
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1510: LD_VAR 0 9
1514: PUSH
1515: LD_INT 1
1517: ARRAY
1518: PPUSH
1519: LD_INT 10
1521: PPUSH
1522: LD_INT 0
1524: PPUSH
1525: CALL_OW 486
// if lab then
1529: LD_VAR 0 8
1533: IFFALSE 1569
// if UnitsInside ( lab [ 1 ] ) then
1535: LD_VAR 0 8
1539: PUSH
1540: LD_INT 1
1542: ARRAY
1543: PPUSH
1544: CALL_OW 313
1548: IFFALSE 1569
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1550: LD_VAR 0 8
1554: PUSH
1555: LD_INT 1
1557: ARRAY
1558: PPUSH
1559: LD_INT 10
1561: PPUSH
1562: LD_INT 0
1564: PPUSH
1565: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1569: LD_ADDR_VAR 0 4
1573: PUSH
1574: LD_INT 1
1576: PPUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 1
1582: PPUSH
1583: LD_INT 2
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: LD_INT 3
1591: PPUSH
1592: LD_INT 100
1594: PPUSH
1595: CALL 4463 0 7
1599: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1600: LD_VAR 0 4
1604: PPUSH
1605: LD_INT 2
1607: PPUSH
1608: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1612: LD_VAR 0 4
1616: PPUSH
1617: LD_INT 21
1619: PPUSH
1620: LD_INT 8
1622: PPUSH
1623: LD_INT 0
1625: PPUSH
1626: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1630: LD_EXP 7
1634: PPUSH
1635: LD_VAR 0 4
1639: PPUSH
1640: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1644: LD_ADDR_VAR 0 4
1648: PUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 1
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 2
1660: PPUSH
1661: LD_INT 1
1663: PPUSH
1664: LD_INT 2
1666: PPUSH
1667: LD_INT 100
1669: PPUSH
1670: CALL 4463 0 7
1674: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1675: LD_VAR 0 4
1679: PPUSH
1680: LD_INT 2
1682: PPUSH
1683: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1687: LD_VAR 0 4
1691: PPUSH
1692: LD_INT 16
1694: PPUSH
1695: LD_INT 3
1697: PPUSH
1698: LD_INT 0
1700: PPUSH
1701: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1705: LD_EXP 8
1709: PPUSH
1710: LD_VAR 0 4
1714: PPUSH
1715: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_INT 1
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: LD_INT 2
1732: PPUSH
1733: LD_INT 2
1735: PPUSH
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 12
1741: PPUSH
1742: LD_INT 100
1744: PPUSH
1745: CALL 4463 0 7
1749: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1750: LD_VAR 0 4
1754: PPUSH
1755: LD_INT 0
1757: PPUSH
1758: LD_INT 5
1760: PPUSH
1761: CALL_OW 12
1765: PPUSH
1766: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1770: LD_VAR 0 4
1774: PPUSH
1775: LD_INT 1
1777: PPUSH
1778: LD_INT 0
1780: PPUSH
1781: CALL_OW 49
// end ;
1785: LD_VAR 0 1
1789: RET
// function PrepareBase ; var blist , i , b ; begin
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
1796: LD_INT 71
1798: PPUSH
1799: LD_INT 5
1801: PPUSH
1802: LD_INT 1
1804: PPUSH
1805: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
1809: LD_ADDR_VAR 0 2
1813: PUSH
1814: LD_STRING GammaBase
1816: PPUSH
1817: EMPTY
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if not blist and debug then
1824: LD_VAR 0 2
1828: NOT
1829: PUSH
1830: LD_EXP 1
1834: AND
1835: IFFALSE 1875
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1837: LD_ADDR_VAR 0 2
1841: PUSH
1842: LD_INT 0
1844: PUSH
1845: LD_INT 51
1847: PUSH
1848: LD_INT 10
1850: PUSH
1851: LD_INT 3
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 0
1859: PUSH
1860: LD_INT 0
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: PUSH
1872: EMPTY
1873: LIST
1874: ST_TO_ADDR
// if not blist then
1875: LD_VAR 0 2
1879: NOT
1880: IFFALSE 1884
// exit ;
1882: GO 2064
// uc_side := 1 ;
1884: LD_ADDR_OWVAR 20
1888: PUSH
1889: LD_INT 1
1891: ST_TO_ADDR
// uc_nation := 1 ;
1892: LD_ADDR_OWVAR 21
1896: PUSH
1897: LD_INT 1
1899: ST_TO_ADDR
// for i in blist do
1900: LD_ADDR_VAR 0 3
1904: PUSH
1905: LD_VAR 0 2
1909: PUSH
1910: FOR_IN
1911: IFFALSE 2062
// begin bc_type := i [ 1 ] ;
1913: LD_ADDR_OWVAR 42
1917: PUSH
1918: LD_VAR 0 3
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1927: LD_ADDR_OWVAR 43
1931: PUSH
1932: LD_VAR 0 3
1936: PUSH
1937: LD_INT 5
1939: ARRAY
1940: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1941: LD_VAR 0 3
1945: PUSH
1946: LD_INT 1
1948: ARRAY
1949: PUSH
1950: LD_INT 7
1952: PUSH
1953: LD_INT 8
1955: PUSH
1956: EMPTY
1957: LIST
1958: LIST
1959: IN
1960: IFFALSE 1990
// begin bc_kind1 := i [ 7 ] ;
1962: LD_ADDR_OWVAR 44
1966: PUSH
1967: LD_VAR 0 3
1971: PUSH
1972: LD_INT 7
1974: ARRAY
1975: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1976: LD_ADDR_OWVAR 45
1980: PUSH
1981: LD_VAR 0 3
1985: PUSH
1986: LD_INT 8
1988: ARRAY
1989: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1990: LD_ADDR_VAR 0 4
1994: PUSH
1995: LD_VAR 0 3
1999: PUSH
2000: LD_INT 2
2002: ARRAY
2003: PPUSH
2004: LD_VAR 0 3
2008: PUSH
2009: LD_INT 3
2011: ARRAY
2012: PPUSH
2013: LD_VAR 0 3
2017: PUSH
2018: LD_INT 4
2020: ARRAY
2021: PPUSH
2022: CALL_OW 47
2026: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2027: LD_VAR 0 4
2031: PPUSH
2032: CALL_OW 266
2036: PUSH
2037: LD_INT 32
2039: EQUAL
2040: IFFALSE 2060
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2042: LD_VAR 0 4
2046: PPUSH
2047: LD_VAR 0 3
2051: PUSH
2052: LD_INT 7
2054: ARRAY
2055: PPUSH
2056: CALL_OW 431
// end ; end ;
2060: GO 1910
2062: POP
2063: POP
// end ; end_of_file
2064: LD_VAR 0 1
2068: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
2069: LD_INT 0
2071: PPUSH
2072: PPUSH
2073: PPUSH
2074: PPUSH
2075: PPUSH
2076: PPUSH
2077: PPUSH
2078: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
2079: LD_INT 0
2081: PPUSH
2082: LD_INT 0
2084: PPUSH
2085: LD_INT 1
2087: PPUSH
2088: LD_INT 32976
2090: NEG
2091: PPUSH
2092: CALL_OW 330
// InGameOn ;
2096: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2100: LD_INT 33
2102: PPUSH
2103: LD_INT 11
2105: PPUSH
2106: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2110: LD_ADDR_VAR 0 2
2114: PUSH
2115: LD_INT 29
2117: PUSH
2118: LD_INT 21
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 41
2127: PUSH
2128: LD_INT 28
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 52
2137: PUSH
2138: LD_INT 26
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: LD_INT 49
2147: PUSH
2148: LD_INT 16
2150: PUSH
2151: EMPTY
2152: LIST
2153: LIST
2154: PUSH
2155: EMPTY
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: ST_TO_ADDR
// for i in points do
2161: LD_ADDR_VAR 0 3
2165: PUSH
2166: LD_VAR 0 2
2170: PUSH
2171: FOR_IN
2172: IFFALSE 2212
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2174: LD_EXP 7
2178: PUSH
2179: LD_EXP 8
2183: PUSH
2184: EMPTY
2185: LIST
2186: LIST
2187: PPUSH
2188: LD_VAR 0 3
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PPUSH
2197: LD_VAR 0 3
2201: PUSH
2202: LD_INT 2
2204: ARRAY
2205: PPUSH
2206: CALL_OW 171
2210: GO 2171
2212: POP
2213: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2214: LD_EXP 7
2218: PUSH
2219: LD_EXP 8
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: PPUSH
2228: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2232: LD_INT 35
2234: PPUSH
2235: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2239: LD_EXP 7
2243: PPUSH
2244: CALL_OW 310
2248: NOT
2249: PUSH
2250: LD_EXP 8
2254: PPUSH
2255: CALL_OW 310
2259: NOT
2260: AND
2261: IFFALSE 2232
// ComTurnUnit ( JMM , Gladstone ) ;
2263: LD_EXP 7
2267: PPUSH
2268: LD_EXP 8
2272: PPUSH
2273: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2277: LD_EXP 8
2281: PPUSH
2282: LD_EXP 7
2286: PPUSH
2287: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2291: LD_ADDR_VAR 0 4
2295: PUSH
2296: LD_INT 26
2298: PUSH
2299: LD_INT 1
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PPUSH
2306: CALL_OW 69
2310: PUSH
2311: LD_EXP 7
2315: PUSH
2316: LD_EXP 8
2320: PUSH
2321: LD_EXP 12
2325: PUSH
2326: LD_EXP 11
2330: PUSH
2331: LD_EXP 9
2335: PUSH
2336: LD_EXP 14
2340: PUSH
2341: EMPTY
2342: LIST
2343: LIST
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: DIFF
2349: ST_TO_ADDR
// if sol then
2350: LD_VAR 0 4
2354: IFFALSE 2370
// sol := sol [ 1 ] ;
2356: LD_ADDR_VAR 0 4
2360: PUSH
2361: LD_VAR 0 4
2365: PUSH
2366: LD_INT 1
2368: ARRAY
2369: ST_TO_ADDR
// team := [ ] ;
2370: LD_ADDR_VAR 0 5
2374: PUSH
2375: EMPTY
2376: ST_TO_ADDR
// if sol then
2377: LD_VAR 0 4
2381: IFFALSE 2399
// team := team ^ sol ;
2383: LD_ADDR_VAR 0 5
2387: PUSH
2388: LD_VAR 0 5
2392: PUSH
2393: LD_VAR 0 4
2397: ADD
2398: ST_TO_ADDR
// if Lisa then
2399: LD_EXP 10
2403: IFFALSE 2421
// team := team ^ Lisa ;
2405: LD_ADDR_VAR 0 5
2409: PUSH
2410: LD_VAR 0 5
2414: PUSH
2415: LD_EXP 10
2419: ADD
2420: ST_TO_ADDR
// if Donaldson then
2421: LD_EXP 13
2425: IFFALSE 2443
// team := team ^ Donaldson ;
2427: LD_ADDR_VAR 0 5
2431: PUSH
2432: LD_VAR 0 5
2436: PUSH
2437: LD_EXP 13
2441: ADD
2442: ST_TO_ADDR
// if Brown then
2443: LD_EXP 14
2447: IFFALSE 2465
// team := team ^ Brown ;
2449: LD_ADDR_VAR 0 5
2453: PUSH
2454: LD_VAR 0 5
2458: PUSH
2459: LD_EXP 14
2463: ADD
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 12
2469: IFFALSE 2487
// team := team ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 12
2485: ADD
2486: ST_TO_ADDR
// if Cyrus then
2487: LD_EXP 11
2491: IFFALSE 2509
// team := team ^ Cyrus ;
2493: LD_ADDR_VAR 0 5
2497: PUSH
2498: LD_VAR 0 5
2502: PUSH
2503: LD_EXP 11
2507: ADD
2508: ST_TO_ADDR
// if Frank then
2509: LD_EXP 9
2513: IFFALSE 2531
// team := team ^ Frank ;
2515: LD_ADDR_VAR 0 5
2519: PUSH
2520: LD_VAR 0 5
2524: PUSH
2525: LD_EXP 9
2529: ADD
2530: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 1
2538: PPUSH
2539: LD_INT 3
2541: PUSH
2542: LD_INT 54
2544: PUSH
2545: EMPTY
2546: LIST
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 21
2554: PUSH
2555: LD_INT 1
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PPUSH
2566: CALL_OW 70
2570: PUSH
2571: LD_EXP 7
2575: PUSH
2576: LD_EXP 8
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: DIFF
2585: PUSH
2586: EMPTY
2587: LIST
2588: PUSH
2589: FOR_IN
2590: IFFALSE 2610
// team := team ^ i ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_VAR 0 3
2606: ADD
2607: ST_TO_ADDR
2608: GO 2589
2610: POP
2611: POP
// if team then
2612: LD_VAR 0 5
2616: IFFALSE 2692
// begin ComExitBuilding ( team ) ;
2618: LD_VAR 0 5
2622: PPUSH
2623: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2627: LD_VAR 0 5
2631: PPUSH
2632: LD_EXP 7
2636: PPUSH
2637: CALL_OW 172
// repeat wait ( 1 ) ;
2641: LD_INT 1
2643: PPUSH
2644: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2648: LD_EXP 7
2652: PPUSH
2653: LD_VAR 0 5
2657: PPUSH
2658: LD_EXP 7
2662: PPUSH
2663: CALL_OW 74
2667: PPUSH
2668: CALL_OW 296
2672: PUSH
2673: LD_INT 6
2675: LESS
2676: IFFALSE 2641
// ComTurnUnit ( team , JMM ) ;
2678: LD_VAR 0 5
2682: PPUSH
2683: LD_EXP 7
2687: PPUSH
2688: CALL_OW 119
// end ; if Lisa then
2692: LD_EXP 10
2696: IFFALSE 2724
// begin ComTurnUnit ( JMM , Lisa ) ;
2698: LD_EXP 7
2702: PPUSH
2703: LD_EXP 10
2707: PPUSH
2708: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2712: LD_EXP 10
2716: PPUSH
2717: LD_STRING D1-Lisa-1
2719: PPUSH
2720: CALL_OW 88
// end ; if sol then
2724: LD_VAR 0 4
2728: IFFALSE 2756
// begin ComTurnUnit ( JMM , sol ) ;
2730: LD_EXP 7
2734: PPUSH
2735: LD_VAR 0 4
2739: PPUSH
2740: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_STRING D1-Sol1-1
2751: PPUSH
2752: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2756: LD_EXP 7
2760: PPUSH
2761: LD_STRING D1-JMM-1
2763: PPUSH
2764: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2768: LD_EXP 7
2772: PPUSH
2773: LD_STRING D1-JMM-1a
2775: PPUSH
2776: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2780: LD_EXP 7
2784: PPUSH
2785: LD_EXP 8
2789: PPUSH
2790: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2794: LD_VAR 0 5
2798: PPUSH
2799: LD_EXP 8
2803: PPUSH
2804: CALL_OW 119
// if Frank then
2808: LD_EXP 9
2812: IFFALSE 2840
// begin Say ( Frank , D1-Frank-1 ) ;
2814: LD_EXP 9
2818: PPUSH
2819: LD_STRING D1-Frank-1
2821: PPUSH
2822: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2826: LD_EXP 7
2830: PPUSH
2831: LD_EXP 9
2835: PPUSH
2836: CALL_OW 119
// end ; if Lisa then
2840: LD_EXP 10
2844: IFFALSE 2872
// begin ComTurnUnit ( JMM , Lisa ) ;
2846: LD_EXP 7
2850: PPUSH
2851: LD_EXP 10
2855: PPUSH
2856: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2860: LD_EXP 10
2864: PPUSH
2865: LD_STRING D1-Lisa-2
2867: PPUSH
2868: CALL_OW 88
// end ; if sol then
2872: LD_VAR 0 4
2876: IFFALSE 2904
// begin ComTurnUnit ( JMM , sol ) ;
2878: LD_EXP 7
2882: PPUSH
2883: LD_VAR 0 4
2887: PPUSH
2888: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2892: LD_VAR 0 4
2896: PPUSH
2897: LD_STRING D1-Sol1-2
2899: PPUSH
2900: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2904: LD_EXP 8
2908: PPUSH
2909: LD_STRING D1-Glad-2
2911: PPUSH
2912: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2916: LD_VAR 0 5
2920: PPUSH
2921: LD_EXP 7
2925: PPUSH
2926: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2930: LD_EXP 7
2934: PPUSH
2935: LD_STRING D1-JMM-2
2937: PPUSH
2938: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2942: LD_EXP 7
2946: PPUSH
2947: LD_EXP 8
2951: PPUSH
2952: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2956: LD_EXP 8
2960: PPUSH
2961: LD_STRING D1-Glad-3
2963: PPUSH
2964: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2968: LD_EXP 7
2972: PPUSH
2973: LD_STRING D1-JMM-3
2975: PPUSH
2976: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2980: LD_EXP 8
2984: PPUSH
2985: LD_STRING D1-Glad-4
2987: PPUSH
2988: CALL_OW 88
// if Frank then
2992: LD_EXP 9
2996: IFFALSE 3024
// begin ComTurnUnit ( JMM , Frank ) ;
2998: LD_EXP 7
3002: PPUSH
3003: LD_EXP 9
3007: PPUSH
3008: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
3012: LD_EXP 9
3016: PPUSH
3017: LD_STRING D1-Frank-4
3019: PPUSH
3020: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3024: LD_EXP 7
3028: PPUSH
3029: LD_EXP 8
3033: PPUSH
3034: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
3038: LD_EXP 7
3042: PPUSH
3043: LD_STRING D1-JMM-4
3045: PPUSH
3046: CALL_OW 88
// if Lisa then
3050: LD_EXP 10
3054: IFFALSE 3121
// begin Say ( Lisa , D1-Lisa-4 ) ;
3056: LD_EXP 10
3060: PPUSH
3061: LD_STRING D1-Lisa-4
3063: PPUSH
3064: CALL_OW 88
// if Frank then
3068: LD_EXP 9
3072: IFFALSE 3121
// begin ComTurnUnit ( Frank , Lisa ) ;
3074: LD_EXP 9
3078: PPUSH
3079: LD_EXP 10
3083: PPUSH
3084: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3088: LD_EXP 9
3092: PPUSH
3093: LD_STRING D1-Frank-5
3095: PPUSH
3096: CALL_OW 88
// Wait ( 3 ) ;
3100: LD_INT 3
3102: PPUSH
3103: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3107: LD_EXP 9
3111: PPUSH
3112: LD_EXP 7
3116: PPUSH
3117: CALL_OW 179
// end ; end ; if sol then
3121: LD_VAR 0 4
3125: IFFALSE 3139
// Say ( sol , D1-Sol1-5 ) ;
3127: LD_VAR 0 4
3131: PPUSH
3132: LD_STRING D1-Sol1-5
3134: PPUSH
3135: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3139: LD_EXP 7
3143: PPUSH
3144: LD_STRING D1-JMM-5
3146: PPUSH
3147: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3151: LD_EXP 8
3155: PPUSH
3156: LD_STRING D1-Glad-5
3158: PPUSH
3159: CALL_OW 88
// if Frank then
3163: LD_EXP 9
3167: IFFALSE 3181
// Say ( Frank , D1-Frank-6 ) ;
3169: LD_EXP 9
3173: PPUSH
3174: LD_STRING D1-Frank-6
3176: PPUSH
3177: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3181: LD_EXP 7
3185: PPUSH
3186: LD_STRING D1-JMM-6
3188: PPUSH
3189: CALL_OW 88
// if Brown and Donaldson then
3193: LD_EXP 14
3197: PUSH
3198: LD_EXP 13
3202: AND
3203: IFFALSE 3252
// case Query ( QCommander ) of 1 :
3205: LD_STRING QCommander
3207: PPUSH
3208: CALL_OW 97
3212: PUSH
3213: LD_INT 1
3215: DOUBLE
3216: EQUAL
3217: IFTRUE 3221
3219: GO 3232
3221: POP
// donaldson_commander := true ; 2 :
3222: LD_ADDR_EXP 4
3226: PUSH
3227: LD_INT 1
3229: ST_TO_ADDR
3230: GO 3252
3232: LD_INT 2
3234: DOUBLE
3235: EQUAL
3236: IFTRUE 3240
3238: GO 3251
3240: POP
// brown_commander := true ; end ;
3241: LD_ADDR_EXP 5
3245: PUSH
3246: LD_INT 1
3248: ST_TO_ADDR
3249: GO 3252
3251: POP
// if not Brown and Donaldson then
3252: LD_EXP 14
3256: NOT
3257: PUSH
3258: LD_EXP 13
3262: AND
3263: IFFALSE 3273
// donaldson_commander := true ;
3265: LD_ADDR_EXP 4
3269: PUSH
3270: LD_INT 1
3272: ST_TO_ADDR
// if Brown and not Donaldson then
3273: LD_EXP 14
3277: PUSH
3278: LD_EXP 13
3282: NOT
3283: AND
3284: IFFALSE 3294
// brown_commander := true ;
3286: LD_ADDR_EXP 5
3290: PUSH
3291: LD_INT 1
3293: ST_TO_ADDR
// if donaldson_commander then
3294: LD_EXP 4
3298: IFFALSE 3445
// begin ComTurnUnit ( JMM , Donaldson ) ;
3300: LD_EXP 7
3304: PPUSH
3305: LD_EXP 13
3309: PPUSH
3310: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3314: LD_EXP 7
3318: PPUSH
3319: LD_STRING D1a-JMM-1
3321: PPUSH
3322: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3326: LD_EXP 13
3330: PPUSH
3331: LD_EXP 7
3335: PPUSH
3336: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3340: LD_EXP 13
3344: PPUSH
3345: LD_EXP 7
3349: PPUSH
3350: CALL_OW 179
// Wait ( 3 ) ;
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3361: LD_EXP 13
3365: PPUSH
3366: LD_STRING D1a-Don-1
3368: PPUSH
3369: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3373: LD_EXP 7
3377: PPUSH
3378: LD_STRING D1b-JMM-2
3380: PPUSH
3381: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3385: LD_EXP 13
3389: PPUSH
3390: LD_STRING D1a-Don-2
3392: PPUSH
3393: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3397: LD_EXP 13
3401: PPUSH
3402: LD_INT 30
3404: PUSH
3405: LD_INT 0
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PPUSH
3412: CALL_OW 69
3416: PUSH
3417: LD_INT 1
3419: ARRAY
3420: PPUSH
3421: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3425: LD_INT 1
3427: PPUSH
3428: LD_STRING GammaCommander
3430: PPUSH
3431: CALL_OW 39
// commander := Donaldson ;
3435: LD_ADDR_VAR 0 7
3439: PUSH
3440: LD_EXP 13
3444: ST_TO_ADDR
// end ; if brown_commander then
3445: LD_EXP 5
3449: IFFALSE 3596
// begin ComTurnUnit ( JMM , Brown ) ;
3451: LD_EXP 7
3455: PPUSH
3456: LD_EXP 14
3460: PPUSH
3461: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3465: LD_EXP 7
3469: PPUSH
3470: LD_STRING D1b-JMM-1
3472: PPUSH
3473: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3477: LD_EXP 14
3481: PPUSH
3482: LD_EXP 7
3486: PPUSH
3487: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3491: LD_EXP 14
3495: PPUSH
3496: LD_EXP 7
3500: PPUSH
3501: CALL_OW 179
// Wait ( 3 ) ;
3505: LD_INT 3
3507: PPUSH
3508: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3512: LD_EXP 14
3516: PPUSH
3517: LD_STRING D1b-Brown-1
3519: PPUSH
3520: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3524: LD_EXP 7
3528: PPUSH
3529: LD_STRING D1a-JMM-2
3531: PPUSH
3532: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3536: LD_EXP 14
3540: PPUSH
3541: LD_STRING D1b-Brown-2
3543: PPUSH
3544: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3548: LD_EXP 14
3552: PPUSH
3553: LD_INT 30
3555: PUSH
3556: LD_INT 0
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: PPUSH
3563: CALL_OW 69
3567: PUSH
3568: LD_INT 1
3570: ARRAY
3571: PPUSH
3572: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3576: LD_INT 2
3578: PPUSH
3579: LD_STRING GammaCommander
3581: PPUSH
3582: CALL_OW 39
// commander := Brown ;
3586: LD_ADDR_VAR 0 7
3590: PUSH
3591: LD_EXP 14
3595: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3596: LD_EXP 7
3600: PPUSH
3601: LD_EXP 8
3605: PPUSH
3606: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3610: LD_EXP 4
3614: NOT
3615: PUSH
3616: LD_EXP 5
3620: NOT
3621: AND
3622: IFFALSE 3646
// begin Say ( JMM , D1c-JMM-1 ) ;
3624: LD_EXP 7
3628: PPUSH
3629: LD_STRING D1c-JMM-1
3631: PPUSH
3632: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3636: LD_INT 3
3638: PPUSH
3639: LD_STRING GammaCommander
3641: PPUSH
3642: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3646: LD_EXP 7
3650: PPUSH
3651: LD_STRING D1d-JMM-1
3653: PPUSH
3654: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3658: LD_ADDR_VAR 0 6
3662: PUSH
3663: LD_INT 21
3665: PUSH
3666: LD_INT 1
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: PPUSH
3673: CALL_OW 69
3677: PUSH
3678: LD_EXP 7
3682: PUSH
3683: LD_EXP 8
3687: PUSH
3688: LD_VAR 0 7
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: LIST
3697: DIFF
3698: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3699: LD_ADDR_EXP 6
3703: PUSH
3704: LD_STRING 1
3706: PPUSH
3707: LD_INT 5
3709: PPUSH
3710: LD_INT 5
3712: PPUSH
3713: LD_INT -5
3715: PUSH
3716: LD_EXP 7
3720: PUSH
3721: LD_INT -6
3723: PUSH
3724: LD_EXP 8
3728: PUSH
3729: LD_INT -2
3731: PUSH
3732: LD_INT -3
3734: PUSH
3735: LD_INT -5
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_VAR 0 6
3751: ADD
3752: PUSH
3753: LD_INT -6
3755: PUSH
3756: LD_INT -4
3758: PUSH
3759: LD_VAR 0 7
3763: PUSH
3764: EMPTY
3765: LIST
3766: LIST
3767: LIST
3768: ADD
3769: PPUSH
3770: LD_INT 1
3772: PUSH
3773: LD_INT 3
3775: PUSH
3776: LD_INT 2
3778: PUSH
3779: LD_INT 1
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PUSH
3786: LD_INT 4
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 42
3799: ST_TO_ADDR
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3800: LD_EXP 7
3804: PPUSH
3805: LD_EXP 2
3809: PUSH
3810: LD_STRING JMM
3812: STR
3813: PPUSH
3814: CALL_OW 38
// if Lisa in save_group then
3818: LD_EXP 10
3822: PUSH
3823: LD_EXP 6
3827: IN
3828: IFFALSE 3858
// begin SaveVariable ( true , LisaInDelta ) ;
3830: LD_INT 1
3832: PPUSH
3833: LD_STRING LisaInDelta
3835: PPUSH
3836: CALL_OW 39
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3840: LD_EXP 10
3844: PPUSH
3845: LD_EXP 2
3849: PUSH
3850: LD_STRING Lisa
3852: STR
3853: PPUSH
3854: CALL_OW 38
// end ; if Bobby in save_group then
3858: LD_EXP 12
3862: PUSH
3863: LD_EXP 6
3867: IN
3868: IFFALSE 3898
// begin SaveVariable ( true , BobbyInDelta ) ;
3870: LD_INT 1
3872: PPUSH
3873: LD_STRING BobbyInDelta
3875: PPUSH
3876: CALL_OW 39
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3880: LD_EXP 12
3884: PPUSH
3885: LD_EXP 2
3889: PUSH
3890: LD_STRING Bobby
3892: STR
3893: PPUSH
3894: CALL_OW 38
// end ; if Cyrus in save_group then
3898: LD_EXP 11
3902: PUSH
3903: LD_EXP 6
3907: IN
3908: IFFALSE 3938
// begin SaveVariable ( true , CyrusInDelta ) ;
3910: LD_INT 1
3912: PPUSH
3913: LD_STRING CyrusInDelta
3915: PPUSH
3916: CALL_OW 39
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3920: LD_EXP 11
3924: PPUSH
3925: LD_EXP 2
3929: PUSH
3930: LD_STRING Cyrus
3932: STR
3933: PPUSH
3934: CALL_OW 38
// end ; if Frank in save_group then
3938: LD_EXP 9
3942: PUSH
3943: LD_EXP 6
3947: IN
3948: IFFALSE 3978
// begin SaveVariable ( true , FrankInDelta ) ;
3950: LD_INT 1
3952: PPUSH
3953: LD_STRING FrankInDelta
3955: PPUSH
3956: CALL_OW 39
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
3960: LD_EXP 9
3964: PPUSH
3965: LD_EXP 2
3969: PUSH
3970: LD_STRING Frank
3972: STR
3973: PPUSH
3974: CALL_OW 38
// end ; if Brown in save_group then
3978: LD_EXP 14
3982: PUSH
3983: LD_EXP 6
3987: IN
3988: IFFALSE 4018
// begin SaveVariable ( true , BrownInDelta ) ;
3990: LD_INT 1
3992: PPUSH
3993: LD_STRING BrownInDelta
3995: PPUSH
3996: CALL_OW 39
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
4000: LD_EXP 14
4004: PPUSH
4005: LD_EXP 2
4009: PUSH
4010: LD_STRING Brown
4012: STR
4013: PPUSH
4014: CALL_OW 38
// end ; if Donaldson in save_group then
4018: LD_EXP 13
4022: PUSH
4023: LD_EXP 6
4027: IN
4028: IFFALSE 4058
// begin SaveVariable ( true , DonaldsonInDelta ) ;
4030: LD_INT 1
4032: PPUSH
4033: LD_STRING DonaldsonInDelta
4035: PPUSH
4036: CALL_OW 39
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4040: LD_EXP 13
4044: PPUSH
4045: LD_EXP 2
4049: PUSH
4050: LD_STRING Donaldson
4052: STR
4053: PPUSH
4054: CALL_OW 38
// end ; SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] ^ save_group , othersGamma ) ;
4058: LD_VAR 0 6
4062: PUSH
4063: LD_EXP 7
4067: PUSH
4068: LD_EXP 8
4072: PUSH
4073: LD_EXP 10
4077: PUSH
4078: LD_EXP 11
4082: PUSH
4083: LD_EXP 12
4087: PUSH
4088: LD_EXP 9
4092: PUSH
4093: LD_EXP 13
4097: PUSH
4098: LD_EXP 14
4102: PUSH
4103: LD_INT 0
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: LIST
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: LD_EXP 6
4121: ADD
4122: DIFF
4123: PPUSH
4124: LD_STRING othersGamma
4126: PPUSH
4127: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
4131: LD_EXP 6
4135: PUSH
4136: LD_EXP 7
4140: PUSH
4141: LD_EXP 8
4145: PUSH
4146: LD_EXP 10
4150: PUSH
4151: LD_EXP 11
4155: PUSH
4156: LD_EXP 12
4160: PUSH
4161: LD_EXP 9
4165: PUSH
4166: LD_EXP 13
4170: PUSH
4171: LD_EXP 14
4175: PUSH
4176: LD_INT 0
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: DIFF
4190: PPUSH
4191: LD_STRING othersDelta
4193: PPUSH
4194: CALL_OW 38
// Wait ( 3 ) ;
4198: LD_INT 3
4200: PPUSH
4201: CALL_OW 67
// for i in save_group do
4205: LD_ADDR_VAR 0 3
4209: PUSH
4210: LD_EXP 6
4214: PUSH
4215: FOR_IN
4216: IFFALSE 4247
// begin if IsInUnit ( i ) then
4218: LD_VAR 0 3
4222: PPUSH
4223: CALL_OW 310
4227: IFFALSE 4238
// ComExitBuilding ( i ) ;
4229: LD_VAR 0 3
4233: PPUSH
4234: CALL_OW 122
// Wait ( 3 ) ;
4238: LD_INT 3
4240: PPUSH
4241: CALL_OW 67
// end ;
4245: GO 4215
4247: POP
4248: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4249: LD_ADDR_EXP 6
4253: PUSH
4254: LD_EXP 6
4258: PPUSH
4259: LD_INT 1
4261: PPUSH
4262: LD_EXP 7
4266: PPUSH
4267: CALL_OW 2
4271: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4272: LD_ADDR_EXP 6
4276: PUSH
4277: LD_EXP 6
4281: PPUSH
4282: LD_INT 2
4284: PPUSH
4285: LD_EXP 8
4289: PPUSH
4290: CALL_OW 2
4294: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4295: LD_ADDR_VAR 0 8
4299: PUSH
4300: LD_INT 21
4302: PUSH
4303: LD_INT 2
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PPUSH
4310: CALL_OW 69
4314: ST_TO_ADDR
// for i = 1 to filter do
4315: LD_ADDR_VAR 0 3
4319: PUSH
4320: DOUBLE
4321: LD_INT 1
4323: DEC
4324: ST_TO_ADDR
4325: LD_VAR 0 8
4329: PUSH
4330: FOR_TO
4331: IFFALSE 4361
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4333: LD_EXP 6
4337: PUSH
4338: LD_VAR 0 3
4342: ARRAY
4343: PPUSH
4344: LD_VAR 0 8
4348: PUSH
4349: LD_VAR 0 3
4353: ARRAY
4354: PPUSH
4355: CALL_OW 120
4359: GO 4330
4361: POP
4362: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4363: LD_EXP 6
4367: PPUSH
4368: LD_INT 87
4370: PPUSH
4371: LD_INT 27
4373: PPUSH
4374: CALL_OW 171
// Wait ( 0 0$05 ) ;
4378: LD_INT 175
4380: PPUSH
4381: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4385: LD_INT 1
4387: PPUSH
4388: LD_STRING %_cont
4390: PPUSH
4391: CALL_OW 340
// end ; end_of_file
4395: LD_VAR 0 1
4399: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4400: LD_INT 0
4402: PPUSH
4403: PPUSH
// if exist_mode then
4404: LD_VAR 0 2
4408: IFFALSE 4433
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4410: LD_ADDR_VAR 0 4
4414: PUSH
4415: LD_EXP 3
4419: PUSH
4420: LD_VAR 0 1
4424: STR
4425: PPUSH
4426: CALL_OW 34
4430: ST_TO_ADDR
4431: GO 4448
// unit := NewCharacter ( ident ) ;
4433: LD_ADDR_VAR 0 4
4437: PUSH
4438: LD_VAR 0 1
4442: PPUSH
4443: CALL_OW 25
4447: ST_TO_ADDR
// result := unit ;
4448: LD_ADDR_VAR 0 3
4452: PUSH
4453: LD_VAR 0 4
4457: ST_TO_ADDR
// end ;
4458: LD_VAR 0 3
4462: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4463: LD_INT 0
4465: PPUSH
// uc_side := side ;
4466: LD_ADDR_OWVAR 20
4470: PUSH
4471: LD_VAR 0 1
4475: ST_TO_ADDR
// uc_nation := nation ;
4476: LD_ADDR_OWVAR 21
4480: PUSH
4481: LD_VAR 0 2
4485: ST_TO_ADDR
// vc_chassis := chassis ;
4486: LD_ADDR_OWVAR 37
4490: PUSH
4491: LD_VAR 0 3
4495: ST_TO_ADDR
// vc_engine := engine ;
4496: LD_ADDR_OWVAR 39
4500: PUSH
4501: LD_VAR 0 4
4505: ST_TO_ADDR
// vc_control := control ;
4506: LD_ADDR_OWVAR 38
4510: PUSH
4511: LD_VAR 0 5
4515: ST_TO_ADDR
// vc_weapon := weapon ;
4516: LD_ADDR_OWVAR 40
4520: PUSH
4521: LD_VAR 0 6
4525: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4526: LD_ADDR_OWVAR 41
4530: PUSH
4531: LD_VAR 0 7
4535: ST_TO_ADDR
// result := CreateVehicle ;
4536: LD_ADDR_VAR 0 8
4540: PUSH
4541: CALL_OW 45
4545: ST_TO_ADDR
// end ;
4546: LD_VAR 0 8
4550: RET
// export function SayX ( units , ident ) ; var i ; begin
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
// result := false ;
4555: LD_ADDR_VAR 0 3
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// if not units then
4563: LD_VAR 0 1
4567: NOT
4568: IFFALSE 4572
// exit ;
4570: GO 4626
// for i in units do
4572: LD_ADDR_VAR 0 4
4576: PUSH
4577: LD_VAR 0 1
4581: PUSH
4582: FOR_IN
4583: IFFALSE 4624
// if IsOk ( i ) then
4585: LD_VAR 0 4
4589: PPUSH
4590: CALL_OW 302
4594: IFFALSE 4622
// begin Say ( i , ident ) ;
4596: LD_VAR 0 4
4600: PPUSH
4601: LD_VAR 0 2
4605: PPUSH
4606: CALL_OW 88
// result := i ;
4610: LD_ADDR_VAR 0 3
4614: PUSH
4615: LD_VAR 0 4
4619: ST_TO_ADDR
// break ;
4620: GO 4624
// end ;
4622: GO 4582
4624: POP
4625: POP
// end ;
4626: LD_VAR 0 3
4630: RET
