// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 1980 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
// PrepareBase ;
 118: CALL 1710 0 0
// uc_side := 1 ;
 122: LD_ADDR_OWVAR 20
 126: PUSH
 127: LD_INT 1
 129: ST_TO_ADDR
// uc_nation := 1 ;
 130: LD_ADDR_OWVAR 21
 134: PUSH
 135: LD_INT 1
 137: ST_TO_ADDR
// team := [ ] ;
 138: LD_ADDR_VAR 0 5
 142: PUSH
 143: EMPTY
 144: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 145: LD_ADDR_EXP 7
 149: PUSH
 150: LD_STRING JMM
 152: PPUSH
 153: LD_EXP 1
 157: NOT
 158: PPUSH
 159: CALL 4128 0 2
 163: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 164: LD_ADDR_EXP 8
 168: PUSH
 169: LD_STRING Gladstone
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: CALL 4128 0 2
 179: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 180: LD_ADDR_EXP 9
 184: PUSH
 185: LD_STRING Frank
 187: PPUSH
 188: LD_EXP 1
 192: NOT
 193: PPUSH
 194: CALL 4128 0 2
 198: ST_TO_ADDR
// if Frank then
 199: LD_EXP 9
 203: IFFALSE 221
// team := team ^ Frank ;
 205: LD_ADDR_VAR 0 5
 209: PUSH
 210: LD_VAR 0 5
 214: PUSH
 215: LD_EXP 9
 219: ADD
 220: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 221: LD_ADDR_EXP 10
 225: PUSH
 226: LD_STRING Lisa
 228: PPUSH
 229: LD_EXP 1
 233: NOT
 234: PPUSH
 235: CALL 4128 0 2
 239: ST_TO_ADDR
// if Lisa then
 240: LD_EXP 10
 244: IFFALSE 262
// team := team ^ Lisa ;
 246: LD_ADDR_VAR 0 5
 250: PUSH
 251: LD_VAR 0 5
 255: PUSH
 256: LD_EXP 10
 260: ADD
 261: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 262: LD_ADDR_EXP 13
 266: PUSH
 267: LD_STRING Donaldson
 269: PPUSH
 270: LD_EXP 1
 274: NOT
 275: PPUSH
 276: CALL 4128 0 2
 280: ST_TO_ADDR
// if Donaldson then
 281: LD_EXP 13
 285: IFFALSE 303
// team := team ^ Donaldson ;
 287: LD_ADDR_VAR 0 5
 291: PUSH
 292: LD_VAR 0 5
 296: PUSH
 297: LD_EXP 13
 301: ADD
 302: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 303: LD_ADDR_EXP 14
 307: PUSH
 308: LD_STRING Brown
 310: PPUSH
 311: LD_EXP 1
 315: NOT
 316: PPUSH
 317: CALL 4128 0 2
 321: ST_TO_ADDR
// if Brown then
 322: LD_EXP 14
 326: IFFALSE 344
// team := team ^ Brown ;
 328: LD_ADDR_VAR 0 5
 332: PUSH
 333: LD_VAR 0 5
 337: PUSH
 338: LD_EXP 14
 342: ADD
 343: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_STRING 04_other_survivors
 351: PPUSH
 352: CALL_OW 31
 356: ST_TO_ADDR
// if not Lisa then
 357: LD_EXP 10
 361: NOT
 362: IFFALSE 473
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 364: LD_ADDR_EXP 11
 368: PUSH
 369: LD_STRING Cyrus
 371: PPUSH
 372: LD_EXP 1
 376: NOT
 377: PPUSH
 378: CALL 4128 0 2
 382: ST_TO_ADDR
// if Cyrus then
 383: LD_EXP 11
 387: IFFALSE 405
// team := team ^ Cyrus ;
 389: LD_ADDR_VAR 0 5
 393: PUSH
 394: LD_VAR 0 5
 398: PUSH
 399: LD_EXP 11
 403: ADD
 404: ST_TO_ADDR
// if not Cyrus then
 405: LD_EXP 11
 409: NOT
 410: IFFALSE 473
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 412: LD_ADDR_EXP 12
 416: PUSH
 417: LD_STRING Bobby
 419: PPUSH
 420: LD_EXP 1
 424: NOT
 425: PPUSH
 426: CALL 4128 0 2
 430: ST_TO_ADDR
// if Bobby then
 431: LD_EXP 12
 435: IFFALSE 453
// team := team ^ Bobby ;
 437: LD_ADDR_VAR 0 5
 441: PUSH
 442: LD_VAR 0 5
 446: PUSH
 447: LD_EXP 12
 451: ADD
 452: ST_TO_ADDR
// if not Bobby then
 453: LD_EXP 12
 457: NOT
 458: IFFALSE 473
// begin others3 := CreateCharacterSet ( 03_others ) ;
 460: LD_ADDR_VAR 0 2
 464: PUSH
 465: LD_STRING 03_others
 467: PPUSH
 468: CALL_OW 31
 472: ST_TO_ADDR
// end ; end ; end ; if others4 then
 473: LD_VAR 0 3
 477: IFFALSE 495
// team := team ^ others4 ;
 479: LD_ADDR_VAR 0 5
 483: PUSH
 484: LD_VAR 0 5
 488: PUSH
 489: LD_VAR 0 3
 493: ADD
 494: ST_TO_ADDR
// if others3 then
 495: LD_VAR 0 2
 499: IFFALSE 517
// team := team ^ others3 ;
 501: LD_ADDR_VAR 0 5
 505: PUSH
 506: LD_VAR 0 5
 510: PUSH
 511: LD_VAR 0 2
 515: ADD
 516: ST_TO_ADDR
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 517: LD_ADDR_VAR 0 6
 521: PUSH
 522: LD_INT 30
 524: PUSH
 525: LD_INT 0
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: PPUSH
 532: CALL_OW 69
 536: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 537: LD_ADDR_VAR 0 7
 541: PUSH
 542: LD_INT 30
 544: PUSH
 545: LD_INT 4
 547: PUSH
 548: EMPTY
 549: LIST
 550: LIST
 551: PPUSH
 552: CALL_OW 69
 556: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 557: LD_ADDR_VAR 0 8
 561: PUSH
 562: LD_INT 2
 564: PUSH
 565: LD_INT 30
 567: PUSH
 568: LD_INT 7
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: PUSH
 575: LD_INT 30
 577: PUSH
 578: LD_INT 6
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PPUSH
 590: CALL_OW 69
 594: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 595: LD_ADDR_VAR 0 9
 599: PUSH
 600: LD_INT 30
 602: PUSH
 603: LD_INT 3
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL_OW 69
 614: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 615: LD_ADDR_VAR 0 10
 619: PUSH
 620: LD_INT 2
 622: PUSH
 623: LD_INT 30
 625: PUSH
 626: LD_INT 32
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: PUSH
 633: LD_INT 30
 635: PUSH
 636: LD_INT 31
 638: PUSH
 639: EMPTY
 640: LIST
 641: LIST
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: PPUSH
 648: CALL_OW 69
 652: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 653: LD_VAR 0 6
 657: PPUSH
 658: LD_STRING Gamma
 660: PPUSH
 661: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 665: LD_VAR 0 6
 669: PPUSH
 670: CALL_OW 274
 674: PPUSH
 675: LD_INT 2
 677: PPUSH
 678: LD_INT 10000
 680: PPUSH
 681: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 685: LD_VAR 0 6
 689: PPUSH
 690: CALL_OW 274
 694: PPUSH
 695: LD_INT 1
 697: PPUSH
 698: LD_INT 10000
 700: PPUSH
 701: CALL_OW 277
// if dep then
 705: LD_VAR 0 6
 709: IFFALSE 791
// begin if Brown then
 711: LD_EXP 14
 715: IFFALSE 751
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 717: LD_EXP 14
 721: PPUSH
 722: LD_VAR 0 6
 726: PUSH
 727: LD_INT 1
 729: ARRAY
 730: PPUSH
 731: CALL_OW 52
// team := team diff Brown ;
 735: LD_ADDR_VAR 0 5
 739: PUSH
 740: LD_VAR 0 5
 744: PUSH
 745: LD_EXP 14
 749: DIFF
 750: ST_TO_ADDR
// end ; if Donaldson then
 751: LD_EXP 13
 755: IFFALSE 791
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 757: LD_EXP 13
 761: PPUSH
 762: LD_VAR 0 6
 766: PUSH
 767: LD_INT 1
 769: ARRAY
 770: PPUSH
 771: CALL_OW 52
// team := team diff Donaldson ;
 775: LD_ADDR_VAR 0 5
 779: PUSH
 780: LD_VAR 0 5
 784: PUSH
 785: LD_EXP 13
 789: DIFF
 790: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 791: LD_VAR 0 10
 795: PUSH
 796: LD_VAR 0 5
 800: PPUSH
 801: LD_INT 25
 803: PUSH
 804: LD_INT 1
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PPUSH
 811: CALL_OW 72
 815: AND
 816: IFFALSE 921
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 818: LD_ADDR_VAR 0 11
 822: PUSH
 823: LD_VAR 0 5
 827: PPUSH
 828: LD_INT 25
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: EMPTY
 835: LIST
 836: LIST
 837: PPUSH
 838: CALL_OW 72
 842: ST_TO_ADDR
// for i in bun do
 843: LD_ADDR_VAR 0 12
 847: PUSH
 848: LD_VAR 0 10
 852: PUSH
 853: FOR_IN
 854: IFFALSE 903
// begin if not filter then
 856: LD_VAR 0 11
 860: NOT
 861: IFFALSE 865
// break ;
 863: GO 903
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 865: LD_VAR 0 11
 869: PUSH
 870: LD_INT 1
 872: ARRAY
 873: PPUSH
 874: LD_VAR 0 12
 878: PPUSH
 879: CALL_OW 52
// filter := Delete ( filter , 1 ) ;
 883: LD_ADDR_VAR 0 11
 887: PUSH
 888: LD_VAR 0 11
 892: PPUSH
 893: LD_INT 1
 895: PPUSH
 896: CALL_OW 3
 900: ST_TO_ADDR
// end ;
 901: GO 853
 903: POP
 904: POP
// team := team diff filter ;
 905: LD_ADDR_VAR 0 5
 909: PUSH
 910: LD_VAR 0 5
 914: PUSH
 915: LD_VAR 0 11
 919: DIFF
 920: ST_TO_ADDR
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
 921: LD_VAR 0 7
 925: PUSH
 926: LD_VAR 0 5
 930: PPUSH
 931: LD_INT 25
 933: PUSH
 934: LD_INT 1
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: PPUSH
 941: CALL_OW 72
 945: AND
 946: IFFALSE 1068
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 948: LD_ADDR_VAR 0 11
 952: PUSH
 953: LD_VAR 0 5
 957: PPUSH
 958: LD_INT 25
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: PPUSH
 968: CALL_OW 72
 972: ST_TO_ADDR
// for i = 1 to filter do
 973: LD_ADDR_VAR 0 12
 977: PUSH
 978: DOUBLE
 979: LD_INT 1
 981: DEC
 982: ST_TO_ADDR
 983: LD_VAR 0 11
 987: PUSH
 988: FOR_TO
 989: IFFALSE 1050
// begin if ( i <= 6 ) then
 991: LD_VAR 0 12
 995: PUSH
 996: LD_INT 6
 998: LESSEQUAL
 999: IFFALSE 1027
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1001: LD_VAR 0 11
1005: PUSH
1006: LD_VAR 0 12
1010: ARRAY
1011: PPUSH
1012: LD_VAR 0 7
1016: PUSH
1017: LD_INT 1
1019: ARRAY
1020: PPUSH
1021: CALL_OW 52
1025: GO 1048
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1027: LD_VAR 0 11
1031: PUSH
1032: LD_VAR 0 12
1036: ARRAY
1037: PPUSH
1038: LD_INT 1
1040: PPUSH
1041: LD_INT 0
1043: PPUSH
1044: CALL_OW 49
// end ;
1048: GO 988
1050: POP
1051: POP
// team := team diff filter ;
1052: LD_ADDR_VAR 0 5
1056: PUSH
1057: LD_VAR 0 5
1061: PUSH
1062: LD_VAR 0 11
1066: DIFF
1067: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1068: LD_VAR 0 8
1072: PUSH
1073: LD_VAR 0 5
1077: PPUSH
1078: LD_INT 25
1080: PUSH
1081: LD_INT 4
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: PPUSH
1088: CALL_OW 72
1092: AND
1093: IFFALSE 1215
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1095: LD_ADDR_VAR 0 11
1099: PUSH
1100: LD_VAR 0 5
1104: PPUSH
1105: LD_INT 25
1107: PUSH
1108: LD_INT 4
1110: PUSH
1111: EMPTY
1112: LIST
1113: LIST
1114: PPUSH
1115: CALL_OW 72
1119: ST_TO_ADDR
// for i = 1 to filter do
1120: LD_ADDR_VAR 0 12
1124: PUSH
1125: DOUBLE
1126: LD_INT 1
1128: DEC
1129: ST_TO_ADDR
1130: LD_VAR 0 11
1134: PUSH
1135: FOR_TO
1136: IFFALSE 1197
// begin if ( i <= 6 ) then
1138: LD_VAR 0 12
1142: PUSH
1143: LD_INT 6
1145: LESSEQUAL
1146: IFFALSE 1174
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1148: LD_VAR 0 11
1152: PUSH
1153: LD_VAR 0 12
1157: ARRAY
1158: PPUSH
1159: LD_VAR 0 8
1163: PUSH
1164: LD_INT 1
1166: ARRAY
1167: PPUSH
1168: CALL_OW 52
1172: GO 1195
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1174: LD_VAR 0 11
1178: PUSH
1179: LD_VAR 0 12
1183: ARRAY
1184: PPUSH
1185: LD_INT 1
1187: PPUSH
1188: LD_INT 0
1190: PPUSH
1191: CALL_OW 49
// end ;
1195: GO 1135
1197: POP
1198: POP
// team := team diff filter ;
1199: LD_ADDR_VAR 0 5
1203: PUSH
1204: LD_VAR 0 5
1208: PUSH
1209: LD_VAR 0 11
1213: DIFF
1214: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1215: LD_VAR 0 9
1219: PUSH
1220: LD_VAR 0 5
1224: PPUSH
1225: LD_INT 25
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: PPUSH
1235: CALL_OW 72
1239: AND
1240: IFFALSE 1362
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1242: LD_ADDR_VAR 0 11
1246: PUSH
1247: LD_VAR 0 5
1251: PPUSH
1252: LD_INT 25
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: PPUSH
1262: CALL_OW 72
1266: ST_TO_ADDR
// for i = 1 to filter do
1267: LD_ADDR_VAR 0 12
1271: PUSH
1272: DOUBLE
1273: LD_INT 1
1275: DEC
1276: ST_TO_ADDR
1277: LD_VAR 0 11
1281: PUSH
1282: FOR_TO
1283: IFFALSE 1344
// begin if ( i <= 6 ) then
1285: LD_VAR 0 12
1289: PUSH
1290: LD_INT 6
1292: LESSEQUAL
1293: IFFALSE 1321
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1295: LD_VAR 0 11
1299: PUSH
1300: LD_VAR 0 12
1304: ARRAY
1305: PPUSH
1306: LD_VAR 0 9
1310: PUSH
1311: LD_INT 1
1313: ARRAY
1314: PPUSH
1315: CALL_OW 52
1319: GO 1342
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1321: LD_VAR 0 11
1325: PUSH
1326: LD_VAR 0 12
1330: ARRAY
1331: PPUSH
1332: LD_INT 1
1334: PPUSH
1335: LD_INT 0
1337: PPUSH
1338: CALL_OW 49
// end ;
1342: GO 1282
1344: POP
1345: POP
// team := team diff filter ;
1346: LD_ADDR_VAR 0 5
1350: PUSH
1351: LD_VAR 0 5
1355: PUSH
1356: LD_VAR 0 11
1360: DIFF
1361: ST_TO_ADDR
// end ; if team then
1362: LD_VAR 0 5
1366: IFFALSE 1409
// for i in team do
1368: LD_ADDR_VAR 0 12
1372: PUSH
1373: LD_VAR 0 5
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1407
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1381: LD_VAR 0 12
1385: PPUSH
1386: LD_INT 1
1388: PPUSH
1389: LD_INT 0
1391: PPUSH
1392: CALL_OW 49
// ComHold ( i ) ;
1396: LD_VAR 0 12
1400: PPUSH
1401: CALL_OW 140
// end ;
1405: GO 1378
1407: POP
1408: POP
// if fac then
1409: LD_VAR 0 9
1413: IFFALSE 1449
// if UnitsInside ( fac [ 1 ] ) then
1415: LD_VAR 0 9
1419: PUSH
1420: LD_INT 1
1422: ARRAY
1423: PPUSH
1424: CALL_OW 313
1428: IFFALSE 1449
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1430: LD_VAR 0 9
1434: PUSH
1435: LD_INT 1
1437: ARRAY
1438: PPUSH
1439: LD_INT 10
1441: PPUSH
1442: LD_INT 0
1444: PPUSH
1445: CALL_OW 486
// if lab then
1449: LD_VAR 0 8
1453: IFFALSE 1489
// if UnitsInside ( lab [ 1 ] ) then
1455: LD_VAR 0 8
1459: PUSH
1460: LD_INT 1
1462: ARRAY
1463: PPUSH
1464: CALL_OW 313
1468: IFFALSE 1489
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1470: LD_VAR 0 8
1474: PUSH
1475: LD_INT 1
1477: ARRAY
1478: PPUSH
1479: LD_INT 10
1481: PPUSH
1482: LD_INT 0
1484: PPUSH
1485: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1489: LD_ADDR_VAR 0 4
1493: PUSH
1494: LD_INT 1
1496: PPUSH
1497: LD_INT 1
1499: PPUSH
1500: LD_INT 1
1502: PPUSH
1503: LD_INT 2
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 3
1511: PPUSH
1512: LD_INT 100
1514: PPUSH
1515: CALL 4191 0 7
1519: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1520: LD_VAR 0 4
1524: PPUSH
1525: LD_INT 2
1527: PPUSH
1528: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1532: LD_VAR 0 4
1536: PPUSH
1537: LD_INT 21
1539: PPUSH
1540: LD_INT 8
1542: PPUSH
1543: LD_INT 0
1545: PPUSH
1546: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1550: LD_EXP 7
1554: PPUSH
1555: LD_VAR 0 4
1559: PPUSH
1560: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1564: LD_ADDR_VAR 0 4
1568: PUSH
1569: LD_INT 1
1571: PPUSH
1572: LD_INT 1
1574: PPUSH
1575: LD_INT 1
1577: PPUSH
1578: LD_INT 2
1580: PPUSH
1581: LD_INT 1
1583: PPUSH
1584: LD_INT 2
1586: PPUSH
1587: LD_INT 100
1589: PPUSH
1590: CALL 4191 0 7
1594: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1595: LD_VAR 0 4
1599: PPUSH
1600: LD_INT 2
1602: PPUSH
1603: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1607: LD_VAR 0 4
1611: PPUSH
1612: LD_INT 16
1614: PPUSH
1615: LD_INT 3
1617: PPUSH
1618: LD_INT 0
1620: PPUSH
1621: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1625: LD_EXP 8
1629: PPUSH
1630: LD_VAR 0 4
1634: PPUSH
1635: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1639: LD_ADDR_VAR 0 4
1643: PUSH
1644: LD_INT 1
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: LD_INT 2
1652: PPUSH
1653: LD_INT 2
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 12
1661: PPUSH
1662: LD_INT 100
1664: PPUSH
1665: CALL 4191 0 7
1669: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1670: LD_VAR 0 4
1674: PPUSH
1675: LD_INT 0
1677: PPUSH
1678: LD_INT 5
1680: PPUSH
1681: CALL_OW 12
1685: PPUSH
1686: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1690: LD_VAR 0 4
1694: PPUSH
1695: LD_INT 1
1697: PPUSH
1698: LD_INT 0
1700: PPUSH
1701: CALL_OW 49
// end ;
1705: LD_VAR 0 1
1709: RET
// function PrepareBase ; var blist , i , b ; begin
1710: LD_INT 0
1712: PPUSH
1713: PPUSH
1714: PPUSH
1715: PPUSH
// blist := LoadVariable ( GammaBase , [ ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_STRING GammaBase
1723: PPUSH
1724: EMPTY
1725: PPUSH
1726: CALL_OW 30
1730: ST_TO_ADDR
// if not blist and debug then
1731: LD_VAR 0 2
1735: NOT
1736: PUSH
1737: LD_EXP 1
1741: AND
1742: IFFALSE 1782
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: LD_INT 0
1751: PUSH
1752: LD_INT 51
1754: PUSH
1755: LD_INT 10
1757: PUSH
1758: LD_INT 3
1760: PUSH
1761: LD_INT 3
1763: PUSH
1764: LD_INT 0
1766: PUSH
1767: LD_INT 0
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: PUSH
1779: EMPTY
1780: LIST
1781: ST_TO_ADDR
// if not blist then
1782: LD_VAR 0 2
1786: NOT
1787: IFFALSE 1791
// exit ;
1789: GO 1975
// uc_side := 1 ;
1791: LD_ADDR_OWVAR 20
1795: PUSH
1796: LD_INT 1
1798: ST_TO_ADDR
// uc_nation := 1 ;
1799: LD_ADDR_OWVAR 21
1803: PUSH
1804: LD_INT 1
1806: ST_TO_ADDR
// for i in blist do
1807: LD_ADDR_VAR 0 3
1811: PUSH
1812: LD_VAR 0 2
1816: PUSH
1817: FOR_IN
1818: IFFALSE 1973
// begin bc_type := i [ 1 ] ;
1820: LD_ADDR_OWVAR 42
1824: PUSH
1825: LD_VAR 0 3
1829: PUSH
1830: LD_INT 1
1832: ARRAY
1833: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1834: LD_ADDR_OWVAR 43
1838: PUSH
1839: LD_VAR 0 3
1843: PUSH
1844: LD_INT 5
1846: ARRAY
1847: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1848: LD_VAR 0 3
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PUSH
1857: LD_INT 7
1859: PUSH
1860: LD_INT 8
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: IN
1867: IFFALSE 1897
// begin bc_kind1 := i [ 7 ] ;
1869: LD_ADDR_OWVAR 44
1873: PUSH
1874: LD_VAR 0 3
1878: PUSH
1879: LD_INT 7
1881: ARRAY
1882: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1883: LD_ADDR_OWVAR 45
1887: PUSH
1888: LD_VAR 0 3
1892: PUSH
1893: LD_INT 8
1895: ARRAY
1896: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1897: LD_ADDR_VAR 0 4
1901: PUSH
1902: LD_VAR 0 3
1906: PUSH
1907: LD_INT 2
1909: ARRAY
1910: PPUSH
1911: LD_VAR 0 3
1915: PUSH
1916: LD_INT 3
1918: ARRAY
1919: PPUSH
1920: LD_VAR 0 3
1924: PUSH
1925: LD_INT 4
1927: ARRAY
1928: PPUSH
1929: CALL_OW 47
1933: ST_TO_ADDR
// if GetBType ( i [ 1 ] ) = b_bunker then
1934: LD_VAR 0 3
1938: PUSH
1939: LD_INT 1
1941: ARRAY
1942: PPUSH
1943: CALL_OW 266
1947: PUSH
1948: LD_INT 32
1950: EQUAL
1951: IFFALSE 1971
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
1953: LD_VAR 0 4
1957: PPUSH
1958: LD_VAR 0 3
1962: PUSH
1963: LD_INT 7
1965: ARRAY
1966: PPUSH
1967: CALL_OW 431
// end ; end ;
1971: GO 1817
1973: POP
1974: POP
// end ; end_of_file
1975: LD_VAR 0 1
1979: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
1980: LD_INT 0
1982: PPUSH
1983: PPUSH
1984: PPUSH
1985: PPUSH
1986: PPUSH
1987: PPUSH
1988: PPUSH
1989: PPUSH
// InGameOn ;
1990: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
1994: LD_INT 33
1996: PPUSH
1997: LD_INT 11
1999: PPUSH
2000: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2004: LD_ADDR_VAR 0 2
2008: PUSH
2009: LD_INT 29
2011: PUSH
2012: LD_INT 21
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 41
2021: PUSH
2022: LD_INT 28
2024: PUSH
2025: EMPTY
2026: LIST
2027: LIST
2028: PUSH
2029: LD_INT 52
2031: PUSH
2032: LD_INT 26
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: PUSH
2039: LD_INT 49
2041: PUSH
2042: LD_INT 16
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: ST_TO_ADDR
// for i in points do
2055: LD_ADDR_VAR 0 3
2059: PUSH
2060: LD_VAR 0 2
2064: PUSH
2065: FOR_IN
2066: IFFALSE 2106
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2068: LD_EXP 7
2072: PUSH
2073: LD_EXP 8
2077: PUSH
2078: EMPTY
2079: LIST
2080: LIST
2081: PPUSH
2082: LD_VAR 0 3
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PPUSH
2091: LD_VAR 0 3
2095: PUSH
2096: LD_INT 2
2098: ARRAY
2099: PPUSH
2100: CALL_OW 171
2104: GO 2065
2106: POP
2107: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2108: LD_EXP 7
2112: PUSH
2113: LD_EXP 8
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: PPUSH
2122: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2126: LD_INT 35
2128: PPUSH
2129: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2133: LD_EXP 7
2137: PPUSH
2138: CALL_OW 310
2142: NOT
2143: PUSH
2144: LD_EXP 8
2148: PPUSH
2149: CALL_OW 310
2153: NOT
2154: AND
2155: IFFALSE 2126
// ComTurnUnit ( JMM , Gladstone ) ;
2157: LD_EXP 7
2161: PPUSH
2162: LD_EXP 8
2166: PPUSH
2167: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2171: LD_EXP 8
2175: PPUSH
2176: LD_EXP 7
2180: PPUSH
2181: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2185: LD_ADDR_VAR 0 4
2189: PUSH
2190: LD_INT 26
2192: PUSH
2193: LD_INT 1
2195: PUSH
2196: EMPTY
2197: LIST
2198: LIST
2199: PPUSH
2200: CALL_OW 69
2204: PUSH
2205: LD_EXP 7
2209: PUSH
2210: LD_EXP 8
2214: PUSH
2215: LD_EXP 12
2219: PUSH
2220: LD_EXP 11
2224: PUSH
2225: LD_EXP 9
2229: PUSH
2230: LD_EXP 14
2234: PUSH
2235: EMPTY
2236: LIST
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: DIFF
2243: ST_TO_ADDR
// if sol then
2244: LD_VAR 0 4
2248: IFFALSE 2264
// sol := sol [ 1 ] ;
2250: LD_ADDR_VAR 0 4
2254: PUSH
2255: LD_VAR 0 4
2259: PUSH
2260: LD_INT 1
2262: ARRAY
2263: ST_TO_ADDR
// team := [ ] ;
2264: LD_ADDR_VAR 0 5
2268: PUSH
2269: EMPTY
2270: ST_TO_ADDR
// if sol then
2271: LD_VAR 0 4
2275: IFFALSE 2293
// team := team ^ sol ;
2277: LD_ADDR_VAR 0 5
2281: PUSH
2282: LD_VAR 0 5
2286: PUSH
2287: LD_VAR 0 4
2291: ADD
2292: ST_TO_ADDR
// if Lisa then
2293: LD_EXP 10
2297: IFFALSE 2315
// team := team ^ Lisa ;
2299: LD_ADDR_VAR 0 5
2303: PUSH
2304: LD_VAR 0 5
2308: PUSH
2309: LD_EXP 10
2313: ADD
2314: ST_TO_ADDR
// if Donaldson then
2315: LD_EXP 13
2319: IFFALSE 2337
// team := team ^ Donaldson ;
2321: LD_ADDR_VAR 0 5
2325: PUSH
2326: LD_VAR 0 5
2330: PUSH
2331: LD_EXP 13
2335: ADD
2336: ST_TO_ADDR
// if Brown then
2337: LD_EXP 14
2341: IFFALSE 2359
// team := team ^ Brown ;
2343: LD_ADDR_VAR 0 5
2347: PUSH
2348: LD_VAR 0 5
2352: PUSH
2353: LD_EXP 14
2357: ADD
2358: ST_TO_ADDR
// if Bobby then
2359: LD_EXP 12
2363: IFFALSE 2381
// team := team ^ Bobby ;
2365: LD_ADDR_VAR 0 5
2369: PUSH
2370: LD_VAR 0 5
2374: PUSH
2375: LD_EXP 12
2379: ADD
2380: ST_TO_ADDR
// if Cyrus then
2381: LD_EXP 11
2385: IFFALSE 2403
// team := team ^ Cyrus ;
2387: LD_ADDR_VAR 0 5
2391: PUSH
2392: LD_VAR 0 5
2396: PUSH
2397: LD_EXP 11
2401: ADD
2402: ST_TO_ADDR
// if Frank then
2403: LD_EXP 9
2407: IFFALSE 2425
// team := team ^ Frank ;
2409: LD_ADDR_VAR 0 5
2413: PUSH
2414: LD_VAR 0 5
2418: PUSH
2419: LD_EXP 9
2423: ADD
2424: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2425: LD_ADDR_VAR 0 3
2429: PUSH
2430: LD_INT 1
2432: PPUSH
2433: LD_INT 3
2435: PUSH
2436: LD_INT 54
2438: PUSH
2439: EMPTY
2440: LIST
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PUSH
2446: LD_INT 21
2448: PUSH
2449: LD_INT 1
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: PPUSH
2460: CALL_OW 70
2464: PUSH
2465: LD_EXP 7
2469: PUSH
2470: LD_EXP 8
2474: PUSH
2475: EMPTY
2476: LIST
2477: LIST
2478: DIFF
2479: PUSH
2480: EMPTY
2481: LIST
2482: PUSH
2483: FOR_IN
2484: IFFALSE 2504
// team := team ^ i ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_VAR 0 3
2500: ADD
2501: ST_TO_ADDR
2502: GO 2483
2504: POP
2505: POP
// if team then
2506: LD_VAR 0 5
2510: IFFALSE 2586
// begin ComExitBuilding ( team ) ;
2512: LD_VAR 0 5
2516: PPUSH
2517: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2521: LD_VAR 0 5
2525: PPUSH
2526: LD_EXP 7
2530: PPUSH
2531: CALL_OW 172
// repeat wait ( 1 ) ;
2535: LD_INT 1
2537: PPUSH
2538: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2542: LD_EXP 7
2546: PPUSH
2547: LD_VAR 0 5
2551: PPUSH
2552: LD_EXP 7
2556: PPUSH
2557: CALL_OW 74
2561: PPUSH
2562: CALL_OW 296
2566: PUSH
2567: LD_INT 6
2569: LESS
2570: IFFALSE 2535
// ComTurnUnit ( team , JMM ) ;
2572: LD_VAR 0 5
2576: PPUSH
2577: LD_EXP 7
2581: PPUSH
2582: CALL_OW 119
// end ; if Lisa then
2586: LD_EXP 10
2590: IFFALSE 2618
// begin ComTurnUnit ( JMM , Lisa ) ;
2592: LD_EXP 7
2596: PPUSH
2597: LD_EXP 10
2601: PPUSH
2602: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2606: LD_EXP 10
2610: PPUSH
2611: LD_STRING D1-Lisa-1
2613: PPUSH
2614: CALL_OW 88
// end ; if sol then
2618: LD_VAR 0 4
2622: IFFALSE 2650
// begin ComTurnUnit ( JMM , sol ) ;
2624: LD_EXP 7
2628: PPUSH
2629: LD_VAR 0 4
2633: PPUSH
2634: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2638: LD_VAR 0 4
2642: PPUSH
2643: LD_STRING D1-Sol1-1
2645: PPUSH
2646: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2650: LD_EXP 7
2654: PPUSH
2655: LD_STRING D1-JMM-1
2657: PPUSH
2658: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2662: LD_EXP 7
2666: PPUSH
2667: LD_STRING D1-JMM-1a
2669: PPUSH
2670: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2674: LD_EXP 7
2678: PPUSH
2679: LD_EXP 8
2683: PPUSH
2684: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2688: LD_VAR 0 5
2692: PPUSH
2693: LD_EXP 8
2697: PPUSH
2698: CALL_OW 119
// if Frank then
2702: LD_EXP 9
2706: IFFALSE 2734
// begin Say ( Frank , D1-Frank-1 ) ;
2708: LD_EXP 9
2712: PPUSH
2713: LD_STRING D1-Frank-1
2715: PPUSH
2716: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2720: LD_EXP 7
2724: PPUSH
2725: LD_EXP 9
2729: PPUSH
2730: CALL_OW 119
// end ; if Lisa then
2734: LD_EXP 10
2738: IFFALSE 2766
// begin ComTurnUnit ( JMM , Lisa ) ;
2740: LD_EXP 7
2744: PPUSH
2745: LD_EXP 10
2749: PPUSH
2750: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2754: LD_EXP 10
2758: PPUSH
2759: LD_STRING D1-Lisa-2
2761: PPUSH
2762: CALL_OW 88
// end ; if sol then
2766: LD_VAR 0 4
2770: IFFALSE 2798
// begin ComTurnUnit ( JMM , sol ) ;
2772: LD_EXP 7
2776: PPUSH
2777: LD_VAR 0 4
2781: PPUSH
2782: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2786: LD_VAR 0 4
2790: PPUSH
2791: LD_STRING D1-Sol1-2
2793: PPUSH
2794: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2798: LD_EXP 8
2802: PPUSH
2803: LD_STRING D1-Glad-2
2805: PPUSH
2806: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2810: LD_VAR 0 5
2814: PPUSH
2815: LD_EXP 7
2819: PPUSH
2820: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2824: LD_EXP 7
2828: PPUSH
2829: LD_STRING D1-JMM-2
2831: PPUSH
2832: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2836: LD_EXP 7
2840: PPUSH
2841: LD_EXP 8
2845: PPUSH
2846: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2850: LD_EXP 8
2854: PPUSH
2855: LD_STRING D1-Glad-3
2857: PPUSH
2858: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2862: LD_EXP 7
2866: PPUSH
2867: LD_STRING D1-JMM-3
2869: PPUSH
2870: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2874: LD_EXP 8
2878: PPUSH
2879: LD_STRING D1-Glad-4
2881: PPUSH
2882: CALL_OW 88
// if Frank then
2886: LD_EXP 9
2890: IFFALSE 2918
// begin ComTurnUnit ( JMM , Frank ) ;
2892: LD_EXP 7
2896: PPUSH
2897: LD_EXP 9
2901: PPUSH
2902: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2906: LD_EXP 9
2910: PPUSH
2911: LD_STRING D1-Frank-4
2913: PPUSH
2914: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
2918: LD_EXP 7
2922: PPUSH
2923: LD_EXP 8
2927: PPUSH
2928: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
2932: LD_EXP 7
2936: PPUSH
2937: LD_STRING D1-JMM-4
2939: PPUSH
2940: CALL_OW 88
// if Lisa then
2944: LD_EXP 10
2948: IFFALSE 3015
// begin Say ( Lisa , D1-Lisa-4 ) ;
2950: LD_EXP 10
2954: PPUSH
2955: LD_STRING D1-Lisa-4
2957: PPUSH
2958: CALL_OW 88
// if Frank then
2962: LD_EXP 9
2966: IFFALSE 3015
// begin ComTurnUnit ( Frank , Lisa ) ;
2968: LD_EXP 9
2972: PPUSH
2973: LD_EXP 10
2977: PPUSH
2978: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
2982: LD_EXP 9
2986: PPUSH
2987: LD_STRING D1-Frank-5
2989: PPUSH
2990: CALL_OW 88
// Wait ( 3 ) ;
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3001: LD_EXP 9
3005: PPUSH
3006: LD_EXP 7
3010: PPUSH
3011: CALL_OW 179
// end ; end ; if sol then
3015: LD_VAR 0 4
3019: IFFALSE 3033
// Say ( sol , D1-Sol1-5 ) ;
3021: LD_VAR 0 4
3025: PPUSH
3026: LD_STRING D1-Sol1-5
3028: PPUSH
3029: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3033: LD_EXP 7
3037: PPUSH
3038: LD_STRING D1-JMM-5
3040: PPUSH
3041: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3045: LD_EXP 8
3049: PPUSH
3050: LD_STRING D1-Glad-5
3052: PPUSH
3053: CALL_OW 88
// if Frank then
3057: LD_EXP 9
3061: IFFALSE 3075
// Say ( Frank , D1-Frank-6 ) ;
3063: LD_EXP 9
3067: PPUSH
3068: LD_STRING D1-Frank-6
3070: PPUSH
3071: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3075: LD_EXP 7
3079: PPUSH
3080: LD_STRING D1-JMM-6
3082: PPUSH
3083: CALL_OW 88
// if Brown and Donaldson then
3087: LD_EXP 14
3091: PUSH
3092: LD_EXP 13
3096: AND
3097: IFFALSE 3146
// case Query ( QCommander ) of 1 :
3099: LD_STRING QCommander
3101: PPUSH
3102: CALL_OW 97
3106: PUSH
3107: LD_INT 1
3109: DOUBLE
3110: EQUAL
3111: IFTRUE 3115
3113: GO 3126
3115: POP
// donaldson_commander := true ; 2 :
3116: LD_ADDR_EXP 4
3120: PUSH
3121: LD_INT 1
3123: ST_TO_ADDR
3124: GO 3146
3126: LD_INT 2
3128: DOUBLE
3129: EQUAL
3130: IFTRUE 3134
3132: GO 3145
3134: POP
// brown_commander := true ; end ;
3135: LD_ADDR_EXP 5
3139: PUSH
3140: LD_INT 1
3142: ST_TO_ADDR
3143: GO 3146
3145: POP
// if not Brown and Donaldson then
3146: LD_EXP 14
3150: NOT
3151: PUSH
3152: LD_EXP 13
3156: AND
3157: IFFALSE 3167
// donaldson_commander := true ;
3159: LD_ADDR_EXP 4
3163: PUSH
3164: LD_INT 1
3166: ST_TO_ADDR
// if Brown and not Donaldson then
3167: LD_EXP 14
3171: PUSH
3172: LD_EXP 13
3176: NOT
3177: AND
3178: IFFALSE 3188
// brown_commander := true ;
3180: LD_ADDR_EXP 5
3184: PUSH
3185: LD_INT 1
3187: ST_TO_ADDR
// if donaldson_commander then
3188: LD_EXP 4
3192: IFFALSE 3339
// begin ComTurnUnit ( JMM , Donaldson ) ;
3194: LD_EXP 7
3198: PPUSH
3199: LD_EXP 13
3203: PPUSH
3204: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3208: LD_EXP 7
3212: PPUSH
3213: LD_STRING D1a-JMM-1
3215: PPUSH
3216: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3220: LD_EXP 13
3224: PPUSH
3225: LD_EXP 7
3229: PPUSH
3230: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3234: LD_EXP 13
3238: PPUSH
3239: LD_EXP 7
3243: PPUSH
3244: CALL_OW 179
// Wait ( 3 ) ;
3248: LD_INT 3
3250: PPUSH
3251: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3255: LD_EXP 13
3259: PPUSH
3260: LD_STRING D1a-Don-1
3262: PPUSH
3263: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3267: LD_EXP 7
3271: PPUSH
3272: LD_STRING D1b-JMM-2
3274: PPUSH
3275: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3279: LD_EXP 13
3283: PPUSH
3284: LD_STRING D1a-Don-2
3286: PPUSH
3287: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3291: LD_EXP 13
3295: PPUSH
3296: LD_INT 30
3298: PUSH
3299: LD_INT 0
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: PUSH
3311: LD_INT 1
3313: ARRAY
3314: PPUSH
3315: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3319: LD_INT 1
3321: PPUSH
3322: LD_STRING GammaCommander
3324: PPUSH
3325: CALL_OW 39
// commander := Donaldson ;
3329: LD_ADDR_VAR 0 7
3333: PUSH
3334: LD_EXP 13
3338: ST_TO_ADDR
// end ; if brown_commander then
3339: LD_EXP 5
3343: IFFALSE 3490
// begin ComTurnUnit ( JMM , Brown ) ;
3345: LD_EXP 7
3349: PPUSH
3350: LD_EXP 14
3354: PPUSH
3355: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3359: LD_EXP 7
3363: PPUSH
3364: LD_STRING D1b-JMM-1
3366: PPUSH
3367: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3371: LD_EXP 14
3375: PPUSH
3376: LD_EXP 7
3380: PPUSH
3381: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3385: LD_EXP 14
3389: PPUSH
3390: LD_EXP 7
3394: PPUSH
3395: CALL_OW 179
// Wait ( 3 ) ;
3399: LD_INT 3
3401: PPUSH
3402: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3406: LD_EXP 14
3410: PPUSH
3411: LD_STRING D1b-Brown-1
3413: PPUSH
3414: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3418: LD_EXP 7
3422: PPUSH
3423: LD_STRING D1a-JMM-2
3425: PPUSH
3426: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3430: LD_EXP 14
3434: PPUSH
3435: LD_STRING D1b-Brown-2
3437: PPUSH
3438: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3442: LD_EXP 14
3446: PPUSH
3447: LD_INT 30
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: PPUSH
3457: CALL_OW 69
3461: PUSH
3462: LD_INT 1
3464: ARRAY
3465: PPUSH
3466: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3470: LD_INT 2
3472: PPUSH
3473: LD_STRING GammaCommander
3475: PPUSH
3476: CALL_OW 39
// commander := Brown ;
3480: LD_ADDR_VAR 0 7
3484: PUSH
3485: LD_EXP 14
3489: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3490: LD_EXP 7
3494: PPUSH
3495: LD_EXP 8
3499: PPUSH
3500: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3504: LD_EXP 4
3508: NOT
3509: PUSH
3510: LD_EXP 5
3514: NOT
3515: AND
3516: IFFALSE 3540
// begin Say ( JMM , D1c-JMM-1 ) ;
3518: LD_EXP 7
3522: PPUSH
3523: LD_STRING D1c-JMM-1
3525: PPUSH
3526: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3530: LD_INT 3
3532: PPUSH
3533: LD_STRING GammaCommander
3535: PPUSH
3536: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3540: LD_EXP 7
3544: PPUSH
3545: LD_STRING D1d-JMM-1
3547: PPUSH
3548: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3552: LD_ADDR_VAR 0 6
3556: PUSH
3557: LD_INT 21
3559: PUSH
3560: LD_INT 1
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PPUSH
3567: CALL_OW 69
3571: PUSH
3572: LD_EXP 7
3576: PUSH
3577: LD_EXP 8
3581: PUSH
3582: LD_VAR 0 7
3586: PUSH
3587: EMPTY
3588: LIST
3589: LIST
3590: LIST
3591: DIFF
3592: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3593: LD_ADDR_EXP 6
3597: PUSH
3598: LD_STRING 1
3600: PPUSH
3601: LD_INT 5
3603: PPUSH
3604: LD_INT 5
3606: PPUSH
3607: LD_INT -5
3609: PUSH
3610: LD_EXP 7
3614: PUSH
3615: LD_INT -6
3617: PUSH
3618: LD_EXP 8
3622: PUSH
3623: LD_INT -2
3625: PUSH
3626: LD_INT -3
3628: PUSH
3629: LD_INT -5
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: PUSH
3641: LD_VAR 0 6
3645: ADD
3646: PUSH
3647: LD_INT -6
3649: PUSH
3650: LD_INT -4
3652: PUSH
3653: LD_VAR 0 7
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: LIST
3662: ADD
3663: PPUSH
3664: LD_INT 1
3666: PUSH
3667: LD_INT 3
3669: PUSH
3670: LD_INT 2
3672: PUSH
3673: LD_INT 1
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: PUSH
3680: LD_INT 4
3682: PUSH
3683: EMPTY
3684: LIST
3685: LIST
3686: LIST
3687: LIST
3688: PPUSH
3689: CALL_OW 42
3693: ST_TO_ADDR
// SaveCharacters ( all diff [ save_group , JMM , Gladstone ] , othersGamma ) ;
3694: LD_VAR 0 6
3698: PUSH
3699: LD_EXP 6
3703: PUSH
3704: LD_EXP 7
3708: PUSH
3709: LD_EXP 8
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: LIST
3718: DIFF
3719: PPUSH
3720: LD_STRING othersGamma
3722: PPUSH
3723: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
3727: LD_EXP 6
3731: PUSH
3732: LD_EXP 7
3736: PUSH
3737: LD_EXP 8
3741: PUSH
3742: LD_EXP 10
3746: PUSH
3747: LD_EXP 11
3751: PUSH
3752: LD_EXP 12
3756: PUSH
3757: LD_EXP 9
3761: PUSH
3762: LD_EXP 13
3766: PUSH
3767: LD_EXP 14
3771: PUSH
3772: LD_INT 0
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: LIST
3784: LIST
3785: DIFF
3786: PPUSH
3787: LD_STRING othersDelta
3789: PPUSH
3790: CALL_OW 38
// if Lisa in save_group then
3794: LD_EXP 10
3798: PUSH
3799: LD_EXP 6
3803: IN
3804: IFFALSE 3816
// begin SaveVariable ( true , LisaInDelta ) ;
3806: LD_INT 1
3808: PPUSH
3809: LD_STRING LisaInDelta
3811: PPUSH
3812: CALL_OW 39
// end ; if Bobby in save_group then
3816: LD_EXP 12
3820: PUSH
3821: LD_EXP 6
3825: IN
3826: IFFALSE 3838
// begin SaveVariable ( true , BobbyInDelta ) ;
3828: LD_INT 1
3830: PPUSH
3831: LD_STRING BobbyInDelta
3833: PPUSH
3834: CALL_OW 39
// end ; if Cyrus in save_group then
3838: LD_EXP 11
3842: PUSH
3843: LD_EXP 6
3847: IN
3848: IFFALSE 3860
// begin SaveVariable ( true , CyrusInDelta ) ;
3850: LD_INT 1
3852: PPUSH
3853: LD_STRING CyrusInDelta
3855: PPUSH
3856: CALL_OW 39
// end ; if Frank in save_group then
3860: LD_EXP 9
3864: PUSH
3865: LD_EXP 6
3869: IN
3870: IFFALSE 3882
// begin SaveVariable ( true , FrankInDelta ) ;
3872: LD_INT 1
3874: PPUSH
3875: LD_STRING FrankInDelta
3877: PPUSH
3878: CALL_OW 39
// end ; if Brown in save_group then
3882: LD_EXP 14
3886: PUSH
3887: LD_EXP 6
3891: IN
3892: IFFALSE 3904
// begin SaveVariable ( true , BrownInDelta ) ;
3894: LD_INT 1
3896: PPUSH
3897: LD_STRING BrownInDelta
3899: PPUSH
3900: CALL_OW 39
// end ; if Donaldson in save_group then
3904: LD_EXP 13
3908: PUSH
3909: LD_EXP 6
3913: IN
3914: IFFALSE 3926
// begin SaveVariable ( true , DonaldsonInDelta ) ;
3916: LD_INT 1
3918: PPUSH
3919: LD_STRING DonaldsonInDelta
3921: PPUSH
3922: CALL_OW 39
// end ; Wait ( 3 ) ;
3926: LD_INT 3
3928: PPUSH
3929: CALL_OW 67
// for i in save_group do
3933: LD_ADDR_VAR 0 3
3937: PUSH
3938: LD_EXP 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 3975
// begin if IsInUnit ( i ) then
3946: LD_VAR 0 3
3950: PPUSH
3951: CALL_OW 310
3955: IFFALSE 3966
// ComExitBuilding ( i ) ;
3957: LD_VAR 0 3
3961: PPUSH
3962: CALL_OW 122
// Wait ( 3 ) ;
3966: LD_INT 3
3968: PPUSH
3969: CALL_OW 67
// end ;
3973: GO 3943
3975: POP
3976: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
3977: LD_ADDR_EXP 6
3981: PUSH
3982: LD_EXP 6
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_EXP 7
3994: PPUSH
3995: CALL_OW 2
3999: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4000: LD_ADDR_EXP 6
4004: PUSH
4005: LD_EXP 6
4009: PPUSH
4010: LD_INT 2
4012: PPUSH
4013: LD_EXP 8
4017: PPUSH
4018: CALL_OW 2
4022: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4023: LD_ADDR_VAR 0 8
4027: PUSH
4028: LD_INT 21
4030: PUSH
4031: LD_INT 2
4033: PUSH
4034: EMPTY
4035: LIST
4036: LIST
4037: PPUSH
4038: CALL_OW 69
4042: ST_TO_ADDR
// for i = 1 to filter do
4043: LD_ADDR_VAR 0 3
4047: PUSH
4048: DOUBLE
4049: LD_INT 1
4051: DEC
4052: ST_TO_ADDR
4053: LD_VAR 0 8
4057: PUSH
4058: FOR_TO
4059: IFFALSE 4089
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4061: LD_EXP 6
4065: PUSH
4066: LD_VAR 0 3
4070: ARRAY
4071: PPUSH
4072: LD_VAR 0 8
4076: PUSH
4077: LD_VAR 0 3
4081: ARRAY
4082: PPUSH
4083: CALL_OW 120
4087: GO 4058
4089: POP
4090: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4091: LD_EXP 6
4095: PPUSH
4096: LD_INT 87
4098: PPUSH
4099: LD_INT 27
4101: PPUSH
4102: CALL_OW 171
// Wait ( 0 0$05 ) ;
4106: LD_INT 175
4108: PPUSH
4109: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4113: LD_INT 1
4115: PPUSH
4116: LD_STRING %_cont
4118: PPUSH
4119: CALL_OW 340
// end ; end_of_file
4123: LD_VAR 0 1
4127: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4128: LD_INT 0
4130: PPUSH
4131: PPUSH
// if exist_mode then
4132: LD_VAR 0 2
4136: IFFALSE 4161
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4138: LD_ADDR_VAR 0 4
4142: PUSH
4143: LD_EXP 3
4147: PUSH
4148: LD_VAR 0 1
4152: STR
4153: PPUSH
4154: CALL_OW 34
4158: ST_TO_ADDR
4159: GO 4176
// unit := NewCharacter ( ident ) ;
4161: LD_ADDR_VAR 0 4
4165: PUSH
4166: LD_VAR 0 1
4170: PPUSH
4171: CALL_OW 25
4175: ST_TO_ADDR
// result := unit ;
4176: LD_ADDR_VAR 0 3
4180: PUSH
4181: LD_VAR 0 4
4185: ST_TO_ADDR
// end ;
4186: LD_VAR 0 3
4190: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4191: LD_INT 0
4193: PPUSH
// uc_side := side ;
4194: LD_ADDR_OWVAR 20
4198: PUSH
4199: LD_VAR 0 1
4203: ST_TO_ADDR
// uc_nation := nation ;
4204: LD_ADDR_OWVAR 21
4208: PUSH
4209: LD_VAR 0 2
4213: ST_TO_ADDR
// vc_chassis := chassis ;
4214: LD_ADDR_OWVAR 37
4218: PUSH
4219: LD_VAR 0 3
4223: ST_TO_ADDR
// vc_engine := engine ;
4224: LD_ADDR_OWVAR 39
4228: PUSH
4229: LD_VAR 0 4
4233: ST_TO_ADDR
// vc_control := control ;
4234: LD_ADDR_OWVAR 38
4238: PUSH
4239: LD_VAR 0 5
4243: ST_TO_ADDR
// vc_weapon := weapon ;
4244: LD_ADDR_OWVAR 40
4248: PUSH
4249: LD_VAR 0 6
4253: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4254: LD_ADDR_OWVAR 41
4258: PUSH
4259: LD_VAR 0 7
4263: ST_TO_ADDR
// result := CreateVehicle ;
4264: LD_ADDR_VAR 0 8
4268: PUSH
4269: CALL_OW 45
4273: ST_TO_ADDR
// end ;
4274: LD_VAR 0 8
4278: RET
// export function SayX ( units , ident ) ; var i ; begin
4279: LD_INT 0
4281: PPUSH
4282: PPUSH
// result := false ;
4283: LD_ADDR_VAR 0 3
4287: PUSH
4288: LD_INT 0
4290: ST_TO_ADDR
// if not units then
4291: LD_VAR 0 1
4295: NOT
4296: IFFALSE 4300
// exit ;
4298: GO 4354
// for i in units do
4300: LD_ADDR_VAR 0 4
4304: PUSH
4305: LD_VAR 0 1
4309: PUSH
4310: FOR_IN
4311: IFFALSE 4352
// if IsOk ( i ) then
4313: LD_VAR 0 4
4317: PPUSH
4318: CALL_OW 302
4322: IFFALSE 4350
// begin Say ( i , ident ) ;
4324: LD_VAR 0 4
4328: PPUSH
4329: LD_VAR 0 2
4333: PPUSH
4334: CALL_OW 88
// result := i ;
4338: LD_ADDR_VAR 0 3
4342: PUSH
4343: LD_VAR 0 4
4347: ST_TO_ADDR
// break ;
4348: GO 4352
// end ;
4350: GO 4310
4352: POP
4353: POP
// end ;
4354: LD_VAR 0 3
4358: RET
