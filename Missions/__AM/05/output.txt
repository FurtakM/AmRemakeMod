// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 64 0 0
// PrepareAmerican ;
  16: CALL 88 0 0
// Action ;
  20: CALL 1964 0 0
// end ;
  24: END
// export debug ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// donaldson_commander := false ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// brown_commander := false ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// save_group := [ ] ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: EMPTY
  58: ST_TO_ADDR
// end ;
  59: LD_VAR 0 1
  63: RET
// function DebugMode ; begin
  64: LD_INT 0
  66: PPUSH
// if not debug then
  67: LD_EXP 1
  71: NOT
  72: IFFALSE 76
// exit ;
  74: GO 83
// FogOff ( 1 ) ;
  76: LD_INT 1
  78: PPUSH
  79: CALL_OW 344
// end ; end_of_file
  83: LD_VAR 0 1
  87: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i ; begin
  88: LD_INT 0
  90: PPUSH
  91: PPUSH
  92: PPUSH
  93: PPUSH
  94: PPUSH
  95: PPUSH
  96: PPUSH
  97: PPUSH
  98: PPUSH
  99: PPUSH
 100: PPUSH
 101: PPUSH
// PrepareBase ;
 102: CALL 1694 0 0
// uc_side := 1 ;
 106: LD_ADDR_OWVAR 20
 110: PUSH
 111: LD_INT 1
 113: ST_TO_ADDR
// uc_nation := 1 ;
 114: LD_ADDR_OWVAR 21
 118: PUSH
 119: LD_INT 1
 121: ST_TO_ADDR
// team := [ ] ;
 122: LD_ADDR_VAR 0 5
 126: PUSH
 127: EMPTY
 128: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_STRING JMM
 136: PPUSH
 137: LD_EXP 1
 141: NOT
 142: PPUSH
 143: CALL 4184 0 2
 147: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 148: LD_ADDR_EXP 6
 152: PUSH
 153: LD_STRING Gladstone
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: CALL 4184 0 2
 163: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 164: LD_ADDR_EXP 7
 168: PUSH
 169: LD_STRING Frank
 171: PPUSH
 172: LD_EXP 1
 176: NOT
 177: PPUSH
 178: CALL 4184 0 2
 182: ST_TO_ADDR
// if Frank then
 183: LD_EXP 7
 187: IFFALSE 205
// team := team ^ Frank ;
 189: LD_ADDR_VAR 0 5
 193: PUSH
 194: LD_VAR 0 5
 198: PUSH
 199: LD_EXP 7
 203: ADD
 204: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 205: LD_ADDR_EXP 8
 209: PUSH
 210: LD_STRING Lisa
 212: PPUSH
 213: LD_EXP 1
 217: NOT
 218: PPUSH
 219: CALL 4184 0 2
 223: ST_TO_ADDR
// if Lisa then
 224: LD_EXP 8
 228: IFFALSE 246
// team := team ^ Lisa ;
 230: LD_ADDR_VAR 0 5
 234: PUSH
 235: LD_VAR 0 5
 239: PUSH
 240: LD_EXP 8
 244: ADD
 245: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 246: LD_ADDR_EXP 11
 250: PUSH
 251: LD_STRING Donaldson
 253: PPUSH
 254: LD_EXP 1
 258: NOT
 259: PPUSH
 260: CALL 4184 0 2
 264: ST_TO_ADDR
// if Donaldson then
 265: LD_EXP 11
 269: IFFALSE 287
// team := team ^ Donaldson ;
 271: LD_ADDR_VAR 0 5
 275: PUSH
 276: LD_VAR 0 5
 280: PUSH
 281: LD_EXP 11
 285: ADD
 286: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 287: LD_ADDR_EXP 12
 291: PUSH
 292: LD_STRING Brown
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: CALL 4184 0 2
 305: ST_TO_ADDR
// if Brown then
 306: LD_EXP 12
 310: IFFALSE 328
// team := team ^ Brown ;
 312: LD_ADDR_VAR 0 5
 316: PUSH
 317: LD_VAR 0 5
 321: PUSH
 322: LD_EXP 12
 326: ADD
 327: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 328: LD_ADDR_VAR 0 3
 332: PUSH
 333: LD_STRING 04_other_survivors
 335: PPUSH
 336: CALL_OW 31
 340: ST_TO_ADDR
// if not Lisa then
 341: LD_EXP 8
 345: NOT
 346: IFFALSE 457
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 348: LD_ADDR_EXP 9
 352: PUSH
 353: LD_STRING Cyrus
 355: PPUSH
 356: LD_EXP 1
 360: NOT
 361: PPUSH
 362: CALL 4184 0 2
 366: ST_TO_ADDR
// if Cyrus then
 367: LD_EXP 9
 371: IFFALSE 389
// team := team ^ Cyrus ;
 373: LD_ADDR_VAR 0 5
 377: PUSH
 378: LD_VAR 0 5
 382: PUSH
 383: LD_EXP 9
 387: ADD
 388: ST_TO_ADDR
// if not Cyrus then
 389: LD_EXP 9
 393: NOT
 394: IFFALSE 457
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 396: LD_ADDR_EXP 10
 400: PUSH
 401: LD_STRING Bobby
 403: PPUSH
 404: LD_EXP 1
 408: NOT
 409: PPUSH
 410: CALL 4184 0 2
 414: ST_TO_ADDR
// if Bobby then
 415: LD_EXP 10
 419: IFFALSE 437
// team := team ^ Bobby ;
 421: LD_ADDR_VAR 0 5
 425: PUSH
 426: LD_VAR 0 5
 430: PUSH
 431: LD_EXP 10
 435: ADD
 436: ST_TO_ADDR
// if not Bobby then
 437: LD_EXP 10
 441: NOT
 442: IFFALSE 457
// begin others3 := CreateCharacterSet ( 03_others ) ;
 444: LD_ADDR_VAR 0 2
 448: PUSH
 449: LD_STRING 03_others
 451: PPUSH
 452: CALL_OW 31
 456: ST_TO_ADDR
// end ; end ; end ; if others4 then
 457: LD_VAR 0 3
 461: IFFALSE 479
// team := team ^ others4 ;
 463: LD_ADDR_VAR 0 5
 467: PUSH
 468: LD_VAR 0 5
 472: PUSH
 473: LD_VAR 0 3
 477: ADD
 478: ST_TO_ADDR
// if others3 then
 479: LD_VAR 0 2
 483: IFFALSE 501
// team := team ^ others3 ;
 485: LD_ADDR_VAR 0 5
 489: PUSH
 490: LD_VAR 0 5
 494: PUSH
 495: LD_VAR 0 2
 499: ADD
 500: ST_TO_ADDR
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 501: LD_ADDR_VAR 0 6
 505: PUSH
 506: LD_INT 30
 508: PUSH
 509: LD_INT 0
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PPUSH
 516: CALL_OW 69
 520: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 521: LD_ADDR_VAR 0 7
 525: PUSH
 526: LD_INT 30
 528: PUSH
 529: LD_INT 4
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: PPUSH
 536: CALL_OW 69
 540: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 541: LD_ADDR_VAR 0 8
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 30
 551: PUSH
 552: LD_INT 7
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: PUSH
 559: LD_INT 30
 561: PUSH
 562: LD_INT 6
 564: PUSH
 565: EMPTY
 566: LIST
 567: LIST
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: PPUSH
 574: CALL_OW 69
 578: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 579: LD_ADDR_VAR 0 9
 583: PUSH
 584: LD_INT 30
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: EMPTY
 591: LIST
 592: LIST
 593: PPUSH
 594: CALL_OW 69
 598: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 599: LD_ADDR_VAR 0 10
 603: PUSH
 604: LD_INT 2
 606: PUSH
 607: LD_INT 30
 609: PUSH
 610: LD_INT 32
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 30
 619: PUSH
 620: LD_INT 31
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: LIST
 631: PPUSH
 632: CALL_OW 69
 636: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 637: LD_VAR 0 6
 641: PPUSH
 642: LD_STRING Gamma
 644: PPUSH
 645: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 649: LD_VAR 0 6
 653: PPUSH
 654: CALL_OW 274
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 10000
 664: PPUSH
 665: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 669: LD_VAR 0 6
 673: PPUSH
 674: CALL_OW 274
 678: PPUSH
 679: LD_INT 1
 681: PPUSH
 682: LD_INT 10000
 684: PPUSH
 685: CALL_OW 277
// if dep then
 689: LD_VAR 0 6
 693: IFFALSE 775
// begin if Brown then
 695: LD_EXP 12
 699: IFFALSE 735
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 701: LD_EXP 12
 705: PPUSH
 706: LD_VAR 0 6
 710: PUSH
 711: LD_INT 1
 713: ARRAY
 714: PPUSH
 715: CALL_OW 52
// team := team diff Brown ;
 719: LD_ADDR_VAR 0 5
 723: PUSH
 724: LD_VAR 0 5
 728: PUSH
 729: LD_EXP 12
 733: DIFF
 734: ST_TO_ADDR
// end ; if Donaldson then
 735: LD_EXP 11
 739: IFFALSE 775
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 741: LD_EXP 11
 745: PPUSH
 746: LD_VAR 0 6
 750: PUSH
 751: LD_INT 1
 753: ARRAY
 754: PPUSH
 755: CALL_OW 52
// team := team diff Donaldson ;
 759: LD_ADDR_VAR 0 5
 763: PUSH
 764: LD_VAR 0 5
 768: PUSH
 769: LD_EXP 11
 773: DIFF
 774: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 775: LD_VAR 0 10
 779: PUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: LD_INT 25
 787: PUSH
 788: LD_INT 1
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PPUSH
 795: CALL_OW 72
 799: AND
 800: IFFALSE 905
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 802: LD_ADDR_VAR 0 11
 806: PUSH
 807: LD_VAR 0 5
 811: PPUSH
 812: LD_INT 25
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL_OW 72
 826: ST_TO_ADDR
// for i in bun do
 827: LD_ADDR_VAR 0 12
 831: PUSH
 832: LD_VAR 0 10
 836: PUSH
 837: FOR_IN
 838: IFFALSE 887
// begin if not filter then
 840: LD_VAR 0 11
 844: NOT
 845: IFFALSE 849
// break ;
 847: GO 887
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 849: LD_VAR 0 11
 853: PUSH
 854: LD_INT 1
 856: ARRAY
 857: PPUSH
 858: LD_VAR 0 12
 862: PPUSH
 863: CALL_OW 52
// filter := Delete ( filter , 1 ) ;
 867: LD_ADDR_VAR 0 11
 871: PUSH
 872: LD_VAR 0 11
 876: PPUSH
 877: LD_INT 1
 879: PPUSH
 880: CALL_OW 3
 884: ST_TO_ADDR
// end ;
 885: GO 837
 887: POP
 888: POP
// team := team diff filter ;
 889: LD_ADDR_VAR 0 5
 893: PUSH
 894: LD_VAR 0 5
 898: PUSH
 899: LD_VAR 0 11
 903: DIFF
 904: ST_TO_ADDR
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
 905: LD_VAR 0 7
 909: PUSH
 910: LD_VAR 0 5
 914: PPUSH
 915: LD_INT 25
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: PPUSH
 925: CALL_OW 72
 929: AND
 930: IFFALSE 1052
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 932: LD_ADDR_VAR 0 11
 936: PUSH
 937: LD_VAR 0 5
 941: PPUSH
 942: LD_INT 25
 944: PUSH
 945: LD_INT 1
 947: PUSH
 948: EMPTY
 949: LIST
 950: LIST
 951: PPUSH
 952: CALL_OW 72
 956: ST_TO_ADDR
// for i = 1 to filter do
 957: LD_ADDR_VAR 0 12
 961: PUSH
 962: DOUBLE
 963: LD_INT 1
 965: DEC
 966: ST_TO_ADDR
 967: LD_VAR 0 11
 971: PUSH
 972: FOR_TO
 973: IFFALSE 1034
// begin if ( i <= 6 ) then
 975: LD_VAR 0 12
 979: PUSH
 980: LD_INT 6
 982: LESSEQUAL
 983: IFFALSE 1011
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
 985: LD_VAR 0 11
 989: PUSH
 990: LD_VAR 0 12
 994: ARRAY
 995: PPUSH
 996: LD_VAR 0 7
1000: PUSH
1001: LD_INT 1
1003: ARRAY
1004: PPUSH
1005: CALL_OW 52
1009: GO 1032
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1011: LD_VAR 0 11
1015: PUSH
1016: LD_VAR 0 12
1020: ARRAY
1021: PPUSH
1022: LD_INT 1
1024: PPUSH
1025: LD_INT 0
1027: PPUSH
1028: CALL_OW 49
// end ;
1032: GO 972
1034: POP
1035: POP
// team := team diff filter ;
1036: LD_ADDR_VAR 0 5
1040: PUSH
1041: LD_VAR 0 5
1045: PUSH
1046: LD_VAR 0 11
1050: DIFF
1051: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1052: LD_VAR 0 8
1056: PUSH
1057: LD_VAR 0 5
1061: PPUSH
1062: LD_INT 25
1064: PUSH
1065: LD_INT 4
1067: PUSH
1068: EMPTY
1069: LIST
1070: LIST
1071: PPUSH
1072: CALL_OW 72
1076: AND
1077: IFFALSE 1199
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1079: LD_ADDR_VAR 0 11
1083: PUSH
1084: LD_VAR 0 5
1088: PPUSH
1089: LD_INT 25
1091: PUSH
1092: LD_INT 4
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: PPUSH
1099: CALL_OW 72
1103: ST_TO_ADDR
// for i = 1 to filter do
1104: LD_ADDR_VAR 0 12
1108: PUSH
1109: DOUBLE
1110: LD_INT 1
1112: DEC
1113: ST_TO_ADDR
1114: LD_VAR 0 11
1118: PUSH
1119: FOR_TO
1120: IFFALSE 1181
// begin if ( i <= 6 ) then
1122: LD_VAR 0 12
1126: PUSH
1127: LD_INT 6
1129: LESSEQUAL
1130: IFFALSE 1158
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1132: LD_VAR 0 11
1136: PUSH
1137: LD_VAR 0 12
1141: ARRAY
1142: PPUSH
1143: LD_VAR 0 8
1147: PUSH
1148: LD_INT 1
1150: ARRAY
1151: PPUSH
1152: CALL_OW 52
1156: GO 1179
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1158: LD_VAR 0 11
1162: PUSH
1163: LD_VAR 0 12
1167: ARRAY
1168: PPUSH
1169: LD_INT 1
1171: PPUSH
1172: LD_INT 0
1174: PPUSH
1175: CALL_OW 49
// end ;
1179: GO 1119
1181: POP
1182: POP
// team := team diff filter ;
1183: LD_ADDR_VAR 0 5
1187: PUSH
1188: LD_VAR 0 5
1192: PUSH
1193: LD_VAR 0 11
1197: DIFF
1198: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1199: LD_VAR 0 9
1203: PUSH
1204: LD_VAR 0 5
1208: PPUSH
1209: LD_INT 25
1211: PUSH
1212: LD_INT 3
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 72
1223: AND
1224: IFFALSE 1346
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1226: LD_ADDR_VAR 0 11
1230: PUSH
1231: LD_VAR 0 5
1235: PPUSH
1236: LD_INT 25
1238: PUSH
1239: LD_INT 3
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: PPUSH
1246: CALL_OW 72
1250: ST_TO_ADDR
// for i = 1 to filter do
1251: LD_ADDR_VAR 0 12
1255: PUSH
1256: DOUBLE
1257: LD_INT 1
1259: DEC
1260: ST_TO_ADDR
1261: LD_VAR 0 11
1265: PUSH
1266: FOR_TO
1267: IFFALSE 1328
// begin if ( i <= 6 ) then
1269: LD_VAR 0 12
1273: PUSH
1274: LD_INT 6
1276: LESSEQUAL
1277: IFFALSE 1305
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1279: LD_VAR 0 11
1283: PUSH
1284: LD_VAR 0 12
1288: ARRAY
1289: PPUSH
1290: LD_VAR 0 9
1294: PUSH
1295: LD_INT 1
1297: ARRAY
1298: PPUSH
1299: CALL_OW 52
1303: GO 1326
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1305: LD_VAR 0 11
1309: PUSH
1310: LD_VAR 0 12
1314: ARRAY
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL_OW 49
// end ;
1326: GO 1266
1328: POP
1329: POP
// team := team diff filter ;
1330: LD_ADDR_VAR 0 5
1334: PUSH
1335: LD_VAR 0 5
1339: PUSH
1340: LD_VAR 0 11
1344: DIFF
1345: ST_TO_ADDR
// end ; if team then
1346: LD_VAR 0 5
1350: IFFALSE 1393
// for i in team do
1352: LD_ADDR_VAR 0 12
1356: PUSH
1357: LD_VAR 0 5
1361: PUSH
1362: FOR_IN
1363: IFFALSE 1391
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1365: LD_VAR 0 12
1369: PPUSH
1370: LD_INT 1
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// ComHold ( i ) ;
1380: LD_VAR 0 12
1384: PPUSH
1385: CALL_OW 140
// end ;
1389: GO 1362
1391: POP
1392: POP
// if fac then
1393: LD_VAR 0 9
1397: IFFALSE 1433
// if UnitsInside ( fac [ 1 ] ) then
1399: LD_VAR 0 9
1403: PUSH
1404: LD_INT 1
1406: ARRAY
1407: PPUSH
1408: CALL_OW 313
1412: IFFALSE 1433
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1414: LD_VAR 0 9
1418: PUSH
1419: LD_INT 1
1421: ARRAY
1422: PPUSH
1423: LD_INT 10
1425: PPUSH
1426: LD_INT 0
1428: PPUSH
1429: CALL_OW 486
// if lab then
1433: LD_VAR 0 8
1437: IFFALSE 1473
// if UnitsInside ( lab [ 1 ] ) then
1439: LD_VAR 0 8
1443: PUSH
1444: LD_INT 1
1446: ARRAY
1447: PPUSH
1448: CALL_OW 313
1452: IFFALSE 1473
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1454: LD_VAR 0 8
1458: PUSH
1459: LD_INT 1
1461: ARRAY
1462: PPUSH
1463: LD_INT 10
1465: PPUSH
1466: LD_INT 0
1468: PPUSH
1469: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1473: LD_ADDR_VAR 0 4
1477: PUSH
1478: LD_INT 1
1480: PPUSH
1481: LD_INT 1
1483: PPUSH
1484: LD_INT 1
1486: PPUSH
1487: LD_INT 2
1489: PPUSH
1490: LD_INT 1
1492: PPUSH
1493: LD_INT 3
1495: PPUSH
1496: LD_INT 100
1498: PPUSH
1499: CALL 4241 0 7
1503: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1504: LD_VAR 0 4
1508: PPUSH
1509: LD_INT 2
1511: PPUSH
1512: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1516: LD_VAR 0 4
1520: PPUSH
1521: LD_INT 21
1523: PPUSH
1524: LD_INT 8
1526: PPUSH
1527: LD_INT 0
1529: PPUSH
1530: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1534: LD_EXP 5
1538: PPUSH
1539: LD_VAR 0 4
1543: PPUSH
1544: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1548: LD_ADDR_VAR 0 4
1552: PUSH
1553: LD_INT 1
1555: PPUSH
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 1
1561: PPUSH
1562: LD_INT 2
1564: PPUSH
1565: LD_INT 1
1567: PPUSH
1568: LD_INT 2
1570: PPUSH
1571: LD_INT 100
1573: PPUSH
1574: CALL 4241 0 7
1578: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1579: LD_VAR 0 4
1583: PPUSH
1584: LD_INT 2
1586: PPUSH
1587: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1591: LD_VAR 0 4
1595: PPUSH
1596: LD_INT 16
1598: PPUSH
1599: LD_INT 3
1601: PPUSH
1602: LD_INT 0
1604: PPUSH
1605: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1609: LD_EXP 6
1613: PPUSH
1614: LD_VAR 0 4
1618: PPUSH
1619: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1623: LD_ADDR_VAR 0 4
1627: PUSH
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 2
1636: PPUSH
1637: LD_INT 2
1639: PPUSH
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 12
1645: PPUSH
1646: LD_INT 100
1648: PPUSH
1649: CALL 4241 0 7
1653: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1654: LD_VAR 0 4
1658: PPUSH
1659: LD_INT 0
1661: PPUSH
1662: LD_INT 5
1664: PPUSH
1665: CALL_OW 12
1669: PPUSH
1670: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1674: LD_VAR 0 4
1678: PPUSH
1679: LD_INT 1
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: CALL_OW 49
// end ;
1689: LD_VAR 0 1
1693: RET
// function PrepareBase ; var blist , i , b ; begin
1694: LD_INT 0
1696: PPUSH
1697: PPUSH
1698: PPUSH
1699: PPUSH
// blist := LoadVariable ( GammaBase , [ ] ) ;
1700: LD_ADDR_VAR 0 2
1704: PUSH
1705: LD_STRING GammaBase
1707: PPUSH
1708: EMPTY
1709: PPUSH
1710: CALL_OW 30
1714: ST_TO_ADDR
// if not blist and debug then
1715: LD_VAR 0 2
1719: NOT
1720: PUSH
1721: LD_EXP 1
1725: AND
1726: IFFALSE 1766
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1728: LD_ADDR_VAR 0 2
1732: PUSH
1733: LD_INT 0
1735: PUSH
1736: LD_INT 51
1738: PUSH
1739: LD_INT 10
1741: PUSH
1742: LD_INT 3
1744: PUSH
1745: LD_INT 3
1747: PUSH
1748: LD_INT 0
1750: PUSH
1751: LD_INT 0
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: PUSH
1763: EMPTY
1764: LIST
1765: ST_TO_ADDR
// if not blist then
1766: LD_VAR 0 2
1770: NOT
1771: IFFALSE 1775
// exit ;
1773: GO 1959
// uc_side := 1 ;
1775: LD_ADDR_OWVAR 20
1779: PUSH
1780: LD_INT 1
1782: ST_TO_ADDR
// uc_nation := 1 ;
1783: LD_ADDR_OWVAR 21
1787: PUSH
1788: LD_INT 1
1790: ST_TO_ADDR
// for i in blist do
1791: LD_ADDR_VAR 0 3
1795: PUSH
1796: LD_VAR 0 2
1800: PUSH
1801: FOR_IN
1802: IFFALSE 1957
// begin bc_type := i [ 1 ] ;
1804: LD_ADDR_OWVAR 42
1808: PUSH
1809: LD_VAR 0 3
1813: PUSH
1814: LD_INT 1
1816: ARRAY
1817: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1818: LD_ADDR_OWVAR 43
1822: PUSH
1823: LD_VAR 0 3
1827: PUSH
1828: LD_INT 5
1830: ARRAY
1831: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1832: LD_VAR 0 3
1836: PUSH
1837: LD_INT 1
1839: ARRAY
1840: PUSH
1841: LD_INT 7
1843: PUSH
1844: LD_INT 8
1846: PUSH
1847: EMPTY
1848: LIST
1849: LIST
1850: IN
1851: IFFALSE 1881
// begin bc_kind1 := i [ 7 ] ;
1853: LD_ADDR_OWVAR 44
1857: PUSH
1858: LD_VAR 0 3
1862: PUSH
1863: LD_INT 7
1865: ARRAY
1866: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1867: LD_ADDR_OWVAR 45
1871: PUSH
1872: LD_VAR 0 3
1876: PUSH
1877: LD_INT 8
1879: ARRAY
1880: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1881: LD_ADDR_VAR 0 4
1885: PUSH
1886: LD_VAR 0 3
1890: PUSH
1891: LD_INT 2
1893: ARRAY
1894: PPUSH
1895: LD_VAR 0 3
1899: PUSH
1900: LD_INT 3
1902: ARRAY
1903: PPUSH
1904: LD_VAR 0 3
1908: PUSH
1909: LD_INT 4
1911: ARRAY
1912: PPUSH
1913: CALL_OW 47
1917: ST_TO_ADDR
// if GetBType ( i [ 1 ] ) = b_bunker then
1918: LD_VAR 0 3
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: CALL_OW 266
1931: PUSH
1932: LD_INT 32
1934: EQUAL
1935: IFFALSE 1955
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
1937: LD_VAR 0 4
1941: PPUSH
1942: LD_VAR 0 3
1946: PUSH
1947: LD_INT 7
1949: ARRAY
1950: PPUSH
1951: CALL_OW 431
// end ; end ;
1955: GO 1801
1957: POP
1958: POP
// end ; end_of_file
1959: LD_VAR 0 1
1963: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
1964: LD_INT 0
1966: PPUSH
1967: PPUSH
1968: PPUSH
1969: PPUSH
1970: PPUSH
1971: PPUSH
1972: PPUSH
1973: PPUSH
// InGameOn ;
1974: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
1978: LD_INT 33
1980: PPUSH
1981: LD_INT 11
1983: PPUSH
1984: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
1988: LD_ADDR_VAR 0 2
1992: PUSH
1993: LD_INT 29
1995: PUSH
1996: LD_INT 21
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 41
2005: PUSH
2006: LD_INT 28
2008: PUSH
2009: EMPTY
2010: LIST
2011: LIST
2012: PUSH
2013: LD_INT 52
2015: PUSH
2016: LD_INT 26
2018: PUSH
2019: EMPTY
2020: LIST
2021: LIST
2022: PUSH
2023: LD_INT 49
2025: PUSH
2026: LD_INT 16
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: ST_TO_ADDR
// for i in points do
2039: LD_ADDR_VAR 0 3
2043: PUSH
2044: LD_VAR 0 2
2048: PUSH
2049: FOR_IN
2050: IFFALSE 2090
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2052: LD_EXP 5
2056: PUSH
2057: LD_EXP 6
2061: PUSH
2062: EMPTY
2063: LIST
2064: LIST
2065: PPUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 1
2073: ARRAY
2074: PPUSH
2075: LD_VAR 0 3
2079: PUSH
2080: LD_INT 2
2082: ARRAY
2083: PPUSH
2084: CALL_OW 171
2088: GO 2049
2090: POP
2091: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2092: LD_EXP 5
2096: PUSH
2097: LD_EXP 6
2101: PUSH
2102: EMPTY
2103: LIST
2104: LIST
2105: PPUSH
2106: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2110: LD_INT 35
2112: PPUSH
2113: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2117: LD_EXP 5
2121: PPUSH
2122: CALL_OW 310
2126: NOT
2127: PUSH
2128: LD_EXP 6
2132: PPUSH
2133: CALL_OW 310
2137: NOT
2138: AND
2139: IFFALSE 2110
// ComTurnUnit ( JMM , Gladstone ) ;
2141: LD_EXP 5
2145: PPUSH
2146: LD_EXP 6
2150: PPUSH
2151: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2155: LD_EXP 6
2159: PPUSH
2160: LD_EXP 5
2164: PPUSH
2165: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2169: LD_ADDR_VAR 0 4
2173: PUSH
2174: LD_INT 26
2176: PUSH
2177: LD_INT 1
2179: PUSH
2180: EMPTY
2181: LIST
2182: LIST
2183: PPUSH
2184: CALL_OW 69
2188: PUSH
2189: LD_EXP 5
2193: PUSH
2194: LD_EXP 6
2198: PUSH
2199: LD_EXP 10
2203: PUSH
2204: LD_EXP 9
2208: PUSH
2209: LD_EXP 7
2213: PUSH
2214: LD_EXP 12
2218: PUSH
2219: EMPTY
2220: LIST
2221: LIST
2222: LIST
2223: LIST
2224: LIST
2225: LIST
2226: DIFF
2227: ST_TO_ADDR
// if sol then
2228: LD_VAR 0 4
2232: IFFALSE 2248
// sol := sol [ 1 ] ;
2234: LD_ADDR_VAR 0 4
2238: PUSH
2239: LD_VAR 0 4
2243: PUSH
2244: LD_INT 1
2246: ARRAY
2247: ST_TO_ADDR
// team := [ ] ;
2248: LD_ADDR_VAR 0 5
2252: PUSH
2253: EMPTY
2254: ST_TO_ADDR
// if sol then
2255: LD_VAR 0 4
2259: IFFALSE 2277
// team := team ^ sol ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_VAR 0 4
2275: ADD
2276: ST_TO_ADDR
// if Lisa then
2277: LD_EXP 8
2281: IFFALSE 2299
// team := team ^ Lisa ;
2283: LD_ADDR_VAR 0 5
2287: PUSH
2288: LD_VAR 0 5
2292: PUSH
2293: LD_EXP 8
2297: ADD
2298: ST_TO_ADDR
// if Donaldson then
2299: LD_EXP 11
2303: IFFALSE 2321
// team := team ^ Donaldson ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 11
2319: ADD
2320: ST_TO_ADDR
// if Brown then
2321: LD_EXP 12
2325: IFFALSE 2343
// team := team ^ Brown ;
2327: LD_ADDR_VAR 0 5
2331: PUSH
2332: LD_VAR 0 5
2336: PUSH
2337: LD_EXP 12
2341: ADD
2342: ST_TO_ADDR
// if Bobby then
2343: LD_EXP 10
2347: IFFALSE 2365
// team := team ^ Bobby ;
2349: LD_ADDR_VAR 0 5
2353: PUSH
2354: LD_VAR 0 5
2358: PUSH
2359: LD_EXP 10
2363: ADD
2364: ST_TO_ADDR
// if Cyrus then
2365: LD_EXP 9
2369: IFFALSE 2387
// team := team ^ Cyrus ;
2371: LD_ADDR_VAR 0 5
2375: PUSH
2376: LD_VAR 0 5
2380: PUSH
2381: LD_EXP 9
2385: ADD
2386: ST_TO_ADDR
// if Frank then
2387: LD_EXP 7
2391: IFFALSE 2409
// team := team ^ Frank ;
2393: LD_ADDR_VAR 0 5
2397: PUSH
2398: LD_VAR 0 5
2402: PUSH
2403: LD_EXP 7
2407: ADD
2408: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2409: LD_ADDR_VAR 0 3
2413: PUSH
2414: LD_INT 1
2416: PPUSH
2417: LD_INT 3
2419: PUSH
2420: LD_INT 54
2422: PUSH
2423: EMPTY
2424: LIST
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PUSH
2430: LD_INT 21
2432: PUSH
2433: LD_INT 1
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: PPUSH
2444: CALL_OW 70
2448: PUSH
2449: LD_EXP 5
2453: PUSH
2454: LD_EXP 6
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: DIFF
2463: PUSH
2464: EMPTY
2465: LIST
2466: PUSH
2467: FOR_IN
2468: IFFALSE 2488
// team := team ^ i ;
2470: LD_ADDR_VAR 0 5
2474: PUSH
2475: LD_VAR 0 5
2479: PUSH
2480: LD_VAR 0 3
2484: ADD
2485: ST_TO_ADDR
2486: GO 2467
2488: POP
2489: POP
// if team then
2490: LD_VAR 0 5
2494: IFFALSE 2570
// begin ComExitBuilding ( team ) ;
2496: LD_VAR 0 5
2500: PPUSH
2501: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2505: LD_VAR 0 5
2509: PPUSH
2510: LD_EXP 5
2514: PPUSH
2515: CALL_OW 172
// repeat wait ( 1 ) ;
2519: LD_INT 1
2521: PPUSH
2522: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2526: LD_EXP 5
2530: PPUSH
2531: LD_VAR 0 5
2535: PPUSH
2536: LD_EXP 5
2540: PPUSH
2541: CALL_OW 74
2545: PPUSH
2546: CALL_OW 296
2550: PUSH
2551: LD_INT 6
2553: LESS
2554: IFFALSE 2519
// ComTurnUnit ( team , JMM ) ;
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_EXP 5
2565: PPUSH
2566: CALL_OW 119
// end ; if Lisa then
2570: LD_EXP 8
2574: IFFALSE 2602
// begin ComTurnUnit ( JMM , Lisa ) ;
2576: LD_EXP 5
2580: PPUSH
2581: LD_EXP 8
2585: PPUSH
2586: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2590: LD_EXP 8
2594: PPUSH
2595: LD_STRING D1-Lisa-1
2597: PPUSH
2598: CALL_OW 88
// end ; if sol then
2602: LD_VAR 0 4
2606: IFFALSE 2634
// begin ComTurnUnit ( JMM , sol ) ;
2608: LD_EXP 5
2612: PPUSH
2613: LD_VAR 0 4
2617: PPUSH
2618: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2622: LD_VAR 0 4
2626: PPUSH
2627: LD_STRING D1-Sol1-1
2629: PPUSH
2630: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2634: LD_EXP 5
2638: PPUSH
2639: LD_STRING D1-JMM-1
2641: PPUSH
2642: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2646: LD_EXP 5
2650: PPUSH
2651: LD_STRING D1-JMM-1a
2653: PPUSH
2654: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2658: LD_EXP 5
2662: PPUSH
2663: LD_EXP 6
2667: PPUSH
2668: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2672: LD_VAR 0 5
2676: PPUSH
2677: LD_EXP 6
2681: PPUSH
2682: CALL_OW 119
// if Frank then
2686: LD_EXP 7
2690: IFFALSE 2718
// begin Say ( Frank , D1-Frank-1 ) ;
2692: LD_EXP 7
2696: PPUSH
2697: LD_STRING D1-Frank-1
2699: PPUSH
2700: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2704: LD_EXP 5
2708: PPUSH
2709: LD_EXP 7
2713: PPUSH
2714: CALL_OW 119
// end ; if Lisa then
2718: LD_EXP 8
2722: IFFALSE 2750
// begin ComTurnUnit ( JMM , Lisa ) ;
2724: LD_EXP 5
2728: PPUSH
2729: LD_EXP 8
2733: PPUSH
2734: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2738: LD_EXP 8
2742: PPUSH
2743: LD_STRING D1-Lisa-2
2745: PPUSH
2746: CALL_OW 88
// end ; if sol then
2750: LD_VAR 0 4
2754: IFFALSE 2782
// begin ComTurnUnit ( JMM , sol ) ;
2756: LD_EXP 5
2760: PPUSH
2761: LD_VAR 0 4
2765: PPUSH
2766: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2770: LD_VAR 0 4
2774: PPUSH
2775: LD_STRING D1-Sol1-2
2777: PPUSH
2778: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2782: LD_EXP 6
2786: PPUSH
2787: LD_STRING D1-Glad-2
2789: PPUSH
2790: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2794: LD_VAR 0 5
2798: PPUSH
2799: LD_EXP 5
2803: PPUSH
2804: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2808: LD_EXP 5
2812: PPUSH
2813: LD_STRING D1-JMM-2
2815: PPUSH
2816: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2820: LD_EXP 5
2824: PPUSH
2825: LD_EXP 6
2829: PPUSH
2830: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2834: LD_EXP 6
2838: PPUSH
2839: LD_STRING D1-Glad-3
2841: PPUSH
2842: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2846: LD_EXP 5
2850: PPUSH
2851: LD_STRING D1-JMM-3
2853: PPUSH
2854: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2858: LD_EXP 6
2862: PPUSH
2863: LD_STRING D1-Glad-4
2865: PPUSH
2866: CALL_OW 88
// if Frank then
2870: LD_EXP 7
2874: IFFALSE 2902
// begin ComTurnUnit ( JMM , Frank ) ;
2876: LD_EXP 5
2880: PPUSH
2881: LD_EXP 7
2885: PPUSH
2886: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2890: LD_EXP 7
2894: PPUSH
2895: LD_STRING D1-Frank-4
2897: PPUSH
2898: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
2902: LD_EXP 5
2906: PPUSH
2907: LD_EXP 6
2911: PPUSH
2912: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
2916: LD_EXP 5
2920: PPUSH
2921: LD_STRING D1-JMM-4
2923: PPUSH
2924: CALL_OW 88
// if Lisa then
2928: LD_EXP 8
2932: IFFALSE 2999
// begin Say ( Lisa , D1-Lisa-4 ) ;
2934: LD_EXP 8
2938: PPUSH
2939: LD_STRING D1-Lisa-4
2941: PPUSH
2942: CALL_OW 88
// if Frank then
2946: LD_EXP 7
2950: IFFALSE 2999
// begin ComTurnUnit ( Frank , Lisa ) ;
2952: LD_EXP 7
2956: PPUSH
2957: LD_EXP 8
2961: PPUSH
2962: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
2966: LD_EXP 7
2970: PPUSH
2971: LD_STRING D1-Frank-5
2973: PPUSH
2974: CALL_OW 88
// Wait ( 3 ) ;
2978: LD_INT 3
2980: PPUSH
2981: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
2985: LD_EXP 7
2989: PPUSH
2990: LD_EXP 5
2994: PPUSH
2995: CALL_OW 179
// end ; end ; if sol then
2999: LD_VAR 0 4
3003: IFFALSE 3017
// Say ( sol , D1-Sol1-5 ) ;
3005: LD_VAR 0 4
3009: PPUSH
3010: LD_STRING D1-Sol1-5
3012: PPUSH
3013: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3017: LD_EXP 5
3021: PPUSH
3022: LD_STRING D1-JMM-5
3024: PPUSH
3025: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3029: LD_EXP 6
3033: PPUSH
3034: LD_STRING D1-Glad-5
3036: PPUSH
3037: CALL_OW 88
// if Frank then
3041: LD_EXP 7
3045: IFFALSE 3059
// Say ( Frank , D1-Frank-6 ) ;
3047: LD_EXP 7
3051: PPUSH
3052: LD_STRING D1-Frank-6
3054: PPUSH
3055: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3059: LD_EXP 5
3063: PPUSH
3064: LD_STRING D1-JMM-6
3066: PPUSH
3067: CALL_OW 88
// if Brown and Donaldson then
3071: LD_EXP 12
3075: PUSH
3076: LD_EXP 11
3080: AND
3081: IFFALSE 3130
// case Query ( QCommander ) of 1 :
3083: LD_STRING QCommander
3085: PPUSH
3086: CALL_OW 97
3090: PUSH
3091: LD_INT 1
3093: DOUBLE
3094: EQUAL
3095: IFTRUE 3099
3097: GO 3110
3099: POP
// donaldson_commander := true ; 2 :
3100: LD_ADDR_EXP 2
3104: PUSH
3105: LD_INT 1
3107: ST_TO_ADDR
3108: GO 3130
3110: LD_INT 2
3112: DOUBLE
3113: EQUAL
3114: IFTRUE 3118
3116: GO 3129
3118: POP
// brown_commander := true ; end ;
3119: LD_ADDR_EXP 3
3123: PUSH
3124: LD_INT 1
3126: ST_TO_ADDR
3127: GO 3130
3129: POP
// if not Brown and Donaldson then
3130: LD_EXP 12
3134: NOT
3135: PUSH
3136: LD_EXP 11
3140: AND
3141: IFFALSE 3151
// donaldson_commander := true ;
3143: LD_ADDR_EXP 2
3147: PUSH
3148: LD_INT 1
3150: ST_TO_ADDR
// if Brown and not Donaldson then
3151: LD_EXP 12
3155: PUSH
3156: LD_EXP 11
3160: NOT
3161: AND
3162: IFFALSE 3172
// brown_commander := true ;
3164: LD_ADDR_EXP 3
3168: PUSH
3169: LD_INT 1
3171: ST_TO_ADDR
// if donaldson_commander then
3172: LD_EXP 2
3176: IFFALSE 3323
// begin ComTurnUnit ( JMM , Donaldson ) ;
3178: LD_EXP 5
3182: PPUSH
3183: LD_EXP 11
3187: PPUSH
3188: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3192: LD_EXP 5
3196: PPUSH
3197: LD_STRING D1a-JMM-1
3199: PPUSH
3200: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3204: LD_EXP 11
3208: PPUSH
3209: LD_EXP 5
3213: PPUSH
3214: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3218: LD_EXP 11
3222: PPUSH
3223: LD_EXP 5
3227: PPUSH
3228: CALL_OW 179
// Wait ( 3 ) ;
3232: LD_INT 3
3234: PPUSH
3235: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3239: LD_EXP 11
3243: PPUSH
3244: LD_STRING D1a-Don-1
3246: PPUSH
3247: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3251: LD_EXP 5
3255: PPUSH
3256: LD_STRING D1b-JMM-2
3258: PPUSH
3259: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3263: LD_EXP 11
3267: PPUSH
3268: LD_STRING D1a-Don-2
3270: PPUSH
3271: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3275: LD_EXP 11
3279: PPUSH
3280: LD_INT 30
3282: PUSH
3283: LD_INT 0
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PPUSH
3290: CALL_OW 69
3294: PUSH
3295: LD_INT 1
3297: ARRAY
3298: PPUSH
3299: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3303: LD_INT 1
3305: PPUSH
3306: LD_STRING GammaCommander
3308: PPUSH
3309: CALL_OW 39
// commander := Donaldson ;
3313: LD_ADDR_VAR 0 7
3317: PUSH
3318: LD_EXP 11
3322: ST_TO_ADDR
// end ; if brown_commander then
3323: LD_EXP 3
3327: IFFALSE 3474
// begin ComTurnUnit ( JMM , Brown ) ;
3329: LD_EXP 5
3333: PPUSH
3334: LD_EXP 12
3338: PPUSH
3339: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3343: LD_EXP 5
3347: PPUSH
3348: LD_STRING D1b-JMM-1
3350: PPUSH
3351: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3355: LD_EXP 12
3359: PPUSH
3360: LD_EXP 5
3364: PPUSH
3365: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3369: LD_EXP 12
3373: PPUSH
3374: LD_EXP 5
3378: PPUSH
3379: CALL_OW 179
// Wait ( 3 ) ;
3383: LD_INT 3
3385: PPUSH
3386: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3390: LD_EXP 12
3394: PPUSH
3395: LD_STRING D1b-Brown-1
3397: PPUSH
3398: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3402: LD_EXP 5
3406: PPUSH
3407: LD_STRING D1a-JMM-2
3409: PPUSH
3410: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3414: LD_EXP 12
3418: PPUSH
3419: LD_STRING D1b-Brown-2
3421: PPUSH
3422: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3426: LD_EXP 12
3430: PPUSH
3431: LD_INT 30
3433: PUSH
3434: LD_INT 0
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: PPUSH
3441: CALL_OW 69
3445: PUSH
3446: LD_INT 1
3448: ARRAY
3449: PPUSH
3450: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3454: LD_INT 2
3456: PPUSH
3457: LD_STRING GammaCommander
3459: PPUSH
3460: CALL_OW 39
// commander := Brown ;
3464: LD_ADDR_VAR 0 7
3468: PUSH
3469: LD_EXP 12
3473: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3474: LD_EXP 5
3478: PPUSH
3479: LD_EXP 6
3483: PPUSH
3484: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3488: LD_EXP 2
3492: NOT
3493: PUSH
3494: LD_EXP 3
3498: NOT
3499: AND
3500: IFFALSE 3524
// begin Say ( JMM , D1c-JMM-1 ) ;
3502: LD_EXP 5
3506: PPUSH
3507: LD_STRING D1c-JMM-1
3509: PPUSH
3510: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3514: LD_INT 3
3516: PPUSH
3517: LD_STRING GammaCommander
3519: PPUSH
3520: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3524: LD_EXP 5
3528: PPUSH
3529: LD_STRING D1d-JMM-1
3531: PPUSH
3532: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3536: LD_ADDR_VAR 0 6
3540: PUSH
3541: LD_INT 21
3543: PUSH
3544: LD_INT 1
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: PPUSH
3551: CALL_OW 69
3555: PUSH
3556: LD_EXP 5
3560: PUSH
3561: LD_EXP 6
3565: PUSH
3566: LD_VAR 0 7
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: DIFF
3576: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3577: LD_ADDR_EXP 4
3581: PUSH
3582: LD_STRING 1
3584: PPUSH
3585: LD_INT 5
3587: PPUSH
3588: LD_INT 5
3590: PPUSH
3591: LD_INT -5
3593: PUSH
3594: LD_EXP 5
3598: PUSH
3599: LD_INT -6
3601: PUSH
3602: LD_EXP 6
3606: PUSH
3607: LD_INT -2
3609: PUSH
3610: LD_INT -3
3612: PUSH
3613: LD_INT -5
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: LIST
3623: LIST
3624: PUSH
3625: LD_VAR 0 6
3629: ADD
3630: PUSH
3631: LD_INT -6
3633: PUSH
3634: LD_INT -4
3636: PUSH
3637: LD_VAR 0 7
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: ADD
3647: PPUSH
3648: LD_INT 1
3650: PUSH
3651: LD_INT 3
3653: PUSH
3654: LD_INT 2
3656: PUSH
3657: LD_INT 1
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PUSH
3664: LD_INT 4
3666: PUSH
3667: EMPTY
3668: LIST
3669: LIST
3670: LIST
3671: LIST
3672: PPUSH
3673: CALL_OW 42
3677: ST_TO_ADDR
// SaveCharacters ( all diff [ save_group , JMM , Gladstone ] , othersGamma ) ;
3678: LD_VAR 0 6
3682: PUSH
3683: LD_EXP 4
3687: PUSH
3688: LD_EXP 5
3692: PUSH
3693: LD_EXP 6
3697: PUSH
3698: EMPTY
3699: LIST
3700: LIST
3701: LIST
3702: DIFF
3703: PPUSH
3704: LD_STRING othersGamma
3706: PPUSH
3707: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
3711: LD_EXP 4
3715: PUSH
3716: LD_EXP 5
3720: PUSH
3721: LD_EXP 6
3725: PUSH
3726: LD_EXP 8
3730: PUSH
3731: LD_EXP 9
3735: PUSH
3736: LD_EXP 10
3740: PUSH
3741: LD_EXP 7
3745: PUSH
3746: LD_EXP 11
3750: PUSH
3751: LD_EXP 12
3755: PUSH
3756: LD_INT 0
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: LIST
3766: LIST
3767: LIST
3768: LIST
3769: DIFF
3770: PPUSH
3771: LD_STRING othersDelta
3773: PPUSH
3774: CALL_OW 38
// if Lisa in save_group then
3778: LD_EXP 8
3782: PUSH
3783: LD_EXP 4
3787: IN
3788: IFFALSE 3812
// begin SaveCharacters ( Lisa , Lisa ) ;
3790: LD_EXP 8
3794: PPUSH
3795: LD_STRING Lisa
3797: PPUSH
3798: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
3802: LD_INT 1
3804: PPUSH
3805: LD_STRING LisaInDelta
3807: PPUSH
3808: CALL_OW 39
// end ; if Bobby in save_group then
3812: LD_EXP 10
3816: PUSH
3817: LD_EXP 4
3821: IN
3822: IFFALSE 3846
// begin SaveCharacters ( Bobby , Bobby ) ;
3824: LD_EXP 10
3828: PPUSH
3829: LD_STRING Bobby
3831: PPUSH
3832: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
3836: LD_INT 1
3838: PPUSH
3839: LD_STRING BobbyInDelta
3841: PPUSH
3842: CALL_OW 39
// end ; if Cyrus in save_group then
3846: LD_EXP 9
3850: PUSH
3851: LD_EXP 4
3855: IN
3856: IFFALSE 3880
// begin SaveCharacters ( Cyrus , Cyrus ) ;
3858: LD_EXP 9
3862: PPUSH
3863: LD_STRING Cyrus
3865: PPUSH
3866: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
3870: LD_INT 1
3872: PPUSH
3873: LD_STRING CyrusInDelta
3875: PPUSH
3876: CALL_OW 39
// end ; if Frank in save_group then
3880: LD_EXP 7
3884: PUSH
3885: LD_EXP 4
3889: IN
3890: IFFALSE 3914
// begin SaveCharacters ( Frank , Frank ) ;
3892: LD_EXP 7
3896: PPUSH
3897: LD_STRING Frank
3899: PPUSH
3900: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
3904: LD_INT 1
3906: PPUSH
3907: LD_STRING FrankInDelta
3909: PPUSH
3910: CALL_OW 39
// end ; if Brown in save_group then
3914: LD_EXP 12
3918: PUSH
3919: LD_EXP 4
3923: IN
3924: IFFALSE 3948
// begin SaveCharacters ( Brown , Brown ) ;
3926: LD_EXP 12
3930: PPUSH
3931: LD_STRING Brown
3933: PPUSH
3934: CALL_OW 38
// SaveVariable ( true , BrownInDelta ) ;
3938: LD_INT 1
3940: PPUSH
3941: LD_STRING BrownInDelta
3943: PPUSH
3944: CALL_OW 39
// end ; if Donaldson in save_group then
3948: LD_EXP 11
3952: PUSH
3953: LD_EXP 4
3957: IN
3958: IFFALSE 3982
// begin SaveCharacters ( Donaldson , Donaldson ) ;
3960: LD_EXP 11
3964: PPUSH
3965: LD_STRING Donaldson
3967: PPUSH
3968: CALL_OW 38
// SaveVariable ( true , DonaldsonInDelta ) ;
3972: LD_INT 1
3974: PPUSH
3975: LD_STRING DonaldsonInDelta
3977: PPUSH
3978: CALL_OW 39
// end ; Wait ( 3 ) ;
3982: LD_INT 3
3984: PPUSH
3985: CALL_OW 67
// for i in save_group do
3989: LD_ADDR_VAR 0 3
3993: PUSH
3994: LD_EXP 4
3998: PUSH
3999: FOR_IN
4000: IFFALSE 4031
// begin if IsInUnit ( i ) then
4002: LD_VAR 0 3
4006: PPUSH
4007: CALL_OW 310
4011: IFFALSE 4022
// ComExitBuilding ( i ) ;
4013: LD_VAR 0 3
4017: PPUSH
4018: CALL_OW 122
// Wait ( 3 ) ;
4022: LD_INT 3
4024: PPUSH
4025: CALL_OW 67
// end ;
4029: GO 3999
4031: POP
4032: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4033: LD_ADDR_EXP 4
4037: PUSH
4038: LD_EXP 4
4042: PPUSH
4043: LD_INT 1
4045: PPUSH
4046: LD_EXP 5
4050: PPUSH
4051: CALL_OW 2
4055: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4056: LD_ADDR_EXP 4
4060: PUSH
4061: LD_EXP 4
4065: PPUSH
4066: LD_INT 2
4068: PPUSH
4069: LD_EXP 6
4073: PPUSH
4074: CALL_OW 2
4078: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4079: LD_ADDR_VAR 0 8
4083: PUSH
4084: LD_INT 21
4086: PUSH
4087: LD_INT 2
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: PPUSH
4094: CALL_OW 69
4098: ST_TO_ADDR
// for i = 1 to filter do
4099: LD_ADDR_VAR 0 3
4103: PUSH
4104: DOUBLE
4105: LD_INT 1
4107: DEC
4108: ST_TO_ADDR
4109: LD_VAR 0 8
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4145
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4117: LD_EXP 4
4121: PUSH
4122: LD_VAR 0 3
4126: ARRAY
4127: PPUSH
4128: LD_VAR 0 8
4132: PUSH
4133: LD_VAR 0 3
4137: ARRAY
4138: PPUSH
4139: CALL_OW 120
4143: GO 4114
4145: POP
4146: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4147: LD_EXP 4
4151: PPUSH
4152: LD_INT 87
4154: PPUSH
4155: LD_INT 27
4157: PPUSH
4158: CALL_OW 171
// Wait ( 0 0$05 ) ;
4162: LD_INT 175
4164: PPUSH
4165: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4169: LD_INT 1
4171: PPUSH
4172: LD_STRING %_cont
4174: PPUSH
4175: CALL_OW 340
// end ; end_of_file
4179: LD_VAR 0 1
4183: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4184: LD_INT 0
4186: PPUSH
4187: PPUSH
// if exist_mode then
4188: LD_VAR 0 2
4192: IFFALSE 4211
// unit := CreateCharacter ( ident ) else
4194: LD_ADDR_VAR 0 4
4198: PUSH
4199: LD_VAR 0 1
4203: PPUSH
4204: CALL_OW 34
4208: ST_TO_ADDR
4209: GO 4226
// unit := NewCharacter ( ident ) ;
4211: LD_ADDR_VAR 0 4
4215: PUSH
4216: LD_VAR 0 1
4220: PPUSH
4221: CALL_OW 25
4225: ST_TO_ADDR
// result := unit ;
4226: LD_ADDR_VAR 0 3
4230: PUSH
4231: LD_VAR 0 4
4235: ST_TO_ADDR
// end ;
4236: LD_VAR 0 3
4240: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4241: LD_INT 0
4243: PPUSH
// uc_side := side ;
4244: LD_ADDR_OWVAR 20
4248: PUSH
4249: LD_VAR 0 1
4253: ST_TO_ADDR
// uc_nation := nation ;
4254: LD_ADDR_OWVAR 21
4258: PUSH
4259: LD_VAR 0 2
4263: ST_TO_ADDR
// vc_chassis := chassis ;
4264: LD_ADDR_OWVAR 37
4268: PUSH
4269: LD_VAR 0 3
4273: ST_TO_ADDR
// vc_engine := engine ;
4274: LD_ADDR_OWVAR 39
4278: PUSH
4279: LD_VAR 0 4
4283: ST_TO_ADDR
// vc_control := control ;
4284: LD_ADDR_OWVAR 38
4288: PUSH
4289: LD_VAR 0 5
4293: ST_TO_ADDR
// vc_weapon := weapon ;
4294: LD_ADDR_OWVAR 40
4298: PUSH
4299: LD_VAR 0 6
4303: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4304: LD_ADDR_OWVAR 41
4308: PUSH
4309: LD_VAR 0 7
4313: ST_TO_ADDR
// result := CreateVehicle ;
4314: LD_ADDR_VAR 0 8
4318: PUSH
4319: CALL_OW 45
4323: ST_TO_ADDR
// end ;
4324: LD_VAR 0 8
4328: RET
// export function SayX ( units , ident ) ; var i ; begin
4329: LD_INT 0
4331: PPUSH
4332: PPUSH
// result := false ;
4333: LD_ADDR_VAR 0 3
4337: PUSH
4338: LD_INT 0
4340: ST_TO_ADDR
// if not units then
4341: LD_VAR 0 1
4345: NOT
4346: IFFALSE 4350
// exit ;
4348: GO 4404
// for i in units do
4350: LD_ADDR_VAR 0 4
4354: PUSH
4355: LD_VAR 0 1
4359: PUSH
4360: FOR_IN
4361: IFFALSE 4402
// if IsOk ( i ) then
4363: LD_VAR 0 4
4367: PPUSH
4368: CALL_OW 302
4372: IFFALSE 4400
// begin Say ( i , ident ) ;
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_VAR 0 2
4383: PPUSH
4384: CALL_OW 88
// result := i ;
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: LD_VAR 0 4
4397: ST_TO_ADDR
// break ;
4398: GO 4402
// end ;
4400: GO 4360
4402: POP
4403: POP
// end ;
4404: LD_VAR 0 3
4408: RET
