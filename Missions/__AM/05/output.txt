// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 80 0 0
// PrepareAmerican ;
  16: CALL 104 0 0
// Action ;
  20: CALL 2054 0 0
// end ;
  24: END
// export debug ; export mission_prefix , mission_prefix_prev ; export donaldson_commander , brown_commander , save_group ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// mission_prefix := 05a_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 05a_
  43: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 04_
  51: ST_TO_ADDR
// donaldson_commander := false ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// brown_commander := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// save_group := [ ] ;
  68: LD_ADDR_EXP 6
  72: PUSH
  73: EMPTY
  74: ST_TO_ADDR
// end ;
  75: LD_VAR 0 1
  79: RET
// function DebugMode ; begin
  80: LD_INT 0
  82: PPUSH
// if not debug then
  83: LD_EXP 1
  87: NOT
  88: IFFALSE 92
// exit ;
  90: GO 99
// FogOff ( 1 ) ;
  92: LD_INT 1
  94: PPUSH
  95: CALL_OW 344
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export JMM , Gladstone , Frank , Lisa , Cyrus , Bobby , Donaldson , Brown ; export function PrepareAmerican ; var others3 , others4 , veh , team , dep , bar , lab , fac , bun , filter , i , tmp ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
 110: PPUSH
 111: PPUSH
 112: PPUSH
 113: PPUSH
 114: PPUSH
 115: PPUSH
 116: PPUSH
 117: PPUSH
 118: PPUSH
// PrepareBase ;
 119: CALL 1790 0 0
// uc_side := 1 ;
 123: LD_ADDR_OWVAR 20
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// uc_nation := 1 ;
 131: LD_ADDR_OWVAR 21
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// team := [ ] ;
 139: LD_ADDR_VAR 0 5
 143: PUSH
 144: EMPTY
 145: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_STRING JMM
 153: PPUSH
 154: LD_EXP 1
 158: NOT
 159: PPUSH
 160: CALL 4385 0 2
 164: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_STRING Gladstone
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: CALL 4385 0 2
 180: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 181: LD_ADDR_EXP 9
 185: PUSH
 186: LD_STRING Frank
 188: PPUSH
 189: LD_EXP 1
 193: NOT
 194: PPUSH
 195: CALL 4385 0 2
 199: ST_TO_ADDR
// if Frank then
 200: LD_EXP 9
 204: IFFALSE 222
// team := team ^ Frank ;
 206: LD_ADDR_VAR 0 5
 210: PUSH
 211: LD_VAR 0 5
 215: PUSH
 216: LD_EXP 9
 220: ADD
 221: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 222: LD_ADDR_EXP 10
 226: PUSH
 227: LD_STRING Lisa
 229: PPUSH
 230: LD_EXP 1
 234: NOT
 235: PPUSH
 236: CALL 4385 0 2
 240: ST_TO_ADDR
// if Lisa then
 241: LD_EXP 10
 245: IFFALSE 263
// team := team ^ Lisa ;
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 5
 256: PUSH
 257: LD_EXP 10
 261: ADD
 262: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 263: LD_ADDR_EXP 13
 267: PUSH
 268: LD_STRING Donaldson
 270: PPUSH
 271: LD_EXP 1
 275: NOT
 276: PPUSH
 277: CALL 4385 0 2
 281: ST_TO_ADDR
// if Donaldson then
 282: LD_EXP 13
 286: IFFALSE 304
// team := team ^ Donaldson ;
 288: LD_ADDR_VAR 0 5
 292: PUSH
 293: LD_VAR 0 5
 297: PUSH
 298: LD_EXP 13
 302: ADD
 303: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 304: LD_ADDR_EXP 14
 308: PUSH
 309: LD_STRING Brown
 311: PPUSH
 312: LD_EXP 1
 316: NOT
 317: PPUSH
 318: CALL 4385 0 2
 322: ST_TO_ADDR
// if Brown then
 323: LD_EXP 14
 327: IFFALSE 345
// team := team ^ Brown ;
 329: LD_ADDR_VAR 0 5
 333: PUSH
 334: LD_VAR 0 5
 338: PUSH
 339: LD_EXP 14
 343: ADD
 344: ST_TO_ADDR
// others4 := CreateCharacterSet ( 04_other_survivors ) ;
 345: LD_ADDR_VAR 0 3
 349: PUSH
 350: LD_STRING 04_other_survivors
 352: PPUSH
 353: CALL_OW 31
 357: ST_TO_ADDR
// DeleteCharacters ( 04_other_survivors ) ;
 358: LD_STRING 04_other_survivors
 360: PPUSH
 361: CALL_OW 40
// if not Lisa then
 365: LD_EXP 10
 369: NOT
 370: IFFALSE 488
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 372: LD_ADDR_EXP 11
 376: PUSH
 377: LD_STRING Cyrus
 379: PPUSH
 380: LD_EXP 1
 384: NOT
 385: PPUSH
 386: CALL 4385 0 2
 390: ST_TO_ADDR
// if Cyrus then
 391: LD_EXP 11
 395: IFFALSE 413
// team := team ^ Cyrus ;
 397: LD_ADDR_VAR 0 5
 401: PUSH
 402: LD_VAR 0 5
 406: PUSH
 407: LD_EXP 11
 411: ADD
 412: ST_TO_ADDR
// if not Cyrus then
 413: LD_EXP 11
 417: NOT
 418: IFFALSE 488
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 420: LD_ADDR_EXP 12
 424: PUSH
 425: LD_STRING Bobby
 427: PPUSH
 428: LD_EXP 1
 432: NOT
 433: PPUSH
 434: CALL 4385 0 2
 438: ST_TO_ADDR
// if Bobby then
 439: LD_EXP 12
 443: IFFALSE 461
// team := team ^ Bobby ;
 445: LD_ADDR_VAR 0 5
 449: PUSH
 450: LD_VAR 0 5
 454: PUSH
 455: LD_EXP 12
 459: ADD
 460: ST_TO_ADDR
// if not Bobby then
 461: LD_EXP 12
 465: NOT
 466: IFFALSE 488
// begin others3 := CreateCharacterSet ( 03_others ) ;
 468: LD_ADDR_VAR 0 2
 472: PUSH
 473: LD_STRING 03_others
 475: PPUSH
 476: CALL_OW 31
 480: ST_TO_ADDR
// DeleteCharacters ( 03_others ) ;
 481: LD_STRING 03_others
 483: PPUSH
 484: CALL_OW 40
// end ; end ; end ; if others4 then
 488: LD_VAR 0 3
 492: IFFALSE 510
// team := team ^ others4 ;
 494: LD_ADDR_VAR 0 5
 498: PUSH
 499: LD_VAR 0 5
 503: PUSH
 504: LD_VAR 0 3
 508: ADD
 509: ST_TO_ADDR
// if others3 then
 510: LD_VAR 0 2
 514: IFFALSE 532
// team := team ^ others3 ;
 516: LD_ADDR_VAR 0 5
 520: PUSH
 521: LD_VAR 0 5
 525: PUSH
 526: LD_VAR 0 2
 530: ADD
 531: ST_TO_ADDR
// if team < 9 then
 532: LD_VAR 0 5
 536: PUSH
 537: LD_INT 9
 539: LESS
 540: IFFALSE 589
// repeat PrepareHuman ( false , rand ( 1 , 4 ) , 4 ) ;
 542: LD_INT 0
 544: PPUSH
 545: LD_INT 1
 547: PPUSH
 548: LD_INT 4
 550: PPUSH
 551: CALL_OW 12
 555: PPUSH
 556: LD_INT 4
 558: PPUSH
 559: CALL_OW 380
// team := team ^ CreateHuman ;
 563: LD_ADDR_VAR 0 5
 567: PUSH
 568: LD_VAR 0 5
 572: PUSH
 573: CALL_OW 44
 577: ADD
 578: ST_TO_ADDR
// until team = 9 ;
 579: LD_VAR 0 5
 583: PUSH
 584: LD_INT 9
 586: EQUAL
 587: IFFALSE 542
// dep := FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ;
 589: LD_ADDR_VAR 0 6
 593: PUSH
 594: LD_INT 30
 596: PUSH
 597: LD_INT 0
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: PPUSH
 604: CALL_OW 69
 608: PUSH
 609: LD_INT 1
 611: ARRAY
 612: ST_TO_ADDR
// bar := FilterAllUnits ( [ f_btype , b_armoury ] ) ;
 613: LD_ADDR_VAR 0 7
 617: PUSH
 618: LD_INT 30
 620: PUSH
 621: LD_INT 4
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: PPUSH
 628: CALL_OW 69
 632: ST_TO_ADDR
// lab := FilterAllUnits ( [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab ] ] ) ;
 633: LD_ADDR_VAR 0 8
 637: PUSH
 638: LD_INT 2
 640: PUSH
 641: LD_INT 30
 643: PUSH
 644: LD_INT 7
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 30
 653: PUSH
 654: LD_INT 6
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: PPUSH
 666: CALL_OW 69
 670: ST_TO_ADDR
// fac := FilterAllUnits ( [ f_btype , b_factory ] ) ;
 671: LD_ADDR_VAR 0 9
 675: PUSH
 676: LD_INT 30
 678: PUSH
 679: LD_INT 3
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: PPUSH
 686: CALL_OW 69
 690: ST_TO_ADDR
// bun := FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
 691: LD_ADDR_VAR 0 10
 695: PUSH
 696: LD_INT 2
 698: PUSH
 699: LD_INT 30
 701: PUSH
 702: LD_INT 32
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: PUSH
 709: LD_INT 30
 711: PUSH
 712: LD_INT 31
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: PPUSH
 724: CALL_OW 69
 728: ST_TO_ADDR
// SetBName ( dep , Gamma ) ;
 729: LD_VAR 0 6
 733: PPUSH
 734: LD_STRING Gamma
 736: PPUSH
 737: CALL_OW 500
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 741: LD_VAR 0 6
 745: PPUSH
 746: CALL_OW 274
 750: PPUSH
 751: LD_INT 2
 753: PPUSH
 754: LD_INT 10000
 756: PPUSH
 757: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_cans , 10000 ) ;
 761: LD_VAR 0 6
 765: PPUSH
 766: CALL_OW 274
 770: PPUSH
 771: LD_INT 1
 773: PPUSH
 774: LD_INT 10000
 776: PPUSH
 777: CALL_OW 277
// if dep then
 781: LD_VAR 0 6
 785: IFFALSE 867
// begin if Brown then
 787: LD_EXP 14
 791: IFFALSE 827
// begin PlaceHumanInUnit ( Brown , dep [ 1 ] ) ;
 793: LD_EXP 14
 797: PPUSH
 798: LD_VAR 0 6
 802: PUSH
 803: LD_INT 1
 805: ARRAY
 806: PPUSH
 807: CALL_OW 52
// team := team diff Brown ;
 811: LD_ADDR_VAR 0 5
 815: PUSH
 816: LD_VAR 0 5
 820: PUSH
 821: LD_EXP 14
 825: DIFF
 826: ST_TO_ADDR
// end ; if Donaldson then
 827: LD_EXP 13
 831: IFFALSE 867
// begin PlaceHumanInUnit ( Donaldson , dep [ 1 ] ) ;
 833: LD_EXP 13
 837: PPUSH
 838: LD_VAR 0 6
 842: PUSH
 843: LD_INT 1
 845: ARRAY
 846: PPUSH
 847: CALL_OW 52
// team := team diff Donaldson ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 5
 860: PUSH
 861: LD_EXP 13
 865: DIFF
 866: ST_TO_ADDR
// end ; end ; if bun and UnitFilter ( team , [ f_class , 1 ] ) then
 867: LD_VAR 0 10
 871: PUSH
 872: LD_VAR 0 5
 876: PPUSH
 877: LD_INT 25
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: EMPTY
 884: LIST
 885: LIST
 886: PPUSH
 887: CALL_OW 72
 891: AND
 892: IFFALSE 1001
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
 894: LD_ADDR_VAR 0 11
 898: PUSH
 899: LD_VAR 0 5
 903: PPUSH
 904: LD_INT 25
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: PPUSH
 914: CALL_OW 72
 918: ST_TO_ADDR
// for i in bun do
 919: LD_ADDR_VAR 0 12
 923: PUSH
 924: LD_VAR 0 10
 928: PUSH
 929: FOR_IN
 930: IFFALSE 999
// begin if not filter then
 932: LD_VAR 0 11
 936: NOT
 937: IFFALSE 941
// break ;
 939: GO 999
// PlaceHumanInUnit ( filter [ 1 ] , i ) ;
 941: LD_VAR 0 11
 945: PUSH
 946: LD_INT 1
 948: ARRAY
 949: PPUSH
 950: LD_VAR 0 12
 954: PPUSH
 955: CALL_OW 52
// team := team diff filter [ 1 ] ;
 959: LD_ADDR_VAR 0 5
 963: PUSH
 964: LD_VAR 0 5
 968: PUSH
 969: LD_VAR 0 11
 973: PUSH
 974: LD_INT 1
 976: ARRAY
 977: DIFF
 978: ST_TO_ADDR
// filter := Delete ( filter , 1 ) ;
 979: LD_ADDR_VAR 0 11
 983: PUSH
 984: LD_VAR 0 11
 988: PPUSH
 989: LD_INT 1
 991: PPUSH
 992: CALL_OW 3
 996: ST_TO_ADDR
// end ;
 997: GO 929
 999: POP
1000: POP
// end ; if bar and UnitFilter ( team , [ f_class , 1 ] ) then
1001: LD_VAR 0 7
1005: PUSH
1006: LD_VAR 0 5
1010: PPUSH
1011: LD_INT 25
1013: PUSH
1014: LD_INT 1
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: PPUSH
1021: CALL_OW 72
1025: AND
1026: IFFALSE 1148
// begin filter := UnitFilter ( team , [ f_class , 1 ] ) ;
1028: LD_ADDR_VAR 0 11
1032: PUSH
1033: LD_VAR 0 5
1037: PPUSH
1038: LD_INT 25
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: EMPTY
1045: LIST
1046: LIST
1047: PPUSH
1048: CALL_OW 72
1052: ST_TO_ADDR
// for i = 1 to filter do
1053: LD_ADDR_VAR 0 12
1057: PUSH
1058: DOUBLE
1059: LD_INT 1
1061: DEC
1062: ST_TO_ADDR
1063: LD_VAR 0 11
1067: PUSH
1068: FOR_TO
1069: IFFALSE 1130
// begin if ( i <= 6 ) then
1071: LD_VAR 0 12
1075: PUSH
1076: LD_INT 6
1078: LESSEQUAL
1079: IFFALSE 1107
// PlaceHumanInUnit ( filter [ i ] , bar [ 1 ] ) else
1081: LD_VAR 0 11
1085: PUSH
1086: LD_VAR 0 12
1090: ARRAY
1091: PPUSH
1092: LD_VAR 0 7
1096: PUSH
1097: LD_INT 1
1099: ARRAY
1100: PPUSH
1101: CALL_OW 52
1105: GO 1128
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1107: LD_VAR 0 11
1111: PUSH
1112: LD_VAR 0 12
1116: ARRAY
1117: PPUSH
1118: LD_INT 1
1120: PPUSH
1121: LD_INT 0
1123: PPUSH
1124: CALL_OW 49
// end ;
1128: GO 1068
1130: POP
1131: POP
// team := team diff filter ;
1132: LD_ADDR_VAR 0 5
1136: PUSH
1137: LD_VAR 0 5
1141: PUSH
1142: LD_VAR 0 11
1146: DIFF
1147: ST_TO_ADDR
// end ; if lab and UnitFilter ( team , [ f_class , 4 ] ) then
1148: LD_VAR 0 8
1152: PUSH
1153: LD_VAR 0 5
1157: PPUSH
1158: LD_INT 25
1160: PUSH
1161: LD_INT 4
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: PPUSH
1168: CALL_OW 72
1172: AND
1173: IFFALSE 1295
// begin filter := UnitFilter ( team , [ f_class , 4 ] ) ;
1175: LD_ADDR_VAR 0 11
1179: PUSH
1180: LD_VAR 0 5
1184: PPUSH
1185: LD_INT 25
1187: PUSH
1188: LD_INT 4
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: PPUSH
1195: CALL_OW 72
1199: ST_TO_ADDR
// for i = 1 to filter do
1200: LD_ADDR_VAR 0 12
1204: PUSH
1205: DOUBLE
1206: LD_INT 1
1208: DEC
1209: ST_TO_ADDR
1210: LD_VAR 0 11
1214: PUSH
1215: FOR_TO
1216: IFFALSE 1277
// begin if ( i <= 6 ) then
1218: LD_VAR 0 12
1222: PUSH
1223: LD_INT 6
1225: LESSEQUAL
1226: IFFALSE 1254
// PlaceHumanInUnit ( filter [ i ] , lab [ 1 ] ) else
1228: LD_VAR 0 11
1232: PUSH
1233: LD_VAR 0 12
1237: ARRAY
1238: PPUSH
1239: LD_VAR 0 8
1243: PUSH
1244: LD_INT 1
1246: ARRAY
1247: PPUSH
1248: CALL_OW 52
1252: GO 1275
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1254: LD_VAR 0 11
1258: PUSH
1259: LD_VAR 0 12
1263: ARRAY
1264: PPUSH
1265: LD_INT 1
1267: PPUSH
1268: LD_INT 0
1270: PPUSH
1271: CALL_OW 49
// end ;
1275: GO 1215
1277: POP
1278: POP
// team := team diff filter ;
1279: LD_ADDR_VAR 0 5
1283: PUSH
1284: LD_VAR 0 5
1288: PUSH
1289: LD_VAR 0 11
1293: DIFF
1294: ST_TO_ADDR
// end ; if fac and UnitFilter ( team , [ f_class , 3 ] ) then
1295: LD_VAR 0 9
1299: PUSH
1300: LD_VAR 0 5
1304: PPUSH
1305: LD_INT 25
1307: PUSH
1308: LD_INT 3
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL_OW 72
1319: AND
1320: IFFALSE 1442
// begin filter := UnitFilter ( team , [ f_class , 3 ] ) ;
1322: LD_ADDR_VAR 0 11
1326: PUSH
1327: LD_VAR 0 5
1331: PPUSH
1332: LD_INT 25
1334: PUSH
1335: LD_INT 3
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: PPUSH
1342: CALL_OW 72
1346: ST_TO_ADDR
// for i = 1 to filter do
1347: LD_ADDR_VAR 0 12
1351: PUSH
1352: DOUBLE
1353: LD_INT 1
1355: DEC
1356: ST_TO_ADDR
1357: LD_VAR 0 11
1361: PUSH
1362: FOR_TO
1363: IFFALSE 1424
// begin if ( i <= 6 ) then
1365: LD_VAR 0 12
1369: PUSH
1370: LD_INT 6
1372: LESSEQUAL
1373: IFFALSE 1401
// PlaceHumanInUnit ( filter [ i ] , fac [ 1 ] ) else
1375: LD_VAR 0 11
1379: PUSH
1380: LD_VAR 0 12
1384: ARRAY
1385: PPUSH
1386: LD_VAR 0 9
1390: PUSH
1391: LD_INT 1
1393: ARRAY
1394: PPUSH
1395: CALL_OW 52
1399: GO 1422
// PlaceUnitArea ( filter [ i ] , gammaBaseArea , false ) ;
1401: LD_VAR 0 11
1405: PUSH
1406: LD_VAR 0 12
1410: ARRAY
1411: PPUSH
1412: LD_INT 1
1414: PPUSH
1415: LD_INT 0
1417: PPUSH
1418: CALL_OW 49
// end ;
1422: GO 1362
1424: POP
1425: POP
// team := team diff filter ;
1426: LD_ADDR_VAR 0 5
1430: PUSH
1431: LD_VAR 0 5
1435: PUSH
1436: LD_VAR 0 11
1440: DIFF
1441: ST_TO_ADDR
// end ; if team then
1442: LD_VAR 0 5
1446: IFFALSE 1489
// for i in team do
1448: LD_ADDR_VAR 0 12
1452: PUSH
1453: LD_VAR 0 5
1457: PUSH
1458: FOR_IN
1459: IFFALSE 1487
// begin PlaceUnitArea ( i , gammaBaseArea , false ) ;
1461: LD_VAR 0 12
1465: PPUSH
1466: LD_INT 1
1468: PPUSH
1469: LD_INT 0
1471: PPUSH
1472: CALL_OW 49
// ComHold ( i ) ;
1476: LD_VAR 0 12
1480: PPUSH
1481: CALL_OW 140
// end ;
1485: GO 1458
1487: POP
1488: POP
// if fac then
1489: LD_VAR 0 9
1493: IFFALSE 1529
// if UnitsInside ( fac [ 1 ] ) then
1495: LD_VAR 0 9
1499: PUSH
1500: LD_INT 1
1502: ARRAY
1503: PPUSH
1504: CALL_OW 313
1508: IFFALSE 1529
// SetSpecResearch ( fac [ 1 ] , 10 , false ) ;
1510: LD_VAR 0 9
1514: PUSH
1515: LD_INT 1
1517: ARRAY
1518: PPUSH
1519: LD_INT 10
1521: PPUSH
1522: LD_INT 0
1524: PPUSH
1525: CALL_OW 486
// if lab then
1529: LD_VAR 0 8
1533: IFFALSE 1569
// if UnitsInside ( lab [ 1 ] ) then
1535: LD_VAR 0 8
1539: PUSH
1540: LD_INT 1
1542: ARRAY
1543: PPUSH
1544: CALL_OW 313
1548: IFFALSE 1569
// SetSpecResearch ( lab [ 1 ] , 10 , false ) ;
1550: LD_VAR 0 8
1554: PUSH
1555: LD_INT 1
1557: ARRAY
1558: PPUSH
1559: LD_INT 10
1561: PPUSH
1562: LD_INT 0
1564: PPUSH
1565: CALL_OW 486
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 100 ) ;
1569: LD_ADDR_VAR 0 4
1573: PUSH
1574: LD_INT 1
1576: PPUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 1
1582: PPUSH
1583: LD_INT 2
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: LD_INT 3
1591: PPUSH
1592: LD_INT 100
1594: PPUSH
1595: CALL 4448 0 7
1599: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1600: LD_VAR 0 4
1604: PPUSH
1605: LD_INT 2
1607: PPUSH
1608: CALL_OW 233
// PlaceUnitXY ( veh , 21 , 8 , false ) ;
1612: LD_VAR 0 4
1616: PPUSH
1617: LD_INT 21
1619: PPUSH
1620: LD_INT 8
1622: PPUSH
1623: LD_INT 0
1625: PPUSH
1626: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1630: LD_EXP 7
1634: PPUSH
1635: LD_VAR 0 4
1639: PPUSH
1640: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1644: LD_ADDR_VAR 0 4
1648: PUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 1
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 2
1660: PPUSH
1661: LD_INT 1
1663: PPUSH
1664: LD_INT 2
1666: PPUSH
1667: LD_INT 100
1669: PPUSH
1670: CALL 4448 0 7
1674: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1675: LD_VAR 0 4
1679: PPUSH
1680: LD_INT 2
1682: PPUSH
1683: CALL_OW 233
// PlaceUnitXY ( veh , 16 , 3 , false ) ;
1687: LD_VAR 0 4
1691: PPUSH
1692: LD_INT 16
1694: PPUSH
1695: LD_INT 3
1697: PPUSH
1698: LD_INT 0
1700: PPUSH
1701: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1705: LD_EXP 8
1709: PPUSH
1710: LD_VAR 0 4
1714: PPUSH
1715: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 100 ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_INT 1
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: LD_INT 2
1732: PPUSH
1733: LD_INT 2
1735: PPUSH
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 12
1741: PPUSH
1742: LD_INT 100
1744: PPUSH
1745: CALL 4448 0 7
1749: ST_TO_ADDR
// SetDir ( veh , rand ( 0 , 5 ) ) ;
1750: LD_VAR 0 4
1754: PPUSH
1755: LD_INT 0
1757: PPUSH
1758: LD_INT 5
1760: PPUSH
1761: CALL_OW 12
1765: PPUSH
1766: CALL_OW 233
// PlaceUnitArea ( veh , gammaBaseArea , false ) ;
1770: LD_VAR 0 4
1774: PPUSH
1775: LD_INT 1
1777: PPUSH
1778: LD_INT 0
1780: PPUSH
1781: CALL_OW 49
// end ;
1785: LD_VAR 0 1
1789: RET
// function PrepareBase ; var blist , i , b ; begin
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
// SetResourceVisibility ( 71 , 5 , 1 ) ;
1796: LD_INT 71
1798: PPUSH
1799: LD_INT 5
1801: PPUSH
1802: LD_INT 1
1804: PPUSH
1805: CALL_OW 441
// blist := LoadVariable ( GammaBase , [ ] ) ;
1809: LD_ADDR_VAR 0 2
1813: PUSH
1814: LD_STRING GammaBase
1816: PPUSH
1817: EMPTY
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if not blist then
1824: LD_VAR 0 2
1828: NOT
1829: IFFALSE 1869
// blist := [ [ b_depot , 51 , 10 , 3 , 3 , 0 , 0 ] ] ;
1831: LD_ADDR_VAR 0 2
1835: PUSH
1836: LD_INT 0
1838: PUSH
1839: LD_INT 51
1841: PUSH
1842: LD_INT 10
1844: PUSH
1845: LD_INT 3
1847: PUSH
1848: LD_INT 3
1850: PUSH
1851: LD_INT 0
1853: PUSH
1854: LD_INT 0
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PUSH
1866: EMPTY
1867: LIST
1868: ST_TO_ADDR
// uc_side := 1 ;
1869: LD_ADDR_OWVAR 20
1873: PUSH
1874: LD_INT 1
1876: ST_TO_ADDR
// uc_nation := 1 ;
1877: LD_ADDR_OWVAR 21
1881: PUSH
1882: LD_INT 1
1884: ST_TO_ADDR
// for i in blist do
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_VAR 0 2
1894: PUSH
1895: FOR_IN
1896: IFFALSE 2047
// begin bc_type := i [ 1 ] ;
1898: LD_ADDR_OWVAR 42
1902: PUSH
1903: LD_VAR 0 3
1907: PUSH
1908: LD_INT 1
1910: ARRAY
1911: ST_TO_ADDR
// bc_level := i [ 5 ] ;
1912: LD_ADDR_OWVAR 43
1916: PUSH
1917: LD_VAR 0 3
1921: PUSH
1922: LD_INT 5
1924: ARRAY
1925: ST_TO_ADDR
// if i [ 1 ] in [ b_lab_half , b_lab_full ] then
1926: LD_VAR 0 3
1930: PUSH
1931: LD_INT 1
1933: ARRAY
1934: PUSH
1935: LD_INT 7
1937: PUSH
1938: LD_INT 8
1940: PUSH
1941: EMPTY
1942: LIST
1943: LIST
1944: IN
1945: IFFALSE 1975
// begin bc_kind1 := i [ 7 ] ;
1947: LD_ADDR_OWVAR 44
1951: PUSH
1952: LD_VAR 0 3
1956: PUSH
1957: LD_INT 7
1959: ARRAY
1960: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
1961: LD_ADDR_OWVAR 45
1965: PUSH
1966: LD_VAR 0 3
1970: PUSH
1971: LD_INT 8
1973: ARRAY
1974: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1975: LD_ADDR_VAR 0 4
1979: PUSH
1980: LD_VAR 0 3
1984: PUSH
1985: LD_INT 2
1987: ARRAY
1988: PPUSH
1989: LD_VAR 0 3
1993: PUSH
1994: LD_INT 3
1996: ARRAY
1997: PPUSH
1998: LD_VAR 0 3
2002: PUSH
2003: LD_INT 4
2005: ARRAY
2006: PPUSH
2007: CALL_OW 47
2011: ST_TO_ADDR
// if GetBType ( b ) = b_bunker then
2012: LD_VAR 0 4
2016: PPUSH
2017: CALL_OW 266
2021: PUSH
2022: LD_INT 32
2024: EQUAL
2025: IFFALSE 2045
// begin PlaceWeaponTurret ( b , i [ 7 ] ) ;
2027: LD_VAR 0 4
2031: PPUSH
2032: LD_VAR 0 3
2036: PUSH
2037: LD_INT 7
2039: ARRAY
2040: PPUSH
2041: CALL_OW 431
// end ; end ;
2045: GO 1895
2047: POP
2048: POP
// end ; end_of_file
2049: LD_VAR 0 1
2053: RET
// export function Action ; var points , i , sol , team , all , commander , filter ; begin
2054: LD_INT 0
2056: PPUSH
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
2061: PPUSH
2062: PPUSH
2063: PPUSH
// PlaceSeeing ( 0 , 0 , 1 , - 32976 ) ;
2064: LD_INT 0
2066: PPUSH
2067: LD_INT 0
2069: PPUSH
2070: LD_INT 1
2072: PPUSH
2073: LD_INT 32976
2075: NEG
2076: PPUSH
2077: CALL_OW 330
// InGameOn ;
2081: CALL_OW 8
// CenterNowOnXY ( 33 , 11 ) ;
2085: LD_INT 33
2087: PPUSH
2088: LD_INT 11
2090: PPUSH
2091: CALL_OW 86
// points := [ [ 29 , 21 ] , [ 41 , 28 ] , [ 52 , 26 ] , [ 49 , 16 ] ] ;
2095: LD_ADDR_VAR 0 2
2099: PUSH
2100: LD_INT 29
2102: PUSH
2103: LD_INT 21
2105: PUSH
2106: EMPTY
2107: LIST
2108: LIST
2109: PUSH
2110: LD_INT 41
2112: PUSH
2113: LD_INT 28
2115: PUSH
2116: EMPTY
2117: LIST
2118: LIST
2119: PUSH
2120: LD_INT 52
2122: PUSH
2123: LD_INT 26
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: PUSH
2130: LD_INT 49
2132: PUSH
2133: LD_INT 16
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: LIST
2144: LIST
2145: ST_TO_ADDR
// for i in points do
2146: LD_ADDR_VAR 0 3
2150: PUSH
2151: LD_VAR 0 2
2155: PUSH
2156: FOR_IN
2157: IFFALSE 2197
// AddComMoveXY ( [ JMM , Gladstone ] , i [ 1 ] , i [ 2 ] ) ;
2159: LD_EXP 7
2163: PUSH
2164: LD_EXP 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: LD_VAR 0 3
2177: PUSH
2178: LD_INT 1
2180: ARRAY
2181: PPUSH
2182: LD_VAR 0 3
2186: PUSH
2187: LD_INT 2
2189: ARRAY
2190: PPUSH
2191: CALL_OW 171
2195: GO 2156
2197: POP
2198: POP
// AddComExitVehicle ( [ JMM , Gladstone ] ) ;
2199: LD_EXP 7
2203: PUSH
2204: LD_EXP 8
2208: PUSH
2209: EMPTY
2210: LIST
2211: LIST
2212: PPUSH
2213: CALL_OW 181
// repeat wait ( 0 0$01 ) ;
2217: LD_INT 35
2219: PPUSH
2220: CALL_OW 67
// until not IsInUnit ( JMM ) and not IsInUnit ( Gladstone ) ;
2224: LD_EXP 7
2228: PPUSH
2229: CALL_OW 310
2233: NOT
2234: PUSH
2235: LD_EXP 8
2239: PPUSH
2240: CALL_OW 310
2244: NOT
2245: AND
2246: IFFALSE 2217
// ComTurnUnit ( JMM , Gladstone ) ;
2248: LD_EXP 7
2252: PPUSH
2253: LD_EXP 8
2257: PPUSH
2258: CALL_OW 119
// ComTurnUnit ( Gladstone , JMM ) ;
2262: LD_EXP 8
2266: PPUSH
2267: LD_EXP 7
2271: PPUSH
2272: CALL_OW 119
// sol := FilterAllUnits ( [ f_sex , sex_male ] ) diff [ JMM , Gladstone , Bobby , Cyrus , Frank , Brown ] ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_INT 26
2283: PUSH
2284: LD_INT 1
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: PPUSH
2291: CALL_OW 69
2295: PUSH
2296: LD_EXP 7
2300: PUSH
2301: LD_EXP 8
2305: PUSH
2306: LD_EXP 12
2310: PUSH
2311: LD_EXP 11
2315: PUSH
2316: LD_EXP 9
2320: PUSH
2321: LD_EXP 14
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: LIST
2330: LIST
2331: LIST
2332: LIST
2333: DIFF
2334: ST_TO_ADDR
// if sol then
2335: LD_VAR 0 4
2339: IFFALSE 2355
// sol := sol [ 1 ] ;
2341: LD_ADDR_VAR 0 4
2345: PUSH
2346: LD_VAR 0 4
2350: PUSH
2351: LD_INT 1
2353: ARRAY
2354: ST_TO_ADDR
// team := [ ] ;
2355: LD_ADDR_VAR 0 5
2359: PUSH
2360: EMPTY
2361: ST_TO_ADDR
// if sol then
2362: LD_VAR 0 4
2366: IFFALSE 2384
// team := team ^ sol ;
2368: LD_ADDR_VAR 0 5
2372: PUSH
2373: LD_VAR 0 5
2377: PUSH
2378: LD_VAR 0 4
2382: ADD
2383: ST_TO_ADDR
// if Lisa then
2384: LD_EXP 10
2388: IFFALSE 2406
// team := team ^ Lisa ;
2390: LD_ADDR_VAR 0 5
2394: PUSH
2395: LD_VAR 0 5
2399: PUSH
2400: LD_EXP 10
2404: ADD
2405: ST_TO_ADDR
// if Donaldson then
2406: LD_EXP 13
2410: IFFALSE 2428
// team := team ^ Donaldson ;
2412: LD_ADDR_VAR 0 5
2416: PUSH
2417: LD_VAR 0 5
2421: PUSH
2422: LD_EXP 13
2426: ADD
2427: ST_TO_ADDR
// if Brown then
2428: LD_EXP 14
2432: IFFALSE 2450
// team := team ^ Brown ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_VAR 0 5
2443: PUSH
2444: LD_EXP 14
2448: ADD
2449: ST_TO_ADDR
// if Bobby then
2450: LD_EXP 12
2454: IFFALSE 2472
// team := team ^ Bobby ;
2456: LD_ADDR_VAR 0 5
2460: PUSH
2461: LD_VAR 0 5
2465: PUSH
2466: LD_EXP 12
2470: ADD
2471: ST_TO_ADDR
// if Cyrus then
2472: LD_EXP 11
2476: IFFALSE 2494
// team := team ^ Cyrus ;
2478: LD_ADDR_VAR 0 5
2482: PUSH
2483: LD_VAR 0 5
2487: PUSH
2488: LD_EXP 11
2492: ADD
2493: ST_TO_ADDR
// if Frank then
2494: LD_EXP 9
2498: IFFALSE 2516
// team := team ^ Frank ;
2500: LD_ADDR_VAR 0 5
2504: PUSH
2505: LD_VAR 0 5
2509: PUSH
2510: LD_EXP 9
2514: ADD
2515: ST_TO_ADDR
// for i in [ FilterUnitsInArea ( gammaBaseArea , [ [ f_not , [ f_inside ] ] , [ f_type , unit_human ] ] ) diff [ JMM , Gladstone ] ] do
2516: LD_ADDR_VAR 0 3
2520: PUSH
2521: LD_INT 1
2523: PPUSH
2524: LD_INT 3
2526: PUSH
2527: LD_INT 54
2529: PUSH
2530: EMPTY
2531: LIST
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: PUSH
2537: LD_INT 21
2539: PUSH
2540: LD_INT 1
2542: PUSH
2543: EMPTY
2544: LIST
2545: LIST
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PPUSH
2551: CALL_OW 70
2555: PUSH
2556: LD_EXP 7
2560: PUSH
2561: LD_EXP 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: DIFF
2570: PUSH
2571: EMPTY
2572: LIST
2573: PUSH
2574: FOR_IN
2575: IFFALSE 2595
// team := team ^ i ;
2577: LD_ADDR_VAR 0 5
2581: PUSH
2582: LD_VAR 0 5
2586: PUSH
2587: LD_VAR 0 3
2591: ADD
2592: ST_TO_ADDR
2593: GO 2574
2595: POP
2596: POP
// if team then
2597: LD_VAR 0 5
2601: IFFALSE 2677
// begin ComExitBuilding ( team ) ;
2603: LD_VAR 0 5
2607: PPUSH
2608: CALL_OW 122
// AddComMoveUnit ( team , JMM ) ;
2612: LD_VAR 0 5
2616: PPUSH
2617: LD_EXP 7
2621: PPUSH
2622: CALL_OW 172
// repeat wait ( 1 ) ;
2626: LD_INT 1
2628: PPUSH
2629: CALL_OW 67
// until GetDistUnits ( JMM , NearestUnitToUnit ( team , JMM ) ) < 6 ;
2633: LD_EXP 7
2637: PPUSH
2638: LD_VAR 0 5
2642: PPUSH
2643: LD_EXP 7
2647: PPUSH
2648: CALL_OW 74
2652: PPUSH
2653: CALL_OW 296
2657: PUSH
2658: LD_INT 6
2660: LESS
2661: IFFALSE 2626
// ComTurnUnit ( team , JMM ) ;
2663: LD_VAR 0 5
2667: PPUSH
2668: LD_EXP 7
2672: PPUSH
2673: CALL_OW 119
// end ; if Lisa then
2677: LD_EXP 10
2681: IFFALSE 2709
// begin ComTurnUnit ( JMM , Lisa ) ;
2683: LD_EXP 7
2687: PPUSH
2688: LD_EXP 10
2692: PPUSH
2693: CALL_OW 119
// Say ( Lisa , D1-Lisa-1 ) ;
2697: LD_EXP 10
2701: PPUSH
2702: LD_STRING D1-Lisa-1
2704: PPUSH
2705: CALL_OW 88
// end ; if sol then
2709: LD_VAR 0 4
2713: IFFALSE 2741
// begin ComTurnUnit ( JMM , sol ) ;
2715: LD_EXP 7
2719: PPUSH
2720: LD_VAR 0 4
2724: PPUSH
2725: CALL_OW 119
// Say ( sol , D1-Sol1-1 ) ;
2729: LD_VAR 0 4
2733: PPUSH
2734: LD_STRING D1-Sol1-1
2736: PPUSH
2737: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
2741: LD_EXP 7
2745: PPUSH
2746: LD_STRING D1-JMM-1
2748: PPUSH
2749: CALL_OW 88
// Say ( JMM , D1-JMM-1a ) ;
2753: LD_EXP 7
2757: PPUSH
2758: LD_STRING D1-JMM-1a
2760: PPUSH
2761: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2765: LD_EXP 7
2769: PPUSH
2770: LD_EXP 8
2774: PPUSH
2775: CALL_OW 119
// ComTurnUnit ( team , Gladstone ) ;
2779: LD_VAR 0 5
2783: PPUSH
2784: LD_EXP 8
2788: PPUSH
2789: CALL_OW 119
// if Frank then
2793: LD_EXP 9
2797: IFFALSE 2825
// begin Say ( Frank , D1-Frank-1 ) ;
2799: LD_EXP 9
2803: PPUSH
2804: LD_STRING D1-Frank-1
2806: PPUSH
2807: CALL_OW 88
// ComTurnUnit ( JMM , Frank ) ;
2811: LD_EXP 7
2815: PPUSH
2816: LD_EXP 9
2820: PPUSH
2821: CALL_OW 119
// end ; if Lisa then
2825: LD_EXP 10
2829: IFFALSE 2857
// begin ComTurnUnit ( JMM , Lisa ) ;
2831: LD_EXP 7
2835: PPUSH
2836: LD_EXP 10
2840: PPUSH
2841: CALL_OW 119
// Say ( Lisa , D1-Lisa-2 ) ;
2845: LD_EXP 10
2849: PPUSH
2850: LD_STRING D1-Lisa-2
2852: PPUSH
2853: CALL_OW 88
// end ; if sol then
2857: LD_VAR 0 4
2861: IFFALSE 2889
// begin ComTurnUnit ( JMM , sol ) ;
2863: LD_EXP 7
2867: PPUSH
2868: LD_VAR 0 4
2872: PPUSH
2873: CALL_OW 119
// Say ( sol , D1-Sol1-2 ) ;
2877: LD_VAR 0 4
2881: PPUSH
2882: LD_STRING D1-Sol1-2
2884: PPUSH
2885: CALL_OW 88
// end ; Say ( Gladstone , D1-Glad-2 ) ;
2889: LD_EXP 8
2893: PPUSH
2894: LD_STRING D1-Glad-2
2896: PPUSH
2897: CALL_OW 88
// ComTurnUnit ( team , JMM ) ;
2901: LD_VAR 0 5
2905: PPUSH
2906: LD_EXP 7
2910: PPUSH
2911: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
2915: LD_EXP 7
2919: PPUSH
2920: LD_STRING D1-JMM-2
2922: PPUSH
2923: CALL_OW 88
// ComTurnUnit ( JMM , Gladstone ) ;
2927: LD_EXP 7
2931: PPUSH
2932: LD_EXP 8
2936: PPUSH
2937: CALL_OW 119
// Say ( Gladstone , D1-Glad-3 ) ;
2941: LD_EXP 8
2945: PPUSH
2946: LD_STRING D1-Glad-3
2948: PPUSH
2949: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
2953: LD_EXP 7
2957: PPUSH
2958: LD_STRING D1-JMM-3
2960: PPUSH
2961: CALL_OW 88
// Say ( Gladstone , D1-Glad-4 ) ;
2965: LD_EXP 8
2969: PPUSH
2970: LD_STRING D1-Glad-4
2972: PPUSH
2973: CALL_OW 88
// if Frank then
2977: LD_EXP 9
2981: IFFALSE 3009
// begin ComTurnUnit ( JMM , Frank ) ;
2983: LD_EXP 7
2987: PPUSH
2988: LD_EXP 9
2992: PPUSH
2993: CALL_OW 119
// Say ( Frank , D1-Frank-4 ) ;
2997: LD_EXP 9
3001: PPUSH
3002: LD_STRING D1-Frank-4
3004: PPUSH
3005: CALL_OW 88
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3009: LD_EXP 7
3013: PPUSH
3014: LD_EXP 8
3018: PPUSH
3019: CALL_OW 119
// Say ( JMM , D1-JMM-4 ) ;
3023: LD_EXP 7
3027: PPUSH
3028: LD_STRING D1-JMM-4
3030: PPUSH
3031: CALL_OW 88
// if Lisa then
3035: LD_EXP 10
3039: IFFALSE 3106
// begin Say ( Lisa , D1-Lisa-4 ) ;
3041: LD_EXP 10
3045: PPUSH
3046: LD_STRING D1-Lisa-4
3048: PPUSH
3049: CALL_OW 88
// if Frank then
3053: LD_EXP 9
3057: IFFALSE 3106
// begin ComTurnUnit ( Frank , Lisa ) ;
3059: LD_EXP 9
3063: PPUSH
3064: LD_EXP 10
3068: PPUSH
3069: CALL_OW 119
// Say ( Frank , D1-Frank-5 ) ;
3073: LD_EXP 9
3077: PPUSH
3078: LD_STRING D1-Frank-5
3080: PPUSH
3081: CALL_OW 88
// Wait ( 3 ) ;
3085: LD_INT 3
3087: PPUSH
3088: CALL_OW 67
// AddComTurnUnit ( Frank , JMM ) ;
3092: LD_EXP 9
3096: PPUSH
3097: LD_EXP 7
3101: PPUSH
3102: CALL_OW 179
// end ; end ; if sol then
3106: LD_VAR 0 4
3110: IFFALSE 3124
// Say ( sol , D1-Sol1-5 ) ;
3112: LD_VAR 0 4
3116: PPUSH
3117: LD_STRING D1-Sol1-5
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
3124: LD_EXP 7
3128: PPUSH
3129: LD_STRING D1-JMM-5
3131: PPUSH
3132: CALL_OW 88
// Say ( Gladstone , D1-Glad-5 ) ;
3136: LD_EXP 8
3140: PPUSH
3141: LD_STRING D1-Glad-5
3143: PPUSH
3144: CALL_OW 88
// if Frank then
3148: LD_EXP 9
3152: IFFALSE 3166
// Say ( Frank , D1-Frank-6 ) ;
3154: LD_EXP 9
3158: PPUSH
3159: LD_STRING D1-Frank-6
3161: PPUSH
3162: CALL_OW 88
// Say ( JMM , D1-JMM-6 ) ;
3166: LD_EXP 7
3170: PPUSH
3171: LD_STRING D1-JMM-6
3173: PPUSH
3174: CALL_OW 88
// if Brown and Donaldson then
3178: LD_EXP 14
3182: PUSH
3183: LD_EXP 13
3187: AND
3188: IFFALSE 3237
// case Query ( QCommander ) of 1 :
3190: LD_STRING QCommander
3192: PPUSH
3193: CALL_OW 97
3197: PUSH
3198: LD_INT 1
3200: DOUBLE
3201: EQUAL
3202: IFTRUE 3206
3204: GO 3217
3206: POP
// donaldson_commander := true ; 2 :
3207: LD_ADDR_EXP 4
3211: PUSH
3212: LD_INT 1
3214: ST_TO_ADDR
3215: GO 3237
3217: LD_INT 2
3219: DOUBLE
3220: EQUAL
3221: IFTRUE 3225
3223: GO 3236
3225: POP
// brown_commander := true ; end ;
3226: LD_ADDR_EXP 5
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
3234: GO 3237
3236: POP
// if not Brown and Donaldson then
3237: LD_EXP 14
3241: NOT
3242: PUSH
3243: LD_EXP 13
3247: AND
3248: IFFALSE 3258
// donaldson_commander := true ;
3250: LD_ADDR_EXP 4
3254: PUSH
3255: LD_INT 1
3257: ST_TO_ADDR
// if Brown and not Donaldson then
3258: LD_EXP 14
3262: PUSH
3263: LD_EXP 13
3267: NOT
3268: AND
3269: IFFALSE 3279
// brown_commander := true ;
3271: LD_ADDR_EXP 5
3275: PUSH
3276: LD_INT 1
3278: ST_TO_ADDR
// if donaldson_commander then
3279: LD_EXP 4
3283: IFFALSE 3430
// begin ComTurnUnit ( JMM , Donaldson ) ;
3285: LD_EXP 7
3289: PPUSH
3290: LD_EXP 13
3294: PPUSH
3295: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3299: LD_EXP 7
3303: PPUSH
3304: LD_STRING D1a-JMM-1
3306: PPUSH
3307: CALL_OW 88
// ComMoveUnit ( Donaldson , JMM ) ;
3311: LD_EXP 13
3315: PPUSH
3316: LD_EXP 7
3320: PPUSH
3321: CALL_OW 112
// AddComTurnUnit ( Donaldson , JMM ) ;
3325: LD_EXP 13
3329: PPUSH
3330: LD_EXP 7
3334: PPUSH
3335: CALL_OW 179
// Wait ( 3 ) ;
3339: LD_INT 3
3341: PPUSH
3342: CALL_OW 67
// Say ( Donaldson , D1a-Don-1 ) ;
3346: LD_EXP 13
3350: PPUSH
3351: LD_STRING D1a-Don-1
3353: PPUSH
3354: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3358: LD_EXP 7
3362: PPUSH
3363: LD_STRING D1b-JMM-2
3365: PPUSH
3366: CALL_OW 88
// Say ( Donaldson , D1a-Don-2 ) ;
3370: LD_EXP 13
3374: PPUSH
3375: LD_STRING D1a-Don-2
3377: PPUSH
3378: CALL_OW 88
// ComEnterUnit ( Donaldson , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3382: LD_EXP 13
3386: PPUSH
3387: LD_INT 30
3389: PUSH
3390: LD_INT 0
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PPUSH
3397: CALL_OW 69
3401: PUSH
3402: LD_INT 1
3404: ARRAY
3405: PPUSH
3406: CALL_OW 120
// SaveVariable ( 1 , GammaCommander ) ;
3410: LD_INT 1
3412: PPUSH
3413: LD_STRING GammaCommander
3415: PPUSH
3416: CALL_OW 39
// commander := Donaldson ;
3420: LD_ADDR_VAR 0 7
3424: PUSH
3425: LD_EXP 13
3429: ST_TO_ADDR
// end ; if brown_commander then
3430: LD_EXP 5
3434: IFFALSE 3581
// begin ComTurnUnit ( JMM , Brown ) ;
3436: LD_EXP 7
3440: PPUSH
3441: LD_EXP 14
3445: PPUSH
3446: CALL_OW 119
// Say ( JMM , D1b-JMM-1 ) ;
3450: LD_EXP 7
3454: PPUSH
3455: LD_STRING D1b-JMM-1
3457: PPUSH
3458: CALL_OW 88
// ComMoveUnit ( Brown , JMM ) ;
3462: LD_EXP 14
3466: PPUSH
3467: LD_EXP 7
3471: PPUSH
3472: CALL_OW 112
// AddComTurnUnit ( Brown , JMM ) ;
3476: LD_EXP 14
3480: PPUSH
3481: LD_EXP 7
3485: PPUSH
3486: CALL_OW 179
// Wait ( 3 ) ;
3490: LD_INT 3
3492: PPUSH
3493: CALL_OW 67
// Say ( Brown , D1b-Brown-1 ) ;
3497: LD_EXP 14
3501: PPUSH
3502: LD_STRING D1b-Brown-1
3504: PPUSH
3505: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3509: LD_EXP 7
3513: PPUSH
3514: LD_STRING D1a-JMM-2
3516: PPUSH
3517: CALL_OW 88
// Say ( Brown , D1b-Brown-2 ) ;
3521: LD_EXP 14
3525: PPUSH
3526: LD_STRING D1b-Brown-2
3528: PPUSH
3529: CALL_OW 88
// ComEnterUnit ( Brown , FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
3533: LD_EXP 14
3537: PPUSH
3538: LD_INT 30
3540: PUSH
3541: LD_INT 0
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: PPUSH
3548: CALL_OW 69
3552: PUSH
3553: LD_INT 1
3555: ARRAY
3556: PPUSH
3557: CALL_OW 120
// SaveVariable ( 2 , GammaCommander ) ;
3561: LD_INT 2
3563: PPUSH
3564: LD_STRING GammaCommander
3566: PPUSH
3567: CALL_OW 39
// commander := Brown ;
3571: LD_ADDR_VAR 0 7
3575: PUSH
3576: LD_EXP 14
3580: ST_TO_ADDR
// end ; ComTurnUnit ( JMM , Gladstone ) ;
3581: LD_EXP 7
3585: PPUSH
3586: LD_EXP 8
3590: PPUSH
3591: CALL_OW 119
// if not donaldson_commander and not brown_commander then
3595: LD_EXP 4
3599: NOT
3600: PUSH
3601: LD_EXP 5
3605: NOT
3606: AND
3607: IFFALSE 3631
// begin Say ( JMM , D1c-JMM-1 ) ;
3609: LD_EXP 7
3613: PPUSH
3614: LD_STRING D1c-JMM-1
3616: PPUSH
3617: CALL_OW 88
// SaveVariable ( 3 , GammaCommander ) ;
3621: LD_INT 3
3623: PPUSH
3624: LD_STRING GammaCommander
3626: PPUSH
3627: CALL_OW 39
// end ; Say ( JMM , D1d-JMM-1 ) ;
3631: LD_EXP 7
3635: PPUSH
3636: LD_STRING D1d-JMM-1
3638: PPUSH
3639: CALL_OW 88
// all := FilterAllUnits ( [ f_type , unit_human ] ) diff [ JMM , Gladstone , commander ] ;
3643: LD_ADDR_VAR 0 6
3647: PUSH
3648: LD_INT 21
3650: PUSH
3651: LD_INT 1
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PPUSH
3658: CALL_OW 69
3662: PUSH
3663: LD_EXP 7
3667: PUSH
3668: LD_EXP 8
3672: PUSH
3673: LD_VAR 0 7
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: LIST
3682: DIFF
3683: ST_TO_ADDR
// save_group := CharacterSelection ( 1 , 5 , 5 , [ sel_change_class , JMM , sel_dont_change_class , Gladstone , sel_not_hired , sel_changeable , sel_change_class ] ^ all ^ [ sel_dont_change_class , sel_not_changeable , commander ] , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
3684: LD_ADDR_EXP 6
3688: PUSH
3689: LD_STRING 1
3691: PPUSH
3692: LD_INT 5
3694: PPUSH
3695: LD_INT 5
3697: PPUSH
3698: LD_INT -5
3700: PUSH
3701: LD_EXP 7
3705: PUSH
3706: LD_INT -6
3708: PUSH
3709: LD_EXP 8
3713: PUSH
3714: LD_INT -2
3716: PUSH
3717: LD_INT -3
3719: PUSH
3720: LD_INT -5
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: LIST
3727: LIST
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: LD_VAR 0 6
3736: ADD
3737: PUSH
3738: LD_INT -6
3740: PUSH
3741: LD_INT -4
3743: PUSH
3744: LD_VAR 0 7
3748: PUSH
3749: EMPTY
3750: LIST
3751: LIST
3752: LIST
3753: ADD
3754: PPUSH
3755: LD_INT 1
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 2
3763: PUSH
3764: LD_INT 1
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PUSH
3771: LD_INT 4
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: LIST
3779: PPUSH
3780: CALL_OW 42
3784: ST_TO_ADDR
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
3785: LD_EXP 7
3789: PPUSH
3790: LD_EXP 2
3794: PUSH
3795: LD_STRING JMM
3797: STR
3798: PPUSH
3799: CALL_OW 38
// if Lisa in save_group then
3803: LD_EXP 10
3807: PUSH
3808: LD_EXP 6
3812: IN
3813: IFFALSE 3843
// begin SaveVariable ( true , LisaInDelta ) ;
3815: LD_INT 1
3817: PPUSH
3818: LD_STRING LisaInDelta
3820: PPUSH
3821: CALL_OW 39
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
3825: LD_EXP 10
3829: PPUSH
3830: LD_EXP 2
3834: PUSH
3835: LD_STRING Lisa
3837: STR
3838: PPUSH
3839: CALL_OW 38
// end ; if Bobby in save_group then
3843: LD_EXP 12
3847: PUSH
3848: LD_EXP 6
3852: IN
3853: IFFALSE 3883
// begin SaveVariable ( true , BobbyInDelta ) ;
3855: LD_INT 1
3857: PPUSH
3858: LD_STRING BobbyInDelta
3860: PPUSH
3861: CALL_OW 39
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
3865: LD_EXP 12
3869: PPUSH
3870: LD_EXP 2
3874: PUSH
3875: LD_STRING Bobby
3877: STR
3878: PPUSH
3879: CALL_OW 38
// end ; if Cyrus in save_group then
3883: LD_EXP 11
3887: PUSH
3888: LD_EXP 6
3892: IN
3893: IFFALSE 3923
// begin SaveVariable ( true , CyrusInDelta ) ;
3895: LD_INT 1
3897: PPUSH
3898: LD_STRING CyrusInDelta
3900: PPUSH
3901: CALL_OW 39
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
3905: LD_EXP 11
3909: PPUSH
3910: LD_EXP 2
3914: PUSH
3915: LD_STRING Cyrus
3917: STR
3918: PPUSH
3919: CALL_OW 38
// end ; if Frank in save_group then
3923: LD_EXP 9
3927: PUSH
3928: LD_EXP 6
3932: IN
3933: IFFALSE 3963
// begin SaveVariable ( true , FrankInDelta ) ;
3935: LD_INT 1
3937: PPUSH
3938: LD_STRING FrankInDelta
3940: PPUSH
3941: CALL_OW 39
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
3945: LD_EXP 9
3949: PPUSH
3950: LD_EXP 2
3954: PUSH
3955: LD_STRING Frank
3957: STR
3958: PPUSH
3959: CALL_OW 38
// end ; if Brown in save_group then
3963: LD_EXP 14
3967: PUSH
3968: LD_EXP 6
3972: IN
3973: IFFALSE 4003
// begin SaveVariable ( true , BrownInDelta ) ;
3975: LD_INT 1
3977: PPUSH
3978: LD_STRING BrownInDelta
3980: PPUSH
3981: CALL_OW 39
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
3985: LD_EXP 14
3989: PPUSH
3990: LD_EXP 2
3994: PUSH
3995: LD_STRING Brown
3997: STR
3998: PPUSH
3999: CALL_OW 38
// end ; if Donaldson in save_group then
4003: LD_EXP 13
4007: PUSH
4008: LD_EXP 6
4012: IN
4013: IFFALSE 4043
// begin SaveVariable ( true , DonaldsonInDelta ) ;
4015: LD_INT 1
4017: PPUSH
4018: LD_STRING DonaldsonInDelta
4020: PPUSH
4021: CALL_OW 39
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4025: LD_EXP 13
4029: PPUSH
4030: LD_EXP 2
4034: PUSH
4035: LD_STRING Donaldson
4037: STR
4038: PPUSH
4039: CALL_OW 38
// end ; SaveCharacters ( all diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] ^ save_group , othersGamma ) ;
4043: LD_VAR 0 6
4047: PUSH
4048: LD_EXP 7
4052: PUSH
4053: LD_EXP 8
4057: PUSH
4058: LD_EXP 10
4062: PUSH
4063: LD_EXP 11
4067: PUSH
4068: LD_EXP 12
4072: PUSH
4073: LD_EXP 9
4077: PUSH
4078: LD_EXP 13
4082: PUSH
4083: LD_EXP 14
4087: PUSH
4088: LD_INT 0
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_EXP 6
4106: ADD
4107: DIFF
4108: PPUSH
4109: LD_STRING othersGamma
4111: PPUSH
4112: CALL_OW 38
// SaveCharacters ( save_group diff [ JMM , Gladstone , Lisa , Cyrus , Bobby , Frank , Donaldson , Brown , 0 ] , othersDelta ) ;
4116: LD_EXP 6
4120: PUSH
4121: LD_EXP 7
4125: PUSH
4126: LD_EXP 8
4130: PUSH
4131: LD_EXP 10
4135: PUSH
4136: LD_EXP 11
4140: PUSH
4141: LD_EXP 12
4145: PUSH
4146: LD_EXP 9
4150: PUSH
4151: LD_EXP 13
4155: PUSH
4156: LD_EXP 14
4160: PUSH
4161: LD_INT 0
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: LIST
4173: LIST
4174: DIFF
4175: PPUSH
4176: LD_STRING othersDelta
4178: PPUSH
4179: CALL_OW 38
// Wait ( 3 ) ;
4183: LD_INT 3
4185: PPUSH
4186: CALL_OW 67
// for i in save_group do
4190: LD_ADDR_VAR 0 3
4194: PUSH
4195: LD_EXP 6
4199: PUSH
4200: FOR_IN
4201: IFFALSE 4232
// begin if IsInUnit ( i ) then
4203: LD_VAR 0 3
4207: PPUSH
4208: CALL_OW 310
4212: IFFALSE 4223
// ComExitBuilding ( i ) ;
4214: LD_VAR 0 3
4218: PPUSH
4219: CALL_OW 122
// Wait ( 3 ) ;
4223: LD_INT 3
4225: PPUSH
4226: CALL_OW 67
// end ;
4230: GO 4200
4232: POP
4233: POP
// save_group := Insert ( save_group , 1 , JMM ) ;
4234: LD_ADDR_EXP 6
4238: PUSH
4239: LD_EXP 6
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_EXP 7
4251: PPUSH
4252: CALL_OW 2
4256: ST_TO_ADDR
// save_group := Insert ( save_group , 2 , Gladstone ) ;
4257: LD_ADDR_EXP 6
4261: PUSH
4262: LD_EXP 6
4266: PPUSH
4267: LD_INT 2
4269: PPUSH
4270: LD_EXP 8
4274: PPUSH
4275: CALL_OW 2
4279: ST_TO_ADDR
// filter := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
4280: LD_ADDR_VAR 0 8
4284: PUSH
4285: LD_INT 21
4287: PUSH
4288: LD_INT 2
4290: PUSH
4291: EMPTY
4292: LIST
4293: LIST
4294: PPUSH
4295: CALL_OW 69
4299: ST_TO_ADDR
// for i = 1 to filter do
4300: LD_ADDR_VAR 0 3
4304: PUSH
4305: DOUBLE
4306: LD_INT 1
4308: DEC
4309: ST_TO_ADDR
4310: LD_VAR 0 8
4314: PUSH
4315: FOR_TO
4316: IFFALSE 4346
// ComEnterUnit ( save_group [ i ] , filter [ i ] ) ;
4318: LD_EXP 6
4322: PUSH
4323: LD_VAR 0 3
4327: ARRAY
4328: PPUSH
4329: LD_VAR 0 8
4333: PUSH
4334: LD_VAR 0 3
4338: ARRAY
4339: PPUSH
4340: CALL_OW 120
4344: GO 4315
4346: POP
4347: POP
// AddComMoveXY ( save_group , 87 , 27 ) ;
4348: LD_EXP 6
4352: PPUSH
4353: LD_INT 87
4355: PPUSH
4356: LD_INT 27
4358: PPUSH
4359: CALL_OW 171
// Wait ( 0 0$05 ) ;
4363: LD_INT 175
4365: PPUSH
4366: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
4370: LD_INT 1
4372: PPUSH
4373: LD_STRING %_cont
4375: PPUSH
4376: CALL_OW 340
// end ; end_of_file
4380: LD_VAR 0 1
4384: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4385: LD_INT 0
4387: PPUSH
4388: PPUSH
// if exist_mode then
4389: LD_VAR 0 2
4393: IFFALSE 4418
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
4395: LD_ADDR_VAR 0 4
4399: PUSH
4400: LD_EXP 3
4404: PUSH
4405: LD_VAR 0 1
4409: STR
4410: PPUSH
4411: CALL_OW 34
4415: ST_TO_ADDR
4416: GO 4433
// unit := NewCharacter ( ident ) ;
4418: LD_ADDR_VAR 0 4
4422: PUSH
4423: LD_VAR 0 1
4427: PPUSH
4428: CALL_OW 25
4432: ST_TO_ADDR
// result := unit ;
4433: LD_ADDR_VAR 0 3
4437: PUSH
4438: LD_VAR 0 4
4442: ST_TO_ADDR
// end ;
4443: LD_VAR 0 3
4447: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
4448: LD_INT 0
4450: PPUSH
// uc_side := side ;
4451: LD_ADDR_OWVAR 20
4455: PUSH
4456: LD_VAR 0 1
4460: ST_TO_ADDR
// uc_nation := nation ;
4461: LD_ADDR_OWVAR 21
4465: PUSH
4466: LD_VAR 0 2
4470: ST_TO_ADDR
// vc_chassis := chassis ;
4471: LD_ADDR_OWVAR 37
4475: PUSH
4476: LD_VAR 0 3
4480: ST_TO_ADDR
// vc_engine := engine ;
4481: LD_ADDR_OWVAR 39
4485: PUSH
4486: LD_VAR 0 4
4490: ST_TO_ADDR
// vc_control := control ;
4491: LD_ADDR_OWVAR 38
4495: PUSH
4496: LD_VAR 0 5
4500: ST_TO_ADDR
// vc_weapon := weapon ;
4501: LD_ADDR_OWVAR 40
4505: PUSH
4506: LD_VAR 0 6
4510: ST_TO_ADDR
// vc_fuel_battery := fuel ;
4511: LD_ADDR_OWVAR 41
4515: PUSH
4516: LD_VAR 0 7
4520: ST_TO_ADDR
// result := CreateVehicle ;
4521: LD_ADDR_VAR 0 8
4525: PUSH
4526: CALL_OW 45
4530: ST_TO_ADDR
// end ;
4531: LD_VAR 0 8
4535: RET
// export function SayX ( units , ident ) ; var i ; begin
4536: LD_INT 0
4538: PPUSH
4539: PPUSH
// result := false ;
4540: LD_ADDR_VAR 0 3
4544: PUSH
4545: LD_INT 0
4547: ST_TO_ADDR
// if not units then
4548: LD_VAR 0 1
4552: NOT
4553: IFFALSE 4557
// exit ;
4555: GO 4611
// for i in units do
4557: LD_ADDR_VAR 0 4
4561: PUSH
4562: LD_VAR 0 1
4566: PUSH
4567: FOR_IN
4568: IFFALSE 4609
// if IsOk ( i ) then
4570: LD_VAR 0 4
4574: PPUSH
4575: CALL_OW 302
4579: IFFALSE 4607
// begin Say ( i , ident ) ;
4581: LD_VAR 0 4
4585: PPUSH
4586: LD_VAR 0 2
4590: PPUSH
4591: CALL_OW 88
// result := i ;
4595: LD_ADDR_VAR 0 3
4599: PUSH
4600: LD_VAR 0 4
4604: ST_TO_ADDR
// break ;
4605: GO 4609
// end ;
4607: GO 4567
4609: POP
4610: POP
// end ;
4611: LD_VAR 0 3
4615: RET
