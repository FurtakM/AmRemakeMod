// export MacMillan , Burlak , Joan , ru_sci , Powell , Stevens , truck1 , truck2 ; export blast_was_seen , lab_destroyed , time_out , entered_contaminated_area , original_stevens , blast_time , technology_taken , keep_base_finished ; export you , americans ; export time_to_complete , ru_artefact ; function prepare_units ; var JMM_car , Bur_car , JMM_load , Bur_load ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
// uc_nation := nation_american ;
   7: LD_ADDR_OWVAR 21
  11: PUSH
  12: LD_INT 1
  14: ST_TO_ADDR
// uc_side := you ;
  15: LD_ADDR_OWVAR 20
  19: PUSH
  20: LD_EXP 17
  24: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  25: LD_ADDR_EXP 1
  29: PUSH
  30: LD_STRING JMM
  32: PPUSH
  33: CALL_OW 34
  37: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
  38: LD_EXP 1
  42: PPUSH
  43: LD_INT 2
  45: PPUSH
  46: CALL_OW 336
// Burlak := CreateCharacter ( Burlak ) ;
  50: LD_ADDR_EXP 2
  54: PUSH
  55: LD_STRING Burlak
  57: PPUSH
  58: CALL_OW 34
  62: ST_TO_ADDR
// SetClass ( Burlak , class_mechanic ) ;
  63: LD_EXP 2
  67: PPUSH
  68: LD_INT 3
  70: PPUSH
  71: CALL_OW 336
// if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) then
  75: LD_STRING Joan
  77: PPUSH
  78: CALL_OW 28
  82: PUSH
  83: LD_STRING Joan
  85: PPUSH
  86: CALL_OW 29
  90: AND
  91: IFFALSE 108
// Joan := CreateCharacter ( Joan ) else
  93: LD_ADDR_EXP 3
  97: PUSH
  98: LD_STRING Joan
 100: PPUSH
 101: CALL_OW 34
 105: ST_TO_ADDR
 106: GO 144
// begin Joan := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// uc_nation := nation_russian ;
 116: LD_ADDR_OWVAR 21
 120: PUSH
 121: LD_INT 3
 123: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
 124: LD_INT 1
 126: PPUSH
 127: LD_INT 8
 129: PPUSH
 130: CALL_OW 384
// ru_sci := CreateHuman ;
 134: LD_ADDR_EXP 4
 138: PUSH
 139: CALL_OW 44
 143: ST_TO_ADDR
// end ; uc_nation := nation_american ;
 144: LD_ADDR_OWVAR 21
 148: PUSH
 149: LD_INT 1
 151: ST_TO_ADDR
// uc_side := americans ;
 152: LD_ADDR_OWVAR 20
 156: PUSH
 157: LD_EXP 18
 161: ST_TO_ADDR
// Powell := CreateCharacter ( Powell ) ;
 162: LD_ADDR_EXP 5
 166: PUSH
 167: LD_STRING Powell
 169: PPUSH
 170: CALL_OW 34
 174: ST_TO_ADDR
// if TestCharacters ( Stevens ) and CheckCharacterSet ( Stevens ) then
 175: LD_STRING Stevens
 177: PPUSH
 178: CALL_OW 28
 182: PUSH
 183: LD_STRING Stevens
 185: PPUSH
 186: CALL_OW 29
 190: AND
 191: IFFALSE 216
// begin Stevens := CreateCharacter ( Stevens ) ;
 193: LD_ADDR_EXP 6
 197: PUSH
 198: LD_STRING Stevens
 200: PPUSH
 201: CALL_OW 34
 205: ST_TO_ADDR
// original_stevens := true ;
 206: LD_ADDR_EXP 13
 210: PUSH
 211: LD_INT 1
 213: ST_TO_ADDR
// end else
 214: GO 252
// begin uc_nation := nation_american ;
 216: LD_ADDR_OWVAR 21
 220: PUSH
 221: LD_INT 1
 223: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
 224: LD_INT 1
 226: PPUSH
 227: LD_INT 8
 229: PPUSH
 230: CALL_OW 384
// Stevens := CreateHuman ;
 234: LD_ADDR_EXP 6
 238: PUSH
 239: CALL_OW 44
 243: ST_TO_ADDR
// original_stevens := false ;
 244: LD_ADDR_EXP 13
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ; uc_side = you ;
 252: LD_ADDR_OWVAR 20
 256: PUSH
 257: LD_EXP 17
 261: ST_TO_ADDR
// uc_nation := nation_american ;
 262: LD_ADDR_OWVAR 21
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// uc_direction := 5 ;
 270: LD_ADDR_OWVAR 24
 274: PUSH
 275: LD_INT 5
 277: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 278: LD_ADDR_VAR 0 2
 282: PUSH
 283: LD_STRING JMM_car
 285: PPUSH
 286: LD_INT 3
 288: PUSH
 289: LD_INT 1
 291: PUSH
 292: LD_INT 1
 294: PUSH
 295: LD_INT 12
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// JMM_load := LoadVariable ( JMM_car_load , 0 ) ;
 309: LD_ADDR_VAR 0 4
 313: PUSH
 314: LD_STRING JMM_car_load
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 325: LD_VAR 0 2
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 1
 336: PUSH
 337: LD_INT 2
 339: PUSH
 340: LD_INT 3
 342: PUSH
 343: LD_INT 4
 345: PUSH
 346: LD_INT 5
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: IN
 356: IFFALSE 368
// uc_nation := nation_american else
 358: LD_ADDR_OWVAR 21
 362: PUSH
 363: LD_INT 1
 365: ST_TO_ADDR
 366: GO 376
// uc_nation := nation_russian ;
 368: LD_ADDR_OWVAR 21
 372: PUSH
 373: LD_INT 3
 375: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 376: LD_ADDR_OWVAR 37
 380: PUSH
 381: LD_VAR 0 2
 385: PUSH
 386: LD_INT 1
 388: ARRAY
 389: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 390: LD_ADDR_OWVAR 39
 394: PUSH
 395: LD_VAR 0 2
 399: PUSH
 400: LD_INT 2
 402: ARRAY
 403: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
 404: LD_ADDR_OWVAR 38
 408: PUSH
 409: LD_VAR 0 2
 413: PUSH
 414: LD_INT 3
 416: ARRAY
 417: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
 418: LD_ADDR_OWVAR 40
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 4
 430: ARRAY
 431: ST_TO_ADDR
// truck1 := CreateVehicle ;
 432: LD_ADDR_EXP 7
 436: PUSH
 437: CALL_OW 45
 441: ST_TO_ADDR
// if JMM_load > 0 then
 442: LD_VAR 0 4
 446: PUSH
 447: LD_INT 0
 449: GREATER
 450: IFFALSE 469
// SetCargo ( truck1 , mat_oil , JMM_load ) ;
 452: LD_EXP 7
 456: PPUSH
 457: LD_INT 2
 459: PPUSH
 460: LD_VAR 0 4
 464: PPUSH
 465: CALL_OW 290
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ) ;
 469: LD_ADDR_VAR 0 3
 473: PUSH
 474: LD_STRING Bur_car
 476: PPUSH
 477: LD_INT 22
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 43
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PPUSH
 495: CALL_OW 30
 499: ST_TO_ADDR
// Bur_load := LoadVariable ( Bur_car_load , 0 ) ;
 500: LD_ADDR_VAR 0 5
 504: PUSH
 505: LD_STRING Bur_car_load
 507: PPUSH
 508: LD_INT 0
 510: PPUSH
 511: CALL_OW 30
 515: ST_TO_ADDR
// if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
 516: LD_VAR 0 3
 520: PUSH
 521: LD_INT 1
 523: ARRAY
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 22
 530: PUSH
 531: LD_INT 23
 533: PUSH
 534: LD_INT 24
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: LIST
 541: LIST
 542: IN
 543: IFFALSE 555
// uc_nation := nation_russian else
 545: LD_ADDR_OWVAR 21
 549: PUSH
 550: LD_INT 3
 552: ST_TO_ADDR
 553: GO 563
// uc_nation := nation_american ;
 555: LD_ADDR_OWVAR 21
 559: PUSH
 560: LD_INT 1
 562: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
 563: LD_ADDR_OWVAR 37
 567: PUSH
 568: LD_VAR 0 3
 572: PUSH
 573: LD_INT 1
 575: ARRAY
 576: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
 577: LD_ADDR_OWVAR 39
 581: PUSH
 582: LD_VAR 0 3
 586: PUSH
 587: LD_INT 2
 589: ARRAY
 590: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
 591: LD_ADDR_OWVAR 38
 595: PUSH
 596: LD_VAR 0 3
 600: PUSH
 601: LD_INT 3
 603: ARRAY
 604: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
 605: LD_ADDR_OWVAR 40
 609: PUSH
 610: LD_VAR 0 3
 614: PUSH
 615: LD_INT 4
 617: ARRAY
 618: ST_TO_ADDR
// truck2 := CreateVehicle ;
 619: LD_ADDR_EXP 8
 623: PUSH
 624: CALL_OW 45
 628: ST_TO_ADDR
// if Bur_load > 0 then
 629: LD_VAR 0 5
 633: PUSH
 634: LD_INT 0
 636: GREATER
 637: IFFALSE 656
// SetCargo ( truck2 , mat_oil , Bur_load ) ;
 639: LD_EXP 8
 643: PPUSH
 644: LD_INT 2
 646: PPUSH
 647: LD_VAR 0 5
 651: PPUSH
 652: CALL_OW 290
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 656: LD_EXP 1
 660: PPUSH
 661: LD_EXP 7
 665: PPUSH
 666: CALL_OW 52
// PlaceHumanInUnit ( Burlak , truck2 ) ;
 670: LD_EXP 2
 674: PPUSH
 675: LD_EXP 8
 679: PPUSH
 680: CALL_OW 52
// PlaceUnitXY ( truck1 , 200 , 86 , false ) ;
 684: LD_EXP 7
 688: PPUSH
 689: LD_INT 200
 691: PPUSH
 692: LD_INT 86
 694: PPUSH
 695: LD_INT 0
 697: PPUSH
 698: CALL_OW 48
// PlaceUnitXY ( truck2 , 202 , 90 , false ) ;
 702: LD_EXP 8
 706: PPUSH
 707: LD_INT 202
 709: PPUSH
 710: LD_INT 90
 712: PPUSH
 713: LD_INT 0
 715: PPUSH
 716: CALL_OW 48
// ComFree ( [ MacMillan , Burlak ] ) ;
 720: LD_EXP 1
 724: PUSH
 725: LD_EXP 2
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PPUSH
 734: CALL_OW 139
// end ;
 738: LD_VAR 0 1
 742: RET
// function prepare_sides ; begin
 743: LD_INT 0
 745: PPUSH
// you = 7 ;
 746: LD_ADDR_EXP 17
 750: PUSH
 751: LD_INT 7
 753: ST_TO_ADDR
// americans = 1 ;
 754: LD_ADDR_EXP 18
 758: PUSH
 759: LD_INT 1
 761: ST_TO_ADDR
// SetAttitude ( you , americans , att_enemy , true ) ;
 762: LD_EXP 17
 766: PPUSH
 767: LD_EXP 18
 771: PPUSH
 772: LD_INT 2
 774: PPUSH
 775: LD_INT 1
 777: PPUSH
 778: CALL_OW 80
// blast_was_seen := false ;
 782: LD_ADDR_EXP 9
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// time_out := false ;
 790: LD_ADDR_EXP 11
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// entered_contaminated_area := false ;
 798: LD_ADDR_EXP 12
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// blast_countdown := false ;
 806: LD_ADDR_EXP 27
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// lab_destroyed := false ;
 814: LD_ADDR_EXP 10
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// technology_taken := false ;
 822: LD_ADDR_EXP 15
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// time_to_complete := [ 15 15$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 830: LD_ADDR_EXP 19
 834: PUSH
 835: LD_INT 31500
 837: PUSH
 838: LD_INT 21000
 840: PUSH
 841: LD_INT 16800
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: LD_OWVAR 67
 853: ARRAY
 854: ST_TO_ADDR
// ru_artefact := 4 ;
 855: LD_ADDR_EXP 20
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// disable ( 1 ) ;
 863: LD_INT 1
 865: DISABLE_MARKED
// disable ( 2 ) ;
 866: LD_INT 2
 868: DISABLE_MARKED
// disable ( 3 ) ;
 869: LD_INT 3
 871: DISABLE_MARKED
// disable ( 4 ) ;
 872: LD_INT 4
 874: DISABLE_MARKED
// disable ( 5 ) ;
 875: LD_INT 5
 877: DISABLE_MARKED
// disable ( 6 ) ;
 878: LD_INT 6
 880: DISABLE_MARKED
// disable ( 7 ) ;
 881: LD_INT 7
 883: DISABLE_MARKED
// disable ( 8 ) ;
 884: LD_INT 8
 886: DISABLE_MARKED
// disable ( 9 ) ;
 887: LD_INT 9
 889: DISABLE_MARKED
// disable ( 10 ) ;
 890: LD_INT 10
 892: DISABLE_MARKED
// end ;
 893: LD_VAR 0 1
 897: RET
// starting begin prepare_sides ;
 898: CALL 743 0 0
// prepare_units ;
 902: CALL 0 0 0
// prepare_us_side ;
 906: CALL 2808 0 0
// starting_scene ;
 910: CALL 4334 0 0
// end ;
 914: END
// export function konec_mise ; var un , JMM_car , Bur_car ; begin
 915: LD_INT 0
 917: PPUSH
 918: PPUSH
 919: PPUSH
 920: PPUSH
// AddMedal ( Explosion , blast_was_seen ) ;
 921: LD_STRING Explosion
 923: PPUSH
 924: LD_EXP 9
 928: PPUSH
 929: CALL_OW 101
// AddMedal ( BioHazard , entered_contaminated_area ) ;
 933: LD_STRING BioHazard
 935: PPUSH
 936: LD_EXP 12
 940: PPUSH
 941: CALL_OW 101
// AddMedal ( Speed , ( TICK - blast_time ) < time_to_complete ) ;
 945: LD_STRING Speed
 947: PPUSH
 948: LD_OWVAR 1
 952: PUSH
 953: LD_EXP 14
 957: MINUS
 958: PUSH
 959: LD_EXP 19
 963: LESS
 964: PPUSH
 965: CALL_OW 101
// GiveMedals ( Main ) ;
 969: LD_STRING Main
 971: PPUSH
 972: CALL_OW 102
// RewardPeople ( [ Burlak , MacMillan ] ) ;
 976: LD_EXP 2
 980: PUSH
 981: LD_EXP 1
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PPUSH
 990: CALL_OW 43
// SaveCharacters ( MacMillan , JMM ) ;
 994: LD_EXP 1
 998: PPUSH
 999: LD_STRING JMM
1001: PPUSH
1002: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
1006: LD_EXP 2
1010: PPUSH
1011: LD_STRING Burlak
1013: PPUSH
1014: CALL_OW 38
// un := IsInUnit ( MacMillan ) ;
1018: LD_ADDR_VAR 0 2
1022: PUSH
1023: LD_EXP 1
1027: PPUSH
1028: CALL_OW 310
1032: ST_TO_ADDR
// if un then
1033: LD_VAR 0 2
1037: IFFALSE 1104
// begin JMM_car := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1039: LD_ADDR_VAR 0 3
1043: PUSH
1044: LD_VAR 0 2
1048: PPUSH
1049: CALL_OW 265
1053: PUSH
1054: LD_VAR 0 2
1058: PPUSH
1059: CALL_OW 262
1063: PUSH
1064: LD_VAR 0 2
1068: PPUSH
1069: CALL_OW 263
1073: PUSH
1074: LD_VAR 0 2
1078: PPUSH
1079: CALL_OW 264
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: ST_TO_ADDR
// SaveVariable ( JMM_car , JMM_car ) ;
1090: LD_VAR 0 3
1094: PPUSH
1095: LD_STRING JMM_car
1097: PPUSH
1098: CALL_OW 39
// end else
1102: GO 1111
// DeleteVariable ( JMM_car ) ;
1104: LD_STRING JMM_car
1106: PPUSH
1107: CALL_OW 41
// un := IsInUnit ( Burlak ) ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_EXP 2
1120: PPUSH
1121: CALL_OW 310
1125: ST_TO_ADDR
// if un then
1126: LD_VAR 0 2
1130: IFFALSE 1197
// begin Bur_car := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1132: LD_ADDR_VAR 0 4
1136: PUSH
1137: LD_VAR 0 2
1141: PPUSH
1142: CALL_OW 265
1146: PUSH
1147: LD_VAR 0 2
1151: PPUSH
1152: CALL_OW 262
1156: PUSH
1157: LD_VAR 0 2
1161: PPUSH
1162: CALL_OW 263
1166: PUSH
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 264
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: ST_TO_ADDR
// SaveVariable ( Bur_car , Bur_car ) ;
1183: LD_VAR 0 4
1187: PPUSH
1188: LD_STRING Bur_car
1190: PPUSH
1191: CALL_OW 39
// end else
1195: GO 1204
// DeleteVariable ( Bur_car ) ;
1197: LD_STRING Bur_car
1199: PPUSH
1200: CALL_OW 41
// YouWin ;
1204: CALL_OW 103
// end ;
1208: LD_VAR 0 1
1212: RET
// export function Mission_Failed ( style ) ; begin
1213: LD_INT 0
1215: PPUSH
// case style of 1 :
1216: LD_VAR 0 1
1220: PUSH
1221: LD_INT 1
1223: DOUBLE
1224: EQUAL
1225: IFTRUE 1229
1227: GO 1239
1229: POP
// YouLost ( Burlak ) ; 2 :
1230: LD_STRING Burlak
1232: PPUSH
1233: CALL_OW 104
1237: GO 1330
1239: LD_INT 2
1241: DOUBLE
1242: EQUAL
1243: IFTRUE 1247
1245: GO 1257
1247: POP
// YouLost ( JMM ) ; 3 :
1248: LD_STRING JMM
1250: PPUSH
1251: CALL_OW 104
1255: GO 1330
1257: LD_INT 3
1259: DOUBLE
1260: EQUAL
1261: IFTRUE 1265
1263: GO 1275
1265: POP
// YouLost ( Time ) ; 4 :
1266: LD_STRING Time
1268: PPUSH
1269: CALL_OW 104
1273: GO 1330
1275: LD_INT 4
1277: DOUBLE
1278: EQUAL
1279: IFTRUE 1283
1281: GO 1293
1283: POP
// YouLost ( Artefact ) ; 5 :
1284: LD_STRING Artefact
1286: PPUSH
1287: CALL_OW 104
1291: GO 1330
1293: LD_INT 5
1295: DOUBLE
1296: EQUAL
1297: IFTRUE 1301
1299: GO 1311
1301: POP
// YouLost ( Lab ) ; 6 :
1302: LD_STRING Lab
1304: PPUSH
1305: CALL_OW 104
1309: GO 1330
1311: LD_INT 6
1313: DOUBLE
1314: EQUAL
1315: IFTRUE 1319
1317: GO 1329
1319: POP
// YouLost ( Cargo ) ; end ;
1320: LD_STRING Cargo
1322: PPUSH
1323: CALL_OW 104
1327: GO 1330
1329: POP
// end ; end_of_file
1330: LD_VAR 0 2
1334: RET
// export us_sol , us_sci , us_mech , us_all_units ; export us_patrol_1 , us_patrol_2 ; export blast_countdown ; every 0 0$1 marked 2 do var i , x , y , cesta ;
1335: GO 1337
1337: DISABLE
1338: LD_INT 0
1340: PPUSH
1341: PPUSH
1342: PPUSH
1343: PPUSH
// begin if difficulty < 3 then
1344: LD_OWVAR 67
1348: PUSH
1349: LD_INT 3
1351: LESS
1352: IFFALSE 1491
// cesta := [ 101 , 39 , 124 , 31 , 123 , 7 , 158 , 21 , 168 , 40 , 168 , 65 , 167 , 90 , 146 , 83 , 146 , 83 , 167 , 90 , 168 , 65 , 168 , 40 , 158 , 21 , 123 , 7 , 124 , 31 , 101 , 39 ] else
1354: LD_ADDR_VAR 0 4
1358: PUSH
1359: LD_INT 101
1361: PUSH
1362: LD_INT 39
1364: PUSH
1365: LD_INT 124
1367: PUSH
1368: LD_INT 31
1370: PUSH
1371: LD_INT 123
1373: PUSH
1374: LD_INT 7
1376: PUSH
1377: LD_INT 158
1379: PUSH
1380: LD_INT 21
1382: PUSH
1383: LD_INT 168
1385: PUSH
1386: LD_INT 40
1388: PUSH
1389: LD_INT 168
1391: PUSH
1392: LD_INT 65
1394: PUSH
1395: LD_INT 167
1397: PUSH
1398: LD_INT 90
1400: PUSH
1401: LD_INT 146
1403: PUSH
1404: LD_INT 83
1406: PUSH
1407: LD_INT 146
1409: PUSH
1410: LD_INT 83
1412: PUSH
1413: LD_INT 167
1415: PUSH
1416: LD_INT 90
1418: PUSH
1419: LD_INT 168
1421: PUSH
1422: LD_INT 65
1424: PUSH
1425: LD_INT 168
1427: PUSH
1428: LD_INT 40
1430: PUSH
1431: LD_INT 158
1433: PUSH
1434: LD_INT 21
1436: PUSH
1437: LD_INT 123
1439: PUSH
1440: LD_INT 7
1442: PUSH
1443: LD_INT 124
1445: PUSH
1446: LD_INT 31
1448: PUSH
1449: LD_INT 101
1451: PUSH
1452: LD_INT 39
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: LIST
1488: ST_TO_ADDR
1489: GO 1562
// cesta := [ 101 , 39 , 124 , 31 , 123 , 7 , 135 , 7 , 135 , 7 , 123 , 7 , 124 , 31 , 101 , 39 ] ;
1491: LD_ADDR_VAR 0 4
1495: PUSH
1496: LD_INT 101
1498: PUSH
1499: LD_INT 39
1501: PUSH
1502: LD_INT 124
1504: PUSH
1505: LD_INT 31
1507: PUSH
1508: LD_INT 123
1510: PUSH
1511: LD_INT 7
1513: PUSH
1514: LD_INT 135
1516: PUSH
1517: LD_INT 7
1519: PUSH
1520: LD_INT 135
1522: PUSH
1523: LD_INT 7
1525: PUSH
1526: LD_INT 123
1528: PUSH
1529: LD_INT 7
1531: PUSH
1532: LD_INT 124
1534: PUSH
1535: LD_INT 31
1537: PUSH
1538: LD_INT 101
1540: PUSH
1541: LD_INT 39
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: LIST
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: ST_TO_ADDR
// repeat for i = 1 to ( cesta div 2 ) do
1562: LD_ADDR_VAR 0 1
1566: PUSH
1567: DOUBLE
1568: LD_INT 1
1570: DEC
1571: ST_TO_ADDR
1572: LD_VAR 0 4
1576: PUSH
1577: LD_INT 2
1579: DIV
1580: PUSH
1581: FOR_TO
1582: IFFALSE 1706
// begin x := cesta [ ( i * 2 ) - 1 ] ;
1584: LD_ADDR_VAR 0 2
1588: PUSH
1589: LD_VAR 0 4
1593: PUSH
1594: LD_VAR 0 1
1598: PUSH
1599: LD_INT 2
1601: MUL
1602: PUSH
1603: LD_INT 1
1605: MINUS
1606: ARRAY
1607: ST_TO_ADDR
// y := cesta [ ( i * 2 ) ] ;
1608: LD_ADDR_VAR 0 3
1612: PUSH
1613: LD_VAR 0 4
1617: PUSH
1618: LD_VAR 0 1
1622: PUSH
1623: LD_INT 2
1625: MUL
1626: ARRAY
1627: ST_TO_ADDR
// ComAgressiveMove ( us_patrol_1 , x , y ) ;
1628: LD_EXP 25
1632: PPUSH
1633: LD_VAR 0 2
1637: PPUSH
1638: LD_VAR 0 3
1642: PPUSH
1643: CALL_OW 114
// repeat wait ( 0 0$3 ) ;
1647: LD_INT 105
1649: PPUSH
1650: CALL_OW 67
// y := true ;
1654: LD_ADDR_VAR 0 3
1658: PUSH
1659: LD_INT 1
1661: ST_TO_ADDR
// for x in us_patrol_1 do
1662: LD_ADDR_VAR 0 2
1666: PUSH
1667: LD_EXP 25
1671: PUSH
1672: FOR_IN
1673: IFFALSE 1696
// if IsBusy ( x ) then
1675: LD_VAR 0 2
1679: PPUSH
1680: CALL_OW 315
1684: IFFALSE 1694
// y := false ;
1686: LD_ADDR_VAR 0 3
1690: PUSH
1691: LD_INT 0
1693: ST_TO_ADDR
1694: GO 1672
1696: POP
1697: POP
// until y ;
1698: LD_VAR 0 3
1702: IFFALSE 1647
// end ;
1704: GO 1581
1706: POP
1707: POP
// until ( not us_patrol_1 ) or ( blast_countdown ) ;
1708: LD_EXP 25
1712: NOT
1713: PUSH
1714: LD_EXP 27
1718: OR
1719: IFFALSE 1562
// if us_patrol_1 then
1721: LD_EXP 25
1725: IFFALSE 1765
// begin ComAgressiveMove ( us_patrol_1 , 56 , 77 ) ;
1727: LD_EXP 25
1731: PPUSH
1732: LD_INT 56
1734: PPUSH
1735: LD_INT 77
1737: PPUSH
1738: CALL_OW 114
// us_sol := us_sol ^ us_patrol_1 ;
1742: LD_ADDR_EXP 21
1746: PUSH
1747: LD_EXP 21
1751: PUSH
1752: LD_EXP 25
1756: ADD
1757: ST_TO_ADDR
// us_patrol_1 := [ ] ;
1758: LD_ADDR_EXP 25
1762: PUSH
1763: EMPTY
1764: ST_TO_ADDR
// end ; end ;
1765: PPOPN 4
1767: END
// every 0 0$1 marked 3 do var i , x , y , cesta ;
1768: GO 1770
1770: DISABLE
1771: LD_INT 0
1773: PPUSH
1774: PPUSH
1775: PPUSH
1776: PPUSH
// begin cesta := [ 135 , 7 , 158 , 21 , 168 , 40 , 168 , 65 , 167 , 90 , 146 , 83 , 146 , 83 , 167 , 90 , 168 , 65 , 168 , 40 , 158 , 21 , 135 , 7 ] ;
1777: LD_ADDR_VAR 0 4
1781: PUSH
1782: LD_INT 135
1784: PUSH
1785: LD_INT 7
1787: PUSH
1788: LD_INT 158
1790: PUSH
1791: LD_INT 21
1793: PUSH
1794: LD_INT 168
1796: PUSH
1797: LD_INT 40
1799: PUSH
1800: LD_INT 168
1802: PUSH
1803: LD_INT 65
1805: PUSH
1806: LD_INT 167
1808: PUSH
1809: LD_INT 90
1811: PUSH
1812: LD_INT 146
1814: PUSH
1815: LD_INT 83
1817: PUSH
1818: LD_INT 146
1820: PUSH
1821: LD_INT 83
1823: PUSH
1824: LD_INT 167
1826: PUSH
1827: LD_INT 90
1829: PUSH
1830: LD_INT 168
1832: PUSH
1833: LD_INT 65
1835: PUSH
1836: LD_INT 168
1838: PUSH
1839: LD_INT 40
1841: PUSH
1842: LD_INT 158
1844: PUSH
1845: LD_INT 21
1847: PUSH
1848: LD_INT 135
1850: PUSH
1851: LD_INT 7
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: ST_TO_ADDR
// repeat for i = 1 to ( cesta div 2 ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: DOUBLE
1886: LD_INT 1
1888: DEC
1889: ST_TO_ADDR
1890: LD_VAR 0 4
1894: PUSH
1895: LD_INT 2
1897: DIV
1898: PUSH
1899: FOR_TO
1900: IFFALSE 2024
// begin x := cesta [ ( i * 2 ) - 1 ] ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 4
1911: PUSH
1912: LD_VAR 0 1
1916: PUSH
1917: LD_INT 2
1919: MUL
1920: PUSH
1921: LD_INT 1
1923: MINUS
1924: ARRAY
1925: ST_TO_ADDR
// y := cesta [ ( i * 2 ) ] ;
1926: LD_ADDR_VAR 0 3
1930: PUSH
1931: LD_VAR 0 4
1935: PUSH
1936: LD_VAR 0 1
1940: PUSH
1941: LD_INT 2
1943: MUL
1944: ARRAY
1945: ST_TO_ADDR
// ComAgressiveMove ( us_patrol_2 , x , y ) ;
1946: LD_EXP 26
1950: PPUSH
1951: LD_VAR 0 2
1955: PPUSH
1956: LD_VAR 0 3
1960: PPUSH
1961: CALL_OW 114
// repeat wait ( 0 0$3 ) ;
1965: LD_INT 105
1967: PPUSH
1968: CALL_OW 67
// y := true ;
1972: LD_ADDR_VAR 0 3
1976: PUSH
1977: LD_INT 1
1979: ST_TO_ADDR
// for x in us_patrol_2 do
1980: LD_ADDR_VAR 0 2
1984: PUSH
1985: LD_EXP 26
1989: PUSH
1990: FOR_IN
1991: IFFALSE 2014
// if IsBusy ( x ) then
1993: LD_VAR 0 2
1997: PPUSH
1998: CALL_OW 315
2002: IFFALSE 2012
// y := false ;
2004: LD_ADDR_VAR 0 3
2008: PUSH
2009: LD_INT 0
2011: ST_TO_ADDR
2012: GO 1990
2014: POP
2015: POP
// until y ;
2016: LD_VAR 0 3
2020: IFFALSE 1965
// end ;
2022: GO 1899
2024: POP
2025: POP
// until ( not us_patrol_2 ) or ( blast_countdown ) ;
2026: LD_EXP 26
2030: NOT
2031: PUSH
2032: LD_EXP 27
2036: OR
2037: IFFALSE 1880
// if us_patrol_2 then
2039: LD_EXP 26
2043: IFFALSE 2083
// begin ComAgressiveMove ( us_patrol_2 , 56 , 77 ) ;
2045: LD_EXP 26
2049: PPUSH
2050: LD_INT 56
2052: PPUSH
2053: LD_INT 77
2055: PPUSH
2056: CALL_OW 114
// us_sol := us_sol ^ us_patrol_2 ;
2060: LD_ADDR_EXP 21
2064: PUSH
2065: LD_EXP 21
2069: PUSH
2070: LD_EXP 26
2074: ADD
2075: ST_TO_ADDR
// us_patrol_2 := [ ] ;
2076: LD_ADDR_EXP 26
2080: PUSH
2081: EMPTY
2082: ST_TO_ADDR
// end ; end ;
2083: PPOPN 4
2085: END
// function prepare_us_patrol ; var i , un , done , sol_lev ; begin
2086: LD_INT 0
2088: PPUSH
2089: PPUSH
2090: PPUSH
2091: PPUSH
2092: PPUSH
// done := 0 ;
2093: LD_ADDR_VAR 0 4
2097: PUSH
2098: LD_INT 0
2100: ST_TO_ADDR
// sol_lev := [ 4 , 5 , 8 ] [ difficulty ] ;
2101: LD_ADDR_VAR 0 5
2105: PUSH
2106: LD_INT 4
2108: PUSH
2109: LD_INT 5
2111: PUSH
2112: LD_INT 8
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: LIST
2119: PUSH
2120: LD_OWVAR 67
2124: ARRAY
2125: ST_TO_ADDR
// us_patrol_1 := [ ] ;
2126: LD_ADDR_EXP 25
2130: PUSH
2131: EMPTY
2132: ST_TO_ADDR
// us_patrol_2 := [ ] ;
2133: LD_ADDR_EXP 26
2137: PUSH
2138: EMPTY
2139: ST_TO_ADDR
// uc_nation := nation_american ;
2140: LD_ADDR_OWVAR 21
2144: PUSH
2145: LD_INT 1
2147: ST_TO_ADDR
// uc_side := americans ;
2148: LD_ADDR_OWVAR 20
2152: PUSH
2153: LD_EXP 18
2157: ST_TO_ADDR
// for i = 1 to ( difficulty + 1 ) do
2158: LD_ADDR_VAR 0 2
2162: PUSH
2163: DOUBLE
2164: LD_INT 1
2166: DEC
2167: ST_TO_ADDR
2168: LD_OWVAR 67
2172: PUSH
2173: LD_INT 1
2175: PLUS
2176: PUSH
2177: FOR_TO
2178: IFFALSE 2326
// begin done := done + 1 ;
2180: LD_ADDR_VAR 0 4
2184: PUSH
2185: LD_VAR 0 4
2189: PUSH
2190: LD_INT 1
2192: PLUS
2193: ST_TO_ADDR
// PrepareSoldier ( 0 , sol_lev + Rand ( 0 , 2 ) ) ;
2194: LD_INT 0
2196: PPUSH
2197: LD_VAR 0 5
2201: PUSH
2202: LD_INT 0
2204: PPUSH
2205: LD_INT 2
2207: PPUSH
2208: CALL_OW 12
2212: PLUS
2213: PPUSH
2214: CALL_OW 381
// un := CreateHuman ;
2218: LD_ADDR_VAR 0 3
2222: PUSH
2223: CALL_OW 44
2227: ST_TO_ADDR
// if ( difficulty = 3 ) and ( done > 2 ) then
2228: LD_OWVAR 67
2232: PUSH
2233: LD_INT 3
2235: EQUAL
2236: PUSH
2237: LD_VAR 0 4
2241: PUSH
2242: LD_INT 2
2244: GREATER
2245: AND
2246: IFFALSE 2287
// begin us_patrol_2 := us_patrol_2 ^ un ;
2248: LD_ADDR_EXP 26
2252: PUSH
2253: LD_EXP 26
2257: PUSH
2258: LD_VAR 0 3
2262: ADD
2263: ST_TO_ADDR
// PlaceUnitXYR ( un , 158 , 21 , 2 , false ) ;
2264: LD_VAR 0 3
2268: PPUSH
2269: LD_INT 158
2271: PPUSH
2272: LD_INT 21
2274: PPUSH
2275: LD_INT 2
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 50
// end else
2285: GO 2324
// begin us_patrol_1 := us_patrol_1 ^ un ;
2287: LD_ADDR_EXP 25
2291: PUSH
2292: LD_EXP 25
2296: PUSH
2297: LD_VAR 0 3
2301: ADD
2302: ST_TO_ADDR
// PlaceUnitXYR ( un , 101 , 39 , 2 , false ) ;
2303: LD_VAR 0 3
2307: PPUSH
2308: LD_INT 101
2310: PPUSH
2311: LD_INT 39
2313: PPUSH
2314: LD_INT 2
2316: PPUSH
2317: LD_INT 0
2319: PPUSH
2320: CALL_OW 50
// end ; end ;
2324: GO 2177
2326: POP
2327: POP
// enable ( 2 ) ;
2328: LD_INT 2
2330: ENABLE_MARKED
// if difficulty = 3 then
2331: LD_OWVAR 67
2335: PUSH
2336: LD_INT 3
2338: EQUAL
2339: IFFALSE 2344
// enable ( 3 ) ;
2341: LD_INT 3
2343: ENABLE_MARKED
// end ;
2344: LD_VAR 0 1
2348: RET
// function prepare_us_base ; var i , un , b_list ; begin
2349: LD_INT 0
2351: PPUSH
2352: PPUSH
2353: PPUSH
2354: PPUSH
// us_sol := [ ] ;
2355: LD_ADDR_EXP 21
2359: PUSH
2360: EMPTY
2361: ST_TO_ADDR
// us_sci := [ ] ;
2362: LD_ADDR_EXP 22
2366: PUSH
2367: EMPTY
2368: ST_TO_ADDR
// uc_nation := nation_american ;
2369: LD_ADDR_OWVAR 21
2373: PUSH
2374: LD_INT 1
2376: ST_TO_ADDR
// uc_side := americans ;
2377: LD_ADDR_OWVAR 20
2381: PUSH
2382: LD_EXP 18
2386: ST_TO_ADDR
// for i = 1 to ( difficulty + 3 ) do
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: DOUBLE
2393: LD_INT 1
2395: DEC
2396: ST_TO_ADDR
2397: LD_OWVAR 67
2401: PUSH
2402: LD_INT 3
2404: PLUS
2405: PUSH
2406: FOR_TO
2407: IFFALSE 2485
// begin PrepareSoldier ( 0 , [ 3 , 6 , 9 ] [ difficulty ] ) ;
2409: LD_INT 0
2411: PPUSH
2412: LD_INT 3
2414: PUSH
2415: LD_INT 6
2417: PUSH
2418: LD_INT 9
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_OWVAR 67
2430: ARRAY
2431: PPUSH
2432: CALL_OW 381
// un := CreateHuman ;
2436: LD_ADDR_VAR 0 3
2440: PUSH
2441: CALL_OW 44
2445: ST_TO_ADDR
// us_sol := us_sol ^ un ;
2446: LD_ADDR_EXP 21
2450: PUSH
2451: LD_EXP 21
2455: PUSH
2456: LD_VAR 0 3
2460: ADD
2461: ST_TO_ADDR
// PlaceUnitXYR ( un , 55 , 75 , 4 , false ) ;
2462: LD_VAR 0 3
2466: PPUSH
2467: LD_INT 55
2469: PPUSH
2470: LD_INT 75
2472: PPUSH
2473: LD_INT 4
2475: PPUSH
2476: LD_INT 0
2478: PPUSH
2479: CALL_OW 50
// end ;
2483: GO 2406
2485: POP
2486: POP
// for i := 1 to 4 do
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: DOUBLE
2493: LD_INT 1
2495: DEC
2496: ST_TO_ADDR
2497: LD_INT 4
2499: PUSH
2500: FOR_TO
2501: IFFALSE 2568
// begin PrepareScientist ( sex_male , 6 + Rand ( 0 , 3 ) ) ;
2503: LD_INT 1
2505: PPUSH
2506: LD_INT 6
2508: PUSH
2509: LD_INT 0
2511: PPUSH
2512: LD_INT 3
2514: PPUSH
2515: CALL_OW 12
2519: PLUS
2520: PPUSH
2521: CALL_OW 384
// un := CreateHuman ;
2525: LD_ADDR_VAR 0 3
2529: PUSH
2530: CALL_OW 44
2534: ST_TO_ADDR
// us_sci := us_sci ^ un ;
2535: LD_ADDR_EXP 22
2539: PUSH
2540: LD_EXP 22
2544: PUSH
2545: LD_VAR 0 3
2549: ADD
2550: ST_TO_ADDR
// PlaceUnitArea ( un , us_base , false ) ;
2551: LD_VAR 0 3
2555: PPUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 0
2561: PPUSH
2562: CALL_OW 49
// end ;
2566: GO 2500
2568: POP
2569: POP
// PrepareMechanic ( 0 , [ 4 , 6 , 9 ] [ difficulty ] ) ;
2570: LD_INT 0
2572: PPUSH
2573: LD_INT 4
2575: PUSH
2576: LD_INT 6
2578: PUSH
2579: LD_INT 9
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: PUSH
2587: LD_OWVAR 67
2591: ARRAY
2592: PPUSH
2593: CALL_OW 383
// us_mech := CreateHuman ;
2597: LD_ADDR_EXP 23
2601: PUSH
2602: CALL_OW 44
2606: ST_TO_ADDR
// PlaceUnitArea ( us_mech , am_repair , false ) ;
2607: LD_EXP 23
2611: PPUSH
2612: LD_INT 10
2614: PPUSH
2615: LD_INT 0
2617: PPUSH
2618: CALL_OW 49
// ComEnterUnit ( us_mech , crane ) ;
2622: LD_EXP 23
2626: PPUSH
2627: LD_INT 15
2629: PPUSH
2630: CALL_OW 120
// if Stevens then
2634: LD_EXP 6
2638: IFFALSE 2671
// begin PlaceUnitArea ( Stevens , us_base , false ) ;
2640: LD_EXP 6
2644: PPUSH
2645: LD_INT 1
2647: PPUSH
2648: LD_INT 0
2650: PPUSH
2651: CALL_OW 49
// us_sci := us_sci ^ Stevens ;
2655: LD_ADDR_EXP 22
2659: PUSH
2660: LD_EXP 22
2664: PUSH
2665: LD_EXP 6
2669: ADD
2670: ST_TO_ADDR
// end ; ComEnterUnit ( us_sci , us_lab ) ;
2671: LD_EXP 22
2675: PPUSH
2676: LD_INT 1
2678: PPUSH
2679: CALL_OW 120
// b_list := FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_bunker ] ] ) ;
2683: LD_ADDR_VAR 0 4
2687: PUSH
2688: LD_INT 22
2690: PUSH
2691: LD_EXP 18
2695: PUSH
2696: EMPTY
2697: LIST
2698: LIST
2699: PUSH
2700: LD_INT 30
2702: PUSH
2703: LD_INT 32
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: PPUSH
2714: CALL_OW 69
2718: ST_TO_ADDR
// for i = 1 to b_list do
2719: LD_ADDR_VAR 0 2
2723: PUSH
2724: DOUBLE
2725: LD_INT 1
2727: DEC
2728: ST_TO_ADDR
2729: LD_VAR 0 4
2733: PUSH
2734: FOR_TO
2735: IFFALSE 2765
// ComEnterUnit ( us_sol [ i ] , b_list [ i ] ) ;
2737: LD_EXP 21
2741: PUSH
2742: LD_VAR 0 2
2746: ARRAY
2747: PPUSH
2748: LD_VAR 0 4
2752: PUSH
2753: LD_VAR 0 2
2757: ARRAY
2758: PPUSH
2759: CALL_OW 120
2763: GO 2734
2765: POP
2766: POP
// us_all_units := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
2767: LD_ADDR_EXP 24
2771: PUSH
2772: LD_INT 22
2774: PUSH
2775: LD_EXP 18
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: LD_INT 21
2786: PUSH
2787: LD_INT 1
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: PPUSH
2798: CALL_OW 69
2802: ST_TO_ADDR
// end ;
2803: LD_VAR 0 1
2807: RET
// export function prepare_us_side ; begin
2808: LD_INT 0
2810: PPUSH
// prepare_us_base ;
2811: CALL 2349 0 0
// prepare_us_patrol ;
2815: CALL 2086 0 0
// end ;
2819: LD_VAR 0 1
2823: RET
// function American_Hunt ( un ) ; var i , b_list ; begin
2824: LD_INT 0
2826: PPUSH
2827: PPUSH
2828: PPUSH
// ComExitBuilding ( us_sol ) ;
2829: LD_EXP 21
2833: PPUSH
2834: CALL_OW 122
// Wait ( 0 0$0.5 ) ;
2838: LD_INT 18
2840: PPUSH
2841: CALL_OW 67
// repeat ComAgressiveMove ( us_sol , GetX ( un ) , GetY ( un ) ) ;
2845: LD_EXP 21
2849: PPUSH
2850: LD_VAR 0 1
2854: PPUSH
2855: CALL_OW 250
2859: PPUSH
2860: LD_VAR 0 1
2864: PPUSH
2865: CALL_OW 251
2869: PPUSH
2870: CALL_OW 114
// wait ( 0 0$1 ) ;
2874: LD_INT 35
2876: PPUSH
2877: CALL_OW 67
// until not ( See ( americans , un ) and ( GetAttitude ( americans , you ) <> att_neutral ) ) ;
2881: LD_EXP 18
2885: PPUSH
2886: LD_VAR 0 1
2890: PPUSH
2891: CALL_OW 292
2895: PUSH
2896: LD_EXP 18
2900: PPUSH
2901: LD_EXP 17
2905: PPUSH
2906: CALL_OW 81
2910: PUSH
2911: LD_INT 0
2913: NONEQUAL
2914: AND
2915: NOT
2916: IFFALSE 2845
// b_list := FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_bunker ] ] ) ;
2918: LD_ADDR_VAR 0 4
2922: PUSH
2923: LD_INT 22
2925: PUSH
2926: LD_EXP 18
2930: PUSH
2931: EMPTY
2932: LIST
2933: LIST
2934: PUSH
2935: LD_INT 30
2937: PUSH
2938: LD_INT 32
2940: PUSH
2941: EMPTY
2942: LIST
2943: LIST
2944: PUSH
2945: EMPTY
2946: LIST
2947: LIST
2948: PPUSH
2949: CALL_OW 69
2953: ST_TO_ADDR
// for i = 1 to us_sol do
2954: LD_ADDR_VAR 0 3
2958: PUSH
2959: DOUBLE
2960: LD_INT 1
2962: DEC
2963: ST_TO_ADDR
2964: LD_EXP 21
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3036
// if i <= ( 0 + b_list ) then
2972: LD_VAR 0 3
2976: PUSH
2977: LD_INT 0
2979: PUSH
2980: LD_VAR 0 4
2984: PLUS
2985: LESSEQUAL
2986: IFFALSE 3016
// ComEnterUnit ( us_sol [ i ] , b_list [ i ] ) else
2988: LD_EXP 21
2992: PUSH
2993: LD_VAR 0 3
2997: ARRAY
2998: PPUSH
2999: LD_VAR 0 4
3003: PUSH
3004: LD_VAR 0 3
3008: ARRAY
3009: PPUSH
3010: CALL_OW 120
3014: GO 3034
// ComMoveToArea ( us_sol [ i ] , parking ) ;
3016: LD_EXP 21
3020: PUSH
3021: LD_VAR 0 3
3025: ARRAY
3026: PPUSH
3027: LD_INT 9
3029: PPUSH
3030: CALL_OW 113
3034: GO 2969
3036: POP
3037: POP
// wait ( 0 0$5 ) ;
3038: LD_INT 175
3040: PPUSH
3041: CALL_OW 67
// end ;
3045: LD_VAR 0 2
3049: RET
// every 0 0$1 trigger FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) marked 1 do var list ;
3050: LD_INT 3
3052: PPUSH
3053: LD_INT 22
3055: PUSH
3056: LD_EXP 17
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: PUSH
3065: EMPTY
3066: LIST
3067: PPUSH
3068: CALL_OW 70
3072: IFFALSE 3167
3074: GO 3076
3076: DISABLE
3077: LD_INT 0
3079: PPUSH
// begin list := FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) ;
3080: LD_ADDR_VAR 0 1
3084: PUSH
3085: LD_INT 3
3087: PPUSH
3088: LD_INT 22
3090: PUSH
3091: LD_EXP 17
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: PUSH
3100: EMPTY
3101: LIST
3102: PPUSH
3103: CALL_OW 70
3107: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3108: LD_INT 35
3110: PPUSH
3111: CALL_OW 67
// until not FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) ;
3115: LD_INT 3
3117: PPUSH
3118: LD_INT 22
3120: PUSH
3121: LD_EXP 17
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PUSH
3130: EMPTY
3131: LIST
3132: PPUSH
3133: CALL_OW 70
3137: NOT
3138: IFFALSE 3108
// if list then
3140: LD_VAR 0 1
3144: IFFALSE 3159
// American_Hunt ( list [ 1 ] ) ;
3146: LD_VAR 0 1
3150: PUSH
3151: LD_INT 1
3153: ARRAY
3154: PPUSH
3155: CALL 2824 0 1
// if not query_started then
3159: LD_EXP 29
3163: NOT
3164: IFFALSE 3167
// enable ;
3166: ENABLE
// end ;
3167: PPOPN 1
3169: END
// every 0 0$1 trigger IsInArea ( truck1 , half_line ) or IsInArea ( truck2 , half_line ) do
3170: LD_EXP 7
3174: PPUSH
3175: LD_INT 5
3177: PPUSH
3178: CALL_OW 308
3182: PUSH
3183: LD_EXP 8
3187: PPUSH
3188: LD_INT 5
3190: PPUSH
3191: CALL_OW 308
3195: OR
3196: IFFALSE 3204
3198: GO 3200
3200: DISABLE
// begin enable ( 1 ) ;
3201: LD_INT 1
3203: ENABLE_MARKED
// end ;
3204: END
// every 0 0$5 marked 7 do var difficulty_time ;
3205: GO 3207
3207: DISABLE
3208: LD_INT 0
3210: PPUSH
// begin difficulty_time := [ 25 25$0 , 15 15$0 , 10 10$0 ] [ difficulty ] ;
3211: LD_ADDR_VAR 0 1
3215: PUSH
3216: LD_INT 52500
3218: PUSH
3219: LD_INT 31500
3221: PUSH
3222: LD_INT 21000
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: PUSH
3230: LD_OWVAR 67
3234: ARRAY
3235: ST_TO_ADDR
// Wait ( difficulty_time ) ;
3236: LD_VAR 0 1
3240: PPUSH
3241: CALL_OW 67
// americans_leaving ;
3245: CALL 3260 0 0
// end ;
3249: PPOPN 1
3251: END
// every 0 0$1 marked 10 do
3252: GO 3254
3254: DISABLE
// begin americans_leaving ;
3255: CALL 3260 0 0
// end ;
3259: END
// function americans_leaving ; var un , list , i , max , vehicles ; begin
3260: LD_INT 0
3262: PPUSH
3263: PPUSH
3264: PPUSH
3265: PPUSH
3266: PPUSH
3267: PPUSH
// keep_base_finished := true ;
3268: LD_ADDR_EXP 16
3272: PUSH
3273: LD_INT 1
3275: ST_TO_ADDR
// ComExitBuilding ( us_sol ) ;
3276: LD_EXP 21
3280: PPUSH
3281: CALL_OW 122
// ComExitBuilding ( us_sci ) ;
3285: LD_EXP 22
3289: PPUSH
3290: CALL_OW 122
// wait ( 0 0$1 ) ;
3294: LD_INT 35
3296: PPUSH
3297: CALL_OW 67
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
3301: LD_ADDR_VAR 0 3
3305: PUSH
3306: LD_INT 22
3308: PUSH
3309: LD_EXP 18
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: PUSH
3318: LD_INT 21
3320: PUSH
3321: LD_INT 1
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: PUSH
3328: EMPTY
3329: LIST
3330: LIST
3331: PPUSH
3332: CALL_OW 69
3336: ST_TO_ADDR
// ComMoveToArea ( list , leave_area ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 7
3344: PPUSH
3345: CALL_OW 113
// vehicles := FilterUnitsInArea ( us_base , [ [ f_side , americans ] , [ f_type , unit_vehicle ] , f_not , [ f_occupied ] ] ) ;
3349: LD_ADDR_VAR 0 6
3353: PUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 22
3359: PUSH
3360: LD_EXP 18
3364: PUSH
3365: EMPTY
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 21
3371: PUSH
3372: LD_INT 2
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 3
3381: PUSH
3382: LD_INT 59
3384: PUSH
3385: EMPTY
3386: LIST
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: PPUSH
3394: CALL_OW 70
3398: ST_TO_ADDR
// if ( 0 + vehicles ) < list then
3399: LD_INT 0
3401: PUSH
3402: LD_VAR 0 6
3406: PLUS
3407: PUSH
3408: LD_VAR 0 3
3412: LESS
3413: IFFALSE 3431
// max := 0 + vehicles else
3415: LD_ADDR_VAR 0 5
3419: PUSH
3420: LD_INT 0
3422: PUSH
3423: LD_VAR 0 6
3427: PLUS
3428: ST_TO_ADDR
3429: GO 3445
// max := 0 + list ;
3431: LD_ADDR_VAR 0 5
3435: PUSH
3436: LD_INT 0
3438: PUSH
3439: LD_VAR 0 3
3443: PLUS
3444: ST_TO_ADDR
// if vehicles and list then
3445: LD_VAR 0 6
3449: PUSH
3450: LD_VAR 0 3
3454: AND
3455: IFFALSE 3523
// for i = 1 to max do
3457: LD_ADDR_VAR 0 4
3461: PUSH
3462: DOUBLE
3463: LD_INT 1
3465: DEC
3466: ST_TO_ADDR
3467: LD_VAR 0 5
3471: PUSH
3472: FOR_TO
3473: IFFALSE 3521
// begin ComEnterUnit ( list [ i ] , vehicles [ i ] ) ;
3475: LD_VAR 0 3
3479: PUSH
3480: LD_VAR 0 4
3484: ARRAY
3485: PPUSH
3486: LD_VAR 0 6
3490: PUSH
3491: LD_VAR 0 4
3495: ARRAY
3496: PPUSH
3497: CALL_OW 120
// AddComMoveToArea ( list [ i ] , leave_area ) ;
3501: LD_VAR 0 3
3505: PUSH
3506: LD_VAR 0 4
3510: ARRAY
3511: PPUSH
3512: LD_INT 7
3514: PPUSH
3515: CALL_OW 173
// end ;
3519: GO 3472
3521: POP
3522: POP
// time_out := true ;
3523: LD_ADDR_EXP 11
3527: PUSH
3528: LD_INT 1
3530: ST_TO_ADDR
// enable ( 9 ) ;
3531: LD_INT 9
3533: ENABLE_MARKED
// repeat wait ( 0 0$0.5 ) ;
3534: LD_INT 18
3536: PPUSH
3537: CALL_OW 67
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] , [ f_placed ] , [ f_ok ] ] ) ;
3541: LD_ADDR_VAR 0 3
3545: PUSH
3546: LD_INT 22
3548: PUSH
3549: LD_EXP 18
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: PUSH
3558: LD_INT 21
3560: PUSH
3561: LD_INT 1
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: PUSH
3568: LD_INT 52
3570: PUSH
3571: EMPTY
3572: LIST
3573: PUSH
3574: LD_INT 50
3576: PUSH
3577: EMPTY
3578: LIST
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: PPUSH
3586: CALL_OW 69
3590: ST_TO_ADDR
// for un in list do
3591: LD_ADDR_VAR 0 2
3595: PUSH
3596: LD_VAR 0 3
3600: PUSH
3601: FOR_IN
3602: IFFALSE 3630
// if not HasTask ( un ) then
3604: LD_VAR 0 2
3608: PPUSH
3609: CALL_OW 314
3613: NOT
3614: IFFALSE 3628
// ComMoveToArea ( un , leave_area ) ;
3616: LD_VAR 0 2
3620: PPUSH
3621: LD_INT 7
3623: PPUSH
3624: CALL_OW 113
3628: GO 3601
3630: POP
3631: POP
// until not list ;
3632: LD_VAR 0 3
3636: NOT
3637: IFFALSE 3534
// if not query_started then
3639: LD_EXP 29
3643: NOT
3644: IFFALSE 3653
// Mission_Failed ( 3 ) ;
3646: LD_INT 3
3648: PPUSH
3649: CALL 1213 0 1
// end ;
3653: LD_VAR 0 1
3657: RET
// every 0 0$1 trigger FilterUnitsInArea ( leave_area , [ [ f_side , americans ] ] ) marked 9 do var list , un , max ;
3658: LD_INT 7
3660: PPUSH
3661: LD_INT 22
3663: PUSH
3664: LD_EXP 18
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: PUSH
3673: EMPTY
3674: LIST
3675: PPUSH
3676: CALL_OW 70
3680: IFFALSE 3803
3682: GO 3684
3684: DISABLE
3685: LD_INT 0
3687: PPUSH
3688: PPUSH
3689: PPUSH
// begin list := FilterUnitsInArea ( leave_area , [ [ f_side , americans ] ] ) ;
3690: LD_ADDR_VAR 0 1
3694: PUSH
3695: LD_INT 7
3697: PPUSH
3698: LD_INT 22
3700: PUSH
3701: LD_EXP 18
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PUSH
3710: EMPTY
3711: LIST
3712: PPUSH
3713: CALL_OW 70
3717: ST_TO_ADDR
// for un in list do
3718: LD_ADDR_VAR 0 2
3722: PUSH
3723: LD_VAR 0 1
3727: PUSH
3728: FOR_IN
3729: IFFALSE 3800
// begin if un in us_sci then
3731: LD_VAR 0 2
3735: PUSH
3736: LD_EXP 22
3740: IN
3741: IFFALSE 3759
// us_sci := us_sci diff un ;
3743: LD_ADDR_EXP 22
3747: PUSH
3748: LD_EXP 22
3752: PUSH
3753: LD_VAR 0 2
3757: DIFF
3758: ST_TO_ADDR
// max := IsInUnit ( un ) ;
3759: LD_ADDR_VAR 0 3
3763: PUSH
3764: LD_VAR 0 2
3768: PPUSH
3769: CALL_OW 310
3773: ST_TO_ADDR
// RemoveUnit ( un ) ;
3774: LD_VAR 0 2
3778: PPUSH
3779: CALL_OW 64
// if max then
3783: LD_VAR 0 3
3787: IFFALSE 3798
// RemoveUnit ( max ) ;
3789: LD_VAR 0 3
3793: PPUSH
3794: CALL_OW 64
// end ;
3798: GO 3728
3800: POP
3801: POP
// enable ;
3802: ENABLE
// end ; end_of_file
3803: PPOPN 3
3805: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = americans then
3806: LD_VAR 0 1
3810: PPUSH
3811: CALL_OW 255
3815: PUSH
3816: LD_EXP 18
3820: EQUAL
3821: IFFALSE 3914
// begin us_patrol_1 := us_patrol_1 diff un ;
3823: LD_ADDR_EXP 25
3827: PUSH
3828: LD_EXP 25
3832: PUSH
3833: LD_VAR 0 1
3837: DIFF
3838: ST_TO_ADDR
// us_patrol_2 := us_patrol_2 diff un ;
3839: LD_ADDR_EXP 26
3843: PUSH
3844: LD_EXP 26
3848: PUSH
3849: LD_VAR 0 1
3853: DIFF
3854: ST_TO_ADDR
// us_sci := us_sci diff un ;
3855: LD_ADDR_EXP 22
3859: PUSH
3860: LD_EXP 22
3864: PUSH
3865: LD_VAR 0 1
3869: DIFF
3870: ST_TO_ADDR
// us_sol := us_sol diff un ;
3871: LD_ADDR_EXP 21
3875: PUSH
3876: LD_EXP 21
3880: PUSH
3881: LD_VAR 0 1
3885: DIFF
3886: ST_TO_ADDR
// if ( not us_sci ) and lab_destroyed and ( not technology_taken ) then
3887: LD_EXP 22
3891: NOT
3892: PUSH
3893: LD_EXP 10
3897: AND
3898: PUSH
3899: LD_EXP 15
3903: NOT
3904: AND
3905: IFFALSE 3914
// Mission_Failed ( 5 ) ;
3907: LD_INT 5
3909: PPUSH
3910: CALL 1213 0 1
// end ; if un = Burlak then
3914: LD_VAR 0 1
3918: PUSH
3919: LD_EXP 2
3923: EQUAL
3924: IFFALSE 3933
// Mission_Failed ( 1 ) ;
3926: LD_INT 1
3928: PPUSH
3929: CALL 1213 0 1
// if un = MacMillan then
3933: LD_VAR 0 1
3937: PUSH
3938: LD_EXP 1
3942: EQUAL
3943: IFFALSE 3952
// Mission_Failed ( 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: CALL 1213 0 1
// if ( un = us_lab ) then
3952: LD_VAR 0 1
3956: PUSH
3957: LD_INT 1
3959: EQUAL
3960: IFFALSE 4001
// begin lab_destroyed := true ;
3962: LD_ADDR_EXP 10
3966: PUSH
3967: LD_INT 1
3969: ST_TO_ADDR
// if not ( us_sci or technology_taken ) then
3970: LD_EXP 22
3974: PUSH
3975: LD_EXP 15
3979: OR
3980: NOT
3981: IFFALSE 3990
// Mission_Failed ( 5 ) ;
3983: LD_INT 5
3985: PPUSH
3986: CALL 1213 0 1
// if not query_started then
3990: LD_EXP 29
3994: NOT
3995: IFFALSE 4001
// query_kill ;
3997: CALL 5913 0 0
// end ; if ( GetSide ( un ) = you ) and ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) then
4001: LD_VAR 0 1
4005: PPUSH
4006: CALL_OW 255
4010: PUSH
4011: LD_EXP 17
4015: EQUAL
4016: PUSH
4017: LD_VAR 0 1
4021: PPUSH
4022: CALL_OW 247
4026: PUSH
4027: LD_INT 2
4029: EQUAL
4030: AND
4031: PUSH
4032: LD_VAR 0 1
4036: PPUSH
4037: CALL_OW 264
4041: PUSH
4042: LD_INT 12
4044: PUSH
4045: LD_INT 51
4047: PUSH
4048: EMPTY
4049: LIST
4050: LIST
4051: IN
4052: AND
4053: IFFALSE 4062
// Mission_Failed ( 6 ) ;
4055: LD_INT 6
4057: PPUSH
4058: CALL 1213 0 1
// end ;
4062: PPOPN 1
4064: END
// on UnitGoesToRed ( un ) do begin if un in [ Burlak , MacMillan ] and not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_btype , b_lab ] ] ) then
4065: LD_VAR 0 1
4069: PUSH
4070: LD_EXP 2
4074: PUSH
4075: LD_EXP 1
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: IN
4084: PUSH
4085: LD_INT 22
4087: PUSH
4088: LD_EXP 17
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: PUSH
4097: LD_INT 21
4099: PUSH
4100: LD_INT 3
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: PUSH
4107: LD_INT 30
4109: PUSH
4110: LD_INT 6
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: LIST
4121: PPUSH
4122: CALL_OW 69
4126: NOT
4127: AND
4128: IFFALSE 4168
// begin if un = Burlak then
4130: LD_VAR 0 1
4134: PUSH
4135: LD_EXP 2
4139: EQUAL
4140: IFFALSE 4149
// Mission_Failed ( 1 ) ;
4142: LD_INT 1
4144: PPUSH
4145: CALL 1213 0 1
// if un = MacMillan then
4149: LD_VAR 0 1
4153: PUSH
4154: LD_EXP 1
4158: EQUAL
4159: IFFALSE 4168
// Mission_Failed ( 2 ) ;
4161: LD_INT 2
4163: PPUSH
4164: CALL 1213 0 1
// end ; if ( un = us_lab ) and ( not query_started ) then
4168: LD_VAR 0 1
4172: PUSH
4173: LD_INT 1
4175: EQUAL
4176: PUSH
4177: LD_EXP 29
4181: NOT
4182: AND
4183: IFFALSE 4189
// query_kill ;
4185: CALL 5913 0 0
// end ;
4189: PPOPN 1
4191: END
// on BuildingCaptured ( building , orig_side , engeneer ) do begin if ( building = us_depot ) and ( not query_started ) and ( not time_out ) then
4192: LD_VAR 0 1
4196: PUSH
4197: LD_INT 5
4199: EQUAL
4200: PUSH
4201: LD_EXP 29
4205: NOT
4206: AND
4207: PUSH
4208: LD_EXP 11
4212: NOT
4213: AND
4214: IFFALSE 4220
// query_kill ;
4216: CALL 5913 0 0
// if ( building = us_lab ) then
4220: LD_VAR 0 1
4224: PUSH
4225: LD_INT 1
4227: EQUAL
4228: IFFALSE 4242
// begin technology_taken := true ;
4230: LD_ADDR_EXP 15
4234: PUSH
4235: LD_INT 1
4237: ST_TO_ADDR
// konecny_rozhovor ;
4238: CALL 6892 0 0
// end ; end ;
4242: PPOPN 3
4244: END
// on ArtifactLoaded ( un , size ) do begin if not art_picked then
4245: LD_EXP 31
4249: NOT
4250: IFFALSE 4264
// begin art_picked := true ;
4252: LD_ADDR_EXP 31
4256: PUSH
4257: LD_INT 1
4259: ST_TO_ADDR
// Artefact_Picked ;
4260: CALL 4997 0 0
// end ; art_cargo := un ;
4264: LD_ADDR_EXP 32
4268: PUSH
4269: LD_VAR 0 1
4273: ST_TO_ADDR
// end ;
4274: PPOPN 2
4276: END
// on ArtifactUnloaded ( un , size ) do begin art_cargo := false ;
4277: LD_ADDR_EXP 32
4281: PUSH
4282: LD_INT 0
4284: ST_TO_ADDR
// end ; end_of_file
4285: PPOPN 2
4287: END
// every 0 0$2 do var un , animal_out ;
4288: GO 4290
4290: DISABLE
4291: LD_INT 0
4293: PPUSH
4294: PPUSH
// begin animal_out := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
4295: LD_ADDR_VAR 0 2
4299: PUSH
4300: LD_INT 23
4302: PUSH
4303: LD_INT 0
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PUSH
4310: EMPTY
4311: LIST
4312: PPUSH
4313: CALL_OW 69
4317: ST_TO_ADDR
// ComMoveToArea ( animal_out , nature ) ;
4318: LD_VAR 0 2
4322: PPUSH
4323: LD_INT 2
4325: PPUSH
4326: CALL_OW 113
// enable ;
4330: ENABLE
// end ; end_of_file
4331: PPOPN 2
4333: END
// export blast_done , query_started , contamine , art_picked , art_cargo ; var dokecano ; export function starting_scene ; begin
4334: LD_INT 0
4336: PPUSH
// RevealFogArea ( you , artefact_fog ) ;
4337: LD_EXP 17
4341: PPUSH
4342: LD_INT 4
4344: PPUSH
4345: CALL_OW 332
// CenterNowOnUnits ( [ truck1 , truck2 ] ) ;
4349: LD_EXP 7
4353: PUSH
4354: LD_EXP 8
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PPUSH
4363: CALL_OW 87
// IngameOn ;
4367: CALL_OW 8
// ComMoveXY ( MacMillan , 192 , 82 ) ;
4371: LD_EXP 1
4375: PPUSH
4376: LD_INT 192
4378: PPUSH
4379: LD_INT 82
4381: PPUSH
4382: CALL_OW 111
// ComMoveXY ( Burlak , 193 , 86 ) ;
4386: LD_EXP 2
4390: PPUSH
4391: LD_INT 193
4393: PPUSH
4394: LD_INT 86
4396: PPUSH
4397: CALL_OW 111
// AddComExitVehicle ( [ MacMillan , Burlak ] ) ;
4401: LD_EXP 1
4405: PUSH
4406: LD_EXP 2
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PPUSH
4415: CALL_OW 181
// wait ( 0 0$5 ) ;
4419: LD_INT 175
4421: PPUSH
4422: CALL_OW 67
// IngameOff ;
4426: CALL_OW 9
// DialogueOn ;
4430: CALL_OW 6
// interface_hidden := true ;
4434: LD_ADDR_OWVAR 54
4438: PUSH
4439: LD_INT 1
4441: ST_TO_ADDR
// Say ( Burlak , D2-Bur-1 ) ;
4442: LD_EXP 2
4446: PPUSH
4447: LD_STRING D2-Bur-1
4449: PPUSH
4450: CALL_OW 88
// Say ( MacMillan , D2-JMM-1 ) ;
4454: LD_EXP 1
4458: PPUSH
4459: LD_STRING D2-JMM-1
4461: PPUSH
4462: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
4466: LD_EXP 2
4470: PPUSH
4471: LD_STRING D2-Bur-2
4473: PPUSH
4474: CALL_OW 88
// SaveForQuickRestart ;
4478: CALL_OW 22
// wait ( 10 ) ;
4482: LD_INT 10
4484: PPUSH
4485: CALL_OW 67
// ChangeMissionObjectives ( MArtPickup ) ;
4489: LD_STRING MArtPickup
4491: PPUSH
4492: CALL_OW 337
// interface_hidden := false ;
4496: LD_ADDR_OWVAR 54
4500: PUSH
4501: LD_INT 0
4503: ST_TO_ADDR
// DialogueOff ;
4504: CALL_OW 7
// ComFree ( [ MacMillan , Burlak ] ) ;
4508: LD_EXP 1
4512: PUSH
4513: LD_EXP 2
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL_OW 139
// blast_done := false ;
4526: LD_ADDR_EXP 28
4530: PUSH
4531: LD_INT 0
4533: ST_TO_ADDR
// query_started := false ;
4534: LD_ADDR_EXP 29
4538: PUSH
4539: LD_INT 0
4541: ST_TO_ADDR
// dokecano := false ;
4542: LD_ADDR_LOC 1
4546: PUSH
4547: LD_INT 0
4549: ST_TO_ADDR
// art_picked := false ;
4550: LD_ADDR_EXP 31
4554: PUSH
4555: LD_INT 0
4557: ST_TO_ADDR
// art_cargo := false ;
4558: LD_ADDR_EXP 32
4562: PUSH
4563: LD_INT 0
4565: ST_TO_ADDR
// end ;
4566: LD_VAR 0 1
4570: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_see , you ] , [ f_side , americans ] , [ f_type , unit_human ] ] ) do
4571: LD_INT 101
4573: PUSH
4574: LD_EXP 17
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: LD_INT 22
4585: PUSH
4586: LD_EXP 18
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PUSH
4595: LD_INT 21
4597: PUSH
4598: LD_INT 1
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: LIST
4609: PPUSH
4610: CALL_OW 69
4614: IFFALSE 4718
4616: GO 4618
4618: DISABLE
// begin if blast_done then
4619: LD_EXP 28
4623: IFFALSE 4627
// exit ;
4625: GO 4718
// repeat wait ( 0 0$1 ) ;
4627: LD_INT 35
4629: PPUSH
4630: CALL_OW 67
// until not FilterAllUnits ( [ [ f_see , you ] , [ f_side , americans ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
4634: LD_INT 101
4636: PUSH
4637: LD_EXP 17
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 22
4648: PUSH
4649: LD_EXP 18
4653: PUSH
4654: EMPTY
4655: LIST
4656: LIST
4657: PUSH
4658: LD_INT 21
4660: PUSH
4661: LD_INT 1
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: PUSH
4668: LD_INT 50
4670: PUSH
4671: EMPTY
4672: LIST
4673: PUSH
4674: EMPTY
4675: LIST
4676: LIST
4677: LIST
4678: LIST
4679: PPUSH
4680: CALL_OW 69
4684: NOT
4685: IFFALSE 4627
// wait ( 0 0$2 ) ;
4687: LD_INT 70
4689: PPUSH
4690: CALL_OW 67
// Say ( Burlak , D3-Bur-1 ) ;
4694: LD_EXP 2
4698: PPUSH
4699: LD_STRING D3-Bur-1
4701: PPUSH
4702: CALL_OW 88
// Say ( MacMillan , D3-JMM-1 ) ;
4706: LD_EXP 1
4710: PPUSH
4711: LD_STRING D3-JMM-1
4713: PPUSH
4714: CALL_OW 88
// end ;
4718: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_see , you ] , [ f_type , unit_building ] ] ) do
4719: LD_INT 101
4721: PUSH
4722: LD_EXP 17
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: PUSH
4731: LD_INT 21
4733: PUSH
4734: LD_INT 3
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PPUSH
4745: CALL_OW 69
4749: IFFALSE 4996
4751: GO 4753
4753: DISABLE
// begin wait ( 0 0$2 ) ;
4754: LD_INT 70
4756: PPUSH
4757: CALL_OW 67
// DialogueOn ;
4761: CALL_OW 6
// interface_hidden := true ;
4765: LD_ADDR_OWVAR 54
4769: PUSH
4770: LD_INT 1
4772: ST_TO_ADDR
// Say ( MacMillan , D3a-JMM-1 ) ;
4773: LD_EXP 1
4777: PPUSH
4778: LD_STRING D3a-JMM-1
4780: PPUSH
4781: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
4785: LD_EXP 2
4789: PPUSH
4790: LD_STRING D3a-Bur-1
4792: PPUSH
4793: CALL_OW 88
// Say ( MacMillan , D3a-JMM-2 ) ;
4797: LD_EXP 1
4801: PPUSH
4802: LD_STRING D3a-JMM-2
4804: PPUSH
4805: CALL_OW 88
// if Joan then
4809: LD_EXP 3
4813: IFFALSE 4829
// SayRadio ( Joan , D3a-Joan-2 ) else
4815: LD_EXP 3
4819: PPUSH
4820: LD_STRING D3a-Joan-2
4822: PPUSH
4823: CALL_OW 94
4827: GO 4841
// SayRadio ( ru_sci , D3a-RSci1-2 ) ;
4829: LD_EXP 4
4833: PPUSH
4834: LD_STRING D3a-RSci1-2
4836: PPUSH
4837: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
4841: LD_EXP 6
4845: PPUSH
4846: LD_STRING D3a-Huck-2
4848: PPUSH
4849: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
4853: LD_EXP 5
4857: PPUSH
4858: LD_STRING D3a-Pow-2
4860: PPUSH
4861: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
4865: LD_EXP 6
4869: PPUSH
4870: LD_STRING D3a-Huck-3
4872: PPUSH
4873: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
4877: LD_EXP 5
4881: PPUSH
4882: LD_STRING D3a-Pow-3
4884: PPUSH
4885: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
4889: LD_EXP 6
4893: PPUSH
4894: LD_STRING D3a-Huck-4
4896: PPUSH
4897: CALL_OW 94
// Say ( MacMillan , D3a-JMM-4 ) ;
4901: LD_EXP 1
4905: PPUSH
4906: LD_STRING D3a-JMM-4
4908: PPUSH
4909: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
4913: LD_EXP 2
4917: PPUSH
4918: LD_STRING D3a-Bur-4
4920: PPUSH
4921: CALL_OW 88
// if Joan then
4925: LD_EXP 3
4929: IFFALSE 4945
// SayRadio ( Joan , D3a-Joan-4 ) else
4931: LD_EXP 3
4935: PPUSH
4936: LD_STRING D3a-Joan-4
4938: PPUSH
4939: CALL_OW 94
4943: GO 4957
// SayRadio ( ru_sci , D3a-RSci1-4 ) ;
4945: LD_EXP 4
4949: PPUSH
4950: LD_STRING D3a-RSci1-4
4952: PPUSH
4953: CALL_OW 94
// Say ( MacMillan , D3a-JMM-5 ) ;
4957: LD_EXP 1
4961: PPUSH
4962: LD_STRING D3a-JMM-5
4964: PPUSH
4965: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
4969: LD_EXP 2
4973: PPUSH
4974: LD_STRING D3a-Bur-5
4976: PPUSH
4977: CALL_OW 88
// interface_hidden := false ;
4981: LD_ADDR_OWVAR 54
4985: PUSH
4986: LD_INT 0
4988: ST_TO_ADDR
// DialogueOff ;
4989: CALL_OW 7
// enable ( 4 ) ;
4993: LD_INT 4
4995: ENABLE_MARKED
// end ;
4996: END
// export function Artefact_Picked ; begin
4997: LD_INT 0
4999: PPUSH
// wait ( 5 ) ;
5000: LD_INT 5
5002: PPUSH
5003: CALL_OW 67
// DialogueOn ;
5007: CALL_OW 6
// interface_hidden := true ;
5011: LD_ADDR_OWVAR 54
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// Say ( MacMillan , D4-JMM-1 ) ;
5019: LD_EXP 1
5023: PPUSH
5024: LD_STRING D4-JMM-1
5026: PPUSH
5027: CALL_OW 88
// Say ( Burlak , D4-Bur-1 ) ;
5031: LD_EXP 2
5035: PPUSH
5036: LD_STRING D4-Bur-1
5038: PPUSH
5039: CALL_OW 88
// ChangeMissionObjectives ( MReturn ) ;
5043: LD_STRING MReturn
5045: PPUSH
5046: CALL_OW 337
// interface_hidden := false ;
5050: LD_ADDR_OWVAR 54
5054: PUSH
5055: LD_INT 0
5057: ST_TO_ADDR
// DialogueOff ;
5058: CALL_OW 7
// end ;
5062: LD_VAR 0 1
5066: RET
// every 0 0$1 marked 4 do var blast_time ;
5067: GO 5069
5069: DISABLE
5070: LD_INT 0
5072: PPUSH
// begin blast_countdown := true ;
5073: LD_ADDR_EXP 27
5077: PUSH
5078: LD_INT 1
5080: ST_TO_ADDR
// blast_time := TICK + ( [ 6 6$0 , 3 3$0 , 1 1$0 ] [ difficulty ] ) ;
5081: LD_ADDR_VAR 0 1
5085: PUSH
5086: LD_OWVAR 1
5090: PUSH
5091: LD_INT 12600
5093: PUSH
5094: LD_INT 6300
5096: PUSH
5097: LD_INT 2100
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_OWVAR 67
5109: ARRAY
5110: PLUS
5111: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
5112: LD_INT 105
5114: PPUSH
5115: CALL_OW 67
// until ( TICK > blast_time ) or IsInArea ( truck1 , half_line ) or IsInArea ( truck2 , half_line ) or IsInArea ( truck1 , leave_blast ) or IsInArea ( truck2 , leave_blast ) ;
5119: LD_OWVAR 1
5123: PUSH
5124: LD_VAR 0 1
5128: GREATER
5129: PUSH
5130: LD_EXP 7
5134: PPUSH
5135: LD_INT 5
5137: PPUSH
5138: CALL_OW 308
5142: OR
5143: PUSH
5144: LD_EXP 8
5148: PPUSH
5149: LD_INT 5
5151: PPUSH
5152: CALL_OW 308
5156: OR
5157: PUSH
5158: LD_EXP 7
5162: PPUSH
5163: LD_INT 8
5165: PPUSH
5166: CALL_OW 308
5170: OR
5171: PUSH
5172: LD_EXP 8
5176: PPUSH
5177: LD_INT 8
5179: PPUSH
5180: CALL_OW 308
5184: OR
5185: IFFALSE 5112
// blast_time := tick ;
5187: LD_ADDR_VAR 0 1
5191: PUSH
5192: LD_OWVAR 1
5196: ST_TO_ADDR
// DialogueOn ;
5197: CALL_OW 6
// interface_hidden := true ;
5201: LD_ADDR_OWVAR 54
5205: PUSH
5206: LD_INT 1
5208: ST_TO_ADDR
// CenterOnXY ( 103 , 52 ) ;
5209: LD_INT 103
5211: PPUSH
5212: LD_INT 52
5214: PPUSH
5215: CALL_OW 84
// wait ( 0 0$3 ) ;
5219: LD_INT 105
5221: PPUSH
5222: CALL_OW 67
// PrepareSiberiteRocket ;
5226: CALL_OW 357
// SendSiberiteRocket ( 103 , 52 ) ;
5230: LD_INT 103
5232: PPUSH
5233: LD_INT 52
5235: PPUSH
5236: CALL_OW 429
// interface_hidden := false ;
5240: LD_ADDR_OWVAR 54
5244: PUSH
5245: LD_INT 0
5247: ST_TO_ADDR
// DialogueOff ;
5248: CALL_OW 7
// blast_done := true ;
5252: LD_ADDR_EXP 28
5256: PUSH
5257: LD_INT 1
5259: ST_TO_ADDR
// contamine := TICK + 6000 ;
5260: LD_ADDR_EXP 30
5264: PUSH
5265: LD_OWVAR 1
5269: PUSH
5270: LD_INT 6000
5272: PLUS
5273: ST_TO_ADDR
// wait ( 0 0$4 ) ;
5274: LD_INT 140
5276: PPUSH
5277: CALL_OW 67
// if not IsLive ( Burlak ) then
5281: LD_EXP 2
5285: PPUSH
5286: CALL_OW 300
5290: NOT
5291: IFFALSE 5300
// Mission_Failed ( 1 ) ;
5293: LD_INT 1
5295: PPUSH
5296: CALL 1213 0 1
// if not IsLive ( MacMillan ) then
5300: LD_EXP 1
5304: PPUSH
5305: CALL_OW 300
5309: NOT
5310: IFFALSE 5319
// Mission_Failed ( 2 ) ;
5312: LD_INT 2
5314: PPUSH
5315: CALL 1213 0 1
// if not ( FindArtifact ( 4 ) or art_cargo ) then
5319: LD_INT 4
5321: PPUSH
5322: CALL_OW 469
5326: PUSH
5327: LD_EXP 32
5331: OR
5332: NOT
5333: IFFALSE 5342
// Mission_Failed ( 4 ) ;
5335: LD_INT 4
5337: PPUSH
5338: CALL 1213 0 1
// after_the_blast ;
5342: CALL 5355 0 0
// enable ( 5 ) ;
5346: LD_INT 5
5348: ENABLE_MARKED
// enable ( 7 ) ;
5349: LD_INT 7
5351: ENABLE_MARKED
// end ;
5352: PPOPN 1
5354: END
// function after_the_blast ; begin
5355: LD_INT 0
5357: PPUSH
// blast_was_seen := true ;
5358: LD_ADDR_EXP 9
5362: PUSH
5363: LD_INT 1
5365: ST_TO_ADDR
// DialogueOn ;
5366: CALL_OW 6
// interface_hidden := true ;
5370: LD_ADDR_OWVAR 54
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// Say ( MacMillan , D6a-JMM-1 ) ;
5378: LD_EXP 1
5382: PPUSH
5383: LD_STRING D6a-JMM-1
5385: PPUSH
5386: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
5390: LD_EXP 2
5394: PPUSH
5395: LD_STRING D6a-Bur-1
5397: PPUSH
5398: CALL_OW 88
// enable ( 8 ) ;
5402: LD_INT 8
5404: ENABLE_MARKED
// Say ( MacMillan , D6c-JMM-1 ) ;
5405: LD_EXP 1
5409: PPUSH
5410: LD_STRING D6c-JMM-1
5412: PPUSH
5413: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
5417: LD_EXP 2
5421: PPUSH
5422: LD_STRING D6c-Bur-1
5424: PPUSH
5425: CALL_OW 88
// Say ( MacMillan , D6c-JMM-2 ) ;
5429: LD_EXP 1
5433: PPUSH
5434: LD_STRING D6c-JMM-2
5436: PPUSH
5437: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
5441: LD_STRING MBase
5443: PPUSH
5444: CALL_OW 337
// interface_hidden := false ;
5448: LD_ADDR_OWVAR 54
5452: PUSH
5453: LD_INT 0
5455: ST_TO_ADDR
// DialogueOff ;
5456: CALL_OW 7
// enable ( 6 ) ;
5460: LD_INT 6
5462: ENABLE_MARKED
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_distxy , 103 , 52 , 27 ] ] ) marked 8 do
5468: LD_INT 22
5470: PUSH
5471: LD_EXP 17
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 92
5482: PUSH
5483: LD_INT 103
5485: PUSH
5486: LD_INT 52
5488: PUSH
5489: LD_INT 27
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 69
5506: IFFALSE 5577
5508: GO 5510
5510: DISABLE
// begin CenterOnUnits ( [ MacMillan , Burlak ] ) ;
5511: LD_EXP 1
5515: PUSH
5516: LD_EXP 2
5520: PUSH
5521: EMPTY
5522: LIST
5523: LIST
5524: PPUSH
5525: CALL_OW 85
// DialogueOn ;
5529: CALL_OW 6
// interface_hidden := true ;
5533: LD_ADDR_OWVAR 54
5537: PUSH
5538: LD_INT 1
5540: ST_TO_ADDR
// Say ( MacMillan , D6b-JMM-1 ) ;
5541: LD_EXP 1
5545: PPUSH
5546: LD_STRING D6b-JMM-1
5548: PPUSH
5549: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
5553: LD_EXP 2
5557: PPUSH
5558: LD_STRING D6b-Bur-1
5560: PPUSH
5561: CALL_OW 88
// interface_hidden := false ;
5565: LD_ADDR_OWVAR 54
5569: PUSH
5570: LD_INT 0
5572: ST_TO_ADDR
// DialogueOff ;
5573: CALL_OW 7
// end ;
5577: END
// every 0 0$1 trigger IsInArea ( MacMillan , blast_area ) and ( contamine > TICK ) marked 6 do
5578: LD_EXP 1
5582: PPUSH
5583: LD_INT 6
5585: PPUSH
5586: CALL_OW 308
5590: PUSH
5591: LD_EXP 30
5595: PUSH
5596: LD_OWVAR 1
5600: GREATER
5601: AND
5602: IFFALSE 5660
5604: GO 5606
5606: DISABLE
// begin CenterOnUnits ( MacMillan ) ;
5607: LD_EXP 1
5611: PPUSH
5612: CALL_OW 85
// DialogueOn ;
5616: CALL_OW 6
// interface_hidden := true ;
5620: LD_ADDR_OWVAR 54
5624: PUSH
5625: LD_INT 1
5627: ST_TO_ADDR
// Say ( MacMillan , D7-JMM-1 ) ;
5628: LD_EXP 1
5632: PPUSH
5633: LD_STRING D7-JMM-1
5635: PPUSH
5636: CALL_OW 88
// interface_hidden := false ;
5640: LD_ADDR_OWVAR 54
5644: PUSH
5645: LD_INT 0
5647: ST_TO_ADDR
// DialogueOff ;
5648: CALL_OW 7
// entered_contaminated_area := true ;
5652: LD_ADDR_EXP 12
5656: PUSH
5657: LD_INT 1
5659: ST_TO_ADDR
// end ;
5660: END
// every 0 0$1 trigger IsInArea ( Burlak , blast_area ) and ( contamine > TICK ) marked 6 do
5661: LD_EXP 2
5665: PPUSH
5666: LD_INT 6
5668: PPUSH
5669: CALL_OW 308
5673: PUSH
5674: LD_EXP 30
5678: PUSH
5679: LD_OWVAR 1
5683: GREATER
5684: AND
5685: IFFALSE 5743
5687: GO 5689
5689: DISABLE
// begin CenterOnUnits ( Burlak ) ;
5690: LD_EXP 2
5694: PPUSH
5695: CALL_OW 85
// DialogueOn ;
5699: CALL_OW 6
// interface_hidden := true ;
5703: LD_ADDR_OWVAR 54
5707: PUSH
5708: LD_INT 1
5710: ST_TO_ADDR
// Say ( Burlak , D7-Bur-1 ) ;
5711: LD_EXP 2
5715: PPUSH
5716: LD_STRING D7-Bur-1
5718: PPUSH
5719: CALL_OW 88
// interface_hidden := false ;
5723: LD_ADDR_OWVAR 54
5727: PUSH
5728: LD_INT 0
5730: ST_TO_ADDR
// DialogueOff ;
5731: CALL_OW 7
// entered_contaminated_area := true ;
5735: LD_ADDR_EXP 12
5739: PUSH
5740: LD_INT 1
5742: ST_TO_ADDR
// end ;
5743: END
// every 0 0$10 marked 5 do var time_limit , warning_time ;
5744: GO 5746
5746: DISABLE
5747: LD_INT 0
5749: PPUSH
5750: PPUSH
// begin time_limit := [ 5 5$0 , 4 4$0 , 3 3$0 ] ;
5751: LD_ADDR_VAR 0 1
5755: PUSH
5756: LD_INT 10500
5758: PUSH
5759: LD_INT 8400
5761: PUSH
5762: LD_INT 6300
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: LIST
5769: ST_TO_ADDR
// warning_time := TICK + time_limit [ difficulty ] ;
5770: LD_ADDR_VAR 0 2
5774: PUSH
5775: LD_OWVAR 1
5779: PUSH
5780: LD_VAR 0 1
5784: PUSH
5785: LD_OWVAR 67
5789: ARRAY
5790: PLUS
5791: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
5792: LD_INT 350
5794: PPUSH
5795: CALL_OW 67
// until TICK > warning_time ;
5799: LD_OWVAR 1
5803: PUSH
5804: LD_VAR 0 2
5808: GREATER
5809: IFFALSE 5792
// if ( not query_started ) or ( not technology_taken ) then
5811: LD_EXP 29
5815: NOT
5816: PUSH
5817: LD_EXP 15
5821: NOT
5822: OR
5823: IFFALSE 5837
// Say ( MacMillan , D8-JMM-1 ) ;
5825: LD_EXP 1
5829: PPUSH
5830: LD_STRING D8-JMM-1
5832: PPUSH
5833: CALL_OW 88
// end ;
5837: PPOPN 2
5839: END
// every 0 0$2 trigger See ( you , oil_2 ) do
5840: LD_EXP 17
5844: PPUSH
5845: LD_INT 9
5847: PPUSH
5848: CALL_OW 292
5852: IFFALSE 5912
5854: GO 5856
5856: DISABLE
// begin CenterOnUnits ( oil_2 ) ;
5857: LD_INT 9
5859: PPUSH
5860: CALL_OW 85
// DialogueOn ;
5864: CALL_OW 6
// interface_hidden := true ;
5868: LD_ADDR_OWVAR 54
5872: PUSH
5873: LD_INT 1
5875: ST_TO_ADDR
// Say ( Burlak , D9-Bur-1 ) ;
5876: LD_EXP 2
5880: PPUSH
5881: LD_STRING D9-Bur-1
5883: PPUSH
5884: CALL_OW 88
// Say ( MacMillan , D9-JMM-1 ) ;
5888: LD_EXP 1
5892: PPUSH
5893: LD_STRING D9-JMM-1
5895: PPUSH
5896: CALL_OW 88
// interface_hidden := false ;
5900: LD_ADDR_OWVAR 54
5904: PUSH
5905: LD_INT 0
5907: ST_TO_ADDR
// DialogueOff ;
5908: CALL_OW 7
// end ;
5912: END
// export function query_kill ; var odpoved ; begin
5913: LD_INT 0
5915: PPUSH
5916: PPUSH
// query_started := true ;
5917: LD_ADDR_EXP 29
5921: PUSH
5922: LD_INT 1
5924: ST_TO_ADDR
// if Query ( QKill ) = 1 then
5925: LD_STRING QKill
5927: PPUSH
5928: CALL_OW 97
5932: PUSH
5933: LD_INT 1
5935: EQUAL
5936: IFFALSE 5944
// query_vyjednavat else
5938: CALL 5953 0 0
5942: GO 5948
// query_pozabijet ;
5944: CALL 6494 0 0
// end ;
5948: LD_VAR 0 1
5952: RET
// function query_vyjednavat ; var un , vedci , list ; begin
5953: LD_INT 0
5955: PPUSH
5956: PPUSH
5957: PPUSH
5958: PPUSH
// SetAttitude ( you , americans , att_neutral , true ) ;
5959: LD_EXP 17
5963: PPUSH
5964: LD_EXP 18
5968: PPUSH
5969: LD_INT 0
5971: PPUSH
5972: LD_INT 1
5974: PPUSH
5975: CALL_OW 80
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
5979: LD_ADDR_VAR 0 4
5983: PUSH
5984: LD_INT 22
5986: PUSH
5987: LD_EXP 18
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PUSH
5996: LD_INT 21
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: ST_TO_ADDR
// for un in list do
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: LD_VAR 0 4
6024: PUSH
6025: FOR_IN
6026: IFFALSE 6107
// if not IsInUnit ( un ) then
6028: LD_VAR 0 2
6032: PPUSH
6033: CALL_OW 310
6037: NOT
6038: IFFALSE 6105
// ComMoveXY ( un , ShiftX ( GetX ( un ) , GetDir ( un ) , 1 ) , ShiftY ( GetY ( un ) , GetDir ( un ) , 1 ) ) ;
6040: LD_VAR 0 2
6044: PPUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: CALL_OW 250
6054: PPUSH
6055: LD_VAR 0 2
6059: PPUSH
6060: CALL_OW 254
6064: PPUSH
6065: LD_INT 1
6067: PPUSH
6068: CALL_OW 272
6072: PPUSH
6073: LD_VAR 0 2
6077: PPUSH
6078: CALL_OW 251
6082: PPUSH
6083: LD_VAR 0 2
6087: PPUSH
6088: CALL_OW 254
6092: PPUSH
6093: LD_INT 1
6095: PPUSH
6096: CALL_OW 273
6100: PPUSH
6101: CALL_OW 111
6105: GO 6025
6107: POP
6108: POP
// Wait ( 10 ) ;
6109: LD_INT 10
6111: PPUSH
6112: CALL_OW 67
// CenterOnUnits ( [ us_lab ] ) ;
6116: LD_INT 1
6118: PUSH
6119: EMPTY
6120: LIST
6121: PPUSH
6122: CALL_OW 85
// InGameOn ;
6126: CALL_OW 8
// if GetLives ( us_lab ) > 300 then
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 256
6137: PUSH
6138: LD_INT 300
6140: GREATER
6141: IFFALSE 6152
// ComExitBuilding ( us_sci ) ;
6143: LD_EXP 22
6147: PPUSH
6148: CALL_OW 122
// Check_Heroes ;
6152: CALL 7072 0 0
// Say ( MacMillan , D10a-JMM-1 ) ;
6156: LD_EXP 1
6160: PPUSH
6161: LD_STRING D10a-JMM-1
6163: PPUSH
6164: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
6168: LD_EXP 2
6172: PPUSH
6173: LD_STRING D10a-Bur-1
6175: PPUSH
6176: CALL_OW 88
// Say ( MacMillan , D10a-JMM-2 ) ;
6180: LD_EXP 1
6184: PPUSH
6185: LD_STRING D10a-JMM-2
6187: PPUSH
6188: CALL_OW 88
// if original_stevens then
6192: LD_EXP 13
6196: IFFALSE 6308
// begin if GetDistUnitArea ( MacMillan , us_base ) = 0 then
6198: LD_EXP 1
6202: PPUSH
6203: LD_INT 1
6205: PPUSH
6206: CALL_OW 299
6210: PUSH
6211: LD_INT 0
6213: EQUAL
6214: IFFALSE 6232
// ComMoveUnit ( Stevens , MacMillan ) else
6216: LD_EXP 6
6220: PPUSH
6221: LD_EXP 1
6225: PPUSH
6226: CALL_OW 112
6230: GO 6246
// ComMoveUnit ( Stevens , Burlak ) ;
6232: LD_EXP 6
6236: PPUSH
6237: LD_EXP 2
6241: PPUSH
6242: CALL_OW 112
// Say ( Stevens , D10a-Huck-2 ) ;
6246: LD_EXP 6
6250: PPUSH
6251: LD_STRING D10a-Huck-2
6253: PPUSH
6254: CALL_OW 88
// if Joan then
6258: LD_EXP 3
6262: IFFALSE 6288
// begin Say ( MacMillan , D10a-JMM-3 ) ;
6264: LD_EXP 1
6268: PPUSH
6269: LD_STRING D10a-JMM-3
6271: PPUSH
6272: CALL_OW 88
// Say ( Stevens , D10a-Huck-3 ) ;
6276: LD_EXP 6
6280: PPUSH
6281: LD_STRING D10a-Huck-3
6283: PPUSH
6284: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
6288: LD_INT 35
6290: PPUSH
6291: CALL_OW 67
// until IsBusy ( Stevens ) ;
6295: LD_EXP 6
6299: PPUSH
6300: CALL_OW 315
6304: IFFALSE 6288
// end else
6306: GO 6452
// begin vedci := FilterAllUnits ( [ [ f_side , americans ] , [ f_class , class_scientistic ] ] ) ;
6308: LD_ADDR_VAR 0 3
6312: PUSH
6313: LD_INT 22
6315: PUSH
6316: LD_EXP 18
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: PUSH
6325: LD_INT 25
6327: PUSH
6328: LD_INT 4
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: EMPTY
6336: LIST
6337: LIST
6338: PPUSH
6339: CALL_OW 69
6343: ST_TO_ADDR
// if vedci then
6344: LD_VAR 0 3
6348: IFFALSE 6366
// un := vedci [ 1 ] else
6350: LD_ADDR_VAR 0 2
6354: PUSH
6355: LD_VAR 0 3
6359: PUSH
6360: LD_INT 1
6362: ARRAY
6363: ST_TO_ADDR
6364: GO 6374
// un := 0 ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_INT 0
6373: ST_TO_ADDR
// Say ( un , D10a-ASci1-3 ) ;
6374: LD_VAR 0 2
6378: PPUSH
6379: LD_STRING D10a-ASci1-3
6381: PPUSH
6382: CALL_OW 88
// if GetDistUnitArea ( Burlak , us_base ) = 0 then
6386: LD_EXP 2
6390: PPUSH
6391: LD_INT 1
6393: PPUSH
6394: CALL_OW 299
6398: PUSH
6399: LD_INT 0
6401: EQUAL
6402: IFFALSE 6420
// ComMoveUnit ( un , Burlak ) else
6404: LD_VAR 0 2
6408: PPUSH
6409: LD_EXP 2
6413: PPUSH
6414: CALL_OW 112
6418: GO 6434
// ComMoveUnit ( un , MacMillan ) ;
6420: LD_VAR 0 2
6424: PPUSH
6425: LD_EXP 1
6429: PPUSH
6430: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6434: LD_INT 35
6436: PPUSH
6437: CALL_OW 67
// until IsBusy ( un ) ;
6441: LD_VAR 0 2
6445: PPUSH
6446: CALL_OW 315
6450: IFFALSE 6434
// end ; ComStop ( un ) ;
6452: LD_VAR 0 2
6456: PPUSH
6457: CALL_OW 141
// Say ( MacMillan , D10a-JMM-4 ) ;
6461: LD_EXP 1
6465: PPUSH
6466: LD_STRING D10a-JMM-4
6468: PPUSH
6469: CALL_OW 88
// technology_taken := true ;
6473: LD_ADDR_EXP 15
6477: PUSH
6478: LD_INT 1
6480: ST_TO_ADDR
// InGameOff ;
6481: CALL_OW 9
// konecny_rozhovor ;
6485: CALL 6892 0 0
// end ;
6489: LD_VAR 0 1
6493: RET
// function query_pozabijet ; var un , list , defenders , intruders ; begin
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
6499: PPUSH
6500: PPUSH
// Check_Heroes ;
6501: CALL 7072 0 0
// DialogueOn ;
6505: CALL_OW 6
// interface_hidden := true ;
6509: LD_ADDR_OWVAR 54
6513: PUSH
6514: LD_INT 1
6516: ST_TO_ADDR
// Say ( MacMillan , D10b-JMM-1 ) ;
6517: LD_EXP 1
6521: PPUSH
6522: LD_STRING D10b-JMM-1
6524: PPUSH
6525: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_warehouse ] ] ) then
6529: LD_INT 22
6531: PUSH
6532: LD_EXP 18
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: LD_INT 30
6543: PUSH
6544: LD_INT 1
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: PPUSH
6555: CALL_OW 69
6559: IFFALSE 6573
// Say ( Burlak , D10b-Bur-1 ) ;
6561: LD_EXP 2
6565: PPUSH
6566: LD_STRING D10b-Bur-1
6568: PPUSH
6569: CALL_OW 88
// interface_hidden := false ;
6573: LD_ADDR_OWVAR 54
6577: PUSH
6578: LD_INT 0
6580: ST_TO_ADDR
// DialogueOff ;
6581: CALL_OW 7
// enable ( 9 ) ;
6585: LD_INT 9
6587: ENABLE_MARKED
// repeat ComMoveToArea ( us_sci , leave_area ) ;
6588: LD_EXP 22
6592: PPUSH
6593: LD_INT 7
6595: PPUSH
6596: CALL_OW 113
// defenders := FilterAllUnits ( [ [ f_side , americans ] , [ f_class , class_soldier ] ] ) ;
6600: LD_ADDR_VAR 0 4
6604: PUSH
6605: LD_INT 22
6607: PUSH
6608: LD_EXP 18
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: PUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 1
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: PPUSH
6631: CALL_OW 69
6635: ST_TO_ADDR
// intruders := FilterUnitsInArea ( us_base , [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6636: LD_ADDR_VAR 0 5
6640: PUSH
6641: LD_INT 1
6643: PPUSH
6644: LD_INT 22
6646: PUSH
6647: LD_EXP 17
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PUSH
6656: LD_INT 2
6658: PUSH
6659: LD_INT 21
6661: PUSH
6662: LD_INT 1
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 21
6671: PUSH
6672: LD_INT 2
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PPUSH
6688: CALL_OW 70
6692: ST_TO_ADDR
// if intruders then
6693: LD_VAR 0 5
6697: IFFALSE 6717
// ComAttackUnit ( defenders , intruders [ 1 ] ) ;
6699: LD_VAR 0 4
6703: PPUSH
6704: LD_VAR 0 5
6708: PUSH
6709: LD_INT 1
6711: ARRAY
6712: PPUSH
6713: CALL_OW 115
// wait ( 0 0$1 ) ;
6717: LD_INT 35
6719: PPUSH
6720: CALL_OW 67
// until ( not us_sci ) or lab_destroyed or ( not intruders ) ;
6724: LD_EXP 22
6728: NOT
6729: PUSH
6730: LD_EXP 10
6734: OR
6735: PUSH
6736: LD_VAR 0 5
6740: NOT
6741: OR
6742: IFFALSE 6588
// ComExitBuilding ( defenders ) ;
6744: LD_VAR 0 4
6748: PPUSH
6749: CALL_OW 122
// repeat list := FilterAllUnits ( [ [ f_see , americans ] , [ f_side , you ] ] ) ;
6753: LD_ADDR_VAR 0 3
6757: PUSH
6758: LD_INT 101
6760: PUSH
6761: LD_EXP 18
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: PUSH
6770: LD_INT 22
6772: PUSH
6773: LD_EXP 17
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PPUSH
6786: CALL_OW 69
6790: ST_TO_ADDR
// if list then
6791: LD_VAR 0 3
6795: IFFALSE 6817
// ComAttackUnit ( defenders , list [ 1 ] ) else
6797: LD_VAR 0 4
6801: PPUSH
6802: LD_VAR 0 3
6806: PUSH
6807: LD_INT 1
6809: ARRAY
6810: PPUSH
6811: CALL_OW 115
6815: GO 6842
// if GetLives ( us_lab ) > 1 then
6817: LD_INT 1
6819: PPUSH
6820: CALL_OW 256
6824: PUSH
6825: LD_INT 1
6827: GREATER
6828: IFFALSE 6842
// ComAttackUnit ( defenders , us_lab ) ;
6830: LD_VAR 0 4
6834: PPUSH
6835: LD_INT 1
6837: PPUSH
6838: CALL_OW 115
// wait ( 0 0$1 ) ;
6842: LD_INT 35
6844: PPUSH
6845: CALL_OW 67
// until lab_destroyed ;
6849: LD_EXP 10
6853: IFFALSE 6753
// ComMoveToArea ( defenders , leave_area ) ;
6855: LD_VAR 0 4
6859: PPUSH
6860: LD_INT 7
6862: PPUSH
6863: CALL_OW 113
// if ( not us_sci ) and lab_destroyed then
6867: LD_EXP 22
6871: NOT
6872: PUSH
6873: LD_EXP 10
6877: AND
6878: IFFALSE 6887
// Mission_Failed ( 5 ) ;
6880: LD_INT 5
6882: PPUSH
6883: CALL 1213 0 1
// end ;
6887: LD_VAR 0 1
6891: RET
// export function konecny_rozhovor ; var art_ready ; begin
6892: LD_INT 0
6894: PPUSH
6895: PPUSH
// if not dokecano then
6896: LD_LOC 1
6900: NOT
6901: IFFALSE 6960
// begin dokecano := true ;
6903: LD_ADDR_LOC 1
6907: PUSH
6908: LD_INT 1
6910: ST_TO_ADDR
// DialogueOn ;
6911: CALL_OW 6
// interface_hidden := true ;
6915: LD_ADDR_OWVAR 54
6919: PUSH
6920: LD_INT 1
6922: ST_TO_ADDR
// Say ( Burlak , D11-Bur-1 ) ;
6923: LD_EXP 2
6927: PPUSH
6928: LD_STRING D11-Bur-1
6930: PPUSH
6931: CALL_OW 88
// ChangeMissionObjectives ( MEnd ) ;
6935: LD_STRING MEnd
6937: PPUSH
6938: CALL_OW 337
// enable ( 10 ) ;
6942: LD_INT 10
6944: ENABLE_MARKED
// disable ( 1 ) ;
6945: LD_INT 1
6947: DISABLE_MARKED
// interface_hidden := false ;
6948: LD_ADDR_OWVAR 54
6952: PUSH
6953: LD_INT 0
6955: ST_TO_ADDR
// DialogueOff ;
6956: CALL_OW 7
// end ; SetAreaMapShow ( exit_area , 1 ) ;
6960: LD_INT 11
6962: PPUSH
6963: LD_INT 1
6965: PPUSH
6966: CALL_OW 424
// repeat wait ( 0 0$2 ) ;
6970: LD_INT 70
6972: PPUSH
6973: CALL_OW 67
// if art_cargo and not IsInArea ( art_cargo , us_base ) then
6977: LD_EXP 32
6981: PUSH
6982: LD_EXP 32
6986: PPUSH
6987: LD_INT 1
6989: PPUSH
6990: CALL_OW 308
6994: NOT
6995: AND
6996: IFFALSE 7008
// art_ready := true else
6998: LD_ADDR_VAR 0 2
7002: PUSH
7003: LD_INT 1
7005: ST_TO_ADDR
7006: GO 7016
// art_ready := false ;
7008: LD_ADDR_VAR 0 2
7012: PUSH
7013: LD_INT 0
7015: ST_TO_ADDR
// until not ( IsInArea ( MacMillan , us_base ) or IsInArea ( Burlak , us_base ) or not art_ready ) ;
7016: LD_EXP 1
7020: PPUSH
7021: LD_INT 1
7023: PPUSH
7024: CALL_OW 308
7028: PUSH
7029: LD_EXP 2
7033: PPUSH
7034: LD_INT 1
7036: PPUSH
7037: CALL_OW 308
7041: OR
7042: PUSH
7043: LD_VAR 0 2
7047: NOT
7048: OR
7049: NOT
7050: IFFALSE 6970
// wait ( 0 0$2 ) ;
7052: LD_INT 70
7054: PPUSH
7055: CALL_OW 67
// konec_mise ;
7059: CALL 915 0 0
// DialogueOff ;
7063: CALL_OW 7
// end ;
7067: LD_VAR 0 1
7071: RET
// function Check_Heroes ; begin
7072: LD_INT 0
7074: PPUSH
// if not IsOK ( MacMillan ) then
7075: LD_EXP 1
7079: PPUSH
7080: CALL_OW 302
7084: NOT
7085: IFFALSE 7094
// YouLost ( 2 ) ;
7087: LD_INT 2
7089: PPUSH
7090: CALL_OW 104
// if not IsOK ( Burlak ) then
7094: LD_EXP 2
7098: PPUSH
7099: CALL_OW 302
7103: NOT
7104: IFFALSE 7113
// YouLost ( 1 ) ;
7106: LD_INT 1
7108: PPUSH
7109: CALL_OW 104
// end ; end_of_file
7113: LD_VAR 0 1
7117: RET
// every 0 0$1 marked 7 do var list , un ;
7118: GO 7120
7120: DISABLE
7121: LD_INT 0
7123: PPUSH
7124: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , f_not , [ f_lives , 1000 ] ] ) ;
7125: LD_ADDR_VAR 0 1
7129: PUSH
7130: LD_INT 22
7132: PUSH
7133: LD_EXP 18
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: LD_INT 21
7144: PUSH
7145: LD_INT 3
7147: PUSH
7148: EMPTY
7149: LIST
7150: LIST
7151: PUSH
7152: LD_INT 2
7154: PUSH
7155: LD_INT 30
7157: PUSH
7158: LD_INT 33
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: PUSH
7165: LD_INT 30
7167: PUSH
7168: LD_INT 32
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: EMPTY
7176: LIST
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 3
7182: PUSH
7183: LD_INT 24
7185: PUSH
7186: LD_INT 1000
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: LIST
7199: PPUSH
7200: CALL_OW 69
7204: ST_TO_ADDR
// if list then
7205: LD_VAR 0 1
7209: IFFALSE 7220
// repair_base ( list ) ;
7211: LD_VAR 0 1
7215: PPUSH
7216: CALL 7231 0 1
// if not keep_base_finished then
7220: LD_EXP 16
7224: NOT
7225: IFFALSE 7228
// enable ;
7227: ENABLE
// end ;
7228: PPOPN 2
7230: END
// function repair_base ( list ) ; var un , driver ; begin
7231: LD_INT 0
7233: PPUSH
7234: PPUSH
7235: PPUSH
// repeat if keep_base_finished then
7236: LD_EXP 16
7240: IFFALSE 7244
// exit ;
7242: GO 7436
// if list then
7244: LD_VAR 0 1
7248: IFFALSE 7268
// ComRepairBuilding ( crane , list [ 1 ] ) else
7250: LD_INT 15
7252: PPUSH
7253: LD_VAR 0 1
7257: PUSH
7258: LD_INT 1
7260: ARRAY
7261: PPUSH
7262: CALL_OW 130
7266: GO 7270
// exit ;
7268: GO 7436
// if GetLives ( crane ) < 700 then
7270: LD_INT 15
7272: PPUSH
7273: CALL_OW 256
7277: PUSH
7278: LD_INT 700
7280: LESS
7281: IFFALSE 7383
// begin ComMoveToArea ( crane , am_repair ) ;
7283: LD_INT 15
7285: PPUSH
7286: LD_INT 10
7288: PPUSH
7289: CALL_OW 113
// while not IsInArea ( crane , am_repair ) do
7293: LD_INT 15
7295: PPUSH
7296: LD_INT 10
7298: PPUSH
7299: CALL_OW 308
7303: NOT
7304: IFFALSE 7315
// wait ( 0 0$1 ) ;
7306: LD_INT 35
7308: PPUSH
7309: CALL_OW 67
7313: GO 7293
// ComExitVehicle ( crane ) ;
7315: LD_INT 15
7317: PPUSH
7318: CALL_OW 121
// while IsDrivenBy ( crane ) do
7322: LD_INT 15
7324: PPUSH
7325: CALL_OW 311
7329: IFFALSE 7340
// wait ( 10 ) ;
7331: LD_INT 10
7333: PPUSH
7334: CALL_OW 67
7338: GO 7322
// ComRepairVehicle ( us_mech , crane ) ;
7340: LD_EXP 23
7344: PPUSH
7345: LD_INT 15
7347: PPUSH
7348: CALL_OW 129
// AddComEnterUnit ( us_mech , crane ) ;
7352: LD_EXP 23
7356: PPUSH
7357: LD_INT 15
7359: PPUSH
7360: CALL_OW 180
// while not IsDrivenBy ( crane ) do
7364: LD_INT 15
7366: PPUSH
7367: CALL_OW 311
7371: NOT
7372: IFFALSE 7383
// wait ( 0 0$1 ) ;
7374: LD_INT 35
7376: PPUSH
7377: CALL_OW 67
7381: GO 7364
// end ; if GetLives ( list [ 1 ] ) = 1000 then
7383: LD_VAR 0 1
7387: PUSH
7388: LD_INT 1
7390: ARRAY
7391: PPUSH
7392: CALL_OW 256
7396: PUSH
7397: LD_INT 1000
7399: EQUAL
7400: IFFALSE 7422
// list := list diff list [ 1 ] ;
7402: LD_ADDR_VAR 0 1
7406: PUSH
7407: LD_VAR 0 1
7411: PUSH
7412: LD_VAR 0 1
7416: PUSH
7417: LD_INT 1
7419: ARRAY
7420: DIFF
7421: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7422: LD_INT 35
7424: PPUSH
7425: CALL_OW 67
// until not list ;
7429: LD_VAR 0 1
7433: NOT
7434: IFFALSE 7236
// end ;
7436: LD_VAR 0 2
7440: RET
