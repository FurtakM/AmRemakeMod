// export Frank , Lisa , Joan , Powell , JMM , Denis , Bobby , Cyrus , Donaldson , Brown , Gladstone , Gary ; export FSol1 , Sol1 , Sci1 ; export you , you2 , russians , arabians ; export otherG2 , other_survivors , Gamma2 ; export SikorskiDiedIn8 ; function load_units_1 ; var i , bud , b , depot , blds , tmp , lidi ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
   7: PPUSH
   8: PPUSH
   9: PPUSH
// InitUc ;
  10: CALL_OW 18
// InitHc ;
  14: CALL_OW 19
// InitVc ;
  18: CALL_OW 20
// Gamma2 := LoadVariable ( Gamma2 , [ ] ) ;
  22: LD_ADDR_EXP 22
  26: PUSH
  27: LD_STRING Gamma2
  29: PPUSH
  30: EMPTY
  31: PPUSH
  32: CALL_OW 30
  36: ST_TO_ADDR
// if not Gamma2 then
  37: LD_EXP 22
  41: NOT
  42: IFFALSE 51
// Msg ( Corrupted save ) ;
  44: LD_STRING Corrupted save
  46: PPUSH
  47: CALL_OW 100
// blds := [ ] ;
  51: LD_ADDR_VAR 0 6
  55: PUSH
  56: EMPTY
  57: ST_TO_ADDR
// for i in Gamma2 do
  58: LD_ADDR_VAR 0 2
  62: PUSH
  63: LD_EXP 22
  67: PUSH
  68: FOR_IN
  69: IFFALSE 295
// begin bc_type := i [ 4 ] ;
  71: LD_ADDR_OWVAR 42
  75: PUSH
  76: LD_VAR 0 2
  80: PUSH
  81: LD_INT 4
  83: ARRAY
  84: ST_TO_ADDR
// bc_level := i [ 5 ] ;
  85: LD_ADDR_OWVAR 43
  89: PUSH
  90: LD_VAR 0 2
  94: PUSH
  95: LD_INT 5
  97: ARRAY
  98: ST_TO_ADDR
// uc_nation := i [ 6 ] ;
  99: LD_ADDR_OWVAR 21
 103: PUSH
 104: LD_VAR 0 2
 108: PUSH
 109: LD_INT 6
 111: ARRAY
 112: ST_TO_ADDR
// case bc_type of b_lab , b_lab_half , b_lab_full :
 113: LD_OWVAR 42
 117: PUSH
 118: LD_INT 6
 120: DOUBLE
 121: EQUAL
 122: IFTRUE 138
 124: LD_INT 7
 126: DOUBLE
 127: EQUAL
 128: IFTRUE 138
 130: LD_INT 8
 132: DOUBLE
 133: EQUAL
 134: IFTRUE 138
 136: GO 169
 138: POP
// begin bc_kind1 := i [ 7 ] ;
 139: LD_ADDR_OWVAR 44
 143: PUSH
 144: LD_VAR 0 2
 148: PUSH
 149: LD_INT 7
 151: ARRAY
 152: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
 153: LD_ADDR_OWVAR 45
 157: PUSH
 158: LD_VAR 0 2
 162: PUSH
 163: LD_INT 8
 165: ARRAY
 166: ST_TO_ADDR
// end ; end ;
 167: GO 170
 169: POP
// tmp := CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
 170: LD_ADDR_VAR 0 7
 174: PUSH
 175: LD_VAR 0 2
 179: PUSH
 180: LD_INT 1
 182: ARRAY
 183: PPUSH
 184: LD_VAR 0 2
 188: PUSH
 189: LD_INT 2
 191: ARRAY
 192: PPUSH
 193: LD_VAR 0 2
 197: PUSH
 198: LD_INT 3
 200: ARRAY
 201: PPUSH
 202: CALL_OW 47
 206: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
 207: LD_OWVAR 42
 211: PUSH
 212: LD_INT 32
 214: EQUAL
 215: PUSH
 216: LD_OWVAR 42
 220: PUSH
 221: LD_INT 33
 223: EQUAL
 224: OR
 225: IFFALSE 245
// PlaceWeaponTurret ( tmp , i [ 7 ] ) ;
 227: LD_VAR 0 7
 231: PPUSH
 232: LD_VAR 0 2
 236: PUSH
 237: LD_INT 7
 239: ARRAY
 240: PPUSH
 241: CALL_OW 431
// if bc_type = b_depot or bc_type = b_warehouse then
 245: LD_OWVAR 42
 249: PUSH
 250: LD_INT 0
 252: EQUAL
 253: PUSH
 254: LD_OWVAR 42
 258: PUSH
 259: LD_INT 1
 261: EQUAL
 262: OR
 263: IFFALSE 277
// Setbname ( tmp , gamma ) ;
 265: LD_VAR 0 7
 269: PPUSH
 270: LD_STRING gamma
 272: PPUSH
 273: CALL_OW 500
// blds := blds ^ tmp ;
 277: LD_ADDR_VAR 0 6
 281: PUSH
 282: LD_VAR 0 6
 286: PUSH
 287: LD_VAR 0 7
 291: ADD
 292: ST_TO_ADDR
// end ;
 293: GO 68
 295: POP
 296: POP
// uc_side := you ;
 297: LD_ADDR_OWVAR 20
 301: PUSH
 302: LD_EXP 16
 306: ST_TO_ADDR
// uc_nation := nation_american ;
 307: LD_ADDR_OWVAR 21
 311: PUSH
 312: LD_INT 1
 314: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 315: LD_ADDR_EXP 5
 319: PUSH
 320: LD_STRING JMM
 322: PPUSH
 323: CALL_OW 34
 327: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 328: LD_ADDR_EXP 4
 332: PUSH
 333: LD_STRING Powell
 335: PPUSH
 336: CALL_OW 25
 340: ST_TO_ADDR
// if TestCharacters ( otherGamma2 ) then
 341: LD_STRING otherGamma2
 343: PPUSH
 344: CALL_OW 28
 348: IFFALSE 363
// otherG2 := CreateCharacterSet ( otherGamma2 ) ;
 350: LD_ADDR_EXP 20
 354: PUSH
 355: LD_STRING otherGamma2
 357: PPUSH
 358: CALL_OW 31
 362: ST_TO_ADDR
// Lisa := 0 ;
 363: LD_ADDR_EXP 2
 367: PUSH
 368: LD_INT 0
 370: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 371: LD_STRING Lisa
 373: PPUSH
 374: CALL_OW 29
 378: IFFALSE 409
// if LoadVariable ( LisaLoc , 0 ) = 2 then
 380: LD_STRING LisaLoc
 382: PPUSH
 383: LD_INT 0
 385: PPUSH
 386: CALL_OW 30
 390: PUSH
 391: LD_INT 2
 393: EQUAL
 394: IFFALSE 409
// Lisa := CreateCharacter ( Lisa ) ;
 396: LD_ADDR_EXP 2
 400: PUSH
 401: LD_STRING Lisa
 403: PPUSH
 404: CALL_OW 34
 408: ST_TO_ADDR
// Frank := 0 ;
 409: LD_ADDR_EXP 1
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 417: LD_STRING Frank
 419: PPUSH
 420: CALL_OW 29
 424: IFFALSE 455
// if LoadVariable ( FrankLoc , 0 ) = 2 then
 426: LD_STRING FrankLoc
 428: PPUSH
 429: LD_INT 0
 431: PPUSH
 432: CALL_OW 30
 436: PUSH
 437: LD_INT 2
 439: EQUAL
 440: IFFALSE 455
// Frank := CreateCharacter ( Frank ) ;
 442: LD_ADDR_EXP 1
 446: PUSH
 447: LD_STRING Frank
 449: PPUSH
 450: CALL_OW 34
 454: ST_TO_ADDR
// Donaldson := 0 ;
 455: LD_ADDR_EXP 9
 459: PUSH
 460: LD_INT 0
 462: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 463: LD_STRING Donaldson
 465: PPUSH
 466: CALL_OW 29
 470: IFFALSE 501
// if LoadVariable ( DonaldsonLoc , 0 ) = 2 then
 472: LD_STRING DonaldsonLoc
 474: PPUSH
 475: LD_INT 0
 477: PPUSH
 478: CALL_OW 30
 482: PUSH
 483: LD_INT 2
 485: EQUAL
 486: IFFALSE 501
// Donaldson := CreateCharacter ( Donaldson ) ;
 488: LD_ADDR_EXP 9
 492: PUSH
 493: LD_STRING Donaldson
 495: PPUSH
 496: CALL_OW 34
 500: ST_TO_ADDR
// Brown := 0 ;
 501: LD_ADDR_EXP 10
 505: PUSH
 506: LD_INT 0
 508: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 509: LD_STRING Brown
 511: PPUSH
 512: CALL_OW 29
 516: IFFALSE 547
// if LoadVariable ( BrownLoc , 0 ) = 2 then
 518: LD_STRING BrownLoc
 520: PPUSH
 521: LD_INT 0
 523: PPUSH
 524: CALL_OW 30
 528: PUSH
 529: LD_INT 2
 531: EQUAL
 532: IFFALSE 547
// Brown := CreateCharacter ( Brown ) ;
 534: LD_ADDR_EXP 10
 538: PUSH
 539: LD_STRING Brown
 541: PPUSH
 542: CALL_OW 34
 546: ST_TO_ADDR
// Gladstone := 0 ;
 547: LD_ADDR_EXP 11
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// if CheckCharacterSet ( Gladstone ) then
 555: LD_STRING Gladstone
 557: PPUSH
 558: CALL_OW 29
 562: IFFALSE 593
// if LoadVariable ( GladstoneLoc , 0 ) = 2 then
 564: LD_STRING GladstoneLoc
 566: PPUSH
 567: LD_INT 0
 569: PPUSH
 570: CALL_OW 30
 574: PUSH
 575: LD_INT 2
 577: EQUAL
 578: IFFALSE 593
// Gladstone := CreateCharacter ( Gladstone ) ;
 580: LD_ADDR_EXP 11
 584: PUSH
 585: LD_STRING Gladstone
 587: PPUSH
 588: CALL_OW 34
 592: ST_TO_ADDR
// Joan := 0 ;
 593: LD_ADDR_EXP 3
 597: PUSH
 598: LD_INT 0
 600: ST_TO_ADDR
// if CheckCharacterSet ( Joan ) then
 601: LD_STRING Joan
 603: PPUSH
 604: CALL_OW 29
 608: IFFALSE 639
// if LoadVariable ( JoanLoc , 0 ) = 2 then
 610: LD_STRING JoanLoc
 612: PPUSH
 613: LD_INT 0
 615: PPUSH
 616: CALL_OW 30
 620: PUSH
 621: LD_INT 2
 623: EQUAL
 624: IFFALSE 639
// Joan := CreateCharacter ( Joan ) ;
 626: LD_ADDR_EXP 3
 630: PUSH
 631: LD_STRING Joan
 633: PPUSH
 634: CALL_OW 34
 638: ST_TO_ADDR
// Denis := 0 ;
 639: LD_ADDR_EXP 6
 643: PUSH
 644: LD_INT 0
 646: ST_TO_ADDR
// if CheckCharacterSet ( Denis ) then
 647: LD_STRING Denis
 649: PPUSH
 650: CALL_OW 29
 654: IFFALSE 685
// if LoadVariable ( DenisLoc , 0 ) = 2 then
 656: LD_STRING DenisLoc
 658: PPUSH
 659: LD_INT 0
 661: PPUSH
 662: CALL_OW 30
 666: PUSH
 667: LD_INT 2
 669: EQUAL
 670: IFFALSE 685
// Denis := CreateCharacter ( Denis ) ;
 672: LD_ADDR_EXP 6
 676: PUSH
 677: LD_STRING Denis
 679: PPUSH
 680: CALL_OW 34
 684: ST_TO_ADDR
// if not Lisa then
 685: LD_EXP 2
 689: NOT
 690: IFFALSE 738
// FSol1 := UnitFilter ( otherG2 diff [ Lisa , Frank , JMM ] , [ f_sex , sex_female ] ) ;
 692: LD_ADDR_EXP 13
 696: PUSH
 697: LD_EXP 20
 701: PUSH
 702: LD_EXP 2
 706: PUSH
 707: LD_EXP 1
 711: PUSH
 712: LD_EXP 5
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: DIFF
 722: PPUSH
 723: LD_INT 26
 725: PUSH
 726: LD_INT 2
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: PPUSH
 733: CALL_OW 72
 737: ST_TO_ADDR
// if FSol1 then
 738: LD_EXP 13
 742: IFFALSE 760
// FSol1 := FSol1 [ 1 ] else
 744: LD_ADDR_EXP 13
 748: PUSH
 749: LD_EXP 13
 753: PUSH
 754: LD_INT 1
 756: ARRAY
 757: ST_TO_ADDR
 758: GO 803
// begin uc_side := you ;
 760: LD_ADDR_OWVAR 20
 764: PUSH
 765: LD_EXP 16
 769: ST_TO_ADDR
// PrepareHuman ( sex_female , 0 , Rand ( - 2 , - 4 ) ) ;
 770: LD_INT 2
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: LD_INT 2
 778: NEG
 779: PPUSH
 780: LD_INT 4
 782: NEG
 783: PPUSH
 784: CALL_OW 12
 788: PPUSH
 789: CALL_OW 380
// FSol1 := CreateHuman ;
 793: LD_ADDR_EXP 13
 797: PUSH
 798: CALL_OW 44
 802: ST_TO_ADDR
// end ; if not Frank then
 803: LD_EXP 1
 807: NOT
 808: IFFALSE 856
// Sol1 := UnitFilter ( otherG2 diff [ Lisa , Frank , JMM ] , [ f_sex , sex_male ] ) ;
 810: LD_ADDR_EXP 14
 814: PUSH
 815: LD_EXP 20
 819: PUSH
 820: LD_EXP 2
 824: PUSH
 825: LD_EXP 1
 829: PUSH
 830: LD_EXP 5
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: DIFF
 840: PPUSH
 841: LD_INT 26
 843: PUSH
 844: LD_INT 1
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PPUSH
 851: CALL_OW 72
 855: ST_TO_ADDR
// if Sol1 then
 856: LD_EXP 14
 860: IFFALSE 878
// Sol1 := Sol1 [ 1 ] else
 862: LD_ADDR_EXP 14
 866: PUSH
 867: LD_EXP 14
 871: PUSH
 872: LD_INT 1
 874: ARRAY
 875: ST_TO_ADDR
 876: GO 921
// begin uc_side := you ;
 878: LD_ADDR_OWVAR 20
 882: PUSH
 883: LD_EXP 16
 887: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , Rand ( - 2 , - 4 ) ) ;
 888: LD_INT 1
 890: PPUSH
 891: LD_INT 0
 893: PPUSH
 894: LD_INT 2
 896: NEG
 897: PPUSH
 898: LD_INT 4
 900: NEG
 901: PPUSH
 902: CALL_OW 12
 906: PPUSH
 907: CALL_OW 380
// Sol1 := CreateHuman ;
 911: LD_ADDR_EXP 14
 915: PUSH
 916: CALL_OW 44
 920: ST_TO_ADDR
// end ; if LoadVariable ( SikorskiLoc , 0 ) = 0 then
 921: LD_STRING SikorskiLoc
 923: PPUSH
 924: LD_INT 0
 926: PPUSH
 927: CALL_OW 30
 931: PUSH
 932: LD_INT 0
 934: EQUAL
 935: IFFALSE 947
// SikorskiDiedin8 := true else
 937: LD_ADDR_EXP 23
 941: PUSH
 942: LD_INT 1
 944: ST_TO_ADDR
 945: GO 955
// SikorskiDiedin8 := false ;
 947: LD_ADDR_EXP 23
 951: PUSH
 952: LD_INT 0
 954: ST_TO_ADDR
// PlaceUnitXYR ( JMM , 52 , 23 , 10 , false ) ;
 955: LD_EXP 5
 959: PPUSH
 960: LD_INT 52
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 10
 968: PPUSH
 969: LD_INT 0
 971: PPUSH
 972: CALL_OW 50
// depot := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 976: LD_ADDR_VAR 0 5
 980: PUSH
 981: LD_INT 30
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: PPUSH
 991: CALL_OW 69
 995: ST_TO_ADDR
// if depot then
 996: LD_VAR 0 5
1000: IFFALSE 1016
// depot := depot [ 1 ] ;
1002: LD_ADDR_VAR 0 5
1006: PUSH
1007: LD_VAR 0 5
1011: PUSH
1012: LD_INT 1
1014: ARRAY
1015: ST_TO_ADDR
// lidi := [ Lisa , Frank , Donaldson , Brown , Joan , Denis , Gladstone , FSol1 , Sol1 ] diff 0 ;
1016: LD_ADDR_VAR 0 8
1020: PUSH
1021: LD_EXP 2
1025: PUSH
1026: LD_EXP 1
1030: PUSH
1031: LD_EXP 9
1035: PUSH
1036: LD_EXP 10
1040: PUSH
1041: LD_EXP 3
1045: PUSH
1046: LD_EXP 6
1050: PUSH
1051: LD_EXP 11
1055: PUSH
1056: LD_EXP 13
1060: PUSH
1061: LD_EXP 14
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: PUSH
1077: LD_INT 0
1079: DIFF
1080: ST_TO_ADDR
// for i in lidi do
1081: LD_ADDR_VAR 0 2
1085: PUSH
1086: LD_VAR 0 8
1090: PUSH
1091: FOR_IN
1092: IFFALSE 1131
// begin PlaceUnitXYR ( i , GetX ( JMM ) , GetY ( JMM ) , 5 , false ) ;
1094: LD_VAR 0 2
1098: PPUSH
1099: LD_EXP 5
1103: PPUSH
1104: CALL_OW 250
1108: PPUSH
1109: LD_EXP 5
1113: PPUSH
1114: CALL_OW 251
1118: PPUSH
1119: LD_INT 5
1121: PPUSH
1122: LD_INT 0
1124: PPUSH
1125: CALL_OW 50
// end ;
1129: GO 1091
1131: POP
1132: POP
// bud := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_workshop ] , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_control_tower ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1133: LD_ADDR_VAR 0 3
1137: PUSH
1138: LD_INT 2
1140: PUSH
1141: LD_INT 30
1143: PUSH
1144: LD_INT 0
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 30
1153: PUSH
1154: LD_INT 1
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: PUSH
1161: LD_INT 30
1163: PUSH
1164: LD_INT 3
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: PUSH
1171: LD_INT 30
1173: PUSH
1174: LD_INT 2
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: PUSH
1181: LD_INT 30
1183: PUSH
1184: LD_INT 6
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 30
1193: PUSH
1194: LD_INT 7
1196: PUSH
1197: EMPTY
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 30
1203: PUSH
1204: LD_INT 8
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: PUSH
1211: LD_INT 30
1213: PUSH
1214: LD_INT 4
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: PUSH
1221: LD_INT 30
1223: PUSH
1224: LD_INT 5
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: PUSH
1231: LD_INT 30
1233: PUSH
1234: LD_INT 36
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 30
1243: PUSH
1244: LD_INT 32
1246: PUSH
1247: EMPTY
1248: LIST
1249: LIST
1250: PUSH
1251: LD_INT 30
1253: PUSH
1254: LD_INT 31
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PPUSH
1276: CALL_OW 69
1280: ST_TO_ADDR
// if CheckCharacterSet ( otherGamma2 ) then
1281: LD_STRING otherGamma2
1283: PPUSH
1284: CALL_OW 29
1288: IFFALSE 1303
// otherG2 := CreateCharacterSet ( otherGamma2 ) ;
1290: LD_ADDR_EXP 20
1294: PUSH
1295: LD_STRING otherGamma2
1297: PPUSH
1298: CALL_OW 31
1302: ST_TO_ADDR
// for i in otherG2 do
1303: LD_ADDR_VAR 0 2
1307: PUSH
1308: LD_EXP 20
1312: PUSH
1313: FOR_IN
1314: IFFALSE 1409
// begin b := bud [ Rand ( 1 , bud ) ] ;
1316: LD_ADDR_VAR 0 4
1320: PUSH
1321: LD_VAR 0 3
1325: PUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 3
1333: PPUSH
1334: CALL_OW 12
1338: ARRAY
1339: ST_TO_ADDR
// if rand ( 1 , 5 ) < 3 then
1340: LD_INT 1
1342: PPUSH
1343: LD_INT 5
1345: PPUSH
1346: CALL_OW 12
1350: PUSH
1351: LD_INT 3
1353: LESS
1354: IFFALSE 1372
// PlaceHumanInUnit ( i , b ) else
1356: LD_VAR 0 2
1360: PPUSH
1361: LD_VAR 0 4
1365: PPUSH
1366: CALL_OW 52
1370: GO 1407
// PlaceUnitXYR ( i , Getx ( b ) , gety ( b ) , 11 , false ) ;
1372: LD_VAR 0 2
1376: PPUSH
1377: LD_VAR 0 4
1381: PPUSH
1382: CALL_OW 250
1386: PPUSH
1387: LD_VAR 0 4
1391: PPUSH
1392: CALL_OW 251
1396: PPUSH
1397: LD_INT 11
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 50
// end ;
1407: GO 1313
1409: POP
1410: POP
// lidi := lidi + otherG2 ;
1411: LD_ADDR_VAR 0 8
1415: PUSH
1416: LD_VAR 0 8
1420: PUSH
1421: LD_EXP 20
1425: PLUS
1426: ST_TO_ADDR
// for i := lidi to 22 do
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: DOUBLE
1433: LD_VAR 0 8
1437: DEC
1438: ST_TO_ADDR
1439: LD_INT 22
1441: PUSH
1442: FOR_TO
1443: IFFALSE 1559
// begin PrepareHuman ( 0 , 0 , rand ( 4 , 6 ) ) ;
1445: LD_INT 0
1447: PPUSH
1448: LD_INT 0
1450: PPUSH
1451: LD_INT 4
1453: PPUSH
1454: LD_INT 6
1456: PPUSH
1457: CALL_OW 12
1461: PPUSH
1462: CALL_OW 380
// b := bud [ Rand ( 1 , bud ) ] ;
1466: LD_ADDR_VAR 0 4
1470: PUSH
1471: LD_VAR 0 3
1475: PUSH
1476: LD_INT 1
1478: PPUSH
1479: LD_VAR 0 3
1483: PPUSH
1484: CALL_OW 12
1488: ARRAY
1489: ST_TO_ADDR
// if rand ( 1 , 5 ) < 3 then
1490: LD_INT 1
1492: PPUSH
1493: LD_INT 5
1495: PPUSH
1496: CALL_OW 12
1500: PUSH
1501: LD_INT 3
1503: LESS
1504: IFFALSE 1522
// PlaceHumanInUnit ( CreateHuman , b ) else
1506: CALL_OW 44
1510: PPUSH
1511: LD_VAR 0 4
1515: PPUSH
1516: CALL_OW 52
1520: GO 1557
// PlaceUnitXYR ( CreateHuman , Getx ( b ) , gety ( b ) , 14 , false ) ;
1522: CALL_OW 44
1526: PPUSH
1527: LD_VAR 0 4
1531: PPUSH
1532: CALL_OW 250
1536: PPUSH
1537: LD_VAR 0 4
1541: PPUSH
1542: CALL_OW 251
1546: PPUSH
1547: LD_INT 14
1549: PPUSH
1550: LD_INT 0
1552: PPUSH
1553: CALL_OW 50
// end ;
1557: GO 1442
1559: POP
1560: POP
// for i := 1 to 6 do
1561: LD_ADDR_VAR 0 2
1565: PUSH
1566: DOUBLE
1567: LD_INT 1
1569: DEC
1570: ST_TO_ADDR
1571: LD_INT 6
1573: PUSH
1574: FOR_TO
1575: IFFALSE 1716
// begin vc_engine := engine_combustion ;
1577: LD_ADDR_OWVAR 39
1581: PUSH
1582: LD_INT 1
1584: ST_TO_ADDR
// vc_control := control_manual ;
1585: LD_ADDR_OWVAR 38
1589: PUSH
1590: LD_INT 1
1592: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_heavy_gun , us_double_gun , us_cargo_bay , us_machine_gun ] [ Rand ( 1 , 5 ) ] ;
1593: LD_ADDR_OWVAR 40
1597: PUSH
1598: LD_INT 4
1600: PUSH
1601: LD_INT 6
1603: PUSH
1604: LD_INT 5
1606: PUSH
1607: LD_INT 12
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: EMPTY
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: PUSH
1620: LD_INT 1
1622: PPUSH
1623: LD_INT 5
1625: PPUSH
1626: CALL_OW 12
1630: ARRAY
1631: ST_TO_ADDR
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
1632: LD_ADDR_OWVAR 37
1636: PUSH
1637: LD_INT 3
1639: PUSH
1640: LD_INT 2
1642: PUSH
1643: LD_INT 4
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 1
1653: PPUSH
1654: LD_INT 3
1656: PPUSH
1657: CALL_OW 12
1661: ARRAY
1662: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
1663: LD_ADDR_OWVAR 24
1667: PUSH
1668: LD_INT 0
1670: PPUSH
1671: LD_INT 5
1673: PPUSH
1674: CALL_OW 12
1678: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , Getx ( b ) , gety ( b ) , 14 , false ) ;
1679: CALL_OW 45
1683: PPUSH
1684: LD_VAR 0 4
1688: PPUSH
1689: CALL_OW 250
1693: PPUSH
1694: LD_VAR 0 4
1698: PPUSH
1699: CALL_OW 251
1703: PPUSH
1704: LD_INT 14
1706: PPUSH
1707: LD_INT 0
1709: PPUSH
1710: CALL_OW 50
// end ;
1714: GO 1574
1716: POP
1717: POP
// end ;
1718: LD_VAR 0 1
1722: RET
// starting begin you := 1 ;
1723: LD_ADDR_EXP 16
1727: PUSH
1728: LD_INT 1
1730: ST_TO_ADDR
// you2 := 4 ;
1731: LD_ADDR_EXP 17
1735: PUSH
1736: LD_INT 4
1738: ST_TO_ADDR
// arabians := 2 ;
1739: LD_ADDR_EXP 19
1743: PUSH
1744: LD_INT 2
1746: ST_TO_ADDR
// russians := 3 ;
1747: LD_ADDR_EXP 18
1751: PUSH
1752: LD_INT 3
1754: ST_TO_ADDR
// load_units_1 ;
1755: CALL 0 0 0
// Dialog1 ;
1759: CALL 1774 0 0
// ChangeMap ( %_cont , %_cont ) ;
1763: LD_STRING %_cont
1765: PPUSH
1766: LD_STRING %_cont
1768: PPUSH
1769: CALL_OW 340
// end ; end_of_file
1773: END
// export function Dialog1 ; begin
1774: LD_INT 0
1776: PPUSH
// InGameOn ;
1777: CALL_OW 8
// Wait ( 0 0$2 ) ;
1781: LD_INT 70
1783: PPUSH
1784: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
1788: LD_EXP 5
1792: PPUSH
1793: CALL_OW 87
// SayRadio ( Powell , D1-Pow-1 ) ;
1797: LD_EXP 4
1801: PPUSH
1802: LD_STRING D1-Pow-1
1804: PPUSH
1805: CALL_OW 94
// Say ( JMM , D1-JMM-1 ) ;
1809: LD_EXP 5
1813: PPUSH
1814: LD_STRING D1-JMM-1
1816: PPUSH
1817: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
1821: LD_EXP 4
1825: PPUSH
1826: LD_STRING D1-Pow-2
1828: PPUSH
1829: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
1833: LD_EXP 5
1837: PPUSH
1838: LD_STRING D1-JMM-2
1840: PPUSH
1841: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
1845: LD_EXP 4
1849: PPUSH
1850: LD_STRING D1-Pow-3
1852: PPUSH
1853: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
1857: LD_EXP 5
1861: PPUSH
1862: LD_STRING D1-JMM-3
1864: PPUSH
1865: CALL_OW 88
// SayRadio ( Powell , D1-Pow-4 ) ;
1869: LD_EXP 4
1873: PPUSH
1874: LD_STRING D1-Pow-4
1876: PPUSH
1877: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
1881: LD_EXP 5
1885: PPUSH
1886: LD_STRING D1-JMM-4
1888: PPUSH
1889: CALL_OW 88
// SayRadio ( Powell , D1-Pow-5 ) ;
1893: LD_EXP 4
1897: PPUSH
1898: LD_STRING D1-Pow-5
1900: PPUSH
1901: CALL_OW 94
// Say ( JMM , D1-JMM-5 ) ;
1905: LD_EXP 5
1909: PPUSH
1910: LD_STRING D1-JMM-5
1912: PPUSH
1913: CALL_OW 88
// SayRadio ( Powell , D1-Pow-6 ) ;
1917: LD_EXP 4
1921: PPUSH
1922: LD_STRING D1-Pow-6
1924: PPUSH
1925: CALL_OW 94
// if not SikorskiDiedin8 then
1929: LD_EXP 23
1933: NOT
1934: IFFALSE 1962
// begin SayRadio ( Powell , D1-Pow-6a ) ;
1936: LD_EXP 4
1940: PPUSH
1941: LD_STRING D1-Pow-6a
1943: PPUSH
1944: CALL_OW 94
// SayRadio ( Powell , D1-Pow-6b ) ;
1948: LD_EXP 4
1952: PPUSH
1953: LD_STRING D1-Pow-6b
1955: PPUSH
1956: CALL_OW 94
// end else
1960: GO 1986
// begin SayRadio ( Powell , D1-Pow-6c ) ;
1962: LD_EXP 4
1966: PPUSH
1967: LD_STRING D1-Pow-6c
1969: PPUSH
1970: CALL_OW 94
// SayRadio ( Powell , D1-Pow-6d ) ;
1974: LD_EXP 4
1978: PPUSH
1979: LD_STRING D1-Pow-6d
1981: PPUSH
1982: CALL_OW 94
// end ; Say ( JMM , D1-JMM-6 ) ;
1986: LD_EXP 5
1990: PPUSH
1991: LD_STRING D1-JMM-6
1993: PPUSH
1994: CALL_OW 88
// Say ( JMM , D1-JMM-6a ) ;
1998: LD_EXP 5
2002: PPUSH
2003: LD_STRING D1-JMM-6a
2005: PPUSH
2006: CALL_OW 88
// SayRadio ( Powell , D1-Pow-7 ) ;
2010: LD_EXP 4
2014: PPUSH
2015: LD_STRING D1-Pow-7
2017: PPUSH
2018: CALL_OW 94
// Say ( JMM , D1-JMM-7 ) ;
2022: LD_EXP 5
2026: PPUSH
2027: LD_STRING D1-JMM-7
2029: PPUSH
2030: CALL_OW 88
// SayRadio ( Powell , D1-Pow-8 ) ;
2034: LD_EXP 4
2038: PPUSH
2039: LD_STRING D1-Pow-8
2041: PPUSH
2042: CALL_OW 94
// Say ( JMM , D1-JMM-8 ) ;
2046: LD_EXP 5
2050: PPUSH
2051: LD_STRING D1-JMM-8
2053: PPUSH
2054: CALL_OW 88
// SayRadio ( Powell , D1-Pow-9 ) ;
2058: LD_EXP 4
2062: PPUSH
2063: LD_STRING D1-Pow-9
2065: PPUSH
2066: CALL_OW 94
// if Lisa then
2070: LD_EXP 2
2074: IFFALSE 2090
// Say ( Lisa , D1a-Lisa-1 ) else
2076: LD_EXP 2
2080: PPUSH
2081: LD_STRING D1a-Lisa-1
2083: PPUSH
2084: CALL_OW 88
2088: GO 2102
// Say ( FSol1 , D1a-FSol1-1 ) ;
2090: LD_EXP 13
2094: PPUSH
2095: LD_STRING D1a-FSol1-1
2097: PPUSH
2098: CALL_OW 88
// if Frank then
2102: LD_EXP 1
2106: IFFALSE 2122
// Say ( Frank , D1a-Frank-1 ) else
2108: LD_EXP 1
2112: PPUSH
2113: LD_STRING D1a-Frank-1
2115: PPUSH
2116: CALL_OW 88
2120: GO 2134
// Say ( Sol1 , D1a-Sol1-1 ) ;
2122: LD_EXP 14
2126: PPUSH
2127: LD_STRING D1a-Sol1-1
2129: PPUSH
2130: CALL_OW 88
// if Lisa then
2134: LD_EXP 2
2138: IFFALSE 2154
// Say ( Lisa , D1a-Lisa-2 ) else
2140: LD_EXP 2
2144: PPUSH
2145: LD_STRING D1a-Lisa-2
2147: PPUSH
2148: CALL_OW 88
2152: GO 2166
// Say ( FSol1 , D1a-FSol1-2 ) ;
2154: LD_EXP 13
2158: PPUSH
2159: LD_STRING D1a-FSol1-2
2161: PPUSH
2162: CALL_OW 88
// if Frank then
2166: LD_EXP 1
2170: IFFALSE 2186
// Say ( Frank , D1a-Frank-2 ) else
2172: LD_EXP 1
2176: PPUSH
2177: LD_STRING D1a-Frank-2
2179: PPUSH
2180: CALL_OW 88
2184: GO 2198
// Say ( Sol1 , D1a-Sol1-2 ) ;
2186: LD_EXP 14
2190: PPUSH
2191: LD_STRING D1a-Sol1-2
2193: PPUSH
2194: CALL_OW 88
// if Lisa then
2198: LD_EXP 2
2202: IFFALSE 2218
// Say ( Lisa , D1a-Lisa-3 ) else
2204: LD_EXP 2
2208: PPUSH
2209: LD_STRING D1a-Lisa-3
2211: PPUSH
2212: CALL_OW 88
2216: GO 2230
// Say ( FSol1 , D1a-FSol1-3 ) ;
2218: LD_EXP 13
2222: PPUSH
2223: LD_STRING D1a-FSol1-3
2225: PPUSH
2226: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
2230: LD_EXP 5
2234: PPUSH
2235: LD_STRING D1a-JMM-3
2237: PPUSH
2238: CALL_OW 88
// Dialog1b ;
2242: CALL 2277 0 0
// ComMoveXY ( JMM , 67 , 66 ) ;
2246: LD_EXP 5
2250: PPUSH
2251: LD_INT 67
2253: PPUSH
2254: LD_INT 66
2256: PPUSH
2257: CALL_OW 111
// wait ( 0 0$4 ) ;
2261: LD_INT 140
2263: PPUSH
2264: CALL_OW 67
// InGameOff ;
2268: CALL_OW 9
// end ;
2272: LD_VAR 0 1
2276: RET
// function Dialog1b ; var adepts , i , j , k ; begin
2277: LD_INT 0
2279: PPUSH
2280: PPUSH
2281: PPUSH
2282: PPUSH
2283: PPUSH
// adepts := [ ] union [ Lisa , Gladstone , Joan , Donaldson ] ;
2284: LD_ADDR_VAR 0 2
2288: PUSH
2289: EMPTY
2290: PUSH
2291: LD_EXP 2
2295: PUSH
2296: LD_EXP 11
2300: PUSH
2301: LD_EXP 3
2305: PUSH
2306: LD_EXP 9
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: LIST
2315: LIST
2316: UNION
2317: ST_TO_ADDR
// adepts := adepts diff 0 ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_INT 0
2330: DIFF
2331: ST_TO_ADDR
// if adepts then
2332: LD_VAR 0 2
2336: IFFALSE 2764
// begin i := Rand ( 1 , adepts ) ;
2338: LD_ADDR_VAR 0 3
2342: PUSH
2343: LD_INT 1
2345: PPUSH
2346: LD_VAR 0 2
2350: PPUSH
2351: CALL_OW 12
2355: ST_TO_ADDR
// case adepts [ i ] of Lisa :
2356: LD_VAR 0 2
2360: PUSH
2361: LD_VAR 0 3
2365: ARRAY
2366: PUSH
2367: LD_EXP 2
2371: DOUBLE
2372: EQUAL
2373: IFTRUE 2377
2375: GO 2392
2377: POP
// Say ( Lisa , D1b-Lisa-1 ) ; Gladstone :
2378: LD_EXP 2
2382: PPUSH
2383: LD_STRING D1b-Lisa-1
2385: PPUSH
2386: CALL_OW 88
2390: GO 2468
2392: LD_EXP 11
2396: DOUBLE
2397: EQUAL
2398: IFTRUE 2402
2400: GO 2417
2402: POP
// Say ( Gladstone , D1b-Glad-1 ) ; Joan :
2403: LD_EXP 11
2407: PPUSH
2408: LD_STRING D1b-Glad-1
2410: PPUSH
2411: CALL_OW 88
2415: GO 2468
2417: LD_EXP 3
2421: DOUBLE
2422: EQUAL
2423: IFTRUE 2427
2425: GO 2442
2427: POP
// Say ( Joan , D1b-Joan-1 ) ; Donaldson :
2428: LD_EXP 3
2432: PPUSH
2433: LD_STRING D1b-Joan-1
2435: PPUSH
2436: CALL_OW 88
2440: GO 2468
2442: LD_EXP 9
2446: DOUBLE
2447: EQUAL
2448: IFTRUE 2452
2450: GO 2467
2452: POP
// Say ( Donaldson , D1b-Don-1 ) ; end ;
2453: LD_EXP 9
2457: PPUSH
2458: LD_STRING D1b-Don-1
2460: PPUSH
2461: CALL_OW 88
2465: GO 2468
2467: POP
// j := Rand ( 1 , adepts ) ;
2468: LD_ADDR_VAR 0 4
2472: PUSH
2473: LD_INT 1
2475: PPUSH
2476: LD_VAR 0 2
2480: PPUSH
2481: CALL_OW 12
2485: ST_TO_ADDR
// if j <> i then
2486: LD_VAR 0 4
2490: PUSH
2491: LD_VAR 0 3
2495: NONEQUAL
2496: IFFALSE 2610
// case adepts [ j ] of Lisa :
2498: LD_VAR 0 2
2502: PUSH
2503: LD_VAR 0 4
2507: ARRAY
2508: PUSH
2509: LD_EXP 2
2513: DOUBLE
2514: EQUAL
2515: IFTRUE 2519
2517: GO 2534
2519: POP
// Say ( Lisa , D1b-Lisa-1 ) ; Gladstone :
2520: LD_EXP 2
2524: PPUSH
2525: LD_STRING D1b-Lisa-1
2527: PPUSH
2528: CALL_OW 88
2532: GO 2610
2534: LD_EXP 11
2538: DOUBLE
2539: EQUAL
2540: IFTRUE 2544
2542: GO 2559
2544: POP
// Say ( Gladstone , D1b-Glad-1 ) ; Joan :
2545: LD_EXP 11
2549: PPUSH
2550: LD_STRING D1b-Glad-1
2552: PPUSH
2553: CALL_OW 88
2557: GO 2610
2559: LD_EXP 3
2563: DOUBLE
2564: EQUAL
2565: IFTRUE 2569
2567: GO 2584
2569: POP
// Say ( Joan , D1b-Joan-1 ) ; Donaldson :
2570: LD_EXP 3
2574: PPUSH
2575: LD_STRING D1b-Joan-1
2577: PPUSH
2578: CALL_OW 88
2582: GO 2610
2584: LD_EXP 9
2588: DOUBLE
2589: EQUAL
2590: IFTRUE 2594
2592: GO 2609
2594: POP
// Say ( Donaldson , D1b-Don-1 ) ; end ;
2595: LD_EXP 9
2599: PPUSH
2600: LD_STRING D1b-Don-1
2602: PPUSH
2603: CALL_OW 88
2607: GO 2610
2609: POP
// k := Rand ( 1 , adepts ) ;
2610: LD_ADDR_VAR 0 5
2614: PUSH
2615: LD_INT 1
2617: PPUSH
2618: LD_VAR 0 2
2622: PPUSH
2623: CALL_OW 12
2627: ST_TO_ADDR
// if k <> j and k <> i then
2628: LD_VAR 0 5
2632: PUSH
2633: LD_VAR 0 4
2637: NONEQUAL
2638: PUSH
2639: LD_VAR 0 5
2643: PUSH
2644: LD_VAR 0 3
2648: NONEQUAL
2649: AND
2650: IFFALSE 2764
// case adepts [ k ] of Lisa :
2652: LD_VAR 0 2
2656: PUSH
2657: LD_VAR 0 5
2661: ARRAY
2662: PUSH
2663: LD_EXP 2
2667: DOUBLE
2668: EQUAL
2669: IFTRUE 2673
2671: GO 2688
2673: POP
// Say ( Lisa , D1b-Lisa-1 ) ; Gladstone :
2674: LD_EXP 2
2678: PPUSH
2679: LD_STRING D1b-Lisa-1
2681: PPUSH
2682: CALL_OW 88
2686: GO 2764
2688: LD_EXP 11
2692: DOUBLE
2693: EQUAL
2694: IFTRUE 2698
2696: GO 2713
2698: POP
// Say ( Gladstone , D1b-Glad-1 ) ; Joan :
2699: LD_EXP 11
2703: PPUSH
2704: LD_STRING D1b-Glad-1
2706: PPUSH
2707: CALL_OW 88
2711: GO 2764
2713: LD_EXP 3
2717: DOUBLE
2718: EQUAL
2719: IFTRUE 2723
2721: GO 2738
2723: POP
// Say ( Joan , D1b-Joan-1 ) ; Donaldson :
2724: LD_EXP 3
2728: PPUSH
2729: LD_STRING D1b-Joan-1
2731: PPUSH
2732: CALL_OW 88
2736: GO 2764
2738: LD_EXP 9
2742: DOUBLE
2743: EQUAL
2744: IFTRUE 2748
2746: GO 2763
2748: POP
// Say ( Donaldson , D1b-Don-1 ) ; end ;
2749: LD_EXP 9
2753: PPUSH
2754: LD_STRING D1b-Don-1
2756: PPUSH
2757: CALL_OW 88
2761: GO 2764
2763: POP
// end ; end ; end_of_file
2764: LD_VAR 0 1
2768: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
2769: LD_INT 0
2771: PPUSH
2772: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
2773: LD_ADDR_VAR 0 8
2777: PUSH
2778: LD_VAR 0 1
2782: PPUSH
2783: LD_VAR 0 3
2787: PPUSH
2788: LD_VAR 0 4
2792: PPUSH
2793: LD_VAR 0 5
2797: PPUSH
2798: LD_VAR 0 6
2802: PPUSH
2803: CALL 2849 0 5
2807: ST_TO_ADDR
// if kdo then
2808: LD_VAR 0 8
2812: IFFALSE 2836
// result := Say ( kdo , ident ) else
2814: LD_ADDR_VAR 0 7
2818: PUSH
2819: LD_VAR 0 8
2823: PPUSH
2824: LD_VAR 0 2
2828: PPUSH
2829: CALL_OW 88
2833: ST_TO_ADDR
2834: GO 2844
// result := false ;
2836: LD_ADDR_VAR 0 7
2840: PUSH
2841: LD_INT 0
2843: ST_TO_ADDR
// end ;
2844: LD_VAR 0 7
2848: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
2849: LD_INT 0
2851: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
2852: LD_ADDR_VAR 0 1
2856: PUSH
2857: LD_VAR 0 1
2861: PPUSH
2862: LD_INT 21
2864: PUSH
2865: LD_INT 1
2867: PUSH
2868: EMPTY
2869: LIST
2870: LIST
2871: PUSH
2872: LD_INT 22
2874: PUSH
2875: LD_VAR 0 2
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PUSH
2884: LD_INT 3
2886: PUSH
2887: LD_INT 23
2889: PUSH
2890: LD_INT 0
2892: PUSH
2893: EMPTY
2894: LIST
2895: LIST
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: LIST
2901: LIST
2902: PPUSH
2903: CALL_OW 72
2907: ST_TO_ADDR
// if sex <> 0 then
2908: LD_VAR 0 3
2912: PUSH
2913: LD_INT 0
2915: NONEQUAL
2916: IFFALSE 2945
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
2918: LD_ADDR_VAR 0 1
2922: PUSH
2923: LD_VAR 0 1
2927: PPUSH
2928: LD_INT 26
2930: PUSH
2931: LD_VAR 0 3
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PPUSH
2940: CALL_OW 72
2944: ST_TO_ADDR
// if Hclass <> 0 then
2945: LD_VAR 0 4
2949: PUSH
2950: LD_INT 0
2952: NONEQUAL
2953: IFFALSE 2982
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
2955: LD_ADDR_VAR 0 1
2959: PUSH
2960: LD_VAR 0 1
2964: PPUSH
2965: LD_INT 25
2967: PUSH
2968: LD_VAR 0 4
2972: PUSH
2973: EMPTY
2974: LIST
2975: LIST
2976: PPUSH
2977: CALL_OW 72
2981: ST_TO_ADDR
// if index <= 0 then
2982: LD_VAR 0 5
2986: PUSH
2987: LD_INT 0
2989: LESSEQUAL
2990: IFFALSE 3000
// index := 1 ;
2992: LD_ADDR_VAR 0 5
2996: PUSH
2997: LD_INT 1
2999: ST_TO_ADDR
// if lidi >= index then
3000: LD_VAR 0 1
3004: PUSH
3005: LD_VAR 0 5
3009: GREATEREQUAL
3010: IFFALSE 3030
// result := lidi [ index ] else
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: LD_VAR 0 1
3021: PUSH
3022: LD_VAR 0 5
3026: ARRAY
3027: ST_TO_ADDR
3028: GO 3038
// result := 0 ;
3030: LD_ADDR_VAR 0 6
3034: PUSH
3035: LD_INT 0
3037: ST_TO_ADDR
// end ; end_of_file
3038: LD_VAR 0 6
3042: RET
// on DestinationUnreachable ( un ) do begin if un = JMM then
3043: LD_VAR 0 1
3047: PUSH
3048: LD_EXP 5
3052: EQUAL
3053: IFFALSE 3086
// ComMoveXY ( JMM , Rand ( 47 , 89 ) , Rand ( 53 , 95 ) ) ;
3055: LD_EXP 5
3059: PPUSH
3060: LD_INT 47
3062: PPUSH
3063: LD_INT 89
3065: PPUSH
3066: CALL_OW 12
3070: PPUSH
3071: LD_INT 53
3073: PPUSH
3074: LD_INT 95
3076: PPUSH
3077: CALL_OW 12
3081: PPUSH
3082: CALL_OW 111
// end ;
3086: PPOPN 1
3088: END
