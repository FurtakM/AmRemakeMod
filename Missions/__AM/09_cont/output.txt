// export arabi_time ; export utocit ; export last_attack ; export testing ; export lev ; export rusaci_pred_koncem ; function f_testing ; begin
   0: LD_INT 0
   2: PPUSH
// utocit := true ;
   3: LD_ADDR_EXP 2
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// last_attack := true ;
  11: LD_ADDR_EXP 3
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabi_time := 0 ;
  19: LD_ADDR_EXP 1
  23: PUSH
  24: LD_INT 0
  26: ST_TO_ADDR
// testing := false ;
  27: LD_ADDR_EXP 4
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// timer := 3 3$0 ;
  35: LD_ADDR_EXP 62
  39: PUSH
  40: LD_INT 6300
  42: ST_TO_ADDR
// rusaci_pred_koncem := 0 0$20 ;
  43: LD_ADDR_EXP 6
  47: PUSH
  48: LD_INT 700
  50: ST_TO_ADDR
// if not utocit or not last_attack or arabi_time <> 0 then
  51: LD_EXP 2
  55: NOT
  56: PUSH
  57: LD_EXP 3
  61: NOT
  62: OR
  63: PUSH
  64: LD_EXP 1
  68: PUSH
  69: LD_INT 0
  71: NONEQUAL
  72: OR
  73: IFFALSE 90
// begin Msg ( testing version ) ;
  75: LD_STRING testing version
  77: PPUSH
  78: CALL_OW 100
// testing := true ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_INT 1
  89: ST_TO_ADDR
// end ; end ;
  90: LD_VAR 0 1
  94: RET
// every 2 2$0 do
  95: GO 97
  97: DISABLE
// begin end ;
  98: END
// export map_size_x , map_size_y ; export mhmg , mgg , mg , mrl , hgg , hrl , hhg ; export Powell , JMM , Bobby , Cyrus , Donaldson , Brown , Gary ; export FSol1 , Sol1 , Sci1 ; export Eng1 , Eng2 , Eng3 , Eng4 , CarE1 ; export Mec1 , Mec2 , Mec3 , Car1 , Car2 , Car3 ; export Aqr1 , Aqr2 ; export Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 , arabi ; export you , you2 , russians , arabians ; export otherG2 , other_survivors ; export SikorskiDiedIn8 ; export ByloSiberitu ; export EndSiberit ; export PoskytnouInformace ; export NastvalPowella ; export lidi , lidi_base , lidi_eng ; export neco_rikaji ; export timer , TimerEnable ; export counter_time ; export dialog2byl ; export KolikMaBytSiberitu ; export rudepot1 , rumine1 , depot1 ; function load_units_2 ; var kolik , m , n , i , all , k , placing , o ; begin
  99: LD_INT 0
 101: PPUSH
 102: PPUSH
 103: PPUSH
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
// InitUc ;
 110: CALL_OW 18
// InitHc ;
 114: CALL_OW 19
// InitVc ;
 118: CALL_OW 20
// kolik := 0 ;
 122: LD_ADDR_VAR 0 2
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// Donaldson := 0 ;
 130: LD_ADDR_EXP 20
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// Brown := 0 ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// Bobby := 0 ;
 146: LD_ADDR_EXP 18
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// Cyrus := 0 ;
 154: LD_ADDR_EXP 19
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// uc_side := you ;
 162: LD_ADDR_OWVAR 20
 166: PUSH
 167: LD_EXP 47
 171: ST_TO_ADDR
// uc_nation := nation_american ;
 172: LD_ADDR_OWVAR 21
 176: PUSH
 177: LD_INT 1
 179: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_STRING JMM
 187: PPUSH
 188: CALL_OW 34
 192: ST_TO_ADDR
// SetClass ( JMM , class_soldier ) ;
 193: LD_EXP 17
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 336
// Powell := NewCharacter ( Powell ) ;
 205: LD_ADDR_EXP 16
 209: PUSH
 210: LD_STRING Powell
 212: PPUSH
 213: CALL_OW 25
 217: ST_TO_ADDR
// uc_side := you2 ;
 218: LD_ADDR_OWVAR 20
 222: PUSH
 223: LD_EXP 48
 227: ST_TO_ADDR
// uc_nation := nation_american ;
 228: LD_ADDR_OWVAR 21
 232: PUSH
 233: LD_INT 1
 235: ST_TO_ADDR
// all := [ ] ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: EMPTY
 242: ST_TO_ADDR
// Gary := NewCharacter ( Gary ) ;
 243: LD_ADDR_EXP 22
 247: PUSH
 248: LD_STRING Gary
 250: PPUSH
 251: CALL_OW 25
 255: ST_TO_ADDR
// all := all ^ [ Gary ] ;
 256: LD_ADDR_VAR 0 6
 260: PUSH
 261: LD_VAR 0 6
 265: PUSH
 266: LD_EXP 22
 270: PUSH
 271: EMPTY
 272: LIST
 273: ADD
 274: ST_TO_ADDR
// Cyrus := 0 ;
 275: LD_ADDR_EXP 19
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 283: LD_STRING Cyrus
 285: PPUSH
 286: CALL_OW 29
 290: IFFALSE 366
// if LoadVariable ( CyrusLoc , 1 ) = 1 then
 292: LD_STRING CyrusLoc
 294: PPUSH
 295: LD_INT 1
 297: PPUSH
 298: CALL_OW 30
 302: PUSH
 303: LD_INT 1
 305: EQUAL
 306: IFFALSE 366
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 308: LD_ADDR_EXP 19
 312: PUSH
 313: LD_STRING Cyrus
 315: PPUSH
 316: CALL_OW 34
 320: ST_TO_ADDR
// SetClass ( Cyrus , class_soldier ) ;
 321: LD_EXP 19
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 336
// all := all ^ [ Cyrus ] ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_VAR 0 6
 342: PUSH
 343: LD_EXP 19
 347: PUSH
 348: EMPTY
 349: LIST
 350: ADD
 351: ST_TO_ADDR
// kolik := kolik + 1 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 1
 364: PLUS
 365: ST_TO_ADDR
// end ; Bobby := 0 ;
 366: LD_ADDR_EXP 18
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 374: LD_STRING Bobby
 376: PPUSH
 377: CALL_OW 29
 381: IFFALSE 457
// if LoadVariable ( BobbyLoc , 1 ) = 1 then
 383: LD_STRING BobbyLoc
 385: PPUSH
 386: LD_INT 1
 388: PPUSH
 389: CALL_OW 30
 393: PUSH
 394: LD_INT 1
 396: EQUAL
 397: IFFALSE 457
// begin Bobby := CreateCharacter ( Bobby ) ;
 399: LD_ADDR_EXP 18
 403: PUSH
 404: LD_STRING Bobby
 406: PPUSH
 407: CALL_OW 34
 411: ST_TO_ADDR
// SetClass ( Bobby , class_soldier ) ;
 412: LD_EXP 18
 416: PPUSH
 417: LD_INT 1
 419: PPUSH
 420: CALL_OW 336
// all := all ^ [ Bobby ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 6
 433: PUSH
 434: LD_EXP 18
 438: PUSH
 439: EMPTY
 440: LIST
 441: ADD
 442: ST_TO_ADDR
// kolik := kolik + 1 ;
 443: LD_ADDR_VAR 0 2
 447: PUSH
 448: LD_VAR 0 2
 452: PUSH
 453: LD_INT 1
 455: PLUS
 456: ST_TO_ADDR
// end ; Donaldson := 0 ;
 457: LD_ADDR_EXP 20
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 465: LD_STRING Donaldson
 467: PPUSH
 468: CALL_OW 29
 472: IFFALSE 536
// if LoadVariable ( DonaldsonLoc , 0 ) = 1 then
 474: LD_STRING DonaldsonLoc
 476: PPUSH
 477: LD_INT 0
 479: PPUSH
 480: CALL_OW 30
 484: PUSH
 485: LD_INT 1
 487: EQUAL
 488: IFFALSE 536
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 490: LD_ADDR_EXP 20
 494: PUSH
 495: LD_STRING Donaldson
 497: PPUSH
 498: CALL_OW 34
 502: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 503: LD_ADDR_VAR 0 6
 507: PUSH
 508: LD_VAR 0 6
 512: PUSH
 513: LD_EXP 20
 517: PUSH
 518: EMPTY
 519: LIST
 520: ADD
 521: ST_TO_ADDR
// kolik := kolik + 1 ;
 522: LD_ADDR_VAR 0 2
 526: PUSH
 527: LD_VAR 0 2
 531: PUSH
 532: LD_INT 1
 534: PLUS
 535: ST_TO_ADDR
// end ; Brown := 0 ;
 536: LD_ADDR_EXP 21
 540: PUSH
 541: LD_INT 0
 543: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 544: LD_STRING Brown
 546: PPUSH
 547: CALL_OW 29
 551: IFFALSE 625
// if kolik < 3 and LoadVariable ( BrownLoc , 0 ) = 1 then
 553: LD_VAR 0 2
 557: PUSH
 558: LD_INT 3
 560: LESS
 561: PUSH
 562: LD_STRING BrownLoc
 564: PPUSH
 565: LD_INT 0
 567: PPUSH
 568: CALL_OW 30
 572: PUSH
 573: LD_INT 1
 575: EQUAL
 576: AND
 577: IFFALSE 625
// begin Brown := CreateCharacter ( Brown ) ;
 579: LD_ADDR_EXP 21
 583: PUSH
 584: LD_STRING Brown
 586: PPUSH
 587: CALL_OW 34
 591: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 592: LD_ADDR_VAR 0 6
 596: PUSH
 597: LD_VAR 0 6
 601: PUSH
 602: LD_EXP 21
 606: PUSH
 607: EMPTY
 608: LIST
 609: ADD
 610: ST_TO_ADDR
// kolik := kolik + 1 ;
 611: LD_ADDR_VAR 0 2
 615: PUSH
 616: LD_VAR 0 2
 620: PUSH
 621: LD_INT 1
 623: PLUS
 624: ST_TO_ADDR
// end ; neco_rikaji := [ JMM , Gary , Cyrus , Bobby ] diff 0 ;
 625: LD_ADDR_EXP 61
 629: PUSH
 630: LD_EXP 17
 634: PUSH
 635: LD_EXP 22
 639: PUSH
 640: LD_EXP 19
 644: PUSH
 645: LD_EXP 18
 649: PUSH
 650: EMPTY
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: PUSH
 656: LD_INT 0
 658: DIFF
 659: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 660: LD_STRING other_survivors
 662: PPUSH
 663: CALL_OW 28
 667: IFFALSE 682
// other_survivors := CreateCharacterSet ( other_survivors ) ;
 669: LD_ADDR_EXP 52
 673: PUSH
 674: LD_STRING other_survivors
 676: PPUSH
 677: CALL_OW 31
 681: ST_TO_ADDR
// for i := ( all + 0 ) to 6 do
 682: LD_ADDR_VAR 0 5
 686: PUSH
 687: DOUBLE
 688: LD_VAR 0 6
 692: PUSH
 693: LD_INT 0
 695: PLUS
 696: DEC
 697: ST_TO_ADDR
 698: LD_INT 6
 700: PUSH
 701: FOR_TO
 702: IFFALSE 752
// begin if other_survivors then
 704: LD_EXP 52
 708: IFFALSE 750
// begin all := all ^ other_survivors [ 1 ] ;
 710: LD_ADDR_VAR 0 6
 714: PUSH
 715: LD_VAR 0 6
 719: PUSH
 720: LD_EXP 52
 724: PUSH
 725: LD_INT 1
 727: ARRAY
 728: ADD
 729: ST_TO_ADDR
// other_survivors := other_survivors diff other_survivors [ 1 ] ;
 730: LD_ADDR_EXP 52
 734: PUSH
 735: LD_EXP 52
 739: PUSH
 740: LD_EXP 52
 744: PUSH
 745: LD_INT 1
 747: ARRAY
 748: DIFF
 749: ST_TO_ADDR
// end ; end ;
 750: GO 701
 752: POP
 753: POP
// for i := ( all + 0 ) to 6 do
 754: LD_ADDR_VAR 0 5
 758: PUSH
 759: DOUBLE
 760: LD_VAR 0 6
 764: PUSH
 765: LD_INT 0
 767: PLUS
 768: DEC
 769: ST_TO_ADDR
 770: LD_INT 6
 772: PUSH
 773: FOR_TO
 774: IFFALSE 804
// begin PrepareSoldier ( 0 , 5 ) ;
 776: LD_INT 0
 778: PPUSH
 779: LD_INT 5
 781: PPUSH
 782: CALL_OW 381
// all := all ^ CreateHuman ;
 786: LD_ADDR_VAR 0 6
 790: PUSH
 791: LD_VAR 0 6
 795: PUSH
 796: CALL_OW 44
 800: ADD
 801: ST_TO_ADDR
// end ;
 802: GO 773
 804: POP
 805: POP
// PrepareScientist ( sex_male , 5 ) ;
 806: LD_INT 1
 808: PPUSH
 809: LD_INT 5
 811: PPUSH
 812: CALL_OW 384
// Sci1 := CreateHuman ;
 816: LD_ADDR_EXP 25
 820: PUSH
 821: CALL_OW 44
 825: ST_TO_ADDR
// all := all ^ Sci1 ;
 826: LD_ADDR_VAR 0 6
 830: PUSH
 831: LD_VAR 0 6
 835: PUSH
 836: LD_EXP 25
 840: ADD
 841: ST_TO_ADDR
// placing := [ [ 93 , 87 ] , [ 96 , 95 ] , [ 90 , 94 ] ] ;
 842: LD_ADDR_VAR 0 8
 846: PUSH
 847: LD_INT 93
 849: PUSH
 850: LD_INT 87
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: PUSH
 857: LD_INT 96
 859: PUSH
 860: LD_INT 95
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PUSH
 867: LD_INT 90
 869: PUSH
 870: LD_INT 94
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: ST_TO_ADDR
// for k in all do
 882: LD_ADDR_VAR 0 7
 886: PUSH
 887: LD_VAR 0 6
 891: PUSH
 892: FOR_IN
 893: IFFALSE 996
// begin o := Rand ( 1 , 3 ) ;
 895: LD_ADDR_VAR 0 9
 899: PUSH
 900: LD_INT 1
 902: PPUSH
 903: LD_INT 3
 905: PPUSH
 906: CALL_OW 12
 910: ST_TO_ADDR
// if GetClass ( k ) = classtype_scientist then
 911: LD_VAR 0 7
 915: PPUSH
 916: CALL_OW 257
 920: PUSH
 921: LD_INT 4
 923: EQUAL
 924: IFFALSE 949
// PlaceUnitXYR ( k , 89 , 84 , 3 , false ) else
 926: LD_VAR 0 7
 930: PPUSH
 931: LD_INT 89
 933: PPUSH
 934: LD_INT 84
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 0
 942: PPUSH
 943: CALL_OW 50
 947: GO 994
// PlaceUnitXYR ( k , placing [ o ] [ 1 ] , placing [ o ] [ 2 ] , 5 , false ) ;
 949: LD_VAR 0 7
 953: PPUSH
 954: LD_VAR 0 8
 958: PUSH
 959: LD_VAR 0 9
 963: ARRAY
 964: PUSH
 965: LD_INT 1
 967: ARRAY
 968: PPUSH
 969: LD_VAR 0 8
 973: PUSH
 974: LD_VAR 0 9
 978: ARRAY
 979: PUSH
 980: LD_INT 2
 982: ARRAY
 983: PPUSH
 984: LD_INT 5
 986: PPUSH
 987: LD_INT 0
 989: PPUSH
 990: CALL_OW 50
// end ;
 994: GO 892
 996: POP
 997: POP
// full_forts ( [ fort1 , fort2 , fort3 ] , UnitFilter ( all , [ [ f_class , class_soldier ] ] ) ) ;
 998: LD_INT 21
1000: PUSH
1001: LD_INT 28
1003: PUSH
1004: LD_INT 86
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: LIST
1011: PPUSH
1012: LD_VAR 0 6
1016: PPUSH
1017: LD_INT 25
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL_OW 72
1034: PPUSH
1035: CALL 12467 0 2
// lidi_base := all ;
1039: LD_ADDR_EXP 59
1043: PUSH
1044: LD_VAR 0 6
1048: ST_TO_ADDR
// lidi := lidi union lidi_base ;
1049: LD_ADDR_EXP 58
1053: PUSH
1054: LD_EXP 58
1058: PUSH
1059: LD_EXP 59
1063: UNION
1064: ST_TO_ADDR
// lidi := lidi ^ JMM ;
1065: LD_ADDR_EXP 58
1069: PUSH
1070: LD_EXP 58
1074: PUSH
1075: LD_EXP 17
1079: ADD
1080: ST_TO_ADDR
// DeleteVariable ( Delta ) ;
1081: LD_STRING Delta
1083: PPUSH
1084: CALL_OW 41
// DeleteCharacters ( Sikorski ) ;
1088: LD_STRING Sikorski
1090: PPUSH
1091: CALL_OW 40
// end ;
1095: LD_VAR 0 1
1099: RET
// function SetDifficulty ; begin
1100: LD_INT 0
1102: PPUSH
// KolikMaBytSiberitu := 60 ;
1103: LD_ADDR_EXP 66
1107: PUSH
1108: LD_INT 60
1110: ST_TO_ADDR
// EndSiberit := [ 150 , 200 , 250 ] [ difficulty ] ;
1111: LD_ADDR_EXP 55
1115: PUSH
1116: LD_INT 150
1118: PUSH
1119: LD_INT 200
1121: PUSH
1122: LD_INT 250
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: LIST
1129: PUSH
1130: LD_OWVAR 67
1134: ARRAY
1135: ST_TO_ADDR
// lev := [ 3 , 5 , 7 ] ;
1136: LD_ADDR_EXP 5
1140: PUSH
1141: LD_INT 3
1143: PUSH
1144: LD_INT 5
1146: PUSH
1147: LD_INT 7
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: ST_TO_ADDR
// end ;
1155: LD_VAR 0 1
1159: RET
// function prepare_your_units ; var i , j ; begin
1160: LD_INT 0
1162: PPUSH
1163: PPUSH
1164: PPUSH
// InitUc ;
1165: CALL_OW 18
// InitHc ;
1169: CALL_OW 19
// uc_side := you2 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_EXP 48
1182: ST_TO_ADDR
// uc_nation := nation_american ;
1183: LD_ADDR_OWVAR 21
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1191: LD_INT 0
1193: PPUSH
1194: LD_INT 4
1196: PPUSH
1197: CALL_OW 382
// Eng1 := CreateHuman ;
1201: LD_ADDR_EXP 26
1205: PUSH
1206: CALL_OW 44
1210: ST_TO_ADDR
// PrepareEngineer ( 0 , 5 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 5
1216: PPUSH
1217: CALL_OW 382
// Eng2 := CreateHuman ;
1221: LD_ADDR_EXP 27
1225: PUSH
1226: CALL_OW 44
1230: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 4
1236: PPUSH
1237: CALL_OW 382
// Eng3 := CreateHuman ;
1241: LD_ADDR_EXP 28
1245: PUSH
1246: CALL_OW 44
1250: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1251: LD_INT 0
1253: PPUSH
1254: LD_INT 4
1256: PPUSH
1257: CALL_OW 382
// Eng4 := CreateHuman ;
1261: LD_ADDR_EXP 29
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1271: LD_ADDR_OWVAR 37
1275: PUSH
1276: LD_INT 2
1278: ST_TO_ADDR
// vc_control := control_manual ;
1279: LD_ADDR_OWVAR 38
1283: PUSH
1284: LD_INT 1
1286: ST_TO_ADDR
// vc_engine := engine_solar ;
1287: LD_ADDR_OWVAR 39
1291: PUSH
1292: LD_INT 2
1294: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1295: LD_ADDR_OWVAR 40
1299: PUSH
1300: LD_INT 12
1302: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1303: LD_ADDR_OWVAR 41
1307: PUSH
1308: LD_INT 60
1310: ST_TO_ADDR
// CarE1 := CreateVehicle ;
1311: LD_ADDR_EXP 30
1315: PUSH
1316: CALL_OW 45
1320: ST_TO_ADDR
// lidi_eng := [ Eng1 , Eng2 , Eng3 ] ;
1321: LD_ADDR_EXP 60
1325: PUSH
1326: LD_EXP 26
1330: PUSH
1331: LD_EXP 27
1335: PUSH
1336: LD_EXP 28
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: ST_TO_ADDR
// lidi := lidi union lidi_eng ;
1346: LD_ADDR_EXP 58
1350: PUSH
1351: LD_EXP 58
1355: PUSH
1356: LD_EXP 60
1360: UNION
1361: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1362: LD_INT 0
1364: PPUSH
1365: LD_INT 4
1367: PPUSH
1368: CALL_OW 383
// Mec1 := CreateHuman ;
1372: LD_ADDR_EXP 31
1376: PUSH
1377: CALL_OW 44
1381: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1382: LD_INT 0
1384: PPUSH
1385: LD_INT 4
1387: PPUSH
1388: CALL_OW 383
// Mec2 := CreateHuman ;
1392: LD_ADDR_EXP 32
1396: PUSH
1397: CALL_OW 44
1401: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1402: LD_INT 0
1404: PPUSH
1405: LD_INT 4
1407: PPUSH
1408: CALL_OW 383
// Mec3 := CreateHuman ;
1412: LD_ADDR_EXP 33
1416: PUSH
1417: CALL_OW 44
1421: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1422: LD_ADDR_OWVAR 37
1426: PUSH
1427: LD_INT 2
1429: ST_TO_ADDR
// vc_control := control_manual ;
1430: LD_ADDR_OWVAR 38
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// vc_engine := engine_solar ;
1438: LD_ADDR_OWVAR 39
1442: PUSH
1443: LD_INT 2
1445: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1446: LD_ADDR_OWVAR 40
1450: PUSH
1451: LD_INT 12
1453: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1454: LD_ADDR_OWVAR 41
1458: PUSH
1459: LD_INT 60
1461: ST_TO_ADDR
// Car1 := CreateVehicle ;
1462: LD_ADDR_EXP 34
1466: PUSH
1467: CALL_OW 45
1471: ST_TO_ADDR
// Car2 := CreateVehicle ;
1472: LD_ADDR_EXP 35
1476: PUSH
1477: CALL_OW 45
1481: ST_TO_ADDR
// Car3 := CreateVehicle ;
1482: LD_ADDR_EXP 36
1486: PUSH
1487: CALL_OW 45
1491: ST_TO_ADDR
// end ;
1492: LD_VAR 0 1
1496: RET
// function prepare_arabians_units ; begin
1497: LD_INT 0
1499: PPUSH
// InitUc ;
1500: CALL_OW 18
// InitHc ;
1504: CALL_OW 19
// uc_side := arabians ;
1508: LD_ADDR_OWVAR 20
1512: PUSH
1513: LD_EXP 50
1517: ST_TO_ADDR
// uc_nation := nation_arabian ;
1518: LD_ADDR_OWVAR 21
1522: PUSH
1523: LD_INT 2
1525: ST_TO_ADDR
// PrepareSoldier ( sex_male , 4 ) ;
1526: LD_INT 1
1528: PPUSH
1529: LD_INT 4
1531: PPUSH
1532: CALL_OW 381
// Ara1 := CreateHuman ;
1536: LD_ADDR_EXP 39
1540: PUSH
1541: CALL_OW 44
1545: ST_TO_ADDR
// hc_name := Louis Gali ;
1546: LD_ADDR_OWVAR 26
1550: PUSH
1551: LD_STRING Louis Gali
1553: ST_TO_ADDR
// PrepareEngineer ( sex_male , 5 ) ;
1554: LD_INT 1
1556: PPUSH
1557: LD_INT 5
1559: PPUSH
1560: CALL_OW 382
// Ara2 := CreateHuman ;
1564: LD_ADDR_EXP 40
1568: PUSH
1569: CALL_OW 44
1573: ST_TO_ADDR
// InitHc ;
1574: CALL_OW 19
// uc_side := arabians ;
1578: LD_ADDR_OWVAR 20
1582: PUSH
1583: LD_EXP 50
1587: ST_TO_ADDR
// uc_nation := nation_arabian ;
1588: LD_ADDR_OWVAR 21
1592: PUSH
1593: LD_INT 2
1595: ST_TO_ADDR
// PrepareSoldier ( sex_female , 4 ) ;
1596: LD_INT 2
1598: PPUSH
1599: LD_INT 4
1601: PPUSH
1602: CALL_OW 381
// Ara3 := CreateHuman ;
1606: LD_ADDR_EXP 41
1610: PUSH
1611: CALL_OW 44
1615: ST_TO_ADDR
// PrepareMechanic ( sex_male , 5 ) ;
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 5
1621: PPUSH
1622: CALL_OW 383
// Ara4 := CreateHuman ;
1626: LD_ADDR_EXP 42
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PrepareMechanic ( sex_male , 4 ) ;
1636: LD_INT 1
1638: PPUSH
1639: LD_INT 4
1641: PPUSH
1642: CALL_OW 383
// Ara5 := CreateHuman ;
1646: LD_ADDR_EXP 43
1650: PUSH
1651: CALL_OW 44
1655: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1656: LD_ADDR_OWVAR 37
1660: PUSH
1661: LD_INT 14
1663: ST_TO_ADDR
// vc_control := control_manual ;
1664: LD_ADDR_OWVAR 38
1668: PUSH
1669: LD_INT 1
1671: ST_TO_ADDR
// vc_engine := engine_combustion ;
1672: LD_ADDR_OWVAR 39
1676: PUSH
1677: LD_INT 1
1679: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
1680: LD_ADDR_OWVAR 40
1684: PUSH
1685: LD_INT 26
1687: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1688: LD_ADDR_OWVAR 41
1692: PUSH
1693: LD_INT 9
1695: ST_TO_ADDR
// AraCar1 := CreateVehicle ;
1696: LD_ADDR_EXP 44
1700: PUSH
1701: CALL_OW 45
1705: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1706: LD_ADDR_OWVAR 37
1710: PUSH
1711: LD_INT 14
1713: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
1714: LD_ADDR_OWVAR 40
1718: PUSH
1719: LD_INT 32
1721: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1722: LD_ADDR_OWVAR 41
1726: PUSH
1727: LD_INT 9
1729: ST_TO_ADDR
// AraCar2 := CreateVehicle ;
1730: LD_ADDR_EXP 45
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// arabi := [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] ;
1740: LD_ADDR_EXP 46
1744: PUSH
1745: LD_EXP 39
1749: PUSH
1750: LD_EXP 40
1754: PUSH
1755: LD_EXP 41
1759: PUSH
1760: LD_EXP 42
1764: PUSH
1765: LD_EXP 43
1769: PUSH
1770: LD_EXP 44
1774: PUSH
1775: LD_EXP 45
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: ST_TO_ADDR
// PlaceHumanInUnit ( Ara4 , AraCar1 ) ;
1789: LD_EXP 42
1793: PPUSH
1794: LD_EXP 44
1798: PPUSH
1799: CALL_OW 52
// PlaceHumanInUnit ( Ara5 , AraCar2 ) ;
1803: LD_EXP 43
1807: PPUSH
1808: LD_EXP 45
1812: PPUSH
1813: CALL_OW 52
// end ;
1817: LD_VAR 0 1
1821: RET
// function prepare_russians_units ; begin
1822: LD_INT 0
1824: PPUSH
// end ;
1825: LD_VAR 0 1
1829: RET
// starting begin f_testing ;
1830: CALL 0 0 0
// depot1 := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1834: LD_ADDR_EXP 69
1838: PUSH
1839: LD_INT 23
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 30
1851: PUSH
1852: LD_INT 0
1854: PUSH
1855: EMPTY
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: PPUSH
1863: CALL_OW 69
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: ST_TO_ADDR
// rudepot1 := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1872: LD_ADDR_EXP 67
1876: PUSH
1877: LD_INT 23
1879: PUSH
1880: LD_INT 3
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: PUSH
1887: LD_INT 30
1889: PUSH
1890: LD_INT 0
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: PPUSH
1901: CALL_OW 69
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: ST_TO_ADDR
// SetBName ( depot1 , terminal ) ;
1910: LD_EXP 69
1914: PPUSH
1915: LD_STRING terminal
1917: PPUSH
1918: CALL_OW 500
// map_size_x := 70 ;
1922: LD_ADDR_EXP 7
1926: PUSH
1927: LD_INT 70
1929: ST_TO_ADDR
// map_size_y := 140 ;
1930: LD_ADDR_EXP 8
1934: PUSH
1935: LD_INT 140
1937: ST_TO_ADDR
// lidi := [ ] ;
1938: LD_ADDR_EXP 58
1942: PUSH
1943: EMPTY
1944: ST_TO_ADDR
// lidi_base := [ ] ;
1945: LD_ADDR_EXP 59
1949: PUSH
1950: EMPTY
1951: ST_TO_ADDR
// lidi_eng := [ ] ;
1952: LD_ADDR_EXP 60
1956: PUSH
1957: EMPTY
1958: ST_TO_ADDR
// neco_rikaji := [ ] ;
1959: LD_ADDR_EXP 61
1963: PUSH
1964: EMPTY
1965: ST_TO_ADDR
// counter_time := 0 ;
1966: LD_ADDR_EXP 64
1970: PUSH
1971: LD_INT 0
1973: ST_TO_ADDR
// SetDifficulty ;
1974: CALL 1100 0 0
// mhmg := 1 ;
1978: LD_ADDR_EXP 9
1982: PUSH
1983: LD_INT 1
1985: ST_TO_ADDR
// mgg := 2 ;
1986: LD_ADDR_EXP 10
1990: PUSH
1991: LD_INT 2
1993: ST_TO_ADDR
// mg := 3 ;
1994: LD_ADDR_EXP 11
1998: PUSH
1999: LD_INT 3
2001: ST_TO_ADDR
// mrl := 4 ;
2002: LD_ADDR_EXP 12
2006: PUSH
2007: LD_INT 4
2009: ST_TO_ADDR
// hgg := 5 ;
2010: LD_ADDR_EXP 13
2014: PUSH
2015: LD_INT 5
2017: ST_TO_ADDR
// hrl := 6 ;
2018: LD_ADDR_EXP 14
2022: PUSH
2023: LD_INT 6
2025: ST_TO_ADDR
// hhg := 7 ;
2026: LD_ADDR_EXP 15
2030: PUSH
2031: LD_INT 7
2033: ST_TO_ADDR
// you := 1 ;
2034: LD_ADDR_EXP 47
2038: PUSH
2039: LD_INT 1
2041: ST_TO_ADDR
// you2 := 4 ;
2042: LD_ADDR_EXP 48
2046: PUSH
2047: LD_INT 4
2049: ST_TO_ADDR
// arabians := 2 ;
2050: LD_ADDR_EXP 50
2054: PUSH
2055: LD_INT 2
2057: ST_TO_ADDR
// russians := 3 ;
2058: LD_ADDR_EXP 49
2062: PUSH
2063: LD_INT 3
2065: ST_TO_ADDR
// SetBName ( RuDepot , ovsyenko ) ;
2066: LD_INT 58
2068: PPUSH
2069: LD_STRING ovsyenko
2071: PPUSH
2072: CALL_OW 500
// prepare_your_units ;
2076: CALL 1160 0 0
// prepare_arabians_units ;
2080: CALL 1497 0 0
// prepare_russians_units ;
2084: CALL 1822 0 0
// load_units_2 ;
2088: CALL 99 0 0
// Dialog2 ;
2092: CALL 2900 0 0
// end ;
2096: END
// export function Save ; var sibu ; begin
2097: LD_INT 0
2099: PPUSH
2100: PPUSH
// SaveCharacters ( JMM , JMM ) ;
2101: LD_EXP 17
2105: PPUSH
2106: LD_STRING JMM
2108: PPUSH
2109: CALL_OW 38
// if Bobby then
2113: LD_EXP 18
2117: IFFALSE 2152
// begin SaveCharacters ( Bobby , Bobby ) ;
2119: LD_EXP 18
2123: PPUSH
2124: LD_STRING Bobby
2126: PPUSH
2127: CALL_OW 38
// if IsDead ( Bobby ) then
2131: LD_EXP 18
2135: PPUSH
2136: CALL_OW 301
2140: IFFALSE 2152
// SaveVariable ( 0 , BobbyLoc ) ;
2142: LD_INT 0
2144: PPUSH
2145: LD_STRING BobbyLoc
2147: PPUSH
2148: CALL_OW 39
// end ; if Cyrus then
2152: LD_EXP 19
2156: IFFALSE 2191
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2158: LD_EXP 19
2162: PPUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: CALL_OW 38
// if IsDead ( Cyrus ) then
2170: LD_EXP 19
2174: PPUSH
2175: CALL_OW 301
2179: IFFALSE 2191
// SaveVariable ( 0 , CyrusLoc ) ;
2181: LD_INT 0
2183: PPUSH
2184: LD_STRING CyrusLoc
2186: PPUSH
2187: CALL_OW 39
// end ; if Brown then
2191: LD_EXP 21
2195: IFFALSE 2230
// begin SaveCharacters ( Brown , Brown ) ;
2197: LD_EXP 21
2201: PPUSH
2202: LD_STRING Brown
2204: PPUSH
2205: CALL_OW 38
// if IsDead ( Brown ) then
2209: LD_EXP 21
2213: PPUSH
2214: CALL_OW 301
2218: IFFALSE 2230
// SaveVariable ( 0 , BrownLoc ) ;
2220: LD_INT 0
2222: PPUSH
2223: LD_STRING BrownLoc
2225: PPUSH
2226: CALL_OW 39
// end ; if Donaldson then
2230: LD_EXP 20
2234: IFFALSE 2269
// begin SaveCharacters ( Donaldson , Donaldson ) ;
2236: LD_EXP 20
2240: PPUSH
2241: LD_STRING Donaldson
2243: PPUSH
2244: CALL_OW 38
// if IsDead ( Donaldson ) then
2248: LD_EXP 20
2252: PPUSH
2253: CALL_OW 301
2257: IFFALSE 2269
// SaveVariable ( 0 , DonaldsonLoc ) ;
2259: LD_INT 0
2261: PPUSH
2262: LD_STRING DonaldsonLoc
2264: PPUSH
2265: CALL_OW 39
// end ; SaveCharacters ( Gary , Gary ) ;
2269: LD_EXP 22
2273: PPUSH
2274: LD_STRING Gary
2276: PPUSH
2277: CALL_OW 38
// if IsDead ( Gary ) then
2281: LD_EXP 22
2285: PPUSH
2286: CALL_OW 301
2290: IFFALSE 2302
// SaveVariable ( 0 , GaryLoc ) ;
2292: LD_INT 0
2294: PPUSH
2295: LD_STRING GaryLoc
2297: PPUSH
2298: CALL_OW 39
// sibu := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2302: LD_ADDR_VAR 0 2
2306: PUSH
2307: LD_EXP 69
2311: PPUSH
2312: CALL_OW 274
2316: PPUSH
2317: LD_INT 3
2319: PPUSH
2320: CALL_OW 275
2324: ST_TO_ADDR
// if sibu > 300 then
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 300
2332: GREATER
2333: IFFALSE 2343
// sibu := 300 ;
2335: LD_ADDR_VAR 0 2
2339: PUSH
2340: LD_INT 300
2342: ST_TO_ADDR
// SaveVariable ( sibu , stoupa9_siberit ) ;
2343: LD_VAR 0 2
2347: PPUSH
2348: LD_STRING stoupa9_siberit
2350: PPUSH
2351: CALL_OW 39
// SaveVariable ( ( PoskytnouInformace > 0 ) , stoupa9_informace ) ;
2355: LD_EXP 56
2359: PUSH
2360: LD_INT 0
2362: GREATER
2363: PPUSH
2364: LD_STRING stoupa9_informace
2366: PPUSH
2367: CALL_OW 39
// SaveCharacters ( other_survivors , other_survivors ) ;
2371: LD_EXP 52
2375: PPUSH
2376: LD_STRING other_survivors
2378: PPUSH
2379: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Donaldson , Brown , Bobby , Cyrus , Gary , 0 ] , otherWithJMM ) ;
2383: LD_INT 22
2385: PUSH
2386: LD_EXP 47
2390: PUSH
2391: EMPTY
2392: LIST
2393: LIST
2394: PUSH
2395: LD_INT 21
2397: PUSH
2398: LD_INT 1
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: LD_INT 23
2407: PUSH
2408: LD_INT 1
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: LIST
2419: PPUSH
2420: CALL_OW 69
2424: PUSH
2425: LD_EXP 17
2429: PUSH
2430: LD_EXP 20
2434: PUSH
2435: LD_EXP 21
2439: PUSH
2440: LD_EXP 18
2444: PUSH
2445: LD_EXP 19
2449: PUSH
2450: LD_EXP 22
2454: PUSH
2455: LD_INT 0
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: LIST
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: DIFF
2467: PPUSH
2468: LD_STRING otherWithJMM
2470: PPUSH
2471: CALL_OW 38
// end ;
2475: LD_VAR 0 1
2479: RET
// every 0 0$3 trigger depot1 do var sib_dep1 ;
2480: LD_EXP 69
2484: IFFALSE 2537
2486: GO 2488
2488: DISABLE
2489: LD_INT 0
2491: PPUSH
// begin sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_EXP 69
2501: PPUSH
2502: CALL_OW 274
2506: PPUSH
2507: LD_INT 3
2509: PPUSH
2510: CALL_OW 275
2514: ST_TO_ADDR
// if sib_dep1 >= EndSiberit then
2515: LD_VAR 0 1
2519: PUSH
2520: LD_EXP 55
2524: GREATEREQUAL
2525: IFFALSE 2536
// ChangeMissionObjectives ( M2a ) else
2527: LD_STRING M2a
2529: PPUSH
2530: CALL_OW 337
2534: GO 2537
// enable ;
2536: ENABLE
// end ;
2537: PPOPN 1
2539: END
// export function SetMedals ; var d , sib_dep1 , sib_celkem , i ; begin
2540: LD_INT 0
2542: PPUSH
2543: PPUSH
2544: PPUSH
2545: PPUSH
2546: PPUSH
// d := difficulty - 1 ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_OWVAR 67
2556: PUSH
2557: LD_INT 1
2559: MINUS
2560: ST_TO_ADDR
// sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2561: LD_ADDR_VAR 0 3
2565: PUSH
2566: LD_EXP 69
2570: PPUSH
2571: CALL_OW 274
2575: PPUSH
2576: LD_INT 3
2578: PPUSH
2579: CALL_OW 275
2583: ST_TO_ADDR
// sib_celkem := 0 ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_INT 0
2591: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_INT 22
2599: PUSH
2600: LD_EXP 47
2604: PUSH
2605: EMPTY
2606: LIST
2607: LIST
2608: PUSH
2609: LD_INT 2
2611: PUSH
2612: LD_INT 30
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PUSH
2622: LD_INT 30
2624: PUSH
2625: LD_INT 1
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PPUSH
2641: CALL_OW 69
2645: PUSH
2646: FOR_IN
2647: IFFALSE 2680
// sib_celkem := sib_celkem + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
2649: LD_ADDR_VAR 0 4
2653: PUSH
2654: LD_VAR 0 4
2658: PUSH
2659: LD_VAR 0 5
2663: PPUSH
2664: CALL_OW 274
2668: PPUSH
2669: LD_INT 3
2671: PPUSH
2672: CALL_OW 275
2676: PLUS
2677: ST_TO_ADDR
2678: GO 2646
2680: POP
2681: POP
// if sib_dep1 >= EndSiberit then
2682: LD_VAR 0 3
2686: PUSH
2687: LD_EXP 55
2691: GREATEREQUAL
2692: IFFALSE 2706
// AddMedal ( MuchSiberite , 1 ) else
2694: LD_STRING MuchSiberite
2696: PPUSH
2697: LD_INT 1
2699: PPUSH
2700: CALL_OW 101
2704: GO 2762
// if sib_celkem < EndSiberit then
2706: LD_VAR 0 4
2710: PUSH
2711: LD_EXP 55
2715: LESS
2716: IFFALSE 2741
// AddMedal ( MuchSiberite , - 1 - 2 * d ) else
2718: LD_STRING MuchSiberite
2720: PPUSH
2721: LD_INT 1
2723: NEG
2724: PUSH
2725: LD_INT 2
2727: PUSH
2728: LD_VAR 0 2
2732: MUL
2733: MINUS
2734: PPUSH
2735: CALL_OW 101
2739: GO 2762
// AddMedal ( MuchSiberite , - 2 - 2 * d ) ;
2741: LD_STRING MuchSiberite
2743: PPUSH
2744: LD_INT 2
2746: NEG
2747: PUSH
2748: LD_INT 2
2750: PUSH
2751: LD_VAR 0 2
2755: MUL
2756: MINUS
2757: PPUSH
2758: CALL_OW 101
// AddMedal ( EarlySiberite , not NastvalPowella ) ;
2762: LD_STRING EarlySiberite
2764: PPUSH
2765: LD_EXP 57
2769: NOT
2770: PPUSH
2771: CALL_OW 101
// AddMedal ( Information , PoskytnouInformace > 0 ) ;
2775: LD_STRING Information
2777: PPUSH
2778: LD_EXP 56
2782: PUSH
2783: LD_INT 0
2785: GREATER
2786: PPUSH
2787: CALL_OW 101
// end ;
2791: LD_VAR 0 1
2795: RET
// export Vyhrano ; export function Vyhra ; begin
2796: LD_INT 0
2798: PPUSH
// if not Vyhrano then
2799: LD_EXP 70
2803: NOT
2804: IFFALSE 2894
// begin Vyhrano := true ;
2806: LD_ADDR_EXP 70
2810: PUSH
2811: LD_INT 1
2813: ST_TO_ADDR
// SetMedals ;
2814: CALL 2540 0 0
// GiveMedals ( Main ) ;
2818: LD_STRING Main
2820: PPUSH
2821: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
2825: LD_INT 22
2827: PUSH
2828: LD_EXP 47
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 21
2839: PUSH
2840: LD_INT 1
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 23
2849: PUSH
2850: LD_INT 1
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: PPUSH
2867: CALL_OW 43
// Save ;
2871: CALL 2097 0 0
// YouWin ;
2875: CALL_OW 103
// ExclusiveOn ;
2879: CALL_OW 4
// WAIT ( 1 ) ;
2883: LD_INT 1
2885: PPUSH
2886: CALL_OW 67
// ExclusiveOff ;
2890: CALL_OW 5
// end ; end ;
2894: LD_VAR 0 1
2898: RET
// final begin end ; end_of_file
2899: END
// export ArmBuild ; export ArmUpgraded ; export function Dialog2 ; begin
2900: LD_INT 0
2902: PPUSH
// InGameOn ;
2903: CALL_OW 8
// PlaceUnitXYR ( Eng1 , 35 , 8 , 3 , false ) ;
2907: LD_EXP 26
2911: PPUSH
2912: LD_INT 35
2914: PPUSH
2915: LD_INT 8
2917: PPUSH
2918: LD_INT 3
2920: PPUSH
2921: LD_INT 0
2923: PPUSH
2924: CALL_OW 50
// PlaceUnitXYR ( Eng2 , 35 , 8 , 3 , false ) ;
2928: LD_EXP 27
2932: PPUSH
2933: LD_INT 35
2935: PPUSH
2936: LD_INT 8
2938: PPUSH
2939: LD_INT 3
2941: PPUSH
2942: LD_INT 0
2944: PPUSH
2945: CALL_OW 50
// PlaceUnitXYR ( Eng3 , 35 , 8 , 3 , false ) ;
2949: LD_EXP 28
2953: PPUSH
2954: LD_INT 35
2956: PPUSH
2957: LD_INT 8
2959: PPUSH
2960: LD_INT 3
2962: PPUSH
2963: LD_INT 0
2965: PPUSH
2966: CALL_OW 50
// PlaceHumanInUnit ( Eng4 , CarE1 ) ;
2970: LD_EXP 29
2974: PPUSH
2975: LD_EXP 30
2979: PPUSH
2980: CALL_OW 52
// PlaceUnitXY ( CarE1 , 41 , 9 , false ) ;
2984: LD_EXP 30
2988: PPUSH
2989: LD_INT 41
2991: PPUSH
2992: LD_INT 9
2994: PPUSH
2995: LD_INT 0
2997: PPUSH
2998: CALL_OW 48
// ComHold ( CarE1 ) ;
3002: LD_EXP 30
3006: PPUSH
3007: CALL_OW 140
// ComMoveXY ( [ Eng1 , Eng2 , Eng3 ] , 34 , 6 ) ;
3011: LD_EXP 26
3015: PUSH
3016: LD_EXP 27
3020: PUSH
3021: LD_EXP 28
3025: PUSH
3026: EMPTY
3027: LIST
3028: LIST
3029: LIST
3030: PPUSH
3031: LD_INT 34
3033: PPUSH
3034: LD_INT 6
3036: PPUSH
3037: CALL_OW 111
// AddComRepairBuilding ( [ Eng1 , Eng2 , Eng3 ] , Depot1 ) ;
3041: LD_EXP 26
3045: PUSH
3046: LD_EXP 27
3050: PUSH
3051: LD_EXP 28
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: PPUSH
3061: LD_EXP 69
3065: PPUSH
3066: CALL_OW 190
// ComEnterUnit ( Gary , rudepot1 ) ;
3070: LD_EXP 22
3074: PPUSH
3075: LD_EXP 67
3079: PPUSH
3080: CALL_OW 120
// Wait ( 0 0$1 ) ;
3084: LD_INT 35
3086: PPUSH
3087: CALL_OW 67
// PlaceUnitXY ( JMM , 33 , 1 , false ) ;
3091: LD_EXP 17
3095: PPUSH
3096: LD_INT 33
3098: PPUSH
3099: LD_INT 1
3101: PPUSH
3102: LD_INT 0
3104: PPUSH
3105: CALL_OW 48
// CenterNowOnUnits ( JMM ) ;
3109: LD_EXP 17
3113: PPUSH
3114: CALL_OW 87
// ComMoveXY ( JMM , 34 , 5 ) ;
3118: LD_EXP 17
3122: PPUSH
3123: LD_INT 34
3125: PPUSH
3126: LD_INT 5
3128: PPUSH
3129: CALL_OW 111
// AddComStand ( JMM ) ;
3133: LD_EXP 17
3137: PPUSH
3138: CALL_OW 225
// CreateCratesXY ( 5 , 39 , 10 , false ) ;
3142: LD_INT 5
3144: PPUSH
3145: LD_INT 39
3147: PPUSH
3148: LD_INT 10
3150: PPUSH
3151: LD_INT 0
3153: PPUSH
3154: CALL_OW 54
// CreateCratesXY ( 5 , 39 , 11 , false ) ;
3158: LD_INT 5
3160: PPUSH
3161: LD_INT 39
3163: PPUSH
3164: LD_INT 11
3166: PPUSH
3167: LD_INT 0
3169: PPUSH
3170: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 10 , false ) ;
3174: LD_INT 5
3176: PPUSH
3177: LD_INT 38
3179: PPUSH
3180: LD_INT 10
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 11 , false ) ;
3190: LD_INT 5
3192: PPUSH
3193: LD_INT 38
3195: PPUSH
3196: LD_INT 11
3198: PPUSH
3199: LD_INT 0
3201: PPUSH
3202: CALL_OW 54
// Wait ( 0 0$3 ) ;
3206: LD_INT 105
3208: PPUSH
3209: CALL_OW 67
// ComMoveXY ( CarE1 , 38 , 1 ) ;
3213: LD_EXP 30
3217: PPUSH
3218: LD_INT 38
3220: PPUSH
3221: LD_INT 1
3223: PPUSH
3224: CALL_OW 111
// while GetY ( CarE1 ) > 3 do
3228: LD_EXP 30
3232: PPUSH
3233: CALL_OW 251
3237: PUSH
3238: LD_INT 3
3240: GREATER
3241: IFFALSE 3252
// wait ( 0 0$0.3 ) ;
3243: LD_INT 10
3245: PPUSH
3246: CALL_OW 67
3250: GO 3228
// RemoveUnit ( CarE1 ) ;
3252: LD_EXP 30
3256: PPUSH
3257: CALL_OW 64
// Say ( JMM , D2-JMM-1 ) ;
3261: LD_EXP 17
3265: PPUSH
3266: LD_STRING D2-JMM-1
3268: PPUSH
3269: CALL_OW 88
// Say ( Eng1 , D2-Eng1-1 ) ;
3273: LD_EXP 26
3277: PPUSH
3278: LD_STRING D2-Eng1-1
3280: PPUSH
3281: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3285: LD_EXP 17
3289: PPUSH
3290: LD_STRING D2-JMM-2
3292: PPUSH
3293: CALL_OW 88
// Say ( Eng1 , D2-Eng1-2 ) ;
3297: LD_EXP 26
3301: PPUSH
3302: LD_STRING D2-Eng1-2
3304: PPUSH
3305: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3309: LD_EXP 17
3313: PPUSH
3314: LD_STRING D2-JMM-3
3316: PPUSH
3317: CALL_OW 88
// SetSideBase ( GetBase ( Depot1 ) , you ) ;
3321: LD_EXP 69
3325: PPUSH
3326: CALL_OW 274
3330: PPUSH
3331: LD_EXP 47
3335: PPUSH
3336: CALL_OW 236
// SetSide ( [ Eng1 , Eng2 , Eng3 ] , you ) ;
3340: LD_EXP 26
3344: PUSH
3345: LD_EXP 27
3349: PUSH
3350: LD_EXP 28
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: PPUSH
3360: LD_EXP 47
3364: PPUSH
3365: CALL_OW 235
// SaveForQuickRestart ;
3369: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
3373: LD_STRING M1
3375: PPUSH
3376: CALL_OW 337
// InGameOff ;
3380: CALL_OW 9
// end ;
3384: LD_VAR 0 1
3388: RET
// export byld2a ; every 0 0$2 trigger IsInArea ( JMM , base ) marked 30 do
3389: LD_EXP 17
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: CALL_OW 308
3401: IFFALSE 3410
3403: GO 3405
3405: DISABLE
// begin dialog2a ;
3406: CALL 3411 0 0
// end ;
3410: END
// export function dialog2a ; var i ; begin
3411: LD_INT 0
3413: PPUSH
3414: PPUSH
// Wait ( 0 0$1 ) ;
3415: LD_INT 35
3417: PPUSH
3418: CALL_OW 67
// ComMoveUnit ( Gary , JMM ) ;
3422: LD_EXP 22
3426: PPUSH
3427: LD_EXP 17
3431: PPUSH
3432: CALL_OW 112
// byld2a := true ;
3436: LD_ADDR_EXP 73
3440: PUSH
3441: LD_INT 1
3443: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
3444: LD_INT 105
3446: PPUSH
3447: CALL_OW 67
// DialogueOn ;
3451: CALL_OW 6
// Say ( JMM , D2-JMM-3a ) ;
3455: LD_EXP 17
3459: PPUSH
3460: LD_STRING D2-JMM-3a
3462: PPUSH
3463: CALL_OW 88
// SetSideBase ( GetBase ( rudepot1 ) , you ) ;
3467: LD_EXP 67
3471: PPUSH
3472: CALL_OW 274
3476: PPUSH
3477: LD_EXP 47
3481: PPUSH
3482: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you2 ] , [ f_type , unit_building ] ] ) do
3486: LD_ADDR_VAR 0 2
3490: PUSH
3491: LD_INT 22
3493: PUSH
3494: LD_EXP 48
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PUSH
3503: LD_INT 21
3505: PUSH
3506: LD_INT 3
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PPUSH
3517: CALL_OW 69
3521: PUSH
3522: FOR_IN
3523: IFFALSE 3541
// SetSide ( i , you ) ;
3525: LD_VAR 0 2
3529: PPUSH
3530: LD_EXP 47
3534: PPUSH
3535: CALL_OW 235
3539: GO 3522
3541: POP
3542: POP
// SetSide ( lidi_base , you ) ;
3543: LD_EXP 59
3547: PPUSH
3548: LD_EXP 47
3552: PPUSH
3553: CALL_OW 235
// SetResourceType ( GetBase ( rudepot1 ) , mat_siberit , 0 ) ;
3557: LD_EXP 67
3561: PPUSH
3562: CALL_OW 274
3566: PPUSH
3567: LD_INT 3
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 277
// Say ( Gary , D2-Gary-3 ) ;
3577: LD_EXP 22
3581: PPUSH
3582: LD_STRING D2-Gary-3
3584: PPUSH
3585: CALL_OW 88
// if Bobby then
3589: LD_EXP 18
3593: IFFALSE 3607
// Say ( Bobby , D2-Bobby-3 ) ;
3595: LD_EXP 18
3599: PPUSH
3600: LD_STRING D2-Bobby-3
3602: PPUSH
3603: CALL_OW 88
// if Cyrus then
3607: LD_EXP 19
3611: IFFALSE 3625
// Say ( Cyrus , D2-Cyrus-3 ) ;
3613: LD_EXP 19
3617: PPUSH
3618: LD_STRING D2-Cyrus-3
3620: PPUSH
3621: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3625: LD_EXP 17
3629: PPUSH
3630: LD_STRING D2-JMM-4
3632: PPUSH
3633: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3637: LD_EXP 22
3641: PPUSH
3642: LD_STRING D2-Gary-4
3644: PPUSH
3645: CALL_OW 88
// if Cyrus then
3649: LD_EXP 19
3653: IFFALSE 3669
// Say ( Cyrus , D2-Cyrus-4 ) else
3655: LD_EXP 19
3659: PPUSH
3660: LD_STRING D2-Cyrus-4
3662: PPUSH
3663: CALL_OW 88
3667: GO 3701
// SayAny ( lidi_base diff neco_rikaji , D2-Sol1-4 , you , sex_male , 0 , 0 ) ;
3669: LD_EXP 59
3673: PUSH
3674: LD_EXP 61
3678: DIFF
3679: PPUSH
3680: LD_STRING D2-Sol1-4
3682: PPUSH
3683: LD_EXP 47
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 0
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL 12924 0 6
// Say ( JMM , D2-JMM-5 ) ;
3701: LD_EXP 17
3705: PPUSH
3706: LD_STRING D2-JMM-5
3708: PPUSH
3709: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-5 , you , sex_female , class_engineer , 0 ) ;
3713: LD_EXP 58
3717: PUSH
3718: LD_EXP 61
3722: DIFF
3723: PPUSH
3724: LD_STRING D2-FEng1-5
3726: PPUSH
3727: LD_EXP 47
3731: PPUSH
3732: LD_INT 2
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: LD_INT 0
3740: PPUSH
3741: CALL 12924 0 6
// Say ( JMM , D2-JMM-6 ) ;
3745: LD_EXP 17
3749: PPUSH
3750: LD_STRING D2-JMM-6
3752: PPUSH
3753: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-6 , you , sex_female , class_engineer , 0 ) ;
3757: LD_EXP 58
3761: PUSH
3762: LD_EXP 61
3766: DIFF
3767: PPUSH
3768: LD_STRING D2-FEng1-6
3770: PPUSH
3771: LD_EXP 47
3775: PPUSH
3776: LD_INT 2
3778: PPUSH
3779: LD_INT 2
3781: PPUSH
3782: LD_INT 0
3784: PPUSH
3785: CALL 12924 0 6
// SayAny ( lidi diff neco_rikaji , D2-Eng1-6 , you , sex_male , class_engineer , 0 ) ;
3789: LD_EXP 58
3793: PUSH
3794: LD_EXP 61
3798: DIFF
3799: PPUSH
3800: LD_STRING D2-Eng1-6
3802: PPUSH
3803: LD_EXP 47
3807: PPUSH
3808: LD_INT 1
3810: PPUSH
3811: LD_INT 2
3813: PPUSH
3814: LD_INT 0
3816: PPUSH
3817: CALL 12924 0 6
// Say ( JMM , D2-JMM-7 ) ;
3821: LD_EXP 17
3825: PPUSH
3826: LD_STRING D2-JMM-7
3828: PPUSH
3829: CALL_OW 88
// Say ( Gary , D2-Gary-75 ) ;
3833: LD_EXP 22
3837: PPUSH
3838: LD_STRING D2-Gary-75
3840: PPUSH
3841: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-7 , you , sex_female , class_engineer , 0 ) ;
3845: LD_EXP 58
3849: PUSH
3850: LD_EXP 61
3854: DIFF
3855: PPUSH
3856: LD_STRING D2-FEng1-7
3858: PPUSH
3859: LD_EXP 47
3863: PPUSH
3864: LD_INT 2
3866: PPUSH
3867: LD_INT 2
3869: PPUSH
3870: LD_INT 0
3872: PPUSH
3873: CALL 12924 0 6
// SayAny ( lidi diff neco_rikaji , D2-Sol1-7 , you , sex_male , class_soldier , 0 ) ;
3877: LD_EXP 58
3881: PUSH
3882: LD_EXP 61
3886: DIFF
3887: PPUSH
3888: LD_STRING D2-Sol1-7
3890: PPUSH
3891: LD_EXP 47
3895: PPUSH
3896: LD_INT 1
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: LD_INT 0
3904: PPUSH
3905: CALL 12924 0 6
// Say ( JMM , D2-JMM-8 ) ;
3909: LD_EXP 17
3913: PPUSH
3914: LD_STRING D2-JMM-8
3916: PPUSH
3917: CALL_OW 88
// dialog2byl := true ;
3921: LD_ADDR_EXP 65
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
3929: LD_STRING M1a
3931: PPUSH
3932: CALL_OW 337
// DialogueOff ;
3936: CALL_OW 7
// MyHint ( SibDet ) ;
3940: LD_STRING SibDet
3942: PPUSH
3943: CALL 14075 0 1
// end ;
3947: LD_VAR 0 1
3951: RET
// every 0 0$5 trigger GetSide ( rudepot1 ) = you and GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) do
3952: LD_EXP 67
3956: PPUSH
3957: CALL_OW 255
3961: PUSH
3962: LD_EXP 47
3966: EQUAL
3967: PUSH
3968: LD_EXP 67
3972: PPUSH
3973: CALL_OW 274
3977: PPUSH
3978: LD_INT 3
3980: PPUSH
3981: CALL_OW 275
3985: AND
3986: IFFALSE 4051
3988: GO 3990
3990: DISABLE
// begin case difficulty of 1 :
3991: LD_OWVAR 67
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4014
4004: POP
// ChangeMissionObjectives ( M2easy ) ; 2 :
4005: LD_STRING M2easy
4007: PPUSH
4008: CALL_OW 337
4012: GO 4051
4014: LD_INT 2
4016: DOUBLE
4017: EQUAL
4018: IFTRUE 4022
4020: GO 4032
4022: POP
// ChangeMissionObjectives ( M2 ) ; 3 :
4023: LD_STRING M2
4025: PPUSH
4026: CALL_OW 337
4030: GO 4051
4032: LD_INT 3
4034: DOUBLE
4035: EQUAL
4036: IFTRUE 4040
4038: GO 4050
4040: POP
// ChangeMissionObjectives ( M2hard ) ; end ;
4041: LD_STRING M2hard
4043: PPUSH
4044: CALL_OW 337
4048: GO 4051
4050: POP
// end ;
4051: END
// every 7 7$0 do
4052: GO 4054
4054: DISABLE
// begin DialogueOn ;
4055: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4059: LD_EXP 16
4063: PPUSH
4064: LD_STRING D3-Pow-1
4066: PPUSH
4067: CALL_OW 94
// if dialog2byl then
4071: LD_EXP 65
4075: IFFALSE 4091
// Say ( JMM , D3-JMM-1 ) else
4077: LD_EXP 17
4081: PPUSH
4082: LD_STRING D3-JMM-1
4084: PPUSH
4085: CALL_OW 88
4089: GO 4103
// Say ( JMM , D3-JMM-1a ) ;
4091: LD_EXP 17
4095: PPUSH
4096: LD_STRING D3-JMM-1a
4098: PPUSH
4099: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4103: LD_EXP 17
4107: PPUSH
4108: LD_STRING D3-JMM-1b
4110: PPUSH
4111: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4115: LD_EXP 16
4119: PPUSH
4120: LD_STRING D3-Pow-2
4122: PPUSH
4123: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
4127: LD_STRING M3
4129: PPUSH
4130: CALL_OW 337
// DialogueOff ;
4134: CALL_OW 7
// counter_time := 22 22$0 ;
4138: LD_ADDR_EXP 64
4142: PUSH
4143: LD_INT 46200
4145: ST_TO_ADDR
// end ;
4146: END
// every 22 22$0 do var qr , i , mt ;
4147: GO 4149
4149: DISABLE
4150: LD_INT 0
4152: PPUSH
4153: PPUSH
4154: PPUSH
// begin SetAttitude ( you , you2 , att_neutral , true ) ;
4155: LD_EXP 47
4159: PPUSH
4160: LD_EXP 48
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: LD_INT 1
4170: PPUSH
4171: CALL_OW 80
// ChangeSideFog ( you2 , you ) ;
4175: LD_EXP 48
4179: PPUSH
4180: LD_EXP 47
4184: PPUSH
4185: CALL_OW 343
// PlaceHumanInUnit ( Mec1 , Car1 ) ;
4189: LD_EXP 31
4193: PPUSH
4194: LD_EXP 34
4198: PPUSH
4199: CALL_OW 52
// PlaceHumanInUnit ( Mec2 , Car2 ) ;
4203: LD_EXP 32
4207: PPUSH
4208: LD_EXP 35
4212: PPUSH
4213: CALL_OW 52
// PlaceHumanInUnit ( Mec3 , Car3 ) ;
4217: LD_EXP 33
4221: PPUSH
4222: LD_EXP 36
4226: PPUSH
4227: CALL_OW 52
// if not PlaceUnitXYR ( Car1 , 35 , 1 , 10 , false ) then
4231: LD_EXP 34
4235: PPUSH
4236: LD_INT 35
4238: PPUSH
4239: LD_INT 1
4241: PPUSH
4242: LD_INT 10
4244: PPUSH
4245: LD_INT 0
4247: PPUSH
4248: CALL_OW 50
4252: NOT
4253: IFFALSE 4270
// PlaceUnitArea ( Car1 , odjezd , false ) ;
4255: LD_EXP 34
4259: PPUSH
4260: LD_INT 5
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 49
// if not PlaceUnitXYR ( Car2 , 35 , 1 , 10 , false ) then
4270: LD_EXP 35
4274: PPUSH
4275: LD_INT 35
4277: PPUSH
4278: LD_INT 1
4280: PPUSH
4281: LD_INT 10
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 50
4291: NOT
4292: IFFALSE 4309
// PlaceUnitArea ( Car2 , odjezd , false ) ;
4294: LD_EXP 35
4298: PPUSH
4299: LD_INT 5
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: CALL_OW 49
// if not PlaceUnitXYR ( Car3 , 35 , 1 , 10 , false ) then
4309: LD_EXP 36
4313: PPUSH
4314: LD_INT 35
4316: PPUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 10
4322: PPUSH
4323: LD_INT 0
4325: PPUSH
4326: CALL_OW 50
4330: NOT
4331: IFFALSE 4348
// PlaceUnitArea ( Car3 , odjezd , false ) ;
4333: LD_EXP 36
4337: PPUSH
4338: LD_INT 5
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 49
// ComMoveXY ( [ Car1 , Car2 , Car3 ] , 37 , 8 ) ;
4348: LD_EXP 34
4352: PUSH
4353: LD_EXP 35
4357: PUSH
4358: LD_EXP 36
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: PPUSH
4368: LD_INT 37
4370: PPUSH
4371: LD_INT 8
4373: PPUSH
4374: CALL_OW 111
// AddComStand ( [ Car1 , Car2 , Car3 ] ) ;
4378: LD_EXP 34
4382: PUSH
4383: LD_EXP 35
4387: PUSH
4388: LD_EXP 36
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: LIST
4397: PPUSH
4398: CALL_OW 225
// CenterNowOnUnits ( Car1 ) ;
4402: LD_EXP 34
4406: PPUSH
4407: CALL_OW 87
// Wait ( 0 0$3 ) ;
4411: LD_INT 105
4413: PPUSH
4414: CALL_OW 67
// DialogueOn ;
4418: CALL_OW 6
// Say ( Mec1 , D4-Mech1-1 ) ;
4422: LD_EXP 31
4426: PPUSH
4427: LD_STRING D4-Mech1-1
4429: PPUSH
4430: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4434: LD_EXP 17
4438: PPUSH
4439: LD_STRING D4-JMM-1
4441: PPUSH
4442: CALL_OW 88
// Say ( Mec1 , D4-Mech1-2 ) ;
4446: LD_EXP 31
4450: PPUSH
4451: LD_STRING D4-Mech1-2
4453: PPUSH
4454: CALL_OW 88
// AddResourceType ( GetBase ( Depot1 ) , mat_cans , 300 ) ;
4458: LD_EXP 69
4462: PPUSH
4463: CALL_OW 274
4467: PPUSH
4468: LD_INT 1
4470: PPUSH
4471: LD_INT 300
4473: PPUSH
4474: CALL_OW 276
// qr := 0 ;
4478: LD_ADDR_VAR 0 1
4482: PUSH
4483: LD_INT 0
4485: ST_TO_ADDR
// if KolikMaBytSiberitu > GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4486: LD_EXP 66
4490: PUSH
4491: LD_EXP 69
4495: PPUSH
4496: CALL_OW 274
4500: PPUSH
4501: LD_INT 3
4503: PPUSH
4504: CALL_OW 275
4508: GREATER
4509: IFFALSE 4601
// begin qr := Query ( QWait ) ;
4511: LD_ADDR_VAR 0 1
4515: PUSH
4516: LD_STRING QWait
4518: PPUSH
4519: CALL_OW 97
4523: ST_TO_ADDR
// case qr of 1 :
4524: LD_VAR 0 1
4528: PUSH
4529: LD_INT 1
4531: DOUBLE
4532: EQUAL
4533: IFTRUE 4537
4535: GO 4552
4537: POP
// Say ( JMM , D5a-JMM-1 ) ; 2 :
4538: LD_EXP 17
4542: PPUSH
4543: LD_STRING D5a-JMM-1
4545: PPUSH
4546: CALL_OW 88
4550: GO 4599
4552: LD_INT 2
4554: DOUBLE
4555: EQUAL
4556: IFTRUE 4560
4558: GO 4575
4560: POP
// Say ( JMM , D5b-JMM-1 ) ; 3 :
4561: LD_EXP 17
4565: PPUSH
4566: LD_STRING D5b-JMM-1
4568: PPUSH
4569: CALL_OW 88
4573: GO 4599
4575: LD_INT 3
4577: DOUBLE
4578: EQUAL
4579: IFTRUE 4583
4581: GO 4598
4583: POP
// Say ( JMM , D5c-JMM-1 ) ; end ;
4584: LD_EXP 17
4588: PPUSH
4589: LD_STRING D5c-JMM-1
4591: PPUSH
4592: CALL_OW 88
4596: GO 4599
4598: POP
// end else
4599: GO 4613
// Say ( JMM , D5-JMM-1 ) ;
4601: LD_EXP 17
4605: PPUSH
4606: LD_STRING D5-JMM-1
4608: PPUSH
4609: CALL_OW 88
// DialogueOff ;
4613: CALL_OW 7
// if qr = 1 then
4617: LD_VAR 0 1
4621: PUSH
4622: LD_INT 1
4624: EQUAL
4625: IFFALSE 4648
// begin counter_time := tick + 5 5$0 ;
4627: LD_ADDR_EXP 64
4631: PUSH
4632: LD_OWVAR 1
4636: PUSH
4637: LD_INT 10500
4639: PLUS
4640: ST_TO_ADDR
// Wait ( 5 5$0 ) ;
4641: LD_INT 10500
4643: PPUSH
4644: CALL_OW 67
// end ; if qr = 2 or qr = 3 then
4648: LD_VAR 0 1
4652: PUSH
4653: LD_INT 2
4655: EQUAL
4656: PUSH
4657: LD_VAR 0 1
4661: PUSH
4662: LD_INT 3
4664: EQUAL
4665: OR
4666: IFFALSE 4676
// NastvalPowella := true ;
4668: LD_ADDR_EXP 57
4672: PUSH
4673: LD_INT 1
4675: ST_TO_ADDR
// DialogueOn ;
4676: CALL_OW 6
// if KolikMaBytSiberitu <= GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4680: LD_EXP 66
4684: PUSH
4685: LD_EXP 69
4689: PPUSH
4690: CALL_OW 274
4694: PPUSH
4695: LD_INT 3
4697: PPUSH
4698: CALL_OW 275
4702: LESSEQUAL
4703: IFFALSE 4719
// Say ( Mec1 , D6-Mech1-1 ) else
4705: LD_EXP 31
4709: PPUSH
4710: LD_STRING D6-Mech1-1
4712: PPUSH
4713: CALL_OW 88
4717: GO 4776
// begin NastvalPowella := true ;
4719: LD_ADDR_EXP 57
4723: PUSH
4724: LD_INT 1
4726: ST_TO_ADDR
// if 0 < GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4727: LD_INT 0
4729: PUSH
4730: LD_EXP 69
4734: PPUSH
4735: CALL_OW 274
4739: PPUSH
4740: LD_INT 3
4742: PPUSH
4743: CALL_OW 275
4747: LESS
4748: IFFALSE 4764
// Say ( Mec1 , D6-Mech1-1a ) else
4750: LD_EXP 31
4754: PPUSH
4755: LD_STRING D6-Mech1-1a
4757: PPUSH
4758: CALL_OW 88
4762: GO 4776
// Say ( Mec1 , D6-Mech1-1b ) ;
4764: LD_EXP 31
4768: PPUSH
4769: LD_STRING D6-Mech1-1b
4771: PPUSH
4772: CALL_OW 88
// end ; DialogueOff ;
4776: CALL_OW 7
// counter_time := 0 ;
4780: LD_ADDR_EXP 64
4784: PUSH
4785: LD_INT 0
4787: ST_TO_ADDR
// if GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > KolikMaBytSiberitu then
4788: LD_EXP 69
4792: PPUSH
4793: CALL_OW 274
4797: PPUSH
4798: LD_INT 3
4800: PPUSH
4801: CALL_OW 275
4805: PUSH
4806: LD_EXP 66
4810: GREATER
4811: IFFALSE 4858
// begin SetCargo ( [ Car1 ] , mat_siberit , KolikMaBytSiberitu ) ;
4813: LD_EXP 34
4817: PUSH
4818: EMPTY
4819: LIST
4820: PPUSH
4821: LD_INT 3
4823: PPUSH
4824: LD_EXP 66
4828: PPUSH
4829: CALL_OW 290
// AddResourceType ( GetBase ( Depot1 ) , mat_siberit , - KolikMaBytSiberitu ) ;
4833: LD_EXP 69
4837: PPUSH
4838: CALL_OW 274
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_EXP 66
4850: NEG
4851: PPUSH
4852: CALL_OW 276
// end else
4856: GO 4911
// begin SetCargo ( [ Car1 ] , mat_siberit , GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) ) ;
4858: LD_EXP 34
4862: PUSH
4863: EMPTY
4864: LIST
4865: PPUSH
4866: LD_INT 3
4868: PPUSH
4869: LD_EXP 69
4873: PPUSH
4874: CALL_OW 274
4878: PPUSH
4879: LD_INT 3
4881: PPUSH
4882: CALL_OW 275
4886: PPUSH
4887: CALL_OW 290
// SetResourceType ( GetBase ( Depot1 ) , mat_siberit , 0 ) ;
4891: LD_EXP 69
4895: PPUSH
4896: CALL_OW 274
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 0
4906: PPUSH
4907: CALL_OW 277
// end ; mt := tick + 0 0$20 ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_OWVAR 1
4920: PUSH
4921: LD_INT 700
4923: PLUS
4924: ST_TO_ADDR
// while UnitFilter ( [ Car1 , Car2 , Car3 ] , [ [ f_placed ] ] ) and mt < tick do
4925: LD_EXP 34
4929: PUSH
4930: LD_EXP 35
4934: PUSH
4935: LD_EXP 36
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: PPUSH
4945: LD_INT 52
4947: PUSH
4948: EMPTY
4949: LIST
4950: PUSH
4951: EMPTY
4952: LIST
4953: PPUSH
4954: CALL_OW 72
4958: PUSH
4959: LD_VAR 0 3
4963: PUSH
4964: LD_OWVAR 1
4968: LESS
4969: AND
4970: IFFALSE 5132
// begin ComMoveToArea ( [ Car1 , Car2 , Car3 ] , odjezd ) ;
4972: LD_EXP 34
4976: PUSH
4977: LD_EXP 35
4981: PUSH
4982: LD_EXP 36
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: PPUSH
4992: LD_INT 5
4994: PPUSH
4995: CALL_OW 113
// AddComMoveXY ( [ Car1 , Car2 , Car3 ] , 38 , 1 ) ;
4999: LD_EXP 34
5003: PUSH
5004: LD_EXP 35
5008: PUSH
5009: LD_EXP 36
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: PPUSH
5019: LD_INT 38
5021: PPUSH
5022: LD_INT 1
5024: PPUSH
5025: CALL_OW 171
// case true of IsInArea ( Car1 , odjezd ) :
5029: LD_INT 1
5031: PUSH
5032: LD_EXP 34
5036: PPUSH
5037: LD_INT 5
5039: PPUSH
5040: CALL_OW 308
5044: DOUBLE
5045: EQUAL
5046: IFTRUE 5050
5048: GO 5062
5050: POP
// RemoveUnit ( Car1 ) ; IsInArea ( Car2 , odjezd ) :
5051: LD_EXP 34
5055: PPUSH
5056: CALL_OW 64
5060: GO 5123
5062: LD_EXP 35
5066: PPUSH
5067: LD_INT 5
5069: PPUSH
5070: CALL_OW 308
5074: DOUBLE
5075: EQUAL
5076: IFTRUE 5080
5078: GO 5092
5080: POP
// RemoveUnit ( Car2 ) ; IsInArea ( Car3 , odjezd ) :
5081: LD_EXP 35
5085: PPUSH
5086: CALL_OW 64
5090: GO 5123
5092: LD_EXP 36
5096: PPUSH
5097: LD_INT 5
5099: PPUSH
5100: CALL_OW 308
5104: DOUBLE
5105: EQUAL
5106: IFTRUE 5110
5108: GO 5122
5110: POP
// RemoveUnit ( Car3 ) ; end ;
5111: LD_EXP 36
5115: PPUSH
5116: CALL_OW 64
5120: GO 5123
5122: POP
// wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// end ;
5130: GO 4925
// for i in [ Car1 , Car2 , Car3 , Mec1 , Mec2 , Mec3 ] do
5132: LD_ADDR_VAR 0 2
5136: PUSH
5137: LD_EXP 34
5141: PUSH
5142: LD_EXP 35
5146: PUSH
5147: LD_EXP 36
5151: PUSH
5152: LD_EXP 31
5156: PUSH
5157: LD_EXP 32
5161: PUSH
5162: LD_EXP 33
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: FOR_IN
5176: IFFALSE 5189
// RemoveUnit ( i ) ;
5178: LD_VAR 0 2
5182: PPUSH
5183: CALL_OW 64
5187: GO 5175
5189: POP
5190: POP
// if NastvalPowella then
5191: LD_EXP 57
5195: IFFALSE 5206
// ChangeMissionObjectives ( M3b ) else
5197: LD_STRING M3b
5199: PPUSH
5200: CALL_OW 337
5204: GO 5213
// ChangeMissionObjectives ( M3a ) ;
5206: LD_STRING M3a
5208: PPUSH
5209: CALL_OW 337
// end ;
5213: PPOPN 3
5215: END
// every 0 0$5 trigger GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > 35 do var r ;
5216: LD_EXP 69
5220: PPUSH
5221: CALL_OW 274
5225: PPUSH
5226: LD_INT 3
5228: PPUSH
5229: CALL_OW 275
5233: PUSH
5234: LD_INT 35
5236: GREATER
5237: IFFALSE 5408
5239: GO 5241
5241: DISABLE
5242: LD_INT 0
5244: PPUSH
// begin Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , class_scientistic , 0 ) ;
5245: LD_ADDR_EXP 25
5249: PUSH
5250: LD_EXP 58
5254: PUSH
5255: LD_EXP 61
5259: DIFF
5260: PPUSH
5261: LD_EXP 47
5265: PPUSH
5266: LD_INT 1
5268: PPUSH
5269: LD_INT 4
5271: PPUSH
5272: LD_INT 0
5274: PPUSH
5275: CALL 13004 0 5
5279: ST_TO_ADDR
// if not Sci1 then
5280: LD_EXP 25
5284: NOT
5285: IFFALSE 5322
// Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , 0 , 0 ) ;
5287: LD_ADDR_EXP 25
5291: PUSH
5292: LD_EXP 58
5296: PUSH
5297: LD_EXP 61
5301: DIFF
5302: PPUSH
5303: LD_EXP 47
5307: PPUSH
5308: LD_INT 1
5310: PPUSH
5311: LD_INT 0
5313: PPUSH
5314: LD_INT 0
5316: PPUSH
5317: CALL 13004 0 5
5321: ST_TO_ADDR
// if Sci1 then
5322: LD_EXP 25
5326: IFFALSE 5408
// begin DialogueOn ;
5328: CALL_OW 6
// Say ( Sci1 , D7-Sci1-1 ) ;
5332: LD_EXP 25
5336: PPUSH
5337: LD_STRING D7-Sci1-1
5339: PPUSH
5340: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5344: LD_EXP 17
5348: PPUSH
5349: LD_STRING D7-JMM-1
5351: PPUSH
5352: CALL_OW 88
// Say ( Sci1 , D7-Sci1-2 ) ;
5356: LD_EXP 25
5360: PPUSH
5361: LD_STRING D7-Sci1-2
5363: PPUSH
5364: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5368: LD_EXP 17
5372: PPUSH
5373: LD_STRING D7-JMM-2
5375: PPUSH
5376: CALL_OW 88
// Say ( Sci1 , D7-Sci1-3 ) ;
5380: LD_EXP 25
5384: PPUSH
5385: LD_STRING D7-Sci1-3
5387: PPUSH
5388: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5392: LD_EXP 17
5396: PPUSH
5397: LD_STRING D7-JMM-3
5399: PPUSH
5400: CALL_OW 88
// DialogueOff ;
5404: CALL_OW 7
// end ; end ;
5408: PPOPN 1
5410: END
// export ArmStarted ; export BarStarted ; function odnes_jeden_oil ; var a ; begin
5411: LD_INT 0
5413: PPUSH
5414: PPUSH
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5415: LD_EXP 40
5419: PPUSH
5420: LD_EXP 67
5424: PPUSH
5425: CALL_OW 296
5429: PUSH
5430: LD_INT 4
5432: GREATER
5433: IFFALSE 5458
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5435: LD_EXP 40
5439: PPUSH
5440: LD_EXP 67
5444: PPUSH
5445: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5449: LD_INT 4
5451: PPUSH
5452: CALL_OW 67
// end ;
5456: GO 5415
// ComStop ( Ara2 ) ;
5458: LD_EXP 40
5462: PPUSH
5463: CALL_OW 141
// ComHold ( Ara2 ) ;
5467: LD_EXP 40
5471: PPUSH
5472: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5476: LD_EXP 40
5480: PPUSH
5481: LD_INT 2
5483: PPUSH
5484: LD_INT 10
5486: PPUSH
5487: CALL_OW 290
// a := GetFuel ( AraCar1 ) ;
5491: LD_ADDR_VAR 0 2
5495: PUSH
5496: LD_EXP 44
5500: PPUSH
5501: CALL_OW 261
5505: ST_TO_ADDR
// while GetFuel ( AraCar1 ) <= a do
5506: LD_EXP 44
5510: PPUSH
5511: CALL_OW 261
5515: PUSH
5516: LD_VAR 0 2
5520: LESSEQUAL
5521: IFFALSE 5546
// begin ComRefuel ( Ara2 , AraCar1 ) ;
5523: LD_EXP 40
5527: PPUSH
5528: LD_EXP 44
5532: PPUSH
5533: CALL_OW 150
// wait ( 0 0$1 ) ;
5537: LD_INT 35
5539: PPUSH
5540: CALL_OW 67
// end ;
5544: GO 5506
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5546: LD_EXP 40
5550: PPUSH
5551: LD_INT 2
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: CALL_OW 290
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5561: LD_EXP 40
5565: PPUSH
5566: LD_EXP 67
5570: PPUSH
5571: CALL_OW 296
5575: PUSH
5576: LD_INT 4
5578: GREATER
5579: IFFALSE 5604
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5581: LD_EXP 40
5585: PPUSH
5586: LD_EXP 67
5590: PPUSH
5591: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5595: LD_INT 4
5597: PPUSH
5598: CALL_OW 67
// end ;
5602: GO 5561
// ComStop ( Ara2 ) ;
5604: LD_EXP 40
5608: PPUSH
5609: CALL_OW 141
// ComHold ( Ara2 ) ;
5613: LD_EXP 40
5617: PPUSH
5618: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5622: LD_EXP 40
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 290
// a := GetFuel ( AraCar2 ) ;
5637: LD_ADDR_VAR 0 2
5641: PUSH
5642: LD_EXP 45
5646: PPUSH
5647: CALL_OW 261
5651: ST_TO_ADDR
// while GetFuel ( AraCar2 ) <= a do
5652: LD_EXP 45
5656: PPUSH
5657: CALL_OW 261
5661: PUSH
5662: LD_VAR 0 2
5666: LESSEQUAL
5667: IFFALSE 5692
// begin ComRefuel ( Ara2 , AraCar2 ) ;
5669: LD_EXP 40
5673: PPUSH
5674: LD_EXP 45
5678: PPUSH
5679: CALL_OW 150
// wait ( 0 0$1 ) ;
5683: LD_INT 35
5685: PPUSH
5686: CALL_OW 67
// end ;
5690: GO 5652
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5692: LD_EXP 40
5696: PPUSH
5697: LD_INT 2
5699: PPUSH
5700: LD_INT 0
5702: PPUSH
5703: CALL_OW 290
// ComStop ( Ara2 ) ;
5707: LD_EXP 40
5711: PPUSH
5712: CALL_OW 141
// ComHold ( Ara2 ) ;
5716: LD_EXP 40
5720: PPUSH
5721: CALL_OW 140
// result := true ;
5725: LD_ADDR_VAR 0 1
5729: PUSH
5730: LD_INT 1
5732: ST_TO_ADDR
// end ;
5733: LD_VAR 0 1
5737: RET
// function odnes_neco ( mat , kolik ) ; var a , i ; begin
5738: LD_INT 0
5740: PPUSH
5741: PPUSH
5742: PPUSH
// for i := 1 to ( kolik div 10 ) do
5743: LD_ADDR_VAR 0 5
5747: PUSH
5748: DOUBLE
5749: LD_INT 1
5751: DEC
5752: ST_TO_ADDR
5753: LD_VAR 0 2
5757: PUSH
5758: LD_INT 10
5760: DIV
5761: PUSH
5762: FOR_TO
5763: IFFALSE 5936
// begin while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5765: LD_EXP 40
5769: PPUSH
5770: LD_EXP 67
5774: PPUSH
5775: CALL_OW 296
5779: PUSH
5780: LD_INT 4
5782: GREATER
5783: IFFALSE 5808
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5785: LD_EXP 40
5789: PPUSH
5790: LD_EXP 67
5794: PPUSH
5795: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5799: LD_INT 4
5801: PPUSH
5802: CALL_OW 67
// end ;
5806: GO 5765
// ComHold ( Ara2 ) ;
5808: LD_EXP 40
5812: PPUSH
5813: CALL_OW 140
// SetCargo ( Ara2 , mat , 10 ) ;
5817: LD_EXP 40
5821: PPUSH
5822: LD_VAR 0 1
5826: PPUSH
5827: LD_INT 10
5829: PPUSH
5830: CALL_OW 290
// a := GetCargo ( AraCar2 , mat ) ;
5834: LD_ADDR_VAR 0 4
5838: PUSH
5839: LD_EXP 45
5843: PPUSH
5844: LD_VAR 0 1
5848: PPUSH
5849: CALL_OW 289
5853: ST_TO_ADDR
// while GetCargo ( AraCar2 , mat ) <= a do
5854: LD_EXP 45
5858: PPUSH
5859: LD_VAR 0 1
5863: PPUSH
5864: CALL_OW 289
5868: PUSH
5869: LD_VAR 0 4
5873: LESSEQUAL
5874: IFFALSE 5899
// begin ComMoveUnit ( Ara2 , AraCar2 ) ;
5876: LD_EXP 40
5880: PPUSH
5881: LD_EXP 45
5885: PPUSH
5886: CALL_OW 112
// wait ( 0 0$1 ) ;
5890: LD_INT 35
5892: PPUSH
5893: CALL_OW 67
// end ;
5897: GO 5854
// SetCargo ( Ara2 , mat , 0 ) ;
5899: LD_EXP 40
5903: PPUSH
5904: LD_VAR 0 1
5908: PPUSH
5909: LD_INT 0
5911: PPUSH
5912: CALL_OW 290
// ComStop ( Ara2 ) ;
5916: LD_EXP 40
5920: PPUSH
5921: CALL_OW 141
// ComHold ( Ara2 ) ;
5925: LD_EXP 40
5929: PPUSH
5930: CALL_OW 140
// end ;
5934: GO 5762
5936: POP
5937: POP
// result := true ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 1
5945: ST_TO_ADDR
// end ;
5946: LD_VAR 0 3
5950: RET
// every 0 0$1 do var mt ;
5951: GO 5953
5953: DISABLE
5954: LD_INT 0
5956: PPUSH
// begin if arabi_time <> 0 then
5957: LD_EXP 1
5961: PUSH
5962: LD_INT 0
5964: NONEQUAL
5965: IFFALSE 6059
// if arabi_time > 1 then
5967: LD_EXP 1
5971: PUSH
5972: LD_INT 1
5974: GREATER
5975: IFFALSE 6059
// begin wait ( arabi_time ) ;
5977: LD_EXP 1
5981: PPUSH
5982: CALL_OW 67
// mt := tick + 3 3$0 ;
5986: LD_ADDR_VAR 0 1
5990: PUSH
5991: LD_OWVAR 1
5995: PUSH
5996: LD_INT 6300
5998: PLUS
5999: ST_TO_ADDR
// while Getside ( rudepot1 ) <> you and mt > tick do
6000: LD_EXP 67
6004: PPUSH
6005: CALL_OW 255
6009: PUSH
6010: LD_EXP 47
6014: NONEQUAL
6015: PUSH
6016: LD_VAR 0 1
6020: PUSH
6021: LD_OWVAR 1
6025: GREATER
6026: AND
6027: IFFALSE 6038
// wait ( 0 0$3 ) ;
6029: LD_INT 105
6031: PPUSH
6032: CALL_OW 67
6036: GO 6000
// if Getside ( rudepot1 ) = you then
6038: LD_EXP 67
6042: PPUSH
6043: CALL_OW 255
6047: PUSH
6048: LD_EXP 47
6052: EQUAL
6053: IFFALSE 6059
// arabi ;
6055: CALL 6080 0 0
// end ; end ;
6059: PPOPN 1
6061: END
// every 27 27$0 trigger arabi_time = 0 do
6062: LD_EXP 1
6066: PUSH
6067: LD_INT 0
6069: EQUAL
6070: IFFALSE 6079
6072: GO 6074
6074: DISABLE
// begin arabi ;
6075: CALL 6080 0 0
// end ;
6079: END
// export kecy , mina1 , mina3 ; function arabi ; var cekani , qr , nabidka , i , a , mytick , to_reach , ara1_faze , ara3_faze , odmitl_v_query ; begin
6080: LD_INT 0
6082: PPUSH
6083: PPUSH
6084: PPUSH
6085: PPUSH
6086: PPUSH
6087: PPUSH
6088: PPUSH
6089: PPUSH
6090: PPUSH
6091: PPUSH
6092: PPUSH
// PlaceUnitArea ( Ara1 , rus_mat_l , false ) ;
6093: LD_EXP 39
6097: PPUSH
6098: LD_INT 3
6100: PPUSH
6101: LD_INT 0
6103: PPUSH
6104: CALL_OW 49
// PlaceUnitArea ( Ara2 , rus_mat_l , false ) ;
6108: LD_EXP 40
6112: PPUSH
6113: LD_INT 3
6115: PPUSH
6116: LD_INT 0
6118: PPUSH
6119: CALL_OW 49
// PlaceUnitArea ( Ara3 , rus_mat_l , false ) ;
6123: LD_EXP 41
6127: PPUSH
6128: LD_INT 3
6130: PPUSH
6131: LD_INT 0
6133: PPUSH
6134: CALL_OW 49
// PlaceUnitArea ( AraCar1 , rus_mat_l , false ) ;
6138: LD_EXP 44
6142: PPUSH
6143: LD_INT 3
6145: PPUSH
6146: LD_INT 0
6148: PPUSH
6149: CALL_OW 49
// PlaceUnitArea ( AraCar2 , rus_mat_l , false ) ;
6153: LD_EXP 45
6157: PPUSH
6158: LD_INT 3
6160: PPUSH
6161: LD_INT 0
6163: PPUSH
6164: CALL_OW 49
// ComHold ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] ) ;
6168: LD_EXP 39
6172: PUSH
6173: LD_EXP 40
6177: PUSH
6178: LD_EXP 41
6182: PUSH
6183: LD_EXP 42
6187: PUSH
6188: LD_EXP 43
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL_OW 140
// DialogueOn ;
6204: CALL_OW 6
// SayRadio ( Ara1 , D8-Ar1-1 ) ;
6208: LD_EXP 39
6212: PPUSH
6213: LD_STRING D8-Ar1-1
6215: PPUSH
6216: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6220: LD_EXP 17
6224: PPUSH
6225: LD_STRING D8-JMM-1
6227: PPUSH
6228: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-2 ) ;
6232: LD_EXP 39
6236: PPUSH
6237: LD_STRING D8-Ar1-2
6239: PPUSH
6240: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6244: LD_EXP 17
6248: PPUSH
6249: LD_STRING D8-JMM-2
6251: PPUSH
6252: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-3 ) ;
6256: LD_EXP 39
6260: PPUSH
6261: LD_STRING D8-Ar1-3
6263: PPUSH
6264: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6268: LD_EXP 17
6272: PPUSH
6273: LD_STRING D8-JMM-3
6275: PPUSH
6276: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-4 ) ;
6280: LD_EXP 39
6284: PPUSH
6285: LD_STRING D8-Ar1-4
6287: PPUSH
6288: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6292: LD_EXP 17
6296: PPUSH
6297: LD_STRING D8-JMM-4
6299: PPUSH
6300: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-5 ) ;
6304: LD_EXP 39
6308: PPUSH
6309: LD_STRING D8-Ar1-5
6311: PPUSH
6312: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6316: LD_EXP 17
6320: PPUSH
6321: LD_STRING D8-JMM-5
6323: PPUSH
6324: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-6 ) ;
6328: LD_EXP 39
6332: PPUSH
6333: LD_STRING D8-Ar1-6
6335: PPUSH
6336: CALL_OW 94
// SayRadio ( Ara2 , D8-Ar2-6 ) ;
6340: LD_EXP 40
6344: PPUSH
6345: LD_STRING D8-Ar2-6
6347: PPUSH
6348: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6352: LD_EXP 17
6356: PPUSH
6357: LD_STRING D8-JMM-6
6359: PPUSH
6360: CALL_OW 88
// SayRadio ( Ara2 , D8-Ar2-7 ) ;
6364: LD_EXP 40
6368: PPUSH
6369: LD_STRING D8-Ar2-7
6371: PPUSH
6372: CALL_OW 94
// Aqr1 := Query ( QBarracks ) ;
6376: LD_ADDR_EXP 37
6380: PUSH
6381: LD_STRING QBarracks
6383: PPUSH
6384: CALL_OW 97
6388: ST_TO_ADDR
// case Aqr1 of 1 :
6389: LD_EXP 37
6393: PUSH
6394: LD_INT 1
6396: DOUBLE
6397: EQUAL
6398: IFTRUE 6402
6400: GO 6429
6402: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6403: LD_EXP 17
6407: PPUSH
6408: LD_STRING D8a-JMM-1
6410: PPUSH
6411: CALL_OW 88
// SayRadio ( Ara1 , D8a-Ar1-1 ) ;
6415: LD_EXP 39
6419: PPUSH
6420: LD_STRING D8a-Ar1-1
6422: PPUSH
6423: CALL_OW 94
// end ; 2 :
6427: GO 6605
6429: LD_INT 2
6431: DOUBLE
6432: EQUAL
6433: IFTRUE 6437
6435: GO 6561
6437: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6438: LD_EXP 17
6442: PPUSH
6443: LD_STRING D8b-JMM-1
6445: PPUSH
6446: CALL_OW 88
// SayRadio ( Ara1 , D8b-Ar1-1 ) ;
6450: LD_EXP 39
6454: PPUSH
6455: LD_STRING D8b-Ar1-1
6457: PPUSH
6458: CALL_OW 94
// Aqr2 := Query ( QInfo ) ;
6462: LD_ADDR_EXP 38
6466: PUSH
6467: LD_STRING QInfo
6469: PPUSH
6470: CALL_OW 97
6474: ST_TO_ADDR
// case Aqr2 of 1 :
6475: LD_EXP 38
6479: PUSH
6480: LD_INT 1
6482: DOUBLE
6483: EQUAL
6484: IFTRUE 6488
6486: GO 6515
6488: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6489: LD_EXP 17
6493: PPUSH
6494: LD_STRING D8b1-JMM-1
6496: PPUSH
6497: CALL_OW 88
// SayRadio ( Ara1 , D8b1-Ar1-1 ) ;
6501: LD_EXP 39
6505: PPUSH
6506: LD_STRING D8b1-Ar1-1
6508: PPUSH
6509: CALL_OW 94
// end ; 2 :
6513: GO 6559
6515: LD_INT 2
6517: DOUBLE
6518: EQUAL
6519: IFTRUE 6523
6521: GO 6558
6523: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6524: LD_EXP 17
6528: PPUSH
6529: LD_STRING D8b2-JMM-1
6531: PPUSH
6532: CALL_OW 88
// SayRadio ( Ara1 , D8b2-Ar1-1 ) ;
6536: LD_EXP 39
6540: PPUSH
6541: LD_STRING D8b2-Ar1-1
6543: PPUSH
6544: CALL_OW 94
// odmitl_v_query := true ;
6548: LD_ADDR_VAR 0 11
6552: PUSH
6553: LD_INT 1
6555: ST_TO_ADDR
// end ; end ;
6556: GO 6559
6558: POP
// end ; 3 :
6559: GO 6605
6561: LD_INT 3
6563: DOUBLE
6564: EQUAL
6565: IFTRUE 6569
6567: GO 6604
6569: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6570: LD_EXP 17
6574: PPUSH
6575: LD_STRING D8c-JMM-1
6577: PPUSH
6578: CALL_OW 88
// odmitl_v_query := true ;
6582: LD_ADDR_VAR 0 11
6586: PUSH
6587: LD_INT 1
6589: ST_TO_ADDR
// SayRadio ( Ara1 , D8c-Ar1-1 ) ;
6590: LD_EXP 39
6594: PPUSH
6595: LD_STRING D8c-Ar1-1
6597: PPUSH
6598: CALL_OW 94
// end ; end ;
6602: GO 6605
6604: POP
// DialogueOff ;
6605: CALL_OW 7
// if Aqr1 = 1 or ( Aqr1 = 2 and Aqr2 = 1 ) then
6609: LD_EXP 37
6613: PUSH
6614: LD_INT 1
6616: EQUAL
6617: PUSH
6618: LD_EXP 37
6622: PUSH
6623: LD_INT 2
6625: EQUAL
6626: PUSH
6627: LD_EXP 38
6631: PUSH
6632: LD_INT 1
6634: EQUAL
6635: AND
6636: OR
6637: IFFALSE 9385
// begin ComMoveToArea ( AraCar1 , pod_base ) ;
6639: LD_EXP 44
6643: PPUSH
6644: LD_INT 30
6646: PPUSH
6647: CALL_OW 113
// wait ( 0 0$1 ) ;
6651: LD_INT 35
6653: PPUSH
6654: CALL_OW 67
// ComMoveToArea ( AraCar2 , pod_base ) ;
6658: LD_EXP 45
6662: PPUSH
6663: LD_INT 30
6665: PPUSH
6666: CALL_OW 113
// ComWait ( [ Ara1 , Ara2 , Ara3 ] , 0 0$4 ) ;
6670: LD_EXP 39
6674: PUSH
6675: LD_EXP 40
6679: PUSH
6680: LD_EXP 41
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: LD_INT 140
6692: PPUSH
6693: CALL_OW 142
// AddComMoveToArea ( [ Ara1 , Ara2 , Ara3 ] , in_base ) ;
6697: LD_EXP 39
6701: PUSH
6702: LD_EXP 40
6706: PUSH
6707: LD_EXP 41
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: LIST
6716: PPUSH
6717: LD_INT 21
6719: PPUSH
6720: CALL_OW 173
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 ] , 95 , 98 ) ;
6724: LD_EXP 39
6728: PUSH
6729: LD_EXP 40
6733: PUSH
6734: LD_EXP 41
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: LIST
6743: PPUSH
6744: LD_INT 95
6746: PPUSH
6747: LD_INT 98
6749: PPUSH
6750: CALL_OW 171
// AddComMoveToArea ( [ Ara1 , Ara3 ] , for_charge ) ;
6754: LD_EXP 39
6758: PUSH
6759: LD_EXP 41
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: PPUSH
6768: LD_INT 29
6770: PPUSH
6771: CALL_OW 173
// AddComPlaceRemoteCharge ( Ara1 , 0 , 0 , rudepot1 ) ;
6775: LD_EXP 39
6779: PPUSH
6780: LD_INT 0
6782: PPUSH
6783: LD_INT 0
6785: PPUSH
6786: LD_EXP 67
6790: PPUSH
6791: CALL_OW 193
// AddComPlaceRemoteCharge ( Ara3 , 0 , 0 , rudepot1 ) ;
6795: LD_EXP 41
6799: PPUSH
6800: LD_INT 0
6802: PPUSH
6803: LD_INT 0
6805: PPUSH
6806: LD_EXP 67
6810: PPUSH
6811: CALL_OW 193
// AddComMoveToArea ( [ Ara1 , Ara3 ] , pod_base ) ;
6815: LD_EXP 39
6819: PUSH
6820: LD_EXP 41
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PPUSH
6829: LD_INT 30
6831: PPUSH
6832: CALL_OW 173
// mytick := tick + 2 2$30 ;
6836: LD_ADDR_VAR 0 7
6840: PUSH
6841: LD_OWVAR 1
6845: PUSH
6846: LD_INT 5250
6848: PLUS
6849: ST_TO_ADDR
// to_reach := [ AraCar1 , AraCar2 , Ara3 , Ara2 , Ara1 ] ;
6850: LD_ADDR_VAR 0 8
6854: PUSH
6855: LD_EXP 44
6859: PUSH
6860: LD_EXP 45
6864: PUSH
6865: LD_EXP 41
6869: PUSH
6870: LD_EXP 40
6874: PUSH
6875: LD_EXP 39
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: LIST
6884: LIST
6885: LIST
6886: ST_TO_ADDR
// while mytick > tick and to_reach do
6887: LD_VAR 0 7
6891: PUSH
6892: LD_OWVAR 1
6896: GREATER
6897: PUSH
6898: LD_VAR 0 8
6902: AND
6903: IFFALSE 7163
// begin if IsInArea ( AraCar1 , pod_base ) or not IsOk ( AraCar1 ) then
6905: LD_EXP 44
6909: PPUSH
6910: LD_INT 30
6912: PPUSH
6913: CALL_OW 308
6917: PUSH
6918: LD_EXP 44
6922: PPUSH
6923: CALL_OW 302
6927: NOT
6928: OR
6929: IFFALSE 6950
// to_reach := to_reach diff [ AraCar1 ] ;
6931: LD_ADDR_VAR 0 8
6935: PUSH
6936: LD_VAR 0 8
6940: PUSH
6941: LD_EXP 44
6945: PUSH
6946: EMPTY
6947: LIST
6948: DIFF
6949: ST_TO_ADDR
// if IsInArea ( AraCar2 , pod_base ) or not IsOk ( AraCar2 ) then
6950: LD_EXP 45
6954: PPUSH
6955: LD_INT 30
6957: PPUSH
6958: CALL_OW 308
6962: PUSH
6963: LD_EXP 45
6967: PPUSH
6968: CALL_OW 302
6972: NOT
6973: OR
6974: IFFALSE 6995
// to_reach := to_reach diff [ AraCar2 ] ;
6976: LD_ADDR_VAR 0 8
6980: PUSH
6981: LD_VAR 0 8
6985: PUSH
6986: LD_EXP 45
6990: PUSH
6991: EMPTY
6992: LIST
6993: DIFF
6994: ST_TO_ADDR
// if IsInArea ( Ara1 , in_base ) or not IsOk ( Ara1 ) then
6995: LD_EXP 39
6999: PPUSH
7000: LD_INT 21
7002: PPUSH
7003: CALL_OW 308
7007: PUSH
7008: LD_EXP 39
7012: PPUSH
7013: CALL_OW 302
7017: NOT
7018: OR
7019: IFFALSE 7040
// to_reach := to_reach diff [ Ara1 ] ;
7021: LD_ADDR_VAR 0 8
7025: PUSH
7026: LD_VAR 0 8
7030: PUSH
7031: LD_EXP 39
7035: PUSH
7036: EMPTY
7037: LIST
7038: DIFF
7039: ST_TO_ADDR
// if IsInArea ( Ara2 , in_base ) or not IsOk ( Ara2 ) then
7040: LD_EXP 40
7044: PPUSH
7045: LD_INT 21
7047: PPUSH
7048: CALL_OW 308
7052: PUSH
7053: LD_EXP 40
7057: PPUSH
7058: CALL_OW 302
7062: NOT
7063: OR
7064: IFFALSE 7085
// to_reach := to_reach diff [ Ara2 ] ;
7066: LD_ADDR_VAR 0 8
7070: PUSH
7071: LD_VAR 0 8
7075: PUSH
7076: LD_EXP 40
7080: PUSH
7081: EMPTY
7082: LIST
7083: DIFF
7084: ST_TO_ADDR
// if IsInArea ( Ara3 , in_base ) or not IsOk ( Ara3 ) then
7085: LD_EXP 41
7089: PPUSH
7090: LD_INT 21
7092: PPUSH
7093: CALL_OW 308
7097: PUSH
7098: LD_EXP 41
7102: PPUSH
7103: CALL_OW 302
7107: NOT
7108: OR
7109: IFFALSE 7130
// to_reach := to_reach diff [ Ara3 ] ;
7111: LD_ADDR_VAR 0 8
7115: PUSH
7116: LD_VAR 0 8
7120: PUSH
7121: LD_EXP 41
7125: PUSH
7126: EMPTY
7127: LIST
7128: DIFF
7129: ST_TO_ADDR
// ComMoveToArea ( AraCar1 , pod_base ) ;
7130: LD_EXP 44
7134: PPUSH
7135: LD_INT 30
7137: PPUSH
7138: CALL_OW 113
// ComMoveToArea ( AraCar2 , pod_base ) ;
7142: LD_EXP 45
7146: PPUSH
7147: LD_INT 30
7149: PPUSH
7150: CALL_OW 113
// wait ( 0 0$1 ) ;
7154: LD_INT 35
7156: PPUSH
7157: CALL_OW 67
// end ;
7161: GO 6887
// if Aqr1 = 1 then
7163: LD_EXP 37
7167: PUSH
7168: LD_INT 1
7170: EQUAL
7171: IFFALSE 7436
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7173: LD_EXP 67
7177: PPUSH
7178: CALL_OW 274
7182: PPUSH
7183: LD_INT 2
7185: PPUSH
7186: CALL_OW 275
7190: PUSH
7191: LD_INT 60
7193: LESS
7194: IFFALSE 7399
// begin DialogueOn ;
7196: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7200: LD_EXP 41
7204: PPUSH
7205: LD_STRING D9a-FAr1-1
7207: PPUSH
7208: CALL_OW 88
7212: IFFALSE 7226
// Say ( JMM , D9a-JMM-1 ) ;
7214: LD_EXP 17
7218: PPUSH
7219: LD_STRING D9a-JMM-1
7221: PPUSH
7222: CALL_OW 88
// DialogueOff ;
7226: CALL_OW 7
// cekani := 0 ;
7230: LD_ADDR_VAR 0 2
7234: PUSH
7235: LD_INT 0
7237: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 do
7238: LD_VAR 0 2
7242: PUSH
7243: LD_INT 60
7245: LESS
7246: PUSH
7247: LD_EXP 67
7251: PPUSH
7252: CALL_OW 274
7256: PPUSH
7257: LD_INT 2
7259: PPUSH
7260: CALL_OW 275
7264: PUSH
7265: LD_INT 60
7267: LESS
7268: AND
7269: IFFALSE 7294
// begin Wait ( 0 0$1 ) ;
7271: LD_INT 35
7273: PPUSH
7274: CALL_OW 67
// cekani := cekani + 1 ;
7278: LD_ADDR_VAR 0 2
7282: PUSH
7283: LD_VAR 0 2
7287: PUSH
7288: LD_INT 1
7290: PLUS
7291: ST_TO_ADDR
// end ;
7292: GO 7238
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7294: LD_EXP 67
7298: PPUSH
7299: CALL_OW 274
7303: PPUSH
7304: LD_INT 2
7306: PPUSH
7307: CALL_OW 275
7311: PUSH
7312: LD_INT 60
7314: LESS
7315: IFFALSE 7360
// begin DialogueOn ;
7317: CALL_OW 6
// Say ( Ara1 , D9a2-Ar1-1 ) ;
7321: LD_EXP 39
7325: PPUSH
7326: LD_STRING D9a2-Ar1-1
7328: PPUSH
7329: CALL_OW 88
// DialogueOff ;
7333: CALL_OW 7
// Aqr1 := 2 ;
7337: LD_ADDR_EXP 37
7341: PUSH
7342: LD_INT 2
7344: ST_TO_ADDR
// Aqr2 := Query ( QInfo ) ;
7345: LD_ADDR_EXP 38
7349: PUSH
7350: LD_STRING QInfo
7352: PPUSH
7353: CALL_OW 97
7357: ST_TO_ADDR
// end else
7358: GO 7397
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7360: LD_EXP 67
7364: PPUSH
7365: CALL_OW 274
7369: PPUSH
7370: LD_INT 2
7372: PPUSH
7373: LD_INT 60
7375: NEG
7376: PPUSH
7377: CALL_OW 276
// if odnes_jeden_oil then
7381: CALL 5411 0 0
7385: IFFALSE 7397
// if odnes_jeden_oil then
7387: CALL 5411 0 0
7391: IFFALSE 7397
// odnes_jeden_oil ;
7393: CALL 5411 0 0
// end ; end else
7397: GO 7436
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7399: LD_EXP 67
7403: PPUSH
7404: CALL_OW 274
7408: PPUSH
7409: LD_INT 2
7411: PPUSH
7412: LD_INT 60
7414: NEG
7415: PPUSH
7416: CALL_OW 276
// if odnes_jeden_oil then
7420: CALL 5411 0 0
7424: IFFALSE 7436
// if odnes_jeden_oil then
7426: CALL 5411 0 0
7430: IFFALSE 7436
// odnes_jeden_oil ;
7432: CALL 5411 0 0
// end ; end ; if ( Aqr1 = 2 ) and ( Aqr2 = 1 ) then
7436: LD_EXP 37
7440: PUSH
7441: LD_INT 2
7443: EQUAL
7444: PUSH
7445: LD_EXP 38
7449: PUSH
7450: LD_INT 1
7452: EQUAL
7453: AND
7454: IFFALSE 7706
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7456: LD_EXP 67
7460: PPUSH
7461: CALL_OW 274
7465: PPUSH
7466: LD_INT 2
7468: PPUSH
7469: CALL_OW 275
7473: PUSH
7474: LD_INT 20
7476: LESS
7477: IFFALSE 7673
// begin DialogueOn ;
7479: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7483: LD_EXP 41
7487: PPUSH
7488: LD_STRING D9a-FAr1-1
7490: PPUSH
7491: CALL_OW 88
7495: IFFALSE 7509
// Say ( JMM , D9a-JMM-1 ) ;
7497: LD_EXP 17
7501: PPUSH
7502: LD_STRING D9a-JMM-1
7504: PPUSH
7505: CALL_OW 88
// DialogueOff ;
7509: CALL_OW 7
// cekani := 0 ;
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_INT 0
7520: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 do
7521: LD_VAR 0 2
7525: PUSH
7526: LD_INT 60
7528: LESS
7529: PUSH
7530: LD_EXP 67
7534: PPUSH
7535: CALL_OW 274
7539: PPUSH
7540: LD_INT 2
7542: PPUSH
7543: CALL_OW 275
7547: PUSH
7548: LD_INT 20
7550: LESS
7551: AND
7552: IFFALSE 7577
// begin Wait ( 0 0$1 ) ;
7554: LD_INT 35
7556: PPUSH
7557: CALL_OW 67
// cekani := cekani + 1 ;
7561: LD_ADDR_VAR 0 2
7565: PUSH
7566: LD_VAR 0 2
7570: PUSH
7571: LD_INT 1
7573: PLUS
7574: ST_TO_ADDR
// end ;
7575: GO 7521
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7577: LD_EXP 67
7581: PPUSH
7582: CALL_OW 274
7586: PPUSH
7587: LD_INT 2
7589: PPUSH
7590: CALL_OW 275
7594: PUSH
7595: LD_INT 20
7597: LESS
7598: IFFALSE 7638
// begin DialogueOn ;
7600: CALL_OW 6
// Say ( Ara1 , D9a3-Ar1-1 ) ;
7604: LD_EXP 39
7608: PPUSH
7609: LD_STRING D9a3-Ar1-1
7611: PPUSH
7612: CALL_OW 88
// DialogueOff ;
7616: CALL_OW 7
// Aqr1 := 2 ;
7620: LD_ADDR_EXP 37
7624: PUSH
7625: LD_INT 2
7627: ST_TO_ADDR
// Aqr2 := 0 ;
7628: LD_ADDR_EXP 38
7632: PUSH
7633: LD_INT 0
7635: ST_TO_ADDR
// end else
7636: GO 7671
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7638: LD_EXP 67
7642: PPUSH
7643: CALL_OW 274
7647: PPUSH
7648: LD_INT 2
7650: PPUSH
7651: LD_INT 20
7653: NEG
7654: PPUSH
7655: CALL_OW 276
// odnes_jeden_oil ;
7659: CALL 5411 0 0
// PoskytnouInformace := 1 ;
7663: LD_ADDR_EXP 56
7667: PUSH
7668: LD_INT 1
7670: ST_TO_ADDR
// end ; end else
7671: GO 7706
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7673: LD_EXP 67
7677: PPUSH
7678: CALL_OW 274
7682: PPUSH
7683: LD_INT 2
7685: PPUSH
7686: LD_INT 20
7688: NEG
7689: PPUSH
7690: CALL_OW 276
// odnes_jeden_oil ;
7694: CALL 5411 0 0
// PoskytnouInformace := 1 ;
7698: LD_ADDR_EXP 56
7702: PUSH
7703: LD_INT 1
7705: ST_TO_ADDR
// end ; end ; if Aqr1 = 1 then
7706: LD_EXP 37
7710: PUSH
7711: LD_INT 1
7713: EQUAL
7714: IFFALSE 9109
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
7716: LD_EXP 67
7720: PPUSH
7721: CALL_OW 274
7725: PPUSH
7726: LD_INT 1
7728: PPUSH
7729: CALL_OW 275
7733: PUSH
7734: LD_INT 25
7736: LESS
7737: IFFALSE 7773
// begin DialogueOn ;
7739: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1 ) then
7743: LD_EXP 40
7747: PPUSH
7748: LD_STRING D9b-Ar2-1
7750: PPUSH
7751: CALL_OW 88
7755: IFFALSE 7769
// Say ( JMM , D9b-JMM-1 ) ;
7757: LD_EXP 17
7761: PPUSH
7762: LD_STRING D9b-JMM-1
7764: PPUSH
7765: CALL_OW 88
// DialogueOff ;
7769: CALL_OW 7
// end ; cekani := 0 ;
7773: LD_ADDR_VAR 0 2
7777: PUSH
7778: LD_INT 0
7780: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
7781: LD_VAR 0 2
7785: PUSH
7786: LD_INT 120
7788: LESS
7789: PUSH
7790: LD_EXP 67
7794: PPUSH
7795: CALL_OW 274
7799: PPUSH
7800: LD_INT 1
7802: PPUSH
7803: CALL_OW 275
7807: PUSH
7808: LD_INT 25
7810: LESS
7811: AND
7812: IFFALSE 7837
// begin Wait ( 0 0$1 ) ;
7814: LD_INT 35
7816: PPUSH
7817: CALL_OW 67
// cekani := cekani + 1 ;
7821: LD_ADDR_VAR 0 2
7825: PUSH
7826: LD_VAR 0 2
7830: PUSH
7831: LD_INT 1
7833: PLUS
7834: ST_TO_ADDR
// end ;
7835: GO 7781
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
7837: LD_EXP 67
7841: PPUSH
7842: CALL_OW 274
7846: PPUSH
7847: LD_INT 1
7849: PPUSH
7850: CALL_OW 275
7854: PUSH
7855: LD_INT 25
7857: GREATEREQUAL
7858: IFFALSE 9004
// begin ComMoveXY ( Ara2 , 94 , 101 ) ;
7860: LD_EXP 40
7864: PPUSH
7865: LD_INT 94
7867: PPUSH
7868: LD_INT 101
7870: PPUSH
7871: CALL_OW 111
// while not UnitFilter ( [ Ara2 ] , [ [ f_distxy , 94 , 101 , 2 ] ] ) do
7875: LD_EXP 40
7879: PUSH
7880: EMPTY
7881: LIST
7882: PPUSH
7883: LD_INT 92
7885: PUSH
7886: LD_INT 94
7888: PUSH
7889: LD_INT 101
7891: PUSH
7892: LD_INT 2
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: LIST
7899: LIST
7900: PUSH
7901: EMPTY
7902: LIST
7903: PPUSH
7904: CALL_OW 72
7908: NOT
7909: IFFALSE 7920
// wait ( 0 0$0.3 ) ;
7911: LD_INT 10
7913: PPUSH
7914: CALL_OW 67
7918: GO 7875
// RemoveEnvironment ( 91 , 99 ) ;
7920: LD_INT 91
7922: PPUSH
7923: LD_INT 99
7925: PPUSH
7926: CALL_OW 347
// RemoveEnvironment ( 91 , 101 ) ;
7930: LD_INT 91
7932: PPUSH
7933: LD_INT 101
7935: PPUSH
7936: CALL_OW 347
// RemoveEnvironment ( 94 , 102 ) ;
7940: LD_INT 94
7942: PPUSH
7943: LD_INT 102
7945: PPUSH
7946: CALL_OW 347
// RemoveEnvironment ( 93 , 100 ) ;
7950: LD_INT 93
7952: PPUSH
7953: LD_INT 100
7955: PPUSH
7956: CALL_OW 347
// SetAttitude ( arabians , you , att_friend , true ) ;
7960: LD_EXP 50
7964: PPUSH
7965: LD_EXP 47
7969: PPUSH
7970: LD_INT 1
7972: PPUSH
7973: LD_INT 1
7975: PPUSH
7976: CALL_OW 80
// while not ArmStarted do
7980: LD_EXP 74
7984: NOT
7985: IFFALSE 8085
// begin wait ( 0 0$0.3 ) ;
7987: LD_INT 10
7989: PPUSH
7990: CALL_OW 67
// SetSide ( ara2 , Getside ( rudepot1 ) ) ;
7994: LD_EXP 40
7998: PPUSH
7999: LD_EXP 67
8003: PPUSH
8004: CALL_OW 255
8008: PPUSH
8009: CALL_OW 235
// ComBuild ( Ara2 , b_armoury , 92 , 101 , 1 ) ;
8013: LD_EXP 40
8017: PPUSH
8018: LD_INT 4
8020: PPUSH
8021: LD_INT 92
8023: PPUSH
8024: LD_INT 101
8026: PPUSH
8027: LD_INT 1
8029: PPUSH
8030: CALL_OW 145
// ComMoveXY ( FilterAllUnits ( [ [ f_distxy , 92 , 101 , 6 ] , [ f_side , arabians ] ] ) , 93 , 90 ) ;
8034: LD_INT 92
8036: PUSH
8037: LD_INT 92
8039: PUSH
8040: LD_INT 101
8042: PUSH
8043: LD_INT 6
8045: PUSH
8046: EMPTY
8047: LIST
8048: LIST
8049: LIST
8050: LIST
8051: PUSH
8052: LD_INT 22
8054: PUSH
8055: LD_EXP 50
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: PPUSH
8068: CALL_OW 69
8072: PPUSH
8073: LD_INT 93
8075: PPUSH
8076: LD_INT 90
8078: PPUSH
8079: CALL_OW 111
// end ;
8083: GO 7980
// SetSide ( ara2 , arabians ) ;
8085: LD_EXP 40
8089: PPUSH
8090: LD_EXP 50
8094: PPUSH
8095: CALL_OW 235
// wait ( 0 0$1 ) ;
8099: LD_INT 35
8101: PPUSH
8102: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8106: LD_EXP 39
8110: PUSH
8111: LD_EXP 41
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PPUSH
8120: LD_INT 30
8122: PUSH
8123: LD_INT 4
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PUSH
8130: LD_INT 23
8132: PUSH
8133: LD_INT 2
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PPUSH
8144: CALL_OW 69
8148: PPUSH
8149: CALL_OW 112
// while not ArmBuild do
8153: LD_EXP 71
8157: NOT
8158: IFFALSE 8169
// wait ( 0 0$1 ) ;
8160: LD_INT 35
8162: PPUSH
8163: CALL_OW 67
8167: GO 8153
// SetAttitude ( arabians , you , att_neutral , true ) ;
8169: LD_EXP 50
8173: PPUSH
8174: LD_EXP 47
8178: PPUSH
8179: LD_INT 0
8181: PPUSH
8182: LD_INT 1
8184: PPUSH
8185: CALL_OW 80
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
8189: LD_EXP 67
8193: PPUSH
8194: CALL_OW 274
8198: PPUSH
8199: LD_INT 1
8201: PPUSH
8202: CALL_OW 275
8206: PUSH
8207: LD_INT 25
8209: LESS
8210: IFFALSE 8246
// begin DialogueOn ;
8212: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1a ) then
8216: LD_EXP 40
8220: PPUSH
8221: LD_STRING D9b-Ar2-1a
8223: PPUSH
8224: CALL_OW 88
8228: IFFALSE 8242
// Say ( JMM , D9b-JMM-1 ) ;
8230: LD_EXP 17
8234: PPUSH
8235: LD_STRING D9b-JMM-1
8237: PPUSH
8238: CALL_OW 88
// DialogueOff ;
8242: CALL_OW 7
// end ; cekani := 0 ;
8246: LD_ADDR_VAR 0 2
8250: PUSH
8251: LD_INT 0
8253: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
8254: LD_VAR 0 2
8258: PUSH
8259: LD_INT 120
8261: LESS
8262: PUSH
8263: LD_EXP 67
8267: PPUSH
8268: CALL_OW 274
8272: PPUSH
8273: LD_INT 1
8275: PPUSH
8276: CALL_OW 275
8280: PUSH
8281: LD_INT 25
8283: LESS
8284: AND
8285: IFFALSE 8310
// begin Wait ( 0 0$1 ) ;
8287: LD_INT 35
8289: PPUSH
8290: CALL_OW 67
// cekani := cekani + 1 ;
8294: LD_ADDR_VAR 0 2
8298: PUSH
8299: LD_VAR 0 2
8303: PUSH
8304: LD_INT 1
8306: PLUS
8307: ST_TO_ADDR
// end ;
8308: GO 8254
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
8310: LD_EXP 67
8314: PPUSH
8315: CALL_OW 274
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL_OW 275
8327: PUSH
8328: LD_INT 25
8330: GREATEREQUAL
8331: IFFALSE 9004
// begin wait ( 0 0$1 ) ;
8333: LD_INT 35
8335: PPUSH
8336: CALL_OW 67
// SetRestrict ( b_barracks , you , state_enabled ) ;
8340: LD_INT 5
8342: PPUSH
8343: LD_EXP 47
8347: PPUSH
8348: LD_INT 1
8350: PPUSH
8351: CALL_OW 324
// SetAttitude ( arabians , you , att_friend , true ) ;
8355: LD_EXP 50
8359: PPUSH
8360: LD_EXP 47
8364: PPUSH
8365: LD_INT 1
8367: PPUSH
8368: LD_INT 1
8370: PPUSH
8371: CALL_OW 80
// ComUpgrade ( FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8375: LD_INT 30
8377: PUSH
8378: LD_INT 4
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: PUSH
8385: LD_INT 23
8387: PUSH
8388: LD_INT 2
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: CALL_OW 69
8403: PPUSH
8404: CALL_OW 146
// wait ( 0 0$1 ) ;
8408: LD_INT 35
8410: PPUSH
8411: CALL_OW 67
// SetRestrict ( b_barracks , you , state_disabled ) ;
8415: LD_INT 5
8417: PPUSH
8418: LD_EXP 47
8422: PPUSH
8423: LD_INT 0
8425: PPUSH
8426: CALL_OW 324
// SetTech ( tech_Mortar , you , state_researched ) ;
8430: LD_INT 41
8432: PPUSH
8433: LD_EXP 47
8437: PPUSH
8438: LD_INT 2
8440: PPUSH
8441: CALL_OW 322
// wait ( 0 0$1 ) ;
8445: LD_INT 35
8447: PPUSH
8448: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) ) ;
8452: LD_EXP 39
8456: PUSH
8457: LD_EXP 41
8461: PUSH
8462: EMPTY
8463: LIST
8464: LIST
8465: PPUSH
8466: LD_INT 30
8468: PUSH
8469: LD_INT 5
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: PUSH
8476: LD_INT 23
8478: PUSH
8479: LD_INT 2
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: PPUSH
8490: CALL_OW 69
8494: PPUSH
8495: CALL_OW 112
// while not ArmUpgraded do
8499: LD_EXP 72
8503: NOT
8504: IFFALSE 8515
// wait ( 0 0$1 ) ;
8506: LD_INT 35
8508: PPUSH
8509: CALL_OW 67
8513: GO 8499
// SetAttitude ( arabians , you , att_neutral , true ) ;
8515: LD_EXP 50
8519: PPUSH
8520: LD_EXP 47
8524: PPUSH
8525: LD_INT 0
8527: PPUSH
8528: LD_INT 1
8530: PPUSH
8531: CALL_OW 80
// DialogueOn ;
8535: CALL_OW 6
// if Say ( Ara2 , D9d-Ar2-1 ) then
8539: LD_EXP 40
8543: PPUSH
8544: LD_STRING D9d-Ar2-1
8546: PPUSH
8547: CALL_OW 88
8551: IFFALSE 8593
// if Say ( Ara1 , D9d-Ar1-1 ) then
8553: LD_EXP 39
8557: PPUSH
8558: LD_STRING D9d-Ar1-1
8560: PPUSH
8561: CALL_OW 88
8565: IFFALSE 8593
// if Say ( JMM , D9d-JMM-1 ) then
8567: LD_EXP 17
8571: PPUSH
8572: LD_STRING D9d-JMM-1
8574: PPUSH
8575: CALL_OW 88
8579: IFFALSE 8593
// Say ( Ara1 , D9d-Ar1-2 ) ;
8581: LD_EXP 39
8585: PPUSH
8586: LD_STRING D9d-Ar1-2
8588: PPUSH
8589: CALL_OW 88
// DialogueOff ;
8593: CALL_OW 7
// nabidka := [ 4 ] ;
8597: LD_ADDR_VAR 0 4
8601: PUSH
8602: LD_INT 4
8604: PUSH
8605: EMPTY
8606: LIST
8607: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) >= 20 then
8608: LD_EXP 67
8612: PPUSH
8613: CALL_OW 274
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: CALL_OW 275
8625: PUSH
8626: LD_INT 20
8628: GREATEREQUAL
8629: IFFALSE 8648
// nabidka := nabidka ^ [ 1 ] ;
8631: LD_ADDR_VAR 0 4
8635: PUSH
8636: LD_VAR 0 4
8640: PUSH
8641: LD_INT 1
8643: PUSH
8644: EMPTY
8645: LIST
8646: ADD
8647: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 50 then
8648: LD_EXP 67
8652: PPUSH
8653: CALL_OW 274
8657: PPUSH
8658: LD_INT 1
8660: PPUSH
8661: CALL_OW 275
8665: PUSH
8666: LD_INT 50
8668: GREATEREQUAL
8669: IFFALSE 8688
// nabidka := nabidka ^ [ 2 ] ;
8671: LD_ADDR_VAR 0 4
8675: PUSH
8676: LD_VAR 0 4
8680: PUSH
8681: LD_INT 2
8683: PUSH
8684: EMPTY
8685: LIST
8686: ADD
8687: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) >= 80 then
8688: LD_EXP 67
8692: PPUSH
8693: CALL_OW 274
8697: PPUSH
8698: LD_INT 2
8700: PPUSH
8701: CALL_OW 275
8705: PUSH
8706: LD_INT 80
8708: GREATEREQUAL
8709: IFFALSE 8728
// nabidka := nabidka ^ [ 3 ] ;
8711: LD_ADDR_VAR 0 4
8715: PUSH
8716: LD_VAR 0 4
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: EMPTY
8725: LIST
8726: ADD
8727: ST_TO_ADDR
// qr := 4 ;
8728: LD_ADDR_VAR 0 3
8732: PUSH
8733: LD_INT 4
8735: ST_TO_ADDR
// if nabidka > 1 then
8736: LD_VAR 0 4
8740: PUSH
8741: LD_INT 1
8743: GREATER
8744: IFFALSE 8868
// begin qr := SelectiveQuery ( QInfo2 , nabidka ) ;
8746: LD_ADDR_VAR 0 3
8750: PUSH
8751: LD_STRING QInfo2
8753: PPUSH
8754: LD_VAR 0 4
8758: PPUSH
8759: CALL_OW 98
8763: ST_TO_ADDR
// case qr of 1 :
8764: LD_VAR 0 3
8768: PUSH
8769: LD_INT 1
8771: DOUBLE
8772: EQUAL
8773: IFTRUE 8777
8775: GO 8801
8777: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_siberit , - 20 ) ; 2 :
8778: LD_EXP 67
8782: PPUSH
8783: CALL_OW 274
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 20
8793: NEG
8794: PPUSH
8795: CALL_OW 276
8799: GO 8866
8801: LD_INT 2
8803: DOUBLE
8804: EQUAL
8805: IFTRUE 8809
8807: GO 8833
8809: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_cans , - 50 ) ; 3 :
8810: LD_EXP 67
8814: PPUSH
8815: CALL_OW 274
8819: PPUSH
8820: LD_INT 1
8822: PPUSH
8823: LD_INT 50
8825: NEG
8826: PPUSH
8827: CALL_OW 276
8831: GO 8866
8833: LD_INT 3
8835: DOUBLE
8836: EQUAL
8837: IFTRUE 8841
8839: GO 8865
8841: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 80 ) ; end ;
8842: LD_EXP 67
8846: PPUSH
8847: CALL_OW 274
8851: PPUSH
8852: LD_INT 2
8854: PPUSH
8855: LD_INT 80
8857: NEG
8858: PPUSH
8859: CALL_OW 276
8863: GO 8866
8865: POP
// end else
8866: GO 8875
// begin Query ( QInfoNothing ) ;
8868: LD_STRING QInfoNothing
8870: PPUSH
8871: CALL_OW 97
// end ; if qr = 4 then
8875: LD_VAR 0 3
8879: PUSH
8880: LD_INT 4
8882: EQUAL
8883: IFFALSE 8907
// begin DialogueOn ;
8885: CALL_OW 6
// Say ( Ara1 , D9f-Ar1-1 ) ;
8889: LD_EXP 39
8893: PPUSH
8894: LD_STRING D9f-Ar1-1
8896: PPUSH
8897: CALL_OW 88
// DialogueOff ;
8901: CALL_OW 7
// end else
8905: GO 9004
// begin case qr of 1 :
8907: LD_VAR 0 3
8911: PUSH
8912: LD_INT 1
8914: DOUBLE
8915: EQUAL
8916: IFTRUE 8920
8918: GO 8933
8920: POP
// odnes_neco ( mat_siberit , 20 ) ; 2 :
8921: LD_INT 3
8923: PPUSH
8924: LD_INT 20
8926: PPUSH
8927: CALL 5738 0 2
8931: GO 8976
8933: LD_INT 2
8935: DOUBLE
8936: EQUAL
8937: IFTRUE 8941
8939: GO 8954
8941: POP
// odnes_neco ( mat_cans , 50 ) ; 3 :
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 50
8947: PPUSH
8948: CALL 5738 0 2
8952: GO 8976
8954: LD_INT 3
8956: DOUBLE
8957: EQUAL
8958: IFTRUE 8962
8960: GO 8975
8962: POP
// odnes_neco ( mat_oil , 80 ) ; end ;
8963: LD_INT 2
8965: PPUSH
8966: LD_INT 80
8968: PPUSH
8969: CALL 5738 0 2
8973: GO 8976
8975: POP
// DialogueOn ;
8976: CALL_OW 6
// Say ( Ara1 , D9e-Ar1-1 ) ;
8980: LD_EXP 39
8984: PPUSH
8985: LD_STRING D9e-Ar1-1
8987: PPUSH
8988: CALL_OW 88
// PoskytnouInformace := 1 ;
8992: LD_ADDR_EXP 56
8996: PUSH
8997: LD_INT 1
8999: ST_TO_ADDR
// DialogueOff ;
9000: CALL_OW 7
// end ; end ; end ; ComExitBuilding ( Ara2 ) ;
9004: LD_EXP 40
9008: PPUSH
9009: CALL_OW 122
// if cekani >= 120 then
9013: LD_VAR 0 2
9017: PUSH
9018: LD_INT 120
9020: GREATEREQUAL
9021: IFFALSE 9109
// begin DialogueOn ;
9023: CALL_OW 6
// if Say ( Ara1 , D9c-Ar1-1 ) then
9027: LD_EXP 39
9031: PPUSH
9032: LD_STRING D9c-Ar1-1
9034: PPUSH
9035: CALL_OW 88
9039: IFFALSE 9105
// if Say ( JMM , D9c-JMM-1 ) then
9041: LD_EXP 17
9045: PPUSH
9046: LD_STRING D9c-JMM-1
9048: PPUSH
9049: CALL_OW 88
9053: IFFALSE 9105
// if Say ( Ara1 , D9c-Ar1-2 ) then
9055: LD_EXP 39
9059: PPUSH
9060: LD_STRING D9c-Ar1-2
9062: PPUSH
9063: CALL_OW 88
9067: IFFALSE 9105
// if Say ( Ara3 , D9c-FAr1-2 ) then
9069: LD_EXP 41
9073: PPUSH
9074: LD_STRING D9c-FAr1-2
9076: PPUSH
9077: CALL_OW 88
9081: IFFALSE 9105
// if Say ( Ara1 , D9c-Ar1-3 ) then
9083: LD_EXP 39
9087: PPUSH
9088: LD_STRING D9c-Ar1-3
9090: PPUSH
9091: CALL_OW 88
9095: IFFALSE 9105
// PoskytnouInformace := 2 ;
9097: LD_ADDR_EXP 56
9101: PUSH
9102: LD_INT 2
9104: ST_TO_ADDR
// DialogueOff ;
9105: CALL_OW 7
// end ; end ; for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
9109: LD_ADDR_VAR 0 5
9113: PUSH
9114: LD_INT 22
9116: PUSH
9117: LD_EXP 50
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 21
9128: PUSH
9129: LD_INT 3
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: PPUSH
9140: CALL_OW 69
9144: PUSH
9145: FOR_IN
9146: IFFALSE 9164
// SetSide ( i , you ) ;
9148: LD_VAR 0 5
9152: PPUSH
9153: LD_EXP 47
9157: PPUSH
9158: CALL_OW 235
9162: GO 9145
9164: POP
9165: POP
// if PoskytnouInformace > 0 and IsLive ( ara1 ) and IsLive ( ara2 ) and IsLive ( ara3 ) then
9166: LD_EXP 56
9170: PUSH
9171: LD_INT 0
9173: GREATER
9174: PUSH
9175: LD_EXP 39
9179: PPUSH
9180: CALL_OW 300
9184: AND
9185: PUSH
9186: LD_EXP 40
9190: PPUSH
9191: CALL_OW 300
9195: AND
9196: PUSH
9197: LD_EXP 41
9201: PPUSH
9202: CALL_OW 300
9206: AND
9207: IFFALSE 9385
// begin DialogueOn ;
9209: CALL_OW 6
// if PoskytnouInformace = 2 then
9213: LD_EXP 56
9217: PUSH
9218: LD_INT 2
9220: EQUAL
9221: IFFALSE 9235
// Say ( JMM , D10a-JMM-1 ) ;
9223: LD_EXP 17
9227: PPUSH
9228: LD_STRING D10a-JMM-1
9230: PPUSH
9231: CALL_OW 88
// if PoskytnouInformace = 1 then
9235: LD_EXP 56
9239: PUSH
9240: LD_INT 1
9242: EQUAL
9243: IFFALSE 9257
// Say ( JMM , D10a-JMM-1 ) ;
9245: LD_EXP 17
9249: PPUSH
9250: LD_STRING D10a-JMM-1
9252: PPUSH
9253: CALL_OW 88
// if Say ( Ara1 , D10a-Ar1-1 ) then
9257: LD_EXP 39
9261: PPUSH
9262: LD_STRING D10a-Ar1-1
9264: PPUSH
9265: CALL_OW 88
9269: IFFALSE 9381
// if Say ( Ara2 , D10a-Ar2-1 ) then
9271: LD_EXP 40
9275: PPUSH
9276: LD_STRING D10a-Ar2-1
9278: PPUSH
9279: CALL_OW 88
9283: IFFALSE 9381
// if Say ( Ara3 , D10a-FAr1-1 ) then
9285: LD_EXP 41
9289: PPUSH
9290: LD_STRING D10a-FAr1-1
9292: PPUSH
9293: CALL_OW 88
9297: IFFALSE 9381
// if Say ( Ara2 , D10a-Ar2-2 ) then
9299: LD_EXP 40
9303: PPUSH
9304: LD_STRING D10a-Ar2-2
9306: PPUSH
9307: CALL_OW 88
9311: IFFALSE 9381
// if Say ( Ara3 , D10a-FAr1-2 ) then
9313: LD_EXP 41
9317: PPUSH
9318: LD_STRING D10a-FAr1-2
9320: PPUSH
9321: CALL_OW 88
9325: IFFALSE 9381
// if Say ( Ara1 , D10a-Ar1-2 ) then
9327: LD_EXP 39
9331: PPUSH
9332: LD_STRING D10a-Ar1-2
9334: PPUSH
9335: CALL_OW 88
9339: IFFALSE 9381
// if Say ( JMM , D10a-JMM-2 ) then
9341: LD_EXP 17
9345: PPUSH
9346: LD_STRING D10a-JMM-2
9348: PPUSH
9349: CALL_OW 88
9353: IFFALSE 9381
// if Say ( Ara1 , D10a-Ar1-3 ) then
9355: LD_EXP 39
9359: PPUSH
9360: LD_STRING D10a-Ar1-3
9362: PPUSH
9363: CALL_OW 88
9367: IFFALSE 9381
// Say ( JMM , D10a-JMM-3 ) ;
9369: LD_EXP 17
9373: PPUSH
9374: LD_STRING D10a-JMM-3
9376: PPUSH
9377: CALL_OW 88
// DialogueOff ;
9381: CALL_OW 7
// end ; end ; if ( Aqr1 = 3 ) or ( Aqr1 = 2 and Aqr2 = 2 ) then
9385: LD_EXP 37
9389: PUSH
9390: LD_INT 3
9392: EQUAL
9393: PUSH
9394: LD_EXP 37
9398: PUSH
9399: LD_INT 2
9401: EQUAL
9402: PUSH
9403: LD_EXP 38
9407: PUSH
9408: LD_INT 2
9410: EQUAL
9411: AND
9412: OR
9413: IFFALSE 10626
// begin ara1_faze := 0 ;
9415: LD_ADDR_VAR 0 9
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// ara3_faze := 0 ;
9423: LD_ADDR_VAR 0 10
9427: PUSH
9428: LD_INT 0
9430: ST_TO_ADDR
// while UnitFilter ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
9431: LD_EXP 39
9435: PUSH
9436: LD_EXP 40
9440: PUSH
9441: LD_EXP 41
9445: PUSH
9446: LD_EXP 42
9450: PUSH
9451: LD_EXP 43
9455: PUSH
9456: LD_EXP 44
9460: PUSH
9461: LD_EXP 45
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: LIST
9470: LIST
9471: LIST
9472: LIST
9473: LIST
9474: PPUSH
9475: LD_INT 50
9477: PUSH
9478: EMPTY
9479: LIST
9480: PPUSH
9481: CALL_OW 72
9485: IFFALSE 10624
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 22
9494: PPUSH
9495: LD_INT 22
9497: PUSH
9498: LD_EXP 50
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PUSH
9507: EMPTY
9508: LIST
9509: PPUSH
9510: CALL_OW 70
9514: PUSH
9515: FOR_IN
9516: IFFALSE 9641
// if not ( ( i = Ara1 ) and ( ara1_faze < 2 ) or ( i = Ara3 ) and ( ara3_faze < 2 ) ) then
9518: LD_VAR 0 5
9522: PUSH
9523: LD_EXP 39
9527: EQUAL
9528: PUSH
9529: LD_VAR 0 9
9533: PUSH
9534: LD_INT 2
9536: LESS
9537: AND
9538: PUSH
9539: LD_VAR 0 5
9543: PUSH
9544: LD_EXP 41
9548: EQUAL
9549: PUSH
9550: LD_VAR 0 10
9554: PUSH
9555: LD_INT 2
9557: LESS
9558: AND
9559: OR
9560: NOT
9561: IFFALSE 9639
// begin RemoveUnit ( i ) ;
9563: LD_VAR 0 5
9567: PPUSH
9568: CALL_OW 64
// if i = AraCar1 then
9572: LD_VAR 0 5
9576: PUSH
9577: LD_EXP 44
9581: EQUAL
9582: IFFALSE 9593
// RemoveUnit ( Ara4 ) ;
9584: LD_EXP 42
9588: PPUSH
9589: CALL_OW 64
// if i = AraCar2 then
9593: LD_VAR 0 5
9597: PUSH
9598: LD_EXP 45
9602: EQUAL
9603: IFFALSE 9614
// RemoveUnit ( Ara5 ) ;
9605: LD_EXP 43
9609: PPUSH
9610: CALL_OW 64
// if IsInUnit ( i ) then
9614: LD_VAR 0 5
9618: PPUSH
9619: CALL_OW 310
9623: IFFALSE 9639
// RemoveUnit ( IsInUnit ( i ) ) ;
9625: LD_VAR 0 5
9629: PPUSH
9630: CALL_OW 310
9634: PPUSH
9635: CALL_OW 64
// end ;
9639: GO 9515
9641: POP
9642: POP
// wait ( 0 0$5 ) ;
9643: LD_INT 175
9645: PPUSH
9646: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
9650: LD_EXP 42
9654: PPUSH
9655: CALL_OW 310
9659: NOT
9660: PUSH
9661: LD_EXP 44
9665: PPUSH
9666: CALL_OW 302
9670: NOT
9671: AND
9672: IFFALSE 9686
// ComMoveToArea ( Ara4 , arab_exit ) ;
9674: LD_EXP 42
9678: PPUSH
9679: LD_INT 22
9681: PPUSH
9682: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
9686: LD_EXP 43
9690: PPUSH
9691: CALL_OW 310
9695: NOT
9696: PUSH
9697: LD_EXP 45
9701: PPUSH
9702: CALL_OW 302
9706: NOT
9707: AND
9708: IFFALSE 9722
// ComMoveToArea ( Ara5 , arab_exit ) ;
9710: LD_EXP 43
9714: PPUSH
9715: LD_INT 22
9717: PPUSH
9718: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
9722: LD_EXP 42
9726: PPUSH
9727: CALL_OW 310
9731: NOT
9732: PUSH
9733: LD_EXP 44
9737: PPUSH
9738: CALL_OW 261
9742: PUSH
9743: LD_INT 0
9745: GREATER
9746: AND
9747: PUSH
9748: LD_EXP 44
9752: PPUSH
9753: CALL_OW 302
9757: AND
9758: IFFALSE 9774
// ComEnterUnit ( Ara4 , AraCar1 ) ;
9760: LD_EXP 42
9764: PPUSH
9765: LD_EXP 44
9769: PPUSH
9770: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
9774: LD_EXP 43
9778: PPUSH
9779: CALL_OW 310
9783: NOT
9784: PUSH
9785: LD_EXP 45
9789: PPUSH
9790: CALL_OW 261
9794: PUSH
9795: LD_INT 0
9797: GREATER
9798: AND
9799: PUSH
9800: LD_EXP 45
9804: PPUSH
9805: CALL_OW 302
9809: AND
9810: IFFALSE 9826
// ComEnterUnit ( Ara5 , AraCar2 ) ;
9812: LD_EXP 43
9816: PPUSH
9817: LD_EXP 45
9821: PPUSH
9822: CALL_OW 120
// ComMoveToArea ( [ Ara2 , AraCar1 , AraCar2 ] , arab_exit ) ;
9826: LD_EXP 40
9830: PUSH
9831: LD_EXP 44
9835: PUSH
9836: LD_EXP 45
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: LIST
9845: PPUSH
9846: LD_INT 22
9848: PPUSH
9849: CALL_OW 113
// AddComMoveXY ( [ Ara2 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
9853: LD_EXP 40
9857: PUSH
9858: LD_EXP 44
9862: PUSH
9863: LD_EXP 45
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: LIST
9872: PPUSH
9873: LD_INT 37
9875: PPUSH
9876: LD_INT 72
9878: PPUSH
9879: CALL_OW 171
// case true of not IsOk ( Ara1 ) :
9883: LD_INT 1
9885: PUSH
9886: LD_EXP 39
9890: PPUSH
9891: CALL_OW 302
9895: NOT
9896: DOUBLE
9897: EQUAL
9898: IFTRUE 9902
9900: GO 9913
9902: POP
// ara1_faze := 4 ; ( GetDistUnitXY ( Ara1 , 57 , 76 ) < 5 ) and ara1_faze = 2 :
9903: LD_ADDR_VAR 0 9
9907: PUSH
9908: LD_INT 4
9910: ST_TO_ADDR
9911: GO 10061
9913: LD_EXP 39
9917: PPUSH
9918: LD_INT 57
9920: PPUSH
9921: LD_INT 76
9923: PPUSH
9924: CALL_OW 297
9928: PUSH
9929: LD_INT 5
9931: LESS
9932: PUSH
9933: LD_VAR 0 9
9937: PUSH
9938: LD_INT 2
9940: EQUAL
9941: AND
9942: DOUBLE
9943: EQUAL
9944: IFTRUE 9948
9946: GO 9959
9948: POP
// ara1_faze := 3 ; MineOfUnit ( Ara1 ) <> 0 and ara1_faze = 1 :
9949: LD_ADDR_VAR 0 9
9953: PUSH
9954: LD_INT 3
9956: ST_TO_ADDR
9957: GO 10061
9959: LD_EXP 39
9963: PPUSH
9964: CALL_OW 459
9968: PUSH
9969: LD_INT 0
9971: NONEQUAL
9972: PUSH
9973: LD_VAR 0 9
9977: PUSH
9978: LD_INT 1
9980: EQUAL
9981: AND
9982: DOUBLE
9983: EQUAL
9984: IFTRUE 9988
9986: GO 10014
9988: POP
// begin ara1_faze := 2 ;
9989: LD_ADDR_VAR 0 9
9993: PUSH
9994: LD_INT 2
9996: ST_TO_ADDR
// mina1 := MineOfUnit ( Ara1 ) ;
9997: LD_ADDR_EXP 77
10001: PUSH
10002: LD_EXP 39
10006: PPUSH
10007: CALL_OW 459
10011: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara1 , 58 , 76 ) < 5 ) and ara1_faze = 0 :
10012: GO 10061
10014: LD_EXP 39
10018: PPUSH
10019: LD_INT 58
10021: PPUSH
10022: LD_INT 76
10024: PPUSH
10025: CALL_OW 297
10029: PUSH
10030: LD_INT 5
10032: LESS
10033: PUSH
10034: LD_VAR 0 9
10038: PUSH
10039: LD_INT 0
10041: EQUAL
10042: AND
10043: DOUBLE
10044: EQUAL
10045: IFTRUE 10049
10047: GO 10060
10049: POP
// ara1_faze := 1 ; end ;
10050: LD_ADDR_VAR 0 9
10054: PUSH
10055: LD_INT 1
10057: ST_TO_ADDR
10058: GO 10061
10060: POP
// case ara1_faze of 0 :
10061: LD_VAR 0 9
10065: PUSH
10066: LD_INT 0
10068: DOUBLE
10069: EQUAL
10070: IFTRUE 10074
10072: GO 10092
10074: POP
// ComMoveXY ( Ara1 , 58 , 76 ) ; 1 :
10075: LD_EXP 39
10079: PPUSH
10080: LD_INT 58
10082: PPUSH
10083: LD_INT 76
10085: PPUSH
10086: CALL_OW 111
10090: GO 10188
10092: LD_INT 1
10094: DOUBLE
10095: EQUAL
10096: IFTRUE 10100
10098: GO 10123
10100: POP
// ComPlaceRemoteCharge ( Ara1 , 0 , 0 , ruDepot1 ) ; 2 :
10101: LD_EXP 39
10105: PPUSH
10106: LD_INT 0
10108: PPUSH
10109: LD_INT 0
10111: PPUSH
10112: LD_EXP 67
10116: PPUSH
10117: CALL_OW 133
10121: GO 10188
10123: LD_INT 2
10125: DOUBLE
10126: EQUAL
10127: IFTRUE 10131
10129: GO 10149
10131: POP
// ComMoveXY ( Ara1 , 57 , 76 ) ; 3 :
10132: LD_EXP 39
10136: PPUSH
10137: LD_INT 57
10139: PPUSH
10140: LD_INT 76
10142: PPUSH
10143: CALL_OW 111
10147: GO 10188
10149: LD_INT 3
10151: DOUBLE
10152: EQUAL
10153: IFTRUE 10157
10155: GO 10187
10157: POP
// begin ComMoveToArea ( Ara1 , arab_exit ) ;
10158: LD_EXP 39
10162: PPUSH
10163: LD_INT 22
10165: PPUSH
10166: CALL_OW 113
// AddComMoveXY ( Ara1 , 37 , 72 ) ;
10170: LD_EXP 39
10174: PPUSH
10175: LD_INT 37
10177: PPUSH
10178: LD_INT 72
10180: PPUSH
10181: CALL_OW 171
// end ; end ;
10185: GO 10188
10187: POP
// case true of not IsOk ( Ara3 ) :
10188: LD_INT 1
10190: PUSH
10191: LD_EXP 41
10195: PPUSH
10196: CALL_OW 302
10200: NOT
10201: DOUBLE
10202: EQUAL
10203: IFTRUE 10207
10205: GO 10218
10207: POP
// ara3_faze := 4 ; ( GetDistUnitXY ( Ara3 , 58 , 76 ) < 5 ) and ara3_faze = 2 :
10208: LD_ADDR_VAR 0 10
10212: PUSH
10213: LD_INT 4
10215: ST_TO_ADDR
10216: GO 10366
10218: LD_EXP 41
10222: PPUSH
10223: LD_INT 58
10225: PPUSH
10226: LD_INT 76
10228: PPUSH
10229: CALL_OW 297
10233: PUSH
10234: LD_INT 5
10236: LESS
10237: PUSH
10238: LD_VAR 0 10
10242: PUSH
10243: LD_INT 2
10245: EQUAL
10246: AND
10247: DOUBLE
10248: EQUAL
10249: IFTRUE 10253
10251: GO 10264
10253: POP
// ara3_faze := 3 ; MineOfUnit ( Ara3 ) <> 0 and ara3_faze = 1 :
10254: LD_ADDR_VAR 0 10
10258: PUSH
10259: LD_INT 3
10261: ST_TO_ADDR
10262: GO 10366
10264: LD_EXP 41
10268: PPUSH
10269: CALL_OW 459
10273: PUSH
10274: LD_INT 0
10276: NONEQUAL
10277: PUSH
10278: LD_VAR 0 10
10282: PUSH
10283: LD_INT 1
10285: EQUAL
10286: AND
10287: DOUBLE
10288: EQUAL
10289: IFTRUE 10293
10291: GO 10319
10293: POP
// begin ara3_faze := 2 ;
10294: LD_ADDR_VAR 0 10
10298: PUSH
10299: LD_INT 2
10301: ST_TO_ADDR
// mina3 := MineOfUnit ( Ara3 ) ;
10302: LD_ADDR_EXP 78
10306: PUSH
10307: LD_EXP 41
10311: PPUSH
10312: CALL_OW 459
10316: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara3 , 70 , 104 ) < 5 ) and ara3_faze = 0 :
10317: GO 10366
10319: LD_EXP 41
10323: PPUSH
10324: LD_INT 70
10326: PPUSH
10327: LD_INT 104
10329: PPUSH
10330: CALL_OW 297
10334: PUSH
10335: LD_INT 5
10337: LESS
10338: PUSH
10339: LD_VAR 0 10
10343: PUSH
10344: LD_INT 0
10346: EQUAL
10347: AND
10348: DOUBLE
10349: EQUAL
10350: IFTRUE 10354
10352: GO 10365
10354: POP
// ara3_faze := 1 ; end ;
10355: LD_ADDR_VAR 0 10
10359: PUSH
10360: LD_INT 1
10362: ST_TO_ADDR
10363: GO 10366
10365: POP
// case ara3_faze of 0 :
10366: LD_VAR 0 10
10370: PUSH
10371: LD_INT 0
10373: DOUBLE
10374: EQUAL
10375: IFTRUE 10379
10377: GO 10397
10379: POP
// ComMoveXY ( Ara3 , 70 , 104 ) ; 1 :
10380: LD_EXP 41
10384: PPUSH
10385: LD_INT 70
10387: PPUSH
10388: LD_INT 104
10390: PPUSH
10391: CALL_OW 111
10395: GO 10493
10397: LD_INT 1
10399: DOUBLE
10400: EQUAL
10401: IFTRUE 10405
10403: GO 10428
10405: POP
// ComPlaceRemoteCharge ( Ara3 , 0 , 0 , ruDepot1 ) ; 2 :
10406: LD_EXP 41
10410: PPUSH
10411: LD_INT 0
10413: PPUSH
10414: LD_INT 0
10416: PPUSH
10417: LD_EXP 67
10421: PPUSH
10422: CALL_OW 133
10426: GO 10493
10428: LD_INT 2
10430: DOUBLE
10431: EQUAL
10432: IFTRUE 10436
10434: GO 10454
10436: POP
// ComMoveXY ( Ara3 , 58 , 76 ) ; 3 :
10437: LD_EXP 41
10441: PPUSH
10442: LD_INT 58
10444: PPUSH
10445: LD_INT 76
10447: PPUSH
10448: CALL_OW 111
10452: GO 10493
10454: LD_INT 3
10456: DOUBLE
10457: EQUAL
10458: IFTRUE 10462
10460: GO 10492
10462: POP
// begin ComMoveToArea ( Ara3 , arab_exit ) ;
10463: LD_EXP 41
10467: PPUSH
10468: LD_INT 22
10470: PPUSH
10471: CALL_OW 113
// AddComMoveXY ( Ara3 , 37 , 72 ) ;
10475: LD_EXP 41
10479: PPUSH
10480: LD_INT 37
10482: PPUSH
10483: LD_INT 72
10485: PPUSH
10486: CALL_OW 171
// end ; end ;
10490: GO 10493
10492: POP
// if not kecy and ara1_faze >= 3 and ara3_faze >= 3 then
10493: LD_EXP 76
10497: NOT
10498: PUSH
10499: LD_VAR 0 9
10503: PUSH
10504: LD_INT 3
10506: GREATEREQUAL
10507: AND
10508: PUSH
10509: LD_VAR 0 10
10513: PUSH
10514: LD_INT 3
10516: GREATEREQUAL
10517: AND
10518: IFFALSE 10622
// begin if odmitl_v_query then
10520: LD_VAR 0 11
10524: IFFALSE 10540
// Say ( Ara2 , D11b-Ar1-1 ) else
10526: LD_EXP 40
10530: PPUSH
10531: LD_STRING D11b-Ar1-1
10533: PPUSH
10534: CALL_OW 88
10538: GO 10552
// Say ( Ara2 , D11a-Ar1-1 ) ;
10540: LD_EXP 40
10544: PPUSH
10545: LD_STRING D11a-Ar1-1
10547: PPUSH
10548: CALL_OW 88
// if mina1 then
10552: LD_EXP 77
10556: IFFALSE 10583
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
10558: LD_EXP 77
10562: PUSH
10563: LD_INT 1
10565: ARRAY
10566: PPUSH
10567: LD_EXP 77
10571: PUSH
10572: LD_INT 2
10574: ARRAY
10575: PPUSH
10576: LD_INT 1200
10578: PPUSH
10579: CALL_OW 453
// if mina3 then
10583: LD_EXP 78
10587: IFFALSE 10614
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
10589: LD_EXP 78
10593: PUSH
10594: LD_INT 1
10596: ARRAY
10597: PPUSH
10598: LD_EXP 78
10602: PUSH
10603: LD_INT 2
10605: ARRAY
10606: PPUSH
10607: LD_INT 1200
10609: PPUSH
10610: CALL_OW 453
// kecy := true ;
10614: LD_ADDR_EXP 76
10618: PUSH
10619: LD_INT 1
10621: ST_TO_ADDR
// end ; end ;
10622: GO 9431
// end else
10624: GO 11035
// begin while UnitFilter ( [ Ara2 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
10626: LD_EXP 40
10630: PUSH
10631: LD_EXP 44
10635: PUSH
10636: LD_EXP 45
10640: PUSH
10641: EMPTY
10642: LIST
10643: LIST
10644: LIST
10645: PPUSH
10646: LD_INT 50
10648: PUSH
10649: EMPTY
10650: LIST
10651: PPUSH
10652: CALL_OW 72
10656: IFFALSE 11035
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
10658: LD_ADDR_VAR 0 5
10662: PUSH
10663: LD_INT 22
10665: PPUSH
10666: LD_INT 22
10668: PUSH
10669: LD_EXP 50
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PUSH
10678: EMPTY
10679: LIST
10680: PPUSH
10681: CALL_OW 70
10685: PUSH
10686: FOR_IN
10687: IFFALSE 10767
// begin RemoveUnit ( i ) ;
10689: LD_VAR 0 5
10693: PPUSH
10694: CALL_OW 64
// if i = AraCar1 then
10698: LD_VAR 0 5
10702: PUSH
10703: LD_EXP 44
10707: EQUAL
10708: IFFALSE 10719
// RemoveUnit ( Ara4 ) ;
10710: LD_EXP 42
10714: PPUSH
10715: CALL_OW 64
// if i = AraCar2 then
10719: LD_VAR 0 5
10723: PUSH
10724: LD_EXP 45
10728: EQUAL
10729: IFFALSE 10740
// RemoveUnit ( Ara5 ) ;
10731: LD_EXP 43
10735: PPUSH
10736: CALL_OW 64
// if IsInUnit ( i ) then
10740: LD_VAR 0 5
10744: PPUSH
10745: CALL_OW 310
10749: IFFALSE 10765
// RemoveUnit ( IsInUnit ( i ) ) ;
10751: LD_VAR 0 5
10755: PPUSH
10756: CALL_OW 310
10760: PPUSH
10761: CALL_OW 64
// end ;
10765: GO 10686
10767: POP
10768: POP
// wait ( 0 0$1 ) ;
10769: LD_INT 35
10771: PPUSH
10772: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
10776: LD_EXP 42
10780: PPUSH
10781: CALL_OW 310
10785: NOT
10786: PUSH
10787: LD_EXP 44
10791: PPUSH
10792: CALL_OW 302
10796: NOT
10797: AND
10798: IFFALSE 10812
// ComMoveToArea ( Ara4 , arab_exit ) ;
10800: LD_EXP 42
10804: PPUSH
10805: LD_INT 22
10807: PPUSH
10808: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
10812: LD_EXP 43
10816: PPUSH
10817: CALL_OW 310
10821: NOT
10822: PUSH
10823: LD_EXP 45
10827: PPUSH
10828: CALL_OW 302
10832: NOT
10833: AND
10834: IFFALSE 10848
// ComMoveToArea ( Ara5 , arab_exit ) ;
10836: LD_EXP 43
10840: PPUSH
10841: LD_INT 22
10843: PPUSH
10844: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
10848: LD_EXP 42
10852: PPUSH
10853: CALL_OW 310
10857: NOT
10858: PUSH
10859: LD_EXP 44
10863: PPUSH
10864: CALL_OW 261
10868: PUSH
10869: LD_INT 0
10871: GREATER
10872: AND
10873: PUSH
10874: LD_EXP 44
10878: PPUSH
10879: CALL_OW 302
10883: AND
10884: IFFALSE 10900
// ComEnterUnit ( Ara4 , AraCar1 ) ;
10886: LD_EXP 42
10890: PPUSH
10891: LD_EXP 44
10895: PPUSH
10896: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
10900: LD_EXP 43
10904: PPUSH
10905: CALL_OW 310
10909: NOT
10910: PUSH
10911: LD_EXP 45
10915: PPUSH
10916: CALL_OW 261
10920: PUSH
10921: LD_INT 0
10923: GREATER
10924: AND
10925: PUSH
10926: LD_EXP 45
10930: PPUSH
10931: CALL_OW 302
10935: AND
10936: IFFALSE 10952
// ComEnterUnit ( Ara5 , AraCar2 ) ;
10938: LD_EXP 43
10942: PPUSH
10943: LD_EXP 45
10947: PPUSH
10948: CALL_OW 120
// ComMoveToArea ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , arab_exit ) ;
10952: LD_EXP 39
10956: PUSH
10957: LD_EXP 40
10961: PUSH
10962: LD_EXP 41
10966: PUSH
10967: LD_EXP 44
10971: PUSH
10972: LD_EXP 45
10976: PUSH
10977: EMPTY
10978: LIST
10979: LIST
10980: LIST
10981: LIST
10982: LIST
10983: PPUSH
10984: LD_INT 22
10986: PPUSH
10987: CALL_OW 113
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
10991: LD_EXP 39
10995: PUSH
10996: LD_EXP 40
11000: PUSH
11001: LD_EXP 41
11005: PUSH
11006: LD_EXP 44
11010: PUSH
11011: LD_EXP 45
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: PPUSH
11023: LD_INT 37
11025: PPUSH
11026: LD_INT 72
11028: PPUSH
11029: CALL_OW 171
// end ;
11033: GO 10626
// end ; end ;
11035: LD_VAR 0 1
11039: RET
// every 0 0$1 do var who , a_maj_to , a , i ;
11040: GO 11042
11042: DISABLE
11043: LD_INT 0
11045: PPUSH
11046: PPUSH
11047: PPUSH
11048: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
11049: LD_ADDR_VAR 0 3
11053: PUSH
11054: LD_INT 22
11056: PUSH
11057: LD_EXP 47
11061: PUSH
11062: EMPTY
11063: LIST
11064: LIST
11065: PUSH
11066: EMPTY
11067: LIST
11068: PPUSH
11069: CALL_OW 69
11073: ST_TO_ADDR
// for i in a do
11074: LD_ADDR_VAR 0 4
11078: PUSH
11079: LD_VAR 0 3
11083: PUSH
11084: FOR_IN
11085: IFFALSE 11155
// if WantsToAttack ( i ) in [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] then
11087: LD_VAR 0 4
11091: PPUSH
11092: CALL_OW 319
11096: PUSH
11097: LD_EXP 39
11101: PUSH
11102: LD_EXP 40
11106: PUSH
11107: LD_EXP 41
11111: PUSH
11112: LD_EXP 42
11116: PUSH
11117: LD_EXP 43
11121: PUSH
11122: LD_EXP 44
11126: PUSH
11127: LD_EXP 45
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: IN
11141: IFFALSE 11153
// begin a_maj_to := true ;
11143: LD_ADDR_VAR 0 2
11147: PUSH
11148: LD_INT 1
11150: ST_TO_ADDR
// break ;
11151: GO 11155
// end ;
11153: GO 11084
11155: POP
11156: POP
// if a_maj_to then
11157: LD_VAR 0 2
11161: IFFALSE 11338
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
11163: LD_EXP 47
11167: PPUSH
11168: LD_EXP 50
11172: PPUSH
11173: LD_INT 2
11175: PPUSH
11176: LD_INT 1
11178: PPUSH
11179: CALL_OW 80
// who := WhoSayAny ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] , arabians , sex_male , 0 , 0 ) ;
11183: LD_ADDR_VAR 0 1
11187: PUSH
11188: LD_EXP 39
11192: PUSH
11193: LD_EXP 40
11197: PUSH
11198: LD_EXP 41
11202: PUSH
11203: LD_EXP 42
11207: PUSH
11208: LD_EXP 43
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: PPUSH
11220: LD_EXP 50
11224: PPUSH
11225: LD_INT 1
11227: PPUSH
11228: LD_INT 0
11230: PPUSH
11231: LD_INT 0
11233: PPUSH
11234: CALL 13004 0 5
11238: ST_TO_ADDR
// if not kecy then
11239: LD_EXP 76
11243: NOT
11244: IFFALSE 11336
// begin DialogueOn ;
11246: CALL_OW 6
// Say ( who , D11a-Ar1-1 ) ;
11250: LD_VAR 0 1
11254: PPUSH
11255: LD_STRING D11a-Ar1-1
11257: PPUSH
11258: CALL_OW 88
// DialogueOff ;
11262: CALL_OW 7
// kecy := true ;
11266: LD_ADDR_EXP 76
11270: PUSH
11271: LD_INT 1
11273: ST_TO_ADDR
// if mina1 then
11274: LD_EXP 77
11278: IFFALSE 11305
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
11280: LD_EXP 77
11284: PUSH
11285: LD_INT 1
11287: ARRAY
11288: PPUSH
11289: LD_EXP 77
11293: PUSH
11294: LD_INT 2
11296: ARRAY
11297: PPUSH
11298: LD_INT 1200
11300: PPUSH
11301: CALL_OW 453
// if mina3 then
11305: LD_EXP 78
11309: IFFALSE 11336
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
11311: LD_EXP 78
11315: PUSH
11316: LD_INT 1
11318: ARRAY
11319: PPUSH
11320: LD_EXP 78
11324: PUSH
11325: LD_INT 2
11327: ARRAY
11328: PPUSH
11329: LD_INT 1200
11331: PPUSH
11332: CALL_OW 453
// end ; end else
11336: GO 11339
// enable ;
11338: ENABLE
// end ;
11339: PPOPN 4
11341: END
// every 45 45$30 do
11342: GO 11344
11344: DISABLE
// begin DialogueOn ;
11345: CALL_OW 6
// SayRadio ( Powell , D12-Pow-1 ) ;
11349: LD_EXP 16
11353: PPUSH
11354: LD_STRING D12-Pow-1
11356: PPUSH
11357: CALL_OW 94
// ChangeMissionObjectives ( M4 ) ;
11361: LD_STRING M4
11363: PPUSH
11364: CALL_OW 337
// EndEnable := true ;
11368: LD_ADDR_EXP 80
11372: PUSH
11373: LD_INT 1
11375: ST_TO_ADDR
// SetAreaMapShow ( exit_area , 1 ) ;
11376: LD_INT 32
11378: PPUSH
11379: LD_INT 1
11381: PPUSH
11382: CALL_OW 424
// DialogueOff ;
11386: CALL_OW 7
// end ;
11390: END
// export konec ; every 55 55$0 do
11391: GO 11393
11393: DISABLE
// begin Konec := true ;
11394: LD_ADDR_EXP 79
11398: PUSH
11399: LD_INT 1
11401: ST_TO_ADDR
// end ;
11402: END
// export EndEnable , TimerCas ; every 0 0$1 do var k , br , zbyva ;
11403: GO 11405
11405: DISABLE
11406: LD_INT 0
11408: PPUSH
11409: PPUSH
11410: PPUSH
// begin if testing then
11411: LD_EXP 4
11415: IFFALSE 11471
// display_strings := [ [ game time:  & ( tick div 1 1$0 ) & :  & ( ( tick - ( tick div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] else
11417: LD_ADDR_OWVAR 47
11421: PUSH
11422: LD_STRING game time: 
11424: PUSH
11425: LD_OWVAR 1
11429: PUSH
11430: LD_INT 2100
11432: DIV
11433: STR
11434: PUSH
11435: LD_STRING : 
11437: STR
11438: PUSH
11439: LD_OWVAR 1
11443: PUSH
11444: LD_OWVAR 1
11448: PUSH
11449: LD_INT 2100
11451: DIV
11452: PUSH
11453: LD_INT 2100
11455: MUL
11456: MINUS
11457: PUSH
11458: LD_INT 35
11460: DIV
11461: STR
11462: PUSH
11463: EMPTY
11464: LIST
11465: PUSH
11466: EMPTY
11467: LIST
11468: ST_TO_ADDR
11469: GO 11478
// display_strings := [ ] ;
11471: LD_ADDR_OWVAR 47
11475: PUSH
11476: EMPTY
11477: ST_TO_ADDR
// zbyva := 60 - GetResourceType ( getbase ( depot1 ) , mat_siberit ) ;
11478: LD_ADDR_VAR 0 3
11482: PUSH
11483: LD_INT 60
11485: PUSH
11486: LD_EXP 69
11490: PPUSH
11491: CALL_OW 274
11495: PPUSH
11496: LD_INT 3
11498: PPUSH
11499: CALL_OW 275
11503: MINUS
11504: ST_TO_ADDR
// if zbyva < 0 then
11505: LD_VAR 0 3
11509: PUSH
11510: LD_INT 0
11512: LESS
11513: IFFALSE 11523
// zbyva := 0 ;
11515: LD_ADDR_VAR 0 3
11519: PUSH
11520: LD_INT 0
11522: ST_TO_ADDR
// if counter_time then
11523: LD_EXP 64
11527: IFFALSE 11564
// display_strings := display_strings ^ [ #Am09-1 , zbyva , counter_time - tick ] ;
11529: LD_ADDR_OWVAR 47
11533: PUSH
11534: LD_OWVAR 47
11538: PUSH
11539: LD_STRING #Am09-1
11541: PUSH
11542: LD_VAR 0 3
11546: PUSH
11547: LD_EXP 64
11551: PUSH
11552: LD_OWVAR 1
11556: MINUS
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: LIST
11562: ADD
11563: ST_TO_ADDR
// if Konec and GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and ( IsOK ( JMM ) ) then
11564: LD_EXP 79
11568: PUSH
11569: LD_EXP 69
11573: PPUSH
11574: CALL_OW 274
11578: PPUSH
11579: LD_INT 3
11581: PPUSH
11582: CALL_OW 275
11586: PUSH
11587: LD_INT 20
11589: GREATEREQUAL
11590: AND
11591: PUSH
11592: LD_EXP 17
11596: PPUSH
11597: CALL_OW 302
11601: AND
11602: IFFALSE 11608
// begin Vyhra ;
11604: CALL 2796 0 0
// end ; if TimerEnable then
11608: LD_EXP 63
11612: IFFALSE 11673
// begin if ContactTime ( russians ) > ( TimerCas + 0 0$45 ) then
11614: LD_EXP 49
11618: PPUSH
11619: CALL_OW 462
11623: PUSH
11624: LD_EXP 81
11628: PUSH
11629: LD_INT 1575
11631: PLUS
11632: GREATER
11633: IFFALSE 11673
// begin if GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and ( IsOK ( JMM ) ) then
11635: LD_EXP 69
11639: PPUSH
11640: CALL_OW 274
11644: PPUSH
11645: LD_INT 3
11647: PPUSH
11648: CALL_OW 275
11652: PUSH
11653: LD_INT 20
11655: GREATEREQUAL
11656: PUSH
11657: LD_EXP 17
11661: PPUSH
11662: CALL_OW 302
11666: AND
11667: IFFALSE 11673
// begin Vyhra ;
11669: CALL 2796 0 0
// end ; end ; end ; if EndEnable then
11673: LD_EXP 80
11677: IFFALSE 11866
// begin if timer < 0 then
11679: LD_EXP 62
11683: PUSH
11684: LD_INT 0
11686: LESS
11687: IFFALSE 11697
// timer := 0 ;
11689: LD_ADDR_EXP 62
11693: PUSH
11694: LD_INT 0
11696: ST_TO_ADDR
// timer := timer - 0 0$1 ;
11697: LD_ADDR_EXP 62
11701: PUSH
11702: LD_EXP 62
11706: PUSH
11707: LD_INT 35
11709: MINUS
11710: ST_TO_ADDR
// if testing then
11711: LD_EXP 4
11715: IFFALSE 11771
// display_strings := display_strings ^ [ [ ( timer div 1 1$0 ) & :  & ( ( timer - ( timer div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] ;
11717: LD_ADDR_OWVAR 47
11721: PUSH
11722: LD_OWVAR 47
11726: PUSH
11727: LD_EXP 62
11731: PUSH
11732: LD_INT 2100
11734: DIV
11735: PUSH
11736: LD_STRING : 
11738: STR
11739: PUSH
11740: LD_EXP 62
11744: PUSH
11745: LD_EXP 62
11749: PUSH
11750: LD_INT 2100
11752: DIV
11753: PUSH
11754: LD_INT 2100
11756: MUL
11757: MINUS
11758: PUSH
11759: LD_INT 35
11761: DIV
11762: STR
11763: PUSH
11764: EMPTY
11765: LIST
11766: PUSH
11767: EMPTY
11768: LIST
11769: ADD
11770: ST_TO_ADDR
// if not FilterUnitsExceptArea ( exit_area , [ [ f_ok ] , [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] ] ) and GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and IsInArea ( JMM , exit_area ) then
11771: LD_INT 32
11773: PPUSH
11774: LD_INT 50
11776: PUSH
11777: EMPTY
11778: LIST
11779: PUSH
11780: LD_INT 22
11782: PUSH
11783: LD_EXP 47
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: PUSH
11792: LD_INT 23
11794: PUSH
11795: LD_INT 1
11797: PUSH
11798: EMPTY
11799: LIST
11800: LIST
11801: PUSH
11802: LD_INT 21
11804: PUSH
11805: LD_INT 1
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: PPUSH
11818: CALL_OW 71
11822: NOT
11823: PUSH
11824: LD_EXP 69
11828: PPUSH
11829: CALL_OW 274
11833: PPUSH
11834: LD_INT 3
11836: PPUSH
11837: CALL_OW 275
11841: PUSH
11842: LD_INT 20
11844: GREATEREQUAL
11845: AND
11846: PUSH
11847: LD_EXP 17
11851: PPUSH
11852: LD_INT 32
11854: PPUSH
11855: CALL_OW 308
11859: AND
11860: IFFALSE 11866
// Vyhra ;
11862: CALL 2796 0 0
// end ; enable ;
11866: ENABLE
// end ;
11867: PPOPN 3
11869: END
// var was_QE ; function QE ; begin
11870: LD_INT 0
11872: PPUSH
// was_QE := true ;
11873: LD_ADDR_LOC 1
11877: PUSH
11878: LD_INT 1
11880: ST_TO_ADDR
// if Query ( QE ) = 2 then
11881: LD_STRING QE
11883: PPUSH
11884: CALL_OW 97
11888: PUSH
11889: LD_INT 2
11891: EQUAL
11892: IFFALSE 11898
// Vyhra ;
11894: CALL 2796 0 0
// end ; end_of_file
11898: LD_VAR 0 1
11902: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
11907: PPUSH
// see_any_r := false ;
11908: LD_ADDR_VAR 0 5
11912: PUSH
11913: LD_INT 0
11915: ST_TO_ADDR
// for sai in sez2 do
11916: LD_ADDR_VAR 0 4
11920: PUSH
11921: LD_VAR 0 2
11925: PUSH
11926: FOR_IN
11927: IFFALSE 11957
// if See ( strana , sai ) then
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 4
11938: PPUSH
11939: CALL_OW 292
11943: IFFALSE 11955
// begin see_any_r := true ;
11945: LD_ADDR_VAR 0 5
11949: PUSH
11950: LD_INT 1
11952: ST_TO_ADDR
// break ;
11953: GO 11957
// end ;
11955: GO 11926
11957: POP
11958: POP
// ; result := see_any_r ;
11959: LD_ADDR_VAR 0 3
11963: PUSH
11964: LD_VAR 0 5
11968: ST_TO_ADDR
// end ;
11969: LD_VAR 0 3
11973: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
11974: LD_INT 0
11976: PPUSH
11977: PPUSH
11978: PPUSH
11979: PPUSH
// for i in who do
11980: LD_ADDR_VAR 0 6
11984: PUSH
11985: LD_VAR 0 1
11989: PUSH
11990: FOR_IN
11991: IFFALSE 12062
// begin for j in what do
11993: LD_ADDR_VAR 0 7
11997: PUSH
11998: LD_VAR 0 3
12002: PUSH
12003: FOR_IN
12004: IFFALSE 12058
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
12006: LD_VAR 0 7
12010: PPUSH
12011: CALL_OW 311
12015: NOT
12016: PUSH
12017: LD_VAR 0 6
12021: PPUSH
12022: LD_VAR 0 7
12026: PPUSH
12027: CALL_OW 296
12031: PUSH
12032: LD_VAR 0 2
12036: LESSEQUAL
12037: AND
12038: IFFALSE 12056
// begin ComEnterUnit ( i , j ) ;
12040: LD_VAR 0 6
12044: PPUSH
12045: LD_VAR 0 7
12049: PPUSH
12050: CALL_OW 120
// break ;
12054: GO 12058
// end ; end ;
12056: GO 12003
12058: POP
12059: POP
// end ;
12060: GO 11990
12062: POP
12063: POP
// end ;
12064: LD_VAR 0 4
12068: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
12069: LD_INT 0
12071: PPUSH
12072: PPUSH
12073: PPUSH
12074: PPUSH
// for i in who do
12075: LD_ADDR_VAR 0 6
12079: PUSH
12080: LD_VAR 0 1
12084: PUSH
12085: FOR_IN
12086: IFFALSE 12185
// begin add := false ;
12088: LD_ADDR_VAR 0 5
12092: PUSH
12093: LD_INT 0
12095: ST_TO_ADDR
// for j in what do
12096: LD_ADDR_VAR 0 7
12100: PUSH
12101: LD_VAR 0 3
12105: PUSH
12106: FOR_IN
12107: IFFALSE 12141
// begin if GetDistUnits ( i , j ) <= dist then
12109: LD_VAR 0 6
12113: PPUSH
12114: LD_VAR 0 7
12118: PPUSH
12119: CALL_OW 296
12123: PUSH
12124: LD_VAR 0 2
12128: LESSEQUAL
12129: IFFALSE 12139
// begin add := true ;
12131: LD_ADDR_VAR 0 5
12135: PUSH
12136: LD_INT 1
12138: ST_TO_ADDR
// end ; end ;
12139: GO 12106
12141: POP
12142: POP
// if add then
12143: LD_VAR 0 5
12147: IFFALSE 12183
// begin if result then
12149: LD_VAR 0 4
12153: IFFALSE 12173
// result := result ^ i else
12155: LD_ADDR_VAR 0 4
12159: PUSH
12160: LD_VAR 0 4
12164: PUSH
12165: LD_VAR 0 6
12169: ADD
12170: ST_TO_ADDR
12171: GO 12183
// result := i ;
12173: LD_ADDR_VAR 0 4
12177: PUSH
12178: LD_VAR 0 6
12182: ST_TO_ADDR
// end ; end ;
12183: GO 12085
12185: POP
12186: POP
// end ;
12187: LD_VAR 0 4
12191: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
12192: LD_INT 0
12194: PPUSH
12195: PPUSH
12196: PPUSH
// i1 := 1 ;
12197: LD_ADDR_VAR 0 5
12201: PUSH
12202: LD_INT 1
12204: ST_TO_ADDR
// while i1 <= path do
12205: LD_VAR 0 5
12209: PUSH
12210: LD_VAR 0 2
12214: LESSEQUAL
12215: IFFALSE 12462
// begin a := path [ i1 ] ;
12217: LD_ADDR_VAR 0 6
12221: PUSH
12222: LD_VAR 0 2
12226: PUSH
12227: LD_VAR 0 5
12231: ARRAY
12232: ST_TO_ADDR
// if a < 0 then
12233: LD_VAR 0 6
12237: PUSH
12238: LD_INT 0
12240: LESS
12241: IFFALSE 12298
// begin while a <= - 1 do
12243: LD_VAR 0 6
12247: PUSH
12248: LD_INT 1
12250: NEG
12251: LESSEQUAL
12252: IFFALSE 12282
// begin a := a + 1 ;
12254: LD_ADDR_VAR 0 6
12258: PUSH
12259: LD_VAR 0 6
12263: PUSH
12264: LD_INT 1
12266: PLUS
12267: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
12268: LD_VAR 0 1
12272: PPUSH
12273: LD_INT 35
12275: PPUSH
12276: CALL_OW 202
// end ;
12280: GO 12243
// i1 := i1 + 1 ;
12282: LD_ADDR_VAR 0 5
12286: PUSH
12287: LD_VAR 0 5
12291: PUSH
12292: LD_INT 1
12294: PLUS
12295: ST_TO_ADDR
// end else
12296: GO 12460
// begin if a = 0 then
12298: LD_VAR 0 6
12302: PUSH
12303: LD_INT 0
12305: EQUAL
12306: IFFALSE 12368
// begin a := path [ i1 + 1 ] ;
12308: LD_ADDR_VAR 0 6
12312: PUSH
12313: LD_VAR 0 2
12317: PUSH
12318: LD_VAR 0 5
12322: PUSH
12323: LD_INT 1
12325: PLUS
12326: ARRAY
12327: ST_TO_ADDR
// if a = 0 then
12328: LD_VAR 0 6
12332: PUSH
12333: LD_INT 0
12335: EQUAL
12336: IFFALSE 12347
// AddComReturn ( for_units ) ;
12338: LD_VAR 0 1
12342: PPUSH
12343: CALL_OW 204
// if a = 1 then
12347: LD_VAR 0 6
12351: PUSH
12352: LD_INT 1
12354: EQUAL
12355: IFFALSE 12366
// AddComRemember ( for_units ) ;
12357: LD_VAR 0 1
12361: PPUSH
12362: CALL_OW 203
// end else
12366: GO 12446
// begin if agressive then
12368: LD_VAR 0 3
12372: IFFALSE 12411
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
12374: LD_VAR 0 1
12378: PPUSH
12379: LD_VAR 0 2
12383: PUSH
12384: LD_VAR 0 5
12388: ARRAY
12389: PPUSH
12390: LD_VAR 0 2
12394: PUSH
12395: LD_VAR 0 5
12399: PUSH
12400: LD_INT 1
12402: PLUS
12403: ARRAY
12404: PPUSH
12405: CALL_OW 174
12409: GO 12446
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
12411: LD_VAR 0 1
12415: PPUSH
12416: LD_VAR 0 2
12420: PUSH
12421: LD_VAR 0 5
12425: ARRAY
12426: PPUSH
12427: LD_VAR 0 2
12431: PUSH
12432: LD_VAR 0 5
12436: PUSH
12437: LD_INT 1
12439: PLUS
12440: ARRAY
12441: PPUSH
12442: CALL_OW 171
// end ; i1 := i1 + 2 ;
12446: LD_ADDR_VAR 0 5
12450: PUSH
12451: LD_VAR 0 5
12455: PUSH
12456: LD_INT 2
12458: PLUS
12459: ST_TO_ADDR
// end ; end ;
12460: GO 12205
// end ;
12462: LD_VAR 0 4
12466: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
12467: LD_INT 0
12469: PPUSH
12470: PPUSH
12471: PPUSH
12472: PPUSH
12473: PPUSH
// forts := forts union [ ] ;
12474: LD_ADDR_VAR 0 1
12478: PUSH
12479: LD_VAR 0 1
12483: PUSH
12484: EMPTY
12485: UNION
12486: ST_TO_ADDR
// sols := sols union [ ] ;
12487: LD_ADDR_VAR 0 2
12491: PUSH
12492: LD_VAR 0 2
12496: PUSH
12497: EMPTY
12498: UNION
12499: ST_TO_ADDR
// for i in forts do
12500: LD_ADDR_VAR 0 6
12504: PUSH
12505: LD_VAR 0 1
12509: PUSH
12510: FOR_IN
12511: IFFALSE 12547
// if not UnitsInside ( i ) then
12513: LD_VAR 0 6
12517: PPUSH
12518: CALL_OW 313
12522: NOT
12523: IFFALSE 12545
// empty := add ( empty , i ) ;
12525: LD_ADDR_VAR 0 4
12529: PUSH
12530: LD_VAR 0 4
12534: PPUSH
12535: LD_VAR 0 6
12539: PPUSH
12540: CALL 12866 0 2
12544: ST_TO_ADDR
12545: GO 12510
12547: POP
12548: POP
// for i in sols do
12549: LD_ADDR_VAR 0 6
12553: PUSH
12554: LD_VAR 0 2
12558: PUSH
12559: FOR_IN
12560: IFFALSE 12608
// if not IsInUnit ( i ) and not IsBusy ( i ) then
12562: LD_VAR 0 6
12566: PPUSH
12567: CALL_OW 310
12571: NOT
12572: PUSH
12573: LD_VAR 0 6
12577: PPUSH
12578: CALL_OW 315
12582: NOT
12583: AND
12584: IFFALSE 12606
// free := add ( free , i ) ;
12586: LD_ADDR_VAR 0 5
12590: PUSH
12591: LD_VAR 0 5
12595: PPUSH
12596: LD_VAR 0 6
12600: PPUSH
12601: CALL 12866 0 2
12605: ST_TO_ADDR
12606: GO 12559
12608: POP
12609: POP
// result := forts diff empty ;
12610: LD_ADDR_VAR 0 3
12614: PUSH
12615: LD_VAR 0 1
12619: PUSH
12620: LD_VAR 0 4
12624: DIFF
12625: ST_TO_ADDR
// if empty <= free then
12626: LD_VAR 0 4
12630: PUSH
12631: LD_VAR 0 5
12635: LESSEQUAL
12636: IFFALSE 12650
// konec := empty else
12638: LD_ADDR_VAR 0 7
12642: PUSH
12643: LD_VAR 0 4
12647: ST_TO_ADDR
12648: GO 12660
// konec := free ;
12650: LD_ADDR_VAR 0 7
12654: PUSH
12655: LD_VAR 0 5
12659: ST_TO_ADDR
// for i := 1 to konec do
12660: LD_ADDR_VAR 0 6
12664: PUSH
12665: DOUBLE
12666: LD_INT 1
12668: DEC
12669: ST_TO_ADDR
12670: LD_VAR 0 7
12674: PUSH
12675: FOR_TO
12676: IFFALSE 12732
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
12678: LD_VAR 0 5
12682: PUSH
12683: LD_VAR 0 6
12687: ARRAY
12688: PPUSH
12689: LD_VAR 0 4
12693: PUSH
12694: LD_VAR 0 6
12698: ARRAY
12699: PPUSH
12700: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
12704: LD_ADDR_VAR 0 3
12708: PUSH
12709: LD_VAR 0 3
12713: PPUSH
12714: LD_VAR 0 4
12718: PUSH
12719: LD_VAR 0 6
12723: ARRAY
12724: PPUSH
12725: CALL 12866 0 2
12729: ST_TO_ADDR
// end ;
12730: GO 12675
12732: POP
12733: POP
// end ;
12734: LD_VAR 0 3
12738: RET
// export function TalkOn ; begin
12739: LD_INT 0
12741: PPUSH
// end ;
12742: LD_VAR 0 1
12746: RET
// export function TalkOff ; begin
12747: LD_INT 0
12749: PPUSH
// end ;
12750: LD_VAR 0 1
12754: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
12755: LD_INT 0
12757: PPUSH
12758: PPUSH
12759: PPUSH
12760: PPUSH
// l1 := [ ] ;
12761: LD_ADDR_VAR 0 3
12765: PUSH
12766: EMPTY
12767: ST_TO_ADDR
// l2 := [ ] ;
12768: LD_ADDR_VAR 0 4
12772: PUSH
12773: EMPTY
12774: ST_TO_ADDR
// for i := 1 to list div 2 do
12775: LD_ADDR_VAR 0 5
12779: PUSH
12780: DOUBLE
12781: LD_INT 1
12783: DEC
12784: ST_TO_ADDR
12785: LD_VAR 0 1
12789: PUSH
12790: LD_INT 2
12792: DIV
12793: PUSH
12794: FOR_TO
12795: IFFALSE 12821
// begin l1 := l1 ^ list [ i ] ;
12797: LD_ADDR_VAR 0 3
12801: PUSH
12802: LD_VAR 0 3
12806: PUSH
12807: LD_VAR 0 1
12811: PUSH
12812: LD_VAR 0 5
12816: ARRAY
12817: ADD
12818: ST_TO_ADDR
// end ;
12819: GO 12794
12821: POP
12822: POP
// l2 := list diff l1 ;
12823: LD_ADDR_VAR 0 4
12827: PUSH
12828: LD_VAR 0 1
12832: PUSH
12833: LD_VAR 0 3
12837: DIFF
12838: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
12839: LD_ADDR_VAR 0 2
12843: PUSH
12844: LD_VAR 0 3
12848: PUSH
12849: EMPTY
12850: LIST
12851: PUSH
12852: LD_VAR 0 4
12856: PUSH
12857: EMPTY
12858: LIST
12859: ADD
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 2
12865: RET
// export function add ( list , list1 ) ; begin
12866: LD_INT 0
12868: PPUSH
// if list = 0 then
12869: LD_VAR 0 1
12873: PUSH
12874: LD_INT 0
12876: EQUAL
12877: IFFALSE 12886
// list := [ ] ;
12879: LD_ADDR_VAR 0 1
12883: PUSH
12884: EMPTY
12885: ST_TO_ADDR
// if list1 = 0 then
12886: LD_VAR 0 2
12890: PUSH
12891: LD_INT 0
12893: EQUAL
12894: IFFALSE 12903
// list1 := [ ] ;
12896: LD_ADDR_VAR 0 2
12900: PUSH
12901: EMPTY
12902: ST_TO_ADDR
// result := list ^ list1 ;
12903: LD_ADDR_VAR 0 3
12907: PUSH
12908: LD_VAR 0 1
12912: PUSH
12913: LD_VAR 0 2
12917: ADD
12918: ST_TO_ADDR
// end ;
12919: LD_VAR 0 3
12923: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
12924: LD_INT 0
12926: PPUSH
12927: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
12928: LD_ADDR_VAR 0 8
12932: PUSH
12933: LD_VAR 0 1
12937: PPUSH
12938: LD_VAR 0 3
12942: PPUSH
12943: LD_VAR 0 4
12947: PPUSH
12948: LD_VAR 0 5
12952: PPUSH
12953: LD_VAR 0 6
12957: PPUSH
12958: CALL 13004 0 5
12962: ST_TO_ADDR
// if kdo then
12963: LD_VAR 0 8
12967: IFFALSE 12991
// result := Say ( kdo , ident ) else
12969: LD_ADDR_VAR 0 7
12973: PUSH
12974: LD_VAR 0 8
12978: PPUSH
12979: LD_VAR 0 2
12983: PPUSH
12984: CALL_OW 88
12988: ST_TO_ADDR
12989: GO 12999
// result := false ;
12991: LD_ADDR_VAR 0 7
12995: PUSH
12996: LD_INT 0
12998: ST_TO_ADDR
// end ;
12999: LD_VAR 0 7
13003: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
13004: LD_INT 0
13006: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
13007: LD_ADDR_VAR 0 1
13011: PUSH
13012: LD_VAR 0 1
13016: PPUSH
13017: LD_INT 21
13019: PUSH
13020: LD_INT 1
13022: PUSH
13023: EMPTY
13024: LIST
13025: LIST
13026: PUSH
13027: LD_INT 22
13029: PUSH
13030: LD_VAR 0 2
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: LD_INT 3
13041: PUSH
13042: LD_INT 23
13044: PUSH
13045: LD_INT 0
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: LIST
13056: LIST
13057: PPUSH
13058: CALL_OW 72
13062: ST_TO_ADDR
// if sex <> 0 then
13063: LD_VAR 0 3
13067: PUSH
13068: LD_INT 0
13070: NONEQUAL
13071: IFFALSE 13100
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
13073: LD_ADDR_VAR 0 1
13077: PUSH
13078: LD_VAR 0 1
13082: PPUSH
13083: LD_INT 26
13085: PUSH
13086: LD_VAR 0 3
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PPUSH
13095: CALL_OW 72
13099: ST_TO_ADDR
// if Hclass <> 0 then
13100: LD_VAR 0 4
13104: PUSH
13105: LD_INT 0
13107: NONEQUAL
13108: IFFALSE 13137
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
13110: LD_ADDR_VAR 0 1
13114: PUSH
13115: LD_VAR 0 1
13119: PPUSH
13120: LD_INT 25
13122: PUSH
13123: LD_VAR 0 4
13127: PUSH
13128: EMPTY
13129: LIST
13130: LIST
13131: PPUSH
13132: CALL_OW 72
13136: ST_TO_ADDR
// if index <= 0 then
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 0
13144: LESSEQUAL
13145: IFFALSE 13155
// index := 1 ;
13147: LD_ADDR_VAR 0 5
13151: PUSH
13152: LD_INT 1
13154: ST_TO_ADDR
// if lidi >= index then
13155: LD_VAR 0 1
13159: PUSH
13160: LD_VAR 0 5
13164: GREATEREQUAL
13165: IFFALSE 13185
// result := lidi [ index ] else
13167: LD_ADDR_VAR 0 6
13171: PUSH
13172: LD_VAR 0 1
13176: PUSH
13177: LD_VAR 0 5
13181: ARRAY
13182: ST_TO_ADDR
13183: GO 13193
// result := 0 ;
13185: LD_ADDR_VAR 0 6
13189: PUSH
13190: LD_INT 0
13192: ST_TO_ADDR
// end ;
13193: LD_VAR 0 6
13197: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
13198: LD_INT 0
13200: PPUSH
13201: PPUSH
13202: PPUSH
// result := [ ] ;
13203: LD_ADDR_VAR 0 3
13207: PUSH
13208: EMPTY
13209: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
13210: LD_ADDR_VAR 0 4
13214: PUSH
13215: LD_VAR 0 1
13219: PPUSH
13220: EMPTY
13221: PPUSH
13222: CALL_OW 70
13226: ST_TO_ADDR
// for i in inbase do
13227: LD_ADDR_VAR 0 5
13231: PUSH
13232: LD_VAR 0 4
13236: PUSH
13237: FOR_IN
13238: IFFALSE 13311
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
13240: LD_VAR 0 5
13244: PPUSH
13245: CALL_OW 247
13249: PUSH
13250: LD_INT 3
13252: EQUAL
13253: PUSH
13254: LD_VAR 0 5
13258: PPUSH
13259: CALL_OW 247
13263: PUSH
13264: LD_INT 2
13266: EQUAL
13267: OR
13268: IFFALSE 13293
// begin result := result ^ UnitsInside ( i ) ;
13270: LD_ADDR_VAR 0 3
13274: PUSH
13275: LD_VAR 0 3
13279: PUSH
13280: LD_VAR 0 5
13284: PPUSH
13285: CALL_OW 313
13289: ADD
13290: ST_TO_ADDR
// end else
13291: GO 13309
// begin result := result ^ i ;
13293: LD_ADDR_VAR 0 3
13297: PUSH
13298: LD_VAR 0 3
13302: PUSH
13303: LD_VAR 0 5
13307: ADD
13308: ST_TO_ADDR
// end ; end ;
13309: GO 13237
13311: POP
13312: POP
// result := UnitFilter ( result , filter ) ;
13313: LD_ADDR_VAR 0 3
13317: PUSH
13318: LD_VAR 0 3
13322: PPUSH
13323: LD_VAR 0 2
13327: PPUSH
13328: CALL_OW 72
13332: ST_TO_ADDR
// end ;
13333: LD_VAR 0 3
13337: RET
// export function ReverseList ( list ) ; var i ; begin
13338: LD_INT 0
13340: PPUSH
13341: PPUSH
// result := [ ] ;
13342: LD_ADDR_VAR 0 2
13346: PUSH
13347: EMPTY
13348: ST_TO_ADDR
// for i := list + 0 downto 1 do
13349: LD_ADDR_VAR 0 3
13353: PUSH
13354: DOUBLE
13355: LD_VAR 0 1
13359: PUSH
13360: LD_INT 0
13362: PLUS
13363: INC
13364: ST_TO_ADDR
13365: LD_INT 1
13367: PUSH
13368: FOR_DOWNTO
13369: IFFALSE 13398
// begin result := result ^ [ list [ i ] ] ;
13371: LD_ADDR_VAR 0 2
13375: PUSH
13376: LD_VAR 0 2
13380: PUSH
13381: LD_VAR 0 1
13385: PUSH
13386: LD_VAR 0 3
13390: ARRAY
13391: PUSH
13392: EMPTY
13393: LIST
13394: ADD
13395: ST_TO_ADDR
// end ;
13396: GO 13368
13398: POP
13399: POP
// end ;
13400: LD_VAR 0 2
13404: RET
// export using8 , using1 , using2 , using3 ; export path8 , path1 , path2 , path3 ; export kdo8 , kdo1 , kdo2 , kdo3 ; export using4 , using5 , using6 , using7 ; export path4 , path5 , path6 , path7 ; export kdo4 , kdo5 , kdo6 , kdo7 ; export function attack ( kdo , path ) ; var i , a ; begin
13405: LD_INT 0
13407: PPUSH
13408: PPUSH
13409: PPUSH
// for i in kdo do
13410: LD_ADDR_VAR 0 4
13414: PUSH
13415: LD_VAR 0 1
13419: PUSH
13420: FOR_IN
13421: IFFALSE 13437
// begin SetTag ( i , 1 ) ;
13423: LD_VAR 0 4
13427: PPUSH
13428: LD_INT 1
13430: PPUSH
13431: CALL_OW 109
// end ;
13435: GO 13420
13437: POP
13438: POP
// while kdo do
13439: LD_VAR 0 1
13443: IFFALSE 13738
// begin for i in kdo do
13445: LD_ADDR_VAR 0 4
13449: PUSH
13450: LD_VAR 0 1
13454: PUSH
13455: FOR_IN
13456: IFFALSE 13727
// begin a := GetTag ( i ) ;
13458: LD_ADDR_VAR 0 5
13462: PUSH
13463: LD_VAR 0 4
13467: PPUSH
13468: CALL_OW 110
13472: ST_TO_ADDR
// if a <= path then
13473: LD_VAR 0 5
13477: PUSH
13478: LD_VAR 0 2
13482: LESSEQUAL
13483: IFFALSE 13711
// begin if not IsDead ( i ) then
13485: LD_VAR 0 4
13489: PPUSH
13490: CALL_OW 301
13494: NOT
13495: IFFALSE 13669
// begin if IsIdle ( i ) then
13497: LD_VAR 0 4
13501: PPUSH
13502: CALL_OW 316
13506: IFFALSE 13667
// begin if a = 1 then
13508: LD_VAR 0 5
13512: PUSH
13513: LD_INT 1
13515: EQUAL
13516: IFFALSE 13557
// begin ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13518: LD_VAR 0 4
13522: PPUSH
13523: LD_VAR 0 2
13527: PUSH
13528: LD_VAR 0 5
13532: ARRAY
13533: PUSH
13534: LD_INT 1
13536: ARRAY
13537: PPUSH
13538: LD_VAR 0 2
13542: PUSH
13543: LD_VAR 0 5
13547: ARRAY
13548: PUSH
13549: LD_INT 2
13551: ARRAY
13552: PPUSH
13553: CALL_OW 114
// end ; if GetDistUnitXY ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) < 5 then
13557: LD_VAR 0 4
13561: PPUSH
13562: LD_VAR 0 2
13566: PUSH
13567: LD_VAR 0 5
13571: ARRAY
13572: PUSH
13573: LD_INT 1
13575: ARRAY
13576: PPUSH
13577: LD_VAR 0 2
13581: PUSH
13582: LD_VAR 0 5
13586: ARRAY
13587: PUSH
13588: LD_INT 2
13590: ARRAY
13591: PPUSH
13592: CALL_OW 297
13596: PUSH
13597: LD_INT 5
13599: LESS
13600: IFFALSE 13667
// begin a := a + 1 ;
13602: LD_ADDR_VAR 0 5
13606: PUSH
13607: LD_VAR 0 5
13611: PUSH
13612: LD_INT 1
13614: PLUS
13615: ST_TO_ADDR
// if a <= path then
13616: LD_VAR 0 5
13620: PUSH
13621: LD_VAR 0 2
13625: LESSEQUAL
13626: IFFALSE 13667
// ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13628: LD_VAR 0 4
13632: PPUSH
13633: LD_VAR 0 2
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: LD_INT 1
13646: ARRAY
13647: PPUSH
13648: LD_VAR 0 2
13652: PUSH
13653: LD_VAR 0 5
13657: ARRAY
13658: PUSH
13659: LD_INT 2
13661: ARRAY
13662: PPUSH
13663: CALL_OW 114
// end ; end ; end else
13667: GO 13683
// a := a + 1 ;
13669: LD_ADDR_VAR 0 5
13673: PUSH
13674: LD_VAR 0 5
13678: PUSH
13679: LD_INT 1
13681: PLUS
13682: ST_TO_ADDR
// if a > path then
13683: LD_VAR 0 5
13687: PUSH
13688: LD_VAR 0 2
13692: GREATER
13693: IFFALSE 13711
// kdo := kdo diff i ;
13695: LD_ADDR_VAR 0 1
13699: PUSH
13700: LD_VAR 0 1
13704: PUSH
13705: LD_VAR 0 4
13709: DIFF
13710: ST_TO_ADDR
// end ; SetTag ( i , a ) ;
13711: LD_VAR 0 4
13715: PPUSH
13716: LD_VAR 0 5
13720: PPUSH
13721: CALL_OW 109
// end ;
13725: GO 13455
13727: POP
13728: POP
// wait ( 0 0$1 ) ;
13729: LD_INT 35
13731: PPUSH
13732: CALL_OW 67
// end ;
13736: GO 13439
// end ;
13738: LD_VAR 0 3
13742: RET
// export function AttackBase ( kdo , path ) ; begin
13743: LD_INT 0
13745: PPUSH
// case false of using1 :
13746: LD_INT 0
13748: PUSH
13749: LD_EXP 83
13753: DOUBLE
13754: EQUAL
13755: IFTRUE 13759
13757: GO 13789
13759: POP
// begin kdo1 := kdo ;
13760: LD_ADDR_EXP 91
13764: PUSH
13765: LD_VAR 0 1
13769: ST_TO_ADDR
// path1 := path ;
13770: LD_ADDR_EXP 87
13774: PUSH
13775: LD_VAR 0 2
13779: ST_TO_ADDR
// RaiseSailEvent ( 1 ) ;
13780: LD_INT 1
13782: PPUSH
13783: CALL_OW 427
// end ; using2 :
13787: GO 14070
13789: LD_EXP 84
13793: DOUBLE
13794: EQUAL
13795: IFTRUE 13799
13797: GO 13829
13799: POP
// begin kdo2 := kdo ;
13800: LD_ADDR_EXP 92
13804: PUSH
13805: LD_VAR 0 1
13809: ST_TO_ADDR
// path2 := path ;
13810: LD_ADDR_EXP 88
13814: PUSH
13815: LD_VAR 0 2
13819: ST_TO_ADDR
// RaiseSailEvent ( 2 ) ;
13820: LD_INT 2
13822: PPUSH
13823: CALL_OW 427
// end ; using3 :
13827: GO 14070
13829: LD_EXP 85
13833: DOUBLE
13834: EQUAL
13835: IFTRUE 13839
13837: GO 13869
13839: POP
// begin kdo3 := kdo ;
13840: LD_ADDR_EXP 93
13844: PUSH
13845: LD_VAR 0 1
13849: ST_TO_ADDR
// path3 := path ;
13850: LD_ADDR_EXP 89
13854: PUSH
13855: LD_VAR 0 2
13859: ST_TO_ADDR
// RaiseSailEvent ( 3 ) ;
13860: LD_INT 3
13862: PPUSH
13863: CALL_OW 427
// end ; using4 :
13867: GO 14070
13869: LD_EXP 94
13873: DOUBLE
13874: EQUAL
13875: IFTRUE 13879
13877: GO 13909
13879: POP
// begin kdo4 := kdo ;
13880: LD_ADDR_EXP 102
13884: PUSH
13885: LD_VAR 0 1
13889: ST_TO_ADDR
// path4 := path ;
13890: LD_ADDR_EXP 98
13894: PUSH
13895: LD_VAR 0 2
13899: ST_TO_ADDR
// RaiseSailEvent ( 4 ) ;
13900: LD_INT 4
13902: PPUSH
13903: CALL_OW 427
// end ; using5 :
13907: GO 14070
13909: LD_EXP 95
13913: DOUBLE
13914: EQUAL
13915: IFTRUE 13919
13917: GO 13949
13919: POP
// begin kdo5 := kdo ;
13920: LD_ADDR_EXP 103
13924: PUSH
13925: LD_VAR 0 1
13929: ST_TO_ADDR
// path5 := path ;
13930: LD_ADDR_EXP 99
13934: PUSH
13935: LD_VAR 0 2
13939: ST_TO_ADDR
// RaiseSailEvent ( 5 ) ;
13940: LD_INT 5
13942: PPUSH
13943: CALL_OW 427
// end ; using6 :
13947: GO 14070
13949: LD_EXP 96
13953: DOUBLE
13954: EQUAL
13955: IFTRUE 13959
13957: GO 13989
13959: POP
// begin kdo6 := kdo ;
13960: LD_ADDR_EXP 104
13964: PUSH
13965: LD_VAR 0 1
13969: ST_TO_ADDR
// path6 := path ;
13970: LD_ADDR_EXP 100
13974: PUSH
13975: LD_VAR 0 2
13979: ST_TO_ADDR
// RaiseSailEvent ( 6 ) ;
13980: LD_INT 6
13982: PPUSH
13983: CALL_OW 427
// end ; using7 :
13987: GO 14070
13989: LD_EXP 97
13993: DOUBLE
13994: EQUAL
13995: IFTRUE 13999
13997: GO 14029
13999: POP
// begin kdo7 := kdo ;
14000: LD_ADDR_EXP 105
14004: PUSH
14005: LD_VAR 0 1
14009: ST_TO_ADDR
// path7 := path ;
14010: LD_ADDR_EXP 101
14014: PUSH
14015: LD_VAR 0 2
14019: ST_TO_ADDR
// RaiseSailEvent ( 7 ) ;
14020: LD_INT 7
14022: PPUSH
14023: CALL_OW 427
// end ; using8 :
14027: GO 14070
14029: LD_EXP 82
14033: DOUBLE
14034: EQUAL
14035: IFTRUE 14039
14037: GO 14069
14039: POP
// begin kdo8 := kdo ;
14040: LD_ADDR_EXP 90
14044: PUSH
14045: LD_VAR 0 1
14049: ST_TO_ADDR
// path8 := path ;
14050: LD_ADDR_EXP 86
14054: PUSH
14055: LD_VAR 0 2
14059: ST_TO_ADDR
// RaiseSailEvent ( 8 ) ;
14060: LD_INT 8
14062: PPUSH
14063: CALL_OW 427
// end ; end ;
14067: GO 14070
14069: POP
// end ;
14070: LD_VAR 0 3
14074: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
14075: LD_INT 0
14077: PPUSH
// if not hinty_co_byli then
14078: LD_EXP 106
14082: NOT
14083: IFFALSE 14092
// hinty_co_byli := [ ] ;
14085: LD_ADDR_EXP 106
14089: PUSH
14090: EMPTY
14091: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
14092: LD_VAR 0 1
14096: PUSH
14097: LD_EXP 106
14101: IN
14102: NOT
14103: IFFALSE 14130
// begin hinty_co_byli := hinty_co_byli ^ ident ;
14105: LD_ADDR_EXP 106
14109: PUSH
14110: LD_EXP 106
14114: PUSH
14115: LD_VAR 0 1
14119: ADD
14120: ST_TO_ADDR
// Hint ( ident ) ;
14121: LD_VAR 0 1
14125: PPUSH
14126: CALL_OW 339
// end ; end ; end_of_file
14130: LD_VAR 0 2
14134: RET
// every 0 0$0.3 trigger FilterUnitsInArea ( at_mine , [ [ f_side , you ] , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ] ) do var a ;
14135: LD_INT 20
14137: PPUSH
14138: LD_INT 22
14140: PUSH
14141: LD_EXP 47
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PUSH
14150: LD_INT 2
14152: PUSH
14153: LD_INT 34
14155: PUSH
14156: LD_INT 44
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_INT 34
14165: PUSH
14166: LD_INT 45
14168: PUSH
14169: EMPTY
14170: LIST
14171: LIST
14172: PUSH
14173: LD_INT 34
14175: PUSH
14176: LD_INT 46
14178: PUSH
14179: EMPTY
14180: LIST
14181: LIST
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PPUSH
14193: CALL_OW 70
14197: IFFALSE 14283
14199: GO 14201
14201: DISABLE
14202: LD_INT 0
14204: PPUSH
// begin if IsLive ( rumine1 ) then
14205: LD_EXP 68
14209: PPUSH
14210: CALL_OW 300
14214: IFFALSE 14282
// begin a := FilterUnitsInArea ( at_mine , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ) ;
14216: LD_ADDR_VAR 0 1
14220: PUSH
14221: LD_INT 20
14223: PPUSH
14224: LD_INT 2
14226: PUSH
14227: LD_INT 34
14229: PUSH
14230: LD_INT 44
14232: PUSH
14233: EMPTY
14234: LIST
14235: LIST
14236: PUSH
14237: LD_INT 34
14239: PUSH
14240: LD_INT 45
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 34
14249: PUSH
14250: LD_INT 46
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: PPUSH
14263: CALL_OW 70
14267: ST_TO_ADDR
// ComAttackUnit ( a , rumine1 ) ;
14268: LD_VAR 0 1
14272: PPUSH
14273: LD_EXP 68
14277: PPUSH
14278: CALL_OW 115
// end ; enable ;
14282: ENABLE
// end ;
14283: PPOPN 1
14285: END
// export function rep_car ( i ) ; begin
14286: LD_INT 0
14288: PPUSH
// case true of IsInArea ( i , NearL ) :
14289: LD_INT 1
14291: PUSH
14292: LD_VAR 0 1
14296: PPUSH
14297: LD_INT 16
14299: PPUSH
14300: CALL_OW 308
14304: DOUBLE
14305: EQUAL
14306: IFTRUE 14310
14308: GO 14325
14310: POP
// ComMoveToArea ( i , repL ) ; IsInArea ( i , NearM ) :
14311: LD_VAR 0 1
14315: PPUSH
14316: LD_INT 24
14318: PPUSH
14319: CALL_OW 113
14323: GO 14425
14325: LD_VAR 0 1
14329: PPUSH
14330: LD_INT 17
14332: PPUSH
14333: CALL_OW 308
14337: DOUBLE
14338: EQUAL
14339: IFTRUE 14343
14341: GO 14358
14343: POP
// ComMoveToArea ( i , repM ) ; IsInArea ( i , NearR ) :
14344: LD_VAR 0 1
14348: PPUSH
14349: LD_INT 25
14351: PPUSH
14352: CALL_OW 113
14356: GO 14425
14358: LD_VAR 0 1
14362: PPUSH
14363: LD_INT 18
14365: PPUSH
14366: CALL_OW 308
14370: DOUBLE
14371: EQUAL
14372: IFTRUE 14376
14374: GO 14391
14376: POP
// ComMoveToArea ( i , repR ) ; IsInArea ( i , NearT ) :
14377: LD_VAR 0 1
14381: PPUSH
14382: LD_INT 26
14384: PPUSH
14385: CALL_OW 113
14389: GO 14425
14391: LD_VAR 0 1
14395: PPUSH
14396: LD_INT 19
14398: PPUSH
14399: CALL_OW 308
14403: DOUBLE
14404: EQUAL
14405: IFTRUE 14409
14407: GO 14424
14409: POP
// ComMoveToArea ( i , repL ) ; end ;
14410: LD_VAR 0 1
14414: PPUSH
14415: LD_INT 24
14417: PPUSH
14418: CALL_OW 113
14422: GO 14425
14424: POP
// while not IsIdle ( i ) do
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 316
14434: NOT
14435: IFFALSE 14446
// wait ( 0 0$1 ) ;
14437: LD_INT 35
14439: PPUSH
14440: CALL_OW 67
14444: GO 14425
// AddComExitVehicle ( UnitsInside ( i ) ) ;
14446: LD_VAR 0 1
14450: PPUSH
14451: CALL_OW 313
14455: PPUSH
14456: CALL_OW 181
// end ;
14460: LD_VAR 0 2
14464: RET
// export function ret_car ( i ) ; begin
14465: LD_INT 0
14467: PPUSH
// ComEnterUnit ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) , i ) , i ) ;
14468: LD_INT 22
14470: PUSH
14471: LD_EXP 49
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PUSH
14480: LD_INT 21
14482: PUSH
14483: LD_INT 1
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: PUSH
14490: EMPTY
14491: LIST
14492: LIST
14493: PPUSH
14494: CALL_OW 69
14498: PPUSH
14499: LD_VAR 0 1
14503: PPUSH
14504: CALL_OW 74
14508: PPUSH
14509: LD_VAR 0 1
14513: PPUSH
14514: CALL_OW 120
// while not UnitsInside ( i ) do
14518: LD_VAR 0 1
14522: PPUSH
14523: CALL_OW 313
14527: NOT
14528: IFFALSE 14539
// wait ( 0 0$1 ) ;
14530: LD_INT 35
14532: PPUSH
14533: CALL_OW 67
14537: GO 14518
// ComAgressiveMove ( i , 92 , 92 ) ;
14539: LD_VAR 0 1
14543: PPUSH
14544: LD_INT 92
14546: PPUSH
14547: LD_INT 92
14549: PPUSH
14550: CALL_OW 114
// end ;
14554: LD_VAR 0 2
14558: RET
// every 0 0$1 do var vehs , i ;
14559: GO 14561
14561: DISABLE
14562: LD_INT 0
14564: PPUSH
14565: PPUSH
// begin vehs := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
14566: LD_ADDR_VAR 0 1
14570: PUSH
14571: LD_INT 22
14573: PUSH
14574: LD_EXP 49
14578: PUSH
14579: EMPTY
14580: LIST
14581: LIST
14582: PUSH
14583: LD_INT 21
14585: PUSH
14586: LD_INT 2
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PPUSH
14597: CALL_OW 69
14601: ST_TO_ADDR
// for i in vehs do
14602: LD_ADDR_VAR 0 2
14606: PUSH
14607: LD_VAR 0 1
14611: PUSH
14612: FOR_IN
14613: IFFALSE 14705
// begin if GetClass ( UnitsInside ( i ) ) = class_mechanic then
14615: LD_VAR 0 2
14619: PPUSH
14620: CALL_OW 313
14624: PPUSH
14625: CALL_OW 257
14629: PUSH
14630: LD_INT 3
14632: EQUAL
14633: IFFALSE 14703
// begin if GetLives ( i ) < 600 then
14635: LD_VAR 0 2
14639: PPUSH
14640: CALL_OW 256
14644: PUSH
14645: LD_INT 600
14647: LESS
14648: IFFALSE 14663
// RaiseSailEvent ( i + 1000 ) ;
14650: LD_VAR 0 2
14654: PUSH
14655: LD_INT 1000
14657: PLUS
14658: PPUSH
14659: CALL_OW 427
// if GetLives ( i ) > 900 and not UnitsInside ( i ) then
14663: LD_VAR 0 2
14667: PPUSH
14668: CALL_OW 256
14672: PUSH
14673: LD_INT 900
14675: GREATER
14676: PUSH
14677: LD_VAR 0 2
14681: PPUSH
14682: CALL_OW 313
14686: NOT
14687: AND
14688: IFFALSE 14703
// RaiseSailEvent ( i + 2000 ) ;
14690: LD_VAR 0 2
14694: PUSH
14695: LD_INT 2000
14697: PLUS
14698: PPUSH
14699: CALL_OW 427
// end ; end ;
14703: GO 14612
14705: POP
14706: POP
// enable ;
14707: ENABLE
// end ;
14708: PPOPN 2
14710: END
// every 10 10$0 trigger utocit do var u1 , u2 , p1 , i , b1 ;
14711: LD_EXP 2
14715: IFFALSE 15193
14717: GO 14719
14719: DISABLE
14720: LD_INT 0
14722: PPUSH
14723: PPUSH
14724: PPUSH
14725: PPUSH
14726: PPUSH
// begin case difficulty of 1 :
14727: LD_OWVAR 67
14731: PUSH
14732: LD_INT 1
14734: DOUBLE
14735: EQUAL
14736: IFTRUE 14740
14738: GO 14805
14740: POP
// begin u1 := CreateVH ( [ mhmg , mhmg ] ) ;
14741: LD_ADDR_VAR 0 1
14745: PUSH
14746: LD_EXP 9
14750: PUSH
14751: LD_EXP 9
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PPUSH
14760: CALL 23031 0 1
14764: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
14765: LD_ADDR_VAR 0 3
14769: PUSH
14770: LD_INT 1
14772: PPUSH
14773: LD_INT 1
14775: PPUSH
14776: CALL 22578 0 2
14780: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
14781: LD_ADDR_VAR 0 5
14785: PUSH
14786: LD_INT 2
14788: PPUSH
14789: CALL 22783 0 1
14793: PUSH
14794: LD_INT 1
14796: PPUSH
14797: CALL 22907 0 1
14801: ADD
14802: ST_TO_ADDR
// end ; 2 :
14803: GO 14964
14805: LD_INT 2
14807: DOUBLE
14808: EQUAL
14809: IFTRUE 14813
14811: GO 14878
14813: POP
// begin u1 := CreateVH ( [ mhmg , mgg ] ) ;
14814: LD_ADDR_VAR 0 1
14818: PUSH
14819: LD_EXP 9
14823: PUSH
14824: LD_EXP 10
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PPUSH
14833: CALL 23031 0 1
14837: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
14838: LD_ADDR_VAR 0 3
14842: PUSH
14843: LD_INT 2
14845: PPUSH
14846: LD_INT 0
14848: PPUSH
14849: CALL 22578 0 2
14853: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
14854: LD_ADDR_VAR 0 5
14858: PUSH
14859: LD_INT 3
14861: PPUSH
14862: CALL 22783 0 1
14866: PUSH
14867: LD_INT 2
14869: PPUSH
14870: CALL 22907 0 1
14874: ADD
14875: ST_TO_ADDR
// end ; 3 :
14876: GO 14964
14878: LD_INT 3
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14963
14886: POP
// begin u1 := CreateVH ( [ mgg ] ) ;
14887: LD_ADDR_VAR 0 1
14891: PUSH
14892: LD_EXP 10
14896: PUSH
14897: EMPTY
14898: LIST
14899: PPUSH
14900: CALL 23031 0 1
14904: ST_TO_ADDR
// u2 := CreateVC ( [ mgg ] ) ;
14905: LD_ADDR_VAR 0 2
14909: PUSH
14910: LD_EXP 10
14914: PUSH
14915: EMPTY
14916: LIST
14917: PPUSH
14918: CALL 23357 0 1
14922: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
14923: LD_ADDR_VAR 0 3
14927: PUSH
14928: LD_INT 1
14930: PPUSH
14931: LD_INT 0
14933: PPUSH
14934: CALL 22578 0 2
14938: ST_TO_ADDR
// b1 := CreateB ( 5 ) ^ CreateS ( 3 ) ;
14939: LD_ADDR_VAR 0 5
14943: PUSH
14944: LD_INT 5
14946: PPUSH
14947: CALL 22783 0 1
14951: PUSH
14952: LD_INT 3
14954: PPUSH
14955: CALL 22907 0 1
14959: ADD
14960: ST_TO_ADDR
// end ; end ;
14961: GO 14964
14963: POP
// for i := 1 to u1 do
14964: LD_ADDR_VAR 0 4
14968: PUSH
14969: DOUBLE
14970: LD_INT 1
14972: DEC
14973: ST_TO_ADDR
14974: LD_VAR 0 1
14978: PUSH
14979: FOR_TO
14980: IFFALSE 15010
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
14982: LD_VAR 0 3
14986: PUSH
14987: LD_VAR 0 4
14991: ARRAY
14992: PPUSH
14993: LD_VAR 0 1
14997: PUSH
14998: LD_VAR 0 4
15002: ARRAY
15003: PPUSH
15004: CALL_OW 52
// end ;
15008: GO 14979
15010: POP
15011: POP
// for i in u1 do
15012: LD_ADDR_VAR 0 4
15016: PUSH
15017: LD_VAR 0 1
15021: PUSH
15022: FOR_IN
15023: IFFALSE 15042
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15025: LD_VAR 0 4
15029: PPUSH
15030: LD_INT 3
15032: PPUSH
15033: LD_INT 0
15035: PPUSH
15036: CALL 23687 0 3
// end ;
15040: GO 15022
15042: POP
15043: POP
// for i in u2 do
15044: LD_ADDR_VAR 0 4
15048: PUSH
15049: LD_VAR 0 2
15053: PUSH
15054: FOR_IN
15055: IFFALSE 15074
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15057: LD_VAR 0 4
15061: PPUSH
15062: LD_INT 3
15064: PPUSH
15065: LD_INT 0
15067: PPUSH
15068: CALL 23687 0 3
// end ;
15072: GO 15054
15074: POP
15075: POP
// wait ( 0 0$1 ) ;
15076: LD_INT 35
15078: PPUSH
15079: CALL_OW 67
// AttackBase ( u1 ^ u2 , pathBL ^ pathUL ) ;
15083: LD_VAR 0 1
15087: PUSH
15088: LD_VAR 0 2
15092: ADD
15093: PPUSH
15094: LD_EXP 108
15098: PUSH
15099: LD_EXP 111
15103: ADD
15104: PPUSH
15105: CALL 13743 0 2
// for i in b1 do
15109: LD_ADDR_VAR 0 4
15113: PUSH
15114: LD_VAR 0 5
15118: PUSH
15119: FOR_IN
15120: IFFALSE 15139
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15122: LD_VAR 0 4
15126: PPUSH
15127: LD_INT 14
15129: PPUSH
15130: LD_INT 0
15132: PPUSH
15133: CALL 23687 0 3
// end ;
15137: GO 15119
15139: POP
15140: POP
// wait ( 0 0$1 ) ;
15141: LD_INT 35
15143: PPUSH
15144: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15148: LD_VAR 0 5
15152: PPUSH
15153: LD_EXP 118
15157: PPUSH
15158: CALL 13743 0 2
// while not ContactTime ( [ russians ] ) do
15162: LD_EXP 49
15166: PUSH
15167: EMPTY
15168: LIST
15169: PPUSH
15170: CALL_OW 462
15174: NOT
15175: IFFALSE 15186
// wait ( 0 0$1 ) ;
15177: LD_INT 35
15179: PPUSH
15180: CALL_OW 67
15184: GO 15162
// MyHint ( PriorityAttacks ) ;
15186: LD_STRING PriorityAttacks
15188: PPUSH
15189: CALL 14075 0 1
// end ;
15193: PPOPN 5
15195: END
// every 15 15$0 trigger utocit do var u1 , p1 , b1 , i , u2 , u1a ;
15196: LD_EXP 2
15200: IFFALSE 15749
15202: GO 15204
15204: DISABLE
15205: LD_INT 0
15207: PPUSH
15208: PPUSH
15209: PPUSH
15210: PPUSH
15211: PPUSH
15212: PPUSH
// begin case difficulty of 1 :
15213: LD_OWVAR 67
15217: PUSH
15218: LD_INT 1
15220: DOUBLE
15221: EQUAL
15222: IFTRUE 15226
15224: GO 15285
15226: POP
// begin u1 := CreateVH ( [ mg ] ) ;
15227: LD_ADDR_VAR 0 1
15231: PUSH
15232: LD_EXP 11
15236: PUSH
15237: EMPTY
15238: LIST
15239: PPUSH
15240: CALL 23031 0 1
15244: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15245: LD_ADDR_VAR 0 2
15249: PUSH
15250: LD_INT 1
15252: PPUSH
15253: LD_INT 0
15255: PPUSH
15256: CALL 22578 0 2
15260: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
15261: LD_ADDR_VAR 0 3
15265: PUSH
15266: LD_INT 2
15268: PPUSH
15269: CALL 22783 0 1
15273: PUSH
15274: LD_INT 1
15276: PPUSH
15277: CALL 22907 0 1
15281: ADD
15282: ST_TO_ADDR
// end ; 2 :
15283: GO 15420
15285: LD_INT 2
15287: DOUBLE
15288: EQUAL
15289: IFTRUE 15293
15291: GO 15352
15293: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15294: LD_ADDR_VAR 0 1
15298: PUSH
15299: LD_EXP 12
15303: PUSH
15304: EMPTY
15305: LIST
15306: PPUSH
15307: CALL 23031 0 1
15311: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15312: LD_ADDR_VAR 0 2
15316: PUSH
15317: LD_INT 1
15319: PPUSH
15320: LD_INT 0
15322: PPUSH
15323: CALL 22578 0 2
15327: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
15328: LD_ADDR_VAR 0 3
15332: PUSH
15333: LD_INT 3
15335: PPUSH
15336: CALL 22783 0 1
15340: PUSH
15341: LD_INT 2
15343: PPUSH
15344: CALL 22907 0 1
15348: ADD
15349: ST_TO_ADDR
// end ; 3 :
15350: GO 15420
15352: LD_INT 3
15354: DOUBLE
15355: EQUAL
15356: IFTRUE 15360
15358: GO 15419
15360: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15361: LD_ADDR_VAR 0 1
15365: PUSH
15366: LD_EXP 12
15370: PUSH
15371: EMPTY
15372: LIST
15373: PPUSH
15374: CALL 23031 0 1
15378: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15379: LD_ADDR_VAR 0 2
15383: PUSH
15384: LD_INT 0
15386: PPUSH
15387: LD_INT 1
15389: PPUSH
15390: CALL 22578 0 2
15394: ST_TO_ADDR
// b1 := CreateB ( 4 ) ^ CreateS ( 3 ) ;
15395: LD_ADDR_VAR 0 3
15399: PUSH
15400: LD_INT 4
15402: PPUSH
15403: CALL 22783 0 1
15407: PUSH
15408: LD_INT 3
15410: PPUSH
15411: CALL 22907 0 1
15415: ADD
15416: ST_TO_ADDR
// end ; end ;
15417: GO 15420
15419: POP
// for i in b1 do
15420: LD_ADDR_VAR 0 4
15424: PUSH
15425: LD_VAR 0 3
15429: PUSH
15430: FOR_IN
15431: IFFALSE 15450
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15433: LD_VAR 0 4
15437: PPUSH
15438: LD_INT 14
15440: PPUSH
15441: LD_INT 0
15443: PPUSH
15444: CALL 23687 0 3
// end ;
15448: GO 15430
15450: POP
15451: POP
// wait ( 0 0$1 ) ;
15452: LD_INT 35
15454: PPUSH
15455: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15459: LD_VAR 0 3
15463: PPUSH
15464: LD_EXP 118
15468: PPUSH
15469: CALL 13743 0 2
// for i := 1 to u1 do
15473: LD_ADDR_VAR 0 4
15477: PUSH
15478: DOUBLE
15479: LD_INT 1
15481: DEC
15482: ST_TO_ADDR
15483: LD_VAR 0 1
15487: PUSH
15488: FOR_TO
15489: IFFALSE 15519
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15491: LD_VAR 0 2
15495: PUSH
15496: LD_VAR 0 4
15500: ARRAY
15501: PPUSH
15502: LD_VAR 0 1
15506: PUSH
15507: LD_VAR 0 4
15511: ARRAY
15512: PPUSH
15513: CALL_OW 52
// end ;
15517: GO 15488
15519: POP
15520: POP
// for i in u1 do
15521: LD_ADDR_VAR 0 4
15525: PUSH
15526: LD_VAR 0 1
15530: PUSH
15531: FOR_IN
15532: IFFALSE 15551
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
15534: LD_VAR 0 4
15538: PPUSH
15539: LD_INT 2
15541: PPUSH
15542: LD_INT 0
15544: PPUSH
15545: CALL 23687 0 3
// end ;
15549: GO 15531
15551: POP
15552: POP
// wait ( 0 0$1 ) ;
15553: LD_INT 35
15555: PPUSH
15556: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
15560: LD_VAR 0 1
15564: PPUSH
15565: LD_EXP 109
15569: PUSH
15570: LD_EXP 114
15574: PPUSH
15575: CALL 13338 0 1
15579: ADD
15580: PUSH
15581: LD_EXP 111
15585: ADD
15586: PPUSH
15587: CALL 13743 0 2
// case difficulty of 1 :
15591: LD_OWVAR 67
15595: PUSH
15596: LD_INT 1
15598: DOUBLE
15599: EQUAL
15600: IFTRUE 15604
15602: GO 15625
15604: POP
// begin u2 := CreateVC ( [ mg ] ) ;
15605: LD_ADDR_VAR 0 5
15609: PUSH
15610: LD_EXP 11
15614: PUSH
15615: EMPTY
15616: LIST
15617: PPUSH
15618: CALL 23357 0 1
15622: ST_TO_ADDR
// end ; 2 :
15623: GO 15690
15625: LD_INT 2
15627: DOUBLE
15628: EQUAL
15629: IFTRUE 15633
15631: GO 15654
15633: POP
// begin u2 := CreateVC ( [ hhg ] ) ;
15634: LD_ADDR_VAR 0 5
15638: PUSH
15639: LD_EXP 15
15643: PUSH
15644: EMPTY
15645: LIST
15646: PPUSH
15647: CALL 23357 0 1
15651: ST_TO_ADDR
// end ; 3 :
15652: GO 15690
15654: LD_INT 3
15656: DOUBLE
15657: EQUAL
15658: IFTRUE 15662
15660: GO 15689
15662: POP
// begin u2 := CreateVC ( [ mg , hhg ] ) ;
15663: LD_ADDR_VAR 0 5
15667: PUSH
15668: LD_EXP 11
15672: PUSH
15673: LD_EXP 15
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PPUSH
15682: CALL 23357 0 1
15686: ST_TO_ADDR
// end ; end ;
15687: GO 15690
15689: POP
// for i in u2 do
15690: LD_ADDR_VAR 0 4
15694: PUSH
15695: LD_VAR 0 5
15699: PUSH
15700: FOR_IN
15701: IFFALSE 15720
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
15703: LD_VAR 0 4
15707: PPUSH
15708: LD_INT 15
15710: PPUSH
15711: LD_INT 0
15713: PPUSH
15714: CALL 23687 0 3
// end ;
15718: GO 15700
15720: POP
15721: POP
// wait ( 0 0$1 ) ;
15722: LD_INT 35
15724: PPUSH
15725: CALL_OW 67
// AttackBase ( u2 , pathBR ^ pathUR ) ;
15729: LD_VAR 0 5
15733: PPUSH
15734: LD_EXP 110
15738: PUSH
15739: LD_EXP 112
15743: ADD
15744: PPUSH
15745: CALL 13743 0 2
// end ;
15749: PPOPN 6
15751: END
// every 18 18$0 trigger utocit do var u1 , p1 , i , u1a ;
15752: LD_EXP 2
15756: IFFALSE 16482
15758: GO 15760
15760: DISABLE
15761: LD_INT 0
15763: PPUSH
15764: PPUSH
15765: PPUSH
15766: PPUSH
// begin case difficulty of 1 :
15767: LD_OWVAR 67
15771: PUSH
15772: LD_INT 1
15774: DOUBLE
15775: EQUAL
15776: IFTRUE 15780
15778: GO 15835
15780: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15781: LD_ADDR_VAR 0 1
15785: PUSH
15786: LD_EXP 12
15790: PUSH
15791: EMPTY
15792: LIST
15793: PPUSH
15794: CALL 23031 0 1
15798: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
15799: LD_ADDR_VAR 0 4
15803: PUSH
15804: LD_EXP 12
15808: PUSH
15809: EMPTY
15810: LIST
15811: PPUSH
15812: CALL 23357 0 1
15816: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15817: LD_ADDR_VAR 0 2
15821: PUSH
15822: LD_INT 0
15824: PPUSH
15825: LD_INT 1
15827: PPUSH
15828: CALL 22578 0 2
15832: ST_TO_ADDR
// end ; 2 :
15833: GO 15968
15835: LD_INT 2
15837: DOUBLE
15838: EQUAL
15839: IFTRUE 15843
15841: GO 15898
15843: POP
// begin u1 := CreateVH ( [ hrl ] ) ;
15844: LD_ADDR_VAR 0 1
15848: PUSH
15849: LD_EXP 14
15853: PUSH
15854: EMPTY
15855: LIST
15856: PPUSH
15857: CALL 23031 0 1
15861: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
15862: LD_ADDR_VAR 0 4
15866: PUSH
15867: LD_EXP 14
15871: PUSH
15872: EMPTY
15873: LIST
15874: PPUSH
15875: CALL 23357 0 1
15879: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15880: LD_ADDR_VAR 0 2
15884: PUSH
15885: LD_INT 0
15887: PPUSH
15888: LD_INT 1
15890: PPUSH
15891: CALL 22578 0 2
15895: ST_TO_ADDR
// end ; 3 :
15896: GO 15968
15898: LD_INT 3
15900: DOUBLE
15901: EQUAL
15902: IFTRUE 15906
15904: GO 15967
15906: POP
// begin u1 := CreateVH ( [ hrl , mrl ] ) ;
15907: LD_ADDR_VAR 0 1
15911: PUSH
15912: LD_EXP 14
15916: PUSH
15917: LD_EXP 12
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PPUSH
15926: CALL 23031 0 1
15930: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
15931: LD_ADDR_VAR 0 4
15935: PUSH
15936: LD_EXP 14
15940: PUSH
15941: EMPTY
15942: LIST
15943: PPUSH
15944: CALL 23357 0 1
15948: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
15949: LD_ADDR_VAR 0 2
15953: PUSH
15954: LD_INT 1
15956: PPUSH
15957: LD_INT 1
15959: PPUSH
15960: CALL 22578 0 2
15964: ST_TO_ADDR
// end ; end ;
15965: GO 15968
15967: POP
// for i := 1 to u1 do
15968: LD_ADDR_VAR 0 3
15972: PUSH
15973: DOUBLE
15974: LD_INT 1
15976: DEC
15977: ST_TO_ADDR
15978: LD_VAR 0 1
15982: PUSH
15983: FOR_TO
15984: IFFALSE 16014
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15986: LD_VAR 0 2
15990: PUSH
15991: LD_VAR 0 3
15995: ARRAY
15996: PPUSH
15997: LD_VAR 0 1
16001: PUSH
16002: LD_VAR 0 3
16006: ARRAY
16007: PPUSH
16008: CALL_OW 52
// end ;
16012: GO 15983
16014: POP
16015: POP
// for i in u1 do
16016: LD_ADDR_VAR 0 3
16020: PUSH
16021: LD_VAR 0 1
16025: PUSH
16026: FOR_IN
16027: IFFALSE 16046
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16029: LD_VAR 0 3
16033: PPUSH
16034: LD_INT 3
16036: PPUSH
16037: LD_INT 0
16039: PPUSH
16040: CALL 23687 0 3
// end ;
16044: GO 16026
16046: POP
16047: POP
// for i in u1a do
16048: LD_ADDR_VAR 0 3
16052: PUSH
16053: LD_VAR 0 4
16057: PUSH
16058: FOR_IN
16059: IFFALSE 16078
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16061: LD_VAR 0 3
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: LD_INT 0
16071: PPUSH
16072: CALL 23687 0 3
// end ;
16076: GO 16058
16078: POP
16079: POP
// wait ( 0 0$1 ) ;
16080: LD_INT 35
16082: PPUSH
16083: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
16087: LD_VAR 0 1
16091: PPUSH
16092: LD_EXP 108
16096: PUSH
16097: LD_EXP 111
16101: ADD
16102: PPUSH
16103: CALL 13743 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
16107: LD_VAR 0 4
16111: PPUSH
16112: LD_EXP 108
16116: PUSH
16117: LD_EXP 111
16121: ADD
16122: PPUSH
16123: CALL 13743 0 2
// case difficulty of 1 :
16127: LD_OWVAR 67
16131: PUSH
16132: LD_INT 1
16134: DOUBLE
16135: EQUAL
16136: IFTRUE 16140
16138: GO 16184
16140: POP
// begin u1 := CreateVH ( [ mg ] ) ;
16141: LD_ADDR_VAR 0 1
16145: PUSH
16146: LD_EXP 11
16150: PUSH
16151: EMPTY
16152: LIST
16153: PPUSH
16154: CALL 23031 0 1
16158: ST_TO_ADDR
// u1a := [ ] ;
16159: LD_ADDR_VAR 0 4
16163: PUSH
16164: EMPTY
16165: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16166: LD_ADDR_VAR 0 2
16170: PUSH
16171: LD_INT 1
16173: PPUSH
16174: LD_INT 0
16176: PPUSH
16177: CALL 22578 0 2
16181: ST_TO_ADDR
// end ; 2 :
16182: GO 16311
16184: LD_INT 2
16186: DOUBLE
16187: EQUAL
16188: IFTRUE 16192
16190: GO 16247
16192: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16193: LD_ADDR_VAR 0 1
16197: PUSH
16198: LD_EXP 15
16202: PUSH
16203: EMPTY
16204: LIST
16205: PPUSH
16206: CALL 23031 0 1
16210: ST_TO_ADDR
// u1a := CreateVC ( [ mg ] ) ;
16211: LD_ADDR_VAR 0 4
16215: PUSH
16216: LD_EXP 11
16220: PUSH
16221: EMPTY
16222: LIST
16223: PPUSH
16224: CALL 23357 0 1
16228: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16229: LD_ADDR_VAR 0 2
16233: PUSH
16234: LD_INT 1
16236: PPUSH
16237: LD_INT 0
16239: PPUSH
16240: CALL 22578 0 2
16244: ST_TO_ADDR
// end ; 3 :
16245: GO 16311
16247: LD_INT 3
16249: DOUBLE
16250: EQUAL
16251: IFTRUE 16255
16253: GO 16310
16255: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16256: LD_ADDR_VAR 0 1
16260: PUSH
16261: LD_EXP 15
16265: PUSH
16266: EMPTY
16267: LIST
16268: PPUSH
16269: CALL 23031 0 1
16273: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16274: LD_ADDR_VAR 0 4
16278: PUSH
16279: LD_EXP 14
16283: PUSH
16284: EMPTY
16285: LIST
16286: PPUSH
16287: CALL 23357 0 1
16291: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16292: LD_ADDR_VAR 0 2
16296: PUSH
16297: LD_INT 0
16299: PPUSH
16300: LD_INT 1
16302: PPUSH
16303: CALL 22578 0 2
16307: ST_TO_ADDR
// end ; end ;
16308: GO 16311
16310: POP
// for i := 1 to u1 do
16311: LD_ADDR_VAR 0 3
16315: PUSH
16316: DOUBLE
16317: LD_INT 1
16319: DEC
16320: ST_TO_ADDR
16321: LD_VAR 0 1
16325: PUSH
16326: FOR_TO
16327: IFFALSE 16357
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16329: LD_VAR 0 2
16333: PUSH
16334: LD_VAR 0 3
16338: ARRAY
16339: PPUSH
16340: LD_VAR 0 1
16344: PUSH
16345: LD_VAR 0 3
16349: ARRAY
16350: PPUSH
16351: CALL_OW 52
// end ;
16355: GO 16326
16357: POP
16358: POP
// for i in u1 do
16359: LD_ADDR_VAR 0 3
16363: PUSH
16364: LD_VAR 0 1
16368: PUSH
16369: FOR_IN
16370: IFFALSE 16389
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16372: LD_VAR 0 3
16376: PPUSH
16377: LD_INT 15
16379: PPUSH
16380: LD_INT 0
16382: PPUSH
16383: CALL 23687 0 3
// end ;
16387: GO 16369
16389: POP
16390: POP
// for i in u1a do
16391: LD_ADDR_VAR 0 3
16395: PUSH
16396: LD_VAR 0 4
16400: PUSH
16401: FOR_IN
16402: IFFALSE 16421
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16404: LD_VAR 0 3
16408: PPUSH
16409: LD_INT 15
16411: PPUSH
16412: LD_INT 0
16414: PPUSH
16415: CALL 23687 0 3
// end ;
16419: GO 16401
16421: POP
16422: POP
// wait ( 0 0$1 ) ;
16423: LD_INT 35
16425: PPUSH
16426: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16430: LD_VAR 0 1
16434: PPUSH
16435: LD_EXP 110
16439: PUSH
16440: LD_EXP 116
16444: ADD
16445: PUSH
16446: LD_EXP 113
16450: ADD
16451: PPUSH
16452: CALL 13743 0 2
// AttackBase ( u1a , pathBR ^ pathMR ^ pathUT ) ;
16456: LD_VAR 0 4
16460: PPUSH
16461: LD_EXP 110
16465: PUSH
16466: LD_EXP 116
16470: ADD
16471: PUSH
16472: LD_EXP 113
16476: ADD
16477: PPUSH
16478: CALL 13743 0 2
// end ;
16482: PPOPN 4
16484: END
// every 22 22$0 trigger utocit do var u1 , p1 , i , u1a ;
16485: LD_EXP 2
16489: IFFALSE 16884
16491: GO 16493
16493: DISABLE
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
16499: PPUSH
// begin case difficulty of 1 :
16500: LD_OWVAR 67
16504: PUSH
16505: LD_INT 1
16507: DOUBLE
16508: EQUAL
16509: IFTRUE 16513
16511: GO 16574
16513: POP
// begin u1 := CreateVH ( [ mrl , mrl ] ) ;
16514: LD_ADDR_VAR 0 1
16518: PUSH
16519: LD_EXP 12
16523: PUSH
16524: LD_EXP 12
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PPUSH
16533: CALL 23031 0 1
16537: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16538: LD_ADDR_VAR 0 4
16542: PUSH
16543: LD_EXP 12
16547: PUSH
16548: EMPTY
16549: LIST
16550: PPUSH
16551: CALL 23357 0 1
16555: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
16556: LD_ADDR_VAR 0 2
16560: PUSH
16561: LD_INT 0
16563: PPUSH
16564: LD_INT 2
16566: PPUSH
16567: CALL 22578 0 2
16571: ST_TO_ADDR
// end ; 2 :
16572: GO 16719
16574: LD_INT 2
16576: DOUBLE
16577: EQUAL
16578: IFTRUE 16582
16580: GO 16643
16582: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16583: LD_ADDR_VAR 0 1
16587: PUSH
16588: LD_EXP 14
16592: PUSH
16593: LD_EXP 14
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PPUSH
16602: CALL 23031 0 1
16606: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16607: LD_ADDR_VAR 0 4
16611: PUSH
16612: LD_EXP 12
16616: PUSH
16617: EMPTY
16618: LIST
16619: PPUSH
16620: CALL 23357 0 1
16624: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
16625: LD_ADDR_VAR 0 2
16629: PUSH
16630: LD_INT 2
16632: PPUSH
16633: LD_INT 0
16635: PPUSH
16636: CALL 22578 0 2
16640: ST_TO_ADDR
// end ; 3 :
16641: GO 16719
16643: LD_INT 3
16645: DOUBLE
16646: EQUAL
16647: IFTRUE 16651
16649: GO 16718
16651: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16652: LD_ADDR_VAR 0 1
16656: PUSH
16657: LD_EXP 14
16661: PUSH
16662: LD_EXP 14
16666: PUSH
16667: EMPTY
16668: LIST
16669: LIST
16670: PPUSH
16671: CALL 23031 0 1
16675: ST_TO_ADDR
// u1a := CreateVC ( [ hrl , hrl ] ) ;
16676: LD_ADDR_VAR 0 4
16680: PUSH
16681: LD_EXP 14
16685: PUSH
16686: LD_EXP 14
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: PPUSH
16695: CALL 23357 0 1
16699: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16700: LD_ADDR_VAR 0 2
16704: PUSH
16705: LD_INT 1
16707: PPUSH
16708: LD_INT 1
16710: PPUSH
16711: CALL 22578 0 2
16715: ST_TO_ADDR
// end ; end ;
16716: GO 16719
16718: POP
// for i := 1 to u1 do
16719: LD_ADDR_VAR 0 3
16723: PUSH
16724: DOUBLE
16725: LD_INT 1
16727: DEC
16728: ST_TO_ADDR
16729: LD_VAR 0 1
16733: PUSH
16734: FOR_TO
16735: IFFALSE 16765
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16737: LD_VAR 0 2
16741: PUSH
16742: LD_VAR 0 3
16746: ARRAY
16747: PPUSH
16748: LD_VAR 0 1
16752: PUSH
16753: LD_VAR 0 3
16757: ARRAY
16758: PPUSH
16759: CALL_OW 52
// end ;
16763: GO 16734
16765: POP
16766: POP
// for i in u1 do
16767: LD_ADDR_VAR 0 3
16771: PUSH
16772: LD_VAR 0 1
16776: PUSH
16777: FOR_IN
16778: IFFALSE 16797
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16780: LD_VAR 0 3
16784: PPUSH
16785: LD_INT 15
16787: PPUSH
16788: LD_INT 0
16790: PPUSH
16791: CALL 23687 0 3
// end ;
16795: GO 16777
16797: POP
16798: POP
// for i in u1a do
16799: LD_ADDR_VAR 0 3
16803: PUSH
16804: LD_VAR 0 4
16808: PUSH
16809: FOR_IN
16810: IFFALSE 16829
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16812: LD_VAR 0 3
16816: PPUSH
16817: LD_INT 15
16819: PPUSH
16820: LD_INT 0
16822: PPUSH
16823: CALL 23687 0 3
// end ;
16827: GO 16809
16829: POP
16830: POP
// wait ( 0 0$4 ) ;
16831: LD_INT 140
16833: PPUSH
16834: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16838: LD_VAR 0 1
16842: PPUSH
16843: LD_EXP 110
16847: PUSH
16848: LD_EXP 116
16852: ADD
16853: PUSH
16854: LD_EXP 113
16858: ADD
16859: PPUSH
16860: CALL 13743 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
16864: LD_VAR 0 4
16868: PPUSH
16869: LD_EXP 108
16873: PUSH
16874: LD_EXP 111
16878: ADD
16879: PPUSH
16880: CALL 13743 0 2
// end ;
16884: PPOPN 4
16886: END
// every 37 37$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , b1 ;
16887: LD_EXP 2
16891: IFFALSE 17551
16893: GO 16895
16895: DISABLE
16896: LD_INT 0
16898: PPUSH
16899: PPUSH
16900: PPUSH
16901: PPUSH
16902: PPUSH
16903: PPUSH
16904: PPUSH
16905: PPUSH
// begin case difficulty of 1 :
16906: LD_OWVAR 67
16910: PUSH
16911: LD_INT 1
16913: DOUBLE
16914: EQUAL
16915: IFTRUE 16919
16917: GO 16962
16919: POP
// begin u1 := CreateVC ( [ mg ] ) ;
16920: LD_ADDR_VAR 0 1
16924: PUSH
16925: LD_EXP 11
16929: PUSH
16930: EMPTY
16931: LIST
16932: PPUSH
16933: CALL 23357 0 1
16937: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
16938: LD_ADDR_VAR 0 8
16942: PUSH
16943: LD_INT 2
16945: PPUSH
16946: CALL 22783 0 1
16950: PUSH
16951: LD_INT 1
16953: PPUSH
16954: CALL 22907 0 1
16958: ADD
16959: ST_TO_ADDR
// end ; 2 :
16960: GO 17071
16962: LD_INT 2
16964: DOUBLE
16965: EQUAL
16966: IFTRUE 16970
16968: GO 17013
16970: POP
// begin u1 := CreateVC ( [ hhg ] ) ;
16971: LD_ADDR_VAR 0 1
16975: PUSH
16976: LD_EXP 15
16980: PUSH
16981: EMPTY
16982: LIST
16983: PPUSH
16984: CALL 23357 0 1
16988: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 2 ) ;
16989: LD_ADDR_VAR 0 8
16993: PUSH
16994: LD_INT 2
16996: PPUSH
16997: CALL 22783 0 1
17001: PUSH
17002: LD_INT 2
17004: PPUSH
17005: CALL 22907 0 1
17009: ADD
17010: ST_TO_ADDR
// end ; 3 :
17011: GO 17071
17013: LD_INT 3
17015: DOUBLE
17016: EQUAL
17017: IFTRUE 17021
17019: GO 17070
17021: POP
// begin u1 := CreateVC ( [ hhg , hgg ] ) ;
17022: LD_ADDR_VAR 0 1
17026: PUSH
17027: LD_EXP 15
17031: PUSH
17032: LD_EXP 13
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PPUSH
17041: CALL 23357 0 1
17045: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 3 ) ;
17046: LD_ADDR_VAR 0 8
17050: PUSH
17051: LD_INT 3
17053: PPUSH
17054: CALL 22783 0 1
17058: PUSH
17059: LD_INT 3
17061: PPUSH
17062: CALL 22907 0 1
17066: ADD
17067: ST_TO_ADDR
// end ; end ;
17068: GO 17071
17070: POP
// for i in u1 do
17071: LD_ADDR_VAR 0 3
17075: PUSH
17076: LD_VAR 0 1
17080: PUSH
17081: FOR_IN
17082: IFFALSE 17101
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17084: LD_VAR 0 3
17088: PPUSH
17089: LD_INT 14
17091: PPUSH
17092: LD_INT 0
17094: PPUSH
17095: CALL 23687 0 3
// end ;
17099: GO 17081
17101: POP
17102: POP
// wait ( 0 0$1 ) ;
17103: LD_INT 35
17105: PPUSH
17106: CALL_OW 67
// AttackBase ( u1 , pathUT ^ pathUR ) ;
17110: LD_VAR 0 1
17114: PPUSH
17115: LD_EXP 113
17119: PUSH
17120: LD_EXP 112
17124: ADD
17125: PPUSH
17126: CALL 13743 0 2
// AttackBase ( b1 , pathUT ^ pathUR ) ;
17130: LD_VAR 0 8
17134: PPUSH
17135: LD_EXP 113
17139: PUSH
17140: LD_EXP 112
17144: ADD
17145: PPUSH
17146: CALL 13743 0 2
// case difficulty of 1 :
17150: LD_OWVAR 67
17154: PUSH
17155: LD_INT 1
17157: DOUBLE
17158: EQUAL
17159: IFTRUE 17163
17161: GO 17200
17163: POP
// begin u2 := CreateVH ( [ mgg ] ) ;
17164: LD_ADDR_VAR 0 4
17168: PUSH
17169: LD_EXP 10
17173: PUSH
17174: EMPTY
17175: LIST
17176: PPUSH
17177: CALL 23031 0 1
17181: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
17182: LD_ADDR_VAR 0 5
17186: PUSH
17187: LD_INT 1
17189: PPUSH
17190: LD_INT 0
17192: PPUSH
17193: CALL 22578 0 2
17197: ST_TO_ADDR
// end ; 2 :
17198: GO 17303
17200: LD_INT 2
17202: DOUBLE
17203: EQUAL
17204: IFTRUE 17208
17206: GO 17251
17208: POP
// begin u2 := CreateVH ( [ mgg , mg ] ) ;
17209: LD_ADDR_VAR 0 4
17213: PUSH
17214: LD_EXP 10
17218: PUSH
17219: LD_EXP 11
17223: PUSH
17224: EMPTY
17225: LIST
17226: LIST
17227: PPUSH
17228: CALL 23031 0 1
17232: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17233: LD_ADDR_VAR 0 5
17237: PUSH
17238: LD_INT 0
17240: PPUSH
17241: LD_INT 2
17243: PPUSH
17244: CALL 22578 0 2
17248: ST_TO_ADDR
// end ; 3 :
17249: GO 17303
17251: LD_INT 3
17253: DOUBLE
17254: EQUAL
17255: IFTRUE 17259
17257: GO 17302
17259: POP
// begin u2 := CreateVH ( [ mgg , hhg ] ) ;
17260: LD_ADDR_VAR 0 4
17264: PUSH
17265: LD_EXP 10
17269: PUSH
17270: LD_EXP 15
17274: PUSH
17275: EMPTY
17276: LIST
17277: LIST
17278: PPUSH
17279: CALL 23031 0 1
17283: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17284: LD_ADDR_VAR 0 5
17288: PUSH
17289: LD_INT 0
17291: PPUSH
17292: LD_INT 2
17294: PPUSH
17295: CALL 22578 0 2
17299: ST_TO_ADDR
// end ; end ;
17300: GO 17303
17302: POP
// for i := 1 to u2 do
17303: LD_ADDR_VAR 0 3
17307: PUSH
17308: DOUBLE
17309: LD_INT 1
17311: DEC
17312: ST_TO_ADDR
17313: LD_VAR 0 4
17317: PUSH
17318: FOR_TO
17319: IFFALSE 17349
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
17321: LD_VAR 0 5
17325: PUSH
17326: LD_VAR 0 3
17330: ARRAY
17331: PPUSH
17332: LD_VAR 0 4
17336: PUSH
17337: LD_VAR 0 3
17341: ARRAY
17342: PPUSH
17343: CALL_OW 52
// end ;
17347: GO 17318
17349: POP
17350: POP
// for i in u2 do
17351: LD_ADDR_VAR 0 3
17355: PUSH
17356: LD_VAR 0 4
17360: PUSH
17361: FOR_IN
17362: IFFALSE 17381
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
17364: LD_VAR 0 3
17368: PPUSH
17369: LD_INT 3
17371: PPUSH
17372: LD_INT 0
17374: PPUSH
17375: CALL 23687 0 3
// end ;
17379: GO 17361
17381: POP
17382: POP
// wait ( 0 0$1 ) ;
17383: LD_INT 35
17385: PPUSH
17386: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
17390: LD_VAR 0 4
17394: PPUSH
17395: LD_EXP 108
17399: PUSH
17400: LD_EXP 111
17404: ADD
17405: PPUSH
17406: CALL 13743 0 2
// case difficulty of 1 :
17410: LD_OWVAR 67
17414: PUSH
17415: LD_INT 1
17417: DOUBLE
17418: EQUAL
17419: IFTRUE 17423
17421: GO 17439
17423: POP
// begin u3 := CreateS ( 1 ) ;
17424: LD_ADDR_VAR 0 6
17428: PUSH
17429: LD_INT 1
17431: PPUSH
17432: CALL 22907 0 1
17436: ST_TO_ADDR
// ; end ; 2 :
17437: GO 17498
17439: LD_INT 2
17441: DOUBLE
17442: EQUAL
17443: IFTRUE 17447
17445: GO 17468
17447: POP
// begin u3 := CreateVC ( [ mgg ] ) ;
17448: LD_ADDR_VAR 0 6
17452: PUSH
17453: LD_EXP 10
17457: PUSH
17458: EMPTY
17459: LIST
17460: PPUSH
17461: CALL 23357 0 1
17465: ST_TO_ADDR
// end ; 3 :
17466: GO 17498
17468: LD_INT 3
17470: DOUBLE
17471: EQUAL
17472: IFTRUE 17476
17474: GO 17497
17476: POP
// begin u3 := CreateVC ( [ hgg ] ) ;
17477: LD_ADDR_VAR 0 6
17481: PUSH
17482: LD_EXP 13
17486: PUSH
17487: EMPTY
17488: LIST
17489: PPUSH
17490: CALL 23357 0 1
17494: ST_TO_ADDR
// end ; end ;
17495: GO 17498
17497: POP
// for i in u3 do
17498: LD_ADDR_VAR 0 3
17502: PUSH
17503: LD_VAR 0 6
17507: PUSH
17508: FOR_IN
17509: IFFALSE 17528
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17511: LD_VAR 0 3
17515: PPUSH
17516: LD_INT 14
17518: PPUSH
17519: LD_INT 0
17521: PPUSH
17522: CALL 23687 0 3
// end ;
17526: GO 17508
17528: POP
17529: POP
// wait ( 0 0$1 ) ;
17530: LD_INT 35
17532: PPUSH
17533: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
17537: LD_VAR 0 6
17541: PPUSH
17542: LD_EXP 117
17546: PPUSH
17547: CALL 13743 0 2
// end ;
17551: PPOPN 8
17553: END
// every 38 38$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
17554: LD_EXP 2
17558: IFFALSE 18019
17560: GO 17562
17562: DISABLE
17563: LD_INT 0
17565: PPUSH
17566: PPUSH
17567: PPUSH
17568: PPUSH
17569: PPUSH
17570: PPUSH
17571: PPUSH
// begin case difficulty of 1 :
17572: LD_OWVAR 67
17576: PUSH
17577: LD_INT 1
17579: DOUBLE
17580: EQUAL
17581: IFTRUE 17585
17583: GO 17622
17585: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
17586: LD_ADDR_VAR 0 1
17590: PUSH
17591: LD_EXP 15
17595: PUSH
17596: EMPTY
17597: LIST
17598: PPUSH
17599: CALL 23031 0 1
17603: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
17604: LD_ADDR_VAR 0 2
17608: PUSH
17609: LD_INT 1
17611: PPUSH
17612: LD_INT 0
17614: PPUSH
17615: CALL 22578 0 2
17619: ST_TO_ADDR
// end ; 2 :
17620: GO 17725
17622: LD_INT 2
17624: DOUBLE
17625: EQUAL
17626: IFTRUE 17630
17628: GO 17673
17630: POP
// begin u1 := CreateVH ( [ mrl , hhg ] ) ;
17631: LD_ADDR_VAR 0 1
17635: PUSH
17636: LD_EXP 12
17640: PUSH
17641: LD_EXP 15
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: PPUSH
17650: CALL 23031 0 1
17654: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
17655: LD_ADDR_VAR 0 2
17659: PUSH
17660: LD_INT 1
17662: PPUSH
17663: LD_INT 1
17665: PPUSH
17666: CALL 22578 0 2
17670: ST_TO_ADDR
// end ; 3 :
17671: GO 17725
17673: LD_INT 3
17675: DOUBLE
17676: EQUAL
17677: IFTRUE 17681
17679: GO 17724
17681: POP
// begin u1 := CreateVH ( [ hrl , hhg ] ) ;
17682: LD_ADDR_VAR 0 1
17686: PUSH
17687: LD_EXP 14
17691: PUSH
17692: LD_EXP 15
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: PPUSH
17701: CALL 23031 0 1
17705: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
17706: LD_ADDR_VAR 0 2
17710: PUSH
17711: LD_INT 0
17713: PPUSH
17714: LD_INT 2
17716: PPUSH
17717: CALL 22578 0 2
17721: ST_TO_ADDR
// end ; end ;
17722: GO 17725
17724: POP
// for i := 1 to u1 do
17725: LD_ADDR_VAR 0 3
17729: PUSH
17730: DOUBLE
17731: LD_INT 1
17733: DEC
17734: ST_TO_ADDR
17735: LD_VAR 0 1
17739: PUSH
17740: FOR_TO
17741: IFFALSE 17771
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
17743: LD_VAR 0 2
17747: PUSH
17748: LD_VAR 0 3
17752: ARRAY
17753: PPUSH
17754: LD_VAR 0 1
17758: PUSH
17759: LD_VAR 0 3
17763: ARRAY
17764: PPUSH
17765: CALL_OW 52
// end ;
17769: GO 17740
17771: POP
17772: POP
// for i in u1 do
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: LD_VAR 0 1
17782: PUSH
17783: FOR_IN
17784: IFFALSE 17803
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
17786: LD_VAR 0 3
17790: PPUSH
17791: LD_INT 2
17793: PPUSH
17794: LD_INT 0
17796: PPUSH
17797: CALL 23687 0 3
// end ;
17801: GO 17783
17803: POP
17804: POP
// wait ( 0 0$4 ) ;
17805: LD_INT 140
17807: PPUSH
17808: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
17812: LD_VAR 0 1
17816: PPUSH
17817: LD_EXP 109
17821: PUSH
17822: LD_EXP 114
17826: PPUSH
17827: CALL 13338 0 1
17831: ADD
17832: PUSH
17833: LD_EXP 111
17837: ADD
17838: PPUSH
17839: CALL 13743 0 2
// case difficulty of 1 :
17843: LD_OWVAR 67
17847: PUSH
17848: LD_INT 1
17850: DOUBLE
17851: EQUAL
17852: IFTRUE 17856
17854: GO 17883
17856: POP
// begin u2 := CreateVC ( [ mgg , mrl ] ) ;
17857: LD_ADDR_VAR 0 4
17861: PUSH
17862: LD_EXP 10
17866: PUSH
17867: LD_EXP 12
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: PPUSH
17876: CALL 23357 0 1
17880: ST_TO_ADDR
// end ; 2 :
17881: GO 17954
17883: LD_INT 2
17885: DOUBLE
17886: EQUAL
17887: IFTRUE 17891
17889: GO 17918
17891: POP
// begin u2 := CreateVC ( [ hgg , mrl ] ) ;
17892: LD_ADDR_VAR 0 4
17896: PUSH
17897: LD_EXP 13
17901: PUSH
17902: LD_EXP 12
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: PPUSH
17911: CALL 23357 0 1
17915: ST_TO_ADDR
// end ; 3 :
17916: GO 17954
17918: LD_INT 3
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17953
17926: POP
// begin u2 := CreateVC ( [ hgg , hrl ] ) ;
17927: LD_ADDR_VAR 0 4
17931: PUSH
17932: LD_EXP 13
17936: PUSH
17937: LD_EXP 14
17941: PUSH
17942: EMPTY
17943: LIST
17944: LIST
17945: PPUSH
17946: CALL 23357 0 1
17950: ST_TO_ADDR
// end ; end ;
17951: GO 17954
17953: POP
// for i in u2 do
17954: LD_ADDR_VAR 0 3
17958: PUSH
17959: LD_VAR 0 4
17963: PUSH
17964: FOR_IN
17965: IFFALSE 17984
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
17967: LD_VAR 0 3
17971: PPUSH
17972: LD_INT 2
17974: PPUSH
17975: LD_INT 0
17977: PPUSH
17978: CALL 23687 0 3
// end ;
17982: GO 17964
17984: POP
17985: POP
// wait ( 0 0$1 ) ;
17986: LD_INT 35
17988: PPUSH
17989: CALL_OW 67
// AttackBase ( u2 , pathBM ^ pathMM ^ pathUR ) ;
17993: LD_VAR 0 4
17997: PPUSH
17998: LD_EXP 109
18002: PUSH
18003: LD_EXP 115
18007: ADD
18008: PUSH
18009: LD_EXP 112
18013: ADD
18014: PPUSH
18015: CALL 13743 0 2
// end ;
18019: PPOPN 7
18021: END
// every 41 41$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
18022: LD_EXP 2
18026: IFFALSE 18222
18028: GO 18030
18030: DISABLE
18031: LD_INT 0
18033: PPUSH
18034: PPUSH
18035: PPUSH
18036: PPUSH
18037: PPUSH
18038: PPUSH
18039: PPUSH
// begin case difficulty of 1 :
18040: LD_OWVAR 67
18044: PUSH
18045: LD_INT 1
18047: DOUBLE
18048: EQUAL
18049: IFTRUE 18053
18051: GO 18080
18053: POP
// begin u1 := CreateVC ( [ hrl , mgg ] ) ;
18054: LD_ADDR_VAR 0 1
18058: PUSH
18059: LD_EXP 14
18063: PUSH
18064: LD_EXP 10
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PPUSH
18073: CALL 23357 0 1
18077: ST_TO_ADDR
// end ; 2 :
18078: GO 18169
18080: LD_INT 2
18082: DOUBLE
18083: EQUAL
18084: IFTRUE 18088
18086: GO 18121
18088: POP
// begin u1 := CreateVC ( [ hrl , hrl , mgg ] ) ;
18089: LD_ADDR_VAR 0 1
18093: PUSH
18094: LD_EXP 14
18098: PUSH
18099: LD_EXP 14
18103: PUSH
18104: LD_EXP 10
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PPUSH
18114: CALL 23357 0 1
18118: ST_TO_ADDR
// end ; 3 :
18119: GO 18169
18121: LD_INT 3
18123: DOUBLE
18124: EQUAL
18125: IFTRUE 18129
18127: GO 18168
18129: POP
// begin u1 := CreateVC ( [ hrl , hrl , hhg , mgg ] ) ;
18130: LD_ADDR_VAR 0 1
18134: PUSH
18135: LD_EXP 14
18139: PUSH
18140: LD_EXP 14
18144: PUSH
18145: LD_EXP 15
18149: PUSH
18150: LD_EXP 10
18154: PUSH
18155: EMPTY
18156: LIST
18157: LIST
18158: LIST
18159: LIST
18160: PPUSH
18161: CALL 23357 0 1
18165: ST_TO_ADDR
// end ; end ;
18166: GO 18169
18168: POP
// for i in u1 do
18169: LD_ADDR_VAR 0 3
18173: PUSH
18174: LD_VAR 0 1
18178: PUSH
18179: FOR_IN
18180: IFFALSE 18199
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18182: LD_VAR 0 3
18186: PPUSH
18187: LD_INT 14
18189: PPUSH
18190: LD_INT 0
18192: PPUSH
18193: CALL 23687 0 3
// end ;
18197: GO 18179
18199: POP
18200: POP
// wait ( 0 0$4 ) ;
18201: LD_INT 140
18203: PPUSH
18204: CALL_OW 67
// AttackBase ( u1 , pathT ) ;
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_EXP 117
18217: PPUSH
18218: CALL 13743 0 2
// end ;
18222: PPOPN 7
18224: END
// every 44 44$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , u2a ;
18225: LD_EXP 2
18229: IFFALSE 19066
18231: GO 18233
18233: DISABLE
18234: LD_INT 0
18236: PPUSH
18237: PPUSH
18238: PPUSH
18239: PPUSH
18240: PPUSH
18241: PPUSH
18242: PPUSH
18243: PPUSH
// begin case difficulty of 1 :
18244: LD_OWVAR 67
18248: PUSH
18249: LD_INT 1
18251: DOUBLE
18252: EQUAL
18253: IFTRUE 18257
18255: GO 18306
18257: POP
// begin u1 := CreateVH ( [ hrl , mg , mrl ] ) ;
18258: LD_ADDR_VAR 0 1
18262: PUSH
18263: LD_EXP 14
18267: PUSH
18268: LD_EXP 11
18272: PUSH
18273: LD_EXP 12
18277: PUSH
18278: EMPTY
18279: LIST
18280: LIST
18281: LIST
18282: PPUSH
18283: CALL 23031 0 1
18287: ST_TO_ADDR
// p1 := CreateH ( 2 , 1 ) ;
18288: LD_ADDR_VAR 0 2
18292: PUSH
18293: LD_INT 2
18295: PPUSH
18296: LD_INT 1
18298: PPUSH
18299: CALL 22578 0 2
18303: ST_TO_ADDR
// end ; 2 :
18304: GO 18433
18306: LD_INT 2
18308: DOUBLE
18309: EQUAL
18310: IFTRUE 18314
18312: GO 18369
18314: POP
// begin u1 := CreateVH ( [ hrl , hhg , mrl , mgg ] ) ;
18315: LD_ADDR_VAR 0 1
18319: PUSH
18320: LD_EXP 14
18324: PUSH
18325: LD_EXP 15
18329: PUSH
18330: LD_EXP 12
18334: PUSH
18335: LD_EXP 10
18339: PUSH
18340: EMPTY
18341: LIST
18342: LIST
18343: LIST
18344: LIST
18345: PPUSH
18346: CALL 23031 0 1
18350: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18351: LD_ADDR_VAR 0 2
18355: PUSH
18356: LD_INT 3
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: CALL 22578 0 2
18366: ST_TO_ADDR
// end ; 3 :
18367: GO 18433
18369: LD_INT 3
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18432
18377: POP
// begin u1 := CreateVH ( [ hrl , hhg , hrl , hgg ] ) ;
18378: LD_ADDR_VAR 0 1
18382: PUSH
18383: LD_EXP 14
18387: PUSH
18388: LD_EXP 15
18392: PUSH
18393: LD_EXP 14
18397: PUSH
18398: LD_EXP 13
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: PPUSH
18409: CALL 23031 0 1
18413: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18414: LD_ADDR_VAR 0 2
18418: PUSH
18419: LD_INT 3
18421: PPUSH
18422: LD_INT 1
18424: PPUSH
18425: CALL 22578 0 2
18429: ST_TO_ADDR
// end ; end ;
18430: GO 18433
18432: POP
// for i := 1 to u1 do
18433: LD_ADDR_VAR 0 3
18437: PUSH
18438: DOUBLE
18439: LD_INT 1
18441: DEC
18442: ST_TO_ADDR
18443: LD_VAR 0 1
18447: PUSH
18448: FOR_TO
18449: IFFALSE 18479
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
18451: LD_VAR 0 2
18455: PUSH
18456: LD_VAR 0 3
18460: ARRAY
18461: PPUSH
18462: LD_VAR 0 1
18466: PUSH
18467: LD_VAR 0 3
18471: ARRAY
18472: PPUSH
18473: CALL_OW 52
// end ;
18477: GO 18448
18479: POP
18480: POP
// for i in u1 do
18481: LD_ADDR_VAR 0 3
18485: PUSH
18486: LD_VAR 0 1
18490: PUSH
18491: FOR_IN
18492: IFFALSE 18511
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18494: LD_VAR 0 3
18498: PPUSH
18499: LD_INT 14
18501: PPUSH
18502: LD_INT 0
18504: PPUSH
18505: CALL 23687 0 3
// end ;
18509: GO 18491
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// AttackBase ( u1 , pathUT ) ;
18520: LD_VAR 0 1
18524: PPUSH
18525: LD_EXP 113
18529: PPUSH
18530: CALL 13743 0 2
// case difficulty of 1 :
18534: LD_OWVAR 67
18538: PUSH
18539: LD_INT 1
18541: DOUBLE
18542: EQUAL
18543: IFTRUE 18547
18545: GO 18608
18547: POP
// begin u2 := CreateVH ( [ hgg ] ) ;
18548: LD_ADDR_VAR 0 4
18552: PUSH
18553: LD_EXP 13
18557: PUSH
18558: EMPTY
18559: LIST
18560: PPUSH
18561: CALL 23031 0 1
18565: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18566: LD_ADDR_VAR 0 8
18570: PUSH
18571: LD_EXP 11
18575: PUSH
18576: LD_EXP 15
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: PPUSH
18585: CALL 23357 0 1
18589: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
18590: LD_ADDR_VAR 0 5
18594: PUSH
18595: LD_INT 1
18597: PPUSH
18598: LD_INT 0
18600: PPUSH
18601: CALL 22578 0 2
18605: ST_TO_ADDR
// end ; 2 :
18606: GO 18759
18608: LD_INT 2
18610: DOUBLE
18611: EQUAL
18612: IFTRUE 18616
18614: GO 18683
18616: POP
// begin u2 := CreateVH ( [ hgg , mrl ] ) ;
18617: LD_ADDR_VAR 0 4
18621: PUSH
18622: LD_EXP 13
18626: PUSH
18627: LD_EXP 12
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: PPUSH
18636: CALL 23031 0 1
18640: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18641: LD_ADDR_VAR 0 8
18645: PUSH
18646: LD_EXP 11
18650: PUSH
18651: LD_EXP 15
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL 23357 0 1
18664: ST_TO_ADDR
// p2 := CreateH ( 1 , 1 ) ;
18665: LD_ADDR_VAR 0 5
18669: PUSH
18670: LD_INT 1
18672: PPUSH
18673: LD_INT 1
18675: PPUSH
18676: CALL 22578 0 2
18680: ST_TO_ADDR
// end ; 3 :
18681: GO 18759
18683: LD_INT 3
18685: DOUBLE
18686: EQUAL
18687: IFTRUE 18691
18689: GO 18758
18691: POP
// begin u2 := CreateVH ( [ hgg , hrl ] ) ;
18692: LD_ADDR_VAR 0 4
18696: PUSH
18697: LD_EXP 13
18701: PUSH
18702: LD_EXP 14
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: PPUSH
18711: CALL 23031 0 1
18715: ST_TO_ADDR
// u2a := CreateVC ( [ hhg , hhg ] ) ;
18716: LD_ADDR_VAR 0 8
18720: PUSH
18721: LD_EXP 15
18725: PUSH
18726: LD_EXP 15
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 23357 0 1
18739: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
18740: LD_ADDR_VAR 0 5
18744: PUSH
18745: LD_INT 0
18747: PPUSH
18748: LD_INT 2
18750: PPUSH
18751: CALL 22578 0 2
18755: ST_TO_ADDR
// end ; end ;
18756: GO 18759
18758: POP
// for i := 1 to u2 do
18759: LD_ADDR_VAR 0 3
18763: PUSH
18764: DOUBLE
18765: LD_INT 1
18767: DEC
18768: ST_TO_ADDR
18769: LD_VAR 0 4
18773: PUSH
18774: FOR_TO
18775: IFFALSE 18805
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
18777: LD_VAR 0 5
18781: PUSH
18782: LD_VAR 0 3
18786: ARRAY
18787: PPUSH
18788: LD_VAR 0 4
18792: PUSH
18793: LD_VAR 0 3
18797: ARRAY
18798: PPUSH
18799: CALL_OW 52
// end ;
18803: GO 18774
18805: POP
18806: POP
// for i in u2 ^ u2a do
18807: LD_ADDR_VAR 0 3
18811: PUSH
18812: LD_VAR 0 4
18816: PUSH
18817: LD_VAR 0 8
18821: ADD
18822: PUSH
18823: FOR_IN
18824: IFFALSE 18843
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
18826: LD_VAR 0 3
18830: PPUSH
18831: LD_INT 3
18833: PPUSH
18834: LD_INT 0
18836: PPUSH
18837: CALL 23687 0 3
// end ;
18841: GO 18823
18843: POP
18844: POP
// wait ( 0 0$1 ) ;
18845: LD_INT 35
18847: PPUSH
18848: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
18852: LD_VAR 0 4
18856: PPUSH
18857: LD_EXP 108
18861: PUSH
18862: LD_EXP 111
18866: ADD
18867: PPUSH
18868: CALL 13743 0 2
// case difficulty of 1 :
18872: LD_OWVAR 67
18876: PUSH
18877: LD_INT 1
18879: DOUBLE
18880: EQUAL
18881: IFTRUE 18885
18883: GO 18918
18885: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl ] ) ;
18886: LD_ADDR_VAR 0 6
18890: PUSH
18891: LD_EXP 10
18895: PUSH
18896: LD_EXP 11
18900: PUSH
18901: LD_EXP 12
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: LIST
18910: PPUSH
18911: CALL 23357 0 1
18915: ST_TO_ADDR
// end ; 2 :
18916: GO 19013
18918: LD_INT 2
18920: DOUBLE
18921: EQUAL
18922: IFTRUE 18926
18924: GO 18965
18926: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl , hgg ] ) ;
18927: LD_ADDR_VAR 0 6
18931: PUSH
18932: LD_EXP 10
18936: PUSH
18937: LD_EXP 11
18941: PUSH
18942: LD_EXP 12
18946: PUSH
18947: LD_EXP 13
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: LIST
18956: LIST
18957: PPUSH
18958: CALL 23357 0 1
18962: ST_TO_ADDR
// end ; 3 :
18963: GO 19013
18965: LD_INT 3
18967: DOUBLE
18968: EQUAL
18969: IFTRUE 18973
18971: GO 19012
18973: POP
// begin u3 := CreateVC ( [ mgg , mg , hrl , hgg ] ) ;
18974: LD_ADDR_VAR 0 6
18978: PUSH
18979: LD_EXP 10
18983: PUSH
18984: LD_EXP 11
18988: PUSH
18989: LD_EXP 14
18993: PUSH
18994: LD_EXP 13
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: LIST
19003: LIST
19004: PPUSH
19005: CALL 23357 0 1
19009: ST_TO_ADDR
// end ; end ;
19010: GO 19013
19012: POP
// for i in u3 do
19013: LD_ADDR_VAR 0 3
19017: PUSH
19018: LD_VAR 0 6
19022: PUSH
19023: FOR_IN
19024: IFFALSE 19043
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19026: LD_VAR 0 3
19030: PPUSH
19031: LD_INT 14
19033: PPUSH
19034: LD_INT 0
19036: PPUSH
19037: CALL 23687 0 3
// end ;
19041: GO 19023
19043: POP
19044: POP
// wait ( 0 0$1 ) ;
19045: LD_INT 35
19047: PPUSH
19048: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
19052: LD_VAR 0 6
19056: PPUSH
19057: LD_EXP 117
19061: PPUSH
19062: CALL 13743 0 2
// end ;
19066: PPOPN 8
19068: END
// every 0 0$5 trigger last_attack and timer < rusaci_pred_koncem do var u1 , p1 , i , u2 , p2 , u3 , p3 , u4 , p4 ;
19069: LD_EXP 3
19073: PUSH
19074: LD_EXP 62
19078: PUSH
19079: LD_EXP 6
19083: LESS
19084: AND
19085: IFFALSE 20668
19087: GO 19089
19089: DISABLE
19090: LD_INT 0
19092: PPUSH
19093: PPUSH
19094: PPUSH
19095: PPUSH
19096: PPUSH
19097: PPUSH
19098: PPUSH
19099: PPUSH
19100: PPUSH
// begin lev := [ 8 , 8 , 8 ] ;
19101: LD_ADDR_EXP 5
19105: PUSH
19106: LD_INT 8
19108: PUSH
19109: LD_INT 8
19111: PUSH
19112: LD_INT 8
19114: PUSH
19115: EMPTY
19116: LIST
19117: LIST
19118: LIST
19119: ST_TO_ADDR
// SetTech ( tech_Comp1 , russians , state_researched ) ;
19120: LD_INT 57
19122: PPUSH
19123: LD_EXP 49
19127: PPUSH
19128: LD_INT 2
19130: PPUSH
19131: CALL_OW 322
// SetTech ( tech_Comp2 , russians , state_researched ) ;
19135: LD_INT 58
19137: PPUSH
19138: LD_EXP 49
19142: PPUSH
19143: LD_INT 2
19145: PPUSH
19146: CALL_OW 322
// SetTech ( tech_Comp3 , russians , state_researched ) ;
19150: LD_INT 59
19152: PPUSH
19153: LD_EXP 49
19157: PPUSH
19158: LD_INT 2
19160: PPUSH
19161: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
19165: LD_INT 51
19167: PPUSH
19168: LD_EXP 49
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
19180: LD_INT 52
19182: PPUSH
19183: LD_EXP 49
19187: PPUSH
19188: LD_INT 2
19190: PPUSH
19191: CALL_OW 322
// SetTech ( tech_Weap3 , russians , state_researched ) ;
19195: LD_INT 53
19197: PPUSH
19198: LD_EXP 49
19202: PPUSH
19203: LD_INT 2
19205: PPUSH
19206: CALL_OW 322
// case difficulty of 1 :
19210: LD_OWVAR 67
19214: PUSH
19215: LD_INT 1
19217: DOUBLE
19218: EQUAL
19219: IFTRUE 19223
19221: GO 19262
19223: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19224: LD_ADDR_VAR 0 1
19228: PUSH
19229: LD_EXP 14
19233: PUSH
19234: LD_EXP 14
19238: PUSH
19239: LD_EXP 14
19243: PUSH
19244: LD_EXP 14
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: LIST
19253: LIST
19254: PPUSH
19255: CALL 23357 0 1
19259: ST_TO_ADDR
// end ; 2 :
19260: GO 19357
19262: LD_INT 2
19264: DOUBLE
19265: EQUAL
19266: IFTRUE 19270
19268: GO 19309
19270: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19271: LD_ADDR_VAR 0 1
19275: PUSH
19276: LD_EXP 14
19280: PUSH
19281: LD_EXP 14
19285: PUSH
19286: LD_EXP 14
19290: PUSH
19291: LD_EXP 14
19295: PUSH
19296: EMPTY
19297: LIST
19298: LIST
19299: LIST
19300: LIST
19301: PPUSH
19302: CALL 23357 0 1
19306: ST_TO_ADDR
// end ; 3 :
19307: GO 19357
19309: LD_INT 3
19311: DOUBLE
19312: EQUAL
19313: IFTRUE 19317
19315: GO 19356
19317: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19318: LD_ADDR_VAR 0 1
19322: PUSH
19323: LD_EXP 14
19327: PUSH
19328: LD_EXP 14
19332: PUSH
19333: LD_EXP 14
19337: PUSH
19338: LD_EXP 14
19342: PUSH
19343: EMPTY
19344: LIST
19345: LIST
19346: LIST
19347: LIST
19348: PPUSH
19349: CALL 23357 0 1
19353: ST_TO_ADDR
// end ; end ;
19354: GO 19357
19356: POP
// for i in u1 do
19357: LD_ADDR_VAR 0 3
19361: PUSH
19362: LD_VAR 0 1
19366: PUSH
19367: FOR_IN
19368: IFFALSE 19387
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19370: LD_VAR 0 3
19374: PPUSH
19375: LD_INT 14
19377: PPUSH
19378: LD_INT 0
19380: PPUSH
19381: CALL 23687 0 3
// end ;
19385: GO 19367
19387: POP
19388: POP
// wait ( 0 0$1 ) ;
19389: LD_INT 35
19391: PPUSH
19392: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
19396: LD_VAR 0 1
19400: PPUSH
19401: LD_EXP 108
19405: PUSH
19406: LD_EXP 111
19410: ADD
19411: PPUSH
19412: CALL 13743 0 2
// case difficulty of 1 :
19416: LD_OWVAR 67
19420: PUSH
19421: LD_INT 1
19423: DOUBLE
19424: EQUAL
19425: IFTRUE 19429
19427: GO 19478
19429: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_EXP 15
19439: PUSH
19440: LD_EXP 15
19444: PUSH
19445: LD_EXP 14
19449: PUSH
19450: EMPTY
19451: LIST
19452: LIST
19453: LIST
19454: PPUSH
19455: CALL 23031 0 1
19459: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19460: LD_ADDR_VAR 0 5
19464: PUSH
19465: LD_INT 0
19467: PPUSH
19468: LD_INT 3
19470: PPUSH
19471: CALL 22578 0 2
19475: ST_TO_ADDR
// end ; 2 :
19476: GO 19593
19478: LD_INT 2
19480: DOUBLE
19481: EQUAL
19482: IFTRUE 19486
19484: GO 19535
19486: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19487: LD_ADDR_VAR 0 4
19491: PUSH
19492: LD_EXP 15
19496: PUSH
19497: LD_EXP 15
19501: PUSH
19502: LD_EXP 14
19506: PUSH
19507: EMPTY
19508: LIST
19509: LIST
19510: LIST
19511: PPUSH
19512: CALL 23031 0 1
19516: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19517: LD_ADDR_VAR 0 5
19521: PUSH
19522: LD_INT 0
19524: PPUSH
19525: LD_INT 3
19527: PPUSH
19528: CALL 22578 0 2
19532: ST_TO_ADDR
// end ; 3 :
19533: GO 19593
19535: LD_INT 3
19537: DOUBLE
19538: EQUAL
19539: IFTRUE 19543
19541: GO 19592
19543: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19544: LD_ADDR_VAR 0 4
19548: PUSH
19549: LD_EXP 15
19553: PUSH
19554: LD_EXP 15
19558: PUSH
19559: LD_EXP 14
19563: PUSH
19564: EMPTY
19565: LIST
19566: LIST
19567: LIST
19568: PPUSH
19569: CALL 23031 0 1
19573: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19574: LD_ADDR_VAR 0 5
19578: PUSH
19579: LD_INT 0
19581: PPUSH
19582: LD_INT 3
19584: PPUSH
19585: CALL 22578 0 2
19589: ST_TO_ADDR
// end ; end ;
19590: GO 19593
19592: POP
// for i := 1 to u2 do
19593: LD_ADDR_VAR 0 3
19597: PUSH
19598: DOUBLE
19599: LD_INT 1
19601: DEC
19602: ST_TO_ADDR
19603: LD_VAR 0 4
19607: PUSH
19608: FOR_TO
19609: IFFALSE 19639
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
19611: LD_VAR 0 5
19615: PUSH
19616: LD_VAR 0 3
19620: ARRAY
19621: PPUSH
19622: LD_VAR 0 4
19626: PUSH
19627: LD_VAR 0 3
19631: ARRAY
19632: PPUSH
19633: CALL_OW 52
// end ;
19637: GO 19608
19639: POP
19640: POP
// for i in u2 do
19641: LD_ADDR_VAR 0 3
19645: PUSH
19646: LD_VAR 0 4
19650: PUSH
19651: FOR_IN
19652: IFFALSE 19671
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
19654: LD_VAR 0 3
19658: PPUSH
19659: LD_INT 2
19661: PPUSH
19662: LD_INT 0
19664: PPUSH
19665: CALL 23687 0 3
// end ;
19669: GO 19651
19671: POP
19672: POP
// wait ( 0 0$1 ) ;
19673: LD_INT 35
19675: PPUSH
19676: CALL_OW 67
// AttackBase ( u2 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
19680: LD_VAR 0 4
19684: PPUSH
19685: LD_EXP 109
19689: PUSH
19690: LD_EXP 114
19694: PPUSH
19695: CALL 13338 0 1
19699: ADD
19700: PUSH
19701: LD_EXP 111
19705: ADD
19706: PPUSH
19707: CALL 13743 0 2
// p4 := CreateS ( 3 ) ;
19711: LD_ADDR_VAR 0 9
19715: PUSH
19716: LD_INT 3
19718: PPUSH
19719: CALL 22907 0 1
19723: ST_TO_ADDR
// p4 := p4 ^ CreateB ( 3 ) ;
19724: LD_ADDR_VAR 0 9
19728: PUSH
19729: LD_VAR 0 9
19733: PUSH
19734: LD_INT 3
19736: PPUSH
19737: CALL 22783 0 1
19741: ADD
19742: ST_TO_ADDR
// for i in p4 do
19743: LD_ADDR_VAR 0 3
19747: PUSH
19748: LD_VAR 0 9
19752: PUSH
19753: FOR_IN
19754: IFFALSE 19773
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
19756: LD_VAR 0 3
19760: PPUSH
19761: LD_INT 15
19763: PPUSH
19764: LD_INT 0
19766: PPUSH
19767: CALL 23687 0 3
// end ;
19771: GO 19753
19773: POP
19774: POP
// wait ( 0 0$1 ) ;
19775: LD_INT 35
19777: PPUSH
19778: CALL_OW 67
// AttackBase ( p4 , pathBR ^ pathUR ) ;
19782: LD_VAR 0 9
19786: PPUSH
19787: LD_EXP 110
19791: PUSH
19792: LD_EXP 112
19796: ADD
19797: PPUSH
19798: CALL 13743 0 2
// case difficulty of 1 :
19802: LD_OWVAR 67
19806: PUSH
19807: LD_INT 1
19809: DOUBLE
19810: EQUAL
19811: IFTRUE 19815
19813: GO 19870
19815: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
19816: LD_ADDR_VAR 0 6
19820: PUSH
19821: LD_EXP 15
19825: PUSH
19826: LD_EXP 14
19830: PUSH
19831: LD_EXP 15
19835: PUSH
19836: LD_EXP 13
19840: PUSH
19841: EMPTY
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: PPUSH
19847: CALL 23031 0 1
19851: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
19852: LD_ADDR_VAR 0 7
19856: PUSH
19857: LD_INT 0
19859: PPUSH
19860: LD_INT 4
19862: PPUSH
19863: CALL 22578 0 2
19867: ST_TO_ADDR
// end ; 2 :
19868: GO 19997
19870: LD_INT 2
19872: DOUBLE
19873: EQUAL
19874: IFTRUE 19878
19876: GO 19933
19878: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
19879: LD_ADDR_VAR 0 6
19883: PUSH
19884: LD_EXP 15
19888: PUSH
19889: LD_EXP 14
19893: PUSH
19894: LD_EXP 15
19898: PUSH
19899: LD_EXP 13
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: PPUSH
19910: CALL 23031 0 1
19914: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
19915: LD_ADDR_VAR 0 7
19919: PUSH
19920: LD_INT 0
19922: PPUSH
19923: LD_INT 4
19925: PPUSH
19926: CALL 22578 0 2
19930: ST_TO_ADDR
// end ; 3 :
19931: GO 19997
19933: LD_INT 3
19935: DOUBLE
19936: EQUAL
19937: IFTRUE 19941
19939: GO 19996
19941: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
19942: LD_ADDR_VAR 0 6
19946: PUSH
19947: LD_EXP 15
19951: PUSH
19952: LD_EXP 14
19956: PUSH
19957: LD_EXP 15
19961: PUSH
19962: LD_EXP 13
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: PPUSH
19973: CALL 23031 0 1
19977: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
19978: LD_ADDR_VAR 0 7
19982: PUSH
19983: LD_INT 0
19985: PPUSH
19986: LD_INT 4
19988: PPUSH
19989: CALL 22578 0 2
19993: ST_TO_ADDR
// end ; end ;
19994: GO 19997
19996: POP
// for i := 1 to u3 do
19997: LD_ADDR_VAR 0 3
20001: PUSH
20002: DOUBLE
20003: LD_INT 1
20005: DEC
20006: ST_TO_ADDR
20007: LD_VAR 0 6
20011: PUSH
20012: FOR_TO
20013: IFFALSE 20043
// begin PlaceHumanInUnit ( p3 [ i ] , u3 [ i ] ) ;
20015: LD_VAR 0 7
20019: PUSH
20020: LD_VAR 0 3
20024: ARRAY
20025: PPUSH
20026: LD_VAR 0 6
20030: PUSH
20031: LD_VAR 0 3
20035: ARRAY
20036: PPUSH
20037: CALL_OW 52
// end ;
20041: GO 20012
20043: POP
20044: POP
// for i in u3 do
20045: LD_ADDR_VAR 0 3
20049: PUSH
20050: LD_VAR 0 6
20054: PUSH
20055: FOR_IN
20056: IFFALSE 20075
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20058: LD_VAR 0 3
20062: PPUSH
20063: LD_INT 15
20065: PPUSH
20066: LD_INT 0
20068: PPUSH
20069: CALL 23687 0 3
// end ;
20073: GO 20055
20075: POP
20076: POP
// wait ( 0 0$1 ) ;
20077: LD_INT 35
20079: PPUSH
20080: CALL_OW 67
// AttackBase ( u3 , pathBR ^ pathUR ) ;
20084: LD_VAR 0 6
20088: PPUSH
20089: LD_EXP 110
20093: PUSH
20094: LD_EXP 112
20098: ADD
20099: PPUSH
20100: CALL 13743 0 2
// case difficulty of 1 :
20104: LD_OWVAR 67
20108: PUSH
20109: LD_INT 1
20111: DOUBLE
20112: EQUAL
20113: IFTRUE 20117
20115: GO 20156
20117: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20118: LD_ADDR_VAR 0 8
20122: PUSH
20123: LD_EXP 13
20127: PUSH
20128: LD_EXP 14
20132: PUSH
20133: LD_EXP 15
20137: PUSH
20138: LD_EXP 10
20142: PUSH
20143: EMPTY
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: PPUSH
20149: CALL 23357 0 1
20153: ST_TO_ADDR
// end ; 2 :
20154: GO 20251
20156: LD_INT 2
20158: DOUBLE
20159: EQUAL
20160: IFTRUE 20164
20162: GO 20203
20164: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20165: LD_ADDR_VAR 0 8
20169: PUSH
20170: LD_EXP 13
20174: PUSH
20175: LD_EXP 14
20179: PUSH
20180: LD_EXP 15
20184: PUSH
20185: LD_EXP 10
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: PPUSH
20196: CALL 23357 0 1
20200: ST_TO_ADDR
// end ; 3 :
20201: GO 20251
20203: LD_INT 3
20205: DOUBLE
20206: EQUAL
20207: IFTRUE 20211
20209: GO 20250
20211: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20212: LD_ADDR_VAR 0 8
20216: PUSH
20217: LD_EXP 13
20221: PUSH
20222: LD_EXP 14
20226: PUSH
20227: LD_EXP 15
20231: PUSH
20232: LD_EXP 10
20236: PUSH
20237: EMPTY
20238: LIST
20239: LIST
20240: LIST
20241: LIST
20242: PPUSH
20243: CALL 23357 0 1
20247: ST_TO_ADDR
// end ; end ;
20248: GO 20251
20250: POP
// for i in u4 do
20251: LD_ADDR_VAR 0 3
20255: PUSH
20256: LD_VAR 0 8
20260: PUSH
20261: FOR_IN
20262: IFFALSE 20281
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
20264: LD_VAR 0 3
20268: PPUSH
20269: LD_INT 14
20271: PPUSH
20272: LD_INT 0
20274: PPUSH
20275: CALL 23687 0 3
// end ;
20279: GO 20261
20281: POP
20282: POP
// wait ( 0 0$1 ) ;
20283: LD_INT 35
20285: PPUSH
20286: CALL_OW 67
// AttackBase ( u4 , pathUT ) ;
20290: LD_VAR 0 8
20294: PPUSH
20295: LD_EXP 113
20299: PPUSH
20300: CALL 13743 0 2
// p4 := CreateB ( 3 ) ;
20304: LD_ADDR_VAR 0 9
20308: PUSH
20309: LD_INT 3
20311: PPUSH
20312: CALL 22783 0 1
20316: ST_TO_ADDR
// p4 := p4 ^ CreateS ( 3 ) ;
20317: LD_ADDR_VAR 0 9
20321: PUSH
20322: LD_VAR 0 9
20326: PUSH
20327: LD_INT 3
20329: PPUSH
20330: CALL 22907 0 1
20334: ADD
20335: ST_TO_ADDR
// for i in p4 do
20336: LD_ADDR_VAR 0 3
20340: PUSH
20341: LD_VAR 0 9
20345: PUSH
20346: FOR_IN
20347: IFFALSE 20366
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20349: LD_VAR 0 3
20353: PPUSH
20354: LD_INT 15
20356: PPUSH
20357: LD_INT 0
20359: PPUSH
20360: CALL 23687 0 3
// end ;
20364: GO 20346
20366: POP
20367: POP
// wait ( 0 0$1 ) ;
20368: LD_INT 35
20370: PPUSH
20371: CALL_OW 67
// AttackBase ( p4 , pathUT ) ;
20375: LD_VAR 0 9
20379: PPUSH
20380: LD_EXP 113
20384: PPUSH
20385: CALL 13743 0 2
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_siberite_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_turret ] ] ] ) do
20389: LD_ADDR_VAR 0 3
20393: PUSH
20394: LD_INT 22
20396: PUSH
20397: LD_EXP 47
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: PUSH
20406: LD_INT 2
20408: PUSH
20409: LD_INT 30
20411: PUSH
20412: LD_INT 28
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 30
20421: PUSH
20422: LD_INT 26
20424: PUSH
20425: EMPTY
20426: LIST
20427: LIST
20428: PUSH
20429: LD_INT 30
20431: PUSH
20432: LD_INT 27
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: PUSH
20439: LD_INT 30
20441: PUSH
20442: LD_INT 5
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: PUSH
20449: LD_INT 30
20451: PUSH
20452: LD_INT 4
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PUSH
20459: LD_INT 30
20461: PUSH
20462: LD_INT 32
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: PUSH
20469: LD_INT 30
20471: PUSH
20472: LD_INT 31
20474: PUSH
20475: EMPTY
20476: LIST
20477: LIST
20478: PUSH
20479: LD_INT 30
20481: PUSH
20482: LD_INT 33
20484: PUSH
20485: EMPTY
20486: LIST
20487: LIST
20488: PUSH
20489: EMPTY
20490: LIST
20491: LIST
20492: LIST
20493: LIST
20494: LIST
20495: LIST
20496: LIST
20497: LIST
20498: LIST
20499: PUSH
20500: EMPTY
20501: LIST
20502: LIST
20503: PPUSH
20504: CALL_OW 69
20508: PUSH
20509: FOR_IN
20510: IFFALSE 20528
// begin PriorityAttack ( russians , i ) ;
20512: LD_EXP 49
20516: PPUSH
20517: LD_VAR 0 3
20521: PPUSH
20522: CALL_OW 470
// end ;
20526: GO 20509
20528: POP
20529: POP
// wait ( 0 0$20 ) ;
20530: LD_INT 700
20532: PPUSH
20533: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_not , [ f_btype , b_warehouse ] ] , [ f_not , [ f_btype , b_depot ] ] ] ) do
20537: LD_ADDR_VAR 0 3
20541: PUSH
20542: LD_INT 22
20544: PUSH
20545: LD_EXP 47
20549: PUSH
20550: EMPTY
20551: LIST
20552: LIST
20553: PUSH
20554: LD_INT 3
20556: PUSH
20557: LD_INT 30
20559: PUSH
20560: LD_INT 1
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 3
20573: PUSH
20574: LD_INT 30
20576: PUSH
20577: LD_INT 0
20579: PUSH
20580: EMPTY
20581: LIST
20582: LIST
20583: PUSH
20584: EMPTY
20585: LIST
20586: LIST
20587: PUSH
20588: EMPTY
20589: LIST
20590: LIST
20591: LIST
20592: PPUSH
20593: CALL_OW 69
20597: PUSH
20598: FOR_IN
20599: IFFALSE 20617
// begin PriorityAttack ( russians , i ) ;
20601: LD_EXP 49
20605: PPUSH
20606: LD_VAR 0 3
20610: PPUSH
20611: CALL_OW 470
// end ;
20615: GO 20598
20617: POP
20618: POP
// wait ( 0 0$30 ) ;
20619: LD_INT 1050
20621: PPUSH
20622: CALL_OW 67
// if Getside ( rudepot1 ) = you and xxx < 2 then
20626: LD_EXP 67
20630: PPUSH
20631: CALL_OW 255
20635: PUSH
20636: LD_EXP 47
20640: EQUAL
20641: PUSH
20642: LD_EXP 107
20646: PUSH
20647: LD_INT 2
20649: LESS
20650: AND
20651: IFFALSE 20668
// begin xxx := xxx + 1 ;
20653: LD_ADDR_EXP 107
20657: PUSH
20658: LD_EXP 107
20662: PUSH
20663: LD_INT 1
20665: PLUS
20666: ST_TO_ADDR
// enable ;
20667: ENABLE
// end ; end ;
20668: PPOPN 9
20670: END
// export xxx ; every 0 0$15 trigger GetSide ( RuDepot1 ) = you and not FilterHumansInArea ( base , [ f_side , you ] ) do var ing , i , a ;
20671: LD_EXP 67
20675: PPUSH
20676: CALL_OW 255
20680: PUSH
20681: LD_EXP 47
20685: EQUAL
20686: PUSH
20687: LD_INT 1
20689: PPUSH
20690: LD_INT 22
20692: PUSH
20693: LD_EXP 47
20697: PUSH
20698: EMPTY
20699: LIST
20700: LIST
20701: PPUSH
20702: CALL 13198 0 2
20706: NOT
20707: AND
20708: IFFALSE 20974
20710: GO 20712
20712: DISABLE
20713: LD_INT 0
20715: PPUSH
20716: PPUSH
20717: PPUSH
// begin InitUc ;
20718: CALL_OW 18
// InitHc ;
20722: CALL_OW 19
// uc_side := russians ;
20726: LD_ADDR_OWVAR 20
20730: PUSH
20731: LD_EXP 49
20735: ST_TO_ADDR
// uc_nation := nation_russian ;
20736: LD_ADDR_OWVAR 21
20740: PUSH
20741: LD_INT 3
20743: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
20744: LD_INT 0
20746: PPUSH
20747: LD_INT 6
20749: PPUSH
20750: CALL_OW 382
// ing := CreateHuman ;
20754: LD_ADDR_VAR 0 1
20758: PUSH
20759: CALL_OW 44
20763: ST_TO_ADDR
// PlaceUnitXYR ( ing , 137 , 147 , 4 , false ) ;
20764: LD_VAR 0 1
20768: PPUSH
20769: LD_INT 137
20771: PPUSH
20772: LD_INT 147
20774: PPUSH
20775: LD_INT 4
20777: PPUSH
20778: LD_INT 0
20780: PPUSH
20781: CALL_OW 50
// wait ( 0 0$5 ) ;
20785: LD_INT 175
20787: PPUSH
20788: CALL_OW 67
// a := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) ;
20792: LD_ADDR_VAR 0 3
20796: PUSH
20797: LD_INT 22
20799: PUSH
20800: LD_EXP 49
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: PUSH
20809: LD_INT 25
20811: PUSH
20812: LD_INT 2
20814: PUSH
20815: EMPTY
20816: LIST
20817: LIST
20818: PUSH
20819: EMPTY
20820: LIST
20821: LIST
20822: PPUSH
20823: CALL_OW 69
20827: ST_TO_ADDR
// ComMoveUnit ( a , rudepot1 ) ;
20828: LD_VAR 0 3
20832: PPUSH
20833: LD_EXP 67
20837: PPUSH
20838: CALL_OW 112
// wait ( 0 0$20 ) ;
20842: LD_INT 700
20844: PPUSH
20845: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) > 3 then
20849: LD_INT 22
20851: PUSH
20852: LD_EXP 49
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: PUSH
20861: LD_INT 25
20863: PUSH
20864: LD_INT 2
20866: PUSH
20867: EMPTY
20868: LIST
20869: LIST
20870: PUSH
20871: EMPTY
20872: LIST
20873: LIST
20874: PPUSH
20875: CALL_OW 69
20879: PUSH
20880: LD_INT 3
20882: GREATER
20883: IFFALSE 20973
// begin TimerEnable := true ;
20885: LD_ADDR_EXP 63
20889: PUSH
20890: LD_INT 1
20892: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
20893: LD_ADDR_EXP 81
20897: PUSH
20898: LD_EXP 49
20902: PPUSH
20903: CALL_OW 462
20907: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
20908: LD_EXP 67
20912: PPUSH
20913: CALL_OW 274
20917: PPUSH
20918: LD_EXP 49
20922: PPUSH
20923: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you ] ] ) do
20927: LD_ADDR_VAR 0 2
20931: PUSH
20932: LD_INT 22
20934: PUSH
20935: LD_EXP 47
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PUSH
20944: EMPTY
20945: LIST
20946: PPUSH
20947: CALL_OW 69
20951: PUSH
20952: FOR_IN
20953: IFFALSE 20971
// NormalAttack ( russians , i ) ;
20955: LD_EXP 49
20959: PPUSH
20960: LD_VAR 0 2
20964: PPUSH
20965: CALL_OW 472
20969: GO 20952
20971: POP
20972: POP
// end ; enable ;
20973: ENABLE
// end ;
20974: PPOPN 3
20976: END
// every 0 0$5 do var a ;
20977: GO 20979
20979: DISABLE
20980: LD_INT 0
20982: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , russians ] , [ f_not , [ f_hastask ] ] ] ) ;
20983: LD_ADDR_VAR 0 1
20987: PUSH
20988: LD_INT 22
20990: PUSH
20991: LD_EXP 49
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PUSH
21000: LD_INT 3
21002: PUSH
21003: LD_INT 60
21005: PUSH
21006: EMPTY
21007: LIST
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: PUSH
21013: EMPTY
21014: LIST
21015: LIST
21016: PPUSH
21017: CALL_OW 69
21021: ST_TO_ADDR
// wait ( 0 0$5 ) ;
21022: LD_INT 175
21024: PPUSH
21025: CALL_OW 67
// a := UnitFilter ( a , [ f_not , [ f_hastask ] ] ) ;
21029: LD_ADDR_VAR 0 1
21033: PUSH
21034: LD_VAR 0 1
21038: PPUSH
21039: LD_INT 3
21041: PUSH
21042: LD_INT 60
21044: PUSH
21045: EMPTY
21046: LIST
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: PPUSH
21052: CALL_OW 72
21056: ST_TO_ADDR
// if a then
21057: LD_VAR 0 1
21061: IFFALSE 21129
// begin ComAgressiveMove ( UnitFilter ( a , [ [ f_inarea , top_half ] ] ) , 42 , 10 ) ;
21063: LD_VAR 0 1
21067: PPUSH
21068: LD_INT 95
21070: PUSH
21071: LD_INT 6
21073: PUSH
21074: EMPTY
21075: LIST
21076: LIST
21077: PUSH
21078: EMPTY
21079: LIST
21080: PPUSH
21081: CALL_OW 72
21085: PPUSH
21086: LD_INT 42
21088: PPUSH
21089: LD_INT 10
21091: PPUSH
21092: CALL_OW 114
// ComAgressiveMove ( UnitFilter ( a , [ [ f_exceptarea , top_half ] ] ) , 93 , 94 ) ;
21096: LD_VAR 0 1
21100: PPUSH
21101: LD_INT 96
21103: PUSH
21104: LD_INT 6
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: PUSH
21111: EMPTY
21112: LIST
21113: PPUSH
21114: CALL_OW 72
21118: PPUSH
21119: LD_INT 93
21121: PPUSH
21122: LD_INT 94
21124: PPUSH
21125: CALL_OW 114
// end ; enable ;
21129: ENABLE
// end ;
21130: PPOPN 1
21132: END
// export pathBL , pathBM , pathBR , pathUL , pathUR , pathUT , pathML , pathMM , pathMR , pathT ; export pathB1 , pathB2 , pathB3 , pathB4 ; var d ; every 0 0$0.1 do
21133: GO 21135
21135: DISABLE
// begin pathBL := [ [ 62 , 119 ] , [ 73 , 120 ] , [ 78 , 121 ] , [ 80 , 118 ] , [ 80 , 113 ] , [ 80 , 109 ] ] ;
21136: LD_ADDR_EXP 108
21140: PUSH
21141: LD_INT 62
21143: PUSH
21144: LD_INT 119
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: PUSH
21151: LD_INT 73
21153: PUSH
21154: LD_INT 120
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PUSH
21161: LD_INT 78
21163: PUSH
21164: LD_INT 121
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: PUSH
21171: LD_INT 80
21173: PUSH
21174: LD_INT 118
21176: PUSH
21177: EMPTY
21178: LIST
21179: LIST
21180: PUSH
21181: LD_INT 80
21183: PUSH
21184: LD_INT 113
21186: PUSH
21187: EMPTY
21188: LIST
21189: LIST
21190: PUSH
21191: LD_INT 80
21193: PUSH
21194: LD_INT 109
21196: PUSH
21197: EMPTY
21198: LIST
21199: LIST
21200: PUSH
21201: EMPTY
21202: LIST
21203: LIST
21204: LIST
21205: LIST
21206: LIST
21207: LIST
21208: ST_TO_ADDR
// pathBM := [ [ 98 , 144 ] , [ 96 , 139 ] , [ 96 , 135 ] , [ 96 , 131 ] , [ 97 , 128 ] , [ 99 , 126 ] , [ 101 , 124 ] ] ;
21209: LD_ADDR_EXP 109
21213: PUSH
21214: LD_INT 98
21216: PUSH
21217: LD_INT 144
21219: PUSH
21220: EMPTY
21221: LIST
21222: LIST
21223: PUSH
21224: LD_INT 96
21226: PUSH
21227: LD_INT 139
21229: PUSH
21230: EMPTY
21231: LIST
21232: LIST
21233: PUSH
21234: LD_INT 96
21236: PUSH
21237: LD_INT 135
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: LD_INT 96
21246: PUSH
21247: LD_INT 131
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PUSH
21254: LD_INT 97
21256: PUSH
21257: LD_INT 128
21259: PUSH
21260: EMPTY
21261: LIST
21262: LIST
21263: PUSH
21264: LD_INT 99
21266: PUSH
21267: LD_INT 126
21269: PUSH
21270: EMPTY
21271: LIST
21272: LIST
21273: PUSH
21274: LD_INT 101
21276: PUSH
21277: LD_INT 124
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: LIST
21289: LIST
21290: LIST
21291: LIST
21292: ST_TO_ADDR
// pathBR := [ [ 130 , 137 ] , [ 120 , 128 ] ] ;
21293: LD_ADDR_EXP 110
21297: PUSH
21298: LD_INT 130
21300: PUSH
21301: LD_INT 137
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 120
21310: PUSH
21311: LD_INT 128
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: ST_TO_ADDR
// pathUL := [ [ 80 , 109 ] , [ 77 , 103 ] , [ 72 , 97 ] , [ 71 , 93 ] , [ 76 , 93 ] , [ 81 , 93 ] , [ 86 , 94 ] , [ 92 , 95 ] ] ;
21322: LD_ADDR_EXP 111
21326: PUSH
21327: LD_INT 80
21329: PUSH
21330: LD_INT 109
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: PUSH
21337: LD_INT 77
21339: PUSH
21340: LD_INT 103
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: PUSH
21347: LD_INT 72
21349: PUSH
21350: LD_INT 97
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: LD_INT 71
21359: PUSH
21360: LD_INT 93
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: PUSH
21367: LD_INT 76
21369: PUSH
21370: LD_INT 93
21372: PUSH
21373: EMPTY
21374: LIST
21375: LIST
21376: PUSH
21377: LD_INT 81
21379: PUSH
21380: LD_INT 93
21382: PUSH
21383: EMPTY
21384: LIST
21385: LIST
21386: PUSH
21387: LD_INT 86
21389: PUSH
21390: LD_INT 94
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: PUSH
21397: LD_INT 92
21399: PUSH
21400: LD_INT 95
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: PUSH
21407: EMPTY
21408: LIST
21409: LIST
21410: LIST
21411: LIST
21412: LIST
21413: LIST
21414: LIST
21415: LIST
21416: ST_TO_ADDR
// pathUR := [ [ 120 , 128 ] , [ 115 , 123 ] , [ 110 , 118 ] , [ 106 , 114 ] , [ 99 , 107 ] , [ 96 , 100 ] , [ 92 , 95 ] ] ;
21417: LD_ADDR_EXP 112
21421: PUSH
21422: LD_INT 120
21424: PUSH
21425: LD_INT 128
21427: PUSH
21428: EMPTY
21429: LIST
21430: LIST
21431: PUSH
21432: LD_INT 115
21434: PUSH
21435: LD_INT 123
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: PUSH
21442: LD_INT 110
21444: PUSH
21445: LD_INT 118
21447: PUSH
21448: EMPTY
21449: LIST
21450: LIST
21451: PUSH
21452: LD_INT 106
21454: PUSH
21455: LD_INT 114
21457: PUSH
21458: EMPTY
21459: LIST
21460: LIST
21461: PUSH
21462: LD_INT 99
21464: PUSH
21465: LD_INT 107
21467: PUSH
21468: EMPTY
21469: LIST
21470: LIST
21471: PUSH
21472: LD_INT 96
21474: PUSH
21475: LD_INT 100
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: PUSH
21482: LD_INT 92
21484: PUSH
21485: LD_INT 95
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: PUSH
21492: EMPTY
21493: LIST
21494: LIST
21495: LIST
21496: LIST
21497: LIST
21498: LIST
21499: LIST
21500: ST_TO_ADDR
// pathUT := [ [ 111 , 87 ] , [ 107 , 88 ] , [ 103 , 88 ] , [ 100 , 85 ] , [ 95 , 85 ] , [ 91 , 85 ] ] ;
21501: LD_ADDR_EXP 113
21505: PUSH
21506: LD_INT 111
21508: PUSH
21509: LD_INT 87
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: PUSH
21516: LD_INT 107
21518: PUSH
21519: LD_INT 88
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PUSH
21526: LD_INT 103
21528: PUSH
21529: LD_INT 88
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: LD_INT 100
21538: PUSH
21539: LD_INT 85
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: LD_INT 95
21548: PUSH
21549: LD_INT 85
21551: PUSH
21552: EMPTY
21553: LIST
21554: LIST
21555: PUSH
21556: LD_INT 91
21558: PUSH
21559: LD_INT 85
21561: PUSH
21562: EMPTY
21563: LIST
21564: LIST
21565: PUSH
21566: EMPTY
21567: LIST
21568: LIST
21569: LIST
21570: LIST
21571: LIST
21572: LIST
21573: ST_TO_ADDR
// pathML := [ [ 80 , 109 ] , [ 85 , 111 ] , [ 89 , 112 ] , [ 94 , 117 ] , [ 98 , 121 ] , [ 101 , 124 ] ] ;
21574: LD_ADDR_EXP 114
21578: PUSH
21579: LD_INT 80
21581: PUSH
21582: LD_INT 109
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 85
21591: PUSH
21592: LD_INT 111
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 89
21601: PUSH
21602: LD_INT 112
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: PUSH
21609: LD_INT 94
21611: PUSH
21612: LD_INT 117
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PUSH
21619: LD_INT 98
21621: PUSH
21622: LD_INT 121
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: LD_INT 101
21631: PUSH
21632: LD_INT 124
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: LIST
21643: LIST
21644: LIST
21645: LIST
21646: ST_TO_ADDR
// pathMM := [ [ 101 , 124 ] , [ 105 , 125 ] , [ 112 , 128 ] , [ 117 , 129 ] , [ 120 , 128 ] ] ;
21647: LD_ADDR_EXP 115
21651: PUSH
21652: LD_INT 101
21654: PUSH
21655: LD_INT 124
21657: PUSH
21658: EMPTY
21659: LIST
21660: LIST
21661: PUSH
21662: LD_INT 105
21664: PUSH
21665: LD_INT 125
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: PUSH
21672: LD_INT 112
21674: PUSH
21675: LD_INT 128
21677: PUSH
21678: EMPTY
21679: LIST
21680: LIST
21681: PUSH
21682: LD_INT 117
21684: PUSH
21685: LD_INT 129
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 120
21694: PUSH
21695: LD_INT 128
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: PUSH
21702: EMPTY
21703: LIST
21704: LIST
21705: LIST
21706: LIST
21707: LIST
21708: ST_TO_ADDR
// pathMR := [ [ 120 , 128 ] , [ 121 , 124 ] , [ 119 , 118 ] , [ 116 , 112 ] , [ 115 , 105 ] , [ 116 , 100 ] , [ 114 , 92 ] , [ 111 , 87 ] ] ;
21709: LD_ADDR_EXP 116
21713: PUSH
21714: LD_INT 120
21716: PUSH
21717: LD_INT 128
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: LD_INT 121
21726: PUSH
21727: LD_INT 124
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PUSH
21734: LD_INT 119
21736: PUSH
21737: LD_INT 118
21739: PUSH
21740: EMPTY
21741: LIST
21742: LIST
21743: PUSH
21744: LD_INT 116
21746: PUSH
21747: LD_INT 112
21749: PUSH
21750: EMPTY
21751: LIST
21752: LIST
21753: PUSH
21754: LD_INT 115
21756: PUSH
21757: LD_INT 105
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PUSH
21764: LD_INT 116
21766: PUSH
21767: LD_INT 100
21769: PUSH
21770: EMPTY
21771: LIST
21772: LIST
21773: PUSH
21774: LD_INT 114
21776: PUSH
21777: LD_INT 92
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: PUSH
21784: LD_INT 111
21786: PUSH
21787: LD_INT 87
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: LIST
21802: LIST
21803: ST_TO_ADDR
// pathT := [ [ 111 , 87 ] , [ 109 , 82 ] , [ 105 , 77 ] , [ 103 , 71 ] , [ 100 , 65 ] , [ 97 , 62 ] , [ 93 , 61 ] , [ 92 , 56 ] , [ 90 , 52 ] , [ 87 , 48 ] , [ 82 , 46 ] , [ 78 , 44 ] , [ 76 , 37 ] , [ 75 , 33 ] , [ 75 , 29 ] , [ 71 , 25 ] , [ 67 , 23 ] , [ 62 , 22 ] , [ 59 , 23 ] , [ 57 , 26 ] , [ 54 , 37 ] , [ 51 , 29 ] , [ 47 , 26 ] , [ 45 , 23 ] , [ 42 , 18 ] ] ;
21804: LD_ADDR_EXP 117
21808: PUSH
21809: LD_INT 111
21811: PUSH
21812: LD_INT 87
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PUSH
21819: LD_INT 109
21821: PUSH
21822: LD_INT 82
21824: PUSH
21825: EMPTY
21826: LIST
21827: LIST
21828: PUSH
21829: LD_INT 105
21831: PUSH
21832: LD_INT 77
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: PUSH
21839: LD_INT 103
21841: PUSH
21842: LD_INT 71
21844: PUSH
21845: EMPTY
21846: LIST
21847: LIST
21848: PUSH
21849: LD_INT 100
21851: PUSH
21852: LD_INT 65
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: PUSH
21859: LD_INT 97
21861: PUSH
21862: LD_INT 62
21864: PUSH
21865: EMPTY
21866: LIST
21867: LIST
21868: PUSH
21869: LD_INT 93
21871: PUSH
21872: LD_INT 61
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: PUSH
21879: LD_INT 92
21881: PUSH
21882: LD_INT 56
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: PUSH
21889: LD_INT 90
21891: PUSH
21892: LD_INT 52
21894: PUSH
21895: EMPTY
21896: LIST
21897: LIST
21898: PUSH
21899: LD_INT 87
21901: PUSH
21902: LD_INT 48
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: PUSH
21909: LD_INT 82
21911: PUSH
21912: LD_INT 46
21914: PUSH
21915: EMPTY
21916: LIST
21917: LIST
21918: PUSH
21919: LD_INT 78
21921: PUSH
21922: LD_INT 44
21924: PUSH
21925: EMPTY
21926: LIST
21927: LIST
21928: PUSH
21929: LD_INT 76
21931: PUSH
21932: LD_INT 37
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: PUSH
21939: LD_INT 75
21941: PUSH
21942: LD_INT 33
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PUSH
21949: LD_INT 75
21951: PUSH
21952: LD_INT 29
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: PUSH
21959: LD_INT 71
21961: PUSH
21962: LD_INT 25
21964: PUSH
21965: EMPTY
21966: LIST
21967: LIST
21968: PUSH
21969: LD_INT 67
21971: PUSH
21972: LD_INT 23
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: PUSH
21979: LD_INT 62
21981: PUSH
21982: LD_INT 22
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: PUSH
21989: LD_INT 59
21991: PUSH
21992: LD_INT 23
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: PUSH
21999: LD_INT 57
22001: PUSH
22002: LD_INT 26
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PUSH
22009: LD_INT 54
22011: PUSH
22012: LD_INT 37
22014: PUSH
22015: EMPTY
22016: LIST
22017: LIST
22018: PUSH
22019: LD_INT 51
22021: PUSH
22022: LD_INT 29
22024: PUSH
22025: EMPTY
22026: LIST
22027: LIST
22028: PUSH
22029: LD_INT 47
22031: PUSH
22032: LD_INT 26
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PUSH
22039: LD_INT 45
22041: PUSH
22042: LD_INT 23
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PUSH
22049: LD_INT 42
22051: PUSH
22052: LD_INT 18
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: PUSH
22059: EMPTY
22060: LIST
22061: LIST
22062: LIST
22063: LIST
22064: LIST
22065: LIST
22066: LIST
22067: LIST
22068: LIST
22069: LIST
22070: LIST
22071: LIST
22072: LIST
22073: LIST
22074: LIST
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: LIST
22080: LIST
22081: LIST
22082: LIST
22083: LIST
22084: LIST
22085: ST_TO_ADDR
// pathB1 := [ [ 97 , 72 ] , [ 84 , 67 ] , [ 84 , 77 ] ] ;
22086: LD_ADDR_EXP 118
22090: PUSH
22091: LD_INT 97
22093: PUSH
22094: LD_INT 72
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: LD_INT 84
22103: PUSH
22104: LD_INT 67
22106: PUSH
22107: EMPTY
22108: LIST
22109: LIST
22110: PUSH
22111: LD_INT 84
22113: PUSH
22114: LD_INT 77
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: PUSH
22121: EMPTY
22122: LIST
22123: LIST
22124: LIST
22125: ST_TO_ADDR
// pathB2 := [ [ 44 , 71 ] , [ 64 , 68 ] , [ 64 , 79 ] ] ;
22126: LD_ADDR_EXP 119
22130: PUSH
22131: LD_INT 44
22133: PUSH
22134: LD_INT 71
22136: PUSH
22137: EMPTY
22138: LIST
22139: LIST
22140: PUSH
22141: LD_INT 64
22143: PUSH
22144: LD_INT 68
22146: PUSH
22147: EMPTY
22148: LIST
22149: LIST
22150: PUSH
22151: LD_INT 64
22153: PUSH
22154: LD_INT 79
22156: PUSH
22157: EMPTY
22158: LIST
22159: LIST
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: LIST
22165: ST_TO_ADDR
// pathB3 := [ [ 91 , 131 ] , [ 93 , 121 ] , [ 94 , 115 ] , [ 107 , 115 ] ] ;
22166: LD_ADDR_EXP 120
22170: PUSH
22171: LD_INT 91
22173: PUSH
22174: LD_INT 131
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: PUSH
22181: LD_INT 93
22183: PUSH
22184: LD_INT 121
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PUSH
22191: LD_INT 94
22193: PUSH
22194: LD_INT 115
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: PUSH
22201: LD_INT 107
22203: PUSH
22204: LD_INT 115
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: ST_TO_ADDR
// pathB4 := [ [ 126 , 128 ] , [ 116 , 107 ] , [ 107 , 87 ] ] ;
22217: LD_ADDR_EXP 121
22221: PUSH
22222: LD_INT 126
22224: PUSH
22225: LD_INT 128
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PUSH
22232: LD_INT 116
22234: PUSH
22235: LD_INT 107
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 107
22244: PUSH
22245: LD_INT 87
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: LIST
22256: ST_TO_ADDR
// lev := [ 2 , 4 , 7 ] ;
22257: LD_ADDR_EXP 5
22261: PUSH
22262: LD_INT 2
22264: PUSH
22265: LD_INT 4
22267: PUSH
22268: LD_INT 7
22270: PUSH
22271: EMPTY
22272: LIST
22273: LIST
22274: LIST
22275: ST_TO_ADDR
// d := difficulty ;
22276: LD_ADDR_LOC 2
22280: PUSH
22281: LD_OWVAR 67
22285: ST_TO_ADDR
// case true of d <= 1 :
22286: LD_INT 1
22288: PUSH
22289: LD_LOC 2
22293: PUSH
22294: LD_INT 1
22296: LESSEQUAL
22297: DOUBLE
22298: EQUAL
22299: IFTRUE 22303
22301: GO 22306
22303: POP
// ; d <= 2 :
22304: GO 22401
22306: LD_LOC 2
22310: PUSH
22311: LD_INT 2
22313: LESSEQUAL
22314: DOUBLE
22315: EQUAL
22316: IFTRUE 22320
22318: GO 22353
22320: POP
// begin SetTech ( tech_Comp1 , russians , state_researched ) ;
22321: LD_INT 57
22323: PPUSH
22324: LD_EXP 49
22328: PPUSH
22329: LD_INT 2
22331: PPUSH
22332: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
22336: LD_INT 51
22338: PPUSH
22339: LD_EXP 49
22343: PPUSH
22344: LD_INT 2
22346: PPUSH
22347: CALL_OW 322
// end ; d <= 3 :
22351: GO 22401
22353: LD_LOC 2
22357: PUSH
22358: LD_INT 3
22360: LESSEQUAL
22361: DOUBLE
22362: EQUAL
22363: IFTRUE 22367
22365: GO 22400
22367: POP
// begin SetTech ( tech_Comp2 , russians , state_researched ) ;
22368: LD_INT 58
22370: PPUSH
22371: LD_EXP 49
22375: PPUSH
22376: LD_INT 2
22378: PPUSH
22379: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
22383: LD_INT 52
22385: PPUSH
22386: LD_EXP 49
22390: PPUSH
22391: LD_INT 2
22393: PPUSH
22394: CALL_OW 322
// end ; end ;
22398: GO 22401
22400: POP
// end ;
22401: END
// every 31 31$0 do
22402: GO 22404
22404: DISABLE
// begin case difficulty of 1 :
22405: LD_OWVAR 67
22409: PUSH
22410: LD_INT 1
22412: DOUBLE
22413: EQUAL
22414: IFTRUE 22418
22416: GO 22436
22418: POP
// SetTech ( tech_Comp1 , russians , state_researched ) ; 2 :
22419: LD_INT 57
22421: PPUSH
22422: LD_EXP 49
22426: PPUSH
22427: LD_INT 2
22429: PPUSH
22430: CALL_OW 322
22434: GO 22489
22436: LD_INT 2
22438: DOUBLE
22439: EQUAL
22440: IFTRUE 22444
22442: GO 22462
22444: POP
// SetTech ( tech_Comp2 , russians , state_researched ) ; 3 :
22445: LD_INT 58
22447: PPUSH
22448: LD_EXP 49
22452: PPUSH
22453: LD_INT 2
22455: PPUSH
22456: CALL_OW 322
22460: GO 22489
22462: LD_INT 3
22464: DOUBLE
22465: EQUAL
22466: IFTRUE 22470
22468: GO 22488
22470: POP
// SetTech ( tech_Comp3 , russians , state_researched ) ; end ;
22471: LD_INT 59
22473: PPUSH
22474: LD_EXP 49
22478: PPUSH
22479: LD_INT 2
22481: PPUSH
22482: CALL_OW 322
22486: GO 22489
22488: POP
// end ;
22489: END
// every 47 47$0 do
22490: GO 22492
22492: DISABLE
// begin case difficulty of 1 :
22493: LD_OWVAR 67
22497: PUSH
22498: LD_INT 1
22500: DOUBLE
22501: EQUAL
22502: IFTRUE 22506
22504: GO 22524
22506: POP
// SetTech ( tech_Weap1 , russians , state_researched ) ; 2 :
22507: LD_INT 51
22509: PPUSH
22510: LD_EXP 49
22514: PPUSH
22515: LD_INT 2
22517: PPUSH
22518: CALL_OW 322
22522: GO 22577
22524: LD_INT 2
22526: DOUBLE
22527: EQUAL
22528: IFTRUE 22532
22530: GO 22550
22532: POP
// SetTech ( tech_Weap2 , russians , state_researched ) ; 3 :
22533: LD_INT 52
22535: PPUSH
22536: LD_EXP 49
22540: PPUSH
22541: LD_INT 2
22543: PPUSH
22544: CALL_OW 322
22548: GO 22577
22550: LD_INT 3
22552: DOUBLE
22553: EQUAL
22554: IFTRUE 22558
22556: GO 22576
22558: POP
// SetTech ( tech_Weap3 , russians , state_researched ) ; end ;
22559: LD_INT 53
22561: PPUSH
22562: LD_EXP 49
22566: PPUSH
22567: LD_INT 2
22569: PPUSH
22570: CALL_OW 322
22574: GO 22577
22576: POP
// end ;
22577: END
// function CreateH ( sol , mec ) ; var units , i ; begin
22578: LD_INT 0
22580: PPUSH
22581: PPUSH
22582: PPUSH
// units := [ ] ;
22583: LD_ADDR_VAR 0 4
22587: PUSH
22588: EMPTY
22589: ST_TO_ADDR
// for i := 1 to sol do
22590: LD_ADDR_VAR 0 5
22594: PUSH
22595: DOUBLE
22596: LD_INT 1
22598: DEC
22599: ST_TO_ADDR
22600: LD_VAR 0 1
22604: PUSH
22605: FOR_TO
22606: IFFALSE 22677
// begin InitUc ;
22608: CALL_OW 18
// InitHc ;
22612: CALL_OW 19
// uc_nation := nation_russian ;
22616: LD_ADDR_OWVAR 21
22620: PUSH
22621: LD_INT 3
22623: ST_TO_ADDR
// uc_side := russians ;
22624: LD_ADDR_OWVAR 20
22628: PUSH
22629: LD_EXP 49
22633: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22634: LD_INT 0
22636: PPUSH
22637: LD_EXP 5
22641: PUSH
22642: LD_LOC 2
22646: ARRAY
22647: PPUSH
22648: CALL_OW 381
// units := units ^ CreateHuman ;
22652: LD_ADDR_VAR 0 4
22656: PUSH
22657: LD_VAR 0 4
22661: PUSH
22662: CALL_OW 44
22666: ADD
22667: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22668: LD_INT 7
22670: PPUSH
22671: CALL_OW 67
// end ;
22675: GO 22605
22677: POP
22678: POP
// for i := 1 to mec do
22679: LD_ADDR_VAR 0 5
22683: PUSH
22684: DOUBLE
22685: LD_INT 1
22687: DEC
22688: ST_TO_ADDR
22689: LD_VAR 0 2
22693: PUSH
22694: FOR_TO
22695: IFFALSE 22766
// begin InitUc ;
22697: CALL_OW 18
// InitHc ;
22701: CALL_OW 19
// uc_nation := nation_russian ;
22705: LD_ADDR_OWVAR 21
22709: PUSH
22710: LD_INT 3
22712: ST_TO_ADDR
// uc_side := russians ;
22713: LD_ADDR_OWVAR 20
22717: PUSH
22718: LD_EXP 49
22722: ST_TO_ADDR
// PrepareMechanic ( 0 , lev [ d ] ) ;
22723: LD_INT 0
22725: PPUSH
22726: LD_EXP 5
22730: PUSH
22731: LD_LOC 2
22735: ARRAY
22736: PPUSH
22737: CALL_OW 383
// units := units ^ CreateHuman ;
22741: LD_ADDR_VAR 0 4
22745: PUSH
22746: LD_VAR 0 4
22750: PUSH
22751: CALL_OW 44
22755: ADD
22756: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22757: LD_INT 7
22759: PPUSH
22760: CALL_OW 67
// end ;
22764: GO 22694
22766: POP
22767: POP
// result := units ;
22768: LD_ADDR_VAR 0 3
22772: PUSH
22773: LD_VAR 0 4
22777: ST_TO_ADDR
// end ;
22778: LD_VAR 0 3
22782: RET
// function CreateB ( num ) ; var units , i ; begin
22783: LD_INT 0
22785: PPUSH
22786: PPUSH
22787: PPUSH
// units := [ ] ;
22788: LD_ADDR_VAR 0 3
22792: PUSH
22793: EMPTY
22794: ST_TO_ADDR
// for i := 1 to num do
22795: LD_ADDR_VAR 0 4
22799: PUSH
22800: DOUBLE
22801: LD_INT 1
22803: DEC
22804: ST_TO_ADDR
22805: LD_VAR 0 1
22809: PUSH
22810: FOR_TO
22811: IFFALSE 22890
// begin InitUc ;
22813: CALL_OW 18
// InitHc ;
22817: CALL_OW 19
// uc_nation := nation_russian ;
22821: LD_ADDR_OWVAR 21
22825: PUSH
22826: LD_INT 3
22828: ST_TO_ADDR
// uc_side := russians ;
22829: LD_ADDR_OWVAR 20
22833: PUSH
22834: LD_EXP 49
22838: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22839: LD_INT 0
22841: PPUSH
22842: LD_EXP 5
22846: PUSH
22847: LD_LOC 2
22851: ARRAY
22852: PPUSH
22853: CALL_OW 381
// hc_class := class_bazooker ;
22857: LD_ADDR_OWVAR 28
22861: PUSH
22862: LD_INT 9
22864: ST_TO_ADDR
// units := units ^ CreateHuman ;
22865: LD_ADDR_VAR 0 3
22869: PUSH
22870: LD_VAR 0 3
22874: PUSH
22875: CALL_OW 44
22879: ADD
22880: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22881: LD_INT 7
22883: PPUSH
22884: CALL_OW 67
// end ;
22888: GO 22810
22890: POP
22891: POP
// result := units ;
22892: LD_ADDR_VAR 0 2
22896: PUSH
22897: LD_VAR 0 3
22901: ST_TO_ADDR
// end ;
22902: LD_VAR 0 2
22906: RET
// function CreateS ( num ) ; var units , i ; begin
22907: LD_INT 0
22909: PPUSH
22910: PPUSH
22911: PPUSH
// units := [ ] ;
22912: LD_ADDR_VAR 0 3
22916: PUSH
22917: EMPTY
22918: ST_TO_ADDR
// for i := 1 to num do
22919: LD_ADDR_VAR 0 4
22923: PUSH
22924: DOUBLE
22925: LD_INT 1
22927: DEC
22928: ST_TO_ADDR
22929: LD_VAR 0 1
22933: PUSH
22934: FOR_TO
22935: IFFALSE 23014
// begin InitUc ;
22937: CALL_OW 18
// InitHc ;
22941: CALL_OW 19
// uc_nation := nation_russian ;
22945: LD_ADDR_OWVAR 21
22949: PUSH
22950: LD_INT 3
22952: ST_TO_ADDR
// uc_side := russians ;
22953: LD_ADDR_OWVAR 20
22957: PUSH
22958: LD_EXP 49
22962: ST_TO_ADDR
// hc_class := class_soldier ;
22963: LD_ADDR_OWVAR 28
22967: PUSH
22968: LD_INT 1
22970: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22971: LD_INT 0
22973: PPUSH
22974: LD_EXP 5
22978: PUSH
22979: LD_LOC 2
22983: ARRAY
22984: PPUSH
22985: CALL_OW 381
// units := units ^ CreateHuman ;
22989: LD_ADDR_VAR 0 3
22993: PUSH
22994: LD_VAR 0 3
22998: PUSH
22999: CALL_OW 44
23003: ADD
23004: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23005: LD_INT 7
23007: PPUSH
23008: CALL_OW 67
// end ;
23012: GO 22934
23014: POP
23015: POP
// result := units ;
23016: LD_ADDR_VAR 0 2
23020: PUSH
23021: LD_VAR 0 3
23025: ST_TO_ADDR
// end ;
23026: LD_VAR 0 2
23030: RET
// function CreateVH ( list ) ; var units , i ; begin
23031: LD_INT 0
23033: PPUSH
23034: PPUSH
23035: PPUSH
// for i in list do
23036: LD_ADDR_VAR 0 4
23040: PUSH
23041: LD_VAR 0 1
23045: PUSH
23046: FOR_IN
23047: IFFALSE 23340
// begin InitUc ;
23049: CALL_OW 18
// InitVc ;
23053: CALL_OW 20
// uc_nation := nation_russian ;
23057: LD_ADDR_OWVAR 21
23061: PUSH
23062: LD_INT 3
23064: ST_TO_ADDR
// uc_side := russians ;
23065: LD_ADDR_OWVAR 20
23069: PUSH
23070: LD_EXP 49
23074: ST_TO_ADDR
// units := [ ] ;
23075: LD_ADDR_VAR 0 3
23079: PUSH
23080: EMPTY
23081: ST_TO_ADDR
// vc_control := control_manual ;
23082: LD_ADDR_OWVAR 38
23086: PUSH
23087: LD_INT 1
23089: ST_TO_ADDR
// vc_engine := engine_combustion ;
23090: LD_ADDR_OWVAR 39
23094: PUSH
23095: LD_INT 1
23097: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23098: LD_ADDR_OWVAR 41
23102: PUSH
23103: LD_INT 75
23105: ST_TO_ADDR
// case i of mhmg :
23106: LD_VAR 0 4
23110: PUSH
23111: LD_EXP 9
23115: DOUBLE
23116: EQUAL
23117: IFTRUE 23121
23119: GO 23140
23121: POP
// begin vc_chassis := ru_medium_tracked ;
23122: LD_ADDR_OWVAR 37
23126: PUSH
23127: LD_INT 22
23129: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23130: LD_ADDR_OWVAR 40
23134: PUSH
23135: LD_INT 42
23137: ST_TO_ADDR
// end ; mgg :
23138: GO 23315
23140: LD_EXP 10
23144: DOUBLE
23145: EQUAL
23146: IFTRUE 23150
23148: GO 23169
23150: POP
// begin vc_chassis := ru_medium_tracked ;
23151: LD_ADDR_OWVAR 37
23155: PUSH
23156: LD_INT 22
23158: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23159: LD_ADDR_OWVAR 40
23163: PUSH
23164: LD_INT 43
23166: ST_TO_ADDR
// end ; mg :
23167: GO 23315
23169: LD_EXP 11
23173: DOUBLE
23174: EQUAL
23175: IFTRUE 23179
23177: GO 23198
23179: POP
// begin vc_chassis := ru_medium_tracked ;
23180: LD_ADDR_OWVAR 37
23184: PUSH
23185: LD_INT 22
23187: ST_TO_ADDR
// vc_weapon := ru_gun ;
23188: LD_ADDR_OWVAR 40
23192: PUSH
23193: LD_INT 44
23195: ST_TO_ADDR
// end ; mrl :
23196: GO 23315
23198: LD_EXP 12
23202: DOUBLE
23203: EQUAL
23204: IFTRUE 23208
23206: GO 23227
23208: POP
// begin vc_chassis := ru_medium_tracked ;
23209: LD_ADDR_OWVAR 37
23213: PUSH
23214: LD_INT 22
23216: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23217: LD_ADDR_OWVAR 40
23221: PUSH
23222: LD_INT 45
23224: ST_TO_ADDR
// end ; hgg :
23225: GO 23315
23227: LD_EXP 13
23231: DOUBLE
23232: EQUAL
23233: IFTRUE 23237
23235: GO 23256
23237: POP
// begin vc_chassis := ru_heavy_tracked ;
23238: LD_ADDR_OWVAR 37
23242: PUSH
23243: LD_INT 24
23245: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23246: LD_ADDR_OWVAR 40
23250: PUSH
23251: LD_INT 43
23253: ST_TO_ADDR
// end ; hrl :
23254: GO 23315
23256: LD_EXP 14
23260: DOUBLE
23261: EQUAL
23262: IFTRUE 23266
23264: GO 23285
23266: POP
// begin vc_chassis := ru_heavy_tracked ;
23267: LD_ADDR_OWVAR 37
23271: PUSH
23272: LD_INT 24
23274: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23275: LD_ADDR_OWVAR 40
23279: PUSH
23280: LD_INT 45
23282: ST_TO_ADDR
// end ; hhg :
23283: GO 23315
23285: LD_EXP 15
23289: DOUBLE
23290: EQUAL
23291: IFTRUE 23295
23293: GO 23314
23295: POP
// begin vc_chassis := ru_heavy_tracked ;
23296: LD_ADDR_OWVAR 37
23300: PUSH
23301: LD_INT 24
23303: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23304: LD_ADDR_OWVAR 40
23308: PUSH
23309: LD_INT 46
23311: ST_TO_ADDR
// end ; end ;
23312: GO 23315
23314: POP
// units := units ^ CreateVehicle ;
23315: LD_ADDR_VAR 0 3
23319: PUSH
23320: LD_VAR 0 3
23324: PUSH
23325: CALL_OW 45
23329: ADD
23330: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23331: LD_INT 7
23333: PPUSH
23334: CALL_OW 67
// end ;
23338: GO 23046
23340: POP
23341: POP
// result := units ;
23342: LD_ADDR_VAR 0 2
23346: PUSH
23347: LD_VAR 0 3
23351: ST_TO_ADDR
// end ;
23352: LD_VAR 0 2
23356: RET
// function CreateVC ( list ) ; var units , i ; begin
23357: LD_INT 0
23359: PPUSH
23360: PPUSH
23361: PPUSH
// units := [ ] ;
23362: LD_ADDR_VAR 0 3
23366: PUSH
23367: EMPTY
23368: ST_TO_ADDR
// for i in list do
23369: LD_ADDR_VAR 0 4
23373: PUSH
23374: LD_VAR 0 1
23378: PUSH
23379: FOR_IN
23380: IFFALSE 23670
// begin InitUc ;
23382: CALL_OW 18
// InitHc ;
23386: CALL_OW 19
// InitVc ;
23390: CALL_OW 20
// uc_nation := nation_russian ;
23394: LD_ADDR_OWVAR 21
23398: PUSH
23399: LD_INT 3
23401: ST_TO_ADDR
// uc_side := russians ;
23402: LD_ADDR_OWVAR 20
23406: PUSH
23407: LD_EXP 49
23411: ST_TO_ADDR
// vc_control := control_computer ;
23412: LD_ADDR_OWVAR 38
23416: PUSH
23417: LD_INT 3
23419: ST_TO_ADDR
// vc_engine := engine_combustion ;
23420: LD_ADDR_OWVAR 39
23424: PUSH
23425: LD_INT 1
23427: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23428: LD_ADDR_OWVAR 41
23432: PUSH
23433: LD_INT 75
23435: ST_TO_ADDR
// case i of mhmg :
23436: LD_VAR 0 4
23440: PUSH
23441: LD_EXP 9
23445: DOUBLE
23446: EQUAL
23447: IFTRUE 23451
23449: GO 23470
23451: POP
// begin vc_chassis := ru_medium_tracked ;
23452: LD_ADDR_OWVAR 37
23456: PUSH
23457: LD_INT 22
23459: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23460: LD_ADDR_OWVAR 40
23464: PUSH
23465: LD_INT 42
23467: ST_TO_ADDR
// end ; mgg :
23468: GO 23645
23470: LD_EXP 10
23474: DOUBLE
23475: EQUAL
23476: IFTRUE 23480
23478: GO 23499
23480: POP
// begin vc_chassis := ru_medium_tracked ;
23481: LD_ADDR_OWVAR 37
23485: PUSH
23486: LD_INT 22
23488: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23489: LD_ADDR_OWVAR 40
23493: PUSH
23494: LD_INT 43
23496: ST_TO_ADDR
// end ; mg :
23497: GO 23645
23499: LD_EXP 11
23503: DOUBLE
23504: EQUAL
23505: IFTRUE 23509
23507: GO 23528
23509: POP
// begin vc_chassis := ru_medium_tracked ;
23510: LD_ADDR_OWVAR 37
23514: PUSH
23515: LD_INT 22
23517: ST_TO_ADDR
// vc_weapon := ru_gun ;
23518: LD_ADDR_OWVAR 40
23522: PUSH
23523: LD_INT 44
23525: ST_TO_ADDR
// end ; mrl :
23526: GO 23645
23528: LD_EXP 12
23532: DOUBLE
23533: EQUAL
23534: IFTRUE 23538
23536: GO 23557
23538: POP
// begin vc_chassis := ru_medium_tracked ;
23539: LD_ADDR_OWVAR 37
23543: PUSH
23544: LD_INT 22
23546: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23547: LD_ADDR_OWVAR 40
23551: PUSH
23552: LD_INT 45
23554: ST_TO_ADDR
// end ; hgg :
23555: GO 23645
23557: LD_EXP 13
23561: DOUBLE
23562: EQUAL
23563: IFTRUE 23567
23565: GO 23586
23567: POP
// begin vc_chassis := ru_heavy_tracked ;
23568: LD_ADDR_OWVAR 37
23572: PUSH
23573: LD_INT 24
23575: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23576: LD_ADDR_OWVAR 40
23580: PUSH
23581: LD_INT 43
23583: ST_TO_ADDR
// end ; hrl :
23584: GO 23645
23586: LD_EXP 14
23590: DOUBLE
23591: EQUAL
23592: IFTRUE 23596
23594: GO 23615
23596: POP
// begin vc_chassis := ru_heavy_tracked ;
23597: LD_ADDR_OWVAR 37
23601: PUSH
23602: LD_INT 24
23604: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23605: LD_ADDR_OWVAR 40
23609: PUSH
23610: LD_INT 45
23612: ST_TO_ADDR
// end ; hhg :
23613: GO 23645
23615: LD_EXP 15
23619: DOUBLE
23620: EQUAL
23621: IFTRUE 23625
23623: GO 23644
23625: POP
// begin vc_chassis := ru_heavy_tracked ;
23626: LD_ADDR_OWVAR 37
23630: PUSH
23631: LD_INT 24
23633: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23634: LD_ADDR_OWVAR 40
23638: PUSH
23639: LD_INT 46
23641: ST_TO_ADDR
// end ; end ;
23642: GO 23645
23644: POP
// units := units ^ CreateVehicle ;
23645: LD_ADDR_VAR 0 3
23649: PUSH
23650: LD_VAR 0 3
23654: PUSH
23655: CALL_OW 45
23659: ADD
23660: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23661: LD_INT 7
23663: PPUSH
23664: CALL_OW 67
// end ;
23668: GO 23379
23670: POP
23671: POP
// result := units ;
23672: LD_ADDR_VAR 0 2
23676: PUSH
23677: LD_VAR 0 3
23681: ST_TO_ADDR
// end ;
23682: LD_VAR 0 2
23686: RET
// function MyPlaceUnitArea ( un , ar , bordr ) ; var h , r ; begin
23687: LD_INT 0
23689: PPUSH
23690: PPUSH
23691: PPUSH
// case ar of rus_mat_l :
23692: LD_VAR 0 2
23696: PUSH
23697: LD_INT 3
23699: DOUBLE
23700: EQUAL
23701: IFTRUE 23705
23703: GO 23723
23705: POP
// h := [ 61 , 119 ] ; rus_mat_m :
23706: LD_ADDR_VAR 0 5
23710: PUSH
23711: LD_INT 61
23713: PUSH
23714: LD_INT 119
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: ST_TO_ADDR
23721: GO 23802
23723: LD_INT 2
23725: DOUBLE
23726: EQUAL
23727: IFTRUE 23731
23729: GO 23749
23731: POP
// h := [ 99 , 148 ] ; rus_mat_r :
23732: LD_ADDR_VAR 0 5
23736: PUSH
23737: LD_INT 99
23739: PUSH
23740: LD_INT 148
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: ST_TO_ADDR
23747: GO 23802
23749: LD_INT 15
23751: DOUBLE
23752: EQUAL
23753: IFTRUE 23757
23755: GO 23775
23757: POP
// h := [ 137 , 148 ] ; rus_mat_t :
23758: LD_ADDR_VAR 0 5
23762: PUSH
23763: LD_INT 137
23765: PUSH
23766: LD_INT 148
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: ST_TO_ADDR
23773: GO 23802
23775: LD_INT 14
23777: DOUBLE
23778: EQUAL
23779: IFTRUE 23783
23781: GO 23801
23783: POP
// h := [ 112 , 87 ] ; end ;
23784: LD_ADDR_VAR 0 5
23788: PUSH
23789: LD_INT 112
23791: PUSH
23792: LD_INT 87
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: ST_TO_ADDR
23799: GO 23802
23801: POP
// r := PlaceUnitArea ( un , ar , bordr ) ;
23802: LD_ADDR_VAR 0 6
23806: PUSH
23807: LD_VAR 0 1
23811: PPUSH
23812: LD_VAR 0 2
23816: PPUSH
23817: LD_VAR 0 3
23821: PPUSH
23822: CALL_OW 49
23826: ST_TO_ADDR
// if not r then
23827: LD_VAR 0 6
23831: NOT
23832: IFFALSE 23875
// r := PlaceUnitXYR ( un , h [ 1 ] , h [ 2 ] , 20 , bordr ) ;
23834: LD_ADDR_VAR 0 6
23838: PUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: LD_VAR 0 5
23848: PUSH
23849: LD_INT 1
23851: ARRAY
23852: PPUSH
23853: LD_VAR 0 5
23857: PUSH
23858: LD_INT 2
23860: ARRAY
23861: PPUSH
23862: LD_INT 20
23864: PPUSH
23865: LD_VAR 0 3
23869: PPUSH
23870: CALL_OW 50
23874: ST_TO_ADDR
// result := r ;
23875: LD_ADDR_VAR 0 4
23879: PUSH
23880: LD_VAR 0 6
23884: ST_TO_ADDR
// end ; end_of_file
23885: LD_VAR 0 4
23889: RET
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = russians then
23890: LD_VAR 0 1
23894: PPUSH
23895: CALL_OW 255
23899: PUSH
23900: LD_EXP 49
23904: EQUAL
23905: IFFALSE 23919
// ComMoveToArea ( un , before_base ) ;
23907: LD_VAR 0 1
23911: PPUSH
23912: LD_INT 23
23914: PPUSH
23915: CALL_OW 113
// end ;
23919: PPOPN 1
23921: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = russians and GetType ( un ) = unit_human then
23922: LD_VAR 0 1
23926: PPUSH
23927: CALL_OW 255
23931: PUSH
23932: LD_EXP 49
23936: EQUAL
23937: PUSH
23938: LD_VAR 0 1
23942: PPUSH
23943: CALL_OW 247
23947: PUSH
23948: LD_INT 1
23950: EQUAL
23951: AND
23952: IFFALSE 23966
// begin ComMoveToArea ( un , border ) ;
23954: LD_VAR 0 1
23958: PPUSH
23959: LD_INT 28
23961: PPUSH
23962: CALL_OW 113
// end ; end ;
23966: PPOPN 1
23968: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin end ;
23969: PPOPN 4
23971: END
// on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) then
23972: LD_VAR 0 1
23976: PPUSH
23977: LD_INT 30
23979: PUSH
23980: LD_INT 4
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: PUSH
23987: LD_INT 23
23989: PUSH
23990: LD_INT 2
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: PPUSH
24001: CALL_OW 72
24005: IFFALSE 24015
// ArmBuild := true ;
24007: LD_ADDR_EXP 71
24011: PUSH
24012: LD_INT 1
24014: ST_TO_ADDR
// if IsDead ( rudepot1 ) and IsInArea ( build , base ) and GetBType ( build ) = b_depot then
24015: LD_EXP 67
24019: PPUSH
24020: CALL_OW 301
24024: PUSH
24025: LD_VAR 0 1
24029: PPUSH
24030: LD_INT 1
24032: PPUSH
24033: CALL_OW 308
24037: AND
24038: PUSH
24039: LD_VAR 0 1
24043: PPUSH
24044: CALL_OW 266
24048: PUSH
24049: LD_INT 0
24051: EQUAL
24052: AND
24053: IFFALSE 24065
// rudepot1 := build ;
24055: LD_ADDR_EXP 67
24059: PUSH
24060: LD_VAR 0 1
24064: ST_TO_ADDR
// if IsInArea ( build , base ) and GetBType ( build ) = b_siberite_mine then
24065: LD_VAR 0 1
24069: PPUSH
24070: LD_INT 1
24072: PPUSH
24073: CALL_OW 308
24077: PUSH
24078: LD_VAR 0 1
24082: PPUSH
24083: CALL_OW 266
24087: PUSH
24088: LD_INT 30
24090: EQUAL
24091: AND
24092: IFFALSE 24104
// rumine1 := build ;
24094: LD_ADDR_EXP 68
24098: PUSH
24099: LD_VAR 0 1
24103: ST_TO_ADDR
// if IsDead ( depot1 ) and IsInArea ( build , top_half ) and GetBType ( build ) = b_depot then
24104: LD_EXP 69
24108: PPUSH
24109: CALL_OW 301
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 6
24121: PPUSH
24122: CALL_OW 308
24126: AND
24127: PUSH
24128: LD_VAR 0 1
24132: PPUSH
24133: CALL_OW 266
24137: PUSH
24138: LD_INT 0
24140: EQUAL
24141: AND
24142: IFFALSE 24154
// depot1 := build ;
24144: LD_ADDR_EXP 69
24148: PUSH
24149: LD_VAR 0 1
24153: ST_TO_ADDR
// if GetBType ( build ) = b_workshop then
24154: LD_VAR 0 1
24158: PPUSH
24159: CALL_OW 266
24163: PUSH
24164: LD_INT 2
24166: EQUAL
24167: IFFALSE 24176
// MyHint ( Tracks ) ;
24169: LD_STRING Tracks
24171: PPUSH
24172: CALL 14075 0 1
// end ;
24176: PPOPN 1
24178: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) then
24179: LD_VAR 0 1
24183: PPUSH
24184: LD_INT 30
24186: PUSH
24187: LD_INT 5
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: PUSH
24194: LD_INT 23
24196: PUSH
24197: LD_INT 2
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: PUSH
24204: EMPTY
24205: LIST
24206: LIST
24207: PPUSH
24208: CALL_OW 72
24212: IFFALSE 24229
// begin ArmUpgraded := true ;
24214: LD_ADDR_EXP 72
24218: PUSH
24219: LD_INT 1
24221: ST_TO_ADDR
// MyHint ( MortarMen ) ;
24222: LD_STRING MortarMen
24224: PPUSH
24225: CALL 14075 0 1
// end ; end ;
24229: PPOPN 1
24231: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibDet then
24232: LD_VAR 0 1
24236: PUSH
24237: LD_INT 20
24239: EQUAL
24240: IFFALSE 24313
// begin if SayAny ( all_units , D13-Sci1-1 , you , 0 , class_scientistic , 0 ) then
24242: LD_OWVAR 3
24246: PPUSH
24247: LD_STRING D13-Sci1-1
24249: PPUSH
24250: LD_EXP 47
24254: PPUSH
24255: LD_INT 0
24257: PPUSH
24258: LD_INT 4
24260: PPUSH
24261: LD_INT 0
24263: PPUSH
24264: CALL 12924 0 6
24268: IFFALSE 24310
// if Say ( JMM , D13-JMM-1 ) then
24270: LD_EXP 17
24274: PPUSH
24275: LD_STRING D13-JMM-1
24277: PPUSH
24278: CALL_OW 88
24282: IFFALSE 24310
// SayAny ( all_units , D13-Sci1-2 , you , 0 , class_scientistic , 0 ) ;
24284: LD_OWVAR 3
24288: PPUSH
24289: LD_STRING D13-Sci1-2
24291: PPUSH
24292: LD_EXP 47
24296: PPUSH
24297: LD_INT 0
24299: PPUSH
24300: LD_INT 4
24302: PPUSH
24303: LD_INT 0
24305: PPUSH
24306: CALL 12924 0 6
// disable ( 20 ) ;
24310: LD_INT 20
24312: DISABLE_MARKED
// end ; end ;
24313: PPOPN 2
24315: END
// on BuildingCaptured ( build , origside , eng ) do begin if not byld2a and origside = you2 then
24316: LD_EXP 73
24320: NOT
24321: PUSH
24322: LD_VAR 0 2
24326: PUSH
24327: LD_EXP 48
24331: EQUAL
24332: AND
24333: IFFALSE 24339
// dialog2a ;
24335: CALL 3411 0 0
// if EndEnable and ( build = rudepot1 ) and origside = you then
24339: LD_EXP 80
24343: PUSH
24344: LD_VAR 0 1
24348: PUSH
24349: LD_EXP 67
24353: EQUAL
24354: AND
24355: PUSH
24356: LD_VAR 0 2
24360: PUSH
24361: LD_EXP 47
24365: EQUAL
24366: AND
24367: IFFALSE 24411
// begin TimerEnable := true ;
24369: LD_ADDR_EXP 63
24373: PUSH
24374: LD_INT 1
24376: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
24377: LD_ADDR_EXP 81
24381: PUSH
24382: LD_EXP 49
24386: PPUSH
24387: CALL_OW 462
24391: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
24392: LD_EXP 67
24396: PPUSH
24397: CALL_OW 274
24401: PPUSH
24402: LD_EXP 49
24406: PPUSH
24407: CALL_OW 236
// end ; end ;
24411: PPOPN 3
24413: END
// on UnitDestroyed ( un ) do begin if un = JMM then
24414: LD_VAR 0 1
24418: PUSH
24419: LD_EXP 17
24423: EQUAL
24424: IFFALSE 24436
// begin disable ( 0 ) ;
24426: LD_INT 0
24428: DISABLE_MARKED
// YouLost ( JMM ) ;
24429: LD_STRING JMM
24431: PPUSH
24432: CALL_OW 104
// end ; end ;
24436: PPOPN 1
24438: END
// on SailEvent ( num ) do begin if ( num div 1000 ) = 1 then
24439: LD_VAR 0 1
24443: PUSH
24444: LD_INT 1000
24446: DIV
24447: PUSH
24448: LD_INT 1
24450: EQUAL
24451: IFFALSE 24466
// rep_car ( num - 1000 ) ;
24453: LD_VAR 0 1
24457: PUSH
24458: LD_INT 1000
24460: MINUS
24461: PPUSH
24462: CALL 14286 0 1
// if ( num div 1000 ) = 2 then
24466: LD_VAR 0 1
24470: PUSH
24471: LD_INT 1000
24473: DIV
24474: PUSH
24475: LD_INT 2
24477: EQUAL
24478: IFFALSE 24493
// ret_car ( num - 2000 ) ;
24480: LD_VAR 0 1
24484: PUSH
24485: LD_INT 2000
24487: MINUS
24488: PPUSH
24489: CALL 14465 0 1
// case num of 1 :
24493: LD_VAR 0 1
24497: PUSH
24498: LD_INT 1
24500: DOUBLE
24501: EQUAL
24502: IFTRUE 24506
24504: GO 24539
24506: POP
// begin using1 := true ;
24507: LD_ADDR_EXP 83
24511: PUSH
24512: LD_INT 1
24514: ST_TO_ADDR
// Attack ( kdo1 , path1 ) ;
24515: LD_EXP 91
24519: PPUSH
24520: LD_EXP 87
24524: PPUSH
24525: CALL 13405 0 2
// using1 := false ;
24529: LD_ADDR_EXP 83
24533: PUSH
24534: LD_INT 0
24536: ST_TO_ADDR
// end ; 2 :
24537: GO 24834
24539: LD_INT 2
24541: DOUBLE
24542: EQUAL
24543: IFTRUE 24547
24545: GO 24580
24547: POP
// begin using2 := true ;
24548: LD_ADDR_EXP 84
24552: PUSH
24553: LD_INT 1
24555: ST_TO_ADDR
// Attack ( kdo2 , path2 ) ;
24556: LD_EXP 92
24560: PPUSH
24561: LD_EXP 88
24565: PPUSH
24566: CALL 13405 0 2
// using2 := false ;
24570: LD_ADDR_EXP 84
24574: PUSH
24575: LD_INT 0
24577: ST_TO_ADDR
// end ; 3 :
24578: GO 24834
24580: LD_INT 3
24582: DOUBLE
24583: EQUAL
24584: IFTRUE 24588
24586: GO 24621
24588: POP
// begin using3 := true ;
24589: LD_ADDR_EXP 85
24593: PUSH
24594: LD_INT 1
24596: ST_TO_ADDR
// Attack ( kdo3 , path3 ) ;
24597: LD_EXP 93
24601: PPUSH
24602: LD_EXP 89
24606: PPUSH
24607: CALL 13405 0 2
// using3 := false ;
24611: LD_ADDR_EXP 85
24615: PUSH
24616: LD_INT 0
24618: ST_TO_ADDR
// end ; 4 :
24619: GO 24834
24621: LD_INT 4
24623: DOUBLE
24624: EQUAL
24625: IFTRUE 24629
24627: GO 24662
24629: POP
// begin using4 := true ;
24630: LD_ADDR_EXP 94
24634: PUSH
24635: LD_INT 1
24637: ST_TO_ADDR
// Attack ( kdo4 , path4 ) ;
24638: LD_EXP 102
24642: PPUSH
24643: LD_EXP 98
24647: PPUSH
24648: CALL 13405 0 2
// using4 := false ;
24652: LD_ADDR_EXP 94
24656: PUSH
24657: LD_INT 0
24659: ST_TO_ADDR
// end ; 5 :
24660: GO 24834
24662: LD_INT 5
24664: DOUBLE
24665: EQUAL
24666: IFTRUE 24670
24668: GO 24703
24670: POP
// begin using5 := true ;
24671: LD_ADDR_EXP 95
24675: PUSH
24676: LD_INT 1
24678: ST_TO_ADDR
// Attack ( kdo5 , path5 ) ;
24679: LD_EXP 103
24683: PPUSH
24684: LD_EXP 99
24688: PPUSH
24689: CALL 13405 0 2
// using5 := false ;
24693: LD_ADDR_EXP 95
24697: PUSH
24698: LD_INT 0
24700: ST_TO_ADDR
// end ; 6 :
24701: GO 24834
24703: LD_INT 6
24705: DOUBLE
24706: EQUAL
24707: IFTRUE 24711
24709: GO 24744
24711: POP
// begin using6 := true ;
24712: LD_ADDR_EXP 96
24716: PUSH
24717: LD_INT 1
24719: ST_TO_ADDR
// Attack ( kdo6 , path6 ) ;
24720: LD_EXP 104
24724: PPUSH
24725: LD_EXP 100
24729: PPUSH
24730: CALL 13405 0 2
// using6 := false ;
24734: LD_ADDR_EXP 96
24738: PUSH
24739: LD_INT 0
24741: ST_TO_ADDR
// end ; 7 :
24742: GO 24834
24744: LD_INT 7
24746: DOUBLE
24747: EQUAL
24748: IFTRUE 24752
24750: GO 24785
24752: POP
// begin using7 := true ;
24753: LD_ADDR_EXP 97
24757: PUSH
24758: LD_INT 1
24760: ST_TO_ADDR
// Attack ( kdo7 , path7 ) ;
24761: LD_EXP 105
24765: PPUSH
24766: LD_EXP 101
24770: PPUSH
24771: CALL 13405 0 2
// using7 := false ;
24775: LD_ADDR_EXP 97
24779: PUSH
24780: LD_INT 0
24782: ST_TO_ADDR
// end ; 8 :
24783: GO 24834
24785: LD_INT 8
24787: DOUBLE
24788: EQUAL
24789: IFTRUE 24793
24791: GO 24826
24793: POP
// begin using8 := true ;
24794: LD_ADDR_EXP 82
24798: PUSH
24799: LD_INT 1
24801: ST_TO_ADDR
// Attack ( kdo8 , path8 ) ;
24802: LD_EXP 90
24806: PPUSH
24807: LD_EXP 86
24811: PPUSH
24812: CALL 13405 0 2
// using8 := false ;
24816: LD_ADDR_EXP 82
24820: PUSH
24821: LD_INT 0
24823: ST_TO_ADDR
// end ; else
24824: GO 24834
24826: POP
// Msg ( neni thread na utok ) ; end ;
24827: LD_STRING neni thread na utok
24829: PPUSH
24830: CALL_OW 100
// end ;
24834: PPOPN 1
24836: END
// on BuildingStarted ( b , hum ) do begin if hum = ara2 then
24837: LD_VAR 0 2
24841: PUSH
24842: LD_EXP 40
24846: EQUAL
24847: IFFALSE 24872
// if GetBType ( b ) = b_armoury then
24849: LD_VAR 0 1
24853: PPUSH
24854: CALL_OW 266
24858: PUSH
24859: LD_INT 4
24861: EQUAL
24862: IFFALSE 24872
// ArmStarted := true ;
24864: LD_ADDR_EXP 74
24868: PUSH
24869: LD_INT 1
24871: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
24872: LD_VAR 0 1
24876: PPUSH
24877: CALL_OW 266
24881: PUSH
24882: LD_INT 4
24884: EQUAL
24885: IFFALSE 24895
// BarStarted := true ;
24887: LD_ADDR_EXP 75
24891: PUSH
24892: LD_INT 1
24894: ST_TO_ADDR
// end ;
24895: PPOPN 2
24897: END
// on EndTheMissionRaised ( a ) do begin Vyhra ;
24898: CALL 2796 0 0
// end ; end_of_file
24902: PPOPN 1
24904: END
// var objevovani_zasilek ; every 0 0$0.1 do
24905: GO 24907
24907: DISABLE
// begin objevovani_zasilek := [ 1 , 0 , 2 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ] ;
24908: LD_ADDR_LOC 3
24912: PUSH
24913: LD_INT 1
24915: PUSH
24916: LD_INT 0
24918: PUSH
24919: LD_INT 2
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: LD_INT 1
24927: PUSH
24928: LD_INT 0
24930: PUSH
24931: LD_INT 0
24933: PUSH
24934: LD_INT 1
24936: PUSH
24937: LD_INT 0
24939: PUSH
24940: LD_INT 0
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: LIST
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: ST_TO_ADDR
// Randomize ;
24955: CALL_OW 10
// end ;
24959: END
// every 0 0$10 do
24960: GO 24962
24962: DISABLE
// begin Randomize ;
24963: CALL_OW 10
// enable ;
24967: ENABLE
// end ;
24968: END
// every 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
24969: GO 24971
24971: DISABLE
24972: LD_INT 0
24974: PPUSH
24975: PPUSH
24976: PPUSH
24977: PPUSH
24978: PPUSH
24979: PPUSH
24980: PPUSH
24981: PPUSH
// begin min5 := 1 ;
24982: LD_ADDR_VAR 0 8
24986: PUSH
24987: LD_INT 1
24989: ST_TO_ADDR
// cek := [ ] ;
24990: LD_ADDR_VAR 0 5
24994: PUSH
24995: EMPTY
24996: ST_TO_ADDR
// cek2 := [ ] ;
24997: LD_ADDR_VAR 0 6
25001: PUSH
25002: EMPTY
25003: ST_TO_ADDR
// last := 0 ;
25004: LD_ADDR_VAR 0 7
25008: PUSH
25009: LD_INT 0
25011: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25012: LD_ADDR_VAR 0 1
25016: PUSH
25017: LD_LOC 3
25021: PUSH
25022: LD_VAR 0 8
25026: ARRAY
25027: ST_TO_ADDR
// for i := 1 to x do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_VAR 0 1
25042: PUSH
25043: FOR_TO
25044: IFFALSE 25070
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25046: LD_ADDR_VAR 0 5
25050: PUSH
25051: LD_VAR 0 5
25055: PUSH
25056: LD_INT 525
25058: PPUSH
25059: LD_INT 10500
25061: PPUSH
25062: CALL_OW 12
25066: ADD
25067: ST_TO_ADDR
25068: GO 25043
25070: POP
25071: POP
// cek := SortListByListAsc ( cek , cek ) ;
25072: LD_ADDR_VAR 0 5
25076: PUSH
25077: LD_VAR 0 5
25081: PPUSH
25082: LD_VAR 0 5
25086: PPUSH
25087: CALL_OW 76
25091: ST_TO_ADDR
// for i in cek do
25092: LD_ADDR_VAR 0 3
25096: PUSH
25097: LD_VAR 0 5
25101: PUSH
25102: FOR_IN
25103: IFFALSE 25139
// begin cek2 := cek2 ^ i - last ;
25105: LD_ADDR_VAR 0 6
25109: PUSH
25110: LD_VAR 0 6
25114: PUSH
25115: LD_VAR 0 3
25119: PUSH
25120: LD_VAR 0 7
25124: MINUS
25125: ADD
25126: ST_TO_ADDR
// last := i ;
25127: LD_ADDR_VAR 0 7
25131: PUSH
25132: LD_VAR 0 3
25136: ST_TO_ADDR
// end ;
25137: GO 25102
25139: POP
25140: POP
// for i := 1 to x do
25141: LD_ADDR_VAR 0 3
25145: PUSH
25146: DOUBLE
25147: LD_INT 1
25149: DEC
25150: ST_TO_ADDR
25151: LD_VAR 0 1
25155: PUSH
25156: FOR_TO
25157: IFFALSE 25186
// begin CreateCratesAnywhere ( 5 , true ) ;
25159: LD_INT 5
25161: PPUSH
25162: LD_INT 1
25164: PPUSH
25165: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25169: LD_VAR 0 6
25173: PUSH
25174: LD_VAR 0 3
25178: ARRAY
25179: PPUSH
25180: CALL_OW 67
// end ;
25184: GO 25156
25186: POP
25187: POP
// end ;
25188: PPOPN 8
25190: END
// every 5 5$0 + 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25191: GO 25193
25193: DISABLE
25194: LD_INT 0
25196: PPUSH
25197: PPUSH
25198: PPUSH
25199: PPUSH
25200: PPUSH
25201: PPUSH
25202: PPUSH
25203: PPUSH
// begin min5 := tick div 5 5$0 ;
25204: LD_ADDR_VAR 0 8
25208: PUSH
25209: LD_OWVAR 1
25213: PUSH
25214: LD_INT 10500
25216: DIV
25217: ST_TO_ADDR
// cek := [ ] ;
25218: LD_ADDR_VAR 0 5
25222: PUSH
25223: EMPTY
25224: ST_TO_ADDR
// cek2 := [ ] ;
25225: LD_ADDR_VAR 0 6
25229: PUSH
25230: EMPTY
25231: ST_TO_ADDR
// last := 0 ;
25232: LD_ADDR_VAR 0 7
25236: PUSH
25237: LD_INT 0
25239: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25240: LD_ADDR_VAR 0 1
25244: PUSH
25245: LD_LOC 3
25249: PUSH
25250: LD_VAR 0 8
25254: ARRAY
25255: ST_TO_ADDR
// for i := 1 to x do
25256: LD_ADDR_VAR 0 3
25260: PUSH
25261: DOUBLE
25262: LD_INT 1
25264: DEC
25265: ST_TO_ADDR
25266: LD_VAR 0 1
25270: PUSH
25271: FOR_TO
25272: IFFALSE 25298
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25274: LD_ADDR_VAR 0 5
25278: PUSH
25279: LD_VAR 0 5
25283: PUSH
25284: LD_INT 525
25286: PPUSH
25287: LD_INT 10500
25289: PPUSH
25290: CALL_OW 12
25294: ADD
25295: ST_TO_ADDR
25296: GO 25271
25298: POP
25299: POP
// cek := SortListByListAsc ( cek , cek ) ;
25300: LD_ADDR_VAR 0 5
25304: PUSH
25305: LD_VAR 0 5
25309: PPUSH
25310: LD_VAR 0 5
25314: PPUSH
25315: CALL_OW 76
25319: ST_TO_ADDR
// for i in cek do
25320: LD_ADDR_VAR 0 3
25324: PUSH
25325: LD_VAR 0 5
25329: PUSH
25330: FOR_IN
25331: IFFALSE 25367
// begin cek2 := cek2 ^ i - last ;
25333: LD_ADDR_VAR 0 6
25337: PUSH
25338: LD_VAR 0 6
25342: PUSH
25343: LD_VAR 0 3
25347: PUSH
25348: LD_VAR 0 7
25352: MINUS
25353: ADD
25354: ST_TO_ADDR
// last := i ;
25355: LD_ADDR_VAR 0 7
25359: PUSH
25360: LD_VAR 0 3
25364: ST_TO_ADDR
// end ;
25365: GO 25330
25367: POP
25368: POP
// for i := 1 to x do
25369: LD_ADDR_VAR 0 3
25373: PUSH
25374: DOUBLE
25375: LD_INT 1
25377: DEC
25378: ST_TO_ADDR
25379: LD_VAR 0 1
25383: PUSH
25384: FOR_TO
25385: IFFALSE 25414
// begin CreateCratesAnywhere ( 5 , true ) ;
25387: LD_INT 5
25389: PPUSH
25390: LD_INT 1
25392: PPUSH
25393: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25397: LD_VAR 0 6
25401: PUSH
25402: LD_VAR 0 3
25406: ARRAY
25407: PPUSH
25408: CALL_OW 67
// end ;
25412: GO 25384
25414: POP
25415: POP
// if min5 < 10 then
25416: LD_VAR 0 8
25420: PUSH
25421: LD_INT 10
25423: LESS
25424: IFFALSE 25427
// enable ;
25426: ENABLE
// end ;
25427: PPOPN 8
25429: END
